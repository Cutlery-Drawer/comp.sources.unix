Path: uunet!rs
From: rs@uunet.UU.NET (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v10i071:  Pascal to C translator, Part07/12
Message-ID: <722@uunet.UU.NET>
Date: 28 Jul 87 19:35:56 GMT
Organization: UUNET Communications Services, Arlington, VA
Lines: 1546
Approved: rs@uunet.UU.NET

Submitted-by: Per Bergsten <mcvax!enea!chalmers!holtec!perb>
Posting-number: Volume 10, Issue 71
Archive-name: ptoc/Part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 12)."
# Contents:  ptc.c.5
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ptc.c.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptc.c.5'\"
else
echo shar: Extracting \"'ptc.c.5'\" \(39665 characters\)
sed "s/^X//" >'ptc.c.5' <<'END_OF_FILE'
X void
Xeexpr(tp)
X	treeptr	tp;
X{
X	treeptr	tq;
X	boolean	flag;
X
X	(*G200_donearr) = false;
X	if (Member((unsigned)(tp->tt), Conset[144])) {
X		tq = typeof(tp->U.V41.texpl);
X		if ((Member((unsigned)(tq->tt), Conset[145])) || (tq == typnods.A[(int)(tset)])) {
X			switch (tp->tt) {
X			  case nplus:
X				(*G196_setused) = true;
X				useunion = true;
X				(void)fprintf(output.fp, "Union"), Putl(output, 0);
X				break ;
X			  case nminus:
X				(*G196_setused) = true;
X				usediff = true;
X				(void)fprintf(output.fp, "Diff"), Putl(output, 0);
X				break ;
X			  case nmul:
X				(*G196_setused) = true;
X				useintr = true;
X				(void)fprintf(output.fp, "Inter"), Putl(output, 0);
X				break ;
X			  case neq:
X				useseq = true;
X				(void)fprintf(output.fp, "Eq"), Putl(output, 0);
X				break ;
X			  case nne:
X				usesne = true;
X				(void)fprintf(output.fp, "Ne"), Putl(output, 0);
X				break ;
X			  case nge:
X				usesge = true;
X				(void)fprintf(output.fp, "Ge"), Putl(output, 0);
X				break ;
X			  case nle:
X				usesle = true;
X				(void)fprintf(output.fp, "Le"), Putl(output, 0);
X				break ;
X			  default:
X				Caseerror(Line);
X			}
X			if (Member((unsigned)(tp->tt), Conset[146]))
X				(*G198_dropset) = false;
X			Putchr('(', output);
X			eexpr(tp->U.V41.texpl);
X			if (tq->tt == nsetof)
X				(void)fprintf(output.fp, ".S"), Putl(output, 0);
X			(void)fprintf(output.fp, ", "), Putl(output, 0);
X			eexpr(tp->U.V41.texpr);
X			tq = typeof(tp->U.V41.texpr);
X			if (tq->tt == nsetof)
X				(void)fprintf(output.fp, ".S"), Putl(output, 0);
X			Putchr(')', output);
X			goto L999;
X		}
X	}
X	if (Member((unsigned)(tp->tt), Conset[147])) {
X		tq = typeof(tp->U.V41.texpl);
X		if (tq->tt == nconfarr)
X			fatal(ecmpconf);
X		if ((Member((unsigned)(tq->tt), Conset[148])) || (tq == typnods.A[(int)(tstring)])) {
X			(void)fprintf(output.fp, "Cmpstr("), Putl(output, 0);
X			eexpr(tp->U.V41.texpl);
X			if (tq->tt == narray)
X				(void)fprintf(output.fp, ".A"), Putl(output, 0);
X			(void)fprintf(output.fp, ", "), Putl(output, 0);
X			tq = typeof(tp->U.V41.texpr);
X			if (tq->tt == nconfarr)
X				fatal(ecmpconf);
X			eexpr(tp->U.V41.texpr);
X			if (tq->tt == narray)
X				(void)fprintf(output.fp, ".A"), Putl(output, 0);
X			Putchr(')', output);
X			switch (tp->tt) {
X			  case neq:
X				(void)fprintf(output.fp, " == "), Putl(output, 0);
X				break ;
X			  case nne:
X				(void)fprintf(output.fp, " != "), Putl(output, 0);
X				break ;
X			  case ngt:
X				(void)fprintf(output.fp, " > "), Putl(output, 0);
X				break ;
X			  case nlt:
X				(void)fprintf(output.fp, " < "), Putl(output, 0);
X				break ;
X			  case nge:
X				(void)fprintf(output.fp, " >= "), Putl(output, 0);
X				break ;
X			  case nle:
X				(void)fprintf(output.fp, " <= "), Putl(output, 0);
X				break ;
X			  default:
X				Caseerror(Line);
X			}
X			Putchr('0', output);
X			goto L999;
X		}
X	}
X	switch (tp->tt) {
X	  case neq:  case nne:  case nlt:  case nle:
X	  case ngt:  case nge:  case nor:  case nand:
X	  case nplus:  case nminus:  case nmul:  case ndiv:
X	  case nmod:  case nquot:
X		flag = (boolean)(cprio.A[(int)(tp->tt) - (int)(nassign)] > cprio.A[(int)(tp->U.V41.texpl->tt) - (int)(nassign)]);
X		if ((Member((unsigned)(tp->tt), Conset[149])) && !arithexpr(tp->U.V41.texpl)) {
X			(void)fprintf(output.fp, "(int)"), Putl(output, 0);
X			flag = true;
X		}
X		if (flag)
X			Putchr('(', output);
X		eexpr(tp->U.V41.texpl);
X		if (flag)
X			Putchr(')', output);
X		switch (tp->tt) {
X		  case neq:
X			(void)fprintf(output.fp, " == "), Putl(output, 0);
X			break ;
X		  case nne:
X			(void)fprintf(output.fp, " != "), Putl(output, 0);
X			break ;
X		  case nlt:
X			(void)fprintf(output.fp, " < "), Putl(output, 0);
X			break ;
X		  case nle:
X			(void)fprintf(output.fp, " <= "), Putl(output, 0);
X			break ;
X		  case ngt:
X			(void)fprintf(output.fp, " > "), Putl(output, 0);
X			break ;
X		  case nge:
X			(void)fprintf(output.fp, " >= "), Putl(output, 0);
X			break ;
X		  case nor:
X			(void)fprintf(output.fp, " || "), Putl(output, 0);
X			break ;
X		  case nand:
X			(void)fprintf(output.fp, " && "), Putl(output, 0);
X			break ;
X		  case nplus:
X			(void)fprintf(output.fp, " + "), Putl(output, 0);
X			break ;
X		  case nminus:
X			(void)fprintf(output.fp, " - "), Putl(output, 0);
X			break ;
X		  case nmul:
X			(void)fprintf(output.fp, " * "), Putl(output, 0);
X			break ;
X		  case ndiv:
X			(void)fprintf(output.fp, " / "), Putl(output, 0);
X			break ;
X		  case nmod:
X			(void)fprintf(output.fp, " %% "), Putl(output, 0);
X			break ;
X		  case nquot:
X			(void)fprintf(output.fp, " / (("), Putl(output, 0);
X			printid(defnams.A[(int)(dreal)]->U.V6.lid);
X			Putchr(')', output);
X			break ;
X		  default:
X			Caseerror(Line);
X		}
X		flag = (boolean)(cprio.A[(int)(tp->tt) - (int)(nassign)] > cprio.A[(int)(tp->U.V41.texpr->tt) - (int)(nassign)]);
X		if ((Member((unsigned)(tp->tt), Conset[150])) && !arithexpr(tp->U.V41.texpr)) {
X			(void)fprintf(output.fp, "(int)"), Putl(output, 0);
X			flag = true;
X		}
X		if (flag)
X			Putchr('(', output);
X		eexpr(tp->U.V41.texpr);
X		if (flag)
X			Putchr(')', output);
X		if (tp->tt == nquot)
X			Putchr(')', output);
X		break ;
X	  case nuplus:  case numinus:  case nnot:
X		switch (tp->tt) {
X		  case numinus:
X			Putchr('-', output);
X			break ;
X		  case nnot:
X			Putchr('!', output);
X			break ;
X		  case nuplus:
X			break ;
X		  default:
X			Caseerror(Line);
X		}
X		flag = (boolean)(cprio.A[(int)(tp->tt) - (int)(nassign)] >= cprio.A[(int)(tp->U.V42.texps->tt) - (int)(nassign)]);
X		if (flag)
X			Putchr('(', output);
X		eexpr(tp->U.V42.texps);
X		if (flag)
X			Putchr(')', output);
X		break ;
X	  case nin:
X		usememb = true;
X		(void)fprintf(output.fp, "Member((unsigned)("), Putl(output, 0);
X		eexpr(tp->U.V41.texpl);
X		(void)fprintf(output.fp, "), "), Putl(output, 0);
X		(*G198_dropset) = true;
X		eexpr(tp->U.V41.texpr);
X		(*G198_dropset) = false;
X		tq = typeof(tp->U.V41.texpr);
X		if (tq->tt == nsetof)
X			(void)fprintf(output.fp, ".S"), Putl(output, 0);
X		Putchr(')', output);
X		break ;
X	  case nassign:
X		tq = typeof(tp->U.V27.trhs);
X		if (tq == typnods.A[(int)(tstring)]) {
X			(void)fprintf(output.fp, "%sstrncpy(", voidcast), Putl(output, 0);
X			eexpr(tp->U.V27.tlhs);
X			(void)fprintf(output.fp, ".A, "), Putl(output, 0);
X			eexpr(tp->U.V27.trhs);
X			(void)fprintf(output.fp, ", sizeof("), Putl(output, 0);
X			eexpr(tp->U.V27.tlhs);
X			(void)fprintf(output.fp, ".A))"), Putl(output, 0);
X		} else
X			if (tq == typnods.A[(int)(tboolean)]) {
X				eexpr(tp->U.V27.tlhs);
X				(void)fprintf(output.fp, " = "), Putl(output, 0);
X				tq = tp->U.V27.trhs;
X				while (tq->tt == nuplus)
X					tq = tq->U.V42.texps;
X				if (Member((unsigned)(tq->tt), Conset[151])) {
X					Putchr('(', output);
X					printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X					(void)fprintf(output.fp, ")("), Putl(output, 0);
X					eexpr(tq);
X					Putchr(')', output);
X				} else
X					eexpr(tq);
X			} else
X				if (tq == typnods.A[(int)(tnil)]) {
X					eexpr(tp->U.V27.tlhs);
X					(void)fprintf(output.fp, " = ("), Putl(output, 0);
X					etypedef(typeof(tp->U.V27.tlhs));
X					(void)fprintf(output.fp, ")NIL"), Putl(output, 0);
X				} else {
X					tq = typeof(tp->U.V27.tlhs);
X					if (tq->tt == nsetof) {
X						usescpy = true;
X						(void)fprintf(output.fp, "Setncpy("), Putl(output, 0);
X						eselect(tp->U.V27.tlhs);
X						(void)fprintf(output.fp, "S, "), Putl(output, 0);
X						(*G198_dropset) = true;
X						tq = typeof(tp->U.V27.trhs);
X						if (tq == typnods.A[(int)(tset)])
X							eexpr(tp->U.V27.trhs);
X						else {
X							eselect(tp->U.V27.trhs);
X							Putchr('S', output);
X						}
X						(*G198_dropset) = false;
X						(void)fprintf(output.fp, ", sizeof("), Putl(output, 0);
X						eselect(tp->U.V27.tlhs);
X						(void)fprintf(output.fp, "S))"), Putl(output, 0);
X					} else {
X						eexpr(tp->U.V27.tlhs);
X						(void)fprintf(output.fp, " = "), Putl(output, 0);
X						eexpr(tp->U.V27.trhs);
X					}
X				}
X		break ;
X	  case ncall:
X		tq = idup(tp->U.V30.tcall);
X		if ((Member((unsigned)(tq->tt), Conset[152])) && (tq->U.V13.tsubstmt != (struct S61 *)NIL))
X			if (tq->U.V13.tsubstmt->tt == npredef)
X				epredef(tq, tp);
X			else
X				ecall(tp);
X		else
X			ecall(tp);
X		break ;
X	  case nselect:
X		eselect(tp->U.V40.trecord);
X		eexpr(tp->U.V40.tfield);
X		break ;
X	  case nindex:
X		eselect(tp->U.V39.tvariable);
X		(void)fprintf(output.fp, "A["), Putl(output, 0);
X		tq = tp->U.V39.toffset;
X		if (arithexpr(tq))
X			eexpr(tq);
X		else {
X			(void)fprintf(output.fp, "(int)("), Putl(output, 0);
X			eexpr(tq);
X			Putchr(')', output);
X		}
X		tq = typeof(tp->U.V39.tvariable);
X		if (tq->tt == narray)
X			if (clower(tq->U.V23.taindx) != 0) {
X				(void)fprintf(output.fp, " - "), Putl(output, 0);
X				tq = typeof(tq->U.V23.taindx);
X				if (tq->tt == nsubrange)
X					if (arithexpr(tq->U.V19.tlo))
X						eexpr(tq->U.V19.tlo);
X					else {
X						(void)fprintf(output.fp, "(int)("), Putl(output, 0);
X						eexpr(tq->U.V19.tlo);
X						Putchr(')', output);
X					}
X				else
X					fatal(etree);
X			}
X		Putchr(']', output);
X		break ;
X	  case nderef:
X		tq = typeof(tp->U.V42.texps);
X		if ((tq->tt == nfileof) || ((tq->tt == npredef) && (tq->U.V12.tdef == dtext))) {
X			eexpr(tp->U.V42.texps);
X			(void)fprintf(output.fp, ".buf"), Putl(output, 0);
X		} else
X			if ((*G202_doarrow) == 0) {
X				Putchr('*', output);
X				eexpr(tp->U.V42.texps);
X			} else {
X				eexpr(tp->U.V42.texps);
X				(void)fprintf(output.fp, "->"), Putl(output, 0);
X				(*G200_donearr) = true;
X			}
X		break ;
X	  case nid:
X		tq = idup(tp);
X		if (tq->tt == nvarpar) {
X			if (((*G202_doarrow) == 0) || (tq->U.V14.tattr == areference)) {
X				(void)fprintf(output.fp, "(*"), Putl(output, 0);
X				printid(tp->U.V43.tsym->U.V6.lid);
X				Putchr(')', output);
X			} else {
X				printid(tp->U.V43.tsym->U.V6.lid);
X				(void)fprintf(output.fp, "->"), Putl(output, 0);
X				(*G200_donearr) = true;
X			}
X		} else
X			if ((tq->tt == nconst) && (*G194_conflag))
X				(void)fprintf(output.fp, "%1d", cvalof(tp)), Putl(output, 0);
X			else
X				if (Member((unsigned)(tq->tt), Conset[153])) {
X					(void)fprintf(output.fp, "(*"), Putl(output, 0);
X					printid(tp->U.V43.tsym->U.V6.lid);
X					Putchr(')', output);
X				} else
X					printid(tp->U.V43.tsym->U.V6.lid);
X		break ;
X	  case nchar:
X		printchr(tp->U.V43.tsym->U.V11.lchar);
X		break ;
X	  case ninteger:
X		(void)fprintf(output.fp, "%1d", tp->U.V43.tsym->U.V10.linum), Putl(output, 0);
X		break ;
X	  case nreal:
X		printtok(tp->U.V43.tsym->U.V8.lfloat);
X		break ;
X	  case nstring:
X		printstr(tp->U.V43.tsym->U.V7.lstr);
X		break ;
X	  case nset:
X		if (constset(tp->U.V42.texps)) {
X			(void)fprintf(output.fp, "Conset[%1d]", setcnt), Putl(output, 0);
X			setcnt = setcnt + 1;
X			tq = mknode(nset);
X			tq->tnext = setlst;
X			setlst = tq;
X			tq->U.V42.texps = tp->U.V42.texps;
X		} else {
X			increment();
X			flag = (*G198_dropset);
X			if ((*G198_dropset))
X				(*G198_dropset) = false;
X			else
X				(void)fprintf(output.fp, "Saveset("), Putl(output, 0);
X			(void)fprintf(output.fp, "(Tmpset = Newset(), "), Putl(output, 0);
X			tq = tp->U.V42.texps;
X			while (tq != (struct S61 *)NIL) {
X				switch (tq->tt) {
X				  case nrange:
X					usemksub = true;
X					(void)fprintf(output.fp, "%sMksubr(", voidcast), Putl(output, 0);
X					(void)fprintf(output.fp, "(unsigned)("), Putl(output, 0);
X					eexpr(tq->U.V41.texpl);
X					(void)fprintf(output.fp, "), "), Putl(output, 0);
X					(void)fprintf(output.fp, "(unsigned)("), Putl(output, 0);
X					eexpr(tq->U.V41.texpr);
X					(void)fprintf(output.fp, "), Tmpset)"), Putl(output, 0);
X					break ;
X				  case nin:  case neq:  case nne:  case nlt:
X				  case nle:  case ngt:  case nge:  case nor:
X				  case nand:  case nmul:  case ndiv:  case nmod:
X				  case nquot:  case nplus:  case nminus:  case nnot:
X				  case numinus:  case nuplus:  case nindex:  case nselect:
X				  case nderef:  case ncall:  case ninteger:  case nchar:
X				  case nid:
X					useins = true;
X					(void)fprintf(output.fp, "%sInsmem(", voidcast), Putl(output, 0);
X					(void)fprintf(output.fp, "(unsigned)("), Putl(output, 0);
X					eexpr(tq);
X					(void)fprintf(output.fp, "), Tmpset)"), Putl(output, 0);
X					break ;
X				  default:
X					Caseerror(Line);
X				}
X				tq = tq->tnext;
X				if (tq != (struct S61 *)NIL) {
X					Putchr(',', output),Putchr('\n', output);
X					indent();
X				}
X			}
X			(void)fprintf(output.fp, ", Tmpset)"), Putl(output, 0);
X			if (!flag) {
X				Putchr(')', output);
X				(*G196_setused) = true;
X			}
X			decrement();
X		}
X		break ;
X	  case nnil:
X		tq = tp;
X		do {
X			tq = tq->tup;
X		} while (!(Member((unsigned)(tq->tt), Conset[154])));
X		if (Member((unsigned)(tq->tt), Conset[155])) {
X			if (typeof(tq->U.V41.texpl) == typnods.A[(int)(tnil)])
X				tq = typeof(tq->U.V41.texpr);
X			else
X				tq = typeof(tq->U.V41.texpl);
X			if (tq->tt == nptr) {
X				Putchr('(', output);
X				etypedef(tq);
X				Putchr(')', output);
X			}
X		}
X		(void)fprintf(output.fp, "NIL"), Putl(output, 0);
X		break ;
X	  default:
X		Caseerror(Line);
X	}
XL999:
X	;
X}
X
X void
Xeconst(tp)
X	treeptr	tp;
X{
X	symptr	sp;
X
X	while (tp != (struct S61 *)NIL) {
X		sp = tp->U.V14.tidl->U.V43.tsym;
X		if (sp->U.V6.lid->inref > 1)
X			sp->U.V6.lid = mkrename('X', sp->U.V6.lid);
X		if (tp->U.V14.tbind->tt == nstring) {
X			indent();
X			(void)fprintf(output.fp, "%s%s%c", C50_static, chartyp, tab1), Putl(output, 0);
X			printid(sp->U.V6.lid);
X			(void)fprintf(output.fp, "[]	= "), Putl(output, 0);
X			eexpr(tp->U.V14.tbind);
X			Putchr(';', output),Putchr('\n', output);
X		} else {
X			(void)fprintf(output.fp, "%s", C4_define), Putl(output, 0);
X			printid(sp->U.V6.lid);
X			Putchr(space, output);
X			eexpr(tp->U.V14.tbind);
X			Putchr('\n', output);
X		}
X		tp = tp->tnext;
X	}
X}
X
Xvoid etypedef();
X
Xvoid etdef();
X
X void
Xetrange(tp)
X	treeptr	tp;
X{
X	integer	lo, hi;
X	register unsigned char	i;
X
X	lo = clower(tp);
X	hi = cupper(tp);
X	{
X		unsigned char	B51 = 1,
X			B52 = nmachdefs;
X
X		if (B51 <= B52)
X			for (i = B51; ; i++) {
X				{
X					register struct S193 *W53 = &machdefs.A[i - 1];
X
X					if ((lo >= W53->lolim) && (hi <= W53->hilim)) {
X						printtok(W53->typstr);
X						goto L999;
X					}
X				}
X				if (i == B52) break;
X			}
X	}
X	fatal(erange);
XL999:
X	;
X}
X
X void
Xprintsuf(ip)
X	idptr	ip;
X{
X	toknbuf	w;
X	toknidx	i, j;
X
X	gettokn(ip->istr, &w);
X	i = 1;
X	j = i;
X	while (w.A[i - 1] != null) {
X		if (w.A[i - 1] == '.')
X			j = i;
X		i = i + 1;
X	}
X	if (w.A[j - 1] == '.')
X		j = j + 1;
X	while (w.A[j - 1] != null) {
X		Putchr(w.A[j - 1], output);
X		j = j + 1;
X	}
X}
X
X void
Xetdef(uid, tp)
X	idptr	uid;
X	treeptr	tp;
X{
X	integer	i;
X	treeptr	tq;
X
X	switch (tp->tt) {
X	  case nid:
X		printid(tp->U.V43.tsym->U.V6.lid);
X		break ;
X	  case nptr:
X		tq = typeof(tp->U.V16.tptrid);
X		if (tq->tt == nrecord) {
X			(void)fprintf(output.fp, "struct "), Putl(output, 0);
X			printid(tq->U.V21.tuid);
X		} else
X			printid(tp->U.V16.tptrid->U.V43.tsym->U.V6.lid);
X		(void)fprintf(output.fp, " *"), Putl(output, 0);
X		break ;
X	  case nscalar:
X		(void)fprintf(output.fp, "enum { "), Putl(output, 0);
X		increment();
X		tp = tp->U.V17.tscalid;
X		if (tp->U.V43.tsym->U.V6.lid->inref > 1)
X			tp->U.V43.tsym->U.V6.lid = mkrename('E', tp->U.V43.tsym->U.V6.lid);
X		printid(tp->U.V43.tsym->U.V6.lid);
X		i = 1;
X		while (tp->tnext != (struct S61 *)NIL) {
X			if (i >= 4) {
X				Putchr(',', output),Putchr('\n', output);
X				indent();
X				i = 1;
X			} else {
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X				i = i + 1;
X			}
X			tp = tp->tnext;
X			if (tp->U.V43.tsym->U.V6.lid->inref > 1)
X				tp->U.V43.tsym->U.V6.lid = mkrename('E', tp->U.V43.tsym->U.V6.lid);
X			printid(tp->U.V43.tsym->U.V6.lid);
X		}
X		decrement();
X		(void)fprintf(output.fp, " } "), Putl(output, 0);
X		break ;
X	  case nsubrange:
X		tq = typeof(tp->U.V19.tlo);
X		if (tq == typnods.A[(int)(tinteger)])
X			etrange(tp);
X		else {
X			if (tq->tup->tt == ntype)
X				tq = tq->tup->U.V14.tidl;
X			etdef((idptr)NIL, tq);
X		}
X		break ;
X	  case nfield:
X		etdef((idptr)NIL, tp->U.V14.tbind);
X		Putchr(tab1, output);
X		tp = tp->U.V14.tidl;
X		if (uid != (struct S59 *)NIL)
X			tp->U.V43.tsym->U.V6.lid = mkconc('.', uid, tp->U.V43.tsym->U.V6.lid);
X		printsuf(tp->U.V43.tsym->U.V6.lid);
X		i = 1;
X		while (tp->tnext != (struct S61 *)NIL) {
X			if (i >= 4) {
X				Putchr(',', output),Putchr('\n', output);
X				indent();
X				Putchr(tab1, output);
X				i = 1;
X			} else {
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X				i = i + 1;
X			}
X			tp = tp->tnext;
X			if (uid != (struct S59 *)NIL)
X				tp->U.V43.tsym->U.V6.lid = mkconc('.', uid, tp->U.V43.tsym->U.V6.lid);
X			printsuf(tp->U.V43.tsym->U.V6.lid);
X		}
X		Putchr(';', output),Putchr('\n', output);
X		break ;
X	  case nrecord:
X		(void)fprintf(output.fp, "struct "), Putl(output, 0);
X		if (tp->U.V21.tuid == (struct S59 *)NIL)
X			tp->U.V21.tuid = uid;
X		else
X			if (uid == (struct S59 *)NIL)
X				printid(tp->U.V21.tuid);
X		(void)fprintf(output.fp, " {\n"), Putl(output, 1);
X		increment();
X		if ((tp->U.V21.tflist == (struct S61 *)NIL) && (tp->U.V21.tvlist == (struct S61 *)NIL)) {
X			indent();
X			(void)fprintf(output.fp, "%s%cdummy;\n", inttyp, tab1), Putl(output, 1);
X		}
X		tq = tp->U.V21.tflist;
X		while (tq != (struct S61 *)NIL) {
X			indent();
X			etdef(uid, tq);
X			tq = tq->tnext;
X		}
X		if (tp->U.V21.tvlist != (struct S61 *)NIL) {
X			indent();
X			(void)fprintf(output.fp, "union {\n"), Putl(output, 1);
X			increment();
X			tq = tp->U.V21.tvlist;
X			while (tq != (struct S61 *)NIL) {
X				if ((tq->U.V20.tvrnt->U.V21.tflist != (struct S61 *)NIL) || (tq->U.V20.tvrnt->U.V21.tvlist != (struct S61 *)NIL)) {
X					indent();
X					if (uid == (struct S59 *)NIL)
X						etdef(mkvrnt(), tq->U.V20.tvrnt);
X					else
X						etdef(mkconc('.', uid, mkvrnt()), tq->U.V20.tvrnt);
X					Putchr(';', output),Putchr('\n', output);
X				}
X				tq = tq->tnext;
X			}
X			decrement();
X			indent();
X			(void)fprintf(output.fp, "} U;\n"), Putl(output, 1);
X		}
X		decrement();
X		indent();
X		if (tp->tup->tt == nvariant) {
X			(void)fprintf(output.fp, "} "), Putl(output, 0);
X			printsuf(tp->U.V21.tuid);
X		} else
X			Putchr('}', output);
X		break ;
X	  case nconfarr:
X		(void)fprintf(output.fp, "struct "), Putl(output, 0);
X		printid(tp->U.V22.tcuid);
X		(void)fprintf(output.fp, " { "), Putl(output, 0);
X		etdef((idptr)NIL, tp->U.V22.tcelem);
X		(void)fprintf(output.fp, "%cA[]; }", tab1), Putl(output, 0);
X		break ;
X	  case narray:
X		(void)fprintf(output.fp, "struct { "), Putl(output, 0);
X		etdef((idptr)NIL, tp->U.V23.taelem);
X		(void)fprintf(output.fp, "%cA[", tab1), Putl(output, 0);
X		tq = typeof(tp->U.V23.taindx);
X		if (tq->tt == nsubrange) {
X			if (arithexpr(tq->U.V19.thi)) {
X				eexpr(tq->U.V19.thi);
X				if (cvalof(tq->U.V19.tlo) != 0) {
X					(void)fprintf(output.fp, " - "), Putl(output, 0);
X					eexpr(tq->U.V19.tlo);
X				}
X			} else {
X				(void)fprintf(output.fp, "(int)("), Putl(output, 0);
X				eexpr(tq->U.V19.thi);
X				if (cvalof(tq->U.V19.tlo) != 0) {
X					(void)fprintf(output.fp, ") - (int)("), Putl(output, 0);
X					eexpr(tq->U.V19.tlo);
X				}
X				Putchr(')', output);
X			}
X			(void)fprintf(output.fp, " + 1"), Putl(output, 0);
X		} else
X			(void)fprintf(output.fp, "%1d", crange(tp->U.V23.taindx)), Putl(output, 0);
X		(void)fprintf(output.fp, "]; }"), Putl(output, 0);
X		break ;
X	  case nfileof:
X		(void)fprintf(output.fp, "struct {\n"), Putl(output, 1);
X		indent();
X		(void)fprintf(output.fp, "%cFILE%c*fp;\n", tab1, tab1), Putl(output, 1);
X		indent();
X		(void)fprintf(output.fp, "%c%s%ceoln:1,\n", tab1, filebits, tab1), Putl(output, 1);
X		indent();
X		(void)fprintf(output.fp, "%seof:1,\n", tab3), Putl(output, 1);
X		indent();
X		(void)fprintf(output.fp, "%sout:1,\n", tab3), Putl(output, 1);
X		indent();
X		(void)fprintf(output.fp, "%sinit:1,\n", tab3), Putl(output, 1);
X		indent();
X		(void)fprintf(output.fp, "%s:%1d;\n", tab3, filefill), Putl(output, 1);
X		indent();
X		Putchr(tab1, output);
X		etdef((idptr)NIL, tp->U.V18.tof);
X		(void)fprintf(output.fp, "%cbuf;\n", tab1), Putl(output, 1);
X		indent();
X		(void)fprintf(output.fp, "} "), Putl(output, 0);
X		break ;
X	  case nsetof:
X		(void)fprintf(output.fp, "struct { %s%cS[%1d]; }", setwtyp, tab1, csetsize(tp)), Putl(output, 0);
X		break ;
X	  case npredef:
X		switch (tp->U.V12.tobtyp) {
X		  case tboolean:
X			printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X			break ;
X		  case tchar:
X			(void)fprintf(output.fp, "%s", chartyp), Putl(output, 0);
X			break ;
X		  case tinteger:
X			printid(defnams.A[(int)(dinteger)]->U.V6.lid);
X			break ;
X		  case treal:
X			printid(defnams.A[(int)(dreal)]->U.V6.lid);
X			break ;
X		  case tstring:
X			(void)fprintf(output.fp, "%s *", chartyp), Putl(output, 0);
X			break ;
X		  case ttext:
X			(void)fprintf(output.fp, "text"), Putl(output, 0);
X			break ;
X		  case tnil:  case tset:  case terror:
X			fatal(etree);
X			break ;
X		  case tnone:
X			(void)fprintf(output.fp, "%s", voidtyp), Putl(output, 0);
X			break ;
X		  default:
X			Caseerror(Line);
X		}
X		break ;
X	  case nempty:
X		(void)fprintf(output.fp, "%s", voidtyp), Putl(output, 0);
X		break ;
X	  default:
X		Caseerror(Line);
X	}
X}
X
X void
Xetypedef(tp)
X	treeptr	tp;
X{
X	etdef((idptr)NIL, tp);
X}
X
X void
Xetype(tp)
X	treeptr	tp;
X{
X	symptr	sp;
X
X	while (tp != (struct S61 *)NIL) {
X		sp = tp->U.V14.tidl->U.V43.tsym;
X		if (sp->U.V6.lid->inref > 1)
X			sp->U.V6.lid = mkrename('Y', sp->U.V6.lid);
X		indent();
X		(void)fprintf(output.fp, "%s", typdef), Putl(output, 0);
X		etypedef(tp->U.V14.tbind);
X		Putchr(tab1, output);
X		printid(sp->U.V6.lid);
X		Putchr(';', output),Putchr('\n', output);
X		tp = tp->tnext;
X	}
X}
X
X void
Xevar(tp)
X	treeptr	tp;
X{
X	treeptr	tq;
X	integer	i;
X
X	while (tp != (struct S61 *)NIL) {
X		indent();
X		switch (tp->tt) {
X		  case nvar:  case nvalpar:  case nvarpar:
X			if (tp->U.V14.tattr == aregister)
X				(void)fprintf(output.fp, "%s", registr), Putl(output, 0);
X			etypedef(tp->U.V14.tbind);
X			break ;
X		  case nparproc:  case nparfunc:
X			if (tp->tt == nparproc)
X				(void)fprintf(output.fp, "%s", voidtyp), Putl(output, 0);
X			else
X				etypedef(tp->U.V15.tpartyp);
X			tq = tp->U.V15.tparid;
X			(void)fprintf(output.fp, "%c(*", tab1), Putl(output, 0);
X			printid(tq->U.V43.tsym->U.V6.lid);
X			(void)fprintf(output.fp, ")()"), Putl(output, 0);
X			goto L555;
X			break ;
X		  default:
X			Caseerror(Line);
X		}
X		Putchr(tab1, output);
X		tq = tp->U.V14.tidl;
X		i = 1;
X		do {
X			if (tp->tt == nvarpar)
X				Putchr('*', output);
X			printid(tq->U.V43.tsym->U.V6.lid);
X			tq = tq->tnext;
X			if (tq != (struct S61 *)NIL) {
X				if (i >= 6) {
X					i = 1;
X					Putchr(',', output),Putchr('\n', output);
X					indent();
X					Putchr(tab1, output);
X				} else {
X					i = i + 1;
X					(void)fprintf(output.fp, ", "), Putl(output, 0);
X				}
X			}
X		} while (!(tq == (struct S61 *)NIL));
X	L555:
X		Putchr(';', output),Putchr('\n', output);
X		if (tp->tt == nvarpar)
X			if (tp->U.V14.tbind->tt == nconfarr) {
X				indent();
X				etypedef(tp->U.V14.tbind->U.V22.tindtyp);
X				Putchr(tab1, output);
X				tq = tp->U.V14.tbind->U.V22.tcindx->U.V19.thi;
X				printid(tq->U.V43.tsym->U.V6.lid);
X				Putchr(';', output),Putchr('\n', output);
X			}
X		tp = tp->tnext;
X	}
X}
X
X
Xvoid estmt();
X
X void
Xewithtype(tp)
X	treeptr	tp;
X{
X	treeptr	tq;
X
X	tq = typeof(tp);
X	(void)fprintf(output.fp, "struct "), Putl(output, 0);
X	printid(tq->U.V21.tuid);
X}
X
X void
Xechoise(tp)
X	treeptr	tp;
X{
X	treeptr	tq;
X	integer	i;
X
X	while (tp != (struct S61 *)NIL) {
X		tq = tp->U.V36.tchocon;
X		i = 0;
X		indent();
X		while (tq != (struct S61 *)NIL) {
X			(void)fprintf(output.fp, "  case "), Putl(output, 0);
X			(*G194_conflag) = true;
X			eexpr(tq);
X			(*G194_conflag) = false;
X			Putchr(':', output);
X			i = i + 1;
X			tq = tq->tnext;
X			if ((tq == (struct S61 *)NIL) || (i % 4 == 0)) {
X				Putchr('\n', output);
X				if (tq != (struct S61 *)NIL)
X					indent();
X				i = 0;
X			}
X		}
X		increment();
X		if (tp->U.V36.tchostmt->tt == nbegin)
X			estmt(tp->U.V36.tchostmt->U.V24.tbegin);
X		else
X			estmt(tp->U.V36.tchostmt);
X		indent();
X		(void)fprintf(output.fp, "break ;\n"), Putl(output, 1);
X		decrement();
X		tp = tp->tnext;
X		if (tp != (struct S61 *)NIL)
X			if (tp->U.V36.tchocon == (struct S61 *)NIL)
X				tp = (struct S61 *)NIL;
X	}
X}
X
X void
Xcenv(ip, dp)
X	idptr	ip;
X	declptr	dp;
X{
X	treeptr	tp;
X	symptr	sp;
X	idptr	np;
X	register hashtyp	h;
X
X	{
X		register struct S60 *W54 = &*dp;
X
X		{
X			hashtyp	B55 = 0,
X				B56 = hashmax - 1;
X
X			if (B55 <= B56)
X				for (h = B55; ; h++) {
X					sp = W54->ddecl.A[h];
X					while (sp != (struct S62 *)NIL) {
X						if (sp->lt == lfield) {
X							np = sp->U.V6.lid;
X							tp = sp->lsymdecl->tup->tup;
X							if ((tp->tup->tt == nvariant) && (tp->U.V21.tuid != (struct S59 *)NIL))
X								np = mkconc('.', tp->U.V21.tuid, np);
X							np = mkconc('>', ip, np);
X							sp->U.V6.lid = np;
X						}
X						sp = sp->lnext;
X					}
X					if (h == B56) break;
X				}
X		}
X	}
X}
X
X void
Xeglobid(tp)
X	treeptr	tp;
X{
X	toknidx	j;
X	toknbuf	w;
X
X	gettokn(tp->U.V43.tsym->U.V6.lid->istr, &w);
X	j = 1;
X	if (w.A[1 - 1] == '*')
X		j = 2;
X	while (w.A[j - 1] != null) {
X		Putchr(w.A[j - 1], output);
X		j = j + 1;
X	}
X}
X
X void
Xestmt(tp)
X	treeptr	tp;
X{
X	treeptr	tq;
X	idptr	locid1, locid2;
X	boolean	stusd;
X	char	opc1, opc2;
X
X	while (tp != (struct S61 *)NIL) {
X		switch (tp->tt) {
X		  case nbegin:
X			if (Member((unsigned)(tp->tup->tt), Conset[156]))
X				indent();
X			Putchr('{', output),Putchr('\n', output);
X			increment();
X			estmt(tp->U.V24.tbegin);
X			decrement();
X			indent();
X			Putchr('}', output);
X			if (tp->tup->tt != nif)
X				Putchr('\n', output);
X			break ;
X		  case nrepeat:
X			indent();
X			(void)fprintf(output.fp, "do {\n"), Putl(output, 1);
X			increment();
X			estmt(tp->U.V33.treptstmt);
X			decrement();
X			indent();
X			(void)fprintf(output.fp, "} while (!("), Putl(output, 0);
X			eexpr(tp->U.V33.treptxp);
X			(void)fprintf(output.fp, "));\n"), Putl(output, 1);
X			break ;
X		  case nwhile:
X			indent();
X			(void)fprintf(output.fp, "while ("), Putl(output, 0);
X			increment();
X			eexpr(tp->U.V32.twhixp);
X			stusd = (*G196_setused);
X			if (tp->U.V32.twhistmt->tt == nbegin) {
X				decrement();
X				(void)fprintf(output.fp, ") "), Putl(output, 0);
X				estmt(tp->U.V32.twhistmt);
X			} else {
X				Putchr(')', output),Putchr('\n', output);
X				estmt(tp->U.V32.twhistmt);
X				decrement();
X			}
X			(*G196_setused) = (boolean)(stusd || (*G196_setused));
X			break ;
X		  case nfor:
X			indent();
X			if (tp->U.V34.tincr) {
X				opc1 = '+';
X				opc2 = '<';
X			} else {
X				opc1 = '-';
X				opc2 = '>';
X			}
X			if (!lazyfor) {
X				locid1 = mkvariable('B');
X				locid2 = mkvariable('B');
X				Putchr('{', output),Putchr('\n', output);
X				increment();
X				indent();
X				tq = idup(tp->U.V34.tforid);
X				etypedef(tq->U.V14.tbind);
X				tq = typeof(tq->U.V14.tbind);
X				Putchr(tab1, output);
X				printid(locid1);
X				(void)fprintf(output.fp, " = "), Putl(output, 0);
X				eexpr(tp->U.V34.tfrom);
X				Putchr(',', output),Putchr('\n', output);
X				indent();
X				Putchr(tab1, output);
X				printid(locid2);
X				(void)fprintf(output.fp, " = "), Putl(output, 0);
X				eexpr(tp->U.V34.tto);
X				Putchr(';', output),Putchr('\n', output);
X				Putchr('\n', output);
X				indent();
X				(void)fprintf(output.fp, "if ("), Putl(output, 0);
X				if (tq->tt == nscalar) {
X					(void)fprintf(output.fp, "(int)("), Putl(output, 0);
X					printid(locid1);
X					Putchr(')', output);
X				} else
X					printid(locid1);
X				(void)fprintf(output.fp, " %c= ", opc2), Putl(output, 0);
X				if (tq->tt == nscalar) {
X					(void)fprintf(output.fp, "(int)("), Putl(output, 0);
X					printid(locid2);
X					Putchr(')', output);
X				} else
X					printid(locid2);
X				Putchr(')', output),Putchr('\n', output);
X				increment();
X				indent();
X				tp->U.V34.tfrom = newid(locid1);
X				tp->U.V34.tfrom->tup = tp;
X			}
X			(void)fprintf(output.fp, "for ("), Putl(output, 0);
X			increment();
X			eexpr(tp->U.V34.tforid);
X			tq = typeof(tp->U.V34.tforid);
X			(void)fprintf(output.fp, " = "), Putl(output, 0);
X			eexpr(tp->U.V34.tfrom);
X			(void)fprintf(output.fp, "; "), Putl(output, 0);
X			if (lazyfor) {
X				if (tq->tt == nscalar) {
X					(void)fprintf(output.fp, "(int)("), Putl(output, 0);
X					eexpr(tp->U.V34.tforid);
X					Putchr(')', output);
X				} else
X					eexpr(tp->U.V34.tforid);
X				(void)fprintf(output.fp, " %c= ", opc2), Putl(output, 0);
X				if (tq->tt == nscalar) {
X					(void)fprintf(output.fp, "(int)("), Putl(output, 0);
X					eexpr(tp->U.V34.tto);
X					Putchr(')', output);
X				} else
X					eexpr(tp->U.V34.tto);
X			}
X			(void)fprintf(output.fp, "; "), Putl(output, 0);
X			eexpr(tp->U.V34.tforid);
X			if (tq->tt == nscalar) {
X				(void)fprintf(output.fp, " = ("), Putl(output, 0);
X				eexpr(tq->tup->U.V14.tidl);
X				(void)fprintf(output.fp, ")((int)("), Putl(output, 0);
X				eexpr(tp->U.V34.tforid);
X				(void)fprintf(output.fp, ")%c1)", opc1), Putl(output, 0);
X			} else
X				(void)fprintf(output.fp, "%c%c", opc1, opc1), Putl(output, 0);
X			if (!lazyfor) {
X				if (tp->U.V34.tforstmt->tt != nbegin) {
X					tq = mknode(nbegin);
X					tq->U.V24.tbegin = tp->U.V34.tforstmt;
X					tq->U.V24.tbegin->tup = tq;
X					tp->U.V34.tforstmt = tq;
X					tq->tup = tp;
X				}
X				tq = tp->U.V34.tforstmt->U.V24.tbegin;
X				while (tq->tnext != (struct S61 *)NIL)
X					tq = tq->tnext;
X				tq->tnext = mknode(nbreak);
X				tq = tq->tnext;
X				tq->tup = tp->U.V34.tforstmt;
X				tq->U.V29.tbrkid = tp->U.V34.tforid;
X				tq->U.V29.tbrkxp = newid(locid2);
X				tq->U.V29.tbrkxp->tup = tq;
X			}
X			if (tp->U.V34.tforstmt->tt == nbegin) {
X				decrement();
X				(void)fprintf(output.fp, ") "), Putl(output, 0);
X				estmt(tp->U.V34.tforstmt);
X			} else {
X				Putchr(')', output),Putchr('\n', output);
X				estmt(tp->U.V34.tforstmt);
X				decrement();
X			}
X			if (!lazyfor) {
X				decrement();
X				decrement();
X				indent();
X				Putchr('}', output),Putchr('\n', output);
X			}
X			break ;
X		  case nif:
X			indent();
X			(void)fprintf(output.fp, "if ("), Putl(output, 0);
X			increment();
X			eexpr(tp->U.V31.tifxp);
X			stusd = (*G196_setused);
X			(*G196_setused) = false;
X			if (tp->U.V31.tthen->tt == nbegin) {
X				decrement();
X				(void)fprintf(output.fp, ") "), Putl(output, 0);
X				estmt(tp->U.V31.tthen);
X				if (tp->U.V31.telse != (struct S61 *)NIL)
X					Putchr(space, output);
X				else
X					Putchr('\n', output);
X			} else {
X				Putchr(')', output),Putchr('\n', output);
X				estmt(tp->U.V31.tthen);
X				decrement();
X				if (tp->U.V31.telse != (struct S61 *)NIL)
X					indent();
X			}
X			if (tp->U.V31.telse != (struct S61 *)NIL) {
X				(void)fprintf(output.fp, "else"), Putl(output, 0);
X				if (tp->U.V31.telse->tt == nbegin) {
X					Putchr(space, output);
X					estmt(tp->U.V31.telse);
X					Putchr('\n', output);
X				} else {
X					increment();
X					Putchr('\n', output);
X					estmt(tp->U.V31.telse);
X					decrement();
X				}
X			}
X			(*G196_setused) = (boolean)(stusd || (*G196_setused));
X			break ;
X		  case ncase:
X			indent();
X			(void)fprintf(output.fp, "switch ("), Putl(output, 0);
X			increment();
X			eexpr(tp->U.V35.tcasxp);
X			(void)fprintf(output.fp, ") {\n"), Putl(output, 1);
X			decrement();
X			echoise(tp->U.V35.tcaslst);
X			indent();
X			(void)fprintf(output.fp, "  default:\n"), Putl(output, 1);
X			increment();
X			if (tp->U.V35.tcasother == (struct S61 *)NIL) {
X				indent();
X				(void)fprintf(output.fp, "Caseerror(Line);\n"), Putl(output, 1);
X			} else
X				estmt(tp->U.V35.tcasother);
X			decrement();
X			indent();
X			Putchr('}', output),Putchr('\n', output);
X			break ;
X		  case nwith:
X			indent();
X			Putchr('{', output),Putchr('\n', output);
X			increment();
X			tq = tp->U.V37.twithvar;
X			while (tq != (struct S61 *)NIL) {
X				indent();
X				(void)fprintf(output.fp, "%s", registr), Putl(output, 0);
X				ewithtype(tq->U.V38.texpw);
X				(void)fprintf(output.fp, " *"), Putl(output, 0);
X				locid1 = mkvariable('W');
X				printid(locid1);
X				(void)fprintf(output.fp, " = "), Putl(output, 0);
X				eaddr(tq->U.V38.texpw);
X				Putchr(';', output),Putchr('\n', output);
X				cenv(locid1, tq->U.V38.tenv);
X				tq = tq->tnext;
X			}
X			Putchr('\n', output);
X			if (tp->U.V37.twithstmt->tt == nbegin)
X				estmt(tp->U.V37.twithstmt->U.V24.tbegin);
X			else
X				estmt(tp->U.V37.twithstmt);
X			decrement();
X			indent();
X			Putchr('}', output),Putchr('\n', output);
X			break ;
X		  case ngoto:
X			indent();
X			if (islocal(tp->U.V26.tlabel))
X				(void)fprintf(output.fp, "goto L%1d;\n", tp->U.V26.tlabel->U.V43.tsym->U.V9.lno), Putl(output, 1);
X			else {
X				tq = idup(tp->U.V26.tlabel);
X				(void)fprintf(output.fp, "longjmp(J[%1d].jb, %1d);\n", tq->U.V13.tstat, tp->U.V26.tlabel->U.V43.tsym->U.V9.lno), Putl(output, 1);
X			}
X			break ;
X		  case nlabstmt:
X			decrement();
X			indent();
X			(void)fprintf(output.fp, "L%1d:\n", tp->U.V25.tlabno->U.V43.tsym->U.V9.lno), Putl(output, 1);
X			increment();
X			estmt(tp->U.V25.tstmt);
X			break ;
X		  case nassign:
X			indent();
X			eexpr(tp);
X			Putchr(';', output),Putchr('\n', output);
X			break ;
X		  case ncall:
X			indent();
X			tq = idup(tp->U.V30.tcall);
X			if ((Member((unsigned)(tq->tt), Conset[157])) && (tq->U.V13.tsubstmt != (struct S61 *)NIL))
X				if (tq->U.V13.tsubstmt->tt == npredef)
X					epredef(tq, tp);
X				else {
X					ecall(tp);
X					Putchr(';', output),Putchr('\n', output);
X				}
X			else {
X				ecall(tp);
X				Putchr(';', output),Putchr('\n', output);
X			}
X			break ;
X		  case npush:
X			indent();
X			eglobid(tp->U.V28.ttmp);
X			(void)fprintf(output.fp, " = "), Putl(output, 0);
X			eglobid(tp->U.V28.tglob);
X			Putchr(';', output),Putchr('\n', output);
X			indent();
X			eglobid(tp->U.V28.tglob);
X			(void)fprintf(output.fp, " = "), Putl(output, 0);
X			if (tp->U.V28.tloc->tt == nid) {
X				tq = idup(tp->U.V28.tloc);
X				if (Member((unsigned)(tq->tt), Conset[158]))
X					printid(tp->U.V28.tloc->U.V43.tsym->U.V6.lid);
X				else
X					eaddr(tp->U.V28.tloc);
X			} else
X				eaddr(tp->U.V28.tloc);
X			Putchr(';', output),Putchr('\n', output);
X			break ;
X		  case npop:
X			indent();
X			eglobid(tp->U.V28.tglob);
X			(void)fprintf(output.fp, " = "), Putl(output, 0);
X			eglobid(tp->U.V28.ttmp);
X			Putchr(';', output),Putchr('\n', output);
X			break ;
X		  case nbreak:
X			indent();
X			(void)fprintf(output.fp, "if ("), Putl(output, 0);
X			eexpr(tp->U.V29.tbrkid);
X			(void)fprintf(output.fp, " == "), Putl(output, 0);
X			eexpr(tp->U.V29.tbrkxp);
X			(void)fprintf(output.fp, ") break;\n"), Putl(output, 1);
X			break ;
X		  case nempty:
X			if (!(Member((unsigned)(tp->tup->tt), Conset[159]))) {
X				indent();
X				Putchr(';', output),Putchr('\n', output);
X			}
X			break ;
X		  default:
X			Caseerror(Line);
X		}
X		if ((*G196_setused) && (Member((unsigned)(tp->tup->tt), Conset[160]))) {
X			indent();
X			(void)fprintf(output.fp, "Claimset();\n"), Putl(output, 1);
X			(*G196_setused) = false;
X		}
X		tp = tp->tnext;
X	}
X}
X
X void
Xelabel(tp)
X	treeptr	tp;
X{
X	treeptr	tq;
X	integer	i;
X
X	i = 0;
X	tq = tp->U.V13.tsublab;
X	while (tq != (struct S61 *)NIL) {
X		if (tq->U.V43.tsym->U.V9.lgo)
X			i = i + 1;
X		tq = tq->tnext;
X	}
X	if (i == 1) {
X		tq = tp->U.V13.tsublab;
X		while (!tq->U.V43.tsym->U.V9.lgo)
X			tq = tq->tnext;
X		indent();
X		(void)fprintf(output.fp, "if (setjmp(J[%1d].jb))\n", tp->U.V13.tstat), Putl(output, 1);
X		(void)fprintf(output.fp, "%cgoto L%1d;\n", tab1, tq->U.V43.tsym->U.V9.lno), Putl(output, 1);
X	} else
X		if (i > 1) {
X			indent();
X			(void)fprintf(output.fp, "switch (setjmp(J[%1d].jb)) {\n", tp->U.V13.tstat), Putl(output, 1);
X			indent();
X			(void)fprintf(output.fp, "  case 0:\n"), Putl(output, 1);
X			indent();
X			(void)fprintf(output.fp, "%cbreak\n", tab1), Putl(output, 1);
X			tq = tp->U.V13.tsublab;
X			while (tq != (struct S61 *)NIL) {
X				if (tq->U.V43.tsym->U.V9.lgo) {
X					indent();
X					(void)fprintf(output.fp, "  case %1d:\n", tq->U.V43.tsym->U.V9.lno), Putl(output, 1);
X					indent();
X					(void)fprintf(output.fp, "%cgoto L%1d;\n", tab1, tq->U.V43.tsym->U.V9.lno), Putl(output, 1);
X				}
X				tq = tq->tnext;
X			}
X			indent();
X			(void)fprintf(output.fp, "  default:\n"), Putl(output, 1);
X			indent();
X			(void)fprintf(output.fp, "%cCaseerror(Line)\n", tab1), Putl(output, 1);
X			indent();
X			Putchr('}', output),Putchr('\n', output);
X		}
X}
X
X void
Xeconf(tp)
X	treeptr	tp;
X{
X	treeptr	tq;
X
X	while (tp != (struct S61 *)NIL) {
X		if (tp->tt == nvarpar)
X			if (tp->U.V14.tbind->tt == nconfarr) {
X				indent();
X				etypedef(tp->U.V14.tbind->U.V22.tindtyp);
X				Putchr(tab1, output);
X				tq = tp->U.V14.tbind->U.V22.tcindx->U.V19.tlo;
X				printid(tq->U.V43.tsym->U.V6.lid);
X				(void)fprintf(output.fp, " = ("), Putl(output, 0);
X				etypedef(tp->U.V14.tbind->U.V22.tindtyp);
X				(void)fprintf(output.fp, ")0;\n"), Putl(output, 1);
X			}
X		tp = tp->tnext;
X	}
X}
X
X void
Xesubr(tp)
X	treeptr	tp;
X{
X	treeptr	tq, ti;
X
X	while (tp != (struct S61 *)NIL) {
X		if (tp->U.V13.tsubsub != (struct S61 *)NIL) {
X			etypedef(tp->U.V13.tfuntyp);
X			Putchr(space, output);
X			printid(tp->U.V13.tsubid->U.V43.tsym->U.V6.lid);
X			(void)fprintf(output.fp, "();\n"), Putl(output, 1);
X			Putchr('\n', output);
X			esubr(tp->U.V13.tsubsub);
X		}
X		if (tp->U.V13.tsubstmt == (struct S61 *)NIL) {
X			if (tp->U.V13.tsubid->U.V43.tsym->lsymdecl->tup == tp)
X				(void)fprintf(output.fp, "%s", xtern), Putl(output, 0);
X			etypedef(tp->U.V13.tfuntyp);
X			Putchr(space, output);
X			printid(tp->U.V13.tsubid->U.V43.tsym->U.V6.lid);
X			(void)fprintf(output.fp, "();\n"), Putl(output, 1);
X			goto L999;
X		}
X		Putchr(space, output);
X		etypedef(tp->U.V13.tfuntyp);
X		Putchr('\n', output);
X		printid(tp->U.V13.tsubid->U.V43.tsym->U.V6.lid);
X		Putchr('(', output);
X		tq = tp->U.V13.tsubpar;
X		while (tq != (struct S61 *)NIL) {
X			switch (tq->tt) {
X			  case nvarpar:  case nvalpar:
X				ti = tq->U.V14.tidl;
X				while (ti != (struct S61 *)NIL) {
X					printid(ti->U.V43.tsym->U.V6.lid);
X					ti = ti->tnext;
X					if (ti != (struct S61 *)NIL)
X						(void)fprintf(output.fp, ", "), Putl(output, 0);
X				}
X				if (tq->U.V14.tbind->tt == nconfarr) {
X					ti = tq->U.V14.tbind->U.V22.tcindx->U.V19.thi;
X					(void)fprintf(output.fp, ", "), Putl(output, 0);
X					printid(ti->U.V43.tsym->U.V6.lid);
X				}
X				break ;
X			  case nparproc:  case nparfunc:
X				ti = tq->U.V15.tparid;
X				printid(ti->U.V43.tsym->U.V6.lid);
X				break ;
X			  default:
X				Caseerror(Line);
X			}
X			tq = tq->tnext;
X			if (tq != (struct S61 *)NIL)
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X		}
X		Putchr(')', output),Putchr('\n', output);
X		increment();
X		evar(tp->U.V13.tsubpar);
X		Putchr('{', output),Putchr('\n', output);
X		econf(tp->U.V13.tsubpar);
X		econst(tp->U.V13.tsubconst);
X		etype(tp->U.V13.tsubtype);
X		evar(tp->U.V13.tsubvar);
X		if ((tp->U.V13.tsubconst != (struct S61 *)NIL) || (tp->U.V13.tsubtype != (struct S61 *)NIL) || (tp->U.V13.tsubvar != (struct S61 *)NIL))
X			Putchr('\n', output);
X		elabel(tp);
X		estmt(tp->U.V13.tsubstmt);
X		if (tp->tt == nfunc) {
X			indent();
X			(void)fprintf(output.fp, "return "), Putl(output, 0);
X			printid(tp->U.V13.tsubvar->U.V14.tidl->U.V43.tsym->U.V6.lid);
X			Putchr(';', output),Putchr('\n', output);
X		}
X		decrement();
X		Putchr('}', output),Putchr('\n', output);
X	L999:
X		Putchr('\n', output);
X		tp = tp->tnext;
X	}
X}
X
X boolean
Xuse(d)
X	predefs	d;
X{
X	register boolean	R174;
X
X	R174 = defnams.A[(int)(d)]->U.V6.lused;
X	return R174;
X}
X
Xvoid eprogram();
X
X void
Xcapital(sp)
X	symptr	sp;
X{
X	toknbuf	tb;
X
X	if (sp->U.V6.lid->inref > 1) {
X		gettokn(sp->U.V6.lid->istr, &tb);
X		tb.A[1 - 1] = uppercase(tb.A[1 - 1]);
X		sp->U.V6.lid = saveid(&tb);
X	}
X}
X
X void
Xetextdef()
X{
X	treeptr	tq;
X
X	(void)fprintf(output.fp, "typedef "), Putl(output, 0);
X	tq = mknode(nfileof);
X	tq->U.V18.tof = typnods.A[(int)(tchar)];
X	etypedef(tq);
X	(void)fprintf(output.fp, "%ctext;\n", tab1), Putl(output, 1);
X}
X
X void
Xeprogram(tp)
X	treeptr	tp;
X{
X	if (tp->U.V13.tsubid != (struct S61 *)NIL) {
X		(void)fprintf(output.fp, "/*\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "**	Code derived from program "), Putl(output, 0);
X		printid(tp->U.V13.tsubid->U.V43.tsym->U.V6.lid);
X		Putchr('\n', output);
X		(void)fprintf(output.fp, "*/\n"), Putl(output, 1);
X		(void)fprintf(output.fp, "%s%s%cexit();\n", xtern, voidtyp, tab1), Putl(output, 1);
X	}
X	if (usecase || usesets || use(dinput) || use(doutput) || use(dwrite) || use(dwriteln) || use(dmessage) || use(deof) || use(deoln) || use(dflush) || use(dpage) || use(dread) || use(dreadln) || use(dclose) || use(dreset) || use(drewrite) || use(dget) || us
X
END_OF_FILE
if test 39665 -ne `wc -c <'ptc.c.5'`; then
    echo shar: \"'ptc.c.5'\" unpacked with wrong size!
fi
# end of 'ptc.c.5'
fi
echo shar: End of archive 7 \(of 12\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 

Rich $alz			"Anger is an energy"
Cronus Project, BBN Labs	rsalz@bbn.com
Moderator, comp.sources.unix	sources@uunet.uu.net
