Path: uunet!rs
From: rs@uunet.UU.NET (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v10i070:  Pascal to C translator, Part06/12
Message-ID: <721@uunet.UU.NET>
Date: 28 Jul 87 19:35:48 GMT
Organization: UUNET Communications Services, Arlington, VA
Lines: 1547
Approved: rs@uunet.UU.NET

Submitted-by: Per Bergsten <mcvax!enea!chalmers!holtec!perb>
Posting-number: Volume 10, Issue 70
Archive-name: ptoc/Part06


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 12)."
# Contents:  ptc.c.4
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ptc.c.4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptc.c.4'\"
else
echo shar: Extracting \"'ptc.c.4'\" \(37883 characters\)
sed "s/^X//" >'ptc.c.4' <<'END_OF_FILE'
X		renamp(tp->U.V13.tsubsub, true);
X		if (on && (tp->U.V13.tsubstmt != (struct S61 *)NIL)) {
X			sp = tp->U.V13.tsubid->U.V43.tsym;
X			if (sp->U.V6.lid->inref > 1) {
X				sp->U.V6.lid = mkrename('P', sp->U.V6.lid);
X				sp->U.V6.lid->inref = sp->U.V6.lid->inref - 1;
X			}
X		}
X		tp = tp->tnext;
X	}
X}
X
Xvoid initcode();
X
X boolean
Xfilevar(tp)
X	treeptr	tp;
X{
X	register boolean	R168;
X	boolean	fv;
X	treeptr	tq;
X
X	switch (tp->tt) {
X	  case npredef:
X		fv = (boolean)(tp == typnods.A[(int)(ttext)]);
X		break ;
X	  case nfileof:
X		fv = true;
X		break ;
X	  case nconfarr:
X		fv = filevar(typeof(tp->U.V22.tcelem));
X		break ;
X	  case narray:
X		fv = filevar(typeof(tp->U.V23.taelem));
X		break ;
X	  case nrecord:
X		fv = false;
X		tq = tp->U.V21.tvlist;
X		while (tq != (struct S61 *)NIL) {
X			if (filevar(tq->U.V20.tvrnt))
X				error(evrntfile);
X			tq = tq->tnext;
X		}
X		tq = tp->U.V21.tflist;
X		while (tq != (struct S61 *)NIL) {
X			if (filevar(typeof(tq->U.V14.tbind))) {
X				fv = true;
X				tq = (struct S61 *)NIL;
X			} else
X				tq = tq->tnext;
X		}
X		break ;
X	  case nptr:
X		fv = false;
X		if (!tp->U.V16.tptrflag) {
X			tp->U.V16.tptrflag = true;
X			if (filevar(typeof(tp->U.V16.tptrid)))
X				error(evarfile);
X			tp->U.V16.tptrflag = false;
X		}
X		break ;
X	  case nsubrange:  case nscalar:  case nsetof:
X		fv = false;
X		break ;
X	  default:
X		Caseerror(Line);
X	}
X	R168 = fv;
X	return R168;
X}
X
X treeptr
Xfileinit(ti, tq, opn)
X	treeptr	ti, tq;
X	boolean	opn;
X{
X	register treeptr	R169;
X	treeptr	tx, ty, tz;
X
X	switch (tq->tt) {
X	  case narray:
X		tz = newid(mkvariable('I'));
X		ty = mknode(nvar);
X		ty->U.V14.tattr = aregister;
X		ty->U.V14.tidl = tz;
X		ty->U.V14.tbind = typeof(tq->U.V23.taindx);
X		tz = tq;
X		while (!(Member((unsigned)(tz->tt), Conset[137])))
X			tz = tz->tup;
X		linkup(tz, ty);
X		if (tz->U.V13.tsubvar == (struct S61 *)NIL)
X			tz->U.V13.tsubvar = ty;
X		else {
X			tz = tz->U.V13.tsubvar;
X			while (tz->tnext != (struct S61 *)NIL)
X				tz = tz->tnext;
X			tz->tnext = ty;
X		}
X		ty = ty->U.V14.tidl;
X		tz = mknode(nindex);
X		tz->U.V39.tvariable = ti;
X		tz->U.V39.toffset = ty;
X		tz = fileinit(tz, tq->U.V23.taelem, opn);
X		tx = mknode(nfor);
X		tx->U.V34.tforid = ty;
X		ty = typeof(tq->U.V23.taindx);
X		if (ty->tt == nsubrange) {
X			tx->U.V34.tfrom = ty->U.V19.tlo;
X			tx->U.V34.tto = ty->U.V19.thi;
X		} else
X			if (ty->tt == nscalar) {
X				ty = ty->U.V17.tscalid;
X				tx->U.V34.tfrom = ty;
X				while (ty->tnext != (struct S61 *)NIL)
X					ty = ty->tnext;
X				tx->U.V34.tto = ty;
X			} else
X				if (ty == typnods.A[(int)(tchar)]) {
X					currsym.st = schar;
X					currsym.U.V2.vchr = minchar;
X					tx->U.V34.tfrom = mklit();
X					currsym.st = schar;
X					currsym.U.V2.vchr = maxchar;
X					tx->U.V34.tto = mklit();
X				} else
X					if (ty == typnods.A[(int)(tinteger)]) {
X						currsym.st = sinteger;
X						currsym.U.V3.vint = -maxint;
X						tx->U.V34.tfrom = mklit();
X						currsym.st = sinteger;
X						currsym.U.V3.vint = maxint;
X						tx->U.V34.tto = mklit();
X					} else
X						fatal(etree);
X		tx->U.V34.tforstmt = tz;
X		tx->U.V34.tincr = true;
X		break ;
X	  case npredef:  case nfileof:
X		if (opn) {
X			ty = mknode(nselect);
X			ty->U.V40.trecord = ti;
X			ty->U.V40.tfield = oldid(defnams.A[(int)(dzinit)]->U.V6.lid, lforward);
X			tx = mknode(nassign);
X			tx->U.V27.tlhs = ty;
X			currsym.st = sinteger;
X			currsym.U.V3.vint = 0;
X			tx->U.V27.trhs = mklit();
X		} else {
X			tx = mknode(ncall);
X			tx->U.V30.tcall = oldid(defnams.A[(int)(dclose)]->U.V6.lid, lidentifier);
X			tx->U.V30.taparm = ti;
X		}
X		break ;
X	  case nrecord:
X		ty = (struct S61 *)NIL;
X		tq = tq->U.V21.tflist;
X		while (tq != (struct S61 *)NIL) {
X			if (filevar(typeof(tq->U.V14.tbind))) {
X				tz = tq->U.V14.tidl;
X				while (tz != (struct S61 *)NIL) {
X					tx = mknode(nselect);
X					tx->U.V40.trecord = ti;
X					tx->U.V40.tfield = tz;
X					tx = fileinit(tx, typeof(tq->U.V14.tbind), opn);
X					tx->tnext = ty;
X					ty = tx;
X					tz = tz->tnext;
X				}
X			}
X			tq = tq->tnext;
X		}
X		tx = mknode(nbegin);
X		tx->U.V24.tbegin = ty;
X		break ;
X	  default:
X		Caseerror(Line);
X	}
X	R169 = tx;
X	return R169;
X}
X
X void
Xinitcode(tp)
X	treeptr	tp;
X{
X	treeptr	ti, tq, tu, tv;
X
X	while (tp != (struct S61 *)NIL) {
X		initcode(tp->U.V13.tsubsub);
X		tv = tp->U.V13.tsubvar;
X		while (tv != (struct S61 *)NIL) {
X			tq = typeof(tv->U.V14.tbind);
X			if (filevar(tq)) {
X				ti = tv->U.V14.tidl;
X				while (ti != (struct S61 *)NIL) {
X					tu = fileinit(ti, tq, true);
X					linkup(tp, tu);
X					tu->tnext = tp->U.V13.tsubstmt;
X					tp->U.V13.tsubstmt = tu;
X					while (tu->tnext != (struct S61 *)NIL)
X						tu = tu->tnext;
X					tu->tnext = fileinit(ti, tq, false);
X					linkup(tp, tu->tnext);
X					ti = ti->tnext;
X				}
X			}
X			tv = tv->tnext;
X		}
X		tp = tp->tnext;
X	}
X}
X
X void
Xtransform()
X{
X	renamc();
X	renamp(top->U.V13.tsubsub, false);
X	extract(top);
X	renamf(top);
X	initcode(top->U.V13.tsubsub);
X	global(top, top, false);
X}
X
Xvoid emit();
X
X void
Xincrement()
X{
X	(*G204_indnt) = (*G204_indnt) + indstep;
X}
X
X void
Xdecrement()
X{
X	(*G204_indnt) = (*G204_indnt) - indstep;
X}
X
X void
Xindent()
X{
X	integer	i;
X
X	i = (*G204_indnt);
X	if (i > 60)
X		i = i / tabwidth * tabwidth;
X	while (i >= tabwidth) {
X		Putchr(tab1, output);
X		i = i - tabwidth;
X	}
X	while (i > 0) {
X		Putchr(space, output);
X		i = i - 1;
X	}
X}
X
X boolean
Xarithexpr(tp)
X	treeptr	tp;
X{
X	register boolean	R170;
X
X	tp = typeof(tp);
X	if (tp->tt == nsubrange)
X		if (tp->tup->tt == nconfarr)
X			tp = typeof(tp->tup->U.V22.tindtyp);
X		else
X			tp = typeof(tp->U.V19.tlo);
X	R170 = (boolean)((tp == typnods.A[(int)(tinteger)]) || (tp == typnods.A[(int)(tchar)]) || (tp == typnods.A[(int)(treal)]));
X	return R170;
X}
X
Xvoid eexpr();
X
Xvoid etypedef();
X
X void
Xeselect(tp)
X	treeptr	tp;
X{
X	(*G202_doarrow) = (*G202_doarrow) + 1;
X	eexpr(tp);
X	(*G202_doarrow) = (*G202_doarrow) - 1;
X	if ((*G200_donearr))
X		(*G200_donearr) = false;
X	else
X		Putchr('.', output);
X}
X
Xvoid epredef();
X
X char
Xtypeletter(tp)
X	treeptr	tp;
X{
X	register char	R171;
X	treeptr	tq;
X
X	tq = tp;
X	if (tq->tt == nformat) {
X		if (tq->U.V41.texpl->tt == nformat) {
X			R171 = 'f';
X			goto L999;
X		}
X		tq = tp->U.V41.texpl;
X	}
X	tq = typeof(tq);
X	if (tq->tt == nsubrange)
X		tq = typeof(tq->U.V19.tlo);
X	if (tq == typnods.A[(int)(tstring)])
X		R171 = 's';
X	else
X		if (tq == typnods.A[(int)(tinteger)])
X			R171 = 'd';
X		else
X			if (tq == typnods.A[(int)(tchar)])
X				R171 = 'c';
X			else
X				if (tq == typnods.A[(int)(treal)])
X					if (tp->tt == nformat)
X						R171 = 'e';
X					else
X						R171 = 'g';
X				else
X					if (tq == typnods.A[(int)(tboolean)]) {
X						R171 = 'b';
X						(*G191_nelems) = 6;
X					} else
X						if (tq->tt == narray) {
X							R171 = 'a';
X							(*G191_nelems) = crange(tq->U.V23.taindx);
X						} else
X							if (tq->tt == nconfarr) {
X								R171 = 'v';
X								(*G191_nelems) = 0;
X							} else
X								fatal(etree);
XL999:
X	;
X	return R171;
X}
X
X void
Xetxt(tp)
X	treeptr	tp;
X{
X	toknbuf	w;
X	char	c;
X	toknidx	i;
X
X	switch (tp->tt) {
X	  case nid:
X		tp = idup(tp);
X		if (tp->tt == nconst)
X			etxt(tp->U.V14.tbind);
X		else
X			fatal(etree);
X		break ;
X	  case nstring:
X		gettokn(tp->U.V43.tsym->U.V7.lstr, &w);
X		i = 1;
X		while (w.A[i - 1] != null) {
X			c = w.A[i - 1];
X			if ((c == cite) || (c == bslash))
X				Putchr(bslash, output);
X			else
X				if (c == percent)
X					Putchr(percent, output);
X			Putchr(c, output);
X			i = i + 1;
X		}
X		break ;
X	  case nchar:
X		c = tp->U.V43.tsym->U.V11.lchar;
X		if ((c == cite) || (c == bslash))
X			Putchr(bslash, output);
X		else
X			if (c == percent)
X				Putchr(percent, output);
X		Putchr(c, output);
X		break ;
X	  default:
X		Caseerror(Line);
X	}
X}
X
X void
Xeformat(tq)
X	treeptr	tq;
X{
X	treeptr	tx;
X	integer	i;
X
X	switch (typeletter(tq)) {
X	  case 'a':
X		Putchr(percent, output);
X		if (tq->tt == nformat)
X			if (tq->U.V41.texpr->tt == ninteger)
X				eexpr(tq->U.V41.texpr);
X			else
X				Putchr('*', output);
X		(void)fprintf(output.fp, ".%1ds", (*G191_nelems)), Putl(output, 0);
X		break ;
X	  case 'b':
X		Putchr(percent, output);
X		if (tq->tt == nformat) {
X			if (tq->U.V41.texpr->tt == ninteger)
X				eexpr(tq->U.V41.texpr);
X			else
X				Putchr('*', output);
X		}
X		Putchr('s', output);
X		break ;
X	  case 'c':
X		if (tq->tt == nchar)
X			etxt(tq);
X		else {
X			Putchr(percent, output);
X			if (tq->tt == nformat)
X				if (tq->U.V41.texpr->tt == ninteger)
X					eexpr(tq->U.V41.texpr);
X				else
X					Putchr('*', output);
X			Putchr('c', output);
X		}
X		break ;
X	  case 'd':
X		Putchr(percent, output);
X		if (tq->tt == nformat) {
X			if (tq->U.V41.texpr->tt == ninteger)
X				eexpr(tq->U.V41.texpr);
X			else
X				Putchr('*', output);
X		} else
X			(void)fprintf(output.fp, "%1d", intlen), Putl(output, 0);
X		Putchr('d', output);
X		break ;
X	  case 'e':
X		(void)fprintf(output.fp, "%c%c", percent, space), Putl(output, 0);
X		tx = tq->U.V41.texpr;
X		if (tx->tt == ninteger) {
X			i = cvalof(tx);
X			(void)fprintf(output.fp, "%1d.", i), Putl(output, 0);
X			i = i - 7;
X			if (i < 1)
X				Putchr('1', output);
X			else
X				(void)fprintf(output.fp, "%1d", i), Putl(output, 0);
X		} else
X			(void)fprintf(output.fp, "*.*"), Putl(output, 0);
X		Putchr('e', output);
X		break ;
X	  case 'f':
X		Putchr(percent, output);
X		tx = tq->U.V41.texpl;
X		if (tx->U.V41.texpr->tt == ninteger) {
X			eexpr(tx->U.V41.texpr);
X			Putchr('.', output);
X			tx = tq->U.V41.texpr;
X			if (tx->tt == ninteger) {
X				i = cvalof(tx);
X				tx = tq->U.V41.texpl->U.V41.texpr;
X				if (i > cvalof(tx) - 1)
X					Putchr('1', output);
X				else
X					(void)fprintf(output.fp, "%1d", i), Putl(output, 0);
X			} else
X				Putchr('*', output);
X		} else
X			(void)fprintf(output.fp, "*.*"), Putl(output, 0);
X		Putchr('f', output);
X		break ;
X	  case 'g':
X		(void)fprintf(output.fp, "%c%1de", percent, fixlen), Putl(output, 0);
X		break ;
X	  case 's':
X		if (tq->tt == nstring)
X			etxt(tq);
X		else {
X			Putchr(percent, output);
X			if (tq->tt == nformat)
X				if (tq->U.V41.texpr->tt == ninteger)
X					eexpr(tq->U.V41.texpr);
X				else
X					(void)fprintf(output.fp, "*.*"), Putl(output, 0);
X			Putchr('s', output);
X		}
X		break ;
X	  default:
X		Caseerror(Line);
X	}
X}
X
X void
Xewrite(tq)
X	treeptr	tq;
X{
X	treeptr	tx;
X
X	switch (typeletter(tq)) {
X	  case 'a':
X		(void)fprintf(output.fp, ", "), Putl(output, 0);
X		tx = tq;
X		if (tq->tt == nformat) {
X			if (tq->U.V41.texpr->tt != ninteger) {
X				eexpr(tq->U.V41.texpr);
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X			}
X			tx = tq->U.V41.texpl;
X		}
X		eexpr(tx);
X		(void)fprintf(output.fp, ".A"), Putl(output, 0);
X		break ;
X	  case 'b':
X		(void)fprintf(output.fp, ", "), Putl(output, 0);
X		tx = tq;
X		if (tq->tt == nformat) {
X			if (tq->U.V41.texpr->tt != ninteger) {
X				eexpr(tq->U.V41.texpr);
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X			}
X			tx = tq->U.V41.texpl;
X		}
X		usebool = true;
X		(void)fprintf(output.fp, "Bools[(int)("), Putl(output, 0);
X		eexpr(tx);
X		(void)fprintf(output.fp, ")]"), Putl(output, 0);
X		break ;
X	  case 'c':
X		if (tq->tt == nformat) {
X			if (tq->U.V41.texpr->tt != ninteger) {
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X				eexpr(tq->U.V41.texpr);
X			}
X			(void)fprintf(output.fp, ", "), Putl(output, 0);
X			eexpr(tq->U.V41.texpl);
X		} else
X			if (tq->tt != nchar) {
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X				eexpr(tq);
X			}
X		break ;
X	  case 'd':
X		(void)fprintf(output.fp, ", "), Putl(output, 0);
X		tx = tq;
X		if (tq->tt == nformat) {
X			if (tq->U.V41.texpr->tt != ninteger) {
X				eexpr(tq->U.V41.texpr);
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X			}
X			tx = tq->U.V41.texpl;
X		}
X		eexpr(tx);
X		break ;
X	  case 'e':
X		(void)fprintf(output.fp, ", "), Putl(output, 0);
X		tx = tq->U.V41.texpr;
X		if (tx->tt != ninteger) {
X			usemax = true;
X			eexpr(tx);
X			(void)fprintf(output.fp, ", Max("), Putl(output, 0);
X			eexpr(tx);
X			(void)fprintf(output.fp, " - 7, 1), "), Putl(output, 0);
X		}
X		eexpr(tq->U.V41.texpl);
X		break ;
X	  case 'f':
X		(void)fprintf(output.fp, ", "), Putl(output, 0);
X		tx = tq->U.V41.texpl;
X		if (tx->U.V41.texpr->tt != ninteger) {
X			eexpr(tx->U.V41.texpr);
X			(void)fprintf(output.fp, ", "), Putl(output, 0);
X		}
X		if ((tx->U.V41.texpr->tt != ninteger) || (tq->U.V41.texpr->tt != ninteger)) {
X			usemax = true;
X			(void)fprintf(output.fp, "Max(("), Putl(output, 0);
X			eexpr(tx->U.V41.texpr);
X			(void)fprintf(output.fp, ") - ("), Putl(output, 0);
X			eexpr(tq->U.V41.texpr);
X			(void)fprintf(output.fp, ") - 1, 1), "), Putl(output, 0);
X		}
X		eexpr(tq->U.V41.texpl->U.V41.texpl);
X		break ;
X	  case 'g':
X		(void)fprintf(output.fp, ", "), Putl(output, 0);
X		eexpr(tq);
X		break ;
X	  case 's':
X		if (tq->tt == nformat) {
X			if (tq->U.V41.texpr->tt != ninteger) {
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X				eexpr(tq->U.V41.texpr);
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X				eexpr(tq->U.V41.texpr);
X			}
X			(void)fprintf(output.fp, ", "), Putl(output, 0);
X			eexpr(tq->U.V41.texpl);
X		} else
X			if (tq->tt != nstring) {
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X				eexpr(tq);
X			}
X		break ;
X	  default:
X		Caseerror(Line);
X	}
X}
X
Xvoid enewsize();
X
X void
Xesubsize(tp, tq)
X	treeptr	tp, tq;
X{
X	treeptr	tx, ty;
X	boolean	addsize;
X
X	tx = tq->U.V20.tvrnt;
X	ty = tx->U.V21.tflist;
X	if (ty == (struct S61 *)NIL) {
X		ty = tx->U.V21.tvlist;
X		while (ty != (struct S61 *)NIL) {
X			if (ty->U.V20.tvrnt->U.V21.tflist != (struct S61 *)NIL) {
X				ty = ty->U.V20.tvrnt->U.V21.tflist;
X				goto L555;
X			}
X			ty = ty->tnext;
X		}
X	L555:
X		;
X	}
X	addsize = true;
X	if (ty == (struct S61 *)NIL) {
X		addsize = false;
X		ty = tx->tup->tup->U.V21.tvlist;
X		while (ty != (struct S61 *)NIL) {
X			if (ty->U.V20.tvrnt->U.V21.tflist != (struct S61 *)NIL) {
X				ty = ty->U.V20.tvrnt->U.V21.tflist;
X				goto L666;
X			}
X			ty = ty->tnext;
X		}
X	L666:
X		;
X	}
X	if (ty == (struct S61 *)NIL) {
X		(void)fprintf(output.fp, "sizeof(*"), Putl(output, 0);
X		eexpr(tp);
X		Putchr(')', output);
X	} else {
X		(void)fprintf(output.fp, "Unionoffs("), Putl(output, 0);
X		eexpr(tp);
X		(void)fprintf(output.fp, ", "), Putl(output, 0);
X		printid(ty->U.V14.tidl->U.V43.tsym->U.V6.lid);
X		if (addsize) {
X			(void)fprintf(output.fp, ") + sizeof("), Putl(output, 0);
X			eexpr(tp);
X			(void)fprintf(output.fp, "->"), Putl(output, 0);
X			printid(tx->U.V21.tuid);
X		}
X		Putchr(')', output);
X	}
X}
X
X void
Xenewsize(tp)
X	treeptr	tp;
X{
X	treeptr	tq, tx, ty;
X	integer	v;
X
X	if ((tp->tnext != (struct S61 *)NIL) && unionnew) {
X		v = cvalof(tp->tnext);
X		tq = typeof(tp);
X		tq = typeof(tq->U.V16.tptrid);
X		if (tq->tt != nrecord)
X			fatal(etree);
X		tx = tq->U.V21.tvlist;
X		while (tx != (struct S61 *)NIL) {
X			ty = tx->U.V20.tselct;
X			while (ty != (struct S61 *)NIL) {
X				if (v == cvalof(ty))
X					goto L555;
X				ty = ty->tnext;
X			}
X			tx = tx->tnext;
X		}
X		fatal(etag);
X	L555:
X		esubsize(tp, tx);
X	} else {
X		(void)fprintf(output.fp, "sizeof(*"), Putl(output, 0);
X		eexpr(tp);
X		Putchr(')', output);
X	}
X}
X
X void
Xepredef(ts, tp)
X	treeptr	ts, tp;
X{
X	treeptr	tq, tv, tx;
X	predefs	td;
X	integer	nelems;
X	char	ch;
X	boolean	txtfile;
X	integer	*F192;
X
X	F192 = G191_nelems;
X	G191_nelems = &nelems;
X	td = ts->U.V13.tsubstmt->U.V12.tdef;
X	switch (td) {
X	  case dabs:
X		tq = typeof(tp->U.V30.taparm);
X		if ((tq == typnods.A[(int)(tinteger)]) || (tq->tt == nsubrange))
X			(void)fprintf(output.fp, "abs("), Putl(output, 0);
X		else
X			(void)fprintf(output.fp, "fabs("), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		Putchr(')', output);
X		break ;
X	  case dargv:
X		(void)fprintf(output.fp, "Argvgt("), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		(void)fprintf(output.fp, ", "), Putl(output, 0);
X		eexpr(tp->U.V30.taparm->tnext);
X		(void)fprintf(output.fp, ".A, sizeof("), Putl(output, 0);
X		eexpr(tp->U.V30.taparm->tnext);
X		(void)fprintf(output.fp, ".A));\n"), Putl(output, 1);
X		break ;
X	  case dchr:
X		tq = typeof(tp->U.V30.taparm);
X		if (tq->tt == nsubrange)
X			if (tq->tup->tt == nconfarr)
X				tq = typeof(tq->tup->U.V22.tindtyp);
X			else
X				tq = typeof(tq->U.V19.tlo);
X		if ((tq == typnods.A[(int)(tinteger)]) || (tq == typnods.A[(int)(tchar)]))
X			eexpr(tp->U.V30.taparm);
X		else {
X			(void)fprintf(output.fp, "(char)("), Putl(output, 0);
X			eexpr(tp->U.V30.taparm);
X			Putchr(')', output);
X		}
X		break ;
X	  case ddispose:
X		(void)fprintf(output.fp, "free("), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		break ;
X	  case deof:
X		(void)fprintf(output.fp, "Eof("), Putl(output, 0);
X		if (tp->U.V30.taparm == (struct S61 *)NIL) {
X			defnams.A[(int)(dinput)]->U.V6.lused = true;
X			printid(defnams.A[(int)(dinput)]->U.V6.lid);
X		} else
X			eexpr(tp->U.V30.taparm);
X		Putchr(')', output);
X		break ;
X	  case deoln:
X		(void)fprintf(output.fp, "Eoln("), Putl(output, 0);
X		if (tp->U.V30.taparm == (struct S61 *)NIL) {
X			defnams.A[(int)(dinput)]->U.V6.lused = true;
X			printid(defnams.A[(int)(dinput)]->U.V6.lid);
X		} else
X			eexpr(tp->U.V30.taparm);
X		Putchr(')', output);
X		break ;
X	  case dexit:
X		(void)fprintf(output.fp, "exit("), Putl(output, 0);
X		if (tp->U.V30.taparm == (struct S61 *)NIL)
X			Putchr('0', output);
X		else
X			eexpr(tp->U.V30.taparm);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		break ;
X	  case dflush:
X		(void)fprintf(output.fp, "fflush("), Putl(output, 0);
X		if (tp->U.V30.taparm == (struct S61 *)NIL) {
X			defnams.A[(int)(doutput)]->U.V6.lused = true;
X			printid(defnams.A[(int)(doutput)]->U.V6.lid);
X		} else
X			eexpr(tp->U.V30.taparm);
X		(void)fprintf(output.fp, ".fp);\n"), Putl(output, 1);
X		break ;
X	  case dpage:
X		(void)fprintf(output.fp, "Putchr(%s, ", ffchr), Putl(output, 0);
X		if (tp->U.V30.taparm == (struct S61 *)NIL) {
X			defnams.A[(int)(doutput)]->U.V6.lused = true;
X			printid(defnams.A[(int)(doutput)]->U.V6.lid);
X		} else
X			eexpr(tp->U.V30.taparm);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		break ;
X	  case dput:  case dget:
X		if (typeof(tp->U.V30.taparm) == typnods.A[(int)(ttext)])
X			if (td == dget)
X				(void)fprintf(output.fp, "Getx"), Putl(output, 0);
X			else
X				(void)fprintf(output.fp, "Putx"), Putl(output, 0);
X		else {
X			(void)fprintf(output.fp, "%s", voidcast), Putl(output, 0);
X			if (td == dget)
X				(void)fprintf(output.fp, "Get"), Putl(output, 0);
X			else
X				(void)fprintf(output.fp, "Put"), Putl(output, 0);
X		}
X		Putchr('(', output);
X		eexpr(tp->U.V30.taparm);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		break ;
X	  case dhalt:
X		(void)fprintf(output.fp, "abort();\n"), Putl(output, 1);
X		break ;
X	  case dnew:
X		eexpr(tp->U.V30.taparm);
X		(void)fprintf(output.fp, " = ("), Putl(output, 0);
X		etypedef(typeof(tp->U.V30.taparm));
X		(void)fprintf(output.fp, ")malloc((unsigned)("), Putl(output, 0);
X		enewsize(tp->U.V30.taparm);
X		(void)fprintf(output.fp, "));\n"), Putl(output, 1);
X		break ;
X	  case dord:
X		(void)fprintf(output.fp, "(unsigned)("), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		Putchr(')', output);
X		break ;
X	  case dread:  case dreadln:
X		txtfile = false;
X		tq = tp->U.V30.taparm;
X		if (tq != (struct S61 *)NIL) {
X			tv = typeof(tq);
X			if (tv == typnods.A[(int)(ttext)]) {
X				txtfile = true;
X				tv = tq;
X				tq = tq->tnext;
X			} else
X				if (tv->tt == nfileof) {
X					txtfile = (boolean)(typeof(tv->U.V18.tof) == typnods.A[(int)(tchar)]);
X					tv = tq;
X					tq = tq->tnext;
X				} else {
X					txtfile = true;
X					tv = (struct S61 *)NIL;
X				}
X		} else {
X			tv = (struct S61 *)NIL;
X			txtfile = true;
X		}
X		if (txtfile) {
X			if (tq == (struct S61 *)NIL)
X				goto L444;
X			if ((tq->tt != nformat) && (tq->tnext == (struct S61 *)NIL) && (typeletter(tq) == 'c')) {
X				eexpr(tq);
X				(void)fprintf(output.fp, " = "), Putl(output, 0);
X				(void)fprintf(output.fp, "Getchr("), Putl(output, 0);
X				if (tv == (struct S61 *)NIL)
X					printid(defnams.A[(int)(dinput)]->U.V6.lid);
X				else
X					eexpr(tv);
X				Putchr(')', output);
X				if (td == dreadln)
X					Putchr(',', output);
X				goto L444;
X			}
X			usescan = true;
X			(void)fprintf(output.fp, "Fscan("), Putl(output, 0);
X			if (tv == (struct S61 *)NIL)
X				printid(defnams.A[(int)(dinput)]->U.V6.lid);
X			else
X				eexpr(tv);
X			(void)fprintf(output.fp, "), "), Putl(output, 0);
X			while (tq != (struct S61 *)NIL) {
X				(void)fprintf(output.fp, "Scan(%c", cite), Putl(output, 0);
X				ch = typeletter(tq);
X				switch (ch) {
X				  case 'a':
X					(void)fprintf(output.fp, "%cs", percent), Putl(output, 0);
X					break ;
X				  case 'c':
X					(void)fprintf(output.fp, "%cc", percent), Putl(output, 0);
X					break ;
X				  case 'd':
X					(void)fprintf(output.fp, "%cld", percent), Putl(output, 0);
X					break ;
X				  case 'g':
X					(void)fprintf(output.fp, "%cle", percent), Putl(output, 0);
X					break ;
X				  default:
X					Caseerror(Line);
X				}
X				(void)fprintf(output.fp, "%c, ", cite), Putl(output, 0);
X				switch (ch) {
X				  case 'a':
X					eexpr(tq);
X					(void)fprintf(output.fp, ".A"), Putl(output, 0);
X					break ;
X				  case 'c':
X					Putchr('&', output);
X					eexpr(tq);
X					break ;
X				  case 'd':
X					(void)fprintf(output.fp, "&Tmplng"), Putl(output, 0);
X					break ;
X				  case 'g':
X					(void)fprintf(output.fp, "&Tmpdbl"), Putl(output, 0);
X					break ;
X				  default:
X					Caseerror(Line);
X				}
X				Putchr(')', output);
X				switch (ch) {
X				  case 'd':
X					(void)fprintf(output.fp, ", "), Putl(output, 0);
X					eexpr(tq);
X					(void)fprintf(output.fp, " = Tmplng"), Putl(output, 0);
X					break ;
X				  case 'g':
X					(void)fprintf(output.fp, ", "), Putl(output, 0);
X					eexpr(tq);
X					(void)fprintf(output.fp, " = Tmpdbl"), Putl(output, 0);
X					break ;
X				  case 'a':  case 'c':
X					break ;
X				  default:
X					Caseerror(Line);
X				}
X				tq = tq->tnext;
X				if (tq != (struct S61 *)NIL) {
X					Putchr(',', output),Putchr('\n', output);
X					indent();
X					Putchr(tab1, output);
X				}
X			}
X			(void)fprintf(output.fp, ", Getx("), Putl(output, 0);
X			if (tv == (struct S61 *)NIL)
X				printid(defnams.A[(int)(dinput)]->U.V6.lid);
X			else
X				eexpr(tv);
X			Putchr(')', output);
X			if (td == dreadln)
X				Putchr(',', output);
X		L444:
X			if (td == dreadln) {
X				usegetl = true;
X				(void)fprintf(output.fp, "Getl(&"), Putl(output, 0);
X				if (tv == (struct S61 *)NIL)
X					printid(defnams.A[(int)(dinput)]->U.V6.lid);
X				else
X					eexpr(tv);
X				Putchr(')', output);
X			}
X		} else {
X			increment();
X			while (tq != (struct S61 *)NIL) {
X				(void)fprintf(output.fp, "%sFread(", voidcast), Putl(output, 0);
X				eexpr(tq);
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X				eexpr(tv);
X				(void)fprintf(output.fp, ".fp)"), Putl(output, 0);
X				tq = tq->tnext;
X				if (tq != (struct S61 *)NIL) {
X					Putchr(',', output),Putchr('\n', output);
X					indent();
X				}
X			}
X			decrement();
X		}
X		Putchr(';', output),Putchr('\n', output);
X		break ;
X	  case dwrite:  case dwriteln:  case dmessage:
X		txtfile = false;
X		tq = tp->U.V30.taparm;
X		if (tq != (struct S61 *)NIL) {
X			tv = typeof(tq);
X			if (tv == typnods.A[(int)(ttext)]) {
X				txtfile = true;
X				tv = tq;
X				tq = tq->tnext;
X			} else
X				if (tv->tt == nfileof) {
X					txtfile = (boolean)(typeof(tv->U.V18.tof) == typnods.A[(int)(tchar)]);
X					tv = tq;
X					tq = tq->tnext;
X				} else {
X					txtfile = true;
X					tv = (struct S61 *)NIL;
X				}
X		} else {
X			tv = (struct S61 *)NIL;
X			txtfile = true;
X		}
X		if (txtfile) {
X			if (tq == (struct S61 *)NIL) {
X				if (Member((unsigned)(td), Conset[138])) {
X					(void)fprintf(output.fp, "Putchr(%s, ", nlchr), Putl(output, 0);
X					if (tv == (struct S61 *)NIL)
X						printid(defnams.A[(int)(doutput)]->U.V6.lid);
X					else
X						eexpr(tv);
X					Putchr(')', output);
X				}
X				Putchr(';', output),Putchr('\n', output);
X				goto L555;
X			} else
X				if ((tq->tt != nformat) && (tq->tnext == (struct S61 *)NIL))
X					if (typeletter(tq) == 'c') {
X						(void)fprintf(output.fp, "Putchr("), Putl(output, 0);
X						eexpr(tq);
X						(void)fprintf(output.fp, ", "), Putl(output, 0);
X						if (tv == (struct S61 *)NIL)
X							printid(defnams.A[(int)(doutput)]->U.V6.lid);
X						else
X							eexpr(tv);
X						Putchr(')', output);
X						if (td == dwriteln) {
X							(void)fprintf(output.fp, ",Putchr(%s, ", nlchr), Putl(output, 0);
X							if (tv == (struct S61 *)NIL)
X								printid(defnams.A[(int)(doutput)]->U.V6.lid);
X							else
X								eexpr(tv);
X							Putchr(')', output);
X						}
X						Putchr(';', output),Putchr('\n', output);
X						goto L555;
X					}
X			tx = (struct S61 *)NIL;
X			(void)fprintf(output.fp, "%sfprintf(", voidcast), Putl(output, 0);
X			if (td == dmessage)
X				(void)fprintf(output.fp, "stderr, "), Putl(output, 0);
X			else {
X				if (tv == (struct S61 *)NIL)
X					printid(defnams.A[(int)(doutput)]->U.V6.lid);
X				else
X					eexpr(tv);
X				(void)fprintf(output.fp, ".fp, "), Putl(output, 0);
X			}
X			Putchr(cite, output);
X			tx = tq;
X			while (tq != (struct S61 *)NIL) {
X				eformat(tq);
X				tq = tq->tnext;
X			}
X			if ((td == dmessage) || (td == dwriteln))
X				(void)fprintf(output.fp, "\\n"), Putl(output, 0);
X			Putchr(cite, output);
X			tq = tx;
X			while (tq != (struct S61 *)NIL) {
X				ewrite(tq);
X				tq = tq->tnext;
X			}
X			(void)fprintf(output.fp, "), Putl("), Putl(output, 0);
X			if (tv == (struct S61 *)NIL)
X				printid(defnams.A[(int)(doutput)]->U.V6.lid);
X			else
X				eexpr(tv);
X			if (td == dwrite)
X				(void)fprintf(output.fp, ", 0)"), Putl(output, 0);
X			else
X				(void)fprintf(output.fp, ", 1)"), Putl(output, 0);
X		} else {
X			increment();
X			tx = typeof(tv);
X			if (tx == typnods.A[(int)(ttext)])
X				tx = typnods.A[(int)(tchar)];
X			else
X				if (tx->tt == nfileof)
X					tx = typeof(tx->U.V18.tof);
X				else
X					fatal(etree);
X			while (tq != (struct S61 *)NIL) {
X				if ((Member((unsigned)(tq->tt), Conset[139])) && (tx == typeof(tq))) {
X					(void)fprintf(output.fp, "%sFwrite(", voidcast), Putl(output, 0);
X					eexpr(tq);
X				} else {
X					if (tx->tt == nsetof) {
X						usescpy = true;
X						(void)fprintf(output.fp, "Setncpy("), Putl(output, 0);
X						eselect(tv);
X						(void)fprintf(output.fp, "buf.S, "), Putl(output, 0);
X						eexpr(tq);
X						if (typeof(tp->U.V27.trhs) == typnods.A[(int)(tset)])
X							eexpr(tq);
X						else {
X							eselect(tq);
X							Putchr('S', output);
X						}
X						(void)fprintf(output.fp, ", sizeof("), Putl(output, 0);
X						eexpr(tv);
X						(void)fprintf(output.fp, ".buf))"), Putl(output, 0);
X					} else {
X						eexpr(tv);
X						(void)fprintf(output.fp, ".buf = "), Putl(output, 0);
X						eexpr(tq);
X					}
X					(void)fprintf(output.fp, ", Fwrite("), Putl(output, 0);
X					eexpr(tv);
X					(void)fprintf(output.fp, ".buf"), Putl(output, 0);
X				}
X				(void)fprintf(output.fp, ", "), Putl(output, 0);
X				eexpr(tv);
X				(void)fprintf(output.fp, ".fp)"), Putl(output, 0);
X				tq = tq->tnext;
X				if (tq != (struct S61 *)NIL) {
X					Putchr(',', output),Putchr('\n', output);
X					indent();
X				}
X			}
X			decrement();
X		}
X		Putchr(';', output),Putchr('\n', output);
X	L555:
X		;
X		break ;
X	  case dclose:
X		tq = typeof(tp->U.V30.taparm);
X		txtfile = (boolean)(tq == typnods.A[(int)(ttext)]);
X		if ((!txtfile) && (tq->tt == nfileof))
X			if (typeof(tq->U.V18.tof) == typnods.A[(int)(tchar)])
X				txtfile = true;
X		if (txtfile)
X			(void)fprintf(output.fp, "Closex("), Putl(output, 0);
X		else
X			(void)fprintf(output.fp, "Close("), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		break ;
X	  case dreset:  case drewrite:
X		tq = typeof(tp->U.V30.taparm);
X		txtfile = (boolean)(tq == typnods.A[(int)(ttext)]);
X		if ((!txtfile) && (tq->tt == nfileof))
X			if (typeof(tq->U.V18.tof) == typnods.A[(int)(tchar)])
X				txtfile = true;
X		if (txtfile)
X			if (td == dreset)
X				(void)fprintf(output.fp, "Resetx("), Putl(output, 0);
X			else
X				(void)fprintf(output.fp, "Rewritex("), Putl(output, 0);
X		else
X			if (td == dreset)
X				(void)fprintf(output.fp, "Reset("), Putl(output, 0);
X			else
X				(void)fprintf(output.fp, "Rewrite("), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		(void)fprintf(output.fp, ", "), Putl(output, 0);
X		tq = tp->U.V30.taparm->tnext;
X		if (tq == (struct S61 *)NIL)
X			(void)fprintf(output.fp, "NULL"), Putl(output, 0);
X		else {
X			tq = typeof(tq);
X			if (tq == typnods.A[(int)(tchar)]) {
X				Putchr(cite, output);
X				ch = cvalof(tp->U.V30.taparm->tnext);
X				if ((ch == bslash) || (ch == cite))
X					Putchr(bslash, output);
X				(void)fprintf(output.fp, "%c%c", ch, cite), Putl(output, 0);
X			} else
X				if (tq == typnods.A[(int)(tstring)])
X					eexpr(tp->U.V30.taparm->tnext);
X				else
X					if (Member((unsigned)(tq->tt), Conset[140])) {
X						eexpr(tp->U.V30.taparm->tnext);
X						(void)fprintf(output.fp, ".A"), Putl(output, 0);
X					} else
X						fatal(etree);
X		}
X		(void)fprintf(output.fp, ");\n"), Putl(output, 1);
X		break ;
X	  case darctan:
X		(void)fprintf(output.fp, "atan("), Putl(output, 0);
X		if (typeof(tp->U.V30.taparm) != typnods.A[(int)(treal)])
X			(void)fprintf(output.fp, "%s", dblcast), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		Putchr(')', output);
X		break ;
X	  case dln:
X		(void)fprintf(output.fp, "log("), Putl(output, 0);
X		if (typeof(tp->U.V30.taparm) != typnods.A[(int)(treal)])
X			(void)fprintf(output.fp, "%s", dblcast), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		Putchr(')', output);
X		break ;
X	  case dexp:
X		(void)fprintf(output.fp, "exp("), Putl(output, 0);
X		if (typeof(tp->U.V30.taparm) != typnods.A[(int)(treal)])
X			(void)fprintf(output.fp, "%s", dblcast), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		Putchr(')', output);
X		break ;
X	  case dcos:  case dsin:  case dsqrt:
X		eexpr(tp->U.V30.tcall);
X		Putchr('(', output);
X		if (typeof(tp->U.V30.taparm) != typnods.A[(int)(treal)])
X			(void)fprintf(output.fp, "%s", dblcast), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		Putchr(')', output);
X		break ;
X	  case dtan:
X		(void)fprintf(output.fp, "atan("), Putl(output, 0);
X		if (typeof(tp->U.V30.taparm) != typnods.A[(int)(treal)])
X			(void)fprintf(output.fp, "%s", dblcast), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		Putchr(')', output);
X		break ;
X	  case dsucc:  case dpred:
X		tq = typeof(tp->U.V30.taparm);
X		if (tq->tt == nsubrange)
X			if (tq->tup->tt == nconfarr)
X				tq = typeof(tq->tup->U.V22.tindtyp);
X			else
X				tq = typeof(tq->U.V19.tlo);
X		if ((tq == typnods.A[(int)(tinteger)]) || (tq == typnods.A[(int)(tchar)])) {
X			(void)fprintf(output.fp, "(("), Putl(output, 0);
X			eexpr(tp->U.V30.taparm);
X			if (td == dpred)
X				(void)fprintf(output.fp, ")-1)"), Putl(output, 0);
X			else
X				(void)fprintf(output.fp, ")+1)"), Putl(output, 0);
X		} else {
X			Putchr('(', output);
X			tq = tq->tup;
X			if (tq->tt == ntype) {
X				Putchr('(', output);
X				printid(tq->U.V14.tidl->U.V43.tsym->U.V6.lid);
X				Putchr(')', output);
X			}
X			(void)fprintf(output.fp, "((int)("), Putl(output, 0);
X			eexpr(tp->U.V30.taparm);
X			if (td == dpred)
X				(void)fprintf(output.fp, ")-1))"), Putl(output, 0);
X			else
X				(void)fprintf(output.fp, ")+1))"), Putl(output, 0);
X		}
X		break ;
X	  case dodd:
X		Putchr('(', output);
X		printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X		(void)fprintf(output.fp, ")(("), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		(void)fprintf(output.fp, ") & 1)"), Putl(output, 0);
X		break ;
X	  case dsqr:
X		tq = typeof(tp->U.V30.taparm);
X		if ((tq == typnods.A[(int)(tinteger)]) || (tq->tt == nsubrange)) {
X			(void)fprintf(output.fp, "(("), Putl(output, 0);
X			eexpr(tp->U.V30.taparm);
X			(void)fprintf(output.fp, ") * ("), Putl(output, 0);
X			eexpr(tp->U.V30.taparm);
X			(void)fprintf(output.fp, "))"), Putl(output, 0);
X		} else {
X			(void)fprintf(output.fp, "pow("), Putl(output, 0);
X			if (typeof(tp->U.V30.taparm) != typnods.A[(int)(treal)])
X				(void)fprintf(output.fp, "%s", dblcast), Putl(output, 0);
X			eexpr(tp->U.V30.taparm);
X			(void)fprintf(output.fp, ", 2.0)"), Putl(output, 0);
X		}
X		break ;
X	  case dround:
X		(void)fprintf(output.fp, "Round("), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		Putchr(')', output);
X		break ;
X	  case dtrunc:
X		(void)fprintf(output.fp, "Trunc("), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		Putchr(')', output);
X		break ;
X	  case dpack:
X		tq = typeof(tp->U.V30.taparm);
X		tx = typeof(tp->U.V30.taparm->tnext->tnext);
X		(void)fprintf(output.fp, "{    %s%s%c_j, _i = ", registr, inttyp, tab1), Putl(output, 0);
X		if (!arithexpr(tp->U.V30.taparm->tnext))
X			(void)fprintf(output.fp, "(int)"), Putl(output, 0);
X		eexpr(tp->U.V30.taparm->tnext);
X		if (tx->tt == narray)
X			(void)fprintf(output.fp, " - %1d", clower(tq->U.V23.taindx)), Putl(output, 0);
X		Putchr(';', output),Putchr('\n', output);
X		indent();
X		(void)fprintf(output.fp, "    for (_j = 0; _j < "), Putl(output, 0);
X		if (tq->tt == nconfarr) {
X			(void)fprintf(output.fp, "(int)("), Putl(output, 0);
X			printid(tx->U.V22.tcindx->U.V19.thi->U.V43.tsym->U.V6.lid);
X			Putchr(')', output);
X		} else
X			(void)fprintf(output.fp, "%1d", crange(tx->U.V23.taindx)), Putl(output, 0);
X		(void)fprintf(output.fp, "; )\n"), Putl(output, 1);
X		indent();
X		Putchr(tab1, output);
X		eexpr(tp->U.V30.taparm->tnext->tnext);
X		(void)fprintf(output.fp, ".A[_j++] = "), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		(void)fprintf(output.fp, ".A[_i++];\n"), Putl(output, 1);
X		indent();
X		Putchr('}', output),Putchr('\n', output);
X		break ;
X	  case dunpack:
X		tq = typeof(tp->U.V30.taparm);
X		tx = typeof(tp->U.V30.taparm->tnext);
X		(void)fprintf(output.fp, "{   %s%s%c_j, _i = ", registr, inttyp, tab1), Putl(output, 0);
X		if (!arithexpr(tp->U.V30.taparm->tnext->tnext))
X			(void)fprintf(output.fp, "(int)"), Putl(output, 0);
X		eexpr(tp->U.V30.taparm->tnext->tnext);
X		if (tx->tt != nconfarr)
X			(void)fprintf(output.fp, " - %1d", clower(tx->U.V23.taindx)), Putl(output, 0);
X		Putchr(';', output),Putchr('\n', output);
X		indent();
X		(void)fprintf(output.fp, "    for (_j = 0; _j < "), Putl(output, 0);
X		if (tq->tt == nconfarr) {
X			(void)fprintf(output.fp, "(int)("), Putl(output, 0);
X			printid(tq->U.V22.tcindx->U.V19.thi->U.V43.tsym->U.V6.lid);
X			Putchr(')', output);
X		} else
X			(void)fprintf(output.fp, "%1d", crange(tq->U.V23.taindx)), Putl(output, 0);
X		(void)fprintf(output.fp, "; )\n"), Putl(output, 1);
X		indent();
X		Putchr(tab1, output);
X		eexpr(tp->U.V30.taparm->tnext);
X		(void)fprintf(output.fp, ".A[_i++] = "), Putl(output, 0);
X		eexpr(tp->U.V30.taparm);
X		(void)fprintf(output.fp, ".A[_j++];\n"), Putl(output, 1);
X		indent();
X		Putchr('}', output),Putchr('\n', output);
X		break ;
X	  default:
X		Caseerror(Line);
X	}
X	G191_nelems = F192;
X}
X
X void
Xeaddr(tp)
X	treeptr	tp;
X{
X	Putchr('&', output);
X	if (!(Member((unsigned)(tp->tt), Conset[141])))
X		error(evarpar);
X	eexpr(tp);
X}
X
X void
Xecall(tp)
X	treeptr	tp;
X{
X	treeptr	tf, tq, tx;
X
X	tf = idup(tp->U.V30.tcall);
X	switch (tf->tt) {
X	  case nproc:  case nfunc:
X		tf = tf->U.V13.tsubpar;
X		break ;
X	  case nparproc:  case nparfunc:
X		tf = tf->U.V15.tparparm;
X		break ;
X	  default:
X		Caseerror(Line);
X	}
X	if (tf != (struct S61 *)NIL) {
X		switch (tf->tt) {
X		  case nvalpar:  case nvarpar:
X			tf = tf->U.V14.tidl;
X			break ;
X		  case nparproc:  case nparfunc:
X			tf = tf->U.V15.tparid;
X			break ;
X		  default:
X			Caseerror(Line);
X		}
X	}
X	eexpr(tp->U.V30.tcall);
X	Putchr('(', output);
X	tq = tp->U.V30.taparm;
X	while (tq != (struct S61 *)NIL) {
X		if (Member((unsigned)(tf->tup->tt), Conset[142])) {
X			if (tq->tt == ncall)
X				printid(tq->U.V30.tcall->U.V43.tsym->U.V6.lid);
X			else
X				printid(tq->U.V43.tsym->U.V6.lid);
X		} else {
X			tx = typeof(tq);
X			if (tx == typnods.A[(int)(tboolean)]) {
X				tx = tq;
X				while (tx->tt == nuplus)
X					tx = tx->U.V42.texps;
X				if (Member((unsigned)(tx->tt), Conset[143])) {
X					Putchr('(', output);
X					printid(defnams.A[(int)(dboolean)]->U.V6.lid);
X					(void)fprintf(output.fp, ")("), Putl(output, 0);
X					eexpr(tq);
X					Putchr(')', output);
X				} else
X					eexpr(tq);
X			} else
X				if ((tx == typnods.A[(int)(tstring)]) || (tx == typnods.A[(int)(tset)])) {
X					(void)fprintf(output.fp, "*(("), Putl(output, 0);
X					etypedef(tf->tup->U.V14.tbind);
X					(void)fprintf(output.fp, " *)"), Putl(output, 0);
X					if (tx == typnods.A[(int)(tset)]) {
X						(*G198_dropset) = true;
X						eexpr(tq);
X						(*G198_dropset) = false;
X					} else
X						eexpr(tq);
X					Putchr(')', output);
X				} else
X					if (tx == typnods.A[(int)(tnil)]) {
X						Putchr('(', output);
X						etypedef(tf->tup->U.V14.tbind);
X						(void)fprintf(output.fp, ")NIL"), Putl(output, 0);
X					} else
X						if (tf->tup->U.V14.tbind->tt == nconfarr) {
X							(void)fprintf(output.fp, "(struct "), Putl(output, 0);
X							printid(tf->tup->U.V14.tbind->U.V22.tcuid);
X							(void)fprintf(output.fp, " *)&"), Putl(output, 0);
X							eexpr(tq);
X							if (tq->tnext == (struct S61 *)NIL)
X								(void)fprintf(output.fp, ", %1d", crange(tx->U.V23.taindx)), Putl(output, 0);
X						} else {
X							if (tf->tup->tt == nvarpar)
X								eaddr(tq);
X							else
X								eexpr(tq);
X						}
X		}
X		tq = tq->tnext;
X		if (tq != (struct S61 *)NIL) {
X			(void)fprintf(output.fp, ", "), Putl(output, 0);
X			if (tf->tnext == (struct S61 *)NIL) {
X				tf = tf->tup->tnext;
X				switch (tf->tt) {
X				  case nvalpar:  case nvarpar:
X					tf = tf->U.V14.tidl;
X					break ;
X				  case nparproc:  case nparfunc:
X					tf = tf->U.V15.tparid;
X					break ;
X				  default:
X					Caseerror(Line);
X				}
X			} else
X				tf = tf->tnext;
X		}
X	}
X	Putchr(')', output);
X}
X
Xvoid eexpr();
X
Xboolean constset();
X
X boolean
Xconstxps(tp)
X	treeptr	tp;
X{
X	register boolean	R173;
X
X	switch (tp->tt) {
X	  case nrange:
X		if (constxps(tp->U.V41.texpr))
X			R173 = constxps(tp->U.V41.texpl);
X		else
X			R173 = false;
X		break ;
X	  case nempty:  case ninteger:  case nchar:
X		R173 = true;
X		break ;
X	  case nid:
X		tp = idup(tp);
X		R173 = (boolean)((tp->tt == nconst) || (tp->tt == nscalar));
X		break ;
X	  case nin:  case neq:  case nne:  case nlt:
X	  case nle:  case ngt:  case nge:  case nor:
X	  case nplus:  case nminus:  case nand:  case nmul:
X	  case ndiv:  case nmod:  case nquot:  case nnot:
X	  case numinus:  case nuplus:  case nset:  case nindex:
X	  case nselect:  case nderef:  case ncall:  case nreal:
X	  case nstring:  case nnil:
X		R173 = false;
X		break ;
X	  default:
X		Caseerror(Line);
X	}
X	return R173;
X}
X
X boolean
Xconstset(tp)
X	treeptr	tp;
X{
X	register boolean	R172;
X
X	R172 = true;
X	while (tp != (struct S61 *)NIL)
X		if (constxps(tp))
X			tp = tp->tnext;
X		else {
X			R172 = false;
X			tp = (struct S61 *)NIL;
X		}
X	return R172;
X}
X
END_OF_FILE
if test 37883 -ne `wc -c <'ptc.c.4'`; then
    echo shar: \"'ptc.c.4'\" unpacked with wrong size!
fi
# end of 'ptc.c.4'
fi
echo shar: End of archive 6 \(of 12\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 

Rich $alz			"Anger is an energy"
Cronus Project, BBN Labs	rsalz@bbn.com
Moderator, comp.sources.unix	sources@uunet.uu.net
