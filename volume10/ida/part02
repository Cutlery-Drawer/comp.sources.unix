Path: seismo!uwvax!uwmacc!uwmcsd1!leah!itsgw!steinmetz!uunet!rs
From: rs@uunet.UU.NET (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v10i013:  The IDA Sendmail Kit, Part02/07
Message-ID: <425@uunet.UU.NET>
Date: 23 Jun 87 04:41:44 GMT
Organization: UUNET Communications Services, Arlington, VA
Lines: 2060
Approved: rs@uunet.uu.net

Mod.sources: Volume 10, Number 13
Submitted by: Lennart Lovstrand <mcvax!ida.liu.se!lel>
Archive-name: ida/Part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 7)."
# Contents:  ida/INSTALL ida/README ida/doc/dbm.1 ida/lib/domaintable
#   ida/lib/pathtable ida/patches/BSD29.diff ida/patches/MDBM.diff
#   ida/patches/daemon.c.diff ida/patches/deliver.c.diff
#   ida/patches/main.c.diff ida/patches/recipient.c.diff
#   ida/patches/srvrsmtp.c.diff
# Wrapped by lenlo@prefix on Wed Jun 10 15:39:51 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f ida/INSTALL -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/INSTALL\"
else
echo shar: Extracting \"ida/INSTALL\" \(3311 characters\)
sed "s/^X//" >ida/INSTALL <<'END_OF_ida/INSTALL'
X#
X#  INSTALL -- The IDA Sendmail Enhancement Kit.
X#  Copyright (c) 1987 Lennart Lovstrand
X#  CIS Dept, Univ of Linkoping, Sweden
X#
X#  Use it, abuse it, but don't sell it.
X#
X
XINSTALLATION INSTRUCTIONS
X
XThese instructions will tell you step-by-step how to install and bring
Xthe Kit's sendmail system up.  The source code modifications are given
Xas context diff(1)'s, based on the BSD 4.3 release of sendmail (version
X5.11), ready to be installed using Larry Wall's eminent patch program.
XYou will also need Maryland's mdbm library if you intend to use this
Xinstead of ndbm.  Finally, in order to automatically produce routing
Xtables, you will need Peter Honeyman's pathalias program.  All of these
Xare available from your nearest USENET comp.sources.unix archive.
X
X [1] Unpack the Kit in the sendmail directory (preferably).  This should
X     give you a new ida subdirectory with all the Kit's files.  (Hmm,
X     perhaps you've already done this since you are reading this file.)
X
X [2] Goto sendmail/ida and check that you agree with the Makefile's
X     definitions.  If you change anything, do a "make configure" to
X     propagate those changes to the subdirectories' Makefiles.
X
X [3] Goto sendmail/ida/doc.  Do "make doc" to print out the accompanying
X     paper and "make man" to print the manual pages.  Do "make install"
X     to install the latter in your manuals directory.
X
X [4] Goto sendmail/ida/patches and do "make backup."  This will create a
X     backup copy of sendmail/src/*.[hc] and sendmail/doc/op.me in
X     Backup.tar.  You can restore them if necessary by performing "make
X     restore," still in the patches directory.
X
X [5] Do one of "make bsd43," "make bsd42," or "make bsd29" to patch the
X     sendmail source to the required compatibility level.  You will need
X     patch(1), for this or else edit the files by hand.  Look out for
X     rejected patches.
X
X [6] Goto sendmail/src and recompile sendmail.  See that it still works.
X     Your old configuration file should still work unless you depend on
X     some obscure side effects.  Note that a BSD 4.2 configuration file
X     might not work with sendmail 5.11.
X
X [7] Goto sendmail/ida/aux and do "make" to compile the auxiliary
X     programs.  Try them out, guided with the newly printed manual
X     pages.
X
X [8] Do "make install" to install the programs in BINDIR (/usr/local/bin
X     by default; but another choice would be /usr/lib/mail if you only
X     intend to use them with this kit).  It's also about time to
X     (manually) do a (symbolic) link from /usr/ucb/bsmtp to
X     /usr/lib/sendmail if you intend to receive batched SMTP mail.
X
X [9] Goto sendmail/ida/cf and inspect the supplied m4(1) configuration
X     definitions.  Send Sendmail.mc to your line printer and study it.
X     Do "make" to see how the sample configurations look expanded.
X
X[10] Goto sendmail/ida/lib and inspect the supplied sample data files.
X     Try applying the xalparse program on the xaliases file if you feel
X     like it.
X
X[11] Determine your site's routing capabilities and create your corre-
X     sponding data files in LIBDIR.  Go back to sendmail/ida/cf and
X     create your own m4(1) configuration file using the samples as
X     templates.  Produce an actual, personal sendmail.cf file.
X
X[12] Try out your new sendmail system.
X     Good Luck!
END_OF_ida/INSTALL
if test 3311 -ne `wc -c <ida/INSTALL`; then
    echo shar: \"ida/INSTALL\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/README -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/README\"
else
echo shar: Extracting \"ida/README\" \(2773 characters\)
sed "s/^X//" >ida/README <<'END_OF_ida/README'
X#
X#  README -- The IDA Sendmail Enhancement Kit.
X#  Copyright (c) 1987 Lennart Lovstrand
X#  CIS Dept, Univ of Linkoping, Sweden
X#
X#  Use it, abuse it, but don't sell it.
X#
X#  Revision 1.0 of Wed May 27 04:29:05 MET DST 1987
X
X
X	Hello and Welcome to The IDA Sendmail Enhancement Kit.
X
X
XThis Kit includes a set of source code modifications to the BSD 4.3
Xsendmail program (version 5.11), which will enable it to have direct
Xaccess to dbm(3) files, separate envelope/header rewritings, multi-token
Xclass matches, and many other things.  Also included is the IDA Sendmail
XMaster Configuration file and a sample setup used at the CIS Dept, U of
XLinkoping.  The configuration file together with the supplied data files
Xand utility programs, implement such nice features as pathalias based
Xsystems routing within sendmail, fully !-/@-translating rulesets, and
Xgeneric local user addresses.
X
XThe new sendmail functions are breifly listed below and further
Xdescribed in the accompanying paper, which also discusses electronic
Xmail addressing in general and hybrid addresses in particular.  (The
Xnumbers to the right indicate in what section of the paper they are
Xdescribed.)
X
X   Nameserver Default Argument............................... 7.1
X   Direct Access to Dbm(3) Files............................. 7.2
X   Batched SMTP Support...................................... 7.3
X   Separate Envelope/Header Rewriting Rulesets............... 7.4
X   Separate Local UUCP Host Name............................. 7.5
X   Return Path for UUCP Mailers.............................. 7.6
X   UUCP Header Address Relativization........................ 7.7
X   Support for Multi-Token Matches........................... 7.8
X   Support for Embedded Subruleset Calls..................... 7.9
X   Elaborate Matching Algorithm for Unknown Local Recipients 7.10
X   Support for Maryland's Mdbm Package...................... 7.11
X   Improved Test Mode Output................................ 7.12
X   Better To: and Cc: Headers of Returned Messages.......... 7.13
X   Queue Bug Fixed.......................................... 7.14
X   Shared Input SMTP Bug Tentatively Fixed.................. 7.15
X   Optional BSD 2.9 and 4.2 Compatibility Code.............. 7.16
X   Miscellaneous Changes.................................... 7.17
X
XRead more in INSTALL about how to get it all together.  I will probably
Xnot be able to help you much since I am moving to a new job.  I'll do
Xwhat I can, anyway.  My old mail address should hopefully still work, so
Xyou can try writing to:
X
X	Lennart Lovstrand
X	Department of Computer and Information Science
X	University of Linkoping
X	S-581 83 Linkoping, SWEDEN
X
X	<lel@ida.liu.se> or {mcvax,munnari,seismo}!enea!liuida!lel
X
Xif you have comments or bugs to report.
X
XLive well,
X--Lennart
END_OF_ida/README
if test 2773 -ne `wc -c <ida/README`; then
    echo shar: \"ida/README\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/doc/dbm.1 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/doc/dbm.1\"
else
echo shar: Extracting \"ida/doc/dbm.1\" \(4959 characters\)
sed "s/^X//" >ida/doc/dbm.1 <<'END_OF_ida/doc/dbm.1'
X.TH DBM 1 "24 April 1987"				\" -*- nroff -*-
X.SH NAME
Xdbm \- general
X.IR dbm (3)
Xdatabase management tool
X.SH SYNOPSIS
X.BR dbm
X.RB [\| \-AILNRSU \|]
X.RB [\| \-d
X.IR dbm_file \|]
X.RB [\| \-m
X.IR mode \|]
X.RB [\| \-o 
X.IR output_file \|]
X.I command
X.RI [\| args\|.\|.\|. \|]
X.SH DESCRIPTION
X.I Dbm
Xis used to manage
X.IR dbm (3)
Xtype databases.  Its function is controlled by the dbm
X.I command
Xgiven on the command line, possibly with additional arguments.  Its
Xtypical usage is to load a
X.I dbm
Xdatabase from a input file or to dump it to a readable format.  It may
Xalso be used to probe for selected keys or add specific key/value pairs. 
XIn addition,
X.I dbm
Xprovides parsing routines for an extended textual format, suitable for
Xbuilding tables or various kinds.  The format is further described in
Xthe section about the
X.B parse
Xcommand below. 
X.SH OPTIONS
X.TP
X.B \-A
XAppend mode, don't automatically clear the database on the
X.BR load
Xand
X.B make
Xoperations. 
X.TP
X.B \-I
XInsert mode; will supply the \s-1DBM_INSERT\s+1 flag to all
X.I dbm_store
Xoperations.  This means that if two entries with equal keys are given,
Xonly the first will actually be entered to the database (default) and no
Xwarning will be given. 
X.TP
X.B \-L
XLowercase mode.  Change all keys to lowercase before reading from or writing
Xto the database.
X.TP
X.B \-R
XReplace mode; will supply the \s-1DBM_REPLACE\s+1 flag to all
X.I dbm_store
Xoperations.  This means that if two entries with equal keys are given,
Xonly the last will actually be entered to the database and no warning
Xmessages are given. 
X.TP
X.B \-S
XAdd a
X.B @@@
Xsenteniel after the last entry has been written to the database. 
X.TP
X.B \-U
XUppercase mode.  Turn all keys to uppercase before reading from or
Xwriting to the database.
X.TP
X.BI \-d " dbm_file"
XPerform all operations on the named database file.  If no
X.B \-d
Xoption is given, the last argument after the
X.I command
Xwill be used as the
X.IR dbm_file. 
X.TP
X.BI \-m " mode"
XUse the given
X.I mode
Xwhen creating new databases. 
X.TP
X.BI \-o " output_file"
XSend all output from the
X.B dump
Xand
X.B parse
Xoperations to the named output file instead of stdout. 
X.SH COMMANDS
X.PP
X.TP
X.B clear
XCreats an empty
X.I dbm
Xdatabase, either by clearing an old one or by creating a new.
X.TP
X.BR delete " key \fR[\|.\|.\|.\|]\fP"
XRemoves entries with the specified keys from the database.
X.TP
X.B dump
XDumps the
X.I dbm
Xdatabase to stdout (or to
X.IR output_file ,
Xif the 
X.B \-o
Xoption is used).  The output will consist of one entry per line with a
Xtab between each key and value. 
X.TP
X.BI fetch " key \fR[\|.\|.\|.\|]\fP"
X.B Fetch
Xwill search for the
X.I key
Xin the database and print both key and value in
X.B dump
Xformat if found on the standard output.  Non-existing
X.IR keys
Xwill be signalled by a [\s-1NOT_FOUND\s+1] message. 
X.TP
X.BR load " [\|\fIfile\fP\|.\|.\|.\|]"
XLoad the database with entries from the specified
X.IR files .
XIf no
X.I files
Xare given or if a file is specified as `-', the database will be loaded
Xfrom standard input.  Each line of the file should have a key and value
Xseparated by a tab.  (Incidentally, this is the same format as
X.B dump
Xand
X.IR pathalias (1)
Xwill produce.)  The database is first cleared unless the append
X(\fB\-A\fP) switch has been given. 
X.TP
X.BR make " [\|\fIfile\fP\|.\|.\|.\|]"
X.B Make
Xcombines the operations of
X.B parse
Xand
X.BR load
X(q.v.), by storing each record after it has been parsed. 
X.TP
X.BR parse " [\|\fIfile\fP\|.\|.\|.\|]"
XThis command will parse the contents of the specified
X.IR files
X(or stdin if no
X.I files
Xare given or when a file is `-'), according to the following syntax:
X.in +\n()Iu
Xvalue key key .\|.\|. 
X.in -\n()Iu
XWhitespace delimit tokens and sharp signs (\fB#\fP) anywhere on a line
Xbegins comments unless any of them are quoted by a backslash (\fB\\\fP)
Xor put inside double quotes (\fB"\fP\|.\|.\|.\|\fB"\fP) or angle
Xbrackets (\fB<\fP\|.\|.\|.\|\fB>\fP).  Lines beginning with whitespace
Xare considered to be continuations of the previous line.
X.TP
X.BI store " key value \fR[\|\fI key value \fR\|.\|.\|.\|]\fI"
XStore one or more key/value pairs explicitly mentioned on the command
Xline.
X.SH EXAMPLES
X.nf
X.ta \w'dbm parse xfile | dbm -AI load foo'u+6n
Xdbm -d foo clear	\fIcreate the database foo\fP
Xcat infile | dbm load foo	\fIload it from the infile\fP
Xdbm parse xfile | dbm -AI load foo	\fIadd keys from the xfile...\fP
X.I "(or, shorter)	\fI...not already present...\fP"
Xdbm -I make xfile foo	\fI...in the database\fP
Xdbm fetch keya keyb foo	\fIfetch values for the keys\fP
Xdbm -R store keyc valuec foo	\fIoverwrite previous value for keyc\fP
X.fi
X.SH AUTHOR
X.nf
XLennart Lovstrand <lel@ida.liu.se>
XCIS Dept, Univ of Linkoping, Sweden
X.fi
X.SH "SEE ALSO"
X.IR pathalias (1),
X.IR dbm (3),
X.IR ndbm (3)
X.SH BUGS
XShould probably remove the senteniel when opening the database for write
Xaccess (provided that the
X.B \-S
Xflag has been given).
X.br
XRequires
X.IR ndbm (3)
Xor
X.IR mdbm (3)
Xsupport for no real reason. 
END_OF_ida/doc/dbm.1
if test 4959 -ne `wc -c <ida/doc/dbm.1`; then
    echo shar: \"ida/doc/dbm.1\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/lib/domaintable -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/lib/domaintable\"
else
echo shar: Extracting \"ida/lib/domaintable\" \(4136 characters\)
sed "s/^X//" >ida/lib/domaintable <<'END_OF_ida/lib/domaintable'
X#
X#	Primitive name server table -- version 3.0 of 20-Apr-87
X#
X#	Format is <official-name> <nickname-1> .. <nickname-n>,
X#	where the <nicnames> are optional.  Comments start with
X#	a sharp sign (#).  A line beginning with whitespace is
X#	assumed to be a continuation of the previous line.
X#
X#	The order in which the names are givin is significant;
X#	early entries will hide later entries with coinciding
X#	nicknames.
X#
X
X#	Misc known nodes
X#
X		# Direct UUCP nodes
Xenea.se		enea	enea.UUCP
Xerilin.UUCP	erilin
Xerix.ericsson.se erix	erix.UUCP
Xliutde.UUCP	liutde
Xrainier.UUCP	rainier
X		# UUCP Major Relays & Backbones
Xcbosgd.UUCP	cbosgd
Xcernvax.UUCP	cernvax
Xdecvax.UUCP	decvax
Xdiku.UUCP	diku
Xenea.se		enea	enea.UUCP
Xi2unix.UUCP	i2unix
Xinria.UUCP	inria
Xmcvax.cwi.nl	mcvax	mcvax.UUCP
Xpenet.UUCP	penet
Xprlb2.UUCP	prlb2
Xukc.UUCP	ukc
Xunido.UUCP	unido
Xvmars.UUCP	vmars
X
X#
X#	These are just here to help people through the ARPAnet name change
X#
X
Xseismo.CSS.GOV		SEISMO.ARPA
XHARVARD.HARVARD.EDU	HARVARD.ARPA
Xucbvax.BERKELEY.EDU	UCB-VAX.ARPA
XWISCVM.WISC.EDU		WISCVM.ARPA
XAI.AI.MIT.EDU		MIT-AI.ARPA
XMC.LCS.MIT.EDU		MIT-MC.ARPA
XKL.SRI.COM		SRI-KL.ARPA
XNIC.SRI.COM		SRI-NIC.ARPA
XSAIL.STANFORD.EDU	SU-AI.ARPA
XSCORE.STANFORD.EDU	SU-SCORE.ARPA
XA.CS.CMU.EDU		CMU-CS-A.ARPA
XC.CS.CMU.EDU		CMU-CS-C.ARPA
XR20.UTEXAS.EDU		UTEXAS-20.ARPA
XSALLY.UTEXAS.EDU	UT-SALLY.ARPA
XRELAY.CS.NET		CSNET-RELAY.ARPA
XSUMEX-AIM.STANFORD.EDU	SUMEX-AIM.ARPA
XCSLI.STANFORD.EDU	CSLI.ARPA
XXerox.COM		Xerox.ARPA
X
X#
X#	Nodes within LiU.SE -- The University of Linkoping, Sweden
X#
X			# The IDA domain -- Dept of Comp and Info Science
XIDA.LiU.SE		liuida.UUCP	liuida.liu.se	liuida.ida.liu.se
X			# DECsystems
XALADIN.LiU.SE		ALADIN.SUNET.SE
XCLOVER.LiU.SE		CLOVER.SUNET.SE
XDAISY.LiU.SE		DAISY.SUNET.SE
XELINOR.LiU.SE		ELINOR.SUNET.SE
XHAZEL.LiU.SE		HAZEL.SUNET.SE			HAZEL.IDA.LiU.SE
XJINJIN.LiU.SE		JINJIN.SUNET.SE
XLINA.LiU.SE		LINA.SUNET.SE
XLINNEA.LiU.SE		LINNEA.SUNET.SE
XLINUS.LiU.SE		LINUSE.SUNET.SE			LINUS.IDA.LiU.SE
XLISBET.LiU.SE		LISBET.SUNET.SE			LISBET.IDA.LiU.SE
XLUDVIG.LiU.SE		LUDVIG.SUNET.SE
XMINMIN.LiU.SE		MINMIN.SUNET.SE
XP13L00.LiU.SE		P13L00.SUNET.SE
XTURTLE.LiU.SE		TURTLE.SUNET.SE
XVIKTOR.LiU.SE		VIKTOR.SUNET.SE
XWEIWEI.LiU.SE		WEIWEI.SUNET.SE
X			# Unix systems
Xasterix.liu.se		asterix.liu.uucp		asterix.ida.liu.se
Xcrabbofix.liu.se					crabbofix.ida.liu.se
Xlillefix.liu.se						lillefix.ida.li
u.se
Xmajestix.liu.se						majestix.ida.li
u.se
Xmiraculix.liu.se					miraculix.ida.liu.se
Xobelix.liu.se		obelix.UUCP obelix.liu.uucp	obelix.ida.liu.se
Xportofix.liu.se						portofix.ida.li
u.se
Xprefix.liu.se						prefix.ida.liu.se
Xsenilix.liu.se						senilix.ida.liu.se
Xsmidefix.liu.se						smidefix.ida.li
u.se
Xtragicomix.liu.se					tragicomix.ida.liu.se
X
X#	Nodes within QZ.SE -- The Stockholm University Computing Center
X#
XFREJA.QZ.SE		FREJA.SUNET.SE
X
X#	Nodes within UU.SE -- University of Uppsala, Sweden
X#
XAIDA.UU.SE		AIDA.SUNET.SE			AIDA.UPPSALA.SE
XBMC1.UU.SE		BMC1.SUNET.SE
XCARMEN.UU.SE		CARMEN.SUNET.SE			CARMEN.UPPSALA.SE
XCARTUS.UU.SE		CARTUS.SUNET.SE
XCELL.UU.SE		CELL.SUNET.SE
XESCIL.UU.SE		ESCIL.SUNET.SE
Xemil.uu.se
XEVA.UU.SE		EVA.SUNET.SE
XFARFAR.UU.SE		FARFAR.SUNET.SE
XGRAPH.UU.SE		GRAPH.SUNET.SE
XGWAX1.UU.SE		GWAX1.SUNET.SE
XGWAX2.UU.SE		GWAX2.SUNET.SE
XIMMUNA.UU.SE		IMMUNA.SUNET.SE
XIMUNIS.UU.SE		IMUNIS.SUNET.SE
XKEMIST.UU.SE		KEMIST.SUNET.SE
Xkuling.uu.se		kuling.UUCP			kuling.uppsala.se
XKVAX1.UU.SE		KVAX1.SUNET.SE
XKVAX2.UU.SE		KVAX2.SUNET.SE
XLABAN.UU.SE		LABAN.SUNET.SE
XLAPSE.UU.SE		LAPSE.SUNET.SE
XMAJA.UU.SE		MAJA.SUNET.SE
XMALIN.UU.SE		MALIN.SUNET.SE
XMAX.UU.SE		MAX.SUNET.SE			MAX.UPPSALA.SE
XMINC.UU.SE		MINC.SUNET.SE
XNIMBUS.UU.SE		NIMBUS.SUNET.SE
Xnumax.uu.se
XPAX.UU.SE		PAX.SUNET.SE
XPELLE.UU.SE		PELLE.SUNET.SE
XPICTOR.UU.SE		PICTOR.SUNET.SE
XRTR18A.UU.SE		RTR18A.SUNET.SE
XSIGURD.UU.SE		SIGURD.SUNET.SE
XSILVER.UU.SE		SILVER.SUNET.SE
XTEKLA.UU.SE		TEKLA.SUNET.SE
XTLU.UU.SE		TLU.SUNET.SE
XXRAY.UU.SE		XRAY.SUNET.SE
X
X#	Nodes within LU.SE -- Universtiy of Lund, Sweden
X#
XAGATON.LU.SE		AGATON.SUNET.SE
XPANDOR.LU.SE		PANDOR.SUNET.SE
X
X#	Nodes within SUNET.SE -- The Swedish University Network (DECnet)
X#	are automatically inserted here.
X
XATHENA.SUNET.SE		# This one is not in the DECnet tables
END_OF_ida/lib/domaintable
if test 4136 -ne `wc -c <ida/lib/domaintable`; then
    echo shar: \"ida/lib/domaintable\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/lib/pathtable -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/lib/pathtable\"
else
echo shar: Extracting \"ida/lib/pathtable\" \(3889 characters\)
sed "s/^X//" >ida/lib/pathtable <<'END_OF_ida/lib/pathtable'
X#########################################################################
X###  Pathalias Route Database	##############################  v3.0  ###
X#########################################################################
X# Edited by Lennart.Lovstrand@IDA.LiU.SE Fri Apr 17 19:37:39 MET DST 1987
X
X###				#########################################
X#	Special Links							#
X###				#########################################
X
Xasterix.liu.se		obelix.liu.se(DIRECT)		# UUCP/TTY
Xmajestix.liu.se		alp.UUCP(DAILY),		# UUCP/modem-12
00
X			enea.se(DEMAND),		# UUCP/modem-2400
X			erilin.UUCP(DIRECT),		# UUCP/modem-2400
X			erix.UUCP(DEMAND),		# UUCP/modem-2400
X			kuling.uu.se(HOURLY),		# UUCP/modem-2400?
X			liutde.UUCP(DAILY),		# UUCP/modem-1200
X			prosys.UUCP(HOURLY),		# UUCP/modem-2400
X			rainier.UUCP(HOURLY),		# UUCP/modem-2400?
X			ida.liu.se(0),			# via aliases dbm
X			IDA-TCP-NET			# SMTP/TCP-IP
Xrainier.UUCP		carola.UUCP, adams.UUCP		# SMTP/TCP-IP
Xaida.uu.se		carmen.uu.se			# Cafard/TTY
Xathena.sunet.se		aida.uu.se			# Cafard/UPNET
X
X
X###				#########################################
X#	Physical Networks						#
X###				#########################################
X
XIDA-TCP-NET = {
X	asterix.liu.se,		# Gould
X	crabbofix.liu.se,	# Sun-3/75M
X	lillefix.liu.se,	# Sun-3/52
X	lisbet.liu.se,		# DEC-2060
X	majestix.liu.se,	# Sun-3/160 FS
X	miraculix.liu.se,	# Sun-3/75C
X	portofix.liu.se,	# Sun-3/75M
X	prefix.liu.se,		# Sun-3/75M
X	senilix.liu.se,		# Sun-3/75M
X	smidefix.liu.se,	# Sun-3/75M
X	tragicomix.liu.se}	# Sun-3/75M
X
X##  The SUNET-xx definitions includes only nodes that know about DECnet
X##  area addressing.
X
XSUNET = {
X	.sunet.se, SUNET-08, SUNET-13, SUNET-18, SUNET-46}
X
XSUNET-08 = {
X	freja.qz.se, vera.sunet.se}
X
XSUNET-13 = {
X	aladin.liu.se, clover.liu.se, daisy.liu.se, elinor.liu.se,
X	hazel.liu.se, jinjin.liu.se, lina.liu.se, linus.liu.se,
X	linnea.liu.se, lisbet.liu.se, liuida.sunet.se, ludvig.liu.se,
X	minmin.liu.se, p13l00.liu.se, turtle.liu.se, viktor.liu.se,
X	weiwei.liu.se}
X
XSUNET-18 = {
X	malin.uu.se, tekla.uu.se, cartus.uu.se, pelle.uu.se, pictor.uu.se,
X	tlu.uu.se, max.uu.se, kvax1.uu.se, kvax2.uu.se, sigurd.uu.se,
X	escil.uu.se, gwax1.uu.se, gwax2.uu.se, kemist.uu.se, cell.uu.se,
X	minc.uu.se, silver.uu.se, lapse.uu.se, maja.uu.se, rtr18a.uu.se,
X	imunis.uu.se, xray.uu.se, graph.uu.se, immuna.uu.se, bmc1.uu.se,
X	farfar.uu.se, eva.uu.se, nimbus.uu.se, laban.uu.se, pax.uu.se}
X
XSUNET-46 = {
X	agaton.lu.se, pandor.lu.se}
X
X##  DECNET-xx defintions include both area-addressing nodes (which
X##  may serve as gateways) and non-area-addressing nodes.
X
XDECNET-08 = {
X	athena.sunet.se, freja.qz.se, vera.sunet.se}
X
X
X###				#########################################
X#	Domain Gateways							#
X###				#########################################
X
Xenea.se		.ARPA, .BITNET, .CSNET, .DEC, .JUNET, .MAILNET, .UUCP,
X		.com, .edu, .gov, .mil, .net, .org,
X		.au, .ca, .de, .fi, .fr, .gb, .il, .jp, .kr, .nl, .no, .nz,
X		.se, .uk, .us,
X		.cdn, .oz
Xerix.UUCP	.ericsson, .ericsson.se
Xlisbet.liu.se	.sunet.se
Xliuida.sunet.se	.psi
Xmajestix.liu.se	.liu, .liu.se, .ida, .ida.liu, .ida.liu.se,
X		.qz, .qz.se, .uu, .uu.se, .uppsala, .uppsala.se
Xnta-vax.ARPA	.Uninett
X
X
X###				#########################################
X#	Implicit links							#
X###				#########################################
X
Xenea.se			calgary.UUCP, relay.cs.net, nta-vax.ARPA,
X			uoregon.UUCP, ohio-state.arpa
Xlisbet.liu.se		freja.qz.se
X
X###				#########################################
X#	Other explict links						#
X###				#########################################
X
Xkuling.uu.se		emil.uu.se
Xrelay.cs.net		csri.toronto.edu, isc.intel.com
Xuoregon.UUCP		drizzle.UUCP
Xcalgary.UUCP		vuw90x.UUCP
Xohio-state.arpa		OSU-20.OHIO-STATE.EDU
X
X###				#########################################
X#	Useful synonyms							#
X###				#########################################
X
Xida.liu.se	= liuida.UUCP
Xobelix.liu.se	= obelix.UUCP
X.ericsson	= .erix
X.ericsson.se	= .erix.se
END_OF_ida/lib/pathtable
if test 3889 -ne `wc -c <ida/lib/pathtable`; then
    echo shar: \"ida/lib/pathtable\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/BSD29.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/BSD29.diff\"
else
echo shar: Extracting \"ida/patches/BSD29.diff\" \(3463 characters\)
sed "s/^X//" >ida/patches/BSD29.diff <<'END_OF_ida/patches/BSD29.diff'
X*** conf.c.old	Wed May 27 04:04:08 1987
X--- conf.c	Wed May 27 04:05:00 1987
X***************
X*** 556,562 ****
X  
X  #ifdef VMUNIX
X  
X! #include <nlist.h>
X  
X  struct	nlist Nl[] =
X  {
X--- 556,566 ----
X  
X  #ifdef VMUNIX
X  
X! #ifdef BSD29
X! #  include <a.out.h>
X! #else BSD29
X! #  include <nlist.h>
X! #endif BSD29
X  
X  struct	nlist Nl[] =
X  {
X***************
X*** 581,587 ****
X--- 585,595 ----
X  		if (kmem < 0)
X  			return (-1);
X  		(void) ioctl(kmem, (int) FIOCLEX, (char *) 0);
X+ #ifdef BSD29
X+ 		nlist("/unix", Nl);
X+ #else BSD29
X  		nlist("/vmunix", Nl);
X+ #endif BSD29
X  		if (Nl[0].n_type == 0)
X  			return (-1);
X  	}
X***************
X*** 691,699 ****
X  **		Picks up extant zombies.
X  */
X  
X! # ifdef VMUNIX
X  # include <sys/wait.h>
X! # endif VMUNIX
X  
X  reapchild()
X  {
X--- 699,707 ----
X  **		Picks up extant zombies.
X  */
X  
X! # if defined(VMUNIX) && !defined(BSD29)
X  # include <sys/wait.h>
X! # endif VMUNIX && !BSD29
X  
X  reapchild()
X  {
X*** daemon.c.old	Wed May 27 01:46:56 1987
X--- daemon.c	Wed May 27 02:51:55 1987
X***************
X*** 553,564 ****
X  	register FILE *f;
X  
X  	hostbuf[0] = '\0';
X! 	f = fopen("/usr/include/whoami", "r");
X! 	if (f != NULL)
X  	{
X! 		(void) fgets(hostbuf, size, f);
X! 		fixcrlf(hostbuf, TRUE);
X! 		(void) fclose(f);
X  	}
X  	return (NULL);
X  }
X--- 553,569 ----
X  	register FILE *f;
X  
X  	hostbuf[0] = '\0';
X! #ifdef BSD29
X! 	if (gethostname(hostbuf, size) < 0)
X! #endif BSD29
X  	{
X! 		f = fopen("/usr/include/whoami", "r");
X! 		if (f != NULL)
X! 		{
X! 			(void) fgets(hostbuf, size, f);
X! 			fixcrlf(hostbuf, TRUE);
X! 			(void) fclose(f);
X! 		}
X  	}
X  	return (NULL);
X  }
X*** deliver.c.old	Wed May 27 01:46:59 1987
X--- deliver.c	Wed May 27 02:51:56 1987
X***************
X*** 16,22 ****
X  # include <errno.h>
X  # include "sendmail.h"
X  # include <sys/stat.h>
X! # include <netdb.h>
X  
X  /*
X  **  Status error messages
X--- 16,24 ----
X  # include <errno.h>
X  # include "sendmail.h"
X  # include <sys/stat.h>
X! # ifndef BSD29
X! #  include <netdb.h>
X! # endif !BSD29
X  
X  /*
X  **  Status error messages
X*** err.c.old	Wed May 27 01:47:01 1987
X--- err.c	Wed May 27 02:52:06 1987
X***************
X*** 14,20 ****
X  
X  # include "sendmail.h"
X  # include <errno.h>
X! # include <netdb.h>
X  
X  /*
X  **  SYSERR -- Print error message.
X--- 14,22 ----
X  
X  # include "sendmail.h"
X  # include <errno.h>
X! # ifndef BSD29
X! #  include <netdb.h>
X! # endif !BSD29
X  
X  /*
X  **  SYSERR -- Print error message.
X*** queue.c.old	Wed May 27 01:47:09 1987
X--- queue.c	Wed May 27 02:27:44 1987
X***************
X*** 11,17 ****
X  
X  # include "sendmail.h"
X  # include <sys/stat.h>
X! # include <sys/dir.h>
X  # include <signal.h>
X  # include <errno.h>
X  
X--- 11,19 ----
X  
X  # include "sendmail.h"
X  # include <sys/stat.h>
X! # ifndef BSD29
X! #  include <sys/dir.h>
X! # endif !BSD29
X  # include <signal.h>
X  # include <errno.h>
X  
X***************
X*** 231,237 ****
X--- 233,243 ----
X  	if (tf != NULL)
X  	{
X  		(void) unlink(qf);
X+ #ifdef BSD29
X+ 		if (link(tf, qf) != 0 || unlink(tf) != 0)
X+ #else BSD29
X  		if (rename(tf, qf) < 0)
X+ #endif BSD29
X  			syserr("cannot unlink(%s, %s), df=%s", tf, qf, e->e_df)
;
X  		errno = 0;
X  	}
X*** sendmail.h.old	Wed May 27 04:13:02 1987
X--- sendmail.h	Wed May 27 04:16:10 1987
X***************
X*** 662,664 ****
X--- 671,682 ----
X  #ifndef LOG_MAIL
X  # define LOG_MAIL	(2<<3)
X  #endif LOG_MAIL
X+ 
X+ /*
X+ **  BSD2.9 Compatibility Code
X+ */
X+ 
X+ #ifdef BSD29
X+ # define EPROCLIM	EAGAIN
X+ # include "../lib/libndir/dir.h"
X+ #endif BSD29
END_OF_ida/patches/BSD29.diff
if test 3463 -ne `wc -c <ida/patches/BSD29.diff`; then
    echo shar: \"ida/patches/BSD29.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/MDBM.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/MDBM.diff\"
else
echo shar: Extracting \"ida/patches/MDBM.diff\" \(3104 characters\)
sed "s/^X//" >ida/patches/MDBM.diff <<'END_OF_ida/patches/MDBM.diff'
X*** alias.c.old	Wed May 27 02:03:20 1987
X--- alias.c	Wed May 27 01:46:52 1987
X***************
X*** 167,175 ****
X  
X  #ifdef NDBM
X  /*
X! **  NDBMINIT -- initialize the ndbm database
X  **
X! **	Only for use with NDBM and the keyed database table.
X  **
X  **	Parameters:
X  **		aliasfile -- name of alias database file
X--- 167,175 ----
X  
X  #ifdef NDBM
X  /*
X! **  NDBMINIT -- initialize the [mn]dbm database
X  **
X! **	Only for use with [MN]DBM and the keyed database table.
X  **
X  **	Parameters:
X  **		aliasfile -- name of alias database file
X***************
X*** 602,607 ****
X--- 602,610 ----
X  	(void) fclose(af);
X  	CurEnv->e_to = NULL;
X  	FileName = NULL;
X+ #ifdef MDBM
X+ 	(void) mdbm_sync(AliasDbm.dbm);
X+ #endif MDBM
X  	message(Arpa_Info, "%d aliases, longest %d bytes, %d bytes total",
X  			naliases, longest, bytes);
X  # ifdef LOG
X*** conf.h.old	Wed May 27 02:07:56 1987
X--- conf.h	Wed May 27 01:53:01 1987
X***************
X*** 42,47 ****
X--- 42,48 ----
X  
X  # define DBM		1	/* use DBM library (requires -ldbm) */
X  # define NDBM		1	/* new DBM library available (requires 
DBM) */
X+ # define MDBM		1	/* subst Maryland's mdbm package for nd
bm */
X  # define DEBUG		1	/* enable debugging */
X  # define LOG		1	/* enable logging */
X  # define SMTP		1	/* enable user and server SMTP */
X*** sendmail.h.old	Wed May 27 01:58:25 1987
X--- sendmail.h	Wed May 27 01:59:12 1987
X***************
X*** 483,489 ****
X   */
X  #define	MAX_ERRNO	100
X  /*
X! **  Database ([n]dbm) definitions.
X  */
X  
X  #ifdef DBM
X--- 483,489 ----
X   */
X  #define	MAX_ERRNO	100
X  /*
X! **  Database ([mn]dbm) definitions.
X  */
X  
X  #ifdef DBM
X***************
X*** 493,507 ****
X  	int	dsize;
X  } DATUM;
X  
X! # define DB_DIREXT	".dir"
X! # define DB_PAGEXT	".pag"
X  
X! # ifdef NDBM
X  
X! #  undef DBM			/* while including ndbm.h */
X! #  include <ndbm.h>		/* DBM is typedef'ed here */
X  typedef DBM DBMFILE;		/* move typedef to DBMFILE */
X! #  define DBM			/* and restore DBM definition */
X  #  include <fcntl.h>		/* needed for dbm_open */
X  
X  #  define DATUM datum		/* use the definition in ndbm.h */
X--- 493,516 ----
X  	int	dsize;
X  } DATUM;
X  
X! # ifdef MDBM
X! #  define DB_DIREXT	".map"
X! #  define DB_PAGEXT	".dat"
X! # else MDBM
X! #  define DB_DIREXT	".dir"
X! #  define DB_PAGEXT	".pag"
X! # endif MDBM
X  
X! # if defined(NDBM) || defined(MDBM)
X  
X! #  ifdef MDBM
X! #   include "mdbm_compat.h"	/* mdbm compatibility file */
X! #  else MDBM
X! #   undef DBM			/* while including ndbm.h */
X! #   include <ndbm.h>		/* DBM is typedef'ed here */
X  typedef DBM DBMFILE;		/* move typedef to DBMFILE */
X! #   define DBM			/* and restore DBM definition */
X! #  endif MDBM
X  #  include <fcntl.h>		/* needed for dbm_open */
X  
X  #  define DATUM datum		/* use the definition in ndbm.h */
X***************
X*** 517,523 ****
X  #  define DB_ALIAS	'@'	/* "name" of aliases database */
X  #  define AliasDbm	DbmTab[DB_ALIAS]
X  
X! # endif NDBM
X  #endif DBM
X  /*
X  **  Global variables.
X--- 526,532 ----
X  #  define DB_ALIAS	'@'	/* "name" of aliases database */
X  #  define AliasDbm	DbmTab[DB_ALIAS]
X  
X! # endif NDBM || MDBM
X  #endif DBM
X  /*
X  **  Global variables.
END_OF_ida/patches/MDBM.diff
if test 3104 -ne `wc -c <ida/patches/MDBM.diff`; then
    echo shar: \"ida/patches/MDBM.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/daemon.c.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/daemon.c.diff\"
else
echo shar: Extracting \"ida/patches/daemon.c.diff\" \(4391 characters\)
sed "s/^X//" >ida/patches/daemon.c.diff <<'END_OF_ida/patches/daemon.c.diff'
X*** daemon.c.orig	Fri Mar 13 18:51:04 1987
X--- daemon.c	Mon May 25 15:55:13 1987
X***************
X*** 481,487 ****
X  **		hbsize -- the size of hbuf.
X  **
X  **	Returns:
X! **		none.
X  **
X  **	Side Effects:
X  **		Looks up the host specified in hbuf.  If it is not
X--- 481,488 ----
X  **		hbsize -- the size of hbuf.
X  **
X  **	Returns:
X! **		An exit code telling if the hostname was found and
X! **		canonicalized.
X  **
X  **	Side Effects:
X  **		Looks up the host specified in hbuf.  If it is not
X***************
X*** 496,501 ****
X--- 497,503 ----
X  {
X  	register struct hostent *hp;
X  	extern struct hostent *gethostbyname();
X+ 	static char tmphbuf[MAXNAME];
X  
X  	/*
X  	**  If first character is a bracket, then it is an address
X***************
X*** 508,520 ****
X  	{
X  		extern struct hostent *gethostbyaddr();
X  		u_long in_addr;
X- 		char ptr[256];
X- 		char *bptr;
X  
X! 		(void) strcpy(ptr, hbuf);
X! 		bptr = index(ptr,']');
X! 		*bptr = '\0';
X! 		in_addr = inet_addr(&ptr[1]);
X  		hp = gethostbyaddr((char *) &in_addr, sizeof(struct in_addr), A
F_INET);
X  		if (hp == NULL)
X  			return;
X--- 510,518 ----
X  	{
X  		extern struct hostent *gethostbyaddr();
X  		u_long in_addr;
X  
X! 		(void) strncpy(tmphbuf, hbuf+1, strlen(hbuf)-2);
X! 		in_addr = inet_addr(tmphbuf);
X  		hp = gethostbyaddr((char *) &in_addr, sizeof(struct in_addr), A
F_INET);
X  		if (hp == NULL)
X  			return;
X***************
X*** 521,528 ****
X  	}
X  	else
X  	{
X! 		makelower(hbuf);
X! 		hp = gethostbyname(hbuf);
X  	}
X  	if (hp != NULL)
X  	{
X--- 519,527 ----
X  	}
X  	else
X  	{
X! 		(void) strcpy(tmphbuf, hbuf);
X! 		makelower(tmphbuf);
X! 		hp = gethostbyname(tmphbuf);
X  	}
X  	if (hp != NULL)
X  	{
X***************
X*** 532,537 ****
X--- 531,537 ----
X  			hp->h_name[--i] = '\0';
X  		(void) strcpy(hbuf, hp->h_name);
X  	}
X+ 	return (hp != NULL);
X  }
X  
X  # else DAEMON
X***************
X*** 584,590 ****
X  	char *hbuf;
X  	int hbsize;
X  {
X! 	return;
X  }
X  
X  #endif DAEMON
X--- 584,691 ----
X  	char *hbuf;
X  	int hbsize;
X  {
X! 	return (FALSE);
X  }
X  
X  #endif DAEMON
X+ 
X+ /*
X+ **  MAPKEY -- Search a dbm database.
X+ **
X+ **	Search the named database using the given key.  If
X+ **	a result is found, sprintf the argument through the
X+ **	result back into the argument and return TRUE;
X+ **	otherwise return FALSE and do nothing.
X+ **
X+ **	Parameters:
X+ **		key -- search string
X+ **		argval -- sprintf argument & result
X+ **		argsiz -- size of argval
X+ **
X+ **	Returns:
X+ **		An exit code telling if there was a match.
X+ **
X+ **	Side Effects:
X+ **		The argval is rewritten to reflect what was found
X+ **		in the database.
X+ */
X+ 
X+ #ifdef NDBM
X+ 
X+ mapkey(db, key, keysiz, arg)
X+     char db, *key, *arg;
X+     int keysiz;
X+ {
X+     DATUM dkey, result;
X+     static char lowkey[MAXNAME];
X+ 
X+ #ifdef DEBUG
X+     if (tTd(60, 1))
X+ 	printf("mapkey(`%c', \"%s\", \"%s\") => ", db, key, arg);
X+ #endif DEBUG
X+ 
X+     if (DbmTab[db].name == NULL) {
X+ 	syserr("database `%c' has not been defined", db);
X+ 	return FALSE;
X+     }
X+ 
X+     if (DbmTab[db].dbm == DB_NOSUCHFILE) {
X+ #ifdef DEBUG
X+ 	if (tTd(60, 1))
X+ 	    printf("NO_FILE\n");
X+ #endif DEBUG
X+ 	return FALSE;
X+     }
X+ 
X+     if (DbmTab[db].dbm == DB_NOTYETOPEN)
X+ 	DbmTab[db].dbm = dbm_open(DbmTab[db].name, O_RDONLY, 0);
X+ 
X+     if (DbmTab[db].dbm == DB_NOSUCHFILE) {
X+ 	syserr("can't open database `%c' [%s]", db, DbmTab[db].name);
X+ #ifdef DEBUG
X+ 	if (tTd(60, 1))
X+ 	    printf("CAN'T OPEN %s\n", DbmTab[db].name);
X+ #endif DEBUG
X+ 	return FALSE;
X+     }
X+ 
X+     (void) strcpy(lowkey, key);
X+     makelower(lowkey);
X+     dkey.dptr = lowkey;
X+     dkey.dsize = strlen(dkey.dptr) + 1;
X+ 
X+     result = dbm_fetch(DbmTab[db].dbm, dkey);
X+     if (result.dptr == NULL) {
X+ #ifdef DEBUG
X+ 	if (tTd(60, 1))
X+ 	    printf("NOT_FOUND\n");
X+ #endif DEBUG
X+ 	return FALSE;
X+     }
X+ 
X+     /* very crude & approximate length check */
X+     if (strlen(result.dptr) +
X+ 	(index(result.dptr, '%') == NULL ? 0 : strlen(arg)) > keysiz)
X+ 	syserr("mapkey: result \"%s\" too long after expansion (%d chars max)",
X+ 	       result.dptr, keysiz);
X+     else
X+ 	(void) sprintf(key, result.dptr, arg);
X+ 
X+ #ifdef DEBUG
X+     if (tTd(60, 1))
X+ 	printf("%s\n", key);
X+ #endif DEBUG
X+     return TRUE;
X+ }
X+ 
X+ #else NDBM
X+ 
X+ /* should really read the table into the stab instead */
X+ mapkey(db, key, keysiz, arg)
X+     char db, *key, *arg;
X+     int keysiz;
X+ {
X+     return FALSE;
X+ }
X+ 
X+ #endif NDBM
END_OF_ida/patches/daemon.c.diff
if test 4391 -ne `wc -c <ida/patches/daemon.c.diff`; then
    echo shar: \"ida/patches/daemon.c.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/deliver.c.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/deliver.c.diff\"
else
echo shar: Extracting \"ida/patches/deliver.c.diff\" \(4822 characters\)
sed "s/^X//" >ida/patches/deliver.c.diff <<'END_OF_ida/patches/deliver.c.diff'
X*** deliver.c.orig	Fri Mar 13 18:51:05 1987
X--- deliver.c	Mon May 25 15:55:16 1987
X***************
X*** 19,24 ****
X--- 19,62 ----
X  # include <netdb.h>
X  
X  /*
X+ **  Status error messages
X+ */
X+ 
X+ 
X+ #define MAXENDERR	(sizeof(Enderr) / sizeof(*Enderr))
X+ char *Enderr[] = {
X+ 	"IMPOSSIBLE",
X+ 	"hangup",
X+ 	"interrupt",
X+ 	"quit",
X+ 	"illegal instruction",
X+ 	"trace trap",
X+ 	"IOT instruction",
X+ 	"EMT instruction",
X+ 	"floating point exception",
X+ 	"kill",
X+ 	"bus error",
X+ 	"segmentation violation",
X+ 	"bad argument to system call",
X+ 	"write on a pipe with no one to read it",
X+ 	"alarm clock",
X+ 	"software termination signal",
X+ 	"urgent condition present on socket",
X+ 	"stop",
X+ 	"stop signal generated from keyboard",
X+ 	"continue after stop",
X+ 	"child status has changed",
X+ 	"background read attempted from control terminal",
X+ 	"background write attempted to control terminal",
X+ 	"I/O is possible on a descriptor",
X+ 	"cpu time limit exceeded",
X+ 	"file size limit exceeded",
X+ 	"virtual time alarm",
X+ 	"profiling timer alarm",
X+ 	"window changed"
X+ };
X+ 
X+ /*
X  **  DELIVER -- Deliver a message to a list of addresses.
X  **
X  **	This routine delivers to everyone on the same host as the
X***************
X*** 116,122 ****
X  
X  	/* rewrite from address, using rewriting rules */
X  	expand("\001f", buf, &buf[sizeof buf - 1], e);
X! 	(void) strcpy(tfrombuf, remotename(buf, m, TRUE, TRUE));
X  
X  	define('g', tfrombuf, e);		/* translated sender address */
X  	define('h', host, e);			/* to host */
X--- 154,160 ----
X  
X  	/* rewrite from address, using rewriting rules */
X  	expand("\001f", buf, &buf[sizeof buf - 1], e);
X! 	(void) strcpy(tfrombuf, remotename(buf, m, TRUE, TRUE, FALSE));
X  
X  	define('g', tfrombuf, e);		/* translated sender address */
X  	define('h', host, e);			/* to host */
X***************
X*** 354,360 ****
X  	**	If we are running SMTP, we just need to clean up.
X  	*/
X  
X! 	message(Arpa_Info, "Connecting to %s.%s...", host, m->m_name);
X  
X  	if (ctladdr == NULL)
X  		ctladdr = &e->e_from;
X--- 392,398 ----
X  	**	If we are running SMTP, we just need to clean up.
X  	*/
X  
X! 	message(Arpa_Info, "Connecting to %s.#%s...", host, m->m_name);
X  
X  	if (ctladdr == NULL)
X  		ctladdr = &e->e_from;
X***************
X*** 629,635 ****
X  	/* see if it died a horrid death */
X  	if ((st & 0377) != 0)
X  	{
X! 		syserr("mailer %s died with signal %o", name, st);
X  		ExitStat = EX_TEMPFAIL;
X  		return (EX_TEMPFAIL);
X  	}
X--- 667,675 ----
X  	/* see if it died a horrid death */
X  	if ((st & 0377) != 0)
X  	{
X! 		syserr("%s died because of %s (%d)--requeueing message",
X! 		       name, ((st >= 0) && (st < MAXENDERR)) ?
X! 		       Enderr[st] : "unknown error code", st);
X  		ExitStat = EX_TEMPFAIL;
X  		return (EX_TEMPFAIL);
X  	}
X***************
X*** 1061,1092 ****
X  	register FILE *fp;
X  	register MAILER *m;
X  {
X! 	char *template = "\001l\n";
X  	char buf[MAXLINE];
X  
X  	if (bitnset(M_NHDR, m->m_flags))
X  		return;
X  
X  # ifdef UGLYUUCP
X  	if (bitnset(M_UGLYUUCP, m->m_flags))
X  	{
X  		char *bang;
X- 		char xbuf[MAXLINE];
X  
X  		expand("\001g", buf, &buf[sizeof buf - 1], CurEnv);
X  		bang = index(buf, '!');
X  		if (bang == NULL)
X! 			syserr("No ! in UUCP! (%s)", buf);
X  		else
X  		{
X  			*bang++ = '\0';
X! 			(void) sprintf(xbuf, "From %s  \001d remote from %s\n",
 bang, buf);
X! 			template = xbuf;
X  		}
X  	}
X  # endif UGLYUUCP
X  	expand(template, buf, &buf[sizeof buf - 1], CurEnv);
X  	putline(buf, fp, m);
X  }
X  /*
X  **  PUTBODY -- put the body of a message.
X--- 1101,1154 ----
X  	register FILE *fp;
X  	register MAILER *m;
X  {
X! 	extern char *macvalue();
X! 	char *oldg = macvalue('g', CurEnv);
X! 	char template[MAXLINE];
X! 	char newg[MAXLINE];
X  	char buf[MAXLINE];
X  
X+ 	strcpy(template, "\001l\n");
X+ 
X  	if (bitnset(M_NHDR, m->m_flags))
X  		return;
X  
X+ 	/* construct path through us if needed */
X+ 	if (bitnset(M_FROMPATH, m->m_flags)) {
X+ 		char myname[MAXLINE];
X+ 
X+ 		expand("\001k", myname, &myname[sizeof myname - 1], CurEnv);
X+ 		if (index(oldg, '!') == NULL
X+ 		    || strncmp(oldg, myname, strlen(myname)) != 0) {
X+ 			sprintf(newg, "%s!%s", myname, oldg);
X+ 			define('g', newg, CurEnv);
X+ 		}
X+ 	}
X+ 
X  # ifdef UGLYUUCP
X  	if (bitnset(M_UGLYUUCP, m->m_flags))
X  	{
X  		char *bang;
X  
X  		expand("\001g", buf, &buf[sizeof buf - 1], CurEnv);
X  		bang = index(buf, '!');
X  		if (bang == NULL)
X! 			syserr("No `!' in UUCP envelope from address! (%s)",
X! 			       buf);
X  		else
X  		{
X  			*bang++ = '\0';
X! 			(void) sprintf(template,
X! 				       "From %s  \001d remote from %s\n",
X! 				       bang, buf);
X  		}
X  	}
X  # endif UGLYUUCP
X  	expand(template, buf, &buf[sizeof buf - 1], CurEnv);
X  	putline(buf, fp, m);
X+ 
X+ 	/* redefine old from address */
X+ 	if (bitnset(M_FROMPATH, m->m_flags))
X+ 		define('g', oldg, CurEnv);
X  }
X  /*
X  **  PUTBODY -- put the body of a message.
END_OF_ida/patches/deliver.c.diff
if test 4822 -ne `wc -c <ida/patches/deliver.c.diff`; then
    echo shar: \"ida/patches/deliver.c.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/main.c.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/main.c.diff\"
else
echo shar: Extracting \"ida/patches/main.c.diff\" \(3868 characters\)
sed "s/^X//" >ida/patches/main.c.diff <<'END_OF_ida/patches/main.c.diff'
X*** main.c.orig	Fri Mar 13 18:51:06 1987
X--- main.c	Mon May 25 15:55:19 1987
X***************
X*** 179,184 ****
X--- 179,192 ----
X  		}
X  		else if (strncmp(p, "-bz", 3) == 0)
X  			nothaw = TRUE;
X+ 		else if (strncmp(p, "-Z", 2) == 0)
X+ 		{
X+ 			FreezeFile = &p[2];
X+ 			if (FreezeFile[0] == '\0')
X+ 				FreezeFile = "sendmail.fc";
X+ 			(void) setgid(getrgid());
X+ 			(void) setuid(getruid());
X+ 		}
X  # ifdef DEBUG
X  		else if (strncmp(p, "-d", 2) == 0)
X  		{
X***************
X*** 250,255 ****
X--- 258,264 ----
X  #endif DEBUG
X  			p = newstr(jbuf);
X  			define('w', p, CurEnv);
X+ 			define('k', p, CurEnv);
X  			setclass('w', p);
X  		}
X  		while (av != NULL && *av != NULL)
X***************
X*** 282,287 ****
X--- 291,298 ----
X  		OpMode = MD_PRINT;
X  	else if (strcmp(p, "smtpd") == 0)
X  		OpMode = MD_DAEMON;
X+ 	else if (strcmp(p, "bsmtp") == 0)
X+ 		OpMode = MD_BSMTP;
X  	while ((p = *++av) != NULL && p[0] == '-')
X  	{
X  		switch (p[1])
X***************
X*** 295,300 ****
X--- 306,312 ----
X  				break;
X  # endif DAEMON
X  			  case MD_SMTP:
X+ 			  case MD_BSMTP:
X  # ifndef SMTP
X  				syserr("I don't speak SMTP");
X  				break;
X***************
X*** 318,323 ****
X--- 330,338 ----
X  		  case 'C':	/* select configuration file (already done) */
X  			break;
X  
X+ 		  case 'Z':	/* select frozen config file (already done) */
X+ 			break;
X+ 
X  # ifdef DEBUG
X  		  case 'd':	/* debugging -- redo in case frozen */
X  			tTsetup(tTdvect, sizeof tTdvect, "0-99.1");
X***************
X*** 514,522 ****
X  
X  			if (m == NULL)
X  				continue;
X! 			printf("mailer %d (%s): P=%s S=%d R=%d M=%ld F=", i, m-
>m_name,
X! 				m->m_mailer, m->m_s_rwset, m->m_r_rwset,
X! 				m->m_maxsize);
X  			for (j = '\0'; j <= '\177'; j++)
X  				if (bitnset(j, m->m_flags))
X  					(void) putchar(j);
X--- 529,538 ----
X  
X  			if (m == NULL)
X  				continue;
X! 			printf("mailer %d (%s): P=%s S=%d/%d R=%d/%d M=%ld F=",
X! 				i, m->m_name, m->m_mailer,
X! 				m->m_se_rwset, m->m_sh_rwset,
X! 				m->m_re_rwset, m->m_rh_rwset, m->m_maxsize);
X  			for (j = '\0'; j <= '\177'; j++)
X  				if (bitnset(j, m->m_flags))
X  					(void) putchar(j);
X***************
X*** 543,548 ****
X--- 559,565 ----
X  		char buf[MAXLINE];
X  
X  		printf("ADDRESS TEST MODE\nEnter <ruleset> <address>\n");
X+ 		printf("[Note: No initial ruleset 3 call]\n");
X  		for (;;)
X  		{
X  			register char **pvp;
X***************
X*** 569,575 ****
X  				pvp = prescan(++p, ',', pvpbuf);
X  				if (pvp == NULL)
X  					continue;
X! 				rewrite(pvp, 3);
X  				p = q;
X  				while (*p != '\0')
X  				{
X--- 586,592 ----
X  				pvp = prescan(++p, ',', pvpbuf);
X  				if (pvp == NULL)
X  					continue;
X! 				/* rewrite(pvp, 3); */
X  				p = q;
X  				while (*p != '\0')
X  				{
X***************
X*** 647,654 ****
X  	**  commands.  This will never return.
X  	*/
X  
X! 	if (OpMode == MD_SMTP)
X! 		smtp();
X  # endif SMTP
X  
X  	/*
X--- 664,676 ----
X  	**  commands.  This will never return.
X  	*/
X  
X! 	if (OpMode == MD_SMTP || OpMode == MD_BSMTP) {
X! 		bool batched = (OpMode == MD_BSMTP);
X! 		OpMode = MD_SMTP;
X! 		/* have to run unbuffered or else will lose synchronization */
X! 		setbuf(InChannel, (char *) NULL);
X! 		smtp(batched);
X! 	}
X  # endif SMTP
X  
X  	/*
X***************
X*** 787,798 ****
X  **		initializes several macros to be themselves.
X  */
X  
X- struct metamac
X- {
X- 	char	metaname;
X- 	char	metaval;
X- };
X- 
X  struct metamac	MetaMacros[] =
X  {
X  	/* LHS pattern matching characters */
X--- 809,814 ----
X***************
X*** 805,812 ****
X  	/* the conditional operations */
X  	'?', CONDIF,	'|', CONDELSE,	'.', CONDFI,
X  
X! 	/* and finally the hostname lookup characters */
X  	'[', HOSTBEGIN,	']', HOSTEND,
X  
X  	'\0'
X  };
X--- 821,829 ----
X  	/* the conditional operations */
X  	'?', CONDIF,	'|', CONDELSE,	'.', CONDFI,
X  
X! 	/* and finally the hostname and database lookup characters */
X  	'[', HOSTBEGIN,	']', HOSTEND,
X+ 	'(', KEYBEGIN,	')', KEYEND,
X  
X  	'\0'
X  };
END_OF_ida/patches/main.c.diff
if test 3868 -ne `wc -c <ida/patches/main.c.diff`; then
    echo shar: \"ida/patches/main.c.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/recipient.c.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/recipient.c.diff\"
else
echo shar: Extracting \"ida/patches/recipient.c.diff\" \(4813 characters\)
sed "s/^X//" >ida/patches/recipient.c.diff <<'END_OF_ida/patches/recipient.c.di
ff'
X*** recipient.c.orig	Fri Mar 13 18:51:10 1987
X--- recipient.c	Mon May 25 15:51:43 1987
X***************
X*** 342,347 ****
X--- 342,350 ----
X  **		may modify name.
X  */
X  
X+ #define WORST_MATCH	-2		/* even worse than no match */
X+ #define NO_UID		-999		/* any "impossible" uid will do
 */
X+ 
X  struct passwd *
X  finduser(name)
X  	char *name;
X***************
X*** 348,356 ****
X--- 351,364 ----
X  {
X  	register struct passwd *pw;
X  	register char *p;
X+ 	int best_match = WORST_MATCH;
X+ 	int best_uid = NO_UID;
X  	extern struct passwd *getpwent();
X  	extern struct passwd *getpwnam();
X+ 	extern struct passwd *getpwuid();
X  
X+ 	errno = 0;
X+ 
X  	/* map upper => lower case */
X  	for (p = name; *p != '\0'; p++)
X  	{
X***************
X*** 358,363 ****
X--- 366,377 ----
X  			*p = tolower(*p);
X  	}
X  
X+ # ifdef DEBUG
X+ 	if (tTd(26, 6))
X+ 		printf("%s password entry for \"%s\"\n",
X+ 		       getpwnam(name) ? "found" : "can't find", name);
X+ # endif DEBUG
X+ 
X  	/* look up this login name using fast path */
X  	if ((pw = getpwnam(name)) != NULL)
X  		return (pw);
X***************
X*** 368,387 ****
X  		if (*p == (SpaceSub & 0177) || *p == '_')
X  			*p = ' ';
X  	}
X  	(void) setpwent();
X  	while ((pw = getpwent()) != NULL)
X  	{
X  		char buf[MAXNAME];
X! 		extern bool sameword();
X  
X  		buildfname(pw->pw_gecos, pw->pw_name, buf);
X! 		if (index(buf, ' ') != NULL && sameword(buf, name))
X! 		{
X! 			message(Arpa_Info, "sending to login name %s", pw->pw_n
ame);
X! 			return (pw);
X! 		}
X  	}
X! 	return (NULL);
X  }
X  /*
X  **  WRITABLE -- predicate returning if the file is writable.
X--- 382,509 ----
X  		if (*p == (SpaceSub & 0177) || *p == '_')
X  			*p = ' ';
X  	}
X+ # ifdef DEBUG
X+ 	if (tTd(26, 6))
X+ 		printf("looking for partial match to \"%s\"\n", name);
X+ # endif DEBUG
X  	(void) setpwent();
X  	while ((pw = getpwent()) != NULL)
X  	{
X  		char buf[MAXNAME];
X! 		register int this_match;
X  
X  		buildfname(pw->pw_gecos, pw->pw_name, buf);
X! 		this_match = partialstring(buf, name);
X! # ifdef DEBUG
X! 		if (tTd(26, 6 && this_match >= 0))
X! 			printf("matched on level %d with \"%s\"\n",
X! 			       this_match, buf);
X! # endif DEBUG
X! 		if (this_match < best_match)
X! 			continue;
X! 
X! 		if (this_match > best_match) {
X! 			best_match = this_match;
X! 			best_uid = pw->pw_uid;
X! 		} else
X! 			best_uid = NO_UID;
X  	}
X! # ifdef DEBUG
X! 		if (tTd(26, 6))
X! 			if (best_match == WORST_MATCH)
X! 				printf("no match, failing...\n");
X! 			else if (best_uid == NO_UID)
X! 				printf("ambiguous match, failing...\n");
X! 			else
X! 				printf("succeding on level %d...\n",
X! 				       best_match);
X! # endif DEBUG
X! 
X! 	if (best_uid == NO_UID)
X! 		return (NULL);
X! 
X! 	pw = getpwuid(best_uid);
X! 	message(Arpa_Info, "sending to login name %s", pw->pw_name);
X! 	return (pw);
X! }
X! /*
X! **  PARTIALSTRING -- is one string of words contained by another?
X! **
X! **	See if one string of words can be found as part of
X! **	another string of words.  All substrings delimited by
X! **	one or more non-alphanumeric characters are considered
X! **	"words", and a partial match is such that all the words
X! **	of the pattern string are either full prefixes
X! **	of the target string.  Upper or lower case letters are
X! **	considered equal.
X! **
X! **	Parameters:
X! **		target -- target string
X! **		pattern -- pattern string
X! **
X! **	Returns:
X! **		The number of fully matched words, or -1 if none.
X! **
X! **	Side Effects:
X! **		None.
X! **
X! */
X! 
X! partialstring(target, pattern)
X!     char *target;
X!     char *pattern;
X! {
X!     register char *t, *p, *q;
X!     int full_words = 0;
X! 
X!     /* skip initial delimiters */
X!     for (t = target; *t != '\0' && !isalnum(*t); t++);
X!     for (p = pattern; *p != '\0' && !isalnum(*p); p++);
X!     q = p;
X! 
X!     while (*t != '\0' && *p != '\0') {
X! 	/*
X! 	 * if at end of pattern word, find next, remember it,
X! 	 * and eat the current target word
X! 	 */
X! 	if (!isalnum(*p)) {
X! 	    while (*p != '\0' && !isalnum(*p)) p++;
X! 	    if (*p == '\0')
X! 		continue;
X! 	    q = p;
X! 	    if (!isalnum(*t)) {
X! 		full_words++;
X! 	    }
X! 	    while (*t != '\0' && isalnum(*t)) t++;
X! 	    while (*t != '\0' && !isalnum(*t)) t++;
X! 	    continue;
X! 	}
X! 
X! 	/*
X! 	 * if match, advance both pointers
X! 	 */
X! 	if ((isupper(*t) ? tolower(*t) : *t) ==
X! 	    (isupper(*p) ? tolower(*p) : *p)) {
X! 	    t++, p++;
X! 	    continue;
X! 	}
X! 
X! 	/*
X! 	 * if no match, backtrack to last unmatched pattern word and
X! 	 * eat current target word
X! 	 */
X! 	p = q;
X! 	while (*t != '\0' && isalnum(*t)) t++;
X! 	while (*t != '\0' && !isalnum(*t)) t++;
X!     }
X! 
X!     /*
X!      * now, the pattern should be fully consumed if there was a match
X!      */
X!     if (*p == '\0')
X! 	return isalnum(*t) ? full_words : full_words + 1;
X!     else
X! 	return -1;
X  }
X  /*
X  **  WRITABLE -- predicate returning if the file is writable.
END_OF_ida/patches/recipient.c.diff
if test 4813 -ne `wc -c <ida/patches/recipient.c.diff`; then
    echo shar: \"ida/patches/recipient.c.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/srvrsmtp.c.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/srvrsmtp.c.diff\"
else
echo shar: Extracting \"ida/patches/srvrsmtp.c.diff\" \(4951 characters\)
sed "s/^X//" >ida/patches/srvrsmtp.c.diff <<'END_OF_ida/patches/srvrsmtp.c.diff
'
X*** srvrsmtp.c.orig	Fri Mar 13 18:51:13 1987
X--- srvrsmtp.c	Mon May 25 15:51:49 1987
X***************
X*** 95,101 ****
X  
X  #define EX_QUIT		22		/* special code for QUIT comman
d */
X  
X! smtp()
X  {
X  	register char *p;
X  	register struct cmd *c;
X--- 95,102 ----
X  
X  #define EX_QUIT		22		/* special code for QUIT comman
d */
X  
X! smtp(batched)
X! 	bool batched;			/* running non-interactively? */
X  {
X  	register char *p;
X  	register struct cmd *c;
X***************
X*** 107,112 ****
X--- 108,114 ----
X  	ADDRESS *a;
X  	char inp[MAXLINE];
X  	char cmdbuf[100];
X+ 	char hostbuf[MAXNAME];		/* for host name transformations */
X  	extern char Version[];
X  	extern tick();
X  	extern bool iswiz();
X***************
X*** 194,200 ****
X  		  case CMDHELO:		/* hello -- introduce yourself */
X  			SmtpPhase = "HELO";
X  			setproctitle("%s: %s", CurHostName, inp);
X! 			if (sameword(p, MyHostName))
X  			{
X  				/* connected to an echo server */
X  				message("553", "%s I refuse to talk to myself",
X--- 196,205 ----
X  		  case CMDHELO:		/* hello -- introduce yourself */
X  			SmtpPhase = "HELO";
X  			setproctitle("%s: %s", CurHostName, inp);
X! 			/* find canonical name */
X! 			strcpy(hostbuf, p);
X! 			maphostname(hostbuf, sizeof(hostbuf));
X! 			if (sameword(hostbuf, MyHostName))
X  			{
X  				/* connected to an echo server */
X  				message("553", "%s I refuse to talk to myself",
X***************
X*** 201,226 ****
X  					MyHostName);
X  				break;
X  			}
X! 			if (RealHostName != NULL && !sameword(p, RealHostName))
X  			{
X- 				char hostbuf[MAXNAME];
X- 
X  				(void) sprintf(hostbuf, "%s (%s)", p, RealHostN
ame);
X! 				define('s', newstr(hostbuf), CurEnv);
X  			}
X- 			else
X- 				define('s', newstr(p), CurEnv);
X- 			message("250", "%s Hello %s, pleased to meet you",
X- 				MyHostName, p);
X  			break;
X  
X  		  case CMDMAIL:		/* mail -- designate sender */
X  			SmtpPhase = "MAIL";
X  
X- 			/* force a sending host even if no HELO given */
X- 			if (RealHostName != NULL && macvalue('s', CurEnv) == NU
LL)
X- 				define('s', RealHostName, CurEnv);
X- 
X  			/* check for validity of this command */
X  			if (hasmail)
X  			{
X--- 206,228 ----
X  					MyHostName);
X  				break;
X  			}
X! 			if (RealHostName != NULL &&
X! 			    !sameword(p, RealHostName) &&
X! 			    !sameword(hostbuf, RealHostName))
X  			{
X  				(void) sprintf(hostbuf, "%s (%s)", p, RealHostN
ame);
X! 				CurHostName = newstr(hostbuf);
X! 				message("250", "Hello %s, why do you call yours
elf %s?",
X! 					RealHostName, p);
X! 			} else {
X! 				CurHostName = newstr(p);
X! 				message("250", "Hello %s, pleased to meet you",
 p);
X  			}
X  			break;
X  
X  		  case CMDMAIL:		/* mail -- designate sender */
X  			SmtpPhase = "MAIL";
X  
X  			/* check for validity of this command */
X  			if (hasmail)
X  			{
X***************
X*** 237,242 ****
X--- 239,245 ----
X  			if (runinchild("SMTP-MAIL") > 0)
X  				break;
X  			initsys();
X+ 			define('s', CurHostName, CurEnv);
X  			setproctitle("%s %s: %s", CurEnv->e_id,
X  				CurHostName, inp);
X  
X***************
X*** 260,266 ****
X  				CurHostName, inp);
X  			if (setjmp(TopFrame) > 0)
X  			{
X! 				CurEnv->e_flags &= ~EF_FATALERRS;
X  				break;
X  			}
X  			QuickAbort = TRUE;
X--- 263,270 ----
X  				CurHostName, inp);
X  			if (setjmp(TopFrame) > 0)
X  			{
X! 				if (!batched)
X! 					CurEnv->e_flags &= ~EF_FATALERRS;
X  				break;
X  			}
X  			QuickAbort = TRUE;
X***************
X*** 272,277 ****
X--- 276,282 ----
X  				break;
X  			a->q_flags |= QPRIMARY;
X  			a = recipient(a, &CurEnv->e_sendqueue);
X+ 
X  			if (Errors != 0)
X  				break;
X  
X***************
X*** 291,303 ****
X  			SmtpPhase = "DATA";
X  			if (!hasmail)
X  			{
X! 				message("503", "Need MAIL command");
X! 				break;
X  			}
X  			else if (CurEnv->e_nrcpts <= 0)
X  			{
X! 				message("503", "Need RCPT (recipient)");
X! 				break;
X  			}
X  
X  			/* collect the text of the message */
X--- 296,314 ----
X  			SmtpPhase = "DATA";
X  			if (!hasmail)
X  			{
X! 				message("503", "Need valid MAIL command");
X! 				if (batched)
X! 					Errors++;
X! 				else
X! 					break;
X  			}
X  			else if (CurEnv->e_nrcpts <= 0)
X  			{
X! 				message("503", "Need valid RCPT (recipient)");
X! 				if (batched)
X! 					Errors++;
X! 				else
X! 					break;
X  			}
X  
X  			/* collect the text of the message */
X***************
X*** 327,339 ****
X  			*/
X  
X  			SmtpPhase = "delivery";
X! 			if (CurEnv->e_nrcpts != 1)
X  			{
X  				HoldErrs = TRUE;
X  				ErrorMode = EM_MAIL;
X  			}
X! 			CurEnv->e_flags &= ~EF_FATALERRS;
X! 			CurEnv->e_xfp = freopen(queuename(CurEnv, 'x'), "w", Cu
rEnv->e_xfp);
X  
X  			/* send to all recipients */
X  			sendall(CurEnv, SM_DEFAULT);
X--- 338,353 ----
X  			*/
X  
X  			SmtpPhase = "delivery";
X! 			if (CurEnv->e_nrcpts != 1 || batched)
X  			{
X  				HoldErrs = TRUE;
X  				ErrorMode = EM_MAIL;
X  			}
X! 			if (!batched) {
X! 				CurEnv->e_flags &= ~EF_FATALERRS;
X! 				CurEnv->e_xfp = freopen(queuename(CurEnv, 'x'),
X! 							"w", CurEnv->e_xfp);
X! 			}
X  
X  			/* send to all recipients */
X  			sendall(CurEnv, SM_DEFAULT);
END_OF_ida/patches/srvrsmtp.c.diff
if test 4951 -ne `wc -c <ida/patches/srvrsmtp.c.diff`; then
    echo shar: \"ida/patches/srvrsmtp.c.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 2 \(of 7\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    echo "See ida/README and ida/INSTALL for further instructions."
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
