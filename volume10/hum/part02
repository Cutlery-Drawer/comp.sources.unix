Path: uunet!rs
From: rs@uunet.UU.NET (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v10i28:  Bill Tuthill's "hum" text concordance package, Part02/03
Message-ID: <475@uunet.UU.NET>
Date: 26 Jun 87 21:48:56 GMT
Organization: UUNET Communications Services, Arlington, VA
Lines: 3102
Approved: rs@uunet.uu.net

Submitted by: John Gilmore <hoptoad!gnu>
Mod.Sources: Volume 10, Number 28
Archive-name: hum/Part02

: To unbundle, sh this file
echo kwal.c
cat >kwal.c <<'@@@ Fin de kwal.c'
# include <stdio.h>				/* kwal.c (rev3.7) */
# include <ctype.h>

usage()			/* print usage and synopsis of options */
{
	puts("Key Word And Line concordance program\t\t(rev3.7)");
	puts("Usage: kwal [-kn -m -wS -fn -sn -r -ln -x -dF + -] filename(s)");
	puts("-kn: keyword is n characters long (defaults to 15)");
	puts("-m : keywords not mapped from upper to lower case");
	puts("-wS: write string S onto id field (use quotes around blanks)");
	puts("-fn: filename (up to n characters) written onto id field");
	puts("-sn: skip n characters of lefthand id field in text and write as id");
	puts("-r : reset linenumber to 1 at beginning of every file");
	puts("-ln: line numbering begins with line n (instead of 1)");
	puts("-x : line numbering is suppressed entirely");
	puts("-d : define punctuation set according to file F");
	puts("+  : the + character indicates cedilla or umlaut");
	puts("-  : read text from standard input (terminal or pipe)");
	exit(1);
}

int kwlen = 15;		/* lefthand keyword length */
int kwmap = 1;		/* toggle for mapping keyword to lcase */
int wrtid = 0;		/* toggle write onto id field */
char *idfld;		/* string to write onto id field */
int wrtfnm = 0;		/* toggle writing of filename */
int skipid = 0;		/* skip and write imbedded id field */
long lineno = 1;	/* count line numbers */
int resetno = 0;	/* reset lineno for new file */
int plusm = 0;		/* toggle plus mark to indicate accents */
char punctuation[BUFSIZ] = ",.;:-?!\"()[]{}" ;

main(argc,argv)		/* Key Word And Line concordance program */
int argc;
char *argv[];
{
	FILE *fp, *fopen();
	int i;

	if (argc == 1)
		usage();

	for (i = 1; i < argc; i++)
	{
		if (*argv[i] == '-')
			getflag(argv[i]);
		else if (*argv[i] == '+')
			plusm = 1;
		else if ((fp = fopen(argv[i],"r")) != NULL)
		{
			kwal(fp, argv[i]);
			fclose(fp);
			if (resetno)
				lineno = 1;
		}
		else  /* cannot open file */
		{
			fprintf(stderr,
			"Kwal cannot access the file: %s\n", argv[i]);
			continue;
		}
	}
	exit(0);
}

getflag(f)		/* parses command line to set options */
char *f;
{
	char *pfile;
	long atol();

	f++;
	switch(*f++)
	{
		case 'k':
			kwlen = atoi(f);
			break;
		case 'm':
			kwmap = 0;
			break;
		case 'w':
			wrtid = 1;
			idfld = f;
			break;
		case 'f':
			wrtfnm = atoi(f);
			break;
		case 's':
			skipid = atoi(f);
			break;
		case 'r':
			resetno = 1;
			break;
		case 'l':
			lineno = atol(f);
			break;
		case 'x':
			lineno = 0;
			break;
		case 'd':
			pfile = f;
			getpunct(pfile);
			break;
		case NULL:
			kwal(stdin, "Stdin");
			break;
		default:
			fprintf(stderr,
			"Invalid kwal flag: -%s\n", --f);
			exit(1);
			break;
	}
}

getpunct(pfile)		/* read user's punctuation from pfile */
char *pfile;
{
	FILE *pfp, *fopen();
	char s[BUFSIZ], *strcpy();

	if ((pfp = fopen(pfile, "r")) == NULL)
	{
		fprintf(stderr,
		"Kwal cannot access Punctfile: %s\n", pfile);
		exit(1);
	}
	else
		while (fgets(s, BUFSIZ, pfp))
			strcpy(punctuation, s);
}

char line[BUFSIZ];	/* line buffer of text */
int pos;		/* position of current word */
char wrtskip[BUFSIZ];	/* storage for embedded id field */

kwal(fp, fname)		/* prints kwal entry for each word */
FILE *fp;
char *fname;
{
	char wd[BUFSIZ];

	while (fgets(line, BUFSIZ, fp) != NULL)
	{
		pos = 0;
		if (skipid)
			cp_skipid();
		while (getword(wd))
		{
			pr_keywd(wd);		/* lefthand keyword */
			pr_idfld(fname);	/* identification fld */
			fputs(line, stdout);	/* print context */
		}
		if (lineno)
			lineno++;
	}
}

cp_skipid()		/* handle strings of embedded id field */
{
	char lncpy[BUFSIZ];
	int i, j;

	strcpy(lncpy, line);

	for (i = 0; i < skipid; i++)
		wrtskip[i] = line[i];
	wrtskip[i] = NULL;

	for (i = 0, j = skipid; lncpy[j] != NULL; i++, j++)
		line[i] = lncpy[j];
	line[i] = NULL;
}

pr_keywd(wd)		/* print keyword, adjusting for backspaces */
char wd[];
{
	char *cp;
	int i, kwbsno = 0;

	cp = wd;
	for (i = 0; i < kwlen; i++)
		if (*cp)
		{
			if (*cp == '\b')
				kwbsno += 2;
			if (plusm && *cp == '+')
				kwbsno++;
			putchar(*cp++);
		}
		else
			putchar(' ');
	while (kwbsno-- > 0)
		putchar(' ');
	putchar('|');
}

pr_idfld(fname)		/* print specified id fields and number */
char *fname;
{
	char *wfile;
	int i;

	if (wrtid)
		printf("%s ", idfld);
	if (wrtfnm)
	{
		wfile = fname;
		for (i = 0; i < wrtfnm; i++)
			if (*wfile)
				putchar(*wfile++);
			else
				putchar(' ');
		putchar(' ');
	}
	if (skipid)
		printf("%s    ", wrtskip);
	if (lineno)
		printf("%6ld    ", lineno);
}

getword(wd)		/* gets next word on each line */
char *wd;
{
	int ln; 

	/* skip over blanks */
	while ((*wd = line[pos++]) && isskip(*wd) && *wd != '\n')
		;
	if (*wd == '\n')
		ln = 0;
	if (kwmap && isupper(*wd))
		*wd = tolower(*wd);

	/* load word from line */
	while ((*++wd = line[pos++]) && !isskip(*wd))
	{
		if (kwmap && isupper(*wd))
			*wd = tolower(*wd);
		ln = 1;
	}
	*wd = NULL;

	pos--;			/* unget newline character */
	return(ln);		/* true if there is more line */
}

isskip(c)		/* function to evaluate punctuation */
char c;
{
	char *ptr;

	if (isspace(c))
		return(1);
	for (ptr = punctuation; *ptr != c && *ptr != NULL; ptr++)
		;
	if (*ptr == NULL)
		return(0);
	else
		return(1);
}
@@@ Fin de kwal.c
echo kwic.c
cat >kwic.c <<'@@@ Fin de kwic.c'
# include <stdio.h>				/* kwic.c (rev3.7) */
# include <ctype.h>
# include <signal.h>

usage()			/* print usage and synopsis of options */
{
	puts("Key Word In Context concordance program\t\t(rev3.7)");
	puts("Usage: kwic [-kn -m -wS -fn -r -ln -pn -ic -cn -dF + -] filename(s)");
	puts("-kn: keyword is n characters long (defaults to 15)");
	puts("-m : keywords not mapped from upper to lower case");
	puts("-wS: write string S onto id field (use quotes around blanks)");
	puts("-fn: filename (up to n characters) written onto id field");
	puts("-r : reset linenumber to 1 at beginning of every file");
	puts("-ln: line numbering begins with line n (instead of 1)");
	puts("-pn: page numbering begins with page n (instead of 1)");
	puts("-ic: page incrementer is character c (defaults to =)");
	puts("-cn: context is n characters long (defaults to 50)");
	puts("-d : define punctuation set according to file F");
	puts("+  : the + character indicates cedilla or umlaut");
	puts("-  : read text from standard input (terminal or pipe)");
	puts("Kwic will linenumber until first page indicator.");
	exit(1);
}

int kwlen = 15;		/* lefthand keyword length */
int kwmap = 1;		/* toggle mapping of keyword to lcase */
int wrtid = 0;		/* toggle write onto id field */
char *idfld;		/* string to write onto id field */
int wrtfnm = 0;		/* toggle writing of filename */
long lineno = 1;	/* count line numbers */
int resetno = 0;	/* reset lineno for new file */
char pgincr = '=';	/* page incrementing character */
int pageno = 0;		/* toggle and count page numbers */
int cntxt = 50;		/* context width around keyword */
int plusm = 0;		/* toggle plus sign as accent mark */
char punct[BUFSIZ/4] 	= ",.;:-?!\"()[]{}" ;
char zerowid[BUFSIZ/4]	= "+" ;

main(argc, argv)	/* Key Word In Context concordance program */
int argc;
char *argv[];
{
	FILE *fp, *fopen();
	int i;

	if (argc == 1)
		usage();

	for (i = 1; i < argc; i++)
	{
		if (*argv[i] == '-')
			getflag(argv[i]);
		else if (*argv[i] == '+')
			plusm = 1;
		else if ((fp = fopen(argv[i], "r")) != NULL)
		{
			kwic(fp, argv[i]);
			fclose(fp);
			if (resetno)
				lineno = 1;
		}
		else
		{
			fprintf(stderr,
			"Kwic cannot access the file: %s\n", argv[i]);
			continue;
		}
	}
	exit(0);
}

getflag(f)		/* parses command line to set options */
char *f;
{
	char *pfile;
	long atol();

	f++;
	switch(*f++)
	{
		case 'k':
			kwlen = atoi(f);
			break;
		case 'm':
			kwmap = 0;
			break;
		case 'w':
			wrtid = 1;
			idfld = f;
			break;
		case 'f':
			wrtfnm = atoi(f);
			break;
		case 'r':
			resetno = 1;
			break;
		case 'l':
			lineno = atol(f);
			break;
		case 'p':
			pageno = atoi(f);
			break;
		case 'i':
			pgincr = *f;
			break;
		case 'c':
			cntxt = atoi(f);
			break;
		case 'd':
			pfile = f;
			getpunct(pfile);
			break;
		case NULL:
			rd_stdin();
			break;
		default:
			fprintf(stderr,
			"Invalid kwic flag: -%s\n", --f);
			exit(1);
			break;
	}
}

getpunct(pfile)		/* read user's punctuation from pfile */
char *pfile;
{
	FILE *pfp, *fopen();
	char s[BUFSIZ/4], *strcpy();

	if ((pfp = fopen(pfile, "r")) == NULL)
	{
		fprintf(stderr,
		"Kwic cannot access Punctfile: %s\n", pfile);
		exit(1);
	}
	if (fgets(s, BUFSIZ/4, pfp))
	{
		strcpy(punct, s);
		punct[strlen(punct)-1] = NULL;
	}
	if (fgets(s, BUFSIZ/4, pfp))
	{
		strcpy(zerowid, s);
		zerowid[strlen(zerowid)-1] = NULL;
		plusm = 1;
	}
}

char *tempfile;		/* file storage for seeking stdin */

rd_stdin()		/* create tempfile with standard input */
{
	FILE *tfp, *fopen();
	char s[BUFSIZ], *mktemp();
	int catch();

	tempfile = "/tmp/KwicXXXXX";
	mktemp(tempfile);
	tfp = fopen(tempfile, "w");
	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, catch);
	while (fgets(s, BUFSIZ, stdin))
		fputs(s, tfp);
	fclose(tfp);
	tfp = fopen(tempfile, "r");
	kwic(tfp, "Stdin");
	unlink(tempfile);
}

catch()			/* remove tempfile in case of interrupt */
{
	unlink(tempfile);
	fprintf(stderr, "\nInterrupt\n");
	exit(1);
}

kwic(fp, fname)		/* prints kwic entry for each word */
FILE *fp;
char *fname;
{
	char word[BUFSIZ], str[BUFSIZ];
	long pos, ftell();
	register int wdlen, i;

	while (wdlen = getword(word, fp))
	{
		pr_keywd(word);		/* lefthand keyword */
		pr_idfld(fname);	/* identificaton field */

		pos = ftell(fp);		/* where in text? */
		if (pos < cntxt/2 + wdlen + 2)	/* if at beginning */
		{
			fseek(fp, -(pos), 1);
			for (i = 0; i < cntxt/2 - pos + wdlen + 2; i++)
				putchar(' ');
			load_str(str, (int)(pos - wdlen - 1), 1, fp);
		}
		else			/* if past beginning of text */
		{
			fseek(fp, (long) -(cntxt/2 + wdlen + 2), 1);
			load_str(str, (cntxt/2 + 1), 0, fp);
		}
		printf("%s|", str);	/* print out first half */

		end_entry(fp);		/* print out second half */

		fseek(fp, pos, 0);	/* back to original location */
		putchar('\n');		/* end concordance entry */
	}
}

pr_keywd(word)		/* print keyword, adjusting for backspaces */
char word[];
{
	char *cp, *index();
	register int i, kwbsno = 0;

	cp = word;

	for (i = 0; i < kwlen; i++)
	{
		if (*cp)
		{
			if (*cp == '\b')
				kwbsno += 2;
			if (plusm && index(zerowid, *cp))
				kwbsno++;
			putchar(*cp++);
		}
		else
			putchar(' ');
	}
	while (kwbsno-- > 0)
		putchar(' ');
	putchar('|');
}


pr_idfld(fname)		/* print specified id fields and numbering */
char *fname;
{
	char *wfile;
	int i;

	if (wrtid)
		printf("%s ", idfld);
	if (wrtfnm)
	{
		wfile = fname;
		for (i = 0; i < wrtfnm; i++)
			if (*wfile)
				putchar(*wfile++);
			else
				putchar(' ');
		putchar(' ');
	}
	if (pageno)
		printf("%3d,%2ld|", pageno, lineno);
	else
		printf("%6ld|", lineno);
}

load_str(str, max, prnt, fp)	/* load first half onto string */
char str[];
int max, prnt;
FILE *fp;
{
	int i, bsno = 0;
	int c;

	for (i = 0; i < max; i++)
	{
		c = getc(fp);
		if (!prnt)
		{
			str[i] = ' ';
			prnt = isspace(c);
		}
		else	/* if (prnt) */
		{
			if (c == '\n')
				str[i] = '/';
			else if (c == '\t')
				str[i] = ' ';
			else
				str[i] = c;

			if (c == '\b')
				bsno += 2;
			if (plusm && index(zerowid, c))
				bsno++;
		}
	}
	str[i] = NULL;
	while (bsno-- > 0)	/* adjust for backspaces */
		putchar(' ');
}

end_entry(fp)		/* read and write to end of entry */
FILE *fp;
{
	register int i, c;

	for (i = 0; i < cntxt/2 - 2; i++)
	{
		c = getc(fp);
		if (c == '\n')
			c = '/';
		if (c == '\t')
			c = ' ';
		if (c == EOF)
			return;
		putchar(c);
	}
	while (!isspace(c = getc(fp)) && c != EOF)
		putchar(c);
}

getword(word, fp)	/* drives program through text word by word */
char word[];
FILE *fp;
{
	static char nl = 0;
	register int wlen = 1;

	if (nl)		/* increments lineno at beginning of line */
	{
		nl = 0;
		lineno++;
	}
	while ((*word = getc(fp)) && isskip(*word) && *word != EOF)
		if (*word == '\n')	/* skip to text */
			lineno++;

	if (*word == pgincr)
	{
		pageno++;	/* pgincr must begin word */
		lineno = 0;
	}
	if (*word == EOF)
		return(NULL);
	if (kwmap)
		if (isupper(*word))
			*word = tolower(*word);

	while ((*++word = getc(fp)) && !isskip(*word) && *word != EOF)
	{				/* get next word */
		if (kwmap)
			if (isupper(*word))
				*word = tolower(*word);
		wlen++;
	}
	if (*word == '\n')	/* set nl at end of line */
		nl = 1;
	*word = NULL;

	return(wlen);
}

isskip(c)		/* function to evaluate punctuation */
char c;
{
	char *ptr;

	if (isspace(c))
		return(1);
	for (ptr = punct; *ptr != c && *ptr != NULL; ptr++)
		;
	if (*ptr == NULL)
		return(0);
	else
		return(1);
}
@@@ Fin de kwic.c
echo lno.c
cat >lno.c <<'@@@ Fin de lno.c'
# include <stdio.h>			/* lno.c (rev3.7) */

long lno = 1;
int dbles = 0;		/* toggle option for double line numbering */
int strph = 0;		/* toggle and count for strophe numbering */

main(argc, argv)	/* line number text, allowing setting */
int argc;
char *argv[];
{
	FILE *fp, *fopen();
	long atol();
	int i;

	if (argc == 1)
	{
		puts("Usage: lno [+n -d -h -sn -] filename(s)\t\t(rev3.7)");
		puts("+n : the beginning line number is n, not 1");
		puts("-d : double line number text with long lines");
		puts("-h : hemistich number text with split lines");
		puts("-sn: number and letter strophes of n lines");
		puts("-  : read standard input instead of files");
		exit(1);
	}
	for (i = 1; i < argc; i++)
	{
		if (*argv[i] == '+')
			lno = atol(argv[i]+1);
		else if (*argv[i] == '-')
			getflag(argv[i]);
		else if ((fp = fopen(argv[i], "r")) != NULL)
		{
			if (dbles)
				dblno(fp);
			if (strph)
				strfno(fp);
			else  /* default action */
				lineno(fp);
			fclose(fp);
		}
		else  /* attempt to open file failed */
		{
			fprintf(stderr,
			"Lno cannot access the file: %s\n", argv[i]);
			continue;
		}
	}
	exit(0);
}

getflag(f)		/* parses command line to set options */
char *f;
{
	f++;
	switch(*f)
	{
		case 'd':
			dbles = 1;
			break;
		case 'h':
			strph = 2;
			break;
		case 's':
			strph = atoi(++f);
			if (strph > 26)
			{
				fprintf(stderr,
				"Too many lines per strophe\n");
				exit(1);
			}
			break;
		case NULL:
			if (dbles)
				dblno(stdin);
			if (strph)
				strfno(stdin);
			else
				lineno(stdin);
			break;
		default:
			fprintf(stderr, "Invalid lno flag: -%s\n", f);
			exit(1);
			break;
	}
}

lineno(fp)		/* this function is self-explanatory */
FILE *fp;
{
	char s[BUFSIZ];

	while (fgets(s, BUFSIZ, fp))
	{
		printf("%6ld\t", lno);
		fputs(s, stdout);
		lno++;
	}
}

dblno(fp)		/* number text, incrementing by twos */
FILE *fp;
{
	char s[BUFSIZ];

	while (fgets(s, BUFSIZ, fp))
	{
		printf("%6ld\t", lno);
		fputs(s, stdout);
		lno += 2;
	}
}

strfno(fp)		/* number n line strophes, appending letters */
FILE *fp;
{
	char s[BUFSIZ], ch = 'a';
	int i = 0;

	while (fgets(s, BUFSIZ, fp))
	{
		printf("%5ld%c\t", lno, ch);
		fputs(s, stdout);
		if (++i < strph)
			ch++;
		else
		{
			lno++;
			i = 0;
			ch = 'a';
		}
	}
}
@@@ Fin de lno.c
echo maxwd.c
cat >maxwd.c <<'@@@ Fin de maxwd.c'
# include <stdio.h>			/* maxwd.c (rev3.7) */
# include <ctype.h>
# define LNGBUF (BUFSIZ * 2)

char filename[15], mxword[BUFSIZ], mxline[LNGBUF];
int mxwdlen = 0, lineno = 0;
int mxlnlen = 0, doline = 0;

main(argc, argv)	/* find, measure and print longest word */
int argc;
char *argv[];
{
	FILE *fopen(), *fp;
	int i;

	if (argc == 1)
	{
		puts("Usage: maxwd [-l -dF -] filename(s)\t\t(rev3.7)");
		puts("will give file, linenumber, maximum word length,");
		puts("\tand then print the longest word");
		puts("-l: look for longest line instead of longest word");
		puts("-d: define punctuation set according to file F");
		puts("- : read standard input instead of files");
		exit(1);
	}
	for (i = 1; i < argc; i++)
	{
		if (*argv[i] == '-')
			getflag(argv[i]);
		else if ((fp = fopen(argv[i], "r")) != NULL)
		{
			if (doline)
				maxline(fp, argv[i]);
			else
				maxword(fp, argv[i]);
			fclose(fp);
		}
		else  /* cannot open file */
		{
			fprintf(stderr,
			"Maxwd cannot access the file: %s\n", argv[i]);
			exit(1);
		}
	}
	printf("%s: line %d: ", filename, lineno);
	if (doline)
	{
		printf("%d characters:\n", mxlnlen-1);
		printf("%s", mxline);
	}
	else
	{
		printf("%d characters:\n", mxwdlen);
		printf("%s\n", mxword);
	}
	exit(0);
}

getflag(f)		/* parses command line to set options */
char *f;
{
	char *pfile;

	f++;
	switch(*f++)
	{
		case 'l':
			doline = 1;
			break;
		case 'd':
			pfile = f;
			getpunct(pfile);
			break;
		case NULL:
			if (doline)
				maxline(stdin, "Stdin");
			else
				maxword(stdin, "Stdin");
			break;
		default:
			fprintf(stderr,
			"Invalid maxwd flag: -%s\n", --f);
			exit(1);
			break;
	}
}

char punct[BUFSIZ] = ",.;:-?!\"()[]{}" ;

getpunct(pfile)		/* read user's punctuation from pfile */
char *pfile;
{
	FILE *pfp, *fopen();
	char s[BUFSIZ], *strcpy();

	if ((pfp = fopen(pfile, "r")) == NULL)
	{
		fprintf(stderr,
		"Maxwd cannot access Punctfile: %s\n", pfile);
		exit(1);
	}
	else
		while (fgets(s, BUFSIZ, pfp))
			strcpy(punct, s);
}

maxword(fp, fname)	/* inspect each file for longest word */
FILE *fp;
char fname[];
{
	char word[BUFSIZ];
	int c, i = 0, wdlen = 0, lno = 1;

	while ((c = getc(fp)) != EOF)
	{
		if (!isskip(c))
		{
			word[i++] = c;
			wdlen++;
		}
		else  /* if (isskip(c)) */
		{
			word[i] = NULL;
			i = 0;
			if ((wdlen = strlen(word)) > mxwdlen)
			{
				strcpy(filename, fname);
				lineno = lno;
				mxwdlen = wdlen;
				strcpy(mxword, word);
			}
		}
		if (c == '\n')
			lno++;
	}
}

isskip(c)		/* function to evaluate punctuation */
char c;
{
	char *ptr;

	if (isspace(c))
		return(1);
	for (ptr = punct; *ptr != c && *ptr != NULL; ptr++)
		;
	if (*ptr == NULL)
		return(0);
	else
		return(1);
}

maxline(fp, fname)	/* inspect each file for longest line */
FILE *fp;
char fname[];
{
	char line[LNGBUF];
	int lnlen = 0, lno = 0;

	while (fgets(line, LNGBUF, fp))
	{
		lno++;
		if ((lnlen = strlen(line)) > mxlnlen)
		{
			strcpy(filename, fname);
			lineno = lno;
			mxlnlen = lnlen;
			strcpy(mxline, line);
		}
	}
}
@@@ Fin de maxwd.c
echo med.c
cat >med.c <<'@@@ Fin de med.c'
# include <curses.h>
# include <signal.h>

main()			/* med - a full-screen music editor */
{
	int y, x, i, die();
	char c, cmd;

	initscr();
	signal(SIGINT, die);
	crmode();
	noecho();
	nonl();

	paintscr();
	while (1)
	{
		c = getch();
		if (c == '\r')		/* RETURN */
			move(y+1, 0);
		else if (c == '\012')	/* ^J, nl */
			move(y+1, x);
		else if (c == '\013')	/* ^K, vt */
			move(y-1, x);
		else if (c == '\014')	/* ^L, np */
			move(y, x+1);
		else if (c == *HO)	/* HOME */
		{
			for (i = 1; HO[i] != '\0' && c == HO[i-1]; i++)
				c = getch();
			move(0, 0);
		}
		else if (c == '|')	/* staff */
		{
			addch(c);
			for (i = 1; i < 3; i++)
			{
				move(y-i, x);
				addch(c);
			}
		}
		else if (c == '!')	/* bar */
		{
			addch(c);
			for (i = 1; i < 8; i++)
			{
				move(y-i, x);
				addch(c);
			}
		}
		else if (c == '\022')	/* redraw screen */
			paintscr();
		else
			addch(c);

		refresh();
		getyx(stdscr, y, x);
		if (y == 0 && x == 0)
		{
			cmd = getch();
			addch(cmd);
			execute(cmd);
		}
	}
}

die()			/* restore terminal in case of interrupt */
{
	signal(SIGINT, SIG_IGN);
	mvcur(0, COLS-1, LINES-1, 0);
	endwin();
	exit(1);
}

paintscr()		/* place treble and bass staffs on screen */
{
	register int ln, co;
	char done = 0;

	move(0, 0);
	addstr("_         \n");
dostaff:
	addch('\n');
	addch('\n');
	for (ln = 1; ln <= 5; ln++)
	{
		for (co = 0; co < COLS-1; co++)
			addch('_');
		addch('\n');
		for (co = 0; co < COLS-1; co++)
			addch(' ');
		addch('\n');
	}
	if (!done && LINES >= 24)
	{
		done = 1;
		goto dostaff;
	}
	move(0, 0);
	refresh();
}

execute(cmd)
char cmd;
{
	move(0, 0);
	printw("Executing %c", cmd);
	move(0, 0);
	refresh();
	if (cmd == 'q')
	{
		mvcur(0, COLS-1, LINES-1, 0);
		endwin();
		exit(0);
	}
}
@@@ Fin de med.c
echo pair.c
cat >pair.c <<'@@@ Fin de pair.c'
# include <stdio.h>				/* pair.c (rev3.7) */

main(argc, argv)	/* pair two files side by side (or intercalate) */
int argc;
char *argv[];
{
	FILE *fopen(), *fp1, *fp2;
	char s1[BUFSIZ], s2[BUFSIZ], fmt1[15], fmt2[15], *sprintf();
	int eof1, eof2, len1 = 40, len2 = 40;
	register int i;

	if (argc < 3 || argc > 5)
	{
		puts("Usage: pair [-m] file1 file2 [+len1 [+len2]]\t(rev3.7)");
		puts("-m: merge (intercalate) two files line by line");
		puts("- : read standard input instead of either file");
		puts("len1 and 2 denote screen width of file1 and 2");
		exit(1);
	}
	if (argv[1][0] == '-' && argv[1][1] == 'm')
	{
		merge(argv[2], argv[3]);
		exit(0);
	}
	if (argv[1][0] == '-' && argv[1][1] == '\0')
		fp1 = stdin;
	else if ((fp1 = fopen(argv[1], "r")) == NULL)
	{
		fprintf(stderr,
		"Pair cannot access the file: %s\n", argv[1]);
		exit(1);
	}
	if (argv[2][0] == '-' && argv[2][1] == '\0')
		fp2 = stdin;
	else if ((fp2 = fopen(argv[2], "r")) == NULL)
	{
		fprintf(stderr,
		"Pair cannot access the file: %s\n", argv[2]);
		exit(1);
	}
	if (argc > 3)
		len1 = atoi(argv[3]+1);
	if (argc > 4)
		len2 = atoi(argv[4]+1);
	sprintf(fmt1, "%%-%d.%ds", len1, len1 - 1);
	sprintf(fmt2, "%%-.%ds\n", len2 - 1);

	eof1 = eof2 = 0;
	while (!eof1 || !eof2)
	{
		if (fgets(s1, BUFSIZ, fp1))
		{
			s1[strlen(s1)-1] = '\0';
			printf(fmt1, s1);
		}
		else	eof1 = 1;

		if (fgets(s2, BUFSIZ, fp2))
		{
			if (eof1)
				for (i = 0; i < len1; i++)
					putchar(' ');
			s2[strlen(s2)-1] = '\0';
			printf(fmt2, s2);
		}
		else	eof2 = 1;

		if (eof2 && !eof1)
			putchar('\n');
	}
	exit(0);
}

merge(arg1, arg2)	/* intercalate two files line by line */
char arg1[], arg2[];
{
	FILE *fopen(), *fp1, *fp2;
	char s1[512], s2[512];
	int eof1, eof2, std = 0;

	if (arg1[0] == '-' && arg1[1] == NULL)
	{
		fp1 = stdin;
		std = 1;
	}
	else if ((fp1 = fopen(arg1, "r")) == NULL)
	{
		fprintf(stderr, "Pair cannot access the file: %s\n", arg1);
		exit(1);
	}
	if (arg2[0] == '-' && arg2[1] == NULL)
	{
		fp2 = stdin;
		std = 1;
	}
	else if ((fp2 = fopen(arg2, "r")) == NULL)
	{
		fprintf(stderr, "Pair cannot access the file: %s\n", arg2);
		exit(1);
	}
	eof1 = eof2 = 0;
	while (!eof1 || !eof2)
	{
		if (fgets(s1, 512, fp1))
		{
			fputs(s1, stdout);
			if (!isatty(fileno(stdout)) && std)
				fputs(s1, stderr);
		}
		else
			eof1 = 1;

		if (fgets(s2, 512, fp2))
		{
			if (eof1)
				putchar('\n');
			fputs(s2, stdout);
			if (!isatty(fileno(stdout)) && std)
				fputs(s2, stderr);
		}
		else
			eof2 = 1;

		if (eof2 && !eof1)
			putchar('\n');
	}
}
@@@ Fin de pair.c
echo pause.c
cat >pause.c <<'@@@ Fin de pause.c'
# include <stdio.h>			/* pause.c (rev3.7) */

main(argc, argv)	/* stop IBM terminal to change ball */
int argc;
char *argv[];
{
	FILE *fp, *fopen();

	if (argc == 1)
		pawse(stdin);
	else
	{
		while (--argc > 0)
			if ((fp = fopen(*++argv, "r")) != NULL)
			{
				pawse(fp);
				fclose(fp);
			}
			else  /* attempt to open failed */
			{
				fprintf(stderr,
				"Pause cannot access the file: %s\t\t(rev3.7)\n",
				*argv);
				continue;
			}
		exit(0);
	}
}

pawse(fp)		/* pause when ctrl-p is read from file */
FILE *fp;
{
	register int c;

	while ((c = getc(fp)) != EOF)
	{
		if (c == '\020')	/* \020 is ctrl-p */
			patient();
		else
			putchar(c);
	}
}

patient()		/* wait for ctrl-d from terminal */
{
	FILE *termptr, *fopen();
	int sig;

	termptr = fopen("/dev/tty", "r");
	while ((sig = getc(termptr)) != EOF)
	{
		if (sig != '\004')	/* \004 is ctrl-d */
			;
		else
			return;
	}
	fclose(termptr);
	return;
}
@@@ Fin de pause.c
echo revconc.c
cat >revconc.c <<'@@@ Fin de revconc.c'
# include <stdio.h>			/* revconc.c (3.7) */
# include <ctype.h>

main(argc, argv)	/* reverse concordance module */
int argc;
char *argv[];
{

	FILE *fp, *fopen();

	if (argc == 1)
		revconc(stdin);
	else
	{
		while (--argc > 0)
			if ((fp = fopen(*++argv, "r")) == NULL)
			{
				fprintf(stderr,
				"Revconc cannot access the file: %s\t\t(rev3.7)\n",
				*argv);
				continue;
			}
			else
			{
				revconc(fp);
				fclose(fp);
			}
		exit(0);
	}
}

revconc(fp) 		/* reverse first word (keyword) on each line */
FILE *fp;
{
	char line[512];

	while (fgets(line, 512, fp))
	{
		revwd(line);
		fputs(line, stdout);
	}
}

revwd(s)  		/* reverse first word of string s in place */
char s[];
{
	int i, j;
	char c;

	for (i = 0, j = firstwdlen(s) - 1; i < j; i++, j--)
	{
		c = s[i];
		s[i] = s[j];
		s[j] = c;
	}
	return;
}

firstwdlen(s) 		/* return length of first word in string s */
char *s;
{
	int i = 0;

	while (!isspace(*s++))
		i++;
	return(i);
}
@@@ Fin de revconc.c
echo sfind.c
cat >sfind.c <<'@@@ Fin de sfind.c'
# include <stdio.h>			/* sfind.c (rev3.7) */
# include <ctype.h>
# define LNGBUF (BUFSIZ*8)
# define isperiod(c)	(c == '.' || c == '?' || c == '!')

usage()			/* print usage and synopsis of options */
{
	puts("Find sentence (record) matching pattern\t\t\t(rev3.7)");
	puts("Usage: sfind [-sC -ln -pn -ic -r] 'pattern' [-] filename(s)");
	puts("-sC: record separator is C (or empty line with no C)");
	puts("-ln: line number set to n (instead of 1)");
	puts("-pn: page number set to n (default off)");
	puts("-ic: page incrementing character is c (not =)");
	puts("-r : reset linenumber to 1 with each new file");
	puts(" - : read standard input instead of files");
	puts("metacharacters:");
	puts("_ is any single character");
	puts("* any number of characters");
	puts("$ matches a newline");
	puts("\\ escape magic");
	exit(1);
}

char pattern[BUFSIZ];	/* pattern to be searched for */
int recds = 0;		/* toggle switch for record searching */
char sepc = NULL;	/* record separating character */
long lineno = 1;	/* count of line numbers */
int pageno = 0;		/* toggle and count page numbers */
char pgincr = '=';	/* page incrementing character */
int resetno = 0;	/* reset linenumber for new file */

main(argc, argv)	/* find all sentences matching a pattern */
int argc;
char *argv[];
{
	FILE *fp, *fopen();
	int i, apat = 0;
	char *strcpy();

	if (argc < 3)
		usage();
	for (i = 1; i < argc; i++)
	{
		if (*argv[i] == '-')
			getflag(argv[i]);
		else if (!apat)
		{
			strcpy(pattern, argv[i]);
			apat = 1;
		}
		else if ((fp = fopen(argv[i], "r")) != NULL)
		{
			findsent(fp, argv[i]);
			fclose(fp);
		}
		else  /* attempt to open file failed */
		{
			fprintf(stderr,
			"Sfind cannot access the file: %s\n", argv[i]);
			continue;
		}
	}
	exit(0);
}

getflag(f)		/* parses command line to set options */
char *f;
{
	long atol();

	f++;
	switch(*f++)
	{
		case 's':
			recds = 1;
			sepc = *f;
			break;
		case 'l':
			lineno = atol(f);
			break;
		case 'p':
			pageno = atoi(f);
			break;
		case 'i':
			pgincr = *f;
			break;
		case 'r':
			resetno = 1;
			break;
		case NULL:
			findsent(stdin, "Stdin");
			break;
		default:
			fprintf(stderr, "Invalid sfind flag: -%s\n", --f);
			exit(1);
			break;
	}
}

findsent(fp, fname)	/* searches through text sentence by sentence */
FILE *fp;
char fname[15];
{
	char sent[LNGBUF];
	int more;

	/* do loop used in case last record has no final sepc */
	do {
		more = getsent(sent, LNGBUF, fp);
		if (index(sent, pattern) >= 0)
		{
			printf("===< %s >", fname);
			if (pageno)
				printf("===< page %d >", pageno);
			printf("===< line %ld >", lineno);
			printf("===< %s >===", pattern);
			if (sent[0] != '\n')
				putchar('\n');
			printf("%s\n", sent);
		}
	} while (more);
	if (resetno)
		lineno = 1;
}

char lastc = NULL;
int nl = 0;

getsent(s, lim, fp)	/* get sentence into s, return length */
char *s;
int lim;
FILE *fp;
{
	register int c;

	lineno += nl;
	nl = 0;
	while (--lim && (c = getc(fp)) != EOF && !is_eos(c, fp))
	{
		if (c == pgincr && isspace(lastc))
			pageno++;
		*s++ = c;
		lastc = c;
		if (c == '\n')
			nl++;
	}
	*s = NULL;
	lastc = c;
	if (c == '\n')
		nl++;
	if (c == EOF)
		return(0);
	return(1);
}

is_eos(c, fp)		/* determine if at end of sentence or record */
int c;
FILE *fp;
{
	int ch;

	if (recds)	/* searching records */
	{
		if (sepc == NULL)	/* RS is a blank line */
		{
			if (lastc == '\n' && c == '\n')
				return(1);
		}
		else if (c == sepc)	/* RS is single character */
			return(1);
	}
	else if (isperiod(lastc))	/* searching sentences */
	{
		if (c == '\n')		/* period before eoln */
			return(1);
		ch = c;			/* test the next char */
		c = getc(fp);
		if (c == EOF)		/* do nothing if at EOF */
			;
		if (isspace(ch) && isspace(c))	/* 2 spaces in row */
			return(1);
		if (ch == '"' && isspace(c))	/* quote and space */
			return(1);
		if (ch == ')' && isspace(c))	/* paren and space */
			return(1);
		ungetc(c, fp);
	}
	return(0);
}

index(s, pat)		/* return index of pat in s, -1 if no match */
char s[], pat[];
{
	register int i, j, k;
	int n, m;

	for (i = 0; s[i]; i++)
	{
		for (j = i, k = 0; pat[k]; j++, k++)
		{
			if (pat[k] == '\\')	/* escape char */
				if (s[j] != pat[++k])
					break;
			if (pat[k] == '$')	/* newline char */
				if (s[j] == '\n')
					continue;
			if (pat[k] == '_')	/* any character */
				continue;
			if (pat[k] == '*')	/* wildcard */
			{
				k++;
			 forward:
				while (s[j] && s[j] != pat[k])
					j++;
				for (m=j+1, n=k+1; s[m] && pat[n]; m++, n++) 
					if (s[m] != pat[n]) {
						j++;
						goto forward;
					}
			}
			if (s[j]=='\n' && pat[k]==' ')	/* ignore nl */
				continue;
			if (s[j] != pat[k])
				break;
		}
		if (pat[k] == NULL)
			return(i);
	}
	return(-1);
}
@@@ Fin de sfind.c
echo skel.c
cat >skel.c <<'@@@ Fin de skel.c'
# include <stdio.h>

main(argc, argv)	/* allow user to enter lines within skeleton */
int argc;
char *argv[];
{
	FILE *fopen(), *pfp, *fp;
	char s[BUFSIZ];

	if (argc != 2)
	{
		puts("Usage: skel filename\t\t(rev3.7)");
		exit(1);
	}
	if (access(argv[1], 0) == 0)
	{
		printf("File %s already exists.\n", argv[1]);
		exit(1);
	}
	if ((pfp = fopen("promptfile", "r")) == NULL)
	{
		puts("Required promptfile is missing.");
		exit(1);
	}
	if ((fp = fopen(argv[1], "w")) == NULL)
	{
		perror(argv[1]);
		exit(1);
	}
	while (fgets(s, BUFSIZ, pfp))
	{
		fputs(s, fp);
		fputs(s, stdout);
		do {
			putchar('\t');
			fgets(s, BUFSIZ, stdin);
			if (s[0] == '~' && (s[1] == 'e' || s[1] == 'v'))
			{
				callex(fp, argv[1], s[1]);
				puts("(continue)");
				continue;
			}
			putc('\t', fp);
			if (s[0] == '.' && s[1] == '\n')
				s[0] = '\003';		/* ctrl-c (etx) */
			fputs(s, fp);
		} while (s[0] != '\003' || s[1] != '\n');
	}
}

callex(fp, argv, e)	/* call ex editor to correct mistakes */
FILE *fp;
char *argv, e;
{
	FILE *tfp, *fopen();
	register int c;
	char command[80], *tempfile, *mktemp(), *sprintf();

	fp = freopen(argv, "r", fp);
	tempfile = "/tmp/SklXXXXX";
	mktemp(tempfile);
	tfp = fopen(tempfile, "w");
	while ((c = getc(fp)) != EOF)
		putc(c, tfp);
	if (ferror(tfp))
		perror(tempfile);
	fclose(tfp);
	if (e == 'e')
		sprintf(command, "ex %s", tempfile);
	if (e == 'v')
		sprintf(command, "vi +$ %s", tempfile);
	system(command);
	tfp = fopen(tempfile, "r");
	fp = freopen(argv, "w", fp);
	while ((c = getc(tfp)) != EOF)
		putc(c, fp);
	if (ferror(fp))
		perror(argv);
	fp = freopen(argv, "a", fp);
	unlink(tempfile);
	return;
}
@@@ Fin de skel.c
echo togrk.c
cat >togrk.c <<'@@@ Fin de togrk.c'
# include <stdio.h>				/* togrk.c (rev3.7) */

main(argc, argv)	/* transliterate Walton's Greek for nroff/troff */
int argc;
char *argv[];
{
	FILE *fopen(), *fp;
	int atbegin = 1;

	if (argc == 1)
	{
		tmacdef();
		togrk(stdin);
		exit(0);
	}
	while (--argc > 0)
	{
		if ((fp = fopen(*++argv, "r")) == NULL)
		{
			fflush(stdout);
			fprintf(stderr,
			"Togrk cannot access the file: %s\n", *argv);
			continue;
		}
		else  /* file opened successfully */
		{
			if (atbegin)
				tmacdef();
			atbegin = 0;
			togrk(fp);
			fclose(fp);
		}
	}
	exit(0);
}

togrk(fp)		/* convert transliteration to troff strings */
FILE *fp;
{
	register int c;

	while ((c = getc(fp)) != EOF)
	{
		switch (c)
		{
		case 'a': printf("\\(*a"); break;	/* alpha */
		case 'A': printf("\\(*A"); break;
		case 'b': printf("\\(*b"); break;	/* beta */
		case 'B': printf("\\(*B"); break;
		case 'g': printf("\\(*g"); break;	/* gamma */
		case 'G': printf("\\(*G"); break;
		case 'd': printf("\\(*d"); break;	/* delta */
		case 'D': printf("\\(*D"); break;
		case 'e': printf("\\(*e"); break;	/* epsilon */
		case 'E': printf("\\(*E"); break;
		case 'z': printf("\\(*z"); break;	/* zeta */
		case 'Z': printf("\\(*Z"); break;
		case 'h': printf("\\(*y"); break;	/* eta(* */
		case 'H': printf("\\(*Y"); break;
		case 'q': printf("\\(*h"); break;	/* theta(*) */
		case 'Q': printf("\\(*H"); break;
		case 'i': printf("\\(*i"); break;	/* iota */
		case 'I': printf("\\(*I"); break;
			/* iota subscript(*) - j - J */
		case 'j': printf("\\(*i"); break;	/* iota subsript? */
		case 'J': printf("\\(*I"); break;
		case 'k': printf("\\(*k"); break;	/* kappa */
		case 'K': printf("\\(*K"); break;
		case 'l': printf("\\(*l"); break;	/* lambda */
		case 'L': printf("\\(*L"); break;
		case 'm': printf("\\(*m"); break;	/* mu */
		case 'M': printf("\\(*M"); break;
		case 'n': printf("\\(*n"); break;	/* nu */
		case 'N': printf("\\(*N"); break;
		case 'x': printf("\\(*c"); break;	/* xi */
		case 'X': printf("\\(*C"); break;
		case 'o': printf("\\(*o"); break;	/* omicron */
		case 'O': printf("\\(*O"); break;
		case 'p': printf("\\(*p"); break;	/* pi */
		case 'P': printf("\\(*P"); break;
		case 'r': printf("\\(*r"); break;	/* rho */
		case 'R': printf("\\(*R"); break;
		case 's': printf("\\(*s"); break;	/* sigma */
		case 'S': printf("\\(*S"); break;
		case 't': printf("\\(*t"); break;	/* tau */
		case 'T': printf("\\(*T"); break;
		case 'u': printf("\\(*u"); break;	/* upsilon */
		case 'U': printf("\\(*U"); break;
		case 'f': printf("\\(*f"); break;	/* phi(*) */
		case 'F': printf("\\(*F"); break;
		case 'c': printf("\\(*x"); break;	/* chi */
		case 'C': printf("\\(*X"); break;
		case 'y': printf("\\(*q"); break;	/* psi */
		case 'Y': printf("\\(*Q"); break;
		case 'w': printf("\\(*w"); break;	/* omega */
		case 'W': printf("\\(*W"); break;
			/* digamma - \fIf\fR - \fIF\fR (passed as is) */
		case '+': printf("\\s-2\\(pl\\s0"); break;
		case '-': printf("\\s-2\\(mi\\s0"); break;
			/* grave accent - change from \ to ` */
		case '`':printf("\\*`"); break;
		case '^': printf("\\*^"); break;
		case '/': printf("\\*'"); break;
			/* question - ; (why not ? ?) */
			/* diaeresis e.g. over alpha - \(*:a */
			/* must be changed to a\*: */
		default: putchar(c); break;
		}
	}
}

tmacdef()	/* define troff macros so macro package isn't needed */
{
	printf(".if n \\{\\\n");
	printf(".ds #H 0\n");
	printf(".ds #V 0.8m\n");
	printf(".ds #f +0.3m\n");
	printf(".ds #[ \\f1\n");
	printf(".ds #] \\fP\n");
	printf(".\\}\n");
	printf(".if t \\{\\\n");
	printf(".ds #H ((1u-(\\\\\\\\n(.fu%2u))*0.13m)\n");
	printf(".ds #V 0.6m\n");
	printf(".ds #f \"\n");
	printf(".ds #[ \\&\n");
	printf(".ds #] \\&\n");
	printf(".\\}\n");
	printf(".ds ' \\k_\\h'-(\\\\n(.wu*8/10-\\*(#H)'\\*(#[\\(aa\\h'|\\\\n_u'\\*(#]\n");
	printf(".ds ` \\k_\\h'-(\\\\n(.wu*8/10-\\*(#H)'\\*(#[\\(ga\\h'|\\\\n_u'\\*(#]\n");
	printf(".ds ^ \\k_\\h'-(\\\\n(.wu-\\*(#H)'\\*(#[^\\h'|\\\\n_u'\\*(#]\n");
	printf(".ds : \\k_\\h'-(\\\\n(.wu*8/10-\\*(#H+0.1m\\*(#f)'\\v'-\\*(#V'\\*(#[\\z.\\h'0.2m\\*(#f'.\\h'|\\\\n_u'\\v'\\*(#V'\\*(#]\n");
	printf(".rm #[ #] #H #V #f\n");
}
@@@ Fin de togrk.c
echo tolpr.c
cat >tolpr.c <<'@@@ Fin de tolpr.c'
# include <stdio.h>			/* tolpr.c (rev3.7) */
# include <ctype.h>

int spacing = 1;	/* spacing factor (2 = doublespace) */
char hdr[512];		/* page header for optional title */
int shift = 1;		/* toggle shift over one tab stop */

main(argc, argv)	/* send 8.5 inch wide output to lpr */
int argc;
char *argv[];
{
	FILE *fp, *fopen();
	int i, files = 0;

	for (i = 1; i < argc; i++)
	{
		if (*argv[i] == '-')
		{
			if (isdigit(argv[i][1]))
				spacing = atoi(argv[i]+1);
			else if (argv[i][1] == 'h')
			{
				strcpy(hdr, argv[++i]);
				strcat(hdr, "  ");
			}
			else if (argv[i][1] == 's')
				shift = 0;
			else {
				fprintf(stderr, "Invalid tolpr flag: %s\n",
					argv[i]);
				exit(1);
			}
		}
		else if ((fp = fopen(argv[i], "r")) != NULL)
		{
			files = 1;
			tolpr(fp);
			fclose(fp);
		}
		else  /* cannot open file */
		{
			fprintf(stderr,
			"Tolpr cannot access the file: %s\n", argv[i]);
			exit(1);
		}
	}
	if (!files)
		tolpr(stdin);
	exit(0);
}

tolpr(fp)		/* insert tab at BOL, remarry widows */
FILE *fp;
{
	char s[BUFSIZ], first = 1, paginate = 0, empty;
	static int pageno = 1;
	register int lno;
	int i;

	for (lno = 1; fgets(s, BUFSIZ, fp); lno++)
	{
		if (first)			/* determine page scheme */
		{
			if (s[0] != '\n')
				paginate = 1;
			first = 0;
		}
		if (paginate && lno == 1)	/* provide 3 blank lines */
		{
			printf("\n\n\n");
			if (shift)
				putchar('\t');
			printf("%sPage %d\n\n", hdr, pageno++);
			lno = 6;
		}
		else if (paginate && lno == 63)	 /* save widow, new page */
		{
			if (empty)
			{
				printf("\n\n\n\n\n\n\n");
				if (shift)
					putchar('\t');
				printf("%sPage %d\n\n", hdr,pageno++);
				lno = 6;
			}
		}
		else if (paginate && lno >= 64)	 /* break to new page */
		{
			breakpg:
				printf("\n\n\n\n\n\n");
				if (shift)
					putchar('\t');
				printf("%sPage %d\n\n", hdr,pageno++);
				lno = 6;
		}
		else if (lno >= 66)		/* reset page cycle */
			lno = 1;

		for (i = 1; i < spacing; i++)	/* optional linespacing */
		{
			putchar('\n');
			lno++;
			if (lno >= 64)
				goto breakpg;
		}
		if (s[0] != '\n' && shift)	/* don't pad empty lines */
		{
			putchar('\t');
			empty = 0;		/* remember empty lines */
		}
		else
			empty = 1;

		fputs(s, stdout);
	}
	while (lno++ <= 66)			/* force out page */
		putchar('\n');
}
@@@ Fin de tolpr.c
echo tosel.c
cat >tosel.c <<'@@@ Fin de tosel.c'
# include <stdio.h>			/* tosel.c (rev3.7) */

main(argc, argv)	/* convert English for IBM terminal */
int argc;
char *argv[];
{
	FILE *fp, *fopen();

	if (argc == 1)
		convert(stdin);
	else
	{
		while (--argc > 0)
			if ((fp = fopen(*++argv, "r")) == NULL)
			{
				fprintf(stderr,
				"Tosel cannot access the file: %s\n",
				*argv);
				continue;
			}
			else
			{
				convert(fp);
				fclose(fp);
			}
		exit(0);
	}
}

convert(fp)		/* Unix ASCII to type-ball EBCDIC */
FILE *fp;
{
	char c;

	while ((c = getc(fp)) != EOF)
		switch (c)
		{
		case 'a': putchar(c = 'p'); break;
		case 'b': putchar(c = ','); break;
		case 'c': putchar(c = 'x'); break;
		case 'd': putchar(c = 'v'); break;
		case 'e': putchar(c = 'u'); break;
		case 'f': putchar(c = 'c'); break;
		case 'g': putchar(c = 'a'); break;
		case 'h': putchar(c = 'z'); break;
		case 'i': putchar(c = 'o'); break;
		case 'j': putchar(c = '&'); break;
		case 'k': putchar(c = 'w'); break;
		case 'l': putchar(c = 'y'); break;
		case 'm': putchar(c = 'j'); break;
		case 'n': putchar(c = 's'); break;
		case 'o': putchar(c = 'q'); break;
		case 'p': putchar(c = 'd'); break;
		case 'q': putchar(c = 'f'); break;
		case 'r': putchar(c = 'n'); break;
		case 's': putchar(c = 'r'); break;
		case 't': putchar(c = '@'); break;
		case 'u': putchar(c = 't'); break;
		case 'v': putchar(c = 'l'); break;
		case 'w': putchar(c = '$'); break;
		case 'x': putchar(c = '/'); break;
		case 'y': putchar(c = 'i'); break;
		case 'z': putchar(c = '0'); break;
		case '.': putchar(c = 'k'); break;
		case ',': putchar(c = 'g'); break;
		case ';': putchar(c = 'e'); break;
		case ':': putchar(c = 'E'); break;
		case '-': putchar(c = '.'); break;
		case '!': putchar(c = '='); break;	
		case '?': putchar(c = 'H'); break;
		case '/': putchar(c = 'h'); break;
		case '"': putchar(c = 'M'); break;
		case '\'': putchar(c = 'm'); break;
		case '(': putchar(c = '"'); break;
		case ')': putchar(c = '('); break;
		case '_': putchar(c = '~'); break;
		case '%': putchar(c = ':'); break;
		case '&': putchar(c = '%'); break;
		case '$': putchar(c = '*'); break;
		case '=': putchar(c = 'b'); break;
		case '+': putchar(c = 'B'); break;
		case '*': putchar(c = '>'); break;
		case '@': putchar(c = '<'); break;
		case '#': putchar(c = ';'); break;
		case '0': putchar(c = '9'); break;
		case '4': putchar(c = '8'); break;
		case '5': putchar(c = '4'); break;
		case '7': putchar(c = '5'); break;
		case '8': putchar(c = '7'); break;
		case '9': putchar(c = '#'); break;
		case 'A': putchar(c = 'P'); break;
		case 'B': putchar(c = '|'); break;
		case 'C': putchar(c = 'X'); break;
		case 'D': putchar(c = 'V'); break;
		case 'E': putchar(c = 'U'); break;
		case 'F': putchar(c = 'C'); break;
		case 'G': putchar(c = 'A'); break;
		case 'H': putchar(c = 'Z'); break;
		case 'I': putchar(c = 'O'); break;
		case 'J': putchar(c = '+'); break;
		case 'K': putchar(c = 'W'); break;
		case 'L': putchar(c = 'Y'); break;
		case 'M': putchar(c = 'J'); break;
		case 'N': putchar(c = 'S'); break;
		case 'O': putchar(c = 'Q'); break;
		case 'P': putchar(c = 'D'); break;
		case 'Q': putchar(c = 'F'); break;
		case 'R': putchar(c = 'N'); break;
		case 'S': putchar(c = 'R'); break;
		case 'T': putchar(c = '\\'); break;
		case 'U': putchar(c = 'T'); break;
		case 'V': putchar(c = 'L'); break;
		case 'W': putchar(c = '!'); break;
		case 'X': putchar(c = '?'); break;
		case 'Y': putchar(c = 'I'); break;
		case 'Z': putchar(c = ')'); break;
		case '[': putchar(c = '"'); break; /* prints ( */
		case '{': putchar(c = '"'); break;
		case ']': putchar(c = '('); break; /* prints ) */
		case '}': putchar(c = '('); break;
		case '`': putchar(c = 'm'); break;
		default: putchar(c); break;
		}
}
@@@ Fin de tosel.c
echo tprep.c
cat >tprep.c <<'@@@ Fin de tprep.c'
# include <stdio.h>			/* tprep.c (rev3.7) */
# include <ctype.h>
# include <signal.h>

usage()		/* print usage and synopsis of options */
{
	puts("Usage: tprep [-y -tpu] filename(s)\t\t(rev3.7)");
	puts("-y: say yes and suppress interactive prompting");
	puts("-t: trim lines, removing trailing blanks and tabs");
	puts("-p: pad, inserting blank at beginning of each line");
	puts("-u: unpad, deleting blank at beginning of each line");
	puts("Tprep rewrites files back on top of themselves.");
	exit(1);
}

char *tempfile;		/* storage file for modified text */
int askflag = 1;	/* ask user's permission (default on) */
int tflag = 0;		/* toggle option for trimming */
int pflag = 0;		/* toggle option for padding */
int uflag = 0;		/* toggle option for unpadding */

main(argc, argv)	/* insert or delete leading blanks */
int argc;
char *argv[];
{
	FILE *fp, *fopen();
	char *s, *mktemp();
	int i = 1;

	if (argc == 1)
		usage();

	for (i = 1; i < argc && *argv[i] == '-'; i++)
		for (s = argv[i]+1; *s != NULL; s++)
			if (*s == 'y')
				askflag = 0;
			else if (*s == 't')
				tflag = 1;
			else if (*s == 'p')
				pflag = 1;
			else if (*s == 'u')
				uflag = 1;
			else
			{
				fprintf(stderr,
				"Illegal tprep option: -%c\n", *s);
				exit(1);
			}
	if (tflag + pflag + uflag > 1)
	{
		fprintf(stderr, "Using incompatible tprep options\n");
		exit(1);
	}
	if (askflag)
		permission();
	if (!tflag && !pflag && !uflag)
		options();

	signal(SIGINT, SIG_IGN);
	tempfile = "/tmp/PrepXXXXX";
	mktemp(tempfile);

	for (; i < argc; i++)
	{
		if ((fp = fopen(argv[i], "r")) != NULL)
		{
			fprintf(stderr,
			"Rewriting the file: %s\n", argv[i]);
			if (tflag)
				trim(fp);
			if (pflag)
				pad(fp);
			if (uflag)
				unpad(fp);
			if (freopen(argv[i], "w", fp) == NULL)
			{
				fprintf(stderr,
				"%s: Write permission denied\n", argv[i]);
				unlink(tempfile);
				exit(1);
			}
			overwrite(fp);
			fclose(fp);
		}
		else  /* attempt to open file failed */
		{
			fprintf(stderr,
			"Tprep cannot access the file: %s\n", argv[i]);
			unlink(tempfile);
			exit(1);
		}
	}
	unlink(tempfile);
	exit(0);
}

permission()		/* make sure user agrees to rewrite files */
{
	FILE *term, *fopen();
	char ans[512];

	term = fopen("/dev/tty", "r");
	fprintf(stderr, "Do you know tprep rewrites files in command line?\n");
	fprintf(stderr, "Type \"y\" if this is OK with you: ");
	fgets(ans, 512, term);
	if (*ans == 'y' || *ans == 'Y')
		putc('\n', stderr);
	else
	{
		fprintf(stderr, "If it makes you feel safer, ");
		fprintf(stderr, "you could copy files to /usr/tmp.\n");
		exit(1);
	}
	return;
}

options()		/* ask user whether to trim, pad or unpad */
{
	FILE *term, *fopen();
	char ans[512];
	int done = 0;

	term = fopen("/dev/tty", "r");
	while (!done)
	{
		fprintf(stderr, "Do you want to trim, pad, or unpad? ");
		fgets(ans, 512, term);
		if (*ans == 't' || *ans == 'T')
		{
			tflag = 1;
			done = 1;
		}
		else if (*ans == 'p' || *ans == 'P')
		{
			pflag = 1;
			done = 1;
		}
		else if (*ans == 'u' || *ans == 'U')
		{
			uflag = 1;
			done = 1;
		}
		else if (*ans == 'q' || *ans == 'Q')
			exit(1);
		else
			fprintf(stderr,
			"\tJust answer \"t\", \"p\" or \"u\" (\"q\" exits).\n");
	}
	putc('\n', stderr);
	return;
}

trim(fp)		/* trim off blanks and send to tempfile */
FILE *fp;
{
	FILE *tfp, *fopen();
	char line[512];
	long count = 0;
	int n;

	tfp = fopen(tempfile, "w");
	while (fgets(line, 512, fp))
	{
		n = strlen(line);
		while (--n >= 0)
		{
			if (!isspace(line[n]))
				break;
			count++;
		}
		line[++n] = '\n';
		line[++n] = NULL;
		fputs(line, tfp);
		count--;		/* uncount newline */
	}
	fclose(tfp);
	fprintf(stderr, "\t%ld blanks and tabs removed\n", count);
}

pad(fp)			/* pad line with blank and send to tempfile */
FILE *fp;
{
	FILE *tfp, *fopen();
	char line[512];
	int count = 0;

	tfp = fopen(tempfile, "w");
	while (fgets(line, 512, fp))
	{
		fprintf(tfp, " %s", line);
		count++;
	}
	fclose(tfp);
	fprintf(stderr, "\t%d lines padded\n", count);
}

unpad(fp)		/* strip leading blank and send to tempfile */
FILE *fp;
{
	FILE *tfp, *fopen();
	char line[512], copy[512];
	int i, j, count = 0;

	tfp = fopen(tempfile, "w");
	while (fgets(line, 512, fp))
	{
		i = 0;
		if (line[i] == ' ')
		{
			i++;
			count++;
		}
		for (j = 0; line[i] != NULL; i++, j++)
			copy[j] = line[i];
		copy[j] = NULL;
		fputs(copy, tfp);
	}
	fclose(tfp);
	fprintf(stderr, "\t%d lines unpadded\n", count);
}

overwrite(fp)		/* write tempfile back over original file */
FILE *fp;
{
	FILE *tfp, *fopen();
	char line[512];

	tfp = fopen(tempfile, "r");
	while (fgets(line, 512, tfp))
		fputs(line, fp);
	fclose(tfp);
}
@@@ Fin de tprep.c
echo troffmt.c
cat >troffmt.c <<'@@@ Fin de troffmt.c'
# include <stdio.h>			/* troffmt.c (rev3.7) */
# include <ctype.h>
# include <signal.h>

char *tempfile;		/* to store contexts while counting */
int nocnt = 0;		/* toggle for not counting keyword */
int nokwd = 0;		/* toggle for suppressing keyword */
int nomacs = 0;		/* toggle for not supplying macros */

usage()			/* print proper usage and exit */
{
	puts("Usage: troffmt [-ckm] [filename(s)] [-]\t\t(rev3.7)");
	puts("-c: suppress counting of keyword frequency");
	puts("-k: entirely suppress printing of keyword");
	puts("-m: do not supply concordance macros automatically");
	puts("- : read standard input instead of files");
	exit(1);
}

main(argc, argv)	/* format concordance for sending to troff */
int argc;
char *argv[];
{
	FILE *fopen(), *fp;
	int i, j, onintr();
	char *mktemp();

	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, onintr);

	tempfile = "/tmp/FmtXXXXX";
	mktemp(tempfile);

	for (i = 1; *argv[i] == '-'; i++)
	{
		for (j = 1; argv[i][j] != NULL; j++)
		{
			if (argv[i][j] == 'c')
				nocnt = 1;
			else if (argv[i][j] == 'k')
				nokwd = 1;
			else if (argv[i][j] == 'm')
				nomacs = 1;
			else  /* bad option */
			{
				fprintf(stderr,
				"Illegal troffmt flag: -%c\n", argv[i][j]);
				usage();
			}
		}
	}
	if (!nomacs)
		pr_macs();
	if (i == argc)
	{
		if (nokwd)
			rmkwds(stdin);
		else if (nocnt)
			ffmt(stdin);
		else
			format(stdin);
	}
	for (; i < argc; i++)
	{
		if (argv[i][0] == '-' && argv[i][1] == NULL)
		{
			if (nokwd)
				rmkwds(stdin);
			else if (nocnt)
				ffmt(stdin);
			else
				format(stdin);
		}
		if ((fp = fopen(argv[i], "r")) != NULL)
		{
			if (nokwd)
				rmkwds(fp);
			else if (nocnt)
				ffmt(fp);
			else
				format(fp);
			fclose(fp);
		}
		else  /* attempt to open file failed */
		{
			fprintf(stderr,
			"Trfmt cannot access the file: %s\n", argv[i]);
			continue;
		}
	}
	unlink(tempfile);
	exit(0);
}

pr_macs()		/* supply concordance macros automatically */
{
	printf(".de KW\n.ne 2.1\n.sp 0.3\n.ta 20n\n.ft B\n..\n");
	printf(".de CX\n.sp 0.1\n.ta 3.6iR 3.75i\n.ft R\n..\n");
	printf(".de HD\n.tl '--''--'\n'sp 2\n.tl ''- %% -''\n'sp 2\n..\n");
	printf(".de FO\n'bp\n..\n.wh 0 HD\n.wh -5 FO\n");
	printf(".so /usr/lib/me/chars.me\n");		/* -me accent marks */
	printf(".nf\n.po 0.5i\n.ll 7.0i\n.lt 7.0i\n");
}

format(fp)	  	/* print keyword and count only if different */
FILE *fp;
{
	FILE *fopen(), *tf;
	char s[BUFSIZ], okw[BUFSIZ/2], nkw[BUFSIZ/2], cntxt[BUFSIZ];
	char *sp, *kwp, *cxp, *strcpy();
	int kwfreq = 0;

	strcpy(okw,"~~~~~");	/* make sure 1st keyword is printed */
	tf = NULL;		/* to prevent core dump with no input */
	while (fgets(s, BUFSIZ, fp))
	{
		for (sp = s, kwp = nkw; *sp != ' ' && *sp != '|'; sp++, kwp++)
		{
			if (*sp == '\b')	/* interpolate troff string */
			{
				*kwp = '\\';
				*++kwp = '*';
			} else
				*kwp = *sp;
		}
		*kwp = NULL;
		for (; *sp && *sp != '|'; sp++)
			;
		for (++sp, cxp = cntxt; *sp && *sp != '\n'; sp++, cxp++)
		{
			if (*sp == '|')
				*cxp = '\t';
			else if (*sp == '\b')	/* interpolate troff string */
			{
				*cxp = '\\';
				*++cxp = '*';
			} else
				*cxp = *sp;
		}
		*cxp = '\n';
		*++cxp = NULL;

		if (strcmp(nkw, okw) != 0)  /* kwds different */
		{
			if (kwfreq != 0)
				prtmpfile(tf, kwfreq);
			printf(".KW\n%s\t", nkw);
			tf = fopen(tempfile, "w");
			fputs(cntxt, tf);
			kwfreq = 1;
		}
		else  /* if keywords are the same */
		{
			fputs(cntxt, tf);
			kwfreq++;
		}
		strcpy(okw, nkw);
	}
	prtmpfile(tf, kwfreq);
}

prtmpfile(tf, kwfreq)		/* print frequency and contexts */
FILE *tf;
int kwfreq;
{
	char save[BUFSIZ];

	if (tf == NULL)		/* exit without core dump */
		exit(1);

	printf("(%d)\n.CX\n", kwfreq);
	fclose(tf);
	tf = fopen(tempfile, "r");
	while (fgets(save, BUFSIZ, tf))
		printf(" %s", save);
	fclose(tf);
}

int onintr()		/* remove tempfile in case of interrupt */
{
	fprintf(stderr, "\nInterrupt\n");
	unlink(tempfile);
	exit(1);
}

ffmt(fp)	  	/* fast format routine, no keyword counting */
FILE *fp;
{
	char s[BUFSIZ], okw[BUFSIZ/2], nkw[BUFSIZ/2], cntxt[BUFSIZ];
	char *sp, *kwp, *cxp;

	strcpy(okw,"~~~~~");	/* make sure 1st keyword is printed */

	while (fgets(s, BUFSIZ, fp))
	{ 
		for (sp = s, kwp = nkw; *sp && *sp != ' '; sp++, kwp++)
		{
			if (*sp == '\b')	/* interpolate troff string */
			{
				*kwp = '\\';
				*++kwp = '*';
			} else
				*kwp = *sp;
		}
		*kwp = NULL;
		for (; *sp && *sp != '|'; sp++)
			;
		for (++sp, cxp = cntxt; *sp && *sp != '\n'; sp++, cxp++)
		{
			if (*sp == '|')
				*cxp = '\t';
			else if (*sp == '\b')	/* interpolate troff string */
			{
				*cxp = '\\';
				*++cxp = '*';
			} else
				*cxp = *sp;
		}
		*cxp = '\n';
		*++cxp = NULL;

		if (strcmp(nkw, okw) != 0)  /* kwds different */
			printf(".KW\n%s\n.CX\n %s", nkw, cntxt);
		else  /* if keywords are the same */
			printf(" %s", cntxt);
		strcpy(okw, nkw);
	}
}

rmkwds(fp)		/* completely suppress printing of keyword */
FILE *fp;
{
	char s[BUFSIZ], *sp;

	while (fgets(s, BUFSIZ, fp))
	{
		for (sp = s; *sp && *sp != '|'; sp++)
			;
		for (; *sp; sp++)
		{
			if (*sp == '|')
				putchar(' ');
			else
				putchar(*sp);
		}
	}
}
@@@ Fin de troffmt.c
echo wdlen.c
cat >wdlen.c <<'@@@ Fin de wdlen.c'
# include <stdio.h>			/* wdlen.c (rev3.7) */
# include <ctype.h>

char punctuation[512] = ",.;:-?!\"()[]{}" ;

int wdlngs[21];		/* array with counts of word lengths */
int longlpr = 0;	/* toggle option for long histogram */

main(argc, argv)	/* tabulate word length frequency */
int argc;
char *argv[];
{
	FILE *fopen(), *fp;
	int i;

	if (argc == 1)
	{
		puts("Usage: wdlen [-l -dPfile -] filename(s)\t\t(rev3.7)");
		puts("-l: print long histogram suitable for lineprinter");
		puts("-d: define punctuation set according to Pfile");
		puts("- : read standard input instead of files");
		exit(1);
	}
	initialize();
	for (i = 1; i < argc; i++)
	{
		if (*argv[i] == '-')
			getflag(argv[i]);
		else if ((fp = fopen(argv[i], "r")) != NULL)
		{
			wdlen(fp);
			fclose(fp);
		}
		else
		{
			fprintf(stderr,
			"Wdlen cannot access the file: %s\n", argv[i]);
			exit(1);
		}
	}
	pr_results();
	exit(0);
}

initialize()		/* set word length array to all zeros */
{
	int i;

	for (i = 0; i < 21; i++)
		wdlngs[i] = 0;
}

getflag(f)		/* parses command line to set options */
char *f;
{
	char *pfile;

	f++;
	switch(*f++)
	{
		case 'l':
			longlpr = 1;
			break;
		case 'd':
			pfile = f;
			getpunct(pfile);
			break;
		case NULL:
			wdlen(stdin);
			break;
		default:
			fprintf(stderr,
			"Invalid wdlen flag: -%s\n", --f);
			exit(1);
			break;
	}
}

getpunct(pfile)		/* read user's punctuation from pfile */
char *pfile;
{
	FILE *pfp, *fopen();
	char s[512], *strcpy();

	if ((pfp = fopen(pfile, "r")) == NULL)
	{
		fprintf(stderr,
		"Wdlen cannot access Punctfile: %s\n", pfile);
		exit(1);
	}
	else
		while (fgets(s, 512, pfp))
			strcpy(punctuation, s);
}

wdlen(fp)		/* tabulate array of word lengths */
FILE *fp;
{
	int wlen;

	while (wlen = getword(fp))
		if (wlen < 21)
			++wdlngs[wlen];
}

getword(fp)		/* move through text, counting word lengths */
FILE *fp;
{
	int wlen = 1;
	register int c;

	while ((c = getc(fp)) != EOF && isskip(c))
		;
	if (c == EOF)
		return(NULL);
	while ((c = getc(fp)) != EOF && !isskip(c))
		wlen++;
	return(wlen);
}

isskip(c)		/* function to evaluate punctuation */
char c;
{
	char *ptr;

	if (isspace(c))
		return(1);
	for (ptr = punctuation; *ptr != c && *ptr != NULL; ptr++)
		;
	if (*ptr == NULL)
		return(0);
	else
		return(1);
}

pr_results()		/* print out table of word lengths */
{
	int max, incr, i, j;

	max = 0;
	for (i = 1; i < 21; i++)
		if (wdlngs[i] > max)
			max = wdlngs[i];
	if (longlpr)
		incr = max/100;
	else
		incr = max/60;
	if (incr == 0)
		incr = 1;
	printf("Wdlen: Count:\n");
	for (i = 1; i < 21; i++)
	{
		printf("   %2d  ", i);
		printf("%5d  ", wdlngs[i]);
		for (j = 0; j < wdlngs[i]; j = j + incr)
			putchar('-');
		putchar('\n');
	}
}
@@@ Fin de wdlen.c
echo wheel.c
cat >wheel.c <<'@@@ Fin de wheel.c'
# include <stdio.h>			/* wheel.c (rev3.7) */
# include <ctype.h>

int nomap = 0;		/* toggle to not map upper to lower case */
int notch = 2;		/* number of words rolling around wheel */

main(argc, argv)	/* print overlapping word clusters in text */
int argc;
char *argv[];
{
	FILE *fp, *fopen();
	int i;

	if (argc == 1)
	{
		puts("Usage: wheel [+n -m -dF -] filename(s)\t\t(rev3.7)");
		puts("+n: print clusters of n words (default 2)");
		puts("-m: do not map upper case to lower case");
		puts("-d: define punctuation set according to file F");
		puts("- : read standard input instead of files");
		exit(1);
	}
	for (i = 1; i < argc; i++)
	{
		if (*argv[i] == '-')
			getflag(argv[i]);
		else if (*argv[i] == '+')
		{
			notch = atoi(argv[i]+1);
			if (notch > 20)
			{
				fprintf(stderr,
				"Clusters must be smaller than 20.\n");
				exit(1);
			}
		}
		else if ((fp = fopen(argv[i], "r")) != NULL)
		{
			roll(fp);
			fclose(fp);
		}
		else  /* cannot open file */
		{
			fprintf(stderr,
			"Wheel cannot access the file: %s\n", argv[i]);
			continue;
		}
	}
	exit(0);
}

getflag(f)		/* parses command line to set options */
char *f;
{
	char *pfile;

	f++;
	switch(*f++)
	{
		case 'm':
			nomap = 1;
			break;
		case 'd':
			pfile = f;
			getpunct(pfile);
			break;
		case NULL:
			roll(stdin);
			break;
		default:
			fprintf(stderr,
			"Invalid wheel flag: -%s\n", --f);
			exit(1);
			break;
	}
}

char punctuation[BUFSIZ] = ",.;:-?!\"()[]{}" ;

getpunct(pfile)		/* read user's punctuation from pfile */
char *pfile;
{
	FILE *pfp, *fopen();
	char s[BUFSIZ], *strcpy();

	if ((pfp = fopen(pfile, "r")) == NULL)
	{
		fprintf(stderr,
		"Wheel cannot access Punctfile: %s\n", pfile);
		exit(1);
	}
	else
		while (fgets(s, BUFSIZ, pfp))
			strcpy(punctuation, s);
}

roll(fp)		/* roll word wheel through text */
FILE *fp;
{
	char word[BUFSIZ], wheel[20][BUFSIZ];
	int i;

	for (i = 0; i < 20; i++)
		*wheel[i] = NULL;
	while (getword(word, fp))
	{
		for (i = 0; i < notch-1; i++)
			strcpy(wheel[i], wheel[i+1]);
		strcpy(wheel[notch-1], word);

		if (*wheel[0] == NULL)
			continue;
		for (i = 0; i < notch; i++)
		{
			if (i != 0)
				putchar(' ');
			fputs(wheel[i], stdout);
		}
		putchar('\n');
	}
}

getword(word, fp)	/* drives program through text word by word */
char word[];
FILE *fp;
{
	while ((*word = getc(fp)) && isskip(*word) && *word != EOF)
		;
	if (*word == EOF)
		return(0);
	if (!nomap && isupper(*word))
		*word = tolower(*word);

	while ((*++word = getc(fp)) && !isskip(*word) && *word != EOF)
	{
		if (!nomap && isupper(*word))
			*word = tolower(*word);
	}
	*word = NULL;
	return(1);
}

isskip(c)		/* function to evaluate punctuation */
char c;
{
	char *ptr;

	if (isspace(c))
		return(1);
	for (ptr = punctuation; *ptr != c && *ptr != NULL; ptr++)
		;
	if (*ptr == NULL)
		return(0);
	else
		return(1);
}
@@@ Fin de wheel.c
echo xref.c
cat >xref.c <<'@@@ Fin de xref.c'
# include <stdio.h>				/* xref.c (rev3.7) */
# include <ctype.h>
# include <signal.h>

usage()			/* print usage and synopsis of options */
{
	puts("Cross Reference Generator\t\t\t(rev3.7)");
	puts("Usage: xref [-r -ln -pn -ic -dPfile -] filename(s)");
	puts("-r : reset linenumber to 1 at beginning of every file");
	puts("-ln: line numbering begins with line n (instead of 1)");
	puts("-pn: page numbering begins with page n (instead of 1)");
	puts("-ic: page incrementer is character c (defaults to =)");
	puts("-wn: width of output page is n (defaults to 80)");
	puts("-d : define punctuation set according to Pfile");
	puts("-  : read text from standard input (terminal or pipe)");
	exit(1);
}

long lineno = 1;	/* count line numbers */
int resetno = 0;	/* reset lineno for new file */
char pgincr = '=';	/* page incrementing character */
int pageno = 0;		/* toggle and count page numbers */
int width = 70;		/* page width for entries */

char punctuation[512] = ",.;:-?!\"()[]{}" ;
char *tempfile = "/tmp/RefXXXXX";

main(argc, argv)	/* cross reference generator for a text */
int argc;
char *argv[];
{
	FILE *fp, *tfp, *fopen();
	char command[BUFSIZ], *mktemp(), *sprintf();
	int i, catch();

	if (argc == 1)
		usage();
	mktemp(tempfile);
	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, catch);
	for (i = 1; i < argc; i++)
	{
		if (*argv[i] == '-')
			getflag(argv[i]);
		else if ((fp = fopen(argv[i], "r")) != NULL)
		{
			xref(fp);
			fclose(fp);
			if (resetno)
				lineno = 1;
		}
		else  /* cannot open file */
		{
			fprintf(stderr,
			"Xref cannot access the file: %s\n", argv[i]);
			exit(1);
		}
	}
	sprintf(command, "sort %s -o %s", tempfile, tempfile);
	system(command);
	if ((tfp = fopen(tempfile, "r")) != NULL)
		frmt(tfp);
	unlink(tempfile);
	exit(0);
}

getflag(f)		/* parses command line to set options */
char *f;
{
	char *pfile;
	long atol();

	f++;
	switch(*f++)
	{
		case 'r':
			resetno = 1;
			break;
		case 'l':
			lineno = atol(f);
			break;
		case 'p':
			pageno = atoi(f);
			break;
		case 'i':
			pgincr = *f;
			break;
		case 'd':
			pfile = f;
			getpunct(pfile);
			break;
		case 'w':
			width = atoi(f) - 10;
			break;
		case NULL:
			xref(stdin);
			break;
		default:
			fprintf(stderr,
			"Invalid xref flag: -%s\n", --f);
			exit(1);
			break;
	}
}

getpunct(pfile)		/* read user's punctuation from pfile */
char *pfile;
{
	FILE *pfp, *fopen();
	char s[512], *strcpy();

	if ((pfp = fopen(pfile, "r")) == NULL)
	{
		fprintf(stderr,
		"Xref cannot access Punctfile: %s\n", pfile);
		exit(1);
	}
	else
		while (fgets(s, 512, pfp))
			strcpy(punctuation, s);
}

xref(fp)		/* prints cross reference for each word */
FILE *fp;
{
	FILE *tfp, *fopen();
	char word[BUFSIZ];

	if ((tfp = fopen(tempfile, "a")) == NULL)
	{
		perror(tempfile);
		exit(1);
	}
	while (getword(word, fp))
	{
		fprintf(tfp, "%s\002", word);  /* ctrl-b */

		if (pageno)
			fprintf(tfp, "%3d,%2ld; \n", pageno, lineno);
		else
			fprintf(tfp, "%5ld; \n", lineno);
	}
	fclose(tfp);
}

getword(word, fp)	/* drives program through text word by word */
char word[];
FILE *fp;
{
	static char nl = 0;

	if (nl)		/* increments lineno at beginning of line */
	{
		nl = 0;
		lineno++;
	}
	while ((*word = getc(fp)) && isskip(*word) && *word != EOF)
		if (*word == '\n')	/* skip to text */
			lineno++;

	if (*word == pgincr)
	{
		pageno++;	/* pgincr must begin word */
		lineno = 0;
	}
	if (*word == EOF)
		return(0);
	if (isupper(*word))
		*word = tolower(*word);

	while ((*++word = getc(fp)) && !isskip(*word) && *word !=EOF)
		if (isupper(*word))
			*word = tolower(*word);

	if (*word == '\n')	/* set nl at end of line */
		nl = 1;
	*word = NULL;

	return(1);
}

isskip(c)		/* function to evaluate punctuation */
char c;
{
	char *ptr;

	if (isspace(c))
		return(1);
	for (ptr = punctuation; *ptr != c && *ptr != NULL; ptr++)
		;
	if (*ptr == NULL)
		return(0);
	else
		return(1);
}

frmt(fp)		/* format keywords and line numbers */
FILE *fp;
{
	char s[BUFSIZ], entry[BUFSIZ], *initial = "~~~~~";
	char old[BUFSIZ], new[BUFSIZ], ref[BUFSIZ], *strcat();
	int i, j;

	strcpy(old, initial);  /* make sure 1st kwd printed */
	*entry = NULL;

	while (fgets(s, BUFSIZ, fp))
	{
		for (i = 0; s[i] != '\002' && i < 510; i++)
			new[i] = s[i];
		new[i] = NULL;

		for (++i, j = 0; s[i] != '\n' && i < 510; i++, j++)
			ref[j] = s[i];
		ref[j] = NULL;

		if (strcmp(new, old) != 0)
		{
			if (*entry != NULL)
				printf("%s\n", entry);
			entry[0] = ' ';
			entry[1] = NULL;
			printf("%s\n", new);
		}
		if (strlen(entry) < width)
			strcat(entry, ref);
		else  /* build entry */
		{
			printf("%s\n", entry);
			entry[0] = ' ';
			entry[1] = NULL;
			strcat(entry, ref);
		}
		strcpy(old, new);
	}
	printf("%s\n", entry);
}

catch()			/* remove tempfile in case of interrupt */
{
	unlink(tempfile);
	fprintf(stderr, "\nInterrupt\n");
	exit(1);
}
@@@ Fin de xref.c
echo ztext
cat >ztext <<'@@@ Fin de ztext'
All sounds of the shore were gone--
wing beats of pelicans,
the low wash of the waves,
the skim sizzling thru the drift,
the waving of palm wings on the breeze that shuffles terns,
the chaotic song of the canary trees--
all these were missing,
as if the storm on the horizon,
breathing, had drawn them in.
@@@ Fin de ztext
exit 0
