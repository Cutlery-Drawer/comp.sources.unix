Path: uunet!rs
From: rs@uunet.UU.NET (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v10i058:  X10R4 patches for Sun3/110C, Part02/3
Message-ID: <644@uunet.UU.NET>
Date: 16 Jul 87 00:08:07 GMT
Organization: UUNET Communications Services, Arlington, VA
Lines: 2149
Approved: rs@uunet.UU.NET

Submitted-by: rochester!rocksanne!mayer (James L. Mayer)
Posting-Number: Volume 10, Issue 58
Archive-name: x10r4.sunpch/Part02

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	NOTICE.Xerox
#	libsun.2
#	changes
#	history
#	X
# This archive created: Mon Jun  8 20:00:14 1987
# By:	James L. Mayer (Xerox Corporation)
export PATH; PATH=/bin:$PATH
echo shar: extracting "'NOTICE.Xerox'" '(1342 characters)'
if test -f 'NOTICE.Xerox'
then
	echo shar: will not over-write existing file "'NOTICE.Xerox'"
else
sed 's/^	X//' << \SHAR_EOF > 'NOTICE.Xerox'
	XCopyright (c) 1987 Xerox Corporation
	X
	XPermission to use, copy, modify, and distribute these modifications is
	Xhereby granted, provided that the above copyright notice appear in all
	Xcopies and that that both that copyright notice and this permission notice
	Xappear in supporting documentation, and that the name of Xerox Corporation
	Xnot be used in advertising or publicity pertaining to distribution of
	Xthe software without specific, written prior permission.
	X
	XTHE XEROX CHANGES TO THE V10R4 RELEASE OF THE X WINDOW SYSTEM ARE
	XPROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE WARRANTIES
	XOF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, OR
	XARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
	X
	XThe Xerox changes to the V10R4 release of the X Window System are
	Xprovided with no support and without any obligation on the part of
	XXerox Corporation to assist in their use, correction, modification or
	Xenhancement.
	X
	XXEROX CORPORATION SHALL HAVE NO LIABILITY WITH RESPECT TO THE INFRINGEMENT
	XOF COPYRIGHT, TRADE SECRETS OR ANY PATENTS BY THE XEROX CHANGES TO THE
	XV10R4 RELEASE OF THE X WINDOW SYSTEM OR ANY PART THEROF.
	X
	XIn no event will Xerox Corporation be liable for any lost revenue or profits
	Xor other special, indirect and consequential damages, even if Xerox had been
	Xadvised of the possibility of such damages.
SHAR_EOF
if test 1342 -ne "`wc -c < 'NOTICE.Xerox'`"
then
	echo shar: error transmitting "'NOTICE.Xerox'" '(should have been 1342 characters)'
fi
fi # end of overwriting check
if test ! -d 'libsun.2'
then
	echo shar: creating directory "'libsun.2'"
	mkdir 'libsun.2'
fi
echo shar: entering directory "'libsun.2'"
cd 'libsun.2'
if test ! -d 'changes'
then
	echo shar: creating directory "'changes'"
	mkdir 'changes'
fi
echo shar: entering directory "'changes'"
cd 'changes'
echo shar: extracting "'text.c.patch'" '(10412 characters)'
if test -f 'text.c.patch'
then
	echo shar: will not over-write existing file "'text.c.patch'"
else
sed 's/^	X//' << \SHAR_EOF > 'text.c.patch'
	X*** /usr/src/new/X.V10R4/libsun/text.c	Mon Dec  1 19:24:22 1986
	X--- text.c	Mon Jun  8 14:30:56 1987
	X***************
	X*** 4,9 ****
	X--- 4,10 ----
	X   * Copyright (c) 1985 Massachusetts Institue of Technology
	X   * Copyright (c) 1986 Sun Microsystems, Inc.
	X   * Copyright (c) 1986 David C. Martin, UC Berkeley
	X+  * Copyright (c) 1987 Xerox Corporation
	X   *
	X   * David C. Martin 
	X   * ARPA: dcmartin@ingres.Berkeley.EDU
	X***************
	X*** 10,15 ****
	X--- 11,33 ----
	X   * UUCP: ..!ucbvax!dcmartin
	X   *
	X   * $Log:	text.c,v $
	X+  * Revision 10.8  87/05/17  12:51:30  mayer
	X+  * Added copyright notice.
	X+  * 
	X+  * Revision 10.7  87/05/11  15:10:00  mayer
	X+  * Special cased some more text handling to work well with the menu package.
	X+  * 
	X+  * Revision 10.6  87/05/02  14:22:55  mayer
	X+  * (1) Changed mask handling.
	X+  * (2) The FBMap stuff should only be used on monocrome displays.
	X+  * (3) Changed "mem_batchrop" to "Xmem_batchrop".
	X+  * (4) Changed "cg2_batchrop" to "Xcg2_batchrop"
	X+  * (5) Added "Xcg4_batchrop" and support routines.  This version
	X+  *     is written entierly within the pixrect specs, so should work
	X+  *     on ANY sun color display.  For general operations it can be
	X+  *     quite slow, however the special case used by "xterm" (replace
	X+  *     mode, fixed width fonts) is handled moderately efficiently.
	X+  * 
	X   * Revision 10.5  86/11/29  13:48:49  jg
	X   * fixes from Berkeley
	X   * 
	X***************
	X*** 27,33 ****
	X   */
	X  
	X  #ifndef lint
	X! static char rcs_id[] = "$Header: text.c,v 10.5 86/11/29 13:48:49 jg Rel $";
	X  #endif lint
	X  
	X  #include <X/mit-copyright.h>
	X--- 45,51 ----
	X   */
	X  
	X  #ifndef lint
	X! static char rcs_id[] = "$Header: text.c,v 10.8 87/05/17 12:51:30 mayer Exp $";
	X  #endif lint
	X  
	X  #include <X/mit-copyright.h>
	X***************
	X*** 75,80 ****
	X--- 93,99 ----
	X  #endif
	X  #include <pixrect/memreg.h>
	X  #include <pixrect/cg2reg.h>
	X+ #include <pixrect/cg4var.h>
	X  
	X  /* I've put in some rather ugly hacks, in the name of performance.  The
	X     global variables private_* are really extra parameters to the batchrop
	X***************
	X*** 111,125 ****
	X  	int			lheight;
	X  	int			sbot, sright;
	X  	static struct pr_prpos	bat[MAXCHARS];
	X  
	X! 	private_czmask = zmask;
	X  	private_fgcolor = fore;
	X  	private_bgcolor = back;
	X! 	if (fore & 1)
	X! 		func += 0x20;
	X! 	if (back & 1)
	X! 		func += 0x10;
	X! 	func = FBMap[func];
	X  	op = SUN_FROM_X_OP(func) | PIX_COLOR(fore);
	X  	/* this is a gross abuse of C, but ... */
	X  	{
	X--- 130,152 ----
	X  	int			lheight;
	X  	int			sbot, sright;
	X  	static struct pr_prpos	bat[MAXCHARS];
	X+ 	int old_mask;
	X  
	X! 	GetZmask(PixRect, &old_mask);
	X! 	SetZmask(PixRect, &zmask);
	X! 
	X  	private_fgcolor = fore;
	X  	private_bgcolor = back;
	X! 
	X! 	if (PixRect->pr_depth == 1)
	X! 	{
	X! 		if (fore & 1)
	X! 			func += 0x20;
	X! 		if (back & 1)
	X! 			func += 0x10;
	X! 		func = FBMap[func];
	X! 	}
	X! 
	X  	op = SUN_FROM_X_OP(func) | PIX_COLOR(fore);
	X  	/* this is a gross abuse of C, but ... */
	X  	{
	X***************
	X*** 216,226 ****
	X--- 243,257 ----
	X  			pr_destroy(region);
	X  		}
	X  	} while (--clipcount > 0);
	X+ 
	X+ 	SetZmask(PixRect, &old_mask);
	X+ 
	X  	/* redisplay the cursor if we zapped it */
	X  	if (!CursorDisplayed)
	X  		DisplayCursor(CurrentCursor);
	X  } /* end PrintText() */
	X  
	X+ 
	X  extern int
	X  PrintTextMask(text, textlen, font, srcpix, charpad, spacepad, dstx, dsty,
	X  	clips, clipcount, func, zmask)
	X***************
	X*** 241,247 ****
	X--- 272,280 ----
	X  	register int		w = 0;
	X  	static struct pr_prpos	bat[MAXCHARS];
	X  	int			bsize = 0, lheight, sbot, sright;
	X+ 	int			old_zmask;
	X  
	X+ 	GetZmask(PixRect, &old_zmask);
	X  	SetZmask(PixRect, &zmask);
	X  	private_bgcolor = -1;
	X  	private_fgcolor = srcpix;
	X***************
	X*** 347,361 ****
	X  			pr_destroy(region);
	X  		}
	X  	} while (--clipcount > 0);
	X  	/* restore cursor if we zapped it */
	X  	if (!CursorDisplayed)
	X  		DisplayCursor(CurrentCursor);
	X- 	/* another gross abuse of C... */
	X- 	{
	X- 		static		allmask = -1;
	X  
	X! 		SetZmask(PixRect, &allmask);
	X! 	}
	X  } /* end PrintTextMask() */
	X  
	X  
	X--- 380,391 ----
	X  			pr_destroy(region);
	X  		}
	X  	} while (--clipcount > 0);
	X+ 
	X  	/* restore cursor if we zapped it */
	X  	if (!CursorDisplayed)
	X  		DisplayCursor(CurrentCursor);
	X  
	X! 	SetZmask(PixRect, &old_zmask);
	X  } /* end PrintTextMask() */
	X  
	X  
	X***************
	X*** 367,373 ****
	X   * Memory batchrop
	X   */
	X  
	X- 
	X  extern char pr_reversedst[];
	X  extern struct pixrectops mem_ops;
	X  
	X--- 397,402 ----
	X***************
	X*** 436,442 ****
	X      if(clip) MEMBATCH(MTRUE,mask,op,revmask) \
	X      else MEMBATCH(MFALSE,mask,op,revmask)
	X  
	X! mem_batchrop(dst, op, src, count)
	X      struct pr_prpos dst;
	X      int         op;
	X      struct pr_prpos *src;
	X--- 465,471 ----
	X      if(clip) MEMBATCH(MTRUE,mask,op,revmask) \
	X      else MEMBATCH(MFALSE,mask,op,revmask)
	X  
	X! Xmem_batchrop(dst, op, src, count)
	X      struct pr_prpos dst;
	X      int         op;
	X      struct pr_prpos *src;
	X***************
	X*** 536,542 ****
	X  
	X  #define resolution unused, 0
	X  
	X! cg2_batchrop(dst, op, src, count)
	X      struct pr_prpos dst;
	X      int         op;
	X      struct pr_prpos *src;
	X--- 565,571 ----
	X  
	X  #define resolution unused, 0
	X  
	X! Xcg2_batchrop(dst, op, src, count)
	X      struct pr_prpos dst;
	X      int         op;
	X      struct pr_prpos *src;
	X***************
	X*** 722,726 ****
	X--- 751,1007 ----
	X  
	X      return (errors);
	X  }
	X+ 
	X+ /*
	X+  * Fudged up version for the CG4 display
	X+  */
	X+ 
	X+ int (*original_batchrop)();
	X+ 
	X+ Xcg4_batchrop(dst, op, src, count)
	X+ 	struct pr_prpos dst;
	X+ 	int op;
	X+ 	struct pr_prpos *src;
	X+ 	int count;
	X+ {
	X+ 	extern int private_bgcolor, private_fgcolor, private_czmask;
	X+ 	static struct pixrect *scratch;
	X+ 	int dx, dy, dw, dh;
	X+ 	int n;
	X+ 	int errors = 0;
	X+ 
	X+ 	op = (op & 0x1f) | PIX_COLOR(private_fgcolor);
	X+ 
	X+ 	if (dst.pr->pr_depth == 1
	X+ 		|| src->pr->pr_depth == dst.pr->pr_depth
	X+ 		|| private_bgcolor == 0
	X+ 		)
	X+ 	{
	X+ 		errors = (*original_batchrop)(dst, op, src, count);
	X+ 	}
	X+ 	else if (private_bgcolor < 0)
	X+ 	{
	X+ 		errors = Xcg4_batchstencil(
	X+ 				dst, op, src, count
	X+ 				);
	X+ 	}
	X+ 	else if ((op & 0x1e) == PIX_SRC)
	X+ 	{
	X+ 		errors = Xcg4_srcbatchrop(
	X+ 				dst, op, private_bgcolor,
	X+ 				src, count
	X+ 				);
	X+ 	}
	X+ 	else
	X+ 	{
	X+ 		errors = Xcg4_complexbatchrop(
	X+ 				dst, op, private_bgcolor,
	X+ 				src, count
	X+ 				);
	X+ 	}
	X+ 
	X+ 	return errors;
	X+ }
	X+ 
	X+ 
	X+ int
	X+ Xcg4_batchstencil(dst, op, source, count)
	X+ 	struct pr_prpos dst;
	X+ 	int op;
	X+ 	struct pr_prpos *source;
	X+ 	int count;
	X+ {
	X+ 	register struct pr_prpos *src;
	X+ 	int dx, dy;
	X+ 	int n;
	X+ 	int errors = 0;
	X+ 	int clipping = (op & PIX_DONTCLIP);
	X+ 	int color = PIX_COLOR(PIX_OPCOLOR(op));
	X+ 	int oper = op & 0x1e;
	X+ 
	X+ 	/*
	X+ 	 *	There are a number of special cases that can be done
	X+ 	 *	efficiently.
	X+ 	 */
	X+ 	switch (oper)
	X+ 	{
	X+ 	case PIX_CLR:
	X+ 		return (*original_batchrop)(dst,
	X+ 			(PIX_NOT(PIX_SRC)&PIX_DST)|clipping, source, count
	X+ 			);
	X+ 	case PIX_SRC^PIX_DST:
	X+ 	case PIX_SRC|PIX_DST:
	X+ 		return (*original_batchrop)(dst,
	X+ 			op, source, count
	X+ 			);
	X+ 	case PIX_DST:
	X+ 		return 0;
	X+ 	case PIX_SRC:
	X+ 		errors |= (*original_batchrop)(dst,
	X+ 				(PIX_NOT(PIX_SRC)&PIX_DST)|clipping,
	X+ 				source, count
	X+ 				);
	X+ 		errors |= (*original_batchrop)(dst,
	X+ 				(PIX_SRC|PIX_DST)|color|clipping,
	X+ 				source, count
	X+ 				);
	X+ 		return errors;
	X+ 	case PIX_SET:
	X+ 		return (*original_batchrop)(dst,
	X+ 			(PIX_SRC|PIX_DST)|clipping, source, count
	X+ 			);
	X+ 	}
	X+ 
	X+ 	dx = dst.pos.x;
	X+ 	dy = dst.pos.y;
	X+ 
	X+ 	for (n = 0; n < count; n++)
	X+ 	{
	X+ 		src = &source[n];
	X+ 
	X+ 		dx += src->pos.x;
	X+ 		dy += src->pos.y;
	X+ 
	X+ 		errors |= pr_stencil(dst.pr, dx, dy,
	X+ 				src->pr->pr_size.x, src->pr->pr_size.y,
	X+ 				op, src->pr, 0, 0,
	X+ 				(struct pixrect *)NULL, 0, 0
	X+ 				);
	X+ 	}
	X+ 
	X+ 	return errors;
	X+ }
	X+ 
	X+ int
	X+ Xcg4_srcbatchrop(dst, op, bgcolor, source, count)
	X+ 	struct pr_prpos dst;
	X+ 	int op;
	X+ 	int bgcolor;
	X+ 	struct pr_prpos *source;
	X+ 	int count;
	X+ {
	X+ 	register struct pr_prpos *p;
	X+ 	int fgcolor = PIX_OPCOLOR(op);
	X+ 	int clip = op & PIX_DONTCLIP;
	X+ 	int errors;
	X+ 	int n, dx, dy, sx, sy, height, width, last_width;
	X+ 
	X+ 	if (count == 0)
	X+ 		return 0;
	X+ 
	X+ 	errors = 0;
	X+ 
	X+ 	p = source;
	X+ 	n = count;
	X+ 
	X+ 	sx = dx = dst.pos.x + p->pos.x;
	X+ 	sy = dy = dst.pos.y+ p->pos.y;
	X+ 
	X+ 	last_width = width = p->pr->pr_size.x;
	X+ 	height = p->pr->pr_size.y;
	X+ 
	X+ 	while (--n > 0)
	X+ 	{
	X+ 		p += 1;
	X+ 
	X+ 		dx += p->pos.x;
	X+ 		dy += p->pos.y;
	X+ 
	X+ 		if (p->pos.x == last_width && p->pos.y == 0
	X+ 			&& p->pr->pr_size.y == height
	X+ 			) {
	X+ 			last_width = p->pr->pr_size.x;
	X+ 			width += last_width;
	X+ 			continue;
	X+ 			}
	X+ 
	X+ 		errors |= pr_rop(dst.pr, sx, sy, width, height,
	X+ 				(PIX_SRC)|PIX_COLOR(bgcolor)|clip,
	X+ 				(struct pixrect *)NULL, 0, 0
	X+ 				);
	X+ 		sx = dx;
	X+ 		sy = dy;
	X+ 		width = last_width = p->pr->pr_size.x;
	X+ 		height = p->pr->pr_size.y;
	X+ 	}
	X+ 
	X+ 	errors |= pr_rop(dst.pr, sx, sy, width, height,
	X+ 			(PIX_SRC)|PIX_COLOR(bgcolor)|clip,
	X+ 			(struct pixrect *)NULL, 0, 0
	X+ 			);
	X+ 
	X+ 	errors |= (*original_batchrop)(dst,
	X+ 			(PIX_SRC^PIX_DST)
	X+ 				|PIX_COLOR(bgcolor^fgcolor)|clip,
	X+ 			source, count
	X+ 			);
	X+ 
	X+ 	return errors;
	X+ }
	X+ 
	X+ int
	X+ Xcg4_complexbatchrop(dst, op, bgcolor, source, count)
	X+ 	struct pr_prpos dst;
	X+ 	int op;
	X+ 	int bgcolor;
	X+ 	struct pr_prpos *source;
	X+ 	int count;
	X+ {
	X+ 	static struct pixrect *scratch;
	X+ 	register struct pr_prpos *src;
	X+ 	register int dx, dy, dw, dh;
	X+ 	int n;
	X+ 	int errors = 0;
	X+ 	int fgcolor = PIX_OPCOLOR(op);
	X+ 
	X+ 	op = op & 0x1f;
	X+ 
	X+ 	dx = dst.pos.x;
	X+ 	dy = dst.pos.y;
	X+ 
	X+ 	for (n = 0; n < count; n += 1)
	X+ 	{
	X+ 		src = &source[n];
	X+ 
	X+ 		dx += src->pos.x;
	X+ 		dy += src->pos.y;
	X+ 
	X+ 		if (scratch == NULL
	X+ 			|| scratch->pr_size.x < src->pr->pr_size.x
	X+ 			|| scratch->pr_size.y < src->pr->pr_size.y
	X+ 			)
	X+ 		{
	X+ 			if (scratch) pr_destroy(scratch);
	X+ 			scratch = mem_create(
	X+ 				src->pr->pr_size.x+100,
	X+ 				src->pr->pr_size.y+100,
	X+ 				8
	X+ 				);
	X+ 			if (scratch == NULL)
	X+ 				Error("Cannot allocate memory for pixrect");
	X+ 		}
	X+ 
	X+ 		errors |= pr_rop(scratch, 0, 0,
	X+ 				src->pr->pr_size.x, src->pr->pr_size.y,
	X+ 				PIX_SRC|PIX_COLOR(bgcolor)|PIX_DONTCLIP,
	X+ 				(struct pixrect *)NULL, 0, 0
	X+ 				);
	X+ 
	X+ 		errors |= pr_rop(scratch, 0, 0,
	X+ 				src->pr->pr_size.x, src->pr->pr_size.y,
	X+ 				(PIX_SRC^PIX_DST) | PIX_DONTCLIP
	X+ 					| PIX_COLOR(bgcolor^fgcolor),
	X+ 				src->pr, 0, 0
	X+ 				);
	X+ 
	X+ 		errors |= pr_rop(dst.pr, dx, dy,
	X+ 				src->pr->pr_size.x, src->pr->pr_size.y,
	X+ 				op, scratch, 0, 0
	X+ 				);
	X+ 	}
	X+ 
	X+ 	return errors;
	X+ }
	X+ 	
	X  
	X  #endif	sun
SHAR_EOF
if test 10412 -ne "`wc -c < 'text.c.patch'`"
then
	echo shar: error transmitting "'text.c.patch'" '(should have been 10412 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'tile.c.patch'" '(5029 characters)'
if test -f 'tile.c.patch'
then
	echo shar: will not over-write existing file "'tile.c.patch'"
else
sed 's/^	X//' << \SHAR_EOF > 'tile.c.patch'
	X*** /usr/src/new/X.V10R4/libsun/tile.c	Mon Dec  1 19:24:27 1986
	X--- tile.c	Mon Jun  8 14:31:05 1987
	X***************
	X*** 1,5 ****
	X  #ifndef lint
	X! static char *rcsid_tile_c = "$Header: tile.c,v 10.3 86/11/29 13:49:10 jg Rel $";
	X  #endif	lint
	X  #ifdef	sun
	X  /*
	X--- 1,5 ----
	X  #ifndef lint
	X! static char *rcsid_tile_c = "$Header: tile.c,v 10.7 87/06/01 13:15:44 mayer Exp $";
	X  #endif	lint
	X  #ifdef	sun
	X  /*
	X***************
	X*** 70,75 ****
	X--- 70,78 ----
	X      int	clipcount;
	X      int xoff, yoff;
	X  {
	X+     if (xoff < 0) xoff = Tile->pr_size.x + xoff % Tile->pr_size.x;
	X+     if (yoff < 0) yoff = Tile->pr_size.y + yoff % Tile->pr_size.y;
	X+ 
	X      if (xymask == NULL) {
	X  	/* spread tile from (dstx,dsty) by (width,height) */
	X  	do {
	X***************
	X*** 81,90 ****
	X  		int         ttop = (ctop > dsty ? ctop : dsty);
	X  		int         twidth = (cleft + cwidth < dstx + width ? cleft + cwidth : dstx + width) - tleft;
	X  		int         theight = (ctop + cheight < dsty + height ? ctop + cheight : dsty + height) - ttop;
	X! 		/* XXX - is this the right tile mode? */
	X  		CheckCursor(tleft, ttop, twidth, theight);
	X  		pr_replrop(PixRect, tleft, ttop, twidth, theight, op,
	X! 		Tile, tleft - xoff, ttop - yoff);
	X  	    }
	X  	} while (--clipcount > 0);
	X      }
	X--- 84,94 ----
	X  		int         ttop = (ctop > dsty ? ctop : dsty);
	X  		int         twidth = (cleft + cwidth < dstx + width ? cleft + cwidth : dstx + width) - tleft;
	X  		int         theight = (ctop + cheight < dsty + height ? ctop + cheight : dsty + height) - ttop;
	X! 
	X  		CheckCursor(tleft, ttop, twidth, theight);
	X  		pr_replrop(PixRect, tleft, ttop, twidth, theight, op,
	X! 			Tile, tleft + xoff, ttop + yoff
	X! 			);
	X  	    }
	X  	} while (--clipcount > 0);
	X      }
	X***************
	X*** 172,181 ****
	X  	CLIP *clips;
	X  {
	X      int         op = SUN_FROM_X_OP(func) | PIX_DONTCLIP;
	X!     int         allmask = -1;
	X  
	X      if ((PixRect->pr_depth == 1) && !(zmask & 1))
	X  	return;
	X      SetZmask(PixRect, &zmask);
	X      switch (PTYPE(tile)) {
	X      case BitmapPixmap:
	X--- 176,189 ----
	X  	CLIP *clips;
	X  {
	X      int         op = SUN_FROM_X_OP(func) | PIX_DONTCLIP;
	X!     int         old_zmask;
	X  
	X+     if (xoff < 0) xoff = tile->width + xoff % tile->width;
	X+     if (yoff < 0) yoff = tile->height + yoff % tile->height;
	X+ 
	X      if ((PixRect->pr_depth == 1) && !(zmask & 1))
	X  	return;
	X+     GetZmask(PixRect, &old_zmask);
	X      SetZmask(PixRect, &zmask);
	X      switch (PTYPE(tile)) {
	X      case BitmapPixmap:
	X***************
	X*** 206,212 ****
	X  	}
	X  	break;
	X      }
	X!     SetZmask(PixRect, &allmask);
	X      RestoreCursor();
	X  }
	X  
	X--- 214,220 ----
	X  	}
	X  	break;
	X      }
	X!     SetZmask(PixRect, &old_zmask);
	X      RestoreCursor();
	X  }
	X  
	X***************
	X*** 249,260 ****
	X  	int		op;		/* sun pr_ op */
	X  	int		width,		/* width of tilepr && pgons */
	X  			height;		/* height of same */
	X- 	int		allmask = -1;	/* all planes */
	X  	extern	u_char	Xstatus;	/* return value for server */
	X  
	X! 	if ((PixRect->pr_depth == 1) && ! (zmask & 1))
	X  		return;
	X  
	X  	vertices = (struct pr_pos *) calloc (vertcount, sizeof (struct pr_pos));
	X  	if (vertices == (struct pr_pos *) NULL) {
	X  		DeviceError ("Couldn't allocate array of vertices");
	X--- 257,271 ----
	X  	int		op;		/* sun pr_ op */
	X  	int		width,		/* width of tilepr && pgons */
	X  			height;		/* height of same */
	X  	extern	u_char	Xstatus;	/* return value for server */
	X+ 	int		old_zmask;	/* file the old mask away */
	X  
	X! 	if (vertcount == 0)
	X  		return;
	X  
	X+ 	if ((PixRect->pr_depth == 1) && ! (zmask & 1))
	X+ 		return;
	X+ 	
	X  	vertices = (struct pr_pos *) calloc (vertcount, sizeof (struct pr_pos));
	X  	if (vertices == (struct pr_pos *) NULL) {
	X  		DeviceError ("Couldn't allocate array of vertices");
	X***************
	X*** 331,338 ****
	X--- 342,360 ----
	X  
	X  	tilepr = mem_create (width, height, PixRect->pr_depth);
	X  	pgons = mem_create (width, height, PixRect->pr_depth);
	X+ 	if (tilepr == NULL || pgons == NULL)
	X+ 	{
	X+ 		if (tilepr != NULL) pr_destroy(tilepr);
	X+ 		free (vertices);
	X+ 		DeviceError ("Cannot allocate tilepr");
	X+ 		Xstatus = BadAlloc;
	X+ 		return;
	X+ 	}
	X  
	X  	if (tile != NULL) {
	X+ 		if (xoff < 0) xoff = tile->width + xoff % tile->width;
	X+ 		if (yoff < 0) yoff = tile->height + yoff % tile->height;
	X+ 
	X  		switch (tile->kind) {
	X  		case BitmapPixmap:
	X  			{
	X***************
	X*** 372,381 ****
	X  	xbase += minx;
	X  	ybase += miny;
	X  
	X! 	pr_rop (pgons, 0, 0, width, height, PIX_SRC | PIX_DONTCLIP,
	X  		PixRect, xbase, ybase);
	X  
	X! 	SetZmask (pgons, &zmask);
	X  
	X  	op = SUN_FROM_X_OP(func) | PIX_DONTCLIP;
	X  
	X--- 394,405 ----
	X  	xbase += minx;
	X  	ybase += miny;
	X  
	X! 	pr_rop (pgons, 0, 0, width, height, PIX_SRC,
	X  		PixRect, xbase, ybase);
	X  
	X! 	GetZmask(PixRect, &old_zmask);
	X! 	SetZmask(PixRect, &zmask);
	X! 	pr_putattributes(pgons, &zmask);
	X  
	X  	op = SUN_FROM_X_OP(func) | PIX_DONTCLIP;
	X  
	X***************
	X*** 419,425 ****
	X  
	X  	free (vertices);
	X  
	X! 	SetZmask (PixRect, &allmask);
	X  	RestoreCursor();
	X  }
	X  #endif	sun
	X--- 443,450 ----
	X  
	X  	free (vertices);
	X  
	X! 	SetZmask(PixRect, &old_zmask);
	X! 
	X  	RestoreCursor();
	X  }
	X  #endif	sun
SHAR_EOF
if test 5029 -ne "`wc -c < 'tile.c.patch'`"
then
	echo shar: error transmitting "'tile.c.patch'" '(should have been 5029 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'util.c.patch'" '(1302 characters)'
if test -f 'util.c.patch'
then
	echo shar: will not over-write existing file "'util.c.patch'"
else
sed 's/^	X//' << \SHAR_EOF > 'util.c.patch'
	X*** /usr/src/new/X.V10R4/libsun/util.c	Mon Dec  1 19:24:29 1986
	X--- util.c	Mon Jun  8 14:31:10 1987
	X***************
	X*** 1,5 ****
	X  #ifndef lint
	X! static char *rcsid_util_c = "$Header: util.c,v 10.4 86/11/29 13:49:21 jg Rel $";
	X  #endif	lint
	X  #ifdef	sun
	X  /*
	X--- 1,5 ----
	X  #ifndef lint
	X! static char *rcsid_util_c = "$Header: util.c,v 10.5 87/05/04 11:07:53 mayer Exp $";
	X  #endif	lint
	X  #ifdef	sun
	X  /*
	X***************
	X*** 188,193 ****
	X--- 188,195 ----
	X  
	X  {
	X      /* XXX - should keep interal shadow of color map and rewrite whole */
	X+     extern short Sun_From_X_Op[];
	X+     extern short Sun_From_X_Op_Reverse[];
	X      extern struct pixrect *PixRect;
	X      while (count--) {
	X  	u_char r, g, b;
	X***************
	X*** 195,201 ****
	X  	r = (u_char) (entries->red>>8);
	X  	g = (u_char) (entries->green>>8);
	X  	b = (u_char) (entries->blue>>8);
	X! 	pr_putcolormap(PixRect, entries->pixel, 1, &r, &g, &b);
	X  	entries++;
	X      }
	X  }
	X--- 197,213 ----
	X  	r = (u_char) (entries->red>>8);
	X  	g = (u_char) (entries->green>>8);
	X  	b = (u_char) (entries->blue>>8);
	X! 
	X! 	if (PixRect->pr_depth > 1)
	X! 	{
	X! 		pr_putcolormap(PixRect, entries->pixel, 1, &r, &g, &b);
	X! 	}
	X! 	else if (entries->pixel == 0)
	X! 	{
	X! 		Sun_From_X_Op_Map = (r
	X! 			? Sun_From_X_Op_Reverse : Sun_From_X_Op
	X! 			);
	X! 	}
	X  	entries++;
	X      }
	X  }
SHAR_EOF
if test 1302 -ne "`wc -c < 'util.c.patch'`"
then
	echo shar: error transmitting "'util.c.patch'" '(should have been 1302 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'initial.c.patch'" '(14093 characters)'
if test -f 'initial.c.patch'
then
	echo shar: will not over-write existing file "'initial.c.patch'"
else
sed 's/^	X//' << \SHAR_EOF > 'initial.c.patch'
	X*** /usr/src/new/X.V10R4/libsun/initial.c	Wed Dec 17 20:34:46 1986
	X--- initial.c	Mon Jun  8 14:30:37 1987
	X***************
	X*** 1,5 ****
	X  #ifndef lint
	X! static char *rcsid = "$Header: initial.c,v 10.6 86/12/17 20:34:22 swick Exp $";
	X  #endif lint
	X  #ifdef	sun
	X  /*
	X--- 1,5 ----
	X  #ifndef lint
	X! static char *rcsid = "$Header: initial.c,v 10.10 87/05/17 12:52:41 mayer Exp $";
	X  #endif lint
	X  #ifdef	sun
	X  /*
	X***************
	X*** 39,52 ****
	X  /*-
	X   * Copyright 1985, Massachusetts Institute of Technology
	X   * Copyright (c) 1986 by Sun Microsystems,  Inc.
	X   */
	X  
	X! /* initial.c	Routines to open & close display
	X   *
	X   *	OpenDisplay		Open it
	X   *	InitDisplay		Download it
	X   *	DisplayDead		Check if dead
	X   *	Allocate_space		Allocate some temporary storage
	X   *
	X   */
	X  
	X--- 39,55 ----
	X  /*-
	X   * Copyright 1985, Massachusetts Institute of Technology
	X   * Copyright (c) 1986 by Sun Microsystems,  Inc.
	X+  * Copyright (c) 1987 Xerox Corporation
	X   */
	X  
	X! /* initial.c	Routines to open & close display and other window dependent
	X!  *		stuff.
	X   *
	X   *	OpenDisplay		Open it
	X   *	InitDisplay		Download it
	X   *	DisplayDead		Check if dead
	X   *	Allocate_space		Allocate some temporary storage
	X+  *	Set_mouse_params	Change the mouse tracking parameters.
	X   *
	X   */
	X  
	X***************
	X*** 65,70 ****
	X--- 68,74 ----
	X  #include <sun/fbio.h>
	X  #include "Xsun.h"
	X  #include <pixrect/pixrect_hs.h>
	X+ #include <pixrect/cg4var.h>
	X  #include <sunwindow/rect.h>
	X  #include <sunwindow/rectlist.h>
	X  #include <sunwindow/pixwin.h>
	X***************
	X*** 71,104 ****
	X  #include <sunwindow/win_screen.h>
	X  #include <sunwindow/win_struct.h>
	X  #include <sunwindow/win_input.h>
	X  #include <sundev/kbd.h>
	X  #include <sundev/kbio.h>
	X  
	X  extern int InputReader();
	X  
	X  struct pixwin *Display;
	X  struct pixrect *PixRect;
	X  u_char InvPix[256];
	X  
	X  short Sun_From_X_Op[] = {
	X!     	PIX_CLR,			/* GXclear */
	X! 	PIX_SRC&PIX_DST,		/* GXand */
	X! 	PIX_SRC&PIX_NOT(PIX_DST),	/* GXandReverse */
	X! 	PIX_SRC,			/* GXcopy */
	X! 	PIX_NOT(PIX_SRC)&PIX_DST,	/* GXandInverted */
	X! 	PIX_DST,			/* GXnoop */
	X! 	PIX_SRC^PIX_DST,		/* GXxor */
	X! 	PIX_SRC|PIX_DST,		/* GXor */
	X! 	PIX_NOT(PIX_SRC)&PIX_NOT(PIX_DST), /* GXnor */
	X! 	PIX_NOT(PIX_SRC)^PIX_DST,	/* GXequiv */
	X! 	PIX_NOT(PIX_DST),		/* GXinvert */
	X! 	PIX_SRC|PIX_NOT(PIX_DST),	/* GXorReverse */
	X! 	PIX_NOT(PIX_SRC),		/* GXcopyInverted */
	X  	PIX_NOT(PIX_SRC)|PIX_DST,		/* GXorInverted */
	X! 	PIX_NOT(PIX_SRC)|PIX_NOT(PIX_DST), /* GXnand */
	X! 	PIX_SET,			/* GXset */
	X  };
	X  
	X  int vsdev = -1;
	X  extern int errno;
	X  DEVICE *CurrentDevice;
	X--- 75,138 ----
	X  #include <sunwindow/win_screen.h>
	X  #include <sunwindow/win_struct.h>
	X  #include <sunwindow/win_input.h>
	X+ #include <sunwindow/cms.h>
	X+ #include <sunwindow/win_ioctl.h>
	X  #include <sundev/kbd.h>
	X  #include <sundev/kbio.h>
	X  
	X  extern int InputReader();
	X+ extern char *index();
	X  
	X  struct pixwin *Display;
	X  struct pixrect *PixRect;
	X+ int DisplayHasROP;			/* is there a raster op chip ? */
	X+ 
	X+ extern char *private_flags;		/* set to vector of private options */
	X+ 					/*	'o' -- use overlay plane */
	X+ 					/*	's' -- use raster chip */
	X+ 
	X  u_char InvPix[256];
	X  
	X  short Sun_From_X_Op[] = {
	X!     	PIX_CLR,				/* GXclear */
	X! 	PIX_SRC&PIX_DST,			/* GXand */
	X! 	PIX_SRC&PIX_NOT(PIX_DST),		/* GXandReverse */
	X! 	PIX_SRC,				/* GXcopy */
	X! 	PIX_NOT(PIX_SRC)&PIX_DST,		/* GXandInverted */
	X! 	PIX_DST,				/* GXnoop */
	X! 	PIX_SRC^PIX_DST,			/* GXxor */
	X! 	PIX_SRC|PIX_DST,			/* GXor */
	X! 	PIX_NOT(PIX_SRC)&PIX_NOT(PIX_DST), 	/* GXnor */
	X! 	PIX_NOT(PIX_SRC)^PIX_DST,		/* GXequiv */
	X! 	PIX_NOT(PIX_DST),			/* GXinvert */
	X! 	PIX_SRC|PIX_NOT(PIX_DST),		/* GXorReverse */
	X! 	PIX_NOT(PIX_SRC),			/* GXcopyInverted */
	X  	PIX_NOT(PIX_SRC)|PIX_DST,		/* GXorInverted */
	X! 	PIX_NOT(PIX_SRC)|PIX_NOT(PIX_DST),	/* GXnand */
	X! 	PIX_SET,				/* GXset */
	X  };
	X  
	X+ short Sun_From_X_Op_Reverse[] = {
	X+     	PIX_SET,					/* GXclear */
	X+ 	PIX_NOT(PIX_SRC&PIX_NOT(PIX_DST)),		/* GXand */
	X+ 	PIX_NOT(PIX_SRC&PIX_DST),			/* GXandReverse */
	X+ 	PIX_NOT(PIX_SRC),				/* GXcopy */
	X+ 	PIX_NOT(PIX_NOT(PIX_SRC)&PIX_NOT(PIX_DST)),	/* GXandInverted */
	X+ 	PIX_DST,					/* GXnoop */
	X+ 	PIX_NOT(PIX_SRC^PIX_NOT(PIX_DST)),		/* GXxor */
	X+ 	PIX_NOT(PIX_SRC|PIX_NOT(PIX_DST)),		/* GXor */
	X+ 	PIX_NOT(PIX_NOT(PIX_SRC)&PIX_DST),		/* GXnor */
	X+ 	PIX_NOT(PIX_NOT(PIX_SRC)^PIX_NOT(PIX_DST)),	/* GXequiv */
	X+ 	PIX_NOT(PIX_DST),				/* GXinvert */
	X+ 	PIX_NOT(PIX_SRC|PIX_DST),			/* GXorReverse */
	X+ 	PIX_SRC,					/* GXcopyInverted */
	X+ 	PIX_NOT(PIX_NOT(PIX_SRC)|PIX_NOT(PIX_DST)),	/* GXorInverted */
	X+ 	PIX_NOT(PIX_NOT(PIX_SRC)|PIX_DST), 		/* GXnand */
	X+ 	PIX_CLR,					/* GXset */
	X+ };
	X+ 
	X+ short *Sun_From_X_Op_Map = Sun_From_X_Op;
	X+ 
	X  int vsdev = -1;
	X  extern int errno;
	X  DEVICE *CurrentDevice;
	X***************
	X*** 109,114 ****
	X--- 143,149 ----
	X  
	X  #ifdef	RAW_KBD
	X  struct kiockey	sunkeymap[128*5];
	X+ int keyboardMapped = 0;
	X  #endif
	X  
	X  /*ARGSUSED*/
	X***************
	X*** 115,129 ****
	X  OpenDisplay (devname)
	X  	char *devname;
	X  {
	X-     struct screen sc;
	X      extern char *getenv();
	X  
	X      signal (SIGWINCH, SIG_IGN);
	X      parent = getenv(PARENT);
	X-     bzero((caddr_t) & sc, sizeof sc);
	X      if (*devname != '/')
	X  	devname = "/dev/fb";
	X-     strncpy(sc.scr_fbname, devname, SCR_NAMESIZE);
	X      if (parent) {
	X  	/* Running under "overview" */
	X  	int         pfd;
	X--- 150,162 ----
	X  OpenDisplay (devname)
	X  	char *devname;
	X  {
	X      extern char *getenv();
	X+     struct screen sc;
	X  
	X      signal (SIGWINCH, SIG_IGN);
	X      parent = getenv(PARENT);
	X      if (*devname != '/')
	X  	devname = "/dev/fb";
	X      if (parent) {
	X  	/* Running under "overview" */
	X  	int         pfd;
	X***************
	X*** 139,144 ****
	X--- 172,179 ----
	X      }
	X      else {
	X  	/* Running alone */
	X+ 	bzero((caddr_t) & sc, sizeof sc);
	X+ 	strncpy(sc.scr_fbname, devname, SCR_NAMESIZE);
	X  	vsdev = win_screennew(&sc);
	X      }
	X      return (vsdev);
	X***************
	X*** 166,172 ****
	X  
	X      while ((dead = wait3(&status, WNOHANG, NULL)) > 0) {
	X  	if (dead == pid) {
	X! 	    exit(0);
	X  	}
	X      }
	X  }
	X--- 201,207 ----
	X  
	X      while ((dead = wait3(&status, WNOHANG, NULL)) > 0) {
	X  	if (dead == pid) {
	X! 	    ServerExit(0);
	X  	}
	X      }
	X  }
	X***************
	X*** 227,260 ****
	X  			       0,
	X      };
	X      struct screen sc;
	X  
	X      win_screenget(vsdev, &sc);
	X!     info->height = sc.scr_rect.r_height;
	X!     info->width = sc.scr_rect.r_width;
	X      if (parent) {
	X  	/* running under "overview" */
	X  	win_setrect(vsdev, &sc.scr_rect);
	X      }
	X      {
	X! 	struct fbtype fbt;
	X! 	int         fd = open(sc.scr_fbname, O_RDWR, 0);
	X  
	X! 	if (fd < 0 || ioctl(fd, FBIOGTYPE, &fbt) < 0) {
	X! 	    if (fd < 0)
	X! 		fprintf(stderr, "Can't open fb %s\n", sc.scr_fbname);
	X! 	    else
	X! 	        fprintf(stderr, "Can't FBIOGTYPE on %s\n", sc.scr_fbname);
	X! 	    return (-1);
	X! 	}
	X! 	close(fd);
	X! 	info->id = fbt.fb_type + SUN_BASE;
	X! 	info->planes = fbt.fb_depth;
	X! 	info->entries = fbt.fb_cmsize;
	X      }
	X      Display = pw_open(vsdev);
	X      PixRect = Display->pw_pixrect;
	X!     pw_reversevideo(Display,0,1);
	X      {
	X  	struct inputmask im;
	X  	struct kiockey kk;
	X  	int	kbfd, i = 0;
	X--- 262,360 ----
	X  			       0,
	X      };
	X      struct screen sc;
	X+     struct fbtype fbtype;
	X+     struct fbgattr attributes;
	X+     int fd;
	X  
	X      win_screenget(vsdev, &sc);
	X! 
	X      if (parent) {
	X  	/* running under "overview" */
	X  	win_setrect(vsdev, &sc.scr_rect);
	X      }
	X+ 
	X+     fd = open(sc.scr_fbname, O_RDWR, 0);
	X+     if (fd < 0)
	X      {
	X! 	    fprintf(stderr, "Can't open fb %s\n", sc.scr_fbname);
	X! 	    return -1;
	X!     }
	X  
	X!     if (ioctl(fd, FBIOGATTR, &attributes) >= 0)
	X!     /*
	X!      *	This device supports emulation types.  Find out what the real
	X!      *  device type is.  There is no need to change the emulation type,
	X!      *	since the PixRect will have the correct depth anyway.
	X!      */
	X!     {
	X! 	fbtype = attributes.fbtype;
	X      }
	X+     else if (ioctl(fd, FBIOGTYPE, &fbtype) < 0)
	X+     {
	X+ 	    fprintf(stderr, "Can't FBIOGTYPE on %s\n", sc.scr_fbname);
	X+ 	    return -1;
	X+     }
	X+ 
	X+     close(fd);
	X+ 
	X      Display = pw_open(vsdev);
	X      PixRect = Display->pw_pixrect;
	X! 
	X!     (void) SetUpPlaneGroups();
	X! 
	X!     info->height = PixRect->pr_size.y;
	X!     info->width = PixRect->pr_size.x;
	X!     info->id = fbtype.fb_type + SUN_BASE;
	X!     info->planes = PixRect->pr_depth;
	X!     info->entries = 1<<PixRect->pr_depth;
	X! 
	X!     DisplayHasROP = info->id == XDEV_SUN2COLOR
	X! 			|| info->id == XDEV_SUN2GP
	X! 			;
	X! 
	X!     if (PixRect->pr_depth == 1)
	X      {
	X+ 	Sun_From_X_Op_Map = Sun_From_X_Op_Reverse;
	X+     }
	X+     else if (DisplayHasROP && index(private_flags, 's') != NULL)
	X+     /*
	X+      *  All of these buffers use the same raster op chip.  The Xcg2_batchrop
	X+      *  routine makes use of it, so is probably the way to go.  Supposedly,
	X+      *  the "special" mem_batchrop routine is no longer necessary for
	X+      *  good speed, so don't bother changing it.
	X+      *  
	X+      */
	X+     {
	X+ 	extern int Xcg2_batchrop();
	X+ 
	X+         PixRect->pr_ops->pro_batchrop = Xcg2_batchrop;
	X+     }
	X+     else
	X+     /*
	X+      *	The Xcg4 special batchrop routine doesn't use anything outside of
	X+      *  the pixrect library, so it makes a good catchall.
	X+      */
	X+     {
	X+         extern int Xcg4_batchrop();
	X+ 	extern int (*original_batchrop)();
	X+ 
	X+ 	original_batchrop = PixRect->pr_ops->pro_batchrop;
	X+         PixRect->pr_ops->pro_batchrop = Xcg4_batchrop;
	X+ 
	X+ 	if (fbtype.fb_type == FBTYPE_SUN4COLOR)			/* dirty pool */
	X+ 	{
	X+ 		cg4_d(PixRect)->flags |= CG4_OVERLAY_CMAP;
	X+ 	}
	X+     }
	X+ 
	X+     {
	X+ 	extern int private_czmask; /* initialize the bitplane mask */
	X+ 
	X+ 	private_czmask = 0xffff;
	X+ 	pr_putattributes(PixRect, &private_czmask);
	X+     }
	X+ 
	X+     {
	X  	struct inputmask im;
	X  	struct kiockey kk;
	X  	int	kbfd, i = 0;
	X***************
	X*** 263,268 ****
	X--- 363,370 ----
	X  #ifdef	RAW_KBD
	X  		struct kiockey ok;
	X  
	X+ 		keyboardMapped = 1;
	X+ 
	X  		for (i = 0; i < 0200; ++i) {
	X  			ok.kio_station =
	X  			kk.kio_station = kk.kio_entry = i;
	X***************
	X*** 404,424 ****
	X      return (0);
	X  }
	X  
	X  /* Check if display is dead */
	X  
	X  DisplayDead ()
	X  {
	X  #ifdef	RAW_KBD
	X! 	int i;
	X! 	int kbfd = open("/dev/kbd", O_RDWR, 0);
	X! 	for (i = 0; i < 0200; ++i) {
	X! 		ioctl(kbfd, KIOCSETKEY, &sunkeymap[i]);
	X! 		if ((sunkeymap[i].kio_entry & 0xf0) == SHIFTKEYS)
	X! 			ioctl(kbfd, KIOCSETKEY, &sunkeymap[i+01000]);
	X! 		else if (sunkeymap[i].kio_entry == BUCKYBITS+METABIT)
	X! 			ioctl(kbfd, KIOCSETKEY, &sunkeymap[i+01000]);
	X  	}
	X- 	close(kbfd);
	X  #endif
	X  	return(0);
	X  }
	X--- 506,637 ----
	X      return (0);
	X  }
	X  
	X+ /* Handle the plane group stuff */
	X+ SetUpPlaneGroups()
	X+ {
	X+ 	char plane_groups[PIX_MAX_PLANE_GROUPS];
	X+ 	int selected;
	X+ 	int ngroups;
	X+ 	int n;
	X+ 	int op;
	X+ 	int overlay_selected = (index(private_flags, 'o') != NULL);
	X+ 
	X+ 	ngroups = pr_available_plane_groups(
	X+ 			PixRect, PIX_MAX_PLANE_GROUPS, plane_groups
	X+ 			);
	X+ 
	X+ 	if (ngroups <= 0) return -1;
	X+ 
	X+ 	if (plane_groups[PIXPG_OVERLAY] == 0)
	X+ 		return 0;
	X+ 
	X+ 	if (overlay_selected)
	X+ 		selected = PIXPG_OVERLAY;
	X+ 	else if (plane_groups[PIXPG_8BIT_COLOR])
	X+ 		selected = PIXPG_8BIT_COLOR;
	X+ 	else if (plane_groups[PIXPG_MONO])
	X+ 		selected = PIXPG_MONO;
	X+ 	else if (plane_groups[PIXPG_OVERLAY])
	X+ 		selected = PIXPG_OVERLAY;
	X+ 	
	X+ 	for (n = 0; n < ngroups; n++)		/* disable everything */
	X+ 	{
	X+ 		if (! plane_groups[n]) continue;
	X+ 		pr_set_planes(PixRect, n, 0);
	X+ 	}
	X+ 
	X+ 	if (plane_groups[PIXPG_OVERLAY_ENABLE])
	X+ 	{
	X+ 		op = (selected == PIXPG_OVERLAY? PIX_SET : PIX_CLR);
	X+ 
	X+ 		pr_set_planes(PixRect, PIXPG_OVERLAY_ENABLE, PIX_ALL_PLANES);
	X+ 
	X+ 		pr_rop(PixRect, 0, 0,
	X+ 			PixRect->pr_size.x, PixRect->pr_size.y,
	X+ 			op, (struct pixrect *)NULL, 0, 0
	X+ 			);
	X+ 
	X+ 		pr_set_planes(PixRect, PIXPG_OVERLAY, 0);
	X+ 	}
	X+ 
	X+ 	pr_set_planes(PixRect, selected, PIX_ALL_PLANES);
	X+ }
	X+ 
	X+ 
	X+ /*
	X+  *	Set the mouse characteristics.  This is a little different than
	X+  *	usual, in that multiple calls to this routine are in addition
	X+  *	to, rather than in place of, the previous values.  To reset
	X+  *	the parameters, send in a threshold of zero.
	X+  */
	X+ Set_mouse_params(threshold, acceleration)
	X+ 	int threshold, acceleration;
	X+ {
	X+ 	Ws_scale_list s;
	X+ 	int n;
	X+ 
	X+ 	if (threshold < 0) threshold = 0;
	X+ 
	X+ 	if (threshold >= WS_SCALE_MAX_CEILING)
	X+ 		threshold = WS_SCALE_MAX_CEILING - 1;
	X+ 	
	X+ 	if (acceleration <= 0)
	X+ 		acceleration = 0;
	X+ 
	X+ 	if (ioctl(vsdev, WINGETSCALING, &s) < 0)
	X+ 	{
	X+ 		perror("SetMouseCharacteristics: WINGET");
	X+ 		return -1;
	X+ 	}
	X+ 
	X+ 	for (n = 0; n < WS_SCALE_MAX_COUNT-2; n++)
	X+ 	{
	X+ 		if (s.scales[n].ceiling >= threshold) break;
	X+ 		if (s.scales[n+1].factor >= acceleration) break;
	X+ 	}
	X+ 
	X+ 	if (threshold == 0)
	X+ 		n = -1;
	X+ 	else
	X+ 		s.scales[n].ceiling = threshold;
	X+ 
	X+ 	s.scales[n+1].ceiling = WS_SCALE_MAX_CEILING;
	X+ 	s.scales[n+1].factor = acceleration;
	X+ 
	X+ 	for (n = n + 2; n < WS_SCALE_MAX_COUNT; n++)
	X+ 	{
	X+ 		s.scales[n].ceiling = 0;
	X+ 		s.scales[n].factor = 0;
	X+ 	}
	X+ 
	X+ 	if (ioctl(vsdev, WINSETSCALING, &s) < 0)
	X+ 	{
	X+ 		perror("SetMouseCharacteristics: WINSETSCALING");
	X+ 		return -1;
	X+ 	}
	X+ 
	X+ 	return 0;
	X+ }
	X+ 
	X+ 
	X  /* Check if display is dead */
	X  
	X  DisplayDead ()
	X  {
	X  #ifdef	RAW_KBD
	X! 	if (keyboardMapped) {
	X! 		int i;
	X! 		int kbfd = open("/dev/kbd", O_RDWR, 0);
	X! 		for (i = 0; i < 0200; ++i) {
	X! 			ioctl(kbfd, KIOCSETKEY, &sunkeymap[i]);
	X! 			if ((sunkeymap[i].kio_entry & 0xf0) == SHIFTKEYS)
	X! 				ioctl(kbfd, KIOCSETKEY, &sunkeymap[i+01000]);
	X! 			else if (sunkeymap[i].kio_entry == BUCKYBITS+METABIT)
	X! 				ioctl(kbfd, KIOCSETKEY, &sunkeymap[i+01000]);
	X! 		}
	X! 		close(kbfd);
	X! 		keyboardMapped = 0;
	X  	}
	X  #endif
	X  	return(0);
	X  }
	X***************
	X*** 480,486 ****
	X      if ((environ = (char **) realloc(environ, sizeof(char *) *
	X  				     (index + 2))) == NULL) {
	X  	fprintf(stderr, "Setenv: malloc out of memory\n");
	X! 	exit(1);
	X      }
	X  
	X      environ[index] = (char *) malloc(strlen(var) + strlen(value));
	X--- 693,699 ----
	X      if ((environ = (char **) realloc(environ, sizeof(char *) *
	X  				     (index + 2))) == NULL) {
	X  	fprintf(stderr, "Setenv: malloc out of memory\n");
	X! 	ServerExit(1);
	X      }
	X  
	X      environ[index] = (char *) malloc(strlen(var) + strlen(value));
SHAR_EOF
if test 14093 -ne "`wc -c < 'initial.c.patch'`"
then
	echo shar: error transmitting "'initial.c.patch'" '(should have been 14093 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'put.c.patch'" '(2933 characters)'
if test -f 'put.c.patch'
then
	echo shar: will not over-write existing file "'put.c.patch'"
else
sed 's/^	X//' << \SHAR_EOF > 'put.c.patch'
	X*** /usr/src/new/X.V10R4/libsun/put.c	Mon Dec  1 19:24:20 1986
	X--- put.c	Mon Jun  8 14:30:41 1987
	X***************
	X*** 1,5 ****
	X  #ifndef lint
	X! static char *rcsid_put_c = "$Header: put.c,v 10.3 86/11/29 13:48:41 jg Rel $";
	X  #endif	lint
	X  #ifdef	sun
	X  /*
	X--- 1,5 ----
	X  #ifndef lint
	X! static char *rcsid_put_c = "$Header: put.c,v 10.6 87/05/11 15:09:28 mayer Exp $";
	X  #endif	lint
	X  #ifdef	sun
	X  /*
	X***************
	X*** 68,76 ****
	X  {
	X      struct pixrect *Src;
	X      int op = SUN_FROM_X_OP(func);
	X!     int allmask = -1;
	X  
	X      SetZmask(PixRect, &zmask);
	X      switch (PTYPE(src)) {
	X      case BitmapPixmap:
	X  	{
	X--- 68,78 ----
	X  {
	X      struct pixrect *Src;
	X      int op = SUN_FROM_X_OP(func);
	X!     int old_zmask;
	X  
	X+     GetZmask(PixRect, &old_zmask);
	X      SetZmask(PixRect, &zmask);
	X+ 
	X      switch (PTYPE(src)) {
	X      case BitmapPixmap:
	X  	{
	X***************
	X*** 142,148 ****
	X  	break;
	X      }
	X      RestoreCursor();
	X!     SetZmask(PixRect, &allmask);
	X  }
	X  
	X  
	X--- 144,150 ----
	X  	break;
	X      }
	X      RestoreCursor();
	X!     SetZmask(PixRect, &old_zmask);
	X  }
	X  
	X  
	X***************
	X*** 212,232 ****
	X  {
	X      struct pixrect *Src;
	X      extern char FBMap[];
	X!     int allmask = -1;
	X      int op;
	X  
	X!     if ((PixRect->pr_depth == 1) && !(zmask & 1))
	X! 	return;
	X      SetZmask(PixRect, &zmask);
	X-     if (fore & 1)
	X- 	func += 0x20;
	X-     if (back & 1)
	X- 	func += 0x10;
	X  
	X-     func = FBMap[func];
	X      op = SUN_FROM_X_OP(func);
	X  
	X!     Src = mem_point(width, height, srcdepth, data);
	X      if (xymask == NULL) {
	X  	do {
	X  	    int         cleft, ctop, cwidth, cheight;
	X--- 214,259 ----
	X  {
	X      struct pixrect *Src;
	X      extern char FBMap[];
	X!     int old_zmask;
	X      int op;
	X  
	X!     if (PixRect->pr_depth == 1)
	X!     {
	X! 	if ((zmask & 01) == 0) return;
	X! 
	X! 	if (fore & 1)
	X! 	    func += 0x20;
	X! 	if (back & 1)
	X! 	    func += 0x10;
	X! 
	X!         func = FBMap[func];
	X!     }
	X! 
	X!     GetZmask(PixRect, &old_zmask);
	X      SetZmask(PixRect, &zmask);
	X  
	X      op = SUN_FROM_X_OP(func);
	X  
	X!     if (srcdepth == 1 && PixRect->pr_depth != 1 && back != 0)
	X!     {
	X!         struct pixrect *bits = mem_point(width, height, srcdepth, data);
	X! 
	X! 	Src = mem_create(width, height, PixRect->pr_depth);
	X! 	pr_rop(Src, 0, 0, width, height,
	X! 		PIX_SRC|PIX_COLOR(back)|PIX_DONTCLIP,
	X! 		(struct pixrect *)NULL, 0, 0
	X! 		);
	X! 	pr_rop(Src, 0, 0, width, height,
	X! 		(PIX_SRC^PIX_DST)|PIX_COLOR(fore^back)|PIX_DONTCLIP,
	X! 		bits, 0, 0
	X! 		);
	X! 	pr_destroy(bits);
	X!     }
	X!     else
	X!     {
	X!         Src = mem_point(width, height, srcdepth, data);
	X!     }
	X! 
	X      if (xymask == NULL) {
	X  	do {
	X  	    int         cleft, ctop, cwidth, cheight;
	X***************
	X*** 263,269 ****
	X      }
	X      RestoreCursor();
	X      pr_destroy(Src);
	X!     SetZmask(PixRect, &allmask);
	X      return;
	X  }
	X  #endif	sun
	X--- 290,296 ----
	X      }
	X      RestoreCursor();
	X      pr_destroy(Src);
	X!     SetZmask(PixRect, &old_zmask);
	X      return;
	X  }
	X  #endif	sun
SHAR_EOF
if test 2933 -ne "`wc -c < 'put.c.patch'`"
then
	echo shar: error transmitting "'put.c.patch'" '(should have been 2933 characters)'
fi
fi # end of overwriting check
echo shar: done with directory "'changes'"
cd ..
echo shar: done with directory "'libsun.2'"
cd ..
if test ! -d 'changes'
then
	echo shar: creating directory "'changes'"
	mkdir 'changes'
fi
echo shar: entering directory "'changes'"
cd 'changes'
echo shar: extracting "'Makefile.patch'" '(1091 characters)'
if test -f 'Makefile.patch'
then
	echo shar: will not over-write existing file "'Makefile.patch'"
else
sed 's/^	X//' << \SHAR_EOF > 'Makefile.patch'
	X*** /usr/src/new/X.V10R4/./Makefile	Mon Dec  1 20:19:47 1986
	X--- Makefile	Mon Jun  8 14:28:33 1987
	X***************
	X*** 1,7 ****
	X  #
	X  # Copyright 1985, 1986, Massachusetts Institute of Technology.
	X  #
	X! # $Header: Makefile,v 10.38 86/12/01 20:19:32 jg Exp $
	X  #
	X  # Subdirectories that have makefiles of their own.
	X  #
	X--- 1,7 ----
	X  #
	X  # Copyright 1985, 1986, Massachusetts Institute of Technology.
	X  #
	X! # $Header: Makefile,v 10.39 87/05/21 11:39:47 mayer Exp $
	X  #
	X  # Subdirectories that have makefiles of their own.
	X  #
	X***************
	X*** 111,118 ****
	X  # fixup Xlib.h to get rid of <sys/types.h> for Sun 2.0 and before.
	X  #	make xlibchange
	X  # replace VAX demo executables with Sun executables.
	X! 	for i in exe.v${XVERSION}/*.sun;  do \
	X! 		-mv $$i exe.v${XVERSION}/`basename $$i .sun` ; \
	X  	done
	X  
	X  is:
	X--- 111,118 ----
	X  # fixup Xlib.h to get rid of <sys/types.h> for Sun 2.0 and before.
	X  #	make xlibchange
	X  # replace VAX demo executables with Sun executables.
	X! 	-for i in exe.v${XVERSION}/*.sun;  do \
	X! 		mv -f $$i exe.v${XVERSION}/`basename $$i .sun` ; \
	X  	done
	X  
	X  is:
SHAR_EOF
if test 1091 -ne "`wc -c < 'Makefile.patch'`"
then
	echo shar: error transmitting "'Makefile.patch'" '(should have been 1091 characters)'
fi
fi # end of overwriting check
echo shar: done with directory "'changes'"
cd ..
if test ! -d 'history'
then
	echo shar: creating directory "'history'"
	mkdir 'history'
fi
echo shar: entering directory "'history'"
cd 'history'
echo shar: extracting "'Makefile'" '(602 characters)'
if test -f 'Makefile'
then
	echo shar: will not over-write existing file "'Makefile'"
else
sed 's/^	X//' << \SHAR_EOF > 'Makefile'
	X
	XRCS file:        ./RCS/Makefile,v;   Working file:    Makefile
	Xhead:            10.39
	Xlocks:           ;  strict
	Xaccess list:   
	Xsymbolic names:
	Xcomment leader:  "# "
	Xtotal revisions: 2;    selected revisions: 2
	Xdescription:
	XMakefile for X.V10R4
	X----------------------------
	Xrevision 10.39        
	Xdate: 87/05/21 11:39:47;  author: mayer;  state: Exp;  lines added/del: 2/2
	XFixed bug with 'make sun' entry.
	X----------------------------
	Xrevision 10.38        
	Xdate: 86/12/01 20:19:32;  author: jg;  state: Exp;  
	XXerox port
	X=============================================================================
SHAR_EOF
if test 602 -ne "`wc -c < 'Makefile'`"
then
	echo shar: error transmitting "'Makefile'" '(should have been 602 characters)'
fi
fi # end of overwriting check
echo shar: done with directory "'history'"
cd ..
if test ! -d 'X'
then
	echo shar: creating directory "'X'"
	mkdir 'X'
fi
echo shar: entering directory "'X'"
cd 'X'
if test ! -d 'changes'
then
	echo shar: creating directory "'changes'"
	mkdir 'changes'
fi
echo shar: entering directory "'changes'"
cd 'changes'
echo shar: extracting "'Makefile.patch'" '(903 characters)'
if test -f 'Makefile.patch'
then
	echo shar: will not over-write existing file "'Makefile.patch'"
else
sed 's/^	X//' << \SHAR_EOF > 'Makefile.patch'
	X*** /usr/src/new/X.V10R4/X/Makefile	Mon Dec  1 18:39:49 1986
	X--- Makefile	Mon Jun  8 14:28:39 1987
	X***************
	X*** 6,12 ****
	X  # -DDNETCONN allows DECnet connections
	X  INCLUDES= -I../include
	X  NETOPTIONS= -DTCPCONN -DDUALTCP -DUNIXCONN
	X! CFLAGS= -O ${NETOPTIONS} ${INCLUDES}
	X  STDLIB= -ldbm
	X  
	X  APOLLOLIB= ../libapollo/libapollo.a
	X--- 6,13 ----
	X  # -DDNETCONN allows DECnet connections
	X  INCLUDES= -I../include
	X  NETOPTIONS= -DTCPCONN -DDUALTCP -DUNIXCONN
	X! OPT=-O
	X! CFLAGS= $(OPT) ${NETOPTIONS} ${INCLUDES}
	X  STDLIB= -ldbm
	X  
	X  APOLLOLIB= ../libapollo/libapollo.a
	X***************
	X*** 81,87 ****
	X  	echo "Installing servers...."
	X  	cd servers; \
	X  	for i in X*; do \
	X! 		install -c -m 775 $$i ${DESTDIR}${CONFDIR};\
	X  	done
	X  	
	X  include:
	X--- 82,88 ----
	X  	echo "Installing servers...."
	X  	cd servers; \
	X  	for i in X*; do \
	X! 		install -c -m 4775 $$i ${DESTDIR}${CONFDIR};\
	X  	done
	X  	
	X  include:
SHAR_EOF
if test 903 -ne "`wc -c < 'Makefile.patch'`"
then
	echo shar: error transmitting "'Makefile.patch'" '(should have been 903 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'input.c.patch'" '(922 characters)'
if test -f 'input.c.patch'
then
	echo shar: will not over-write existing file "'input.c.patch'"
else
sed 's/^	X//' << \SHAR_EOF > 'input.c.patch'
	X*** /usr/src/new/X.V10R4/X/input.c	Wed Dec 17 20:26:02 1986
	X--- input.c	Mon Jun  8 14:28:45 1987
	X***************
	X*** 13,19 ****
	X   */
	X  
	X  #ifndef lint
	X! static char *rcsid_input_c = "$Header: input.c,v 10.12 86/12/17 20:25:13 swick Exp $";
	X  #endif
	X  
	X  
	X--- 13,19 ----
	X   */
	X  
	X  #ifndef lint
	X! static char *rcsid_input_c = "$Header: input.c,v 10.13 87/05/02 14:33:39 mayer Exp $";
	X  #endif
	X  
	X  
	X***************
	X*** 532,539 ****
	X  	    return;
	X  	}
	X  	ocurs = cursor;
	X! 	deltax = ocurs->xoff - curs->xoff;
	X! 	deltay = ocurs->yoff - curs->yoff;
	X  	button_window = NULL;
	X  	if (mouse_grabber == 0) {
	X  	    Stash_grabs (client);
	X--- 532,546 ----
	X  	    return;
	X  	}
	X  	ocurs = cursor;
	X! 	if (ocurs == NULL)
	X! 	{
	X! 		deltax = deltay = 0;
	X! 	}
	X! 	else
	X! 	{
	X! 		deltax = ocurs->xoff - curs->xoff;
	X! 		deltay = ocurs->yoff - curs->yoff;
	X! 	}
	X  	button_window = NULL;
	X  	if (mouse_grabber == 0) {
	X  	    Stash_grabs (client);
SHAR_EOF
if test 922 -ne "`wc -c < 'input.c.patch'`"
then
	echo shar: error transmitting "'input.c.patch'" '(should have been 922 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'main.c.patch'" '(4178 characters)'
if test -f 'main.c.patch'
then
	echo shar: will not over-write existing file "'main.c.patch'"
else
sed 's/^	X//' << \SHAR_EOF > 'main.c.patch'
	X*** /usr/src/new/X.V10R4/X/main.c	Mon Dec  1 18:40:23 1986
	X--- main.c	Mon Jun  8 14:28:59 1987
	X***************
	X*** 5,11 ****
	X  /* Initialization and socket routines */
	X  
	X  #ifndef lint
	X! static char *rcsid_main_c = "$Header: main.c,v 10.17 86/11/06 19:42:02 jg Rel $";
	X  #endif
	X  
	X  #include <dbm.h>
	X--- 5,11 ----
	X  /* Initialization and socket routines */
	X  
	X  #ifndef lint
	X! static char *rcsid_main_c = "$Header: main.c,v 10.19 87/05/11 15:19:11 mayer Exp $";
	X  #endif
	X  
	X  #include <dbm.h>
	X***************
	X*** 48,53 ****
	X--- 48,55 ----
	X  char *rgb_name = RGB_DB;	/* RGB database name */
	X  int havergb = 0;		/* have RGB database? */
	X  
	X+ char *private_flags = "";	/* device dependent flags */
	X+ 
	X  static short _back[16] = {0x8888, 0x2222, 0x4444, 0x1111,
	X  			  0x8888, 0x2222, 0x4444, 0x1111,
	X  			  0x8888, 0x2222, 0x4444, 0x1111,
	X***************
	X*** 163,168 ****
	X--- 165,173 ----
	X  		default_lock = 1;
	X  	    } else if (strcmp (arg, "m") == 0) {
	X  		default_mono = 1;
	X+ 	    } else if (strcmp (arg, "-u") == 0 && i < argc) {
	X+ 		private_flags = argv[i];
	X+ 		i++;
	X  	    } else if (strcmp (arg, "-p") == 0 && i < argc) {
	X  		default_savercycle = atoi (argv[i]);
	X  		if (default_savercycle == 0) Usage ();
	X***************
	X*** 202,210 ****
	X  Usage ()
	X  {
	X  	printf("usage:  X <display> [option ...] <tty>\n");
	X! 	printf("options: -a #, c #, -c, -f #, -l, l, m, -p #, -r, r, -s #, -t #, v, -v\n");
	X  	printf("         -0 <color> -1 <color> -D <rgbdb>\n");
	X! 	exit(1);
	X  }
	X  
	X  /* Called from Dispatcher when there are no complete requests to process, or
	X--- 207,215 ----
	X  Usage ()
	X  {
	X  	printf("usage:  X <display> [option ...] <tty>\n");
	X! 	printf("options: -a #, c #, -c, -f #, -l, l, m, o, -p #, -r, r, -s #, -t #, v, -v\n");
	X  	printf("         -0 <color> -1 <color> -D <rgbdb>\n");
	X! 	ServerExit(1);
	X  }
	X  
	X  /* Called from Dispatcher when there are no complete requests to process, or
	X***************
	X*** 687,692 ****
	X--- 692,698 ----
	X  	BITMAP *bit1, *bit2;
	X  	datum dbent;
	X  	RGB color;
	X+ 	int old_mask;
	X  
	X  	lastfdesc = getdtablesize() - 1;
	X  	if (lastfdesc > maxsocks)
	X***************
	X*** 698,703 ****
	X--- 704,710 ----
	X  	    strcat (fname, "msgs");
	X  	    freopen (fname, "w+", stderr);
	X  	}
	X+ 	setlinebuf(stderr);
	X  	if (getpgrp (0) == 0)
	X  	    setpgrp (0, getpid ());
	X  	if (dbminit (rgb_name) == 0)
	X***************
	X*** 816,824 ****
	X  	}
	X  #endif
	X  	if (requestmask == 0) Error ("No Listeners");
	X! 	signal (SIGHUP, SIG_IGN);
	X  	if (InitDisplay (&device)) Error ("Initializing");
	X  	signal (SIGHUP, HangUp);
	X  	Qmax = device.queue->size - 1;
	X  	devmask = 1 << devdesc;
	X  	selmask[0] = devmask | requestmask;
	X--- 823,836 ----
	X  	}
	X  #endif
	X  	if (requestmask == 0) Error ("No Listeners");
	X! 
	X! 	old_mask = sigblock(sigmask(SIGHUP));
	X  	if (InitDisplay (&device)) Error ("Initializing");
	X  	signal (SIGHUP, HangUp);
	X+ 	(void) sigsetmask(old_mask&~sigmask(SIGHUP));
	X+ 
	X+ 	(void) setuid(getuid());
	X+ 
	X  	Qmax = device.queue->size - 1;
	X  	devmask = 1 << devdesc;
	X  	selmask[0] = devmask | requestmask;
	X***************
	X*** 985,1000 ****
	X  
	X  #ifdef GPROF
	X  	chdir ("/tmp");
	X! 	exit (0);
	X  #endif
	X  	for (i = firstsock; i < maxsock; i++) {
	X  	    if (socketOn[i])
	X  		close (i);
	X  	}
	X! 	if (DisplayDead ())
	X  	    Error ("HangUp");
	X  }
	X  
	X  /* log a server error */
	X  
	X  Notice (where)
	X--- 997,1023 ----
	X  
	X  #ifdef GPROF
	X  	chdir ("/tmp");
	X! 	ServerExit (0);
	X  #endif
	X  	for (i = firstsock; i < maxsock; i++) {
	X  	    if (socketOn[i])
	X  		close (i);
	X  	}
	X! 	if (CloseDisplay ())
	X  	    Error ("HangUp");
	X  }
	X  
	X+ /* close down the display */
	X+ int
	X+ CloseDisplay()
	X+ {
	X+ 	int old_mask = sigblock(sigmask(SIGHUP));
	X+ 	int result = DisplayDead();
	X+ 	(void) sigsetmask(old_mask);
	X+ 	return result;
	X+ }
	X+  
	X+ 
	X  /* log a server error */
	X  
	X  Notice (where)
	X***************
	X*** 1015,1021 ****
	X  	Notice (where);
	X  	if (errdelay)
	X  	    sleep (errdelay);
	X! 	exit (1);
	X  }
	X  
	X  /* log a device error */
	X--- 1038,1054 ----
	X  	Notice (where);
	X  	if (errdelay)
	X  	    sleep (errdelay);
	X! 	ServerExit (1);
	X! }
	X! 
	X! /* clean up and exit */
	X! 
	X! ServerExit (code)
	X! 	int code;
	X! {
	X! 	fflush (stderr);
	X! 	(void) CloseDisplay ();
	X! 	exit (code);
	X  }
	X  
	X  /* log a device error */
SHAR_EOF
if test 4178 -ne "`wc -c < 'main.c.patch'`"
then
	echo shar: error transmitting "'main.c.patch'" '(should have been 4178 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'resource.c.patch'" '(1054 characters)'
if test -f 'resource.c.patch'
then
	echo shar: will not over-write existing file "'resource.c.patch'"
else
sed 's/^	X//' << \SHAR_EOF > 'resource.c.patch'
	X*** /usr/src/new/X.V10R4/X/resource.c	Mon Dec  1 18:40:30 1986
	X--- resource.c	Mon Jun  8 14:29:09 1987
	X***************
	X*** 15,21 ****
	X   *	Xalloc, Xrealloc
	X   */
	X  #ifndef lint
	X! static char *rcsid_resource_c = "$Header: resource.c,v 10.17 86/12/01 11:43:53 jg Rel $";
	X  #endif
	X  
	X  #include "Xint.h"
	X--- 15,21 ----
	X   *	Xalloc, Xrealloc
	X   */
	X  #ifndef lint
	X! static char *rcsid_resource_c = "$Header: resource.c,v 10.18 87/05/02 14:35:25 mayer Exp $";
	X  #endif
	X  
	X  #include "Xint.h"
	X***************
	X*** 335,341 ****
	X          if ((myhostent = gethostbyname(hname)) == 
	X              (struct hostent *)NULL) {
	X  	      Error("Define_self");                                  
	X! 	      exit(1);
	X              }         
	X          }
	X  	host = (HOST *) Xalloc (sizeof (HOST));
	X--- 335,341 ----
	X          if ((myhostent = gethostbyname(hname)) == 
	X              (struct hostent *)NULL) {
	X  	      Error("Define_self");                                  
	X! 	      ServerExit(1);
	X              }         
	X          }
	X  	host = (HOST *) Xalloc (sizeof (HOST));
SHAR_EOF
if test 1054 -ne "`wc -c < 'resource.c.patch'`"
then
	echo shar: error transmitting "'resource.c.patch'" '(should have been 1054 characters)'
fi
fi # end of overwriting check
echo shar: done with directory "'changes'"
cd ..
if test ! -d 'history'
then
	echo shar: creating directory "'history'"
	mkdir 'history'
fi
echo shar: entering directory "'history'"
cd 'history'
echo shar: extracting "'Makefile'" '(650 characters)'
if test -f 'Makefile'
then
	echo shar: will not over-write existing file "'Makefile'"
else
sed 's/^	X//' << \SHAR_EOF > 'Makefile'
	X
	XRCS file:        X/RCS/Makefile,v;   Working file:    Makefile
	Xhead:            1.2
	Xlocks:           ;  strict
	Xaccess list:   
	Xsymbolic names:
	Xcomment leader:  "# "
	Xtotal revisions: 2;    selected revisions: 2
	Xdescription:
	XX.V10R4 release.
	X----------------------------
	Xrevision 1.2        
	Xdate: 87/05/11 15:17:26;  author: mayer;  state: Exp;  lines added/del: 3/2
	XAdded "OPT=" makefile variable, and changed so that it is installed in
	Xsuid mode.
	X----------------------------
	Xrevision 1.1        
	Xdate: 87/05/02 14:32:08;  author: mayer;  state: Exp;  
	XInitial revision
	X=============================================================================
SHAR_EOF
if test 650 -ne "`wc -c < 'Makefile'`"
then
	echo shar: error transmitting "'Makefile'" '(should have been 650 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'input.c'" '(664 characters)'
if test -f 'input.c'
then
	echo shar: will not over-write existing file "'input.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'input.c'
	X
	XRCS file:        X/RCS/input.c,v;   Working file:    input.c
	Xhead:            10.13
	Xlocks:           ;  strict
	Xaccess list:   
	Xsymbolic names:
	Xcomment leader:  " * "
	Xtotal revisions: 2;    selected revisions: 2
	Xdescription:
	XX.V10R4 release.
	X----------------------------
	Xrevision 10.13        
	Xdate: 87/05/02 14:33:39;  author: mayer;  state: Exp;  lines added/del: 9/2
	XMake sure "Grab_mouse" works when there is no current cursor.
	X----------------------------
	Xrevision 10.12        
	Xdate: 86/12/17 20:25:13;  author: swick;  state: Exp;  
	XXerox Webster Research Center SUN 3/110C port
	X=============================================================================
SHAR_EOF
if test 664 -ne "`wc -c < 'input.c'`"
then
	echo shar: error transmitting "'input.c'" '(should have been 664 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'main.c'" '(897 characters)'
if test -f 'main.c'
then
	echo shar: will not over-write existing file "'main.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'main.c'
	X
	XRCS file:        X/RCS/main.c,v;   Working file:    main.c
	Xhead:            10.19
	Xlocks:           ;  strict
	Xaccess list:   
	Xsymbolic names:
	Xcomment leader:  " * "
	Xtotal revisions: 3;    selected revisions: 3
	Xdescription:
	XX.V10R4 release.
	X----------------------------
	Xrevision 10.19        
	Xdate: 87/05/11 15:19:11;  author: mayer;  state: Exp;  lines added/del: 8/2
	XAdded "-u" flag.  This flag takes a string argument, which is made
	Xavailable to the machine dependent part of the server.
	X----------------------------
	Xrevision 10.18        
	Xdate: 87/05/02 14:34:45;  author: mayer;  state: Exp;  lines added/del: 32/5
	XAdded code to reset the keyboard on error exits.
	X----------------------------
	Xrevision 10.17        
	Xdate: 86/11/06 19:42:02;  author: jg;  state: Rel;  
	XXerox Webster Research Center SUN 3/110C port
	X=============================================================================
SHAR_EOF
if test 897 -ne "`wc -c < 'main.c'`"
then
	echo shar: error transmitting "'main.c'" '(should have been 897 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'resource.c'" '(654 characters)'
if test -f 'resource.c'
then
	echo shar: will not over-write existing file "'resource.c'"
else
sed 's/^	X//' << \SHAR_EOF > 'resource.c'
	X
	XRCS file:        X/RCS/resource.c,v;   Working file:    resource.c
	Xhead:            10.18
	Xlocks:           ;  strict
	Xaccess list:   
	Xsymbolic names:
	Xcomment leader:  " * "
	Xtotal revisions: 2;    selected revisions: 2
	Xdescription:
	XX.V10R4 release.
	X----------------------------
	Xrevision 10.18        
	Xdate: 87/05/02 14:35:25;  author: mayer;  state: Exp;  lines added/del: 1/1
	XAdded code to reset the keyboard on error exits.
	X----------------------------
	Xrevision 10.17        
	Xdate: 86/12/01 11:43:53;  author: jg;  state: Rel;  
	XXerox Webster Research Center SUN 3/110C port
	X=============================================================================
SHAR_EOF
if test 654 -ne "`wc -c < 'resource.c'`"
then
	echo shar: error transmitting "'resource.c'" '(should have been 654 characters)'
fi
fi # end of overwriting check
echo shar: done with directory "'history'"
cd ..
echo shar: done with directory "'X'"
cd ..
#	End of shell archive
exit 0

-- 

Rich $alz			"Anger is an energy"
Cronus Project, BBN Labs	rsalz@bbn.com
Moderator, comp.sources.unix	sources@uunet.uu.net
