Path: seismo!uunet!rs
From: rs@uunet.UU.NET (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v10i001:  Crypt Breaker's Workbench, Part01/11
Message-ID: <373@uunet.UU.NET>
Date: 17 Jun 87 22:33:58 GMT
Organization: UUNET Communications Services, Arlington, VA
Lines: 2648
Approved: rs@uunet.uu.net

Submitted by: Robert W. Baldwin <BALDWIN@XX.LCS.MIT.EDU>
Mod.sources: Volume 10, Issue 1
archive-name: cbw/Part01

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 11)."
# Contents:  Index MANIFEST Makefile TODO.txt UU.graphics approx.c
#   autotri.h banner.c cblocks.c char-io.c common.words dblock.h
#   dbsaux.c enigma.c h19.slice keylib.c layout.h
#   mss-prob-printout.txt mss.stats mss.words parser.c parser.h
#   pgate.c pqueue.c pqueue.h sdriver.c short.words stats.slice
#   test3.words trigrams.short trigrams.stats tritab.c vt100.slice
#   zeecode.c
# Wrapped by rs@uunet on Wed Jun 17 18:17:00 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Index -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Index\"
else
echo shar: Extracting \"Index\" \(2276 characters\)
sed "s/^X//" >Index <<'END_OF_Index'
XIndex for CBW programs and data files.
X
X
XTemplate:
X
XProgram Name:  
XDescription:   
XBrief Doc:     
XMaintainer:    
XFiles:         
X
X
XPrograms:
X
XProgram Name:  cbw
XDescription:   Interactive code breaker's workbench.
XBrief Doc:     Execute "runcbw", see cbw.doc.
XMaintainer:    Bob Baldwin  (Baldwin@mit-xx) (eddie!baldwin.UUCP)
XFiles:         dblock.h, layout.h, parser.h, specs.h, window.h,
X               banner.c, cblocks.c, dblock.c, dline.c, gblock.c,
X               keylib.c, knit.c, parser.c, screen.c, start.c,
X               stats.c, triglist.c, trigram.c, user.c, webster.c,
X               windowlib.c
X
X
XProgram Name:  enigma
XDescription:   Identical to crypt command based on one-rotor enigma.
XBrief Doc:     enigma <infile >outfile    It will ask for key.
XMaintainer:    Bob Baldwin
XFiles:         enigma.c
X
X
XProgram Name:  zeecode
XDescription:   Zeecode assumes that the file zeecode.perm contains a .perm
X	       file produced by cbw.  It uses the A0 and Zee permutations
X	       in that file to decode the standard input, printing results
X	       on the standard output.
XBrief Doc:     zeecode <cipherfile >cleartextfile
X               Reads zeecode.save to get A0 and Zee.
XMaintainer:    Bob Baldwin
XFiles:         zeecode.c
X
X
X
XData Files:
X
XTemplate:
X
XFile Name:	
XDescription:	
X
X
XFile Name:	*.slice
XDescription:	Pieces of .login file to init CBW shell variables.
X
XFile Name:	graphics
XDescription:	Cat'ing this file displays all the graphics characters
X		on heath and vt100 terminals.
X
XFile Name:	cbw.log
XDescription:	History of changes to cbw source.
X
XFile Name:	cbw.doc and cbw.mss
XDescription:	User manual for cbw.
X
XFile Name:	trigrams.stats
XDescription:	Frequencies of common trigrams.
X
XFile Name:	mss-bigram.stats
XDescription:	Bigram statistics for scribe files. 
X
XFile Name:	mss.stats
XDescription:	Monogram statistics for scribe files. 
X
XFile Name:	*.cipher
XDescription:	Ciphertext file read by cbw.
X
XFile Name:	*.perm
XDescription:	Permutations saved by cbw to record partial solutions
X		to a ciphertext.
X
XFile Name:	*.txt
XDescription:	Original text used to create the .cipher files.
X
XFile Name:	*.words
XDescription:	Lists of words for use with the probable-word guessing
X		strategy.
X
XFile Name:	test3.words
XDescription:	Probable words for test3.cipher.
END_OF_Index
if test 2276 -ne `wc -c <Index`; then
    echo shar: \"Index\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f MANIFEST -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"MANIFEST\"
else
echo shar: Extracting \"MANIFEST\" \(2376 characters\)
sed "s/^X//" >MANIFEST <<'END_OF_MANIFEST'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Index                     1	
X MANIFEST                  1	
X Makefile                  1	
X Read.me                   5	
X TODO.txt                  1	
X UU.foo                    9	
X UU.graphics               1	
X UU.test                   4	
X UU.test1                  4	
X UU.test2                  3	
X UU.test3                 10	
X approx.c                  1	
X autotri.c                 4	
X autotri.h                 1	
X banner.c                  1	
X bdriver.c                 2	
X cblocks.c                 1	
X cbw.doc                  11	
X cbw.log                   3	
X char-io.c                 1	
X cipher.c                  5	
X cipher.h                  2	
X common.words              1	
X dblock.c                  7	
X dblock.h                  1	
X dbsaux.c                  1	
X dline.c                   4	
X eclass.c                  5	
X edriver.c                 2	
X enigma.c                  1	
X foo.perm                  6	
X gblock.c                  2	
X h19.slice                 1	
X keylib.c                  1	
X knit.c                    5	
X layout.h                  1	
X lpair.c                   6	
X mss-bigram-old.stats      2	
X mss-bigram.stats          3	
X mss-prob-printout.txt     1	
X mss.stats                 1	
X mss.words                 1	
X parser.c                  1	
X parser.h                  1	
X perm.c                    2	
X pgate.c                   1	
X pqueue.c                  1	
X pqueue.h                  1	
X pword.c                   3	
X screen.c                  3	
X sdriver.c                 1	
X short.words               1	
X specs.h                   4	
X start.c                   2	
X stats.c                   8	
X stats.slice               1	
X tdriver.c                 3	
X terminal.c                8	
X terminal.h                2	
X test.txt                  4	
X test1.perm                6	
X test1.txt                 3	
X test2.txt                 2	
X test3.perm                7	
X test3.txt                 9	
X test3.words               1	
X trigrams.short            1	
X trigrams.stats            1	
X tritab.c                  1	
X user.c                    4	
X vt100.slice               1	
X webster.c                 2	
X window.h                  3	
X windowlib.c               2	
X zeecode.c                 1	
X zeecode.perm              5	
END_OF_MANIFEST
if test 2376 -ne `wc -c <MANIFEST`; then
    echo shar: \"MANIFEST\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Makefile -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile\"
else
echo shar: Extracting \"Makefile\" \(1573 characters\)
sed "s/^X//" >Makefile <<'END_OF_Makefile'
XCFLAGS = -g
X
X# Object files for for the workbench.
Xcbreq =	pword.o lpair.o approx.o \
X		eclass.o cipher.o char-io.o \
X		tritab.o autotri.o pqueue.o \
X		webster.o user.o gblock.o dblock.o dbsaux.o banner.o \
X		cblocks.o stats.o parser.o knit.o \
X		pgate.o perm.o terminal.o \
X		keylib.o windowlib.o dline.o screen.o 
X
X# The main program.
Xcbw: start.o $(cbreq) 
X	cc $(CFLAGS) start.o $(cbreq) \
X	-lcurses -ltermcap -lm -o cbw
X
X# Program to decrypt files after they have been broken by CBW.
Xzeecode: zeecode.o
X	cc $(CFLAGS) zeecode.o -o zeecode
X
X# Program to encrypt files, this is identical to the
X# Unix crypt function based on a two rotor enigma.
Xenigma: enigma.o
X	cc $(CFLAGS) enigma.o -o enigma
X
X#
X# The remaining files are test drivers.
X#
X
Xbd: bdriver.o $(cbreq)
X	cc -g bdriver.o $(cbreq) -lm \
X	-lcurses -ltermcap -lm -o bd
X
Xsd: sdriver.o $(cbreq)
X	cc -g sdriver.o $(cbreq) \
X	-lcurses -ltermcap -lm -o sd
X
Xapprox: approx.o
X	cc -g approx.o -lm -o approx
X
Xstats: stats.o char-io.o
X	cc -g stats.o char-io.o -lm -o stats
X
Xtri: tdriver.o $(cbreq)
X	cc -g tdriver.o $(cbreq) -lm \
X	-lcurses -ltermcap -lm -o tri
X
Xectreq = edriver.o eclass.o cipher.o char-io.o \
X		triglist.o \
X		webster.o user.o gblock.o dblock.o dbsaux.o banner.o \
X		cblocks.o trigram.o stats.o parser.o knit.o \
X		pgate.o perm.o \
X		keylib.o windowlib.o dline.o screen.o 
X
X
Xect: $(ectreq)
X	cc -g $(ectreq) -lm \
X	-o ect
X
Xptt: char-io.o probtab.o
X	cc -g char-io.o probtab.o -lm -o ptt
X
Xdt: disptest.o keylib.o windowlib.o screen.o
X	cc disptest.o keylib.o windowlib.o screen.o -o dt
X
Xtriplace: triplace.o
X
X
END_OF_Makefile
if test 1573 -ne `wc -c <Makefile`; then
    echo shar: \"Makefile\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f TODO.txt -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"TODO.txt\"
else
echo shar: Extracting \"TODO.txt\" \(2021 characters\)
sed "s/^X//" >TODO.txt <<'END_OF_TODO.txt'
XSuggested Improvements to CBW
X
X	See cbw.log for things that have been done.
X
X- Most terminals can be in both inverse video and graphics mode, but
X  the graphics variable format cannot reflect this.
X  - need new mode 'B' meaning both.
X
X- Program doesn't handle blocks less than 256 chars, which
X  makes it hard to decode very short messages.  -- Hard to fix.
X
X- Add window done proc that can cleanup state before
X  a window is replaced.  This would fix the bug in the
X  knitting window which causes it to accept the currently
X  displayed guess.
X
X- Add a decode block command.
X- Make the help window two line tall.
X- Add a command that allows guess words from the keyboard
X  rather than a file.  -- NO better to build vocabulary files.
X
X- Make the propagate command take a range of destination
X  blocks.  E.G. "propagate block 0 to blocks 1 thru 5".
X
X- Make C-U multiply cursor motion commands as in emacs.
X- The command "q<retrun>" should expand into a quit, instead
X  of typing "q<space><return>".
X
X- Add batch mode that applies a sequence of command to all
X  the blocks in a file.
X  -- The driver routines do this, so it should be easy.
X
X- Document the statistics file format.
X- Write a C program for gathering statistics
X  -- The original was written in CLU.
X
X- Add a confirm request to the load command.
X
X- Add a better indicator that the program is busy
X  - especially for the knit command.
X
X- Need better explaination on knitting.
X
X- Add an automatic C-T mode to help verify correct characters.
X- Add command to identify weak characters in the block
X  - i.e., chars that don't deduce anything else.
X
X- Add a save command with a default name that the user can change.
X  - It should default to the load file name.
X
X- If 127 out of 128 wires are known, set the 128th.
X
X- Document the zeecode program.
X
X- Add a command to goto a specific block number.
X- Need better explaination of the pword command.
X
X- Add command that search a dictionary for a word that will
X  fit at a given place.
X  - Worry about case and endings.
END_OF_TODO.txt
if test 2021 -ne `wc -c <TODO.txt`; then
    echo shar: \"TODO.txt\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f UU.graphics -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"UU.graphics\"
else
echo shar: Extracting \"UU.graphics\" \(327 characters\)
sed "s/^X//" >UU.graphics <<'END_OF_UU.graphics'
Xbegin 644 graphics
XM&T9A8F-D969G:!M'"AM&:6IK;&UN;W`;1PH;1G%R<W1U=G=X&T<*&T9Y>GM\
XM?7X;1PH;1D%"0T1%1D=(&T<*&T9)2DM,34Y/4!M'"AM&45)35%565U@;1PH;
XM1EE:6UQ=(%\;1PHM+2T*&T8!`@,$!08'"!M'"AM&"0H+#`T.#Q`;1PH;1A$2
XM$Q05%A<8&T<*&T89&B`<'1\;1PHM+2T*&T8Q,C,T-38W.#DP&T<*&T8A0",D
XF)5XF*B@I&T<*&T8@+5\]*V!^6UU<?#LZ)R)[?2P\+CXO/QM'"@H*
X`
Xend
END_OF_UU.graphics
if test 327 -ne `wc -c <UU.graphics`; then
    echo shar: \"UU.graphics\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f approx.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"approx.c\"
else
echo shar: Extracting \"approx.c\" \(1891 characters\)
sed "s/^X//" >approx.c <<'END_OF_approx.c'
X/*
X * Fast approximations of useful math functions.
X *
X * Robert W. Baldwin, May 1985.
X */
X
X
X#include	<stdio.h>
X#include	<math.h>
X#include	"window.h"
X#include	"specs.h"
X
X
X#define STANDALONE	FALSE
X
X#define	NFEXP		100		/* Number of entries in fexp_value table. */
X#define	DXFEXP		0.05	/* Interval width in fexp table. */
X#define	MAXFEXP		(NFEXP * DXFEXP)	/* Max value < this */
X
X
X/* Table of values for exp(-(x*x)/2) starting with zero at intervals of 0.1
X * The values of the derivative of exp(-(x*x)/2) are in fexp_deriv.
X */
Xfloat	fexp_value[NFEXP];
Xfloat	fexp_deriv[NFEXP];
X
X
X/* Table for fast square root computation.
X */
Xfloat	isqrt[BLOCKSIZE];
X
X
X#if STANDALONE
Xmain()
X{
X	int		i;
X	float	fi;
X
X	printf("\t\t\t\tTable of exp(-(x*x)/2)");
X	printf("\nX\t\treal\t\tapprox");
X	printf("\n\n");
X
X	approx_init();
X
X	for (i = 0 ; i < (NFEXP + 5) ; i++)  {
X		fi = i;
X		fi = fi * DXFEXP;
X		fi += DXFEXP/2.0;
X		printf("%f\t", fi);
X		printf("%f\t", exp(-(fi*fi)/2));
X		printf("%f", fexp(fi));
X		printf("\n");
X		}
X}
X#endif
X
X
X
X/* Initialize the approximation tables.
X */
Xapprox_init()
X{
X	sqrt_tab();
X	fexp_tab();
X}
X
X
X/* Fill in the table of square roots.
X */
Xsqrt_tab()
X{
X	reg	int		i;
X		float	fi;
X
X	for (i = 0 ; i < BLOCKSIZE ; i++)  {
X		fi = i;
X		isqrt[i] = sqrt(fi);
X		}
X}
X
X
X/* Fill in th approximation table for fexp.
X */
Xfexp_tab()
X{
X	int		i;
X	float	fi;
X	float	value;
X	float	deriv;
X
X	for (i = 0 ; i < NFEXP ; i++)  {
X		fi = i;
X		fi = fi * DXFEXP;
X		value = exp(-(fi*fi)/2);
X		deriv = -fi * value;
X		fexp_value[i] = value;
X		fexp_deriv[i] = deriv;
X		}
X}
X
X
X/* Return a fast approximation to exp(-(x*x)/2).
X */
Xfloat	fexp(x)
Xreg	float	x;
X{
Xreg	int		index;
X	float	approx;
Xreg	float	result;
X
X	x = abs(x);
X	if (x >= MAXFEXP)
X		return(0.0);
X	index = x * (1.0 / DXFEXP);
X	approx = index;
X	approx = approx * DXFEXP;
X	result = fexp_value[index];
X	result += (x - approx) * fexp_deriv[index];
X
X	return(result);
X}
END_OF_approx.c
if test 1891 -ne `wc -c <approx.c`; then
    echo shar: \"approx.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f autotri.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"autotri.h\"
else
echo shar: Extracting \"autotri.h\" \(1158 characters\)
sed "s/^X//" >autotri.h <<'END_OF_autotri.h'
X/*
X * Definitions for automatically guessing with trigrams. 
X */
X
X
X#define	PERMSZ		20
X#define	TRIGTABSZ	150
X#define	TRIGBUFSZ	(4*(TRIGTABSZ+1))
X
X
X
X#define	trig_ent	struct xtrigent
Xtrig_ent	{
X		float	prob;		/* A priori probability of this trigram. */
X		char	*trigram;	/* Null for last entry in table. */
X		int		notused;	/* For compatibility with pqueue. */
X		};
X
X
X#define	atrinfo	struct xatrinfo
Xatrinfo	{
X		ecinfo		*eci;
X		/* A guess must have a better score than this field. */
X		float		max_score;
X		/* A guess must deduce atleast this many chars. */
X		int			min_total_chars;
X		/* Each wire of the guess must deduce this many chars. */
X		int			min_wire_chars;
X		char		*best_trigram;
X		float		best_score;
X		int			gcount;			/* Total number of guesses. */
X		float		total_score;	/* Their cummulative score. */
X		/* NONE terminated string of the chars deduced by the best trigram. */
X		/* Does not include the trigram itself. */
X		int			best_pvec[BLOCKSIZE+1];
X		/* Table of permutation wirings deduced by the best guess so far. */
X		/* The table is terminated by a perment with x == NONE. */
X		perment		best_permvec[PERMSZ];
X		};
X
X
Xextern	trig_ent	trig_tab[];
X
END_OF_autotri.h
if test 1158 -ne `wc -c <autotri.h`; then
    echo shar: \"autotri.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f banner.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"banner.c\"
else
echo shar: Extracting \"banner.c\" \(1477 characters\)
sed "s/^X//" >banner.c <<'END_OF_banner.c'
X/*
X * Banner window abstraction.  Just a title text with default behavior.
X *
X * Robert W. Baldwin,  December 1984.
X */
X
X
X#include	<stdio.h>
X#include	"window.h"
X#include	"layout.h"
X
X
X/* Window for the title banner. */
X
Xdispline	banline1 = {
X			1,1,			/* Origin. */
X			1,MAXWIDTH,		/* Height and width. */
X			1,1,			/* Initial cursor position */
X			NULL,			/* No private data. */
X			wl_setcur,		/* Firstime = Set cursor to current value. */
X			wl_noop,		/* Lasttime = do nothing. */
X			wl_dldraw,		/* Default dispaly line draw routine. */
X			dokey,			/* Default keystroke handler. */
X			arwktab,		/* Basic arrow keystroke handler. */
X			1,MAXWIDTH,		/* Min and Max column for cursor in line. */
X			};
X
Xdispline	*banlines[] = {
X			&banline1,		/* List of display lines for the banner. */
X			NULL,
X			};
X
Xtwindow		banner = {
X			1,1,			/* Origin. */
X			1,MAXWIDTH,		/* Height and width. */
X			1,1,			/* Initial cursor position */
X			NULL,			/* No private data. */
X			wl_setcur,		/* Firstime = accept current cursor position. */
X			wl_noop,		/* Lasttime = do nothing. */
X			wl_twdraw,		/* Simple draw routine. */
X			dokey,			/* Default keystroke handler. */
X			arwktab,		/* Basic arrow keystroke handler. */
X			banlines,
X			};
X
X
X
X/* Initialize the banner window and return a pointer to it.
X * Fill in the banner text.
X */
Xgwindow *(ibanner())
X{
X	displine	*line;
X	int			i;
X
X	line = banner.dlines[0];
X	clrdline(line);
X	setndline(line, BANTEXT, BANLM);
X	return ((gwindow *) &banner);
X}
END_OF_banner.c
if test 1477 -ne `wc -c <banner.c`; then
    echo shar: \"banner.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f cblocks.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"cblocks.c\"
else
echo shar: Extracting \"cblocks.c\" \(1196 characters\)
sed "s/^X//" >cblocks.c <<'END_OF_cblocks.c'
X/*
X * Abstraction for the table of cipher text blocks.
X *
X * Robert W. Baldwin, December 1984.
X *
X * History:
X * 3/8/85	Bob Baldwin		Changed fname to cipherfile.
X * 1/13/85  Bob Baldwin		Permutation stuff moved to perm.c
X */
X
X
X#include	<stdio.h>
X#include	"window.h"
X#include	"layout.h"
X#include	"specs.h"
X
X
X
X#define	FROMSTART	0		/* For fseek call, how offset measured. */
X
X
X/* Input file name for ciphertext, set by main. */
Xchar	*cipherfile;
X
X
X/* Fill the given buffer with the i-th ciphertext block.
X * The block index is zero-based.
X * Return FALSE if try to read non-existant bytes.
X */
Xint	fillcbuf(blocknum, cbuf)
Xint		blocknum;
Xchar	*cbuf;
X{
X	FILE	*fd;
X	long	offset;
X	long	res;
X	int		i;
X
X	if ((blocknum < 0) || (NPERMS <= blocknum))  return(FALSE);
X
X	if ((fd = fopen(cipherfile, "r")) == NULL)  {
X		printf("\nCould not open %s to read ciphertext.\n", cipherfile);
X		exit(0);
X		}
X
X	offset = blocknum * BLOCKSIZE;
X	fseek(fd, offset, FROMSTART);
X	res = ftell(fd);
X	if (res != offset) {
X		printf("\nSeek failed on %s to %d, got %d.\n", cipherfile, offset,res);
X		exit(0);
X		}
X
X	if (fread(cbuf,sizeof(*(cbuf)),BLOCKSIZE,fd) != BLOCKSIZE)  {
X		return(FALSE);
X		}
X
X	fclose(fd);
X
X	return(TRUE);
X}
END_OF_cblocks.c
if test 1196 -ne `wc -c <cblocks.c`; then
    echo shar: \"cblocks.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f char-io.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"char-io.c\"
else
echo shar: Extracting \"char-io.c\" \(1265 characters\)
sed "s/^X//" >char-io.c <<'END_OF_char-io.c'
X/*
X * Read and write slashified characters.
X * Translated from Tim Shepard's CLU code. 
X */
X
X#include	<stdio.h>
X
X#define	EOL	(-37)
X
Xwrite_char(out, c)
XFILE	*out;
Xint		c;
X{
X   char	*s;
X   char	buf[6];
X
X   if (c == '\\')
X      {s = "\\\\";}
X   else if (c == '\n')
X      {s = "\\n";}
X   else if (c == '\t')
X      {s = "\\t";}
X   else if (c == '\f')
X      {s = "\\p";}
X   else if (c == '\b')
X      {s = "\\b";}
X   else if (c == '\r')
X      {s = "\\r";}
X   else if (c < ' ' || '~' < c)  {
X      s = buf;
X	  s[0] = '\\';
X	  s[1] = '0' + (c/64);
X	  s[2] = '0' + ((c%64)/8);
X	  s[3] = '0' + (c%8);
X	  s[4] = '\000';
X	  }
X   else  {
X      s = buf;
X	  s[0] = c;
X	  s[1] = '\000';
X      }
X
X   fprintf(out, "%s", s);
X}
X
X
Xint	read_char(inp)
XFILE	*inp;
X{
X   int	c;
X
X   c = getc(inp);
X   if (c == EOF) return(EOF);
X   if (c == '\n') return(EOL);
X   if (c == '\\')  {
X      c = getc(inp);
X	  if (c == EOF) return(EOF);
X      if (c == 'n')
X	     {c = '\n';}
X      else if (c == 't')
X	     {c = '\t';}
X      else if (c == 'p')
X	     {c = '\f';}
X      else if (c == 'b')
X	     {c = '\b';}
X      else if (c == 'r')
X	     {c = '\r';}
X      else if ('0' <= c  &&  c <= '7')  {
X	     c = 64*(c - '0');
X		 c = c + 8*(getc(inp)-'0');
X		 c = c + 1*(getc(inp)-'0');
X		 }
X   }
X   return(c);
X}
END_OF_char-io.c
if test 1265 -ne `wc -c <char-io.c`; then
    echo shar: \"char-io.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f common.words -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"common.words\"
else
echo shar: Extracting \"common.words\" \(259 characters\)
sed "s/^X//" >common.words <<'END_OF_common.words'
X the 
X The 
X\nThe 
X.  The 
X with 
X that 
X then 
X when 
X than 
X when 
X\nWhen 
X When 
X\nWhat 
X What 
X what 
X from 
X\nFor 
X.  For
X for 
X but 
X and 
X not 
X are 
X may 
X will 
X have 
X has 
X been 
X each 
X only 
X also 
X more 
X both 
X one 
X two 
Xwould 
Xcould 
Xshould 
END_OF_common.words
if test 259 -ne `wc -c <common.words`; then
    echo shar: \"common.words\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f dblock.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"dblock.h\"
else
echo shar: Extracting \"dblock.h\" \(667 characters\)
sed "s/^X//" >dblock.h <<'END_OF_dblock.h'
Xextern	int	dbsrc2pos();
Xextern	int	dbsp2row();
Xextern	int	dbsp2col();
Xextern	int	dbsdpchar();
X
X
X
X#define dbsinfo	struct xdbsinfo
Xstruct	xdbsinfo	{
X		char	*cbuf;		/* Ciphertext block. */
X		int		*pbuf;		/* Plaintext block. */
X		int		*perm;		/* Partial permutation, -1 -> none known. */
X		char	*mbuf;		/* Bools for which chars are marked. */
X		int		wirecnt;	/* Number of known wires in perm. */
X		int		cmdloc;		/* Position in pbuf where cmd started. */
X		int		cmdnext;	/* Index for next char to add to cmdbuf. */
X		int		*cmdbuf;	/* Command from user. */
X		int		*operm;		/* Permutation after last command. */
X		int		blknum;		/* Zero based index of current block. */
X		};
END_OF_dblock.h
if test 667 -ne `wc -c <dblock.h`; then
    echo shar: \"dblock.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f dbsaux.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"dbsaux.c\"
else
echo shar: Extracting \"dbsaux.c\" \(2998 characters\)
sed "s/^X//" >dbsaux.c <<'END_OF_dbsaux.c'
X/*
X * dblock.c takes too long to compile, so this is separate.
X *
X * Robert W. Baldwin, December 1984.
X */
X
X
X#include	<stdio.h>
X#include	"window.h"
X#include	"layout.h"
X#include	"specs.h"
X#include	"pqueue.h"
X#include	"cipher.h"
X
X#include	"dblock.h"
X
X
Xecinfo	t_ecinfo;
X
X
X/* Try all the possible characters at the current position.
X * Display those that do not generate any conflicts.
X */
Xdbstryall(dbs, k)
Xgwindow	*dbs;
Xkey		k;
X{
X	int		col, pos;
X	int		oldrow, oldcol;
X	int		i;
X	int		tchar;
X	ecinfo	*ecbi;
X	dbsinfo	*dbsi;
X	int		pque_index;
X	pqueue_hdr	pque_hdr;
X	pqueue_ent	the_pque[MAXCHAR+1];
X
X	dbsi = ((dbsinfo *) dbs->wprivate);
X	ecbi = &t_ecinfo;
X
X	pque_init(&pque_hdr, 1000.0, &the_pque[0], MAXCHAR+1);
X	ec_init(dbsi->cbuf, dbsi->perm, ecbi);
X	
X	oldrow = dbs->wcur_row;
X	oldcol = dbs->wcur_col;
X	pos = dbsrc2pos(oldrow, oldcol);
X	dbstrypq(ecbi, &pque_hdr, pos);
X
X	wl_setcur(dbs, dbsp2row(BLOCKSIZE), dbsp2col(BLOCKSIZE));
X
X	tchar = 0;
X	for (col = 1 ; col < dbs->wwidth ; col++)  {
X		pque_index = col - 1;
X		if (pque_index >= pque_hdr.next_index)  break;
X		tchar = the_pque[pque_index].value1;
X		plnchars(1, char2sym(tchar));
X		}
X  alldone:
X	plnchars((dbs->wwidth) - col, ' ');
X	wl_setcur(dbs, oldrow, oldcol);
X}
X
X
X/* Try all chars in position pos.  Added them to a priority queue.
X * The most likely character appears first.
X */
Xdbstrypq(ecbi, pque_hdr, pos)
Xecinfo		*ecbi;
Xpqueue_hdr	*pque_hdr;
Xint			pos;
X{
X	int		plainchar;
X	int		added;
X	float	score;
X	extern	float	score2_scale, score1_scale;
X	float	score1, score2;
X	float	sdev1, sdev2;		/* Standard Deviation for 1st and 2nd stats. */
X	gsinfo	tmpgsi;
X	gsinfo	*gsi;
X	int		gssbuf[BLOCKSIZE+1];
X
X	gsi	= &tmpgsi;
X	gsi_init(gsi, ecbi->plaintext, gssbuf);
X
X	for (plainchar = 0 ; plainchar <= MAXCHAR ; plainchar++)  {
X		gsi_clear(gsi);
X		added = gsi_class_guess(gsi, ecbi, pos, plainchar);
X		if (added > 0) {
X			sdev1 = gsi_1score(gsi);
X			if (sdev1 < 0.0)
X				continue;
X			sdev2 = gsi_2score(gsi);
X			if (sdev2 < 0.0)
X				continue;
X			score = sdev1 + sdev2;
X			pque_add(pque_hdr, score, plainchar, 0);
X			}
X		}
X}
X
X
X/* Word search from dictionary.  Try to find the word at the cursor position.
X * The cursor must be at either the beginning or end of a word as indicated
X * by the cursor being adjacent to a whitespace character.
X * 
X * For now, a pattern is extracted an a word lookup command gets executed.
X * The keystroke argument, k, is not used.
X */
Xdbswrdsrch(dbs, k)
Xgwindow	*dbs;
Xkey		k;
X{
X	int	oldrow, oldcol;		/* To reset cursor pos if needed. */
X	int	pos;			/* Char offset in block. */
X	int	prev_char;
X	ecinfo	*ecbi;
X	dbsinfo	*dbsi;
X	
X	dbsi = ((dbsinfo *) dbs->wprivate);
X	ecbi = &t_ecinfo;
X	ec_init(dbsi->cbuf, dbsi->perm, ecbi);
X	
X	oldrow = dbs->wcur_row;
X	oldcol = dbs->wcur_col;
X	pos = dbsrc2pos(oldrow, oldcol);
X	prev_char = pos > 0 ? dbsi->pbuf[pos-1] : NONE;
X	if (isletter(prev_char)) {
X		usrstatus(&user,
X		   "Word Search: Cursor must be start of a word.");
X		return;
X		}
X
X/*	websearch(&webster, ecbi, pos, TRUE); */
X	return;
X}
END_OF_dbsaux.c
if test 2998 -ne `wc -c <dbsaux.c`; then
    echo shar: \"dbsaux.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f enigma.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"enigma.c\"
else
echo shar: Extracting \"enigma.c\" \(2225 characters\)
sed "s/^X//" >enigma.c <<'END_OF_enigma.c'
Xstatic char *sccsid = "@(#)crypt.c	4.2 (Berkeley) 7/9/81";
X
X/*
X *	A one-rotor machine designed along the lines of Enigma
X *	but considerably trivialized.
X */
X
X#define ECHO 010
X#include <stdio.h>
X#define ROTORSZ 256
X#define MASK 0377
Xchar	t1[ROTORSZ];
Xchar	t2[ROTORSZ];
Xchar	t3[ROTORSZ];
Xchar	deck[ROTORSZ];
Xchar	*getpass();
Xchar	buf[13];
X
Xsetup(pw)
Xchar *pw;
X{
X	int ic, i, k, temp, pf[2];
X	unsigned random;
X	long seed;
X
X	strncpy(buf, pw, 8);
X	while (*pw)
X		*pw++ = '\0';
X	buf[8] = buf[0];
X	buf[9] = buf[1];
X	pipe(pf);
X	if (fork()==0) {
X		close(0);
X		close(1);
X		dup(pf[0]);
X		dup(pf[1]);
X		execl("/usr/lib/makekey", "-", 0);
X		execl("/lib/makekey", "-", 0);
X		exit(1);
X	}
X	write(pf[1], buf, 10);
X	wait((int *)NULL);
X	if (read(pf[0], buf, 13) != 13) {
X		fprintf(stderr, "crypt: cannot generate key\n");
X		exit(1);
X	}
X	seed = 123;
X	for (i=0; i<13; i++)
X		seed = seed*buf[i] + i;
X	for(i=0;i<ROTORSZ;i++) {
X		t1[i] = i;
X		deck[i] = i;
X	}
X	for(i=0;i<ROTORSZ;i++) {
X		seed = 5*seed + buf[i%13];
X		random = seed % 65521;
X		k = ROTORSZ-1 - i;
X		ic = (random&MASK)%(k+1);
X		random >>= 8;
X		temp = t1[k];
X		t1[k] = t1[ic];
X		t1[ic] = temp;
X		if(t3[k]!=0) continue;
X		ic = (random&MASK) % k;
X		while(t3[ic]!=0) ic = (ic+1) % k;
X		t3[k] = ic;
X		t3[ic] = k;
X	}
X	for(i=0;i<ROTORSZ;i++)
X		t2[t1[i]&MASK] = i;
X}
X
Xmain(argc, argv)
Xchar *argv[];
X{
X	register i, n1, n2, nr1, nr2;
X	int secureflg = 0;
X
X	if (argc > 1 && argv[1][0] == '-' && argv[1][1] == 's') {
X		argc--;
X		argv++;
X		secureflg = 1;
X	}
X	if (argc != 2){
X		setup(getpass("Enter key:"));
X	}
X	else
X		setup(argv[1]);
X	n1 = 0;
X	n2 = 0;
X	nr2 = 0;
X
X	while((i=getchar()) >=0) {
X		if (secureflg) {
X			nr1 = deck[n1]&MASK;
X			nr2 = deck[nr1]&MASK;
X		} else {
X			nr1 = n1;
X		}
X		i = t2[(t3[(t1[(i+nr1)&MASK]+nr2)&MASK]-nr2)&MASK]-nr1;
X		putchar(i);
X		n1++;
X		if(n1==ROTORSZ) {
X			n1 = 0;
X			n2++;
X			if(n2==ROTORSZ) n2 = 0;
X			if (secureflg) {
X				shuffle(deck);
X			} else {
X				nr2 = n2;
X			}
X		}
X	}
X}
X
Xshuffle(deck)
X	char deck[];
X{
X	int i, ic, k, temp;
X	unsigned random;
X	static long seed = 123;
X
X	for(i=0;i<ROTORSZ;i++) {
X		seed = 5*seed + buf[i%13];
X		random = seed % 65521;
X		k = ROTORSZ-1 - i;
X		ic = (random&MASK)%(k+1);
X		temp = deck[k];
X		deck[k] = deck[ic];
X		deck[ic] = temp;
X	}
X}
END_OF_enigma.c
if test 2225 -ne `wc -c <enigma.c`; then
    echo shar: \"enigma.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f h19.slice -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"h19.slice\"
else
echo shar: Extracting \"h19.slice\" \(1164 characters\)
sed "s/^X//" >h19.slice <<'END_OF_h19.slice'
X# For GRAPHICSMAP, the first char must be one of the following:
X# \G - graphics mode
X# \N - normal mode
X# \S - standout (inverse) mode
X# The remaining positions use the regular slash codes.
X#
Xsetenv GRAPHICSMAP	'tb=\Gh:lf=\Gk:cr=\Gg:na=\Gi:\
X			ff=\G~:cc=\Gw:uk=\G^:ul=\Gz:\
X			vb=\G'\`':hb=\Ga:ll=\Ge'
X
X# For KEYMAP, the symbol \E is the same as \033 (escape), it can
X# appear anywhere in the value fields.
X# Info in KEYMAP superceeds info in the TERMCAP file/variable.
X#
X#setenv KEYMAP \
X#'pr=\ES:ne=\033T:ac=\033U:jc=\033V:up=\EA:do=\EB:ri=\EC:le=\ED:'
X
X
X# Here is a full termcap entry for the heath.
X# The original was missing ks and ke.
X#
Xsetenv TERMCAP \
X'kb|h19|heath|h19-b|h19b|heathkit|heath-19|z19|zenith|heathkit h19:\
X	:cr=^M:nl=^J:bl=^G:\
X	:al=1*\EL:am:le=^H:bs:cd=\EJ:ce=\EK:cl=\EE:cm=\EY%+ %+ :co#80:dc=\EN:\
X	:dl=1*\EM:do=\EB:ei=\EO:ho=\EH:im=\E@:li#24:mi:nd=\EC:as=\EF:ae=\EG:\
X	:ms:ta=^I:pt:sr=\EI:se=\Eq:so=\Ep:up=\EA:vs=\Ex4:ve=\Ey4:\
X	:kb=^h:ku=\EA:kd=\EB:kl=\ED:kr=\EC:kh=\EH:kn#8:\
X	:k1=\ES:k2=\ET:k3=\EU:k4=\EV:k5=\EW:\
X	:l6=blue:l7=red:l8=white:k6=\EP:k7=\EQ:k8=\ER:\
X	:es:hs:ts=\Ej\Ex5\Ex1\EY8%+ \Eo:fs=\Ek\Ey5:ds=\Ey1:\
X	:ks=\Et:ke=\Eu'
END_OF_h19.slice
if test 1164 -ne `wc -c <h19.slice`; then
    echo shar: \"h19.slice\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f keylib.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"keylib.c\"
else
echo shar: Extracting \"keylib.c\" \(1944 characters\)
sed "s/^X//" >keylib.c <<'END_OF_keylib.c'
X/*
X * Library of keystroke handling routines.
X *
X * Robert W. Baldwin,  December 1984.
X */
X
X#include	<stdio.h>
X#include	"window.h"
X#include	"terminal.h"
X#include	"specs.h"
X
X
X/* Keystroke table for default arrow key functionality.
X * Used by the windows that don't accept keystroke commands.
X */
Xkeyer	arwktab[]	=	{
X		{CGO_UP, jogup},
X		{CGO_DOWN, jogdown},
X		{CGO_LEFT, jogleft},
X		{CGO_RIGHT, jogright},
X		{0, NULL},
X};
X
X
X
X/* The following routines move the cursor.
X * If the cursor is still in the window, they update the
X * cursor location in the window's data structure.
X */
Xjogup(w,k)
Xgwindow	*w;
Xkey		k;
X{
X	if (w->wcur_row > 1) {
X		w->wcur_row--;
X		}
X	jogcursor(1);
X}
X
Xjogdown(w,k)
Xgwindow	*w;
Xkey		k;
X{
X	if (w->wcur_row < w->wheight) {
X		w->wcur_row++;
X		}
X	jogcursor(2);
X}
X
Xjogleft(w,k)
Xgwindow	*w;
Xkey		k;
X{
X	if (w->wcur_col > 1) {
X		w->wcur_col--;
X		}
X	jogcursor(3);
X}
X
Xjogright(w,k)
Xgwindow	*w;
Xkey		k;
X{
X	if (w->wcur_col < w->wwidth) {
X		w->wcur_col++;
X		}
X	jogcursor(4);
X}
X
X
X
X/* ddokey is the lookup routine for interpreting keys.
X * It searches a table of keyer entries for one that matches the
X * given key.  If a match is found, it calls the corresponding
X * routine and returns TRUE.  Otherwise returns FALSE.
X * The end of the table is marked by an entry with a keychar = 0 or -1.
X * If it is -1, the proc in that entry will be called with the key,
X * and TRUE is returned.  If it is 0, the no-match status is returned.
X */
Xint ddokey(w, k, ktab)
Xgwindow	*w;		/* Window */
Xkey	k;		/* Key to handle */
Xkeyer	*ktab;		/* Table of handling procedures */
X{
X	int	cmd;
X
X	cmd = (k >> CMDSHIFT) & CMDMASK;
X	for ( ; ktab->keychar != 0 ; ktab++ )  {
X		if (ktab->keychar == cmd  ||  ktab->keychar == -1)  {
X			(*(ktab->keyproc))(w, (k & CHARM));
X			return(TRUE);
X			}
X		}
X
X	return(FALSE);
X}
X
X
X
X/* Lookup and call a keyproc in the window's key handling table.
X */
Xdokey(w, k)
Xgwindow		*w;
Xkey			k;
X{
X	return(ddokey(w, k, w->wkeyprocs));
X}
END_OF_keylib.c
if test 1944 -ne `wc -c <keylib.c`; then
    echo shar: \"keylib.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f layout.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"layout.h\"
else
echo shar: Extracting \"layout.h\" \(1450 characters\)
sed "s/^X//" >layout.h <<'END_OF_layout.h'
X/*
X * Constants that define the layout of the screen.
X *
X * Robert W. Baldwin, December 1984.
X */
X
X
X
X/* Parameter for the screen layout. */
X
X#define	WINDNUM		7				/* Number of windows at top level. */
X
X#define	BANLM		21				/* Left margin of banner text. */
X#define	BANTEXT		"Crypt Breaker's Workbench"
X
X#define	DBLROW		2				/* Starting row of label. */
X#define	DBLCOL		9				/* Column where block number starts. */
X#define	DBSROW		(DBLROW+1)		/* Decryption Block. */
X#define	DBWIDTH		65				/* Decrypted block. */
X#define	DBHEIGHT	11				/* Decrytped block, not incl label. */
X#define	DBLTEXT		"Block -"		/* Label for decrypted block. */
X
X#define GBLROW		(DBSROW+DBHEIGHT)	/* Guess block label row. */
X#define	GBSROW		(GBLROW+1)		/* Guess block storage row. */
X#define	GBWIDTH		DBWIDTH			/* Width of same. */
X#define GBHEIGHT	6				/* Height of same. */
X#define	GBLTEXT		"Guess Window"	/* Label for guess block. */
X
X#define	WEBROW		DBLROW			/* Starting row of history */
X#define	WEBCOL		(DBWIDTH+1)		/* Starting column */
X#define	WEBWIDTH	(MAXWIDTH-DBWIDTH)		/* Decision history. */
X#define	WEBHEIGHT	(DBHEIGHT+GBHEIGHT+2)	/* Includes a title line. */
X
X#define USRROW		(GBSROW+GBHEIGHT)	/* User I/O area. */
X#define USRSCOL		10				/* Starting column of status msgs. */
X#define USRHEIGHT	(MAXHEIGHT-(GBHEIGHT+1)-(DBHEIGHT+1)-(1))
X/* total - guess block and title - decrypt block and title - banner */
X#define USRWIDTH	MAXWIDTH		/* Width of I/O window. */
END_OF_layout.h
if test 1450 -ne `wc -c <layout.h`; then
    echo shar: \"layout.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mss-prob-printout.txt -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mss-prob-printout.txt\"
else
echo shar: Extracting \"mss-prob-printout.txt\" \(2266 characters\)
sed "s/^X//" >mss-prob-printout.txt <<'END_OF_mss-prob-printout.txt'
Xsingle letter frequencies
X
XExpected value of prob is 0.313350.  Variance is 0.156338.
X
X 0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000 
X 0.0000  0.2167  0.2167  0.0000  0.2167  0.2167  0.0000  0.0000 
X 0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000 
X 0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000 
X 0.2167  0.0140  0.0040  0.0034  0.0034  0.0034  0.0034  0.0040 
X 0.0032  0.0052  0.0034  0.0034  0.0140  0.0103  0.0140  0.0004 
X 0.0342  0.0342  0.0342  0.0342  0.0342  0.0342  0.0342  0.0342 
X 0.0342  0.0342  0.0140  0.0140  0.0032  0.0034  0.0052  0.0140 
X 0.0034  0.0558  0.0127  0.0239  0.0270  0.0904  0.0136  0.0166 
X 0.0342  0.0496  0.0013  0.0039  0.0324  0.0195  0.0456  0.0526 
X 0.0162  0.0008  0.0423  0.0480  0.0652  0.0210  0.0073  0.0133 
X 0.0027  0.0119  0.0007  0.0032  0.0004  0.0052  0.0034  0.0103 
X 0.0040  0.0558  0.0127  0.0239  0.0270  0.0904  0.0136  0.0166 
X 0.0342  0.0496  0.0013  0.0039  0.0324  0.0195  0.0456  0.0526 
X 0.0162  0.0008  0.0423  0.0480  0.0652  0.0210  0.0073  0.0133 
X 0.0027  0.0119  0.0007  0.0032  0.0034  0.0052  0.0034  0.0000 
X
XExpected value of logprob is -3.623789.  Variance is 18.575068.
XLog of single letter frequencies
X
X-4.7974 -4.7974 -4.7974 -4.7974 -4.7974 -4.7974 -4.7974 -4.7974 
X-4.7974 -0.6641 -0.6641  0.0000 -0.6641 -0.6641 -4.7974 -4.7974 
X-4.7974 -4.7974 -4.7974 -4.7974 -4.7974 -4.7974 -4.7974 -4.7974 
X-4.7974 -4.7974 -4.7974 -4.7974 -4.7974 -4.7974 -4.7974 -4.7974 
X-0.6641 -1.8534 -2.4012 -2.4690 -2.4690 -2.4690 -2.4690 -2.4012 
X-2.4899 -2.2815 -2.4690 -2.4690 -1.8534 -1.9865 -1.8534 -3.4550 
X-1.4664 -1.4664 -1.4664 -1.4664 -1.4664 -1.4664 -1.4664 -1.4664 
X-1.4664 -1.4664 -1.8534 -1.8534 -2.4899 -2.4690 -2.2815 -1.8534 
X-2.4690 -1.2536 -1.8970 -1.6219 -1.5682 -1.0437 -1.8680 -1.7800 
X-1.4662 -1.3041 -2.8783 -2.4065 -1.4891 -1.7100 -1.3410 -1.2786 
X-1.7892 -3.1162 -1.3733 -1.3191 -1.1855 -1.6768 -2.1384 -1.8768 
X-2.5747 -1.9247 -3.1442 -2.4899 -3.4550 -2.2815 -2.4690 -1.9865 
X-2.4012 -1.2536 -1.8970 -1.6219 -1.5682 -1.0437 -1.8680 -1.7800 
X-1.4662 -1.3041 -2.8783 -2.4065 -1.4891 -1.7100 -1.3410 -1.2786 
X-1.7892 -3.1162 -1.3733 -1.3191 -1.1855 -1.6768 -2.1384 -1.8768 
X-2.5747 -1.9247 -3.1442 -2.4899 -2.4690 -2.2815 -2.4690 -4.7974 
END_OF_mss-prob-printout.txt
if test 2266 -ne `wc -c <mss-prob-printout.txt`; then
    echo shar: \"mss-prob-printout.txt\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mss.stats -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mss.stats\"
else
echo shar: Extracting \"mss.stats\" \(812 characters\)
sed "s/^X//" >mss.stats <<'END_OF_mss.stats'
X211123
X
X45 \000
X0 \001
X0 \002
X0 \003
X0 \004
X0 \005
X0 \006
X0 \007
X0 \b
X826 \t
X5539 \n
X0 \013
X0 \p
X0 \r
X0 \016
X0 \017
X0 \020
X0 \021
X0 \022
X0 \023
X0 \024
X0 \025
X0 \026
X0 \027
X0 \030
X0 \031
X0 \032
X0 \033
X0 \034
X0 \035
X0 \036
X0 \037
X36061  
X7 !
X502 "
X46 #
X268 $
X773 %
X31 &
X102 '
X1378 (
X1378 )
X106 *
X65 +
X1585 ,
X519 -
X1980 .
X61 /
X267 0
X551 1
X278 2
X120 3
X136 4
X140 5
X96 6
X65 7
X84 8
X96 9
X594 :
X61 ;
X211 <
X464 =
X204 >
X38 ?
X1785 @
X422 A
X157 B
X222 C
X296 D
X532 E
X190 F
X51 G
X133 H
X406 I
X31 J
X92 K
X228 L
X202 M
X280 N
X178 O
X308 P
X9 Q
X174 R
X417 S
X896 T
X142 U
X37 V
X143 W
X41 X
X91 Y
X2 Z
X738 [
X267 \\
X738 ]
X23 ^
X315 _
X1 `
X10370 a
X2389 b
X4918 c
X5538 d
X19962 e
X3405 f
X2781 g
X5595 h
X10833 i
X214 j
X496 k
X5735 l
X4371 m
X10902 n
X10866 o
X4123 p
X419 q
X9791 r
X9291 s
X13582 t
X4777 u
X1195 v
X1768 w
X824 x
X2453 y
X189 z
X26 {
X39 |
X26 }
X21 ~
X0 \177
X
END_OF_mss.stats
if test 812 -ne `wc -c <mss.stats`; then
    echo shar: \"mss.stats\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mss.words -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mss.words\"
else
echo shar: Extracting \"mss.words\" \(450 characters\)
sed "s/^X//" >mss.words <<'END_OF_mss.words'
X\n@Device
X@Device
X@device
X\n@device
X[Dover]
X[dover]
X(dover)
X\n@Style
X\n@style
X@Make
X@make
X\n@Make
X\n@make
X\n@Section
X\n@section
X\n@Subsection
X\n@SubSection
X\n@subsection
X\n@Center
X\n@center
X\n@Heading
X\n@MajorHeading
X\n@heading
X\n@majorheading
X\n@Begin
X\n@begin
X\n@End
X\n@end
X[Article]
X(Article)
X[Text]
X(Text)
X[article]
X(article)
X[text]
X(text)
Xtimesroman
XTimesRoman
XTimesroman
XHelvetica
Xhelvetica
Xfont
XFont
XIndent
Xindent
Xdouble
Xsingle
XDouble
XSingle
X
END_OF_mss.words
if test 450 -ne `wc -c <mss.words`; then
    echo shar: \"mss.words\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f parser.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"parser.c\"
else
echo shar: Extracting \"parser.c\" \(2096 characters\)
sed "s/^X//" >parser.c <<'END_OF_parser.c'
X/* 
X * Command completion and parsing routines.
X *
X * Robert W. Baldwin, December 1984.
X */
X
X
X#include	<stdio.h>
X#include	"window.h"
X#include	"specs.h"
X#include	"parser.h"
X
X
X/* Return TRUE if the cmdstring equals the model string up to and including
X * the first space.
X */
Xint	cmpword(model, cmdstring)
Xchar	*model, *cmdstring;
X{
X	while (*model != 0  &&  *cmdstring != 0) {
X		if (*model == *cmdstring  &&  *model == ' ')  return (TRUE);
X		if (*model != *cmdstring)  break;
X		model++;
X		cmdstring++;
X		}
X	if (*model == 0)  return(TRUE);
X	return(FALSE);
X}
X
X
X/* Return TRUE if the first word of the cmdstring is a substring
X * of the first word of model string.
X */
Xint	submatch(model, cmdstring)
Xchar	*model;
Xchar	*cmdstring;
X{
X	while (*model != 0  &&  *cmdstring != 0) {
X		if (*cmdstring == ' ')  break;
X		if (*model != *cmdstring)  return(FALSE);
X		if (*model == ' ')  break;
X		model++;
X		cmdstring++;
X		}
X
X	return(TRUE);
X}
X
X
X
X/* Lookup and perform a command from a command table.
X * If not found, return an error message.
X */
Xchar	*cmddo(cmdtab, cmdstring)
Xcmdent	*cmdtab;
Xchar	*cmdstring;
X{
X	for ( ; cmdtab->cmdname != 0 ; cmdtab++)  {
X		if (cmpword(cmdtab->cmdname, cmdstring))  {
X			return((*(cmdtab->cmdproc))(cmdstring));
X			}
X		}
X
X	return(CMDBAD);
X}
X
X
X
X/* Do automatic completion of the string based on the
X * command choices in the command table.
X * Be careful to avoid doubly expanding a string, by requiring that
X * the first few characters to match, but the whole word must not match.
X * If sucessful, return a pointer to the template string
X * in the command table.  Otherwise return NULL.
X */
Xchar	*cmdcomplete(cmdtab, cmdstring)
Xcmdent	*cmdtab;
Xchar	*cmdstring;
X{
X	cmdent	*centp;
X	char	*close;
X
X	for (centp = cmdtab ; centp->cmdname != 0 ; centp++)  {
X		if (cmpword(centp->cmdname, cmdstring))  {
X			return(NULL);	/* Has been expanded. */
X			}
X		}
X
X	close = NULL;
X	for (centp = cmdtab ; centp->cmdname != 0 ; centp++)  {
X		if (submatch(centp->cmdname, cmdstring))  {
X			if (close != NULL)  return(NULL);	/* Not yet unique. */
X			close = centp->cmdname;
X			}
X		}
X
X	return(close);
X}
END_OF_parser.c
if test 2096 -ne `wc -c <parser.c`; then
    echo shar: \"parser.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f parser.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"parser.h\"
else
echo shar: Extracting \"parser.h\" \(809 characters\)
sed "s/^X//" >parser.h <<'END_OF_parser.h'
X/*
X * Header for command parsing and completing routines.
X *
X * Robert W. Baldwin, December 1984.
X */
X
X
X
X#define	CMDBAD	"I don't know how to do that."
X
X
X/* A command table is an array of cmdent's terminated by a
X * cmdent that has a cmdname = NULL.
X * The command name can contain helpful noise words since
X * the comparision is only done on characters upto the first space.
X * The cmdproc is passed the full command string (including cmd name),
X * and returns a pointer to a status message.  The return pointer should
X * be NULL is everything goes ok.
X *
X * The command table should have atleast two non-empty entries for completion
X * to work properly.
X */
X
X#define	cmdent	struct xcmdent
X
Xstruct	xcmdent	{
X		char	*cmdname;	/* Comparison done up to first blank. */
X		char	*(*cmdproc)(/* cmd-string */);
X		};
END_OF_parser.h
if test 809 -ne `wc -c <parser.h`; then
    echo shar: \"parser.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pgate.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pgate.c\"
else
echo shar: Extracting \"pgate.c\" \(1250 characters\)
sed "s/^X//" >pgate.c <<'END_OF_pgate.c'
X/*
X * Routines to use knowledge of Zee to expand knowledge of Perms.
X *
X * Bob Baldwin, January 1985.
X */
X
X
X#include	<stdio.h>
X#include	"window.h"
X#include	"specs.h"
X
X
Xextern	int	kzee[];
Xextern	int	kzeeinv[];
X
X
X/* User command to propage info from Ai to Aj using Zee**(j-i).
X * Returns NULL if sucessful.
X */
Xchar *pgate(str)
Xchar	*str;
X{
X	FILE	*fd;
X	int		i;
X	int		k;
X	int		from, to;
X	int		*zeek, *zeeinvk;	/* Zee ** k */
X	int		*fromperm, *tmp1perm, *tmp2perm;
X	int		kexp[BLOCKSIZE+1], kexpinv[BLOCKSIZE+1];
X	int		ktmp1perm[BLOCKSIZE+1];
X	int		ktmp2perm[BLOCKSIZE+1];
X
X	tmp1perm = ktmp1perm;
X	tmp2perm = ktmp2perm;
X	zeek = kexp;
X	zeeinvk = kexpinv;
X	from = to = 0;
X
X	if ((i = sscanf(str,"%*[^:]: %d %*[^:]: %d", &from, &to)) != 2) {
X		return("Could not parse all the arguments.");
X		}
X
X	if (dbsgetblk(&dbstore) != to)
X		dbssetblk(&dbstore, to);
X
X	k = to - from;
X	if (k >= 0) {
X		expperm(kzee, zeek, k);
X		expperm(kzeeinv, zeeinvk, k);
X		}
X	else {
X		expperm(kzee, zeeinvk, -k);
X		expperm(kzeeinv, zeek, -k);
X		}
X
X	multperm(refperm(from), zeek, tmp1perm);
X	multperm(zeeinvk, tmp1perm, tmp2perm);
X
X	if (!dbsmerge(&dbstore, tmp2perm))  {
X		wl_rcursor(&user);
X		return("Merge conflicts with current plaintext.");
X		}
X
X	wl_rcursor(&user);
X	return(NULL);
X}
END_OF_pgate.c
if test 1250 -ne `wc -c <pgate.c`; then
    echo shar: \"pgate.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pqueue.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pqueue.c\"
else
echo shar: Extracting \"pqueue.c\" \(1661 characters\)
sed "s/^X//" >pqueue.c <<'END_OF_pqueue.c'
X/*
X * Priority queue.
X *
X * Bob Baldwin, February, 1985.
X */
X
X#include	<stdio.h>
X#include	"pqueue.h"
X
X
X
X/* Initialize a pqueue header with the given parameters.
X */
Xpque_init(pque_hdr, max_score, pque_tab, pque_size)
Xpqueue_hdr	*pque_hdr;
Xfloat		max_score;
Xpqueue_ent	*pque_tab;
Xint			pque_size;
X{
X	pque_hdr->next_index = 0;
X	pque_hdr->pque_size = pque_size;
X	pque_hdr->max_score = max_score;
X	pque_hdr->pque_tab = pque_tab;
X}
X
X
X/* Return TRUE if the pqueue cannot hold another entry.
X */
Xint	pque_full(pque_hdr)
Xpqueue_hdr	*pque_hdr;
X{
X	return (pque_hdr->next_index >= pque_hdr->pque_size);
X}
X
X
X/* Add an entry to the priority queue.  Sorted lowest score first.
X * The queue header indicates the next free slot, the maximum
X * score (all scores in queue < max), and the size of the table.
X * If the pqueue is full the lowest scoring entry will be
X * thrown out.
X *
X * Implementation:  Find the first slot before sizelast+1 that
X * has a size less than the size arg.  Shuffle down the list
X * to create a hole and insert the new entry.
X */
Xpque_add(pque_hdr, score, value1, value2)
Xpqueue_hdr	*pque_hdr;
Xfloat		score;
Xint			value1;
Xint			value2;
X{
X	int			k;		/* Slot where new entry will go. */
X	int			i;
X	pqueue_ent	*pque;
X	pqueue_ent	new_ent;
X
X	if (score >= pque_hdr->max_score)  return;
X
X	new_ent.score = score;
X	new_ent.value1 = value1;
X	new_ent.value2 = value2;
X	pque = pque_hdr->pque_tab;
X
X	for (k = 0 ; k < pque_hdr->next_index ; k++)  {
X		if (pque[k].score > score)  break;
X		}
X
X	for (i = pque_hdr->next_index ; i > k ; i--)  {
X		pque[i] = pque[i-1];
X		}
X	if (pque_hdr->next_index < pque_hdr->pque_size)
X		pque_hdr->next_index++;
X
X	pque[k] = new_ent;
X}
END_OF_pqueue.c
if test 1661 -ne `wc -c <pqueue.c`; then
    echo shar: \"pqueue.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pqueue.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pqueue.h\"
else
echo shar: Extracting \"pqueue.h\" \(555 characters\)
sed "s/^X//" >pqueue.h <<'END_OF_pqueue.h'
X/*
X * Priority queue declarations.
X *
X * Bob Baldwin, February, 1985.
X */
X
Xextern	int		pque_full(/* pque_hdr */);
Xextern			pque_add(/* pque_hdr */);
Xextern			pque_init(/* pque_hdr, min_score, pque_tab, pque_size */);
X
X#define	pqueue_ent	struct xpqueue_ent
Xpqueue_ent	{
X		float	score;
X		int		value1;
X		int		value2;
X		};
X
X#define	pqueue_hdr	struct xpqueue_hdr
Xpqueue_hdr	{
X		int			next_index;		/* Next free entry. */
X		int			pque_size;		/* Number of entries. */
X		float		max_score;		/* Score < max */
X		pqueue_ent	*pque_tab;		/* Ptr to first entry. */
X		};
END_OF_pqueue.h
if test 555 -ne `wc -c <pqueue.h`; then
    echo shar: \"pqueue.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f sdriver.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"sdriver.c\"
else
echo shar: Extracting \"sdriver.c\" \(2099 characters\)
sed "s/^X//" >sdriver.c <<'END_OF_sdriver.c'
X/*
X * Test driver for scoring stuff
X */
X
X#include	<stdio.h>
X#include	<math.h>
X#include	"window.h"
X#include	"specs.h"
X#include	"cipher.h"
X
X
Xextern	str2gsi();
X
Xgsinfo	mygsi;
Xint		kwnbuf[100], gssbuf[100];
X
X/* Test routine for statistics. */
Xmain(argc, argv)
Xint		argc;
Xchar	*argv[];
X{
X	char	*p;
X	int		c, i;
X	float	h;
X	char	plainbuf[BLOCKSIZE+1];
X	int		pvec[BLOCKSIZE+1];
X	float	pscore, fscore;
X	int		length;
X	gsinfo	*gsi;
X	char	str[100];
X
X	printf("\nStatistics Test driver.  Type a line to see its score.\n\n");
X
X	load_1stats_from("mss.stats");
X	load_2stats_from("mss-bigram.stats");
X
X	gsi = &mygsi;
X	gsi->cknown = kwnbuf;
X	gsi->cguessed = gssbuf;
X
X	while (TRUE) {
X		length = 0;
X		for (p = plainbuf ; (c=read_char(stdin)) != EOL ; *p++ = c )  {
X			length++;
X			}
X		*p = NULL;
X
X		stripdots(plainbuf, str);
X		str2pvec(str, pvec);
X		pscore = pvec_1score(pvec);
X		printf("pvec_1score is %5.3f", pscore);
X/*
X		pscore = var_1score(pvec);
X		printf("var_1score is %5.3f", pscore);
X
X		pscore = prob_1score(pvec);
X		printf(", and prob_1score is %.3e", pscore);
X*/
X
X		str2gsi(plainbuf, gsi);
X		pscore = gsi_score(gsi);
X		printf(", and gsi_score is %5.3f", pscore);
X
X		printf("\n");
X		}
X}
X
X
X/* Fill in guess info block from string.  Treat all chars as
X * consecutive, except "." means unknown.
X */
Xstr2gsi(str, gsi)
Xchar	*str;
Xgsinfo	*gsi;
X{
X	int		cpos_index, guessed_index;
X
X	cpos_index = 0;
X	guessed_index = 0;
X	while (*str != NULL)  {
X		if (*str == '.')  {
X			(gsi->cguessed)[guessed_index] = NONE;
X			}
X		else {
X			gsi->cpos[cpos_index] = guessed_index;
X			cpos_index++;
X			(gsi->cguessed)[guessed_index] = 0377 & (*str);
X			}
X		(gsi->cknown)[guessed_index] = NONE;
X		guessed_index++;
X		str++;
X		}
X	gsi->cpos[cpos_index] = NONE;
X	(gsi->cknown)[guessed_index] = NONE;
X	(gsi->cguessed)[guessed_index] = NONE;
X}
X
X/* Copy in to out deleting the character "."
X */
Xstripdots(in, out)
Xchar	*in, *out;		/* Null terminated strings. */
X{
X	while (*in != NULL)  {
X		if (*in != '.')
X			*out++ = *in++;
X		else
X			in++;
X		}
X	*out = NULL;
X}
X
X
Xkey	u_getkey()
X{
X}
X
Xkeyer	topktab[] ={{0, NULL}};
X
X
Xchar	*quitcmd()
X{
X	exit(0);
X}
END_OF_sdriver.c
if test 2099 -ne `wc -c <sdriver.c`; then
    echo shar: \"sdriver.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f short.words -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"short.words\"
else
echo shar: Extracting \"short.words\" \(65 characters\)
sed "s/^X//" >short.words <<'END_OF_short.words'
X an 
X on 
X of 
X if 
X is 
X in 
X it 
X at 
X as 
X to 
X so 
X by 
X be 
END_OF_short.words
if test 65 -ne `wc -c <short.words`; then
    echo shar: \"short.words\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f stats.slice -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"stats.slice\"
else
echo shar: Extracting \"stats.slice\" \(182 characters\)
sed "s/^X//" >stats.slice <<'END_OF_stats.slice'
Xset cbwdir=`pwd`
Xsetenv LETTERSTATS ${cbwdir}/mss.stats
Xsetenv BIGRAMSTATS ${cbwdir}/mss-bigram.stats
Xsetenv TRIGRAMSTATS ${cbwdir}/trigrams.stats
Xsetenv DICTIONARY /usr/dict/words
X
END_OF_stats.slice
if test 182 -ne `wc -c <stats.slice`; then
    echo shar: \"stats.slice\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f test3.words -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"test3.words\"
else
echo shar: Extracting \"test3.words\" \(223 characters\)
sed "s/^X//" >test3.words <<'END_OF_test3.words'
Xbandwidth
Xhome
Xcable
Xpersonal
X personal
X\npersonal
X home or
Xcomputer
X computer
X\ncomputer
Xbusiness
X business
X\nbusiness
Xcommunication
X communication
X\ncommunication
XLAN
X LAN
X\nLAN
Xfiber
X fiber
X\nfiber
Xoptic
X optic
X\noptic
X
END_OF_test3.words
if test 223 -ne `wc -c <test3.words`; then
    echo shar: \"test3.words\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f trigrams.short -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"trigrams.short\"
else
echo shar: Extracting \"trigrams.short\" \(171 characters\)
sed "s/^X//" >trigrams.short <<'END_OF_trigrams.short'
X100362
X
X1532	the
X 500	The
X 747	ing
X 667	and
X 547	her
X 448	ere
X 376	ent
X 353	tha
X 336	was
X 312	eth
X 306	for
X 298	hat
X 281	she
X 227	ion
X 274	int
X 264	his
X 252	ers
X 190	ure
X
END_OF_trigrams.short
if test 171 -ne `wc -c <trigrams.short`; then
    echo shar: \"trigrams.short\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f trigrams.stats -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"trigrams.stats\"
else
echo shar: Extracting \"trigrams.stats\" \(548 characters\)
sed "s/^X//" >trigrams.stats <<'END_OF_trigrams.stats'
X62721
X
X1377	   
X1098	 th
X607	the
X300 The
X699	he 
X473	.  
X357	to 
X344	 to
X338	 of
X332	of 
X338	ing
X307	 an
X305	is 
X299	ed 
X288	  t
X257	and
X247	ng 
X222	 a 
X211	 in
X210	 is
X204	er 
X204	re 
X191	es 
X186	ion
X178	at 
X173	 be
X169	s. 
X168	tio
X157	 wh
X155	ent
X153	hat
X150	con
X144	 re
X143	se 
X138	or 
X137	as 
X132	en 
X131	on 
X128	tha
X128	in 
X126	ly 
X124	thi
X119	for
X119	 pr
X117	ate
X117	her
X117	 ar
X117	are
X115	ch 
X115	\n\n@
X114	 so
X115	 fo
X113	pro
X112	lay
X112	all
X111	 wi
X109	ati
X109	le 
X108	al 
X108	 ha
X107	ver
X105	 we
X104	 la
X104	age
X102	an 
X102	his
X101	ere
X
END_OF_trigrams.stats
if test 548 -ne `wc -c <trigrams.stats`; then
    echo shar: \"trigrams.stats\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f tritab.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"tritab.c\"
else
echo shar: Extracting \"tritab.c\" \(3020 characters\)
sed "s/^X//" >tritab.c <<'END_OF_tritab.c'
X/*
X * Operations to load and print the table of trigrams.
X */
X
X#include	<math.h>
X#include	<stdio.h>
X#include	"window.h"
X#include	"specs.h"
X#include	"cipher.h"
X#include	"autotri.h"
X
X
X
X#define	DEFAULTTRIGLIST	"trigrams.txt"
Xint		trig_loaded = FALSE;
X
X/* This number is the probability that a randomly selected trigram
X * is not in the table of trigrams.
X */
Xfloat	trig_other_prob;
X
X
X/* Table of trigrams with their probabilities.
X * The last entry has trig_ent.trigram == NULL.
X * This table is also be used as a priority queue.
X */
Xint			trig_tab_next;			/* For priority queue. */
Xtrig_ent	trig_tab[TRIGTABSZ];
X
X
X
X/* The following buffer is used to store all the trigram
X * strings read from the file.
X * trig_buf_next points to the net free character.
X */
Xchar	*trig_buf_next;
Xchar	trig_buf[TRIGBUFSZ];
X
X
X
X/* Load the trigram table from the named file.
X */
Xload_tri_from(filename)
Xchar	*filename;
X{
X	FILE	*inp;
X
X	if ((inp = fopen(filename, "r")) == NULL)  {
X		printf("\nCannot open %s to read trigram stats.\n", filename);
X		exit(0);
X		}
X	load_tri(inp);
X	fclose(inp);
X}
X
X
X/* Load trigram table from the given stream.
X * Input format:
X * <Total number of trigrams>
X * <blank line>
X * <Count for a particular trigram><space><Chars in the particular trigram>
X * ...
X * <Count for a particular trigram><space><Chars in the particular trigram>
X * <blank line>
X * <End of file>
X */
Xload_tri(inp)
XFILE	*inp;
X{
X	int		i,n;
X	int		tmp;
X	int		c;
X	float	v, trigram_prob;
X	float	etotal, ctotal;
X	char	*trigram_start;
X
X	trig_loaded = TRUE;
X	trig_tab_next = 0;
X	trig_buf_next = trig_buf;
X	trig_other_prob = 1.0;
X	trig_tab[0].trigram = NULL;
X
X	if (fscanf(inp, "%d", &tmp) != 1)  {
X		printf("\nError while getting total trigram count.\n");
X		exit(0);
X		}
X	etotal = tmp;
X	ctotal = 0.0;
X
X	if (fscanf(inp, "\n") != 0)  {
X		printf("\nError while skipping blank line in trigram file.\n");
X		return;
X		}
X
X	while (TRUE) {
X		if ((n = fscanf(inp, "%d", &tmp)) != 1)  {
X			if (n == 0) break;
X			if (n == EOF) break;
X			printf("\nError getting character count from trigram file.\n ");
X			return;
X			}
X		v = tmp;
X		ctotal += v;
X		trigram_prob = v/etotal;
X		trig_other_prob -= trigram_prob;
X
X		c = read_char(inp);		/* Skip the space. */
X		trigram_start = trig_buf_next;
X		while (TRUE) {
X			c = read_char(inp);
X			if (c == EOL)  break;
X			if (trig_buf_next >= &trig_buf[TRIGBUFSZ-1]) {
X				printf("\nOverflowed Trigram buffer.\n");
X				exit(0);
X				}
X			*trig_buf_next++ = c & CHARMASK;
X			}
X		if (trig_buf_next >= &trig_buf[TRIGBUFSZ-1]) {
X			printf("\nOverflowed Trigram buffer.\n");
X			exit(0);
X			}
X		*trig_buf_next++ = NULL;
X
X		trig_tab[trig_tab_next].prob = trigram_prob;
X		trig_tab[trig_tab_next].trigram = trigram_start;
X		trig_tab[trig_tab_next].notused = 0;
X		trig_tab_next++;
X		}
X
X}
X
X
X/* Print the trigram table onto a stream.
X */
Xprint_tri(out)
XFILE	*out;
X{
X	int		i;
X
X	fprintf(out, "\n");
X	for (i = 0 ; trig_tab[i].trigram != NULL ; i++)  {
X		fprintf(out, "'%s'\t%7.4f\n", trig_tab[i].trigram, trig_tab[i].prob);
X		}
X	fprintf(out, "\n");
X}
END_OF_tritab.c
if test 3020 -ne `wc -c <tritab.c`; then
    echo shar: \"tritab.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f vt100.slice -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"vt100.slice\"
else
echo shar: Extracting \"vt100.slice\" \(947 characters\)
sed "s/^X//" >vt100.slice <<'END_OF_vt100.slice'
X# vt100 terminal info file for CBW.
X#
X# Set the termcap explicitly since many sites have weak /etc/termcap files.
Xsetenv TERMCAP 'd1|vt100v|vt100 in vt52 mode:\
X	:ce=3\EK:sf=2\n:sr=2\EI:cs=\E<\E[%i%2;%2r\E[?2l:\
X	:so=2\E<\E[7m:se=2\E[m\E[?2l:us=2\E<\E[4m:ue=2\E[m\E[?2l:\
X	:is=\E<\E[m\E>\E[?3;4;6;7l\E[?2l\200\200\200\200\200\200\200\200:\
X	:dN#4:\
X	:cr=^M:do=^J:nl=^J:bl=^G:\
X	:le=^H:bs:cd=\EJ:ce=\EK:cl=\EH\EJ:cm=\EY%+ %+ :co#80:li#24:nd=\EC:\
X	:ta=^I:pt:sr=\EI:up=\EA:ku=\EA:kd=\EB:kr=\EC:kl=\ED:kb=^H:\
X	:as=\EF:ae=\EG:ks=:ke=:k1=\EP:k2=\EQ:k3=\ER:k4=\ES:'
X
X#
X# Keystroke command map.
X# No need to set this.
X#
X# setenv KEYMAP ''
X
X#
X# For GRAPHICSMAP, the first char must be one of the following:
X# \G - graphics mode
X# \N - normal mode
X# \S - standout (inverse) mode
X# The remaining positions use the regular slash codes.
X#
Xsetenv GRAPHICSMAP 'tb=\Gb:lf=\Ge:cr=\Gd:\
X		   :na=\G'\`':ff=\Gc:cc=\Gf:uk=\G~:ul=\Go:\
X		   :hb=\Gq:vb=\Gx:ll=\Gm:'
X
END_OF_vt100.slice
if test 947 -ne `wc -c <vt100.slice`; then
    echo shar: \"vt100.slice\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f zeecode.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"zeecode.c\"
else
echo shar: Extracting \"zeecode.c\" \(2181 characters\)
sed "s/^X//" >zeecode.c <<'END_OF_zeecode.c'
X/*
X * Encryption/Decrytion program based on crypt but uses A0 and Zee
X * rather than Rotor and Reflector.
X *
X * Robert W. Baldwin, December 1984.
X */
X
X
X#include	<stdio.h>
X
X
X#define	BLOCKSIZE	256
X#define	MODMASK		(BLOCKSIZE-1)
X#define	FALSE		0
X#define	TRUE		1
X
X
X/* Global state. */
X
Xint		perm[BLOCKSIZE];	/* Current A permutation. */
Xint		nxtperm[BLOCKSIZE];	/* Next A permutation. */
Xint		zee[BLOCKSIZE];		/* Zee permutation. */
Xint		zeeinv[BLOCKSIZE];	/* Inverse of Zee permutation. */
X
X
Xchar	*permfile = "zeecode.perm";
X
X
X/* Do the deed.
X */
Xmain()
X{
X	int	i;
X	int	*curperm;
X	FILE *fd;
X
X	if ((fd = fopen(permfile, "r")) == NULL)  {
X		printf("\nCould not open %s to read permutations.\n", permfile);
X		exit(0);
X		}
X
X	readblock(fd, zee);
X	for (i = 0 ; i < BLOCKSIZE ; i++)  zeeinv[zee[i]] = i;
X	readblock(fd, perm);
X
X	fclose(fd);
X
X	while (doblock(perm))  {
X		pgate(perm, nxtperm, zee, zeeinv);
X		for (i = 0 ; i < BLOCKSIZE ; i++)  perm[i] = nxtperm[i];
X		}
X}
X
X
X/* Compute the permutation after inperm using z and its inverse zi.
X * The result is placed in outperm.
X */
Xpgate(inperm, outperm, z, zi)
Xint	*inperm;
Xint	*outperm;
Xint	*z;
Xint	*zi;
X{
X	int		i,x,v;
X	int		w;
X
X	for (i = 0 ; i < BLOCKSIZE ; i++) {
X		w = -1;
X		x = z[i];
X		if (x != -1) {
X			v = inperm[x&MODMASK];
X			if (v != -1)
X				w = zi[v&MODMASK];
X			}
X		outperm[i] = w;
X		}
X}
X
X
X/* Read character from stdin, encrypt them with the given permutation, p,
X * and write them to stdout.
X * Return FALSE if reach end of file.
X */
Xdoblock(p)
Xint	p[];
X{
X	int		pos;
X	int		sc;
X	char	c;
X
X	for (pos = 0 ; pos < BLOCKSIZE ; pos++) {
X		if ((c=getchar()) == EOF)  return(FALSE);
X		sc = p[MODMASK&(c+pos)];
X		if (sc == -1)  {putchar('?');}
X		else  {putchar(MODMASK & (sc - pos));}
X		}
X	return(TRUE);
X}
X
X
X/* Read a block of BLOCKSIZE integers into the given buffer from
X * the given stream.
X * The block is terminated by a newline character.
X */
Xreadblock(fd, buf)
XFILE	*fd;
Xint		buf[];
X{
X	int	i;
X
X	for (i = 0 ; i < BLOCKSIZE ; i++) {
X		if (fscanf(fd, "%3d ", &buf[i]) != 1)  {
X			printf("\nReadblock error on i = %d\n", i);
X			exit(0);
X			}
X		}
X	if (fscanf(fd, "\n") != 0)  {
X		printf("\nReadblock error on newline\n");
X		exit(0);
X		}
X}
END_OF_zeecode.c
if test 2181 -ne `wc -c <zeecode.c`; then
    echo shar: \"zeecode.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 1 \(of 11\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Rich $alz			rsalz@pineapple.bbn.com
Cronus Project, BBN Labs	"Anger is an energy"
