Path: seismo!uunet!rs
From: rs@uunet.UU.NET (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v10i003:  Crypt Breaker's Workbench, Part03/11
Message-ID: <375@uunet.UU.NET>
Date: 17 Jun 87 22:40:03 GMT
Organization: UUNET Communications Services, Arlington, VA
Lines: 2404
Approved: rs@uunet.uu.net

Submitted by: Robert W. Baldwin <BALDWIN@XX.LCS.MIT.EDU>
Mod.sources: Volume 10, Issue 3
Archive-name: cbw/Part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 11)."
# Contents:  UU.test2 cbw.log mss-bigram.stats pword.c screen.c
#   tdriver.c test1.txt window.h
# Wrapped by rs@uunet on Wed Jun 17 18:17:10 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f UU.test2 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"UU.test2\"
else
echo shar: Extracting \"UU.test2\" \(5977 characters\)
sed "s/^X//" >UU.test2 <<'END_OF_UU.test2'
Xbegin 644 test2.cipher
XM1'&`=V[P=-\_@(BE.Z.<"HG/_;^M8!^QSO@`J4MNJY\21BB@3F9IH:3$H.OR
XMDTWP*'E)?K;:BI4^JL.H-4B_ZAR?3Q2?,1(/X=X,#+3ZH0<*4#HZGS54.D2-
XM`$;Z?=6[(6"-?\#2^(1H?[IOC?3#8O!?!Y9EF77<8>"])Y<:XLK@/Q54ERGD
XM9',M_2J!ZRD(VP<YG:L>_<0M!G;AY./N]B7@^(4R827(V+GT[]3GU7[32"&C
XMB\(S-)2KCB!%>F<.@&10?7P9L[834HM.PO>5+[E]F_M/BHFP_B9Q\FR)8S_/
XMA"V1%JNSR[QGDO:`$O)VEF,Y^Z6-@O>*J_Z'AR-3>["$^DF72TKI>N7,!CAY
XMQW5VMQCN(UO4+<(/0#_^O>,)V+_6TDD[@-'1/1MM2Z*FKYFC.TPY6O1(+IL&
XM5RJ57.>ZG(2Y8$9>^?H)#4T;KHX--`N75/[.\_5V==P["4WC3%5F;$4XKJHE
XM,<0(O&X?*#R'&R&$)BR=F72@*!,MN)==PKF*"\OTPBW[@^F7*`$FV,%+5G/%
XM']'":HKFMOM"J<KW_7\JJ7/)"S?7<OY`#:BL'7Z'K.C_AA.G,W^;0E3[4M-3
XM][<,3%`I)B>PK0UN%&Q*K!Y!0&X^G;T8VAD*!I9?%1*M/026CY`X7:6).#'7
XM+]HZ+)INE).6"*(LNTZ]AH9%2WMTH'+G'3\F9WB][CD0E7>W<$J0#A*YXJ_?
XM&KNWB22NKQQ'1OT_\['D3<S#[2>(UPUI4*1,2]NAYJ,L:FOZ9P\?MN_;[9G[
XMTP8^\PGVSF+7+=_L[J$"-)Z'.Q&6W-V:+_><1#F_*\F<++HO;BT4]^--'RK#
XMX:$6,"ZZX3?6HSEUM7ZS_12.C<B</0PT,\$G-RN%;:B25^Z\N"8RLGE"N+\>
XM;E!'SVM7<#)5ZQ/]EV("`;J2)USYN6ZZN79#[\G*K<B1).5A!)?*)AV\R#;$
XMOTG\@H&G&.3"T20SY3%K'X0#1<I'[^&/]K#B(A(97)X<L?=EUJY%3JOGY"*G
XMIK)]*MT\:&4>@Q'X646)K3?B\<$V^WRLVY*#V)3^&-3324+05R/G-.^NV6S/
XMS8-O1;N_VC`DE9`J@?F[L$0CM*QY2+>RQI;HB^;W\>1X_9G?%-ZSAPBP?]I]
XM>NG6[JA.S,)Y^K"?Q%F[5^?3MWG)O+.RQ'%$SJ2H`H6^-HD\^;FK?2TA`/_:
XM`L?]KOL'CY>KX_3=NO>XMU'3MPRXZ44JG>CJ-NKVJ]C)5]4Q9NYUZ/DVI;T9
XMQLO7$EPJ."C!K.%\>[%Y_".I"BD;%^LC%'QZ`"@)_;%QJDZODJHNGJ<Y%S=@
XMC1-BGW#;>N\$,@KF:-8*:6C6#MD(SO8!:'SR%ZIKDKR[%VXP4F-NSFA'-J@]
XM9)TZJB(Z,MY1G7!<@8#WRZ*&TX2?D&_FJ"[)E$22]5Q`&@A<//&E)EF<&"F:
XM>-,XEA42=2"4'5N36>W=CQ/2.34.5B$<"@J?]BQ`E](DT(CG-N4.KE^,8CQ(
XMEEZOU!SWFYJ%O&V[D(1GMF<P;PYAG,5LPUI2P)@("F.[('Y.S7O$C:U)JVD/
XM1535B$&Z?(D_((!]NSIO?`)1(R?SLC,#2H[R`&/^[#MZKHI4]T1L16I'E+MM
XM#QV2FFK)O1;FRVT";L>D_TJ078"]/+L247TCCO*BQ*ES1K`;'2XG^<\YDJ]>
XMM5S&74G"\C"7"%,NP+#[LDV7H$V-D<HH*7R9+"M^;]'[=%J])@1:%B*!"4M*
XM'D&C($_*T3C^!)A3=YQ0,[4Q?J"QPD@E',4CGJ(%']>VM589LM'&SQR''BFR
XM?\CF:CIMQFD_!]SV/:!ACAI<7BL3F(<=_H0)-'V`?P=%?-"^+:`B`;99'G9S
XMA=/+PF*.YZKX'TL5,)0I=X.]G-9_C!`7;D,Z/PX]@5EKNNEL-AN,?(IR81.L
XM1S+62&`)V%13`RH6&$[<3*I<@%%?I);0BEZ(A8SNR(GRM5-)25`RKJ!X'JM)
XM1Q1"$C?7[14E'#DT"=8[/""`@'Y%MLG+EJ*1P9^>9G.DCHU:WY;AC*,UD=B#
XM,7+-+F.0?I??;S?J-4)!V0*A3FAG.=DA;4:J1<?WRO57]@V<5:Z,[3<D,^Q2
XM-5<TT=HQ+B4YSSLK-<?Q,EJ'*D#HN:V!_@L>A!R2!M,M4XQPP)AML(JN-52&
XM]V5*L_U.`'>+RL("JS^Q`P`["]^T-ZU(-9W(0^LBU/.=3Q=-0S8=[4^H98<+
XM;*0X0*@3!#2:_J/\H'ICG3]#=?03[N#3#^^-F3S\<RYJ^#!D8AN;=PGVOV^2
XM+IX2,[@@%/02J4&V86#U>5D/4.&[3(&\HP+XL,1II",_FEY8.ZYO.%I[49VH
XM@V0]VP^VYN6+.FH-DQ=FVYQ_G9Y&FHF5J.2%')@<4=U.$#Z??".^W*.WUP#D
XM2MJ7+Z'%=U?.S6B9KATN7_QI()?#X+DKHJ^]<EYSM.S8_^SH""#N9+R[.^D`
XM+77)M'$UQ9[K$M[QNC>215>/8]KC01=7;::>5]'2,S([,Z2_4/(:&<%N[1!4
XM,@4L@IY._7?4^7@G:(<_9<.KQE3J]^*7EJ&YX3]'N$#87IFQ>UJ?=FXR-:GS
XM1MOCCPWYA";(4:)>N9^^>\E(Z[F+T,]H7+$:KWM+5D4GX!9U1'?DZ\#J##=+
XM:<#!F"]%^=8U<RF02+&'0!FM/<L#OJ![=*>F:/!=,70&L&E8:595P&L%2%9L
XMI5^R=ALL?;/JYYH.8!_D_?(5#K]@_+\'-Z#(YV\[JH_$2W"_<:9O8#)!Q#3@
XM?;R__'ED=QA&M#/BQE=J,Q"J],VI0A#O#I&&YB\EADAU1C66<>QR<>MOWACB
XME?XQT"^'51SF]U"?_)YZN/Y2^YC](VWX:P[O]$=)2"%&`_D+=WM,4TK@S2?N
XMI,LV0M(AK:R]S51KVJXYQ^'MYQ:KU0;G."4/H'6%C8S_>=J-LP0=![6'I-.M
XMJ2A5:9(1D%QN?_7^#\NU6Y\*Q)$'E-BI4*KDR6"[+SR`?\J&X8:4I)T*@;J,
XMQWT4O+M`DK8ICSC[-157(-!&:SN<0AO_XX_;*L0%$<V;QICT2M;DM,"DUPS<
XM>+7;)8^".^3ES-LSLX,*%SK&^^$2BD#3W-'VA)MP@L:[+90;Z!CFID*(/.T"
XM849+UZAO6_[]Q'IS.T*[_]WW]1].-L=P9E&EKHHO(7$1'ITH&YC'7:H_J:EN
XM;+%#)(-P,IZR<HTMFU^ZG.N68]#[_J?^L.)Z7?]T4W?+(W15U7'P:ASPM,PE
XMEX#U.N@P+Z;?.`N#@KP$VB4R3@LA2WCIKBYA4/#OLI,75G+ICTWF4Z@('IL/
XMDO7WE#U$_F_QM?J#^(GPE_6X#DF2.Z@Y<-;5C;D_4MVRN$:Q9,$)E$%1`4Y.
XM_DMM+[R>_"N;D%ES5)Z'<&^96F<E(HA?]F[GE<`U3(R6V`KSOGFHVEKFY1$F
XMZ\_O+W@93^%]XTMZ-NWW02,['AU*5H8BRD6G,A5"$Q*/XL/@):6LCW#K3$OH
XM"0C*X'B4Q`*!06"NVL*IU%:OKMQDT:Q0LLTRIZ/"Y@])8QCLG)U#*X-O+Y$:
XM-U_K5-ZE;/P[<<=59,8G4;>%\_A>!92N'1`;(YHA'[OGD+HNXQ\#?=)$C&[L
XM)B`F'.KVD[QD$6*!M]YT!+CZ@XA%SG$^-C69G(RY>.]+UY\V."0V<.H)E)0P
XM,S7C5DY-KR]<Q)7KR<)U!L")`TX%?*&V2G+L\UIX`"71=$&:&Y=FH3NUZ%F<
XM\97"8-BO;3A!VH4-]<^8EX\XP3,7DDQJ2I)_CQM:TL^>U+^YV81)S8+ULN,[
XM/2W.@Y7<HDU<5.A_;JT3"8B:AYA\Z#L]ZS,5UWR!Q@Y@LJP5S/!1HF4OI-4(
XMPQY1@VWS+?%E&;19/QV,(R7+<<FA'.:E3@J!5+T?$;^5GD;^#4$(BN[M0CWT
XMA.J"V/TDLFUQ;ZVMSXN0)LMX0FA_;%_GQVEA@\BNAH4D61'D$)X'WY4GDYC=
XMJ@I@71+5F%G@N8S'&GN4G=IY>\QSKA"K]P-F`:*/\8"CTC!26<#)2&QK_>3#
XMO"J0?V9BZ#/;SMD6]0H)#%C]5CY$7MJ(G"$-/?N_=@0\#R,-`H^0)#"?"5C?
XMOZ9%WQ*U)".Z%@S.ZRSO*A@.3"%*_PGI)`/!^!SCKWDV9\!(^"4D,9IV`#3P
XMIF(;8'O'TS[\]\^;,*H"%93CDI'18@\LGY1`'C&&Y8OEB?/?\4>6$C(9(_'A
XM20MC>BTJ:]-0:%%&9=,<26Z\`U9NN"UG11`/0H#P'0J-@7I&O<!'<7!H(YR!
XM_SW<;.C%@UVYV1!^$G$S"UKV?[]-LJ;B%6AGD#O<N]I"N&]H?OU7^S+$4YR"
XMR+^KJB'UMP,EP#E\2*`;V(,S%TTO_BV0ST2Q;:=K'GGI8FM57VL9$<6_%<UA
XM+S->E*]OOZ>]MFPK:W1DKFOX_,C9>J!XH`H<(K\E_OVL;A-9(Y%R9P7,\L':
XM9\"7[.E?:3"1W/6(5(&5\(^'=8]RJ'%O;C-FDP(O)F'?S8:I3$M.UM;S%"9(
XMR075J&DDED`]'B*F)1H9UZ%NO;K<?Z'%#T2F'6-]O#P67GL>CX(;1<1Q^8P5
XMG]6N=XT"/5?N<8>JUGDM3:M1$WL19SM5E/T+6W+S3:3;HQGT$O()@+-^_T^C
XM+?7!R?ZF?*ZC\\X:ZC['.>R[2T[H61V(0#6+_#2>'RV1D/37NR<O)?@4\R?(
XMLH5V#>\S+?RA??#>].8EFG.$B>SKR[O7?*8M1W%RT*E3:]AB<OZ1-Q`E`[4!
XMFU^O55V6G:/$N'.2])`YJC=VH-?8_&<P;Z_J:="ZWH75^U"UH><"76OEY"@`
XM]<<D`W[<<_K!1-=SA%*?G*$AZ'ZH_A0/OW>!^(8O,?HO=[\&?@[+[*+K?,D^
XM!H`*#&%R&04@1;V[1]'0V_SFM.X_!B1\_94.#$G23/X[C8.>?`B,H@0R"S`0
XMS6;+LB5?0A_%X07?DPD46<Q_"503)VYZFI*1EV-9\EE^#%VYWRU1JZK+94M+
XM=TF/(F1(#$+-]QN&LD3CQL2"M:)]/&.MZF@J*7]R4LP/<LEXZK2S?ZO!PS,K
XM3FU0N#A<\_C"P6?E]F!$;MQ@8H!99[0O..Y!'"`&?@W@)2DH?DC'56=05\Q7
XMP'&Y6=87R#+\KY_C16A#B_W-1J*&FC'!3.(VVS1&6$2-.-_[+M8]AA>=]%![
XM12YQ7)<>W#0TO7585_G.9<%57DDC;6NG!`/3DFT64E'+CNY-QYGV%^.,PM8X
XM9&;.N]9UF@]?)S,ER`8N>BT)@M=-R-746_C;^%=/;LS[G=BBQX03)/D4:<B\
XM"7(NP4+'!H4H60RT5++?KWY1F.T<XM\GTI$>!NH;@KKVY27\<OV`8%_B[D47
XM>$<'!G^N>#:RC61J;&)JCIDW8FOU`X<,P%L1CK+_#H&@,.3=\/RC-C6:)_[U
XM\IM;753,T=(6]@HN4\H=FQL@W*!6CYZXG/8/:`T=LPH)?P<7\P1X=P"S>SL`
XMOIZLC<"5"QO!"QB8HACS$1/1G,3\K]W<"-KU;^0%J5N>3S!P;[0OP6XU%A4;
XM>).][#3=N?9(8%\I-_`CA+G!(#V\NQ,$K&=X0P2$L@HSY30S*_NH"],L)F/0
XM][KFV.1_@+1+W\1'"?L7%GL1:K!6LPQ`#7(89V!?#:9QMCQNLSEK0<B("9&0
XMQ6."4\R_-8R'BGKS#XJC/NZG<0Z+G#O,4$].R:V+L5>?FT9;&R&PK_?R3RB!
XIJ4T3R-\0.T6>,^B\N3^:RW!B89UH*=6`&07I85?6`?)M#D40*\S1^_/R
X`
Xend
END_OF_UU.test2
if test 5977 -ne `wc -c <UU.test2`; then
    echo shar: \"UU.test2\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f cbw.log -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"cbw.log\"
else
echo shar: Extracting \"cbw.log\" \(4985 characters\)
sed "s/^X//" >cbw.log <<'END_OF_cbw.log'
X
XWho:   Bob Baldwin
XWhy:   
XWhen:  6/16/85
XWhat:  
X
X
X
XWho:   Bob Baldwin
XWhy:   Had to learn about terminal independence sometime.
XWhen:  10/8/86
XWhat:  
X- Change outline of lookup window to use graphics.
X- Change graphics bit to 128 from 256.
X- Change screen plstring to check graphics bit.
X- The dictionary file found via a shell variable DICTIONARY.
X  - Defaults to /usr/dict/words.
X- Require that all control characters except \n and \t be
X  quoted before they are inserted into the block.
X  - Note problem with making C-Q or C-S active.
X- Avoid the disperr() routine until the screen is initialized.
X  - This fixes problems caused when termcap doesn't specify screen size.
X  --> Don't avoid, just fix disperr not to call setcursor().
X- Send init term sequence to terminal (if any).
X- Speed up the graphic printing by remembering whether the term
X  is in graphics mode.
X- Fix bug that allowed the cursor to move off the screen, which caused
X  the program to exit.
X  - Force screen size to 24 x 80.
X  - Change go_down behavior in user window.
X- Have the PF4 key jump the cursor to the command line (if any).
X  - Have C-X also do this.
X- Fix formatting problems due to 4 char tab versus 8 char tab bug.
X- Send sequence to active keypad.
X- Have C-Z abort the current command (what about C-C?).
X- Add a command to suspend the program and return to the shell.
X  - This avoids the long wait on reading stats.
X- In general need to provide a way to re-init terminal when
X  program is exited and entered.
X- Get the PF key definitions from the termcaps file.
X- Add general keymap which can handle long sequences generated
X  by a single keystroke.
X- Init keymap from shell variable.
X- Add graphics character map.
X- Init from defaults and shell variable.
X
X
XWho:   Bob Baldwin
XWhy:   Remove references to buggy word lookup features.
XWhen:  6/16/85
XWhat:  dbsaux.c
X
XWho:   Bob Baldwin
XWhy:   Make start up faster.
XWhen:  1/15/86
XWhat:  stats.c
X
XWho:   Bob Baldwin
XWhy:   More work on word lookup.
XWhen:  6/16/85
XWhat:  specs.h, lpair.c, dbsaux.c, webster.c
X
XWho:   Bob Baldwin
XWhy:   Fix formatting.
XWhen:  6/13/85
XWhat:  cipher.h
X
XWho:   Bob Baldwin
XWhy:   Add word lookup cmd to dblock. (^S)
XWhen:  6/13/85
XWhat:  dblock.c, dbsaux.c, webster.c, window.h, specs.h
X
XWho:   Bob Baldwin
XWhy:   Make ^T use bigram stats.
XWhen:  5/11/85
XWhat:  dbsaux.c
X
XWho:   Bob Baldwin
XWhy:   Fix decryption block help message to indicate ^L and ^G.
XWhen:  5/11/85
XWhat:  dblock.c
X
XWho:   Bob Baldwin
XWhy:   Added routine to clear guess window, gbsclear().
XWhen:  5/11/85
XWhat:  gblock.c
X
XWho:   Bob Baldwin
XWhy:   Integrate bigram guessing into cbw.
XWhen:  5/11/85
XWhat:  user.c, specs.h
X
XWho:   Bob Baldwin
XWhy:   Add fast approx for sqrt and exp.
XWhen:  5/11/85
XWhat:  approx.c
X
XWho:   Bob Baldwin
XWhy:   Try bigram equiv class guessing strategies.
XWhen:  5/2/85
XWhat:  lpair.c, cipher.h
X
XWho:   Bob Baldwin
XWhy:   Add bigram statistics.
XWhen:  4/28/85
XWhat:  stats.c, bdriver.c, specs.h, cipher.h
X
XWho:   Bob Baldwin
XWhy:   Add new scoring alg based on prob sample drawn from english.
XWhen:  3/3/85
XWhat:  stats.c, sdriver.c, specs.h
X
XWho:   Bob Baldwin
XWhy:   Make merge only show changes.
XWhen:  2/15/85
XWhat:  dblock.c
X
XWho:   Bob Baldwin
XWhy:   Fix duplicate bug in permvec_from_string.
XWhen:  2/15/85
XWhat:  cipher.c
X
XWho:   Bob Baldwin
XWhy:   Experimenting with new scoring functions.
XWhen:  2/15/85
XWhat:  stats.c
X
XWho:   Bob Baldwin
XWhy:   Add command to try probable words from a file.
XWhen:  2/15/85
XWhat:  user.c
XAdded: pword.c
X
XWho:   Bob Baldwin
XWhy:   Change interface to ec_init().
XWhen:  2/15/85
XWhat:  autotri.c, dbsaux.c, eclass.c, edriver.c
X
XWho:   Bob Baldwin
XWhy:   Make equiv class assume wiring in dblock window.
XWhen:  2/15/85
XWhat:  eclass.c
X
XWho:   Bob Baldwin
XWhy:   Make clear zee command leave cursor on cmd line.
XWhen:  2/4/85
XWhat:  knit.c
X
XWho:   Bob Baldwin
XWhy:   Bug of knit and propagate not properly restoring user area cursor.
XWhen:  2/4/85
XWhat:  user.c
X
XWho:   Bob Baldwin
XWhy:   Bug overflowing string on bad argument parsing.
XWhen:  2/4/85
XWhat:  pgate.c, knit.c
X
XWho:   Bob Baldwin
XWhy:   Make knit command take an arg which is the minimum guess count to show.
XWhen:  2/4/85
XWhat:  user.c, knit.c
X
XWho:   Bob Baldwin
XWhy:   Make ^T try all char command smarter
XWhen:  2/3/85
XWhat:  dbsaux.c, Makefile
XAdded: pqueue.c
X
XWho:   Bob Baldwin
XWhy:   Divide by zero bug in pvec_1score
XWhen:  2/2/85
XWhat:  stats.c
X
XWho:   Bob Baldwin
XWhy:   Fix crufty acceptance criteria for equiv class maximizing.
XWhen:  2/2/85
XWhat:  eclass.c, user.c
X
XWho:   Bob Baldwin
XWhy:   Termcap file doesn't have enter graphics mode for vt100v
XWhen:  2/1/85
XWhat:  screen.c
X
XWho:   Bob Baldwin
XWhy:   Add initial guess based on equivalence classes.
XWhen:  2/1/85
XWhat:  Makefile, user.c, gblock.c
XAdded: eclass.c, edriver.c (test program)
X
XWho:   Bob Baldwin
XWhy:   Make better abstractions for the cipher system and statistics.
XWhen:  1/31/85
XWhat:  stats.c, specs.h
XAdded: cipher.c, cipher.h
END_OF_cbw.log
if test 4985 -ne `wc -c <cbw.log`; then
    echo shar: \"cbw.log\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mss-bigram.stats -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mss-bigram.stats\"
else
echo shar: Extracting \"mss-bigram.stats\" \(5518 characters\)
sed "s/^X//" >mss-bigram.stats <<'END_OF_mss-bigram.stats'
X158143
X
X0 \000\001\002\003\004\005\006\007\177\b\v\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037
X1538 ({[<
X3284 Pp
X667 Xx
X1509 >)}]
X293 Qq
X1836 Yy
X2426 @*+|~^=#$%&
X7301 Rr
X138 Zz
X7217 Ss
X2980 .,:;?!
X10913 Tt
X666 _-
X3594 Uu
X891 Vv
X214 \\/
X1467 Ww
X1052 0123456789
X34092 \t\n\p\r 
X266 '`"
X8090 Aa
X1877 Bb
X3797 Cc
X4324 Dd
X15271 Ee
X2624 Ff
X2047 Gg
X4466 Hh
X8322 Ii
X187 Jj
X435 Kk
X4437 Ll
X3397 Mm
X8366 Nn
X8159 Oo
X***
X1848 \tI
X900 ED
X184 D.
X327 \t0
X478 H\t
X850 ME
X1246 TI
X781 RO
X13 SL
X38 YS
X45 'S
X137 AP
X20 >@
X6 UF
X108 @S
X166 (P
X245 PU
X20 .>
X43 HT
X23 FA
X5 T0
X8 F(
X3 _Z
X20 G>
X3 OX
X9 \\J
X17 DG
X1 _A
X1 .W
X12 >'
X1 BM
X3 IQ
X2 NB
X1 >Y
X3 _(
X1 W@
X510 VE
X1012 AR
X129 BO
X908 IS
X321 DI
X187 CL
X50 \tK
X1171 ND
X2 _\\
X247 EF
X22 E_
X39 OA
X76 M.
X1 G'
X138 @U
X73 (R
X10 .'
X26 P>
X82 .@
X4 O(
X19 GY
X16 _C
X11 Q\t
X6 SN
X2 D0
X8 XX
X4 \\L
X7 G@
X1 ZR
X469 LL
X676 A\t
X291 OC
X1330 AT
X590 \tM
X135 FE
X282 SP
X437 RS
X7 \\N
X22 M0
X18 @>
X86 (\t
X152 XA
X41 NF
X245 MI
X14 .B
X10 TM
X36 Y>
X57 X(
X5 'W
X2 P'
X61 P@
X22 N_
X20 _E
X6 EH
X15 '>
X41 (T
X30 PY
X5 V.
X9 YW
X7 @W
X8 Z\t
X3 >D
X1418 \tO
X805 TO
X47 RU
X70 OE
X673 HA
X130 AV
X165 VI
X350 UL
X203 @@
X139 0>
X41 @'
X200 BS
X34 XC
X4 Y'
X16 >F
X11 '@
X17 Y@
X39 I>
X16 F.
X2 .D
X24 H(
X49 (V
X17 J\t
X10 W_
X16 DM
X23 _G
X2 FG
X1 @Y
X2 YY
X1 _.
X2 NH
X26 V0
X18 \\P
X1006 ST
X2278 S\t
X595 FI
X65 BU
X335 DO
X224 EL
X34 LP
X222 UN
X27 KS
X33 _0
X21 XE
X138 CR
X328 WH
X198 MM
X77 R>
X13 _I
X41 O.
X25 0'
X186 OG
X23 AX
X175 @B
X3 .F
X11 RW
X1 PD
X135 \tQ
X6 G_
X16 (X
X30 0@
X10 I@
X27 Q(
X2 YB
X1 GF
X1 'B
X3 I'
X11 \\R
X177 RY
X1456 \tS
X1612 EN
X321 TS
X2344 HE
X572 CT
X245 MO
X76 UP
X114 IB
X11 R'
X2 ZA
X24 ((
X72 NL
X55 (A
X31 @D
X69 C\t
X76 GH
X50 OI
X10 LR
X5 P_
X16 X.
X7 A(
X1 'D
X3 PF
X1 B>
X2 FK
X14 \\T
X8 R@
X540 L\t
X173 TU
X300 \tU
X482 AC
X312 EP
X502 UR
X46 XI
X44 (C
X141 BY
X28 VO
X59 OK
X17 YF
X33 NN
X16 WL
X117 DS
X161 ID
X41 H.
X102 PH
X10 JA
X78 LT
X2 _M
X14 >L
X4 'F
X25 CV
X20 @F
X30 RB
X9 K>
X9 Y_
X3 .J
X7 X0
X1 KW
X3 @_
X2 \\V
X1624 ER
X562 UT
X401 IF
X256 U\t
X954 \tW
X430 HI
X530 FO
X439 OM
X117 ZE
X107 SA
X27 GL
X85 (E
X34 @H
X85 \t>
X247 DU
X133 NP
X130 T>
X124 RD
X78 TW
X17 WN
X11 LV
X71 MS
X83 S(
X7 Q.
X15 >N
X9 _O
X4 0_
X10 .L
X1 K'
X4 JC
X2 I_
X1 KY
X1 'H
X429 \tY
X4322 E\t
X157 AG
X469 ET
X449 CA
X140 MU
X172 TY
X447 PL
X127 SC
X31 D>
X1380 \t@
X97 T@
X223 GN
X61 \t'
X32 (.
X3 'J
X30 RF
X3 R_
X5 .N
X3 NR
X55 JE
X114 OO
X18 WP
X16 T'
X26 C(
X18 A.
X23 (G
X2 IH
X1 HK
X2 _Q
X12 \\A
X3 \\Z
X1 Z.
X2 BD
X1 >P
X142 EV
X1021 SE
X1214 NT
X756 \tB
X1723 N\t
X6 BF
X236 LA
X126 AI
X71 CC
X102 (I
X10 .P
X34 @L
X62 (0
X54 WR
X6 D'
X61 UX
X15 D@
X43 M>
X17 DY
X1 'L
X15 YL
X2 A0
X6 RH
X1 KD
X12 _S
X1 B_
X15 HM
X15 L(
X5 TB
X4 \\C
X2 ZI
X2 FS
X1 J.
X3 >R
X4 IJ
X447 IL
X263 HO
X742 \tD
X415 S.
X466 EX
X507 CE
X9 \\E
X1059 >\t
X146 W\t
X146 OS
X65 NV
X100 AK
X314 GR
X3 M'
X70 PP
X99 UA
X59 FU
X7 >T
X5 BH
X15 LC
X43 M@
X20 @N
X48 YN
X5 'N
X1 _U
X4 (K
X5 MY
X2 U(
X4 J0
X3 .R
X593 EA
X878 OU
X679 SI
X2478 IN
X511 G\t
X2564 .\t
X784 PR
X1219 LE
X835 \tF
X83 YP
X553 AM
X110 UC
X123 E(
X53 \t_
X133 MB
X10 'P
X25 GT
X87 DD
X18 C.
X29 RL
X14 _>
X38 BJ
X40 (M
X39 @P
X3 F>
X4 TF
X44 T_
X10 .T
X2 _W
X8 S0
X2 \\.
X4 \\G
X22 SK
X2853 TH
X232 CI
X372 \tH
X141 P\t
X109 PT
X549 EC
X123 RN
X256 OW
X38 _@
X300 BL
X280 NA
X199 N(
X285 UE
X53 D_
X57 L.
X50 IP
X48 FY
X5 F@
X6 HS
X21 (O
X9 'R
X4 @R
X5 O>
X15 LG
X1 MD
X1 0P
X25 \\0
X1 F'
X6 \\I
X852 Y\t
X592 LI
X88 \tJ
X196 IR
X245 EE
X54 CK
X6 _B
X32 UG
X226 NC
X11 M_
X802 @\t
X13 U.
X42 '\t
X92 WA
X5 RP
X8 O@
X12 DH
X3 YT
X14 HU
X5 SM
X149 @T
X14 JO
X18 W(
X10 (Q
X27 X>
X27 'T
X4 \\K
X6 .X
X1 KL
X9 >A
X1 O'
X16 >(
X440 AS
X641 IT
X189 SO
X637 \tL
X200 RR
X105 TL
X226 0\t
X448 E.
X690 NE
X168 OB
X75 (S
X11 >C
X234 QU
X67 UI
X41 GA
X242 EG
X15 H>
X6 DJ
X52 I\t
X18 G(
X11 X@
X3 _D
X1 MH
X2 @V
X1 CM
X15 KN
X2 .A
X11 0T
X3 LK
X2 'V
X4 \\M
X1 .Z
X1 BP
X1 ZS
X1106 R\t
X713 NG
X155 FF
X196 RT
X187 N.
X674 \tN
X23 DL
X143 IV
X431 OD
X49 EI
X361 PA
X681 CO
X114 BR
X61 AU
X29 .C
X230 WE
X261 __
X6 HY
X12 P(
X4 Q>
X4 LM
X33 _F
X24 H@
X7 (U
X7 TN
X33 E0
X3 >E
X1 @X
X1 F_
X1 H'
X2 .\\
X15 SQ
X5 \\O
X4 GC
X708 OF
X300 GE
X982 \tP
X279 UM
X64 JU
X38 .E
X108 NI
X296 SS
X243 LO
X29 IX
X152 >.
X101 TP
X14 B\t
X22 RV
X3 'A
X20 @A
X23 Y(
X7 @(
X29 O_
X16 W.
X6 BT
X12 EK
X18 DN
X7 >G
X132 (>
X2 _H
X6 (W
X1 CQ
X2 HB
X4 AW
X18 YZ
X9 A>
X5 Z>
X1 0X
X2 \\Q
X129 K\t
X495 EM
X29 CS
X210 IA
X315 WI
X661 \tR
X267 SU
X66 NK
X83 IZ
X204 AY
X412 TR
X86 G.
X431 PE
X16 .G
X66 ..
X39 @C
X2 (Y
X66 I(
X6 'C
X32 0(
X148 (@
X6 >0
X181 @\\
X6 \\S
X12 J>
X6 GG
X5 BV
X8 UO
X2 OH
X7 MN
X1 A'
X1 KT
X4 YC
X12 >I
X4 0A
X1 XF
X3 '\\
X1 ZY
X37 YE
X838 RA
X323 AB
X1904 T\t
X3762 \tT
X10293 \t\t
X516 IC
X34 .0
X198 CU
X420 MP
X66 TT
X18 NM
X73 S>
X23 .I
X6 'E
X230 GI
X135 @E
X109 LS
X52 P.
X19 FL
X38 R(
X20 (B
X49 H_
X25 DR
X11 SW
X18 OJ
X5 EO
X4 _L
X1 WK
X25 0\\
X4 VN
X3 J@
X1 J'
X1 \\U
X493 US
X312 AD
X1580 D\t
X569 NO
X169 LU
X79 BA
X156 Y.
X38 RC
X62 PI
X237 OL
X10 @.
X9 S'
X7 S@
X65 (D
X47 '.
X101 EQ
X177 IE
X56 DT
X40 _N
X58 B(
X149 \tV
X61 SY
X6 @G
X28 P0
X10 Q_
X5 C>
X1 \\>
X12 >M
X1 R\\
X1 MR
X1 \\W
X188 0.
X1901 RE
X186 WO
X1484 ON
X1327 ES
X369 M\t
X4 KA
X32 AF
X5 DV
X69 @0
X324 IG
X26 I.
X95 @I
X37 YI
X5 >O
X22 CY
X51 \tX
X26 (F
X2 '0
X30 _P
X20 L>
X7 LW
X17 NQ
X5 'I
X11 (_
X5 XL
X2 C'
X6 C@
X8 .M
X1 GM
X36 \\@
X1 \\Y
X2366 \tA
X458 NS
X351 00
X571 TA
X339 LY
X118 FR
X188 OP
X351 \t(
X646 BE
X156 R.
X85 RG
X180 T(
X5 V\t
X13 U>
X104 EU
X30 \tZ
X50 GO
X25 VT
X6 I0
X5 HL
X9 L@
X3 (H
X4 XN
X2 JF
X2 L'
X3 II
X18 SD
X4 PM
X15 0I
X2 >Q
X2 \\B
X830 F\t
X1002 OR
X524 RI
X1161 \tC
X166 KE
X16 TC
X22 IK
X52 S_
X72 FT
X299 E>
X288 PO
X29 LB
X35 B.
X3 U@
X32 @M
X127 DA
X138 NU
X44 _\t
X110 EW
X13 (J
X113 D(
X12 SF
X13 WS
X117 XP
X35 _T
X60 YM
X4 HN
X5 AJ
X5 .Q
X3 'M
X13 >S
X5 U'
X2 \\D
X2 CD
X716 AL
X794 \tE
X509 MA
X1311 TE
X366 YO
X879 O\t
X35 RK
X155 SH
X302 OT
X88 UB
X30 K.
X30 BI
X2 C_
X203 LD
X120 E@
X9 'O
X53 EY
X69 N>
X345 IM
X15 E'
X37 GS
X26 (L
X2 @O
X11 _V
X12 .S
X2 \\_
X2 NW
X4 M(
X13 \\F
X62 UD
X911 DE
X861 IO
X189 \tG
X1231 AN
X500 CH
X20 PS
X281 T.
X1 L_
X123 VA
X81 XT
X262 RM
X100 \t.
X2 _X
X80 X\t
X128 OV
X104 NY
X49 KI
X44 GU
X6 W>
X7 EB
X28 HR
X71 (N
X108 >>
X4 \\H
X32 N'
X8 LF
X10 N@
X2 >W
X***
X-2.0964
X0.513225
X0.716397
X
END_OF_mss-bigram.stats
if test 5518 -ne `wc -c <mss-bigram.stats`; then
    echo shar: \"mss-bigram.stats\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pword.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pword.c\"
else
echo shar: Extracting \"pword.c\" \(5380 characters\)
sed "s/^X//" >pword.c <<'END_OF_pword.c'
X/*
X * Automatic guessing based on probable words.
X *
X * Bob Baldwin, February 1985.
X */
X
X#include	<stdio.h>
X#include	<math.h>
X#include	"window.h"
X#include	"terminal.h"
X#include	"layout.h"
X#include	"specs.h"
X#include	"cipher.h"
X#include	"autotri.h"
X
X
X#define	DEBUG	FALSE
X
X#define	NWORDS		100
X#define WDBUFSZ		(8*NWORDS)
X#define	WDPERMSZ	40
X#define	PWDLABEL1	"Probable word search -- Please Wait"
X#define	PWDLABEL2	"Probable word search -- Done"
X#define	PWDHELP		"F3 enters guess, ^G undoes it."
X
X
Xextern	char	mcbuf[];
Xextern	ecinfo	gecinfo;
Xextern	atrinfo gatrinfo;
Xextern	atrdraw(), atrfirst(), atrenter(), atrundo();
Xextern	char	*pwd_init();
X
X/* Gloabal State. */
Xchar	*word_tab[NWORDS];
Xchar	word_buf[WDBUFSZ];
X
Xkeyer	pwdktab[] = {
X		{CACCEPT, atrenter},
X		{CUNDO, atrundo},
X		{CGO_UP, jogup},
X		{CGO_DOWN, jogdown},
X		{CGO_LEFT, jogleft},
X		{CGO_RIGHT, jogright},
X		{0, NULL},
X};
X
X/* Routine invoked by user to search of a list of probable words.
X * The window is drawn empty, and then filled in with the guess.
X * Return NULL if command completes ok.
X */
Xchar	*pwdguess(str)
Xchar	*str;			/* Command line */
X{
X	gwindow	*pwd;
X	atrinfo	*pwdi;
X	ecinfo	*ecbi;
X	int		*dbsperm;
X	float	max_score;
X	char	*errmsg;
X	int		i;
X	char	filename[MAXWIDTH+1];
X
X	if ((i = sscanf(str, "%*[^:]: %s %*[^:]: %f",
X		filename, &max_score)) != 2)  {
X			return("Could not parse both arguments.");
X		}
X
X	pwd = &gbstore;
X	pwdi = &gatrinfo;
X	dbsperm = refperm(dbsgetblk(&dbstore));
X	errmsg = pwd_init(filename, mcbuf, dbsperm, pwdi);
X	if (errmsg != NULL)  return(errmsg);
X
X	ecbi = pwdi->eci;
X	pwdi->min_total_chars = 1;
X	pwdi->max_score = max_score;
X	pwdi->min_wire_chars = 0;
X
X	gbsswitch(pwd, ((char *) pwdi), pwdktab, atrfirst, wl_noop, atrdraw);
X
X	gblset(&gblabel, PWDLABEL1);
X	atrdraw(pwd);
X	fflush(stdout);
X
X	pwd_autoguess(pwdi);
X	decode(ecbi->ciphertext, ecbi->plaintext, ecbi->perm);
X
X	gblset(&gblabel, PWDLABEL2);
X	atrdraw(pwd);
X
X	return(NULL);
X}
X
X
X/* Load a word table from the given file.
X * Format is a word on each line terminated by a blank line
X * Returns error message or NULL.
X */
Xchar *wtab_load_from(filename, charbuf, buffree, wtab, tabsize)
Xint		buffree, tabsize;
Xchar	*filename, *charbuf;
Xchar	*wtab[];
X{
X	FILE	*inp;
X	char	*wordstart;
X	int		wordindex, wordlength;
X	int		c;
X
X	if ((inp = fopen(filename, "r"))== NULL)  {
X		return("Cannot open file to read probable words.");
X		}
X
X	wordindex = 0;
X	while(wordindex < tabsize-1)  {
X		wordstart = charbuf;
X		wordlength = 0;
X		while ((c = read_char(inp)) != EOL) {
X			*charbuf++ = c;
X			wordlength++;
X			buffree--;
X			if (buffree <= 1)  break;
X			}
X		*charbuf++ = NULL;
X		buffree--;
X		if (wordlength == 0  ||  buffree <= 0)  break;
X		wtab[wordindex++] = wordstart;
X		}
X
X	wtab[wordindex] = NULL;
X
X	fclose(inp);
X	return(NULL);
X}
X
X
X
X/* Fill in probable word info from given ciphertext block.
X * The filter parameters are not set by this routine.
X */
Xchar *pwd_init(filename, cipher, perm, pwdi)
Xchar	*filename;
Xchar	cipher[];
Xint		perm[];
Xatrinfo	*pwdi;
X{
X	int		i;
X	char	*errmsg;
X
X	pwdi->eci = &gecinfo;
X	errmsg = wtab_load_from(filename, word_buf, WDBUFSZ, word_tab, NWORDS);
X	if (errmsg != NULL)  return(errmsg);
X	ec_init(cipher, perm, pwdi->eci);
X	pwd_guess_init(pwdi);
X	return(NULL);
X}
X
X
X/* Per guess initialization.
X */
Xpwd_guess_init(pwdi)
Xatrinfo	*pwdi;
X{
X	pwdi->best_trigram = NULL;
X	pwdi->best_score = 10.0;
X	pwdi->gcount = 0;
X	pwdi->total_score = 0;
X	pwdi->best_pvec[0] = NONE;
X	pwdi->best_permvec[0].x = NONE;
X}
X
X
X
X/* Score a word at a given position.
X * Fills in permvec and pvec.
X */
Xfloat	pwd_score(pwdi, word, pos, permvec, pvec)
Xatrinfo		*pwdi;
Xchar		*word;
Xint			pos;
Xperment		permvec[];
Xint			pvec[];
X{
X	int		added, wordlen;
X	char	*p;
X	float	score;
X	ecinfo	*eci;
X
X	p = word;
X	wordlen = 0;
X	while (*p++ != NULL)  wordlen++;
X	eci = pwdi->eci;
X	added = permvec_from_string(pwdi->eci, word, pos, permvec);
X	if (added == ERROR)  return(-1.0);
X	added = permvec2pvec(pwdi->eci, permvec, pvec, -1, -1);
X	if (added == ERROR)  return(-1.0);
X	if (added < pwdi->min_total_chars) {
X		return(-1.0);
X		}
X
X	score = pvec_1score(pvec);
X#if DEBUG
X	print_pvec(stdout, pvec);
X	printf("Putting %s at %d, gets a score of %f\n",
X	        word, pos, score);
X#endif
X	return(score);
X}
X
X
X/* Select the best probable word for a given position.
X * Returns pointer to the word, or NULL.
X * Fills in pwdi with additional information.
X * Filtering parameters are passed in pwdi.
X */
Xchar	*pwd_best(pwdi, pos)
Xatrinfo	*pwdi;
Xint		pos;
X{
X	int		windex;
X	float	score;
X	perment	permvec[WDPERMSZ];
X	int		pvec[BLOCKSIZE+1];
X
X	pwd_guess_init(pwdi);
X
X	for (windex = 0 ; word_tab[windex] != NULL ; windex++)  {
X		score = pwd_score(pwdi, word_tab[windex], pos, permvec, pvec);
X		if (score < 0.0)  continue;
X		pwdi->gcount++;
X		pwdi->total_score += score;
X		if (score < pwdi->best_score) {
X			pwdi->best_score = score;
X			pwdi->best_trigram = word_tab[windex];
X			pvec_copy(pvec, pwdi->best_pvec);
X			permvec_copy(permvec, pwdi->best_permvec, WDPERMSZ);
X			}
X		}
X	if (pwdi->best_score < pwdi->max_score)
X		{return(pwdi->best_trigram);}
X	else
X		{return(NULL);}
X}
X
X
X
X/* Perform automatic guessing given a set of
X * filter parameters in an atrinfo structure.
X */
Xpwd_autoguess(pwdi)
Xatrinfo	*pwdi;
X{
X	int		pos;
X	char	*word;
X
X	for (pos = 0 ; pos < BLOCKSIZE ; pos++) {
X		word = pwd_best(pwdi, pos);
X		if (word != NULL) {
X			accept_permvec(pwdi, pwdi->best_permvec);
X			}
X		}
X}
END_OF_pword.c
if test 5380 -ne `wc -c <pword.c`; then
    echo shar: \"pword.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f screen.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"screen.c\"
else
echo shar: Extracting \"screen.c\" \(5791 characters\)
sed "s/^X//" >screen.c <<'END_OF_screen.c'
X/* Screen interface package
X *
X * Author: Bob Baldwin  June 1983
X * $Date: 86/01/15 16:04:16 $
X * $Log:	screen.c,v $
X * Revision 1.1  86/01/15  16:04:16  baldwin
X * Initial revision
X * 
X * Much code moved to terminal.c  baldwin 10/86
X *
X * Revision 1.2  85/01/10  02:35:10  simsong
X * Changed to termcap support
X * 
X * Revision 1.1  85/01/09  23:45:10  simsong
X * Initial revision
X * 
X */
X
X
X/* The screen consists of 24 lines and 80 columns.  The basic screen
X * operation is replacing the character that is already at a given
X * position with a new character.  That is, characters are placed,
X * they are not inserted.
X *
X * Various commands are provided for positioning the cursor, placing
X * strings on the screen, and removing characters.
X *
X * If a routine finds something wrong or inconsistent, it will print
X * an error message on the screen.
X */
X
X
X#include <stdio.h>
X#include <strings.h>
X#include "window.h"
X#include "terminal.h"
X#include "specs.h"
X
X
X
X/* These variables contain the current location of the cursor.
X * The origin, or home, of the  cursor is in the upper lefthand
X * corner of the screen.  That location is line 1, column 1.
X * The lower righthand corner of the screen is the location
X * identified by line 24, column 80.
X */
X
Xint	cline;
Xint	ccolumn;
X
X/* These must be 24 and 80 since only that region of the screen
X * is covered by the windows.  The wl_driver() routine will
X * exit if the cursor moves out of that area.
X */
Xint	MXLINE = MAXHEIGHT;	    /* Max line number */
Xint	MXCOL = MAXWIDTH;	    /* Max column number */
X
X
X
X/* Clear Screen.  This should be the first screen operation called in order
X * to initialize the line and column locations.
X */
Xclrscreen()
X{
X	enter_mode(SMNORMAL);
X	Puts(erase_scr);			    /* clear the screen */
X	cline = 1;
X	ccolumn = 1;
X}
X
X
X/* Set Cursor Position.  The next character places on the screen
X * will appear in the given line and column.
X *
X * Note: Bob's code is broken in that it assumes the screen goes
X * from 1..24 and 1..80, rather than 0..23 and 0..79. So this
X * routine subtracs one before it calls the curses routine.
X */
Xsetcursor(line, column)
Xint	line, column;		/* ranges: 1..24 and 1..80 inclusive */
X{
X	if (line < 1 || line > MXLINE  ||  column < 1 || column > MXCOL)  {
X		disperr("setcursor tried to move cursor off screen");
X		return;
X		}
X
X	cline = line;
X	ccolumn = column;
X	
X	enter_mode(SMNORMAL);
X	Puts(tgoto(cm,column-1,line-1));
X}
X
X
X/* Return the row location of the cursor (1 is in upper-left corner).
X */
Xrowcursor()
X{
X	return(cline);
X}
X
X
X/* Return the row location of the cursor (1 is in upper-left corner).
X */
Xcolcursor()
X{
X	return(ccolumn);
X}
X
X
X
X/* Get Cursor Position
X * The value returned equals 256*LineNumber + ColumnNumber
X */
Xint	getcursor()
X{
X	return((cline<<8)+ccolumn);
X}
X
X
X/* Jog the Cursor one position
X * The value of dir determines the direction of travel:
X * 1 = up, 2 = down, 3 = left, 4 = right.  A value other than one of those
X * four will cause an error message to be printed.
X */
X/* of course, there is a more ellegant way to implement this */
X
Xjogcursor(dir)
Xint	dir;
X{
X	switch(dir) {
X		case 1:	cline = (cline<=1) ? 1 : cline-1;
X			break;
X		case 2:	cline = (cline >= MXLINE) ? MXLINE : cline+1;
X			break;
X		case 3:	ccolumn = (ccolumn <= 1) ? 1 : ccolumn-1;
X			break;
X		case 4:	ccolumn = (ccolumn >= MXCOL) ? MXCOL : ccolumn+1;
X			break;
X		default:
X			disperr("jogcursor arg out of range");
X			return;
X		}
X
X	setcursor(cline, ccolumn);
X}
X
X
X/* Place String on the current line.  The cursor is advanced to the
X * position after the last character in the string, unless we hit the
X * edge of the screen in which case the cursor stays pinned to the
X * edge and doesn't move beyond it.
X */
Xplstring(s)
Xchar	*s;
X{
X	for ( ; *s != NULL ; s++)  {
X		putsym((*s) & 0377);
X	}
X	ccolumn += strlen(s);
X	if (ccolumn >= MXCOL)
X	  	ccolumn = MXCOL;	/* Assumes no wrap-around. */
X}
X
X
X/* Place a number of Spaces
X * This routine can also be used to erase characters on the screen by
X * overwriting them with spaces.
X */
Xplnspaces(n)
Xint	n;
X{	int	i;
X	if (n < 0)  {
X		disperr("plnspaces: negative arg");
X		return;
X		}
X
X	for (i = 0 ; i < n ; i++)  {
X		putsym(' ');
X		}
X	ccolumn += n;
X	if (ccolumn >= MXCOL)
X	  	ccolumn = MXCOL;
X}
X
X
X/* Place a Number of a given Character
X */
Xplnchars(n, c)
Xint	n;
Xint	c;
X{	
X	int	i;
X	if (n < 0)  {
X		disperr("plnchars: negative arg");
X		return;
X		}
X
X	for (i = 0 ; i < n ; i++)  {
X		putsym(c);
X		}
X	ccolumn += n;
X	if (ccolumn >= MXCOL)
X	  	ccolumn = MXCOL;
X}
X
X
X/* Vertical place a Character a Number of times.
X * This routine can be used to draw vertical lines using
X * a given character.  It correctly handles displaying
X * in column 80.
X * The cursor is moved to the position below the last character
X * placed on the screen.  However the cursor will not move below
X * the last line on the screen.
X */
Xvertnchars(n,c)
Xint	n;
Xint	c;
X{
X	int	i;
X	if (n < 0)  {
X		disperr("vertnchars: negative arg");
X		return;
X		}
X
X	for (i = 0 ; i < n ; i++)  {
X		putsym(c);
X		/* Assume cursor motion ok even in graphic mode. */
X		setcursor(++cline, ccolumn);
X		if (cline >= MXLINE)  {
X			cline = MXLINE;
X			break;
X			}
X		}
X}
X
X
X/* Delete characters after the cursor up until the End Of the Line
X */
Xdeleol()
X{
X	Puts(erase_eol);
X}
X
X
X/* Delete characters after the cursor up until the End Of the Screen
X */
Xdeleos()
X{
X	Puts(erase_eos);
X}
X
X
X/* Display Error message.  The message is a string that does not end
X * with a \n.
X */
Xdisperr(s)
Xchar	*s;
X{	int	sline, scolumn;		/* Saved line and column numbers. */
X
X	sline = cline;
X	scolumn  = ccolumn;
X
X/*	setcursor(1, 1);	 avoid bug when screen size unknown. */
X	printf("\n%s\n", s);
X/*	setcursor(sline, scolumn);  or position not set. */
X}
X
X
X/* Put a string to stdout without trailing newline.
X */
XPuts(s)
Xchar *s;
X{
X	while(*s)
X		putchar(*s++);
X}
END_OF_screen.c
if test 5791 -ne `wc -c <screen.c`; then
    echo shar: \"screen.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f tdriver.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"tdriver.c\"
else
echo shar: Extracting \"tdriver.c\" \(5804 characters\)
sed "s/^X//" >tdriver.c <<'END_OF_tdriver.c'
X/*
X * Test driver for automated trigram guessing.
X */
X
X#include	<stdio.h>
X#include	<math.h>
X#include	"window.h"
X#include	"specs.h"
X#include	"cipher.h"
X#include	"autotri.h"
X
X
Xextern	char	*atr_best();
Xextern			atr_autoguess();
Xextern	float	atr_score();
Xextern	int		accept_permvec();
X
Xatrinfo	myatrinfo;
Xchar	plainbuf[BLOCKSIZE+1];
Xint		naccepted, nwrong, nright;		/* Number of wires accepted / wrong. */
X
Xextern	char	mcbuf[];
X
X/* Test routine for automated trigram guessing. */
Xmain(argc, argv)
Xint		argc;
Xchar	*argv[];
X{
X	FILE	*inp;
X	int		i, blknum;
X	int		nblocks;
X	int		*saveperm;
X	long	filelength;
X	atrinfo	*atri;
X	char	permfbuf[100];
X	char	cipherfbuf[100];
X	char	plainfbuf[100];
X	char	*perm = ".perm";
X	char	*plain = ".txt";
X	char	*code = ".cipher";
X	char	*p, *q;
X
X	if (argc != 5)  {
X		printf("Usage: %s input_file_root", argv[0]);
X		printf(" min_score min_total_chars min_per_wire_chars\n");
X		exit(0);
X		}
X
X	p = cipherfile = cipherfbuf;
X	q = argv[1];
X	while (*p++ = *q++);
X	--p;
X	q = code;
X	while (*p++ = *q++);
X
X	p = plainfbuf;
X	q = argv[1];
X	while (*p++ = *q++);
X	--p;
X	q = plain;
X	while (*p++ = *q++);
X
X	p = permfile = permfbuf;
X	q = argv[1];
X	while (*p++ = *q++);
X	--p;
X	q = perm;
X	while (*p++ = *q++);
X
X	atri = &myatrinfo;
X
X	if (sscanf(argv[2], "%f", &atri->max_score) != 1)  {
X		printf("Could not parse the max score from %s.\n", argv[2]);
X		exit(0);
X		}
X
X	if (sscanf(argv[3], "%d", &atri->min_total_chars) != 1)  {
X		printf("Could not parse the min chars from %s.\n", argv[2]);
X		exit(0);
X		}
X
X	if (sscanf(argv[4], "%d", &atri->min_wire_chars) != 1)  {
X		printf("Could not parse the min chars from %s.\n", argv[2]);
X		exit(0);
X		}
X
X	permchgflg = FALSE;
X
X	letterstats = "mss.stats";
X	trigramstats = "trigrams.stats";
X	load_1stats_from(letterstats);
X	load_tri_from(trigramstats);
X
X	if ((inp = fopen(cipherfile, "r")) == NULL) {
X		printf("\nCannot open %s for reading.\n", cipherfile);
X		exit(0);
X		}
X	fseek(inp, 0L, 2);
X	filelength = ftell(inp);
X	fclose(inp);
X
X	nblocks = filelength / BLOCKSIZE;
X	if (nblocks > NPERMS)  nblocks = NPERMS;
X
X	printf("\t\tAutomated Trigram Guessing");
X	printf(" for %s\n\n",cipherfile);
X	printf("Max score = %4.2f", atri->max_score);
X	printf(".  Min total chars = %d", atri->min_total_chars);
X	printf(".  Min per wire chars = %d", atri->min_wire_chars);
X	printf("\n\n");
X	for (blknum = 0 ; blknum < nblocks ; blknum++) {
X		do_block(blknum, cipherfile, plainfbuf, atri);
X		saveperm = refperm(blknum);
X		for (i = 0 ; i < BLOCKSIZE ; i++)
X			saveperm[i] = atri->eci->perm[i];
X		}
X
X	permsave();
X}
X
X
Xdo_block(blknum, cfile, pfile, atri)
Xint		blknum;
Xchar	*cfile, *pfile;
Xatrinfo	*atri;
X{
X	int		i,c,x,y;
X	int		j;
X	int		pos;
X	char	*trigram;
X	int		charcount;				/* Number of characters deduced. */
X	float	score;
X	int		*dbsperm;
X	perment	permvector[PERMSZ];
X	int		pvec[BLOCKSIZE+1];
X	char	str[BLOCKSIZE+1];
X
X	cipherfile = pfile;
X	fillcbuf(blknum, plainbuf);
X	cipherfile = cfile;
X	fillcbuf(blknum, mcbuf);
X
X	dbsperm = refperm(blknum);
X	atr_init(mcbuf, dbsperm, atri);
X
X	ec_autoguess(atri->eci, 1.7);
X/*	decode(atri->eci->ciphertext, atri->eci->plaintext, atri->eci->perm);
X
X	naccepted = 0;
X	nwrong = 0;
X	nright = 0;
X	charcount = 0;
X	for (i = 0 ; i < BLOCKSIZE ; i++)  {
X		if (atri->eci->plaintext[i] != NONE)  charcount++;
X		if (((y=atri->eci->perm[i]) != NONE) && (i < y))  naccepted++;
X		}
X
X	printf("\n\nEquiv Guessing for block %d yields %d wires",blknum,naccepted);
X	printf(" and %d characters.\n\n", charcount);
X	ec_dplain(stdout, atri->eci);
X*/
X
X	naccepted = 0;
X	nwrong = 0;
X	nright = 0;
X
X	printf("\n\nStarting block %d.\n", blknum);
X#if TRUE
X	for (pos = 0 ; pos < BLOCKSIZE ; pos++) {
X		trigram = atr_best(atri, pos);
X		if (trigram != NULL) {
X			accept_permvec(atri, atri->best_permvec);
X/*			printf("\n");
X			printf("Best trigram at %d is '%s'", pos, atri->best_trigram);
X			pvec2str(str, atri->best_pvec);
X			printf(" which deduced '%s'", str);
X			printf(" with a score of %f", atri->best_score);
X			printf(".\n");
X			printf("There were %d guesses", atri->gcount);
X			printf(" yeilding a total score of %f", atri->total_score);
X			printf(".\n");
X*/
X			if (wrong_guess(plainbuf, pos, atri->best_trigram))  {
X				nwrong++;
X/*				printf("WRONG\n");*/
X				}
X			else {
X				nright++;
X/*				printf("CORRECT\n");*/
X				}
X			}
X		}
X#else
X	atr_autoguess(atri);
X#endif
X
X	decode(atri->eci->ciphertext, atri->eci->plaintext, atri->eci->perm);
X
X	charcount = 0;
X	for (i = 0 ; i < BLOCKSIZE ; i++)  {
X		if (atri->eci->plaintext[i] != NONE)  charcount++;
X		if (((y=atri->eci->perm[i]) != NONE) && (i < y))  naccepted++;
X		}
X
X	printf("\n\nPlaintext for block %d using %d wires", blknum, naccepted);
X	printf(" yields %d characters.", charcount);
X#if TRUE
X	printf("\nThere were %d right guesses and %d wrong ones.",nright, nwrong);
X#endif
X	printf("\n\n");
X	ec_dplain(stdout, atri->eci);
X}
X
X
X/* Look for best trigram at given position.
X */
Xtrytri(atri, pos, tindex)
Xatrinfo	*atri;
Xint		pos;
Xint		tindex;
X{
X	int		i;
X	int		j, x, y;
X	char	*trigram;
X	char	str[BLOCKSIZE+1];
X
X/*
X	trigram = atr_best(atri, pos, min_score);
X
X	if (trigram != NULL) {
X		printf("Best trigram is %s", atri->best_trigram);
X		pvec2str(str, atri->best_pvec);
X		printf(" which deduced '%s'", str);
X		printf("' with a score of %f", atri->best_score);
X		printf(".\n");
X		printf("There were %d guesses", atri->gcount);
X		printf(" yeilding a total score of %d", atri->total_score);
X		printf(".\n");
X		}
X*/
X}
X
X
X/* Return TRUE if the guess is wrong.
X */
Xint	wrong_guess(plaintext, position, trigram)
Xchar	*plaintext;
Xint		position;
Xchar	*trigram;
X{
X	char	*guess, *reality;
X
X	guess = trigram;
X	reality = &plaintext[position];
X
X	while (*guess) {
X		if (*guess++ != *reality++)  return(TRUE);
X		}
X
X	return(FALSE);
X}
X
X
X
Xkey	u_getkey()
X{
X}
X
Xkeyer	topktab[] ={{0, NULL}};
X
X
Xchar *quitcmd(arg)
Xchar	*arg;
X{
X	printf("\n");
X	exit(1);
X}
END_OF_tdriver.c
if test 5804 -ne `wc -c <tdriver.c`; then
    echo shar: \"tdriver.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f test1.txt -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"test1.txt\"
else
echo shar: Extracting \"test1.txt\" \(6301 characters\)
sed "s/^X//" >test1.txt <<'END_OF_test1.txt'
XData may be passed to the procedure through value
Xparameters, and return values obtained through reference parameters.
XThe caller is suspended pending the return of the callee.  However,
Xinvocations differ from local procedure calls in several important
Xways.  The first, which is particular to Eden, is the requirement of
Xan accompanying capability to name to the target Eject.  Therefore,
Xthe Eject programmer is quite aware of the fact that an invocation is
Xnot "just another procedure call".  A second difference is
Xperformance.  Invocations will be far slower than a local procedure
Xcall simply because there is more going on.  The Eden kernel must
Xlocal the target Eject; network traffic may be necessary if the target
XEject is not on the same machine; parameters must be packaged into a
Xmessage to be sent to the target Eject; the target Eject must
Xunpackage the message and call the desired procedure with the
Xparameter values; the target Eject must package the results into a
Xmessage to be sent to the invoking Eject; finally, the invoking Eject
Xmust unpackage the results and return them to the calling procedure.
XIn light of such a performance deficit, Eject programmers may be
Xreluctant to structure a particular collection of Ejects in novel ways
Xin order to avoid the invocation overhead.
X
XThe thesis of this paper is to demonstrate that acceptable performance
Xfor invocations can be obtained in the Eden environment by paying
Xclose attention to the design and implementation of modules that
Xsupport remote procedure calls.  For the purposes of this thesis, the
Xscope will be limited to the Ejects' point of view.  The Eden kernel
Xwill not be considered.
X
X\section{Some Background}\label{introbck}
X
XEden has had a long history of improvements to its invocation
Xmechanism.  Previous work has concentrated on removing extraneous {\it
Xinter-process communication} (IPC) messages.  Particularly in Eden's
Xcase, IPC messages are very expensive.  Eden is built on top of Unix;
Xtherefore, each IPC message from an Eject to the Eden kernel, and vice
Xversa, involves at least a Unix process switch and copying the IPC
Xmessage into and out of the Unix kernel.
X
XThe first versions of Eden required 14 IPC messages to be sent per
Xlocal invocation.  A local invocation occurs when the invoking Eject
Xand the target Eject reside on the same physical machine.
XWhat was 2-process kernel's role in this setup?
X
XThe 2-process Eden kernel was finally replaced by a 1-process Eden
Xkernel, immediately reducing the number of messages required for an
Xinvocation by eliminating the IPC messages between the two kernel
Xprocesses.
X
XThe final reduction in IPC messages sent per invocation occurred
Xduring the summer of 1984.  Two more IPC messages were eliminated.
XOne of the messages eliminated was the IPC message from the Eden
Xkernel to the invoking Eject that communicated the {\it invocation
Xhandle} assigned to that particular call.  It was replaced by a scheme
Xwhere the invoking Eject was allowed to generate its own {\it local
Xinvocation handle} to communicate with the Eden kernel, and the Eden
Xkernel would generate its own unique handle in order to communicate
Xwith another Eden kernel or the target Eject.  The Eden kernel
Xguarantees that the reply message to an invocation will be stamped
Xwith the invoking Eject-generated handle.  The other IPC message
Xeliminated was the status message from the Eden kernel to the target
XEject confirming the kernel's approval of the reply message (format,
Xor contents if capabilities were contained in the reply).  The more
Xlogical scheme of notifying the invoking Eject of the failure status
Xof the reply, or the actual reply if the status was success, is now
Xbeing used.  The result of all these improvements is shown in figure
X\ref{oldfig}.  (See section \ref{oldexp} for an explanation of figure
X\ref{oldfig}.)
X
X\section{Related Work}\label{introrel}
X
XNelson's thesis thoroughly examines remote procedure calls.  He
Xstudies a number of implementations, and proposes a design for
XEmmisary(?), a new RPC mechanism with excellent transparency and
Xexceptional performance.  To attain exceptional performance, Nelson
Xgives a list of "lessons" that an RPC mechanism must have.  The
Xlessons are summarized here for the reader:
X
X\begin{itemize}
X\end{itemize}
X
XIn designing an RPC mechanism, it is convenient to use a layer model.
XHowever, strict adherance to the layer model often results in poor
Ximplementations.  There is a prohibitive cost associated with highly
Xmodular implementations that cannot be tolerated in RPC
Ximplementations.  In proposing a solution to the asynchrony
Xproblem, Cooper\cite{soft} advocates "soft layering".  The idea of soft
Xlayering may be applied to any naturally layered system whose layers
Xmust work well together.
X
X\section{Structure of Thesis}\label{introstruct}
X
XChapter \ref{old} examines the deficiencies of the current Eden
Xinvocation mechanism.  The reader is taken on a tour through the
Xprocess of initiating an invocation and receiving its reply, and
Xreceiving a new invocation and replying to the invocation.
X
XChapter \ref{new} proposes restructuring the dispatcher module for
Xsynchronous invocations (by far the most heavily used form of
Xcommunication within Eden) and breaking down the "hard layering" that
Xcurrently exists between the various layers that support invocations,
Xfrom the Eject's point of view, in order to obtain significant
Xperformance gains.
X
X\chapter{A Closer Look at the Eden Invocation Mechanism}\label{old}
X
X\section{The Dispatcher -- Interface and Internals}\label{olddis}
X
X\section{Flow of Data -- CIP, Stub, and ESCII}\label{olddat}
X
X\section{Summary}\label{oldsum}
X
X\chapter{An Alternative Synchronous Invocation Mechanism}\label{new}
X
X\section{Assumptions and Limitations}\label{newass}
X
X\section{The Dispatcher -- Interface and Internals}\label{newdis}
X
X\section{A Word About Buffer Management}\label{newbuf}
X
X\section{Flow of Data -- CIP, Stub, and ESCII}\label{newdat}
X
X\section{Results and Timings}\label{newres}
X
X\section{Summary}\label{newsum}
X
X\chapter{Conclusions and Further Work}\label{concl}
X
X\section{Lessons Re-learned}\label{conles}
X
X\section{Soft Layering}\label{conlay}
X
X\section{Modularization and Interfaces}\label{conmod}
X
X\section{Further Work}\label{confur}
X
X\end{document}
X
END_OF_test1.txt
if test 6301 -ne `wc -c <test1.txt`; then
    echo shar: \"test1.txt\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f window.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"window.h\"
else
echo shar: Extracting \"window.h\" \(6063 characters\)
sed "s/^X//" >window.h <<'END_OF_window.h'
X/* 
X * Structure definitions for the window and keyboard routines.
X * The first half of this file contains structure declarations.
X * The second half contains functions, static variables, and
X * key value declarations.
X *
X * Robert W. Baldwin,  December 1984
X */
X
X
X/* Parameters */
X
X#define	MAXWIDTH	80		/* Max width of a display line. */
X#define	MAXHEIGHT	24		/* Max height of a window. */
X
X
X/* Key stroke handler structure.
X * The table is searched to find a key that matches the command typed
X * by the user.  The corresponding keyproc is then invoked.
X * The last entry in the table can have keychar == 0  or  -1.
X * If it is -1, that entry's corresponding
X * procedure is invoked with any characacter not previously matched.
X * If it is 0, then the table driver knows it should look at 
X * another table (if any).
X * See terminal.h and .c for more info on command keys.
X */
X
X#define	key	int		/* Command code in high byte, arg in low. */
X#define	keyer	struct xkeyer	/* Typically have a table of these. */
X
Xstruct	xkeyer	{
X	key	keychar;	/* Must be -1 or 0 for last entry in table. */
X	int	(*keyproc)();	/* Called with: window and key arg. */
X	};
X
X
X/* Common window definition. */
X
X#define zwindow \
X	int	worg_row;	/* Row and column of the upper lefthand corner */\
X	int	worg_col;	/* of this window in global screen coordinates */\
X	int	wheight;	/* Number of rows in window. */\
X	int	wwidth;		/* Number of columns. */\
X	int	wcur_row;	/* Location of cursor relative to the origin. */\
X	int	wcur_col;	/* Equals (1,1) if at window's origin. */\
X	char	*wprivate;	/* Ptr to window's private data. */\
X	int	(*wfirst)();	/* Called when cursor enters window. */\
X	int	(*wlast)();	/* Called after cursor leaves window. */\
X	int	(*wredraw)();	/* Called to redraw window over junk. */\
X	int	(*wkey)();	/* Called when key pressed and window is active*/\
X	keyer	*wkeyprocs	/* Procs that perform key stroke actions. */
X
X
X/* Specification of window procedures. */
X
X/* The follow declarations are assumed: gwindow *w;  key k;  keyer *ktab;
X * int	currow, curcol;  (cursor location in local coordinates).
X *
X * wfirst(w, currow, curcol)
X *    Called when cursor first enters window,
X *	  Responsible for setting w->wcur_row, w->wcur_col to desired value.
X *	  The display's cursor is already at the given coordinates.
X *
X * wlast(w)
X *    Called when the driving loop notices that the cursor is no longer
X *    in the currently active window.  Responsible for any cleanup needed
X *    before another window can become active.
X *
X * wredraw(w)
X *    Called to cleanup junk on the screen, usually at the user's request.
X *    The routine should set every character within its window.
X *	  It should leave the cursor at some reasonable place, such as the
X *    place it last was within this window.
X *
X * wkey(w, k)
X *    Called when a key is pressed, and this window is active.
X *    Responsible for performing the desired action.  Sub-windows
X *    can assume that common keystrokes (like arrow movement) have
X *    already been handled.
X */
X
X/* General purpose window. */
X
X#define	gwindow		struct	xgwindow
X
Xstruct 	xgwindow	{
X	zwindow;
X	};
X
X
X/* Display line for fixed and editable strings. */
X
X#define	displine	struct	xdispline
X
Xstruct	xdispline	{
X	zwindow;
X	int	dl_min_col;	/* Min location of cursor relative to origin */
X	int	dl_max_col;	/* Max location of cursor relative to origin */
X	int	dl_length;	/* Last non-blank column in line. */
X	char	dl_chars[MAXWIDTH+1];	/* Null terminated string whose len */
X					/*  always == the width of the line. */
X	};
X
X
X/* Window containing changeable lines of text. */
X
X#define	twindow		struct	xtwindow
X
Xstruct	xtwindow	{
X	zwindow;
X	displine	**dlines;	/* Null terminated array of lines. */
X	};
X
X
X/* Procedures from windowlib.c */
X
Xextern	int	wl_driver(/* wtab */);	/* Run window system. */
Xextern	int	wl_refresh(/* wtab */);	/* Redraw all windows. */
Xextern	int	wl_rcursor(/* w */);	/* Restore old cursor position. */
Xextern	int	wl_setcur(/* w, row, col */);	/* Set cursor relative. */
Xextern	int	wl_noop(/* w */);	/* Do nothing. */
Xextern	int	wl_hascur(/* w */);	/* Return TRUE if cursor in window. */
Xextern	int	wl_draw(/* w */);	/* Invoke window's redraw routine. */
Xextern	int	wl_twdraw(/* w */);	/* Redraw for twindow. */
Xextern	int	wl_dldraw(/* w */);	/* Redraw for displine. */
Xextern	wl_dlleft(/* w */), wl_dlright(/* w */);
Xextern	wl_dlfdel(/* w */), wl_dlbdel(/* w */), wl_dlclr(/* w */);
Xextern	wl_dlinsert(/* w, k */);
Xextern	wl_dlgetvar(/* w, buf */);	/* Fill buf with variable part. */
Xextern	wl_dlsetvar(/* w, str */);	/* Set variable part from string. */
Xextern	wl_nxtarg(/* line */);		/* Adv to next %. */
Xextern	int	clrdline(/* dl */);	/* Blankout all chars in displine. */
Xextern	int	setdline(/* dl */);	/* Set first chars of displine. */
Xextern	int	wl_erase(/* w */);	/* Blank out a window. */
Xextern	int	wl_outline(/* w */);	/* Outline w/o changing insides. */
Xextern	int	key2graphic(/* c */);	/* Returns key to represent char c. */
X
X
X/* Procedures from keylib.c */
Xextern	int	getkey();		/* Get a key stroke from the user. */
Xextern	int	dokey(/* w, k */);	/* Invokes window's keyproc for k. */
Xextern	int	ddokey(/* w,k,ktab */);	/* Invokes keyproc for k found in ktab. */
Xextern	int	noopkey(/* w, k */);	/* A do-nothing keyproc. */
X
X
X/* These four routines move the cursor and if it is still within
X * the window, w, they update the window's cursor position field.
X * They can be used as keyprocs.
X */
Xextern	int	jogleft(/* w, k */);
Xextern	int	jogright(/* w, k */);
Xextern	int	jogup(/* w, k */);
Xextern	int	jogdown(/* w, k */);
X
X
X/* Static variables from keylib.c */
X
Xextern	keyer	arwktab[];		/* Default key table for arrow keys. */
X					/* They call the correct jog routine */
X
X
X
X/* ASCII character definitions
X */
X#define	CNTRL		037
X#define CTRL_P		(CNTRL & 'P')
X#define CTRL_N		(CNTRL & 'N')
X#define CTRL_B		(CNTRL & 'B')
X#define CTRL_F		(CNTRL & 'F')
X#define CTRL_C		(CNTRL & 'C')   /* added by slg */
X#define	RETURN		(CNTRL & 'M')
X#define	LINEFEED	(CNTRL & 'J')
X#define	TAB		(CNTRL & 'I')
X#define	SPACE		(' ')
X
END_OF_window.h
if test 6063 -ne `wc -c <window.h`; then
    echo shar: \"window.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 3 \(of 11\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

-- 
Rich $alz			rsalz@pineapple.bbn.com
Cronus Project, BBN Labs	"Anger is an energy"
