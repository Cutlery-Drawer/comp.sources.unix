Path: uunet!rs
From: rs@uunet.UU.NET (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v10i046:  CRC Plotting Package, Part02/06
Message-ID: <605@uunet.UU.NET>
Date: 9 Jul 87 01:14:19 GMT
Organization: UUNET Communications Services, Arlington, VA
Lines: 2894
Approved: rs@uunet.UU.NET

Submitted-by: "Wombat" <rsk@j.cc.purdue.edu>
Posting-Number: Volume 10, Issue 46
Archive-name: crc_plot/Part02



#	This is a shell archive.
#	Remove everything above and including the cut line.
#	Then run the rest of the file through sh.
#----cut here-----cut here-----cut here-----cut here----#
#!/bin/sh
# shar:	Shell Archiver
#	Run the following text with /bin/sh to create:
#	lib
mkdir lib
chdir lib
cat << \SHAR_EOF > crc.h
#
/*
	crc.h - include file for the CRC graphics package

	Carl Crawford
	Purdue University
	W. Lafayette, IN 47907

	Jan. 1981
*/

#include <stdio.h>
#include <math.h>
#include <signal.h>

unsigned short *_pic;   /* pointer to bit plane */
int     _xp,_yp;        /* integer position */
float   _axp,_ayp;      /* real position */
float   _xo,_yo;        /* current origin */
int     _ud;            /* indicates up/down for pen */
int     _error;         /* indicates error in plotting */
float	_fac;		/* scale factor */
float	_ipsz;		/* size of the internal file - 1 */
float	_ipsz10;	/* ipsize / 10.0 */
int     DEV;            /* major device number */
char    DEVN;           /* minor device number */
int	BLANK;		/* 1 = don't blank device before plotting */
char	*STORE;		/* default storage file */
char	*PLOTFILT;	/* Plot Filter Name */
float	TICDIS;		/* distance between tic marks on the axis */
float	HEIGHT;		/* char height in axis routines */
int	DIGITS;		/* number of dec. digits + 1 in axis annotation */
unsigned _bufsize;	/* size of point buffer */
char	_abuf[100];	/* char buffer for anyone */
char	*SITE;		/* site for gplp */ 
FILE	*_pipe_fd;	/* file descriptor for pipes and pseudo pipes */
int	(*_isig)();	/* save SIGINT signal */
int	(*_qsig)();	/* save SIGQUIT signal */
int	(*_hsig)();	/* save SIGHUP signal */
int	_intty[3];	/* save current tty modes in here */

/*	control characters */

#define	NUL 0		/* <nul> */
#define	SOH 1		/* <soh> */
#define	STX 2		/* <stx> */
#define	ETC 3		/* <etc> */
#define ETX 3           /* <etx> */
#define EOT 4           /* <eot> */
#define ENQ 5           /* <enq> */
#define ACK 6		/* <ack> */
#define BEL 7		/* <bel> */
#define BS 8            /* <bs> */
#define HT 9		/* <ht> */
#define LF 10           /* <lf> */
#define VT 11           /* <vt> */
#define FF 12           /* <ff> */
#define CR 13           /* <cr> */
#define SO 14           /* <so> */
#define SI 15           /* <si> */
#define DLE 16		/* <dle> */
#define DC1 17		/* <dc1> */
#define DC2 18		/* <dc2> */
#define DC3 19		/* <dc3> */
#define DC4 20		/* <dc4> */
#define NAK 21		/* <nak> */
#define	SYN 22		/* <syn> */
#define ETB 23          /* <etb> */
#define CAN 24		/* <can> */
#define EM 25		/* <em> */
#define SUB 26          /* <sub> */
#define ESC 27          /* <esc> */
#define	FS 28		/* <fs> */
#define GS 29           /* <gs> */
#define RS 30           /* <rs> */
#define US 31           /* <us> */



/*      variables for HP and TEK */

int _CM;	/* current mode */
int _X;		/* x position */
int _Y;		/* y position */
int _FILL;	/* number of fill characters */

#define	BINARY_FONT_FILE	"/usr/unsup/lib/crc/font.5x7"
#define	PLOTBIN			"/usr/bin/plot"

#define	BIT	0	/* major device table */
#define GOV	1
#define IMAGE	2
#define	GGOV	3
#define	GIMAGE	4
#define	PLOT	5
#define	TEK	6
#define HP	7

#define MBIT	4
/* maximum device in bit plane mode */

/*
	Major and minor device tables

	DEV     DEVN    dev     OUTPUT
	0       0       0       file or standard output
		1       8       Versatec through gp (I)
		2       16      Printronix through gplp (I) and opr (I)

	1       0       1       Comtal graphics overlay 0(*)
		1       9       Comtal graphics overlay 1(*)
		2       17      Comtal graphics overlay 2(*)


	2       0       2       Comtal image image displayed(*)
		1       10      Comtal image 0(*)
		2       18      Comtal image 1(*)
		3       26      Comtal image 2(*)

	3       0       3       Grinnell graphics overlay 0(*)
		1       11      Grinnell graphics overlay 1(*)
		2       19      Grinnell graphics overlay 2(*)
		3       27      Grinnell graphics overlay 3(*)

	4       0       4       Grinnell Image being Displayed (*)
		1       12      Grinnell Image Plane 0(*)
		2       20      Grinnell Image Plane 1(*)
		3       28      Grinnell Image Plane 2(*)
		4       36      Grinnell Image Plane 3(*)
		5       44      Grinnell Image Plane 4(*)

	5	0	5	Plot Subroutines

	6       0       6       Tektronix through standard output
		1	14	Retro-Graphics through standard output
		2	22	Tektronix 4113

	7       0       7       HP through /u/lib/graphics/hpd

(*) - through /u/lib/graphics/gd

*/
SHAR_EOF
cat << \SHAR_EOF > Makefile
# crc/lib Makefile
#
# $Header: /usr/src/unsup/bin/crc/lib/RCS/Makefile,v 1.7 87/05/06 23:27:49 rsk Local $
#
#	Richard S. Kulawiec, Purdue University Computing Center
#	9/26/86
#

BIN=	${DESTDIR}/usr/unsup/bin
LIB=	${DESTDIR}/usr/unsup/lib/crc

OWNER= binary
GROUP= system
MODE= 751
SHMODE= 755
SUMODE= 4751
SGMODE= 2751
TXTMODE= 644

INCLUDE=
CDEFS=
CFLAGS= -O ${CDEFS} ${INCLUDE}

HDR=	crc.h
SRC=	_clean.c _err.c _plotend.c _schk.c _ssize.c alpha.c alpha_.c axis.c \
	axis_.c draxis.c draxis_.c axisv.c axisv_.c dline.c dline_.c factor.c \
	factor_.c fname.c fname_.c laxis.c laxis_.c line.c line_.c newpen.c \
	newpen_.c number.c number_.c plot.c plot_.c plotp.c plots.c plots_.c \
	plotsubs.c scale.c scale_.c site.c site_.c sline.c sline_.c speed.c \
	speed_.c symbol.c symbol_.c where.c where_.c
OBJ=	_clean.o _err.o _plotend.o _schk.o _ssize.o alpha.o alpha_.o axis.o \
	axis_.o draxis.o draxis_.o axisv.o axisv_.o dline.o dline_.o factor.o \
	factor_.o fname.o fname_.o laxis.o laxis_.o line.o line_.o newpen.o \
	newpen_.o number.o number_.o plot.o plot_.o plotp.o plots.o plots_.o \
	plotsubs.o scale.o scale_.o site.o site_.o sline.o sline_.o speed.o \
	speed_.o symbol.o symbol_.o where.o where_.o
SOURCE=	Makefile ${SRC} ${HDR}


all:		libG.a

libG.a:		$(OBJ) crc.h
		ar r libG.a $(OBJ); ranlib libG.a

clean:	FRC
	rm -f Makefile.bak libG.a *.o a.out core errs lint.errs tags

depend:	${HDR} ${SRC}
	maketd -a ${CDEFS} ${INCLUDE} ${SRC}

install: all FRC
	-install -c -m ${TXTMODE} -o ${OWNER} -g ${GROUP} libG.a ${LIB}
	-ranlib ${LIB}/libG.a

lint: ${HDR} ${SRC} FRC
	lint ${CDEFS} ${INCLUDE} ${SRC}

print: source FRC
	lpr -J"crc/lib source" ${SOURCE}

source: ${SOURCE}

spotless: clean 
	rcsclean ${SOURCE}

tags: ${HDR} ${SRC}
	ctags -t ${HDR} ${SRC}

${SOURCE}:
	co $@

FRC:

# DO NOT DELETE THIS LINE - make depend DEPENDS ON IT
I=/usr/include
S=/usr/include/sys

_clean.o: $I/math.h $I/signal.h $I/stdio.h _clean.c crc.h

_err.o: $I/math.h $I/signal.h $I/stdio.h _err.c crc.h

_plotend.o: $I/math.h $I/signal.h $I/stdio.h _plotend.c crc.h

_schk.o: $I/math.h $I/signal.h $I/stdio.h _schk.c crc.h

_ssize.o: $I/math.h $I/signal.h $I/stdio.h _ssize.c crc.h

alpha.o: $I/math.h $I/signal.h $I/stdio.h alpha.c crc.h

alpha_.o: $I/math.h $I/signal.h $I/stdio.h alpha_.c crc.h

axis.o: $I/math.h $I/signal.h $I/stdio.h axis.c crc.h

axis_.o: $I/math.h $I/signal.h $I/stdio.h axis_.c crc.h

draxis.o: $I/math.h $I/signal.h $I/stdio.h crc.h draxis.c

draxis_.o: $I/math.h $I/signal.h $I/stdio.h crc.h draxis_.c

axisv.o: $I/math.h $I/signal.h $I/stdio.h axisv.c crc.h

axisv_.o: $I/math.h $I/signal.h $I/stdio.h axisv_.c crc.h

dline.o: $I/math.h $I/signal.h $I/stdio.h crc.h dline.c

dline_.o: $I/math.h $I/signal.h $I/stdio.h crc.h dline_.c

factor.o: $I/math.h $I/signal.h $I/stdio.h crc.h factor.c

factor_.o: $I/math.h $I/signal.h $I/stdio.h crc.h factor_.c

fname.o: $I/math.h $I/signal.h $I/stdio.h crc.h fname.c

fname_.o: $I/math.h $I/signal.h $I/stdio.h crc.h fname_.c

laxis.o: $I/math.h $I/signal.h $I/stdio.h crc.h laxis.c

laxis_.o: $I/math.h $I/signal.h $I/stdio.h crc.h laxis_.c

line.o: $I/math.h $I/signal.h $I/stdio.h crc.h line.c

line_.o: $I/math.h $I/signal.h $I/stdio.h crc.h line_.c

newpen.o: $I/math.h $I/signal.h $I/stdio.h crc.h newpen.c

newpen_.o: $I/math.h $I/signal.h $I/stdio.h crc.h newpen_.c

number.o: $I/math.h $I/signal.h $I/stdio.h crc.h number.c

number_.o: $I/math.h $I/signal.h $I/stdio.h crc.h number_.c

plot.o: $I/math.h $I/signal.h $I/stdio.h crc.h plot.c

plot_.o: $I/math.h $I/signal.h $I/stdio.h crc.h plot_.c

plotp.o: $I/math.h $I/signal.h $I/stdio.h crc.h plotp.c

plots.o: $I/math.h $I/signal.h $I/stdio.h crc.h plots.c

plots_.o: $I/math.h $I/signal.h $I/stdio.h crc.h plots_.c

plotsubs.o: $I/math.h $I/signal.h $I/stdio.h crc.h plotsubs.c

scale.o: $I/math.h $I/signal.h $I/stdio.h crc.h scale.c

scale_.o: $I/math.h $I/signal.h $I/stdio.h crc.h scale_.c

site.o: $I/math.h $I/signal.h $I/stdio.h crc.h site.c

site_.o: $I/math.h $I/signal.h $I/stdio.h crc.h site_.c

sline.o: $I/math.h $I/signal.h $I/stdio.h crc.h sline.c

sline_.o: $I/math.h $I/signal.h $I/stdio.h crc.h sline_.c

speed.o: $I/math.h $I/signal.h $I/stdio.h crc.h speed.c

speed_.o: $I/math.h $I/signal.h $I/stdio.h crc.h speed_.c

symbol.o: $I/math.h $I/signal.h $I/stdio.h crc.h symbol.c

symbol_.o: $I/math.h $I/signal.h $I/stdio.h crc.h symbol_.c

where.o: $I/math.h $I/signal.h $I/stdio.h crc.h where.c

where_.o: $I/math.h $I/signal.h $I/stdio.h crc.h where_.c

# *** Do not add anything here - It will go away. ***
SHAR_EOF
cat << \SHAR_EOF > _clean.c
/*
	_clean - clean up after interrupts

	The CRC graphics package

	Carl Crawford
	Purdue University
	W. Lafayette, IN 47907

	Spetember 1981
*/

#include "crc.h"

_clean()
{
	if(DEV > MBIT)_plotend();
	exit(1);
}
SHAR_EOF
cat << \SHAR_EOF > _err.c
#include	"crc.h"

/*
	_err - clean up after error

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

_err(s1,s2)
char	*s1,*s2;
{
	if(DEV > MBIT)_plotend();

	fputs(s1,stderr);
	fputs(s2,stderr);
	fputc('\n',stderr);
	exit(1);
}
SHAR_EOF
cat << \SHAR_EOF > _plotend.c
/*
	_plotend - clean up HP and Tektronix

	The CRC graphics package

	Carl Crawford
	Purdue University
	W. Lafayette, IN 47907

	September 1981
*/

#include "crc.h"

_plotend()
{
	if(DEV == HP){
		newpen(0);
		plotp(3);
		pclose(_pipe_fd);
	}
	if(DEV == TEK){
		alpha();
		fclose(_pipe_fd);
		stty(0,_intty);
	}
	if(DEV == HP || DEV == TEK){
		signal(SIGHUP,_hsig);
		signal(SIGINT,_isig);
		signal(SIGQUIT,_qsig);
	}
	if(DEV == PLOT && PLOTFILT)
		pclose(_pipe_fd);
}
SHAR_EOF
cat << \SHAR_EOF > _schk.c
/*
	_schk - check for idenitcal scale values

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

_schk(x,y)
float	x,y;
{
	if(x == y)_err("scale values identical","");
}
SHAR_EOF
cat << \SHAR_EOF > _ssize.c
/*
	_ssize - calculate the length of a string

	The CRC graphics package

	Carl Crawford
	Purdue University
	W. Lafayette, IN 47907

	September 1981
*/

#include	"crc.h"

int _ssize(label)
char label[];
{
	float ns;
	int nns,i;
	ns= .5;
	for(i=0;label[i] != '\0';i++){
		if(label[i] == '$'){
			i++;
			switch (label[i]){
			case '~': /* infinity */
				ns=ns+1.33;
				break;
			case ':': /* super score */
			case ';': /* under score */
			case '[': /* open subscript */
			case ']': /* close subscript */
			case '{': /* open superscript */
			case '}': /* close superscript */
				break;
			case '_': /* back space */
				ns=ns-1.0;
				break;
			case ' ':
				ns=ns+0.5;
				break;
			default:
				ns=ns+1.0;
				break;
			}
		}
		else ns=ns+1.0;
	}
	nns=(int)ns;
	return(nns);
}
SHAR_EOF
cat << \SHAR_EOF > alpha.c
#include "crc.h"

/*
	alpha - put tektronix in alpha numermic mode

	The CRC graphics package

	Carl Crawford
	Purdue University
	W. Lafayette, IN 47907

	April 15, 1981
*/

alpha()
{
	if(DEV == TEK){
		_CM &= 0177774;
		plotp(US);
		if(DEVN)plotp(CAN);
		fflush(_pipe_fd);
	}
	if(DEV == HP){
		if((_CM & 1)== 0)return;
		plotp('}');
		plotp('~');
		plotp('\'');
		_CM &= 0177774;
	}
}
SHAR_EOF
cat << \SHAR_EOF > alpha_.c
#include	"crc.h"

/*
	alpha_ - f77 callable alpha

	The CRC graphics package

	carl crawford
	purdue university
	july 1980
*/


alpha_()
{
	alpha();
}
SHAR_EOF
cat << \SHAR_EOF > axis.c
#include	"crc.h"
/*
	axis - interface to 'draxis'

	The CRC graphics package

*/

axis(x,y,label,xy,size,xmin,xmax,idata)
float	x,y,size,xmin,xmax;
int	xy,idata;
char	*label;
{
	float angle;
	int xydum;
	angle = 0.0;
	xydum = 1;
	switch(xy){
		case 0:
			break;
		case 1:
			angle = 90.0;
			xydum = -1;
			break;
		case 2:
			xydum = -1;
			break;
		case 3:
			angle = 90.0;
			break;
	}	
	draxis(x,y,label,angle,xydum,size,xmin,xmax,idata);
}
SHAR_EOF
cat << \SHAR_EOF > axis_.c
/*
	axis_ - F77 interface to 'axis'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

axis_(x,y,label,xy,size,min,max,flag,labell)
float	*x;
float	*y;
char	*label;
long int	*xy;
float	*size;
float	*min;
float	*max;
long	int	*flag;
long	int	labell;
{
	axis(*x,*y,label,(int)*xy,*size,*min,*max,(int)*flag);
}
SHAR_EOF
cat << \SHAR_EOF > axisv.c
#include	"crc.h"

/*
	axisv - set variables for 'axis' subroutine

	The CRC graphics package

	carl crawford
	purdue university
	west lafayette, indiana 47907

	april 1980
*/

axisv(ticdis,digits)
float	ticdis;
int	digits;
{
	TICDIS = ticdis;
	DIGITS = digits;
}
SHAR_EOF
cat << \SHAR_EOF > axisv_.c
#include	"crc.h"

/*
	axisv_ - f77 callable version of 'axisv'

	The CRC graphics package

	carl crawford
	purdue university
	west lafayette, indiana 47907

	april 1980
*/

axisv_(ticdis,digits)
float	*ticdis;
long	int	*digits;
{
	axisv(*ticdis,(int) *digits);
}
SHAR_EOF
cat << \SHAR_EOF > dline.c
/*
	dline - draw dashed line

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

dline(x,y,n,dsh,gap,m,lx,ly)
float 	*x,*y,*dsh,*gap,lx,ly;
int	n,m;
{
	float	xn,yn,xn1,yn1,dx,dy,len,lenl;
	float	at,nx,ny,xs,ys;
	int	i,lp,dshgap,sp;

	if(m == 0){
		line(x,y,n,0,lx,ly); 
		return;
	}
	lenl = dsh[0];	
	dshgap = 0;
	sp = 0;
	lp = 0;
	xn = x[n];	
	xn1 = x[n+1];
	yn = y[n];	
	yn1 = y[n+1];
	_schk(xn,xn1);
	_schk(yn,yn1);
	xn1 = lx / (xn1 - xn);
	yn1 = ly / (yn1 - yn);

	plot((x[0]-xn)*xn1,(y[0]-yn)*yn1,3);
	for(i=1;i<n;i++){
		dx = (x[i] - x[i-1]) * xn1;
		dy = (y[i] - y[i-1]) * yn1;
		len = sqrt( (dx*dx) + (dy*dy));
		if(len <= lenl){
			plot((x[i]-xn)*xn1,(y[i]-yn)*yn1,2+dshgap);
			if(sp){
				x[i-1] = xs;
				y[i-1] = ys;
				sp = 0;
			}
			if((lenl -= len) == 0.)
				if(++dshgap == 1){
					lenl = gap[lp];
				}
			else{
				dshgap = 0;
				if(++lp == m)lp =0;
				lenl = dsh[lp];
			}
		}
		else{
			at = atan2(dy,dx);
			nx = cos(at)*lenl;
			ny = sin(at)*lenl;
			plot((x[i-1]-xn)*xn1+nx,(y[i-1]-yn)*yn1+ny,2+dshgap);
			if(++dshgap  == 1){
				lenl = gap[lp];
			}
			else{
				dshgap = 0;
				if(++lp == m) lp = 0;
				lenl = dsh[lp];
			}
			if(sp == 0){
				xs = x[i-1];
				ys = y[i-1];
				sp = 1;
			}
			x[i-1] += (nx/xn1);
			y[i-1] += (ny/yn1);
			i--;
		}
	}
}
SHAR_EOF
cat << \SHAR_EOF > dline_.c
/*
	dline_ - F77 interface to 'dline'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

dline_(x,y,n,dsh,gap,m,lx,ly)
float	*x;
float	*y;
long	int	*n;
float	*dsh;
float	*gap;
long	int	*m;
float	*lx;
float	*ly;
{
	dline(x,y,(int)*n,dsh,gap,(int)*m,*lx,*ly);
}
SHAR_EOF
cat << \SHAR_EOF > draxis.c
#include	"crc.h"

/*
	draxis - draw numerically annotated axes for slant axes

	The CRC graphics package

	carl crawford
	purdue univeristy
	w. lafayette, in 47907

	may 1980
*/
#define	PI	3.141592
#define SMALL	0.000001

draxis(x,y,label,angle,xy,size,xmin,xmax,idata)
/*		xy	=	1	clockwise
			=	-1	counter clockwise */
float	x,y,angle,size,xmin,xmax;
int	xy,idata;
char	*label;
{
	float	xt,yt,half,dumang,sang,cang;
	float	height,del,delx,dely,dticx,dticy;
	int	numt,i,j;
	int     n1,n2,fl,atic;
	char	*b,*c;

	angle = angle*PI/180.0;
	sang = sin(angle);
	cang = cos(angle);
	atic = 1;
	plot(x,y,3);
	height = HEIGHT;
	plot(x+size*cang,y+size*sang,2);
	if(TICDIS == 0.0)_err("axis error: ","ticdis zero");
	numt = floor(size/TICDIS+.5); 
	if(!numt) 
		numt = -1;
	plot(x,y,3);
	xt = x;	
	yt = y;
	dticx = 0.075*atic*cos(angle-xy*PI/2.0);
	dticy = 0.075*atic*sin(angle-xy*PI/2.0);
	del =  ( xmax - xmin ) / numt;
	delx = size*cang/numt;
	dely = size*sang/numt;
	numt++;
	for(i = 0;i<numt;i++){
		plot(xt+dticx,yt+dticy,2);
		xt += delx;
		yt += dely;
		plot(xt,yt,3);
	}
	if(idata >= 0)n1 = _axisl(xmin,xmax,idata,1);

	c = label;
	b = _abuf;
	while(*b++ = *c++);
	if(n1 && idata >= 0){
		--b;
		*b++ = ' ';
		*b++ = '(';
		*b++ = 'X';
		*b++ = '1';
		*b++ = '0';
		*b++ = '$';
		*b++ = '{';
		if(n1 < 0){
			*b++ = '-';
			n1 = -n1;
		}
		if(n1 > 9){
			*b++ = '0' + (n1/10);
			n2 = n1/10;
			n1 -= n2*10;
		}
		*b++ = '0' + n1;
		*b++ = '$';
		*b++ = '}';
		*b++ = ')';
		*b = 0;
	}
	half = 6.0/7.0 * _ssize(_abuf) / 2.0 * height;
	dticx = 1.1*atic*cos(angle-xy*PI/2.0) + ( size/2.0-half ) * cang;
	dticy = 1.1*atic*sin(angle-xy*PI/2.0) + ( size/2.0-half ) * sang;
	if( fabs(angle-PI/2) < SMALL )
		symbol(x+(xy*atic * 1.2),y+(size/2.0) - half,height,_abuf,90.0);
	else if( fabs(angle) < SMALL ) 
		symbol(x+(size/2.0)-half,y-(xy*atic * .75),height,_abuf,0.0);
	else if( fabs(angle) <= PI/2.0 ){ 
	  symbol(x+dticx,y+dticy,height,_abuf,angle*180.0/PI);
	}
	else{ 
	  dumang = angle - PI;
	  if( dumang < -PI)
		dumang += 2.0*PI;
	  dticx += 2.0 * half * cang;
	  dticy += 2.0 * half * sang;
	  symbol(x+dticx,y+dticy,height,_abuf,dumang*180.0/PI);
	}
	if( idata < 0)return;
	height *= 2.8/4.0;
	plot(x,y,3);
	xt = x;	
	yt = y;
	for(i = 0; i <numt; i++){
	    half = height * (6.0/7.0) * _axisl(xmin,del,idata,0);
	    if( fabs(angle-PI/2) < SMALL )
		symbol(xt+xy*atic*(((xy<0)*half)+0.145),yt -(height/2.0),height,_abuf,0.0);
	    else if( fabs(angle) < SMALL ) 
		symbol(xt-(half/2.0),yt-(xy*atic*(0.145 + height)),height,_abuf,0.0);
	    else if( xy*angle > SMALL ) 
		symbol(xt+0.6*height+height*fabs(cang),yt-1.5*xy*height*cang,height,_abuf,0.0);
	    else 
		symbol(xt-0.6*height-height*fabs(cang)-half,yt-xy*height*cang,height,_abuf,0.0);
	    xmin += del;
	    xt += delx;
	    yt += dely;
	}
}

_axisl(a,b,iflag,opt)
float	a,b;
int	iflag,opt;
{
	double	d;
	double c;
	int	minus,dc,si,i;
	static	int	n,efl;
	int	n1,n2,n3;
	char	*ecvt(),*bu,*bb;

	if(opt){
		c = b - a;
		ecvt(fabs(a),DIGITS,&n1,&si);
		ecvt(fabs(b),DIGITS,&n2,&si);
		ecvt(fabs(c),DIGITS,&n3,&si);
		if(iabs(n1-n2) <= 1) n = (n1 > n2)? n1 : n2;
		else	if(iabs(n1-n3) <= 1) n = n3;
		else	if(iabs(n2-n3) <= 1) n = n2;
		efl = 0;
		if(n <= -2 || n >= (DIGITS + iflag)){
			efl = 1;
		}
		return(efl ? n-1 : 0);
	}
	else{
		if(iflag)d = floor(a + 0.5);
		else	d = a;
		minus = 0;
		if(d < 0){
			d = -d;
			minus = 1;
		}
		bu = ecvt(d,DIGITS,&dc,&si);
		if(d == 0.0)dc++;
		if(efl)dc -= n - 1;
		if(iflag && efl == 0){
			bu[dc] = 0;
			bb = _abuf;
			if(minus)*bb++ = '-';
			while( *bb++ = *bu++);
		}
		else{
			bb = _abuf;
			if(minus)*bb++ = '-';
			if(dc <= 0){
				*bb++ = '.';
				while(dc++)*bb++ = '0';
				while(*bb++ = *bu++);
				_abuf[DIGITS+1+minus] = 0;
			}
			else{
				while(dc--)*bb++ = *bu++;
				*bb++ = '.';
				while(*bb++ = *bu++);
			}
		}
		return(_ssize(_abuf));
	}
}

iabs(i)
int	i;
{
	return((i>0)? i : -i);
}
SHAR_EOF
cat << \SHAR_EOF > draxis_.c
/*
	draxis_ - F77 interface to 'draxis'

	The CRC graphics package

*/

#include	"crc.h"

draxis_(x,y,label,angle,xy,size,min,max,flag)
float	*x;
float	*y;
float	*angle;
char	*label;
long int	*xy;
float	*size;
float	*min;
float	*max;
long	int	*flag;
{
	draxis(*x,*y,label,*angle,(int)*xy,*size,*min,*max,(int)*flag);
}
SHAR_EOF
cat << \SHAR_EOF > factor.c
/*
	factor - change scale factor

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

factor(sf)
float	sf;
{
	_fac = sf;
}
SHAR_EOF
cat << \SHAR_EOF > factor_.c
/*
	factor_ - F77 interface to 'factor'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

factor_(sf)
float	*sf;
{
	factor(*sf);
}
SHAR_EOF
cat << \SHAR_EOF > fname.c
/*
	fname - change file name when DEV=0

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47907

	October 1981
*/

#include	"crc.h"

fname(s)
char *s;
{
	extern	char	*malloc();

	STORE = malloc(strlen(s)+1);
	strcpy(STORE,s);
}
SHAR_EOF
cat << \SHAR_EOF > fname_.c
/*
	fname_ - F77 interface to 'fname'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

fname_(s)
char	*s;
{
	fname(s);
}
SHAR_EOF
cat << \SHAR_EOF > laxis.c
/*
	laxis - draw logarithmic axes

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

laxis(x,y,label,xy,size,logmin,logmax,flag)
float x,y,size;
char *label;
int xy,logmin,logmax,flag;

{


	int ns,k,iexp,flg,i,test;
	float t[10],a,b,angle,height,ttt,tt,ht,ipd,length;
	char exp[5];

	_schk((float)logmax,(float)logmin);
	ipd = size/((float)(logmax-logmin));

	if(size <= 0. || ipd <= 0.)_err("parameter error in 'laxis'","");

	height = .7*HEIGHT;

	length=4.*height;
	if(xy == 1 || xy ==3)length=HEIGHT;

	test = (int)(length/ipd) + 1;

	tt=.1;
	ttt=.075;
	ht=.0375;

	t[1]=.301; 
	t[2]=.477; 
	t[3]=.602; 
	t[4]=.699;
	t[5]=.778; 
	t[6]=.845; 
	t[7]=.903; 
	t[8]=.954;

	iexp= logmin-1;

	plot(x,y,-3);

	flg=flag;
	if(flag < 0)flg= -flag;

	ns = _ssize(label);

	switch(xy){
	case 0:
		plot(size,0.,2);
		i=0;
		a= 0.;
		while(a < .01+ size){
			iexp=iexp+1;
			plot(a,0.,3);
			plot(a,-ttt,2);
			if(flag >= 0 && i%test == 0){
				plot(a,0.,3);
				plot(a,-tt,2);
				symbol(a-.714*height,-(tt+1.93*height),height,"10",0.);
				sprintf(exp,"%d",iexp);
				symbol(a+height,-(tt+1.36*height),.8*height,exp,0.);
			}
			k=1;
			b=a+t[1]*ipd;
			while(k < 9 && b < size && flg != 1){
				if((flg == 2 && (k == 1 || k == 4)) || flg != 2){
					plot(b,0.,3);
					plot(b,-ht,2);
				}
				k=k+1;
				b=a+t[k]*ipd;
			}
			i=i+1;
			a=a+ipd;
		}
		a=.5*(size-.857*HEIGHT*ns);
		b= -tt-2.95*HEIGHT-.6*HEIGHT;
		angle=0.;
		break;
	case 1:
		plot(0.,size,2);
		i=0;
		a=0.;
		while(a < .01+ size){
			iexp=iexp+1;
			plot(0.,a,3);
			plot(-ttt,a,2);
			if(flag >= 0 && i%test == 0){
				plot(0.,a,3);
				plot(-tt,a,2);
				symbol(-(tt+4.23*height),a-.5*height,height,"10",0.);
				sprintf(exp,"%d",iexp);
				symbol(-(tt+2.516*height),a+.07*height,.8*height,exp,0.);
			}
			k=1;
			b=a+t[1]*ipd;
			while(k < 9 && b < size && flg != 1){
				if((flg == 2 && (k == 1 || k == 4)) || flg != 2){
					plot(0.,b,3);
					plot(-ht,b,2);
				}
				k=k+1;
				b=a+t[k]*ipd;
			}
			i=i+1;
			a=a+ipd;
		}
		b=.5*(size-.857*HEIGHT*ns);
		a= -tt-3.75*HEIGHT-.6*HEIGHT;
		angle=90.;
		break;
	case 2:
		plot(size,0.,2);
		i=0;
		a=0.;
		while(a < .01+size){
			iexp=iexp+1;
			plot(a,0.,3);
			plot(a,ttt,2);
			if(flag >= 0 && i%test == 0){
				plot(a,0.,3);
				plot(a,tt,2);
				symbol(a-.714*height,tt+.43*height,height,"10",0.);
				sprintf(exp,"%d",iexp);
				symbol(a+height,tt+.86*height,.8*height,exp,0.);
			}
			k=1;
			b=a+t[1]*ipd;
			while(k < 9 && b < size && flg != 1){
				if((flg == 2 && (k == 1 || k == 4)) || flg != 2){
					plot(b,0.,3);
					plot(b,ht,2);
				}
				k=k+1;
				b=a+t[k]*ipd;
			}
			i=i+1;
			a=a+ipd;
		}
		a=.5*(size-.857*HEIGHT*ns);
		b= tt+2.*HEIGHT+.6*HEIGHT;
		angle=0.;
		break;
	case 3:
		plot(0.,size,2);
		i=0;
		a=0.;
		while(a < .01+size){
			iexp=iexp+1;
			plot(0.,a,3);
			plot(ttt,a,2);
			if(flag >= 0 && i%test == 0){
				plot(0.,a,3);
				plot(tt,a,2);
				symbol(tt+.43*height,a-.5*height,height,"10",0.);
				sprintf(exp,"%d",iexp);
				symbol(tt+2.14*height,a+.07*height,.8*height,exp,0.);
			}
			k=1;
			b=a+t[1]*ipd;
			while(k < 9 && b < size && flg != 1){
				if((flg == 2 && (k == 1 || k == 4)) || flg != 2){
					plot(0.,b,3);
					plot(ht,b,2);
				}
				k=k+1;
				b=a+t[k]*ipd;
			}
			i=i+1;
			a=a+ipd;
		}
		b=.5*(size-.857*HEIGHT*ns);
		a= tt+4.76*HEIGHT+.6*HEIGHT;
		angle=90.;
		break;
	default:
		plot(-x,-y,-3);
		return;
	}

	symbol(a,b,HEIGHT,label,angle);
	plot(-x,-y,-3);
	return;
}
SHAR_EOF
cat << \SHAR_EOF > laxis_.c
/*
	laxis_ - F77 interface to 'laxis'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

laxis_(x,y,label,xy,size,logmin,logmax,flag,labell)
float	*x;
float	*y;
char	*label;
long	int	*xy;
float	*size;
long	int	*logmin;
long	int	*logmax;
long	int	*flag;
long	int	labell;
{
	laxis(*x,*y,label,(int)*xy,*size,(int)*logmin,(int)*logmax,(int)*flag);
}
SHAR_EOF
cat << \SHAR_EOF > line.c
/*
	line - draw lines

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

line(x,y,n,bar,lx,ly)
float *x,*y,lx,ly;
int n,bar;
{
	float xn,yn,yn1,xn1;
	register	int i;

	xn = x[n];	
	xn1 = x[n+1];
	yn = y[n];	
	yn1 = y[n+1];
	_schk(xn,xn1);
	_schk(yn,yn1);
	xn1 = lx / (xn1 - xn);
	yn1 = ly / (yn1 - yn);
	plot((x[0]-xn)*xn1,(y[0]-yn)*yn1,3);
	for(i=1;i<n;i++){
		if(bar)plot((x[i]-xn)*xn1,(y[i-1]-yn)*yn1,2);
		plot((x[i]-xn)*xn1,(y[i]-yn)*yn1,2);
	}
	if(bar){
		plot((x[n-1]+x[n-1]-x[n-2]-xn)*xn1,(y[n-1]-yn)*yn1,2);
	}
}
SHAR_EOF
cat << \SHAR_EOF > line_.c
/*
	line_ F77 interface to 'line'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

line_(x,y,n,bar,lx,ly)
float	*x;
float	*y;
long	int	*n;
long	int	*bar;
float	*lx;
float	*ly;
{
	line(x,y,(int)*n,(int)*bar,*lx,*ly);
}
SHAR_EOF
cat << \SHAR_EOF > newpen.c
/*
	newpen - change pens on HP plotter

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

newpen(n)
int	n;
{
	_ud = 1;
	switch(DEV) {
	    case HP:
		if((_CM & 1) == 0){
			plotp(ETX);
			_CM &= 0177774;
			_CM += 1;
		}
		if((n < 0)||(n > 4))return;
		if(_CM & 2){
			plotp('}');
			_CM &= 0177774;	
			_CM += 1;
		}
		plotp('v');
		plotp(0100 + n);
	    break;
	case TEK:
		if(DEVN == 2) {		/* Tek 4113 only	*/
		    plotp(ESC);
		    plotp('M');		/* Set line index	*/
		    plotp('L');
		    tint(n);
		    plotp(ESC);
		    plotp('M');		/* Set text index	*/
		    plotp('T');
		    tint(n);
		    }
	}
}
SHAR_EOF
cat << \SHAR_EOF > plot.c
#include	"crc.h"

/*
	plot - draw vectors

	The CRC graphics package

	Carl Crawford
	Purdue University
	West Lafayette, IN 47907

	September 1980

*/


#define MASK	0100000

plot(x,y,i)
float x,y;
int i;
{
	int l,m;

	switch((i>0)? i : -i){
	case 1:
		break;
	case 2:
		_ud = 0;
		break;
	case 3:
		_ud = 1;
		break;
	case 999:
		if(DEV > MBIT)_plotend();
		else{
			dsply();
			free(_pic);
		}
		return;
	default:
		return;
	}

	if( _fac != 1.0){
		x *= _fac;	
		y *= _fac;
	}
	l = floor( ( x + _xo )*_ipsz10 + 0.5) - _xp;
	m = floor( ( y + _yo )*_ipsz10 + 0.5) - _yp;

#ifdef	OLD
	l = floor( ( x + _xo - _xp/_ipsz10)/10.0 * _ipsz + 0.5 );
	m = floor( ( y + _yo - _yp/_ipsz10)/10.0 * _ipsz + 0.5 );
#endif	OLD

	if(_ud == 0){
		if(DEV <= MBIT)_bresen(l,m);
		else{
			drawr(l, m);
			_xp += l;
			_yp += m;
		}
	}
	else{
		_xp += l;
		_yp += m;
		if(DEV > MBIT)_mover( l,m);
	}
	_axp = _xo + x;
	_ayp = _yo + y;
	if(i<0){
		_xo = _axp;
		_yo = _ayp;
	}
}

_bresen(dx,dy)
int dx,dy;
{
	int ix,iy,major[2],minor[2],nb;
	int	zerozero[2];
	register int na,nc,nctr;

#ifdef	OLD
	if(dx == 0 && dy == 0)return;
#endif	OLD
	/* Resolve to first quadrant */
	ix=1;
	if(dx<0){
		ix = -1;
		dx = -dx;
	}
	iy=1;
	if(dy<0){
		iy = -1;
		dy = -dy;
	}

	/* Resolve to proper octant */
	major[1] = iy;
	major[0] = ix;
	if(dx<dy){
		minor[0] = 0;
		minor[1] = iy;
		na = dy;
		nb = dx + dx;
	}
	else{
		minor[1] = 0;
		minor[0] = ix;
		na = dx;
		nb = dy + dy;
	}
	nc = na + na;
	nctr = na;

	zerozero[0] = zerozero[1] = 0;
	step(zerozero);
	/* Loop through all the steps */
	while(nctr>0){
		na = na + nb;
		if(na>=nc){
			na -= nc;
			step(major);
		}
		else{
			step(minor);
		}
		nctr -= 1;
	}
}

step(a)
int a[];
{
	register int pos,c;
	register unsigned short bit;

	_xp += a[0];
	_yp += a[1];
	if(_xp<0 || _xp>511 || _yp<0 || _yp>511){
		if(_error == 0){
			fprintf(stderr,"attempt to plot outside of picture\n");
		}
		_error = 1;
		return;
	}

	pos = (16352 - (_yp<<5))+(_xp>>4);
	bit = 1<<(15-(_xp&017));
	_pic[pos] |= bit;
}

dsply()
{
						/*
						 * Check to see if output is
						 * to a bit mapped device that
						 * needs an output filter.  
						 * Write the bit map and then
						 * do a pclose to wait for the
						 * end of the proc.
						 */
	if((DEVN && DEV == BIT) || DEV == GOV || DEV == IMAGE
		|| DEV == GGOV || DEV == GIMAGE){
		write(fileno(_pipe_fd), _pic, _bufsize);
		pclose(_pipe_fd);
		return;
	}
	if(STORE[0] == '-' && STORE[1] == '\0'){
		_pipe_fd = stdout;
	}else{
		if((_pipe_fd=fopen(STORE,"w")) == NULL)_err("can't create: ",STORE);
	}
	write(fileno(_pipe_fd), _pic, _bufsize);
	fclose(_pipe_fd);
}

drawr(deltax,deltay)
int deltax,deltay;
/*
 *	Draw to relative postion given by delta-x and delta-y.
 */
{
	register x,y;

	x = deltax + _X;
	while(x < 0)x += 10230;
	if(x > 10230)x %= 10230;
	y = deltay + _Y;
	while(y < 0)y += 7790;
	if(y > 7790)y %= 7790;
	draw(x,y);
}

draw(x,y)
int x,y;
/*
 *	Draw a vector from current co-ordinate to (x,y).
 */
{
	register i;

	x &= 037777;	
	y &= 037777;
	if(DEV == TEK){
		if((_CM & 1) == 0){
			_CM++;
			plotp(GS);
			_CM &= 0177775;
			_CM += 2;
			plotty(_Y);	
			plottx(_X);
			plotfil(x,y);
			plotty(y);
			plottx(x);
			_X = x;	
			_Y = y;
			return;
		}
		if((_CM & 2) == 0){
			plotty(_Y);	
			plottx(_X);
			_CM &= 0177775;	
			_CM += 2;
		}
		plotfil(x,y);
		plotty(y);	
		plottx(x);
		_X = x;	
		_Y = y;
		return;
	}

	if(DEV == HP){
		if((_CM & 1)== 0){
			plotp(ETX);
			_CM&= 0177774;
			_CM += 1;
		}
		if(_CM & 2){		/* next will draw	*/
			pmbpo(x,y);
		}
		else{
			plotp('p');
			pmbpo(_X,_Y);
			pmbpo(x,y);
			_CM &= 0177774;	
			_CM += 3;
		}
		_X = x;	
		_Y = y;
	}

	if (DEV == PLOT){
		p_cont(_X=x,_Y=y);
		_X = x;	
		_Y = y;
	}

}

plotfil(x,y)
int x,y;
/*
 *	Look at magnitude of change in current X andY and
 *	new x and y.  Set correct number of fill charctors.
 */
{

	x -= _X;	
	if(x < 0) x = -x;
	y -= _Y;	
	if(y < 0) y = -y;
	x &= 070000;	
	y &= 070000;
	x >>= 12;	
	y >>= 12;
	_FILL = x;	
	_FILL += y;
	_FILL++;	/* for good measure */
}

_mover(deltax,deltay)
int deltax,deltay;
/*
 *	Routine to move by +- delta-x and +- delta-y
 */
{
	register x,y;

	x = deltax + _X;
	while(x < 0)x += 10230;
	if(x > 10230)x %= 10230;
	y = deltay + _Y;
	while(y < 0)y += 7790;
	if(y > 7790)y %= 7790;
	move(x,y);
}

move(x,y)
int x,y;
/*	
 *	Move to an x,y co-ordinate.  Leave in graphic mode.
 */
{

	x &= 037777;	
	y &= 037777;
	if(DEV == TEK){
		if((_CM & 1) == 0){
			plotp(GS);
			_CM++;
			_CM &= 0177775;	
			_CM += 2;
			plotty(y);	
			plottx(x);
			_X = x;	
			_Y = y;
			return;
		}
		if((_CM & 2) == 2){
			plotp(GS);
		}
		plotty(y);	
		plottx(x);
		_CM &= 0177775;	
		_CM += 2;
		_X = x;	
		_Y = y;
		return;
	}

	if(DEV == HP){
		if((_CM & 1) == 0){
			plotp(ETX);	/* end alpha mode	*/
			_CM &= 0177774;
		}
		if(_CM & 2){
			plotp('}');
		}
		plotp('p');
		pmbpo(x,y);
		_CM |= 3;
		_X = x;	
		_Y = y;
	}

	if (DEV == PLOT)
		p_move(_X=x, _Y=y);

}

plotty(n)
int n;
/*	Prints out a 10-bit Tektronics number supplied in n.
 */
{
	register char c;
	register i,j;

	i = n/10;
	if((n % 10) > 4)i++;
	j = i >> 5;
	plotp((j & 037) + 040);
	plotp((i & 037) + '`');
}

plottx(n)
int n;
/*	Prints out a 10-bit Tektronics number supplied in n.
 */
{
	register char c;
	register i,j;

	i = n/10;
	if((n % 10) > 4)i++;
	j = i >> 5;
	plotp((j & 037) + 040);
	plotp((i & 037) + 0100);
	while(_FILL--)plotp(1);
	_FILL = 0;
}

pmbpo(x,y)
int x,y;
{
	/*	Puts out x and y in HP MBP format.	*/
	register max;
	register char c;

	x &= 037777;	
	y &= 037777;
	max = x;
	if(y > x)max = y;
	if(max < 4){
		plotp(0140 + (x << 2) + y);
		return;
	}
	if(max < 32){
		plotp(0140 + (x >> 1));
		c = ((x <<5) & 040) + y;
		if(!(c & 040))c += 0100;
		plotp(c);
		return;
	}
	if(max < 256){
		plotp(0140 + (x >> 4));
		c = ((x << 2) & 074) + ((y >> 6) & 3);
		if(!(c & 040))c += 0100;
		plotp(c);
		c = y & 077;
		if(!(c & 040))c += 0100;
		plotp(c);
		return;
	}
	if(max < 2048){
		c = 0140 + ((x >> 7) & 017);
		plotp(c);
		c = (x >> 1) & 077;
		if(!(c & 040))c += 0100;
		plotp(c);
		c = ((x << 5) & 040) + ((y >> 6)& 037);
		if(!(c & 040))c += 0100;
		plotp(c);
		c = y & 077;
		if(!(c & 040))c += 0100;
		plotp(c);
		return;
	}
	c = (x >> 10) & 017;
	plotp(c + 0140);
	c = (x >> 4) & 077;
	if(!(c & 040))c += 0100;
	plotp(c);
	c = ((x << 2) & 074) + ((y >> 12) & 3);
	if(!(c & 040))c += 0100;
	plotp(c);
	c = (y >> 6) & 077;
	if(!(c & 040))c += 0100;
	plotp(c);
	c = y & 077;
	if(!(c & 040))c += 0100;
	plotp(c);
}

pmbno(n)
int n;
{
	/*	print out n in HP MBN format	*/
	register char c;

	n &= 0177777;
	if(n < 16){
		plotp(n + '`');
		return;
	}
	if(n < 1024){
		c = '`' + ((n >> 6)& 017);
		plotp(c);
		c = n & 077;
		if(!(c & 040))c += 0100;
		plotp(c);
		return;
	}
	c = (n >> 12) & 07;
	plotp(c + 0140);
	c = (n >> 6) & 077;
	if(!(c & 040))c += 0100;
	plotp(c);
	c = n & 077;
	if(!(c & 040))c += 0100;
	plotp(c);
}
SHAR_EOF
cat << \SHAR_EOF > newpen_.c
/*
	newpen_ - F77 interface to 'newpen'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

newpen_(n)
long	int	*n;
{
	newpen((int)*n);
}
SHAR_EOF
cat << \SHAR_EOF > number.c
/*
	number - provide formatted numeric labelling

	The CRC graphics package

	Carl Crawford
	Purdue University
	W. Lafayette, IN 47907

	September 1981
*/

#include	"crc.h"

number(x,y,height,angle,fmt,args)
float x,y,height,angle;
int args;
char *fmt;

{
	struct _iobuf _strbuf;

	_strbuf._flag = _IOWRT+_IOSTRG;
	_strbuf._ptr = _abuf;
	_strbuf._cnt = 32767;
	_doprnt(fmt, &args, &_strbuf);
	putc('\0', &_strbuf);
	symbol(x,y,height,_abuf,angle);
}
SHAR_EOF
cat << \SHAR_EOF > number_.c
/*
	number_ - F77 interface to 'number'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"
#ifndef vax
#  include	<ctype.h>
#endif /* vax */

number_(x,y,height,angle,format,num,formatl)
float	*x,*y,*height,*angle;
char	*format;
union {
	short	s;
	int	i;
	long	l;
	float	f;
	double	d;
}	*num;
long	int	formatl;
{
#ifdef vax
	number(*x,*y,*height,*angle,format,*num);
#else  /* vax */
/*
 * On machines with big endian byte order we need to know how many bytes
 * num is pointing to, so we scan the format string to figure to this
 * out as best possible.  N.B. This is a kludge!!!
 */
	register char *p;
	int longint;

	longint = 0;
	for (p = format; p < format + formatl; p++) {
		if (*p != '%') {
			continue;
		}
		p++;
		while (*p == '#' || *p == '-' || *p == '+' || *p == ' ') {
			p++;
		}
		while (isdigit(*p)) {
			p++;
		}
		if (*p == '.') {
			p++;
			while (isdigit(*p)) {
				p++;
			}
		}
		if (*p == 'l' || *p == 'L') {
			longint = 1;
			p++;
		}
		if (*p == 'd' || *p == 'D' || *p == 'o' || *p =='O' ||
		    *p == 'x' || *p == 'X' || *p == 'u' || *p =='U' ) {
			if (longint) {
				/* We were passed a FORTRAN INTEGER*4 value */
				number(*x, *y, *height, *angle, format, num->l);
			} else {
				/* We were passed a FORTRAN INTEGER value */
				number(*x, *y, *height, *angle, format, num->i);
			}
			return;
		}
		if (*p == 'f' || *p == 'F' || *p == 'e' || *p =='E' ||
		    *p == 'g' || *p == 'G' ) {
			/* We were passed a FORTRAN REAL or DOUBLE PRECISION
			 * value */
			number(*x, *y, *height, *angle, format, *num);
			return;
		}
	}
	/* scan of format string failed so we'll assume we were passed
	 * a FORTRAN REAL or DOUBLE PRECISION value. */
	number(*x, *y, *height, *angle, format, *num);
#endif /* vax */
}
SHAR_EOF
cat << \SHAR_EOF > plot_.c
/*
	plot_ - F77 interface to 'plot'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

plot_(x,y,i)
float	*x;
float	*y;
long int	*i;
{
	plot(*x,*y,(int)*i);
}
SHAR_EOF
cat << \SHAR_EOF > plotp.c
/*
	plotp - send char to the TEK or the HP

	The CRC graphics package

	Carl Crawford
	Purdue University
	W. Lafayette, IN

	September 1981
*/

#include	"crc.h"

plotp(data)
char data;	
{
	fputc(data,_pipe_fd);
}
SHAR_EOF
cat << \SHAR_EOF > plots.c
/*
	plots - initialize graphics system

	The CRC graphics package

	Carl Crawford
	Purdue University
	W. Lafayette, IN 47907

*/

#include	"crc.h"

plots(dev,blank,str)
int	dev;
int	blank;
char	*str;
{
	char	*malloc();
	unsigned int	q;
	FILE	*fd,*popen();
	char	*DeviceSpec;
	int	ustr;	/* 1=used str */
	int	_clean();	/* clean up routine after interrupts */

	_pic = 0;   		/* pointer to bit plane */
	_xp = 0;_yp = 0;        /* integer position */
	_X = 0; _Y = 0;		/* Tek (?) Position */
	_axp = 0;_ayp = 0;      /* real position */
	_xo = 0;_yo = 0;        /* current origin */
	_ud = 0;            	/* indicates up/down for pen */
	_error = 0;         	/* indicates error in plotting */
	_fac = 0;		/* scale factor */
	_ipsz10 = 0;		/* ipsize / 10.0 */

	BLANK = blank;
	DEV = dev & 07;
	DEVN = ((dev&070)>>3);
	if(dev & 0100){
		ustr = 1;
	}else{
		ustr = 0;
	}
	_bufsize = 32768;
	_ipsz = 511.;
	TICDIS = 1.0;
	if(!STORE)STORE = "graph";
	if(!SITE)SITE = "-pl";
	HEIGHT = .2;
	DIGITS = 6;
	PLOTFILT = NULL;
	switch(DEV){

	case BIT:         /* output file mode */
		switch(DEVN){

		case 0:         /* file */
			_pipe_fd = stdout;      /* override error message */
			break;
		case 1:         /* gp */
			strcpy(_abuf,"exec gp -i ");
			if(ustr)strcat(_abuf,str);
			_pipe_fd = popen(_abuf,"w");
			break;
		case 2:        /* gplp */
			strcpy(_abuf,"exec gplp ");
			strcat(_abuf,SITE);
			strcat(_abuf," -i ");
			if(ustr)strcat(_abuf,str);
			_pipe_fd = popen(_abuf,"w");
			break;
		}
		break;
	case GOV:		/* graphics overlay */
	case IMAGE:		/* comtal image */
	case GGOV:		/* Grinnell Graphics Overlay */
	case GIMAGE:		/* Grinnell Image Plane */
		DeviceSpec = "0";
		if (DEV == IMAGE || DEV == GIMAGE){
			if (DEVN == 0)
				*DeviceSpec = NULL;
			else
				*DeviceSpec += DEVN - 1;
		} else {
			*DeviceSpec += DEVN;
		}
		sprintf(_abuf,"exec /usr/lib/graphics/gd -%c%c%s%c ",
			(DEV == GOV || DEV == IMAGE) ? 'C' : 'G',
			(DEV == GOV || DEV == GGOV) ? 'o' : 'i',
			DeviceSpec,
			BLANK ? 'b' : ' ');
		if(ustr)strcat(_abuf,str);
		_pipe_fd = popen(_abuf,"w");
		break;
	case PLOT:
		if (ustr && str){
			char	buffer[BUFSIZ];

			sprintf(buffer,"%s -T%s\n",PLOTBIN,str);
			PLOTFILT = str;
			_pipe_fd = popen(buffer,"w");
		} else {
			_pipe_fd = fdopen(dup(1),"w");
		}
		p_space(0,0,7800,7800);
		if (!BLANK)
			p_erase();
		break;
	case TEK:         /* tektronix */
		_pipe_fd = fdopen(dup(1),"w"); /* buffer Tek info */
		break;
	case HP:        /* HP */
		strcpy(_abuf,"exec /usr/lib/graphics/hpd ");
		if(ustr)strcat(_abuf,str);
		_pipe_fd = popen(_abuf,"w");
		break;
	default:
		fprintf(stderr,"plots: bad device number\n");
		exit(1);
	}
	if(_pipe_fd == NULL){
		fprintf(stderr,"can't execute pipe\n");
		exit(1);
	}
	if(DEV <= MBIT){
		if( (_pic = (unsigned short *) malloc(_bufsize)) == NULL){
			_err("plots: can't allocate space","");
		}
		if(BLANK&&DEV==0&&DEVN==0&&((fd=fopen(STORE,"r"))!=NULL)){
			fread(_pic,sizeof(*_pic),16384,fd);
			fclose(fd);
		}else{
			for(q=0;q<16384;_pic[q++] = 0);
		}
	}
	else{
		plotinit();
		_hsig = signal(SIGHUP,_clean);
		_isig = signal(SIGINT,_clean);
		_qsig = signal(SIGQUIT,_clean);
		_ipsz = 7790.;
	}
	_ipsz10 = _ipsz / 10.0;
	_xo = _yo = _axp = _ayp = 0.0;
	_xp = _yp = _error= 0;
	_ud = 1;
	_fac = 1.0;
}

plotinit()
{
	register i,j;
	int	tty[3];
	register char *p;


	if(DEV == TEK){
		_CM = 0;

		/* set to 'bs0' and 'lcase' */

		gtty(0,_intty);
		tty[0] = _intty[0];
		tty[1] = _intty[1];
		tty[2] = _intty[2] & ~000004 & ~0100000;
		stty(0,tty);

		if(!BLANK){	/* blank sreen if necessary */
			switch(DEVN) {
			    case 0:
			    case 2:
				plotp(ESC);	
				plotp(FF);
				fflush(_pipe_fd);
				sleep(2);
				break;
			    case 1:	/* extra stuff for Retrographics */
				plotp(GS);
				plotp(SUB);
				plotp(EM);
				plotp(ESC);	
				plotp(FF);
				plotp(US);
				fflush(_pipe_fd);
			    }
		}
		_FILL = 0;
		plotp(ESC);	/* set proper vector type */
		plotp('`');
		return;
	}

	if(DEV == HP){
		_CM = 0;
		plotp(ESC);    
		plotp('.');	
		plotp('(');
		plotp(ESC);  
		plotp('.'); 
		plotp('M');
		plotp(':');  
		plotp(ESC);
		p = ".I513;5;71;10:";
		while(*p)plotp(*p++);
		/*  Set handshake mode 2, buff size 513 bytes, enquire  = ^E,
			GO string singal = "G\n" */
		plotp('~');	
		plotp('W');
		pmbpo(380,366);
		pmbpo(13903,10668);
		plotp('~');	
		plotp('S');
		pmbpo(10244,7804);
		plotp('}');
		_CM = 1;
		plotp(ETX); /* set proper vector type */
		plotp('}');
		plotp('~');
		plotp('R');
		plotp('}');
		alpha();
		newpen(1);
	}
}
SHAR_EOF
cat << \SHAR_EOF > plots_.c
/*
	plots_ - F77 interface to 'plot'

	The CRC graphics package

	Carl Crawford
	Purdue University
	W. Lafayette, IN. 47907

	September 1981: <crc> added 'str' to call
*/

#include	"crc.h"

plots_(dev,blank,str)
long int	*dev;
long int	*blank;
char	*str;
{
	plots((int)*dev,(int)*blank,str);
}
SHAR_EOF
cat << \SHAR_EOF > plotsubs.c
#include <stdio.h>
#include "crc.h"

p_cont(xi,yi){
	putc('n',_pipe_fd);
	p_putsi(xi);
	p_putsi(yi);
}
p_erase(){
	putc('e',_pipe_fd);
}
p_move(xi,yi){
	putc('m',_pipe_fd);
	p_putsi(xi);
	p_putsi(yi);
}

p_putsi(a){
	putc((char)a,_pipe_fd);
	putc((char)(a>>8),_pipe_fd);
}

p_space(x0,y0,x1,y1){
	putc('s',_pipe_fd);
	p_putsi(x0);
	p_putsi(y0);
	p_putsi(x1);
	p_putsi(y1);
}
SHAR_EOF
cat << \SHAR_EOF > scale.c
/*
	scale - find minimum and maximum of vector

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

scale(a,n)
float *a;
int n;
{
	float ai,fmax,fmin;
	register	int i;

	fmax = fmin = *a;
	for(i=0;i<n;i++){
		ai=a[i];
		if(ai > fmax) fmax = ai;
		if(ai < fmin) fmin = ai;
	}
	a[n] = fmin;
	a[n+1] = fmax;
}
SHAR_EOF
cat << \SHAR_EOF > scale_.c
/*
	scale_ - F77 version of 'scale'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981

	Didn't call 'scale' because of name conflicts in
	F77's libraries.
*/

#include	"crc.h"

scale_(a,n)
float	*a;
long	int	*n;
{
	float ai,fmax,fmin;
	register int i;

	fmax = fmin = *a;
	for(i=0;i<*n;i++){
		ai=a[i];
		if(ai > fmax) fmax = ai;
		if(ai < fmin) fmin = ai;
	}
	a[*n] = fmin;
	a[1 + *n] = fmax;
}
SHAR_EOF
cat << \SHAR_EOF > site.c
#include	"crc.h"

/*
	site - change default site for gplp linkage

	The CRC graphics package

	carl crawford
	purdue university
	w. lafayette. in 47907

	jan. 5, 1981
*/

site(s)
char *s;
{
	SITE = s;
}
SHAR_EOF
cat << \SHAR_EOF > site_.c
#include	"crc.h"
/*
	site_ - interface to site from F77

	The CRC graphics package

	Carl Crawford
	Purdue University
	W. Lafayette, IN 47907

	Jan. 6, 1981
*/

site_(s)
char	*s;
{
	site(s);
}
SHAR_EOF
cat << \SHAR_EOF > sline.c
/*
	sline - draw lines with on center symbols

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

sline(x,y,n,lx,ly,j,sym)
float *x,*y,lx,ly;
int n,j,sym;
{
	float xn,yn,yn1,xn1;
	register	int i;
	int code;
	char t[2];

	xn = x[n];	
	xn1 = x[n+1];
	yn = y[n];	
	yn1 = y[n+1];
	_schk(xn,xn1);
	_schk(yn,yn1);
	xn1 = lx / (xn1 - xn);
	yn1 = ly / (yn1 - yn);

	if(j == 0)j = 1;
	code=2;
	if(j < 0){
		code=3;
		j= -j;
	}
	t[0]= 0;
	t[1]= 0;
	if(sym <= 0 )t[0]= ' ';
	else    if(sym < 11)t[0]=t[0]+sym+175;
	else    if(sym <14)t[0]=t[0]+sym+159;
	else t[0]= ' ';
	if(sym == 0)j=4096;
	plot((x[0]-xn)*xn1,(y[0]-yn)*yn1,3);
	symbol((x[0]-xn)*xn1,(y[0]-yn)*yn1,.65*HEIGHT,t,0.);
	plot((x[0]-xn)*xn1,(y[0]-yn)*yn1,3);
	for(i=1;i<n;i++){
		plot((x[i]-xn)*xn1,(y[i]-yn)*yn1,code);
		if(i%j == 0){
			symbol((x[i]-xn)*xn1,(y[i]-yn)*yn1,.65*HEIGHT,t,0.);
			plot((x[i]-xn)*xn1,(y[i]-yn)*yn1,3);
		}
	}
}
SHAR_EOF
cat << \SHAR_EOF > sline_.c
/*
	sline_ - F77 interface to 'sline'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

sline_(x,y,n,lx,ly,j,sym)
float *x,*y,*lx,*ly;
long int *n,*j,*sym;
{
	sline(x,y,(int)*n,*lx,*ly,(int)*j,(int)*sym);
}
SHAR_EOF
cat << \SHAR_EOF > speed.c
/*
	speed - change speed of HP plotter 

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include "crc.h"

speed(vel)
int vel;
{
	if(DEV == HP){
		plotp('~');
		plotp('V');
		plotp(vel<32 ? 0100+vel : vel);
	}
}
SHAR_EOF
cat << \SHAR_EOF > speed_.c
#include	"crc.h"

/*
	speed_ - f77 interface to 'speed'

	The CRC graphics package

	Carl Crawford
	Purdue University
	W. Lafayette, IN 47907

	March 11, 1981
*/

speed_(vel)
long	int	*vel;
{
	speed((int)*vel);
}
SHAR_EOF
cat << \SHAR_EOF > symbol.c
/*
	symbol - plot strings

	The CRC graphics package

	Carl Crawford
	Purdue University
	W. Lafayette, IN 47907

*/

#include	"crc.h"

symbol(x,y,height,str,angle)
	float x,y,angle;
	float height;
	char *str;
{
	int f,vis;
	int charfont();
	float xx,yy,t1,t2,ca,sa,d2r;
	static	float	oangle,oheight;
	static	int	first	= 1;	/* ==1 if first call	*/
	int	dollar;
	char    cc;

	if(DEV == TEK && DEVN == 2 && index(str,'$') == 0) {
	    register	int	i;
	    plot(x,y,3);
	    if(oangle != angle || first) {
		plotp(ESC);	/* Graphic text rotation	*/
		plotp('M');
		plotp('R');
		tint((int) angle); tint(0);
		oangle = angle;
		}
	    if(oheight != height || first) {
		plotp(ESC);	/* Graphic test size		*/
		plotp('M');
		plotp('C');
		tint((int)(190*height));
		tint((int)(265*height));
		tint((int)( 75*height));
		oheight = height;
		}
	    first = 0;
	    plotp(ESC);	/* Output graphic string	*/
	    plotp('L');
	    plotp('T');
	    tint(strlen(str));
	    for(i=0; str[i]; i++)
		plotp(str[i]);
	    return;
	    }

	d2r = 4.0 * atan(1.0) / 180.0;
	dollar = 0;
	angle *= d2r;
	sa = sin(angle);
	ca = cos(angle);
	plot(x,y,3);

	while(cc = *str){
		if(cc == '$' && dollar == 0){
			dollar = 1;
			str++;
		}
		else{
			if(dollar == 1){
				dollar = 0;
				cc += 0200;
			}

/*				/* kludge bad font defintition for '.' */
/*			if(cc == '.' && DEV <= MBIT)
/*				cc = ',';
 */
			do{
				f = charfont(cc,height,&xx,&yy,&vis);
				t1 = ca * xx - sa * yy;
				t2 = sa * xx + ca *yy;
				plot(t1+x,t2+y,3-vis);
			}
			while(f);
			x += t1;
			y += t2;
			str++;
		}
	}
}

/*   Charfont is a program that looks up the end points  of  line
segments  for  plotting  characters.   Each  time  'charfont'  is
called, it returns the relative coordinates, which when added  to
the  current  location yields the final end point for a line seg-
ment.  The initial point of the line segment is the current loca-
tion.   Whether the line segment is to be visible or not is indi-
cated by the returned value in "visflg". */

short  *pntcoord;	/* pointer to coordinates */
int	initflg;	/* 1=open font file */
struct  {		/* header structure */
	short  height;
	short  coordsz;
	short  pntr1st[256];
}fontcom;

charfont(symbol,height,x,y,visflg)
	char  symbol;
	float  height, *x, *y;
	int  *visflg;
{
	int  i;
	static short *pntr;
	static float  scale;
	register int  temp;

	if(initflg == 0)
		fontinit(BINARY_FONT_FILE);

	/* find coordinate of first point */

	if (pntr == 0) {
		if ( (i=fontcom.pntr1st[symbol&0377]) == -1) {

			/* assume space if can't find it */

			if ( (i=fontcom.pntr1st[' ']) == -1) {

				/* set if no space */

				*x = 0.0;
				*y = 0.0;
				*visflg = 0;
				return(0);
			}
		}
		pntr = pntcoord+i;
		scale = height/fontcom.height;
	}
	temp = *pntr++;
	
	/* get X coordiante */

	*x = ((temp>>7)&077)*scale;
	if (temp&0020000)*x = (-(*x));

	/* get Y coordinate */

	*y = (temp&077)*scale;
	if (temp&0100)*y = (-(*y));

	/* get visib flag */

	*visflg = (temp&040000)&&01;

	/* check for last coordinate */

	if (temp < 0) {
		pntr = 0;
		return(0);
	}
	return(1);
}

/*  The font file used by 'fontinit' to read  in  the  data  for
	'charfont' has the following format:

short  height     Default character height.
short  size       Bytes of core required to hold coordinates.
short  pnt[256]   Indexes to 1st coordinate of each symbol.
short  crd[size]  Coordinates of symbols

Where each crd[i] has the following format:

  EVSXXXXXXSYYYYYY
  III     IIIIIIII
  III     I   I----- Y coordinate (sign magnitude format)
  IIIIIIIII
  II   I----- X coordinate (sign magnitude format)
  II----- Line segment visible flag (0=invisible, 1=visible)
  I----- 1=more coordinates; 0=last coordinate

*/

fontinit(file)
char  *file;
{
	FILE  *fd;	/* input file desciptor */
	char  *malloc();

	if((fd = fopen(file,"r")) == NULL)
		_err ("unable to open character font file ", file);

	/* assume that structure of font file is correct */
	fread(&fontcom,sizeof(fontcom),1,fd);
	if((pntcoord=(short *) malloc(fontcom.coordsz)) == NULL)
		_err ("can't allocate space for fonts","");
	fread(pntcoord,fontcom.coordsz,1,fd);
	initflg = 1;
	fclose(fd);
}

tint(i)
	int i;
{
	int negative,lo,hi1,hi2;
	negative = 1;
	if(i < 0){
		i = -i;
		negative = 0;
		}
	lo = (i % 16) + 32;
	if(negative)lo += 16;
	i /= 16;
	hi1 = (i % 64) + 64;
	i /= 64;
	hi2 = (i % 64) + 64;
	if(hi2 == 64){
		if(hi1 == 64){
			plotp(lo);
			return;
			}
		plotp(hi1); plotp(lo);
		return;
		}
	plotp(hi2); plotp(hi1); plotp(lo);
}
SHAR_EOF
cat << \SHAR_EOF > symbol_.c
/*
	symbol_ - F77 interface to 'symbol'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

symbol_(x,y,height,string,angle,stringl)
float	*x;
float	*y;
float	*height;
char	*string;
float	*angle;
long	int	stringl;
{
	symbol(*x,*y,*height,string,*angle);
}
SHAR_EOF
cat << \SHAR_EOF > where.c
/*
	where - return plot status

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

where(x,y,sf)
float	*x,*y,*sf;
{
	*x = _axp - _xo;
	*y = _ayp - _yo;
	*sf = _fac;
}
SHAR_EOF
cat << \SHAR_EOF > where_.c
/*
	where_ - F77 interface to 'where'

	The CRC graphics package

	Carl Crawford 
	Purdue University
	West Lafayette, IN 47901

	October 1981
*/

#include	"crc.h"

where_(x,y,sf)
float	*x;
float	*y;
float	*sf;
{
	where(x,y,sf);
}
SHAR_EOF
chdir ..
#	End of shell archive
exit 0

-- 

Rich $alz			"Anger is an energy"
Cronus Project, BBN Labs	rsalz@bbn.com
Moderator, comp.sources.unix	sources@uunet.uu.net
