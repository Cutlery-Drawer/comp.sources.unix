Subject:  v17i084:  ACM-style programmning contest programs, Part01/03
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: jim nelson <nelson@uncecs.edu>
Posting-number: Volume 17, Issue 84
Archive-name: contest-prog/part01

This is a set of ACM-style Programming Contest software that I wrote
for our this year's (1988)'s "Local Programming Contest".  We could not
afford to field a team to go to the Regional Contest, so we just
Po'Boy-ed it here at home.

This software is provided without any warranty whatsoever.  It's free
and free of copyright.  It's just what I did for our contest.  It'll
certainly require some version of unix, either BSD4.2 or SysV, or
compatible.  I've tested it on our Sequent B8 (BSD4.2, or very close,
NS32032), and on each of our SysV boxes, one running SysV2.1 (3b2/300)
and the other running SysV3.1 (3b2/310?) (don't ask why they're not
both running 3.1, it's a long bloody story...). No Suns available to me
(isn't that incredible?).

What we have here is a combination of shell (Bourne) scripts and
C-programs which I found useful in being a "judge" in our local
"Programming Contest".  We discussed trying to field a team to go to
the Regionals, and decided we 1) couldn't afford the gas, and 2)
couldn't win anyway.

Anyway, this software is being put on the net (if it gets past the
moderator) just to possibly inspire others to sorta goad their defunct
ACM/CS student groups (ours died with the dues increase) to come back
alive.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  MANIFEST README digits.c f judge n prob1.ans prob1.in
#   prob1.txt prob13.ans prob13.in prob14.ans prob14.in prob15.ans
#   prob15.c prob15.in prob16.ans prob16.in prob17.ans prob17.in
#   prob18.ans prob18.in prob2.ans prob2.c prob2.in prob3.ans prob3.c
#   prob3.in prob3.txt prob4.ans prob4.c prob4.in prob5.ans prob5.c
#   prob5.in prob6.ans prob6.c prob6.in rules scoreascorrect
#   scoreasincorre scoreboard seconds.c sf shorten.c shutofflogins
#   syserr.c testem visc
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2408 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X Makefile                   2	
X README                     1	
X chexec8.c                  2	
X compare.c                  2	
X contestrules               3	
X digits.c                   1	
X f                          1	
X gr                         3	
X judge                      1	
X n                          1	
X passwd                     2	
X prob1.ans                  1	
X prob1.c                    2	
X prob1.in                   1	
X prob1.txt                  1	
X prob13.ans                 1	
X prob13.c                   2	
X prob13.in                  1	
X prob13.txt                 2	
X prob14.ans                 1	
X prob14.c                   2	
X prob14.in                  1	
X prob14.txt                 2	
X prob15.ans                 1	
X prob15.c                   1	
X prob15.in                  1	
X prob15.txt                 2	
X prob16.ans                 1	
X prob16.c                   2	
X prob16.in                  1	
X prob16.txt                 2	
X prob17.ans                 1	
X prob17.c                   2	
X prob17.in                  1	
X prob17.txt                 2	
X prob18.ans                 1	
X prob18.c                   3	
X prob18.in                  1	
X prob18.txt                 3	
X prob2.ans                  1	
X prob2.c                    1	
X prob2.in                   1	
X prob2.txt                  2	
X prob3.ans                  1	
X prob3.c                    1	
X prob3.in                   1	
X prob3.txt                  1	
X prob4.ans                  1	
X prob4.c                    1	
X prob4.in                   1	
X prob4.txt                  2	
X prob5.ans                  1	
X prob5.c                    1	
X prob5.in                   1	
X prob5.txt                  2	
X prob6.ans                  1	
X prob6.c                    1	
X prob6.in                   1	
X prob6.txt                  2	
X rules                      1	
X sb.c                       2	
X score.c                    3	
X scoreascorrect             1	
X scoreasincorre             1	
X scoreboard                 1	
X seconds.c                  1	
X sf                         1	
X shorten.c                  1	
X shutofflogins              1	
X start                      2	
X syserr.c                   1	
X testem                     1	
X visc                       1	
END_OF_FILE
if test 2408 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(7871 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
XThis is a set of ACM-style Programming Contest software that I wrote
Xfor our this year's (1988)'s "Local Programming Contest".  We could not
Xafford to field a team to go to the Regional Contest, so we just
XPo'Boy-ed it here at home.
X
XThis software is provided without any warranty whatsoever.  It's free
Xand free of copyright.  It's just what I did for our contest.  It'll
Xcertainly require some version of unix, either BSD4.2 or SysV, or
Xcompatible.  I've tested it on our Sequent B8 (BSD4.2, or very close,
XNS32032), and on each of our SysV boxes, one running SysV2.1 (3b2/300)
Xand the other running SysV3.1 (3b2/310?) (don't ask why they're not
Xboth running 3.1, it's a long bloody story...). No Suns available to me
X(isn't that incredible?).
X
XWhat we have here is a combination of shell (Bourne) scripts and
XC-programs which I found useful in being a "judge" in our local
X"Programming Contest".  We discussed trying to field a team to go to
Xthe Regionals, and decided we 1) couldn't afford the gas, and 2)
Xcouldn't win anyway.
X
XAnyway, this software is being put on the net (if it gets past the
Xmoderator) just to possibly inspire others to sorta goad their defunct
XACM/CS student groups (ours died with the dues increase) to come back
Xalive.
X
XInstallation:
X
XAdd a user to your system; his name probably should be "judges" (well,
Xof course, cousin, you gotta be root to do this... trust me!).  Make
Xsure his .profile or .login or .whatever sets his umask to 077.  The
Xgroup of user judges should be the same as his uid.  The group of the
Xteams should be their uids also. But, at least on Berkeley, the group
Xof the directories of the teams should be the same as the group of the
Xjudges.  More on this later.
X
XLog in as judges.  (No root privileges needed, nor desired).
X
XCopy all this stuff from wherever you were reading it into the
X"judges" directory (which is where you should be now).
X
XUnshar the Parts.
X
XLook at Makefile, to see if there are any pathname dependencies
XI missed.  On our system, users are in /usr1, /usr2, and /usr3,
Xand I put judges in /usr2.  More traditional systems will
Xhave /u, /v, etc., I guess.
X
XMake a directory called /usr/contest with 0777 permissions; don't
Xworry, we're only putting easily reconstituted stuff there.  The
X"score" program, for example, needs to live in a directory which
Xis in each of the teams' PATHs; it will be setuid judges, so it
Xcan read the scoreboard, which will be in the judges' protected
Xdirectory.
X
XLook at Makefile to see if you can stand P=& (parallel make).
X
XType
X% make all
X
XThis should compile the necessary C-language programs (score, compare,
Xdigits, seconds, and shorten) and place score and seconds into the
Xcontest directory, along with judge, which is a shell script.
X
XMake accounts of the form teamxx, where xx is either a single digit, or
Xis a double digit.  What I mean is: team2, not team02.  Insure that
Xtheir PATH includes /usr/contest.  Insure that they can mail to judges
Xand that judges can mail to each of them.  Insure that they can read
X/tmp. (If I'm not talking to a root-priv person, forget it, and go send
Xall this stuff to your local administrator).  Make their passwords
Xwhatever you want, but something you can tell them in the poop-session
Xbefore the start of the contest.
X
XType
X% make install
X
XIf all goes well, you should be ready to go.  What I did was run
Xshutofflogins a half-hour before the start of the contest.  It
Xmesses with /etc/passwd by only allowing our magic system accounts,
Xselected faculty, and judges, and teamxx to survive, and all others
Xare taken out.  It needs "nawk" to work.  This step is probably
Xnot necessary;  I was just paranoid.  And, of course, needs to be
Xroot to mess with /etc/passwd.
X
XLong before start-time, edit the file "sf" to reflect the names of
Xyour teams.  Four man teams may not fit.  Truncate them accordingly.
X
XAt start time, type
X% start < sf
Xwhich will set up the scoreboard and start- and end-time files.
X
XTeams submit judged runs by
X% judge probX.pas
X
Xfor example.  The digit(s) (represented by X above) in the filename
Xmust reflect the problem number.  Extensions currently supported are
X.c, .f, .p, and .pas .
X
XThe judges' account must be able to read the teams' directories and
Xprograms.  This is why the teams directories should be readable by
Xgroup judges, but not readable by any other group, especially other
Xteams.  Only judges should be in group judges; and only owner and group
Xjudges should be able to read team directories and files.
X
XThe shell-script "gr" is actually the heart of this whole deal.  It
Xattempts to compile and execute the teams' submissions and to grade the
Xoutput either right or wrong.  The program "compare" was written to
Xfill the void caused by diff -b not working the way I wanted when one
Xof the lines did not begin with a blank.  Also, our fortran generates
Xgratuitious output when a 'stop' statement is executed.  I have not
Xfixed this problem.  What we did was tell those teams using fortran to
Xavoid use of the 'stop' statement.  Running off the end of main is much
Xnicer.
X
XThe little C-program chexec8.c simply executes the teams' submitted
Xprograms after compiling them into a small subdirectory.  The "8"
Xrefers to the eighth version of this little thing.  What made this not
Xjust a simple chdir, chroot, and exec program was a rather incredible
Xback-and-forth between me and a couple of my students in an advanced
Xclass:  "I can steal the input, and I can also steal other teams'
Xoutput".  "How?" "A daemon which never exits and looks in the current
Xdirectory for interesting stuff and copies it into its internal guts
X(remember that it belongs to you, "judges"), and when judges sends mail
Xto the other teams that somebody has solved a problem, it waits for
Xanother instance of turkey, and then sends to the correctly named
Xfiles, an output from its own guts, properly named, as if it were the
Xoutput of a correct run of that particular problem.  First iteration
Xsimply did the chroot.  Second piped input from above and output to
Xabove, doing about all it could except protecting against fork().  ...
Xetc.  What we finally decided was: judges should run the team-program,
Xand should INSURE that no process owned by judges should be allowed to
Xlive after the "first-child" of the judging chexec8 program exits.  I
Xcurrently have that simple-mindedly just issuing kill(...,9) calls to
Xthe next 200 processes.  This will not be sufficient on a busy system,
Xbut thats' where I left it for this time around.  The culprit would 
Xseem to be fork().  Really paranoid sysadmins would just remove
Xfork() from the system library, insure that no students who had
Xever in the past been allowed to login on this system had make
Xcopies of fork(), and ... etc.
X
XThis latter iteration on the possibility of stealing the input and or
Xthe output of other teams' runs was what caused this software to be
Xmore than several weeks late, and why other work, such as grading
Xpapers, has gone undone.  Comments are solicited; versions 1 thru 7 of
Xchexec.c are probably floating around somewhere.  Thanks to Steve
XPerry, David McGough, and Chris Spell for playing the Devil's Advocate
Xfor chexec.
X
XThe "solutions" provided are entirely by me; some of the other judges
Xsubmitted much nicer programs, but mine were written in a semi-contest
Xsituation of "quick and dirty", 'cause I had to write all twelve
Xsolutions one Saturday.  Really, folks, this is not my best code ...
XThey are all in C, although I did re-write a few of them in Pascal and
XFortran just for testing, I then threw those versions away. (No bigotry
Xaround here ...).
X
X
XBugs and flames to
Xnelson@ecsvax.uucp
X...mcnc!ecsvax!nelson
X(too bad it's not ...mcnc!ecsvax!uncw!nelson just yet ... we're
Xtrying)
X
XJim Nelson
XMathematical Sciences Dept.
XUniv. of NC at Wilmington
XWilmington, NC 28403
X919-395-3300 direct, or 919-395-3290 dept. office
END_OF_FILE
if test 7871 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'digits.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'digits.c'\"
else
echo shar: Extracting \"'digits.c'\" \(285 characters\)
sed "s/^X//" >'digits.c' <<'END_OF_FILE'
X#include <stdio.h>
Xmain(argc,argv)
Xchar *argv[];
X{
X	int i,k;
X	char *p,*q;
X	if(argc!=2)exit(1);
X	p=argv[1];
X	q=p;
X	p +=strlen(p)-1;
X	while(p>=q && *p!='/')p--;
X	p++;
X	for(;*p;p++)if(*p>='0' && *p<='9')break;
X	if(!*p){putchar('-');return;}
X	while(*p>='0' && *p<='9'){putchar(*p);p++;}
X}
END_OF_FILE
if test 285 -ne `wc -c <'digits.c'`; then
    echo shar: \"'digits.c'\" unpacked with wrong size!
fi
# end of 'digits.c'
fi
if test -f 'f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'f'\"
else
echo shar: Extracting \"'f'\" \(778 characters\)
sed "s/^X//" >'f' <<'END_OF_FILE'
X$1 == "root" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$1 == "nelson" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$1 == "norris" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$1 == "herbst" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$1 == "smithh" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$1 == "whipkey" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$1 == "daemon" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$1 == "usrlimit" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$1 == "judges" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$1 == "guest" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$1 == "score" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$1 ~  "team" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$1 ~  "uucp" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X$7 ~  "uucp" {print $1":"$2":"$3":"$4":"$5":"$6":"$7}
X
END_OF_FILE
if test 778 -ne `wc -c <'f'`; then
    echo shar: \"'f'\" unpacked with wrong size!
fi
# end of 'f'
fi
if test -f 'judge' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'judge'\"
else
echo shar: Extracting \"'judge'\" \(282 characters\)
sed "s/^X//" >'judge' <<'END_OF_FILE'
X#! /bin/sh
Xj=$HOME/$1
Xchgrp GROUP $j
Xchmod g+r $j
X# "seconds" must be in everybody's path
X#either /usr/uncw or /usr/local or somesuch
Xecho Judge: $j `seconds` \; `date`>>mailmsg$$
Xmail judges <mailmsg$$
X# leave the mail message in contestant's account (for evidence)
X#rm mailmsg$$
X
END_OF_FILE
if test 282 -ne `wc -c <'judge'`; then
    echo shar: \"'judge'\" unpacked with wrong size!
fi
chmod +x 'judge'
# end of 'judge'
fi
if test -f 'n' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'n'\"
else
echo shar: Extracting \"'n'\" \(40 characters\)
sed "s/^X//" >'n' <<'END_OF_FILE'
Xcp /dev/null $1
X# like
X# > file
X# in sh
END_OF_FILE
if test 40 -ne `wc -c <'n'`; then
    echo shar: \"'n'\" unpacked with wrong size!
fi
chmod +x 'n'
# end of 'n'
fi
if test -f 'prob1.ans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob1.ans'\"
else
echo shar: Extracting \"'prob1.ans'\" \(16 characters\)
sed "s/^X//" >'prob1.ans' <<'END_OF_FILE'
X3
X112
X6555
X9743
END_OF_FILE
if test 16 -ne `wc -c <'prob1.ans'`; then
    echo shar: \"'prob1.ans'\" unpacked with wrong size!
fi
# end of 'prob1.ans'
fi
if test -f 'prob1.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob1.in'\"
else
echo shar: Extracting \"'prob1.in'\" \(74 characters\)
sed "s/^X//" >'prob1.in' <<'END_OF_FILE'
X9743 3
X3 6555
X21 48
X22 112
X3 29
X6555 18
X3 29
X19 9743
X112 49
X6555 12
X-1 -1
END_OF_FILE
if test 74 -ne `wc -c <'prob1.in'`; then
    echo shar: \"'prob1.in'\" unpacked with wrong size!
fi
# end of 'prob1.in'
fi
if test -f 'prob1.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob1.txt'\"
else
echo shar: Extracting \"'prob1.txt'\" \(701 characters\)
sed "s/^X//" >'prob1.txt' <<'END_OF_FILE'
XProblem 1: Cast out duplicate integers.
X
XThe input file will contain integers, two per line, with one
Xblank between the two numbers.
X
XThe two numbers are to be treated a belonging to two arrays,
Xsay left and right.  
X
XThe numbers will be greater than or equal to 0, and less than
Xor equal to 32767.  There will be fewer than five hundred pairs
Xof numbers.
X
XThe last record will contain
X-1 -1
X
XPrint, one per line, in ascending order, those numbers which appear 
Xin both the left-array and the right-array.  Print a particular 
Xnumber only once, even though it may appear in an array more than once.
X
XExample:
X
X9743 3
X3 6555
X21 48
X3 29
X19 9743
X-1 -1
X
XFor the example, the correct output will be
X3
X9743
END_OF_FILE
if test 701 -ne `wc -c <'prob1.txt'`; then
    echo shar: \"'prob1.txt'\" unpacked with wrong size!
fi
# end of 'prob1.txt'
fi
if test -f 'prob13.ans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob13.ans'\"
else
echo shar: Extracting \"'prob13.ans'\" \(21 characters\)
sed "s/^X//" >'prob13.ans' <<'END_OF_FILE'
X1100
X0
X-111
X10
X10001
END_OF_FILE
if test 21 -ne `wc -c <'prob13.ans'`; then
    echo shar: \"'prob13.ans'\" unpacked with wrong size!
fi
# end of 'prob13.ans'
fi
if test -f 'prob13.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob13.in'\"
else
echo shar: Extracting \"'prob13.in'\" \(72 characters\)
sed "s/^X//" >'prob13.in' <<'END_OF_FILE'
X      110+11-1 +   100
X
X1100-   11000  +111-10
X101-11
X	1111 + 11 -    1
END_OF_FILE
if test 72 -ne `wc -c <'prob13.in'`; then
    echo shar: \"'prob13.in'\" unpacked with wrong size!
fi
# end of 'prob13.in'
fi
if test -f 'prob14.ans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob14.ans'\"
else
echo shar: Extracting \"'prob14.ans'\" \(315 characters\)
sed "s/^X//" >'prob14.ans' <<'END_OF_FILE'
X1 20
X1 30
X1 40
X1 50
X1 60
X1 70
X1 80
X1 90
X2 60
X2 80
X2 100
X2 120
X2 140
X2 160
X2 180
X3 120
X3 150
X3 180
X3 210
X3 240
X3 270
X4 200
X4 240
X4 280
X4 320
X4 360
X5 300
X5 350
X5 400
X5 450
X6 420
X6 480
X6 540
X7 560
X7 630
X8 720
X12 504
X12 756
X12 1008
X13 806
X13 1209
X14 1148
X23 1472
X23 2208
X24 1512
X24 2016
X26 2418
X34 2924
X36 3024
X46 4416
END_OF_FILE
if test 315 -ne `wc -c <'prob14.ans'`; then
    echo shar: \"'prob14.ans'\" unpacked with wrong size!
fi
# end of 'prob14.ans'
fi
if test -f 'prob14.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob14.in'\"
else
echo shar: Extracting \"'prob14.in'\" \(0 characters\)
sed "s/^X//" >'prob14.in' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'prob14.in'`; then
    echo shar: \"'prob14.in'\" unpacked with wrong size!
fi
# end of 'prob14.in'
fi
if test -f 'prob15.ans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob15.ans'\"
else
echo shar: Extracting \"'prob15.ans'\" \(160 characters\)
sed "s/^X//" >'prob15.ans' <<'END_OF_FILE'
X5 10 2 8 1 9 4 13 12 3 7 11  6
X14 13 15 2 5 9 3 11 10 1 8 4 7 6  12
X17 1 3 6 10 15 8 2 14 16 7 4 9 11 13 5  12
X1 3 6 10 15 4 13 7 19 18 5 12 9 14 11 8 17 16  2
END_OF_FILE
if test 160 -ne `wc -c <'prob15.ans'`; then
    echo shar: \"'prob15.ans'\" unpacked with wrong size!
fi
# end of 'prob15.ans'
fi
if test -f 'prob15.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob15.c'\"
else
echo shar: Extracting \"'prob15.c'\" \(334 characters\)
sed "s/^X//" >'prob15.c' <<'END_OF_FILE'
Xmain(){
X	int a[500];
Xint	m,n,i,j,num,pn,M,N;
Xfor(pn=0;pn<4;pn++){
X	scanf("%d%d",&M,&N);
X	n=N;
X	m=M;
X	for(i=1;i<=n+1;i++)a[i]=i;
X
Xloop:
X	if(m>n)m=1;
X	printf("%d ",a[m]);
X	for(j=m;j<=100;j++)a[j]=a[j+1];
X	n--;
X	if(m>n)m=1;
X	if(n==1){printf(" %d\n", a [m]);continue;}
X	for(i=1;i<=M-1;i++){if(m>n)m=1;m++;if(m>n)m=1;}
X	goto loop;
X
X
X
X
X}
X}
END_OF_FILE
if test 334 -ne `wc -c <'prob15.c'`; then
    echo shar: \"'prob15.c'\" unpacked with wrong size!
fi
# end of 'prob15.c'
fi
if test -f 'prob15.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob15.in'\"
else
echo shar: Extracting \"'prob15.in'\" \(40 characters\)
sed "s/^X//" >'prob15.in' <<'END_OF_FILE'
X   5   13
X  14   15
X  17   17
X  20   19
END_OF_FILE
if test 40 -ne `wc -c <'prob15.in'`; then
    echo shar: \"'prob15.in'\" unpacked with wrong size!
fi
# end of 'prob15.in'
fi
if test -f 'prob16.ans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob16.ans'\"
else
echo shar: Extracting \"'prob16.ans'\" \(128 characters\)
sed "s/^X//" >'prob16.ans' <<'END_OF_FILE'
X 1  2  13  16  19  20  27  29  30 
X 3 
X 4  5  9  11  14  15  21  22  23  24  26  32  33 
X 6  7  25  31 
X 8  10  12  17  18  28 
END_OF_FILE
if test 128 -ne `wc -c <'prob16.ans'`; then
    echo shar: \"'prob16.ans'\" unpacked with wrong size!
fi
# end of 'prob16.ans'
fi
if test -f 'prob16.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob16.in'\"
else
echo shar: Extracting \"'prob16.in'\" \(319 characters\)
sed "s/^X//" >'prob16.in' <<'END_OF_FILE'
X   28   33
X   22   33
X   13   20
X    9   11
X   16   29
X   25    7
X   24   15
X   11   23
X   18   28
X   27    2
X    6   31
X   32   11
X    1   27
X   10   12
X   26    5
X   19   16
X   33    9
X   12    8
X    4   14
X    7   31
X   28   17
X   21    4
X    9    5
X   30   20
X   15   21
X   13   29
X    8   28
X   27   16
X   23   14
END_OF_FILE
if test 319 -ne `wc -c <'prob16.in'`; then
    echo shar: \"'prob16.in'\" unpacked with wrong size!
fi
# end of 'prob16.in'
fi
if test -f 'prob17.ans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob17.ans'\"
else
echo shar: Extracting \"'prob17.ans'\" \(361 characters\)
sed "s/^X//" >'prob17.ans' <<'END_OF_FILE'
X5 8 is inside triangle 1
X7 5 is outside triangle 1
X7 10 is outside triangle 1
X8 5 is inside triangle 1
X10 4 is inside triangle 1
X10 8 is inside triangle 1
X11 6 is outside triangle 1
X5 2 is outside triangle 2
X5 7 is outside triangle 2
X5 8 is inside triangle 2
X6 6 is inside triangle 2
X6 8 is outside triangle 2
X8 5 is outside triangle 2
X9 2 is inside triangle 2
END_OF_FILE
if test 361 -ne `wc -c <'prob17.ans'`; then
    echo shar: \"'prob17.ans'\" unpacked with wrong size!
fi
# end of 'prob17.ans'
fi
if test -f 'prob17.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob17.in'\"
else
echo shar: Extracting \"'prob17.in'\" \(180 characters\)
sed "s/^X//" >'prob17.in' <<'END_OF_FILE'
X   3   7
X   9  11
X  12   3
X   5   8
X   7   5
X   7  10
X   8   5
X  10   4
X  10   8
X  11   6
X   4  11
X   6   4
X  10   1
X   5   2
X   5   7
X   5   8
X   6   6
X   6   8
X   8   5
X   9   2
END_OF_FILE
if test 180 -ne `wc -c <'prob17.in'`; then
    echo shar: \"'prob17.in'\" unpacked with wrong size!
fi
# end of 'prob17.in'
fi
if test -f 'prob18.ans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob18.ans'\"
else
echo shar: Extracting \"'prob18.ans'\" \(200 characters\)
sed "s/^X//" >'prob18.ans' <<'END_OF_FILE'
X
Xthequickbrownfoxjumpsoverthelazydog'sbackcqcqdek4xehownowbrowncow
Xkcex4czydoqhworbwkaasovertgcon******woeblpownfoxjuh'qwc**********ondsemrthequickb
X
Ximroft thee **lla  snow i
Xnow is the time for all
END_OF_FILE
if test 200 -ne `wc -c <'prob18.ans'`; then
    echo shar: \"'prob18.ans'\" unpacked with wrong size!
fi
# end of 'prob18.ans'
fi
if test -f 'prob18.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob18.in'\"
else
echo shar: Extracting \"'prob18.in'\" \(106 characters\)
sed "s/^X//" >'prob18.in' <<'END_OF_FILE'
Xencode
Xthequickbrownfoxjumpsoverthelazydog'sbackcqcqdek4xehownowbrowncow
Xdecode
Ximroft thee **lla  snow i
END_OF_FILE
if test 106 -ne `wc -c <'prob18.in'`; then
    echo shar: \"'prob18.in'\" unpacked with wrong size!
fi
# end of 'prob18.in'
fi
if test -f 'prob2.ans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob2.ans'\"
else
echo shar: Extracting \"'prob2.ans'\" \(220 characters\)
sed "s/^X//" >'prob2.ans' <<'END_OF_FILE'
X    9    1
X   32   12
X   97    5
X   98    1
X   99    1
X  100    3
X  101    9
X  102    2
X  103    1
X  104    5
X  105    4
X  108    2
X  109    4
X  110    1
X  111    7
X  112    2
X  114    4
X  115    2
X  116   10
X  121    3
END_OF_FILE
if test 220 -ne `wc -c <'prob2.ans'`; then
    echo shar: \"'prob2.ans'\" unpacked with wrong size!
fi
# end of 'prob2.ans'
fi
if test -f 'prob2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob2.c'\"
else
echo shar: Extracting \"'prob2.c'\" \(308 characters\)
sed "s/^X//" >'prob2.c' <<'END_OF_FILE'
Xmain()
X{
X	char line[99];
X
X	int count[256];
X	int i;
X		char *gets();
X
X	for(i=0;i<256;i++)count[i]=0;
X	while( gets(line)==line )
X		for(i=0;line[i] && line[i]!='\n';i++)
X			count[ line[i] ]++;
X		
X	printf("%5d%5d\n",'\t',count['\t']);
X	for(i=' ';i<0177;i++) if(count[i])printf("%5d%5d\n",i,count[i]);
X	exit(0);
X}
END_OF_FILE
if test 308 -ne `wc -c <'prob2.c'`; then
    echo shar: \"'prob2.c'\" unpacked with wrong size!
fi
# end of 'prob2.c'
fi
if test -f 'prob2.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob2.in'\"
else
echo shar: Extracting \"'prob2.in'\" \(84 characters\)
sed "s/^X//" >'prob2.in' <<'END_OF_FILE'
Xtime for all
X	good men to
Xcome to the aid of
Xtheie party
Xthirty days hath september
END_OF_FILE
if test 84 -ne `wc -c <'prob2.in'`; then
    echo shar: \"'prob2.in'\" unpacked with wrong size!
fi
# end of 'prob2.in'
fi
if test -f 'prob3.ans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob3.ans'\"
else
echo shar: Extracting \"'prob3.ans'\" \(103 characters\)
sed "s/^X//" >'prob3.ans' <<'END_OF_FILE'
XThe quick brown fox jumps over the lazy dog's back.
XThe quick blue fox jumps over the lazy dog's back.
END_OF_FILE
if test 103 -ne `wc -c <'prob3.ans'`; then
    echo shar: \"'prob3.ans'\" unpacked with wrong size!
fi
# end of 'prob3.ans'
fi
if test -f 'prob3.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob3.c'\"
else
echo shar: Extracting \"'prob3.c'\" \(188 characters\)
sed "s/^X//" >'prob3.c' <<'END_OF_FILE'
Xmain(){
X	char line[256];
X	int i;
X	char *gets();
X	while(gets(line)==line){
X		i=0;
X		while(line[i]>=' ' || line[i]=='\t')i++;
X		i--;
X		while(i>=0){putchar(line[i--]);}
X		putchar('\n');
X	}
X}
END_OF_FILE
if test 188 -ne `wc -c <'prob3.c'`; then
    echo shar: \"'prob3.c'\" unpacked with wrong size!
fi
# end of 'prob3.c'
fi
if test -f 'prob3.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob3.in'\"
else
echo shar: Extracting \"'prob3.in'\" \(103 characters\)
sed "s/^X//" >'prob3.in' <<'END_OF_FILE'
X.kcab s'god yzal eht revo spmuj xof nworb kciuq ehT
X.kcab s'god yzal eht revo spmuj xof eulb kciuq ehT
END_OF_FILE
if test 103 -ne `wc -c <'prob3.in'`; then
    echo shar: \"'prob3.in'\" unpacked with wrong size!
fi
# end of 'prob3.in'
fi
if test -f 'prob3.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob3.txt'\"
else
echo shar: Extracting \"'prob3.txt'\" \(753 characters\)
sed "s/^X//" >'prob3.txt' <<'END_OF_FILE'
XProblem 3: Reverse the characters in a line.
X
XFor each line in a file (on the standard input), reverse
Xthe order of the characters in the line.
X
XThere is an unknown, but fairly small (less than ten thousand)
Xnumber of lines in the input file.
X
XEach line is guaranteed to be less than 80 characters long.
X
XFor example, if the file on stdin consists of exactly two lines:
X
Xhello
Xworld!
X
Xthen the output should be
X
Xolleh
X!dlrow
X
Xon exactly two lines.  The byte count of a correct output for the
Xexample would be 13 (remember that the newlines count as bytes).
XThe blank lines in the above listing of the explanation are not 
Xpart of the output.  Note that each output line should be left-
Xjustified (e.g., the ! in the example must come out in column 1).
X
END_OF_FILE
if test 753 -ne `wc -c <'prob3.txt'`; then
    echo shar: \"'prob3.txt'\" unpacked with wrong size!
fi
# end of 'prob3.txt'
fi
if test -f 'prob4.ans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob4.ans'\"
else
echo shar: Extracting \"'prob4.ans'\" \(23 characters\)
sed "s/^X//" >'prob4.ans' <<'END_OF_FILE'
X1 2
X3 6
X-1 4
X-1 6
X-1 6
END_OF_FILE
if test 23 -ne `wc -c <'prob4.ans'`; then
    echo shar: \"'prob4.ans'\" unpacked with wrong size!
fi
# end of 'prob4.ans'
fi
if test -f 'prob4.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob4.c'\"
else
echo shar: Extracting \"'prob4.c'\" \(768 characters\)
sed "s/^X//" >'prob4.c' <<'END_OF_FILE'
Xmain(){
X/*	integer odds(100),evens(100)*/
X	int odds[101],evens[101];
X	int k; /*had to be added... fortran implicitly declared it*/
X/*	integer a*/
X	int a;
X/*	integer i,j*/
X	int i,j;
X
X/*	i=1*/
X/*	j=1*/
X	i=j=1;
X/*	do 10 k=1,100*/
X	for(k=1;k<=100;k++)odds[k]=evens[k]= -1;
X/*	odds(k)= -1*/
X/*10	evens(k)= -1*/
X
X/*1	read*,a*/
Xloop: scanf("%d",&a);
X/*	if(a.lt.0)goto 4*/
X	if(a<0)goto out;
X/*	if( mod(a,2) .eq. 0)goto 2*/
X/*	odds(i)=a*/
X/*	i= i+1*/
X/*	goto 3*/
X/*2	evens(j)=a*/
X/*	j=j+1*/
X/*3	continue*/
X	if(a%2)odds[i++]=a;
X	else evens[ j++]=a;
X/*	goto 1*/
X	goto loop;
X
X/*4	continue*/
Xout:
X/*	j = max(i,j) -1*/
X	j= (j>i?j:i)-1;
X	for(i=1;i<=j;i++)
X/*	do 5 i=1,j*/
X/*	print*,odds(i),evens(i)*/
X	printf("%d %d\n",odds[i],evens[i]);
X/*5	continue*/
X/*	stop*/
X/*	end*/
Xexit(0);
X}
END_OF_FILE
if test 768 -ne `wc -c <'prob4.c'`; then
    echo shar: \"'prob4.c'\" unpacked with wrong size!
fi
# end of 'prob4.c'
fi
if test -f 'prob4.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob4.in'\"
else
echo shar: Extracting \"'prob4.in'\" \(25 characters\)
sed "s/^X//" >'prob4.in' <<'END_OF_FILE'
X 1
X       3
X2
X6
X4
X6
X6
X-1
END_OF_FILE
if test 25 -ne `wc -c <'prob4.in'`; then
    echo shar: \"'prob4.in'\" unpacked with wrong size!
fi
# end of 'prob4.in'
fi
if test -f 'prob5.ans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob5.ans'\"
else
echo shar: Extracting \"'prob5.ans'\" \(16 characters\)
sed "s/^X//" >'prob5.ans' <<'END_OF_FILE'
X4
X3
X1
X0
X6
X4
X2
X3
END_OF_FILE
if test 16 -ne `wc -c <'prob5.ans'`; then
    echo shar: \"'prob5.ans'\" unpacked with wrong size!
fi
# end of 'prob5.ans'
fi
if test -f 'prob5.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob5.c'\"
else
echo shar: Extracting \"'prob5.c'\" \(284 characters\)
sed "s/^X//" >'prob5.c' <<'END_OF_FILE'
Xmain()
X{
X	char line[256];
X	int i,j,wc;
X	char *gets();
X	
X	while( gets(line)==line)
X	{
X		if(strlen(line)==0){printf("0\n");continue;}
X		i=0;
X		wc=0;
X	for(i=0;line[i];i++){
X	if(line[i]>='a' && line[i]<='z'){
X						if(line[i+1]<'a' ||line[i+1]>'z')wc++;
X			}
X	}
X	printf("%d\n",wc);
X	}
X}
X
END_OF_FILE
if test 284 -ne `wc -c <'prob5.c'`; then
    echo shar: \"'prob5.c'\" unpacked with wrong size!
fi
# end of 'prob5.c'
fi
if test -f 'prob5.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob5.in'\"
else
echo shar: Extracting \"'prob5.in'\" \(136 characters\)
sed "s/^X//" >'prob5.in' <<'END_OF_FILE'
Xnow is the time
X thirty days hath
X   september
X
X   testing testing cqcqcq de k4xe
X   how now brown cow
X   more words
X   some more words
END_OF_FILE
if test 136 -ne `wc -c <'prob5.in'`; then
    echo shar: \"'prob5.in'\" unpacked with wrong size!
fi
# end of 'prob5.in'
fi
if test -f 'prob6.ans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob6.ans'\"
else
echo shar: Extracting \"'prob6.ans'\" \(116 characters\)
sed "s/^X//" >'prob6.ans' <<'END_OF_FILE'
X1 2 3 4 6 0
X4 3 2 1 0 6
X1 3 2 4 5 1
X1 2 4 3 5 1
X3 4 1 2 2 4
X3 4 2 1 1 5
X2733 13274 11 1 1 5
X4 3 2 5 3 3
X6 4 3 5 2 4
END_OF_FILE
if test 116 -ne `wc -c <'prob6.ans'`; then
    echo shar: \"'prob6.ans'\" unpacked with wrong size!
fi
# end of 'prob6.ans'
fi
if test -f 'prob6.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob6.c'\"
else
echo shar: Extracting \"'prob6.c'\" \(266 characters\)
sed "s/^X//" >'prob6.c' <<'END_OF_FILE'
Xmain(){
X	int i,j;
X	int lt,gt,a[4];
X	while( scanf("%d%d%d%d",&a[0],&a[1],&a[2],&a[3])==4){
X	if(a[0]<0)exit(0);
X	gt=lt=0;
X	for(i=0;i<=2;i++)for(j=i+1;j<=3;j++){
X	if(a[i]<a[j])lt++;
X	if(a[i]>a[j])gt++;
X	}
X	printf("%d %d %d %d %d %d\n",a[0],a[1],a[2],a[3],lt,gt);
X	}
X	}
END_OF_FILE
if test 266 -ne `wc -c <'prob6.c'`; then
    echo shar: \"'prob6.c'\" unpacked with wrong size!
fi
# end of 'prob6.c'
fi
if test -f 'prob6.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prob6.in'\"
else
echo shar: Extracting \"'prob6.in'\" \(92 characters\)
sed "s/^X//" >'prob6.in' <<'END_OF_FILE'
X1 2 3 4
X4 3 2 1
X1 3 2 4
X1 2 4 3
X3 4 1 2
X3 4 2 1
X2733 13274 11 1
X4 3 2 5
X6 4 3 5
X-1 -1 -1 -1
END_OF_FILE
if test 92 -ne `wc -c <'prob6.in'`; then
    echo shar: \"'prob6.in'\" unpacked with wrong size!
fi
# end of 'prob6.in'
fi
if test -f 'rules' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rules'\"
else
echo shar: Extracting \"'rules'\" \(44 characters\)
sed "s/^X//" >'rules' <<'END_OF_FILE'
X/usr/local/bin/less /usr/news/contestrules
X
END_OF_FILE
if test 44 -ne `wc -c <'rules'`; then
    echo shar: \"'rules'\" unpacked with wrong size!
fi
chmod +x 'rules'
# end of 'rules'
fi
if test -f 'scoreascorrect' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scoreascorrect'\"
else
echo shar: Extracting \"'scoreascorrect'\" \(653 characters\)
sed "s/^X//" >'scoreascorrect' <<'END_OF_FILE'
Xif test -f lock
Xthen
Xecho busy
Xexit
Xelse
Xtouch lock
Xfi
Xecho "team no. ?"
Xread t
Xecho "problem no. ?"
Xread q
Xmv t${t}p${q}* keep
Xt=team$t
X#	echo "1" $qq $q $seconds>>scoreboard
X# do this manually
X
X	echo yes their output is correct
X	echo you must manually edit the scoreboard and change the
X	echo desired \"0\" in col 1 to a \"1\"
X	echo \
X	"CONGRATS! $t successfully did prob$q at `date`">\
X		$src.done
X	mail $t < $src.done
X	echo "submitted: $seconds">$src.at
X	echo "$t completed problem $q at `date`">$src.msg
X	list=""
X	for i in `cat listofteams` ; do
X		case $i in
X			$t) ;;
X			*) list="$list $i"
X			;;
X		esac
X	done
X	mail $list < $src.msg
X	rm lock
X	exit
END_OF_FILE
if test 653 -ne `wc -c <'scoreascorrect'`; then
    echo shar: \"'scoreascorrect'\" unpacked with wrong size!
fi
chmod +x 'scoreascorrect'
# end of 'scoreascorrect'
fi
if test -f 'scoreasincorre' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scoreasincorre'\"
else
echo shar: Extracting \"'scoreasincorre'\" \(470 characters\)
sed "s/^X//" >'scoreasincorre' <<'END_OF_FILE'
X	echo "team no. ?"
X	read qq
X	t=team$qq
X	echo "problem no. ?"
X	read q
X	p=prob$q
X	seconds=`seconds`
X	echo "0" $qq $q $seconds >>scoreboard
X
X	echo not correct
X	echo if necessary, you must manually change the appropriate
X	echo \"0\" in scoreboard
X	echo  "do you wish to mail them an explanatory note? "
X	read zork
X	case $zork in
X		y) 
X		echo "mail $t"
X		mail -s "$p" $t
X		;;
X		*) echo "your $p not correct">failure$$
X		mail -s "$p" $t<failure$$
X		rm -f failure$$
X		;;
X	esac
END_OF_FILE
if test 470 -ne `wc -c <'scoreasincorre'`; then
    echo shar: \"'scoreasincorre'\" unpacked with wrong size!
fi
chmod +x 'scoreasincorre'
# end of 'scoreasincorre'
fi
if test -f 'scoreboard' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scoreboard'\"
else
echo shar: Extracting \"'scoreboard'\" \(246 characters\)
sed "s/^X//" >'scoreboard' <<'END_OF_FILE'
X21
X1 3 prentice,hall
X2 3 addison,wesley
X3 3 bob,carol,ted,alice
X4 3 von,neumann
X5 2 eckert,mauchly
X6 2 boole,babbage
X7 1 romeo,juliet
X8 1 laurel,hardy
X9 1 a_g_bell,watson
X10 1 abbott,costello
X11 1 hansel,gretel
X12 1 the_judges
X-1 -1 xx
X596574216
END_OF_FILE
if test 246 -ne `wc -c <'scoreboard'`; then
    echo shar: \"'scoreboard'\" unpacked with wrong size!
fi
# end of 'scoreboard'
fi
if test -f 'seconds.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'seconds.c'\"
else
echo shar: Extracting \"'seconds.c'\" \(65 characters\)
sed "s/^X//" >'seconds.c' <<'END_OF_FILE'
Xmain(){
X	long time(), t;
X	printf("%ld\n",time( (long *) 0 ));
X	}
END_OF_FILE
if test 65 -ne `wc -c <'seconds.c'`; then
    echo shar: \"'seconds.c'\" unpacked with wrong size!
fi
# end of 'seconds.c'
fi
if test -f 'sf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sf'\"
else
echo shar: Extracting \"'sf'\" \(227 characters\)
sed "s/^X//" >'sf' <<'END_OF_FILE'
X1
X3
Xprentice,hall
X2
X3
Xaddison,wesley
X3
X3
Xbob,carol,ted,alice
X4
X3
Xvon,neumann
X5
X2
Xeckert,mauchly
X6
X2
Xboole,babbage
X7
X1
Xromeo,juliet
X8
X1
Xlaurel,hardy
X9
X1
Xa_g_bell,watson
X10
X1
Xabbott,costello
X11
X1
Xhansel,gretel
X12
X1
Xthe_judges
X-1
END_OF_FILE
if test 227 -ne `wc -c <'sf'`; then
    echo shar: \"'sf'\" unpacked with wrong size!
fi
# end of 'sf'
fi
if test -f 'shorten.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shorten.c'\"
else
echo shar: Extracting \"'shorten.c'\" \(359 characters\)
sed "s/^X//" >'shorten.c' <<'END_OF_FILE'
X#include <stdio.h>
X#define zero '0'
X#define nine '9'
Xmain(argc,argv)
Xchar *argv[];
X{
X	int i,k;
X	char *p,*q;
X	if(argc!=2)exit(1);
X	p=argv[1];
X	putchar('t');
X	while( *p &&(*p<zero || *p>nine))p++;
X	while(*p &&(*p>=zero && *p<=nine)){putchar(*p);p++;}
X	putchar('p');
X	while( *p &&(*p<zero || *p>nine))p++;
X	while(*p &&(*p>=zero && *p<=nine)){putchar(*p);p++;}
X}
END_OF_FILE
if test 359 -ne `wc -c <'shorten.c'`; then
    echo shar: \"'shorten.c'\" unpacked with wrong size!
fi
# end of 'shorten.c'
fi
if test -f 'shutofflogins' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shutofflogins'\"
else
echo shar: Extracting \"'shutofflogins'\" \(212 characters\)
sed "s/^X//" >'shutofflogins' <<'END_OF_FILE'
X#! /bin/sh
X/usr/uncw/nawk -F: -f f /etc/passwd >passwd
X/bin/cp /etc/passwd /etc/passwd.precon
X/bin/cp passwd /etc/passwd
Xfor i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14
Xdo
X/bin/cp /dev/null /usr/spool/mail/team$i
Xdone
END_OF_FILE
if test 212 -ne `wc -c <'shutofflogins'`; then
    echo shar: \"'shutofflogins'\" unpacked with wrong size!
fi
chmod +x 'shutofflogins'
# end of 'shutofflogins'
fi
if test -f 'syserr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'syserr.c'\"
else
echo shar: Extracting \"'syserr.c'\" \(294 characters\)
sed "s/^X//" >'syserr.c' <<'END_OF_FILE'
X#ifndef stderr
X#include <stdio.h>
X#endif
X
Xvoid syserr(msg)
Xchar *msg;
X{
X	extern int errno, sys_nerr;
X	extern char *sys_errlist[];
X	fprintf(stderr,"ERROR: %s (%d",msg,errno);
X	if(errno>0&&errno<sys_nerr)
X		fprintf(stderr,"; %s)\n",sys_errlist[errno]);
X	else
X		fprintf(stderr,")\n");
X	exit(1);
X}
END_OF_FILE
if test 294 -ne `wc -c <'syserr.c'`; then
    echo shar: \"'syserr.c'\" unpacked with wrong size!
fi
# end of 'syserr.c'
fi
if test -f 'testem' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'testem'\"
else
echo shar: Extracting \"'testem'\" \(487 characters\)
sed "s/^X//" >'testem' <<'END_OF_FILE'
X#! /bin/sh
Xfor i in 1 2 3 4 5 6 13 14 15 16 17 18
Xdo
Xecho $i
Xif test -f prob$i.ok
Xthen
Xcontinue
Xfi
Xif test -f prob$i.e
Xthen
X:
Xelse
Xbduflag=""
Xcase $i in
X	*17*) echo cc  ${bduflag} prob17.c -o prob17.e
X	 cc  ${bduflag} prob17.c -o prob17.e -lm;;
X	*) echo cc prob$i.c -o prob$i.e
X	 cc prob$i.c -o prob$i.e ;;
Xesac
Xfi
Xecho $i
Xprob$i.e<prob$i.in>prob$i.tst
Xif compare prob$i.ans prob$i.tst
Xthen
Xecho ok
Xcp /dev/null prob$i.ok
Xelse
Xecho bad
Xrm prob$i.e
Xfi
X
X
X
Xdiff prob$i.ans prob$i.tst
Xdone
X
END_OF_FILE
if test 487 -ne `wc -c <'testem'`; then
    echo shar: \"'testem'\" unpacked with wrong size!
fi
chmod +x 'testem'
# end of 'testem'
fi
if test -f 'visc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'visc'\"
else
echo shar: Extracting \"'visc'\" \(90 characters\)
sed "s/^X//" >'visc' <<'END_OF_FILE'
X#! /bin/sh
Xif test -f lock
Xthen
X	echo locked
X	exit
Xfi
Xtouch lock
Xvi ++ scoreboard
Xrm lock
END_OF_FILE
if test 90 -ne `wc -c <'visc'`; then
    echo shar: \"'visc'\" unpacked with wrong size!
fi
chmod +x 'visc'
# end of 'visc'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

