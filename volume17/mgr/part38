Subject:  v17i039:  MGR, Bellcore window manager, Part38/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 39
Archive-name: mgr/part38




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 38 (of 61)."
# Contents:  doc/mgr.1 lib/term.h src/blit/blit.C
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:47 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/mgr.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/mgr.1'\"
else
echo shar: Extracting \"'doc/mgr.1'\" \(14459 characters\)
sed "s/^X//" >'doc/mgr.1' <<'END_OF_FILE'
X'\"                        Copyright (c) 1988 Bellcore
X'\"                            All Rights Reserved
X'\"       Permission is granted to copy or use this program, EXCEPT that it
X'\"       may not be sold for profit, the copyright notice must be reproduced
X'\"       on copies, and credit should be given to Bellcore where it is due.
X'\"       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X'\"
X'\"	$Header: mgr.1,v 4.5 88/07/18 08:08:00 sau Exp $
X'\"	$Source: /tmp/mgrsrc/doc/RCS/mgr.1,v $
X.ds M \fBM\s-2GR\s+2\fP
X.TH \*M 1L "April 30, 1985"
X.SH NAME
Xmgr \- manage windows on a \fB\s-2SUN\s+2\fP Workstation
X.SH SYNOPSIS
Xmgr
X[ \fB\-f\fP\fIfont_dir\fP ]
X[ \fB\-i\fP\fIicon_dir\fP ]
X[ \fB\-s\fP\fIstartup_file\fP ]
X.if n .ti +0.5i
X[ \fB\-n\fP ]
X[ \fB\-x\fP ]
X[ \fB\-v\fP ]
X[ \fB\-V\fP ]
X[ \fB\-F\fP\fIdefault_font\fP ]
X.ti +0.5i
X{
X[ \fB\-d\fP\fIlist\fP ]
X[ \fB\-m\fP \fImouse_device\fP ]
X[ \fB\-B\fP\fIwindow_buff\fP ]
X[ \fB\-b\fP\fIshell_buff\fP ]
X.if n .ti +0.5i
X[ \fB\-P\fP\fIpoll_interval\fP ]
X.ti +0.5i
X[ \fB\-S\fP\fIscreen\fP ]
X}
X.SH DESCRIPTION
X.I Mgr
Xis a window manager for the \fB\s-2SUN\s+2\fP
Xworkstation.
XIt permits the creation and manipulation of overlapping
Xwindows, with different processes running in each window.
XThe user controls the function and layout of the display with a mouse.
XWindows are updated asynchronously even if they are partially (or
Xcompletely) obscured by other windows,
Xalthough obscured windows may arrange to have their
Xoutput suspended until the window is uncovered.
X.LP
XEach window runs a terminal emulator which, in addition to the functions
Xnormally required to run screen oriented programs, such as
X.I vi,
Xprovides primitives for drawing lines, doing 
X.I bit-blts,
Xand performing administrative functions such as 
X.I reshaping
Xthe window,
Xchanging
X.I fonts,
Xor
Xstarting a new window.
XDetails of of the terminal emulator operation are described in
Xthe \*M - C Language Application Interface.
X.LP
XThe useful command line options are:
X.TP
X.BI \-f font_dir
XUse
X.I font_dir
Xas the directory to find the fonts, instead of
X.B /usr/mgr/font.
X.TP
X.BI \-i icon_dir
XUse
X.I icon_dir
Xas the directory to find the icons, instead of
X.B /usr/mgr/icon.
X.TP
X.BI \-s startup_file
XUse 
X.I startup file
Xinstead of
X.B $HOME/.mgrc
Xto obtain initial configuration information.
XSee the description of startup commands below.
X.TP 
X.B \-n
XBitmap files are created using the new, portable bitmap format.  The
Xportable format has an 8 byte header, and each row is padded to a byte
Xboundary.
XOrdinarily the old (6 byte) bitmap header is
Xproduced, followed by the bitmap data with each line padded to an 16
Xbit boundary.  Eventually, the sense of 
X.B \-n
Xwill change, when all of the programs that were written in the old
Xformat are changed.
X.TP 
X.B \-x
XDon't use a startup file upon execution.
X.TP 
X.B \-v
XDon't run 
X\*M
Xat all.  Print the current version number and creation date instead.
X.TP 
X.B \-V
XJust like
X.B \-v
Xabove only prints the compile flags used to make
X\*M and its home directory.
X.TP
X.BI \-F default_font
XUse
X.I default_font
Xas the pathname of a \*M font to be used in place of \*M's
Xbuiltin default font.
X.LP
XThe rest of the options are:
X.TP 
X.BI \-d list
XPrint debugging information on 
X.I stderr.
X.I list
Xis one or more of the characters:
X.B *ABCEFMNPSUbcdefilmnopsuwxy
Xeach of which turns on debugging output for some aspect of \*M.
X.TP 
X.BI \-m mouse_device
XUse 
X.I mouse_device
Xinstead of
X.B /dev/mouse
Xto obtain mouse coordinates.
X.TP
X.BI \-S screen
XUse
X.I screen
Xinstead of
X.B /dev/bwtwo0
Xas the display device.
X.TP
X.BI \-B win_buff
XProcess characters to a window in up to
X.I win_buff
Xbyte chunks (the default is 40).
X.TP
X.BI \-b shell_buff
XBuffer up to 
X.I shell_buff
Xbytes of output from a program before writing it on a window
X(the default is 256).
X.TP
X.BI \-P poll_interval
XWhen output is pending in a window, wait
X.I poll_interval
Xmicro-seconds on every polling loop to give more
Xprocess time to the processes running in the windows.
XThe default is zero.
X.SS "Startup File Format"
XUpon invocation
X\*M
Xreads commands from the "startup file",
X.B $HOME/.mgrc
X(see 
X.B \-s
Xflag above)
Xto initialize the display.
XCommands are placed one per line with the command arguments separated
Xby spaces or tabs.
XThe following commands are supported:
X.LP
X.TP
X\fBinitcmd\fP \fIcommand\fP [ \fIargs...\fP ]
XThis command line is handed to the shell and executed
Xat the time the startup file is read.
X.TP
X\fBsuspendcmd\fP \fIcommand\fP [ \fIargs...\fP ]
XThis command line is handed to the shell and executed
Xeach time \*M suspends it self,
Xeither due to a main menu selection or the Left-z key.
X.TP
X\fBresumecmd\fP \fIcommand\fP [ \fIargs...\fP ]
XThis command line is handed to the shell and executed
Xeach time \*M resumes after a suspension.
X.TP
X\fBquitcmd\fP \fIcommand\fP [ \fIargs...\fP ]
XThis command line is handed to the shell and executed
Xjust before \*M quits,
Xeither due to a main menu selection or the Left-Q key.
X.TP
X\fBmap\fP \fIn0 n1 n2 n3 n4 n5 n6 n7\fP
XThis changes the meaning of the mouse buttons.
XEach
X.I n[0-7]
Xrepresents one of the 8 states of the three
X.I mouse buttons.
XThe default mapping is: 0 1 2 3 4 5 6 7.
XTo change the meaning of the 
X.I left
Xand
X.I right
Xbuttons, 0 2 4 6 1 3 5 7 would be used.
XIt is possible to map a button out of existence, which may have
Xgrave consequences.
X.TP
X\fBfont\fP \fIfont_number font_name\fP
XThe default font may be overridden by specifying the font
X.I font name
Xwhich is to be substituted for the font at position
X.IR font_number .
XFont numbers
Xare small integers, in the range of 0-99.
XThe
X.IR font_name s
Xare found in the font directory, by default
X.BR /usr/mgr/font .
XSee the
X.B \-f
Xflag above.
X.TP
X\fBwindow\fP \fIx y wide high\fP [ \fIfont_number\fP ]
XA window is created whose corner is at the coordinates
X.I (x, y)
Xand whose size is
X.I (wide, high).
XUnits are in pixels, with 
X.I x
Xand
X.I y
Xincreasing to the 
X.I right
Xand
X.I
Xdown
Xrespectively.
X.I Wide
Xand
X.I high
Xcan be set in terms of characters in the current font by appending
Xthe letter "c" to the value.
XIf
X.I x
Xand
X.I y
Xare
X.BR \-1 ,
Xthen they are replaced by values that causes new windows to
X"tile" across the screen.
XSetting
X.I wide
Xand
X.I high
Xto
X.B \-1
Xis identical to setting them to "80c" and "24c" respectively.
XThe scope of the
X.B window
Xcommand continues until either another 
X.B window
Xcommand or
X.B done
Xis reached.
XThe rest of the options,
X.B shell, start, init,
X.B flags,
Xand
X.B newwindow
Xapply only to the current
X.B window
Xcommand.
X.RS
X.TP
X\fBshell\fP \fIcommand\fP [ \fIargs...\fP ]
X.I Command
Xis the name of the command or shell to be started in the window.
XIf
X.I command 
Xis not specified, then the environment variable
X.B $SHELL,
Xor 
X.B /bin/csh
Xis used.
X.TP
X\fBstart\fP \fIcommand\fP
XThe
X.I command 
Xis sent to the 
X.I shell
Xupon startup, as if it had
Xbeen typed at the keyboard.
X.TP
X\fBinit\fP \fIinitial_string\fP
XThe 
X.I
Xinitial string
Xis sent to the 
X.I window
Xupon startup.
XThe string is terminated by white space, the remainder of the
Xline may be used as a comment.
XThe codes:
X.B \e\e, \eb, \ef \ee, \en, \er, \eMx
Xor
X.B \es
Xmay be used to represent
X.I \e, backspace formfeed, escape, newline, return, x|0200,
Xor
X.I space
Xrespectively.
X.TP
X\fBflags\fP \fIflag...\fP
XNormally a window self destructs when the original process running in it dies.
Xif
X.B nokill,
Xcurrently the only flag,
Xis specified, the window hangs around until specifically snuffed by
Xthe user.
X.TP
X.B newwindow
XThe current window specification is not to be used to initialize the display,
Xbut instead will be used when
X.B "Left n"
Xor
X.B "Right n"
Xto create a new window.
X.RE
X.TP
X.B done
X.B done
Xmust be the last line in the startup file if any
X.B window
Xcommands are specified, or the last
X.B window
Xcommand will not take affect.
X.SS "Using The Mouse"
XUser interaction with 
X\*M
Xis with the mouse.
XMoving the mouse causes a corresponding movement of the 
X.I mouse cursor,
Xusually an arrow pointing to the upper left.
XThe
X.I left
Xor
X.I command button
Xof mouse activates a
X.I menu
Xwhose options depend upon the current mouse position.
XAn option is chosen by moving the mouse vertically while the
X.I command
Xbutton is depressed, releasing the button when the appropriate
Xselection is highlighted.
X.LP
XWhen the mouse is over the background pattern, or at the extreme
Xleft edge of the screen, the
X.I command menu 
Xis activated by the 
Xmouse.
XThe
X.I command
Xmenu options are:
X.TP 12
X.B new window
XA new window is created by moving the the mouse cursor
X(now a box) to the upper left corner of the window, depressing
Xthe
X.I command button,
Xsweeping out the window, then releasing the
X.I command button.
XThe new window, if it is big enough, is started with a shell
Xrunning in it.
X.TP 12
X.B redraw
XThe background and windows are redrawn.
XThis is useful if a process unknown to
X\*M
Xscribbles on the display.
XIt is left to the processing running in a window to fix the contents
Xof its window.
X.TP 12
X.B quit
X\*M
Xis terminated, after the
X.I quit
Xis confirmed.
XAlternately,
X\*M
Xmay be suspended (ala
X.B ^Z 
Xin
X.B csh
X).
X.LP
XWhen the mouse is over the 
X.I active
Xwindow, the fat bordered window the keyboard is connected to,
Xthe 
X.I window menu
Xis activated by depressing the
X.I command button.
XThe
X.I window
Xmenu options are:
X.TP 12
X.B reshape
X.I Reshape
Xreshapes the 
X.I active
Xwindow, using a procedure similar to
X.I new window
Xabove.
X.TP 12
X.B move
XAn outline of the current window
Xis moved along with the mouse until the
X.I command button
Xis depressed and released.
XThe current window is then moved to the new location.
X.TP 12
X.B bury
XThe current window is made inactive.
XAnother window (if any) becomes the
X.I active
Xwindow.
X.TP 12
X.B cut
XThe mouse may be used to sweep out and save text 
Xfrom the current window into a global buffer.
XA small scissors appears as the mouse cursor.
XPosition the upper left corner of the scissors with the upper left
Xcorner of the first character to be saved, then push one of the
Xmouse buttons, moving the mouse to sweep out the desired text.
XReleasing the button causes the outlined text to be saved.
XUsing the 
X.I command button
Xwith 
X.I cut
Xcauses the current contents of the global buffer (if any) to be
Xreplaced by the indicated text.
XEither of the other two buttons causes the indicated text to be appended
Xto the global buffer.
X.IP
XThe
X.I cut
Xfacility currently works only for windows containing a single font, aligned
Xon the default character boundaries.  Applications which use only
Xthe terminal emulator sub-set of
X.I MGR
Xcapabilities, such as the
X.I shell,
X.I mail, 
Xand
X.I editors
Xautomatically meet this restriction.
XCuttability may be restored by issuing a 
X.I clear
X(i.e. form feed)
Xto the window.
XThe window flashes and beeps if the 
X.I cut
Xoperation could not be completed,
Xusually the result of corrupted data in the window.  In such cases,
Xno text is saved.
XSee 
X\*M - C Language Application Interface
Xfor a detailed description of the various 
X.I cut
Xoption settings.
X.TP 12
X.B paste
XThe contents of the global buffer (if any) are inserted into the input
Xstream of the current window.  The global buffer is filled using 
X.B cut
Xabove, or under program control.
X.TP 12
X.B destroy
XAll processes associated with the current window are sent
Xa
X.I  hangup
Xsignal, and the window is destroyed.
X.LP
XWhen the mouse is clicked on any window except the
X.I active
Xwindow, that window moves to the
X.I front
Xand becomes the
X.I active 
Xwindow.
X.SS "Using The Left and Right Keys"
XWhen
X\*M
Xis invoked from the console keyboard,
Xmany of the system menu functions have keyboard equivalents.
XSome of the more interesting ones are
Xactivated by holding down the
X.B Left
Xor
X.B Right
Xkeys, and then pressing:
X.TP 6
Xspace bar
Xto activate the previous window
X.TP 6
XBack Space
Xto activate the bottom window
X.TP 6
Xc
Xto initiate a 
X.I cut-text
Xoperation
X.TP 6
Xp
Xto initiate a 
X.I paste
Xoperation
X.TP 6
Xh
Xhide the top window on the bottom
X.TP 6
Xl
Xto clear the active window
X.TP 6
Xm
Xinitiate a
X.I cut-text
Xoperation which will automatically cause a
X.I paste
Xoperation when completed
X.TP 6
Xn
Xto start a new window, 80 x 24 characters (if it will fit),
Xplaced in the "tile" position of its window-set ID
X.TP 6
XN
Xstart a new window by sweeping with the mouse
X.TP 6
XQ
Xto exit
X\*M
Xquickly
X.TP 6
X1\-9
Xto activate the window with window-set ID 1 through 9
X.TP 6
X0
Xactivates the window with window-set ID 10,
Xa synonym for w10<Return>
X.TP 6
Xw\fInumber\fP<Return>
Xactivate the window with window-set ID
X.I number
X.TP 6
Xr
Xto redraw the windows
X.TP 6
XR
Xto redraw the windows
X.TP 6
X.TP 6
Xz
Xto suspend 
X\*M
X.LP
XThere are other characters that cause \*M to display debugging information
Xwhich may disrupt the screen; they are
Xi,
XI,
XM,
X+,
X-,
X#,
Xand
X?.
XUse "redraw", either from the command menu on the mouse or "right r"
Xto restore the screen display.
X.LP
XThe environment variable
X.B \s-2DEFAULT_FONT\s+2
Xmay be assigned the full path name of a
X\*M
Xfont,
Xwhich will then replace
X\*M's
Xbuilt in default font.
X.SH FILES
X.TP 20
X.B /dev/mouse
Xplace to obtain mouse coordinates.
X.TP 20
X.B /dev/bwtwo0
Xname of the display.
X.TP 20
X.B /usr/mgr/icon
Xplace to find 
X\*M
Xicons.
X.TP 20
X.B /usr/mgr/font
Xplace to find 
X\*M
Xfonts.
X.TP 20
X.B /usr/mgr/font/.mgrc
Xthe global default startup file;
Xdelivered with 15 fonts specified.
X.TP 20
X.B $HOME/.mgrc
Xplace to find startup commands.
X.TP 20
X.B /dev/bell
XFor ringing the bell.
X.TP 20
X.B /dev/[pt]ty[pq]?
XName of the pseudo-tty's.
X.SH SEE ALSO
X\*M - C Language Application Interface
X.br
Xbounce(1L)
Xbrowse(1L)
Xbury(1L)
Xclock(1L)
Xclock2(1L)
Xclose(1L)
Xdmgr(1L)
Xether(1L)
Xfont(1L)
Xiconmail(1L)
Xiconmsgs(1L)
Xloadfont(1L)
Xmaze(1L)
Xmenu(1L)
Xmgr(1L)
Xmgrmail(1L)
Xmgrmsgs(1L)
Xoclose(1L)
Xomgrmail(1L)
Xrotate(1L)
Xset_console(1L)
Xset_termcap(1L)
Xshape(1L)
Xshow(1L)
Xshowfont(1L)
Xsnap(1L)
Xstartup(1L)
Xstat(1L)
Xstringart(1L)
Xtjfilter(1L)
Xwindow_print(1L)
Xzoom(1L)
Xbitmap(5L)
Xfont(5L)
X.SH DIAGNOSTICS
X.TP
XCan't find a frame buffer
XNo display device available.  Make
Xsure 
X.I /dev/bwtwo0
Xexists in 
X.I /dev.
X.TP
XCan't find a mouse, or it is already in use
X\*M
Xmust have exclusive control of the mouse.
X.TP
XInternal \*M error 
Xeverything else.
X.SH BUGS
X.TP 3
X*
XA separate application program,
Xset_console(1L)
Xis required to prevent others from scribbling on 
X.B /dev/console
Xand messing up the display.
X.TP 3
X*
XAs 
X\*M
Xrequires exclusive control of the mouse, 
Xit may not be invoked from within itself.
X.TP 3
X*
XOnly fixed-width fonts are supported.
X.SH AUTHOR
XStephen A. Uhler
END_OF_FILE
# end of 'doc/mgr.1'
fi
if test -f 'lib/term.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/term.h'\"
else
echo shar: Extracting \"'lib/term.h'\" \(15350 characters\)
sed "s/^X//" >'lib/term.h' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: term.h,v 4.6 88/08/18 10:17:05 sau Exp $
X	$Source: /tmp/mgrsrc/lib/RCS/term.h,v $
X*/
Xstatic char	h_term_[] = "$Source: /tmp/mgrsrc/lib/RCS/term.h,v $$Revision: 4.6 $";
X
X/* macros for writing to mgr terminal emulator */
X
X#ifndef _TERM_INCL
X#define _TERM_INCL
X
X#include "window.h"
X
X#ifndef stderr
X#include <stdio.h>
X#endif
X 
X#ifndef ECHO
X#include <sgtty.h>
X#endif
X
X#define TTYMAX		10	/* stack size for ttyset() */
X
X#define M_FLUSH		0x1	/* autoflush output after each write */
X#define M_DEBUG		0x2	/* use stderr instead of /dev/tty mgr i/o */
X#define M_MODEOK	0x4	/* assume tty modes are always ok */
X
X#ifndef M_DEVICEIN
X#define M_DEVICEIN	"/dev/tty"
X#endif
X
X#ifndef M_DEVICEOUT
X#define M_DEVICEOUT	"/dev/tty"
X#endif
X
X
X#define m_flush()		fflush(m_termout)
X
X#define BTWN(a,x,b)	\
X	((x)<(a)?a:(x)>(b)?b:x)
X#define LIMIT(x)	BTWN(0,x,1152)
X
X#ifndef M_NOFLUSH
X#define _m_flsh		,(m_flags&M_FLUSH?m_flush():m_flags)
X#else
X#define _m_flsh
X#endif
X
X/* vi-like stuff */
X
X#define m_addline() \
X	(fprintf(m_termout,"%c%c",m_escchar,E_ADDLINE)_m_flsh)
X
X#define m_addlines(n) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,n,E_ADDLINE)_m_flsh)
X
X#define m_addchar() \
X	(fprintf(m_termout,"%c%c",m_escchar,E_ADDCHAR)_m_flsh)
X
X#define m_addchars(n) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,n,E_ADDCHAR)_m_flsh)
X
X#define m_deleteline() \
X	(fprintf(m_termout,"%c%c",m_escchar,E_DELETELINE)_m_flsh)
X
X#define m_deletelines(n) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,n,E_DELETELINE)_m_flsh)
X
X#define m_deletechar() \
X	(fprintf(m_termout,"%c%c",m_escchar,E_DELETECHAR)_m_flsh)
X
X#define m_deletechars(n) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,n,E_DELETECHAR)_m_flsh)
X
X#define m_standend() \
X	(fprintf(m_termout,"%c%c",m_escchar,E_STANDEND)_m_flsh)
X
X#define m_standout() \
X	(fprintf(m_termout,"%c%c",m_escchar,E_STANDOUT)_m_flsh)
X
X#define m_bell() \
X	(fprintf(m_termout,"\007")_m_flsh)
X
X#define m_setcursor(n) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,n,E_SETCURSOR)_m_flsh)
X
X/* lines */
X
X/*
X#define m_line(x0,y0,x1,y1) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d%c",m_escchar, \
X	LIMIT(x0),LIMIT(y0),LIMIT(x1),LIMIT(y1),E_LINE)_m_flsh)
X*/
X
X#define m_line(x0,y0,x1,y1) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d%c",m_escchar, \
X	x0,y0,x1,y1,E_LINE)_m_flsh)
X
X#define m_lineto(to,x0,y0,x1,y1) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d,%d%c",m_escchar, \
X	x0,y0,x1,y1,to,E_LINE)_m_flsh)
X
X#define m_draw(x,y) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar, \
X	LIMIT(x),LIMIT(y),E_LINE)_m_flsh)
X
X#define m_fastdraw(x,y,count,buff) \
X	(fprintf(m_termout,"%c%d,%d,%d%c",m_escchar, \
X	LIMIT(x),LIMIT(y),count,E_GRUNCH), \
X	fwrite(buff,1,count,m_termout)_m_flsh)
X
X#define m_rfastdraw(count,buff) \
X	(fprintf(m_termout,"%c%d%c",m_escchar, \
X	count,E_GRUNCH), \
X	fwrite(buff,1,count,m_termout)_m_flsh)
X
X#define m_aligntext() \
X	(fprintf(m_termout,"%c%c",m_escchar, \
X	E_LINE)_m_flsh)
X
X#define m_gotext() \
X	(fprintf(m_termout,"%c%c",m_escchar, \
X	E_GO)_m_flsh)
X
X#define m_go(x,y) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar, \
X	LIMIT(x),LIMIT(y),E_GO)_m_flsh)
X
X/* bitblits */
X
X#define m_clear() \
X	(fprintf(m_termout,"%c",C_FF)_m_flsh)
X
X#define m_func(func)\
X	(fprintf(m_termout,"%c%d%c",m_escchar,func,E_BITBLT)_m_flsh)
X
X#define m_bitwrite(x,y,w,h) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d%c",m_escchar,x,y,w,h,E_BITBLT)_m_flsh)
X
X#define m_bitwriteto(x,y,w,h,to) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d,%d%c", \
X	m_escchar,x,y,w,h,to,E_BITBLT)_m_flsh)
X
X#define m_bitcopy(xd,yd,w,h,xs,ys) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d,%d,%d%c", \
X	m_escchar,xd,yd,w,h,xs,ys,E_BITBLT)_m_flsh)
X
X#define m_bitcopyto(xd,yd,w,h,xs,ys,to,from) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d,%d,%d,%d,%d%c", \
X	m_escchar,xd,yd,w,h,xs,ys,to,from,E_BITBLT)_m_flsh)
X
X#define m_bitld(w,h,x,y,size) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d,%d%c",\
X	m_escchar,w,h,x,y,size,E_BITLOAD),m_flush())
X
X#define m_bitldto(w,h,x,y,to,size) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d,%d,%d%c",\
X	m_escchar,w,h,x,y,to,size,E_BITLOAD),m_flush())
X
X#define m_bitdestroy(n) \
X	(fprintf(m_termout,"%c%d%c",\
X	m_escchar,n,E_BITCRT),m_flush())
X
X#define m_bitcreate(n,w,h) \
X	(fprintf(m_termout,"%c%d,%d,%d%c",\
X	m_escchar,n,w,h,E_BITCRT),m_flush())
X
X#define m_bitget(from,size,offset) \
X	(fprintf(m_termout,"%c%d,%d,%d%c",\
X	m_escchar,from,size,offset,E_BITGET),m_flush())
X 
X#define m_othersave(id,sub,name) \
X	(fprintf(m_termout,"%c%d,%d,%d%c%s",\
X	m_escchar,id,sub,strlen(name),E_SMAP,name)_m_flsh)
X 
X#define m_windowsave(name) \
X	(fprintf(m_termout,"%c%d%c%s",\
X	m_escchar,strlen(name),E_SMAP,name)_m_flsh)
X 
X#define m_bitsave(from,name) \
X	(fprintf(m_termout,"%c%d,%d%c%s",\
X	m_escchar,from,strlen(name),E_SMAP,name)_m_flsh)
X 
X#define m_bitfromfile(to,name) \
X	(fprintf(m_termout,"%c%d,%d%c%s",\
X	m_escchar,to,strlen(name),E_GMAP,name)_m_flsh)
X 
X#define m_highlight(x,y,w,h) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d%c",\
X	m_escchar,x,y,w,h,E_BLEEP),m_flush())
X 
X#define m_stringto(to,x,y,text) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d%c%s",\
X	m_escchar,to,x,y,strlen(text),E_STRING,text)_m_flsh)
X
X/* other graphic functions */
X
X#define m_circle(x,y,r) \
X	(fprintf(m_termout,"%c%d,%d,%d%c",m_escchar, \
X	LIMIT(x),LIMIT(y),LIMIT(r),E_CIRCLE)_m_flsh)
X
X#define m_ellipse(x,y,r1,r2) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d%c",m_escchar, \
X	LIMIT(x),LIMIT(y),LIMIT(r1),LIMIT(r2),E_CIRCLE)_m_flsh)
X
X#define m_arc(x,y,x1,y1,x2,y2) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d,%d,%d%c",m_escchar, \
X	LIMIT(x),LIMIT(y),LIMIT(x1),LIMIT(y1),LIMIT(x2),LIMIT(y2), \
X	E_CIRCLE)_m_flsh)
X
X#define m_ellipseto(to,x,y,r1,r2) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d,%d%c",m_escchar, \
X	LIMIT(x),LIMIT(y),LIMIT(r1),LIMIT(r2),to,E_CIRCLE)_m_flsh)
X
X#define m_rcircle(r) \
X	(fprintf(m_termout,"%c%d%c",m_escchar, \
X	LIMIT(r),E_CIRCLE)_m_flsh)
X
X#define m_rellipse(r1,r2) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar, \
X	LIMIT(r1),LIMIT(r2),E_CIRCLE)_m_flsh)
X
X
X#define m_movemouse(x,y) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar,x,y,E_MOUSE)_m_flsh)
X
X#define m_movecursor(x,y) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar,x,y,E_MOVE)_m_flsh)
X
X#define m_move(col,row) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar,col,row,E_CUP)_m_flsh)
X
X#define m_moveprint(x,y,str) \
X	(fprintf(m_termout,"%c%d,%d%c%s",m_escchar,x,y,E_MOVE,str)_m_flsh)
X
X#define m_incr(x) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,x,E_MOVE)_m_flsh)
X
X#define m_cleareol() \
X	(fprintf(m_termout,"%c%c",m_escchar,E_CLEAREOL)_m_flsh)
X
X#define m_cleareos() \
X	(fprintf(m_termout,"%c%c",m_escchar,E_CLEAREOS)_m_flsh)
X
X/* window manipulation */
X
X#define m_movewindow(x,y) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar,x,y,E_SHAPE)_m_flsh)
X
X#define m_shapewindow(x,y,dx,dy) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d%c",m_escchar,x,y,dx,dy,E_SHAPE)_m_flsh)
X
X#define m_font(x) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,x,E_FONT)_m_flsh)
X
X#define m_loadfont(n,name) \
X	(fprintf(m_termout,"%c%d,%d%c%s", \
X	m_escchar,n,strlen(name),E_FONT,name)_m_flsh)
X
X#define m_size(cols,rows) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar,cols,rows,E_SIZE)_m_flsh)
X
X#define m_sizeall(x,y,cols,rows) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d%c", \
X         m_escchar,x,y,cols,rows,E_SIZE)_m_flsh)
X
X#define m_scrollregion(first,last) \
X	(fprintf(m_termout,"%c%d,%d%c", \
X	m_escchar,first,last,E_TEXTREGION)_m_flsh)
X
X#define m_textregion(x,y,wide,high) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d%c", \
X	m_escchar,x,y,wide,high,E_TEXTREGION)_m_flsh)
X
X#define m_textreset() \
X	(fprintf(m_termout,"%c%c",m_escchar,E_TEXTREGION)_m_flsh)
X
X/* window creation/ destruction */
X
X#define m_newwin(x,y,w,h) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d%c",m_escchar,x,y,w,h,E_MAKEWIN)_m_flsh)
X
X#define m_destroywin(n) \
X	(fprintf(m_termout,"%c%d,0%c",m_escchar,n,E_MAKEWIN)_m_flsh)
X
X#define m_selectwin(n) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,n,E_MAKEWIN)_m_flsh)
X
X/* events */
X
X#define m_setevent(event,x) \
X	(fprintf(m_termout,"%c%d,%d%c%s", \
X	m_escchar,_mapevent(event),strlen(x),E_EVENT,x)_m_flsh)
X
X#define m_clearevent(event) \
X	(fprintf(m_termout,"%c%d%c", \
X	m_escchar,_mapevent(event),E_EVENT)_m_flsh)
X
X/* message passing */
X
X#define m_sendme(str) \
X	(fprintf(m_termout,"%c%d%c%s", \
X	m_escchar,strlen(str),E_GIMME,str)_m_flsh)
X
X#define m_sendto(pid,str) \
X	(fprintf(m_termout,"%c%d,%d%c%s", \
X	m_escchar,pid,strlen(str),E_SEND,str)_m_flsh)
X
X#define m_broadcast(str) \
X	(fprintf(m_termout,"%c%d%c%s", \
X	m_escchar,strlen(str),E_SEND,str)_m_flsh)
X
X#define m_snarf(str) \
X	(fprintf(m_termout,"%c%d%c%s", \
X	m_escchar,strlen(str),E_SNARF,str)_m_flsh)
X
X#define m_put() \
X	(fprintf(m_termout,"%c%c", \
X	m_escchar,E_PUTSNARF)_m_flsh)
X
X/* environment stacking */
X
X#define m_push(mode) \
X	(m_envcount++, \
X         fprintf(m_termout,"%c%d%c",m_escchar,(mode)|P_CLEAR,E_PUSH) \
X         _m_flsh)
X
X#define m_pushsave(mode) \
X	(m_envcount++, \
X	fprintf(m_termout,"%c%d%c",m_escchar,(mode),E_PUSH)_m_flsh)
X
X#define m_pop() \
X	(m_envcount?m_envcount--:0, \
X         fprintf(m_termout,"%c%c",m_escchar,E_POP)_m_flsh)
X
X#define m_popall() \
X	while(m_envcount--) \
X         (fprintf(m_termout,"%c%c",m_escchar,E_POP)_m_flsh)
X
X/* tty mode settings */
X
X#define m_setraw() \
X	m_setflags(RAW)
X
X#define m_setnoraw() \
X	m_resetflags(RAW)
X#define m_unsetraw	m_setnoraw		/* obsolete */
X
X#define m_setecho()	 \
X        m_setflags(ECHO)
X
X#define m_setnoecho() \
X        m_resetflags(ECHO)
X
X/* other stuff */
X
X#define m_setmode(mode) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,mode,E_SETMODE)_m_flsh)
X
X#define m_dupkey(key) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar,M_DUPKEY,key,E_SETMODE)_m_flsh)
X
X#define m_clearmode(mode) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,mode,E_CLEARMODE)_m_flsh)
X
X#define m_getinfo(x) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,x,E_GETINFO),m_flush())
X
X#define m_whatsat(x,y) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar,x,y,E_GETINFO),m_flush())
X
X#define m_get()\
X	(m_flush(),fgets(m_linebuf,sizeof(m_linebuf),m_termin))
X
X#define m_getchar()\
X	(getc(m_termin))
X
X#define m_gets(buff)\
X	(m_flush(),fgets(buff,sizeof(buff),m_termin))
X
X#define m_putchar(c) \
X	(putc(c,m_termout)_m_flsh)
X
X#define m_printstr(str) \
X	(fprintf(m_termout,"%s",str)_m_flsh)
X
X#define m_setesc(x) \
X	(m_escchar = (x))
X
X#define m_resetesc() \
X	(m_escchar = ESC)
X
X#define m_sleep() \
X	(fprintf(m_termout,"%c%c",m_escchar,E_NULL)_m_flsh)
X
X/* menu stuff */
X
X#ifndef M_DELIM
X#define M_DELIM	'\005'		/* menu delimiter character */
X#endif
X
X#define m_selectmenu(n) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,n,E_MENU)_m_flsh)
X
X#define m_selectmenu2(n) \
X	(fprintf(m_termout,"%c-%d%c",m_escchar,n,E_MENU)_m_flsh)
X
X#define m_nomenu() \
X	(fprintf(m_termout,"%c%d%c",m_escchar,999,E_MENU)_m_flsh)
X
X#define m_nomenu2() \
X	(fprintf(m_termout,"%c-%d%c",m_escchar,999,E_MENU)_m_flsh)
X
X#define m_loadmenu(n,str) \
X	(fprintf(m_termout,"%c%d,%d%c%s",m_escchar,n,strlen(str),E_MENU,str)_m_flsh)
X
X#define m_clearmenu(n) \
X	(fprintf(m_termout,"%c%d,0%c",m_escchar,n,E_MENU)_m_flsh)
X
X#define m_linkmenu(parent,item,child,flags) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d%c", \
X	m_escchar,parent,item,child,flags,E_MENU)_m_flsh)
X
X#define m_unlinkmenu(parent,item) \
X	(fprintf(m_termout,"%c%d,%d,%d,%c", \
X	m_escchar,parent,item,-1,E_MENU)_m_flsh)
X
X#define m_pagemenu(parent,child) \
X	(fprintf(m_termout,"%c%d,%d,%d,%c", \
X	m_escchar,parent,-1,child,E_MENU)_m_flsh)
X
X#define m_unpagemenu(parent) \
X	(fprintf(m_termout,"%c%d,%d,%d,%c", \
X	m_escchar,parent,-1,-1,E_MENU)_m_flsh)
X
X/* temporary menu stuff */
X
X#define m_menuitem(menu,item) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar,menu,item,E_FOO)_m_flsh)
X
X#define m_menuerase(menu) \
X	(fprintf(m_termout,"%c%d%c",m_escchar,menu,E_FOO)_m_flsh)
X
X#define m_menushow(x,y,menu) \
X	(fprintf(m_termout,"%c%d,%d,%d%c",m_escchar,x,y,menu,E_FOO)_m_flsh)
X
X#define m_menubar(x,y,menu,item) \
X	(fprintf(m_termout,"%c%d,%d,%d,%d%c",m_escchar,x,y,menu,item,E_FOO)_m_flsh)
X
X/* temporary relative character motion */
X
X#define m_right(tenths) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar,tenths,10,E_RIGHT)_m_flsh)
X
X#define m_left(tenths) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar,tenths,-10,E_RIGHT)_m_flsh)
X
X#define m_up(tenths) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar,tenths,10,E_UP)_m_flsh)
X
X#define m_down(tenths) \
X	(fprintf(m_termout,"%c%d,%d%c",m_escchar,tenths,10,E_DOWN)_m_flsh)
X
X/* color stuff */
X
X#define m_fcolor(color) \
X        (fprintf(m_termout,"%c%d%c",m_escchar,color,E_FCOLOR)_m_flsh)
X#define m_bcolor(color) \
X        (fprintf(m_termout,"%c%d%c",m_escchar,color,E_BCOLOR)_m_flsh)
X#define m_linecolor(op,color) \
X        (fprintf(m_termout,"%c%d,%d%c",m_escchar,op,color,E_BITBLT)_m_flsh)
X
X#define _mapevent(z)				((z)==3||(z)==4?2-(z):z)
X
X/* events */
X
X#define BUTTON_1		1		/* end button depressed */
X#define BUTTON_2		2		/* middle button depressed */
X#define BUTTON_1U		3		/* end button released */
X#define BUTTON_2U		4		/* middle button released */
X#define RESHAPE			5		/* window was reshaped */
X#define RESHAPED		5		/* window was reshaped */
X#define REDRAW			6		/* screen was redrawn */
X#define REDRAWN			6		/* screen was redrawn */
X#define ACTIVATE		7		/* window was activated */
X#define ACTIVATED		7		/* window was activated */
X#define DEACTIVATE		8		/* window was deactivated */
X#define DEACTIVATED		8		/* window was deactivated */
X#define COVERED			9		/* window was covered */
X#define UNCOVERED		10		/* window was uncovered */
X#define MOVE			11		/* window was moved */
X#define MOVED			11		/* window was moved */
X#define DESTROY			12		/* window was destroyed */
X#define ACCEPT			13		/* accept messages */
X#define NOTIFY			14		/* set notification */
X#define SNARFED			16		/* text was just snarfed */
X#define PASTE			17		/* text was just pasted */
X
X/* stuff for setting terminal modes */
X
X#define _m_ttyset()		(m_flags&M_MODEOK?m_flags:m_ttyset())
X#define _m_ttyreset()		(m_flags&M_MODEOK?m_flags:m_ttyreset())
X
X/* global variables */
X
X#define MAXLINE		256	/* maximum line size from mgr */
X
Xextern FILE *m_termin;		/* output to window */
Xextern FILE *m_termout;		/* input from mgr */
Xextern int m_flags;		/* setup flags */
Xextern int m_envcount;		/* # of stacked environments */
Xextern int m_saveenvcount;	/* ??? */
Xextern char m_escchar;		/* \033, change only for debugging */
Xextern char m_menuchar;		/* menu field seperator char (\005) */
Xextern char m_linebuf[MAXLINE];
X
Xextern int get_info(), get_size(), parse(), get_font(), is_active(), menu_load();
Xextern char *m_lastline(), *get_termcap();
X
X/* structure definitions */
X
X#define MENU_SIZE(x)	(sizeof(x)/sizeof(struct menu_entry))
X
Xstruct menu_entry {
X   char *value;		/* this appears in the menu */
X   char *action;	/* this gets sent by mgr upon selection */
X   };
X
Xstruct window_data {
X   int x,y;		/* origin */
X   int w,h;		/* width, height */
X   char tty[3];		/* name of controlling tty */
X   char status;		/* activation status */
X   int num;		/* window number (>0 for client) */
X   int setid;		/* window set ID */
X   };
X
Xstruct icon {
X   char *name;		/* name of icon */
X   int type;		/* always 1 */
X   int w;		/* bitmap width */
X   int h;		/* bitmap height */
X   unsigned char *data;	/* data goes here */
X   };
X
X#endif _TERM_INCL
END_OF_FILE
# end of 'lib/term.h'
fi
if test -f 'src/blit/blit.C' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/blit/blit.C'\"
else
echo shar: Extracting \"'src/blit/blit.C'\" \(15535 characters\)
sed "s/^X//" >'src/blit/blit.C' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: blit.C,v 4.1 88/06/21 13:19:02 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/blit/RCS/blit.C,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/blit/RCS/blit.C,v $$Revision: 4.1 $";
X
X/* bitblit code for 68020's */
X
X#include <stdio.h>
X#include "bitmap.h"
X#include "asm.h"
X
X#define UP		0x10	/* direction bottom up */
X#define LEFT	0x20	/* direction right to left */
X#define SMALL	0x40	/* > 32 bits */
X
X#define NSRC	1		/* no source required */
X
X/* multiword source <op> destination, long aligned on destination */
X
X#define ROP_TOP(name) \
X		GOTO(LL4!name); \
X	LABEL(LL1!name)
X
X#define ROP_BOTTOM(how,name) \
X		how($d_skip,$d_base); \
X		how($s_skip,$s_offset); \
X	LABEL(LL4!name); \
X		LOOP($count,LL1!name)
X
X/* bits at left edge of long boundary */
X
X#define ROP_LEFT(how,op1,op2) \
X		MOVE($l_width,$i); \
X		MOVE($l_width,$T_DST); \
X		NEG($T_DST); \
X		BF_EXT($T_DST,$d_base,$T_DST,$i); \
X		BF_EXT($T_SRC,$s_base,$s_offset,$i); \
X		op1($T_DST,$T_SRC); \
X		op2($T_DST,$T_SRC); \
X		MOVE($l_width,$T_DST); \
X		NEG($T_DST); \
X		BF_INS($T_SRC,$d_base,$T_DST,$i)
X
X/* full words in middle Left to Right */
X
X#define ROP_LR(how,op1,op2,name) \
X		ADD($i,$s_offset); \
X		MOVE($words,$i); \
X		GOTO(LL3!name); \
X	LABEL(LL2!name); \
X		BF_EXT($T_SRC,$s_base,$s_offset,IMM(0)); \
X		MOVE(IND($d_base),$T_DST); \
X		op1($T_DST,$T_SRC); \
X		op2($T_DST,$T_SRC); \
X		MOVE($T_SRC,INCR($d_base)); \
X		ADD(IMM(32),$s_offset); \
X	LABEL(LL3!name); \
X		LOOP($i,LL2!name)
X
X/* full words in middle Right to Left */
X
X#define ROP_RL(how,op1,op2,name) \
X		MOVE($words,$i); \
X		GOTO(LL3!name); \
X	LABEL(LL2!name); \
X		SUB(IMM(32),$s_offset); \
X		BF_EXT($T_SRC,$s_base,$s_offset,IMM(0)); \
X		MOVE(DECR($d_base),$T_DST); \
X		op1($T_DST,$T_SRC); \
X		op2($T_DST,$T_SRC); \
X		MOVE($T_SRC,IND($d_base)); \
X	LABEL(LL3!name); \
X		LOOP($i,LL2!name); \
X		MOVE($l_width,$i); \
X		SUB($i,$s_offset);
X
X/* bits at right edge of long boundary */
X
X#define ROP_RIGHT(how,op1,op2) \
X		MOVE($r_width,$i); \
X		BF_EXT($T_SRC,$s_base,$s_offset,$i); \
X		BF_EXT($T_DST,$d_base,IMM(0),$i); \
X		op1($T_DST,$T_SRC); \
X		op2($T_DST,$T_SRC); \
X		BF_INS($T_SRC,$d_base,IMM(0),$i);
X
X/* multiword set/clear/invert - top half */
X
X#define ROP1(how,name) \
X            GOTO(L4!name); \
X         LABEL(L1!name);\
X        		MOVE($l_width,$i); \
X        		MOVE($l_width,$T_DST); \
X        		NEG($T_DST); \
X        		how($d_base,$T_DST,$i);\
X			   MOVE($words,$i);\
X			   GOTO(L3!name);\
X         LABEL(L2!name)
X
X/* multiword set/clear/invert - bottom half */
X
X#define ROP2(how,name) \
X         LABEL(L3!name); \
X			   LOOP($i,L2!name); \
X            MOVE($r_width,$i); \
X            how($d_base,IMM(0),$i);\
X			   ADD($d_skip,$d_base); \
X         LABEL(L4!name);\
X            LOOP($count,L1!name)
X
X/* (<=32 bits) no source, used for SET, CLEAR and INVERT */
X
X#define NO_SRC(func)			\
X		  GOTO(L2!func);						\
X		LABEL(L1!func);						\
X		  func($d_base,$words,$i);	\
X		  ADD($d_skip,$words);			\
X		LABEL(L2!func);			\
X		  LOOP($count,L1!func)
X
X/*
X *  (<=32 bits) DST doesn't count. Use for SRC, ~SRC.
X *  how is ADD for top down, SUB for bottom up
X */
X
X#define NO_DST(how,op)	\
X		  GOTO(L2!op!how); \
X		LABEL(L1!op!how); \
X		  BF_EXT($T_SRC,$s_base,$s_offset,$i); \
X		  op($T_DST,$T_SRC); \
X		  BF_INS($T_SRC,$d_base,$words,$i); \
X		  how($d_skip,$words); \
X		  how($s_skip,$s_offset); \
X		LABEL(L2!op!how); \
X		  LOOP($count,L1!op!how)
X
X/*
X * (<=32 bits) both SRC and DST count
X *  how is ADD for top down, SUB for bottom up
X */
X
X#define ROP(how,op1,op2)	\
X		  GOTO(L2!op1!op2!how); \
X		LABEL(L1!op1!op2!how); \
X		  BF_EXT($T_SRC,$s_base,$s_offset,$i); \
X		  BF_EXT($T_DST,$d_base,$words,$i); \
X		  op1($T_DST,$T_SRC); \
X		  op2($T_DST,$T_SRC); \
X		  BF_INS($T_SRC,$d_base,$words,$i); \
X		  how($d_skip,$words); \
X		  how($s_skip,$s_offset); \
X		LABEL(L2!op1!op2!how); \
X		  LOOP($count,L1!op1!op2!how)
X
X/* generic case >32 bits */
X
X#define ROP_CASE(op,name,op1,op2) \
X      case GET_OP(op):					/* name  left->right top->bottom */\
X         ROP_TOP(name!td_lr);\
X         ROP_LEFT(ADD,op1,op2);\
X         ROP_LR(ADD,op1,op2,name!td_lr);\
X         ROP_RIGHT(ADD,op1,op2);\
X         ROP_BOTTOM(ADD,name!td_lr);\
X         break;\
X      case GET_OP(op) | UP:			/* name left->right  bottom->up */\
X         ROP_TOP(name!bu_lr);\
X         ROP_LEFT(SUB,op1,op2);\
X         ROP_LR(SUB,op1,op2,name!bu_lr);\
X         ROP_RIGHT(SUB,op1,op2);\
X         ROP_BOTTOM(SUB,name!bu_lr);\
X         break;\
X      case GET_OP(op) | LEFT:			/* name right->left  top->bottom */\
X         ROP_TOP(name!td_rl);\
X         ROP_RIGHT(ADD,op1,op2);\
X         ROP_RL(ADD,op1,op2,name!td_rl);\
X         ROP_LEFT(ADD,op1,op2);\
X         ROP_BOTTOM(ADD,name!td_rl);\
X         break;\
X      case GET_OP(op) | UP | LEFT:	/* name right->left  bottom->up */\
X         ROP_TOP(name!bu_rl);\
X         ROP_RIGHT(SUB,op1,op2);\
X         ROP_RL(SUB,op1,op2,name!bu_rl);\
X         ROP_LEFT(SUB,op1,op2);\
X         ROP_BOTTOM(SUB,name!bu_rl);\
X         break
X
X			/* generic case <= 32 bits */
X
X#define SMALL_CASE(op,op1,op2) \
X		case GET_OP(op) | SMALL:\
X			i = wide; \
X			ROP(ADD,op1,op2);\
X			break;\
X		case GET_OP(op) | SMALL | UP:\
X			i = wide; \
X			ROP(SUB,op1,op2);\
X			break
X
X#define dprintf if(Bdebug)fprintf
Xint Bdebug = 0;
X
Xstatic char nsrc[16] = {		/* fold no source cases */
X	0,0,0,0,
X	0xf&~DST, 0xf&~DST, 0xf&~DST, 0xf&~DST,
X	0xf&DST, 0xf&DST, 0xf&DST, 0xf&DST, 
X	0xf, 0xf, 0xf, 0xf
X	};
X
Xstatic char zsrc[16] = {		/* no source req'd cases */
X	1,0,0,0,0,
X	1,0,0,0,0,
X	1,0,0,0,0,
X	1 };	
X
Xmem_rop(dst,x_dst,y_dst,wide,high,op,src,x_src,y_src)
XBITMAP *dst;				/* bitmaps */
XBITMAP *src;				/* bitmaps */
Xint x_dst,y_dst;			/* destination coords */
Xint x_src,y_src;			/* source coords */
Xint wide,high;				/* bitmap size */
Xint op;						/* bitmap function */
X   {
X	/* address registers */
X
X	register int *d_base;			/* destination bitmap base addresses */
X	register int *s_base;			/* source bitmap base addresses */
X
X	/* data registers */
X
X	register int s_offset;			/* source bit offset */
X	register int d_skip;				/* bytes to next line in dst */
X	register int s_skip;				/* bits to next line in src */
X   register int i = 0;				/* temporary data register */
X											/* width in bits (<= 32 bits) */
X	register int count=high;		/* # of rows */
X   register int words;				/* words across in inner loop (>32 bits) */
X											/* dest bit offset (<= 32 bits) */
X
X	/* temporary address reg. storage for 'i' above (>32 bits only) */
X
X   register int *l_width;			/* bits on left to next long boundary */
X   register int *r_width;			/* bits from last long boundary on right */
X
X	/* clipping and argument checking */
X
X	if (!src) {
X      if (Bdebug && op&0xf != 0xf&nsrc[op&0xf])
X		   dprintf(stderr,"no src, setting op %d -> %d\n",op&0xf,nsrc[op&0xf]);
X      op = 0xf&nsrc[op&0xf];						/* a NULL src sources 1's */
X		}
X
X	else if (zsrc[op&0xf])					 {
X      if (Bdebug && src)
X		   dprintf(stderr,"op=%d, setting src->NULL\n",op&0xf);
X		src == BIT_NULL;							/* don't check no src cases */
X		}
X	
X	if (wide<0) {
X		dprintf(stderr,"Clip: w<0 (%d)\n",wide);
X		x_dst += wide;
X		wide = - wide;
X		}
X
X	if (count<0) {
X		y_dst += count;
X		count = - count;
X		dprintf(stderr,"Clip: h<0 (%d)\n",count);
X		}
X
X   if (x_dst < 0) {
X		dprintf(stderr,"Clip: x_dst<0 (%d)\n",x_dst);
X		if (src)
X			x_src -= x_dst;
X		wide += x_dst;
X		x_dst = 0;
X		}
X
X   if (y_dst < 0) {
X		dprintf(stderr,"Clip: y_dst<0 (%d)\n",y_dst);
X		if (src)
X			y_src -= y_dst;
X		count += y_dst;
X		y_dst = 0;
X		}
X
X	if (src) {
X		if (x_src < 0) {
X			dprintf(stderr,"Clip: x_src<0 (%d)\n",x_src);
X			x_dst -= x_src;
X			wide += x_src;
X			x_src = 0;
X			}
X
X		if (y_src < 0) {
X			dprintf(stderr,"Clip: y_src<0 (%d)\n",y_src);
X			y_dst-=y_src;
X			count+=y_src;
X			y_src=0;
X			}
X			
X		if ((i = x_src+wide - src->wide) > 0) {
X			dprintf(stderr,"Clip: wide too big for src (%d->%d)\n",wide,wide-i);
X			wide -= i;
X			}
X
X		if ((i = y_src+count - src->high) > 0) {
X			dprintf(stderr,"Clip: high too big for src (%d->%d)\n",count,count-i);
X			count -= i;
X			}
X
X		x_src += src->x0;
X		y_src += src->y0;
X		}
X
X	if ((i = x_dst + wide - dst->wide) > 0) {
X		dprintf(stderr,"Clip: wide too big for dst (%d->%d)\n",wide,wide-i);
X		wide -= i;
X		}
X	if ((i = y_dst + count - dst->high) > 0) {
X		dprintf(stderr,"Clip: high too big for dst (%d->%d)\n",count,count-i);
X		count -= i;
X		}
X
X	if (wide<1 || count < 1) {
X		dprintf(stderr,"Clip: high or wide < 1 (%d,%d)\n",wide,count);
X		return(-1);
X		}
X	x_dst += dst->x0;
X	y_dst += dst->y0;
X
X
X	/* end of clipping code */
X
X   /* set up common initial conditions */
X
X	if (wide <= 32) {			/* small cases */
X		i = SMALL;
X		}
X	else {
X		i = 0;
X		l_width = (int *) (32 - (x_dst&31));	/* bits on left edge 1-32 */
X		r_width = (int *) ((x_dst + wide) & 31);	/* bits on right edge 0-31 */
X		words =   (wide - (int) l_width)>>5;	/* longs in middle */
X		if (!r_width) {								/* change 0-31 to 1-32 */
X			r_width = (int *) 32;
X			words--;
X			}
X		}
X
X   /* find bitblt direction */
X
X   if (src && src->data == dst->data)  {
X      if (y_dst>y_src)
X         i |= UP;
X      if (x_dst>x_src && wide > 32)
X		   i |= LEFT;
X		}
X       
X	/* set initial conditions */
X
X   switch(i) {
X	case 0:				/* top->bottom		left->right */
X      d_base = dst->data +((BIT_LINE(dst)*y_dst+x_dst+32)>>5);
X   	d_skip = (BIT_LINE(dst)>>3) - (words<<2);		/* bytes to next row */
X		if (src) {
X			s_base = src->data;
X			s_skip = BIT_LINE(src) - (wide - (int)r_width);		/* in bits */
X			s_offset = BIT_LINE(src) * y_src + x_src;				/* in bits */
X			}
X		/* dprintf(stderr,"RIGHT DOWN\n"); */
X      break;
X
X	case UP:				/* bottom->top		left->right */
X      d_base = dst->data +((BIT_LINE(dst)*(y_dst+count-1)+x_dst+32)>>5);
X   	d_skip = (BIT_LINE(dst)>>3) + (words<<2);		/* bytes to next row */
X		s_base = src->data;
X		s_skip = BIT_LINE(src) + (wide - (int)r_width);		/* in bits */
X		s_offset = BIT_LINE(src) * (y_src+count-1) + x_src;
X		/* dprintf(stderr,"RIGHT UP\n"); */
X      break;
X
X	case LEFT:			/* top->bottom		right->left */
X      d_base = dst->data +((BIT_LINE(dst)*y_dst+x_dst+wide-1)>>5);
X   	d_skip = (BIT_LINE(dst)>>3) + (words<<2);		/* bytes to next row */
X		s_base = src->data;
X		s_skip = BIT_LINE(src) + (words<<5) + (int) l_width;
X		s_offset = BIT_LINE(src)*y_src + x_src+wide-(int)r_width;
X		/* dprintf(stderr,"LEFT DOWN\n"); */
X      break;
X
X	case UP|LEFT:		/* bottom->top		right->left */
X      d_base = dst->data +((BIT_LINE(dst)*(y_dst+count-1)+x_dst+wide-1)>>5);
X   	d_skip = (BIT_LINE(dst)>>3) - (words<<2);		/* bytes to next row */
X		s_base = src->data;
X		s_skip = BIT_LINE(src) - (words<<5) - (int) l_width;
X		s_offset = BIT_LINE(src)*(y_src+count-1) + x_src+wide-(int)r_width;
X		/* dprintf(stderr,"LEFT UP\n"); */
X      break;
X
X	case SMALL:			/* <= 32 bits */
X		d_base =  dst->data;	/* destination base address */
X		d_skip = BIT_LINE(dst->primary);	/* bits/row */
X		words = d_skip*y_dst+x_dst;
X		if (src) {
X			s_base = src->data; /* source base address */
X			s_skip = BIT_LINE(src->primary);	/* bits/row */
X			s_offset = s_skip*y_src+x_src;
X			}
X		/* dprintf(stderr,"SMALL DOWN\n"); */
X      break;
X
X	case SMALL | UP:
X		d_base =  dst->data;	/* destination base address */
X		d_skip = BIT_WIDE(dst->primary);	/* bits/row */
X		words = d_skip*(y_dst+count-1)+x_dst;
X		s_base = (int *) src->data; /* source base address */
X		s_skip = BIT_WIDE(src->primary);	/* bits/row */
X		s_offset = s_skip*(y_src+count-1)+x_src;
X		/* dprintf(stderr,"SMALL UP\n"); */
X      break;
X
X	default:
X		dprintf(stderr,"Invalid direction: 0x%x\n",i);
X		break;
X		}
X
X/*
X   dprintf(stderr,"op:%d d_base:0x%x\td_skip:%d\	(%d %d*32 %d)\n",
X						op&0xf,d_base,d_skip,(int)l_width,words,(int)r_width);					
X   if (src)
X		dprintf(stderr,"\ts_base:0x%x\ts_skip:%d\ts_offset:%d\n",
X						s_base,s_skip,s_offset);					
X
X	dprintf(stderr,"go %x\n",i);
X*/
X
X	/* @+		DON't DISTURB THIS COMMENT */
X
X	switch(op&0xf | i) {
X
X		/* no source involvement <= 32 bits */
X
X		case GET_OP(BIT_SET) | SMALL:
X		case GET_OP(BIT_SET) | UP | SMALL:
X			i = wide;
X			NO_SRC(BF_SET);
X			break;	
X		case GET_OP(BIT_CLR) | SMALL:
X		case GET_OP(BIT_CLR) | UP | SMALL:
X			i = wide;
X			NO_SRC(BF_CLR);
X			break;	
X		case GET_OP(BIT_NOT(BIT_DST)) | SMALL:
X		case GET_OP(BIT_NOT(BIT_DST)) | UP | SMALL:
X			i = wide;
X			NO_SRC(BF_INV);
X			break;	
X
X		/* no dest involement */
X
X		case GET_OP(BIT_SRC) | SMALL:
X			i = wide;
X			NO_DST(ADD,NOP);
X			break;
X		case GET_OP(~BIT_SRC) | SMALL:
X			i = wide;
X			NO_DST(ADD,NOT_SRC);
X			break;
X
X		case GET_OP(BIT_SRC) | UP | SMALL:
X			i = wide;
X			NO_DST(SUB,NOP);
X			break;
X		case GET_OP(~BIT_SRC) | UP | SMALL:
X			i = wide;
X			NO_DST(SUB,NOT_SRC);
X			break;
X
X		/* source and dest  and cases */
X
X		SMALL_CASE(BIT_SRC&BIT_DST,AND,NOP);
X		SMALL_CASE(~(BIT_SRC&BIT_DST),AND,NOT_SRC);
X		SMALL_CASE(~BIT_SRC&BIT_DST,NOT_SRC,AND);
X		SMALL_CASE(BIT_SRC&~BIT_DST,NOT_DST,AND);
X
X		/* source and dest  or cases */
X
X		SMALL_CASE(BIT_SRC|BIT_DST,OR,NOP);
X		SMALL_CASE(~(BIT_SRC|BIT_DST),OR,NOT_SRC);
X		SMALL_CASE(~BIT_SRC|BIT_DST,NOT_SRC,OR);
X		SMALL_CASE(BIT_SRC|~BIT_DST,NOT_DST,OR);
X
X		/* source and dest  xor cases */
X
X		SMALL_CASE(BIT_SRC^BIT_DST,XOR,NOP);
X		SMALL_CASE(~(BIT_SRC^BIT_DST),XOR,NOT_SRC);
X
X
X		/****************************************************************
X		 * > 32 bits
X		 */
X
X		/* no source involvement */
X
X		case GET_OP(BIT_SET):
X		case GET_OP(BIT_SET) | UP:
X		case GET_OP(BIT_SET) | LEFT:
X		case GET_OP(BIT_SET) | UP | LEFT:
X			MOVEQ(0,$T_SRC);
X         NOT($T_SRC);
X	      ROP1(BF_SET,set);
X         MOVE($T_SRC,INCR($d_base));
X		   ROP2(BF_SET,set);
X			break;	
X
X		case GET_OP(BIT_CLR):
X		case GET_OP(BIT_CLR) | UP:
X		case GET_OP(BIT_CLR) | LEFT:
X		case GET_OP(BIT_CLR) | UP | LEFT:
X			MOVEQ(0,$T_SRC);
X	      ROP1(BF_CLR,clear);
X         MOVE($T_SRC,INCR($d_base));
X	      ROP2(BF_CLR,clear);
X			break;	
X
X		case GET_OP(~BIT_DST):
X		case GET_OP(~BIT_DST) | UP:
X		case GET_OP(~BIT_DST) | LEFT:
X		case GET_OP(~BIT_DST) | UP | LEFT:
X	      ROP1(BF_INV,invert);
X		   MOVE(IND($d_base),$T_SRC);
X	      NOT($T_SRC);
X         MOVE($T_SRC,INCR($d_base));
X	      ROP2(BF_INV,invert);
X			break;	
X
X		/* source involvement, no DST  (this could be better) */
X      /* The optimizer doesn't toss the un-needed loads of the destination */
X
X		ROP_CASE(BIT_SRC,src,NOP,NOP);
X		ROP_CASE(~BIT_SRC,not_src,NOP,NOT_SRC);
X
X		/* source involvement  - and operations */
X
X		ROP_CASE(BIT_SRC&BIT_DST,and,AND,NOP);
X		ROP_CASE(~(BIT_SRC&BIT_DST),not_and,AND,NOT_SRC);
X		ROP_CASE(~BIT_SRC&BIT_DST,mask,NOT_SRC,AND);
X		ROP_CASE(BIT_SRC&~BIT_DST,not_mask,NOT_DST,AND);
X
X		/* source involvement  - or operations */
X
X		ROP_CASE(BIT_SRC|BIT_DST,or,OR,NOP);
X		ROP_CASE(~(BIT_SRC|BIT_DST),not_or,OR,NOT_SRC);
X		ROP_CASE(~BIT_SRC|BIT_DST,project,NOT_SRC,OR);
X		ROP_CASE(BIT_SRC|~BIT_DST,not_project,NOT_DST,OR);
X
X		/* source involvement  - xor operations */
X
X		ROP_CASE(BIT_SRC^BIT_DST,xor,XOR,NOP);
X		ROP_CASE(~(BIT_SRC^BIT_DST),not_xor,XOR,NOT_SRC);
X
X		/* no-op cases */
X
X		case GET_OP(DST) :	
X		case GET_OP(DST) | LEFT:
X		case GET_OP(DST) | SMALL:
X		case GET_OP(DST) | UP | SMALL:
X			break;
X
X      default:									/* not implemented */
X         fprintf(stderr,"operation 0x%x not implemented\n",op);
X         break;
X		}
X	return(0);
X  	}
END_OF_FILE
# end of 'src/blit/blit.C'
fi
echo shar: End of archive 38 \(of 61\).
cp /dev/null ark38isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
