Subject:  v17i021:  MGR, Bellcore window manager, Part21/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 21
Archive-name: mgr/part21




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 20 (of 61)."
# Contents:  demo/misc/Makefile demo/misc/clock2.c src/blit/bitmap.c
#   src/blit/line.C src/blit/sym.c src/destroy.c src/font_subs.c
#   src/oblit/bitmap.c src/print.c src/win_make.c
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:23 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'demo/misc/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/misc/Makefile'\"
else
echo shar: Extracting \"'demo/misc/Makefile'\" \(4414 characters\)
sed "s/^X//" >'demo/misc/Makefile' <<'END_OF_FILE'
X#                        Copyright (c) 1987 Bellcore
X#                            All Rights Reserved
X#       Permission is granted to copy or use this program, EXCEPT that it
X#       may not be sold for profit, the copyright notice must be reproduced
X#       on copies, and credit should be given to Bellcore where it is due.
X#       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X
X#	$Header: Makefile,v 4.5 88/08/22 10:30:44 sau Exp $
X#	$Source: /tmp/mgrsrc/demo/misc/RCS/Makefile,v $
X
X# makefile for demos 
X
XLIB= ../../lib/libmgr.a
XBIT= ../../lib/blitlib.a
XINCL= -I../../lib
XCPIO=demo.cpio
XTAR = demo.tar
XCFLAGS=-O $(INCL)
XLDFLAGS=$(LIB)
XSTART=.
XCPIO=misc.cpio
XINSROOT=/usr/mgr
XINSDIR=$(INSROOT)/bin
X
XCFILES= art_data.c bounce.c clock.c clock2.c close.c \
X	dmgr.c ether.c getpty.c grav.c grid.c hilbert.c hpmgr.c maze.c \
X	mgrmail.c mgrmode.c mgrmsgs.c oclose.c omgrmail.c overlayd.c \
X	set_console.c set_emacs.c set_termcap.c show.c startup.c \
X	stat.c stringart.c  lock.c
X
XOFILES= art_data.o bounce.o clock.o clock2.o close.o \
X	dmgr.o ether.o getpty.o grav.o grid.o hilbert.o hpmgr.o maze.o \
X	mgrmail.o mgrmode.o mgrmsgs.o oclose.o omgrmail.o overlayd.o \
X	set_console.o set_emacs.o set_termcap.o show.o startup.o \
X	stat.o stringart.o lock.o
X
XSMALL=	bounce clock clock2 close dmgr ether grav grid hilbert \
X	hpmgr maze mgrmail mgrmode mgrmsgs oclose omgrmail \
X	set_emacs set_termcap show startup stat stringart 
X
XALL = $(SMALL) overlayd set_console lock
X
XOTHER = Makefile
X
Xall:		$(ALL)
X
Xsmall:		$(SMALL)
X
Xfast:
X		cc -c $(CFLAGS) $(CFILES)
X		make all
X
Xbanner:		banner.o $(LIB)
X		cc $(CFLAGS) -o banner banner.o $(LDFLAGS)
X
Xclock:		clock.o $(LIB)
X		cc $(CFLAGS) -o clock clock.o $(LDFLAGS)
X
Xclock2:		clock2.o $(LIB)
X		cc $(CFLAGS) -o clock2 clock2.o $(LDFLAGS)
X
Xbounce:		bounce.o $(LIB)
X		cc $(CFLAGS) -o bounce bounce.o $(LDFLAGS)
X
Xdmgr:		dmgr.o $(LIB)
X		cc $(CFLAGS) -o dmgr dmgr.o $(LDFLAGS)
X
Xgrav:		grav.o $(LIB)
X		cc $(CFLAGS) -o grav grav.o $(LDFLAGS)
X
Xhpmgr:		hpmgr.o getpty.o $(LIB)
X		cc $(CFLAGS) -o hpmgr hpmgr.o getpty.o $(LDFLAGS)
X
Xmgrmsgs:	mgrmsgs.o $(LIB)
X		cc $(CFLAGS) -o mgrmsgs mgrmsgs.o $(LDFLAGS)
X
Xomgrmail:	omgrmail.o $(LIB)
X		cc $(CFLAGS) -o omgrmail omgrmail.o $(LDFLAGS)
X
Xmgrmail:	mgrmail.o $(LIB)
X		cc $(CFLAGS) -o mgrmail mgrmail.o $(LDFLAGS)
X
Xchart:		chart.o $(LIB)
X		cc $(CFLAGS) -o chart chart.o $(LDFLAGS)
X
Xclose:		close.o $(LIB)
X		cc $(CFLAGS) -o close close.o $(LDFLAGS)
X
Xoclose:		oclose.o $(LIB)
X		cc $(CFLAGS) -o oclose oclose.o $(LDFLAGS)
X
Xclose3:		close3.o $(LIB)
X		cc $(CFLAGS) -o close3 close3.o $(LDFLAGS)
X
Xstringart:	stringart.o art_data.o $(LIB)
X		cc $(CFLAGS) -o stringart stringart.o art_data.o $(LDFLAGS)
X
Xstat:		stat.o $(LIB)
X		cc $(CFLAGS) -o stat stat.o $(LDFLAGS)
X
Xether:		ether.o $(LIB)
X		cc $(CFLAGS) -o ether ether.o $(LDFLAGS)
X
Xset_console:	set_console.o $(LIB)
X		cc $(CFLAGS) -o set_console set_console.o $(LDFLAGS)
X
Xset_emacs:	set_emacs.o $(LIB)
X		cc $(CFLAGS) -o set_emacs set_emacs.o $(LDFLAGS)
X
Xset_termcap:	set_termcap.o $(LIB)
X		cc $(CFLAGS) -o set_termcap set_termcap.o $(LDFLAGS)
X
Xmgrmode:	mgrmode.o $(LIB)
X		cc $(CFLAGS) -o mgrmode mgrmode.o $(LDFLAGS)
X
Xshow:		show.o $(LIB)
X		cc $(CFLAGS) -o show show.o $(LDFLAGS)
X
Xstartup:	startup.o $(LIB)
X		cc $(CFLAGS) -o startup startup.o $(LDFLAGS)
X
Xhilbert:	hilbert.o $(LIB)
X		cc $(CFLAGS) -o hilbert hilbert.o $(LDFLAGS)
X
Xoverlayd:	overlayd.o $(LIB)
X		cc $(CFLAGS) -o overlayd overlayd.o $(LDFLAGS)
X
Xgrid:		grid.o $(LIB)
X		cc $(CFLAGS) -o grid grid.o $(LDFLAGS)
X
Xview:		view.o $(LIB)
X		cc $(CFLAGS) -o view view.o $(LDFLAGS)
X
Xfile:		file.o $(LIB)
X		cc $(CFLAGS) -o file file.o $(LDFLAGS)
X
Xprint:		print.o $(LIB)
X		cc $(CFLAGS) -o print print.o $(LDFLAGS)
X
Xwprint:		wprint.o $(LIB)
X		cc $(CFLAGS) -o wprint wprint.o $(LDFLAGS)
X
Xlock:		lock.o $(LIB)
X		cc $(CFLAGS) -o lock lock.o $(BIT) $(OTHERLIB)
X
Xmaze:		maze.o $(LIB)
X		cc $(CFLAGS) -o maze maze.o $(LDFLAGS)
X
X$(OFILES):	../../lib/term.h $(LIB)
X
Xinstall:	all $(INSDIR)
X		cd $(INSDIR);  rm -f $(ALL)
X		cp $(ALL) $(INSDIR)
X
Xsmallinstall:	small $(INSDIR)
X		cd $(INSDIR);  rm -f $(SMALL)
X		cp $(SMALL) $(INSDIR)
X		-/etc/chown root $(INSDIR)/maze  &&  chmod u+s $(INSDIR)/maze
X
X$(INSDIR):
X	mkdir $@
X
Xtar:		   
X		tar cf $(TAR) `ls $(CFILES) $(SH) $(OTHER)`
X
Xclean:		
X		rm -f *.o
X
Xclobber:		
X		rm -f $(ALL)
X
Xlist:
X	@for i in ${CFILES} ${HFILES} ${OTHER}; do \
X		echo "${START}/$$i"; \
X	done	
X
Xcpio:
X	make -s list | cpio -ocv > ${CPIO}
END_OF_FILE
# end of 'demo/misc/Makefile'
fi
if test -f 'demo/misc/clock2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/misc/clock2.c'\"
else
echo shar: Extracting \"'demo/misc/clock2.c'\" \(5054 characters\)
sed "s/^X//" >'demo/misc/clock2.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: clock2.c,v 4.2 88/06/22 14:37:27 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/misc/RCS/clock2.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/misc/RCS/clock2.c,v $$Revision: 4.2 $";
X
X/* get today's date  (analog clock version) */
X
X#include <errno.h>
X#include <time.h>
X#include <stdio.h>
X#include "term.h"
X#include "restart.h"
X
X#define OFFSET		(500<<10)		/* shift points to 1st quad */
X
X/* sin, cos tables: 0-360 deg. in 6 deg. increments (scaled to +/- 1024) */
X
Xint sin[] = {
X	 0, 107, 212, 316, 416, 512,
X	 601, 685, 760, 828, 886, 935,
X	 973, 1001, 1018, 1023, 1018, 1001,
X	 973, 935, 886, 828, 760, 685,
X	 601, 511, 416, 316, 212, 107,
X	 0, -107, -212, -316, -416, -512,
X	 -601, -685, -760, -828, -886, -935,
X	 -973, -1001, -1018, -1023, -1018, -1001,
X	 -973, -935, -886, -828, -760, -685,
X	 -601, -511, -416, -316, -212, -107,
X	 0 };
X
X
Xint cos[] = {
X	 1023, 1018, 1001, 973, 935, 886,
X	 828, 760, 685, 601, 511, 416,
X	 316, 212, 107, 0, -107, -212,
X	 -316, -416, -512, -601, -685, -760,
X	 -828, -886, -935, -973, -1001, -1018,
X	 -1023, -1018, -1001, -973, -935, -886,
X	 -828, -760, -685, -601, -511, -416,
X	 -316, -212, -107, 0, 107, 212,
X	 316, 416, 512, 601, 685, 760,
X	 828, 886, 935, 973, 1001, 1018,
X	 1023 };
X
Xtypedef struct coord {
X	int x,y;
X	} coord;
X
X/* coordinates of the hands at 12:00 */
X
Xcoord second[] = { 1,-30,  0,485 };
Xcoord minute[] = { 10,-10,  0,400,  -10,-10,  10,-10 };
Xcoord hour[] = { 35,-10,  0,270,  -35,-10,  35,-10 };
X
Xcoord big_tic[] = { -11,485,  0,450,  11,485 };
Xcoord tic[] = { 0,485,  0,460 };
X
Xint h, old_h, m, old_m, s, old_s;
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   register int i;
X   int cal=0;
X   int dotime(), clean();
X   char line[80];
X
X   ckmgrterm( *argv );
X
X   if (argc>1 && strcmp(argv[1],"-c")==0)
X      cal++;
X
X   /* setup mgr environment */
X
X   m_setup(0);
X   m_push(P_FLAGS|P_EVENT);
X   m_ttyset();
X
X   m_setevent(REDRAW,"R\r");
X   m_setevent(RESHAPE,"R\r");
X   if (cal)
X      m_setevent(ACTIVATE,"A\r");
X
X   signal(SIGALRM,dotime);
X   signal(SIGTERM,clean);
X   signal(SIGINT,clean);
X   signal(SIGHUP,clean);
X
X   while(1) {
X      m_func(B_SET);
X      m_clear();
X      m_ellipse(500,500,490,490);
X      for(i=0;i<60;i+=5) 		/* the tic marks */
X         if (i%15==0)
X            draw(big_tic,2,i);
X         else
X            draw(tic,1,i);
X   
X      m_movecursor(500,500);
X      get_time(&h, &m, &s);
X
X      draw(hour,3,h);
X      draw(minute,3,m);
X
X      m_func(B_INVERT);
X      draw(second,1,s);
X      m_flush();
X      dotime();
X
X      /* wait for an event */
X
X      while(1) {
X	 extern int   errno;
X
X         errno = 0;
X	 *line = '\0';
X         if (m_gets(line) == NULL  &&  errno  &&  errno != EINTR)
X            clean(0);
X         alarm(0);
X         if (*line=='R')
X            break;
X         else if (cal && *line == 'A') {
X            long time(), tmp = time(0);
X            char *ctime();
X
X            m_push(P_ALL);
X            m_font(11);
X            m_size(27,3);
X            m_clear();
X            m_printstr("\n "); 
X            m_printstr(ctime(&tmp));
X            m_flush();
X            sleep(3);
X            m_pop();
X            m_clearmode(M_ACTIVATE);
X            m_flush();
X            }
X         dotime();
X         }
X      }
X   }
X
X/* update the time */
X
Xint
Xdotime()
X   {
X   old_h=h, old_m=m, old_s=s;
X   get_time(&h, &m, &s);
X
X   draw(second,1,old_s);
X   if (old_m != m) {
X      m_func(B_CLEAR);
X      draw(minute,3,old_m);
X      draw(hour,3,old_h);
X 
X      m_func(B_SET);
X      draw(hour,3,h);
X      draw(minute,3,m);
X      m_func(B_INVERT);
X      }
X
X   draw(second,1,s);
X   m_flush();
X   signal(SIGALRM,dotime);
X   alarm(1);
X   }
X
X/* rotate and draw hands */
X   
X#define X(i)	(what[i].x)
X#define Y(i)	(what[i].y)
X
Xdraw(what, n, theta)
Xcoord what[];			/* array of points */
Xint n;				/* number of points */
Xint theta;			/* angle (in 160th of a circle) */
X   {
X   register int i;
X
X   for(i=0;i<n;i++) {
X      m_line((X(i)*cos[theta]+Y(i)*sin[theta] + OFFSET)>>10,
X           (X(i)*sin[theta]-Y(i)*cos[theta] + OFFSET)>>10,
X           (X(i+1)*cos[theta]+Y(i+1)*sin[theta] + OFFSET)>>10,
X           (X(i+1)*sin[theta]-Y(i+1)*cos[theta] + OFFSET)>>10);
X           }
X   }
X
X/* convert time to angles */
X
Xget_time(h,m,s)
Xint *h, *m, *s;		/* hours, minutes, seconds */
X   {
X   struct tm *tme, *localtime();
X   long tmp,time();
X    
X   tmp = time(0);
X   tme = localtime(&tmp);
X
X   *m = tme->tm_min;
X   *s = tme->tm_sec;
X   if (tme->tm_hour > 11)
X      tme->tm_hour -= 12;
X   *h = tme->tm_hour*5 + (2+tme->tm_min)/12;
X   }
X
X/* clean up and exit */
X
Xclean(n)
Xint	n;
X   {
X   m_popall(0);
X   m_clear();
X   m_flush();
X   m_ttyreset();
X   exit(1);
X   }
END_OF_FILE
# end of 'demo/misc/clock2.c'
fi
if test -f 'src/blit/bitmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/blit/bitmap.c'\"
else
echo shar: Extracting \"'src/blit/bitmap.c'\" \(4616 characters\)
sed "s/^X//" >'src/blit/bitmap.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: bitmap.c,v 4.2 88/07/07 09:04:29 sau Exp $
X	$Source: /tmp/mgrsrc/src/blit/RCS/bitmap.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/blit/RCS/bitmap.c,v $$Revision: 4.2 $";
X
X/*  SUN-2  and SUN-3 bitblit code */
X
X#ifdef sun
X#  include <sys/ioctl.h>
X#  include <sun/fbio.h>
X#  include <sys/file.h>
X#  include <sys/mman.h>
X#endif
X#include <stdio.h>
X#include "bitmap.h"
X
Xint bit_debug = 1;
Xstatic int _s_start;
Xstatic _s_len;
X
X/* open the screen; it looks like memory */
X
XBITMAP *
Xbit_open(name)
Xchar *name;			/* name of frame buffer */
X{
X   BITMAP *result = BIT_NULL;
X#ifdef sun
X   int fd;
X   char *malloc();
X   register DATA addr;
X   struct fbtype buff;
X   int pagesize;
X
X   Bprintf(1) ("bit_open:(%s)\n", name);
X
X   /* open the SUN screen */
X
X   if ((fd = open(name, O_RDWR)) < 0)
X      return (BIT_NULL);
X
X   /* get the frame buffer size */
X
X   if (ioctl(fd, FBIOGTYPE, &buff) < 0)
X      return (BIT_NULL);
X
X   /* malloc space for frame buffer */
X
X   pagesize = getpagesize();
X   if ((_s_start = (int) malloc(buff.fb_size + pagesize)) == 0)
X      return (BIT_NULL);
X
X   /* align space on a page boundary */
X
X   buff.fb_size = (buff.fb_size+pagesize-1) &~ (pagesize-1);
X   addr = (DATA ) ((_s_start + pagesize - 1) & ~(pagesize - 1));
X
X   /* map the frame buffer into malloc'd space */
X
X#ifdef _MAP_NEW		/* New semantics for mmap in Sun release 4.0 */
X   addr = (DATA) mmap(addr, _s_len=buff.fb_size,
X						 PROT_WRITE, _MAP_NEW|MAP_SHARED, fd, 0);
X   if ((int)addr == -1)
X      return (BIT_NULL);
X#else
X   if (mmap(addr, _s_len = buff.fb_size, PROT_WRITE, MAP_SHARED, fd, 0) < 0)
X      return (BIT_NULL);
X#endif
X
X   if ((result = (BITMAP *) malloc(sizeof(BITMAP))) == (BITMAP *) 0)
X      return (BIT_NULL);
X
X   result->primary = result;
X   result->data = addr;
X   result->x0 = 0,
X      result->y0 = 0,
X      result->wide = buff.fb_width;
X   result->high = buff.fb_height;
X   result->type = _SCREEN;
X   Bprintf(2) ("  O.K.(0x%lx)\n (%d x %x)",
X	       (long) result->data, result->wide, result->high);
X#endif
X   return (result);
X}
X
X/* destroy a bitmap, free up space */
X
Xint
Xbit_destroy(bitmap)
XBITMAP *bitmap;
X{
X   Bprintf(1) ("bit_destroy:\n");
X   if (bitmap == (BITMAP *) 0)
X      return (-1);
X   if (IS_MEMORY(bitmap) && IS_PRIMARY(bitmap))
X      free(bitmap->data);
X   else if (IS_SCREEN(bitmap) && IS_PRIMARY(bitmap)) {
X      munmap(BIT_DATA(bitmap), _s_len);
X      free(_s_start);
X   }
X   free(bitmap);
X   return (0);
X}
X
X/* create a bitmap as a sub-rectangle of another bitmap */
X
XBITMAP *
Xbit_create(map, x, y, wide, high)
XBITMAP *map;
Xint x, y, wide, high;
X{
X   char *malloc();
X   register BITMAP *result;
X
X   Bprintf(1) ("bit_create:\n");
X   if (x + wide > map->wide)
X      wide = map->wide - x;
X   if (y + high > map->high)
X      high = map->high - y;
X   if (wide < 1 || high < 1)
X      return (BIT_NULL);
X
X   if ((result = (BITMAP *) malloc(sizeof(BITMAP))) == (BITMAP *) 0)
X      return (BIT_NULL);
X
X   result->data = map->data;
X   result->x0 = map->x0 + x;
X   result->y0 = map->y0 + y;
X   result->wide = wide;
X   result->high = high;
X   result->primary = map->primary;
X   result->type = map->type;
X   Bprintf(2) ("  Created %d,%d %d,%d\n", result->x0, result->y0,
X	       result->wide, result->high);
X   return (result);
X}
X
X/* allocate space for, and create a memory bitmap */
X
XBITMAP *
Xbit_alloc(wide, high, data, bits)
Xunsigned short wide, high;
XDATA data;
Xint bits;	/* in preparation for color */
X{
X   char *malloc();
X   register BITMAP *result;
X   register int size;
X
X   Bprintf(1) ("bit_alloc:\n");
X   if ((result = (BITMAP *) malloc(sizeof(BITMAP))) == (BITMAP *) 0)
X      return (result);
X
X   result->x0 = 0;
X   result->y0 = 0;
X   result->high = high;
X   result->wide = wide;
X
X   size = BIT_SIZE(result);
X
X   if (data != (DATA ) 0)
X      result->data = data;
X#ifdef ALIGN32
X   else if ((result->data = (DATA ) memalign(4,size)) == (DATA ) 0) {
X#else
X   else if ((result->data = (DATA ) malloc(size)) == (DATA ) 0) {
X#endif
X      free(result);
X      return ((BITMAP *) 0);
X   }
X
X   result->primary = result;
X   result->type = _MEMORY;
X   Bprintf(2) ("  Created %d,%d %d,%d\n", result->x0, result->y0,
X	       result->wide, result->high);
X   return (result);
X}
END_OF_FILE
# end of 'src/blit/bitmap.c'
fi
if test -f 'src/blit/line.C' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/blit/line.C'\"
else
echo shar: Extracting \"'src/blit/line.C'\" \(4306 characters\)
sed "s/^X//" >'src/blit/line.C' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: line.C,v 4.2 88/06/30 11:40:57 sau Exp $
X	$Source: /tmp/mgrsrc/src/blit/RCS/line.C,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/blit/RCS/line.C,v $$Revision: 4.2 $";
X
X#include "asm.h"
X#include "bitmap.h"
X
X/*  Draw a line  - Bresenham method using bit-field instructions.
X *  The bitfield instructions don't buy much (<10%), but they're there.
X */
X
Xbit_line(dest, x0, y0, x1, y1, func)
Xregister BITMAP *dest;				/* destination bitmap */	
Xint x0, y0, x1, y1;			/* line coordinates */
Xint func;					/* set, clear, or invert */
X   {
X   register int err, rincr, rdecr, d_incr, count;
X   register int offset;			/* bit offset from x0,y0 */
X   register long *base;			/* address of x0,y0 */
X   int dx, dy;				/* # of pixels in x and y */
X   int temp;
X
X#ifndef NOCLIP
X   /* clip here */
X
X#define TOP	001
X#define BOTTOM	002
X#define LEFT	004
X#define RIGHT	010
X#define CROSS(x,y) \
X	  (x<0 ? LEFT : x>= (dest->wide) ? RIGHT : 0) + \
X	  (y < 0 ? TOP : y >=  (dest -> high) ? BOTTOM : 0)
X
X      {
X
X      /* The classic line clipping algorithm */
X
X      int cross0 = CROSS(x0, y0);
X      int cross1 = CROSS(x1, y1);
X
X      while (cross0 || cross1) {
X	      int cross, x, y;
X	      if (cross0 & cross1)
X	         return;
X	      if (cross0 != 0)
X	         cross = cross0;
X	      else
X	         cross = cross1;
X	      if (cross & (LEFT | RIGHT)) {
X	         int edge = (cross & LEFT) ? 0 : dest->wide - 1;
X	         y = y0 + (y1 - y0) * (edge - x0) / (x1 - x0);
X	         x = edge;
X	         }
X	      else if (cross & (TOP | BOTTOM)) {
X	         int edge = (cross & TOP) ? 0 : dest->high - 1;
X	         x = x0 + (x1 - x0) * (edge - y0) / (y1 - y0);
X	         y = edge;
X	         }
X	      if (cross == cross0) {
X	         x0 = x;
X	         y0 = y;
X	         cross0 = CROSS(x, y);
X	         }
X	      else {
X	         x1 = x;
X	         y1 = y;
X	         cross1 = CROSS(x, y);
X	         }
X         }
X      }
X
X   /* end of clipping */
X#endif
X
X   x0 += dest->x0;
X   y0 += dest->y0;
X   x1 += dest->x0;
X   y1 += dest->y0;
X
X   /* always draw left to right */
X
X   if (x1 < x0) {
X      temp = x1, x1 = x0, x0 = temp;
X      temp = y1, y1 = y0, y0 = temp;
X      }
X   dx = x1 - x0;
X   dy = y1 - y0;
X
X   if (dy > 0)
X      d_incr = BIT_LINE(dest);
X   else
X      d_incr = -BIT_LINE(dest), dy = -dy;
X
X   base = y0 * (BIT_LINE(dest) >> 5) + (dest->data);	/* start of line */
X   offset = x0;			/* bit offset from line */
X
X#define STEP(dx,dy,xmove,ymove,op) {		\
X    rincr = (dx - dy)<<1;			\
X    rdecr = -(dy<<1);				\
X    err = dx + rdecr;				\
X    for (count = dx; count >= 0; count--) {	\
X        op($base,$offset,IMM(1)); \
X        offset  += (xmove);	    				\
X        if (err < 0) {				\
X            offset += (ymove);				\
X            err += rincr;				\
X            }					\
X        else {					\
X            err += rdecr;				\
X            }					\
X        } 					\
X    }
X
X   /* @+ */
X
X   if (dx > dy)			/* gentle slope */
X      switch (OPCODE(func)) {
X	 case OPCODE(SRC):
X	 case OPCODE(SRC | DST):
X	 case OPCODE(SRC | ~DST):
X	 case OPCODE(~0):
X	    STEP(dx, dy, 1, d_incr, BF_SET);
X	    break;
X	 case OPCODE(~SRC):
X	 case OPCODE(~(SRC|DST)):
X	 case OPCODE(DST & ~SRC):
X	 case OPCODE(0):
X	    STEP(dx, dy, 1, d_incr, BF_CLR);
X	    break;
X	 case OPCODE(SRC ^ DST):
X	 case OPCODE(~DST):
X	 case OPCODE(SRC & ~DST):
X	 case OPCODE(~(SRC&DST)):
X	    STEP(dx, dy, 1, d_incr, BF_INV);
X	    break;
X         }
X   else				/* steep slope */
X      switch (OPCODE(func)) {
X	 case OPCODE(SRC):
X	 case OPCODE(SRC | DST):
X	 case OPCODE(SRC | ~DST):
X	 case OPCODE(~0):
X	    STEP(dy, dx, d_incr, 1, BF_SET);
X	    break;
X	 case OPCODE(~SRC):
X	 case OPCODE(~(SRC|DST)):
X	 case OPCODE(DST & ~SRC):
X	 case OPCODE(0):
X	    STEP(dy, dx, d_incr, 1, BF_CLR);
X	    break;
X	 case OPCODE(SRC ^ DST):
X	 case OPCODE(~DST):
X	 case OPCODE(SRC & ~DST):
X	 case OPCODE(~(SRC&DST)):
X	    STEP(dy, dx, d_incr, 1, BF_INV);
X	    break;
X	}
X   }
END_OF_FILE
# end of 'src/blit/line.C'
fi
if test -f 'src/blit/sym.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/blit/sym.c'\"
else
echo shar: Extracting \"'src/blit/sym.c'\" \(5117 characters\)
sed "s/^X//" >'src/blit/sym.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: sym.c,v 4.1 88/06/21 13:19:15 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/blit/RCS/sym.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/blit/RCS/sym.c,v $$Revision: 4.1 $";
X
X/* do symbolic substitution for asm decls SUN version */
X
X/*	sample stab entries
X	.stabs	"x:r(0,1)",0x40,0,4,7
X	.stabs	"i:r(0,1)",0x40,0,4,6
X	.stabs	"d:r(0,13)",0x40,0,1,12
X	.stabs	"s:r(0,13)=*(0,2)",0x40,0,1,13
X   sample sun instruction
X	   bfins.l %d1, (%$dbase)[%$dst:%$field]
X*/
X
X#include "stdio.h"
X#include "hash.h"
X
X#define GET_OPT(i)   \
X   strlen(argv[i])>2 ? argv[i]+2 : argv[++i]
X
X#define FMT	"	.stabs	\"%[^:]:r%*[^\"]\",0x%d,%*d,%*d,%s"
X#define TSIZE		501			/* # of entries in hash table */
X#define KEY	"#$ %s %s"		/* key work entry */
X#define dprintf	if(debug)fprintf
X
Xchar line[512];			/* input line buffer */
Xchar name[32];				/* parameter name */
Xchar reg[10];				/* register value */
X
Xstruct table_entry *table[TSIZE];
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   int class;		/* storage class */
X   int n;
X   char *start, *end;	/* for finding sub's. */
X   char *index(), *get_end();
X   int value;		/* register value to substitute */
X   int count = 0;	/* # of subs */
X   int line_cnt=0;		/* input line # */
X   char type;		/* register type 'a' or 'd' */
X   int debug = 0;
X   register int i;
X
X   for(i=1;i<argc;i++) {
X      if (*argv[i] == '-')
X         switch (argv[i][1]) {
X            case 'd':            /* turn on debugging */
X               debug++;
X               break;
X            case 'K':            /* add keyword */
X                  { 
X                  char *key = (GET_OPT(i));
X                  char *reg = argv[++i];
X                  add_entry(table,TSIZE,key);
X                  put_entry(table,TSIZE,key,reg);
X                  dprintf(stderr,"adding %s => %s from command line\n",key,reg);
X                  }
X               break;
X            default:
X               fprintf(stderr,"%s: bad flag %c ignored\n",argv[0],argv[i][1]);
X            }
X         }
X
X   dprintf(stderr,"Asm symbolic processor\n");
X   while(gets(line) != NULL) {
X      line_cnt++;
X		n = sscanf(line,FMT,name,&class,reg);
X		if (n==3 && class == 40) {					/* declaration */
X         if (is_entry(table,TSIZE,reg))  {		/* delete old name */
X            dlt_entry(table,TSIZE,get_entry(table,TSIZE,reg));
X            }
X         add_entry(table,TSIZE,reg);
X         add_entry(table,TSIZE,name);
X         put_entry(table,TSIZE,name,reg);
X         put_entry(table,TSIZE,reg,name);
X         puts(line);
X         dprintf(stderr,"adding %s => %s from stab entry\n",name,reg);
X         }
X      else if (sscanf(line,KEY,name,reg) == 2) {	/* keyword substitution */
X         add_entry(table,TSIZE,name);
X         put_entry(table,TSIZE,name,reg);
X         dprintf(stderr,"adding %s => %s from file\n",name,reg);
X         }
X      else if (start = index(line,'$')) {				/* parameter substitution */
X         fwrite(line,1,start-line,stdout);
X         do {
X            end = get_end(start+1);
X            strncpy(name,start+1,end-start-1);
X            name[end-start-1] = '\0';
X            if (is_entry(table,TSIZE,name)) { /* do substitution */
X               value = atoi(get_entry(table,TSIZE,name));
X               if (value > 7) {
X                  type = 'a';
X                  value -=8;
X                  }
X               else
X                  type = 'd';
X               printf("%c%d",type,value);
X               dprintf(stderr,"line %d: substituting <%c%d> for <%s>\n",
X                       line_cnt,type,value,name);
X               count++;
X               }
X            else if (is_reg(name))	{							/* can't find sub */
X               printf("%s",name);
X               } 
X            else {			
X               printf("$%s",name);
X               fprintf(stderr,"%s: Line %d no register found for %s\n",
X                       *argv,line_cnt,name);
X               }
X            if (start = index(end,'$')) 
X               fwrite(end,1,start-end,stdout);
X            else
X               printf("%s\n",end);
X            }
X         while(start);
X         }
X      else															/* pass through */
X         puts(line);
X      }
X   dprintf(stderr,"%d substitutions made on %d lines\n",count,line_cnt);
X   exit(0);
X   }
X
X/* find end of word */
X
Xchar *
Xget_end(str)
Xchar *str;
X   {
X   register char c;
X   register int i=0;
X
X   while (i++,(c = *str++)) {
X      if (c>='a' && c<='z') continue;
X      if (c>='A' && c <= 'Z') continue;
X      if (i>1 && c>='0' && c <= '9') continue;
X      if (c != '_') break;
X      }
X   return(str-1);
X   }
X
X/* see if variable is [ad][0-7] */
X
Xint
Xis_reg(name)
Xchar *name;
X   {
X   return( (name[0]=='d' || name[1] == 'a') &&
X           (name[1] >= '0' && name[1] <= '7'));
X   }
END_OF_FILE
# end of 'src/blit/sym.c'
fi
if test -f 'src/destroy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/destroy.c'\"
else
echo shar: Extracting \"'src/destroy.c'\" \(5076 characters\)
sed "s/^X//" >'src/destroy.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: destroy.c,v 4.1 88/06/21 13:21:40 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/RCS/destroy.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/destroy.c,v $$Revision: 4.1 $";
X
X/* destroy a window (needs fixing) */
X
X#include "bitmap.h"
X#include <stdio.h> 	/* temporary */
X#include <sys/wait.h>
X#include <sys/signal.h>
X#include "defs.h"
X#include "font.h"
X#include "event.h"
X
X#define ALL	1
X
X/* mark active window for destruction */
X
Xint destroy_window()
X   {
X   ACTIVE(flags) |= W_DIED;
X   }
X
X/* destroy a window */
X
Xint destroy(win)
Xregister WINDOW *win;
X   {
X   int i;
X   union wait status;
X
X   if (win == (WINDOW *) 0)
X      return(-1);
X
X   MOUSE_OFF(mousex,mousey);
X   cursor_off();
X
X   if (win != active) {
X      ACTIVE_OFF();
X      expose(win);
X      }
X
X   active = W(next);
X
X   /* deallocate window slot */
X
X   if (active)
X      ACTIVE(prev) = W(prev);
X
X   /* remove window from screen */
X
X   erase_win(W(border));
X
X   if (W(main)==win) {		/* kill process associated with the window */
X#ifdef DEBUG
X      dprintf(d)(stderr,"%s: destroy main %s\r\n",W(tty),W(alt)?"ALT":"");
X#endif
X      killpg(W(pid),SIGHUP);
X
X      if (geteuid() < 1) {
X         chmod(W(tty),0666);
X         chown(W(tty),0,0);
X         }
X
X      close(W(to_fd));
X      mask &= ~(1<<W(to_fd));
X      poll &= ~(1<<W(to_fd));
X#ifdef WHO
X      rm_utmp(W(tty));
X#endif
X
X      /* tell alternate windows main died */
X
X      set_dead(win);
X
X      /* wait for shell to die */
X
X#ifdef DEBUG
X      dprintf(d)(stderr,"waiting for ..."); fflush(stderr);
X#endif
X      if (W(pid) > 1) {
X         i = wait3(&status,WNOHANG,0L);
X         if (i == 0) { 					/* start it so it can die */
X            kill(W(pid),SIGCONT);
X            wait(&status);
X            }
X         }
X#ifdef DEBUG
X      dprintf(d)(stderr," %d\r\n",i);
X#endif
X      next_window--; 
X      }
X
X   else if (W(main) && !(W(main)->flags&W_DIED)) {	/* main still alive */
X#ifdef DEBUG
X      dprintf(d)(stderr,"%s: destroy alt %d\r\n",W(tty),W(num));
X#endif
X      do_event(EVENT_DESTROY,win,E_MAIN);
X      if (W(from_fd)) {		/* re-attach output to main window */
X         W(main)->from_fd = W(main)->to_fd;
X         W(main)->max = W(max) - W(current); /* ??? */
X#ifdef DEBUG
X      dprintf(d)(stderr,"%s: copy %d chars at %d\r\n",
X               W(main)->max, W(current));
X#endif
X         bcopy(W(buff)+W(current)+1,W(main)->buff,W(main)->max);
X         W(main)->current = 0;
X#ifdef DEBUG
X         dprintf(d)(stderr,"%s: reattaching main %d chars\r\n",W(tty),W(max));
X#endif
X         }
X      detach(win);
X      }
X   else if (W(main)) {		/* tell main alts know they are dead */
X      W(main)->alt = (WINDOW *) 0;
X#ifdef DEBUG
X      dprintf(d)(stderr,"%s: destroy alt, (tell main)\r\n",W(tty));
X#endif
X      }
X   else {
X#ifdef DEBUG
X      dprintf(d)(stderr,"%s: destroy alt, (dead main)\r\n",W(tty));
X#endif
X      }
X
X   /* fix up display if any windows left */
X
X   if (active) {
X      repair(win);
X      un_covered();
X      clip_bad(win);	/* invalidate clip lists */
X      ACTIVE_ON();
X      cursor_on();
X      }
X
X   /* free space associated with dead window */
X
X   unlink_win(win,ALL);
X
X#ifdef DEBUG
X   dprintf(d)(stderr,"Active: %s-%d\r\n",
X          active?ACTIVE(tty):"NONE", active?ACTIVE(num):0);
X#endif
X
X   MOUSE_ON(mousex,mousey);
X
X   return(0);
X   }
X
X/* free all space associated with a window */
X
Xunlink_win(win,how)
Xregister WINDOW *win;		/* window to unlink */
Xint how;			/* if how, unlink window stack as well */
X   {
X   register int i;
X
X#ifdef DEBUG
X   dprintf(u)(stderr,"Unlinking %s %s\n",W(tty),how?"ALL":"");
X#endif
X
X   if (how && W(stack))
X      unlink_win(W(stack),how);
X   if (W(window))
X       bit_destroy(W(window));
X   for(i=0; i< MAXBITMAPS;i++) 
X      if (W(bitmaps)[i])
X          bit_destroy(W(bitmaps)[i]);
X   if (W(border))
X       bit_destroy(W(border));
X   if (W(save))
X       bit_destroy(W(save));
X   if (W(snarf))
X      free(W(snarf));
X   if (W(bitmap))
X      free(W(bitmap));
X   zap_cliplist(win);
X
X   for(i=0; i< MAXEVENTS;i++) 
X       if (W(events)[i])
X          free(W(events)[i]);
X
X   for(i=0; i< MAXMENU;i++) 
X      if (W(menus)[i])
X         menu_destroy(W(menus)[i]);
X
X   free(win);
X   }
X
X/* unlink an alternate window from list */
X
Xint
Xdetach(win2)
XWINDOW *win2;
X   {
X   register WINDOW *win = win2;
X
X   if (!(W(main)))
X      return;
X   for(win=win2->main;W(alt)!=win2;win=W(alt))
X      ;
X   W(alt)= win2->alt;
X   }
X
X/* notify alternate windows of impending death */
X
Xset_dead(win)
Xregister WINDOW *win;
X   {
X   for(win = W(alt); win != (WINDOW *) 0; win = W(alt)) {
X#ifdef DEBUG
X      dprintf(d)(stderr,"%s: telling %d\r\n",W(tty),W(num));
X#endif
X      W(main) = (WINDOW *) 0;
X      }
X   }
END_OF_FILE
# end of 'src/destroy.c'
fi
if test -f 'src/font_subs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/font_subs.c'\"
else
echo shar: Extracting \"'src/font_subs.c'\" \(4187 characters\)
sed "s/^X//" >'src/font_subs.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: font_subs.c,v 4.2 88/06/24 10:18:04 sau Exp $
X	$Source: /tmp/mgrsrc/src/RCS/font_subs.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/font_subs.c,v $$Revision: 4.2 $";
X
X/* font routines */
X
X#include "bitmap.h"
X#include "font.h"
X#include "default_font.h"
X#include "window.h"
X#include <stdio.h>
X#ifdef DEBUG
X#   include "defs.h"
X#endif
X
X#define HEAD(x)		font->head.x
X
X/**************************************************************************
X *
X *	set up a font file
X */
X
Xstruct font *
Xopen_font(file)
Xchar *file;			/* name of font file */
X   {
X   FILE *fp;
X   int size;
X   char *malloc();
X   struct font *font, *open_sfont();
X
X   if (file == (char *) 0 || *file == '\0') {
X      return(open_sfont(default_font_head,&default_font));
X      }
X
X#ifdef DEBUG
X      dprintf(f)(stderr,"Opening font file [%s]\n",file);
X#endif
X
X   if ((fp=fopen(file,"r"))  == NULL)
X      return((struct font *)0);
X
X   if ((font=(struct font *) malloc(sizeof(struct font))) == (struct font *)0) {
X      fclose(fp);
X      return((struct font *)0);
X      }
X
X   if (fread(&(font->head),HEADER_SIZE,1,fp) != 1) {
X      free((char *) font);
X      fclose(fp);
X      return((struct font *)0);
X      }
X
X   if (HEAD(type) != FONT_A) {
X      free((char *) font);
X      fclose(fp);
X      return((struct font *)0);
X      }
X                               
X   font->data = bit_alloc(HEAD(wide) *HEAD(count),HEAD(high),NULL_DATA,1);
X   font->table = (struct entry **) 0;
X
X   /* read in font data */
X
X   size = BIT_SIZE(font->data);
X   fread(BIT_DATA(font->data), size, 1, fp);
X
X   /* create individual characters */
X
X   glyph_create( font );
X
X   fclose(fp);
X   return(font);
X   }
X
X
X/**************************************************************************
X *
X *	deallocate a font
X */
X
Xint
Xfree_font(dead_font)
Xstruct font *dead_font;		/* font to be deallocated */
X   {
X   register int i;
X
X   if (!dead_font)
X      return(-1);
X
X   for(i=0;i<MAXGLYPHS;i++)
X      if (dead_font->glyph[i])
X         bit_destroy(dead_font->glyph[i]);
X   if (dead_font->head.type != FONT_S)
X      bit_destroy(dead_font->data);
X   zap_fhash(dead_font);		/* free up hash table space */
X   i=font_purge(dead_font);	/* eliminate references to dead font */
X
X#ifdef DEBUG
X      dprintf(f)(stderr,"freeing font %d (%d references)\n",
X      dead_font->ident,i);
X#endif
X
X   free((char *) dead_font);
X   }
X
X/**************************************************************************
X *
X *	set up a static font file
X */
X
Xstruct font *
Xopen_sfont(head,data)
Xstruct font_header head;	/* font header */
XBITMAP *data;		/* array of bits */
X   {
X   char *malloc();
X   struct font *font;
X
X   if ((font=(struct font *) malloc(sizeof(struct font))) == (struct font *)0)
X      return((struct font *)0);
X
X   font->head = head;
X   font->data = data;
X   font->head.type = FONT_S;
X   font->table = (struct entry **) 0;
X
X   /* create individual characters */
X
X   glyph_create( font );
X
X   return(font);
X   }
X
X
Xstatic
Xglyph_create( font )
Xstruct font *font;
X   {
X   register int i, x;
X   int		first = HEAD(start);
X   int		last = HEAD(start) + HEAD(count);
X   int		wide = HEAD(wide);
X   int		high = HEAD(high);
X   int		nochar;
X   
X   /* Pick the character to be printed for characters not in the set.
X      Normally, it is the character specified by C_NOCHAR, but it that isn't
X      in the range of the set, we pick the first character (which is usually
X      a space).
X   */
X   nochar = C_NOCHAR - HEAD(start);
X   if( nochar >= last )
X	nochar = 0;
X   nochar *= wide;
X
X   x = 0;
X   for(i=0; i<MAXGLYPHS; i++)
X      if (i < first || i >= last)
X         font->glyph[i] = bit_create(font->data, nochar, 0, wide, high);
X      else {
X         font->glyph[i] = bit_create(font->data, x, 0, wide, high);
X         x += wide;
X         }
X   }
END_OF_FILE
# end of 'src/font_subs.c'
fi
if test -f 'src/oblit/bitmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/oblit/bitmap.c'\"
else
echo shar: Extracting \"'src/oblit/bitmap.c'\" \(4634 characters\)
sed "s/^X//" >'src/oblit/bitmap.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: bitmap.c,v 4.2 88/07/07 09:08:51 sau Exp $
X	$Source: /tmp/mgrsrc/src/oblit/RCS/bitmap.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/oblit/RCS/bitmap.c,v $$Revision: 4.2 $";
X
X/*  SUN-2  and SUN-3 bitblit code */
X
X#ifdef sun
X#  include <sys/ioctl.h>
X#  include <sun/fbio.h>
X#  include <sys/file.h>
X#  include <sys/mman.h>
X#endif
X#include <stdio.h>
X#include "bitmap.h"
X
Xint bit_debug = 1;
Xstatic int _s_start;
Xstatic _s_len;
X
X/* open the screen; it looks like memory */
X
XBITMAP *
Xbit_open(name)
Xchar *name;			/* name of frame buffer */
X{
X   BITMAP *result = BIT_NULL;
X#ifdef sun
X   int fd;
X   char *malloc();
X   register DATA addr;
X   struct fbtype buff;
X   int pagesize;
X
X   Bprintf(1) ("bit_open:(%s)\n", name);
X
X   /* open the SUN screen */
X
X   if ((fd = open(name, O_RDWR)) < 0)
X      return (BIT_NULL);
X
X   /* get the frame buffer size */
X
X   if (ioctl(fd, FBIOGTYPE, &buff) < 0)
X      return (BIT_NULL);
X
X   /* malloc space for frame buffer */
X
X   pagesize = getpagesize();
X   if ((_s_start = (int) malloc(buff.fb_size + pagesize)) == 0)
X      return (BIT_NULL);
X
X   /* align space on a page boundary */
X
X   buff.fb_size = (buff.fb_size+pagesize-1) &~ (pagesize-1);
X   addr = (DATA ) ((_s_start + pagesize - 1) & ~(pagesize - 1));
X
X   /* map the frame buffer into malloc'd space */
X
X#ifdef _MAP_NEW      /* New semantics for mmap in Sun release 4.0 */
X   addr = (DATA) mmap(addr, _s_len=buff.fb_size,
X                   PROT_WRITE, _MAP_NEW|MAP_SHARED, fd, 0);
X   if ((int)addr == -1)
X      return (BIT_NULL);
X#else
X   if (mmap(addr, _s_len = buff.fb_size, PROT_WRITE, MAP_SHARED, fd, 0) < 0)
X      return (BIT_NULL);
X#endif
X
X   if ((result = (BITMAP *) malloc(sizeof(BITMAP))) == (BITMAP *) 0)
X      return (BIT_NULL);
X
X   result->primary = result;
X   result->data = addr;
X   result->x0 = 0,
X      result->y0 = 0,
X      result->wide = buff.fb_width;
X   result->high = buff.fb_height;
X   result->type = _SCREEN;
X   Bprintf(2) ("  O.K.(0x%lx)\n (%d x %x)",
X	       (long) result->data, result->wide, result->high);
X#endif
X   return (result);
X}
X
X/* destroy a bitmap, free up space */
X
Xint
Xbit_destroy(bitmap)
XBITMAP *bitmap;
X{
X   Bprintf(1) ("bit_destroy:\n");
X   if (bitmap == (BITMAP *) 0)
X      return (-1);
X   if (IS_MEMORY(bitmap) && IS_PRIMARY(bitmap))
X      free(bitmap->data);
X   else if (IS_SCREEN(bitmap) && IS_PRIMARY(bitmap)) {
X      munmap(BIT_DATA(bitmap), _s_len);
X      free(_s_start);
X   }
X   free(bitmap);
X   return (0);
X}
X
X/* create a bitmap as a sub-rectangle of another bitmap */
X
XBITMAP *
Xbit_create(map, x, y, wide, high)
XBITMAP *map;
Xint x, y, wide, high;
X{
X   char *malloc();
X   register BITMAP *result;
X
X   Bprintf(1) ("bit_create:\n");
X   if (x + wide > map->wide)
X      wide = map->wide - x;
X   if (y + high > map->high)
X      high = map->high - y;
X   if (wide < 1 || high < 1)
X      return (BIT_NULL);
X
X   if ((result = (BITMAP *) malloc(sizeof(BITMAP))) == (BITMAP *) 0)
X      return (BIT_NULL);
X
X   result->data = map->data;
X   result->x0 = map->x0 + x;
X   result->y0 = map->y0 + y;
X   result->wide = wide;
X   result->high = high;
X   result->primary = map->primary;
X   result->type = map->type;
X   Bprintf(2) ("  Created %d,%d %d,%d\n", result->x0, result->y0,
X	       result->wide, result->high);
X   return (result);
X}
X
X/* allocate space for, and create a memory bitmap */
X
XBITMAP *
Xbit_alloc(wide, high, data, bits)
Xunsigned short wide, high;
XDATA data;
Xint bits;	/* in preparation for color */
X{
X   char *malloc();
X   register BITMAP *result;
X   register int size;
X
X   Bprintf(1) ("bit_alloc:\n");
X   if ((result = (BITMAP *) malloc(sizeof(BITMAP))) == (BITMAP *) 0)
X      return (result);
X
X   result->x0 = 0;
X   result->y0 = 0;
X   result->high = high;
X   result->wide = wide;
X
X   size = BIT_SIZE(result);
X
X   if (data != (DATA ) 0)
X      result->data = data;
X#ifdef ALIGN32
X   else if ((result->data = (DATA ) memalign(4,size)) == (DATA ) 0) {
X#else
X   else if ((result->data = (DATA ) malloc(size)) == (DATA ) 0) {
X#endif
X      free(result);
X      return ((BITMAP *) 0);
X   }
X
X   result->primary = result;
X   result->type = _MEMORY;
X   Bprintf(2) ("  Created %d,%d %d,%d\n", result->x0, result->y0,
X	       result->wide, result->high);
X   return (result);
X}
END_OF_FILE
# end of 'src/oblit/bitmap.c'
fi
if test -f 'src/print.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/print.c'\"
else
echo shar: Extracting \"'src/print.c'\" \(4315 characters\)
sed "s/^X//" >'src/print.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: print.c,v 4.1 88/06/21 13:34:25 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/RCS/print.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/print.c,v $$Revision: 4.1 $";
X
X/* debugging routines for printing status info */
X
X#include <stdio.h>
X
Xstatic char *flags[] = { 
X   "active",
X   "escape",
X   "snarfable",
X   "reverse",
X   "standout",
X   "died",
X   "expose",
X   "background",
X   "nokill",
X   "vi",
X   "downloading",
X   "noinput",
X   "nowrap",
X   "overstrike",
X   "abs-coords",
X   "minus",
X   "snarf-lines",
X   "snarf-tabs",
X   "snarf-hard",
X   (char *) 0
X   };
X
Xstatic char *events[] = {
X   "1_up",
X   "no-event",
X   "2_up",
X   "3_up",
X   "no-event",
X   "3_down",
X   "2_down",
X   "no-event",
X   "1_down",
X   "shape",
X   "redraw",
X   "activated",
X   "deactivated",
X   "covered",
X   "uncovered",
X   "moved",
X   "destroyed",
X   "accept",
X   "notify",
X   "tell-me",
X   "snarfed",
X   "paste",
X   "stack",
X   "stack_flag",
X   (char *) 0
X   };
X
Xstatic char *stack[] = {
X   "menu",
X   "event",
X   "font",
X   "cursor",
X   "bitmap",
X   "position",
X   "window",
X   "flags",
X   "mouse",
X   "text",
X   "CLEAR",
X   (char *) 0
X   };
X
Xstatic char *menu_states[] = {
X    "choice",
X    "bottom",
X    "top",
X    "top & bottom",
X    "left",
X    "left & bottom",
X    "left & top",
X    "left & top & bottom",
X    "right",
X    "right & bottom",
X    "right & top",
X    "right & top & bottom",
X    "right & left",
X    "right & left & bottom",
X    "right & left & top",
X    "right & left & top & bottom",
X   };
X
Xstatic char buff[512];
X
X/* get flag names */
X
Xchar *print_flags(n)
Xint n;
X   {
X   char *binary();
X   register int i,j;
X
X   sprintf(buff,"(%s)",binary(n));
X   for(j=1,i=0;flags[i];i++,j<<=1)
X      if (j&n) {
X         if (*buff) strcat(buff,",");
X         strcat(buff,flags[i]);
X         }
X   return(buff);
X   }
X
X/* get menu states */
X
Xchar
X*print_menu(n)
Xint n;		/* menu state */
X   {
X   return(menu_states[n%16]);
X   }
X
X/* get stack codes */
X
Xchar *print_stack(n)
Xint n;
X   {
X   register int i,j;
X   char *binary();
X
X   sprintf(buff,"(%s)",binary(n));
X   for(j=1,i=0;stack[i];i++,j<<=1)
X      if (j&n) {
X         if (*buff) strcat(buff,",");
X         strcat(buff,stack[i]);
X         }
X   return(buff);
X   }
X
X/* get event names */
X
Xchar *print_events(n)
Xint n;
X   {
X   register int i,j;
X   char *binary();
X
X   sprintf(buff,"(%s)",binary(n));
X   for(j=1,i=0;events[i];i++,j<<=1)
X      if (j&n) {
X         if (*buff) strcat(buff,",");
X         strcat(buff,events[i]);
X         }
X   return(buff);
X   }
X
X
X/* get ps info */
X
Xstatic char *list[100];
Xstatic int p_count = 0;
X
Xint
Xget_ps()
X   {
X   FILE *popen(), *ps = popen("ps a","r");
X   char line[81];
X   char *index(), *save_line();
X
X   fgets(line,sizeof(line),ps);
X   while(fgets(line,sizeof(line),ps) != NULL) {
X      list[p_count++] = save_line(line+6);
X      }
X   pclose(ps);
X   return(p_count);
X   }
X
Xint
Xfree_ps()
X   {
X   register int i;
X
X   for(i=0;i<p_count;i++) {
X      if (list[i])
X         free(list[i]);
X      }
X   p_count = 0;
X   }
X
Xchar *
Xprint_ps(tty)
Xchar *tty;
X   {
X   register int i;
X   register char *check = tty + (strlen(tty) - 2);
X   register char *p1,*p2;
X   char *index(), *strcpy();
X
X   *buff = '\0';
X   for(i=0;i<p_count;i++)
X      if (list[i] && strncmp(check,list[i],2)==0 &&
X                     (int)(p1 = index(list[i],':')+4)>4) {
X         if (p2 = index(p1,'\n'))
X            *p2 = '\0';
X         strcpy(buff,p1);
X         if (*p1 != '-')
X            break;
X         }
X   return(buff ? buff : strcpy(buff,"?? unknown ??"));
X   } 
X
X/*****************************************************************************
X *	print x in binary
X */
X
Xchar *
Xbinary(x)
Xint x;
X   {
X   register int i;
X   static char out[33];
X   int n=32;
X
X   out[n+1] = '\0';
X   for(i=0;i<n+1;i++)
X      if (x&(1<<i))
X         out[n-i] = '1';
X      else
X         out[n-i] = '0';
X   for(i=0;out[i]=='0' && i<33;i++);
X   return(i>0?out+i-1:out);
X   }
END_OF_FILE
# end of 'src/print.c'
fi
if test -f 'src/win_make.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/win_make.c'\"
else
echo shar: Extracting \"'src/win_make.c'\" \(4132 characters\)
sed "s/^X//" >'src/win_make.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: win_make.c,v 4.1 88/06/21 13:34:54 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/RCS/win_make.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/win_make.c,v $$Revision: 4.1 $";
X
X/* make an alternate window */
X
X#include "bitmap.h"
X#include "font.h"
X#include "defs.h"
X#include "window.h"
X#include "event.h"
X#include <stdio.h>
X
X/* manipulte an alternate (client) window - called by put_window() */
X
Xint
Xwin_make(win,indx)
XWINDOW *win;			/* window issuing make-call */
Xint indx;			/* current index into char string (yuk!) */
X   {
X   register int *p = W(esc);	/* array of ESC digits */
X   int buff[10];
X   WINDOW *win2=win, *insert_win();
X
X   switch (W(esc_cnt)) {
X      case 1:			/*  destroy the window */
X#ifdef DEBUG
X         dprintf(N)(stderr,"%s: destroying %d\n",W(tty),p[0]);
X#endif
X         if (p[0]<=0 || W(main)->alt == (WINDOW *) 0 ||
X                  W(main)->alt->num<p[0]) {
X            break;
X            }
X         for (win = W(main)->alt;win!=(WINDOW *) 0; win=W(alt))  {
X            if (W(num)==p[0])
X               break;
X            }
X         if (win != (WINDOW *) 0) 
X            W(flags) |= W_DIED;
X         break;
X
X      case 0:		/* goto a new window */
X         if (W(num)==p[0] || W(main)->alt == (WINDOW *) 0 ||
X                  W(main)->alt->num<p[0]) {
X            break;
X            }
X         for (win = W(main);win!=(WINDOW *) 0; win=W(alt))  {
X            if (W(num)==p[0])
X               break;
X            }
X
X         /* move contents of shell buffer to new window */
X
X         if (win != (WINDOW *) 0) {
X            W(from_fd) = W(to_fd);
X            win2->from_fd = 0;
X            W(max) = win2->max - win2->current - indx - 1;
X            bcopy(win2->buff + win2->current + indx + 1,W(buff),W(max));
X            W(current) = 0;
X#ifdef DEBUG
X            dprintf(N)(stderr,"%s: xfer %d\r\n",W(tty),W(max));
X#endif
X            }
X         break;
X
X      case 3:		/* make a new window */
X         p[4] = -1;
X         /* no break */
X      case 4:		/* new window + font (not implemented) */
X#ifdef DEBUG
X         dprintf(N)(stderr,"%s: making alternate window\n",W(tty));
X#endif
X         if (check_window(p[0],p[1],p[2],p[3],p[4]) == 0 ||
X                 next_window >= MAXWIN) {
X            write(ACTIVE(to_fd),"\n",1);
X            break;
X            }
X         if (win!=active)
X            cursor_off();
X         ACTIVE_OFF();
X         if ((active = insert_win((WINDOW *) 0)) == (WINDOW *) 0 ||
X                     !setup_window(active,font,p[0],p[1],p[2],p[3])) {
X            fprintf(stderr,"Out of memory for window creation -- bye!\n");
X            quit();
X            }
X
X         /* next_window++;  (this needs more thought) */
X
X         /* make the window */
X
X         set_covered(active);
X         border(active,BLK_BDR,WH_BDR);
X         CLEAR(ACTIVE(window),BIT_CLR);
X         ACTIVE_ON();
X         cursor_on();
X
X#ifdef DEBUG
X         dprintf(N)(stderr,"%s: window created\n",W(tty));
X#endif
X         /* fix pointer chain */
X
X         ACTIVE(to_fd) =  W(to_fd);
X         ACTIVE(main) = W(main);
X         ACTIVE(pid) =  W(pid);
X         ACTIVE(setid) =  W(setid);
X         strcpy(ACTIVE(tty),ACTIVE(main)->tty);
X         ACTIVE(from_fd) = 0;
X         ACTIVE(alt) =  W(main)->alt;
X         ACTIVE(main)->alt = active;
X         if (ACTIVE(alt))
X            ACTIVE(num) = ACTIVE(alt)->num + 1;
X         else
X            ACTIVE(num) = 1;
X         
X#ifdef DEBUG
X         dprintf(N)(stderr,"%s: created num %d\r\n",ACTIVE(tty),ACTIVE(num));
X#endif
X         sprintf(buff,"%d\n",ACTIVE(num));
X         write(ACTIVE(to_fd),buff,strlen(buff));
X         clip_bad(active);	/* invalidate clip lists */
X         break;
X      case 5:		/* nothing */
X         break;
X     }
X   }
END_OF_FILE
# end of 'src/win_make.c'
fi
echo shar: End of archive 20 \(of 61\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
