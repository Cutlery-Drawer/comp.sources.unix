Subject:  v17i018:  MGR, Bellcore window manager, Part18/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 18
Archive-name: mgr/part18




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 17 (of 61)."
# Contents:  demo/icon/cycle.c demo/misc/hilbert.c demo/misc/overlayd.c
#   font-16/Ucmrb8 font-16/Ucour9x16bu font-32/Ucmrb8
#   font-32/Ucour9x16bu lib/dump.h misc/tjfilter.c src/blit/bitmap.h
#   src/oblit/bitmap.h src/shape.c src/utmp.c
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:19 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'demo/icon/cycle.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/icon/cycle.c'\"
else
echo shar: Extracting \"'demo/icon/cycle.c'\" \(3517 characters\)
sed "s/^X//" >'demo/icon/cycle.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: cycle.c,v 4.2 88/06/24 17:22:31 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/icon/RCS/cycle.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/icon/RCS/cycle.c,v $$Revision: 4.2 $";
X
X#include <sys/time.h>
X#include <stdio.h>
X#include <signal.h>
X#include "term.h"
X
X/*
X * cycle -- a program to do simple flip-book animation
X * Steve Hawley
X */
X
X#define fsleep(x) \
X   { \
X   struct timeval time; \
X   time.tv_sec = 0; \
X   time.tv_usec = x; \
X   select(0,0,0,0,&time); \
X   }
X
X#define DEF_SPEED 90000
X#define MAXBUF 512
X
Xstatic char	*cmd;
Xstatic int	offset;	/* where icons end (offset from argc) */
Xstatic int	bitcount;	/* number of bitmaps created */
Xstatic char	cwd[MAXBUF];
Xstatic int	w, h;
X
Xstatic
Xcleanup()
X{
X	/* be a nice program and clean up */
X	int i;
X
X	m_ttyreset();			/* reset echo */
X	for (i = 1; i <= bitcount; i++)	/* free up bitmaps */
X		m_bitdestroy(i);
X	m_pop();			/* pop environment */
X	exit(0);
X}
X
Xmain(argc,argv)
Xchar **argv;
X{
X	char	*getenv();
X	int	speed, i;
X	int	reverse = 0;
X	FILE	*popen(), *fp = popen("/bin/pwd", "r");
X
X	cmd = *argv;
X	argc--; argv++;
X
X	if (!fp) {
X		fprintf(stderr,"%s: can't get current directory\n",cmd);
X		exit(2);
X	}
X	fgets(cwd,sizeof(cwd),fp);
X	*(cwd + strlen(cwd) - 1) = '\0';  /* blah */
X	pclose(fp);
X
X	if (argc < 1)
X		usage();
X
X	ckmgrterm();
X
X	m_setup(M_FLUSH);	/* flush output stream */
X	m_push(P_BITMAP|P_EVENT|P_FLAGS);
X	m_setmode(M_ABS);
X
X	signal(SIGINT,cleanup);		/* program loops forever */
X	signal(SIGTERM,cleanup);	/* this gives a mechanism */
X	signal(SIGQUIT,cleanup);	/* for cleaning up */
X
X	m_func(B_COPY);	/* bit copy, so we don't have to erase */
X	m_clear();	/* clear the screen */
X	m_ttyset()	;/* no keybaord echo */
X
X	speed = DEF_SPEED;
X	offset = 0;
X
X	while( argv[0][0] == '-' ) {
X		switch( argv[0][1] ) {
X		case 's':
X			speed = atoi(&(argv[0][2]));
X			break;
X		case 'r':
X			reverse = 1;
X			break;
X		default:
X			usage();
X		}
X		argv++; argc--;
X	}
X
X	if (argc < 1)
X		usage();
X
X	for ( ; argc;  argv++, argc-- ) {
X		bitcount++;
X		loadmap( bitcount, *argv );
X	}
X	while(1) {
X		for (i = 1; i <= bitcount; i++) {
X			m_bitcopyto(0, 0, w, h, 0, 0, 0, i);
X			fsleep(speed);
X			/* delay a bit, so we can see animation */
X		}
X		if( !reverse )
X			continue;
X		for (i--;  i > 1;  i--) {
X			m_bitcopyto(0, 0, w, h, 0, 0, 0, i);
X			fsleep(speed);
X		}
X	}
X}
X
X
Xstatic
Xloadmap( i, file )
Xint	i;
Xchar	*file;
X{
X	char	buf[MAXBUF];
X
X	if (*file == '/')
X		m_bitfromfile(i, file);
X	else if (strncmp(file, "../", 3) == 0) {
X		sprintf(buf, "%s/%s", cwd, file);
X		m_bitfromfile(i, buf);
X	}
X	else if (strncmp(file, "./", 2) == 0) {
X		sprintf(buf, "%s%s", cwd, file+1);
X		m_bitfromfile(i, buf);
X	}
X	else {
X		m_bitfromfile(i, file);
X	}
X	m_gets(buf);
X	sscanf(buf, "%d %d", &w, &h); /* load in icons. */
X	if (w == 0 || h == 0) {
X		fprintf(stderr, "%s: %s is not a bitmap.\n", cmd, file);
X		cleanup();
X	}
X}
X
X
Xstatic
Xusage()
X{
X	fprintf(stderr, "Usage: %s [-sspeed] [-r] icon1 [icon2 ...iconn]\n",
X		cmd);
X	fputs("\
X-sspeed	delay `speed' microseconds between frames\n\
X-r	after running forward through the frames, reverse and run backwards\n",
X		stderr);
X	exit(1);
X}
END_OF_FILE
# end of 'demo/icon/cycle.c'
fi
if test -f 'demo/misc/hilbert.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/misc/hilbert.c'\"
else
echo shar: Extracting \"'demo/misc/hilbert.c'\" \(3548 characters\)
sed "s/^X//" >'demo/misc/hilbert.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: hilbert.c,v 4.3 88/05/31 13:22:43 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/misc/RCS/hilbert.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/misc/RCS/hilbert.c,v $$Revision: 4.3 $";
X
X#include <signal.h>
X#include "term.h"
X
X/* program to draw hilbert space filling curves (very quick).
X * Steve Hawley			11/87 (Macintosh C implementation)
X * translated from a pascal version from the Oberlin Computer Science
X * Lab manual, Fall 1984, Author unknown.
X * --------- ported to mgr by SAU: FAST version uses fast vector mode
X */
X
Xint dir;
X
X/* global direction variable.  The original program used turtle graphics
X * with turn functions taking angles.  I cheat since all turns in this
X * program are 90 degrees, and make the directions be:
X *		0: down
X *		1: right
X *		2: up
X *		3: left
X */
X
Xstart()
X{
X	/* put the graphics cursor somewhere nice, and initialize
X	 * the direction.
X	 */
X
X	m_go(10,10);
X
X	dir = 0;
X}
X
Xleft()
X{
X	/* a turn to the left is actually the direction + 3
X	 * modulo 3.
X	 */
X	dir = (dir + 3) & 0x3;
X}
X
Xright()
X{
X	/* a right turn is the direction + 1 modulo 3 */
X	dir = (dir + 1) & 0x3;
X}
X
Xforward(size)
Xregister int size;
X{
X	/* move the graphics cursor and draw a line segment.
X	 * The Macintosh function Line(dh, dv) draws a line from the
X	 * current graphics cursor to the graphics cursor displaced
X	 * by dh and dv (horizontal and vertical deltas).
X	 */
X	switch(dir) {
X	case 0:
X		Line(0, size);
X		break;
X	case 1:
X		Line(size, 0);
X		break;
X	case 2:
X		Line(0, -size);
X		break;
X	case 3:
X		Line(-size, 0);
X		break;
X	}
X}
X
X/* mutually recursive hilbert functions: */
Xlhilbert(size, level)
Xregister int size, level;
X{
X	if (level > 0) {
X		left();
X		rhilbert(size, level-1);
X		forward(size);
X		right();
X		lhilbert(size, level-1);
X		forward(size);
X		lhilbert(size, level-1);
X		right();
X		forward(size);
X		rhilbert(size, level-1);
X		left();
X	}
X}
X
Xrhilbert(size, level)
Xregister int size, level;
X{
X	if (level > 0) {
X		right();
X		lhilbert(size, level-1);
X		forward(size);
X		left();
X		rhilbert(size, level-1);
X		forward(size);
X		rhilbert(size, level-1);
X		left();
X		forward(size);
X		lhilbert(size, level-1);
X		right();
X	}
X}
X
Xmain (argc,argv)
Xint	argc;
Xchar	**argv;
X{
X	int clean();
X
X	ckmgrterm( *argv );
X 	m_setup(0);	
X	signal(SIGTERM,clean);
X	signal(SIGINT,clean);
X	signal(SIGHUP,clean);
X	system("stty litout");
X	m_func(B_SET);
X	/* initialize */
X	start();
X	m_clear();
X	/* draw the hilbert (this is *very* fast) */
X	rhilbert(8, 7);
X	clean();
X}
X
X/* FAST drawing stuff */
X
X#define SIZE	75			/* maximum # of points in a shot */
X#define MAX	7				/* maximum distance */
Xstatic int count = 0;
Xchar buff[1024];	/* grunge buffer */
X
X/* add delta to grunge list */
X
Xint
XLine(dx,dy)
Xregister int dx,dy;
X	{
X	register int mx,my;
X
X	if (dx > MAX || dy > MAX) {
X		mx = (dx>>1);
X		my = (dy>>1);
X	   buff[count++] = (mx+8)<<4 | (my+8);
X		dx = dx-mx;
X		dy = dy-my;
X		}
X
X	buff[count++] = (dx+8)<<4 | (dy+8);
X	if (count >= SIZE)
X		flush();
X
X	}
X
X/* flush pending grunge data */
X
Xint
Xflush()
X	{
X	if (count > 0) {
X		m_rfastdraw(count,buff);
X		count = 0;
X		}
X	}
X
Xclean()
X	{
X	flush();
X	m_flush();
X	system("stty -litout");
X	exit(0);
X	}
END_OF_FILE
# end of 'demo/misc/hilbert.c'
fi
if test -f 'demo/misc/overlayd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/misc/overlayd.c'\"
else
echo shar: Extracting \"'demo/misc/overlayd.c'\" \(3450 characters\)
sed "s/^X//" >'demo/misc/overlayd.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: overlayd.c,v 4.1 88/06/22 14:37:59 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/misc/RCS/overlayd.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/misc/RCS/overlayd.c,v $$Revision: 4.1 $";
X
X/*	overlayd		(S A Uhler)
X *
X *	turn off overlay plane anytime /dev/console gets scrunged (cgfour only)
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <sys/ioctl.h>
X#include <sys/file.h>
X#include <sys/mman.h>
X#include <stdio.h>
X
X#define CONSOLE	 "/dev/console"
X#define DISPLAY	"/dev/fb"
X#define BITS	(1152*900)	/* bits in a plane */
X#define SLEEP	5		/* polling interval */
X
X#define INIT	0	/* ok to init frame buffer */
X#define OK	1	/* frame buffer ok, do it */
X#define BAD	2	/* couldn't get fb, punt */
X
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   struct stat statb;
X   int fd;
X   long mod_time;
X   long now;
X
X   switch (fork()) {
X   default:	/* parent */
X      exit(0);
X   case -1:	/* fork() error */
X      perror( *argv );
X      exit(1);
X   case 0: 	/* child */
X
X      /* fix environment */
X
X      fd = open("/dev/tty");
X      ioctl(fd,TIOCNOTTY,0);
X      close(fd);
X      close(0); close(1); close(2);
X      chdir("/");
X
X      overlay(DISPLAY,0);
X      stat(CONSOLE,&statb);
X      mod_time = statb.st_mtime;
X
X      while(1) {
X         stat(CONSOLE,&statb);
X         sleep(SLEEP);
X         if (mod_time < statb.st_mtime) {
X            mod_time = statb.st_mtime;
X            overlay(DISPLAY,0);
X            }
X         }
X      }
X   }
X
Xstatic int state = INIT;
X
Xoverlay(name,how)
Xchar *name;
Xint how;
X   {
X   int fd;
X   char  *malloc();
X   static int *addr = (int * ) 0;	/* starting address of frame buffer */
X   register int *start,*end;	/* range of addresses to change */
X   int size,temp,pagesize;
X   static int bits = BITS;
X
X   /* open the SUN screen */
X
X   switch(state) {
X      case BAD:
X         return(-1);
X         break;
X      case INIT:				/* first call, get fb */
X         state = BAD;
X         if ((fd = open(name,O_RDWR)) <0) {
X            perror(name);
X            return(-1);
X            }
X
X         /* malloc space for frame buffer  -- overlay and enable planes */
X
X         pagesize = getpagesize();
X         size = bits >> 2;	/* bitplane size in bytes  * 2 */
X         size = (size+pagesize-1) &~ (pagesize-1);	/* round to next page */
X
X         if ((temp = (int) malloc(size+pagesize)) == 0) {
X            perror("malloc");
X            return(-1);
X            }
X   
X         /* align space on a page boundary */
X   
X         addr = (int *)(((unsigned int)temp+pagesize-1) & ~(pagesize-1));
X   
X         /* map the frame buffer into malloc'd space */
X   
X         if (mmap(addr,size,PROT_WRITE,MAP_SHARED,fd,0) < 0) {
X            perror("mmap");
X            free(temp);
X            return(-1);
X            }
X         state = OK;
X         /* no break */
X      case OK:		 /* write data to plane */
X
X         start = addr + 128*1024/4;		/* start of enable plane */
X         end =   start +(bits>>5);		/* end of enable plane */
X
X         while(start < end)
X            *start++ = how;
X      }
X   }
END_OF_FILE
# end of 'demo/misc/overlayd.c'
fi
if test -f 'font-16/Ucmrb8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-16/Ucmrb8'\"
else
echo shar: Extracting \"'font-16/Ucmrb8'\" \(3566 characters\)
sed "s/^X//" >'font-16/Ucmrb8' <<'END_OF_FILE'
Xbegin 644 cmrb8.fnt
XM%@H0!8                 _S_AP'#_@                            
XM        &                     ,                             
XM                                                            
XM                                       #_O\& ^!P?S_G\=P^'^_X
XM<!P_X<!P  V  =P   /@<          #\   !P  ;'\<P<!P!@P         
XM#!P' \#P!@_!X?P^!P        #X  </X'S\/\_P^/^/@?/^^!C/>/C^'P_ 
XM_'\_[_O>_[_G\/A@#X&   P #P  '@ !X #P!P#CP                   
XM      !\&#X  _YS!@=P<'\=QS/^'#_/^' <..' <#X-@ '<   &,'      
XM     _    </\&S?/\/@< P&          P^'P-AF X/@_'X<P^    &  8!
XMW#@'!W#\=AS',?AW!P#AV' 8Q['<=SN'89Q_',<QC',<QG# 8 &!@  8  < 
XM  X  [  < < X< \            &           X!@'!W/^< 8'<'!C'<.#
XM=AP?[_AP'#CC -@<!P?P    !C!P          /    '#_!LVS^#L# 8 P& 
XM       8-@<'<=P.# ?QF',=P   #  # =QL!P=PS'<<!P&8=P< X?!P'<>Q
XMW'<[AW&,?QS',8P^#X#@P# !@\  '  '   .  .P '    ' '           
XM !@          . 8!P_C_A@&!W!P8QW#@W8^/\_X<!PXX           '\]X
XM   #       #P   !P_S_O@_@[!@. .'X&      &'<'!W'<'@P' #!S'<' 
XM<!@  8 8Q@<'<<QSG <#F'<' .'@<!W'\=QW.X=QP!P<P^'\/ ^ X, P 8?@
XM !P_!\!\/@\/X'Q^#P'A_!P]S^!P_ _'X?C_/\_[G/^_Y_#@& <-P_XP!@?P
XM^'\=P<!P?Q_O^' <..           !_-V    8       ^    <&8-CX'P/@
XM #@#@\!@     #!W!P!P.#X/!\ P/AW!P' P/\# ,-\/AW' <Y\'PX!W!P#A
XM\' =Q_'<=SN'8? <',/A_!P' <# & &-L   .X=@_&X=@X#<=P< X? <'^=P
XMV'89P_,8.!W',YP^'<;@X!@'  /^_X8'\/A_'<' <'\_S_AP'#C@        
XM   W;-@  #_@      /@   '!F#8? ,!P  X X_P8      P=P< 8'!N#8?@
XM,!X=P   8   8'#W#X?AP'.?!\. ?P< X?!P'<;QW'X[A\#X'!S#X?P<!P' 
XMP!@!@8    .'<<#N.<.!W'<' .'@'!_G<=QW.<.#@#@=QS.</ S X\ 8 \ #
XM_C &!_#X8QW!@'!_'^_X<!PXX           -VW8   !@      #P   !P  
XMV!X'P_@ . .#P_P '\  8'<' , 8;@''<' _#\   #   ,!P]P^',<!SGP?#
XM_'<' .'P<!_&\=QP.X? /!P<P>'<' <!P, , 8&    /AW' [C_#@=QW!P#A
XM\!P?YW'<=SG#@? X'</C_!P/@<#@& <  _X8'X=P^  =P8!P/C_/^' <..  
XM         #=O>    P      !\       _X>!^;P #@#A^!@     &!W!P&!
XMW/\!QW!P9P?    8/\& <-\/ASG,<YP' [AW!P#A^' ?QG'<<#N'X!P<','!
XMW!X' X# # &!@   'X=QP.XX X'<=P< X? <'^=QW'<YPX#X.QW#X_P<!P' 
XMX!@'  /^  \'<9QC'<, <!P?[_AP'#C@           W9C            ? 
XM      &P_@_NX  8 P& 8!@  8# -@<#,=P.'<=P<&<9P   #  #  # &<<X
XMS'<<!P&X=P<'X?AP'\9QW' _A^&,'!S!P=P^!P. P 8!@8   #O'<<#N. .!
XMW'<' .'X'!SG<=QW.<.#'#L=P^/\'@,#@. 8!P #_@ &!W&<?QW#,' </\_X
XM<!PXX           '\8P           'P   !P !L/X/[N  # 8  & \  / 
XMP#X'!_&8#AV'X'!F'X' < 8 !@!P9AG'./AV',<!^'<'!^'<<QC&,=QP/X=Y
XMW!P/@<&,9P<',, & 8&    [QV#L;AS#@-QW!P#A^!P<YW#8=AG#@XP['<'#
XM_#<& [#@& <  _X !@/C_G\_Y_#X/A_O^' <..           !_#X       
XM    !_    <  ;!\&<;P  8,    /  #P8 <'\?P\!\/ \!P/ \!P'      
XM<#P_[_!P_#_/@/C_CX/#_O\][S#X^!_/N?@^!P'!C/^/A_#X P^!@_X '\? 
XM>#\/A\!\_X^ X_X^/^_X<'P/Q\/X'@_@PYS_A@?P?!@^  /^            
XM   _S_AP'#C@                                    &  #F       
XM !P  8                     P                                
XM   #P                     /^            '    .        !P <  
XM          8        #_@              '^_X<!PXX               
XM    !_                             8                        
XM8                                                           
XM             =P   ?@        < '            <         _X     
XM         #_/^' </^                                          
XM        ,                                                   
XM                                              #X   'P       
XM /@#P           '         /^               ?[_AP'#_@        
XM                                                            
XM                                                            
XM                                                           #
X!_@  
X 
Xend
END_OF_FILE
# end of 'font-16/Ucmrb8'
fi
if test -f 'font-16/Ucour9x16bu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-16/Ucour9x16bu'\"
else
echo shar: Extracting \"'font-16/Ucour9x16bu'\" \(3393 characters\)
sed "s/^X//" >'font-16/Ucour9x16bu' <<'END_OF_FILE'
Xbegin 644 cour9x16bu.fnt
XM%@D0!88              'X_AP.                                 
XM                                                            
XM                                                            
XM                                ' X' X'     /S^' X          
XM       X' X' X'  /P      ,     &&         ,                 
XM                                               'Q@'P        
XM                                   !P,'  <             <#@<#
XM@<    !^/X<#@                #@<#@<#@< !^  &#8; P8!P# P,    
XM    !@P&#X/ 8?@X_CX?    , & ?!X                             
XM          8# #   !@ '   <  X ' & 8X#P          !@         , 
XMP& !(            !P.!P.!P    #\_AP.                 .!P.!P.!
XMP #\  8-AL/RQ-@,& 8"       &$@X8QF#A@,#&8S&   !@ ,#&,QP?@^?C
XM_?X^>Y^/[S>&#8X\?P\?A^?_O>_'>[W?Q@, ,#  &  ,   P &0 , 8!A@# 
XM          &          P# 8,4@            ' X' X'     ?C^' X  
XM               X' X' X'  ?@ !@V&QC),P!@8!@(!@     PS%AC 8>& 
XM@ 9C,8   ,  8,9A! S&8S&$PF8S!@&&(P,(A&8QF8S,9,L8Q)(Q&)#& 8 P
XM>  ,  P  #  8  P   & ,           8         # ,!AK<          
XM   <#@<#@<     _/X<#@                #@<#@<#@<  _  &#8_F UC 
XM,# #&L&     ##,& ,!C88& #&,Q@P&!@  P!F<.#,PC&8# PC,& 89# QC$
XMQC&QC,P@PQC$DAH8@88!@##,  8/#X.A\/'X.SX>#X9@QMFX/&X.V\?GX[GO
XMQW.[W\, P&$9(            !P.!P.!P    'X_AP.                 
XM.!P.!P.!P 'X  8 !L.!L&  , ,/@8     8,P8!@\9A\?@,/C&# 8,#^!@,
XM:0H,S ,9D,C ,P8!AH,#F.3&,;&,QP##&&BZ&@T#!@# ,    !F,QF,QF&!F
XM,P8!AL##;,QF,QF.;&&!F,22,Q&1@@# ( $@            ' X' X'     
XM/S^' X                 X' X' X'  /P !@ &P.!@M@ P P</\ /X !@S
XM!@, 9& 9C!AC'X  !@  #!AI&P^, QGP^, _!@&'@P.H],8_,8^!P,,8:.X,
XM#08& , P     8QL)C,88,8S!@&'@,-LS,,QL8P, 8&8S-8>&8,,   8    
XM           <#@<#@<    !^/X<#@                #@<#@<#@< !^   
XM  _@,-F< # ##8&     ,#,&!@!G\!F,&&,!@  # _@8,&81#,P#&9#(SS,&
XM&8;# VB\QC QC8!@PQAH;!8&# 8 8#     ?C&P&,_!@QC,& 8> PVS,PS&Q
XMC ?!@9AH_@P+!@( P"  #            !P.!P.!P    #\_AP.         
XM        .!P.!P.!P #\    !L8QK8@ , ,(@8     P,P8,#&!C&8PP8P$ 
XM  &  #  8#^,;",9@,#&,P89AL,32)S&,#&,R&##&#!$%@881@!@,    #&,
XM; 8S &#&,P8!AL##;,S#,;&, &&!F'AL'@\, P# 8  2            ' X'
XM X'     ?C^' X                 X' X' X'  ?@ !@ &QC,EF  8!@ !
XM@,  ,& 2!AC,8&,9C#!C P,!@,  8  S,(QF8S&$P&8S!AF&8Q,(C,PP,PS,
XMX,,8,$0C!AC& # P    ,8S&(S&,8&8S!@&&8,-LS&8S&8P,89&8,$0S!AC#
XM ,!@ !(            <#@<#@<     _/X<#@                #@<#@<#
XM@<  _  &  ;'XC3V !@&    P  P8 P?G\? \?#X,#X< P& 8 # ,!YYW\/'
XMX_W@/'N?CP]W]YW$>'@>'N_!X? P1'>/'\8 ,#     >VX/!V/GX/G.?@8YS
XM\VW./#X/G@_ X.PP1'.&'\, P&  $@          ?[_?[_?[_?[_?___[_?[
XM_?[_?[_?[_?[_?[_?[_?[_?[_?__ #_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[
XM_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[
XM_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[
XM_   ' X' X'     /S^' X                 X' X' X'  /P      ,  
XM   &&    (                     !                            
XM    %@             'P 'P              P   ,        P 8      
XM    #  !P,'   P            <#@<#@<    !^/X<#@               
XM #@<#@<#@< !^                  !                      (     
XM                           #@                               
XM>   '@       '@#P          ^                     !P.!P.!P   
XM #\_AP.                 .!P.!P.!P #\                        
XM                                                            
XM                                                            
X(            
X 
Xend
END_OF_FILE
# end of 'font-16/Ucour9x16bu'
fi
if test -f 'font-32/Ucmrb8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-32/Ucmrb8'\"
else
echo shar: Extracting \"'font-32/Ucmrb8'\" \(3566 characters\)
sed "s/^X//" >'font-32/Ucmrb8' <<'END_OF_FILE'
Xbegin 644 cmrb8.fnt
XM& H0!8                 _S_AP'#_@                            
XM        &                     ,                             
XM                                                            
XM                                       #_O\& ^!P?S_G\=P^'^_X
XM<!P_X<!P  V  =P   /@<          #\   !P  ;'\<P<!P!@P         
XM#!P' \#P!@_!X?P^!P        #X  </X'S\/\_P^/^/@?/^^!C/>/C^'P_ 
XM_'\_[_O>_[_G\/A@#X&   P #P  '@ !X #P!P#CP                   
XM      !\&#X  _YS!@=P<'\=QS/^'#_/^' <..' <#X-@ '<   &,'      
XM     _    </\&S?/\/@< P&          P^'P-AF X/@_'X<P^    &  8!
XMW#@'!W#\=AS',?AW!P#AV' 8Q['<=SN'89Q_',<QC',<QG# 8 &!@  8  < 
XM  X  [  < < X< \            &           X!@'!W/^< 8'<'!C'<.#
XM=AP?[_AP'#CC -@<!P?P    !C!P          /    '#_!LVS^#L# 8 P& 
XM       8-@<'<=P.# ?QF',=P   #  # =QL!P=PS'<<!P&8=P< X?!P'<>Q
XMW'<[AW&,?QS',8P^#X#@P# !@\  '  '   .  .P '    ' '           
XM !@          . 8!P_C_A@&!W!P8QW#@W8^/\_X<!PXX           '\]X
XM   #       #P   !P_S_O@_@[!@. .'X&      &'<'!W'<'@P' #!S'<' 
XM<!@  8 8Q@<'<<QSG <#F'<' .'@<!W'\=QW.X=QP!P<P^'\/ ^ X, P 8?@
XM !P_!\!\/@\/X'Q^#P'A_!P]S^!P_ _'X?C_/\_[G/^_Y_#@& <-P_XP!@?P
XM^'\=P<!P?Q_O^' <..           !_-V    8       ^    <&8-CX'P/@
XM #@#@\!@     #!W!P!P.#X/!\ P/AW!P' P/\# ,-\/AW' <Y\'PX!W!P#A
XM\' =Q_'<=SN'8? <',/A_!P' <# & &-L   .X=@_&X=@X#<=P< X? <'^=P
XMV'89P_,8.!W',YP^'<;@X!@'  /^_X8'\/A_'<' <'\_S_AP'#C@        
XM   W;-@  #_@      /@   '!F#8? ,!P  X X_P8      P=P< 8'!N#8?@
XM,!X=P   8   8'#W#X?AP'.?!\. ?P< X?!P'<;QW'X[A\#X'!S#X?P<!P' 
XMP!@!@8    .'<<#N.<.!W'<' .'@'!_G<=QW.<.#@#@=QS.</ S X\ 8 \ #
XM_C &!_#X8QW!@'!_'^_X<!PXX           -VW8   !@      #P   !P  
XMV!X'P_@ . .#P_P '\  8'<' , 8;@''<' _#\   #   ,!P]P^',<!SGP?#
XM_'<' .'P<!_&\=QP.X? /!P<P>'<' <!P, , 8&    /AW' [C_#@=QW!P#A
XM\!P?YW'<=SG#@? X'</C_!P/@<#@& <  _X8'X=P^  =P8!P/C_/^' <..  
XM         #=O>    P      !\       _X>!^;P #@#A^!@     &!W!P&!
XMW/\!QW!P9P?    8/\& <-\/ASG,<YP' [AW!P#A^' ?QG'<<#N'X!P<','!
XMW!X' X# # &!@   'X=QP.XX X'<=P< X? <'^=QW'<YPX#X.QW#X_P<!P' 
XMX!@'  /^  \'<9QC'<, <!P?[_AP'#C@           W9C            ? 
XM      &P_@_NX  8 P& 8!@  8# -@<#,=P.'<=P<&<9P   #  #  # &<<X
XMS'<<!P&X=P<'X?AP'\9QW' _A^&,'!S!P=P^!P. P 8!@8   #O'<<#N. .!
XMW'<' .'X'!SG<=QW.<.#'#L=P^/\'@,#@. 8!P #_@ &!W&<?QW#,' </\_X
XM<!PXX           '\8P           'P   !P !L/X/[N  # 8  & \  / 
XMP#X'!_&8#AV'X'!F'X' < 8 !@!P9AG'./AV',<!^'<'!^'<<QC&,=QP/X=Y
XMW!P/@<&,9P<',, & 8&    [QV#L;AS#@-QW!P#A^!P<YW#8=AG#@XP['<'#
XM_#<& [#@& <  _X !@/C_G\_Y_#X/A_O^' <..           !_#X       
XM    !_    <  ;!\&<;P  8,    /  #P8 <'\?P\!\/ \!P/ \!P'      
XM<#P_[_!P_#_/@/C_CX/#_O\][S#X^!_/N?@^!P'!C/^/A_#X P^!@_X '\? 
XM>#\/A\!\_X^ X_X^/^_X<'P/Q\/X'@_@PYS_A@?P?!@^  /^            
XM   _S_AP'#C@                                    &  #F       
XM !P  8                     P                                
XM   #P                     /^            '    .        !P <  
XM          8        #_@              '^_X<!PXX               
XM    !_                             8                        
XM8                                                           
XM             =P   ?@        < '            <         _X     
XM         #_/^' </^                                          
XM        ,                                                   
XM                                              #X   'P       
XM /@#P           '         /^               ?[_AP'#_@        
XM                                                            
XM                                                            
XM                                                           #
X!_@  
X 
Xend
END_OF_FILE
# end of 'font-32/Ucmrb8'
fi
if test -f 'font-32/Ucour9x16bu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-32/Ucour9x16bu'\"
else
echo shar: Extracting \"'font-32/Ucour9x16bu'\" \(3393 characters\)
sed "s/^X//" >'font-32/Ucour9x16bu' <<'END_OF_FILE'
Xbegin 644 cour9x16bu.fnt
XM& D0!88              'X_AP.                                 
XM                                                            
XM                                                            
XM                                ' X' X'     /S^' X          
XM       X' X' X'  /P      ,     &&         ,                 
XM                                               'Q@'P        
XM                                   !P,'  <             <#@<#
XM@<    !^/X<#@                #@<#@<#@< !^  &#8; P8!P# P,    
XM    !@P&#X/ 8?@X_CX?    , & ?!X                             
XM          8# #   !@ '   <  X ' & 8X#P          !@         , 
XMP& !(            !P.!P.!P    #\_AP.                 .!P.!P.!
XMP #\  8-AL/RQ-@,& 8"       &$@X8QF#A@,#&8S&   !@ ,#&,QP?@^?C
XM_?X^>Y^/[S>&#8X\?P\?A^?_O>_'>[W?Q@, ,#  &  ,   P &0 , 8!A@# 
XM          &          P# 8,4@            ' X' X'     ?C^' X  
XM               X' X' X'  ?@ !@V&QC),P!@8!@(!@     PS%AC 8>& 
XM@ 9C,8   ,  8,9A! S&8S&$PF8S!@&&(P,(A&8QF8S,9,L8Q)(Q&)#& 8 P
XM>  ,  P  #  8  P   & ,           8         # ,!AK<          
XM   <#@<#@<     _/X<#@                #@<#@<#@<  _  &#8_F UC 
XM,# #&L&     ##,& ,!C88& #&,Q@P&!@  P!F<.#,PC&8# PC,& 89# QC$
XMQC&QC,P@PQC$DAH8@88!@##,  8/#X.A\/'X.SX>#X9@QMFX/&X.V\?GX[GO
XMQW.[W\, P&$9(            !P.!P.!P    'X_AP.                 
XM.!P.!P.!P 'X  8 !L.!L&  , ,/@8     8,P8!@\9A\?@,/C&# 8,#^!@,
XM:0H,S ,9D,C ,P8!AH,#F.3&,;&,QP##&&BZ&@T#!@# ,    !F,QF,QF&!F
XM,P8!AL##;,QF,QF.;&&!F,22,Q&1@@# ( $@            ' X' X'     
XM/S^' X                 X' X' X'  /P !@ &P.!@M@ P P</\ /X !@S
XM!@, 9& 9C!AC'X  !@  #!AI&P^, QGP^, _!@&'@P.H],8_,8^!P,,8:.X,
XM#08& , P     8QL)C,88,8S!@&'@,-LS,,QL8P, 8&8S-8>&8,,   8    
XM           <#@<#@<    !^/X<#@                #@<#@<#@< !^   
XM  _@,-F< # ##8&     ,#,&!@!G\!F,&&,!@  # _@8,&81#,P#&9#(SS,&
XM&8;# VB\QC QC8!@PQAH;!8&# 8 8#     ?C&P&,_!@QC,& 8> PVS,PS&Q
XMC ?!@9AH_@P+!@( P"  #            !P.!P.!P    #\_AP.         
XM        .!P.!P.!P #\    !L8QK8@ , ,(@8     P,P8,#&!C&8PP8P$ 
XM  &  #  8#^,;",9@,#&,P89AL,32)S&,#&,R&##&#!$%@881@!@,    #&,
XM; 8S &#&,P8!AL##;,S#,;&, &&!F'AL'@\, P# 8  2            ' X'
XM X'     ?C^' X                 X' X' X'  ?@ !@ &QC,EF  8!@ !
XM@,  ,& 2!AC,8&,9C#!C P,!@,  8  S,(QF8S&$P&8S!AF&8Q,(C,PP,PS,
XMX,,8,$0C!AC& # P    ,8S&(S&,8&8S!@&&8,-LS&8S&8P,89&8,$0S!AC#
XM ,!@ !(            <#@<#@<     _/X<#@                #@<#@<#
XM@<  _  &  ;'XC3V !@&    P  P8 P?G\? \?#X,#X< P& 8 # ,!YYW\/'
XMX_W@/'N?CP]W]YW$>'@>'N_!X? P1'>/'\8 ,#     >VX/!V/GX/G.?@8YS
XM\VW./#X/G@_ X.PP1'.&'\, P&  $@          ?[_?[_?[_?[_?___[_?[
XM_?[_?[_?[_?[_?[_?[_?[_?[_?__ #_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[
XM_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[
XM_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[_?[
XM_   ' X' X'     /S^' X                 X' X' X'  /P      ,  
XM   &&    (                     !                            
XM    %@             'P 'P              P   ,        P 8      
XM    #  !P,'   P            <#@<#@<    !^/X<#@               
XM #@<#@<#@< !^                  !                      (     
XM                           #@                               
XM>   '@       '@#P          ^                     !P.!P.!P   
XM #\_AP.                 .!P.!P.!P #\                        
XM                                                            
XM                                                            
X(            
X 
Xend
END_OF_FILE
# end of 'font-32/Ucour9x16bu'
fi
if test -f 'lib/dump.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/dump.h'\"
else
echo shar: Extracting \"'lib/dump.h'\" \(3420 characters\)
sed "s/^X//" >'lib/dump.h' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: dump.h,v 4.2 88/07/20 15:16:24 sau Exp $
X	$Source: /tmp/mgrsrc/lib/RCS/dump.h,v $
X*/
Xstatic char	h_dump_[] = "$Source: /tmp/mgrsrc/lib/RCS/dump.h,v $$Revision: 4.2 $";
X/* format for saved bitmaps */
X
X#define B_HSIZE		(sizeof(struct b_header))
X#define B_OHSIZE		(sizeof(struct old_b_header))
X
X#define NEW_BHDR	1	/* flag for bitmapwrite */
X#define OLD_BHDR	0	/* " */
X
X/* given bitmap header, get w[idth] and h[eight] */
X
X#define B_GETOLDHDR(hdr,W,H) ( \
X	W = ((int)((hdr)->h_wide - ' ') << 6) + (hdr)->l_wide - ' ', \
X	H = ((int)((hdr)->h_high - ' ') << 6) + (hdr)->l_high - ' ')
X
X#define B_GETHDR8(hdr,W,H,D) ( \
X	W = ((int)((hdr)->h_wide - ' ') << 6) + (hdr)->l_wide - ' ', \
X	H = ((int)((hdr)->h_high - ' ') << 6) + (hdr)->l_high - ' ', \
X	D = ((int)((hdr)->depth - ' ')))
X
X/* given w[idth] and h[eight], produce header */
X
X#define B_PUTOLDHDR(hdr,w,h) \
X	(hdr)->magic[0]='z', (hdr)->magic[1]='z', \
X	(hdr)->h_wide = (((w)>>6)&0x3f) + ' ', \
X	(hdr)->l_wide = ((w)&0x3f) + ' ', \
X	(hdr)->h_high = (((h)>>6)&0x3f) + ' ', \
X	(hdr)->l_high = ((h)&0x3f) + ' '
X#define B8_PUTOLDHDR(hdr,w,h) \
X	(hdr)->magic[0]='z', (hdr)->magic[1]='y', \
X	(hdr)->h_wide = (((w)>>6)&0x3f) + ' ', \
X	(hdr)->l_wide = ((w)&0x3f) + ' ', \
X	(hdr)->h_high = (((h)>>6)&0x3f) + ' ', \
X	(hdr)->l_high = ((h)&0x3f) + ' '
X
X#define B_PUTHDR8(hdr,w,h,d) ( \
X	(hdr)->magic[0]='y', (hdr)->magic[1]='z', \
X	(hdr)->h_wide = (((w)>>6)&0x3f) + ' ', \
X	(hdr)->l_wide = ((w)&0x3f) + ' ', \
X	(hdr)->h_high = (((h)>>6)&0x3f) + ' ', \
X	(hdr)->l_high = ((h)&0x3f) + ' ', \
X	(hdr)->depth = ((d)&0x3f) + ' ', \
X	(hdr)->_reserved = ' ' )
X
X
X/*	Bitmap header magic numbers for 1-bit-deep bitmaps with
X	8, 16, and 32 bit padding.
X	16 and 32 bit padding are ancient history, but still acknowledged.
X*/
X#define B_ISHDR8(hdr)	((hdr)->magic[0]=='y' && (hdr)->magic[1]=='z')
X
X#define B_ISHDR16(hdr) \
X	((hdr)->magic[0]=='z' && (hdr)->magic[1]=='z')
X#define B_ISHDR32(hdr) \
X	((hdr)->magic[0]=='x' && (hdr)->magic[1]=='z')
X
X#ifdef ALIGN32
X#define B_ISHDR(hdr)	B_ISHDR32(hdr)
X#define B8_ISHDR(hdr) \
X	((hdr)->magic[0]=='x' && (hdr)->magic[1]=='y')
X#else
X#define B_ISHDR(hdr)	B_ISHDR16(hdr)
X#define B8_ISHDR(hdr) \
X	((hdr)->magic[0]=='z' && (hdr)->magic[1]=='y')
X#endif
X
X/*
X	#ifdef COLOR
X	#define B_ISANY(hdr) \
X		(B_ISHDR(hdr) || B8_ISHDR(hdr))
X	#else
X	#define B_ISANY(hdr)	B_ISHDR(hdr)
X	#endif
X*/
X
X/* number of bytes of data for bitmap */
X
X#define B_SIZE8(w,h,d)	((h)*((((w*d)+7L)&~7L)>>3))
X#define B_SIZE16(w,h,d)	((h)*((((w*d)+15L)&~15L)>>3))
X#define B_SIZE32(w,h,d)	((h)*((((w*d)+31L)&~31L)>>3))
X#define B_SIZE(w,h)	((h)*((((w)+BITS)&~BITS)>>3))
X#define B8_SIZE(w,h)	((h)*(w))
X
Xstruct old_b_header {
X   char magic[2];
X   char h_wide;
X   char l_wide;
X   char h_high;
X   char l_high;
X   };
X
Xstruct b_header {
X   char magic[2];
X   char h_wide;
X   char l_wide;
X   char h_high;
X   char l_high;
X   char depth;
X   char _reserved;	/* to pad b_header out to 8 bytes, which should be an
X			exact alignment on any machine we are likely to
X			encounter */
X   };
END_OF_FILE
# end of 'lib/dump.h'
fi
if test -f 'misc/tjfilter.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/tjfilter.c'\"
else
echo shar: Extracting \"'misc/tjfilter.c'\" \(3520 characters\)
sed "s/^X//" >'misc/tjfilter.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/* graphics print filter for hp think jet printer (mgr format) */
X/* version 2 - eliminate trailing white space */
X/* version 3 - rotate fat pictures */
X
X/*	$Header: tjfilter.c,v 1.3 88/08/24 10:36:59 bianchi Exp $
X	$Source: /tmp/mgrsrc/misc/RCS/tjfilter.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/misc/RCS/tjfilter.c,v $$Revision: 1.3 $";
X
X#include <stdio.h>
X#include "dump.h"
X#include <sgtty.h>
X
X#define MAX	640		/* maximum dots per line */
X#define START	"\033*rA"	/* start graphics */
X#define COUNT	"\033*b%dW"	/* bytes on this line */
X#define END	"\033*rB\n"	/* end graphics */
X#define LOW	"\033*640S"	/* low density print mode */
X
Xchar buff[MAX];
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   register int byteno;				/* byte number */
X   register char *pntr;
X   int mode;					/* tty local modes */
X   int reverse = 0;				/* reverse bits */
X   int rotate = 0;				/* rotate bitmap */
X   int w,h,d;					/* bitmap size */
X   int bytes;					/* bytes/line of bitmap */
X   int lastbyte;				/* last significant byte */
X   unsigned char mask;				/* to mask last byte */
X   char mask1;					/* to mask last byte */
X   int speed=0;					/* set speed to 9600 baud */
X   int clean();
X   char *sprintf();
X   FILE *input, *popen();			/* for rotate filter */
X
X   if (argc>1 && strcmp(argv[1],"-r")==0)
X      reverse++;
X   else if (argc>1 && strcmp(argv[1],"-s")==0)
X      speed++;
X
X   if (argc>2 && strcmp(argv[2],"-r")==0)
X      reverse++;
X   else if (argc>2 && strcmp(argv[2],"-s")==0)
X      speed++;
X
X   if (!bitmaphead( stdin, &w, &h, &d, &bytes )) {
X      fprintf(stderr,"%s: invalid bitmap format \n",*argv);
X      exit(2);
X      }
X
X   /* rotate bitmap, if short and fat */
X
X   if (w>MAX && h<MAX && 
X            (input = popen(sprintf(buff,"rotate -w %d -h %d",w,h),"r"))) {
X      rotate++;
X      if (!bitmaphead( stdin, &w, &h, &d, &bytes )) {
X         fprintf(stderr,"%s: invalid bitmap format \n",*argv);
X         exit(2);
X         }
X      }
X   else
X      input = stdin;
X      
X
X   mask = w%8 ? 0xff >> (w%8) : 0;
X   mask1 = ~(mask & 0xff);
X   lastbyte = w/8;
X
X   /* set up the printer */
X
X   ioctl(1,TIOCLGET,&mode);
X   mode |= LLITOUT;
X   ioctl(1,TIOCLSET,&mode);
X   if (speed)
X      set_speed(1,B9600);
X
X   printf(LOW);
X   printf(START);
X
X   while (fread(buff,bytes,1,input) > 0)  {
X      if (reverse)
X         invert(buff,bytes);
X      buff[lastbyte] &= mask1;
X      for(byteno=lastbyte, pntr=buff+byteno; byteno>=0; byteno--)
X         if (*pntr--)
X            break;
X      printf(COUNT,byteno+1);
X      fwrite(buff,byteno+1,1,stdout);
X      }
X
X   printf(END);
X   mode &= ~LLITOUT;
X   /* ioctl(1,TIOCLSET,&mode); */
X   if (rotate)
X      pclose(input);
X   exit(0);
X   }
X
X/* invert each bit */
X
Xinvert(data,count)
Xregister unsigned char *data;
Xint count;
X   {
X   register unsigned char *end = data + count;
X
X   while(data < end)
X      *data++ = ~*data;
X   }
X
X
X/*
X *	Set the terminal speed 
X */
X
Xset_speed(file,speed)
Xint file;		/* file pointer */
Xint speed;
X{
X	struct sgttyb buff;
X
X	gtty(file,&buff);
X	buff.sg_ospeed  = speed;
X	buff.sg_ispeed  = speed;
X	stty(file,&buff);
X        return(0);
X}
END_OF_FILE
# end of 'misc/tjfilter.c'
fi
if test -f 'src/blit/bitmap.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/blit/bitmap.h'\"
else
echo shar: Extracting \"'src/blit/bitmap.h'\" \(3558 characters\)
sed "s/^X//" >'src/blit/bitmap.h' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: bitmap.h,v 4.2 88/07/19 14:17:18 sau Exp $
X	$Source: /tmp/mgrsrc/src/blit/RCS/bitmap.h,v $
X*/
Xstatic char	h_bitmap_[] = "$Source: /tmp/mgrsrc/src/blit/RCS/bitmap.h,v $$Revision: 4.2 $";
X
X/* header file for SUN bitmap operations */
X
X#ifndef Min
X#define Min(x,y)	((x)>(y)?y:x)
X#endif
X
Xtypedef int *DATA;
X
X#define bit_blit(dest,dx,dy,width,height,func,source,sx,sy)  \
X	mem_rop(dest,dx,dy,width,height,func,source,sx,sy) 
X
X#define bit_static(name,wide,high,data,n)	\
X	BITMAP name = {(DATA) data, &name, 0, 0, wide, high, _STATIC};
X#define NULL_DATA	((DATA) 0)
X
X#define BIT_NULL	((BITMAP *) 0)
X
X#define IS_SCREEN(x)	((x)->type==_SCREEN)
X#define IS_MEMORY(x)	((x)->type==_MEMORY)
X#define IS_PRIMARY(x)	((x)->primary == (x))
X
X/*
X * OPCODE(expr), where expr is boolean expression involving SRC and DST,
X * is one of sixteen numbers encoding a rasterop opcode.
X */
X
X#define			DST 	0xA	/* 1010 */ /* same as f_dest */
X#define			SRC	0xC	/* 1100 */ /* same as f_source */
X#define OPCODE(expr)	(0xF&(expr))
X
X/* names for common bitblit functions */
X
X#ifndef BIT_NOT
X#   define BIT_NOT(x)	(~(x))
X#endif
X#define BIT_SRC		SRC
X#define BIT_DST		DST
X#define BIT_SET		(BIT_SRC|BIT_NOT(BIT_SRC))
X#define BIT_CLR		(BIT_SRC&BIT_NOT(BIT_SRC))
X#define BIT_XOR		(BIT_SRC^BIT_DST)
X#define BIT_INVERT	(BIT_NOT(DST))
X#define GET_OP(x)	((x)&0xf)
X
X/* change rop function for white-on-black */
X
X#define ROP_INVERT(x)	GET_OP(rev_ops[0xf&(x)])
X
X/* bitmap types */
X
X#define _SCREEN		1		/* frame buffer */
X#define _MEMORY		2		/* malloc'd space */
X#define _STATIC		3		/* don't free space at destroy time */
X
X/* member access macros */
X
X#define BIT_X(x)	x->x0
X#define BIT_Y(x)	x->y0
X#define BIT_DATA(x)	x->data
X#define BIT_WIDE(x)	x->wide
X#define BIT_HIGH(x)	x->high
X#define BIT_DEPTH(x)	1		/* no color support for now */
X
X
X/* bit mask for bitmap data padding */
X
X#define BITS	31L
X
X/* BIT_SIZE(map) == the number of chars needed to store the data of the bitmap.
X   Usually used with malloc(3).
X*/
X
X#define BIT_SIZE(m)     BIT_Size(BIT_WIDE(m), BIT_HIGH(m), BIT_DEPTH(m)) /* bytes */
X
X/* BIT_Size(wide,high,depth) = the number of chars needed to store the data of a
X   bitmap of the given number of bits wide high and deep.
X	   Typical usage:
X		char	bitbuffer[ Bit_Size(16,16,1) ];
X*/
X
X#define BIT_Size(wide,high,d)     ((d)*((wide+BITS)&~BITS)*high>>3) /* bytes */
X
X#define BIT_LINE(x)     ((x->primary->wide+BITS)&~BITS) /* lng aligned (bits)*/
X
X/* structure and type definitions */
X
Xtypedef struct bitmap {
X   DATA	data;		/* bitmap data */
X   struct bitmap	*primary;	/* pointer to primary bitmap */
X   short		x0, y0;		/* starting coordinates, in bits.
X					            0, 0  ==  upper left corner of screen */
X   short		wide, high;	/* bitmap size, in bits */
X   unsigned short	type;		/* bitmap type */
X   } BITMAP;
X
X/* function declarations */
X
Xint mem_rop();
Xint bit_destroy();
Xint bit_line();
XBITMAP * bit_create();
XBITMAP * bit_alloc();
XBITMAP * bit_open();
X
X/* for non existant color support */
X
X#define DEPTH				1			/* bits per pixel */
X#define NOCOLOR         0xF
X#define GETCOLOR(x)     0
X#define PUTCOLOR(x)     0
X
X/* other */
X
X#define Bprintf(x)	/* gone */
END_OF_FILE
# end of 'src/blit/bitmap.h'
fi
if test -f 'src/oblit/bitmap.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/oblit/bitmap.h'\"
else
echo shar: Extracting \"'src/oblit/bitmap.h'\" \(3547 characters\)
sed "s/^X//" >'src/oblit/bitmap.h' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: bitmap.h,v 4.2 88/07/19 14:19:23 sau Exp $
X	$Source: /tmp/mgrsrc/src/oblit/RCS/bitmap.h,v $
X*/
Xstatic char	h_bitmap_[] = "$Source: /tmp/mgrsrc/src/oblit/RCS/bitmap.h,v $$Revision: 4.2 $";
X
X/* header file for SUN bitmap operations */
X
X#ifndef Min
X#define Min(x,y)	((x)>(y)?y:x)
X#endif
X
Xtypedef unsigned short *DATA;
X
X#define bit_blit(dest,dx,dy,width,height,func,source,sx,sy)  \
X	mem_rop(dest,dx,dy,width,height,func,source,sx,sy) 
X
X#define bit_static(name,wide,high,data,n)	\
X	BITMAP name = {(DATA) data, &name, 0, 0, wide, high, _STATIC};
X#define NULL_DATA	((DATA) 0)
X
X#define BIT_NULL	((BITMAP *) 0)
X
X#define IS_SCREEN(x)	((x)->type==_SCREEN)
X#define IS_MEMORY(x)	((x)->type==_MEMORY)
X#define IS_PRIMARY(x)	((x)->primary == (x))
X
X/*
X * OPCODE(expr), where expr is boolean expression involving SRC and DST,
X * is one of sixteen numbers encoding a rasterop opcode.
X */
X
X#define			DST 	0xA	/* 1010 */ /* same as f_dest */
X#define			SRC	0xC	/* 1100 */ /* same as f_source */
X#define OPCODE(expr)	(0xF&(expr))
X
X/* names for common bitblit functions */
X
X#ifndef BIT_NOT
X#   define BIT_NOT(x)	(~(x))
X#endif
X#define BIT_SRC		SRC
X#define BIT_DST		DST
X#define BIT_SET		(BIT_SRC|BIT_NOT(BIT_SRC))
X#define BIT_CLR		(BIT_SRC&BIT_NOT(BIT_SRC))
X#define BIT_XOR		(BIT_SRC^BIT_DST)
X#define BIT_INVERT	(BIT_NOT(DST))
X#define GET_OP(x)	((x)&0xf)
X
X/* change rop function for white-on-black */
X
X#define ROP_INVERT(x)	GET_OP(rev_ops[0xf&(x)])
X
X/* bitmap types */
X
X#define _SCREEN		1		/* frame buffer */
X#define _MEMORY		2		/* malloc'd space */
X#define _STATIC		3		/* don't free space at destroy time */
X
X/* member access macros */
X
X#define BIT_X(x)	x->x0
X#define BIT_Y(x)	x->y0
X#define BIT_DATA(x)	x->data
X#define BIT_WIDE(x)	x->wide
X#define BIT_HIGH(x)	x->high
X#define BIT_DEPTH(x)	1		/* no color support for now */
X
X
X/* bit mask for bitmap data padding */
X
X#define BITS	15L
X
X/* BIT_SIZE(map) == the number of chars needed to store the data of the bitmap.
X   Usually used with malloc(3).
X*/
X
X#define BIT_SIZE(m)     BIT_Size(BIT_WIDE(m), BIT_HIGH(m), BIT_DEPTH(m)) /* bytes */
X
X/* BIT_Size(wide,high,depth) = the number of chars needed to store the data of a
X   bitmap of the given number of bits wide high and deep.
X	   Typical usage:
X		char	bitbuffer[ Bit_Size(16,16,1) ];
X*/
X
X#define BIT_Size(wide,high,d)     ((d)*((wide+BITS)&~BITS)*high>>3) /* bytes */
X
X#define BIT_LINE(x)	((x->primary->wide+BITS)>>4) /* short aligned (shorts) */
X
X/* structure and type definitions */
X
Xtypedef struct bitmap {
X   DATA	data;		/* bitmap data */
X   struct bitmap	*primary;	/* pointer to primary bitmap */
X   short		x0, y0;		/* starting coordinates, in bits.
X					0, 0  ==  upper left corner */
X   short		wide, high;	/* bitmap size, in bits */
X   unsigned short	type;		/* bitmap type */
X   } BITMAP;
X
X/* function declarations */
X
Xint mem_rop();
Xint bit_destroy();
Xint bit_line();
XBITMAP * bit_create();
XBITMAP * bit_alloc();
XBITMAP * bit_open();
X
X/* for non existant color support */
X
X#define DEPTH				1			/* bits per pixel */
X#define NOCOLOR         0xF
X#define GETCOLOR(x)     0
X#define PUTCOLOR(x)     0
X
X/* other */
X
X#define Bprintf(x)	/* gone */
END_OF_FILE
# end of 'src/oblit/bitmap.h'
fi
if test -f 'src/shape.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/shape.c'\"
else
echo shar: Extracting \"'src/shape.c'\" \(3509 characters\)
sed "s/^X//" >'src/shape.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: shape.c,v 4.1 88/06/21 13:34:38 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/RCS/shape.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/shape.c,v $$Revision: 4.1 $";
X
X/* re-shape a window */
X
X#include "bitmap.h"
X#include <stdio.h> 	/* temporary */
X#include "defs.h"
X#include "font.h"
X#include "event.h"
X
X#define FSIZE(c)	((int) (ACTIVE(font)->head.c))
X
X/* reshape a window with the mouse */
X
Xint shape_window()
X   {
X   int dx=16 ,dy=16 ;
X
X   SETMOUSEICON(&mouse_box);
X   move_mouse(screen,mouse,&mousex,&mousey,0);
X   SETMOUSEICON(&mouse_arrow);
X   get_rect(screen,mouse,mousex,mousey,&dx,&dy,0);
X   do_button(0);
X
X   /* look for shape event here */
X
X   do_event(EVENT_SHAPE,active,E_MAIN);
X
X   return(shape(mousex,mousey,dx,dy));
X   }
X
X/* reshape a window to specified dimentions */
X
Xint
Xshape(x,y,dx,dy)
Xint x,y,dx,dy;
X   {
X   int sx,sy,w,h;
X   register WINDOW *win;
X   register int i;
X
X   if (dx>0) {
X      sx= x; w = dx;
X      }
X   else {
X      sx= x+dx; w = -dx;
X      }
X   if (dy>0) {
X      sy= y; h = dy;
X      }
X   else {
X      sy= y+dy; h = -dy;
X      }
X
X   if (sx < 0) sx = 0;
X   
X   if (sx + w >= BIT_WIDE(screen))
X      w = BIT_WIDE(screen) - sx;
X
X   if (sy + h >= BIT_HIGH(screen))
X      h = BIT_HIGH(screen) - sy;
X
X   if (w < SUM_BDR + ACTIVE(font)->head.wide*MIN_X +1 ||
X       h < SUM_BDR + ACTIVE(font)->head.high*MIN_Y +1)
X       return(-1);
X
X#ifdef ALIGN
X   alignwin(screen,&sx,&w,SUM_BDR);
X#endif
X
X   /* remove current window position */
X
X   save_win(active);
X   erase_win(ACTIVE(border));
X   clip_bad(active);	/* invalidate clip lists */
X
X   /* redraw remaining windows */
X
X   repair(active);
X
X   /* adjust window state */
X
X   ACTIVE(x0) = sx;
X   ACTIVE(y0) = sy;
X   bit_destroy(ACTIVE(window));
X   bit_destroy(ACTIVE(border));
X   ACTIVE(border) = bit_create(screen,sx,sy,w,h);
X   ACTIVE(window) = bit_create(ACTIVE(border),
X                    SUM_BDR,SUM_BDR,w-SUM_BDR*2,h-SUM_BDR*2);
X
X   for(win=ACTIVE(next);win != (WINDOW *) 0;win=W(next)) {
X      if (W(flags)&W_ACTIVE && intersect(active,win))
X         save_win(win);
X      }
X
X   CLEAR(ACTIVE(window),ACTIVE(background));
X
X   border(active,BLK_BDR,WH_BDR);
X   bit_blit(ACTIVE(border),0,0,BIT_WIDE(ACTIVE(save))-SUM_BDR,
X          BIT_HIGH(ACTIVE(save))-SUM_BDR,BIT_SRC,ACTIVE(save),0,0);
X
X   /* make sure character cursor is in a good spot */
X
X   if (ACTIVE(x) > BIT_WIDE(ACTIVE(window))) {
X      ACTIVE(x) = 0;
X      ACTIVE(y) += FSIZE(high);
X      }
X   if (ACTIVE(y) > BIT_HIGH(ACTIVE(window))) {
X#ifdef WIERD
X      ACTIVE(y) = BIT_HIGH(ACTIVE(window));
X      scroll(ACTIVE(window),0,BIT_HIGH(ACTIVE(window)),
X             FSIZE(high),ACTIVE(background));
X      bit_blit(ACTIVE(window),0,BIT_HIGH(ACTIVE(window))-FSIZE(high),
X               BIT_WIDE(ACTIVE(save)),FSIZE(high),BIT_SRC,
X               ACTIVE(save),SUM_BDR,BIT_HIGH(ACTIVE(save))-FSIZE(high)-SUM_BDR);
X#else
X      ACTIVE(y) = BIT_HIGH(ACTIVE(window))-FSIZE(high);
X#endif
X      }
X
X   bit_destroy(ACTIVE(save));
X   ACTIVE(save) = (BITMAP *) 0;
X
X	clip_bad(active);					/* invalidate clip lists */
X   un_covered();
X   return(0);
X   }
END_OF_FILE
# end of 'src/shape.c'
fi
if test -f 'src/utmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/utmp.c'\"
else
echo shar: Extracting \"'src/utmp.c'\" \(3465 characters\)
sed "s/^X//" >'src/utmp.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: utmp.c,v 4.1 88/06/21 13:34:52 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/RCS/utmp.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/utmp.c,v $$Revision: 4.1 $";
X
X/* manage utmp file */
X
X#include <pwd.h>
X#include <utmp.h>
X#include <sys/file.h>
X#include <sys/time.h>
X#include <stdio.h>
X
X#define UTMP	"/etc/utmp"
X#define TTYS	"/etc/ttys"
X
Xstatic struct utmp	entry, save_entry;
Xstatic char		zap[sizeof(entry)];
Xstatic int		save_slot;
X
X/* remove an entry from utmp file */
X
Xint
Xrm_utmp(line)	
Xchar *line;
X   {
X   return(_rm_utmp(line,0));
X   }
X
X/* remove and save an entry in the utmp file */
X
Xint
Xsave_utmp(line)
Xchar *line;
X   {
X   return(_rm_utmp(line,1));
X   }
X
X/* add an entry to the utmp file */
X
Xint
Xadd_utmp(fd,host)
Xint fd;
Xchar *host;
X   {
X   return(_add_utmp(fd,host,0));
X   }
X
X/* restore a previously saved utmp file entry */
X
Xint
Xrestore_utmp(fd,host)
Xint fd;
Xchar *host;
X   {
X   return(_add_utmp(fd,host,1));
X   }
X
X/* defined here so we needn't include defs.h */
X
X#ifdef SYSV
X#define index		strchr
X#define rindex		strrchr
X#endif
X
X/* utmp add-entry service routine */
X
Xint
X_add_utmp(fd,host,flag)
Xint fd;
Xchar *host;
Xint flag;
X   {
X   char *ttyname(), *rindex();
X   long time();
X   struct passwd *getpwuid();
X   struct timeval tp;
X   char *line = ttyname(0);
X   int tty;
X   int tell;
X
X   if ((fd = open(UTMP,O_RDWR)) >= 0) {
X      if (flag) {
X         lseek(fd,(long) (save_slot*sizeof(entry)),0);
X         write(fd,&save_entry,sizeof(entry));
X         }
X      else if (line && (tty=ttyslot())) {
X
X         lseek(fd,(long) (tty*sizeof(entry)),0);
X         if (rindex(line,'/'))
X            line = rindex(line,'/')+1;
X
X         strncpy(entry.ut_line, line, sizeof entry.ut_line);
X         strncpy(entry.ut_name, getpwuid(getuid())->pw_name,
X		sizeof entry.ut_name);
X         if (host == (char *) 0)
X            strcpy(entry.ut_host, "");
X         else
X            strncpy(entry.ut_host, host, sizeof entry.ut_host);
X         gettimeofday(&tp,0);
X         entry.ut_time = tp.tv_sec;
X      
X         write(fd,&entry,sizeof(entry));
X         }
X      close(fd);
X      return(tty);
X      }
X   return(-1);
X   }
X
X/* remove utmp entry service routine */
X
Xint
X_rm_utmp(line,flag)
Xchar *line;
Xint flag;
X   {
X   int tty;
X   int fd;
X   FILE *file;
X   char *fgets(), *rindex();
X   char buff[32];
X   int neof = 0;
X
X   /* find ttyslot */
X
X   if (line == (char *) 0) 
X      return(-1);
X
X   if (rindex(line,'/'))
X      line = rindex(line,'/')+1;
X
X   if (file = fopen(TTYS,"r")) {
X      for(tty=1; neof = fgets(buff,sizeof(buff),file) != NULL;tty++)
X         if (strncmp(line,buff+2,strlen(line)) == 0) break;
X      fclose(file);
X      }
X   else {
X      return(-2);
X      }
X      
X   /* zap utmp entry */
X
X   if ( neof &&(fd = open(UTMP,O_RDWR))>=0) {
X      lseek(fd,(long) (tty*sizeof(entry)),0);
X      if (flag) {
X	 save_slot = tty;
X         read(fd,&save_entry,sizeof(entry));
X         lseek(fd,(long) (tty*sizeof(entry)),0);
X         }
X      write(fd,zap,sizeof(entry));
X      close(fd);
X      return(tty);
X      }
X   return(-1);
X   }
END_OF_FILE
# end of 'src/utmp.c'
fi
echo shar: End of archive 17 \(of 61\).
cp /dev/null ark17isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
