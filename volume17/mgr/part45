Subject:  v17i046:  MGR, Bellcore window manager, Part45/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 46
Archive-name: mgr/part45




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 45 (of 61)."
# Contents:  src/oblit/blit.c
#   icon/Uthinker icon/Utombstone icon/Uumbrella icon/Uveye1
#   icon/Uveye2 icon/Uveye3 icon/Uweird_thing icon/Uyieldsign
#   icon/eye/Ueye icon/eye/Ueye1 icon/eye/Ueye10 icon/eye/Ueye11
#   icon/eye/Ueye12 icon/eye/Ueye13 icon/eye/Ueye14 icon/eye/Ueye15
#   icon/eye/Ueye16 icon/eye/Ueye17 icon/eye/Ueye18 icon/eye/Ueye19
#   icon/eye/Ueye2 icon/eye/Ueye20 icon/eye/Ueye21 icon/eye/Ueye22
#   icon/eye/Ueye23 icon/eye/Ueye24 icon/eye/Ueye3 icon/eye/Ueye4
#   icon/eye/Ueye5 icon/eye/Ueye6 icon/eye/Ueye7 icon/eye/Ueye8
#   icon/eye/Ueye9 menu/Makefile menu/README misc/termcap
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:54 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'icon/Uthinker' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/Uthinker'\"
else
echo shar: Extracting \"'icon/Uthinker'\" \(210 characters\)
sed "s/^X//" >'icon/Uthinker' <<'END_OF_FILE'
Xbegin 644 thinker
XM>GH@.B! /@   '\   !'@   HX   (.   !!P   (+   'P(  "4!   E%( 
XM $I)   F(8  $O%  !^!(  @ B  (_P@ !P (  0 $  ( .P "&=7  0:JH 
XL"#57 !XJJP U%56 :HJJ@%5A58!JL*K 56=50&K*JL!5=56 :JJO #__^   
X 
Xend
END_OF_FILE
# end of 'icon/Uthinker'
fi
if test -f 'icon/Utombstone' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/Utombstone'\"
else
echo shar: Extracting \"'icon/Utombstone'\" \(212 characters\)
sed "s/^X//" >'icon/Utombstone' <<'END_OF_FILE'
Xbegin 644 tombstone
XM>GH@0"!   _P  !P#@ !@ &  @  0 0  " (   0$   "!    @CX8^$(S&,
XMQ",QC,1#X8^"0S&, D,QC )#-:Q"0    D    ) __\"0    D#__P)    "
XL0/__ D    )    "0    D    )    "0    D    )    "0    G____X"
X 
Xend
END_OF_FILE
# end of 'icon/Utombstone'
fi
if test -f 'icon/Uumbrella' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/Uumbrella'\"
else
echo shar: Extracting \"'icon/Uumbrella'\" \(211 characters\)
sed "s/^X//" >'icon/Uumbrella' <<'END_OF_FILE'
Xbegin 644 umbrella
XM>GH@0"!   "     @   #_@  '__  '__\ #___@!___\ ____@/___X'___
XM_!____P8X<.,$$"!!   @    (    "     @    (    "     @    (  
XL  "     @    (    "     @    <    '(   !W    ?P   '\    ^   
X 
Xend
END_OF_FILE
# end of 'icon/Uumbrella'
fi
if test -f 'icon/Uveye1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/Uveye1'\"
else
echo shar: Extracting \"'icon/Uveye1'\" \(296 characters\)
sed "s/^X//" >'icon/Uveye1' <<'END_OF_FILE'
Xbegin 644 veye1
XM>GH@4"!                     !_      . X     P &    !  !    "
XM   @   $   0   (!5 (   ("J@(   0%50$  '@*^H"  ( 5[4"X!X +]H1
XMX!XX5_4)X!T@+_H)X!T@5_42<#B0*^HD<#B0%50D<#D("JA(.'$(!5"$.'$,
XM  "$.'#R  "$'. !@ !X'.  8<. '.  $B0 #\  $?X #\  " ( #\  " ( 
X2!X  !^, !X   )* !X   'T 
X 
Xend
END_OF_FILE
# end of 'icon/Uveye1'
fi
if test -f 'icon/Uveye2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/Uveye2'\"
else
echo shar: Extracting \"'icon/Uveye2'\" \(208 characters\)
sed "s/^X//" >'icon/Uveye2' <<'END_OF_FILE'
Xbegin 644 veye2
XM>GH@0"!   XX   $$   !=   #06  #"(8 ! 4!  @" ( 0  ! (!5 (" JH
XM"! 55 0@*^H"(%>U D0OVA%(5_4)2"_Z"217]1(2*^HD$A54) D*J$@0A5"$
XL$(  A!"  (0/  !X .'#@  2)   $B0  !(D   2)   (4(  $"!   _?@"$
X 
Xend
END_OF_FILE
# end of 'icon/Uveye2'
fi
if test -f 'icon/Uveye3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/Uveye3'\"
else
echo shar: Extracting \"'icon/Uveye3'\" \(208 characters\)
sed "s/^X//" >'icon/Uveye3' <<'END_OF_FILE'
Xbegin 644 veye3
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (  5("  *
XMJ!..%501!"OL$017M!$$+]P1!%?T$00O_!"(5_004"OL"" 56 @ "J@$  50
XL @  ( $  $  P &  " .   0\   "2    D@   )]@  "@V  ! "0  __L!0
X 
Xend
END_OF_FILE
# end of 'icon/Uveye3'
fi
if test -f 'icon/Uweird_thing' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/Uweird_thing'\"
else
echo shar: Extracting \"'icon/Uweird_thing'\" \(214 characters\)
sed "s/^X//" >'icon/Uweird_thing' <<'END_OF_FILE'
Xbegin 644 weird_thing
XM>GH@0"!  !YX  !AA@  @ $  0?@@ (  $ "!F! !$F2( 2H%2 %*92@!2?D
XMH 4@!* %* 2@!2ODH 4L!* %* 2@!* %( A@!A 04 H($$F2" B*41 '"E#@
XL  I0   *4   $D@  !0H   4*   %"@  !0H  'D)X &%"A@& ) &!_^?_C@
X 
Xend
END_OF_FILE
# end of 'icon/Uweird_thing'
fi
if test -f 'icon/Uyieldsign' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/Uyieldsign'\"
else
echo shar: Extracting \"'icon/Uyieldsign'\" \(212 characters\)
sed "s/^X//" >'icon/Uyieldsign' <<'END_OF_FILE'
Xbegin 644 yieldsign
XM>GH@0"! #___\#    Q    "@    8BOH\&(J"(AA2@B(4(N(B)"*"(B(B@B
XM)!(ON\@0   ("   $ 0  " $   @ @  0 $  ( !  "  ( !  !  @  0 ( 
XL " $   0"   $ @   @0   $(    \                              
X 
Xend
END_OF_FILE
# end of 'icon/Uyieldsign'
fi
if test -f 'icon/eye/Ueye' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye'\"
else
echo shar: Extracting \"'icon/eye/Ueye'\" \(210 characters\)
sed "s/^X//" >'icon/eye/Ueye' <<'END_OF_FILE'
Xbegin 644 eye
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (  5("  *
XMJ!  %500("OL$$A7M!"0+]P1(%?T$D O_!$@5_00G"OL"$(56 @A"J@$,050
XL D( ( $D $  V &  " .   0\   "2    D@   )]@  "@V  ! "0  __L!0
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye'
fi
if test -f 'icon/eye/Ueye1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye1'\"
else
echo shar: Extracting \"'icon/eye/Ueye1'\" \(211 characters\)
sed "s/^X//" >'icon/eye/Ueye1' <<'END_OF_FILE'
Xbegin 644 eye1
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (  5("  *
XMJ!  %500("OL$$A7M!"0+]P1(%?T$D O_!$@5_00G"OL"$(56 @A"J@$,050
XL D( ( $D $  V &  " .   0\   "2<   DX@  1 0  (NX  $ 0   _X !0
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye1'
fi
if test -f 'icon/eye/Ueye10' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye10'\"
else
echo shar: Extracting \"'icon/eye/Ueye10'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye10' <<'END_OF_FILE'
Xbegin 644 eye10
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (!5 (" JH
XM"! 55 0@*^H"(%>U D0OVA%(5_4)2"_Z"217]1(2*^HD$A54) D*J$@0A5"$
XL$(  A!"  (0/  !X /'#@  2)   $B0  "$D  ! I   /T(   "!    ?@"$
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye10'
fi
if test -f 'icon/eye/Ueye11' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye11'\"
else
echo shar: Extracting \"'icon/eye/Ueye11'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye11' <<'END_OF_FILE'
Xbegin 644 eye11
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (!5 (" JH
XM"! 55 0@*^H"(%>U D0OVA%(5_4)2"_Z"217]1(2*^HD$A54) D*J$@0A5"$
XL$(  A!"  (0/  !X /'#@  2)   $B0  !(D   A)   7J0  &'"   _?@"$
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye11'
fi
if test -f 'icon/eye/Ueye12' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye12'\"
else
echo shar: Extracting \"'icon/eye/Ueye12'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye12' <<'END_OF_FILE'
Xbegin 644 eye12
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (!5 (" JH
XM"! 55 0@*^H"(%>U D0OVA%(5_4)2"_Z"217]1(2*^HD$A54) D*J$@0A5"$
XL$(  A!"  (0/  !X /'#@  2)   $B0  !(D   2)   (20  $#"   _?@"$
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye12'
fi
if test -f 'icon/eye/Ueye13' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye13'\"
else
echo shar: Extracting \"'icon/eye/Ueye13'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye13' <<'END_OF_FILE'
Xbegin 644 eye13
XM>GH@0"!             #^   ' <  &  P "  " !   0 @  " 2H  0%5  
XM$"JH  @WU 0(+VH2"#^T"0@OZ@2(/_0"2"_J!(@WU#D(&JA"$!50A! *H(P@
XL! !"0 ( )( !@!L  ' $   /"   Y)   1R0  " B   =T0   @"   '_  @
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye13'
fi
if test -f 'icon/eye/Ueye14' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye14'\"
else
echo shar: Extracting \"'icon/eye/Ueye14'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye14' <<'END_OF_FILE'
Xbegin 644 eye14
XM>GH@0"!             #^   ' <  &  P "  " !   0 @  " 2H  0%5  
XM$"JH  @WU 0(+VH2"#^T"0@OZ@2(/_0"2"_J!(@WU#D(&JA"$!50A! *H(P@
XL! !"0 ( )( !@!L  ' $   /"   !)   8E,  )R(@ !!.(  ,4$   Y^  @
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye14'
fi
if test -f 'icon/eye/Ueye15' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye15'\"
else
echo shar: Extracting \"'icon/eye/Ueye15'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye15' <<'END_OF_FILE'
Xbegin 644 eye15
XM>GH@0"!             #^   ' <  &  P "  " !   0 @  " 2H  0%5  
XM$"JH  @WU 0(+VH2"#^T"0@OZ@2(/_0"2"_J!(@WU#D(&JA"$!50A! *H(P@
XL! !"0 ( )( !@!L  '!$   /R   !,@   .(   $!   -_P  $!   !_P  @
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye15'
fi
if test -f 'icon/eye/Ueye16' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye16'\"
else
echo shar: Extracting \"'icon/eye/Ueye16'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye16' <<'END_OF_FILE'
Xbegin 644 eye16
XM>GH@0"!             #^   ' <  &  P "  " !   0 @  " 2H  0%5  
XM$"JH  @WU 0(+VH2"#^T"0@OZ@2(/_0"2"_J!(@WU#D(&JA"$!50A! *H(P@
XL! !"0 ( )( !@!L  '($   ..    D@  !Q(   @*   /^@   0$   '_  @
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye16'
fi
if test -f 'icon/eye/Ueye17' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye17'\"
else
echo shar: Extracting \"'icon/eye/Ueye17'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye17' <<'END_OF_FILE'
Xbegin 644 eye17
XM>GH@0"!             #^   ' <  &  P "  " !   0 @  " 2H  0%5  
XM$"JH  @WU 0(+VH2"#^T"0@OZ@2(/_0"2"_J!(@WU#D(&JA"$!50A! *H(P@
XL! !"0 ( )( !@!L  '($   ..   0D@  +3(  ",I   070  #("   ._@ @
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye17'
fi
if test -f 'icon/eye/Ueye18' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye18'\"
else
echo shar: Extracting \"'icon/eye/Ueye18'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye18' <<'END_OF_FILE'
Xbegin 644 eye18
XM>GH@0"!             #^   ' <  &  P "  " !   0 @  " 2H  0%5  
XM$"JH  @WU 0(+VH2"#^T"0@OZ@2(/_0"2"_J!(@WU#D(&JA"$!50A! *H(P@
XL! !"0 ( )( !@!L  '($   ..    F0   )D   "<@  'D(  " ^   _X  @
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye18'
fi
if test -f 'icon/eye/Ueye19' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye19'\"
else
echo shar: Extracting \"'icon/eye/Ueye19'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye19' <<'END_OF_FILE'
Xbegin 644 eye19
XM>GH@0"!   ?P   X#@  P &  0  0 (  " $   0"   " @   @0   $,   
XM!#    90   %8    V    ,@   "$   !!    0(   (&   #!0  !02   D
XL#P  > #APX  $B0  !(D   2)   $D(  "&!  ! _@  /P             D
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye19'
fi
if test -f 'icon/eye/Ueye2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye2'\"
else
echo shar: Extracting \"'icon/eye/Ueye2'\" \(211 characters\)
sed "s/^X//" >'icon/eye/Ueye2' <<'END_OF_FILE'
Xbegin 644 eye2
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (  5("  *
XMJ!  %500("OL$$A7M!"0+]P1(%?T$D O_!$@5_00G"OL"$(56 @A"J@$,050
XL D( ( $D $  V &  " .   0\   "2   #*1@ !$3D  1R"  ""C   ?G !0
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye2'
fi
if test -f 'icon/eye/Ueye20' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye20'\"
else
echo shar: Extracting \"'icon/eye/Ueye20'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye20' <<'END_OF_FILE'
Xbegin 644 eye20
XM>GH@0"!   ?P   X#@  P &  0  0 (  " $   0"   " @   @0   $,   
XM!C    90   %8    V    ,@   "$   !!    0(   (&   #!0  !02   D
XL#P  > #APX  $B0  !(D   29@  $J4  "%F  ! O   /P             D
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye20'
fi
if test -f 'icon/eye/Ueye21' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye21'\"
else
echo shar: Extracting \"'icon/eye/Ueye21'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye21' <<'END_OF_FILE'
Xbegin 644 eye21
XM>GH@0"!   ?P   X#@  P &  0  0 (  " $   0"   " @   @0   $,   
XM!C    90   %8    V    ,@   "$   !!    0(   (&   #!0  !02   D
XL#P  > #APX  $B0  !(D   2)   (20  $"D   _0@   'X            D
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye21'
fi
if test -f 'icon/eye/Ueye22' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye22'\"
else
echo shar: Extracting \"'icon/eye/Ueye22'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye22' <<'END_OF_FILE'
Xbegin 644 eye22
XM>GH@0"!   ?P   X#@  P &  0  0 (  " $   0"   " @   @0   $,   
XM!C    90   %8    V    ,@   "$   !!    0(   (&   #!0  !02   D
XL#P  > #APX  $B0  !(D   A)   0*0  #]"    @0   'X            D
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye22'
fi
if test -f 'icon/eye/Ueye23' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye23'\"
else
echo shar: Extracting \"'icon/eye/Ueye23'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye23' <<'END_OF_FILE'
Xbegin 644 eye23
XM>GH@0"!   ?P   X#@  P &  0  0 (  " $   0"   " @   @0   $,   
XM!C    90   %8    V    ,@   "$   !!    0(   (&   #!0  !02   D
XL#P  > #APX  $B0  !(D   S)   4J0  #-"   >@0   'X            D
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye23'
fi
if test -f 'icon/eye/Ueye24' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye24'\"
else
echo shar: Extracting \"'icon/eye/Ueye24'\" \(212 characters\)
sed "s/^X//" >'icon/eye/Ueye24' <<'END_OF_FILE'
Xbegin 644 eye24
XM>GH@0"!   ?P   X#@  P &  0  0 (  " $   0"   " @   @0   $,   
XM!C    90   %8    V    ,@   "$   !!    0(   (&   #!0  !02   D
XL#P  > #APX  $B0  !(D   2)   $B0  !):   AI0  /_\            D
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye24'
fi
if test -f 'icon/eye/Ueye3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye3'\"
else
echo shar: Extracting \"'icon/eye/Ueye3'\" \(211 characters\)
sed "s/^X//" >'icon/eye/Ueye3' <<'END_OF_FILE'
Xbegin 644 eye3
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (  5("  *
XMJ!  %500("OL$$A7M!"0+]P1(%?T$D O_!$@5_00G"OL"$(56 @A"J@$,050
XL D( ( $D $  V &  "(.   3\   $R   !'    @(   /^P   ("   #_@!0
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye3'
fi
if test -f 'icon/eye/Ueye4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye4'\"
else
echo shar: Extracting \"'icon/eye/Ueye4'\" \(211 characters\)
sed "s/^X//" >'icon/eye/Ueye4' <<'END_OF_FILE'
Xbegin 644 eye4
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (  5("  *
XMJ!  %500("OL$$A7M!"0+]P1(%?T$D O_!$@5_00G"OL"$(56 @A"J@$,050
XL D( ( $D $  V &  "!.   <<   $D   !(X   4!   %_P  " @   _X !0
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye4'
fi
if test -f 'icon/eye/Ueye5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye5'\"
else
echo shar: Extracting \"'icon/eye/Ueye5'\" \(211 characters\)
sed "s/^X//" >'icon/eye/Ueye5' <<'END_OF_FILE'
Xbegin 644 eye5
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (  5("  *
XMJ!  %500("OL$$A7M!"0+]P1(%?T$D O_!$@5_00G"OL"$(56 @A"J@$,050
XL D( ( $D $  V &  "!.   <<   $D(  !,M   E,0  +H(  $!,  !_< !0
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye5'
fi
if test -f 'icon/eye/Ueye6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye6'\"
else
echo shar: Extracting \"'icon/eye/Ueye6'\" \(211 characters\)
sed "s/^X//" >'icon/eye/Ueye6' <<'END_OF_FILE'
Xbegin 644 eye6
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (  5("  *
XMJ!  %500("OL$$A7M!"0+]P1(%?T$D O_!$@5_00G"OL"$(56 @A"J@$,050
XL D( ( $D $  V &  "!.   <<   )D   "9   !.0   0G@  'P$   '_ !0
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye6'
fi
if test -f 'icon/eye/Ueye7' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye7'\"
else
echo shar: Extracting \"'icon/eye/Ueye7'\" \(211 characters\)
sed "s/^X//" >'icon/eye/Ueye7' <<'END_OF_FILE'
Xbegin 644 eye7
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (!5 (" JH
XM"! 55 0@*^H"(%>U D0OVA%(5_4)2"_Z"217]1(2*^HD$A54) D*J$@0A5"$
XL$(  A!"  (0/  !X /'#@  2)   $B0  !(D   20@  (8$  $#^   _  "$
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye7'
fi
if test -f 'icon/eye/Ueye8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye8'\"
else
echo shar: Extracting \"'icon/eye/Ueye8'\" \(211 characters\)
sed "s/^X//" >'icon/eye/Ueye8' <<'END_OF_FILE'
Xbegin 644 eye8
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (!5 (" JH
XM"! 55 0@*^H"(%>U D0OVA%(5_4)2"_Z"217]1(2*^HD$A54) D*J$@0A5"$
XL$(  A!"  (0/  !X /'#@  2)   $B0  !(D   20@  $KT  "'#   _?@"$
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye8'
fi
if test -f 'icon/eye/Ueye9' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon/eye/Ueye9'\"
else
echo shar: Extracting \"'icon/eye/Ueye9'\" \(211 characters\)
sed "s/^X//" >'icon/eye/Ueye9' <<'END_OF_FILE'
Xbegin 644 eye9
XM>GH@0"!             !_   #@.  #  8 !  !  @  ( 0  ! (!5 (" JH
XM"! 55 0@*^H"(%>U D0OVA%(5_4)2"_Z"217]1(2*^HD$A54) D*J$@0A5"$
XL$(  A!"  (0/  !X /'#@  2)   $B0  !(D   A)   0,(  #^!    ?@"$
X 
Xend
END_OF_FILE
# end of 'icon/eye/Ueye9'
fi
if test -f 'menu/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'menu/Makefile'\"
else
echo shar: Extracting \"'menu/Makefile'\" \(243 characters\)
sed "s/^X//" >'menu/Makefile' <<'END_OF_FILE'
X# makefile for demos 
X
X#INSDIR= /usr/mgr/bin
X
XMENUS= mail_menu more_menu shell_menu vi_menu
XSTART = .
X
Xall small:	$(ALL)
X
Xsmallinstall:
X
Xinstall:
X
Xclean clobber:
X
Xlist:
X	@for i in Makefile README $(MENUS); do \
X		echo "${START}/$$i"; \
X	done	
END_OF_FILE
# end of 'menu/Makefile'
fi
if test -f 'menu/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'menu/README'\"
else
echo shar: Extracting \"'menu/README'\" \(175 characters\)
sed "s/^X//" >'menu/README' <<'END_OF_FILE'
XFiles in this directory contain mgr menus.  The menus are loaded with
Xthe "menu" command.   The <name>.out files are pre-compiled menus.  
XThe are loaded via "cat <name>.out"
END_OF_FILE
# end of 'menu/README'
fi
if test -f 'misc/termcap' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/termcap'\"
else
echo shar: Extracting \"'misc/termcap'\" \(273 characters\)
sed "s/^X//" >'misc/termcap' <<'END_OF_FILE'
Xpx|mgr|SAU winow manager teminal emulator:\
X	:am:li#24:co#80:bs:cl=^L:ce=\Ec:cd=\EC:\
X	:cm=\E%r%d,%dM:cs=\E%d,%dt:\
X	:al=\Ea:dl=\Ed:ta=^I:\
X	:AL=\E%da:DL=\E%dd: \
X	:ic=\EA:dc=\EE:\
X	:up=\Eu:do=\Ef:nd=\Er:\
X	:so=\Ei:se=\En:vs=\EV:ve=\Ev:\
X	:ku=\E[A:kd=\E[B:kr=\E[C:kl=\E[D:
END_OF_FILE
# end of 'misc/termcap'
fi
if test -f 'src/oblit/blit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/oblit/blit.c'\"
else
echo shar: Extracting \"'src/oblit/blit.c'\" \(26880 characters\)
sed "s/^X//" >'src/oblit/blit.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: blit.c,v 4.1 88/06/21 13:07:59 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/oblit/RCS/blit.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/oblit/RCS/blit.c,v $$Revision: 4.1 $";
X
X/*  SUN-2 bitblit code */
X
X#include "bitmap.h"
X
X/*
X * your standard unrolled-loop (I don't think this buys much)
X */
X
X#define LOOP(n,s) {				\
X    register int cnt;				\
X    for (cnt=(n); cnt>=16; cnt-=16) {		\
X       s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;		\
X       }					\
X    switch (cnt) {				\
X       case 15: s; case 14: s; case 13: s; case 12: s;	\
X       case 11: s; case 10: s; case  9: s; case  8: s;	\
X       case  7: s; case  6: s; case  5: s; case  4: s;	\
X       case  3: s; case  2: s; case  1: s; 		\
X       }						\
X    }
X
X/*
X * A funny unrolled-loop: even and odd cases differ
X */
X
X#define LOOP2(n,s1,s2) { 				\
X    register int cnt;					\
X    for (cnt=(n); cnt>=16; cnt-=16)	{		\
X       s1;s2;s1;s2;s1;s2;s1;s2;s1;s2;s1;s2;s1;s2;s1;s2;	\
X       }						\
X    switch (cnt) {					\
X       case 15: s1;s2; case 13: s1;s2; case 11: s1;s2; 	\
X       case  9: s1;s2; case  7: s1;s2; case  5: s1;s2;	\
X       case  3: s1;s2; case  1: s1;			\
X          break;					\
X       case 14: s1;s2; case 12: s1;s2; case 10: s1;s2;	\
X       case  8: s1;s2; case  6: s1;s2; case  4: s1;s2;	\
X       case  2: s1;s2; case  0: src=srcx;		\
X       }						\
X    }
X
X#define lsrc	((unsigned long *)src)
X#define lsrcx	((unsigned long *)srcx)
X
X/*
X *  General memory-to-memory rasterop
X */
X
Xmem_rop(dest, dx, dy, width, height, func, source, sx, sy)
Xint sx, sy, dx, dy;		/* properly clipped source and dest */
Xint width, height;		/* rectangle to be transferred */
XBITMAP *source, *dest;		/* bit map pointers */
Xint func;			/* rasterop function */
X
X{
X   int dwwidth = BIT_LINE(dest);
X   int swwidth = 0;
X   int xs, ys;
X   int xd, yd;
X   unsigned short *sbase = (unsigned short *) 0;
X   unsigned short *dbase = (dest->data);
X
X   /* clipping, should already be done ? */
X
X   {
X      register int t;
X
X      if (width < 0)
X	 dx += width, width = -width;
X      if (height < 0)
X	 dy += height, height = -height;
X      if (dx < 0) {
X	 if (source)
X	    sx -= dx;
X	 width += dx, dx = 0;
X      }
X
X      if (dy < 0) {
X	 if (source)
X	    sy -= dy;
X	 height += dy, dy = 0;
X      }
X
X      if (source) {
X	 if (sx < 0)
X	    dx -= sx, width += sx, sx = 0;
X	 if (sy < 0)
X	    dy -= sy, height += sy, sy = 0;
X	 if ((t = sx + width - source->wide) > 0)
X	    width -= t;
X	 if ((t = sy + height - source->high) > 0)
X	    height -= t;
X
X	 swwidth = BIT_LINE(source);
X	 xs = sx + source->x0, ys = sy + source->y0;
X	 sbase = (source->data);
X      }
X
X      if ((t = dx + width - dest->wide) > 0)
X	 width -= t;
X      if ((t = dy + height - dest->high) > 0)
X	 height -= t;
X
X      if (width < 1 || height < 1)
X	 return;
X   }
X
X   /*********/
X
X   xd = dx + dest->x0, yd = dy + dest->y0;
X   func = OPCODE(func);
X
X   if (!source) {		/* no source bitmap */
X
X      register unsigned long *dst =
X      (unsigned long *) (dbase + yd * dwwidth + (xd >> 4));
X      register unsigned int mask1 =
X      ((unsigned long) 0xFFFFFFFF) >> (xd & 15);
X      register unsigned int h_cnt =
X      ((xd + width - 1) - ((xd & ~15)) >> 5) + 1;
X      register unsigned int mask2 =
X      0xFFFFFFFF << (31 - (((xd + width - 1) - (xd & ~15)) & 31));
X      register unsigned int d_incr =
X      (dwwidth << 1) - (h_cnt << 2);
X      register unsigned int v_cnt;
X
X      if (h_cnt > 1)		/* multi-line bitblit */
X	 switch (func) {	/* no source */
X	    case OPCODE(0):
X	    case OPCODE(~(DST | SRC)):
X	    case OPCODE(DST & ~SRC):
X	    case OPCODE(~SRC):	/* no source multi-word blit */
X	       for (v_cnt = height; v_cnt > 0; v_cnt--) {
X		  *dst++ = *dst & ~mask1;
X		  LOOP((h_cnt) - 2, *dst++ = 0);
X		  *dst++ = *dst & ~mask2;
X		  (int) dst += d_incr;
X	       }
X
X	       break;
X	    case OPCODE(~DST & SRC):
X	    case OPCODE(~DST):
X	    case OPCODE(DST ^ SRC):
X	    case OPCODE(~(DST & SRC)):	/* no source multi-word blit */
X	       for (v_cnt = height; v_cnt > 0; v_cnt--) {
X		  *dst++ = *dst ^ mask1;
X		  LOOP((h_cnt) - 2, *dst++ = ~*dst);
X		  *dst++ = *dst ^ mask2;
X		  (int) dst += d_incr;
X	       }
X
X	       break;
X	    case OPCODE(SRC):
X	    case OPCODE(~DST | SRC):
X	    case OPCODE(DST | SRC):
X	    case OPCODE(~0):	/* no source multi-word blit */
X	       for (v_cnt = height; v_cnt > 0; v_cnt--) {
X		  *dst++ = ((*dst) | (mask1));
X		  LOOP((h_cnt) - 2, *dst++ = ~0);
X		  *dst++ = ((*dst) | (mask2));
X		  (int) dst += d_incr;
X	       }
X
X	       break;
X	 }
X
X      else {			/* single line bit-blit */
X	 mask1 &= mask2;
X	 switch (func) {	/* no source */
X	    case OPCODE(0):
X	    case OPCODE(~(DST | SRC)):
X	    case OPCODE(DST & ~SRC):
X	    case OPCODE(~SRC):	/* no source single-word blit */
X	       for (v_cnt = height; v_cnt > 0; v_cnt--) {
X		  *dst++ = *dst & ~mask1;
X		  (int) dst += d_incr;
X	       }
X
X	       break;
X	    case OPCODE(~DST & SRC):
X	    case OPCODE(~DST):
X	    case OPCODE(DST ^ SRC):
X	    case OPCODE(~(DST & SRC)):	/* no source single-word blit */
X	       for (v_cnt = height; v_cnt > 0; v_cnt--) {
X		  *dst++ = *dst ^ mask1;
X		  (int) dst += d_incr;
X	       }
X
X	       break;
X	    case OPCODE(SRC):
X	    case OPCODE(~DST | SRC):
X	    case OPCODE(DST | SRC):
X	    case OPCODE(~0):	/* no source single-word blit */
X	       for (v_cnt = height; v_cnt > 0; v_cnt--) {
X		  *dst++ = ((*dst) | (mask1));
X		  (int) dst += d_incr;
X	       }
X
X	       break;
X	 }
X
X      }
X
X   }
X
X   /* source (op) dest bitmap */
X
X   else {
X      unsigned int lmask =
X      0xFFFF >> (xd & 15);	/* mask for left edge */
X      unsigned int h_cnt =
X      ((xd + width - 1) >> 4) - (xd >> 4) + 1;	/* shorts in dest */
X      unsigned int rmask =
X      0xFFFF << (15 - ((xd + width - 1) & 15));	/* mask for right edge */
X
X      register unsigned short *src =
X      sbase + ys * swwidth + (xs >> 4);	/* source */
X      register unsigned short *srcx;	/* source alternate */
X      register unsigned short *dst =
X      dbase + yd * dwwidth + (xd >> 4);	/* destination */
X      register unsigned int mask1, mask2;	/* masks */
X      register unsigned int shift;	/* shift count */
X      int s_incr, d_incr;	/* how to get line to line */
X      int v_cnt;		/* number of lines */
X
X      if ((xs & 15) > (xd & 15))
X	 shift = 16 - (xs & 15) + (xd & 15);
X      else
X	 shift = (xd & 15) - (xs & 15), src -= 1;
X
X      if (yd < ys)
X	 s_incr = swwidth, d_incr = dwwidth;	/* top to bottom */
X      else
X	 s_incr = -swwidth, d_incr = -dwwidth,
X	    src += (height - 1) * swwidth,
X	    dst += (height - 1) * dwwidth;	/* bottom to top */
X
X      if (xd < xs) {		/* left to right */
X	 s_incr -= h_cnt + 1, d_incr -= h_cnt;
X	 if (h_cnt > 1) {
X	    mask1 = lmask, mask2 = rmask;
X	    {
X	       switch (func) {
X		  case OPCODE(~(DST | SRC)):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = ~(*dst | *lsrc++ >> shift) & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = ~(*dst | *lsrcx++ >> shift), *dst++ = ~(*dst | *lsrc++ >> shift));
X			*dst++ = ~(*dst | *lsrc++ >> shift) & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST & ~SRC):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = *dst & ~*lsrc++ >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = *dst & ~*lsrcx++ >> shift, *dst++ = *dst & ~*lsrc++ >> shift);
X			*dst++ = *dst & ~*lsrc++ >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~SRC):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = ~*lsrc++ >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = ~*lsrcx++ >> shift, *dst++ = ~*lsrc++ >> shift);
X			*dst++ = ~*lsrc++ >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~DST & SRC):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = ~*dst & *lsrc++ >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = ~*dst & *lsrcx++ >> shift, *dst++ = ~*dst & *lsrc++ >> shift);
X			*dst++ = ~*dst & *lsrc++ >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST ^ SRC):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = *dst ^ *lsrc++ >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = *dst ^ *lsrcx++ >> shift, *dst++ = *dst ^ *lsrc++ >> shift);
X			*dst++ = *dst ^ *lsrc++ >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~(DST & SRC)):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = ~(*dst & *lsrc++ >> shift) & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = ~(*dst & *lsrcx++ >> shift), *dst++ = ~(*dst & *lsrc++ >> shift));
X			*dst++ = ~(*dst & *lsrc++ >> shift) & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST & SRC):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = *dst & *lsrc++ >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = *dst & *lsrcx++ >> shift, *dst++ = *dst & *lsrc++ >> shift);
X			*dst++ = *dst & *lsrc++ >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~(DST ^ SRC)):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = ~(*dst ^ *lsrc++ >> shift) & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = ~(*dst ^ *lsrcx++ >> shift), *dst++ = ~(*dst ^ *lsrc++ >> shift));
X			*dst++ = ~(*dst ^ *lsrc++ >> shift) & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST | ~SRC):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = *dst | ~*lsrc++ >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = *dst | ~*lsrcx++ >> shift, *dst++ = *dst | ~*lsrc++ >> shift);
X			*dst++ = *dst | ~*lsrc++ >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(SRC):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = *lsrc++ >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = *lsrcx++ >> shift, *dst++ = *lsrc++ >> shift);
X			*dst++ = *lsrc++ >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~DST | SRC):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = ~*dst | *lsrc++ >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = ~*dst | *lsrcx++ >> shift, *dst++ = ~*dst | *lsrc++ >> shift);
X			*dst++ = ~*dst | *lsrc++ >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST | SRC):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = *dst | *lsrc++ >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = *dst | *lsrcx++ >> shift, *dst++ = *dst | *lsrc++ >> shift);
X			*dst++ = *dst | *lsrc++ >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;	/* these should never be called - use no source case */
X		  case OPCODE(0):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			*dst++ = 0 & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = 0, *dst++ = 0);
X			*dst++ = 0 & mask2 | *dst & ~mask2;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~DST):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			*dst++ = ~*dst & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = ~*dst, *dst++ = ~*dst);
X			*dst++ = ~*dst & mask2 | *dst & ~mask2;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~0):	/* left->right multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			*dst++ = ~0 & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst++ = ~0, *dst++ = ~0);
X			*dst++ = ~0 & mask2 | *dst & ~mask2;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST):
X		     break;
X	       }
X
X	    }
X
X	 }
X
X	 else {
X	    mask1 = lmask & rmask;
X	    {
X	       switch (func) {
X		  case OPCODE(~(DST | SRC)):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = ~(*dst | *lsrc++ >> shift) & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST & ~SRC):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = *dst & ~*lsrc++ >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~SRC):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = ~*lsrc++ >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~DST & SRC):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = ~*dst & *lsrc++ >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST ^ SRC):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = *dst ^ *lsrc++ >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~(DST & SRC)):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = ~(*dst & *lsrc++ >> shift) & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST & SRC):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = *dst & *lsrc++ >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~(DST ^ SRC)):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = ~(*dst ^ *lsrc++ >> shift) & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST | ~SRC):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = *dst | ~*lsrc++ >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(SRC):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = *lsrc++ >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~DST | SRC):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = ~*dst | *lsrc++ >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST | SRC):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx++;
X			*dst++ = *dst | *lsrc++ >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;	/* these should never be called - use no source case */
X		  case OPCODE(0):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			*dst++ = 0 & mask1 | *dst & ~mask1;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~DST):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			*dst++ = ~*dst & mask1 | *dst & ~mask1;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~0):	/* left->right single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			*dst++ = ~0 & mask1 | *dst & ~mask1;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST):
X		     break;
X	       }
X
X	    }
X
X	 }
X
X      }
X
X      else {			/* right to left */
X	 s_incr += h_cnt + 1, d_incr += h_cnt;
X	 src += h_cnt - 1, dst += h_cnt - 1;
X	 if (h_cnt > 1) {
X	    mask1 = rmask, mask2 = lmask;
X	    {
X	       switch (func) {
X		  case OPCODE(~(DST | SRC)):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = ~(*dst | *lsrc-- >> shift) & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = ~(*dst | *lsrcx-- >> shift), *dst-- = ~(*dst | *lsrc-- >> shift));
X			*dst-- = ~(*dst | *lsrc-- >> shift) & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST & ~SRC):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = *dst & ~*lsrc-- >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = *dst & ~*lsrcx-- >> shift, *dst-- = *dst & ~*lsrc-- >> shift);
X			*dst-- = *dst & ~*lsrc-- >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~SRC):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = ~*lsrc-- >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = ~*lsrcx-- >> shift, *dst-- = ~*lsrc-- >> shift);
X			*dst-- = ~*lsrc-- >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~DST & SRC):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = ~*dst & *lsrc-- >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = ~*dst & *lsrcx-- >> shift, *dst-- = ~*dst & *lsrc-- >> shift);
X			*dst-- = ~*dst & *lsrc-- >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST ^ SRC):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = *dst ^ *lsrc-- >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = *dst ^ *lsrcx-- >> shift, *dst-- = *dst ^ *lsrc-- >> shift);
X			*dst-- = *dst ^ *lsrc-- >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~(DST & SRC)):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = ~(*dst & *lsrc-- >> shift) & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = ~(*dst & *lsrcx-- >> shift), *dst-- = ~(*dst & *lsrc-- >> shift));
X			*dst-- = ~(*dst & *lsrc-- >> shift) & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST & SRC):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = *dst & *lsrc-- >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = *dst & *lsrcx-- >> shift, *dst-- = *dst & *lsrc-- >> shift);
X			*dst-- = *dst & *lsrc-- >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~(DST ^ SRC)):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = ~(*dst ^ *lsrc-- >> shift) & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = ~(*dst ^ *lsrcx-- >> shift), *dst-- = ~(*dst ^ *lsrc-- >> shift));
X			*dst-- = ~(*dst ^ *lsrc-- >> shift) & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST | ~SRC):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = *dst | ~*lsrc-- >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = *dst | ~*lsrcx-- >> shift, *dst-- = *dst | ~*lsrc-- >> shift);
X			*dst-- = *dst | ~*lsrc-- >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(SRC):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = *lsrc-- >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = *lsrcx-- >> shift, *dst-- = *lsrc-- >> shift);
X			*dst-- = *lsrc-- >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~DST | SRC):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = ~*dst | *lsrc-- >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = ~*dst | *lsrcx-- >> shift, *dst-- = ~*dst | *lsrc-- >> shift);
X			*dst-- = ~*dst | *lsrc-- >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST | SRC):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = *dst | *lsrc-- >> shift & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = *dst | *lsrcx-- >> shift, *dst-- = *dst | *lsrc-- >> shift);
X			*dst-- = *dst | *lsrc-- >> shift & mask2 | *dst & ~mask2;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;	/* these should never be called - use no source case */
X		  case OPCODE(0):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			*dst-- = 0 & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = 0, *dst-- = 0);
X			*dst-- = 0 & mask2 | *dst & ~mask2;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~DST):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			*dst-- = ~*dst & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = ~*dst, *dst-- = ~*dst);
X			*dst-- = ~*dst & mask2 | *dst & ~mask2;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~0):	/* right->left multi-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			*dst-- = ~0 & mask1 | *dst & ~mask1;
X			LOOP2((h_cnt) - 2, *dst-- = ~0, *dst-- = ~0);
X			*dst-- = ~0 & mask2 | *dst & ~mask2;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST):
X		     break;
X	       }
X
X	    }
X
X	 }
X
X	 else {
X	    mask1 = lmask & rmask;
X	    {
X	       switch (func) {
X		  case OPCODE(~(DST | SRC)):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = ~(*dst | *lsrc-- >> shift) & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST & ~SRC):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = *dst & ~*lsrc-- >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~SRC):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = ~*lsrc-- >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~DST & SRC):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = ~*dst & *lsrc-- >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST ^ SRC):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = *dst ^ *lsrc-- >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~(DST & SRC)):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = ~(*dst & *lsrc-- >> shift) & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST & SRC):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = *dst & *lsrc-- >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~(DST ^ SRC)):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = ~(*dst ^ *lsrc-- >> shift) & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST | ~SRC):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = *dst | ~*lsrc-- >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(SRC):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = *lsrc-- >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~DST | SRC):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = ~*dst | *lsrc-- >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST | SRC):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			srcx = src;
X			srcx--;
X			*dst-- = *dst | *lsrc-- >> shift & mask1 | *dst & ~mask1;
X			src += s_incr;
X			dst += d_incr;
X		     }
X
X		     break;	/* these should never be called - use no source case */
X		  case OPCODE(0):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			*dst-- = 0 & mask1 | *dst & ~mask1;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~DST):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			*dst-- = ~*dst & mask1 | *dst & ~mask1;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(~0):	/* right->left single-word blit */
X		     for (v_cnt = height; v_cnt > 0; v_cnt--) {
X			*dst-- = ~0 & mask1 | *dst & ~mask1;
X			dst += d_incr;
X		     }
X
X		     break;
X		  case OPCODE(DST):
X		     break;
X	       }
X
X	    }
X
X	 }
X
X      }
X
X   }
X
X}
END_OF_FILE
# end of 'src/oblit/blit.c'
fi
echo shar: End of archive 45 \(of 61\).
cp /dev/null ark45isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
