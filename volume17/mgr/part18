Subject:  v17i019:  MGR, Bellcore window manager, Part19/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 19
Archive-name: mgr/part19




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 18 (of 61)."
# Contents:  demo/icon/Makefile demo/icon/mclock.c
#   doc/usrman/croff/mktable.c font-16/Ucmr10x16b font-16/Ucmr10x16bI
#   font-16/Ucmr10x16bu font-32/Ucmr10x16b font-32/Ucmr10x16bI
#   font-32/Ucmr10x16bu misc/rotate.c src/data.c src/event.h src/kbd.c
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:20 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'demo/icon/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/icon/Makefile'\"
else
echo shar: Extracting \"'demo/icon/Makefile'\" \(3557 characters\)
sed "s/^X//" >'demo/icon/Makefile' <<'END_OF_FILE'
X#                        Copyright (c) 1987 Bellcore
X#                            All Rights Reserved
X#       Permission is granted to copy or use this program, EXCEPT that it
X#       may not be sold for profit, the copyright notice must be reproduced
X#       on copies, and credit should be given to Bellcore where it is due.
X#       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X
X#	$Header: Makefile,v 4.14 88/08/24 16:00:08 bianchi Exp $
X#	$Source: /tmp/mgrsrc/demo/icon/RCS/Makefile,v $
X
X# icon stuff
X#
X#	walk,mclock,cycle  courtesy  S. D. Hawley
X#
XINCL = ../../lib
X
X#	need pixrect if mgr is pixrect (or color) version
X#	zoom and snap don't work in color, see NOCOLOR= below
X
X
XLIB = $(INCL)/libmgr.a
XMGR = ../../src
XBITDIR=../../lib
XBITLIB = $(BITDIR)/blitlib.a $(OTHERLIB)
XCFLAGS= -I$(INCL) -I$(BITDIR)
X
XCFILES= browse.c cycle.c cut.c iconmail.c iconmsgs.c icontoc.c mclock.c snap.c \
X	walk.c window_print.c zoom.c set_colormap.c overlay.c invert_colormap.c
XHFILES = mail_icons.h msgs_icons.h
XOTHER = Makefile README
XSTART=.
XCPIO=icon.cpio
XINSROOT=/usr/mgr
XINSDIR=$(INSROOT)/bin
X
XSMALL= browse cycle cut iconmail iconmsgs mclock walk window_print
X
X#remove NOCOLOR modules for color versions
XNOCOLOR=zoom snap
X#NOCOLOR=
XALL = $(SMALL) $(NOCOLOR) set_colormap overlay invert_colormap
X
Xall:	$(ALL)
X
Xsmall:	$(SMALL)
X
Xfast:	$(CFILES)
X		cc -c $(CFLAGS) $(CFILES)
X		make all
X
Xconvert_icon:	convert_icon.o $(LIB)
X		cc -o convert_icon convert_icon.o $(LIB)
X
Xtest2:		test2.o $(LIB)
X		cc -o test2 test2.o $(LIB)
X
Xchess:		chess.o $(LIB)
X		cc -o chess chess.o $(LIB)
X
Xcut:		cut.o $(LIB)
X		cc -o cut cut.o $(LIB)
X
Xbrowse:		browse.o $(LIB)
X		cc -o browse browse.o $(LIB)
X
Xwalk:		walk.o $(LIB)
X		cc -o walk walk.o $(LIB)
X
Xiconmail.o:	mail_icons.h
X
Xiconmail:	iconmail.o $(LIB)
X		cc -o iconmail iconmail.o $(LIB)
X
Xiconmsgs.o:	msgs_icons.h
X
Xiconmsgs:	iconmsgs.o $(LIB)
X		cc -o iconmsgs iconmsgs.o $(LIB)
X
Xicontoc:	icontoc.o $(LIB) $(MGR)/bitmaphead.o $(MGR)/bitmapread.o
X		cc -o icontoc icontoc.o $(LIB) \
X			$(MGR)/bitmaphead.o $(MGR)/bitmapread.o $(BITLIB)
X
Xsnap:		snap.o $(LIB) $(MGR)/bitmaphead.o $(MGR)/bitmapread.o
X		cc -o snap snap.o $(LIB) \
X			$(MGR)/bitmaphead.o $(MGR)/bitmapread.o $(BITLIB)
X
Xoverlay:		overlay.o $(LIB)
X		cc -o overlay overlay.o $(LIB) $(BITLIB)
X
Xzoom:		zoom.o $(LIB) $(MGR)/bitmaphead.o $(MGR)/bitmapread.o
X		cc -o zoom zoom.o $(LIB) \
X			$(MGR)/bitmaphead.o $(MGR)/bitmapread.o $(BITLIB)
X
Xmclock:		mclock.o $(LIB) 
X		cc -o mclock mclock.o $(LIB)
X
Xcycle:		cycle.o  $(LIB)
X		cc -o cycle cycle.o $(LIB)
X
Xwindow_print:	window_print.o  $(LIB)
X		cc -o window_print window_print.o $(LIB)
X
Xinvert_colormap:	invert_colormap.o
X		cc -o invert_colormap invert_colormap.o -lpixrect
X
Xset_colormap:	set_colormap.o
X		cc -o set_colormap set_colormap.o -lpixrect
X
Xtj3:		tj3.o  $(LIB)
X		cc -o tj3 tj3.o $(LIB)
X
Xtj2:		tj2.o  $(LIB)
X		cc -o tj2 tj2.o $(LIB)
X
Xtj:		tj.o  $(LIB)
X		cc -o tj tj.o $(LIB)
X
Xflip:		flip.o 
X		cc -o flip flip.o
X
Xrotate:		rotate.o 
X		cc -o rotate rotate.o
X
Xtjfilter:	tjfilter.o 
X		cc -o tjfilter tjfilter.o
X
Xget_header:	get_header.o 
X		cc -o get_header get_header.o
X
Xcpp_filter:	cpp_filter.o
X		cc -o cpp_filter cpp_filter.o
X
X$(ALL):		$(INCL)/term.h
X
Xinstall:	all $(INSDIR)
X		cd $(INSDIR);  rm -f $(ALL)
X		cp $(ALL) $(INSDIR)
X
Xsmallinstall:	small $(INSDIR)
X		cd $(INSDIR);  rm -f $(SMALL)
X		cp $(SMALL) $(INSDIR)
X
X$(INSDIR):
X		mkdir $@
X
Xclean:	
X		rm -f *.o core
X
Xclobber:
X		rm -f $(ALL)
X
Xlist:
X	@for i in ${CFILES} ${HFILES} ${OTHER}; do \
X		echo "${START}/$$i"; \
X	done	
X
Xcpio:
X	make -s list | cpio -ocv > ${CPIO}
END_OF_FILE
# end of 'demo/icon/Makefile'
fi
if test -f 'demo/icon/mclock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/icon/mclock.c'\"
else
echo shar: Extracting \"'demo/icon/mclock.c'\" \(3712 characters\)
sed "s/^X//" >'demo/icon/mclock.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: mclock.c,v 4.1 88/06/21 14:00:05 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/icon/RCS/mclock.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/icon/RCS/mclock.c,v $$Revision: 4.1 $";
X
X/* by sdh */
X
X#include <sys/time.h>
X#include <stdio.h>
X#include <signal.h>
X#include "term.h"
X
X#define SCREEN 0
X#define MINS 1
X#define MASKMINS 13
X#define HRS 25
X#define MASKHRS 37
X#define FACE 49
X#define SCRATCH 50
X#define ICONPATH	"mouse"
X
Xstatic char *_quit = "\034";
X
Xint x, y, w, firstw, h, firsth, i, j, k;
Xint hsize, vsize;
X
Xcleanup()
X{
X	m_clear();
X	m_pop();
X	exit(0);
X}
X
Xclearit()
X{
X	m_clear();
X	do_time();
X}
X
Xshapeit()
X{
X	int	border;
X
X	get_size(&x, &y, &hsize, &vsize);
X	get_param( (char *)0, (int *)0, (int *)0, &border );
X	m_shapewindow(x, y, w + 2*border, h + 2*border);
X}
X
X
Xmain(argc,argv)
Xchar **argv;
X{
X	register int s = 0;
X	int speed = 1;
X	char buf[101];
X
X	ckmgrterm( *argv );
X
X	m_setup(M_FLUSH);
X	m_push(P_BITMAP | P_EVENT | P_FLAGS | P_POSITION);
X	m_setmode(M_ABS);
X
X	if (argc>1 && strcmp(argv[1],"-s")==0)
X		speed++;
X
X
X	signal(SIGINT,cleanup);
X	signal(SIGTERM,cleanup);
X	signal(SIGQUIT,clearit);
X
X	m_setevent(RESHAPE,_quit);
X	m_setevent(REDRAW,_quit);
X	
X	m_ttyset(); /* no echo */
X	fprintf(stderr,"Please wait...");
X	fflush(stderr);
X	for (i = 0; i < 12; i++) {
X	/* load all the hands and their masks */
X		sprintf(buf, "%s/mhand%d",ICONPATH, i);
X		m_bitfile(i+MINS, buf, &w, &h);
X		panic(); /* if the dimensions are wrong, panic and exit */
X		sprintf(buf, "%s/mmhand%d",ICONPATH, i);
X		m_bitfile(i+MASKMINS, buf, &w, &h);
X		panic();
X		sprintf(buf, "%s/hhand%d",ICONPATH, i);
X		m_bitfile(i+HRS, buf, &w, &h);
X		panic();
X		sprintf(buf, "%s/mhhand%d",ICONPATH, i);
X		m_bitfile(i+MASKHRS, buf, &w, &h);
X		panic();
X	}
X	sprintf(buf, "%s/mickface",ICONPATH); /* get the face */
X	m_bitfile(FACE, buf, &w, &h);
X	panic();
X	m_ttyreset();/* reset echo */
X	shapeit();
X	clearit();
X	while(1) {
X		m_flush();
X		do_time();
X		sleep(15); /* update only every 15 seconds */
X	}
X}
X
Xdo_time()
X{
X	struct tm *tme, *localtime();
X	long tmp, time();
X	int hr, mn, mn1;
X
X	tmp = time(0);
X	tme = localtime(&tmp); /* get the time */
X
X	mn = tme->tm_min;
X	hr = (tme->tm_hour > 11 ? tme->tm_hour - 12 : tme->tm_hour);
X	/* set hours to be 0-11 */
X	mn1 = ( (mn/5) + (mn % 5 < 3 ? 0 : 1));
X	/* adjust minutes so that 10:03 will read as 10:05 to help accuracy */
X	if (mn > 33) hr++;
X	/* move hour hand when minute hand is on 7 so that 7:45 will look ok */
X	mn1 %= 12; /* fix minutes to be 0-11 */
X	hr %= 12; /* fix hours to be 0-11 */
X
X	m_func(B_COPY);
X	m_bitcopyto(0, 0, w, h, 0, 0, SCRATCH, FACE); /* copy face */
X	m_func(B_AND);
X	m_bitcopyto(0, 0, w, h, 0, 0, SCRATCH, MASKHRS + hr); /* mask of hour */
X	m_func(B_OR);
X	m_bitcopyto(0, 0, w, h, 0, 0, SCRATCH, HRS + hr); /* OR hour in */
X	m_func(B_AND);
X	m_bitcopyto(0, 0, w, h, 0, 0, SCRATCH, MASKMINS + mn1); /* mask minutes */
X	m_func(B_OR);
X	m_bitcopyto(0, 0, w, h, 0, 0, SCRATCH, MINS + mn1); /* OR in minute hand */
X	m_func(B_COPY);
X	m_bitcopyto(0, 0, w, h, 0, 0, SCREEN, SCRATCH); /* put on screen */
X}
X
Xpanic()
X{
X	if( !firstw )
X		firstw = w;
X	if( !firsth )
X		firsth = h;
X	if( !w  ||  !h  ||  w != firstw  ||  h != firsth ) {
X		m_ttyreset();
X		fprintf(stderr, "%d %d\n", w, h );
X		fprintf(stderr, "bitmap size mismatch: bitmaps may be bad.\n");
X		exit(0);
X	}
X}
END_OF_FILE
# end of 'demo/icon/mclock.c'
fi
if test -f 'doc/usrman/croff/mktable.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/usrman/croff/mktable.c'\"
else
echo shar: Extracting \"'doc/usrman/croff/mktable.c'\" \(3609 characters\)
sed "s/^X//" >'doc/usrman/croff/mktable.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: mktable.c,v 1.1 88/07/07 10:12:17 sau Exp $
X	$Source: /tmp/mgrsrc/doc/usrman/croff/RCS/mktable.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/doc/usrman/croff/RCS/mktable.c,v $$Revision: 1.1 $";
X
X/* make a compile time hash table  (SAU)
X *
X * usage: mktable <name> <size>
X *
X */
X
X#include <stdio.h>
X#include "hash.h"
X
X#define SIZE		71
X#define MIN_SIZE	5
X
Xchar key[80];
Xchar value[80];
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   register int i,code, count = 0;
X   char *malloc(), *sprintf();
X   TABLE **table;			/* place to build hash table into */
X   register TABLE *list, *next;
X   char *name;				/* name of table */
X   char *prog = *argv;
X   int len=0, size;
X   char tmp[80];
X
X   int r_flag = 0;			/* reverse sense of keyword-value */
X   int n_flag = 0;			/* no values */
X   
X   for(;argc>1 && *argv[1]=='-';argv++,argc--) 
X      switch(argv[1][1]) {
X         case 'r': r_flag++; break;
X         case 'n': case '1': n_flag++; *value='\0'; break;
X         default : fprintf(stderr,"%s: flag %s ignored\n",prog,argv[1]);
X         }
X
X   if (argc < 3) {
X      fprintf(stderr,"usage: %s [-r -n] <name> <number of buckets>\n",prog);
X      exit(1);
X      }
X
X   name = argv[1];
X
X   if ((size = atoi(argv[2])) < MIN_SIZE) 
X      size = SIZE;
X 
X   if ((table = (TABLE **) malloc(size * sizeof(TABLE))) == NULL) {
X      perror("Can't alloc space for table");
X      exit(1);
X      }
X
X   bzero(table,size*sizeof(TABLE));
X
X   /* build the hash table */
X
X   while(1) {
X      if (n_flag)
X         code = scanf("%s\n",key);
X      else if (r_flag)
X         code = scanf("%s %s\n",value,key);
X      else
X         code = scanf("%s %s\n",key,value);
X
X      if (code == EOF)
X         break;
X      add_entry(table,size,key);
X      put_entry(table,size,key,value);
X      count++;
X      }
X
X   /* print out data */
X
X   printf("/* hash table: %d items in %d buckets */\n\n",count,size);
X   printf("#include <stdio.h>\n");
X   printf("#include \"hash.h\"\n\n");
X   printf("#define SIZE_%s	%d\n\n",name,size);
X   printf("struct table_entry %s_data[] = {\n",name);
X
X   for(count=0,i=0;i<size;i++) {
X      for(code=0,list=table[i];list != (TABLE *) 0; list = next,count++) {
X         next = list->next;
X         printf("   {\"%s\", \"%s\", %d, 0x%x, %s},",
X               list->name, list->value, list->count, HASH_STATIC,
X               next ? sprintf(tmp,"&%s_data[%d]",name,count+1) : "NULL");
X         if (code++ == 0)
X            printf("	/*  %d */\n",i);
X         else
X            printf("\n");
X         }
X      }
X   printf("   };\n\n");
X
X   /* print out hash table */
X
X   printf("/* hash table: %d items */\n\n",size);
X   printf("struct table_entry *%s[] = {\n  ",name);
X
X   for(len=2,code=count=i=0;i<size;i++) {
X      for(list=table[i]; list != (TABLE *) 0; list = list->next) {
X         count++;
X         code++;
X         }
X      if (code) {
X         sprintf(tmp," &%s_data[%d],",name,count-code);
X         code = 0; 
X         }
X      else
X         sprintf(tmp," NULL,");
X
X      len += strlen(tmp);
X
X      if (len > 78) {
X         printf("\n  ");
X         len = 2 + strlen(tmp);
X         }
X      
X      printf("%s",tmp);
X      }
X   if (len)
X      printf("\n  ");
X   printf(" };\n\n");
X   }
END_OF_FILE
# end of 'doc/usrman/croff/mktable.c'
fi
if test -f 'font-16/Ucmr10x16b' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-16/Ucmr10x16b'\"
else
echo shar: Extracting \"'font-16/Ucmr10x16b'\" \(3570 characters\)
sed "s/^X//" >'font-16/Ucmr10x16b' <<'END_OF_FILE'
Xbegin 644 cmr10x16b.fnt
XM%@H0!8                 _S_AP'#_@                            
XM        &                     ,                             
XM                                                            
XM                                       #_O\& ^!P?S_G\=P^'^_X
XM<!P_X<!P  V  =P   /@<          #\   !P  ;'\<P<!P!@P         
XM#!P' \#P!@_!X?P^!P        #X  </X'S\/\_P^/^/@?/^^!C/>/C^'P_ 
XM_'\_[_O>_[_G\/A@#X&   P #P  '@ !X #P!P#CP                   
XM      !\&#X  _YS!@=P<'\=QS/^'#_/^' <..' <#X-@ '<   &,'      
XM     _    </\&S?/\/@< P&          P^'P-AF X/@_'X<P^    &  8!
XMW#@'!W#\=AS',?AW!P#AV' 8Q['<=SN'89Q_',<QC',<QG# 8 &!@  8  < 
XM  X  [  < < X< \            &           X!@'!W/^< 8'<'!C'<.#
XM=AP?[_AP'#CC -@<!P?P    !C!P          /    '#_!LVS^#L# 8 P& 
XM       8-@<'<=P.# ?QF',=P   #  # =QL!P=PS'<<!P&8=P< X?!P'<>Q
XMW'<[AW&,?QS',8P^#X#@P# !@\  '  '   .  .P '    ' '           
XM !@          . 8!P_C_A@&!W!P8QW#@W8^/\_X<!PXX           '\]X
XM   #       #P   !P_S_O@_@[!@. .'X&      &'<'!W'<'@P' #!S'<' 
XM<!@  8 8Q@<'<<QSG <#F'<' .'@<!W'\=QW.X=QP!P<P^'\/ ^ X, P 8?@
XM !P_!\!\/@\/X'Q^#P'A_!P]S^!P_ _'X?C_/\_[G/^_Y_#@& <-P_XP!@?P
XM^'\=P<!P?Q_O^' <..           !_-V    8       ^    <&8-CX'P/@
XM #@#@\!@     #!W!P!P.#X/!\ P/AW!P' P/\# ,-\/AW' <Y\'PX!W!P#A
XM\' =Q_'<=SN'8? <',/A_!P' <# & &-L   .X=@_&X=@X#<=P< X? <'^=P
XMV'89P_,8.!W',YP^'<;@X!@'  /^_X8'\/A_'<' <'\_S_AP'#C@        
XM   W;-@  #_@      /@   '!F#8? ,!P  X X_P8      P=P< 8'!N#8?@
XM,!X=P   8   8'#W#X?AP'.?!\. ?P< X?!P'<;QW'X[A\#X'!S#X?P<!P' 
XMP!@!@8    .'<<#N.<.!W'<' .'@'!_G<=QW.<.#@#@=QS.</ S X\ 8 \ #
XM_C &!_#X8QW!@'!_'^_X<!PXX           -VW8   !@      #P   !P  
XMV!X'P_@ . .#P_P '\  8'<' , 8;@''<' _#\   #   ,!P]P^',<!SGP?#
XM_'<' .'P<!_&\=QP.X? /!P<P>'<' <!P, , 8&    /AW' [C_#@=QW!P#A
XM\!P?YW'<=SG#@? X'</C_!P/@<#@& <  _X8'X=P^  =P8!P/C_/^' <..  
XM         #=O>    P      !\       _X>!^;P #@#A^!@     &!W!P&!
XMW/\!QW!P9P?    8/\& <-\/ASG,<YP' [AW!P#A^' ?QG'<<#N'X!P<','!
XMW!X' X# # &!@   'X=QP.XX X'<=P< X? <'^=QW'<YPX#X.QW#X_P<!P' 
XMX!@'  /^  \'<9QC'<, <!P?[_AP'#C@           W9C            ? 
XM      &P_@_NX  8 P& 8!@  8# -@<#,=P.'<=P<&<9P   #  #  # &<<X
XMS'<<!P&X=P<'X?AP'\9QW' _A^&,'!S!P=P^!P. P 8!@8   #O'<<#N. .!
XMW'<' .'X'!SG<=QW.<.#'#L=P^/\'@,#@. 8!P #_@ &!W&<?QW#,' </\_X
XM<!PXX           '\8P           'P   !P !L/X/[N  # 8  & \  / 
XMP#X'!_&8#AV'X'!F'X' < 8 !@!P9AG'./AV',<!^'<'!^'<<QC&,=QP/X=Y
XMW!P/@<&,9P<',, & 8&    [QV#L;AS#@-QW!P#A^!P<YW#8=AG#@XP['<'#
XM_#<& [#@& <  _X !@/C_G\_Y_#X/A_O^' <..           !_#X       
XM    !_    <  ;!\&<;P  8,    /  #P8 <'\?P\!\/ \!P/ \!P'      
XM<#P_[_!P_#_/@/C_CX/#_O\][S#X^!_/N?@^!P'!C/^/A_#X P^!@_X '\? 
XM>#\/A\!\_X^ X_X^/^_X<'P/Q\/X'@_@PYS_A@?P?!@^  /^            
XM   _S_AP'#C@                                    &  #F       
XM !P  8                     P                                
XM   #P                     /^            '    .        !P <  
XM          8        #_@              '^_X<!PXX               
XM    !_                             8                        
XM8                                                           
XM             =P   ?@        < '            <         _X     
XM         #_/^' </^                                          
XM        ,                                                   
XM                                              #X   'P       
XM /@#P           '         /^               ?[_AP'#_@        
XM                                                            
XM                                                            
XM                                                           #
X!_@  
X 
Xend
END_OF_FILE
# end of 'font-16/Ucmr10x16b'
fi
if test -f 'font-16/Ucmr10x16bI' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-16/Ucmr10x16bI'\"
else
echo shar: Extracting \"'font-16/Ucmr10x16bI'\" \(3571 characters\)
sed "s/^X//" >'font-16/Ucmr10x16bI' <<'END_OF_FILE'
Xbegin 644 cmr10x16bI.fnt
XM%@H0!8  _______________ , >/X\ ?___________________________\
XM   _____Y_____________________S_____________________________
XM____________________________________________________________
XM_______________________________________\ 0#Y_!^/@, 8#B/!X! '
XMC^/ 'C^/__)__B/___P?C__________\#   ./__DX#C/C^/^?/_________
XM\^/X_#\/^? ^'@/!^/________\'__CP'X,#P# /!P!P?@P!!^<PAP<!X/ _
XM X# $ 0A $ 8#P>?\'Y___/_\/__X?_^'_\/^/\</___________________
XM______^#Y\'__ &,^?B/CX#B.,P!X\ P!X_CQQX_C\'R?_XC___YSX______
XM_____ P  #CP#Y,@P#P?C_/Y__________/!X/R>9_'P? X'C/!____Y__G^
XM(\?X^(\#B>,XS@>(^/\>)X_G.$XCB,1XGF. XSC.<XSC.8\_G_Y^?__G__C_
XM__'__$__C_C_'C_#____________Y___________'^?X^(P!C_GXCX^<XCQ\
XMB>/@$ >/X\<<_R?C^/@/____^<^/__________P\   X\ ^3),!\3\_G_/Y_
XM_______GR?CXCB/Q\_@.9XSB/___\__\_B.3^/B/,XCC^/YGB/C_'@^/XCA.
XM(XC$>(YS@.,XSG/!\'\?/\_^?#__X__X___Q__Q/_X____X_X___________
XM_^?__________Q_G^/ < >?Y^(^/G.(\?(G!P# 'C^/''___________X#"'
XM___\_______\/   ./ , 0? ?$^?Q_QX'Y______YXCX^(XCX?/X_\^,XCX_
XMC^?__G_G.?CXCC.,8_C\9XCX_QX?C^(X#B.(Q'B./^/C/!X#P_!_'S_/_G@?
XM_^/ ^#^#P?#P'X.!\/X> ^/",!^/ _ X'@< P# $8P! & \?Y_CR/ '/^?@/
XM!X#B/C^/@. 0!X_CQQ___________^ R)____G_______!P  #CYGR<'X/P?
XM_\?\?#^?_____\^(^/^/Q\'P^#_/P>(^/X_/P#\_SR#P>(X_C&#X/'^(^/\>
XM#X_B. XCB,1XG@_CXSP> ^/X_C\_Y_YR3___Q'B? Y'B?'\CB/C_'@_CX!B/
XM)XGF/ SGQ^(XS&/!XCD?'^?X__P! 'GX#P> XCX_CX# , >/X\<?________
XM___(DR?__\ ?______P<   X^9\G@_S^/__'_' /G______/B/C_GX^1\G@?
XMS^'B/___G___GX\(\'@>/XQ@^#Q_@/C_'@^/XCD.(X'$>#\'X^,\'@/C^/X_
XM/^?^?G____QXCC\1QCQ^(XCX_QX?X^ 8CB.(QCQ\?\?B.,QCP_,_'#_G_#_\
XM <_Y^ \'G.(^?X^ X! 'C^/''___________R)(G___^?______\/   ./__
XM)^'X/ ?_Q_Q\/ /_X#__GXCX_S_GD?XXCX_ \#___\___S^/"/!XSC^,8/@\
XM XCX_QX/C^ Y#B./Q'@_P^/C/AXCX_C^/S_S_GY____P>(X_$< \?B.(^/\>
XM#^/@&(XCB,8\?@_'XCP< ^/P?C\?Y_C__ 'GX'B/!__B/G^/P< P!X_CQQ__
XM_________\B0A____/______^#P  #___ 'A^!D/_\?\>!^?_____Y^(^/Y^
XM(P#^.(^/F/@____GP#Y_CR#P>,8SC&/X_$>(^/\>!X_@.8XCC\1X'^/CXSX^
XM(^'X_'\_\_Y^?___X'B./Q''_'XCB/C_'@_CX!B.(XC&/'\'Q.(\' /C^/X_
XM'^?X__P!__#XCF.<XCS_C^/@$ >/X\<?___________(F<____________@\
XM   ___Y/ ? 1'__G_/Y_G^?__G\_R?C\SB/QXCB/CYCF/___\__\__\_YCC'
XM,XCC^/Y'B/CX'@>/X#F.(X_ >!YSX^,^/B/!^/Q_/_G^?G___\0XCC\1Q_Q^
XM(XCX_QX'X^,8CB.(QCQ\X\3B/!P#X?S\?Q_G^/_\ ?_Y^(YC@.(\SX_CP# '
XMC^/''___________X#G/___________X/   ./_^3P'P$1__\_G__Y_#__P_
XM/\'X^ YG\>)X'X^9X'X_C_G_^?^/F>8XQP>)XSC^!XCX^!XCC.<YSB./P'B&
XM(^/P?CYSF/CXSS_Y_GY____$.)\3D>,\?R.(^/\>!^/C&(\GB>8\?'/$XCX\
XM \CY_$\?Y_C__ '_^?P< 8# & \'P> 0!X_CQQ___________^ \'_______
XM____^ P  #C__D^#YCD/__GS____P__\/G_CX#@/#^#P_#^/P_#^/X______
XMC\/ $ ^/ \ P?P< <'P\ 0#"$,\'!^ P1@?!^/X^<P!P> \'_/!^? '_X#@_
XMA\#P>#^# '!_' '!P! 'CX/P.#P'X? ?/&, >?@/@^?!__P!____________
XM___ , >/X\<?___________________________\   _____Y__\9_______
XM_^/__G_____________________/________________________________
XM___\/_____________________P!____________X____Q________^/_C__
XM__________G________\ ?______________X! 'C^/''_______________
XM____^ _______   /__________________G________________________
XMG___________________________________________________________
XM_____________B/___@?________C_X____________C_________ '_____
XM_________\ P!X_CP!____________________________P  #__________
XM________S___________________________________________________
XM______________________________________________\'___X/_______
XM_P?\/___________X_________P!_______________@$ >/X\ ?________
XM___________________\   _____________________________________
XM____________________________________________________________
XM___________________________________________________________\
X! ?__
X 
Xend
END_OF_FILE
# end of 'font-16/Ucmr10x16bI'
fi
if test -f 'font-16/Ucmr10x16bu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-16/Ucmr10x16bu'\"
else
echo shar: Extracting \"'font-16/Ucmr10x16bu'\" \(3571 characters\)
sed "s/^X//" >'font-16/Ucmr10x16bu' <<'END_OF_FILE'
Xbegin 644 cmr10x16bu.fnt
XM%@H0!8                 _S_AP'#_@                            
XM        &                     ,                             
XM                                                            
XM                                       #_O\& ^!P?S_G\=P^'^_X
XM<!P_X<!P  V  =P   /@<          #\   !P  ;'\<P<!P!@P         
XM#!P' \#P!@_!X?P^!P        #X  </X'S\/\_P^/^/@?/^^!C/>/C^'P_ 
XM_'\_[_O>_[_G\/A@#X&   P #P  '@ !X #P!P#CP                   
XM      !\&#X  _YS!@=P<'\=QS/^'#_/^' <..' <#X-@ '<   &,'      
XM     _    </\&S?/\/@< P&          P^'P-AF X/@_'X<P^    &  8!
XMW#@'!W#\=AS',?AW!P#AV' 8Q['<=SN'89Q_',<QC',<QG# 8 &!@  8  < 
XM  X  [  < < X< \            &           X!@'!W/^< 8'<'!C'<.#
XM=AP?[_AP'#CC -@<!P?P    !C!P          /    '#_!LVS^#L# 8 P& 
XM       8-@<'<=P.# ?QF',=P   #  # =QL!P=PS'<<!P&8=P< X?!P'<>Q
XMW'<[AW&,?QS',8P^#X#@P# !@\  '  '   .  .P '    ' '           
XM !@          . 8!P_C_A@&!W!P8QW#@W8^/\_X<!PXX           '\]X
XM   #       #P   !P_S_O@_@[!@. .'X&      &'<'!W'<'@P' #!S'<' 
XM<!@  8 8Q@<'<<QSG <#F'<' .'@<!W'\=QW.X=QP!P<P^'\/ ^ X, P 8?@
XM !P_!\!\/@\/X'Q^#P'A_!P]S^!P_ _'X?C_/\_[G/^_Y_#@& <-P_XP!@?P
XM^'\=P<!P?Q_O^' <..           !_-V    8       ^    <&8-CX'P/@
XM #@#@\!@     #!W!P!P.#X/!\ P/AW!P' P/\# ,-\/AW' <Y\'PX!W!P#A
XM\' =Q_'<=SN'8? <',/A_!P' <# & &-L   .X=@_&X=@X#<=P< X? <'^=P
XMV'89P_,8.!W',YP^'<;@X!@'  /^_X8'\/A_'<' <'\_S_AP'#C@        
XM   W;-@  #_@      /@   '!F#8? ,!P  X X_P8      P=P< 8'!N#8?@
XM,!X=P   8   8'#W#X?AP'.?!\. ?P< X?!P'<;QW'X[A\#X'!S#X?P<!P' 
XMP!@!@8    .'<<#N.<.!W'<' .'@'!_G<=QW.<.#@#@=QS.</ S X\ 8 \ #
XM_C &!_#X8QW!@'!_'^_X<!PXX           -VW8   !@      #P   !P  
XMV!X'P_@ . .#P_P '\  8'<' , 8;@''<' _#\   #   ,!P]P^',<!SGP?#
XM_'<' .'P<!_&\=QP.X? /!P<P>'<' <!P, , 8&    /AW' [C_#@=QW!P#A
XM\!P?YW'<=SG#@? X'</C_!P/@<#@& <  _X8'X=P^  =P8!P/C_/^' <..  
XM         #=O>    P      !\       _X>!^;P #@#A^!@     &!W!P&!
XMW/\!QW!P9P?    8/\& <-\/ASG,<YP' [AW!P#A^' ?QG'<<#N'X!P<','!
XMW!X' X# # &!@   'X=QP.XX X'<=P< X? <'^=QW'<YPX#X.QW#X_P<!P' 
XMX!@'  /^  \'<9QC'<, <!P?[_AP'#C@           W9C            ? 
XM      &P_@_NX  8 P& 8!@  8# -@<#,=P.'<=P<&<9P   #  #  # &<<X
XMS'<<!P&X=P<'X?AP'\9QW' _A^&,'!S!P=P^!P. P 8!@8   #O'<<#N. .!
XMW'<' .'X'!SG<=QW.<.#'#L=P^/\'@,#@. 8!P #_@ &!W&<?QW#,' </\_X
XM<!PXX           '\8P           'P   !P !L/X/[N  # 8  & \  / 
XMP#X'!_&8#AV'X'!F'X' < 8 !@!P9AG'./AV',<!^'<'!^'<<QC&,=QP/X=Y
XMW!P/@<&,9P<',, & 8&    [QV#L;AS#@-QW!P#A^!P<YW#8=AG#@XP['<'#
XM_#<& [#@& <  _[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[
XM_O^_[_O^ #_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[
XM_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[
XM_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[
XM_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_@ _[_O^_[_O^_[_O^_[
XM_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[
XM_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[
XM_O^_[_O^_[_O^_[_O^_[_@              '^_X<!PXX               
XM    !_                             8                        
XM8                                                           
XM             =P   ?@        < '            <         _X     
XM         #_/^' </^                                          
XM        ,                                                   
XM                                              #X   'P       
XM /@#P           '         /^               ?[_AP'#_@        
XM                                                            
XM                                                            
XM                                                           #
X!_@  
X 
Xend
END_OF_FILE
# end of 'font-16/Ucmr10x16bu'
fi
if test -f 'font-32/Ucmr10x16b' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-32/Ucmr10x16b'\"
else
echo shar: Extracting \"'font-32/Ucmr10x16b'\" \(3570 characters\)
sed "s/^X//" >'font-32/Ucmr10x16b' <<'END_OF_FILE'
Xbegin 644 cmr10x16b.fnt
XM& H0!8                 _S_AP'#_@                            
XM        &                     ,                             
XM                                                            
XM                                       #_O\& ^!P?S_G\=P^'^_X
XM<!P_X<!P  V  =P   /@<          #\   !P  ;'\<P<!P!@P         
XM#!P' \#P!@_!X?P^!P        #X  </X'S\/\_P^/^/@?/^^!C/>/C^'P_ 
XM_'\_[_O>_[_G\/A@#X&   P #P  '@ !X #P!P#CP                   
XM      !\&#X  _YS!@=P<'\=QS/^'#_/^' <..' <#X-@ '<   &,'      
XM     _    </\&S?/\/@< P&          P^'P-AF X/@_'X<P^    &  8!
XMW#@'!W#\=AS',?AW!P#AV' 8Q['<=SN'89Q_',<QC',<QG# 8 &!@  8  < 
XM  X  [  < < X< \            &           X!@'!W/^< 8'<'!C'<.#
XM=AP?[_AP'#CC -@<!P?P    !C!P          /    '#_!LVS^#L# 8 P& 
XM       8-@<'<=P.# ?QF',=P   #  # =QL!P=PS'<<!P&8=P< X?!P'<>Q
XMW'<[AW&,?QS',8P^#X#@P# !@\  '  '   .  .P '    ' '           
XM !@          . 8!P_C_A@&!W!P8QW#@W8^/\_X<!PXX           '\]X
XM   #       #P   !P_S_O@_@[!@. .'X&      &'<'!W'<'@P' #!S'<' 
XM<!@  8 8Q@<'<<QSG <#F'<' .'@<!W'\=QW.X=QP!P<P^'\/ ^ X, P 8?@
XM !P_!\!\/@\/X'Q^#P'A_!P]S^!P_ _'X?C_/\_[G/^_Y_#@& <-P_XP!@?P
XM^'\=P<!P?Q_O^' <..           !_-V    8       ^    <&8-CX'P/@
XM #@#@\!@     #!W!P!P.#X/!\ P/AW!P' P/\# ,-\/AW' <Y\'PX!W!P#A
XM\' =Q_'<=SN'8? <',/A_!P' <# & &-L   .X=@_&X=@X#<=P< X? <'^=P
XMV'89P_,8.!W',YP^'<;@X!@'  /^_X8'\/A_'<' <'\_S_AP'#C@        
XM   W;-@  #_@      /@   '!F#8? ,!P  X X_P8      P=P< 8'!N#8?@
XM,!X=P   8   8'#W#X?AP'.?!\. ?P< X?!P'<;QW'X[A\#X'!S#X?P<!P' 
XMP!@!@8    .'<<#N.<.!W'<' .'@'!_G<=QW.<.#@#@=QS.</ S X\ 8 \ #
XM_C &!_#X8QW!@'!_'^_X<!PXX           -VW8   !@      #P   !P  
XMV!X'P_@ . .#P_P '\  8'<' , 8;@''<' _#\   #   ,!P]P^',<!SGP?#
XM_'<' .'P<!_&\=QP.X? /!P<P>'<' <!P, , 8&    /AW' [C_#@=QW!P#A
XM\!P?YW'<=SG#@? X'</C_!P/@<#@& <  _X8'X=P^  =P8!P/C_/^' <..  
XM         #=O>    P      !\       _X>!^;P #@#A^!@     &!W!P&!
XMW/\!QW!P9P?    8/\& <-\/ASG,<YP' [AW!P#A^' ?QG'<<#N'X!P<','!
XMW!X' X# # &!@   'X=QP.XX X'<=P< X? <'^=QW'<YPX#X.QW#X_P<!P' 
XMX!@'  /^  \'<9QC'<, <!P?[_AP'#C@           W9C            ? 
XM      &P_@_NX  8 P& 8!@  8# -@<#,=P.'<=P<&<9P   #  #  # &<<X
XMS'<<!P&X=P<'X?AP'\9QW' _A^&,'!S!P=P^!P. P 8!@8   #O'<<#N. .!
XMW'<' .'X'!SG<=QW.<.#'#L=P^/\'@,#@. 8!P #_@ &!W&<?QW#,' </\_X
XM<!PXX           '\8P           'P   !P !L/X/[N  # 8  & \  / 
XMP#X'!_&8#AV'X'!F'X' < 8 !@!P9AG'./AV',<!^'<'!^'<<QC&,=QP/X=Y
XMW!P/@<&,9P<',, & 8&    [QV#L;AS#@-QW!P#A^!P<YW#8=AG#@XP['<'#
XM_#<& [#@& <  _X !@/C_G\_Y_#X/A_O^' <..           !_#X       
XM    !_    <  ;!\&<;P  8,    /  #P8 <'\?P\!\/ \!P/ \!P'      
XM<#P_[_!P_#_/@/C_CX/#_O\][S#X^!_/N?@^!P'!C/^/A_#X P^!@_X '\? 
XM>#\/A\!\_X^ X_X^/^_X<'P/Q\/X'@_@PYS_A@?P?!@^  /^            
XM   _S_AP'#C@                                    &  #F       
XM !P  8                     P                                
XM   #P                     /^            '    .        !P <  
XM          8        #_@              '^_X<!PXX               
XM    !_                             8                        
XM8                                                           
XM             =P   ?@        < '            <         _X     
XM         #_/^' </^                                          
XM        ,                                                   
XM                                              #X   'P       
XM /@#P           '         /^               ?[_AP'#_@        
XM                                                            
XM                                                            
XM                                                           #
X!_@  
X 
Xend
END_OF_FILE
# end of 'font-32/Ucmr10x16b'
fi
if test -f 'font-32/Ucmr10x16bI' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-32/Ucmr10x16bI'\"
else
echo shar: Extracting \"'font-32/Ucmr10x16bI'\" \(3571 characters\)
sed "s/^X//" >'font-32/Ucmr10x16bI' <<'END_OF_FILE'
Xbegin 644 cmr10x16bI.fnt
XM& H0!8  _______________ , >/X\ ?___________________________\
XM   _____Y_____________________S_____________________________
XM____________________________________________________________
XM_______________________________________\ 0#Y_!^/@, 8#B/!X! '
XMC^/ 'C^/__)__B/___P?C__________\#   ./__DX#C/C^/^?/_________
XM\^/X_#\/^? ^'@/!^/________\'__CP'X,#P# /!P!P?@P!!^<PAP<!X/ _
XM X# $ 0A $ 8#P>?\'Y___/_\/__X?_^'_\/^/\</___________________
XM______^#Y\'__ &,^?B/CX#B.,P!X\ P!X_CQQX_C\'R?_XC___YSX______
XM_____ P  #CP#Y,@P#P?C_/Y__________/!X/R>9_'P? X'C/!____Y__G^
XM(\?X^(\#B>,XS@>(^/\>)X_G.$XCB,1XGF. XSC.<XSC.8\_G_Y^?__G__C_
XM__'__$__C_C_'C_#____________Y___________'^?X^(P!C_GXCX^<XCQ\
XMB>/@$ >/X\<<_R?C^/@/____^<^/__________P\   X\ ^3),!\3\_G_/Y_
XM_______GR?CXCB/Q\_@.9XSB/___\__\_B.3^/B/,XCC^/YGB/C_'@^/XCA.
XM(XC$>(YS@.,XSG/!\'\?/\_^?#__X__X___Q__Q/_X____X_X___________
XM_^?__________Q_G^/ < >?Y^(^/G.(\?(G!P# 'C^/''___________X#"'
XM___\_______\/   ./ , 0? ?$^?Q_QX'Y______YXCX^(XCX?/X_\^,XCX_
XMC^?__G_G.?CXCC.,8_C\9XCX_QX?C^(X#B.(Q'B./^/C/!X#P_!_'S_/_G@?
XM_^/ ^#^#P?#P'X.!\/X> ^/",!^/ _ X'@< P# $8P! & \?Y_CR/ '/^?@/
XM!X#B/C^/@. 0!X_CQQ___________^ R)____G_______!P  #CYGR<'X/P?
XM_\?\?#^?_____\^(^/^/Q\'P^#_/P>(^/X_/P#\_SR#P>(X_C&#X/'^(^/\>
XM#X_B. XCB,1XG@_CXSP> ^/X_C\_Y_YR3___Q'B? Y'B?'\CB/C_'@_CX!B/
XM)XGF/ SGQ^(XS&/!XCD?'^?X__P! 'GX#P> XCX_CX# , >/X\<?________
XM___(DR?__\ ?______P<   X^9\G@_S^/__'_' /G______/B/C_GX^1\G@?
XMS^'B/___G___GX\(\'@>/XQ@^#Q_@/C_'@^/XCD.(X'$>#\'X^,\'@/C^/X_
XM/^?^?G____QXCC\1QCQ^(XCX_QX?X^ 8CB.(QCQ\?\?B.,QCP_,_'#_G_#_\
XM <_Y^ \'G.(^?X^ X! 'C^/''___________R)(G___^?______\/   ./__
XM)^'X/ ?_Q_Q\/ /_X#__GXCX_S_GD?XXCX_ \#___\___S^/"/!XSC^,8/@\
XM XCX_QX/C^ Y#B./Q'@_P^/C/AXCX_C^/S_S_GY____P>(X_$< \?B.(^/\>
XM#^/@&(XCB,8\?@_'XCP< ^/P?C\?Y_C__ 'GX'B/!__B/G^/P< P!X_CQQ__
XM_________\B0A____/______^#P  #___ 'A^!D/_\?\>!^?_____Y^(^/Y^
XM(P#^.(^/F/@____GP#Y_CR#P>,8SC&/X_$>(^/\>!X_@.8XCC\1X'^/CXSX^
XM(^'X_'\_\_Y^?___X'B./Q''_'XCB/C_'@_CX!B.(XC&/'\'Q.(\' /C^/X_
XM'^?X__P!__#XCF.<XCS_C^/@$ >/X\<?___________(F<____________@\
XM   ___Y/ ? 1'__G_/Y_G^?__G\_R?C\SB/QXCB/CYCF/___\__\__\_YCC'
XM,XCC^/Y'B/CX'@>/X#F.(X_ >!YSX^,^/B/!^/Q_/_G^?G___\0XCC\1Q_Q^
XM(XCX_QX'X^,8CB.(QCQ\X\3B/!P#X?S\?Q_G^/_\ ?_Y^(YC@.(\SX_CP# '
XMC^/''___________X#G/___________X/   ./_^3P'P$1__\_G__Y_#__P_
XM/\'X^ YG\>)X'X^9X'X_C_G_^?^/F>8XQP>)XSC^!XCX^!XCC.<YSB./P'B&
XM(^/P?CYSF/CXSS_Y_GY____$.)\3D>,\?R.(^/\>!^/C&(\GB>8\?'/$XCX\
XM \CY_$\?Y_C__ '_^?P< 8# & \'P> 0!X_CQQ___________^ \'_______
XM____^ P  #C__D^#YCD/__GS____P__\/G_CX#@/#^#P_#^/P_#^/X______
XMC\/ $ ^/ \ P?P< <'P\ 0#"$,\'!^ P1@?!^/X^<P!P> \'_/!^? '_X#@_
XMA\#P>#^# '!_' '!P! 'CX/P.#P'X? ?/&, >?@/@^?!__P!____________
XM___ , >/X\<?___________________________\   _____Y__\9_______
XM_^/__G_____________________/________________________________
XM___\/_____________________P!____________X____Q________^/_C__
XM__________G________\ ?______________X! 'C^/''_______________
XM____^ _______   /__________________G________________________
XMG___________________________________________________________
XM_____________B/___@?________C_X____________C_________ '_____
XM_________\ P!X_CP!____________________________P  #__________
XM________S___________________________________________________
XM______________________________________________\'___X/_______
XM_P?\/___________X_________P!_______________@$ >/X\ ?________
XM___________________\   _____________________________________
XM____________________________________________________________
XM___________________________________________________________\
X! ?__
X 
Xend
END_OF_FILE
# end of 'font-32/Ucmr10x16bI'
fi
if test -f 'font-32/Ucmr10x16bu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-32/Ucmr10x16bu'\"
else
echo shar: Extracting \"'font-32/Ucmr10x16bu'\" \(3571 characters\)
sed "s/^X//" >'font-32/Ucmr10x16bu' <<'END_OF_FILE'
Xbegin 644 cmr10x16bu.fnt
XM& H0!8                 _S_AP'#_@                            
XM        &                     ,                             
XM                                                            
XM                                       #_O\& ^!P?S_G\=P^'^_X
XM<!P_X<!P  V  =P   /@<          #\   !P  ;'\<P<!P!@P         
XM#!P' \#P!@_!X?P^!P        #X  </X'S\/\_P^/^/@?/^^!C/>/C^'P_ 
XM_'\_[_O>_[_G\/A@#X&   P #P  '@ !X #P!P#CP                   
XM      !\&#X  _YS!@=P<'\=QS/^'#_/^' <..' <#X-@ '<   &,'      
XM     _    </\&S?/\/@< P&          P^'P-AF X/@_'X<P^    &  8!
XMW#@'!W#\=AS',?AW!P#AV' 8Q['<=SN'89Q_',<QC',<QG# 8 &!@  8  < 
XM  X  [  < < X< \            &           X!@'!W/^< 8'<'!C'<.#
XM=AP?[_AP'#CC -@<!P?P    !C!P          /    '#_!LVS^#L# 8 P& 
XM       8-@<'<=P.# ?QF',=P   #  # =QL!P=PS'<<!P&8=P< X?!P'<>Q
XMW'<[AW&,?QS',8P^#X#@P# !@\  '  '   .  .P '    ' '           
XM !@          . 8!P_C_A@&!W!P8QW#@W8^/\_X<!PXX           '\]X
XM   #       #P   !P_S_O@_@[!@. .'X&      &'<'!W'<'@P' #!S'<' 
XM<!@  8 8Q@<'<<QSG <#F'<' .'@<!W'\=QW.X=QP!P<P^'\/ ^ X, P 8?@
XM !P_!\!\/@\/X'Q^#P'A_!P]S^!P_ _'X?C_/\_[G/^_Y_#@& <-P_XP!@?P
XM^'\=P<!P?Q_O^' <..           !_-V    8       ^    <&8-CX'P/@
XM #@#@\!@     #!W!P!P.#X/!\ P/AW!P' P/\# ,-\/AW' <Y\'PX!W!P#A
XM\' =Q_'<=SN'8? <',/A_!P' <# & &-L   .X=@_&X=@X#<=P< X? <'^=P
XMV'89P_,8.!W',YP^'<;@X!@'  /^_X8'\/A_'<' <'\_S_AP'#C@        
XM   W;-@  #_@      /@   '!F#8? ,!P  X X_P8      P=P< 8'!N#8?@
XM,!X=P   8   8'#W#X?AP'.?!\. ?P< X?!P'<;QW'X[A\#X'!S#X?P<!P' 
XMP!@!@8    .'<<#N.<.!W'<' .'@'!_G<=QW.<.#@#@=QS.</ S X\ 8 \ #
XM_C &!_#X8QW!@'!_'^_X<!PXX           -VW8   !@      #P   !P  
XMV!X'P_@ . .#P_P '\  8'<' , 8;@''<' _#\   #   ,!P]P^',<!SGP?#
XM_'<' .'P<!_&\=QP.X? /!P<P>'<' <!P, , 8&    /AW' [C_#@=QW!P#A
XM\!P?YW'<=SG#@? X'</C_!P/@<#@& <  _X8'X=P^  =P8!P/C_/^' <..  
XM         #=O>    P      !\       _X>!^;P #@#A^!@     &!W!P&!
XMW/\!QW!P9P?    8/\& <-\/ASG,<YP' [AW!P#A^' ?QG'<<#N'X!P<','!
XMW!X' X# # &!@   'X=QP.XX X'<=P< X? <'^=QW'<YPX#X.QW#X_P<!P' 
XMX!@'  /^  \'<9QC'<, <!P?[_AP'#C@           W9C            ? 
XM      &P_@_NX  8 P& 8!@  8# -@<#,=P.'<=P<&<9P   #  #  # &<<X
XMS'<<!P&X=P<'X?AP'\9QW' _A^&,'!S!P=P^!P. P 8!@8   #O'<<#N. .!
XMW'<' .'X'!SG<=QW.<.#'#L=P^/\'@,#@. 8!P #_@ &!W&<?QW#,' </\_X
XM<!PXX           '\8P           'P   !P !L/X/[N  # 8  & \  / 
XMP#X'!_&8#AV'X'!F'X' < 8 !@!P9AG'./AV',<!^'<'!^'<<QC&,=QP/X=Y
XMW!P/@<&,9P<',, & 8&    [QV#L;AS#@-QW!P#A^!P<YW#8=AG#@XP['<'#
XM_#<& [#@& <  _[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[
XM_O^_[_O^ #_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[
XM_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[
XM_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[
XM_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_@ _[_O^_[_O^_[_O^_[
XM_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[
XM_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[_O^_[
XM_O^_[_O^_[_O^_[_O^_[_@              '^_X<!PXX               
XM    !_                             8                        
XM8                                                           
XM             =P   ?@        < '            <         _X     
XM         #_/^' </^                                          
XM        ,                                                   
XM                                              #X   'P       
XM /@#P           '         /^               ?[_AP'#_@        
XM                                                            
XM                                                            
XM                                                           #
X!_@  
X 
Xend
END_OF_FILE
# end of 'font-32/Ucmr10x16bu'
fi
if test -f 'misc/rotate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/rotate.c'\"
else
echo shar: Extracting \"'misc/rotate.c'\" \(3729 characters\)
sed "s/^X//" >'misc/rotate.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/* rotate a bitmap 90 deg clockwise (mgr format) */
X
X/*	$Header: rotate.c,v 4.1 88/08/24 14:39:17 bianchi Exp $
X	$Source: /tmp/mgrsrc/misc/RCS/rotate.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/misc/RCS/rotate.c,v $$Revision: 4.1 $";
X
X#include <stdio.h>
X#include "dump.h"
X#include "bitmap.h"
X
X#define MAX	2400		/* max bitmap size */
X
X#define GET_OPT(i)	\
X	strlen(argv[i])>2 ? argv[i]+2 : argv[++i]
X
Xunsigned char buff[MAX];	/* output row buffer */
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   char *malloc();
X   struct b_header b_buff, *head = &b_buff;
X   int w=0,h=0,d;
X   int inbytes,outbytes,size;
X   int reverse = 0;
X   int x_flag=0;
X
X   register unsigned char *data;
X   register unsigned char *src;
X   register int bit,word;
X   register int col,row;
X   int ok;
X   int verbose = 0;
X   int i;
X
X   /* check arguments */
X
X   for(i=1;i<argc;i++) {
X      if (*argv[i] == '-')
X         switch (argv[i][1]) {
X            case 'w':				/* specify width */
X               w = atoi(GET_OPT(i));
X               break;
X            case 'h':				/* specify height */
X               h = atoi(GET_OPT(i));
X               break; 
X            case 'x':				/* don't output header */
X               x_flag++;
X               break; 
X            case 'r':				/* reverse bits */
X               reverse++;
X               break; 
X            case 'v':				/* verbose */
X               verbose++;
X               break; 
X            default:
X               fprintf(stderr,"%s: invalid flag %c ignored\n",argv[0],argv[i][1]);
X            }
X      else
X         fprintf(stderr,"%s: invalid argument %s ignored\n",argv[0],argv[i]);
X      }
X
X
X   if (w==0 && h==0) {
X
X      /* read in bitmap header */
X
X      if (!bitmaphead( stdin, &w, &h, &d, &inbytes )) {
X         fprintf(stderr,"%s: invalid bitmap format \n",*argv);
X         exit(1);
X         }
X      }
X
X   else if (w==0 || h==0) {
X      fprintf(stderr,"%s:  Both -h and -w must be specified\n",*argv);
X      exit(1);
X      }
X      
X   if (w > MAX) {
X      fprintf(stderr,"%s:  bitmap too big\n",*argv);
X      exit(1);
X      }
X
X   size = inbytes * h;			/* total bytes in bitmap */
X   outbytes = ((h+7)&~7)/8;		/* bytes/row (output) */
X   
X   if ((data= (unsigned char *) malloc(size)) == NULL) {
X      fprintf(stderr,"%s: can't malloc space\n",*argv);
X      exit(2);
X      }
X      
X   for(ok=1,col=0;ok>0 && col<size;col += (ok=Read(data+col,size-col)))
X      if (verbose) write(2,">",1);
X
X   /* write new header */
X
X   if (!x_flag) {
X      B_PUTHDR8(head,h,w,d);
X      fwrite(head,sizeof b_buff,1,stdout);
X      }
X
X   /* rotate and output new bitmap */
X
X   data += size - inbytes;		/* start at end */
X   for (col = 0;col< w; col++) {
X      bit = 0x80 >> (col&0x7);
X      word = col/8;
X      if (reverse)
X         for(src = &buff[outbytes]; src >= buff; src-- )
X		*src = ~0;
X      else
X         bzero(buff,outbytes);
X      for(src=data+word,row = 0; row< h; row++,src -= inbytes) 
X         if (*src & bit)
X            buff[row>>3] ^= 0x80 >> (row&0x7);
X      fwrite(buff,outbytes,1,stdout);
X      if (verbose) write(2,">",1);
X      }
X   exit(0);
X   }
X
X/* do multiple passes for read */
X
XRead(buff,count)
Xregister char *buff;
Xint count;
X   {
X   register int sum=0,current=0;
X
X   while((current = fread(buff+sum,1,count-sum,stdin))>0)
X      sum += current;
X   return(sum);
X   }
END_OF_FILE
# end of 'misc/rotate.c'
fi
if test -f 'src/data.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/data.c'\"
else
echo shar: Extracting \"'src/data.c'\" \(3751 characters\)
sed "s/^X//" >'src/data.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: data.c,v 4.2 88/07/19 14:15:18 sau Exp $
X	$Source: /tmp/mgrsrc/src/RCS/data.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/data.c,v $$Revision: 4.2 $";
X
X/* static data items for window manager */
X
X#include "bitmap.h"
X#include "defs.h"
X#include "font.h"
X
X/* bit maps */
X
X#include "icons.h"
X
X/* space to store screen covered by mouse */
X
Xstatic char c_save[ BIT_Size(16,16,DEPTH) ];
X
X
X/* structures for mouse icons */
X
Xbit_static(pattern,16,4,pat_data,1);
Xbit_static(mouse_arrow,16,32,c_arrow1,1);
Xbit_static(mouse_box,16,32,c_box,1);
Xbit_static(mouse_cut,16,32,c_cut,1);
Xbit_static(mouse_cup,16,32,c_cup,1);
Xbit_static(mouse_save,16,16,c_save,DEPTH);
Xbit_static(mouse_cross,16,16,c_cross,1);
Xbit_static(mouse_bull,8,8,c_bull,1);
Xbit_static(mouse_bull2,8,8,c_bull2,1);
X
X/* menus */
X
Xchar *active_menu[] = {		/* active-window menu */
X   "reshape",
X   "move",
X   "bury",
X#ifdef CUT
X   "cut",
X   "paste",
X#endif
X   "- - - -",
X   "destroy",
X   (char *) 0};
X
Xchar *main_menu[] = {		/* primary menu */
X   "new window",
X   "redraw",
X   "quit",
X   (char *) 0};
X
Xchar *full_menu[] = {		/* primary menu  - no more windows allowed */
X   "redraw",
X   "quit",
X   (char *) 0};
X
Xchar *quit_menu[] = {		/* to verify quit */
X   "cancel",
X   "suspend",
X   "- - - -",
X   "really quit",
X   (char *) 0};
X  
X
X/* menu functions - these have a 1-1 corrospondance with the menu items */
X
Xint new_window(), shape_window(), move_window(), destroy_window(), quit();
Xint redraw(), hide_win(), nothing();
X#ifdef CUT
Xint cut(), paste();
X#endif
X
Xfunction main_functions[] = {
X   new_window,
X   redraw,
X   quit,
X   (function) 0 };
X
Xfunction full_functions[] = {
X   redraw,
X   quit,
X   (function) 0 };
X
Xfunction active_functions[] = {
X   shape_window,
X   move_window,
X   hide_win,
X#ifdef CUT
X   cut,
X   paste,
X#endif
X   nothing,
X   destroy_window,
X   (function) 0 };
X
X/* default font info */
X
Xchar *font_dir = FONTDIR;
Xchar *fontlist[MAXFONT];
X
X/* default icon info */
Xchar *icon_dir = ICONDIR;
X
X/* raster of table for inverted screen */
X
Xint rev_ops[] = {
X   0xf,0x7,0xb,0x3,0xd,0x5,0x9,0x1,0xe,0x6,0xa,0x2,0xc,0x4,0x8,0x0
X   };
X
XBITMAP *m_rop;				/* current mouse bit map */
Xint next_window=0;			/* next available window count */
Xstruct font *font;			/* default font */
XBITMAP *screen;				/* default screen */
XWINDOW *active = (WINDOW *) 0;		/* window connected to keyboard */
XWINDOW *last_active = (WINDOW *) 0;	/* last window connected to keyboard */
Xint button_state = 0;			/* state of the mouse buttons */
Xint mouse, mousex, mousey;		/* mouse fd, x-coord, y-coord */
Xint debug = 0;				/* ==1 for debug prints */
Xint mouse_on = 0;			/* 1 iff mouse track is on */
Xchar *snarf = (char *) 0;		/* place to keep snarfed text */
Xchar *message = (char *) 0;		/* place to keep message */
Xchar *start_command;			/* command for shell at window start */
Xchar *init_command;			/* str to send window upon creation */
Xint id_message = 0;			/* id of message sender */
Xshort buckey_map = 0;			/* mapping from ptty to buckey key */
Xunsigned int init_flags = INIT_FLAGS;	/* initial flags for new windows */
Xint mask = 0;				/* process mask for select */
Xint poll = 0;				/* processes with non-processed but
X					 * already read data */
X#ifdef DEBUG
Xchar debug_level[] = "                                ";	/* debug flags */
X#endif
X
X/* aarg! */
X
Xnothing() {}
END_OF_FILE
# end of 'src/data.c'
fi
if test -f 'src/event.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/event.h'\"
else
echo shar: Extracting \"'src/event.h'\" \(3647 characters\)
sed "s/^X//" >'src/event.h' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: event.h,v 4.1 88/06/21 13:21:58 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/RCS/event.h,v $
X*/
Xstatic char	h_event_[] = "$Source: /tmp/mgrsrc/src/RCS/event.h,v $$Revision: 4.1 $";
X
X/* event codings for mgr */
X
X#define EVENT_B1_DOWN		1		/* right button down */
X#define EVENT_B2_DOWN		2		/* middle button down */
X#define EVENT_BSYS_DOWN		4		/* left (system) button down */
X#define EVENT_B1_UP		-1		/* right button going up */
X#define EVENT_B2_UP		-2		/* middle button going up */
X#define EVENT_BSYS_UP		-4		/* left (system) button up */
X#define EVENT_SHAPE		5		/* window reshaped */
X#define EVENT_REDRAW		6		/* screen redraw */
X#define EVENT_ACTIVATED		7		/* window made active window */
X#define EVENT_DEACTIVATED	8		/* window no longer active */
X#define EVENT_COVERED		9		/* window is partly obscured */
X#define EVENT_UNCOVERED		10		/* window is un-obscured */
X#define EVENT_MOVE		11		/* window was moved */
X#define EVENT_DESTROY		12		/* client window destroyed */
X#define EVENT_ACCEPT		13		/* messages accepted */
X#define EVENT_NOTIFY		14		/* set window name */
X#define EVENT_TELLME		15		/* unused */
X#define EVENT_SNARFED		16		/* a snarf happened */
X#define EVENT_PASTE		17		/* a paste happened */
X
X#define MIN_EVENT		-4
X#define MAX_EVENT		17
X/* NOTE, MAXEVENTS in defines.h must be kept consistent with these values.
X*/
X
X/* Check if the given event number is legal, return TRUE if it is.
X*/
X#define CHK_EVENT(event)	(MIN_EVENT <= (event)  &&  (event) <= MAX_EVENT)
X
X/* event stack control flags */
X
X#define EVENT_STACK		18		/* stack events */
X#define EVENT_STFLAG		19		/* events stacked somewhere */
X
X/* button event control chars */
X
X#define E_ESC			'%'		/* escape char */
X#define E_POS			'p'		/* return mouse position */
X#define E_CPOS			'P'		/* mouse position (cols/rows)*/
X#define E_SWRECT		'r'		/* sweep out a rectangle */
X#define E_SWRECTA		'R'		/* " in screen coords */
X#define E_SWBOX      'b'      /* sweep out a box */
X#define E_SWBOXA     'B'      /* " in screen coords */
X#define E_SWLINE		'l'		/* sweep out a line */
X#define E_SWTEXT		't'		/* sweep out text */
X#define E_SWTEXTT		'T'		/* " text region only */
X#define E_NOTIFY		'n'		/* get applic. notification */
X#define E_WHO			'w'		/* get applic. id */
X#define E_WHOSIZE		'S'		/* get applic. size */
X#define E_FROM			'f'		/* who is message from */
X#define E_MESS			'm'		/* message sent */
X#define E_MSGSIZE		's'		/* size of message sent */
X#define E_SNARFSIZE		'c'		/* size of cut buffer */
X#define E_SNARFBUF		'C'		/* content of cut buffer */
X
X#define E_LIST_BUTTON		"%pPrRbBlTtnwS"	/* valid esc's for buttons */
X#define E_LIST_ACCEPT		"%pPfms"	/* valid esc's for notify */
X#define E_LIST_SNARF		"%cCf"		/* valid esc's for snarf */
X#define E_LIST_PASTE		"%c"		/* valid esc's for snarf */
X
X#define E_MAIN		0			/* in main window */
X#define E_STACK		1			/* on window stack */
X
X/* other event macros */
X
X/* convert event number to index into event array */
X#define GET_EVENT(event)	((event)-(MIN_EVENT))
X
X#define EVENT_SET_MASK(win,event)	\
X				((win->event_mask) |= (1L<<GET_EVENT(event)))
X#define EVENT_CLEAR_MASK(win,event)	\
X				((win->event_mask) &= ~(1L<<GET_EVENT(event)))
X#define IS_EVENT(win,event)	\
X				((win->event_mask) & (1L<<GET_EVENT(event)))
END_OF_FILE
# end of 'src/event.h'
fi
if test -f 'src/kbd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/kbd.c'\"
else
echo shar: Extracting \"'src/kbd.c'\" \(3690 characters\)
sed "s/^X//" >'src/kbd.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: kbd.c,v 4.2 88/07/07 08:59:02 sau Exp $
X	$Source: /tmp/mgrsrc/src/RCS/kbd.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/kbd.c,v $$Revision: 4.2 $";
X
X#include <stdio.h>
X#include <sys/signal.h>
X#include "bitmap.h"
X#include "defs.h"
X#ifdef sun
X#include <sys/time.h> 
X#ifdef KBD
X# include <sys/types.h>
X# include <sundev/kbio.h>
X# ifndef TIOCCONS					/* definiton moved in rel. 4.0 */
X#   include "<sys/termios.h>"
X# endif
X#endif KBD
X#endif
X
Xstatic int	bell_fd;
X
X/* initialize bell, for Suns */
Xint
Xinitbell()
X   {
X#ifdef BELL
X   int i;
X   if ( !debug  &&  (i=open("/dev/bell",1))>=0 )
X      bell_fd = i;
X   else
X      bell_fd = -1;
X#endif
X   }
X
X
X
Xstatic int ring = 0;
X
X/* turn on the bell */
X
Xvoid
Xbell_on()
X   {
X#ifdef BELL
X   int	bell_off();
X
X   if( bell_fd >= 0 ) {
X      if (ring==0)
X         write( bell_fd, "\002", 1 );
X      signal( SIGALRM, bell_off );
X      set_timer(15);		/* set alarm for 100'th seconds */
X      ring++;
X      return;
X      }
X#endif
X/*    We are looking for some way to make a noise when ever possible.
X      This line breaks when the console is redirected to an mgr window and
X      mgr's stderr (fd 2) is the console.
X
X   write( 2, "\007", 1 );
X*/
X   }
X
X#ifdef BELL
X/* turn off the bell */
X
Xint
Xbell_off(n)
Xint n;			/* signal #, ignored */
X   {
X   write(bell_fd,"\003",1);	/* turns the bell off */
X   set_timer(0);		/* insure timer is off */
X   ring = 0;
X   }
X
X
X/* reset the keyboard */
X
Xint
Xkbd_reset()
X   {
X   if( bell_fd >= 0 )
X      write(bell_fd,"\001",1);	/* this resets the kbd and turns bell off */
X   set_timer(0);		/* insure timer is off */
X   ring = 0;
X   }
X
X
Xint
Xset_timer(time)
Xint time;		/* time in 100'th of seconds */
X   {
X   struct	itimerval new,old;
X
X   new.it_interval.tv_sec = 0L;
X   new.it_interval.tv_usec = 0L;
X   new.it_value.tv_sec = time/100;
X   new.it_value.tv_usec = (time%100) * 10000;
X
X   setitimer(ITIMER_REAL,&new,&old);
X   }
X
X#endif
X
X
Xstatic int kbd_fd = -1;
X
X/* initialize the keyboard, especially when it is a separate device */
X
Xinitkbd()
X{
X#ifdef KBD
X   int fd;
X
X   if ((fd = set_kbd(1)) > 0) {
X	kbd_fd = 0; 
X   	close(kbd_fd);
X	dup(fd);
X	close(fd);
X	}
X   else if( fd == 0 )
X	return;
X   else  {
X	if( debug )
X	   fprintf(stderr,"Can't find keyboard, using stdin\n");
X	kbd_fd = -1;
X	}
X#endif
X}
X
X/* set/reset direct mode
X   When setting direct mode, returns file descriptor of keyboard */
X
Xint
Xset_kbd(how)
Xint how;			/* 1=direct, 0=no direct */
X   {
X   int one = 1;
X   int zero = 0;
X   int cons;
X
X#ifdef KBD
X#ifndef  KBD_CMD_RESET
X#define  KBD_CMD_RESET	0x01	/* Should be in a header file, but .. */
X#endif
X   if (how == 0) {		/* make sure kbd is released */
X      if (kbd_fd == -1)
X	 return(-1);
X      ioctl(kbd_fd, KIOCSDIRECT, &zero);	/* turn off direct mode */
X      ioctl(kbd_fd, KIOCCMD, KBD_CMD_RESET);	/* reset the keyboard */
X      close(kbd_fd);				/* close the keyboard */
X      cons = open("/dev/console", 0);	/* put console messages back */
X      ioctl(cons, TIOCCONS, &one);
X      close(cons);
X      return(0);
X      }
X   else {		/* open the kbd for input */
X      kbd_fd = open("/dev/kbd", 0);
X      ioctl(kbd_fd, KIOCSDIRECT, &one);		/* turn on direct mode */
X      ioctl(kbd_fd, KIOCCMD, KBD_CMD_RESET);	/* reset the keyboard */
X      }
X#endif
X   return(kbd_fd);
X   }
END_OF_FILE
# end of 'src/kbd.c'
fi
echo shar: End of archive 18 \(of 61\).
cp /dev/null ark18isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
