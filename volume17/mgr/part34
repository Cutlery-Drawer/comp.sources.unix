Subject:  v17i035:  MGR, Bellcore window manager, Part34/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 35
Archive-name: mgr/part34




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 34 (of 61)."
# Contents:  demo/icon/msgs_icons.h doc/usrman/doc.6 src/down_load.c
#   src/win_subs.c
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:42 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'demo/icon/msgs_icons.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/icon/msgs_icons.h'\"
else
echo shar: Extracting \"'demo/icon/msgs_icons.h'\" \(11000 characters\)
sed "s/^X//" >'demo/icon/msgs_icons.h' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: msgs_icons.h,v 4.1 88/06/21 14:00:07 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/icon/RCS/msgs_icons.h,v $
X*/
Xstatic char	h_msgs_icons_[] = "$Source: /tmp/mgrsrc/demo/icon/RCS/msgs_icons.h,v $$Revision: 4.1 $";
X
X
X/* icon: msg_board */
X
Xunsigned char msg_board_data[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xf7, 0xbc, 0xe3, 0xde, 0xf0, 0x00, 
X   0x00, 0x36, 0x84, 0x21, 0x14, 0x50, 0x80, 0x00, 0x00, 0x2a, 0x84, 0x21, 
X   0x14, 0x10, 0x80, 0x00, 0x00, 0x22, 0xe7, 0xbd, 0xf4, 0xdc, 0xf0, 0x00, 
X   0x00, 0x22, 0x80, 0x85, 0x14, 0x50, 0x10, 0x00, 0x00, 0x22, 0x80, 0x85, 
X   0x14, 0x50, 0x10, 0x00, 0x00, 0x22, 0xf7, 0xbd, 0x13, 0x9e, 0xf0, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 
X   0xff, 0xff, 0xff, 0xfe, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x7f, 0xff, 0xff, 0xff, 
X   0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   };
X
Xstruct icon msg_board = {
X   "msg_board",1,64,64,msg_board_data};
X
X
X/* icon: msg_note */
X
Xunsigned char msg_note_data[] = {
X   0x7f, 0xc0, 0x40, 0x46, 0x46, 0x40, 0x46, 0x40, 0x40, 0x40, 0x40, 0x46, 
X   0x40, 0x40, 0x80, 0x80, 0xff, 0x80, 
X   };
X
Xstruct icon msg_note = {
X   "msg_note",1,10,9,msg_note_data};
X
X
X/* icon: msg_read */
X
Xunsigned char msg_read_data[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xf7, 0xbc, 0xe3, 0xde, 0xf0, 0x00, 
X   0x00, 0x36, 0x84, 0x21, 0x14, 0x50, 0x80, 0x00, 0x00, 0x2a, 0x84, 0x21, 
X   0x14, 0x10, 0x80, 0x00, 0x00, 0x22, 0xe7, 0xbd, 0xf4, 0xdc, 0xf0, 0x00, 
X   0x00, 0x22, 0x80, 0x85, 0x14, 0x50, 0x10, 0x00, 0x00, 0x22, 0x80, 0x85, 
X   0x14, 0x50, 0x10, 0x00, 0x00, 0x22, 0xf7, 0xbd, 0x13, 0x9e, 0xf0, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 
X   0xff, 0xff, 0xff, 0xfe, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x06, 0x60, 0x1e, 0x70, 0x20, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x61, 0x9c, 0x10, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x80, 0x66, 0x00, 0x00, 0x0f, 0xf8, 0x06, 0x60, 0x00, 0x11, 0x18, 
X   0x00, 0x08, 0x08, 0x06, 0x60, 0x00, 0x18, 0x88, 0x00, 0x08, 0xc8, 0x06, 
X   0x60, 0x00, 0x04, 0x48, 0x00, 0x08, 0xc8, 0x06, 0x60, 0x00, 0x02, 0x48, 
X   0x00, 0x08, 0x08, 0x06, 0x60, 0x01, 0xff, 0x48, 0x00, 0x08, 0x08, 0x06, 
X   0x60, 0x01, 0x01, 0x48, 0x00, 0x08, 0x08, 0x06, 0x60, 0x01, 0x19, 0xff, 
X   0x00, 0x10, 0x10, 0x06, 0x60, 0x01, 0x1f, 0x91, 0xc0, 0x1f, 0xf0, 0x06, 
X   0x60, 0x01, 0x18, 0x02, 0x60, 0x00, 0x00, 0x06, 0x60, 0x01, 0x30, 0x00, 
X   0x10, 0x00, 0x00, 0x06, 0x60, 0x01, 0x40, 0x00, 0x08, 0x00, 0x00, 0x06, 
X   0x60, 0x02, 0x80, 0x00, 0x04, 0x00, 0x00, 0x06, 0x61, 0xc3, 0x80, 0x00, 
X   0x16, 0x00, 0x00, 0x06, 0x62, 0x21, 0x00, 0x00, 0x06, 0x1f, 0x80, 0x06, 
X   0x64, 0x33, 0x00, 0x00, 0x01, 0x20, 0x40, 0x06, 0x68, 0x13, 0x80, 0x00, 
X   0x01, 0x20, 0x20, 0x06, 0x68, 0x0a, 0x00, 0x00, 0x00, 0xa0, 0x30, 0x06, 
X   0x68, 0x0e, 0x00, 0x00, 0x00, 0xc0, 0x10, 0x06, 0x68, 0x0e, 0x00, 0x00, 
X   0x00, 0x40, 0x10, 0x06, 0x68, 0x04, 0x00, 0x00, 0x01, 0x4c, 0x10, 0x06, 
X   0x68, 0xf4, 0x00, 0x00, 0x00, 0xaa, 0x10, 0x06, 0x69, 0x9c, 0x00, 0x00, 
X   0x00, 0x73, 0x10, 0x06, 0x69, 0x8c, 0x00, 0x00, 0x00, 0x79, 0x10, 0x06, 
X   0x68, 0x6c, 0x00, 0x00, 0x00, 0x39, 0x10, 0x06, 0x6c, 0x1e, 0x00, 0x00, 
X   0x00, 0x2b, 0x10, 0x06, 0x64, 0x02, 0x00, 0x00, 0x00, 0x34, 0x10, 0x06, 
X   0x64, 0x02, 0x00, 0x00, 0x00, 0x10, 0x10, 0x06, 0x64, 0x06, 0x00, 0x00, 
X   0x00, 0x30, 0x30, 0x06, 0x62, 0x05, 0x00, 0x00, 0x00, 0x30, 0x20, 0x06, 
X   0x62, 0x0d, 0x00, 0x00, 0x00, 0x28, 0x60, 0x06, 0x63, 0x10, 0x80, 0x00, 
X   0x00, 0x27, 0xc0, 0x06, 0x61, 0xe0, 0xc0, 0x00, 0x00, 0x40, 0x00, 0x06, 
X   0x60, 0x00, 0x60, 0x00, 0x00, 0xbf, 0xc0, 0x06, 0x60, 0x00, 0x30, 0x00, 
X   0x01, 0x40, 0x40, 0x06, 0x60, 0x00, 0x0c, 0x00, 0x06, 0x46, 0x40, 0x06, 
X   0x60, 0x00, 0x03, 0x00, 0x18, 0x46, 0x40, 0x06, 0x60, 0x00, 0x00, 0xc0, 
X   0xe0, 0x40, 0x40, 0x06, 0x60, 0x00, 0x00, 0xbf, 0x60, 0x40, 0x40, 0x06, 
X   0x60, 0x00, 0x00, 0x80, 0x20, 0x40, 0x40, 0x06, 0x60, 0x00, 0x00, 0x80, 
X   0x20, 0x80, 0x80, 0x06, 0x60, 0x00, 0x01, 0x00, 0x10, 0xff, 0x80, 0x06, 
X   0x60, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x06, 0x7f, 0xff, 0xff, 0xff, 
X   0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   };
X
Xstruct icon msg_read = {
X   "msg_read",1,64,64,msg_read_data};
X
X
X/* icon: msg_none */
X
Xunsigned char msg_none_data[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xf7, 0xbc, 0xe3, 0xde, 0xf0, 0x00, 
X   0x00, 0x36, 0x84, 0x21, 0x14, 0x50, 0x80, 0x00, 0x00, 0x2a, 0x84, 0x21, 
X   0x14, 0x10, 0x80, 0x00, 0x00, 0x22, 0xe7, 0xbd, 0xf4, 0xdc, 0xf0, 0x00, 
X   0x00, 0x22, 0x80, 0x85, 0x14, 0x50, 0x10, 0x00, 0x00, 0x22, 0x80, 0x85, 
X   0x14, 0x50, 0x10, 0x00, 0x00, 0x22, 0xf7, 0xbd, 0x13, 0x9e, 0xf0, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 
X   0xff, 0xff, 0xff, 0xfe, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x06, 0x60, 0x1e, 0x70, 0x20, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x61, 0x9c, 0x10, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x80, 0x66, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x11, 0x18, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x18, 0x88, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x04, 0x48, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x02, 0x48, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x03, 0x48, 0x00, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x01, 0x48, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x01, 0xff, 
X   0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x07, 0x81, 0xc0, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x08, 0x00, 0x60, 0x00, 0x00, 0x06, 0x60, 0x00, 0x30, 0x00, 
X   0x10, 0x00, 0x00, 0x06, 0x60, 0x00, 0x40, 0x00, 0x08, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x80, 0x0f, 0x04, 0x00, 0x00, 0x06, 0x61, 0xc1, 0x8c, 0x11, 
X   0x86, 0x00, 0x00, 0x06, 0x62, 0x21, 0x1e, 0x10, 0xc2, 0x1f, 0x80, 0x06, 
X   0x64, 0x33, 0x13, 0x16, 0x41, 0x20, 0x40, 0x06, 0x68, 0x13, 0x21, 0x16, 
X   0x41, 0x20, 0x20, 0x06, 0x68, 0x0a, 0x27, 0x08, 0x40, 0xa0, 0x30, 0x06, 
X   0x68, 0x0e, 0x26, 0x88, 0x40, 0xc0, 0x10, 0x06, 0x68, 0x0e, 0x10, 0xa6, 
X   0x80, 0x40, 0x10, 0x06, 0x68, 0x04, 0x19, 0xa3, 0x80, 0x4c, 0x10, 0x06, 
X   0x68, 0xf4, 0x0f, 0x30, 0x00, 0x2a, 0x10, 0x06, 0x69, 0x98, 0x00, 0x10, 
X   0x00, 0x13, 0x10, 0x06, 0x69, 0x8c, 0x20, 0x10, 0x00, 0x09, 0x10, 0x06, 
X   0x68, 0x6c, 0x10, 0x08, 0x08, 0x19, 0x10, 0x06, 0x6c, 0x1e, 0x10, 0x0c, 
X   0x18, 0x0b, 0x10, 0x06, 0x64, 0x02, 0x08, 0x04, 0x10, 0x04, 0x10, 0x06, 
X   0x64, 0x02, 0x0c, 0x04, 0x10, 0x10, 0x10, 0x06, 0x64, 0x06, 0x04, 0x38, 
X   0x30, 0x10, 0x30, 0x06, 0x62, 0x05, 0x06, 0x00, 0x20, 0x10, 0x20, 0x06, 
X   0x62, 0x0d, 0x03, 0x00, 0x60, 0x28, 0x60, 0x06, 0x63, 0x10, 0x81, 0x80, 
X   0xc0, 0x27, 0xc0, 0x06, 0x61, 0xe0, 0xc0, 0xe3, 0x80, 0x40, 0x00, 0x06, 
X   0x60, 0x00, 0x60, 0x3e, 0x00, 0x80, 0x00, 0x06, 0x60, 0x00, 0x30, 0x00, 
X   0x01, 0x00, 0x00, 0x06, 0x60, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x03, 0x00, 0x18, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0xc0, 
X   0xe0, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0xbf, 0x60, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x00, 0x80, 0x20, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x80, 
X   0x20, 0x00, 0x00, 0x06, 0x60, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x06, 
X   0x60, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x06, 0x7f, 0xff, 0xff, 0xff, 
X   0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   };
X
Xstruct icon msg_none = {
X   "msg_none",1,64,64,msg_none_data};
X
END_OF_FILE
# end of 'demo/icon/msgs_icons.h'
fi
if test -f 'doc/usrman/doc.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/usrman/doc.6'\"
else
echo shar: Extracting \"'doc/usrman/doc.6'\" \(11735 characters\)
sed "s/^X//" >'doc/usrman/doc.6' <<'END_OF_FILE'
X'\"                        Copyright (c) 1988 Bellcore
X'\"                            All Rights Reserved
X'\"       Permission is granted to copy or use this program, EXCEPT that it
X'\"       may not be sold for profit, the copyright notice must be reproduced
X'\"       on copies, and credit should be given to Bellcore where it is due.
X'\"       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X'\"
X'\"	$Header: doc.6,v 4.1 88/06/29 17:05:09 bianchi Exp $
X'\"	$Source: /tmp/mgrsrc/doc/usrman/RCS/doc.6,v $
X.Sh page Using the Library
XClients using 
X.I
XThe C Interface Library
X.R
Xshould specify:
X.DS
X.ft \*(Ff
X#include "term.h"
X.ft R
X.DE
Xwhich also includes 
X.DS
X.ft \*(Ff
X<stdio.h>
X.ft R
X.DE
Xif it has not already been included.
XPrograms are compiled either with
X.DS
X.ft \*(Ff
Xcc -o foo foo.c term.o -I$(lib)
X.ft R
X.DE
Xwhere $(lib) is the \*M include directory
Xor simply
X.DS
X.ft \*(Ff
Xcc -o foo foo.c -lmgr
X.ft R
X.DE
Xif the library is installed in a standard location.
XThe file
X.I term.o
Xcontains the functions listed in the last section.
XSeveral compile time options are available to the client program using
Xthe library.
XNormally, the library setup routine,
X.Fr m_setup
X attempts to open 
X.I /dev/tty
Xto communicate with \*M.
XClient programs may define the C preprocessor symbols
X.SM
X.I M_DEVICEIN
X.LG
Xor
X.SM
X.I M_DEVICEOUT
X.LG
Xto override the selection of
X.I /dev/tty
Xfor input or output respectively.
XAfter each macro call,
Xthe flush flag
X.SM
X.I M_FLUSH
X.LG
Xis tested to see if output should be flushed to \*M.
XIf the C preprocessor symbol
X.SM
X.I M_NOFLUSH
X.LG
Xis defined, before the client program includes
X.I term.h ,
XThe flush flag is never tested, and it becomes the responsibility of the
Xclient program to insure output is flushed at the appropriate times.
X.LP
XSeveral external variables maintained by the library are accessible to
Xclient programs.
XThe
X.I stdio
X.SM
X.I FILE
X.LG
Xpointers
X.I m_termin
Xand
X.I m_termout
Xare used for directing output to, and receiving input from \*M.
XThese file pointers are initialized in
X.Fr m_setup
X\&, and may be changed by client programs after
X.Fr m_setup
X is called.
XThe integer
X.I m_flags
Xcontains the current library mode settings, as returned by
X.Fr m_setup
X\&.
XThe 
X.SM
X.I M_MODEOK
X.LG
Xand
X.SM
X.I M_FLUSH
X.LG
Xbits of 
X.I m_flags
Xmay also be changed at any time after 
X.Fr m_setup 
X is called.
XThe integer
X.I m_envcount
Xcontains the current window context depth, and is used by
X.Fr m_popall
Xto pop the appropriate number of contexts.
X.I M_envcount
Xshould not be changed by client programs.
XFinally, the character
X.I m_menuchar
Xdefines the menu separator character used by
X.Fr menu_load
X\&.
XThis character, set to '\e005' by the library package,
Xcan be changed to any character that will not appear as part of
Xa menu item or action.
X.Sh page Glossary
X.IP "\fBabsolute coordinates\fP" 0.5i
X.br
X.I "Absolute coordinates"
Xis a coordinate system used in
X.I windows
Xmeasured in units of pixels.
X.IP "\fBactive window\fP" 0.5i
X.br
XThe
X.I active
Xwindow is the window logically in the front of the display, which is
Xreceiving keyboard and mouse input.
X.IP "\fBalternate window\fP" 0.5i
X.br
XAn
X.I "alternate window"
Xis an additional window created by a client program that shares the
Xcommunication channel with the main window.
X.IP \fBbitmap\fP 0.5i
X.br
XA
X.I bitmap
Xis a rectangular array of bits, or pixels if the bitmap is
Xcurrently on the display.
X.IP \fBchannel\fP 0.5i
X.br
XThe
X.I channel
Xis the bidirectional byte stream connecting \*M with
Xthe client program.
XThe 
X.I channel
Xis usually the program's standard input and output.
X.IP "\fBcharacter coordinates\fP" 0.5i
X.br
X.I "Character coordinates"
Xis the 
Xcoordinate system used in windows for counting characters in
X.I columns
Xand
X.I rows .
X.IP "\fBcharacter cursor\fP" 0.5i
X.br
XThe
X.I "character cursor"
Xis the location in the window where the next character will be placed.
XThe cursor location is always highlighted on the active window.
X.IP "\fBchild menu\fP" 0.5i
X.br
XA
X.I "child menu"
Xis the
Xmenu that will pop up when the user slides off to the right
Xof a popped up 
X.I "parent menu" .
X.IP "\fBclient program\fP" 0.5i
X.br
XA
X.I "client program"
Xis any Unix command that is running in an \*M window.
XClient programs may be existing programs, as might be found in
X.I /bin
Xor new applications written specifically to take advantage of the
Xwindowing environment.
X.IP \fBclient-host\fP 0.5i
X.br
XThe
X.I "client-host"
Xis the computer that the client program is running on.
XIt is often the same as the
X.I \*M-host
Xmachine, but it does not need to be.
X.IP "\fBdisplay coordinates\fP" 0.5i
X.I "Display coordinates"
Xis a coordinate system used to measure pixels on the display.
XThe top left corner of the display is at (0,0), with
X.I x
Xincreasing to the right, and
X.I y
Xincreasing down.
X.br
X.IP \fBexposed\fP 0.5i
X.br
XA window is
X.I exposed
Xif it is entirely visible.
X.IP "\fBgraphics point\fP" 0.5i
X.br
XThe
X.I "graphics point"
Xis a location on the window, measured in the prevailing window
Xcoordinate system, that may serve as a reference location 
Xor origin for many of the graphics operations.
X.IP \fBlistener\fP 0.5i
X.br
XA 
X.I listener
Xis a window that has turned on the
X.SM
X.Fi ACCEPT
X.LG
Xevent and is willing to receive messages from other client programs.
X.IP "\fBmain window\fP" 0.5i
X.br
XA client program's
X.I "main window"
Xis the window the program was started in.
XThe client program may create and destroy alternate windows,
Xbut not its
X.I "main window" .
XIf the user destroys a client program's
X.I " main window" ,
Xthe connection
Xto \*M is severed, and the client program receives a
X.I hangup
Xsignal.
X.IP \fB\*M-host\fP 0.5i
X.br
XThe
X\*M-host is the computer that \*M is running on. 
X.IP "\fBmouse cursor\fP" 0.5i
X.br
XThe
X.I "mouse cursor"
Xis a small bitmap or
X.I icon
Xthat tracks the movement of the mouse on the display.
XNormally the
X.I "mouse cursor"
Xis a small arrow pointing north west.
X.IP \fBobscured\fP 0.5i
X.br
XA window is
X.I obscured
Xwhen it is partially or totally covered by another
Xwindow.
X.IP "\fBparent menu\fP" 0.5i
X.br
XA  menu is called a
X.I "parent menu"
Xwhen sliding off to the right of a selected item causes
Xanother menu or
X.I "child menu"
Xto pop up.
X.IP "\fBrelative coordinates\fP" 0.5i
X.br
X.I "Relative coordinates"
Xis a coordinate system for windows where a single unit represents one
Xthousandth of the way across (or down) the window.
X.IP "\fBscratchpad bitmap\fP" 0.5i
X.br
XA 
X.I "scratchpad bitmap"
Xis a chunk of memory, allocated by \*M for use by a client program,
Xthat may hold a bitmap image that is not on the display.
X.IP "\fBsnarf buffer\fP" 0.5i
X.br
XThe
X.I "snarf buffer"
Xis a buffer maintained by \*M of arbitrary size that is accessible by all
Xclient programs.
X.IP "\fBtarget window\fP" 0.5i
X.br
XA
X.I "target window"
Xis a window that is to receive a message from another window.
X.IP "\fBtext region\fP" 0.5i
X.br
XA 
X.I "text region"
Xis the part of the window in which character text and the 
Xfunctions that operate on characters work.
XThe
X.I "text region"
Xmay be the entire window (the default)
Xor a rectangular subregion within the window.
X.IP "\fBwindow border\fP" 0.5i
X.br
XThe
X.I "window border"
Xis a thin black border around every window that separates the
Xwindow from the rest of the display.
X.IP "\fBwindow context\fP" 0.5i
X.br
XA
X.I "window context"
Xcontains the values for one or more aspects of the window's
Xstate.
X.I "Window context"
Xa may be saved on a stack, and then restored at some later time.
X.IP "\fBwindow id\fP" 0.5i
X.br
XA
X.I "window id"
Xis a unique number assigned to every window that may be used
Xas an identifier when sending a message to the window.
X.I "Window id" s
Xhave two parts,
Xthe first part is the process number of the client program that
Xwas started when the window was created,
Xthe second part is the windows
X.I alternate
Xwindow number, or
Xzero for a main window.
X.Sh page Sample Client Program
X.LP
XThis program, called
X.I close ,
Xcloses, or iconifies a window.  
XIts not a terribly useful application in its own right, but it does
Xexercise several of the library calls.
XWhen 
X.I close
Xstarts up, it makes the window smaller,
Xmoves it toward the top of the display,
Xthen writes the word "closed" in it.
XIf the window is covered by another window,
Xit changes the word "closed" to "hidden", then flashes its window every
X15 seconds as long as the window is covered.
XIf the window is then uncovered, the word "hidden" gets changed back
Xto "closed".
XActivating the window causes
X.I close
Xto restore the window's original shape and contents, then exit.
X.LP
X.SS
X/* iconify a MGR window */
X
X#include <signal.h>
X#include "term.h"
X
X#define TIME    15                /* time interval for reminder */
X#define CONTEXT P_POSITION | P_WINDOW | P_FLAGS | P_EVENT | P_CURSOR
X
Xstatic char line[80];             /* event input buffer */
X
Xmain()
X    {
X    int clean(), timer();         /* interrupt routines */
X    int x,y;                      /* window position on display */
X    char *msg = "closed";         /* closed window "icon" */
X
X    /* setup the window environment */
X
X    m_setup(M_FLUSH);             /* setup i/o, turn on flushing */
X    m_push(CONTEXT);              /* save current window context */
X    m_setmode(M_NOWRAP);          /* don't auto-wrap at right margin */
X    m_ttyset();                   /* set up tty modes */
X
X    /* catch the appropriate signals */
X
X    signal(SIGTERM,clean);        /* in case we get terminated */
X    signal(SIGALRM,timer);        /* for the reminder service */
X
X    /* iconify the window */
X
X    get_size(&x,&y,0,0);          /* fetch window coordinates */
X    m_sizeall(x,10,strlen(msg),1);/* move and resize window */
X    m_clear();                    /* clear the window */
X    m_printstr(msg);              /* print message in the window */
X
X    /* catch events */
X
X    m_setevent(ACTIVATE, "A\er"); /* window is now the active window */
X    m_setevent(COVERED,  "C\er"); /* covered by another window */
X    m_setevent(UNCOVERED,"U\er"); /* completely visible */
X    m_setevent(REDRAW,   "R\er"); /* redraw requested */
X
X    m_clearmode(M_ACTIVATE);      /* bury the window */
X
X    /* wait for an event */
X
X    while(m_gets(line) != NULL)   /* read a line from MGR */
X        switch (*line) {
X        case 'A':                 /* window is activated */
X            clean();              /* clean up and exit */
X            break;
X        case 'C':                 /* window is covered */
X            m_clear();
X            m_printstr("hidden");
X            alarm(TIME);          /* turn on reminder */
X            break;
X        case 'R':                 /* system 'redraw' */
X        case 'U':                 /* window is uncovered */
X            m_clear();
X            m_printstr(msg);
X            alarm(0);             /* turn off reminder */
X            break;
X        case 'T':                 /* send reminder */
X            m_setmode(M_WOB);     /* highlight window */
X            m_bell();             /* ring the bell */
X            sleep(1);
X            alarm(TIME);          /* reset reminder timer */
X            m_clearmode(M_WOB);   /* reset window highlighting */
X            break;
X        }
X    }
X
Xclean()                           /* clean up and exit */
X    {
X    m_ttyreset();                 /* reset tty modes */
X    m_popall();                   /* restore window context */
X    exit(0);
X    }
X
Xtimer()                           /* called at reminder timeout */
X    {
X    m_sendme("T\er");             /* send timeout message */
X    }
X.SE
X.Sh page Macros and Functions by Category
X.LP
X.FS *
XThe routines marked with a dagger (\(dg) are functions,
Xthe other routines are macros.  The page number on which the macro or
Xfunction is defined is printed in bold face after the name.
X.FE
END_OF_FILE
# end of 'doc/usrman/doc.6'
fi
if test -f 'src/down_load.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/down_load.c'\"
else
echo shar: Extracting \"'src/down_load.c'\" \(11133 characters\)
sed "s/^X//" >'src/down_load.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: down_load.c,v 4.2 88/07/25 10:35:27 sau Exp $
X	$Source: /tmp/mgrsrc/src/RCS/down_load.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/down_load.c,v $$Revision: 4.2 $";
X
X/* down load text -- called from put_window.c */
X
X#include <sys/file.h>
X#include "bitmap.h"
X#include "font.h"
X#include "defs.h"
X#include "menu.h"
X#include "event.h"
X#include <stdio.h>
X#include "window.h"
X
Xint
Xdown_load(win,window,text)
Xregister WINDOW *win;
XBITMAP *window, *text;
X   {
X   int cnt = W(esc_cnt);
X   struct font *Get_font();
X   struct menu_state *do_menu();
X   int id;
X
X      switch(W(code)) {
X         case T_INVALID:		/* invalid text mode */
X		if( debug )
X		   fprintf(stderr,"mgr: invalid download code\n");
X		break;
X         case T_MENU:				/* down load menu */
X                {
X                struct font *f;
X                int fn = W(esc[1]);
X
X                if (*W(snarf) && cnt>1 ) {
X                   f=Get_font(fn);
X                   }
X                else
X                   f = W(font);
X                  
X                if (*W(snarf)) {
X                   W(menus)[*W(esc)] = do_menu(W(snarf),f,
X                           PUTCOLOR(W(style)),PUTCOLOR(W(background)));
X		   if( active == win ) {
X                      if (W(menu[0]) == *W(esc) && button_state==BUTTON_2)
X                        go_menu(0);
X                      else if (W(menu[1]) == *W(esc) && button_state==BUTTON_1)
X                        go_menu(1);
X		      }
X                   }
X                else
X                   W(menus)[*W(esc)] = (struct menu_state *) 0;
X                free(W(snarf));
X                W(snarf) = (char *) 0;
X                }
X                break;
X         case T_EVENT:				/* down load an event */
X                cnt=W(esc)[0];
X                if (!CHK_EVENT(cnt)) {
X                   free(W(snarf));
X                   W(snarf) = (char *) 0;
X                   break;
X                   }
X                if (W(events)[GET_EVENT(cnt)]) {
X                   free (W(events)[GET_EVENT(cnt)]);
X                   W(events)[GET_EVENT(cnt)] = (char *) 0;
X                   }
X                if (*W(snarf)) {
X                   W(events)[GET_EVENT(cnt)] = W(snarf);
X                   EVENT_SET_MASK(win,cnt);
X#ifdef DEBUG
X                   dprintf(e)(stderr,"%s: setting event %d (%d)[%s]\r\n",
X                           W(tty),GET_EVENT(cnt),strlen(W(snarf)), W(snarf));
X#endif
X                   /* if button is down, then do the associated event */
X
X                   if (win == active  &&
X			(cnt==EVENT_B1_DOWN && button_state == BUTTON_1 ||
X                         cnt==EVENT_B2_DOWN && button_state == BUTTON_2))
X		      do_event(button_state,win,E_MAIN);
X                   }
X                else  {
X                   EVENT_CLEAR_MASK(win,cnt);
X#ifdef DEBUG
X                   dprintf(e)(stderr,"%s: clearing event %d\r\n",
X                             W(tty),GET_EVENT(cnt));
X#endif
X                   free(W(snarf));
X                   }
X                W(snarf) = (char *) 0;
X                break;
X         case T_STRING:				/* draw text into offscreen bitmap */
X                {
X                int x = cnt>1 ? Scalex(W(esc[1])) : 0;
X                int y = cnt>2 ? Scaley(W(esc[2])) : 0;
X
X                if (y<FSIZE(high)) y=FSIZE(high);
X                if (x<0) x=0;
X#ifdef DEBUG
X                dprintf(y)(stderr,"%s: drawing [%s] to %d\r\n",
X                    W(tty),W(snarf),*W(esc));
X#endif
X                if (*W(esc)>0 && W(bitmaps)[*W(esc)-1] == (BITMAP *) 0) {
X                   W(bitmaps)[*W(esc)-1] = bit_alloc(
X                          x+strlen(W(snarf))*FSIZE(wide),
X                          y, NULL_DATA,DEPTH);
X#ifdef DEBUG
X                dprintf(y)(stderr,"%s: STRING creating %d (%dx%d)\n",
X                          W(tty),*W(esc),
X                          x+strlen(W(snarf))*FSIZE(wide),y);
X#endif
X                   }
X                if (*W(esc) > 0)
X                   put_str(W(bitmaps)[*W(esc)-1],x,y,
X                           W(font),W(op),W(snarf));
X                else
X                   put_str(window,x,y,W(font),W(op),W(snarf));
X                }
X                break;
X         case T_YANK:				/* fill yank buffer */
X                if (snarf)
X                   free (snarf);
X                snarf = W(snarf);
X#ifdef DEBUG
X                dprintf(y)(stderr,"%s: yanking [%s]\r\n",W(tty),snarf);
X#endif
X                id_message = W(pid);
X                W(snarf) = (char *) 0;
X                for(win=active;win != (WINDOW *) 0;win=W(next))
X                   do_event(EVENT_SNARFED,win,E_MAIN);
X                break;
X
X         case T_SEND:				/* send a message */
X                id = *W(esc);
X                if (message) {
X                   free(message);
X                   message = (char *) 0;
X                   }
X                message = W(snarf);
X                id_message = W(pid);
X                W(snarf) = (char *) 0;
X#ifdef DEBUG
X                dprintf(e)(stderr,"%s: sending [%s]\r\n",W(tty),W(snarf));
X                dprintf(c)(stderr,"sending %d->%d: %s\r\n",
X                   W(pid),cnt==0?0:id,message);
X#endif
X                for(win=active;win != (WINDOW *) 0;win=W(next))
X                   if (cnt==0 || W(pid)==id) {
X                      do_event(EVENT_ACCEPT,win,E_MAIN);
X                      if (cnt) break;
X                      }
X                break;
X
X         case T_GMAP:				/* load a bitmap from a file */
X                {
X                   BITMAP *b, *bitmapread();
X		   FILE *fp = NULL;
X                   char filename[MAX_PATH];
X                   char c = *W(snarf);
X
X                   /* make relative to icon directory */
X
X                   if (c == '/' || (c == '.' && W(snarf)[1]=='/'))
X                      strcpy(filename,W(snarf));
X                   else
X                      sprintf(filename,"%s/%s",icon_dir,W(snarf));
X
X                   if (*W(esc) > 0 && *W(esc) < MAXBITMAPS &&
X                            read_ok(filename) &&
X			    (fp = fopen(filename,"r")) != NULL &&
X                            (b = bitmapread(fp))) {
X		      if( W(bitmaps[*W(esc)-1]) )
X			 bit_destroy( W(bitmaps[*W(esc)-1]) );
X		      W(bitmaps[*W(esc)-1]) = b;
X                      sprintf(filename,"%d %d\n",BIT_WIDE(b),BIT_HIGH(b));
X                      write(W(to_fd),filename,strlen(filename));
X                      }
X                   else {
X                      write(W(to_fd),"\n",1);
X                      }
X		   if( fp != NULL )
X			fclose(fp);
X                   }
X                break;
X
X         case T_SMAP:				/* save a bitmap on a file */
X                {
X		   FILE *fp;
X                   BITMAP *b;
X                   int size;
X                   int exists;		/* file already exists */
X                   int free_b = 0;
X                   int num = *W(esc);
X                   BITMAP *get_map();
X
X                   switch(cnt) {
X                      case 1:			/* off screen bitmap */
X                         if (num > 0)
X                            b = W(bitmaps[num-1]);
X                         else
X                            b = screen;
X                         break;
X                      case 0:			/* my window */
X                         free_b++;
X                         b = bit_alloc(BIT_WIDE(window),BIT_HIGH(window),
X                                       NULL_DATA,DEPTH);
X                         if (b)
X                            bit_blit(b,0,0,BIT_WIDE(b),BIT_HIGH(b),BIT_SRC,window,0,0);
X                         break;
X                      case 2:			/* other guy's window */
X                         free_b++;
X                         b = get_map(num,W(esc[1]));
X                         break;
X                      }
X               
X#ifdef DEBUG
X                   dprintf(*)(stderr,"saving...\n");
X#endif
X                   if (b && W(snarf) && ((exists=access(W(snarf),0)),
X                            write_ok(W(snarf))) &&
X                            (fp = fopen(W(snarf),"w")) != NULL) {
X#ifdef DEBUG
X                      dprintf(y)(stderr,"saving bitmap %d x %d on %s (%d)\n",BIT_WIDE(b),BIT_HIGH(b),W(snarf),fileno(fp));
X#endif
X                      if (exists<0)	/* file just created */
X                         fchown(fileno(fp),getuid(),getgid());
X                      bitmapwrite( fp, b, get_bm_type() );
X                      fclose(fp);
X#ifdef DEBUG
X                      dprintf(y)(stderr,"saved %d on %s\n",size,W(snarf));
X#endif
X                      }
X                   if (W(snarf))
X                      free(W(snarf));
X                   W(snarf) = (char *) 0;
X
X                   if (b && free_b)
X                      bit_destroy(b);
X                   }
X                break;
X
X         case T_GIMME:				/* send to process */
X                if (W(snarf) && *W(snarf)) 
X                   Write(W(to_fd),W(snarf),strlen(W(snarf)));
X#ifdef DEBUG
X                dprintf(y)(stderr,"%s: sending [%s]\r\n",W(snarf));
X#endif
X                if (W(snarf))
X                   free(W(snarf));
X                W(snarf) = (char *) 0;
X                break;
X
X         case T_GRUNCH:				/* graphics scrunch mode (experimental) */
X                if (W(snarf)) 
X                   grunch(win,window);
X#ifdef DEBUG
X                dprintf(y)(stderr,"%s: grunching [%d]\r\n",W(tty),W(esc)[cnt]);
X#endif
X                if (W(snarf))
X                   free(W(snarf));
X                W(snarf) = (char *) 0;
X                break;
X
X         case T_FONT:				/* change a font name */
X                if (W(esc)[0] <= MAXFONT && W(esc)[0] > 0) {
X                   if (fontlist[W(esc[0])-1])
X                      free(fontlist[W(esc[0])-1]);
X                   fontlist[W(esc[0])-1] = W(snarf);
X                   }
X                else
X                   free(W(snarf));
X                W(snarf) = (char *) 0;
X                break;
X         case T_BITMAP:				/* down-load a bitmap */
X                win_map(win,window);
X                break;
X         }
X   }
X
X/* find bitmap associated with window id */
X
XBITMAP *
Xget_map(id,sub)
Xint id;				/* pid of process controlling window */
Xint sub;			/* window number of this window */
X   {
X   register WINDOW *win;
X   register BITMAP *map;
X
X   for(win=active;win != (WINDOW *) 0;win=W(next))
X      if (W(pid)==id && W(num)==sub) {
X         map = bit_alloc(BIT_WIDE(W(window)),BIT_HIGH(W(window)),
X                         NULL_DATA,DEPTH);
X         if (map && W(flags)&W_ACTIVE)
X            bit_blit(map,0,0,BIT_WIDE(map),BIT_HIGH(map),
X                     BIT_SRC,W(window),0,0);
X         else if (map)
X            bit_blit(map,0,0,BIT_WIDE(map),BIT_HIGH(map),
X                     BIT_SRC,W(save),SUM_BDR,SUM_BDR);
X         return(map);
X         }
X   return(BIT_NULL);
X   }
END_OF_FILE
# end of 'src/down_load.c'
fi
if test -f 'src/win_subs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/win_subs.c'\"
else
echo shar: Extracting \"'src/win_subs.c'\" \(11289 characters\)
sed "s/^X//" >'src/win_subs.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: win_subs.c,v 4.2 88/06/21 14:48:26 sau Exp $
X	$Source: /tmp/mgrsrc/src/RCS/win_subs.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/win_subs.c,v $$Revision: 4.2 $";
X
X/* Teminal emulator functions called from put_window() */
X
X#include "bitmap.h"
X#include "font.h"
X#include "defs.h"
X#include "window.h"
X#include "clip.h"
X#include <stdio.h>
X
X#define FSIZE(c)	((int) (W(font)->head.c))
X#define Abs(x)		((x)>0?(x):-(x))
X
X/*****************************************************************************
X *	Do raster ops
X */
X
Xint
Xwin_rop(win,window)
Xregister WINDOW *win;
XBITMAP *window;
X    {
X    register int *p = W(esc);
X    register int op;
X
X    if (W(flags)&W_REVERSE)
X       op = ROP_INVERT(W(op));
X    else
X       op = W(op);
X
X#ifdef DEBUG
X    dprintf(B)(stderr,"%s: blit\t",W(tty));
X#endif
X    switch (W(esc_cnt)) {
X       case 0:		/* set raster op function */
X               W(op) = W(op)&~NOCOLOR | NOCOLOR&GET_OP(*p);
X               if (W(flags)&W_OVER) {
X                  W(style) = GET_OP(*p);
X                  if ((W(flags)&W_REVERSE) ^ (W(flags)&W_STANDOUT))
X                     W(style) = ROP_INVERT(*p);
X                  }
X#ifdef DEBUG
X               dprintf(B)(stderr,"setting function %d\n",p[0]);
X#endif
X               break;
X       case 1:    /* set raster op color && function */
X               W(op) = (NOCOLOR&GET_OP(p[0])) | (GETCOLOR(p[1]));
X#ifdef DEBUG
X               dprintf(B)(stderr,"setting mode %d, color %d\n",p[0],p[1]);
X#endif
X               break;
X
X       case 3:		/* ras_write */
X               bit_blit(window,Scalex(p[0]),Scaley(p[1]),
X                               Scalex(p[2]),Scaley(p[3]),
X                               op,NULL_DATA,0,0);
X               if (Do_clip())
X                  Set_clip(Scalex(p[0]),Scaley(p[1]),
X                           Scalex(p[0])+Scaley(p[2]),
X                           Scalex(p[1])+Scaley(p[3]));
X               break;
X       case 4:		/* ras_write  specify dest */
X               if (p[4]>MAXBITMAPS)
X                  break;
X               if (p[4]>0 && W(bitmaps)[p[4]-1]== (BITMAP *) 0)
X                  W(bitmaps)[p[4]-1] = bit_alloc(
X                              Scalex(p[0])+Scalex(p[2]),
X                              Scaley(p[1])+Scaley(p[3]),NULL_DATA,DEPTH);
X               bit_blit(p[4]?W(bitmaps)[p[4]-1]:window,
X                               Scalex(p[0]),Scaley(p[1]),
X                               Scalex(p[2]),Scaley(p[3]),
X                               op,0,0,0);
X               if (Do_clip() && p[4]==0)
X                  Set_clip(Scalex(p[0]),Scaley(p[1]),
X                           Scalex(p[0])+Scaley(p[2]),
X                           Scalex(p[1])+Scaley(p[3]));
X               break;
X       case 5:		/* ras_copy */
X               bit_blit(window,Scalex(p[0]),Scaley(p[1]),
X                               Scalex(p[2]),Scaley(p[3]),
X                               op,window,
X                               Scalex(p[4]),Scaley(p[5]));
X               if (Do_clip())
X                  Set_clip(Scalex(p[0]),Scaley(p[1]),
X                           Scalex(p[0])+Scaley(p[2]),
X                           Scalex(p[1])+Scaley(p[3]));
X               break;
X       case 7:		/* ras_copy specify dst,src */
X               if (p[6]>MAXBITMAPS || p[7]>MAXBITMAPS)
X                  break;
X               if (p[6]>0 && W(bitmaps)[p[6]-1]== (BITMAP *) 0) {
X                  W(bitmaps)[p[6]-1] = bit_alloc(
X                              Scalex(p[0])+Scalex(p[2]),
X                              Scaley(p[1])+Scaley(p[3]),NULL_DATA,DEPTH);
X                  }
X#ifdef DEBUG
X               dprintf(B)(stderr,"blitting %d to %d\n",p[7],p[6]);
X#endif
X               bit_blit(p[6]?W(bitmaps)[p[6]-1]:window,
X                           Scalex(p[0]),Scaley(p[1]),
X                           Scalex(p[2]),Scaley(p[3]),op,
X                           p[7]?W(bitmaps)[p[7]-1]:window,
X                           Scalex(p[4]),Scaley(p[5]));
X               if (Do_clip() && p[6]==0)
X                  Set_clip(Scalex(p[0]),Scaley(p[1]),
X                           Scalex(p[0])+Scaley(p[2]),
X                           Scalex(p[1])+Scaley(p[3]));
X       }
X   }
X
X/*****************************************************************************
X *	down load a bit map  - parse escape sequence
X */
X
Xint
Xwin_map(win,window)
Xregister WINDOW *win;
Xregister BITMAP  *window;
X   {
X   register int cnt = W(esc_cnt);
X   register int *p = W(esc);
X   register int op;
X
X   if (W(flags)&W_REVERSE)
X      op = ROP_INVERT(W(op));
X   else
X      op = W(op);
X
X   switch(cnt) {
X      case 2:		/* bitmap to graphics point */
X         bit_blit(window,Scalex(W(gx)),Scaley(W(gy)),
X                         p[0],p[1],op,W(bitmap),0,0);
X         bit_destroy(W(bitmap));
X         if (Do_clip()) {
X            Set_clip(Scalex(W(gx)),Scaley(W(gy)),
X                     Scalex(W(gx))+p[0],Scaley(W(gy))+p[1]);
X            }
X         break;
X      case 3:		/* bitmap to graphics point  specify dest*/
X         if (p[2] > MAXBITMAPS)
X            break;
X         if (p[2]>0 && W(bitmaps)[p[2]-1]== (BITMAP *) 0)
X            W(bitmaps)[p[2]-1]=W(bitmap);
X         else {
X            bit_blit(p[2]?W(bitmaps)[p[2]-1]:window,
X                         Scalex(W(gx)),Scaley(W(gy)),
X                         p[0],p[1],op,W(bitmap),0,0);
X            bit_destroy(W(bitmap));
X            }
X         break;
X      case 4:		/* bitmap to specified point */
X         bit_blit(window,p[2],p[3],p[0],p[1],op,W(bitmap),0,0);
X         bit_destroy(W(bitmap));
X         if (Do_clip()) {
X            Set_clip(p[2],p[3],p[2]+p[0],p[3]+p[1]);
X            }
X         break;
X      case 5:		/* bitmap to specified point  specify dest */
X         if (p[4] > MAXBITMAPS)
X            break;
X         if (p[4]>0 && W(bitmaps)[p[4]-1]== (BITMAP *) 0)
X            W(bitmaps)[p[4]-1]=W(bitmap);
X         else {
X            bit_blit(p[4]?W(bitmaps)[p[4]-1]:window,
X                        p[2],p[3],p[0],p[1],op,W(bitmap),0,0);
X            bit_destroy(W(bitmap));
X            }
X         break;
X      }
X   W(snarf) = (char *) 0;
X   }
X
X/*****************************************************************************
X *	plot a line 
X */
X
Xint
Xwin_plot(win,window)
Xregister WINDOW *win;
XBITMAP *window;
X    {
X    register int *p = W(esc);
X    int op;
X
X    if (W(flags)&W_REVERSE)
X       op = ROP_INVERT(W(op));
X    else
X       op = W(op);
X
X    switch (W(esc_cnt)) {
X       case 0:			/* set cursor to graphics point */
X               W(x) = Scalex(W(gx));
X               W(y) = Scaley(W(gy));
X               break;
X       case 1:			/* draw to graphics point */
X               Bit_line(win,window,Scalex(W(gx)),Scaley(W(gy)),
X                               Scalex(p[0]),Scaley(p[1]),op);
X               W(gx) = p[0];
X               W(gy) = p[1];
X               break;
X       case 3:
X               Bit_line(win,window,Scalex(p[0]),Scaley(p[1]),
X                               Scalex(p[2]),Scaley(p[3]),op);
X               break;
X       case 4:
X               if (p[4]<MAXBITMAPS && W(bitmaps)[p[4]-1])
X                  bit_line(W(bitmaps)[p[4]-1],Scalex(p[0]),Scaley(p[1]),
X                               Scalex(p[2]),Scaley(p[3]),op);
X               break;
X       }
X    }
X
XBit_line(win,dst,x1,y1,x2,y2,op)
Xregister WINDOW *win;
Xregister BITMAP *dst;
Xregister int x1,y1,x2,y2,op;
X   {
X#ifdef DEBUG
X   dprintf(l)(stderr,"%s: line [%d] %d,%d %d,%d\n",W(tty),op,x1,y1,x2,y2);
X#endif
X   bit_line(dst,x1,y1,x2,y2,op);
X   if (Do_clip()) {
X      Set_clip(x1,y1,x2+1,y2+1); 
X      Set_clip(x2,y2,x1+1,y1+1); 
X      }
X   }
X
X
X/* experimantal graphics crunch mode */
X
Xint
Xgrunch(win,dst)
XWINDOW *win;	/* window */
XBITMAP *dst;	/* destination */
X	{
X   register char *buf = W(snarf);
X   register int cnt = W(esc)[W(esc_cnt)];
X   int op;
X	int penup = 0;
X   int *p = W(esc);
X	register int x,y,x1,y1;
X
X   if (W(flags)&W_REVERSE)
X      op = ROP_INVERT(W(op));
X   else
X      op = W(op);
X
X	/* set starting point */
X
X	if (W(esc_cnt) > 1) {
X      x =  p[0];
X      y =  p[1];
X      }
X	else {
X      x = W(gx);
X      y = W(gy);
X		}
X	while (cnt-- > 0) {
X		x1 = (*buf>>4 & 0xf) - 8;
X		y1 = (*buf & 0xf) - 8;
X		if (x1==0 && y1 ==0)
X         penup = 1;
X      else if (penup == 0){
X         bit_line(dst,Scalex(x),Scaley(y),Scalex(x+x1),Scaley(y+y1),op);
X#ifdef DEBUG
X         dprintf(y)(stderr,"%s: line [%d] %d,%d + %d,%d\n",W(tty),op,x,y,x1,y1);
X#endif
X			x += x1;
X         y += y1;
X			}
X		else {
X			x += x1;
X         y += y1;
X			penup = 0;
X			}
X		buf++;
X		}
X	W(gx) = x;
X   W(gy) = y;
X	}
X
X/*****************************************************************************
X *	plot a circle 
X */
X
Xint
Xcircle_plot(win,window)
Xregister WINDOW *win;
XBITMAP *window;
X    {
X    register int *p = W(esc);
X    int op;
X
X    if (W(flags)&W_REVERSE)
X       op = ROP_INVERT(W(op));
X    else
X       op = W(op);
X
X
X    switch (W(esc_cnt)) {
X       case 0:		/* draw a 'circle'  at graphics point*/
X               circle(window,Scalex(W(gx)),Scaley(W(gy)),Scalexy(p[0]),op);
X               break;
X       case 1:		/* draw an 'ellipse' at graphics point */
X               ellipse(window, Scalex(W(gx)), Scaley(W(gy)),
X                               Scalex(p[0]), Scaley(p[1]), op);
X               break;
X       case 2:		/* draw a 'circle' */
X               circle(window,Scalex(p[0]),Scaley(p[1]),Scalexy(p[2]),op);
X               break;
X       case 3:		/* draw an 'ellipse' */
X               ellipse(window, Scalex(p[0]), Scaley(p[1]),
X                               Scalex(p[2]), Scaley(p[3]), op);
X               break;
X       case 4:		/* draw an 'ellipse' to offscreen bitmap */
X               if (p[4]<MAXBITMAPS && W(bitmaps)[p[4]-1])
X                  ellipse(W(bitmaps)[p[4]-1], Scalex(p[0]), Scaley(p[1]),
X                               Scalex(p[2]), Scaley(p[3]), op);
X               break;
X       case 5:		/* draw an arc  ccw centered at p0,p1 */
X               arc(window, Scalex(p[0]), Scaley(p[1]), Scalex(p[2]), Scaley(p[3]),
X                               Scalex(p[4]), Scaley(p[5]), op);
X               break;
X       case 6:		/* draw an arc  ccw centered at p0,p1  to offscreen bitmap */
X               if (p[6]<MAXBITMAPS && W(bitmaps)[p[6]-1])
X                  arc(W(bitmaps)[p[6]-1], Scalex(p[0]), Scaley(p[1]), Scalex(p[2]),
X                                Scaley(p[3]), Scalex(p[4]), Scaley(p[5]), op);
X               break;
X       }
X    if (Do_clip())
X       Set_all();
X    }
X
X/*****************************************************************************
X *	move the graphics pointer
X */
X
Xint
Xwin_go(win)
Xregister WINDOW *win;
X    {
X    register int *p = W(esc);
X
X    switch (W(esc_cnt)) {
X       case 0:			/* set the graphics point to cursor pos */
X               W(gx) = W(x);
X               W(gy) = W(y);
X               break;
X       case 1: case 2:		/* set the graphics point */
X               W(gx) =  p[0];
X               W(gy) =  p[1];
X               break;
X       }
X    }
END_OF_FILE
# end of 'src/win_subs.c'
fi
echo shar: End of archive 34 \(of 61\).
cp /dev/null ark34isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
