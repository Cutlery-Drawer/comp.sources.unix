Subject:  v17i036:  MGR, Bellcore window manager, Part35/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 36
Archive-name: mgr/part35




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 35 (of 61)."
# Contents:  demo/misc/hpmgr.c font-16/Uoldeng22x30r lib/term.c
#   src/get_menus.c
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:43 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'demo/misc/hpmgr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/misc/hpmgr.c'\"
else
echo shar: Extracting \"'demo/misc/hpmgr.c'\" \(12178 characters\)
sed "s/^X//" >'demo/misc/hpmgr.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*
X**	hp2621 terminal emulator
X*/
X#ifndef lint
Xstatic char rcsid[] = "$Header: hpmgr.c,v 4.2 88/06/22 14:37:42 bianchi Exp $";
X#endif
X
X#include "term.h"
X#include <ctype.h>
X
X#define MAX_ROW		24
X#define MAX_COL		80
X
X#define C_X	(MAX_COL*f_w)		/* width of the screen */
X#define C_Y	(MAX_ROW*f_h)		/* height of the screen */
X/*
XFILE *outfile;
X*/
X
Xextern int more_out;
Xstatic char *m_fields[16];
X
Xint cur_x = 0;		/* cursor location */
Xint cur_y = 0;
X
Xextern char *shiftline();
Xextern char *del_line();
Xint banner_space;
Xint x,y,w,h,f_w,f_h;
X
Xint in_mode = 0;	/* insert mode flag */
X
X#define	min(a,b)	((a)<(b)?(a):(b))
X#define	max(a,b)	((a)>(b)?(a):(b))
X
Xint margin;
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X{
X	extern int verboseflag;
X	int dummy;
X
X	ckmgrterm( *argv );
X
X	if (argc > 1 && !(strcmp(argv[1],"-v")))
X	{
X		verboseflag = 1;
X	}
X
X/*
X	if ((outfile = fopen("hpmgr.out","w+")) == NULL)
X	{
X		printf("can't create logfile\n");
X		exit(1);
X	}
X*/
X
X	m_termin = stdin;
X	m_termout = stdout;
X
X	m_push(P_MENU|P_POSITION|P_EVENT|P_FLAGS);
X	m_setmode(M_ABS);
X	get_size(&x,&y,&w,&h);
X	get_font(&f_w,&f_h);
X	get_margin(&margin);
X
X	banner_space = f_h+2;
X
X	m_setmode(M_BACKGROUND);
X
X	if ((w != C_X ) || ((C_Y + banner_space )!= h))
X	{
X		m_shapewindow(x,y,C_X+(2*margin),
X				  C_Y + banner_space + (2*margin));
X	}
X
X	get_size(&x,&y,&w,&h);
X	m_clear();
X
X	/* print the banner line */
X	m_printstr("                   HP2621 EMULATOR");
X	m_flush();
X	m_func(B_INVERT);
X	m_bitwrite(0,0,w,banner_space-1);
X	m_flush();
X	m_func(B_OR);
X
X	m_textregion(0,banner_space,C_X,C_Y);
X	m_clear();
X	m_flush();
X
X	do_env("TERM=","h2");
X	do_env("TERMCAP=","");
X	getpty((char**)0);
X	printf("\n\rPANIC -- getpty failed!! something is wrong!!\n\r");
X}
X
X
X
Xint
Xget_margin(x)
Xint *x;
X
X   { 
X   register int count;
X
X   if ((count = get_info(G_SYSTEM,m_fields)) >= 4) {
X      *x = atoi(m_fields[3]); 
X      return(1);
X      }
X   else 
X	return(-count);
X   }
X
Xinmassage(ptr,cnt)
Xchar *ptr; int cnt;
X{
X	return(cnt);
X}
X
Xoutmassage(ptr,cnt)
Xchar *ptr; int cnt;
X{
X	char *start = ptr;
X	char *to, *sptr, *shiftptr;
X	int newcnt = 0;
X	char newbuf[1024];
X	char smallb[1024];
X	static char holdb[1024];
X	
X	static int gotesc = 0;
X	static int gotamp = 0;
X	static int gota = 0;
X	static int gotc = 0;
X	static int goty = 0;
X	static int gotr = 0;
X	static int gotd = 0;
X	static int gotj = 0;
X
X	static int xval = 0;
X	static int yval = 0;
X
X/*
Xfprintf(outfile,"outmassage --  more = %d  cnt = %d\n",more_out,cnt);
Xfflush(outfile);
X*/
X	/*
X	**	check to see if we have more data on hold
X	*/
X	if (cnt == -2)
X	{
X		if (more_out)
X		{
X			to = ptr;
X			mystrncpy(&to,holdb,more_out);
X			cnt = more_out;
X			more_out = 0;
X		}
X		else
X		{
X			printf("panic -- outmassage got cnt = %d and more_out = %d\n",
X							cnt,more_out);
X			exit(1);
X		}
X	}
X	else
X	{
X		if (cnt <= 0)
X			return(cnt);
X	}
X
X	for(to = newbuf;(cnt > 0) && (newcnt < (1024-100));ptr++,cnt--)
X	{
X
X		*ptr &= 0177;
X/*
Xfputc(*ptr,outfile);
X*/
X
X		if (gotesc)
X		{
X			switch (*ptr)
X			{
X				case '\000':
X					goto out;
X				case ESC :
X					gotamp = gota = gotc = gotj = gotd  =
X						goty = gotr = 0;
X					goto out;
X				case '&' :
X					gotamp = 1;
X					goto out;
X				case 'a' :
X					gota = 1;
X					goto out;
X				case 'y' :
X					goty = 1;
X					goto out;
X				case 'r' :
X					gotr = 1;
X					goto out;
X				case 'c' :
X					gotc = 1;
X					goto out;
X
X				case 'd' :
X					gotd = 1;
X					goto out;
X				case '1' :
X				case '2' :
X				case '3' :
X					/*
X					**	skip tabs for now
X					*/
X					if (!gotamp)
X					{
X						gotesc = 0;
X						goto out;
X					}
X				case '0' :
X				case '4' :
X				case '5' :
X				case '6' :
X				case '7' :
X				case '8' :
X				case '9' :
X					if (gotc || goty || gotr)
X					{
X						yval *=10;
X						yval += (*ptr) - '0';
X					}
X					else
X					{
X						xval *=10;
X						xval += (*ptr) - '0';
X					}
X					goto out;
X				case 'j' :
X					gotj = 1;
X					goto out;
X				/*
X				**	begin standout mode
X				*/
X				case 'D' :
X					if (gotamp && gotd)
X					{
X						*to++ = ESC;
X						*to++ = 'i';
X						newcnt += 2;
X					}
X					gotesc = gotamp = gotj = gotd = 0;
X					goto out;
X				/*
X				**	skip keyboard mode for now
X				**	but  handle end of standout mode
X				*/
X				case '@' :
X					if (gotamp && gotd)
X					{
X						*to++ = ESC;
X						*to++ = 'n';
X						newcnt += 2;
X					}
X					gotesc = gotamp = gotj = gotd = 0;
X					goto out;
X				case 'B' :
X					if (gotamp)
X					{
X						gotesc = gotamp = gotj = 0;
X						goto out;
X					}
X					goto parsepanic;
X				
X				/*
X				**	clear screen
X				*/
X				case 'J' :
X					*to++ = ESC;
X					*to++ = 'C';
X					newcnt += 2;
X					gotesc = 0;
X					goto out;
X
X				/*
X				**	home cursor
X				*/
X				case 'H' :
X					sprintf(smallb,"%c%d,%dM",ESC,0,0);	
X					mystrncpy(&to,smallb,strlen(smallb));
X					newcnt += strlen(smallb);
X					cur_x = cur_y = gotesc = 0;
X					goto out;
X
X				/*
X				**	clear to eol
X				*/
X				case 'K' :
X					*to++ = ESC;
X					*to++ = 'c';
X					newcnt += 2;
X					gotesc =0;
X					goto out;
X				
X				/*
X				**	delete line
X				*/
X				case 'M' :
X					*to++ = ESC;
X					*to++ = 'd';
X					newcnt += 2;
X					gotesc = 0;
X					goto out;
X					
X				/*
X				**	end insert mode 
X				*/
X				case 'R' :
X					if (gota && gotamp)
X					{
X						goto vertaddr;
X					}
X					in_mode = 0;
X					gotesc = 0;
X					goto out;
X				/*
X				**	start insert mode 
X				*/
X				case 'Q' :
X					in_mode = 1;
X					gotesc = 0;
X					goto out;
X
X				/*
X				**	open line 
X				*/
X				case 'L' :
X					*to++ = ESC;
X					*to++ = 'a';
X					newcnt += 2;
X					gotesc=0;
X					goto out;
X					
X				/*
X				**	up line 
X				*/
X				case 'A' :
X					*to++ = ESC;
X					*to++ = 'u';
X					newcnt += 2;
X					gotesc=0;
X					goup();
X					goto out;
X					
X				case 'i' :
X					cur_x -= (cur_x%8?cur_x%8:8);
X					sprintf(smallb,"%c%d,%dM", ESC,cur_x,cur_y);	
X					mystrncpy(&to,smallb,strlen(smallb));
X					newcnt += strlen(smallb);
X					gotesc = 0;
X					goto out;
X
X				/*
X				**	delete char
X				*/
X				case 'P' :
X					shiftptr = del_line();
X					mystrncpy(&to,shiftptr,strlen(shiftptr));
X					newcnt += strlen(shiftptr);
X					gotesc=0;
X					goto out;
X					
X				/*
X				**	non destructive space
X				**	and horizontal motion
X				*/
X				case 'C' :
X					if (gotamp)
X					{
X						if (gota)
X						{
X							if(gotr||goty)
X							{
X								goto fulladdr;
X							}
X							sprintf(smallb,
X								"%c%d,%dM",ESC,xval,cur_y);	
X							mystrncpy(&to,smallb,strlen(smallb));
X							newcnt += strlen(smallb);
X							cur_x = xval;
X							gotesc = gotamp = gota =
X								gotc = xval = yval = 0;
X						}
X						else
X						{
X							goto parsepanic;
X						}
X					}
X					else
X					{
X						*to++ = ESC;
X						*to++ = 'r';
X						newcnt += 2;
X						gotesc=0;
X						goright();
X					}
X					goto out;
X					
X
X				case 'Y' :
X			vertaddr:
X					if (gotamp && gota)
X					{
X			fulladdr:
X						if (goty || gotr)
X						{
X							int tmp;
X							tmp = xval;
X							xval = yval;
X							yval = tmp;
X						}
X						if (gotc || goty || gotr)
X						{
X							/*
X							**	2-D cursor motion
X							*/
X/*
Xfprintf(outfile,"xval = %d, yval = %d",xval,yval);
Xfflush(outfile);
X*/
X							if (yval > MAX_ROW-1)
X							{
X								fprintf(stderr,
X								"PANIC -- got address > 23 = %d", yval);
X								sleep(10);
X							}
X							sprintf(smallb,"%c%d,%dM",
X								ESC,xval,yval);	
X							mystrncpy(&to,smallb,strlen(smallb));
X							newcnt += strlen(smallb);
X							cur_x = xval;
X							cur_y = yval;
X							gotesc = gotamp = gota = gotc =
X								xval = yval = goty = gotr = 0;
X						}
X						else
X						{
X							/*
X							**	vertical motion
X							*/
X							if (xval > MAX_ROW-1)
X							{
X								fprintf(stderr,
X								"PANIC -- got address > 23 = %d", xval);
X								sleep(10);
X							}
X							sprintf(smallb,
X								"%c%d,%dM",ESC,cur_x,xval);	
X							mystrncpy(&to,smallb,strlen(smallb));
X							newcnt += strlen(smallb);
X							cur_y = xval;
X							gotesc = gotamp = gota =
X								gotr = goty = gotc = xval = yval = 0;
X						}
X						goto out;
X					}
X					else
X					{
X						goto parsepanic;
X					}
X				default : 
X		  parsepanic:;
X/*
X					fprintf(outfile,"|BAD ESCAPE CODE esc = %d gotamp = %d gota = %d gotc = %d gotj = %d goty = %d gotr = %d code = %o|\n",
X					gotesc,gotamp,gota,gotc,
X						gotj,goty,gotr,*ptr);
X*/
X					printf("|BAD ESCAPE CODE esc = %d gotamp = %d gota = %d gotc = %d gotj = %d goty = %d gotr = %d code = %o|\n",
X					gotesc,gotamp,gota,gotc,
X						gotj,goty,gotr,*ptr);
X					sleep(10);
X					gotesc = gotamp = gota = gotc = xval = yval = 0;
X					goto out;
X			}
X		}
X
X		switch (*ptr)
X		{
X			case '\000' :
X				break;
X			case ESC:
X				gotamp = gota = gotc = gotj =
X					goty = gotr = xval = yval = 0;
X				gotesc = 1;
X				break;
X			case '\010' :
X				goleft();
X				goto dochar;
X			case '\012' :
X				godown();
X				goto dochar;
X			case '\015' :
X				cur_x = 0;
X				goto dochar;
X			case '\011' :
X				cur_x += (8 - (cur_x%8));
X				goto dochar;
X			default:
X				if (in_mode && isprint(*ptr))
X				{
X					shiftptr = shiftline();
X					mystrncpy(&to,shiftptr,strlen(shiftptr));
X					newcnt += strlen(shiftptr);
X				}
X				goright();
X		dochar :
X				*to++ = *ptr;
X				newcnt++;
X				break;
X		}
X	out:;
X	}
X
X	/*
X	**	make sure we didn't over run the end of the buffer
X	*/
X	if ((newcnt < 0) || (newcnt >= 1024))
X	{
X		printf("panic: newcnt = %d, out of range\n",newcnt);
X	}
X	/*
X	**	did we run out of buffer space before finishing the input?
X	*/
X	if (cnt)
X	{
X		to = holdb;
X		mystrncpy(&to,ptr,cnt);
X		more_out = cnt;
X	}
X	strncpy(start,newbuf,newcnt);
X/*
X	fprintf(outfile,"newcnt = %d\n",newcnt);
X	if ((newcnt > 0) && (newcnt < 1024))
X		fwrite(start,sizeof(char),newcnt,outfile);
X*/
X	return(newcnt);
X}
X
Xgoright()
X{
X	if (cur_x == (MAX_COL-1))
X	{
X		cur_x = 0;
X		godown();
X	}
X	else
X	{
X		cur_x++;
X	}
X}
X
Xgoleft()
X{
X	cur_x = max(0,cur_x - 1);
X}
X
Xgoup()
X{
X	cur_y = max(0,cur_y - 1);
X}
X
Xgodown()
X{
X	cur_y = min(MAX_ROW - 1, cur_y + 1);
X}
X
Xchar *
Xshiftline()
X{
X	static char shiftbuf[1024];
X	static char buf2[1024];
X
X/*
Xfprintf(outfile,"cur_x = %d cur_y = %d\n\n",cur_x, cur_y);
Xfflush(outfile);
X*/
X
X	/*	m_func	 */
X	sprintf(shiftbuf,"%c%d%c",ESC,B_COPY,E_BITBLT);
X
X	/*	m_bitcopy */
X	sprintf(buf2,"%c%d,%d,%d,%d,%d,%d%c",
X		  ESC,
X		  (cur_x+1)*f_w,			/* dest  x */
X		  banner_space + (cur_y*f_h),		/* dest  y */
X		  f_w*((MAX_COL-1)-cur_x),		/* width  */
X		  f_h,					/* height */
X		  cur_x*f_w,				/* src  x */
X		  banner_space + (cur_y*f_h),		/* src  y */
X		  E_BITBLT);
X	strcat(shiftbuf,buf2);
X
X	/*	m_func	    */
X	sprintf(buf2,"%c%d%c",ESC,B_CLEAR,E_BITBLT);
X	strcat(shiftbuf,buf2);
X
X/*
X	sprintf(buf2,"%c%d,%d,%d,%d%c",
X		  ESC,
X		  cur_x*f_w,			 x
X		  banner_space + (cur_y*f_h),	 y 
X		  f_w,				width 
X		  f_h,				height
X		  E_BITBLT);
X	strcat(shiftbuf,buf2);
X
X*/
X	/*	m_func	    */
X	sprintf(buf2,"%c%d%c",ESC,B_OR,E_BITBLT);
X	strcat(shiftbuf,buf2);
X	return(shiftbuf);
X}
X
Xchar *
Xdel_line()
X{
X	static char shiftbuf[1024];
X	static char buf2[1024];
X	/*	m_func	 */
X	sprintf(shiftbuf,"%c%d%c",ESC,B_COPY,E_BITBLT);
X
X	/*	m_bitcopy */
X	sprintf(buf2,"%c%d,%d,%d,%d,%d,%d%c",
X		  ESC,
X		  cur_x*f_w,				/* dest x */
X		  banner_space + (cur_y*f_h),		/* dest y */
X		  f_w*((MAX_COL-1)-cur_x),		/* width  */
X		  f_h,					/* height */
X		  (cur_x+1)*f_w,			/* src  x */
X		  banner_space + (cur_y*f_h),		/* src  y */
X		  E_BITBLT);
X	strcat(shiftbuf,buf2);
X
X	/*	m_func	    */
X	sprintf(buf2,"%c%d%c",ESC,B_CLEAR,E_BITBLT);
X	strcat(shiftbuf,buf2);
X
X	sprintf(buf2,"%c%d,%d,%d,%d%c",
X		  ESC,
X		  C_X-f_w,			/*  x */
X		  banner_space + (cur_y*f_h),	/*  y */
X		  f_w,				/* width  */
X		  f_h,				/* height */
X		  E_BITBLT);
X	strcat(shiftbuf,buf2);
X
X	/*	m_func	    */
X	sprintf(buf2,"%c%d%c",ESC,B_OR,E_BITBLT);
X	strcat(shiftbuf,buf2);
X	return(shiftbuf);
X}
X
Xmystrncpy(to,from,cnt)
Xchar **to, *from; int cnt;
X{
X	while(cnt > 0)
X	{
X		**to = *from;
X		(*to)++;	/* increment the pointer,NOT the pointer to the pointer */
X		from++;
X		cnt--;
X	}
X}
Xcleanup()
X{
X	m_pop();
X	m_textreset();
X	m_clear();
X	exit(0);
X}
END_OF_FILE
# end of 'demo/misc/hpmgr.c'
fi
if test -f 'font-16/Uoldeng22x30r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-16/Uoldeng22x30r'\"
else
echo shar: Extracting \"'font-16/Uoldeng22x30r'\" \(12277 characters\)
sed "s/^X//" >'font-16/Uoldeng22x30r' <<'END_OF_FILE'
Xbegin 644 oldeng22x30r.fnt
XM%A8>"%L@                          @                         
XM                                                            
XM          /0 XP,  1 G_P XSQ!QB( !$ XW@!D  #C, XW@#C>  !$@> 1
XM "& /(P  A@#R.  _  ?@0#$8 (C  P&# 8"(.(P!                   
XM   @      $              #      "          "   (            
XM                                                            
XM         !P                                                 
XM                                              ?X!_@^ (O __X!
XM_G_#_'X B\!_OR"R  '^8!_OP'^_( #ET_ _ ./ ?KZ #CP'JW !_P __P'E
XM] <OH!Y??@\#X?)Z!P 0                  !       ,      (      
XM /@     4          4   0                                    
XM                                             #X             
XM                                      "                     
XM                      _L!_#. 1_ __\!_/_#^/X!'\!_9\&Y  '\X!_1
XMY']GP -VY_!_ \7@_L< /%X/[#@"!XA__P!V. ^QP =GQQ.'P_*\!__P    
XM              "@      <      $       SP     <          <  !P
XM                            "       @  "                    
XM                     !X                                #  #(
XM  !@  &   .  /^  (( ! P  P  #                             @\
XM!&,. R> 90>!&0.",9P#)X!&X8 [  $8X!&@^$;A@ 9\Y#B>!WCPCX< =X\(
XM^#@$ _!'_@!T. /AP ?'1P.'@G,< __@                  #P      < 
XM     &      !QP     <          <  !P                        
XM    $      !   $                                          H 
XM                               'T 'P  #Z  /H  .  /^  ?X #_@ 
XM!]  'T                            !< #8.!F( #0. !@  "X@&80 !
XMX0 =   "X !@< 'A !ITX#@(#.AP#H< SH< Z#@$ . $" !T. .AP ='1P'(
XM '(< /_                   #X      <      /      !P      <   
XM       <  !P                            <      #   ,        
XM                                  0                         
XM      ![X +@  ]\ #WP  <  ?\ !_P '_@ >^ ![X                  
XM          =. ,X.#.( '0. &@  ,X@,X@ &X  =   ,X &@( ;A #ITX#P(
XM#.@X#H< SH. Z#@& $ (B !T. .AP ='1P'( '(<  "                 
XM  !P      <      '@     !P      <          <  !P            
XM                <      &   8                                
XM          @                               !PX #@  X< #AP  < 
XM 0  !W@  _  <. !PX                            ^. <X.#.( '0. 
XM.@  <X@,Y  .X  =   <X .@  [A #ITX#P('.@X#H<!SH. Z#@/P  9B !T
XM. .AP ='1P#P '(<  "                    @      <      #P     
XM!P      <   0  !   <  !P                            <      &
XM   8                                                        
XM                  !PX #@  X< #AP  8  0  !P   "  <. !PX      
XM                      ^' <Z,&.( '8> .@  <X@8Z  .Z( =   <X .A
XMP [A #ITX"X(&.@<#H<!CH' Z#@;^#@SB !T. .AP ='1P#P '(<  $     
XM                      <      !X     !P      <   X  #@  <  !P
XM                            <      .   X                    
XM                                                      !PX #@
XM  X< #AP  X  0  !P   "  <. !PX "   (                      "'
XM \Z8&.( /7N >G  \_@8\  >Z\ ]   \X >FX![A 'OWX&X(..@<'O\#CH'!
XMZ' 9_]PSB #W^ >_P ='1P/^ //\  (                           < 
XM      \     !P      <   0  !   <  !P                        
XM    <      .   X                                            
XM                              !PX #@  P< #!P  T  0  !P   $  
XM<. !PX '   <                      $'!\[L..( ?0. ^OH!\_@X_@ ^
XM[<!]  !\X ^XX#[A /OWX.<(..@</H<#CH'#Z< </\ACB 'T. ^AP ]_?P/^
XM ?(<  0                           <       >@    !^      <   
XM       <  !P                            ?@     .   X        
XM                                                            
XM      !PX #@   <  !P !L  XX !P   (  <. !PX /@  ^            
XM          '_A\^...( ?0. ^_P!\_@XZ8 ^^<!]  !\X ^@<#[A /OWX.?X
XM.._\/H<#CO_#[^ /!^!CB 'T. ^AP!]'1P/^ ?(< '\                 
XM      $P  =@  &   O  !@ !^   ,  <P  R  #(  <0 !P  """ ((  " 
XM !$   @  R0  80 ?@  @@ '"  <(( X2 #+( /@@                   
XM                                          !PX #@   \  #@ !< 
XM _] !P@  (  ?^ !QX '   <                      /_A\Z...( ?7N 
XM^@@!\_@XZ, ^Z<!]  !\X ^@<#[A /OWX/^(..@</H<#CH'#_. 'Y/#CB 'W
XM^ ^_P!]'1P!X ?(< '\                       /]  ?Z  /P ''  'P 
XM!\   R0 =Z !\  'P  =X !P  '//@<^  /  #^  #P !_P !_@ ?  !QP '
XMO0 >\]!\^ 'WP ?_                                            
XM                  !PX #@  #\  '  "<  Y^ !WT  8  /\ "^X "   (
XM                      /_P<Z...( '8> .@@ <X@X[\ .[\ =   <X .@
XM8 [A #ITX".(..@<#O\#CH' ^. #_##CB !T. .AP!]_?P"< '(< '\     
XM                  &^  =\ !_P ''  \P !P  '#P >< "X  #@  >< !P
XM  /WW _< !SH 'G0 <Z "[P '?  <  !SX #S@ //.!/\ +C@ G^        
XM                                            ^         !PX #@
XM  '\  #H $<  @> !XX  P  ?^  0X                            (!
XMP<[^..( '0. .@@ <X@XZ. .Z< =   <X .AP [A #ITX"'(.._\#H<#CO_ 
XMZ'  _[#CB !T. .AP ='1P"< '/\ "                        ".  <<
XM !Y@ ''  <X !P  '#@ <<  X  #@  <, !P  ''' << !QP #C@ <<  Y@ 
XM'&  <  !QP #C@ ... .8 #C@  ,                                
XM                   !\         !PX #@  ,   !P /_@  . !PX  P  
XM<.   X                            0!P<Z...( '0. .@@ <X@XZ. .
XM[\ =   <X .GP [A #ITX"'(&.@8#H<!CH& Z'  '_#CB !T. .AP ='1P$.
XM '(< "                        #.  << !P  ''  << !P  '#@ <<  
XMX  #@  <8 !P  ''' << !QP #C@ <<  X  '$  <  !QP #C@ ... '  #C
XM@  P                                                   #X   
XM      !PX #@  (   !P  <   . !PX !P  <.   X                  
XM          0 X8[^',) '0. .@@ <X@8S\ .Z< =   <X .XX [! #ITX"#H
XM',@8#H<!S(& Z'  $_!S"0!T. .AP ='1P$. '(< $                  
XM      &N  << !P  ''  <8 !P  '#@ <<  X  #@  =X !P  ''' << !QP
XM #C@ <<  X  '^  <  !QP #C@ ... '  #C@ !                     
XM                                          !PX #@  0   !P  < 
XM  . !PX !@  <.   X                            @ X1R.'() &0. 
XM,@@ 8X@<B, ,R< =   8X ,@X R! #ITX"#H# @P#H< P(, Z#@ $;!R"0!T
XM. .AP ='1P(' '(< (                        ..  << !P  ''  =@ 
XM!P  '#@ <<  X  #@  >X !P  ''' << !QP #C@ <<  X  !_@ <  !QP #
XMC@ ... #@ #C@ /P                                            
XM    (      "      !PX #@  0   !P  <   . !PX #@  <.   X "   (
XM                     !P0<#".#P+ %P. /P@ 8X@,"8 .B8 9  !PX /A
XM< _! #ITX'!X# @P#H< P(, \#@ (3 \"P!\. .AP ?'1P<' '(< 0      
XM                  ..  << !P  ''  >  !P  '#@ <<  X  #@  <X !P
XM  ''' << !QP #C@ <<  X   C@ <  !QP #C@ ... #@ #C@ $         
XM                                        <      '      !PX #@
XM  3X  ]P  <  /N !PX #P  <.  >X '   <                     '\@
XM</R.#0^ '\. ?^B!^X@,"X ?C8#1  'XX ?R<!_Y(/)TX;QX!PC@/H< <(X!
XM_+@'_" T/@!_. .!P ?G1Q_+D'(< ?@$                      ..  <<
XM !P  ''  <  !P  '#@ <<  X  #@  <= !P  ''' << !QP #C@ <<  X  
XM!C@ <  !QP #C@ ... YP #C@ $                                 
XM                ^      /@     !]X #H  G] !_P  =  ?^ !]X #V  
XM?>  _X /@  ^                     /_ <?^.!_\ /_> __\#_X@'#P _
XM^0'Q  /\P _\.C__P?)TXO\X \O ?N\ /;P#_QT/_\ ?_ #_^@/_P _W_S_S
XMH'(< __X                      '?  N< "X@ +G  ?$ "Y  'S@ ^<  
XMX  #@  N> "Z  /OG@^> "YP 'S@ N<  Y  #[@ N@ !SX #C@ ...!_R #C
XM@ /\@                                               >      '
XM      "^  'P  _^ #_   ^  _X "^  !X  O@ !_@ '   >            
XM         >. ,\?P _X >/P!X/X'GP@#C !Y\0/^  >>@!XX/'@_@_RX=\<X
XM .\ ?O  #G 'CAX9_X /^ 'CW '@ !Y[P'CAP(_X!__P                
XM      #F  '@  ?  !X  /X  >  /_@ <8  <  !P  '<  <  ''' <<  > 
XM /\  '\ !>  '^  '  #]P %\  7]P#^\ #_@ ?_                    
XM                            *      "       ,  !@  X$ ""   , 
XM P0  ,   @  #  !!  "   *                     P$ %@'  /( P#@#
XM !P,!@@ \ # 8@(\  P' # 0&, ' C@0+@(8 #P 3L   ^ ,! PPGP #R , 
XMB !  # 1 ,! @8'P# ?@                      !$  "   ,   @  #@ 
XM (   S0 (0  (   P  "(  (  """ ((  (  +P  "<  ,   8  "   P@  
XMP  #C ",8 !@   ^                                            
XM    $                                                      $
XM                     P  !@    ( P  #   ,  @   #  @(   P  #  
XM ,   @  #@      #H   " ,   @@   " ,      #   ,   8          
XM                                         !P  0      X       
XM             #@   <                           "             
XM                                        (                   
XM                                   (                     @  
XM!     ( @  "   (  @   "  0&   @  "   (   @  #       #H   " (
XM   A    " (      "   (   8                                  
XM                 !P  (      X                    #@   <     
XM                      "'                                    
XM                                                            
XM                                 @  !     ( @  "   (  @   " 
XM 8!@  @  "   (   0  "       #H   # (   1    " (      "   (  
XM 8'P                                                  P  ,  
XM    8                    #@   <                           "/
XM@                                                           
XM                                                            
XM         @  !     ( @  "   (  @   "  <    @  "   (   0  "   
XM    #H   #"(   .    " (      "   (   /_X                    
XM                            & P  .      8                   
XM #@   <                           #_@                       
XM                                                            
XM                                             @  !     ( @  "
XM " (  @   "  <    @  "   ( ( ,  "       #H   #B(        " ( 
XM     "   (   /_\                                            
XM    -A@  .     'P                    #@   >                 
XM          #X@                                               
XM                                                            
XM                     0   @    8 0  ! , $ !@   !  \    0  !  
XM $ P #@ !       #@   !\$        & $      !   $   'X$        
XM                                        +7   >     /@       
XM             #    <                           !P@           
XM                                                            
XM                                                         ,  
XM 9    X ,   PP # #@    P X    ,   P  ##      P      #0    \#
XM        . #       P  #     $                                
XM                 N   <     /                     "    8     
XM                        @                                   
XM                                                            
XM                                 #   &    0 #   /   P!     ,
XM P    #   ,   \      ,      "     8 P       $  P      ,   P 
XM                                                     8   8  
XM   )                     $    0                            #
XM         P@(    X     @ (        @   (    __@               
XM                                          & P   X       8   
XM                     #@   !P                                
XM#_@                                                         
XM                                                            
XM                                (   !      @ (   " "  @ "   
XM  "  <     (   "    @ @ #   "         Z    #B @         "  @
XM       "    @   #__                                         
XM                 V&   #@      ?                         .   
XM '@                                /B                       
XM                                                            
XM                                                            
XM       0   "     &  0   $ P !  8     $ #P     0   $   ! ,  #
XM@  $        #@    'P!          8 !        $   !    'X$      
XM                                                   "UP   >  
XM    #X                         P    <                       
XM          <(                                                
XM                                                            
XM                                          P   &0    X  P   ,
XM,  # #@     , .      P   ,   ##       ,        -     / #    
XM     #@ #        ,   #      0                               
XM                           N   !P      /                    
XM     "    !@                                  @             
XM                                                            
XM                                                            
XM                 P   &    !   P   /   # $      , P      P   
XM,   #P       ,        @     8 #         $  #        ,   #   
XM                                                            
XM !@   &       D                         0    $              
X5                    ,       
X 
Xend
END_OF_FILE
# end of 'font-16/Uoldeng22x30r'
fi
if test -f 'lib/term.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/term.c'\"
else
echo shar: Extracting \"'lib/term.c'\" \(12324 characters\)
sed "s/^X//" >'lib/term.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: term.c,v 4.3 88/07/01 09:33:49 bianchi Exp $
X	$Source: /tmp/mgrsrc/lib/RCS/term.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/lib/RCS/term.c,v $$Revision: 4.3 $";
X
X/* routines for writing to mgr terminal emulator */
X
X#include "term.h"
X#include "restart.h"
X
XFILE	*m_termout;
XFILE	*m_termin;
Xint	m_flags;
Xint	m_envcount = 0;
Xint	m_saveenvcount = 0;
Xchar	m_escchar = ESC;
Xchar	m_menuchar = M_DELIM;
X
Xjmp_buf _env;
X
Xstruct sgttyb	sgtty__save[TTYMAX];
Xint		sgtty_cnt = 0;
Xchar		m_linebuf[MAXLINE];
Xstatic char	*m_fields[16];
X
X/******************************************************************************
X *
X *	setup
X */
X
Xint
Xm_setup(flags)
Xint flags;
X   {
X   m_flags = flags;
X
X   if (!(m_flags&M_DEBUG)) {
X      m_termout = fopen(M_DEVICEOUT,"w");
X      m_termin = fopen(M_DEVICEIN,"r");
X      }
X
X   if (m_termin == NULL || m_termout == NULL) 
X      m_flags |= M_DEBUG;
X
X   if (m_flags&M_DEBUG) {
X      m_termin = stdin;
X      m_termout = stdout;
X      }
X   return(m_flags);
X   }
X
X/******************************************************************************
X *
X *	get generic window parameters
X */
X
Xint
Xget_info(type,list)
Xint type;
Xchar **list;
X   { 
X   if (type > G_MAX )
X      return(-1);
X   switch( type ) {
X   case G_ALL:
X   case G_ALLMINE:
X	return(-1);
X   }
X   _m_ttyset();
X   m_getinfo(type);
X   m_gets(m_linebuf);
X   _m_ttyreset();
X   return  parse(m_linebuf,list); 
X   }
X
X/******************************************************************************
X *
X *	read window parameters off of standard input
X */
X
Xint
Xget_windata(windatap)
Xstruct window_data *windatap;
X   { 
X   if( parse(m_gets(m_linebuf),m_fields) < 8 )
X	return 0;
X   windatap->x = atoi(m_fields[0]);
X   windatap->y = atoi(m_fields[1]);
X   windatap->w = atoi(m_fields[2]);
X   windatap->h = atoi(m_fields[3]);
X   strcpy(windatap->tty,m_fields[4]);
X   windatap->num = atoi(m_fields[5]);
X   windatap->status = *m_fields[6];
X   windatap->setid = atoi(m_fields[7]);
X   return 1;
X}
X
X/******************************************************************************
X *
X *	Get window parameters, one window at a time.
X *	Returns 1 if window_data structure has been filled, 0 otherwise.
X *	It is important to call get_eachwin() in a tight loop that doesn't
X *	ever exit, so that all the data is picked up.
X */
X
Xint
Xget_eachwin( windatap )
Xstruct window_data *windatap;
X   { 
X   static int i = 0;
X
X   if( !i ) {
X      _m_ttyset();
X      m_getinfo(G_ALL);
X   }
X   i = get_windata( windatap );
X   if( !i )
X      _m_ttyreset();
X   return(i);
X   }
X
X
X/******************************************************************************
X *
X *	Get window parameters for the current window set, one window at a time.
X *	Returns 1 if window_data structure has been filled, 0 otherwise.
X *	It is important to call get_eachcleintwin() in a tight loop that
X *	doesn' tever exit, so that all the data is picked up.
X */
X
Xint
Xget_eachclientwin( windatap )
Xstruct window_data *windatap;
X   { 
X   static int i = 0;
X
X   if( !i ) {
X      _m_ttyset();
X      m_getinfo(G_ALLMINE);
X   }
X   i = get_windata( windatap );
X   if( !i )
X      _m_ttyreset();
X   return(i);
X   }
X
X/******************************************************************************
X *
X *	Get all window parameters.
X *	NOTE CAREFULLY: The array of window_data structures pointed to by
X *	list must be more than the total number of windows on the screen;
X *	not a robust technique.
X *	get_eachwin() is recommended above this.
X */
X
Xint
Xget_all(list)
Xstruct window_data *list;
X   { 
X   register int i;
X
X   for(i=0;  get_eachwin( list );  i++ )
X      list++;
X   return(i);
X   }
X
X/******************************************************************************
X *
X *	Get window parameters for client windows.
X *	NOTE CAREFULLY: The array of window_data structures pointed to by
X *	list must be more than the total number of windows on the screen;
X *	not a robust technique.
X *	get_eachclientwin() is recommended above this.
X */
X
Xint
Xget_client(list)
Xstruct window_data *list;
X   { 
X   register int i;
X
X   _m_ttyset();
X   m_getinfo(G_ALLMINE);
X   for(i=0;  get_windata( list );  i++ )
X      list++;
X   _m_ttyreset();
X   return(i);
X   }
X
X/******************************************************************************
X *
X *	get the window size
X */
X
Xint
Xget_size(x,y,wide,high)
Xint *x, *y, *wide, *high;
X
X   { 
X   register int count;
X
X   if ((count = get_info(G_COORDS,m_fields)) >= 4) {
X      if (x)
X         *x = atoi(m_fields[0]); 
X      if (y)
X         *y = atoi(m_fields[1]); 
X      if (wide)
X         *wide = atoi(m_fields[2]); 
X      if (high)
X         *high = atoi(m_fields[3]); 
X      return(count);
X      }
X   else return(-count);
X   }
X
X/******************************************************************************
X *
X *	get the mouse coords
X */
X
Xint
Xget_mouse(x,y)
Xint *x, *y;
X
X   { 
X   register int count;
X
X   if ((count = get_info(G_MOUSE2,m_fields)) >= 3) {
X      if (x)
X         *x = atoi(m_fields[0]); 
X      if (y)
X         *y = atoi(m_fields[1]); 
X      return(atoi(m_fields[2]));
X      }
X   else return(-count);
X   }
X
X/******************************************************************************
X *
X *	get system parameters
X */
X
Xint
Xget_param(host,xmax,ymax,border)
Xchar *host;
Xint *xmax, *ymax, *border;
X
X   { 
X   register int count;
X
X   if ((count = get_info(G_SYSTEM,m_fields)) >= 4) {
X      if (host)
X         strcpy(host,m_fields[0]);
X      if (xmax)
X         *xmax = atoi(m_fields[1]); 
X      if (ymax)
X         *ymax = atoi(m_fields[2]); 
X      if (border)
X         *border = atoi(m_fields[3]); 
X      return(count);
X      }
X   else return(-count);
X   }
X
X/******************************************************************************
X *
X *	get the cursor position
X */
X
Xint
Xget_cursor(x,y)
Xint *x, *y;
X
X   { 
X   register int count;
X
X   if ((count = get_info(G_CURSOR,m_fields)) > 2) {
X      if (x)
X         *x = atoi(m_fields[0]); 
X      if (y)
X         *y = atoi(m_fields[1]); 
X      return(2);
X      }
X   else return(-count);
X   }
X
X/******************************************************************************
X *
X *	get the window size - rows and columns
X */
X
Xint
Xget_colrow(cols,rows)
Xint *cols, *rows;
X
X   { 
X   register int count;
X
X   if ((count = get_info(G_WINSIZE,m_fields)) == 2) {
X      if (cols)
X         *cols = atoi(m_fields[0]); 
X      if (rows)
X         *rows = atoi(m_fields[1]); 
X      return(2);
X      }
X   else return(-count);
X   }
X
X/******************************************************************************
X *
X *	get the termcap entry
X */
X
Xchar *
Xget_termcap()
X   { 
X   _m_ttyset();
X   m_getinfo(G_TERMCAP);
X   m_gets(m_linebuf);
X   _m_ttyreset();
X   return(m_linebuf);
X   }
X
X/******************************************************************************
X *
X *	get the font size
X */
X
Xint
Xget_font(wide,high)
Xint  *wide, *high;
X
X   { 
X   register int count, result;
X
X   if ((count = get_info(G_FONT,m_fields)) >= 3) {
X      if (wide)
X         *wide = atoi(m_fields[0]); 
X      if (high)
X         *high = atoi(m_fields[1]); 
X      result = atoi(m_fields[2]); 
X      return(result);
X      }
X   else return(-count);
X   }
X
X/******************************************************************************
X *
X *	make a new window
X */
X
Xint
Xm_makewindow(x,y,wide,high)
Xint  x,y,wide,high;
X   { 
X   register int count, result;
X   _m_ttyset();
X   m_newwin(x,y,wide,high);
X   m_gets(m_linebuf);
X   _m_ttyreset();
X   return(atoi(m_linebuf));
X   }
X
X/******************************************************************************
X *
X *	see if window is active
X */
X
Xint
Xis_active()
X   { 
X   *m_linebuf = '\0';
X   get_info(G_STATUS,m_fields);
X   return(*m_linebuf == 'a');
X   }
X
X/******************************************************************************
X *
X *	return last line read
X */
X
Xchar *
Xm_lastline()
X   {
X   return(m_linebuf);
X   }   
X
X/******************************************************************************
X *
X *	down load a menu
X */
X
Xmenu_load(n,count,text)
Xint n;				/* menu number */
Xint count;			/* number of menu items */
Xstruct menu_entry *text;	/* menu choices */
X   {
X   register int i, len;
X
X   if (text == (struct menu_entry *) 0)
X      return (-1);
X
X   /* calculate string lengths */
X
X   len = 2 * count + 1;
X
X   for (i=0;i<count;i++)
X       len += strlen(text[i].value) + strlen(text[i].action);
X   
X   fprintf(m_termout,"%c%d,%d%c%c",m_escchar,n,len,E_MENU,m_menuchar);
X
X   for (i=0;i<count;i++)
X      fprintf(m_termout,"%s%c",text[i].value,m_menuchar);
X
X   for (i=0;i<count;i++)
X      fprintf(m_termout,"%s%c",text[i].action,m_menuchar);
X
X   m_flush();
X   }
X
X/******************************************************************************
X *
X *	download a bitmap 
X */
X
Xm_bitload(x,y,w,h,data)
Xint x,y;
Xint w,h;
Xregister char *data;
X   {
X   register int size = h * ((w+15)&~15)/8;		/* round to 16 bit boundary */
X   m_bitld(w,h,x,y,size);
X   while(size-- > 0)
X      fputc(*data++,m_termout);
X   m_flush();
X   }
X
X/******************************************************************************
X *
X *	Set and save the terminal mode  (if required);
X */
X
Xm_ttyset()
X   {
X	int code;
X   struct sgttyb buff;
X
X   code = gtty(fileno(m_termout),sgtty__save + sgtty_cnt);
X
X   if (sgtty__save[sgtty_cnt].sg_flags&(ECHO|RAW)) {
X      buff = sgtty__save[sgtty_cnt];
X      buff.sg_flags &= ~(ECHO|RAW);
X      m_flush();
X      stty(fileno(m_termout),&buff);
X      }
X
X   if (sgtty_cnt < TTYMAX)
X      sgtty_cnt++;
X
X	return(code);
X   }
X
X
X/******************************************************************************
X *
X *	Restore the terminal mode 
X */
X
Xm_ttyreset()
X   {
X   if (sgtty_cnt)
X      sgtty_cnt--;
X   else
X      return(1);
X
X   if (sgtty__save[sgtty_cnt].sg_flags&(ECHO|RAW)) {
X      m_flush();
X      return(stty(fileno(m_termout),sgtty__save + sgtty_cnt));
X      }
X   else
X      return(0);
X   }
X
X/******************************************************************************
X *
X *	change the terminal modes
X */
X
Xm_resetflags(flags)
X   {
X   struct sgttyb buff;
X      gtty(fileno(m_termin),&buff);
X      if (buff.sg_flags & flags) {
X         buff.sg_flags &= ~flags;
X	 m_flush();
X         stty(fileno(m_termin),&buff);
X         }
X   }
X
Xm_setflags(flags)
X   {
X   struct sgttyb buff;
X      gtty(fileno(m_termin),&buff);
X      if (!( buff.sg_flags & flags)) {
X         buff.sg_flags |= flags;
X	 m_flush();
X         stty(fileno(m_termin),&buff);
X         }
X   }
X
X/**
X	Given a bitmap id and an icon name,
X	have mgr load that icon into that bitmap, returning the icon width
X	and height via the given integer pointers.
X	Return a positive number if successful.
X	If the icon is not loaded, set the width and height values to 0 and
X	return 0.
X*/
Xint
Xm_bitfile( bitmapid, iconname, iconwidthp, iconheightp )
Xint	bitmapid;
Xchar	*iconname;
Xint	*iconwidthp,
X	*iconheightp;
X   {
X	*iconwidthp = *iconheightp = 0;
X	m_bitfromfile( bitmapid, iconname );
X	m_flush();
X	return( sscanf( m_get(), "%d %d", iconwidthp, iconheightp ) == 2 );
X   }
X
X/*****************************************************************************
X *	parse a line into fields
X */
X
X#ifndef iswhite
X#define iswhite(x)	((x)==' ' || (x)=='\t')
X#endif
X
Xint
Xparse(line,fields)
Xregister char *line;
Xregister char **fields;
X   {
X   int inword = 0;
X   int count = 0;
X   char *start;
X   register char c;
X
X   for(start = line;(c = *line) && c != '\n';line++)
X      if (inword && iswhite(c)) {
X         inword = 0;
X         *line = '\0';
X         *fields++ = start;
X         count++;
X         }
X      else if (!inword && !iswhite(c)) {
X         start = line;
X         inword = 1;
X         }
X
X   if (inword) {
X      *fields++ = start;
X      count++;
X      if (c == '\n')
X         *line = '\0';
X      }
X   *fields = (char *) 0;
X   return(count);
X   }
X
X/******************************************
X *	stuff for restarting
X */
X
X_Catch()
X   {
X   ioctl(fileno(m_termin),TIOCFLUSH,0);
X   longjmp(_env,1);
X   }
X
X_Clean()
X   {
X   while(m_saveenvcount < m_envcount)
X      m_pop(0);
X   exit(1);
X   }
END_OF_FILE
# end of 'lib/term.c'
fi
if test -f 'src/get_menus.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/get_menus.c'\"
else
echo shar: Extracting \"'src/get_menus.c'\" \(11895 characters\)
sed "s/^X//" >'src/get_menus.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: get_menus.c,v 4.1 88/06/21 13:33:43 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/RCS/get_menus.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/get_menus.c,v $$Revision: 4.1 $";
X
X/******************************************************************************
X *
X *	low level popup menu management routines
X */
X
X#include <stdio.h>
X#include "bitmap.h"
X#include "menu.h"
X#include "font.h"
X
X#define MAX_LIST	100	/* max number of choices */
X#define BLIP		8	/* size of cursor blip */
X
X#define BETWEEN(a,x,b)	(x)<(a)?a:((x)>(b)?b:x)
X
X#define Pr_ropall(S,f)	bit_blit(S,0,0,BIT_WIDE(S),BIT_HIGH(S),f,NULL_DATA,0,0)
X
X#define BAR(s,z)	bit_blit(s, 0, (z+1)*state->bar_sizey, \
X                               state->bar_sizex, state->bar_sizey, \
X                               BIT_NOT(BIT_DST), NULL_DATA, 0, 0);
X
X#ifdef NOTRACK
X#define TRACKON(s,x,y)
X#define TRACKOFF(s,x,y)
X#else
X#define TRACKON(s,x,y) { \
X	bit_blit(&track,0,0,BLIP,BLIP, \
X	BIT_SRC,s,(x)-BLIP/2,(y)-BLIP/2); \
X	bit_blit(s,(x)-BLIP/2,(y)-BLIP/2,BLIP,BLIP, \
X	BIT_NOT(BIT_SRC) & BIT_DST,&mouse_bull,0,0); \
X	bit_blit(s,(x)-BLIP/2,(y)-BLIP/2,BLIP,BLIP, \
X	BIT_SRC | BIT_DST,&mouse_bull2,0,0); \
X	}
X#define TRACKOFF(s,x,y) \
X	bit_blit(s,(x)-BLIP/2,(y)-BLIP/2,BLIP,BLIP, \
X	BIT_SRC,&track,0,0)
X#endif
X
X#ifndef Min
X#define Min(x,y)		((x)>(y)?(y):(x))
X#endif
X#ifndef Max
X#define Max(x,y)		((x)>(y)?(x):(y))
X#endif
X#define LIMIT(x,max)		(x)>(max)?1:(-(x)>(max)?-1:0)
X#define Abs(x)			((x)>0?(x):-(x))
X#define MENU			struct menu_state
X
X/*	The height of each selection area (i.e. word) in the pop-up menu.
X	The 2 extra pixels create a 1-pixel boarder above and below each word.
X*/
X#define HIGH		(font->head.high+2)
X
Xextern BITMAP mouse_bull, mouse_bull2;
Xstatic unsigned short save_bits[BLIP];
Xstatic bit_static(track,BLIP,BLIP,save_bits,DEPTH);
X
X/* allocate space for and initialize menu */
X
Xstruct menu_state *
Xmenu_define(font,list,values,max,fg,bg)
Xstruct font *font;		/* which font to use for menu */
Xchar *list[];			/* list of menu items */
Xchar *values[];			/* list of return values */
Xint max;			/* max number of menu items */
Xint fg,bg;		/* clt values for menu color */
X   {
X   register int i, incr, count;	/* counters */
X   int size_x=0, size_y=0;
X   struct menu_state *state;	/* menu state */
X   char *malloc(), *save_line();
X   BITMAP *menu,			/* menu image */
X	 *box,			/* menu pix_rect */
X	 *inside,		/* box - border */
X	 *save;			/* part of screen covered by menu */
X   int box_x, box_y;		/* dimensions of menu box */
X
X   /* find size of box */
X
X   for(count=0;list[count]!=(char *) 0 && count<(max>0?max:MAX_LIST); count++) {
X      size_x = Max(size_x,strlen(list[count]));
X      }
X
X   /*	The 2 extra pixels are to allow a 1-pixel border to the left and right
X	of each word.
X   */
X   size_x = size_x * font->head.wide + 2;
X   size_y = count * HIGH;
X   box_x =size_x+2*MENU_BORDER;
X   box_y =size_y+2*MENU_BORDER;
X
X   /* build box */
X
X   menu = bit_alloc(box_x,box_y,NULL_DATA,DEPTH);
X   inside = bit_create(menu,MENU_BORDER,MENU_BORDER,size_x,size_y);
X
X   /* paint text into box */
X
X#ifdef COLOR
X   Pr_ropall(menu,BIT_SRC|GETCOLOR(fg));
X   Pr_ropall(inside,BIT_SRC|GETCOLOR(bg));
X#else
X   Pr_ropall(menu,BIT_SET);
X   Pr_ropall(inside,BIT_CLR);
X#endif
X   for(i=0,incr=HIGH-1;i<count;i++,incr+=HIGH) {
X#ifdef COLOR
X      /* do local color here */
X      put_str(inside,1,incr,font,
X              BIT_SRC^BIT_DST | GETCOLOR(bg)^GETCOLOR(fg),list[i]);
X#else
X      put_str(inside,1,incr,font,BIT_SRC,list[i]);
X#endif
X      }
X
X   /* save the menu state */
X
X   if ((state = (MENU *) malloc(sizeof(struct menu_state))) == (MENU *) 0) {
X      bit_destroy(inside);
X      bit_destroy(menu);
X      return(state);
X      }
X
X   /* get the values */
X
X   if (values != (char **) 0) {
X      state -> action = (struct menu_action *) 
X               malloc(count * sizeof(struct menu_action));
X      if (state->action) for(i=0;i<count;i++) {
X         state->action[i].value = save_line(values[i]);
X         state->action[i].next_menu = -1;
X         }
X      
X      }
X   else
X      state->action = (struct menu_action *) 0;
X
X   state -> menu = menu;
X   state -> bar_sizex = size_x;
X   state -> bar_sizey = HIGH;
X   state -> count = count;
X   state -> current = 0;
X   state -> next = -1;
X   state->flags = 0;
X   state -> screen = (BITMAP *) 0;
X   state -> save = (BITMAP *) 0;
X
X   bit_destroy(inside);
X   return(state);
X   }
X
X/* put the menu on the display */
X
Xstruct menu_state *
Xmenu_setup(state,screen,x,y,start)
Xstruct menu_state *state;	/* existing menu state */
XBITMAP *screen;			/* where to put the menu */
Xint x,y;			/* current offset of mouse on screen */
Xint start;			/* preselected item */
X   {
X   register int i, incr, count;	/* counters */
X   char *malloc();
X
X   /* position the box on the screen */
X
X   if (state->BIT_WIDE(menu)>BIT_WIDE(screen) ||
X       state->BIT_WIDE(menu)>BIT_WIDE(screen) ||
X       state->save)
X       return((MENU *) 0);
X
X   x = Min(x,BIT_WIDE(screen) - state->BIT_WIDE(menu));
X   y = Min(y,BIT_HIGH(screen) - 
X                 state->BIT_HIGH(menu) - state->bar_sizey);
X   y = Max(y,state->bar_sizey+BLIP);
X
X   state->save = bit_alloc(state->BIT_WIDE(menu),state->BIT_HIGH(menu),
X                  NULL_DATA,DEPTH);
X   bit_blit(state->save,0,0,state->BIT_WIDE(menu),
X          state->BIT_HIGH(menu),BIT_SRC,screen,x,y);
X
X   /* initialize the menu */
X
X   state -> screen = screen;
X   state -> current = start;
X   state -> menu_startx = x;
X   state -> menu_starty = y;
X   state -> x_pos = state-> bar_sizex/2;
X
X   bit_blit(screen,x,y,state->BIT_WIDE(menu),state->BIT_HIGH(menu),BIT_SRC,
X          state->menu,0,0);
X
X   if (start>=0 && start<state->count) {
X       BITMAP *inside = bit_create(screen,state->menu_startx+MENU_BORDER,
X                    state->menu_starty+MENU_BORDER,
X                    state->bar_sizex,state->bar_sizey*state->count);
X       BAR(inside,start-1);
X       bit_destroy(inside);
X       }
X   
X   return(state);
X   }
X
X
X/******************************************************************************
X
Xallow user to select an item 
X
X */
X
Xint menu_get(state,mouse,button,exit)
Xstruct menu_state *state;
Xint mouse;			/* fd to read mouse data from */
Xint button;			/* button termination condition (not yet)*/
Xint exit;			/* off-menu exit codes */
X   {
X   register BITMAP *inside;	/* the menu */
X   register int y_position;
X   register int x_position;
X   int push;
X   int x_mouse, y_mouse;	/* mouse delta's */
X   int done=0;
X   int inverse;			/* selected item */
X   int count;			/* number of items */
X   int old;
X
X   if (state == (MENU *) 0)
X       return(-1);
X
X   old = inverse = state -> current;
X   count = state -> count;
X   state->exit=0;
X
X   /* set up text region */
X
X   inside = bit_create(state->screen,state->menu_startx+MENU_BORDER,
X                    state->menu_starty+MENU_BORDER - state->bar_sizey,
X                    state->bar_sizex,state->bar_sizey*(count+2));
X
X   /* make sure we aren't already exited */
X
X   if (exit&EXIT_BOTTOM && inverse >= count) {
X      old = inverse = count-1;
X      BAR(inside,inverse);	/* on */
X      }
X
X   /* set initial blip position */
X
X   x_position = state->x_pos;
X   y_position = state->bar_sizey*(inverse+1) + state->bar_sizey/2;
X
X   /* track the mouse */
X
X   TRACKON(inside,x_position,y_position);		/* on */
X   do {
X      push = mouse_get(mouse,&x_mouse,&y_mouse);
X      TRACKOFF(inside,x_position,y_position);		/* off */
X      x_position += x_mouse;
X      y_position -= y_mouse;
X      y_position = BETWEEN(BLIP, y_position, (2+count)*state->bar_sizey-BLIP);
X
X      if (x_position <= 0 && (exit&EXIT_LEFT)) {
X         state->exit = EXIT_LEFT;
X         done++;
X         }
X      else if (x_position >= BIT_WIDE(inside) && (exit&EXIT_RIGHT)) {
X         state->exit = EXIT_RIGHT;
X         done++;
X         }
X
X      x_position = BETWEEN(BLIP/2, x_position, BIT_WIDE(inside) - BLIP/2);
X
X      TRACKON(inside,x_position,y_position);		/* on */
X
X      if (done)
X         break;
X
X      /* fix bar */
X
X      inverse = (2+count) * y_position / BIT_HIGH(inside) - 1;
X      if (inverse != old) {
X         TRACKOFF(inside,x_position,y_position);		/* off */
X         if (old >=0 && old < count)
X            BAR(inside,old);		/* off */
X         if (inverse >=0 && inverse < count)
X            BAR(inside,inverse);	/* on */
X         old = inverse;
X
X         if (inverse < 0 && exit&EXIT_TOP) {
X            state->exit = EXIT_TOP;
X            done++;
X            }
X         else if (inverse >= count && exit&EXIT_BOTTOM) {
X            state->exit = EXIT_BOTTOM;
X            done++;
X            }
X         TRACKON(inside,x_position,y_position);		/* on */
X         }
X      }
X      while (push != button && !done);
X   state->current = inverse;
X   state->x_pos = x_position;
X   TRACKOFF(inside,x_position,y_position);		/* off */
X   bit_destroy(inside);
X   return(0);
X   }
X
X/******************************************************************************
X
Xremove the menu drom the screen, restore previous screen contents
X
X */
X
Xstruct menu_state *
Xmenu_remove(state)
Xstruct menu_state *state;
X   {
X   if (state == (MENU *) 0) return(state);
X   if (state->save != (BITMAP *) 0) {
X      bit_blit(state->screen,state->menu_startx,state->menu_starty,
X         state->BIT_WIDE(save),state->BIT_HIGH(save),BIT_SRC,state->save,0,0);
X      bit_destroy(state->save);
X      state->save = (BITMAP *) 0;
X      }
X   return(state);
X   }
X
X/* free space associated with a menu */
X
Xint
Xmenu_destroy(state)
Xstruct menu_state *state;
X   {
X   register int i;
X
X   menu_remove(state);
X
X   if (state->menu != (BITMAP *)0)
X      bit_destroy(state->menu);
X
X   if (state->action != (struct menu_action *) 0) {
X      for(i=0;i<state->count;i++)
X         if (state->action[i].value)
X            free(state->action[i].value);
X      free(state->action);
X      }
X
X   free(state);
X   return(0);
X   }
X
X/* put a character string into a bitmap - only used for menus */
X
Xint
Xput_str(map,x,y,font,op,str)
XBITMAP *map;
Xregister int x;
Xint y;
Xstruct font *font;
Xint op;
Xregister char *str;
X   {
X   register char c;
X   register int wide = font->head.wide;
X   register int high = font->head.high;
X
X   while (c = *str++) {
X      bit_blit(map,x,y-high,wide,high,op,font->glyph[c],0,0);
X      x+=wide;
X      }
X   }
X
X/* copy a menu  - for environment stacks */
X
Xstruct menu_state *
Xmenu_copy(menu)
Xregister struct menu_state *menu;
X   {
X   register struct menu_state *tmp;
X   register int i;
X   char *alloc(), *malloc(), *save_line();
X
X   if (menu == (struct menu_state *) 0)
X      return(menu);
X
X   if ((tmp = (struct menu_state *) malloc(sizeof(struct menu_state))) 
X                                                   == (struct menu_state *) 0)
X      return((struct menu_state *) 0);
X
X   bcopy((char *) menu,(char *)tmp,sizeof(struct menu_state));
X
X   /* copy menu image */
X
X   if (menu->menu) {
X      tmp->menu = bit_alloc(BIT_WIDE(menu->menu),
X                            BIT_HIGH(menu->menu),NULL_DATA,DEPTH);
X      bit_blit(tmp->menu,0,0,BIT_WIDE(tmp->menu),BIT_HIGH(tmp->menu),
X                            BIT_SRC,menu->menu,0,0);
X      }
X
X   /* copy menu values */
X
X   if (menu->action != (struct menu_action *) 0) {
X      tmp->action = (struct menu_action *) 
X                    malloc(sizeof(struct menu_action)*menu->count);
X      if (tmp->action)
X         for(i=0;i<menu->count;i++) {
X            tmp->action[i].value = save_line(menu->action[i].value);
X            tmp->action[i].next_menu = menu->action[i].next_menu;
X            } 
X      }
X
X   return(tmp);
X   }
END_OF_FILE
# end of 'src/get_menus.c'
fi
echo shar: End of archive 35 \(of 61\).
cp /dev/null ark35isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
