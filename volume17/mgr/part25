Subject:  v17i026:  MGR, Bellcore window manager, Part25/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 26
Archive-name: mgr/part25




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 25 (of 61)."
# Contents:  demo/misc/ether.c demo/misc/lock.c demo/msg/client.c
#   font-16/U81 src/copyright.c src/get_info.c
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:30 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'demo/misc/ether.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/misc/ether.c'\"
else
echo shar: Extracting \"'demo/misc/ether.c'\" \(7443 characters\)
sed "s/^X//" >'demo/misc/ether.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: ether.c,v 4.2 88/06/22 14:37:31 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/misc/RCS/ether.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/misc/RCS/ether.c,v $$Revision: 4.2 $";
X
X/* strip_chart vmstat output version II */
X
X#include "term.h"
X#include <signal.h>
X#include <sgtty.h>
X
XFILE *popen(), *file;
X
X#define INTERVAL	60	/* bar interval (in secs) */
X#define SCROLL		4	/* # of scrolls per window */
X#define MAX		3	/* max number of plots */
X#define FREQ		3	/* update frequency (secs)*/
X#define DELTA		4	/* pixels/update */
X
X#define Min(x,y)	((x)>(y)?(y):(x))
X#define Max(x,y)	((x)>(y)?(x):(y))
X#define dprintf		if (debug) fprintf
X
Xchar *labels[] = {		/* graph labels */
X   "Input" , "Output", "Coll."
X   };
X
Xint indx[] = {			/* field indeces into netstat(1) */
X   0, 2, 4
X   };
X
Xint limit[] = {			/* default maximums */
X   15, 15, 3
X   };
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   register int i;
X   register int x;	/* current plot position */
X   int bar=0;		/* hash mark counter */
X   int back=0;		/* enable background writes */
X   int solid=1;		/* make solid lines */
X   int freq = FREQ;	/* update frequency (secs) */
X   int size;		/* size of label region */
X   int interval;	/* hash mark interval (secs) */
X
X   char host[16];	/* hostname */
X   char title[255];	/* chart title */
X   char line[255];	/* vmstat input buffer */
X   char *fields[20];	/* place for raw input fields */
X   char *sprintf();
X
X   int current[MAX];	/* current data value */
X   int old[MAX];	/* previous data value */
X   int first =1;	/* first time through */ 
X   int clean();
X
X   int f_high, f_wide;		/* font size */
X   int high,wide;		/* window size */
X   int x1;			/* left margin */
X   int x2;			/* title */
X   int y1;			/* title line */
X   int y2;			/* first bar */
X   int scroll;			/* scroll amount */
X   int delta=DELTA;		/* pixels/line */
X   int item;
X   int dummy;
X   int debug=0;
X
X   ckmgrterm( *argv );
X
X   for(i=1;i<argc;i++) {
X      if (strcmp(argv[i],"-d")==0) {
X         debug++;
X         }
X      else if (strncmp(argv[i],"-f",2)==0) {
X         freq = atoi(argv[i]+2);
X         if (freq < 1) freq = 1;
X         if (freq > 120) freq = 120;
X         }
X      else if (strncmp(argv[i],"-m",2)==0) {
X         int max;
X         max = atoi(argv[i]+2);
X         if (max < 1) max = 1;
X         if (max > 999) max = 999;
X         limit[0] = limit[1] = max;
X         limit[2] = (max>=5) ? max/5 : 1;
X         
X         }
X      else
X         fprintf(stderr,"%s: unknown flag %s. Ignored\n",*argv,argv[i]);
X      }
X
X   if ((file = popen(sprintf(line,"netstat %d",freq),"r")) == NULL)
X      exit(1);
X
X   m_setup(M_FLUSH);
X   m_ttyset();
X   m_push(P_EVENT|P_FLAGS);
X   m_setmode(M_ABS);
X
X   signal(SIGINT,clean);
X   signal(SIGTERM,clean);
X
X   system("stty -ctlecho");
X   m_setevent(RESHAPE,"R\fRedrawing...\n");
X   m_setevent(REDRAW,"R\fRedrawing...\n");
X   first = 1;
X
X   while (1) {
X
X      for(size=0,i=0;i<MAX;i++)
X         size = Max(size,strlen(labels[i]));
X
X      /* clear the screen, flush pending input */
X
X      read_it(fileno(m_termin),line);
X
X      /* get font size */
X
X      get_font(&f_wide,&f_high);
X
X      /* get window size */
X
X      get_size(&dummy,&dummy,&wide,&high);
X   
X      if (wide==0 || high==0 || f_wide==0 || f_high==0) {
X         fprintf(stderr,"Can't get window info\n");
X         clean();
X         }
X
X      /* get the title */
X
X      gethostname(host,sizeof(host));
X
X      sprintf(title,"Network statistics for %s in packets/%d seconds",
X              host,freq);
X
X      if (strlen(title)*f_wide > wide)
X         sprintf(title,"%s (pkts/%ds.)",host,freq);
X
X      /* make sure window is big enough */
X
X      if (f_high * (2*MAX+1) > high) {
X         fprintf(stderr,"\fWindow isn't tall enough\n");
X         m_gets(line);
X         continue;
X         }
X      if (f_high * (3*MAX +1) > high)
X         size += 3;
X
X      if (strlen(title)*f_wide > wide || 3*size*f_wide > wide*2) {
X         fprintf(stderr,"\fWindow isn't\nwide enough\n");
X         m_gets(line);
X         continue;
X         }
X
X      /* calculate key positions */
X
X      x1 = (size*f_wide+1);
X      x2 = (wide-strlen(title)*f_wide)/2;
X      y1 = f_high +1;
X      y2 = (high - y1) /MAX;
X      high--;
X
X      m_func(B_SET);
X      m_clear();
X      x = x1;
X      scroll = Max((wide-x1)/SCROLL,10);
X      scroll += scroll%delta;
X
X      if (freq >15)
X         interval = INTERVAL * 10 /freq;
X      else 
X         interval = INTERVAL / freq;
X
X      /* draw form */
X
X      m_moveprint(x2,y1,title);
X
X      for(i=0;i<MAX;i++) {
X         m_moveprint(x1-f_wide,high-i*y2,"0");
X         m_moveprint(x1-f_wide*3,high-(i+1)*y2+f_wide*2+1,
X                     sprintf(line,"%3d",limit[i]));
X         m_moveprint(1,high-i*y2-(y2-f_high)/2,labels[i]);
X         m_line(x1,high-i*y2,wide,high-i*y2);
X         }
X   
X      m_line(0,y1,wide,y1);
X      m_line(x1,y1,x1,high);
X      m_movecursor(x1,0);
X      m_flush();
X
X      /* read the data */
X
X      while (fgets(line,sizeof(line),file) != NULL) {
X         i = parse(line,fields);
X         if (strcmp(*fields,"input")==0) {
X            fgets(line,sizeof(line),file);
X            fgets(line,sizeof(line),file);
X            continue;
X            }
X
X         /* calculate new line position */
X
X         for(i=0;i<MAX;i++) {
X            current[i] = atoi(fields[indx[i]]) *
X                         (y2-3)/limit[i];
X            current[i] = Min(current[i],y2-3) + y2*i + 1;
X
X            if (!first) {
X               m_line(x,high-old[i],x+delta,high-current[i]);
X               if (solid)
X                  m_line(x+delta,high-y2*i,x+delta,high-current[i]);
X               }
X
X            dprintf(stderr,"%s %d->%d, ",labels[i],
X                            high-old[i],high-current[i]);
X            old[i] = current[i];
X            }
X         dprintf(stderr," [%d]\n",high);
X   
X         if (++bar  == interval) {
X            m_line(x,y1,x,high);
X            bar = 0;
X            dprintf(stderr,"---------\n");
X            }
X
X         if (first)
X            first = 0;
X         else
X            x += delta;
X
X         if (x > wide-delta) {
X
X            /* scroll the display */
X
X            x -= scroll;
X            m_func(B_COPY);
X            m_bitcopy(x1+1,y1+1,wide-x1-1,high-y1-1,x1+scroll+1,y1+1);
X            m_func(B_CLEAR);
X            m_bitwrite(wide-scroll,y1+1,scroll,high);
X            m_func(B_SET);
X         
X            dprintf(stderr,"scroll to %d,%d from %d,%d\n",
X                    x1+1,y1+1,x1+scroll+1,y1+1);
X            for(i=0;i<MAX;i++) 
X               m_line(wide-scroll,high-i*y2,wide,high-i*y2);
X            }
X         m_flush();
X         if (read_it(fileno(m_termin),line) && *line == 'R')
X            break;
X         }
X      }
X   }
X
Xclean()			/* clean up on SIGINT */
X   {
X   m_pop(0);
X   pclose(file);
X   m_clear();
X   m_flush();
X   m_ttyreset();
X   exit(1);
X   }
X
Xint read_it(fd,line)	/* non blocking read */
Xint fd;
Xchar *line;
X   {
X   long rd;
X
X   ioctl(fd,FIONREAD,&rd);
X   line[rd] = '\0';
X   if (rd > 0)  {
X      return(read(fd,line,rd));
X      }
X   else
X      return(0);
X   }
END_OF_FILE
# end of 'demo/misc/ether.c'
fi
if test -f 'demo/misc/lock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/misc/lock.c'\"
else
echo shar: Extracting \"'demo/misc/lock.c'\" \(6857 characters\)
sed "s/^X//" >'demo/misc/lock.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/* ************************************************************ *\
X/* star-trek lock screen (sau/sdh) */
X
X#include <sgtty.h>
X#include <stdio.h>
X#include <pwd.h>
X#include <sys/time.h>
X#include <signal.h>
X#include "bitmap.h"
X
X#define WIDE	BIT_WIDE(display)
X#define HIGH	BIT_HIGH(display)
X#define NICE	10
X
Xstruct passwd *pwd, *getpwuid();
Xstruct timeval poll = {0,50000};
Xstruct sgttyb sg,save;
Xchar buff[100];
Xstatic int dir = 1;
X
Xmain()
X   {
X   int read;
X	int pid;
X	int flip();
X   BITMAP *display = bit_open("/dev/bwtwo0");
X   BITMAP *stash = bit_alloc(WIDE,HIGH,NULL,1);
X
X   if (!(display&&stash)) {
X      printf("Can't initialize the display, sorry\n");
X		exit(1);
X      }
X
X   pwd = getpwuid(getuid());
X
X   signal(SIGINT,SIG_IGN);
X   signal(SIGHUP,SIG_IGN);
X   signal(SIGTERM,SIG_IGN);
X   signal(SIGQUIT,SIG_IGN);
X   signal(SIGTSTP,SIG_IGN);
X
X   gtty(0,&sg);
X   save = sg;
X   sg.sg_flags &= ~(ECHO|RAW);
X   sg.sg_flags |= CBREAK;
X   stty(0,&sg);
X   
X   bit_blit(stash,0,0,WIDE,HIGH,BIT_SRC,display,0,0);
X   bit_blit(display,0,0,WIDE,HIGH,BIT_SET,NULL,0,0);
X   if (NICE > 0)
X      nice(NICE);
X	if ((pid=fork()) == 0) {/* child */
X		signal(SIGALRM,flip);
X		fly(display);
X		}
X   else {
X		while(1) {
X			read = 1;
X			if (select(32,&read,0,0,&poll) && read) {
X				gets(buff);
X				kill(pid,SIGALRM);	/* change directions */
X				if (strcmp(pwd->pw_passwd,crypt(buff,pwd->pw_passwd)) == 0) {
X					stty(0,&save);
X					kill(pid,SIGKILL);
X					while(wait(0)!=pid);
X					bit_blit(display,0,0,WIDE,HIGH,BIT_SRC,stash,0,0);
X					exit(0);
X					}
X				}
X			}
X		}
X	}
X
X/* star trek effect */
X/*
X * porter.c  Steve Hawley 4/3/87
X * rehacked 5/18/1988 for extra speed.
X * re-re hacked 6/20/88 for MGR (SAU)
X * A demo to get stars inspired by Star Trek without
X * using quickdraw, and by addressing the screen directly.
X * this version is roughly 8 times faster than its quickdraw
X * equivalent.
X * In considering the bit drawing routines, remember that
X * on the macintosh, a bit turned on is black, not white.
X */
X
X#define BG_COLOR	4		/* usually blue */
X#define SSIZE	2	/* star size */
X#define MAXZ 500 /* maximum z depth */
X#define NSTARS 256 /* maximum number of stars */
X#define SPEED	6		/* star speed */
X#define SCALE	(short)7	/* for rotator */
X#define COUNT	(short)3	/* for rotator */
X#define ON 1  /* plotting states */
X#define OFF 0
X#define Random() rand()
X
Xshort maxv, maxh; /* display size */
Xshort hmaxv, hmaxh;	/* 1/2 display size */
X
Xstruct st {
X   short x, y, z;
X	short color;
X	short dir;
X   } stars[NSTARS]; /* our galaxy */
X
Xfly (where)
XBITMAP *where;
X{
X        register short i;
X        register struct st *stp;
X
X        init_all(where);     /* set up global variables */
X        for (i=0, stp = stars; i< NSTARS; i++, stp++) {
X                /* initialize galaxy */
X                do {
X                        stp->x = Random();
X                        stp->y = Random();
X                        stp->z = (Random() % MAXZ) + 1;
X                        stp->dir = dir ? COUNT : -COUNT;
X                        stp->color = Random() % 23;
X								if (stp->color == BG_COLOR)
X                        	stp->color++;
X			
X                } while(project(where,stp->x, stp->y, stp->z, stp->color, ON)); /* on screen? */
X        }
X        while (1) { /* loop 'til button */
X                i = NSTARS;
X                stp = stars;
X                do {
X                        project(where,stp->x, stp->y, stp->z, stp->color, OFF); /* turn star off*/
X                        if ((stp->z -= SPEED) <= 0) { /* star went past us */
X                                stp->x = Random();
X                                stp->y = Random();
X                                stp->z = MAXZ;
X                                stp->dir = dir ? COUNT : -COUNT;
X                        }
X								else {		/* rotate universe */
X									cordic(&stp->x,&stp->y,SCALE,stp->dir);
X								}
X                        if (project(where,stp->x, stp->y, stp->z, stp->color, ON)) {
X                                /* if projection is off screen, get a new position */
X                                stp->x = Random();
X                                stp->y = Random();
X                                stp->z = MAXZ;
X                                stp->dir = dir ? COUNT : -COUNT;
X                        }
X                ++stp;
X                } while(--i);
X        }
X}
X
Xproject(where,x, y, z, col, state)
Xregister BITMAP *where;
Xregister short x, y, z;
Xregister int col;
Xregister short state;
X{
X        
X        /* one-point perspective projection */
X        /* the offsets (maxh/2) and maxv/2) ensure that the
X         * projection is screen centered
X         */
X		x = (x/z) + hmaxh;
X		y = (y/z) + hmaxv;
X        return(xplot(where,x, y, z, col, state));
X
X}
X
Xinit_all(where)
Xregister BITMAP *where;
X{
X   maxv = BIT_HIGH(where);
X   hmaxv = maxv>>1;
X   maxh = BIT_WIDE(where);
X   hmaxh = maxh>>1;
X}       
X
Xxplot(where,x, y, z, col, state)
Xregister BITMAP *where;
Xregister int x, y;
Xregister int z;	/* actually z position */
Xregister int col;
Xint state;
X{
X        register int size = SSIZE;
X        /* are we on the screen? If not, let the caller know*/
X        if (x < 0 || x >= maxh || y < 0 || y >= maxv )
X            return(1);
X
X      if (z > (3*MAXZ/4))
X         size--;
X      else if ( z< (MAXZ/4))
X         size++;
X      bit_blit(where,x,y,size,size, state ?
X		BIT_SRC^BIT_DST | GETCOLOR(col)^GETCOLOR(BG_COLOR) :
X		BIT_SRC | GETCOLOR(BG_COLOR),
X                 0l,0,0);
X        return(0);
X}
X
X/* CORDIC rotator. Takes as args a point (x,y) and spins it */
X/* count steps counter-clockwise.                   1       */
X/*                                Rotates atan( --------- ) */
X/*                                                  scale   */
X/*                                                 2        */
X/* Therefore a scale of 5 is 1.79 degrees/step and          */
X/* a scale of 4 is 3.57 degrees/step                        */
X
Xcordic(x, y, scale, count)
Xshort *x, *y;
Xregister short scale, count;
X
X{
X   register short tempx, tempy;
X
X   tempx = *x;
X   tempy = *y;
X
X   if (count > 0) /* positive count (counter-clockwise) */
X      for (; count; count--){
X         tempx -= (tempy >> scale);
X         tempy += (tempx >> scale); 
X      }
X   else          /* negative count (clockwise) */
X      for (; count; count++){
X         tempx += (tempy >> scale);
X         tempy -= (tempx >> scale);
X      }
X
X   *x = tempx;
X   *y = tempy;
X}
X
Xint flip()
X   {
X   dir = 1-dir;
X	}
END_OF_FILE
# end of 'demo/misc/lock.c'
fi
if test -f 'demo/msg/client.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/msg/client.c'\"
else
echo shar: Extracting \"'demo/msg/client.c'\" \(6568 characters\)
sed "s/^X//" >'demo/msg/client.c' <<'END_OF_FILE'
X/*	$Header: client.c,v 4.1 88/06/21 14:02:36 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/msg/RCS/client.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/msg/RCS/client.c,v $$Revision: 4.1 $";
X
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/* sample client for testing server (template only) */
X
X#include <stdio.h>
X#include <signal.h>
X#include "term.h"
X#include "do.h"
X
X#define MAX	20	/* max # of servers */
X
Xstruct server {
X   int id;
X   char *name;
X   };
X
Xstruct server servers[MAX];
Xint cnt=0;			/* server count */
X 
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   register int i;
X   char *ttyname();
X   char *str_save();
X   int clean();
X   char message[100];
X   char line[100];
X   char args[100];
X   char name[20];
X   int id;
X
X   ckmgrterm( *argv );
X
X   m_setup(M_FLUSH);
X   chmod(ttyname(2),0600);		/* this is not gauranteed */
X   m_push(P_EVENT|P_FLAGS);		/* save old events and flags */
X   signal(SIGTERM,clean);		/* cleanup upon termination */
X   signal(SIGINT,clean);
X   m_setevent(NOTIFY,"client");		/* my name is "client" */
X   m_setevent(ACCEPT,"&%f:%m\r");	/* get messages: &<from>:<message\r */
X   m_setevent(BUTTON_1,"D %n");
X   m_setevent(BUTTON_2,"X %n is id %w");
X   sprintf(message,"%c",C_WHO);
X   m_broadcast(message);		/* ask all servers for their id's */
X   m_flush();
X
X   /* loop, reading lines from keyboard */
X
X   while(m_gets(line) != NULL) {
X      printf("got: %s",line);
X      if (*line == '&') {
X         sscanf(line+1,"%d:%s %[^\n]", &id,message,args);
X         switch (*message) {
X            case S_HI:			/* received server announcement */
X               printf("Server %d (%s) started [%s]\n",id,message,args);
X               install(args,id);
X               break;
X
X            case S_BYE:			/* a server died */
X               printf("Server %d died\n",id);
X               for(i=0;i<cnt;i++)
X                  if (servers[i].id == id) {
X                     printf("server %s (%d) removed from %d\n",
X                            servers[i].name,servers[i].id,i);
X                     servers[i].id = 0;
X                     free(servers[i].name);
X                     break;
X                     }
X                  if (i+1 == cnt && cnt>0)
X                     cnt--;
X               break;
X
X            case S_REPLY:			/* a server reply message */
X               printf("Server %d replied %s\n",id,message);
X               switch (message[1]) {
X                  case R_WHO:			/* who are you */
X                     install(args,id);
X                     break;
X                  case R_RCVD:			/* received command */
X                     printf("Command received\n");
X                     break;
X                  case R_DO:			/* working on command */
X                     printf("Command is executing\n");
X                     break;
X                  case R_DONE:			/* command completed */
X                     printf("Command completed\n");
X                     break;
X                  case R_BAD:			/* command rejected */
X                     printf("Command rejected\n");
X                     break;
X                  case R_UNKWN:			/* unknown command */
X                     printf("Command unknown\n");
X                     break;
X                  default:
X                     printf("Unknown server reply\n");
X                  }
X               break;
X
X            case C_WHO:			/* some other client sent this */
X               printf("got a client WHO message\n");
X               break;
X
X            default:
X               printf("non-server message from %d (%s)\n",id,message);
X               break;
X            }
X         }
X
X      /* not a message, must be a button hit or kbd */
X
X      else {
X         switch (*line) {
X            case 'L':			/* list servers */
X               for(i=0;i<cnt;i++) {
X                  if (servers[i].id > 0)
X                     printf("%d) server %d is [%s]\n",
X                             i,servers[i].id, servers[i].name);
X                  }
X               break;
X
X            case 'S':			/* put file in snarf buffer */
X               m_snarf(line+2);
X               printf("Putting->snarf buffer: %s\n",line+2);
X               break;
X
X            case 'D':			/* send command to server */
X               sscanf(line,"%*s %s %[^\n]", name,args);
X               for(i=0;i<cnt;i++) 
X                  if (servers[i].id > 0 && strcmp(servers[i].name,name)==0) {
X                     printf("sending [%s] to %s (%d)\n",
X                             args,name,servers[i].id);
X                     sprintf(message,"%c %s",C_DO,args);
X                     m_sendto(servers[i].id,message);
X                     break;
X                     }
X               if (i==cnt)
X                  printf("Can't find server [%s]\n",name);
X               break;
X
X            case '?':			/* list commands */
X               printf("L		list servers\n");
X               printf("D <server> <command>		do a command\n");
X               printf("?		ask for help\n");
X               break;
X
X            default:
X               printf("Not a message: %s\n",line);
X            }
X         }
X      m_flush();
X      }
X   }
X   
X/*	Clean up and exit */
X
Xclean(n)
Xint n;
X   {
X   m_popall();
X   exit(n);
X   }
X
X/* save a copy of string s */
X
Xchar *
Xstr_save(s)
Xchar *s;
X   {
X   char *malloc(), *strcpy();
X   return(strcpy(malloc(strlen(s)+1),s)); 
X   }
X
X/* install a server */
X
Xint
Xinstall(name,id)
Xchar *name;
Xint id;
X   {
X   register int i,spot = -1;
X
X   for(i=0;i<cnt;i++)
X      if (servers[i].id == id) {
X         printf("server id %d already installed at %d\n",id,i);
X         if (strcmp(name,servers[i].name) != 0) {
X            free(servers[i].name);
X            servers[i].name = str_save(name);
X            }
X         return(i);
X         }
X      else if (spot == -1 && servers[i].id == 0)
X         spot = i;
X
X
X      if (spot != -1) {
X         servers[spot].id = id;
X         servers[spot].name = str_save(name);
X         printf("server %s (%d) installed at %d\n",
X                name,id,spot);
X         }
X      else if (cnt < MAX) {
X         servers[cnt].id = id;
X         servers[cnt].name = str_save(name);
X         printf("server %s (%d) installed at %d\n",
X                name,id,cnt);
X         cnt++;
X         }
X   return(i);
X   }
END_OF_FILE
# end of 'demo/msg/client.c'
fi
if test -f 'font-16/U81' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-16/U81'\"
else
echo shar: Extracting \"'font-16/U81'\" \(7749 characters\)
sed "s/^X//" >'font-16/U81' <<'END_OF_FILE'
Xbegin 644 81.fnt
XM%@X9!8  __@,    .                 #        !X         # #__P
XM                          P!C &##,  8#P#@ !PX              .
XM#\ X ?P'\ ,#_\'\/_X/@'\            #\   " _X!_#_P__O_X?PP!A^
XM  &P!L # &X!A_#_P'\/_ ?P?_L ; &P!L 9 "__@'YP ?@ $    $      
XM                                                        #@,!
XMP    ![_^ P   #\                 > #      /X         , /_^  
XM                        # &, 8,,P.!@[@?  .!P              P?
XMX'@'_Q_\!P/_Q_\__C_A_\            ?X   <#_\?_/_S_^__G_S &'X 
XM ; .P . [@&?_/_Q_\__'_Q_^P!L ; &P!D +_^ ?C !^  X    P       
XM            '      #                                   8 P!@
XM    /__X#    ?X         >      #\ ,      PP         8!@ 8   
XM         (             , 8P!@Q_A\,#'!\  P#              '#AT
XMV 8#& P& P & P .,&& P           #AP  !P, Q@,P#, #  8#, 8&  !
XML!S  \'O 9@,P#& S ,8# ,# &8#, 9@,8!@ X!@.  8 'P   &         
XM&   #P  8  < !P8  ,                  P               # # #  
XM  !S__@,   #C@        #\   @_ /P P      !@    !P& Q@& !@    
XM        @             P!C ,&/_,8P8,#P & &              8<#V8
XM# &P!@P#  P!@ Q@,P!@           <#@  /@P!L ; &P , # &P!@8  &P
XM., #X^\!L ; &P!L ; & P, 9@,P!F Q@& # & 8 !@ [@   X  !@     8
XM   ?  !@ !P '!@  P                 #                , , ,   
XM '/_^ P   <&         (X# &/_!M@#       &     ?P8#& 8 &      
XM      '  !F         # &, P9\^QF!@P'  8 8             #A@/!@,
XM ; &# , # & #& S &           !@&   V# &P!L ;  P , ; &!@  ;!P
XMP -W;8&P!L ; &P!L 8# P!F S &,&# P 8 8!P & ''   #P  &     !@ 
XM #   &     <&  #                  ,                8 P!@    
XM8/_X#   !@8         A@. YP<.W , '@    8    #CA@,,#  8       
XM     <  >>         , 8P?_VS;&8'& 8 !@!@ ,           ,& X&  !
XM@ 88 P ,   88#, 8             8  #8, ;  P!L #  P , 8&  !L.# 
XM S9M@; &P!L ; &P  ,# &,&, 8P8,# #@!@#  8 X.   /@  8     &   
XM,   8      8  ,                  P               !@# &    !@
XM__@,  #,#          # <'& 0S, P!_@   !@    <'& PP, !@        
XM   #X '@>         P!C!__;,'S .X#  & & !X ,        !P8'@8  & 
XM#!@#  P  !@P8P!@            !@_ 8PP!L # &P , #  P!@8  &QP, #
XM'&S!L ; &P!L ;   P, 8P8P!AC 88 , & . !@' <   ^ _A@     8   P
XM  !@     !@  P&      &         #                & , 8    &#_
XM^ P!X8P, P   #X/PP, XX< ',[__,S    &!__^!@,8##_P &!X        
XM 8=P!X >   @ 0  # &,!@Q\P., > (  X <### P        &!@^!@  P ,
XM,,, #   ,#WA@.#@    &  &   ./_!C# &P , ;  P , # &!@  ;. P ,(
XM;,&P!L ; &P!L  # P!C!C &&,!A@!@ 8 8 & X P  !P'_&/ /X#Q@_ # #
XMQF/ #   &#@# ;G&?@/P8\ \9C@#^!_Q@&8!F 9 "8!G_X 8 P!@    X/_X
XM# /QF!@'@   \#__ 8!W \ 8QO_]C&    8?__^& Q@,'^  8?X"$ P  P #
XM#C@>  >'_[ #   ,   &##S !@'P   #@!P.,<#         X&'8&  & !@P
XMPP ,   P#X'CX? #@ !X  >  !Q@.&,, S  P!L #  P , 8&  !MP#  PAL
XM8; &P#, ; ,8  ,# &&,, 8-@#, . !@!P 8        P&;_#_P_V/_!_P_V
XM;_ ,  P8< ,!^^;_#_QO\/]F_@?\'_& 9@&8!F 9@&?_@# # #    # __@,
XM!AL8, S   ' ,SP!@#X \!#" P$,(X<#YC@  <8#& P88!_C P88&  !@ 8<
XM''@  >?_L ,   P   8,'\ & _    . ' \SP,        # 8Y@8  P!\&##
XM_PQP & ' ']A\ ?  >   >  ., <P8__, # &_^/_C  __@8  &^ , # &QA
XML ;_\P!O_Q_X P, 88PP!@^ /P P & # !@       # 9X,,!C!XP,'_#!Y\
XM, P #!C@ P&,9X.,#'@PP>?'# 8# 8!G Y@&<#F 8 , < , .    ,#_^0PD
XM#QAP#,/_\8 C& & ' #\ , # PPWSX?^<   Y@,8#!A@'^>'C PP  #'_[P>
XM>  !X  8!@  #   #!@/X P'.    X < _\ P        <!G&!@ & 'P8,/_
XMS?P 8!_ '&'P!\ '@?_@> !PQXS!C_\P , ;_X_^, #_^!@  ;P P , ;#&P
XM!O_# &_\!_P# P!AC# &#X > &  8 . &         !G 9@&8#F 8# 8#G 8
XM#  ,&< # 8QG 9@&<!F YP,,!@,!@&,#& 8X<8!@!@!P P X <! P/_YC&P.
XM&#P88__S  ,8 \ < _X P ,#__QXS [@  !V Q@,#,  9,R8!F   &?_G!P>
XM  >  !@&   ,   ,& SP# X<   #@!P!_@#        !@&X8&  P !C P #/
XMCP# >/  8. 'P!X!_^ > .#/[,&, S  P!L #  P/L 8&  !O@#  P!L,; &
XMP , ; 8 # ,# &#8,(8-@ P X !@ 8 8         >8!F !@&8!@,!@&8!@,
XM  P;@ ,!C&8!F 9@&8!F  P  P& 8X<8!ASA@& , # # # #X$# __G,[ 8X
XM#AA@ #, !A@'P!P'!P#  P/__##8!L   #8#& P,P !L>/______\!@.. > 
XM'@?_C P   P   P8#/@8#AS   . ' #\/_\  ?_@  . ?!@8 &  #,#  &X#
XM ,!@, !@  . >     >!P,QM_\P!L # &P , # ^P!@8  &W , # &P9L ; 
XM P!L!@ & P, 8-@PAAC # #  & !P!@        ?Y@&8 & 9_^ P& 9@& P 
XM#!^  P&,9@&8!F 9@&8 #_@# 8!AAA@&#\& 8!@ & , 8 ?PP,#_^,S,!C@'
XM,#  ,_@&& [ '@P# , # PP\,-@&P   -@,8# S  &PP_______P, =P >!X
XM!_^,#   #   /_X,V!G.#L   8 8 ?X__P !_^   P!X&!@ P  ,__@ ; &!
XM@, 8 &    !X    !X& S&W_S &P , ;  P , ; &!@  ;. P , ;!FP!L #
XM &P#  8# P!@V#'&&, , 8  8 # &        /YF 9@ 8!G_X# 8!F 8#  ,
XM'\ # 8QF 9@&8!F 9@ '_ ,!@&'.& 8'@8!@,  8 P!@!GF!P/_X[<P&. <P
XM,  S  88'& 6# , P ,!#"PPV ;    V Q@,!X  ;'C8!F   &?_@^  >>  
XM  88       __FS8,^X.P  !@!@#_P#        ' ' 8& &   ;_^ !L 8& 
XMP!@ 8    !X!_^ > 8#/^8#, ;  P!L #  P!L 8&  !L<#  P!L#; &P , 
XM; , !@,# &!P,^8P8 P#@ !@ . 8       !P&8!F !@&8  ,!@&8!@,  P<
XMX ,!C&8!F 9@&8!F   & P& 8,P8Q@_!@&!@ !@# & ,/X& __AMC XX!V 8
XM #, !@PX8!8, P#   &,;'C8!N   '8#& P'@ !DS(P,,   Q_^!P  9@   
XM!A@      !@P?/@V/@>   & & \SP,      X 8 \!@8 P P!@## &P!@P# 
XM&P!@X   !X'_X'@  ,?Q@,P!L ; &P , # &P!@8# &PX, # &P-L ;  P-L
XM S & P, 8' W=C!@# ,  &  8!@       & 9@&8 & 9@  P& 9@& P #!AP
XM P&,9@&8!F 9@&8   8# 8!@_!GF'.& 8,  & , 8 @? 8#_^#\$#S@'8!@ 
XM 8 ,#' P%@X' ,   ,S'SY@,<   Y@,<' >  &>'AA@8  &!@ '     !_^#
XM,       &# _\&8W!X   8 8#C' P X   'P#@#P.!@& # & ,, ; &# , ;
XM &'P X !X  !X   X . [ &P!L ;  P , ; &!@, ;!PP , ; >P!L # ^P#
XM, 8# P!@<#X^8# ,!@  8 !P&        8#G 9@&8#F 8# 8#F 8#  ,&#@#
XM 8QF 9@&<!F Y@ ,!@,!@.!X&S8X<8#A@  P P P" X!@/_X/P8;/@[ #  !
XMP P,8# >!XX P/_\?X.'##@X  '& PXX P  8P,"$ P  P,  (     '_X,P
XM   ,   P8!_@9C>/P   P# ,,,# 'P   ? , +AP& P & P P8#& P8 8#& 
XMP? 'P !X  >  <!P'P!L Q@,P#, #  8#, 8& 8#,#C  P!L!Y@,P &!S ,8
XM# ,!@, @/!Y@, P.  !@ # 8       !@>>## 8P>,!@, P>8!@,  P8' ,!
XMC&8!F 9X,,'F  P& P##X'@>'G XP^,  # # #    & __@> _'__, ,  #P
XM# ; & P'_@# __P>   /\!___X8#!_ # __A_@      !@  @'_Y_^   >  
XM  P  #!@#,##X_S   #@< !X , ?   !\!P '^'_C_^?_ #!_\?_!@!_\?_!
XM\ ?  !@ !@ !P#_[ &__'_S_\__L !_\P!A^!_\P'/_[ &P#G_S  ?_L 9_\
XM P'_P" X#L 8# __@'X .?@       #_9O\/_#_8_\ P#_9@& P #!@. P&,
XM9@&,#&_P_V8 !_P!\/]@,!P.8!C_9_^ & , 8    8#_^ P!X'/X@ 0  #X,
XM!L <  'X ,        /@!__^!@,!P ,#__!X            ?_G_X   P   
XM#   ,& ,P,' ^    '#@ #  P \   #@&  /P?^/_X?P ,!_ ?P& !_ ?P#@
XM \        ' #^, ;_@'\/_#_^P !_# &'X!_# ,__L ; .'\,  ?WP!A_ #
XM '\ (# &P!@,#_^ ?@ 9^        'YF/ /X#Q@_@# #QF 8#  ,& 8# 8QF
XM 8_\8\ \9@ #^ #P/& P& 9 "#QG_X . P'    !@/_X    ,           
XM                                                            
XM                        !P                                 !
XMP                                                   ,       
XM                                           &      P         
XM!_!@  !@                 &     #     #, __@    P            
XM                                                            
XM                       &                                  & 
XM                                                            
XM                                          8     #           
XM &   &                  8     ,     ,P#_^    #              
XM                                                            
XM                      P                                  P  
XM                                                            
XM                    /__                ,#      ,            
XM8   8                ,#      P     S /_X    ,               
XM                                                            
XM                    "                                  "    
XM                                                            
XM                   __\                _\     /@           !@
XM  !@                _\     #     !\ __@    P                
XM                                                            
XM                                                            
XM                                                            
XM                                    !_      \            &  
X: &                !_      ,     #@  
X 
Xend
END_OF_FILE
# end of 'font-16/U81'
fi
if test -f 'src/copyright.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/copyright.c'\"
else
echo shar: Extracting \"'src/copyright.c'\" \(7128 characters\)
sed "s/^X//" >'src/copyright.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: copyright.c,v 4.3 88/07/11 13:46:06 sau Exp $
X	$Source: /tmp/mgrsrc/src/RCS/copyright.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/copyright.c,v $$Revision: 4.3 $";
X
X/* flash a copyright notice at Mgr startup */
X
X#include <sys/time.h> 
X#include <sys/signal.h>
X#include "bitmap.h"
X#include "copyright.h"
X
X#define SSIZE	3		/* star size */
X
X#define BG_COLOR		4	/* background color */
X#define LOGO_COLOR	2	
X#define CR_COLOR		5	/* copyright color */
X
Xstatic BITMAP *logo[] =
X	{ &lb_0, &lb_1, &lb_2, &lb_3, &lb_4, &lb_5, &lb_6, &lb_7};
X
Xstatic struct timeval delay = {
X   (long) 0, (long) 120000
X   };
X
X/* for "star trek" clip areas */
X
Xstruct rect {
X	short x1,y1;
X	short x2,y2;
X	}c1,c2;
X
Xcopyright(where)
XBITMAP *where;	/* where to blast the copyright */
X	{
X	BITMAP *notice = &cr;
X	int x = (BIT_WIDE(where)-BIT_WIDE(notice))/2;
X	int y = BIT_HIGH(where)/2;
X	int high = BIT_HIGH(logo[0]);
X	int wide = BIT_WIDE(logo[0]);
X	int mask = 1;		/* select mask (1 == kbd) */
X	int pid;				/* pid of "startrek" program */
X	register int i;
X	char c;
X
X	c1.x1 = x - SSIZE;
X	c1.y1 = y - SSIZE;
X	c1.x2 = BIT_WIDE(notice) + x;
X	c1.y2 = BIT_HIGH(notice) + y;
X
X	bit_blit(where,0,0,BIT_WIDE(where),
X            BIT_HIGH(where),BIT_SRC|GETCOLOR(BG_COLOR),0l,0,0);
X	bit_blit(where,x,y,BIT_WIDE(notice),BIT_HIGH(notice),
X            BIT_SRC^BIT_DST|GETCOLOR(BG_COLOR)^GETCOLOR(CR_COLOR),
X            notice,0,0);
X
X	x = (BIT_WIDE(where)-wide)/2;
X	y = y - high - BIT_HIGH(notice);
X
X	c2.x1 = x - SSIZE;
X	c2.y1 = y - SSIZE;
X	c2.x2 = wide + x;
X	c2.y2 = high + y;
X
X	/* kick off stars */
X
X	if ((pid=fork()) == 0) /* child */
X		fly(where,c1,c2);
X   else {
X		for(i=0;select(32,&mask,0,0,&delay) <= 0;i++,mask=1)
X			bit_blit(where,x,y,wide,high,
X			BIT_SRC|GETCOLOR(BG_COLOR),
X			logo[i%8],0,0);
X		read(0,&c,1);
X		kill(pid,SIGTERM);
X		while(wait(0)!=pid);
X		}
X	}
X
X/* star trek effect */
X
X
X/*
X * porter.c  Steve Hawley 4/3/87
X * rehacked 5/18/1988 for extra speed.
X * re-re hacked 6/20/88 for MGR (SAU)
X * A demo to get stars inspired by Star Trek without
X * using quickdraw, and by addressing the screen directly.
X * this version is roughly 8 times faster than its quickdraw
X * equivalent.
X * In considering the bit drawing routines, remember that
X * on the macintosh, a bit turned on is black, not white.
X */
X
X#define MAXZ 500 /* maximum z depth */
X#define NSTARS 256 /* maximum number of stars */
X#define SPEED	8		/* star speed */
X#define SCALE	(short)6	/* for rotator */
X#define COUNT	(short)3	/* for rotator */
X#define ON 1  /* plotting states */
X#define OFF 0
X#define Random() rand()
X
Xshort maxv, maxh; /* display size */
Xshort hmaxv, hmaxh;	/* 1/2 display size */
X
Xstruct st {
X        short x, y, z;
X	short color;
X        } stars[NSTARS]; /* our galaxy */
X
Xfly (where,clip1,clip2)
XBITMAP *where;
Xstruct rect clip1, clip2;		/* "holes" in galaxy */
X{
X        register short i;
X        register struct st *stp;
X
X        init_all(where);     /* set up global variables */
X        for (i=0, stp = stars; i< NSTARS; i++, stp++) {
X                /* initialize galaxy */
X                do {
X                        stp->x = Random();
X                        stp->y = Random();
X                        stp->z = (Random() % MAXZ) + 1;
X                        stp->color = Random() % 23;
X								if (stp->color == BG_COLOR)
X                        	stp->color++;
X			
X                } while(project(where,stp->x, stp->y, stp->z, stp->color, ON,clip1,clip2)); /* on screen? */
X        }
X        while (1) { /* loop 'til button */
X                i = NSTARS;
X                stp = stars;
X                do {
X                        project(where,stp->x, stp->y, stp->z, stp->color, OFF,clip1,clip2); /* turn star off*/
X                        if ((stp->z -= SPEED) <= 0) { /* star went past us */
X                                stp->x = Random();
X                                stp->y = Random();
X                                stp->z = MAXZ;
X                        }
X								else {		/* rotate universe */
X									cordic(&stp->x,&stp->y,SCALE,COUNT);
X								}
X                        if (project(where,stp->x, stp->y, stp->z, stp->color, ON,clip1,clip2)) {
X                                /* if projection is off screen, get a new position */
X                                stp->x = Random();
X                                stp->y = Random();
X                                stp->z = MAXZ;
X                        }
X                ++stp;
X                } while(--i);
X        }
X}
X
Xproject(where,x, y, z, col, state,clip1,clip2)
Xregister BITMAP *where;
Xregister short x, y, z;
Xregister int col;
Xregister short state;
Xstruct rect clip1, clip2;
X{
X        
X        /* one-point perspective projection */
X        /* the offsets (maxh/2) and maxv/2) ensure that the
X         * projection is screen centered
X         */
X		x = (x/z) + hmaxh;
X		y = (y/z) + hmaxv;
X        return(xplot(where,x, y, col, state,clip1,clip2));
X
X}
X
Xinit_all(where)
Xregister BITMAP *where;
X{
X   maxv = BIT_HIGH(where);
X   hmaxv = maxv>>1;
X   maxh = BIT_WIDE(where);
X   hmaxh = maxh>>1;
X}       
X
Xxplot(where,x, y, col, state,clip1,clip2)
Xregister BITMAP *where;
Xregister int x, y;
Xregister int col;
Xint state;
Xstruct rect clip1, clip2;
X{
X        register short *line, b;
X        
X        /* are we on the screen? If not, let the caller know*/
X        if (x < 0 || x >= maxh || y < 0 || y >= maxv )
X            return(1);
X        if (!(x < clip1.x1 || x >= clip1.x2 || y < clip1.y1 || y >= clip1.y2 ))
X            return(0);
X        if (!(x < clip2.x1 || x >= clip2.x2 || y < clip2.y1 || y >= clip2.y2 ))
X            return(0);
X
X        bit_blit(where,x,y,SSIZE,SSIZE, state ?
X		BIT_SRC^BIT_DST | GETCOLOR(col)^GETCOLOR(BG_COLOR) :
X		BIT_SRC | GETCOLOR(BG_COLOR),
X                 0l,0,0);
X        return(0);
X}
X
X/* CORDIC rotator. Takes as args a point (x,y) and spins it */
X/* count steps counter-clockwise.                   1       */
X/*                                Rotates atan( --------- ) */
X/*                                                  scale   */
X/*                                                 2        */
X/* Therefore a scale of 5 is 1.79 degrees/step and          */
X/* a scale of 4 is 3.57 degrees/step                        */
X
Xcordic(x, y, scale, count)
Xshort *x, *y;
Xregister short scale, count;
X
X{
X   register short tempx, tempy;
X
X   tempx = *x;
X   tempy = *y;
X
X   if (count > 0) /* positive count (counter-clockwise) */
X      for (; count; count--){
X         tempx -= (tempy >> scale);
X         tempy += (tempx >> scale); 
X      }
X   else          /* negative count (clockwise) */
X      for (; count; count++){
X         tempx += (tempy >> scale);
X         tempy += (tempx >> scale);
X      }
X
X   *x = tempx;
X   *y = tempy;
X}
END_OF_FILE
# end of 'src/copyright.c'
fi
if test -f 'src/get_info.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/get_info.c'\"
else
echo shar: Extracting \"'src/get_info.c'\" \(7612 characters\)
sed "s/^X//" >'src/get_info.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: get_info.c,v 4.3 88/08/22 11:42:35 sau Exp $
X	$Source: /tmp/mgrsrc/src/RCS/get_info.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/get_info.c,v $$Revision: 4.3 $";
X
X/* return info to shell */
X
X#include "bitmap.h"
X#include "font.h"
X#include "defs.h"
X#include "menu.h"
X#include "event.h"
X#include <stdio.h>
X#include "window.h"
X
X/*	BUTTON_SYS is never reported as a possible button setting. */
X#define	RPT_BUTTON()	(button_state == BUTTON_SYS ? 0 : button_state )
X
Xget_info(win,window,text)
Xregister WINDOW *win;			/* window info is about */
XBITMAP *window;				/* window's bitmap data */
XBITMAP *text;				/* window's text region */
X   {
X   int cnt = W(esc_cnt);		/* # of leading ESC #'s */
X   int count;				/* whatever */
X   char font_buff[MAX_PATH];		/* space to store a path name */
X   char coords[1024];			/* space for return value */
X   register WINDOW *win2;		/* generic window pntr */
X   struct font *Get_font();
X
X   if (cnt == 1) {		/* info about spot */
X      for(win2=active;win2!=(WINDOW *) 0;win2=win2->next)
X         if (mousein(W(esc)[0],W(esc)[1],win2,1))
X            break;
X      if (win2 != (WINDOW *) 0)
X         sprintf(coords,"%s %s %d %d\n",
X                  win->tty+strlen(win->tty)-2,
X                  win2->tty+strlen(win2->tty)-2,win2->num,win2->pid);
X      else
X         sprintf(coords,"\n");
X      Write(W(to_fd),coords,strlen(coords));
X      return;
X      }
X      
X#ifdef DEBUG
X   dprintf(i)(stderr,"%s: getting info %d\r\n",W(tty),*W(esc));
X#endif
X   switch (W(esc)[0]) {
X      case G_TERMCAP:	/* send termcap entry back to shell */
X           {
X           int lines = T_HIGH/FSIZE(high);
X           int cols  = T_WIDE/FSIZE(wide);
X           sprintf(coords,"%s:am:li#%d:co#%d:bs:cl=^L:ce=\\E%c:cd=\\E%c:cm=\\E%%r%%d%c%%d%c:al=\\E%c:dl=\\E%c:ic=\\E%c:dc=\\E%c:im=:ta=^I:up=\\E%c:do=\\E%c:nd=\\E%c:ku=\\E[A:kd=\\E[B:kr=\\E[C:kl=\\E[D:so=\\E%c:se=\\E%c:vs=\\E%c:ve=\\E%c:\n",
X                   C_NAME,lines,cols,E_CLEAREOL,E_CLEAREOS,
X                   E_SEP1,E_CUP,E_ADDLINE,E_DELETELINE,E_ADDCHAR,E_DELETECHAR, 
X                   E_UPLINE,E_DOWN,E_RIGHT,E_STANDOUT,E_STANDEND,
X                   E_VI,E_NOVI);
X           }
X           break;
X      case G_WINSIZE:					/* cols, lines */
X           sprintf(coords,"%d %d\n", T_WIDE/FSIZE(wide),
X              T_HIGH/FSIZE(high));
X           break;
X      case G_FONT:					/* font wide, high, # */
X           {
X           register int id = W(font)->ident;
X           sprintf(coords,"%d %d %d %s\n", FSIZE(wide),
X              FSIZE(high),id,id>0?fontlist[id-1]:
X              "default.fnt");
X           }
X           break;
X      case G_CURSOR:					/* x,y gx,gy cursor_type */
X           sprintf(coords,"%d %d %d %d %d\n",
X              W(x)/FSIZE(wide),
X              W(y)/FSIZE(high)-1,
X              W(gx), W(gy),
X              W(curs_type));
X           break;
X      case G_TEXT:			/* text region size: x,y,wide,high */
X           sprintf(coords,"%d %d %d %d\n",
X              W(text.x),W(text.y),W(text.wide),W(text.high));
X           break;
X      case G_MOUSE:					/* mouse coordinates */
X           sprintf(coords,"%d %d %d\n", mousex, mousey, RPT_BUTTON());
X           break;
X      case G_MOUSE2:				/* massaged coordinates */
X           if (W(flags)&W_ABSCOORDS)
X              sprintf(coords, "%d %d %d\n", mousex-W(x0), mousey-W(y0), 
X                    RPT_BUTTON());
X           else
X              sprintf(coords,"%d %d %d\n",
X                    (mousex-W(x0))*GMAX/BIT_WIDE(W(window)),
X                    (mousey-W(y0))*GMAX/BIT_HIGH(W(window)),
X                    RPT_BUTTON());
X           break;
X      case G_COORDS:					/* window coords */
X           sprintf(coords,"%d %d %d %d\n",W(x0),W(y0),
X              WIDE,HIGH);
X           break;
X      case G_STATUS:					/* window status */
X           sprintf(coords,"%c\n",W(flags)&W_ACTIVE
X                   ? C_EXPOSED: C_OBSCURED);
X           if (win == active)
X              *coords = C_ACTIVE;
X           break;
X      case G_ALLMINE:			/* window status for client windows */
X      case G_ALL:				/* complete window status */
X           {
X           register char status;
X           *coords = '\0';
X           for(win2=active;win2!=(WINDOW *) 0;win2=win2->next) {
X              if (*W(esc)==G_ALLMINE && win2->main != W(main))
X                 continue;
X              status = win2->flags&W_ACTIVE ? C_EXPOSED:C_OBSCURED;
X              if (win2 == win)
X                 status += ('A'-'a');
X              sprintf(coords+strlen(coords),"%d %d %d %d %s %d %c %d\n",
X                      win2->x0,
X                      win2->y0,
X                      win2->BIT_WIDE(border),
X                      win2->BIT_HIGH(border),
X                      win2->tty+strlen(win2->tty)-2,
X                      win2->num,
X                      status,
X		      win2->setid);
X               Write(W(to_fd),coords,strlen(coords));
X               *coords = '\0';
X               }
X           sprintf(coords+strlen(coords),"\n");
X           }
X           break;
X      case G_NOTIFY:			/* list windows with notify set  */
X           {
X           register char *str;
X           *coords = '\0';
X           for(win2=active;win2!=(WINDOW *) 0;win2=win2->next) {
X#ifdef DEBUG
X              dprintf(i)(stderr,"  checking %s\r\n",win2->tty);
X#endif
X              if (IS_EVENT(win2,EVENT_NOTIFY) &&
X                    (str = win2->events[GET_EVENT(EVENT_NOTIFY)])) {
X                 sprintf(coords+strlen(coords),"%d.%d %d %s\n",
X                          win2->pid,win2->num,strlen(str),str);
X                 Write(W(to_fd),coords,strlen(coords));
X                 *coords = '\0';
X#ifdef DEBUG
X                 dprintf(i)(stderr,"    got %s\r\n",str);
X#endif
X                 } 
X              }
X           sprintf(coords+strlen(coords),"\n");
X           }
X           break;
X      case G_SYSTEM:					/* system status */
X           gethostname(coords,sizeof(coords));
X           sprintf(coords+strlen(coords)," %d %d %d %d %d\n",
X                      BIT_WIDE(screen),
X                      BIT_HIGH(screen),
X                      SUM_BDR,
X                      DEPTH,
X                      BITS+1);
X           break;
X      case G_ID:					/* client window id */
X           for(count=0,win2=W(main);win2;win2=win2->alt)
X              count++;
X           sprintf(coords,"%d %d\n",W(num),count);
X           break;
X      case G_FLAGS:					/* window flags */
X           sprintf(coords,"%0x\n",W(flags));
X           break;
X#ifdef OBSOLETE
X      case G_ALLFONT:					/* font information */
X           {
X           register struct font *temp;
X           register int i;
X 
X           sprintf(coords,"%d %d",font->head.wide,
X                                 font->head.high);
X           for(i=0;i<MAXFONT;i++)  {
X              temp=Get_font(i);
X              sprintf(coords+strlen(coords), "  %d %d",
X                            temp->head.wide,
X                            temp->head.high);
X              }
X           strcat(coords,"\n");
X           }
X           break;
X#endif
X      }
X   if (strlen(coords))
X      Write(W(to_fd),coords,strlen(coords));
X#ifdef DEBUG
X   dprintf(i)(stderr,"  sending (%d) [%s]\r\n",
X                 strlen(coords),coords);
X#endif
X   }
END_OF_FILE
# end of 'src/get_info.c'
fi
echo shar: End of archive 25 \(of 61\).
cp /dev/null ark25isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
