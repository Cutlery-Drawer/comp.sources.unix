Subject:  v17i022:  MGR, Bellcore window manager, Part21/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 22
Archive-name: mgr/part21




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 21 (of 61)."
# Contents:  Makefile demo/misc/clock.c doc/zoom.1 font-32/Ugal12x20b
#   font-32/Ugal12x20r src/fast_scroll.c src/get_text.c src/getshell.c
#   src/oblit/line.c
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:24 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(5287 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#                        Copyright (c) 1987 Bellcore
X#                            All Rights Reserved
X#       Permission is granted to copy or use this program, EXCEPT that it
X#       may not be sold for profit, the copyright notice must be reproduced
X#       on copies, and credit should be given to Bellcore where it is due.
X#       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X
X#	$Header: Makefile,v 4.10 88/08/25 17:15:04 bianchi Exp $
X#	$Source: /tmp/mgrsrc/RCS/Makefile,v $
X
X#	top level makefile for mgr
X
X#########################################################################
X
X#	To make mgr type:
X#	make INSROOT=<root> TARGET=<target> [OTHERLIB=<otherlib>]
X#		<root> is the mgr root directory (normally /usr/mgr)
X#		<target> is the target version of mgr, typically
X#			prod:	 for the "production" monochrome release or
X#			color: for the color version
X#		<otherlib> is the name of any auxiliary graphics libraries required.
X#			The color (and 386/i) versions need -lpixrect
X#
X
X#########################################################################33
X
X
X# set to root of mgr directory
XINSROOT = /usr/mgr
XINSROOT = /usr/public/pkg/nmgr
X
X# set to auxiliary bitmap library (use -lpixrect for color)
XOTHERLIB=-lpixrect
XOTHERLIB=
X
X# pieces necessary for creating demos and applications only
X# (for not-necessarily-suns)
XSMALLDIR = lib demo doc menu
X
X# directories that need making (-src, a special case)
XSUBDIR = font icon $(SMALLDIR)
X
X# full mgr directories
XALLDIR = src font-16 font-32 icon $(SMALLDIR) misc
X
XSTART=.
X
XCPIO=cpio
XCPIO_OUT=mgr.cpio
XCPIO_OPTS = ocv
X
XMAKE=make
XTARGET=all
X
Xall:	src $(SUBDIR)
X
X#	this is broken - use co_mgr instead
Xco:
X	-mkdir $(ALLDIR)
X	co `make -s list MAKE=true`
X	for i in $(ALLDIR); do \
X	(cd $$i; echo "	co: $$i";\
X	 co Makefile
X	 $(MAKE) co ;\
X	 cd ..);\
X	done	
X
X#	"make fast" builds the mgr command quickly, without paying attention
X#	to dependencies.
X
Xfast:
X	cd src;  echo "	making src fast";  $(MAKE)  INSROOT=$(INSROOT) fast
X
X
X#	"make small" builds the mgr support library and support commands.
X#	A "small" mgr package (see smallinstall and smallcpio) is that portion
X#	which does not necessarily have to be on the same machine as the mgr
X#	command.
X
Xsmall:
X	for i in $(SMALLDIR); do \
X	(cd $$i; echo "	making $$i";\
X 	 $(MAKE)  INSROOT=$(INSROOT) $@;\
X	 cd ..);\
X	done	
X
X#	"make <<directoryname>>" will make the named directory.  Note that this
X#	is the better way to make individual subdirectories because that way
X#	INSROOT is propigated down to all files that need it, in particular
X#	"src" files.
X
X$(SUBDIR):
X	cd $@;  echo "	making $@";  $(MAKE) \
X		 OTHERLIB=$(OTHERLIB) INSROOT=$(INSROOT) all
X
Xsrc:
X	cd src; echo " making src"; $(MAKE) \
X		 OTHERLIB=$(OTHERLIB) INSROOT=$(INSROOT) $(TARGET)
X
X#	"make install" installs mgr and all its support files and commands.
X#	mgr is not made setuid-root.
X
Xinstall:	$(INSROOT)
X	cd src; \
X	 $(MAKE) OTHERLIB=$(OTHERLIB) INSROOT=$(INSROOT) $(TARGET) install;
X	for i in $(SUBDIR); do \
X	(cd $$i; echo "	installing $$i";\
X 	 $(MAKE)  OTHERLIB=$(OTHERLIB) INSROOT=$(INSROOT) install;\
X	 cd ..);\
X	done	
X
X#	"make installasroot" runs "make install" as root.  mgr and some of the
X#	support commands are made setuid-root.
Xinstallasroot:
X	/bin/su root -c '$(MAKE) OTHERLIB=$(OTHERLIB) INSROOT=$(INSROOT) \
X		TARGET=$(TARGET) install'
X
X#	"make smallinstall" installs the mgr support commands which do not
X#	have to be on the same machine as the mgr command.
Xsmallinstall:	$(INSROOT)
X	for i in $(SMALLDIR); do \
X		(cd $$i; echo "	$@ing $$i";\
X		 $(MAKE)  OTHERLIB=$(OTHERLIB) INSROOT=$(INSROOT) $@;\
X		 cd ..);\
X	done	
X
X$(INSROOT):
X	mkdir $@
X
X#	"make clean" removes all intermediate files created by "make all".
X#	"make clobber" removes all target files created by "make all".
Xclean clobber:
X	-rm font
X	for i in $(ALLDIR); do \
X		if [ -d $$i ]; then \
X			(cd $$i; echo "	$@ing $$i";\
X			 $(MAKE)  INSROOT=$(INSROOT) $@;\
X			 cd ..);\
X		fi; \
X	done	
X
X#	"make list" outputs the complete list of files needed by "make all".
X#	This list is also what goes into a delivery package.
X#	This list is used by several scripts to keep track of stuff
Xlist:
X	@echo $(START)/README
X	@echo $(START)/Makefile
X	@for i in $(ALLDIR); do \
X		echo "$(START)/$$i"; \
X		if [ -d $$i ]; then \
X			cd $$i; $(MAKE)  START=$(START)/$$i list; cd ..; \
X		fi \
X	done	
X
X
X#	"make smalllist" outputs the list of files needed by "make small".
X#	This list is also what goes into a "small" delivery package.
Xsmalllist:
X	@echo $(START)/README
X	@echo $(START)/Makefile
X	@echo $(START)/font
X	@echo $(START)/font/default.fnt
X	@echo $(START)/font/Makefile
X	@for i in $(SMALLDIR); do \
X		(cd $$i; echo "$(START)/$$i";\
X		 $(MAKE)  START=$(START)/$$i list;\
X		 cd ..);\
X	done	
X
X#	"make cpio" creates a file containing a complete delivery package.
Xcpio:
X	$(MAKE) -s list | $(CPIO) -$(CPIO_OPTS) > $(CPIO_OUT)
X
X#	"make smallcpio" creates a file containing a "small" delivery package.
Xsmallcpio:
X	$(MAKE) -s smalllist | $(CPIO) -$(CPIO_OPTS) > $(CPIO_OUT).small
X
X
X#	The FRC target forces items to remake.  Thus "make lib" will
X#	issue the commands for the "lib" target, even though the lib directory
X#	exists.
Xsrc $(SUBDIR):	FRC
X
XFRC:
X
X#	for GNU make
X.PHONY:	src $(SUBDIR)
X.PHONY:	clean list fast cpio smallcpio install smallinstall
END_OF_FILE
# end of 'Makefile'
fi
if test -f 'demo/misc/clock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/misc/clock.c'\"
else
echo shar: Extracting \"'demo/misc/clock.c'\" \(5310 characters\)
sed "s/^X//" >'demo/misc/clock.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: clock.c,v 4.2 88/06/22 14:37:25 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/misc/RCS/clock.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/misc/RCS/clock.c,v $$Revision: 4.2 $";
X
X/* get today's date */
X
X#include <errno.h>
X#include <time.h>
X#include <signal.h>
X#include "term.h"
X
X#define FONT		14			/* default font */
X#define POLL		15			/* poll interval */
X#define FIX(x)		((x)>12?(x)-12:(x))
X#define dprintf		if (debug) fprintf
X
Xstatic char line[MAXLINE];
Xstatic int x, y;		/* starting coord for clock */
Xstatic int fired = 0;		/* alarm fired */
Xstatic int armed = 0;		/* alarm armed */
Xstatic int covered = 0;		/* window is covered */
Xstatic int fx, fy;		/* font size */
Xstatic int wx, wy;		/* window size */
Xstatic char *alarm_time = NULL;
Xstatic int debug;
X
Xstatic struct menu_entry enable[] = {
X	"ALARM CLOCK","",
X	"enable alarm","+\r",
X};
X
Xstatic struct menu_entry disable[] = {
X	"ALARM CLOCK","",
X	"disable alarm","-\r",
X};
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   int update(), clean();
X   char *today();
X   char buff[MAXLINE];
X   int f_flag=0, s_flag=0, b_flag=0;
X   int font;
X   register int i;
X   char *getenv();
X
X   ckmgrterm( *argv );
X
X   debug = (getenv("DEBUG") != NULL);
X   for(i=1;i<argc;i++)
X      if (*argv[i] == '-') switch (argv[i][1]) {
X         case 'f':	/* -f<fontnumber>   select alternate font */
X	     f_flag++;
X	     font=atoi(argv[i]+2);
X	     break;
X         case 'b':	/* -b   bury the window immediately */
X	     b_flag++;
X	     break;
X         case 's':	/* -s   don't resize window, center the display */
X	     s_flag++;
X	     break;
X         }
X      else {
X         alarm_time = argv[i];
X         dprintf(stderr,"Setting alarm time to: %s\n",alarm_time);
X         armed=1;
X         };
X
X   m_setup(0);
X   signal(SIGALRM,update);
X   signal(SIGINT,clean);
X   signal(SIGTERM,clean);
X   m_ttyset();
X   if (armed) {
X      m_push(P_MENU|P_EVENT|P_FLAGS|P_FONT);
X      menu_load(1,2,enable);
X      menu_load(2,2,disable);
X      m_selectmenu(1+armed);
X      }
X   else
X      m_push(P_EVENT|P_FLAGS|P_FONT);
X   m_setmode(M_NOWRAP);
X   m_setmode(M_ABS);
X   m_setevent(BUTTON_1,"A\r");
X   m_setevent(BUTTON_1U,"X\r");
X   m_setevent(RESHAPE,"X\r");
X   m_setevent(REDRAW,"X\r");
X   m_setevent(COVERED,"C\r");
X   m_setevent(UNCOVERED,"E\r");
X
X   if (f_flag)
X      m_font(font);
X   else
X      m_font(FONT);
X   if (!s_flag)
X      m_size(5,1);
X   if (b_flag)
X      m_clearmode(M_ACTIVATE);
X
X   setxy();
X   update();
X   while (1) {
X      extern int   errno;
X
X      errno = 0;
X      *line = '\0';
X      if (m_gets(line) == NULL  &&  errno  &&  errno != EINTR)
X         clean();
X      alarm(0);
X      dprintf(stderr,"Got: %s\n",line);
X      switch (*line) {
X         case 'C':			/* covered */
X            covered = 1;
X            break;
X         case 'E':			/* exposed */
X            covered = 0;
X            break;
X         case '+':			/* enable alarm */
X            dprintf(stderr,"Arming alarm\n");
X            armed = 1;
X            m_selectmenu(armed+1);
X            m_flush();
X            break;
X         case '-':			/* disable alarm */
X            dprintf(stderr,"Disarming alarm\n");
X            armed = 0;
X            fired = 0;
X            m_selectmenu(armed+1);
X            m_flush();
X            break;
X         case 'A':			/* show alarm time */
X            if (alarm_time) {
X               m_moveprint(x,y,alarm_time);
X               m_movecursor(wx+fx,y);
X               m_flush();
X               m_gets(line);
X               fired = 0;
X               }
X            break; 
X         case 'X':			/* redraw, reshape */
X            setxy();
X            break;
X         }
X      update();
X      }
X   }
X
Xint
Xupdate()
X   {
X   char *today();
X   char *s = today();
X   m_moveprint(x,y,s);
X   m_movecursor(wx+fx,y);
X   if (fired || (armed && alarm_time && strcmp(alarm_time,s)==0)) {
X      dprintf(stderr,"Fireing alarm %s\n",fired?"":"FIRST TIME");
X      fired = 1;
X      if (covered) {
X         m_setmode(M_NOINPUT);
X         m_setmode(M_ACTIVATE);
X         }
X      m_setmode(M_WOB);
X      m_printstr("\007");
X      m_flush();
X      sleep(2);
X      m_clearmode(M_WOB);
X      if (covered) {
X         m_clearmode(M_ACTIVATE); 
X         m_clearmode(M_NOINPUT);
X         }
X      }
X   m_flush();
X   signal(SIGALRM,update);
X   alarm(POLL);
X   }
X   
Xchar * 
Xtoday()
X   {
X   struct tm *tme, *localtime();
X   static char result[9];
X   long tmp,time();
X
X   tmp = time(0);
X   tme = localtime(&tmp);
X   sprintf(result,"%02d:%02d",FIX(tme->tm_hour),tme->tm_min);
X   return(result);
X   }
X
Xclean()
X   {
X   m_pop(0);
X   m_ttyreset();
X   exit(1);
X   }
X
Xsetxy()
X   {
X   char *today();
X
X   get_font(&fx,&fy);
X   get_size(0,0,&wx,&wy);
X   x = (wx - strlen(today())*fx)/2;
X   y = fy + (wy - fy)/2;
X   if (x<0) x = 0;
X   if (y<0) y = 0;
X   m_clear();
X   dprintf(stderr,"Setting %d x %d at %d x %d in %d x %d\n",
X          strlen(today())*fx,fy,x,y,wx,wy);
X   m_flush();
X   }
END_OF_FILE
# end of 'demo/misc/clock.c'
fi
if test -f 'doc/zoom.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/zoom.1'\"
else
echo shar: Extracting \"'doc/zoom.1'\" \(5172 characters\)
sed "s/^X//" >'doc/zoom.1' <<'END_OF_FILE'
X'\"                        Copyright (c) 1988 Bellcore
X'\"                            All Rights Reserved
X'\"       Permission is granted to copy or use this program, EXCEPT that it
X'\"       may not be sold for profit, the copyright notice must be reproduced
X'\"       on copies, and credit should be given to Bellcore where it is due.
X'\"       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X'\"
X'\"	$Header: zoom.1,v 4.1 88/06/21 13:56:26 bianchi Exp $
X'\"	$Source: /tmp/mgrsrc/doc/RCS/zoom.1,v $
X.TH zoom 1L "June 10, 1986"
X.SH NAME
Xzoom \- an icon editor for
X.I mgr
X.SH SYNOPSIS
X.B zoom
X<\fBicon file\fP> ...
X.SH DESCRIPTION
X.B zoom
Xis a mouse driven icon editter for
X.I mgr.
X.B Zoom
Xdivides the window into three regions, a banner line at the top containing
Xfour status fields,
Xa message line at the bottom,
Xand the remainder of the window for an enlarged, or
X.I zoomed
Xrepresentation of
X.I <icon>
Xbeing editted.
XIf the first file given on the command line is not an icon,
Xzoom prompts for its width and height.
X.LP
XThe current state of zoom is indicated by the four status fields in the
Xbanner line.
X.TP
X*
XThe first, or
X.I raster function
Xfield displays the current raster-op function to be applied to the next
Xedit operation.  This function may be changed with the pop-up menu,
Xactivated by pressing the middle mouse button while the mouse track is in the 
X.I raster function
Xfield.
XNormally the choices are 
X.B set, clear, toggle
Xand
X.B grid.
XThe first three are raster-op functions; the
X.I grid
Xoption toggles the bitmap alignment grid.
XIf the
X.B put
Xcommand is pending (see below), the raster-op choices become
X.B copy, paint mask,
Xand
X.B exclusive-or. 
X.TP
X*
XThe second, or
X.I edit
Xfield displays one of the six possible edit functions:
X.B Yank, Put, Shrink, Grow, Fix,
Xand
X.B  Undo.
XFix and Undo are performed when selected. 
X.B Fix
Xchanges the window size
Xto give square pixels. 
X.B Undo
Xun-does the previous edit operation.
XIf any of the other functions is selected, it becomes the pending function,
Xand is highlighted.
XWhen a function is pending, the next sweep operation performs that function
Xon the group of pixels enclosed by the sweeping rectangle (the 
X.I selected
Xpixels).
X.RS
X.TP
X.B Yank
Xcopies the 
X.I selected
Xpixels into the yank buffer.
X.TP
X.B Put
Xcombines the yank buffer with the 
X.I selected
Xpixels in a manner determined
Xby the current
X.I raster function
Xfield.
X.TP
X.B Shrink
Xmakes the icon smaller by scaling the selected pixels to fill the entire
Xwindow.
X.TP 
X.B Grow
Xmakes the icon bigger by scaling the entire icon to fit into the
Xselected pixel region.
X.RE
X.TP 
X*
XThe Third or
X.I size
Xfield displays the current 
X.I width
Xand
X.I height
Xof the icon, in pixels.
XThe size of the icon may be changed by selecting the pop-up menu
Xwhen the mouse track is in the
X.I size
Xfield
Xand responding to the prompt.
XWhile in the prompt window, the menu permits the selection
Xof several standard icon sizes.
X.TP
X*
XThe fourth, and final field is the
X.I file
Xfield.
XThe
X.I file
Xfield displays the current file name of the icon.
XThe filing options
X.B Save, Get, Yank,
Xand
XQuit
Xare, as usual, accessed by a pop-up menu when the mouse track
Xis in the
X.I file
Xfield.
XThe
X.I file
Xoptions prompt for a file name.  
XA list of all of the files specified on the command line
Xis available via the pop-up menu within the prompt window.
X.RS
X.TP
X.B
XSave
Xsaves the icon by the specified name.
X.TP
X.B Get
Xedits a new icon , tossing the current icon into the bit-bucket.
X.TP
X.B Yank
Xcopies the specified icon into the
X.I yank 
Xbuffer for use with the
X.B put
Xcommand.
X.TP
X.B Quit
Xquits
XZoom. Quit does
X.B NOT
Xsave the icon.  A save must be explicitly issued first.
XZoom may also be terminated by typing
X"Q\er" to the window, or hitting your favorite interrupt key.
X.RE
X.LP
XFor those who are not particularly font of rodents, all of the
X.B zoom 
Xcommands may be accessed via 1 or 2 letter keyboard commands
X(followed by a \er), some of which
Xare:
X
X 	R	Repaint window
X 	x	toggle alignment grid
X 	w	FIX window aspect ratio
X 	u	UNDO
X
X 	s1	select SET mode
X 	s2	select CLEAR mode
X 	s3	select TOGGLE mode
X
X 	f	SAVE file
X 	g	GET a new file
X 	y	YANK a file
X 	Q	QUIT
X
X 	F1	select YANK function
X 	F2	select PUT function
X 	F3	SHRINK icon
X 	F4	GROW icon
X
X 	P0	set COPY mode
X 	P1	set PAINT mode
X 	P2	set MASK mode
X 	P3	set XOR mode
X
X.LP
XOkay, now to edit the icon.
X.TP 
X*
XPressing the middle button and moving it either sets or clears the pixels
Xit passes over.  If the first pixel it touches is clear, the pixels will
Xbe set; if it is set, all touched pixels will be cleared.
X.TP
X*
XHolding, moving, then releasing the right mouse button sweeps out
Xa rectangular region of
X.I selected pixels.
XIf no function is currently highlighted in the 
X.I edit
Xfield,
Xthe current raster-op function is performed on 
Xthe selected pixels.
XOtherwise, the highlighted function is performed.
X.SH BUGS
X.TP 3
X*
XZoom works best on small icons, running on the local machine.
X.TP 3
X*
XYou can't view the actual size of the icon being editted.
X.TP 3
X*
XIcon coordinates must be typed in exactly in the form of
X.B x
X,
X.B y
Xwith no spaces or tabs.
X.SH SEE ALSO
Xbrowse(1L)
Xdump(5L)
Xmgr(1L)
END_OF_FILE
# end of 'doc/zoom.1'
fi
if test -f 'font-32/Ugal12x20b' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-32/Ugal12x20b'\"
else
echo shar: Extracting \"'font-32/Ugal12x20b'\" \(5330 characters\)
sed "s/^X//" >'font-32/Ugal12x20b' <<'END_OF_FILE'
Xbegin 644 gal12x20b.fnt
XM& P4!8                                                      
XM              !P'< [!P/'!X#@ ..            '!X P'X#\ <#^!X'_
XM#X#\          #X                                            
XM          !^< ?@!@   8  ,    '   \  &     < 'P              
XM               >!P/                                         
XM                              !P'< ['\9N#\'P <'            .
XM#\!P/\'^ \#^#@/_&<&>          '\  !P_X#^_X?^?^#^^/'\'\^/? \'
XMX'#X?\#X_X'_?_^'\/__^'^'/_!^< ?@#P   X  <    /  !N  . !P .\ 
XM!P                             X!P#@                        
XM                                              !P'< [/^9N'.'P
XM \'@           .&<#P<>,/ \& ' <&..,/          />  !P<,&'<>.&
XM.&&'<'!P!P<<. </<#&>..&><<.'9S<#<&=S<#<#,.!P. #@'X  !P  \   
XM '  !N  > !P .< !P              !@             X!P#@        
XM                                                            
XM  !P'<!W=_9\'.!P X#@           <&.'P8.8'!\& .  &..<'        
XM  ,.#\#X<.,#<..&.&,#<'!P!P<X. >/>#,..',.<.<#!P<#.,=S.&.& .!P
XM. #@.<  !P  <    '  #@  .     < !P              !@          
XM   <!P'                                                     
XM                  !P'<'_=W/<'.!P!X#P#X         <../P . '!\, 
XM.  ...<'           ./^#X<., <'. . , <'!P!P=P. >/?#,'.','<.<#
XM!P<#.,=S/,', <!P' #@<.  !\  <    '  #@  .     < !P          
XM    #@             <!P'                                     
XM                                  !P'<'_=P X#\#@!P!P!P!P    
XM   X..!P . /#</\<  ,',<'#@   '  <  ..'#8<.< <'. . < <'!P!P?@
XM. >/?#<'.'<'<.> !P<#.,?S',', <!P' #@    !\#\=\'\#_#X#@'[/\'P
XM ^<>!P_^-\#\_\#[>\'^?^??^'___/^/?_ <!P'                     
XM                                                  !P  #N/P X
XM'P' !P!P=W!P       X..!P .!^#<.>=\ ,#X>/'P#@ >  /  <<'&<<<< 
XM<'.,.,< <'!P!P? . ??;C<'..<'<,/@!P<#'8?^#X#X X!P#@#@     X'.
XM?^.>.?..#@.?/>!P .<X!P?_?>&>>>&?/N..#@..<#=S>&<#</ X!P#@    
XM                                                            
XM      !P  #N'\!P/P& !P!P?_!P      !P..!P <#^&< /?^ <!P/_'P'P
XM!X?^'P X=[&<?\< <'/\/\< ?_!P!P? . ??9S<'/\<'?X'P!P<#'8.^!P!P
XM X!P#@#@      &.>/,.,/<''\<...!P .=P!P=W..,/</,//..&#@...&=S
XM/,.&8>!X!P#P                                                
XM                      !P  '<!^#@?X  !P!P'<!P      #@..!P X /
XM&< '>/ 8#X'W#@'P'P?^!\!P?_&,<.< <'.,.,< <'!P!P?@. ??9[<'. <'
XM?@!\!P<#'8/^!P!P!P!P!P#@       ^<'< <'<'#@<...!P .?@!P=W..<'
XM<'<'. / #@...&=S'X.& \ X!P#@'C                              
XM                                      !P  '<!W#@<_  !P!P  ?_
XM  ?_  #@..!P!P ',< '<' 8&< '  #@?    ?#@?O/^<'< <'. . <?<'!P
XM!P?P. ;_8[<'. <'?P >!P<##@/^#X!P!P!P X#@      'N<'< <'?_#@<.
XM..!P .? !P=W..<'<'<'. 'P#@..',/^#P',!X <!P' /W              
XM                                                      !P  ?^
XM!W'><?  !X#P'<?_  ?_  ' ..!P#@ '/_ '<' X.. .    ?    ?#@?O,.
XM<'< <'. . <'<'!P!P=X. ;W8?<'. <'=X /!P<##P/\&<!P#@!P X#@    
XM  ..<'< <'< #@.<..!P .?@!P=W..<'<'<'. !\#@..',/^!X',#P <!P' 
XM/^                                                          
XM              ?^=W'S<>   X#@?_!P    #@' .,!P' 8'?_8'<' P.. .
XM#@  'P?^!\  =_,&<', <'. . ,'<'!P!P<\. ;W8/,&. .&<\8'!P<##P'<
XM&>!P#@!P <#@      ..<'< <'< #@/X..!P .?P!P=W..<'<'<'.  >#@..
XM#X/^#\#X'@ <!P' =^                                          
XM                              .X?^.S<<   \'@=W!P#@  'P. ',!P
XM.#<& <<'>& P.. <'P#@!X?^'P  < 8'<'.#<&.#. .'<'!P!P<>.#9G8/.&
XM. /&<>8'!P>&!@'<,.!P' !P <#@      ..>'>&>/. #@< ..!P .=X!P=W
XM..>&<&>'. ,.#C..#X'<&>#X/# X!P#@8\                          
XM                                          !P  =P/\.S/_   <' 
XM!P!P'P  'P. 'X!P?_/\ <../\!P',!X'P'P >  / #@. 8'<.'&<<.#. ''
XM<'!P!P</.#9G8'',. '\</<.!P/^!@'<8'!P'#!^ .?@      />?.../?''
XM#@?^..!P .<\!P=W../,>,//. ..#V/>!P'<,/!P>' X!P#@            
XM                                                          !P
XM  =P!P<>'W   .. #X!P'P  #@< #P/^?_'X <'\'X!@#X/@#@'P '  < #@
XM/_\/_\#\_P?_? #\^/'\!P^'?_]O\##X? #P^'?\'\'\!@'<\/#X/_!^ .?@
XM      '_;\'\'W#\'P/_??'\ .^?'\__??'X?X'_? /\!\'W!P'<^?!P?_ >
XM!P/                                                         
XM                                    !P                      
XM      !P        #_                  !P            'X        
XM                                  ,'    ,.          <  '    
XM          !@    !P                                          
XM                                                    !P      
XM                      !P                            !P      
XM      ,]                          __              8#    ..  
XM        <  '              #@    !P                          
XM                                                            
XM        #@                            #@                    
XM        !@             ?                          __        
XM      8#    /,          <  '              #     !P          
XM                                                            
XM                        '                             '     
XM                        /                                   
XM                      ?^    'X          <  '              ? 
XM    !P                                                      
XM                                        &                   
XM          &                             .                   
XM                                      /\    #P          ^  /
X5              >     !P      
X 
Xend
END_OF_FILE
# end of 'font-32/Ugal12x20b'
fi
if test -f 'font-32/Ugal12x20r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-32/Ugal12x20r'\"
else
echo shar: Extracting \"'font-32/Ugal12x20r'\" \(5330 characters\)
sed "s/^X//" >'font-32/Ugal12x20r' <<'END_OF_FILE'
Xbegin 644 gal12x20r.fnt
XM& P4!8                                                      
XM              !@&8 S!@.&!P#  ,,            &!P @'P#X 8#\!P'^
XM#P#X          #P                                            
XM          !\8 ? !    0  (    &   X  $     8 '@              
XM               <!@.                                         
XM                              !@&8 S'X1,#X'@ 8&            ,
XM#X!@/X'\ X#\# /^$8$<          'X  !@_P#\_P?\?\#\\/'X'X\.> X'
XMP'#P?X#P_P'^?^\'X._O\'\'/^!\8 ? #@   P  8    .  !,  , !@ ,X 
XM!@                             P!@#                         
XM                                              !@&8 S/\1,&,'@
XM X'            ,$8#@8<(. X$ & 8$,,(.          .<  !@8($&8<,$
XM,$$&8&!@!@88, 8.8"$<,,$<88,&1B8"8$9B8"8"(,!@, # &P  !@  X   
XM &  !,  < !@ ,8 !@              !              P!@#         
XM                                                            
XM  !@&8!F9N18&,!@ P#            8$,'@0,0&!8$ ,  $,,8&        
XM  (,#X"P8,("8,,$,$("8&!@!@8P, <.<"(,,&(,8,8"!@8",(9B,$,$ ,!@
XM, # ,8  !@  8    &  #   ,     8 !@              !           
XM   8!@&                                                     
XM                  !@&8'_9F.8&,!@!P#@#P         8,,-@ , &!8( 
XM,  ,,,8&           ,/\"P8,( 8&, , ( 8&!@!@9@, <.>"(&,&(&8,8"
XM!@8",(9B.(&( 8!@& # 8,  !X  8    &  #   ,     8 !@          
XM    #              8!@&                                     
XM                                  !@&8'_9@ P#X# !@!@!@!@    
XM   P,,!@ , ."8/X8  (&(8&#    &  8  ,,&"08,8 8&, , 8 8&!@!@; 
XM, <.6"8&,&8&8,< !@8",(=B&(&( 8!@& #     !X#X9X'X#V#P# 'R-X'@
XM \8<!@W<)X#X[X#R<X'\?\>>\'_W^/\/?^ 8!@&                     
XM                                                  !@  #,/@ P
XM'@& !@!@9F!@       P,,!@ ,!\"8,<9X (#0<.'@#  <  .  88&$8888 
XM8&,(,(8 8&!@!@> , 663"8&,,8&8(/ !@8"&0=T#0#0 P!@# #      P&,
XM;\,<,>,,# ,>.<!@ ,8P!@;N><$<<<$>-,,,# ,,8"9B<$8"8. P!@#     
XM                                                            
XM      !@  #,'X!@/@$ !@!@=N!@      !@,,!@ 8#\$8 .;\ 8!@/V'@'@
XM!P?\'@ P9R$8?X8 8&/X/X8 ?^!@!@> , 661B8&-X8&?P'@!@8"&0,T!@!@
XM P!@# #       $,<.(,(.8&'X8,,,!@ ,9@!@9F,,(.8.(..,,$# ,,,$9B
XM.(,$0<!P!@#@                                                
XM                      !@  &8!\# =P  !@!@&8!@      # ,,!@ P .
XM$8 &<. 0"P'F# '@'@?\!X!@;Z$(8,8 8&,(,(8 8&!@!@? , 661R8&, 8&
XM? !X!@8"&0-T!@!@!@!@!@#        \8&8 8&8&# 8,,,!@ ,? !@9F,,8&
XM8&8&, . # ,,,$9B'0,$ X P!@# '"                              
XM                                      !@  &8!F# 8V  !@!@  ?^
XM  ?^  # ,,!@!@ &(8 &8& 0$8 &  # >    ># ;*/\8&8 8&, , 8?8&!@
XM!@;@, 360R8&, 8&;@ <!@8"# .\"P!@!@!@ P#       ',8&8 8&?^# 8,
XM,,!@ ,> !@9F,,8&8&8&, '@# ,,&(-T#@&(!P 8!@& /F              
XM                                                      !@  ?\
XM!F&<8>  !P#@&8?^  ?^  & ,,!@#  &/^ &8& P,, ,    >    ># ;*(,
XM8&8 8&, , 8&8&!@!@9P, 3F0:8&, 8&9P .!@8"#@.X$8!@# !@ P#     
XM  ,,8&8 8&8 # ,8,,!@ ,? !@9F,,8&8&8&, !X# ,,&(.T!P&(#@ 8!@& 
XM-L                                                          
XM              ?\9F&B8<   P# =N!@    # & ,(!@& 0&?^0&8& @,, ,
XM#   '@?\!X  9^($8&( 8&, , (&8&!@!@8X, 3F0.($, ,$8X0&!@8"#@&8
XM$<!@# !@ 8#       ,,8&8 8&8 # /P,,!@ ,;@!@9F,,8&8&8&,  <# ,,
XM#0.T"X#0'  8!@& 9\                                          
XM                              ,P?\,B88   X' 9F!@#   '@, &(!@
XM,"8$ 88&<$ @,, 8'@# !P?\'@  8 0&8&,"8$,", ,&8&!@!@8<,"1&0.,$
XM, .$8<0&!@<$! &8(,!@& !@ 8#       ,,<&<$<., # 8 ,,!@ ,9P!@9F
XM,,<$8$<&, (,#",,#0&8$<#0." P!@# 0X                          
XM                                          !@  9@/X,B/^   8& 
XM!@!@'@  '@, 'P!@?^/X 8,,/X!@&(!P'@'@ <  . # , 0&8,&$88,", &&
XM8&!@!@8.,"1&0&&(, 'X8.8,!@/\! &80&!@&"!\ ,?       .<>,,,.6&&
XM# ?\,,!@ ,8X!@9F,,.(<(.., ,,#D.<!@&8(.!@<& P!@#             
XM                                                          !@
XM  9@!@8<'F   ,, #P!@'@  # 8 #@/\?^'P 8'X'P! #P/ # '@ &  8 # 
XM/^X/_X#X_@?^> #X\/'X!@\'?^Y/X##P> #@\'?X'X'X! &8X/#P/^!\ ,? 
XM      'N3X'X'G#X'@/^>>'X ,\>'X[W>>'P?P'^> /X!X'F!@&8\?!@?^ <
XM!@.                                                         
XM                                    !@                      
XM      !@        #^                  !@            'P        
XM                                  (&    (,          8  &    
XM          !     !@                                          
XM                                                    !@      
XM                      !@                            !@      
XM      (Y                          __              0"    ,,  
XM        8  &              #     !@                          
XM                                                            
XM        #                             #                     
XM        !              >                          __        
XM      0"    .(          8  &              "     !@          
XM                                                            
XM                        &                             &     
XM                        .                                   
XM                      ?\    'P          8  &              > 
XM    !@                                                      
XM                                        $                   
XM          $                             ,                   
XM                                      /X    #@          \  /
X5              <     !@      
X 
Xend
END_OF_FILE
# end of 'font-32/Ugal12x20r'
fi
if test -f 'src/fast_scroll.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/fast_scroll.c'\"
else
echo shar: Extracting \"'src/fast_scroll.c'\" \(5271 characters\)
sed "s/^X//" >'src/fast_scroll.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: fast_scroll.c,v 4.1 88/06/21 13:22:00 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/RCS/fast_scroll.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/fast_scroll.c,v $$Revision: 4.1 $";
X
X/*
X * fast scroll for 68010 assuming byte boundaries  (SAU)
X *	This code is highly machine dependent
X */
X
X#include <stdio.h>
X#include "bitmap.h"
X
X#define BYTESWIDE(x)	((x->primary->wide+7)>>3)
X
X#ifndef mc68020
X
X/* these macros rely upon the proper register assignments */
X
X#define START(x)	asm("x:	movl	d7,d0")
X#define LOOP(l)		asm("l:	movw	a3@+,a4@+"); \
X			asm("	dbf	d0,l")
X#define GOTO(x)		asm("	dbf	d5,x")
X#define SKIP()		asm("	addl	d6,a4"); \
X			asm("	addl	d6,a3")
X#define BYTE()		asm("	movb	a3@+,a4@+")
X#define ADJ(x)		asm("	subql	#x,d7")
X
Xfast_scroll(map,x,y,wide,high,delta)
Xregister BITMAP *map;					/* a5 */
Xint x,y,wide,high,delta;
X   {
X   register unsigned char *dst = (unsigned char *) 	/* a4 */
X         ((long) (map->data) + (y*BYTESWIDE(map) + (x>>3)));
X   register unsigned char *src =			/* a3 */
X         dst + (delta*BYTESWIDE(map));
X   register long count =				/* d7 */
X         (wide>>4) - 1;			/* # of shorts - 1 for inner dbf */
X   register long skip = 				/* d6 */
X         BYTESWIDE(map)-(wide>>3);	/* bytes to skip at right edge */
X   register long h = 					/* d5 */
X         high-delta-1;			/* # of lines to scroll */
X   int which = (((long) dst)&1) + ((skip&1)<<1);
X
X   switch (which) {
X      case 0:			/* skip&1 == 0 */
X	 START(C0); LOOP(LP0); SKIP(); GOTO(C0);
X         break;
X      case 1:
X         ADJ(1); START(C1); BYTE(); LOOP(LP1); BYTE(); SKIP(); GOTO(C1);
X         break;
X
X      case 2:			/* skip&1 == 1 */
X	 START(C2); LOOP(LP2); BYTE(); SKIP(); GOTO(C2);
X         break;
X      case 3:
X	 START(C3); BYTE(); LOOP(LP3); SKIP(); GOTO(C3);
X         break;
X      }
X   }
X
X/*
X * fast scroll for 68020 assuming byte boundaries  (SAU)
X *	This code is highly machine dependent
X */
X
X#else
X
X/* these macros rely upon the proper register assignments */
X
X#define START(x)	asm("x:	movl	d7,d0")
X#define LOOP(l)		asm("l:	movl	a3@+,a4@+"); \
X			asm("	dbf	d0,l")
X#define GOTO(x)		asm("	dbf	d5,x")
X#define SKIP()		asm("	addl	d6,a4"); \
X			asm("	addl	d6,a3")
X#define WORD()		asm("	movw	a3@+,a4@+")
X#define BYTE()		asm("	movb	a3@+,a4@+")
X#define ADJ(x)		asm("	subql	#x,d7")
X
Xfast_scroll(map,x,y,wide,high,delta)
Xregister BITMAP *map;					/* a5 */
Xint x,y,wide,high,delta;
X   {
X   register unsigned char *dst = (unsigned char *) 	/* a4 */
X         ((long) (map->data) + (y*BYTESWIDE(map) + (x>>3)));
X   register unsigned char *src =			/* a3 */
X         dst + (delta*BYTESWIDE(map));
X   register long count =				/* d7 */
X         (wide>>5) - 1;			/* # of longs - 1 for inner dbf */
X   register long skip = 				/* d6 */
X         BYTESWIDE(map)-(wide>>3);	/* bytes to skip at right edge */
X   register long h = 					/* d5 */
X         high-delta-1;			/* # of lines to scroll */
X   int which = (((long) dst)&3) + ((skip&3)<<2);
X
X   switch (which) {
X      case 0:			/* skip&3 == 0 */
X	 START(C0); LOOP(LP0); SKIP(); GOTO(C0);
X         break;
X      case 1:
X         ADJ(1); START(C1); BYTE(); WORD(); LOOP(LP1); BYTE(); SKIP(); GOTO(C1);
X         break;
X      case 2:
X         ADJ(1); START(C2); WORD(); LOOP(LP2); WORD(); SKIP(); GOTO(C2);
X         break;
X      case 3:
X         ADJ(1); START(C3); BYTE(); LOOP(LP3); WORD(); BYTE(); SKIP(); GOTO(C3);
X         break;
X
X      case 4:			/* skip&3 == 1 */
X	 START(C4); LOOP(LP4); WORD(); BYTE(); SKIP(); GOTO(C4);
X         break;
X      case 5:
X	 START(C5); BYTE(); WORD(); LOOP(LP5); SKIP(); GOTO(C5);
X         break;
X      case 6:
X	 START(C6); WORD(); LOOP(LP6); BYTE(); SKIP(); GOTO(C6);
X         break;
X      case 7:
X	 START(C7); BYTE(); LOOP(LP7); WORD(); SKIP(); GOTO(C7);
X         break;
X
X      case 8:			/* count%4 == 2 */
X	 START(C8); LOOP(LP8); WORD(); SKIP(); GOTO(C8);
X         break;
X      case 9:
X         ADJ(1); START(C9); BYTE(); WORD(); LOOP(LP9);
X         WORD(); BYTE(); SKIP(); GOTO(C9);
X         break;
X      case 10:
X	 START(C10); WORD(); LOOP(LP10); SKIP(); GOTO(C10);
X         break;
X      case 11:
X	 START(C11); BYTE(); LOOP(LP11); BYTE(); SKIP(); GOTO(C11);
X         break;
X
X      case 12:			/* count%4 == 3 */
X	 START(C12); LOOP(LP12); BYTE(); SKIP(); GOTO(C12);
X         break;
X      case 13:
X         ADJ(1); START(C13); BYTE(); WORD(); LOOP(LP13);
X         WORD(); SKIP(); GOTO(C13);
X         break;
X      case 14:
X         ADJ(1); START(C14); WORD(); LOOP(LP14); WORD();
X         BYTE(); SKIP(); GOTO(C14);
X         break;
X      case 15:
X	 START(C15); BYTE(); LOOP(LP15); SKIP(); GOTO(C15);
X         break;
X      }
X   }
X
X/* normal bit-blit version of the above (for testing) */
X
XFast_scroll(map,x,y,wide,high,delta)
Xregister BITMAP *map;					/* a5 */
Xint x,y,wide,high,delta;
X   {
X   bit_blit(map,x&7,y,wide&7,high,
X            BIT_SRC,map,x&7,delta);
X   }
X#endif
END_OF_FILE
# end of 'src/fast_scroll.c'
fi
if test -f 'src/get_text.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/get_text.c'\"
else
echo shar: Extracting \"'src/get_text.c'\" \(5192 characters\)
sed "s/^X//" >'src/get_text.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: get_text.c,v 4.1 88/06/21 13:33:49 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/RCS/get_text.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/get_text.c,v $$Revision: 4.1 $";
X
X/* sweep out text rectangle */
X
X#include <stdio.h>
X#include "bitmap.h"
X#include "defs.h"
X#include "font.h"
X#include "event.h"
X
X#define FSIZE(c)	((int) (W(font)->head.c))
X#define THICK	2
X
X#define TOP	1
X#define MIDDLE	2
X#define BOTTOM	3
X#define ALL	4
X
Xint
Xget_text(screen,mouse,x,y,dx,dy,win,c)
XBITMAP *screen;		/* where to sweep out the box */
Xint mouse;			/* file to get mouse coords from */
Xint x,y;			/* starting position */
Xregister int *dx,*dy;		/* box width,height */
XWINDOW *win;			/* text window */
Xint c;				/* E_SWTEXT or E_SWTEXTT */
X   {
X   register int button;
X   int left,top;
X   int cols,rows;
X   int gx,gy;
X   int x_mouse, y_mouse;
X   int lastdx, lastdy;				/* previous dx,dy */
X	int newx = *dx * FSIZE(wide);
X	int newy = *dy * FSIZE(high);  
X   rectangle text;
X
X   /* set up text regions */
X
X   if (c == E_SWTEXT)				/* no text region */
X      text.x = text.y = text.wide = text.high = 0;
X   else if (!in_text(x,y,win)) {
X      button=move_mouse(screen,mouse,&mousex,&mousey,1);
X      return(0);
X      }
X   else 
X      text = W(text);
X
X   left = W(x0) + SUM_BDR + text.x;	/* edge of window (pixels) */
X   top = W(y0) + SUM_BDR + text.y;	/* top of window (pixels) */
X   cols = (text.wide ? text.wide : BIT_WIDE(W(window)))/FSIZE(wide);
X   rows = (text.wide ? text.high : BIT_HIGH(W(window)))/FSIZE(high);
X   gx = FSIZE(wide);			/* char width (pixels) */
X   gy = FSIZE(high);			/* char height (pixels) */
X
X   x = (x-left)/gx;
X   y = (y-top)/gy;
X
X   do_box(screen,x,y,dx,dy,top,left,cols,rows,gx,gy);	 /* on */
X   do {
X      button=mouse_get(mouse,&x_mouse,&y_mouse);
X      newx += x_mouse<<1;
X      newy -= y_mouse<<1;
X      lastdx = *dx, *dx = newx/gx;
X      lastdy = *dy ,*dy = newy/gy;
X      if (lastdx != *dx || lastdy != *dy) {
X         do_box(screen,x,y,&lastdx,&lastdy,top,left,cols,rows,gx,gy);	/* off*/
X         if (do_box(screen,x,y,dx,   dy,   top,left,cols,rows,gx,gy))	/* on */
X            newx = gx * *dx,  newy = gy * *dy;
X         }
X      }
X   while (button!=0);
X
X   do_box(screen,x,y,dx,dy,top,left,cols,rows,gx,gy);			/* off*/
X   return(1);
X   }
X
X/* piece boxes */
X
Xint
Xdo_box(screen,x1,y1,px,py,top,left,cols,rows,gx,gy)
XBITMAP *screen;
Xint x1,y1;		/* starting pos in rows/cols */
Xint *px,*py;		/* ending delta in rows/cols */
Xint top,left;		/* start of window in pixels */
Xint cols,rows;		/* size of window */
Xint gx,gy;		/* character size (in pixels) */
X   {
X   register int dx = *px;
X   register int dy = *py;
X
X   if (dy < 0)
X      dy = 0;
X
X   if (dy == 0 && dx < 0)
X      dx = 0;
X
X   if (x1 + dx < 0)
X      dx = -x1;
X
X   if (x1+dx > cols)
X      dx = cols-x1;
X
X   if (y1+ dy >= rows)
X      dy = rows-y1-1;
X
X   switch(dy) {
X      case 0:		/* 1 line */
X         tbox(screen, left+x1*gx-1, top+y1*gy-2,   dx*gx,       gy+3, ALL);
X         break;
X      case 1:		/* two lines */
X         tbox(screen, left+x1*gx-1, top+y1*gy-2,       (cols-x1)*gx,  gy+2, TOP);
X         tbox(screen, left-1,       top + (y1+1)*gy, (x1+dx)*gx,    gy+1, BOTTOM);
X         break;
X      default:		/* many lines */
X         tbox(screen, left+x1*gx-1, top + y1*gy-2,      (cols-x1)*gx, gy+2, TOP);
X         tbox(screen, left-1,       top + (y1+1)*gy,  cols*gx,      (dy-1)*gy, MIDDLE);
X         tbox(screen, left-1,       top + (y1+dy)*gy, (x1+dx)*gx,   gy+1, BOTTOM);
X         break;
X      }
X   if (*px != dx || *py != dy) {
X      *px = dx; *py = dy;
X      return(1);
X      }
X   else
X      return(0);
X   }
X
X/* draw a box */
X
X#define INVERT(screen,x,y,wide,high) \
X	bit_blit(screen,x,y,wide,high,BIT_NOT(BIT_DST),NULL_DATA,0,0);
X
Xstatic
Xtbox(screen,x1,y1,dx,dy,side)
XBITMAP *screen;
Xint x1,y1,dx,dy;
Xint side;
X   {
X   switch (side) {
X      case TOP:
X         INVERT(screen,x1,y1,dx,THICK);
X         INVERT(screen,x1+dx,y1,THICK, dy);
X         INVERT(screen,x1+THICK,y1+dy,dx-THICK,THICK);
X         INVERT(screen,x1,y1+THICK,THICK, dy-THICK);
X         break;
X      case MIDDLE:
X         INVERT(screen,x1+THICK,y1,dx-THICK,THICK);
X         INVERT(screen,x1+dx,y1+THICK,THICK, dy-THICK);
X         INVERT(screen,x1+THICK,y1+dy,dx-THICK,THICK);
X         INVERT(screen,x1,y1+THICK,THICK, dy-THICK);
X         break;
X      case BOTTOM:
X         INVERT(screen,x1+THICK,y1,dx-THICK,THICK);
X         INVERT(screen,x1+dx,y1+THICK,THICK, dy-THICK);
X         INVERT(screen,x1+THICK,y1+dy,dx,THICK);
X         INVERT(screen,x1,y1+THICK,THICK, dy);
X         break;
X      case ALL:
X         INVERT(screen,x1,y1,dx,THICK);
X         INVERT(screen,x1+dx,y1,THICK, dy);
X         INVERT(screen,x1+THICK,y1+dy,dx,THICK);
X         INVERT(screen,x1,y1+THICK,THICK, dy);
X         break;
X      }
X   }
END_OF_FILE
# end of 'src/get_text.c'
fi
if test -f 'src/getshell.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/getshell.c'\"
else
echo shar: Extracting \"'src/getshell.c'\" \(5305 characters\)
sed "s/^X//" >'src/getshell.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: getshell.c,v 4.1 88/06/21 13:33:51 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/RCS/getshell.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/getshell.c,v $$Revision: 4.1 $";
X
X/* start a shell */
X
X#include <sys/file.h>
X#include <sys/signal.h>
X#include <sgtty.h>
X#include <stdio.h>
X#include "bitmap.h"
X#include "defs.h"
X
X#define SHELL		"/bin/sh"
X
Xstatic char line[] = {"/dev/ptypX"};
Xstatic int  pty_index=5;		/* better hit rate than 0 */
Xextern char **environ;
X
X/*	get a pty line */
X
Xint
Xgetapty()
X   {
X   register int i;
X   int fd;
X
X   line[5] = 'p';
X   for(line[8]='p';line[8]<'r';line[8]+= 1)
X      for (i=1;i<=16;i++) {
X         line[9]="0123456789abcdef"[(pty_index+i)%16];
X         if ((fd = open(line,2)) >= 0) {
X            /* pty_index = (pty_index+i)%16;   temp */
X            line[5] = 't';
X            return(fd);
X            }
X         }
X   return(-1);
X   }
X      
Xint getatty()
X   {
X   int fd;
X   line[5]='t';
X   fd=open(line,2);
X   if (fd<0) {
X      sleep(3);
X      return (open(line,2));
X      }
X   return(fd);
X   }
X
Xchar *
Xlast_tty()
X   {
X   return(line);
X   }
X
X/******************************************************************************/
X/* start a command */
X
Xget_command(argv,file)
Xchar **argv;
Xint *file;
X   {
X   register int i;				/* counter */
X   int fd;					/* file desc */
X   int tty;					/* fd of /dev/tty */
X   int pid;					/* pid of shell */
X   int group;					/* process group id */
X   int tty_slots;				/* # of tty slots */
X   char *name, *get_path();
X   char *getenv();
X   char *shell = getenv("SHELL");
X   char *arg[2];
X   char who[MAXNAME];
X
X   if (argv == (char **) 0 ) {
X      argv = arg;
X      *argv = shell?shell:SHELL;
X      *(argv+1) = (char *) 0;
X      }
X   name = get_path(argv[0]);
X
X   if (name == (char *) 0 || *name == '\0')
X      return(-2);
X
X#ifdef DEBUG
X   dprintf(s)(stderr,"EXECING: ");
X   for(i=0;argv[i]!='\0';i++)
X      dprintf(s)(stderr,"%s ",argv[i]);
X   dprintf(s)(stderr,"\n");
X#endif
X
X   if ((*file=getapty()) < 0)
X      return(-1);
X
X   if ((pid=fork()) > 0) {
X      /* parent side of fork */
X      char buff[2];
X      read(*file,buff,sizeof(buff));	/* wait for slave side to open */
X#ifdef DEBUG
X      dprintf(s)(stderr,"EXEC done, slave side open\r\n ");
X#endif
X      return(pid);
X      }
X   else if (pid<0)
X      /* error side of fork */
X      return(pid);
X
X   /* child side of fork */
X   for(i=0;i<NSIG;i++)
X      signal( i, SIG_DFL );
X
X   /* void association with controlling terminal */
X
X#ifdef TIOCNOTTY
X   tty = open("/dev/tty",0);
X   ioctl(tty,TIOCNOTTY,0);
X   close(tty);
X#endif
X
X   /* open slave side of ptty */
X
X   if ((fd=getatty())<0) {
X      _quit("");
X      perror("Slave side of p-tty won't open");
X      exit(1);
X      }
X
X   group=getpid();
X
X#ifndef SYSV
X   tty_slots = getdtablesize();
X#else
X   tty_slots = 20;
X#endif
X
X   for(i=0;i<tty_slots;i++) if (i != fd) close(i);
X
X   /* set the uid-0 stuff up */
X
X   if (geteuid() < 1) {
X      int uid = getuid();
X      fchmod(fd,0622);
X      fchown(fd,uid,-1);
X      setreuid(uid,uid);
X
X      uid = getgid();
X      fchown(fd,-1,uid);
X      setregid(uid,uid);
X      }
X
X   i = dup(fd);
X   close(fd);
X   dup(i);
X   dup(i);
X
X   setpgrp(group,group);
X   ioctl(0,TIOCSPGRP,&group);
X
X	adjust_mode(NTTYDISC,ECHO|CRMOD|EVENP|ODDP);
X	restore_modes(0);
X
X   /* add a utmp entry */
X
X#ifdef WHO
X   add_utmp(0,sprintf(who,"%s%c",HOST,line[9]));
X#endif
X
X   /* start the command */
X
X#ifdef DEBUG
X   dprintf(s)(stderr,"execing %s (%s ...)\r\n",name,*argv);
X#endif
X
X   do_env("TERM=",TERMNAME);
X   do_env("TERMCAP=","");
X
X   write(2,"\n",1);	/* tell master that slave side is open */
X   execve(name,argv,environ);
X   _exit(1);
X   }
X
X/* half open a ptty then return */
X
Xchar *
Xhalf_open(file)
Xint *file;
X   {
X   register int i;				/* counter */
X   int pid;					/* file desc */
X
X   if ((*file=getapty()) < 0)
X      return((char *) 0);
X   ioctl(*file,TIOCREMOTE,0);	/* I dunno */
X   return(line);
X   }
X
X/* get a complete path name from command */
X
Xstatic char path[512];
Xstatic char start[512];
X
Xchar *
Xget_path(name)
Xchar *name;
X   {
X   char *getenv(), *index();
X   register char c, *next, *list;
X
X   if (index("/.",*name))
X      if (access(name,X_OK)==0)
X         return(name);
X      else
X         return((char *)0);
X
X   strcpy(start,getenv("PATH"));
X   for(list=start;next=index(list,':');list=next+1) {
X      *next = '\0';
X      sprintf(path,"%s/%s",list,name);
X      if (access(path,X_OK) == 0)
X         return(path);
X      }
X
X   sprintf(path,"%s/%s",list,name);
X   if (list && access(path,X_OK) == 0) {
X      return(path);
X      }
X   else {
X      return((char *) 0);
X      }
X   }
X
X/* change an environment variable */
X
Xdo_env(name,value)
Xchar *name, *value;
X   {
X   register int i;
X   int n = strlen(name);
X   
X   for(i=0;environ[i] != (char *) 0;i++)
X      if (strncmp(environ[i],name,n) == 0) {
X         strcpy(environ[i]+n,value);
X         break;
X         }
X   }
END_OF_FILE
# end of 'src/getshell.c'
fi
if test -f 'src/oblit/line.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/oblit/line.c'\"
else
echo shar: Extracting \"'src/oblit/line.c'\" \(5272 characters\)
sed "s/^X//" >'src/oblit/line.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: line.c,v 4.2 88/07/07 10:57:06 sau Exp $
X	$Source: /tmp/mgrsrc/src/oblit/RCS/line.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/oblit/RCS/line.c,v $$Revision: 4.2 $";
X
X/*  Draw a line 16 bit version */
X
X#include "bitmap.h"
X
Xbit_line(dest, x0, y0, x1, y1, func)
XBITMAP *dest;
Xint x0, y0, x1, y1;
Xint func;
X{
X   register int r, rincr, rdecr, d_incr, count;
X   register unsigned short bit;
X   register unsigned short *dst;
X   int temp, dx, dy;
X
X   /* clip here */
X
X#define TOP		1
X#define BOTTOM	2
X#define LEFT	4
X#define RIGHT	8
X
X#define crossings(x,y) \
X	  (x<0 ? LEFT : x>= (b->wide) ? RIGHT : 0) + \
X	  (y < 0 ? TOP : y >=  (b -> high) ? BOTTOM : 0)
X
X   {
X      register BITMAP *b = dest;
X
X      /* The classic clipping algorithm */
X
X      int Cross0 = crossings(x0, y0);
X      int Cross1 = crossings(x1, y1);
X
X      while (Cross0 || Cross1) {
X	 int Cross, x, y;
X	 if (Cross0 & Cross1)
X	    return;
X	 if (Cross0 != 0)
X	    Cross = Cross0;
X	 else
X	    Cross = Cross1;
X	 if (Cross & (LEFT | RIGHT)) {
X	    int edge = (Cross & LEFT) ? 0 : b->wide - 1;
X	    y = y0 + (y1 - y0) * (edge - x0) / (x1 - x0);
X	    x = edge;
X	 }
X	 else if (Cross & (TOP | BOTTOM)) {
X	    int edge = (Cross & TOP) ? 0 : b->high - 1;
X	    x = x0 + (x1 - x0) * (edge - y0) / (y1 - y0);
X	    y = edge;
X	 }
X	 if (Cross == Cross0) {
X	    x0 = x;
X	    y0 = y;
X	    Cross0 = crossings(x, y);
X	 }
X	 else {
X	    x1 = x;
X	    y1 = y;
X	    Cross1 = crossings(x, y);
X	 }
X      }
X      x0 += b->x0;
X      y0 += b->y0;
X      x1 += b->x0;
X      y1 += b->y0;
X   }
X
X   /* always left to right */
X
X   if (x1 < x0) {
X      temp = x1, x1 = x0, x0 = temp;
X      temp = y1, y1 = y0, y0 = temp;
X   }
X   dx = x1 - x0;
X   dy = y1 - y0;
X   if (dy > 0)
X      d_incr = BIT_LINE(dest);
X   else
X      d_incr = -(BIT_LINE(dest)), dy = -dy;
X
X   dst = (x0 >> 4) + y0 * (BIT_LINE(dest)) + (dest->data);	/*-*/
X   bit = (0x8000 >> (x0 & 15));
X
X   /* */
X
X   if (dx > dy)
X      switch (OPCODE(func)) {
X	 case OPCODE(SRC):
X	 case OPCODE(SRC | DST):
X	 case OPCODE(SRC | ~DST):
X	 case OPCODE(~0):
X	    {
X	       rincr = (dx - dy) << 1;
X	       rdecr = -(dy << 1);
X	       r = dx + rdecr;
X	       for (count = dx; count >= 0; count--) {
X		  *dst |= bit;
X		  if ((bit >>= 1) == 0) {
X		     bit = 0x8000;
X		     dst++;
X		  }
X
X		  ;
X		  if (r < 0) {
X		     dst += d_incr;
X		     r += rincr;
X		  }
X
X		  else {
X		     r += rdecr;
X		  }
X
X	       }
X
X	    }
X
X	    ;
X	    break;
X    case OPCODE(~SRC):
X    case OPCODE(~(SRC|DST)):
X    case OPCODE(DST & ~SRC):
X    case OPCODE(0):
X	    {
X	       rincr = (dx - dy) << 1;
X	       rdecr = -(dy << 1);
X	       r = dx + rdecr;
X	       for (count = dx; count >= 0; count--) {
X		  *dst &= ~bit;
X		  if ((bit >>= 1) == 0) {
X		     bit = 0x8000;
X		     dst++;
X		  }
X
X		  ;
X		  if (r < 0) {
X		     dst += d_incr;
X		     r += rincr;
X		  }
X
X		  else {
X		     r += rdecr;
X		  }
X
X	       }
X
X	    }
X
X	    ;
X	    break;
X    case OPCODE(SRC ^ DST):
X    case OPCODE(~DST):
X    case OPCODE(SRC & ~DST):
X    case OPCODE(~(SRC&DST)):
X	    {
X	       rincr = (dx - dy) << 1;
X	       rdecr = -(dy << 1);
X	       r = dx + rdecr;
X	       for (count = dx; count >= 0; count--) {
X		  *dst ^= bit;
X		  if ((bit >>= 1) == 0) {
X		     bit = 0x8000;
X		     dst++;
X		  }
X
X		  ;
X		  if (r < 0) {
X		     dst += d_incr;
X		     r += rincr;
X		  }
X
X		  else {
X		     r += rdecr;
X		  }
X
X	       }
X
X	    }
X
X	    ;
X	    break;
X      }
X
X   else
X      switch (OPCODE(func)) {
X    case OPCODE(SRC):
X    case OPCODE(SRC | DST):
X    case OPCODE(SRC | ~DST):
X    case OPCODE(~0):
X	    {
X	       rincr = (dy - dx) << 1;
X	       rdecr = -(dx << 1);
X	       r = dy + rdecr;
X	       for (count = dy; count >= 0; count--) {
X		  *dst |= bit;
X		  dst += d_incr;
X		  if (r < 0) {
X		     if ((bit >>= 1) == 0) {
X			bit = 0x8000;
X			dst++;
X		     }
X
X		     ;
X		     r += rincr;
X		  }
X
X		  else {
X		     r += rdecr;
X		  }
X
X	       }
X
X	    }
X
X	    ;
X	    break;
X    case OPCODE(~SRC):
X    case OPCODE(~(SRC|DST)):
X    case OPCODE(DST & ~SRC):
X    case OPCODE(0):
X	    {
X	       rincr = (dy - dx) << 1;
X	       rdecr = -(dx << 1);
X	       r = dy + rdecr;
X	       for (count = dy; count >= 0; count--) {
X		  *dst &= ~bit;
X		  dst += d_incr;
X		  if (r < 0) {
X		     if ((bit >>= 1) == 0) {
X			bit = 0x8000;
X			dst++;
X		     }
X
X		     ;
X		     r += rincr;
X		  }
X
X		  else {
X		     r += rdecr;
X		  }
X
X	       }
X
X	    }
X
X	    ;
X	    break;
X    case OPCODE(SRC ^ DST):
X    case OPCODE(~DST):
X    case OPCODE(SRC & ~DST):
X    case OPCODE(~(SRC&DST)):
X	    {
X	       rincr = (dy - dx) << 1;
X	       rdecr = -(dx << 1);
X	       r = dy + rdecr;
X	       for (count = dy; count >= 0; count--) {
X		  *dst ^= bit;
X		  dst += d_incr;
X		  if (r < 0) {
X		     if ((bit >>= 1) == 0) {
X			bit = 0x8000;
X			dst++;
X		     }
X
X		     ;
X		     r += rincr;
X		  }
X
X		  else {
X		     r += rdecr;
X		  }
X
X	       }
X
X	    }
X
X	    ;
X	    break;
X      }
X
X}
END_OF_FILE
# end of 'src/oblit/line.c'
fi
echo shar: End of archive 21 \(of 61\).
cp /dev/null ark21isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
