Subject:  v17i029:  MGR, Bellcore window manager, Part28/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 29
Archive-name: mgr/part28




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 28 (of 61)."
# Contents:  demo/icon/snap.c font-16/Ucmr15x25r misc/hp_raster.c
#   src/defs.h src/new_window.c src/update.c
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:33 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'demo/icon/snap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/icon/snap.c'\"
else
echo shar: Extracting \"'demo/icon/snap.c'\" \(8035 characters\)
sed "s/^X//" >'demo/icon/snap.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: snap.c,v 4.5 88/08/23 10:47:42 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/icon/RCS/snap.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/icon/RCS/snap.c,v $$Revision: 4.5 $";
X
X/* snap a piece of the screen -- only works locally */
X
X#include <signal.h>
X#include <sys/file.h>
X#include "term.h"
X#include "bitmap.h"
X#include "dump.h"
X
X#define ICON   "easel"
X#define SCREEN   "/dev/bwtwo0"
X#define min(x,y)      ((x)>(y)?(y):(x))
X#define dprintf   if(debug)fprintf
X#define PRINTER   "lp"         /* default printer name */
X#define CANCEL      10            /* time after which REVIEW is canceled */
X
Xstatic char buff[100];         /* mgr input buffer */
Xstatic char cmd[100];            /* lpr command buffer */
Xstatic char *name;               /* file name */
Xstatic char my_host[32];            /* my-host */
Xstatic char mgr_host[32];            /* mgr host */
X
Xstatic int debug=0;
Xstatic int review=0;            /* review more set */
Xstatic int func = BIT_SRC;
X
X#define MENU_COUNT      (sizeof(menu)/sizeof(struct menu_entry))
X
Xstatic struct menu_entry menu[] = {
X   "print","Print\r",
X   "file","File\r",
X   "review =>","View\r",
X   "quit","Quit\r",
X};
Xstatic struct menu_entry rop[] = {
X   "set","-Set\r",
X   "paint","-Paint\r",
X   "xor","-Xor\r",
X   "mask","-Mask\r",
X};
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   BITMAP *screen , *tmp = (BITMAP *) 0;
X   char *printer, *getenv();
X
X   FILE *fp;      /* file to write */
X   int w,h;
X   int wide,high;   /* picture size */
X   int x,y;      /* window pos */
X   int x1,y1;   /* sweep coords */
X   int xmax, ymax;      /* display size */
X   int n;
X   int snapping = 0;      /* ready to snap */
X   int format = OLD_BHDR;			/* new format */
X   int cancel(),clean();
X
X   FILE *pf;
X   
X   ckmgrterm();
X
X   debug = (int) getenv("DEBUG");
X
X   if (argc > 1 && strcmp("-n",argv[1])==0) {
X      format=NEW_BHDR;
X      argc--;
X      argv++;
X		}
X
X   if (argc != 2) {
X      fprintf(stderr,"Usage: snap [-n] <file>\n");
X      exit(1);
X      }
X
X   name = argv[1];
X
X   if ((screen = bit_open(SCREEN)) == (BITMAP *) 0) {
X      fprintf(stderr,"%s: Can't find %s\n",*argv,SCREEN);
X      exit(1);
X      }
X
X   if ((fp = fopen(name, "w")) == NULL) {
X      perror("fopen");
X      fprintf(stderr,"%s: Can't fopen %s\n",*argv,name);
X      exit(1);
X      }
X
X   if ((printer = getenv("PRINTER")) == (char *) 0)
X      printer = PRINTER;
X   sprintf(cmd,"lpr -P%s -J%s -v",printer,name);
X
X   /* setup mgr library */
X
X   m_setup(0);
X
X   get_param(mgr_host,&xmax,&ymax,0);
X   gethostname(my_host,sizeof(my_host));
X
X   if (strcmp(my_host,mgr_host) != 0) {
X      fprintf(stderr,"%s only works on host: %s\n",
X               argv[0],mgr_host);
X      exit(1);
X       }
X
X   m_push(P_FONT|P_FLAGS|P_MENU|P_POSITION);
X   m_ttyset();
X   signal(SIGALRM,cancel);
X   signal(SIGTERM,clean);
X   signal(SIGINT,clean);
X   signal(SIGHUP,clean);
X
X   m_setmode(M_NOWRAP);
X   m_setmode(M_ABS);
X   m_func(B_COPY);
X   m_bitfromfile(1,ICON);
X   m_flush();
X   m_gets(buff);
X   n = sscanf(buff,"%d %d",&w,&h);
X   if (n < 2) {
X      fprintf(stderr,"%s: Can't find %s\n",*argv,ICON);
X      clean(1);
X      }
X   setup(1,w,h);
X   m_setevent(BUTTON_1,"S%R\r");   /* get coords */
X   m_setevent(REDRAW,"Redraw\r");	/* get coords */
X   m_setevent(RESHAPE,"Reshape\r");	/* get coords */
X   menu_load(1,MENU_COUNT,menu);
X   menu_load(2,MENU_COUNT,rop);
X   m_selectmenu(1);
X   m_linkmenu(1,2,2,6);
X   m_clearmode(M_ACTIVATE);
X
X   m_flush();
X   while(m_gets(buff)) {
X      dprintf(stderr,"got %s\n",buff);
X      switch (*buff) {
X      case 'R':            /* redraw */
X         setup(1,w,h);
X         m_clearmode(M_ACTIVATE);
X         break;
X      case 'S':            /* set up to snap a picture */
X         n = sscanf(buff+1,"%d %d %d %d",&x,&y,&x1,&y1);
X         if (n < 4)
X            break;;
X         m_setmode(M_WOB);
X         wide = abs(x1-x);
X         high = abs(y1-y);
X         x = min(x,x1);
X         y = min(y,y1);
X         m_push(P_MOUSE);
X         if (x > 16 || y > 16)
X            m_movemouse(0,0);         /* get mouse out of the picture */
X         else 
X            m_movemouse(xmax-17,ymax-17);
X         if (review) {
X            alarm(0);
X            m_sendme("B review\r");                     /* synchronize review */
X            }
X         else {
X            m_sendme("E snap\r");                     /* synchronize snap */
X            snapping = 1;
X            if (tmp) {
X               bit_destroy(tmp);
X               tmp = NULL;
X               }
X            tmp = bit_alloc(wide,high,BIT_NULL,1);
X            }
X         break;
X      case 'B':               /* review the picture */
X         if (review && tmp && !snapping) {
X            review = 0;
X            if (wide < 20 && high < 20) {
X               wide = BIT_WIDE(tmp);
X               high = BIT_HIGH(tmp);
X               }
X            bit_blit(screen,x,y,wide,high,func,tmp,0,0);
X            dprintf(stderr,"review %d,%d by %d,%d\n",x,y,wide,high);
X            m_pop();
X            }
X         m_clearmode(M_WOB);
X         m_clearmode(M_ACTIVATE);
X         break;
X      case 'E':               /* get the picture */
X         if (snapping && x!=16 && y!=16) {
X            bit_blit(tmp,0,0,wide,high,BIT_SRC,screen,x,y);
X            m_pop();
X            m_clearmode(M_WOB);
X            m_clearmode(M_ACTIVATE);
X            }
X         snapping = 0;
X         break;
X      case 'F':                  /* file it */
X         if (tmp && !snapping) {
X            fseek(fp,0L,0);
X            ftruncate(fileno(fp),0);
X	    if (!bitmapwrite(fp,tmp,format) ) {
X               m_push(P_ALL);
X               m_font(0);
X               m_size(27,3);
X               m_clear();
X               m_printstr("unable to write file\n");
X               m_printstr(name);
X               m_flush();
X               sleep(3);
X               m_pop();
X               m_clearmode(M_ACTIVATE);
X               m_flush();
X               }
X            dprintf(stderr,"filing\n");
X            }
X	 fflush(fp);
X         m_clearmode(M_ACTIVATE);
X         break;
X      case 'Q':                  /* quit */
X         clean(0);
X         break;
X      case 'P':                  /* print */
X         if (tmp && !snapping && (pf = popen(cmd,"w"))) {
X				bitmapwrite(pf,tmp,format);
X            dprintf(stderr,"printing [%s]\n",cmd);
X            pclose(pf);
X            }
X         m_clearmode(M_ACTIVATE);
X         break;
X      case '-':                  /* set review mode*/
X         if (review) 
X            switch (*(buff+1)) {
X               case 'S':         /* set */
X                  func = BIT_SRC;
X                  break;
X               case 'P':         /* paint */
X                  func = BIT_SRC | BIT_DST;
X                  break;
X               case 'X':         /* XOR */
X                  func = BIT_SRC ^ BIT_DST;
X                  break;
X               case 'M':         /* MASK */
X                  func = BIT_SRC & BIT_DST;
X                  break;
X               }
X      case 'V':                  /* review */
X         if (tmp && !snapping) {
X            alarm(CANCEL);
X            review++;
X            m_setmode(M_WOB);
X            }
X         break;
X         }
X      m_flush();
X      }
X   
X   clean(0);
X   }
X
Xint clean(n)
Xint n;
X   {
X   m_ttyreset();
X   m_popall();
X   exit(n);
X   }
X
Xsetup(where,w,h)
Xint where;      /* bitmap # */
Xint w,h;         /* window size */
X   {
X   int wx,wy;	/* window position */
X
X   get_size(&wx,&wy,0,0);
X   m_shapewindow(wx,wy,w+10,h+10);
X   m_clear();
X   m_bitcopyto(0,0,w,h,0,0,0,where);
X   m_movecursor(w+20,h/2);
X   }
X
Xint
Xcancel()
X   {
X   review = 0;
X   m_putchar('\007');
X   m_clearmode(M_WOB);
X   m_flush();
X   }
END_OF_FILE
# end of 'demo/icon/snap.c'
fi
if test -f 'font-16/Ucmr15x25r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font-16/Ucmr15x25r'\"
else
echo shar: Extracting \"'font-16/Ucmr15x25r'\" \(8306 characters\)
sed "s/^X//" >'font-16/Ucmr15x25r' <<'END_OF_FILE'
Xbegin 644 cmr15x25r.fnt
XM%@\9!8  __@&    !P                  &         /           P 
XMW_^                            & &, ,&#,  , \ <  '!P        
XM       <#\ < '\ _@ P'_X'\'_\#X _@             ?@   $ _X _@_\
XM'_\__@_@P!@_  !F ,P & ,X!@_@_\ _@_\ _@?_F ,P!F ,P!B $__@#\< 
XM#\  0    $                                                  
XM                 < P#@     \__@&    'X                  /  P
XM      ?P          P W_\                            & &, ,&#,
XM!P,#N ^  . X               8'^ \ ?_#_X!P'_X?_'_\/^#_X       
XM      _P   . __#_X__'_\__C_XP!@_  !F <P ' <X!C_X__#_X__#_X?_
XMF ,P!F ,P!B $__@#\, #\  X    ,                     .       P
XM                                     P P P    !^__@&    /\  
XM        >       ?@ P      88          8!@ ,             $   
XM           & &, ,&'^#X8#' ^  , 8               X.'1L 8## 8!@
XM&  8#  <,&# 8            !PX   . P## 8P#&  P # 8P!@,  !F XP 
XM'@\\!C 8P## 8P## 8 P& ,8#& ,8## , #@# .  , !\    8         !
XM@   /   8  .  <#   P                   P                !@ P
XM 8    #F__@&    <<          _   $#\ ?@ P       ,     !P# 88!
XM@ ,             $              & &, 8,/_&,8&# >  8 ,        
XM       P<#S, P!F ,# &  P!@ 88#& ,            #@<   ? P!F ,P!
XMF  P & ,P!@,  !F!PP 'Q\\!F ,P!F ,P!F , P& ,8#& ,8## , # # & 
XM , #N    X   8     !@   ?   8  .  <#   P                   P
XM                !@ P 8    #F__@&    X,          C@& ,/_ VP P
XM       ,     '\# 88!@ ,             .  !C          & &, 8,?/
XMF,P&# .  8 ,              !P8#P, P!F ,# &  P!@ 88#& ,       
XM     # ,   ; P!F ,P!F  P & ,P!@,  !F#@P &[LV!F ,P!F ,P!F , P
XM& ,8#& ,,&!@8 & # '  , ''    \   8     !@   P   8     <#   P
XM                   P                 P P P    # __@&    P,  
XM        A@' <<'!VX P /     ,     ..# 8,#  ,             .  '
XMCP         & &,#_^;-F,P'& ,  8 ,  P           !@8#@,  !@ ,& 
XM&  P   P8#& ,              ,   ; P!F  P!F  P &  P!@,  !F' P 
XM&;,V!F ,P!F ,P!F   P& ,,&& ,,&!@8 . # #  , .#@   ^   8     !
XM@   P   8      #   P                   P                 P P
XM P    # __@&   Q@8           P#@X8!!F8 P _P    ,     <'# 8,#
XM  ,             ?  > \         & &,#_^;,#Y@#N 8  8 , !X &   
XM      #@8'@,  !@ 8& &  P   P,&& ,              ,#\ Q@P!F  P!
XMF  P &  P!@,  !F. P &.,S!F ,P!F ,P!F   P& ,,&& ,&, PP , # #@
XM , <!P   ^ ?P8     !@   P   8      #   P#       8          P
XM                 P P P    # __@& 'AA@8 P    ^!^& P!QP< #F<__
XMQF8    ,!_W_ 8## 8/_  ,!X         !@[@!X /   $ "   & &, P8?,
XM!Q@!X 0  X . PPP&         # 8/@,  #  8,,&  P  !@/># <#@    !
XM@  8   </_ Q@P!F  P!F  P &  P!@,  !F< P &$,S!F ,P!F ,P!F   P
XM& ,,&& ,&, PP 8 # !@ , X X   < _X8\ ?P#Q@?@ P >,8\ &   #!P P
XM#<X9^ ?@8\ >,8X ?P'_# ,8!C ,0 C ,?_@ P P P    ' __@& /QC P!X
XM   #P'_^ 8 [@/ #&,__S&,    ,'_W_P8## 8'^  ,'^ 0@#  !@ #!QP'@
XM #P?_F &   &    P8/, # 'P    X . XQP&         ' 8=@,  &  P,,
XM&  P  !@#X#Q\'P <  '@  >   X8#@Q@P#&  P!F  P &  P!@,  !FX P 
XM&$,QAF ,P#& ,P##   P& ,&,& ,#8 9@ X # !P ,        !@,;_!_X/]
XMA_X'_!_L;_ &  ,##@ P#]\;_!_X;_!_L;^ _X'_# ,8!C ,8!C ,?_@!@ P
XM 8    & __@& 8;#!@#,   ' &9X 8 ? #P"&$ P"&$.' ?,.   X8## 8&&
XM /\,# PP&   P &#@X>   \?_F &   &    P8'\ # /P    X . \SP&   
XM      & 8Y@,  , /@8,'_@QP # !P _L'P ^  >   '@ !PP!Q@P__&  P!
XMG_P_^&  __@,  !GP P & ,QAF ,__& ,__#_P P& ,&,& ,#X ?@ P #  P
XM ,        !@,>#!@,,'A@8'_!@\?# &  ,#'  P#&,>#A@8>#!@\?'!@, P
XM# ,<#C ,<#C , # #@ P <    & __B&$0/##@#,'_^& $8P 8 . #\ &  P
XM&&&?/@_\<   <8## 8&& /\>'A@8,   8?_G@\>   \  # ,   &   !@P#^
XM & <X    X . /_ &         . 9Q@,  8 /@8,'_XW\ # '\ .,'P ^ !X
XM#_\!X #@QXQ@P__&  P!G_P_^&  __@,  !G@ P & ,PQF ,_\& ,_\ _X P
XM& ,&,& ,#X / !@ #  X ,          ,<!C ,8#C , P# <<!@&  ,#.  P
XM#&,<!C ,<!C <<#!@, P# ,,## ,.'# , & #@ P < ' 0& __C&,P.#!X&&
XM'_^,  8P \ . /^ &  P'_^QXQ@<X   .8## 8#,  ,3,C ,8   ,?_C@X'@
XM #P  # ,   &   !@P#/ & X<    X . '^ &         , ;A@,  P  PP,
XM  8^/ & >/  ,#@ ^ '@#_\ > ' S^Q@PP#&  P!F  P &!\P!@,  !GP P 
XM& ,PQF ,P & ,P&  8 P& ,#8&$,#8 & #@ #  8 ,          \8!C  8!
XMC , P# ,8!@&  ,#<  P#&,8!C ,8!C ,8 !@  P# ,.'# ,'.# , , !@ P
XM 8 /@0& __CF<P&' <&&  &,  PP!\ . <' &  P'_^PPS ,P   &8## 8#,
XM  ,QXW_^__W_^ 8!QP!X / ?_A@8   &   !@P#/@, X<P   X . #\'_^  
XM#_\   < ?!@, !@  8P,  ,X# & 8#  ,   < >     '@. S&S_XP!F  P!
XMF  P &!\P!@,  !FX P & ,P9F ,P & ,P&  , P& ,#8&$,&, & #  #  <
XM ,         /\8!C  8!C_\ P# ,8!@&  ,#\  P#&,8!C ,8!C ,8 !_P P
XM# ,&&# ,#\# , 8  P P P ?PP& __AF8P&' .,#  &/X PP#L / P# &  P
XM&&&PPS ,P   &8## 8#,  ,PPW_^__W_^ P [@ > \ ?_A@8   &   '_\#-
XM@,XX.P   8 , '^'_^  #_\   8 >!@, #   8__@ ,P!@, P!@ ,     > 
XM    '@, S&S_XP!F  P!F  P & ,P!@,  !F< P & ,P9F ,P & ,P#  , P
XM& ,#8&.,&, & &  #  , ,        !_,8!C  8!C_\ P# ,8!@&  ,#^  P
XM#&,8!C ,8!C ,8  _X P# ,'.# ,!X# , P  P P P 9Y@. __AVXP&' .,#
XM  &,  PP'& + P# &  P"&$PPS ,P   &8## 8!X  ,QXS ,8   ,?_@?  '
XMCP    PP       '_\;-@9\X.P   8 , /_ &         X <!@, &   ,__
XM@ ,P!@, P!@ ,     '@#_\ > , S_C 8P!F  P!F  P & ,P!@,  !F. P 
XM& ,P-F ,P & ,P#  , P& ,!P&?,,& & .  #  . ,        #@,8!C  8!
XMC   P# ,8!@&  ,#G  P#&,8!C ,8!C ,8   , P# ,#,#&,#\# ,!@  P P
XM P P_@, __@VPP.' .8!@ &,  P8.& + P# &   #&,QXS ,X   .8## 8!X
XM  ,3,A@8,   8?_@.  !C     PP       #!@?/@;&X'@   8 , \SP&   
XM   #@ P \!@, , & , ,& ,P!@8 P!F ,#@   !X#_\!X   Q_# 8P!F ,P!
XMF  P & ,P!@, P!F' P & ,P-F ,P &!LP#& , P& ,!P&[L,& & ,  #  &
XM ,        # ,8!C  8!C   P# ,8!@&  ,##@ P#&,8!C ,8!C ,8   , P
XM# ,#\#/,'.# ,#   P P P @? , __@?@0/' .8!@  & !@8<# + X' &   
XM!F8?/C 8<   <8##@X!X  ,>'@PP&   P&  .      ?_@9@       #!@/_
XM S&<'@   8 , XQP& #@   'P!P \#@, 8 & , ,& ,P!@8 P!F ,'P <  >
XM   '@   X ' <P!F ,P!F  P & ,P!@, P!F#@P & ,P'F ,P &!\P#& , P
XM& ,!P'Q\8# & 8  #  ' ,        # <<!C ,8#C , P# <8!@&  ,#!P P
XM#&,8!C ,<!C <8 !@, P# <!X#9L.'# <&  !@ P 8 @. , __@?@8;'P<P 
XMP  ' !@88# / >. & __P_P.'!AP.   X8#!QP P  ,,# 0@#  !@,  $   
XM   ?_@9@   &   &# '^ S&>/P   , 8 PPP& 'P   'P!@ N' , P # 8 ,
XM# 88# P 8## 8'P ^  '@  >  . <!V ,P## 8P#&  P # 8P!@, 8#&!PP 
XM& ,P'C 8P # XP## 8 P# 8 @'@\8# & X  #  # ,        # \>#!@,,'
XMA@, P!@\8!@&  ,# X P#&,8!C ,>#!@\8 !@, P!A\!X#P\<#AA\,  !@ P
XM 8    , __@/ /QW_XP P  #P!@,P!@& ?^ & __P/   !_@'_W_P8# _@ P
XM'_\'^        8  $ ?_C_\   /    &   &# #,!A\/\P   . X !X & 'P
XM   'P#@ '^#_P__C_X ,#_X?_ P ?_#_X'P ^  !@  8  . /_F ,__#_X__
XM'_\P #_XP!@_ ?_& X__F ,P#C_XP #_\P!C_X P#_X @' <P!@& __@#\ #
XMC\        !_L;_!_X/]A_X P!_L8!@&  ,# < P#&,8!A@8;_!_L8  _X ?
XM!_L P#@<8!A_L?_@ P P P    , __@& '@6?P@ 0   ^!@,P!P  'X &   
XM      ? !_W_ 8# .  P'_^!X             ?_C_\   &    &   &# #,
XM!@X#X    '!P  P & #P   #@#  #\#_P__@_@ , _@'\ P '\ _@#@ >   
XM      . #^& ,_X _@_\'_\P  _@P!@_ '\& 8__F ,P#@_@P  _NP!@_@ P
XM _@ @& ,P!@& __@#\ !C\         _,8\ ?P#Q@?P P >,8!@&  ,# , P
XM#&,8!A_X8\ >,8  ?P / >, P# ,0 @>,?_@ < P#@    , __@    &    
XM                                                            
XM                                      !P                    
XM                .                                           
XM            &                                               
XM       ,      ,           _@8   ,                   ,      P
XM     &8 __@    &                                            
XM                                                          !@
XM                                    ,                       
XM                                                            
XM                           ,      ,             8   ,       
XM            ,      P     &8 __@    &                        
XM                                                            
XM                  #                                     8   
XM                                                            
XM                         '__@                !@8      ,     
XM        8   ,                 !@8      P     &8 __@    &    
XM                                                            
XM                                      "                     
XM                0                                           
XM                                             '__@           
XM     !_X     #X             8   ,                 !_X      P
XM     #X __@    &                                            
XM                                                            
XM                                                            
XM                                                            
XM                          _@     #P             8   ,       
X5           _@      P     !P 
X 
Xend
END_OF_FILE
# end of 'font-16/Ucmr15x25r'
fi
if test -f 'misc/hp_raster.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/hp_raster.c'\"
else
echo shar: Extracting \"'misc/hp_raster.c'\" \(8273 characters\)
sed "s/^X//" >'misc/hp_raster.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/* Raster print filter for hp laser printer */
X
X/***********************************************************************
X * $Header: hp_raster.c,v 1.3 88/07/15 14:34:13 sau Exp $
X * $Locker:  $
X * $Source: /tmp/mgrsrc/misc/RCS/hp_raster.c,v $
X * $Log:	hp_raster.c,v $
X * Revision 1.3  88/07/15  14:34:13  sau
X * Add new bitmap format (handles both formats now )
X * 
X * Revision 1.1  88/07/15  14:32:21  sau
X * Initial revision
X * 
X * Revision 1.2  88/07/08  08:25:43  sau
X * 
X * 
X * Revision 1.1  88/07/08  08:16:57  sau
X * Initial revision
X * 
X * Revision 1.1  88/07/08  08:14:22  sau
X * Initial revision
X * 
X * Revision 1.5  87/07/14  20:10:40  sau
X * Eliminate training white space on a line by line basis
X * 
X * Revision 1.4  87/06/25  11:03:29  sau
X * Auto scaling, lpr version
X * 
X ***********************************************************************/
X
X/* avoid complaints from "lint" */
X
X#ifndef lint
Xstatic char     RCS_Id[] = "$Header: hp_raster.c,v 1.3 88/07/15 14:34:13 sau Exp $";
X#endif
X#include <stdio.h>
X#include "dump.h"
X
X#define GET_OPT(i)	\
X	strlen(argv[i])>2 ? argv[i]+2 : argv[++i]
X#define WIDTH16(w)	((((w)+15)&~0xf)>>3)		/* old bitmap format */
X#define WIDTH8(w)	((w)>>3)							/* new bitmap format */
X#define Min(x,y)	((x)<(y)?(x):(y))
X
X#define DOTS_WIDE	(8*300)		/* dots across page */
X#define DOTS_HIGH	(10*300+150)	/* dots down page */
X#define WIDE		1152		/* default # pixels/row */
X#define HIGH		900		/* default # rows/screen */
X#define HI_RES		300		/* dots per inch */
X#define MED_RES		150		/* dots per inch */
X#define LOW_RES		100		/* dots per inch */
X#define MIN_RES		75		/* dots per inch */
X#define MAX		4000		/* maximum row size */
X#define BORDER		3		/* default size of border */
X#define STRIP		3		/* white strip for viewgrqaphs */
X
X/* printer macros */
X
X#define set_pos(xp,yp) \
X	printf("\033*p%dy%dX",yp,xp)	/* set cursor position (dots) */
X#define set_res(res) \
X	printf("\033*t%dR",res)		/* set dots/inch */
X#define reset() \
X	printf("\033E")			/* reset the printer */
X#define manual_feed() \
X	printf("\033&l2H")		/* select manual feed */
X#define start_graphics() \
X	printf("\033*r1A")		/* set raster mode */
X#define set_row(wide) \
X	(printf("\033*b%dW",wide), fflush(stdout))
X#define end_graphics() \
X	printf("\033*rB")		/* end graphics mode */
X#define set_copies(n) \
X	printf("\033&l%dX",Min(n,99))	/* set copy count */
X#define set_rule(w,h) \
X	printf("\033*c%da%dB",w,h)	/* set rule size */
X#define print_rule(type) \
X	printf("\033*c%dP",type)	/* print 'type' rule */
X
Xunion {
X	struct b_header new;
X	struct old_b_header old;
X	char type[2];
X	} h_buff, *head = &h_buff;
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   register int k,i,j=0;
X   int n;				/* last non-white space */
X   unsigned char buff[MAX/8];		/* graphics line buffer */
X   int wide = WIDE, high = HIGH;	/* raster size */
X   int no_head=0;			/* no raster header found */
X   int reverse=0;			/* reverse bits */
X   int pause = 0;			/* for vgrafs */
X   int manual = 0;			/* select manual feed */
X   int copies = 0;			/* set copy count */
X   int border = 0;			/* draw border around picture */
X   int res = MED_RES;			/* resolution dots/in */
X   int force_res=0;			/* force resolution */
X   int x0,y0;				/* starting raster coord */
X   int x=0,y=0;					/* user supplied coords */
X   int bytes;				/* raster line size */
X	int depth=1;			/* bitmap depth */
X	char type[2];			/* bitmap type */
X
X   /* check arguments */
X
X   for(i=1;i<argc;i++) {
X      if (*argv[i] == '-')
X         switch (argv[i][1]) {
X            case 'X':				/* x coord */
X               x = atoi(GET_OPT(i));
X               break;
X            case 'Y':				/* y coord */
X               y = atoi(GET_OPT(i));
X               break;
X            case 'r':				/* reverse bits */
X               force_res = atoi(GET_OPT(i));
X               break;
X            case 'm':				/* set manual feed */
X               manual++;
X               break;
X            case 'n':				/* login (from lpd )*/
X               GET_OPT(i);
X               break;
X            case 'h':				/*  host (from lpd) */
X               GET_OPT(i);
X               break;
X            case 'y':				/* specify border- for lpd */
X               border = Min(32,atoi(GET_OPT(i)));
X               break;
X            case 'b':				/* set border size */
X               if (argv[i][2])
X                  border = atoi(&argv[i][2]);
X               else
X                  border = BORDER;
X               break;
X            case 'c':				/* set copies */
X               copies = atoi(GET_OPT(i));
X               break;
X            case 'p':				/* set pause */
X            case 'x':				/* for lpd */
X               pause = atoi(GET_OPT(i));
X               break;
X            default:
X               fprintf(stderr,"%s: bad flag %c ignored\n",argv[0],argv[i][1]);
X            }
X      }
X
X   /* get header */
X
X   if (!no_head) {
X      read(0,head->type,2);				/* get magic number */
X      if (B_ISHDR16(&head->old)) {		/* old style header */
X         read(0,head->type+2,B_OHSIZE-2);
X         B_GETOLDHDR(&head->old,wide,high);
X   		bytes = WIDTH16(wide);
X			}
X		else if (B_ISHDR8(&head->new)) {		/* new style header */
X         read(0,head->type+2,B_HSIZE-2);
X         B_GETHDR8(&head->new,wide,high,depth);
X   		bytes = WIDTH8(wide);
X			}
X      else {		/* assume 16 bit alignment , no header */
X         wide=WIDE,high=HIGH-1;
X         Read(0,buff,WIDTH16(wide)-2);		/* oops ! lose 1st line */
X   		bytes = WIDTH16(wide);
X         }
X      }
X
X	if (depth != 1) {
X		fprintf(stderr,"Sorry, Can\'t handle 8-bit pixels\n");
X		exit(0);
X		}
X
X   /* compute appropriate resolution */
X
X   switch(Min(DOTS_WIDE/(border+wide),DOTS_HIGH/(border+high))) {
X      case 0:		/* picture too big, use hi-res and go */
X         /* no break - for now */
X      case 1:
X         res = HI_RES;
X         break;
X      case 2:
X         res = MED_RES;
X         break;
X      case 3:
X         res = LOW_RES;
X         break;
X      default:
X         res = MIN_RES;
X         break;
X      }
X
X   if (force_res)
X      res = force_res;
X
X   /* center picture */
X
X   if (pause>1) 			/* skip white strip for viewgraphs */
X      x0 = (DOTS_WIDE-HI_RES*wide/res);
X   else
X      x0 = (DOTS_WIDE-HI_RES*wide/res)/2;
X   y0 = (DOTS_HIGH-HI_RES*high/res)/2;
X
X   if (x>0)
X      x0 = x;
X   if (y>0)
X      y0 = y;
X
X   fprintf(stderr,"printing raster %dx%d at %d,%d - %d dots/in%s\n",
X            wide,high,x0,y0,res,border ? " (bordered)":"");
X
X   /* setup printer */
X
X   reset();					/* reset the printer */
X   if (pause || manual) 
X		manual_feed();				/* select manual feed */
X   if (copies)
X		set_copies(copies);			/* set copy count */
X   set_pos(x0,y0);				/* set starting position */
X   set_res(res);				/* set resolution */
X   start_graphics();				/* start graphics */
X
X   for (i=0;i<high;i++) {
X      Read(0,buff,bytes);
X      for(j=bytes;j>0 && buff[j-1]==0;j--); 
X      set_row(j);
X      write(1,buff,j);
X      }
X   end_graphics();
X
X   /* draw borders */
X
X   if (border) {
X      set_rule(border,2*border+high*HI_RES/res);
X      set_pos(x0-border,y0-border);
X      print_rule(0);				/* left edge */
X      set_pos(x0+wide*HI_RES/res,y0-border);
X      print_rule(0);				/* right edge */
X
X      set_rule(wide*HI_RES/res,border);
X      set_pos(x0,y0-border);
X      print_rule(0);				/* top edge */
X      set_pos(x0,y0+high*HI_RES/res);
X      print_rule(0);				/* bottom edge */
X      }
X
X   printf("\n\f");
X   exit(0);
X   }
X
X/* do multiple passes for read */
X
XRead(fd,buff,count)
Xint fd,count;
Xregister char *buff;
X   {
X   register int sum=0,current=0;
X
X   while((current = read(0,buff+sum,count-sum))>0)
X      sum += current;
X   return(sum);
X   }
X
X/* return index of 1st non zero byte, or bytes if entirely blank */
X
Xint
Xfirst(buff,bytes)
Xregister char *buff;
Xregister int bytes;
X   {
X   char *start = buff+1;
X   while(bytes-- > 0)
X      if (*buff++) 
X         break;
X   return(buff-start);
X   }
END_OF_FILE
# end of 'misc/hp_raster.c'
fi
if test -f 'src/defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/defs.h'\"
else
echo shar: Extracting \"'src/defs.h'\" \(8116 characters\)
sed "s/^X//" >'src/defs.h' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: defs.h,v 4.2 88/08/12 07:40:25 sau Exp $
X	$Source: /tmp/mgrsrc/src/RCS/defs.h,v $
X*/
Xstatic char	h_defs_[] = "$Source: /tmp/mgrsrc/src/RCS/defs.h,v $$Revision: 4.2 $";
X
X/* defines for mgr */
X
X/* configurable parameters */
X#include "defines.h"
X
X#ifdef SYSV
X#define index		strchr
X#define rindex		strrchr
X#endif
X
X#ifdef DEBUG
Xextern char debug_level[];
Xchar *index();
X#define dprintf(x) \
X	if (debug && index(debug_level,'x')) fprintf
X#endif
X
X/* macros -- for speed */
X
X#ifdef FASTMOUSE
X#define MoUSE(a,b)     bit_blit(screen, a, b, 16,16, \
X                               BIT_SRC^BIT_DST, m_rop,0,0)
X#define MOUSE_ON(a,b)	(!mouse_on && (mouse_on=1, MoUSE(a,b)) )
X#define MOUSE_OFF(a,b)	( mouse_on && (mouse_on=0, MoUSE(a,b)) )
X#else
X/* turn on the mouse only if it is off */
X#define MOUSE_ON(a,b)     (!mouse_on && ( \
X				  mouse_on=1, \
X			          bit_blit(&mouse_save,0,0,16,16, \
X					BIT_SRC,screen,a,b), \
X				  bit_blit(screen,a,b,16,16, \
X					BIT_SRC|BIT_DST,m_rop,0,0), \
X				  bit_blit(screen,a,b,16,16, \
X				      BIT_NOT(BIT_SRC)&BIT_DST,m_rop,0,16) \
X				  ))
X/* turn off the mouse only if it is on */
X#define MOUSE_OFF(a,b)     (mouse_on && ( \
X			          mouse_on=0, \
X			          bit_blit(screen,a,b,16,16, \
X					BIT_SRC,&mouse_save,0,0) \
X			          ))
X#endif
X
X#define CLEAR(s,op)	bit_blit((s),0,0,BIT_WIDE(s),BIT_HIGH(s), \
X			op,0,0,0);
X
X#define ACTIVE_ON() \
X			border(active,SUM_BDR-1,1), \
X			last_active = active!=last_active ? \
X			  ( \
X			  do_event(EVENT_DEACTIVATED,last_active,E_MAIN), \
X			  do_event(EVENT_ACTIVATED,active,E_MAIN), \
X			  active ) \
X			: \
X			  last_active
X 			  	
X#define ACTIVE_OFF() \
X			border(active,BLK_BDR,WH_BDR)
X
X#define SETMOUSEICON(x)	(m_rop = x)
X
X/* short hand */
X
X#define W(x)		(win->x)
X#define BETWEEN(a,x,b)	(x)<(a)?a:((x)>(b)?b:x)
X#define ACTIVE(x)	(active->x)
X#define ABS(x)		((x)>0 ? (x) : -(x))
X
X/* mouse buttons */
X
X#define BUTTON_SYS	4		/* system menu */
X#define BUTTON_2	2		/* middle button (unused) */
X#define BUTTON_1	1		/* right button (vi?) */
X
X/* Window table flags */
X
X#define W_ACTIVE	0x000001L	/* Window is non_occluded */
X#define W_ESCAPE	0x000002L	/* An escape sequence is in progress */
X#define W_STOPPED	0x000004L	/* Window is stopped ( unused ) */
X#define W_REVERSE	0x000008L	/* window is white on black */
X#define W_STANDOUT	0x000010L	/* window is in standout mode */
X#define W_DIED		0x000020L	/* window has died */
X#define W_EXPOSE	0x000040L	/* expose window upon shell output */
X#define W_BACKGROUND	0x000080L	/* permit obscured window to update */
X#define W_NOKILL	0x000100L	/* don't kill window upon exit */
X#define W_VI		0x000200L	/* temporary vi hack -- */
X#define W_TEXT		0x000400L	/* downloading text */
X#define W_NOINPUT	0x000800L	/* don't accept keyboard input */
X#define W_NOWRAP	0x001000L	/* don't auto wrap */
X#define W_OVER		0x002000L	/* overstrike mode */
X#define W_ABSCOORDS	0x004000L	/* use absolute coordinates */
X#define W_MINUS		0x008000L	/* negative coord value */
X#define W_SNARFABLE	0x000004L	/* ok to gather data into cut buffer */
X#define W_SNARFLINES	0x010000L	/* snarf only lines */
X#define W_SNARFTABS	0x020000L	/* change spaces to tabs in snarf */
X#define W_SNARFHARD	0x040000L	/* snarf even if errors */
X#define W_SNARFLAGS	(W_SNARFTABS | W_SNARFHARD | W_SNARFLINES)
X#define W_INHERIT	0x080000L	/* inherit menus and bitmaps */
X#define W_DUPKEY	0x100000L	/* duplicate key mode */
X#define W_NOBUCKEY	0x200000L	/* Buckey keys (i.e. "Left-<char>" and
X					"Right-<char>") have no effect */
X#define W_CLIPDONE	0x400000L	/* clip list for background update valid
X					*/
X
X#define W_LOOK \
X	(W_EXPOSE | W_BACKGROUND)	/* Window ready to accept data */
X
X#define W_STATE \
X	(W_ESCAPE | W_TEXT)		/* terminal emulator states */
X
X#ifdef CUT
X#define W_SAVE \
X	(W_REVERSE | W_STANDOUT | W_EXPOSE | W_BACKGROUND | \
X	 W_VI | W_NOINPUT | W_NOWRAP | \
X	 W_SNARFLAGS | \
X	 W_OVER | W_ABSCOORDS)		/* savable flags */
X#else
X#define W_SAVE \
X	(W_REVERSE | W_STANDOUT | W_EXPOSE | W_BACKGROUND | \
X	 W_VI | W_NOINPUT | W_NOWRAP | \
X	 W_OVER | W_ABSCOORDS)		/* savable flags */
X#endif
X
X#define INIT_FLAGS	W_BACKGROUND	/* default window creation flags */
X
X/* Structure definitions */
X
Xtypedef struct {	/* used for text regions */
X  int x,y,wide,high;
X  } rectangle;
X
Xtypedef struct  {	/* some day */
X  int x,y;
X  } point;
X
Xtypedef struct window {		/* primary window structure */
X  struct window *next;	/* next window */
X  struct window *prev;	/* previous window */
X  struct window *stack;	/* stack of saved window environments */
X  struct window *main;	/* main window (or 0 if main window ) */
X  struct window *alt;	/* alternate window ( 0 if none) */
X  BITMAP *border;	/* window + border */
X  BITMAP *window;	/* This is the window */
X  BITMAP *save;		/* pointer to window bit-image if inactive */
X  BITMAP *bitmap;	/* for use when downloading bitmaps */
X  BITMAP *bitmaps[MAXBITMAPS];	/* scratchpad space */
X  BITMAP *cursor;	/* bitmap of cursor (future; unused just now) */
X  struct font *font;	/* this is the font */
X  char *clip_list;	/* pointer to clip list for BG updates */
X
X  rectangle text;	/* location of text region within window */
X  int x0,y0;		/* origin of window on screen */
X  int x,y;		/* cursor character position */
X  int gx,gy;		/* graphics cursor */
X  int op;		/* raster op function (see bitmap.h)  */
X  int style;		/* character style normal/inverse video */
X  int background;	/* background color WOB or BOW */
X  int curs_type;	/* cursor type */
X
X  int esc_cnt;		/* # of escape digits entered */
X  int esc[MAXESC];	/* escape array (as in ESCnn,nnm) */
X  int code;		/* code for text function */
X  char dup;		/* char to duplicate from keyboard */
X
X  struct menu_state *menus[MAXMENU];	/* menus */
X  short menu[2];	/* index into menus for current button 1&2 menu */
X  long event_mask;	/* event mask  (see event.h) */
X  char *events[MAXEVENTS];	/* place for event strings */
X  char *snarf;			/* temporary snarf buffer */
X
X  unsigned long flags;		/* misc. window flags (see defines above) */
X
X  char buff[MAXSHELL];	/* shell input buffer */
X  int  max;		/* the # of chars in buff */
X  int  current;		/* the current char in buff */
X  int  to_fd;		/* file descriptor to shell */
X  int  from_fd;		/* file descriptor from shell */
X  int  pid;		/* process number of the shell */
X  int  setid;		/* window set id, 1..N, one per pid */
X  int  num;		/* window number ( for multiple window/proc) */
X			/* The window set id and the window number together
X			uniquely identify a window. */
X
X  char tty[MAXTTY];	/* name of shell's tty */
X  } WINDOW;
X
Xtypedef int (*function)();
Xint new_window(), move_window(), destroy_window(), quit();
Xint redraw();
Xint sig_child(), catch();
X
X/* static data items (described in data.c) */
X
Xextern short c_arrow1[];
Xextern short c_box[];
Xextern short pat_data[];
Xextern char *full_menu[];
Xextern char *main_menu[];
Xextern char *active_menu[];
Xextern char *test_menu[];
Xchar *quit_menu[];
Xextern function full_functions[];
Xextern function main_functions[];
Xextern function active_functions[];
X
Xextern BITMAP *m_rop;
Xextern int next_window;
Xextern BITMAP pattern, mouse_box, mouse_arrow, mouse_cup, mouse_cross,mouse_cut;
Xextern BITMAP mouse_save, mouse_not;
Xextern struct font *font;
Xextern BITMAP *screen;
Xextern int mask;
Xextern int poll;
Xextern int rev_ops[];
Xextern WINDOW *active;
Xextern WINDOW *last_active;
Xextern int button_state;
Xextern mouse, mousex, mousey, mouse_on;
Xextern int debug;
Xextern char *fontlist[], *font_dir;
Xextern char *icon_dir;
Xextern char *snarf;
Xextern char *message;
Xextern char *start_command;
Xextern char *init_command;
Xextern int id_message;
Xextern short buckey_map;
Xextern unsigned int init_flags;
Xextern char *version[];
END_OF_FILE
# end of 'src/defs.h'
fi
if test -f 'src/new_window.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/new_window.c'\"
else
echo shar: Extracting \"'src/new_window.c'\" \(7968 characters\)
sed "s/^X//" >'src/new_window.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: new_window.c,v 4.2 88/08/12 07:41:02 sau Exp $
X	$Source: /tmp/mgrsrc/src/RCS/new_window.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/new_window.c,v $$Revision: 4.2 $";
X
X/* Create a new window */
X
X#include "bitmap.h"
X#include <fcntl.h>
X#include <stdio.h>
X#include "defs.h"
X#include "window.h"
X#include "font.h"
X#include "menu.h"
X
X/* sweep out a new window */
X
Xint new_window()
X   {
X   register WINDOW *win;
X   int dx=16,dy=16;
X   char *malloc();
X   WINDOW * insert_win();
X
X   if (next_window >= MAXWIN)
X       return(-1);
X   SETMOUSEICON(&mouse_box);
X   move_mouse(screen,mouse,&mousex,&mousey,0);
X   SETMOUSEICON(&mouse_arrow);
X   get_rect(screen,mouse,mousex,mousey,&dx,&dy,0);
X   do_button(0);
X
X   return( create_window( mousex, mousey, dx, dy, -1, 0 ) );
X   }
X
X/* insert a new window into the window list */
X
XWINDOW *
Xinsert_win(win)
XWINDOW *win;
X   {
X   char *malloc();
X
X   if (win == (WINDOW *) 0 &&
X           (win = (WINDOW *) malloc(sizeof(WINDOW))) == (WINDOW *) 0) {
X      if( debug )
X	 fprintf(stderr,"Can't malloc window space\n");
X      return(win);
X      }
X
X   if (active) {
X      W(prev) = ACTIVE(prev);
X      ACTIVE(prev) = win;
X      W(next) = active;
X      }
X   else {
X      W(prev) = win;
X      W(next) = (WINDOW *) 0;
X      }
X   return(win);
X   }
X
X/* create a new window given coords */
X
Xint
Xcreate_window(x,y,dx,dy,font_num,argv)
Xint x,y,dx,dy;
Xint font_num;
Xchar **argv;
X   {
X   register WINDOW * win;
X   WINDOW * insert_win();
X
X   if (next_window >= MAXWIN)
X       return(-1);
X   if (check_window(x,y,dx,dy,font_num) == 0)
X      return(-1);
X
X   /* alloc window space */
X
X   if ((win = (WINDOW *) malloc(sizeof(WINDOW))) == (WINDOW *) 0) {
X      fprintf(stderr,"Can't malloc window space\n");
X      return(-1);
X      }
X      
X   if ((W(pid) = get_command(argv,&W(from_fd))) < 0) {
X      free(win);
X      fprintf(stderr,"Can't get a pty\n");
X      return(-1);
X      }
X   W(to_fd) = W(from_fd);
X   W(setid) = next_windowset_id();
X
X   active = insert_win(win);
X
X   make_window(screen,x,y,dx,dy,font_num,"");
X   return(0);
X   }
X
X/* create a new window given coords , with only 1/2 a ptty */
X
Xchar *
Xhalf_window(x,y,dx,dy,font_num)
Xint x,y,dx,dy;
Xint font_num;
X   {
X   register WINDOW * win;
X   WINDOW * insert_win();
X   char *half_open();
X   char *tty;
X
X   if (next_window >= MAXWIN)
X       return(NULL);
X   if (check_window(x,y,dx,dy,font_num) == 0)
X      return(NULL);
X
X   /* alloc window space */
X
X   if ((win = (WINDOW *) malloc(sizeof(WINDOW))) == (WINDOW *) 0) {
X      fprintf(stderr,"Can't malloc window space\n");
X      return(NULL);
X      }
X      
X   if ((tty = half_open(&W(from_fd))) == NULL) {
X      free(win);
X      fprintf(stderr,"Can't get a pty\n");
X      return(NULL);
X      }
X
X   W(setid) = next_windowset_id();
X   active = insert_win(win);
X
X   W(to_fd) = W(from_fd);
X   make_window(screen,x,y,dx,dy,font_num,"");
X   W(pid) = 1;
X   W(flags) |= W_NOKILL;
X
X   return(tty);
X   }
X
X/* check window size */
X
Xint
Xcheck_window(x,y,dx,dy,fnt)
Xint x, y, dx, dy;
Xint fnt;
X   {
X   struct font *curr_font, *Get_font();
X
X   if (dx<0)
X      x += dx, dx = -dx;
X   if (dy<0)
X      y += dy, dy = -dy;
X   
X   if (x >= BIT_WIDE(screen) || y >= BIT_HIGH(screen))
X       return(0);
X
X   if (x + dx >= BIT_WIDE(screen))
X      dx = BIT_WIDE(screen)-x;
X
X   if (y + dy >= BIT_HIGH(screen))
X      dy = BIT_HIGH(screen)-y;
X
X   curr_font = Get_font(fnt);
X
X#ifdef DEBUG
X   dprintf(n)(stderr,"starting: (%d,%d)  %d x %d\r\n",x,y,dx,dy);
X#endif
X
X   if (dx < SUM_BDR + curr_font->head.wide*MIN_X +1 ||
X              dy < SUM_BDR + curr_font->head.high*MIN_Y +1)
X      return(0);
X   else
X      return(1);
X   }
X
X/* draw the window on the screen */
X
Xmake_window(screen,x,y,dx,dy,fnt,start)
XBITMAP *screen;
Xint x, y, dx, dy;
Xint fnt;
Xchar *start;
X   {
X   register WINDOW *win = active;
X   register int i;
X   struct font *curr_font, *Get_font();
X   char *last_tty();
X
X   if (dx<0)
X      x += dx, dx = -dx;
X   if (dy<0)
X      y += dy, dy = -dy;
X   
X   if (x < 0) x = 0;
X
X   if (x + dx >= BIT_WIDE(screen))
X      dx = BIT_WIDE(screen)-x;
X
X   if (y + dy >= BIT_HIGH(screen))
X      dy = BIT_HIGH(screen)-y;
X
X   curr_font = Get_font(fnt);
X   if (curr_font == font) {
X#ifdef DEBUG
X      dprintf(n)(stderr,"Can't find font %d, using default\r\n", fnt);
X#endif
X      }
X
X#ifdef DEBUG
X   dprintf(n)(stderr,"starting window: (%d,%d)  %d x %d font (%d,%d)\r\n",
X             x,y,dx,dy,curr_font->head.wide, curr_font->head.high);
X   dprintf(n)(stderr,"min size: %d x %d\r\n",
X           SUM_BDR + curr_font->head.wide*MIN_X +1,
X           SUM_BDR + curr_font->head.high*MIN_Y +1);
X#endif
X
X   if (dx < SUM_BDR + curr_font->head.wide*MIN_X +1 ||
X       dy < SUM_BDR + curr_font->head.high*MIN_Y +1)
X       return(-1);
X
X#ifdef DEBUG
X   dprintf(n)(stderr,"adjusted to: (%d,%d)  %d x %d\r\n",x,y,dx,dy);
X#endif
X
X   if (!setup_window(win,curr_font,x,y,dx,dy)) {
X      fprintf(stderr,"Out of memory for window creation -- bye!\n");
X      quit();
X      }
X
X   next_window++;
X
X   /* make the window */
X
X   set_covered(win);
X   border(win,BLK_BDR,WH_BDR);
X   CLEAR(W(window),BIT_CLR);
X
X   /* set up file descriptor modes */
X
X   if (fcntl(W(from_fd),F_SETFL,fcntl(W(from_fd),F_GETFL,0)|FNDELAY) == -1)
X      fprintf(stderr,"%s: fcntl failed for fd %d\n",W(tty),W(from_fd));
X
X   mask |= 1<<W(to_fd);
X
X   /* send initial string (if any) */
X
X   if (start && *start) {
X#ifdef DEBUG
X      dprintf(n)(stderr,"Sending initial string: [%s]\n",start);
X#endif
X      Write(W(to_fd),start,strlen(start));
X      }
X   return(0);
X   }
X
X/* initialize window state */
X
Xint
Xsetup_window(win,curr_font,x,y,dx,dy)
Xregister WINDOW *win;
Xint x,y,dx,dy;
Xstruct font *curr_font;
X   {
X   register int i;
X
X#ifdef ALIGN
X   alignwin(screen,&x,&dx,SUM_BDR);
X#endif
X
X   W(font) = curr_font;
X   W(x) = 0;
X   W(y) = curr_font->head.high;
X   W(esc_cnt) = 0;
X   W(esc[0]) = 0;
X   W(flags) = W_ACTIVE | init_flags;
X#ifdef CUT
X   W(flags) |= W_SNARFABLE;
X#endif
X#ifdef COLOR
X   W(background) = NOCOLOR&BIT_SRC | GETCOLOR(WHITE);
X   W(style) = NOCOLOR&BIT_SRC | GETCOLOR(BLACK);
X#else
X   W(style) = OPCODE(BIT_SRC);
X   W(background) = OPCODE(BIT_CLR);
X#endif
X	W(curs_type) = CS_BLOCK;
X   W(x0) = x;
X   W(y0) = y;
X   W(border) = bit_create(screen,x,y,dx,dy);
X   W(window) = bit_create(W(border),SUM_BDR,SUM_BDR,dx-SUM_BDR*2,dy-SUM_BDR*2);
X
X   W(text.x) = 0;
X   W(text.y) = 0;
X   W(text.wide) = 0;
X   W(text.high) = 0;
X
X   W(bitmap) = (BITMAP *) 0;
X   for(i=0;i<MAXBITMAPS;i++)
X      W(bitmaps)[i] = (BITMAP *) 0;
X
X   W(save) = (BITMAP *) 0;
X   W(stack) = (WINDOW *) 0;
X   W(main) = win;
X   W(alt) = (WINDOW *) 0;
X   W(esc_cnt) = 0;
X   W(esc[0])=0;
X   W(clip_list) = (char *) 0;
X
X   for(i=0;i<MAXMENU;i++)
X      W(menus[i]) = (struct menu_state *) 0;
X
X   W(menu[0]) = W(menu[1]) = -1;
X   W(event_mask) = 0;
X
X   for(i=0;i<MAXEVENTS;i++)
X      W(events)[i] = (char *) 0;
X
X   W(snarf) = (char *) 0;
X   W(gx) = 0;
X   W(gy) = 0;
X   W(op) = OPCODE(BIT_SET);
X   W(max) = 0;
X   W(current) = 0;
X   strcpy(W(tty), last_tty());
X   W(num) = 0;
X   clip_bad(win);	/* invalidate clip lists */
X   return(W(border) && W(window));
X   }
X
X/*
X	Look through all the windows for the next available window set id.
X*/
X
Xint
Xnext_windowset_id()
X   {
X      char		list[ MAXWIN + 2 ];
X      register char	*cp;
X      register WINDOW	*win;
X
X      for( cp = list;  cp < &list[ MAXWIN + 2 ];  cp++ )
X	 *cp = 0;
X
X      for( win = active;  win != (WINDOW *)0;  win = W(next) )
X	 list[ W(setid) ] = 1;
X
X      /*	There is no window set ID zero.
X      */
X      for( cp = list + 1;  *cp;  cp++ )
X	 ;
X
X      return cp - list;
X   }
END_OF_FILE
# end of 'src/new_window.c'
fi
if test -f 'src/update.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/update.c'\"
else
echo shar: Extracting \"'src/update.c'\" \(7972 characters\)
sed "s/^X//" >'src/update.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: update.c,v 4.1 88/06/21 13:34:49 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/RCS/update.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/update.c,v $$Revision: 4.1 $";
X
X/* update a background window */
X
X/*
X *	   build a clip list
X *	1) find all window edges that intersect with the current window 
X *	2) sort all tops+bottoms then left+rights into increasing order
X *	3) for each rectangular patch, see if it is visible on target window
X *	4) if visible, coellesce patch and keep on a list
X *    update window against clip list
X * 5) run through list, and update each rext that intersects with
X *    the clip region
X */
X
X#include "bitmap.h"
X#include "defs.h"
X#include "clip.h"
X#include <stdio.h>
X
X#define MAX_COORDS	((MAXWIN+1)  * 5)	/* educated guess (stab in the dark?) */
X
Xstruct rect_list {				/* list of visible "patches" of obscured window */
X	rectangle rect;				/* clipping rectangle */
X	struct rect_list *next;		/* next clipping rectangle */
X	};
X
Xstatic int x[MAX_COORDS];		/* left/right edges of covering windows */
Xstatic int y[MAX_COORDS];		/* top/bottom edges of covering windows */
X
X/* update an obscured window */
X
Xupdate(win, clipp)
Xregister WINDOW *win;
Xrect	*clipp;
X	{
X	/* generate clip list */
X
X	if (!(W(flags)&W_CLIPDONE)) {
X		if (W(clip_list) != NULL) /* free old list (we could reuse it) */
X			zap_cliplist(win);
X		gen_list(win);
X		W(flags) |= W_CLIPDONE;
X		}
X
X	/* update the window */
X
X   do_update(win,clipp);			/* do the update */
X	}
X
X/* free window's clip list */
X
Xint
Xzap_cliplist(win)
XWINDOW *win;
X	{
X	register struct rect_list *list = (struct rect_list *) W(clip_list);
X	register struct rect_list *next;
X
X#ifdef DEBUG
X	dprintf(U)(stderr,"Zapping clip list\r\n");
X#endif
X	for(;list;list=next) {
X		next = list->next;
X		free(list);
X		}	
X	W(clip_list) = NULL;
X	}
X
X/* generate a clip list */
X
Xint
Xgen_list(window)
Xregister WINDOW *window;
X   {
X
X   register WINDOW *win = window;
X   register struct rect_list *list, *prev = (struct rect_list *)0;
X   register int x_cnt = 2, y_cnt = 2;
X   register int i, j;
X   int count = 0;
X   int skip;		/* covered by another window - skip patch */
X   int hold;		/* hold for coellessing */
X
X   int cmp();		/* compare for qsort */
X
X   /* build arrays of window coordinates: intersecting win's above win */
X
X   x[0] = SUM_BDR + W(x0);
X   y[0] = SUM_BDR + W(y0);
X   x[1] = SUM_BDR + W(x0) + BIT_WIDE(W(window));
X   y[1] = SUM_BDR + W(y0) + BIT_HIGH(W(window));
X
X   for(win = active; win != window; win=W(next)) {
X      if (!(in_win(win,x[0],y[0],x[1],y[1])))
X         continue;
X
X      if (W(x0) >= x[0] && W(x0) <= x[1])
X         x[x_cnt++] = W(x0);
X
X      if (W(y0) >= y[0] && W(y0) <= y[1])
X         y[y_cnt++] = W(y0);
X
X      if (W(x0) + BIT_WIDE(W(border)) >= x[0] &&
X               W(x0) + BIT_WIDE(W(border)) <= x[1])
X         x[x_cnt++] = W(x0) + BIT_WIDE(W(border));
X
X      if (W(y0) + BIT_HIGH(W(border)) >= y[0] &&
X               W(y0) + BIT_HIGH(W(border)) <= y[1])
X         y[y_cnt++] = W(y0) + BIT_HIGH(W(border));
X      
X      if (y_cnt >= MAX_COORDS || x_cnt >= MAX_COORDS)
X         break;
X      }
X
X   /* sort window coordinate lists */
X
X   qsort(x,x_cnt,sizeof(int),cmp);
X   qsort(y,y_cnt,sizeof(int),cmp);
X
X   x_cnt--;
X   y_cnt--;
X
X   /* build list of covering rectangles */
X
X   for(j=0; j<y_cnt; j++) {
X
X      if (y[j] == y[j+1])	/* avoid zero-height patches */
X         continue;
X
X      for(hold=x_cnt,i=0; i<x_cnt; i++) {
X
X         if (x[i] == x[i+1])	/* avoid zero-width patches */
X            continue;
X
X			/* see if patch is visible */
X
X         for(skip=0,win=active; win!=window; win=W(next))
X            if (in_win(win, x[i], y[j], x[i+1], y[j+1])) {
X               skip++;
X               break;
X               }
X
X			/* visible, add patch to list, or append to previous patch */
X
X         if (!skip)  {
X				if (i == hold) {		/* coel. across */
X					list->rect.wide += x[i+1] - x[i];
X					hold++;
X					}
X				else {	/* flush held rect */
X					count++;		/* only for debugging */
X					list = (struct rect_list *) alloc(sizeof(struct rect_list));
X					list->rect.x = x[i] - W(x0);
X					list->rect.y = y[j] - W(y0);
X					list->rect.wide = x[i+1] - x[i];
X					list->rect.high = y[j+1] - y[j];
X					list -> next = NULL;
X					if (prev)
X						prev -> next = list;
X					if (!W(clip_list))	/* set initial rectangle */
X						W(clip_list) = (char *) list;
X					prev = list;
X					hold = i+1;				/* next 'i' to check for coell. */
X					}
X            }
X         }
X      }
X
X/* look at rect list	DEBUG code, commented out!
X
X	for(list=(struct rect_list *) W(clip_list);list;list = list->next) {
X		int	x = list->rect.x,
X			y = list->rect.y,
X			wide = list->rect.wide,
X			high = list->rect.high;
X		in_mouseoff( x, y, wide, high );
X		bit_blit(W(border), x, y, wide, high, BIT_NOT(BIT_DST),0L,0,0);
X		dprintf(U)(stderr,"  Rect %d,%d  %dx%d\n", x, y, wide, high );
X		getchar();
X		bit_blit(W(border), x, y, wide, high, BIT_NOT(BIT_DST),0L,0,0);
X		MOUSE_ON(mousex,mousey);
X		}
XDEBUG code, commented out! */
X
X#ifdef DEBUG
X	dprintf(U)(stderr,"%s: Built clip list (%d)\r\n",W(tty),count);
X#endif
X
X	return(0);	/* I'll think of something */
X   }
X
X/* update obscured window */
X
Xint
Xdo_update(win,clipp)	
Xregister WINDOW *win;	/* window to update */
Xrect *clipp;      	/* region of window to update (window coords) */
X	{
X   register struct rect_list *list;	/* list of rectangle to clip to */
X   register rectangle *got;		/* intersecting region */
X   rectangle *got_int();		/* finds intersecting rectangle */
X
X#ifdef DEBUG
X	dprintf(*)(stderr,"Updating background window to %d,%d => %d,%d\r\n",
X		clipp->x1,clipp->y1,clipp->x2,clipp->y2);
X#endif
X
X	for(list=(struct rect_list *)W(clip_list);list;list = list->next) {
X		if (got = got_int(&(list->rect),clipp)) {
X			register int	x = got->x,
X					y = got->y,
X					wide = got->wide,
X					high = got->high;
X			in_mouseoff( x + W(x0), y + W(y0), wide, high );
X			bit_blit(W(border),x,y,wide,high,BIT_SRC,W(save),x,y);
X			MOUSE_ON(mousex,mousey);
X			}
X		}
X	}
X
X/* find the intersection of 2 rectangles */
X
Xrectangle *
Xgot_int(r1,r2)
Xregister rectangle *r1;		/* rect 1 */
Xregister rect *r2;			/* other rect   (should both be same struct) */
X	{
X	static rectangle result;
X
X	result.x = Max(r1->x,r2->x1+SUM_BDR);
X	result.y = Max(r1->y,r2->y1+SUM_BDR);
X	result.wide = Min(r1->x + r1->wide, r2->x2+SUM_BDR) - result.x;
X	result.high = Min(r1->y + r1->high, r2->y2+SUM_BDR) - result.y;
X
X	if (result.wide > 0 && result.high > 0 )
X      return(&result);
X	else
X		return((rectangle *) 0);
X	}
X
X/* see if mouse in rectangle, if so turn the mouse off */
X
Xin_mouseoff(x0,y0,wide,high)
Xregister int x0,y0,wide,high;
X   {
X   if( !( x0 > mousex+16 || y0 > mousey+16 ||
X        x0+wide < mousex || y0+high < mousey))
X	MOUSE_OFF(mousex,mousey);
X   }
X         
X/* see if rectangle in window */
X
Xint
Xin_win(win,x0,y0,x1,y1)
Xregister WINDOW *win;
Xregister x0,y0,x1,y1;
X   {
X   return(
X      W(x0) + BIT_WIDE(W(border)) <= x0 ||
X      x1 <= W(x0) ||
X      W(y0) + BIT_HIGH(W(border)) <= y0 ||
X      y1 <= W(y0)
X   ?  0  :  1);
X   }
X
X/* compare for qsort */
X
Xint
Xcmp(x,y)
Xint *x, *y;
X   {
X   return( *x - *y);
X   }
X
X/* invalidate clip list for all windows affected by 'window' */
X
Xclip_bad(window)
Xregister WINDOW *window;		/* this window has changed */
X	{
X	register WINDOW *win;		/* working window */
X
X	/* invalidate all intersecting window clip lists below this one */
X
X	window->flags &= ~W_CLIPDONE;		/* invalidate clip list */
X   for(win=window->next;win != (WINDOW *) 0;win=W(next))
X		if (intersect(win,window)) 
X			W(flags) &= ~W_CLIPDONE;		/* invalidate clip list */
X	}
END_OF_FILE
# end of 'src/update.c'
fi
echo shar: End of archive 28 \(of 61\).
cp /dev/null ark28isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
