Subject:  v17i038:  MGR, Bellcore window manager, Part37/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 38
Archive-name: mgr/part37




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 37 (of 61)."
# Contents:  demo/msg/do.c lib/scribe.c.4 src/mgr.c
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:46 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'demo/msg/do.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/msg/do.c'\"
else
echo shar: Extracting \"'demo/msg/do.c'\" \(14264 characters\)
sed "s/^X//" >'demo/msg/do.c' <<'END_OF_FILE'
X/*	$Header: do.c,v 4.1 88/06/21 14:02:38 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/msg/RCS/do.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/msg/RCS/do.c,v $$Revision: 4.1 $";
X
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/* do a service */
X
X#include <stdio.h>
X#include <signal.h>
X#include "term.h"
X#include "do.h"
X
X#define dprintf		if (debug) fprintf
X#define have_icon(icon)	(icon->w && icon->h)
X#define GET_OPT(i)	\
X	strlen(argv[i])>2 ? argv[i]+2 : argv[++i]
X
X#define MSG		'&'		/* message leader */
X
X#define TIMEOUT		3		/* need first response by now */
X
X#define NORMAL		0		/* quiescent icon */
X#define RUNNING		1		/* icon while running command */
X#define ACTIVE		2		/* icon while window active */
X
X/* remote options */
X
X#define NONE	0			/* no remotes at all */
X#define LOCAL	1			/* command runs locally, ship file */
X#define REMOTE	2			/* command runs remotely */
X
Xint debug;
Xint wx,wy,border;			/* initial window parameters */
Xint fw, fh;				/* font size */
Xstruct icon *icon;			/* current icon */
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   register int i;
X
X   char *index(), *ttyname(), *getenv();
X   int timeout(),clean();
X
X   struct icon icons[3];		/* icons */
X   char line[100];			/* mgr inout buffer */
X   char file[100];			/* command args go here */
X   char message[100];			/* place to format messages */
X   char temp[100];			/* temp file name */
X   char do_host[32];			/* our host */
X
X   char action;				/* message command */
X   char *client_host;			/* client host */
X   char *command;			/* command to run */
X   char *name = NULL;			/* server name (if not command) */
X   char *path;				/* path part of file name */
X
X   int id;				/* id of sender */
X   int code;				/* return code from command */
X   int xpos, ypos;			/* where command window goes */
X   int wide ,high;			/* command window size */
X   int nowindow = 0;			/* no command window */
X   int font=0;				/* font in leiu of icon */
X   int wait=0;				/* wait for ack at command term. */
X   int remote=NONE;			/* remote requests permitted */
X   int icon_count=0;			/* Number of icons */
X   int servers = 0;			/* number of servers out there */
X   int bailout = 0;			/* bail out w/out running command */
X
X   debug = (int) getenv("DEBUG");
X
X   /* check for valid environment */
X
X   if (argc < 3) {
X      fprintf(stderr,"usage: %s [options] -c<command> icon1 icon2 [icon3]\n",
X              *argv);
X      fprintf(stderr,"options:\n");
X      fprintf(stderr,"   -C nnn   number of columns\n");
X      fprintf(stderr,"   -R nnn   number of rows\n");
X      fprintf(stderr,"   -f n     font\n");
X      fprintf(stderr,"   -n name  name of command (if not command name)\n");
X      fprintf(stderr,"   -p       wait for CR at command termination\n");
X      fprintf(stderr,"   -W       don't make alternate window\n");
X      fprintf(stderr,"   -x nnn   starting window position\n");
X      fprintf(stderr,"   -y nnn   starting window position\n");
X      fprintf(stderr,"   -i       interactive starting icon position\n");
X      fprintf(stderr,"   -r       permit remote invocations\n");
X      fprintf(stderr,"   -N       remote invocations run over there1\n");
X      exit(1);
X      }
X
X   ckmgrterm( *argv );
X   
X   /* setup mgr */
X
X   m_setup(M_FLUSH);
X   chmod(ttyname(2),0600);	/* this is not gauranteed */
X   m_push(P_POSITION|P_FONT|P_EVENT|P_FLAGS);
X
X   signal(SIGTERM,clean);
X   signal(SIGINT,clean);
X   signal(SIGHUP,clean);
X   signal(SIGALRM,timeout);
X
X   m_ttyset();
X   m_setmode(M_NOWRAP);
X   m_setmode(M_ABS);
X   m_func(B_COPY);
X
X   m_setevent(ACCEPT,"&%f:%m\r");
X   m_setevent(REDRAW,"R\r");
X   m_setevent(RESHAPE,"S\r");
X   m_setevent(MOVE,"M\r");
X   m_setevent(ACTIVATE,"A\r");
X   m_setevent(DEACTIVATE,"D\r");
X
X   get_size(&wx,&wy,&wide,&high);
X   get_param(0,0,0,&border);
X   font = get_font(&fw,&fh);
X   dprintf(stderr,"%d,%d %dx%d font %d (%d,%d)\n",wx,wy,wide,high,font,fw,fh);
X
X   xpos = wx, ypos=wy;
X   gethostname(do_host,sizeof(do_host));
X
X   /* check arguments */
X
X   for(i=1;i<argc;i++) {
X      if (*argv[i] == '-')
X         switch (argv[i][1]) {
X            case 'W':				/* don't make alt. window */
X               nowindow++;
X               break;
X            case 'r':				/* remote file, local command */
X               remote=LOCAL;
X               break;
X            case 'N':				/* remote commmand,local file */
X               remote=REMOTE;
X               break;
X            case 'p':				/* wait for ack */
X               wait++;
X               break;
X            case 'n':				/* specify command name */
X               name = GET_OPT(i);
X               break;
X            case 'c':				/* specify command */
X               command = GET_OPT(i);
X               break;
X            case 'f':				/* specify font */
X               font = atoi(GET_OPT(i));
X               break;
X            case 'C':				/* specify columns */
X               wide = 2*border + fw * atoi(GET_OPT(i));
X               break;
X            case 'R':				/* specify rows */
X               high = 2*border + fh * atoi(GET_OPT(i));
X               break;
X            case 'w':				/* specify wide */
X               wide = atoi(GET_OPT(i));
X               break;
X            case 'i':				/* specify icon start */
X               {
X                  int x,y;
X                  m_push(P_EVENT);
X                  m_setevent(BUTTON_1,"Z %p\r");
X                  fprintf(stderr,"Click button 1 to indicate icon position\n");
X                  while (*m_gets(line) != 'Z')
X                     ;
X                  sscanf(line,"Z %d %d",&x,&y);
X                  wx += x, wy +=y;
X                  m_pop();
X                  }
X               break;
X            case 'x':				/* specify x_start */
X               xpos = atoi(GET_OPT(i));
X               break;
X            case 'y':				/* specify y_start */
X               ypos = atoi(GET_OPT(i));
X               break;
X            default:
X               fprintf(stderr,"%s: bad flag %c ignored\n",argv[0],argv[i][1]);
X            }
X      else if (icon_count < 3) {
X         download_icon(&icons[icon_count],argv[i],icon_count+1,font);
X         icon_count++;
X         }
X      else
X         fprintf(stderr,"%s: invalid arg [%s] ignored\n",argv[0],argv[i]);
X      }
X
X   if (RUNNING > icon_count) {
X      fprintf(stderr,"%s: Not enough icons specified\n",argv[0]);
X      exit(2);
X      }
X      
X   if (debug) 
X      getchar();
X
X   set_icon(&icons[NORMAL]);
X
X   if (name == NULL)
X      name = command;
X
X   m_setevent(NOTIFY,name);
X   sprintf(message,"%c %s",S_HI,name);
X
X   m_broadcast(message);
X   alarm(TIMEOUT);
X   m_clearmode(M_ACTIVATE);
X   m_flush();
X   dprintf(stderr,"%s: broadcast id\r\n",name);
X         
X   while(m_gets(line) != NULL) {
X
X      /* process messages */
X
X      if (*line == MSG) {
X         sscanf(line+1,"%d:%c %[^\n]", &id,&action,file);
X         dprintf(stderr,"%s id: %d message: %s\r\n",name,id,file);
X         switch (action) {
X            case C_DO:			/* received command */
X               dprintf(stderr,"%s received command from %d (%s)\r\n",
X                       name,id,file);
X               sprintf(message,"%c%c",S_REPLY,R_RCVD);
X               m_sendto(id,message);
X               set_icon(&icons[RUNNING]);
X
X               /* no file name in command, use snarf buffer */
X
X               if (*file == C_SNARF) {
X                  m_put();
X                  m_gets(file);
X                  dprintf(stderr,"%s snarfing (%s)\r\n", name,file);
X                  }
X
X               /* get host name (if none, assume local host) */
X
X               if (path=index(file,HOST)) {
X                  *path = '\0';
X                  client_host = file;
X                  path++;
X                  }
X               else {
X                  path = file;
X                  client_host = do_host;
X                  }
X
X               dprintf(stderr,"Got %s at %s\n",path,client_host);
X              
X               if (strcmp(client_host,do_host)!= 0)
X                  switch (remote) {
X                     case NONE:		/* no remote access allowed */ 
X                        sprintf(message,"%c%c",S_REPLY,R_HOST);
X                        m_sendto(id,message);
X                        bailout++;
X                        break;
X                     case LOCAL:	/* ship file to command */
X                        sprintf(temp,"TEMP/%s:%s.%d",
X                               client_host,path,getpid());
X                        sprintf(message,"rcp %s:%s %s",
X                               client_host,path,temp);
X                        if (system(message)) {
X                           sprintf(message,"%c%c",S_REPLY,R_NET);
X                           m_sendto(id,message);
X                           bailout++;
X                           }
X                        break;
X                     case REMOTE:	/* run command remotely */
X                        sprintf(message,"rsh %s '%s %s'",
X                                client_host,command,path);
X                        break;
X                     }
X               else
X                  sprintf(message,"%s %s",command,path);
X               
X               if (bailout)
X                  break;
X
X               if (nowindow) {
X                  m_ttyreset();
X                  dprintf(stderr,"%s Running [%s] no window\n",name,message);
X                  code = system(message);
X                  m_ttyset();
X                  }
X               else 
X                  code = do_command(message,0,0,font,xpos,ypos,wide,high,wait);
X               set_icon(&icons[NORMAL]);
X               sprintf(message,"%c%c",S_REPLY,code==0?R_DONE:R_BAD);
X               m_sendto(id,message);
X               m_clearmode(M_ACTIVATE);
X               break;
X            case C_WHO:			/* received who-are-you inquiry */
X               dprintf(stderr,"%s received query from %d\r\n",name,id);
X               sprintf(message,"%c%c %s",S_REPLY,R_WHO,name);
X               m_sendto(id,message);
X               break;
X            case S_HI:			/* Hi, I'm a server */
X               dprintf(stderr,"%s Server HI message, ignored\r\n",name);
X               alarm(0);
X               break;
X            case S_BYE:			/* server died */
X               dprintf(stderr,"%s Server BYE message, ignored\r\n",name);
X               break;
X            case S_REPLY:		/* someone thinks I'm a client */
X               dprintf(stderr,"%s Oops, I got a server reply message\r\n",name);
X               break;
X            default:			/* unknown message */
X               sprintf(message,"%c%c",S_REPLY,R_UNKWN);
X               m_sendto(id,message);
X               dprintf(stderr,"%s unknown message\r\n",name);
X               break;
X            }
X         }
X      else {
X
X         /* process mgr events */
X
X         dprintf(stderr,"%s Not a message: %s\r\n",name,line);
X         switch(*line) {
X            case 'M':				/* moved */
X              get_size(&wx,&wy,0,0);
X              break;
X            case 'S':				/* reshape */
X              get_size(&wx,&wy,0,0);
X              reset_icon();
X              break;
X            case 'R':				/* redraw */
X              reset_icon();
X              break;
X#ifdef OOPS
X            case 'A':				/* window activated */
X              if (icon_count > ACTIVE)
X                 set_icon(&icons[ACTIVE]);
X              break;
X            case 'D':				/* window deactivated */
X              if (icon_count > ACTIVE)
X                 set_icon(&icons[NORMAL]);
X              break;
X#endif
X            }
X         }
X      m_flush();
X      }
X   }
X   
X/* down load an icon */
X
Xdownload_icon(icon,name,where,font)
Xregister struct icon *icon;	/* name of icon to download */
Xchar *name;			/* text string in lieu of icon */
Xint where;			/* bitmap to download icon to */
Xint font;			/* char font if no icon */
X   {
X   int size;
X   char line[100];
X   int w_in=0,h_in=0;
X
X   /* look only on the local machine */
X
X   dprintf(stderr,"   looking for %s\r\n",name);
X   m_bitfromfile(where,name);
X   m_flush();
X   m_gets(line);
X   sscanf(line,"%d %d",&w_in,&h_in);
X   dprintf(stderr,"   Found %s (%d x %d)\r\n",name,w_in,h_in);
X   icon->w = w_in;
X   icon->h = h_in;
X   icon->type = (h_in && w_in) ? where : font;
X   icon->name = name;
X   return(w_in && h_in);
X   } 
X
X/* put icon in a window */
X
Xset_icon(name)
Xstruct icon *name;		/* name of icon */
X   {
X   m_push(P_EVENT);
X   if (have_icon(name)) {
X      m_font(1);
X      dprintf(stderr,"Setting icon %s\r\n",name->name);
X      m_shapewindow(wx,wy,name->w+2*border,name->h+2*border);
X      m_bitcopyto(0,0,name->w,name->h,0,0,0,name->type);
X      }
X   else {
X      dprintf(stderr,"Setting text %s\r\n",name->name);
X      m_font(name->type);
X      m_size(strlen(name->name),1);
X      m_clear();
X      m_printstr(name->name);
X      }
X   m_flush();
X   m_clearmode(M_ACTIVATE);
X   m_pop();
X   icon = name;
X   }
X
Xreset_icon()
X   {
X   if (icon)
X      set_icon(icon);
X   }
X
X/* time out */
X
Xint
Xtimeout(n)
Xint n;
X   {
X   fprintf(stderr,"Can't send messages, sorry\n");
X   clean(n);
X   }
X
X/*	Clean up and exit */
X
Xclean(n)
Xint n;
X   {
X   char message[40];
X
X   sprintf(message,"%c",S_BYE);
X   m_broadcast(message);
X   m_gets(message);
X   m_popall();
X   m_clear();
X   m_ttyreset();
X   exit(n);
X   }
X
X/* run  a command in a sub window */
X
Xdo_command(command,menu,count,font,xpos,ypos,wide,high,wait)
Xchar *command;
Xstruct menu_entry *menu;
Xint count;
Xint font,xpos,ypos,wide,high;
Xint wait;
X   {
X   int code;		/* return code from command */
X   int n;		/* sub-window number */
X
X   n=m_makewindow(xpos,ypos,wide,high);
X
X   if (n==0) {			/* can't make window */
X      m_printstr("\007\fCan't open command window, sorry");
X      return(-1);
X      }
X
X   m_selectwin(n);
X   if (count) {
X      menu_load(1,count,menu);
X      m_selectmenu(1);
X      }
X   if (font > 0)
X      m_font(font);
X   m_ttyreset();
X   dprintf(stderr,"Running [%s]\n",command);
X   code = system(command);
X   if (wait) {
X      char temp[10];
X      m_gets(temp);
X      }
X   m_ttyset();
X   m_selectwin(0);
X   m_destroywin(n);
X   return(code);
X   }
END_OF_FILE
# end of 'demo/msg/do.c'
fi
if test -f 'lib/scribe.c.4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/scribe.c.4'\"
else
echo shar: Extracting \"'lib/scribe.c.4'\" \(14275 characters\)
sed "s/^X//" >'lib/scribe.c.4' <<'END_OF_FILE'
X	31, 31, 0, -1, 2, 0, 4, 0, 6, -1};
Xstatic char c347[115] = {
X	56, -11, 13,			/*, 8, 26, Z  */
X	7, 11, 6, 9, 0, 3, -4, -2, -6, -5, -9, -9, 31, 31, 4, 6,
X	-4, -3, 31, 31, 9, 12, 6, 8, 4, 5, 0, 0, -6, -6, -7, -8,
X	31, 31, -9, 10, -7, 12, -4, 11, 3, 11, 9, 12, 31, 31, -8, 11,
X	-4, 10, 1, 10, 6, 11, 31, 31, -9, 10, -5, 9, 0, 9, 5, 10,
X	7, 11, 31, 31, -7, -8, -5, -7, 0, -6, 5, -6, 9, -7, 31, 31,
X	-6, -8, -1, -7, 4, -7, 8, -8, 31, 31, -9, -9, -3, -8, 4, -8,
X	7, -9, 9, -7, 31, 31, -6, 2, -1, 2, 31, 31, 2, 2, 6, 2};
Xstatic char c348[25] = {
X	11, -7, 9,			/*, 1, 49, [  */
X	-3, 16, -3, -16, 31, 31, -2, 16, -2, -16, 31, 31, -3, 16, 4, 16,
X	31, 31, -3, -16, 4, -16};
Xstatic char c349[7] = {
X	2, -11, 11,			/*, 1, 40, /  */
X	-9, 16, 9, -16};
Xstatic char c350[25] = {
X	11, -7, 9,			/*, 1, 50, ]  */
X	2, 16, 2, -16, 31, 31, 3, 16, 3, -16, 31, 31, -4, 16, 3, 16,
X	31, 31, -4, -16, 3, -16};
Xstatic char c351[17] = {
X	7, -11, 11,			/*, 9, 28, 1, */
X	-8, -2, 0, 3, 8, -2, 31, 31, -8, -2, 0, 2, 8, -2};
Xstatic char c352[7] = {
X	2, -12, 12,			/*, 1, 38, -  */
X	-9, -12, 9, -12};
Xstatic char c353[15] = {
X	6, -6, 6,			/*, 9, 30, 3, */
X	-2, 12, 3, 6, 31, 31, -2, 12, -3, 11, 3, 6};
Xstatic char c354[107] = {
X	52, -8, 11,			/*, 7, 1, A  */
X	-2, 0, -4, -2, -5, -4, -5, -6, -4, -8, -2, -9, 0, -7, 3, -6,
X	31, 31, -5, -4, -4, -6, -3, -7, -1, -8, 31, 31, -4, -2, -4, -4,
X	-3, -6, -1, -7, 0, -7, 31, 31, -4, 2, -2, 2, 1, 3, 3, 4,
X	4, 5, 6, 3, 5, 2, 5, -6, 6, -7, 7, -7, 31, 31, -3, 4,
X	-4, 3, -1, 3, 31, 31, 2, 3, 5, 3, 4, 4, 4, -7, 5, -8,
X	31, 31, -5, 3, -3, 5, -2, 4, 0, 3, 3, 2, 3, -7, 5, -9,
X	7, -7, 31, 31, -5, 3, 0, -2};
Xstatic char c355[89] = {
X	43, -9, 11,			/*, 7, 2, B  */
X	-6, 10, -5, 8, -5, -6, -7, -7, 31, 31, -4, 8, -5, 10, -4, 11,
X	-4, -6, -1, -8, 31, 31, -6, 10, -3, 12, -3, -6, -1, -7, 0, -8,
X	31, 31, -7, -7, -5, -7, -3, -8, -2, -9, 0, -8, 3, -7, 5, -7,
X	31, 31, -3, 2, 0, 3, 2, 4, 3, 5, 4, 4, 6, 3, 7, 3,
X	5, 2, 5, -7, 31, 31, 2, 4, 4, 3, 4, -6, 31, 31, 0, 3,
X	1, 3, 3, 2, 3, -7};
Xstatic char c356[71] = {
X	34, -8, 8,			/*, 7, 3, C  */
X	-4, 3, -4, -6, -6, -7, -5, -7, -3, -8, -2, -9, 31, 31, -3, 3,
X	-3, -7, -1, -8, 31, 31, -2, 3, -2, -6, 0, -7, 4, -5, -1, -8,
X	-2, -9, 31, 31, -4, 3, 0, 4, 2, 5, 3, 4, 5, 3, 6, 3,
X	31, 31, 1, 4, 2, 3, 4, 3, 31, 31, -2, 3, 0, 4, 2, 2,
X	4, 2, 6, 3};
Xstatic char c357[83] = {
X	40, -9, 10,			/*, 7, 4, D  */
X	0, 5, -2, 4, -5, 3, -5, -6, -7, -7, 31, 31, -4, 3, -4, -6,
X	-1, -8, 31, 31, 0, 5, -3, 3, -3, -6, -1, -7, 0, -8, 31, 31,
X	-7, -7, -5, -7, -3, -8, -2, -9, 0, -8, 3, -7, 5, -7, 31, 31,
X	-5, 10, -2, 12, -1, 9, 5, 3, 5, -7, 31, 31, -2, 9, -4, 10,
X	-3, 11, -2, 9, 4, 3, 4, -6, 31, 31, -5, 10, 3, 2, 3, -7};
Xstatic char c358[65] = {
X	31, -8, 8,			/*, 7, 5, E  */
X	-4, 3, -4, -6, -6, -7, -5, -7, -3, -8, -2, -9, 31, 31, -3, 3,
X	-3, -7, -1, -8, 31, 31, -2, 3, -2, -6, 0, -7, 4, -5, -1, -8,
X	-2, -9, 31, 31, -4, 3, 0, 4, 2, 5, 5, 1, 3, 0, -2, -3,
X	31, 31, 1, 4, 4, 1, 31, 31, -2, 3, 0, 4, 3, 0};
Xstatic char c359[83] = {
X	40, -8, 8,			/*, 7, 6, F  */
X	-4, 10, -4, -6, -6, -7, -5, -7, -3, -8, -2, -9, 31, 31, -3, 10,
X	-3, -7, -1, -8, 31, 31, -2, 10, -2, -6, 0, -7, 1, -7, -1, -8,
X	-2, -9, 31, 31, -4, 10, 0, 11, 2, 12, 3, 11, 5, 10, 6, 10,
X	31, 31, 1, 11, 2, 10, 4, 10, 31, 31, -2, 10, 0, 11, 2, 9,
X	4, 9, 6, 10, 31, 31, -7, 5, -4, 5, 31, 31, -2, 5, 1, 5};
Xstatic char c360[113] = {
X	55, -9, 11,			/*, 7, 7, G  */
X	-5, 3, -5, -6, -7, -7, -6, -7, -4, -8, -3, -9, -2, -8, 0, -7,
X	3, -6, 31, 31, -4, 2, -4, -7, -2, -8, 31, 31, -3, 3, -3, -6,
X	-1, -7, 0, -7, 31, 31, -5, 3, -3, 3, 0, 4, 2, 5, 3, 4,
X	5, 3, 7, 3, 5, 2, 5, -10, 4, -13, 2, -15, 0, -16, -1, -15,
X	-3, -14, -5, -14, 31, 31, 1, 4, 4, 2, 4, -10, 31, 31, 1, -15,
X	-1, -14, -2, -14, 31, 31, 0, 4, 1, 3, 3, 2, 3, -8, 4, -11,
X	4, -13, 31, 31, 2, -15, 1, -14, -1, -13, -3, -13, -5, -14};
Xstatic char c361[95] = {
X	46, -9, 11,			/*, 7, 8, H  */
X	-6, 10, -5, 8, -5, -6, -7, -7, -6, -7, -4, -8, -3, -9, 31, 31,
X	-4, 8, -5, 10, -4, 11, -4, -7, -2, -8, 31, 31, -6, 10, -3, 12,
X	-3, -6, -1, -7, -3, -9, 31, 31, -3, 2, 0, 3, 2, 4, 3, 5,
X	4, 4, 6, 3, 7, 3, 5, 2, 5, -7, 3, -9, 2, -11, 31, 31,
X	2, 4, 4, 3, 4, -7, 3, -9, 31, 31, 0, 3, 1, 3, 3, 2,
X	3, -7, 2, -11, 2, -14, 3, -16, 4, -16, 2, -14};
Xstatic char c362[71] = {
X	34, -5, 7,			/*, 7, 9, I  */
X	0, 12, -2, 10, 0, 9, 2, 10, 0, 12, 31, 31, 0, 11, -1, 10,
X	1, 10, 0, 11, 31, 31, 0, 5, -1, 4, -3, 3, -1, 2, -1, -7,
X	1, -9, 3, -7, 31, 31, 0, 2, 1, 3, 0, 4, -1, 3, 0, 2,
X	0, -7, 1, -8, 31, 31, 0, 5, 1, 4, 3, 3, 1, 2, 1, -6,
X	2, -7, 3, -7};
Xstatic char c363[79] = {
X	38, -5, 7,			/*, 7, 10, J  */
X	0, 12, -2, 10, 0, 9, 2, 10, 0, 12, 31, 31, 0, 11, -1, 10,
X	1, 10, 0, 11, 31, 31, 0, 5, -1, 4, -3, 3, -1, 2, -1, -7,
X	1, -9, 2, -11, 31, 31, 0, 2, 1, 3, 0, 4, -1, 3, 0, 2,
X	0, -7, 1, -9, 31, 31, 0, 5, 1, 4, 3, 3, 1, 2, 1, -7,
X	2, -11, 2, -14, 0, -16, -2, -16, -2, -15, 0, -16};
Xstatic char c364[101] = {
X	49, -9, 10,			/*, 7, 11, K  */
X	-6, 10, -5, 8, -5, -6, -7, -7, -6, -7, -4, -8, -3, -9, 31, 31,
X	-4, 8, -5, 10, -4, 11, -4, -7, -2, -8, 31, 31, -6, 10, -3, 12,
X	-3, -6, -1, -7, -3, -9, 31, 31, -3, 2, 0, 4, 2, 5, 4, 2,
X	1, 0, -3, -3, 31, 31, 1, 4, 3, 2, 31, 31, 0, 4, 2, 1,
X	31, 31, 1, 0, 2, -1, 4, -6, 5, -7, 6, -7, 31, 31, 1, -1,
X	2, -2, 3, -7, 4, -8, 31, 31, 0, -1, 1, -2, 2, -7, 4, -9,
X	6, -7};
Xstatic char c365[45] = {
X	21, -5, 7,			/*, 7, 12, L  */
X	-2, 10, -1, 8, -1, -6, -3, -7, -2, -7, 0, -8, 1, -9, 31, 31,
X	0, 8, -1, 10, 0, 11, 0, -7, 2, -8, 31, 31, -2, 10, 1, 12,
X	1, -6, 3, -7, 4, -7, 2, -8, 1, -9};
Xstatic char c366[135] = {
X	66, -13, 15,			/*, 7, 13, M  */
X	-11, 3, -10, 3, -9, 2, -9, -6, -11, -7, -10, -7, -8, -8, -7, -9,
X	31, 31, -9, 4, -8, 3, -8, -7, -6, -8, 31, 31, -11, 3, -9, 5,
X	-7, 3, -7, -6, -5, -7, -7, -9, 31, 31, -7, 2, -4, 3, -2, 4,
X	-1, 5, 1, 3, 1, -6, 3, -7, 1, -9, 31, 31, -2, 4, 0, 3,
X	0, -7, 2, -8, 31, 31, -4, 3, -3, 3, -1, 2, -1, -6, -2, -7,
X	0, -8, 1, -9, 31, 31, 1, 2, 4, 3, 6, 4, 7, 5, 8, 4,
X	10, 3, 11, 3, 9, 2, 9, -6, 10, -7, 11, -7, 31, 31, 6, 4,
X	8, 3, 8, -7, 9, -8, 31, 31, 4, 3, 5, 3, 7, 2, 7, -7,
X	9, -9, 11, -7};
Xstatic char c367[91] = {
X	44, -9, 11,			/*, 7, 14, N  */
X	-7, 3, -6, 3, -5, 2, -5, -6, -7, -7, -6, -7, -4, -8, -3, -9,
X	31, 31, -5, 4, -4, 3, -4, -7, -2, -8, 31, 31, -7, 3, -5, 5,
X	-3, 3, -3, -6, -1, -7, -3, -9, 31, 31, -3, 2, 0, 3, 2, 4,
X	3, 5, 4, 4, 6, 3, 7, 3, 5, 2, 5, -6, 6, -7, 7, -7,
X	31, 31, 2, 4, 4, 3, 4, -7, 5, -8, 31, 31, 0, 3, 1, 3,
X	3, 2, 3, -7, 5, -9, 7, -7};
Xstatic char c368[81] = {
X	39, -9, 11,			/*, 7, 15, O  */
X	-5, 3, -5, -6, -7, -7, 31, 31, -4, 2, -4, -6, -1, -8, 31, 31,
X	-3, 3, -3, -6, -1, -7, 0, -8, 31, 31, -7, -7, -5, -7, -3, -8,
X	-2, -9, 0, -8, 3, -7, 5, -7, 31, 31, -5, 3, -3, 3, 0, 4,
X	2, 5, 3, 4, 5, 3, 7, 3, 5, 2, 5, -7, 31, 31, 1, 4,
X	4, 2, 4, -6, 31, 31, 0, 4, 1, 3, 3, 2, 3, -7};
Xstatic char c369[109] = {
X	53, -9, 11,			/*, 7, 16, P  */
X	-6, 5, -5, 3, -5, -6, -7, -7, -5, -7, -5, -16, 31, 31, -5, 4,
X	-4, 3, -4, -15, -3, -14, -4, -12, 31, 31, -4, -7, -3, -7, -1, -8,
X	31, 31, -6, 5, -4, 4, -3, 3, -3, -6, -1, -7, 0, -8, 31, 31,
X	-3, -8, -2, -9, 0, -8, 3, -7, 5, -7, 31, 31, -3, -8, -3, -12,
X	-2, -14, -5, -16, 31, 31, -3, 2, 0, 3, 2, 4, 3, 5, 4, 4,
X	6, 3, 7, 3, 5, 2, 5, -7, 31, 31, 2, 4, 4, 3, 4, -6,
X	31, 31, 0, 3, 1, 3, 3, 2, 3, -7};
Xstatic char c370[89] = {
X	43, -9, 11,			/*, 7, 17, Q  */
X	-5, 3, -5, -6, -7, -7, 31, 31, -4, 2, -4, -7, -2, -8, 31, 31,
X	-3, 3, -3, -6, -1, -7, 0, -7, 31, 31, -7, -7, -6, -7, -4, -8,
X	-3, -9, -2, -8, 0, -7, 3, -6, 31, 31, -5, 3, -3, 3, 0, 4,
X	2, 5, 3, 4, 5, 3, 7, 3, 5, 2, 5, -16, 31, 31, 1, 4,
X	4, 2, 4, -15, 3, -14, 4, -12, 31, 31, 0, 4, 1, 3, 3, 2,
X	3, -12, 2, -14, 5, -16};
Xstatic char c371[77] = {
X	37, -8, 8,			/*, 7, 18, R  */
X	-6, 3, -5, 3, -4, 2, -4, -6, -6, -7, -5, -7, -3, -8, -2, -9,
X	31, 31, -5, 4, -3, 3, -3, -7, -1, -8, 31, 31, -6, 3, -4, 5,
X	-2, 3, -2, -6, 0, -7, 1, -7, -1, -8, -2, -9, 31, 31, -2, 3,
X	2, 5, 3, 4, 5, 3, 6, 3, 31, 31, 1, 4, 2, 3, 4, 3,
X	31, 31, 0, 4, 2, 2, 4, 2, 6, 3};
Xstatic char c372[119] = {
X	58, -8, 10,			/*, 7, 19, S  */
X	-5, 3, -5, -1, -3, -2, 3, -2, 5, -3, 5, -7, 31, 31, -4, 3,
X	-4, -1, 31, 31, 4, -3, 4, -7, 31, 31, -2, 4, -3, 3, -3, -1,
X	-1, -2, 31, 31, 1, -2, 3, -3, 3, -7, 2, -8, 31, 31, -5, 3,
X	-2, 4, 0, 5, 2, 4, 4, 4, 5, 5, 31, 31, -1, 4, 1, 4,
X	31, 31, -2, 4, 0, 3, 2, 3, 4, 4, 31, 31, 5, -7, 2, -8,
X	0, -9, -2, -8, -4, -8, -6, -9, 31, 31, 1, -8, -1, -8, 31, 31,
X	2, -8, 0, -7, -3, -7, -6, -9, 31, 31, 5, 5, 4, 3, 2, 0,
X	-3, -5, -6, -9};
Xstatic char c373[57] = {
X	27, -5, 7,			/*, 7, 20, T  */
X	-2, 10, -1, 8, -1, -6, -3, -7, -2, -7, 0, -8, 1, -9, 31, 31,
X	0, 8, -1, 10, 0, 11, 0, -7, 2, -8, 31, 31, -2, 10, 1, 12,
X	1, -6, 3, -7, 4, -7, 2, -8, 1, -9, 31, 31, -4, 5, -1, 5,
X	31, 31, 1, 5, 4, 5};
Xstatic char c374[95] = {
X	46, -9, 11,			/*, 7, 21, U  */
X	-7, 3, -6, 3, -5, 2, -5, -6, -7, -7, 31, 31, -6, 4, -4, 3,
X	-4, -7, -2, -8, 31, 31, -7, 3, -5, 5, -3, 3, -3, -6, -1, -7,
X	0, -7, 31, 31, -7, -7, -6, -7, -4, -8, -3, -9, -2, -8, 0, -7,
X	3, -6, 31, 31, 3, 5, 4, 4, 6, 3, 7, 3, 5, 2, 5, -6,
X	6, -7, 7, -7, 31, 31, 2, 4, 4, 3, 4, -7, 5, -8, 31, 31,
X	3, 5, 1, 3, 3, 2, 3, -7, 5, -9, 7, -7};
Xstatic char c375[73] = {
X	35, -9, 11,			/*, 7, 22, V  */
X	-6, 5, -5, 3, -5, -6, -2, -9, 0, -7, 3, -6, 5, -6, 31, 31,
X	-5, 4, -4, 3, -4, -6, -1, -8, 31, 31, -6, 5, -4, 4, -3, 3,
X	-3, -5, -2, -6, 0, -7, 31, 31, 3, 5, 4, 4, 6, 3, 7, 3,
X	5, 2, 5, -6, 31, 31, 2, 4, 4, 3, 4, -5, 31, 31, 3, 5,
X	1, 3, 3, 2, 3, -6};
Xstatic char c376[115] = {
X	56, -13, 15,			/*, 7, 23, W  */
X	-10, 5, -9, 3, -9, -6, -6, -9, -4, -7, -1, -6, 31, 31, -9, 4,
X	-8, 3, -8, -6, -5, -8, 31, 31, -10, 5, -8, 4, -7, 3, -7, -5,
X	-6, -6, -4, -7, 31, 31, -1, 5, -3, 3, -1, 2, -1, -6, 2, -9,
X	4, -7, 7, -6, 9, -6, 31, 31, -2, 4, 0, 3, 0, -6, 3, -8,
X	31, 31, -1, 5, 0, 4, 2, 3, 1, 2, 1, -5, 2, -6, 4, -7,
X	31, 31, 7, 5, 8, 4, 10, 3, 11, 3, 9, 2, 9, -6, 31, 31,
X	6, 4, 8, 3, 8, -5, 31, 31, 7, 5, 5, 3, 7, 2, 7, -6};
Xstatic char c377[119] = {
X	58, -10, 11,			/*, 7, 24, X  */
X	-7, 3, -6, 3, -4, 2, -3, 1, 1, -7, 2, -8, 4, -9, 6, -7,
X	31, 31, -5, 4, -3, 3, 2, -7, 4, -8, 31, 31, -7, 3, -5, 5,
X	-3, 4, -2, 3, 2, -5, 3, -6, 5, -7, 6, -7, 31, 31, 0, -1,
X	3, 5, 4, 4, 6, 4, 7, 5, 31, 31, 3, 4, 4, 3, 5, 3,
X	31, 31, 2, 3, 4, 2, 6, 3, 7, 5, 31, 31, -1, -3, -4, -9,
X	-5, -8, -7, -8, -8, -9, 31, 31, -4, -8, -5, -7, -6, -7, 31, 31,
X	-3, -7, -5, -6, -7, -7, -8, -9, 31, 31, -5, -2, -2, -2, 31, 31,
X	1, -2, 4, -2};
Xstatic char c378[121] = {
X	59, -9, 11,			/*, 7, 25, Y  */
X	-7, 3, -6, 3, -5, 2, -5, -6, -7, -7, 31, 31, -6, 4, -4, 3,
X	-4, -7, -2, -8, 31, 31, -7, 3, -5, 5, -3, 3, -3, -6, -1, -7,
X	0, -7, 31, 31, -7, -7, -6, -7, -4, -8, -3, -9, -2, -8, 0, -7,
X	3, -6, 31, 31, 3, 5, 4, 4, 6, 3, 7, 3, 5, 2, 5, -10,
X	4, -13, 2, -15, 0, -16, -1, -15, -3, -14, -5, -14, 31, 31, 2, 4,
X	4, 3, 4, -10, 31, 31, 1, -15, -1, -14, -2, -14, 31, 31, 3, 5,
X	1, 3, 3, 2, 3, -8, 4, -11, 4, -13, 31, 31, 2, -15, 1, -14,
X	-1, -13, -3, -13, -5, -14};
Xstatic char c379[77] = {
X	37, -9, 11,			/*, 7, 26, Z  */
X	6, 5, -6, -9, 31, 31, -6, 3, -4, 2, -1, 2, 2, 3, 6, 5,
X	31, 31, -5, 4, -3, 3, 1, 3, 31, 31, -6, 3, -4, 5, -2, 4,
X	2, 4, 6, 5, 31, 31, -6, -9, -2, -7, 1, -6, 4, -6, 6, -7,
X	31, 31, -1, -7, 3, -7, 5, -8, 31, 31, -6, -9, -2, -8, 2, -8,
X	4, -9, 6, -7, 31, 31, -4, -2, 4, -2};
Xstatic char c380[57] = {
X	27, -7, 9,			/*, 3, 49, [  */
X	2, 16, -1, 13, -2, 10, -2, 8, -1, 5, 2, 2, 31, 31, 0, 14,
X	-1, 11, -1, 7, 0, 4, 31, 31, 2, 2, -1, 0, 2, -2, 31, 31,
X	2, -2, -1, -5, -2, -8, -2, -10, -1, -13, 2, -16, 31, 31, 0, -4,
X	-1, -7, -1, -11, 0, -14};
Xstatic char c381[7] = {
X	2, -4, 4,			/*, 9, 14, N  */
X	0, 16, 0, -16};
Xstatic char c382[57] = {
X	27, -7, 9,			/*, 3, 50, ]  */
X	-2, 16, 1, 13, 2, 10, 2, 8, 1, 5, -2, 2, 31, 31, 0, 14,
X	1, 11, 1, 7, 0, 4, 31, 31, -2, 2, 1, 0, -2, -2, 31, 31,
X	-2, -2, 1, -5, 2, -8, 2, -10, 1, -13, -2, -16, 31, 31, 0, -4,
X	1, -7, 1, -11, 0, -14};
Xstatic char c383[49] = {
X	23, -12, 14,			/*, 3, 59, >  */
X	-9, -3, -9, -1, -8, 2, -6, 3, -4, 3, -2, 2, 2, -1, 4, -2,
X	6, -2, 8, -1, 9, 1, 31, 31, -9, -1, -8, 1, -6, 2, -4, 2,
X	-2, 1, 2, -2, 4, -3, 6, -3, 8, -2, 9, 1, 9, 3};
Xstatic char c384[7] = {
X	2, -12, 14,			/*, 3, 38, -  */
X	-9, -12, 9, -12};
X
Xstatic char *p[384] = { 
X	c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12,
X	c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24,
X	c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36,
X	c37, c38, c39, c40, c41, c42, c43, c44, c45, c46, c47, c48,
X	c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59, c60,
X	c61, c62, c63, c64, c65, c66, c67, c68, c69, c70, c71, c72,
X	c73, c74, c75, c76, c77, c78, c79, c80, c81, c82, c83, c84,
X	c85, c86, c87, c88, c89, c90, c91, c92, c93, c94, c95, c96,
X	c97, c98, c99, c100,c101,c102,c103,c104,c105,c106,c107,c108,
X	c109,c110,c111,c112,c113,c114,c115,c116,c117,c118,c119,c120,
X	c121,c122,c123,c124,c125,c126,c127,c128,c129,c130,c131,c132,
X	c133,c134,c135,c136,c137,c138,c139,c140,c141,c142,c143,c144,
X	c145,c146,c147,c148,c149,c150,c151,c152,c153,c154,c155,c156,
X	c157,c158,c159,c160,c161,c162,c163,c164,c165,c166,c167,c168,
X	c169,c170,c171,c172,c173,c174,c175,c176,c177,c178,c179,c180,
X	c181,c182,c183,c184,c185,c186,c187,c188,c189,c190,c191,c192,
X	c193,c194,c195,c196,c197,c198,c199,c200,c201,c202,c203,c204,
X	c205,c206,c207,c208,c209,c210,c211,c212,c213,c214,c215,c216,
X	c217,c218,c219,c220,c221,c222,c223,c224,c225,c226,c227,c228,
X	c229,c230,c231,c232,c233,c234,c235,c236,c237,c238,c239,c240,
X	c241,c242,c243,c244,c245,c246,c247,c248,c249,c250,c251,c252,
X	c253,c254,c255,c256,c257,c258,c259,c260,c261,c262,c263,c264,
X	c265,c266,c267,c268,c269,c270,c271,c272,c273,c274,c275,c276,
X	c277,c278,c279,c280,c281,c282,c283,c284,c285,c286,c287,c288,
X	c289,c290,c291,c292,c293,c294,c295,c296,c297,c298,c299,c300,
X	c301,c302,c303,c304,c305,c306,c307,c308,c309,c310,c311,c312,
X	c313,c314,c315,c316,c317,c318,c319,c320,c321,c322,c323,c324,
X	c325,c326,c327,c328,c329,c330,c331,c332,c333,c334,c335,c336,
X	c337,c338,c339,c340,c341,c342,c343,c344,c345,c346,c347,c348,
X	c349,c350,c351,c352,c353,c354,c355,c356,c357,c358,c359,c360,
X	c361,c362,c363,c364,c365,c366,c367,c368,c369,c370,c371,c372,
X	c373,c374,c375,c376,c377,c378,c379,c380,c381,c382,c383,c384};
X/*--------------------------*/
X	i = char_per_font * font + (ch-32);
X	c = error_char;
X	if (i >= 0 && i <383) c = p[i];
X	*npts = ( *c++) << 1;		/* convert pt count to coord count*/
X	*min = *c++;			/* extent of char, in char coords*/
X	*max = *c++;
X	for (i=0; i<*npts; i++) *pts++ = *c++;
X}
X
END_OF_FILE
# end of 'lib/scribe.c.4'
fi
if test -f 'src/mgr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mgr.c'\"
else
echo shar: Extracting \"'src/mgr.c'\" \(13239 characters\)
sed "s/^X//" >'src/mgr.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: mgr.c,v 4.7 88/07/28 11:11:05 sau Exp $
X	$Source: /tmp/mgrsrc/src/RCS/mgr.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/RCS/mgr.c,v $$Revision: 4.7 $";
X
X/* main routine for MGR */
X
X#include "bitmap.h"
X#include <stdio.h>
X#include <sys/signal.h>
X#ifdef sun
X#include <sys/time.h> 
X#endif
X#include <errno.h>
X#include "defs.h"
X#include "menu.h"
X#include "font.h"
X#include "event.h"
X
X#ifndef Min
X#define Min(x,y)		((x)>(y)?(y):(x))
X#endif
X#define POLL(poll)		(poll&mask ? &set_poll : (struct timeval *) 0)
X
X#ifdef sun
Xstruct timeval set_poll = {
X   (long) 0, (long) POLL_INT
X   };				/* set select to poll */
X#endif
X
Xchar *mouse_dev = MOUSE_DEV;		/* name of mouse device */
Xstatic int bitmaptype = 1;			/* old, non portable bitmap format */
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   register WINDOW *win;		/* current window to update */
X   register int i;			/* counter */
X   register int count;			/* # chars read from shell */
X   int maxbuf = MAXBUF;			/* # chars processed per window */
X   int shellbuf = MAXSHELL;		/* # chars processed per shell */
X   int type=1;				/* state var. for parsing argv */
X   int reads;				/* masks, result of select */
X   int tty;				/* fd for controlling tty */
X
X   unsigned char c;			/* reads from kbd go here */
X   char start_file[MAX_PATH];		/* name of startup file */
X   char *screen_dev = SCREEN_DEV;	/* name of frame buffer */
X   char *default_font = (char * )0;	/* default font */
X   char *rindex(), *getenv(), *ttyname();
X   char *term = getenv("TERM");		/* place to put terminal name */
X#ifdef SHRINK
X   BITMAP *prime;
X#endif
X
X   SETMOUSEICON(&mouse_arrow);
X
X   /* process arguments */
X
X   sprintf(start_file,"%s/%s",getenv("HOME"),STARTFILE);
X   while(--argc > 0) {
X      argv++;
X#ifdef DEBUG
X      dprintf(S)(stderr,"argument %s type %c\r\n",*argv,type==1?'*':type);
X#endif
X      switch(type) {
X         case 1:	/* looking for flag */
X              if (**argv == '-')
X                 switch(type = *(*argv+1)) {
X#ifdef DEBUG
X                 case 'd': debug = 1;
X                           strcpy(debug_level,*argv+2);
X                           fprintf(stderr,"Debug level: [%s]\n",debug_level);
X                           type = 1;
X                           break;
X#endif
X                 case 'v': 		/* print version number */
X                           printf("Mgr version %s created on %s at: %s\n",
X                                  version[0],version[1],version[2]);
X                           exit(1);
X                 case 'V': 		/* print version and options */
X                           printf("Mgr version %s created on %s at: %s by %s\n",
X                                  version[0],version[1],version[2],version[5]);
X                           printf("Compile flags: %s\n",version[3]);
X                           printf("Home directory: %s\n",version[4]);
X									printf("built with: %s\n",version[6]);
X                           exit(1);
X                 case 'x': strcpy(start_file,"/dev/null");
X                           type = 1;
X                           break;
X                 case 'n': 	/* use new style bitmap headers */
X                           bitmaptype = 0;
X                           break;
X                 }
X              else fprintf(stderr,"Invalid argument %s, ignored\n",*argv);
X              break;
X         case 'm':	/* set mouse device */
X              mouse_dev = *argv;
X              type = 1;
X              break;
X         case 's':	/* set start file */
X              strcpy(start_file,*argv);
X              type = 1;
X              break;
X         case 'F':	/* set default font file */
X              default_font = *argv;
X              type = 1;
X         case 'P':	/* set polling timeout */
X              set_poll.tv_usec = (long) atoi(*argv);
X              break;
X         case 'b':	/* set shell buffering */
X              shellbuf = atoi(*argv);
X              shellbuf = BETWEEN(5,shellbuf,1024);
X              break;
X         case 'B':	/* set window buffering */
X              maxbuf = atoi(*argv);
X              maxbuf = BETWEEN(1,maxbuf,shellbuf);
X              break;
X         case 'f':	/* set font directory */
X              font_dir = *argv;
X              type = 1;
X              break;
X         case 'i':	/* set icon directory */
X              icon_dir = *argv;
X              type = 1;
X              break;
X         case 'S':	/* set alternate frame buffer */
X              screen_dev = *argv;
X              type = 1;
X              break;
X         default:	/* invalid flag */
X             fprintf(stderr,"Invalid flag %c, ignored\r\n",type);
X              type = 1;
X              break;
X         }
X      }
X
X   /* keep mgr from being run within itself */
X
X   if (term && strcmp(TERMNAME,term)==0) {
X      fprintf(stderr,"Can't invoke mgr from within itself\n");
X      exit(1);
X      }
X   /* save tty modes for ptty's */
X
X   save_modes(0);
X
X   /* free all unused fd's */
X
X   count = getdtablesize();
X   for(i=3;i<count;i++)
X      close(i);
X
X#ifdef WHO
X   save_utmp(ttyname(0));
X#endif
X
X   /* initialize the keyboard; sometimes a special device */
X   initkbd();
X
X   /* initialize the bell; sometimes a special device requiring funnys */
X   initbell();
X
X   /* get the default font file */
X
X   if (default_font || (default_font = getenv(DEFAULT_FONT)))
X      font = open_font(default_font);
X
X   if (font == (struct font *) 0)
X      font = open_font("");
X   font->ident = 0;
X
X   /* set up the default font names */
X
X   /* open the mouse */
X
X   if ((mouse=open(mouse_dev,2)) <0) {
X      perror("can't find the mouse, or it is already in use\n");
X      exit(1);
X      }
X
X   if (set_mouseio(mouse) < 0)
X      fprintf(stderr,"can't set mouse to exclusive use\n");
X
X   mousex=mousey=32;
X
X   /* find the screen */
X
X#ifdef SHRINK			/* for sdh */
X
X#ifndef X0
X# define X0 64
X#endif
X#ifndef Y0
X# define Y0 64
X#endif
X#ifndef W0
X# define W0 1024
X#endif
X#ifndef H0
X# define H0 772
X#endif
X
X   if ((prime = bit_open(screen_dev)) == (BITMAP *) 0) {
X      perror("can't find the screen");
X      exit(2);
X      }
X   screen = bit_create(prime,X0&~0xf,Y0&~0xf,W0&~0xf,H0&~0xf);
X#else
X   if ((screen = bit_open(screen_dev)) == (BITMAP *) 0) {
X      perror("can't find the screen");
X      exit(2);
X      }
X#endif
X
X   copyright(screen);
X
X   set_tty(0);
X
X   SETMOUSEICON(&mouse_cup);
X
X   /* catch the right interrupts */
X
X   for(i=0;i<NSIG;i++) switch(i) {
X      case SIGCHLD:     signal(SIGCHLD,sig_child);
X                        break;
X      case SIGILL:	/* <= 3.0 abort gererates this one */
X      case SIGCONT:
X      case SIGIOT:	/* 3.2 abort generates this (gee thanks, SUN!) */
X      case SIGQUIT:
X                        break;
X      case SIGTTIN:
X      case SIGTTOU:     signal(i,SIG_IGN);
X                        break;
X      default:          signal(i,catch);
X                        break;
X      }
X
X   /* set the terminal type */
X
X   if (term && strlen(term) >= strlen(TERMNAME))
X      strcpy(term,TERMNAME);
X
X	/* get default font definitions */
X
X      {
X      char buff[MAX_PATH];
X      sprintf(buff,"%s/%s",font_dir,STARTFILE);
X      startup(buff);
X      }
X
X   /* process startup file */
X
X   startup(start_file);
X   if (active != (WINDOW *) 0)
X      ACTIVE_ON();
X   else {
X      MOUSE_OFF(mousex,mousey);
X      erase_win(screen,0,0);
X      MOUSE_ON(mousex,mousey);
X   }
X
X   /* turn on mouse cursor */
X
X   MOUSE_OFF(mousex,mousey);
X   SETMOUSEICON(&mouse_arrow);
X   MOUSE_ON(mousex,mousey);
X
X   /* void tty association 		(does bad things when mgr crashes) */
X
X   /*  void_tty();       Flakey ... Commented Out! */
X
X   /* always look for keyboard and mouse input */
X
X   mask |= (1<<mouse) | (1<<0); 
X
X   /* main polling loop */
X
X   while(1) {
X
X      /* see if any window died */
X
X      for(win=active;win != (WINDOW *) 0;) 
X         if (W(flags)&W_DIED) {
X#ifdef DEBUG
X            dprintf(d)(stderr,"Destroying %s-%d\r\n",W(tty),W(num));
X#endif
X            destroy(win);
X            win = active;
X            }
X         else
X            win = W(next);
X
X      /* wait for input */
X
X      reads = mask & ~poll;
X
X#ifdef DEBUG
X      dprintf(l)(stderr,"select: mask=0x%x poll=0x%x 0x%x got\r\n",
X                 mask,poll,reads);
X#endif
X#ifdef sun
X      if (select(32,&reads,0,0,POLL(poll)) <0) {
X#ifdef DEBUG
X         dprintf(l)(stderr,"select failed %d->%d\r\n",
X                 reads, mask & ~poll);
X         if (debug) 
X            perror("Select:");
X#endif
X         reads = mask & ~poll;
X         continue;
X         }
X#else
X	????? /* I need to package up select some how */
X#endif
X#ifdef DEBUG
X      dprintf(l)(stderr,"0x%x\r\n",reads);
X#endif
X
X      /* process mouse */
X
X      if (reads & (1<<mouse))
X         do {
X            proc_mouse(mouse);
X            }
X         while(mouse_count());
X      
X      /* process keyboard input */
X      
X      if (reads&1 && active && !(ACTIVE(flags)&W_NOINPUT)) {
X         read(0,&c,1);
X#ifdef BUCKEY
X         if ( (ACTIVE(flags)&W_NOBUCKEY)  ||  !do_buckey(c) )
X            write(ACTIVE(to_fd),&c,1);
X#else
X         write(ACTIVE(to_fd),&c,1);
X#endif
X			if (ACTIVE(flags)&W_DUPKEY && c==ACTIVE(dup))
X         	write(ACTIVE(to_fd),&c,1);
X         continue;
X         }
X       else if (reads&1 && !active) {		/* toss the input */
X         read(0,&c,1);
X#ifdef BUCKEY
X         do_buckey(c);
X#endif
X	 }
X
X      /* process shell output */
X
X      for(win=active;win != (WINDOW *) 0;win=W(next)) {
X         register int fd_bit = W(from_fd) ? 1<<W(from_fd) : 0;
X
X         /* read data into buffer */
X
X         if (fd_bit&reads&(~poll)) {
X            W(current) = 0;
X            if ((W(max) = read(W(from_fd),W(buff),shellbuf)) > 0) {
X               poll |= fd_bit;
X#ifdef DEBUG
X               dprintf(p)(stderr,"%s: reading %d [%.*s]\r\n",W(tty),
X                     W(max),W(max),W(buff));
X#endif
X               }
X            else {
X               poll &= ~fd_bit;
X#ifdef KILL
X               if (W(flags)&W_NOKILL)
X                  W(flags) |= W_DIED;
X#endif
X#ifdef DEBUG
X               if(debug) {
X                  fprintf(stderr,"%s: Select boo-boo fd(%d) code %d\r\n",
X                          W(tty),W(from_fd),W(max));
X                  perror(W(tty)); 
X                  }
X#endif
X               }
X            }
X 
X         /* check for window to auto-expose */
X
X         if (fd_bit&poll && W(flags)&W_EXPOSE && !(W(flags)&W_ACTIVE)) {
X#ifdef DEBUG
X            dprintf(m)(stderr,"%s: activating self\r\n",W(tty));
X#endif
X            MOUSE_OFF(mousex,mousey);
X            cursor_off();
X            ACTIVE_OFF();
X            expose(win);
X            ACTIVE_ON();
X            cursor_on();
X            MOUSE_ON(mousex,mousey);
X            }
X
X         /* write data into the window */
X
X         if (fd_bit&poll && W(flags)&(W_ACTIVE|W_BACKGROUND)) {
X            
X#ifdef PRIORITY			/* use priority scheduling */
X            if (win==active)
X               count = Min(maxbuf,W(max)-W(current));
X            else if (W(flags)&W_ACTIVE)
X               count = Min(maxbuf>>1,W(max)-W(current));
X            else
X               count = Min(maxbuf>>2,W(max)-W(current));
X#else				/* use round robin scheduling */
X            count = Min(maxbuf,W(max)-W(current));
X#endif
X
X            i = put_window(win,W(buff)+W(current),count);
X#ifdef DEBUG
X            dprintf(w)(stderr,"%s: writing %d/%d %.*s [%.*s]\r\n",
X                       W(tty),i,count,i,W(buff)+W(current),count-i,
X                       W(buff)+W(current)+i);
X#endif
X
X            W(current) += i;
X            if (W(current) >= W(max))
X               poll &= ~fd_bit;
X            }
X         }
X      }
X   }
X
X/*************************************************************************
X *	catch dead children 
X */
X
Xsig_child(sig)
Xint sig;
X   {
X   register WINDOW *win;
X   extern int errno;
X
X   /* see if a shell has died, mark deleted */
X
X#ifdef DEBUG
X   dprintf(d)(stderr,"Looking for dead windows\r\n");
X#endif
X
X   for(win=active;win != (WINDOW *) 0;win=W(next)) {
X      if (kill(W(pid),0) != 0 && !(W(flags)&W_NOKILL)) {
X         W(flags) |= W_DIED;
X#ifdef DEBUG
X         dprintf(d)(stderr, "%s-%d DIED\r\n",W(tty),W(num));
X#endif
X         }
X      }
X   }
X
X/* process mouse */
X
Xint
Xproc_mouse(mouse)
Xint mouse;
X   {
X   int dx, dy;
X   static int still_down = 0;
X   register int button, done = 0;
X
X   do {
X      button = mouse_get(mouse,&dx,&dy);
X      MOUSE_OFF(mousex,mousey);
X      mousex += 2*dx;
X      mousey -= 2*dy;
X      mousex = BETWEEN(0,mousex,BIT_WIDE(screen)-1);
X      mousey = BETWEEN(0,mousey,BIT_HIGH(screen)-1);
X      if (button != button_state) {
X         do_button( button );
X         done++;
X         }
X      MOUSE_ON(mousex,mousey);
X      } while (mouse_count() && !done);
X   return(done);
X   }
X
X/* reopen the mouse after suspend */
X      
Xint
Xmouse_reopen()
X   {
X   int m = open(mouse_dev,2);
X   set_mouseio(m);
X   return(m);
X   }
X
X/* return bitmap type */
X
Xint
Xget_bm_type()
X   {
X   return (bitmaptype);
X   }
END_OF_FILE
# end of 'src/mgr.c'
fi
echo shar: End of archive 37 \(of 61\).
cp /dev/null ark37isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
