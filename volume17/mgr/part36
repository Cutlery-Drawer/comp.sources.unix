Subject:  v17i037:  MGR, Bellcore window manager, Part36/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 37
Archive-name: mgr/part36




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 36 (of 61)."
# Contents:  demo/icon/mail_icons.h demo/misc/maze.c src/Makefile
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:45 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'demo/icon/mail_icons.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/icon/mail_icons.h'\"
else
echo shar: Extracting \"'demo/icon/mail_icons.h'\" \(12881 characters\)
sed "s/^X//" >'demo/icon/mail_icons.h' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: mail_icons.h,v 4.1 88/06/21 14:00:02 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/icon/RCS/mail_icons.h,v $
X*/
Xstatic char	h_mail_icons_[] = "$Source: /tmp/mgrsrc/demo/icon/RCS/mail_icons.h,v $$Revision: 4.1 $";
X
X
X/* icon: mbox_closed */
X
Xunsigned char mbox_closed_data[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfe, 0x00, 
X   0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x27, 0x00, 
X   0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x28, 0x80, 0x00, 0x00, 0x00, 0x80, 
X   0x00, 0x00, 0x30, 0x4e, 0x38, 0x00, 0x00, 0x80, 0x00, 0x00, 0x20, 0x46, 
X   0x30, 0x40, 0x00, 0xc0, 0x00, 0x00, 0x20, 0x45, 0x50, 0xa3, 0x90, 0x40, 
X   0x00, 0x00, 0x3c, 0x44, 0x91, 0x11, 0x10, 0x40, 0x00, 0x00, 0x3c, 0x44, 
X   0x91, 0x11, 0x10, 0x40, 0x00, 0x00, 0xe4, 0x44, 0x11, 0xf1, 0x10, 0x40, 
X   0x00, 0x00, 0xe4, 0x44, 0x11, 0x11, 0x12, 0x40, 0x00, 0x00, 0x24, 0x44, 
X   0x11, 0x11, 0x1c, 0x40, 0x00, 0x00, 0x24, 0x44, 0x11, 0x13, 0x80, 0x40, 
X   0x00, 0x00, 0x24, 0x44, 0x11, 0x38, 0x01, 0xc0, 0x00, 0x00, 0x24, 0x44, 
X   0x13, 0x80, 0x0f, 0x00, 0x00, 0x00, 0x30, 0x44, 0x38, 0x00, 0x70, 0x00, 
X   0x00, 0x00, 0x18, 0x4e, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x0c, 0x40, 
X   0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x06, 0x40, 0x0f, 0xc0, 0x00, 0x00, 
X   0x00, 0x00, 0x03, 0x40, 0x78, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc1, 
X   0xc4, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x24, 0x40, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x78, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 
X   0xa4, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x24, 0x40, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x2d, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 
X   0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x24, 0x43, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x05, 0xa4, 0x5e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 
X   0xe4, 0x6c, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x64, 0xf0, 0x40, 0x00, 
X   0x00, 0x00, 0x00, 0x20, 0x64, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x25, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x80, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x35, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x1e, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   };
X
Xstruct icon mbox_closed = {
X   "mbox_closed",1,64,64,mbox_closed_data};
X
X
X/* icon: mbox_full */
X
Xunsigned char mbox_full_data[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfe, 0x00, 
X   0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x37, 0x00, 
X   0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2f, 0x80, 0x00, 0x00, 0x00, 0x80, 
X   0x00, 0x00, 0x7f, 0x8e, 0x38, 0x00, 0x00, 0x80, 0x00, 0x3f, 0xff, 0xc6, 
X   0x30, 0x40, 0x00, 0xc0, 0x00, 0x20, 0x00, 0x45, 0x50, 0xa3, 0x90, 0x40, 
X   0x00, 0x26, 0x41, 0xc4, 0x91, 0x11, 0x10, 0x40, 0x00, 0x20, 0xab, 0x44, 
X   0x91, 0x11, 0x10, 0x40, 0x00, 0x10, 0x1c, 0xc4, 0x11, 0xf1, 0x10, 0x40, 
X   0x00, 0x13, 0xe0, 0xc4, 0x11, 0x11, 0x12, 0x40, 0x00, 0x7c, 0x01, 0x44, 
X   0x11, 0x11, 0x1c, 0x40, 0x00, 0x60, 0x02, 0x44, 0x11, 0x13, 0x80, 0x40, 
X   0x00, 0x7f, 0xfc, 0x44, 0x11, 0x38, 0x01, 0xc0, 0x00, 0x40, 0x00, 0x44, 
X   0x13, 0x80, 0x0f, 0x00, 0x00, 0x60, 0x00, 0x44, 0x38, 0x00, 0x70, 0x00, 
X   0x00, 0x20, 0x03, 0xce, 0x00, 0x07, 0x80, 0x00, 0x00, 0x20, 0x0e, 0x40, 
X   0x00, 0x78, 0x00, 0x00, 0x00, 0x20, 0xf6, 0x40, 0x0f, 0xc0, 0x00, 0x00, 
X   0x00, 0x27, 0x83, 0x40, 0x78, 0x40, 0x00, 0x00, 0x00, 0x38, 0x01, 0xc1, 
X   0xc4, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x24, 0x40, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x78, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 
X   0xa4, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x24, 0x40, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x2d, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 
X   0x24, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x24, 0x43, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x05, 0xa4, 0x5e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 
X   0xe4, 0x6c, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x64, 0xf0, 0x40, 0x00, 
X   0x00, 0x00, 0x00, 0x20, 0x64, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x25, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x80, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x35, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x1e, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   };
X
Xstruct icon mbox_full = {
X   "mbox_full",1,64,64,mbox_full_data};
X
X
X/* icon: mbox_open */
X
Xunsigned char mbox_open_data[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfe, 0x00, 
X   0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x27, 0x00, 
X   0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2d, 0x80, 0x00, 0x00, 0x00, 0x80, 
X   0x00, 0x00, 0x3a, 0x8e, 0x38, 0x00, 0x00, 0x80, 0x00, 0x00, 0x35, 0x46, 
X   0x30, 0x40, 0x00, 0xc0, 0x00, 0x00, 0x3a, 0xc5, 0x50, 0xa3, 0x90, 0x40, 
X   0x00, 0x00, 0x35, 0x44, 0x91, 0x11, 0x10, 0x40, 0x00, 0x00, 0x3a, 0xc4, 
X   0x91, 0x11, 0x10, 0x40, 0x00, 0x00, 0x35, 0x44, 0x11, 0xf1, 0x10, 0x40, 
X   0x00, 0x00, 0x3a, 0xc4, 0x11, 0x11, 0x12, 0x40, 0x00, 0x00, 0x35, 0x44, 
X   0x11, 0x11, 0x1c, 0x40, 0x00, 0x00, 0x3a, 0xc4, 0x11, 0x13, 0x80, 0x40, 
X   0x00, 0x00, 0x35, 0x44, 0x11, 0x38, 0x01, 0xc0, 0x00, 0x00, 0x3a, 0xc4, 
X   0x13, 0x80, 0x0f, 0x00, 0x00, 0x00, 0x35, 0x44, 0x38, 0x00, 0x70, 0x00, 
X   0x00, 0x00, 0x1a, 0xce, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x4d, 0x40, 
X   0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0xe6, 0xc0, 0x0f, 0xc0, 0x00, 0x00, 
X   0x00, 0x00, 0xb3, 0x40, 0x78, 0x40, 0x00, 0x00, 0x00, 0x01, 0x99, 0xc1, 
X   0xc4, 0x40, 0x00, 0x00, 0x00, 0x01, 0x0c, 0x86, 0x24, 0x40, 0x00, 0x00, 
X   0x00, 0x03, 0x06, 0x78, 0x24, 0x40, 0x00, 0x00, 0x00, 0x02, 0x03, 0x00, 
X   0x24, 0x40, 0x00, 0x00, 0x00, 0x06, 0x01, 0x80, 0x24, 0x40, 0x00, 0x00, 
X   0x00, 0x04, 0x01, 0x80, 0x24, 0x40, 0x00, 0x00, 0x00, 0x0c, 0x01, 0x80, 
X   0x24, 0x40, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x24, 0x40, 0x00, 0x00, 
X   0x00, 0x08, 0x03, 0x00, 0x24, 0x40, 0x00, 0x00, 0x00, 0x0c, 0x02, 0x29, 
X   0xa4, 0x40, 0x00, 0x00, 0x00, 0x04, 0x06, 0x19, 0x24, 0x40, 0x00, 0x00, 
X   0x00, 0x06, 0x0c, 0x2d, 0x24, 0x40, 0x00, 0x00, 0x00, 0x03, 0x38, 0x77, 
X   0x24, 0x40, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x0f, 0x24, 0x43, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x05, 0xa4, 0x5e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 
X   0xe4, 0x6c, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x64, 0xf0, 0x40, 0x00, 
X   0x00, 0x00, 0x00, 0x20, 0x64, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x25, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x80, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x35, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x1e, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   };
X
Xstruct icon mbox_open = {
X   "mbox_open",1,64,64,mbox_open_data};
X
X
X/* icon: mbox_zip */
X
Xunsigned char mbox_zip_data[] = {
X   0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf8, 0x00, 
X   0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xfe, 0x00, 
X   0x00, 0x00, 0x7f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x00, 
X   0x00, 0x03, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x07, 0xff, 0xff, 0xfc, 0x00, 
X   0x00, 0x0f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf0, 0x00, 
X   0x00, 0x3f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xe0, 
X   0x00, 0xff, 0xff, 0xff, 0xf0, 0x1e, 0x01, 0xff, 0xff, 0xff, 0xf0, 0x21, 
X   0x03, 0xff, 0x87, 0xff, 0xf8, 0x06, 0x07, 0xf8, 0x07, 0xff, 0xf8, 0x78, 
X   0x07, 0x80, 0x07, 0xff, 0xfd, 0x80, 0x0e, 0x00, 0x07, 0xff, 0xfe, 0x00, 
X   0x18, 0x00, 0x07, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf0, 0x00, 
X   0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x00, 
X   0x00, 0x00, 0x07, 0xff, 0x80, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 
X   0x00, 0x00, 0x1f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 
X   0x00, 0x00, 0x7f, 0xdf, 0x00, 0x00, 0x00, 0x00, 0xff, 0x9e, 0x00, 0x00, 
X   0x00, 0x01, 0xff, 0x1e, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x1a, 0x00, 0x00, 
X   0x00, 0x07, 0xfc, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf0, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x7f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xc0, 
X   0x00, 0x7f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x60, 0x30, 0x41, 0x98, 0x00, 0x20, 0x70, 0x70, 0xe1, 0x98, 0x04, 
X   0x20, 0x78, 0xf0, 0xe1, 0x98, 0x04, 0xf8, 0x7d, 0xf1, 0xb1, 0x98, 0x1f, 
X   0x70, 0x6f, 0xb1, 0xb1, 0x98, 0x0e, 0x50, 0x67, 0x33, 0xf9, 0x98, 0x0a, 
X   0x88, 0x62, 0x33, 0xf9, 0x98, 0x11, 0x00, 0x60, 0x37, 0x0d, 0x9f, 0xc0, 
X   0x00, 0x60, 0x36, 0x0d, 0x9f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xc0, 
X   0x00, 0x7f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xc0, 
X   };
X
Xstruct icon mbox_zip = {
X   "mbox_zip",1,48,52,mbox_zip_data};
X
END_OF_FILE
# end of 'demo/icon/mail_icons.h'
fi
if test -f 'demo/misc/maze.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/misc/maze.c'\"
else
echo shar: Extracting \"'demo/misc/maze.c'\" \(12767 characters\)
sed "s/^X//" >'demo/misc/maze.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/* mgr version */
X/* ************************************************************ *\
X
X	maze.c		
X
X	Author: JGosling
X	Information Technology Center
X	Carnegie-Mellon University
X
X	(c) Copyright IBM Corporation, 1985
X	Written: 28.July.1984
X
X
X\* ************************************************************ */
X
Xstatic char rcsid[] = "$Header: maze.c,v 4.2 88/06/22 14:37:47 bianchi Exp $";
Xstatic char IBMid[] = "(c) Copyright IBM Corporation, 1985";
X
X/* ************************************************************ */
X/*								*/
X/*	$Log:	maze.c,v $
X * Revision 4.2  88/06/22  14:37:47  bianchi
X * remove version.h
X * 
X * Revision 4.1  88/06/21  13:42:38  bianchi
X * convert copyright notice to public distribution form
X * 
X * Revision 2.1  88/01/19  18:00:58  bianchi
X * add ckmgrterm()
X * 
X * Revision 1.2  87/12/18  09:28:28  bianchi
X * add copyright
X * 
X * Revision 1.1  87/07/27  16:29:27  bianchi
X * initial version
X * 
X * Revision 1.2  85/01/29  02:42:30  peterson
X * . Add standard header and copyright
X * 							*/
X/*								*/
X/* ************************************************************ */
X
X/* A simple maze wars game to test out user level graphics */
X
X#include <stdio.h>
X#include "term.h"
X#include <errno.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <netdb.h>
X#include <arpa/inet.h>
X
Xint errno;
X
Xint Redraw = 1;
Xint debug = 0;
Xint _func = -1;
X
X#define dprintf		if(debug)fprintf
X#define SERVER	"mazewar"
X
X#define M_func(n)	(_func!=n ? (m_func(n),_func=n) : 0)
X
X#define MazeWidth 15
X#define MazeHeight (sizeof MazeWalls/MazeWidth)
Xchar MazeWalls[] = {
X1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
X1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
X1,1,0,1,0,1,0,1,1,1,0,1,1,0,1,
X1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,
X1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,
X1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,
X1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,
X1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,
X1,1,0,1,0,1,0,0,0,0,0,1,0,0,1,
X1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,
X1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,
X1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,
X1,0,0,0,1,0,0,0,1,1,1,1,0,1,1,
X1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,
X1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
X};
X/*
Xchar MazeWalls[] = {
X1,1,1,1,1,1,1,1,1,1,
X1,0,0,0,0,0,0,0,0,1,
X1,0,1,1,1,0,1,1,0,1,
X1,0,0,1,0,0,0,0,1,1,
X1,1,1,1,0,1,1,0,0,1,
X1,0,0,0,0,1,0,1,0,1,
X1,1,0,1,1,1,0,0,0,1,
X1,1,0,1,1,0,0,1,0,1,
X1,0,0,0,0,0,1,1,0,1,
X1,1,1,1,1,1,1,1,1,1,
X};
X*/
X
Xstruct DirectionOffsets {
X	char left, right, forward, backward;
X} DirectionOffsets[4] = {
X	{ -1, 1, -MazeWidth, MazeWidth }, /* facing up */
X	{ -MazeWidth, MazeWidth, 1, -1 }, /* facing right */
X	{ 1, -1, MazeWidth, -MazeWidth }, /* facing down */
X	{ MazeWidth, -MazeWidth, -1, 1 }  /* facing left */
X};
X
Xstruct state {
X    int id;
X    short position, direction;
X};
X
Xstruct state me, him;
X#define HashSize 47
Xstruct state others[HashSize];
X
Xstruct state *SlotsUsed[HashSize];
Xint NOthers;
X
Xint direction = 1;
Xint position = MazeWidth+1;
Xint BogyDistance = 999;
Xstruct state *BogyId;
Xint BogyRDir;
X
Xint swidth, sheight;
Xint fwidth, fheight;
X
Xint displaystate[MazeWidth+1];
Xint MaxDepth;
X
Xcx, cy;
X
X#define ForwardFrom(p) ((p)+DirectionOffsets[direction].forward)
X#define BackwardFrom(p) ((p)+DirectionOffsets[direction].backward)
X#define LeftFrom(p) ((p)+DirectionOffsets[direction].left)
X#define RightFrom(p) ((p)+DirectionOffsets[direction].right)
X
X#define At(p) MazeWalls[p]
X#define AtForward(p) MazeWalls[ForwardFrom(p)]
X#define AtBackward(p) MazeWalls[BackwardFrom(p)]
X#define AtLeft(p) MazeWalls[LeftFrom(p)]
X#define AtRight(p) MazeWalls[RightFrom(p)]
X
XDrawFrom (p, w, h)
Xregister    p; {
X    int     depth = 0;
X    int     nmax = 0;
X    if (BogyId) {
X	DrawEye (BogyDistance, BogyRDir);
X	BogyDistance = 9999;
X	BogyId = 0;
X    }
X    M_func(B_INVERT);
X    while (!At (p) || depth <= MaxDepth) {
X	register    iw = w * 4 / 5;
X	register    ih = h * 4 / 5;
X	register    ThisMask = 0;
X	register    DoMask;
X	if (depth && BogyId == 0) {
X	    register struct state **f;
X	    for (f = SlotsUsed; *f; f++)
X		if ((*f) -> position == p) {
X		    DrawEye (depth, BogyRDir = (*f) -> direction - direction);
X		    BogyDistance = depth;
X		    BogyId = *f;
X		}
X	}
X	if (!At (p)) {
X	    nmax = depth;
X	    if (AtLeft (p))
X		ThisMask |= 1 << 0;
X	    if (AtRight (p))
X		ThisMask |= 1 << 1;
X	    if (AtForward (p))
X		ThisMask |= 1 << 2;
X	    if (!AtLeft (p) && AtForward (LeftFrom (p)))
X		ThisMask |= 1 << 3;
X	    if (!AtRight (p) && AtForward (RightFrom (p)))
X		ThisMask |= 1 << 4;
X	    if (((AtRight (p) + AtForward (p) + AtRight (ForwardFrom (p))) & 1)
X		    || (AtRight (p) && AtForward (p)))
X		ThisMask |= 1 << 5;
X	    if (((AtLeft (p) + AtForward (p) + AtLeft (ForwardFrom (p))) & 1)
X		    || (AtLeft (p) && AtForward (p)))
X		ThisMask |= 1 << 6;
X	    p = ForwardFrom (p);
X	}
X	DoMask = depth > MaxDepth ? ThisMask : displaystate[depth] ^ ThisMask;
X	displaystate[depth] = ThisMask;
X
X/****************************************************************/
X
X	if (DoMask & (1 << 0)) {
X	    m_go (cx - w + 1, cy - h + 1);
X	    m_draw (cx - iw, cy - ih);
X	    m_go (cx - w + 1, cy + h - 1);
X	    m_draw (cx - iw, cy + ih);
X	}
X	if (DoMask & (1 << 1)) {
X	    m_go (cx + w - 1, cy - h + 1);
X	    m_draw (cx + iw, cy - ih);
X	    m_go (cx + w - 1, cy + h - 1);
X	    m_draw (cx + iw, cy + ih);
X	}
X	if (DoMask & (1 << 2)) {
X	    m_go (cx - iw, cy - ih);
X	    m_draw (cx + iw, cy - ih);
X	    m_go (cx - iw, cy + ih);
X	    m_draw (cx + iw, cy + ih);
X	}
X	if (DoMask & (1 << 3)) {
X	    m_go (cx - w + 1, cy - ih);
X	    m_draw (cx - iw, cy - ih);
X	    m_go (cx - w + 1, cy + ih);
X	    m_draw (cx - iw, cy + ih);
X	}
X	if (DoMask & (1 << 4)) {
X	    m_go (cx + w - 1, cy - ih);
X	    m_draw (cx + iw, cy - ih);
X	    m_go (cx + w - 1, cy + ih);
X	    m_draw (cx + iw, cy + ih);
X	}
X	if (DoMask & (1 << 5)) {
X	    m_go (cx + iw, cy - ih);
X	    m_draw (cx + iw, cy + ih);
X	}
X	if (DoMask & (1 << 6)) {
X	    m_go (cx - iw, cy - ih);
X	    m_draw (cx - iw, cy + ih);
X	}
X	w = iw;
X	h = ih;
X	depth++;
X    }
X    MaxDepth = nmax;
X}
X
XFlagRedraw () {
X    Redraw++;
X}
X
XCanSee (him) {
X    register    p;
X    register    depth = 1;
X    for (p = position; ((p = ForwardFrom (p)), p>0 && p<MazeWidth*MazeWidth && !At (p)); depth++)
X	if (p == him)
X	    return depth;
X    return 0;
X}
X
XDrawEye (depth, rdir) {
X    register    r = cy < cx ? cy : cx;
X    register    sr;
X    while (--depth >= 0)
X	r = r * 4 / 5;
X    sr = r / 3;
X    m_go (cx - sr, cy - r);
X    m_draw (cx + sr, cy - r);
X    m_draw (cx + r, cy - sr);
X    m_draw (cx + r, cy + sr);
X    m_draw (cx + sr, cy + r);
X    m_draw (cx - sr, cy + r);
X    m_draw (cx - r, cy + sr);
X    m_draw (cx - r, cy - sr);
X    m_draw (cx - sr, cy - r);
X    while (rdir < 0)
X	rdir += 4;
X    switch (rdir) {
X	case 2: 
X	    m_go (cx - r, cy);
X	    m_draw (cx, cy - sr);
X	    m_draw (cx + r, cy);
X	    m_draw (cx, cy + sr);
X	    m_draw (cx - r, cy);
X	    break;
X	case 3: 
X	    m_go (cx - r, cy - sr);
X	    m_draw (cx, cy);
X	    m_draw (cx - r, cy + sr);
X	    break;
X	case 1: 
X	    m_go (cx + r, cy - sr);
X	    m_draw (cx, cy);
X	    m_draw (cx + r, cy + sr);
X	    break;
X    }
X}
X
XDrawMaze (xo, yo, width, height) {
X    register    x,
X                y;
X    M_func(B_OR);
X    for (x = 0; x < MazeWidth; x++)
X	for (y = 0; y < MazeHeight; y++)
X	    if (At (y * MazeWidth + x))
X                m_bitwrite(xo + x * width / MazeWidth,
X			yo + y * height / MazeHeight,
X			(x + 1) * width / MazeWidth - x * width / MazeWidth ,
X			(y + 1) * height / MazeHeight - y * height / MazeHeight );
X}
X
XDrawAllArrows () {
X    register struct state **f;
X    DrawArrow (position,direction);
X    for (f = SlotsUsed; *f; f++)
X    DrawArrow ((*f)->position,(*f)->direction);
X}
X
XDrawArrow (position, direction) {
X    static char *arrow[4] = {
X	"^", ">", "v", "<"
X    };
X    register    x = position % MazeWidth;
X    register    y = position / MazeWidth;
X    M_func(B_XOR);
X    m_moveprint ((((x << 1) + 1) * swidth / MazeWidth) >> 1,
X	    ((((y << 1) + 1) * cy / MazeHeight) >> 1) + cy * 2 + (fheight>>1),
X	    arrow[direction]);
X    m_movecursor(0,0);
X}
X
XUpdateOther () {
X    register struct state  *s = &others[him.id % HashSize];
X    register dist;
X    while (s -> id && s -> id != him.id) {
X	s--;
X	if (s < others)
X	    s = others + HashSize - 1;
X    }
X    M_func(B_XOR);
X    if (s -> id == 0)
X	SlotsUsed[NOthers++] = s;
X    else {
X	DrawArrow (s -> position, s -> direction);
X	if (s == BogyId) {
X	    DrawEye (BogyDistance, BogyRDir);
X	    BogyDistance = 9999;
X	    BogyId = 0;
X	}
X    }
X    if ((dist = CanSee (him.position)) && dist<BogyDistance) {
X	BogyDistance = dist;
X	BogyId = s;
X	DrawEye (BogyDistance, BogyRDir = him.direction - direction);
X    }
X    *s = him;
X    DrawArrow (s -> position, s -> direction);
X}
X
Xstruct sockaddr_in  sin, sout;
X
Xint     RecvSocket,
X        SendSocket,
X        rmask;
X
Xmain( argc, argv )
Xint	argc;
Xchar	*argv[];
X{
X    char *getenv();
X    int net;
X    struct hostent *hp;
X    struct servent *sp;
X    struct netent  *np;
X    char host[32];
X    int id;
X
X    ckmgrterm( *argv );
X
X    if (getenv("DEBUG")) {
X       debug++;
X       }
X
X    m_setup(0);
X    m_push(P_FLAGS|P_EVENT);
X    m_setmode(M_ABS);
X    m_setmode(M_OVERSTRIKE);
X    M_func(B_SRC);
X    m_setevent(REDRAW,"R");
X    m_setevent(RESHAPE,"R");
X    m_ttyset();
X    m_setraw();
X    m_setnoecho();
X
X    if ((RecvSocket = socket (AF_INET, SOCK_DGRAM, 0)) < 0)
X       perror("recv socket");
X    if ((SendSocket = socket (AF_INET, SOCK_DGRAM, 0)) < 0)
X       perror("send socket");
X
X    rmask = (1 << fileno (m_termin)) | (1 << RecvSocket);
X    gethostname(host,sizeof(host)-1);
X    if ((hp=gethostbyname(host)) == NULL)
X       perror("gethostbyname");
X    if ((sp=getservbyname(SERVER,"udp")) ==0)
X       perror("Unknown service");
X    net = inet_netof(*((struct in_addr *)hp->h_addr));
X    id = inet_lnaof(*((struct in_addr *)hp->h_addr));
X
X    sin.sin_family = hp->h_addrtype;
X    if (sp>0) {
X        sin.sin_port = sp->s_port;
X        sin.sin_addr = inet_makeaddr(net,INADDR_ANY);
X        setsockopt (RecvSocket, SOL_SOCKET, SO_REUSEADDR, 0, 0);
X        sout = sin;
X        }
X
X    dprintf(stderr,"host: %s port: %ld, network %d service: %s\n",
X           hp->h_name, sp->s_port, net, sp->s_name);
X    if (bind (RecvSocket, &sin, sizeof sin) < 0)
X	perror ("bind");
X
X    me.id = (getpid () << 16) + id;
X
X    FlagRedraw ();
X    while (1) {
X	    me.position = position;
X	    me.direction = direction;
X	    if (sp>0 && sendto (SendSocket, (char *) &me, sizeof me, 0, &sout, sizeof sout)
X                        != sizeof me)
X		perror ("sendto");
X            else
X                dprintf(stderr,"Sent %d %d %d\n",
X                        me.id,me.direction,me.position);
X	if (Redraw) {
X            get_size(0,0,&swidth,&sheight);
X            get_font(&fwidth,&fheight);
X	    M_func(B_SET);
X	    cx = swidth / 2;
X	    cy = sheight / 3;
X	    m_clear();
X	    DrawMaze (0, 2 * cy, swidth, cy);
X	    Redraw = 0;
X	    MaxDepth = -1;
X	}
X	DrawFrom (position, cx, cy);
X	M_func(B_OR);
X	DrawAllArrows ();
X	{
X	    register    op = position;
X	    register    c;
X	    while (1) {
X		int     raction = rmask;
X		m_flush();
X                dprintf(stderr,"Select %x...",raction); fflush(stderr);
X		select (32, &raction, 0, 0, 0);
X                dprintf(stderr," got %x\n",raction);
X		if ((raction & (1 << RecvSocket))
X			&& read (RecvSocket, (char *)&him, sizeof him) == sizeof him) {
X                    dprintf(stderr,"Got %d (%d) %d %d\n",
X                            him.id,me.id,him.direction,him.position);
X		    if (him.id != me.id && him.direction < 4)
X			UpdateOther ();
X		}
X		else
X		    perror ("read");
X		if (Redraw || (raction & (1 << fileno (m_termin))))
X		    break;
X	    };
X	    if (!Redraw) {
X		c = getc (m_termin);
X	        M_func(B_OR);
X		DrawAllArrows ();
X	    }
X	    else
X		if (errno != EINTR)
X		    break;
X		else {
X		    errno = 0;
X		    continue;
X		}
X	    switch (c & 0177) {
X		case ' ': 
X		case 'f': 
X		case '8': 
X		    position = ForwardFrom (position);
X		    break;
X		case 'l': 
X		case '4': 
X		    if (--direction < 0)
X			direction = 3;
X		    break;
X		case 'r': 
X		case '6': 
X		    if (++direction > 3)
X			direction = 0;
X		    break;
X		case 'b': 
X		case '2': 
X		    position = BackwardFrom (position);
X		    break;
X                case 'R':
X                    FlagRedraw();
X                    break;
X		case 'q': 
X		case 3: 	/* ^C */
X		    m_ttyreset();
X                    m_clear();
X                    m_pop();
X		    exit (1);
X		    break;
X	    }
X	    if (At (position))
X		position = op;
X	}
X    }
X}
END_OF_FILE
# end of 'demo/misc/maze.c'
fi
if test -f 'src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile'\"
else
echo shar: Extracting \"'src/Makefile'\" \(13038 characters\)
sed "s/^X//" >'src/Makefile' <<'END_OF_FILE'
X#                        Copyright (c) 1987 Bellcore
X#                            All Rights Reserved
X#       Permission is granted to copy or use this program, EXCEPT that it
X#       may not be sold for profit, the copyright notice must be reproduced
X#       on copies, and credit should be given to Bellcore where it is due.
X#       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X
X#	$Header: Makefile,v 4.17 88/08/24 15:55:00 bianchi Exp $
X#	$Source: /tmp/mgrsrc/src/RCS/Makefile,v $
X
X#
X#	compile flags:
X#	  WHO:		muck utmp file so "who" works
X#	  VI		code for vi mouse hack
X#	  DEBUG		turns on lots of debugging code (for -d option)
X#	  FASTMOUSE	xor mouse track
X#	  BUCKEY	for keyboard operated "mouse" commands
X#	  PRIORITY	for priority window scheduling instead of 
X#			round-robin; the active window gets higher priority
X#	  CUT		for cut/paste (don't use)
X#	  ALIGN		forces window alignment for fast scrolling
X#			use with non-pixrect version only
X#	  ALIGN32	bitmaps are aligned on 32 instead of 16 bit boundaries.
X#					use with new bit_blit code
X#	  WEIRD		does weird thing on window reshapes
X#	  KILL		kills windows upon tty i/o errors
X#
X#	  MALLOC	for malloc debugging code - you supply the malloc
X#
X#	  SHRINK	use only some of the screen (define [XYWH]0 too)
X#
X#	  NOSTACK	don't permit event stacking 
X#
X#	  BELL		really ring the bell (works on at least sun 3's)
X#			You need to do a "mknod /dev/bell c 12 2"
X#
X#	  KBD		read mgr input from the sun kbd, instead of stdin
X#			This permits redirection of console msgs to a window
X#
X#	  FRACCHAR	fractional character movement stuff (experimental)
X#
X#	  XMENU		extended menu stuff (experimental)
X#
X#		Standard compile flags
XMGR=mgr
XBLITDIR=blit
XDDEP = -DALIGN
XBIT_LIB =   $(BLITDIR)/blitlib.a
XOTHERLIB =
XINCL = ../lib
XMACHDEP_H =
XMACHDEP_C = fast_scroll.c
XMACHDEP_O = fast_scroll.o
XVER = 3.2
X#
X# built-in path names:
X#
X###########################################
XINSROOT=/usr/mgr
XFLAG = -O
X###########################################
XSTART=.
XDSAME = -DWHO -DVI -DBUCKEY -DDEBUG -DKILL -DCUT -DBELL \
X			-DKBD -DALIGN32 -DFRACCHAR
X#	FONTDIR:	where to find font files  (default: /usr/mgr/font)
X#	ICONDIR:	where to find icons	  (default: /usr/mgr/icon)
XPATHFLAGS = -DFONTDIR=\"$(INSROOT)/font\" -DICONDIR=\"$(INSROOT)/icon\"
X#
XDFLAGS = $(DSAME) $(DDEP)
XCFLAGS = $(FLAG) $(DFLAGS) $(PATHFLAGS) -I$(BLITDIR) -I$(INCL)
XFONT_LIB = ../font
XDEFAULT_FONT = $(FONT_LIB)/default.fnt
XINSDIR = $(INSROOT)/bin
XCPIO=src.cpio
XTAR=src.tar
XDEPEND = make.depend
XLOG=make.log
XALLMGRS= mgr color_mgr nmgr omgr pix_mgr mgr-test
XALLDOTFILES= .mgr-test .color_mgr .nmgr .omgr .pix_mgr .mgr-o
X
XPORTCFILES = \
X	Write.c bitmaphead.c bitmapread.c border.c \
X	cut.c data.c debug_flags.c destroy.c \
X	do_buckey.c do_button.c do_event.c do_menu.c down_load.c \
X	erase_win.c font_subs.c get_font.c get_info.c get_menus.c \
X	get_rect.c get_text.c getshell.c graph_subs.c intersect.c \
X	kbd.c mgr.c mouse_get.c move.c move_box.c new_window.c print.c \
X	put_window.c scroll.c set_mode.c shape.c sigdata.c startup.c \
X	subs.c update.c utmp.c win_make.c win_stack.c win_subs.c \
X	write_ok.c 
X
XCFILES = $(PORTCFILES) $(MACHDEP_C)
X
XOFILES = \
X	Write.o bitmaphead.o bitmapread.o border.o \
X	cut.o data.o debug_flags.o destroy.o \
X	do_buckey.o do_button.o do_event.o do_menu.o down_load.o \
X	erase_win.o font_subs.o get_font.o get_info.o get_menus.o \
X	get_rect.o get_text.o getshell.o graph_subs.o intersect.o \
X	kbd.o mgr.o mouse_get.o move.o move_box.o new_window.o print.o \
X	put_window.o scroll.o set_mode.o shape.o sigdata.o startup.o \
X	subs.o update.o utmp.o win_make.o win_stack.o win_subs.o \
X	write_ok.o \
X	$(MACHDEP_O)
X
XHFILES = \
X	$(INCL)/dump.h $(INCL)/window.h \
X	clip.h copyright.h default_font.h defines.h defs.h event.h \
X	font.h icons-16.h icons-32.h menu.h \
X	$(MACHDEP_H)
X
XOTHER = \
X	Makefile \
X	copyright.c \
X	compile_font.c dependencies
X
X############################################################################
Xall:	$(MGR) 
X
X############################################################################
X# color mgr, for sun 3/60, sun3/110 and sun-roadrunner
Xcolor:
X	$(MAKE) DSAME="-DWHO -DVI -DBUCKEY -DDEBUG -DKILL -DBELL -DKBD \
X			-DCOLOR -DFASTMOUSE" \
X		INSROOT=$(INSROOT) \
X		DDEP= \
X		MACHDEP_C= MACHDEP_H= MACHDEP_O= \
X		OTHERLIB=-lpixrect \
X		BLITDIR=pixrect \
X		FLAG=$(FLAG) \
X		MGR=color_mgr \
X		VER=2.2
X
X############################################################################
Xinstallcolor:
X	$(MAKE) DSAME="-DWHO -DVI -DBUCKEY -DDEBUG -DKILL -DBELL -DKBD \
X			-DCOLOR -DFASTMOUSE" \
X		INSROOT=$(INSROOT) \
X		DDEP= \
X		MACHDEP_C= MACHDEP_H= MACHDEP_O= \
X		BLITDIR=pixrect \
X		OTHERLIB=-lpixrect \
X		FLAG=$(FLAG) \
X		MGR=color_mgr \
X		VER=2.2 \
X		install
X
X############################################################################
X# sun 3's production release (no debugging code, optimized)
Xprod:
X	$(MAKE) DSAME="-DWHO -DVI -DBUCKEY -DKILL -DCUT -DALIGN \
X			-DALIGN32 -DBELL -DKBD -DFRACCHAR"  \
X		INSROOT=$(INSROOT) \
X		FLAG=-O \
X		MGR=mgr-o
X
X############################################################################
X# sun 3's (68020 based) next (test) release
Xexp:
X	$(MAKE) DSAME="-DWHO -DVI -DBUCKEY -DDEBUG -DKILL -DCUT -DALIGN \
X			-DALIGN32 -DBELL -DKBD -DFRACCHAR -DXMENU"  \
X		INSROOT=$(INSROOT) \
X		FLAG=$(FLAG) \
X		MGR=nmgr
X
X############################################################################
X# sun 3's (68020 based) pre release 3.4
Xold:
X	$(MAKE) DSAME="-DWHO -DVI -DBUCKEY -DDEBUG -DKILL -DCUT -DALIGN"  \
X		INSROOT=$(INSROOT) \
X		FLAG=$(FLAG) \
X		MGR=omgr
X
X############################################################################
X# sun 2's (68010 based)
Xsun2:
X	$(MAKE) DSAME="-DWHO -DVI -DBUCKEY -DDEBUG -DKILL -DCUT -DBELL -DKBD \
X		       -DALIGN" \
X		INSROOT=$(INSROOT) \
X		FLAG=$(FLAG) \
X		BLITDIR=oblit
X
X############################################################################
X# sun 2's (68010 based) running pre-3.4 releases (i.e. 1.0)
Xoldsun2:
X	$(MAKE) DSAME="-DWHO -DVI -DBUCKEY -DDEBUG -DKILL -DCUT -DALIGN" \
X		INSROOT=$(INSROOT) \
X		FLAG=$(FLAG) \
X		BLITDIR=oblit
X
X############################################################################
Xpixlib:
X	$(MAKE) DSAME="-DWHO -DVI -DBUCKEY -DDEBUG -DKILL -DCUT -DBELL -DKBD" \
X		INSROOT=$(INSROOT) \
X		DDEP= MACHDEP_C= MACHDEP_H= MACHDEP_O= \
X		BLITDIR=pixrect OTHERLIB=-lpixrect \
X		FLAG=$(FLAG) \
X		MGR=pix_mgr \
X		VER=2.2
X
X########################################################################
X
Xfast:	gang $(MGR)
X
X#		Placing $(HFILES) and $(CFILES) in the dependency list let's us
X#		see which files actually caused the rebuild in the $(LOG).
X#		Other than that, and checking for their existence, they are not
X#		needed for the actual build of mgr.
X
X$(MGR):	.$(MGR) $(HFILES) $(CFILES) $(OFILES) copyright.o version.o FRClibrary
X	-rm -f mgr
X	-mv $(MGR) _$(MGR)
X	$(CC) $(LFLAGS) $(FLAG) -o $(MGR) $(MALLOC) $(OFILES) version.o copyright.o \
X		$(BIT_LIB) $(OTHERLIB)
X	@date >> $(LOG)
X	echo "changed $?" >> $(LOG)
X	@size $(MGR)
X	@echo "$(MGR) on `date`" > .done
X	-ln $(MGR) mgr
X
X.PRECIOUS: .$(MGR)
X
X.$(MGR) gang:	default_font.h icons.h
X	rm -f $(OFILES) $(ALLDOTFILES) copyright.o icons.h .done
X	$(MAKE) BLITDIR=$(BLITDIR) icons.h
X	touch .$(MGR)
X	$(CC) -c $(CFLAGS) $(PORTCFILES)
X
Xdefault_font.h:
X		make compile_font
X		./compile_font < $(DEFAULT_FONT) default_font \
X			     > default_font.h
X
Xcompile_font:	compile_font.o
X		$(CC) $(LFLAGS) -o compile_font compile_font.o
X
X# pick the icon file with appropriate alignment 
X#	set up a link to the proper font directory as well
X
Xicons.h:
X		-rm icons.h
X		-rm ../font	
X		@if [ x$(BLITDIR) = xblit ]; \
X		then \
X			echo 'Creating 32-bit aligned mouse icons'; \
X			ln -s icons-32.h icons.h; \
X			echo 'Setting links to 32-bit fonts'; \
X			ln -s `pwd`/../font-32 ../font; \
X		else \
X			echo 'Setting links to 16-bit fonts'; \
X			ln -s `pwd`/../font-16 ../font; \
X			echo 'Creating 16-bit aligned mouse icons'; \
X			ln -s icons-16.h icons.h; \
X		fi
X		
X#	create mgr version information
X
Xversion.c:	$(OFILES)
X		echo "/* compilation info for $(MGR) */"	 > version.c
X		@echo " "					>> version.c
X		@echo "char *version[]={"			>> version.c
X		@echo "   \"$(VER)\",\"`hostname`\",\"`date`\",">> version.c
X		@echo "   \"`echo $(DFLAGS) | sed 's/-D//g'`\",">> version.c
X		@echo "   \"$(INSROOT)\","			>> version.c
X		@echo "   \"`whoami`\","			>> version.c
X		@echo "   \"`strings /vmunix | grep 'Release'`\",">> version.c
X		@echo "   };"					>> version.c 
X
X# The optimizer botches on this one
X
Xfast_scroll.o:	fast_scroll.c
X		$(CC) -c -I$(BLITDIR) fast_scroll.c
X
X#	put copyright data into text segment
Xcopyright.o:	copyright.c copyright.h
X		$(CC) -c $(FLAG) $(DFLAGS) -I$(BLITDIR) -R copyright.c
X
X$(BLITDIR)/blitlib.a FRClibrary:
X		cd $(BLITDIR); $(MAKE) FLAG=$(FLAG) blitlib.a
X#		make blit library avaliable to the applications
X		-rm -f $(INCL)/blitlib.a $(INCL)/bitmap.h
X		-ln -s `pwd`/$(BLITDIR)/blitlib.a $(INCL)/blitlib.a
X		-ln -s `pwd`/$(BLITDIR)/bitmap.h $(INCL)/bitmap.h
X
X$(LOG):		
X		echo "MGR version log > $(LOG)
X
Xclean:		
X		rm -f *.o version.c $(ALLDOTFILES) .done
X		cd blit; $(MAKE) clean
X		cd oblit; $(MAKE) clean
X		cd pixrect; $(MAKE) clean
X
Xclobber:
X		rm -f compile_font $(ALLMGRS)
X
Xinstall:	.done $(INSDIR) /dev/bwtwo0
X		cd $(INSDIR);  rm -f $(MGR)
X		cp $(MGR) $(INSDIR)
X		-/etc/chown root $(INSDIR)/$(MGR)  && \
X		 chmod u+s,go-w $(INSDIR)/$(MGR)
X
X.done:
X		@echo "No MGR available to install"
X
X$(INSDIR):
X		mkdir $@
X
X/dev/bwtwo0:
X		-/bin/su root -c 'cd /dev;  MAKEDEV bwtwo0'
X
Xtar:		
X		tar cf $(TAR) `make list`
X		
Xdepend:	
X		dependencies `$(MAKE) list` > $(DEPEND)
X		echo " header file dependencies written to $(DEPEND)"
X
Xlist:
X	@for i in $(HFILES) $(CFILES) $(OTHER); do \
X		echo "$(START)/$$i"; \
X	done	
X	@for i in blit oblit pixrect; do \
X		echo "${START}/$$i";\
X		if [ -d $$i ]; then \
X	 		cd $$i; $(MAKE) START=${START}/$$i list; cd ..;\
X		fi \
X	done	
X
Xcpio:
X	make -s list  |  sort -u  |  cpio -ocv > $(CPIO)
X
X
X# header file dependencies go here 
X
XWrite.o: \
X	Write.c
X
Xbitmaphead.o: \
X	bitmaphead.c $(INCL)/dump.h $(BLITDIR)/bitmap.h
X
Xbitmapread.o: \
X	bitmapread.c $(INCL)/dump.h $(BLITDIR)/bitmap.h
X
Xborder.o: \
X	border.c $(BLITDIR)/bitmap.h defs.h defines.h
X
Xcopyright.c:	copyright.h
X
Xcopyright.o: \
X	$(BLITDIR)/bitmap.h
X
Xcut.o: \
X	cut.c $(BLITDIR)/bitmap.h defs.h defines.h font.h $(INCL)/window.h \
X	event.h
X
Xdata.o: \
X	data.c $(BLITDIR)/bitmap.h defs.h defines.h font.h icons.h
X
Xdebug_flags.o: \
X	debug_flags.c
X
Xdestroy.o: \
X	destroy.c $(BLITDIR)/bitmap.h defs.h defines.h font.h event.h
X
Xdo_buckey.o: \
X	do_buckey.c $(BLITDIR)/bitmap.h defs.h defines.h font.h \
X	event.h
X
Xdo_button.o: \
X	do_button.c $(BLITDIR)/bitmap.h menu.h defs.h defines.h \
X	font.h event.h
X
Xdo_event.o: \
X	do_event.c $(BLITDIR)/bitmap.h defs.h defines.h font.h event.h
X
Xdo_menu.o: \
X	do_menu.c $(BLITDIR)/bitmap.h menu.h defs.h defines.h font.h
X
Xdown_load.o: \
X	down_load.c $(BLITDIR)/bitmap.h font.h defs.h defines.h \
X	menu.h event.h $(INCL)/window.h
X
Xerase_win.o: \
X	erase_win.c $(BLITDIR)/bitmap.h defs.h defines.h
X
Xfont_subs.o: \
X	font_subs.c $(BLITDIR)/bitmap.h font.h default_font.h $(INCL)/window.h
X
Xget_font.o: \
X	get_font.c $(BLITDIR)/bitmap.h font.h
X
Xget_info.o: \
X	get_info.c $(BLITDIR)/bitmap.h font.h defs.h defines.h menu.h \
X	event.h $(INCL)/window.h
X
Xget_menus.o: \
X	get_menus.c $(BLITDIR)/bitmap.h menu.h font.h
X
Xget_rect.o: \
X	get_rect.c $(BLITDIR)/bitmap.h defs.h defines.h
X
Xget_text.o: \
X	get_text.c $(BLITDIR)/bitmap.h defs.h defines.h font.h event.h
X
Xgetshell.o: \
X	getshell.c $(BLITDIR)/bitmap.h defs.h defines.h
X
Xgraph_subs.o: \
X	graph_subs.c $(BLITDIR)/bitmap.h
X
Xintersect.o: \
X	intersect.c $(BLITDIR)/bitmap.h defs.h defines.h
X
Xkbd.o: \
X	kbd.c $(BLITDIR)/bitmap.h defs.h defines.h
X
Xmgr.o: \
X	mgr.c $(BLITDIR)/bitmap.h defs.h defines.h menu.h font.h \
X	event.h
X
Xmouse_get.o: \
X	mouse_get.c
X
Xmove.o: \
X	move.c $(BLITDIR)/bitmap.h defs.h defines.h event.h
X
Xmove_box.o: \
X	move_box.c $(BLITDIR)/bitmap.h defs.h defines.h
X
Xnew_window.o: \
X	new_window.c $(BLITDIR)/bitmap.h defs.h defines.h font.h \
X	menu.h
X
Xprint.o: \
X	print.c
X
Xput_window.o: \
X	put_window.c $(BLITDIR)/bitmap.h font.h defs.h defines.h \
X	menu.h event.h $(INCL)/window.h clip.h
X
Xscroll.o: \
X	scroll.c $(BLITDIR)/bitmap.h defs.h defines.h clip.h
X
Xset_mode.o: \
X	set_mode.c
X
Xshape.o: \
X	shape.c $(BLITDIR)/bitmap.h defs.h defines.h font.h event.h
X
Xsigdata.o: \
X	sigdata.c
X
Xstartup.o: \
X	startup.c $(BLITDIR)/bitmap.h defs.h defines.h
X
Xsubs.o: \
X	subs.c $(BLITDIR)/bitmap.h font.h defs.h defines.h event.h
X
Xupdate.o: \
X	update.c $(BLITDIR)/bitmap.h defs.h defines.h clip.h
X
Xutmp.o: \
X	utmp.c
X
Xwin_make.o: \
X	win_make.c $(BLITDIR)/bitmap.h font.h defs.h defines.h $(INCL)/window.h \
X	event.h
X
Xwin_stack.o: \
X	win_stack.c $(BLITDIR)/bitmap.h font.h defs.h defines.h \
X	$(INCL)/window.h menu.h event.h
X
Xwin_subs.o: \
X	win_subs.c $(BLITDIR)/bitmap.h font.h defs.h defines.h $(INCL)/window.h \
X	clip.h
X
Xwrite_ok.o: \
X	write_ok.c defines.h
X
Xfast_scroll.o: \
X	fast_scroll.c $(BLITDIR)/bitmap.h
X
Xcompile_font.o: \
X	compile_font.c $(BLITDIR)/bitmap.h font.h
X
END_OF_FILE
# end of 'src/Makefile'
fi
echo shar: End of archive 36 \(of 61\).
cp /dev/null ark36isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
