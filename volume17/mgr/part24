Subject:  v17i025:  MGR, Bellcore window manager, Part24/61
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen A. Uhler <sau@bellcore.com>
Posting-number: Volume 17, Issue 25
Archive-name: mgr/part24




#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 24 (of 61)."
# Contents:  demo/icon/cut.c demo/icon/window_print.c demo/misc/close.c
#   doc/usrman/croff/croff.l doc/usrman/croff/hash.c src/blit/hash.c
#   src/default_font.h
# Wrapped by rsalz@papaya.bbn.com on Thu Nov 17 21:05:28 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'demo/icon/cut.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/icon/cut.c'\"
else
echo shar: Extracting \"'demo/icon/cut.c'\" \(6170 characters\)
sed "s/^X//" >'demo/icon/cut.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: cut.c,v 1.1 88/07/08 11:11:39 sau Exp $
X	$Source: /tmp/mgrsrc/demo/icon/RCS/cut.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/icon/RCS/cut.c,v $$Revision: 1.1 $";
X
X/* save current cut buffer in a file */
X
X#include <signal.h>
X#include "term.h"
X
X#define TERM		"mgr"			/* name of valid terminal id */
X
X#define RESTORE	0				/* restore previous icon */
X#define CLOSED		1
X#define OPEN		2
X#define WINK		3
X
X#define ICON_CLOSED	"file_shut"
X#define ICON_OPEN		"file_open"
X#define ICON_WINK		"file_shutb"
X#define CMDNAME		"hm -s"	/* default command */
X#define SLOP			3			/* space around the window */
X
X#define MENU_COUNT		(sizeof(menu)/sizeof(struct menu_entry))
X#define max(x,y)	((x)>(y)?(x):(y))
X#define min(x,y)	((x)<(y)?(x):(y))
X#define dprintf	if(debug)fprintf
X
Xint border;
XFILE *debug;
X
Xmain(argc,argv)
X	int argc;
X	char **argv;
X	{
X	register int i;
X	char *getenv();
X	char *term = getenv ("TERM");
X   char *name = argv[0];
X   char *cmd;				/* command to pipe data to */
X	char line[80];			/* event input buffer */
X
X	int x,y,wide,high;	/* main window size */
X	int w,h;					/* icon size */
X	int max_w, max_h;		/* max icon size */
X	int ix, iy;				/* icon position */
X	int fw,fh,font;				/* font for vi window */
X   int got=0;
X   int shape = 1;			/* window reshape? */
X   FILE *test;				/* temporary file */
X
X	int clean();
X
X	if (getenv("DEBUG"))
X		debug = stderr;
X	else
X		debug = NULL;
X
X	/* make sure environment is ok */
X
X	if (term!=NULL && strcmp(term,TERM)!=0) {
X		fprintf(stderr,"%s only runs on %s terminals\n",name,TERM);
X		exit(1);
X	   }
X
X	/* get args */
X
X   if (argc>1 && strcmp(argv[1],"-s")==0) {	/* don't redhape window */
X      argc--, argv++;
X      shape=0;
X      }
X
X   if (argc>1)
X      cmd = argv[1];
X   else if ((cmd=getenv("CUT")) == NULL)
X      cmd = CMDNAME;
X
X   /* make sure we can run the command */
X
X   if ((test = popen(cmd,"w")) == NULL || pclose(test)!=0) {
X      fprintf(stderr,"%s: Can't start (%s)\n",name,cmd);
X      exit(1);
X      }
X   
X	/* set up window environment */
X
X	m_setup(0);
X	m_ttyset();
X
X	signal(SIGHUP,clean);
X	signal(SIGTERM,clean);
X	signal(SIGINT,clean);
X
X	m_push(P_FONT|P_POSITION|P_EVENT|P_FLAGS);
X	get_size(&x,&y,&wide,&high);
X	get_param(0,0,0,&border);
X	m_setmode(M_NOWRAP);
X	m_func(B_COPY);
X
X	/* get icons */
X
X	if (!down_load(ICON_CLOSED,CLOSED,&w,&h)) {
X      fprintf(stderr,"%s: Can't find %s\n",name,ICON_CLOSED);
X		clean(1);
X		}
X	max_h = h; max_w = w;
X
X	if (!down_load(ICON_OPEN,OPEN,&w,&h)) {
X      fprintf(stderr,"%s: Can't find %s\n",name,ICON_OPEN);
X		clean(1);
X		}
X	max_h = max(max_h,h);
X	max_w = max(max_w,w);
X
X	if (!down_load(ICON_WINK,WINK,&w,&h)) {
X      fprintf(stderr,"%s: Can't find %s\n",name,ICON_WINK);
X		clean(1);
X		}
X
X	max_h = max(max_h,h);
X	max_w = max(max_w,w);
X
X	/* get icon position */
X   
X	m_font(1);	/* a small font */
X   if (shape) {
X		m_push(P_FLAGS|P_EVENT);
X		m_setmode(M_ABS);
X		m_setevent(BUTTON_1,"Z %p\r");
X		fprintf(stderr,"Click button 1 to indicate icon position\n");
X		while (*m_gets(line) != 'Z')
X			;
X		sscanf(line,"Z %d %d",&w,&h);
X		ix = w + x + border; 
X		iy = h + y + border;
X		m_pop();
X
X		/* iconify window */
X
X		m_shapewindow(ix,iy,SLOP+2*border+max_w, SLOP+2*border+max_h);
X		dprintf(debug,"Shaping window to %d x %d\n",border+max_w, border+max_h);
X      }
X
X	/* setup events */
X
X	m_setevent(ACTIVATE,"A\r");
X	m_setevent(DEACTIVATE,"D\r");
X	m_setevent(REDRAW,"R\r");
X	m_setevent(RESHAPE,"S\r");
X	m_setevent(SNARFED,"C %c\r");
X	m_clearmode(M_ACTIVATE);
X
X	/* display icon */
X
X	setup(CLOSED);
X
X	/* wait for an event */
X
X	while(!feof(m_termin)) {
X		m_flush();
X		m_gets(line);
X		switch(*line) {
X			case 'A':	/* window is activated */
X            if (got) {
X               setup(OPEN);
X				   m_flush();
X				   m_put();
X				   m_sendme("\r\005 done\r");
X				   m_flush();
X				   append_file(cmd,got);
X               got = 0;
X               }
X            sleep(1);
X				m_clearmode(M_ACTIVATE);
X				break;
X			case 'D':	/* window is deactivated */
X				setup(CLOSED);
X				break;
X			case 'S':	/* window is reshaped */
X            if (shape) {
X					get_size(&ix,&iy,0,0);
X					m_shapewindow(ix,iy,SLOP+2*border+max_w, SLOP+2*border+max_h);
X               }
X				setup(RESTORE);
X				break;
X			case 'R':	/* screen is redrawn */
X            setup(RESTORE);
X				break;
X			case 'C':	/* Someone cut something */
X				got = atoi(line+2);		/* # of bytes */
X				setup(WINK);
X				m_flush();
X				sleep(1);
X				setup(CLOSED);
X			}
X		}
X	}
X
X/*	Clean up and exit */
X
Xclean()
X	{
X	m_popall();
X	m_ttyreset();
X	exit(1);
X	}
X
X/* setup an icon */
X
Xsetup(where)
Xint where;		/* bitmap # */
X	{
X   static int was=0;
X
X   if (where==0)		/* restore previous icon */
X      where = was;
X
X	m_clear();
X	m_bitcopyto(0,0,999,999,0,0,0,where);
X	dprintf(debug,"displaying icon [%d] \n",where);
X   m_flush();
X   was = where;
X	}
X
X/* download icon */
X
Xint
Xdown_load(name,where,w,h)
Xchar *name;	/* name of icon */
Xint where;	/* scratchpad bitmap # */
Xint *w, *h;	/* icon size */
X	{
X	char buff[20];
X	int n;
X
X   m_bitfromfile(where,name);
X   m_flush();
X   m_gets(buff);
X   n = sscanf(buff,"%d %d",w,h);
X	dprintf(debug,"Getting icon [%s] into %d (%d x %d)\n",
X		name,where,*w,*h);
X	if (n < 2) 
X		return(0);
X	else
X		return(1);
X	}
X
Xint
Xappend_file(cmd,bytes)
Xchar *cmd;		/* command to pipe file to */
Xint bytes;
X	{
X   FILE *file;
X   long now = time(0);
X   char *ctime();
X	register int c,count = 0;
X	int gotn = 0;
X
X   dprintf(stderr,"appending %d bytes\n",bytes);
X   file = popen(cmd,"w");
X   fprintf(file,"\n> %d bytes at: %s  ",bytes,ctime(&now));
X
X	while((c=getc(m_termin)) != '\005') {
X		if (c=='\n' && gotn++ ==0) {
X		   count++;
X			putc(c,file);
X			putc(' ',file);
X			putc(' ',file);
X			}
X		else if (c!= '\n') {
X			putc(c,file);
X			gotn = 0;
X			}
X		}
X	fflush(file);
X   pclose(file);
X	return(count);
X	}
END_OF_FILE
# end of 'demo/icon/cut.c'
fi
if test -f 'demo/icon/window_print.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/icon/window_print.c'\"
else
echo shar: Extracting \"'demo/icon/window_print.c'\" \(6454 characters\)
sed "s/^X//" >'demo/icon/window_print.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: window_print.c,v 4.1 88/06/21 14:00:15 bianchi Exp $
X	$Source: /tmp/mgrsrc/demo/icon/RCS/window_print.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/icon/RCS/window_print.c,v $$Revision: 4.1 $";
X
X/* print any window on the hp think jet (use lpr filter) */
X
X#include <stdio.h>
X#include <signal.h>
X#include <sys/file.h>
X#include "term.h"
X#include "dump.h"
X
X#define TEMP	"/tmp/pr."			/* temp file name */
X#define MESSAGE	"\rwindow dump"			/* window message */
X#define WORKING	"\rworking..................."	/* print in progress */
X#define JOB	"window"			/* default page header */
X#define OPTION	'v'				/* lpr filter option */
X
X#define MSG_OK		"ok"			/* message ack - success */
X#define MSG_BAD		"x"			/* message nac - failure */
X#define MSG_FILE	"F"			/* service type - no data */
X#define NAME		"print bitmap"		/* name of service */
X
X#define dprintf	if(debug) fprintf
X
X#define GET_OPT(i)	\
X	strlen(argv[i])>2 ? argv[i]+2 : argv[++i]
X#define Min(x)		((x)<5 ? 5 : (x))
X
Xchar command[100];				/* lpr command to run */
Xchar line[100];					/* event input buffer */
Xchar temp[20];					/* temp file name */
Xchar my_host[20];				/* my host */
Xchar mgr_host[20];				/* mgr host */
Xchar title[40];					/* window title */
X
Xint remote;					/* remote from mgr host */
Xint debug;
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   register int i, c;
X   int x,y;					/* bitmap size */
X   int id,sub;					/* window to dump */
X   int clean();
X   char *sprintf();
X
X   char *printer = NULL;			/* printer name */
X   char *job = JOB;				/* job name */
X   char *filter = NULL;				/* pre-filter */
X   char *message = NULL;			/* message line */
X   char option = OPTION;			/* lpr filter */
X   char *noprint = NULL;			/* just same file */
X
X   ckmgrterm( *argv );
X   gethostname(my_host,sizeof(my_host));
X   debug = getenv("DEBUG");
X
X   /* check arguments */
X
X   for(i=1;i<argc;i++) {
X      if (*argv[i] == '-')
X         switch (argv[i][1]) {
X            case 'f':				/* specify filter */
X               filter = GET_OPT(i);
X               break;
X            case 'p':				/* printer name */
X            case 'P':				/* printer name */
X               printer = GET_OPT(i);
X               break; 
X            case 'm':				/* message line */
X               message = GET_OPT(i);
X               break; 
X            case 'j':				/* job name */
X            case 'J':				/* job name */
X               job = GET_OPT(i);
X               break; 
X            case 'o':				/* option flag */
X               option = *(GET_OPT(i));
X               break; 
X            case 'x':				/* dont print name */
X               noprint = GET_OPT(i);
X               break; 
X            default:
X               fprintf(stderr,"%s: invalid flag %c ignored\n",argv[0],argv[i][1]);
X            }
X      else
X         fprintf(stderr,"%s: invalid argument %s ignored\n",argv[0],argv[i]);
X      }
X
X   /* setup mgr */
X
X   m_setup(M_FLUSH);
X   m_push(P_FLAGS|P_EVENT);
X   m_ttyset();
X
X   get_param(mgr_host,0,0,0);
X   remote = strcmp(mgr_host,my_host);
X   dprintf(stderr,"my host (%s), mgr host (%s)\n",my_host,mgr_host);
X
X   if (message)
X      sprintf(title,"\r%s",message);
X   else if (printer && remote)
X      sprintf(title,"%s at %s on %s",MESSAGE,my_host,printer);
X   else if (remote)
X      sprintf(title,"%s at %s",MESSAGE,my_host);
X   else if (printer)
X      sprintf(title,"%s on %s",MESSAGE,printer);
X   else
X      strcpy(title,MESSAGE);
X
X   get_size(&x,&y,0,0);
X   if (!debug)
X      m_sizeall(x,y,Min(strlen(title)-1),1);
X   m_setmode(M_NOWRAP);
X   m_clear();
X   m_printstr(title);
X   m_clearmode(M_ACTIVATE);
X   
X   m_setevent(ACTIVATED,"A\r");			/* window made active */
X   m_setevent(DEACTIVATED,"D\r");		/* window made in-avtive */
X   m_setevent(BUTTON_1,"B %w\r");		/* button 1 hit */
X   m_setevent(REDRAW,"R\r");
X   m_setevent(RESHAPE,"S\r");
X   
X   signal(SIGHUP,clean);
X   signal(SIGINT,clean);
X   signal(SIGTERM,clean);
X
X   /* build command */
X
X   sprintf(temp,"%s%s%d",TEMP,my_host,getpid());
X   dprintf(stderr,"temp file name: (%s)\n",temp);
X   
X   if (noprint) {
X      if (remote)
X         sprintf(command,"rcp %s:%s %s",mgr_host,temp,noprint);
X      else
X         sprintf(command,"cp %s %s",temp,noprint);
X      }
X   else {
X      if (remote)
X         sprintf(command,"rsh %s cat %s | ",mgr_host,temp);
X      else
X         sprintf(command,"< %s ",temp);
X      if (filter) 
X         sprintf(command+strlen(command),"%s | ",filter);
X      strcat(command,"lpr ");
X      if (printer)
X         sprintf(command+strlen(command),"-P%s ",printer);
X      sprintf(command+strlen(command),"-J%s -%c",job,option);
X      }
X   dprintf(stderr,"command: (%s)\n",command);
X   
X   while (m_gets(line) != NULL) {
X     dprintf(stderr,"main loop got: %s",line);
X     switch(c = *line) {
X        case 'S':				/* window reshaped */
X           get_size(&x,&y,0,0);
X           if (!debug)
X              m_sizeall(x,y,strlen(title)-1,1);
X           m_clear();
X           m_printstr(title);
X           break;
X        case 'R':				/* window redrawn */
X           m_printstr(title);
X           break;
X        case 'A':				/* window activated */
X           m_setmode(M_WOB);
X           break;
X        case 'D':				/* window deactivated */
X           m_clearmode(M_WOB);
X           break;
X        case 'B':				/* button hit */
X           id = 0;
X           sscanf(line+2,"%d.%d",&id,&sub);
X           dprintf(stderr," got: %d, %d\n",id,sub);
X           if (id) {
X              m_othersave(id,sub,temp);
X              m_clearmode(M_WOB);
X              m_printstr(WORKING);
X              sleep(1); 
X              system(command,temp);
X              if (remote)
X                 system(sprintf(command,"rsh %s rm %s\n",mgr_host,temp));
X              else
X                 unlink(temp);
X              }
X           m_printstr(title);
X           m_clearmode(M_ACTIVATE);
X           break;  
X        }
X      }
X   }
X
Xclean(n)
Xint n;
X   {
X   m_ttyreset();
X   if (remote)
X      system(sprintf(command,"rsh %s rm %s\n",mgr_host,temp));
X   else
X      unlink(temp);
X   m_pop();
X   m_clear();
X   exit(n);
X   }
END_OF_FILE
# end of 'demo/icon/window_print.c'
fi
if test -f 'demo/misc/close.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo/misc/close.c'\"
else
echo shar: Extracting \"'demo/misc/close.c'\" \(6539 characters\)
sed "s/^X//" >'demo/misc/close.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1987 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: close.c,v 4.6 88/08/08 09:43:38 sau Exp $
X	$Source: /tmp/mgrsrc/demo/misc/RCS/close.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/demo/misc/RCS/close.c,v $$Revision: 4.6 $";
X
X/* close a window  - keep icon uncovered */
X
X#include <signal.h>
X#include "term.h"
X
X
Xstatic int debug = 0;			/* for debugging */
X
Xstatic int wide, high, xmax, ymax, border;	/* global mgr state info */
X
X#define Max(x,y)	((x)>(y)?(x):(y))
X#define Min(x,y)	((x)<(y)?(x):(y))
X#define dprintf		if (debug) fprintf
X
X#define XSLOP		6	/* extra horizontal space around window */
X#define YSLOP		2	/* extra vertical space around window */
X#define WAIT		20	/* seconds until next look for an opening */
X#define RAND		11	/* max time to wait before moving */
X
X#define Active		"A\r"
X#define Covered		"C\r"
X#define Redraw		"R\r"
X
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   char host[16];			/* host name */
X   char line[MAXLINE];			/* input buffer for events */
X   char text[MAXLINE];			/* text for icon */
X   char moving[MAXLINE];		/* text for icon while moving */
X   int font;
X   int clean();
X   int sigalrm();
X   char *getenv();
X
X   ckmgrterm( *argv );
X
X   /* turn on debugging */
X
X   if (getenv("DEBUG"))
X      debug++;
X
X   /* get icon text */
X
X   srand(getpid());
X   if (debug)
X      setbuf(stderr,NULL);
X   m_setup(M_FLUSH);
X   m_push(P_ALL & (~P_MOUSE));	
X
X   signal(SIGINT,clean);
X   signal(SIGTERM,clean);
X   signal(SIGALRM,sigalrm);
X
X   m_ttyset();
X
X   if (argc>3)
X      usage(*argv);
X
X   if (argc>1  &&  *argv[1] ) {
X      /* There is a message and it is not zero length */
X      text[0] = '\f';
X      /* If the string in argv[1] contains a %d, then the window set ID will
X         be included in the message.
X      */
X      sprintf(&text[1], argv[1], m_setid());
X      sprintf(moving, "\fMoving %s", &text[1]);
X   }
X   else {
X      /* No message or it is zero length. */
X      gethostname(host,sizeof(host));
X      sprintf(text, "\f%s(%d)", host, m_setid());
X      sprintf(moving, "\fMoving(%d)", m_setid());
X      }
X
X   if (!debug)
X      m_setmode(M_NOINPUT);
X   if (argc==3  &&  (font=atoi(argv[2])) > 0)
X      m_font(font);
X
X   setupwindow(text);
X
X   /* set events */
X
X   m_setevent(ACTIVATED,Active);
X   m_setevent(COVERED,Covered); 
X   m_setevent(REDRAW,Redraw); 
X
X   /* bury it and wait */
X
X   if (!goto_spot(wide,high)) {
X      /* Window was too big; use font zero and try again */
X      m_font( 0 );
X      setupwindow( text );
X      }
X   goto_spot(wide,high);
X   	/* no place to go; we'll stay where we are until something opens up */
X
X   while(1) {
X      m_clearmode(M_ACTIVATE);
X      if (!debug)
X         m_setmode(M_NOINPUT);
X      m_gets(line);
X      alarm(0);
X      m_push(P_EVENT);
X      m_setevent(COVERED,Covered); 
X      dprintf(stderr,"Read [%s]\n",line);
X
X      if (*line == *Active)			/* activate window */
X         clean();
X
X      else if (*line == *Covered) {
X         m_printstr(moving);
X         get_size(0,0,&wide,&high);
X         wide += 2*border+XSLOP;
X         high += 2*border+YSLOP;
X         dprintf(stderr,"going to ?,? %d %d\n",wide,high);
X         sleep(((unsigned)rand()) % RAND);
X         if (goto_spot(wide,high)) {
X	    m_clearevent(COVERED);
X            m_clearmode(M_ACTIVATE);
X            }
X         else {				/* no place to go */
X            alarm(WAIT);
X            }
X         }
X      m_printstr(text);
X      m_pop();
X      }
X   }
X
X/* restore window state and exit */
X
Xstatic
Xclean()
X   {
X   m_ttyreset();
X   m_popall(0);
X   exit(1);
X   }
X
X/* find an unused spot for a window */
X
Xstatic
Xint
Xgoto_spot(wide, high)
Xint wide,high;					/* minimum spot size */
X   {
X   struct window_data	coords[1000];	/* present window coords. go here */
X   register int		c,
X			count,
X			intersection,
X			setid = m_setid(),
X			x,
X			y, nexty;
X
X   while( (count = get_all(coords)) == 0 )
X	;
X   dprintf(stderr,"found %d windows\n", count);
X
X   /*	Find the best spot.  We want to avoid too exhaustive a search.
X	We march through the screen, trying to fit the moving window into
X	spaces.  Any time we collide with a window, we skip to the right edge
X	of that window and note if it's top edge is the lowest one we've seen
X	which is still above where we are.  This allows us to skip over the
X	larger areas of occupied screen quickly.
X   */
X   for( y = ymax-high;  y >= 0;  y = nexty - 1 ) {
X      nexty = y;
X      for( x = xmax-wide;  x >= 0;  x -= 1 ) {
X	 intersection = 0;
X	 for( c = 0;  c < count;  c++ ) {
X	    if( coords[c].setid == setid )
X	       continue;
X            if( in_win( coords+c, x, y, x + wide, y + high ) ) {
X	       intersection = 1;
X	       nexty = Max( y, Max( nexty, coords[c].y - high ) );
X	       x = coords[c].x - wide;
X	       break;
X	       }
X	    }
X	 if( !intersection ) {
X            dprintf(stderr,"going to %d, %d\n", x, y);
X	    m_push(P_EVENT);
X	    m_movewindow( x + XSLOP/2, y + YSLOP/2 );
X	    m_pop();
X	    return( 1 );
X	    }
X	 }
X      }
X   dprintf(stderr,"no openings\n");
X   return( 0 );
X   }
X
X
X/* check for window-rectangle intersection */
X
Xstatic
Xint
Xin_win(list,x0,y0,x1,y1)
Xregister struct window_data *list;		/* window coordinates */
Xregister int x0,y0,x1,y1;			/* rectangle coordinates */
X   {
X   return(
X   (
X      list->x + list->w < x0  ||  x1 < list->x  ||
X      list->y + list->h < y0  ||  y1 < list->y
X   ) ?  0  :  1);
X   }
X
X
X/* send an alarm signal */
X
Xstatic
Xsigalrm()
X   {
X   m_sendme(Covered);
X   }
X
X
Xstatic
Xint
Xm_setid()
X{
X	static int		setid = -1;
X	struct window_data	window;
X
X	if( setid == -1 ) {
X		while( get_eachclientwin( &window ) )
X			;
X		setid = window.setid;
X	}
X	return setid;
X}
X
X
Xstatic
Xusage( pgm )
Xchar	*pgm;
X{
X	fprintf( stderr, "Usage:  %s [ message [ fontnumber ] ]\n", pgm );
X	fputs( "\
XIf the message is zero-length, the default message is printed.\n\
XIf fontnumber is non-numberic or not available, zero is assumed.\n\
X", stderr );
X	exit( 255 );
X}
X
X
Xstatic
Xsetupwindow( text )
Xchar	*text;
X{
X	/* change window size */
X
X	m_size(Max(strlen(text)-1, 5), 1);
X	m_setmode(M_NOWRAP);
X	m_printstr(text);
X
X	/* how big is it */
X
X	get_size(0, 0, &wide, &high);
X	get_param(0, &xmax, &ymax, &border);
X	wide += 2*border+XSLOP;
X	high += 2*border+YSLOP;
X}
END_OF_FILE
# end of 'demo/misc/close.c'
fi
if test -f 'doc/usrman/croff/croff.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/usrman/croff/croff.l'\"
else
echo shar: Extracting \"'doc/usrman/croff/croff.l'\" \(6025 characters\)
sed "s/^X//" >'doc/usrman/croff/croff.l' <<'END_OF_FILE'
X%{
X/*
X                         Copyright (c) 1988 Bellcore
X                             All Rights Reserved
X        Permission is granted to copy or use this program, EXCEPT that it
X        may not be sold for profit, the copyright notice must be reproduced
X        on copies, and credit should be given to Bellcore where it is due.
X        BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X
X	$Header: croff.l,v 1.2 88/07/07 10:17:25 sau Exp $
X	$Source: /tmp/mgrsrc/doc/usrman/croff/RCS/croff.l,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/doc/usrman/croff/RCS/croff.l,v $$Revision: 1.2 $";
X
X/* is this lex abuse? */
X
X
X#include "hash.h"
X
X#define dprintf	if(debug)fprintf
X
Xextern struct table_entry keywords_data[];
Xextern struct table_entry *keywords[];
X
Xchar *ks,*ke;	/* keyword delimeters */
Xchar *cs,*ce;	/* comment delimeters */
Xchar *is,*ie;	/* identifier delimeters */
Xchar *fs,*fe;	/* function delimeters */
Xchar *ps,*pe;	/* pre-proc delimeters */
X
Xint force = 0;		/* force xlation without .SS */
Xint no_troff = 0;	/* dont xlate \ etc */
Xint no_lig = 0;		/* on't emit troff ligatures (brain damaged imagen) */
Xint debug = 0;		/* do debugging */
X
X%}
X
X%START start comment quote
XW	[ 	]*
XK	[a-zA-Z_][a-zA-Z0-9_]*
X
X%%
X
X
X^".SS".*$ {			/* start source processing */
X        static char t1[25],t2[25],t3[25],t4[25];
X	int n;
X	BEGIN start;
X        if (!force) {
X	   ECHO;
X	   n = sscanf(yytext,".SS %s %s %s %s",t1,t2,t3,t4);
X           switch(n) {
X              case 4: case 5: case 6: case 7: case 8: case 9:
X                 ce = t4;
X              case 3:
X                 ke = t3;
X              case 2:
X                 cs = t2;
X              case 1:
X                 ks = t1;
X              }
X	   }
X	}
X<start,comment,quote>^".SE" {	/* end source processing */
X	if (!force)
X           BEGIN 0;
X	ECHO;
X	}
X<start>"/*" {			/* start a comment */
X	BEGIN comment;
X	printf("%s",cs);
X	ECHO;
X	dprintf(stderr,"[CS]");
X	}
X<comment>"*/" {			/* end a comment */
X	ECHO;
X	printf("%s",ce);
X	BEGIN start;
X	dprintf(stderr,"[CE]");
X	}
X<start,comment,quote>"\-|" {	/* handle troff escapes */
X	if (no_troff)
X           ECHO;
X	else switch(*yytext) {
X           case '-':  printf("\\-");   break;
X	   case '\\': printf("\\e");   break;
X	   case '|':  printf("\\(or"); break;
X           }
X	dprintf(stderr,"%s",yytext);
X	}
X<start>\" {			/* start quote */
X	BEGIN quote;
X	ECHO;
X	dprintf(stderr,"[\"");
X	}
X<quote>\\\" {			/* \" in a string */
X	printf("\\e\"");
X	}
X<quote>\" {			/* end quoted string */
X	BEGIN start;
X	ECHO;
X	dprintf(stderr,"\"]");
X	}
X<start,comment,quote>[fF][il]	|
X<start,comment,quote>ff {	/* defeat troff ligatures */
X	if (no_lig)
X	   printf("%c\\&%c",yytext[0],yytext[1]);
X	else
X           ECHO;
X	dprintf(stderr,"[%s]\n",yytext);
X	}
X<start>^#{W}define	|
X<start>^#{W}undef	|
X<start>^#{W}line	|
X<start>^#{W}include	|
X<start>^#{W}ifdef	|
X<start>^#{W}ifndef	|
X<start>^#{W}if		|
X<start>^#{W}endif	|
X<start>^#{W}else {		/* pre-processor tokens */
X	   printf("%s%s%s",ps,yytext,pe);
X	   dprintf(stderr,"%s%s%s","[PS]",yytext,"[PE]");
X	}
X<start>{K}/{W}\( {		/* look for key words  - might be functions */
X	if (is_entry(keywords,HSIZE,yytext)) 
X	   printf("%s%s%s",ks,yytext,ke);
X 	else
X	   printf("%s%s%s",fs,yytext,fe);
X	}
X<start>{K} {			/* look for key words  - might be identifiers */
X	if (is_entry(keywords,HSIZE,yytext)) 
X	   printf("%s%s%s",ks,yytext,ke);
X 	else
X	   printf("%s%s%s",is,yytext,ie);
X	}
X%%
X
X#define GET_OPT(i)	\
X	strlen(argv[i])>2 ? argv[i]+2 : argv[++i]
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X   {
X   register int i;
X   register char c = '\0';
X
X   /* set default values */
X
X   ks = "\\fB";		/* keywords in bold */
X   ke = "\\fP";
X   cs = "\\fI";		/* comments in bold */
X   ce = "\\fP";
X   is = "";
X   ie = "";
X   fs = "";
X   fe = "";
X   ps = "\\fB";		/* cpp decl's in bold */
X   pe = "";
X
X   debug = getenv("DEBUG");
X
X   /* get arguments */
X
X   for(i=1;i<argc;i++) {
X      if (*argv[i] == '-')
X         switch (c = argv[i][1]) {
X            case 'a':	/* add keyword to list */
X               add_entry(keywords,HSIZE,GET_OPT(i));
X               break;
X            case 'd':	/* delete keyword from list */
X               dlt_entry(keywords,HSIZE,GET_OPT(i));
X               break;
X            case 'F':	/* force processing without .SS */
X               unput('\n');unput('S'); unput('S'); unput('.');
X               force++;
X               break;
X            case 'l':	/* don't pass any ligatures to troff */
X               no_lig++;	
X               break;
X            case 't':	/* don't futz with \, | or - \n */
X               no_troff++;	
X               break;
X            case 'p':	/* set pre-processor escape prefix */
X               ps = GET_OPT(i);
X               break;
X            case 'i':	/* set identifier escape prefix */
X               is = GET_OPT(i);
X               break;
X            case 'f':	/* set function escape prefix */
X               fs = GET_OPT(i);
X               break;
X            case 'k':	/* set keyword escape prefix */
X               ps = ks = GET_OPT(i);
X               break;
X            case 'c':	/* set comment escape prefix */
X               cs = GET_OPT(i);
X               break;
X            case 'e':	/* set all ending escape prefixen */
X               ie = pe = fe = ke = ce = GET_OPT(i);
X               break;
X            default:
X               fprintf(stderr,"%s: flag %s ignored\n",*argv,argv[i]);
X               break;
X            }
X         else switch(c) {	/* optional turn-off codes */
X            case 'p':
X               pe = argv[i];
X               break;
X            case 'i':
X               ie = argv[i];
X               break;
X            case 'f':
X               fe = argv[i];
X               break;
X            case 'k':
X               pe = ke = argv[i];
X               break;
X            case 'c':
X               ce = argv[i];
X               break;
X            default:
X               fprintf(stderr,"%s: arg [%s] ignored\n",*argv,argv[i]);
X               break;
X            }
X      }
X   yylex();
X   }
X
Xyywrap()
X   {
X   return(1);
X   }
END_OF_FILE
# end of 'doc/usrman/croff/croff.l'
fi
if test -f 'doc/usrman/croff/hash.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/usrman/croff/hash.c'\"
else
echo shar: Extracting \"'doc/usrman/croff/hash.c'\" \(6039 characters\)
sed "s/^X//" >'doc/usrman/croff/hash.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: hash.c,v 1.1 88/07/07 10:12:06 sau Exp $
X	$Source: /tmp/mgrsrc/doc/usrman/croff/RCS/hash.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/doc/usrman/croff/RCS/hash.c,v $$Revision: 1.1 $";
X
X/************************************************************************
X *
X *	Simple Forms Package		Version 1.0	10/83
X */
X
X/* table lookup routines */
X
X#include "hash.h"
X#include <stdio.h>
X
X/*******************************************************************************
X * Generate a hash table index from an arbitrary length string
X * This is probably not a good algorithm
X */
X
Xint
XHash(key,max)
Xchar *key;		/* key to hash on */
Xint max;		/* max should be a prime number */
X   {
X   register int i = 0;
X   register long sum;
X   for(sum = 0; *key != '\0';i++, sum += (*key++)<<(i&7));
X   return((int) (sum % max));
X   }
X
X/*******************************************************************************
X * Generate a hash table index from an arbitrary length string
X * This is probably not a good algorithm
X */
X
Xint
Xhash(key,max)
Xregister char *key;		/* key to hash on */
Xint max;			/* max should be a prime number */
X   {
X   register int sum;
X        
X   for (sum = *key; *key; sum += (*key) * (*(++key)));
X   return( (sum += *(key-2)) % max);
X   }
X
X/*******************************************************************************
X *	add an entry to the hash table, return count
X */
X
Xint
Xadd_entry(table,size,name)
Xstruct table_entry *table[];	/* name of hash table */
Xint size;			/* number of table entries */
Xchar *name;			/* name to be put in table */
X	{
X	int HASH(), index;
X	char *alloc(), *save_line();
X	register TABLE *list;
X
X	index=HASH(name,size);
X	for(list=table[index]; list != (TABLE *) 0; list = list -> next)
X	   if (Same(list->name,name)) {
X	      list -> count += 1;
X	      return(list -> count);
X	      }
X	list = (TABLE *) alloc(sizeof (TABLE));
X	list -> name = save_line(name);
X	list -> next = table[index];
X	list -> value = (char *) 0;
X	list -> count = 1;
X	table[index] = list;
X	return(1);
X	}	    
X
X/*******************************************************************************
X *	remove an entry to the hash table, return count
X */
X
Xint
Xdlt_entry(table,size,name)
Xstruct table_entry *table[];	/* pntr to hash table */
Xint size;			/* size of hash table */
Xchar *name;			/* name to be put in table */
X	{
X	int HASH(), index;
X	void free();
X	register struct table_entry *list, *temp= (struct table_entry *) 0;
X	index=HASH(name,size);
X	for(list=table[index]; list != (TABLE *) 0; temp=list,list = list->next)
X	   if (Same(list->name,name)) {
X	      if (list -> count > 0)
X	         list -> count -= 1;
X	      if (list -> count == 0 && !(list->flags&HASH_STATIC)) {
X	         free(list -> name);
X	         if (list -> value)
X 	            free(list -> value);
X	         if (list == table[index]) {
X	            table[index] = list->next;
X	            free(list);
X	            }
X	         else {
X	            temp->next = list->next;
X                    free(list);
X	            }
X		 return(0);
X	         }    
X	      else return(list -> count);
X	      }
X	return(-1);
X	}	    
X
X/*******************************************************************************
X *	get an entry to the hash table, return value
X */
X
Xchar *
Xget_entry(table,size,name)
Xstruct table_entry *table[];
Xint size;
Xchar *name;			/* name to be put in table */
X	{
X	int HASH(), index;
X	register struct table_entry *list;
X
X	index=HASH(name,size);
X	for(list=table[index]; list != (TABLE *) 0; list = list -> next)
X	   if (Same(list->name,name)) {
X	      return(list->count > 0 ? list -> value : (char *) 0);
X	      }
X	return((char *) 0);
X	}	    
X
X/*******************************************************************************
X *	see if item is in table 
X */
X
Xint
Xis_entry(table,size,name)
Xstruct table_entry *table[];
Xint size;
Xchar *name;			/* name to be put in table */
X	{
X	int HASH(), index;
X	register struct table_entry *list;
X
X	index=HASH(name,size);
X	for(list=table[index]; list != (TABLE *) 0; list = list -> next)
X	   if (Same(list->name,name)) {
X	      return(list->count);
X	      }
X	return(0);
X	}	    
X
X/*******************************************************************************
X *	put an entry to the hash table, return 1 if ok
X */
X
Xint
Xput_entry(table,size,name,value)
Xstruct table_entry *table[];	/* name of hash table */
Xint size;			/* number of table entries */
Xchar *name;			/* name to be put in table */
Xchar *value;			/* value to be put into table */
X	{
X	int HASH(), index;
X	register struct table_entry *list;
X        char *save_line();
X	void free();
X
X	index=HASH(name,size);
X	for(list=table[index]; list != (TABLE *) 0; list = list -> next)
X	   if (Same(list->name,name) && !(list->flags&HASH_STATIC)) {
X	      if (list -> value != (char *) 0) free(list -> value);
X	      if (value != (char *) 0) list -> value = save_line(value);
X              else list->value == (char *) 0;
X	      return(1);
X	      }
X	return(0);
X	}	    
X
X/*******************************************************************************
X *
X *	allocate space for, and save a string; return its address
X */
X
Xchar *
Xsave_line(string)
Xchar *string;
X   {
X   char *where,*alloc(),*strcpy();
X
X   if (string == (char *) 0) string = "";
X   where=alloc(strlen(string)+1);
X   strcpy(where,string);
X   return(where);
X   }
X
X/*******************************************************************************
X *
X *	allocate some space
X */
X
Xchar *
Xalloc(bytes)
Xint bytes;
X  {
X  char *malloc(),*where;
X  void exit();
X
X  if ((where=malloc((unsigned)bytes)) == NULL) {
X     fprintf(stderr,"no room for %d bytes\n",bytes);
X     exit(1);
X     }
X  return(where);
X  }	
END_OF_FILE
# end of 'doc/usrman/croff/hash.c'
fi
if test -f 'src/blit/hash.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/blit/hash.c'\"
else
echo shar: Extracting \"'src/blit/hash.c'\" \(6027 characters\)
sed "s/^X//" >'src/blit/hash.c' <<'END_OF_FILE'
X/*                        Copyright (c) 1988 Bellcore
X *                            All Rights Reserved
X *       Permission is granted to copy or use this program, EXCEPT that it
X *       may not be sold for profit, the copyright notice must be reproduced
X *       on copies, and credit should be given to Bellcore where it is due.
X *       BELLCORE MAKES NO WARRANTY AND ACCEPTS NO LIABILITY FOR THIS PROGRAM.
X */
X/*	$Header: hash.c,v 4.1 88/06/21 13:19:05 bianchi Exp $
X	$Source: /tmp/mgrsrc/src/blit/RCS/hash.c,v $
X*/
Xstatic char	RCSid_[] = "$Source: /tmp/mgrsrc/src/blit/RCS/hash.c,v $$Revision: 4.1 $";
X
X/************************************************************************
X *
X *	Simple Forms Package		Version 1.0	10/83
X */
X
X/* table lookup routines */
X
X#include "hash.h"
X#include <stdio.h>
X
X/*******************************************************************************
X * Generate a hash table index from an arbitrary length string
X * This is probably not a good algorithm
X */
X
Xint
XHash(key,max)
Xchar *key;		/* key to hash on */
Xint max;		/* max should be a prime number */
X   {
X   register int i = 0;
X   register long sum;
X   for(sum = 0; *key != '\0';i++, sum += (*key++)<<(i&7));
X   return((int) (sum % max));
X   }
X
X/*******************************************************************************
X * Generate a hash table index from an arbitrary length string
X * This is probably not a good algorithm
X */
X
Xint
Xhash(key,max)
Xregister char *key;		/* key to hash on */
Xint max;			/* max should be a prime number */
X   {
X   register int sum;
X        
X   for (sum = *key; *key; sum += (*key) * (*(++key)));
X   return( (sum += *(key-2)) % max);
X   }
X
X/*******************************************************************************
X *	add an entry to the hash table, return count
X */
X
Xint
Xadd_entry(table,size,name)
Xstruct table_entry *table[];	/* name of hash table */
Xint size;			/* number of table entries */
Xchar *name;			/* name to be put in table */
X	{
X	int HASH(), index;
X	char *alloc(), *save_line();
X	register TABLE *list;
X
X	index=HASH(name,size);
X	for(list=table[index]; list != (TABLE *) 0; list = list -> next)
X	   if (Same(list->name,name)) {
X	      list -> count += 1;
X	      return(list -> count);
X	      }
X	list = (TABLE *) alloc(sizeof (TABLE));
X	list -> name = save_line(name);
X	list -> next = table[index];
X	list -> value = (char *) 0;
X	list -> count = 1;
X	table[index] = list;
X	return(1);
X	}	    
X
X/*******************************************************************************
X *	remove an entry to the hash table, return count
X */
X
Xint
Xdlt_entry(table,size,name)
Xstruct table_entry *table[];	/* pntr to hash table */
Xint size;			/* size of hash table */
Xchar *name;			/* name to be put in table */
X	{
X	int HASH(), index;
X	void free();
X	register struct table_entry *list, *temp= (struct table_entry *) 0;
X	index=HASH(name,size);
X	for(list=table[index]; list != (TABLE *) 0; temp=list,list = list->next)
X	   if (Same(list->name,name)) {
X	      if (list -> count > 0)
X	         list -> count -= 1;
X	      if (list -> count == 0 && !(list->flags&HASH_STATIC)) {
X	         free(list -> name);
X	         if (list -> value)
X 	            free(list -> value);
X	         if (list == table[index]) {
X	            table[index] = list->next;
X	            free(list);
X	            }
X	         else {
X	            temp->next = list->next;
X                    free(list);
X	            }
X		 return(0);
X	         }    
X	      else return(list -> count);
X	      }
X	return(-1);
X	}	    
X
X/*******************************************************************************
X *	get an entry to the hash table, return value
X */
X
Xchar *
Xget_entry(table,size,name)
Xstruct table_entry *table[];
Xint size;
Xchar *name;			/* name to be put in table */
X	{
X	int HASH(), index;
X	register struct table_entry *list;
X
X	index=HASH(name,size);
X	for(list=table[index]; list != (TABLE *) 0; list = list -> next)
X	   if (Same(list->name,name)) {
X	      return(list->count > 0 ? list -> value : (char *) 0);
X	      }
X	return((char *) 0);
X	}	    
X
X/*******************************************************************************
X *	see if item is in table 
X */
X
Xint
Xis_entry(table,size,name)
Xstruct table_entry *table[];
Xint size;
Xchar *name;			/* name to be put in table */
X	{
X	int HASH(), index;
X	register struct table_entry *list;
X
X	index=HASH(name,size);
X	for(list=table[index]; list != (TABLE *) 0; list = list -> next)
X	   if (Same(list->name,name)) {
X	      return(list->count);
X	      }
X	return(0);
X	}	    
X
X/*******************************************************************************
X *	put an entry to the hash table, return 1 if ok
X */
X
Xint
Xput_entry(table,size,name,value)
Xstruct table_entry *table[];	/* name of hash table */
Xint size;			/* number of table entries */
Xchar *name;			/* name to be put in table */
Xchar *value;			/* value to be put into table */
X	{
X	int HASH(), index;
X	register struct table_entry *list;
X        char *save_line();
X	void free();
X
X	index=HASH(name,size);
X	for(list=table[index]; list != (TABLE *) 0; list = list -> next)
X	   if (Same(list->name,name) && !(list->flags&HASH_STATIC)) {
X	      if (list -> value != (char *) 0) free(list -> value);
X	      if (value != (char *) 0) list -> value = save_line(value);
X              else list->value == (char *) 0;
X	      return(1);
X	      }
X	return(0);
X	}	    
X
X/*******************************************************************************
X *
X *	allocate space for, and save a string; return its address
X */
X
Xchar *
Xsave_line(string)
Xchar *string;
X   {
X   char *where,*alloc(),*strcpy();
X
X   if (string == (char *) 0) string = "";
X   where=alloc(strlen(string)+1);
X   strcpy(where,string);
X   return(where);
X   }
X
X/*******************************************************************************
X *
X *	allocate some space
X */
X
Xchar *
Xalloc(bytes)
Xint bytes;
X  {
X  char *malloc(),*where;
X  void exit();
X
X  if ((where=malloc((unsigned)bytes)) == NULL) {
X     fprintf(stderr,"no room for %d bytes\n",bytes);
X     exit(1);
X     }
X  return(where);
X  }	
END_OF_FILE
# end of 'src/blit/hash.c'
fi
if test -f 'src/default_font.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/default_font.h'\"
else
echo shar: Extracting \"'src/default_font.h'\" \(6467 characters\)
sed "s/^X//" >'src/default_font.h' <<'END_OF_FILE'
X/* static font file */
X
Xstruct font_header default_font_head = {
X	(char) 22, (char) 8, (char) 16,
X	(char) 5, (char) 95, (char) 32
X	};
X
Xshort default_font_image[] = {
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x003c, 0x003c, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x000e, 0x0070, 0x0000,
X	0x0008, 0x240a, 0x3864, 0x3008, 0x0810, 0x0800, 0x0000, 0x0002,
X	0x3c08, 0x3c3c, 0x0c3e, 0x3c7e, 0x3c3c, 0x0000, 0x0400, 0x203c,
X	0x1810, 0x781c, 0x787e, 0x7e1c, 0x423e, 0x1e42, 0x40c6, 0x423c,
X	0x7c3c, 0x7c3c, 0x7e42, 0x8282, 0x4282, 0x7e20, 0x2004, 0x0000,
X	0x2000, 0x4000, 0x0200, 0x0c00, 0x4008, 0x0440, 0x3800, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0808, 0x0000,
X	0x0008, 0x240a, 0x54a4, 0x4808, 0x1008, 0x2a00, 0x0000, 0x0002,
X	0x4218, 0x4242, 0x0c20, 0x4202, 0x4242, 0x0000, 0x0800, 0x1042,
X	0x2410, 0x4422, 0x4440, 0x4022, 0x4208, 0x0244, 0x40c6, 0x6242,
X	0x4242, 0x4242, 0x0842, 0x8292, 0x4282, 0x0220, 0x2004, 0x0000,
X	0x1000, 0x4000, 0x0200, 0x1200, 0x4008, 0x0440, 0x0800, 0x0000,
X	0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0010, 0x0808, 0x0000,
X	0x0008, 0x2414, 0x54a8, 0x4808, 0x1008, 0x1c08, 0x0000, 0x0004,
X	0x4228, 0x4242, 0x1420, 0x4002, 0x4242, 0x0000, 0x1000, 0x0842,
X	0x4228, 0x4442, 0x4240, 0x4042, 0x4208, 0x0248, 0x40aa, 0x6242,
X	0x4242, 0x4242, 0x0842, 0x4492, 0x2444, 0x0420, 0x1004, 0x1000,
X	0x0800, 0x4000, 0x0200, 0x1000, 0x4000, 0x0040, 0x0800, 0x0000,
X	0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0010, 0x0808, 0x0000,
X	0x0008, 0x243e, 0x50c8, 0x3008, 0x2004, 0x2a08, 0x0000, 0x0004,
X	0x4608, 0x0202, 0x147c, 0x7c04, 0x4242, 0x0808, 0x2000, 0x0402,
X	0x4e28, 0x4440, 0x4240, 0x4040, 0x4208, 0x0250, 0x40aa, 0x5242,
X	0x4242, 0x4220, 0x0842, 0x4492, 0x2444, 0x0820, 0x1004, 0x2800,
X	0x0438, 0x5c3c, 0x3a3c, 0x7c3a, 0x5c38, 0x1c44, 0x08ee, 0x5c3c,
X	0x5c3a, 0x2c3c, 0x7c42, 0x4282, 0x4442, 0x7c10, 0x0808, 0x3200,
X	0x0008, 0x0014, 0x3808, 0x2000, 0x2004, 0x0808, 0x007e, 0x0008,
X	0x4a08, 0x041c, 0x2442, 0x4204, 0x3c42, 0x0808, 0x407e, 0x0204,
X	0x5244, 0x7c40, 0x427c, 0x7c40, 0x7e08, 0x0270, 0x40aa, 0x5242,
X	0x4242, 0x7c18, 0x0842, 0x4454, 0x1828, 0x0820, 0x0804, 0x4400,
X	0x0044, 0x6242, 0x4642, 0x1046, 0x6208, 0x0448, 0x0892, 0x6242,
X	0x6246, 0x3242, 0x1042, 0x4282, 0x4442, 0x0410, 0x0808, 0x5a00,
X	0x0008, 0x0028, 0x1410, 0x5200, 0x2004, 0x007e, 0x0000, 0x0008,
X	0x5208, 0x0802, 0x2402, 0x4208, 0x4242, 0x0000, 0x4000, 0x0208,
X	0x5244, 0x4240, 0x4240, 0x404e, 0x4208, 0x0248, 0x4092, 0x4a42,
X	0x7c42, 0x4804, 0x0842, 0x287c, 0x1828, 0x1020, 0x0804, 0x8200,
X	0x0004, 0x4240, 0x4242, 0x1042, 0x4208, 0x0450, 0x0892, 0x4242,
X	0x4242, 0x2040, 0x1042, 0x2492, 0x2822, 0x0860, 0x0806, 0x4c00,
X	0x0008, 0x007c, 0x1413, 0x9400, 0x2004, 0x0008, 0x0000, 0x0010,
X	0x6208, 0x1002, 0x4402, 0x4208, 0x423e, 0x0000, 0x207e, 0x0408,
X	0x4c44, 0x4240, 0x4240, 0x4042, 0x4208, 0x0244, 0x4092, 0x4a42,
X	0x4042, 0x4402, 0x0842, 0x2854, 0x2410, 0x2020, 0x0404, 0x0000,
X	0x003c, 0x4240, 0x427e, 0x1042, 0x4208, 0x0470, 0x0892, 0x4242,
X	0x4242, 0x203c, 0x1042, 0x2492, 0x1024, 0x1010, 0x0808, 0x0000,
X	0x0000, 0x0028, 0x5415, 0x8800, 0x2004, 0x0008, 0x0000, 0x0010,
X	0x4208, 0x2042, 0x7e42, 0x4210, 0x4202, 0x0000, 0x1000, 0x0800,
X	0x40fe, 0x4242, 0x4240, 0x4042, 0x4208, 0x4244, 0x4092, 0x4642,
X	0x4042, 0x4442, 0x0842, 0x2844, 0x2410, 0x2020, 0x0404, 0x0000,
X	0x0044, 0x4240, 0x4240, 0x1042, 0x4208, 0x0448, 0x0892, 0x4242,
X	0x4242, 0x2002, 0x1042, 0x2492, 0x2814, 0x2010, 0x0808, 0x0000,
X	0x0008, 0x0050, 0x5425, 0x8800, 0x1008, 0x0008, 0x1800, 0x0820,
X	0x4208, 0x4042, 0x0442, 0x4210, 0x4242, 0x0818, 0x0800, 0x1008,
X	0x2282, 0x4222, 0x4440, 0x4026, 0x4208, 0x4242, 0x4082, 0x4642,
X	0x4042, 0x4242, 0x0842, 0x1044, 0x4210, 0x4020, 0x0204, 0x0000,
X	0x0044, 0x6242, 0x4642, 0x1046, 0x4208, 0x0444, 0x0892, 0x4242,
X	0x6246, 0x2042, 0x1246, 0x1892, 0x4418, 0x4010, 0x0808, 0x0000,
X	0x0008, 0x0050, 0x3826, 0x7600, 0x1008, 0x0000, 0x0800, 0x0820,
X	0x3c3e, 0x7e3c, 0x043c, 0x3c10, 0x3c3c, 0x0808, 0x0400, 0x2008,
X	0x1c82, 0x7c1c, 0x787e, 0x401a, 0x423e, 0x3c42, 0x7e82, 0x423c,
X	0x403c, 0x423c, 0x083c, 0x1044, 0x4210, 0x7e20, 0x0204, 0x0000,
X	0x003a, 0x5c3c, 0x3a3c, 0x103a, 0x4208, 0x0442, 0x0892, 0x423c,
X	0x5c3a, 0x203c, 0x0c3a, 0x186c, 0x4408, 0x7e10, 0x0808, 0x0000,
X	0x0000, 0x0000, 0x1000, 0x0000, 0x0810, 0x0000, 0x0800, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0010, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0004, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0002, 0x0000, 0x0400, 0x0000, 0x0000,
X	0x4002, 0x0000, 0x0000, 0x0000, 0x0008, 0x0010, 0x0808, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0420, 0x0000, 0x1000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x000e, 0x0000, 0x0000, 0x0000, 0x0000, 0x003c, 0x003c, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0042, 0x0000, 0x4400, 0x0000, 0x0000,
X	0x4002, 0x0000, 0x0000, 0x0000, 0x0050, 0x000e, 0x0870, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x003c, 0x0000, 0x3800, 0x0000, 0x0000,
X	0x4002, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x00fe,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X	
X	};
X
Xbit_static(default_font,760,16,default_font_image,1);
END_OF_FILE
# end of 'src/default_font.h'
fi
echo shar: End of archive 24 \(of 61\).
cp /dev/null ark24isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
	21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \
	38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \
	55 56 57 58 59 60 61 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 61 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
