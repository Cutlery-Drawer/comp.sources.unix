Subject:  v17i065:  Zoo archive program, Part02/10
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Rahul Dhesi <bsu-cs!dhesi@iuvax.cs.indiana.edu>
Posting-number: Volume 17, Issue 65
Archive-name: zoo2/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 10)."
# Wrapped by rsalz@papaya.bbn.com on Thu Feb  2 18:03:57 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Copyright' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Copyright'\"
else
echo shar: Extracting \"'Copyright'\" \(3768 characters\)
sed "s/^X//" >'Copyright' <<'END_OF_FILE'
X
X                            COPYRIGHT
X
X
XThe following rules apply only to the zoo archiver itself.
XCurrently, all extract-only programs, and all supporting utili-
Xties, are fully in the public domain and are expected to remain so
Xfor the forseeable future.
X
X
X               Copyright Statement for Version 1.71
X
XThe distribution restrictions placed on zoo versions 1.71 and ear-
Xlier are now relaxed.  Version 1.71 and earlier source and the
XAmigaDOS and MS-DOS binary files may be distributed for any pur-
Xpose, whether commercial or noncommercial, by anybody, provided
X(a) the files are distributed unmodified and (b) the recipient is
Xnotified in advance of being provided the software that "version
X1.71 is an outdated version and version 2.00 and higher versions
Xare now available from other sources".  However, creation and dis-
Xtribution of any derivative work is governed by the copyright
Xstatement for versions 2.00 and 2.01.
X
X
X          Copyright Statement for Versions 2.00 and 2.01
X
XThe following conditions apply to the C source code, the MS-DOS
Xsupport package, and to the MS-DOS executable code.  Distribution
Xconditions for J. Brian Waters's AmigaDOS implementation may
Xdiffer and will be stated in the copyright statement accompanying
Xit.
X
X"This program" refers to versions 2.00 and 2.01 and separately to
Xeach subsequent version of the Zoo archiver and to all derivative
Xworks thereof.  "Distribution right" means any copyright, compila-
Xtion copyright, license, or other right to control distribution or
Xcopying.  "Compiled code" means software that can be executed by a
Xcomputer system.
X
XThis program is copyrighted but its distribution for noncommercial
Xpurposes is permitted, with the following restrictions.
X
X   - You are prohibited from distributing this program as part of
X     any package over which you claim a distribution right.  This
X     restriction does not apply if any distribution right is
X     claimed only over individual items that you own or for which
X     the distribution right has been explicitly assigned to you,
X     and not over the package as a collection.
X
X   - You are prohibited from making this program available for
X     downloading via telecommunications if you charge a total of
X     more than $8.00 per hour at 1200 bps during evening and night
X     hours.
X
X   - You are prohibited from distributing this program as compiled
X     code unless you also distribute the source code from which
X     the compiled code was obtained.  This restriction does not
X     apply if the compiled code was created by me.
X
X   - You are prohibited from creating, from this program, any
X     derivative work over which you claim a distribution right.
X
X   - You are prohibited from creating from this program, whether
X     deliberately or through negligence, any derivative work that
X     violates the compatibility goals stated in the user manual
X     for this program.
X
X   - You may use this program, and any derivative works that you
X     create, internally within your own organization free of
X     charge.  You may distribute such derivative works outside
X     your organization provided you adhere to all other conditions
X     of this copyright policy.
X
XThe above restrictions may be relaxed by special agreement; please
Xcontact me for details.
X
X
X                              -- Rahul Dhesi 1988/08/25
X                                 UUCP:    iuvax!bsu-cs!dhesi or
X                                          pur-ee!bsu-cs!dhesi
X                                 GEnie:   DHESI
X                                 Plink:   OLS806
X                                 Phone:   +1 317 285 8641 daytime EST
X                                 US mail: 720 W. Centennial Ave #15,
X                                          Muncie, Indiana 47303
END_OF_FILE
if test 3768 -ne `wc -c <'Copyright'`; then
    echo shar: \"'Copyright'\" unpacked with wrong size!
fi
# end of 'Copyright'
fi
if test -f 'addfname.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'addfname.c'\"
else
echo shar: Extracting \"'addfname.c'\" \(3539 characters\)
sed "s/^X//" >'addfname.c' <<'END_OF_FILE'
X#ifndef LINT
Xstatic char sccsid[]="@(#) addfname.c 2.11 88/02/06 20:17:17";
X#endif /* LINT */
X
X/*
XCopyright (C) 1986, 1987 Rahul Dhesi -- All rights reserved
X(C) Copyright 1988 Rahul Dhesi -- All rights reserved
X*/
X#include "options.h"
X
X/* Adds a filename to global list.  (This global list will eventually
Xbe searched by the inlist() function.)  The second and subsequent
Xparameters suppplied are stored with the name of the file and 
Xreturned by inlist. */
X
X#include "zooio.h"
X#include "various.h"
X#include "zoo.h"
X#include "zoofns.h"
X#include "zoomem.h" /* to get LIST_SIZE */
X
Xstatic struct item *fentry[LIST_SIZE];
Xstatic int lastname = 0;                  /* index of last name */
X
Xstruct item {              /* global filename list entry */
X   char *fname;
X   long position;
X   unsigned int date;
X   unsigned int time;
X	unsigned vflag;
X	unsigned version_no;
X};
X
Xvoid addfname(fname, position, date, time, vflag, version_no)
Xchar *fname;
Xlong position;
Xunsigned int date, time;
Xunsigned vflag;
Xunsigned version_no;
X{
X   if (lastname == 0)
X      fentry[lastname] = (struct item *) emalloc (sizeof(struct item));
X
X   /* keep a few empty spaces at end to avoid off by one errors */
X   if (lastname >= LIST_SIZE - 3)
X      memerr();
X
X   fentry[lastname]->fname = strdup(fname);
X   fentry[lastname]->position = position;
X   fentry[lastname]->date = date;
X   fentry[lastname]->time = time;
X	fentry[lastname]->vflag = vflag;
X	fentry[lastname]->version_no = version_no;
X   lastname++;
X   /* allocate memory for empty entry at end */
X   fentry[lastname] = (struct item *) emalloc (sizeof(struct item)); 
X} /* addfname */
X
X/* inlist() */
X/* Examines global list built by addfname() to see if supplied filename
Xis in the list.  
X
XIf found, returns the file's position within the archive as the function 
Xvalue and the date, time, version flag, and version number as parameters.
XIf not found, returns -1.  Also returns the highest version no. seen
Xfor this filename and the vflag associated with that version.
X
XA simple sequential search is done.
X
XIf justname is nonzero, then the search is for the filename only
Xwithout the directory prefix;  else it is for the full
Xpathname.
X*/
X
Xlong inlist (fname, date, time, this_version_no, high_vflag, 
X					high_version_no, high_pos, justname)
Xchar *fname;
Xunsigned int *date, *time;
Xunsigned *high_vflag;
Xunsigned *this_version_no;
Xunsigned *high_version_no;
Xlong *high_pos;
Xint justname;
X{
X   register int i = 0;
X
X	*high_version_no = 0;
X	if (justname)
X		fname = nameptr (fname);					/* if directory wanted */
X   fentry[lastname]->fname = fname;          /* sentinel */
X	fentry[lastname]->version_no = 0;
X
X#ifdef IGNORECASE
X#define	COMPARE	strcmpi
X#else
X#define	COMPARE	strcmp
X#endif
X
X   while (COMPARE(fname,
X			(justname ? nameptr (fentry[i]->fname) : fentry[i]->fname)) != 0) {
X      i++;
X   }
X
X   if (i == lastname)
X      return (-1L);
X   else {
X		int j;
X		*date = fentry[i]->date;
X		*time = fentry[i]->time;
X		*high_pos = fentry[i]->position;
X		*high_vflag = fentry[i]->vflag;
X		for (j = i; j < lastname; j++) {	/* find highest version no. for file */
X			if (COMPARE(fname,
X				(justname ? nameptr (fentry[j]->fname) : fentry[j]->fname)) == 0) {
X				if (*high_version_no < fentry[j]->version_no) {
X					*high_version_no = fentry[j]->version_no;
X					*high_vflag = fentry[j]->vflag;
X					*high_pos = fentry[j]->position;
X					*date = fentry[j]->date;
X					*time = fentry[j]->time;
X				}
X			}
X		}
X		*this_version_no = fentry[i]->version_no;
X      return (fentry[i]->position);
X   }
X} /* inlist() */
END_OF_FILE
if test 3539 -ne `wc -c <'addfname.c'`; then
    echo shar: \"'addfname.c'\" unpacked with wrong size!
fi
# end of 'addfname.c'
fi
if test -f 'basename.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'basename.c'\"
else
echo shar: Extracting \"'basename.c'\" \(3229 characters\)
sed "s/^X//" >'basename.c' <<'END_OF_FILE'
X#ifndef LINT
X/* @(#) basename.c 2.2 87/12/27 13:42:40 */
Xstatic char sccsid[]="@(#) basename.c 2.2 87/12/27 13:42:40";
X#endif /* LINT */
X
X/*
XCopyright (C) 1986, 1987 Rahul Dhesi -- All rights reserved
X*/
X
X#include "options.h"
X#include "zooio.h"
X#include "zoo.h"
X#include "parse.h"
X#include "various.h"
X#include "zoofns.h"
X#include "debug.h"
X#include "assert.h"
X
X/* This function strips device/directory information from
Xa pathname and returns just the plain filename */
Xvoid basename (pathname, fname)
Xchar *pathname;
Xchar fname[];
X{
X   strcpy (fname, nameptr (pathname));
X}
X
X/* Set of legal MSDOS filename characters.  The working of cvtchr() depends
Xon the order of the first few characters here.  In particular, '_' is
Xpositioned so '.' gets converted to it. */
Xstatic char legal[] = 
X"tabcdefghijklmnopqrs_uvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ@^`{}~!#$%&'()-";
X
X/****************
Xcvtchr() converts a character to a lowercase alphabetic character in
Xa somewhat random way.  
X*/
X#define  cvtchr(ch)        legal[(ch & 0xff) % 26]
X
X/***************
Xcleanup() cleans up a string so it contains only legal MSDOS filename
Xcharacters.  Any other characters are converted to an underscore.
XIf the filename is null or if it begins with a dot, it is fixed.
XAll dots are also converted.
X*/
X
X#ifdef LINT_ARGS
Xvoid cleanup (char *);
X#endif
X
Xvoid cleanup (p)
Xchar *p;
X{
X   assert(p != NULL);
X   if (*p == '\0')
X      strcpy (p, "X");
X   if (*p == '.')
X      *p = '_';
X   while (*p != '\0') {
X      if (strchr (legal, *p) == NULL) {   /* if invalid character */
X         *p = cvtchr(*p);
X      }
X      p++;
X   }
X}
X/* This function strips device/directory information from a pathname,
Xforces the remaining filename to MSDOS format, and returns it.  Any
Xillegal characters are fixed.
X*/
Xvoid dosname (pathname, fname)
Xchar *pathname;
Xchar fname[];
X{
X   struct path_st path_st;
X   parse (&path_st, pathname);
X   strcpy (fname, path_st.fname);
X   cleanup (fname);
X
X#ifdef VER_CH  /* remove any trailing extension field */
X   if (path_st.ext[0] != '\0')
X      strip_ver (path_st.ext);
X#endif
X
X   /* extension could have been nulled, so we test again */
X   if (path_st.ext[0] != '\0') {
X      cleanup (path_st.ext);
X      strcat (fname, ".");
X      strcat (fname, path_st.ext);
X   }
X
X#ifdef SPECMOD
X   specfname (fname);
X#endif
X}
X
X/* rootname() */
X/* Accepts a pathname.  Returns the root filename, i.e., with both the
Xdirectory path and the extension stripped. */
X
Xvoid rootname (path, root)
Xchar *path, *root;
X{
X   char *p;
X   static char dot[] = {EXT_CH, '\0'};
X   strcpy(root, nameptr(path));           /* copy all but path prefix */
X   p = findlast(root, dot);               /* find last dot */
X   if (p != NULL)                         /* if found ... */
X      *p = '\0';                          /* ... null it out */
X}
X
X/* nameptr() */
X/* Accepts a pathname.  Returns a pointer to the filename within
Xthat pathname.
X*/
X
Xchar *nameptr (path)
Xchar *path;
X{
X   char *t;
X   t = findlast (path, PATH_SEP);   /* last char separating device/directory */
X   debug ((printf ("nameptr:  findlast returned ptr to string [%s].\n",t)))
X   if (t == NULL)                /* no separator */
X      return (path);
X   else {
X      return (t+1);
X   }
X}
END_OF_FILE
if test 3229 -ne `wc -c <'basename.c'`; then
    echo shar: \"'basename.c'\" unpacked with wrong size!
fi
# end of 'basename.c'
fi
if test -f 'fiz.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fiz.1'\"
else
echo shar: Extracting \"'fiz.1'\" \(3849 characters\)
sed "s/^X//" >'fiz.1' <<'END_OF_FILE'
X.\" @(#) fiz.1 1.2 88/01/31 23:22:04
X.\"
X.\" For formatting with nroff:
X.\"   nroff -man fiz.1
X.\"
X.TH FIZ 1 "Jan 31, 1988"
X.SH NAME
Xfiz \- analyze damaged zoo archive for data revovery
X.SH SYNOPSIS
X.I fiz
X.RB archive[ .zoo ]
X.SH DESCRIPTION
X.I Fiz
Xis used to analyze damaged
X.I zoo
Xarchives and locate directory entries and file data in them.
XThe current version of 
X.I fiz
Xis 2.0 and it is meant to be used in conjunction with
X.I zoo
Xversion 2.0.
X.I Fiz
Xmakes no assumptions about archive structure.  Instead, it simply
Xsearches the entire subject archive for tag values
Xthat mark the locations of directory entries and file data.
XIn a 
X.I zoo
Xarchive, a
X.I directory entry
Xcontains information about a stored file such as its name, whether 
Xcompressed or not, and its timestamp.  The
X.I file data
Xare the actual data for the archived file, and may be
Xeither the original data, or the result of compressing the file.
X.PP
XFor each directory entry found,
X.I fiz
Xprints where in the archive it is located, the directory path and
Xfilename(s) found in it, whether the directory entry appears
Xto be corrupted (indicated by [*CRC Error*]), and the value of
Xthe pointer to the file data that is found in the directory entry.
XFor each block of file data found in the archive,
X.I fiz
Xprints where in the archive the block begins.  In the case of
Xan undamaged archive, the pointer to file data found in
Xa directory entry will correspond to where
X.I fiz
Xactually locates the data.  Here is some sample output from 
X.I fiz:
X.PP
X.nf
X****************
X    2526: DIR  [changes] ==>   95
X    2587: DATA
X****************
X    3909: DIR  [copyrite] ==> 1478
X    3970: DATA
X    4769: DATA
X****************
X.fi
X.sp 1
XIn such output, 
X.B DIR
Xindicates where 
X.I fiz
Xfound a directory entry in the archive, and
X.B DATA
Xindicates where 
X.I fiz
Xfound file data in the archive.  Filenames located by
X.I fiz
Xare enclosed in square brackets, and the notation
X"==>   95" indicates that the directory entry found by
X.I fiz
Xat position 2526 has a file data pointer to
Xposition 95.  In actuality,
X.I fiz
Xfound file data at positions 2587, 3970, and
X4769.  Since 
X.I fiz
Xfound only two directory entries, and each directory entry corresponds
Xto one file, one of the file data positions is an artifact.
X.PP
XOnce the locations of directory entries and file data are found, the
X.B @
Xmodifier to
X.I "zoo's"
Xarchive list and extract commands can be used and
Xthe archive contents selectively listed or extracted,
Xskipping the damaged portion.  This is further described
Xin the documentation for
X.I zoo(1).
X.PP
XIn the above case, commands to try giving to 
X.I zoo
Xmight be
X.B x@2526,2587
X(extract beginning at position 2526, and get file data
Xfrom position 2587),
X.B x@3090,3970
X(extract at 3090, get data from 3970)
Xand
X.B x@3909,4769
X(extract at 3909, get data from 4769).  Once a correctly-matched
Xdirectory entry/file data pair is found,
X.I zoo
Xwill in most cases synchronize with and correctly extract all files
Xsubsequently found in the archive.  Trial and error should allow
Xall undamaged files to be extracted.
XAlso note that self-extracting archives created using
X.I sez
X(the Self-Extracting
X.I Zoo
Xutility for MS-DOS), which are normally executed on an MS-DOS
Xsystem for extraction, can
Xbe extracted on non-MSDOS systems in a similar way.
X.PP
X.SH "SEE ALSO"
Xzoo(1)
X.SH BUGS
XRandom byte patterns can occasionally be incorrectly recognized
Xas tag values.  This occurs very rarely, however, and trial
Xand error will usually permit all undamaged data to be
Xextracted.
X.SH DIAGNOSTICS
X.I Fiz
Xalways exits with a status code of 0.
X.SH "FUTURE DIRECTIONS"
XAutomation of data recovery from a damaged archive is potentially
Xachievable.  However, since damaged archives occur only rarely,
X.I fiz
Xas it currently stands is unlikely to change much in the
Xnear future.
X.SH AUTHOR
XRahul Dhesi
END_OF_FILE
if test 3849 -ne `wc -c <'fiz.1'`; then
    echo shar: \"'fiz.1'\" unpacked with wrong size!
fi
# end of 'fiz.1'
fi
if test -f 'fiz.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fiz.man'\"
else
echo shar: Extracting \"'fiz.man'\" \(4227 characters\)
sed "s/^X//" >'fiz.man' <<'END_OF_FILE'
X
X
X
XFIZ(1)              **IX Programmer's Manual               FIZ(1)
X
X
X
XNAME
X     fiz - analyze damaged zoo archive for data revovery
X
XSYNOPSIS
X     fiz archive[.zoo]
X
XDESCRIPTION
X     Fiz is used to analyze damaged zoo archives and locate
X     directory entries and file data in them.  The current ver-
X     sion of fiz is 2.0 and it is meant to be used in conjunction
X     with zoo version 2.0.  Fiz makes no assumptions about
X     archive structure.  Instead, it simply searches the entire
X     subject archive for tag values that mark the locations of
X     directory entries and file data.  In a zoo archive, a direc-
X     tory entry contains information about a stored file such as
X     its name, whether compressed or not, and its timestamp.  The
X     file data are the actual data for the archived file, and may
X     be either the original data, or the result of compressing
X     the file.
X
X     For each directory entry found, fiz prints where in the
X     archive it is located, the directory path and filename(s)
X     found in it, whether the directory entry appears to be cor-
X     rupted (indicated by [*CRC Error*]), and the value of the
X     pointer to the file data that is found in the directory
X     entry.  For each block of file data found in the archive,
X     fiz prints where in the archive the block begins.  In the
X     case of an undamaged archive, the pointer to file data found
X     in a directory entry will correspond to where fiz actually
X     locates the data.  Here is some sample output from fiz:
X
X     ****************
X         2526: DIR  [changes] ==>   95
X         2587: DATA
X     ****************
X         3909: DIR  [copyrite] ==> 1478
X         3970: DATA
X         4769: DATA
X     ****************
X
X     In such output, DIR indicates where fiz found a directory
X     entry in the archive, and DATA indicates where fiz found
X     file data in the archive.  Filenames located by fiz are
X     enclosed in square brackets, and the notation "==>   95"
X     indicates that the directory entry found by fiz at position
X     2526 has a file data pointer to position 95.  In actuality,
X     fiz found file data at positions 2587, 3970, and 4769.
X     Since fiz found only two directory entries, and each direc-
X     tory entry corresponds to one file, one of the file data
X     positions is an artifact.
X
X
X
X
X
XPrinted 2/7/88            Jan 31, 1988                          1
X
X
X
X
X
X
XFIZ(1)              **IX Programmer's Manual               FIZ(1)
X
X
X
X     Once the locations of directory entries and file data are
X     found, the @ modifier to zoo's archive list and extract com-
X     mands can be used and the archive contents selectively
X     listed or extracted, skipping the damaged portion.  This is
X     further described in the documentation for zoo(1).
X
X     In the above case, commands to try giving to zoo might be
X     x@2526,2587 (extract beginning at position 2526, and get
X     file data from position 2587), x@3090,3970 (extract at 3090,
X     get data from 3970) and x@3909,4769 (extract at 3909, get
X     data from 4769).  Once a correctly-matched directory
X     entry/file data pair is found, zoo will in most cases syn-
X     chronize with and correctly extract all files subsequently
X     found in the archive.  Trial and error should allow all
X     undamaged files to be extracted.  Also note that self-
X     extracting archives created using sez (the Self-Extracting
X     Zoo utility for MS-DOS), which are normally executed on an
X     MS-DOS system for extraction, can be extracted on non-MSDOS
X     systems in a similar way.
X
XSEE ALSO
X     zoo(1)
X
XBUGS
X     Random byte patterns can occasionally be incorrectly recog-
X     nized as tag values.  This occurs very rarely, however, and
X     trial and error will usually permit all undamaged data to be
X     extracted.
X
XDIAGNOSTICS
X     Fiz always exits with a status code of 0.
X
XFUTURE DIRECTIONS
X     Automation of data recovery from a damaged archive is poten-
X     tially achievable.  However, since damaged archives occur
X     only rarely, fiz as it currently stands is unlikely to
X     change much in the near future.
X
XAUTHOR
X     Rahul Dhesi
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
XPrinted 2/7/88            Jan 31, 1988                          2
X
X
X
END_OF_FILE
if test 4227 -ne `wc -c <'fiz.man'`; then
    echo shar: \"'fiz.man'\" unpacked with wrong size!
fi
# end of 'fiz.man'
fi
if test -f 'generic.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'generic.c'\"
else
echo shar: Extracting \"'generic.c'\" \(3350 characters\)
sed "s/^X//" >'generic.c' <<'END_OF_FILE'
X#ifndef LINT
Xstatic char genericid[]="@(#) generic.c 2.2 88/01/24 12:44:03";
X#endif /* LINT */
X
X/* 
XGeneric template for machine-dependent functions.
X
XThe contents of this file are hereby released to the public domain
X
X											-- Rahul Dhesi 1988/01/24
X
XFunctions in this file have not yet been revised to work with zoo 
Xversion 2.0.  To port zoo to a new system, look in files sysv.c and bsd.c 
Xto see which system-dependent functions may be needed.
X*/
X
X/****************
Xfunction trunc() truncates a file.
X*/
X
Xint trunc (handle)
Xint handle;
X{
X   /* code to truncate file goes here -- may be left empty */
X}
X
X/*****************
XFunction gettime() or getutime() gets the date and time of the file handle 
Xor filename supplied.  Date and time is in MSDOS format.
X*/
X#ifdef GETUTIME
Xgetutime (fname, date, time)
Xchar *fname;
X#else
Xgettime (handle,date,time)
Xint handle;
X#endif
Xunsigned *date, *time;
X{
X   *date = *time = 0; /* not yet implemented */
X}
X
X/*****************
XFunction settime() or setutime() sets the date and time of the file handle
Xor filename supplied.  Date and time is in MSDOS format.
X*/
X#ifdef NIXTIME
Xint setutime(path,date,time)
Xchar *path;
X#else
Xint settime(handle, date, time)
Xint handle;
X#endif
Xunsigned int date, time;
X{
X   /* not yet implemented */
X}
X
X/*****************
XFunction mktemp() accepts a template of the form `baseXXXXXX' where
Xbase is an arbitrary string, and returns a unique temporary filename.
XIf template is not correct, it is returned unchanged.
X*/
Xchar *mktemp(template)
Xchar *template;
X{
X#ifndef NDEBUG
X   if (instr(template, "XXXXXX") == -1)
X      prterror ('w', "Incorrect template [%s] supplied to mktemp().\n",
X         template);
X#endif
X
X   strcpy(&template[instr(template, "XXXXXX")],"z.@@@");
X   return (template);
X}
X
X/*****************
XFunction isadir() or isuadir() returns 1 if supplied handle or 
Xfilename is a directory or other special file that should not be 
Xarchived, else it returns 0.
X*/
X
X#ifdef CHEKDIR
Xint isadir(han)
Xint han;
X{
X   return (0); /* by default assume never a directory */
X}
X#endif
X
X#ifdef CHEKUDIR
Xint isuadir(path)
Xchar *path;
X{
X   return (0); /* by default assume never a directory */
X}
X#endif
X
X/****************
XFunction fixfname() converts the supplied filename to a syntax
Xlegal for the host system.  It is used during extraction to make sure
Xthat a file can be extracted even if a badly-implemented archiver
Xstored it with an illegal filename.
X*/
X
Xchar *fixfname(fname)
Xchar *fname;
X{
X   return (fname); /* default is no-op */
X}
X
X/*****************
XFunction nextfile() is effectively a no-op.  Any wildcard expansion 
Xmust have been done before Zoo receives the arguments.
X*/
X
X#define FMAX 1
Xchar *nextfile (what, filespec, fileset)
Xint what;                        /* whether to initialize or match      */
Xregister char *filespec;         /* filespec to match if initializing   */
Xregister int fileset;            /* which set of files                  */
X{
X   static int first_time [FMAX+1];
X   static char saved_fspec [FMAX+1][PATHSIZE];  /* our own copy of filespec */
X
X   if (what == 0) {
X      strcpy (saved_fspec[fileset], filespec);  /* save the filespec */
X      first_time[fileset] = 1;
X      return (NULL);
X   }
X
X   if (first_time[fileset]) {
X      first_time[fileset] = 0;
X      return (saved_fspec[fileset]);
X   } else {
X      return (NULL);
X   }
X}
END_OF_FILE
if test 3350 -ne `wc -c <'generic.c'`; then
    echo shar: \"'generic.c'\" unpacked with wrong size!
fi
# end of 'generic.c'
fi
if test -f 'getfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getfile.c'\"
else
echo shar: Extracting \"'getfile.c'\" \(4549 characters\)
sed "s/^X//" >'getfile.c' <<'END_OF_FILE'
X#ifndef LINT
Xstatic char sccsid[]="@(#) getfile.c 2.7 88/01/24 12:44:23";
X#endif /* LINT */
X
X/*
XCopyright (C) 1986, 1987 Rahul Dhesi -- All rights reserved
X(C) Copyright 1988 Rahul Dhesi -- All rights reserved
X*/
X
X#include "options.h"
X/*
XThis function copies n characters from the source file to the destination
X
XInput:   out_f:    		destination file
X         in_f:     		source file
X         count:         count of characters to copy
X         docrc:         0 if crc not wanted
X
XIf count is -1, copying is done until eof is encountered.
X
XThe source file is transferred to the current file pointer position in the
Xdestination file, using the handles provided.  Function return value is 0
Xif no error, 2 if write error, and 3 if read error.
X
XIf docrc is not 0, the global variable crccode is updated via addbfcrc().
XThis is done even if the output is to the null device.
X
XIf UNBUF_IO is defined, and if more than UNBUF_LIMIT bytes are 
Xbeing transferred or copying is to end of file, the data transfer 
Xis done using low-level read() and write() functions, which must 
Xbe defined elsewhere.  File descriptors are obtained for this 
Xpurpose using the fileno() macro, which must be provided elsewhere 
Xtoo.  This is meant to provide greater efficiency on some systems.
XThe files of type ZOOFILE are synchronized with their file 
Xdescriptors by doing a reasonable number of seeks and other
Xmiscellaneous operations before and after the transfer.  Such 
Xsimultaneous use of buffered and unbuffered files is not
Xportable and should not be used without extensive testing.
X*/
X
X#ifdef UNBUF_IO
Xint read PARMS ((int, VOIDPTR, unsigned));
Xint write PARMS ((int, VOIDPTR, unsigned));
Xlong lseek PARMS ((int, long, int));
Xlong tell PARMS ((int));
X#endif /* UNBUF_IO */
X
X#include "zoo.h"		/* satisfy declarations in zooio.h */
X#include "zooio.h"
X#include "various.h"
X#include "zoofns.h"
X#include "zoomem.h"
X
Xint getfile (in_f, out_f, count, docrc)
XZOOFILE in_f, out_f;
Xlong count;
Xint docrc;
X{
X   register int how_much;
X#ifdef UNBUF_IO
X	int in_d, out_d;	/* file descriptors for unbuffered I/O */
X#endif /* UNBUF_IO */
X
X#ifdef UNBUF_IO
X	if (out_f != NULLFILE && (count == -1 || count > UNBUF_LIMIT)) {
X		in_d = fileno (in_f);		/* get ..						*/
X		out_d = fileno (out_f);		/* ... file descriptors		*/
X
X		/* Synchronize buffered and unbuffered files */
X		zooseek (in_f, zootell (in_f), 0);
X		zooseek (out_f, zootell (out_f), 0);
X
X#if 0
X		lseek (in_d, zootell (in_f), 0);
X		lseek (out_d, zootell (out_f), 0);
X#endif
X
X		if (count == -1) {
X			while ((how_much = read (in_d, out_buf_adr, MEM_BLOCK_SIZE)) > 0) {
X				if (how_much == -1 ||
X						write (out_d, out_buf_adr, how_much) != how_much)
X					return (2);
X				if (docrc)
X					addbfcrc (out_buf_adr,how_much);
X			}
X			zooseek (in_f, tell (in_d), 0);		/* resynch	*/
X			zooseek (out_f, tell (out_d), 0);	/* resynch	*/
X
X#ifndef NDEBUG
X			if (ftell (in_f) != tell (in_d) || ftell (out_f) != tell (out_d)) {
X				prterror ('w', "seek mismatch in copy to EOF\n");
X				printf ("in_f =%6ld, in_d =%6ld\n", ftell (in_f),  tell (in_d));
X				printf ("out_f=%6ld, out_d=%6ld\n", ftell (out_f), tell (out_d));
X			}
X#endif /* NDEBUG */
X
X			return (0);
X		}
X
X		while (count > 0) {
X			if (count > MEM_BLOCK_SIZE)
X				how_much = MEM_BLOCK_SIZE;
X			else
X				how_much = (int) count;
X			count -= how_much;
X			if (read (in_d, out_buf_adr, how_much) != how_much)
X				return (3);
X			if (docrc)
X				addbfcrc (out_buf_adr, how_much);
X			if (write (out_d, out_buf_adr, how_much) != how_much)
X				return (2);
X		}
X		zooseek (in_f, tell (in_d), 0);		/* resynch	*/
X		zooseek (out_f, tell (out_d), 0);	/* resynch	*/
X#ifndef NDEBUG
X		if (ftell (in_f) != tell (in_d) || ftell (out_f) != tell (out_d))
X			 prterror ('w', "seek mismatch in fixed length copy\n");
X#endif /* NDEBUG */
X		return (0);
X	}
X#endif /* UNBUF_IO */
X
X   if (count == -1) {
X      while ((how_much = zooread (in_f, out_buf_adr, MEM_BLOCK_SIZE)) > 0) {
X         if (how_much == -1 ||
X               zoowrite (out_f, out_buf_adr, how_much) != how_much)
X            return (2);
X         if (docrc)
X            addbfcrc (out_buf_adr,how_much);
X      }
X      return (0);
X   }
X
X   while (count > 0) {
X      if (count > MEM_BLOCK_SIZE)
X         how_much = MEM_BLOCK_SIZE;
X      else
X         how_much = (int) count;
X      count -= how_much;
X      if (zooread (in_f, out_buf_adr, how_much) != how_much)
X         return (3);
X      if (docrc)
X         addbfcrc (out_buf_adr, how_much);
X      if (zoowrite (out_f, out_buf_adr, how_much) != how_much)
X         return (2);
X   }
X   return (0);
X}
END_OF_FILE
if test 4549 -ne `wc -c <'getfile.c'`; then
    echo shar: \"'getfile.c'\" unpacked with wrong size!
fi
# end of 'getfile.c'
fi
if test -f 'makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile'\"
else
echo shar: Extracting \"'makefile'\" \(2601 characters\)
sed "s/^X//" >'makefile' <<'END_OF_FILE'
X# @(#) makefile 2.2 88/01/27 19:37:59 
X#Make Zoo
X#
X#The contents of this makefile are hereby released to the public domain.
X#                                  -- Rahul Dhesi 1986/12/31
X#
X#This makefile should not be invoked directly, because different 
X#targets require different compilation switches.  The standard make
X#utility does not allow different switches to be specified for each target
X#(except through recursive invocation, which takes more memory than 
X#some systems have).  Invoke this makefile through one of the several
X#shell scripts supplied.  For non *NIX systems, convert the appropriate
X#shell script to one accepted by your system.
X#
X#This makefile expects two macro names, `cswitch' and `extra', to hold
X#all the switches to be supplied to the C compiler.  It also expects
X#a macro `ldswitch' to hold the switch for the loader when invoked.
X#
X#There is no target for installation.  Just copy the executables
X#(zoo and fiz) to the appropriate destination directory.
X#
X#"make lint" will probably not work.
X
XCC = cc
Xcswitch =
Xextra = -DBIG_MEM -DNDEBUG
X
X#List of all object files created for Zoo
XZOOOBJS = 	addbfcrc.o addfname.o basename.o comment.o crcdefs.o \
X		getfile.o lzc.o lzd.o machine.o makelist.o misc.o misc2.o \
X		nextfile.o needed.o options.o parse.o portable.o prterror.o \
X		version.o zoo.o zooadd.o zooadd2.o zoodel.o zooext.o zoofilt.o \
X		zoolist.o zoopack.o
X
XFIZOBJS = fiz.o addbfcrc.o portable.o crcdefs.o
X
X.c.o :
X	$(CC) $(cswitch) $(extra) $*.c
X
Xall : ERROR
X
X#doesn't work
Xlint: $(ZOOOBJS)
X	lint $(ZOOOBJS)
X
Xzoo: $(ZOOOBJS)
X	$(CC) $(ldswitch) $(ZOOOBJS)
X
Xfiz: $(FIZOBJS)
X	$(CC) $(ldswitch) $(FIZOBJS)
X
Xclean :
X	/bin/rm -f core a.out $(ZOOOBJS) $(FIZOBJS)
X
Xlzd.o : lzd.c zoomem.h
X	$(CC) $(cswitch) $(extra) $*.c
X
Xlzc.o : lzc.c zoomem.h
X	$(CC) $(cswitch) $(extra) $*.c
X
Xaddbfcrc.o : addbfcrc.c
X
Xaddfname.o : addfname.c
X
Xbasename.o : basename.c
X
Xcomment.c : zooio.h
X
Xcrcdefs.o : crcdefs.c
X
Xgetfile.o : getfile.c zoomem.h
X	$(CC) $(cswitch) $(extra) $*.c
X
Xmachine.o : machine.c nixtime.i
X	$(CC) $(cswitch) $(extra) $*.c
X
Xmakelist.o : makelist.c
X
Xmisc.c : zooio.h
X
Xmisc2.o : misc2.c zoomem.h
X	$(CC) $(cswitch) $(extra) $*.c
X
Xoptions.o : options.c
X
Xnextfile.o :  nextfile.c
X
Xneeded.o : needed.c
X
Xparse.o : parse.c
X
Xportable.o : portable.c
X
Xprterror.o : prterror.c
X
Xzoo.o :   zoo.c zoomem.h errors.i
X	$(CC) $(cswitch) $(extra) $*.c
X
Xzooadd.c : zooio.h
X
Xzooadd2.c : zooio.h
X
Xzoodel.c : zooio.h
X
Xzooext.o : zooext.c  errors.i zooio.h
X	$(CC) $(cswitch) $(extra) $*.c
X
Xzoofilt.o : zoofilt.c zooio.h
X	$(CC) $(cswitch) $(extra) $*.c
X
Xzoolist.c : zooio.h
X
Xzoopack.c : zooio.h
END_OF_FILE
if test 2601 -ne `wc -c <'makefile'`; then
    echo shar: \"'makefile'\" unpacked with wrong size!
fi
# end of 'makefile'
fi
if test -f 'mstime.i' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mstime.i'\"
else
echo shar: Extracting \"'mstime.i'\" \(2860 characters\)
sed "s/^X//" >'mstime.i' <<'END_OF_FILE'
X#ifndef LINT
Xstatic char mstimeid[]="@(#) mstime.i 2.2 88/01/24 12:47:58";
X#endif /* LINT */
X
X/*
X(C) Copyright 1987 Rahul Dhesi -- All rights reserved
X*/
X
X#define BASEYEAR 1970
X
X/****************
XFunction mstime() converts time in seconds since January 1 of BASEYEAR
Xto MS-DOS format date and time.
X*/
Xmstime(longtime, date, time)
Xlong longtime;       /* input:  seconds since Jan 1, BASEYEAR   */
Xint *date, *time;    /* output: MS-DOS format date and time */
X
X{
X   static int daysinmo[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
X#define FEBRUARY 1
X   int year, month, day, hour, min, sec;
X   long secsinhour, secsinday, secsinyear, secsinleapyear;
X
X   int leapyear;                             /* is this a leap year? */
X   int done;                                 /* control variable */
X
X   secsinhour = (long) (60 * 60);            /* seconds in an hour */
X   secsinday  = 24 * secsinhour;             /* seconds in a day */
X   secsinyear = 365 * secsinday;             /* seconds in a year */
X   secsinleapyear = secsinyear + secsinday;  /* seconds in a leap year */
X
X#ifdef DEBUG
Xprintf("mstime:  input longtime = %ld\n", longtime);
X#endif
X
X   /* We can't handle dates before 1970 so force longtime positive */
X   if (longtime < 0)
X      longtime = 0;
X
X   /* 
X   Step through years from BASEYEAR onwards, subtracting number of
X   seconds in each, stopping just before longtime would become negative.
X   */
X   year = BASEYEAR;
X   done = 0;
X   while (!done) {
X      long yearlength;
X      leapyear = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);
X      if (leapyear)
X         yearlength = secsinleapyear;
X      else
X         yearlength = secsinyear;
X
X      if (longtime >= yearlength) {
X         longtime -= yearlength;
X         year++;
X      } else
X         done++;
X   }
X
X   /* Now `year' contains year and longtime contains remaining seconds */
X   daysinmo[FEBRUARY] = leapyear ? 29 : 28;
X
X   month = 0; /* range is 0:11 */
X   while (longtime > daysinmo[month] * secsinday) {
X      longtime = longtime - daysinmo[month] * secsinday;
X      month++;
X   }
X   month++; /* range now 1:12 */
X
X   day = longtime / secsinday;     /* day of month, range 0:30 */
X   longtime = longtime % secsinday;
X   day++;                         /* day of month, range 1:31 */
X
X   hour = longtime / secsinhour;       /* hours, range 0:23 */
X   longtime = longtime % secsinhour;
X
X   min = longtime / 60L;               /* minutes, range 0:59 */
X   longtime = longtime % 60L;
X
X   sec = longtime;                     /* seconds, range 0:59 */
X
X#ifdef DEBUG
Xprintf("mstime:  date = %4d/%02d/%02d   time = %02d:%02d:%02d\n",
X      year, month, day, hour, min, sec);
Xif (leapyear)
X   printf("(leap year)\n");
X#endif
X
X   if (year < 1980)
X      year = 1980;
X   *date = day + (month << 5) + ((year - 1980) << 9);
X   *time = (sec / 2) + (min << 5) + (hour << 11);
X}
END_OF_FILE
if test 2860 -ne `wc -c <'mstime.i'`; then
    echo shar: \"'mstime.i'\" unpacked with wrong size!
fi
# end of 'mstime.i'
fi
if test -f 'nixtime.i' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nixtime.i'\"
else
echo shar: Extracting \"'nixtime.i'\" \(3434 characters\)
sed "s/^X//" >'nixtime.i' <<'END_OF_FILE'
X#ifndef LINT
Xstatic char nixtimeid[]="@(#) nixtime.i 2.3 88/01/24 12:49:28";
X#endif /* LINT */
X
X/*
XTime handling routines for UNIX systems.  These are included by the file
Xmachine.c as needed.
X
XThe contents of this file are hereby released to the public domain.
X
X                                    -- Rahul Dhesi  1986/12/31
X*/
X
Xstruct tm *localtime();
X
X/*****************
XFunction gettime() gets the date and time of the file handle supplied.
XDate and time is in MSDOS format.
X*/
Xint gettime (file, date, time)
XZOOFILE file;
Xunsigned *date, *time;
X{
X   struct stat buf;           /* buffer to hold file information */
X   struct tm *tm;             /* will hold year/month/day etc. */
X	int handle;
X	handle = fileno(file);
X   if (fstat (handle, &buf) == -1) {
X      prterror ('w', "Could not get file time\n");
X      *date = *time = 0;
X   } else {
X      tm = localtime (&buf.st_mtime); /* get info about file mod time */
X      *date = tm->tm_mday + ((tm->tm_mon + 1) << 5) +
X         ((tm->tm_year - 80) << 9);
X      *time = tm->tm_sec / 2 + (tm->tm_min << 5) +
X         (tm->tm_hour << 11);
X   }
X
X}
X
X/*****************
XFunction setutime() sets the date and time of the filename supplied.
XDate and time is in MSDOS format.  It assumes the existence of a function
Xmstonix() that accepts MSDOS format time and returns **IX format time,
Xand a function gettz() that returns the difference (localtime - gmt)
Xin seconds, taking daylight savings time into account.
X*/
Xint setutime(path,date,time)
Xchar *path;
Xunsigned int date, time;
X{
X	long mstonix();
X	long gettz();
X	long utimbuf[2];
X	utimbuf[0] = utimbuf[1] = gettz() + mstonix (date, time);
X	return (utime (path, utimbuf));
X}
X
X/****************
XFunction mstonix() accepts an MSDOS format date and time and returns
Xa **IX format time.  No adjustment is done for timezone.
X*/
X
Xlong mstonix (date, time)
Xunsigned int date, time;
X{
X   int year, month, day, hour, min, sec, daycount;
X   long longtime;
X   /* no. of days to beginning of month for each month */
X   static int dsboy[12] = { 0, 31, 59, 90, 120, 151, 181, 212,
X                              243, 273, 304, 334};
X
X   if (date == 0 && time == 0)			/* special case! */
X      return (0L);
X
X   /* part of following code is common to zoolist.c */
X   year  =  (((unsigned int) date >> 9) & 0x7f) + 1980;
X   month =  ((unsigned int) date >> 5) & 0x0f;
X   day   =  date        & 0x1f;
X
X   hour =  ((unsigned int) time >> 11)& 0x1f;
X   min   =  ((unsigned int) time >> 5) & 0x3f;
X   sec   =  ((unsigned int) time & 0x1f) * 2;
X
X/*
XDEBUG and leap year fixes thanks to Mark Alexander 
X<uunet!amdahl!drivax!alexande>
X*/
X#ifdef DEBUG
X   printf ("mstonix:  year=%d  month=%d  day=%d  hour=%d  min=%d  sec=%d\n",
X           year, month, day, hour, min, sec);
X#endif
X
X   /* Calculate days since 1970/01/01 */
X   daycount = 365 * (year - 1970) +    /* days due to whole years */
X               (year - 1969) / 4 +     /* days due to leap years */
X               dsboy[month-1] +        /* days since beginning of this year */
X               day-1;                  /* days since beginning of month */
X
X   if (year % 4 == 0 && 
X       year % 400 != 0 && month >= 3)  /* if this is a leap year and month */
X      daycount++;                      /* is March or later, add a day */
X
X   /* Knowing the days, we can find seconds */
X   longtime = daycount * 24L * 60L * 60L    +
X          hour * 60L * 60L   +   min * 60   +    sec;
X	return (longtime);
X}
END_OF_FILE
if test 3434 -ne `wc -c <'nixtime.i'`; then
    echo shar: \"'nixtime.i'\" unpacked with wrong size!
fi
# end of 'nixtime.i'
fi
if test -f 'options.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'options.h'\"
else
echo shar: Extracting \"'options.h'\" \(5008 characters\)
sed "s/^X//" >'options.h' <<'END_OF_FILE'
X/* @(#) options.h 2.22 88/08/24 15:27:36 */
X
X/*
XThe contents of this file are hereby released to the public domain.
X
X                           -- Rahul Dhesi 1986/11/14
X
XFor documentation about this file, see options.doc.
X*/
X
X
X/* ZOO is always defined currently */
X#define ZOO
X
X/* Compilation without ZOOCOMMENT has not been tested */
X#define ZOOCOMMENT
X
X#ifdef SYS_V
X#define FILTER
X#define VER_DISPLAY ";"
X#define VER_INPUT ":;"
X#define IO_MACROS
X#define EXISTS(f)		(access(f, 00) == 0)
X#define MEMSET
X#define FNLIMIT 14
X#define CHEKDIR
X#define NIXTIME
X#define NIXFNAME
X#define NEEDCTYP
X#define NOENUM
X#define PORTABLE
X#define REN_LINK
X#define SETBUF
X#define GETTZ
X#define FATTR
X#endif
X
X#ifdef TURBOC
X#define VER_DISPLAY ";"
X#define VER_INPUT ":;"
X#define USE_ASCII
X#define SPECINIT
X#define SPECEXIT
X#define PURIFY
X#define DISK_CH ':'
X#define IGNORECASE
X#define WILDCARD "*.*"
X#define FOLD
X#define FORCESLASH
X#define FNLIMIT 12
X#define CUR_DIR "."
X#define PATH_CH "/"
X#define PATH_SEP ":/\\"
X#define EXT_CH '.'
X#define EXT_SEP  ":/\\."
X#define EXT_DFLT ".zoo"
X#define SETMODE
X/* 0x8000 and 0x4000 taken from <fcntl.h> for Turbo C */
X#define MODE_BIN(f)      setmode(fileno(f), 0x8000)
X#define MODE_TEXT(f)     setmode(fileno(f), 0x4000)
X#define LINT_ARGS
X#define MORE 	...
X#define NOTHING		void
X#define VOIDPTR		void *
X#define REN_REV
X#define UNBUF_IO
X#define UNBUF_LIMIT		512
X#ifdef  PORTABLE
X#define SPECNEXT
X#define NIXTIME
X#undef  WILDCARD
X#endif
X
X#endif /* TURBOC */
X
X#ifdef MSC
X#define VER_DISPLAY ";"
X#define VER_INPUT ":;"
X#define ALWAYS_INT
X#define USE_ASCII
X#define SPECINIT
X#define SPECEXIT
X#define PURIFY
X#define DISK_CH ':'
X#define IGNORECASE
X#define WILDCARD "*.*"
X#define FOLD
X#define FORCESLASH
X#define FNLIMIT 12
X#define CUR_DIR "."
X#define PATH_CH "/"
X#define PATH_SEP ":/\\"
X#define EXT_CH '.'
X#define EXT_SEP  ":/\\."
X#define EXT_DFLT ".zoo"
X#define SETMODE
X/* 0x8000 and 0x4000 taken from <fcntl.h> for Microsoft C */
X#define MODE_BIN(f)      setmode(fileno(f), 0x8000)
X#define MODE_TEXT(f)     setmode(fileno(f), 0x4000)
X#define LINT_ARGS
X#define MORE
X#define NOTHING
X#define VOIDPTR		char *
X#define REN_NORM
X
X#define UNBUF_IO
X#define UNBUF_LIMIT		512
X
X#ifdef  PORTABLE
X#define SPECNEXT
X#define NIXTIME
X#undef  WILDCARD
X#endif
X
X#endif /* MSC */
X
X#ifdef BSD4_3
X#define NOSTRCHR /* not really needed for 4.3BSD */
X#define FILTER
X#define VER_DISPLAY ";"
X#define VER_INPUT ":;"
X#define IO_MACROS
X#define EXISTS(f)		(access(f, 00) == 0)
X#define FNLIMIT 1023
X#define CHEKDIR
X#define NIXTIME
X#define NIXFNAME
X#define NEEDCTYP
X#define PORTABLE
X#define NOENUM
X#define REN_REV
X#define SETBUF
X#define GETTZ
X#define FATTR
X#endif
X
X
X
X#ifdef VMS
X
X/*
XSelect VMS pre-4.6 or 4.6 next line.  Pre-4.6 library does not have
Xrename() and memset() so zoo defines its own;  4.6 has these, so we
Xmust use them, else VMS library functions will conflict with our
Xown.
X*/
X# if 1		/* VMS version 4.6 */
X#  define VMS_RENAME /* this symbol used only in file vms.c */
X#  define REN_REV
X#  define MEMSET
X# else		/* VMS pre-version 4.5 */
X#  define REN_NORM
X# endif
X
X#define VER_DISPLAY ";"
X#define VER_INPUT ":;"
X
X#define IO_MACROS
X#define SPEC_WILD
X#define EXT_ANYWAY
X#define VER_CH ';'
X#define SPECEXIT
X#define CHEKUDIR
X#define FNLIMIT 78
X#define DIR_SEP '.'  /* separates dir fields */
X#define DISK_CH ':'
X#define DIR_LBRACK "[" /* left bracketing symbol dir dir name */
X#define PATH_CH "]"
X#define PATH_SEP ":]"
X#define EXT_CH '.'
X#define EXT_SEP ":]."
X#define EXT_DFLT ".zoo"
X#define CUR_DIR "."
X#define NIXTIME
X#define NEEDCTYP
X#define NOENUM
X#define PORTABLE
X#define DUMB_ASS
X#define IGNORECASE
X#define SPECMOD
X#define SPECNEXT
X#define WILDCARD "*.*"
X#define FOLD
X#endif
X
X#ifdef MCH_AMIGA
X#define VER_DISPLAY ";"
X#define VER_INPUT ":;"
X#define PURIFY
X#define DISK_CH ':'
X#define SPECNEXT
X#define WILDCARD "*"
X#define IGNORECASE
X#define FNLIMIT 30
X#define NEEDCTYP
X#define CUR_DIR "."
X#define PATH_CH "/"
X#define PATH_SEP ":/"
X#define EXT_CH   '.'
X#define EXT_SEP  ":/."
X#define EXT_DFLT ".zoo"
X#define PORTABLE
X#define NOSIGNAL
X#define REN_REV
X#define NOENUM
X#define SETBUF
X#define CHEKUDIR
X#define GETUTIME
X#define NIXTIME
X#endif
X
X#ifdef NIXFNAME
X#define CUR_DIR "."
X#define PATH_CH "/"
X#define PATH_SEP "/"
X#define EXT_CH '.'
X#define EXT_SEP  "/."
X#define EXT_DFLT ".zoo"
X#endif
X
X#ifdef GENERIC
X/* #define SPECNEXT */
X#define IGNORECASE
X#define FNLIMIT 11
X#define NEEDCTYP
X#define CUR_DIR "."
X#define PATH_CH "/"
X#define PATH_SEP ":/"
X#define EXT_CH   '.'
X#define EXT_SEP  ":/."
X#define EXT_DFLT ".zoo"
X#define PORTABLE
X#define NOSIGNAL
X/* REN_LINK is UNIX-specific.  Can't find a generic rename() function */
X#define REN_LINK
X/* #define FLAT */
X#define NOENUM
X#define SETBUF
X#define CHEKUDIR
X#define GETUTIME
X#define NIXTIME
X#endif
X
X/* ANSI compatibility in declarations -- see zoofns.h for usage */
X#ifndef PARMS
X#ifdef LINT_ARGS
X#define	PARMS(x)		x
X#else
X#define	PARMS(x)		()
X#endif
X#endif
X
X/* Compensate for strchr/index differences */
X#ifdef NOSTRCHR
X#define	strchr	index
X#define	strrchr	rindex
X#endif
END_OF_FILE
if test 5008 -ne `wc -c <'options.h'`; then
    echo shar: \"'options.h'\" unpacked with wrong size!
fi
# end of 'options.h'
fi
if test -f 'zoofns.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zoofns.h'\"
else
echo shar: Extracting \"'zoofns.h'\" \(3138 characters\)
sed "s/^X//" >'zoofns.h' <<'END_OF_FILE'
X/* @(#) zoofns.h 2.5 88/01/16 19:03:13 */
X/* @(#) zoofns.h 2.7 88/01/27 19:39:18 */
X
X/*
XThe contents of this file are hereby released to the public domain.
X
X                           -- Rahul Dhesi 1986/11/14
X*/
X
X/* Defines function declarations for all Zoo functions */
X
X#ifndef PARMS
X#ifdef LINT_ARGS
X#define	PARMS(x)		x
X#else
X#define	PARMS(x)		()
X#endif
X#endif
X
X/* 
X:.,$s/(PARMS\(.*\));/PARMS\1;/
X*/
Xlong calc_ofs PARMS ((char *));
Xchar *addext PARMS ((char *, char *));
Xchar *combine PARMS ((char[], char *, char *));
Xchar *emalloc PARMS ((unsigned int));
Xchar *erealloc PARMS ((char *, unsigned int));
Xchar *findlast PARMS ((char *, char *));
Xchar *fixfname PARMS ((char *));
Xchar *getstdin PARMS ((NOTHING));
Xchar *lastptr PARMS ((char *));
Xchar *nameptr PARMS ((char *));
Xchar *newcat PARMS ((char *, char *));
Xchar *memset PARMS ((char *, int, unsigned));
Xchar *nextfile PARMS ((int, char *, int));
Xint cfactor PARMS ((long, long));
Xint chname PARMS ((char *, char *));
Xint cmpnum PARMS ((unsigned int, unsigned int, unsigned int, unsigned int));
Xint ctrl_c PARMS ((NOTHING));
Xint exists PARMS ((char *));
Xint getfile PARMS ((ZOOFILE, ZOOFILE, long, int));
Xint getutime PARMS ((char *, unsigned *, unsigned *));
Xint gettime PARMS ((ZOOFILE, unsigned *, unsigned *));
Xint handle_break PARMS ((NOTHING));
X
X#ifdef USE_ASCII
Xint isupper PARMS ((char));
Xint isdigit PARMS ((char));
X#endif /* USE_ASCII */
X
Xint kill_files PARMS ((char *[], int));
X#ifdef UNBUF_IO
Xint lzc PARMS ((int, int));
Xint lzd PARMS ((int, int));
X#else
Xint lzc PARMS ((ZOOFILE, ZOOFILE));
Xint lzd PARMS ((ZOOFILE, ZOOFILE));
X#endif
Xint match_half PARMS ((char *, char *));
Xint samefile PARMS ((char *, char *));
Xint settime PARMS ((ZOOFILE, unsigned, unsigned));
Xint setutime PARMS ((char *, unsigned, unsigned));
Xint strcmpi PARMS ((char *, char *));
X
X#ifdef USE_ASCII
Xint tolower PARMS ((char));
Xint toascii PARMS ((char));
X#endif /* USE_ASCII */
X
Xint zooexit PARMS ((int));
Xlong inlist PARMS ((char *, unsigned int *, unsigned int *, unsigned *,
X					unsigned *, unsigned *, long *, int));
Xunsigned long space PARMS ((int, int *));
Xvoid addbfcrc PARMS ((char *, int));
Xvoid addfname PARMS ((char *, long, unsigned int, unsigned int, 
X							unsigned, unsigned));
Xvoid add_version PARMS ((char *, struct direntry *));
Xvoid basename PARMS ((char *, char []));
Xvoid break_off PARMS ((NOTHING));
Xvoid close_file PARMS ((ZOOFILE));
Xvoid comment PARMS ((char *, char *));
Xvoid extension PARMS ((char *, char []));
Xvoid exit PARMS ((int));
Xvoid fixslash PARMS ((char *));
Xvoid makelist PARMS ((int, char *[], char *[], int, char *, char *, char *, int *));
Xvoid memerr PARMS ((NOTHING));
Xvoid prterror PARMS ((int, char *, MORE));
Xvoid rootname PARMS ((char *, char *));
Xvoid skip_files PARMS ((ZOOFILE, unsigned int *, unsigned int *, int *,
X                  char [], long *));
Xvoid writenull PARMS ((ZOOFILE, int));
Xvoid zooadd PARMS ((char *, int, char **, char *));
Xvoid zoodel PARMS ((char *, char *, int));
Xvoid zoofilt PARMS ((char *));
Xvoid zooext PARMS ((char *, char *));
Xvoid zoolist PARMS ((char **, char *, int));
Xvoid zoopack PARMS ((char *, char *));
END_OF_FILE
if test 3138 -ne `wc -c <'zoofns.h'`; then
    echo shar: \"'zoofns.h'\" unpacked with wrong size!
fi
# end of 'zoofns.h'
fi
echo shar: End of archive 2 \(of 10\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
