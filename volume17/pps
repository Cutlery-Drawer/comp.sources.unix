Subject:  v17i080:  PostScript pretty-printers for common languages, etc.
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET

Submitted-by: Smadi Paradise <rlgvax!smadi>
Posting-number: Volume 17, Issue 80
Archive-name: pps

Pps is a pretty printer for PostScript devices. It handles C, awk, sh,
lisp, mail, PostScript and English; adding more languages is simple.

Pps is almost as fast as plain text-to-PostScript filters, so some
people here use it daily for source-code listing.  Most of the work is
done by the printer: Unix just separates the input into tokens, using
different lex(1) programs for each language.

Slide does the same, but ``expands'' the output to fit over a full
page. This is useful for making overhead projection transparencies.

Both pps and slide run on Sun, Vax, Gould, CCI, RT and other BSD
machines; they used to cope with SVR2, but that was a long time ago.

On Paradise
(a guest of) uunet!rlgvax!smadi

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	READ_ME
#	pps.man
#	slide.man
#	Makefile
#	pps.h
#	lind.c
#	prc.c
#	text.c
#	awk.l
#	c.l
#	csh.l
#	lisp.l
#	mail.l
#	ps.l
#	sh.l
#	pps.sh
#	slide.sh
#	pps.pro
#	slide.pro
#	fonts
export PATH; PATH=/bin:/usr/bin:$PATH
echo shar: "extracting 'READ_ME'" '(887 characters)'
if test -f 'READ_ME'
then
    echo shar: "will not over-write existing file 'READ_ME'"
else
sed 's/^X//' << \SHAR_EOF > 'READ_ME'
XPps is a pretty printer for PostScript devices. It handles C, awk, sh,
Xlisp, mail, PostScript and English; adding more languages is simple.
X
XPps is almost as fast as plain text-to-PostScript filters, so some
Xpeople here use it daily for source-code listing.  Most of the work is
Xdone by the printer: Unix just separates the input into tokens, using
Xdifferent lex(1) programs for each language.
X
XSlide does the same, but ``expands'' the output to fit over a full
Xpage. This is useful for making overhead projection transparencies.
X
XBoth pps and slide run on Sun, Vax, Gould, CCI, RT and other BSD
Xmachines; they used to cope with SVR2, but that was a long time ago.
X
XEdit the three first lines in Makefile to reflect your system
Xconventions, then ``make install''.
X
XEnjoy!
X
XOn Paradise, The Hebrew University of Jerusalem, Israel.
Xon@hujics.bitnet  on@humus.huji.ac.il  ...!mcvax!huji!on
SHAR_EOF
if test 887 -ne "`wc -c < 'READ_ME'`"
then
    echo shar: "error transmitting 'READ_ME'" '(should have been 887 characters)'
fi
fi
echo shar: "extracting 'pps.man'" '(2206 characters)'
if test -f 'pps.man'
then
    echo shar: "will not over-write existing file 'pps.man'"
else
sed 's/^X//' << \SHAR_EOF > 'pps.man'
X.	\"$Header: pps.man,v 0.0 88/06/22 05:22:23 on Rel $
X.TH PPS 1 huji.ac.il
X.if '\*(lb''.ds lb Library
X.if '\*(lg''.ds lg C, awk, csh...
X.if t .ds tm \(tm
X.SH NAME
Xpps \- pretty printer for PostScript
X.SH SYNOPSIS
X.B pps 
X[-h header] [-l language] [-s style] [-t tabs] [-v pitch] files
X.SH DESCRIPTION
X.B Pps
Xtranslates its input
X.I files
Xto PostScript\*(tm
Xfor printing on the
XApple LaserWriter\*(tm and similar devices.
XWhen no input files are specified
X(or when a ``-'' is given)
Xthe standard input is read.
X.PP
X.B Pps
Xprints a header at the top of each page,
Xsimilar to the one printed by
X.BR pr(1) .
XThe
X.BI -h " text"
Xflag replaces the file name in the header with
X.IR text .
XSubtitles
Xare printed along the right edge of the page
Xwhenever a new function is declared.
X.PP
XFormatting is language-sensitive:
XThe input language is specified by the
X.BI -l " language"
Xflag
X(default is C, see ``FILES'' below).
X.PP
XSince ``pretty'' is a matter of taste,
Xthere are zillions of flags to modify the output style:
X.IP "\fB-C \fP\fIfont\fP"
XUse
X.I font
Xfor comments (default: New Century Schoolbook Roman).
X.I Font
Xshould be a PostScript name of an available font,
Xor a reasonable abbreviation.
X.IP "\fB-K \fP\fIfont\fP"
XSame, for keywords
X(default: \f(CBCourier-Bold\fP).
X.IP "\fB-S \fP\fIfont\fP"
XSame, for strings and character constant
X(default: \f(COCourier-Oblique\fP).
X.IP "\fB-I \fP\fIfont\fP"
XSame, for the rest of the text (default: \fCCourier\fP).
X.IP "\fB-n \fP\fIn\fP"
Xprints line numbers every \fIn\fPth line (default 10).
X.IP "\fB-t \fP\fIn\fP"
Xsets the tab stops to be
X.I n
Xcharacters wide.
XOn proportional spacing fonts,
Xa character width is taken to be the width of
Xthe letter ``n''
Xof the normal font.
X.IP "\fB-v \fP\fIn\fP"
XSet the vertical pitch to be
X.I n
Xlines per inch
X(default 7).
X.PP
X.IP "\fB-s \fPstyle"
XSource a PostScript program in file
X.I style
Xto override some of the
Xconstants and macros,
Xhence get a different formatting style.
X.SH FILES
X.nf
X\*(lb/{\*(lg} \-
X	language sensitive front end processors
X\*(lb/fonts \- list of font names and abbreviations
X.fi
X.SH "SEE ALSO"
Xvgrind(1), pr(1)
X.SH BUGS
X.nf
XFunction declarations are naively detected.
XThere are too many options.
X.fi
SHAR_EOF
if test 2206 -ne "`wc -c < 'pps.man'`"
then
    echo shar: "error transmitting 'pps.man'" '(should have been 2206 characters)'
fi
fi
echo shar: "extracting 'slide.man'" '(879 characters)'
if test -f 'slide.man'
then
    echo shar: "will not over-write existing file 'slide.man'"
else
sed 's/^X//' << \SHAR_EOF > 'slide.man'
X.	\"$Header: slide.man,v 0.0 88/06/22 05:22:41 on Rel $
X.TH SLIDE 1 huji.ac.il
X.if '\*(lb''.ds lb Library
X.if '\*(lg''.ds lg C, awk, csh...
X.if t .ds tm \(tm
X.SH NAME
Xslide \- produce overhead transparencies on a PostScript printer
X.SH SYNOPSIS
X.B slide
X[-l language] [-t tabs] files
X.SH DESCRIPTION
X.B Slide
Xproduces a PostScript\*(tm program that prints
X.I files
Xon the Apple LaserWriter\*(tm and similar devices.
XThe output scale is set
Xso the largest file
Xfits on a single page.
X.PP
XFormatting is language-sensitive:
XThe input language is specified by the
X.BI -l " language"
Xflag
X(default is C, see ``FILES'' below).
X.PP
XThe
X"\fB-t \fP\fIn\fP"
Xflag
Xsets the tab stops to be
X.I n
Xcharacters wide.
X.SH FILES
X.nf
X\*(lb/{\*(lg} \-
X	language sensitive front end processors
X.fi
X.SH "SEE ALSO"
Xpps(1), vgrind(1)
X.SH BUGS
X.nf
XSlides full of code may bore your audience to death.
X.fi
SHAR_EOF
if test 879 -ne "`wc -c < 'slide.man'`"
then
    echo shar: "error transmitting 'slide.man'" '(should have been 879 characters)'
fi
fi
echo shar: "extracting 'Makefile'" '(1642 characters)'
if test -f 'Makefile'
then
    echo shar: "will not over-write existing file 'Makefile'"
else
sed 's/^X//' << \SHAR_EOF > 'Makefile'
X# $Header: Makefile,v 0.0 88/06/22 05:21:37 on Rel $
X# Edit the three lines below to suit your system conventions
XBIN = .
XLIB = .
XCHAP = n
XMAN = /usr/man/man$(CHAP)
X
XLANG = awk c csh lisp mail ps text sh
XAUX = prc
XPRO = *.pro
XFRONT = pps slide
XMANS = pps.$(CHAP) slide.$(CHAP)
XSOURCES = READ_ME *.man Makefile *.h *.c *.l *.sh *.pro fonts
XAR = shar
XARFLG = -a
X
X.SUFFIXES: .$(CHAP) .man
X
X.man.$(CHAP):
X	echo .ds lb $(LIB) > $@
X	echo $(LANG) | sed 's/ /,/g;s/^/.ds lg /' >> $@ 
X	cat $*.man >> $@
X
X
Xall: $(LANG) $(AUX) $(FRONT) $(MANS)
X
X
Xawk: awk.o lind.o
X	$(CC) $(CFLAGS) -o $@ $@.o lind.o -ll
X
Xc: c.o lind.o
X	$(CC) $(CFLAGS) -o $@ $@.o lind.o -ll
X
Xcsh: csh.o lind.o
X	$(CC) $(CFLAGS) -o $@ $@.o lind.o -ll
X
Xmail: mail.o lind.o
X	$(CC) $(CFLAGS) -o $@ $@.o lind.o -ll
X
Xps: ps.o lind.o
X	$(CC) $(CFLAGS) -o $@ $@.o lind.o -ll
X
Xsh: sh.o lind.o
X	$(CC) $(CFLAGS) -o $@ $@.o lind.o -ll
X
Xtext: text.o lind.o
X	$(CC) $(CFLAGS) -o $@ $@.o lind.o -ll
X
Xlisp: lisp.o lind.o
X	@echo warning: $@ has no built-ins -- see comment.
X	$(CC) $(CFLAGS) -o $@ $@.o lind.o -ll
X
Xawk.o c.o csh.o sh.o lisp.o: pps.h
X
X
Xpps: pps.sh
X	sed 's|^lib=.*|lib=$(LIB)|' pps.sh > $@
X	chmod 755 $@
X
Xslide: slide.sh
X	sed 's|^lib=.*|lib=$(LIB)|' slide.sh > $@
X	chmod 755 $@
X
X
Xprc: prc.c
X	$(CC) $(CFLAGS) -o $@ prc.c
X
X
Xinstall: $(LIB) $(BIN) $(MAN)
X
X$(LIB): $(LANG) $(AUX) $(PRO) fonts
X	-(cd $@; rm -f $(PRO) fonts) || mkdir $@
X	cp $(LANG) $(AUX) $(PRO) fonts $@
X
X$(BIN): $(FRONT)
X	cp $(FRONT) $@
X
X$(MAN): $(MANS)
X	cp $(MANS) $@
X	man pps > /dev/null
X	man slide > /dev/null
X
X
Xpps.$(AR): $(SOURCES)
X	$(AR) $(ARFLG) $(SOURCES) > $@
X
Xclean:
X	rm -f $(FRONT) $(LANG) $(AUX) $(MANS) *.o pps.$(AR)
SHAR_EOF
if test 1642 -ne "`wc -c < 'Makefile'`"
then
    echo shar: "error transmitting 'Makefile'" '(should have been 1642 characters)'
fi
fi
echo shar: "extracting 'pps.h'" '(400 characters)'
if test -f 'pps.h'
then
    echo shar: "will not over-write existing file 'pps.h'"
else
sed 's/^X//' << \SHAR_EOF > 'pps.h'
X/* $Header: pps.h,v 0.0 88/06/22 05:22:20 on Rel $ */
X/*
X * Interface from lex front-end to pps.c
X */
X/*
X * The postscript routines assume that *font is one of the following: 
X *	I - variables and operators.
X *	C - comments
X *	S - strings
X *	K - keywords
X */
Xextern char *font;
X#define begin(S)	(sput(), (BEGIN (S)), font = "S") /* Yech! */
X
X#ifdef ECHO
X#undef ECHO
X#endif
X#define ECHO		echo(yytext)
SHAR_EOF
if test 400 -ne "`wc -c < 'pps.h'`"
then
    echo shar: "error transmitting 'pps.h'" '(should have been 400 characters)'
fi
fi
echo shar: "extracting 'lind.c'" '(2824 characters)'
if test -f 'lind.c'
then
    echo shar: "will not over-write existing file 'lind.c'"
else
sed 's/^X//' << \SHAR_EOF > 'lind.c'
X#ifndef lint
Xstatic char rcsid[] = "$Header: lind.c,v 0.0 88/06/22 05:22:17 on Rel $";
X#endif
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
X/*
X * Language-independent PostScript Interface.
X *
X * Use language dependent yylex() to output Postscript Macros:
X * (string) fname - take string to be the current filename.
X * (string) funct - take string to be the current function name.
X * (string) Font s - put string at current location, using Font.
X * n t - put n tabs
X * n n - put n newlines
X * n f - put n newpages
X */
Xextern char *keywords[];	/* must be defined in lexer */
XFILE *yyin;
XFILE *yyout;
X#define yyoutput(C)	putc((C), yyout)
X
Xchar *font = "INITIAL";
Xint bdone;	/* a string is being output */
X
X/*
X * Print yytext[], escaping postscript 'dirty' characters.
X * Start a postscript string output sequence, if necessary.
X */
Xecho(cp)
Xregister char *cp;
X{
X	if (!*cp)
X		return;
X
X	if (bdone++ == 0)
X		yyoutput('(');
X	for (; *cp; cp++)
X		switch (*cp) {
X			case '(':
X			case ')':
X			case '\\':
X				yyoutput('\\');
X			default:
X				yyoutput(*cp);
X		}
X}
X
X/*
X * Terminate a string output sequence.
X */
Xsput()
X{
X	if (bdone == 0)
X		return;
X	fprintf(yyout, ") %c s ", *font);
X	bdone = 0;
X}
X
X/*
X * Output a string of tabs, newlines or formfeeds.
X */
Xspace(s)
Xregister char *s;
X{
X	register n, prev;
X	char *fmt;
X
X	while (*s) {
X		for (prev = *s, n = 0; prev == *s; s++, n++)
X			;
X		switch (prev) {
X			case '\t':
X				fmt = "%d t\t";
X				break;
X			case '\n':
X				fmt = "%d n\n";
X				break;
X			case '\f':
X				fmt = "%d f\n";
X				break;
X		}
X		sput();
X		fprintf(yyout, fmt, n);
X	}
X}
X
X/*
X * Print a subtitle.
X */
Xfunct(s)
Xregister char *s;
X{
X	if (!*s)
X		return;
X	sput();
X	echo(s);
X	fprintf(yyout, ") funct\n", s);
X	bdone = 0;
X}
X/*
X * Is s a keyword?
X */
Xiskw(s)
Xregister char *s;
X{
X	register char **kw;
X
X	for (kw = &keywords[1]; *kw; kw++) {
X		register char *kp = *kw;
X		register char *sp = s;
X
X		while (*kp == *sp++)
X			if (*kp++ == '\0')
X				return(kw - keywords);
X	}
X	return(0);
X}
X
X/*
X * Given a file descriptor, print its modification date.
X */
Xvoid
Xfdate(fd)
Xint fd;
X{
X	struct stat st;
X	register char *cp;
X	extern char *ctime();
X
X	if (fstat(fd, &st) < 0 || (st.st_mode & S_IFMT) != S_IFREG)
X		time(&st.st_mtime);
X	cp = ctime(&st.st_mtime);
X	strcpy(&cp[16], &cp[19]);
X	fprintf(yyout, "(%.17s) fdate\n", &cp[4]);
X}
X
X/*
X * yyelx() each input file.
X */
Xmain(argc, argv)
Xchar **argv;
X{
X	int i;
X
X	if (argc == 1) {
X		fdate(fileno(yyin = stdin));
X		fprintf(yyout, "() fname\n");
X		yylex();
X		sput();
X	}
X	for (i = 1; i < argc; i++) {
X		if (*argv[i] == '-') {
X			yyin = stdin;
X			*argv[i] = '\0';
X		} else if ((yyin = fopen(argv[i], "r")) == NULL) {
X			perror(argv[i]);
X			continue;
X		}
X
X		fdate(fileno(yyin));
X		fprintf(yyout, "(%s) fname\n", argv[i]);
X		yylex();
X		sput();
X		if (yyin != stdin)
X			fclose(yyin);
X	}
X	exit(0);
X}
SHAR_EOF
if test 2824 -ne "`wc -c < 'lind.c'`"
then
    echo shar: "error transmitting 'lind.c'" '(should have been 2824 characters)'
fi
fi
echo shar: "extracting 'prc.c'" '(1972 characters)'
if test -f 'prc.c'
then
    echo shar: "will not over-write existing file 'prc.c'"
else
sed 's/^X//' << \SHAR_EOF > 'prc.c'
X#include <stdio.h>
X
Xchar	*wd = "prc";
Xstruct prc {
X	int page;
X	int row;
X	int col;
X};
X
Xstruct prc zero, max;
Xint tab = 8;
X
Xmain(argc, argv)
Xchar **argv;
X{
X	int i;
X	register FILE *fp;
X
X	while (argc > 1 && *argv[1] == '-') {
X		switch (argv[1][1]) {
X		case 'p':
X		case 'r':
X		case 'c': 
X			wd = argv[1]+1;
X			break;
X		case 't':
X			if (tab = atoi(&argv[1][2]))
X				break;
X			argc--;
X			argv++;
X			tab = atoi(argv[1]);
X			break;
X		default:
X			fprintf(stderr,
X				"Usage: prc [-prc] [-t tab] [files]\n");
X			exit(1);
X		}
X		argc--;
X		argv++;
X	}
X
X	i = 1;
X	fp = stdin;
X
X	do {
X		if (argc > 1 && (fp = fopen(argv[i], "r")) == NULL) {
X			perror(argv[i]);
X			continue;
X		}
X		prc1(fp);
X		if (argc > 2)
X			printf(" %s", argv[i]);
X		putchar('\n');
X		fclose(fp);
X	} while(++i < argc);
X
X	if (argc > 2) {
X		prprc(&max);
X		printf(" maximum\n");
X	}
X	exit(0);
X}
X
X#define MAX(A, B)	((A) > (B) ? (A) : (B))
X#define ROUND(A, B)	((A + B) / (B) * (B))
X
Xprprc(prcp)
Xstruct prc *prcp;
X{
X	register char *wdp = wd;
X
X	while (*wdp) switch (*wdp++) {
X	case 'p':
X		ipr(prcp->page);
X		break;
X
X	case 'r':
X		ipr(prcp->row);
X		break;
X
X	case 'c':
X		ipr(prcp->col);
X		break;
X
X	}
X}
X
Xipr(num)
Xint num;
X{
X	printf(" %7d", num);
X}
X
Xprc1(fp)
XFILE *fp;
X{
X	register int c;
X	struct prc cur;
X	struct prc fil;
X
X	cur = zero;
X	fil = zero;
X	if ((c = getc(fp)) == EOF) {
X		prprc(&fil);
X		return;
X	}
X	ungetc(c, fp);
X
X	while ((c = getc(fp)) != EOF) {
X		switch (c) {
X			case '\b':
X				if (cur.col > 0)
X					cur.col--;
X				break;
X			case '\f':
X				cur.page++;
X				fil.row = MAX(cur.row, fil.row);
X				cur.row = -1;
X			case '\n':
X				cur.row++;
X				fil.col = MAX(cur.col, fil.col);
X				cur.col = 0;
X				break;
X			case '\t':
X				cur.col = ROUND(cur.col, tab);
X				break;
X			default:
X				cur.col++;
X				break;
X		};
X	}
X
X	fil.col = MAX(cur.col, fil.col);
X	fil.row = MAX(cur.row, fil.row);
X	fil.page = cur.page + 1;
X
X	prprc(&fil);
X
X	max.page = MAX(fil.page, max.page);
X	max.row = MAX(fil.row, max.row);
X	max.col = MAX(fil.col, max.col);
X}
SHAR_EOF
if test 1972 -ne "`wc -c < 'prc.c'`"
then
    echo shar: "error transmitting 'prc.c'" '(should have been 1972 characters)'
fi
fi
echo shar: "extracting 'text.c'" '(1829 characters)'
if test -f 'text.c'
then
    echo shar: "will not over-write existing file 'text.c'"
else
sed 's/^X//' << \SHAR_EOF > 'text.c'
X#ifndef lint
Xstatic char rcsid[] = "$Header: text.c,v 0.0 88/06/22 05:22:51 on Rel $";
X#endif
X#include <stdio.h>
X#include <ctype.h>
X#include "pps.h"
X/*
X * "Lexical analizer" for plain text (e.g. the output of nroff(1)):
X * Prints _\b. and .\b_ in italics; c\bc in bold.
X */
XFILE *yyin = stdin;
XFILE *yyout = stdout;
Xchar *keywords[1];
X
Xstatic
Xstruct ca {
X	char c;		/* character to print */
X	char a;		/* font to use */
X} ca[BUFSIZ];
X
X#define ITALIC	'S'
X#define NORM	'I'
X#define BOLD	'K'
X
X/*
X * Add character c at position cap.
X */
Xstatic
Xcaput(c, cap)
Xregister c;
Xregister struct ca *cap;
X{
X	switch (cap->c) {
X		case '_':
X			cap->a = ITALIC;
X			break;
X		case '\0':
X		case ' ':
X			cap->a = NORM;
X			break;
X		default:
X			switch (c) {
X				case '_':
X					cap->a = ITALIC;
X					return;
X				default:
X					if (cap->c == c)
X						cap->a = BOLD;
X				case ' ':
X					break;
X			}
X	}
X	cap->c = c;
X}
X
X/*
X * Print text collected so far.
X */
Xstatic
Xcaflush(caend)
Xstruct ca *caend;
X{
X	char buf[BUFSIZ];
X	register struct ca *cap;
X	static struct ca zeroca;
X
X	for (cap = ca; cap < caend;) {
X		register char *cp = buf;
X
X		while (cap < caend && cap->a == *font) {
X			*cp++ = cap->c;
X			*cap++ = zeroca;
X		}
X		*cp = '\0';
X		echo(buf);
X		sput();
X		if (cap->a)
X			*font = cap->a;
X	}
X}
X
X/*
X * Process input text:
X *	Call space() for [\t\n\f],
X *	Save others in ca.
X */
Xyylex()
X{
X	register struct ca *cap = ca;
X	static char sp[2];
X
X	for (;;) {
X		register c;
X
X		while (isprint(c = getc(yyin)) || c == ' ')
X			caput(c, cap++);
X		
X		switch (c) {
X			default:
X				continue;
X			case '\b':
X				if (cap > ca)
X					cap--;
X				continue;
X			case '\r':	/* BUG -- won't work after \t */
X				cap = ca;
X				continue;
X			case '\t':
X			case '\n':
X			case '\f':
X			case EOF:
X				break;
X		}
X		caflush(cap);
X		cap = ca;
X		if (c == EOF)
X			return;
X		*sp = c;
X		space(sp);
X	}
X}
SHAR_EOF
if test 1829 -ne "`wc -c < 'text.c'`"
then
    echo shar: "error transmitting 'text.c'" '(should have been 1829 characters)'
fi
fi
echo shar: "extracting 'awk.l'" '(1238 characters)'
if test -f 'awk.l'
then
    echo shar: "will not over-write existing file 'awk.l'"
else
sed 's/^X//' << \SHAR_EOF > 'awk.l'
X%{
X#ifndef lint
Xstatic char rcsid[] = "$Header: awk.l,v 0.0 88/06/22 05:21:58 on Rel $";
X#endif
X#include "pps.h"
X#include <ctype.h>
X
Xint nbrace;
X%}
Xletter	[A-Za-z_]
Xdigit	[0-9]
Xwhite	[ \t]
X%Start COMMENT STRING1 STRING2 KEYWORD
X%%
X<INITIAL>{letter}({letter}|{digit})*/{white}*:	{
X			funct(yytext);
X			REJECT;
X		}
X<INITIAL>{letter}({letter}|{digit})*	{
X			int kw = iskw(yytext);
X			if (kw)
X				begin(KEYWORD);
X			ECHO;
X			if (kw)
X				begin(INITIAL);
X		}
X<INITIAL>\"	{ ECHO; begin(STRING1); }
X<STRING1>\\.	{ ECHO; }
X<STRING1>\"	{ begin(INITIAL); ECHO; }
X<INITIAL>~[ \t]*\/	{ ECHO; begin(STRING2); }
X<INITIAL>^[ \t]*\/	{
X			if (!nbrace) {
X				ECHO;
X				begin(STRING2);
X			} else
X				REJECT;
X		}
X<STRING2>\\.	{ ECHO; }
X<STRING2>\/	{ begin(INITIAL); ECHO; }
X<INITIAL>\{	{ ECHO; nbrace++; }
X<INITIAL>\}	{ ECHO; nbrace--; }
X<INITIAL>#.*	{ begin(COMMENT); ECHO; begin(INITIAL); }
X[\t\n\f]+	{ space(yytext); }
X.		{ ECHO; }
X%%
Xchar *keywords[] = {
X	"",
X	"BEGIN",
X	"END",
X	"FILENAME",
X	"FS",
X	"NF",
X	"NR",
X	"OFMT",
X	"OFS",
X	"ORS",
X	"RS",
X	"break",
X	"continue",
X	"else",
X	"exit",
X	"exp",
X	"for",
X	"getline",
X	"if",
X	"in",
X	"int",
X	"index",
X	"length",
X	"log",
X	"next",
X	"print",
X	"printf",
X	"split",
X	"sprintf",
X	"sqrt",
X	"substr",
X	"while",
X	NULL
X};
SHAR_EOF
if test 1238 -ne "`wc -c < 'awk.l'`"
then
    echo shar: "error transmitting 'awk.l'" '(should have been 1238 characters)'
fi
fi
echo shar: "extracting 'c.l'" '(1411 characters)'
if test -f 'c.l'
then
    echo shar: "will not over-write existing file 'c.l'"
else
sed 's/^X//' << \SHAR_EOF > 'c.l'
X%{
X#ifndef lint
Xstatic char rcsid[] = "$Header: c.l,v 0.0 88/06/22 05:22:01 on Rel $";
X#endif
X#include "pps.h"
X#include <ctype.h>
X
Xint nbrace;
X%}
Xletter	[A-Za-z_]
Xdigit	[0-9]
Xwhite	[ \t]
X%Start COMMENT STRING1 STRING2 KEYWORD
X%%
X<INITIAL>^{white}*{letter}({letter}|{digit})*/{white}*\(	{
X			register char *cp = yytext;
X			if (nbrace == 0) {
X				while (isspace(*cp++))
X					;
X				funct(--cp);
X			}
X			REJECT;
X		}
X<INITIAL>{letter}({letter}|{digit})*	{
X			int kw = iskw(yytext);
X			if (kw)
X				begin(KEYWORD);
X			ECHO;
X			if (kw)
X				begin(INITIAL);
X		}
X<INITIAL>\"	{ begin(STRING1); ECHO; }
X<INITIAL>\'	{ begin(STRING2); ECHO; }
X<INITIAL>\/\*	{ begin(COMMENT); ECHO; }
X<STRING1>\\.	{ ECHO; }
X<STRING2>\\.	{ ECHO; }
X<STRING1>\"	{ ECHO; begin(INITIAL); }
X<STRING2>\'	{ ECHO; begin(INITIAL); }
X<COMMENT>\*\/	{ ECHO; begin(INITIAL); }
X[\t\n\f]+	{ space(yytext); }
X<INITIAL>\{	{ nbrace++; REJECT; }
X<INITIAL>\}	{ nbrace--; REJECT; }
X.		{ ECHO; }
X%%
X/*
X * This should better be sorted by frequency.
X */
Xchar *keywords[] = {
X	"   ",
X	"asm",
X	"auto",
X	"break",
X	"case",
X	"char",
X	"continue",
X	"default",
X	"define",
X	"do",
X	"double",
X	"else",
X	"endif",
X	"enum",
X	"extern",
X	"float",
X	"for",
X	"fortran",
X	"goto",
X	"if",
X	"ifdef",
X	"ifndef",
X	"include",
X	"int",
X	"long",
X	"register",
X	"return",
X	"short",
X	"sizeof",
X	"static",
X	"struct",
X	"switch",
X	"typedef",
X	"undef",
X	"union",
X	"unsigned",
X	"void", 
X	"while",
X	NULL
X};
SHAR_EOF
if test 1411 -ne "`wc -c < 'c.l'`"
then
    echo shar: "error transmitting 'c.l'" '(should have been 1411 characters)'
fi
fi
echo shar: "extracting 'csh.l'" '(1574 characters)'
if test -f 'csh.l'
then
    echo shar: "will not over-write existing file 'csh.l'"
else
sed 's/^X//' << \SHAR_EOF > 'csh.l'
X%{
X#ifndef lint
Xstatic char rcsid[] = "$Header: csh.l,v 0.0 88/06/22 05:22:04 on Rel $";
X#endif
X#include "pps.h"
X#include <ctype.h>
X
Xint nbrace;
X%}
Xletter	[A-Za-z_]
Xdigit	[0-9]
Xwhite	[ \t]
Xbuiltin	[\$\<\*0-9]
X%Start COMMENT STRING1 STRING2 KEYWORD
X%%
X<INITIAL>{letter}({letter}|{digit})*/{white}*:	{
X			funct(yytext);
X			REJECT;
X		}
X<INITIAL>{letter}({letter}|{digit})*	{
X			int kw = iskw(yytext);
X			if (kw)
X				begin(KEYWORD);
X			ECHO;
X			if (kw)
X				begin(INITIAL);
X		}
X<INITIAL>\"	{ begin(STRING1); ECHO; }
X<INITIAL>\'	{ begin(STRING2); ECHO; }
X<INITIAL>#.*	{ begin(COMMENT); ECHO; begin(INITIAL); }
X<STRING1>\\.	{ ECHO; }
X<STRING2>\\.	{ ECHO; }
X<STRING1>\"	{ ECHO; begin(INITIAL); }
X<STRING2>\'	{ ECHO; begin(INITIAL); }
X<INITIAL>\${builtin}	{ begin(KEYWORD); ECHO; begin(INITIAL); }
X<STRING1>\${builtin}	{ begin(KEYWORD); ECHO; begin(STRING1); }
X<INITIAL>\$	{ begin(KEYWORD); ECHO; begin(INITIAL); }
X<STRING1>\$	{ begin(KEYWORD); ECHO; begin(STRING1); }
X[\t\n\f]+	{ space(yytext); }
X.		{ ECHO; }
X%%
Xchar *keywords[] = {
X	"",
X	"alias",
X	"alloc",
X	"break",
X	"breaksw",
X	"case",
X	"cd",
X	"chdir",
X	"continue",
X	"default",
X	"echo",
X	"else",
X	"end",
X	"endif",
X	"endsw",
X	"exec",
X	"exit",
X	"foreach",
X	"glob",
X	"goto",
X	"history",
X	"if",
X	"logout",
X	"nice",
X	"nohup",
X	"onintr",
X	"repeat",
X	"set",
X	"setenv",
X	"shift",
X	"source",
X	"switch",
X	"then",
X	"time",
X	"while",
X	"umask",
X	"unalias",
X	"unset",
X	"wait",
X	"while",
X	"@",
X	"env",
X	"argv",
X	"child",
X	"home",
X	"ignoreeof",
X	"noclobber",
X	"noglob",
X	"nomatch",
X	"path",
X	"prompt",
X	"shell",
X	"status",
X	"verbose",
X	NULL
X};
SHAR_EOF
if test 1574 -ne "`wc -c < 'csh.l'`"
then
    echo shar: "error transmitting 'csh.l'" '(should have been 1574 characters)'
fi
fi
echo shar: "extracting 'lisp.l'" '(938 characters)'
if test -f 'lisp.l'
then
    echo shar: "will not over-write existing file 'lisp.l'"
else
sed 's/^X//' << \SHAR_EOF > 'lisp.l'
X%{
X#ifndef lint
Xstatic char rcsid[] = "$Header: lisp.l,v 0.0 88/06/22 05:22:11 on Rel $";
X#endif
X#include <ctype.h>
X#include "pps.h"
X
Xint def;
X%}
Xletter	[@A-Za-z_\-:\$]
Xdigit	[0-9]
Xwhite	[ \t]
X%Start COMMENT STRING1 STRING2 KEYWORD
X%%
X<INITIAL>c[ad]+r	{ begin(KEYWORD); ECHO; begin(INITIAL); }
X<INITIAL>def	{ def++; REJECT; }
X<INITIAL>{letter}({letter}|{digit})*	{	/* BUG */
X			int kw = iskw(yytext);
X
X			if (kw)
X				begin(KEYWORD);
X			else if (def) {
X				funct(yytext);
X				def = 0;
X			}
X			ECHO;
X			if (kw)
X				begin(INITIAL);
X		}
X<INITIAL>\"	{ begin(STRING1); ECHO; }
X<INITIAL>\#	{ begin(COMMENT); ECHO; begin(INITIAL); }
X<INITIAL>;	{ begin(COMMENT); ECHO; begin(INITIAL); }
X<STRING1>\\.	{ ECHO; }
X<STRING1>\"	{ ECHO; begin(INITIAL); }
X[\t\n\f]+	{ space(yytext); }
X.		{ ECHO; }
X%%
X/*
X * Your pet lisp dialect has other built-ins than ours;
X * anyway, the list is too long to ship over the net...
X */
Xchar *keywords[] = {
X	"",
X	NULL
X};
SHAR_EOF
if test 938 -ne "`wc -c < 'lisp.l'`"
then
    echo shar: "error transmitting 'lisp.l'" '(should have been 938 characters)'
fi
fi
echo shar: "extracting 'mail.l'" '(476 characters)'
if test -f 'mail.l'
then
    echo shar: "will not over-write existing file 'mail.l'"
else
sed 's/^X//' << \SHAR_EOF > 'mail.l'
X%{
X#ifndef lint
Xstatic char rcsid[] = "$Header: mail.l,v 0.0 88/06/22 05:22:14 on Rel $";
X#endif
X#include "pps.h"
X#define KEYWORD INITIAL
X%}
Xfield	^[^ \t:]+:
X%Start COMMENT
X%%
X<INITIAL>{field}	{
X			begin(KEYWORD);
X			ECHO;
X			if (!iskw(yytext))
X				begin(INITIAL);
X		}
X<INITIAL>\n\n+	{ begin(COMMENT); REJECT; }
X<COMMENT>^From	{ begin(INITIAL); REJECT; }
X[\t\n\f]+	{ space(yytext); }
X.		{ ECHO; }
X%%
Xchar *keywords[] = {
X	"",
X	"Date:",
X	"From:",
X	"Subject:",
X	"To:",
X	NULL
X};
SHAR_EOF
if test 476 -ne "`wc -c < 'mail.l'`"
then
    echo shar: "error transmitting 'mail.l'" '(should have been 476 characters)'
fi
fi
echo shar: "extracting 'ps.l'" '(3710 characters)'
if test -f 'ps.l'
then
    echo shar: "will not over-write existing file 'ps.l'"
else
sed 's/^X//' << \SHAR_EOF > 'ps.l'
X%{
X#ifndef lint
Xstatic char rcsid[] = "$Header: ps.l,v 0.0 88/06/22 05:22:35 on Rel $";
X#endif
X#include "pps.h"
X
Xint nbrace;
X%}
Xnonspecial	[^ \t\n\f()<>[\]/]
X%S STRING KEYWORD COMMENT
X%%
X<INITIAL>^\/{nonspecial}+/[ \t]*\{	{
X			funct(yytext + 1);
X			REJECT;
X		}
X<INITIAL>{nonspecial}+	{
X			int kw = iskw(yytext);
X			if (kw)
X				begin(KEYWORD);
X			ECHO;
X			if (kw)
X				begin(INITIAL);
X		}
X<INITIAL>\(	{ begin(STRING); ECHO; }
X<STRING>\\.	{ ECHO; }
X<STRING>\)	{ ECHO; begin(INITIAL); }
X<INITIAL>%.*	{ begin(COMMENT); ECHO; begin(INITIAL); }
X[\t\n\f]+	{ space(yytext); }
X.		{ ECHO; }
X%%
Xchar *keywords[] = {
X	"",
X	"=",
X	"==",
X	"VMerror",
X	"[",
X	"]",
X	"abs",
X	"add",
X	"aload",
X	"anchorsearch",
X	"and",
X	"arc",
X	"arcn",
X	"arcto",
X	"array",
X	"ashow",
X	"astore",
X	"atan",
X	"awidthshow",
X	"bitshift",
X	"bytesavailable",
X	"cachestatus",
X	"ceiling",
X	"charpath",
X	"clear",
X	"cleartomark",
X	"clip",
X	"clippath",
X	"closefile",
X	"closepath",
X	"concat",
X	"concatmatrix",
X	"copy",
X	"copypage",
X	"cos",
X	"count",
X	"countdictstack",
X	"countexecstack",
X	"counttomark",
X	"currentcacheparams",
X	"currentdash",
X	"currentfile",
X	"currentflat",
X	"currentfont",
X	"currentgray",
X	"currenthsbcolor",
X	"currentlinecap",
X	"currentlinejoin",
X	"currentlinewidth",
X	"currentmatrix",
X	"currentmiterlimit",
X	"currentpacking",
X	"currentpoint",
X	"currentrgbcolor",
X	"currentscreen",
X	"currenttransfer",
X	"curveto",
X	"cvi",
X	"cvlit",
X	"cvn",
X	"cvr",
X	"cvrs",
X	"cvs",
X	"cvx",
X	"def",
X	"defaultmatrix",
X	"definefont",
X	"dict",
X	"dictfull",
X	"dictstack",
X	"dictstackoverflow",
X	"dictstackunderflow",
X	"div",
X	"dtransform",
X	"dup",
X	"echo",
X	"eoclip",
X	"eofill",
X	"eq",
X	"erasepage",
X	"exch",
X	"exec",
X	"execstack",
X	"execstackoverflow",
X	"executeonly",
X	"exit",
X	"exp",
X	"false",
X	"file",
X	"fill",
X	"findfont",
X	"flattenpath",
X	"floor",
X	"flush",
X	"flushfile",
X	"for",
X	"forall",
X	"framedevice",
X	"ge",
X	"get",
X	"getinterval",
X	"grestore",
X	"grestoreall",
X	"gsave",
X	"gt",
X	"identmatrix",
X	"idiv",
X	"idtransform",
X	"if",
X	"ifelse",
X	"image",
X	"imagemask",
X	"index",
X	"initclip",
X	"initgraphics",
X	"initmatrix",
X	"interrupt",
X	"invalidaccess",
X	"invalidexit",
X	"invalidfileaccess",
X	"invalidfont",
X	"invalidrestore",
X	"invertmatrix",
X	"ioerror",
X	"itransform",
X	"known",
X	"kshow",
X	"le",
X	"limitcheck",
X	"lineto",
X	"ln",
X	"load",
X	"log",
X	"loop",
X	"lt",
X	"makefont",
X	"mark",
X	"matrix",
X	"maxlength",
X	"mod",
X	"moveto",
X	"mul",
X	"ne",
X	"neg",
X	"newpath",
X	"nocurrentpoint",
X	"not",
X	"null",
X	"nulldevice",
X	"or",
X	"packedarray",
X	"pathbbox",
X	"pathforall",
X	"pop",
X	"print",
X	"prompt",
X	"pstack",
X	"put",
X	"putinterval",
X	"quit",
X	"rand",
X	"rangecheck",
X	"rcheck",
X	"rcurveto",
X	"read",
X	"readhexstring",
X	"readline",
X	"readonly",
X	"readstring",
X	"repeat",
X	"restore",
X	"reversepath",
X	"rlineto",
X	"rmoveto",
X	"roll",
X	"rotate",
X	"round",
X	"rrand",
X	"run",
X	"save",
X	"scale",
X	"scalefont",
X	"search",
X	"setcachedevice",
X	"setcachelimit",
X	"setcacheparams",
X	"setcharwidth",
X	"setdash",
X	"setflat",
X	"setfont",
X	"setgray",
X	"sethsbcolor",
X	"setlinecap",
X	"setlinejoin",
X	"setlinewidth",
X	"setmatrix",
X	"setmitrlimit",
X	"setpacking",
X	"setrgbcolor",
X	"setscreen",
X	"settransfer",
X	"show",
X	"showpage",
X	"sin",
X	"sqrt",
X	"srand",
X	"stack",
X	"stackoverflow",
X	"stackunderflow",
X	"start",
X	"status",
X	"stop",
X	"stopped",
X	"store",
X	"string",
X	"stringwidth",
X	"stroke",
X	"strokepath",
X	"sub",
X	"syntaxerror",
X	"systemdict",
X	"token",
X	"transform",
X	"translate",
X	"true",
X	"truncate",
X	"type",
X	"typecheck",
X	"undefined",
X	"undefinedfilename",
X	"undefinedresult",
X	"unmatchedmark",
X	"unregistered",
X	"userdict",
X	"usertime",
X	"version",
X	"vmstatus",
X	"wcheck",
X	"where",
X	"widthshow",
X	"write",
X	"writehexstring",
X	"writestring",
X	"xcheck",
X	"xor",
X	NULL
X};
SHAR_EOF
if test 3710 -ne "`wc -c < 'ps.l'`"
then
    echo shar: "error transmitting 'ps.l'" '(should have been 3710 characters)'
fi
fi
echo shar: "extracting 'sh.l'" '(1261 characters)'
if test -f 'sh.l'
then
    echo shar: "will not over-write existing file 'sh.l'"
else
sed 's/^X//' << \SHAR_EOF > 'sh.l'
X%{
X#ifndef lint
Xstatic char rcsid[] = "$Header: sh.l,v 0.0 88/06/22 05:22:38 on Rel $";
X#endif
X#include <ctype.h>
X#include "pps.h"
X
Xint nbrace;
X%}
Xletter	[A-Za-z_]
Xdigit	[0-9]
Xwhite	[ \t]
Xbuiltin	[#\*@\-\?\$\!0-9]
X%Start COMMENT STRING1 STRING2 KEYWORD
X%%
X<INITIAL>{letter}({letter}|{digit})*	{
X			int kw = iskw(yytext);
X			if (kw)
X				begin(KEYWORD);
X			ECHO;
X			if (kw)
X				begin(INITIAL);
X		}
X<INITIAL>\"	{ begin(STRING1); ECHO; }
X<INITIAL>\'	{ begin(STRING2); ECHO; }
X<INITIAL>#.*	{ begin(COMMENT); ECHO; begin(INITIAL); }
X<STRING1>\\.	{ ECHO; }
X<STRING2>\\.	{ ECHO; }
X<STRING1>\"	{ ECHO; begin(INITIAL); }
X<STRING2>\'	{ ECHO; begin(INITIAL); }
X<INITIAL>\${builtin}	{ begin(KEYWORD); ECHO; begin(INITIAL); }
X<STRING1>\${builtin}	{ begin(KEYWORD); ECHO; begin(STRING1); }
X<INITIAL>\$	{ begin(KEYWORD); ECHO; begin(INITIAL); }
X<STRING1>\$	{ begin(KEYWORD); ECHO; begin(STRING1); }
X[\t\n\f]+	{ space(yytext); }
X.		{ ECHO; }
X%%
Xchar *keywords[] = {
X	"",
X	"for",
X	"in",
X	"do",
X	"done",
X	"case",
X	"if",
X	"then",
X	"else",
X	"elif",
X	"fi",
X	"while",
X	"break",
X	"cd",
X	"chdir",
X	"continue",
X	"eval",
X	"exec",
X	"exit",
X	"export",
X	"read",
X	"readonly",
X	"set",
X	"shift",
X	"times",
X	"trap",
X	"umsak",
X	"wait",
X	"HOME",
X	"IFS",
X	"MAIL",
X	"PATH",
X	"PS1",
X	"PS2",
X	NULL
X};
SHAR_EOF
if test 1261 -ne "`wc -c < 'sh.l'`"
then
    echo shar: "error transmitting 'sh.l'" '(should have been 1261 characters)'
fi
fi
echo shar: "extracting 'pps.sh'" '(1515 characters)'
if test -f 'pps.sh'
then
    echo shar: "will not over-write existing file 'pps.sh'"
else
sed 's/^X//' << \SHAR_EOF > 'pps.sh'
Xrcsid='$Header: pps.sh,v 0.0 88/06/22 05:22:29 on Rel $'
X#
X# Argument processor and handshaker for C to postscript pretty printer
X#
Xlib=.
Xusage="Usage: $0 [-C font] [-h heder] [-l lang] [-t tabs] [-v pitch] [files]"
Xinit=ppsinit
Xwhile [ x"$*" != x ]
Xdo
X	case $1 in
X		-[ICSK])
X:			${2?$usage}
X			if font=`grep -w -i $2 $lib/fonts`
X			then
X				font=`echo $font | sed 's/ .*//'`
X			else
X				echo ${0}: ${2}: Unknown font 1>&2
X				exit 17
X			fi
X			pos=`echo $1 | sed 's/-//'`
X			init="fonts /$pos /$font put $init"
X			shift
X			;;
X		-h)
X:			${2?$usage}
X			header=`echo "$2" | sed 's/[\\()]/\\\&/g'`
X			init="/header ($header) def $init"
X			shift
X			;;
X		-l)
X:			${2?$usage}
X			if [ ! -r $lib/$2 ]
X			then
X				echo ${0}: ${2}: Unknown language 1>&2
X				exit 17
X			fi
X			lang=$2
X			shift
X			;;
X		-n)
X			init="/lineres ${2?$usage} def $init"
X			shift;
X			;;
X		-p)
X			init="/progsize ${2?$usage} def $init"
X			shift;
X			;;
X		-s)
X			if [ ! -r ${2?$usage} ]
X			then
X				echo ${0}: ${2} unreadable 1>&2
X				exit 17
X			fi
X			shift
X			;;
X		-t)
X			init="/tabstop ${2?$usage} def $init"
X			shift;
X			;;
X		-v)
X			init="/lpi ${2?$usage} def $init"
X			shift;
X			;;
X		-?*)
X			echo $usage 1>&2
X			exit 19
X			;;
X		*)
X			files="$files $1"
X			;;
X	esac
X	shift
Xdone
X
Xcat - ${prog-$lib/pps.pro} $style << EOC
X%!PS-Adobe-1.0
X%%Title: ${files-standard input}
X%%Creator: $0 ($rcsid)
X%%CreationDate: `date`
X%%For: ${USER-unknown}@${HOST-`hostname || uuname -l`}
X%%EndComments
XEOC
Xecho $init && ${lib}/${lang=c} $files && echo "%%Trailer
Xppsdone"
SHAR_EOF
if test 1515 -ne "`wc -c < 'pps.sh'`"
then
    echo shar: "error transmitting 'pps.sh'" '(should have been 1515 characters)'
fi
chmod +x 'pps.sh'
fi
echo shar: "extracting 'slide.sh'" '(954 characters)'
if test -f 'slide.sh'
then
    echo shar: "will not over-write existing file 'slide.sh'"
else
sed 's/^X//' << \SHAR_EOF > 'slide.sh'
Xrcsid='$Header: slide.sh,v 0.0 88/06/22 05:22:48 on Rel $'
X#
X# Argument processor and handshaker for slide maker.
X#
Xusage="usage: ${0} [ -l language ] [ -t tabstop ] files"
Xlib=.
XPATH=/bin:/usr/bin
X
Xwhile [ "$*" ]
Xdo
X	case $1 in
X		-l)
X			if [ ! -r $lib/${2?$usage} ]
X			then
X				echo ${0}: ${2}: Unknown language 1>&2
X				exit 17
X			fi
X			lang=$2
X			shift
X			;;
X		-t)
X			tab=${2?$usage} ; shift
X			;;
X		-*)
X			echo $uasge 1>&2
X			exit 1
X			;;
X		*)
X			files="$files $1"
X	esac
X	shift
Xdone
X
X# Sainity check
X: ${files?"Sorry, cannot read standard input."}
X: ${lang=c}
X: ${tab=8}
Xcolrow=`$lib/prc -cr -t $tab $files | sed -n '$s/[^0-9][^0-9]*/ /gp'`
X
Xcat - ${prog-$lib/slide.pro} $style << EOC
X%!PS-Adobe-1.0
X%%Title: ${files-standard input}
X%%Creator: $0 ($rcsid)
X%%CreationDate: `date`
X%%For: ${USER-unknown}@${HOST-`hostname || uuname -l`}
X%%EndComments
XEOC
Xecho "
X/tabstop $tab def
X$colrow ppsinit
X" && ${lib}/${lang=c} $files && echo "%%Trailer
Xppsdone"
SHAR_EOF
if test 954 -ne "`wc -c < 'slide.sh'`"
then
    echo shar: "error transmitting 'slide.sh'" '(should have been 954 characters)'
fi
chmod +x 'slide.sh'
fi
echo shar: "extracting 'pps.pro'" '(4116 characters)'
if test -f 'pps.pro'
then
    echo shar: "will not over-write existing file 'pps.pro'"
else
sed 's/^X//' << \SHAR_EOF > 'pps.pro'
X%%$Header: pps.pro,v 0.0 88/06/22 05:22:26 on Rel $
X
X% General macros ( should be builtins :-)
X
X/inch { 72 mul } def
X/min { 2 copy gt { exch } if pop } def
X/max { 2 copy lt { exch } if pop } def
X/curx { currentpoint pop } def
X/cury { currentpoint exch pop } def
X
X% Show a string, right justified, and move to its beginning.
X/rshow {	% string
X	dup stringwidth pop neg		% string width, negative
X	dup 0 rmoveto
X	exch show
X	0 rmoveto			% to beginning of string
X} def
X
X% Commands
X
X/fname {	% string fname -
X	/filename exch def
X	/pageno 0 def
X	/lineno 1 def
X	1 f
X} def
X
X/fdate {	% string fdate -
X	/date exch def
X} def
X
X/funct {	% string funct -
X	gsave
X	C titlesize scalefont setfont
X
X	fbase
X	dontstep ( ) stringwidth pop sub cury min
X	moveto
X	90 rotate
X	rshow
X	/dontstep curx ( ) stringwidth pop sub def	% Yech!
X
X	grestore
X} def
X
X/t {	% ntabs t -
X	{ 
X		curx 1 add
X		tabwidth div ceiling
X		tabwidth mul
X		dup rlimit gt {
X			pop
X			lcont marshow
X			1 nl
X		} {
X			cury moveto
X		} ifelse
X	} repeat
X} def
X
X/nl {	% nlines nl -	(internal use)
X	{
X		cury dy add
X		dup
X		highth neg le {
X			pop
X			1 f
X		} {
X			0 exch
X			moveto
X		} ifelse
X	} repeat
X} def
X
X% Show a string in margins, if there is enough room.
X/marshow {	% string marshow -	(internal)
X	cury dight add dontstep lt {
X		gsave
X
X		C setfont
X		width cury moveto
X		rshow
X		/dontstep cury def
X
X		grestore
X	} if
X} def
X
X/n {	% nlines n -
X	dup lineno add
X	/lineno exch def
X
X	nl
X	% Bug: does not number blank lines!
X	lineres 0 gt {
X		lineno lineres mod 0 eq {
X			lineno maxline cvs marshow
X		} if
X	} if
X} def
X
X/np {	% npages np -	(internal)
X	totalpage 0 gt {
X		showpage
X	} if
X	/totalpage totalpage 1 add def
X	margin ury translate
X	0 0 moveto
X} def
X
X/f {	% npages f -
X	{
X		np
X		/pageno pageno 1 add def
X		titleput
X		pageno 1 gt {
X			lineno maxline cvs marshow
X		} if
X	} repeat
X} def
X	
X/s {	% string font s -
X	setfont
X
X	dup stringwidth pop
X	curx add
X	rlimit gt {
X		lcont marshow
X		1 nl
X	} if
X	show
X} def
X
X% This is a halfhearted attempt.
X% The ultimate thing is a printf() like specification from argv[].
X/titleput { % - titleput -
X	0 dy 3 mul rmoveto	% space for title
X
X	C setfont
X	date show
X
X	C titlesize scalefont setfont
X
X	width cury moveto
X	pageno maxpage cvs rshow
X
X	curx (  ) stringwidth pop sub rlimit min
X	cury moveto
X	currentdict /header known {
X		header
X	} {
X		filename
X	} ifelse rshow
X
X	/dontstep cury def
X	0 cury dy 2 mul add moveto
X} def
X
X% Init macro - must be called after definitions are changed.
X
X/ppsinit { % - ppsinit -
X	gsave
X
X	/dy	 1 inch lpi div neg def
X	fonts {
X		findfont dy neg progsize mul scalefont def
X	} forall
X
X	% Paper limits
X	initclip clippath pathbbox
X	/ury exch def
X	/urx exch 5 sub def	% margin may be set wrong
X	/lly exch def
X	/llx exch def
X
X	% Line numbers are right justified to width.
X	% We force a newline when rlimit is exceeded by text.
X	/highth ury lly sub dy add def
X	/margin llx 1 inch add def
X	/width urx margin sub def
X
X	% UnderlinePosition or FontBBox may be missing...
X	% Measure sizes of things we print in margins.
X	C setfont
X	/rlimit width maxline stringwidth pop sub def	% right limit
X
X	newpath 0 0 moveto
X	(670) true charpath flattenpath pathbbox
X	/dight exch def					% digit ht
X	pop pop pop
X
X	C titlesize scalefont setfont
X	newpath 0 0 moveto
X	(qypfgj\(\),_) true charpath flattenpath pathbbox
X	pop pop exch pop width add
X	/fbase exch def					% function base
X
X	I setfont
X	/tabwidth (n) stringwidth pop tabstop mul def
X
X	/totalpage 0 def
X
X	grestore
X} def
X
X/ppsdone {
X	showpage
X} def
X
X% Page style -- may be modified.
X
X/tabstop 8 def  	% Charcters per tabstop
X/lineres 10 def		% Line numbering resolution
X/maxline (9999) def	% Maximum lines / file
X/maxpage (999) def	% Maximum pages / file
X
X/lpi 7 def		% Lines per inch
X/progsize 70 72 div def	% Program point size / line spacing
X/titlesize 1.2 def	% Title point size / program point size
X
X% Default fonts -- need not be fixed pitch.
X/fonts 4 dict def
Xfonts begin
X	/C /NewCenturySchlbk-Roman def	% Comments
X	/K /Courier-Bold def		% Keywords
X	/S /Courier-Oblique def		% Strings
X	/I /Courier def			% The rest
Xend
X
X/lcont (\274) def	% Line continuation char (ellipsis)
X%%EndProlog
SHAR_EOF
if test 4116 -ne "`wc -c < 'pps.pro'`"
then
    echo shar: "error transmitting 'pps.pro'" '(should have been 4116 characters)'
fi
fi
echo shar: "extracting 'slide.pro'" '(2458 characters)'
if test -f 'slide.pro'
then
    echo shar: "will not over-write existing file 'slide.pro'"
else
sed 's/^X//' << \SHAR_EOF > 'slide.pro'
X% $Header: slide.pro,v 0.0 88/06/22 05:22:44 on Rel $
X% General macros
X/curx { currentpoint pop } def
X/cury { currentpoint exch pop } def
X/min { 2 copy gt { exch } if pop } def
X/max { 2 copy lt { exch } if pop } def
X
X/vecop {
X% [ v1x v1y ] [ v2x v2y ] { op } vecop [ v1x v2x { op } v1y v2y { op } ]
X	3 1 roll aload pop
X	3 2 roll aload pop
X	3 2 roll
X	5 -1 roll dup 6 1 roll exec
X	exch 4 2 roll exch exec
X	exch
X	[ 3 1 roll ]
X} def
X 
X% Automatic stretching
X/pagedim { % - pagedim [ llx lly ] [ urx ury ]
X	initclip clippath pathbbox
X	[ 3 1 roll ]
X	3 1 roll
X	[ 3 1 roll ]
X} def
X
X/ndim { % - ndim [ nx ny ]
X	[ I setfont (n) stringwidth pop dy ]
X} def
X
X/stretch { % w h stretch -
X	dup
X	% How much can we magnify?
X	pagedim { sub } vecop margin { sub } vecop	% page space
X	exch { div } vecop
X	aload pop min exch
X	% How much can we magnify on rotated page?
X	[ pagedim { sub } vecop margin { sub } vecop aload pop exch ]
X	exch { div } vecop
X	aload pop min exch
X
X	gsave
X	2 copy
X	gt {	% landscape
X		pagedim exch pop
X		margin [ 2 2 ] { div } vecop { add } vecop
X		aload pop translate
X		90 rotate
X		pop dup scale
X	} {	% portrait
X		[ pagedim 0 get exch 1 get ]
X		margin [ 2 -2 ] { div } vecop { add } vecop
X		aload pop translate
X		dup scale pop
X	} ifelse
X	/txfrm matrix currentmatrix def
X	grestore
X} def
X
X% pps instructions
X/fname {	% string fname -
X	/filename exch def
X	/pageno 0 def
X	1 f
X} def
X
X/fdate { /date exch def } def
X/funct { pop } def
X
X/t {	% ntabs t -
X	{ 
X		curx 1 add
X		tabwidth div ceiling
X		tabwidth mul
X		cury moveto
X	} repeat
X} def
X
X/n {	% nlines n -
X	{ 0 cury dy sub moveto } repeat
X} def
X
X/f {	% npages f -
X	{
X		totalpage 0 gt {
X			showpage
X		} if
X		/totalpage totalpage 1 add def
X		/pageno pageno 1 add def
X	} repeat
X
X	txfrm setmatrix
X	0 0 moveto
X	1 n
X} def
X	
X/s {	% string font s -
X	setfont
X	show
X} def
X
X/ppsinit { % width ht ppsinit -
X	fonts {
X		findfont ppoints scalefont def
X	} forall
X	[ 3 1 roll ] ndim { mul } vecop stretch
X	/tabwidth ndim 0 get tabstop mul def
X	/totalpage 0 def
X} def
X
X/ppsdone {	% - ppsdone -
X	1 f
X} def
X
X% Fonts -- should better be fixed pitch.
X/fonts 4 dict def
Xfonts begin
X	/C /NewCenturySchlbk-Roman def	% Comments
X	/K /Courier-Bold def		% Keywords
X	/S /Courier-Oblique def		% Strings
X	/I /Courier def			% The rest
Xend
X
X% Page parameters
X/margin [ 60 60 ] def		% x, y margin in points
X/ppoints 10 def			% pointsize -- do not change!
X/dy ppoints def			% line spacing, >= ppoints
X/tabstop 8 def			% ens per tabstop
X%%EndProlog
SHAR_EOF
if test 2458 -ne "`wc -c < 'slide.pro'`"
then
    echo shar: "error transmitting 'slide.pro'" '(should have been 2458 characters)'
fi
fi
echo shar: "extracting 'fonts'" '(1016 characters)'
if test -f 'fonts'
then
    echo shar: "will not over-write existing file 'fonts'"
else
sed 's/^X//' << \SHAR_EOF > 'fonts'
X# $Header: fonts,v 0.0 88/06/22 05:22:07 on Rel $
X# Font name aliases for pps
X# Has all LaserWriter+ fonts.
X# PostScript		Nicknames
XCourier			c
XCourier-Bold		cb
XCourier-Oblique		co ci
XCourier-BoldObluique	cbo cbi cib cob cd
XTimes-Roman			t
XTimes-Bold		tb
XTimes-Italic		to ti
XTimes-BoldItalic	tbi tbo tib tob td
XHelvetica		h
XHelvetica-Bold		hb
XHelvetica-Oblique	ho hi
XHelvetica-BoldObluique	hbo hbi hib hob hd
XSymbol
XAvantGarde-Book		avantgarde ag
XAvantGarde-BookOblique	ago ao
XAvantGarde-Demi		agb ab
XAvantGrade-DemiOblique	agd ad aib abi aob abo
XBookman-Demi		bb
XBookman-DemiItalic	bd bib bbi bob bbo
XBookman-Light		bookman b
XBookman-LightItalic	bi bo
XHelvetica-Narrow	hn n
XHelvetica-Narrow-Bold	hnb nb
XHelvetica-Narrow-Oblique	hno hni no ni
XHelvetica-Narrow-BoldOblique	hnbo nbo hnd nd hnob nob
XNewCenturySchlbk-Roman		newentury schoolbook century ncs ncsr
XNewCenturySchlbk-Bold		ncsb
XNewCenturySchlbk-Italic		ncsi ncso
XNewCenturySchlbk-BoldItalic	ncsni ncsbo ncsd
XZapfChancery-MediumItalic	zcmi zc z
XZapfDingbats
SHAR_EOF
if test 1016 -ne "`wc -c < 'fonts'`"
then
    echo shar: "error transmitting 'fonts'" '(should have been 1016 characters)'
fi
fi
exit 0
#	End of shell archive


