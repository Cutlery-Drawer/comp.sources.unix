From: decvax!hplabs!hpcnou!dat (Dave Taylor)
Subject: Msg Shar.part.2
Newsgroups: mod.sources
Approved: jpn@panda.UUCP

Mod.sources:  Volume 4, Issue 6
Submitted by: decvax!hplabs!hpcnou!dat (Dave Taylor)



# Msg Shar part 2 of 7

# Shell Archive created by hpcnou!dat at Wed Feb 26 15:55:52 1986

# To unpack the enclosed files, please use this file as input to the
# Bourne (sh) shell.  This can be most easily done by the command;
#     sh < thisfilename

# This archive contains;
#  doc/Msg.guide    hdrs/curses.h       hdrs/defs.h         hdrs/headers.h
#  hdrs/msg.h       hdrs/sysdefs.h


if [ ! -d doc ]
then
  echo creating directory doc
  mkdir doc
fi

# ---------- file doc/Msg.guide ----------


if [ -f doc/Msg.guide ]
then
  echo File 'doc/Msg.guide' already exists\!
  exit 1
fi

echo extracting file doc/Msg.guide...
cat << 'END-OF-FILE' > doc/Msg.guide
'
'  Users guide to the MSG mail system.
'  format with 'nroff -mm Msg.guide > Msg.format
'  or something similar.
'  (C) Copyright 1985 Dave Taylor
'
'  reachable at ..ihnp4!hpfcla!d_taylor
'  or HP - CNO, 3404 E. Harmony Rd, Fort Collins, CO, 80525
'
'  (303) 226-3800 x2419
'
'  Last update: February 24th, 1986
'
.SA 1
.nr Hy 1
.nr Pt 1
.PH ""
.PF "''Page \\\\nP'"
.HM 1 1
.sp 3
.PH "'Msg Users Guide''Version 3.2'"
.ce 99
Msg 3.1 Users Guide
.sp 2
Dave Taylor
.sp 2
\*(DT
.ce 0
.sp 3
.H 1 "Introduction"
.P 1
The UNIX operating system was originally written on a small PDP machine
to work with teletypewriters.  Consequently, all the original software for
the operating system was written with a 'tty' in mind - they were all 
line oriented, rather than screen oriented.
.P
Gradually this began to change, and, with the addition of the Berkeley
.I vi
visual shell to the 
.I ed
line editor, the trend was brought to the attention of certain 
UNIX systems designers.  
.P
This, however, seemingly hasn't been enough, as 
.I vi
and
.I notes
are still the only screen oriented software available
(other than games, which are a taboo subject with managers
and the like!).  Consequently, after becoming more and more frustrated
with the existing electronic mail facilities on the system ('mail'
and 'mailx', both of which are essentially line-editors) I decided
to write my own!
.P
This document discusses the 
.I msg
mailer, and includes a set of example screens and a discussion
of configuration (for systems administrators).  It is broken
down into the following general sections;
The \fI.msgrc\fR file,
starting options of 
.I msg,
the main system level,
responses of various commands,
the alias system,
and system configuration.
.P
Any comments or problems with either this document or the program
itself are welcome: all installed systems should have an alias
that will ensure that I receive any mail sent to 'msg'.
.SK
.H 1 "The .msgrc File"
.P
The \fImsg\fR mailer has the 
ability to automatically read in a configuration 
file at each invocation.  The file must be
called ".msgrc" and reside in your home directory for it
to be read in, and can have any of the following entries
in any order (note that the first four entries replace
environment variables of the same name, and the four
boolean options supplement required starting parameters);
.VL 10 0
.LI "fullname"
This is the name the mailer will use when sending mail 
from you.  It is highly recommended that you use your
full name and nothing strange or unusual, as that can
appear extremely rude to people receiving your mail.
.LI  "maildir"
This is the default mail folder.  It is used to expand filenames
in the mailer when specified using the '=' metacharacter.  That
is, if you save to file "=/stuff" then the '=' will be expanded
to the current value of maildir.
.LI "mailbox"
This is where to put incoming mail after you've read it.
When you answer 'y' to the "save to mailbox?" prompt, this
is where the messages go!
.LI "editor"
The editor to use when typing in message to people.
.LI "print"
This indicates how to print out a message.  There are two
possible formats for this string, either a command that
can have a filename affixed to (as a suffix) and then
sent to the system for execution, or a string that 
contains the meta-sequence '%s' which will be replaced
by the name of the file and then also sent to the
shell.  Examples of each are;
.nf

	print = print -formfeed
	print = pr %s | lpr

.fi
.LI "prefix"
When you reply to a message or forward a message to another person,
you can optionally include the original message.  Defining the
prefix value here allows you to indicate what the prefix of 
each included line should be.  The default is "> " and is
fairly standard in the Unix community.
.LI "savemail"
This is where outgoing mail will have a copy silently (and
quickly) saved.  This will only be used if the flag 'copy'
is turned on.  Also note that if the 'savename' flag
is turned on then this line is ignored since each outgoing
message is saved according to whom it's being sent to.
.LI "shell"
This defines the shell to use when doing '!' escapes and
such.  Note that the program also reads the $SHELL variable
out of the current environment, but that defining this
in the .msgrc file will override the environment definition.
.LI "weedout"
This is something new and exciting!  When specifying this
option, you can then list as many headers of messages that
you \fBdon't\fR want to see when you are read mail.
This list can continue for as many lines as desired, as 
long as the continued lines all have leading indentation.
.LI "alternatives"
This is a list of other machine/username combinations
that you receive mail from (forwarded).  This is used 
when the G)roup reply feature is invoked to ensure that
you don't send yourself a copy of the outbound message.
.LI "autocopy"
This is a boolean flag, and if set will automatically copy
the text of each message being replied to into the edit
buffer.  This is the same as the '-a' starting parameter.
.LI "copy"
This, in combination with the "savemail" filename, will
allow you to have silent copies of all outgoing mail
made on the outbound step.  
.LI "resolve"
This is a boolean flag that defines the behaviour of the
program for such actions as deletion, saving a message 
and so on.  
.LI "weed"
This is a boolean flag that, in combination with the
"weedout" list, allows you to custom define the set of
headers you would like to not have displayed while reading
messages.  The defaults are listed further into the
document.
.LI "noheader"
This boolean flag tells the mailer not to include the 
headers of messages when copying a message into a file
buffer for replying to or forwarding.
.LI "titles"
This boolean flag allows you to have each page of a message
to be titled with:
.nf
Message #N from username	Mailed date at time
.fi
where all the information has been previously extracted
from the message.
This is especially useful if you weed out all the headers of each
message with a large 'weedout' list...
.LE
.sp
Two more things: the format for each of the lines is;
.nf

	variable = value

.fi
and for boolean variables, value can be 'ON' or 'OFF' only.
.sp
For a better idea of how this all works, here's my .msgrc file.
While looking through it, notice that you can have lots of comments
and blank lines for readability and that you can also use 'shell
variables' and the '~' metacharacter for your home directory, 
and they are expanded accordingly when read in by the mailer.
.nf

  #
  # .msgrc - automatic variable defines for the 'msg' mailer.
  #
  # Personalized for Dave Taylor
  # 
  
  fullname = Dave Taylor

  # where to save my mail to, default directory
  maildir  = ~/Mail
  
  # where to save messages to, default file
  mailbox  = ~/Mail/mailbox
  
  # what editor to use
  editor   = $EDITOR
  
  # where to save mail if not specified somewhere else
  savemail = ~/Mail/mail.sent
  
  # how to print a message ('%s' is the filename)
  print    = /usr/local/bin/print -p lpn -f %s
  
  # prefix sequence for including message text in other messages...
  prefix = > 
  
  # what headers I DON'T want to see, ever.
  
  weedout  = "Via:"  "Sent:"  "Date:"  "Status:"  "Original"
	     "From"  "Phase"  "Subject:"  "Fruit"  "Sun"
	     "Lat"  "Buzzword"  "Return"  "Posted" "Telephone"
	     "Postal-Address" "Origin" "X-Sent-By-Nmail-V"
	     "Resent" "X-Location"  "Source" "Mood"  "Neuron"
	     "Libido" "To:" "X-Mailer:"  "Full-Name:" "X-HPMAIL"
	     "Cc:" "cc:" "Mmdf" "Network-"
  
  # automatically copy message being replied to into buffer? 
  autocopy = OFF
  
  # save a copy of all outbound messages? 
  copy     = ON
  
  # emulate the mailx message increment mode (only increment after something
  # has been 'done' to a message, either saved or deleted)
  resolve  = ON
  
  # enable the weedout list to be read...
  weed     = ON
  
  # when messages are copied into the outbound buffer, don't include headers
  noheader = ON
  
  # display message title when displaying pages of message
  titles	 = ON
  
  # alternative addresses that I could receive mail from (usually a
  # forwarding mailbox)

  alternatives = hpcnof!dat,  hpcnof!d_taylor,   hpcnou!d_taylor,
	         hpcnou!root, hpcnou!postmaster, hpcnoe!d_taylor, 
                 hpcnoe!dat,  hpcnoa!d_taylor,   hpcnoa!dat, 
                 hpfcla!d_taylor

.fi
Along with this, there is still an environment variable
that the mailer checks for, namely "EDITOR", which can
also define what editor to use when entering messages.
As with the shell variable, having an editor specified
in the .msgrc file will override anything read in from
the current environment.
.sp 2
.H 1 "The Starting Parameters"
.P
There are a number of starting options to the
.I msg
program, with only one that needs to be remembered: '-?'or '-h' for help.
.P 0
The flags are;
.VL 10 3
.LI "-d"
Debug.  Useful for debugging the 
.I msg
program.  The results of using the debug option is
much less drastic than in the previous versions of 
the program - it creates a file in your home directory
called "Msg.debug.info" and creates a (verbose) log
of activity as the program is used.  
.LI "-f <file>"
File.  Read specified file rather than the default input mailbox.
.LI "-h or -?"
Help.  Gives a short list of all these options and exit.
.LI "-k"
Keypad - This option, when used, lets the \fImsg\fR program
know that you're on an HP terminal, and it can then interpret
the PREV NEXT and HOME/DOWN-HOME keys accordingly.  If you
are not on an HP terminal, it is recommended that you do
NOT use this option.
.LI "-s"
Softkeys.  The \fImsg\fR mailer can, to a rather limited
extent, use the HP softkeys as an alternative form of
input.  If you specify this option be sure that you're on
an HP terminal that can accept the standard 2622 terminal
escape sequences!
.LI "-z"
Zero.  This causes the mailer not to be started if you don't
have any mail.   This emulates the behaviour of programs
like 'mailx'.
.LI "-S <subject>"
In batch mode, this is how to indicate the subject of the
resulting message.  Please see the section on "Non-Interactive
Uses of Msg" for further information.
.LE
.P
All the above flags default to reasonable options, so there is
usually no need to use them.   
.sp 2
.H 1 "Non-Interactive Uses of Msg"
.P 1
Before we discuss the main mail system, it's worth noting that 
there are a couple of other ways to use the \fBmsg\fR mail 
system, namely to 'send only' and to send files (batchmail).
.P
To send a message to someone without any of the associated 
overhead of the main system being loaded, you can invoke the
mailer with the name(s) of the people to send to.  The 
mailer will then prompt for Subject, Copies, and then drop
you in your (defined in the ".msgrc" file) editor to compose
the message.   When composition is complete, the program 
verifies transmission then terminates.  For example;
.nf

  $ \fBmsg dat\fR
  To: ihnp4!hpfcla!d_taylor
  Subject: \fBthis is a test\fR
  Copies To: \fB<return>\fR

  <invokes editor, message composed, then>

  Are you sure you want to send this? (y/n) \fBy\fR

  mail sent.

  $

.fi
Note that the user input is in \fBbold\fR face, so you can see that
the mailer verified the alias expansion too!
.sp
.P
The mailer also supports batch type mailing, of files and so on,
by using the following starting sequence;
.nf

  $ \fBmsg -S "File help.c" dat < help.c\fR

.fi
which will read in the file and transmit it to the specified user
with the specified subject.  Note that the program is intelligent
enough to check to see what the stdin is from this invocation, so
a command of the form
.nf

  $ \fBmsg -S "file help.c" dat\fR

.fi
would result in the following sequence (since the program is reading
the "standard in" for information;
.nf

  $ \fBmsg -S "file help.c" dat\fR
  To: ihnp4!hpfcla!d_taylor
  Subject: file help.c

  Enter your message, ending with ^D

  \fBthis is the message
  Please don't ask me why I used this wierd mode!

  ^D\fR
  <end-of-message>

  $

.fi
which is reasonable behaviour!!  (not only that, but this is 
almost exactly what \fB/bin/mail\fR does in the same situation!!)
.sp
.P
Enough of this foolishness, however, let's get onto the real
stuff;
.sp 2
.H 1 "The Main System"
.P 1
Upon entry to the program, the main screen will be 
displayed as below;
.sp
.DS
.ce
-----------------------------------------------------------------
.ce
Mailbox is '/usr/mail/mymail' with 13 messages.  [Version 3.0]
.nf

   1<-   Apr 3  rob		Doing anything tonight?
   2     Apr 5  hplabs!joe	bug in gammon game
   3	 Apr 5  root		
   4	 Apr 6  root	        (continuation of previous message)
U  5     Apr 8  decvax!mouse	Re: net.music article decvax:495
   6	 Apr 13 John Jacobs      How can you hate RUSH?
   7     Apr 15 kevin	 	More software requests
N  8	 Apr 18 games		Hi there
N  9	 Apr 18 Dave Taylor	EditFile.c source...
N 10 	 Apr 23 veeger!carl	More silly stuff


.ce 3
|=pipe, !=shell, ?=help, <n>=set current to n, /=search pattern
A)lias, C)hange mailbox, D)elete, F)orward, G)roup reply, M)ail,
N)ext, P)rint, R)eply, S)ave to file, Q)uit, U)ndelete, or eX)it
                                                            
Mail :@
.fi
.ce
-----------------------------------------------------------------
.DE
.sp
.P 
There are a number of things to notice about this screen;
.ML o 5
.LI
The top line always displays the current mail file, 
the number of messages in the file, and the current 
.I msg
version number.
.LI
On the left side of each message is the message
number which is unique for each message in the file.
.LI
The arrow ('<-') always points to the current message.  This is the
message that the commands having default message numbers
(such as D)elete, and N)ext) will work with.
.LI
The date associated with each message is the date the person
.B sent 
the message.  This is obtained by either the oldest of the
">From" line dates, or, if possible, by parsing the "Date:"
line.
.LI 
The third field displayed is a truncated 'from' address, and will
indicate whom the message is from.  Note that on the sixth and
ninth messages full names appear instead of the usual machine!login
format.  This is because these messages have a From line of the
form:
.nf
  
	From: fullname <address>
or      From: address (fullname)

.fi
which the mailer reads and displays if possible.  The \fImsg\fR
mailer (version 2.1 and beyond) also generates this header line on
outgoing mail.
.LI
The final field is the (optional) subject of the message.  Note
that message 3 has no subject.
.LI
Message five is an 'Urgent' message (it contains the header
.nf

	Priority: Urgent

.fi
to make it urgent) that should be read immediately.
.LI
Messages 8 thru 10 are new since the last time the user read their
mail - the "N" in the leftmost margin indicates this.
.LI
A maximum of ten messages are displayed at one time*.
.FS \*
On terminals with greater than 25 lines, more messages will be 
displayed automatically.  
.FE
Further into
the document we'll learn how to change 'pages' in the mailbox. 
.LI
The three line mini-menu will always 
indicate what commands are available at 
the current moment.  
' This display can be inhibited by the '-m' (menu) starting option.
.LI
Finally, the '@' character indicates where the cursor would be, awaiting
your input.
.LE
.P
The typical action at this point is to use the 
.I <return>
key to read the current message.  This particular option isn't
noted in the mini-menu, but choosing the '?=help' option will
inform you of a number of choices other than those in the 
basic menu!
.P
Pressing this key will clear the screen and display the first page
of the message.  At the bottom of the page, the system will write
either;
.sp
.tl 'Please press <space> to continue''<xx> lines left'
.sp
or
.sp
.tl 'Please press <space> to return'
.P 0
These indicate how much of the current message has been read: 'continue'
indicates the presence of
at least one more line of information (the exact number will
be indicated on the right hand side as 'xx lines left').  Pressing
<return> rather than <space> will automatically return you to the main
system level at any page of a message.
.P
When the message continues onto another page the \fImsg\fR mailer will
also indicate how many lines are left in the message...
.P
If resolve-mode is turned off (see the 'resolve' flag)
the current message pointer 
(the arrow) will be incremented after reading the message
and will point to the next message in
the list.  
.P
As you can see, it would be quite simple to quickly read through
all the pending mail by repeatedly using the
.I <return>
command at the menu level, and the <space> bar while reading 
each message!
.P
While reading is perhaps the most fundamental function that the
.I msg
program performs, there are a number of other options available,
namely;
.sp
.VL 25 0 1
.LI "Command"
Action
.LE
.sp
.VL 22 3 1
.LI "|"
Pipe current message to specified command.
.LI "!"
Shell escape.
.LI "?"
A help screen listing commands
.LI "+, <space>, or <NEXT>"
Next page of headers
.LI "-, or <PREV>"
Previous page of headers
.LI "=, or <HOME>"
Set current message to 1
.LI "*, or <SHIFT>-<HOME>"
Set current to last message.
.LI "<n>"
Set current message to n
.sp
.LI "a"
Alias, change to 'alias' mode 
.LI "c"
Change current mail file
.LI "d"
Delete current message
.LI "f"
Forward message to specified user
.LI "g" 
Group reply - reply to everyone who received the current message
.LI "h"
Display message + headers
.LI "j"
Increment current message by one
.LI "k"
Decrement current message by one
.LI "m"
Mail to arbitrary user(s)
.LI "n or <return>"
Next message (Read current, then increment)
.LI "o"
Option.  Alter current options.
.LI "p"
Print current message.
.LI "r"
Reply to the author of current message
.LI "s"
Save current message to file
.LI "t"
The current time and date is displayed
.LI "q"
Quit - mail deleted, saved in mbox or left.
.LI "u"
Undelete current message
.LI "v"
Variables.  Display current variables.
.LI "x"
Exit - don't record as read, don't save...
.sp
.LI "^L"
Rewrite screen.
.LI "^M (<return>)"
Read current message
.LI "^Q, ^Z, DEL"
Exit - don't record as read, don't save...
.LE
.sp
.P 0
That are all the commands available at the main level of the
.I msg
program!  Now you can see why it is nice to leave the three-line
menu displayed!
.sp 2
.P
As an example, let's enter a series of commands and indicate
what the display would be after each one;
.sp
.P 0
First off, let's go to the next page of mail with '+';
.sp
.DS
.nf
.ce
-----------------------------------------------------------------
.ce
Mailbox is '/usr/mail/mymail' with 13 messages.  [Version 3.0]
.nf

N 11<-    Apr 27 Jack		Wanna buy some albums cheap?
N 12      Apr 28 Jack		Cancel the previous offer!
N 13	  Apr 30 sdcsvax!dx	Moving day (long)		









.ce 3
|=pipe, !=shell, ?=help, <n>=set current to n, /=search pattern
A)lias, C)hange mailbox, D)elete, F)orward, G)roup reply, M)ail,
N)ext, P)rint, R)eply, S)ave to file, Q)uit, U)ndelete, or eX)it

Mail :@
.fi
.ce
-----------------------------------------------------------------
.DE
.P 1
We need to move the current message pointer to message 11, so
type in '11', then let's read the new current message by
using the 
.I next
command (typing <return>)...
.sp 
.DS
.nf
.ce
-----------------------------------------------------------------
.sp
Message #11 from Jack  		Mailed December 7, 1984 at 8:45 pm

Hey Dave! I've got some old AC/DC and KISS albums, and as I know
you are a collector, do you want to buy them off of me before
I make ashtrays out of them (or frisbees...)?

			Humourously,
					Jack The Gripper







Please press <space> to return: @
.sp
.ce
-----------------------------------------------------------------
.DE
.sp
.fi
.P
Needless to say, we can't let this message go by without replying!
So let's press the <space> bar to return to the main menu, 
then use the
.I "reply"
command to respond.
.P
After pressing the 'r' key, the program asks if a copy of the source
message is desired (the character under the cursor indicates the
default if <return> is pressed.  In this case, the default is 'no');
.sp
.nf
copy source message? (y/n) @
.fi
.P
We choose to answer no, so press the 'n' key.  Next 
.I msg
verifies that the subject is okay;
.sp
.nf
Subject: Re: Wanna buy some albums cheap?@
.fi
.sp
Typing anything other than <return> will allow us
to change the subject to something more appropriate.
Furthermore, if we choose to type our "kill line"
character (the same as the one the shell uses,
probably Control-U or Control-X) the entire line will
be erased.
We decide, however, to leave it be and press return.
.sp
Finally, we're asked if we want to send copies of this
message to anyone.  We don't, so we press <return> one
more time.
.P
The program then puts us
in the
.I vi
editor (the default, assuming no other editor specified 
by the '.msgrc' variable "editor") with a blank file.
.P
After having entered a suitable reply, and left the editor,
the 
.I msg
system then verifies that we really want to send the message with;
.sp
Are you sure you want to send this message? (y/n) @
.sp
To which the response is 'y' for 'yes'.  It then sends the message off
to Jack, who will receive it hopefully quite soon (or at least
before he makes ashtrays out of the albums!)
.sp
.P
Also, if we have a file called \fB".msgheaders"\fR in our home
directory, the mailer will include those headers in the 
outbound message.  This is to allow custom (personalized)
mail, especially headers like "Organization:" and "Location:".
.sp
.P
Message 11 is still the current message,
so, now that we have saved it, let's mark it for deletion by
using the
.I delete
command 'd'.
.P
The screen is now;
.sp
.nf
.DS
.ce
-----------------------------------------------------------------
.ce
Mailbox is '/usr/mail/mymail' with 13 messages.  [Version 3.0]
.nf

N 11    * Apr 27 Jack		Wanna buy some albums cheap?
N 12<-    Apr 28 Jack		Cancel the previous offer!
N 13	  Apr 30 sdcsvax!dx	Moving day (long)		
 









.ce 3
|=pipe, !=shell, ?=help, <n>=set current to n, /=search pattern
A)lias, C)hange mailbox, D)elete, F)orward, G)roup reply, M)ail,
N)ext, P)rint, R)eply, S)ave to file, Q)uit, U)ndelete, or eX)it

Mail :@
.fi
.ce
-----------------------------------------------------------------
.DE
.sp
.P
Now lets go back to the first page of messages by typing '=';
.sp
.DS
.ce
-----------------------------------------------------------------
.ce
Mailbox is '/usr/mail/mymail' with 13 messages.  [version 2.2]
.nf

   1<-   Apr 3  rob		Doing anything tonight?
   2     Apr 5  hplabs!joe	bug in gammon game
   3	 Apr 5  root		
   4	 Apr 6  root	        (continuation of previous message)
U  5     Apr 8  decvax!mouse	Re: net.music article decvax:495
   6	 Apr 13 John Jacob       How can you hate RUSH?
   7     Apr 15 kevin	 	More software requests
N  8	 Apr 18 games		Hi there
N  9	 Apr 18 Dave Taylor	EditFile.c source...
N 10	 Apr 23 veeger!carl	More silly stuff



.ce 3
|=pipe, !=shell, ?=help, <n>=set current to n, /=search pattern
A)lias, C)hange mailbox, D)elete, F)orward, G)roup reply, M)ail,
N)ext, P)rint, R)eply, S)ave to file, Q)uit, U)ndelete, or eX)it

Mail :@
.ce
-----------------------------------------------------------------
.DE
.fi
.sp
.P
Gee..note five not only looks mildly interesting but it's an 
Urgent message too!  So 
let's read it by typing '5'<return>
to make that the current message, and press <return> again
to read it.  After reading
the message we decide that this seems like a message worth
keeping in the 'music' mailbox, so lets do that by using
the 
.I "save to file"
command!
.P
Pressing 's' results in the 
.I msg
system prompting;
.P 0
Save to what file : @
.P 0
to which we reply '=/music'.  The file is then saved in the
directory we specified as mail home via the '.msgrc'
variable "maildir". After saving, the "Mail:"
prompt returns, with message 5 marked for deletion and the
current message pointer incremented to message 6.
.P
Before we finish up, we suddenly remember that one of the 
messages was supposed to be about how to write decent 
documentation for Unix systems, so let's try to find it...
.P
First off, we'll move back to message one with the <HOME>
key (you'll need to use the "-k" starting option and be on
an HP terminal for this to work!) and then use the '/'
pattern matching command:
.nf

Mail: Pattern		      / = match anywhere in messages
Match pattern: @

.fi
we'll type in 'document' and see if the system can find it.
After a brief second or two it returns 'pattern not found.'
Hmm...maybe it's not either the from or the subject of
any of the messages...In case, let's try using the new
.I "match anywhere in message" 
command;
.nf

Mail: @

.fi
To which we type '/' for pattern matching;
.nf

Mail: Pattern		      / = match anywhere in messages
Match pattern: @

.fi
Now we'll use '/' again to get the match anywhere in file
option, and then get the prompt;
.nf

Match pattern (in entire mailbox): @

.fi
to which we respond 'document' again.  
.P
The
.B msg
mailer then searches through each line of all the messages in 
the file and moves the current message pointer to message 
number 7.  A quick check reveals that this message indeed
contains the word 'document', but it's not the one we want,
so we're going to just get outta here!
.P
We've had enough mail for today, so lets quit, saving
all messages in our mailbox as defined in the '.msgrc' file, except
messages 5 and 11, which are marked for deletion.
.P
.I Quit
prompts;
.sp
.nf
Delete messages? (y/n) @
.fi
.sp
to which we answer 'y' for yes.  The next prompt is then;
.sp
.nf
Keep mail in incoming mailbox? (y/n) @
.fi
.sp
To which we also answer yes...the program then quickly saves
the files, removing message 5 and 11 as it goes along, and exits.
.sp
.H 1 "Responses..."
.sp
.P
This section will discuss each command in the 
.I msg
program in more detail than above, including the 
prompts the user can expect upon executing the
command, the meaning of different options etc etc.
.sp
.VL 10 3
.LI |
Pipe.  This command allows you to pipe the current message
through other filters as you desire.  The shell used for
the entire command will be either the one specified in
your ".msgrc" file, or, if none, /bin/sh.
.LI !
Shell.  This allows you to send a command to the shell without
leaving the program. 
.LI ?
Help.  This command produces a two-page display that details
all the commands available in a reference guide format.  
.LI \/
Pattern match.  This command, on the top level, allows the
user to search through all the from and subject lines of
the current mailbox starting at the current message and
continuing through the end.  If the first character of the
pattern is a '/', then the program will try to match the
specified pattern against ANY line in the mailbox.  Again,
this works from one after the current message through the
end.
.LI <n>
Specify new current message.  Typing in any of the digits one
thru nine will result in the 
.I msg
program producing the prompt 'Set current to : n', where 'n' is
the digit entered.  
Note that changing the current message to a message not on the 
current page of the headers will result in a new page of headers
being displayed.
.LI a
Alias.  The alias system is a way by which more complex mail addresses
can be shortened for the mail user.  For example;
.P 0
joe, blow : Joe Blow : veeger!hpcnoe!hpcfla!jblow
.P 0
which allows mail to 'joe' with the system expanding
the address properly.  As is obvious, this not only saves remembering
complex addresses, it also allows the address to be optimized to
go through the minimum number of machines without anyone having to
be informed of the change.  A more detailed discussion can
be found in the section entitled 'The Alias System'.
.LI c
Change mailbox.  Specifying this command allows the user to change
the mailbox file that is currently being read.  This is intended 
for perusal and reply to previously archived messages.
The prompt is 'Name of new mailbox : ' and entering <return>
cancels the operation, while entering a filename causes the program
to read that file as the new mailbox file, if possible.
As with the "save" command, this command expands filenames
with '~' being your home directory and '=' being your
MAILDIR directory, if defined.  This command also allows the
special character '!' to be used to allow you to change to
the default incoming mailbox.
.LI "d, u"
Delete and Undelete.  Neither of these two commands have any prompts
and indicate their action by either adding an asterisk to the current
message index entry (indicating deletion pending) or removing the
asterisk (indicating that the deletion is cancelled).
.LI f
Forward.  Allows the user to forward the current message to another user.  
This copies the message into the edit
buffer and allows the user to add their own message too.
The prompt is 'Forward to:' and will expand an alias if
entered.
.LI "j, k"
These two keys work similarly to what they would do in 'vi' or
any of the other screen oriented programs.  The 'j' key moves
the current message pointer down to the next message (going to
the next page if needed) and the 'k' key moves the current
message pointer back to the previous message (also changing 
pages if needed)
.LI m
Mail.  Send mail to a specified user.  The prompt that is associated
with this command is 'Send mail to :'.  Entering an alias name results
in the full address being rewritten in parenthesis immediately.  This
prompt is followed by 'Subject:' which allows the user to title their
note.  The final field is 'Copies to: ', which allows other people
specified to receive "carbon copies" of the message. 
Upon entering all three items the 
.I vi
editor (or any other editor specified by $EDITOR) 
is invoked and the message can be composed.
.LI n
Next message.  See above.
.LI o
Options.  This is a small subsystem of the 
.I msg
system with the various options selected by their first
letter, '1' enabling the option, '0' disabling it
and <return> leaving it unchanged. 'r' returns to
the main system.
.LI p
Print message.  This allows you to print out the current
message to a previously defined printer (see the section
on the '.msgrc' discussing the "print" variable)
.LI q
Quit.  This command's action is dependent on the current state of
the 
.I msg
program.
For example, if the current mailbox is the default mailbox the messages
that are not deleted are saved in the file $home/mbox, whereas
if it is a specified mailbox the to-be-deleted messages are 
removed from the
file.  The possible prompts are 'Save to mailbox?' if the default mailbox
is being read and there is at least one message to save, 'Delete all
messages' if all messages in any mailbox are marked for deletion 
or 'Delete message(s)?'
if not reading the default mailbox and there are some messages that
should be saved.  A response of 'n' (no) to any of these questions will
result in the quit command aborting, and the files being untouched.
.LI r
Reply.  Reply to the author of the current message.  If
the autocopy flag is not specified, the program will 
prompt 'Copy Message? (y/n)' to which the user can specify 
whether a copy of the source message is to be copied into the edit
buffer, or not.  If copied in, all lines from the message are 
prepended with the prefix character sequence, as specified in
the users ".msgrc" file.
.LI s
Save to file.  As demonstrated in the above example, this command
allows the current message to be copied into an arbitrary file.
If there is anything in the file currently the
message is appended to the end, otherwise the file is created
containing only the message.  The prompt for this command
is 'Save to file : '.  A response of <return> cancels the command
and returns the user to the system prompt.
After saving a file, the message is marked for deletion and
the current message pointer is incremented.
There are two available meta-characters when specifying a 
filename too - '~' as the first character expands to your
home directory, and '=' as the first character expands to
the mail folder directory defined via the 'maildir' 
variable in the users ".msgrc" file.
.LI t
Time.  This simply displays the current date and time in a nice
readable format.
.LI v
Variables.  This is also a small subsystem of the 
.I msg
system allowing you to alter the value of various 
.I msg
variables.  The variables that you can change are
the 'EDITOR' variable which determines what editor to 
use when you compose a message,
the 'MAILBOX' variable which indicates where mail is
to be put after being read, and
the 'USERNAME' variable.  (Note that only the superuser
can change their username within the program)
.LI x
Exit.  This is functionally the same as answering 'n'o to the 
.I quit
command prompt, and simply leaves the program in the quickest
possible manner.  This command can also occur from typing
DELETE, control-Q or control-Z, all of which are also 
.I exit
commands.
.LE
.sp 2
.H 1 "Special Outgoing Mail Processing"
.sp
.P
There are a few extra features that the mailer offers on
outgoing mail that are worthy of mention;
.sp
.P
The first, and probably the most exciting feature, is the
ability to send \fBencrypted\fR mail!  To do this is 
extremely simple:  You need merely to have two 'key lines'
"[encode]" and "[clear]" in the message body.
.P
Consider the following outgoing message:
.nf

	Joe,
		Remember that talk we had about Amy?  Well,
	I talked to my manager about it and he said...

	uhh...better encrypt this...the usual 'key'...

	[encode]

		He said that Amy was having family problems
	and that it had been affecting her work.

		Given this, I went and talked to her, and 
	told her I was sorry for getting angry.  She said
	that she understood.

		We're friends again!!
	[clear]
	
		Exciting stuff, eh?   

					 Mike

.fi
While this is obviously quite readable while being typed into 
the editor, as soon as the message is confirmed as wanting
to be sent, the \fImsg\fR mailer prompts with;
.nf

	Enter encryption key: @

.fi
and accepts a key (or series of 8 or less characters) without
echoing them to the screen.  After entry, it will ask for the
same key again to confirm it, then *poof* it will encrypt and
send the mail!
.P
If you have the "copy" option enabled, the program will save
your copy of the message encrypted too.  (This is to ensure
the privacy and security of your archived mail too!)
.P
If the mailer doesn't ask for the encryption key, it's because
you don't have the '[encode]' entered as the first 8 characters
of the line.  It MUST be so for this to work!!
.P
On the other end, a person receiving this mail (they must also
be using \fImsg\fR to receive it, since this mailer has a
unique encryption program) will be reading the
message and then suddenly be prompted;
.nf

	Enter decryption key: @

.fi
and will again be asked to re-enter it to confirm.  The
program will then on-the-fly decrypt the mail and display
each line as it is decoded.  The '[clear]' line signifies
that the block to encrypt is done.
.P
For those sites not running \fImsg\fR, I also have
available the encryption code as a separate program
suitable for a filter for use with other mailers...
.sp
.P
The other option on outgoing mail is the ability to
specify what section of the message you want to have
archived (assuming "copy" is enabled) and what section
you don't.  This is most useful for sending out source
file listings and so on...
.P
To indicate the end of the section that should be
saved in the archive, you need merely to have the
line
.nf

	[no save]

.fi
appear by itself on a line.  This will be removed from 
the outgoing mail, and will indicate the last line of
the message in the saved mail.
.sp 2
.H 1 "The Mail Archive File"
.sp
.P
The format of the mail saved to the archive file is also
worth a quick discussion.  Unlike the usual exact copy
of the entire header section, the archived mail has the
following header;
.nf

	From To:<name> 15 Jan 1985 4:54:30 MST
	Original-To: <address>
	Subject: <subject>

	<message body>

.fi
The first line, the 'From' line, is deliberately mangled
with the occurance of the 'To:<name' to ensure that when
you are perusing your archive file with the mailer that
you see WHO the message was TO, since they're all going
to be FROM you!!  The <name> will either be the machine!login
of the person, or, if used as an alias, it will be the 
alias name.
.P
To read this file, you can use the mailer, choosing the 
"C)hange mailbox" command, or start up specifying your
archive file as the mailbox to read.
.sp 2
.H 1 "Using MSG with the Notes System"
.sp
.P
A new and innovative feature in the 3.0 release of the 
.B msg
program is the ability to read files saved by the notes
system and display them as individual messages.  Unfortunately,
the notes software does not currently save a note with
the subject line, however, so the mailer uses the next best
thing and displays each note in the form:
.nf

    1  Apr 5  hplabs!kundler	Note from group net.unix-wizards
    2  Apr 7  hplabs!richards	Note from group net.unix-wizards

.fi
and so on.  The individual notes can be replied to by using the
.I reply
command, as with normal mail, and the mailer will modify it's
behaviour to work with this particular brand of mail file.
.P
How does the mailer know if it's reading a file that contains
normal mail versus a saved set of notes?  By checking the
first line of the file - if it's the header line that notes
emits (ie "/***** host:login / notesgroup / date **/") then
the file is considered to be a notes file.  If not, the default
for unknown files is to assume they're mail files.
.sp 2
.H 1 "The Alias System"
.sp
.P
As mentioned previously, there exists in the
.I msg
system a set of aliases that associate
an arbitrary word (such as a persons name) to a complex
address or group.  
The advantages are readily apparent; rather than
remembering an address of the form;
.P 0
machine1!machine2!machine3! ... !machineN!account
.P 0
the user merely has to remember a single word.  
.P
Two alias tables are available for a each
user within 
.I msg,
namely the system alias file and the users' alias file.  The
system alias file is created and maintained (by the system administrator)
by editing the file '/usr/mail/.alias_text' as described
in the documentation with the 
.I newalias
command, then running the 
.I newalias 
program.
.P
An individual user can also have an alias file which works
in conjunction with the system aliases.  To do this, they
need merely to peruse the documentation for the 
.I newalias
command and create a file as indicated therein.  After 
executing the program, the aliases will be available
for using from within 
.I msg.
.P
The command 
.I checkalias
is also useful to ensure that the aliases
are installed correctly.
.P
Within
.I msg,
however, the alias system acts as an entirely different program, with
it's own commands and own mini-menu.  The menu replaces the
standard mini-menu with;
.sp
.DS
.nf
.ce
---------------------------------------------------------------------
.sp
.ce
Alias commands
.sp
.ce
A)lias current message, C)heck alias, M)ake user alias, R)eturn
.sp 2
Alias: @
.ce
---------------------------------------------------------------------
.sp
.DE
.fi
.P 0
The commands are;
.VL 10 3
.LI a
Alias current message.  
This allows the user to create an alias that has the
return address of the current message as the address field of
the alias.  It prompts for a unique alias name.   Important
note: when you alias an address in this fashion, the mailer
will try to minimize the amount it needs to store by
iteratively comparing machine names in the path with the
machines in the pathalias database.  Once it finds an entry
the address will be saved at that point.   For further 
information, please see the "Msg Alias System Guide".
.LI c
Check alias.  This is a simple way of checking what is in the alias
database - it prompts for an alias name, and returns the address
associated with that name or the error message 'alias not found'
as appropriate.  
.LI m
Make user alias.  This will prompt for a unique alias name and
then for an address.  The information provided will be added
to your individual alias_text file ($home/.alias_text) and 
then added to the database.
.LI r
Return.  Return to the main level of the 
.I msg
program.
.LE
.sp 2
.H 1 "While We're Talking Aliases..."
.P
Another feature worthy of discussion, since it's been getting
lots of veiled references throughout this document, is the system
alias section.  This is implemented using the uucp pathalias 
database, with a file (whose location is specified in the hdrs/sysdefs.h
file - see the Configuration Guide) in the format:
.nf

  hostname <tab> address!%s

.fi
The actual details of the file are, suprise suprise, located in 
the Alias System Users Guide.
.P
Anyway, to use them is quite simple...when specifying the address
of someone, you can either have an alias for them already, resond
to their mail to you, or use the system alias feature!
.P
Enough hype, right?  Okay...to use this feature, you specify an
address by either "machine!person" ignoring if your specific
machine can talk directly to the machine specified, or, if you
prefer the ARPANET addressing scheme, "person@machine".  When
you enter the address as specified, the mailer will quickly
search through the pathalias database file and expand the
specified address to be a legitimate routing address.
.P
What's really nice about this is that the address that we're
going to send to can be either on ARPA, CSNET, BITNET, uucp,
or any other network.  The method of specifying the basic
address is the same regardless!
.P
For example, mail to me could be sent as either "hpfcla!d_taylor"
(or "hpfcla!hpcnof!d_taylor", with the first machine name being
expanded) or "d_taylor@hpfcla".  \fBmsg\fR will expand them
both in the same manner.
.P
As the song goes, check the alias guide...
.sp 2
.H 1 "Expert Mail Users and Debugging the Mailer"
.P
There are some additional facilities available in the
.I msg
mailer for those people who are knowledgable about 
mail protocols, or trying to debug/track down a 
problem.
.P
The 'h' command at the outermost level of the mailer
will display the current message ignoring the current
setting of the 'weed' option.  This is most useful
for answering questions of the form "I wonder what
this guy put in his header?" and such.  This command
does not show up on the mini-menu because it is somewhat
esoteric, but it DOES appear on the '?' help screen (can
you find it there?).
.P
The '@' command at the outermost level of the mailer
will output a screen of debugging information,
including the number of lines and 
offsets of each of the message in the current mailbox.
.P
The '#' command at the outermost level of the mailer
will display the entire stored 'record structure' for
the current message.
.P
The '%' command at the outermost level of the mailer
will display the full computed return address of the
current message.
.P
Starting up 
.I msg
with the "-d" debug option will create a file called
.B Msg.debug.info
in your home directory and contain a wealth of useful
information (to me, at least!) to aid in tracking down
what errors are occuring and why.  With this option
on, most everything acts the same with the exception
of when you get new mail while in the mailer - it will
indicate "New mail: N bytes" rather than the usual
"New mail has arrived...hang on...".
.sp
.P
If there are any problems with the mailer,  please try
to recreate the error with the debug option enabled
before sending defect reports my way.
.P
.sp
One final note: all error numbers reported by the program
are defined in the HP-UX Reference Manual in Errno(2).
.sp
.H 1 "Credits and so on"
.P
This mailer has been evolving over the past year or so with
some extremely valuable input from the following people at
Hewlett Packard;
Mark Laubach, Walt Underwood, Tw Cook, Larry Fenske, Rob Sartin,
and of course Carl Dierschow.
There have been many others, to numerous to mention, that
have inspired me with questions like "why can't the 
mailer..." or "why does it do that?"
.P
Also helpful was the ability to have my 'own' machine to 
close up the many many iterative loops that this software
has gone through - since being on a big multi-user machine
tends to slow it down to a standstill...
.P
Finally, it's also been a very useful experience overall,
confirming my beliefs that iterative software design and
keeping a close watch on users (not to mention an open
mind and mailbox!) improves a product manyfold.  
.P
Incidentally, this entire mail system, including this
documentation, is 
.nf

.ce
(C) Copyright 1986 Dave Taylor
END-OF-FILE

size=`wc -c < doc/Msg.guide`

if [ $size != 44850 ]
then
  echo Warning: doc/Msg.guide changed - should be 44850 bytes, not $size bytes
fi

chmod 644 doc/Msg.guide

if [ ! -d hdrs ]
then
  echo creating directory hdrs
  mkdir hdrs
fi

# ---------- file hdrs/curses.h ----------


if [ -f hdrs/curses.h ]
then
  echo File 'hdrs/curses.h' already exists\!
  exit 1
fi

echo extracting file hdrs/curses.h...
cat << 'END-OF-FILE' > hdrs/curses.h
/*** 			curses.h			***/

/*** (C) Copyright 1986 Dave Taylor			***/

     /*** Include file for seperate compilation.  ***/

#define OFF		0
#define ON 		1

int  InitScreen(),      /* This must be called before anything else!! */

     ClearScreen(), 	 CleartoEOLN(),

     MoveCursor(),       PutLine(),
     CursorUp(),         CursorDown(), 
     CursorLeft(),       CursorRight(), 

     StartBold(),        EndBold(), 
     StartUnderline(),   EndUnderline(), 
     StartHalfbright(),  EndHalfbright(),
     StartInverse(),     EndInverse(),
	
     transmit_functions(),

     Raw(),              ReadCh();

char *return_value_of();
END-OF-FILE

size=`wc -c < hdrs/curses.h`

if [ $size != 637 ]
then
  echo Warning: hdrs/curses.h changed - should be 637 bytes, not $size bytes
fi

chmod 644 hdrs/curses.h

# ---------- file hdrs/defs.h ----------


if [ -f hdrs/defs.h ]
then
  echo File 'hdrs/defs.h' already exists\!
  exit 1
fi

echo extracting file hdrs/defs.h...
cat << 'END-OF-FILE' > hdrs/defs.h
/**		defs.h			**/

/**  define file for msg mail system.  **/

/**  (C) Copyright 1985 Dave Taylor    **/

#include "sysdefs.h"	/* system/configurable defines */

#define VERSION		"3.2"	/* version number! */

#define SLEN		256	/* long for ensuring no overwrites... */
#define SHORT		5	/* super short strings!		      */
#define NLEN		20	/* name length for aliases            */
#define SHORT_SLEN      40
#define LONG_SLEN	250	/* for mail addresses from remote machines! */
#define LONG_STRING	500	/* even longer string for group expansion   */
#define VERY_LONG_STRING 2500	/* huge string for group alias expansion    */

#define BREAK		(char)  0	/* default interrupt    */
#define BACKSPACE	(char)  8	/* backspace character  */
#define TAB		(char)  9       /* tab character        */
#define RETURN		(char) 13	/* carriage return char */
#define LINE_FEED	(char) 10	/* line feed character  */
#define COMMA		','		/* comma character      */
#define SPACE		' '		/* space character      */
#define DOT		'.'		/* period/dot character */
#define BANG		'!'		/* exclaimation mark!   */
#define AT_SIGN		'@'		/* at-sign character    */
#define PERCENT		'%'		/* percent sign char.   */
#define ESCAPE		(char) 27	/* the escape		*/

#define STANDARD_INPUT  0		/* file number of stdin */

#ifndef TRUE
#define TRUE		1
#define FALSE		0
#endif

#define OUTGOING	0		/* defines for lock file   */
#define INCOMING	1		/* creation..see lock()    */

#define SH		0		/* defines for system_call */
#define USER_SHELL	1		/* to work correctly!      */

#define EXECUTE_ACCESS	01		/* for access() call 	   */
#define ACCESS_EXISTS	00		/* for access(2)           */

#define BIG_NUM		999999		/* big number!             */
#define BIGGER_NUM	9999999 	/* bigger number!          */

#define START_ENCODE	"[encode]"
#define END_ENCODE	"[clear]"

#define DONT_SAVE	"[no save]"

#define alias_file	".aliases"
#define group_file	".groups"
#define system_file	".systems"

#define JANUARY		0			/* months of the year */
#define FEBRUARY	1
#define MARCH		2
#define APRIL		3
#define MAY		4
#define JUNE		5
#define JULY		6
#define AUGUST		7
#define SEPTEMBER	8
#define OCTOBER		9
#define NOVEMBER	10
#define DECEMBER	11

#define equal(s,w)	(strcmp(s,w) == 0)
#define min(a,b)	a < b? a : b
#define ctrl(c)	        c - 'A' + 1	/* control character mapping */
#define plural(n)	n == 1 ? "" : "s"
#define lastch(s)	s[strlen(s)-1]
#define no_ret(s)	if (lastch(s) == '\n') lastch(s) = '\0' 
#define first_word(s,w) (strncmp(s,w, strlen(w)) == 0)
#define ClearLine(n)	MoveCursor(n,0); CleartoEOLN()
#define whitespace(c)	(c == ' ' || c == '\t')
#define quote(c)	(c == '"' || c == '\'') 
#define onoff(n)	(n == 0 ? "OFF" : "ON")

/** a few for the usage of function keys... **/

#define f1	1
#define f2	2
#define f3	3
#define f4	4
#define f5	5
#define f6	6
#define f7	7
#define f8	8

#define MAIN	0
#define ALIAS   1
#define YESNO	2
#define CHANGE  3
#define READ	4

/* wouldn't it be nice to have variable argument macros... */

#define dprint0(s)	     if (debug) { \
				fprintf(debugfile, s); fflush(debugfile); }
#define dprint1(s,a)	     if (debug) { \
				fprintf(debugfile, s, a);  fflush(debugfile); }
#define dprint2(s,a,b)	     if (debug) { \
			        fprintf(debugfile, s, a, b); fflush(debugfile);}
#define dprint3(s,a,b,c)     if (debug) { fprintf(debugfile, \
				s, a, b, c); fflush(debugfile); }
#define dprint4(s,a,b,c,d)   if (debug) { fprintf(debugfile, \
				s, a, b, c, d); fflush(debugfile); }
#define dprint5(s,a,b,c,d,e) if (debug) { fprintf(debugfile, \
			        s, a, b, c, d, e); fflush(debugfile); }

#define dprint6(s,a,b,c,d,e,f) if (debug) { fprintf(debugfile, \
			        s, a, b, c, d, e, f); fflush(debugfile); }

/* I guess this corrects it, though.  Wretched stuff though! */

struct date_rec {
	int  month;		/** this record stores a **/
	int  day;		/**   specific date and  **/
	int  year;		/**     time...		 **/
	int  hour;
	int  minute;
       };

struct header_rec {
	int  lines;		/** # of lines in the message  **/
	int  priority;		/** Urgent message?  (flag)    **/
	int  delete;		/** is message to be deleted?  **/
	long offset;		/** offset in bytes of message **/
	struct date_rec received; /** when msg received here   **/
	char from[SLEN];	/**   when 		       **/
	char dayname[8];	/**      the                   **/
	char month[10];		/**        message             **/
	char day[3];		/**          was 	       **/
	char year[5];		/**            sent            **/
	char time[NLEN];	/**              to you!       **/
	char subject[SLEN];    	/** The subject of the msg     **/
       };

struct alias_rec {
	char   name[NLEN];	/* alias name 			     */
	long   byte;		/* offset into data file for address */
       };

struct lsys_rec {
	char   name[NLEN];	/* name of machine connected to      */
	struct lsys_rec *next;	/* linked list pointer to next       */
       };

struct addr_rec {
	 char   address[NLEN];	/* machine!user you get mail as      */
	 struct addr_rec *next;	/* linked list pointer to next       */
	};
END-OF-FILE

size=`wc -c < hdrs/defs.h`

if [ $size != 5028 ]
then
  echo Warning: hdrs/defs.h changed - should be 5028 bytes, not $size bytes
fi

chmod 644 hdrs/defs.h

# ---------- file hdrs/headers.h ----------


if [ -f hdrs/headers.h ]
then
  echo File 'hdrs/headers.h' already exists\!
  exit 1
fi

echo extracting file hdrs/headers.h...
cat << 'END-OF-FILE' > hdrs/headers.h
/**		headers.h		**/

/**  header file for msg mail system.  **/

/**  (C) Copyright 1985, Dave Taylor   **/

#include <stdio.h>
#include <fcntl.h>

#include "curses.h"
#include "defs.h"

/******** global variables accessable by all pieces of the program *******/

extern int current;		/* current message number  */
extern int header_page;         /* current header page     */
extern int last_header_page;    /* last header page        */
extern int message_count;	/* max message number      */
extern int total_lines_in_file;	/* number of lines in file */
extern int headers_per_page;	/* number of headers/page  */
extern char infile[SLEN];	/* name of current mailbox */
extern char hostname[SLEN];	/* name of machine we're on*/
extern char username[SLEN];	/* return address name!    */
extern char full_username[SLEN];/* Full username - gecos   */
extern char home[SLEN];		/* home directory of user  */
extern char folders[SLEN];	/* folder home directory   */
extern char mailbox[SLEN];	/* mailbox name if defined */
extern char editor[SLEN];	/* default editor for mail */
extern char printout[SLEN];	/* how to print messages   */
extern char savefile[SLEN];	/* name of file to save to */
extern char prefixchars[SLEN];	/* prefix char(s) for msgs */
extern char shell[SLEN];	/* default system shell    */
extern char batch_subject[SLEN];/* subject buffer for batchmail */

extern char start_highlight[SLEN],
	    end_highlight[SLEN]; /* to delimit urgent messages */

extern char backspace,		/* the current backspace char  */
	    kill_line;		/* the current kill_line char  */

extern char up[SHORT], 
	    down[SHORT];	/* cursor control seq's    */
extern int  cursor_control;	/* cursor control avail?   */


/** the following two are for arbitrary weedout lists.. **/

extern char weedlist[MAX_IN_WEEDLIST][NLEN];
extern int  weedcount;		/* how many headers to check?        */

extern int  file_changed;	/* flag: true iff infile changed      */
extern int  mini_menu;		/* flag: display menu?     	      */
extern int  mbox_specified;     /* flag: specified alternate mailbox? */
extern int  check_first;	/* flag: verify mail to be sent!      */
extern int  auto_copy;		/* flag: auto copy source into reply? */
extern int  filter;		/* flag: weed out header lines?	      */
extern int  resolve_mode;	/* flag: resolve before moving mode?  */
extern int  auto_cc;		/* flag: mail copy to yourself?       */
extern int  noheader;		/* flag: copy + header to file?       */
extern int  title_messages;	/* flag: title message display?       */
extern int  edit_outbound;	/* flag: edit outbound headers?       */
extern int  read_aliases;	/* flag: read in alias files??	      */
extern int  hp_terminal;	/* flag: are we on an hp terminal?    */
extern int  hp_softkeys;	/* flag: are there softkeys?          */
extern int  save_by_name;  	/* flag: save mail by login name?     */
extern int  notesfile;		/* flag: is input file from notes?    */
extern int  mail_only;		/* flag: send mail then leave?        */
extern int  check_only;		/* flag: check aliases and leave?     */
extern int  move_when_paged;	/* flag: move when '+' or '-' used?   */

extern int debug;		/** debugging mode on?  **/

extern int mailbox_defined;	/** specified mailbox?  **/

extern int LINES;		/** lines per screen    **/
extern int COLUMNS;		/** columns per line    **/

extern int size_of_pathfd;	/** size of pathfile, 0 if none **/

extern FILE *mailfile;		/* current mailbox file    */
extern FILE *debugfile;		/* file for debut output   */
extern FILE *pathfd;		/* path alias file         */

extern struct header_rec header_table[MAX_HEADERS];

extern struct alias_rec user_hash_table  [MAX_UALIASES];
extern struct alias_rec system_hash_table[MAX_SALIASES];

extern struct date_rec last_read_mail;

extern struct lsys_rec *talk_to_sys;	/* who do we talk to? */

extern struct addr_rec *alternative_addresses;	/* how else do we get mail? */

extern int system_files;	/* do we have system aliases? */
extern int user_files;		/* do we have user aliases?   */

extern int system_data;		/* fileno of system data file */
extern int user_data;		/* fileno of user data file   */

extern int userid;		/* uid for current user	      */
extern int progid;		/* euid for program	      */
END-OF-FILE

size=`wc -c < hdrs/headers.h`

if [ $size != 4253 ]
then
  echo Warning: hdrs/headers.h changed - should be 4253 bytes, not $size bytes
fi

chmod 644 hdrs/headers.h

# ---------- file hdrs/msg.h ----------


if [ -f hdrs/msg.h ]
then
  echo File 'hdrs/msg.h' already exists\!
  exit 1
fi

echo extracting file hdrs/msg.h...
cat << 'END-OF-FILE' > hdrs/msg.h
/**		msg.h			**/

/**  header file for msg mail system.  **/

/**  (C) Copyright 1986, Dave Taylor   **/

#include <stdio.h>
#include <fcntl.h>

#include "../hdrs/curses.h"
#include "../hdrs/defs.h"

/******** static character string containing the copyright notice  *******/

static char copyright[] = { "(C) Copyright 1986, Dave Taylor" };

/******** global variables accessable by all pieces of the program *******/

int current = 0;		/* current message number  */
int header_page = 0;     	/* current header page     */
int last_header_page = -1;     	/* last header page        */
int message_count = 0;		/* max message number      */
int total_lines_in_file;    	/* number of lines in file */
int headers_per_page;		/* number of headers/page  */
char infile[SLEN];		/* name of current mailbox */
char hostname[SLEN];		/* name of machine we're on*/
char username[SLEN];		/* return address name!    */
char full_username[SLEN];	/* Full username - gecos   */
char home[SLEN];		/* home directory of user  */
char folders[SLEN];		/* folder home directory   */
char mailbox[SLEN];		/* mailbox name if defined */
char editor[SLEN];		/* editor for outgoing mail*/
char printout[SLEN];		/* how to print messages   */
char savefile[SLEN];		/* name of file to save to */
char prefixchars[SLEN];		/* prefix char(s) for msgs */
char shell[SLEN];		/* current system shell    */
char batch_subject[SLEN];	/* subject buffer for batchmail */

char start_highlight[SLEN],
     end_highlight[SLEN];	/* to delimit urgent msgs  */

char backspace,			/* the current backspace char */
     kill_line;			/* the current kill-line char */

char up[SHORT], down[SHORT];	/* cursor control seq's    */
int  cursor_control = FALSE;	/* cursor control avail?   */

char weedlist[MAX_IN_WEEDLIST][NLEN];
int  weedcount;

int file_changed = 0;		/* flag: true if infile changed     */
int mini_menu = 1;		/* flag: menu specified?	    */
int mbox_specified = 0;		/* flag: specified alternate mbox?  */
int check_first = 1;		/* flag: verify mail to be sent!    */
int auto_copy = 0;		/* flag: automatically copy source? */
int filter = 0;			/* flag: weed out header lines?	    */
int resolve_mode = 1;		/* flag: delete saved mail?	    */
int auto_cc = 0;		/* flag: mail copy to user?	    */
int noheader = 0;		/* flag: copy + header to file?     */
int title_messages = 0;		/* flag: title message display?     */
int edit_outbound = 0;		/* flag: edit outbound headers?	    */
int read_aliases = 1;		/* flag: read in alias files?	    */
int hp_terminal = 0;		/* flag: are we on HP term?	    */
int hp_softkeys = 0;		/* flag: are there softkeys?        */
int save_by_name = 0;		/* flag: save mail by login name?   */
int notesfile = 0;		/* flag: is input file from notes?  */
int mail_only = 0;		/* flag: send mail then leave?      */
int check_only = 0;		/* flag: check aliases then leave?  */
int move_when_paged = 0;	/* flag: move when '+' or '-' used? */

int debug = 0; 			/** default is no debug! **/

int mailbox_defined = 0;	/** mailbox specified?    **/

int LINES=23;			/** lines per screen      **/
int COLUMNS=80;			/** columns per page      **/

int size_of_pathfd;		/** size of pathfile, 0 if none **/

FILE *mailfile;			/* current mailbox file    */
FILE *debugfile;		/* file for debug output   */
FILE *pathfd;			/* path alias file         */

struct header_rec header_table[MAX_HEADERS];

struct alias_rec user_hash_table[MAX_UALIASES];
struct alias_rec system_hash_table[MAX_SALIASES];

struct date_rec last_read_mail; /* last time we read mailbox  */

struct lsys_rec *talk_to_sys;   /* what machines do we talk to? */

struct addr_rec *alternative_addresses;	/* how else do we get mail? */

int system_files = 0;		/* do we have system aliases? */
int user_files = 0;		/* do we have user aliases?   */

int system_data;		/* fileno of system data file */
int user_data;			/* fileno of user data file   */

int userid;			/* uid for current user	      */
int progid;			/* euid for program	      */
END-OF-FILE

size=`wc -c < hdrs/msg.h`

if [ $size != 3982 ]
then
  echo Warning: hdrs/msg.h changed - should be 3982 bytes, not $size bytes
fi

chmod 644 hdrs/msg.h

# ---------- file hdrs/sysdefs.h ----------


if [ -f hdrs/sysdefs.h ]
then
  echo File 'hdrs/sysdefs.h' already exists\!
  exit 1
fi

echo extracting file hdrs/sysdefs.h...
cat << 'END-OF-FILE' > hdrs/sysdefs.h
/**			sysdefs.h			**/

/**  System level, configurable, defines for the MSG mail system.  **/

/**  (C) Copyright 1986 Dave Taylor                                **/

/** define the following if you think that the information in messages
    that have "Reply-To:" and/or "From:" fields with addresses will
    contain valid addressing information.  If this isn't defined, the
    calculated return address will ALWAYS be used instead.  (note that
    this doesn't necessarily proclude the use of G)roup replies).

#define USE_EMBEDDED_ADDRESSES	

**/

#define FIND_DELTA	10		/* byte region where the binary search
					   on the path alias file is fruitless 
                                           (can't be within this boundary)    */

#define MAX_HEADERS	500	/* max number of messages in one file!   */	
#define MAX_SALIASES	503	/* number of system aliases allowed      */
#define MAX_UALIASES	251	/* number of user aliases allowed 	 */
#define MAX_IN_WEEDLIST 50	/* max headers to weed out               */

#define MAX_HOPS	35	/* max hops in return addr to E)veryone  */

#define MAX_ATTEMPTS	6	/* #times to attempt lock file creation */

/** see leavembox.c to determine if this should be defined or not....The 
    default is to NOT have it defined.

#define REMOVE_AT_LAST

**/

#define DEFAULT_BATCH_SUBJECT  "no subject (file transmission)"

/** If you want to have the mailer know about valid mailboxes on the
    host machine (assumes no delivery agent aliases) then you should
    undefine this (the default is to have it defined)...

#define NOCHECK_VALIDNAME

**/

#define NOTES_HEADER		"/***** "
#define NOTES_FOOTER		"/* ---------- */"

#ifdef BSD
# define system_hash_file	"/usr/spool/mail/.alias_hash"
# define system_data_file	"/usr/spool/mail/.alias_data"
#else
# define system_hash_file	"/usr/mail/.alias_hash"
# define system_data_file	"/usr/mail/.alias_data"
#endif

#define pathfile		"/usr/lib/nmail.paths"

#define Lsys			"/usr/lib/uucp/L.sys"

/** where to put the output of the msg -d command... (in home dir) **/
#define DEBUG		"Msg.debug.info"

#define temp_file	"/tmp/snd."
#define temp_mbox	"/tmp/mbox."
#define temp_print      "/tmp/print."
#define mailtime_file	".last_read_mail"

#ifdef BSD
# define default_editor	"/usr/ucb/vi"
# define mailhome	"/usr/spool/mail/"
#else
# define default_editor	"/usr/bin/vi"
# define mailhome	"/usr/mail/"
#endif

#define sendmail	"/usr/lib/sendmail"
#define sendmailflags	"-oi"
#define mailer		"/bin/rmail"
#define mailx		"/usr/bin/mailx"

#define cutfile		"/usr/local/bin/cutfile"

#define helphome	"/usr/local/lib/"
#define helpfile	"msg-help.main"

#define msgrcfile	"/.msgrc"
#define mailheaders	".msgheaders"
#define unedited_mail	"emergency.mbox"
#define newalias	"newalias 1>&2 > /dev/null"

#define remove		"/bin/rm -f"		/* how to remove a file */
#define cat		"/bin/cat"		/* how to display files */
END-OF-FILE

size=`wc -c < hdrs/sysdefs.h`

if [ $size != 2882 ]
then
  echo Warning: hdrs/sysdefs.h changed - should be 2882 bytes, not $size bytes
fi

chmod 644 hdrs/sysdefs.h

echo done

exit 0




