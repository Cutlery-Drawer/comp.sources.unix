From: decvax!hplabs!hpcnou!dat (Dave Taylor)
Subject: Msg Shar.part.1
Newsgroups: mod.sources
Approved: jpn@panda.UUCP

Mod.sources:  Volume 4, Issue 5
Submitted by: decvax!hplabs!hpcnou!dat (Dave Taylor)

# Msg Shar part 1 of 7

# Shell Archive created by hpcnou!dat at Wed Feb 26 15:55:39 1986

# To unpack the enclosed files, please use this file as input to the
# Bourne (sh) shell.  This can be most easily done by the command;
#     sh < thisfilename

# This archive contains;
#  Overview         Instructions        Makefile            README
#  bin/makelisting  doc/Config.guide    doc/answer.1        doc/autoreply.1
#  doc/checkalias.1 doc/fastmail.1      doc/from.1          doc/msg.1
#  doc/newalias.1   doc/newmail.1       doc/printmail.1     doc/readmsg.1
#  doc/helpfile     doc/msgrc.sample


# ---------- file Overview ----------


if [ -f Overview ]
then
  echo File 'Overview' already exists\!
  exit 1
fi

echo extracting file Overview...
cat << 'END-OF-FILE' > Overview
			An Overview of the Msg Mail System
			----------------------------------

Introduction

	This file discusses the functionality of the Msg mail system
and explains some of the motivation behind the creation and of various
features.

1. What is Msg?

	Currently on Unix, there seems to be a preponderence of line-oriented 
software.  This is most unfortunate as most of the software on Unix tends to
be pretty darn hard to use!  I believe that there is more than a slight
correlation between the two, and, since I was myself having problems using
"mailx" with high-volume mail, I created a new mail system.

	In the lingo of the mail guru, Msg is a "User Agent" system,  it's
designed to run with "sendmail" or "/bin/rmail" (according to what's on
your system) and is a full replacement of programs like "/bin/mail" and
"mailx".  The system is more than just a single program, however, and
includes programs like "from" to list a 'table of contents' of your
mail, "printmail" to quickly paginate mail files (to allow 'clean'
printouts), and "autoreply", a systemwide daemon that can autoanswer
mail for people while they're on vacation without having multiple
copies spawned on the system.

2. What's New about Msg?

	The most significant difference between Msg and earlier mail
systems is that Msg is screen-oriented.  Upon further use, however,
users will find that Msg is also quite a bit easier to use, and quite
a bit more "intelligent" about sending mail and so on.   For example,
say you're on "usenet" and receive a message from someone on the
ARPANET.  The sender also "cc'd" another person on ARPA.  With Msg
you can simply G)roup reply and it will build the correct return
addresses.

	There are lots of subtleties like that in the program, most of
which you'll probably find when you need them.

3. What systems does it work on?

	Msg was originally written on HP-UX, HP's proprietary version
of Bell system V, with a little BSD thrown in.  Since then, it has been
ported to Bell and Berkeley, and should run on both systems without any
modifications (if there turn out to be modifications, please notify the
author as soon as possible).

	Some people have expressed interest in porting the mail system
to Xenix.  If it is indeed 100% system V compatible it should be rather
trivial...

4. Does it obey existing mail standards?

	Yes!  That's another of the basic reasons the program was 
originally written!  To ensure that the date field, the "From:" line
and so on were all added in the correct format.  The program is 100%
correct according to the RFC-822 electronic mail header protocol
guide.

5. What were the main motivating factors?

	The first two I've already mentioned, but here's a (somewhat
partial) list;

	-  To have a mail system that exploited the CRT instead of
	   assuming I'm on a teletype.

	- To have a mailer that was 100% correct when dealing with	 
	  network mail (ie RFC-822).

	- To create a system that needed no documentation for the
	  casual user, but was still powerful enough and sophisticated
	  enough for a mail expert.

	- To write a "significant" piece of software as a learning
	  experience (I admit it!)

	- To find out how reasonable it is to try to modify a program
	  to meet the expectations of the users, rather than vice-versa.

	- To basically correct some of the dumb things that the current
	  mailers do, like letting you send mail to addresses that it
	  could trivially figure out are going to result in 'dead.letter'

	- To tie in intimately with the pathalias program output, and
	  allow users to specify machine!user or user@machine and have
	  the COMPUTER do the work of figuring out addresses...

6. Is it reliable?

	The mailer, in various incarnations, has logged literally
thousands upon thousands of hours without any problems that aren't
now corrected.  As new problems arise they're dealt with in as
rapid a manner as possible...

7. What should I do now?

	The first step would be to install the mail system and have
the "msg" mailbox/alias expand to my email address (hpfcla!d_taylor).
Then, once it's all up and running, drop me a line letting me know
that your site is running the system (bookkeeping) and what you and
your site think of it.

	REMEMBER: The product is evolving so if you'd like to have a
something change, or have something new added, LET ME KNOW!!!  I'd 
much rather make the change myself than start getting change reports
mailed from around the world!!

8. Disclaimers 

	The author of this program will deny all liability for any
damages, either real or imagined, due to the execution of this program
or anything related to either the software or the system.  Furthermore,
the entire system and all source within, including the presentation
screens and commands, are legally copyrighted by the author, and while
they can be used, and abused for public domain systems, will be in 
violation of the law if used in systems or programs sold for profit.

	By installing the mailer or even extracting it from the network,
you are agreeing to the above disclaimer.

9. Finally

	I think it's a good program, and I can cite at least 75 people
who would (begrudgingly, I'm sure) agree.  You should most certainly
install the program and try it!!



				-- Dave Taylor
				
				hplabs!hpfcla!d_taylor

February 12th, 1986
END-OF-FILE

size=`wc -c < Overview`

if [ $size != 5319 ]
then
  echo Warning: Overview changed - should be 5319 bytes, not $size bytes
fi

chmod 644 Overview

# ---------- file Instructions ----------


if [ -f Instructions ]
then
  echo File 'Instructions' already exists\!
  exit 1
fi

echo extracting file Instructions...
cat << 'END-OF-FILE' > Instructions

				Instructions
				------------

			Last Update: January 14th, 1986


	This file contains instructions on how to create and install
the entire MSG mail system.  It should be read BEFORE any attempts
are made at actually creating and/or installing any of the software
contained herein!

	First off, you'll need to create the documents so that you
can read the "MSG Configuration Guide" and configure the system
correctly for your local site needs...

	$ make documentation

This will create two documents - the "Msg Users Guide", and the "Msg
Configuration Guide".  For our purposes, you're only interested in the 
configuration guide, so at this point print out the file 

		"doc/Config.fmtd" 

and then continue reading with that document.

--------

I assume you've read and followed the directions in the Configuration
guide if you're back here!  If not, GO DO IT!!!

--------

Try again - ready?

Okay.  Now that we've configured the MSG system so that it will all
be happy with the file locations, node type, memory requirements,
and so on of your system we can actually try to make the system!

The first step is to edit the Makefile so that the define for the
macro "DEFINE" is correct for your OS.  The choices are "BSD", "UTS"
or the default of Bell/HP-UX.

When you're done, type:

	$ make all

This will take a fair while, so it's recommended that you go and eat 
lunch or play a game for a while!! 

Assuming there are no errors during compilation (we'll have to assume
that for the moment) you should now be able to list the directory "bin"
and find the following files:

  "answer", "arepdaemon", "autoreply", "cutfile", "fastmail", "from", 
  "msg", "newalias", "newmail", "printmail", "readmsg" and "snd"

at this point you need to check the system level Makefile (in this
directory) to check that the defines for the following are correct
for your system:

	TAPE=   /dev/rct
	DEST=   /usr/local/bin
	LIB=    /usr/local/lib
	MAN=	/usr/man/man1

(these are the Bell System V defaults, more or less).  Once they're 
altered to your satisfaction, you can install all the software by
becoming root on your machine (you'll need write permission to the
directories above) then typing:

	$ make install
	
When this is done:
	
	$ cd /usr/local/bin

(or wherever you changed DEST in the makefile to) then typing:

	$ chown root msg
	$ chmod 4755 msg

This is because the mailer has to have the ability to CREATE new
files in the "mailhome" directory.  If it doesn't have this 
permission, it will immediately fail upon invokation, telling
you that it wants that permission.   

Note to System Administrators:  As an administrator of a single
user and 25 user Unix system, I am aware of the potential dangers
that a setuid root program pose.  However, great cares have been
taken to remove any possibility of raising a ruckus with the
added privileges.   (check src/syscall.c for example)  If any
problems do arise PLEASE LET ME KNOW!!!

Finally, we're just about done!   The final checks can be made
by the following commands:

	$ /usr/local/bin/msg -z

should say "no mail" if nothing's in the mailbox

	$ /usr/local/bin/msg -f test/test.mail

should read in EIGHT messages from various people.  While here, try to
A)lias C)urrent message for each of the eight messages to confirm that
the reply/address system is working okay.   Now try to C)hange mailboxes
to the file "test/test.note" and use the '%' key to see if the mailer is
generating valid return addresses for the notes (If not, then you might
need to install the pathalias database - see "sysdefs.h" for more info)
Change back to "test/test.mail" and Q)uit without having marked anything 
for deletion...answer the questions accordingly.

If you get this far you're in Wonderful shape!  In fact, you're done!

Congratulations!  You've just installed one of the best electronic mail
systems available today on your machine (if I say so myself!)

HANDY HINTS:  If you want to create a print of the entire set of
sources, including this file, use the command:

	$ make listing

If, on the other hand, you just want to create a listing file of 
just the MSG sources, try:

	$ make msg-listing

Also, if you have a number of machines on a network, you can rlogin
to the remote machine and then do a remote install (after checking
to ensure that the networking copy method in the Makefile under the
target "remote-install" is correct) by typing:

	$ make -f <remote Makefile> REMOTE=<remote file system> rmt-install

(for example, if we had installed the system on machine "machx" and 
 wanted to install it on "machy", with the Makefile in /src/Msg on
 "machx", we could type from "machy";
	 $ make -f machx:/src/Msg/Makefile REMOTE=machx: rmt-install
 to have it install the system on machine y!)

That's it!
----------

	Author's address:	hpcnof!dat@HPLABS
				ihnp4!hpfcla!d_taylor

	Mail address:		Dave Taylor
				Hewlett Packard - CNO (MS 102)
				3404 East Harmony Road
				Fort Collins CO
				80525

	phone:		(work)  (303) 229-2419


  This document and the entire mail system is

	(C) Copyright 1986, Dave Taylor
END-OF-FILE

size=`wc -c < Instructions`

if [ $size != 5088 ]
then
  echo Warning: Instructions changed - should be 5088 bytes, not $size bytes
fi

chmod 644 Instructions

# ---------- file Makefile ----------


if [ -f Makefile ]
then
  echo File 'Makefile' already exists\!
  exit 1
fi

echo extracting file Makefile...
cat << 'END-OF-FILE' > Makefile
#
#  Makefile for the entire MSG mail system
#
#         (C) Copyright 1986, Dave Taylor
#
#  Last modification: February 12th, 1986
 
#########################
#
# The following entries need to be customized for the local site:  
#    The first is the address of the data-cassette drive to allow
# easy tape copies to be made, and the second is the final location 
# that all the software should be installed in when 'make install'
# is run.
#
#########################

TAPE=   /dev/rct
DEST=   /usr/local/bin

LIB=    /usr/local/lib
MAN=	/usr/man/man1
CATMAN=/usr/man/cat1
SHAR=   /usr/local/bin/shar

# if on a Berkeley system:
# DEFINE = -DBSD
# else if on a UTS system:
# DEFINE = -DUTS
# otherwise;
DEFINE=

#########################

LIBS=   -ltermcap
CFLAGS= -O
CC=	/bin/cc
RM=	/bin/rm -f
MV=     /bin/mv
CP=	/bin/cp

DOCS=   Config.guide Msg.guide README msg.1 from.1 \
	printmail.1 newalias.1 newmail.1 answer.1 \
	grabalias.1 fastmail.1 readmsg.1 autoreply.1

UTILSRC=utils/newmail.c utils/answer.c utils/from.c 	        \
	utils/readmsg.c utils/printmail.c utils/newalias.c 	\
	utils/fastmail.c utils/cutfile.c utils/arepdaemon.c	\
	utils/autoreply.c

MSGSRC=	src/addr_utils.c src/alias.c src/aliasdb.c src/aliaslib.c src/args.c  \
        src/curses.c src/date.c src/delete.c src/encode.c src/file.c          \
	src/file_utils.c src/fileio.c src/hdrconfg.c src/help.c 	      \
	src/initialize.c src/input_utils.c src/mailout.c src/mailtime.c       \
	src/mkhdrs.c src/msg.c src/newmbox.c src/notesfile.c  \
	src/output_utils.c src/pattern.c src/quit.c src/read_rc.c src/reply.c \
	src/return_addr.c src/screen.c src/showmsg.c src/strings.c 	      \
	src/syscall.c src/utils.c src/validname.c src/savecopy.c

################

all:	documentation msg utils
	@echo Everything is up to date!

documentation:  doc/Msg.guide.fmtd  doc/Config.fmtd
	
doc/Msg.guide.fmtd: doc/Msg.guide
	nroff -mm doc/Msg.guide > doc/Msg.guide.fmtd

doc/Config.fmtd:  doc/Config.guide
	nroff -mm doc/Config.guide > doc/Config.fmtd

bin/msg: ${MSGSRC}
	cd src; make DEFINE=${DEFINE} msg; cd ..
	
bin/utils: ${UTILSRC}
	cd utils; make all; cd ..
	@touch bin/utils

install: all
	${MV} bin/msg          ${DEST}/msg
	${MV} bin/from         ${DEST}/from
	${MV} bin/newalias     ${DEST}/newalias
	${MV} bin/printmail    ${DEST}/printmail
	${MV} bin/fastmail     ${DEST}/fastmail
	${MV} bin/readmsg      ${DEST}/readmsg
	${MV} bin/newmail      ${DEST}/newmail
	${MV} bin/cutfile      ${DEST}/cutfile
	${MV} bin/checkalias   ${DEST}/checkalias
	${MV} bin/arepdaemon   ${DEST}/arepdaemon
	${MV} bin/autoreply    ${DEST}/autoreply
	${RM} ${CATMAN}/msg.1 ${CATMAN}/from.1 ${CATMAN}/newalias.1 \
	      ${CATMAN}/printmail.1 ${CATMAN}/fastmail.1 ${CATMAN}/msg.1 \
	      ${CATMAN}/checkalias.1 ${CATMAN}/autoreply.1
	${CP} doc/msg.1        ${MAN}/msg.1
	${CP} doc/from.1       ${MAN}/from.1
	${CP} doc/newalias.1   ${MAN}/newalias.1
	${CP} doc/printmail.1  ${MAN}/printmail.1
	${CP} doc/fastmail.1   ${MAN}/fastmail.1
	${CP} doc/checkalias.1 ${MAN}/checkalias.1
	${CP} doc/autoreply.1  ${MAN}/autoreply.1
	${CP} doc/helpfile     ${LIB}/msg-help.main
	chmod a+rx ${DEST}/from ${DEST}/newalias ${DEST}/printmail \
	           ${DEST}/fastmail ${DEST}/readmsg ${DEST}/cutfile \
		   ${DEST}/checkalias ${DEST}/autoreply
	chown root ${DEST}/msg
	chmod 4755 ${DEST}/msg
	@echo Done with installation.

rmt-install: remote-defined
	@echo " "
	@echo Warning: This assumes "install" has been done on the
	@echo "         remote machine.  If this is not the case you"
	@echo "         better hit BREAK quickly!"
	@echo " "
	${CP} ${REMOTE}${DEST}/msg          ${DEST}/msg
	${CP} ${REMOTE}${DEST}/from         ${DEST}/from
	${CP} ${REMOTE}${DEST}/newalias     ${DEST}/newalias
	${CP} ${REMOTE}${DEST}/printmail    ${DEST}/printmail
	${CP} ${REMOTE}${DEST}/fastmail     ${DEST}/fastmail
	${CP} ${REMOTE}${DEST}/readmsg      ${DEST}/readmsg
	${CP} ${REMOTE}${DEST}/newmail      ${DEST}/newmail
	${CP} ${REMOTE}${DEST}/cutfile      ${DEST}/cutfile
	${CP} ${REMOTE}${DEST}/checkalias   ${DEST}/checkalias
	${CP} ${REMOTE}${DEST}/arepdaemon   ${DEST}/arepdaemon
	${CP} ${REMOTE}${DEST}/autoreply    ${DEST}/autoreply
	${RM} ${CATMAN}/msg.1 \
	      ${CATMAN}/from.1 \
              ${CATMAN}/newalias.1 \
	      ${CATMAN}/printmail.1 \
	      ${CATMAN}/fastmail.1 \
              ${CATMAN}/checkalias.1 \
              ${CATMAN}/autoreply.1 \
              ${CATMAN}/msg.1
	${CP} ${REMOTE}${MAN}/msg.1        ${MAN}/msg.1
	${CP} ${REMOTE}${MAN}/from.1       ${MAN}/from.1
	${CP} ${REMOTE}${MAN}/newalias.1   ${MAN}/newalias.1
	${CP} ${REMOTE}${MAN}/printmail.1  ${MAN}/printmail.1
	${CP} ${REMOTE}${MAN}/fastmail.1   ${MAN}/fastmail.1
	${CP} ${REMOTE}${MAN}/checkalias.1 ${MAN}/checkalias.1
	${CP} ${REMOTE}${MAN}/autoreply.1  ${MAN}/autoreply.1
	${CP} ${REMOTE}${LIB}/helpfile     ${LIB}/msg-help.main
	chmod a+rx ${DEST}/from ${DEST}/newalias ${DEST}/printmail \
	           ${DEST}/fastmail ${DEST}/readmsg ${DEST}/cutfile \
		   ${DEST}/checkalias ${DEST}/autoreply
	chown root ${DEST}/msg
	chmod 4755 ${DEST}/msg
	@echo everything is installed based on files from ${REMOTE}

source: 
	tar cvf ${TAPE} bin/makelisting utils/*.c src/*.c doc/* hdrs/* \
	Instructions Makefile README utils/Makefile src/Makefile test/*

shar:   
	@echo \\nMaking Part One...
	${SHAR} Overview Instructions Makefile README \
	     bin/makelisting doc/Config.guide doc/*.1 doc/helpfile \
	     doc/msgrc.sample
	@rm -f Shar.part.1
	@/bin/echo \\n# Msg Shar part 1 of 7 | cat - Shell-Archive > Shar.part.1
	@echo \\nMaking Part Two...
	${SHAR} doc/Msg.guide hdrs/*.h
	@rm -f Shar.part.2
	@/bin/echo \\n# Msg Shar part 2 of 7 | cat - Shell-Archive > Shar.part.2
	@echo \\nMaking Part Three...
	${SHAR} src/[a-e]*.c src/file.c
	@rm -f Shar.part.3
	@/bin/echo \\n# Msg Shar part 3 of 7 | cat - Shell-Archive > Shar.part.3
	@echo \\nMaking Part Four...
	${SHAR} src/file?*.c src/[g-m]*.c 
	@rm -f Shar.part.4
	@/bin/echo \\n# Msg Shar part 4 of 7 | cat - Shell-Archive > Shar.part.4
	@echo \\nMaking Part Five...
	${SHAR} src/n[n-z]*.c src/[o-r]*.c src/s[a-q]*.c
	@rm -f Shar.part.5
	@/bin/echo \\n# Msg Shar part 5 of 7 | cat - Shell-Archive > Shar.part.5
	@echo \\nMaking Part Six...
	${SHAR} src/n[a-m]*.c src/s[r-z]*.c src/[t-z]*.c src/Makefile \
		utils/a*.c
	@rm -f Shar.part.6
	@/bin/echo \\n# Msg Shar part 6 of 7 | cat - Shell-Archive > Shar.part.6
	@echo \\nMaking Part Seven...
	${SHAR} utils/[b-z]*.c utils/Makefile test/test.*
	@rm -f Shar.part.7
	@/bin/echo \\n# Msg Shar part 7 of 7 | cat - Shell-Archive > Shar.part.7
	@rm -f Shell-Archive
	@echo ' '
	@echo Created shar files one through seven \(Shar.part.\<n\>\)

lint:
	lint ${UTILSRC} > lint.out

listing:
	@echo listing all source files 
	@/bin/echo \\f > LISTING
	@echo adding README...
	@cat README >> LISTING
	@/bin/echo \\f >> LISTING
	@echo adding Instructions...
	@cat Instructions >> LISTING
	@bin/makelisting Makefile ${UTILSRC} src/Makefile src/*.c hdrs/*.h
	@echo LISTING generated.

msg-listing: 
	@echo listing just the MSG system source files
	@echo ' ' > src/LISTING
	@cd src ; make listing ; cd ..
	@echo LISTING generated \(in directory /src\).

clean:
	@cd src ; make clean ; cd ..
	@cd utils; make clean ; cd ..
	@echo All spurious files removed

msg: bin/msg
utils: bin/utils
utils/checkalias:
doc/Msg.guide:
doc/Config.guide:

remote-defined:
	@if ( "${REMOTE}" == "" ) then; \
	   echo " " ; \
	   echo "You need to define 'REMOTE' as the remote file system" ; \
	   echo "for this particular command.   The easiest way to do " ; \
	   echo "this is to type:" ;\
	   echo "    make -f <makefile> REMOTE=<remote file system> rmt-install" ; \
	   echo " " ; \
	 endif
	@if ( "${REMOTE}" == "" ) exit 1
END-OF-FILE

size=`wc -c < Makefile`

if [ $size != 7730 ]
then
  echo Warning: Makefile changed - should be 7730 bytes, not $size bytes
fi

chmod 644 Makefile

# ---------- file README ----------


if [ -f README ]
then
  echo File 'README' already exists\!
  exit 1
fi

echo extracting file README...
cat << 'END-OF-FILE' > README
				MSG 3.1

Files contained within this release are;

Instructions	-  how to make the entire system
Makefile	-  entire system make file
README          -  this file

in directory "bin"
  makelisting	-  tool to help create nice listings

in directory "doc"
  Alias.guide   -  A short guide on using the alias system
  Config.guide	-  A Guide on how to configure the MSG system
  Msg.guide	-  The Users guide on the mail system
  answer.1	-  The manual entry for the 'answer' command
  autoreply.1	-  The manual entry for the 'autoreply' command
  checkalias.1	-  The manual entry for the 'checkalias' command
  fastmail.1	-  The manual entry for the 'fastmail' command
  from.1	-  The manual entry for the 'from' command
  helpfile	-  The MSG system main helpfile
  msg.1		-  The manual entry for the 'msg' command
  msgrc.sample	-  A sample '.msgrc' file for reference
  newalias.1	-  The manual entry for the 'newalias' command
  newmail.1	-  The manual entry for the 'newmail' command
  printmail.1	-  The manual entry for the 'prntmail' command
  readmsg.1	-  The manual entry for the 'readmsg' command
  snd.1		-  The manual entry for the 'snd' command
  	
in directory "hdrs"
  curses.h	-  Include file for the cursor control library
  defs.h	-  Generic defines,  stuff like string lengths
  headers.h	-  External routine global variable defs
  msg.h		-  Main routine global variable defs
  sysdefs.h	-  System dependent defines.   Alter for your site!

in directory "src"
  Makefile	-  The make file for the MSG mailer itself...
  addr_utils.c  -  Utilities for manipulating addresses
  alias.c	-  The main alias routines
  aliasdb.c	-  The alias database (pathalias) routines
  aliaslib.c	-  Utility routines for the alias routines
  args.c	-  Starting arguments parsing routines
  curses.c	-  The cursor control package
  date.c	-  Routines that deal with dates and/or times
  delete.c	-  Delete message routines
  encode.c	-  Crypt/decrypt routines
  file.c	-  File related commands
  file_utils.c	-  Utilities to do with files
  fileio.c	-  Reading and/or writing files
  hdrconfg.c	-  Edit message headers on outbound mail
  help.c	-  Help routine
  initialize.c  -  Initialize the system
  input_utils.c -  Utilities for data (keyboard) input
  mailout.c     -  Send a message
  mailtime.c    -  When did we last read mail and so on
  mkhdrs.c      -  Create outgoing message headers 
  msg.c	        -  The main program!
  newmbox.c	-  Read in a new mailbox
  notesfile.c   -  Notes-related routines
  options.c     -  Alter options
  output_utils.c-  Utilities for data (screen) output
  pattern.c     -  Pattern matching routines
  quit.c	-  Quit, removing deleted messages, etc
  read_rc.c	-  Read the users ".msgrc" file
  reply.c	-  Reply or Forward mail
  return_addr.c -  Compute return address, full or compressed
  screen.c	-  Screen oriented routines
  showmsg.c	-  Show the current message on the screen
  strings.c	-  General string library
  syscall.c	-  Make calls to the system
  validname.c	-  Check to see if the specified name is a legal address

in directory "test"
  test.mail	-  Mail with all sorts of return addresses & headers
  test.notes	-  Notes for testing too

in directory "utils"
  answer.c	-  Answering machine interface (for secretaries)
  arepdaemon.c	-  Daemon works in conjunction with autoreply
  autoreply.c	-  Automatically reply to users mail (vacation, etc)
  cutfile.c	-  Extract a specified piece of a file (internals)
  fastmail.c	-  Batch mail interface. 
  from.c	-  Display who messages are from in specified mailbox
  newalias.c	-  Install new aliases
  newmail.c	-  Daemon to keep you notified of new mail
  printmail.c	-  Interface to allow graceful printing of mailboxes
  readmsg.c	-  Read a specific message NOW
  snd.c		-  send a message without overhead of starting MSG
END-OF-FILE

size=`wc -c < README`

if [ $size != 3838 ]
then
  echo Warning: README changed - should be 3838 bytes, not $size bytes
fi

chmod 644 README

if [ ! -d bin ]
then
  echo creating directory bin
  mkdir bin
fi

# ---------- file bin/makelisting ----------


if [ -f bin/makelisting ]
then
  echo File 'bin/makelisting' already exists\!
  exit 1
fi

echo extracting file bin/makelisting...
cat << 'END-OF-FILE' > bin/makelisting

# shell script to make a listing file..

for file in `echo $* | tr -s ' ' '\012' | sort`
do
  /bin/echo \\f >> LISTING
  echo adding $file...
  cat $file >> LISTING
done

# foreach file (`echo $* | tr -s ' ' '\012' | sort`)
  # /bin/echo \\f >> LISTING
  # echo adding $file...
  # cat $file >> LISTING
# end
END-OF-FILE

size=`wc -c < bin/makelisting`

if [ $size != 310 ]
then
  echo Warning: bin/makelisting changed - should be 310 bytes, not $size bytes
fi

chmod 755 bin/makelisting

if [ ! -d doc ]
then
  echo creating directory doc
  mkdir doc
fi

# ---------- file doc/Config.guide ----------


if [ -f doc/Config.guide ]
then
  echo File 'doc/Config.guide' already exists\!
  exit 1
fi

echo extracting file doc/Config.guide...
cat << 'END-OF-FILE' > doc/Config.guide
'
'  Configuration guide to the MSG mail system
'  format with 'nroff -mm Config.guide > Config.format'
'  or something similar.
'  (C) Copyright 1985 Dave Taylor
'
'  reachable at ..hpfcla!hpcnoe!d_taylor
'  or HP - CNO, 3404 E. Harmony Rd, Fort Collins, CO, 80525
'  (303) 226-3800 x2419
'
'  Last modification: August 20th, 1985
'
.SA 1
.nr Hy 1
.nr Pt 1
.PH ""
.PF "''Page \\\\nP'"
.HM 1 1
.ce 3
Configuration Guide
to the
MSG Mail System
.sp
.ce 999
(C) Copyright 1986, by
Dave Taylor
.sp
\*(DT
.ce 0
.sp
.P
This document is intended as a supplement to the Msg Users Guide
and is only of interest to sites having the source code to the
.B msg
system.
.sp
.P
Virtually all of the installation dependent definitions are contained
in the file 'hdrs/sysdefs.h', as detailed below;
.sp
.DS
.nf
.ce
-------------------------------------------------------------
#define USE_EMBEDDED_ADDRESSES	

#define FIND_DELTA	10	/* for binary searches in path database  */

#define MAX_HEADERS	500	/* max number of messages in one file!   */	
#define MAX_SALIASES	503	/* number of system aliases allowed      */
#define MAX_UALIASES	251	/* number of user aliases allowed 	 */
#define MAX_IN_WEEDLIST 50	/* max headers to weed out               */

#define MAX_HOPS	35	/* max hops in return addr to E)veryone  */

#define MAX_ATTEMPTS	6	/* #times to attempt lock file creation */

#define REMOVE_AT_LAST		/* see leavembox.c */

#define DEFAULT_BATCH_SUBJECT	"no subject (file transmission)"

#define NOCHECK_VALIDNAME	/* see validname.c */

#define NOTES_HEADER		"/***** "
#define NOTES_FOOTER		"/* ---------- */"

#ifdef BSD
# define system_hash_file	"/usr/spool/mail/.alias_hash"
# define system_data_file	"/usr/spool/mail/.alias_data"
#else
# define system_hash_file	"/usr/mail/.alias_hash"
# define system_data_file	"/usr/mail/.alias_data"
#endif

#define pathfile		"/usr/lib/nmail.paths"

#define Lsys			"/usr/lib/uucp/L.sys"

#define DEBUG		"Msg.debug.info"

#define temp_file	"/tmp/snd."
#define temp_mbox	"/tmp/mbox."
#define temp_print      "/tmp/print."
#define mailtime_file	".last_read_mail"
#ifdef BSD
#  define default_editor	"/usr/ucb/vi"
#  define mailhome		"/usr/spool/mail/"
#else
#  define default_editor	"/usr/bin/vi"
#  define mailhome		"/usr/mail/"
#endif

#define sendmail	"/usr/lib/sendmail"
#define sendmailflags	"-oi"
#define mailer		"/bin/rmail"
#define mailx		"/usr/bin/mailx"

#define helphome	"/usr/local/lib/"
#define helpfile	"main.help"

#define msgrcfile	"/.msgrc"
#define mailheaders	".msgheaders"
#define unedited_mail	"emergency.mbox"
#define newalias	"newalias 1>&2 > /dev/null"

#define remove		"/bin/rm -f"		/* how to remove a file */
#define cat		"/bin/cat"		/* how to display files */

.fi
.ce
-------------------------------------------------------------
.DE
.sp
.VL 15 0
.LI "USE_EMBEDDED_ADDRESSES"
This controls the mailers response to messages that contain 
"Reply-To:" or "From:" lines that actually contain a return
address.  If it's defined, the mailer will attempt to use
the address specified (overriding the return address built from the path that
the mail took).  It will look the address up in the pathalias
database (see the documentation on the alias system) for 
incomplete paths, but it is still recommended that this be left
undefined.  
.P
This will, of course, make the mailer not be a standard 'RFC-822' 
mailer, since the mail system is defined to use the reply-to
if included rather than the return address, but, at least for
addresses on the ARPA net, it ain't going to work a lot of the time!
.LI "FIND_DELTA"
This is the delta that the binary search of the pathalias database
will use to determine when it's slicing up a single line, rather than
a multitude of lines.   Ideally, this should be set to 1 byte less
than the shortest line in the file...the default is 10 bytes.
.LI MAX_HEADERS	
The maximum number of messages allowed in a single mailbox.
.LI MAX_SALIASES	
The number of system aliases allowed.  (It is recommended that
this be a prime number to improve the performance of the 
hashing function (it's a complicated proof!))
.LI MAX_UALIASES
The number of user aliases allowed.  (should be a prime number -
see the comment above)
.LI MAX_IN_WEEDLIST 
The maximum number of headers that can be specified in the weedout
list of the .msgrc file.  A suggested alternative approach if this
number is too small is to specify initial substrings in the file
rather than increasing the number.  For example, say you want to 
weedout the headers "Latitude:" and "Latitudinal-Coords:", you
could simply specify "Latitud" and match them both!  Furthermore
you could also specify headers like "X-" and remove all the user
defined headers!
.LI MAX_HOPS
When replying to a G)roup, this is the maximum number of hops that
a message can have taken.  This is used to try to optimize the 
return address (remove cyclic loops and so on) and regular use
should show that the default of 35 is plenty more than you'll
ever need!
.LI MAX_ATTEMPTS
When reading in the default mailbox (/usr/mail/$username) the mailer
creates a file called "/usr/mail/$username.lock" to ensure that no
mail is added to the file while it's being either read, or replaced
(ie written to).  Occasionally, this lock file will already be in
place since someone is currently sending you mail.  If this occurs,
the mailer will wait a few seconds and try to create the lock file
again.  This parameter defines the number of tries the mailer should
take before giving up.
.LI REMOVE_AT_LAST
When it does decide to give up after trying to create the lock file,
(see MAX_ATTEMPTS, above) this will define how to act.  If it's 
defined, the mailer will attempt to remove the lock file after the
MAX_ATTEMPTS timeout.  On the other hand, if it's not defined (the
recommended state) it'll simply quit the mailer, telling the user
to try again in a few minutes.
.LI DEFAULT_BATCH_SUBJECT
What the subject should be on messages that are from redirected input
but don't have a subject specified...
.LI NOCHECK_VALIDNAME
This disables the checking of validnames on the existing machine.
On machines that run a system such as \fBsendmail\fR and use the
sendmail alias feature, this should be defined.  On other systems
this should be left as the default (not defined) to avoid users
generating "dead.letter" files...
.LI NOTES_HEADER
This defines the first "word" of the line that a notes file entry
would contain.
.LI NOTES_FOOTER
This defines the footer line (in it's entirety).
.LI system_hash_file
This is the file that contains the hashed version of the system 
aliases.  It is also used in the newalias command.  (note that
it is defined differently if you're running on a Berkeley system)
.LI system_data_file
This is the other file the newalias command installs in the system
alias area.  (Note this is defined differently if you're runnnig
a bsd system)
.LI pathfile
This defines the location of the alias datafile.  This file is in
the format that pathalias generates, that is;
.nf
   
    machine <tab> address

.fi
For further information, please see the Msg Alias System documentation.
.LI Lsys
This defines where the system L.sys file is kept.  This is used for the
mailer to quickly know what machines the current machine can talk to
directly (to avoid trying to search the pathalias database to route mail
to these machines).  
.LI DEBUG
The name of the file to put in the users home directory if they choose to
use the "-d" debug option. 
.LI temp_file
Temporary file for sending outbound messages.
.Li temp_mbox
Place to keep copy of incoming mailbox to avoid collisions with newer
mail.
.LI temp_print 
File to use when creating a printout of a message.
.LI mailtime_file
File to compare date to to determine if a given message is New
since the last time the mail was read or not.
.LI default_editor
If no editor is specified in the users .msgrc file, this is which
editor to use.  ENSURE IT IS A VALID EDITOR ON THIS MACHINE!!
(Not that the default home for "vi" is different on BSD machines)
.LI mailhome
Where all the incoming mailboxes are, and also where the 'lock'
files have to be put for the mailer to know not to add new
mail while we're reading/writing the mailfile.
(note that mail is kept in a different directory on Berkeley 
systems)
.LI sendmail
Defines where sendmail is (if you have it on your system).
.LI sendmailflags 
Defines the flags to hand to sendmail if and when the program
chooses to use it.
.LI mailer
If you don't have sendmail, this is the mailer that'll be used.
.LI mailx
If all else fails, this mailer can be used in a rather dumb way.
.LI helphome
Where the help file is kept (soon to be help files!)
.LI helpfile
The name of the main helpfile (kept in "helphome").
.LI msgrcfile
The name of the automatic control file (currently ".msgrc")
.LI mailheaders	
The name of the optional file that users may have that will be
included in the headers of each outbound message.
.LI unedited_mail
In the strange case when the mailer suddenly finds all the directories
it uses shut off (like /usr/mail and /tmp) then it'll put the current
mailbox into this file in the users home directory.
.LI newalias
How to install new aliases..
.LI remove
How to remove a file.
.LI cat
How to display a file to stdout.
.LE
END-OF-FILE

size=`wc -c < doc/Config.guide`

if [ $size != 9258 ]
then
  echo Warning: doc/Config.guide changed - should be 9258 bytes, not $size bytes
fi

chmod 644 doc/Config.guide

# ---------- file doc/answer.1 ----------


if [ -f doc/answer.1 ]
then
  echo File 'doc/answer.1' already exists\!
  exit 1
fi

echo extracting file doc/answer.1...
cat << 'END-OF-FILE' > doc/answer.1
.TH ANSWER 1L 
.ad b
.SH NAME
answer - phone message transcription system
.SH SYNOPSIS
.B answer
.PP
.SH HP-UX COMPATIBILITY
.TP 10
Level:
HP-UX/STANDARD
.TP
Origin:
Hewlett Packard
.SH DESCRIPTION
.I Answer\^
is a part of the 
.B msg
mail system and is designed for secretaries and the like
to allow them to answer phones and|or listen to phone message
machines and quickly and easily transcribe the messages into
electronic mail.
.P
The program uses it's own alias set (usually a subset of the
system aliases, with more fields per user (ie unique first
names, unique last names, first-initial lastname, and so on)).
Note this means that you must create and then install, using
.I newalias,
a separate alias table for the account this program is to 
be run from (we at CNO use a unique account for this).  
.P
Interface-wise, the program is a breeze to use - type 'answer'
to start it up and then merely type a user name at the
.nf
	
	Message to:

.fi
prompt, and then enter the message, ending with a blank line.
Names can be entered as 'Firstname Lastname' and the system
will try to find a mail alias based on the first letter of the
first name plus the last name.  For example, 'Dave Taylor'
will cause the program to search for an alias 'd_taylor' in
the file (note the transliteration into lower case).   The 
program will loop until killed or quit.
.P
.I Answer
can be easily exited by typing any of 'quit', 'exit' 'done', 
or 'bye' at the 'Message to:' prompt.
.SH AUTHOR
Dave Taylor, Hewlett Packard - Colorado Networks Operation
.SH SEE ALSO
.I "The MSG Users Guide", 
by Dave Taylor
.sp
.br
newalias(1L), checkalias(1L), mail(1), mailx(1), from(1L), printmail(1L)
.SH FILES
$home/.alias_hash             individual alias hash table
.br
$home/.alias_data             individual alias data table
.br
/tmp/snd*                     edit buffer for outgoing mail
END-OF-FILE

size=`wc -c < doc/answer.1`

if [ $size != 1870 ]
then
  echo Warning: doc/answer.1 changed - should be 1870 bytes, not $size bytes
fi

chmod 644 doc/answer.1

# ---------- file doc/autoreply.1 ----------


if [ -f doc/autoreply.1 ]
then
  echo File 'doc/autoreply.1' already exists\!
  exit 1
fi

echo extracting file doc/autoreply.1...
cat << 'END-OF-FILE' > doc/autoreply.1
.TH AUTOREPLY 1L 
.ad b
.SH NAME
autoreply - Automatic mail reply system
.SH SYNOPSIS
.B autoreply
.br
.B "autoreply off"
.br
.B autoreply
<
.B filename
>
.PP
.SH HP-UX COMPATIBILITY
.TP 10
Systems:
AT&T System V and Berkeley BSD
.TP
Origin:
HP Colorado Networks Operation
.SH DESCRIPTION
.I Autoreply\^
is a part of the 
.B msg
mail system and is designed to enable users to easily set up
an automatic response to all mail they receive.  This is
typically during a vacation or some other period of time that
the user is not available to reply to mail (although some
people get enough mail that they have it permanently running
to simply send an "ack" to each message)
.PP
The system is quite easy to use...
You can type "autoreply" and be informed of your current
status in the system (on or off), or "autoreply off" will
turn your autoreplying off.
.PP
To add yourself to the system, you need merely to compose a
form response in a file somewhere, then type "autoreply <file>"
where <file> is the name of the file.
.SH "SPECIAL NOTE"
For this to function correctly, the program "arepdaemon" must
be running as a daemon in background.  This program automatically
checks all the currently enrolled users for new mail in their
mailboxes...
.SH AUTHOR
Dave Taylor, Hewlett Packard - Colorado Networks Operation
.SH SEE ALSO
.I "The MSG Users Guide", 
by Dave Taylor
.sp
.br
mail(1), mailx(1), msg(1L)
.SH "BUGS"
Unfortunately, this program isn't too brilliant about identifying
mail that shouldn't be responded to (like mail from other
daemons, or your mother) but that's a more general problem anyway.
.sp
Also, occasionally a user will remove themselves from the
autoreply system and the system won't turn their autoreply
off.  This is a problem that hasn't been solved yet (obviously
since it's in the "bugs" section!!) and any further information
would be appreciated!
END-OF-FILE

size=`wc -c < doc/autoreply.1`

if [ $size != 1871 ]
then
  echo Warning: doc/autoreply.1 changed - should be 1871 bytes, not $size bytes
fi

chmod 644 doc/autoreply.1

# ---------- file doc/checkalias.1 ----------


if [ -f doc/checkalias.1 ]
then
  echo File 'doc/checkalias.1' already exists\!
  exit 1
fi

echo extracting file doc/checkalias.1...
cat << 'END-OF-FILE' > doc/checkalias.1
.TH CHECKALIAS 1L
.ad b
.SH NAME
checkalias - check to see if an alias is defined.
.SH SYNOPSIS
.B checkalias
alias, alias, ...
.SH HP-UX COMPATIBILITY
.TP 10
Level:
HP-UX/STANDARD
.TP
Origin:
HP CNO
.SH DESCRIPTION
.I Checkalias
checks the user file first, and then the system alias file
to try to find the specified alias or aliases.  If found, 
the value of the alias is printed out, otherwise an error
is generated.
.P
Note: this is in fact a one-line shell script;
.nf

	msg -c $*

.fi
.SH AUTHOR
Dave Taylor, Hewlett Packard Colorado Network Operation
.SH SEE\ ALSO
newalias(1L), msg(1L), mail(1), mailx(1)
.SH BUGS
Note that the precedence of aliases is user file then system
file.  This means that a user can 'overload' an alias by having
one defined in the system file also defined in theirs.  This
shouldn't turn out to be a problem, but is something for
the system administrator to keep in mind when creating the
system alias file.
END-OF-FILE

size=`wc -c < doc/checkalias.1`

if [ $size != 943 ]
then
  echo Warning: doc/checkalias.1 changed - should be 943 bytes, not $size bytes
fi

chmod 644 doc/checkalias.1

# ---------- file doc/fastmail.1 ----------


if [ -f doc/fastmail.1 ]
then
  echo File 'doc/fastmail.1' already exists\!
  exit 1
fi

echo extracting file doc/fastmail.1...
cat << 'END-OF-FILE' > doc/fastmail.1
.TH FASTMAIL 1L
.ad b
.SH NAME
fastmail - quick batch mail interface to a single address
.SH SYNOPSIS
.B fastmail
[-d] [-f Fromname] [-s Subject] filename address
.br
.SH HP-UX COMPATIBILITY
.TP 10
Level:
HP-UX/STANDARD
.TP
Origin:
HP CNO
.SH DESCRIPTION
.I Fastmail
is a low-level interface to the mail system that allows batch
processing of mail.  It's intended for mailing to very large
groups of people in a staggered fashion. 
.SH EXAMPLE
Let's say we're user "big" on machine "big-vax" and we have a
shell script called 'batch-mail' that contains the following
lines:
.nf

   #
   # Batch Mail - batch mailing of a file to a LOT of users
   #  
   # Usage: batch-mail "from" "subject" filename

   fastmail -f "$1" -s "$2" $3 person1
   sleep 10
   fastmail -f "$1" -s "$2" $3 person2
   sleep 10
   fastmail -f "$1" -s "$2" $3 person3
   sleep 10
   fastmail -f "$1" -s "$2" $3 person4

   < etc >

with the invocation:

   batch-mail "Mr. Big" "Warning to all" warning.text

.fi
would mail a copy of the 'warning.text' file to person1, person2, 
person3, etc.  Each resultant message will include the headers:
.nf

    From: big-vax!big (Mr. Big)
    Subject: Warning to all

.fi
for compatibility.  This program should turn out to be considerably
faster than the alternative methods of accomplishing this task.
.SH FILES
/usr/lib/sendmail       sendmail transport if available
.br
/bin/rmail              transport if no sendmail
.br
/tmp/fastmail.$$        temporary file 
.SH AUTHOR
Dave Taylor, Hewlett Packard Colorado Network Operation
.SH SEE\ ALSO
sendmail(1), rmail(1), snd(1L)
END-OF-FILE

size=`wc -c < doc/fastmail.1`

if [ $size != 1595 ]
then
  echo Warning: doc/fastmail.1 changed - should be 1595 bytes, not $size bytes
fi

chmod 644 doc/fastmail.1

# ---------- file doc/from.1 ----------


if [ -f doc/from.1 ]
then
  echo File 'doc/from.1' already exists\!
  exit 1
fi

echo extracting file doc/from.1...
cat << 'END-OF-FILE' > doc/from.1
.TH FROM 1L
.ad b
.SH NAME
from - list from and subject of all messages in mailbox or file
.SH SYNOPSIS
.B from
[ filename ]
.SH HP-UX COMPATIBILITY
.TP 10
Level:
HP-UX/STANDARD
.TP
Origin:
HP CNO
.SH DESCRIPTION
.I From
outputs a line per message in the current users mailbox 
of the form;
.PP
<from> [subject]
.PP
If a filename is specified, the program reads that file
rather than the default file.
.PP
Note that this program accepts the standard UNIX mail
headers and also accepts the modified headers that the
Shared Resource Manager mailer outputs...
.SH AUTHOR
Dave Taylor, Hewlett Packard Colorado Network Operation
.SH SEE\ ALSO
msg(1L), mail(1), mailx(1)
.SH BUGS
Occasionally it gets confused about whether a message has
a subject or not.  This, unfortunately, is due to the
vast number of possible headers in the messages...
END-OF-FILE

size=`wc -c < doc/from.1`

if [ $size != 837 ]
then
  echo Warning: doc/from.1 changed - should be 837 bytes, not $size bytes
fi

chmod 644 doc/from.1

# ---------- file doc/msg.1 ----------


if [ -f doc/msg.1 ]
then
  echo File 'doc/msg.1' already exists\!
  exit 1
fi

echo extracting file doc/msg.1...
cat << 'END-OF-FILE' > doc/msg.1
.TH MSG 1L 
.ad b
.SH NAME
msg - an interactive mail system
.SH SYNOPSIS
.B msg
[
.B \-cdhkmrswz
] [
.B \-f
<
.B file
>]
.br
.B msg 
[
.B \-S 
<
.B subject
>] <
.B "list of aliases or addresses"
>
.PP
.SH HP-UX COMPATIBILITY
.TP 10
Level:
HP-UX/STANDARD
.TP
Origin:
Hewlett Packard
.SH DESCRIPTION
.I Msg\^
is a new interactive mailer program that supercedes 
.I mail
and 
.I mailx.
.PP
There are three main ways to use the \fBmsg\fR mailer; 
one way to use the mailer is to specify a list of addresses on the
command line when the mailer is invoked.  This will allow sending
of a single message to the specified recipients with all the
options usually available in the \fBmsg\fR system itself.
.PP
The second way, used most commonly when transmitting files and such,
is to specify the subject of the message and the recipients using
the command line and redirect a file as standard input.  For example,
the command 
.nf

	msg -S testing joe < test.c 

.fi
would mail a copy of the
file test.c to alias joe, with the subject "testing" indicated.
.PP
Otherwise, the starting options are;
.TP 1.0i
.B "-c"
Checkalias - expand the following aliases and return.
.B "-d"
Debug - turn on debug option - lot's of output!
.TP
.B "-f <file>"
File - read file (specified) rather than the incoming mailbox.
.TP
.B "-h"
Help - give a list of starting options.
.TP
.B "?"
Synonymous with the "-h" option.
.TP
.B "-k"
Keypad - force knowledge of HP terminal keyboard, to allow
the use of the NEXT, PREV and HOME/SHIFT-HOME keys.
.TP
.B "-m"
Menu off - Use the extra lines for more message headers.
.TP
.B "-s"
Softkeys - enable use of softkeys on HP terminals only.
which ones in the ".msgrc" file.
.TP
.B "-z"
Zero - don't enter MSG if no mail is pending.
.SH AUTHOR
Dave Taylor
.SH SEE ALSO
.I "The MSG Users Guide", 
by Dave Taylor
.sp
.br
.I "A Guide to the Msg Alias System"
by Dave Taylor
.sp 
.br
newalias(1L), checkalias(1L), mail(1), mailx(1), from(1L), printmail(1L)
.SH FILES
/usr/local/bin/msg-help.main      help file
.br
/usr/mail/.alias_hash             system alias hash table
.br
/usr/mail/.alias_data             system alias data table
.br
$home/.alias_hash                 user alias hash table
.br
$home/.alias_data                 user alias data table
.br
/tmp/snd*                         outgoing mail edit buffer
.br
/tmp/mbox*                        temporary mailbox
.SH DIAGNOSTICS
Should know about terminals other than HP.  (If only 
termcap were that powerful!)
END-OF-FILE

size=`wc -c < doc/msg.1`

if [ $size != 2480 ]
then
  echo Warning: doc/msg.1 changed - should be 2480 bytes, not $size bytes
fi

chmod 644 doc/msg.1

# ---------- file doc/newalias.1 ----------


if [ -f doc/newalias.1 ]
then
  echo File 'doc/newalias.1' already exists\!
  exit 1
fi

echo extracting file doc/newalias.1...
cat << 'END-OF-FILE' > doc/newalias.1
.TH NEWALIAS 1L
.ad b
.SH NAME
newalias - install new msg aliases for user and/or system
.SH SYNOPSIS
.B newalias
.SH HP-UX COMPATIBILITY
.TP 10
Level:
HP-UX/STANDARD
.TP
Origin:
HP CNO
.SH DESCRIPTION
.I Newalias
creates new hash and data files from a text file.  If the
program is invoked by any account other than the superuser
account, the program looks for a file 
called $home/.alias_text
and, upon finding it, creates files $home/.alias_hash and
$home/.alias_data for the 
.I msg
program.
.PP
If the Superuser invokes the program, they are given the
option of either updating their personal alias files or
the system alias files.
.PP
The format that the program expects is;
.sp
.nf
	alias, alias, .. : comment : address
or
	alias, alias, .. : comment : alias, alias, ...
   
The first form is for an individual user such as;

	dave, taylor : Dave Taylor : veeger!hpcnou!dat

and the second is for defining a group alias such as;

	gurus : Unix Gurus : alan, john, dave, mike, richard,
		             larry, t_richardson

.fi
.sp
Note that lines can be continued at will, blank lines are accepted
without error, and that any line starting with '#' is considered a
comment and is not processed.
.PP
The comment field is thrown away by this program, but it is 
recommended that it contain the name of the user who the alias
is for.
.PP
Finally, aliases can contain other aliases, and/or groups;
.sp
.nf
	unix : Unix people : gurus, taylor, jonboy
.fi
' onto the next page, if you please
.sp 3
.SH FILES
$home/.alias_text               alias source for user 
.br
$home/.alias_hash               alias hash table for user
.br
$home/.alias_data               alias data file for user
.br
/usr/mail/.alias_text           alias source for system
.br
/usr/mail/.alias_hash           alias hash table for system
.br
/usr/mail/.alias_data           alias data file for system
.SH AUTHOR
Dave Taylor, Hewlett Packard Colorado Network Operation
.SH SEE\ ALSO
msg(1L), checkalias(1L), mail(1), mailx(1)
.SH DIAGNOSTICS
Newalias has a couple of descriptive error messages which
don't need to be detailed here.  It is, however, worth
noting that the
.I checkalias
program can be used to ensure that the aliases are in the
proper order and are available for the 
.I msg
system.
END-OF-FILE

size=`wc -c < doc/newalias.1`

if [ $size != 2268 ]
then
  echo Warning: doc/newalias.1 changed - should be 2268 bytes, not $size bytes
fi

chmod 644 doc/newalias.1

# ---------- file doc/newmail.1 ----------


if [ -f doc/newmail.1 ]
then
  echo File 'doc/newmail.1' already exists\!
  exit 1
fi

echo extracting file doc/newmail.1...
cat << 'END-OF-FILE' > doc/newmail.1
.TH NEWMAIL 1L 
.ad b
.SH NAME
newmail - daemon to asynchronously notify of new mail
.SH SYNOPSIS
.B newmail
.PP
.SH HP-UX COMPATIBILITY
.TP 10
Level:
HP-UX/STANDARD
.TP
Origin:
Hewlett Packard
.SH DESCRIPTION
.I Newmail\^
is a daemon designed to run in background and every 60 seconds
check to see if there is any new mail for the user that
started it up.
.P
If there is new mail, the program will asynchronously write to
the terminal that it was started on a message of the form
.nf

   New mail has arrived from <name> - <subject>

.fi
where <name> is either the name of the person sending it,
if available (the ARPA 'From:' line) or machine!login where
machine is the machine the mail was sent from.  If there
is no subject, the message "<no subject>" will appear on
the screen.
.P
This program will run forever, and can internally reset 
itself if mail is deleted from the incoming mailbox while
trying to monitor it.
.SH AUTHOR
Dave Taylor, Hewlett Packard - Colorado Networks Operation
.SH SEE ALSO
notify in sh(1) or csh(1), announce(1L)
.SH NOTE
This program replaces the "announce" program.
END-OF-FILE

size=`wc -c < doc/newmail.1`

if [ $size != 1101 ]
then
  echo Warning: doc/newmail.1 changed - should be 1101 bytes, not $size bytes
fi

chmod 644 doc/newmail.1

# ---------- file doc/printmail.1 ----------


if [ -f doc/printmail.1 ]
then
  echo File 'doc/printmail.1' already exists\!
  exit 1
fi

echo extracting file doc/printmail.1...
cat << 'END-OF-FILE' > doc/printmail.1
.TH PRINTMAIL 1L
.ad b
.SH NAME
printmail - format mail in a readable fashion for printing
.SH SYNOPSIS
.B printmail
{-d}
{filename}
.SH HP-UX COMPATIBILITY
.TP 10
Level:
HP-UX/STANDARD
.TP
Origin:
HP CNO
.SH DESCRIPTION
.I Printmail
copies all messages from either the file specified or the
default user mailbox separated by form feeds to standard output.  
With the
.B \-d
option, the messages are separated by a dashed line
rather than the formfeed (for lots of little mail).
.P
A typical usage of this command is;
.nf
	printmail -d | print 
.fi
.SH AUTHOR
Dave Taylor, Hewlett Packard Colorado Network Operation
.SH SEE\ ALSO
msg(1L), mail(1), mailx(1), from(1L)
END-OF-FILE

size=`wc -c < doc/printmail.1`

if [ $size != 667 ]
then
  echo Warning: doc/printmail.1 changed - should be 667 bytes, not $size bytes
fi

chmod 644 doc/printmail.1

# ---------- file doc/readmsg.1 ----------


if [ -f doc/readmsg.1 ]
then
  echo File 'doc/readmsg.1' already exists\!
  exit 1
fi

echo extracting file doc/readmsg.1...
cat << 'END-OF-FILE' > doc/readmsg.1
.TH READMSG 1L
.ad b
.SH NAME
readmsg - read messages from incoming mail
.SH SYNOPSIS
.B readmsg
message [message ...]
.br
.SH HP-UX COMPATIBILITY
.TP 10
Level:
HP-UX/STANDARD
.TP
Origin:
HP Colorado Networks Operation
.SH DESCRIPTION
.I Readmsg
is a simple program that writes the specified message or messages
to the screen.  The messages can be specified as either their
order in the mail file (if you know it!) or the last message
can be specified by the metacharacter '$'. 
.P
This is most useful in conjunction with 'newmail', so that when
you get a message that might be important, you can simply
type 'readmsg $' and find out what it is...
.SH EXAMPLE
Let's say we want to read the first, fourth, and last messages
from our incoming mail (note that it is recommended that you
feed the output of \fBreadmsg\fR to another program that will
paginate, or you are in danger of having the message fly past
before you can read it!):
.nf

	% readmsg 1 4 $ | more

.fi
would work admirably.
.SH FILES
/usr/mail/<username>   The incoming mail
.SH AUTHOR
Dave Taylor, Hewlett Packard Colorado Network Operation
.SH SEE\ ALSO
newmail(1L), msg(1L)
END-OF-FILE

size=`wc -c < doc/readmsg.1`

if [ $size != 1143 ]
then
  echo Warning: doc/readmsg.1 changed - should be 1143 bytes, not $size bytes
fi

chmod 644 doc/readmsg.1

# ---------- file doc/helpfile ----------


if [ -f doc/helpfile ]
then
  echo File 'doc/helpfile' already exists\!
  exit 1
fi

echo extracting file doc/helpfile...
cat << 'END-OF-FILE' > doc/helpfile

        Command                 	Action

	   | 			  Pipe current message to ...
	   !			  Shell escape
           ?                      This screen of information
           + or <space>           Next page of headers
           -                      Previous page of headers
           =                      Set current message to 1
	   *			  Set current message to last message
           <n>                    Set current message to n

           a                      Alias, change to 'alias' mode 
           c                      Change current mail file
           d                      Delete current message
           f                      Forward message to specified user
	   g                      Group (all recipients) reply to message
	   h			  Headers displayed with message
           j			  Increment current message by one
	   k			  Decrement current message by one
           m                      Mail to arbitrary user(s)
           n                      Next message (Read current, then increment)
	<return>		  Read current message
	   p                      print current message
           r                      Reply to current message
           s                      Save message to specified file
	   t			  Time - display the current time and date.
           q                      Quit - mail deleted, saved in mbox or left.
           u                      Undelete current message
           x                      Exit - don't record as read, don't save...


          ^L                      Rewrite screen.
	  ^M (<return>)		  Read Current Message
	  ^Q, ^Z, DEL		  Exit - don't record as read, don't save...
END-OF-FILE

size=`wc -c < doc/helpfile`

if [ $size != 1659 ]
then
  echo Warning: doc/helpfile changed - should be 1659 bytes, not $size bytes
fi

chmod 644 doc/helpfile

# ---------- file doc/msgrc.sample ----------


if [ -f doc/msgrc.sample ]
then
  echo File 'doc/msgrc.sample' already exists\!
  exit 1
fi

echo extracting file doc/msgrc.sample...
cat << 'END-OF-FILE' > doc/msgrc.sample
#
# .msgrc - automatic variable defines for the 'msg' mailer.
#
# Personalized for ??
# 

# where to save my mail to, default directory
maildir  = ~/Mail

# where to save messages to, default file
mailbox  = ~/Mail/mailbox

# what editor to use
editor   = $EDITOR

# where to save mail if not specified somewhere else
savemail = ~/Mail/mail.sent

# how to print a message ('%s' is the filename)
print    = /usr/local/bin/print -p lpn -f %s

# prefix sequence for including message text in other messages...
prefix = > 

# what headers I DON'T want to see, ever.

weedout  = "Via:"  "Sent:"  "Date:"  "Status:"  "Original"
	   "From"  "Phase"  "Subject:"  "Fruit"  "Sun"
	   "Lat"  "Buzzword"  "Return"  "Posted" "Telephone"
	   "Postal-Address" "Origin" "X-Sent-By-Nmail-V"
	   "Resent" "X-Location"  "Source" "Mood"  "Neuron"
	   "Libido" "To:" "X-Mailer:"  "Full-Name:" "X-HPMAIL"
	   "Cc:" "cc:" "Mmdf" "Network-"

# automatically copy message being replied to into buffer? 
autocopy = OFF

# save a copy of all outbound messages? 
copy     = ON

# emulate the mailx message increment mode (only increment after something
# has been 'done' to a message, either saved or deleted)
resolve  = ON

# enable the weedout list to be read...
weed     = ON

# when messages are copied into the outbound buffer, don't include headers
noheader = ON

# display message title when displaying pages of message
titles	 = ON

# alternative addresses that I could receive mail from (usually a
# forwarding mailbox)

# alternatives = 
END-OF-FILE

size=`wc -c < doc/msgrc.sample`

if [ $size != 1520 ]
then
  echo Warning: doc/msgrc.sample changed - should be 1520 bytes, not $size bytes
fi

chmod 644 doc/msgrc.sample

echo done

exit 0




