Subject: lplot and quickplot (Part 2 of 2)
From: Duane Hesser <talcott!seismo!hplsla!tikal!sysad>
Newsgroups: mod.sources
Approved: jpn@panda.UUCP

Mod.sources:  Volume 4, Issue 94
Submitted by: Duane Hesser <seismo!hplsla!tikal!sysad>

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	Makefile
#	Makefile.lplot
#	Makefile.quick
#	alpha_plot.c
#	functions.c
#	global.c
#	iobuf.c
#	lplot.c
#	read_stream.c
#	defs.h
#	extern.h
#	io.h
#	testprogs.d
# This archive created: Fri May  2 18:21:02 1986
export PATH; PATH=/bin:$PATH
echo shar: extracting "'Makefile'" '(1452 characters)'
if test -f 'Makefile'
then
	echo shar: will not over-write existing file "'Makefile'"
else
cat << \SHAR_EOF > 'Makefile'
# 
# $Header: Makefile,v $
# 
# $Log: Makefile,v $
# 
# 

BIN=/usr/public/bin
MAN=/usr/man/manp

nothing:
	@echo 'Use:'
	@echo 'make all             to update lplot and quickplot'
	@echo 'make new             to make both from scratch'
	@echo 'make clean           to remove .o files'
	@echo 'make bclean          to remove binaries and .o files'
	@echo 'make lplot           to make only lplot'
	@echo 'make quickplot       to make only quickplot'
	@echo 'make install         to update and install both'
	@echo 'make install_l       to update and install lplot'
	@echo 'make install_q       to update and install quickplot'
	@echo 'make install.man     to update and install man pages'

all:	lplot quickplot 

new:	bclean all

lplot: MAKINGLPLOT	FORCE
	make -f Makefile.lplot

quickplot: MAKINGQUICK	FORCE
	make -f Makefile.quick

FORCE:

bclean:
	-rm -f *.o quickplot lplot LQPLOT.*

clean:
	-rm -f *.o  LQPLOT.*

copy:
	cpr -n -s defs.h global.c extern.h io.h lplot.c read_stream.c \
	functions.c iobuf.c  alpha_plot.c | lprn -E4

install: install_l install_q

install_l: lplot 
	-rm -f $(BIN)/lplot $(BIN)/rlplot $(BIN)/quickplot
	install -s lplot $(BIN)
	ln $(BIN)/lplot $(BIN)/rlplot

install_q: quickplot
	install -s quickplot $(BIN)

install.man:
	cp lplot.p quickplot.p $(MAN)
	man lplot > /dev/null
	man quickplot > /dev/null

MAKINGLPLOT:
	-rm -f MAKINGQUICK *.o
	touch MAKINGLPLOT

MAKINGQUICK:
	-rm -f MAKINGLPLOT *.o
	touch MAKINGQUICK

SHAR_EOF
if test 1452 -ne "`wc -c < 'Makefile'`"
then
	echo shar: error transmitting "'Makefile'" '(should have been 1452 characters)'
fi
fi
echo shar: extracting "'Makefile.lplot'" '(729 characters)'
if test -f 'Makefile.lplot'
then
	echo shar: will not over-write existing file "'Makefile.lplot'"
else
cat << \SHAR_EOF > 'Makefile.lplot'
# 
# $Header: Makefile.lplot,v $
# 
# $Log: Makefile.lplot,v $
# 
# 

DEFINES=-DDEBUG -DBIGENDIAN
CFLAGS = -O $(DEFINES)
#CFLAGS = -pg $(DEFINES)

lplot:	global.o lplot.o read_stream.o \
		functions.o iobuf.o alpha_plot.o
		cc -o lplot $(CFLAGS) global.o lplot.o \
		read_stream.o functions.o iobuf.o \
		alpha_plot.o -lm 

clean:
		rm -f *.o

copy:
		cpr -n -s defs.h global.c extern.h io.h \
		lplot.c read_stream.c functions.c iobuf.c \
		alpha_plot.c | lprn

lint:
		lint -ph $(DEFINES) global.c lplot.c \
		read_stream.c functions.c iobuf.c \
		alpha_plot.c

global.o:	defs.h io.h
lplot.o:	defs.h extern.h io.h
read_stream.o:	defs.h extern.h
functions.o:	defs.h extern.h
iobuf.o:	defs.h extern.h io.h
alpha_plot.o:	extern.h
SHAR_EOF
if test 729 -ne "`wc -c < 'Makefile.lplot'`"
then
	echo shar: error transmitting "'Makefile.lplot'" '(should have been 729 characters)'
fi
fi
echo shar: extracting "'Makefile.quick'" '(679 characters)'
if test -f 'Makefile.quick'
then
	echo shar: will not over-write existing file "'Makefile.quick'"
else
cat << \SHAR_EOF > 'Makefile.quick'
# 
# $Header: Makefile.quick,v $
# 
# $Log: Makefile.quick,v $
# 
# 

DEFINES=-DQUICKPLOT -DDEBUG -DBIGENDIAN
CFLAGS = -O $(DEFINES)
#CFLAGS = -pg $(DEFINES)

quickplot:	global.o lplot.o read_stream.o functions.o iobuf.o
	cc -o quickplot $(CFLAGS) global.o lplot.o read_stream.o \
		functions.o iobuf.o -lm -ltermcap

clean:
	rm -f *.o quickplot lplot

copy:
	cpr -n -s defs.h global.c extern.h io.h lplot.c read_stream.c \
	functions.c iobuf.c  | lprn

lint:
	lint -ph $(DEFINES) global.c lplot.c read_stream.c \
	functions.c iobuf.c 

global.o:	defs.h io.h
lplot.o:	defs.h extern.h io.h
read_stream.o:	defs.h extern.h
functions.o:	defs.h extern.h
iobuf.o:	defs.h extern.h io.h
SHAR_EOF
if test 679 -ne "`wc -c < 'Makefile.quick'`"
then
	echo shar: error transmitting "'Makefile.quick'" '(should have been 679 characters)'
fi
fi
echo shar: extracting "'alpha_plot.c'" '(9282 characters)'
if test -f 'alpha_plot.c'
then
	echo shar: will not over-write existing file "'alpha_plot.c'"
else
cat << \SHAR_EOF > 'alpha_plot.c'
/* :set tabstops=4													*/
static char *RCSid = "$Header: alpha_plot.c,v 1.1 86/04/20 16:16:28 sysad Exp $";

/*
 * $Log:	alpha_plot.c,v $
 * Revision 1.1  86/04/20  16:16:28  sysad
 * Initial distribution version
 * 
 * 
 */


/* It is the intent of the author that this software may be distributed
 * and used freely, without restriction.  If you make improvements or
 * enhancements, I would appreciate a copy.
 *
 * Duane H. Hesser	Teltone Corporation
 * ....uw-beaver!tikal!sysad
 * ....uw-beaver!tikal!dhh
 */

/* Character table for generation of ascii characters.
 * Each row represents one character.  A nine high by eight wide
 * matrix is used, including two descenders.  The first byte of
 * each row is the "width" of the character; the remaining bytes
 * are the bit pattern of the character, starting with the
 * descenders (table[x][3] is the lower left corner of the character,
 * which references the starting location of the character).
 *
 * Characters generated by lplot are rather severely restricted
 * by the low dot density; as a result, labels will usually be
 * "longer" in plotted length than those produced by other filters.
 * The "width" includes the separation of the character from any
 * following character (starting location of current character +
 * width of current character = starting location of following
 * character).  This is used to improve the appearance of labels,
 * and reduce the problem of label size expansion.
 */
#include "extern.h"

char table[][10] = {
5, 0,    0,    0,    0,    0,    0,    0,    0,    0,      /* ' '   */
6, 0,    0,    040,  0,    040,  040,  040,  040,  040,    /*  '!'  */
5, 0,    0,    0,    0,    0,    0,    0,    0120, 0120,   /*  '"'  */
7, 0,    0,    0120, 0120, 0370, 0120, 0370, 0120, 0120,   /*  '#'  */
9, 0,    0,    020,  0374, 022,  0174, 0220, 0176, 020,    /*  '$'  */
9, 0,    0,    0204, 0112, 044,  020,  0110, 0244, 0102,   /*  '%'  */
8, 0,    0,    0144, 0230, 0220, 0250, 0104, 0240, 0100,   /*  '&'  */
3, 0,    0,    0,    0,    0,    0,    0200, 0100, 0100,   /*  '''  */
5, 0,    0,    040,  0100, 0200, 0200, 0200, 0100, 040,    /*  '('  */
5, 0,    0,    0200, 0100, 040,  040,  040,  0100, 0200,   /*  ')'  */
7, 0,    0,    0250, 0160, 0330, 0160, 0250, 0,    0,      /*  '*'  */
7, 0,    0,    040,  040,  0370, 040,  040,  0,    0,      /*  '+'  */
4, 0200, 0100, 0100, 0,    0,    0,    0,    0,    0,      /*  ','  */
7, 0,    0,    0,    0,    0,    0370, 0,    0,    0,      /*  '-'  */
3, 0,    0,    0200, 0,    0,    0,    0,    0,    0,      /*  '.'  */
9, 0,    0,    0200, 0100, 040,  020,  010,  04,   02,     /*  '/'  */
9, 0,    0,    070,  0104, 0202, 0202, 0202, 0104, 070,    /*  '0'  */
6, 0,    0,    0160, 0040, 0040, 0040, 0040, 0140, 0040,   /*  '1'  */
8, 0,    0,    0374, 0200, 0160, 010,  04,   0204, 0170,   /*  '2'  */
8, 0,    0,    0170, 0204, 04,   070,  04,   0204, 0170,   /*  '3'  */
8, 0,    0,    010,  010,  0374, 0210, 0110, 050,  010,    /*  '4'  */
8, 0,    0,    0160, 0210, 04,   010,  0360, 0200, 0370,   /*  '5'  */
8, 0,    0,    0170, 0204, 0204, 0370, 0100, 040,  020,    /*  '6'  */
8, 0,    0,    0100, 0100, 0100, 040,  020,  010,  0374,   /*  '7'  */
9, 0,    0,    070,  0104, 0202, 0104, 070,  0104, 070,    /*  '8'  */
8, 0,    0,    040,  020,  010,  0170, 0204, 0204, 0170,   /*  '9'  */
4, 0,    0,    0,    0300, 0,    0,    0300, 0,    0,      /*  ':'  */
5, 0,    0200, 0100, 0140, 0,    0140, 0,    0,    0,      /*  ';'  */
6, 0,    0,    020,  040,  0100, 0200, 0100, 040,  020,    /*  '<'  */
7, 0,    0,    0,    0,    0370, 0,    0370, 0,    0,      /*  '='  */
6, 0,    0,    0200, 0100, 040,  020,  040,  0100, 0200,   /*  '>'  */
8, 0,    0,    040,  0,    040,  020,  010,  0204, 0170,   /*  '?'  */
10,   0, 0,    076,  0100, 0236, 0245, 0231, 0102, 074,    /*  '@'  */
9, 0,    0,    0202, 0202, 0376, 0202, 0104, 050,  020,    /*  'A'  */
8, 0,    0,    0370, 0204, 0204, 0370, 0204, 0204, 0370,   /*  'B'  */
8, 0,    0,    0170, 0204, 0200, 0200, 0200, 0204, 0170,   /*  'C'  */
8, 0,    0,    0370, 0204, 0204, 0204, 0204, 0204, 0370,   /*  'D'  */
8, 0,    0,    0374, 0200, 0200, 0360, 0200, 0200, 0374,   /*  'E'  */
8, 0,    0,    0200, 0200, 0200, 0360, 0200, 0200, 0374,   /*  'F'  */
8, 0,    0,    0170, 0204, 0204, 0214, 0200, 0204, 0170,   /*  'G'  */
8, 0,    0,    0204, 0204, 0204, 0374, 0204, 0204, 0204,   /*  'H'  */
5, 0,    0,    0340, 0100, 0100, 0100, 0100, 0100, 0340,   /*  'I'  */
7, 0,    0,    0140, 0220, 020,  020,  020,  020,  070,    /*  'J'  */
8, 0,    0,    0204, 0210, 0220, 0340, 0220, 0210, 0204,   /*  'K'  */
8, 0,    0,    0374, 0200, 0200, 0200, 0200, 0200, 0200,   /*  'L'  */
9, 0,    0,    0202, 0202, 0202, 0222, 0252, 0306, 0202,   /*  'M'  */
9, 0,    0,    0202, 0206, 0212, 0222, 0242, 0302, 0202,   /*  'N'  */
8, 0,    0,    0170, 0204, 0204, 0204, 0204, 0204, 0170,   /*  'O'  */
8, 0,    0,    0200, 0200, 0200, 0370, 0204, 0204, 0370,   /*  'P'  */
8, 0,    0,    064,  0110, 0224, 0204, 0204, 0110, 060,    /*  'Q'  */
8, 0,    0,    0204, 0210, 0220, 0370, 0204, 0204, 0370,   /*  'R'  */
8, 0,    0,    0170, 0204, 04,   0170, 0200, 0204, 0170,   /*  'S'  */
6, 0,    0,    040,  040,  040,  040,  040,  040,  0370,   /*  'T'  */
9, 0,    0,    070,  0104, 0202, 0202, 0202, 0202, 0202,   /*  'U'  */
9, 0,    0,    020,  050,  0104, 0202, 0202, 0202, 0202,   /*  'V'  */
9, 0,    0,    0202, 0306, 0252, 0222, 0202, 0202, 0202,   /*  'W'  */
9, 0,    0,    0202, 0104, 050,  020,  050,  0104, 0202,   /*  'X'  */
9, 0,    0,    020,  020,  020,  020,  050,  0104, 0202,   /*  'Y'  */
8, 0,    0,    0374, 0200, 0100, 040,  020,  010,  0374,   /*  'Z'  */
5, 0,    0,    0340, 0200, 0200, 0200, 0200, 0200, 0340,   /*  '['  */
9, 0,    0,    02,   04,   010,  020,  040,  0100, 0200,   /*  '\'  */
5, 0,    0,    0340, 040,  040,  040,  040,  040,  0340,   /*  ']'  */
6, 0,    0,    0,    0,    0,    0,    0210, 0120, 040,    /*  '^'  */
8, 0,    0377, 0,    0,    0,    0,    0,    0,    0,      /*  '_'  */
4, 0,    0,    0,    0,    0,    0,    040,  040,  0100,   /*  '`'  */
8, 0,    0,    0164, 0210, 0170, 010,  0360, 0,    0,      /*  'a'  */
7, 0,    0,    0360, 0210, 0210, 0210, 0360, 0200, 0200,   /*  'b'  */
7, 0,    0,    0170, 0200, 0200, 0200, 0170, 0,    0,      /*  'c'  */
8, 0,    0,    0164, 0210, 0210, 0210, 0170, 010,  010,    /*  'd'  */
8, 0,    0,    0170, 0200, 0370, 0204, 0170, 0,    0,      /*  'e'  */
6, 0,    0,    0100, 0100, 0100, 0340, 0100, 0110, 060,    /*  'f'  */
7, 0360, 010,  0170, 0210, 0210, 0210, 0160, 0,    0,      /*  'g'  */
7, 0,    0,    0210, 0210, 0210, 0210, 0360, 0200, 0200,   /*  'h'  */
5, 0,    0,    0340, 0100, 0100, 0100, 0300, 0,    0100,   /*  'i'  */
7, 0140, 0220, 020,  020,  020,  020,  020,  0,    020,    /*  'j'  */
7, 0,    0,    0210, 0220, 0240, 0300, 0240, 0220, 0200,   /*  'k'  */
5, 0,    0,    0340, 0100, 0100, 0100, 0100, 0100, 0300,   /*  'l'  */
9, 0,    0,    0222, 0222, 0222, 0222, 0356, 0,    0,      /*  'm'  */
8, 0,    0,    0104, 0104, 0104, 0104, 0270, 0,    0,      /*  'n'  */
7, 0,    0,    0160, 0210, 0210, 0210, 0160, 0,    0,      /*  'o'  */
7, 0200, 0200, 0360, 0210, 0210, 0210, 0360, 0,    0,      /*  'p'  */
7, 010,  010,  0170, 0210, 0210, 0210, 0170, 0,    0,      /*  'q'  */
6, 0,    0,    0200, 0200, 0200, 0310, 0260, 0,    0,      /*  'r'  */
7, 0,    0,    0360, 010,  0160, 0200, 0170, 0,    0,      /*  's'  */
7, 0,    0,    020,  050,  040,  040,  0370, 040,  040,    /*  't'  */
8, 0,    0,    0164, 0210, 0210, 0210, 0210, 0,    0,      /*  'u'  */
8, 0,    0,    040,  0120, 0210, 0210, 0210, 0,    0,      /*  'v'  */
9, 0,    0,    0104, 0252, 0222, 0222, 0202, 0,    0,      /*  'w'  */
8, 0,    0,    0210, 0120, 040,  0120, 0210, 0,    0,      /*  'x'  */
8, 0360, 010,  0170, 0210, 0210, 0210, 0210, 0,    0,      /*  'y'  */
8, 0,    0,    0370, 0100, 040,  020,  0370, 0,    0,      /*  'z'  */
6, 0,    0,    060,  0100, 0100, 0200, 0100, 0100, 060,    /*  '{'  */
3, 0,    0,    0200, 0200, 0200, 0,    0200, 0200, 0200,   /*  '|'  */
7, 0,    0,    0300, 040,  040,  020,  040,  040,  0300,   /*  '}'  */
7, 0,    0,    0,    0,    0,    0,    020,  0250, 0100,   /*  '~'  */
7, 0,    0,    040,  0160, 0250, 040,  040,  0,    0,      /*  'd'  */
};

alpha_plot(c)
char c;
{
	int width;
	int index = c - ' ';
	char *ptr;
	short x,y,i,j;

	if((index < 0) || (index >= sizeof(table))) return;

	ptr = table[index];
	width = ((int)*ptr++ & 0377);

	/* Move so that the character is plotted with its center (approx)
	 * is plotted at the current point.  We have to undo this at the
	 * end.
	 */
	curxdot -= 3;
	curydot -= 3;
	/* this is a hack--character height changes due to different
	 * dot densities in x and y.  we restore this at the end.
	 */
	if(Rotate) --curydot;
	
	for(i = 0;i < 9; ++i)
	{
		if(ptr[i])
		{
			for(j = 0; j < 8; ++j)
			{
				if(plotbit(ptr[i],j))
				{
					x = curxdot + 7 - j;
					y = curydot + i - 2;
					point(x,y);
				}
			}
		}
	}
	if(Rotate)
	{
		/* different dot densities, again							*/
		width = (double)width * YPERINCH / XPERINCH;
		curydot++;	/* end hack										*/
	}
	curx += (double)width/mapxfac;
	curxdot += 3;
	curydot += 3;
	curxdot += width;
}
SHAR_EOF
if test 9282 -ne "`wc -c < 'alpha_plot.c'`"
then
	echo shar: error transmitting "'alpha_plot.c'" '(should have been 9282 characters)'
fi
fi
echo shar: extracting "'functions.c'" '(11457 characters)'
if test -f 'functions.c'
then
	echo shar: will not over-write existing file "'functions.c'"
else
cat << \SHAR_EOF > 'functions.c'
/* :set tabstops=4													*/
static char *RCSid = "$Header: functions.c,v 1.1 86/04/20 16:16:38 sysad Exp $";

/*
 * $Log:	functions.c,v $
 * Revision 1.1  86/04/20  16:16:38  sysad
 * Initial distribution version
 * 
 * 
 */


/* It is the intent of the author that this software may be distributed
 * and used freely, without restriction.  If you make improvements or
 * enhancements, I would appreciate a copy.
 *
 * Duane H. Hesser	Teltone Corporation
 * ....uw-beaver!tikal!sysad
 * ....uw-beaver!tikal!dhh
 */

#include "defs.h"
#include "extern.h"

space(x0,y0,x1,y1)
short x0,y0,x1,y1;
{
	static int noinit = 1;
	double tmp;

#ifdef DEBUG
	if(debug & 1) printf("space(%d,%d,%d,%d)\n",x0,y0,x1,y1);
#endif
	lowx_space = (double)x0;
	lowy_space = (double)y0;
	highx_space = (double)x1;
	highy_space = (double)y1;
	xspace = highx_space - lowx_space;
	yspace = highy_space - lowy_space;
	if(maxcol > XDOTS) maxcol = XDOTS;
	if(maxrow > YDOTS) maxrow = YDOTS;
#ifdef QUICKPLOT
	/* Autowrap can be a problem; some terminals and/or screen packages
	 * wrap early (i.e., they wrap when the last character is
	 * placed in the row, rather than waiting for the next character.
	 * Safest way seems to be to waste a column.
	 */
	if(autowrap) maxcol--;
#endif
	maxx = maxcol - 1;
	maxy = maxrow - 1;
	if(Rotate)
	{
		if(noinit)
		{
			noinit = 0;
			tmp = spacex;
			spacex = spacey;
			spacey = tmp;
			tmp = maxx;
			maxx = maxy;
			maxy = tmp;
			/* re-compute the margins */
			tmp = (Xmargin / XPERINCH) * YPERINCH;
			Xmargin = (Ymargin / YPERINCH) * XPERINCH;
			Ymargin = tmp;
		}
	}
	if(spacex > maxx) spacex = maxx;
	if(spacey > maxy) spacey = maxy;
	xfac = ( spacex/xspace ) * argxfac;
	yfac = ( spacey/yspace ) * argyfac;
	mapxfac = xfac * Scalfac;
	mapyfac = yfac * Scalfac;
#ifdef DEBUG
	if(debug &2)
	{
		printf("maxrow=%d,maxcol=%d,maxx=%d,maxy=%d\n",maxrow,maxcol,maxx,maxy);
		printf("xfac=%G,yfac=%G,mapxfac=%G,mapyfac=%G\n",xfac,yfac,mapxfac,mapyfac);
		printf("spacex=%G,spacey=%G,xspace=%G,yspace=%G\n",spacex,spacey,xspace,yspace);
	}
#endif
}

cont(x,y)
short x,y;
{
	x = (short)mapx(x);
	y = (short)mapy(y);
	make_line(curxdot,curydot,x,y);
	curxdot = x;
	curydot = y;
#ifdef DEBUG
	if(debug & 1) printf("cont(%d,%d)\n",curxdot,curydot);
#endif
}

move(x,y)
short x,y;
{
	curxdot = (short)mapx(x);
	curydot = (short)mapy(y);
#ifdef DEBUG
	if(debug & 1) printf("move(%d,%d)\n",curxdot,curydot);
#endif
}

line(x0,y0,x1,y1)
short x0,y0,x1,y1;
{
	x0 = (short)mapx(x0);
	x1 = (short)mapx(x1);
	y0 = (short)mapy(y0);
	y1 = (short)mapy(y1);
	make_line(x0,y0,x1,y1);
#ifdef DEBUG
	if(debug & 1) printf("line(%d,%d,%d,%d)\n",x0,y0,x1,y1);
#endif
	curxdot = x1;
	curydot = y1;
}

make_line(x0,y0,x1,y1)
short x0,y0,x1,y1;
{
	short xdots,ydots,i,j,signx,signy;
	double tanxy;
#ifdef QUICKPLOT
	char pc = plotchar;
#endif

	xdots = x1 - x0;
	ydots = y1 - y0;
	signx = (xdots > 0) ? 1 : -1;
	signy = (ydots > 0) ? 1 : -1;
	point(x0,y0);
	if(xdots == 0)
	{
		if(ydots == 0) return;
		for(i = signy; i != ydots; i += signy)
		{
#ifndef QUICKPLOT
			if(!(abs(i) & linemask)) continue;
#else
			if(abs(i) & 1) plotchar = linemask;
			else plotchar = pc;
#endif
			point(x0,y0 + i);
		}
	}
	else if(ydots == 0)
	{
		for(i = signx; i != xdots; i += signx)
		{
#ifndef QUICKPLOT
			if(!(abs(i) & linemask)) continue;
#else
			if(abs(i) & 1) plotchar = linemask;
			else plotchar = pc;
#endif
			point(x0 + i,y0);
		}
	}
	else if(abs(xdots) >= abs(ydots))
	{
		tanxy = (double)ydots / (double)xdots;
		for(i = signx; i != xdots; i += signx)
		{
#ifndef QUICKPLOT
			if(!(abs(i) & linemask)) continue;
#else
			if(abs(i) & 1) plotchar = linemask;
			else plotchar = pc;
#endif
			j = i * tanxy;
			point(x0 + i,y0 + j);
		}
	}
	else
	{
		tanxy = (double)xdots / (double)ydots;
		for(i = signy; i != ydots; i += signy)
		{
#ifndef QUICKPLOT
			if(!(abs(i) & linemask)) continue;
#else
			if(abs(i) & 1) plotchar = linemask;
			else plotchar = pc;
#endif
			j = i * tanxy;
			point(x0 + j,y0 + i);
		}
	}
	point(x1,y1);
#ifdef QUICKPLOT
	plotchar = pc;
#endif
}


circle(x,y,r)
short x,y,r;
{
	short x0;

	x0 = x + r;
	arc(x,y,x0,y,x0,y);
	move(x,y);
}

label(str,len)
char *str;
int len;
{
	int i;
	char *rp;

#ifdef DEBUG
	if(debug & 1) printf("label(%s,%d)\n",str,len);
#endif
	for(i=0; i < len && str[i] != '\n'; i++) 
	{
		if((str[i] < ' ') || (str[i] >= '\177')) continue;
#ifndef QUICKPLOT
		alpha_plot(str[i]);
#else
		if(Rotate)
		{
			rp = &Row[curxdot][maxy-curydot];
			if(*rp && (*rp != plotchar))  ++curxdot;
			Row[curxdot][maxy-curydot] = str[i];
		}
		else
		{
			rp = &Row[curydot][curxdot];
			if(*rp && (*rp != plotchar))  ++curxdot;
			Row[curydot][curxdot] = str[i];
		}
#endif
	}
}

#ifndef QUICKPLOT
point(x,y)
short x,y;
{
	short row,byte,bit;
	if(x > maxx)
	{
		x = maxx;
	}
	else if(x < 0)
	{
		x = 0;
	}
	if(y > maxy)
	{
		y = maxy;
	}
	else if(y < 0)
	{
		y = 0;
	}

	if(Rotate)
	{
		row = x;
		byte = (maxy - y) / 6;
		bit = 5 - (y % 6);
	}
	else
	{
		row = y;
		byte = x/6;
		bit = x%6;
	}
	Row[row][byte] |= BIT[bit];
}

#else QUICKPLOT

point(x,y)
short x,y;
{
	short row,col;
	char pc;

	pc = plotchar;
	if(x > maxx)
	{
		x = maxx;
		pc = '@';
	}
	else if(x < 0)
	{
		x = 0;
		pc = '@';
	}
	if(y > maxy)
	{
		y = maxy;
		pc = '@';
	}
	else if(y < 0)
	{
		y = 0;
		pc = '@';
	}

	if(Rotate)
	{
		row = x;
		col = maxy - y;
	}
	else
	{
		row = y;
		col = x;
	}
	if(!Row[row][col]) Row[row][col] = pc;
}
#endif QUICKPLOT

/* Make an arc with (x,y) as center, (x0,y0) as starting point,
 * and (x1,y1) as end point.
 *
 * The algorithm here is simpler than it looks; the intent is to
 * compute the points required just once in the first quadrant,
 * then reflect them across the axes or origin if they are required
 * in the other quadrants.
 * 1. Find the starting and ending quadrants.
 * 2. Verify the end point, and make sure it is on the arc thru (x0,y0)
 *    with center (x,Y).
 * 3. Determine which quadrants require points to be plotted.
 * 4. Determine the minimum and maximum "y" deltas in each quadrant.
 *    and set the starting point for line drawing in each quadrant.
 * 5. Pot the arc by incrementing the delta "y" and computing the
 *    corresponding "x" delta in the first quadrant.  Then check each
 *    quadrant to see if the corresponding point is needed, and draw a
 *    line from the last point plotted in that quadrant to the current
 *    point in that quadrant.
 */
#include <math.h>
arc(x,y,x0,y0,x1,y1)
short x,y,x0,y0,x1,y1;
{
	int i,ystart,ymax,dx,dy,sq,endq,nq;
	int q[4],qmin[4],qmax[4];
	short lx[4],ly[4],nx,ny,r,rx,ry;
	double asin(),sin(),cos(),ra,theta;

#ifdef DEBUG
	if(debug & 3)
		printf("to arc(%d,%d,%d,%d,%d,%d)\n",x,y,x0,y0,x1,y1);
#endif
	/* find starting quadrant										*/
	if(y0 >= y)
	{
		if(x0 > x) sq = 1;
		else if(y0 == y) sq = 3;
		else sq = 2;
	}
	else if(x0 >= x) sq = 4;
	else sq = 3;
	/* find ending quadrant											*/
	if(x1 >= x)
	{
		if(y1 > y) endq = 1;
		else if(x1 == x) endq = 3;
		else endq = 4;
	}
	else if(y1 >= y) endq = 2;
	else endq = 3;

	/* The calling program can easily pass a phony x1,y1 which
	 * doesn't lie on the arc thru x0,y0 with center x,y.
	 * Fix it.
	 */
	dx = abs(x0 - x); dy = abs(y0 - y);
	if(dx == 0)
	{
		if(dy == 0) return;	/* 0 radius; that's easy			*/
		r = dy;
	}
	else if(dy == 0) r = dx;
	else
	{
		r = sqrt(((double)dx * (double)dx) + ((double)dy * (double)dy));
		/* r should never be <= 0, unless integer truncation occurs	*/
		if(r <= 0) r = 1;
	}

	ra = (double)abs(y1 - y) / (double)r;
	theta = asin(ra);
	dx = r * cos(theta) + 0.5;
	dy = r * sin(theta) + 0.5;
	/* make sure these are positive									*/
	if((dx == 0) && (dy == 0)) return;
	r = abs((int)r);
	dx = abs(dx);
	dy = abs(dy);

	if(debug & 3) printf("dx=%d,dy=%d\n",dx,dy);
	if(endq & 2) x1 = x - dx;
	else x1 = x + dx;
	if(endq > 2) y1 = y - dy;
	else y1 = y + dy;
	if(debug & 3) printf("x1=%d,y1=%d\n",x1,y1);

	/* Map to device units.  Radius is mapped for both x direction
	 * and y direction because resolution differs in the two directions.
	 */
	x = (short)mapx(x);
	x0 = (short)mapx(x0);
	x1 = (short)mapx(x1);
	y = (short)mapy(y);
	y0 = (short)mapy(y0);
	y1 = (short)mapy(y1);
	rx = (short)(((double)r * mapxfac) + .01);
	ry = (short)(((double)r * mapyfac) + .01);

	/* Mark the quadrants which require plotting.
	 * Note that quadrants are numbered from 1-4, just like in math
	 * class, but the "q" arrays run from 0-3
	 */
	q[0] = q[1] = q[2] = q[3] = 0;
	if(sq <= endq)
	{
		for(i = sq; i <= endq; ++i)
		{
			++q[i - 1];
			nq++;		/* number of quadrants						*/
		}
	}
	else
	{
		for(i = sq; i <= 4; ++i)
		{
			++q[i - 1];
			nq++;
		}
		for(i = 1; i <= endq; ++i)
		{
			++q[i - 1];
			nq++;
		}
	}
	if(debug & 1)
	{
		printf("arc(%d,%d,%d,%d,%d,%d)\n",x,y,x0,y0,x1,y1);
		printf("(radius=%d,%d,%d)\n",r,rx,ry);;
	}

	/* find the min and max y increments							*/
	if(nq >= 3)
	{
		ystart = 0;
		ymax = ry;
	}
	else if(nq == 1)
	{
		if((sq == 1) || (sq == 3))
		{
			ystart = abs(y0 - y);
			ymax = abs(y1 - y);
		}
		else
		{
			ymax = abs(y0 - y);
			ystart = abs(y1 - y);
		}
	}
	else if((sq + endq) == 5)	/* 1 & 4 or 2 & 3					*/
	{
		ystart = 0;
		ymax = (abs(y0 - y) > abs(y1 - y)) ? abs(y0 - y) : abs(y1 - y);
	}
	else
	{
		ymax = ry;
		ystart = (abs(y0 - y) > abs(y1 - y)) ? abs(y1 - y) : abs(y0 - y);
	}
	/* now find the min and max y increments for each quadrant		*/
	if(q[0])		/* 1st quadrant									*/
	{
		if(sq == 1)
		{
			qmin[0] = y0 - y;
			ly[0] = y0;
			lx[0] = x0;
		}
		else
		{
			qmin[0] = 0;
			ly[0] = y;
			lx[0] = x + rx;
		}
		if(endq == 1) qmax[0] = y1 - y;
		else qmax[0] = ry;
	}
	if(q[1])		/* 2nd quadrant									*/
	{
		if(sq == 2)
		{
			qmax[1] = y0 - y;
		}
		else
		{
			qmax[1] = ry;
		}
		if(endq == 2)
		{
			qmin[1] = y1 - y;
			ly[1] = y1;
			lx[1] = x1;
		}
		else
		{
			qmin[1] = 0;
			ly[1] = y;
			lx[1] = x - rx;
		}
	}
	if(q[2])		/* 3rd	quadrant								*/
	{
		if(sq == 3)
		{
			qmin[2] = y - y0;
			ly[2] = y0;
			lx[2] = x0;
		}
		else
		{
			qmin[2] = 0;
			ly[2] = y;
			lx[2] = x - rx;
		}
		if(endq == 3)
		{
			qmax[2] = y - y1;
		}
		else
		{
			qmax[2] = ry;
		}
	}
	if(q[3])		/* 4th quadrant									*/
	{
		if(sq == 4)
		{
			qmax[3] = y - y0;
		}
		else
		{
			qmax[3] = ry;
		}
		if(endq == 4)
		{
			qmin[3] = y - y1;
			ly[3] = y1;
			lx[3] = x1;
		}
		else
		{
			qmin[3] = 0;
			ly[3] = y;
			lx[3] = x + rx;
		}
	}
#ifdef DEBUG
	if(debug & 3)
	{
		printf("sq=%d,endq=%d,ystart=%d,ymax=%d\n",sq,endq,ystart,ymax);
		printf("q\t  min \t  max \t  lx  \t  ly\n");
		for(i=0; i < 4; ++i)
		{
			if(q[i])
				printf("%d\t%d\t%d\t%d\t%d\n",i+1,qmin[i],qmax[i],lx[i],ly[i]);
		}
	}
#endif DEBUG
	/* finally ready to plot										*/
	for(i = ystart; i <= ymax; ++i)
	{
		ra = ry ? (double)i / (double)ry: 0;
		theta = asin(ra);
		dx = (double)rx * cos(theta) + 0.5;
		if(q[0] && (i >= qmin[0]) && (i <= qmax[0]))
		{
			nx = x + dx;
			ny = y + i;
			make_line(lx[0],ly[0],nx,ny);
			lx[0] = nx;
			ly[0] = ny;
		}
		if(q[1] && (i >= qmin[1]) && (i <= qmax[1]))
		{
			nx = x - dx;
			ny = y + i;
			make_line(lx[1],ly[1],nx,ny);
			lx[1] = nx;
			ly[1] = ny;
		}
		if(q[2] && (i >= qmin[2]) && (i <= qmax[2]))
		{
			nx = x - dx;
			ny = y - i;
			make_line(lx[2],ly[2],nx,ny);
			lx[2] = nx;
			ly[2] = ny;
		}
		if(q[3] && (i >= qmin[3]) && (i <= qmax[3]))
		{
			nx = x + dx;
			ny = y - i;
			make_line(lx[3],ly[3],nx,ny);
			lx[3] = nx;
			ly[3] = ny;
		}
	}
}
SHAR_EOF
if test 11457 -ne "`wc -c < 'functions.c'`"
then
	echo shar: error transmitting "'functions.c'" '(should have been 11457 characters)'
fi
fi
echo shar: extracting "'global.c'" '(2962 characters)'
if test -f 'global.c'
then
	echo shar: will not over-write existing file "'global.c'"
else
cat << \SHAR_EOF > 'global.c'
/* :set tabstops=4													*/
static char *RCSid = "$Header: global.c,v 1.1 86/04/20 16:16:41 sysad Exp $";

/*
 * $Log:	global.c,v $
 * Revision 1.1  86/04/20  16:16:41  sysad
 * Initial distribution version
 * 
 * 
 */


/* It is the intent of the author that this software may be distributed
 * and used freely, without restriction.  If you make improvements or
 * enhancements, I would appreciate a copy.
 *
 * Duane H. Hesser	Teltone Corporation
 * ....uw-beaver!tikal!sysad
 * ....uw-beaver!tikal!dhh
 */

#include "defs.h"
#include "io.h"

/* This is the output array; it should be big enough for the largest
 * "raster" which will be used (currently the full size of an 11 x 13.2
 * inch line printer page).
 */
char Row[YDOTS][XARRAYSIZE];
#ifndef QUICKPLOT
/* These are the bits which are or'ed into the output array to acivate
 * the appropriate hammers.
 */
char BIT[] = {
	'\001','\002','\004','\010','\020','\040','\100','\0'
};
#else
char plotchar = PLOTCHAR;
int autowrap = 0;			/* does the terminal auto-wrap at eol?	*/
#endif

/* Initially, we map everything into an 8 inch square for lplot,
 * or into a 132 wide x 66 line "screen" for quickplot.  The 8 inch
 * square for lplot is consistent with scaling for things like
 * "vplot" which plot onto an 8 1/2 x 11 inch page.
 * The values initialized may be changed (within array size limits
 * by program arguments, and will take effect at the first space()
 * call.
 */
double spacex = SPACEX;
double spacey = SPACEY;

/* These are the program units which will map into spacex & spacey
 * after the space() call.
 */
double xspace,yspace;

/* min and max points mapped into the plotting space by space()		*/
double highx_space,highy_space,lowx_space,lowy_space;

/* maximum dots each direction; truncate larger values.				*/
int maxrow = YDOTS;
int maxcol = XDOTS;
/* maximum x and y values; generally one less than maxrow, maxcol	*/
int maxx = MAXX;
int maxy = MAXY;

/* current coordinates in program units and dots					*/
short curx,cury,curxdot,curydot;

double Scalfac = 1.0;			/* settable overall scale factor	*/
double xfac = 1.0;				/* scale factor for x				*/
double yfac = 1.0;				/* scale factor for y				*/
double argxfac = 1.0;			/* argument scale factor for x		*/
double argyfac = 1.0;			/* argument scale factor for y		*/
double mapxfac = 1.0;			/* final mapping factor for x 		*/
double mapyfac = 1.0;			/* final mapping factor for y		*/
double Xmargin = 0.0;			/* settable left margin in pixels	*/
double Ymargin = 0.0;			/* settable bottom margin in pixels	*/

int Plotdata = 0;				/* set when raster is ready to send	*/
int Eflag = 0;					/* force erase before each plot		*/
int Nflag = 0;					/* suppress erasing while in effect	*/
#ifdef QUICKPLOT
int linemask = PLOTCHAR;		/* solid, dotted, dashed, etc.		*/
#else
int linemask = SOLID;			/* solid, dotted, dashed, etc.		*/
#endif

char *Name;
int debug = 0;

#ifndef QUICKPLOT
int Npages = 0;
#endif
int Rotate = 0;
SHAR_EOF
if test 2962 -ne "`wc -c < 'global.c'`"
then
	echo shar: error transmitting "'global.c'" '(should have been 2962 characters)'
fi
fi
echo shar: extracting "'iobuf.c'" '(2781 characters)'
if test -f 'iobuf.c'
then
	echo shar: will not over-write existing file "'iobuf.c'"
else
cat << \SHAR_EOF > 'iobuf.c'
/* :set tabstops=4													*/
static char *RCSid = "$Header: iobuf.c,v 1.1 86/04/20 16:16:43 sysad Exp $";

/*
 * $Log:	iobuf.c,v $
 * Revision 1.1  86/04/20  16:16:43  sysad
 * Initial distribution version
 * 
 * 
 */

/* An utterly simple buffering scheme; it's all we need.			*/

/* It is the intent of the author that this software may be distributed
 * and used freely, without restriction.  If you make improvements or
 * enhancements, I would appreciate a copy.
 *
 * Duane H. Hesser	Teltone Corporation
 * ....uw-beaver!tikal!sysad
 * ....uw-beaver!tikal!dhh
 */

#include	"io.h"

bufopen(file,io)
char *file;
struct inbuf *io;
{

	if((io->fd = open(file,0)) < 0)
		return(-1);
	io->nleft = 0;
	io->eof = 0;
	return(io->fd);
}

bufclose(io)
struct inbuf *io;
{
	if(io->fd >= 0) close(io->fd);
	io->eof = 1;
	io->nleft = 0;
	io->fd = -1;
}

char
getbyte(io)
struct inbuf *io;
{
	char next,ebuf[32];

	if(io->nleft <= 0)
	{
		if(io->fd < 0)
		{
			sprintf(ebuf,"%s: unopen file error in getbyte()\n");
			write(2,ebuf,strlen(ebuf));
			exit(69);
		}
		io->nleft = read(io->fd,io->buff,INBUFSIZE);
		if(io->nleft < 0)
		{
			sprintf(ebuf,"%s: read error in getbyte()\n");
			write(2,ebuf,strlen(ebuf));
			exit(69);
		}
		io->nextp = io->buff;
	}
	if(io->nleft-- <= 0)
	{
		io->eof++;
		return('\0');
	}
	next = *(io->nextp++) & '\377';
	return(next);
}



getstr(io,buf)
struct inbuf *io;
char *buf;
{
	char *ptr = buf;
	char getbyte();

	while( *ptr = getbyte(io) )
	{
		if(*ptr++ == '\n')
		{
			*--ptr = '\0';
			break;
		}
	}
	return(strlen(buf));
}


#ifdef BIGENDIAN
union {
	short sh_word;
	struct {
		char hi_byte;
		char lo_byte;
	} sh_bytes;
} sh;
#else
union {
	short sh_word;
	struct {
		char lo_byte;
		char hi_byte;
	} sh_bytes;
} sh;
#endif
short
getshort(io)
struct inbuf *io;
{
	char c,ebuf[32];

	c = getbyte(io);
	if(eof(io))
	{
		sprintf(ebuf,"unexpected EOF in getshort()\n");
		write(2,ebuf,strlen(ebuf));
		exit(69);
	}
	else sh.sh_bytes.lo_byte = c;

	c = getbyte(io);
	if(eof(io))
	{
		sprintf(ebuf,"unexpected EOF in getshort()\n");
		write(2,ebuf,strlen(ebuf));
		exit(69);
	}
	else sh.sh_bytes.hi_byte = c;
	return(sh.sh_word);
}

eof(source)
struct inbuf *source;
{
	return(source->eof);
}


/* Note that we don't even bother to "open" for output; just use
 * file descriptor 1 (normally stdout)
 */
bufwrite(from,len,outbuf)
char *from;
int len;
struct outbuf *outbuf;
{
	if(len <= 0) return;
	if((len + outbuf->datalen) > OUTBUFSIZE) buf_flush(outbuf);
	bcopy(from,outbuf->nextp,len);
	outbuf->datalen += len;
	outbuf->nextp += len;
	if((len + outbuf->datalen) >= OUTBUFSIZE) buf_flush(outbuf);
}

buf_flush(buf)
struct outbuf *buf;
{
	if(buf->datalen > 0) write(1,buf->buffer,buf->datalen);
	buf->nextp = buf->buffer;
	buf->datalen = 0;
}
SHAR_EOF
if test 2781 -ne "`wc -c < 'iobuf.c'`"
then
	echo shar: error transmitting "'iobuf.c'" '(should have been 2781 characters)'
fi
fi
echo shar: extracting "'lplot.c'" '(7614 characters)'
if test -f 'lplot.c'
then
	echo shar: will not over-write existing file "'lplot.c'"
else
cat << \SHAR_EOF > 'lplot.c'
/* :set tabstops=4													*/
static char *RCSid = "$Header: lplot.c,v 1.1 86/04/20 16:16:46 sysad Exp $";

/*
 * $Log:	lplot.c,v $
 * Revision 1.1  86/04/20  16:16:46  sysad
 * Initial distribution version
 * 
 * 
 */


/* LPLOT and QUICKPLOT -- main program.
 * This file handles initialization (mostly argument gathering),
 * calls the plot function to fill the output array, then processes
 * the array and outputs it.
 */

/* It is the intent of the author that this software may be distributed
 * and used freely, without restriction.  If you make improvements or
 * enhancements, I would appreciate a copy.
 *
 * Duane H. Hesser	Teltone Corporation
 * ....uw-beaver!tikal!sysad
 * ....uw-beaver!tikal!dhh
 */

#include "extern.h"
#ifdef DEBUG
#include <stdio.h>
#endif


main(argc,argv)
int argc;
char **argv;
{
	extern void onintr();
	extern int read_stream();
	struct inbuf src;
	int files = 0;
	double atof();
#ifndef QUICKPLOT
	char *user, *host, *actfile;
#endif

	Name = argv[0];
	++argv;
#ifdef DEBUG
	setbuf(stdout,(char *)0);
#endif
#ifndef QUICKPLOT
	if(strcmp(Name,"rlplot") == 0)
	{
		++Rotate;
	}
#endif


	Eflag = 1;
#ifdef QUICKPLOT
	getsize((char *)0);				/* get the size of the terminal */
#else
	user = host = actfile = (char *)0;
#endif
	while(--argc) 
	{
		if(argv[0][0] == '-')
		{
			switch(argv[0][1])
			{
#ifdef QUICKPLOT
			case 'T':	/* size for a specific terminal				*/
				getsize(argv[1]);
				--argc;
				++argv;
				break;
			case 'c':	/* select plotting character				*/
				plotchar = *argv[1];
				--argc;
				++argv;
				break;
#endif
			case 'r':	/* rotate entire plot 90 degrees			*/
				++Rotate;
				break;
			case 'W':
				maxcol = atoi(argv[1]);
				--argc;
				++argv;
				break;
			case 'H':
				maxrow = atoi(argv[1]);
				--argc;
				++argv;
				break;
			case 'X':	/* move the whole plot horizontally			*/
#ifdef QUICKPLOT
				Xmargin = atof(argv[1]);				/* columns	*/
#else
				Xmargin = atof(argv[1]) * XPERINCH;		/* inches	*/
#endif
				--argc;
				++argv;
				break;
			case 'Y':	/* move the whole plot vertically			*/
#ifdef QUICKPLOT
				Ymargin = atof(argv[1]);				/* rows		*/
#else
				Ymargin = atof(argv[1]) * YPERINCH;		/* inches	*/
#endif
				--argc;
				++argv;
				break;
			case 's':	/* request x, y, or overall scale factors	*/
				if(argv[0][2] == '\0')
					Scalfac = atof(argv[1]);
				else if(argv[0][2] == 'x')
					argxfac = atof(argv[1]);
				else if(argv[0][2] == 'y')
					argyfac = atof(argv[1]);
				--argc;
				++argv;
				break;
			case 'e':	/* force erase before each file is plotted	*/
				++Eflag;
				Nflag = 0;
				break;
			case 'N':	/* suppress erasing							*/
				++Nflag;
				Eflag = 0;
				break;
#ifndef QUICKPLOT
			case 'x':	/* get width in pixels (from lpr)			*/
				maxcol = atoi(&argv[0][2]);
				break;
			case 'y':	/* get hieght in pixels (from lpr)			*/
				maxrow = atoi(&argv[0][2]);
				break;
			case 'n':	/* get user (from lpr) for accounting		*/
				user = argv[1];
				++argv;
				--argc;
				break;
			case 'h':	/* get host and accounting file (from lpr)	*/
				host = argv[1];
				++argv; --argc;
				actfile = argv[2];
				--argc; ++argv;
				break;
#endif
#ifdef DEBUG
			case 'd':	/* debug									*/
				debug = atoi(argv[1]);
				++argv;
				--argc;
				break;
#endif
			case '\0':	/* read standard input here					*/
				src.fd = 0;
				src.nleft = 0;
				src.eof = 0;
				lplot(&src);
				if(Plotdata && Eflag) output();
				bufclose(&src);
				break;
			default:
				break;
			}
		}
		else		/* file argument								*/
		{
			if(bufopen(argv[0],&src) < 0) 
			{
				char ebuf[64];
				sprintf(ebuf,"%s: can't open input %s\n",Name,argv[0]);
				write(2,ebuf,strlen(ebuf));
				exit(1);
			}
			lplot(&src);
			if(Plotdata && Eflag) output();
			bufclose(&src);
			files++;
		}
		argv++;
	}
	Nflag = 0;
	if(files == 0)	/* no file arguments given; read stdin			*/
	{
		src.fd = 0;
		src.nleft = 0;
		src.eof = 0;
		lplot(&src);
	}
	if(Plotdata) output();	/* force out anything that may be left	*/
#ifndef QUICKPLOT
	if(actfile && *actfile && (access(actfile,02) == 0))
	{
		int fda = open(actfile,1);
		char abuf[32];
		if(fda < 0) exit(0);
		if(!user || !*user) user = "lplot";
		if(!host || !*host) host = "unknown";
		sprintf(abuf,"%7.2f\t%s:%s\n", (float)Npages, host, user);
		write(fda,abuf,strlen(abuf));
	}
#endif
	exit(0);
}

lplot(source)
struct inbuf *source;
{
	int got;
	/* This next is a hack to suppress an initial "erase" command,
	 * (as "graph(1)" is so fond of issuing) before there is anything
	 * to plot.  If there is plot data, the erase will force it out.
	 * After the first page is printed, an erase will be honored
	 * unconditionally (unless erasing is suppressed with '-N').
	 */
	static int firstplot = 1;

	while( (got = read_stream(source)))
	{
#ifdef DEBUG
		if(debug & 2) printf("got=%ld,Plotdata=%d\n",got,Plotdata);
#endif
		/* got = -1 means no plot cmds except erase					*/
		if((got == -1) && !Nflag && !Plotdata)
		{
			if(!firstplot)
				write(1,"\014",1);
			continue;
		}
		Plotdata++;				/* there is something to plot		*/
		firstplot = 0;
		if(!Nflag && got < 0)	/* erase command received			*/
			output();
	}
}

/* Send the plot data to stdout.  The data are processed by rows,
 * each of which is treated as a string.  We don't send nulls at
 * the end of the string, but we must fill in null bytes before
 * the last byte in the row which contains data.  For lplot, we
 * must set bit 6 ('\100') to make the byte valid for plotting;
 * for quickplot, null bytes need to be spaces.
 */
output()
{
	int y,len,maxc;
	char c;
	struct outbuf outbuf;

	outbuf.datalen = 0;
	outbuf.nextp = outbuf.buffer;

#ifdef QUICKPLOT
	maxc = maxcol;
#else
	maxc = (maxcol + 5)/6;
#endif
#ifdef DEBUG
	if(debug & 2) printf("output:maxc=%d\n",maxc);
#endif

	for(y = maxrow - 1; y >= 0; --y)
	{
		char *row = Row[y];
		char *end = &row[maxc];

		/* make sure the string is terminated 						*/
		*end-- = '\0';

		/* find the last non-null byte in the row					*/
		while(!*end && (end >= row))	end--;
		len = end - row + 1;
#ifdef DEBUG
		if(debug & 4) printf("row[%d]=%d bytes\n",y,len);
#endif

#ifndef QUICKPLOT
		/* set bit 6 in all bytes to be transmitted					*/
		while(end >= row) *end-- |= BIT[6]; 
		Row[y][len++] = GRAPHICSCHAR;
		Row[y][len++] = '\n';
		Row[y][len] = '\0';
#else
		/* just send a space for quickplot							*/
		while(end >= row) if(!*end) *end-- = ' '; else --end;
		len = strlen(Row[y]);
		/* leave cursor lower right									*/
		if(y)
		{
			strcat(Row[y],"\n");
			++len;
		}
#endif
		bufwrite(Row[y],len,&outbuf);
#ifdef DEBUG
		if(debug & 4) buf_flush(&outbuf);
#endif
		bzero(Row[y],XARRAYSIZE);	/* clear the array for next plot */
	}
	Plotdata = 0;
	buf_flush(&outbuf);
#ifdef QUICKPLOT
	/* Pause after each plot unless output is redirected.
	 * Read from the error channel because we might be reading
	 * plot data from stdin.
	 */
	if(isatty(1) && isatty(2)) read(2,&c,1);
	else write(1,"\n",1);
#else
	/* for accounting, one page per plot							*/
	Npages++;
#endif
}

#ifdef QUICKPLOT
/* get the size of the terminal from the environment				*/
getsize(term)
char *term;
{
	char *terminal,termbuf[1024],*getenv();
	int cols,lines;

	/* set defaults													*/
	maxcol = cols = XDOTS;
	maxrow = lines = YDOTS;

	if(!term) terminal = getenv("TERM");
	else terminal = term;

	if((terminal)  && (tgetent(termbuf,terminal) == 1))
	{
		cols = tgetnum("co");
		if(cols > 0) maxcol = cols;
		lines = tgetnum("li");
		if(lines > 0) maxrow = lines;
		autowrap = tgetflag("am");
	}
	spacex = maxcol;
	spacey = maxrow;
}
#endif QUICKPLOT
SHAR_EOF
if test 7614 -ne "`wc -c < 'lplot.c'`"
then
	echo shar: error transmitting "'lplot.c'" '(should have been 7614 characters)'
fi
fi
echo shar: extracting "'read_stream.c'" '(3320 characters)'
if test -f 'read_stream.c'
then
	echo shar: will not over-write existing file "'read_stream.c'"
else
cat << \SHAR_EOF > 'read_stream.c'
/* :set tabstops=4													*/
static char *RCSid = "$Header: read_stream.c,v 1.1 86/04/20 16:16:49 sysad Exp $";

/*
 * $Log:	read_stream.c,v $
 * Revision 1.1  86/04/20  16:16:49  sysad
 * Initial distribution version
 * 
 * 
 */


/* It is the intent of the author that this software may be distributed
 * and used freely, without restriction.  If you make improvements or
 * enhancements, I would appreciate a copy.
 *
 * Duane H. Hesser	Teltone Corporation
 * ....uw-beaver!tikal!sysad
 * ....uw-beaver!tikal!dhh
 */

#include "defs.h"
#include "extern.h"

read_stream(source)
struct inbuf *source;
{
	char c;
	char string[256],ebuf[64];
	int len,got;
	short x0,y0,x1,y1,r;
	char getbyte();
	short getshort();

	got = 0;
#ifdef QUICKPLOT
	linemask = plotchar;
#endif
	while((c = getbyte(source)) && !eof(source))
	{
		++got;
		switch(c)
		{
			case 'm':
				curx = getshort(source);
				cury = getshort(source);
				move(curx,cury);
				break;
			
			case 'n':
				curx = getshort(source);
				cury = getshort(source);
				cont(curx,cury);
				break;
			
			case 'p':
				curx = getshort(source);
				cury = getshort(source);
				move(curx,cury);
				point(curxdot,curydot);
				break;
			
			case 'l':
				x1 = getshort(source);
				y1 = getshort(source);
				curx = getshort(source);
				cury = getshort(source);
				line(x1,y1,curx,cury);
				break;
			
			case 't':
				len = getstr(source,string);
				label(string,len);
				break;
			
			case 'a':
				curx = getshort(source);
				cury = getshort(source);
				x0 = getshort(source);
				y0 = getshort(source);
				x1 = getshort(source);
				y1 = getshort(source);
				arc(curx,cury,x0,y0,x1,y1);
				/* The manual doesn't specify this, but it seems
				 * the most reasonable thing to do.
				 */
				move(curx,cury);
				break;
			
			case 'c':
				x1 = getshort(source);
				y1 = getshort(source);
				r = getshort(source);
				circle(x1,y1,r);
				/* (x1,y1) becomes current point					*/
				break;
			
			case 'e':
				return(-got); /* negative got triggers erase		*/
				break;
			break;
			
			case 'f':
				--got;
				len = getstr(source,string);
				if(!len) break;

#ifdef DEBUG
				if(debug & 1) printf("linemask=%s",string);
#endif
#ifdef QUICKPLOT
				if(strcmp(string,"solid") == 0)
					linemask = plotchar;
				else if(strcmp(string,"dotted") == 0)
					linemask = '2';
				else if(strcmp(string,"shortdashed") == 0)
					linemask = '3';
				else if(strcmp(string,"longdashed") == 0)
					linemask = '4';
				else if(strcmp(string,"dotdashed") == 0)
					linemask = '5';
				break;
#else
				if(strcmp(string,"solid") == 0)
					linemask = SOLID;
				else if(strcmp(string,"dotted") == 0)
					linemask = DOTTED;
				else if(strcmp(string,"shortdashed") == 0)
					linemask = SHORTDASHED;
				else if(strcmp(string,"longdashed") == 0)
					linemask = LONGDASHED;
				else if(strcmp(string,"dotdashed") == 0)
					linemask = DOTDASHED;
				break;
#endif QUICKPLOT
			
			case 's':
				--got;
				x0 = getshort(source);
				y0 = getshort(source);
				x1 = getshort(source);
				y1 = getshort(source);
				space(x0,y0,x1,y1);
				break;
			default:
				--got;
				sprintf(ebuf,"bad input data: cmd (0%o)\n",c);
				write(2,ebuf,strlen(ebuf));
				break;
		}
	}
	/* return the number of commands decoded						*/
	return(--got > 0 ? got : 0);
}

SHAR_EOF
if test 3320 -ne "`wc -c < 'read_stream.c'`"
then
	echo shar: error transmitting "'read_stream.c'" '(should have been 3320 characters)'
fi
fi
echo shar: extracting "'defs.h'" '(2516 characters)'
if test -f 'defs.h'
then
	echo shar: will not over-write existing file "'defs.h'"
else
cat << \SHAR_EOF > 'defs.h'
/* :set tabstop=4													*/
/*
 * $Header: defs.h,v 1.1 86/04/20 16:16:52 sysad Exp $
 */

/*
 * $Log:	defs.h,v $
 * Revision 1.1  86/04/20  16:16:52  sysad
 * Initial distribution version
 * 
 * 
 */


/* It is the intent of the author that this software may be distributed
 * and used freely, without restriction.  If you make improvements or
 * enhancements, I would appreciate a copy.
 *
 * Duane H. Hesser	Teltone Corporation
 * ....uw-beaver!tikal!sysad
 * ....uw-beaver!tikal!dhh
 */

#ifndef QUICKPLOT
#define	GRAPHICSCHAR	'\005'	/* puts printer in graphics mode	*/
#define	XPERINCH	((double)60.0)		/* horizontal dot density	*/
#define	YPERINCH	((double)72.0)		/* vertical dot density		*/
#define	SPACEX	((8 * XPERINCH) - 1)	/* dots for 8 inch plot area*/
#define	SPACEY	((8 * YPERINCH)	- 1)	/* dots for 8 inch plot area*/
#define	XDOTS	792				/* maximum possible horizontal dots	*/
/* we lose 12 dots vertically with the print head positioned for
 * printing on the first line in ascii mode
 */
#define	YDOTS	780				/* maximum possible vertical dots	*/
#define	XBYTES	(XDOTS/6)		/* bytes needed for XDOTS			*/
#define	MAXX	(XDOTS - 1)		/* maximum plottable x value		*/
#define	MAXY	(YDOTS - 1)		/* maximum plottable y value		*/
#else
#define	PLOTCHAR	'X'			/* use this char for plotting		*/
#define	XPERINCH	((double)10.0)		/* horizontal dot density	*/
#define	YPERINCH	((double)6.0)		/* vertical dot density		*/
#define	SPACEX	((8 * XPERINCH) - 1)	/* dots for 8 inch plot area*/
#define	SPACEY	((8 * YPERINCH)	- 1)	/* dots for 8 inch plot area*/
#define	XDOTS	132				/* maximum possible horizontal dots	*/
#define	YDOTS	66				/* maximum possible vertical dots	*/
#define	XBYTES	(XDOTS)			/* horizontal dimension of array	*/
#define	MAXX	(XDOTS - 1)		/* maximum plottable x value		*/
#define	MAXY	(YDOTS - 1)		/* maximum plottable y value		*/
#endif

/* Horizontal dimension of Row array.
 * Add 1 byte for a null, 1 for LF, 1 for graphics byte
 */
#define	XARRAYSIZE	(XBYTES + 3)

/* Linemode masks; used in make_line() for lplot					*/
#define	SOLID 0177777
#define	DOTTED 001
#define	SHORTDASHED 003
#define	DOTDASHED 013
#define	LONGDASHED 007

#ifndef QUICKPLOT
#define	mapx(x)	((((double)x - lowx_space) * mapxfac) + Xmargin + 0.5)
#define	mapy(y)	((((double)y - lowy_space) * mapyfac) + Ymargin + 0.5)
#define	plotbit(x,a)	(x & (1 << a))
#else
#define	mapx(x)	((((double)x - lowx_space) * mapxfac) + Xmargin + 0.01)
#define	mapy(y)	((((double)y - lowy_space) * mapyfac) + Ymargin + 0.01)
#endif
SHAR_EOF
if test 2516 -ne "`wc -c < 'defs.h'`"
then
	echo shar: error transmitting "'defs.h'" '(should have been 2516 characters)'
fi
fi
echo shar: extracting "'extern.h'" '(1193 characters)'
if test -f 'extern.h'
then
	echo shar: will not over-write existing file "'extern.h'"
else
cat << \SHAR_EOF > 'extern.h'
/* :set tabstop=4													*/
/*
 * $Header: extern.h,v 1.1 86/04/20 16:17:03 sysad Exp $
 */

/*
 * $Log:	extern.h,v $
 * Revision 1.1  86/04/20  16:17:03  sysad
 * Initial distribution version
 * 
 * 
 */


/* It is the intent of the author that this software may be distributed
 * and used freely, without restriction.  If you make improvements or
 * enhancements, I would appreciate a copy.
 *
 * Duane H. Hesser	Teltone Corporation
 * ....uw-beaver!tikal!sysad
 * ....uw-beaver!tikal!dhh
 */

#include "defs.h"
#include "io.h"
extern char Row[][XARRAYSIZE];
#ifndef QUICKPLOT
extern char BIT[];
#else
extern char plotchar;
extern int autowrap;
#endif

extern double spacex,spacey;
extern double xspace,yspace;
extern double lowx_space,highx_space,lowy_space,highy_space;
extern int maxx,maxy,maxrow,maxcol;

extern short curx,cury,curxdot,curydot;
extern double Scalfac,xfac,yfac,argxfac,argyfac;
extern double mapxfac,mapyfac;
extern double Xmargin,Ymargin;

extern int Plotdata;
extern int Eflag;
extern int Nflag;
extern int linemask;

extern char *Name;
#ifdef DEBUG
extern int debug;
#endif
extern int Rotate;

#ifndef QUICKPLOT
extern int Npages;
extern char table[][10];
#endif
SHAR_EOF
if test 1193 -ne "`wc -c < 'extern.h'`"
then
	echo shar: error transmitting "'extern.h'" '(should have been 1193 characters)'
fi
fi
echo shar: extracting "'io.h'" '(701 characters)'
if test -f 'io.h'
then
	echo shar: will not over-write existing file "'io.h'"
else
cat << \SHAR_EOF > 'io.h'
/* :set tabstop=4													*/
/*
 * $Header: io.h,v 1.1 86/04/20 16:17:06 sysad Exp $
 */

/*
 * $Log:	io.h,v $
 * Revision 1.1  86/04/20  16:17:06  sysad
 * Initial distribution version
 * 
 * 
 */


/* It is the intent of the author that this software may be distributed
 * and used freely, without restriction.  If you make improvements or
 * enhancements, I would appreciate a copy.
 *
 * Duane H. Hesser	Teltone Corporation
 * ....uw-beaver!tikal!sysad
 * ....uw-beaver!tikal!dhh
 */

#define	INBUFSIZE	2048
#define	OUTBUFSIZE	2048

struct inbuf
{
	int fd;
	int nleft;
	int eof;
	char *nextp;
	char buff[INBUFSIZE];
};

struct outbuf {
	int datalen;
	char *nextp;
	char buffer[OUTBUFSIZE];
};
SHAR_EOF
if test 701 -ne "`wc -c < 'io.h'`"
then
	echo shar: error transmitting "'io.h'" '(should have been 701 characters)'
fi
fi
if test ! -d 'testprogs.d'
then
	echo shar: creating directory "'testprogs.d'"
	mkdir 'testprogs.d'
fi
echo shar: extracting "'testprogs.d/Makefile'" '(497 characters)'
if test -f 'testprogs.d/Makefile'
then
	echo shar: will not over-write existing file "'testprogs.d/Makefile'"
else
cat << \SHAR_EOF > 'testprogs.d/Makefile'
all:	box circle lineh linev lined dlined arc

arc:	arc.c
	cc -o arc arc.c -lplot -lm

box:	box.c
	cc -o box box.c -lplot

circle:	circle.c
	cc -o circle circle.c -lplot -lm

lineh:	lineh.c
	cc -o lineh lineh.c -lplot

linev:	linev.c
	cc -o linev linev.c -lplot

lined:	lined.c
	cc -o lined lined.c -lplot

dlined:	dlined.c
	cc -o dlined dlined.c -lplot

graphplot:
	grplot
	@echo 'type "quickplot tmpload" or "lplot tmpload | lpr -v"'
clean:
	rm -f box circle lineh linev lined tmpload dlined arc
SHAR_EOF
if test 497 -ne "`wc -c < 'testprogs.d/Makefile'`"
then
	echo shar: error transmitting "'testprogs.d/Makefile'" '(should have been 497 characters)'
fi
fi
echo shar: extracting "'testprogs.d/lined.c'" '(270 characters)'
if test -f 'testprogs.d/lined.c'
then
	echo shar: will not over-write existing file "'testprogs.d/lined.c'"
else
cat << \SHAR_EOF > 'testprogs.d/lined.c'
/* diagaonal line lower left to upper right */
main(argc,argv)
int argc;
char **argv;
{
	int x0,x1,y0,y1;

	x0 = 0;
	y0 = 0;
	x1 = 2000;
	y1 = 2000;
	space(x0,y0,2000,2000);
	move(x0,y0);
	label("+");
	move(x1,y1);
	label("+");
	line(x0,y0,x1,y1);
	erase();
	exit(0);
}
SHAR_EOF
if test 270 -ne "`wc -c < 'testprogs.d/lined.c'`"
then
	echo shar: error transmitting "'testprogs.d/lined.c'" '(should have been 270 characters)'
fi
fi
echo shar: extracting "'testprogs.d/linev.c'" '(273 characters)'
if test -f 'testprogs.d/linev.c'
then
	echo shar: will not over-write existing file "'testprogs.d/linev.c'"
else
cat << \SHAR_EOF > 'testprogs.d/linev.c'
/* vertical line along left side of plot space */
main(argc,argv)
int argc;
char **argv;
{
	int x0,x1,y0,y1;

	x0 = 0;
	y0 = 0;
	x1 = 2000;
	y1 = 2000;
	space(x0,y0,2000,2000);
	move(x0,y0);
	label("+");
	move(x0,y1);
	label("+");
	line(x0,y0,x0,y1);
	erase();
	exit(0);
}
SHAR_EOF
if test 273 -ne "`wc -c < 'testprogs.d/linev.c'`"
then
	echo shar: error transmitting "'testprogs.d/linev.c'" '(should have been 273 characters)'
fi
fi
echo shar: extracting "'testprogs.d/box.c'" '(373 characters)'
if test -f 'testprogs.d/box.c'
then
	echo shar: will not over-write existing file "'testprogs.d/box.c'"
else
cat << \SHAR_EOF > 'testprogs.d/box.c'
/* box surrounding plot space--no args */

main(argc,argv)
int argc;
char **argv;
{
	int x0,x1,y0,y1;

	x0 = 0;
	y0 = 0;
	x1 = 2000;
	y1 = 2000;
	space(x0,y0,x1,y1);

	move(x0,y0);
	label("1");
	move(x0,y1);
	label("2");
	move(x1,y1);
	label("3");
	move(x1,y0);
	label("4");
	move(x0,y0);
	line(x0,y0,x0,y1);
	cont(x1,y1);
	cont(x1,y0);
	cont(x0,y0);
	erase();
	exit(0);
}
SHAR_EOF
if test 373 -ne "`wc -c < 'testprogs.d/box.c'`"
then
	echo shar: error transmitting "'testprogs.d/box.c'" '(should have been 373 characters)'
fi
fi
echo shar: extracting "'testprogs.d/dlined.c'" '(475 characters)'
if test -f 'testprogs.d/dlined.c'
then
	echo shar: will not over-write existing file "'testprogs.d/dlined.c'"
else
cat << \SHAR_EOF > 'testprogs.d/dlined.c'
/* with no args, gives dotted diagaonal line. one optional argument is
 * permitted to change line mode.  permitted modes are:
 *	solid
 *	dotted
 *  shortdashed
 *  longdashed
 *  dotdashed
 */
main(argc,argv)
int argc;
char **argv;
{
	int x0,x1,y0,y1;

	x0 = 0;
	y0 = 0;
	x1 = 2000;
	y1 = 2000;
	space(x0,y0,2000,2000);
	if(argc > 1) linemod(argv[1]);
	else linemod("dotted");
	move(x0,y0);
	label("+");
	move(x1,y1);
	label("+");
	line(x0,y0,x1,y1);
	erase();
	exit(0);
}
SHAR_EOF
if test 475 -ne "`wc -c < 'testprogs.d/dlined.c'`"
then
	echo shar: error transmitting "'testprogs.d/dlined.c'" '(should have been 475 characters)'
fi
fi
echo shar: extracting "'testprogs.d/lineh.c'" '(273 characters)'
if test -f 'testprogs.d/lineh.c'
then
	echo shar: will not over-write existing file "'testprogs.d/lineh.c'"
else
cat << \SHAR_EOF > 'testprogs.d/lineh.c'
/* hoizontal line across bottom of plot space */

main(argc,argv)
int argc;
char **argv;
{
	int x0,x1,y0,y1;

	x0 = 0;
	y0 = 0;
	x1 = 2000;
	y1 = 2000;
	space(x0,y0,2000,2000);
	move(x0,y0);
	label("+");
	move(x1,y0);
	label("+");
	line(x0,y0,x1,y0);
	erase();
	exit(0);
}
SHAR_EOF
if test 273 -ne "`wc -c < 'testprogs.d/lineh.c'`"
then
	echo shar: error transmitting "'testprogs.d/lineh.c'" '(should have been 273 characters)'
fi
fi
echo shar: extracting "'testprogs.d/arc.c'" '(541 characters)'
if test -f 'testprogs.d/arc.c'
then
	echo shar: will not over-write existing file "'testprogs.d/arc.c'"
else
cat << \SHAR_EOF > 'testprogs.d/arc.c'
/* arc centered on x,y starting at x0,y0, thru x1,y1	*/

#include <math.h>
main(argc,argv)
int argc;
char **argv;
{
	int x,y,x0,y0,x1,y1;

	if(argc == 1)
	{
		x = 1000;
		y = 1000;
		x0 = 2000;
		y0 = 1000;
		x1 = 700;
		y1 = 700;
	}
	else if(argc != 7)
	{
		printf("usage: arc x y x0 y0 x1 y1\n\t(range 0-2000)\n");
		exit(1);
	}
	else
	{
		x = atoi(argv[1]);
		y = atoi(argv[2]);
		x0 = atoi(argv[3]);
		y0 = atoi(argv[4]);
		x1 = atoi(argv[5]);
		y1 = atoi(argv[6]);
	}
	space(0,0,2000,2000);
	arc(x,y,x0,y0,x1,y1);
	erase();
	exit(0);
}
SHAR_EOF
if test 541 -ne "`wc -c < 'testprogs.d/arc.c'`"
then
	echo shar: error transmitting "'testprogs.d/arc.c'" '(should have been 541 characters)'
fi
fi
echo shar: extracting "'testprogs.d/circle.c'" '(213 characters)'
if test -f 'testprogs.d/circle.c'
then
	echo shar: will not over-write existing file "'testprogs.d/circle.c'"
else
cat << \SHAR_EOF > 'testprogs.d/circle.c'
/* circle inscribed on plot space--no args */
#include <math.h>
main(argc,argv)
int argc;
char **argv;
{
	int x,y,r;

	x = 1000;
	y = 1000;
	r = 1000;
	space(0,0,2000,2000);
	circle(x,y,r);
	erase();
	exit(0);
}

SHAR_EOF
if test 213 -ne "`wc -c < 'testprogs.d/circle.c'`"
then
	echo shar: error transmitting "'testprogs.d/circle.c'" '(should have been 213 characters)'
fi
fi
echo shar: done with directory "'testprogs.d'"
exit 0
#	End of shell archive
