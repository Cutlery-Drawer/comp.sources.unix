Subject: UNaXcess (2 of 3)
Newsgroups: mod.sources
Approved: jpn@panda.UUCP

Mod.sources:  Volume 4, Issue 66
Submitted by: decvax!cwruecmp!ncoast!allbery

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	bull.c
#	conf.c
#	date.c
#	dir.c
#	msg.c
#	param.c
#	sys.c
# This archive created: Sat Apr 12 10:02:51 1986
export PATH; PATH=/bin:$PATH
echo shar: extracting "'bull.c'" '(1154 characters)'
if test -f 'bull.c'
then
	echo shar: will not over-write existing file "'bull.c'"
else
cat << \SHAR_EOF > 'bull.c'
/*
 * %W% %E% %U% ncoast!bsa %Z%
 * %Z% Copyright (C) 1986 by Brandon S. Allbery, All Rights Reserved %Z%
 */

#ifndef lint
static char _SccsId[] = "%W% %E% %U% ncoast!bsa %Z%";
static char _CopyRt[] = "%Z% Copyright (C) 1985 by Brandon S. Allbery %Z%";
#endif  lint

#include "ua.h"

bulletin(s)
    char *s;
    {
    short mcnt, himotd;
    char tmps[256];
    FILE *fp;

    if (user.u_access == A_MKUSER)
    	return;
    sprintf(tmps, "%s/himotd", MOTD);
    if ((fp = fopen(tmps, "r")) == NULL)
	{
	log("Error %d opening %s", errno, tmps);
	panic("himotd");
	}
    fgets(tmps, 32, fp);
    fclose(fp);
    himotd = atoi(tmps);
    for (mcnt = (strcmp(user.u_name, "guest") == 0? 0: user.u_nbull + 1); mcnt <= himotd; mcnt++)
	{
	sprintf(tmps, "%s/%d", MOTD, mcnt);
	if (!readmotd(tmps, mcnt))
	    break;
	}
    }

readmotd(motd, mnum)
    char *motd;
    short mnum;
    {
    char line[256];

    printf("Bulletin #%d:\n", mnum);
    cat(motd);
    printf("\nContinue or Stop (C)? ");
    if (!isatty(0) || nopause)
	{
	putchar('\n');
	line[0] = '\0';
	}
    else
	gets(line);
    log("C/S? %s", line);
    return ToLower(line[0]) != 's';
    }
SHAR_EOF
if test 1154 -ne "`wc -c < 'bull.c'`"
then
	echo shar: error transmitting "'bull.c'" '(should have been 1154 characters)'
fi
fi
echo shar: extracting "'conf.c'" '(13406 characters)'
if test -f 'conf.c'
then
	echo shar: will not over-write existing file "'conf.c'"
else
cat << \SHAR_EOF > 'conf.c'
/*
 * %W% %E% %U% ncoast!bsa %Z%
 * %Z% Copyright (C) 1986 by Brandon S. Allbery, All Rights Reserved %Z%
 */

#ifndef lint
static char _SccsId[] = "%W% %E% %U% ncoast!bsa %Z%";
static char _CopyRt[] = "%Z% Copyright (C) 1985 by Brandon S. Allbery %Z%";
#endif  lint

#include "ua.h"

char conference[33];

confidx()
    {
    FILE *ifd;
    short icnt, himsg;
    char line[256];
    DIR *dp;
    struct direct *dfd;

    icnt = 0;
    puts("\n\"!\" after a conference name indicates an unsubscribed-to conference.\n\nConference                        HiMsg Conference                        HiMsg");
    if ((dp = opendir(MSGBASE)) == NULL)
	{
	log("Error %d opening dir %s/", errno, MSGBASE);
	panic("msgdir");
	}
    while ((dfd = readdir(dp)) != NULL)
	{
	if (dfd->d_name[0] == '.')
	    continue;
	sprintf(line, "%s/%s/himsg", MSGBASE, dfd->d_name);
	if ((ifd = fopen(line, "r")) == NULL)
	    {
	    log("No himsg in conference %s", dfd->d_name);
	    continue;
	    }
	fgets(line, 32, ifd);
	himsg = atoi(line);
	printf("%-32.32s%c %-5d", dfd->d_name, (isunsub(dfd->d_name)? '!': ':'), himsg);
	fclose(ifd);
	if (user.u_llen < 80 || !(++icnt % 2))
	    putchar('\n');
	else if (!(icnt % 2))
	    putchar('|');
	}
    closedir(dp);
    puts("\n");
    return 1;
    }

join(c)
    char *c;
    {
    char line[256], *p;

    p = c - 1;
    while (*++p != '\0')
	if (*p == ' ')
	    if (verify(++p))
		{
		strcpy(conference, p);
		return 1;
		}
    do
	{
	printf("Enter conference: ");
	gets(line);
	log("Enter conference: %s", line);
	if (line[0] == '\0')
	    return 1;
	}
    while (!verify(line));
    strcpy(conference, line);
    log("Current conference is %s", conference);
    return 1;
    }

verify(conf)
    char *conf;
    {
    char *cp, line[256];

    for (cp = conf; *cp != 0; cp++)
	{
	if (!isprint(*cp))
	    return 0;
	else if (*cp == '/' || *cp == '!' || *cp == ':')
	    *cp = '.';
	else
	    *cp = ToLower(*cp);
	}
    if (cp - conf > CONFSIZE)
	conf[CONFSIZE] = '\0';
    sprintf(line, "%s/%s", MSGBASE, conf);
    if (chdir(line) == -1)
	{
	if (errno != ENOENT)
	    {
	    log("Error %d accessing dir %s/", errno, line);
	    return 0;
	    }
	else
	    return newconf(conf);
	}
    chdir("../..");
    if (isunsub(conf)) {
        printf("You are unsubscribed from this conference.  Rejoin (N)? ");
        gets(line);
        log("Unsubscribed.  Resubscribe? %s", line);
        if (ToLower(line[0]) == 'y')
            resubscribe(conf);
        else
            return 0;
    }
    if (parms.ua_xrc && conf[0] == 'x' && conf[1] == '-')
	{
	printf("This is a Restricted Access (X-RATED) conference.  The material within\n may be unsuitable for, or unacceptable to, some users of UNaXcess.\n\nDo you still wish to join this conference (N)? ");
	gets(line);
	log("Restricted.  Join? %s", line);
	return (ToLower(line[0]) == 'y');
	}
    return 1;
    }

killmsg(n)
    char *n;
    {
    short mnum, flag;
    char line[256], *p;

    if (user.u_access == A_GUEST)
	{
	puts("You aren't authorized for this function.");
	log("Security violation:  KILL by a GUEST");
	return 1;
	}
    flag = 0;
    for (p = n; *p != '\0'; p++)
	if (*p == ' ')
	    {
	    if ((mnum = atoi(++p)) < 1)
		break;
	    dokill(mnum);
	    flag++;
	    }
    if (flag)
	return 1;
    printf("Enter message number to kill: ");
    gets(line);
    if (line[0] == '\0')
	return 1;
    if ((mnum = atoi(line)) < 1)
	{
	puts("Bad message number.");
	log("Bad message number: %s", line);
	return 1;
	}
    dokill(mnum);
    return 1;
    }

dokill(msg)
    short msg;
    {
    char mfile[256];

    sprintf(mfile, "%s/%s/%d", MSGBASE, conference, msg);
    if (user.u_access != A_WITNESS && strcmp(getowner(mfile), user.u_name) != 0)
	{
	puts("Sorry, you don't own that message.");
	log("Security violation:  KILL by non-owner");
	return;
	}
    if (unlink(mfile) < 0)
	{
	printf("No such message: %d", msg);
	log("Error %d unlinking %s", errno, mfile);
	return;
	}
    log("Deleted %s:%d", conference, msg);
    }

char *getowner(file)
    char *file;
    {
    FILE *f;
    char line[1024], *p;
    static char owner[256];

    strcpy(owner, parms.ua_sysop);
    if ((f = fopen(file, "r")) == NULL)
	return owner;
    while (fgets(line, 1024, f) != NULL)
	if (line[0] == '\n')
	    break;
	else if (strncmp(line, "From: ", 6) == 0)
	    {
	    strcpy(owner, &line[6]);
	    break;
	    }
    fclose(f);
    for (p = owner; *p != '\0'; p++)
	*p = ToLower(*p);
    return owner;
    }

newconf(conf)
    char *conf;
    {
    char line[256];
    FILE *f;

    if (user.u_access == A_GUEST)
	{
	log("Security violation:  attempted MKCONF by guest");
	puts("Sorry, there is no such conference.");
	return 0;
	}
    printf("There is no conference by that name.  Do you want to create it (N)? ");
    gets(line);
    log("Nonexistent.  Create? %s", line);
    if (ToLower(line[0]) != 'y')
	return 0;
    if (parms.ua_xrc && conf[0] == 'x' && conf[1] == '-')
	{
	printf("Conferences beginning with \"x-\" are designated as Restricted Access (X-RATED)\nconferences under UNaXcess, and will often carry information unsuitable for some\n");
	printf("users or unacceptable to some users.  If you do not wish to create such a\nconference, answer NO to the next question and choose a conference name not\n");
	printf("beginning with the characters \"x-\".\n\nDo you wish to create an X-RATED conference (N)? ");
	gets(line);
	log("Restricted.  Create? %s", line);
	if (ToLower(line[0]) != 'y')
	    return 0;
	}
    if (parms.ua_roc && conf[0] == 'r' && conf[1] == '-')
	if (user.u_access != A_WITNESS)
	    {
	    puts("Only Fairwitnesses can make READ-ONLY conferences.");
	    log("Attempted mk of RO conf by non-FW");
	    return 0;
	    }
	else
	    {
	    puts("This conference will be READ-ONLY, except to Fairwitnesses.\nIf you want anyone to be able to add to it, answer NO and use a name not\nbeginning with \"R-\".");
	    printf("\nDo you want to make this READ-ONLY conference (N)? ");
	    gets(line);
	    log("Read-only.  Create? %s", line);
	    if (ToLower(line[0]) != 'y')
		return 0;
	    }
    sprintf(line, "exec mkconf %s/%s %d", MSGBASE, conf, geteuid());
    if (system(line) != 0)
	{
	log("Mkconf of %s failed.", conf);
	puts("Hmmm... guess you aren't allowed.");
	return 0;
	}
    log("New conference: %s", conf);
    sprintf(line, "%s/%s/himsg", MSGBASE, conf);
    if ((f = fopen(line, "w")) == NULL)
	{
	log("Error %d opening %s", line);
	puts("Can't create high message file.  Strange...");
	return 0;
	}
    fputs("0", f);
    fclose(f);
    puts("You will now be placed in the message editor to make a message describing\nthis conferemnce.  It will be addressed to, and readable by, all users.");
    mkmsg("All", "This conference", conf, 0);
    return 1;
    }

isprivate(msg)
    char *msg;
    {
    FILE *fp;
    char line[1024], to[1024], from[1024];
    short pflag;

    if (user.u_access == A_WITNESS)
	return 0;
    if ((fp = fopen(msg, "r")) == NULL)
	return 0;
    strcpy(to, "All");
    pflag = 0;
    while (fgets(line, 1024, fp) != NULL)
	{
	if (line[0] == '\n')
	    break;
	else if (strncmp(line, "To: ", 4) == 0)
	    strcpy(to, &line[4]);
	else if (strncmp(line, "From: ", 6) == 0)
	    strcpy(from, &line[6]);
	else if (strncmp(line, "Subject (Private): ", 19) == 0)
	    pflag = 1;
	}
    fclose(fp);
    if (pflag && strcmp(user.u_name, to) == 0)
	return 0;
    else if (pflag && strcmp(user.u_name, from) == 0)
	return 0;
    else if (pflag)
	{
	log("Message %s is private.", msg);
	return 1;
	}
    else
	return 0;
    }

isunsub(conf)
char *conf; {
    struct _himsg *hip;

    for (hip = hicnts; hip != NULL; hip = hip->hi_next)
        if (strcmp(hip->hi_conf, conf) == 0)
            break;
    return (hip != NULL && hip->hi_uns == HI_UNSUB);
}

unsubscribe(conf)
char *conf; {
    struct _himsg *hip, *workp;
    char line[512];
    
    if (s_cmp(conf, "general") == 0) {
        puts("Can't unsubscribe the general conference.");
        log("Attempted to unsubscribe to general.");
        return;
    }
    if (s_cmp(conf, user.u_lconf) == 0) {
        printf("Unsubscribe to login conference (N)? ");
        gets(line);
        log("Unsub login conf? %s", line);
        if (ToLower(line[0]) != 'y')
            return;
        strcpy(user.u_lconf, "general");
    }
    for (hip = hicnts; hip != NULL; hip = hip->hi_next)
        if (strcmp(hip->hi_conf, conf) == 0)
            break;
    if (hip != NULL)
        hip->hi_uns = HI_UNSUB;
    else {
	if ((workp = (struct _himsg *) calloc((unsigned) 1, sizeof (struct _himsg))) == NULL)
	    {
	    log("Error %d allocating _himsg for %s", errno, conf);
	    panic("alloc");
	    }
	strcpy(workp->hi_conf, conf);
	workp->hi_num = 0;
	workp->hi_next = hicnts;
	hicnts = workp;
	workp->hi_uns = HI_UNSUB;
    }
    log("Unsubscribed to %s", conf);
    printf("Unsubscribed to conference %s.\n", conf);
}

resubscribe(conf)
char *conf; {
    struct _himsg *hip, *workp;
    
    for (hip = hicnts; hip != NULL; hip = hip->hi_next)
        if (strcmp(hip->hi_conf, conf) == 0)
            break;
    if (hip != NULL)
        hip->hi_uns = HI_SUBSCR;
    else {
	if ((workp = (struct _himsg *) calloc((unsigned) 1, sizeof (struct _himsg))) == NULL)
	    {
	    log("Error %d allocating _himsg for %s", errno, conf);
	    panic("alloc");
	    }
	strcpy(workp->hi_conf, conf);
	workp->hi_num = 0;
	workp->hi_next = hicnts;
	hicnts = workp;
	workp->hi_uns = HI_SUBSCR;
    }
    log("Resubscribed to %s", conf);
    printf("Resubscribed to conference %s.\n", conf);
}

unsub(c)
char *c; {
    char line[256], *p;

    p = c - 1;
    while (*++p != '\0')
	if (*p == ' ')
	    if (isconf(++p))
		{
		unsubscribe(p);
		return 1;
		}
    for (;;) {
	printf("Unsubscribe to which conference (%s) [NONE to abort]: ", conference);
	gets(line);
	log("Unsub conference: %s", line);
	if (line[0] == '\0') {
	    unsubscribe(conference);
	    return 1;
	}
	if (s_cmp(line, "none") == 0)
	    return 1;
	if (isconf(line)) {
	    unsubscribe(line);
	    return 1;
	}
    }
}

isconf(conf)
char *conf; {
    char *cp, line[256];

    for (cp = conf; *cp != 0; cp++) {
    	if (!isprint(*cp))
	    return 0;
	else if (*cp == '/' || *cp == '!' || *cp == ':')
	    *cp = '.';
	else
	    *cp = ToLower(*cp);
	}
    if (cp - conf > CONFSIZE)
	conf[CONFSIZE] = '\0';
    sprintf(line, "%s/%s", MSGBASE, conf);
    if (chdir(line) == -1)
        return 0;
    chdir("../..");
    return 1;
}

setlconf(conf)
char *conf; {
    char line[256], *p;

    if (s_cmp(user.u_name, "guest") == 0) {
        log("Guest SET LOGIN CONF denied.");
        puts("GUEST can't set a login conference.");
        return 1;
    }
    p = conf - 1;
    while (*++p != '\0')
	if (*p == ' ')
	    if (isconf(++p)) {
                if (isunsub(p)) {
                    puts("You're unsubscribed from it.  <J>oin it and resubscribe.");
                    log("Unsubscribed -- login conf set aborted.");
                    return 1;
                }
		strcpy(user.u_lconf, p);
		log("New login conference: %s", user.u_lconf);
                putuser(user.u_name, &user);
		return 1;
	    }
    do {
	printf("Enter new login conference: ");
	gets(line);
	log("Login conference: %s", line);
	if (line[0] == '\0')
	    return 1;
    } while (!isconf(line));
    if (isunsub(line)) {
        puts("You're unsubscribed from it.  <J>oin it and resubscribe.");
        log("Unsubscribed -- login conf set aborted.");
        return 1;
    }
    strcpy(user.u_lconf, line);
    log("New login conference: %s", user.u_lconf);
    putuser(user.u_name, &user);
    return 1;
}

uisunsub(user, conf)
char *user, *conf; {
    struct _himsg *hip, *uhi;
    char *cp;

    for (cp = user; *cp != '\0'; cp++)
        *cp = ToLower(*cp);
    if ((uhi = readhigh(user)) < 0) {
        log("Couldn't read %s's userindex.", user);
        return 0;
    }
    for (hip = uhi; hip != NULL; hip = hip->hi_next)
        if (strcmp(hip->hi_conf, conf) == 0)
            break;
    cp = (hip != NULL && hip->hi_uns == HI_UNSUB? "!": ":");
    for (hip = uhi->hi_next; uhi != NULL; uhi = hip)
        free((char *) uhi);
    return (*cp == '!');
}

cleanhigh() {
    struct _himsg *hip, *lastp;
    DIR *conferences;
    struct direct *conf;
    
    lastp = NULL;
    puts("Checking for deleted conferences...");
    for (hip = hicnts; hip != NULL; lastp = hip, hip = hip->hi_next) {
        if (!isconf(hip->hi_conf)) {
            printf("Conference \"%s\" was deleted since your last session.\n", hip->hi_conf);
            if (lastp == NULL)
                hicnts = hip->hi_next;
            else
                lastp->hi_next = hip->hi_next;
            free((char *) hip);
        }
    }
    puts("\nChecking for new conferences...");
    if ((conferences = opendir(MSGBASE)) == NULL) {
        log("Error %d opening dir %s/", errno, MSGBASE);
        panic("msgdir");
    }
    while ((conf = readdir(conferences)) != NULL) {
        if (strcmp(conf->d_name, ".") == 0)
            continue;
        if (strcmp(conf->d_name, "..") == 0)
            continue;
        for (hip = hicnts; hip != NULL; hip = hip->hi_next)
            if (strcmp(hip->hi_conf, conf->d_name) == 0)
                break;
        if (hip == NULL)
            printf("Conference \"%s\" has been created since your last session.\n", conf->d_name);
    }
    closedir(conferences);
}
SHAR_EOF
if test 13406 -ne "`wc -c < 'conf.c'`"
then
	echo shar: error transmitting "'conf.c'" '(should have been 13406 characters)'
fi
fi
echo shar: extracting "'date.c'" '(1557 characters)'
if test -f 'date.c'
then
	echo shar: will not over-write existing file "'date.c'"
else
cat << \SHAR_EOF > 'date.c'
/*
 * %W% %E% %U% ncoast!bsa %Z%
 * %Z% Copyright (C) 1986 by Brandon S. Allbery, All Rights Reserved %Z%
 */

#ifndef lint
static char _SccsId[] = "%W% %E% %U% ncoast!bsa %Z%";
static char _CopyRt[] = "%Z% Copyright (C) 1985 by Brandon S. Allbery %Z%";
#endif  lint

#ifdef BSD
#include <sys/time.h>
#else
#include <time.h>
#endif BSD

static char *month[] =
    {
	"January",	"February",	"March",	"April",
	"May",		"June",		"July",		"August",
	"September",	"October",	"November",	"December"
    };

static char *wkday[] =
    {
	"Sunday",	"Monday",	"Tuesday",	"Wednesday",
	"Thursday",	"Friday",	"Saturday"
    };

struct tm *localtime();

char *date()
    {
    long clock;
    struct tm *ltbuf;
    static char tbuf[18];

    time(&clock);
    ltbuf = localtime(&clock);
    sprintf(tbuf, "%02d/%02d/%02d %02d:%02d:%02d", ltbuf->tm_mon + 1, ltbuf->tm_mday, ltbuf->tm_year, ltbuf->tm_hour, ltbuf->tm_min, ltbuf->tm_sec);
    return tbuf;
    }

char *longdate()
    {
    long clock;
    struct tm *ltbuf;
    static char tbuf[80];
    short hour;
    char ampm;

    time(&clock);
    ltbuf = localtime(&clock);
    if (ltbuf->tm_hour == 0)
	{
	hour = 12;
	ampm = 'A';
	}
    else if (ltbuf->tm_hour < 12)
	{
	hour = ltbuf->tm_hour;
	ampm = 'A';
	}
    else if (ltbuf->tm_hour == 12)
	{
	hour = 12;
	ampm = 'P';
	}
    else
	{
	hour = ltbuf->tm_hour - 12;
	ampm = 'P';
	}
    sprintf(tbuf, "%s, %s %d, 19%02d - %d:%02d %cM", wkday[ltbuf->tm_wday], month[ltbuf->tm_mon], ltbuf->tm_mday, ltbuf->tm_year, hour, ltbuf->tm_min, ampm);
    return tbuf;
    }
SHAR_EOF
if test 1557 -ne "`wc -c < 'date.c'`"
then
	echo shar: error transmitting "'date.c'" '(should have been 1557 characters)'
fi
fi
echo shar: extracting "'dir.c'" '(2625 characters)'
if test -f 'dir.c'
then
	echo shar: will not over-write existing file "'dir.c'"
else
cat << \SHAR_EOF > 'dir.c'
/*
 *
 *				N O T I C E
 *
 * This file is NOT a copyrighted part of the UNaXcess distribution.  These
 * are directory-reading routines which are compatible with the Berkeley Unix
 * (4.2BSD, 4.3BSD) strectory routines.  They come from the Usenet news
 * distribution and are in the public domain.
 *
 * To get the best use of them:  install the file "dir.h" in /usr/include
 * -- standard usage calls it "ndir.h", and make a random archive of dir.o and
 * put it in /usr/lib/libndir.a .  It is then available with "-lndir".
 *
 * Bell System {III, V} sites, just make an archive -- it is only one file
 * anyway.  Other sites will have to run ranlib on the archive to keep ld
 * happy.
 */

#include <sys/types.h>
#include "dir.h"

#ifndef BSD

/*
 * close a directory.
 */
closedir(dirp)
        register DIR *dirp;
{
        close(dirp->dd_fd);
        dirp->dd_fd = -1;
        dirp->dd_loc = 0;
        free(dirp);
}



/*
 * open a directory.
 */
DIR *
opendir(name)
        char *name;
{
        register DIR *dirp;
        register int fd;

        if ((fd = open(name, 0)) == -1)
                return NULL;
        if ((dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
                close (fd);
                return NULL;
        }
        dirp->dd_fd = fd;
        dirp->dd_loc = 0;
        return dirp;
}



/*
 * read an old style directory entry and present it as a new one
 */
#define ODIRSIZ 14

struct  olddirect {
        ino_t   od_ino;
        char    od_name[ODIRSIZ];
};

/*
 * get next entry in a directory.
 */
struct direct *
readdir(dirp)
        register DIR *dirp;
{
        register struct olddirect *dp;
        static struct direct dir;

        for (;;) {
                if (dirp->dd_loc == 0) {
                        dirp->dd_size = read(dirp->dd_fd, dirp->dd_buf, 
                            DIRBLKSIZ);
                        if (dirp->dd_size <= 0)
                                return NULL;
                }
                if (dirp->dd_loc >= dirp->dd_size) {
                        dirp->dd_loc = 0;
                        continue;
                }
                dp = (struct olddirect *)(dirp->dd_buf + dirp->dd_loc);
                dirp->dd_loc += sizeof(struct olddirect);
                if (dp->od_ino == 0)
                        continue;
                dir.d_ino = dp->od_ino;
                strncpy(dir.d_name, dp->od_name, ODIRSIZ);
                dir.d_name[ODIRSIZ] = '\0'; /* insure null termination */
                dir.d_namlen = strlen(dir.d_name);
                dir.d_reclen = DIRBLKSIZ;
                return (&dir);
        }
}

#endif BSD
SHAR_EOF
if test 2625 -ne "`wc -c < 'dir.c'`"
then
	echo shar: error transmitting "'dir.c'" '(should have been 2625 characters)'
fi
fi
echo shar: extracting "'msg.c'" '(16927 characters)'
if test -f 'msg.c'
then
	echo shar: will not over-write existing file "'msg.c'"
else
cat << \SHAR_EOF > 'msg.c'
/*
 * %W% %E% %U% ncoast!bsa %Z%
 * %Z% Copyright (C) 1986 by Brandon S. Allbery, All Rights Reserved %Z%
 */

#ifndef lint
static char _SccsId[] = "%W% %E% %U% ncoast!bsa %Z%";
static char _CopyRt[] = "%Z% Copyright (C) 1985 by Brandon S. Allbery %Z%";
#endif  lint

#include "ua.h"

selmsg(s, fn)
    char *s;
    int (*fn)();
    {
    char line[256], *p;
    short lomsg, himsg;
    FILE *f;

    sprintf(line, "%s/%s/himsg", MSGBASE, conference);
    if ((f = fopen(line, "r")) == NULL)
	{
	log("Error %d opening %s", errno, line);
	if (strcmp(conference, "general") == 0)
	    {
	    panic("conf");
	    }
	puts("I can't find the high message file.  Moving back to general...");
	strcpy(conference, "general");
	return 1;
	}
    fgets(line, 32, f);
    fclose(f);
    himsg = atoi(line);
    for (p = s; *p != 0; p++)
	if (*p == ' ')
	    {
	    if (strcmp(++p, "new") == 0)
		{
		domsg(conference, 0, himsg, fn);
		return 1;
		}
	    else if ((lomsg = atoi(p)) < 1 || lomsg > himsg)
		break;
	    else
		{
		domsg(conference, lomsg, lomsg, fn);
		return 1;
		}
	    }
    printf("<F>orward, <R>everse, <I>ndividual, or <N>ew: ");
    gets(line);
    log("Mode: %s", line);
    switch (line[0])
	{
	case 'F':
	case 'f':
	    lomsg = 1;
	    break;
	case 'R':
	case 'r':
	    lomsg = himsg;
	    himsg = 1;
	    break;
	case 'I':
	case 'i':
	    printf("Enter message number: ");
	    gets(line);
	    log("Message: %s", line);
	    if ((lomsg = atoi(line)) < 1 || lomsg > himsg)
		{
		puts("No such message.");
		log("No such message.");
		return 1;
		}
	    domsg(conference, lomsg, lomsg, fn);
	    return 1;
	case 'N':
	case 'n':
	    lomsg = 0;
	    break;
	case '\0':
	    return 1;
	default:
	    puts("What?");
	    log("Illegal search mode.");
	    return 1;
	}
    if (lomsg != 0)
	{
	printf("Starting message (%d): ", lomsg);
	gets(line);
	log("Start: %s", line);
	if (line[0] != 0)
	    if (atoi(line) < 1 || (lomsg > 1 && atoi(line) > lomsg))
		{
		puts("Bad message number.");
		log("Bad message number.");
		return 1;
		}
	    else
		lomsg = atoi(line);
	printf("Ending message (%d): ", himsg);
	gets(line);
	log("End: %s", line);
	if (line[0] != 0)
	    if (atoi(line) < 1 || (himsg > 1 && atoi(line) > himsg))
		{
		puts("Bad message number.");
		log("Bad message number.");
		return 1;
		}
	    else
		himsg = atoi(line);
	}
    domsg(conference, lomsg, himsg, fn);
    return 1;
    }

readmsg(s)
    char *s;
    {
    return selmsg(s, doread);
    }

scanmsg(s)
    char *s;
    {
    return selmsg(s, doscan);
    }

doread(msg, conf, mnum)
    char *msg, *conf;
    short mnum;
    {
    char line[256];

    printf("\nMessage %d of %s:\n", mnum, conf);
    if (isprivate(msg))
	{
	puts("This message is private.");
	return 1;
	}
    cat(msg);

DR_Loop:
    printf("\nContinue, Stop, Unsubscribe, or Reply (C): ");
    if (!isatty(0) || nopause)
	{
	line[0] = '\0';
	putchar('\n');
	}
    else
	gets(line);
    log("C/S/U/R: %s", line);
    switch (line[0])
	{
	case 'c':
	case 'C':
	case '\0':
	    return 1;
        case 'U':
        case 'u':
            unsubscribe(conf);
            return 0;
	case 's':
	case 'S':
	    return 0;
	case 'r':
	case 'R':
	    reply(msg, conf);
	    goto DR_Loop;
	default:
	    puts("What?  Please enter one of C, S, U, or R.");
	    goto DR_Loop;
	}
    }

msgok(file)
    char *file;
    {
    FILE *fp;

    if ((fp = fopen(file, "r")) == NULL)
	return 0;
    fclose(fp);
    return 1;
    }

doscan(msg, conf, mnum)
char *msg, *conf;
short mnum; {
    char line[1024];
    FILE *f;
    short dflag, fflag, tflag, sflag;

    if ((f = fopen(msg, "r")) == NULL) {
	puts("Cannot open file.");
	log("Error %d opening %s", errno, msg);
	return 1;
    }
    printf("\nMessage %d of %s: \n", mnum, conf);
    dflag = fflag = tflag = sflag = 0;
    if (isprivate(msg))
	puts("Message is private.");
    else {
	while (fgets(line, 1024, f) != NULL) {
	    if (line[0] == '\n')
		break;
	    if (!dflag && strncmp(line, "Date: ", 6) == 0) {
		printf("%s", line);
		dflag++;
		continue;
	    }
	    if (!fflag && strncmp(line, "From: ", 6) == 0) {
		printf("%s", line);
		fflag++;
		continue;
	    }
	    if (!tflag && strncmp(line, "To: ", 4) == 0) {
		printf("%s", line);
		tflag++;
		continue;
	    }
	    if (!sflag && strncmp(line, "Subject: ", 9) == 0) {
		printf("%s", line);
		sflag++;
		continue;
	    }
	    if (!sflag && strncmp(line, "Subject (Private): ", 19) == 0) {
		printf("%s", line);
		sflag++;
		continue;
	    }
	}
        if (!tflag)
	    puts("To: All");
    }
    fclose(f);
    puts("--------------------------------");
    if (mnum % 3 == 0)	/* kludged, but there isn't an easy fix without */
        if (!cont())	/* rewriting the I/O system. */
            longjmp(cmdloop, 1);	/* also a kludge... */
    return 1;
    }

domsg(conf, lomsg, himsg, fn)
    char *conf;
    short lomsg, himsg;
    int (*fn)();
    {
    short mcnt;
    char tmps[256];
    struct _himsg *ptr, *lastp;

    for (ptr = hicnts, lastp = NULL; ptr != NULL; lastp = ptr, ptr = ptr->hi_next)
	if (strcmp(conf, ptr->hi_conf) == 0)
	    break;
    if (ptr == NULL)
	{
	if ((ptr = (struct _himsg *) calloc((unsigned) 1, sizeof (struct _himsg))) == NULL)
	    {
	    log("Error %d allocating _himsg for %s", errno, conf);
	    panic("alloc");
	    }
	ptr->hi_next = hicnts;
        hicnts = ptr;
        ptr->hi_uns = HI_SUBSCR;
	strcpy(ptr->hi_conf, conf);
	ptr->hi_num = 0;
	}
    if (lomsg == 0)			/* read new messages */
	for (mcnt = ptr->hi_num + 1; mcnt <= himsg; mcnt++)
	    {
	    sprintf(tmps, "%s/%s/%d", MSGBASE, conf, mcnt);
	    if (msgok(tmps) <= 0)
		continue;
	    if (!(*fn)(tmps, conf, mcnt))
		break;
	    }
    else if (lomsg <= himsg)		/* forward or individual read */
	for (mcnt = lomsg; mcnt <= himsg; mcnt++)
	    {
	    sprintf(tmps, "%s/%s/%d", MSGBASE, conf, mcnt);
	    if (msgok(tmps) <= 0)
		continue;
	    if (!(*fn)(tmps, conf, mcnt))
		break;
	    }
    else
	for (mcnt = lomsg; mcnt >= himsg; mcnt--)
	    {
	    sprintf(tmps, "%s/%s/%d", MSGBASE, conf, mcnt);
	    if (msgok(tmps) <= 0)
		continue;
	    if (!(*fn)(tmps, conf, mcnt))
		break;
	    }
    ptr->hi_num = himsg;
    writehigh(hicnts);
    }

readnew()
    {
    DIR *dp;
    struct direct *dirp;
    FILE *hp;
    short himsg;
    char line[256];

    if ((dp = opendir(MSGBASE)) == NULL)
	{
	log("Error %d reading dir %s/", errno, MSGBASE);
	panic("msgdir");
	}
    while ((dirp = readdir(dp)) != NULL)
	{
	if (dirp->d_name[0] == '.')
	    continue;
        if (isunsub(dirp->d_name))
            continue;
	printf("\nExamining conference %s...\n", dirp->d_name);
	log("Reading %s.", dirp->d_name);
	if (parms.ua_xrc && dirp->d_name[0] == 'x' && dirp->d_name[1] == '-')
	    {
            if (user.u_access == A_GUEST) {
                log("Guest skipping Restricted conference.");
                continue;
            }
	    printf("This conference is Restricted (X-RATED).  The material within may not be\nsuitable for, or acceptable to, some users.\n\nDo you wish to skip it (Y)? ");
	    if (!isatty(0) || nopause)
		{
		line[0] = '\0';
		putchar('\n');
		}
	    else
		gets(line);
	    log("Restricted.  Skip? %s", line);
	    if (ToLower(line[0]) != 'n')
		continue;
	    }
	sprintf(line, "%s/%s/himsg", MSGBASE, dirp->d_name);
	if ((hp = fopen(line, "r")) == NULL)
	    {
	    log("Error %d opening %s", errno, line);
	    puts("Can't open high message file.");
	    continue;
	    }
	fgets(line, 32, hp);
	fclose(hp);
	himsg = atoi(line);
	domsg(dirp->d_name, 0, himsg, doread);
    
    RN_Loop:
	printf("\nNext conference, Unsubscribe, or Stop (N): ");
	if (!isatty(0) || nopause)
	    {
	    putchar('\n');
	    line[0] = '\0';
	    }
	else
	    gets(line);
	log("Next/Unsub/Stop: %s", line);
	switch (line[0])
	    {
	    case 'N':
	    case 'n':
	    case '\0':
		break;
	    case 'U':
	    case 'u':
	        unsubscribe(dirp->d_name);
	        break;
	    case 'S':
	    case 's':
		closedir(dp);
		return 1;
	    default:
		puts("Please enter one of N, U, or S.");
		goto RN_Loop;
	    }
	}
    closedir(dp);
    return 1;
    }

enter(s)
    char *s;
    {
    char to[256], subj[256], *p, line[256];
    short pflag;

    if (user.u_access == A_GUEST && strcmp(conference, "guest") != 0)
	{
	log("Security violation:  GUEST entering messages.");
	puts("You aren't allowed to enter messages in this conference.");
	return 1;
	}
    for (p = s; *p != '\0'; p++)
	if (*p == ' ')
	    {
	    strcpy(to, ++p);
	    break;
	    }
    if (*p == '\0')
	{
	printf("Who is this message to (ALL)? ");
	gets(line);
	log("To: %s", line);
	if (line[0] == '\0')
	    strcpy(line, "all");
	for (p = line; *p != '\0'; p++)
	    *p = ToLower(*p);
	strcpy(to, line);
	}
    printf("Subject: ");
    gets(line);
    strcpy(subj, line);
    log("Subject: %s", line);
    pflag = 0;
    if (parms.ua_pm) {
    	printf("Is this message to be private (N)? ");
    	gets(line);
    	log("Private? %s", line);
    	if (ToLower(line[0]) == 'y')
	    pflag = 1;
    }
    mkmsg(to, subj, conference, pflag);
    return 1;
    }

reply(msg, conf)
    char *msg, *conf;
    {
    char to[256], subj[256], line[1024], rconf[256];
    short fflag, sflag, pflag;
    FILE *f;

    if (user.u_access == A_GUEST && strcmp(conf, "guest") != 0)
	{
	log("Security violation:  GUEST entering messages");
	puts("You aren't allowed to enter messages.");
	return;
	}
    if ((f = fopen(msg, "r")) == NULL)
	{
	log("Error %d opening %s", errno, msg);
	puts("Can't re-open message file.");
	return;
	}
    fflag = sflag = 0;
    strcpy(to, "All\n");
    strcpy(subj, "Re: Orphaned Response\n");	/* now you know... */
    while (fgets(line, 1024, f) != NULL)
	{
	if (line[0] == '\n')
	    break;
	if (!fflag && strncmp(line, "From: ", 6) == 0)
	    {
	    strcpy(to, &line[6]);
	    fflag++;
	    continue;
	    }
	if (!sflag && strncmp(line, "Subject: ", 9) == 0)
	    {
	    if (strncmp(&line[9], "Re: ", 4) == 0)
		strcpy(subj, &line[9]);
	    else
		strcpy(&subj[4], &line[9]);
	    sflag++;
	    continue;
	    }
	if (!sflag && strncmp(line, "Subject (Private): ", 19) == 0)
	    {
	    if (strncmp(&line[19], "Re: ", 4) == 0)
		strcpy(subj, &line[19]);
	    else
		strcpy(&subj[4], &line[19]);
	    sflag++;
	    continue;
	    }
	}
    fclose(f);
    to[strlen(to) - 1] = '\0';			/* get rid of trailing nl */
    subj[strlen(subj) - 1] = '\0';
    printf("What conference do you wish this reply to be in (%s): ", conf);
    gets(line);
    if (line[0] != '\0' && verify(line))
	{
	strcpy(rconf, line);
	conf = rconf;
	}
    pflag = 0;
    if (parms.ua_pm) {
	    printf("Is this message to be private (N)? ");
	    gets(line);
	    log("Private? %s", line);
	    if (ToLower(line[0]) == 'y')
		pflag = 1;
    }
    mkmsg(to, subj, conf, pflag);
    }

mkmsg(to, subj, conf, ispriv)
    char *to, *subj, *conf;
    {
    static char lockfile[] = "msgbase.lock";
    char *tempfile = mktemp("/tmp/UAmXXXXXX");
    FILE *mfp, *sfp;
    char line[1024], *p;
    long clock;
    short mcnt;
    struct tm *ltbuf;
    struct user ubuf;

    if (parms.ua_roc && conf[0] == 'r' && conf[1] == '-')
	{
	conf = "general";			/* responses get redirected */
	puts("Read-only conference; message will be added to \"general\".");
	}
    if (ispriv && !getuser(to, &ubuf))
	{
	printf("Can't send private message to \"%s\"; he's unregistered.\n", to);
	log("Attempted private message to unregistered user.");
	return 0;
	}
    if ((mfp = fopen(tempfile, "w")) == NULL)
	{
	log("Error %d opening %s", errno, tempfile);
	panic("tmp");
	}
    for (p = to; *p != '\0'; p++)
	*p = ToUpper(*p);
    fprintf(mfp, "To: %s\nSubject%s: %s\n\n", to, (ispriv? " (Private)": ""), subj);
    fclose(mfp);
    input(tempfile);
    for (;;)
	{
	printf("\nEdit command (L, C, E, S, or A): ");
	gets(line);
	log("Edit command: %s", line);
	switch (line[0])
	    {
	    case 'l':
	    case 'L':
		cat(tempfile);
		break;
	    case 'c':
	    case 'C':
		input(tempfile);
		break;
	    case 'e':
	    case 'E':
		if (user.u_access == A_SYSTEM || user.u_access == A_WITNESS)
		    xedit(tempfile);
		else
		    edit(tempfile);
		break;
	    case 'a':
	    case 'A':
		printf("Do you really want to abort this edit (N)? ");
		gets(line);
		log("Abort? %s", line);
		if (ToLower(line[0]) == 'y')
		    {
		    unlink(tempfile);
		    return 0;
		    }
		break;
	    case '?':
		puts("Editor commands:\nL - List message\nC - Continue message entry\nE - Edit message\nS - Save message\nA - Abort message");
		break;
	    case '\0':
		break;
	    case 's':
	    case 'S':
		puts("Saving message...");
		mklock(lockfile);
		sprintf(line, "%s/%s/himsg", MSGBASE, conf);
		if ((sfp = fopen(line, "r")) == NULL)
		    {
		    log("Error %d opening %s", errno, line);
		    rmlock(lockfile);
		    unlink(tempfile);
		    panic("himsg");
		    }
		fgets(line, 32, sfp);
		fclose(sfp);
		mcnt = atoi(line) + 1;
		sprintf(line, "%s/%s/%d", MSGBASE, conf, mcnt);
		if ((sfp = fopen(line, "w")) == NULL)
		    {
		    log("Error %d opening %s", errno, line);
		    unlink(tempfile);
		    rmlock(lockfile);
		    panic("msg");
		    }
		fprintf(sfp, "Date: %s\nFrom: ", longdate());
		for (p = user.u_name; *p != '\0'; p++)
		    putc(ToUpper(*p), sfp);
		putc('\n', sfp);
		if ((mfp = fopen(tempfile, "r")) == NULL)
		    {
		    fclose(sfp);
		    log("Error %d opening %s", errno, tempfile);
		    unlink(tempfile);
		    unlink(line);
		    rmlock(lockfile);
		    panic("tmp");
		    }
		while (fgets(line, 1024, mfp) != NULL)
		    fputs(line, sfp);
		fclose(sfp);
		fclose(mfp);
		unlink(tempfile);
		sprintf(line, "%s/%s/himsg", MSGBASE, conf);
		if ((sfp = fopen(line, "w")) == NULL)
		    {
		    log("Error %d opening %s", errno, line);
		    panic("himsg");
		    }
		fprintf(sfp, "%d\n", mcnt);
		fclose(sfp);
		rmlock(lockfile);
		return 1;
	    default:
		puts("Please enter L, C, E, S, or A; or ? for help.");
	    }
	}
    }

input(file)
    char *file;
    {
    FILE *fp;
    char line[256], *p;

    if ((fp = fopen(file, "a")) == NULL)
	{
	log("Error %d opening %s", errno, file);
	unlink(file);
	panic("tmp");
	}
    puts("\nEnter your text now.  End it with a slash on a line by itself.\n");
    log("Entering text...");
    for (;;)
	{
	printf("] ");
	if (gets(line) == NULL)
	    {
	    log("Illegal character: EOF");
	    clearerr(stdin);			/* 4.2 brain damage fix */
	    continue;
	    }
	if (strcmp(line, "/") == 0)
	    break;
	for (p = line; *p != '\0'; p++)
	    if (iscntrl(*p) && *p != '\t')
		{
		log("Illegal character: ^%c", uncntrl(*p));
		putc('^', fp);
		putc(uncntrl(*p), fp);
		}
	    else
		putc(*p, fp);
	putc('\n', fp);
	}
    fclose(fp);
    }

edit(file)
    char *file;
    {
    char line[256], rline[256], *edtemp = mktemp("/tmp/UaEdXXXXXX");
    short lcnt, lnum;
    FILE *ip, *fp;

    for (;;)
	{
	printf("\nLine number to edit (<ENTER> to exit): ");
	gets(line);
	log("Line #: %s", line);
	if (line[0] == '\0')
	    return;
	lnum = atoi(line);
	if (lnum < 1)
	    continue;
	if ((fp = fopen(file, "r")) == NULL)
	    {
	    log("Error %d opening %s", errno, file);
	    panic("tmp");
	    }
	if ((ip = fopen(edtemp, "w")) == NULL)
	    {
	    log("Error %d opening %s", errno, edtemp);
	    puts("Can't open the temporary file.");
	    fclose(fp);
	    return;
	    }
	for (lcnt = 1; lcnt < lnum; lcnt++)
	    {
	    fgets(line, 256, fp);
	    fputs(line, ip);
	    }
	fgets(line, 256, fp);
	if (feof(fp))
	    {
	    puts("Not that many lines in the message.");
	    fclose(fp);
	    fclose(ip);
	    unlink(edtemp);
	    continue;
	    }
	printf("\nLine %d currently reads:\n\n> %s\nRe-enter the line, or hit <ENTER> to leave it unchanged:\n\n] ", lnum, line);
	gets(rline);
	log("Replacement: %s", rline);
	if (rline[0] == '\0')
	    fputs(line, ip);
	else
	    fprintf(ip, "%s\n", rline);
	while (fgets(line, 256, fp) != NULL)
	    fputs(line, ip);
	fclose(ip);
	fclose(fp);
	unlink(file);
	if (copylink(edtemp, file) < 0)
	    {
	    log("Error %d copylinking %s to %s", errno, edtemp, file);
	    panic("copylink");
	    }
	unlink(edtemp);
	}
    }
    
doqscan(msg, conf, mnum)
    char *msg, *conf;
    short mnum;
    {
    char line[1024];
    FILE *f;

    if ((f = fopen(msg, "r")) == NULL)
	{
	puts("Cannot open file.");
	log("Error %d opening %s", errno, msg);
	return 1;
	}
    printf("%5d. ", mnum);
    if (isprivate(msg))
	puts("Private message.");
    else
	while (fgets(line, 1024, f) != NULL)
	    {
	    if (line[0] == '\n')
		break;
	    if (strncmp(line, "Subject: ", 9) == 0)
		{
		printf("%s", &line[9]);
		break;
		}
	    if (strncmp(line, "Subject (Private): ", 19) == 0)
		{
		printf("%s", &line[8]);		/* include privacy tag */
		break;
		}
	    }
    fclose(f);
    if (mnum % 16 == 0)	/* kludge, see comment in doscan() */
    	if (!cont())
    	    longjmp(cmdloop, 1);
    return 1;
    }

qscan(s)
    char *s;
    {
    return selmsg(s, doqscan);
    }
SHAR_EOF
if test 16927 -ne "`wc -c < 'msg.c'`"
then
	echo shar: error transmitting "'msg.c'" '(should have been 16927 characters)'
fi
fi
echo shar: extracting "'param.c'" '(4415 characters)'
if test -f 'param.c'
then
	echo shar: will not over-write existing file "'param.c'"
else
cat << \SHAR_EOF > 'param.c'
/*
 * %W% %E% %U% ncoast!bsa %Z%
 * %Z% Copyright (C) 1986 by Brandon S. Allbery, All Rights Reserved %Z%
 */

#ifndef lint
static char _SccsId[] = "%W% %E% %U% ncoast!bsa %Z%";
static char _CopyRt[] = "%Z% Copyright (C) 1985 by Brandon S. Allbery %Z%";
#endif  lint

#include "ua.h"

struct sys parms = {
	"/usr/unaxcess",
	1,
	0,
	"ua-edit",
	"/bin/sh",
	1,
	"unaxcess",
	30,
	"sysop",
	1,
	0,
	"",
	"",
	1,
	3,
	"trap '' 2; stty -echo; echo 'Begin sending your file.  End with a CONTROL-D.'; cat - > %s; stty echo",
	"trap '' 2; cat %s",
	"umodem -rb",
	"umodem -sb",
	"kermit -iwr",
	"kermit -iws",
};

#define NUM		0
#define STR		1
#define BOOL		2

struct rparm {
	char *parmname;
	char parmtype;
	char *parmval;
} sysparms[] = {
	"readonly",	BOOL,	&parms.ua_roc,
	"x-rated",	BOOL,	&parms.ua_xrc,
	"editor",	STR,	parms.ua_edit,
	"shell",	STR,	parms.ua_shell,
	"read-env",	BOOL,	&parms.ua_env,
	"bbs-user",	STR,	parms.ua_bbs,
	"time-limit",	NUM,	&parms.ua_tlimit,
	"sysop",	STR,	parms.ua_sysop,
	"private-msgs",	BOOL,	&parms.ua_pm,
	"logging",	BOOL,	&parms.ua_log,
	"banner",	STR,	parms.ua_bnr,
	"login-msg",	STR,	parms.ua_login,
	"pauses",	NUM,	&parms.ua_hco,
	"login-tries",	NUM,	&parms.ua_nla,
	"ascii-upload",	STR,	parms.ua_auc,
	"ascii-download",STR,	parms.ua_adc,
	"xmodem-upload",STR,	parms.ua_xuc,
	"xmodem-download",STR,	parms.ua_xdc,
	"kermit-upload",STR,	parms.ua_kuc,
	"kermit-download",STR,	parms.ua_kdc,
	0,		0,	0,
};

/*
 * 1. Get home directory
 * 2. Open $HOME/uaconfig
 * 3. Parse lines; # is a comment, input form is KEYWORD VALUE
 *    VALUE is numeric, Y/N, "string" and backslash escapes for
 *     \n \t \r \b \f \e \nnn are understood
 * 4. Assign the values to the parms structure
 */

static char line[512], var[20], sval[50];
 
getparms() {
 	char home[512];
 	FILE *cfp;
 	short nval, cnt, pos, scnt, canon;
 	
#ifdef JPNHACK
 	strcpy(home, "/c/jpn/ua");
#else
 	strcpy(home, getpwuid(geteuid())->pw_dir);
#endif
 	strcpy(parms.ua_home, home);
 	strcpy(line, home);
 	strcat(line, "/");
 	strcat(line, CONFIG);
 	if ((cfp = fopen(line, "r")) == NULL) {
 		fprintf(stderr, "panic: param get, %s\n", line);
 		exit(1);
 	}
 	while (fgets(line, 512, cfp) != NULL) {
 		line[strlen(line) - 1] = '\0';
 		if (Index(line, '#') != NULL)
 			*(Index(line, '#')) = '\0';
 		scnt = 0;
 		pos = 0;
 		while (line[pos] != '\0' && line[pos] != ' ' && line[pos] != '\t')
 			var[scnt++] = line[pos++];
 		var[scnt] = '\0';
 		if (var[0] == '\0')
 			continue;
 		for (cnt = 0; sysparms[cnt].parmname != NULL; cnt++)
 			if (strcmp(sysparms[cnt].parmname, var) == 0)
 				break;
 		if (sysparms[cnt].parmname == NULL) {
 			fprintf(stderr, "Please inform the sysop that there is an invalid parameter\nin the setup file.\n");
 			continue;
 		}
		while (line[pos] == ' ' || line[pos] == '\t')
			pos++;
 		switch (sysparms[cnt].parmtype) {
 			case NUM:
 				*((char *) sysparms[cnt].parmval) = atoi(&line[pos]) & 0xff;
 				break;
 			case BOOL:
 				if (line[pos] == '\0' || ToLower(line[pos]) == 'y')
 					*((char *) sysparms[cnt].parmval) = 1;
 				else
 					*((char *) sysparms[cnt].parmval) = 0;
 				break;
 			case STR:
 				if (line[pos] == '"') {
 					canon = 1;
 					pos++;
 				}
 				for (scnt = 0; (canon? line[pos] != '"': line[pos] != '\0' && line[pos] != ' ' && line[pos] != '\t'); pos++, scnt++) {	
 					if (canon && line[pos] == '\\') {
 						switch (line[++pos]) {	
 							case 'n':
 								sval[scnt] = '\n';
 								break;
 							case 't':
 								sval[scnt] = '\t';
 								break;
 							case 'r':
 								sval[scnt] = '\r';
 								break;
 							case 'b':
 								sval[scnt] = '\b';
 								break;
 							case 'f':
 								sval[scnt] = '\f';
 								break;
 							case 'e':
 							case 'E':
 								sval[scnt] = '\033';
 								break;
 							case 'a':
 								sval[scnt] = '\7';	/* proposed extension of C string metasyntax */
 								break;
 							case '0':
 							case '1':
 							case '2':
 							case '3':
 							case '4':
 							case '5':
 							case '6':
 							case '7':
 								sval[scnt] = 0;
 								while (Index("01234567", line[pos]) != NULL)
 									sval[scnt] = sval[scnt] * 8 + (line[pos++] - '0');
								pos--;
								break;
							default:
								sval[scnt] = line[pos];
 						}
 					}
 					else
 						sval[scnt] = line[pos];
 				}
 				sval[scnt] = '\0';
 				strcpy(sysparms[cnt].parmval, sval);
 		}
 	}
}
SHAR_EOF
if test 4415 -ne "`wc -c < 'param.c'`"
then
	echo shar: error transmitting "'param.c'" '(should have been 4415 characters)'
fi
fi
echo shar: extracting "'sys.c'" '(8173 characters)'
if test -f 'sys.c'
then
	echo shar: will not over-write existing file "'sys.c'"
else
cat << \SHAR_EOF > 'sys.c'
/*
 * %W% %E% %U% ncoast!bsa %Z%
 * %Z% Copyright (C) 1986 by Brandon S. Allbery, All Rights Reserved %Z%
 */

#ifndef lint
static char _SccsId[] = "%W% %E% %U% ncoast!bsa %Z%";
static char _CopyRt[] = "%Z% Copyright (C) 1985 by Brandon S. Allbery %Z%";
#endif  lint

#include "ua.h"

static FILE *lfp;

short critical = 0;

short quitc = 0;
short intr = 0;
short alrm = 0;

short shhh = 0;

short warned = 0;

#ifdef SYS3
#include <sys/ioctl.h>
#include <termio.h>
struct termio mode;
#else
#include <sgtty.h>
#ifndef V7
#include <sys/ioctl.h>
#endif
struct sgttyb mode;
#endif

logon()
    {
    struct stat sb;
    char *cp;
    char *getenv();

    	/* first set up ttymode structure */
#ifdef SYS3
    ioctl(0, TCGETA, &mode);
#else
#ifdef V7
    gtty(0, &mode);
#else
    ioctl(0, TIOCGETP, &mode);
#endif
#endif

    if (parms.ua_env) {
    	if ((cp = getenv("SHELL")) != NULL)
    		strcpy(parms.ua_shell, cp);
    	if ((cp = getenv("EDITOR")) != NULL)
    		strcpy(parms.ua_edit, cp);
    }
    
    if (!parms.ua_log || stat(LOG, &sb) < 0)		/* no logfile => no logging */
	{
	lfp = NULL;
	return;
	}
    if ((lfp = fopen(LOG, "a")) == NULL)
	{
	perror(LOG);
	puts("panic: log");
	exit(2);
	}
    }

log(fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9)
    char *fmt, *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8, *a9;
    {
    char buf[1024];
    static char lockfile[] = "logfile.lock";

    if (lfp == NULL)			/* logging not enabled */
	return;
    CRIT();
    sprintf(buf, fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    mklock(lockfile);
    fprintf(lfp, "%s (%05d)  %s\n", date(), getpid(), visible(buf));
    fflush(lfp);
    rmlock(lockfile);
    NOCRIT();
    }

logsig(sig)
    int sig;
    {
    log("Received signal %d.", sig);
    panic("signal");
    }

panic(s)
    char *s;
    {
    log("panic: %s", s);
    fprintf(stderr, "panic: %s\n", s);
    unlink(RIndex(ttyname(2), '/') + 1);
    exit(1);
    }

quit()
    {
    char line[256];

    if (critical) {
    	quitc++;
    	return;
    }
    puts("\n\nFast logout\n");
    signal(SIGQUIT, quit);
    log("Signalled QUIT.");
    printf("\nDo you really want to leave UNaXcess (N)? ");
    gets(line);
    if (ToLower(line[0]) == 'y')
	{
	printf("OK, %s.  See you later!\n\n\n", user.u_name);
	cleanup();
	}
    }

intrp()
    {
    if (critical) {
    	intr++;
    	return;
    }
    puts("\n\nAborted.");
    log("Command aborted.");
    signal(SIGINT, intrp);
    longjmp(cmdloop, 1);
    }

char *visible(s)
    char *s;
    {
    static char vs[256];
    char *sp, *vp;

    vp = vs;
    for (sp = s; *sp != '\0'; sp++)
	if (!iscntrl(*sp))
	    *vp++ = *sp;
	else
	    {
	    *vp++ = '^';
	    *vp++ = uncntrl(*sp);
	    }
    *vp = '\0';
    return vs;
    }

shell()
    {
    short sig;
    unsigned altime;

    if (user.u_access == A_GUEST || user.u_access == A_USER || parms.ua_shell[0] == '\0')
	{
	puts("You don't have shell access privileges.");
	log("Security violation:  Unauthorized SHELL");
	return 1;
	}
    switch (fork())
	{
	case -1:
	    log("Error %d forking shell", errno);
	    puts("Sorry, the system's full.  Try again later.");
	    return 1;
	case 0:
	    for (sig = 2; sig < SIGUSR1; sig++)
		signal(sig, SIG_DFL);
	    setuid(getuid());
	    chdir(getpwuid(getuid())->pw_dir);
	    run(parms.ua_shell, 0);
	    log("Error %d exec'ing %s", errno, parms.ua_shell);
	    puts("Couldn't run the shell.");
	    exit(1);
	default:
	    CRIT();
	    for (sig = 2; sig < SIGUSR1; sig++)
		signal(sig, SIG_IGN);
	    signal(SIGALRM, thatsall);	/* trapped by the CRIT() */
	    wait(NULL);
	    signal(SIGINT, intrp);
	    signal(SIGQUIT, quit);
	    for (sig = 4; sig < SIGUSR1; sig++)
		signal(sig, logsig);
	    signal(SIGALRM, thatsall);
	    NOCRIT();
	}
    return 1;
    }

thatsall()
    {
    if (critical) {
    	alrm++;
    	return;
    }
    if (warned) {
        log("Timeout.");
        puts("\nI'm sorry, but you're out of time.\n\n");
        cleanup();
        }
    else 
        {
    	log("5-minute warning.");
    	puts("\nYou have only five minutes left in this session.\n\n");
    	warned = 1;
    	alarm(5 * 60);
        }
    }

/*
 * I've had problems with this.  If it breaks, delete the innards of the lock
 * functions.  Hopefully, I got it right this time...
 */

mklock(lockfile)
char *lockfile; {
    char lockpath[50];
    int lock_fd;
    struct stat statbuf;
    
/*  strcpy(lockpath, "lock/"); */  /* jpn - install did not create lock/ */
    strcpy(lockpath, lockfile);
    while (stat(lockpath, &statbuf) == 0)
        if (statbuf.st_atime > 60) {
            unlink(lockpath);
            break;
        }
    if ((lock_fd = creat(lockpath, 0600)) < 0) {
        fprintf(stderr, "Errno = %d creating lockfile %s\n", errno, lockpath);
        exit(-1);
    }
    close(lock_fd);
}

rmlock(lockfile)
char *lockfile; {
    char lockpath[50];
    struct stat statbuf;
    
/*  strcpy(lockpath, "lock/"); */  /* jpn - install did not create lock/ */
    strcpy(lockpath, lockfile);
    if (stat(lockpath, &statbuf) < 0) {
        log("Lockfile %s deleted???", lockpath);
        printf("\n\nSomeone futzed with the lockfile.  Please tell %s IMMEDIATELY!!!\nSorry, but this means I have to log you out now.\n\n", parms.ua_sysop);
        panic("LOCKFILE DELETED");
    }
    if (unlink(lockpath) < 0) {
        log("Errno = %d, can't unlink lockfile %s", errno, lockpath);
        puts("\nI've got a lockfile problem.  You won't be able to do some\nthings until it's fixed.  Sorry...\n");
    }
}

xedit(file)
    char *file;
    {
    short sig;
    unsigned altime;

    if (user.u_access == A_GUEST || user.u_access == A_USER || parms.ua_edit[0] == '\0')
	{
	puts("You don't have shell access privileges.");
	log("Security violation:  Unauthorized XEDIT");
	return 1;
	}
    if (strcmp(parms.ua_edit, "ua-edit") == 0) {
    	edit(file);
    	return 1;
    }
    switch (fork())
	{
	case -1:
	    log("Error %d forking shell", errno);
	    puts("Sorry, the system's full.  Using the line editor...");
	    edit(file);
	    return 1;
	case 0:
	    for (sig = 2; sig < SIGUSR1; sig++)
		signal(sig, SIG_DFL);
	    setuid(getuid());
	    chdir(getpwuid(getuid())->pw_dir);
	    run(parms.ua_edit, file);
	    log("Error %d exec'ing %s", errno, parms.ua_edit);
	    puts("Couldn't run the editor; using the line editor...");
	    edit(file);
	    exit(0);
	default:
	    CRIT();
	    for (sig = 2; sig < SIGUSR1; sig++)
		signal(sig, SIG_IGN);
	    signal(SIGALRM, thatsall);
	    wait(NULL);
	    signal(SIGINT, intrp);
	    signal(SIGQUIT, quit);
	    for (sig = 4; sig < SIGUSR1; sig++)
		signal(sig, logsig);
	    signal(SIGALRM, thatsall);
	    NOCRIT();
	}
    return 1;
    }

CRIT() {
	alrm = 0;
	quitc = 0;
	intr = 0;
	if (critical)
		return;	/* clears pending signals */
	critical = 1;
}

NOCRIT() {
	if (!critical)
		return;
	critical = 0;
	if (alrm)
		thatsall(14);
	if (quitc)
		quit(3);
	if (intr)
		intrp(2);
	alrm = 0;
	quitc = 0;
	intr = 0;
}

run(cmd, arg)
char *cmd, *arg; {
	char cmdbuf[5120];
	
	sprintf(cmdbuf, "%s %s", cmd, (arg? arg: ""));
	execl("/bin/sh", "sh", "-c", cmdbuf, 0);
	return -1;
}

silent() {
	if (shhh)
		return;
#ifdef SYS3
	mode.c_lflag &= ~(ICANON|ISIG|ECHO|ECHOE|ECHOK);
	mode.c_cc[VMIN] = 1;
	mode.c_cc[VTIME] = 0;
	ioctl(0, TCSETAW, &mode);
#else
	mode.sg_flags |= CBREAK;
	mode.sg_flags &= ~ECHO;
#ifdef V7
	stty(0, &mode);
#else
	ioctl(0, TIOCSETP, &mode);
#endif
#endif
	shhh = 1;
}

talk() {
	if (!shhh)
		return;
#ifdef SYS3
	mode.c_lflag |= (ICANON|ISIG|ECHO|ECHOE|ECHOK);
	mode.c_cc[VEOF] = CEOF;
	mode.c_cc[VEOL] = CNUL;
	ioctl(0, TCSETAW, &mode);
#else
	mode.sg_flags |= ECHO;
	mode.sg_flags &= ~CBREAK;
#ifdef V7
	stty(0, &mode);
#else
	ioctl(0, TIOCSETP, &mode);
#endif
#endif
	shhh = 0;
}

copylink(src, dest)
char *src, *dest; {
	int srcp, destp, cnt;
	char buf[1024];
	
	if (link(src, dest) == 0) {
		unlink(src);
		return 0;
	}
	if ((srcp = open(src, 0)) < 0) {
		perror(src);
		return -1;
	}
	unlink(dest);
	if ((destp = creat(dest, 0600)) < 0) {
		perror(dest);
		return -1;
	}
	while ((cnt = read(srcp, buf, sizeof buf)) > 0)
		write(destp, buf, cnt);
	close(destp);
	close(srcp);
	return 0;
}
SHAR_EOF
if test 8173 -ne "`wc -c < 'sys.c'`"
then
	echo shar: error transmitting "'sys.c'" '(should have been 8173 characters)'
fi
fi
exit 0
#	End of shell archive
