From: genrad!decvax!minow (Martin Minow)
Subject: Microemacs (Part 4 of 6)
Newsgroups: mod.sources
Approved: jpn@panda.UUCP

Mod.sources:  Volume 4, Issue 71
Submitted by: decvax!minow (Martin Minow)

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	sys
# This archive created: Sun Apr 13 11:17:16 1986
export PATH; PATH=/bin:$PATH
if test ! -d 'sys'
then
	echo shar: creating directory "'sys'"
	mkdir 'sys'
fi
if test ! -d 'sys/atari'
then
	echo shar: creating directory "'sys/atari'"
	mkdir 'sys/atari'
fi
echo shar: extracting "'sys/atari/c.bat'" '(133 characters)'
if test -f 'sys/atari/c.bat'
then
	echo shar: will not over-write existing file "'sys/atari/c.bat'"
else
cat << \SHAR_EOF > 'sys/atari/c.bat'
a:cp68 -i a: %1.c %1.i
a:c068 %1.i %1.1 %1.2 %1.3 -f
a:rm %1.i
a:c168 %1.1 %1.2 %1.s
a:rm %1.1
a:rm %1.2
a:as68 -l -u %1.s
a:rm %1.s
SHAR_EOF
if test 133 -ne "`wc -c < 'sys/atari/c.bat'`"
then
	echo shar: error transmitting "'sys/atari/c.bat'" '(should have been 133 characters)'
fi
fi
echo shar: extracting "'sys/atari/fileio.c'" '(2956 characters)'
if test -f 'sys/atari/fileio.c'
then
	echo shar: will not over-write existing file "'sys/atari/fileio.c'"
else
cat << \SHAR_EOF > 'sys/atari/fileio.c'
/*
 * Name:	MicroEMACS
 *		Atari 520ST file I/O.
 * Version:	30
 * Last edit:	22-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	"def.h"

extern	FILE	*fopen();
static	FILE	*ffp;

/*
 * Open a file for reading.
 */
ffropen(fn)
char	*fn;
{
	ffp = fopen(fn, "r");
	adjustcase(fn);
	if (ffp == NULL)
		return (FIOFNF);
	return (FIOSUC);
}

/*
 * Open a file for writing.
 * Return TRUE if all is well, and
 * FALSE on error (cannot create).
 */
ffwopen(fn)
char	*fn;
{
	ffp = fopen(fn, "w");
	adjustcase(fn);
	if (ffp == NULL) {
		eprintf("Cannot open file for writing");
		return (FIOERR);
	}
	return (FIOSUC);
}

/*
 * Close a file.
 * Should look at the status.
 */
ffclose()
{
	fclose(ffp);
	return (FIOSUC);
}

/*
 * Write a line to the already
 * opened file. The "buf" points to the
 * buffer, and the "nbuf" is its length, less
 * the free newline. Return the status.
 * Check only at the newline.
 */
ffputline(buf, nbuf)
register char	buf[];
{
	register int	i;

	for (i=0; i<nbuf; ++i)
		putc(buf[i]&0xFF, ffp);
	putc('\n', ffp);
	if (ferror(ffp) != FALSE) {
		eprintf("Write I/O error");
		return (FIOERR);
	}
	return (FIOSUC);
}

/*
 * Read a line from a file, and store the bytes
 * in the supplied buffer. Stop on end of file or end of
 * line. Don't get upset by files that don't have an end of
 * line on the last line; this seem to be common on CP/M-86 and
 * MS-DOS (the suspected culprit is VAX/VMS kermit, but this
 * has not been confirmed. If this is sufficiently researched
 * it may be possible to pull this kludge). Delete any CR
 * followed by an LF. This is mainly for runoff documents,
 * both on VMS and on Ultrix (they get copied over from
 * VMS systems with DECnet).
 */
ffgetline(buf, nbuf)
register char	buf[];
{
	register int	c;
	register int	i;

	i = 0;
	for (;;) {
		c = getc(ffp);
		if (c == '\r') {		/* Delete any non-stray	*/
			c = getc(ffp);		/* carriage returns.	*/
			if (c != '\n') {
				if (i >= nbuf-1) {
					eprintf("File has long line");
					return (FIOERR);
				}
				buf[i++] = '\r';
			}
		}
		if (c==EOF || c=='\n')		/* End of line.		*/
			break;
		if (i >= nbuf-1) {
			eprintf("File has long line");
			return (FIOERR);
		}
		buf[i++] = c;
	}
	if (c == EOF) {				/* End of file.		*/
		if (ferror(ffp) != FALSE) {
			eprintf("File read error");
			return (FIOERR);
		}
		if (i == 0)			/* Don't get upset if	*/
			return (FIOEOF);	/* no newline at EOF.	*/
	}
	buf[i] = 0;
	return (FIOSUC);
}

/*
 * Finish this routine when you decide
 * what the right thing to do when renaming a
 * file for backup purposes.
 */
fbackupfile(fname)
char	*fname;
{
	return (TRUE);
}

/*
 * Zap file name to lower case, since
 * the system on the 520ST has case insensitive
 * file names, and lower looks better in the
 * modelines than upper.
 */
adjustcase(fn)
register char	*fn;
{
	register int	c;

	while ((c = *fn) != 0) {
		if (ISUPPER(c) != FALSE)
			*fn = TOLOWER(c);
		++fn;
	}
}
SHAR_EOF
if test 2956 -ne "`wc -c < 'sys/atari/fileio.c'`"
then
	echo shar: error transmitting "'sys/atari/fileio.c'" '(should have been 2956 characters)'
fi
fi
echo shar: extracting "'sys/atari/getn.s'" '(583 characters)'
if test -f 'sys/atari/getn.s'
then
	echo shar: will not over-write existing file "'sys/atari/getn.s'"
else
cat << \SHAR_EOF > 'sys/atari/getn.s'
* Routines to read the size of the display.
* MicroEMACS works even on a screen that has been blessed
* by the "hi50" program.
* MicroEMACS version 30, for the Atari.

	.text

* getnrow() -- get number of rows.

	.globl	_getnrow

_getnrow:

	move.l	a2, -(sp)
	move.l	d2, -(sp)
	dc.w	$A000
	move.l	(sp)+, d2
	movea.l	(sp)+, a2

	move.w	-42(a0), d0
	addq.w	#1, d0
	ext.l	d0

	rts

* getncol() -- get number of columns.

	.globl	_getncol

_getncol:
	move.l	a2, -(sp)
	move.l	d2, -(sp)
	dc.w	$A000
	move.l	(sp)+, d2
	movea.l	(sp)+, a2

	move.w	-44(a0), d0
	addq.w	#1, d0
	ext.l	d0

	rts
SHAR_EOF
if test 583 -ne "`wc -c < 'sys/atari/getn.s'`"
then
	echo shar: error transmitting "'sys/atari/getn.s'" '(should have been 583 characters)'
fi
fi
echo shar: extracting "'sys/atari/spawn.c'" '(423 characters)'
if test -f 'sys/atari/spawn.c'
then
	echo shar: will not over-write existing file "'sys/atari/spawn.c'"
else
cat << \SHAR_EOF > 'sys/atari/spawn.c'
/*
 * Name:	MicroEMACS
 *		Atari 520ST CLI spawn.
 * Version:	30
 * Last edit:	22-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	"def.h"

/*
 * Spawn CLI. Since MicroEMACS wants to hold
 * a lot of memory, this may never be made to work right
 * in GEMDOS. On the other hand, it sure would be a
 * nice thing to have.
 */
spawncli(f, n, k)
{
	eprintf("Not in GEMDOS");
	return (FALSE);
}
SHAR_EOF
if test 423 -ne "`wc -c < 'sys/atari/spawn.c'`"
then
	echo shar: error transmitting "'sys/atari/spawn.c'" '(should have been 423 characters)'
fi
fi
echo shar: extracting "'sys/atari/sysdef.h'" '(721 characters)'
if test -f 'sys/atari/sysdef.h'
then
	echo shar: will not over-write existing file "'sys/atari/sysdef.h'"
else
cat << \SHAR_EOF > 'sys/atari/sysdef.h'
/*
 * Name:	MicroEMACS
 *		Atari 520ST header file.
 * Version:	30
 * Last edit:	22-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#define	PCC	1			/* "[]" gets an error.		*/
#define	KBLOCK	512			/* Kill grow.			*/
#define	GOOD	0			/* Good exit status.		*/

/*
 * For "(void)" casts.
 */
typedef	int	void;

/*
 * Macros used by the buffer name making code.
 * Start at the end of the file name, scan to the left
 * until BDC1 (or BDC2, if defined) is reached. The buffer
 * name starts just to the right of that location, and
 * stops at end of string (or at the next BDC3 character,
 * if defined). BDC2 and BDC3 are mainly for VMS.
 */
#define	BDC1	'\\'			/* Buffer names.		*/
#define	BDC2	':'
SHAR_EOF
if test 721 -ne "`wc -c < 'sys/atari/sysdef.h'`"
then
	echo shar: error transmitting "'sys/atari/sysdef.h'" '(should have been 721 characters)'
fi
fi
echo shar: extracting "'sys/atari/ttyio.c'" '(714 characters)'
if test -f 'sys/atari/ttyio.c'
then
	echo shar: will not over-write existing file "'sys/atari/ttyio.c'"
else
cat << \SHAR_EOF > 'sys/atari/ttyio.c'
/*
 * Name:	MicroEMACS
 *		Atari 520ST terminal I/O.
 * Version:	30
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	"def.h"
#include	<osbind.h>

int	nrow;				/* Terminal size, rows.		*/
int	ncol;				/* Terminal size, columns.	*/

/*
 * Open. Determine the size of
 * the display by calling the assembly
 * language "getnrow" and "getncol"
 * routines.
 */
ttopen()
{
	nrow = getnrow();
	if (nrow > NROW)
		nrow = NROW;
	ncol = getncol();
	if (ncol > NCOL)
		ncol = NCOL;
}
/*
 * No-op.
 */
ttclose()
{
}

/*
 * Put character.
 */
ttputc(c)
{
	Crawio(c & 0x7F);
}

/*
 * No-op.
 */
ttflush()
{
}

/*
 * Get characters.
 */
ttgetc()
{
	return (Crawcin() & 0x7F);
}
SHAR_EOF
if test 714 -ne "`wc -c < 'sys/atari/ttyio.c'`"
then
	echo shar: error transmitting "'sys/atari/ttyio.c'" '(should have been 714 characters)'
fi
fi
echo shar: extracting "'sys/atari/xemacs.bat'" '(74 characters)'
if test -f 'sys/atari/xemacs.bat'
then
	echo shar: will not over-write existing file "'sys/atari/xemacs.bat'"
else
cat << \SHAR_EOF > 'sys/atari/xemacs.bat'
a:link68 [co[XEMACS.INP]]
a:relmod XEMACS.68K XEMACS.TOS
a:rm XEMACS.68K

SHAR_EOF
if test 74 -ne "`wc -c < 'sys/atari/xemacs.bat'`"
then
	echo shar: error transmitting "'sys/atari/xemacs.bat'" '(should have been 74 characters)'
fi
fi
echo shar: extracting "'sys/atari/xemacs.inp'" '(256 characters)'
if test -f 'sys/atari/xemacs.inp'
then
	echo shar: will not over-write existing file "'sys/atari/xemacs.inp'"
else
cat << \SHAR_EOF > 'sys/atari/xemacs.inp'
[U] XEMACS.68K=A:GEMS.O,
BASIC.O,
BUFFER.O,
CINFO.O,
DISPLAY.O,
ECHO.O,
EXTEND.O,
FILE.O,
FILEIO.O,
GETN.O,
KBD.O,
LINE.O,
MAIN.O,
RANDOM.O,
REGION.O,
SEARCH.O,
SPAWN.O,
SYMBOL.O,
TTY.O,
TTYKBD.O,
TTYIO.O,
VERSION.O,
WINDOW.O,
WORD.O,
A:OSBIND.O,
A:GEMLIB
SHAR_EOF
if test 256 -ne "`wc -c < 'sys/atari/xemacs.inp'`"
then
	echo shar: error transmitting "'sys/atari/xemacs.inp'" '(should have been 256 characters)'
fi
fi
echo shar: done with directory "'sys/atari'"
if test ! -d 'sys/cpm86'
then
	echo shar: creating directory "'sys/cpm86'"
	mkdir 'sys/cpm86'
fi
echo shar: extracting "'sys/cpm86/fileio.c'" '(3242 characters)'
if test -f 'sys/cpm86/fileio.c'
then
	echo shar: will not over-write existing file "'sys/cpm86/fileio.c'"
else
cat << \SHAR_EOF > 'sys/cpm86/fileio.c'
/*
 * Name:	MicroEMACS
 *		CP/M-86 file I/O.
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	"def.h"

static	FILE	*ffp;

/*
 * Open a file for reading.
 */
ffropen(fn)
char	*fn;
{
	if ((ffp=fopen(fn, "r")) == NULL)
		return (FIOFNF);
	return (FIOSUC);
}

/*
 * Open a file for writing.
 * Return TRUE if all is well, and
 * FALSE on error (cannot create).
 */
ffwopen(fn)
char	*fn;
{
	if ((ffp=fopen(fn, "w")) == NULL) {
		eprintf("Cannot open file for writing");
		return (FIOERR);
	}
	return (FIOSUC);
}

/*
 * Close a file.
 * Should look at the status.
 */
ffclose()
{
	fclose(ffp);
	return (FIOSUC);
}

/*
 * Write a line to the already
 * opened file. The "buf" points to the
 * buffer, and the "nbuf" is its length, less
 * the free newline. Return the status.
 * Check only at the newline.
 */
ffputline(buf, nbuf)
register char	buf[];
{
	register int	i;

	for (i=0; i<nbuf; ++i)
		putc(buf[i]&0xFF, ffp);
	putc('\n', ffp);
	if (ferror(ffp) != FALSE) {
		eprintf("Write I/O error");
		return (FIOERR);
	}
	return (FIOSUC);
}

/*
 * Read a line from a file, and store the bytes
 * in the supplied buffer. Stop on end of file or end of
 * line. Don't get upset by files that don't have an end of
 * line on the last line; this seem to be common on CP/M-86 and
 * MS-DOS (the suspected culprit is VAX/VMS kermit, but this
 * has not been confirmed. If this is sufficiently researched
 * it may be possible to pull this kludge). Delete any CR
 * followed by an LF. This is mainly for runoff documents,
 * both on VMS and on Ultrix (they get copied over from
 * VMS systems with DECnet).
 */
ffgetline(buf, nbuf)
register char	buf[];
{
	register int	c;
	register int	i;

	i = 0;
	for (;;) {
		c = getc(ffp);
		if (c == '\r') {		/* Delete any non-stray	*/
			c = getc(ffp);		/* carriage returns.	*/
			if (c != '\n') {
				if (i >= nbuf-1) {
					eprintf("File has long line");
					return (FIOERR);
				}
				buf[i++] = '\r';
			}
		}
		if (c==EOF || c=='\n')		/* End of line.		*/
			break;
		if (i >= nbuf-1) {
			eprintf("File has long line");
			return (FIOERR);
		}
		buf[i++] = c;
	}
	if (c == EOF) {				/* End of file.		*/
		if (ferror(ffp) != FALSE) {
			eprintf("File read error");
			return (FIOERR);
		}
		if (i == 0)			/* Don't get upset if	*/
			return (FIOEOF);	/* no newline at EOF.	*/
	}
	buf[i] = 0;
	return (FIOSUC);
}

/*
 * Some CP/M-86 user should figure out
 * the right rules for backup file names, and make
 * this work. I don't use CP/M-86, so I cannot figure
 * out the right rules. Return TRUE so the callers
 * don't abort writes.
 */
fbackupfile(fname)
char	*fname;
{
	return (TRUE);				/* Hack.		*/
}

/*
 * The string "fn" is a file name.
 * Perform any required case adjustments. All sustems
 * we deal with so far have case insensitive file systems.
 * We zap everything to lower case. The problem we are trying
 * to solve is getting 2 buffers holding the same file if
 * you visit one of them with the "caps lock" key down.
 * On UNIX file names are dual case, so we leave
 * everything alone.
 */
adjustcase(fn)
register char	*fn;
{
	register int	c;

	while ((c = *fn) != 0) {
		if (c>='A' && c<='Z')
			*fn = c + 'a' - 'A';
		++fn;
	}
}
SHAR_EOF
if test 3242 -ne "`wc -c < 'sys/cpm86/fileio.c'`"
then
	echo shar: error transmitting "'sys/cpm86/fileio.c'" '(should have been 3242 characters)'
fi
fi
echo shar: extracting "'sys/cpm86/spawn.c'" '(466 characters)'
if test -f 'sys/cpm86/spawn.c'
then
	echo shar: will not over-write existing file "'sys/cpm86/spawn.c'"
else
cat << \SHAR_EOF > 'sys/cpm86/spawn.c'
/*
 * Name:	MicroEMACS
 *		CP/M-86 spawn a sub-CLI (ha-ha).
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	"def.h"

/*
 * Create a subjob with a copy
 * of the command intrepreter in it. When the
 * command interpreter exits, mark the screen as
 * garbage so that you do a full repaint. Bound
 * to "C-C" and called from "C-Z".
 */
spawncli(f, n, k)
{
	eprintf("Not in CP/M-86");
	return (FALSE);
}
SHAR_EOF
if test 466 -ne "`wc -c < 'sys/cpm86/spawn.c'`"
then
	echo shar: error transmitting "'sys/cpm86/spawn.c'" '(should have been 466 characters)'
fi
fi
echo shar: extracting "'sys/cpm86/sysdef.h'" '(571 characters)'
if test -f 'sys/cpm86/sysdef.h'
then
	echo shar: will not over-write existing file "'sys/cpm86/sysdef.h'"
else
cat << \SHAR_EOF > 'sys/cpm86/sysdef.h'
/*
 * Name:	MicroEMACS
 *		CP/M-86 system header file.
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#define	PCC	0			/* "[]" will work.		*/

/*
 * Macros used by the buffer name making code.
 * Start at the end of the file name, scan to the left
 * until BDC1 (or BDC2, if defined) is reached. The buffer
 * name starts just to the right of that location, and
 * stops at end of string (or at the next BDC3 character,
 * if defined). BDC2 and BDC3 are mainly for VMS.
 */
#define	BDC1	':'			/* Buffer name.			*/
SHAR_EOF
if test 571 -ne "`wc -c < 'sys/cpm86/sysdef.h'`"
then
	echo shar: error transmitting "'sys/cpm86/sysdef.h'" '(should have been 571 characters)'
fi
fi
echo shar: extracting "'sys/cpm86/ttyio.c'" '(614 characters)'
if test -f 'sys/cpm86/ttyio.c'
then
	echo shar: will not over-write existing file "'sys/cpm86/ttyio.c'"
else
cat << \SHAR_EOF > 'sys/cpm86/ttyio.c'
/*
 * Name:	MicroEMACS
 *		CP/M-86 terminal I/O.
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	"def.h"

#include	<bdos.h>

int	nrow;				/* Terminal size, rows.		*/
int	ncol;				/* Terminal size, columns.	*/

/*
 * Set up terminal.
 * Almost no operation in CP/M-86.
 */
ttopen()
{
	nrow = NROW;
	ncol = NCOL;
}

/*
 * No operation in CP/M-86.
 */
ttclose()
{
}

/*
 * Write character.
 */
ttputc(c)
{
	bios(BCONOUT, c, 0);
}

/*
 * No operation on CP/M-86.
 */
ttflush()
{
}

/*
 * Read character.
 */
ttgetc()
{
	return (biosb(BCONIN, 0, 0));
}
SHAR_EOF
if test 614 -ne "`wc -c < 'sys/cpm86/ttyio.c'`"
then
	echo shar: error transmitting "'sys/cpm86/ttyio.c'" '(should have been 614 characters)'
fi
fi
echo shar: done with directory "'sys/cpm86'"
if test ! -d 'sys/ultrix'
then
	echo shar: creating directory "'sys/ultrix'"
	mkdir 'sys/ultrix'
fi
echo shar: extracting "'sys/ultrix/Makefile'" '(873 characters)'
if test -f 'sys/ultrix/Makefile'
then
	echo shar: will not over-write existing file "'sys/ultrix/Makefile'"
else
cat << \SHAR_EOF > 'sys/ultrix/Makefile'
# Makefile for MicroEMACS.
# Is there a better way to do the rebuilds, other than using
# the links?

SYS	= ultrix
TTY	= ansi

CFLAGS	= -O

OBJ =	basic.o \
	buffer.o \
	cinfo.o \
	display.o \
	echo.o \
	extend.o \
	file.o \
	kbd.o \
	line.o \
	main.o \
	random.o \
	region.o \
	search.o \
	symbol.o \
	version.o \
	window.o \
	word.o \
	fileio.o \
	spawn.o \
	ttyio.o \
	tty.o \
	ttykbd.o

xemacs:		$(OBJ)
	cc -o xemacs $(OBJ)

$(OBJ):		def.h sysdef.h ttydef.h

sysdef.h:	sys/$(SYS)/sysdef.h	# Update links, if needed.
	ln sys/$(SYS)/sysdef.h .

ttydef.h:	tty/$(TTY)/ttydef.h
	ln tty/$(TTY)/ttydef.h .

fileio.c:	sys/$(SYS)/fileio.c
	ln sys/$(SYS)/fileio.c .

spawn.c:	sys/$(SYS)/spawn.c
	ln sys/$(SYS)/spawn.c .

tty.c:		tty/$(TTY)/tty.c
	ln tty/$(TTY)/tty.c .

ttyio.c:	sys/$(SYS)/ttyio.c
	ln sys/$(SYS)/ttyio.c .

ttykbd.c:	tty/$(TTY)/ttykbd.c
	ln tty/$(TTY)/ttykbd.c .
SHAR_EOF
if test 873 -ne "`wc -c < 'sys/ultrix/Makefile'`"
then
	echo shar: error transmitting "'sys/ultrix/Makefile'" '(should have been 873 characters)'
fi
fi
echo shar: extracting "'sys/ultrix/fileio.c'" '(3636 characters)'
if test -f 'sys/ultrix/fileio.c'
then
	echo shar: will not over-write existing file "'sys/ultrix/fileio.c'"
else
cat << \SHAR_EOF > 'sys/ultrix/fileio.c'
/*
 * Name:	MicroEMACS
 * 		Ultrix-32 file I/O.
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	"def.h"

static	FILE	*ffp;

/*
 * Open a file for reading.
 */
ffropen(fn)
char	*fn;
{
	if ((ffp=fopen(fn, "r")) == NULL)
		return (FIOFNF);
	return (FIOSUC);
}

/*
 * Open a file for writing.
 * Return TRUE if all is well, and
 * FALSE on error (cannot create).
 */
ffwopen(fn)
char	*fn;
{
	if ((ffp=fopen(fn, "w")) == NULL) {
		eprintf("Cannot open file for writing");
		return (FIOERR);
	}
	return (FIOSUC);
}

/*
 * Close a file.
 * Should look at the status.
 */
ffclose()
{
	fclose(ffp);
	return (FIOSUC);
}

/*
 * Write a line to the already
 * opened file. The "buf" points to the
 * buffer, and the "nbuf" is its length, less
 * the free newline. Return the status.
 * Check only at the newline.
 */
ffputline(buf, nbuf)
register char	buf[];
{
	register int	i;

	for (i=0; i<nbuf; ++i)
		putc(buf[i]&0xFF, ffp);
	putc('\n', ffp);
	if (ferror(ffp) != FALSE) {
		eprintf("Write I/O error");
		return (FIOERR);
	}
	return (FIOSUC);
}

/*
 * Read a line from a file, and store the bytes
 * in the supplied buffer. Stop on end of file or end of
 * line. Don't get upset by files that don't have an end of
 * line on the last line; this seem to be common on CP/M-86 and
 * MS-DOS (the suspected culprit is VAX/VMS kermit, but this
 * has not been confirmed. If this is sufficiently researched
 * it may be possible to pull this kludge). Delete any CR
 * followed by an LF. This is mainly for runoff documents,
 * both on VMS and on Ultrix (they get copied over from
 * VMS systems with DECnet).
 */
ffgetline(buf, nbuf)
register char	buf[];
{
	register int	c;
	register int	i;

	i = 0;
	for (;;) {
		c = getc(ffp);
		if (c == '\r') {		/* Delete any non-stray	*/
			c = getc(ffp);		/* carriage returns.	*/
			if (c != '\n') {
				if (i >= nbuf-1) {
					eprintf("File has long line");
					return (FIOERR);
				}
				buf[i++] = '\r';
			}
		}
		if (c==EOF || c=='\n')		/* End of line.		*/
			break;
		if (i >= nbuf-1) {
			eprintf("File has long line");
			return (FIOERR);
		}
		buf[i++] = c;
	}
	if (c == EOF) {				/* End of file.		*/
		if (ferror(ffp) != FALSE) {
			eprintf("File read error");
			return (FIOERR);
		}
		if (i == 0)			/* Don't get upset if	*/
			return (FIOEOF);	/* no newline at EOF.	*/
	}
	buf[i] = 0;
	return (FIOSUC);
}

/*
 * Rename the file "fname" into a backup
 * copy. On Unix the backup has the same name as the
 * original file, with a "~" on the end; this seems to
 * be newest of the new-speak. The error handling is
 * all in "file.c". The "unlink" is perhaps not the
 * right thing here; I don't care that much as
 * I don't enable backups myself.
 */
fbackupfile(fname)
char	*fname;
{
	register char	*nname;

	if ((nname=malloc(strlen(fname)+1+1)) == NULL)
		return (ABORT);
	(void) strcpy(nname, fname);
	(void) strcat(nname, "~");
	(void) unlink(nname);			/* Ignore errors.	*/
	if (rename(fname, nname) < 0) {
		free(nname);
		return (FALSE);
	}
	free(nname);
	return (TRUE);
}

/*
 * The string "fn" is a file name.
 * Perform any required case adjustments. All sustems
 * we deal with so far have case insensitive file systems.
 * We zap everything to lower case. The problem we are trying
 * to solve is getting 2 buffers holding the same file if
 * you visit one of them with the "caps lock" key down.
 * On UNIX file names are dual case, so we leave
 * everything alone.
 */
adjustcase(fn)
register char	*fn;
{
#if	0
	register int	c;

	while ((c = *fn) != 0) {
		if (c>='A' && c<='Z')
			*fn = c + 'a' - 'A';
		++fn;
	}
#endif
}
SHAR_EOF
if test 3636 -ne "`wc -c < 'sys/ultrix/fileio.c'`"
then
	echo shar: error transmitting "'sys/ultrix/fileio.c'" '(should have been 3636 characters)'
fi
fi
echo shar: extracting "'sys/ultrix/spawn.c'" '(2731 characters)'
if test -f 'sys/ultrix/spawn.c'
then
	echo shar: will not over-write existing file "'sys/ultrix/spawn.c'"
else
cat << \SHAR_EOF > 'sys/ultrix/spawn.c'
/*
 * Name:	MicroEMACS
 *		Spawn CLI; stop if C shell.
 * Version:	29
 * Last edit:	10-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 *
 * Spawn. New version, which
 * interracts with the job control stuff
 * in the 4.X BSD C shell.
 */
#include	"def.h"

#include	<sgtty.h>
#include	<signal.h>

char	*shellp	= NULL;			/* Saved "SHELL" name.		*/

extern	struct	sgttyb	oldtty;		/* There really should be a	*/
extern	struct	sgttyb	newtty;		/* nicer way of doing this, so	*/
extern	struct	sgttyb	oldtchars;	/* spawn does not need to know	*/
extern	struct	sgttyb	newtchars;	/* about the insides of the	*/
extern	struct	sgttyb	oldltchars;	/* terminal I/O code.		*/
extern	struct	sgttyb	newltchars;

extern	char	*getenv();

/*
 * This code does a one of 2 different
 * things, depending on what version of the shell
 * you are using. If you are using the C shell, which
 * implies that you are using job control, then MicroEMACS
 * moves the cursor to a nice place and sends itself a
 * stop signal. If you are using the Bourne shell it runs
 * a subshell using fork/exec. Bound to "C-C", and used
 * as a subcommand by "C-Z".
 */
spawncli(f, n, k)
{
	register int	pid;
	register int	wpid;
	register int	(*oqsig)();
	register int	(*oisig)();
	int		status;

	if (shellp == NULL) {
		shellp = getenv("SHELL");
		if (shellp == NULL)
			shellp = getenv("shell");
		if (shellp == NULL)
			shellp = "/bin/sh";	/* Safer.		*/
	}
	ttcolor(CTEXT);
	ttnowindow();
	if (strcmp(shellp, "/bin/csh") == 0) {
		if (epresf != FALSE) {
			ttmove(nrow-1, 0);
			tteeol();
			epresf = FALSE;
		}				/* Csh types a "\n"	*/
		ttmove(nrow-2, 0);		/* before "Stopped".	*/
	} else {
		ttmove(nrow-1, 0);
		if (epresf != FALSE) {
			tteeol();
			epresf = FALSE;
		}
	}
	ttflush();
	if (ioctl(0, TIOCSLTC, &oldltchars) < 0
	||  ioctl(0, TIOCSETC, &oldtchars)  < 0
	||  ioctl(0, TIOCSETP, &oldtty)     < 0) {
		eprintf("IOCTL #1 to terminal failed");
		return (FALSE);
	}
	if (strcmp(shellp, "/bin/csh") == 0)	/* C shell.		*/
		kill(0, SIGTSTP);
	else {					/* Bourne shell.	*/
		oqsig = signal(SIGQUIT, SIG_IGN);
		oisig = signal(SIGINT,  SIG_IGN);
		if ((pid=fork()) < 0) {
			signal(SIGQUIT, oqsig);
			signal(SIGINT,  oisig);
			eprintf("Failed to create process");
			return (FALSE);
		}
		if (pid == 0) {
			execl(shellp, "sh", "-i", NULL);
			_exit(0);		/* Should do better!	*/
		}
		while ((wpid=wait(&status))>=0 && wpid!=pid)
			;
		signal(SIGQUIT, oqsig);
		signal(SIGINT,  oisig);
	}
	sgarbf = TRUE;				/* Force repaint.	*/
	if (ioctl(0, TIOCSETP, &newtty)     < 0
	||  ioctl(0, TIOCSETC, &newtchars)  < 0
	||  ioctl(0, TIOCSLTC, &newltchars) < 0) {
		eprintf("IOCTL #2 to terminal failed");
		return (FALSE);
	}
	return (TRUE);
}
SHAR_EOF
if test 2731 -ne "`wc -c < 'sys/ultrix/spawn.c'`"
then
	echo shar: error transmitting "'sys/ultrix/spawn.c'" '(should have been 2731 characters)'
fi
fi
echo shar: extracting "'sys/ultrix/sysdef.h'" '(660 characters)'
if test -f 'sys/ultrix/sysdef.h'
then
	echo shar: will not over-write existing file "'sys/ultrix/sysdef.h'"
else
cat << \SHAR_EOF > 'sys/ultrix/sysdef.h'
/*
 * Name:	MicroEMACS
 *		Ultrix-32 system header file.
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#define	PCC	1			/* "[]" gets an error.		*/
#define	KBLOCK	8192			/* Kill grow.			*/
#define	GOOD	0			/* Good exit status.		*/

/*
 * Macros used by the buffer name making code.
 * Start at the end of the file name, scan to the left
 * until BDC1 (or BDC2, if defined) is reached. The buffer
 * name starts just to the right of that location, and
 * stops at end of string (or at the next BDC3 character,
 * if defined). BDC2 and BDC3 are mainly for VMS.
 */
#define	BDC1	'/'			/* Buffer names.		*/
SHAR_EOF
if test 660 -ne "`wc -c < 'sys/ultrix/sysdef.h'`"
then
	echo shar: error transmitting "'sys/ultrix/sysdef.h'" '(should have been 660 characters)'
fi
fi
echo shar: extracting "'sys/ultrix/ttyio.c'" '(3900 characters)'
if test -f 'sys/ultrix/ttyio.c'
then
	echo shar: will not over-write existing file "'sys/ultrix/ttyio.c'"
else
cat << \SHAR_EOF > 'sys/ultrix/ttyio.c'
/*
 * Name:	MicroEMACS
 *		Ultrix-32 terminal I/O.
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 *
 * The functions in this file
 * negotiate with the operating system for
 * keyboard characters, and write characters to
 * the display in a barely buffered fashion.
 */
#include	"def.h"

#include	<sgtty.h>

#define	NOBUF	512			/* Output buffer size.		*/

char	obuf[NOBUF];			/* Output buffer.		*/
int	nobuf;
struct	sgttyb	oldtty;			/* V6/V7 stty data.		*/
struct	sgttyb	newtty;
struct	tchars	oldtchars;		/* V7 editing.			*/
struct	tchars	newtchars;
struct	ltchars oldltchars;		/* 4.2 BSD editing.		*/
struct	ltchars	newltchars;
int	nrow;				/* Terminal size, rows.		*/
int	ncol;				/* Terminal size, columns.	*/

/*
 * This function gets called once, to set up
 * the terminal channel. On Ultrix is's tricky, since
 * we want flow control, but we don't want any characters
 * stolen to send signals. Use CBREAK mode, and set all
 * characters but start and stop to 0xFF.
 */
ttopen()
{
	register char	*cp;
	extern char	*getenv();

	if (ioctl(0, TIOCGETP, &oldtty) < 0)
		abort();
	newtty.sg_ospeed = oldtty.sg_ospeed;
	newtty.sg_ispeed = oldtty.sg_ispeed;
	newtty.sg_erase  = oldtty.sg_erase;
	newtty.sg_kill   = oldtty.sg_kill;
	newtty.sg_flags  = oldtty.sg_flags;
	newtty.sg_flags &= ~(ECHO|CRMOD);	/* Kill echo, CR=>NL.	*/
	newtty.sg_flags |= CBREAK;		/* Half-cooked mode.	*/
	if (ioctl(0, TIOCSETP, &newtty) < 0)
		abort();
	if (ioctl(0, TIOCGETC, &oldtchars) < 0)
		abort();
	newtchars.t_intrc  = 0xFF;		/* Interrupt.		*/
	newtchars.t_quitc  = 0xFF;		/* Quit.		*/
	newtchars.t_startc = 0x11;		/* ^Q, for terminal.	*/
	newtchars.t_stopc  = 0x13;		/* ^S, for terminal.	*/
	newtchars.t_eofc   = 0xFF;
	newtchars.t_brkc   = 0xFF;
	if (ioctl(0, TIOCSETC, &newtchars) < 0)
		abort();
	if (ioctl(0, TIOCGLTC, &oldltchars) < 0)
		abort();
	newltchars.t_suspc  = 0xFF;		/* Suspend #1.		*/
	newltchars.t_dsuspc = 0xFF;		/* Suspend #2.		*/
	newltchars.t_rprntc = 0xFF;
	newltchars.t_flushc = 0xFF;		/* Output flush.	*/
	newltchars.t_werasc = 0xFF;
	newltchars.t_lnextc = 0xFF;		/* Literal next.	*/
	if (ioctl(0, TIOCSLTC, &newltchars) < 0)
		abort();
	if ((cp=getenv("TERMCAP")) == NULL
	|| (nrow=getvalue(cp, "li")) <= 0
	|| (ncol=getvalue(cp, "co")) <= 0) {
		nrow = 24;
		ncol = 80;
	}
	if (nrow > NROW)			/* Don't crash if the	*/
		nrow = NROW;			/* termcap entry is	*/
	if (ncol > NCOL)			/* too big.		*/
		ncol = NCOL;
}

/*
 * This routine scans a string, which is
 * actually the return value of a getenv call for the TERMCAP
 * variable, looking for numeric parameter "name". Return the value
 * if found. Return -1 if not there. Assume that "name" is 2
 * characters long. This limited use of the TERMCAP lets us find
 * out the size of a window on the X display.
 */
getvalue(cp, name)
register char	*cp;
register char	*name;
{
	for (;;) {
		while (*cp!=0 && *cp!=':')
			++cp;
		if (*cp++ == 0)			/* Not found.		*/
			return (-1);
		if (cp[0]==name[0] && cp[1]==name[1] && cp[2]=='#')
			return (atoi(cp+3));	/* Stops on ":".	*/
	}
}

/*
 * This function gets called just
 * before we go back home to the shell. Put all of
 * the terminal parameters back.
 */
ttclose()
{
	ttflush();
	if (ioctl(0, TIOCSLTC, &oldltchars) < 0)
		abort();
	if (ioctl(0, TIOCSETC, &oldtchars) < 0)
		abort();
	if (ioctl(0, TIOCSETP, &oldtty) < 0)
		abort();
}

/*
 * Write character to the display.
 * Characters are buffered up, to make things
 * a little bit more efficient.
 */
ttputc(c)
{
	if (nobuf >= NOBUF)
		ttflush();
	obuf[nobuf++] = c;
}

/*
 * Flush output.
 */
ttflush()
{
	if (nobuf != 0) {
		write(1, obuf, nobuf);
		nobuf = 0;
	}
}

/*
 * Read character from terminal.
 * All 8 bits are returned, so that you can use
 * a multi-national terminal.
 */
ttgetc()
{
	char	buf[1];

	while (read(0, &buf[0], 1) != 1)
		;
	return (buf[0] & 0xFF);
}
SHAR_EOF
if test 3900 -ne "`wc -c < 'sys/ultrix/ttyio.c'`"
then
	echo shar: error transmitting "'sys/ultrix/ttyio.c'" '(should have been 3900 characters)'
fi
fi
echo shar: done with directory "'sys/ultrix'"
if test ! -d 'sys/vms'
then
	echo shar: creating directory "'sys/vms'"
	mkdir 'sys/vms'
fi
echo shar: extracting "'sys/vms/fileio.c'" '(3410 characters)'
if test -f 'sys/vms/fileio.c'
then
	echo shar: will not over-write existing file "'sys/vms/fileio.c'"
else
cat << \SHAR_EOF > 'sys/vms/fileio.c'
/*
 * Name:	MicroEMACS
 * Version:	29
 *		VAX/VMS file I/O.
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 *
 * Read and write ASCII files. All
 * of the low level file I/O knowledge is here.
 * VAX/VMS.
 * Pretty much vanilla standard I/O, using
 * the (traditional) funny open.
 */
#include	"def.h"

static	FILE	*ffp;

/*
 * Open a file for reading.
 */
ffropen(fn)
char	*fn;
{
	if ((ffp=fopen(fn, "r")) == NULL)
		return (FIOFNF);
	return (FIOSUC);
}

/*
 * Open a file for writing.
 * Return TRUE if all is well, and
 * FALSE on error (cannot create).
 */
ffwopen(fn)
char	*fn;
{
	register int	fd;

	if ((fd=creat(fn, 0, "rfm=var", "rat=cr")) < 0
	|| (ffp=fdopen(fd, "w")) == NULL) {
		eprintf("Cannot open file for writing");
		return (FIOERR);
	}
	return (FIOSUC);
}

/*
 * Close a file.
 * Should look at the status.
 */
ffclose()
{
	fclose(ffp);
	return (FIOSUC);
}

/*
 * Write a line to the already
 * opened file. The "buf" points to the
 * buffer, and the "nbuf" is its length, less
 * the free newline. Return the status.
 * Check only at the newline.
 */
ffputline(buf, nbuf)
register char	buf[];
{
	register int	i;

	for (i=0; i<nbuf; ++i)
		putc(buf[i]&0xFF, ffp);
	putc('\n', ffp);
	if (ferror(ffp) != FALSE) {
		eprintf("Write I/O error");
		return (FIOERR);
	}
	return (FIOSUC);
}

/*
 * Read a line from a file, and store the bytes
 * in the supplied buffer. Stop on end of file or end of
 * line. Don't get upset by files that don't have an end of
 * line on the last line; this seem to be common on CP/M-86 and
 * MS-DOS (the suspected culprit is VAX/VMS kermit, but this
 * has not been confirmed. If this is sufficiently researched
 * it may be possible to pull this kludge). Delete any CR
 * followed by an LF. This is mainly for runoff documents,
 * both on VMS and on Ultrix (they get copied over from
 * VMS systems with DECnet).
 */
ffgetline(buf, nbuf)
register char	buf[];
{
	register int	c;
	register int	i;

	i = 0;
	for (;;) {
		c = getc(ffp);
		if (c == '\r') {		/* Delete any non-stray	*/
			c = getc(ffp);		/* carriage returns.	*/
			if (c != '\n') {
				if (i >= nbuf-1) {
					eprintf("File has long line");
					return (FIOERR);
				}
				buf[i++] = '\r';
			}
		}
		if (c==EOF || c=='\n')		/* End of line.		*/
			break;
		if (i >= nbuf-1) {
			eprintf("File has long line");
			return (FIOERR);
		}
		buf[i++] = c;
	}
	if (c == EOF) {				/* End of file.		*/
		if (ferror(ffp) != FALSE) {
			eprintf("File read error");
			return (FIOERR);
		}
		if (i == 0)			/* Don't get upset if	*/
			return (FIOEOF);	/* no newline at EOF.	*/
	}
	buf[i] = 0;
	return (FIOSUC);
}

/*
 * VMS has version numbers, so there is
 * no need for MicroEMACS to bother making its own
 * flavour of backup copy. Return TRUE so the
 * caller doesn't quit.
 */
fbackupfile(fname)
char	*fname;
{
	return (TRUE);
}

/*
 * The string "fn" is a file name.
 * Perform any required case adjustments. All sustems
 * we deal with so far have case insensitive file systems.
 * We zap everything to lower case. The problem we are trying
 * to solve is getting 2 buffers holding the same file if
 * you visit one of them with the "caps lock" key down.
 * On UNIX file names are dual case, so we leave
 * everything alone.
 */
adjustcase(fn)
register char	*fn;
{
	register int	c;

	while ((c = *fn) != 0) {
		if (c>='A' && c<='Z')
			*fn = c + 'a' - 'A';
		++fn;
	}
}
SHAR_EOF
if test 3410 -ne "`wc -c < 'sys/vms/fileio.c'`"
then
	echo shar: error transmitting "'sys/vms/fileio.c'" '(should have been 3410 characters)'
fi
fi
echo shar: extracting "'sys/vms/spawn.c'" '(2289 characters)'
if test -f 'sys/vms/spawn.c'
then
	echo shar: will not over-write existing file "'sys/vms/spawn.c'"
else
cat << \SHAR_EOF > 'sys/vms/spawn.c'
/*
 * Name:	MicroEMACS
 *		VAX/VMS spawn a DCL subprocess.
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	"def.h"

#include	<ssdef.h>
#include	<stsdef.h>
#include	<descrip.h>
#include	<iodef.h>

#define	EFN	0				/* Event flag.		*/

extern	int	oldmode[3];			/* In "termio.c".	*/
extern	int	newmode[3];
extern	short	iochan;

/*
 * Create a subjob with a copy
 * of the command intrepreter in it. When the
 * command interpreter exits, mark the screen as
 * garbage so that you do a full repaint. Bound
 * to "C-C" and called from "C-Z". The message at
 * the start in VMS puts out a newline. Under
 * some (unknown) condition, you don't get one
 * free when DCL starts up.
 */
spawncli(f, n, k)
{
	ttcolor(CTEXT);				/* Normal color.	*/
	ttwindow(0, nrow-1);			/* Full screen scroll.	*/
	ttmove(nrow-1, 0);			/* Last line.		*/
	eputs("[Starting DCL]");
	ttputc('\r');
	ttputc('\n');
	ttflush();
	sgarbf = TRUE;
	return (sys(NULL));			/* NULL => DCL.		*/
}

/*
 * Run a command. The "cmd" is a pointer
 * to a command string, or NULL if you want to run
 * a copy of DCL in the subjob (this is how the standard
 * routine LIB$SPAWN works. You have to do wierd stuff
 * with the terminal on the way in and the way out,
 * because DCL does not want the channel to be
 * in raw mode.
 */
sys(cmd)
register char	*cmd;
{
	struct	dsc$descriptor	cdsc;
	struct	dsc$descriptor	*cdscp;
	long	status;
	long	substatus;
	long	iosb[2];

	status = SYS$QIOW(EFN, iochan, IO$_SETMODE, iosb, 0, 0,
			  oldmode, sizeof(oldmode), 0, 0, 0, 0);
	if (status!=SS$_NORMAL || (iosb[0]&0xFFFF)!=SS$_NORMAL)
		return (FALSE);
	cdscp = NULL;				/* Assume DCL.		*/
	if (cmd != NULL) {			/* Build descriptor.	*/
		cdsc.dsc$a_pointer = cmd;
		cdsc.dsc$w_length  = strlen(cmd);
		cdsc.dsc$b_dtype   = DSC$K_DTYPE_T;
		cdsc.dsc$b_class   = DSC$K_CLASS_S;
		cdscp = &cdsc;
	}
	status = LIB$SPAWN(cdscp, 0, 0, 0, 0, 0, &substatus, 0, 0, 0);
	if (status != SS$_NORMAL)
		substatus = status;
	status = SYS$QIOW(EFN, iochan, IO$_SETMODE, iosb, 0, 0,
			  newmode, sizeof(newmode), 0, 0, 0, 0);
	if (status!=SS$_NORMAL || (iosb[0]&0xFFFF)!=SS$_NORMAL)
		return (FALSE);
	if ((substatus&STS$M_SUCCESS) == 0)	/* Command failed.	*/
		return (FALSE);
	return (TRUE);
}
SHAR_EOF
if test 2289 -ne "`wc -c < 'sys/vms/spawn.c'`"
then
	echo shar: error transmitting "'sys/vms/spawn.c'" '(should have been 2289 characters)'
fi
fi
echo shar: extracting "'sys/vms/sysdef.h'" '(715 characters)'
if test -f 'sys/vms/sysdef.h'
then
	echo shar: will not over-write existing file "'sys/vms/sysdef.h'"
else
cat << \SHAR_EOF > 'sys/vms/sysdef.h'
/*
 * Name:	MicroEMACS
 *		VAX/VMS system header file.
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	<ssdef.h>

#define	PCC	0			/* "[]" works.			*/
#define	KBLOCK	8192			/* Kill grow.			*/
#define	GOOD	(SS$_NORMAL)		/* Good exit status.		*/

/*
 * Macros used by the buffer name making code.
 * Start at the end of the file name, scan to the left
 * until BDC1 (or BDC2, if defined) is reached. The buffer
 * name starts just to the right of that location, and
 * stops at end of string (or at the next BDC3 character,
 * if defined). BDC2 and BDC3 are mainly for VMS.
 */
#define	BDC1	':'			/* Buffer names.		*/
#define	BDC2	']'
#define	BDC3	';'
SHAR_EOF
if test 715 -ne "`wc -c < 'sys/vms/sysdef.h'`"
then
	echo shar: error transmitting "'sys/vms/sysdef.h'" '(should have been 715 characters)'
fi
fi
echo shar: extracting "'sys/vms/ttyio.c'" '(4573 characters)'
if test -f 'sys/vms/ttyio.c'
then
	echo shar: will not over-write existing file "'sys/vms/ttyio.c'"
else
cat << \SHAR_EOF > 'sys/vms/ttyio.c'
/*
 * Name:	MicroEMACS
 *		VAX/VMS terminal I/O.
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	"def.h"

#include	<stsdef.h>
#include	<ssdef.h>
#include	<descrip.h>
#include	<iodef.h>
#include	<ttdef.h>
#include	<tt2def.h>

#define	NIBUF	128			/* Probably excessive.		*/
#define	NOBUF	512			/* Not too big for 750/730.	*/
#define	EFN	0			/* Event flag			*/

char	obuf[NOBUF];			/* Output buffer		*/
int	nobuf;				/* # of bytes in above		*/
char	ibuf[NIBUF];			/* Input buffer			*/
int	nibuf;				/* # of bytes in above		*/
int	ibufi;				/* Read index			*/
int	oldmode[3];			/* Old TTY mode bits		*/
int	newmode[3];			/* New TTY mode bits		*/
short	iochan;				/* TTY I/O channel		*/
int	nrow;				/* Terminal size, rows.		*/
int	ncol;				/* Terminal size, columns.	*/

/*
 * This routines gets called once, to set up the
 * terminal channel.
 * On VMS we find the translation of the SYS$COMMAND: logical name,
 * assign a channel to it, and set it raw. Let VMS handle the flow
 * control.
 */
ttopen()
{
	struct	dsc$descriptor	idsc;
	struct	dsc$descriptor	odsc;
	char	oname[40];
	int	iosb[2];
	int	status;

	odsc.dsc$a_pointer = "SYS$COMMAND";
	odsc.dsc$w_length  = strlen(odsc.dsc$a_pointer);
	odsc.dsc$b_dtype   = DSC$K_DTYPE_T;
	odsc.dsc$b_class   = DSC$K_CLASS_S;
	idsc.dsc$b_dtype   = DSC$K_DTYPE_T;
	idsc.dsc$b_class   = DSC$K_CLASS_S;
	do {
		idsc.dsc$a_pointer = odsc.dsc$a_pointer;
		idsc.dsc$w_length  = odsc.dsc$w_length;
		odsc.dsc$a_pointer = &oname[0];
		odsc.dsc$w_length  = sizeof(oname);
		status = LIB$SYS_TRNLOG(&idsc, &odsc.dsc$w_length, &odsc);
		if (status!=SS$_NORMAL && status!=SS$_NOTRAN)
			exit(status);
		if (oname[0] == 0x1B) {
			odsc.dsc$a_pointer += 4;
			odsc.dsc$w_length  -= 4;
		}
	} while (status == SS$_NORMAL);
	status = SYS$ASSIGN(&odsc, &iochan, 0, 0);
	if (status != SS$_NORMAL)
		exit(status);
	status = SYS$QIOW(EFN, iochan, IO$_SENSEMODE, iosb, 0, 0,
			  oldmode, sizeof(oldmode), 0, 0, 0, 0);
	if (status!=SS$_NORMAL || (iosb[0]&0xFFFF)!=SS$_NORMAL)
		exit(status);
	nrow = (oldmode[1]>>24) & 0xFF;		/* Length.		*/
	if (nrow > NROW)
		nrow = NROW;
	ncol = (oldmode[0]>>16) & 0xFFFF;	/* Width.		*/
	if (ncol > NCOL)
		ncol = NCOL;
	newmode[0] = oldmode[0];		/* Only in version 4.	*/
	newmode[1] = oldmode[1] | TT$M_NOECHO | TT$M_TTSYNC;
	newmode[2] = oldmode[2] | TT2$M_PASTHRU;
	status = SYS$QIOW(EFN, iochan, IO$_SETMODE, iosb, 0, 0,
			  newmode, sizeof(newmode), 0, 0, 0, 0);
	if (status!=SS$_NORMAL || (iosb[0]&0xFFFF)!=SS$_NORMAL)
		exit(status);
}

/*
 * This function gets called just
 * before we go back home to the command interpreter.
 * On VMS it puts the terminal back in a reasonable state.
 */
ttclose()
{
	int	status;
	int	iosb[1];

	ttflush();
	status = SYS$QIOW(EFN, iochan, IO$_SETMODE, iosb, 0, 0,
	         oldmode, sizeof(oldmode), 0, 0, 0, 0);
	if (status!=SS$_NORMAL || (iosb[0]&0xFFFF)!=SS$_NORMAL)
		exit(status);
	status = SYS$DASSGN(iochan);
	if (status != SS$_NORMAL)
		exit(status);
}

/*
 * Write a character to the display.
 * On VMS, terminal output is buffered, and
 * we just put the characters in the big array,
 * after cheching for overflow.
 */
ttputc(c)
{
	if (nobuf >= NOBUF)
		ttflush();
	obuf[nobuf++] = c;
}

/*
 * This function does the real work of
 * flushing out buffered I/O on VMS. All
 * we do is blast out the block with a write call. No status
 * checking is done on the write, because there isn't anything
 * clever that can be done, and because you will see the
 * error as a messed up screen.
 */
ttflush()
{
	int	iosb[2];

	if (nobuf != 0) {
		SYS$QIOW(EFN, iochan, IO$_WRITELBLK|IO$M_NOFORMAT,
		iosb, 0, 0, obuf, nobuf, 0, 0, 0, 0);
		nobuf = 0;
	}
}

/*
 * Read a character from the terminal,
 * performing no editing and doing no echo at all.
 * More complex in VMS that almost anyplace else, which
 * figures.
 */
ttgetc()
{
	int	status;
	int	iosb[2];
	int	term[2];

	term[0] = 0;
	term[1] = 0;
	while (ibufi >= nibuf) {
		ibufi   = 0;
		status = SYS$QIOW(EFN, iochan, IO$_READLBLK|IO$M_TIMED,
			 iosb, 0, 0, ibuf, NIBUF, 0, term, 0, 0);
		if (status != SS$_NORMAL)
			continue;
		status = iosb[0] & 0xFFFF;
		if (status!=SS$_NORMAL && status!=SS$_TIMEOUT)
			continue;
		nibuf = (iosb[0]>>16) + (iosb[1]>>16);
		if (nibuf == 0) {
			status = SYS$QIOW(EFN, iochan, IO$_READLBLK,
				iosb, 0, 0, ibuf, 1, 0, term, 0, 0);
			if (status != SS$_NORMAL)
				continue;
			if ((iosb[0]&0xFFFF) != SS$_NORMAL)
				continue;
			nibuf = (iosb[0]>>16) + (iosb[1]>>16);
		}
	}
	return (ibuf[ibufi++] & 0xFF);
}
SHAR_EOF
if test 4573 -ne "`wc -c < 'sys/vms/ttyio.c'`"
then
	echo shar: error transmitting "'sys/vms/ttyio.c'" '(should have been 4573 characters)'
fi
fi
echo shar: extracting "'sys/vms/uemacs.mms'" '(2633 characters)'
if test -f 'sys/vms/uemacs.mms'
then
	echo shar: will not over-write existing file "'sys/vms/uemacs.mms'"
else
cat << \SHAR_EOF > 'sys/vms/uemacs.mms'
! MICROEMACS BUILD FILE.
! VAX/VMS.
! IS THERE A BETTER WAY TO DEAL WITH THE COMMAND FILES,
! GIVEN THAT YOU CANNOT SAY "-I" ON THE COMMAND LINE OF THE
! CC COMMAND?

SYS	=	[.SYS.VMS]
TTY	=	[.TTY.ANSI]

.FIRST
	COPY $(SYS)SYSDEF.H []SYSDEF.H
	COPY $(TTY)TTYDEF.H []TTYDEF.H

.LAST
	DEL []SYSDEF.H;*
	DEL []TTYDEF.H;*

! LINK.

UEMACS.EXE :	BASIC.OBJ	BUFFER.OBJ	CINFO.OBJ	DISPLAY.OBJ -
		ECHO.OBJ	EXTEND.OBJ	FILE.OBJ	KBD.OBJ -
		LINE.OBJ	MAIN.OBJ	RANDOM.OBJ	REGION.OBJ -
		SEARCH.OBJ	SYMBOL.OBJ	VERSION.OBJ	WINDOW.OBJ -
		WORD.OBJ	FILEIO.OBJ	TTYIO.OBJ	SPAWN.OBJ -
		TTY.OBJ		TTYKBD.OBJ
	LINK/EXE=UEMACS.EXE/NOMAP -
		BASIC.OBJ,	BUFFER.OBJ,	CINFO.OBJ,	DISPLAY.OBJ, -
		ECHO.OBJ,	EXTEND.OBJ,	FILE.OBJ,	KBD.OBJ, -
		LINE.OBJ,	MAIN.OBJ,	RANDOM.OBJ,	REGION.OBJ, -
		SEARCH.OBJ,	SYMBOL.OBJ,	VERSION.OBJ,	WINDOW.OBJ, -
		WORD.OBJ,	FILEIO.OBJ,	TTYIO.OBJ,	SPAWN.OBJ, -
		TTY.OBJ,	TTYKBD.OBJ,	SYS$LIBRARY:VAXCRTL.OLB/LIB
	PURGE/LOG

! COMMON.

BASIC.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H BASIC.C

BUFFER.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H BUFFER.C

CINFO.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H CINFO.C

DISPLAY.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H DISPLAY.C

ECHO.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H ECHO.C

EXTEND.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H EXTEND.C

FILE.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H FILE.C

KBD.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H KBD.C

LINE.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H LINE.C

MAIN.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H MAIN.C

RANDOM.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H RANDOM.C

REGION.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H REGION.C

SEARCH.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H SEARCH.C

SYMBOL.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H SYMBOL.C

VERSION.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H VERSION.C

WINDOW.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H WINDOW.C

WORD.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H WORD.C

! SYSTEM.

FILEIO.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H $(SYS)FILEIO.C
	COPY $(SYS)FILEIO.C []FILEIO.C
	CC/OBJECT=FILEIO.OBJ FILEIO.C
	DELETE FILEIO.C;*

TTYIO.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H $(SYS)TTYIO.C
	COPY $(SYS)TTYIO.C []TTYIO.C
	CC/OBJECT=TTYIO.OBJ TTYIO.C
	DELETE TTYIO.C;*

SPAWN.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H $(SYS)SPAWN.C
	COPY $(SYS)SPAWN.C []SPAWN.C
	CC/OBJECT=SPAWN.OBJ SPAWN.C
	DELETE SPAWN.C;*

! TERMINAL.

TTY.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H $(TTY)TTY.C
	COPY $(TTY)TTY.C []TTY.C
	CC/OBJECT=TTY.OBJ TTY.C
	DELETE TTY.C;*

TTYKBD.OBJ :	DEF.H $(SYS)SYSDEF.H $(TTY)TTYDEF.H $(TTY)TTYKBD.C
	COPY $(TTY)TTYKBD.C []TTYKBD.C
	CC/OBJECT=TTYKBD.OBJ TTYKBD.C
	DELETE TTYKBD.C;*
SHAR_EOF
if test 2633 -ne "`wc -c < 'sys/vms/uemacs.mms'`"
then
	echo shar: error transmitting "'sys/vms/uemacs.mms'" '(should have been 2633 characters)'
fi
fi
echo shar: done with directory "'sys/vms'"
if test ! -d 'sys/msdos'
then
	echo shar: creating directory "'sys/msdos'"
	mkdir 'sys/msdos'
fi
echo shar: extracting "'sys/msdos/fileio.c'" '(3264 characters)'
if test -f 'sys/msdos/fileio.c'
then
	echo shar: will not over-write existing file "'sys/msdos/fileio.c'"
else
cat << \SHAR_EOF > 'sys/msdos/fileio.c'
/*
 * Name:	MicroEMACS
 *		MS-DOS file I/O.
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	"def.h"

static	FILE	*ffp;

/*
 * Open a file for reading.
 */
ffropen(fn)
char	*fn;
{
	if ((ffp=fopen(fn, "r")) == NULL)
		return (FIOFNF);
	return (FIOSUC);
}

/*
 * Open a file for writing.
 * Return TRUE if all is well, and
 * FALSE on error (cannot create).
 */
ffwopen(fn)
char	*fn;
{
	if ((ffp=fopen(fn, "w")) == NULL) {
		eprintf("Cannot open file for writing");
		return (FIOERR);
	}
	return (FIOSUC);
}

/*
 * Close a file.
 * Should look at the status.
 */
ffclose()
{
	fclose(ffp);
	return (FIOSUC);
}

/*
 * Write a line to the already
 * opened file. The "buf" points to the
 * buffer, and the "nbuf" is its length, less
 * the free newline. Return the status.
 * Check only at the newline.
 */
ffputline(buf, nbuf)
register char	buf[];
{
	register int	i;

	for (i=0; i<nbuf; ++i)
		putc(buf[i]&0xFF, ffp);
	putc('\n', ffp);
	if (ferror(ffp) != FALSE) {
		eprintf("Write I/O error");
		return (FIOERR);
	}
	return (FIOSUC);
}

/*
 * Read a line from a file, and store the bytes
 * in the supplied buffer. Stop on end of file or end of
 * line. Don't get upset by files that don't have an end of
 * line on the last line; this seem to be common on CP/M-86 and
 * MS-DOS (the suspected culprit is VAX/VMS kermit, but this
 * has not been confirmed. If this is sufficiently researched
 * it may be possible to pull this kludge). Delete any CR
 * followed by an LF. This is mainly for runoff documents,
 * both on VMS and on Ultrix (they get copied over from
 * VMS systems with DECnet).
 */
ffgetline(buf, nbuf)
register char	buf[];
{
	register int	c;
	register int	i;

	i = 0;
	for (;;) {
		c = getc(ffp);
		if (c == '\r') {		/* Delete any non-stray	*/
			c = getc(ffp);		/* carriage returns.	*/
			if (c != '\n') {
				if (i >= nbuf-1) {
					eprintf("File has long line");
					return (FIOERR);
				}
				buf[i++] = '\r';
			}
		}
		if (c==EOF || c=='\n')		/* End of line.		*/
			break;
		if (i >= nbuf-1) {
			eprintf("File has long line");
			return (FIOERR);
		}
		buf[i++] = c;
	}
	if (c == EOF) {				/* End of file.		*/
		if (ferror(ffp) != FALSE) {
			eprintf("File read error");
			return (FIOERR);
		}
		if (i == 0)			/* Don't get upset if	*/
			return (FIOEOF);	/* no newline at EOF.	*/
	}
	buf[i] = 0;
	return (FIOSUC);
}

/*
 * Some backup user on MS-DOS might want
 * to determine some rule for doing backups on that
 * system, and fix this. I don't use MS-DOS, so I don't
 * know what the right rules would be. Return TRUE so
 * the caller does not abort a write.
 */
fbackupfile(fname)
char	*fname;
{
	return (TRUE);				/* Hack.		*/
}

/*
 * The string "fn" is a file name.
 * Perform any required case adjustments. All sustems
 * we deal with so far have case insensitive file systems.
 * We zap everything to lower case. The problem we are trying
 * to solve is getting 2 buffers holding the same file if
 * you visit one of them with the "caps lock" key down.
 * On UNIX file names are dual case, so we leave
 * everything alone.
 */
adjustcase(fn)
register char	*fn;
{
	register int	c;

	while ((c = *fn) != 0) {
		if (c>='A' && c<='Z')
			*fn = c + 'a' - 'A';
		++fn;
	}
}
SHAR_EOF
if test 3264 -ne "`wc -c < 'sys/msdos/fileio.c'`"
then
	echo shar: error transmitting "'sys/msdos/fileio.c'" '(should have been 3264 characters)'
fi
fi
echo shar: extracting "'sys/msdos/putline.asm'" '(1946 characters)'
if test -f 'sys/msdos/putline.asm'
then
	echo shar: will not over-write existing file "'sys/msdos/putline.asm'"
else
cat << \SHAR_EOF > 'sys/msdos/putline.asm'
; High speed screen update for Rainbow.
; putline(row, col, buf);
; Row and column are origin 1.
; The buf is a pointer to an array of characters.
; It won't write past the end of the line in
; the video RAM; it looks for the FF at the end
; of the line.
; This routine by Bob McNamara.
; put into large model .ASM format by Rich Ellison

putline_code	segment byte	public	'code'
extrn	tthue_:word
	public	putline_
	assume	cs:putline_code,ds:nothing,es:nothing,ss:nothing

ScrSeg  equ	0ee00h
ScrPtr	equ	3
CMODE	equ	2

putline_	proc	far	; putline(Row, Col, Buf)	/* fast video */
Row	equ	10		; int	Row;			/*   row addr */
Col	equ	12		; int	Col;			/*   col addr */
Buf	equ	14		; char	*Buf;			/*   data     */
				; {
	push	si
	push	di
	push	bp
	mov	bp,sp
	push	ds
	push	es
	mov	ax,ScrSeg		;point extra segment into screen RAM
	mov	es,ax
	mov	di,es:ScrPtr+1		;di <- base line address
	and	di,0fffh
	mov	al,0ffh
	cld

	mov	dx,[bp+Row]		;row number to write (dx)
	lds	si,dword ptr[bp+Buf]	;string to be moved ds:(si)
	mov	bx,[bp+Col]		;column number to start at (bx)
	dec	bx			;column number starts at 1
	dec	dx			;row number starts at 1
	jz	l2
l1:	mov	cx,140
	repnz scasb
	mov	di,es:[di]		;pointer to next line (di)
	and	di,0fffh
	dec	dx
	jnz	l1
l2:	add	di,bx			;di -> offset in row
	push	di

l3:	cmp	al,es:[di]
	jz	l4
	movsb
	cmp	al,es:[di]
	jz	l4
	movsb
	cmp	al,es:[di]
	jz	l4
	movsb
	cmp	al,es:[di]
	jz	l4
	movsb
	cmp	al,es:[di]
	jz	l4
	movsb
	cmp	al,es:[di]
	jz	l4
	movsb
	cmp	al,es:[di]
	jz	l4
	movsb
	cmp	al,es:[di]
	jz	l4
	movsb
	jmp	l3
l4:
	pop	cx
	mov	ax,cx
	sub	di,cx
	mov	cx,di			;cx contains repeat count
	add	ax,1000h		;point into attribute portion of RAM
	mov	di,ax			;di contains pointer into attr. RAM
	mov	ax,0fh			;assume rev. video
	cmp	word ptr tthue_,CMODE	;is this for mode line?
	jz	l5			;yes
	mov	ax,0eh			;no, clear attributes
l5:
	rep stosb

	pop	es
	pop	ds
	pop	bp
	pop	di
	pop	si
	ret
putline_	endp

	putline_code	ends
	end
SHAR_EOF
if test 1946 -ne "`wc -c < 'sys/msdos/putline.asm'`"
then
	echo shar: error transmitting "'sys/msdos/putline.asm'" '(should have been 1946 characters)'
fi
fi
echo shar: extracting "'sys/msdos/putline.s'" '(1221 characters)'
if test -f 'sys/msdos/putline.s'
then
	echo shar: will not over-write existing file "'sys/msdos/putline.s'"
else
cat << \SHAR_EOF > 'sys/msdos/putline.s'
/ High speed screen update for Rainbow.
/ MWC-86 has this in CP/M-86 but not in MS-DOS.
/ putline(row, col, buf);
/ Row and column are origin 1.
/ The buf is a pointer to an array of characters.
/ It won't write past the end of the line in
/ the video RAM; it looks for the FF at the end
/ of the line.
/ This routine by Bob McNamara.

	.globl	putline_

Scr_Seg = 0xEE00
ScrPtr	= 3

putline_:
	push	si
	push	di
	push	es
	mov	ax,$Scr_Seg	/point our extra segment into screen RAM
	mov	es,ax
	mov	di,es:ScrPtr+1	/di <- base line address
	and	di,$0x0fff
	movb	al,$0xff
	cld

	mov	bx,sp
	mov	dx,8(bx)	/dx = row number to write
	mov	si,12(bx)	/si = string to be moved
	mov	bx,10(bx)	/bx = column number to start at
	dec	bx		/column number starts at 1
	dec	dx		/row number starts at 1 too
	jz	2f
1:
	mov	cx,$140
	repnz scasb
	mov	di,es:(di)	/di = pointer to next line
	and	di,$0x0fff
	dec	dx
	jnz	1b
2:	
	add	di,bx		/di -> offset in row
3:
	cmpb	al,es:(di)
	jz	4f
	movsb
	cmpb	al,es:(di)
	jz	4f
	movsb
	cmpb	al,es:(di)
	jz	4f
	movsb
	cmpb	al,es:(di)
	jz	4f
	movsb
	cmpb	al,es:(di)
	jz	4f
	movsb
	cmpb	al,es:(di)
	jz	4f
	movsb
	cmpb	al,es:(di)
	jz	4f
	movsb
	cmpb	al,es:(di)
	jz	4f
	movsb
	jmp	3b
4:
	pop	es
	pop	di
	pop	si
	ret
SHAR_EOF
if test 1221 -ne "`wc -c < 'sys/msdos/putline.s'`"
then
	echo shar: error transmitting "'sys/msdos/putline.s'" '(should have been 1221 characters)'
fi
fi
echo shar: extracting "'sys/msdos/spawn.c'" '(1603 characters)'
if test -f 'sys/msdos/spawn.c'
then
	echo shar: will not over-write existing file "'sys/msdos/spawn.c'"
else
cat << \SHAR_EOF > 'sys/msdos/spawn.c'
/*
 * Name:	MicroEMACS
 *		MS-DOS spawn command.com
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	"def.h"

#include	<dos.h>

#if	!LARGE
char	*cspec	= NULL;				/* Command string.	*/
#endif

/*
 * Create a subjob with a copy
 * of the command intrepreter in it. When the
 * command interpreter exits, mark the screen as
 * garbage so that you do a full repaint. Bound
 * to "C-C" and called from "C-Z".
 */
spawncli(f, n, k)
{
#if	LARGE
	eprintf("Not in large model MS-DOS");
	return (FALSE);
#else
	ttcolor(CTEXT);				/* Normal color.	*/
	ttwindow(0, nrow-1);			/* Full screen scroll.	*/
	ttmove(nrow-1, 0);			/* Last line.		*/
	ttflush();
	if (cspec == NULL) {			/* Try to find it.	*/
		cspec = getenv("COMSPEC");
		if (cspec == NULL)
			cspec = "A:COMMAND.COM";
	}
	sys(cspec, "");				/* Run CLI.		*/
	sgarbf = TRUE;
	return(TRUE);
#endif
}

#if	!LARGE
/*
 * This routine, once again
 * by Bob McNamara, is a C translation
 * of the "system" routine in the MWC-86 run
 * time library. It differs from the "system" routine
 * in that it does not unconditionally append the
 * string ".exe" to the end of the command name.
 * We needed to do this because we want to be
 * able to spawn off "command.com". We really do
 * not understand what it does, but if you don't
 * do it exactly "malloc" starts doing very
 * very strange things.
 */
sys(cmd, tail)
char	*cmd;
char	*tail;
{
	register unsigned n;
	extern   char	  *__end;

	n = __end + 15;
	n >>= 4;
	n = ((n + dsreg() + 16) & 0xFFF0) + 16;
	return(execall(cmd, tail, n));
}
#endif
SHAR_EOF
if test 1603 -ne "`wc -c < 'sys/msdos/spawn.c'`"
then
	echo shar: error transmitting "'sys/msdos/spawn.c'" '(should have been 1603 characters)'
fi
fi
echo shar: extracting "'sys/msdos/sysdef.h'" '(609 characters)'
if test -f 'sys/msdos/sysdef.h'
then
	echo shar: will not over-write existing file "'sys/msdos/sysdef.h'"
else
cat << \SHAR_EOF > 'sys/msdos/sysdef.h'
/*
 * Name:	MicroEMACS
 *		MS-DOS system header file.
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#define	LARGE	0			/* Large model.			*/
#define	PCC	0			/* "[]" will work.		*/

/*
 * Macros used by the buffer name making code.
 * Start at the end of the file name, scan to the left
 * until BDC1 (or BDC2, if defined) is reached. The buffer
 * name starts just to the right of that location, and
 * stops at end of string (or at the next BDC3 character,
 * if defined). BDC2 and BDC3 are mainly for VMS.
 */
#define	BDC1	':'			/* Buffer names.		*/
SHAR_EOF
if test 609 -ne "`wc -c < 'sys/msdos/sysdef.h'`"
then
	echo shar: error transmitting "'sys/msdos/sysdef.h'" '(should have been 609 characters)'
fi
fi
echo shar: extracting "'sys/msdos/ttyio.c'" '(607 characters)'
if test -f 'sys/msdos/ttyio.c'
then
	echo shar: will not over-write existing file "'sys/msdos/ttyio.c'"
else
cat << \SHAR_EOF > 'sys/msdos/ttyio.c'
/*
 * Name:	MicroEMACS
 *		MS-DOS terminal I/O.
 * Version:	29
 * Last edit:	05-Feb-86
 * By:		rex::conroy
 *		decvax!decwrl!dec-rhea!dec-rex!conroy
 */
#include	"def.h"

#include	<dos.h>

int	nrow;				/* Terminal size, rows.		*/
int	ncol;				/* Terminal size, columns.	*/

/*
 * Initialization.
 * Almost no operation in MS-DOS.
 */
ttopen()
{
	nrow = NROW;
	ncol = NCOL;
}

/*
 * No operation in MS-DOS.
 */
ttclose()
{
}

/*
 * Write character.
 */
ttputc(c)
{
	dosb(CONDIO, c, 0);
}

/*
 * No operation in MS-DOS.
 */
ttflush()
{
}

/*
 * Read character.
 */
ttgetc()
{
	return (dosb(CONRAW,  0, 0));
}
SHAR_EOF
if test 607 -ne "`wc -c < 'sys/msdos/ttyio.c'`"
then
	echo shar: error transmitting "'sys/msdos/ttyio.c'" '(should have been 607 characters)'
fi
fi
echo shar: done with directory "'sys/msdos'"
echo shar: done with directory "'sys'"
exit 0
#	End of shell archive
