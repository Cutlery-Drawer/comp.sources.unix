From: genrad!linus!utzoo!bnr-vpa!bruce (Bruce Townsend)
Subject: compile/decompile nroff driver tables (USG only)
Newsgroups: mod.sources
Approved: jpn@panda.UUCP

Mod.sources:  Volume 4, Issue 48
Submitted by: utzoo!bnr-vpa!bruce (Bruce Townsend)

	This program is intended for USG systems only, since
Berkelely has a different driver table format, and I understand
that many (all?) Berkeley systems have the necessary tools
supplied.
	My submission includes a program for building tables
from a source, a man page (term.5) explaining the source, a
program that does the inverse operation of building a source
from existing binary tables (useful for modifying existing
tables) and various bits of documentation.
	The program is not guaranteed to be portable to all
USG systems, as I did not have access to any other than my own,
but it does run on at least two other machines, and it should
not be too much work to port to any USG machine.


Following is the shar archive of the source.

			Thanks,
			-Bruce Townsend
Mail path: {utzoo, utcs}!bnr-vpa!bruce

:----------------------CUT HERE--------------------------
#!/bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #!/bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	Makefile
#	README
#	charlist
#	elbat.c
#	tabXXX.c
#	table.c
#	table.doc
#	term.5
#	term.h
# This archive created: Mon Jul 29 15:48:02 1985
export PATH; PATH=/bin:$PATH
echo shar: extracting "'Makefile'" '(748 characters)'
if test -f 'Makefile'
then
	echo shar: over-writing existing file "'Makefile'"
fi
sed 's/^X//' << \SHAR_EOF > 'Makefile'
X#	Makefile for table.c, method of producing a single terminal
X#	table for nroff under USG UNIX.
X#	Makefile written by Bruce Townsend (utcs!bnr-vpa!bruce)
X#	and Ian Darwin (utcs!darwin!ian)
X#	March 6, 1985.
X
XTABFILES = tabXXX
XDESTDIR = /usr/lib/term
XLINTTAB = tabXXX
XDEFS =
XCFLAGS = $(DEFS) -O
XLDFLAGS = -s
XLFLAGS = $(DEFS)
X
X$(TABFILES): dummy_file
X	$(MAKE) -$(MAKEFLAGS) table.o $@.o
X	cc $(LDFLAGS) table.o $@.o
X	./a.out $@
X
X# This dummy_file should never exist, it is a kludge to get Make to
X# always execute cc.
Xdummy_file:
X	@rm -f dummy_file
X
Xall:	$(TABFILES)
X
Xinstall: $(TABFILES)
X	mv $(TABFILES) $(DESTDIR)
X
Xlint:	table.c
X	lint $(LFLAGS) table.c $(LINTTAB).c
X
Xelbat:	elbat.o
X	cc $(LDFLAGS) elbat.o -o elbat
X
Xclean:
X	rm -f a.out tab*.o elbat.o
SHAR_EOF
if test 748 -ne "`wc -c 'Makefile'`"
then
	echo shar: error transmitting "'Makefile'" '(should have been 748 characters)'
fi
echo shar: extracting "'README'" '(1970 characters)'
if test -f 'README'
then
	echo shar: over-writing existing file "'README'"
fi
sed 's/^X//' << \SHAR_EOF > 'README'
X	There are two programs in this package. "table", written by
XBruce Townsend with help from Ian Darwin, prepares an nroff driver
Xtable from a source file. "elbat", written by Matt Crawford and
Xmodified for USG UNIX by Bruce Townsend, is the inverse operation -
Xit decompiles an nroff driver table, producing a source file.
X
X	The Makefile should not need modification other than to
Xadd new names of terminal drivers, of the form "tabXXX" where
X"XXX" is a mnemonic for a terminal, e.g. tab450 for a Diablo 450
Xin 10-pitch mode. These names are added to the TABFILES definition
Xin the Makefile. The format for Berkeley tab files is different
Xand thus this package will not work on Berkely systems without
Xsubstantial hacking.
X
X	You may want to change CFLAGS, LDFLAGS, etc. to your taste
Xor de-bugging preference.
X
X	To compile the elbat program, type "make elbat".
XTo de-compile a file, type "elbat /usr/lib/term/tabXXX > tabXXX.c"
X
X	To compile a tabXXX file (say tab450), type "make tab450".
XOf course, you need the tab450.c source before you do this.
XDo NOT FORGET to include the tabXXX name in the TABFILES definition
Xin the Makefile first.
X
X	Be VERY CAREFULL with "make install" (try "make -n install
Xfirst).
X
X	Read the table.doc file and the term.5 man page for more info.
XI have updated the term.5 man page to reflect this program.
X
XIF YOU HAVE PROBLEMS...
X	It is quite possible that some or all of the integers stored
Xin the tabfile are long, not int. On our machine, long = int = 32 bits,
Xso I do not know which is appropriate. Read the table.doc file for
Xmore info.
X
XAcknowledgements:
X	Ian Darwin tested out the first (very buggy) version of
Xthis utility, and suggested many useful changes, including the
Xintroduction of the Makefile.
X
X	Matt Crawford wrote the elbat program originally for
XBerkeley systems.
X			-Bruce Townsend
X
X			Voice Processing Applications,
X			Bell-Northern Research,
X			Ottawa, Ontario.
X
XMail path: {utzoo, utcs, bnr-di, bnr-mtl}!bnr-vpa!bruce
SHAR_EOF
if test 1970 -ne "`wc -c 'README'`"
then
	echo shar: error transmitting "'README'" '(should have been 1970 characters)'
fi
echo shar: extracting "'charlist'" '(2694 characters)'
if test -f 'charlist'
then
	echo shar: over-writing existing file "'charlist'"
fi
sed 's/^X//' << \SHAR_EOF > 'charlist'
XTABLE OF NROFF CHARACTER INPUT NAMES
XIN THE ORDER THEY APPEAR IN THE codetab[] TABLE
X(see term(5))
X_______________
XName    Number
X        (Octal)
X_______________
X<sp>    000
X!       001
X"       002
X#       003
X$       004
X%       005
X&       006
X'       007
X(       010
X)       011
X*       012
X+       013
X,       014
X-       015
X.       016
X/       017
X0       020
X1       021
X2       022
X3       023
X4       024
X5       025
X6       026
X7       027
X8       030
X9       031
X:       032
X;       033
X<       034
X=       035
X>       036
X?       037
X@       040
XA       041
XB       042
XC       043
XD       044
XE       045
XF       046
XG       047
XH       050
XI       051
XJ       052
XK       053
XL       054
XM       055
XN       056
XO       057
XP       060
XQ       061
XR       062
XS       063
XT       064
XU       065
XV       066
XW       067
XX       070
XY       071
XZ       072
X[       073
X\       074
X]       075
X^       076
X_       077
X`       100
Xa       101
Xb       102
Xc       103
Xd       104
Xe       105
Xf       106
Xg       107
Xh       110
Xi       111
Xj       112
Xk       113
Xl       114
Xm       115
Xn       116
Xo       117
Xp       120
Xq       121
Xr       122
Xs       123
Xt       124
Xu       125
Xv       126
Xw       127
Xx       130
Xy       131
Xz       132
X{       133
X|       134
X}       135
X~       136
X\|      137
X\(hy    140
X\(bu    141
X\(sq    142
X\(em    143
X\(ru    144
X\(14    145
X\(12    146
X\(34    147
X\-      150
X\(fi    151
X\(fl    152
X\(ff    153
X\(Fi    154
X\(Fl    155
X\(de    156
X\(dg    157
X\(sc    160
X\(fm    161
X\(aa    162
X\(ga    163
X\(ul    164
X\(sl    165
X\^      166
X\<sp>   167
X\(*a    170
X\(*b    171
X\(*g    172
X\(*d    173
X\(*e    174
X\(*z    175
X\(*y    176
X\(*h    177
X\(*i    200
X\(*k    201
X\(*l    202
X\(*m    203
X\(*n    204
X\(*c    205
X\(*o    206
X\(*p    207
X\(*r    210
X\(*s    211
X\(*t    212
X\(*u    213
X\(*f    214
X\(*x    215
X\(*q    216
X\(*w    217
X\(*G    220
X\(*D    221
X\(*H    222
X\(*L    223
X\(*C    224
X\(*P    225
X\(*S    226
X\(*T    227
X\(*U    230
X\(*F    231
X\(*Q    232
X\(*W    233
X\(sr    234
X\(ts    235
X\(rn    236
X\(>=    237
X\(<=    240
X\(==    241
X\(mi    242
X\(~=    243
X\(ap    244
X\(!=    245
X\(->    246
X\(<-    247
X\(ua    250
X\(da    251
X\(eq    252
X\(mu    253
X\(di    254
X\(+-    255
X\(cu    256
X\(ca    257
X\(sb    260
X\(sp    261
X\(ib    262
X\(ip    263
X\(if    264
X\(pd    265
X\(gr    266
X\(no    267
X\(is    270
X\(pt    271
X\(es    272
X\(mo    273
X\(pl    274
X\(rg    275
X\(co    276
X\(br    277
X\(ct    300
X\(dd    301
X\(rh    302
X\(lh    303
X\(**    304
X\(bs    305
X\(or    306
X\(ci    307
X\(lt    310
X\(lb    311
X\(rt    312
X\(rb    313
X\(lk    314
X\(rk    315
X\(bv    316
X\(lf    317
X\(rf    320
X\(lc    321
X\(rc    322
SHAR_EOF
if test 2694 -ne "`wc -c 'charlist'`"
then
	echo shar: error transmitting "'charlist'" '(should have been 2694 characters)'
fi
echo shar: extracting "'elbat.c'" '(5459 characters)'
if test -f 'elbat.c'
then
	echo shar: over-writing existing file "'elbat.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'elbat.c'
X/* elbat:  a program to de-compile nroff drive tables so they can
X**         be fiddled with.
X**
X** usage:  elbat tabXXX > tabXXX.c
X**
X** Matt Crawford, University of Chicago, 10 May 1984
X** ihnp4!oddjob!matt	       crawford@anl-mcs.arpa
X**
X** Modified by: Bruce Townsend, Bell Northern-Research, March 6 1985
X**       - Changed for USG UNIX systems.
X**
X*/
X
X#include <stdio.h>
X#include <ctype.h>
X#include <fcntl.h>
X#include "term.h"
X
Xvoid	loadtab(), vprint();
Xchar	*codelabel[] = {
X	"space",	"!",	"\"",	"#",	"$",	"%",	"&",
X	"' close",	"(",	")",	"*",	"+",	",",	"- hyphen",
X	".",	"/",	"0",	"1",	"2",	"3",	"4",	"5",
X	"6",	"7",	"8",	"9",	":",	";",	"<",	"=",
X	">",	"?",	"@",	"A",	"B",	"C",	"D",	"E",
X	"F",	"G",	"H",	"I",	"J",	"K",	"L",	"M",
X	"N",	"O",	"P",	"Q",	"R",	"S",	"T",	"U",
X	"V",	"W",	"X",	"Y",	"Z",	"[",	"\\",	"]",
X	"^",	"_ dash",	"` open",	"a",	"b",	"c",
X	"d",	"e",	"f",	"g",	"h",	"i",	"j",	"k",
X	"l",	"m",	"n",	"o",	"p",	"q",	"r",	"s",
X	"t",	"u",	"v",	"w",	"x",	"y",	"z",	"{",
X	"|",	"}",	"~",	"narrow sp",	"hyphen",	"bullet",
X	"square",	"3/4 em",	"rule",	"1/4",	"1/2",	"3/4",
X	"minus",	"fi",	"fl",	"ff",	"ffi",	"ffl",	"degree",
X	"dagger",	"section",	"foot mark",	"acute accent",
X	"grave accent",	"underrule",	"slash (longer)",
X	"half narrow space",	"unpaddable space",	"alpha",
X	"beta",	"gamma",	"delta",	"epsilon",	"zeta",
X	"eta",	"theta",	"iota",	"kappa",	"lambda",
X	"mu",	"nu",	"xi",	"omicron",	"pi",	"rho",	"sigma",
X	"tau",	"upsilon",	"phi",	"chi",	"psi",	"omega",
X	"Gamma",	"Delta",	"Theta",	"Lambda",
X	"Xi",	"Pi",	"Sigma",	"Tau",	"Upsilon",	"Phi",
X	"Psi",	"Omega",	"square root",	"terminal sigma",
X	"root en",	">=",	"<=",	"identically equal",
X	"equation minus",	"approx =",	"approximates",
X	"not equal",	"right arrow",	"left arrow",	"up arrow",
X	"down arrow",	"eqn equals",	"multiply",	"divide",
X	"plus-minus",	"cup (union)",	"cap (intersection)",	"subset of",
X	"superset of",	"improper subset",	" improper superset",
X	"infinity",	"pt deriv",	"gradient",	"not",	"integral",
X	"proportional to",	"empty set",	"member of",
X	"equation plus",	"registration mk",	"copyright mk",
X	"box rule",	"cent sign",	"dbl dagger",	"right hand",
X	"left hand",	"math * ",	"bell system sign",
X	"or (was star)",	"circle",	"left top of big curly",
X	"left bottom of big curly",	"right top of big curly",
X	"right bottom of big curly",	"left center of big curly",
X	"right center of big curly",	"bold vertical rule",
X	"left bottom of big bracket",	"right bottom of big bracket",
X	"left top of big bracket",	"right top of big bracket",
X	"???",	"???",	"???",	"???",	"???",	"???",	"???",	"???",
X	"???",	"???",	"???",	"???",	"???",	/* No idea what these are */
X};
X
Xstruct t t;
Xstruct t_stor t_stor;
X
Xmain(argc, argv)
Xchar	**argv;
X{
X	register int	c;
X	register char	**endptr = &t.zzz;
X	register FILE	*twfp;
X	char		labelbuf[64];
X
X	if (argc != 2) {
X		fprintf (stderr, "Usage: elbat tabXXX > tabXXX.c\n");
X		exit(1);
X		}
X
X	loadtab(argv[1]);
X	if ( (twfp = fopen("term.h", "r")) == NULL ) {
X		perror("term.h");
X		exit(1);
X	}
X	
X	while ( (c = getc(twfp)) != EOF && c != /*{*/ '}')
X		putc(c, stdout);
X	fclose(twfp);
X	printf(/*{*/ "} t = {\n" /*}*/);	/* Stupid emacs! */
X	printf("/*bset    */\t\t0%o,\n", t.bset);
X	printf("/*breset  */\t\t0%o,\n", t.breset);
X#define intshow(memb) \
X		printf("/*%-8s*/\t\t%d,\n", "memb", t.memb)
X	intshow(Hor);
X	intshow(Vert);
X	intshow(Newline);
X	intshow(Char);
X	intshow(Em);
X	intshow(Halfline);
X	intshow(Adj);
X#define show(memb) \
X		printf("/*%-8s*/\t\t\"", "memb");\
X		vprint(t.memb);\
X		printf("\",\n")
X	show(twinit);
X	show(twrest);
X	show(twnl);
X	show(hlr);
X	show(hlf);
X	show(flr);
X	show(bdon);
X	show(bdoff);
X	show(iton);
X	show(itoff);
X	show(ploton);
X	show(plotoff);
X	show(up);
X	show(down);
X	show(right);
X	show(left);
X	while ( **--endptr == '\0' )
X		;
X	for ( c = 0; c < 256-32		/* Not all 256-32 chars are in use */
X		&& &t.codetab[c] <= endptr; c++ ) {
X		sprintf(labelbuf, "/* %s */", codelabel[c]);
X		printf("%-20s\t\"", labelbuf);
X		if ( t.codetab[c][0] )
X			vprint(t.codetab[c]);
X		else if ( t.codetab[c][1] ) {
X			printf("\\000");
X			vprint(t.codetab[c]+1);
X			}
X		else
X			printf("\\000\\0");
X		printf("\",\n");
X	}
X	printf(/*{*/ "};\n");
X	exit(0);
X}
X
Xvoid
Xvprint(str)
Xregister char	*str;
X{
X	while ( str && *str ) {
X		char	c[5];
X
X		if ( isascii(*str) && isprint(*str)
X				&& *str != '\\' && *str != '"' ) {
X			c[0] = *str;
X			c[1] = '\0';
X		} else
X			switch ( *str ) {
X			case '\\':
X			case '"':
X				c[0] = '\\';
X				c[1] = *str;
X				c[2] = '\0';
X			        break;
X			case '\b':
X			        strcpy(c, "\\b");
X			        break;
X			case '\t':
X			        strcpy(c, "\\t");
X			        break;
X			case '\n':
X			        strcpy(c, "\\n");
X			        break;
X			case '\r':
X			        strcpy(c, "\\r");
X			        break;
X			default:
X				sprintf(c, "\\%03.3o", (int)*str & 0377);
X			        break;
X			}
X		fputs(c, stdout);
X		str++;
X	}
X}
X
Xvoid
Xloadtab( tname )
Xchar	*tname;
X{
X	register int	tfd;
X	int		c_size, *ip;
X	register char	**pp, *mptr;
X	extern char	*malloc();
X
X	if( (tfd=open(tname, O_RDONLY)) < 0 ) {
X		perror( tname );
X		exit(1);
X	}
X	read(tfd, &c_size, sizeof(int));
X	read(tfd, &t_stor, sizeof(t_stor));
X	mptr = malloc (c_size);
X	read(tfd, mptr, c_size);
X	t.bset = t_stor.bset;
X	t.breset = t_stor.breset;
X	t.Hor = t_stor.Hor;
X	t.Vert = t_stor.Vert;
X	t.Newline = t_stor.Newline;
X	t.Char = t_stor.Char;
X	t.Em = t_stor.Em;
X	t.Halfline = t_stor.Halfline;
X	t.Adj = t_stor.Adj;
X	ip = &t_stor.twinit;
X	for ( pp = &t.twinit; pp < &t.zzz;) *pp++ = mptr + *ip++;
X}
SHAR_EOF
if test 5459 -ne "`wc -c 'elbat.c'`"
then
	echo shar: error transmitting "'elbat.c'" '(should have been 5459 characters)'
fi
echo shar: extracting "'tabXXX.c'" '(8319 characters)'
if test -f 'tabXXX.c'
then
	echo shar: over-writing existing file "'tabXXX.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'tabXXX.c'
X/* This is an example of a source file for an nroff driver table.
X * It is a very stripped down version of a Diablo 450 in 10 pitch.
X * The integer settings (bset - Adj) are correct for this terminal
X * but only ascii charcters and some simple special charcters are
X * included. Therefore, it is not intended as a source for a useful
X * driver table, but rather as a starting point so that you can
X * hack up your own.
X */
X
X#include	<termio.h>	/* Req'd only for bset, breset */
X
X#define INCH 240
X
Xstruct {
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X	int Em;
X	int Halfline;
X	int Adj;
X	char *twinit;
X	char *twrest;
X	char *twnl;
X	char *hlr;
X	char *hlf;
X	char *flr;
X	char *bdon;
X	char *bdoff;
X	char *iton;
X	char *itoff;
X	char *ploton;
X	char *plotoff;
X	char *up;
X	char *down;
X	char *right;
X	char *left;
X	char *codetab[256-32];
X	char *zzz;
X	} t = {
X/*bset    */		0,
X/*breset  */		ONLCR | OCRNL | ONLRET,
X/*Hor     */		INCH / 60,
X/*Vert    */		INCH / 48,
X/*Newline */		INCH / 6,
X/*Char    */		INCH / 10,
X/*Em      */		INCH / 10,
X/*Halfline*/		INCH / 12,
X/*Adj     */		INCH / 10,
X/*twinit  */		"",
X/*twrest  */		"",
X/*twnl    */		"",
X/*hlr     */		"",
X/*hlf     */		"",
X/*flr     */		"",
X/*bdon    */		"",
X/*bdoff   */		"",
X/*iton    */		"",
X/*itoff   */		"",
X/*ploton  */		"",
X/*plotoff */		"",
X/*up      */		"",
X/*down    */		"",
X/*right   */		"",
X/*left    */		"",
X/* space */         	"\001 ",
X/* ! */             	"\001!",
X/* " */             	"\001\"",
X/* # */             	"\001#",
X/* $ */             	"\001$",
X/* % */             	"\001%",
X/* & */             	"\001&",
X/* ' close */       	"\001'",
X/* ( */             	"\001(",
X/* ) */             	"\001)",
X/* * */             	"\001*",
X/* + */             	"\001+",
X/* , */             	"\001,",
X/* - hyphen */      	"\001-",
X/* . */             	"\001.",
X/* / */             	"\001/",
X/* 0 */             	"\2010",
X/* 1 */             	"\2011",
X/* 2 */             	"\2012",
X/* 3 */             	"\2013",
X/* 4 */             	"\2014",
X/* 5 */             	"\2015",
X/* 6 */             	"\2016",
X/* 7 */             	"\2017",
X/* 8 */             	"\2018",
X/* 9 */             	"\2019",
X/* : */             	"\001:",
X/* ; */             	"\001;",
X/* < */             	"\001<",
X/* = */             	"\001=",
X/* > */             	"\001>",
X/* ? */             	"\001?",
X/* @ */             	"\001@",
X/* A */             	"\201A",
X/* B */             	"\201B",
X/* C */             	"\201C",
X/* D */             	"\201D",
X/* E */             	"\201E",
X/* F */             	"\201F",
X/* G */             	"\201G",
X/* H */             	"\201H",
X/* I */             	"\201I",
X/* J */             	"\201J",
X/* K */             	"\201K",
X/* L */             	"\201L",
X/* M */             	"\201M",
X/* N */             	"\201N",
X/* O */             	"\201O",
X/* P */             	"\201P",
X/* Q */             	"\201Q",
X/* R */             	"\201R",
X/* S */             	"\201S",
X/* T */             	"\201T",
X/* U */             	"\201U",
X/* V */             	"\201V",
X/* W */             	"\201W",
X/* X */             	"\201X",
X/* Y */             	"\201Y",
X/* Z */             	"\201Z",
X/* [ */             	"\001[",
X/* \ */             	"\001\\",
X/* ] */             	"\001]",
X/* ^ */             	"\001^",
X/* _ dash */        	"\001_",
X/* ` open */        	"\001`",
X/* a */             	"\201a",
X/* b */             	"\201b",
X/* c */             	"\201c",
X/* d */             	"\201d",
X/* e */             	"\201e",
X/* f */             	"\201f",
X/* g */             	"\201g",
X/* h */             	"\201h",
X/* i */             	"\201i",
X/* j */             	"\201j",
X/* k */             	"\201k",
X/* l */             	"\201l",
X/* m */             	"\201m",
X/* n */             	"\201n",
X/* o */             	"\201o",
X/* p */             	"\201p",
X/* q */             	"\201q",
X/* r */             	"\201r",
X/* s */             	"\201s",
X/* t */             	"\201t",
X/* u */             	"\201u",
X/* v */             	"\201v",
X/* w */             	"\201w",
X/* x */             	"\201x",
X/* y */             	"\201y",
X/* z */             	"\201z",
X/* { */             	"\001{",
X/* | */             	"\001|",
X/* } */             	"\001}",
X/* ~ */             	"\001~",
X/* narrow sp */     	"\000\0",
X/* hyphen */        	"\001-",
X/* bullet */        	"\000\0",
X/* square */        	"\000\0",
X/* 3/4 em */        	"\001-",
X/* rule */          	"\001_",
X/* 1/4 */           	"\0031/4",
X/* 1/2 */           	"\0031/2",
X/* 3/4 */           	"\0033/4",
X/* minus */         	"\001-",
X/* fi */            	"\202fi",
X/* fl */            	"\202fl",
X/* ff */            	"\202ff",
X/* ffi */           	"\203ffi",
X/* ffl */           	"\203ffl",
X/* degree */        	"\000\0",
X/* dagger */        	"\000\0",
X/* section */       	"\000\0",
X/* foot mark */     	"\000\0",
X/* acute accent */  	"\000\0",
X/* grave accent */  	"\000\0",
X/* underrule */     	"\001_",
X/* slash (longer) */	"\001/",
X/* half narrow space */	"\000\0",
X/* unpaddable space */	"\001 ",
X/* alpha */         	"\000\0",
X/* beta */          	"\000\0",
X/* gamma */         	"\000\0",
X/* epsilon */       	"\000\0",
X/* zeta */          	"\000\0",
X/* eta */           	"\000\0",
X/* theta */         	"\000\0",
X/* iota */          	"\000\0",
X/* kappa */         	"\000\0",
X/* lambda */        	"\000\0",
X/* mu */            	"\000\0",
X/* nu */            	"\000\0",
X/* xi */            	"\000\0",
X/* omicron */       	"\000\0",
X/* pi */            	"\000\0",
X/* rho */           	"\000\0",
X/* sigma */         	"\000\0",
X/* tau */           	"\000\0",
X/* upsilon */       	"\000\0",
X/* phi */           	"\000\0",
X/* chi */           	"\000\0",
X/* psi */           	"\000\0",
X/* omega */         	"\000\0",
X/* Gamma */         	"\000\0",
X/* Delta */         	"\000\0",
X/* Theta */         	"\000\0",
X/* Lambda */        	"\000\0",
X/* Xi */            	"\000\0",
X/* Pi */            	"\000\0",
X/* Sigma */         	"\000\0",
X/* Tau */           	"\000\0",
X/* Upsilon */       	"\000\0",
X/* Phi */           	"\000\0",
X/* Psi */           	"\000\0",
X/* Omega */         	"\000\0",
X/* square root */   	"\000\0",
X/* terminal sigma */	"\000\0",
X/* root en */       	"\000\0",
X/* >= */            	"\000\0",
X/* <= */            	"\000\0",
X/* identically equal */	"\000\0",
X/* equation minus */	"\000\0",
X/* approx = */      	"\000\0",
X/* approximates */  	"\000\0",
X/* not equal */     	"\000\0",
X/* right arrow */   	"\000\0",
X/* left arrow */    	"\000\0",
X/* up arrow */      	"\000\0",
X/* down arrow */    	"\000\0",
X/* eqn equals */    	"\000\0",
X/* multiply */      	"\000\0",
X/* divide */        	"\000\0",
X/* plus-minus */    	"\000\0",
X/* cup (union) */   	"\000\0",
X/* cap (intersection) */	"\000\0",
X/* subset of */     	"\000\0",
X/* superset of */   	"\000\0",
X/* improper subset */	"\000\0",
X/*  improper superset */	"\000\0",
X/* infinity */      	"\000\0",
X/* pt deriv */      	"\000\0",
X/* gradient */      	"\000\0",
X/* not */           	"\000\0",
X/* integral */      	"\000\0",
X/* proportional to */	"\000\0",
X/* empty set */     	"\000\0",
X/* member of */     	"\000\0",
X/* equation plus */ 	"\001+",
X/* registration mk */	"\000\0",
X/* copyright mk */  	"\000\0",
X/* box rule */      	"\001|",
X/* cent sign */     	"\000\0",
X/* dbl dagger */    	"\000\0",
X/* right hand */    	"\000\0",
X/* left hand */     	"\000\0",
X/* math *  */       	"\001*",
X/* bell system sign */	"\000\0",
X/* or (was star) */ 	"\001|",
X/* circle */        	"\000\0",
X/* left top of big curly */	"\001|",
X/* left bottom of big curly */	"\001|",
X/* right top of big curly */	"\001|",
X/* right bottom of big curly */	"\001|",
X/* left center of big curly */	"\001|",
X/* right center of big curly */	"\001|",
X/* bold vertical rule */	"\001|",
X/* left bottom of big bracket */	"\001|",
X/* right bottom of big bracket */	"\001|",
X/* left top of big bracket */	"\001|",
X/* right top of big bracket */	"\001|",
X/* ??? */           	"\000\0",
X/* ??? */           	"\000\0",
X/* ??? */           	"\000\0",
X/* ??? */           	"\000\0",
X/* ??? */           	"\000\0",
X/* ??? */           	"\000\0",
X/* ??? */           	"\000\0",
X/* ??? */           	"\000\0",
X/* ??? */           	"\000\0",
X/* ??? */           	"\000\0",
X/* ??? */           	"\000\0",
X/* ??? */           	"\000\0",
X/* ??? */           	"\000\0",
X};
SHAR_EOF
if test 8319 -ne "`wc -c 'tabXXX.c'`"
then
	echo shar: error transmitting "'tabXXX.c'" '(should have been 8319 characters)'
fi
echo shar: extracting "'table.c'" '(7221 characters)'
if test -f 'table.c'
then
	echo shar: over-writing existing file "'table.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'table.c'
X/*
X *
X *     TABLE - A PROGRAM TO PREPARE NROFF DRIVER TABLES
X *     copyright (c) 1985 by Bruce Townsend and Bell-Northern Research.
X *     Permission hereby granted to use, distribute, modify, or copy
X *     except for profit, providing this disclaimer is included.
X *
X *     The contributions of Ian Darwin (the Makefile, cleaning up the
X *     code, etc) are gratefully acknowledged.
X *
X *     Version 1.2 -
X *        * The program has been substantially modified from version 1.1
X *          The major bug in version 1.1 was that zero-width characters
X *          were not handled properly. This has been fixed.
X *
X *     Please send bug reports to Bruce Townsend (utcs!bnr-vpa!bruce)
X *
X *     Usage:
X *           1) Build a file tabXXX.c, where XXX is some reasonable
X *              acronym for the terminal or printer you want to drive
X *              (peruse existing names to see what's reasonable!).
X *              Make this file by hacking up one of the existing
X *              table entries.
X *           2) If the amount of char data that the structure
X *              references is very large, you may want to redefine
X *              C_SIZE
X *           3) check to see whether <sgtty.h> or <termio.h> should
X *              be #included in the tabXXX.c file. One of these include
X *              files may be necessary to provide settings for t.bset,
X *              t.breset. This is instead of the previous tendency to code
X *              octal magic numbers in these fields.
X *           4) Enter your new table into the Makefile; just add the
X *              name "tabXXX" to the TABFILES definition.
X *           5) Type "make tabXXX" where tabXXX is the same name
X *              you chose before.
X *           6) Locate the tabfile in the proper place (on our system
X *              the directory is /usr/lib/term
X *
X *
X */
X
X#define C_SIZE	10000	/* The maximum amount of character data allowed
X			   in the initialized structure t - increase if
X			   necessary */
X
X#include <stdio.h>
X#include "term.h"	/* This file contains the definition of the
X			   the structures t and t_stor */
X
X/************* DO NOT ALTER ANYTHING AFTER THIS POINT ***************/
X
Xextern struct t t;
Xstruct t_stor t_stor;
X
Xchar	c_data[C_SIZE];
Xchar	*c_pointer[256];
Xint	c_length[256];
Xchar	*c_end = c_data;
Xint	n_strings, c_size;
X
Xmain (argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	FILE	*table;
X	int	i, j, i_len, j_len;
X	char	*tail, *start, *char_pointer, *strcpy();
X
X	if (argc != 2) {	/* Need a file name argument */
X	    fprintf (stderr, "Usage: table \"file\"\n");
X	    exit (1);
X	    }
X
X	/* Open the file */
X	if ((table = fopen (argv[1], "w")) == NULL) {
X	    fprintf (stderr, "File %s not opened for writing\n", argv[1]);
X	    exit (1);
X	    }
X
X	/* Copy the integer values from the initialized structure
X	   to the storage structure */
X	t_stor.bset = t.bset;
X	t_stor.breset = t.breset;
X	t_stor.Hor = t.Hor;
X	t_stor.Vert = t.Vert;
X	t_stor.Newline = t.Newline;
X	t_stor.Char = t.Char;
X	t_stor.Em = t.Em;
X	t_stor.Halfline = t.Halfline;
X	t_stor.Adj = t.Adj;
X
X	/* Add the character strings into a character array */
X	addstring (t.twinit);
X	addstring (t.twrest);
X	addstring (t.twnl);
X	addstring (t.hlr);
X	addstring (t.hlf);
X	addstring (t.flr);
X	addstring (t.bdon);
X	addstring (t.bdoff);
X	addstring (t.iton);
X	addstring (t.itoff);
X	addstring (t.ploton);
X	addstring (t.plotoff);
X	addstring (t.up);
X	addstring (t.down);
X	addstring (t.right);
X	addstring (t.left);
X	for (i = 0; i < 256 - 32; i++) addchar (t.codetab[i]);
X
X	/* eliminate strings which are tails of other strings */
X	for (i = 0; i < n_strings; i++) {
X	    if (! c_pointer[i]) continue;	/* String cleared out */
X	    i_len = c_length[i];
X	    for (j = 0; j < n_strings; j++) {
X		if (i == j || ! c_pointer[j]) continue;
X		j_len = c_length[j];
X		if (i_len <= j_len) {	/* string i could be tail of string j */
X		    tail = c_pointer[j] + j_len - i_len;
X		    if (! char_comp (c_pointer[i], tail, i_len)) {
X			c_pointer[i] = 0;
X			break;
X			}
X		    }
X		}
X	    }
X
X	/* Compress the c_data array */
X	char_pointer = c_data;
X	for (i = j = 0; i < n_strings; i++) {
X	    if (! (start = c_pointer[i])) continue;
X	    c_pointer[j] = char_pointer;
X	    c_length[j++] = c_length[i];
X	    for (i_len = c_length[i]; i_len--;) *char_pointer++ = *start++;
X	    *char_pointer++ = 0;
X	    }
X	n_strings = j;
X	c_size = char_pointer - c_data;
X
X	/* Now find each string in this table and provide an index to it */
X	t_stor.twinit = findstring (t.twinit);
X	t_stor.twrest = findstring (t.twrest);
X	t_stor.twnl = findstring (t.twnl);
X	t_stor.hlr = findstring (t.hlr);
X	t_stor.hlf = findstring (t.hlf);
X	t_stor.flr = findstring (t.flr);
X	t_stor.bdon = findstring (t.bdon);
X	t_stor.bdoff = findstring (t.bdoff);
X	t_stor.iton = findstring (t.iton);
X	t_stor.itoff = findstring (t.itoff);
X	t_stor.ploton = findstring (t.ploton);
X	t_stor.plotoff = findstring (t.plotoff);
X	t_stor.up = findstring (t.up);
X	t_stor.down = findstring (t.down);
X	t_stor.right = findstring (t.right);
X	t_stor.left = findstring (t.left);
X	for (i = 0; i < 256 - 32; i++) {
X	    t_stor.codetab[i] = findchar (t.codetab[i]);
X	    }
X	t_stor.zzz = 0;
X
X	/* Write the character storage block size */
X	if (fwrite (&c_size, sizeof (c_size), 1, table) != 1)
X	    write_err ();
X
X	if (fwrite (&t_stor, sizeof (t_stor), 1, table) != 1)
X	    write_err ();
X
X	if (fwrite (c_data, sizeof (*c_data), c_size, table) != c_size)
X	    write_err ();
X
X	if (fclose (table)) {
X	    fprintf (stderr, "File %s not closed properly\n", argv[1]);
X	    exit (1);
X	    }
X	}
X
Xaddstring (string)
Xchar	*string;
X{
X	c_pointer[n_strings] = c_end;
X	c_end += (c_length[n_strings] = strlen (string)) + 1;
X	if (c_end >= c_data + C_SIZE) {
X	    fprintf (stderr, "Table size too small, increase it!\n");
X	    exit(1);
X	    }
X	strcpy (c_pointer[n_strings++], string);
X}
X
Xaddchar (string)
Xchar	*string;
X{
X	c_pointer[n_strings] = c_end;
X	c_end += (c_length[n_strings] = strlen (string + 2) + 2) + 1;
X	if (c_end >= c_data + C_SIZE) {
X	    fprintf (stderr, "Table size too small, increase it!\n");
X	    exit(1);
X	    }
X	*c_pointer[n_strings] = *string++;	/* Copy in first two bytes */
X	*(c_pointer[n_strings]+1) = *string++;
X	strcpy (c_pointer[n_strings++] + 2, string); /* Copy the rest */
X}
X
Xchar_comp (str1, str2, len)
Xchar	*str1, *str2;
Xint	len;
X{
X	while (len--) {
X	    if (*str1++ != *str2++) return (1);
X	    }
X	return (0);
X	}
X
Xfindstring (string)
Xchar	*string;
X{
X	int	c_len, s_len, i;
X
X	for (i = 0; i < n_strings; i++) {
X	    if ((c_len = c_length[i]) >= (s_len = strlen (string))) {
X		if (!char_comp (string, c_pointer[i] + c_len - s_len, s_len))
X		    return (c_pointer[i] + c_len - s_len - c_data);
X		}
X	    }
X	fprintf (stderr, "Serious bug! string not found in table\n");
X	exit(1);
X	/* NOTREACHED */
X	}
X
Xfindchar (string)
Xchar	*string;
X{
X	int	c_len, s_len, i;
X
X	for (i = 0; i < n_strings; i++) {
X	    if ((c_len = c_length[i]) >= (s_len = strlen (string+2) + 2)) {
X		if (!char_comp (string, c_pointer[i] + c_len - s_len, s_len))
X		    return (c_pointer[i] + c_len - s_len - c_data);
X		}
X	    }
X	fprintf (stderr, "Serious bug! character not found in table\n");
X	exit(1);
X	/* NOTREACHED */
X	}
X
Xwrite_err () {
X	fprintf (stderr, "Write to file failed\n");
X	exit (1);
X	}
SHAR_EOF
if test 7221 -ne "`wc -c 'table.c'`"
then
	echo shar: error transmitting "'table.c'" '(should have been 7221 characters)'
fi
echo shar: extracting "'table.doc'" '(6854 characters)'
if test -f 'table.doc'
then
	echo shar: over-writing existing file "'table.doc'"
fi
sed 's/^X//' << \SHAR_EOF > 'table.doc'
XDOCUMENTATION OF NROFF TAB FILE UTILITY
X-Bruce Townsend, Bell-Northern Research, March 1985
X (utcs!bnr-vpa!bruce)
X
X	This file contains some documentation for the table program.
XThis program makes printer and terminal driver tables suitable for
Xnroff. The development of this program was motivated by the lack of
Xany other means to prepare custom nroff driver tables, for those
Xsystems which do not have the original source that prepared the driver
Xtables (usually found in /usr/lib/term).
X	The format for the tables imbodied in this program was deduced
Xfrom a "term" manual page, and by examining the contents of several
Xexisting tab files. Therefore, this program is not definitive in
Xany sense, but is intended as a help for those who (like myself) do
Xnot have access to any formal tools that make these tab files.
X	Also it is possible that this program will require modification
Xfor systems where the size of an integer is not 32 bits. The system
Xthat this program was developed on is an HP9000 (System III) and the
Xdata sizes are:
X		long	32
X		int	32
X		short	16
X		char	 8
XAs I have not had access to different machines, I do not know whether
Xcertain data in the tab file is of int or long type, since that type
Xis the same on our machine. I have assumed int type.
X
XIf your luck is really bad, I suppose it is possible that the format
Xof the tab file is different across various implementations.
X
XThe format of the tab file is:
XType	Name		Size on HP9000		Description
X----	----		--------------		-----------
Xint	c_size		4 bytes	- The amount of character data in bytes
X				that follows the t_stor structure. In fact
X				the size of the file in bytes should be:
X				c_size + sizeof (c_size) + sizeof (t_stor)
X				(On our machine: c_size + 1004)
X
Xstruct {		1000 bytes - This is the storage for the "t"
X	int bset;		structure with one change. All the elements
X	int breset;		of the t structure which were pointers to
X	int Hor;		strings are now integer indexes to one
X	int Vert;		large character array.
X	int Newline;
X	int Char;
X	int Em;
X	int Halfline;
X	int Adj;
X	int twinit;
X	int twrest;
X	int twnl;
X	int hlr;
X	int hlf;
X	int flr;
X	int bdon;
X	int bdoff;
X	int iton;
X	int itoff;
X	int ploton;
X	int plotoff;
X	int up;
X	int down;
X	int right;
X	int left;
X	int codetab[256-32];
X	int zzz;
X} t_stor;
X
Xchar	array[c_size]	(variable size)- This is the storage for the strings
X					pointed to by the indexes.
X
X		How to Use the Table Program
X		----------------------------
XExamine the "term" manual page which explains the purpose of each of
Xthe items in the "t" structure. Make a copy of the tabXXX.c program
Xand edit it, replacing XXX with a suitable mnemonic. Initialize the
Xt structure to the integer or character string values that are necessary
Xfor the terminal or printer in question. You have a high degree of
Xflexibility here, and variable-width characters, overstrike combinations,
Xetc are easy to implement.
X
XThe only catch here is determining which index of the t.codetab[] array
Xcorresponds to which nroff printable character. This information is not
Xin the manual page. After some experimentation, I have made a table
Xwhich list the characters I know about. The table has some holes in it,
Xbut is as complete as I can make it. If anyone has additions or
Xcorrections, please let me know. The table is found in the file
Xcharlist. Also, the comments in tabXXX.c should help.
X
XWARNING: ALL CHARACTER STRINGS IN THE codetab[] array MUST be at
Xleast two characters in size, not counting the null terminator.
XThe typical definition for a zero-width string which prints nothing
Xis "\000\0" and NOT "". THIS IS VERY IMPORTANT, because it is
Xnecessary to allow the first byte of these strings to be zero
Xin the case of zero-width strings that do print something.
XE.G. the string "\000^\b" is a zero-width "hat" character.
X
XIf the amount of char data is very large, you may need to increase the
Xdefinition of C_SIZE in table.c. It is now set at 10000 characters.
XThe table.c program will burp out a message to this effect if
Xnecessary.
X
XThe t.bset and t.breset flags will need definitions from either
X<termio.h> or <sgtty.h>. Include whichever is appropriate for your
Xsystem in tabXXX.c.
X
XAfter the tabXXX.c file has been edited, place it in the same
Xdirectory as table.c and the Makefile, and compile the table with:
X	make tabXXX
X
XThis will compile and run a program which will in turn make the
Xtab file. Move the tabfile to its destination directory (likely
X/usr/term/tab).
X
XRun nroff as:
X	nroff -TXXX ...
X(for example):
X	nroff -T630P ...
X
XDebugging is not easy.
XYou can use the supplied program which takes a tab file (tabXXX) and
Xmakes a source file (tabXXX.c). The program is called elbat (reverse
Xof table) Do this by:
X	elbat tabXXX > tabXXX.c
Xand compare to your original tabXXX.c
X	Do this for tab files that you have already to check that
Xthe format is the same on your system as on mine.
X
X
X		The Table Program
X		-----------------
X
XAs mentioned before, this program is not to be considered a
Xdefinitive one. It works for HP9000's as far as I can tell.
X
XHowever, it does have the feature of compressing the supplied
Xcharacter data as much as possible. If one string is the tail of
Xanother (e.g. the strings abcdef and def), than only the largest
Xstring is stored. The smaller is indexed into the middle of the
Xlarger. Repeated strings (including the null string) are only stored
Xonce.
X
XIt should generate a tabfile very close to the size of the distributed
Xtables. Check by using elbat on a distributed table, compile using
Xthe table utility, and compare the sizes. The character data will
Xalmost certainly be stored in a different order than in the
Xdistributed table, so "cmp -l" will find most bytes different.
XHowever, the nroff results using the two files should be identical.
X
XThe program has not been extensively tested. There may be bugs or
Xmisinformation. Let me know of any problems.
X
XIf the tab files produced by this program do not work at all on your
Xsystem, then it may be that the data types for c_size, and
Xt_stor.whatever are incorrect. (Long instead of int?) You can get an
Xindication by looking at the first word (int or long?) of an
Xexisting tab file. This is the amount of char data stored in the
Xfile. Subtract it from the size of the file in bytes. The result
Xwill be the size of the t_stor structure plus the size of the c_size
Xvariable. The t_stor structure has 250 elements in it. If each is
X4 bytes, as on our system, and the c_size variable is 4 bytes also,
Xthen the result of the previous subtraction should be 1004. If
Xthe sizeof(int) on your system is 16 bits, then the difference
Xshould be 502. If it is not, then perhaps the types (some or all)
Xof c_size, and the elements in t_stor should be changed to reflect
Xthis.
X
X			Good luck!
X
XI can be reached at:
X
X		utcs!bnr-vpa!bruce			(UUCP)
Xor		(613) 726 - 3008			(Phone)
X		(Ottawa, Canada)
X
SHAR_EOF
if test 6854 -ne "`wc -c 'table.doc'`"
then
	echo shar: error transmitting "'table.doc'" '(should have been 6854 characters)'
fi
echo shar: extracting "'term.5'" '(6192 characters)'
if test -f 'term.5'
then
	echo shar: over-writing existing file "'term.5'"
fi
sed 's/^X//' << \SHAR_EOF > 'term.5'
X.TH TERM 5
X.SH NAME
Xterm \- terminal driving tables for nroff
X.SH DESCRIPTION
X.IR Nroff (1)
Xuses driving tables to customize its output for various types of
Xoutput devices, such as printing terminals, special word-processing
Xterminals (such as Diablo, Qume, or NEC Spinwriter mechanisms),
Xor special output filter programs.  These driving tables are written
Xas C programs, compiled, and installed in
X\f3/usr/lib/term/tab\f2name\fP ,
Xwhere
X.I name\^
Xis the name for that terminal type as given in
X.IR term (7).
XThe structure of the tables is as follows:
X.PP
X.nf
X.ta 5m 10m 15m 20m 25m 30m 35m 40m 45m 50m 55m 60m
X#define	INCH	240
X
Xstruct {
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X	int Em;
X	int Halfline;
X	int Adj;
X	char *twinit;
X	char *twrest;
X	char *twnl;
X	char *hlr;
X	char *hlf;
X	char *flr;
X	char *bdon;
X	char *bdoff;
X	char *iton;
X	char *itoff;
X	char *ploton;
X	char *plotoff;
X	char *up;
X	char *down;
X	char *right;
X	char *left;
X	char *codetab[256\-32];
X	char *zzz;
X} t;
X.fi
X.DT
X.PP
XThe meanings of the various fields are as follows:
X.TP 10
X.I bset\^
Xbits to set in the
X.I c_oflag\^
Xfield of the
X.I termio\^
Xstructure (see
X.IR tty (4))
Xbefore output.
X.TP 10
X.I breset\^
Xbits to reset in the
X.I c_oflag\^
Xfield of the
X.I termio\^
Xstructure
Xbefore output.
X.TP 10
X.I Hor\^
Xhorizontal resolution in fractions of an inch.
X.TP 10
X.I Vert\^
Xvertical resolution in fractions of an inch.
X.TP 10
X.I Newline\^
Xspace moved by a newline (linefeed) character in fractions
Xof an inch.
X.TP 10
X.I Char\^
Xquantum of character sizes, in fractions of an inch.
X(i.e., a character is a multiple of Char units wide)
X.TP 10
X.I Em\^
Xsize of an em in fractions of an inch.
X.TP 10
X.I Halfline\^
Xspace moved by a half-linefeed (or half-reverse-linefeed)
Xcharacter in fractions of an inch.
X.TP 10
X.I Adj\^
Xquantum of white space, in fractions of an inch.
X(i.e., white spaces are a multiple of Adj units wide)
X.IP
XNote: if this is less than the size of the space
Xcharacter (in units of Char; see below for how the
Xsizes of characters are defined),
X.I nroff\^
Xwill output
Xfractional spaces using plot mode.  Also, if the
X.B \-e
Xswitch to
X.I nroff\^
Xis used, Adj is set equal to Hor by
X.IR nroff .
X.TP 10
X.I twinit\^
Xset of characters used to initialize the terminal
Xin a mode suitable for
X.IR nroff .
X.TP 10
X.I twrest\^
Xset of characters used to restore the terminal to
Xnormal mode.
X.TP 10
X.I twnl\^
Xset of characters used to move down one line.
X.TP 10
X.I hlr\^
Xset of characters used to move up one-half line.
X.TP 10
X.I hlf\^
Xset of characters used to move down one-half line.
X.TP 10
X.I flr\^
Xset of characters used to move up one line.
X.TP 10
X.I bdon\^
Xset of characters used to turn on hardware boldface mode,
Xif any.
X.I Nroff\^
Xassumes that boldface mode is reset automatically by the
X.I twnl\^
Xstring, because many letter-quality printers reset the boldface
Xmode when they receive a carriage return;
Xthe
X.I twnl\^
Xstring should include whatever characters are necessary to
Xreset the boldface mode.
X.TP 10
X.I bdoff\^
Xset of characters used to turn off hardware boldface mode,
Xif any.
X.TP 10
X.I iton\^
Xset of characters used to turn on hardware italics mode,
Xif any.
X.TP 10
X.I itoff\^
Xset of characters used to turn off hardware italics mode,
Xif any.
X.TP 10
X.I ploton\^
Xset of characters used to turn on hardware plot mode
X(for Diablo type mechanisms), if any.
X.TP 10
X.I plotoff\^
Xset of characters used to turn off hardware plot mode
X(for Diablo type mechanisms), if any.
X.TP 10
X.I up\^
Xset of characters used to move up one resolution unit
X(Vert) in plot mode, if any.
X.TP 10
X.I down\^
Xset of characters used to move down one resolution unit
X(Vert) in plot mode, if any.
X.TP 10
X.I right\^
Xset of characters used to move right one resolution unit
X(Hor) in plot mode, if any.
X.TP 10
X.I left\^
Xset of characters used to move left one resolution unit
X(Hor) in plot mode, if any.
X.TP 10
X.I codetab\^
Xdefinition of characters needed to print an
X.I nroff\^
Xcharacter
Xon the terminal.
XThe first byte is the number of character units (Char) needed to hold the
Xcharacter; i.e., ``\\001'' is one unit wide, ``\\002'' is two
Xunits wide, etc.  The high-order bit (0200) is on if
Xthe character is to be underlined in underline mode
X(.ul).
XThe rest of the bytes are the characters used to produce the character in
Xquestion.  If the character has the sign (0200) bit on,
Xit is a code to move the terminal in plot mode.  It is
Xencoded as:
X.RS
X.IP "0100 bit on" 15
Xvertical motion.
X.IP "0100 bit off" 15
Xhorizontal motion.
X.IP "040 bit on" 15
Xnegative (up or left) motion.
X.IP "040 bit off" 15
Xpositive (down or right) motion.
X.IP "037 bits" 15
Xnumber of such motions to make.
X.RE
X.TP 10
X.I zzz\^
Xa zero terminator at the end.
X.PP
XAll quantities which are in units of fractions of an inch should
Xbe expressed as
X.RI INCH* num / denom ,
Xwhere
X.I num\^
Xand
X.I denom\^
Xare respectively the numerator and denominator of the fraction; i.e.,
X1/48 of an inch would be written as ``INCH/48''.
X.PP
XIf any sequence of characters does not pertain to the output device,
Xthat sequence should be given as a null string.
X.PP
XIf you have source license:
X.br
XThe source code for the terminal
X.I name\^
Xis in
X.BI /usr/src/cmd/text/roff.d/terms.d/tab name .c.
XWhen a new terminal type is added, the file
X.I maketerms.c\^
Xshould be updated to `#include' the source to that driving table;
Xnote that the various terminal types are grouped into ``parts'' labelled
X.BR PART1 ,
X.BR PART2 ,
Xand
X.BR PART3 .
XIf necessary, more parts can be added.  Other changes necessary to
X.I maketerms.c\^
Xare left as an exercise to the reader.
XThe makefile
X.I terms.mk\^
Xin that directory should then be updated.
X.PP
XIf you do not have source license, but have Bruce Townsend's
X.I table\^
Xutility:
X.br
XThe source code for the terminal
X.I name\^
Xis in a file called
X.BI tab name .c.
XWhen a new terminal type is added, the file
X.I Makefile\^
Xin the same directory should be updated.
XJust add the name
X.BI tab name
Xto the definition of
X.BR TABFILES .
XThen type
X.BI "make tab" name.
XStore the result in
X.B /usr/lib/term.
X.SH FILES
X/usr/lib/term/tab\f2name\fP	driving tables
X.br
Xtab\f2name\fP.c	source for driving tables
X.SH SEE ALSO
Xtroff(1), term(7)
SHAR_EOF
if test 6192 -ne "`wc -c 'term.5'`"
then
	echo shar: error transmitting "'term.5'" '(should have been 6192 characters)'
fi
echo shar: extracting "'term.h'" '(800 characters)'
if test -f 'term.h'
then
	echo shar: over-writing existing file "'term.h'"
fi
sed 's/^X//' << \SHAR_EOF > 'term.h'
X#ifndef	INCH
X#define	INCH	240
X#endif
X
Xstruct t {
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X	int Em;
X	int Halfline;
X	int Adj;
X	char *twinit;
X	char *twrest;
X	char *twnl;
X	char *hlr;
X	char *hlf;
X	char *flr;
X	char *bdon;
X	char *bdoff;
X	char *iton;
X	char *itoff;
X	char *ploton;
X	char *plotoff;
X	char *up;
X	char *down;
X	char *right;
X	char *left;
X	char *codetab[256-32];
X	char *zzz;
X	};
X
Xstruct t_stor {		/* This structure will be stored in the tab file */
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X	int Em;
X	int Halfline;
X	int Adj;
X	int twinit;
X	int twrest;
X	int twnl;
X	int hlr;
X	int hlf;
X	int flr;
X	int bdon;
X	int bdoff;
X	int iton;
X	int itoff;
X	int ploton;
X	int plotoff;
X	int up;
X	int down;
X	int right;
X	int left;
X	int codetab[256-32];
X	int zzz;
X};
SHAR_EOF
if test 800 -ne "`wc -c 'term.h'`"
then
	echo shar: error transmitting "'term.h'" '(should have been 800 characters)'
fi
#	End of shell archive
exit 0
