From: talcott!seismo!gatech!unmvax!wampler (Bruce Wampler)
Subject: tvx: 6 of 10
Newsgroups: mod.sources
Approved: jpn@panda.UUCP

Mod.sources:  Volume 4, Issue 20
Submitted by: gatech!unmvax!wampler (Bruce Wampler)

#--------CUT---------CUT---------CUT---------CUT--------#
#########################################################
#  TVX: File 6 of 10                                    #
#                                                       #
# This is a shell archive file.  To extract files:      #
#                                                       #
#    1)	Make a directory (like tvx) for the files.      #
#    2) Write a file, such as "filen.shar", containing  #
#       this archive file into the directory.           #
#    3) Type "sh file.shar".  Do not use csh.           #
#                                                       #
#########################################################
#
#
echo Extracting tvx_edit.c:
sed 's/^X//' >tvx_edit.c <<\SHAR_EOF
X/* ---------------------------------------------------------------------
X	This module contains the main edit routine, which is
Xdifferent for each editor being emulated.  The code that is unique
Xto each emulation is confined to the three .ic files, tvx_lex.c, and
Xthis module.  The remainder of the tvx files are the same for all versions.
X
X
X   This version of TVX Copyright (c) 1986 by Bruce E. Wampler
X
X   Permission is hereby granted for free, unrestricted nonprofit
X   use of this software.  Please feel free to modify, distribute,
X   and share this software as long as you aren't making any money
X   from it.  If you want to use this code in a profit making environment,
X   please contact the author for permission.
X
X--------------------------------------------------------------------- */
X
X#include "tvx_defs.ic"		/* note tv_defs.ic will #include stdio.h */
X#include "tvx_glbl.ic"
X
X  char clower(),cupper();
X
X
X#ifdef TVX_CMDSET		/* works for both tvx_em and tvx0m_em */
X/* =============================>>> EDIT   <<<============================= */
X  edit()
X  { /*	edit - main editing routine */
X
X    SLOW int lexval,lexcnt,succ, lastln, itmp;
X    SLOW int noteloc[10], ni, lex_def;
X    SLOW char lexchr;
X
X    static int ins_set[] =		/* allowable commands for insert */
X      {
X	VINSERT, VOPENLINE, VQUIT, VABORT, VFBEGIN, VGET, VYANK, 0
X      };
X
X    static int jump_set[] =	/* commands to not reset jump memory */
X      {
X	VJUMP, VMEMORY, VHELP, VNOTELOC, VPRINTS, 0
X      };
X    SLOW char fchr;		/* temp char for prefixed commands */
X
X    startm();
X    remark("Reading file...");
X
X    rdpage();			/* read a page into the buffer */
X
X    tvclr();			/* clear the screen */
X
X    if (curlin >= 1)
X	tvtype(curlin,tvlins);	/* type out lines */
X
X    tvxy(1,1);			/* and rehome the cursor */
X    waserr = FALSE;		/* no errors to erase yet */
X
X    if (curlin<1)
X	tverr("Buffer empty");
X#ifdef SCR_BUF
X    ttflush();
X#endif
X
X    lexval = UNKNOWN;		/* so can remember 1st time through */
X    useprint = FALSE;		/* not to printer */
X    succ=TRUE;			/* assume success initially */
X
X    lastln = 1	;		/* remember where we were */
X    for (ni = 0 ; ni < 10 ; noteloc[ni++] = 1)
X	;			/* init noteloc */
X    do
X      {
X	oldlex = lexval;		/* remember last command */
X	if (! succ)
X	    echof = TRUE;		/* resume echo when error */
X	lex_def = lex(&lexval,&lexcnt,&lexchr,succ);	/* get command input */
X	if (waserr)
X	    fixend();
X	waserr=FALSE;
X	succ=TRUE;
X	if (lexval == UNKNOWN)
X	  {
X	    cmderr(lexchr);
X	    succ = FALSE;	/* announce failure to lex */
X	  }
X	else
X	  {
X	    if (curlin < 1)	/* make sure legal command for empty buffer */
X	      {
X		if (!inset(lexval,ins_set))
X		  {
X		    tverrb("Can't, buffer empty. Insert 1st ");
X		    succ=FALSE;
X		    continue;
X		  }
X	      }
X	    if (!inset(lexval,jump_set))
X		lastln=curlin;		/* let user look at help w/o changing */
X
X	    switch (lexval)
X	    {
Xcase 1: 			/* right */
X	    right(lexcnt);
X	    break;
Xcase 2: 			/* left */
X	    right(-lexcnt);
X	    break;
Xcase 3: 			/* down line */
X	    dwnlin(lexcnt);
X	    break;
Xcase 4: 			/* up line */
X	    dwnlin(-lexcnt);
X	    break;
Xcase 5: 			/* down in column */
X	    dwncol(lexcnt);
X	    break;
Xcase 6: 			/* up in column */
X	    dwncol(-lexcnt);
X	    break;
Xcase 7: 			/* delete last character */
X	    succ = delnxt(-lexcnt);
X	    break;
Xcase 8: 			/* delete next character */
X	    succ = delnxt(lexcnt);
X	    break;
Xcase 9: 			/* insert */
X	    succ = insert(lexcnt,lex_def);
X	    break;
Xcase 10:			/* kill a line */
X	    killin(lexcnt);
X	    break;
Xcase 11:			/* kill rest of line */
X	    krest();
X	    break;
Xcase 12:			/* kill previous part of line */
X	    kprev();
X	    break;
Xcase 13:			/* move to beginning of line */
X	    beglin();
X	    break;
Xcase 14:			/* move to end of the line */
X	    endlin();
X	    break;
Xcase 15:			/* search for a pattern */
X	    succ = search(lexcnt,TRUE);
X	    break;
Xcase 16:			/* search for next part of a pattern */
X	    succ = snext(lexcnt,TRUE);
X	    break;
Xcase 17:			/* flip screen */
X	    dwnlin(min(lexcnt*tvlins,nxtlin-curlin+1));
X	    break;
Xcase 18:			/* goto top of page */
X	    toppag();
X	    break;
Xcase 19:			/* goto to bottom of page */
X	    botpag();
X	    break;
Xcase 20:			/* goto real beginning of the file */
X	    succ = fbeg();
X	    break;
Xcase 21:			/* verify */
X	    verify(lexcnt);
X	    break;
Xcase 22:			/* open new line */
X	    openln(lexcnt);
X#ifdef TVX_EM			/* don't need insert for modeless tvx */
X	    succ = insert(1,TRUE); /* go into insert mode, insert mode */
X#endif
X	    break;
Xcase 23:			/* delete last thing manipulated */
X	    succ = rmvlst();
X	    break;
Xcase 24:			/* save lines in move buffer */
X	    succ = save(lexcnt,FALSE);
X	    break;
Xcase 25:			/* get move buffer */
X	    succ = getsav();
X	    break;
Xcase 26:			/* read in next page of file */
X	    wtpage(lexcnt);	/* write out the current page */
X	    succ = rdpage();	/* read in the next */
X	    tvclr();
X	    if (succ || lexcnt < 0)
X		verify(1);
X	    break;
Xcase 27:			/* append external file to save buffer */
X	    succ = addfil(lexcnt);
X	    break;
Xcase 28:			/* quit */
X	    tvclr();
X	    remark("Exit");
X	    goto lquit;
Xcase 29:			/* search again */
X	    succ = search(lexcnt,FALSE); /* FALSE => don't read search string */
X	    break;
Xcase 30:			/* execute repeat buffer again */
X	    if (lexcnt != 1)
X		echof=FALSE;	/* turn off echo */
X	    rptcnt[rptuse] = lexcnt > 0 ? lexcnt : (-lexcnt);
X	    break;
Xcase 31:			/* print memory status, etc. */
X	    memory();
X	    break;
Xcase 32:			/* change a parameter */
X	    if (!grptch(&fchr))
X	      {
X		succ = FALSE;
X		break;
X	      }
X	    setpar(lexcnt,fchr);
X	    break;
Xcase 33:			/* remove last and enter insert mode */
X	    if ((succ = rmvlst()))
X		succ = insert(1,TRUE);
X	    break;
Xcase 34:			/* unkill last line killed */
X	    succ = unkill();
X	    break;
Xcase 35:			/* jump over a word */
X	    wordr(lexcnt);
X	    break;
Xcase 36:			/* neg jump over word */
X	    wordr(-lexcnt);
X	    break;
Xcase 37:			/* append to save buffer */
X	    succ = save(lexcnt,TRUE);
X	    break;
Xcase 38:			/* print screen */
X	    scrprint();
X	    break;
Xcase 39:			/* show repeat buffer + help*/
X	    shoset();
X	    break;
Xcase 40:			/* flip screen half page */
X	    dwnlin( min((lexcnt*tvlins)/2 , nxtlin-curlin+1) );
X	    break;
Xcase 41:			/* abort */
X	    abort();
X	    break;
Xcase 42:			/* change characters */
X	    if ((succ = delnxt(lexcnt)))
X		succ = insert(1,TRUE);
X	    break;
Xcase 43:			/* jump back to last location */
X	    itmp = curlin;
X	    curlin = lastln;
X	    curchr = *(lines+curlin)+1;	/* point to the current character */
X	    verify(1);
X	    lastln = itmp;
X	    break;
Xcase 44:			/* tidy up screen */
X	    succ = neaten(lexcnt);
X	    break;
Xcase 45:			/* save current location */
X	    if (lexcnt < 1 || lexcnt > 9)
X		lexcnt = 0;
X	    noteloc[lexcnt] = curlin;
X	    break;
Xcase 46:			/* return to noted location */
X	    itmp = curlin;
X	    if (lexcnt < 1 || lexcnt > 9)
X		lexcnt = 0;
X	    if (noteloc[lexcnt] >= nxtlin)
X	      {
X		tverrb("Line no longer there ");
X		noteloc[lexcnt] = curlin;
X	      }
X	    else
X	      {
X		curlin = noteloc[lexcnt];
X		curchr = *(lines+curlin)+1; /* point to the current character */
X		verify(1);
X		lastln = itmp;
X	      }
X	    break;
X
Xcase 47:
X	    opsystem();		/* call operating system */
X	    break;
X
Xcase 48:
X	    if (lex_def)		/* default 1 passed */
X		lexcnt = rptuse + 1;	/* use current repeat loop */
X	    succ = edit_rpt(lexcnt);	/* edit repeat buffer */
X	    break;
X
Xcase 49:
X	    succ = store_rpt(lexcnt);	/* store repeat buffer */
X	    break;
X
Xcase 50:
X	    succ = exec_rpt(lexcnt);	/* execute repeat buffer */
X	    break;
X
Xcase 51:
X	    succ = ins_pat(lexcnt);
X	    break;
Xcase 52:
X	    succ = user_1(lexcnt);	/* user function 1 */
X	    break;
X
Xcase 53:
X	    succ = user_2(lexcnt);	/* user function 2 */
X	    break;
Xcase 54:				/* '~': change case */
X	    foldcase(lexcnt);
X	    break;
X	    }  			/* end of switch */
X	    continue;		/* next iteration of do loop */
X	  } /* end of else */
X#ifdef SCR_BUF
X	ttflush();
X#endif
X      } /* end of do loop */
X    while (1);
X
Xlquit:
X    for ( wtpage(1) ; rdpage() ; wtpage(1) )	/* write whole file */
X	;
X    tvclr();
X  }
X#endif
X
X#ifdef VI_EM			/* vi emulation */
X/* =============================>>> EDIT   <<<============================= */
X  edit()
X  { /*	edit - main editing routine */
X
X    SLOW int lexval,lexcnt,succ, lastln, itmp;
X    SLOW int noteloc[10], ni, lex_def;
X    SLOW char lexchr;
X
X    static int ins_set[] =	/* MUCH more limited than tvx */
X      {
X	VINSERT, VENDZ, VTVX, VNOOP, 0
X      };
X
X    static int jump_set[] =	/* commands to not reset jump memory */
X      {
X	VTVX, VMEMORY, VHELP, VNOTELOC, VNOOP, 0
X      };
X    SLOW char fchr;		/* temp char for prefixed commands */
X    static int dir_up = FALSE;	/* search down by default */
X
X    startm();
X    remark("Reading file...");
X
X    rdpage();			/* read a page into the buffer */
X
X    tvclr();			/* clear the screen */
X
X    if (curlin >= 1)
X	tvtype(curlin,tvlins);	/* type out lines */
X
X    tvxy(1,1);			/* and rehome the cursor */
X    waserr = FALSE;		/* no errors to erase yet */
X
X    if (curlin<1)
X	tverr("Buffer empty");
X#ifdef SCR_BUF
X    ttflush();
X#endif
X
X    lexval = UNKNOWN;		/* so can remember 1st time through */
X    useprint = FALSE;		/* not to printer */
X    succ=TRUE;			/* assume success initially */
X
X    lastln = 1	;		/* remember where we were */
X    for (ni = 0 ; ni < 10 ; noteloc[ni++] = 1)
X	;			/* init noteloc */
X    do
X      {
X	oldlex = lexval;		/* remember last command */
X	if (! succ)
X	    echof = TRUE;		/* resume echo when error */
X	lex_def = lex(&lexval,&lexcnt,&lexchr,succ);	/* get command input */
X	if (waserr)
X	    fixend();
X	waserr=FALSE;
X	succ=TRUE;
X	if (lexval == UNKNOWN)
X	  {
X	    cmderr(lexchr);
X	    succ = FALSE;	/* announce failure to lex */
X	  }
X	else
X	  {
X	    if (curlin < 1)	/* make sure legal command for empty buffer */
X	      {
X		if (!inset(lexval,ins_set))
X		  {
X		    tverrb("Can't, buffer empty. Insert 1st ");
X		    succ=FALSE;
X		    continue;
X		  }
X	      }
X	    if (!inset(lexval,jump_set))
X		lastln=curlin;		/* let user look at help w/o changing */
X
X/* these all started out in order, but... */
X	    switch (lexval)
X	    {
Xcase 1: 			/* ^B: screen up */
X	    dwnlin(min(-lexcnt*tvlins,nxtlin-curlin+1));
X	    break;
Xcase 2: 			/* ^D: half screen */
X	    dwnlin( min((lexcnt*tvlins)/2 , nxtlin-curlin+1) );
X	    break;
Xcase 3: 			/* ^F: screen down */
X	    dwnlin(min(lexcnt*tvlins,nxtlin-curlin+1));
X	    break;
Xcase 4: 			/* ^G: memory status */
X	    memory();
X	    break;
Xcase 5: 			/* ^H: left (must be here to avoid
X				    conflict with normal char del */
X	    right(-lexcnt);
X	    break;
Xcase 6: 			/* ^L: verify screen */
X	    verify(lexcnt);
X	    break;
Xcase 7: 			/* '=': help */
X	    shoset();
X	    break;
Xcase 8: 			/* '!' - tidy */
X	    succ = neaten(lexcnt);
X	    break;
Xcase 9: 			/* '#': execute macro n times */
X	    succ = exec_rpt(lexcnt);	/* execute repeat buffer */
X	    break;
Xcase 10:			/* '$': end of current line */
X	    endlin();
X	    break;
Xcase 11:			/* '*': insert last found pattern */
X	    succ = ins_pat(lexcnt);
X	    break;
Xcase 12:			/* '/': search down */
X	    dir_up = FALSE;
X	    succ = search(1,TRUE);	/* searching down*/
X	    break;
Xcase 13:			/* ':': set parameter, just like tvx */
X	    tverrb("Use ZZ to exit ");
X	    break;
Xcase 14:			/* 'J': join lines */
X	    endlin();
X	    delnxt(lexcnt);
X	    succ = insert((int) ' ',FALSE);
X	    break;
Xcase 15:			/* '?': find upwards */
X	    dir_up = TRUE;
X	    succ = search(-1,TRUE);
X	    break;
Xcase 16:			/* '@': execute current repeat loop */
X	    if (lexcnt != 1)
X		echof=FALSE;	/* turn off echo */
X	    rptcnt[rptuse] = lexcnt > 0 ? lexcnt : (-lexcnt);
X	    break;
Xcase 17:			/* 'A': append to end of line {.i} */
X	    endlin();
X	    succ = insert(1,TRUE); /* go into insert mode, insert mode */
X	    break;
Xcase 18:			/* 'C': changes rest of line {"i } */
X	    krest();		/* kill rest of line */
X	    succ = insert(1,TRUE); /* enter insert mode */
X	    break;
Xcase 19:			/* 'D': delete rest of the line {"} */
X	    krest();		/* kill rest of line */
X	    break;
Xcase 20:			/* 'G': goes to line number n, or
X				    end of buffer if no n */
X	    if (lex_def)	/* no n supplied */
X		botpag();
X	    else
X	      {
X		toppag();	/* go to top of file */
X		dwnlin(lexcnt - 1);	/* go to that line */
X	      }
X	    break;
Xcase 21:			/* 'H': Beginning of buffer */
X	    toppag();		/* go to top of buffer */
X	    break;
X
Xcase 22:			/* 'I': inserts a beginning of line */
X	    beglin();
X	    succ = insert(1,TRUE); /* go into insert mode */
X	    break;
Xcase 23:			/* 'J': like vi j - down in column */
X	    dwncol(lexcnt);
X	    break;
Xcase 24:			/* 'K': like vi k - up in column */
X	    dwncol(-lexcnt);
X	    break;
Xcase 25:			/* 'L': bottom line of file */
X	    botpag();
X	    beglin();
X	    break;
Xcase 26:			/* 'M': return to marked location */
X	    itmp = curlin;
X	    if (lexcnt < 1 || lexcnt > 9)
X		lexcnt = 0;
X	    if (noteloc[lexcnt] >= nxtlin)
X	      {
X		tverrb("Line no longer there ");
X		noteloc[lexcnt] = curlin;
X	      }
X	    else
X	      {
X		curlin = noteloc[lexcnt];
X		curchr = *(lines+curlin)+1; /* point to the current character */
X		verify(1);
X		lastln = itmp;
X	      }
X	    break;
Xcase 27:			/* 'N': reverse find again */
X	    succ = search((dir_up ? 1 : -1),FALSE);
X			 /* FALSE => don't read search string */
X	    break;
Xcase 28:			/* 'O': open a line above current line */
X	    beglin();
X	    openln(lexcnt);
X	    succ = insert(1,TRUE); /* go into insert mode, insert mode */
X	    break;
Xcase 29:			/* 'P': put save buffer above current line */
X	    beglin();
X	    succ = getsav();
X	    break;
Xcase 30:			/* 'T': tvx commands */
X	    if (!grptch(&fchr))
X	      {
X		succ = FALSE;
X		break;
X	      }
X	    fchr = clower(fchr);	/* lower case */
X	    if (curlin < 1)	/* make sure legal command for empty buffer */
X	      {
X		if ( fchr != 'b')
X		  {
X		    tverrb("Can't, buffer empty. Insert 1st ");
X		    succ=FALSE;
X		    break;
X		  }
X	      }
X	    switch (fchr)
X	    {
X	    case ':':			/* set parameter */
X		if (!grptch(&fchr))
X		  {
X		    succ = FALSE;
X		    break;
X		  }
X		setpar(lexcnt,fchr);
X		break;
X	    case '!':
X		opsystem();		/* call operating system */
X		break;
X	    case 'b':			/* goto real beginning of the file */
X		succ = fbeg();
X		break;
X	    case 'e':			/* edit repeat buffer */
X		if (lex_def)		/* default 1 passed */
X		    lexcnt = rptuse + 1;	/* use current repeat loop */
X		succ = edit_rpt(lexcnt);	/* edit repeat buffer */
X		break;
X	    case 'j':			/* jump back to last location */
X		itmp = curlin;
X		curlin = lastln;
X		curchr = *(lines+curlin)+1; /* point to the current character */
X		verify(1);
X		lastln = itmp;
X		break;
X	    case 'p':		/* put external file from save buffer */
X		succ = addfil(-1);
X		break;
X	    case 'r':			/* restore repeat buffer */
X		succ = store_rpt(lexcnt);	/* store repeat buffer */
X		break;
X	    case 's':			/* print screen */
X		scrprint();
X		break;
X	    case 'u':			/* "undo" */
X		succ = unkill();
X		break;
X	    case 'w':			/* read in next page of file */
X		wtpage(lexcnt);	/* write out the current page */
X		succ = rdpage();	/* read in the next */
X		tvclr();
X		if (succ || lexcnt < 0)
X		    verify(1);
X		break;
X	    case 'y':		/* yank external file to save buffer */
X		succ = addfil(1);
X		break;
X	    case '/':		/* search across buffers */
X		succ = snext(1,TRUE);
X		break;
X	    case '(':		/* user 1 */
X		succ = user_1(lexcnt);	/* user function 1 */
X		break;
X	    default:
X		tverrb("Use !,b,e,j,p,r,s,u,w,y, or / with q ");
X		break;
X	    }
X	    break;
Xcase 31:			/* 'X': delete character before cursor */
X	    succ = delnxt(-lexcnt);
X	    break;
Xcase 32:			/* 'Y': append to save buffer */
X	    succ = save(lexcnt,TRUE);
X	    break;
Xcase 33:			/* 'Z': exit (ZZ: normal, ZA: abort) */
X	    if (!grptch(&fchr))
X	      {
X		succ = FALSE;
X		break;
X	      }
X	    switch (clower(fchr))
X	    {
X	    case 'z':		/* normal exit */
X		tvclr();
X		remark("Exit");
X		goto lquit;
X	    case 'a':		/* abort or terminate exit */
X		abort();
X		break;
X	    case 27:		/* escape is no op */
X		break;
X	    default:
X		tverrb("Use Z or A with Z");
X		break;
X	    }
X	    break;
Xcase 34:			/* '^': beginning of line */
X	    beglin();
X	    break;
Xcase 35:			/* 'a': append text */
X	    right(1);
X	    succ = insert(lexcnt,lex_def);
X	    break;
Xcase 36:			/* 'b': word left */
X	    wordr(-lexcnt);
X	    break;
Xcase 37:			/* 'c': change something */
X	    if (!grptch(&fchr))
X	      {
X		succ = FALSE;
X		break;
X	      }
X	    switch (clower(fchr))
X	    {
X	    case 'c':		/* change line */
X		killin(lexcnt);	/* remove the line */
X		openln(1);
X		succ = insert(1,TRUE); /* go into insert mode */
X		break;
X	    case ' ':		/* change one character */
X		delnxt(lexcnt);
X		succ = insert(1,TRUE); /* go into insert mode */
X		break;
X	    case '^':		/* to beginning of line */
X		kprev();
X		succ = insert(1,TRUE); /* go into insert mode */
X		break;
X	    case '$':		/* to beginning of line */
X		krest();
X		succ = insert(1,TRUE); /* go into insert mode */
X		break;
X	    case '/':		/* delete last thing, enter insert */
X		if ((succ = rmvlst()))
X		    succ = insert(1,TRUE);
X		break;
X	    case 27:		/* escape is no op */
X		break;
X	    default:
X		tverrb("Use c,<sp>,^,$, or / with c ");
X		break;
X	    }
X	    break;
Xcase 38:			/* 'd': delete d, <sp>, ^, or $ */
X	    if (!grptch(&fchr))
X	      {
X		succ = FALSE;
X		break;
X	      }
X	    switch (clower(fchr))
X	    {
X	    case 'd':		/* delete line */
X		killin(lexcnt);	/* remove the line */
X		break;
X	    case ' ':		/* delete character */
X		delnxt(lexcnt);
X		break;
X	    case '0':
X	    case '^':		/* to beginning of line */
X		kprev();
X		break;
X	    case '$':		/* to beginning of line */
X		krest();
X		break;
X	    case '/':		/* delete last thing */
X		succ = rmvlst();
X		break;
X	    case 27:		/* escape is no op */
X		break;
X	    default:
X		tverrb("Use d,<sp>,^,$, or / with d ");
X		break;
X	    }
X	    break;
Xcase 39:			/* ^U: half screen up */
X	    dwnlin( min((-lexcnt*tvlins)/2 , nxtlin-curlin+1) );
X	    break;
Xcase 40:			/* 'i': insert */
X	    succ = insert(1,lex_def);
X	    break;
Xcase 41:			/* 'j': down to line beginning */
X	    dwnlin(lexcnt);
X	    break;
Xcase 42:			/* 'k': up to line beginning */
X	    dwnlin(-lexcnt);
X	    break;
Xcase 43:			/* 'l': right */
X	    right(lexcnt);
X	    break;
Xcase 44:			/* 'm': mark location n */
X	    if (lexcnt < 1 || lexcnt > 9)
X		lexcnt = 0;
X	    noteloc[lexcnt] = curlin;
X	    break;
Xcase 45:			/* 'n': find next (in last direction) */
X	    succ = search((dir_up ? -1 : 1),FALSE);
X	    break;
Xcase 46:			/* 'o': open following line {do} */
X	    dwnlin(1);
X	    openln(lexcnt);
X	    succ = insert(1,TRUE); /* go into insert mode */
X	    break;
Xcase 47:			/* 'p': put save buffer after cur line */
X	    dwnlin(1);
X	    succ = getsav();
X	    break;
Xcase 48:			/* 'r': replace next char */
X	    if (!grptch(&fchr))
X	      {
X		succ = FALSE;
X		break;
X	      }
X	    delnxt(lexcnt);		/* delete count character */
X	    succ = insert((int)fchr,FALSE);
X#ifndef VI_MODS
X	    right(-1);			/* and back over char replaced */
X#endif
X	    break;
Xcase 49:				/* 's': substitute */
X	    if ((succ = delnxt(lexcnt)))
X		succ = insert(1,TRUE);
X	    break;
Xcase 50:				/* ESC: no operation */
X	    break;
Xcase 51:				/* 'w': advance word */
X	    wordr(lexcnt);
X	    break;
Xcase 52:				/* 'x': delete char */
X	    succ = delnxt(lexcnt);
X	    break;
Xcase 53:				/* 'y': yank to save buffer */
X	    succ = save(lexcnt,FALSE);
X	    break;
Xcase 54:				/* '~': change case */
X	    foldcase(lexcnt);
X	    break;
X	    }  			/* end of switch */
X	    continue;		/* next iteration of do loop */
X	  } /* end of else */
X#ifdef SCR_BUF
X	ttflush();
X#endif
X      } /* end of do loop */
X    while (1);
X
Xlquit:
X    for ( wtpage(1) ; rdpage() ; wtpage(1) )	/* write whole file */
X	;
X    tvclr();
X  }
X#endif
X
X#ifdef EMAX_EM		/* emacs modeless editor emulation */
X/* =============================>>> EDIT   <<<============================= */
X  edit()
X  { /*	edit - main editing routine */
X
X    SLOW int lexval,lexcnt,succ, lastln, itmp;
X    SLOW int noteloc[10], ni, lex_def;
X    SLOW char lexchr;
X
X    static int ins_set[] =	/* MUCH more limited than tvx */
X      {
X	VQUIT, VTVX, VNOOP, VEXTEND, VOPENLINE, VGET, 0
X      };
X
X    static int jump_set[] =	/* commands to not reset jump memory */
X      {
X	VTVX, VHELP, VNOOP, 0
X      };
X
X    static int c_jump_set[] =	/* jump set for ^C */
X      {
X	7, 10, 13, 'l', 0
X      };
X
X    SLOW char fchr;		/* temp char for prefixed commands */
X
X    startm();
X    remark("Reading file...");
X
X    rdpage();			/* read a page into the buffer */
X
X    tvclr();			/* clear the screen */
X
X    if (curlin >= 1)
X	tvtype(curlin,tvlins);	/* type out lines */
X
X    tvxy(1,1);			/* and rehome the cursor */
X    waserr = FALSE;		/* no errors to erase yet */
X
X    if (curlin<1)
X	tverr("Buffer empty");
X#ifdef SCR_BUF
X    ttflush();
X#endif
X
X    lexval = UNKNOWN;		/* so can remember 1st time through */
X    useprint = FALSE;		/* not to printer */
X    succ=TRUE;			/* assume success initially */
X
X    lastln = 1 ;	/* remember where we were */
X    for (ni = 0 ; ni < 10 ; noteloc[ni++] = 1)
X	;			/* init noteloc */
X    do
X      {
X	oldlex = lexval;		/* remember last command */
X	if (! succ)
X	    echof = TRUE;		/* resume echo when error */
X	lex_def = lex(&lexval,&lexcnt,&lexchr,succ);	/* get command input */
X	if (waserr)
X	    fixend();
X	waserr=FALSE;
X	succ=TRUE;
X	if (lexval == UNKNOWN)
X	  {
X	    cmderr(lexchr);
X	    succ = FALSE;	/* announce failure to lex */
X	  }
X	else
X	  {
X	    if (curlin < 1)	/* make sure legal command for empty buffer */
X	      {
X		if (!inset(lexval,ins_set))
X		  {
X		    tverrb("Can't, buffer empty. Insert 1st ");
X		    succ=FALSE;
X		    continue;
X		  }
X	      }
X	    if (!inset(lexval,jump_set))
X		lastln = curlin;	/* let user look at help w/o changing */
X
X	    switch (lexval)
X	    {
Xcase 1: 			/* ^A: Cursor to start of line */
X	    beglin();
X	    break;
Xcase 2: 			/* ^B: left */
X	    right(-lexcnt);
X	    break;
Xcase 3: 			/* ^C: Command (tvx) */
X	    if (!grptch(&fchr))
X	      {
X		succ = FALSE;
X		break;
X	      }
X	    fchr = clower(fchr);	/* lower case */
X	    if (curlin < 1)	/* make sure legal command for empty buffer */
X	      {
X		if ( fchr != 2 && fchr != 'r')
X		  {
X		    tverrb("Can't, buffer empty. Insert 1st ");
X		    succ=FALSE;
X		    break;
X		  }
X	      }
X	    if (!inset((int)fchr,c_jump_set))
X		lastln = curlin;	/* reset jump loc if not special */
X
X	    switch (fchr)
X	    {
X	    case 1:			/* ^A: append to save buffer */
X		lexval = VSAPPEND;
X		succ = save(lexcnt,TRUE);
X		break;
X	    case 2:			/* ^B: goto real begin of the file */
X		succ = fbeg();
X		break;
X	    case 5:			/* ^E: edit repeat buffer */
X		if (lex_def)		/* default 1 passed */
X		    lexcnt = rptuse + 1;	/* use current repeat loop */
X		succ = edit_rpt(lexcnt);	/* edit repeat buffer */
X		break;
X	    case 6:			/* ^F: fill (tidy) */
X		succ = neaten(lexcnt);
X		break;
X	    case 7:			/* ^G: no op */
X		break;
X	    case 8:			/* ^H: half screen down */
X		dwnlin( min((lexcnt*tvlins)/2 , nxtlin-curlin+1) );
X		break;
X	    case 10:			/* ^J: jump back to last location */
X		itmp = curlin;
X		curlin = lastln;
X		curchr = *(lines+curlin)+1;	/* point to the current char */
X		verify(1);
X		lastln = itmp;
X		break;
X	    case 11:			/* ^K: kill last thing */
X		succ = rmvlst();
X		break;
X	    case 13:			/* ^M: Mark current loc */
X		if (lexcnt < 1 || lexcnt > 9)
X		    lexcnt = 0;
X		noteloc[lexcnt] = curlin;
X		break;
X	    case 14:			/* ^N: move to next line */
X		dwnlin(lexcnt);
X		break;
X	    case 16:			/* ^P: beginning of prev line */
X		dwnlin(-lexcnt);
X		break;
X	    case 18:			/* ^R: restore repeat buffer */
X		succ = store_rpt(lexcnt);	/* store repeat buffer */
X		break;
X	    case 23:			/* ^W: write buffer */
X		wtpage(lexcnt);	/* write out the current page */
X		succ = rdpage();	/* read in the next */
X		tvclr();
X		if (succ || lexcnt < 0)
X		    verify(1);
X		break;
X	    case '(':		/* user 1 */
X		succ = user_1(lexcnt);	/* user function 1 */
X		break;
X	    case '~':			/* ~: change case */
X		foldcase(lexcnt);
X		break;
X	    case '*':			/* * insert found pattern */
X		succ = ins_pat(lexcnt);
X		break;
X	    case ';':			/* ;: search again */
X		lexval = VSAGAIN;
X		succ = search(1,FALSE);
X		break;
X	    case 'g':			/* goto line number n */
X		toppag();	/* go to top of file */
X		dwnlin(lexcnt - 1);	/* go to that line */
X		break;
X	    case 'h':			/* H: half screen up */
X		dwnlin( min((-lexcnt*tvlins)/2 , nxtlin-curlin+1) );
X		break;
X	    case 'i':
X		succ = insert(lexcnt,lex_def);
X		break;
X	    case 'l':			/* print screen */
X		scrprint();
X		break;
X	    case 'm':			/* m: return to marked loc */
X		itmp = curlin;
X		if (lexcnt < 1 || lexcnt > 9)
X		    lexcnt = 0;
X		if (noteloc[lexcnt] >= nxtlin)
X		  {
X		    tverrb("Line no longer there ");
X		    noteloc[lexcnt] = curlin;
X		  }
X		else
X		  {
X		    curlin = noteloc[lexcnt];
X		    curchr = *(lines+curlin)+1; /* point to the current char */
X		    verify(1);
X		    lastln = itmp;
X		  }
X		break;
X	    case 'p':			/* p: put line ins save buffer */
X		lexval = VSAVE;
X		succ = save(lexcnt,FALSE);
X		break;
X	    case 'r':		/* read external file to save buffer */
X		succ = addfil(1);
X		break;
X	    case 's':		/* search across buffers */
X		lexval = VNEXT;
X		succ = snext(1,TRUE);
X		break;
X	    case 'u':			/* "undo" */
X		succ = unkill();
X		break;
X	    case 'v':			/* v: set value */
X		 if (!grptch(&fchr))
X		  {
X		    succ = FALSE;
X		    break;
X		  }
X		setpar(lexcnt,fchr);
X		break;
X	    case 'w':		/* write save buffer to file*/
X		succ = addfil(-1);
X		break;
X	    default:
X		tverrb("Not valid command for ^C prefix ");
X		break;
X	    }
X	    break;
Xcase 4: 			/* ^D: Delete next char */
X	    succ = delnxt(lexcnt);
X	    break;
Xcase 5: 			/* ^E: End of line */
X	    endlin();
X	    break;
Xcase 6: 			/* ^F: right (forward) */
X	    right(lexcnt);
X	    break;
Xcase 7: 			/* ^G: noop */
X	    break;
Xcase 8: 			/* ^H: delete backwards */
X	    succ = delnxt(-lexcnt);
X	    break;
Xcase 9: 			/* ^K: kill line */
X	    if (lex_def)	/* no n supplied */
X	      {
X		if (*(buff+curchr) == ENDLINE)	/* + new line if there */
X		    delnxt(1);
X		else
X		    krest();	/* delete rest of the line, or newline */
X	      }
X	    else if (lexcnt == 0)	/* to beginning if 0 */
X		kprev();
X	    else
X		killin(lexcnt);
X	    break;
Xcase 10:			/* ^L: verify */
X	    verify(1);
X	    break;
Xcase 11:			/* ^N: next line (down in col) */
X	    dwncol(lexcnt);
X	    break;
Xcase 12:			/* ^O: open line */
X	    openln(lexcnt);
X	    break;
Xcase 13:			/* ^P: previous line (up in col) */
X	    dwncol(-lexcnt);
X	    break;
Xcase 14:			/* ^R: reverse search */
X	    succ = search(-1,TRUE);
X	    break;
Xcase 15:			/* ^S: normal search */
X	    succ = search(1,TRUE);
X	    break;
Xcase 16:			/* ^V: forward pages */
X	    dwnlin(min(lexcnt*tvlins,nxtlin-curlin+1));
X	    break;
Xcase 17:			/* ^X: extended command */
X	    if (!grptch(&fchr))
X	      {
X		succ = FALSE;
X		break;
X	      }
X	    fchr = clower(fchr);	/* lower case */
X	    if (curlin < 1)	/* make sure legal command for empty buffer */
X	      {
X		if ( fchr != 3)
X		  {
X		    tverrb("Can't, buffer empty. Insert 1st ");
X		    succ=FALSE;
X		    break;
X		  }
X	      }
X	    switch (fchr)
X	    {
X	    case 2:
X		memory();
X		break;
X	    case 3:			/* ^C: abort */
X		abort();
X		break;
X	    case 'e':			/* execute repeat loop */
X		if (lexcnt != 1)
X		    echof=FALSE;	/* turn off echo */
X		rptcnt[rptuse] = lexcnt > 0 ? lexcnt : (-lexcnt);
X		break;
X	    default:
X		tverrb("Not valid command for ^X prefix ");
X		break;
X	    }
X	
X	    break;
Xcase 18:			/* ^Y: Yank back save buffer */
X	    succ = getsav();
X	    break;
Xcase 19:			/* ^Z: save and exit */
X	    tvclr();
X	    remark("Save and exit");
X	    goto lquit;
Xcase 20:			/* !: call os */
X	    opsystem();		/* call operating system */
X	    break;
X
X/*	these have been prefixed by escape */
Xcase 21:			/* #: execute repeat loop again */
X	    succ = exec_rpt(lexcnt);	/* execute repeat buffer */
X	    break;
Xcase 22:			/* >: end of buffer */
X	    botpag();
X	    break;
Xcase 23:			/* <: top of buffer */
X	    toppag();
X	    break;
Xcase 24:			/* b: backward words */
X	    wordr(-lexcnt);
X	    break;
Xcase 25:			/* f: forward words */
X	    wordr(lexcnt);
X	    break;
Xcase 26:			/* v: backward pages */
X	    dwnlin(min(-lexcnt*tvlins,nxtlin-curlin+1));
X	    break;
Xcase 27:			/* ?: help */
X	    shoset();
X	    break;
X	    }  			/* end of switch */
X	    continue;		/* next iteration of do loop */
X	  } /* end of else */
X#ifdef SCR_BUF
X	ttflush();
X#endif
X      } /* end of do loop */
X    while (1);
X
Xlquit:
X    for ( wtpage(1) ; rdpage() ; wtpage(1) )	/* write whole file */
X	;
X    tvclr();
X  }
X#endif
X
X/* =============================>>> DWNCOL <<<============================= */
X  dwncol(cnt)
X  int cnt;
X  { /* dwncol - move down in column */
X
X    SLOW int curcol,l,oldef,needns;
X
X    needns = FALSE;
X    if (leftmg > 1)		/* handle right virtual screen different */
X      {
X	oldef=echof;
X	needns = TRUE;
X	echof = FALSE;
X      }
X
X    if (oldlex==VDOWNCOL || oldlex==VUPCOL)	/* several in a row? */
X	curcol=oldcol;		/* pick up old value */
X    else
X      {
X	curcol = curchr - *(lines+curlin);	/* calculate the current column */
X	oldcol = curcol;
X      }
X    dwnlin(cnt);		/* go down given lines */
X    if (curlin>=1 && curlin<nxtlin && curcol>1)	/* not at ends? */
X      {
X	l = strlen(buff + ((*(lines+curlin)) + 1) );
X	right(min(curcol-1,l));
X      }
X
X    if (needns)			/* needed new screen */
X      {
X	echof=oldef;
X	newscr();
X      }
X  }
X
X/* =============================>>> RMVLST <<<============================= */
X  int rmvlst()
X  {  /* rmvlst - delete the previous thing found or manipulated
X	length of oldlen is set by insert, find, and save
X	may also use savlen if set by save */
X
X    SLOW int oldech;
X#ifdef TVX_CMDSET
X    static int rmv_set[] =
X      {
X	VSEARCH, VNEXT, VSAVE, VGET, VSAGAIN, VSAPPEND,
X	VMVWORD, VMVBWORD, 0
X      };
X#endif
X#ifdef VI_EM
X    static int rmv_set[] =
X      {
X	VSEARCH, VSAVE, VGET, VSAGAIN, VSAPPEND, VPUT,
X	VMVWORD, VMVBWORD, VRSEARCH, VRSAGAIN, 0
X      };
X#endif
X#ifdef EMAX_EM
X    static int rmv_set[] =
X      {
X	VSEARCH, VNEXT, VSAVE, VGET, VSAGAIN, VSAPPEND,
X	VMVWORD, VMVBWORD, VRSEARCH, 0
X      };
X#endif
X
X    if (!inset(oldlex,rmv_set))
X	return (FALSE);
X
X    if (savlen > 0)
X      {
X	if (curlin == nxtlin-1 && slastl != 0)
X	  {
X	    --savlen;	/* reduce the count */
X	    if (savlen > 0)
X	      {
X		oldech = echof;
X		echof = FALSE;
X		killin(-savlen);	/* kill off previous lines */
X		echof = oldech;
X	      }
X	    killin(1);		/* kill the last line */
X	  }
X	else
X	    killin(-savlen);	/* kill off savlen lines */
X      }
X    else if (oldlen != 0)
X      {
X	if (! delnxt(-oldlen))
X	    return (FALSE);
X      }
X    oldlen = 0;			/* don't allow multiple deletes! */
X    savlen = (-1);
X    return (TRUE);
X  }
X
X/* =============================>>> SAVE   <<<============================= */
X  int save(cnt,app)
X  int cnt,app;
X  { /* save - save cnt lines in save buffer */
X
X    SLOW int l,lend;
X    SLOW BUFFINDEX from;
X
X    if (curlin == nxtlin-1 && slastl!=0)
X      {
X	tverrb("Can't save last line twice! ");
X	return (FALSE);
X      }
X    if (cnt < 0)
X	return (FALSE);
X
X    oldlen = 0;			/* use savlin instead */
X
X    if ((oldlex != VSAVE && !app) || cnt == 0)
X      { 			/* if new save, cnt == 0 and not appending */
X	slastl=0;
X	savlin=0;		/* haven't saved anything */
X	savlen=0;
X	nxtsav=mxbuff;	/* start saving at end */
X	if (cnt == 0)
X	  {
X	    return (TRUE);
X	  }
X      }
X
X    if (oldlex != VSAPPEND && app)	/* need to reset count for append */
X	savlen=0;
X
X    lend=min(curlin+cnt-1 ,nxtlin-1);
X    for (l=curlin; l <= lend ; ++l)
X      {
X	if (nxtsav-nxtchr < ALMOSTOUT)	/* make space if need and can */
X	    if (!gbgcol() || (nxtsav-nxtchr) < ALMOSTOUT)
X	      {
X		tverrb("No save room ");
X		return (FALSE);
X	      }
X
X	from = *(lines+l)+1;		/* first character of the line */
X	do
X	  {
X	    *(buff+nxtsav--) = *(buff+from++);
X	  }
X	while (*(buff+from-1)!=ENDLINE);
X	++savlin;		/* keep track of the length */
X	++savlen;		/* savlen for rmvlst */
X	if (curlin==nxtlin-1)	/* don't save last line twice! */
X	  {
X	    slastl=1;
X	    break;
X	  }
X	dwnlin(1);	/* move to next line on screen for + only */
X      }
X#ifdef SCR_BUF
X    ttflush();
X#endif
X    return (TRUE);
X  }
SHAR_EOF
echo Extracting tvx_glbl.ic:
sed 's/^X//' >tvx_glbl.ic <<\SHAR_EOF
X/* ---------------   TVX global declarations   ------------------------ */
X
X/*   This version of TVX Copyright (c) 1986 by Bruce E. Wampler
X
X   Permission is hereby granted for free, unrestricted nonprofit
X   use of this software.  Please feel free to modify, distribute,
X   and share this software as long as you aren't making any money
X   from it.  If you want to use this code in a profit making environment,
X   please contact the author for permission.
X*/
X/*
X   Following trick allows only one file for externals.  If EXTERN is not
X   defined, then variables are decleared extern.  ONE module, tvlex.c,
X   defines EXTERN, and thus actually declares things.  If you need to
X   change one of these values (terminal definition, for example), then
X   only tvlex.c needs to be recompiled!
X*/
X#ifndef EXTERN
X#define EXTERN extern
X#define USEEXTERN /**/
X#endif
X
X/* constants defined within the next #ifndef area are the important
X   system values that define the terminal, margins, etc.  ALL variables
X   between begpatch and endpatch must be initialized for the MS-DOS cii-86
X   compiler to put them all in the same contiguous memory area.
X   This allows the tvconfig program to work properly to find the #####:
X   patch area patern.  This works on the C/80 CP/M version, too, but
X   has never been tried on unix since the termcap driver is normally used.
X*/
X
X#ifndef USEEXTERN
X    EXTERN char begpatch[6] = {'#','#','#','#','#',':'};
X
X#include "tvx_term.ic"		/* include terminal definitions */
X
X/* the order of lexsym values MUST be in the order specified here to
X   correspond to the order of the switch in edit()
X*/
X/* ---------------------------- Standard TVX --------------------------- */
X#ifdef TVX_EM			/* define standard command set */
X    EXTERN char lexsym[LEXVALUES+1] = { '@', 'r', 'l', 'd', 'u',
X      4, 21, 8, 'k', 'i', 11, '"', '\'', ',', '.', 'f', 6, 'p',
X      'b', 'e', 2, 'v', 'o', '/', 's', 'g', 23, 25, 24, ';', '&',
X      'm', ':', '=', 7, 9, '{', 'a', 16, '?', 'h', 20, 'c', 'j', 't',
X      'n', 14, 15, 5, 18, '#', '*','(', ')','~'};
X/*  SYNONYM and function key list */
X
X    EXTERN char loop_beg = '<';
X    EXTERN char loop_end = '>';
X
X    EXTERN char synofr[20] =	/* from table */
X      {' ',13,'[',']',000,000,000,000,000,000,00,00,00,00,00,00,00,00,00,00};
X    EXTERN char synoto[20] =		/* translate to table */
X      {'r','d','{','{',000,0,000,00,00,000,00,00,00,00,00,00,00,00,00,00};
X#ifdef IBMPC
X    EXTERN char funkey = 0;		/* leading char for function key */
X    EXTERN char funchar[50] =	/* code sent by function key */
X      {	 /* make keypad function keys work like you would expect */
X	 71,  72,  73,  75,  77,  79,  82,  83,  80,  81,
X	 59, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X      };
X    EXTERN char funcmd[50] =	/* equivalent command */
X      {
X	'b',  21, 'h', 'l', 'r', 'e', 'i',  11,   4, 'p',
X	'&', 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X      };
X#else				/* regular terminal synonyms */
X    EXTERN char funkey = 0;		/* leading char for function key */
X    EXTERN char funchar[50] =	/* code sent by function key */
X      {
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000
X      };
X    EXTERN char funcmd[50] =	/* equivalent command */
X      {
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000
X      };
X#endif
X#endif		/* TVX_EM */
X
X/* ---------------------------- VI EMULATOR --------------------------- */
X#ifdef VI_EM			/* define vi emulation set */
X    EXTERN char lexsym[LEXVALUES+1] =
X      {
X      /*     1    2    3    4    5    6    7    8   9   10 */
X      '_',   2,   4,   6,   7,   8,  12, '=', '!', '#', '$',
X	   '*', '/', ':', 'J', '?', '@', 'A', 'C', 'D', 'G',
X	   'H', 'I',  14,  16, 'L', 'M', 'N', 'O', 'P', 'T',
X	   'X', 'Y', 'Z', '^', 'a', 'b', 'c', 'd',  21, 'i',
X	   '+', 'K', 'l', 'm', 'n', 'o', 'p', 'r', 's',  27,
X	   'w', 'x', 'y', '~'
X      };
X    EXTERN char loop_beg = '<';
X    EXTERN char loop_end = '>';
X
X/*  SYNONYM and function key list */
X#ifdef VI_MODS			/* extended definitions */
X    EXTERN char synofr[20] =	/* from table */
X/*          ^J  ^M  ^R  ^T    */
X      { 'h',10, 13, 18, 20,' ','B','Q','W','`','q','z','j','k',
X	11,127,00,00,00,00};
X    EXTERN char synoto[20] =		/* translate to table */
X      {  8, 14,'+', 12,'T','l','b','T','w','M','T', 12,'+','K',
X	16,'X',00,00,00,00};
X#else				/* regular definitions */
X    EXTERN char synofr[20] =	/* from table */
X/*          ^J  ^M  ^R  ^T    */
X      { 'h',10, 13, 18, 20,' ','B','Q','W','`','q','z','j','k',
X	11,127,00,00,00,00};
X    EXTERN char synoto[20] =		/* translate to table */
X      {  8, 14,'+', 12,'T','l','b','T','w','M','T', 12, 14, 16,
X	16,'X',00,00,00,00};
X#endif
X
X#ifdef IBMPC
X    EXTERN char funkey = 0;		/* leading char for function key */
X    EXTERN char funchar[50] =	/* code sent by function key */
X      {	 /* make keypad function keys work like you would expect */
X	 71,  72,  73,  75,  77,  79,  82,  83,  80,  81,
X	 00, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X      };
X    EXTERN char funcmd[50] =	/* equivalent command */
X      {
X	'H', 'K',   2,   8, 'l', 'L', 'i', 'X', '+',   6,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X      };
X#else				/* regular terminal synonyms */
X    EXTERN char funkey = 0;		/* leading char for function key */
X    EXTERN char funchar[50] =	/* code sent by function key */
X      {
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000
X      };
X    EXTERN char funcmd[50] =	/* equivalent command */
X      {
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000
X      };
X#endif
X#endif
X/* .......................... MODELESS VERSIONS ........................ */
X/*
X	The lexical analyzer and parser has been designed to allow
X	function keys to be easily used for modeless commands.  The
X	best way is to define lexsym using the usual mnemonic forms
X	of commands, and use the function key and synonym tables to
X	define function keys.  First, map function keys to single
X	negative values (or chars with hi bit set (> 127)).  Then,
X	have those values mapped to the real command in the synomym
X	tables.
X*/
X/* ---------------------------- Modeless TVX --------------------------- */
X#ifdef TVX0M_EM
X   /* like tvx, except normal lower case commands map to ^X and normal
X      control commands map to ESC commands */
X    EXTERN char lexsym[LEXVALUES+1] = { '@', 18, 12, 4, 21,
X      'd', 'u', 8, 11, 'i', 'k', '"', '\'', ',', '.', 6, 'f', 16,
X        2, 5, 'b', 22, 15, '/', 's', 'g', 'w', 'y', 'x', ';', '&',
X      'm', ':', '=', 7, 9, '{', 'a', 'p', '?', 'h', 't', 3, 'j', 20,
X      14, 'n', 'o', 'e', 'r', '#', '*','(', ')','~'};
X/*  SYNONYM and function key list */
X
X    EXTERN char loop_beg = '<';
X    EXTERN char loop_end = '>';
X    EXTERN char synofr[20] =	/* from table */
X      {'[',']',0,0,000,000,000,000,000,000,00,00,00,00,00,00,00,00,00,00};
X    EXTERN char synoto[20] =		/* translate to table */
X      {'{','{',0,0,000,0,000,00,00,000,00,00,00,00,00,00,00,00,00,00};
X#ifdef IBMPC
X    EXTERN char funkey = 0;		/* leading char for function key */
X    EXTERN char funchar[50] =	/* code sent by function key */
X      {	 /* make keypad function keys work like you would expect */
X	 71,  72,  73,  75,  77,  79,  83,  80,  81, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X      };
X    EXTERN char funcmd[50] =	/* equivalent command */
X      {
X	  2,  21,  16,  12,  18,  5,   11,   4,  16, 000,
X        000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X      };
X#else				/* regular terminal synonyms */
X    EXTERN char funkey = 0;		/* leading char for function key */
X    EXTERN char funchar[50] =	/* code sent by function key */
X      {
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000
X      };
X    EXTERN char funcmd[50] =	/* equivalent command */
X      {
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000
X      };
X#endif
X#endif
X
X/* ---------------------------- EMAX --------------------------- */
X#ifdef EMAX_EM
X   /* like tvx, except normal lower case commands map to ^X and normal
X      control commands map to ESC commands */
X    EXTERN char lexsym[LEXVALUES+1] =
X      { '%',   1,   2,   3,   4,   5,   6,   7,   8,  11,  12,
X	      14,  15,  16,  18,  19,  22,  24,  25,  26, '!',
X             '#', '>', '<', 'b', 'f', 'v', '?'
X      };
X/*  SYNONYM and function key list */
X
X    EXTERN char loop_beg = '(';		/* <esc>( for emax */
X    EXTERN char loop_end = ')';
X
X    EXTERN char synofr[20] =	/* from table */
X      {127,0202,0203,0204,'s',000,000,000,000,000,00,00,00,00,00,00,00,00,00,00};
X    EXTERN char synoto[20] =		/* translate to table */
X      {  8, '<', 'v', '>', 19,0,000,00,00,000,00,00,00,00,00,00,00,00,00,00};
X#ifdef IBMPC
X    EXTERN char funkey = 0;		/* leading char for function key */
X    EXTERN char funchar[50] =	/* code sent by function key */
X      {	 /* make keypad function keys work like you would expect */
X/*	 hm,  ^,  pgu,  <-,  ->, end, del,  v , pgd, */
X	 71,  72,  73,  75,  77,  79,  83,  80,  81, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X      };
X    EXTERN char funcmd[50] =	/* equivalent command */
X      {
X	0202, 16,0203,   2,   6,0204,   4,  14,  22, 000,
X        000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X      };
X#else				/* regular terminal synonyms */
X    EXTERN char funkey = 0;		/* leading char for function key */
X    EXTERN char funchar[50] =	/* code sent by function key */
X      {
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000
X      };
X    EXTERN char funcmd[50] =	/* equivalent command */
X      {
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
X	000, 000, 000, 000, 000, 000, 000, 000, 000, 000
X      };
X#endif
X#endif
X/* ------------------- END OF COMMAND SET VALUES ------------------ */
X
X    EXTERN char user_set[40] = "";		/* user search set */
X    EXTERN char use_wild = TRUE;		/* use wild cards by default */
X    EXTERN char old_cmds[16] = {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0 };
X    EXTERN int old_cindex = 0;			/* cursor into old_cmds */
X    EXTERN int cut_mode = DEF_CUTMODE;		/* kill line cuts */
X#ifdef NOMODE_LEX
X    EXTERN int escape_chr = 27;			/* ESC is default prefix char */
X#else
X    EXTERN int escape_chr = 0;			/* ESC is default prefix char */
X#endif
X
X
X#ifdef MSDOS
X    EXTERN char cfgname[40] = "-c=\\bin\\config.tvx";
X#endif
X#ifdef GEMDOS
X    EXTERN char cfgname[40] = "-c=config.tvx";
X#endif
X#ifdef UNIX
X    EXTERN char cfgname[40] = "-c=config.tvx";
X#endif
X#ifdef OSCPM
X    EXTERN char cfgname[40] = "-c=a:config.tvx";
X#endif
X    EXTERN int endpatch = 0;	/* to get address of end of patch area */
X
X#else
X    EXTERN char begpatch[6];
X
X    EXTERN char lexsym[LEXVALUES+1];
X    EXTERN char loop_beg, loop_end;
X
X    EXTERN char synofr[20],	/* from table */
X	synoto[20];		/* translate to table */
X
X    EXTERN char funkey,		/* leading char for function key */
X	funchar[50],	/* code sent by function key */
X	funcmd[50];	/* equivalent command */
X    EXTERN int addx,		/* amount to add to get x */
X	addy;			/* to get y */
X    EXTERN char cxychr;		/* true if convert xy bin to ascii */
X    EXTERN char cversn[12],	/* a version to identify config */
X	cxy1st,			/* l if line first, c if column 1st */
X	cxybeg[8],		/* start xy control seq */
X	cxymid[8],		/* middle xy control seq */
X	cxyend[8],		/* end sequence */
X	cerrbg[8],		/* string to print when errors start */
X	cerred[8],		/* when errors done */
X	ctopb[8],		/* top blanks = reverse linefeed */
X	cinit[20],		/* start up sequence */
X	cendit[20],		/* to end session */
X	cbotb[8],		/* bottom sequence */
X	celin[8],		/* erase to end of line */
X	cescr[8],		/* erase to end of screen */
X	cclears[8],		/* clear and home */
X	cdelchr[8],		/* delete character */
X	ccsrcm[8],		/* set cursor to command mode */
X	ccsrin[8],		/* set cursor to insert mode */
X	ciline[8],		/* insert a line */
X	ckline[8],		/* kill a line */
X	cundlb[8],		/* turn on underline */
X	cundle[8],		/* turn off underline */
X	cboldb[8],		/* start bold */
X	cbolde[8];		/* end bold */
X
X    EXTERN int dsp_mem,ddline,dscrl,dxcase,usecz,autoin,logdef;
X    EXTERN char delkey;
X
X    EXTERN int	tvlins,	/* number of lines on screen */
X		tvcols,	/* number of columns on screen */
X		tvhardlines,	/* real number of lines (for small window) */
X		tvx,	/* current x cursor position */
X		tvy,	/* current y cursor position */
X		tvdlin,	/* the "active" display line */
X		dsplin,	/* the default display line */
X		tabspc,	/* spacing for tabs */
X		leftmg,	/* left margin of display */
X		wraplm,	/* auto wrap? */
X		isibmpc; /* for possible use with a general version */
X
X    EXTERN char user_set[40],			/* wild matches */
X	use_wild;
X
X    EXTERN char old_cmds[16];
X    EXTERN int old_cindex;			/* cursor into old_cmds */
X    EXTERN int cut_mode;			/* kill line cuts */
X    EXTERN int escape_chr;			/* prefix char */
X
X    EXTERN char cfgname[40];
X
X    EXTERN int endpatch;	/* to get address of end of patch area */
X#endif
X
X
X    EXTERN int	bakpos,		/* used when building log file */
X		bakflg,		/* if writing to log file */
X		usebak,		/* if want to build a log file or not */
X		makebackup;	/* if want to retain backup .bak file */
X
X    EXTERN BUFFINDEX nxtsav,	/* top of save buffer */
X		curchr,		/* pointer to current character */
X		nxtchr,		/* ptr to buff of next new chr */
X		mxbuff,		/* maximum number of chars in buff */
X		*lines;		/* line ptrs */
X
X    EXTERN int 	curlin,		/* pointer to current line */
X		nxtlin,		/* ptr to lines of next new line */
X		mxline;		/* maximum number of lines */
X
X    EXTERN char *buff;		/* character and save buffer */
X
X#ifdef NOALLOC
X    EXTERN int myline[MAXLINE+1];	/* the real line buffer */
X    EXTERN char mybuff[MAXBUFF+1];	/* the real buffer */
X#endif
X
X    EXTERN int	oldlen,		/* length for '=' command */
X		savlin,		/* number of saved lines */
X		savlen;		/* line lenght of save buffer for rmvlst */
X
X    EXTERN int	oldlex,		/* last commands lexical value */
X		oldcol,		/* beginning column for dwncol */
X		echof,		/* whether or not to echo action */
X		xcases,		/* exact case flag */
X		scroll;		/* scroll window */
X
X    EXTERN int newfil;		/* YES if creating a new file */
X    EXTERN int rdonly;		/* YES if reading a file only */
X
X    EXTERN char orig_file[FNAMESIZE+1],	/* original file */
X		source_file[FNAMESIZE+1], /* where file really is */
X		work_file[FNAMESIZE+1],	/* current working output file */
X		dest_file[FNAMESIZE+1];	/* ultimate name for file */
X
X    EXTERN int	rptuse,		    /* which repeat buffer currently active */
X		rptcnt[REPEATBUFS],	/* number of repeats left to do */
X		nxtrpt[REPEATBUFS];	/* pointer to next repeat character */
X
X    EXTERN char rptbuf[REPEATBUFS][102]; /* up to 100 chars in repeat loop */
X    EXTERN char sbuff[102];		/* search buffer */
X    EXTERN char pat_buff[102];		/* save the pattern */
X
X/* other globals */
X#ifndef USEEXTERN
X    int slastl = 0;
X#else
X    extern int slastl;
X#endif
X
X    EXTERN char unkbuf[130];
X
X    EXTERN int useprint;	/* whether to print */
X    EXTERN int xoutcm;		/* used for 240 col virtual screen */
X    EXTERN int last_col_out;	/* last column output */
X    EXTERN int waserr;
X    EXTERN int blimit;		/* limit for read in buffer */
X    EXTERN int ttymode;		/* true if in tty mode */
X    EXTERN int ttynext;		/* cursor to next char from rdtty */
X    EXTERN int ins_mode;	/* true if insert mode */
X    EXTERN int force_tty;	/* for unix to force tty mode */
X
X
X    EXTERN FILE *infile, *outfile, *bkuin, *bkuout;
X    EXTERN int ineof;
X
X/* ---------------------------- GLOBALS ------------------------------- */
SHAR_EOF
echo ALL DONE!
exit 0

