From: talcott!seismo!gatech!unmvax!wampler (Bruce Wampler)
Subject: tvx: 3 of 10
Newsgroups: mod.sources
Approved: jpn@panda.UUCP

Mod.sources:  Volume 4, Issue 17
Submitted by: talcott!seismo!gatech!unmvax!wampler (Bruce Wampler)

#--------CUT---------CUT---------CUT---------CUT--------#
#########################################################
#  TVX: File 3 of 10                                    #
#                                                       #
# This is a shell archive file.  To extract files:      #
#                                                       #
#    1)	Make a directory (like tvx) for the files.      #
#    2) Write a file, such as "filen.shar", containing  #
#       this archive file into the directory.           #
#    3) Type "sh file.shar".  Do not use csh.           #
#                                                       #
#########################################################
#
#
echo Extracting Makefile:
sed 's/^X//' >Makefile <<\SHAR_EOF
X## Makefile for tvx
XDEST	      = .
X
XEXTHDRS	      = /usr/include/ctype.h \
X		/usr/include/sgtty.h \
X		/usr/include/stdio.h \
X		/usr/include/sys/ioctl.h \
X		/usr/include/sys/types.h \
X		/usr/include/sys/stat.h \
X		/usr/include/sys/ttychars.h \
X		/usr/include/sys/ttydev.h
X
XHDRS	      = tvx_glbl.ic\
X		tvx_defs.ic
X
XLDFLAGS	      =
X
XCFLAGS        = -O\
X		-DTVX_EM
X
XLIBS	      = /usr/lib/libtermcap.a
X
XLINKER	      = cc
X
XMAKEFILE      = Makefile
X
XOBJS	      = tvx_unix.o \
X		tvx_io.o \
X		tvx_lex.o \
X		tvx_1.o \
X		tvx_2.o \
X		tvx_edit.o \
X		tvx_lib.o
X
XPRINT	      = pr
X
XPROGRAM	      = tvx
X
XSRCS	      = tvx_unix.c \
X		tvx_io.c \
X		tvx_lex.c \
X		tvx_1.c \
X		tvx_2.c \
X		tvx_edit.c \
X		tvx_lib.c
X
Xall:		$(PROGRAM)
X
X$(PROGRAM):     $(OBJS) $(LIBS)
X		@echo -n "Loading $(PROGRAM) ... "
X		@$(LINKER) $(LDFLAGS) $(OBJS) $(LIBS) -o $(PROGRAM)
X		@echo "done"
X
Xclean:;		@rm -f $(OBJS)
X
Xdepend:;	@mkmf -f $(MAKEFILE) PROGRAM=$(PROGRAM) DEST=$(DEST)
X
Xindex:;		@ctags -wx $(HDRS) $(SRCS)
X
Xinstall:	$(PROGRAM)
X		@echo Installing $(PROGRAM) in $(DEST)
X		@install -s $(PROGRAM) $(DEST)
X
Xprint:;		@$(PRINT) $(HDRS) $(SRCS)
X
Xprogram:        $(PROGRAM)
X
Xtags:           $(HDRS) $(SRCS); @ctags $(HDRS) $(SRCS)
X
Xupdate:		$(DEST)/$(PROGRAM)
X
X$(DEST)/$(PROGRAM): $(SRCS) $(LIBS) $(HDRS) $(EXTHDRS)
X		@make -f $(MAKEFILE) DEST=$(DEST) install
X###
Xtvx_unix.o: /usr/include/ctype.h /usr/include/sys/ioctl.h \
X	/usr/include/sys/types.h /usr/include/sys/stat.h \
X	/usr/include/sys/ttychars.h /usr/include/sys/ttydev.h \
X	/usr/include/sgtty.h /usr/include/stdio.h tvx_defs.ic tvx_glbl.ic
Xtvx_io.o: /usr/include/stdio.h tvx_defs.ic tvx_glbl.ic
Xtvx_lex.o: /usr/include/stdio.h tvx_defs.ic tvx_glbl.ic
Xtvx_1.o: /usr/include/stdio.h tvx_defs.ic tvx_glbl.ic
Xtvx_2.o: /usr/include/stdio.h tvx_defs.ic tvx_glbl.ic
Xtvx_edit.o: /usr/include/stdio.h tvx_defs.ic tvx_glbl.ic
Xtvx_lib.o: /usr/include/stdio.h tvx_defs.ic
X
SHAR_EOF
echo Extracting Makefile.sysV:
sed 's/^X//' >Makefile.sysV <<\SHAR_EOF
X## Makefile for tvx on System V
XDEST	      = .
X
XEXTHDRS	      = /usr/include/ctype.h \
X		/usr/include/sgtty.h \
X		/usr/include/stdio.h \
X		/usr/include/sys/ioctl.h \
X		/usr/include/sys/types.h \
X		/usr/include/sys/stat.h
X
XHDRS	      = tvx_glbl.ic\
X		tvx_defs.ic
X
XLDFLAGS	      =
X
XCFLAGS        = -O\
X		-DTVX_EM
X
XLIBS	      = /usr/lib/libtermcap.a
X
XLINKER	      = cc
X
XMAKEFILE      = Makefile.sysV
X
XOBJS	      = tvx_unix.o \
X		tvx_io.o \
X		tvx_lex.o \
X		tvx_1.o \
X		tvx_2.o \
X		tvx_edit.o \
X		tvx_lib.o
X
XPRINT	      = pr
X
XPROGRAM	      = tvx
X
XSRCS	      = tvx_unix.c \
X		tvx_io.c \
X		tvx_lex.c \
X		tvx_1.c \
X		tvx_2.c \
X		tvx_edit.c \
X		tvx_lib.c
X
Xall:		$(PROGRAM)
X
X$(PROGRAM):     $(OBJS) $(LIBS)
X		@echo -n "Loading $(PROGRAM) ... "
X		@$(LINKER) $(LDFLAGS) $(OBJS) $(LIBS)
X 		@cp a.out $(PROGRAM)
X 		@rm a.out
X		@echo "done"
X
Xclean:;		@rm -f $(OBJS)
X
Xdepend:;	@mkmf -f $(MAKEFILE) PROGRAM=$(PROGRAM) DEST=$(DEST)
X
Xindex:;		@ctags -wx $(HDRS) $(SRCS)
X
Xinstall:	$(PROGRAM)
X		@echo Installing $(PROGRAM) in $(DEST)
X		@install -s $(PROGRAM) $(DEST)
X
Xprint:;		@$(PRINT) $(HDRS) $(SRCS)
X
Xprogram:        $(PROGRAM)
X
Xtags:           $(HDRS) $(SRCS); @ctags $(HDRS) $(SRCS)
X
Xupdate:		$(DEST)/$(PROGRAM)
X
X$(DEST)/$(PROGRAM): $(SRCS) $(LIBS) $(HDRS) $(EXTHDRS)
X		@make -f $(MAKEFILE) DEST=$(DEST) install
X###
Xtvx_unix.o: /usr/include/ctype.h /usr/include/sys/ioctl.h \
X	/usr/include/sys/types.h /usr/include/sys/stat.h \
X	/usr/include/sgtty.h /usr/include/stdio.h tvx_defs.ic tvx_glbl.ic
Xtvx_io.o: /usr/include/stdio.h tvx_defs.ic tvx_glbl.ic
Xtvx_lex.o: /usr/include/stdio.h tvx_defs.ic tvx_glbl.ic
Xtvx_1.o: /usr/include/stdio.h tvx_defs.ic tvx_glbl.ic
Xtvx_2.o: /usr/include/stdio.h tvx_defs.ic tvx_glbl.ic
Xtvx_edit.o: /usr/include/stdio.h tvx_defs.ic tvx_glbl.ic
Xtvx_lib.o: /usr/include/stdio.h tvx_defs.ic
X
SHAR_EOF
echo Extracting tvx_make.bat:
sed 's/^X//' >tvx_make.bat <<\SHAR_EOF
XREM This is the batch file needed to compile and link the basic TVX using
XREM Computer Innovations C-86 compiler.  If you have a different
XREM compiler, you will have to make your own batch file.
XREM     Once the basic TVX has been made, the other make batch files
XREM     should be used to compile the appropriate modules for
XREM	the other emulation versions if desired.
XREM	This batch file assumes stdio.h is in a directory called \c\.
XREM
Xcc1 tvx_1 -hc:\c\
Xcc2 tvx_1
Xcc3 tvx_1
Xcc4 tvx_1
Xcc1 tvx_2 -hc:\c\
Xcc2 tvx_2
Xcc3 tvx_2
Xcc4 tvx_2
Xcc1 tvx_edit -hc:\c\
Xcc2 tvx_edit
Xcc3 tvx_edit
Xcc4 tvx_edit
Xcc1 tvx_lex -hc:\c\
Xcc2 tvx_lex
Xcc3 tvx_lex
Xcc4 tvx_lex
Xcc1 tvx_io -hc:\c\
Xcc2 tvx_io
Xcc3 tvx_io
Xcc4 tvx_io
Xcc1 tvx_lib -hc:\c\
Xcc2 tvx_lib
Xcc3 tvx_lib
Xcc4 tvx_lib
XREM
XREM If you have in any way modified TVX_IBM.C, then it needs to be recompiled.
XREM
XREM cc1 tvx_ibm -hc:\c\
XREM cc2 tvx_ibm
XREM cc3 tvx_ibm
XREM cc4 tvx_ibm
XREM
XREM Otherwise, use the following hand optimized version.  Some of the expensive
XREM calls to sysint have been replaced with direct calls.  It is much faster
XREM than the C version, and is the only case I've ever found that this is true.
XREM
Xmasm tvx_ibm;
XREM
XREM	Now, link the thing into a file called TVX.EXE
XREM	It uses the CII small, DOS 2 library, which is called /c/cslib2
XREM	on my system.  You may need to replace the library with whatever
XREM	you call the corresponding library (like c86s2s.lib).
XREM
Xlink tvx_1+tvx_2+tvx_edit+tvx_lex+tvx_io+tvx_lib+tvx_ibm,tvx,nul:,/c/cslib2
XREM
XREM	Build the patch / configuration utilities
XREM
Xcc1 tvx_cfg -hc:\c\
Xcc2 tvx_cfg
Xcc3 tvx_cfg
Xcc4 tvx_cfg
Xlink tvx_cfg,tvx_cfg,nul:,/c/cslib2
Xcc1 tvx_ptch -hc:\c\
Xcc2 tvx_ptch
Xcc3 tvx_ptch
Xcc4 tvx_ptch
Xlink tvx_ptch,tvx_ptch,nul:,/c/cslib2
XREM
XREM	Build of tvx finished
XREM
SHAR_EOF
echo Extracting atari.info:
sed 's/^X//' >atari.info <<\SHAR_EOF
X#------------------------- ATARI SPECIAL FILES -------------------------
X    This file contains some extra files needed to compile and use
XTVX on the Atari 520st.  These files are included in this one file.
XYou will have to split it apart yourself.  The files assume you have
Xthe developers kit, and include:
X
X	HIRES.S - the assembly source of the 25/50 line screen interface
X        RES25PRG.S - assembly source of PROGRAM to change to 25 lines
X	RES50PRG.S - assembly source of PROGRAM to change to 50 lines
X		{ Just assemble and link/relmod these, no libraries needed }
X		These are needed because TVX allows you to switch to a 50
X		line display ('(' command), but doesn't force it back to
X		25 when it exits (maybe you want to stay in 50!).  Having
X		the programs allows you to switch back to 25 outside of
X		TVX.
X	STDIOTVX.H - fixed up version of stdio.h to avoid portab.h problems.
X	CTVX.BAT - Batch file to compile all modules of TVX. Assumes
X		the compiler is in A:, TVX source in B:, and the
X		batch file run from B: (e.g. {B}a:batch ctvx).
X		(If you build VIX or EMAX, you only need to recompile
X		 the TVX_EDIT and TVX_LEX modules, after changing the ifdefs)
X		Be patient, it takes over an hour to compile on floppies.
X	LINKTVX.BAT - file to link tvx.  Assumes .o's on B:, run from a:.
X
X#-------------------- cut here, save as HIRES.S -------------------------
X*  Make hi rez screen bios handle 25 lines of 8x16 characters
X*
X		.text
X		.globl _rez25
XLINEA_I		equ	$A000 
XGET_REZ		equ	4		; extended bios resolution inquiry
X_rez25: 
X	link	R14,#-4			; set up
X	move.w	#GET_REZ,-(sp)		; get screen resolution
X	trap	#14 
X	addq.w	#2,sp
X	cmp.w	#2,d0			; only execute if already in hi rez
X	bne	ex25f 
X	dc.w	LINEA_I			; get the important pointers 
X	move.l	08(a1),a1		; a1 -> 8x16 font header 
X	move.l	72(a1),-$0A(a0)		; v_off_ad <- 8x16 offset table ad
X	move.l	76(a1),-$16(a0)		; v_fnt_ad <- 8x16 font data addr 
X	move.w	#0016,-$2E(a0)		; v_cel_ht <- 16  8x16 cell heigh
X	move.w	#0024,-$2A(a0)		; v_cel_my <- 24  maximum cell "Y" 
X	move.w	#1280,-$28(a0)		; v_cel_wr <- 1280  vertical byte offset
X	move	#1,R0			; true return
X	bra	ex25
Xex25f:
X	move	#0,R0			; false return
Xex25:	unlk	R14			; prepare for return
X	rts
X*
X*  Make hi rez screen bios handle 50 lines of 8x8 characters
X*
X		.globl _rez50
X_rez50: 
X	link	R14,#-4			; set up
X	move.w	#GET_REZ,-(sp)		; get screen resolution
X	trap	#14 
X	addq.w	#2,sp
X	cmp.w	#2,d0			; only execute if already in hi rez
X	bne	ex50f 
X	dc.w	LINEA_I			; get the important pointers 
X	move.l	04(a1),a1		; a1 -> 8x8 font header 
X	move.l	72(a1),-$0A(a0)		; v_off_ad <- 8x8 offset table ad
X	move.l	76(a1),-$16(a0)		; v_fnt_ad <- 8x8 font data addr 
X	move.w	#008,-$2E(a0)		; v_cel_ht <- 8  8x8 cell heigh
X	move.w	#0049,-$2A(a0)		; v_cel_my <- 49  maximum cell "Y" 
X	move.w	#640,-$28(a0)		; v_cel_wr <- 640  vertical byte offset
X	move	#1,R0			; true return
X	bra	ex50
Xex50f:
X	move	#0,R0			; false return
Xex50:	unlk	R14			; prepare for return
X	rts
X	.data
X	end 
X#-------------------- cut here, save as RES25PRG.S -------------------------
X*
X*  Make hi rez screen bios handle 25 lines of 8x16 characters
X*
X*  Simply as68 this, then link it, no libraries needed
X		.text
X		.globl _hi25
XLINEA_I		equ     $A000 
XGET_REZ		equ     4       	; extended bios resolution inquiry
X_hi25: 
X	lea     stack,sp 
X	move.w  #GET_REZ,-(sp)  	; get screen resolution
X	trap    #14 
X	addq.w  #2,sp
X	cmp.w   #2,d0           	; only execute if already in hi rez
X	bne     exit 
X	dc.w    LINEA_I      	; get the important pointers 
X	move.l  08(a1),a1       	; a1 -> 8x16 font header 
X	move.l  72(a1),-$0A(a0) 	; v_off_ad <- 8x16 offset table ad
X	move.l  76(a1),-$16(a0) 	; v_fnt_ad <- 8x16 font data addr 
X	move.w  #0016,-$2E(a0)  	; v_cel_ht <- 16    8x16 cell heigh
X	move.w  #0024,-$2A(a0)  	; v_cel_my <- 24    maximum cell "Y" 
X	move.w  #1280,-$28(a0)  	; v_cel_wr <- 1280  vertical byte offset
Xexit:   clr.w   -(sp)           	; back to the os 
X	trap    #1 
X	ds.l    $10
Xstack:  ds.l    $01             	; hey chef, gimme a short stack
X	end 
X#-------------------- cut here, save as RES50PRG.S -------------------------
X*
X*  Make hi rez screen bios handle 25 lines of 8x16 characters
X*
X*  Simply as68 this, then link it, no libraries needed
X*
X		.text
X		.globl _hi50
XLINEA_I		equ     $A000 
XGET_REZ		equ     4       	; extended bios resolution inquiry
X_hi50: 
X	lea     stack,sp 
X	move.w  #GET_REZ,-(sp)  	; get screen resolution
X	trap    #14 
X	addq.w  #2,sp
X	cmp.w   #2,d0           	; only execute if already in hi rez
X	bne     exit 
X	dc.w    LINEA_I      	; get the important pointers 
X	move.l  04(a1),a1       	; a1 -> 8x8 font header 
X	move.l  72(a1),-$0A(a0) 	; v_off_ad <- 8x8 offset table ad
X	move.l  76(a1),-$16(a0) 	; v_fnt_ad <- 8x8 font data addr 
X	move.w  #008,-$2E(a0)		; v_cel_ht <- 8    8x8 cell heigh
X	move.w  #0049,-$2A(a0)  	; v_cel_my <- 49    maximum cell "Y" 
X	move.w  #640,-$28(a0)		; v_cel_wr <- 640  vertical byte offset
Xexit:   clr.w   -(sp)           	; back to the os 
X	trap    #1 
X	ds.l    $10
Xstack:  ds.l    $01             	; hey chef, gimme a short stack
X	end 
X#-------------------- cut here, save as STDIOTVX.H -------------------------
X/* stdio.h fixed to make it compatible with the rest of the world */
X
X#define mc68k 0
X
X#define TRUE 1
X#define FALSE 0
X
X#define	NULL	0
X#define NULLPTR (char *) 0
X#define	EOF	(-1)
X
X#define BUFSIZ	512
X#define MAXFILES	16
Xstruct _iobuf {	
X	int _fd;
X	int _flag;
X	char *_base;
X	char *_ptr;
X	int _cnt;
X};
X
X#ifndef FILE
Xextern struct _iobuf _iob[MAXFILES];
X#define FILE struct _iobuf
X#endif
X#define NULLFILE ((FILE *)0)
X
X#define _IOREAD	0x01
X#define _IOWRT	0x02
X#define _IOABUF	0x04
X#define _IONBUF	0x08
X#define _IOERR	0x10
X#define _IOEOF	0x20
X#define _IOLBUF 0x40
X#define _IOSTRI	0x80
X#define _IOASCI	0x100
X
X#define stdin  (&_iob[0])
X#define stdout (&_iob[1])
X#define stderr (&_iob[2])
X
X#define clearerr(p) ((p)->_flag &= ~_IOERR)
X#define feof(p) ((p)->_flag & _IOEOF)
X#define ferror(p) ((p)->_flag & _IOERR)
X#define fileno(p) ((p)->_fd)
X#define getchar() getc(stdin)
X#define putchar(c) putc(c,stdout)
X#define putc fputc
X#define getc fgetc
X
X
X#define	abs(x)	((x) < 0 ? -(x) : (x))
X
X#define MAX(x,y)   (((x) > (y)) ? (x) :  (y))
X#define	MIN(x,y)   (((x) < (y)) ? (x) :  (y))
X#define max(x,y)   (((x) > (y)) ? (x) :  (y))
X#define	min(x,y)   (((x) < (y)) ? (x) :  (y))
X
X/*************************** end of stdio.h *********************************/
X#-------------------- cut here, save as CTVX.BAT -------------------------
Xa:as68 -l -u -s a: b:hires.s
Xa:cp68 -p -I A: tvx_1.c tvx_1.i
Xa:c068 tvx_1.i tvx_1.1 tvx_1.2 tvx_1.3 -f
Xa:rm tvx_1.i
Xa:c168 tvx_1.1 tvx_1.2 tvx1.s
Xa:rm tvx_1.1
Xa:rm tvx_1.2
Xa:as68 -l -u -s a: b:tvx1.s
Xa:rm b:tvx1.s
Xa:cp68 -p -I A: tvx_2.c tvx_2.i
Xa:c068 tvx_2.i tvx_2.1 tvx_2.2 tvx_2.3 -f
Xa:rm tvx_2.i
Xa:c168 tvx_2.1 tvx_2.2 tvx2.s
Xa:rm tvx_2.1
Xa:rm tvx_2.2
Xa:as68 -l -u -s a: b:tvx2.s
Xa:rm b:tvx2.s
Xa:cp68 -p -I A: tvx_io.c tvx_io.i
Xa:c068 tvx_io.i tvx_io.1 tvx_io.2 tvx_io.3 -f
Xa:rm tvx_io.i
Xa:c168 tvx_io.1 tvx_io.2 tvxio.s
Xa:rm tvx_io.1
Xa:rm tvx_io.2
Xa:as68 -l -u -s a: b:tvxio.s
Xa:rm b:tvxio.s
Xa:cp68 -p -I A: tvx_lib.c tvx_lib.i
Xa:c068 tvx_lib.i tvx_lib.1 tvx_lib.2 tvx_lib.3 -f
Xa:rm tvx_lib.i
Xa:c168 tvx_lib.1 tvx_lib.2 tvxlib.s
Xa:rm tvx_lib.1
Xa:rm tvx_lib.2
Xa:as68 -l -u -s a: b:tvxlib.s
Xa:rm b:tvxlib.s
Xa:cp68 -p -I A: tvx_edit.c tvx_edit.i
Xa:c068 tvx_edit.i tvx_edit.1 tvx_edit.2 tvx_edit.3 -f
Xa:rm tvx_edit.i
Xa:c168 tvx_edit.1 tvx_edit.2 tvxedit.s
Xa:rm tvx_edit.1
Xa:rm tvx_edit.2
Xa:as68 -l -u -s a: b:tvxedit.s
Xa:rm b:tvxedit.s
Xa:cp68 -p -I A: tvx_lex.c tvx_lex.i
Xa:c068 tvx_lex.i tvx_lex.1 tvx_lex.2 tvx_lex.3 -f
Xa:rm tvx_lex.i
Xa:c168 tvx_lex.1 tvx_lex.2 tvxlex.s
Xa:rm tvx_lex.1
Xa:rm tvx_lex.2
Xa:as68 -l -u -s a: b:tvxlex.s
Xa:rm b:tvxlex.s
X#-------------------- cut here, save as LINKTVX.BAT -------------------------
Xlink68 [u] B:tvx.68k=gems,b:tvx1,b:tvx2,b:tvxedit,b:tvxlex,b:tvxio,b:tvxlib,b:hires,osbind,gemlib
Xrelmod b:tvx
Xrm b:tvx.68K
X#-------------------- END OF ATARI SPECIAL FILES -------------------------
X
SHAR_EOF
echo Extracting tvx_ibm.c:
sed 's/^X//' >tvx_ibm.c <<\SHAR_EOF
X/* ------------------------- tvx_ibm.c -------------------------- */
X/*
X	This is the interface to the PC's ROM BIOS.  It could
X	be bypassed by using the ANSI.SYS driver, but that would
X	be SLOW!  This version is cii-c86 dependent, mainly using
X	the routine sysint, for example:
X		  sysint(0x10, &rin, &rout);
X		int. number^     ^registers in and out
X	If possible, these calls should be replaced with direct
X	assembly language calls.  The overhead of sysint is high
X	and noticeably slows down screen update.
X*/
X
X#define FALSE 0
X#define TRUE 1
X/*	Interface to IBM ROM BIOS INT10 screen control.  Following
X	control codes are defined:
X
X	^@,0	^A,1	^B,2	^C,3
X	other, erslin, erseos, inslin
X	^D,4	^E,5	^F,6	^G,7
X	undlon, undloff, dellin, bell
X	^H,8	^I,9	^J,10	^K,11
X	backsp,	tab, linefeed, boldon
X	^L,12	^M,13	^N,14	^O,15
X	boldoff, enter, reversoff, blinkoff
X	^P,16	^Q,17	^R,18	^S,19, ^T,20
X	reverson, blinkon, setxy, cursor1, initcursor
X */
X#define m_normal 07	/* white on black */
X#define m_underline 01	/* normal, underlined */
X#define m_reverse 0x70
X#define m_dim 0xF7	/* dim display */
X#define m_bright 0x08	/* bright display */
X#define m_blink	0x80	/* blink for errors */
X#define m_noblink 0x7F
X
X
X/* ============================ dispch ============================== */
X  dispch(chin)
X  int chin;
X  {
X
X    static int ch;
X    struct regval
X      {
X	unsigned int ax;
X	unsigned int bx;
X	unsigned int cx;
X	unsigned int dx;
X	unsigned int si;
X	unsigned int di;
X	unsigned int ds;
X	unsigned int es;
X      };
X    struct regval rin, rout;
X
X	/* data structures for screen control */
X    static int ich;
X    static int maxcol = 79;		/*  max col, counting from 0 */
X    static int savechar;
X    static int initflg = FALSE;
X    static int curpage = 0;		/* current display page (internal) */
X    static int curmode = 7;		/* white on black */
X    static int curcol;			/* col and row, preserve this order */
X    static int currow;			/* so can load in one instruction */
X    static int curstate = 0;		/* 0: accepting chars
X					   1: waiting for row
X					   2: waiting for col */
X    static int rowpend = 0;		/* to save pending row */
X    static int initcursor;		/* initial cursor */
X    static int altcursor;
X    static int color;		/* mono or color */
X
X    ch = chin & 0xff;
X
X    if (!initflg)
X      {
X	rin.ax = 0x0F00;		/* ah is 15, get video state */
X	sysint(0x10, &rin, &rout);	/* int 10h */
X	maxcol = ((rout.ax >> 8) & 0xff) - 1;	/* make relative value (0-79) */
X  	curpage = (rout.bx >> 8) & 0xff;	/* the active page */
X	rin.ax = 0x0300;		/* read cursor position */
X	sysint(0x10, &rin, &rout);	/* int 10h */
X	curcol = rout.dx & 0xff;	/* low order is col */
X	currow = (rout.dx >> 8) & 0xff;
X	sysint(0x11,&rin,&rout);	/* get system configuration */
X	color = (rout.ax & 0x30) != 0x30;
X	if (!color)
X	  {
X	    initcursor = 0x0c0d;	/* 12, 13 - avoids PC ROM bug! */
X	    altcursor = 0x060d;		/* 6,13 for insert */
X	  }
X	else
X	  {
X	    initcursor = 0x0607;	/* current cursor mode, color */
X	    altcursor = 0x0307;		/* half block */
X	  }
X	initflg = TRUE;
X      }
X
X
X    if (curstate != 0)		/* waiting for row or col? */
X      {
X	if (curstate == 1)
X	  {
X		/* in state 1, so this is row */
X	    rowpend = ch;		/* save pending row */
X	    curstate = 2;		/* now in wait state */
X	    return;
X	  }
X	else		/* waiting for column */
X	  {
X	    ich = ch - ' ';	/* convert to absolute */
X	    if (ich > maxcol)
X		ich = maxcol;
X	    curcol = ich;	/* remember column */
X	    rowpend -= ' ';	/* convert row */
X	    if (rowpend > 24)
X		rowpend = 24;
X	    currow = rowpend;
X	    rin.dx = (currow << 8) | curcol;
X	    rin.bx = curpage << 8;
X	    rin.ax = 0x200;	/* 2 => set cursor */
X	    sysint(0x10, &rin, &rout);	/* int 10h */
X	    curstate = 0;
X	    return;
X	  }
X      }
X    else
X      {
X	if (ch >= ' ')
X	    goto SHOWCHAR;	/* slight optimization */
X
X	switch (ch)
X	  {
X	    case 1:		/* erase from cursor to end of line */
Xerslin:
X		rin.cx = rin.dx = currow << 8;		/* set row */
X		rin.cx |= curcol;		/* set col */
X		rin.dx |= maxcol;		/* blank to max col */
X		rin.ax = 0x600;	      /* scroll active page up, blank section */
X		rin.bx = curmode << 8;
X		sysint(0x10, &rin, &rout);	/* int 10h */
X		return;
X
X	    case 2:		/* erase from cursor to end of screen */
X		/* first, earase current row */
X		rin.cx = rin.dx = currow << 8;		/* set row */
X		rin.cx |= curcol;		/* set col */
X		rin.dx |= maxcol;		/* blank to max col */
X		rin.ax = 0x600;	      /* scroll active page up, blank section */
X		rin.bx = curmode << 8;
X		sysint(0x10, &rin, &rout);	/* int 10h */
X		if (currow >= 24)	/* on bottom row now? */
X		    return;
X		rin.cx = (currow + 1) << 8; 	/* next row, col 0 */
X		rin.dx = 0x1800 | maxcol;
X		rin.ax = 0x0600;		/* 6: scroll 0: blank */
X		sysint(0x10, &rin, &rout);	/* int 10h */
X		return;
X
X	    case 3:		/* insert a blank line at cursor */
X		if (currow < 24)
X		  {
X		    rin.cx = (currow << 8);
X		    rin.dx = 0x1800 | maxcol;	/* define window to scroll */
X		    rin.bx = curmode << 8;
X		    rin.ax = 0x0701;		/* one line, scroll down */
X		    sysint(0x10, &rin, &rout);	/* int 10h */
X		  }
X		curcol = 0;		/* home to line beginning */
X		rin.dx = currow << 8;	/* dh = currow, dl = 0 */
X		rin.bx = curpage << 8;
X		rin.ax = 0x0200;	/* reset cursor position */
X		sysint(0x10, &rin, &rout);	/* int 10h */
X		if (currow >= 24)	/* special case */
X		    goto erslin;
X		return;
X
X	    case 4:		/* underline on */
X		curmode = (curmode & 0x88) | m_underline;
X		return;
X
X	    case 5:		/* underline off */
X		curmode = (curmode & 0x88) | m_normal;
X		return;
X
X	    case 6:			/*  kill line cursor is on */
X		rin.cx = currow << 8;	/* define window to scroll */
X		rin.dx = 0x1800 | maxcol;
X		rin.ax = 0x0601;		/* one line (al), scroll up (6) */
X		rin.bx = curmode << 8;
X		sysint(0x10, &rin, &rout);	/* int 10h */
X		curcol = 0 ;		/* home to line beginning */
X		rin.dx = currow << 8;
X		rin.bx = curpage << 8;
X		rin.ax = 0x0200;
X		sysint(0x10, &rin, &rout);	/* int 10h */
X		return;
X
X	    case 7:		/* bell */
X		bdos(2,ch);
X		return;
X
X	    case 8:		/* backspace */
X		if (curcol <= 0)
X		    return;
X		--curcol;
X		rin.bx = curpage << 8;
X		rin.dx = (currow << 8) | curcol;
X		rin.ax = 0x0200;	/* set cursor pos */
X		sysint(0x10, &rin, &rout);	/* int 10h */
X		return;
X
X	    case 9:		/* tab */
X		ch = ' ';
X		goto SHOWCHAR;
X
X	    case 10:		/* line feed, scroll if bottom */
X		if (currow < 24)
X		  {
X		    rin.dx = (++currow << 8) | curcol;
X		    rin.bx = curpage << 8;
X		    rin.ax = 0x0200;		/* set cursor */
X		    sysint(0x10, &rin, &rout);	/* int 10h */
X		  }
X		else
X		  {
X			/* need to scroll up */
X		    rin.ax = 0x0601;	/* scroll up (6) 1 line (1) */
X		    rin.cx = 0;		/* upper right */
X		    rin.dx = 0x1800 | maxcol;
X		    rin.bx = curmode << 8;
X		    sysint(0x10, &rin, &rout);	/* int 10h */
X		  }
X		return;
X
X	    case 11:		/* bold on */
X		curmode |= m_bright;
X		return;
X
X	    case 12:		/* bold off */
X		curmode &= m_dim;
X		return;
X
X	    case 13:		/* CR, include erase end of line */
X		if (curcol >= maxcol)
X		    goto NOBLANK;
X		rin.cx = rin.dx = currow << 8;		/* set row */
X		rin.cx |= curcol;		/* set col */
X		rin.dx |= maxcol;		/* blank to max col */
X		rin.ax = 0x0600;	/* scroll up, blank section */
X		rin.bx = curmode << 8;
X		sysint(0x10, &rin, &rout);	/* int 10h */
XNOBLANK:
X		curcol = 0;
X	        rin.dx = (currow << 8);
X		rin.bx = curpage << 8;
X		rin.ax = 0x0200;
X		sysint(0x10, &rin, &rout);	/* int 10h */
X		return;
X
X	    case 14:		/* reverse off */
X		curmode = (curmode & 0x88) | m_normal ;
X		return;
X
X	    case 15:		/* blink off */
X		curmode &= m_noblink;
X		return;
X
X	    case 16:		/* reverse on */
X		curmode = (curmode & 0x88) | m_reverse;
X		return;
X
X	    case 17:		/* blink on */
X		curmode |= m_blink;
X		return;
X
X	    case 18:		/* set xy */
X		curstate = 1;
X		return;
X
X	    case 19:			/* change cursor */
X		rin.ax = 0x0100;	/* set cursor type */
X		rin.cx = altcursor;	/* half block */
X		sysint(0x10, &rin, &rout);
X		return;
X
X	    case 20:			/* change cursor */
X		rin.ax = 0x0100;	/* set cursor type */
X		rin.cx = initcursor;	/* original */
X		sysint(0x10, &rin, &rout);
X		return;
X
X
X	    default:		/* show char */
XSHOWCHAR:
X		if (curcol > maxcol)	/* update column */
X		    return;
X		rin.ax = 0x0900 | ch;		/* display char */
X		rin.bx = (curpage << 8) | curmode;
X		rin.cx = 1;
X		sysint(0x10, &rin, &rout);	/* int 10h */
X		++curcol;
X		rin.dx = (currow << 8) | curcol;
X		rin.ax = 0x0200;
X		sysint(0x10, &rin, &rout);	/* int 10h */
X		return;
X	  }	/* end of switch */
X      }		/* end of else */
X  }
SHAR_EOF
echo Extracting tvx_unix.c:
sed 's/^X//' >tvx_unix.c <<\SHAR_EOF
X/* -------------------------- tvx_unix.c ------------------------------ */
X#include "tvx_defs.ic"
X#include "tvx_glbl.ic"
X
X#ifdef SYSV
X#undef VQUIT			/* name conflict with sys V - irrelevant
X				name in tvx_unix.c */
X#include <termio.h>
X#endif
X
X#define TEMPEXT ".$$1"		/* temporary file */
X#define BACKEXT ".B"		/* backup file */
X#define SWITCH '-'
X#define FILESEP '.'
X
X/* define USETMP if you want intermediate workfiles built on
X   /tmp.  Otherwise, they will be built on the same directory as
X   the original file.  This latter method is often a bit faster,
X   especially when exiting if /tmp is on a different volume than
X   the destination file (which makes mv COPY the file rather than
X   just renameing. */
X
X/* #define USETMP */			/* define if create temp files on /tmp */
X
X#include <ctype.h>
X#include <sys/ioctl.h>
X#include <sys/types.h>
X
X#ifdef ULTRIX11
X#include <sgtty.h>
X#endif
X
X#ifdef SCR_BUF
Xchar *Scrbuf;                   /* Base address of screen buffer. */
Xchar *Scrptr;                   /* Dynamic screen buffer pointer. */
X#endif
X/* --------------  terminal I/O stuff --------------- */
X
X#ifdef SYSV
Xstatic struct termio sgb;
X#else
Xstatic struct sgttyb sgb;
Xstatic struct tchars tch;
Xstatic struct ltchars ltc;
X#endif
X
X#define Ioctl ioctl
X#define Read read
X#define Write write
X
X/* ------------- file mode stuff ---------------------- */
X#include <sys/stat.h>
X  static struct stat info;		/* structure to get info */
X
X/* ------------- misc stuff ---------------------- */
X
X  extern int errno;
X  extern char **environ;
X
X
X#ifdef TERMCAP			/* routines needed for termcap */
X/* ------------- termcap stuff ---------------------- */
X  char PC;
X  char *BC;
X  char *UP;
X  char TERM[40];
X  short ospeed;
X
X  static char Tcm[80];		/* special entry for cm */
X  static char empty[2];
X  static char Tbc[20];
X  static char Tup[20];
X
X  static int	Tco,			/* number of columns per line */
X		Tli;			/* number of lines */
X
X  static char tcbuff[1024];		/* buffer to hold termcap entry */
X 
X
X/* ==========================>>> gettermcap  <<<========================= */
X  gettermcap()
X  {
X    char *tp;
X    char *getenv();
X    char entry[80];		/* scratch buffer for entry */
X
X    empty[0] = 0;
X
X#ifdef SYSV
X    ospeed = sgb.c_cflag & CBAUD;
X#else
X    ospeed = sgb.sg_ospeed;	/* get the speed */
X#endif
X
X    if ((tp = getenv("TERM")) == NULL)
X      {
X	goto FORCETTY;
X      }
X    strcpy(TERM,tp);		/* copy to our TERM */
X
X    if (tgetent(tcbuff,TERM) < 1)
X      {
X	goto FORCETTY;
X      }
X
X/*	read required termcap entries, save in appropriate TVX arrays */
X
X    if (!gettcap("cm",Tcm))
X      {
X	goto FORCETTY;
X      }
X
X    if (!gettcap("ce",entry))
X      {
X	goto FORCETTY;
X      }
X    if (!capcpy(celin,entry,7))	/* copy entry to end of line */
X      {
X	goto FORCETTY;
X      }
X    
X    if (tgetflag("da"))
X	dsp_mem = TRUE;			/* display has memory */
X    else if (tgetflag("db"))
X	dsp_mem = TRUE;
X
X    gettcap("cd",entry);		/* clear to end of display */
X    capcpy(cescr,entry,7);
X
X    gettcap("al",entry);		/* insert a line (add line) */
X    capcpy(ciline,entry,7);
X
X    gettcap("dl",entry);	/* delete a line */
X    capcpy(ckline,entry,7);
X
X    if (!gettcap("sr",entry))	/* reverse scroll */
X      {
X	strcpy(ctopb,ciline);	/* add line works the same */
X      }
X    else
X	capcpy(ctopb,entry,7);
X
X    gettcap("dc",entry);		/* delete character */
X    capcpy(cdelchr,entry,7);
X    gettcap("cl",entry);		/* clear screen */
X    capcpy(cclears,entry,7);
X
X
X    gettcap("ve",entry);		/* stand cursor changer end */
X    capcpy(ccsrcm,entry,7);
X    gettcap("vs",entry);		/* stand cursor changer begin */
X    capcpy(ccsrin,entry,7);
X
X    gettcap("se",entry);		/* stand out end */
X    capcpy(cbolde,entry,7);
X
X    gettcap("so",entry);		/* begin standout */
X    capcpy(cboldb,entry,7);
X
X    cerred[0] = 7;				/* bell for sure */
X    gettcap("vb",entry);		/* visual bell? */
X    if (*entry)
X	capcpy(cerred,entry,7);
X
X    if (!capcpy(&cversn[1],TERM,10))		/* copy name to version */
X	strcpy(cversn,"TERMCAP");
X
X    if ((Tco = tgetnum("co")) < 0)	/* # of cols */
X	Tco = 79;		/* assume 80 x 24 */
X    if ((Tli = tgetnum("li")) < 0)	/* # of lines */
X	Tli = 24;		/* assume 80 x 24 */
X
X    tvhardlines = tvlins = Tli;	/* number of lines */
X    tvcols = Tco - 1; /* set col val (-1 avoids all the line wrap crap )*/
X    if (tvhardlines != 24 || tvhardlines != 25)	/* strange terminal */
X      {
X	ddline = (tvlins / 2) + 1;
X	setdscrl();		/* calculate scroll */
X      }
X
X    gettcap("bc",entry);		/* get backspace character */
X    if (!*entry)
X      {
X	Tbc[0] = 8; Tbc[1] = 0;
X      }
X    else
X	capcpy(Tbc,entry,19);
X    BC = Tbc;
X    gettcap("up",entry);		/* get backspace character */
X    if (!*entry)
X      {
X	Tup[0] = 0;
X      }
X    else
X	capcpy(Tup,entry,19);
X    UP = Tup;
X    gettcap("pc",entry);		/* get the pad character */
X    PC = *entry;
X
X#ifdef USE_TC_is
X    gettcap("is",entry);		/* initialization string */
X    tcapcs(entry);			/* send the intialization string */
X#endif
X
X    gettcap("ti",entry);		/* cm initialization string */
X    tcapcs(entry);			/* send the intialization string */
X
X    return;
X
XFORCETTY:
X   reset();
X   remark("");
X   remark("Unable to set up for video terminal, try again with -t switch.");
X   exit(999);
X  }
X
X/* =============================>>> capcpy  <<<============================= */
X  capcpy(to,from,len)
X  char *to, *from;
X  int len;
X  {		/* copy a capability, checking length */
X    if (strlen(from) > len)
X      {
X	*to = 0;
X	return (FALSE);
X      }
X    else
X	strcpy(to,from);
X    return (TRUE);
X  }
X
X/* =============================>>> gettcap  <<<============================= */
X  gettcap(cap,area)
X  char *cap, *area;
X  {
X    char **cpp, *cp;
X
X    cpp = &cp;		/* I think */
X    cp = area;
X    *area = 0;		/* assume null entry */
X
X    tgetstr(cap,cpp);	/* get the capability */
X    return (*area);		/* return 1st char */
X	
X  }
X
X/* =============================>>> tcapcs  <<<============================= */
X  tcapcs(str)
X  char *str;
X  {
X 	/* send a termcap generated control string to terminal */
X
X    register char *cp;
X    int ttwt();
X
X    if (!(echof && !bakflg && !ttymode))
X	return;
X    if (!*str)		/* don't send null strings */
X	return;
X    cp = str;
X    tputs(cp,1,ttwt);
X
X  }
X
X/* =============================>>> tcapxy  <<<============================= */
X  tcapxy(x,y)
X  int x,y;
X  {
X	/* move cursor to x,y */
X
X   char *tgoto();
X
X   tcapcs(tgoto(Tcm,x-1,y-1));	/* send the string, adjusting x,y */
X
X  }
X#endif   /* termcap */
X
X
X/* =============================>>> ttinit  <<<============================= */
X  ttinit()
X  {
X#ifdef SYSV
X    struct termio nsgb;
X#else
X    struct sgttyb nsgb;
X    struct tchars ntch;
X    struct ltchars nltc;
X#endif
X
X#ifdef SCR_BUF
X    char *malloc();
X
X    /* malloc the screen buffer */
X    if ((Scrbuf = malloc(S_BUFSIZE)) == NULL)
X      {
X	reset();
X	remark("");
X	remark("tvx: cannot allocate screen buffer, aborting");
X	exit(999);
X      }
X    Scrptr = Scrbuf;
X#endif
X
X#ifdef SYSV
X    (void) Ioctl(0, TCGETA, &sgb);
X    (void) Ioctl(0, TCGETA, &nsgb);
X#else
X    (void) Ioctl(0, TIOCGETP, &sgb);
X    (void) Ioctl(0, TIOCGETP, &nsgb);
X    (void) Ioctl(0, TIOCGETC, &tch);
X    (void) Ioctl(0, TIOCGETC, &ntch);
X    (void) Ioctl(0, TIOCGLTC, &ltc);
X#endif
X
X#ifdef SYSV
X    nsgb.c_lflag &= ~(ECHO | ICANON);
X    nsgb.c_iflag &= ~(ICRNL | IXOFF);
X#else
X    nsgb.sg_flags |= CBREAK;
X    nsgb.sg_flags &= ~(CRMOD|ECHO|LCASE|TANDEM);
X#endif
X
X#ifdef SYSV
X    nsgb.c_cc[VMIN] = 1;	/* minimum characters */
X    nsgb.c_cc[VTIME] = -1;	/* time before read returns */
X#else
X    ntch.t_intrc = -1;  /* interrupt */
X    ntch.t_quitc = -1;  /* quit */
X    ntch.t_eofc = -1;   /* end-of-file */
X    ntch.t_brkc = -1;   /* input delimiter (like nl) */
X#endif
X
X/* the following two lines control flow control */
X
X#ifndef FLOWCONTROL
X#ifdef SYSV
X    nsgb.c_iflag &= ~(IXON | IXOFF);
X#else
X    ntch.t_startc = -1; /* start output */
X    ntch.t_stopc = -1;  /* stop output */
X#endif
X#endif
X
X#ifndef SYSV
X    nltc.t_suspc = -1;  /* stop process signal */
X    nltc.t_dsuspc = -1; /* delayed stop process signal */
X    nltc.t_rprntc = -1; /* reprint line */
X    nltc.t_flushc = -1; /* flush output (toggles) */
X    nltc.t_werasc = -1; /* word erase */
X    nltc.t_lnextc = -1; /* literal next character */
X#endif
X
X#ifdef SYSV
X    (void) Ioctl(0, TCSETA, &nsgb);
X#else
X    (void) Ioctl(0, TIOCSETP, &nsgb);
X    (void) Ioctl(0, TIOCSETC, &ntch);
X    (void) Ioctl(0, TIOCSLTC, &nltc);
X#endif
X
X#ifdef TERMCAP
X    gettermcap();			/* set up terminal characteristics */
X#endif
X
X    info.st_mode = -1;			/* no mode stuff yet */
X }
X
X
X#ifdef SCR_BUF
X/* =============================>>> ttflush  <<<============================= */
X  ttflush()
X  {
X    if (Scrptr != Scrbuf)
X	write(1, Scrbuf, Scrptr - Scrbuf);
X    Scrptr = Scrbuf;
X  }
X#endif
X
X/* =============================>>> ttrd_unix  <<<============================= */
X  ttrd_unix()
X  {
X           char c;
X
X    Read(0, &c, 1);
X    return(c);
X  }
X
X/* =============================>>> ttwtln  <<<============================= */
X  ttwtln(cbuf,cnt)
X  char *cbuf;
X  int cnt;
X  {
X#ifndef SCR_BUF
X    if (echof && !bakflg && !ttymode)
X	Write(1, cbuf, cnt);
X#else
X    if (echof && !bakflg && !ttymode)
X      {
X	while(cnt-- > 0)
X	  {
X            if (Scrptr < Scrbuf + S_BUFSIZE)
X                *Scrptr++ = *cbuf++;
X            else
X	      {
X                ttflush();
X                *Scrptr++ = *cbuf++;
X	      }
X	  }
X      }
X#endif
X  }
X
X/* =============================>>> ttwt  <<<============================= */
X  ttwt(c)
X  char c;
X  {
X    if (ttymode)
X	return;
X#ifndef SCR_BUF
X    Write(1, &c, 1);
X#else
X    if (Scrptr < Scrbuf + S_BUFSIZE)
X        *Scrptr++ = c;
X    else
X      {
X        ttflush();
X        *Scrptr++ = c;
X      }
X#endif
X  }
X
X/* =============================>>> ttclos  <<<============================= */
X  ttclos()
X  {
X
X#ifdef TERMCAP
X    char entry[80];
X
X    gettcap("te",entry);		/* cm end up string */
X    tcapcs(entry);			/* send it */
X#endif
X
X#ifdef SYSV
X    (void) Ioctl(0, TCSETA, &sgb);
X#else
X    (void) Ioctl(0, TIOCSETP, &sgb);
X    (void) Ioctl(0, TIOCSETC, &tch);
X    (void) Ioctl(0, TIOCSLTC, &ltc);
X#endif
X  }
X
X/* =============================>>> ttosinit  <<<============================= */
X  ttosinit()
X  {			/* need a special version for not doing termcap */
X#ifdef SYSV
X    struct termio nsgb;
X#else
X    struct sgttyb nsgb;
X    struct tchars ntch;
X    struct ltchars nltc;
X#endif
X
X    char entry[80];		/* scratch buffer for entry */
X
X#ifdef SYSV
X    (void) Ioctl(0, TCGETA, &sgb);
X    (void) Ioctl(0, TCGETA, &nsgb);
X#else
X    (void) Ioctl(0, TIOCGETP, &sgb);
X    (void) Ioctl(0, TIOCGETP, &nsgb);
X    (void) Ioctl(0, TIOCGETC, &tch);
X    (void) Ioctl(0, TIOCGETC, &ntch);
X    (void) Ioctl(0, TIOCGLTC, &ltc);
X#endif
X
X#ifdef SYSV
X    nsgb.c_lflag &= ~(ECHO | ICANON);
X    nsgb.c_iflag &= ~(ICRNL | IXOFF);
X#else
X    nsgb.sg_flags |= CBREAK;
X    nsgb.sg_flags &= ~(CRMOD|ECHO|LCASE|TANDEM);
X#endif
X
X#ifdef SYSV
X    nsgb.c_cc[VMIN] = 1;	/* minimum characters */
X    nsgb.c_cc[VTIME] = -1;	/* time before read returns */
X#else
X    ntch.t_intrc = -1;  /* interrupt */
X    ntch.t_quitc = -1;  /* quit */
X    ntch.t_eofc = -1;   /* end-of-file */
X    ntch.t_brkc = -1;   /* input delimiter (like nl) */
X#endif
X
X/* the following two lines control flow control */
X
X#ifndef FLOWCONTROL
X#ifdef SYSV
X    nsgb.c_iflag &= ~(IXON | IXOFF);
X#else
X    ntch.t_startc = -1; /* start output */
X    ntch.t_stopc = -1;  /* stop output */
X#endif
X#endif
X
X#ifndef SYSV
X    nltc.t_suspc = -1;  /* stop process signal */
X    nltc.t_dsuspc = -1; /* delayed stop process signal */
X    nltc.t_rprntc = -1; /* reprint line */
X    nltc.t_flushc = -1; /* flush output (toggles) */
X    nltc.t_werasc = -1; /* word erase */
X    nltc.t_lnextc = -1; /* literal next character */
X#endif
X
X#ifdef SYSV
X    (void) Ioctl(0, TCSETA, &nsgb);
X#else
X    (void) Ioctl(0, TIOCSETP, &nsgb);
X    (void) Ioctl(0, TIOCSETC, &ntch);
X    (void) Ioctl(0, TIOCSLTC, &nltc);
X#endif
X
X#ifdef TERMCAP
X#ifdef USE_TC_is
X    gettcap("is",entry);		/* initialization string */
X    tcapcs(entry);			/* send the intialization string */
X#endif
X
X    gettcap("ti",entry);		/* cm initialization string */
X    tcapcs(entry);			/* send the intialization string */
X#endif
X }
X
X/* ==========================>>> unix_sys  <<<============================= */
X  unix_sys()
X  {
X    char rp[150];
X    int oldtty;
X
X    tvclr();			/* clear the screen */
X    oldtty = ttymode; ttymode = FALSE;
XDO_UNIX:
X    remark("Unix command interface"); remark("");
X    remark("Enter Unix command line: ");
X    reply(rp,149);
X    reset();		/* reset terminal to unix mode */
X
X    system(rp);
X
X    ttosinit();		/* reset terinal to our mode */
X
X    remark("");
X    remark("");
X
X    prompt("Any key to continue with edit (! for another Unix command): ");
X    reply(rp,1);
X
X    trmini();		/* this has to be here or screen is cleared! */
X    if (*rp == '!')
X	goto DO_UNIX;
X
X    ttymode = oldtty;
X    verify(1);
X  }
X
X/* =============================>>> get_mode <<<============================= */
X  get_mode(f)
X  FILE *f;
X  {		/* gets access mode of open file f */
X
X    char rp[10];
X
X    info.st_mode = -1;	/* assume no mode */
X
X    if (newfil)
X	return;
X    if (fstat(fileno(f),&info) != 0)
X      {
X	info.st_mode = -1;	/* assume no mode */
X	return;
X      }
X    info.st_mode &= 07777;	/* zap extraneous stuff*/
X    if (((info.st_mode & 0222) == 0) || rdonly)	/* no write permission */
X      {
X	prompt("No write permission for file, edit R/O? (y/n) ");
X	ureply(rp,1);
X	if (*rp == 'Y')
X	    rdonly = TRUE;
X	else
X	  {
X	    reset();
X	    exit(999);
X	  }
X      }
X  }
X
X/* =============================>>> set_mode <<<============================= */
X  set_mode(f)
X  FILE *f;
X  {		/* sets access mode of open file f */
X#ifdef SYSV
X    if (newfil)
X	return;
X    else
X	tverrb("Unable to set file mode, umask will be used.");
X    return;	/* The person doing the port to System V removed the
X	fchmod code.  It may not apply to System V, but was needed on
X	the BSD version to keep executable shell scripts executable.
X	(among other things - that is the most obvious reason)
X	Maybe someone knows if this is needed on System V.  BEW 2/11/86 */
X#else
X    if (newfil || info.st_mode == -1)
X	return;
X#ifndef ULTRIX11
X    if (fchmod(fileno(f),info.st_mode) != 0)
X#endif
X	tverrb("Unable to set file mode, umask will be used.");
X#endif
X  }
X
X/* ==========================>>> expand_name <<<============================ */
X  expand_name(n)
X  char *n;
X  {		/* expands unix file names */
X    char tmp[FNAMESIZE+1];
X
X    if ((*n == '~') && (n[1] == '/'))
X      {
X	strcpy(tmp,getenv("HOME"));
X	scopy(n,1,tmp,strlen(tmp));
X	strcpy(n,tmp);
X      }
X  }
X
X/* =============================>>> ren_file <<<=========================== */
X  ren_file(old,new)
X  char *old, *new;
X  {
X    int pid;
X    static char *mvarg[4];
X    static int status;
X
X    if (rename(old,new) != 0)
X      {
X	mvarg[0] = "/bin/mv";
X	mvarg[1] = old;
X	mvarg[2] = new;
X	mvarg[3]=0;
X	pid=fork();
X	if (pid == 0)
X	  {
X	    execve("/bin/mv",mvarg,environ);
X            tverrb("Error trying to start mv utility");
X	    _exit(999);
X	  }
X	wait(&status);
X	if (status > 255)		/* error return */
X	  {
X	    prompt(old) ; prompt(" not renamed to "); remark(new);
X	    prompt("Edited file found as: "); remark(old);
X	  }
X      }
X  }
X
X/* =============================>>> temp_name <<<=========================== */
X  temp_name(n,first)
X  char *n;
X  int first;
X  {
X	/* generates a temporary name from n.  Depending on value of
X	   first, it will either add a 1 or 2 to name */
X    SLOW int i;
X
X#ifdef USETMP
X    SLOW char pidno[20];
X    long pidint;
X
X    if (first)			/* create full temp name */
X      {
X	*n = 0;
X	pidint=getpid();
X	itoa(pidint,pidno);
X	strcpy(n,"/tmp/tvx1");
X	scopy(pidno,0,n,9);
X      }
X    else			/* alternate between 1 and 2 */
X      {
X	if (n[8] == '1')
X	    n[8] = '2';
X	else
X	    n[8] = '1';
X      }
X#else
X    if (first)
X      {
X	if ((i = rindx(n,FILESEP)) > 0)	/* see if extenstion */
X	    scopy(TEMPEXT,0,n,i);		/* make .bak */
X	else
X	  {
X	    scopy(TEMPEXT,0,n,strlen(n));	/* just add on */
X	  }
X      }
X    else
X      {
X	i = strlen(n);
X	if (n[i-1] == '1')
X	    n[i-1] = '2';
X	else
X	    n[i-1] = '1';
X      }
X#endif
X  }
X
X#ifndef SUN
X/* =============================>>> USER_1 <<<============================= */
X  user_1(knt)
X  int knt;
X  {
X    knt = 0;
X    return (TRUE);
X  }
X
X#else
X/* =============================>>> USER_1 <<<============================= */
X  user_1(knt)
X  int knt;
X  {
X	/* for suns, re-initialize window */
X#ifdef TERMCAP
X    gettermcap();		/* set up terminal characteristics */
X    tvidefs();		/* and reset defs */
X#endif
X    verify(1);
X    return (TRUE);
X  }
X#endif
X
X/* =============================>>> USER_2 <<<============================= */
X  user_2(knt)
X  int knt;
X  {
X    knt = 0;
X    return (TRUE);
X  }
X
X#ifdef SYSV
X/* ============================>>> RENAME <<<============================ */
X  rename(from, to)
X  char *from, *to;
X  {
X    if (access(from, 00) != 0 || access(to, 02) != 0)
X	return(-1);
X    unlink(to);
X    return(link(from, to));
X  }
X#endif
X#ifdef PRO350
X/* =============================>>> rename <<<============================= */
X  rename(old, new)
X  char *old;
X  char *new;
X  {
X    int res;
X
X    if ((res = link(old, new)) < 0)
X	return (res);
X    else
X	unlink(old);
X    return (0);
X  }
X#endif
X/* -------------------------- tvx_unix.c ------------------------------ */
SHAR_EOF
echo ALL DONE!
exit 0

