From: talcott!seismo!gatech!unmvax!wampler (Bruce Wampler)
Subject: tvx 5 of 10
Newsgroups: mod.sources
Approved: jpn@panda.UUCP

Mod.sources:  Volume 4, Issue 19
Submitted by: gatech!unmvax!wampler (Bruce Wampler)

#--------CUT---------CUT---------CUT---------CUT--------#
#########################################################
#                                                       #
# This is a shell archive file.  To extract files:      #
#                                                       #
#    1)	Make a directory (like tvx) for the files.      #
#    2) Write a file, such as "filen.shar", containing  #
#       this archive file into the directory.           #
#    3) Type "sh file.shar".  Do not use csh.           #
#                                                       #
#########################################################
#
#
echo Extracting tvx_2.c:
sed 's/^X//' >tvx_2.c <<\SHAR_EOF
X/* ========================================================================
X
X	tvx_2.c - Part 2 of main TVX code 
X
X============================================================================ */
X
X#include "tvx_defs.ic"		/* note tv_defs will #include stdio.h */
X#include "tvx_glbl.ic"
X
X/* =============================>>> KILLIN <<<============================= */
X  killin(cnt)
X  int cnt;
X  { /* ##  killin - kill cnt lines */
X
X    SLOW int i,lim;
X    SLOW int from,to,ityp,istrt;
X    SLOW int s_curlin, s_curchr, s_echo;
X
X    if (cut_mode)		/* does kill "cut" */
X      {
X	s_echo = echof;
X	echof = FALSE;		/* turn off echo */
X	s_curlin = curlin;	/* save line */
X	save(cnt,FALSE);	/* save those lines */
X	curlin = s_curlin;
X	echof = s_echo;		/* restore things */
X      }
X
X    if (cnt+curlin >= nxtlin || (curlin == nxtlin-1 && cnt >= 0))
X      { 			/* special case: deleting rest of buffer */
X	svklin(nxtlin-1);
X	for (i = curlin ; i <= nxtlin-1 ; )
X	    kline(*(lines+i++));
X	nxtlin = curlin--;
X	if (curlin > 0)
X	  {
X	    curchr = *(lines+curlin)+1;
X	    newscr();
X	  }
X	else
X	  {
X	    curchr = 0;
X	    tvclr();
X	  }
X#ifdef SCR_BUF
X	ttflush();
X#endif
X	return;
X      }
X
X    if (cnt < 0)		/* negative kill */
X      {
X	cnt = min(-cnt,curlin-1);	/* all upwards? */
X	dwnlin(-cnt);		/* go up that far */
X      }
X
X    if (cnt != 0)
X      {
X	range(cnt,&to,&from);	/* calculate the line numbers to kill */
X
X	curlin=to;		/* remember new current line */
X
X	svklin(from);	/* save one line */
X	for (i = to ; i <= from ; )		/* mark lines deleted */
X	    kline(*(lines+i++));
X
X	lim = min(nxtlin-1,mxline);
X	for (++from ; from <= lim ; )
X	  {
X	    *(lines+to++) = *(lines+from++);	/* copy next line number */
X	  }
X
X	nxtlin=to;
X	if (nxtlin == curlin)
X	    --curlin;		/* don't go past end */
X	curchr = *(lines+curlin)+1;	/* remember new current character */
X
X	if (cnt >= 0 && curlin+(tvlins-tvdlin) < nxtlin &&
X	  tvdlin < tvlins)	/* killing down */
X	  {
X	    tvxy(1,tvy);	/* get to start of line */
X	    ityp=min(tvlins-tvdlin+1,nxtlin-curlin);
X	    if (cnt!=1 || !ckline[0])
X	      {
X		tvescr();	/* erase the screen */
X		istrt=curlin;
X	      }
X	    else
X	      {
X		sendcs(ckline);
X		istrt=curlin+ityp-1;
X		tvxy(1,tvlins);
X		ityp=1;
X	      }
X	    tvtype(istrt,ityp);
X	    tvhdln();	/* home to display line */
X	  }
X	else if ( cnt != 1)	/* neg and > 1 too complicated */
X	    newscr();			/* kill up, just retype whole screen */
X	else if (nxtlin < tvlins)	/* top part of screen */
X	  {
X	    if (*ckline)		/* kill line defined */
X	      {
X		tvxy(1,tvy);		/* get to start of line */
X		sendcs(ckline);		/* just need to kill the line */
X		tvhdln();
X	      }
X	    else
X		newscr();		/* rewrite it all */
X	  }
X	else if (tvdlin < tvlins)	/* must be in last part of buffer */
X	  {
X	    if (*ckline && *ctopb)	/* kill line & topb defined */
X	      {
X		tvxy(1,tvy);		/* get to start of line */
X		sendcs(ckline);		/* kill the line */
X		if (curlin-tvdlin > 0)	/* something to scroll */
X		  {
X		    tvtopb(1);		/* scroll down one line */
X		    tvtype(curlin-tvdlin,1);	/* type the offscreen line */
X		    tvdlin++;		/* will start display on next line */
X		  }
X		tvhdln();
X	      }
X	    else
X		newscr();		/* rewrite it all */
X	  }
X	else		/* if all else fails */
X	    newscr();
X      }
X#ifdef SCR_BUF
X    ttflush();
X#endif
X  }
X
X/* =============================>>> KLINE  <<<============================= */
X  kline(ptr)
X  BUFFINDEX ptr;
X  {  /* kline - kill off the line beginning at buff position ptr */
X
X    SLOW BUFFINDEX i;
X
X    for (i=ptr; *(buff+i) != ENDLINE ; )	/* insert GARBAGE to kill */
X	*(buff+i++) = GARBAGE;
X
X    *(buff+i) = GARBAGE;		/* kill the endline */
X  }
X
X/* =============================>>> KPREV  <<<============================= */
X  kprev()
X  { /* kprev - kill from cursor to beginning of line */
X
X    FAST int chrs;
X
X    svklin(curlin);				/* save one line */
X    chrs = curchr - *(lines+curlin) - 1;	/* how much to delete */
X    if (chrs > 0)
X	delnxt(-chrs);	/* won't cause a combine, so don't worry */
X  }
X
X/* =============================>>> KREST  <<<============================= */
X  krest()
X  { /* krest - kill the rest of the line, not including cursor and ENDLINE */
X
X    SLOW int chrs;
X    SLOW BUFFINDEX i;
X
X    svklin(curlin);	/* save one line */
X    chrs=0;
X    for (i=curchr; *(buff+i)!=ENDLINE; ++i)
X	++chrs; 	/* count how much to delete */
X    if (chrs > 0)
X	delnxt(chrs);	/* won't cause combine, so don't worry */
X  }
X
X/* =============================>>> NEATEN <<<============================= */
X  int neaten(count)
X  int count;
X  {  /* neaten - fill lines to current margin */
X
X    SLOW int oldef, i;
X    SLOW BUFFINDEX linbeg;
X    SLOW int retval;
X
X    retval = TRUE;
X    oldef = echof;
X    if (count > 1)
X	echof = FALSE;
X    if (wraplm <= 1 || curlin >= nxtlin-1)
X	goto l900;		/* work only if wrap limit turned on */
X
X    for (i=1 ; i<=count ; ++i)
X      {
X	beglin();		/* start at beginning of line */
X	if (curlin >= nxtlin-1)
X	    goto l900;
X
X	/* don't neaten leading space, cr, period or tab */
X
X	if (*(buff+curchr) == '.')
X	  {
X	    dwnlin(1);
X	    continue;		/* skip dot commands */
X	  }
X
X	while (*(buff+curchr)== ' ' || *(buff+curchr)==ENDLINE
X	  || *(buff+curchr) == 9)
X	  {
X	    right(1);	/* skip this line */
X	  }
X
X	do
X	  {
X	    if (*(buff+curchr) == ENDLINE)
X	      {
X		if (tvx+leftmg < wraplm)	/* combine lines! */
X		  {
X		    linbeg = *(lines+curlin+1)+1;
X			/* pt to first char of next line */
X		    if (*(buff+linbeg) == ' ' || *(buff+linbeg) == ENDLINE
X		      || *(buff+linbeg) == 9 || *(buff+linbeg) == '.')
X		      {
X			dwnlin(1);
X			break;	/* no more combining */
X		      }
X		    if (! neat1(1,32))
X			goto l990;
X		    goto NEATNEXT;	/* tab over another word */
X		  }
X		else
X		  {
X		    dwnlin(1);	/* no more combining on line */
X		    break;
X		  }
X	      }
X
XNEATNEXT:
X	    if (*(buff+curchr-1)==' ' && tvx+leftmg >= wraplm)	/* change to cr */
X	      {
X		if (! neat1(-1,CR))	/* delete the blank */
X		    goto l990;
X		break;
X	      }
X	    wordr(1);
X	  } /*# end of the repeat */
X	while (1);
X      } /*# end of the for	 */
Xl900:
X    echof = oldef;
X    if (oldef && count > 1)
X	newscr();
X#ifdef SCR_BUF
X    else
X	ttflush();
X#endif
X
X    return (retval);
X
Xl990:				/* failure return */
X    retval = FALSE;
X    goto l900;
X  }
X
X/* =============================>>> NEAT1  <<<============================= */
X  neat1(dir, val)
X  int dir, val;
X  {  /* change character dir to val */
X
X    SLOW int oldwrp;
X
X    oldwrp = wraplm;
X    wraplm = 0;
X    if (! delnxt(dir))
X	goto l900;
X    if (! ins_chr(val))
X	goto l900;
X    wraplm = oldwrp;
X    return (TRUE);
Xl900:
X    wraplm = oldwrp;
X    return (FALSE);
X  }
X
X/* =============================>>> NEWSCR <<<============================= */
X  newscr()
X  { /* newscr - retype entire screen, updating cursor position if necessary */
X
X   SLOW int ibeg,cnt;
X
X    if (tvlins != tvhardlines || nxtlin-1 <= tvlins)
X	/* two kinds of screen rewrite */
X	tvclr();			/* clear the screen and home */
X    else
X	tvxy(1,1);
X
X    finddl(&ibeg,&cnt); 	/* calculate where it will go */
X    tvtype(ibeg,cnt);		/* type it out */
X    tvhdln();			/* home to display line */
X#ifdef SCR_BUF
X    ttflush();
X#endif
X  }
X
X/* =============================>>> OPENLN <<<============================= */
X  openln(cnt)
X  int cnt;
X  {  /* openln - open a new line */
X
X    FAST int i;
X    SLOW int pcnt, oldauto;
X
X    oldauto = autoin; autoin = FALSE;	/* don't allow autoindent */
X    pcnt = cnt >= 0 ? cnt : (-cnt);	/* only allow positive opens */
X    for (i=1; i<=pcnt; ++i)
X	ins_chr(CR);	/* insert right number of newlines */
X    dwnlin(-pcnt);	/* and goto beginning of the opened line */
X    endlin();
X    autoin = oldauto;
X#ifdef SCR_BUF
X    ttflush();
X#endif
X  }
X
X/* =============================>>> RANGE  <<<============================= */
X  range(cnt,lbeg,lend)
X  int cnt,*lbeg,*lend;
X  { /* determine a legal line number range given cnt */
X
X    if (cnt <= 0)
X      {
X	*lbeg=max(curlin+cnt,1);
X	*lend=curlin;
X	if (cnt < 0)
X	   *lend = (*lend)-1;
X      }
X    else
X      {
X	*lbeg=curlin;
X	*lend=min(nxtlin-1,curlin+cnt-1);
X      }
X }
X
X/* =============================>>> RIGHT  <<<============================= */
X  right(cnt)
X  int cnt;
X  {  /* move cursor right cnt characters
X	newlines count as one character */
X
X    FAST int change,i;
X
X    change=0;			/* nochange yet */
X    if (cnt > 0)
X      {
X	for (i = 1 ; i <= cnt ; ++i)
X	  {
X	    if (*(buff+curchr)==ENDLINE)
X	      {
X		if (curlin+1 >= nxtlin)
X		    break;		/* don't go beyond end! */
X		++curlin;
X		++change;		/* we've gone down one line */
X		curchr = *(lines+curlin)+1;
X	      }
X	    else
X		++curchr;
X	  }
X      }
X    else if (cnt < 0)
X      {
X	cnt=(-cnt);
X	for (i = 1 ; i <= cnt ; ++i)
X	  {
X	    --curchr;
X	    if (*(buff+curchr) == BEGLINE)
X	      {
X		if (curlin > 1)
X		  {
X		    --curlin;
X		    --change;
X		    for (curchr = *(lines+curlin) ; *(buff+curchr)!=ENDLINE ;
X		      ++curchr)
X			;	/* bump curchr to end of the line */
X		  }
X		else
X		  {
X		    ++curchr;
X		    break;
X		  }
X	      }
X	  }
X      }
X    if (change != 0)		/* don't do unnecessary change */
X	update(change);
X    tvhdln();
X#ifdef SCR_BUF
X    ttflush();
X#endif
X  }
X
X/* =============================>>> SEARCH <<<============================= */
X  search(lexcnt,iarg)
X  int lexcnt,iarg;
X  { /* search - search down in buffer for a pattern */
X
X    SLOW char chr,c0,c1,c2;
X    static int slines;
X    SLOW int oldx,oldy,oldlin;
X    SLOW int change, searchv, lininc, newln, fold_wild;
X    SLOW int l,lbeg,is;
X    SLOW BUFFINDEX ib, bbeg, oldpos, nbbeg;
X    FAST int i;
X
X    SLOW int how_match, set_len;	/* how wild card matching happens */
X    char *cp, *s_getset();
X    SLOW int w_len,inset,extra_len;		/* length of match */
X
X    static int lastsb = 0;
X
X    lininc = (lexcnt >= 0 ) ? 1 : (-1);
X    searchv = FALSE;
X    newln = FALSE;		/* haven't rubbed out 2nd line */
X
X    oldpos = curchr;		/* need to remember for -f */
X    oldx = tvx ; oldy = tvy ; oldlin = curlin;
X
X    ins_mode = TRUE;		/* so ttymode can echo right */
X
X    if (! iarg)
X	goto l100;		/* get arg form search buffer */
X
X    tvmsg("Find?",FALSE);
X
X    if (! grptch(&chr))
X	goto l9000;
X
X    slines=1;			/* only one line so far */
X    for (i = 0; chr != ESC && i < 100; ++i)	/* read in the pattern */
X      {
X	if (chr == delkey && rptcnt[rptuse] <= 0) /* edit interactive input */
X	  {
X	    --i;		/* adjust i for for loop ++i */
X	    if (i >= 0)		/* wipe out chars on screen */
X	      {
X		if (sbuff[i] == 0)	/* newline */
X		  {
X		     --slines; ctrlch(CR); newln = TRUE;
X		  }
X		else
X		  {
X		    if (newln)
X		      {
X			tvcout('\\');
X			ctrlch(sbuff[i]);
X		      }
X		    else
X		      {
X			tvcout(BACKSPACE);
X			tvcout(' ');
X			tvcout(BACKSPACE);
X			if (sbuff[i] < ' ' && sbuff[i] != 27)
X			  {
X			    tvcout(BACKSPACE);
X			    tvcout(' ');
X			    tvcout(BACKSPACE);
X			  }
X		      }
X		  }
X		--i;		/* wipe the character */
X	      }
X#ifdef SCR_BUF
X	    ttflush();
X#endif
X	    gkbd(&chr);		/* get new char */
X	    continue;
X	  }
X	sbuff[i]=chr;		/* stuff it away */
X	if (chr == LF)
X	  {
X#ifdef USELF
X	    tvcout(chr);	/*$$$ to ignore lfs in cr/lf systems */
X#endif
X	  }
X	else if (chr == CR)
X	  {
X	    if (rptcnt[rptuse] <= 0)
X		ctrlch(chr);
X	    ++slines;
X	    sbuff[i]=0;	/* end of a line */
X	  }
X	else
X	    ctrlch(chr);	/* echo character, handline control chars */
X
X#ifdef SCR_BUF
X	    ttflush();
X#endif
X/*# fetch the next character */
X	if (! grptch(&chr))
X	    goto l9000;
X      }
X
X    tvcout('$');	/* echo the escape */
X    tvxy(oldx,oldy);	/* return to old location */
X
X    if (i>0)			/* we got a new pattern */
X      {
X	lastsb=i-1;		/* last valid character */
X	sbuff[i] = 0;		/* make sure an EOS */
X      }
X    fixend();
X
Xl100:
X    extra_len = 0;
X    if (lininc < 0)
X	endlin();
X    bbeg = curchr;		/* start from current character first time */
X    c0 = sbuff[0];		/* initial char of pattern */
X    if (!xcases)			/* get initial character of pattern */
X	c0 = (c0 >= 'A' && c0 <= 'Z') ? c0+' ' : c0;
X
X    for (l = curlin ; l < nxtlin && l ; l += lininc)  /* l is same as l != 0 */
X      {
X	if ( !c0 )		/* !c0 same as c0 == 0 */
X	  {
X	    if (lastsb == 0)	/* matching cr only? */
X	      {
X		dwnlin(1);	/* go down one line */
X		newscr();	/* screen needs updating */
X		goto l8000;
X	      }
X	    else
X	      {
X		for (ib = bbeg; *(buff+ib); ++ib)
X		    ;
X		goto l1000;
X	      }
X	  }
X
Xl900:
X	if (c0 < ' ')	/* save time, check if might be w.c. once */
X	  {
X	    ib = bbeg;
X	    if (*(buff+ib))
X		goto l1000;
X	  }
X
X	for (ib=bbeg; *(buff+ib); ++ib)	/* search current line */
X	  {
X	    c2 = *(buff+ib);	/* next char of buffer */
X	    if (!xcases)
X		c2 = (c2 >= 'A' && c2 <= 'Z') ? c2+' ' : c2;
X	
X	    if (c2 != c0)
X		continue;		/* first characters don't match */
X	    else if (lastsb == 0)
X	      { 		/* one character pattern */
X		curchr = ib+1;
X		curlin = l;
X		goto l5000;	/* successful match */
X	      }
X	    else
X	      {
X		if ((c1 = sbuff[1]) < ' ')	/* possible wild? */
X		    goto l1000;
X		c2 = *(buff+ib+1);
X		if (! xcases)	/* fold to lower case */
X		  {
X		    c1 = (c1 >= 'A' && c1 <= 'Z') ? c1+' ' : c1;
X		    c2 = (c2 >= 'A' && c2 <= 'Z') ? c2+' ' : c2; /* clower */
X		  }
X		if ( c1 != c2 )
X		    continue;	/* first two don't match */
X		else
X		    goto l1000;	/* first two match, so possibility */
X	      }
X	  }
X
X/*    # fall thru => no match on this line */
Xl950:
X	bbeg = *(lines+l+lininc)+1;	/* next beginning character */
X	continue;			/* go check next line */
X					
Xl1000:				/* we have two characters matching! */
X	nbbeg = ib;		/* beginning of possible match in buff */
X	lbeg = l; 		/* current line we are searching */
X	how_match = 1;		/* assume exact match */
X	for (is = -1 ; ++is <= lastsb ; )
X	  {
X	    if ((c1 = sbuff[is]) < ' ')		/* possible wild card */
X	      {
X		if (c1 == W_span)
X		  {
X		    extra_len--;
X		    how_match = 2;		/* span match */
X		    continue;			/* keep scanning search pat */
X		  }
X		else if (c1 == W_skip)		/* skip? */
X		  {
X		    extra_len--;
X		    how_match = 0;		/* skip match */
X		    continue;			/* keep scanning search pat */
X		  }
X		else if ((cp = s_getset(c1,&set_len,&fold_wild)) == NULL)	/* not wild */
X		    goto NOT_WILD;		/* continue normally */
X		 
X	/* ok, to here, then have possible wild card match */
X	
X		w_len = 0;
X
X		for ( ; ; )
X		  {
X		    chr = *(buff + nbbeg);	/* pick up char */
X		    if (fold_wild)		/* fold if not user */
X			chr = clower(chr);
X		    if (chr == ENDLINE)		/* break on end of line */
X			break;			/* get out */
X	
X		    inset = s_inset(chr,cp,set_len);	/* see if in set */
X		    if ((how_match > 0 && inset) || (how_match == 0 && !inset))
X		      {
X			nbbeg++; 		/* bump to next char */
X			++w_len;
X			if (how_match == 1)
X		            break;		/* only once on mode 1 */
X		      }
X		    else
X			break;
X		  }
X
X		if (w_len <= 0)
X		  {
X		    ++bbeg; 	/* this part of line doesn't match */
X		    extra_len = 0;
X		    if (c0 == 0)
X			goto l950;
X		    else
X			goto l900;	/* try rest of current line */
X		  }
X
X	/* to here, then exit from wild card match */
X		extra_len += w_len - 1;
X		how_match = 1;			/* back to 1 again */
X		continue;		/* leave cursor on 1st unmatched */
X	      }
X
XNOT_WILD:
X	    c2 = *(buff+nbbeg);
X	    if (! xcases)	/* fold to lower case */
X	      {
X		c1 = (c1 >= 'A' && c1 <= 'Z') ? c1+' ' : c1;
X		c2 = (c2 >= 'A' && c2 <= 'Z') ? c2+' ' : c2; /* clower */
X	      }
X
X	    if ( c1 != c2 )
X	      {
X		extra_len = 0;
X		++bbeg; 	/* this part of line doesn't match */
X		if (c0 == 0)
X		    goto l950;
X		else
X		    goto l900;	/* try rest of current line */
X	      }
X
X	/* regular matched sequence */
X
X	    if (*(buff+nbbeg)==0 && lbeg+1 < nxtlin)
X	      {
X		++lbeg;
X		nbbeg = *(lines+lbeg)+1;	/* point to next character */
X	      }
X	    else
X		++nbbeg;
X	  }
X
X/*#  fall through => found the pattern */
X	curlin = lbeg;
X	curchr = nbbeg;
X
Xl5000:
X	change = curlin-oldlin;	/* compute real line change */
X	if ((slines > 1 && iarg) || tvdlin == tvlins || newln)
X	    newscr();
X	else
X	    update(change);
X	goto l8000;
X      }
X    curchr = oldpos;		/* reset things */
X    tvxy(oldx, oldy);
X    if (slines > 1 && iarg)
X	newscr();		/* patch up screen */
X    pat_buff[0] = 0;
X    tverrb("Not found ");	/* announce failure a little */
X    goto l9000;
X
Xl8000:				/* success return */
X    oldlen = lastsb+1+extra_len;		/* remember the length */
X    save_pat();		/* save the find pattern */
X    savlen = (-1);			/* haven't saved lines */
X    searchv = TRUE;
X
Xl9000:
X    ins_mode = FALSE;
X#ifdef SCR_BUF
X    ttflush();
X#endif
X    return (searchv);
X  }
X
X/* =============================>>> S_GETSET <<<============================= */
X  char *s_getset(wildchr,set_len,fold)
X  char wildchr;		/* wild card character */
X  int *set_len, *fold;		/* length of set, fold flag */
X  {
X    static char sets[] =		/* possible sets */
X      {
X	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
X	'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
X	'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3',
X	'4', '5', '6', '7', '8', '9', '.', ',', '?', '!',
X	'[', ']', '{', '}', '(', ')', '<', '>', '\'','"',
X	'+', '-', '/', '*', '=', '@', '#', '$', '%', '^',
X	'&', '_', '~', '`', '|', '\\', ' ', 9, ';', ':', 0
X      };
X
X    struct wild_set
X      {
X	char wch;
X	int s_start, s_len;
X      };
X
X    static struct wild_set wild_cards[] =
X      {
X	{ W_letter,  0, 26 },	/* ^L is a letter, starts at 0, 26 long */
X	{ W_digit, 26, 10 },	/* ^D is digit, starts at 26, 10 long */
X	{ W_alpha,  0, 36 },	/* ^A is alpha numeric, start at 0, 36 long */
X	{ W_punc, 36,  4 },	/* ^P is punctuation, at 36, 4 long */
X	{ W_anything,  0, 70 },	/* ^X is any thing, whole set */
X	{ W_others, 36, 34 },	/* ^O is non-alphanum, start at 36, 32 long */
X	{ 0 ,  0,  0 }	/* end of set */
X      };
X
X    SLOW int i;
X    
X    *fold = FALSE;		/* assume won't fold */
X    if (!use_wild)
X	return NULL;		/* not there if not using! */
X
X    for (i = 0 ; wild_cards[i].wch ; ++i)	/* scan list */
X      {
X	if (wildchr == wild_cards[i].wch)	/* found the one we want */
X	  {
X	    *set_len = wild_cards[i].s_len;
X	    *fold = TRUE;
X	    return (&sets[ wild_cards[i].s_start ]);
X	  }
X      }
X    if (wildchr == W_user)
X      {
X	*set_len = strlen(user_set);
X	return user_set;
X      }
X    else
X	return NULL;
X
X  }
X  
X/* =============================>>> S_inset <<<============================= */
X  s_inset(c2,cp,set_len)
X  char c2, *cp;
X  int set_len;
X  {
X    FAST int i;
X
X    for (i = 0 ; i < set_len ; ++i)
X	if (c2 == *(cp+i))
X	    return TRUE;
X    return FALSE;
X  }
X  
X/* =============================>>> SETPAR <<<============================= */
X  setpar(val,chr)
X  int val;
X  char chr;
X  { /* setpar - reset varoius parameters
X		syntax for setpar is [val]:<let>, where [val] is the new value
X		of the parameter, : is the setpar command, and <let> is the
X		letter of the parameter to set. */
X
X    chr = clower(chr);
X
X    switch (chr)
X      {
X   	case 'a':		/* set auto indent */
X 	    autoin = val > 0;
X	    break;
X
X	case 'c':		/* cut mode */
X 	    cut_mode = val > 0;
X	    break;
X
X   	case 'e':		/* expand tabs */
X 	    tabspc = max(val,0);
X	    verify(1);		/* need to redisplay */
X	    break;
X
X	case 'd':		/* display line */
X	    if (val < 1 || val > tvlins)
X		tverrb("Bad par val");
X	    else
X	      {
X		dsplin=val;
X		verify(1);
X	      }
X	    break;
X
X   	case 'f':		/* set find mode */
X	    xcases = val <= 0;
X	    break;
X
X	case 'm':		/* match wild cards */
X	    use_wild = val;
X	    break;
X
X	case 'o':
X	    if (rdonly)
X	      {
X		tverrb("Can't :o, R/O");
X		break;
X	      }
X	    tvclr();
X	    ask("New output file name: ",dest_file,FNAMESIZE);
X	    if (*dest_file)
X		rdonly = FALSE;
X	    verify(1);
X	    break;
X
X	case 's':		/* scroll lines */
X	    if (val < 0 || val > dsplin-1)
X		tverrb("Bad par val");
X	    else
X		scroll=val;
X	    break;
X
X	case 't':		/* tty mode */
X	    tvclr();
X	    ttymode = val;
X	    ttynext = 1000;
X	    verify(1);
X	    break;
X
X	case 'r':		/* change repeat buffer in use */
X	    if (val < 1 || val > REPEATBUFS)
X		tverrb("Bad par val");
X	    else
X		rptuse=val-1;	/* adjust for 0 index int */
X	    break;
X
X	case 'u':
X	    tvclr();
X	    ask("Enter user wild card set: ",user_set,39);
X	    verify(1);
X	    break;
X
X	case 'v':		/* virtual window size */
X	    if (val < 3 || val > tvhardlines)
X		tverrb("Bad par val");
X	    else
X	      {
X		tvlins = val;			/* set to new display line */
X		ddline = (tvlins / 2) + 1;	/* fix home line */
X		setdscrl();			/* set scroll value */
X		dsplin = ddline;		/* reset these */
X		scroll = dscrl;
X		verify(1);			/* update the screen */
X	      }
X	    break;
X
X	case 'w':		/* change wrap width */
X	    wraplm=val;
X	    break;
X
X	default:
X	    tverrb("Bad par name");
X      }
X#ifdef SCR_BUF
X    ttflush();
X#endif
X  }
X
X/* =============================>>> SNEXT  <<<============================= */
X  snext(lexcnt,iarg)
X  int lexcnt,iarg;
X  { /* snext - find a text pattern across page boundaries */
X
X    SLOW int ihow,pagout;
X
X    if (lexcnt < 0)
X      {
X	tverrb("Search fails");
X	return (FALSE);
X      }
X	
X    ihow=iarg;			/* make a local copy */
X    pagout=FALSE;
X    for(;;)
X      {
X	if (! search(lexcnt,ihow))
X	  {
X	    wtpage(1);		/* write out current page */
X	    ihow=FALSE;		/* don't reread search pattern */
X	    pagout=TRUE;
X	    if (! rdpage())
X	      {
X		tvclr();	/* no more text */
X		tverrb("Search fails");
X		return (FALSE);
X	      }
X	  }
X	else			/* found it */
X	  {
X	    if (pagout)
X		newscr();
X#ifdef SCR_BUF
X	    else
X		ttflush();
X#endif
X	    return (TRUE);
X	  }
X      }
X  }
X
X/* =============================>>> STORE_RPT <<<============================= */
X  store_rpt(dummy)
X  int dummy;
X  {	/* start at current cursor position, insert into repeat buffer
X	   identified until find >$$ or exceed size limit, deleting as it goes */
X
X    SLOW char chr;
X    SLOW int saved, i, val;
X
X    beglin();		/* start by moving to beginning of current line */
X
X    if ((chr = *(buff+curchr)) != '#')	/* get current char, which must be # */
X      {
X	tverrb("Not a valid rpt buff");
X	return (FALSE);	
X      }
X    val = *(buff+curchr+1)-'0';		/* pick up buffer number */
X
X    if (!chk_rpt_nr(val))
X	return FALSE;
X
X    delnxt(4);				/* delete the #n:< */
X
X    --val;		/* change to relative */
X
X    saved = 0;				/* no previous chars */
X    for (i = 0 ;  ; ++i)
X      {
X	chr = *(buff+curchr);		/* get the character */
X
X	if (chr == ESC && i > 1 && rptbuf[val][i-1] == ESC &&
X	    rptbuf[val][i-2] == loop_end)
X	  {
X	    rptbuf[val][i-2] = 0;	/* set to 0 */
X	    nxtrpt[val] = 0;
X	    delnxt(2);			/* delete the 27 and following CR */
X#ifdef SCR_BUF
X	    ttflush();
X#endif
X	    return TRUE;
X	  }
X	if (++saved > 99)
X	  {
X	    tverrb("Only 100 chars in rpt");
X	    return FALSE;
X	  }
X	if (chr == ENDLINE)
X	    chr = CR;
X	rptbuf[val][i] = chr;			/* save the char */
X	delnxt(1);			/* and delete it */
X      }
X  }
X
X/* =============================>>> SVKLIN <<<============================= */
X  svklin(lin)
X  int lin;
X  { /* svklin - save one line that will be killed */
X
X    SLOW BUFFINDEX from,to;
X
X    to=0;
X    for (from= *(lines+lin)+1; *(buff+from)!=ENDLINE; ++from)
X      {
X	unkbuf[to]= *(buff+from);	/* put it in unkill buffer */
X	to = min(130,to+1);
X      }
X    unkbuf[to]=0;
X  }
X
X/* =============================>>> TOPPAG <<<============================= */
X  toppag()
X  { /* toppag - move cursor to top of the page */
X
X    curlin=1;
X    curchr = *(lines+1)+1;		/* first char of buffer */
X    newscr();
X  }
X
X/* =============================>>> TVIDEFS <<<============================= */
X  tvidefs()
X  { /* initialize these AFTER opening, defaults set by -c */
X
X    dsplin=ddline;
X    scroll=dscrl;
X    xcases=dxcase;
X  }
X
X/* =============================>>> TVINIT <<<============================= */
X  tvinit()
X  { /* perform initializations needed for tv edit */
X
X    FAST BUFFINDEX i;
X    FAST char *chrp;
X    SLOW char *lim;
X    char *malloc();
X
X#ifdef MSDOS
X    BUFFINDEX coreleft();		/* !!! cii-86 dependent */
X#endif
X
X/*	This is a time eater if a big buffer -- if your loader inits
X	mem to some known value, it might be possible to change GARBAGE
X	to that value (be sure no other conflicts, like EOS == 0) 	*/
X
X/* try for maximum size buffer */
X
X#ifndef GEMDOS
X    if ((lines = (BUFFINDEX *) malloc((MAXLINE+1)*sizeof(BUFFINDEX)))
X       == NULL)		/* line pointer array */
X	exit(1);
X#else
Xif ((lines=(BUFFINDEX *)malloc((unsigned int)((MAXLINE+1)*sizeof(BUFFINDEX))) )
X       == NULL)		/* line pointer array */
X	exit(1);
X#endif
X
X#ifdef UNIX
X    for (mxbuff=MAXBUFF ; (buff = malloc(mxbuff+2))==NULL ; mxbuff -= 1000)
X	;			/* text buffer pointer */
X#endif
X#ifdef OSCPM
X    for (mxbuff=MAXBUFF ; (buff = malloc(mxbuff+2))==NULL ; mxbuff -= 1000)
X	;			/* text buffer pointer */
X#endif
X#ifdef GEMDOS
X    for (mxbuff = 60000L ; (buff = malloc((unsigned int) (mxbuff+2)))==NULL
X      ; mxbuff -= 1000L)
X	;			/* text buffer pointer */
X#endif
X#ifdef MSDOS			/* *** Cii-86 C compiler dependent! */
X
X    /* cii-86 requires you to manually leave some memory left over
X       for the I/O routines to use.  'coreleft' does this. Sigh. */
X
X    if ((mxbuff = (coreleft() - 5000) ) > MAXBUFF)
X	mxbuff = MAXBUFF;
X    for ( ; (buff = malloc(mxbuff+2))==NULL ; mxbuff -= 1000)
X	;			/* text buffer pointer */
X#endif
X
X    mxline = MAXLINE;
X
X    lim = buff + mxbuff;
X    for (chrp = buff ; chrp <= lim ; *chrp++ = GARBAGE )
X	;	/* mark as all garbage */
X
X    curlin =			/* init some stuff */
X    oldlen =
X    curchr = 0;
X
X    xoutcm = leftmg = nxtlin = nxtchr = tvdlin = 1;
X    *(buff+mxbuff) = ENDLINE;	/* needs to be ENDLINE for save buffer */
X    nxtsav=mxbuff;		/* point to end of the buffer */
X
X    pat_buff[0] = 0;		/* null pattern buffer */
X
X
X    savlin = savlen = (-1);
X    for (i = 0 ; i < REPEATBUFS ; ++i)
X      {  			/* fix repeat buffers to initial state */
X	rptbuf[i][0] = rptcnt[i]= nxtrpt[i] = rptbuf[i][1] = 0;
X      }
X    rptuse=0;			/* start with first repeat buff */
X    bakflg = FALSE;
X    ineof =
X    echof = TRUE;
X  }
X
X/* =============================>>> TVERR  <<<============================= */
X  tverr(str)
X  char str[];
X  { /* tverr -	display an error message on the last line of the screen
X       		always writes on screen, returns to old position */
X
X    SLOW int oldx,oldy,oldxot,oldech;
X
X    waserr = TRUE;
X    oldx=tvx ; oldy=tvy ; oldxot=xoutcm ; oldech=echof;
X
X    ttynext = 1000;		/* force new read */
X
X    echof = TRUE;			/* always echo! */
X    tvmsg(str,TRUE); 		/* print the message part */
X    tvxy(oldx,oldy);
X    xoutcm=oldxot;
X    echof=oldech;		/* restore to what it was */
X#ifdef SCR_BUF
X    ttflush();
X#endif
X  }
X
X/* =============================>>> TVERRB <<<============================= */
X  tverrb(str)
X  char str[];
X  { /* tverrb - display an error message on the last line of the screen
X      		always writes on screen, returns to old position */
X
X    sendcs(cerrbg);
X    tverr(str);
X    sendcs(cerred);
X#ifdef SCR_BUF
X    ttflush();
X#endif
X  }
X
X/* =============================>>> TVHDLN <<<============================= */
X  tvhdln()
X  { /* tvhdln - home to display line */
X
X    SLOW int xf;
X    xf = findx();
X    tvxy(xf,tvdlin);
X  }
X
X/* =============================>>> TVMSG  <<<============================= */
X  tvmsg(str,intty)
X  char str[];
X  int intty;
X  { /* tvmsg - display a message on the last line of the screen */
X
X    FAST int i;
X    SLOW int oldtty;
X
X    tvxy(1,tvhardlines);
X    tvelin();
X    
X    oldtty = ttymode;
X    if (ttymode && intty)
X      {
X	ttymode = FALSE;
X	prompt(">");
X      }
X
X    for (i=0; str[i]; ctrlch(str[i++]))
X	;
X
X    if (oldtty)		/* end with < if was ttymode */
X	remark("<");
X
X    ttymode = oldtty;
X#ifdef SCR_BUF
X    ttflush();
X#endif
X  }
X
X/* =============================>>> TVTYLN <<<============================= */
X  tvtyln(chrptr)
X  BUFFINDEX chrptr;
X  { /* tvtyln - type a line on the screen without cr/lf */
X
X#ifdef ULBD
X    FAST BUFFINDEX i;
X
X    if (cundlb[0] || cboldb[0])	/* check for underline/bold */
X      {
X	for (i = *(lines+curlin)+1 ; *(buff+i)!=ENDLINE ; ++i)
X	    if (*(buff+i)==TOGUNDERLINE || *(buff+i)==TOGBOLD)
X	      {
X		tvxy(1,tvy);
X		xoutcm=1;
X		tvplin(*(lines+curlin)+1);
X		return;
X	      }
X      }
X#endif
X    xoutcm=tvx;
X    tvplin(chrptr);
X#ifdef SCR_BUF
X    ttflush();
X#endif
X  }
X
X/* =============================>>> UNKILL <<<============================= */
X  int unkill()
X  { /* unkill the single last line killed */
X
X    SLOW char chrval;
X    FAST int i;
X
X    openln(1);		/* put the CR 1st - makes update pretty */
X    for (i=0; unkbuf[i]; ++i)
X      {
X	chrval = unkbuf[i];
X	if (! ins_chr(chrval))	/* unkill slowly by using insert */
X	  {
X	    return (FALSE);
X	  }
X      }
X    dwnlin(1);		/* back to where we were */
X    return (TRUE);
X  }
X
X/* =============================>>> UPDATE <<<============================= */
X  update(change)
X  int change;
X  { /* update - update the screen when line position has changed
X		will not be used if any alterations have been made */
X
X    SLOW int abschg,bscrol;
X
X    if (! echof)
X	return;
X    abschg =  change;
X
X    bscrol = (ctopb[0]==0) ? 0 : scroll;
X
X    if (change < 0)			/* have to scroll screen down */
X      {
X	abschg = (-change);
X	if (tvdlin-abschg < 1)
X	    newscr();
X	else if (curlin < tvdlin)	/* won't fit exactly */
X	  {
X	    if (tvdlin >= dsplin-scroll && abschg!=1)
X	      {
X		tvclr();		/* clear the screen */
X		tvtype(1,tvlins);	/* type out a screen */
X	      }
X	    tvdlin=curlin;
X	  }
X	else if (tvdlin-abschg >= dsplin-scroll)
X	    tvdlin -= abschg;
X	else
X	  {
X	    if (tvdlin > dsplin-scroll)
X	      { 			/* moving up from below display line */
X		abschg=dsplin-scroll-(tvdlin-abschg);
X		tvdlin=dsplin-scroll;	/* update */
X	      }
X	    if (ctopb[0]==0)		/* can't do reverse linefeeds */
X		newscr();		/* no choice, redraw screen */
X	    else
X	      {
X		tvtopb(abschg);		/* make blank lines at top */
X		tvtype(curlin-tvdlin+1,abschg);	/* fill in */
X	      }
X	  }
X      }
X    else if (change > 0)		/* have to scroll screen up */
X	if ((tvdlin+change>tvlins && tvdlin<dsplin+bscrol) || change>=tvlins)
X	    newscr();
X	else if (tvdlin < dsplin+bscrol || nxtlin-1 <= tvlins)
X	    if (tvdlin+change > dsplin+bscrol && nxtlin-1 > tvlins)
X		newscr();
X	    else
X		tvdlin += change;
X	else if (nxtlin-curlin<=tvlins-tvdlin)	/* on bottom part */
X	  {
X	    if (tvdlin<=dsplin+bscrol && abschg!=1)
X	      {
X		tvclr();		/* rewrite whole screen */
X		tvtype(nxtlin-tvlins,tvlins);
X	      }
X	    tvdlin=min(tvlins,nxtlin-1)-(nxtlin-curlin)+1;
X	  }
X	else
X	  {
X	    tvbotb(abschg);		/* make room */
X	    tvxy(1,tvlins-abschg+1);	/* home to right line */
X	    tvtype(curlin+tvlins-tvdlin-abschg+1,abschg);  /* fix up screen */
X	    if (tvdlin < dsplin+bscrol)
X		tvdlin=dsplin;
X	  }
X    tvhdln();
X#ifdef SCR_BUF
X    ttflush();
X#endif
X  }
X
X/* =============================>>> WORDR  <<<============================= */
X  wordr(cnt)
X  int cnt;
X  {  /* wordr - move cursor over words */
X
X    SLOW int lim,words,incr,lenmov;
X
X    lenmov=0;
X    if (cnt<0)
X      {
X	incr = (-1);		/* change */
X	lim = (-cnt);
X      }
X    else if (cnt == 0)
X      {
X	incr = -1;
X	lim = 0;
X      }
X    else 
X      {
X	incr = 1; 
X	lim = cnt;
X      }
X
X    for (words=1; words<=lim; ++words)
X      {
X	if ((*(buff+curchr)==ENDLINE && incr>0) ||
X	    (*(buff+curchr-1)==BEGLINE && incr<0) )
X	  {
X	    if (curlin+incr==nxtlin || curlin+incr<1)
X		break;		/* at a buffer limit, so quit */
X	    dwnlin(incr);	/* move up or down */
X	    lenmov += incr;
X	    if (cnt<0)
X		endlin();
X	    continue;		/* move to next word */
X	  }
X
X/* ok, first, skip over word characters */
X	while (wrdchr(*(buff+curchr)))
X	  {
X	    if (*(buff+curchr-1)==BEGLINE && incr<=0)
X		goto l100;
X	    else
X	      {
X		curchr += incr;
X		lenmov += incr;
X	      }
X	  }
X
X/* now skip over remaining non word chars */
X	while (! wrdchr(*(buff+curchr)))
X	   {
X	    if ((*(buff+curchr)==ENDLINE && incr>0) || (*(buff+curchr-1)==BEGLINE &&
X	      incr<0))
X		break;
X	    else
X	      {
X		curchr += incr;
X		lenmov += incr;
X	      }
X	  }
Xl100: ;
X      }
X
X    if (incr < 0)		/* move cursor to beginning of word */
X	while (wrdchr(*(buff+curchr-1)))
X	  {
X	    curchr += incr;
X	    lenmov += incr;
X	  }
X    tvhdln();
X#ifdef SCR_BUF
X    ttflush();
X#endif
X    oldlen = lenmov ; savlen=(-1) ;
X  }
X
X/* =============================>>> WRDCHR <<<============================= */
X  int wrdchr(chr)
X  char chr;
X  { /* wrdchr - determine if a character is a "word" type character */
X
X    if ((chr>='a' && chr <= 'z') || (chr >= 'A' && chr <= 'Z') ||
X      (chr >= '0' && chr <= '9'))
X	return (TRUE);
X    else
X 	return (FALSE);
X  }
SHAR_EOF
echo Extracting tvx_term.ic:
sed 's/^X//' >tvx_term.ic <<\SHAR_EOF
X/* -----------------  Various terminal definitions ---------------------- */
X/* ********************************************************************** */
X#ifdef IBMPC
X    EXTERN int addx = 31;		/* amount to add to get x */
X    EXTERN int addy = 31;		/* to get y */
X    EXTERN char cxychr = 0;		/* true if convert xy bin to ascii */
X    EXTERN char cversn[12] = "IBM-PC";     /* a version to identify config */
X    EXTERN char cxy1st = 'l';			/* l if line first, c if column 1st */
X    EXTERN char cxybeg[8] = {18,0,0,0,0,0,0,0};	/* start xy control seq  */
X    EXTERN char cxymid[8] = {0,0,0,0,0,0,0,0};  /* middle xy control seq */
X    EXTERN char cxyend[8] = {0,0,0,0,0,0,0,0};  /* end sequence */
X    EXTERN char cerrbg[8] = {16,0,0,0,0,0,0,0}; /* string to print when errors start */
X    EXTERN char cerred[8] = {14,0,0,0,0,0,0,0};  /* when errors done */
X    EXTERN char ctopb[8] = {3,0,0,0,0,0,0,0}; /* top blanks = reverse linefeed */
X    EXTERN char cinit[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X	/* start up sequence */
X    EXTERN char cendit[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X	/* to end session */
X    EXTERN char cbotb[8] = {10,0,0,0,0,0,0,0};  /* bottom blank line sequence */
X    EXTERN char celin[8] = {1,0,0,0,0,0,0,0};	    /* erase to end of line */
X    EXTERN char cescr[8] = {2,0,0,0,0,0,0,0};	    /* erase to end of screen */
X    EXTERN char cclears[8]={0,0,0,0,0,0,0,0};	/* clear screen, home cusor */
X    EXTERN char cdelchr[8]={0,0,0,0,0,0,0,0};	/* delete char on screen */
X    EXTERN char ccsrcm[8] = {20,0,0,0,0,0,0,0};	/* set cursor to command mode */
X    EXTERN char ccsrin[8] = {19,0,0,0,0,0,0,0};	/* set cursor to insert mode */
X    EXTERN char ciline[8] = {3,0,0,0,0,0,0,0};	    /* insert a line */
X    EXTERN char ckline[8] = {6,0,0,0,0,0,0,0};	    /* kill a line */
X    EXTERN char cundlb[8] = {4,0,0,0,0,0,0,0};	/* turn on underline */
X    EXTERN char cundle[8] = {5,0,0,0,0,0,0,0};	/* turn off underline */
X    EXTERN char cboldb[8] = {11,0,0,0,0,0,0,0};	/* start bold */
X    EXTERN char cbolde[8] = {12,0,0,0,0,0,0,0};	/* end bold */
X
X    EXTERN int dsp_mem = 0;
X    EXTERN int ddline = 16;
X    EXTERN int dscrl = 0;
X    EXTERN int dxcase = 0;
X#ifdef USECTRLZ
X    EXTERN int usecz = 1;
X#else
X    EXTERN int usecz = 0;
X#endif
X    EXTERN int autoin = 0;	/* TRUE if auto indent, FALSE otherwise */
X    EXTERN int logdef = 0;	/* backup log file by default 0->no, 1-> yes */
X    EXTERN char delkey = 8;
X    EXTERN int tvlins = 25;	/* number of lines on screen */
X    EXTERN int tvcols = 80;	/* number of columns on screen */
X    EXTERN int tvhardlines = 25;	/* real number of lines */
X    EXTERN int tvx = 0;        /* current x cursor position */
X    EXTERN int tvy = 0;        /* current y cursor position */
X    EXTERN int tvdlin = 0;     /* the "active" display line */
X    EXTERN int dsplin = 0;     /* the default display line */
X    EXTERN int tabspc = 8;     /* spacing for tabs */
X    EXTERN int leftmg = 0;	/* left margin of display */
X    EXTERN int wraplm = 0;	/* auto wrap? */
X    EXTERN int isibmpc = 1;	/* for possible use with a general version */
X
X#endif
X/* ********************************************************************** */
X#ifdef TERMCAP
X    EXTERN int addx = 0;		/* amount to add to get x */
X    EXTERN int addy = 0;			/* to get y */
X    EXTERN char cxychr = 0;		/* true if convert xy bin to ascii */
X    EXTERN char cversn[12] = ":";     /* a version to identify config */
X    EXTERN char cxy1st = 0;			/* l if line first, c if column 1st */
X    EXTERN char cxybeg[8] = {0,0,0,0,0,0,0,0};	/* start xy control seq  */
X    EXTERN char cxymid[8] = {0,0,0,0,0,0,0,0};  /* middle xy control seq */
X    EXTERN char cxyend[8] = {0,0,0,0,0,0,0,0};  /* end sequence */
X    EXTERN char cerrbg[8] = {0,0,0,0,0,0,0,0}; /* string to print when errors start */
X    EXTERN char cerred[8] = {0,0,0,0,0,0,0,0};  /* when errors done */
X    EXTERN char ctopb[8] = {0,0,0,0,0,0,0,0}; /* top blanks = reverse linefeed */
X    EXTERN char cinit[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X	/* start up sequence */
X    EXTERN char cendit[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X	/* to end session */
X    EXTERN char cbotb[8] = {10,0,0,0,0,0,0,0};  /* bottom blank line sequence */
X    EXTERN char celin[8] = {0,0,0,0,0,0,0,0};	    /* erase to end of line */
X    EXTERN char cescr[8] = {0,0,0,0,0,0,0,0};	    /* erase to end of screen */
X    EXTERN char cclears[8]={0,0,0,0,0,0,0,0};	/* clear screen, home cusor */
X    EXTERN char cdelchr[8]={0,0,0,0,0,0,0,0};	/* delete char on screen */
X    EXTERN char ccsrcm[8] = {0,0,0,0,0,0,0,0};	/* set cursor to command mode */
X    EXTERN char ccsrin[8] = {0,0,0,0,0,0,0,0};	/* set cursor to insert mode */
X    EXTERN char ciline[8] = {0,0,0,0,0,0,0,0};	    /* insert a line */
X    EXTERN char ckline[8] = {0,0,0,0,0,0,0,0};	    /* kill a line */
X    EXTERN char cundlb[8] = {0,0,0,0,0,0,0,0};	/* turn on underline */
X    EXTERN char cundle[8] = {0,0,0,0,0,0,0,0};	/* turn off underline */
X    EXTERN char cboldb[8] = {0,0,0,0,0,0,0,0};	/* start bold */
X    EXTERN char cbolde[8] = {0,0,0,0,0,0,0,0};	/* end bold */
X
X    EXTERN int dsp_mem = 0;
X    EXTERN int ddline = 12;	/* unix really needs scroll window */
X    EXTERN int dscrl = 6;
X    EXTERN int dxcase = 0;
X#ifdef USECTRLZ
X    EXTERN int usecz = 1;
X#else
X    EXTERN int usecz = 0;
X#endif
X    EXTERN int autoin = 0;	/* TRUE if auto indent, FALSE otherwise */
X    EXTERN int logdef = 0;	/* backup log file by default 0->no, 1-> yes */
X    EXTERN char delkey = 8;
X    EXTERN int tvlins = 0;	/* number of lines on screen */
X    EXTERN int tvcols = 0;	/* number of columns on screen */
X    EXTERN int tvhardlines = 0;	/* real number of lines */
X    EXTERN int tvx = 0;        /* current x cursor position */
X    EXTERN int tvy = 0;        /* current y cursor position */
X    EXTERN int tvdlin = 0;     /* the "active" display line */
X    EXTERN int dsplin = 0;     /* the default display line */
X    EXTERN int tabspc = 8;     /* spacing for tabs */
X    EXTERN int leftmg = 0;	/* left margin of display */
X    EXTERN int wraplm = 0;	/* auto wrap? */
X    EXTERN int isibmpc = 0;	/* for possible use with a general version */
X
X#endif
X/* ********************************************************************** */
X#ifdef VT100 
X    EXTERN int addx = 0;		/* amount to add to get x */
X    EXTERN int addy = 0;			/* to get y */
X    EXTERN char cxychr = 1;		/* true if convert xy bin to ascii */
X    EXTERN char cversn[12] = "VT-100";     /* a version to identify config */
X    EXTERN char cxy1st = 'l';			/* l if line first, c if column 1st */
X    EXTERN char cxybeg[8] = {27,'[',0,0,0,0,0,0};	/* start xy control seq  */
X    EXTERN char cxymid[8] = {';',0,0,0,0,0,0,0};  /* middle xy control seq */
X    EXTERN char cxyend[8] = {'H',0,0,0,0,0,0,0};  /* end sequence */
X    EXTERN char cerrbg[8] = {7,0,0,0,0,0,0,0}; /* string to print when errors start */
X    EXTERN char cerred[8] = {0,0,0,0,0,0,0,0};  /* when errors done */
X    EXTERN char ctopb[8] = {27,'M',0,0,0,0,0,0}; /* top blanks = reverse linefeed */
X    EXTERN char cinit[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X	/* start up sequence */
X    EXTERN char cendit[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X	/* to end session */
X    EXTERN char cbotb[8] = {10,0,0,0,0,0,0,0};  /* bottom blank line sequence */
X    EXTERN char celin[8] = {27,'[','K',0,0,0,0,0}; /* erase to end of line */
X    EXTERN char cescr[8] = {27,'[','J',0,0,0,0,0};	    /* erase to end of screen */
X    EXTERN char cclears[8]={0,0,0,0,0,0,0,0};	/* clear screen, home cusor */
X    EXTERN char cdelchr[8]={0,0,0,0,0,0,0,0};	/* delete char on screen */
X    EXTERN char ccsrcm[8] = {0,0,0,0,0,0,0,0};	/* set cursor to command mode */
X    EXTERN char ccsrin[8] = {0,0,0,0,0,0,0,0};	/* set cursor to insert mode */
X    EXTERN char ciline[8] = {0,0,0,0,0,0,0,0};	    /* insert a line */
X    EXTERN char ckline[8] = {0,0,0,0,0,0,0,0};	    /* kill a line */
X    EXTERN char cundlb[8] = {0,0,0,0,0,0,0,0};	/* turn on underline */
X    EXTERN char cundle[8] = {0,0,0,0,0,0,0,0};	/* turn off underline */
X    EXTERN char cboldb[8] = {0,0,0,0,0,0,0,0};	/* start bold */
X    EXTERN char cbolde[8] = {0,0,0,0,0,0,0,0};	/* end bold */
X
X    EXTERN int dsp_mem = 0;
X    EXTERN int ddline = 16;
X    EXTERN int dscrl = 0;
X    EXTERN int dxcase = 0;
X#ifdef USECTRLZ
X    EXTERN int usecz = 1;
X#else
X    EXTERN int usecz = 0;
X#endif
X    EXTERN int autoin = 0;	/* TRUE if auto indent, FALSE otherwise */
X    EXTERN int logdef = 0;	/* backup log file by default 0->no, 1-> yes */
X    EXTERN char delkey = 8;
X    EXTERN int tvlins = 24;	/* number of lines on screen */
X    EXTERN int tvcols = 80;	/* number of columns on screen */
X    EXTERN int tvhardlines = 24;	/* real number of lines */
X    EXTERN int tvx = 0;        /* current x cursor position */
X    EXTERN int tvy = 0;        /* current y cursor position */
X    EXTERN int tvdlin = 0;     /* the "active" display line */
X    EXTERN int dsplin = 0;     /* the default display line */
X    EXTERN int tabspc = 8;     /* spacing for tabs */
X    EXTERN int leftmg = 0;	/* left margin of display */
X    EXTERN int wraplm = 0;	/* auto wrap? */
X    EXTERN int isibmpc = 0;	/* for possible use with a general version */
X#endif
X/* ********************************************************************** */
X#ifdef ATARI520				/* like a 25 line VT-52! */
X    EXTERN int addx = 31;		/* amount to add to get x */
X    EXTERN int addy = 31;			/* to get y */
X    EXTERN char cxychr = 0;		/* true if convert xy bin to ascii */
X    EXTERN char cversn[12] = "520ST";     /* a version to identify config */
X    EXTERN char cxy1st = 'l';			/* l if line first, c if column 1st */
X    EXTERN char cxybeg[8] = {27,'Y',0,0,0,0,0,0};	/* start xy control seq  */
X    EXTERN char cxymid[8] = {0,0,0,0,0,0,0,0};  /* middle xy control seq */
X    EXTERN char cxyend[8] = {0,0,0,0,0,0,0,0};  /* end sequence */
X    EXTERN char cerrbg[8] = {27,'p',0,0,0,0,0,0}; /* string to print when errors start */
X    EXTERN char cerred[8] = {27,'q',0,0,0,0,0,0};  /* when errors done */
X    EXTERN char ctopb[8] = {27,'I',0,0,0,0,0,0}; /* top blanks = reverse linefeed */
X    EXTERN char cinit[20] = {27,'w',27,'e',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X	/* start up sequence */
X    EXTERN char cendit[20] = {27,'v',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X	/* to end session */
X    EXTERN char cbotb[8] = {10,0,0,0,0,0,0,0};  /* bottom blank line sequence */
X    EXTERN char celin[8] = {27,'K',0,0,0,0,0,0};	    /* erase to end of line */
X    EXTERN char cescr[8] = {27,'J',0,0,0,0,0,0};	    /* erase to end of screen */
X    EXTERN char cclears[8]={27,'E',0,0,0,0,0,0};	/* clear screen, home cusor */
X    EXTERN char cdelchr[8]={27,'M',0,0,0,0,0,0};	/* delete char on screen */
X    EXTERN char ccsrcm[8] = {0,'y','4',0,0,0,0,0};	/* set cursor to command mode */
X    EXTERN char ccsrin[8] = {0,'x','4',0,0,0,0,0};	/* set cursor to insert mode */
X    EXTERN char ciline[8] = {27,'L',0,0,0,0,0,0};	    /* insert a line */
X    EXTERN char ckline[8] = {27,'M',0,0,0,0,0,0};	    /* kill a line */
X    EXTERN char cundlb[8] = {27,'p',0,0,0,0,0,0};	/* turn on underline */
X    EXTERN char cundle[8] = {27,'q',0,0,0,0,0,0};	/* turn off underline */
X    EXTERN char cboldb[8] = {27,'p',0,0,0,0,0,0};	/* start bold */
X    EXTERN char cbolde[8] = {27,'q',0,0,0,0,0,0};	/* end bold */
X
X    EXTERN int dsp_mem = 0;
X    EXTERN int ddline = 16;
X    EXTERN int dscrl = 0;
X    EXTERN int dxcase = 0;
X#ifdef USECTRLZ
X    EXTERN int usecz = 1;
X#else
X    EXTERN int usecz = 0;
X#endif
X    EXTERN int autoin = 0;	/* TRUE if auto indent, FALSE otherwise */
X    EXTERN int logdef = 0;	/* backup log file by default 0->no, 1-> yes */
X    EXTERN char delkey = 8;
X    EXTERN int tvlins = 25;	/* number of lines on screen */
X    EXTERN int tvcols = 80;	/* number of columns on screen */
X    EXTERN int tvhardlines = 25;	/* real number of lines */
X    EXTERN int tvx = 0;        /* current x cursor position */
X    EXTERN int tvy = 0;        /* current y cursor position */
X    EXTERN int tvdlin = 0;     /* the "active" display line */
X    EXTERN int dsplin = 0;     /* the default display line */
X    EXTERN int tabspc = 8;     /* spacing for tabs */
X    EXTERN int leftmg = 0;	/* left margin of display */
X    EXTERN int wraplm = 0;	/* auto wrap? */
X    EXTERN int isibmpc = 0;	/* for possible use with a general version */
X#endif
X/* ********************************************************************** */
X/* ********************************************************************** */
X#ifdef H19
X    EXTERN int addx = 31;		/* amount to add to get x */
X    EXTERN int addy = 31;			/* to get y */
X    EXTERN char cxychr = 0;		/* true if convert xy bin to ascii */
X    EXTERN char cversn[12] = "H19";     /* a version to identify config */
X    EXTERN char cxy1st = 'l';			/* l if line first, c if column 1st */
X    EXTERN char cxybeg[8] = {27,'Y',0,0,0,0,0,0};	/* start xy control seq  */
X    EXTERN char cxymid[8] = {0,0,0,0,0,0,0,0};  /* middle xy control seq */
X    EXTERN char cxyend[8] = {0,0,0,0,0,0,0,0};  /* end sequence */
X    EXTERN char cerrbg[8] = {27,'p',0,0,0,0,0,0}; /* string to print when errors start */
X    EXTERN char cerred[8] = {27,'q',0,0,0,0,0,0};  /* when errors done */
X    EXTERN char ctopb[8] = {27,'I',0,0,0,0,0,0}; /* top blanks = reverse linefeed */
X    EXTERN char cinit[20] = {27,'w',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X	/* start up sequence */
X    EXTERN char cendit[20] = {27,'v',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X	/* to end session */
X    EXTERN char cbotb[8] = {10,0,0,0,0,0,0,0};  /* bottom blank line sequence */
X    EXTERN char celin[8] = {27,'K',0,0,0,0,0,0};	    /* erase to end of line */
X    EXTERN char cescr[8] = {27,'J',0,0,0,0,0,0};	    /* erase to end of screen */
X    EXTERN char cclears[8]={27,'E',0,0,0,0,0,0};	/* clear screen, home cusor */
X    EXTERN char cdelchr[8]={27,'M',0,0,0,0,0,0};	/* delete char on screen */
X    EXTERN char ccsrcm[8] = {27,'y','4',0,0,0,0,0};	/* set cursor to command mode */
X    EXTERN char ccsrin[8] = {27,'x','4',0,0,0,0,0};	/* set cursor to insert mode */
X    EXTERN char ciline[8] = {27,'L',0,0,0,0,0,0};	    /* insert a line */
X    EXTERN char ckline[8] = {27,'M',0,0,0,0,0,0};	    /* kill a line */
X    EXTERN char cundlb[8] = {27,'p',0,0,0,0,0,0};	/* turn on underline */
X    EXTERN char cundle[8] = {27,'q',0,0,0,0,0,0};	/* turn off underline */
X    EXTERN char cboldb[8] = {27,'p',0,0,0,0,0,0};	/* start bold */
X    EXTERN char cbolde[8] = {27,'q',0,0,0,0,0,0};	/* end bold */
X
X    EXTERN int dsp_mem = 0;
X    EXTERN int ddline = 16;
X    EXTERN int dscrl = 0;
X    EXTERN int dxcase = 0;
X#ifdef USECTRLZ
X    EXTERN int usecz = 1;
X#else
X    EXTERN int usecz = 0;
X#endif
X    EXTERN int autoin = 0;	/* TRUE if auto indent, FALSE otherwise */
X    EXTERN int logdef = 0;	/* backup log file by default 0->no, 1-> yes */
X    EXTERN char delkey = 8;
X    EXTERN int tvlins = 24;	/* number of lines on screen */
X    EXTERN int tvcols = 80;	/* number of columns on screen */
X    EXTERN int tvhardlines = 24;	/* real number of lines */
X    EXTERN int tvx = 0;        /* current x cursor position */
X    EXTERN int tvy = 0;        /* current y cursor position */
X    EXTERN int tvdlin = 0;     /* the "active" display line */
X    EXTERN int dsplin = 0;     /* the default display line */
X    EXTERN int tabspc = 8;     /* spacing for tabs */
X    EXTERN int leftmg = 0;	/* left margin of display */
X    EXTERN int wraplm = 0;	/* auto wrap? */
X    EXTERN int isibmpc = 0;	/* for possible use with a general version */
X#endif
X/* ********************************************************************** */
X#ifdef HP2621
X    EXTERN int addx = -1;		/* amount to add to get x */
X    EXTERN int addy = -1;			/* to get y */
X    EXTERN char cxychr = 1;		/* true if convert xy bin to ascii */
X    EXTERN char cversn[12] = "HP2621x";     /* a version to identify config */
X    EXTERN char cxy1st = 'l';			/* l if line first, c if column 1st */
X    EXTERN char cxybeg[8] = {27,'&','a',0,0,0,0,0};	/* start xy control seq  */
X    EXTERN char cxymid[8] = {'y',0,0,0,0,0,0,0};  /* middle xy control seq */
X    EXTERN char cxyend[8] = {'C',0,0,0,0,0,0,0};  /* end sequence */
X    EXTERN char cerrbg[8] = {7,0,0,0,0,0,0,0}; /* string to print when errors start */
X    EXTERN char cerred[8] = {0,0,0,0,0,0,0,0};  /* when errors done */
X    EXTERN char ctopb[8] = {27,'L',0,0,0,0,0,0}; /* top blanks = reverse linefeed */
X    EXTERN char cinit[20] = {27,'&','j','@',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X	/* start up sequence */
X    EXTERN char cendit[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X	/* to end session */
X    EXTERN char cbotb[8] = {10,0,0,0,0,0,0,0};  /* bottom blank line sequence */
X    EXTERN char celin[8] = {27,'K',0,0,0,0,0,0};	    /* erase to end of line */
X    EXTERN char cescr[8] = {27,'J',0,0,0,0,0,0};	    /* erase to end of screen */
X    EXTERN char cclears[8]={27,'H',27,'J',0,0,0,0};	/* clear screen, home cusor */
X    EXTERN char cdelchr[8]={27,'P',0,0,0,0,0,0};	/* delete char on screen */
X    EXTERN char ccsrcm[8] = {27,'&','j','@',0,0,0,0};	/* set cursor to command mode */
X    EXTERN char ccsrin[8] = {27,'&','j','B',0,0,0,0};	/* set cursor to insert mode */
X    EXTERN char ciline[8] = {27,'L',0,0,0,0,0,0};	    /* insert a line */
X    EXTERN char ckline[8] = {27,'M',0,0,0,0,0,0};	    /* kill a line */
X    EXTERN char cundlb[8] = {0,'p',0,0,0,0,0,0};	/* turn on underline */
X    EXTERN char cundle[8] = {0,'q',0,0,0,0,0,0};	/* turn off underline */
X    EXTERN char cboldb[8] = {0,'p',0,0,0,0,0,0};	/* start bold */
X    EXTERN char cbolde[8] = {0,'q',0,0,0,0,0,0};	/* end bold */
X
X    EXTERN int dsp_mem = 1;
X    EXTERN int ddline = 12;
X    EXTERN int dscrl = 6;
X    EXTERN int dxcase = 0;
X#ifdef USECTRLZ
X    EXTERN int usecz = 1;
X#else
X    EXTERN int usecz = 0;
X#endif
X    EXTERN int autoin = 0;	/* TRUE if auto indent, FALSE otherwise */
X    EXTERN int logdef = 0;	/* backup log file by default 0->no, 1-> yes */
X    EXTERN char delkey = 8;
X    EXTERN int tvlins = 24;	/* number of lines on screen */
X    EXTERN int tvcols = 79;	/* number of columns on screen */
X    EXTERN int tvhardlines = 24;	/* real number of lines */
X    EXTERN int tvx = 0;        /* current x cursor position */
X    EXTERN int tvy = 0;        /* current y cursor position */
X    EXTERN int tvdlin = 0;     /* the "active" display line */
X    EXTERN int dsplin = 0;     /* the default display line */
X    EXTERN int tabspc = 8;     /* spacing for tabs */
X    EXTERN int leftmg = 0;	/* left margin of display */
X    EXTERN int wraplm = 0;	/* auto wrap? */
X    EXTERN int isibmpc = 0;	/* for possible use with a general version */
X#endif
X/* ********************************************************************** */
SHAR_EOF
echo ALL DONE!
exit 0

