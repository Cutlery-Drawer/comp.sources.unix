Subject:  v22i025:  MIT Athena delete/undelete programs, release 2, Part01/03
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 595a9f60 8a64bdca e9307896 eac15f1c

Submitted-by: "Jonathan I. Kamens" <jik@pit-manager.mit.edu>
Posting-number: Volume 22, Issue 25
Archive-name: undel2/part01

Delete marks files and directories for later permanent removal (by
renaming them with a prefix of ".#").  Files accidentally marked for
deletion can be recovered using undelete(1).  Marked files are
periodically removed automatically by the system; they can also be removed
on demand (see purge(1) and expunge(1) for details).  Users can list files
which have been marked for removal but have not yet been removed using
lsdel(1).

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  MANIFEST Makefile PATCHLEVEL README col.h delete.h
#   delete_errs.et directories.h errors.c errors.h expunge.h lsdel.h
#   man1 man1/delete.1 man1/expunge.1 man1/lsdel.1 man1/purge.1
#   man1/undelete.1 mit-copyright.h pattern.h shell_regexp.c
#   shell_regexp.h stack.c stack.h undelete.h util.h
# Wrapped by rsalz@papaya.bbn.com on Mon May  7 16:53:57 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1150 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	
X Makefile                   1	
X PATCHLEVEL                 1	
X README                     1	
X col.c                      2	
X col.h                      1	
X delete.c                   3	
X delete.h                   1	
X delete_errs.et             1	
X directories.c              3	
X directories.h              1	
X errors.c                   1	
X errors.h                   1	
X expunge.c                  2	
X expunge.h                  1	
X lsdel.c                    2	
X lsdel.h                    1	
X man1                       1	
X man1/delete.1              1	
X man1/expunge.1             1	
X man1/lsdel.1               1	
X man1/purge.1               1	
X man1/undelete.1            1	
X mit-copyright.h            1	
X pattern.c                  3	
X pattern.h                  1	
X shell_regexp.c             1	
X shell_regexp.h             1	
X stack.c                    1	
X stack.h                    1	
X undelete.c                 2	
X undelete.h                 1	
X util.c                     2	
X util.h                     1	
END_OF_FILE
if test 1150 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(4803 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#     Copyright 1988 Massachusetts Institute of Technology.
X#
X#     For copying and distribution information, see the file
X#     "mit-copyright.h".
X#
X#     $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/Makefile,v $
X#     $Author: jik $
X#     $Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/Makefile,v 1.17 89/12/20 15:14:34 jik Exp $
X#
X
XDESTDIR=
XTARGETS= 	delete undelete expunge purge lsdel
XINSTALLDIR= 	/bin/athena
XMANDIR=		/usr/man
XMANSECT=	1
XCC= 		cc
XCOMPILE_ET= 	compile_et
XLINT= 		lint
XDEFINES=	-DAFS_MOUNTPOINTS
XINCLUDES=	-I/usr/include\
X		-I/afs/athena.mit.edu/astaff/project/afsdev/build/$(MACHINE)/include
XCFLAGS= 	-O $(INCLUDES) $(DEFINES) $(CDEBUGFLAGS)
XLDFLAGS=	-L/usr/athena/lib\
X		-L/afs/athena.mit.edu/astaff/project/afsdev/build/$(MACHINE)/lib/afs
XLIBS= 		-lcom_err -lsys
XLINTFLAGS=	$(DEFINES) $(INCLUDES) $(CDEBUGFLAGS) -u
XLINTLIBS=	
XSRCS= 		delete.c undelete.c directories.c pattern.c util.c\
X		expunge.c lsdel.c col.c shell_regexp.c\
X		errors.c stack.c
XINCS= 		col.h delete.h directories.h expunge.h lsdel.h\
X		mit-copyright.h pattern.h undelete.h util.h\
X		shell_regexp.h errors.h stack.h
XETS=		delete_errs.h delete_errs.c
XETSRCS=		delete_errs.et
X
XMANS= 		man1/delete.1 man1/expunge.1 man1/lsdel.1 man1/purge.1\
X		man1/undelete.1
X
XETLIBSRCS=	et/Makefile et/com_err.3 et/compile_et.1\
X		et/com_err.texinfo.Z.uu et/error_table.y et/et_lex.lex.l\
X		et/texinfo.tex.Z.uu et/*.c et/*.h et/*.et
XARCHIVE=	README Makefile PATCHLEVEL $(SRCS) $(INCS) $(ETSRCS)\
X		$(MANS) 
XARCHIVEDIRS= 	man1 et et/profiled
X
XDELETEOBJS= 	delete.o util.o delete_errs.o errors.o
XUNDELETEOBJS= 	undelete.o directories.o util.o pattern.o\
X		shell_regexp.o delete_errs.o errors.o stack.o
XEXPUNGEOBJS= 	expunge.o directories.o pattern.o util.o col.o\
X		shell_regexp.o delete_errs.o errors.o stack.o
XLSDELOBJS= 	lsdel.o util.o directories.o pattern.o col.o\
X		shell_regexp.o delete_errs.o errors.o stack.o
X
XDELETESRC= 	delete.c util.c delete_errs.c errors.c
XUNDELETESRC= 	undelete.c directories.c util.c pattern.c\
X		shell_regexp.c delete_errs.c errors.c stack.c
XEXPUNGESRC= 	expunge.c directories.c pattern.c util.c col.c\
X		shell_regexp.c delete_errs.c errors.c stack.c
XLSDELSRC= 	lsdel.c util.c directories.c pattern.c col.c\
X		shell_regexp.c delete_errs.c errors.c stack.c
X
X.SUFFIXES: .c .h .et
X
X.et.h: $*.et
X	${COMPILE_ET} $*.et
X.et.c: $*.et
X	${COMPILE_ET} $*.et
X
Xall: $(TARGETS)
X
Xlint_all: lint_delete lint_undelete lint_expunge lint_lsdel
X
Xinstall: bin_install man_install
X
X# Errors are ignored on bin_install and man_install because make on
X# some platforms, in combination with the shell, does really stupid
X# things and detects an error where there is none.
X
Xman_install:
X	-for i in $(TARGETS) ; do\
X	  install -c man1/$$i.1\
X		$(DESTDIR)$(MANDIR)/man$(MANSECT)/$$i.$(MANSECT);\
X	done
X
Xbin_install: $(TARGETS)
X	-for i in $(TARGETS) ; do\
X          if [ -f $(DESTDIR)$(INSTALLDIR)/$$i ]; then\
X            mv $(DESTDIR)$(INSTALLDIR)/$$i $(DESTDIR)$(INSTALLDIR)/.#$$i ; \
X          fi; \
X	  install -c -s $$i $(DESTDIR)$(INSTALLDIR) ; \
X        done
X
Xdelete: $(DELETEOBJS)
X	$(CC) $(LDFLAGS) $(CFLAGS) -o delete $(DELETEOBJS) $(LIBS)
X
Xsaber_delete:
X	#setopt program_name delete
X	#load $(LDFLAGS) $(CFLAGS) $(DELETESRC) $(LIBS)
X
Xlint_delete: $(DELETESRC)
X	$(LINT) $(LINTFLAGS) $(DELETESRC) $(LINTLIBS)
X
Xundelete: $(UNDELETEOBJS)
X	$(CC) $(LDFLAGS) $(CFLAGS) -o undelete $(UNDELETEOBJS) $(LIBS)
X
Xsaber_undelete:
X	#setopt program_name undelete
X	#load $(LDFLAGS) $(CFLAGS) $(UNDELETESRC) $(LIBS)
X
Xlint_undelete: $(UNDELETESRC)
X	$(LINT) $(LINTFLAGS) $(UNDELETESRC) $(LINTLIBS)
X
Xexpunge: $(EXPUNGEOBJS)
X	$(CC) $(LDFLAGS) $(CFLAGS) -o expunge $(EXPUNGEOBJS) $(LIBS)
X
Xsaber_expunge:
X	#setopt program_name expunge
X	#load $(LDFLAGS) $(CFLAGS) $(EXPUNGESRC) $(LIBS)
X
Xlint_expunge: $(EXPUNGESRC)
X	$(LINT) $(LINTFLAGS) $(EXPUNGESRC) $(LINTLIBS)
X
Xpurge: expunge
X	ln -s expunge purge
X
Xlsdel: $(LSDELOBJS)
X	$(CC) $(LDFLAGS) $(CFLAGS) -o lsdel $(LSDELOBJS) $(LIBS)
X
Xlint_lsdel: $(LSDELSRC)
X	$(LINT) $(LINTFLAGS) $(LSDELSRC) $(LINTLIBS)
X
Xsaber_lsdel:
X	#setopt program_name lsdel
X	#load $(LDFLAGS) $(CFLAGS) $(LSDELSRC) $(LIBS)
X
Xtar: $(ARCHIVE)
X	tar cvf - $(ARCHIVE) $(ETLIBSRCS) | compress > delete.tar.Z
X
Xshar: $(ARCHIVE)
X	makekit -oMANIFEST -h2 MANIFEST $(ARCHIVEDIRS) $(ARCHIVE) $(ETLIBSRCS)
X
Xpatch: $(ARCHIVE)
X	makepatch $(ARCHIVE)
X	mv patch delete.patch`cat PATCHLEVEL`
X	shar delete.patch`cat PATCHLEVEL` > delete.patch`cat PATCHLEVEL`.shar
X
Xclean:
X	-rm -f *~ *.bak *.o delete undelete lsdel expunge purge\
X		delete_errs.h delete_errs.c
X
Xdepend: $(SRCS) $(INCS) $(ETS)
X	/usr/athena/makedepend -v $(CFLAGS) -s'# DO NOT DELETE' $(SRCS)
X
X$(DELETEOBJS): delete_errs.h
X$(EXPUNGEOBJS): delete_errs.h
X$(UNDELETEOBJS): delete_errs.h
X$(LSDELOBJS): delete_errs.h
X
X# DO NOT DELETE THIS LINE -- makedepend depends on it
END_OF_FILE
if test 4803 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'PATCHLEVEL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PATCHLEVEL'\"
else
echo shar: Extracting \"'PATCHLEVEL'\" \(2 characters\)
sed "s/^X//" >'PATCHLEVEL' <<'END_OF_FILE'
X9
END_OF_FILE
if test 2 -ne `wc -c <'PATCHLEVEL'`; then
    echo shar: \"'PATCHLEVEL'\" unpacked with wrong size!
fi
# end of 'PATCHLEVEL'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(5067 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X			       OVERVIEW
X
XThis archive contains the sources for five programs (well, actually,
Xfour, since one is a symbolic link):
X
X	delete
X	undelete
X	expunge
X	purge
X	lsdel
X
XThe programs were written at Project Athena in response to the problem
Xwhich many novice Unix users have with accidentally deleting files
Xthey didn't want to delete (Hell, I've done it :-).
X
X
X			 SUPPORTED PLATFORMS
X
XI've personally compiled these sources under 4.3BSD on VAXen and IBM
XRT/PC's, under Mach on the NeXT Machine, under Ultrix on the
XDECstation 3100, and under SunOS 4.0, and I assume they should compile
Xwith minimal trouble on other architectures.  If you make it compile
Xon another platform and you have to make changes, please send me
Xpatches.
X
X
X			 WHAT YOU NEED TO DO
X
X1. Compile the com_err library (see below for more details) found in
X   the sub-directory et, and install it if you want to (you'll have to
X   modify the delete Makefile a bit if you don't).
X
X2. Edit the Makefile to fit your site.  See below for details.
X
X3. Compile away!  Type "make" to make without installing, or "make
X   install" to install binaries and man pages in the locations you
X   specified when you edited the Makefile.
X
X
X		       CUSTOMIZING THE MAKEFILE
X
XYou are probably going to have to do one or more of the following to
Xmake the Makefile work for you.
X
X1. Change the install binary directory and install man page directory
X   (and possibly man section).
X
X2. Change the "-I/usr/include" to point to the et subdirectory if you
X   have not installed the com_err header file in a standard location,
X   or to wherever you have installed it.  Change the COMPILE_ET
X   variable to use et/compile_et if you haven't installed the
X   compile_et utility.  Change the -L/usr/athena/lib flag to point to
X   wherever you have installed the library, or to the et subdirectory
X   if you have not.
X
X3. Deal with the AFS_MOUNTPOINTS flag, which specifies whether
X   undelete, expunge and lsdel will check for Andrew File System mount
X   points in addition to standard Unix mount points.
X
X   a. If you undefine it, remove the -I and -L flags that point to AFS
X      includes and libraries, and remove the "-lsys" from the LIBS
X      variable.
X
X   b. If you leave it defined, change the -I and -L flags to point to
X      wherever you keep your AFS includes and libraries.
X
X
X			   COM_ERR LIBRARY
X
XThis is the second release of this package.  Unlike the first release,
Xthis release requires (for error-handling) a library called com_err,
Xwhich was written by members of the MIT Student Information Processing
XBoard (SIPB).  Along with that library comes a utility called
Xcompile_et.  The sources to the com_err library and compile_et are
Xincluded with the sources to the delete package; you should compile
Xthem and then either install them in a "standard location" on your
Xmachine or modify the delete Makefile so that it knows where they are.
XThe delete Makefile does not compile them by default, since they are
Xalready compiled and installed at Athena, so you should compile and
Xinstall them separately from delete etc.
X
XThe files texinfo.tex and com_err.texinfo in the et sources are
Xcompressed and uuencoded because they have control characters in them.
XThey have to be uudecoded and uncompressed before using them.  Neither
Xof them is necessary for just building the library and using it to
Xbuild delete et al -- they are just documentation about the library.
X
XThe version of the com_err library I've included here is "in flux" --
Xits authors tell me that several enhancements are planned for the near
Xfuture.  When the library is worked into a more final form, it will
Xprobably be distributed (to comp.sources.unix, etc.) separately from
Xdelete.
X
X
X			     FINAL NOTES
X
XThe final patch level used for the first release of this package was
Xpatch level 2.  Since this is a whole new release, and there were some
Xunofficial patches here and there during the life of the first
Xrelease, I upped the patch level to 5 for the first distribution of
Xthe second release of the delete package.
X
XThere were NO REAL PATCHES numbered 3, 4, or 5 -- I simply chose to
Xjump from 2 to 5 when issuing a new release.  Therefore, if you have
Xdelete sources with a patch level less than 5, you will need to get a
Xwhole new copy of the sources.
X
XIn other words, treat patch level 5 as patch level 0 for all intents
Xand purposes (gee, tha sounds stupid, but you get the idea :-).  See
Xthe file PATCHLEVEL in the sources to find out what patch level of the
Xsources you currently have in your position (if you're reading this
XREADME file out of a source distribution, you almost definitely have
Xpatch level 6 or later).
X
XAs usual, suggestions and bug fixes are always welcomed.
X
XMy address:
X
XJonathan Kamens			              USnail:
XMIT Project Athena				11 Ashford Terrace
Xjik@Athena.MIT.EDU				Allston, MA  02134
XOffice: 617-253-8495			      Home: 617-782-0710
X
XP.S. Please see the file "mit-copyright.h" for copying and
Xredistribution information.  Copyright 1989 Massachusetts Institute of
XTechnology.  All Rights Reserved.  Etc.
END_OF_FILE
if test 5067 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'col.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'col.h'\"
else
echo shar: Extracting \"'col.h'\" \(1507 characters\)
sed "s/^X//" >'col.h' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/col.h,v $
X * $Author: jik $
X *
X * This header file is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X#include "mit-copyright.h"
X
X/*
X * DEF_COL_WIDTH: the column with to try to use if none is specified.
X * DEF_WAIT: 1 if the program is supposed to wait for stdin to get to
X *           end-of-file and then print out everything in order in
X *           columns by default.  If this is 0, then the default is
X *           for the program to print across instead of down and to
X *           print as it receives input from stdin.
X * DEF_VAR_COLS: if 1, use variable-width columns based on text width.
X *               if 1, DEF_WAIT must be true.
X * DEF_SCR_WIDTH: default screen width
X * DEF_NUM_ITEMS: if 1, number each item
X * DEF_MARGIN: the default margin in between columns of text
X */ 
X#define DEF_COL_WIDTH 20
X#define DEF_WAIT 1
X#define DEF_VAR_COLS 1
X#define DEF_SCR_WIDTH 80
X#define DEF_NUM_ITEMS 1
X#define DEF_MARGIN 2
X /* This is used for when we need a guess as to how long a number will */
X /* be when printed.  Also, if we are supposed to work in wait mode    */
X /* and are not given a maxitems value, this is what is used.          */
X#define DEF_MAX_ITEMS 10000
END_OF_FILE
if test 1507 -ne `wc -c <'col.h'`; then
    echo shar: \"'col.h'\" unpacked with wrong size!
fi
# end of 'col.h'
fi
if test -f 'delete.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'delete.h'\"
else
echo shar: Extracting \"'delete.h'\" \(557 characters\)
sed "s/^X//" >'delete.h' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/delete.h,v $
X * $Author: jik $
X * $Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/delete.h,v 1.4 89/10/23 13:43:22 jik Exp $
X * 
X * This file is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X
X#include "mit-copyright.h"
END_OF_FILE
if test 557 -ne `wc -c <'delete.h'`; then
    echo shar: \"'delete.h'\" unpacked with wrong size!
fi
# end of 'delete.h'
fi
if test -f 'delete_errs.et' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'delete_errs.et'\"
else
echo shar: Extracting \"'delete_errs.et'\" \(1551 characters\)
sed "s/^X//" >'delete_errs.et' <<'END_OF_FILE'
X#     Copyright 1988 Massachusetts Institute of Technology.
X#
X#     For copying and distribution information, see the file
X#     "mit-copyright.h".
X#
X#     $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/delete_errs.et,v $
X#     $Author: jik $
X#     $Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/delete_errs.et,v 1.3 89/12/28 14:44:22 jik Exp $
X#
X
X	et	del
X
Xec REGEXP_MISSING_QUOTED_CHAR,
X	"missing quoted character after backslash"
Xec REGEXP_MISSING_BRACE,
X	"missing ]"
Xec REGEXP_EMPTY_BRACES,
X	"illegal empty braces"
Xec DIR_NOT_DIRECTORY,
X	"internal error: directory operation on non-directory"
Xec DIR_IMPOSSIBLE_ERROR,
X	"interal error: something that shouldn't happen just did"
Xec COL_COLUMNS_TOO_THIN,
X	"possible internal error: listing columns too thin"
Xec DELETE_IS_DOTFILE,
X	"can't delete `.' or `..'"
Xec DELETE_CANT_DEL_DIR,
X	"can't delete (not file)"
Xec DELETE_DIR_NOT_EMPTY,
X	"can't delete (directory not empty)"
Xec DELETE_CANT_DEL_FILE,
X	"can't delete (not directory)"
Xec DELETE_NOT_DELETED,
X	""
Xec UNDEL_NOT_UNDELETED,
X	""
Xec NO_HOME_DIR,
X	"can't find home directory"
Xec INTERNAL_ERROR,
X	"strange internal error"
Xec ENOMATCH,
X	"no match"
Xec EXPUNGE_NOT_EXPUNGED,
X	""
Xec PURGE_TOO_MANY_ARGS,
X	"command takes no arguments"
Xec PAT_NO_FILES_REQUESTED,
X	"internal error: no files requested in call to find_matches or do_match"
Xec PAT_IS_MOUNT,
X	"ignored (is mount point)"
Xec STACK_BAD_OP,
X	"internal error: call to dostack with undefined stack operation"
Xec STACK_EMPTY,
X	"internal error: attempt to pop from empty stack"
X
X	end
X
END_OF_FILE
if test 1551 -ne `wc -c <'delete_errs.et'`; then
    echo shar: \"'delete_errs.et'\" unpacked with wrong size!
fi
# end of 'delete_errs.et'
fi
if test -f 'directories.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'directories.h'\"
else
echo shar: Extracting \"'directories.h'\" \(1542 characters\)
sed "s/^X//" >'directories.h' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/directories.h,v $
X * $Author: jik $
X * $Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/directories.h,v 1.8 89/11/06 19:54:20 jik Exp $
X * 
X * This file is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X
X#include "mit-copyright.h"
X
Xtypedef short Boolean;
X#define True			(Boolean) 1
X#define False			(Boolean) 0
X
X
X#define blk_to_k(x)		(x * DEV_BSIZE / 1024)
X
X#define FOLLOW_LINKS		1
X#define DONT_FOLLOW_LINKS	0
X
X#define DIR_MATCH		1
X#define DIR_NO_MATCH		0
X     
Xtypedef struct filrec {
X     char name[MAXNAMLEN];
X     struct filrec *previous;
X     struct filrec *parent;
X     struct filrec *dirs;
X     struct filrec *files;
X     struct filrec *next;
X     Boolean specified;
X     Boolean freed;
X     struct stat specs;
X} filerec;
X
X
X
Xint add_directory_to_parent();
Xint add_file_to_parent();
Xint add_path_to_tree();
Xint find_child();
Xfilerec *first_in_directory();
Xfilerec *first_specified_in_directory();
Xfilerec *get_cwd_tree();
Xfilerec *get_root_tree();
Xfilerec *next_directory();
Xfilerec *next_in_directory();
Xfilerec *next_leaf();
Xfilerec *next_specified_directory();
Xfilerec *next_specified_in_directory();
Xfilerec *next_specified_leaf();
X
Xint get_leaf_path();
Xint accumulate_names();
X
Xvoid free_leaf();
END_OF_FILE
if test 1542 -ne `wc -c <'directories.h'`; then
    echo shar: \"'directories.h'\" unpacked with wrong size!
fi
# end of 'directories.h'
fi
if test -f 'errors.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'errors.c'\"
else
echo shar: Extracting \"'errors.c'\" \(1495 characters\)
sed "s/^X//" >'errors.c' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/errors.c,v $
X * $Author: jik $
X *
X * This program is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X
X#if (!defined(lint) && !defined(SABER))
X     static char rcsid_errors_c[] = "$Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/errors.c,v 1.2 89/11/06 21:27:20 jik Exp $";
X#endif
X
X#include <varargs.h>
X#include <com_err.h>
X#include <stdio.h>
X#include "delete_errs.h"
X#include "mit-copyright.h"
X
Xchar *whoami;
Xint error_reported = 1;
Xint error_occurred = 0;
Xint report_errors = 1;
Xint error_code = 0;
X
X/*
X * Proper use of this procedure requires strict adherance to the way
X * it is supposed to be used by all procedures in a program.  Whenever
X * there is an error, set_error must be called with the error value.
X * Then, either the procedure that detects the error must call
X * error(), or it must pass the error up to its parent for the parent
X * to report.
X */
X
X
Xvoid error(str)
Xchar *str;
X{
X     if (report_errors && (! error_reported)) {
X	  if (*str)
X	       fprintf(stderr, "%s: %s: %s\n", whoami, str,
X		       error_message(error_code));
X	  else
X	       fprintf(stderr, "%s: %s\n", whoami, error_message(error_code));
X     }
X     error_reported = 1;
X}
END_OF_FILE
if test 1495 -ne `wc -c <'errors.c'`; then
    echo shar: \"'errors.c'\" unpacked with wrong size!
fi
# end of 'errors.c'
fi
if test -f 'errors.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'errors.h'\"
else
echo shar: Extracting \"'errors.h'\" \(883 characters\)
sed "s/^X//" >'errors.h' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/errors.h,v $
X * $Author: jik $
X * $Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/errors.h,v 1.2 89/11/06 21:27:23 jik Exp $
X * 
X * This file is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X#include "mit-copyright.h"
X
Xextern char *whoami;
Xextern int error_reported;
Xextern int error_occurred;
Xextern int report_errors;
Xextern int error_code;
X
Xvoid error();
X
X#define set_error(cd) {error_code = cd; error_reported = 0; error_occurred = 1;}
X#define set_warning(cd) {error_code = cd; error_reported = 0;}
X#define set_status(cd) {error_code = cd;}
END_OF_FILE
if test 883 -ne `wc -c <'errors.h'`; then
    echo shar: \"'errors.h'\" unpacked with wrong size!
fi
# end of 'errors.h'
fi
if test -f 'expunge.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expunge.h'\"
else
echo shar: Extracting \"'expunge.h'\" \(656 characters\)
sed "s/^X//" >'expunge.h' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/expunge.h,v $
X * $Author: jik $
X * $Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/expunge.h,v 1.4 89/10/23 13:37:05 jik Exp $
X * 
X * This file is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X#include "mit-copyright.h"
X
X#define ERROR_MASK		1
X#define NO_DELETE_MASK		2
X#define NO_TIMEOUT_MASK		4
X
Xint get_the_files();
END_OF_FILE
if test 656 -ne `wc -c <'expunge.h'`; then
    echo shar: \"'expunge.h'\" unpacked with wrong size!
fi
# end of 'expunge.h'
fi
if test -f 'lsdel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lsdel.h'\"
else
echo shar: Extracting \"'lsdel.h'\" \(623 characters\)
sed "s/^X//" >'lsdel.h' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/lsdel.h,v $
X * $Author: jik $
X * $Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/lsdel.h,v 1.4 89/10/23 13:33:51 jik Exp $
X * 
X * This file is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X#include "mit-copyright.h"
X
X#define ERROR_MASK 1
X#define NO_DELETE_MASK 2
X
Xint get_the_files();
END_OF_FILE
if test 623 -ne `wc -c <'lsdel.h'`; then
    echo shar: \"'lsdel.h'\" unpacked with wrong size!
fi
# end of 'lsdel.h'
fi
if test ! -d 'man1' ; then
    echo shar: Creating directory \"'man1'\"
    mkdir 'man1'
fi
if test -f 'man1/delete.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/delete.1'\"
else
echo shar: Extracting \"'man1/delete.1'\" \(4217 characters\)
sed "s/^X//" >'man1/delete.1' <<'END_OF_FILE'
X.\"	$Source: /afs/athena.mit.edu/user/j/jik/src/delete/man1/RCS/delete.1,v $
X.\"	$Author: jik $
X.\"	$Header: /afs/athena.mit.edu/user/j/jik/src/delete/man1/RCS/delete.1,v 1.5 89/09/14 03:42:51 jik Exp $
X.\"
X.\" Copyright 1989 by the Massachusetts Institute of Technology.  All
X.\" rights reserved.  The file /usr/include/mit-copyright.h specifies
X.\" the terms and conditions for redistribution.
X.\"
X.\"
X.TH DELETE 1 "January 26, 1988" "MIT Project Athena"
X.ds ]W MIT Project Athena
X.SH NAME
Xdelete \- a recoverable file-deletion utility
X.SH SYNOPSIS
X.B delete
X[
X.B \-r
X] [
X.B \-i
X] [
X.B \-f
X] [
X.B \-n
X] [
X.B \-v
X] [
X.B \-e
X] [
X.B \-F
X] [
X.B \-D
X] [
X.B \-\|\-
X] filename ...
X.PP
X.SH DESCRIPTION
X.I Delete
Xmarks files and directories for later permanent removal (by renaming
Xthem with a prefix of \fI.#\fR).  Files accidentally marked for deletion
Xcan be recovered using
X.I undelete(1).
XMarked files are periodically
Xremoved automatically by the system; they can also be removed on demand
X(see \fIpurge\fR(1) and \fIexpunge\fR(1) for details).
XUsers can list files which have been marked for
Xremoval but have not yet been removed using \fIlsdel\fR(1).
X.PP
XIf the user does not have write permission to a file, its permissions
Xare printed and the user is asked whether the file should be removed.
XIf the first character of the response line is \fIy\fR the file is
Xremoved, otherwise it remains.
X.PP
XUsers wishing to retain the user interface of \fIrm\fR(1)
Xand \fIrmdir\fR(1)
Xwhile still being able to recover accidentally removed files can do so
Xby aliasing
X.I rm
Xto
X.I delete \-F \-e
Xand
X.I rmdir
Xto
X.I delete \-D \-e
X(see below).
X.SH OPTIONS
X.I Delete
Xaccepts the following command-line options:
X.TP
X.B \-r
XIf a designated filename is a non-empty directory,
X.I delete
Xwill signal an error unless the
X.B \-r
Xoption is specified.  In that case,
X.I delete
Xrecursively deletes the directory's entire contents and the directory
Xitself.  If the
X.B \-F
Xoption is specified (see below),
X.I delete
Xwill signal an error even if the directory is empty.
X.TP
X.B \-i
XCauses
X.I delete
Xto ask whether to delete each file, and, in recursive
Xmode, whether to examine each directory.
X.TP
X.B \-f
XPrevents
X.I delete
Xfrom asking any questions and from reporting any errors.
X.TP
X.B \-n
XNo file removals are performed.  Instead,
X.I delete
Xprints to the standard output the files that it would remove were the
X.B \-n
Xoption not specified.
X.TP
X.B \-v
XCauses
X.I delete
Xto report each file as it is deleted.
X.TP
X.B \-e
XCauses
X.I delete
Xto emulate \fIrm\fR(1) and \fIrmdir\fR(1) as much as it can (i.e.
Xerror and status messages and other peculiarities of \fIrm\fR(1) and
X\fIrmdir\fI(1)).
X.TP
X.B \-F
XCauses
X.I delete
Xto emulate
X.I rm
Xby preventing it from removing even empty directories when the
X.B \-r
Xoption is not specified.
X.TP
X.B \-D
XCauses
X.I delete
Xto emulate
X.I rmdir
Xby preventing it from removing anything but empty directories.
X.TP
X.B \-\|\-
XTwo dashes indicate that all the arguments following it are to be treated as
Xfile names, even if they start with a dash.
X.SH "SEE ALSO"
Xundelete(1), purge(1), expunge(1), lsdel(1), rm(1), rmdir(1)
X.SH AUTHOR
XJonathan I. Kamens (MIT-Project Athena)
X.SH COPYRIGHT
XCopyright (c) 1989 by the Massachusetts Institute of Technology.
X.PP
XAll rights reserved.
X.PP
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted,
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in
Xsupporting documentation, and that the name of the Massachusetts
XInstitute of Technology (M.I.T.) not be used in advertising or publicity
Xpertaining to distribution of the software without specific, written
Xprior permission.
X.PP
XM.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XM.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X
X
END_OF_FILE
if test 4217 -ne `wc -c <'man1/delete.1'`; then
    echo shar: \"'man1/delete.1'\" unpacked with wrong size!
fi
# end of 'man1/delete.1'
fi
if test -f 'man1/expunge.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/expunge.1'\"
else
echo shar: Extracting \"'man1/expunge.1'\" \(4062 characters\)
sed "s/^X//" >'man1/expunge.1' <<'END_OF_FILE'
X.\"	$Source: /afs/athena.mit.edu/user/j/jik/src/delete/man1/RCS/expunge.1,v $
X.\"	$Author: jik $
X.\"	$Header: /afs/athena.mit.edu/user/j/jik/src/delete/man1/RCS/expunge.1,v 1.6 89/11/02 07:10:08 jik Exp $
X.\"
X.\" Copyright 1989 by the Massachusetts Institute of Technology.  All
X.\" rights reserved.  The file /usr/include/mit-copyright.h specifies
X.\" the terms and conditions for redistribution.
X.\"
X.\"
X.TH EXPUNGE 1 "January 27, 1988" "MIT Project Athena"
X.ds ]W MIT Project Athena
X.SH NAME
Xexpunge, purge \- permanent removal of \fIdelete\fR\^d files
X.SH SYNOPSIS
X.B expunge
X[
X.B \-r
X] [
X.B \-i
X] [
X.B \-f
X] [
X.B \-t \fIn\fR
X] [
X.B \-n
X] [
X.B \-v
X] [
X.B \-l
X] [
X.B \-s
X] [
X.B \-m
X] [
X.B \-y
X] [
X.B \-\|\-
X] [ filename [ ... ]]
X.PP
X.B purge
X.PP
X.SH DESCRIPTION
X.I Expunge
Xand
X.I purge
Xpermanently remove files which have been marked for deletion using
X\fIdelete\fR(1).  Files removed with \fIexpunge\fR or \fIpurge\fR
Xcannot be recovered, and care should therefore be exercised in the
Xuse of these utilities.
X.PP
X.I Purge
Xis a simple utility which takes no command-line arguments.  When it is
Xexecuted, it searches through the user's entire home directory and
Xfinds all files that have been marked for deletion.  It then displays
Xa list of the files where are to be removed and prompts for
Xconfirmation.  A response from the user starting with the letter
X\fIy\fR will cause the files to be permanently expunged.
X.PP
XBecause
X.I purge
Xsearches through the user's entire home directory, it can take quite a
Xwhile to complete its search.  This is normal.
X.PP
XThe filenames passed to
X.I expunge
Xon the command-line can be directories (deleted or not deleted) or
Xdeleted files.  Deleted files or directories are always completely
Xexpunged, while the treatment of non-deleted directories depends on
Xthe
X.BR \-r
Xcommand-line option (see below).  If no command-line filenames are
Xspecified,
X.I expunge
Xdefaults to the current working directory.
X.PP
XFor information about wildcard use with \fIexpunge\fR, please see
X\fIundelete\fR(1).
X.PP
X.SH OPTIONS
X.I Expunge
Xaccepts the following command-line options:
X.TP
X.B \-r
XWhen a non-deleted directory is passed to \fIexpunge\fR, the 
X.BR \-r
Xoption causes the directory to be searced recursively for deleted
Xfiles.  If the recursive option is \fInot\fR specified, only the
Xdirect children of the non-deleted directory are examined.  A
Xrecursive search of a large directory can take quite a while.
X.TP
X.B \-i
XThe user is prompted for confirmation with the name of the file and
Xits size in kilobytes before each file or directory is
Xremoved.
X.TP
X.B \-f
XUsed in conjunction with the
X.BR \-l
Xoption, this option prevents 
X.I expunge
Xfrom prompting for confirmation after listing all the files that are
Xtoo be deleted.  Furthermore, it prevents the printing of error
Xmessages.
X.TP
X.B \-t\fIn\fR
XSpecifies the minimum age (in days) of files to be expunged, measured
Xas the length of time since the last file modification.
X.TP
X.B \-n
XNo file expunges are performed.  Instead,
X.I expunge
Xprints to the standard output the files that it would expunge were the
X.BR \-n
Xoption not specified.
X.TP
X.B \-v
XCauses 
X.I expunge
Xto report each file as it is expunged, as well as the size of the file
Xand a running total of the number of kilobytes expunged.
X.TP
X.B \-l
XCauses 
X.I expunge
Xto list all found files before expunging them, similar to the actions
Xof
X.I purge.
X.TP
X.B \-s
XSymbolic links are followed when searching for deleted files.
X.TP
X.B \-m
XMount points are followed when searching for deleted files.
X.TP
X.B \-y
XThe total number of kilobytes expunged is printed after
X.I expunge
Xis finished removing files.
X.TP
X.B \-\|\-
XTwo dashes indicate that all arguments following it are to be treated
Xas file names, even if they start with a dash.
X.SH "SEE ALSO"
Xdelete(1), undelete(1), lsdel(1), rm(1), rmdir(1)
X.SH AUTHOR
XJonathan I. Kamens (MIT-Project Athena)
X.SH RESTRICTIONS
XCopyright (c) 1989 by the Massachusetts Institute of Technology.  All
Xrights reserved.
X.IR Delete (1)
Xspecifies the terms and conditions for redistribution.
END_OF_FILE
if test 4062 -ne `wc -c <'man1/expunge.1'`; then
    echo shar: \"'man1/expunge.1'\" unpacked with wrong size!
fi
# end of 'man1/expunge.1'
fi
if test -f 'man1/lsdel.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/lsdel.1'\"
else
echo shar: Extracting \"'man1/lsdel.1'\" \(2152 characters\)
sed "s/^X//" >'man1/lsdel.1' <<'END_OF_FILE'
X.\"	$Source: /afs/athena.mit.edu/user/j/jik/src/delete/man1/RCS/lsdel.1,v $
X.\"	$Author: jik $
X.\"	$Header: /afs/athena.mit.edu/user/j/jik/src/delete/man1/RCS/lsdel.1,v 1.5 89/11/02 07:12:21 jik Exp $
X.\"
X.\" Copyright 1989 by the Massachusetts Institute of Technology.  All
X.\" rights reserved.  The file /usr/include/mit-copyright.h specifies
X.\" the terms and conditions for redistribution.
X.\"
X.\"
X.TH LSDEL 1 "January 27, 1988" "MIT Project Athena"
X.ds ]W MIT Project Athena
X.SH NAME
Xlsdel \- list deleted files
X.SH SYNOPSIS
X.B lsdel
X[
X.B \-d
X] [
X.B \-r
X] [
X.B \-t \fIn\fR
X] [
X.B \-s
X] [
X.B \-m
X] [
X.B \-y
X] [ filename [ ... ]]
X.PP
X.SH DESCRIPTION
X.I Lsdel
Xlists files that have been marked for deletion by the \fIdelete\fR(1)
Xprogram.
X.PP
XFor information about using wildcards with \fIlsdel\fR, see
X\fIundelete\fR(1).
X.PP
XFilenames passed to \fIlsdel\fR can be directories (non-deleted or
Xdeleted) or deleted files.  If a non-deleted directory is specified,
Xlsdel lists the deleted contents of that directory.  If the
X.BR \-r
Xoption is specified, all non-deleted children of the directory will be
Xsearched recursively for deleted files.  If no command-line filenames
Xare specified,
X.I lsdel
Xdefaults to the current working directory.
X.PP
X.I Lsdel
Xrecursively lists deleted directories by default.  This can be
Xdisabled with the
X.BR \-d
Xoption, which causes directory names, rather than their contents, to
Xbe listed.
X.PP
XThe
X.BR \-t
Xoption allows the user to specify a minimum age, in days, of files to
Xlist.  Only files that have not been modified in \fIn\fR days or more
Xwill be listed.
X.PP
XThe
X.BR \-s
Xoptions tells
X.I lsdel
Xto follow symbolic links when searching for deleted files.  The
X.BR \-m
Xoption does the same thing for mount points.
X.PP
XThe
X.BR \-y
Xoption causes
X.I lsdel
Xto print the total amount of space taken up by all the files it lists.
X.SH "SEE ALSO"
Xdelete(1), undelete(1), purge(1), expunge(1), ls(1)
X.SH AUTHOR
XJonathan I. Kamens (MIT-Project Athena)
X.SH RESTRICTIONS
XCopyright (c) 1989 by the Massachusetts Institute of Technology.  All
Xrights reserved.
X.IR Delete (1)
Xspecifies the terms and conditions for redistribution.
END_OF_FILE
if test 2152 -ne `wc -c <'man1/lsdel.1'`; then
    echo shar: \"'man1/lsdel.1'\" unpacked with wrong size!
fi
# end of 'man1/lsdel.1'
fi
if test -f 'man1/purge.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/purge.1'\"
else
echo shar: Extracting \"'man1/purge.1'\" \(421 characters\)
sed "s/^X//" >'man1/purge.1' <<'END_OF_FILE'
X.\"	$Source: /afs/athena.mit.edu/user/j/jik/src/delete/man1/RCS/purge.1,v $
X.\"	$Author: jik $
X.\"	$Header: /afs/athena.mit.edu/user/j/jik/src/delete/man1/RCS/purge.1,v 1.1 89/01/27 04:50:13 jik Exp $
X.\"
X.\" Copyright 1989 by the Massachusetts Institute of Technology.  All
X.\" rights reserved.  The file /usr/include/mit-copyright.h specifies
X.\" the terms and conditions for redistribution.
X.\"
X.\"
X.so man1/expunge.1
END_OF_FILE
if test 421 -ne `wc -c <'man1/purge.1'`; then
    echo shar: \"'man1/purge.1'\" unpacked with wrong size!
fi
# end of 'man1/purge.1'
fi
if test -f 'man1/undelete.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/undelete.1'\"
else
echo shar: Extracting \"'man1/undelete.1'\" \(3506 characters\)
sed "s/^X//" >'man1/undelete.1' <<'END_OF_FILE'
X.\"	$Source: /afs/athena.mit.edu/user/j/jik/src/delete/man1/RCS/undelete.1,v $
X.\"	$Author: jik $
X.\"	$Header: /afs/athena.mit.edu/user/j/jik/src/delete/man1/RCS/undelete.1,v 1.5 89/11/02 07:13:26 jik Exp $
X.\" Copyright 1989 by the Massachusetts Institute of Technology.  All
X.\" rights reserved.  The file /usr/include/mit-copyright.h specifies
X.\" the terms and conditions for redistribution.
X.\"
X.\"
X.TH UNDELETE 1 "January 26, 1988" "MIT Project Athena"
X.ds ]W MIT Project Athena
X.SH NAME
Xundelete \- recover files removed by delete
X.SH SYNOPSIS
X.B undelete
X[
X.B \-r
X] [
X.B \-i
X] [
X.B \-f
X] [
X.B \-v
X] [
X.B \-n
X] [
X.B \-R
X] [
X.B \-\|\-
X] [ filename [ ... ]]
X.PP
X.DESCRIPTION
X.I Undelete
Xrecovers files and directories that have been marked for permanent removal by 
X\fIdelete\fR(1), but have not
Xyet been removed.
X.PP
XFilenames passed to
X.I undelete
Xcan be directories or deleted files.
XIf a directory that is not deleted is passed to
X.I undelete,
Xthen the deleted files or directories in it will be restored; if the
Xrecursive option is specified, then all deleted files or directories
Xin any of its children will be restored as well.
X.PP
XThe shell wildcards \fI*\fR and \fI?\fR, as well as shell brace
Xnotation using \fI[\fR and \fI]\fR, are interpreted correctly by
X.I undelete.
XIt is possible to pass wildcards to the program without the wildcards
Xbeing intercepted by the shell by setting
X.I noglob
X(in \fIcsh\fR) or by quoting the wildcards.  To delete a file that
Xactually has a wildcard in its name, you must precede the quoted
Xwildcard with a quoted backslash.
X.PP
XIf no files are specified on the command line,
X.I undelete
Xgoes into interactive mode.  In interactive mode, the user is prompted
Xto enter files to be restored, one file per line.  Typing a carriage
Xreturn on an empty prompt line exits the program.
X.PP
XWildcards and quoting backslashes can be entered directly at the
Xprompt without any shell interference (which is the
Xmain reason there is an interactive mode).
X.SH OPTIONS
X.I Undelete
Xaccepts the following command-line options:
X.TP
X.B \-r
XIf a specified file is a directory, the directory and all of its
Xchildren are restored recursively.
X.TP
X.B \-i
XThe user is prompted for confirmation before each file or directory is
Xrestored.  This is not the same as the interactive file name entry
Xmode which is automatically activated when no files are specified on
Xthe command line.
X.TP
X.B \-f
XPrevents
X.I undelete
Xfrom reporting errors.  Further, if an intact (undeleted) version of a
Xfile which is requested for undeletion exists, then
X.I undelete
Xwill not prompt for confirmation before overwriting the undeleted file
Xwith the recovered one.
X.TP
X.B \-v
XCauses
X.I undelete
Xto report each file as it is restored.  Also, causes an introductory
Xmessage to be printed when entering interactive mode.
X.TP
X.B \-n
XNo file recoveries are performed.  Instead,
X.I undelete
Xprints to the standard output the files that it would recover were the
X.B \-n
Xoption not specified.
X.TP
X.B \-R
XPrevents
X.I undelete
Xfrom restoring the contents of directories in any case.
X.TP
X.B \-\|\-
XTwo dashes indicate that all arguments following it are to be treated as file
Xnames, even if they start with a dash.
X.SH "SEE ALSO"
Xdelete(1), purge(1), expunge(1), lsdel(1), rm(1), rmdir(1)
X.SH AUTHOR
XJonathan I. Kamens (MIT-Project Athena)
X.SH RESTRICTIONS
XCopyright (c) 1989 by the Massachusetts Institute of Technology.  All
Xrights reserved.
X.IR Delete (1)
Xspecifies the terms and conditions for redistribution.
END_OF_FILE
if test 3506 -ne `wc -c <'man1/undelete.1'`; then
    echo shar: \"'man1/undelete.1'\" unpacked with wrong size!
fi
# end of 'man1/undelete.1'
fi
if test -f 'mit-copyright.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mit-copyright.h'\"
else
echo shar: Extracting \"'mit-copyright.h'\" \(1025 characters\)
sed "s/^X//" >'mit-copyright.h' <<'END_OF_FILE'
X/*
X
XCopyright 1987,1988 by the Massachusetts Institute of Technology
X
XAll rights reserved.
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted,
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in
Xsupporting documentation, and that the name of the Massachusetts
XInstitute of Technology (M.I.T.) not be used in advertising or publicity
Xpertaining to distribution of the software without specific, written
Xprior permission.
X
XM.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XM.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X
X*/
END_OF_FILE
if test 1025 -ne `wc -c <'mit-copyright.h'`; then
    echo shar: \"'mit-copyright.h'\" unpacked with wrong size!
fi
# end of 'mit-copyright.h'
fi
if test -f 'pattern.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pattern.h'\"
else
echo shar: Extracting \"'pattern.h'\" \(1199 characters\)
sed "s/^X//" >'pattern.h' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/pattern.h,v $
X * $Author: jik $
X * $Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/pattern.h,v 1.5 89/11/06 19:54:32 jik Exp $
X * 
X * This program is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X#include "mit-copyright.h"
X
Xint add_str();
Xint add_arrays();
Xint find_contents();
Xint find_deleted_contents();
Xint find_deleted_contents_recurs();
Xint find_matches();
Xint find_deleted_matches();
Xint find_recurses();
Xint find_deleted_recurses();
X
X#define FIND_DELETED		(1<<0)
X#define FIND_UNDELETED		(1<<1)
X#define RECURS_FIND_DELETED	(1<<2)
X#define RECURS_FIND_UNDELETED	(1<<3)
X#define RECURS_DELETED		(1<<4)
X#define FOLLW_LINKS		(1<<5)
X#define FOLLW_MOUNTPOINTS	(1<<6)
X#define FIND_DOTFILES		(1<<7)
X#define FIND_CONTENTS		(1<<8)
X#define SUPPRESS_WARNINGS	(1<<9)
X#define RECURS			(RECURS_FIND_DELETED | RECURS_FIND_UNDELETED |\
X				 RECURS_DELETED | FIND_CONTENTS)
END_OF_FILE
if test 1199 -ne `wc -c <'pattern.h'`; then
    echo shar: \"'pattern.h'\" unpacked with wrong size!
fi
# end of 'pattern.h'
fi
if test -f 'shell_regexp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shell_regexp.c'\"
else
echo shar: Extracting \"'shell_regexp.c'\" \(3189 characters\)
sed "s/^X//" >'shell_regexp.c' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/shell_regexp.c,v $
X * $Author: jik $
X *
X * This program is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X
X#if (!defined(lint) && !defined(SABER))
X     static char rcsid_shell_regexp_c[] = "$Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/shell_regexp.c,v 1.2 89/11/06 21:27:16 jik Exp $";
X#endif
X
X#include <com_err.h>
X#include "shell_regexp.h"
X#include "delete_errs.h"
X#include "errors.h"
X#include "mit-copyright.h"
X
Xstatic int real_cmp();
X
X/*
X * This is a simple pattern matcher that takes a pattern string and
X * another string (theoretically a filename) and checks if the second
X * string matches the pattern string using shell special characters
X * (i.e. it recognizes \, ?, *, [, ]).  It also special cases dot
X * files (i.e. * doesn't match files that start with periods, and
X * neither will ?*, and neither will [.]*).
X */
X
Xint reg_cmp(pattern, filename)
Xchar *pattern, *filename;
X{
X     /* First, dot file special cases */
X     if ((*filename == '.') && (*pattern != '.'))
X	  return REGEXP_NO_MATCH;
X
X     return real_cmp(pattern, filename);
X}
X
Xstatic int real_cmp(pattern, filename)
Xchar *pattern, *filename;
X{
X     if (*pattern == '\0') {
X	  if (*filename == '\0')
X	       return REGEXP_MATCH;
X	  else
X	       return REGEXP_NO_MATCH;
X     }
X     
X     if (*pattern == '*') {
X	  int retval;
X	  char *ptr;
X	  
X	  if (*(pattern + 1) == '\0')
X	       /* asterisk by itself matches anything */
X	       return REGEXP_MATCH;
X	  for (ptr = filename; *ptr; ptr++)
X	       if ((retval = real_cmp(pattern + 1, ptr)) != REGEXP_NO_MATCH)
X		    return retval;
X	  return REGEXP_NO_MATCH;
X     }
X
X     if (*filename == '\0')
X	  return REGEXP_NO_MATCH;
X     
X     if (*pattern == '?')
X	  return real_cmp(pattern + 1, filename + 1);
X
X     if (*pattern == '\\') {
X	  if (*(pattern + 1) == '\0') {
X	       set_error(REGEXP_MISSING_QUOTED_CHAR);
X	       return -1;
X	  }
X	  if (*(pattern + 1) == *filename)
X	       return real_cmp(pattern + 2, filename + 1);
X	  else
X	       return REGEXP_NO_MATCH;
X     }
X
X     if (*pattern == '[') {
X	  char *ptr, *end_ptr;
X
X	  for (end_ptr = pattern + 1; (*end_ptr != '\0') && (*end_ptr != ']');
X	       end_ptr++) ;
X	  if (*end_ptr == '\0') {
X	       set_error(REGEXP_MISSING_BRACE);
X	       return -1;
X	  }
X	  if (end_ptr == pattern + 1) {
X	       set_error(REGEXP_EMPTY_BRACES);
X	       return -1;
X	  }
X	  for (ptr = pattern + 1; ptr < end_ptr; ptr++) {
X	       if ((*(ptr + 1) == '-') && (*(ptr + 2) != ']')) {
X		    if ((*ptr <= *filename) && (*(ptr + 2) >= *filename))
X			 return real_cmp(end_ptr + 1, filename + 1);
X		    else {
X			 ptr += 2;
X			 continue;
X		    }
X	       }
X	       if (*ptr == *filename)
X		    return real_cmp(end_ptr + 1, filename + 1);
X	  }
X
X	  return REGEXP_NO_MATCH;
X     }
X		    
X     if (*pattern == *filename)
X	  return real_cmp(pattern + 1, filename + 1);
X     else
X	  return REGEXP_NO_MATCH;
X}
END_OF_FILE
if test 3189 -ne `wc -c <'shell_regexp.c'`; then
    echo shar: \"'shell_regexp.c'\" unpacked with wrong size!
fi
# end of 'shell_regexp.c'
fi
if test -f 'shell_regexp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shell_regexp.h'\"
else
echo shar: Extracting \"'shell_regexp.h'\" \(536 characters\)
sed "s/^X//" >'shell_regexp.h' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/shell_regexp.h,v $
X * $Author: jik $
X *
X * This program is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X#include "mit-copyright.h"
X
Xextern int reg_cmp();
X
X#define REGEXP_MATCH 1
X#define REGEXP_NO_MATCH 0
END_OF_FILE
if test 536 -ne `wc -c <'shell_regexp.h'`; then
    echo shar: \"'shell_regexp.h'\" unpacked with wrong size!
fi
# end of 'shell_regexp.h'
fi
if test -f 'stack.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stack.c'\"
else
echo shar: Extracting \"'stack.c'\" \(2320 characters\)
sed "s/^X//" >'stack.c' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/stack.c,v $
X * $Author: jik $
X *
X * This program is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X
X#if (!defined(lint) && !defined(SABER))
X     static char rcsid_stack_c[] = "$Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/stack.c,v 1.5 89/12/11 03:32:37 jik Exp $";
X#endif
X
X#include <sys/types.h>
X#include <stdio.h>
X#include <errno.h>
X#include "stack.h"
X#include "delete_errs.h"
X#include "errors.h"
X#include "mit-copyright.h"
X#include "util.h"
X
Xextern char *realloc();
Xextern int errno;
X
X#define STACK_INC 	25
X
X
X
Xint dostack(data, op, bytes)
Xcaddr_t data;
Xint op, bytes;
X{
X     static caddr_t stack = (caddr_t) NULL;
X     static int size = 0, count = 0;
X
X     switch (op) {
X     case EMPTY_STACK:
X	  if (size) {
X	       free(stack);
X	       stack = (caddr_t) NULL;
X	       size = count = 0;
X	  }
X	  return 0;
X     case STACK_PUSH:
X	  if (bytes == 0)
X	       return 0;
X	  if (size - count < bytes) {
X	       do
X		    size += STACK_INC;
X	       while (size - count < bytes);
X	       stack = (caddr_t) (stack ? realloc((char *) stack,
X						  (unsigned) size) :
X				  Malloc((unsigned) size));
X	       if (! stack) {
X		    size = count = 0;
X		    set_error(errno);
X		    error("Malloc");
X		    return error_code;
X	       }
X	  }
X	  bcopy(data, stack + count, bytes);
X	  count += bytes;
X	  return 0;
X     case STACK_POP:
X	  if (bytes == 0)
X	       return 0;
X	  if (count == 0) {
X	       set_status(STACK_EMPTY);
X	       return error_code;
X	  }
X	  else {
X	       int newblocks, newsize;
X
X	       count -= bytes;
X	       bcopy(stack + count, data, bytes);
X	       newblocks = count / STACK_INC + ((count % STACK_INC) ? 1 : 0);
X	       newsize = newblocks * STACK_INC;
X	       if (newsize < size) {
X		    size = newsize;
X		    stack = (caddr_t) realloc((char *) stack, (unsigned) size);
X		    if (! stack) {
X			 set_error(errno);
X			 error("realloc");
X			 return error_code;
X		    }
X	       }
X	       return 0;
X	  }
X     default:
X	  set_error(STACK_BAD_OP);
X	  return error_code;
X     }
X}
END_OF_FILE
if test 2320 -ne `wc -c <'stack.c'`; then
    echo shar: \"'stack.c'\" unpacked with wrong size!
fi
# end of 'stack.c'
fi
if test -f 'stack.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stack.h'\"
else
echo shar: Extracting \"'stack.h'\" \(817 characters\)
sed "s/^X//" >'stack.h' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/stack.h,v $
X * $Author: jik $
X * $Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/stack.h,v 1.2 89/11/06 21:26:50 jik Exp $
X * 
X * This file is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X#include "mit-copyright.h"
X
X#define STACK_PUSH 	0
X#define STACK_POP	1
X#define EMPTY_STACK	2
X
X#define push(data, size)	dostack((caddr_t) data, STACK_PUSH, size)
X#define pop(data, size)		dostack((caddr_t) data, STACK_POP, size)
X#define popall()		dostack((caddr_t) NULL, EMPTY_STACK, 0)
X     
END_OF_FILE
if test 817 -ne `wc -c <'stack.h'`; then
    echo shar: \"'stack.h'\" unpacked with wrong size!
fi
# end of 'stack.h'
fi
if test -f 'undelete.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'undelete.h'\"
else
echo shar: Extracting \"'undelete.h'\" \(748 characters\)
sed "s/^X//" >'undelete.h' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/undelete.h,v $
X * $Author: jik $
X * $Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/undelete.h,v 1.4 89/10/23 13:09:09 jik Exp $
X * 
X * This program is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X#include "mit-copyright.h"
X
X#define DELETEPREFIX ".#"
X#define DELETEREPREFIX "\\.#"
X
Xtypedef struct {
X     char *user_name;
X     char *real_name;
X} listrec;
X
Xint sort_files();
Xint unique();
X
Xint get_the_files();
END_OF_FILE
if test 748 -ne `wc -c <'undelete.h'`; then
    echo shar: \"'undelete.h'\" unpacked with wrong size!
fi
# end of 'undelete.h'
fi
if test -f 'util.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util.h'\"
else
echo shar: Extracting \"'util.h'\" \(1149 characters\)
sed "s/^X//" >'util.h' <<'END_OF_FILE'
X/*
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/util.h,v $
X * $Author: jik $
X * $Header: /afs/athena.mit.edu/user/j/jik/src/delete/RCS/util.h,v 1.10 90/01/11 03:44:53 jik Exp $
X * 
X * This file is part of a package including delete, undelete,
X * lsdel, expunge and purge.  The software suite is meant as a
X * replacement for rm which allows for file recovery.
X * 
X * Copyright (c) 1989 by the Massachusetts Institute of Technology.
X * For copying and distribution information, see the file "mit-copyright.h."
X */
X#include "mit-copyright.h"
X
Xchar *append();
Xchar *convert_to_user_name();
Xchar *firstpart();
Xchar *lastpart();
Xchar *strindex();
Xchar *strrindex();
X#ifdef MALLOC_DEBUG
Xchar *Malloc();
X#else
X#define Malloc(a) malloc(a)
Xextern char *malloc();
X#endif
X
Xint is_mountpoint(), is_link();
X
X#define is_dotfile(A) ((*A == '.') && \
X		       ((*(A + 1) == '\0') || \
X			((*(A + 1) == '.') && \
X			 (*(A + 2) == '\0'))))
X
X#define is_deleted(A) ((*A == '.') && (*(A + 1) == '#'))
X
X /* It would be BAD to pass something with a ++ anywhere near it into */
X /* this macro! 						      */
X#define Opendir(dir) opendir(*(dir) ? (dir) : ".")
END_OF_FILE
if test 1149 -ne `wc -c <'util.h'`; then
    echo shar: \"'util.h'\" unpacked with wrong size!
fi
# end of 'util.h'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
exit 0 # Just in case...
