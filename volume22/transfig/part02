Subject:  v23i015:  Tools for creating TeX documents with portable graphics, Part02/06
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 7343b6b4 9f1c53a2 a3af18c4 d4688d13

Submitted-by: Micah Beck <beck@cs.cornell.edu>
Posting-number: Volume 23, Issue 15
Archive-name: transfig/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 6)."
# Contents:  transfig/doc/fig2dev.1 transfig/fig2dev/bound.c
#   transfig/fig2dev/fig2dev.c transfig/fig2dev/latex_line.c
#   transfig/fig2dev/object.h transfig/fig2dev/read1_3.c
# Wrapped by beck@rocky on Thu May 17 15:56:10 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'transfig/doc/fig2dev.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'transfig/doc/fig2dev.1'\"
else
echo shar: Extracting \"'transfig/doc/fig2dev.1'\" \(6038 characters\)
sed "s/^X//" >'transfig/doc/fig2dev.1' <<'END_OF_FILE'
X.TH FIG2DEV 1 "7 May 1989"
X.SH NAME
Xfig2dev \- translates Fig code to various graphics languages
X
X.SH SYNOPSIS
X.B fig2dev
X.B \-L
X.I language
X[
X.B \-m
X.I mag
X] [
X.B \-f 
X.I font
X] [
X.B \-s
X.I fsize
X] [
X.I other options
X] [
X\fIfig-file\fR [ \fIout-file\fR ] ]
X
X.SH DESCRIPTION
X.I Fig2dev
Xtranslates fig code in the named
X.I fig-file
Xinto the specified graphics 
X.I language
Xand puts them in
X.I out-file.
XThe default
X.I fig-file
Xand
X.I out-file
Xare standard input and standard output, respectively
X.LP
XFig (Facility for Interactive Generation of figures) is a screen-oriented
Xtool which allows the user to draw and manipulate objects interactively.
XVarious versions of Fig run under the Suntools/Sunview window environment
Xand under version 11 of the X Windows System.
XFig2dev is compatible with Fig versions 1.3, 1.4-TFX, and 2.0.
X
X.SH OPTIONS
X.TP
X.B \-L
XSet the output graphics language.
XValid languages are
X\fBbox, epic, eepic, eepicemu, latex, null, pic, pictex,\fR
Xand
X.B ps.
X.TP
X.B \-m
XSet the magnification at which the figure is rendered to
X.I mag.
XThe default is 1.0.
X.TP
X.B \-f 
XSet the default font used for text objects to
X.I font.
XThe default is Roman; the format of this option depends on the graphics
X.I language
Xin use.
XIn TeX-based languages, the font is the base of the name given in lfonts.tex,
Xfor instance \"cmr\" for Roman, or \"tt\" for teletype.
XIn PostScript, it is any font name known to the printer or interpreter.
X.TP
X.B \-s
XSet the default font size (in points) for text objects to
X.I fsize.
XThe default is 11*mag, and thus is scaled by the \fB-m\fR option.
XIf there is no scaling, the default font is eleven point Roman."
X.TP
X.I other options
XThe other options are specific to the choice of graphics
X.I language,
Xas described below.
X
X.SH EPIC OPTIONS
XEPIC is an enhancement to LaTeX picture drawing environment.
XIt was developed by Sunil Podar of Department of Computer Science
Xin S.U.N.Y at Stony Brook.
X.LP
XEEPIC is an extension to EPIC and LaTeX picture drawing environment
Xwhich uses tpic specials as a graphics mechanism.
XIt was written by Conrad Kwok of Division of
XComputer Science at University of California, Davis.
X.LP
XEEPIC-EMU is an EEPIC emulation package which does not use tpic specials.
X.TP
X.B \-S
XSet the scale to which the figure is rendered.
XThis option automatically sets the 
X.I magnification
Xand size to
X.I scale
X/ 12 and 
X.I scale
Xrespectively.
X.TP
X.B \-l
XUse "\fB\\thicklines\fR" when width of the line is wider than 
X.I lwidth.
XThe default is 2.
X.TP
X.B \-v
XInclude comments in the output file.
X.TP
X.B \-P
XGenerate a complete LaTeX file. In other words, the ouput file can be
Xformatted without requiring any changes. The additional text inserted
Xin the beginning and at the end of the file is controlled by the
Xconfiguration parameter "Preamble" and "Postamble".
X.TP
X.B \-W
XEnable variable line width
X.TP
X.B \-w
XDisable variable line width. Only "\fB\\thicklines\fR" and/or
X"\fB\\thinlines\fR" commands will be generated in the output file.
X.LP
XWhen variable line width option is enabled, "\fB\\thinlines\fR"
Xcommand is still used when line width is less than
X\fILineThick\fR. One potential problem is that the width of
X"\fB\\thinlines\fR" is 0.4pt
Xbut the resolution of Fig is 1/80 inch (approx. 1pt). If
X\fILineThick\fR is set to 2, normal lines will be drawn in 0.4pt
Xwide lines but the next line width is already 2pt. One possible
Xsolution is to set \fILineThick\fR to 1 and set the width of the
Xthose lines you want to be drawn in "\fB\\thinlines\fR"  to 0.
X
XDue to this problem, Varible line width \fIVarWidth\fR
Xis defaulted to be false.
X
X.SH LATEX OPTIONS
X.TP
X.B \-l
XSets the threshold between LaTeX thin and thick lines to 
X.I lwidth
Xpixels.
XLaTeX supports only two different line width: \\thinlines and \\thicklines.
XLines of width greater than
X.I lwidth
Xpixels are drawn as \\thicklines.
XAlso affects the size of dots in dotted line style.
XThe default is 0.
X.TP
X.B \-d
XSet a seperate magnification for the length of line dashes to
X.I dmag.
X.TP
X.B \-v
XVerbose mode.
X.LP
XLaTeX cannot accurately represent all the graphics objects which can
Xbe described by Fig.
XFor example, the possible slopes which lines may have are limited.
XSome objects, such as spline curves, cannot be drawn at all.
XFig2latex chooses the closest possible line slope, and prints error
Xmessages when objects cannot be drawn accurately
X
X.SH PICTEX OPTIONS
X.B \-p 
XSet the symbol used by PiCTeX for plotting lines and curves to 
X.I psymbol.
XThe default is "\fB\\sevrm .\fR"
X.TP
X.B \-l 
XSet the width of any rules used to draw lines and boxes within the picture to 
X.I lwidth.
XThe default is "\fB0.7pt\fR".
X.LP
XIn order to include PiCTeX pictures into a document, it is necessary to
Xload the PiCTeX macros.
X.LP
XPiCTeX uses TeX integer register arithmetic to generate curves,
Xand so it is very slow.
XPiCTeX draws curves by \fB\\put\fR-ing the \fIpsymbol\fR repeatedly,
Xand so requires a large amount of TeX's internal memory,
Xand generates large DVI files.
XThe size of TeX's memory limits the number of plot symbols in a picture.
XAs a result, it is best to use PiCTeX to generate small pictures.
X
X.SH POSTSCRIPT OPTIONS
X.TP
X.B -c
Xoption centers the figure on the page.
XThe centering may not be accurate if there are texts in the
X.I fig_file
Xthat extends too far to the right of other objects.
X.TP
X.B -P
Xindicates that the figure describes a full page which will not
Xnecessarily be inserted into a document, but can be sent directly
Xto a PS printer.
XThis ensures that a showpage command is inserted at the end of
Xthe figure, and inhibits translation of the figure coordinate system.
X.TP
X.B -l
XRotate figure to landscape mode.
X
X.SH "SEE ALSO"
X[x]fig(1),
Xpic(1)
Xpic2fig(1),
Xtransfig(1)
X.SH AUTHORS
XMicah Beck (beck@svax.cs.cornell.edu)
X.br
XCornell University
X.br
XMay 7 1989
X.sp
Xand Frank Schmuck (then of Cornell University)
X.br
Xand Conrad Kwok (then of the U.C. Davis).
X.sp
XModified from f2p (fig to PIC), by the author of Fig
X.br
XSupoj Sutanthavibul (supoj@sally.utexas.edu)
X.br
XUniversity of Texas at Austin. 
X
END_OF_FILE
if test 6038 -ne `wc -c <'transfig/doc/fig2dev.1'`; then
    echo shar: \"'transfig/doc/fig2dev.1'\" unpacked with wrong size!
fi
# end of 'transfig/doc/fig2dev.1'
fi
if test -f 'transfig/fig2dev/bound.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'transfig/fig2dev/bound.c'\"
else
echo shar: Extracting \"'transfig/fig2dev/bound.c'\" \(9753 characters\)
sed "s/^X//" >'transfig/fig2dev/bound.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <math.h>
X#include "pi.h"
X#include "object.h"
X
X#define		Ninety_deg		M_PI_2
X#define		One_eighty_deg		M_PI
X#define		Two_seventy_deg		(M_PI + M_PI_2)
X#define		Three_sixty_deg		(M_PI + M_PI)
X#define		round(x)		((int) ((x) + ((x >= 0)? 0.5: -0.5)))
X#define		half(z1 ,z2)		((z1+z2)/2.0)
X#define		max(a, b)		(((a) > (b)) ? (a) : (b))
X#define		min(a, b)		(((a) < (b)) ? (a) : (b))
X
Xarc_bound(arc, xmin, ymin, xmax, ymax)
XF_arc	*arc;
Xint	*xmin, *ymin, *xmax, *ymax;
X{
X	double	alpha, beta;
X	double	dx, dy, radius;
X	int	bx, by, sx, sy;
X
X	dx = arc->point[0].x - arc->center.x;
X	dy = arc->center.y - arc->point[0].y;
X	alpha = atan2(dy, dx);
X	if (alpha < 0.0) alpha += Three_sixty_deg;
X	/* compute_angle returns value between 0 to 2PI */
X	
X	radius = hypot(dx, dy);
X
X	dx = arc->point[2].x - arc->center.x;
X	dy = arc->center.y - arc->point[2].y;
X	beta = atan2(dy, dx);
X	if (beta < 0.0) beta += Three_sixty_deg;
X
X	bx = max(arc->point[0].x, arc->point[1].x);
X	bx = max(arc->point[2].x, bx);
X	by = max(arc->point[0].y, arc->point[1].y);
X	by = max(arc->point[2].y, by);
X	sx = min(arc->point[0].x, arc->point[1].x);
X	sx = min(arc->point[2].x, sx);
X	sy = min(arc->point[0].y, arc->point[1].y);
X	sy = min(arc->point[2].y, sy);
X
X	if (arc->direction == 1) { /* counter clockwise */
X	    if (alpha > beta) {
X		if (alpha <= 0 || 0 <= beta)
X		    bx = (int)(arc->center.x + radius + 1.0);
X		if (alpha <= Ninety_deg || Ninety_deg <= beta)
X		    sy = (int)(arc->center.y - radius - 1.0);
X		if (alpha <= One_eighty_deg || One_eighty_deg <= beta)
X		    sx = (int)(arc->center.x - radius - 1.0);
X		if (alpha <= Two_seventy_deg || Two_seventy_deg <= beta)
X		    by = (int)(arc->center.y + radius + 1.0);
X		}
X	    else {
X		if (0 <= beta && alpha <= 0)
X		    bx = (int)(arc->center.x + radius + 1.0);
X		if (Ninety_deg <= beta && alpha <= Ninety_deg)
X		    sy = (int)(arc->center.y - radius - 1.0);
X		if (One_eighty_deg <= beta && alpha <= One_eighty_deg)
X		    sx = (int)(arc->center.x - radius - 1.0);
X		if (Two_seventy_deg <= beta && alpha <= Two_seventy_deg)
X		    by = (int)(arc->center.y + radius + 1.0);
X		}
X	    }
X	else {	/* clockwise	*/
X	    if (alpha > beta) {
X		if (beta <= 0 && 0 <= alpha)
X		    bx = (int)(arc->center.x + radius + 1.0);
X		if (beta <= Ninety_deg && Ninety_deg <= alpha)
X		    sy = (int)(arc->center.y - radius - 1.0);
X		if (beta <= One_eighty_deg && One_eighty_deg <= alpha)
X		    sx = (int)(arc->center.x - radius - 1.0);
X		if (beta <= Two_seventy_deg && Two_seventy_deg <= alpha)
X		    by = (int)(arc->center.y + radius + 1.0);
X		}
X	    else {
X		if (0 <= alpha || beta <= 0)
X		    bx = (int)(arc->center.x + radius + 1.0);
X		if (Ninety_deg <= alpha || beta <= Ninety_deg)
X		    sy = (int)(arc->center.y - radius - 1.0);
X		if (One_eighty_deg <= alpha || beta <= One_eighty_deg)
X		    sx = (int)(arc->center.x - radius - 1.0);
X		if (Two_seventy_deg <= alpha || beta <= Two_seventy_deg)
X		    by = (int)(arc->center.y + radius + 1.0);
X		}
X	    }
X	*xmax = bx; *ymax = by;
X	*xmin = sx; *ymin = sy;
X	}
X
Xcompound_bound(compound, xmin, ymin, xmax, ymax, include)
XF_compound	*compound;
Xint		*xmin, *ymin, *xmax, *ymax;
Xint		include;
X{
X	F_arc		*a;
X	F_ellipse	*e;
X	F_compound	*c;
X	F_spline	*s;
X	F_line		*l;
X	F_text		*t;
X	int		bx, by, sx, sy, first = 1;
X	int		llx, lly, urx, ury;
X
X	for (a = compound->arcs; a != NULL; a = a->next) {
X	    arc_bound(a, &sx, &sy, &bx, &by);
X	    if (first) {
X		first = 0;
X		llx = sx; lly = sy;
X		urx = bx; ury = by;
X		}
X	    else {
X		llx = min(llx, sx); lly = min(lly, sy);
X		urx = max(urx, bx); ury = max(ury, by);
X		}
X	    }
X
X	for (c = compound->compounds; c != NULL; c = c->next) {
X	    compound_bound(c, &sx, &sy, &bx, &by);
X	    if (first) {
X		first = 0;
X		llx = sx; lly = sy;
X		urx = bx; ury = by;
X		}
X	    else {
X		llx = min(llx, sx); lly = min(lly, sy);
X		urx = max(urx, bx); ury = max(ury, by);
X		}
X	    }
X
X	for (e = compound->ellipses; e != NULL; e = e->next) {
X	    ellipse_bound(e, &sx, &sy, &bx, &by);
X	    if (first) {
X		first = 0;
X		llx = sx; lly = sy;
X		urx = bx; ury = by;
X		}
X	    else {
X		llx = min(llx, sx); lly = min(lly, sy);
X		urx = max(urx, bx); ury = max(ury, by);
X		}
X	    }
X
X	for (l = compound->lines; l != NULL; l = l->next) {
X	    line_bound(l, &sx, &sy, &bx, &by);
X	    if (first) {
X		first = 0;
X		llx = sx; lly = sy;
X		urx = bx; ury = by;
X		}
X	    else {
X		llx = min(llx, sx); lly = min(lly, sy);
X		urx = max(urx, bx); ury = max(ury, by);
X		}
X	    }
X
X	for (s = compound->splines; s != NULL; s = s->next) {
X	    spline_bound(s, &sx, &sy, &bx, &by);
X	    if (first) {
X		first = 0;
X		llx = sx; lly = sy;
X		urx = bx; ury = by;
X		}
X	    else {
X		llx = min(llx, sx); lly = min(lly, sy);
X		urx = max(urx, bx); ury = max(ury, by);
X		}
X	    }
X
X	for (t = compound->texts; t != NULL; t = t->next) {
X	    text_bound(t, &sx, &sy, &bx, &by, include);
X	    if (first) {
X		first = 0;
X		llx = sx; lly = sy;
X		urx = bx; ury = by;
X		}
X	    else {
X		llx = min(llx, sx); lly = min(lly, sy);
X		urx = max(urx, bx); ury = max(ury, by);
X		}
X	    }
X
X	*xmin = llx; *ymin = lly;
X	*xmax = urx; *ymax = ury;
X	}
X
Xellipse_bound(e, xmin, ymin, xmax, ymax)
XF_ellipse	*e;
Xint		*xmin, *ymin, *xmax, *ymax;
X{
X	*xmin = e->center.x - e->radiuses.x;
X	*ymin = e->center.y - e->radiuses.y;
X	*xmax = e->center.x + e->radiuses.x;
X	*ymax = e->center.y + e->radiuses.y;
X	}
X
Xline_bound(l, xmin, ymin, xmax, ymax)
XF_line	*l;
Xint	*xmin, *ymin, *xmax, *ymax;
X{
X	points_bound(l->points, xmin, ymin, xmax, ymax);
X	}
X
Xspline_bound(s, xmin, ymin, xmax, ymax)
XF_spline	*s;
Xint		*xmin, *ymin, *xmax, *ymax;
X{
X	if (int_spline(s)) {
X	    int_spline_bound(s, xmin, ymin, xmax, ymax);
X	    }
X	else {
X	    normal_spline_bound(s, xmin, ymin, xmax, ymax);
X	    }
X	}
X
Xint_spline_bound(s, xmin, ymin, xmax, ymax)
XF_spline	*s;
Xint		*xmin, *ymin, *xmax, *ymax;
X{
X	F_point		*p1, *p2;
X	F_control	*cp1, *cp2;
X	double		x0, y0, x1, y1, x2, y2, x3, y3, sx1, sy1, sx2, sy2;
X	double		tx, ty, tx1, ty1, tx2, ty2;
X	double		sx, sy, bx, by;
X
X	p1 = s->points;
X	sx = bx = p1->x;
X	sy = by = p1->y;
X	cp1 = s->controls;
X	for (p2 = p1->next, cp2 = cp1->next; p2 != NULL;
X		p1 = p2, cp1 = cp2, p2 = p2->next, cp2 = cp2->next) {
X	    x0 = p1->x; y0 = p1->y;
X	    x1 = cp1->rx; y1 = cp1->ry;
X	    x2 = cp2->lx; y2 = cp2->ly;
X	    x3 = p2->x; y3 = p2->y;
X	    tx = half(x1, x2); ty = half(y1, y2);
X	    sx1 = half(x0, x1); sy1 = half(y0, y1);
X	    sx2 = half(sx1, tx); sy2 = half(sy1, ty);
X	    tx2 = half(x2, x3); ty2 = half(y2, y3);
X	    tx1 = half(tx2, tx); ty1 = half(ty2, ty);
X
X	    sx = min(x0, sx); sy = min(y0, sy);
X	    sx = min(sx1, sx); sy = min(sy1, sy);
X	    sx = min(sx2, sx); sy = min(sy2, sy);
X	    sx = min(tx1, sx); sy = min(ty1, sy);
X	    sx = min(tx2, sx); sy = min(ty2, sy);
X	    sx = min(x3, sx); sy = min(y3, sy);
X
X	    bx = max(x0, bx); by = max(y0, by);
X	    bx = max(sx1, bx); by = max(sy1, by);
X	    bx = max(sx2, bx); by = max(sy2, by);
X	    bx = max(tx1, bx); by = max(ty1, by);
X	    bx = max(tx2, bx); by = max(ty2, by);
X	    bx = max(x3, bx); by = max(y3, by);
X	    }
X	*xmin = round(sx);
X	*ymin = round(sy);
X	*xmax = round(bx);
X	*ymax = round(by);
X	}
X
Xnormal_spline_bound(s, xmin, ymin, xmax, ymax)
XF_spline	*s;
Xint		*xmin, *ymin, *xmax, *ymax;
X{
X	F_point	*p;
X	double	cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4;
X	double	x1, y1, x2, y2, sx, sy, bx, by;
X	double	px, py, qx, qy;
X
X	p = s->points;
X	x1 = p->x;  y1 = p->y;
X	p = p->next;
X	x2 = p->x;  y2 = p->y;
X	cx1 = (x1 + x2) / 2.0;   cy1 = (y1 + y2) / 2.0;
X	cx2 = (cx1 + x2) / 2.0;  cy2 = (cy1 + y2) / 2.0;
X	if (closed_spline(s)) {
X	    x1 = (cx1 + x1) / 2.0;
X	    y1 = (cy1 + y1) / 2.0;
X	    }
X	sx = min(x1, cx2); sy = min(y1, cy2);
X	bx = max(x1, cx2); by = max(y1, cy2);
X
X	for (p = p->next; p != NULL; p = p->next) {
X	    x1 = x2;  y1 = y2;
X	    x2 = p->x;  y2 = p->y;
X	    cx4 = (x1 + x2) / 2.0; cy4 = (y1 + y2) / 2.0;
X	    cx3 = (x1 + cx4) / 2.0; cy3 = (y1 + cy4) / 2.0;
X	    cx2 = (cx4 + x2) / 2.0;  cy2 = (cy4 + y2) / 2.0;
X
X	    px = min(cx2, cx3); py = min(cy2, cy3);
X	    qx = max(cx2, cx3); qy = max(cy2, cy3);
X
X	    sx = min(sx, px); sy = min(sy, py);
X	    bx = max(bx, qx); by = max(by, qy);
X	    }
X	if (closed_spline(s)) {
X	    *xmin = round(sx); *ymin = round(sy);
X	    *xmax = round(bx); *ymax = round(by);
X	    }
X	else {
X	    *xmin = round(min(sx, x2)); *ymin = round(min(sy, y2));
X	    *xmax = round(max(bx, x2)); *ymax = round(max(by, y2));
X	    }
X	}
X
Xtext_bound(t, xmin, ymin, xmax, ymax, include)
XF_text	*t;
Xint	*xmin, *ymin, *xmax, *ymax;
Xint	include;
X{
X	if (t->type == T_CENTER_JUSTIFIED) {
X		*xmin = t->base_x - t->length / 2;
X		*xmax = t->base_x + t->length / 2;
X	} else if (t->type == T_RIGHT_JUSTIFIED) {
X		*xmin = t->base_x - t->length;
X		*xmax = t->base_x;
X	} else {
X		*xmin = t->base_x;
X		*xmax = t->base_x + (include ? t->length : 0);
X	}
X	*ymax = t->base_y;
X	*ymin = t->base_y - t->height;
X	}
X
Xpoints_bound(points, xmin, ymin, xmax, ymax)
XF_point	*points;
Xint	*xmin, *ymin, *xmax, *ymax;
X{
X	int	bx, by, sx, sy;
X	F_point	*p;
X
X	bx = sx = points->x; by = sy = points->y;
X	for (p = points->next; p != NULL; p = p->next) {
X	    sx = min(sx, p->x); sy = min(sy, p->y);
X	    bx = max(bx, p->x); by = max(by, p->y);
X	    }
X	*xmin = sx; *ymin = sy;
X	*xmax = bx; *ymax = by;
X	}
X
Xcontrol_points_bound(cps, xmin, ymin, xmax, ymax)
XF_control	*cps;
Xint		*xmin, *ymin, *xmax, *ymax;
X{
X	F_control	*c;
X	double		bx, by, sx, sy;
X
X	bx = sx = cps->lx;
X	by = sy = cps->ly;
X	sx = min(sx, cps->rx); sy = min(sy, cps->ry);
X	bx = max(bx, cps->rx); by = max(by, cps->ry);
X	for (c = cps->next; c != NULL; c = c->next) {
X	    sx = min(sx, c->lx); sy = min(sy, c->ly);
X	    bx = max(bx, c->lx); by = max(by, c->ly);
X	    sx = min(sx, c->rx); sy = min(sy, c->ry);
X	    bx = max(bx, c->rx); by = max(by, c->ry);
X	    }
X	*xmin = round(sx); *ymin = round(sy);
X	*xmax = round(bx); *ymax = round(by);
X	}
END_OF_FILE
if test 9753 -ne `wc -c <'transfig/fig2dev/bound.c'`; then
    echo shar: \"'transfig/fig2dev/bound.c'\" unpacked with wrong size!
fi
# end of 'transfig/fig2dev/bound.c'
fi
if test -f 'transfig/fig2dev/fig2dev.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'transfig/fig2dev/fig2dev.c'\"
else
echo shar: Extracting \"'transfig/fig2dev/fig2dev.c'\" \(5666 characters\)
sed "s/^X//" >'transfig/fig2dev/fig2dev.c' <<'END_OF_FILE'
X/* 
X *	Fig2dev : General Fig code translation program
X *
X*/
X#ifdef hpux
X#include <sys/types.h>
X#endif
X#include <sys/file.h>
X#include <stdio.h>
X#include <ctype.h>
X#include "object.h"
X#include "fig2dev.h"
X#include "drivers.h"
X
Xextern int getopt();
Xextern char *optarg;
Xextern int optind;
X
X#define DEFAULT_FONT_SIZE 11
X
Xstruct driver *dev = NULL;
X
Xchar		Usage[] = "Usage: %s [-L language] [-f font] [-s size] [-m scale] [input [output]]\n";
Xchar		Err_badarg[] = "Argument -%c unkown to %s driver.";
Xchar		Err_incomp[] = "Incomplete %s object at line %d.";
Xchar		Err_mem[] = "Running out of memory.";
X
Xchar		*prog;
Xchar		*from = NULL, *to = NULL;
Xint		font_size = 0;
Xdouble		mag = 1.0;
XFILE		*tfp = NULL;
Xint		llx = 0, lly = 0, urx = 0, ury = 0;
X
Xstruct obj_rec {
X	void (*gendev)();
X	char *obj;
X	int depth;
X};
X
Xput_msg(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
Xchar   *format, *arg1, *arg2, *arg3, *arg4, *arg5, *arg6, *arg7, *arg8;
X{
X	fprintf(stderr, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
X	fprintf(stderr, "\n");
X	}
X
Xget_args(argc, argv)
Xint	 argc;
Xchar	*argv[];
X{
X  	int	c, i;
X	double	atof();
X
X	prog = *argv;
X/* add :? */
X	while ((c = getopt(argc, argv, "cd:f:l:L:m:Pp:s:S:vwW:?")) != EOF) {
X
X	  /* generic option handling */
X	  switch (c) {
X
X		case 'L':			/* set output language */
X		    for (i=0; *drivers[i].name; i++) 
X			if (!strcmp(optarg, drivers[i].name))
X				dev = drivers[i].dev;
X		    if (!dev) {
X			fprintf(stderr,
X				"Unknown graphics language %s\n", optarg);
X			fprintf(stderr,"Known languages are:\n");
X			/* display available languages - 23/01/90 */
X			for (i=0; *drivers[i].name; i++)
X				fprintf(stderr,"%s ",drivers[i].name);
X			fprintf(stderr,"\n");
X			exit(1);
X		    }
X		    break;
X
X		case 's':			/* set default font size */
X		    font_size = atoi(optarg);
X		    break;
X
X		case 'm':			/* set magnification */
X		    mag = atof(optarg);
X		    break;
X
X		case '?':			/* usage 		*/
X			fprintf(stderr,Usage,prog);
X			exit(1);
X	    }
X
X	    /* pass options through to driver */
X	    if (!dev) {
X		fprintf(stderr, "No graphics language specified.\n");
X		exit(1);
X	    }
X	    dev->option(c, optarg);
X      }
X
X	/* default font size is scaled if not specified */
X	if (!font_size) font_size = DEFAULT_FONT_SIZE*mag + 0.5;
X
X	if (optind < argc) from = argv[optind++];  /*  from file  */
X	if (optind < argc) to   = argv[optind];  /*  to file    */
X}
X
Xmain(argc, argv)
Xint	 argc;
Xchar	*argv[];
X{
X	F_compound	objects;
X	int		status;
X
X	get_args(argc, argv);
X
X	if (to == NULL)
X	    tfp = stdout;
X	else if ((tfp = fopen(to, "w")) == NULL) {
X	    fprintf(stderr, "Couldn't open %s", to);
X	    fprintf(stderr, Usage, prog);
X	    exit(1);
X	    }
X
X	if (from)
X	    status = read_fig(from, &objects);
X	else	/* read from stdin */
X	    status = readfp_fig(stdin, &objects);
X
X	if (status != 0) {
X	    if (from) read_fail_message(from, status);
X	    exit(1);
X	    }
X	gendev_objects(&objects, dev);
X	if (tfp != stdout) (void)fclose(tfp);
X	exit(0);
X	}
X
X/* count primitive objects & create pointer array */
Xstatic int compound_dump(com, array, count, dev)
XF_compound *com;
Xstruct obj_rec *array;
Xint count;
Xstruct driver *dev;
X{
X  	F_arc		*a;
X	F_compound	*c;
X	F_ellipse	*e;
X	F_line		*l;
X	F_spline	*s;
X	F_text		*t;
X
X	for (c = com->compounds; c != NULL; c = c->next)
X	  count = compound_dump(c, array, count, dev);
X	for (a = com->arcs; a != NULL; a = a->next) {
X	  if (array) {
X		array[count].gendev = dev->arc;
X		array[count].obj = (char *)a;
X		array[count].depth = a->depth;
X	  }
X	  count += 1;
X	}
X	for (e = com->ellipses; e != NULL; e = e->next) {
X	  if (array) {
X		array[count].gendev = dev->ellipse;
X		array[count].obj = (char *)e;
X		array[count].depth = e->depth;
X	  }
X	  count += 1;
X	}
X	for (l = com->lines; l != NULL; l = l->next) {
X	  if (array) {
X		array[count].gendev = dev->line;
X		array[count].obj = (char *)l;
X		array[count].depth = l->depth;
X	  }
X	  count += 1;
X	}
X	for (s = com->splines; s != NULL; s = s->next) {
X	  if (array) {
X		array[count].gendev = dev->spline;
X		array[count].obj = (char *)s;
X		array[count].depth = s->depth;
X	  }
X	  count += 1;
X	}
X	for (t = com->texts; t != NULL; t = t->next) {
X	  if (array) {
X		array[count].gendev = dev->text;
X		array[count].obj = (char *)t;
X		array[count].depth = t->depth;
X	  }
X	  count += 1;
X	}
X	return count;
X}
X
Xgendev_objects(objects, dev)
XF_compound	*objects;
Xstruct driver *dev;
X{
X	F_arc		*a;
X	F_compound	*c;
X	F_ellipse	*e;
X	F_line		*l;
X	F_spline	*s;
X	F_text		*t;
X
X	int obj_count, rec_comp();
X	struct obj_rec *rec_array, *r; 
X
X	if (0 == (double)objects->nwcorner.x) {
X	    fprintf(stderr, "Resolution is zero!! default to 80 ppi\n");
X	    objects->nwcorner.x = 80;
X	    }
X	if (objects->nwcorner.y != 1 && objects->nwcorner.y != 2) {
X	    fprintf(stderr, "Wrong coordinate system; cannot continue\n");
X	    return;
X	    }
X
X	/* Compute bounding box of objects, supressing texts if indicated */
X	compound_bound(objects, &llx, &lly, &urx, &ury, dev->text_include);
X
X	/* dump object pointers to an array */
X	obj_count = compound_dump(objects, 0, 0, dev);
X	if (!obj_count) {
X	    fprintf(stderr, "No object");
X	    return;
X	    }
X	rec_array = (struct obj_rec *)malloc(obj_count*sizeof(struct obj_rec));
X	(void)compound_dump(objects, rec_array, 0, dev);
X
X	/* sort object array by depth */
X	qsort(rec_array, obj_count, sizeof(struct obj_rec), rec_comp);
X
X	/* generate header */
X	(*dev->start)(objects);
X
X	/* generate objects in sorted order */
X	for (r = rec_array; r<rec_array+obj_count; r++)
X		(*(r->gendev))(r->obj);
X
X	/* generate trailer */
X	(*dev->end)();
X}
X
Xint rec_comp(r1, r2)
Xstruct obj_rec *r1, *r2;
X{
X	return (r2->depth - r1->depth);
X}
X
X/* null operation */
Xvoid gendev_null() {};
END_OF_FILE
if test 5666 -ne `wc -c <'transfig/fig2dev/fig2dev.c'`; then
    echo shar: \"'transfig/fig2dev/fig2dev.c'\" unpacked with wrong size!
fi
# end of 'transfig/fig2dev/fig2dev.c'
fi
if test -f 'transfig/fig2dev/latex_line.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'transfig/fig2dev/latex_line.c'\"
else
echo shar: Extracting \"'transfig/fig2dev/latex_line.c'\" \(4499 characters\)
sed "s/^X//" >'transfig/fig2dev/latex_line.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <math.h>
X/* 
X *	latex_line.c: 
X *	    Subroutines for drawing and translating lines for the LaTeX
X *	    picture environment.
X *	Written by Frank Schmuck (schmuck@svax.cs.cornell.edu)
X *	June 1988
X *
X *	The LaTeX picture environment allows generating pictures in standard
X *	LaTeX.  However, some restrictions apply:  lines and vectors (a vector
X *	is a line with an arrow at the end) can only be drawn with a finite
X *	number of slopes.  The available slopes are given by dy/dx where
X *	dx and dy must be integers <= 6 for lines and <= 4 for vectors.
X *
X *	The subroutines in this file are used in fig2latex to approximate
X *	an arbitrary line or vector by a LaTeX line/vector, and in fig to 
X *	restrict line drawing to slopes supported by LaTeX.
X */
X
X/*
X * Constant for converting from radian to degrees
X */
Xdouble rad2deg = 57.295779513082320877;
X
Xint  pgcd(a,b)
X    int a, b;
X/*
X *  compute greatest common divisor, assuming 0 < a <= b
X */
X{
X    b = b % a;
X    return (b)? gcd(b, a): a;
X}
X
Xint  gcd(a, b)
X    int a, b;
X/*
X *  compute greatest common divisor
X */
X{
X    if (a < 0) a = -a;
X    if (b < 0) b = -b;
X    return (a <= b)? pgcd(a, b): pgcd(b, a);
X}
X
Xint  lcm(a, b)
X    int a, b;
X/*
X *  Compute least common multiple
X */
X{
X    return abs(a*b)/gcd(a,b);
X}
X
X/*
X *  Tables of line and vector slopes supported by LaTeX
X */
X 
Xstruct angle_table {
X    int    x, y;
X    double angle;
X};
X
X#define N_LINE 25
X
Xstruct angle_table line_angles[N_LINE] =
X  { {0, 1, 90.0}, 
X    {1, 0,  0.0},
X    {1, 1, 45.0}, 
X    {1, 2, 63.434948822922010648},
X    {1, 3, 71.565051177077989351},
X    {1, 4, 75.963756532073521417},
X    {1, 5, 78.690067525979786913},
X    {1, 6, 80.537677791974382609},
X    {2, 1, 26.565051177077989351},
X    {2, 3, 56.309932474020213086},
X    {2, 5, 68.198590513648188229}, 
X    {3, 1, 18.434948822922010648},
X    {3, 2, 33.690067525979786913},
X    {3, 4, 53.130102354155978703},
X    {3, 5, 59.036243467926478582},
X    {4, 1, 14.036243467926478588},
X    {4, 3, 36.869897645844021297},
X    {4, 5, 51.340191745909909396},
X    {5, 1, 11.309932474020213086},
X    {5, 2, 21.801409486351811770},
X    {5, 3, 30.963756532073521417},
X    {5, 4, 38.659808254090090604},
X    {5, 6, 50.194428907734805993},
X    {6, 1, 9.4623222080256173906},
X    {6, 5, 39.805571092265194006}
X  };
X
X#define N_ARROW 13
X
Xstruct angle_table arrow_angles[N_ARROW] =
X  { {0, 1, 90.0}, 
X    {1, 0,  0.0},
X    {1, 1, 45.0}, 
X    {1, 2, 63.434948822922010648},
X    {1, 3, 71.565051177077989351},
X    {1, 4, 75.963756532073521417},
X    {2, 1, 26.565051177077989351},
X    {2, 3, 56.309932474020213086},
X    {3, 1, 18.434948822922010648},
X    {3, 2, 33.690067525979786913},
X    {3, 4, 53.130102354155978703},
X    {4, 1, 14.036243467926478588},
X    {4, 3, 36.869897645844021297},
X  };
X
Xget_slope(dx, dy, sxp, syp, arrow)
X    int  dx, dy, *sxp, *syp, arrow;
X/*
X *  Find the LaTeX line slope that is closest to the one given by dx, dy.
X *  Result is returned in *sxp, *syp.  If (arrow != 0) the closest LaTeX
X *  vector slope is selected.
X */
X{
X    double angle;
X    int    i, s, max;
X    double d, d1;
X    struct angle_table *st;
X
X    if (dx == 0) {
X	*sxp = 0;
X	*syp = (dy < 0)? -1: 1;
X	return;
X    }
X    angle = atan((double)abs(dy) / (double)abs(dx)) * rad2deg;
X    if (arrow) {
X	st = arrow_angles;
X	max = N_ARROW;
X    } else {
X	st = line_angles;
X	max = N_LINE;
X    }
X    s = 0;
X    d = 9.9e9;
X    for (i = 0; i < max; i++) {
X	d1 = fabs(angle - st[i].angle);
X	if (d1 < d) {
X	    s = i;
X	    d = d1;
X	} 
X    }
X    *sxp = st[s].x;
X    if (dx < 0) *sxp = -*sxp;
X    *syp = st[s].y;
X    if (dy < 0) *syp = -*syp;
X}
X
Xlatex_endpoint(x1, y1, x2, y2, xout, yout, arrow, magnet)
X    int  x1, y1, x2, y2;
X    int  *xout, *yout;
X    int  arrow, magnet;
X/*
X *  Computes a point "close" to (x2,y2) that is reachable from (x1,y1)
X *  by a LaTeX line (LaTeX vector if arrow != 0).  The result is returned
X *  in *xout, *yout.  If (magnet > 1) the point returned is selected such that
X *  (*xout - x1) and (*yout - y1) are both multiples of magnet.
X */
X{
X    int    dx, dy, sx, sy, ds, dsx, dsy;
X
X    dx = x2-x1;
X    dy = y2-y1;
X    get_slope(dx, dy, &sx, &sy, arrow);
X    if (abs(sx) >= abs(sy)) {
X	ds = lcm(sx, magnet*gcd(sx,magnet));
X	dsx = (2*abs(dx)/ds + 1)/2;
X	dsx = (dx >= 0)? dsx*ds: -dsx*ds;
X	*xout = x1 + dsx;
X	*yout = y1 + dsx*sy/sx;
X    } else {
X	ds = lcm(sy, magnet*gcd(sy,magnet));
X	dsy = (2*abs(dy)/ds + 1)/2;
X	dsy = (dy >= 0)? dsy*ds: -dsy*ds;
X	*yout = y1 + dsy;
X	*xout = x1 + dsy*sx/sy;
X    }
X}
END_OF_FILE
if test 4499 -ne `wc -c <'transfig/fig2dev/latex_line.c'`; then
    echo shar: \"'transfig/fig2dev/latex_line.c'\" unpacked with wrong size!
fi
# end of 'transfig/fig2dev/latex_line.c'
fi
if test -f 'transfig/fig2dev/object.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'transfig/fig2dev/object.h'\"
else
echo shar: Extracting \"'transfig/fig2dev/object.h'\" \(4954 characters\)
sed "s/^X//" >'transfig/fig2dev/object.h' <<'END_OF_FILE'
X#define					DEFAULT			(-1)
X
Xtypedef		struct f_pattern {
X			int			w, h;
X			int			*p;
X			}
X		F_pattern;
X
Xtypedef		struct f_pen {
X			int			x, y;
X			int			*p;
X			}
X		F_pen;
X
Xtypedef		struct f_point {
X			int			x, y;
X			struct f_point		*next;
X			}
X		F_point;
X
Xtypedef		struct f_pos {
X			int			x, y;
X			}
X		F_pos;
X
Xtypedef		struct f_arrow {
X			int			type;
X			int			style;
X			double			thickness;
X			double			wid;
X			double			ht;
X			}
X		F_arrow;
X
Xtypedef		struct f_ellipse {
X			int			type;
X#define					T_ELLIPSE_BY_RAD	1
X#define					T_ELLIPSE_BY_DIA	2
X#define					T_CIRCLE_BY_RAD		3
X#define					T_CIRCLE_BY_DIA		4
X			int			style;
X			int			thickness;
X			int			color;
X#define					BLACK			0
X			int			depth;
X			int			direction;
X			double			style_val;
X			double			angle;
X			struct f_pen		*pen;
X			struct f_pattern	*area_fill;
X#define		       			UNFILLED	(F_pattern *)0
X#define		       			BLACK_FILL	(F_pattern *)1
X#define		       			DARK_GRAY_FILL	(F_pattern *)2
X#define		       			MED_GRAY_FILL	(F_pattern *)3
X#define		       			LIGHT_GRAY_FILL	(F_pattern *)4
X#define		       			WHITE_FILL	(F_pattern *)5
X			struct f_pos		center;
X			struct f_pos		radiuses;
X			struct f_pos		start;
X			struct f_pos		end;
X			struct f_ellipse	*next;
X			}
X		F_ellipse;
X
Xtypedef		struct f_arc {
X			int			type;
X#define					T_3_POINTS_ARC		1
X			int			style;
X			int			thickness;
X			int			color;
X			int			depth;
X			struct f_pen		*pen;
X			struct f_pattern	*area_fill;
X			double			style_val;
X			int			direction;
X			struct f_arrow		*for_arrow;
X			struct f_arrow		*back_arrow;
X			struct {double x, y;}	center;
X			struct f_pos		point[3];
X			struct f_arc		*next;
X			}
X		F_arc;
X
Xtypedef		struct f_line {
X			int			type;
X#define					T_POLYLINE	1
X#define					T_BOX		2
X#define					T_POLYGON	3
X#define	                                T_ARC_BOX       4
X/* JNT */
X			int			style;
X			int			thickness;
X			int			color;
X			int			depth;
X			double			style_val;
X			int			radius;	/* for T_ARC_BOX */
X			struct f_pen		*pen;
X			struct f_pattern	*area_fill;
X			struct f_arrow		*for_arrow;
X			struct f_arrow		*back_arrow;
X			struct f_point		*points;
X			struct f_line		*next;
X			}
X		F_line;
X
Xtypedef		struct f_text {
X			int			type;
X#define					T_LEFT_JUSTIFIED	0
X#define					T_CENTER_JUSTIFIED	1
X#define					T_RIGHT_JUSTIFIED	2
X			int			font;
X#define					DEFAULT_FONT		0
X#define					ROMAN_FONT		1
X#define					BOLD_FONT		2
X#define					ITALIC_FONT		3
X#define					MODERN_FONT		4
X#define					TYPEWRITER_FONT		5
X			int			size;	/* point size */
X			int			color;
X			int			depth;
X			double			angle;	/* in radian */
X			int			style;
X#define					PLAIN		1
X#define					ITALIC		2
X#define					BOLD		4
X#define					OUTLINE		8
X#define					SHADOW		16
X			int			height;	/* pixels */
X			int			length;	/* pixels */
X			int			base_x;
X			int			base_y;
X			struct f_pen		*pen;
X			char			*cstring;
X			struct f_text		*next;
X			}
X		F_text;
X
Xtypedef		struct f_control {
X			double			lx, ly, rx, ry;
X			struct f_control	*next;
X			}
X		F_control;
X
X#define		int_spline(s)		(s->type & 0x2)
X#define		normal_spline(s)	(!(s->type & 0x2))
X#define		closed_spline(s)	(s->type & 0x1)
X#define		open_spline(s)		(!(s->type & 0x1))
X
Xtypedef		struct f_spline {
X			int			type;
X#define					T_OPEN_NORMAL		0
X#define					T_CLOSED_NORMAL		1
X#define					T_OPEN_INTERPOLATED	2
X#define					T_CLOSED_INTERPOLATED	3
X			int			style;
X			int			thickness;
X			int			color;
X			int			depth;
X			double			style_val;
X			struct f_pen		*pen;
X			struct f_pattern	*area_fill;
X			struct f_arrow		*for_arrow;
X			struct f_arrow		*back_arrow;
X			/*
X			For T_OPEN_NORMAL and T_CLOSED_NORMAL points
X			are control points while they are knots for
X			T_OPEN_INTERPOLATED and T_CLOSED_INTERPOLTED
X			whose control points are stored in controls.
X			*/
X			struct f_point		*points;
X			struct f_control	*controls;
X			struct f_spline		*next;
X			}
X		F_spline;
X
Xtypedef		struct f_compound {
X			struct f_pos		nwcorner;
X			struct f_pos		secorner;
X			struct f_line		*lines;
X			struct f_ellipse	*ellipses;
X			struct f_spline		*splines;
X			struct f_text		*texts;
X			struct f_arc		*arcs;
X			struct f_compound	*compounds;
X			struct f_compound	*next;
X			}
X		F_compound;
X
X#define		ARROW_SIZE		sizeof(struct f_arrow)
X#define		POINT_SIZE		sizeof(struct f_point)
X#define		CONTROL_SIZE		sizeof(struct f_control)
X#define		ELLOBJ_SIZE		sizeof(struct f_ellipse)
X#define		ARCOBJ_SIZE		sizeof(struct f_arc)
X#define		LINOBJ_SIZE		sizeof(struct f_line)
X#define		TEXOBJ_SIZE		sizeof(struct f_text)
X#define		SPLOBJ_SIZE		sizeof(struct f_spline)
X#define		COMOBJ_SIZE		sizeof(struct f_compound)
X
X/**********************  object codes  **********************/
X
X#define		O_ELLIPSE		1
X#define		O_POLYLINE		2
X#define		O_SPLINE		3
X#define		O_TEXT			4
X#define		O_ARC			5
X#define		O_COMPOUND		6
X#define		O_END_COMPOUND		(-O_COMPOUND)
X#define		O_ALL_OBJECT		99
X
X/************  object styles (except for f_text)  ************/
X
X#define		SOLID_LINE		0
X#define		DASH_LINE		1
X#define		DOTTED_LINE		2
X
X#define		CLOSED_PATH		0
X#define		OPEN_PATH		1
END_OF_FILE
if test 4954 -ne `wc -c <'transfig/fig2dev/object.h'`; then
    echo shar: \"'transfig/fig2dev/object.h'\" unpacked with wrong size!
fi
# end of 'transfig/fig2dev/object.h'
fi
if test -f 'transfig/fig2dev/read1_3.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'transfig/fig2dev/read1_3.c'\"
else
echo shar: Extracting \"'transfig/fig2dev/read1_3.c'\" \(9833 characters\)
sed "s/^X//" >'transfig/fig2dev/read1_3.c' <<'END_OF_FILE'
X/*******************************************************************/
X/***************       Read version 1.3 format       ***************/
X/*******************************************************************/
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <errno.h>
X#include "alloc.h"
X#include "object.h"
X
X/*******    Fig 1.3 subtype of objects    *******/
X#define			DRAW_ELLIPSE_BY_RAD 	1
X#define			DRAW_ELLIPSE_BY_DIA 	2
X#define			DRAW_CIRCLE_BY_RAD 	3
X#define			DRAW_CIRCLE_BY_DIA 	4
X#define			DRAW_CIRCULAR_ARC	5
X#define			DRAW_POLYLINE		6
X#define			DRAW_BOX		7
X#define			DRAW_POLYGON		8
X#define			DRAW_TEXT		9
X#define			DRAW_SPLINE		10
X#define			DRAW_CLOSEDSPLINE	11
X#define			DRAW_COMPOUND		13
X
Xextern F_arrow		*forward_arrow(), *backward_arrow();
Xextern int		figure_modified;
Xextern int		errno;
Xextern char		*sys_errlist[];
Xextern int		sys_nerr, errno;
X
Xstatic F_ellipse	*read_ellipseobject();
Xstatic F_line		*read_lineobject();
Xstatic F_text		*read_textobject();
Xstatic F_spline		*read_splineobject();
Xstatic F_arc		*read_arcobject();
Xstatic F_compound	*read_compoundobject();
X
Xextern int		line_no;
Xextern int		num_object;
X
Xint
Xread_1_3_objects(fp, obj)
XFILE		*fp;
XF_compound	*obj;
X{
X	F_ellipse	*e, *le = NULL;
X	F_line		*l, *ll = NULL;
X	F_text		*t, *lt = NULL;
X	F_spline	*s, *ls = NULL;
X	F_arc		*a, *la = NULL;
X	F_compound	*c, *lc = NULL;
X	int		 n;
X	int		 object, pixperinch, canvaswid, canvasht, coord_sys;
X
X	n = fscanf(fp,"%d%d%d%d\n", &pixperinch, &coord_sys, &canvaswid, &canvasht);
X	if (n != 4) {
X	    put_msg("Incorrect format in the first line in input file");
X	    return(-1);
X	    }
X	obj->nwcorner.x = pixperinch;
X	obj->nwcorner.y = coord_sys;
X	while (fscanf(fp, "%d", &object) == 1) {
X	    switch (object) {
X		case O_POLYLINE :
X		    if ((l = read_lineobject(fp)) == NULL) return(-1);
X		    if (ll)
X			ll = (ll->next = l);
X		    else
X			ll = obj->lines = l;
X		    num_object++;
X		    break;
X		case O_SPLINE :
X		    if ((s = read_splineobject(fp)) == NULL) return(-1);
X		    if (ls)
X			ls = (ls->next = s);
X		    else
X			ls = obj->splines = s;
X		    num_object++;
X		    break;
X		case O_ELLIPSE :
X		    if ((e = read_ellipseobject(fp)) == NULL) return(-1);
X		    if (le)
X			le = (le->next = e);
X		    else
X			le = obj->ellipses = e;
X		    num_object++;
X		    break;
X		case O_ARC :
X		    if ((a = read_arcobject(fp)) == NULL) return(-1);
X		    if (la)
X			la = (la->next = a);
X		    else
X			la = obj->arcs = a;
X		    num_object++;
X		    break;
X		case O_TEXT :
X		    if ((t = read_textobject(fp)) == NULL) return(-1);
X		    if (lt)
X			lt = (lt->next = t);
X		    else
X			lt = obj->texts = t;
X		    num_object++;
X		    break;
X		case O_COMPOUND :
X		    if ((c = read_compoundobject(fp)) == NULL) return(-1);
X		    if (lc)
X			lc = (lc->next = c);
X		    else
X			lc = obj->compounds = c;
X		    num_object++;
X		    break;
X		default:
X		    put_msg("Incorrect object code %d", object);
X		    return(-1);
X		} /*  switch */
X	    } /*  while */
X	if (feof(fp))
X	    return(0);
X	else
X	    return(errno);
X	}
X
Xstatic F_arc *
Xread_arcobject(fp)
XFILE	*fp;
X{
X	F_arc	*a;
X	int	f, b, h, w, n;
X
X	Arc_malloc(a);
X	a->type = T_3_POINTS_ARC;
X	a->color = BLACK;
X	a->depth = 0;
X	a->pen = NULL;
X	a->for_arrow = NULL;
X	a->back_arrow = NULL;
X	a->next = NULL;
X	n = fscanf(fp, " %d %d %d %lf %d %d %d %d %d %lf %lf %d %d %d %d %d %d\n",
X		&a->type, &a->style, &a->thickness, 
X		&a->style_val, &a->direction, &f, &b,
X		&h, &w, &a->center.x, &a->center.y, 
X		&a->point[0].x, &a->point[0].y, 
X		&a->point[1].x, &a->point[1].y, 
X		&a->point[2].x, &a->point[2].y);
X	if (n != 17) {
X	    put_msg("incomplete arc data");
X	    free((char*)a);
X	    return(NULL);
X	    }
X	if (f) {
X	    a->for_arrow = forward_arrow();
X	    a->for_arrow->wid = w;
X	    a->for_arrow->ht = h;
X	    }
X	if (b) {
X	    a->back_arrow = backward_arrow();
X	    a->back_arrow->wid = w;
X	    a->back_arrow->ht = h;
X	    }
X	return(a);
X	}
X
Xstatic F_compound *
Xread_compoundobject(fp)
XFILE	*fp;
X{
X	F_arc		*a, *la = NULL;
X	F_ellipse	*e, *le = NULL;
X	F_line		*l, *ll = NULL;
X	F_spline	*s, *ls = NULL;
X	F_text		*t, *lt = NULL;
X	F_compound	*com, *c, *lc = NULL;
X	int		 n, object;
X
X	Compound_malloc(com);
X	com->arcs = NULL;
X	com->ellipses = NULL;
X	com->lines = NULL;
X	com->splines = NULL;
X	com->texts = NULL;
X	com->compounds = NULL;
X	com->next = NULL;
X	n = fscanf(fp, " %d %d %d %d\n", &com->nwcorner.x, &com->nwcorner.y,
X		&com->secorner.x, &com->secorner.y);
X	if (n != 4) {
X	    put_msg("Incorrect compound object format");
X	    return(NULL);
X	    }
X	while (fscanf(fp, "%d", &object) == 1) {
X	    switch (object) {
X		case O_POLYLINE :
X		    if ((l = read_lineobject(fp)) == NULL) { 
X			free_line(&l);
X			return(NULL);
X			}
X		    if (ll)
X			ll = (ll->next = l);
X		    else
X			ll = com->lines = l;
X		    break;
X		case O_SPLINE :
X		    if ((s = read_splineobject(fp)) == NULL) { 
X			free_spline(&s);
X			return(NULL);
X			}
X		    if (ls)
X			ls = (ls->next = s);
X		    else
X			ls = com->splines = s;
X		    break;
X		case O_ELLIPSE :
X		    if ((e = read_ellipseobject(fp)) == NULL) { 
X			free_ellipse(&e);
X			return(NULL);
X			}
X		    if (le)
X			le = (le->next = e);
X		    else
X			le = com->ellipses = e;
X		    break;
X		case O_ARC :
X		    if ((a = read_arcobject(fp)) == NULL) { 
X			free_arc(&a);
X			return(NULL);
X			}
X		    if (la)
X			la = (la->next = a);
X		    else
X			la = com->arcs = a;
X		    break;
X		case O_TEXT :
X		    if ((t = read_textobject(fp)) == NULL) { 
X			free_text(&t);
X			return(NULL);
X			}
X		    if (lt)
X			lt = (lt->next = t);
X		    else
X			lt = com->texts = t;
X		    break;
X		case O_COMPOUND :
X		    if ((c = read_compoundobject(fp)) == NULL) { 
X			free_compound(&c);
X			return(NULL);
X			}
X		    if (lc)
X			lc = (lc->next = c);
X		    else
X			lc = com->compounds = c;
X		    break;
X		case O_END_COMPOUND :
X		    return(com);
X		} /*  switch */
X	    }
X	if (feof(fp))
X	    return(com);
X	else {
X	    put_msg("Format error: %s", sys_errlist[errno]);
X	    return(NULL);
X	    }
X	}
X
Xstatic F_ellipse *
Xread_ellipseobject(fp)
XFILE	*fp;
X{
X	F_ellipse	*e;
X	int		n, t;
X
X	Ellipse_malloc(e);
X	e->color = BLACK;
X	e->angle = 0.0;
X	e->depth = 0;
X	e->pen = NULL;
X	e->area_fill = NULL;
X	e->next = NULL;
X	n = fscanf(fp," %d %d %d %lf %d %d %d %d %d %d %d %d %d\n", 
X		&t, &e->style,
X		&e->thickness, &e->style_val, &e->direction, 
X		&e->center.x, &e->center.y, 
X		&e->radiuses.x, &e->radiuses.y, 
X		&e->start.x, &e->start.y, 
X		&e->end.x, &e->end.y);
X	if (n != 13) {
X	    put_msg("incomplete ellipse data");
X	    free((char*)e);
X	    return(NULL);
X	    }
X	if (t == DRAW_ELLIPSE_BY_RAD)
X	    e->type = T_ELLIPSE_BY_RAD;
X	else if (t == DRAW_ELLIPSE_BY_DIA)
X	    e->type = T_ELLIPSE_BY_DIA;
X	else if (t == DRAW_CIRCLE_BY_RAD)
X	    e->type = T_CIRCLE_BY_RAD;
X	else
X	    e->type = T_CIRCLE_BY_DIA;
X	return(e);
X	}
X
Xstatic F_line *
Xread_lineobject(fp)
XFILE			*fp;
X{
X	F_line	*l;
X	F_point	*p, *q;
X	int	f, b, h, w, n, t, x, y;
X
X	Line_malloc(l);
X	l->color = BLACK;
X	l->depth = 0;
X	l->pen = NULL;
X	l->area_fill = NULL;
X	l->for_arrow = NULL;
X	l->back_arrow = NULL;
X	l->next = NULL;
X	l->points = Point_malloc(p);
X	n = fscanf(fp, " %d %d %d %lf %d %d %d %d %d %d", &t, 
X		&l->style, &l->thickness, &l->style_val,
X		&f, &b, &h, &w, &p->x, &p->y);
X	if (n != 10) {
X	    put_msg("incomplete line data");
X	    free((char*)l);
X	    return(NULL);
X	    }
X	if (t == DRAW_POLYLINE)
X	    l->type = T_POLYLINE;
X	else if (t == DRAW_POLYGON)
X	    l->type = T_POLYGON;
X	else
X	    l->type = T_BOX;
X	if (f) {
X	    l->for_arrow = forward_arrow();
X	    l->for_arrow->wid = w;
X	    l->for_arrow->ht = h;
X	    }
X	if (b) {
X	    l->back_arrow = backward_arrow();
X	    l->back_arrow->wid = w;
X	    l->back_arrow->ht = h;
X	    }
X	for (;;) {
X	    if (fscanf(fp, " %d %d", &x, &y) != 2) {
X		put_msg("incomplete line object");
X		free_linestorage(l);
X		return(NULL);
X		}
X	    if (x == 9999) break;
X	    Point_malloc(q);
X	    q->x = x;
X	    q->y = y;
X	    q->next = NULL;
X	    p->next = q;
X	    p = q;
X	    }
X	return(l);
X	}
X
Xstatic F_spline *
Xread_splineobject(fp)
XFILE	*fp;
X{
X	F_spline	*s;
X	F_point		*p, *q;
X	int		f, b, h, w, n, t, x, y;
X
X	Spline_malloc(s);
X	s->color = BLACK;
X	s->depth = 0;
X	s->pen = NULL;
X	s->area_fill = NULL;
X	s->for_arrow = NULL;
X	s->back_arrow = NULL;
X	s->controls = NULL;
X	s->next = NULL;
X	s->points = Point_malloc(p);
X	n = fscanf(fp, " %d %d %d %lf %d %d %d %d %d %d", 
X	    	&t, &s->style, &s->thickness, &s->style_val,
X	    	&f, &b,
X	    	&h, &w, &p->x, &p->y);
X	if (n != 10) {
X	    put_msg("incomplete spline data");
X	    free((char*)s);
X	    return(NULL);
X	    }
X	if (t == DRAW_CLOSEDSPLINE)
X	    s->type = T_CLOSED_NORMAL;
X	else
X	    s->type = T_OPEN_NORMAL;
X	if (f) {
X	    s->for_arrow = forward_arrow();
X	    s->for_arrow->wid = w;
X	    s->for_arrow->ht = h;
X	    }
X	if (b) {
X	    s->back_arrow = backward_arrow();
X	    s->back_arrow->wid = w;
X	    s->back_arrow->ht = h;
X	    }
X	for (;;) {
X	    if (fscanf(fp, " %d %d", &x, &y) != 2) {
X		put_msg("incomplete spline object");
X		free_splinestorage(s);
X		return(NULL);
X		};
X	    if (x == 9999) break;
X	    Point_malloc(q);
X	    q->x = x;
X	    q->y = y;
X	    q->next = NULL;
X	    p->next = q;
X	    p = q;
X	    }
X	return(s);
X	}
X
Xstatic F_text *
Xread_textobject(fp)
XFILE	*fp;
X{
X	F_text	*t;
X	int	n;
X	char	buf[128];
X
X	Text_malloc(t);
X	t->type = T_LEFT_JUSTIFIED;
X	t->style = PLAIN;
X	t->color = BLACK;
X	t->depth = 0;
X	t->pen = NULL;
X	t->angle = 0.0;
X	t->next = NULL;
X	n = fscanf(fp," %d %d %d %d %d %d %d %[^\n]", &t->font, 
X		&t->size, &t->style, &t->height, &t->length, 
X		&t->base_x, &t->base_y, buf);
X	if (n != 8) {
X	    put_msg("incomplete text data");
X	    free((char*)t);
X	    return(NULL);
X	    }
X	t->cstring = (char *) calloc((unsigned)(strlen(buf)+1), sizeof(char));
X	if (t->cstring == NULL) {
X	    put_msg(Err_mem);
X	    free((char*) t);
X	    return(NULL);
X	    }
X	(void)strcpy(t->cstring, buf);
X	if (t->size == 0) t->size = 18;
X	return(t);
X	}
END_OF_FILE
if test 9833 -ne `wc -c <'transfig/fig2dev/read1_3.c'`; then
    echo shar: \"'transfig/fig2dev/read1_3.c'\" unpacked with wrong size!
fi
# end of 'transfig/fig2dev/read1_3.c'
fi
echo shar: End of archive 2 \(of 6\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
