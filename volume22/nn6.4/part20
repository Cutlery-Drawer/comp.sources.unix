Newsgroups: comp.sources.unix
Subject: REPOST v22i054:  NN Newsreader, release 6.4, Part20/21
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: f47b9bb9 df15399e 12fc4738 f5c7ca7c

Submitted-by: "Kim F. Storm" <storm@texas.dk>
Posting-number: Volume 22, Issue 54
Archive-name: nn6.4/part20

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  active.c conf/s-bsd4-2.h conf/s-sys5.h contrib/aspell db.h
#   doc/RELEASE_NOTES fullname.c help/help.commands hostname.c
#   inews/conf.h inews/nntp.h init.sample man/nncheck.1 man/nngrep.1
#   match.c nnstats.sh nntp.h
# Wrapped by storm@texas.dk on Sun May  6 18:20:22 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 20 (of 22)."'
if test -f 'active.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'active.c'\"
else
  echo shar: Extracting \"'active.c'\" \(2547 characters\)
  sed "s/^X//" >'active.c' <<'END_OF_FILE'
X/*
X *	(c) Copyright 1990, Kim Fabricius Storm.  All rights reserved.
X *
X *	read/update incore copy of active file
X */
X
X#include "config.h"
X
Xread_active_file(act, copy)
XFILE *act, *copy;
X{
X    char line[512];
X    register char *cp, *name;
X    register group_header *gh, *gh1;
X    group_header *add_new_group(), *lookup_no_alias();
X    int must_update;
X    register flag_type old_flag;
X    
X    Loop_Groups_Header(gh)
X	gh->master_flag &= ~M_VALID;
X
X    while (fgets(line, 512, act)) {
X	if (copy != NULL) fputs(line, copy);
X	must_update = 0;
X
X	cp = line;
X	while (*cp && isspace(*cp)) cp++; /* eat blank lines */
X	if (*cp == NUL || *cp == '#') continue;
X
X	/* cp -> NAME space 00888 ... nl */
X	name = cp;
X	while (*cp != ' ') cp++;
X	*cp++ = NUL;
X
X	gh = lookup_no_alias(name);
X	if (gh == NULL) {
X	    /* new group */
X	    gh = add_new_group(name);
X	    if (gh == NULL) continue;
X	    must_update = 1;
X	}
X	
X	while (*cp && isspace(*cp)) cp++;
X	gh->last_a_article = atol(cp);
X
X	while (*cp && isdigit(*cp)) cp++;
X	while (*cp && isspace(*cp)) cp++;
X
X	if (*cp == NUL) {
X	    log_entry('E', "Error in active file for entry %s", name);
X	    continue;
X	}
X
X	gh->first_a_article = atol(cp);
X	if (gh->first_a_article == 0) gh->first_a_article = 1;
X	while (*cp && isdigit(*cp)) cp++;
X	while (*cp && isspace(*cp)) cp++;
X
X	gh->master_flag |= M_VALID;
X	if (gh->master_flag & M_IGNORE_G) continue;
X
X	old_flag = gh->master_flag & 
X	    (M_IGNORE_A | M_MODERATED | M_NOPOST | M_ALIASED);
X	gh->master_flag &= 
X	    ~(M_IGNORE_A | M_MODERATED | M_NOPOST | M_ALIASED);
X	
X	switch (*cp) {
X	 default:
X	    break;
X
X	 case 'x':
X	    gh->master_flag |= M_IGNORE_A;
X	    if ((old_flag & (M_IGNORE_A|M_ALIASED)) == M_IGNORE_A) continue;
X	    must_update++;
X	    break;
X
X	 case 'm':
X	    gh->master_flag |= M_MODERATED;
X	    if (old_flag & M_MODERATED) continue;
X	    must_update++;
X	    break;
X
X	 case 'n':
X	    gh->master_flag |= M_NOPOST;
X	    if (old_flag & M_NOPOST) continue;
X	    must_update++;
X	    break;
X
X	 case '=':
X	    gh->master_flag |= M_ALIASED | M_IGNORE_A;
X	    if (old_flag & M_ALIASED) continue;
X	    while (*++cp && isspace(*cp)) cp++;
X	    name = cp;
X	    while (*cp && !isspace(*cp)) cp++;
X	    *cp = NUL;
X	    gh1 = lookup(name);
X	    gh->data_write_offset = (off_t)gh1->group_num;
X	    must_update = 1;
X	    break;
X	}
X
X	if ((old_flag & M_ALIASED) && (gh->master_flag & M_ALIASED) == 0) {
X	    gh->data_write_offset = 0;
X	    gh->master_flag |= M_MUST_CLEAN;
X	    continue;
X	}
X	    
X	if (must_update && who_am_i == I_AM_MASTER)
X	    db_write_group(gh);
X    }
X}
END_OF_FILE
  if test 2547 -ne `wc -c <'active.c'`; then
    echo shar: \"'active.c'\" unpacked with wrong size!
  fi
  # end of 'active.c'
fi
if test -f 'conf/s-bsd4-2.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'conf/s-bsd4-2.h'\"
else
  echo shar: Extracting \"'conf/s-bsd4-2.h'\" \(2628 characters\)
  sed "s/^X//" >'conf/s-bsd4-2.h' <<'END_OF_FILE'
X/*
X *	This version is for BSD 4.2 systems
X */
X
X
X/*
X *	Include header files containing the following definitions:
X *
X * 		off_t, time_t, struct stat
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X
X/*
X *	Define if your system has system V like ioctls
X */
X
X#undef	HAVE_TERMIO			/* */
X
X/*
X *	Define to use terminfo database.
X *	Otherwise, termcap is used
X */
X
X#undef	USE_TERMINFO			/* */
X
X/*
X *	Specify the library (or libraries) containing the termcap/terminfo
X *	routines.
X *
X *	Notice:  nn only uses the low-level terminal access routines
X *	(i.e. it does not use curses).
X */
X
X#define TERMLIB	-ltermlib
X
X/*
X *	Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X
X#ifdef USE_STRINGS_H
X#undef USE_STRINGS_H
X#include <strings.h>
X#else
X#include <string.h>
X#endif
X
X#undef HAVE_STRCHR			/* */
X
X/*
X *	Define if a signal handler has type void (see signal.h)
X */
X
X#undef	SIGNAL_HANDLERS_ARE_VOID	/* */
X
X/*
X *	Define MICRO_ALARM to timeout in 0.1 seconds if possible
X */
X
X#define MICRO_ALARM()	alarm(1)	/* could use setitimer ... */
X
X/*
X *	Define if your system has BSD like job control (SIGTSTP works)
X */
X
X#define HAVE_JOBCONTROL			/* */
X
X/*
X *	Define if your system provides the "directory(3X)" access routines
X *
X *	If true, include the header file(s) required by the package below
X *	(remember that <sys/types.h> or equivalent is included above)
X *	Also typedef Direntry to the proper struct type.
X */
X
X#define	HAVE_DIRECTORY			/* */
X
X#include <sys/dir.h>			/* BSD */
X
Xtypedef struct direct Direntry;		/* BSD */
X
X/*
X *	Define if your system has a mkdir() library routine
X */
X
X#define	HAVE_MKDIR			/* */
X
X/*
X *	Define if your system provides a BSD like gethostname routine.
X *	Otherwise, define HAVE_UNAME if uname() is avaiable.
X */
X
X#define	HAVE_GETHOSTNAME	/* BSD systems */
X
X/*
X *	Define HAVE_MULTIGROUP if system has simultaneous multiple group
X *	membership capability (BSD style).
X */
X
X#define HAVE_MULTIGROUP
X
X/*
X *	Define DETATCH_TERMINAL to be a command sequence which
X *	will detatch a process from the control terminal
X *	Also include system files needed to perform this HERE.
X *	If not possible, just define it (empty)
X */
X
X#include <sys/file.h>	/* for O_RDONLY */
X#include <sys/ioctl.h>	/* for TIOCNOTTY */
X
X#define	DETATCH_TERMINAL \
X    { int t = open("/dev/tty", O_RDONLY); \
X	  if (t >= 0) ioctl(t, TIOCNOTTY, (int *)0), close(t); }
X
X
X/*
X *	Specify where the Bourne Shell is.
X */
X
X#define SHELL		"/bin/sh"
X
X/*
X *	Specify the default mailer to be invoked by nnmail
X */
X
X#define	MAILX	"/usr/ucb/Mail"		/* BSD */
X
X/*
X *	Define the maximum length of any pathname that may occur
X */
X
X#define	FILENAME 	256
END_OF_FILE
  if test 2628 -ne `wc -c <'conf/s-bsd4-2.h'`; then
    echo shar: \"'conf/s-bsd4-2.h'\" unpacked with wrong size!
  fi
  # end of 'conf/s-bsd4-2.h'
fi
if test -f 'conf/s-sys5.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'conf/s-sys5.h'\"
else
  echo shar: Extracting \"'conf/s-sys5.h'\" \(2736 characters\)
  sed "s/^X//" >'conf/s-sys5.h' <<'END_OF_FILE'
X/*
X *	This is a generic System V Release 2 & 3 file.
X *
X *	If you need to modify anything, make a new s- file,
X *	#include this file, and #define or #undef a few symbols.
X */
X
X
X/*
X *	Include header files containing the following definitions:
X *
X * 		off_t, time_t, struct stat
X */
X
X#ifdef lint
Xstruct proc {	/* sys/types.h references this on many systems */
X    int keep_lint_happy;
X};
X#endif
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X/*
X *	Define if your system has system V like ioctls
X */
X
X#define	HAVE_TERMIO			/* */
X
X/*
X *	Define to use terminfo database.
X *	Otherwise, termcap is used
X */
X
X#define	USE_TERMINFO			/* */
X
X/*
X *	Specify the library containing the termcap/terminfo access routines.
X *	Notice:  nn does not use curses.
X *	Notice:  You must also specify whether termcap or terminfo is
X *		 used when you edit config.h (see below).
X */
X
X#define	TERMLIB -lcurses
X
X/*
X *	Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X
X#define HAVE_STRCHR			/* */
X
X/*
X *	Define if a signal handler has type void (see signal.h)
X */
X
X#define	SIGNAL_HANDLERS_ARE_VOID	/* */
X
X/*
X *	Define if signals must be set again after they are caught
X */
X
X#define	RESET_SIGNAL_WHEN_CAUGHT	/* */
X
X/*
X *	Define MICRO_ALARM to timeout in 0.1 seconds if possible
X */
X
X#define MICRO_ALARM()	alarm(1)	/* System V */
X
X/*
X *	Define if your system has BSD like job control (SIGTSTP works)
X */
X
X/* #define HAVE_JOBCONTROL			/* */
X
X/*
X *	Define if your system provides the "directory(3X)" access routines
X *
X *	If true, include the header file(s) required by the package below
X *	(remember that <sys/types.h> or equivalent is included above)
X *	Also typedef Direntry to the proper struct type.
X */
X
X#ifdef NO_DIRENT_H
X#undef NO_DIRENT_H
X#else
X
X#define	HAVE_DIRECTORY			/* */
X
X#include <dirent.h>			/* System V */
Xtypedef struct dirent Direntry;		/* System V */
X
X#endif
X
X/*
X *	Define if your system has a mkdir() library routine
X */
X
X#define	HAVE_MKDIR			/* */
X
X/*
X *	Define HAVE_GETHOSTNAME if your system provides a BSD like
X *	gethostname routine.
X *	Otherwise, define HAVE_UNAME if uname() is avaiable.
X *	As a final resort, define HOSTNAME to the name of your system.
X */
X
X#define	HAVE_UNAME			/* System V */
X
X/*
X *	Define DETATCH_TERMINAL to be a command sequence which
X *	will detatch a process from the control terminal
X *	Also include files needed to perform this HERE.
X *	If not possible, just define it (empty)
X */
X
X#define	DETATCH_TERMINAL setpgrp();	/* System V */
X
X/*
X *	Specify where the Bourne Shell is.
X */
X
X#define SHELL		"/bin/sh"
X
X/*
X *	Specify the default mailer to be invoked by nnmail
X */
X
X#define	MAILX		"/usr/bin/mailx"	/* SV */
X
X/*
X *	Define the maximum length of any pathname that may occur
X */
X
X#define	FILENAME 	256
END_OF_FILE
  if test 2736 -ne `wc -c <'conf/s-sys5.h'`; then
    echo shar: \"'conf/s-sys5.h'\" unpacked with wrong size!
  fi
  # end of 'conf/s-sys5.h'
fi
if test -f 'contrib/aspell' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'contrib/aspell'\"
else
  echo shar: Extracting \"'contrib/aspell'\" \(2723 characters\)
  sed "s/^X//" >'contrib/aspell' <<'END_OF_FILE'
XFrom: davison@drivax.uucp (Wayne Davison)
XDate: Thu, 19 Apr 90 13:47:07 PST
XTo: storm@texas.dk
XSubject: Our spelling checker installation
X
X *  An advanced front-end to ispell written in perl!
X *  Your shell/kernel must handle the #! control.
X *  Also look over the script if your ispell and perl is not in
X *  /usr/local/bin.
X *
X *  To use this code, you will need to put it somewhere suitable and
X *  set the variable 'spell-checker' to the full path of this program,
X *  e.g.
X *	set spell-checker /usr/local/bin/aspell
X *
X *  ++Kim
X
X
XI also created a perl script to disect the article before sending it to the
Xspelling checker -- it separates the header and the signature from the body,
XPLUS it includes the Subject, Keywords, and Summmary lines in the article to
Xbe checked.  After the checking is complete, it removes the .bak file, and
Xreconstructs the article using the various pieces.
X
XThe source for aspell follow.
X
X \  /| / /|\/ /| /(_)		<--flip monitor over for neato effect!
X(_)/ |/ /\|/ / |/  \
X   (W    A Y   N   e)
X
X----8<------8<------8<------8<-----cut here----->8------>8------>8------>8----
X#! /usr/local/bin/perl
Xif ($#ARGV != $[) {
X	print "Usage: aspell filename\n";
X	exit 1;
X}
X$FILE = shift;				# get filename of file to check
X$BODY = "/tmp/aspell$$";
Xopen(FILE,$FILE);			# open file for input
Xopen(BODY,">$BODY");			# open output file that we'll check
Xwhile (<FILE>) {				# read a line
X	last unless /^([ \t]|[^ \t]*:)(.*)/;	# quit at end of header
X	$header[$#header+1] = $_;		# save header in array
X	sw1: {				# write certain headers to output file
X		/^Subject:(.*)/  && do {print BODY; last sw1;};
X		/^Keywords:(.*)/ && do {print BODY; last sw1;};
X		/^Summary:(.*)/  && do {print BODY; last sw1;};
X	}
X}
Xprint BODY;				# write blank line to output file
Xwhile (<FILE>) {			# keep reading if not @ EOF
X	last if /^-- $/;		# quit if we find the signature
X	print BODY;			# write line to output file
X}
Xdo {
X	$sig[$#sig+1] = $_;		# save signature in array (if there)
X} while (<FILE>);			# until EOF
Xclose(BODY);
Xclose(FILE);
X
Xsystem "/usr/local/bin/ispell", "$BODY";	# run ispell
Xunlink "${BODY}.bak";				# rm .bak file
X
Xopen(FILE,">$FILE");			# open original file for output
Xopen(BODY,$BODY);			# open body of article for input
Xfor ($i = 0; $i <= $#header; $i++) {
X	$_ = $header[$i];		# grab a header line
X	sw2: {				# substitute spelling-checked versions
X		/^Subject:(.*)/  && ($_ = <BODY>, last sw2);
X		/^Keywords:(.*)/ && ($_ = <BODY>, last sw2);
X		/^Summary:(.*)/  && ($_ = <BODY>, last sw2);
X	}
X	print FILE;			# re-write header
X}
Xwhile(<BODY>) {
X	print FILE;			# re-write body
X}
Xfor ($i = 0; $i <= $#sig; $i++) {
X	print FILE $sig[$i];		# re-write signature (if present)
X}
Xunlink "$BODY";				# clean up
END_OF_FILE
  if test 2723 -ne `wc -c <'contrib/aspell'`; then
    echo shar: \"'contrib/aspell'\" unpacked with wrong size!
  fi
  # end of 'contrib/aspell'
fi
if test -f 'db.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'db.h'\"
else
  echo shar: Extracting \"'db.h'\" \(2870 characters\)
  sed "s/^X//" >'db.h' <<'END_OF_FILE'
X/*
X *	(c) Copyright 1990, Kim Fabricius Storm.  All rights reserved.
X *
X *	DATABASE ORGANIZATION:
X *
X *	The central nn information is contained in following files:
X *		DB_DIRECTORY/MASTER
X *		DB_DIRECTORY/GROUPS
X *		DB_DIRECTORY/DATA/nnn.x
X *		DB_DIRECTORY/DATA/nnn.d
X *
X * 	The MASTER file consists of a header and one entry for each news
X *	group.  The sequence of the group headers defines the group
X *	number associated with the group.
X *
X * 	The GROUPS file contains the names of the news groups; the names
X *	occur in the same sequence as in the MASTER file.
X *
X *	For each news group, the DATA directory contains two files whose
X *	name is constructed from the group number 'nnn':
X *
X *		nnn.x	Index file
X *		nnn.d	Data file
X *
X *	The index file provides a a mapping from article numbers to offsets
X *	in the data file.
X *
X *	The data file contains the actual header data.  Each article is
X *	represented by a Header, an array of Cross Postings, and the
X *	strings representing the sender name and the article subject:
X *
X *		header
X *		group_number 1 [ if cross posted ]
X *		group_number 2
X *		...
X *		sender name (null terminated) [if sender_length > 0]
X *		subject (null terminated) [if subject_length > 0]
X *
X *	For a digest, cross posted groups are only specified for the
X *	first entry (the header entry).
X *
X *	On disk, the article_number is negative for digest article
X *	header and zero for following sub articles.
X *
X *	The format of the index and data files are specified below.
X *
X *	Unless NETWORK_DATABASE is defined, the database will
X *	will contain machine dependent binary data.
X */
X
X#ifdef NETWORK_DATABASE
Xtypedef int32 cross_post_number;
X#ifdef NETWORK_BYTE_ORDER
X#define NETW_CROSS_INT(cp) cp
X#define NETW_CROSS_EXT(cp) cp
X#else
X#define NETW_CROSS_INT(cp) ntohl(cp)
X#define NETW_CROSS_EXT(cp) htonl(cp)
X#endif
X#else
Xtypedef group_number cross_post_number;
X#define NETW_CROSS_INT(cp) cp
X#define NETW_CROSS_EXT(cp) cp
X#endif
X
Xtypedef struct {
X    article_number	dh_number;
X
X    time_stamp	dh_date; /* encoded Date: filed (not a time_t value!!) */
X
X    off_t	dh_hpos; /* absolute offset for first byte of header */
X    off_t	dh_lpos; /* absolute offset for last byte of article */
X    int16	dh_fpos; /* relative offset for first byte in article text */
X
X    int16	dh_lines;
X    int8	dh_replies;
X
X    int8	dh_cross_postings;
X    int8	dh_subject_length;
X    int8	dh_sender_length;
X} data_header;
X
X#define DBUF_SIZE	255
X
Xtypedef struct {
X    int			dh_type;
X
X#define	DH_NORMAL		0
X#define	DH_DIGEST_HEADER	1
X#define DH_SUB_DIGEST		2
X
X    cross_post_number	dh_cross[DBUF_SIZE+1];
X    char		dh_sender[DBUF_SIZE+1];
X    char		dh_subject[DBUF_SIZE+1];
X} data_dynamic_data;
X
X
X/* open database files */
X
XFILE *open_data_file();
X
X/* data access */
X
Xoff_t get_index_offset(), get_data_offset();
X
Xextern data_header db_hdr;
Xextern data_dynamic_data db_data;
END_OF_FILE
  if test 2870 -ne `wc -c <'db.h'`; then
    echo shar: \"'db.h'\" unpacked with wrong size!
  fi
  # end of 'db.h'
fi
if test -f 'doc/RELEASE_NOTES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/RELEASE_NOTES'\"
else
  echo shar: Extracting \"'doc/RELEASE_NOTES'\" \(2841 characters\)
  sed "s/^X//" >'doc/RELEASE_NOTES' <<'END_OF_FILE'
XRelease 6.4.0 known problems
X----------------------------
X
XProg:	nn
XTitle:	G= in merged groups
X
X	When searching for a subject or author in a merged group using
X	G = .... only the group of the most recently accessed article
X	is searched.
X
XProg:	nnmaster
XTitle:	initial collection of news should use get_article_list
X
X	Explicitly requesting all articles in the range min..last is
X	wasteful.  A better method would be to use the get_article_list
X	method used by expire method 1.
X
XProg:	stdio
XTitle:	handling of network errors
X
X		stdio is not well suited to handle network problems, and it is
X	known to be slow as well.  A replacement is needed.
X	
XProg:	aux.sh
XTitle:	RECMAIL must work
X
X	If the RECMAIL fails for some reason, the user is told so via
X	mail - using RECMAIL.  It is checked during installation that
X	the RECMAIL program exists, but not that it works.
X
XProg:	nnmaster
XTitle:	Changes to GROUPS file should be detected automatically
X
X	It shouldn't be necessary to stop the master, run nnmaster -G,
X	and restart the master if GROUPS is changed.
X
XProg:	nn
XTitle:	.newsrc and select line length limited to 8k
X
X	There shouldn't be any limit on the length of lines in these
X	files.
X
XProg:	nn
XTitle:	Cannot reload init file
X
X	It should be possible to reload the init file or other files
X	to have variable settings and presentation sequence on the
X	fly.
X	
XProg:	nn
XTitle:	macro syntax and init file differs
X
X	The syntax of macros shouldn't differ from the normal init
X	file syntax.
X
XProg:	nn
XTitle:	The confirm-entry function is done after menu collection
X
X	It should be done before spending time on collecting the menu.
X
XProg:	database
XTitle:	keywords and summary are not stored in the database
X
X	Kill/select is not possible on keywords or summary, since they
X	are not in the database.  The summary could also be used on
X	the menu to annontate articles with identical subjects.
X
XProg:	nn
XTitle:	Cannot follow thread in References: line
X
X	This is one of the major new facilities planned for 7.0.
X	
XProg:	nn
XTitle:	Cannot go to "previous article" if it was in another group.
X
X	A "history menu" is planned for rel. 7.0 to overcome this.
X
X
XProg:	nn - menu
XTitle:	The , and / keys should scroll the menu rather than wrap around
X
X	It would be more logical that way.
X
XProg:	nn - options
XTitle:	The -s and -n options cannot be combined.
X	
X	It could be useful to search for a specific subject from
X	a specific sender.
X	
XProg:	nn - mail-format
XTitle:	The "From " line could be more informative in mail-folders.
X
X	It should contain the poster's name rather than the group's
X	name.
X
XProg:	nn
XTitle:	Should look for more news before exiting.
X
X	News which has arrived in already read groups during news
X	reading is not seen until the next invocation of nn.
X
XProg:	nn
XTitle:	Shell layers are not supported.
X
X	^Z is eaten by nn so shell layers don't work.
END_OF_FILE
  if test 2841 -ne `wc -c <'doc/RELEASE_NOTES'`; then
    echo shar: \"'doc/RELEASE_NOTES'\" unpacked with wrong size!
  fi
  # end of 'doc/RELEASE_NOTES'
fi
if test -f 'fullname.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fullname.c'\"
else
  echo shar: Extracting \"'fullname.c'\" \(2613 characters\)
  sed "s/^X//" >'fullname.c' <<'END_OF_FILE'
X/*
X * This file is derived from Bnews' fullname.c file.
X * Bnews is Copyright (c) 1986 by Rick Adams.
X *
X * NOTICE: THIS CODE HAS BEEN MODIFIED TO FIT THE NN ENVIRONMENT:
X *
X *	The full_name function has been rewritten entirely, although
X *	there are still some structural resemblence.
X *	Fullname checks $NAME before looking at /etc/passwd.
X *	The LOCALNAME alternative has been removed, because it would fit
X *	nn very poorly.
X *	The buildfname function is made static and moved before full_name.
X *
X * fullname.c - this file is made separate so that different local
X * conventions can be applied.  The stock version understands two
X * conventions:
X *
X * (a) Berkeley finger: the gecos field in /etc/passwd begins with
X *     the full name, terminated with comma, semicolon, or end of
X *     field.  & expands to the login name.
X * (b) BTL RJE: the gecos field looks like
X *	: junk - full name ( junk :
X *     where the "junk -" is optional.
X *
X * If you have a different local convention, modify this file accordingly.
X */
X
X#ifdef SCCSID
Xstatic char	*SccsId = "@(#)fullname.c	1.13	11/4/87";
X#endif /* SCCSID */
X
X#include "config.h"
X#include <pwd.h>
X
X/*
X**  BUILDFNAME -- build full name from gecos style entry.
X**	(routine lifted from sendmail)
X**
X**	This routine interprets the strange entry that would appear
X**	in the GECOS field of the password file.
X**
X**	Parameters:
X**		p -- name to build.
X**		login -- the login name of this user (for &).
X**		buf -- place to put the result.
X**
X**	Returns:
X**		none.
X**
X**	Side Effects:
X**		none.
X*/
X
Xstatic buildfname(p, login, buf)
X	register char *p;
X	char *login;
X	char *buf;
X{
X	register char *bp = buf;
X
X	if (*p == '*')
X		p++;
X	while (*p != '\0' && *p != ',' && *p != ';' && *p != ':' && *p != '(')
X	{
X		if (*p == '-' && (isdigit(p[-1]) || isspace(p[-1]))) {
X			bp = buf;
X			p++;
X		}
X		else if (*p == '&')
X		{
X			strcpy(bp, login);
X			if ((bp == buf || !isalpha(bp[-1])) && islower(*bp))
X				*bp = toupper(*bp);
X			while (*bp != '\0')
X				bp++;
X			p++;
X		}
X		else
X			*bp++ = *p++;
X	}
X	*bp = '\0';
X}
X
X/*
X * Figure out who is sending the message and sign it.
X * We attempt to look up the user in the gecos field of /etc/passwd.
X */
Xchar *full_name()
X{
X    static char *fullname = NULL;
X    char inbuf[FILENAME];
X    struct passwd *pw, *getpwuid();
X
X    if (fullname == NULL) {
X	if ((fullname = getenv("NAME")) != NULL)
X	    return fullname;
X
X	pw = getpwuid((int)user_id);
X	if (pw == NULL) return fullname = "?";
X
X	buildfname(pw->pw_gecos, pw->pw_name, inbuf);
X	if (inbuf[0] == 0) strcpy(inbuf, pw->pw_name);
X
X	fullname = copy_str(inbuf);
X    }
X    return fullname;
X}
END_OF_FILE
  if test 2613 -ne `wc -c <'fullname.c'`; then
    echo shar: \"'fullname.c'\" unpacked with wrong size!
  fi
  # end of 'fullname.c'
fi
if test -f 'help/help.commands' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/help.commands'\"
else
  echo shar: Extracting \"'help/help.commands'\" \(2870 characters\)
  sed "s/^X//" >'help/help.commands' <<'END_OF_FILE'
X;:ACOMMAND NAMES;:A						;:AMAP COMMAND;:A
X
X;:BNAME		MENU	MORE	FUNCTION
Xadvance-article		A	advance to next article from menu
Xadvance-group	A 		advance one group in sequence
Xarticle N		a-z	select article N (0..no of menu lines-1)
Xback-article		B	go back one article from menu
Xback-group	B 		go back one group in sequence
Xcancel		C	C	cancel an article
Xcommand		:	:	extenced command prefix
Xcompress		c	compress text (eliminate extra spaces)
Xcontinue	SPACE	SPACE	the "space bar" command
Xcontinue-no-mark CR	CR	as the "space bar" command, but don't mark
Xdecode		:decode	:decode	decode uuencoded article(s)
Xfind			/	regular expression search
Xfind-next		.	repeat regular expression search
Xfollow		F 	f F	follow up
Xfull-digest		H	show complete digest
Xgoto-group	G	G	goto group or open folder
Xgoto-menu		=	go back to menu
Xhelp		?	?	online help
Xjunk-articles	J		change marking of articles on the menu
Xkill-select	K	K	kill/select handling
Xlayout		L		change menu layout
Xleave-article	l	l	leave (mark) article for later use
Xline+1		down	CR	next menu line/scroll one line
Xline-1		up		previous menu line
Xline=@			g	goto specific line
Xmacro N				invoke macro number N (0..100)
Xmail		M	m M	mail or forward
Xmessage		^P	^P	repeat last prompt line message
Xnext-article		n	skip to next article
Xnext-group	N		goto to next group without reading current
Xnext-subject		k	skip to next article with different subject
Xnil				unbound key
Xoverview	Y	Y	show groups with unread news
Xpage+1		>		goto next page if any
Xpage+1/2		d ^D	scroll half page forward
Xpage-1		<	DEL	goto one page back
Xpage-1/2		u ^U	scroll half page backwards
Xpage=$		$	$	goto end of menu/article
Xpage=0			h	goto header of article
Xpage=1		^	^	goto first menu/article page
Xpage=@				goto specific page of article (not implemented)
Xpatch		:patch	:patch	pipe article through patch program
Xpost		:post	:post	post new article
Xpreview		%		preview article
Xprevious	P	p	goto previous group/article
Xprint		:print	P	print article
Xquit		Q	Q	quit nn
Xread-return	Z		read selected articles and return to menu
Xread-skip	X		read selected article, skip unseen menu pages
Xredraw		^L ^R	^L ^R	redraw screen
Xreply		R	r R	reply
Xrot13			D	decrypt rot13 article
Xsave-body	W	w W	save article without header
Xsave-full	S	s S	save article with full header
Xsave-short	O	o O	save article with short header
Xselect          .		select (or deselect) current menu entry
Xselect-auto     +		select "auto-selected" articles
Xselect-invert 	@		invert all selections on current menu page
Xselect-range    -		select range of articles
Xselect-subject	*		select all articles with current subject
Xshell         	!	!	shell command prefix
Xskip-lines		TAB	skip lines starting with same char as last line
Xunselect-all  	~		unselect all articles
Xunshar				unshar article(s)
Xunsub         	U	U	unsubscribe (or subscribe) to current group
Xversion       	V	V	print release information
END_OF_FILE
  if test 2870 -ne `wc -c <'help/help.commands'`; then
    echo shar: \"'help/help.commands'\" unpacked with wrong size!
  fi
  # end of 'help/help.commands'
fi
if test -f 'hostname.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hostname.c'\"
else
  echo shar: Extracting \"'hostname.c'\" \(2359 characters\)
  sed "s/^X//" >'hostname.c' <<'END_OF_FILE'
X/*
X *	(c) Copyright 1990, Kim Fabricius Storm.  All rights reserved.
X *
X *	"generic" gethostname() emulation:
X * 
X *	Possibilities are used in following order:
X *
X *	HAVE_GETHOSTNAME		-- use gethostname()
X *	HAVE_UNAME			-- use sysV uname().nodename
X *	HOSTNAME_FILE "/.../..."	-- read hostname from file
X *	HOSTNAME_WHOAMI			-- use sysname from whoami.h
X *	HOSTNAME "host"			-- hard-coded hostname
X *	You lose!
X */
X
X#include "config.h"
X
X#undef DONE
X
X#ifdef HAVE_GETHOSTNAME
X/*
X *	Easy -- we already got it
X */
X#define DONE
X#endif
X
X#ifndef DONE
X#ifdef HAVE_UNAME
X/*
X *	System V uname() is available.	Use nodename field.
X */
X
X#include <sys/utsname.h>
X
Xgethostname(name, length)
Xchar *name;
Xint length;
X{
X    struct utsname un;
X
X    uname(&un);
X    strncpy(name, un.nodename, length);
X}
X#define DONE
X#endif
X#endif
X
X#ifndef DONE
X#ifdef HOSTNAME_FILE
X/*
X *	Hostname is available in a file.
X *	The name of the file is defined in HOSTNAME_FILE.
X *	This is not intended to fail (or exit would have been via nn_exit)
X */
X
Xgethostname(name, length)
Xchar *name;
Xint length;
X{
X    FILE *f;
X    register char *p;
X    
X    f = fopen(HOSTNAME_FILE, "r"); /* Generic code -- don't use open_file */
X    if (f == NULL) goto err;
X    if (fgets(name, length, f) == NULL) goto err;
X    if ((p = strchr(name, NL)) != NULL) *p = NUL;
X    fclose(f);
X    return;
X    
Xerr:    
X    fprintf(stderr, "HOSTNAME NOT FOUND IN %s\n", HOSTNAME_FILE);
X    exit(77);
X}
X#define DONE
X#endif
X#endif
X
X#ifndef DONE
X#ifdef HOSTNAME_WHOAMI
X/*
X *	Hostname is found in whoami.h
X */
X
Xgethostname(name, length)
Xchar *name;
Xint length;
X{
X    FILE *f;
X    char buf[512];
X    register char *p, *q;
X    
X    f = fopen("/usr/include/whoami.h", "r");
X    if (f == NULL) goto err;
X    
X    while (fgets(buf, 512, f) != NULL) {
X	if (buf[0] != '#') continue;
X	if ((p = strchr(buf, '"')) == NULL) continue;
X	*p++ = NUL;
X	if (strncmp(buf, "#define sysname", 15)) continue;
X	if ((q = strchr(p, '"')) == NULL) break;
X	*q = NUL;
X	strncpy(name, p, length);
X	return;
X    }
X    
X err:
X    fprintf(stderr, "HOSTNAME (sysname) NOT DEFINED IN whoami.h\n");
X    exit(77);
X}
X#define DONE
X#endif
X#endif
X
X#ifndef DONE
X#ifdef HOSTNAME
Xgethostname(name, length)
Xchar *name;
Xint length;
X{
X    strncpy(name, HOSTNAME, length);
X}
X#define DONE
X#endif
X#endif
X
X#ifndef DONE
XYOU LOSE ON GETHOSTNAME -- DEFINE HOSTNAME IN CONFIG.H
X#endif
END_OF_FILE
  if test 2359 -ne `wc -c <'hostname.c'`; then
    echo shar: \"'hostname.c'\" unpacked with wrong size!
  fi
  # end of 'hostname.c'
fi
if test -f 'inews/conf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'inews/conf.h'\"
else
  echo shar: Extracting \"'inews/conf.h'\" \(2825 characters\)
  sed "s/^X//" >'inews/conf.h' <<'END_OF_FILE'
X/*
X * Configuration file for nn version of nntp inews.  Written by
X * Steve Simmons (scs@lokkur.dexter.mi.us), Dec 19, 1989.  Placed
X * in the public domain by the author.  This file rationalizes
X * the stock NNTP release of inews with the definitions for NN.
X * The rationalization was done as of NN version 6.3.10 and NNTP
X * version 1.5.7.
X *
X * You must edit this file to reflect your local configuration
X * and environment.
X *
X * Follow the instructions given in the comments.  See the file
X * README for more comments.
X *
X * $RCSfile: conf.h,v $	$Revision: 1.1 $
X *
X * $Author: news $	$Date: 89/12/20 17:43:03 $
X *
X * $State: Exp $	$Locker:  $
X *
X * $Log:	conf.h,v $
X * Revision 1.1  89/12/20  17:43:03  news
X * Initial revision
X *
X * May 1st, 1990, Kim Storm
X * Modifications to get hostname for free (see README.NN)
X */
X
X#ifndef	NNINEWSCONF_H
X#define	NNINEWSCONF_H
X
X#include	"config.h"
X
X#ifndef NNTP
X/* WHY DO YOU WANT TO MAKE MINI-INEWS WHEN YOU DONT USE NNTP */
X#endif
X
X/*
X *  Define your local domain name.  You *must* define something here.
X *
X *  You are not strictly *required* to have a domain name; nonetheless
X *  it's a good idea.  If you are on the Internet or otherwise have a
X *  valid domain name, use it (except see HIDDENNET below).  If you're
X *  a uucp-only site, use ".uucp" for now and go get a real name.
X *
X *  Note that if you imbed your domain name in the hostname and you don't
X *  use HIDDENNET, you should comment out the definition.
X */
X
X#define	DOMAIN	"iti.org"
X
X/*
X *  If you define this, the hostname will not appear in the posting
X *  data except on the path.  Items will be from user@DOMAIN (with
X *  DOMAIN as defined above).  If you don't want this, comment it out.
X */
X
X#define	HIDDENNET
X
X/*
X *  There are a number of ways that inews will try to figure out the
X *  host name.  When used with nn, the definitions in ../config.h
X *  will specify this, so you don't have to do anything special here.
X */
X
X/*
X *  If you don't have bcopy, the following define will make one...
X */
X
X/* #define USG			/* */
X
X/*
X *  You shouldn't need to touch anything below this line.
X */
X
X/*
X *  This is the code needed to get the proper hostname.
X *
X *	nn provides a gethostname function for generic use.
X *	we fake uname() for inews.c using this:
X */
X
X#define	uname(str) gethostname(str, sizeof(str))
X
X/*
X *  Stock nntp inews and nn use some different #define names for the
X *  same general functions.  This synchronises them.
X */
X
X#define	SERVER_FILE	NNTP_SERVER
X
X/*
X *	Reverse engineering (nn got this the other way around)....
X */
X
X#ifdef HAVE_STRCHR
X#define	rindex strrchr
X#define index strchr
X#endif
X
X/*
X *  Sanity checks (You know.  Checks you get from Sanity Claus)
X */
X
X#ifdef	HIDDENNET
X#ifndef	DOMAIN
XYOU_BLEW_IT READ_THE_INSTRUCTIONS_AGAIN
X#endif
X#endif
X
X#endif	/* of ifdef NNINEWSCONF_H */
END_OF_FILE
  if test 2825 -ne `wc -c <'inews/conf.h'`; then
    echo shar: \"'inews/conf.h'\" unpacked with wrong size!
  fi
  # end of 'inews/conf.h'
fi
if test -f 'inews/nntp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'inews/nntp.h'\"
else
  echo shar: Extracting \"'inews/nntp.h'\" \(2530 characters\)
  sed "s/^X//" >'inews/nntp.h' <<'END_OF_FILE'
X/*
X * Response codes for NNTP server
X *
X * @(#)nntp.h	1.7	(Berkeley) 1/11/88
X *
X * First digit:
X *
X *	1xx	Informative message
X *	2xx	Command ok
X *	3xx	Command ok so far, continue
X *	4xx	Command was correct, but couldn't be performed
X *		for some specified reason.
X *	5xx	Command unimplemented, incorrect, or a
X *		program error has occured.
X *
X * Second digit:
X *
X *	x0x	Connection, setup, miscellaneous
X *	x1x	Newsgroup selection
X *	x2x	Article selection
X *	x3x	Distribution
X *	x4x	Posting
X */
X
X#define	CHAR_INF	'1'
X#define	CHAR_OK		'2'
X#define	CHAR_CONT	'3'
X#define	CHAR_ERR	'4'
X#define	CHAR_FATAL	'5'
X
X#define	INF_HELP	100	/* Help text on way */
X#define	INF_DEBUG	199	/* Debug output */
X
X#define	OK_CANPOST	200	/* Hello; you can post */
X#define	OK_NOPOST	201	/* Hello; you can't post */
X#define	OK_SLAVE	202	/* Slave status noted */
X#define	OK_GOODBYE	205	/* Closing connection */
X#define	OK_GROUP	211	/* Group selected */
X#define	OK_GROUPS	215	/* Newsgroups follow */
X#define	OK_ARTICLE	220	/* Article (head & body) follows */
X#define	OK_HEAD		221	/* Head follows */
X#define	OK_BODY		222	/* Body follows */
X#define	OK_NOTEXT	223	/* No text sent -- stat, next, last */
X#define	OK_NEWNEWS	230	/* New articles by message-id follow */
X#define	OK_NEWGROUPS	231	/* New newsgroups follow */
X#define	OK_XFERED	235	/* Article transferred successfully */
X#define	OK_POSTED	240	/* Article posted successfully */
X
X#define CONT_XFER	335	/* Continue to send article */
X#define	CONT_POST	340	/* Continue to post article */
X
X#define	ERR_GOODBYE	400	/* Have to hang up for some reason */
X#define	ERR_NOGROUP	411	/* No such newsgroup */
X#define	ERR_NCING	412	/* Not currently in newsgroup */
X#define	ERR_NOCRNT	420	/* No current article selected */
X#define	ERR_NONEXT	421	/* No next article in this group */
X#define	ERR_NOPREV	422	/* No previous article in this group */
X#define	ERR_NOARTIG	423	/* No such article in this group */
X#define ERR_NOART	430	/* No such article at all */
X#define ERR_GOTIT	435	/* Already got that article, don't send */
X#define ERR_XFERFAIL	436	/* Transfer failed */
X#define	ERR_XFERRJCT	437	/* Article rejected, don't resend */
X#define	ERR_NOPOST	440	/* Posting not allowed */
X#define	ERR_POSTFAIL	441	/* Posting failed */
X
X#define	ERR_COMMAND	500	/* Command not recognized */
X#define	ERR_CMDSYN	501	/* Command syntax error */
X#define	ERR_ACCESS	502	/* Access to server denied */
X#define ERR_FAULT	503	/* Program fault, command not performed */
X
X/* RFC 977 defines this; don't change it. */
X
X#define	NNTP_STRLEN	512
END_OF_FILE
  if test 2530 -ne `wc -c <'inews/nntp.h'`; then
    echo shar: \"'inews/nntp.h'\" unpacked with wrong size!
  fi
  # end of 'inews/nntp.h'
fi
if test -f 'init.sample' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'init.sample'\"
else
  echo shar: Extracting \"'init.sample'\" \(2435 characters\)
  sed "s/^X//" >'init.sample' <<'END_OF_FILE'
X######################### GLOBAL INIT FILE ##################
X#
X#	Examine this sample init file before installing it
X#	It may set variables or define a presentation sequence
X#	which is inadequate for you.
X
X
X############################ VARIABLES ##########################
X#
X#	These are some of the variables you may want to set-up globally.
X#	Check with the manual to see if you really need them!
X
X# set bug-report-address uunet!dkuug.dk!nn-bugs
Xset default-distribution local
Xset default-save-file +$G
Xset header-lines _FODn=S
Xset include-art-id
Xset mail-format
Xset mark-overlap
Xset save-counter .%02d
X
X# set this if you use NFS (and specify -y2 on nnmaster as well):
X# set retry-on-error 2
X
X################# DEFAULT PRESENTATION SEQUENCE ####################
X#
X#	Adapt this to your local preferences.
X#	Users can override this sequence in their own init file.
X#
X#	**** THIS IS JUST AN EXAMPLE TO SHOW THE POSSIBILITIES	****
X#	**** IT IS DEFINITELY NOT WHAT YOU WANT TO HAVE HERE	****
X#	**** IF YOU DON'T KNOW WHAT TO PUT HERE, YOU ARE BETTER	****
X#	**** OFF JUST DELETING THE REST OF THIS FILE !!!!!	****
X
Xsequence
X
X	# groups everybody should read first (local groups)
X< texas*
X< general
X
X	# If you include the following !! line, users without their own
X	# init file will only get the local groups specified above!
X	#
X	# Other users will have to include a @ in their private presentation
X	# sequence to disable the '!!' operator entirely, or they can
X	# include the (few) groups they want to see.
X# !!
X
X	# also put local test first -- if users want to experiment, they want
X	# to see the results immediately.
X< test
X
X	# ignore some groups for ordinary users; anybody can get these
X	# by including them in their own init file.
X
X	# ignore non-local test groups
X! .test
X	# ignore offensive groups
X! alt.sex*
X! .bizarre
X! rec.humor
X
X	# the default sequence for the other groups
X	# subgroups are presented in alphabetical order
X
X	# danish/scandinavian groups
Xdk.
Xnordunet.
X
X
X	# european groups
X	# read eunet.general before eunet.followup and other eunet groups
Xeunet.general
Xeunet.followup
Xeunet.
X
X	# new groups are presented here
X	# use ! NEW to ignore new groups entirely!
XNEW
X
X	# world groups - prefer technical groups to other groups.
Xnews.
Xcomp.
Xsci.
Xgnu.
Xbionet.
Xalt.
Xrec.
Xmisc.
Xtalk.
X
X	# delay junk (we then only see non-cross postings.)
X> junk
X
X# groups that are not mentioned above will be shown here in alphabetical
X# order
X
X
END_OF_FILE
  if test 2435 -ne `wc -c <'init.sample'`; then
    echo shar: \"'init.sample'\" unpacked with wrong size!
  fi
  # end of 'init.sample'
fi
if test -f 'man/nncheck.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/nncheck.1'\"
else
  echo shar: Extracting \"'man/nncheck.1'\" \(2757 characters\)
  sed "s/^X//" >'man/nncheck.1' <<'END_OF_FILE'
X.TH NNCHECK 1 "Release 6.4"
X.\" (c) Copyright 1988, 1990, Kim F. Storm.  All rights reserved.
X.UC 4
X.SH NAME
Xnncheck \- check for unread articles
X.SH SYNOPSIS
X.B nncheck
X[ -Q -r -t ]  [ -f format ]
X.SH DESCRIPTION
X.I nncheck
Xwill report if there are some articles on the system which you have not read.
X.LP
XWithout options, \fInncheck\fP will simply print a message reporting
Xthe number of unread articles with the following format:
X.br
X	There are 327 unread articles in 25 groups
X.br
Xand when there are no unread articles, the following message will be
Xprinted:
X.br
X	No News (is good news)
X.LP
X\fInncheck\fP will exit with a value of 0 if there are unread
Xarticles, and 99 if there is no news (see the exception for the \-r
Xoption.)
X.LP
XIt is important to notice that even though unread articles have been
Xreported by \fInncheck\fP, the actual number of unread articles may be
Xmuch lower (or even zero) when \fInn\fP is invoked to read
Xthe articles.  This is because the calculation of the number of unread
Xarticles is only based on recorded article number intervals.  Invoking
X\fInn\fP to read the articles may reveal that the articles have
Xpreviously been read in another news group, have been expired, or are
X.I killed
Xusing the
X.I auto-kill
Xfacility.
X.LP
XThe following options are used to modify the amount and format of the
Xoutput from \fInncheck\fP:
X.TP
X.B \-Q
XQuiet operation.  No output is produced, only the exit status indicate
Xwhether there is unread news.
X.TP
X.B \-t
XPrint the name of each group with unread articles, and how many unread
Xarticles there are (not counting split digests!).
X.TP
X.B \-r
XOutput a single integer value specifying the number of unread
Xarticles, and exit with a 0 status (somebody told me this would be
Xuseful).
X.TP
X\&\-\fBf\fP \fIformat\fP
XOutput the number of unread articles using the specified format.  The
Xformat is a text that may contain the following %-escapes:
X.sp 0.5v
X.DT
X.ta 1i 2i
X.\"ta 1 10 20
X.nf
X	\fB%-code\fP	\fBresulting output\fP
X.sp 0.5v
X	%u	"\fIuuu\fP unread articles"
X	%g	"\fIggg\fP groups"
X	%i	"is" if 1 unread article, else "are"
X	%U	"\fIuuu\fP"
X	%G	"\fIggg\fP"
X.fi
X.DT
X.sp 0.5v
Xwhere
X.I uuu
Xis the number of unread articles, and
X.I ggg
Xis the number of groups with unread articles.
X.sp 0.5v
XFor example, the default output format is
X.br
X	"There %i %u in %g"
X.br
Xwhich I prefer to the following less perfect format:
X.br
X	"There are %U unread article(s) in %G group(s)"
X.LP
X.SH FILES
X.DT
X.ta \w'$db/MASTER'u+6m
X.\"ta 0 12
X~/.nn/rc	The record of read articles
X.br
X$db/MASTER	The database master index
X.DT
X.SH SEE ALSO
Xnn(1), nngoback(1), nngrep(1), nntidy(1)
X.br
Xnnadmin(1M), nnquery(1M), nnusage(1M), nnmaster(1M)
X.SH AUTHOR
XKim F. Storm, Texas Instruments A/S, Denmark
X.br
XE-mail: storm@texas.dk
END_OF_FILE
  if test 2757 -ne `wc -c <'man/nncheck.1'`; then
    echo shar: \"'man/nncheck.1'\" unpacked with wrong size!
  fi
  # end of 'man/nncheck.1'
fi
if test -f 'man/nngrep.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/nngrep.1'\"
else
  echo shar: Extracting \"'man/nngrep.1'\" \(2688 characters\)
  sed "s/^X//" >'man/nngrep.1' <<'END_OF_FILE'
X.TH NNGREP 1 "Release 6.4"
X.\" (c) Copyright 1988, 1990, Kim F. Storm.  All rights reserved.
X.UC 4
X.SH NAME
Xnngrep \- grep for news group names (nn)
X.SH SYNOPSIS
X.B nngrep
X[ \-\fBainprsu\fP ]
X[ \-\fBl\fP ]
X[ \fIpattern\fP ]
X.SH DESCRIPTION
X\fInngrep\fP can print various selections of the available news
Xgroups.
X.LP
XWithout options, \fInngrep\fP will list all currently \fIsubscribed\fP
Xnewsgroups whose name matches any of the specified \fIpatterns\fP.  If
Xno pattern is specified, all subscribed groups will be listed.
X.LP
XThe selection of news groups against which the patterns are matches,
Xand subsequently printed by \fInngrep\fP can be limited or
Xexpanded using the following command line options and arguments:
X.TP
X\fB\-a\fP
XUse \fIboth\fP subscribed and unsubscribed groups.  Overrides the
X\fB\-u\fP option.
X.TP
X\fB\-i\fP
XUse only \fIignored\fP groups, i.e. which are \fInot\fP in the
Xpresentation sequence.
X.TP
X\fB\-n\fP
XUse only \fInew\fP groups.  Notice that \fInn\fP considers a group to
Xbe new until you have read at least one article in the group, or you
Xhave unsubscribed to the group.  This means that even reasonable
Xactive news groups may remain "new" for quite some time if it only
Xcontains articles which are cross-posted to other groups which occur
Xearlier in your presentation sequence.
X.TP
X\fB\-p\fP
XUse only groups with \fIunread\fP (pending) articles.
X.TP
X\fB\-r\fP
XUse only \fIread\fP groups, i.e. without unread articles.
X.TP
X\fB\-s\fP
XUse only groups which are in the presentation \fIsequence\fP.
X.TP
X\fB\-u\fP
XUse only \fIunsubscribed\fP groups.
X.LP
XThese options can be combined if they don't logically exclude each
Xother.
X.LP
XFor example, to get the names of all "source" groups, you can use the
Xcommand
X.br
X	nngrep source
X.LP
XYou can use this to read a specific subset of news groups with
X\fInn\fP; for example
X.br
X	nn `nngrep -sp source`
X.SH LONG LISTING
XA \fIlong\fP listing of the matched groups can be requested with the
X\fB\-l\fP option.  It will include the following information:
X.LP
X.DT
X.ta \w'SEQUENCE'u+3m
X.\"ta 0 12
XSUBSCR	Specifies whether the group is subscribed or not (yes/no).
X.br
XNEW	Specifies whether the group is new or not (yes/no).
X.br
XUNREAD	Shows the number of unread articles in the group (if any).
X.br
XSEQUENCE	Shows the group's index in the presentation sequence.
X.br
XGROUP	The name of the group.
X.br
X.DT
X.SH FILES
X.DT
X.ta \w'~/.nn/init'u+3m
X.\"ta 0 12
X~/.newsrc	The record of read articles
X.br
X~/.nn/init	The presentation sequence
X.DT
X.SH SEE ALSO
Xnn(1), nncheck(1), nngoback(1), nngrep(1)
X.br
Xnnadmin(1M), nnquery(1M), nnusage(1M), nnmaster(8)
X.SH AUTHOR
XKim F. Storm, Texas Instruments A/S, Denmark
X.br
XE-mail: storm@texas.dk
X
END_OF_FILE
  if test 2688 -ne `wc -c <'man/nngrep.1'`; then
    echo shar: \"'man/nngrep.1'\" unpacked with wrong size!
  fi
  # end of 'man/nngrep.1'
fi
if test -f 'match.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'match.c'\"
else
  echo shar: Extracting \"'match.c'\" \(2864 characters\)
  sed "s/^X//" >'match.c' <<'END_OF_FILE'
X/*
X *	(c) Copyright 1990, Kim Fabricius Storm.  All rights reserved.
X *
X *	String/Subject matching routines.
X */
X
X#include "config.h"
X#include "regexp.h"
X
Xexport int case_fold_search = 1;
X
X#define MAXFOLD	256	/* max length of any string */
X
X/*
X *	Systems which have a tolower(c) function which is defined for
X *	all characters, but no _tolower(c) macro which works for
X *	isupper(c) only, may define HAVE_GENERIC_TOLOWER -- it
X *	may give a slight speed-up, but is not mandatory.
X */
X
X#ifndef HAVE_GENERIC_TOLOWER
X#ifndef _tolower
X#define _tolower(c) tolower(c)
X#endif
X#endif
X
Xfold_string(mask)	/* convert mask to lower-case */
Xregister char *mask;
X{
X    register char c;
X
X    for ( ; c = *mask; mask++) {
X#ifdef _tolower
X	if (!isascii(c) || !isupper(c)) continue;
X	*mask = _tolower(c);
X#else
X	*mask = tolower(c);
X#endif
X    }
X}
X
Xstreq_fold(mask, str)		/* mask is prefix of str - FOLD */
Xregister char *mask, *str;
X{
X    register char c, d;
X
X    while (d = *mask++) {
X	if ((c = *str++) == NUL) return 0;
X	if (c == d) continue;
X#ifdef _tolower
X	if (!isascii(c) || !isupper(c) || _tolower(c) != d) return 0;
X#else
X	if (tolower(c) != d) return 0;
X#endif
X    }
X    return c == NUL ? 1 : 2;
X}
X
Xstrmatch_fold(mask, str)	/* mask occurs anywhere in str - FOLD */
Xchar *mask;
Xregister char *str;
X{
X    register char c, m1 = *mask++;
X
X    for (;;) {
X	while (c = *str++) {	/* find first occ. of mask[0] in str. */
X	    if (c == m1) break;
X#ifdef _tolower
X	    if (!isascii(c) || !isupper(c)) continue;
X	    if (_tolower(c) == m1) break;
X#else
X	    if (tolower(c) == m1) break;
X#endif
X	}
X	if (c == NUL) return 0;
X	if (streq_fold(mask, str)) return 1;
X    }
X}
X
Xstrmatch(mask, str)		/* mask occurs anywhere in str - CASE */
Xchar *mask;
Xregister char *str;
X{
X    register char *q, *m;
X    register char m1 = *mask;
X
X    for (; *str; str++) {
X	if (*str != m1) continue;
X
X	q = str; m = mask;
X	do
X	    if (*++m == NUL) return 1;
X	while (*++q == *m);
X    }
X    return 0;
X}
X
Xstrmatch_cf(mask, str)		/* fold if case_fold_search is set */
Xchar *mask;
Xchar *str;
X{
X    if (case_fold_search)
X	return strmatch_fold(mask, str);
X
X    return strmatch(mask, str);
X}
X
X/*
X *	case insensitive regexp matching
X */
X
Xint regexec_fold(prog, string)
Xregister regexp *prog;
Xchar  *string;
X{
X    char buf[256];
X    register char c, *bp, *str, *maxb;
X
X    bp = buf, maxb = &buf[255];
X    str = string;
X    while (bp < maxb && (c = *str++) != NUL)
X#ifdef _tolower
X	*bp++ = (!isascii(c) || !isupper(c)) ? c : _tolower(c);
X#else
X	*bp++ = tolower(c);
X#endif
X    *bp = NUL;
X
X    if (!regexec(prog, buf)) return 0;
X
X    prog->startp[0] = string + (prog->startp[0] - buf);
X    prog->endp[0] = string + (prog->endp[0] - buf);
X    return 1;
X}
X
Xint regexec_cf(prog, string)
Xregister regexp *prog;
Xchar  *string;
X{
X    if (case_fold_search)
X	return regexec_fold(prog, string);
X
X    return regexec(prog, string);
X}
X
END_OF_FILE
  if test 2864 -ne `wc -c <'match.c'`; then
    echo shar: \"'match.c'\" unpacked with wrong size!
  fi
  # end of 'match.c'
fi
if test -f 'nnstats.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nnstats.sh'\"
else
  echo shar: Extracting \"'nnstats.sh'\" \(3021 characters\)
  sed "s/^X//" >'nnstats.sh' <<'END_OF_FILE'
X# --- prefix is inserted above by make ---
X#
X# Extract collection & expiration statistics from Log file.
X#
X# From: Mark Moraes <moraes@csri.toronto.edu>
X#
X# Heavily modified by Kim F. Storm:
X#  Added expiration statistics
X#  Will now make daily statistics & grand summary
X#  Split into two awk scripts to fit in argument list space
X#  (and as a side-effect to be able to use functions in old awk!!!)
X
XCHECK="0>0"
XLONG=0
XSUMMARY=1
Xdebug=false
X
XLOOP=true
Xwhile $LOOP; do
X  case "$1" in
X  -l)	LONG=1
X	shift;;
X  -d)	CHECK="\$2!=\"$2\" || \$3!=\"$3\""
X	shift; shift; shift;;
X  -m)	CHECK="\$2!=\"$2\""
X	shift; shift;;
X  -t)   SUMMARY=0
X	shift;;
X  -D)	debug=true
X	shift;;
X  -*)   echo "unknown option: $1"
X	exit 1;;
X  *)	LOOP=false
X	;;
X  esac
Xdone
X
Xgrep '^[CX]:' `ls -tr ${@-$LOG}` |
X${AWK} 'BEGIN{
X  day="0"; l='$LONG'; t='$SUMMARY'
X  f=" %d %d %d %d %d %d %d\n"
X}
X'"$CHECK"' { next }
Xday!=$3{
X  if(day!="0")print "d " date
X  if(l && day!="0" && (run>0 || xrun>0)){
X    print "h"
X    printf "c" f,run,art,Mart,gr,Mgr,sec,Msec
X    printf "e" f,xrun,xart,xMart,xgr,xMgr,xsec,xMsec
X  }
X  day=$3
X  date=$2 " " $3
X  run=art=gr=sec=0
X  Mart=Mgr=Msec=0
X  xrun=xart=xgr=xsec=0
X  xMart=xMgr=xMsec=0
X}
X$6=="Collect:" {
X  if ($7 <= 0) next
X  run++; art+=$7; gr+=$9; sec+=$11
X  Trun++; Tart+=$7; Tgr+=$9; Tsec+=$11
X  if ($7 > Mart) Mart=$7;
X  if ($9 > Mgr) Mgr=$9;
X  if ($11 > Msec) Msec=$11;
X  if ($11 > 0) A=$7 / $11; else A=$7;
X  if (A > Mps) Mps=A;
X  next
X}
X$6=="Expire:" {
X  if ($7 <= 0) next
X  xrun++; xart+=$7; xgr+=$9; xsec+=$11
X  xTrun++; xTart+=$7; xTgr+=$9; xTsec+=$11
X  if ($7 > xMart) xMart=$7
X  if ($9 > xMgr) xMgr=$9
X  if ($11 > xMsec) xMsec=$11
X  if ($11 > 0) A=$7 / $11; else A=$7
X  if (A > xMps) xMps=A
X  next
X}
XEND{
X  if (day == "0") { print "Z"; exit }
X  print "d " date
X  if (l && (run > 0 || xrun > 0)) {
X    print "h"
X    printf "c" f,run,art,Mart,gr,Mgr,sec,Msec
X    printf "e" f,xrun,xart,xMart,xgr,xMgr,xsec,xMsec
X  }
X  if (t) {
X    print "H"
X    printf "C %d %d %d %d\n",Trun,Tart,Tsec,Mps
X    printf "E %d %d %d %d\n",xTrun,xTart,xTsec,xMps
X  }
X}' |
Xif $debug ; then
X  cat
Xelse
X${AWK} 'BEGIN{
X first=""
X}
X/^d/{
X last=$2 " " $3
X if (first == "") first=last
X next
X}
X/^h/{
X printf "\nStatistics for %s\n", last
X next
X}
X/^H/{
X tostr=""
X if (first != last) tostr=" to " last
X printf "\nSummary for %s%s:\n", first, tostr
X next
X}
X/^[cC]/{tp="Collection"}
X/^[eE]/{tp="Expiration"}
X/^[ce]/{
X if ($2 == 0) next
X printf "\n  %s runs: %d\n", tp, $2
X printf "%10d articles, average of %5d per run, maximum %6d\n", $3, $3/$2, $4
X printf "%10d groups,   average of %5d per run, maximum %6d\n", $5, $5/$2, $6
X printf "%10d seconds,  average of %5d per run, maximum %6d\n", $7, $7/$2, $8
X next
X}
X/^[CE]/{
X printf "\n  %s runs: %d\n", tp, $2
X if ($2 == 0) next
X printf "%10d articles, average of %5d per run\n", $3, $3/$2
X printf "%10d seconds,  average of %5d per run\n", $4, $4/$2
X if ($4>0) avg=$3/$4; else avg=$3
X printf "    average of %d articles per second, maximum %d\n", avg, $5
X}
X/^Z/{
X printf "Log is empty\n"
X}'
Xfi
X
END_OF_FILE
  if test 3021 -ne `wc -c <'nnstats.sh'`; then
    echo shar: \"'nnstats.sh'\" unpacked with wrong size!
  fi
  # end of 'nnstats.sh'
fi
if test -f 'nntp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nntp.h'\"
else
  echo shar: Extracting \"'nntp.h'\" \(2530 characters\)
  sed "s/^X//" >'nntp.h' <<'END_OF_FILE'
X/*
X * Response codes for NNTP server
X *
X * @(#)nntp.h	1.7	(Berkeley) 1/11/88
X *
X * First digit:
X *
X *	1xx	Informative message
X *	2xx	Command ok
X *	3xx	Command ok so far, continue
X *	4xx	Command was correct, but couldn't be performed
X *		for some specified reason.
X *	5xx	Command unimplemented, incorrect, or a
X *		program error has occured.
X *
X * Second digit:
X *
X *	x0x	Connection, setup, miscellaneous
X *	x1x	Newsgroup selection
X *	x2x	Article selection
X *	x3x	Distribution
X *	x4x	Posting
X */
X
X#define	CHAR_INF	'1'
X#define	CHAR_OK		'2'
X#define	CHAR_CONT	'3'
X#define	CHAR_ERR	'4'
X#define	CHAR_FATAL	'5'
X
X#define	INF_HELP	100	/* Help text on way */
X#define	INF_DEBUG	199	/* Debug output */
X
X#define	OK_CANPOST	200	/* Hello; you can post */
X#define	OK_NOPOST	201	/* Hello; you can't post */
X#define	OK_SLAVE	202	/* Slave status noted */
X#define	OK_GOODBYE	205	/* Closing connection */
X#define	OK_GROUP	211	/* Group selected */
X#define	OK_GROUPS	215	/* Newsgroups follow */
X#define	OK_ARTICLE	220	/* Article (head & body) follows */
X#define	OK_HEAD		221	/* Head follows */
X#define	OK_BODY		222	/* Body follows */
X#define	OK_NOTEXT	223	/* No text sent -- stat, next, last */
X#define	OK_NEWNEWS	230	/* New articles by message-id follow */
X#define	OK_NEWGROUPS	231	/* New newsgroups follow */
X#define	OK_XFERED	235	/* Article transferred successfully */
X#define	OK_POSTED	240	/* Article posted successfully */
X
X#define CONT_XFER	335	/* Continue to send article */
X#define	CONT_POST	340	/* Continue to post article */
X
X#define	ERR_GOODBYE	400	/* Have to hang up for some reason */
X#define	ERR_NOGROUP	411	/* No such newsgroup */
X#define	ERR_NCING	412	/* Not currently in newsgroup */
X#define	ERR_NOCRNT	420	/* No current article selected */
X#define	ERR_NONEXT	421	/* No next article in this group */
X#define	ERR_NOPREV	422	/* No previous article in this group */
X#define	ERR_NOARTIG	423	/* No such article in this group */
X#define ERR_NOART	430	/* No such article at all */
X#define ERR_GOTIT	435	/* Already got that article, don't send */
X#define ERR_XFERFAIL	436	/* Transfer failed */
X#define	ERR_XFERRJCT	437	/* Article rejected, don't resend */
X#define	ERR_NOPOST	440	/* Posting not allowed */
X#define	ERR_POSTFAIL	441	/* Posting failed */
X
X#define	ERR_COMMAND	500	/* Command not recognized */
X#define	ERR_CMDSYN	501	/* Command syntax error */
X#define	ERR_ACCESS	502	/* Access to server denied */
X#define ERR_FAULT	503	/* Program fault, command not performed */
X
X/* RFC 977 defines this; don't change it. */
X
X#define	NNTP_STRLEN	512
END_OF_FILE
  if test 2530 -ne `wc -c <'nntp.h'`; then
    echo shar: \"'nntp.h'\" unpacked with wrong size!
  fi
  # end of 'nntp.h'
fi
echo shar: End of archive 20 \(of 22\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 22 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

