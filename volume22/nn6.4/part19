Subject:  v22i053:  NN Newsreader, release 6.4, Part19/21
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 87ea17b3 5c5fecc1 0fd3183b 6c9d0924

Submitted-by: "Kim F. Storm" <storm@texas.dk>
Posting-number: Volume 22, Issue 53
Archive-name: nn6.4/part19

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  conf/s-fortune.h conf/s-template.h conf/s-umipsb.h dir.c
#   execute.c global.h inews/Makefile inews/README.NN keymap.h
#   man/nngoback.1 options.c pack_date.c proto.c
# Wrapped by storm@texas.dk on Sun May  6 18:20:17 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 19 (of 22)."'
if test -f 'conf/s-fortune.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'conf/s-fortune.h'\"
else
  echo shar: Extracting \"'conf/s-fortune.h'\" \(3266 characters\)
  sed "s/^X//" >'conf/s-fortune.h' <<'END_OF_FILE'
X*******************************************************************
X/*
X *	This file is for Fortune 32:16 systems.
X *	Use with m-m680x0.h file, but requires STRCSPN in config.h
X *	The Fortune may have problems with the nested #ifdef:s in
X *	regexp.c (STRCSPN + __STDC__).  If so remove the __STDC__ ifdef.
X *
X *	From thewev!root, July 9, 1989.
X */
X
X
X/*
X *	Include header files containing the following definitions:
X *
X * 		off_t, time_t, struct stat
X */
X
X#include <sys/types.h>
X#include <stat.h>
X
X
X/*
X *	Define if your system has system V like ioctls
X */
X
X/* #define	HAVE_TERMIO			/* */
X
X/*
X *	Define to use terminfo database.
X *	Otherwise, termcap is used
X */
X
X/* #define	USE_TERMINFO			/* */
X
X/*
X *	Specify the library (or libraries) containing the termcap/terminfo
X *	routines.
X *
X *	Notice:  nn only uses the low-level terminal access routines
X *	(i.e. it does not use curses).
X */
X
X#define TERMLIB	-ltermlib
X
X/*
X *	Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X
X/* #define HAVE_STRCHR			/* */
X
X/*
X *	Define if a signal handler has type void (see signal.h)
X */
X
X/* #define	SIGNAL_HANDLERS_ARE_VOID	/* */
X
X/*
X *	Define if signals must be set again after they are caught
X */
X
X#define	RESET_SIGNAL_WHEN_CAUGHT	/* */
X
X/*
X *	Define MICRO_ALARM to timeout in 0.1 seconds if possible
X */
X
X#define MICRO_ALARM()	alarm(1)	/* System V */
X/*#define MICRO_ALARM()	ualarm(100000,0)	/* BSD 4.3 */
X
X/*
X *	Define if your system has BSD like job control (SIGTSTP works)
X */
X
X/* #define HAVE_JOBCONTROL			/* */
X
X
X/*
X *	Define if your system has a 4.3BSD like syslog library.
X */
X
X#undef HAVE_SYSLOG
X
X/*
X *	Define if your system provides the "directory(3X)" access routines
X *
X *	If true, include the header file(s) required by the package below
X *	(remember that <sys/types.h> or equivalent is included above)
X *	Also typedef Direntry to the proper struct type.
X */
X
X/* #define	HAVE_DIRECTORY			/* */
X
X/* #include <dirent.h>			/* System V */
X#include <sys/dir.h>				/* BSD */
X
X/* typedef struct dirent Direntry;		/* System V */
Xtypedef struct direct Direntry;		/* BSD */
X
X/*
X *	Define if your system has a mkdir() library routine
X */
X
X#define	HAVE_MKDIR			/* */
X
X
X/*
X *	Define HAVE_GETHOSTNAME if your system provides a BSD like
X *	gethostname routine.
X *	Otherwise, define HAVE_UNAME if uname() is avaiable.
X *	As a final resort, define HOSTNAME to the name of your system
X *	(in config.h).
X */
X
X/* #define	HAVE_GETHOSTNAME	/* BSD systems */
X
X/* #define	HAVE_UNAME			/* System V */
X
X/*
X *	Define DETATCH_TERMINAL to be a command sequence which
X *	will detatch a process from the control terminal
X *	Also include system files needed to perform this HERE.
X *	If not possible, just define it (empty)
X */
X
X/* #include "...." */
X
X#define	DETATCH_TERMINAL /* setpgrp(); */
X
X
X/*
X *	Specify where the Bourne Shell is.
X */
X
X#define SHELL		"/bin/sh"
X
X/*
X *	Specify the default mailer to be invoked by nnmail
X */
X
X#define	MAILX		"/bin/mail"	/* FOR:PRO */
X/* #define	MAILX	"/usr/ucb/Mail"		/* BSD */
X
X/*
X *	Define the maximum length of any pathname that may occur
X */
X
X#define	FILENAME 	128
X
X
X/*
X *	Define standard compiler flags here:
X */
X
X#define COMPILER_FLAGS -O
X
X/*
X *	If your system requires other libraries when linking nn
X *	specify them here:
X */
X
X#define EXTRA_LIB
END_OF_FILE
  if test 3266 -ne `wc -c <'conf/s-fortune.h'`; then
    echo shar: \"'conf/s-fortune.h'\" unpacked with wrong size!
  fi
  # end of 'conf/s-fortune.h'
fi
if test -f 'conf/s-template.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'conf/s-template.h'\"
else
  echo shar: Extracting \"'conf/s-template.h'\" \(4660 characters\)
  sed "s/^X//" >'conf/s-template.h' <<'END_OF_FILE'
X/*
X *	Use this file as a template for new s- files
X */
X
X
X/*
X *	Include header files containing the following definitions:
X *
X * 		off_t, time_t, struct stat
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X
X/*
X *	Define if your system has system V like ioctls
X */
X
X#define	HAVE_TERMIO			/* */
X
X/*
X *	Define to use terminfo database.
X *	Otherwise, termcap is used
X */
X
X#define	USE_TERMINFO			/* */
X
X/*
X *	Specify the library (or libraries) containing the termcap/terminfo
X *	routines.
X *
X *	Notice:  nn only uses the low-level terminal access routines
X *	(i.e. it does not use curses).
X */
X
X#define TERMLIB	-ltermlib
X
X/*
X *	Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X
X#define HAVE_STRCHR			/* */
X
X/*
X *	Availability of varargs/vprintf/vsprintf is normally assumed
X *	on most systems, *unless* NO_VARARGS is defined either here or
X *	in the m- file.
X *
X *	To overrule a NO_VARARGS in the m- file, define HAVE_VARARGS
X *	below if the varargs feature is available, *including* the
X *	vprintf/vsprintf routines.
X *
X *	You may also define NO_VARARGS here, if varargs or the v*printf
X *	are not available on this OS, but the m- file doesn't say so.
X */
X
X/* #define HAVE_VARARGS /* Ignore NO_VARARGS -- else default */
X/* #define NO_VARARGS /* */
X
X/*
X *	Define if a signal handler has type void (see signal.h)
X */
X
X#define	SIGNAL_HANDLERS_ARE_VOID	/* */
X
X/*
X *	Define if signals must be set again after they are caught
X */
X
X#define	RESET_SIGNAL_WHEN_CAUGHT	/* */
X
X/*
X *	Define MICRO_ALARM to timeout in 0.1 seconds if possible
X */
X
X#define MICRO_ALARM()	alarm(1)	/* System V */
X/*#define MICRO_ALARM()	ualarm(100000,0)	/* BSD 4.3 */
X
X/*
X *	Define if your system has BSD like job control (SIGTSTP works)
X */
X
X/* #define HAVE_JOBCONTROL			/* */
X
X
X/*
X *	Define if your system has a 4.3BSD like syslog library.
X */
X
X#undef HAVE_SYSLOG
X
X/*
X *	Define if your system provides the "directory(3X)" access routines
X *
X *	If true, include the header file(s) required by the package below
X *	(remember that <sys/types.h> or equivalent is included above)
X *	Also typedef Direntry to the proper struct type.
X */
X
X#define	HAVE_DIRECTORY			/* */
X
X#include <dirent.h>			/* System V */
X/* #include <sys/dir.h>				/* BSD */
X
Xtypedef struct dirent Direntry;		/* System V */
X/* typedef struct direct Direntry;		/* BSD */
X
X/*
X *	Define if your system has a mkdir() library routine
X */
X
X#define	HAVE_MKDIR			/* */
X
X
X/*
X *	Pick one:
X *	Define HAVE_GETHOSTNAME if you have a BSD like gethostname routine.
X *	Define HAVE_UNAME if a system V compatible uname() is available.
X *	Define HOSTNAME_FILE "...." to a file containing the hostname.
X *	Define HOSTNAME_WHOAMI if sysname is defined in <whoami.h>.
X *
X *	As a final resort, define HOSTNAME to the name of your system
X *	(in config.h).
X */
X
X/* #define HAVE_GETHOSTNAME			/* BSD systems */
X/* #define HAVE_UNAME				/* System V */
X/* #define HOSTNAME_FILE "/etc/uucpname"	/* or another file */
X/* #define HOSTNAME_WHOAMI			/* in <whoami.h> */
X
X/*
X *	Define HAVE_MULTIGROUP if system has simultaneous multiple group
X *	membership capability (BSD style).
X *	Also define NGROUPS or include the proper .h file if NGROUPS is
X *	not defined in <sys/param.h>.
X *	Also define GIDSET_TYPE to the type of the elements in the array
X *	initialized by getgroups() if different from "int" (many systems
X *	have a gid_t, but very few use it for getgroups()).
X */
X
X/* #define HAVE_MULTIGROUP	/* BSD */
X
X/*
X *	Define DETATCH_TERMINAL to be a command sequence which
X *	will detatch a process from the control terminal
X *	Also include system files needed to perform this HERE.
X *	If not possible, just define it (empty)
X */
X
X/* #include "...." */
X
X#define	DETATCH_TERMINAL /* setpgrp(); */
X
X
X/*
X *	Specify where the Bourne Shell is.
X */
X
X#define SHELL		"/bin/sh"
X
X/*
X *	Define OLD_AWK to the name of the "old awk" program if your
X *	standard 'awk' is 'nawk' (new awk).  Use full path if necessary.
X *	(This is a temporary hack until I get time to fix the scripts
X *	which breaks nawk).
X */
X
X/* #define OLD_AWK	"oawk"		/* */
X
X/*
X *	Define AVOID_SHELL_EXEC if the system gets confused by
X *		#!/bin/sh
X *	lines in shell scripts, e.g. only reads #! and thinks it
X *	is a csh script.
X */
X
X/* #define AVOID_SHELL_EXEC		/* */
X
X/*
X *	Specify the default mailer to be invoked by nnmail
X */
X
X#define	MAILX		"/usr/bin/mailx"	/* SV */
X/* #define	MAILX	"/usr/ucb/Mail"		/* BSD */
X
X/*
X *	Define the maximum length of any pathname that may occur
X */
X
X#define	FILENAME 	256
X
X
X/*
X *	Define standard compiler flags here:
X */
X
X#define COMPILER_FLAGS
X
X/*
X *	If your system requires other libraries when linking nn
X *	specify them here:
X */
X
X#define EXTRA_LIB
END_OF_FILE
  if test 4660 -ne `wc -c <'conf/s-template.h'`; then
    echo shar: \"'conf/s-template.h'\" unpacked with wrong size!
  fi
  # end of 'conf/s-template.h'
fi
if test -f 'conf/s-umipsb.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'conf/s-umipsb.h'\"
else
  echo shar: Extracting \"'conf/s-umipsb.h'\" \(4131 characters\)
  sed "s/^X//" >'conf/s-umipsb.h' <<'END_OF_FILE'
X/*
X *	This is a file for Mips Risc/os, version 4.0 or later, for
X *	compiling in the bsd43 (instead of sys v) environment.
X *	From: beldar@mips.com (Gardner Cohen)
X */
X
X
X/*
X *	Include header files containing the following definitions:
X *
X * 		off_t, time_t, struct stat
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X
X/*
X *	Define if your system has system V like ioctls
X */
X
X#undef	HAVE_TERMIO			/* */
X
X/*
X *	Define to use terminfo database.
X *	Otherwise, termcap is used
X */
X
X#undef	USE_TERMINFO			/* */
X
X/*
X *	Specify the library (or libraries) containing the termcap/terminfo
X *	routines.
X *
X *	Notice:  nn only uses the low-level terminal access routines
X *	(i.e. it does not use curses).
X */
X
X#define TERMLIB	-ltermcap
X
X/*
X *	Define HAVE_STRCHR if strchr() and strrchr() are available
X */
X
X#define HAVE_STRCHR			/* */
X
X/*
X *	Define if a signal handler has type void (see signal.h)
X */
X
X#undef	SIGNAL_HANDLERS_ARE_VOID	/* */
X
X/*
X *	Define if signals must be set again after they are caught
X */
X
X#undef	RESET_SIGNAL_WHEN_CAUGHT	/* */
X
X/*
X *	Define MICRO_ALARM to timeout in 0.1 seconds if possible
X */
X
X/*#define MICRO_ALARM()	alarm(1)	/* System V */
X#define MICRO_ALARM()	ualarm(100000,0)	/* BSD 4.3 */
X
X/*
X *	Define if your system has BSD like job control (SIGTSTP works)
X */
X
X#define HAVE_JOBCONTROL			/* */
X
X
X/*
X *	Define if your system has a 4.3BSD like syslog library.
X */
X
X#undef HAVE_SYSLOG
X
X/*
X *	Define if your system provides the "directory(3X)" access routines
X *
X *	If true, include the header file(s) required by the package below
X *	(remember that <sys/types.h> or equivalent is included above)
X *	Also typedef Direntry to the proper struct type.
X */
X
X#define	HAVE_DIRECTORY			/* */
X
X#include <sys/dir.h>				/* BSD */
X
Xtypedef struct direct Direntry;		/* BSD */
X
X/*
X *	Define if your system has a mkdir() library routine
X */
X
X#define	HAVE_MKDIR			/* */
X
X
X/*
X *	Define HAVE_GETHOSTNAME if your system provides a BSD like
X *	gethostname routine.
X *	Otherwise, define HAVE_UNAME if uname() is avaiable.
X *	As a final resort, define HOSTNAME to the name of your system
X *	(in config.h).
X */
X
X#define	HAVE_GETHOSTNAME	/* BSD systems */
X
X/*
X *	Define HAVE_MULTIGROUP if system has simultaneous multiple group
X *	membership capability (BSD style).
X *
X *	Also define GIDSET_TYPE to the type of the elements in the array
X *	initialized by getgroups() if different from "int" (many systems
X *	have a gid_t, but very few use it for getgroups()).
X */
X
X#define HAVE_MULTIGROUP
X
X#define GIDSET_TYPE	gid_t	/* Newer 4.3 systems may use this */
X
X/* #define	HAVE_UNAME			/* System V */
X
X/*
X *	Define DETATCH_TERMINAL to be a command sequence which
X *	will detatch a process from the control terminal
X *	Also include system files needed to perform this HERE.
X *	If not possible, just define it (empty)
X */
X
X
X#include <sys/file.h>	/* for O_RDONLY */
X#include <sys/ioctl.h>	/* for TIOCNOTTY */
X
X#define	DETATCH_TERMINAL \
X    { int t = open("/dev/tty", O_RDONLY); \
X	  if (t >= 0) ioctl(t, TIOCNOTTY, (int *)0), close(t); }
X
X
X
X/*
X *	Specify where the Bourne Shell is.
X */
X
X#define SHELL		"/bin/sh"
X
X/*
X *	Define AVOID_SHELL_EXEC if the system gets confused by
X *		#!/bin/sh
X *	lines in shell scripts, e.g. only reads #! and thinks it
X *	is a csh script.
X */
X
X/* #define AVOID_SHELL_EXEC		/* */
X
X/*
X *	Specify the default mailer to be invoked by nnmail
X */
X
X#define	MAILX		"/usr/bin/mailx"	/* SV */
X/* #define	MAILX	"/usr/ucb/Mail"		/* BSD */
X
X
X/*
X *	Specify the default pager & options.
X */
X
X#define	PAGER		"less"
X
X/*
X *	Specify the default print command and options.
X */
X
X#define	PRINTER		"/usr/bin/lp -s"
X
X
X/*
X *	Define the maximum length of any pathname that may occur
X */
X
X#define	FILENAME 	1024
X
X
X/*
X *	Define standard compiler flags here:
X */
X#undef COMPILER_FLAGS
X#undef COMPILER
X#undef CDEBUG
X#define COMPILER_FLAGS -O2 -Olimit 2000
X#define COMPILER cc -systype bsd43
X#define CDEBUG -g3
X
X/*
X *	If your system requires other libraries when linking nn
X *	specify them here:
X */
X
X#define EXTRA_LIB
X
X/*
X *	It is said that vprintf is missing from the bsd43 library
X *	on MIPS/120 -- what a mess!	++KFS
X */
X
X#define NO_VARARGS
END_OF_FILE
  if test 4131 -ne `wc -c <'conf/s-umipsb.h'`; then
    echo shar: \"'conf/s-umipsb.h'\" unpacked with wrong size!
  fi
  # end of 'conf/s-umipsb.h'
fi
if test -f 'dir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dir.c'\"
else
  echo shar: Extracting \"'dir.c'\" \(3623 characters\)
  sed "s/^X//" >'dir.c' <<'END_OF_FILE'
X/*
X *	(c) Copyright 1990, Kim Fabricius Storm.  All rights reserved.
X *
X *	Directory access.
X * 	read file names in directory 'dir' starting with 'prefix'
X */
X
X#include "config.h"
X#include "articles.h"
X#include "dir.h"
X
Xstatic char dir_path[FILENAME], *dir_tail;
X
X#ifdef HAVE_DIRECTORY
X
Xstatic string_marker str_mark;
Xstatic char **completions = NULL;
Xstatic char **comp_iterator;
Xstatic char **comp_help;
X
X/*
X * list_directory scans the directory twice; first time to find out how
X * many matches there are, and second time to save the names, after
X * sufficient memory have been allocated to store it all.
X */
X
Xstatic sort_directory(f1, f2)		/* Used by [Dqsort */
X    register char **f1;
X    register char **f2;
X{
X    return strcmp(*f1, *f2);
X}
X
Xlist_directory(dir, prefix)
Xchar *dir, *prefix;
X{
X    DIR *dirp;
X    register Direntry *dp;
X    register char *cp;
X    register char **comp;
X    int pflen = strlen(prefix);
X    unsigned count = 0, comp_length = 0;
X
X    if ((dirp = opendir(dir)) == NULL)
X	return 0;			/* tough luck */
X
X    mark_str(&str_mark);
X
X    while ((dp = readdir(dirp)) != NULL) {
X	cp = dp->d_name;
X#ifdef FAKED_DIRECTORY
X	if (dp->d_ino == 0) continue;
X	cp[14] = NUL;
X#endif
X	if (*cp == '.' && (cp[1] == '\0' || (cp[1] == '.' && cp[2] == '\0')))
X	    continue;
X	if (pflen && strncmp(prefix, cp, pflen)) continue;
X	if (count == comp_length) {
X	    comp_length += 100;
X	    completions = resizeobj(completions, char *, comp_length + 1);
X	    comp = completions + count;
X	}
X	strcpy(*comp++ = alloc_str(strlen(cp)), cp);
X	count++;
X    }
X    closedir(dirp);
X    if (count == 0) {
X	release_str(&str_mark);
X	return 0;
X    }
X
X    quicksort(completions, count, char *, sort_directory);
X    *comp = (char *)0;
X    comp_iterator = completions;
X    comp_help = completions;
X
X    dir_tail = dir_path;
X    while (*dir_tail++ = *dir++);
X    dir_tail[-1] = '/';
X
X    return 1;
X}
X
Xnext_directory(buffer, add_slash)
Xregister char *buffer;
Xint add_slash;
X{
X    if (*comp_iterator != NULL) {
X	strcpy(buffer, *comp_iterator);
X
X	if (add_slash) {
X	    strcpy(dir_tail, *comp_iterator);
X	    if (file_exist(dir_path, "d"))
X		strcat(buffer, "/");
X	}
X	comp_iterator++;
X	return 1;
X    }
X    close_directory();
X    return 0;
X}
X
Xcompl_help_directory()
X{
X    list_completion((char *)NULL);
X
X    if (*comp_help == NULL) comp_help = completions;
X    while (*comp_help && list_completion(*comp_help))
X	    comp_help++;
X
X    fl;
X    return 1;
X}
X
Xclose_directory()
X{
X    if (completions) {
X	release_str(&str_mark);
X	freeobj(completions);
X	completions = NULL;
X    }
X}
X
X#else
X
Xstatic FILE *dirf;
Xstatic int prefix_lgt;
X
Xlist_directory(dir, prefix)
Xchar *dir, *prefix;
X{
X    if (prefix[0])
X	sprintf(dir_path, "cd %s && echo %s* 2>/dev/null", dir, prefix);
X    else
X	sprintf(dir_path, "cd %s && ls 2>/dev/null", dir);
X    prefix_lgt = strlen(prefix);
X
X    if ((dirf = popen(dir_path, "r")) == NULL) return 0;
X
X    dir_tail = dir_path;
X    while (*dir_tail++ = *dir++);
X    dir_tail[-1] = '/';
X
X    return 1;
X}
X
Xnext_directory(buffer, add_slash)
Xchar *buffer;
Xint add_slash;
X{
X    register char *cp;
X    register int c;
X
X    cp = buffer;
X    while ((c = getc(dirf)) != EOF && (c != SP) && (c != NL))
X	*cp++ = c;
X
X    if (cp != buffer) {
X	*cp = NUL;
X	if (strcmp(buffer + prefix_lgt, "*")) {
X
X	    if (!add_slash) return 1;
X
X	    strcpy(dir_tail, buffer);
X    	    if (file_exist(dir_path, "d")) {
X		*cp++ = '/';
X		*cp = NUL;
X	    }
X
X	    return 1;
X	}
X
X    }
X
X    close_directory();
X    return 0;
X}
X
Xcompl_help_directory()
X{
X    return 0;
X}
X
Xclose_directory()
X{
X    if (dirf) {
X	pclose(dirf);
X	dirf = NULL;
X    }
X}
X#endif /* HAVE_DIRECTORY */
X
END_OF_FILE
  if test 3623 -ne `wc -c <'dir.c'`; then
    echo shar: \"'dir.c'\" unpacked with wrong size!
  fi
  # end of 'dir.c'
fi
if test -f 'execute.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'execute.c'\"
else
  echo shar: Extracting \"'execute.c'\" \(3113 characters\)
  sed "s/^X//" >'execute.c' <<'END_OF_FILE'
X/*
X *	(c) Copyright 1990, Kim Fabricius Storm.  All rights reserved.
X *
X *	UNIX command execution.
X */
X
X#include <signal.h>
X#include <errno.h>
X#include "config.h"
X#include "term.h"
X
Xexport int shell_restrictions = 0;	/* disable shell escapes */
X
Xexport char *user_shell;
Xexport char *exec_chdir_to = NULL;
X
Xstatic shell_check()
X{
X    if (shell_restrictions) {
X	msg("Restricted operation - not allowed");
X	return -1;
X    }
X    return 0;
X}
X
X
Xinit_execute()
X{
X    if ((user_shell = getenv("SHELL")) == NULL)
X	user_shell = SHELL;
X}
X
Xexecute(path, args, toggle_visual)
Xchar *path, **args;
Xint toggle_visual;
X{
X    int was_raw, pid, i, status;
X    sig_type  (*quit)(), (*intr)(), (*tstp)();
X    extern int errno;
X
X    was_raw = toggle_visual ? visual_off() : unset_raw();
X
X    while ((pid = fork()) == -1) sleep(1);
X
X    if (pid == 0) {
X	for (i = 3 ; i < 20 ; i++)
X	    close(i);
X
X	if (exec_chdir_to != NULL) chdir(exec_chdir_to);
X
X	execv(path, args);
X
X	fprintf(stderr, "%s: not found\n", path);
X	nn_exit(20);
X    }
X    quit = signal(SIGQUIT, SIG_IGN);
X    intr = signal(SIGINT,  SIG_IGN);
X#ifdef HAVE_JOBCONTROL
X    tstp = signal(SIGTSTP, SIG_DFL);
X#endif
X    while ((i = wait(&status)) != pid && (i != -1 || errno == EINTR));
X
X    signal(SIGQUIT, quit);
X    signal(SIGINT,  intr);
X#ifdef HAVE_JOBCONTROL
X    signal(SIGTSTP, tstp);
X#endif
X    if (toggle_visual) {
X	visual_on();
X	if (toggle_visual == 2) s_redraw++;
X    }
X
X    if (was_raw) raw();
X
X    return status != 0;
X}
X
X
Xshell_escape()
X{
X    static char command[FILENAME] = "";
X    char *cmd;
X    int first = 1;
X
X    if (shell_check()) return 0;
X
X    for (;;) {
X	prompt("\1!\1");
X	cmd = get_s(command, NONE, NONE, NULL_FCT);
X	if (cmd == NULL) return !first;
X
X	if (*cmd == NUL) {
X	    if (first) run_shell((char *)NULL, 1);
X	    return 1;
X	}
X
X	strcpy(command, cmd);
X
X	if (!run_shell(command, first)) return !first;
X	first = 0;
X	prompt_line = -1;
X    }
X}
X
X
Xstatic char *exec_sh_args[] = {
X    "nnsh",
X    (char *)NULL, /* "-c" or "-i" */
X    (char *)NULL, /* cmdstring */
X    (char *)NULL
X};
X
Xrun_shell(command, clear)
Xchar *command;
Xint clear; /* -2 => no command output (:!!command) - keep visual,
X	      output before command: -1 => none, 0 => CR/NL, 1 => clear */
X{
X    char cmdstring[512];
X
X    if (shell_check()) return 0;
X
X    if (command != NULL) {
X	if (!expand_file_name(cmdstring, command, 1)) return 0;
X	exec_sh_args[1] = "-c";
X        exec_sh_args[2] = cmdstring;
X    } else {
X	exec_sh_args[1] = "-i";
X        exec_sh_args[2] = NULL;
X    }
X
X    if (clear > 0) {
X	clrdisp();
X	fl;
X    } else if (clear == 0) {
X	putchar(CR);
X	putchar(NL);
X    }
X
X    execute(user_shell, exec_sh_args, clear == -2 ? 0 : 1);
X    return 1;
X}
X
X#ifndef HAVE_JOBCONTROL
Xstatic char *exec_suspend_args[] = {
X    "nnsh",
X    "-i",
X    (char *)NULL
X};
X#endif
X
Xsuspend_nn()
X{
X    int was_raw;
X
X    if (shell_check()) return 0;
X
X    gotoxy(0, Lines-1);
X    clrline();
X
X#ifdef HAVE_JOBCONTROL
X    was_raw = visual_off();
X    kill(process_id, SIGSTOP);
X    visual_on();
X    s_redraw++;
X    if (was_raw) raw();
X#else
X    execute(user_shell, exec_suspend_args, 2);
X#endif
X
X    return 1;
X}
END_OF_FILE
  if test 3113 -ne `wc -c <'execute.c'`; then
    echo shar: \"'execute.c'\" unpacked with wrong size!
  fi
  # end of 'execute.c'
fi
if test -f 'global.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'global.h'\"
else
  echo shar: Extracting \"'global.h'\" \(4559 characters\)
  sed "s/^X//" >'global.h' <<'END_OF_FILE'
X/*
X *	(c) Copyright 1990, Kim Fabricius Storm.  All rights reserved.
X *
X *	Global declarations and definitions.
X */
X
X/*
X *	Marks for global/external variables
X */
X
X#define	export			/* export variable from module */
X#define import	extern		/* import variable into module */
X
X/*
X *	Various constants and types
X */
X
Xtypedef int8  	attr_type;
Xtypedef int32 	flag_type;
X
X#ifdef I286_BUG
X#	define FLAG(n)	(1L<<(n-1))
X#else
X#	define FLAG(n)	(((flag_type)1)<<(n-1))
X#endif
X
Xtypedef int32	article_number;
Xtypedef int16	group_number;
Xtypedef uint32	time_stamp;
X
Xtypedef int	(* fct_type )();
X#define CALL(fct)  (* (fct))
X#define NULL_FCT  (fct_type)NULL
X
X/* frequently used characters */
X
X#define NUL	'\0'
X#define TAB	'\t'
X#define NL	'\n'
X#define CR	'\r'
X#define BS	'\b'
X#define SP	' '
X
X/* misc macros */
X
X#define fl fflush(stdout)
X
X#ifdef CONTROL_
X#undef CONTROL_
X#endif
X#define CONTROL_(c)	(c&037)
X
X#ifndef HAVE_STRCHR
X#define	strrchr		rindex
X#define strchr		index
X#endif
X
X#ifdef SIGNAL_HANDLERS_ARE_VOID
X#define sig_type void
X#else
X#define sig_type int
X#endif
X
X#ifndef NNTP
X#undef NNTP_POST
X#endif
X
X/*
X *	Some systems don't define these in <sys/stat.h>
X */
X
X#ifndef S_IFMT
X#define	S_IFMT	0170000			/* type of file */
X#define S_IFDIR	0040000			/* directory */
X#define S_IFREG	0100000			/* regular */
X#endif
X
X#ifndef O_RDONLY
X#define	O_RDONLY	0
X#define	O_WRONLY	1
X#define	O_RDWR		2
X#endif
X
X/* define types of library functions */
X
Xchar 	*getenv(), *ctime();
Xchar 	*strchr(), *strrchr();
Xoff_t 	lseek(), ftell(), tell();
Xint	atoi();
Xlong	atol();
X
X
X/* define types of own functions */
X
Xchar *mk_file_name(), *home_relative();
Xchar *date_time(), *user_name(), *plural();
Xchar *copy_str();
X
Xtime_t	file_exist(), m_time(), cur_time();
X
Xextern FILE *open_file();
Xchar *relative();
X
X#define	OPEN_READ	0	/* open for reading */
X#define	OPEN_UPDATE	1	/* open/create for update */
X#define	OPEN_CREATE	2	/* create/truncate for write */
X#define	OPEN_APPEND	3	/* open for append */
X#define OPEN_CREATE_RW	4	/* create for read/write */
X
X#define	DONT_CREATE	0x40	/* return if file does not exist */
X#define	MUST_EXIST	0x80	/* fatal error if cannot open */
X#define	OPEN_UNLINK	0x100	/* unlink after open (not OPEN_UPDATE) */
X
X
X/*
X *	Other external definitions
X *
X *	NOTICE: the distinction between pointers and arrays is important
X *		here (they are global variables - not function arguments)
X */
X
Xextern char
X
X    *nn_directory,
X    *lib_directory,
X    version_id[];
X
X#ifdef NNTP
Xextern int  use_nntp;   /* 1 iff we are using nntp */
X#else
X#define use_nntp 0	/* for optimizers */
X#endif
X
Xextern int
X    s_hangup,	/* hangup signal */
X    s_keyboard,	/* keyboard signal */
X    s_pipe,	/* broken pipe */
X    s_redraw;	/* continue signal after stop */
X
Xextern int who_am_i;
X
X#define I_AM_MASTER	0
X#define I_AM_NN		1
X#define I_AM_ADMIN	2
X#define I_AM_CHECK	3
X#define I_AM_TIDY	4
X#define I_AM_EMACS	5
X#define I_AM_GOBACK	6
X#define I_AM_POST	7
X#define I_AM_GREP	8
X#define	I_AM_DAILY	9
X#define	I_AM_SPEW	10
X#define I_AM_EXPIRE	11
X#define	I_AM_ACCT	12
X
Xextern unsigned short		/* as they are on most systems... */
X    user_id,
X    group_id;
X
Xextern int
X    process_id;
X
Xextern int errno;
X
X/*
X *	Storage management
X */
X
Xextern char *mem_obj(), *mem_resize(), *mem_str();
X
X#define	newobj(type, nelt) \
X    (type *)mem_obj(sizeof(type), (int32)(nelt))
X
X#define	newstr(nelt) \
X    mem_str((int32)(nelt))
X
X#define	resizeobj(obj, type, nelt) \
X    (type *)mem_resize((char *)(obj), sizeof(type), (int32)(nelt))
X
X#define	freeobj(obj) mem_free((char *)(obj))
X
X#define quicksort(a,n,t,f) qsort((char *)(a), (unsigned)(n), sizeof(t), f)
X
X#include "vararg.h"
X#include "data.h"
X
X/*
X *	db external data
X */
X
Xextern master_header master;
X
X/* group headers */
X
Xextern group_header *active_groups, **sorted_groups;
X
X/* current group information */
X
Xextern char 	group_path_name[];
Xextern char	*group_file_name;
X
Xextern group_header *current_group, *group_sequence, *rc_sequence;
X
Xextern group_header *lookup();
X
X
Xint l_g_index, s_g_first;
X
X#define	Loop_Groups_Number(num) \
X    for (num = 0; num < master.number_of_groups; num++)
X
X#define Loop_Groups_Header(gh) \
X    for (l_g_index = 0, gh=active_groups; \
X	 l_g_index < master.number_of_groups; \
X	 l_g_index++, gh++)
X
X#define Loop_Groups_Sorted(gh) \
X    for (l_g_index = s_g_first; \
X	 (l_g_index < master.number_of_groups) && \
X	 (gh = sorted_groups[l_g_index]) ;\
X	 l_g_index++)
X
X#define	Loop_Groups_Sequence(gh) \
X    for (gh = group_sequence; gh; gh = gh->next_group)
X
X#define	Loop_Groups_Newsrc(gh) \
X    for (gh = rc_sequence; gh; gh = gh->newsrc_seq)
END_OF_FILE
  if test 4559 -ne `wc -c <'global.h'`; then
    echo shar: \"'global.h'\" unpacked with wrong size!
  fi
  # end of 'global.h'
fi
if test -f 'inews/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'inews/Makefile'\"
else
  echo shar: Extracting \"'inews/Makefile'\" \(1463 characters\)
  sed "s/^X//" >'inews/Makefile' <<'END_OF_FILE'
X# Makefile for NN version of mini inews.
X#
X# $RCSfile: Makefile,v $	$Revision: 1.3 $
X#
X# $Author: news $	$Date: 89/12/21 17:59:52 $
X#
X# $State: Exp $	$Locker:  $
X#
X# $Log:	Makefile,v $
X# Revision 1.3  89/12/21  17:59:52  news
X# Added kit processing, cleanups.
X#
X
XTARGET	= inews
X
XBINDIR	= /usr/lib/news/
XSHELL	= /bin/sh
X
XCC	= cc
X# General definitions here which apply to all -- form -DDEF
XDEFS	= -DFOR_NN
X# Link libraries -- form -lLIB
XLIBS	= ../hostname.o
X# Lint definitions -- same as DEFS, but form -D DEF
XLDEFS	= -D lint -D FOR_NN
X# Lint libraries -- same as LIBS, but form -l LIB
XLLIBS	=
X# Set to -g for debugging, -O for optimise, or both if compiler handles it
XDEBUG	= -O
XCFLAGS	= $(DEBUG) $(DEFS) -I.. -I../conf
X
XSRCS	= inews.c clientlib.c version.c
XOBJS	= inews.o clientlib.o version.o
XCLUDES	= clientlib.h conf.h nntp.h
XKIT	= Makefile README README.NN $(SRCS) $(CLUDES)
X
X$(TARGET): $(OBJS)
X	$(CC) $(CFLAGS) -o $(TARGET) $(OBJS) $(LIBS)
X
X$(OBJS):	$(CLUDES)
X
Xall:	$(TARGET)
X
XManifest:	$(KIT)
X	touch Manifest
X	rm -f foo
X	ls -ls Manifest $(KIT) > foo
X	mv foo Manifest
X	ls -ls Manifest $(KIT) > foo
X	mv foo Manifest
X
Xkit:	Manifest
X	shar Manifest $(KIT) > inews.shar
X
Xclean:
X	rm -f $(OBJS) core lint tags
X
Xclobber:	clean
X	rm -f $(TARGET) Make.Log Manifest $(KIT)
X
Xlint:	$(SRCS)
X	lint -D lint $(LLIBES) $(LDEFS) $(SRCS) > lint
X
Xtags:	$(SRCS)
X	ctags $(SRCS)
X
Xinstall:	$(TARGET)
X	../inst inews $(TARGET)
X#	install -o news -g news -m 511 -s -c $(TARGET) $(BINDIR)
END_OF_FILE
  if test 1463 -ne `wc -c <'inews/Makefile'`; then
    echo shar: \"'inews/Makefile'\" unpacked with wrong size!
  fi
  # end of 'inews/Makefile'
fi
if test -f 'inews/README.NN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'inews/README.NN'\"
else
  echo shar: Extracting \"'inews/README.NN'\" \(3051 characters\)
  sed "s/^X//" >'inews/README.NN' <<'END_OF_FILE'
XFrom: Steve Simmons <scs%itivax@relay.EU.net>
XTo: storm@texas.dk (Kim F. Storm)
XDate: Thu, 21 Dec 89 18:02:03 EDT
XSubject: Inews Kit For NN
X
XWhat Is This:
X
XThis is a mini-inews, suitable for building client-only versions of NN
Xthat use NNTP for remote reading.  Some unknown (to me) person patched
Xit to be driven on NNs config.h file.  I have taken those changes, reversed
Xmost of them and upgraded to NNTP release version 1.5.7.  This inews was
Xa co-operative venture when Stan released it, and it's kind of fitting
Xthat it continues to be worked on by many hands.
X
XIf you have a full installation of news where you're installing NN,
Xyou could care less about this.
X
XCopyrights:
X
XSee individual files for authors.  I wrote conf.h and the
XMakefile, and explicitly put them in the public domain.  Other parts
Xmay have other copyrights, see the individual files.
X
XMaintenance:
X
XMy less-than-humble opinion is that as Stan releases nntp patches, you will
Xbe able to apply them to this code with no changes whatsoever.  As Stan
Xreleases patches I will attempt to apply them and upgrade this source,
Xbut no guarantees.
X
XWhy A Separate Release From NNTP:
X
XNN and NNTP both use configuration files to let you fit the software
Xfor your system.  Unfortunately, they used rather different methods.
XThis release specificly reconciles NNs 'config.h' and NNTPs '../common/conf.h'
Xby creating a local "conf.h" which maps 'config.h' to what NNTP inews needs.
XResult -- once you build the config.h for NN you're 98% done with NNTP inews.
X
XINSTALLATION:
X
XIdeally you went to your nn source directory and created a subdir
Xnamed inews.  Then you unpacked this in that directory (I have already
Xdone that, ++Kim).
X
XAll you should need to do is read conf.h, make any changes you feel
Xlike, and then type 'make'.  If things work, type 'make install'.  For
Xmore data on the inews itself, read the file README.  It's slightly
Xedited from the NNTP version to reflect its separation from the rest
Xof NNTP.
X
XFor more data on the inews itself, read the file README.  It's
Xslightly edited from the NNTP version to reflect its separation from
Xthe rest of NNTP.
X
XSteve Simmons
Xscs@lokkur.dexter.mi.us
XDecember 21, 1989
X
X
X--- Changes by Kim Storm, storm@texas.dk
X
XI have edited what Steve sent me a bit further to simplify the
Xconfiguration and installation even more: It now uses nn's code to get
Xthe hostname, so this is now got for free, and it gets the location of
Xthe inews program from config.h as well.
X
XMakefile:
X	Added -I../conf to CFLAGS
X	nn's hostname.o is used instead of uname.o to get the hostname.
X	Installation uses nn's inst script (which will use the possible
X	definition of INEWS or NEWS_LIB_DIRECTORY in config.h).
X
Xconf.h:
X	#defines to set the proper hostname removed.
X	#include "../config.h" line moved to start of file.
X	Documents optional #define USG to get bcopy function.
X
Xclientlib.c, inews.c
X	Added tweaks using a FOR_NN #define to include/exclude
X	code to co-exist with nn's config.h file.
X
Xuname.c:
X	Not used (so it is omitted from this distribution).
END_OF_FILE
  if test 3051 -ne `wc -c <'inews/README.NN'`; then
    echo shar: \"'inews/README.NN'\" unpacked with wrong size!
  fi
  # end of 'inews/README.NN'
fi
if test -f 'keymap.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'keymap.h'\"
else
  echo shar: Extracting \"'keymap.h'\" \(4642 characters\)
  sed "s/^X//" >'keymap.h' <<'END_OF_FILE'
X/*
X *	(c) Copyright 1990, Kim Fabricius Storm.  All rights reserved.
X *
X *	Keyboard (re)mapping
X */
X
X#define K_INVALID		0x0000 /* unknown command (for lookup) */
X
X#define K_UNBOUND		0x0001 /* unbound command key 		*/
X
X#define K_REDRAW		0x0002 /* redraw 			*/
X#define K_CONTINUE		0x0003 /* continue with next ... 	*/
X#define K_LAST_MESSAGE		0x0004 /* repeat last message 		*/
X#define K_HELP			0x0005 /* online help 			*/
X#define K_SHELL			0x0006 /* shell escape 		*/
X#define K_VERSION		0x0007 /* print version 		*/
X#define K_EXTENDED_CMD		0x0008 /* extended commands		*/
X
X#define K_QUIT			0x0009 /* quit 			*/
X
X#define	K_BUG_REPORT		0x000a /* send bug report */
X
X#define K_SAVE_NO_HEADER 	0x0011 /* save articles without header */
X#define K_SAVE_SHORT_HEADER 	0x0012 /* save article with short header */
X#define K_SAVE_FULL_HEADER 	0x0013 /* save articles with full header */
X
X#define K_PRINT			0x0014 /* print ariticle 		*/
X
X#define K_UNSHAR		0x0015 /* unshar article		*/
X
X#define K_REPLY			0x0016 /* reply to article 		*/
X#define K_FOLLOW_UP		0x0017 /* follow up to article 	*/
X#define K_POST			0x0018 /* post an article		*/
X#define K_MAIL_OR_FORWARD 	0x0019 /* mail (forward article) 	*/
X#define K_CANCEL		0x001a /* cancel article 		*/
X#define K_UNSUBSCRIBE		0x001b /* (un)subscribe to group 	*/
X#define K_GROUP_OVERVIEW 	0x001c /* group overview 		*/
X#define K_PATCH			0x001d /* pipe article to patch         */
X#define	K_UUDECODE		0x001e /* uudecode articles		*/
X
X#define K_GOTO_GROUP		0x001f /* goto named group/folder	*/
X
X#define K_KILL_HANDLING		0x0020 /* enter kill menu		*/
X
X    /* scrolling/menu movement */
X
X#define K_CONTINUE_NO_MARK	0x0021 /* as continue but don't mark seen */
X#define K_JUNK_ARTICLES		0x0022 /* convert given attr to read	*/
X#define K_SKIP_LINES		0x0023 /* skip lines of same type	*/
X#define K_NEXT_PAGE		0x0024 /* next page 			*/
X#define K_NEXT_HALF_PAGE 	0x0025 /* next half page		*/
X#define K_NEXT_LINE		0x0026 /* next line			*/
X#define K_PREV_PAGE		0x0027 /* previous page 		*/
X#define K_PREV_HALF_PAGE 	0x0028 /* previous half page		*/
X#define K_PREV_LINE		0x0029 /* previous line		*/
X
X#define K_HEADER_PAGE		0x002a /* first page incl. header	*/
X#define K_FIRST_PAGE		0x002b /* first page 			*/
X#define K_LAST_PAGE		0x002c /* last page 			*/
X
X#define K_GOTO_LINE		0x002d /* goto specific line		*/
X#define K_GOTO_PAGE		0x002e /* goto specific page		*/
X#define K_GOTO_MATCH		0x002f /* goto line matching regexp	*/
X#define K_NEXT_MATCH		0x0030 /* find next match		*/
X
X#define K_PREVIOUS		0x0031 /* goto prev group or article	*/
X				/* (no update is performed)	*/
X
X    /* more() SPECIFIC COMMANDS */
X
X#define K_LEAVE_ARTICLE		0x0032 /* goto next article, mark current */
X#define K_LEAVE_NEXT		0x0033 /* mark current for next time	*/
X#define K_NEXT_ARTICLE		0x0034 /* goto next article	 	*/
X#define K_NEXT_SUBJECT		0x0035 /* goto next subject		*/
X#define K_FULL_DIGEST		0x0036 /* show full digest		*/
X#define K_ROT13			0x0037 /* do rot13 			*/
X#define K_COMPRESS		0x0038 /* compress spaces		*/
X#define K_BACK_TO_MENU		0x0039 /* return to menu */
X#define	K_BACK_ARTICLE		0x003a /* back one article		*/
X#define	K_FORW_ARTICLE		0x003b /* forward one article		*/
X
X    /* menu() SPECIFIC COMMANDS	 */
X
X#define K_SELECT		0x0041 /* select current, move down 	*/
X#define K_SELECT_INVERT		0x0042 /* invert all selections 	*/
X#define K_SELECT_SUBJECT 	0x0043 /* select all with same subject */
X#define K_SELECT_RANGE		0x0044 /* select range 		*/
X#define K_AUTO_SELECT		0x0045 /* auto select from kill file	*/
X#define K_UNSELECT_ALL		0x0046 /* undo all selections		*/
X
X#define K_LAYOUT		0x0049 /* change menu layout 		*/
X
X#define K_NEXT_GROUP_NO_UPDATE 	0x004a /* goto next group, no update 	*/
X#define K_READ_GROUP_UPDATE 	0x004b /* read selected, then next group */
X#define K_READ_GROUP_THEN_SAME	0x004c /* read selected, then same group */
X
X#define K_ADVANCE_GROUP		0x004d /* advance one group in sequence */
X#define K_BACK_GROUP		0x004e /* back-up one group in sequence */
X
X#define K_PREVIEW		0x004f /* preview article 		*/
X
X#define	K_EQUAL_KEY		0x0070 /* map command special symbol	*/
X
X#define	K_MACRO			0x0100 /* call macro			*/
X#define	K_ARTICLE_ID		0x0200 /* article id in lower part	*/
X
X
X/*
X * KEY MAP SIZE is:
X *   (128 normal chars) + (0200) + (4 arrow keys) + (10 function keys)
X */
X
X#define MULTI_KEYS	(1 + 4 + 10)
X#define KEY_MAP_SIZE	(128 + MULTI_KEYS)
X
X
X/* restrictions */
X
X#define K_ONLY_MENU	0x0001
X#define K_ONLY_MORE	0x0002
X
Xtypedef unsigned char key_type;
X
Xextern int menu_key_map[];
Xextern int more_key_map[];
X
Xextern key_type global_key_map[];
X
Xextern char *key_name();
Xextern key_type parse_key();
END_OF_FILE
  if test 4642 -ne `wc -c <'keymap.h'`; then
    echo shar: \"'keymap.h'\" unpacked with wrong size!
  fi
  # end of 'keymap.h'
fi
if test -f 'man/nngoback.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/nngoback.1'\"
else
  echo shar: Extracting \"'man/nngoback.1'\" \(3441 characters\)
  sed "s/^X//" >'man/nngoback.1' <<'END_OF_FILE'
X.TH NNGOBACK 1 "Release 6.4"
X.\" (c) Copyright 1988, 1990, Kim F. Storm.  All rights reserved.
X.UC 4
X.SH NAME
Xnngoback \- make news articles unread on a day-by-day basis (nn)
X.SH SYNOPSIS
X.B nngoback
X[ \-\fBNQvi\fP ]
X[\-\fBd\fP] \fIdays\fP
X[ \fIgroup\fP ]...
X.SH DESCRIPTION
X.I nngoback
Xwill rewind the .newsrc record file of \fBnn\fP(1) one or more \fIdays\fP.
XIt can be used to rewind all groups, or only a specified set of
X\fIgroups\fP.
XIn other words, \fInngoback\fP can mark news articles which have
Xarrived on the system during the last \fIdays\fP days unread.
X.LP
XOnly \fIsubscribed\fP groups that occur in the current presentation
Xsequence are rewound.  That means that if no \fIgroup\fP arguments are
Xspecified, all groups occurring in the sequence defined in the
X\fIinit\fP file will be rewound.  Otherwise, only the groups specified
Xon the argument line will be rewound.
X.LP
XWhen a group is rewound, the information about selections, partially
Xread digests etc. are discarded.  It will print notifications about
Xthis unless the \-\fBQ\fP (quiet) option is used.
X.LP
XIf the \-\fBi\fP (interactive) option is specified, \fInngoback\fP
Xwill report for each how many articles \fIcan be\fP marked unread, and
Xask for confirmation before going back in that group.
X.LP
XIf the \-\fBv\fP (verbose) option is specified, \fInngoback\fP will
Xreport how many articles are marked unread.
X.LP
XIf the \-\fBN\fP (no-update) option is specified, \fInngoback\fP will
Xperform the entire goback operation, but not update the .newsrc file.
X.LP
XIf you are not up-to-date with your news reading, you can also use
X\fBnngoback\fP to catch up to only have the last few days of news
Xwaiting to be read in the following way:
X.br
X	nn \-a0
X.br
X	nngoback 3
X.br
XThe \fBnn\fP command will mark all articles in all groups as read (answer
X.I all
Xto the catch-up question.)  The following \fBnngoback\fP will then make
Xthe last three days of news unread again.
X.LP
XExamples:
X.TP
Xnngoback 0
XMark the articles which have arrived today as unread.
X.TP
Xnngoback 1
XMark the articles which have arrived yesterday and today as unread.
X.TP
Xnngoback 6
XMark the articles which have arrived during the last week as unread.
X.LP
XYou cannot go more than 14 days back with \fInngoback\fP.
X.SH THE BACK_ACT DAEMON
XIt is a prerequisite for the use of \fInngoback\fP that the script
X\fBback_act\fP is executed at an appropriate time once (and only once)
Xevery day.  Preferably this is done by \fBcron\fP right before the
Xbacth of news for `today' is received.  \fBback_act\fP will maintain
Xcopies of the active file for the last 14 days.
X.SH FILES
X.DT
X.ta \w'~/.newsrc.goback'u+5m
X.\"ta 0 21
X~/.newsrc	The record of read articles.
X.br
X~/.newsrc.goback	The original rc file before goback.
X.br
X$db/active.\fIN\fP	The \fIN\fP days `old' active file.
X.br
X$master/back_act	Script run by cron to maintain old active files.
X.br
X.DT
X.SH SEE ALSO
Xnn(1), nncheck(1), nngrep(1), nntidy(1)
X.br
Xnnadmin(1M), nnquery(1M), nnusage(1M), nnmaster(8)
X.SH NOTES
X\fBnngoback\fP does not check the age of the `old' active files; it
Xwill blindly believe that active.0 was created today, and that
Xactive.7 is really seven days old!  Therefore, the \fIback_act\fP
Xscript should be run once and only once every day for \fInngoback\fP
Xto work properly.
X.LP
XThe days are counted relative to the time the active files were copied.
X.SH AUTHOR
XKim F. Storm, Texas Instruments A/S, Denmark
X.br
XE-mail: storm@texas.dk
END_OF_FILE
  if test 3441 -ne `wc -c <'man/nngoback.1'`; then
    echo shar: \"'man/nngoback.1'\" unpacked with wrong size!
  fi
  # end of 'man/nngoback.1'
fi
if test -f 'options.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'options.c'\"
else
  echo shar: Extracting \"'options.c'\" \(3764 characters\)
  sed "s/^X//" >'options.c' <<'END_OF_FILE'
X/*
X *	(c) Copyright 1990, Kim Fabricius Storm.  All rights reserved.
X *
X *	Generic option parsing
X */
X
X#include "config.h"
X#include "options.h"
X
Xstatic char **save_argv, *usage_mesg;
Xstatic struct option_descr *save_optd;
X
X
Xchar *program_name(av)
Xchar **av;
X{
X    char *cp;
X
X    /* skip "/path/" part of program name */
X    if (cp = strrchr(*av, '/'))
X	return cp + 1;
X    else
X	return *av;
X}
X
Xstatic dump_options(type, tail)
Xint type;
Xchar *tail;
X{
X    register struct option_descr *od;
X    int any = 0;
X
X    for (od = save_optd; od->option_letter; od++) {
X	if (od->option_type != type) continue;
X	fprintf(stderr, any ? "%c" : " -%c", od->option_letter );
X	any++;
X    }
X
X    if (any && tail && tail[0]) {
X	fprintf(stderr, "%s", tail);
X    }
X}
X
Xstatic error(message, option_letter)
Xchar *message, option_letter;
X{
X    char *prog_name = program_name(save_argv);
X
X    fprintf(stderr, "%s: ", prog_name);
X    fprintf(stderr, message, option_letter);
X    fputc('\n', stderr);
X
X    fprintf(stderr, "usage: %s", prog_name);
X
X    dump_options(1, "");
X    dump_options(2, " STR");
X    dump_options(3, " [STR]");
X    dump_options(4, " NUM");
X    dump_options(5, " [NUM]");
X
X    if (usage_mesg) fprintf(stderr, usage_mesg);
X    fputc(NL, stderr);
X
X    nn_exit(9);
X}
X
Xparse_options(ac, av, envname, options, usage)
Xint ac;
Xchar **av, *envname;
Xstruct option_descr options[];
Xchar *usage;
X{
X    register char *cp, opt;
X    register struct option_descr *od;
X    extern int atoi();
X    int files;
X    char **names;
X    char *envinit;
X
X    save_argv = av;
X    save_optd = options;
X
X    if (options == NULL) return 0;
X
X    usage_mesg = usage;
X
X    --ac;
X    names = ++av;
X    files = 0;
X
X    envinit = envname ? getenv(envname) : NULL;
X    cp = envinit;
X
X next_option:
X
X    if (envinit) {
X	while (*cp && isspace(*cp)) cp++;
X	if (*cp == '-') {
X	    cp++;
X	    goto next_option;
X	}
X	if (*cp == NUL) {
X	    envinit = NULL;
X	    goto next_option;
X	}
X    } else
X	if (cp == NULL || *cp == NUL) {
X	    if ((cp = *av++) == NULL) {
X		*names = NULL;
X		return files;
X	    }
X	    ac--;
X
X	    if (*cp != '-') {
X		*names++ = cp;
X		cp = NULL;
X		files++;
X		goto next_option;
X	    }
X
X	    cp++; /* skip - */
X	}
X
X    opt = *cp++;
X
X    for (od = options; od->option_letter; od++) {
X	if (od->option_letter != opt) continue;
X
X	switch (od->option_type) {
X
X	 case 1:	/* BOOL_OPTION */
X
X	    *((int *)(od->option_address)) = !*((int *)(od->option_address));
X	    goto next_option;
X
X	 case 2:	/* STRING_OPTION */
X	 case 3:	/* OPTIONAL_STRING */
X
X	    /* -oSTR or -o STR */
X
X	    while (*cp && isspace(*cp)) cp++;
X
X	    if (*cp == NUL) {
X		if (envinit || ac == 0) {
X		    if (od->option_type == 3) goto opt_str;
X		    error("missing string argumet to -%c", opt);
X		}
X		cp = *av++;
X		ac--;
X	    }
X
X	    if (od->option_type == 3 && *cp == '-') {
X		cp++;
X		goto opt_str;
X	    }
X
X	    *(od->option_address) = cp;
X
X	    if (envinit) {
X		while (*cp && !isspace(*cp)) cp++;
X		if (*cp) *cp++ = NUL;
X	    } else
X		cp = NULL;
X
X	    goto next_option;
X
X	 opt_str:
X	    *(od->option_address) = od->option_default;
X	    goto next_option;
X
X	 case 4:
X	 case 5:
X
X	    /* -oN or -o N */
X
X	    while (*cp && isspace(*cp)) cp++;
X
X	    if (*cp) {
X		if (!isdigit(*cp)) {
X		    if (od->option_type == 5) goto opt_int;
X		    error("non-numeric argument to -%c", opt);
X		}
X	    } else {
X		if (envinit || ac == 0 || !isdigit(**av)) {
X		    if (od->option_type == 5) goto opt_int;
X		    error("missing argument to -%c", opt);
X		}
X
X		cp = *av++;
X		ac--;
X	    }
X	    *((int *)(od->option_address)) = atoi(cp);
X	    while (isdigit(*cp)) cp++;
X	    goto next_option;
X
X	 opt_int:
X	    *((int *)(od->option_address)) = (int)(od->option_default);
X	    goto next_option;
X	}
X    }
X
X    error("unknown option '-%c'", opt);
X    /*NOTREACHED*/
X}
END_OF_FILE
  if test 3764 -ne `wc -c <'options.c'`; then
    echo shar: \"'options.c'\" unpacked with wrong size!
  fi
  # end of 'options.c'
fi
if test -f 'pack_date.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pack_date.c'\"
else
  echo shar: Extracting \"'pack_date.c'\" \(4124 characters\)
  sed "s/^X//" >'pack_date.c' <<'END_OF_FILE'
X/*
X *	(c) Copyright 1990, Kim Fabricius Storm.  All rights reserved.
X *
X *	Calculate an approximate "time_stamp" value for a date
X *	string.  The actual value is not at all critical,
X *	as long as the "ordering" is ok.
X *
X *	The result is NOT a time_t value, i.e. ctime() will
X *	not produce the original Date string.
X *
X *	The date must have format:  [...,] [D]D Mmm YY hh:mm:ss TZONE
X *
X *	Thanks to Wayne Davison for the timezone decoding code.
X */
X
X#include "config.h"
X
X/* #define DATE_TEST /* never define this !! */
X
Xstatic long wtz(h, m, c)
Xint  h, m;
Xchar c;
X{
X    if (c != 's') h--;		/* daylight savings */
X    return h*60L+m*30L;
X}
X
Xstatic long etz(h, m, c)
Xint  h, m;
Xchar c;
X{
X    if (c == 's') h++;		/* summer time */
X    return -(h*60L+m*30L);
X}
X
X#define TOLOWER(ch) (isupper(ch) ? tolower(ch) : (ch))
X
Xstatic long tzone(date)
Xregister char *date;
X{
X    char ch1, ch2, ch3, ch4;
X    long tz, wtz(), etz();
X
X    while (*date && !isalpha(*date)) date++;
X    if (*date == NUL || *date == 'G') return 0;
X
X    ch1 = TOLOWER(*date);
X    while (date++, (ch2 = TOLOWER(*date)) == '.')	/* p.s.t. -> pst */
X	;
X    while (date++, (ch3 = TOLOWER(*date)) == '.')
X	;
X    while (date++, (ch4 = TOLOWER(*date)) == '.')
X	;
X    switch (ch1) {
X     case 'n':
X	tz = wtz(3,1,0); break;		/* Newfoundland: nst */
X     case 'a':
X	if (ch2 == 'e') {
X	    tz = etz(10,0,ch4); break;	/* Australian Eastern: aest, aesst */
X	}
X	if (ch2 == 'c') {
X	    tz = etz(9,1,ch4); break;	/* Australian Central: acst, acsst */
X	}
X	if (ch2 == 'w') {
X	    tz = etz(8,1,ch4); break;	/* Australian Western: awst, awsst */
X	}
X	tz = wtz(4,0,ch2); break;	/* Atlantic: ast, adt */
X     case 'b':
X	tz = etz(1,0,0); break;		/* British summer: bst */
X     case 'c':
X	tz = wtz(6,0,ch2); break;	/* Central: cst, cdt */
X     case 'e':
X	if (ch2 == 'e') {
X	    tz = etz(0,0,ch3); break;	/* European Eastern: eet, eest */
X	}
X	tz = wtz(5,0,ch2); break;	/* Eastern: est, edt */
X     case 'g':
X	tz = etz(0,0,0); break;		/* Greenwich: gmt */
X     case 'h':
X	tz = wtz(10,0,ch2); break;	/* Hawaii: hst, hdt */
X     case 'j':
X	tz = etz(9,0,0); break;		/* Japan: jst */
X     case 'm':
X	if (ch2 == 'e') {
X	    tz = etz(1,0,ch3); break;	/* Middle European: met, mest */
X	}
X	tz = wtz(7,0,ch2); break;	/* Mountain: mst, mdt */
X     case 'p':
X	tz = wtz(8,0,ch2); break;	/* Pacific: pst, pdt */
X     case 'w':
X	tz = etz(2,0,ch3); break;	/* Western European: wet, west */
X     case 'y':
X	tz = wtz(9,0,ch2); break;	/* Yukon: yst, ydt */
X     default:
X	tz = 0; break;		/* use GMT if we can't understand it */
X    }
X
X    return tz;
X}
X
Xstatic next_int(dp)
Xchar **dp;
X{
X    register char *str = *dp;
X    register i;
X
X    while (*str && !isdigit(*str)) str++;
X
X    i = 0;
X    while (*str && isdigit(*str))
X	i = (i * 10) + *str++ - '0';
X
X    *dp = str;
X    return i;
X}
X
Xtime_stamp pack_date(date)
Xchar *date;
X{
X    register time_stamp res;
X    register int min, hour, day, mon, year;
X
X    if (date == NULL || (day = next_int(&date)) == 0) return 0;
X
X    while (*date && isspace(*date)) date++;
X
X    switch (*date++) {
X     case 'J':
X	if (*date++ == 'a') { mon = 0; break; }
X	if (*date++ == 'n') { mon = 5; break; }
X	mon = 6; break;
X     case 'F':
X	mon = 1; break;
X     case 'M':
X	if (*++date == 'r') { mon = 2; break; }
X	mon = 4; break;
X     case 'A':
X	if (*date++ == 'p') { mon = 3; break; }
X	mon = 7; break;
X     case 'S':
X	mon = 8; break;
X     case 'O':
X	mon = 9; break;
X     case 'N':
X	mon = 10; break;
X     case 'D':
X	mon = 11; break;
X     default:
X	return 0;
X    }
X
X    year = next_int(&date);
X    hour = next_int(&date);
X    min = next_int(&date);
X
X    year -= 87;	/* base is 1987 */
X    if (year < 0) year += 100;
X
X    res = (year * 12 + mon) * 31 + day - 1;
X    res *= 24 * 60;
X    res += (hour * 60) + min;
X
X    return res + tzone(date);
X}
X
X
X#ifdef DATE_TEST
X
X
Xmain()
X{
X    char buffer[128];
X    char *dp;
X    unsigned long t;
X
X    while (fgets(buffer, 128, stdin)) {
X	if (strncmp(buffer, "Date:", 5)) continue;
X
X	dp = strchr(buffer, ':');
X	if (dp == NULL) continue;
X	dp++;
X	while (isspace(*dp)) dp++;
X	t = pack_date(dp);
X	printf("%lu\t%s\n", t, dp);
X    }
X
X    exit(0);
X}
X
X#endif
END_OF_FILE
  if test 4124 -ne `wc -c <'pack_date.c'`; then
    echo shar: \"'pack_date.c'\" unpacked with wrong size!
  fi
  # end of 'pack_date.c'
fi
if test -f 'proto.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'proto.c'\"
else
  echo shar: Extracting \"'proto.c'\" \(3702 characters\)
  sed "s/^X//" >'proto.c' <<'END_OF_FILE'
X/*
X *	(c) Copyright 1990, Kim Fabricius Storm.  All rights reserved.
X *
X *	Master/slave communication and locking.
X */
X
X#include "config.h"
X#include <signal.h>
X#include <errno.h>
X#include <pwd.h>
X#include "proto.h"
X
Ximport char *master_directory, *db_directory;
X
X/*
X *	When setting a lock, we must check a little later that
X *	we really got the lock set, i.e. that another process
X *	didn't set it at the same time!
X */
X
X#define LOCK_SAFETY	5	/* seconds */
X
X/*
X *	proto_lock(program, mode)
X *
X *	Returns:
X *	-1	Not running.
X *	0	Running, no permission (PL_WAKEUP_SOFT)
X *	0	Lock set (PL_SET)
X *	1	Lock not set (PL_SET)  (another is running)
X *	1       Locked and running (PL_WAKEUP)
X *	pid	Locked and running (PL_CHECK)
X */
X
Xproto_lock(prog, command)
X{
X    FILE *m_pid;
X    int try, pid;
X    char buf[10], *any, *lock;
X
X    switch (prog) {
X     case I_AM_MASTER:
X     case I_AM_EXPIRE:
X	lock = relative(master_directory, "MPID");
X	break;
X     case I_AM_SPEW:
X	lock = relative(master_directory, "WPID");
X	break;
X#ifdef ACCOUNTING
X     case I_AM_ACCT:
X	lock = relative(db_directory, "LCK..acct");
X	break;
X#endif
X     case I_AM_NN:
X	lock = relative(nn_directory, "LOCK");
X	break;
X     default:
X	sys_error("Invalid LOCK prog");
X    }
X
X    if (command == PL_TRANSFER) {
X	m_pid = open_file(lock, OPEN_UPDATE|MUST_EXIST);
X	fprintf(m_pid, "%d\n", process_id);
X	fclose(m_pid);
X	return 1;
X    }
X
X    if (command == PL_CLEAR)
X	goto rm_lock;
X
X    try = 1;
X again:
X
X    m_pid = open_file(lock, OPEN_READ);
X    if (m_pid == NULL) goto no_lock;
X    any = fgets(buf, 10, m_pid);
X    fclose(m_pid);
X
X    if (any == NULL || (pid = atoi(buf)) <= 2) {
X	/* lock file is corrupted! */
X	if (who_am_i == I_AM_NN) goto rm_lock;
X	if (--try < 0) goto rm_lock;
X	sleep(LOCK_SAFETY);	/* maybe it is being written */
X	goto again;
X    }
X
X    if (kill(pid, command == PL_TERMINATE ? SIGHUP : SIGALRM) == 0) {
X	switch (command) {
X	 case PL_SET_QUICK:
X	    sleep(1);
X	    goto again;
X
X	 case PL_SET_WAIT:
X	 case PL_CLEAR_WAIT:
X	    sleep(30);
X	    goto again;
X
X	 case PL_CHECK:
X	    return pid;
X
X	 default:
X	    return 1;
X	}
X    }
X
X    if (command == PL_CHECK)
X	return (errno == EPERM) ? pid : -1;
X    if (command == PL_WAKEUP_SOFT)
X	return (errno == EPERM) ? 0 : -1;
X
X    /* lock file contains a non-existing process, or a process with */
X    /* wrong owner, ie. neither master or expire, so remove it */
X
X rm_lock:
X    unlink(lock);
X
X no_lock:
X    if (command != PL_SET && command != PL_SET_QUICK && command != PL_SET_WAIT)
X	return -1;
X
X    m_pid = open_file(lock, OPEN_CREATE);
X    if (m_pid == NULL) return 1;	/* failed to lock (permission?) */
X    fprintf(m_pid, "%d\n", process_id);
X    fclose(m_pid);
X
X    /* a user will not start nn twice at the exact same time! */
X    if (who_am_i == I_AM_NN || command == PL_SET_QUICK) return 0;
X
X    sleep(LOCK_SAFETY);
X
X    m_pid = open_file(lock, OPEN_READ);
X    if (m_pid == NULL) return 1; /* somebody stole the lock file */
X    any = fgets(buf, 10, m_pid);
X    fclose(m_pid);
X
X    if (any == NULL || atoi(buf) != process_id) return 1;
X
X    return 0;	/* lock is set */
X}
X
Xsend_master(command, gh, opt, arg)
Xchar command;
Xgroup_header *gh;
Xchar opt;
Xlong arg;
X{
X    FILE *gate;
X
X    gate = open_file(relative(master_directory, "GATE"), OPEN_APPEND);
X
X    if (gate == NULL) {
X	printf("Cannot send to master (check GATE file)\n");
X	return;
X    }
X
X    fprintf(gate, "%c;%ld;%c;%ld;%s %s;\n",
X	    command, gh == NULL ? -1L : gh->group_num, opt, arg,
X	    user_name(), date_time((time_t)0));
X
X    fclose(gate);
X
X    log_entry('A', "SEND %c %s %c %ld",
X		  command, gh == NULL ? "(all)" : gh->group_name, opt, arg);
X
X    if (who_am_i == I_AM_ADMIN)
X	proto_lock(I_AM_MASTER, PL_WAKEUP_SOFT);
X}
X
END_OF_FILE
  if test 3702 -ne `wc -c <'proto.c'`; then
    echo shar: \"'proto.c'\" unpacked with wrong size!
  fi
  # end of 'proto.c'
fi
echo shar: End of archive 19 \(of 22\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 22 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
