Subject:  v22i039:  NN Newsreader, release 6.4, Part04/21
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 0529026a 1e3a6086 a2dc298d 1ee726bc

Submitted-by: "Kim F. Storm" <storm@texas.dk>
Posting-number: Volume 22, Issue 39
Archive-name: nn6.4/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  global.c man/nn.1.D
# Wrapped by storm@texas.dk on Sun May  6 18:19:22 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 22)."'
if test -f 'global.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'global.c'\"
else
  echo shar: Extracting \"'global.c'\" \(12323 characters\)
  sed "s/^X//" >'global.c' <<'END_OF_FILE'
X/*
X *	(c) Copyright 1990, Kim Fabricius Storm.  All rights reserved.
X *
X *	Global declarations and auxiliary functions.
X */
X
X#include <signal.h>
X#include <errno.h>
X#include <pwd.h>
X#include "config.h"
X#include "patchlevel.h"
X
Xexport char *home_directory;
Xexport char *nn_directory;		/* ~/.nn */
Xexport char *news_directory;		/* /usr/spool/news */
Xexport char *news_lib_directory; 	/* /usr/lib/news */
Xexport char *lib_directory;		/* /usr/local/lib/nn */
Xexport char *master_directory;		/* = lib */
Xexport char *help_directory;		/* = lib/help */
Xexport char *bin_directory = BIN_DIRECTORY;
X
Xexport char *db_directory;	/* /usr/spool/nn or NEWS_DIR/.nn */
Xexport char *db_data_directory;	/* ..../DATA     or undefined    */
X
Xexport char *news_active;	/* NLIB/active or DB/ACTIVE */
X
Xexport char *pager;
X
Xexport char *log_file;			/* = lib/Log */
Xexport char *log_entry_filter = NULL;
X
Xexport char *temp_file;
X
X#ifndef TMP_DIRECTORY
X#define TMP_DIRECTORY "/usr/tmp"
X#endif
Xexport char *tmp_directory = TMP_DIRECTORY;
X
Xexport char version_id[32];
X
Xexport unsigned short user_id, group_id;
Xexport int process_id;
Xexport int who_am_i;
Xexport int dont_write_console = 0;
X
X#ifdef HAVE_MULTIGROUP
X#ifndef NGROUPS
X#include <sys/param.h>
X#endif
X#ifndef GIDSET_TYPE
X#define GIDSET_TYPE int
X#endif
Xstatic int ngroups;
Xstatic GIDSET_TYPE gidset[NGROUPS];
X
Xstatic in_grplist(gid)
XGIDSET_TYPE gid;
X{
X    int n;
X
X    for (n = 0; n < ngroups; ++n)
X	if (gidset[n] == gid) return 1;
X
X    return 0;
X}
X
X#define group_access(gpid)	in_grplist((GIDSET_TYPE)(gpid))
X#else
X#define group_access(gid)	((gid) == group_id)
X#endif
X
X/* signal handler interface */
X
Xexport int s_hangup		= 0;	/* hangup signal */
Xexport int s_keyboard		= 0;	/* keyboard interrupt */
Xexport int s_pipe		= 0;	/* broken pipe */
Xexport int s_redraw		= 0;	/* redraw signal (if job control) */
X
Xsig_type catch_hangup(n)
X{
X    signal(n, SIG_IGN);
X
X    s_hangup++;
X}
X
Xstatic sig_type catch_keyboard(n)
X{
X    s_keyboard++;
X
X#ifdef RESET_SIGNAL_WHEN_CAUGHT
X    signal(n, catch_keyboard);
X#endif
X}
X
Xstatic sig_type catch_pipe(n)
X{
X    s_pipe++;
X
X#ifdef RESET_SIGNAL_WHEN_CAUGHT
X    signal(n, catch_pipe);
X#endif
X}
X
X#ifdef HAVE_JOBCONTROL
Xstatic sig_type catch_suspend(n)
X{
X    s_redraw++;
X
X#ifdef RESET_SIGNAL_WHEN_CAUGHT
X    signal(n, catch_suspend);
X#endif
X
X    suspend_nn();
X}
X#endif
X
X
Xinit_global()
X{
X    unsigned short getuid(), getgid();
X    int getpid();
X    int suspend_nn();
X
X    if (who_am_i != I_AM_NN) {
X	signal(SIGINT,  SIG_IGN);
X	signal(SIGQUIT, SIG_IGN);
X    }
X    signal(SIGTERM, catch_hangup);
X    signal(SIGHUP,  catch_hangup);
X    signal(SIGPIPE, catch_pipe);
X    signal(SIGALRM, SIG_IGN);
X
X#ifdef SIGPWR
X    signal(SIGPWR, catch_hangup);
X#endif
X
X    sprintf(version_id, "%s.%d #%d", RELEASE, PATCHLEVEL,
X#include "update.h"
X	    );
X
X    user_id = getuid();
X
X#ifdef HAVE_MULTIGROUP
X    ngroups = getgroups(NGROUPS, gidset);	/* Get users's group set */
X    group_id = gidset[0];	/* not used, but just in case... */
X#else
X    group_id = getgid();
X#endif
X
X    process_id = getpid();
X
X#ifdef NEWS_DIRECTORY
X    news_directory = NEWS_DIRECTORY;
X#else
X    news_directory = "/usr/spool/news";
X#endif
X
X#ifdef DB_DIRECTORY
X    db_directory = DB_DIRECTORY;
X#else
X    db_directory = mk_file_name(news_directory, ".nn");
X#endif
X
X#ifdef ACCOUNTING
X    if (who_am_i == I_AM_ACCT)
X	return 0;
X#endif
X
X#ifdef DB_DATA_DIRECTORY
X    db_data_directory = DB_DATA_DIRECTORY;
X#else
X#ifdef DB_DIRECTORY
X    db_data_directory = mk_file_name(db_directory, "DATA");
X#else
X    db_data_directory = NULL;
X#endif
X#endif
X
X#ifdef NEWS_LIB_DIRECTORY
X    news_lib_directory = NEWS_LIB_DIRECTORY;
X#else
X    news_lib_directory = "/usr/lib/news";
X#endif
X
X    /* this may later be changed by nntp_check */
X    news_active = mk_file_name(news_lib_directory, "active");
X
X#ifdef CLIENT_DIRECTORY
X    lib_directory = CLIENT_DIRECTORY;
X#else
X    lib_directory = LIB_DIRECTORY;
X#endif
X
X#ifdef MASTER_DIRECTORY
X    master_directory = MASTER_DIRECTORY;
X#else
X    master_directory = lib_directory;
X#endif
X
X#ifdef HELP_DIRECTORY
X    help_directory = HELP_DIRECTORY;
X#else
X    help_directory = mk_file_name(lib_directory, "help");
X#endif
X
X#ifdef LOG_FILE
X    log_file = LOG_FILE;
X#else
X    log_file = mk_file_name(lib_directory, "Log");
X#endif
X
X    if (who_am_i == I_AM_MASTER || who_am_i == I_AM_SPEW)
X	return 0;
X
X    signal(SIGINT,  catch_keyboard);
X    signal(SIGQUIT, catch_keyboard);
X#ifdef HAVE_JOBCONTROL
X    signal(SIGTSTP, catch_suspend);
X#endif
X
X    if ((home_directory = getenv("HOME")) == NULL)
X	user_error("No HOME environment variable");
X
X    if ((pager = getenv("PAGER")) == NULL)
X	pager = DEFAULT_PAGER;
X
X    nn_directory = mk_file_name(home_directory, ".nn");
X
X    if (who_am_i != I_AM_ADMIN && !file_exist(nn_directory, "drwx")) {
X	if (who_am_i != I_AM_NN) return -1;
X	if (mkdir(nn_directory, 0755) < 0)
X	    user_error("Cannot create %s directory", nn_directory);
X	return 1;
X    }
X
X    return 0;
X}
X
Xnew_temp_file()
X{
X    static char buf[FILENAME];
X    static char *temp_dir = NULL;
X
X    if (temp_dir == NULL)
X	if ((temp_dir = getenv("TMPDIR")) == NULL)
X	    temp_dir = tmp_directory; /* just to make test above false */
X	else
X	    tmp_directory = temp_dir;
X
X    sprintf(buf, "%s/nn.XXXXXX", tmp_directory);
X    mktemp(buf);
X    temp_file = buf;
X}
X
X
XFILE *open_file(name, mode)
Xchar *name;
Xint mode;
X{
X    FILE *f;
X    int fd;
X    extern int errno;
X
X    if ((mode & DONT_CREATE) && !file_exist(name, (char *)NULL))
X	return NULL;
X
X    switch (mode & 0x0f) {
X
X     case OPEN_READ:
X
X	f = fopen(name, "r");
X	break;
X
X     case OPEN_UPDATE:
X
X/*	f = fopen(name, "r+"); 	-- not reliable on many systems (sigh) */
X
X	if ((fd = open(name, O_WRONLY)) >= 0) {
X	    if ((f = fdopen(fd, "w")) != NULL) return f;
X	    close(fd);
X	}
X
X	/* fall thru */
X
X     case OPEN_CREATE:
X
X	f = fopen(name, "w");
X	break;
X
X     case OPEN_APPEND:
X
X	f = fopen(name, "a");
X	break;
X
X     case OPEN_CREATE_RW:
X
X	f = fopen(name, "w+");	/* not safe on all systems -- beware */
X	break;
X
X     default:
X
X	sys_error("Illegal mode: open_file(%s, 0x%x)", name, mode);
X    }
X
X    if (f) {
X	if (mode & OPEN_UNLINK) unlink(name);
X	return f;
X    }
X
X    if ((mode & MUST_EXIST) == 0) return NULL;
X
X    sys_error("Cannot open file %s, mode=0x%x, errno=%d", name, mode, errno);
X
X    return NULL;
X}
X
X
X
X
X/*
X * 	relative -- concat directory name and file name
X */
X
Xchar *relative(dir, name)
Xchar *dir, *name;
X{
X    static char concat_path[FILENAME];
X
X    sprintf(concat_path, "%s/%s", dir, name);
X    return concat_path;
X}
X
X
Xchar *mk_file_name(dir, name)
Xchar *dir, *name;
X{
X    char *buf;
X
X    buf = newstr(strlen(dir) + strlen(name) + 2);
X    sprintf(buf, "%s/%s", dir, name);
X
X    return buf;
X}
X
X
Xchar *home_relative(dir)
Xchar *dir;
X{
X    if (dir) {
X	if (*dir == '/')
X	    return copy_str(dir);
X	else {
X	    if (*dir == '~' && *++dir == '/') dir++;
X	    return mk_file_name(home_directory, dir);
X	}
X    }
X    return NULL;
X}
X
X
Xchar *copy_str(str)
Xchar *str;
X{
X    char *new;
X
X    new = newstr(strlen(str) + 1);
X    if (new) strcpy(new, str);
X
X    return new;
X}
X
Xtime_t m_time(f)
XFILE *f;
X{
X    struct stat st;
X
X    if (fstat(fileno(f), &st) < 0) return 0;
X    return st.st_mtime;
X}
X
X
Xtime_t file_exist(name, mode)
Xchar *name;
Xchar *mode;
X{
X    struct stat statb;
X    extern int errno;
X
X    if (stat(name, &statb)) return 0;
X
X    if (mode == NULL) return statb.st_mtime;
X
X    while (*mode) {
X	switch (*mode++) {
X	case 'd':
X	    if ((statb.st_mode & S_IFMT) == S_IFDIR) continue;
X	    errno = ENOTDIR;
X	    return 0;
X	case 'f':
X	    if ((statb.st_mode & S_IFMT) == S_IFREG) continue;
X	    if ((statb.st_mode & S_IFMT) == 0000000) continue;
X	    if ((statb.st_mode & S_IFMT) == S_IFDIR) {
X		errno = EISDIR;
X		return 0;
X	    }
X	    break;
X	case 'r':
X	    if ((statb.st_mode & 0400) && statb.st_uid == user_id) continue;
X	    if ((statb.st_mode & 0040) && group_access(statb.st_gid)) continue;
X    	    if ((statb.st_mode & 0004)) continue;
X	    break;
X	case 'w':
X	    if ((statb.st_mode & 0200) && statb.st_uid == user_id) continue;
X	    if ((statb.st_mode & 0020) && group_access(statb.st_gid)) continue;
X    	    if ((statb.st_mode & 0002)) continue;
X	    break;
X	case 'x':
X	    if ((statb.st_mode & 0100) && statb.st_uid == user_id) continue;
X	    if ((statb.st_mode & 0010) && group_access(statb.st_gid)) continue;
X    	    if ((statb.st_mode & 0001)) continue;
X	    break;
X	}
X	errno = EACCES;
X	return 0;
X    }
X
X    /* all modes are ok */
X    return statb.st_mtime;
X}
X
X
X#ifdef HAVE_SYSLOG
X#include <syslog.h>
X#endif /* HAVE_SYSLOG */
X
X
Xstatic enter_log(type, va_tail)
Xchar type;
Xva_tdcl
X{
X    FILE *log;
X    char *msg, buf[512];
X
X    if (log_entry_filter != NULL)
X	for (msg = log_entry_filter; *msg; msg++)
X	    if (*msg == type) return 1;
X
X    msg  = va_arg1(char *);
X    vsprintf(buf, msg, va_args2toN);
X
X    /* cannot use relative: one of the args may be generated by it */
X
X    log = open_file(log_file, OPEN_APPEND);
X    if (log == NULL) return 0;
X
X    fprintf(log, "%c: %s (%s): %s\n", type,
X	    date_time((time_t)0), user_name(), buf);
X
X    fclose(log);
X    return 1;
X}
X
X/*VARARGS*/
Xsys_error(va_alist)
Xva_dcl
X{
X    char buf[512];
X    char *fmt;
X    FILE *f;
X    use_vararg;
X
X    start_vararg;
X    enter_log('E', va_args1toN);
X    end_vararg;
X
X    start_vararg;
X    fmt = va_arg1(char *);
X    vsprintf(buf, fmt, va_args2toN);
X    end_vararg;
X
X    if (who_am_i == I_AM_MASTER) {
X	if (dont_write_console) nn_exit(7);
X#ifndef HAVE_SYSLOG
X	f = open_file("/dev/console", OPEN_CREATE);
X	if (f == NULL) nn_exit(8);
X	fprintf(f, "\n\rNNMASTER FATAL ERROR\n\r%s\n\n\r", buf);
X	fclose(f);
X#else /* HAVE_SYSLOG */
X	openlog("nnmaster", LOG_CONS, LOG_DAEMON);
X	syslog(LOG_ALERT, "%s", buf);
X	closelog();
X#endif /* HAVE_SYSLOG */
X	nn_exit(7);
X    }
X    user_error("%s", buf);
X}
X
X/*VARARGS*/
Xlog_entry(va_alist)
Xva_dcl
X{
X    int type, rval;
X    use_vararg;
X
X    start_vararg;
X    type = va_arg1(int);
X    rval = enter_log(type, va_args2toN);
X    end_vararg;
X
X    return rval;
X}
X
Xchar *user_name()
X{
X    static char *user = NULL;
X    struct passwd *pw, *getpwuid();
X
X    if (who_am_i == I_AM_MASTER) return "M";
X    if (who_am_i == I_AM_EXPIRE) return "X";
X
X    if (user == NULL) {
X	pw = getpwuid((int)user_id);
X	if (pw == NULL) user = "?";
X	user = copy_str(pw->pw_name);
X    }
X
X    return user;
X}
X
Xtime_t cur_time()
X{
X    time_t t;
X
X    time(&t);
X    return t;
X}
X
Xchar *date_time(t)
Xtime_t t;
X{
X    char *str;
X
X    if (t == (time_t)0) t = cur_time();
X    str = ctime(&t);
X
X    str[16] = 0;
X    return str+4;
X}
X
Xchar *plural(n)
Xlong n;
X{
X    return n != 1 ? "s" : "";
X}
X
X/*
X *	memory management
X */
X
X/* #define MEM_DEBUG		/* trace memory usage */
X
Xstatic mem_error(t, bytes)
Xint t;
Xint32 bytes;
X{
X    char buf[200];
X
X    if (t == 1) {
X	sprintf(buf, "Alloc failed: unsigned too short to represent %ld bytes",
X		(long)bytes);
X    } else {
X	sprintf(buf, "Out of memory - cannot allocate %ld bytes",
X		(long)bytes);
X    }
X
X    sys_error(buf);
X}
X
Xchar *mem_obj(size, nelt)
Xunsigned size;
Xint32 nelt;
X{
X    unsigned n;
X    char *obj, *calloc();
X
X    n = nelt;
X    if (n != nelt) mem_error(1, nelt);
X
X    obj = calloc(n, size);
X#ifdef MEM_DEBUG
X    printf("CALLOC(%u,%u) => %lx\n", n, size, (long)obj);
X#endif
X    if (obj == NULL) mem_error(2, (int32)(size * nelt));
X    return obj;
X}
X
Xchar *mem_str(nelt)
Xint32 nelt;
X{
X    unsigned n;
X    char *obj, *malloc();
X
X    n = nelt;
X    if (n != nelt) mem_error(1, nelt);
X
X    obj = malloc(n);
X#ifdef MEM_DEBUG
X    printf("MALLOC(%u) => %lx\n", n, (long)obj);
X#endif
X    if (obj == NULL) mem_error(2, nelt);
X    return obj;
X}
X
Xchar *mem_resize(obj, size, nelt)
Xchar *obj;
Xunsigned size;
Xint32 nelt;
X{
X    unsigned n;
X    char *realloc(), *obj1;
X
X    if (obj == NULL)
X	return mem_obj(size, nelt);
X
X    nelt *= size;
X
X    n = nelt;
X    if (n != nelt) mem_error(1, nelt);
X
X    obj1 = realloc(obj, n);
X#ifdef MEM_DEBUG
X    printf("REALLOC(%lx, %u) => %lx\n", (long)obj, n, (long)obj1);
X#endif
X    if (obj1 == NULL) mem_error(2, (int32)size);
X    return obj1;
X}
X
Xmem_free(obj)
Xchar *obj;
X{
X#ifdef MEM_DEBUG
X    printf("FREE(%lx)\n", (long)obj);
X#endif
X    if (obj != NULL) free(obj);
X}
X
X#ifndef HAVE_MKDIR
X
Xmkdir(path, mode)
Xchar *path;
Xint mode;
X{
X    char command[FILENAME*2 + 20];
X
X    sprintf(command, "{ mkdir %s && chmod %o %s ; } > /dev/null 2>&1",
X	    path, mode, path);
X    return system(command) != 0 ? -1 : 0;
X}
X#endif
END_OF_FILE
  if test 12323 -ne `wc -c <'global.c'`; then
    echo shar: \"'global.c'\" unpacked with wrong size!
  fi
  # end of 'global.c'
fi
if test -f 'man/nn.1.D' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/nn.1.D'\"
else
  echo shar: Extracting \"'man/nn.1.D'\" \(39579 characters\)
  sed "s/^X//" >'man/nn.1.D' <<'END_OF_FILE'
X.\" BEGINPART D
X.SH CUSTOMIZED ARTICLE HEADER PRESENTATION
XNormally, \fInn\fP will just print a (high-lighted) single line header
Xcontaining the author, subject, and date (optional) of the article
Xwhen it is read.
X.LP
XBy setting the
X.B header-lines
Xvariable as described below, it is possible to get a more informative
Xmulti line header with optional high-lighting and underlining.
X.LP
XThe
X.B header-lines
Xvariable is set to a list of header line identifiers, and the
Xcustomized headers will then contain exactly these header lines
X\fIin the specified order\fP.
X.LP
XThe following header line identifiers are recognized in the
X.B header-lines
Xvariable:
X.LP
X.in +8n
X.ta 5m
X.\"ta 4 9
X.br
X\fBA\fP	Approved:
X.br
X\fBB\fP	Distribution:
X.br
X\fBD\fP	Date:
X.br
X\fBd\fP	Date-Received:
X.br
X\fBF\fP	From:
X.br
X\fBI\fP	Message-Id:
X.br
X\fBK\fP	Keywords:
X.br
X\fBL\fP	Lines:
X.br
X\fBN\fP	Newsgroups:
X.br
X\fBn\fP	Newsgroups:   (but only if cross posted)
X.br
X\fBO\fP	Organization:
X.br
X\fBP\fP	Path:
X.br
X\fBR\fP	Reply-To:
X.br
X\fBS\fP	Subject:
X.br
X\fBW\fP	Followup-To:
X.br
X\fBX\fP	References:
X.br
X\fBx\fP	Back-References:
X.br
X\fBY\fP	Summary:
X.in -8n
X.DT
X.LP
XPreceding the identifier with an equal sign "=" or an underscore "_"
Xwill cause the header field contents to be high-lighted or underlined.
X.LP
XIncluding an asterisk "*" in the list will produce the standard one
Xline header at that point.
X.LP
XExample:  The following setting of the
X.B header-lines
Xvariable will show the author (underlined), organization, posting
Xdate, and subject (high-lighted) when articles are read:
X.sp 0.5v
X	set header-lines _FOD=S
X.SH COMMAND LINE OPTIONS
XSome of the command line options have already been described, but
Xbelow we provide a complete list of the effect of each option by
Xshowing the equivalent
X.BR set ,
X.BR unset ,
Xor
X.B toggle
Xcommand.
X.LP
XNotice that the init files are read \fIbefore\fP the options are
Xparsed (unless you use the \-\fBI\fP option).  Therefore, the options
Xwhich are related to boolean variables set in the init file will
Xtoggle the value set there, rather than the default value.
XConsequently, the meaning of the options are also user-defined.
X.LP
XThe explanations below describe the effect related to the default
Xsetting of the variables, with the `reverse' effect in square
Xbrackets.
X.TP
X\-\fBa\fP\fIN\fP	{\fBset limit\fP \fIN\fP}
X.I Limit
Xthe maximum number of articles presented in each group to
X.I N.
XThis is useful to get up-to-date quickly if you have not
Xread news for a longer period.
X.TP
X\-\fBa0\fP
XMark
X.I all
Xunread articles as read.  See the full explanation at the beginning of
Xthis manual.
X.TP
X\-\fBB\fP	{\fBtoggle backup\fP}
XDo not [do] backup the rc file.
X.TP
X\-\fBd\fP	{\fBtoggle split\fP}
XDo not [do] split digests into separate articles.
X.TP
X\-\fBf\fP	{\fBtoggle fsort\fP}
XDo not [do] sort folders according to the subject (present the
Xarticles in a folder in the sequence in which they were saved).
X.TP
X\-\fBg\fP
XPrompt for the name of a news group or folder to be entered
X.TP
X\-\fBi\fP	{\fBtoggle case-fold-search\fP}
XNormally searches with \-\fBn\fP and \-\fBs\fP are case indenpendent.
XUsing this option, the case becomes significant.
X.TP
X\-\fBI\fP
XDo not read the init file.  This must be the first option!!
X.TP
X\-\fBI\fP\fIfile-list\fP
XSpecifies an alternate list of init files to be loaded instead of the
Xstandard global and private init files.  The list is a comma-separated
Xlist of file names.  Names which does not contain a `/' are looked for
Xin the ~/.nn directory.  An empty element in the list is interpreted
Xas the global init file.  The list of init files must
X\fInot\fP be separated from the \fB\-I\fP option by blanks, and it
Xmust be the first option.  Example:  The default behaviour corresponds
Xto using -I,init (first the global file, then the file ~/.nn/init).
X.TP
X\-\fBk\fP	{\fBtoggle kill\fP}
XDo not [do] perform automatic kill and selection of articles.
X.TP
X\-\fBl\fP\fIN\fP	{\fBset stop\fP \fIN\fP}
XStop after printing the first \fIN\fP lines of each article.
XThis is useful on slow terminals.
X.TP
X\-\fBL\fP[\fIf\fP]	{\fBset layout\fP \fIf\fP}
XSelect alternative menu layout
X.IR f
X(0 to 4).
XIf
X.I f
Xis omitted, menu layout 3 is selected.
X.TP
X\-\fBm\fP	{\fIno corresponding variable\fP}
XMerge all articles into one `meta group' instead of showing
Xthem one group at a time.  When -m is used, no articles will be marked
Xas read.
X.TP
X\-\fBn\fP\fIWORD\fP
XCollect only articles which contain the string \fIWORD\fP in the
Xsender's name (case is ignored).  If \fIWORD\fP
Xstarts with a slash `/', the rest of the argument is used as a
X\fIregular expression\fP instead of a fixed string.
X.TP
X\-\fBN\fP	{\fIno corresponding variable\fP}
XDisable updating of the rc file.  This includes not recording that
Xgroups have been read or unsubscribed to (although \fInn\fP will think
Xso until you quit).
X.TP
X\-\fBq\fP	{\fBtoggle sort\fP}
XDo not [do] sort the articles (q means quick, but it isn't
Xany quicker in practice!)
X.TP
X\-\fBQ\fP	{\fBtoggle silent\fP}
XQuiet mode - don't [do] print the logo or "No News" messages.
X.TP
X\-\fBr\fP	{\fBtoggle repeat-group-query\fP}
XMake \-\fBg\fP repeat query for a group to enter.
X.TP
X\-\fBs\fP\fIWORD\fP
XCollect only articles which contain the string
X.I WORD
Xin their subject (case is ignored).  If
X.I WORD
Xstarts with a slash `/', the rest of the argument is used as a
X\fIregular expression\fP instead of a fixed string.
X.TP
X\-\fBS\fP	{\fBtoggle repeat\fP}
XDo not [do] eliminate duplicated subject lines on menus.
X.TP
X\-\fBT\fP	{\fBtoggle time\fP}
XDo not [do] show the current time in the prompt line.
X.TP
X\-\fBw\fP[\fIN\fP]	{\fBset window\fP \fIN\fP}
XReserve \fIN\fP lines of the menu screen for a preview window.  If
X\fIN\fP is omitted, the preview window is set to 5 lines.
X.TP
X\-\fBW\fP	{\fBtoggle confirm-messages\fP}
X[Don't] Wait for confirmation on all messages.
X.TP
X\-\fBx\fP[\fIN\fP]	{\fBset old N\fP}
XPresent (or scan) all (or the last \fIN\fP) unread as well as
Xread articles.  This will
X.I never
Xmark unread articles as read.
X.TP
X\-\fBX\fP	{\fIno corresponding variable\fP}
XRead/scan unsubscribed groups also.  Most useful when looking for
Xa specific subject in all groups, e.g.
X.br
X   nn -mxX -sSubject all
X.br
X.SH MACRO DEFINITIONS
XPractically any combination of commands and key strokes can be defined
Xas a macro which can be bound to a single key in menu and/or reading mode.
X.LP
XThe macro definition must specify a sequence of commands and key
Xstrokes as if they were typed directly from the keyboard.  For
Xexample, a string specifying a file name must follow a save command.
XThis manual does not give a complete specification of all the input
Xrequired by the various commands; it is recommended to execute the
Xdesired command sequence from the keyboard prior to defining the macro
Xto get the exact requirements of each command.
X.LP
XAlthough it is possible to define temporary macros interactively using the
X.B :define
Xcommand, macro definitions are normally placed in the
X.I init
Xfile.  Macros are numbered from 0 to 100, i.e. it is possible to define
Xa total of 101 different macros (inplicit macros defined with the
X\fBmap\fP command uses internal numbers from 101 to 200).
X.LP
XTo define macro number \fIM\fP, the following construction is used
X(the line breaks are mandatory):
X.nf
X	\fBdefine\fP \fIM\fP
X		\fIbody\fP
X	\fBend\fP
X.fi
X.LP
XThe \fIbody\fP consists of a sequence of \fItokens\fP separated by
Xwhite space (blanks or newlines).  However, certain \fItokens\fP
Xcontinue to the end of the current line.
X.LP
XThe following \fItokens\fP may occur in the macro \fIbody\fP:
X.TP
X.I Comments
XEmpty lines and text following a # character (preceded by white space)
Xis ignored.
X.TP
X.I Command Names
XAny command name listed in the key mapping section can be included in
Xa macro causing that command to be invoked when the macro is executed.
X.TP
X.I Extended Commands
XAll the extended commands which can be executed through the
X.B command
Xcommand (normally bound to the : key) can also be executed in a macro.
XAn extended command starts with a colon (:) and continues to the
Xend of the current line.  Example:
X.br
X	:show groups total
X.TP
X.I Key Strokes
XA key stroke (which is normally mapped into a command depending on the
Xcurrent mode) is specified as a key name enclosed in single quotes.
XExamples (A-key, left arrow key, RETURN key):
X.br
X	'A'  'left'  '^M'
X.TP
X.I Shell Commands
XExternal commands can be invoked as part of a macro execution.  There
Xare two forms of shell command invokations available depending on
Xwhether a command \fImay\fP produce output or require user input, or
Xit is \fIguaranteed\fP to complete without input or output to the
Xterminal.  The difference is that in the latter case, \fInn\fP does
Xnot prepare the terminal to be used by another program.  When the
Xcommand completes, the screen is \fInot\fP redrawn
Xautomatically; you should use the \fBredraw\fP command to do that.
XThe tho forms are:
X.sp 0.5v
X	:!echo this command uses the terminal
X.br
X	:!!echo this command does not > /tmp/file
X.TP
X.I Strings
XInput to commands prompting for a string, e.g. a file name, can be
Xspecified in a macro as a double quoted string.  Example (save without
Xprompting for a file name):
X.br
X	\fBsave-short\fP "+$G"
X.TP
X.I Conditionals
XConditionals may occur anywhere in a macro; a conditional is evaluated
Xwhen the macro is executed, and if the condition is false \fIthe rest
Xof the current line is ignored\fP.  The following conditionals are available:
X.nf
X	\fB?menu\fP	True in menu mode
X	\fB?show\fP	True in reading mode
X	\fB?folder\fP	True when looking at a folder
X	\fB?group\fP	True when looking at a news group
X	\fB?yes\fP	Query user, true if answer is yes
X	\fB?no\fP	Query user, true if answer is no
X.fi
XExample (stop macro execution if user rejects to continue):
X.br
X	\fBprompt\fP "continue? " \fB?no break\fP
X.sp 0.5v
XIn addition to these conditionals, it is possible to test the current
Xvalue of boolean and integer variables using the following form:
X.br
X	\fB?\fP\fIvariable\fP\fB=\fP\fIvalue\fP
X.br
XThis conditional will be true (1) if the variable is an integer variable
Xwhose current value is the one specified, or (2) if the variable is a
Xboolean variable which is either \fBon\fP or \fBoff\fP.  Examples:
X.nf
X	?layout=3 :set layout 1
X	?monitor=on  break
X	?sort=off :sort age
X.fi
X.TP
X.B break
XTerminate macro execution completely.  This includes nested macros.
XExample (stop if looking at a folder):
X.br
X	\fB?folder\fP \fBbreak\fP
X.TP
X.B return
XTerminate execution of current macro.  If the current macro is called
Xfrom another macro, execution of that macro continues immediately.
X.TP
X.B input
XQuery the user for a key stroke or a string, for example a file name.
XExample (prompt the user for a file name in the usual way):
X.br
X	\fBsave-short\fP \fBinput\fP
X.TP
X.B yes
XConfirm unconditionally \fIif\fP a command requires confirmation.  It
Xis ignored if the command does not require confirmation.  Example
X(confirm creation of new files):
X.br
X	\fBsave-short\fP "+$G" \fByes\fP
X.TP
X.B no
XTerminate execution of current macro \fIif\fP a command requires
Xconfirmation; otherwise ignore it.  If neither \fByes\fP nor \fBno\fP
Xis specified when a command requires confirmation, the user must
Xanswer the question as usual \- if the user confirms the action
Xexecution continues normally; otherwise the execution of the current
Xmacro is terminated.  Example (do not create new files):
X.br
X	\fBsave-short\fP "+$L/misc" \fBno\fP
X.TP
X\fBprompt\fP \fIstring\fP
XPrint the \fIstring\fP in the prompt line (highlighted).  The string
Xmust be enclosed in double quotes.  Example:
X.br
X	\fBprompt\fP "Enter recipient name"
X.br
XWhen the macro terminates, the original prompt shown on entry to the
Xmacro will automatically be redrawn.  If this is not desireable (e.g.
Xif the macro goes from selection to reading mode), the redrawing of
Xthe prompt can be disabled by using a \fBprompt\fP command with an
Xempty \fIstring\fP ("").  Example:
X.nf
X	\fBprompt\fP "Enter reading mode?" # old prompt is saved
X	?no return # and old prompt is restored
X	read-skip       # changes the prompt
X	\fBprompt\fP "" # so forget old prompt
X.TP
X\fBecho\fP \fIstring\fP
XDisplay the \fIstring\fP in the prompt line for a short period.  Example:
X.br
X	?show \fBecho\fP "Cannot be used in reading mode" break
X.TP
X\fBputs\fP \fIstring-to-end-of-line\fP
XThe rest of the line is output directly to the terminal without
Xinterpretation.
X.TP
X\fBmacro\fP \fIM\fP
XInvoke macro number \fIM\fP.  The maximum macro nesting level is five
X(also catches macro loops).
X.LP
XI use the following macro to quickly save all the selected files in a
Xfile whose name is entered as usual.  It also works in reading mode
X(saving just the current article).
X.nf
X	\fBdefine\fP 1
X		:unset save-report
X		save-short input yes
X		?menu '+'
X		:set save-report
X	\fBend\fP
X.fi
X.SH KEY MAPPINGS
XThe descriptions of the keys and commands provided in this manual
Xreflects the default key mappings in \fInn\fP.  However, you can
Xeasily change these mappings to match your personal demands, and it is
Xalso possible to remap keys depending on the terminal in use.
XPermanent remapping of keys must be done through the
X.I init
Xfile, while temporary changes (for the duration of the current
Xinvocation of \fInn\fP) can be made with the
X.B :map
Xcommand.
X.LP
XThe binding and mapping of keys are controlled by four tables:
X.TP
X.B The multikey definition table
XThis table is used for mapping multicharacter key sequences into
Xsingle characters.  By default the table contains the mappings for the
Xfour cursor keys, and there is room for 10 user-defined multikeys.
XThe fourteen multikeys are named:
X.BR up ,
X.BR down ,
X.BR right ,
X.BR left
X(the four arrow keys), and
X.BR #0
Xthrough
X.BR #9
Xfor the user-defined keys.
X.sp 0.5v
XMultikey #\fIi\fP is defined using the following command:
X.sp 0.5v
X	\fBmap #\fP\fIi\fP \fIkey-sequence\fP
X.sp 0.5v
Xwhere the
X.I sequence
Xis a list of 7-bit character names (see below) separated by spaces.
XFor example, if the HOME key sends the sequence ESC [ H, you can
Xdefine multikey #0 to be the home key using the command:
X.sp 0.5v
X	map #0 ^[ [ H
X.TP
X.B The input key mapping table
XAll characters that are read from the keyboard will be mapped through
Xthe input mapping table.  Consequently, you can globally remap one key
Xto produce any other key value.  By default all keys are mapped into
Xthemselves.
X.sp 0.5v
XAn entry in the input key mapping table to map \fIinput-key\fP into
X\fInew-key\fP is made with the command
X.sp 0.5v
X	\fBmap key\fP \fIinput-key\fP \fInew-key\fP
X.sp 0.5v
XFor example, to make your ESC key function as
X.B interrupt
Xyou can use the command
X.sp 0.5v
X	map key ^[ ^G
X.TP
X.B The selection mode key binding table
XThis table defines for each key which command should be invoked when
Xthat key is pressed in selection mode, i.e. when the article menu is
Xshown.  The command to bind a
X.I key
Xto a
X.I command
Xin selection mode is:
X.sp 0.5v
X	\fBmap menu\fP \fIkey command\fP
X.sp 0.5v
XFor example, to have the HOME key defined as multikey #0 above bound
Xto the
X.B select
Xcommand, the following command is used:
X.sp 0.5v
X	map menu #0 select
X.sp 0.5v
XTo remap a key to select a specific article on the menu (which the `a'
Xthrough `z' keys do by default), the \fIcommand\fP must be specified
Xas `\fBarticle\fP \fIN\fP' where \fIN\fP is the entry number on the
Xmenu counted from zero (i.e. a=0, b=1, ..., z=25, 0=26, ..., 9=35).
XFor example, to map `J' to select article `j', the following
Xcommand is used:
X.sp 0.5v
X	map menu J article 9
X.TP
X.B The reading mode key binding table
XThis table defines for each key which command should be invoked when
Xthat key is pressed in reading mode, i.e. when the article text is
Xshown.  The command to bind a
X.I key
Xto a
X.I command
Xin reading mode is:
X.sp 0.5v
X	\fBmap show\fP \fIkey command\fP
X.TP
X.B Mapping keys in both modes
XUsing the pseudo-keymap `both', it is possible to map a key to a
Xcommand in both selection and reading mode at once.  For example, to
Xmap the home key to macro number 5 in both modes, the following
Xcommand can be used:
X.sp 0.5v
X	map both #0 macro 5
X.TP
X.B Aliasing
XA key can also be mapped directly to the command currently bound to
Xanother key.  Later remapping of the other key will not change the
Xmapping of the `aliased' key.  This is done using the following command:
X.sp 0.5v
X	map \fIkeymap new-key\fP \fBas\fP \fIold-key\fP
X.TP
X.B Binding macros to keys
XA previously defined macro can be bound to a key using the command:
X.sp 0.5v
X	map \fIkeymap key\fP \fBmacro\fP \fImacro-number\fP
X.TP
X.B Implicit macro definitions
XAn implicit macro can also be defined directly in connection with the
X\fBmap\fP command:
X.sp 0.5v
X	map \fIkeymap key\fP \fB(\fP
X.br
X	\fIbody\fP...
X.br
X	\fB)\fP
X.LP
XKeys and character names are specified using the following notation:
X.TP
X.I C
XA single printable character represents the key or character itself.
X.TP
X\fB^\fP\fIC\fP
XThis notation represents a control key or character.
XDEL is written as \fB^?\fP
X.TP
X\fI125\fP, \fI0175\fP, \fI0x7D\fP
XCharacters and keys can be specified by their ordinal value in
Xdecimal, octal, and hexadecimal notation.
X.TP
X\fBup\fP, \fBdown\fP, \fBright\fP, \fBleft\fP
XThese names represent the cursor keys.
X.TP
X\fB#0\fP  through  \fB#9\fP
XThese symbols represent the ten user-defined multikeys.
X.LP
XTo show the current contents of the four tables, the following
Xversions of the \fB:map\fP command are available:
X.TP
X.B :map
XShow the current mode's key bindings.
X.TP
X.B :map menu
XShow the selection mode key bindings.
X.TP
X.B :map show
XShow the reading mode key bindings.
X.TP
X.B :map #
XShow the multikey definition table.
X.TP
X.B :map key
XShow the input key mapping table.
X.SH STANDARD KEY BINDINGS
XBelow is a list of all the commands that can be bound to keys, either
Xin selection mode, in reading mode, or both.  For each command the
Xdefault command key bindings in both modes are shown.
XIf the key is not bound in one of the modes, but it can be bound, the
Xcorresponding part will just be empty.  If the command cannot be bound
Xin one of the modes, that mode will contain the word \fBnix\fP.
X.LP
X.in +8n
X.ta \w'continue-no-mark'u+5m +\w'Selection_mode'u+3m
X.\"ta 4 26 42
X.br
X\fIFunction	Selection mode	Reading mode
X.br
X\fBadvance-article\fP	\fBnix\fP 	a
X.br
X\fBadvance-group\fP	A 	A
X.br
X\fBarticle\fP \fIN\fP	a-z0-9 	\fBnix\fP
X.br
X\fBback-article\fP	\fBnix\fP 	b
X.br
X\fBback-group\fP	B 	B
X.br
X\fBcancel\fP	C 	C
X.br
X\fBcommand\fP	:  	:
X.br
X\fBcompress\fP	\fBnix\fP 	c
X.br
X\fBcontinue\fP	\fBspace\fP 	\fBspace\fP
X.br
X\fBcontinue-no-mark\fP	\fBreturn\fP 	\fBnix\fP
X.br
X\fBdecode\fP
X.br
X\fBfind\fP	= 	/
X.br
X\fBfind-next\fP	\fBnix\fP 	.
X.br
X\fBfollow\fP	F 	fF
X.br
X\fBfull-digest\fP	\fBnix\fP 	H
X.br
X\fBgoto-group\fP	G 	G
X.br
X\fBgoto-menu\fP	\fBnix\fP 	= Z
X.br
X\fBhelp\fP	? 	?
X.br
X\fBjunk-articles\fP	J 	\fBnix\fP
X.br
X\fBkill-select\fP	K 	K
X.br
X\fBlayout\fP	" 	\fBnix\fP
X.br
X\fBleave-article\fP	\fBnix\fP 	l
X.br
X\fBleave-next\fP	L 	L
X.br
X\fBline+1\fP	,  \fBdown\fP 	\fBreturn\fP
X.br
X\fBline-1\fP	/ 	\fBnix\fP
X.br
X\fBline=@\fP	\fBnix\fP 	g
X.br
X\fBmacro\fP \fIM\fP
X.br
X\fBmail\fP	M 	m M
X.br
X\fBmessage\fP	^P 	^P
X.br
X\fBnext-article\fP	\fBnix\fP 	n
X.br
X\fBnext-group\fP	N 	N
X.br
X\fBnext-subject\fP	\fBnix\fP 	k
X.br
X\fBnil\fP
X.br
X\fBoverview\fP	Y 	Y
X.br
X\fBpage+1\fP	> 	\fBnix\fP
X.br
X\fBpage+1/2\fP	\fBnix\fP 	d
X.br
X\fBpage-1\fP	< 	\fBdelete  backspace\fP
X.br
X\fBpage-1/2\fP	\fBnix\fP 	u
X.br
X\fBpage=0\fP	\fBnix\fP 	h
X.br
X\fBpage=1\fP	^ 	^
X.br
X\fBpage=$\fP	$ 	$
X.br
X\fBpatch\fP
X.br
X\fBpost\fP
X.br
X\fBpreview\fP	% 	%
X.br
X\fBprevious\fP	P 	p
X.br
X\fBprint\fP		P
X.br
X\fBquit\fP	Q 	Q
X.br
X\fBread-return\fP	Z 	\fBnix\fP
X.br
X\fBread-skip\fP	X 	X
X.br
X\fBredraw\fP	^L ^R 	^L ^R
X.br
X\fBreply\fP	R 	r R
X.br
X\fBrot13\fP	\fBnix\fP 	D
X.br
X\fBsave-body\fP	W 	w W
X.br
X\fBsave-full\fP	S 	s S
X.br
X\fBsave-short\fP	O 	o O
X.br
X\fBselect\fP	. 	\fBnix\fP
X.br
X\fBselect-auto\fP	+ 	\fBnix\fP
X.br
X\fBselect-invert\fP	@ 	\fBnix\fP
X.br
X\fBselect-range\fP	- 	\fBnix\fP
X.br
X\fBselect-subject\fP	* 	*
X.br
X\fBshell\fP	! 	!
X.br
X\fBskip-lines\fP	\fBnix\fP 	\fBtab\fP
X.br
X\fBunselect-all\fP	~ 	\fBnix\fP
X.br
X\fBunshar\fP
X.br
X\fBunsub\fP	U 	U
X.br
X\fBversion\fP	V 	V
X.in -8n
X.DT
X.LP
XSee the descriptions of the default bindings for a description of the
Xcommands.  The pseudo command
X.B nil
Xis used to
X.I unbind
Xa key.
X.SH THE INIT FILES
XThe
X.I init
Xfiles are used to customize \fInn\fP's behaviour to your personal taste.
X\fINn\fP uses two init files \- a system-wide init file located in the
Xlibrary directory, and a private init file located in the user's
X\&\fI.nn\fP directory.  The private init file is read after the global
Xinit file to allow the user to change the default setup.
X.LP
XThe init file may contain the following types of commands (and data):
X.TP
X.B Comments
XEmpty lines and lines with a # character as the first non-blank
Xcharacter are ignored.
X.TP
X.B Variable settings
XYou can
X.B set
X(or
X.BR unset )
Xall the variables described earlier to change
Xnn's behaviour permanently.  The
X.B set
Xand
X.B unset
Xcommands you can use in the init file have exactly the same format as
Xthe
X.B :set
Xand
X.B :unset
Xcommands described earlier (except that the : prefix is omitted.)
X.TP
X.B Key mappings
XYou can use all the versions of the
X.B map
Xcommand in the init file.
X.TP
X.B Macro Definitions
XYou can define sequences of commands and key strokes using the
X\fBdefine\fP...\fBend\fP construction,
Xwhich can then be
Xbound to single keys with the
X.B map
Xcommand.
X.TP
X.B Load terminal specific files
XYou can load a terminal specific file using the
X.sp 0.5v
X	\fBload\fP \fIfile\fP
X.sp 0.5v
XThe character
X.B @
Xin the
X.I file
Xwill be replaced by the terminal type defined in the TERM environment
Xvariable.  \fInn\fP silently ingores the
X.B load
Xcommand if the file does not exist (so you don't have to have a
Xspecific init file for terminals which does not require remapping).
XIf the file is not specified by an absolute pathname, it must reside
Xin your ~/.nn directory.  Examples:
X.nf
X	# load local customizations
X	load /usr/lib/nninit
X	# load personal terminal specific customizations
X	load init.@
X.fi
X.TP
X.B Change working directory of nn
XYou can use the
X.B cd
Xcommand to change the working directory whenever you enter \fInn\fP.
XExample:
X.nf
X	# Use folder directory as working directory inside \fInn\fP
X	cd ~/News
X.fi
X.TP
X.B Command groups
XThe init file can contain groups of commands which are executed under
Xspecial conditions.  The command groups are described in the section
Xon command groups below.
X.TP
X.B One or more save-files sections
XA \fBsave-files\fP section is used to assign default save files to
Xspecific groups:
X.sp 0.5v
X.nf
X	\fBsave-files\fP
X	  \fIgroup-name (pattern)\fP \fIfile-name\fP
X	  ...
X	\fBend\fP
X.fi
X.sp 0.5v
XThe group name (patterns) and save file names are specified in the
Xsame way as in the presentation sequence (see below).  Example:
X.br
X.nf
X	\fBsave-files\fP
X	  news*  +news/$L
X	  comp.sources*  /u/src/$L/
X	\fBend\fP
X.fi
X.TP
X.B The news group presentation sequence
XThe
X.I last
Xpart of the init file may specify the sequence in which you want the
Xnews groups to be presented.  This part starts with the command
X.B sequence
Xand continues to the end of the init file.
X.LP
XBoth init files may contain a presentation sequence.  In this case,
Xthe global sequence is \fIappended\fP to the private sequence.
X.SH COMMAND GROUPS
XCommand groups may only occur in the init file, and they provide a way
Xto have series of commands executed at certain points during news reading.
X.LP
XIn release 6.4, these possibilities are still rather rudimentary, and
Xa mixture of normal init file syntax and macro syntax is used
Xdepending on whether the command group is only executed on start-up or
Xseveral times during the \fInn\fP session.
X.LP
XA command group begins with the word \fBon\fP and
Xends with the word \fBend\fP.  The \fBon\fP symbol must followed by
Xone of the following identifiers denoting when the group is executed:
X.sp 0.5v
X.nf
X	\fBon\fP ...
X	commands
X	\fBend\fP
X.fi
X.sp 0.5v
XThe following command groups may be defined:
X.TP
X\fBon slow\fP
X.br
XThe commands (init file syntax) in the group are executed only if the
Xcurrent terminal output speed is less than or equal to the baud rate
Xset in the \fBslow-speed\fP variable.  This can be used to optimize
Xthe user-interface for slow terminals by setting suitable variables:
X.sp 0.5v
X.nf
X	\fBon slow\fP
X		set confirm-entry
X		set slow-mode
X		set delay-redraw
X		unset visible-bell
X		set compress
X		unset header-lines
X		set stop 5
X		set window 10
X	\fBend\fP
X.fi
X.TP
X\fBon fast\fP
X.br
XSame as \fBon slow\fP except that the commands are only executed when
Xthe terminal is running at a speed above the \fBslow-speed\fP value.
X.TP
X\fBon term\fP \fIterm-type\fP...
X.br
XThe commands are executed if one of the \fIterm-type\fP names is
Xidentical to value of the TERM environment variable.
X.TP
X\fBon host\fP \fIhost-name\fP...
X.br
XThe commands are executed if the local host's name occur in the
X\fIhost-name\fP list.
X.TP
X\fBon entry\fP [ \fIgroup list\fP ]
X.br
XThese commands (macro format!) are executed every time \fInn\fP enters a
Xnews group.  If a group list is not specified, the commands are
Xassociated with all groups which don't have its own entry macro
Xspecified in the group sequence.  Otherwise, the entry macro will be
Xassociated with the groups in the list.  The group list is specified
Xusing the meta-notations described in the presentation sequence section.
X.sp 0.5v
XThe `:set', `:unset', and `:local' commands at the beginning of the
Xcommand group are executed \fIbefore\fP \fInn\fP collects the articles
Xin the group, so it is possible to set variables like
X\fBcross-post\fP.  The other commands, and :set/:unset commands that
Xfollows a command of another type will be executed immediately
X\fIafter\fP the first menu page is presented.
X.sp 0.5v
X.nf
X	\fBon entry\fP comp.sources* alt.sources
X		:local cross-post on
X	\fBend\fP
X.fi
X.SH GROUP PRESENTATION SEQUENCE
XNews groups are normally presented in the sequence defined in the
Xsystem-wide
X.B init
Xfile in \fInn\fP's library directory.
X.LP
XYou can personalize the presentation sequence
Xby specifying an alternative sequence in the private
X.I init
Xfile.
XThe sequence in the private init file is used
X.I before
Xthe global presentation sequence, and need only
Xdescribe the deviations from the default presentation sequence.
X.LP
XThe presentation sequence must start with the word
X.br
X	\fBsequence\fP
X.br
Xfollowed by a list of the news group names in the order you want them
Xto be presented.
XThe group names must be separated by white space.
XThe sequence list must be the \fIlast\fP part of the
Xinit file (the parsing of commands from the init file stops when the
Xword \fBsequence\fP is encountered).
X.LP
XYou may use a full group name like "comp.unix.questions", or just the
Xname of a main group or subgroup, e.g. "comp" or "comp.unix".
XHowever, if "comp" precedes "comp.unix.questions" in the list, this
Xsubgroup will be placed in the normal alphabetic sequence during the
Xcollection of all the "comp" groups.
X.LP
XGroups which are not explicitly mentioned in any of the sequence files
Xwill be placed after the mentioned groups, unless `!!' is used and it
Xhas not been disabled (as described below).
X.LP
XEach group name may be followed by a file or folder name (must start
Xwith either of `/' `~' or `+') which will specify the default save file
Xfor that group (and its subgroups).  A single `+' following the group
Xname is an abbreviation for the last save file name used.
X.LP
XWhen an article is saved, the default save name will be used as the
Xinitial contents of the file name prompt for further editing.  It
Xtherefore does not need to be be a complete file name (unless you use
Xthe quick save mode).
X.LP
XEach group name may also be associated
Xwith a so-called \fBentry action\fP.  This is basically an (unnamed)
Xmacro which is invoked on entry to the group (following the same rules
Xas the `on entry' command group related to :set and :unset commands).
X.LP
XThe entry action begins with a left parenthesis `\fB(\fP' and ends
Xwith a right parenthesis `\fB)\fP' on an otherwise empty line:
X.sp 0.5v
X.nf
X	comp.sources. +src/$L/ (
X		:set cross-post
X	)
X.fi
X.sp 0.5v
XThe last entry action can be repeated by specifying an empty set of
Xparenthesis, e.g.
X.sp 0.5v
X	comp.unix. +unix ()
X.sp 0.5v
XThe entry action of a preceding group in the sequence can be
Xassociated with the current group(s) by specifying the name of the
Xgroup in the parentheses instead of the commands, e.g.
X.sp 0.5v
X	comp.unix. +unix (comp.sources.unix)
X.sp 0.5v
XA macro can also be associated with the entry action by specifying its
Xnumber in the same way as the group name above, e.g.
X.sp 0.5v
X	rec.music. +music (30)
X.sp 0.5v
XNotice that it is the
X\fIcurrent\fP definition of the macro which is associated with the
Xgroup, so if the macro is later redefined with the `:define' command,
Xit will not have any effect on the entry action.
X.LP
XGroup names can be specified using the following notations:
X.TP
Xgroup.name
XAppend the group (if it exists) to the presentation sequence list.  If
X\fBalso-subgroups\fP is set (default), all subscribed subgroups of the
Xgroup will be included as well (if there are any).  Examples: "comp",
X"comp.unix", "comp.unix.questions".  If the group does not exits (e.g.
X"comp"), the subgroups will be included even when \fBalso-subgroups\fP
Xis not set, i.e. "comp" is equivalent to "comp.".
X.TP
Xgroup.name.
XAppend the subgroups of the specified group to the presentation
Xsequence.  The group itself (if it exists) is not included.
XExamples: "comp.", "comp.unix.".
X.TP
X.group.name
XAppend the groups whose name ends with the specified name to the
Xsequence.  Example: ".test".
X.TP
Xgroup.name*
XAppend the group and its subgroups to the presentation sequence list
X(even when \fBalso-subgroups\fP is not set).  Example: "comp.unix*".
X.LP
XThe following meta notation can be used in a sequence file.  The
Xgroup.name can be specified using any of the forms described above:
X.TP
X\&! groups
XCompletely ignore the group or groups specified
Xunless they are already in the presentation sequence (i.e. has been
Xexplicitly mentioned earlier in the sequence).
X.TP
X\&!:\fIcode\fP groups
XIgnore a selection of groups based on the given \fIcode\fP letter (see
Xbelow), unless they are already included in the sequence.  Notice that
Xthese forms \fIonly\fP excludes groups from the
Xpresentation sequence, i.e. they \fIdo not\fP include the remaining
Xgroups at this point; that must be done explicitly elsewhere.
X.TP
X\&!:U groups
XIgnore unsubscribed groups, i.e. if they are neither new, nor present
Xand subscribed in \&.newsrc.
XThis is useful to ignore a whole hierarchy except for a
Xfew groups which are explicitly mentioned in \&.newsrc and still see
Xnew groups as they are created.
X.TP
X\&!:X groups
XIgnore unsubscribed \fIand\fP new groups, i.e. if they are not
Xcurrently present and subscribed in \&.newsrc.
XThis is useful to ignore a whole hierarchy except for a
Xfew groups which are explicitly mentioned in \&.newsrc.  New groups in
Xthe hierarchy are ignored unless `NEW' occurs earlier in the sequence.
X.TP
X\&!:O groups
XIgnore old groups, i.e. \fIunless\fP they are new.  This is useful to
Xignore a whole hierarchy but still see new groups which are created in
Xthe hierarchy (it might become interesting some day).  Individual
Xgroups can still be included in the sequence if they are specified
Xbefore the `!:O' entry.
X.TP
X\&!:N groups
XIgnore new groups in the hierarchy.
X.TP
X\&!!
XStop building the presentation sequence.  This eliminates all groups
Xthat are not already in the presentation sequence.
X.TP
X\fBNEW\fP
XThis is a pseudo group name which matches all \fInew\fP groups; you
Xcould place this symbol early in your presentation sequence to see new
Xgroups `out of sequence' (to attract your attention to them).
X.TP
X\fBRC\fP
XThis is a pseudo group name which matches all groups occurring in the
X.newsrc file.  It will cause the groups in .newsrc to be appended to
Xthe presentation sequence in the sequence in which they are listed in
X.newsrc.
X.TP
X\fBRC:\fP\fInumber\fP
XSimilar to the \fBRC\fP entry, but limited to the first \fInumber\fP
Xlines of the .newsrc file.  Example: RC:10 (use 10 lines of .newsrc).
X.TP
X\fBRC:\fP\fIstring\fP
XSimilar to the \fBRC\fP entry, but limited to the lines upto (and
Xincluding) the first line (i.e. group) starting with the given
X\fIstring\fP.  For example:  RC:alt.sources
X.TP
X\&< group.name
XPlace the group (and its subgroups) at the beginning of the
Xpresentation sequence.  Notice that each `<' entry will place the
Xgroup(s) at the beginning of the current sequence, i.e. < A < B < C
Xwill generate the sequence C B A.
X.TP
X\&> group.name
XPlace the group (and its subgroups) after all other groups that are
Xand will be entered into the presentation sequence.
X.TP
X\&@
XDisable the `!!' command.  This can be included in the personal
Xpresentation sequence if the global
X.B sequence
Xfile contains a !! entry (see example 1 below).
X.TP
X\&% .... %
XStarts and ends a region of the sequence where it is possible to
Xinclude groups which has been eliminated earlier.  This may be useful
Xto alter the sequence of some groups, e.g. to place comp.sources.bugs
Xafter all other source groups, the following sequence can be used:
X.sp 0.5v
X! comp.sources.bugs comp.sources* % comp.sources.bugs %
X.LP
X.sp 0.5v
X.B Example 1:
XIn a company where ordinary users only should read the local
Xnews groups, and ignore the rest (including new news groups which are
Xotherwise always subscribed to initially), can use the following
Xglobal presentation sequence:
X.sp 0.5v
X.nf
X	general
X	follow
X	! local.test
X	local
X	!!
X.fi
X.sp 0.5v
XThe "expert" users in the company must put the
X.B @
Xcommand somewhere
Xin their private sequence to avoid losing news groups which they have
Xnot explicitly mentioned in their init file.
X.sp
X.B Example 2:
XThis is the global sequence for systems with
Xheavy news addicts who setup their own sequences anyway.
X.nf
X.sp 0.5v
X	# all must read the general news first
X	< general
X.sp 0.5v
X	# test is test, and junk is junk,
X	# so it is placed at the very end
X	> test
X	> .test
X	> junk
X.sp 0.5v
X	# this is the standard sequence which everybody may
X	# change to their own liking
X	local	# our local groups
X	dk	# the Danish groups
X	eunet.general # to present it before eunet.followup
X	eunet	# the other European groups
X	comp	# the serious groups
X	news	# news on news
X	sci	# other serious groups
X	rec	# not really that important (don't quote me)
X	misc	# well, it must be somewhere
X.sp 0.5v
X	# the groups that are not listed above goes here
X.sp 0.5v
X.fi
XNotice the use of comments in the sequence where they are allowed at
Xthe end of non-empty lines as well.
X.sp
X.B Example 3:
XMy own presentation sequence (in the init file) simply
Xlists my favourite groups and the corresponding default save files:
X.nf
X.sp 0.5v
X   \fBsequence\fP
X	!:U alt*  # ignore unsubscribed alt groups
X	news.software.nn +nn
X	comp.sys.ti* +ti/$L
X	NEW  # show new groups here
X	news*
X	rec.music.synth +synth/
X	comp.emacs*,gnu.emacs +emacs/misc
X	comp.risks +risks
X	eunet.sources +src/unix/
X	comp.sources* +src/$L/
X.sp 0.5v
X.fi
XThe presentation sequence is not used when \fInn\fP is called with one or
Xmore news group names on the command line; it is thus possible to read
Xignored groups (on explicit request) wihtout changing the init file.
X(Of course, you can also use the
X.B G
Xcommand to read ignored groups).
X.SH MERGING NEWS GROUPS
XThe third example above contains the following line:
X.sp 0.5v
X	comp.emacs*,gnu.emacs +emacs/misc
X.sp 0.5v
XThis is the syntax used to \fImerge\fP groups.  When two or more
Xgroups are merged, all new articles in these groups are presented
Xtogether as if they were one group.  To merge groups, their names must
Xbe listed together in the sequence, and only separated by a single
Xcomma.  To merge the groups resulting from a single group pattern
X(e.g. comp.emacs*), the group pattern must be followed by a comma and
Xa blank (e.g. comp.emacs*, ...).
X.LP
XMerged groups are presented as the first group in the "list", and the
Xword "MERGED" will be shown after the group name.  The \fBY\fP
X{\fBoverview\fP} command will still show merged groups as individual
Xgroups, but they will be annotated with the symbol `&' on the first of
Xthe groups, and a `+' on the rest of the groups.
X.LP
XIn the current version, the concept of the \fIcurrent group\fP in
Xconnection with merged groups is a bit fuzzy.  This should only be
Xnoticeable with the \fBG\fP command, which will take the most recently
Xused group among the merged groups as the current group.  So things
Xlike \fBG = ...\fP may not always work as expected.
X.SH ENVIRONMENT
XThe following environment variables are used by \fInn\fP:
X.LP
X.BR EDITOR .
XThe editor invoked when editing replies, follow-ups, and composing
Xmail.  \fInn\fP knows about the following editors:
X\fIvi\fP, \fIded\fP, \fIGNU emacs\fP, and \fImicro-emacs\fP,
Xand will try to position the cursor on the first line following the
Xheader, i.e. after the blank line which must not be deleted!  If an
Xarticle has been included, the cursor is placed on the first line of
Xthe included text (to allow you to delete sections easily).
X.LP
X.BR LOGNAME .
XThis is taken as the login name of the current user.  It is used by
X\fInn\fP to return failed mail.  If it is not defined, \fInn\fP will
Xuse the value of USER, or if that is not defined either, \fInn\fP will
Xuse the call `who am i' to get this information.  If all attempts
Xfail, the failed mail is dropped in the bit bucket.
X.LP
X.BR PAGER .
XThis is used as the initial value of the \fBpager\fP variable.
X.LP
X.BR SHELL .
XThis is the shell which is spawned if the system cannot suspend
X\fInn\fP, and it will be used to execute the shell escapes.
X.LP
X.BR TERM .
XThe terminal type.
X.SH FILES
X.DT
X.nr tW \w'~/.nn/KILL.COMP'
X.nr tX \w'/usr/lib/nntp-server'
X.if \n(tWu>\n(tXu .nr tX \n(tWu
X.ta \n(tWu+3m
X.\"ta 0 22
X~/.newsrc	The record of read articles.
X.br
X~/.nn/select	The record of selected and seen articles.
X.br
X~/.nn/init	Personal configuration and presentation sequence.
X.br
X~/.nn/kill	The automatic kills and selections.
X.br
X~/.nn/KILL.COMP	The compiled kill file.
X.br
X~/.nn/LAST	The time stamp of the last news group we have seen.
X.br
X~/.nn/.param	Parameter file for the aux script
X.br
X$lib/init	System-wide setup and presentation sequence.
X.br
X$lib/aux	The response edit and send script.
X.br
X$lib/routes	Mapping rules for mail addresses (on non-domain systems).
X.br
X$db/*	The news data base.
X.br
X/etc/termcap	Terminal data base [BSD].
X.br
X/usr/lib/terminfo/*	Terminal data base [SysV].
X.br
X/usr/lib/nntp-server	Name of remote nntp server.
X.sp 0.5v
X.DT
XThe name $lib and $db are the directories used for the auxiliary files
Xand the news data base respectively.  Their name and location is
Xdefined at compile time.  Common choices are /usr/local/lib/nn or
X/usr/lib/news/nn for $lib and /usr/spool/nn or /usr/spool/news/.nn for
X$db.
X.SH SEE ALSO
XOther netnews documentation.
X.br
Xnncheck(1), nngoback(1), nngrep(1), nntidy(1)
X.br
Xnnadmin(1M), nnquery(1M), nnusage(1M), nnmaster(8)
X.SH AUTHOR
XKim F. Storm, Texas Instruments A/S, Denmark
X.br
XE-mail: storm@texas.dk  (but see the addresses below)
X.LP
XThe NNTP support was designed and implemented by Ren\o'\(aae' Seindal,
XInstitute of Datalogy, University of Copenhagen, Denmark.
X.LP
XBugs and fixes, suggestions, ideas, critique, etc. can be sent to
Xthe following address:
X.br
X	nn-bugs@dkuug.dk
X.LP
XThe news.software.nn group is used for discussion on all subjects
Xrelated to the nn news reader.  This includes, but is not limited to,
Xquestions, answers, ideas, hints, information from the development
Xgroup, patches, etc.
X.\" ENDPART D
END_OF_FILE
  if test 39579 -ne `wc -c <'man/nn.1.D'`; then
    echo shar: \"'man/nn.1.D'\" unpacked with wrong size!
  fi
  # end of 'man/nn.1.D'
fi
echo shar: End of archive 4 \(of 22\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 22 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
