Subject:  v22i059:  NN Newsreader, release 6.4, Patch3
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: af167553 9b54cc8a 2f7b8431 5d3d7b4f

Submitted-by: "Kim F. Storm" <storm@texas.dk>
Posting-number: Volume 22, Issue 59
Archive-name: nn6.4/patch3

	     This is an official patch to nn release 6.4
	     -------------------------------------------

			       PATCH #3

			    Priority: HIGH


These patches fix more bugs in the 6.4 release.  A major bug related
to rmgroup'ing one group resulting in another group being dropped from
the database has been solved.  The problems related to unsubscribing
to the last group in the presentation sequence are also solved.

All changes are described in the updated RELEASE_NOTES file (read that
for details about this patch).  Thanks to all who reported bugs and
provided fixes.

To apply this patch, use nn's :patch command, or run this command from
the shell in the root of the nn source tree:
	patch -p0 < this-article


++Kim Storm

*** ./LAST/active.c	Sat May  5 13:37:31 1990
--- active.c	Mon May 21 12:01:08 1990
***************
*** 16,23 ****
      int must_update;
      register flag_type old_flag;
      
!     Loop_Groups_Header(gh)
  	gh->master_flag &= ~M_VALID;
  
      while (fgets(line, 512, act)) {
  	if (copy != NULL) fputs(line, copy);
--- 16,26 ----
      int must_update;
      register flag_type old_flag;
      
!     Loop_Groups_Header(gh) {
  	gh->master_flag &= ~M_VALID;
+ 	gh->first_a_article = 0;
+ 	gh->last_a_article = 0;
+     }
  
      while (fgets(line, 512, act)) {
  	if (copy != NULL) fputs(line, copy);
*** ./LAST/admin.c	Wed May 16 11:22:33 1990
--- admin.c	Mon May 21 13:45:45 1990
***************
*** 262,267 ****
--- 262,269 ----
  
      data = ix = NULL;
  
+     if (gh->master_flag & M_IGNORE_GROUP) return 1;
+ 
      if (gh->first_db_article == (gh->last_db_article + 1)
  	&& gh->index_write_offset == 0)
  	return 1;
***************
*** 419,426 ****
      article_number first_article;
      int n;
  
!     if (init_group(gh) <= 0)
  	printf("cannot access group %s\n", gh->group_name);
  
      update_group(gh);
  
--- 421,430 ----
      article_number first_article;
      int n;
  
!     if (init_group(gh) <= 0) {
  	printf("cannot access group %s\n", gh->group_name);
+ 	return 0;
+     }
  
      update_group(gh);
  
***************
*** 515,520 ****
--- 519,525 ----
   err:
      if (data != NULL) fclose(data);
      if (ix != NULL) fclose(ix);
+     if (gh->master_flag & M_IGNORE_GROUP) return 0;
      printf("\n*** DATABASE INCONSISTENCY DETECTED - run V)alidate\n");
      return 0;
  }
*** ./LAST/answer.c	Wed May 16 11:23:33 1990
--- answer.c	Fri May 18 22:26:05 1990
***************
*** 105,112 ****
  FILE *t;
  int use_follow;
  {
!     fprintf(t, "Newsgroups: %s\n",
! 	    use_follow && news.ng_follow ? news.ng_follow : news.ng_groups);
      ed_line++;
  }
  
--- 105,116 ----
  FILE *t;
  int use_follow;
  {
!     char *ng;
! 
!     ng = use_follow && news.ng_follow ? news.ng_follow : news.ng_groups;
!     if (ng == NULL) return;
!     
!     fprintf(t, "Newsgroups: %s\n", ng);
      ed_line++;
  }
  
***************
*** 522,540 ****
  	if (command == K_BUG_REPORT) {
  	    fprintf(t, "\n=== configuration ===\n");
  	    append_file(relative(lib_directory, "conf"), t);
  	    fprintf(t, "=== end ===\n");
  	}
      }
  
-     /* empty line terminates header */
-     fputc(NL, t);
-     ed_line++;
- 
      prompt("\1WAIT\1");
  
      if (incl) {
  	register c, prevnl = 1;
  
  	while ((c = getc(art)) != EOF) {
  	    if (c == NL) {
  		putc(c, t);
--- 526,545 ----
  	if (command == K_BUG_REPORT) {
  	    fprintf(t, "\n=== configuration ===\n");
  	    append_file(relative(lib_directory, "conf"), t);
+ 	    fprintf(t, "=== variable settings ===\n");
+ 	    print_variable_config(t, 0);
  	    fprintf(t, "=== end ===\n");
  	}
      }
  
      prompt("\1WAIT\1");
  
      if (incl) {
  	register c, prevnl = 1;
  
+ 	fputc(NL, t);
+ 	ed_line++;
+ 
  	while ((c = getc(art)) != EOF) {
  	    if (c == NL) {
  		putc(c, t);
***************
*** 820,826 ****
      if (!post_no_edit)
  	prompt("\1WAIT\1");
  
!     ed_line = 3;
  #ifdef NNTP
  #ifdef NNTP_MINI_INEWS_HEADER
      mini_inews_header(t);
--- 825,831 ----
      if (!post_no_edit)
  	prompt("\1WAIT\1");
  
!     ed_line = 4;
  #ifdef NNTP
  #ifdef NNTP_MINI_INEWS_HEADER
      mini_inews_header(t);
*** ./LAST/aux.sh	Wed May 16 11:23:33 1990
--- aux.sh	Thu May 17 15:14:18 1990
***************
*** 166,171 ****
--- 166,175 ----
        { cat $WORK ; echo ; } >> $FNAME
      fi
      ;;
+ 
+   ENV)
+     set
+     ;;
    esac
  done
  
*** ./LAST/conf/s-dynix3-0.h	Wed May 16 11:23:34 1990
--- conf/s-dynix3-0.h	Thu May 17 01:05:27 1990
***************
*** 7,9 ****
--- 7,10 ----
  
  #undef HAVE_MULTIGROUP
  FILE *popen ();
+ #define FAKE_INTERRUPT
*** ./LAST/db.c	Wed May 16 11:22:35 1990
--- db.c	Mon May 21 13:22:43 1990
***************
*** 43,49 ****
      current_digest_article = 0;
  
      if (gh == NULL) return 0;
!     if (gh->master_flag & M_IGNORE_GROUP) return 0;
      if (gh == current_group) return 1;
  
      current_group = gh;
--- 43,49 ----
      current_digest_article = 0;
  
      if (gh == NULL) return 0;
! /*    if (gh->master_flag & M_IGNORE_GROUP) return 0;	/* OBS */
      if (gh == current_group) return 1;
  
      current_group = gh;
***************
*** 51,57 ****
      if (gh->group_flag & G_FOLDER) {
  	group_position = NULL;
  	group_file_name = NULL;
! 	strcpy(group_path_name, gh->group_name);
  	return 1;
      }
  
--- 51,57 ----
      if (gh->group_flag & G_FOLDER) {
  	group_position = NULL;
  	group_file_name = NULL;
! 	strcpy(group_path_name, gh->archive_file);
  	return 1;
      }
  
***************
*** 565,571 ****
      db_data_path(data_file, gh, d_or_x);
  
      if (mode == -1) {
! 	unlink(data_file);
  	f = NULL;
      } else {
  	f = open_file(data_file, (mode & ~MUST_EXIST));
--- 565,572 ----
      db_data_path(data_file, gh, d_or_x);
  
      if (mode == -1) {
! 	if (unlink(data_file) < 0 && errno != ENOTDIR && errno != ENOENT)
! 	    log_entry('E', "Cannot unlink %s (errno=%d)", data_file, errno);
  	f = NULL;
      } else {
  	f = open_file(data_file, (mode & ~MUST_EXIST));
*** ./LAST/doc/RELEASE_NOTES	Wed May 16 11:23:35 1990
--- doc/RELEASE_NOTES	Mon May 21 13:38:16 1990
***************
*** 154,160 ****
  Prog:	nn
  Title:	Remapping keys may interfere with Junk command.
  From:	Robert.Stockton@ELROND.GANDALF.CS.CMU.EDU
! 
  	Menu mode macros are invoked when the appropriate keystrokes are used
  	in the Junk command.  For example, when I rebound 'N' in menu mode to
  	a macro, it interfered with Junking of "Leave-Next" articles.
--- 154,163 ----
  Prog:	nn
  Title:	Remapping keys may interfere with Junk command.
  From:	Robert.Stockton@ELROND.GANDALF.CS.CMU.EDU
! Fixed:	Patch #3 [init.c keymap.c keymap.h group.c menu.c]
! 	(The fix involves a "shadow" keymap for the menu map keys bound to
! 	a macro.  The shadow binding is shown by :show map menu, ++Kim).
! 	
  	Menu mode macros are invoked when the appropriate keystrokes are used
  	in the Junk command.  For example, when I rebound 'N' in menu mode to
  	a macro, it interfered with Junking of "Leave-Next" articles.
***************
*** 310,316 ****
  
  Prog:	nn
  Title:	Interrupt char doesn't work (CBREAK/DYNIX)
! From:	Jaap Vermeulen <jaap@sequent.uucp>
  
  	Interrupt (^C) does not work. ^G does work.
  	'stty' tells me I'm really using interrupt (^C).
--- 313,320 ----
  
  Prog:	nn
  Title:	Interrupt char doesn't work (CBREAK/DYNIX)
! From:	Jaap Vermeulen <jaap@sequent.uucp> + fix
! Fixed:	Patch #3 [term.c global.c s-dynix3-0.h s-template.h]
  
  	Interrupt (^C) does not work. ^G does work.
  	'stty' tells me I'm really using interrupt (^C).
***************
*** 445,450 ****
--- 449,552 ----
  From:	Bill Gaines <bill%iccdev@relay.EU.net> + fix
  Fixed:	Patch #2 [Makefile]
  
+ Prog:	nn
+ Title:	Cannot unsubscribe to last group in sequence
+ From:	Peter Andersen <datpete@daimi.dk>
+ 	Chuq Von Rospach <chuq@Apple.COM>
+ 	Jaap Vermeulen <jaap%sequent@relay.EU.net>
+ Fixed:	Patch #3 [newsrc.c]
+ 
+ 	When keep_unsubscribed is false, unsubscribing to the last presented
+ 	group has no effect (it is not saved in .newsrc.)
+ 
+ Prog:	nnusage
+ Title:	Manual not updated to reflect 6.4 behaviour and options
+ From:	dmr@csli.Stanford.EDU (Daniel M. Rosenberg)
+ Fixed:	Patch #3 [nnusage.1m]
+ 
+ Prog:	nn
+ Title:	Interactive :map # doesn't work
+ From:	Jaap Vermeulen <jaap%sequent@relay.EU.net>
+ Fixed:	Patch #3 [init.c]
+ 
+ 	Interactive ':map #' is impossible.
+ 
+ Prog:	nn
+ Title:	Macros cannot be called by number using :macro N
+ From:	KFS
+ Fixed:	Patch #3 [init.c menu.c]
+ 
+ Prog:	nngrab
+ Title:	If keyword contain upper-case characters, nothing is found
+ From:	James A. Woods <jaw@riacs.edu>
+ Fixed:	Patch #3 [nngrab.sh nngrab.1 (new -c option)]
+ 
+ 	Removing the -i option on egrep and folding the subjects database
+ 	to lowercase (patch #2) breaks a command like "nngrab NeXT".
+ 
+ Prog:	nnmaster
+ Title:	From: ... (First Last - Division) is packed into "F L Division"
+ From:	olson%anchor.esd@sgi.com (Dave Olson)
+ Fixed:	Patch #3 [pack_name.c]
+ 
+ Prog:	nn
+ Title:	cursor isn't placed on the proper line in editor for :post cmd.
+ From:	arjen@mutad.uucp (Arjen Duursma) + fix
+ Fixed:	Patch #3 [answer.c]
+ 
+ Prog:	nn
+ Title:	A & B commands dump core in online manual and folders.
+ From:	Peter Radig <peter@radig.de>
+ Fixed:	Patch #3 [folder.c]
+ 
+ Prog:	nn
+ Title:	Return to menu with = in preview mode does not preserve attribute.
+ From:	Pekka Kyt|laakso <netmgr@csc.fi>
+ Fixed:	Patch #3 [menu.c]
+ 
+ Prog:	nn
+ Title:	Reply to a folder article w/o Newsgroups: header may dump core
+ From:	KFS
+ Fixed:	Patch #3 [answer.c]
+ 
+ Prog:	nn
+ Title:	default-save-file for folders is interpreted incorrectly
+ From:	Paul Petersen <petersen@uicsrd.csrd.uiuc.edu>
+ Fixed:	Patch #3 [save.c group.c variable.c nn.1 -- new folder-save-file]
+ 
+ 	Say you have a folder of +alt.sources then the default save file is
+ 	something like +/homes/petersen/News/alt.sources
+ 
+ Prog:	nnmaster
+ Title:	rmgrouped groups were not properly cleaned from the database
+ From:	chuq@Apple.COM
+ Fixed:	Patch #3 [master.c db.c group.c admin.c active.c]
+ 
+ 	Groups which are removed from the active file are not properly
+ 	removed from the database (actually another group would be removed!)
+ 
+ Prog:	nn
+ Title:	May dump core if saving to pipe and command fails.
+ From:	grady@scam.Berkeley.EDU (Steven Grady)
+ 
+ 	nn just segmentation-faulted on me when I was doing ":unshar" on
+ 	multiple articles.  The disk was full.
+ 
+ Prog:	nn
+ Title:	Unmark does not clear standout mode on HP terminals
+ From:	Bill Gaines <bill%iccdev@relay.EU.net>
+ 
+ 	On HP terminals, if you mark an article, and then unmark it, the
+ 	inverse video highlight does not go away.  You have to use "^L" to
+ 	get a correct view of which articles are marked and which are not.
+ 
+ Prog:	nn
+ Title:	extended command help causes screen to be cleared after next command
+ From:	shields@nccnat.uucp (Paul Shields)
+ 
+ 	In the command, ":? [space] pwd [return]" which prints the working
+ 	directory correctly, but then repaints the screen immediately.
+ 
  
  New features since initial 6.4.0 release
  ----------------------------------------
***************
*** 463,465 ****
--- 565,598 ----
  Title:	updated to nntp release 1.5.8 (very minor changes!)
  From:	KFS (with patches provided by Stan Barber)
  Added:	Patch #2 [inews/*]
+ 
+ Prog:	nn
+ Title:	New marked-by-<command> variables
+ From:	KFS (inspired by a request from Jeff Sparkes)
+ Added:	Patch #3 [menu.c variable.c nn.1]
+ 
+ 	The X, Z, and N can now be tuned regarding the amount of articles on
+ 	the menu pages they will mark seen when executed.
+ 
+ Prog:	nn
+ Title:	:bug command now includes modified variables
+ From:	KFS (suggested by several users)
+ Added:	Patch #3 [variable.c answer.c]
+ 
+ Prog:	nn
+ Title:	New :print-variables command
+ From:	KFS
+ Added:	Patch #3 [variable.c init.c]
+ 
+ Prog:	nn
+ Title:	Arrow keys can now be redefined (e.g. map #up ^[ O A)
+ From:	KFS (on request from Jaap Vermeulen)
+ Fixed:	Patch #3 [init.c nn.1]
+ 
+ 	I cannot define the up, down, right and left keys (in case they are
+ 	not defined in my termcap entry).  Interactive ':map #' is impossible.
+ 
+ Prog:	nn
+ Title:	New folder-save-file variable for saving from folders.
+ From:	KFS (to fix problem with default-save-file)
+ Fixed:	Patch #3 [save.c group.c variable.c nn.1]
*** ./LAST/folder.c	Thu Apr 26 14:28:28 1990
--- folder.c	Fri May 18 23:22:24 1990
***************
*** 252,260 ****
      memory_marker		mem_marker;
      group_header 		fake_group;
      int				cc_save;
      extern time_stamp pack_date();
  
!     fake_group.group_name = path;
      fake_group.group_flag = G_FOLDER | G_FAKED;
      fake_group.master_flag = 0;
      fake_group.save_file = NULL;
--- 252,265 ----
      memory_marker		mem_marker;
      group_header 		fake_group;
      int				cc_save;
+     char folder_name[FILENAME], folder_file[FILENAME];
      extern time_stamp pack_date();
  
!     strcpy(folder_name, path);
!     fake_group.group_name = folder_name;
!     if (!expand_file_name(folder_file, folder_name, 1)) return ME_NO_REDRAW;
!     fake_group.archive_file = path = folder_file;
!     fake_group.next_group = fake_group.prev_group = NULL;
      fake_group.group_flag = G_FOLDER | G_FAKED;
      fake_group.master_flag = 0;
      fake_group.save_file = NULL;
***************
*** 332,340 ****
  	msg("Not a folder (no article header)");
  	menu_cmd = ME_NO_REDRAW;
      } else {
- 	strcpy(buffer, path);
- 	fake_group.group_name = buffer;	/* save for later use */
- 
  	if (n_articles > 1) {
  	    clrdisp();
  	    prompt_line = 2;
--- 337,342 ----
***************
*** 349,355 ****
  
  	if (cancel_count) {
  	    clrdisp();
! 	    printf("Folder: %s\nFile:   %s\n\n", buffer, group_path_name);
  	    if (cancel_count == n_articles)
  		printf("Cancel all articles and remove folder? ");
  	    else
--- 351,357 ----
  
  	if (cancel_count) {
  	    clrdisp();
! 	    printf("Folder: %s\nFile:   %s\n\n", folder_name, folder_file);
  	    if (cancel_count == n_articles)
  		printf("Cancel all articles and remove folder? ");
  	    else
*** ./LAST/global.c	Wed May 16 11:23:36 1990
--- global.c	Thu May 17 00:41:24 1990
***************
*** 76,81 ****
--- 76,88 ----
  export int s_pipe		= 0;	/* broken pipe */
  export int s_redraw		= 0;	/* redraw signal (if job control) */
  
+ #ifdef FAKE_INTERRUPT
+ #include <setjmp.h>
+ 
+ export jmp_buf fake_keyb_sig;
+ export int arm_fake_keyb_sig = 0;
+ #endif
+ 
  sig_type catch_hangup(n)
  {
      signal(n, SIG_IGN);
***************
*** 85,95 ****
  
  static sig_type catch_keyboard(n)
  {
-     s_keyboard++;
- 
  #ifdef RESET_SIGNAL_WHEN_CAUGHT
      signal(n, catch_keyboard);
  #endif
  }
  
  static sig_type catch_pipe(n)
--- 92,105 ----
  
  static sig_type catch_keyboard(n)
  {
  #ifdef RESET_SIGNAL_WHEN_CAUGHT
      signal(n, catch_keyboard);
  #endif
+ #ifdef FAKE_INTERRUPT
+     if (arm_fake_keyb_sig)
+ 	longjmp(fake_keyb_sig, 1);
+ #endif
+     s_keyboard++;
  }
  
  static sig_type catch_pipe(n)
*** ./LAST/group.c	Wed May 16 11:23:37 1990
--- group.c	Mon May 21 13:22:43 1990
***************
*** 25,31 ****
  import int  merged_menu, keep_unsubscribed, keep_unsub_long;
  import int  killed_articles;
  import int  seq_cross_filtering;
! import char *default_save_file;
  
  import char delayed_msg[];
  import int32 db_read_counter;
--- 25,31 ----
  import int  merged_menu, keep_unsubscribed, keep_unsub_long;
  import int  killed_articles;
  import int  seq_cross_filtering;
! import char *default_save_file, *folder_save_file;
  
  import char delayed_msg[];
  import int32 db_read_counter;
***************
*** 191,197 ****
  
   reenter:
      for (; gh; gh = gh->merge_with) {
! 	if (init_group(gh) <= 0) {
  	    if (mg_head != NULL) continue;
  	    menu_return( ME_NEXT );
  	}
--- 191,197 ----
  
   reenter:
      for (; gh; gh = gh->merge_with) {
! 	if ((gh->master_flag & M_IGNORE_GROUP) || init_group(gh) <= 0) {
  	    if (mg_head != NULL) continue;
  	    menu_return( ME_NEXT );
  	}
***************
*** 361,367 ****
      article_number first;
      memory_marker mem_marker;
      group_header *orig_group;
!     int menu_cmd;
      extern int menu(), file_completion();
      extern article_header *get_menu_article();
      extern int get_from_macro;
--- 361,367 ----
      article_number first;
      memory_marker mem_marker;
      group_header *orig_group;
!     int menu_cmd, cmd_key;
      extern int menu(), file_completion();
      extern article_header *get_menu_article();
      extern int get_from_macro;
***************
*** 397,406 ****
  	    
  	    prompt("\1Enter\1 %s %s?  (ABGNPy) ", gh->group_name, buffer);
  	    
! 	    command = get_c();
! 	    if (command & GETC_COMMAND) goto_return(ME_REDRAW);
! 	    if (command == 'y') break;
! 	    command = menu_key_map[command];
  	}
  
  	switch (command) {
--- 397,411 ----
  	    
  	    prompt("\1Enter\1 %s %s?  (ABGNPy) ", gh->group_name, buffer);
  	    
! 	    cmd_key = get_c();
! 	    if (cmd_key & GETC_COMMAND) {
! 		command = cmd_key & ~GETC_COMMAND;
! 		if (command == K_REDRAW) goto_return(ME_REDRAW);
! 	    } else {
! 		if (cmd_key == 'y') break;
! 		command = menu_key_map[cmd_key];
! 		if (command & K_MACRO) command = orig_menu_map[cmd_key];
! 	    }
  	}
  
  	switch (command) {
***************
*** 480,490 ****
--- 485,507 ----
  	if (current_group == NULL) goto_return(ME_NO_REDRAW);
  	if ((current_group->group_flag & G_FOLDER) == 0) {
  	    if (!ah) {
+ #ifdef NNTP
+ 		if (use_nntp) {
+ 		    msg("Can only use G%% in reading mode");
+ 		    goto_return(ME_NO_REDRAW);
+ 		}
+ #endif
  		prompt("\1READ\1");
  		if ((ah = get_menu_article()) == NULL)
  		    goto_return(ME_NO_REDRAW);
  	    }
  	    if ((ah->flag & A_DIGEST) == 0) {
+ #ifdef NNTP
+ 		if (use_nntp) {
+ 		    answer = nntp_get_filename(ah->a_number, current_group);
+ 		    goto get_folder;
+ 		}
+ #endif
  		*group_file_name = NUL;
  		sprintf(fbuffer, "%s%ld", group_path_name, ah->a_number);
  		answer = fbuffer;
***************
*** 686,694 ****
   get_folder:
      m_endinput();
      if (strcmp(answer, "+") == 0)
! 	answer = (gh && gh->save_file != NULL) ? gh->save_file : default_save_file;
!     if (!expand_file_name(buffer, answer, 1)) goto_return (ME_NO_REDRAW);
!     menu_cmd = folder_menu(buffer);
      gh = NULL;
      goto goto_exit;
  
--- 703,711 ----
   get_folder:
      m_endinput();
      if (strcmp(answer, "+") == 0)
! 	answer = (gh && gh->save_file != NULL) ? gh->save_file : 
! 	    (gh->group_flag & G_FOLDER) ? folder_save_file : default_save_file;
!     menu_cmd = folder_menu(answer);
      gh = NULL;
      goto goto_exit;
  
*** ./LAST/init.c	Wed May 16 11:22:39 1990
--- init.c	Fri May 18 11:51:11 1990
***************
*** 245,250 ****
--- 245,251 ----
      "local",			5,	3,
      "man",			3,	0,
      "map",			3,	-1,
+     "map #",			5,	-2,
      "map both",			8,	4,
      "map key",			7,	0,
      "map menu",			8,	4,
***************
*** 252,258 ****
      "mkdir",			5,	1,
      "patch",			5,	0, /* QUICK HACK */
      "post",			4,	0, /* QUICK HACK */
!     "print",			5,	0, /* QUICK HACK */
      "pwd",			3,	0,
      "rmail",			5,	0,
      "set",			3,	3,
--- 253,260 ----
      "mkdir",			5,	1,
      "patch",			5,	0, /* QUICK HACK */
      "post",			4,	0, /* QUICK HACK */
!     "print",			5,	-3, /* QUICK HACK */
!     "print-variables",		15,	0,
      "pwd",			3,	0,
      "rmail",			5,	0,
      "set",			3,	3,
***************
*** 315,321 ****
  	other_compl = NULL;
  
  	for (; alt->alt_name; alt++) {
! 	    if (len <= alt->alt_len || head[alt->alt_len] != SP) continue;
  	    index = strncmp(alt->alt_name, head, alt->alt_len);
  	    if (index < 0) continue;
  	    if (index > 0) break;
--- 317,328 ----
  	other_compl = NULL;
  
  	for (; alt->alt_name; alt++) {
! 	    if (len <= alt->alt_len) continue;
! 	    if (head[alt->alt_len] != SP) {
! 		if (alt->alt_type != -2) continue;
! 		if (strncmp(alt->alt_name, head, alt->alt_len)) continue;
! 		return -1;
! 	    }
  	    index = strncmp(alt->alt_name, head, alt->alt_len);
  	    if (index < 0) continue;
  	    if (index > 0) break;
***************
*** 402,407 ****
--- 409,419 ----
  	    if (list_completion(p) == 0) break;
  	    temp = help_alt->alt_len;
  
+ 	    if (help_alt->alt_type == -3) {
+ 		help_alt++;
+ 		continue;
+ 	    }
+ 	
  	    do help_alt++;
  	    while ((q = help_alt->alt_name) && help_alt->alt_len > temp &&
  		   strncmp(p, q, temp) == 0);
***************
*** 420,435 ****
  	if (index > 0) break;
  
  	p = alt->alt_name;
! 	sprintf(tail, "%s ", p + len);
  	temp = alt->alt_len;
  
  	do alt++;
! 	while ((q = alt->alt_name) && alt->alt_len > temp &&
  	       strncmp(p, q, temp) == 0);
  
  	return 1;
      }
!     return 0;
  }
  
  static print_debug_info()
--- 432,459 ----
  	if (index > 0) break;
  
  	p = alt->alt_name;
! 	sprintf(tail, "%s%s", p + len, alt->alt_type <= -2 ? "" : " ");
  	temp = alt->alt_len;
  
+ 	if (alt->alt_type == -3) {
+ 	    alt++;
+ 	    return 1;
+ 	}
+ 	
  	do alt++;
! 	while ((q = alt->alt_name) && alt->alt_len > temp && 
  	       strncmp(p, q, temp) == 0);
  
  	return 1;
      }
! 
!     cmd_completion(head, len);
!     if (temp = cmd_completion((char *)NULL, 0)) {
! 	other_compl = cmd_completion;
! 	tail = NULL;
!     }
! 
!     return temp;
  }
  
  static print_debug_info()
***************
*** 574,579 ****
--- 598,604 ----
  FILE *initf;
  {
      int code, map_menu, map_show, must_redraw = 0;
+     key_type bind_to;
  
      SWITCH( argv(1) ) {
  
***************
*** 587,600 ****
  	    key_type multi_buffer[16], *mb;
  	    int i;
  
! 	    if (!isdigit(argv(1)[1])) break;
  
  	    for (i = 2, mb = multi_buffer; argv(i); i++)
  		*mb++ = parse_key(argv(i));
  	    *mb = NUL;
  
! 	    enter_multi_key(K_function(argv(1)[1] - '0'),
! 			    (key_type *)copy_str((char *)multi_buffer));
  
  	    goto out;
  	}
--- 612,630 ----
  	    key_type multi_buffer[16], *mb;
  	    int i;
  
! 	    if (argv(1)[1] == NUL) break;
! 	    if (isdigit(argv(1)[1])) 
! 		bind_to = K_function(argv(1)[1] - '0');
! 	    else {
! 		bind_to = parse_key(argv(1) + 1);
! 		if (bind_to <= 0x80) break; /* not pretty! */
! 	    }
  
  	    for (i = 2, mb = multi_buffer; argv(i); i++)
  		*mb++ = parse_key(argv(i));
  	    *mb = NUL;
  
! 	    enter_multi_key(bind_to, (key_type *)copy_str((char *)multi_buffer));
  
  	    goto out;
  	}
***************
*** 638,644 ****
  		    goto mac_err;
  
  	    if (code != K_INVALID) {
! 		menu_key_map[parse_key(argv(2))] = code;
  		if (!map_show) goto out;
  	    }
  	}
--- 668,677 ----
  		    goto mac_err;
  
  	    if (code != K_INVALID) {
! 		bind_to = parse_key(argv(2));
! 		if (code & K_MACRO && orig_menu_map[bind_to] == 0)
! 		    orig_menu_map[bind_to] = menu_key_map[bind_to];
! 		menu_key_map[bind_to] = code;
  		if (!map_show) goto out;
  	    }
  	}
***************
*** 906,913 ****
  
  	    alt_cmd_key = lookup_command(sw_string,
  				 in_menu_mode ? K_ONLY_MENU : K_ONLY_MORE);
! 	    if (alt_cmd_key != K_INVALID && alt_cmd_key != K_HELP)
  		return AC_KEYCMD;
  	}
  
  	CASE( "q" ) {
--- 939,951 ----
  
  	    alt_cmd_key = lookup_command(sw_string,
  				 in_menu_mode ? K_ONLY_MENU : K_ONLY_MORE);
! 	    if (alt_cmd_key != K_INVALID && alt_cmd_key != K_HELP) {
! 		if (alt_cmd_key == K_MACRO) {
! 		    if (ARGTAIL == NULL) break;
! 		    alt_cmd_key |= atoi(ARGTAIL);
! 		}
  		return AC_KEYCMD;
+ 	    }
  	}
  
  	CASE( "q" ) {
***************
*** 1033,1038 ****
--- 1071,1087 ----
  	    return AC_REDRAW;
  	}
  
+ 	CASE( "print-variables" ) {
+ 	    import char printer[];
+ 	    FILE *p;
+ 	    if (p = popen(ARGTAIL ? ARGTAIL : printer, "w")) {
+ 		print_variable_config(p, 1);
+ 		pclose(p);
+ 		msg("Variables printed");
+ 	    }
+ 	    break;
+ 	}
+ 	
  	CASE( "pwd" ) {
  	    FILE *p = popen("exec pwd", "r");
  	    char dir[FILENAME];
*** ./LAST/keymap.c	Fri Apr 27 21:30:58 1990
--- keymap.c	Thu May 17 11:19:11 1990
***************
*** 410,415 ****
--- 410,416 ----
  /* #9  */	K_UNBOUND
  };
  
+ export int orig_menu_map[KEY_MAP_SIZE];	/* initially empty */
  
  
  static struct command_name_map {
***************
*** 797,802 ****
--- 798,805 ----
  	if (map[c] & K_MACRO) {
  	    if (pg_next() < 0) goto out;
  	    printf("macro %d: %s", (map[c] & ~K_MACRO), key_name(c));
+ 	    if (map == menu_key_map && orig_menu_map[c] != K_UNBOUND) 
+ 		printf(" (%s)", command_name(orig_menu_map[c]));
  	}
  
   out:
*** ./LAST/keymap.h	Thu Apr 26 21:10:15 1990
--- keymap.h	Thu May 17 11:19:12 1990
***************
*** 123,128 ****
--- 123,129 ----
  
  extern int menu_key_map[];
  extern int more_key_map[];
+ extern int orig_menu_map[];
  
  extern key_type global_key_map[];
  
*** ./LAST/man/nn.1.A	Wed May 16 11:23:42 1990
--- man/nn.1.A	Mon May 21 17:18:31 1990
***************
*** 598,607 ****
  articles have been read, return to selection mode in the
  .I current
  group.  It will mark \fIselected\fP articles \fIread\fP as they are
! read, but \fIunread\fP articles are not changed.
  .TP
  \&\fBX\fP	{\fBread-skip\fP}
! Mark all \fIunread\fP articles \fIseen\fP on all menu pages, and enter
  reading mode \fIimmediately\fP with the currently selected articles.
  As the selected articles are read, they are marked \fIread\fP.  When
  all selected articles have been read, \fInn\fP will enter selection
--- 598,609 ----
  articles have been read, return to selection mode in the
  .I current
  group.  It will mark \fIselected\fP articles \fIread\fP as they are
! read, but \fIunread\fP articles are not normally changed (can be
! controlled with the variable \fBmarked-by-read-return\fP.)
  .TP
  \&\fBX\fP	{\fBread-skip\fP}
! Mark all \fIunmarked\fP articles \fIseen\fP on all menu pages (or the
! pages defined by the \fBmarked-by-read-skip\fP variable), and enter
  reading mode \fIimmediately\fP with the currently selected articles.
  As the selected articles are read, they are marked \fIread\fP.  When
  all selected articles have been read, \fInn\fP will enter selection
***************
*** 614,623 ****
  for later, you can use the following commands which will only mark
  \fIseen\fP and \fIread\fP articles as read.  Currently selected
  articles will still be selected the next time you enter the group.
! None of these commands will change any attributes themselves.
  .TP
  \&\fBN\fP	{\fBnext-group\fP}
! Go forward to the next group in the presentation sequence.
  .TP
  \&\fBP\fP	{\fBprevious\fP}
  Go back to the previous group.  This command will enter selection mode
--- 616,627 ----
  for later, you can use the following commands which will only mark
  \fIseen\fP and \fIread\fP articles as read.  Currently selected
  articles will still be selected the next time you enter the group.
! None of these commands will change any attributes themselves (by default).
  .TP
  \&\fBN\fP	{\fBnext-group\fP}
! Go forward to the next group in the presentation sequence.  If the
! variable \fBmarked-by-next-group\fP is set articles on the menu can
! optionally be marked \fIseen\fP
  .TP
  \&\fBP\fP	{\fBprevious\fP}
  Go back to the previous group.  This command will enter selection mode
***************
*** 653,661 ****
  command.
  .LP
  \fBRelated variables\fP:
! auto-preview-mode, auto-select-subject, case-fold-search,
! confirm-auto-quit, confirm-entry,
! auto-junk-seen, confirm-junk-seen, retain-seen-status, select-on-sender.
  .SH THE JUNK-ARTICLES AND LEAVE-NEXT COMMANDS
  The \fBJ\fP {\fBjunk-articles\fP} command is a very flexible command
  which can perform all sorts of attribute changes, either on individual
--- 657,666 ----
  command.
  .LP
  \fBRelated variables\fP:
! auto-junk-seen, auto-preview-mode, auto-select-subject, case-fold-search,
! confirm-auto-quit, confirm-entry, confirm-junk-seen,
! marked-by-next-group, marked-by-read-return, marked-by-read-skip,
! retain-seen-status, select-on-sender.
  .SH THE JUNK-ARTICLES AND LEAVE-NEXT COMMANDS
  The \fBJ\fP {\fBjunk-articles\fP} command is a very flexible command
  which can perform all sorts of attribute changes, either on individual
***************
*** 1104,1110 ****
  .LP
  \fBRelated variables\fP:
  confirm-append, confirm-create, decode-header-file,
! decode-skip-prefix, default-save-file,
  edit-patch-command, edit-print-command, edit-unshar-command, folder,
  mail-format, mmdf-format, patch-command, printer, quick-save,
  save-counter, save-counter-offset, save-report,
--- 1109,1115 ----
  .LP
  \fBRelated variables\fP:
  confirm-append, confirm-create, decode-header-file,
! decode-skip-prefix, default-save-file, folder-save-file,
  edit-patch-command, edit-print-command, edit-unshar-command, folder,
  mail-format, mmdf-format, patch-command, printer, quick-save,
  save-counter, save-counter-offset, save-report,
*** ./LAST/man/nn.1.B	Wed May 16 11:23:44 1990
--- man/nn.1.B	Mon May 21 17:18:31 1990
***************
*** 18,24 ****
  \fB+\fP
  A single plus is replaced by the expansion of the file name contained in the
  .B default-save-file
! variable.
  .TP
  \fB~/\fP\fIfile\fP
  The
--- 18,24 ----
  \fB+\fP
  A single plus is replaced by the expansion of the file name contained in the
  .B default-save-file
! variable (or by \fBfolder-save-file\fP when saving from a folder).
  .TP
  \fB~/\fP\fIfile\fP
  The
***************
*** 85,91 ****
  next in part3.shar, and so on).
  .LP
  \fBRelated variables\fP:
! default-save-file, folder, save-counter, save-counter-offset.
  .SH FILE AND GROUP NAME COMPLETION
  When entering a file name or a news group name, a simple
  .B completion
--- 85,91 ----
  next in part3.shar, and so on).
  .LP
  \fBRelated variables\fP:
! default-save-file, folder, folder-save-file, save-counter, save-counter-offset.
  .SH FILE AND GROUP NAME COMPLETION
  When entering a file name or a news group name, a simple
  .B completion
***************
*** 423,429 ****
  .fi
  .LP
  \fBRelated variables\fP:
! case-fold-search, default-save-file
  .SH AUTOMATIC KILL AND SELECTION
  When there is a subject or an author which you are either very
  interested in, or find completely uninteresting, you can easily
--- 423,429 ----
  .fi
  .LP
  \fBRelated variables\fP:
! case-fold-search, default-save-file, folder-save-file
  .SH AUTOMATIC KILL AND SELECTION
  When there is a subject or an author which you are either very
  interested in, or find completely uninteresting, you can easily
*** ./LAST/man/nn.1.C	Wed May 16 11:23:46 1990
--- man/nn.1.C	Mon May 21 17:18:31 1990
***************
*** 342,350 ****
  the subject for the specified period.
  .TP
  \fBdefault-save-file\fP \fIfile\fP	(string, default +$F)
! The default save file used in quick save mode.  It can also be
! specified using the abbreviation "+" as the file name in normal save
! mode.
  .TP
  \fBdelay-redraw\fP		(boolean, default false)
  Normally, \fInn\fP will redraw the screen after extended
--- 342,352 ----
  the subject for the specified period.
  .TP
  \fBdefault-save-file\fP \fIfile\fP	(string, default +$F)
! The default save file used when saving articles in news groups where
! no save file has been specified in the init file (either in a
! \fBsave-files\fP section or in the presentation sequence).
! It can also be specified using the abbreviation "+" as the file name
! when prompted for a file name even in groups with their own save file.
  .TP
  \fBdelay-redraw\fP		(boolean, default false)
  Normally, \fInn\fP will redraw the screen after extended
***************
*** 425,430 ****
--- 427,435 ----
  .I init
  file.
  .TP
+ \fBfolder-save-file\fP \fIfile\fP	(string, default not set)
+ The default save file used when saving articles \fIfrom\fP a folder.
+ .TP
  \fBfsort\fP		(boolean, default true)
  When set, folders are sorted alphabetically according to the subject
  (and age).
***************
*** 523,529 ****
  sent from \fInn\fP using the \fBreply\fP and \fBmail\fP commands.  For
  example:
  .br
!    set mail-header Reply-To: storm@texas.dk
  .br
  .TP
  \fBmail-record\fP \fIfile\fP	(string, default not set)
--- 528,534 ----
  sent from \fInn\fP using the \fBreply\fP and \fBmail\fP commands.  For
  example:
  .br
!    set mail-header Reply-To: storm@texas.dk;Organization: TI - DK
  .br
  .TP
  \fBmail-record\fP \fIfile\fP	(string, default not set)
***************
*** 549,554 ****
--- 554,582 ----
  program.  Otherwise, the file containing the message will be given as
  the first (and only) argument to the \fBmailer\fP command.
  .TP
+ \fBmarked-by-next-group\fP \fIN\fP	(integer, default 0)
+ Specifies the amount of (unmarked) articles on the menu marked
+ \fIseen\fP by the \fBN\fP {\fBnext-group\fP} command in selection
+ mode.  See \fBmarked-by-read-skip\fP for possible values of \fIN\fP.
+ .TP
+ \fBmarked-by-read-return\fP \fIN\fP	(integer, default 0)
+ Specifies the amount of (unmarked) articles on the menu marked
+ \fIseen\fP by the \fBZ\fP {\fBread-return\fP} command in selection
+ mode.  See \fBmarked-by-read-skip\fP for possible values of \fIN\fP.
+ .TP
+ \fBmarked-by-read-skip\fP \fIN\fP	(integer, default 4)
+ Specifies the amount of (unmarked) articles on the menu marked
+ \fIseen\fP by the \fBX\fP {\fBread-skip\fP} command in selection mode.
+ The following values of \fIN\fP are recognized:
+ .br
+ .nf
+ 	0:  No articles are marked seen
+ 	1:  Current page is marked seen
+ 	2:  Previous pages are marked seen
+ 	3:  Previous and current pages are marked seen
+ 	4:  All pages are marked seen
+ .fi
+ .TP
  \fBmark-overlap\fP	(boolean, default false)
  When set, \fInn\fP will draw a line (using the underline capabilities
  of the terminal if possible) to indicate the end of the overlap (see the
***************
*** 602,608 ****
  The \fIheaders\fP string specifies one or more extra header lines
  (separated by semi-colons `;') which are added to the header of
  articles posted from \fInn\fP using the \fBfollow\fP and \fBpost\fP
! commands.
  .TP
  \fBnews-record\fP \fIfile\fP	(string, default not set)
  Save file for follow-ups and postings.  Same rules and format as the
--- 630,636 ----
  The \fIheaders\fP string specifies one or more extra header lines
  (separated by semi-colons `;') which are added to the header of
  articles posted from \fInn\fP using the \fBfollow\fP and \fBpost\fP
! commands.  See \fBmail-header\fP for an example.
  .TP
  \fBnews-record\fP \fIfile\fP	(string, default not set)
  Save file for follow-ups and postings.  Same rules and format as the
***************
*** 919,925 ****
  \fBsuggest-default-save\fP	(boolean, default true)
  When set, \fInn\fP will present the \fBdefault-save-file\fP when
  prompting for a save file name in a group without a specific save
! file.  When not set, no file name is presented, and to use the default
  save file, a single + must be specified.
  .TP
  \fBtidy-newsrc\fP		(boolean, default false)
--- 947,954 ----
  \fBsuggest-default-save\fP	(boolean, default true)
  When set, \fInn\fP will present the \fBdefault-save-file\fP when
  prompting for a save file name in a group without a specific save
! file, or \fBfolder-save-file\fP when saving from a folder.  When not
! set, no file name is presented, and to use the default
  save file, a single + must be specified.
  .TP
  \fBtidy-newsrc\fP		(boolean, default false)
*** ./LAST/man/nn.1.D	Wed May 16 11:23:47 1990
--- man/nn.1.D	Mon May 21 17:18:31 1990
***************
*** 423,429 ****
  .BR #9
  for the user-defined keys.
  .sp 0.5v
! Multikey #\fIi\fP is defined using the following command:
  .sp 0.5v
  	\fBmap #\fP\fIi\fP \fIkey-sequence\fP
  .sp 0.5v
--- 423,430 ----
  .BR #9
  for the user-defined keys.
  .sp 0.5v
! Multikey #\fIi\fP (where \fIi\fP is a digit or an arrow key name) is
! defined using the following command:
  .sp 0.5v
  	\fBmap #\fP\fIi\fP \fIkey-sequence\fP
  .sp 0.5v
*** ./LAST/man/nngrab.1	Wed May 16 11:23:50 1990
--- man/nngrab.1	Fri May 18 20:22:23 1990
***************
*** 3,10 ****
  .SH NAME
  nngrab \- news retrieval by keyword (nn)
  .SH SYNOPSIS
! .B nngrab
! .I keyword
  .SH DESCRIPTION
  .I nngrab
  invokes \fInn\fP
--- 3,9 ----
  .SH NAME
  nngrab \- news retrieval by keyword (nn)
  .SH SYNOPSIS
! \fBnngrab\fP [ \-\fBc\fP ] \fIkeyword\fP
  .SH DESCRIPTION
  .I nngrab
  invokes \fInn\fP
***************
*** 20,26 ****
  .sp 0.5v
  will retrieve items concerning Nikola Tesla.
  .LP
! Keyword case is ignored, and the \fIkeyword\fP can be a regular
  expressions (escaped to avoid conflicts with the shell).  For example,
  .sp 0.5v
  	nngrab "n.*tesla"
--- 19,26 ----
  .sp 0.5v
  will retrieve items concerning Nikola Tesla.
  .LP
! Keyword case is ignored unless \-\fBc\fP is specified, and the
! \fIkeyword\fP can be a regular
  expressions (escaped to avoid conflicts with the shell).  For example,
  .sp 0.5v
  	nngrab "n.*tesla"
*** ./LAST/man/nnusage.1m	Sat Mar 31 23:12:58 1990
--- man/nnusage.1m	Fri May 18 23:22:23 1990
***************
*** 5,21 ****
  nnusage \- display \fInn\fP usage statistics
  .SH SYNOPSIS
  .B nnusage
! [ -t ]
  .SH DESCRIPTION
  .B nnusage
  will extract the usage entries from the log file and calculate the
! total usage time for each \fInn\fP user.
  .LP
! Without options, the output will be sorted according to user names.
  .LP
- With the \-t option, \fInnusage\fP will list the users ordered after
- the total usage time.
- .LP
  Since it is possible to
  suspend
  \fInn\fP, or leave the terminal while \fInn\fP is active, \fInn\fP
--- 5,21 ----
  nnusage \- display \fInn\fP usage statistics
  .SH SYNOPSIS
  .B nnusage
! [ \-\fBat\fP ]
  .SH DESCRIPTION
  .B nnusage
  will extract the usage entries from the log file and calculate the
! total usage time for the current user, or for all \fInn\fP users if
! \-\fBa\fP is specified.
  .LP
! When \-\fBt\fP is used with the \-\fBa\fP option, \fInnusage\fP will
! list the users ordered after the total usage time.  Otherwise, the
! output will be sorted according to user names.
  .LP
  Since it is possible to
  suspend
  \fInn\fP, or leave the terminal while \fInn\fP is active, \fInn\fP
***************
*** 30,37 ****
  .SH SEE ALSO
  nn(1), nncheck(1), nngoback(1), nngrep(1), nntidy(1)
  .br
! nnadmin(1M), nnquery(1M), nnmaster(8)
  .SH NOTES
  The \fInn\fP package must have been compiled with the STATISTICS
  option turned on to produce the usage entries in the log file.
  .LP
--- 30,40 ----
  .SH SEE ALSO
  nn(1), nncheck(1), nngoback(1), nngrep(1), nntidy(1)
  .br
! nnacct(1m), nnadmin(1M), nnquery(1M), nnmaster(8)
  .SH NOTES
+ If \fInn\fP is compiled with ACCOUNTING turned on, then calls to
+ \fInnusage\fP are converted into equivalent calls to \fInnacct\fP.
+ .LP
  The \fInn\fP package must have been compiled with the STATISTICS
  option turned on to produce the usage entries in the log file.
  .LP
*** ./LAST/master.c	Wed May 16 11:22:45 1990
--- master.c	Mon May 21 13:22:43 1990
***************
*** 171,183 ****
      gh->first_db_article = 0;
      gh->last_db_article = 0;
  
!     if (gh->data_write_offset > (off_t)0) {
! 	gh->data_write_offset = (off_t)0;
  	(void)open_data_file(gh, 'd', -1);
-     }
-     
-     if (gh->index_write_offset) {
- 	gh->index_write_offset = (off_t)0;
  	(void)open_data_file(gh, 'x', -1);
      }
      
--- 171,181 ----
      gh->first_db_article = 0;
      gh->last_db_article = 0;
  
!     gh->data_write_offset = (off_t)0;
!     gh->index_write_offset = (off_t)0;
! 
!     if (init_group(gh)) {
  	(void)open_data_file(gh, 'd', -1);
  	(void)open_data_file(gh, 'x', -1);
      }
      
***************
*** 438,445 ****
  	next_g->next_group = gh;
  	next_g = gh;
  	gh->next_group = NULL;
- 
- 	init_group(gh);	/* for clean_group() */
  
  	/* moderation flag will be set by first visit_active_file call */
  
--- 436,441 ----
*** ./LAST/menu.c	Wed May 16 11:23:53 1990
--- menu.c	Fri May 18 22:26:07 1990
***************
*** 24,29 ****
--- 24,32 ----
  export int  collapse_subject = 25; /* collapse long subjects at position */
  export int  conf_group_entry = 0; /* ask whether group should be entered */
  export int  conf_entry_limit = 0; /* ask only if more than .. unread */
+ export int  mark_read_skip = 4; /* effect of X command */
+ export int  mark_read_return = 0; /* effect of Z command */
+ export int  mark_next_group = 0; /* effect of N command */
  
  export int  auto_preview_mode = 0; /* preview rather than select */
  export int  preview_continuation = 12; /* what to do after preview */
***************
*** 452,458 ****
  static int article_id;
  static int cur_key;
  
! static int get_k_cmd()
  {
      extern int any_message;
      register int c, map;
--- 455,461 ----
  static int article_id;
  static int cur_key;
  
! static int get_k_cmd_1()
  {
      extern int any_message;
      register int c, map;
***************
*** 472,482 ****
      }
      if (s_hangup) map = K_QUIT;
  
-     if (map & K_MACRO) {
- 	m_invoke(map & ~K_MACRO);
- 	goto loop;
-     }
- 
      if (map & K_ARTICLE_ID) {
  	article_id = map & ~K_ARTICLE_ID;
  	map = K_ARTICLE_ID;
--- 475,480 ----
***************
*** 491,496 ****
--- 489,504 ----
      return map;
  }
  
+ static int get_k_cmd()
+ {
+     register int map;
+ 
+     map = get_k_cmd_1();
+     if (map & K_MACRO)
+ 	map = orig_menu_map[cur_key];
+     return map;
+ }
+ 
  
  char *pct(start, end, first, last)
  long start, end, first, last;
***************
*** 592,598 ****
      int			doing_unshar, did_unshar, junk_prompt;
      char 		*fname, *savemode, *init_save();
      int 		maxa;	/* max no of articles per menu page */
!     int 		o_firsta, o_mode;	/* for recursive calls */
      static		menu_level = 0;
      char		purpose[80], pr_fmt[60];
      extern int 		enable_stop, file_completion();
--- 600,607 ----
      int			doing_unshar, did_unshar, junk_prompt;
      char 		*fname, *savemode, *init_save();
      int 		maxa;	/* max no of articles per menu page */
!     article_number	o_firsta, temp1, temp2;
!     int			o_mode;	/* for recursive calls */
      static		menu_level = 0;
      char		purpose[80], pr_fmt[60];
      extern int 		enable_stop, file_completion();
***************
*** 752,760 ****
       }
  
       last_k_cmd = cur_k_cmd;
-      k_cmd = get_k_cmd();
  
    alt_key:
  
       switch (cur_k_cmd = k_cmd) {
  
--- 761,775 ----
       }
  
       last_k_cmd = cur_k_cmd;
  
+   get_next_k_cmd:
+      k_cmd = get_k_cmd_1();
+ 
    alt_key:
+     if (k_cmd & K_MACRO) {
+ 	m_invoke(k_cmd & ~K_MACRO);
+ 	goto get_next_k_cmd;
+     }
  
       switch (cur_k_cmd = k_cmd) {
  
***************
*** 1022,1035 ****
  	 if (nexta < n_articles) goto nextmenu;
  	 break;
  
-       case K_READ_GROUP_UPDATE:
- 	 repl_attr_all(0, A_SEEN, 0);
- 	 break;
- 
        case K_READ_GROUP_THEN_SAME:
  	 break;
  
        case K_NEXT_GROUP_NO_UPDATE:
  	 menu_return(ME_NEXT);
  
        case K_PREVIOUS:
--- 1037,1068 ----
  	 if (nexta < n_articles) goto nextmenu;
  	 break;
  
        case K_READ_GROUP_THEN_SAME:
+ 	 if (temp = mark_read_return) goto do_marked_by;
  	 break;
  
        case K_NEXT_GROUP_NO_UPDATE:
+ 	 if (temp = mark_next_group) goto do_marked_by;
+ 	 menu_return(ME_NEXT);
+ 
+       case K_READ_GROUP_UPDATE:
+ 	 if (temp = mark_read_skip) break;
+       do_marked_by:
+ 	 temp1 = 0; temp2 = n_articles;
+ 	 switch (temp) {
+ 	  case 1:
+ 	     temp1 = firsta;
+ 	  case 3:
+ 	     temp2 = nexta;
+ 	     break;
+ 	  case 2:
+ 	     temp2 = firsta - 1;
+ 	     break;
+ 	  case 4:
+ 	     break;
+ 	 }
+ 	 repl_attr(temp1, temp2, 0, A_SEEN, 0);
+ 	 if (k_cmd != K_NEXT_GROUP_NO_UPDATE) break;
  	 menu_return(ME_NEXT);
  
        case K_PREVIOUS:
***************
*** 1103,1109 ****
  	  junk_another:
  	     if (cura < 0 || cura > numa) cura = 0;
  	     gotoxy(0, firstl + cura); fl;
! 	     
  	     switch (get_k_cmd()) {
  	      case K_JUNK_ARTICLES:
  		 junk_prompt++;	/* can be 0 */
--- 1136,1142 ----
  	  junk_another:
  	     if (cura < 0 || cura > numa) cura = 0;
  	     gotoxy(0, firstl + cura); fl;
! 
  	     switch (get_k_cmd()) {
  	      case K_JUNK_ARTICLES:
  		 junk_prompt++;	/* can be 0 */
***************
*** 1394,1403 ****
--- 1427,1438 ----
  	 ah = articles[firsta+cura];
  
  	 no_raw();
+ 	 orig_attr = ah->attr;
  	 ah->attr = 0;
  	 menu_cmd = more(ah, MM_PREVIEW, prompt_line);
  	 if (menu_cmd == MC_MENU) {
  	     next_cura = cura;
+ 	     if (ah->attr == 0) ah->attr = orig_attr;
  	     if (prompt_line < 0) goto redraw;
  	     mark();
  	     prompt_line = temp;
***************
*** 1404,1410 ****
  	     goto build_prompt;
  	 }
  
! 	 if (preview_mark_read && ah->attr == 0) ah->attr = A_READ;
  	 if (prompt_line >= 0)
  	     mark();
  	 next_cura = ++cura;
--- 1439,1447 ----
  	     goto build_prompt;
  	 }
  
! 	 if (ah->attr == 0)
! 	     ah->attr = preview_mark_read ? A_READ : orig_attr;
! 
  	 if (prompt_line >= 0)
  	     mark();
  	 next_cura = ++cura;
*** ./LAST/more.c	Wed May 16 11:22:46 1990
--- more.c	Mon May 21 14:02:04 1990
***************
*** 595,602 ****
  	}
  	skip_char = NUL;
  	if (overlap > 0) {
! 	    underline_line = linenum;
! 	    linenum -= overlap;
  	    goto next_page;
  	}
      }
--- 595,602 ----
  	}
  	skip_char = NUL;
  	if (overlap > 0) {
! 	    underline_line = linenum - 1;
! 	    linenum -= overlap + 1;
  	    goto next_page;
  	}
      }
*** ./LAST/newsrc.c	Wed May 16 11:23:54 1990
--- newsrc.c	Wed May 16 21:49:04 1990
***************
*** 989,994 ****
--- 989,999 ----
  	    if (gh->newsrc_line != NULL && gh->newsrc_orig != gh->newsrc_line)
  		freeobj(gh->newsrc_line);
  	    gh->newsrc_line = NULL;
+ 	    if (gh->newsrc_orig != NULL) dump_newsrc();
+ 	    if (gh->select_line != NULL && gh->newsrc_orig != gh->select_line)
+ 		freeobj(gh->select_line);
+ 	    gh->select_line = NULL;
+ 	    if (gh->select_orig != NULL) dump_select();
  	    return;
  	}
  	
*** ./LAST/nngrab.sh	Wed May 16 11:22:50 1990
--- nngrab.sh	Fri May 18 22:59:11 1990
***************
*** 8,20 ****
  
  trap "rm -f $TMP/nngrab$$" 0 1 2 15
  
  if [ ! $# -eq 1 ] ; then
! 	echo "usage: $0 keyword-pattern"
  	exit 1
  fi
  
  if [ -s $DB/subjects ] ; then
! 	egrep "^[^:]*:.*$1" $DB/subjects |
  	sed 's/^\([^:]*\):.*/\1/' |
  	uniq > $TMP/nngrab$$
  
--- 8,28 ----
  
  trap "rm -f $TMP/nngrab$$" 0 1 2 15
  
+ FOLDCASE=""
+ if [ x"$1" = x"-c" ] ; then
+ 	FOLDCASE="-i"
+ 	shift
+ fi
+ 
  if [ ! $# -eq 1 ] ; then
! 	echo "usage: $0 [-c] keyword-pattern"
  	exit 1
  fi
  
+ KW="`echo "$1" | tr '[A-Z]' '[a-z]'`"
+ 
  if [ -s $DB/subjects ] ; then
! 	egrep "^[^:]*:.*${KW}" $DB/subjects |
  	sed 's/^\([^:]*\):.*/\1/' |
  	uniq > $TMP/nngrab$$
  
***************
*** 23,29 ****
  		exit
  	fi
  
! 	$BIN/nn -Q -mxX -s/"$1" -G `cat $TMP/nngrab$$`
  else
! 	$BIN/nn -Q -mxX -s/"$1" all
  fi
--- 31,37 ----
  		exit
  	fi
  
! 	$BIN/nn -Q -mxX $FOLDCASE -s/"$1" -G `cat $TMP/nngrab$$`
  else
! 	$BIN/nn -Q -mxX $FOLDCASE -s/"$1" all
  fi
*** ./LAST/pack_name.c	Mon Apr 23 18:25:58 1990
--- pack_name.c	Fri May 18 15:05:58 1990
***************
*** 339,347 ****
  		name++;
  		continue;
  	    }
! 	    if (prev_space)
! 		*p = TAB;
! 	    else {
  		*p = '-';
  		lname++;
  	    }
--- 339,348 ----
  		name++;
  		continue;
  	    }
! 	    if (prev_space) {
! 		*p = NUL; break;	/* strip from " -" */
! 		/* *p = TAB; 	/* do not strip from " -" */
! 	    } else {
  		*p = '-';
  		lname++;
  	    }
*** ./LAST/patchlevel.h	Wed May 16 11:23:57 1990
--- patchlevel.h	Mon May 21 13:32:45 1990
***************
*** 11,19 ****
   *	1990-03-03: Release 6.4beta	(FTP)
   *	1990-05-07: Release 6.4		(comp.sources.unix)
   *
!  *	1990-05-10: Patch #1 (6.4.1)
!  *	1990-05-15: Patch #2 (6.4.2)
   */
  
! #define PATCHLEVEL 2
  
--- 11,20 ----
   *	1990-03-03: Release 6.4beta	(FTP)
   *	1990-05-07: Release 6.4		(comp.sources.unix)
   *
!  *	1990-05-10: Patch #1 (6.4.1) - HIGH
!  *	1990-05-15: Patch #2 (6.4.2) - HIGH
!  *	1990-05-21: Patch #3 (6.4.3) - HIGH
   */
  
! #define PATCHLEVEL 3
  
*** ./LAST/save.c	Thu Apr 26 20:34:11 1990
--- save.c	Fri May 18 23:31:03 1990
***************
*** 12,17 ****
--- 12,18 ----
  #include "news.h"
  
  export char *default_save_file = "+$F";
+ export char *folder_save_file = NULL;
  export int suggest_save_file = 1;
  export char *unshar_header_file = "Unshar.Headers";
  export int  use_mail_folders = 0;
***************
*** 183,189 ****
  
  	    save_name = current_group->save_file;
  	    if (save_name == NULL && suggest_save_file)
! 		save_name = default_save_file;
  	    if (save_name != NULL) {
  		if (!expand_file_name(name_buf, save_name, 2)) return NULL;
  		save_name = name_buf;
--- 184,191 ----
  
  	    save_name = current_group->save_file;
  	    if (save_name == NULL && suggest_save_file)
! 		save_name = (current_group->group_flag & G_FOLDER) ?
! 		    folder_save_file : default_save_file;
  	    if (save_name != NULL) {
  		if (!expand_file_name(name_buf, save_name, 2)) return NULL;
  		save_name = name_buf;
***************
*** 193,203 ****
  	    if (save_name == NULL || *save_name == NUL) return NULL;
  
  	    if (save_name[1] == NUL && save_name[0] == '+')
! 		save_name = default_save_file;
  	    else
  		if (current_group->save_file == NULL ||
  		    strcmp(save_name, current_group->save_file))
  		    strcpy(last_input, save_name);
  	}
  
  	if (*save_name == '|') {
--- 195,207 ----
  	    if (save_name == NULL || *save_name == NUL) return NULL;
  
  	    if (save_name[1] == NUL && save_name[0] == '+')
! 		save_name = (current_group->group_flag & G_FOLDER) ?
! 		    folder_save_file : default_save_file;
  	    else
  		if (current_group->save_file == NULL ||
  		    strcmp(save_name, current_group->save_file))
  		    strcpy(last_input, save_name);
+ 	    if (save_name == NULL || *save_name == NUL) return NULL;
  	}
  
  	if (*save_name == '|') {
*** ./LAST/sequence.c	Wed May 16 11:22:51 1990
--- sequence.c	Fri May 18 15:56:23 1990
***************
*** 451,462 ****
  	    continue;
  	}
  
! 	if (file_exist(group, "fr")) {
  	    faked_entry(group, G_FOLDER);
  	    any++;
  	    continue;
  	}
  
  	if (*group == '+' || *group == '~') {
  	    char exp_file[FILENAME];
  	    group_header fake_group;
--- 451,463 ----
  	    continue;
  	}
  
! 	if (*group == '+' || *group == '~' || file_exist(group, "fr")) {
  	    faked_entry(group, G_FOLDER);
  	    any++;
  	    continue;
  	}
  
+ #ifdef NOT_DEF
  	if (*group == '+' || *group == '~') {
  	    char exp_file[FILENAME];
  	    group_header fake_group;
***************
*** 474,479 ****
--- 475,481 ----
  	    errors++;
  	    continue;
  	}
+ #endif
  
  	found = 0;
  	start_group_search(group);
*** ./LAST/term.c	Wed May 16 11:23:58 1990
--- term.c	Thu May 17 01:15:32 1990
***************
*** 107,112 ****
--- 107,119 ----
  
  #else	/* V7/BSD TTY DRIVER */
  
+ #ifdef FAKE_INTERRUPT
+ #include <setjmp.h>
+ 
+ extern jmp_buf fake_keyb_sig;
+ extern int arm_fake_keyb_sig;
+ #endif
+ 
  #include <sgtty.h>
  
  static struct sgttyb norm_tty, raw_tty;
***************
*** 803,809 ****
      while (--n >= 0) {
  	c = (key_type)*cp++;
  #else
! 
      while ((n = read(0, (char *)&c, 1)) > 0) {
  	c &= 0177;	/* done by ISTRIP on USG systems */
  #endif
--- 810,822 ----
      while (--n >= 0) {
  	c = (key_type)*cp++;
  #else
! #ifdef FAKE_INTERRUPT
!     if (setjmp(fake_keyb_sig)) {
! 	arm_fake_keyb_sig = 0;
! 	return K_interrupt;
!     }
!     arm_fake_keyb_sig = 1;
! #endif
      while ((n = read(0, (char *)&c, 1)) > 0) {
  	c &= 0177;	/* done by ISTRIP on USG systems */
  #endif
***************
*** 830,836 ****
--- 843,853 ----
  		first_key = c;
  		alarm_on = 1;
  		signal(SIGALRM, mk_timeout);
+ #ifdef MICRO_ALARM
  		MICRO_ALARM();
+ #else
+ 		sleep(1);
+ #endif
  	    }
  #endif
  	    key_cnt++;
***************
*** 852,857 ****
--- 869,877 ----
  #endif
  
  #ifndef KEY_BURST
+ #ifdef FAKE_INTERRUPT
+     arm_fake_keyb_sig = 0;
+ #endif
      if (n < 0) {
  	if (errno != EINTR) s_hangup++;
  	return K_interrupt;
*** ./LAST/variable.c	Wed May 16 11:23:59 1990
--- variable.c	Mon May 21 17:08:29 1990
***************
*** 18,23 ****
--- 18,24 ----
      *editor_program,
      *extra_mail_headers,
      *extra_news_headers,
+     *folder_save_file,
      *header_lines,
      *folder_directory,
      included_mark[],
***************
*** 120,125 ****
--- 121,129 ----
      fmt_linenum,
      Lines,
      match_skip_prefix,
+     mark_next_group,
+     mark_read_return,
+     mark_read_skip,
      min_pv_window,
      new_group_action,
      newsrc_update_freq,
***************
*** 229,234 ****
--- 233,239 ----
      "flow-control",		BOOL 0,		(char **)&flow_control,
      "flush-typeahead",		BOOL 0,		(char **)&flush_typeahead,
      "folder",			STR 2,		(char **)&folder_directory,
+     "folder-save-file",		STR 3,		(char **)&folder_save_file,
      "fsort",			BOOL 2,		(char **)&dont_sort_folders,
      "header-lines",		STR 0,		(char **)&header_lines,
      "help-key",			KEY 0,		(char **)&help_key,
***************
*** 251,256 ****
--- 256,264 ----
      "mailer",			STR 0,		(char **)&mailer_program,
      "mailer-pipe-input",	BOOL 0,		(char **)&mailer_pipe_input,
      "mark-overlap",		BOOL 0,		(char **)&mark_overlap,
+     "marked-by-next-group",	INT 0,		(char **)&mark_next_group,
+     "marked-by-read-return",	INT 0,		(char **)&mark_read_return,
+     "marked-by-read-skip",	INT 0,		(char **)&mark_read_skip,
      "min-window",		INT 1,		(char **)&min_pv_window,
      "mmdf-format",		BOOL 0,		(char **)&use_mmdf_folders,
      "monitor",			BOOL 0,		(char **)&monitor_mode,
***************
*** 531,536 ****
--- 539,590 ----
  }
  
  
+ static char *var_value(var, tag)
+ register struct variable_defs *var;
+ char *tag;
+ {
+     static char ival[16];
+     register char *str;
+     register int b;
+ 
+     *tag = var_on_stack(var) ? '>' :
+ 	(var->var_flags & V_MODIFIED) ? '*' : ' ';
+ 
+     switch (VAR_TYPE) {
+      case V_STRING:
+ 	str = (VAR_OP == 1) ? CBUF_VAR : STR_VAR;
+ 	break;
+ 
+      case V_BOOLEAN:
+ 	b = BOOL_VAR;
+ 	if (VAR_OP == 2 || VAR_OP == 4) b = !b;
+ 	str = b ? "on" : "off";
+ 	break;
+ 
+      case V_INTEGER:
+ 	sprintf(ival, "%d", INT_VAR);
+ 	str = ival;
+ 	break;
+ 	
+      case V_KEY:
+ 	str = key_name(KEY_VAR);
+ 	break;
+ 
+      case V_SPECIAL:
+ 	str = "UNDEF";
+ 	switch (VAR_OP) {
+ 	 case 2:
+ 	    if (!also_read_articles) break;
+ 	    sprintf(ival, "%d", article_limit);
+ 	    str = ival;
+ 	    break;
+ 	}
+ 	break;
+     }
+     if (str == NULL) str = "NULL";
+     return str;
+ }
+ 
  test_variable(expr)
  char *expr;
  {
***************
*** 865,868 ****
--- 919,938 ----
  
  out:
      pg_end();
+ }
+ 
+ print_variable_config(f, all)
+ FILE *f;
+ int all;
+ {
+     register struct variable_defs *var;
+     char *str, tag[2];
+     register int b;
+     
+     tag[1] = NUL;
+     for (var = variables; var < &variables[TABLE_SIZE]; var++) {
+ 	if (!all && (var->var_flags & V_MODIFIED) == 0) continue;
+ 	str = var_value(var, tag);
+ 	fprintf(f, "%s%s='%s'\n", all ? tag : "", var->var_name, str);
+     }
  }

exit 0 # Just in case...
