Path: j.cc.purdue.edu!mentor.cc.purdue.edu!purdue!tut.cis.ohio-state.edu!snorkelwacker!apple!bbn.com!papaya.bbn.com!rsalz
From: rsalz@uunet.uu.net (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v22i022:  Error table compiler and library, Part01/03
Message-ID: <2502@papaya.bbn.com>
Date: 7 May 90 20:50:42 GMT
Lines: 1850
Approved: rsalz@uunet.UU.NET

Submitted-by: "Jonathan I. Kamens" <jik@pit-manager.mit.edu>
Posting-number: Volume 22, Issue 22
Archive-name: et/part01

[  This was originally bundled into the Delete package, but I split it out
   because I think it should be available more easily.  It's used in lots of
   Athena software.

   The introduction below comes from the manpage. The file texinfo.tex was
   split into two parts for posting.  --r$  ]

This is an error-table library.

    #include <com_err.h>
    void com_err (whoami, code, format, ...);
	    const char *whoami;
	    long code;
	    const char *format;
    proc = set_com_err_hook (proc);
    void (* proc) (const char *, long, const char *, va_list);
    proc = reset_com_err_hook ();
    void initialize_XXXX_error_table ();

Com_err displays an error message on the standard error stream stderr
composed of the whoami string, which should specify the program name or
some subportion of a program, followed by an error message generated from
the code value (derived from compile_et, and a string produced using the
format string and any following arguments, in the same style as fprintf.

The behavior of com_err can be modified using set_com_err_hook; this
defines a procedure which is called with the arguments passed to com_err,
instead of the default internal procedure which sends the formatted text
to error output.  Thus the error messages from a program can all easily be
diverted to another form of diagnostic logging, such as syslog (3).
Reset_com_err_hook may be used to restore the behavior of com_err to its
default form.  Both procedures return the previous ``hook'' value.  These
``hook'' procedures must have the declaration given for proc above in the
synopsis.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  MANIFEST Makefile com_err.3 com_err.c com_err.h
#   compile_et.1 compile_et.c compiler.h error_message.c error_table.h
#   error_table.y et_lex.lex.l et_name.c init_et.c internal.h
#   mit-sipb-copyright.h profiled strcasecmp.c test.c test1.et
#   test2.et
# Wrapped by rsalz@litchi.bbn.com on Mon May  7 16:40:32 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(874 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X Makefile                   1	
X com_err.3                  1	
X com_err.c                  1	
X com_err.h                  1	
X com_err.texinfo            2	
X compile_et.1               1	
X compile_et.c               1	
X compiler.h                 1	
X error_message.c            1	
X error_table.h              1	
X error_table.y              1	
X et_lex.lex.l               1	
X et_name.c                  1	
X init_et.c                  1	
X internal.h                 1	
X mit-sipb-copyright.h       1	
X profiled                   1	
X strcasecmp.c               1	
X test.c                     1	
X test1.et                   1	
X test2.et                   1	
X texinfo.tex.1              3	(part 1)
X texinfo.tex.2              2	(part 2)
END_OF_FILE
if test 874 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(3918 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# Makefile for error-table routines
X#
X# Copyright 1987, 1989 MIT Student Information Processing Board
X# For copyright info, see mit-sipb-copyright.h.
X#
X#	$Header: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/Makefile,v 1.2 89/11/07 18:56:09 jik Exp $
X#	$Locker:  $
X#
X
XCFLAGS=	-O
XLINTFLAGS= -uhvpb
XLINTFILES= error_message.c et_name.c init_et.c com_err.c # perror.c
XLIBOBJS= error_message.o et_name.o init_et.o com_err.o # perror.o
X
XBINDIR=/usr/athena
XINCDIR=/usr/include
XLIBDIR=/usr/athena/lib
XDOCDIR=/usr/doc/athena
XDESTDIR=
X
XFILES=	Makefile et_name.c error_message.c compile_et.c \
X		error_table.y et_lex.lex.l init_et.c \
X		com_err.c com_err.h \
X		error_table.h mit-sipb-copyright.h \
X		test.c test1.et test2.et \
X		compiler.h internal.h \
X		com_err.texinfo texinfo.tex strcasecmp.c
XCFILES=	compile_et.c error_table.c error_message.c et_name.c \
X	init_et.c com_err.c strcasecmp.c
X
X#
X# what to build...
X#
Xall:	compile_et libcom_err.a libcom_err_p.a
X
Xlint:	llib-lcom_err.ln
X
Xarchive:	et.tar
X
Xdoc:	com_err.dvi
X
X#
X# rules
X#
X.SUFFIXES: .h .c .et .ps .x9700 .mss .dvi .texinfo
X
X.et.c:
X	./compile_et $*.et
X
X.et.h:
X	./compile_et $*.et
X
X.texinfo.dvi:
X	tex $<
X
X.dvi.ps:
X	rm -f $@.new
X	dvi2ps -r $< > $@.new
X	mv $@.new $@
X
X.c.o:
X	${CC} -c -pg ${CFLAGS} $*.c
X	mv $*.o profiled/$*.o
X	${CC} -c ${CFLAGS} $*.c
X
X#
X# real entries...
X#
Xcompile_et:	compile_et.o error_table.o strcasecmp.o
X	${CC} ${CFLAGS} -o compile_et compile_et.o error_table.o\
X		strcasecmp.o -ll
X
Xet.tar:	${FILES}
X	rm -f et.tar
X	tar cfrlv et.tar ${FILES}
X
Xtags:	TAGS
X
Xcom_err.ps : com_err.dvi
Xcom_err.dvi: com_err.texinfo
X
Xerror_table.o: et_lex.lex.c
X
Xinstall: all
X	install -c -s compile_et ${DESTDIR}${BINDIR}/compile_et
X	install -c -m 444 com_err.h ${DESTDIR}${INCDIR}/com_err.h
X	install -c -m 444 mit-sipb-copyright.h \
X				${DESTDIR}${INCDIR}/mit-sipb-copyright.h
X	install -c libcom_err.a ${DESTDIR}${LIBDIR}/libcom_err.a
X	ranlib ${DESTDIR}${LIBDIR}/libcom_err.a
X	install -c libcom_err_p.a ${DESTDIR}${LIBDIR}/libcom_err_p.a
X	ranlib ${DESTDIR}${LIBDIR}/libcom_err_p.a
X	install -c com_err.texinfo ${DESTDIR}${DOCDIR}/com_err.texinfo
X	install -c com_err.3 ${DESTDIR}/usr/man/man3/com_err.3
X	install -c compile_et.1 ${DESTDIR}/usr/man/man1/compile_et.1
X
XTAGS:	et_name.c error_message.c compile_et.c error_table.c \
X		lex.yy.c perror.c init_et.c
X	etags et_name.c error_message.c compile_et.c \
X		error_table.c perror.c init_et.c
X
Xlibcom_err.a:	$(LIBOBJS)
X	ar cruv libcom_err.a $(LIBOBJS)
X	ranlib libcom_err.a
X
Xlibcom_err_p.a:	$(LIBOBJS)
X	(cd profiled; ar uv ../libcom_err_p.a $(LIBOBJS); \
X		ranlib ../libcom_err_p.a)
X
Xlibcom_err.o:	$(LIBOBJS)
X	ld -r -s -o libcom_err.o $(LIBOBJS)
X	chmod -x libcom_err.o
X
Xllib-lcom_err.ln: $(LINTFILES)
X	lint -Ccom_err $(LINTFLAGS) $(LINTFILES)
X
Xclean:
X	rm -f *~ \#* *.bak \
X		*.otl *.aux *.toc *.PS *.dvi *.x9700 *.ps \
X		*.cp *.fn *.ky *.log *.pg *.tp *.vr \
X		*.o profiled/*.o libcom_err.a libcom_err_p.a \
X		com_err.o compile_et \
X		et.ar TAGS y.tab.c lex.yy.c error_table.c \
X		et_lex.lex.c \
X		test1.h test1.c test2.h test2.c test \
X		eddep makedep
X
X# for testing
Xtest:	test.o test1.o test2.o libcom_err.a
X	cc ${CFLAGS} -o test test.o test1.o test2.o libcom_err.a
Xtest.o:	test1.h test2.h
Xtest1.o : test1.c
Xtest1.c : test1.et
Xtest2.o : test2.c
Xtest2.c : test2.et
X# 'make depend' code
Xdepend: ${CFILES} et_lex.lex.c
X	rm -f eddep makedep
X	/bin/cc -M ${CFLAGS} ${CFILES} | \
X	sed 's; ./; ;' | \
X	sed -e ':loop' \
X	    -e 's/\.\.\/[^ /]*\/\.\./../' \
X	    -e 't loop' > makedep
X# add a blank line so that if there are no dependencies, ed
X# won't report an error (it does on some 
X	echo "$$" > eddep
X	echo "a" >> eddep
X	echo "" >> eddep
X	echo "." >> eddep
X	echo '/^# DO NOT DELETE THIS LINE/+1,$$d' >> eddep
X	echo '$$r makedep' >>eddep
X	echo 'w' >>eddep
X	cp Makefile Makefile.bak
X	ed - Makefile < eddep
X	rm eddep makedep
X#
X# the last line in the makefile should be...
X# DO NOT DELETE THIS LINE -- make depend depends on it.
END_OF_FILE
if test 3918 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'com_err.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'com_err.3'\"
else
echo shar: Extracting \"'com_err.3'\" \(2531 characters\)
sed "s/^X//" >'com_err.3' <<'END_OF_FILE'
X.\" Copyright (c) 1988 Massachusetts Institute of Technology,
X.\" Student Information Processing Board.  All rights reserved.
X.\"
X.\" $Header: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/com_err.3,v 1.1 89/11/07 19:05:23 jik Exp $
X.\"
X.TH COM_ERR 3 "22 Nov 1988" SIPB
X.SH NAME
Xcom_err \- common error display routine
X.SH SYNOPSIS
X.nf
X #include <com_err.h>
X.PP
Xvoid com_err (whoami, code, format, ...);
X	const char *whoami;
X	long code;
X	const char *format;
X.PP
Xproc = set_com_err_hook (proc);
X.fi
Xvoid (*
X.I proc
X) (const char *, long, const char *, va_list);
X.nf
X.PP
Xproc = reset_com_err_hook ();
X.PP
Xvoid initialize_XXXX_error_table ();
X.fi
X.SH DESCRIPTION
X.I Com_err
Xdisplays an error message on the standard error stream
X.I stderr
X(see
X.IR stdio (3S))
Xcomposed of the
X.I whoami
Xstring, which should specify the program name or some subportion of
Xa program, followed by an error message generated from the
X.I code
Xvalue (derived from
X.IR compile_et (1)),
Xand a string produced using the
X.I format
Xstring and any following arguments, in the same style as
X.IR fprintf (3).
X
XThe behavior of
X.I com_err
Xcan be modified using
X.I set_com_err_hook;
Xthis defines a procedure which is called with the arguments passed to
X.I com_err,
Xinstead of the default internal procedure which sends the formatted
Xtext to error output.  Thus the error messages from a program can all
Xeasily be diverted to another form of diagnostic logging, such as
X.IR syslog (3).
X.I Reset_com_err_hook
Xmay be used to restore the behavior of
X.I com_err
Xto its default form.  Both procedures return the previous ``hook''
Xvalue.  These ``hook'' procedures must have the declaration given for
X.I proc
Xabove in the synopsis.
X
XThe
X.I initialize_XXXX_error_table
Xroutine is generated mechanically by
X.IR compile_et (1)
Xfrom a source file containing names and associated strings.  Each
Xtable has a name of up to four characters, which is used in place of
Xthe
X.B XXXX
Xin the name of the routine.  These routines should be called before
Xany of the corresponding error codes are used, so that the
X.I com_err
Xlibrary will recognize error codes from these tables when they are
Xused.
X
XThe
X.B com_err.h
Xheader file should be included in any source file that uses routines
Xfrom the
X.I com_err
Xlibrary; executable files must be linked using
X.I ``-lcom_err''
Xin order to cause the
X.I com_err
Xlibrary to be included.
X
X.\" .IR for manual entries
X.\" .PP for paragraph breaks
X
X.SH "SEE ALSO"
Xcompile_et (1), syslog (3).
X
XKen Raeburn, "A Common Error Description Library for UNIX".
END_OF_FILE
if test 2531 -ne `wc -c <'com_err.3'`; then
    echo shar: \"'com_err.3'\" unpacked with wrong size!
fi
# end of 'com_err.3'
fi
if test -f 'com_err.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'com_err.c'\"
else
echo shar: Extracting \"'com_err.c'\" \(2900 characters\)
sed "s/^X//" >'com_err.c' <<'END_OF_FILE'
X/*
X * Copyright 1987, 1988 by MIT Student Information Processing Board.
X *
X * For copyright info, see mit-sipb-copyright.h.
X */
X
X#include <stdio.h>
X#include "mit-sipb-copyright.h"
X
X/*
X * Our environment only provides for ANSI's <stdarg.h> when using GNU
X * C.  Grump grump...
X */
X#if ! __GNUC__
X#define VARARGS 1
X#endif
X
X/* We don't have the v*printf routines... */
X#define vfprintf(stream,fmt,args) _doprnt(fmt,args,stream)
X
X#if __STDC__ && !VARARGS
X#	include <stdarg.h>
X#else /* varargs: not STDC or no <stdarg> */
X	/* Non-ANSI, always take <varargs.h> path. */
X#	undef VARARGS
X#	define VARARGS 1
X#	include <varargs.h>
X#	undef vfprintf
X#	define vfprintf(stream,fmt,args) _doprnt(fmt,args,stream)
X#endif /* varargs */
X
X#include "error_table.h"
X#include "internal.h"
X
X/*
X * Protect us from header version (externally visible) of com_err, so
X * we can survive in a <varargs.h> environment.  I think.
X */
X#define com_err com_err_external
X#include "com_err.h"
X#undef com_err
X
X/* BSD. sigh. */
X#undef vfprintf
X#define vfprintf(stream,fmt,args) _doprnt(fmt,args,stream)
X
X#if ! lint
Xstatic const char rcsid[] =
X    "$Header: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/com_err.c,v 1.2 89/11/07 18:57:42 jik Exp $";
X#endif	/* ! lint */
X
Xstatic void
X#ifdef __STDC__
Xdefault_com_err_proc (const char *whoami, long code, const char *fmt, va_list args)
X#else
Xdefault_com_err_proc (whoami, code, fmt, args)
X    const char *whoami;
X    long code;
X    const char *fmt;
X    va_list args;
X#endif
X{
X    if (whoami) {
X	fputs(whoami, stderr);
X	fputs(": ", stderr);
X    }
X    if (code) {
X	fputs(error_message(code), stderr);
X	fputs(" ", stderr);
X    }
X    if (fmt) {
X        vfprintf (stderr, fmt, args);
X    }
X    putc('\n', stderr);
X    /* should do this only on a tty in raw mode */
X    putc('\r', stderr);
X    fflush(stderr);
X}
X
Xerrf com_err_hook = default_com_err_proc;
X
Xvoid com_err_va (whoami, code, fmt, args)
X    const char *whoami;
X    long code;
X    const char *fmt;
X    va_list args;
X{
X    (*com_err_hook) (whoami, code, fmt, args);
X}
X
X#if ! VARARGS
Xvoid com_err (const char *whoami,
X	      long code,
X	      const char *fmt, ...)
X{
X#else
Xvoid com_err (va_alist)
X    va_dcl
X{
X    const char *whoami, *fmt;
X    long code;
X#endif
X    va_list pvar;
X
X    if (!com_err_hook)
X	com_err_hook = default_com_err_proc;
X#if VARARGS
X    va_start (pvar);
X    whoami = va_arg (pvar, const char *);
X    code = va_arg (pvar, long);
X    fmt = va_arg (pvar, const char *);
X#else
X    va_start(pvar, fmt);
X#endif
X    com_err_va (whoami, code, fmt, pvar);
X    va_end(pvar);
X}
X
X#ifdef __STDC__
Xerrf set_com_err_hook (errf new_proc)
X#else
Xerrf set_com_err_hook (new_proc)
X    errf new_proc;
X#endif
X{
X    errf x = com_err_hook;
X    com_err_hook = new_proc ? new_proc : (errf) default_com_err_proc;
X    return x;
X}
X
Xerrf reset_com_err_hook () {
X    errf x = com_err_hook;
X    com_err_hook = default_com_err_proc;
X    return x;
X}
END_OF_FILE
if test 2900 -ne `wc -c <'com_err.c'`; then
    echo shar: \"'com_err.c'\" unpacked with wrong size!
fi
# end of 'com_err.c'
fi
if test -f 'com_err.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'com_err.h'\"
else
echo shar: Extracting \"'com_err.h'\" \(1010 characters\)
sed "s/^X//" >'com_err.h' <<'END_OF_FILE'
X/*
X * Header file for common error description library.
X *
X * Copyright 1988, Student Information Processing Board of the
X * Massachusetts Institute of Technology.
X *
X * For copyright and distribution info, see the documentation supplied
X * with this package.
X */
X
X#ifndef __COM_ERR_H
X
X#ifdef __STDC__
X#ifndef __HIGHC__		/* gives us STDC but not stdarg */
X#include <stdarg.h>
X#else
X#include <varargs.h>
X#endif
X/* ANSI C -- use prototypes etc */
Xtypedef void (*errf) (const char *, long, const char *, va_list);
Xvoid com_err (const char *, long, const char *, ...);
Xchar const *error_message (long);
Xvoid (*com_err_hook) (const char *, long, const char *, va_list);
Xerrf set_com_err_hook (errf);
Xvoid (*reset_com_err_hook ()) (const char *, long, const char *, va_list);
X#else
X/* no prototypes */
Xtypedef void (*errf) ();
Xvoid com_err ();
Xchar *error_message ();
Xvoid (*com_err_hook) ();
Xerrf set_com_err_hook();
Xvoid (*reset_com_err_hook ()) ();
X#endif
X
X#define __COM_ERR_H
X#endif /* ! defined(__COM_ERR_H) */
END_OF_FILE
if test 1010 -ne `wc -c <'com_err.h'`; then
    echo shar: \"'com_err.h'\" unpacked with wrong size!
fi
# end of 'com_err.h'
fi
if test -f 'compile_et.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compile_et.1'\"
else
echo shar: Extracting \"'compile_et.1'\" \(2235 characters\)
sed "s/^X//" >'compile_et.1' <<'END_OF_FILE'
X.\" Copyright (c) 1988 Massachusetts Institute of Technology,
X.\" Student Information Processing Board.  All rights reserved.
X.\"
X.\" $Header: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/compile_et.1,v 1.1 89/11/07 19:05:47 jik Exp $
X.\"
X.TH COMPILE_ET 1 "22 Nov 1988" SIPB
X.SH NAME
Xcompile_et \- error table compiler
X.SH SYNOPSIS
X.B compile_et
Xfile
X.SH DESCRIPTION
X.B Compile_et
Xconverts a table listing error-code names and associated messages into
Xa C source file suitable for use with the
X.IR com_err (3)
Xlibrary.
X
XThe source file name must end with a suffix of ``.et''; the file
Xconsists of a declaration supplying the name (up to four characters
Xlong) of the error-code table:
X
X.B error_table
X.I name
X
Xfollowed by up to 256 entries of the form:
X
X.B error_code
X.I name,
X"
X.I string
X"
X
Xand a final
X
X.B end
X
Xto indicate the end of the table.
X
XThe name of the table is used to construct the name of a subroutine
X.I initialize_XXXX_error_table
Xwhich must be called in order for the
X.I com_err
Xlibrary to recognize the error table.
X
XThe various error codes defined are assigned sequentially increasing
Xnumbers (starting with a large number computed as a hash function of
Xthe name of the table); thus for compatibility it is suggested that
Xnew codes be added only to the end of an existing table, and that no
Xcodes be removed from tables.
X
XThe names defined in the table are placed into a C header file with
Xpreprocessor directives defining them as integer constants of up to
X32 bits in magnitude.
X
XA C source file is also generated which should be compiled and linked
Xwith the object files which reference these error codes; it contains
Xthe text of the messages and the initialization subroutine.  Both C
Xfiles have names derived from that of the original source file, with
Xthe ``.et'' suffix replaced by ``.c'' and ``.h''.
X
XA ``#'' in the source file is treated as a comment character, and all
Xremaining text to the end of the source line will be ignored.
X
X.SH BUGS
X
XSince
X.B compile_et
Xuses a very simple parser based on
X.IR yacc (1),
Xits error recovery leaves much to be desired.
X
X.\" .IR for manual entries
X.\" .PP for paragraph breaks
X
X.SH "SEE ALSO"
Xcom_err (3).
X
XKen Raeburn, "A Common Error Description Library for UNIX".
END_OF_FILE
if test 2235 -ne `wc -c <'compile_et.1'`; then
    echo shar: \"'compile_et.1'\" unpacked with wrong size!
fi
# end of 'compile_et.1'
fi
if test -f 'compile_et.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compile_et.c'\"
else
echo shar: Extracting \"'compile_et.c'\" \(6760 characters\)
sed "s/^X//" >'compile_et.c' <<'END_OF_FILE'
X/*
X *
X * Copyright 1986, 1987, 1988
X * by MIT Student Information Processing Board.
X *
X * For copyright info, see "mit-sipb-copyright.h".
X *
X */
X
X#include <stdio.h>
X#include <sys/file.h>
X#include <string.h>
X#include <sys/param.h>
X#include "mit-sipb-copyright.h"
X#include "compiler.h"
X
X#ifndef __STDC__
X#define const
X#endif
X
X#ifndef lint
Xstatic const char copyright[] =
X    "Copyright 1987,1988 by MIT Student Information Processing Board";
X
Xstatic const char rcsid_compile_et_c[] =
X    "$Header: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/compile_et.c,v 1.1 89/11/07 19:05:27 jik Exp $";
X#endif
X
Xextern char *gensym();
Xextern char *current_token;
Xextern int table_number, current;
Xchar buffer[BUFSIZ];
Xchar *table_name = (char *)NULL;
XFILE *hfile, *cfile;
X
X/* C library */
Xextern char *malloc();
Xextern int errno;
X
X/* lex stuff */
Xextern FILE *yyin;
Xextern int yylineno;
X
Xchar * xmalloc (size) unsigned int size; {
X    char * p = malloc (size);
X    if (!p) {
X	perror (whoami);
X	exit (1);
X    }
X    return p;
X}
X
Xstatic int check_arg (str_list, arg) char const *const *str_list, *arg; {
X    while (*str_list)
X	if (!strcmp(arg, *str_list++))
X	    return 1;
X    return 0;
X}
X
Xstatic const char *const debug_args[] = {
X    "d",
X    "debug",
X    0,
X};
X
Xstatic const char *const lang_args[] = {
X    "lang",
X    "language",
X    0,
X};
X
Xstatic const char *const language_names[] = {
X    "C",
X    "K&R C",
X    "C++",
X    0,
X};
X
Xstatic const char * const c_src_prolog[] = {
X    "static const char * const text[] = {\n",
X    0,
X};
X
Xstatic const char * const krc_src_prolog[] = {
X    "#ifdef __STDC__\n",
X    "#define NOARGS void\n",
X    "#else\n",
X    "#define NOARGS\n",
X    "#define const\n",
X    "#endif\n\n",
X    "static const char * const text[] = {\n",
X    0,
X};
X
Xstatic const char *const struct_def[] = {
X    "struct error_table {\n",
X    "    char const * const * msgs;\n",
X    "    long base;\n",
X    "    int n_msgs;\n",
X    "};\n",
X    "struct et_list {\n",
X    "    struct et_list *next;\n",
X    "    const struct error_table * table;\n",
X    "};\n",
X    "extern struct et_list *_et_list;\n",
X    "\n", 0,
X};
X
Xstatic const char warning[] =
X    "/*\n * %s:\n * This file is automatically generated; please do not edit it.\n */\n";
X
X/* pathnames */
Xchar c_file[MAXPATHLEN];	/* output file */
Xchar h_file[MAXPATHLEN];	/* output */
X
Xstatic void usage () {
X    fprintf (stderr, "%s: usage: %s ERROR_TABLE\n",
X	     whoami, whoami);
X    exit (1);
X}
X
Xstatic void dup_err (type, one, two) char const *type, *one, *two; {
X    fprintf (stderr, "%s: multiple %s specified: `%s' and `%s'\n",
X	     whoami, type, one, two);
X    usage ();
X}
X
Xint main (argc, argv) int argc; char **argv; {
X    char *p, *ename;
X    int len;
X    char const * const *cpp;
X    int got_language = 0;
X
X    /* argument parsing */
X    debug = 0;
X    filename = 0;
X    whoami = argv[0];
X    p = strrchr (whoami, '/');
X    if (p)
X	whoami = p+1;
X    while (argv++, --argc) {
X	char *arg = *argv;
X	if (arg[0] != '-') {
X	    if (filename)
X		dup_err ("filenames", filename, arg);
X	    filename = arg;
X	}
X	else {
X	    arg++;
X	    if (check_arg (debug_args, arg))
X		debug++;
X	    else if (check_arg (lang_args, arg)) {
X		got_language++;
X		arg = *++argv, argc--;
X		if (!arg)
X		    usage ();
X		if (language)
X		    dup_err ("languanges", language_names[(int)language], arg);
X#define check_lang(x,v) else if (!strcasecmp(arg,x)) language = v
X		check_lang ("c", lang_C);
X		check_lang ("ansi_c", lang_C);
X		check_lang ("ansi-c", lang_C);
X		check_lang ("krc", lang_KRC);
X		check_lang ("kr_c", lang_KRC);
X		check_lang ("kr-c", lang_KRC);
X		check_lang ("k&r-c", lang_KRC);
X		check_lang ("k&r_c", lang_KRC);
X		check_lang ("c++", lang_CPP);
X		check_lang ("cplusplus", lang_CPP);
X		check_lang ("c-plus-plus", lang_CPP);
X#undef check_lang
X		else {
X		    fprintf (stderr, "%s: unknown language name `%s'\n",
X			     whoami, arg);
X		    fprintf (stderr, "\tpick one of: C K&R-C\n");
X		    exit (1);
X		}
X	    }
X	    else {
X		fprintf (stderr, "%s: unknown control argument -`%s'\n",
X			 whoami, arg);
X		usage ();
X	    }
X	}
X    }
X    if (!filename)
X	usage ();
X    if (!got_language)
X	language = lang_KRC;
X    else if (language == lang_CPP) {
X	fprintf (stderr, "%s: Sorry, C++ support is not yet finished.\n",
X		 whoami);
X	exit (1);
X    }
X
X    p = xmalloc (strlen (filename) + 5);
X    strcpy (p, filename);
X    filename = p;
X    p = strrchr(filename, '/');
X    if (p == (char *)NULL)
X	p = filename;
X    else
X	p++;
X    ename = p;
X    len = strlen (ename);
X    p += len - 3;
X    if (strcmp (p, ".et"))
X	p += 3;
X    *p++ = '.';
X    /* now p points to where "et" suffix should start */
X    /* generate new filenames */
X    strcpy (p, "c");
X    strcpy (c_file, ename);
X    *p = 'h';
X    strcpy (h_file, ename);
X    strcpy (p, "et");
X
X    yyin = fopen(filename, "r");
X    if (!yyin) {
X	perror(filename);
X	exit(1);
X    }
X
X    hfile = fopen(h_file, "w");
X    if (hfile == (FILE *)NULL) {
X	perror(h_file);
X	exit(1);
X    }
X    fprintf (hfile, warning, h_file);
X
X    cfile = fopen(c_file, "w");
X    if (cfile == (FILE *)NULL) {
X	perror(c_file);
X	exit(1);
X    }
X    fprintf (cfile, warning, c_file);
X
X    /* prologue */
X    if (language == lang_C)
X	cpp = c_src_prolog;
X    else if (language == lang_KRC)
X	cpp = krc_src_prolog;
X    else
X	abort ();
X    while (*cpp)
X	fputs (*cpp++, cfile);
X
X    /* parse it */
X    yyparse();
X    fclose(yyin);		/* bye bye input file */
X
X    fputs ("    0\n};\n\n", cfile);
X    for (cpp = struct_def; *cpp; cpp++)
X	fputs (*cpp, cfile);
X    fprintf(cfile,
X	    "static const struct error_table et = { text, %ldL, %d };\n\n",
X	    table_number, current);
X    fputs("static struct et_list link = { 0, 0 };\n\n",
X	  cfile);
X    fprintf(cfile, "void initialize_%s_error_table (%s) {\n",
X	    table_name, (language == lang_C) ? "void" : "NOARGS");
X    fputs("    if (!link.table) {\n", cfile);
X    fputs("        link.next = _et_list;\n", cfile);
X    fputs("        link.table = &et;\n", cfile);
X    fputs("        _et_list = &link;\n", cfile);
X    fputs("    }\n", cfile);
X    fputs("}\n", cfile);
X    fclose(cfile);
X
X    fprintf (hfile, "extern void initialize_%s_error_table ();\n",
X	     table_name);
X    fprintf (hfile, "#define ERROR_TABLE_BASE_%s (%ldL)\n",
X	     table_name, table_number);
X    /* compatibility... */
X    fprintf (hfile, "\n/* for compatibility with older versions... */\n");
X    fprintf (hfile, "#define init_%s_err_tbl initialize_%s_error_table\n",
X	     table_name, table_name);
X    fprintf (hfile, "#define %s_err_base ERROR_TABLE_BASE_%s\n", table_name,
X	     table_name);
X    fclose(hfile);		/* bye bye include file */
X
X    return 0;
X}
X
Xint yyerror(s) char *s; {
X    fputs(s, stderr);
X    fprintf(stderr, "\nLine number %d; last token was '%s'\n",
X	    yylineno, current_token);
X}
END_OF_FILE
if test 6760 -ne `wc -c <'compile_et.c'`; then
    echo shar: \"'compile_et.c'\" unpacked with wrong size!
fi
# end of 'compile_et.c'
fi
if test -f 'compiler.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compiler.h'\"
else
echo shar: Extracting \"'compiler.h'\" \(379 characters\)
sed "s/^X//" >'compiler.h' <<'END_OF_FILE'
X/*
X * definitions common to the source files of the error table compiler
X */
X
X#ifndef __STDC__
X/* loser */
X#undef const
X#define const
X#endif
X
Xenum lang {
X    lang_C,			/* ANSI C (default) */
X    lang_KRC,			/* C: ANSI + K&R */
X    lang_CPP			/* C++ */
X};
X
Xint debug;			/* dump debugging info? */
Xchar *filename;			/* error table source */
Xenum lang language;
Xconst char *whoami;
END_OF_FILE
if test 379 -ne `wc -c <'compiler.h'`; then
    echo shar: \"'compiler.h'\" unpacked with wrong size!
fi
# end of 'compiler.h'
fi
if test -f 'error_message.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'error_message.c'\"
else
echo shar: Extracting \"'error_message.c'\" \(1857 characters\)
sed "s/^X//" >'error_message.c' <<'END_OF_FILE'
X/*
X * $Header: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/error_message.c,v 1.1 89/11/07 19:05:30 jik Exp $
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/error_message.c,v $
X * $Locker:  $
X *
X * Copyright 1987 by the Student Information Processing Board
X * of the Massachusetts Institute of Technology
X *
X * For copyright info, see "mit-sipb-copyright.h".
X */
X
X#include <stdio.h>
X#include "error_table.h"
X#include "mit-sipb-copyright.h"
X#include "internal.h"
X
Xstatic const char rcsid[] =
X    "$Header: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/error_message.c,v 1.1 89/11/07 19:05:30 jik Exp $";
Xstatic const char copyright[] =
X    "Copyright 1986, 1987, 1988 by the Student Information Processing Board\nand the department of Information Systems\nof the Massachusetts Institute of Technology";
X
Xstatic char buffer[25];
X
Xstruct et_list * _et_list = (struct et_list *) NULL;
X
Xconst char * error_message (code)
Xlong	code;
X{
X    int offset;
X    struct et_list *et;
X    int table_num;
X    int started = 0;
X    char *cp;
X
X    offset = code & ((1<<ERRCODE_RANGE)-1);
X    table_num = code - offset;
X    if (!table_num) {
X	if (offset < sys_nerr)
X	    return(sys_errlist[offset]);
X	else
X	    goto oops;
X    }
X    for (et = _et_list; et; et = et->next) {
X	if (et->table->base == table_num) {
X	    /* This is the right table */
X	    if (et->table->n_msgs <= offset)
X		goto oops;
X	    return(et->table->msgs[offset]);
X	}
X    }
Xoops:
X    strcpy (buffer, "Unknown code ");
X    if (table_num) {
X	strcat (buffer, error_table_name (table_num));
X	strcat (buffer, " ");
X    }
X    for (cp = buffer; *cp; cp++)
X	;
X    if (offset >= 100) {
X	*cp++ = '0' + offset / 100;
X	offset %= 100;
X	started++;
X    }
X    if (started || offset >= 10) {
X	*cp++ = '0' + offset / 10;
X	offset %= 10;
X    }
X    *cp++ = '0' + offset;
X    *cp = '\0';
X    return(buffer);
X}
END_OF_FILE
if test 1857 -ne `wc -c <'error_message.c'`; then
    echo shar: \"'error_message.c'\" unpacked with wrong size!
fi
# end of 'error_message.c'
fi
if test -f 'error_table.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'error_table.h'\"
else
echo shar: Extracting \"'error_table.h'\" \(663 characters\)
sed "s/^X//" >'error_table.h' <<'END_OF_FILE'
X/*
X * Copyright 1988 by the Student Information Processing Board of the
X * Massachusetts Institute of Technology.
X *
X * For copyright info, see mit-sipb-copyright.h.
X */
X
X#ifndef _ET_H
X/* Are we using ANSI C? */
X#ifndef __STDC__
X#define const
X#endif
Xextern int errno;
Xstruct error_table {
X    char const * const * msgs;
X    long base;
X    int n_msgs;
X};
Xstruct et_list {
X    struct et_list *next;
X    const struct error_table *table;
X};
Xextern struct et_list * _et_list;
X
X#define	ERRCODE_RANGE	8	/* # of bits to shift table number */
X#define	BITS_PER_CHAR	6	/* # bits to shift per character in name */
X
Xextern const char *error_table_name();
X#define _ET_H
X#endif
END_OF_FILE
if test 663 -ne `wc -c <'error_table.h'`; then
    echo shar: \"'error_table.h'\" unpacked with wrong size!
fi
# end of 'error_table.h'
fi
if test -f 'error_table.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'error_table.y'\"
else
echo shar: Extracting \"'error_table.y'\" \(4747 characters\)
sed "s/^X//" >'error_table.y' <<'END_OF_FILE'
X%{
X#include <stdio.h>
X#if !defined(__STDC__) || defined(__HIGHC__)
Xchar *malloc(), *realloc();
X#endif     
Xchar *str_concat(), *ds(), *quote();
Xchar *current_token = (char *)NULL;
Xextern char *table_name;
X%}
X%union {
X	char *dynstr;
X}
X
X%token ERROR_TABLE ERROR_CODE_ENTRY END
X%token <dynstr> STRING QUOTED_STRING
X%type <dynstr> ec_name description table_id
X%{
X%}
X%start error_table
X%%
X
Xerror_table	:	ERROR_TABLE table_id error_codes END
X			{ table_name = ds($2);
X			  current_token = table_name;
X			  put_ecs(); }
X		;
X
Xtable_id	:	STRING
X			{ current_token = $1;
X			  set_table_num($1);
X			  $$ = $1; }
X		;
X
Xerror_codes	:	error_codes ec_entry
X		|	ec_entry
X		;
X
Xec_entry	:	ERROR_CODE_ENTRY ec_name ',' description
X			{ add_ec($2, $4);
X			  free($2);
X			  free($4); }
X		|	ERROR_CODE_ENTRY ec_name '=' STRING ',' description
X			{ add_ec_val($2, $4, $6);
X			  free($2);
X			  free($4);
X			  free($6);
X			}
X		;
X
Xec_name		:	STRING
X			{ $$ = ds($1);
X			  current_token = $$; }
X		;
X
Xdescription	:	QUOTED_STRING
X			{ $$ = ds($1);
X			  current_token = $$; }
X		;
X
X%%
X/*
X *
X * Copyright 1986, 1987 by the MIT Student Information Processing Board
X *
X * For copyright info, see mit-sipb-copyright.h.
X */
X
X#include <string.h>
X#include <assert.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/time.h>
X#include "internal.h"
X#include "error_table.h"
X#include "mit-sipb-copyright.h"
X
X#ifndef	lint
Xstatic char const rcsid_error_table_y[] =
X    "$Header: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/error_table.y,v 1.2 89/11/07 18:55:08 jik Exp $";
X#endif
X
Xextern FILE *hfile, *cfile;
X
Xstatic long gensym_n = 0;
Xchar *
Xgensym(x)
X	char const *x;
X{
X	char *symbol;
X	if (!gensym_n) {
X		struct timeval tv;
X		struct timezone tzp;
X		gettimeofday(&tv, &tzp);
X		gensym_n = (tv.tv_sec%10000)*100 + tv.tv_usec/10000;
X	}
X	symbol = malloc(32 * sizeof(char));
X	gensym_n++;
X	sprintf(symbol, "et%ld", gensym_n);
X	return(symbol);
X}
X
Xchar *
Xds(string)
X	char const *string;
X{
X	char *rv;
X	rv = malloc(strlen(string)+1);
X	strcpy(rv, string);
X	return(rv);
X}
X
Xchar *
Xquote(string)
X	char const *string;
X{
X	char *rv;
X	rv = malloc(strlen(string)+3);
X	strcpy(rv, "\"");
X	strcat(rv, string);
X	strcat(rv, "\"");
X	return(rv);
X}
X
Xlong table_number;
Xint current = 0;
Xchar **error_codes = (char **)NULL;
X
Xadd_ec(name, description)
X	char const *name, *description;
X{
X	fprintf(cfile, "\t\"%s\",\n", description);
X	if (error_codes == (char **)NULL) {
X		error_codes = (char **)malloc(sizeof(char *));
X		*error_codes = (char *)NULL;
X	}
X	error_codes = (char **)realloc((char *)error_codes,
X				       (current + 2)*sizeof(char *));
X	error_codes[current++] = ds(name);
X	error_codes[current] = (char *)NULL;
X}
X
Xadd_ec_val(name, val, description)
X	char const *name, *val, *description;
X{
X	const int ncurrent = atoi(val);
X	if (ncurrent < current) {
X		printf("Error code %s (%d) out of order", name,
X		       current);
X		return;
X	}
X      
X	while (ncurrent > current)
X	     fputs("\t(char *)NULL,\n", cfile), current++;
X	
X	fprintf(cfile, "\t\"%s\",\n", description);
X	if (error_codes == (char **)NULL) {
X		error_codes = (char **)malloc(sizeof(char *));
X		*error_codes = (char *)NULL;
X	}
X	error_codes = (char **)realloc((char *)error_codes,
X				       (current + 2)*sizeof(char *));
X	error_codes[current++] = ds(name);
X	error_codes[current] = (char *)NULL;
X} 
X
Xput_ecs()
X{
X	int i;
X	for (i = 0; i < current; i++) {
X	     if (error_codes[i] != (char *)NULL)
X		  fprintf(hfile, "#define %-40s (%ldL)\n",
X			  error_codes[i], table_number + i);
X	}
X}
X
X/*
X * char_to_num -- maps letters and numbers into a small numbering space
X * 	uppercase ->  1-26
X *	lowercase -> 27-52
X *	digits    -> 53-62
X *	underscore-> 63
X */
X
Xstatic const char char_set[] =
X	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_";
X
Xint char_to_num(c)
X	char c;
X{
X	const char *where;
X	int diff;
X
X	where = strchr (char_set, c);
X	if (where) {
X		diff = where - char_set + 1;
X		assert (diff < (1 << ERRCODE_RANGE));
X		return diff;
X	}
X	else if (isprint (c))
X		fprintf (stderr,
X			 "Illegal character `%c' in error table name\n",
X			 c);
X	else
X		fprintf (stderr,
X			 "Illegal character %03o in error table name\n",
X			 c);
X	exit (1);
X}
X
Xset_table_num(string)
X	char *string;
X{
X	if (char_to_num (string[0]) > char_to_num ('z')) {
X		fprintf (stderr, "%s%s%s%s",
X			 "First character of error table name must be ",
X			 "a letter; name ``",
X			 string, "'' rejected\n");
X		exit (1);
X	}
X	if (strlen(string) > 4) {
X		fprintf(stderr, "Table name %s too long, truncated ",
X			string);
X		string[4] = '\0';
X		fprintf(stderr, "to %s\n", string);
X	}
X	while (*string != '\0') {
X		table_number = (table_number << BITS_PER_CHAR)
X			+ char_to_num(*string);
X		string++;
X	}
X	table_number = table_number << ERRCODE_RANGE;
X}
X
X#include "et_lex.lex.c"
END_OF_FILE
if test 4747 -ne `wc -c <'error_table.y'`; then
    echo shar: \"'error_table.y'\" unpacked with wrong size!
fi
# end of 'error_table.y'
fi
if test -f 'et_lex.lex.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'et_lex.lex.l'\"
else
echo shar: Extracting \"'et_lex.lex.l'\" \(600 characters\)
sed "s/^X//" >'et_lex.lex.l' <<'END_OF_FILE'
XPC	[^\"]
XAN	[A-Z_a-z0-9]
X%{
X#include <strings.h>
X%}
X%%
X
Xerror_table	return ERROR_TABLE;
Xet		return ERROR_TABLE;
Xerror_code	return ERROR_CODE_ENTRY;
Xec		return ERROR_CODE_ENTRY;
Xend		return END;
X
X[\t\n ]		;
X
X\"{PC}*\"	{ register char *p; yylval.dynstr = ds(yytext+1);
X		  if (p=rindex(yylval.dynstr, '"')) *p='\0';
X		  return QUOTED_STRING;
X		}
X
X{AN}*	{ yylval.dynstr = ds(yytext); return STRING; }
X
X#.*\n		;
X
X.		{ return (*yytext); }
X%%
X#ifndef lint
Xstatic char rcsid_et_lex_lex_l[] = "$Header: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/et_lex.lex.l,v 1.2 89/11/07 19:00:35 jik Exp $";
X#endif
END_OF_FILE
if test 600 -ne `wc -c <'et_lex.lex.l'`; then
    echo shar: \"'et_lex.lex.l'\" unpacked with wrong size!
fi
# end of 'et_lex.lex.l'
fi
if test -f 'et_name.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'et_name.c'\"
else
echo shar: Extracting \"'et_name.c'\" \(1131 characters\)
sed "s/^X//" >'et_name.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 by MIT Student Information Processing Board
X *
X * For copyright info, see mit-sipb-copyright.h.
X */
X
X#include "error_table.h"
X#include "mit-sipb-copyright.h"
X#include "internal.h"
X
X#ifndef	lint
Xstatic const char copyright[] =
X    "Copyright 1987,1988 by Student Information Processing Board, Massachusetts Institute of Technology";
Xstatic const char rcsid_et_name_c[] =
X    "$Header: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/et_name.c,v 1.1 89/11/07 19:05:32 jik Exp $";
X#endif
X
Xstatic const char char_set[] =
X	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_";
X
Xstatic char buf[6];
X
Xconst char * error_table_name(num)
X    int num;
X{
X    int ch;
X    int i;
X    char *p;
X
X    /* num = aa aaa abb bbb bcc ccc cdd ddd d?? ??? ??? */
X    p = buf;
X    num >>= ERRCODE_RANGE;
X    /* num = ?? ??? ??? aaa aaa bbb bbb ccc ccc ddd ddd */
X    num &= 077777777;
X    /* num = 00 000 000 aaa aaa bbb bbb ccc ccc ddd ddd */
X    for (i = 4; i >= 0; i--) {
X	ch = (num >> BITS_PER_CHAR * i) & ((1 << BITS_PER_CHAR) - 1);
X	if (ch != 0)
X	    *p++ = char_set[ch-1];
X    }
X    *p = '\0';
X    return(buf);
X}
END_OF_FILE
if test 1131 -ne `wc -c <'et_name.c'`; then
    echo shar: \"'et_name.c'\" unpacked with wrong size!
fi
# end of 'et_name.c'
fi
if test -f 'init_et.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'init_et.c'\"
else
echo shar: Extracting \"'init_et.c'\" \(1278 characters\)
sed "s/^X//" >'init_et.c' <<'END_OF_FILE'
X/*
X * $Header: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/init_et.c,v 1.1 89/11/07 19:05:34 jik Exp $
X * $Source: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/init_et.c,v $
X * $Locker:  $
X *
X * Copyright 1986, 1987, 1988 by MIT Information Systems and
X *	the MIT Student Information Processing Board.
X *
X * For copyright info, see mit-sipb-copyright.h.
X */
X
X#include <stdio.h>
X#include "error_table.h"
X#include "mit-sipb-copyright.h"
X
X#ifndef __STDC__
X#define const
X#endif
X
X#ifndef	lint
Xstatic const char rcsid_init_et_c[] =
X    "$Header: /afs/athena.mit.edu/user/j/jik/src/delete/et/RCS/init_et.c,v 1.1 89/11/07 19:05:34 jik Exp $";
X#endif
X
Xextern char *malloc(), *realloc();
X
Xstruct foobar {
X    struct et_list etl;
X    struct error_table et;
X};
X
Xextern struct et_list * _et_list;
X
Xint init_error_table(msgs, base, count)
X    const char * const * msgs;
X    int base;
X    int count;
X{
X    struct foobar * new_et;
X
X    if (!base || !count || !msgs)
X	return 0;
X
X    new_et = (struct foobar *) malloc(sizeof(struct foobar));
X    if (!new_et)
X	return errno;	/* oops */
X    new_et->etl.table = &new_et->et;
X    new_et->et.msgs = msgs;
X    new_et->et.base = base;
X    new_et->et.n_msgs= count;
X
X    new_et->etl.next = _et_list;
X    _et_list = &new_et->etl;
X    return 0;
X}
END_OF_FILE
if test 1278 -ne `wc -c <'init_et.c'`; then
    echo shar: \"'init_et.c'\" unpacked with wrong size!
fi
# end of 'init_et.c'
fi
if test -f 'internal.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'internal.h'\"
else
echo shar: Extracting \"'internal.h'\" \(290 characters\)
sed "s/^X//" >'internal.h' <<'END_OF_FILE'
X/*
X * internal include file for com_err package
X */
X#include "mit-sipb-copyright.h"
X#ifndef __STDC__
X#undef const
X#define const
X#endif
X
Xextern int errno;
Xextern char const * const sys_errlist[];
Xextern const int sys_nerr;
X
X#if !defined(__STDC__) || defined(__HIGHC__)
Xint perror ();
X#endif
END_OF_FILE
if test 290 -ne `wc -c <'internal.h'`; then
    echo shar: \"'internal.h'\" unpacked with wrong size!
fi
# end of 'internal.h'
fi
if test -f 'mit-sipb-copyright.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mit-sipb-copyright.h'\"
else
echo shar: Extracting \"'mit-sipb-copyright.h'\" \(769 characters\)
sed "s/^X//" >'mit-sipb-copyright.h' <<'END_OF_FILE'
X/*
X
XCopyright 1987, 1988 by the Student Information Processing Board
X	of the Massachusetts Institute of Technology
X
XPermission to use, copy, modify, and distribute this software
Xand its documentation for any purpose and without fee is
Xhereby granted, provided that the above copyright notice
Xappear in all copies and that both that copyright notice and
Xthis permission notice appear in supporting documentation,
Xand that the names of M.I.T. and the M.I.T. S.I.P.B. not be
Xused in advertising or publicity pertaining to distribution
Xof the software without specific, written prior permission.
XM.I.T. and the M.I.T. S.I.P.B. make no representations about
Xthe suitability of this software for any purpose.  It is
Xprovided "as is" without express or implied warranty.
X
X*/
X
END_OF_FILE
if test 769 -ne `wc -c <'mit-sipb-copyright.h'`; then
    echo shar: \"'mit-sipb-copyright.h'\" unpacked with wrong size!
fi
# end of 'mit-sipb-copyright.h'
fi
if test ! -d 'profiled' ; then
    echo shar: Creating directory \"'profiled'\"
    mkdir 'profiled'
fi
if test -f 'strcasecmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'strcasecmp.c'\"
else
echo shar: Extracting \"'strcasecmp.c'\" \(3767 characters\)
sed "s/^X//" >'strcasecmp.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1987 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)strcasecmp.c	5.6 (Berkeley) 6/27/88";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/types.h>
X
X/*
X * This array is designed for mapping upper and lower case letter
X * together for a case independent comparison.  The mappings are
X * based upon ascii character sequences.
X */
Xstatic u_char charmap[] = {
X	'\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
X	'\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
X	'\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
X	'\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
X	'\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
X	'\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
X	'\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
X	'\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
X	'\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
X	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
X	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
X	'\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
X	'\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
X	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
X	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
X	'\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
X	'\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
X	'\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
X	'\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
X	'\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
X	'\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
X	'\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
X	'\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
X	'\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
X	'\300', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
X	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
X	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
X	'\370', '\371', '\372', '\333', '\334', '\335', '\336', '\337',
X	'\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
X	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
X	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
X	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
X};
X
Xstrcasecmp(s1, s2)
X	char *s1, *s2;
X{
X	register u_char	*cm = charmap,
X			*us1 = (u_char *)s1,
X			*us2 = (u_char *)s2;
X
X	while (cm[*us1] == cm[*us2++])
X		if (*us1++ == '\0')
X			return(0);
X	return(cm[*us1] - cm[*--us2]);
X}
X
Xstrncasecmp(s1, s2, n)
X	char *s1, *s2;
X	register int n;
X{
X	register u_char	*cm = charmap,
X			*us1 = (u_char *)s1,
X			*us2 = (u_char *)s2;
X
X	while (--n >= 0 && cm[*us1] == cm[*us2++])
X		if (*us1++ == '\0')
X			return(0);
X	return(n < 0 ? 0 : cm[*us1] - cm[*--us2]);
X}
END_OF_FILE
if test 3767 -ne `wc -c <'strcasecmp.c'`; then
    echo shar: \"'strcasecmp.c'\" unpacked with wrong size!
fi
# end of 'strcasecmp.c'
fi
if test -f 'test.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test.c'\"
else
echo shar: Extracting \"'test.c'\" \(1798 characters\)
sed "s/^X//" >'test.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <errno.h>
X#include "com_err.h"
X#include "test1.h"
X#include "test2.h"
X
Xextern int sys_nerr, errno;
X
Xmain()
X{
X	printf("Before initiating error table:\n\n");
X	printf("Table name '%s'\n", error_table_name(KRB_MK_AP_TGTEXP));
X	printf("UNIX  name '%s'\n", error_table_name(EPERM));
X	printf("Msg TGT-expired is '%s'\n", error_message(KRB_MK_AP_TGTEXP));
X	printf("Msg EPERM is '%s'\n", error_message(EPERM));
X	printf("Msg FOO_ERR is '%s'\n", error_message(FOO_ERR));
X	printf("Msg {sys_nerr-1} is '%s'\n", error_message(sys_nerr-1));
X	printf("Msg {sys_nerr} is '%s'\n", error_message(sys_nerr));
X
X	printf("With 0: tgt-expired -> %s\n", error_message(KRB_MK_AP_TGTEXP));
X
X	initialize_krb_error_table();
X	printf("KRB error table initialized:  base %d (%s), name %s\n",
X	       ERROR_TABLE_BASE_krb, error_message(ERROR_TABLE_BASE_krb),
X	       error_table_name(ERROR_TABLE_BASE_krb));
X	initialize_krb_error_table();
X	printf("With krb: tgt-expired -> %s\n",
X	       error_message(KRB_MK_AP_TGTEXP));
X
X	initialize_quux_error_table();
X	printf("QUUX error table initialized: base %d (%s), name %s\n",
X	       ERROR_TABLE_BASE_quux, error_message(ERROR_TABLE_BASE_quux),
X	       error_table_name(ERROR_TABLE_BASE_quux));
X
X	printf("Msg for TGT-expired is '%s'\n",
X	       error_message(KRB_MK_AP_TGTEXP));
X	printf("Msg {sys_nerr-1} is '%s'\n", error_message(sys_nerr-1));
X	printf("Msg FOO_ERR is '%s'\n", error_message(FOO_ERR));
X	printf("Msg KRB_SKDC_CANT is '%s'\n",
X		    error_message(KRB_SKDC_CANT));
X	printf("Msg 1e6 (8B 64) is '%s'\n", error_message(1000000));
X	printf("\n\nCOM_ERR tests:\n");
X	com_err("whoami", FOO_ERR, (char *)NULL);
X	com_err("whoami", FOO_ERR, " -- message goes %s", "here");
X	com_err("whoami", 0, (char *)0);
X	com_err("whoami", 0, "error number %d\n", 0);
X}
END_OF_FILE
if test 1798 -ne `wc -c <'test.c'`; then
    echo shar: \"'test.c'\" unpacked with wrong size!
fi
# end of 'test.c'
fi
if test -f 'test1.et' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test1.et'\"
else
echo shar: Extracting \"'test1.et'\" \(1129 characters\)
sed "s/^X//" >'test1.et' <<'END_OF_FILE'
X	error_table	krb
X
X	error_code	KRB_MK_AP_TKFIL,
X			"Can't read ticket file"
X
X	ec		KRB_MK_AP_NOTKT,
X			"Can't find ticket or TGT"
X
X	ec		KRB_MK_AP_TGTEXP,
X			"TGT expired"
X
X	ec		KRB_RD_AP_UNDEC,
X			"Can't decode authenticator"
X
X	ec		KRB_RD_AP_EXP,
X			"Ticket expired"
X
X	ec		KRB_RD_AP_REPEAT,
X			"Repeated request"
X
X	ec		KRB_RD_AP_NOT_US,
X			"The ticket isn't for us"
X
X	ec		KRB_RD_AP_INCON,
X			"Request is inconsistent"
X
X	ec		KRB_RD_AP_TIME,
X			"Delta-T too big"
X
X	ec		KRB_RD_AP_BADD,
X			"Incorrect net address"
X
X	ec		KRB_RD_AP_VERSION,
X			"Protocol version mismatch"
X
X	ec		KRB_RD_AP_MSG_TYPE,
X			"Invalid message type"
X
X	ec		KRB_RD_AP_MODIFIED,
X			"Message stream modified"
X
X	ec		KRB_RD_AP_ORDER,
X			"Message out of order"
X
X	ec		KRB_RD_AP_UNAUTHOR,
X			"Unauthorized request"
X
X	ec		KRB_GT_PW_NULL,
X			"Current password is null"
X
X	ec		KRB_GT_PW_BADPW,
X			"Incorrect current password"
X
X	ec		KRB_GT_PW_PROT,
X			"Protocol error"
X
X	ec		KRB_GT_PW_KDCERR,
X			"Error returned by KDC"
X
X	ec		KRB_GT_PW_NULLTKT,
X			"Null ticket returned by KDC"
X
X	ec		KRB_SKDC_RETRY,
X			"Retry count exceeded"
X
X	ec		KRB_SKDC_CANT,
X			"Can't send request"
X
X	end
END_OF_FILE
if test 1129 -ne `wc -c <'test1.et'`; then
    echo shar: \"'test1.et'\" unpacked with wrong size!
fi
# end of 'test1.et'
fi
if test -f 'test2.et' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test2.et'\"
else
echo shar: Extracting \"'test2.et'\" \(85 characters\)
sed "s/^X//" >'test2.et' <<'END_OF_FILE'
X	error_table	quux
X
X	ec	FOO_ERR, "foo"
X
X	ec	BAR_ERR, "bar"
X
X	ec	BAZ_ERR, "meow"
X
X	end
END_OF_FILE
if test 85 -ne `wc -c <'test2.et'`; then
    echo shar: \"'test2.et'\" unpacked with wrong size!
fi
# end of 'test2.et'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
exit 0 # Just in case...
-- 
Please send comp.sources.unix-related mail to rsalz@uunet.uu.net.
Use a domain-based address or give alternate paths, or you may lose out.
