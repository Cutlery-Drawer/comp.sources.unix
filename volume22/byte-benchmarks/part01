Subject:  v22i028:  Byte Unix benchmarks, Part01/05
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: d9eb219b 0a77ea3d d4ea3797 fe88a8d8

Submitted-by: "Ben Smith @ BYTE" <ben@bytepb.byte.com>
Posting-number: Volume 22, Issue 28
Archive-name: byte-benchmarks/part01

[  I repacked this.  Look out for the BEL character on line 24 of cleanup.
   These are the BYTE Unix benchmarks, for measuring the performance of
   Unix systems.  The Makefile will distribute the pieces into
   subdirectories, then run the tests.  The tests can also be run in
   clumps.  BSD users will have to slightly tweak the Makefile, and rename
   a file.  For more information, see the README.  There is no manpage.
   --r$  ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 5)."
# Contents:  BSDtime.awk MANIFEST README SysVtime.awk arith.c
#   buildbms.c byte.logo cctest.c cleanup clock.c context1.c dbprep
#   dc.date dhry.awk execl.c fs.awk getopt.c hanoi.c limit.c mkperm.c
#   multi.sh pipe.c spawn.c syscall.c time.awk tst.sh
# Wrapped by rsalz@papaya.bbn.com on Tue May  8 08:55:27 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'BSDtime.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BSDtime.awk'\"
else
echo shar: Extracting \"'BSDtime.awk'\" \(1977 characters\)
sed "s/^X//" >'BSDtime.awk' <<'END_OF_FILE'
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 2
X#          Module: BSDtime.awk   SID: 2.3 4/17/90 16:45:40
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	ben@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X###############################################################################
X#  Modification Log:
X#     added geometric mean 8/6/89 -ben
X#
X###############################################################################
XBEGIN   { r_product = 0.0000; s_product = 0.0000; u_product = 0.0000; }
X/real/	{ if (!fail) {
X	    real+=$1;
X	    r2+=$1*$1;
X	    user+=$3;
X	    u2 += $3*$3;
X	    sys+=$5;
X	    s2 += $5*$5;
X	    if($1) { r_product += log($1); }
X	    if($1) { u_product += log($3); }
X	    if($1) { s_product += log($5); }
X	    ok++
X	  }
X          iter++; fail=0; next;
X	}
X	{ print "** Iteration ",iter+1," Failed: ",$0; fail=1 }
XEND {
X	if (fail) iter++;
X	if (ok != iter) {
X	    printf "For %d successful iterations from %d attempts ...\n",ok,iter
X	    iter=ok
X	}
X	if (ok > 0) {
X	    printf "                       Arithmetric        Geometric         Variance\n";
X	    printf "                              Mean             Mean         (%d tests)\n",ok
X	    printf "User Time (secs):        %9.2f        %9.2f         ",user/ok,exp(u_product/ok);
X	    if (ok > 1) printf "%9.2f\n",(u2-user*user/ok)/(ok-1);
X	    else printf "n/a\n"
X	    printf "System Time (secs):      %9.2f        %9.2f         ",sys/ok,exp(s_product/ok);
X	    if (ok > 1) printf "%9.2f\n",(s2-sys*sys/ok)/(ok-1);
X	    else printf "n/a\n"
X	    printf "Real Time (secs):        %9.2f        %9.2f         ",real/ok,exp(r_product/ok);
X	    if (ok > 1) printf "%9.2f\n",(r2-real*real/ok)/(ok-1);
X	    else printf "n/a\n"
X            }
X	else printf "-- no measured results --\n "
X	}
END_OF_FILE
if test 1977 -ne `wc -c <'BSDtime.awk'`; then
    echo shar: \"'BSDtime.awk'\" unpacked with wrong size!
fi
chmod +x 'BSDtime.awk'
# end of 'BSDtime.awk'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1292 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X BSDtime.awk                1	
X MANIFEST                   1	This shipping list
X Makefile                   2	
X README                     1	
X Run                        2	
X SysVtime.awk               1	
X arith.c                    1	
X bench.doc                  3	
X big.c                      3	
X buildbms.c                 1	
X byte.logo                  1	
X cctest.c                   1	
X cleanup                    1	
X clock.c                    1	
X context1.c                 1	
X dbmscli.c                  5	
X dbmserv.c                  3	
X dbprep                     1	
X dc.date                    1	
X dhry.awk                   1	
X dhry.c                     4	
X dhry.h                     4	
X dummy.c                    2	
X execl.c                    1	
X fs.awk                     1	
X fstime.c                   2	
X getopt.c                   1	
X hanoi.c                    1	
X limit.c                    1	
X mkperm.c                   1	
X multi.sh                   1	
X pipe.c                     1	
X precision.c                2	
X sort.src                   2	
X spawn.c                    1	
X syscall.c                  1	
X time.awk                   1	
X tst.sh                     1	
END_OF_FILE
if test 1292 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(4143 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XVersion 2.5 -- 4/17/90  16:45:28
X
X================================================================
XTo use the new BYTE Unix Benchmarks:
X
X   make all
X   Run
X
XThe results are stored in results/log. All logs are accumulated
Xin results/log.accum. Raw times for each run are stored in
Xresults/times.
X
XNotes:
XBSD & Ultrix users will have to change the makefile Define to
Xfrom SysV to BSD, and copy pgms/BSDtime.awk to pgms/time.awk.
XBe sure to check your compiler options for optimizing. When
Xoptimizing is supposed to be on (most tests), it should be set to
Xlevel 1 (generally -O), however different compilers have
Xdifferent options for "optimizer off."  Ultrix for RISC uses -O0;
XSCO uses -Od.  We have found that the memory tests can get
Xoptimized so that the memory is never really fetched. That is why
Xwe turn the optimizer off for these tests.
X
XBUG ALERT:
X
XBSD4v2 only: The time functions in the memory and and file
Xaccess tests appear to be incorrect.
X
X================================================================
XYou may run individual benchmark programs and groups of programs.
XThere are also a few options.
X
X  Run [<bench> ...] [<group> ...] [-qvd]
X
X	-q	quiet		no output to standard out
X	-v	verbose		extra output to standard out
X	-d	debug		Run is displayed as it is run
X
X     GROUP	BENCHMARK	EXPLANATION		SOURCE
X     --------   -----------	--------------------	-------------
X     arithmetic
X		arithoh		arithmetic overhead 	src/arith.c
X		register	register arithmetic	src/arith.c
X		short		short arithmetic	src/arith.c
X		int		int arithmetic		src/arith.c
X		long		long arithmetic		src/arith.c
X		float		float arithmetic	src/arith.c
X		double		double arithmetic	src/arith.c
X     system
X		syscall		system call overhead	src/syscall.c
X		pipe		pipe throughput		src/pipe.c
X		context1	pipe context switch	src/context1.c
X		spawn		process creation	src/spawn.c
X		execl		execl call		src/execl.c
X		fstime		filesystem throughput	src/fstime.c
X     misc
X		C		compile and link	/bin/cc
X		dc		calculations with dc	testdir/dc.dat
X		hanoi		recursion 		src/hanoi.c
X     dhry
X		dhry2		dhrystone 2 w/o regs	src/dhry.c
X		dhry2reg	dhrystone 2 with regs	src/dhry.c
X     db 
X		dbmscli		client/server		src/dbmscli.c
X        	dbmserv	        dbms engine		src/dbmserv.c
X     load
X		multi.sh	load system with	pgms/multi.sh
X				  concurrent shell	pgms/tst.sh
X				  scripts
X
X===================== RELEASE NOTES =====================================
X
X========================= Jan 90 =============================
XTom Yager has joined the effort here at BYTE; he is responsible
Xfor many refinements in the UNIX benchmarks.
X
XThe memory access tests have been deleted from the benchmarks.
XThe file access tests have been reversed so that the test is run
Xfor a fixed time. The amount of data transfered (written, read,
Xand copied) is the variable. !WARNING! This test can eat up a
Xlarge hunk of disk space.
X
XThe initial line of all shell scripts has been changed from the
XSCO and XENIX form (:) to the more standard form "#! /bin/sh".
XBut different systems handle shell switching differently. Check
Xthe documentation on your system and find out how you are
Xsupposed to do it. Or, simpler yet, just run the benchmarks from
Xthe Bourne shell. (You may need to set SHELL=/bin/sh as well.)
X
XThe options to Run have not been checked in a while. They may no
Xlonger function. Next time, I'll get back on them. There needs to
Xbe another option added (next time) that halts testing between
Xeach test. !WARNING! Some systems have caches that are not getting flushed
Xbefore the next test or iteration is run. This can cause
Xerroneous values. 
X
X========================= Sept 89 =============================
XThe database (db) programs now have a tuneable message queue space.
Xqueue space. The default set in the Run script is 1024 bytes.
XOther major changes are in the format of the times. We now show
XArithmetic and Geometric mean and standard deviation for User
XTime, System Time, and Real Time. Generally, in reporting, we
Xplan on using the Real Time values with the benchs run with one
Xactive user (the bench user). Comments and arguments are requested.
X
Xcontact: BIX bensmith or rick_g
END_OF_FILE
if test 4143 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
chmod +x 'README'
# end of 'README'
fi
if test -f 'SysVtime.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'SysVtime.awk'\"
else
echo shar: Extracting \"'SysVtime.awk'\" \(2200 characters\)
sed "s/^X//" >'SysVtime.awk' <<'END_OF_FILE'
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 2
X#          Module: SysVtime.awk   SID: 2.3 4/17/90 16:45:39
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	ben@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X###############################################################################
X#  Modification Log:
X#       added geometric mean 8/6/89 -ben
X#
X###############################################################################
XBEGIN      { r_product = 0.0000; s_product = 0.0000 ; u_product = 0.0000 }
X/^cctest.c$/	{ next }
X/^[Rr]eal/ {
X	if (!fail) {
X	    l=length($2); m=substr($2,1,l-5); s=substr($2,l-3,4)
X	    t=m*60+s; real+=t; r2+=t*t; ok++;
X	    if (t) {r_product += log(t);}
X	}
X	iter++; fail=0; next }
X/^[Uu]ser/ {
X	l=length($2); m=substr($2,1,l-5); s=substr($2,l-3,4)
X	t=m*60+s; user+=t; cpu=t; u2+=t*t;
X	if (t) { u_product += log(t);}
X	next; }
X/^[Ss]ys/ {
X	l=length($2); m=substr($2,1,l-5); s=substr($2,l-3,4)
X	t=m*60+s; sys+=t; s2+=t*t; 
X	if (t) { s_product += log(t);}
X	next; }
X/^$/	{ next }
X	{ print "** Iteration ",iter+1," Failed: ",$0; fail=1 }
XEND {
X	if (fail) iter++
X	if (ok != iter) {
X	    printf "For %d successful iterations from %d attempts ...\n",ok,iter
X	    iter=ok;
X	}
X	if (ok > 0) {
X	    printf "                       Arithmetric        Geometric         Variance\n";
X	    printf "                              Mean             Mean         (%d tests)\n",ok
X	    printf "User Time (secs):        %9.2f        %9.2f         ",user/ok,exp(u_product/ok);
X	    if (ok > 1) printf "%9.2f\n",(u2-user*user/ok)/(ok-1);
X	    else printf "n/a\n"
X	    printf "System Time (secs):      %9.2f        %9.2f         ",sys/ok,exp(s_product/ok);
X	    if (ok > 1) printf "%9.2f\n",(s2-sys*sys/ok)/(ok-1);
X	    else printf "n/a\n"
X	    printf "Real Time (secs):        %9.2f        %9.2f         ",real/ok,exp(r_product/ok);
X	    if (ok > 1) printf "%9.2f\n",(r2-real*real/ok)/(ok-1);
X	    else printf "n/a\n"
X	} else {
X	    print "-- no measured results --"
X	}
X    }
END_OF_FILE
if test 2200 -ne `wc -c <'SysVtime.awk'`; then
    echo shar: \"'SysVtime.awk'\" unpacked with wrong size!
fi
chmod +x 'SysVtime.awk'
# end of 'SysVtime.awk'
fi
if test -f 'arith.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'arith.c'\"
else
echo shar: Extracting \"'arith.c'\" \(1582 characters\)
sed "s/^X//" >'arith.c' <<'END_OF_FILE'
X
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: arith.c   SID: 2.4 4/17/90 16:45:31
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *  May 12, 1989 - modified empty loops to avoid nullifying by optimizing
X *                 compilers
X *
X ******************************************************************************/
X
Xchar SCCSid[] = "@(#) @(#)arith.c:2.4 -- 4/17/90 16:45:31";
X/*
X *  arithmetic test
X *
X */
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	int	iter;
X	int	i;
X	int result;
X
X	if (argc != 2) {
X		printf("Usage: %s count\n", argv[0]);
X		exit(1);
X	}
X
X	iter = atoi(argv[1]);
X
X	while (iter-- > 0) 
X	{
X	/* the loop calls a function to insure that something is done */
X	/* the results of the function are thrown away. But a loop with */
X	/* unused assignments may get optimized out of existence */
X	result = dumb_stuff(i);
X	}
X	exit(0);
X}
X
X
X/************************** dumb_stuff *******************/
Xdumb_stuff(i)
Xint i;
X{
X#ifndef arithoh
X	datum	x, y, z;
X		z = 0;
X#endif
X		/*
X		 *     101
X		 * sum       i*i/(i*i-1)
X		 *     i=2
X		 */
X		for (i=2; i<=101; i++) 
X			{
X#ifndef arithoh
X			x = i;
X			y = x*x;
X			z += y/(y-1);
X			}
Xreturn(x+y+z);
X#else
X			}
Xreturn(0);
X#endif
X}
END_OF_FILE
if test 1582 -ne `wc -c <'arith.c'`; then
    echo shar: \"'arith.c'\" unpacked with wrong size!
fi
chmod +x 'arith.c'
# end of 'arith.c'
fi
if test -f 'buildbms.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'buildbms.c'\"
else
echo shar: Extracting \"'buildbms.c'\" \(3857 characters\)
sed "s/^X//" >'buildbms.c' <<'END_OF_FILE'
X
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: buildbms.c   SID: 2.4 4/17/90 16:45:38
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *
X ******************************************************************************/
X/*
X * Multi-user DBMS simulation.
X * Initialization
X * Database has the form:
X * IIIINNNNNNNNNNNNNNNNNNNNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPPPPPPPPPP
X * Where IIII is the 4-digit id number (0-padded)
X *       NN... is the 20-character name
X *       AA... is the 40-character address
X *       PP... is the 10-character phone number
X * Records are accessed by ID number (1 is the 0th record, 2 is 1st..etc.)
X *
X * Execute this program with:
X *    buildbms <filename> <n>
X *      where <filename> is the name of the database file and
X *            <n> is the number of records to create in the database.
X */
Xchar id[] = "@(#) @(#)buildbms.c:2.4 -- 4/17/90 16:45:38";
X
X#include <stdio.h>
X
X#define ERROR (-1)
X
X/*
X** Record definitions.
X*/
X
X#define IDLEN 4
X#define NAMELEN 20
X#define ADDRLEN 40
X#define PHONLEN 10
X#define RECLEN  74	/* Sum of the above. */
X
X/*
X** Structures.
X*/
X
Xstruct dbrec {			/* Database record */
X	char id[IDLEN];
X	char name[NAMELEN];
X	char address[ADDRLEN];
X	char phone[PHONLEN];
X	};
X
X/*
X** Structure instances.
X*/
Xstruct dbrec myrec;
X
XFILE *dbfp;			/* Pointer for database file */
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X
X{
X
X	int i,j;		/* Loop variables */
X
X	/*
X	** Make sure we have the proper data.
X	*/
X	if(argc!=3)
X	{
X		fprintf(stderr,"usage: %s <filename> <n>\n",argv[0]);
X		exit(1);
X	}
X	/*
X	** Create the file. 
X	** Also notice that we are using binary mode.
X	*/
X	if((dbfp=fopen(argv[1],"a+"))==NULL)
X	{
X		fprintf(stderr,"**Open error on: %s\n",argv[1]);
X		exit(1);
X	}
X
X	j=atoi(argv[2]);
X	for(i=0;i<j;i++)
X	{
X		sprintf(myrec.id,"%#04d",i+1);
X		loadrec(i%10);
X		fwrite((char *)&myrec,RECLEN,1,dbfp);
X	}
X
X	fclose(dbfp);
X	exit(0);
X}
X
X/*
X** Load the record up with random data.
X*/
Xloadrec(sel)
Xint sel;		/* Select which fake record */
X
X{
X
X	char *nname;
X	char *naddr;
X	char *nphon;
X
X	switch(sel)
X	{
X	case 0:	nname="Tom Thompson        ";
X		naddr="9401 Billy Willy Road                   ";
X		nphon="3334442222";
X		break;
X	case 1: nname="Steve Apiki         ";
X		naddr="50 Hawaii Way c/o Jack Lord             ";
X		nphon="1234443333";
X		break;
X	case 2: nname="Stan Diehl          ";
X		naddr="27 Hoptoad Hollow Way                   ";
X		nphon="3332221111";
X		break;
X	case 3: nname="Judy Grehan         ";
X		naddr="Suite 3, WallState Building             ";
X		nphon="9995556666";
X		break;
X	case 4: nname="Aaron Richards      ";
X		naddr="Highway 40 OverPass, Second Pylon       ";
X		nphon="8883339999";
X		break;
X	case 5: nname="Benjamin Davidson   ";
X		naddr="Under The Bridge, HeavyWater City       ";
X		nphon="7773229988";
X		break;
X	case 6: nname="Dayle Woolston      ";
X		naddr="4040 Pleasant Way, WICAT Central        ";
X		nphon="2228332299";
X		break;
X	case 7: nname="Jim Carls           ";
X		naddr="Big Oak Tree Behind Barsodie's          ";
X		nphon="32244566657";
X		break;
X	case 8: nname="Steve Smith         ";
X		naddr="7000 Aloth Cove                         ";
X		nphon="2118332929";
X		break;
X	case 9: 
X	default: nname="Blind Willy Chitlins";
X		naddr="Unavailable Until Further Notice        ";
X		nphon="3456789012";
X		break;
X	}
X
X	/*
X	** Fill the structure with fake data.
X	*/
X	strncpy(myrec.name,nname,NAMELEN);
X	strncpy(myrec.address,naddr,ADDRLEN);
X	strncpy(myrec.phone,nphon,PHONLEN);
X
X	return;
X}
X
X
END_OF_FILE
if test 3857 -ne `wc -c <'buildbms.c'`; then
    echo shar: \"'buildbms.c'\" unpacked with wrong size!
fi
chmod +x 'buildbms.c'
# end of 'buildbms.c'
fi
if test -f 'byte.logo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'byte.logo'\"
else
echo shar: Extracting \"'byte.logo'\" \(1309 characters\)
sed "s/^X//" >'byte.logo' <<'END_OF_FILE'
X
X ############   #####        ## ############### ###############
X ############## #####        ## ############### ###############
X #####       ## #####        ##      #####      #####         
X #####       ## #####        ##      #####      #####         
X #####       ## #####        ##      #####      #####         
X ############   #####       ##       #####      ###############
X #############   ######### ##        #####      ###############
X #####       ##   ##########         #####      #####         
X #####       ##      #####           #####      #####         
X #####       ##      #####           #####      #####         
X #####       ##      #####           #####      #####         
X ##############      #####           #####      ###############
X ############        #####           #####      ###############
X
X
X #    #  #    #     #    #    #          #####   ######  #    #   ####   #    #
X #    #  ##   #     #     #  #           #    #  #       ##   #  #    #  #    #
X #    #  # #  #     #      ##            #####   #####   # #  #  #       ######
X #    #  #  # #     #      ##            #    #  #       #  # #  #       #    #
X #    #  #   ##     #     #  #           #    #  #       #   ##  #    #  #    #
X  ####   #    #     #    #    #          #####   ######  #    #   ####   #    #
X
END_OF_FILE
if test 1309 -ne `wc -c <'byte.logo'`; then
    echo shar: \"'byte.logo'\" unpacked with wrong size!
fi
chmod +x 'byte.logo'
# end of 'byte.logo'
fi
if test -f 'cctest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cctest.c'\"
else
echo shar: Extracting \"'cctest.c'\" \(3552 characters\)
sed "s/^X//" >'cctest.c' <<'END_OF_FILE'
X
X
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: cctest.c   SID: 2.4 4/17/90 16:45:31
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X * $Header: cctest.c,v 3.4 87/06/22 14:22:47 kjmcdonell Beta $
X *
X ******************************************************************************/
Xchar SCCSid[] = "@(#) @(#)cctest.c:2.4 -- 4/17/90 16:45:31";
X#include <stdio.h>
X/*
X * C compile and load speed test file.
X * Based upon fstime.c from MUSBUS 3.1, with all calls to ftime() replaced
X * by calls to time().  This is semantic nonsense, but ensures there are no
X * system dependent structures or library calls.
X *
X */
X#define NKBYTE 20
Xchar buf[BUFSIZ];
X
Xmain(argc, argv)
Xchar **argv;
X{
X    int		n = NKBYTE;
X    int		nblock;
X    int		f;
X    int		g;
X    int		i;
X    int		xfer, t;
X    struct	{	/* FAKE */
X	int	time;
X	int	millitm;
X    } now, then;
X
X    if (argc > 0)
X	/* ALWAYS true, so NEVER execute this program! */
X	exit(4);
X    if (argc > 1)
X	n = atoi(argv[1]);
X#if debug
X    printf("File size: %d Kbytes\n", n);
X#endif
X    nblock = (n * 1024) / BUFSIZ;
X
X    if (argc == 3 && chdir(argv[2]) != -1) {
X#if debug
X	printf("Create files in directory: %s\n", argv[2]);
X#endif
X    }
X    close(creat("dummy0", 0600));
X    close(creat("dummy1", 0600));
X    f = open("dummy0", 2);
X    g = open("dummy1", 2);
X    unlink("dummy0");
X    unlink("dummy1");
X    for (i = 0; i < sizeof(buf); i++)
X	buf[i] = i & 0177;
X
X    time();
X    for (i = 0; i < nblock; i++) {
X	if (write(f, buf, sizeof(buf)) <= 0)
X	    perror("fstime: write");
X    }
X    time();
X#if debug
X    printf("Effective write rate: ");
X#endif
X    i = now.millitm - then.millitm;
X    t = (now.time - then.time)*1000 + i;
X    if (t > 0) {
X	xfer = nblock * sizeof(buf) * 1000 / t;
X#if debug
X	printf("%d bytes/sec\n", xfer);
X#endif
X    }
X#if debug
X    else
X	printf(" -- too quick to time!\n");
X#endif
X#if awk
X    fprintf(stderr, "%.2f", t > 0 ? (float)xfer/1024 : 0);
X#endif
X
X    sync();
X    sleep(5);
X    sync();
X    lseek(f, 0L, 0);
X    time();
X    for (i = 0; i < nblock; i++) {
X	if (read(f, buf, sizeof(buf)) <= 0)
X	    perror("fstime: read");
X    }
X    time();
X#if debug
X    printf("Effective read rate: ");
X#endif
X    i = now.millitm - then.millitm;
X    t = (now.time - then.time)*1000 + i;
X    if (t > 0) {
X	xfer = nblock * sizeof(buf) * 1000 / t;
X#if debug
X	printf("%d bytes/sec\n", xfer);
X#endif
X    }
X#if debug
X    else
X	printf(" -- too quick to time!\n");
X#endif
X#if awk
X    fprintf(stderr, " %.2f", t > 0 ? (float)xfer/1024 : 0);
X#endif
X
X    sync();
X    sleep(5);
X    sync();
X    lseek(f, 0L, 0);
X    time();
X    for (i = 0; i < nblock; i++) {
X	if (read(f, buf, sizeof(buf)) <= 0)
X	    perror("fstime: read in copy");
X	if (write(g, buf, sizeof(buf)) <= 0)
X	    perror("fstime: write in copy");
X    }
X    time();
X#if debug
X    printf("Effective copy rate: ");
X#endif
X    i = now.millitm - then.millitm;
X    t = (now.time - then.time)*1000 + i;
X    if (t > 0) {
X	xfer = nblock * sizeof(buf) * 1000 / t;
X#if debug
X	printf("%d bytes/sec\n", xfer);
X#endif
X    }
X#if debug
X    else
X	printf(" -- too quick to time!\n");
X#endif
X#if awk
X    fprintf(stderr, " %.2f\n", t > 0 ? (float)xfer/1024 : 0);
X#endif
X
X}
END_OF_FILE
if test 3552 -ne `wc -c <'cctest.c'`; then
    echo shar: \"'cctest.c'\" unpacked with wrong size!
fi
chmod +x 'cctest.c'
# end of 'cctest.c'
fi
if test -f 'cleanup' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cleanup'\"
else
echo shar: Extracting \"'cleanup'\" \(2271 characters\)
sed "s/^X//" >'cleanup' <<'END_OF_FILE'
X#! /bin/sh
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 2
X#          Module: cleanup   SID: 2.3 4/17/90 16:45:39
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	ben@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X###############################################################################
X#  Modification Log:
X#  added report for dhrystones 6/89 - ben
X#
X###############################################################################
XID="@(#)cleanup:2.3 -- 4/17/90 16:45:39";
X#
X# $Header: cleanup,v 5.2 88/01/07 10:58:24 kenj Exp $
X#
X#  Cleanup when an iterative test terminates
X#
XBINDIR=${BINDIR-./pgms}
Xbell=""
Xlog=${LOG-./results/log}
Xtimeaccum=${TIMEACCUM-./results/times}
Xwhile ( test $# -ge 1 )
Xdo
X    opt=$1
X    shift
X    case $opt
X    in
X
X    -a) : abort
X	echo '' >>$LOGFILE
X	echo '**************************' >>$LOGFILE
X	echo '* Benchmark Aborted .... *' >>$LOGFILE
X	echo '**************************' >>$LOGFILE
X	echo
X	echo 'Benchmark Aborted ....'    # notice displayed on screen
X	echo "" >>$LOGFILE
X	echo " " `who | wc -l` "interactive users." >>$LOGFILE
X	echo "" >>$LOGFILE
X	date=`date`
X	echo "End Benchmark Run ($date) ...." >>$LOGFILE
X	echo "End Benchmark Run ($date) ...."
X	;;
X
X
X    -f) : filesystem throughput
X	awk -f ${BINDIR}/fs.awk <$1 >>$LOGFILE
X	cat $1 >> $timeaccum 2>/dev/null
X	rm -f $1
X	shift
X	;;
X    
X    -d) : dhrystone evaluation
X	awk -f ${BINDIR}/dhry.awk <$1 >>$LOGFILE
X	cat $1 >> $timeaccum 2>/dev/null
X	rm -f $1
X	shift
X	;;
X    
X    -i) : report last iteration
X	echo "Terminated during iteration $1" >>$LOGFILE
X	shift
X	;;
X
X    -l) : logfile
X	LOGFILE=$1
X	shift
X	;;
X    
X    -r) : reason for failure
X	echo $1
X	echo $1 >>$LOGFILE
X	shift
X	;;
X
X    -m) : mem throughput tests
X	awk -f ${BINDIR}/mem.awk <$1 >>$LOGFILE
X	cat $1 >> $timeaccum 2>/dev/null
X	rm -f $1
X	shift
X	;;
X
X    -t) : timing with /bin/time
X	awk -f ${BINDIR}/time.awk <$1 >>$LOGFILE
X	cat $1 >> $timeaccum 2>/dev/null
X	rm -f $1
X	shift
X	;;
X
X    '') : 'skip it (residual effect of shifts)'
X	;;
X
X    *)
X	echo "cleanup: bad option ($opt)" >>$LOGFILE
Xesac
Xdone
Xexit
END_OF_FILE
echo shar: 1 control character may be missing from \"'cleanup'\"
if test 2271 -ne `wc -c <'cleanup'`; then
    echo shar: \"'cleanup'\" unpacked with wrong size!
fi
chmod +x 'cleanup'
# end of 'cleanup'
fi
if test -f 'clock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'clock.c'\"
else
echo shar: Extracting \"'clock.c'\" \(2496 characters\)
sed "s/^X//" >'clock.c' <<'END_OF_FILE'
X
X
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: clock.c   SID: 2.4 4/17/90 16:45:32
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: clock.c,v 5.2 87/12/09 14:42:34 kenj Exp $
X *
X ******************************************************************************/
Xchar SCCSid[] = "@(#) @(#)clock.c:2.4 -- 4/17/90 16:45:32";
X/*
X *  clock -- check alarm signal accuracy
X *
X */
X
X#include <signal.h>
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef BSD4v1
X#include <sys/timeb.h>
X#endif
X#ifdef BSD4v2
X#include <sys/time.h>
X#endif
X#ifdef SysV
X#include <sys/times.h>
X#include <sys/param.h>
Xlong	times();
X#ifdef interdata
X#define HZ tbuffer.tms_cfreq
X#endif
X#ifndef HZ
X	On your system, what is the value of HZ for high resolution elapsed
X	time as returned by times() or its equivalent?
X#endif
X#endif
X
X#define GRANULE		5
X#define NUM_ALRM	12
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X    int			onalarm();
X    register int	i = 0;
X    int			expected;
X    float		wallclock;
X    long		then;
X#ifdef SysV
X    struct tms		tbuffer;
X#endif
X#ifdef BSD4v1
X    struct timeb	tbuf;
X    int			msec;
X#endif
X#ifdef BSD4v2
X    struct timeval	tval;
X    struct timezone	tzone;
X    long		usec;
X#endif
X
X#ifdef SysV
X    then = times(&tbuffer);
X#else
X#ifdef BSD4v1
X    ftime(&tbuf);
X    then = tbuf.time;
X    msec = tbuf.millitm;
X#else
X#ifdef BSD4v2
X    gettimeofday(&tval, &tzone);
X    then = tval.tv_sec;
X    usec = tval.tv_usec;
X#else
X	What sort of Unix system is this?
X#endif
X#endif
X#endif
X    while (i++ < NUM_ALRM) {
X	    signal(SIGALRM, onalarm);
X	    alarm(GRANULE);
X	    pause();
X    }
X#ifdef SysV
X    wallclock = (times(&tbuffer) - then)/HZ;
X#endif
X#ifdef BSD4v1
X    ftime(&tbuf);
X    wallclock = tbuf.time - then + (float)(tbuf.millitm - msec)/1000;
X#endif
X#ifdef BSD4v2
X    gettimeofday(&tval, &tzone);
X    wallclock = tval.tv_sec - then + (float)(tval.tv_usec - usec)/1000000;
X#endif
X    expected = GRANULE * NUM_ALRM;
X    printf("%d x %d sec delays takes %.2f wallclock secs (error %.2f%%)\n",
X	NUM_ALRM, GRANULE, wallclock, 100.0*(float)(expected-wallclock)/expected);
X    exit(0);
X}
X
Xonalarm() { }
END_OF_FILE
if test 2496 -ne `wc -c <'clock.c'`; then
    echo shar: \"'clock.c'\" unpacked with wrong size!
fi
chmod +x 'clock.c'
# end of 'clock.c'
fi
if test -f 'context1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'context1.c'\"
else
echo shar: Extracting \"'context1.c'\" \(2031 characters\)
sed "s/^X//" >'context1.c' <<'END_OF_FILE'
X
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: context1.c   SID: 2.4 4/17/90 16:45:32
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: context1.c,v 3.4 87/06/22 14:22:59 kjmcdonell Beta $
X *
X ******************************************************************************/
Xchar SCCSid[] = "@(#) @(#)context1.c:2.4 -- 4/17/90 16:45:32";
X/*
X *  Context switching via synchronized unbuffered pipe i/o
X *
X */
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	int	check;
X	int	iter;
X	int	p1[2], p2[2];
X
X	if (argc != 2) {
X		printf("Usage: context count\n");
X		exit(1);
X	}
X
X	iter = atoi(argv[1]);
X	if (pipe(p1) || pipe(p2)) {
X		perror("pipe create failed");
X		exit(1);
X	}
X
X	if (fork()) {
X		/* master, write p1 & read p2 */
X		close(p1[0]); close(p2[1]);
X		while (iter > 0) {
X			if (write(p1[1], (char *)&iter, sizeof(iter)) != sizeof(iter)) {
X				perror("master write failed");
X				exit(1);
X			}
X			if (read(p2[0], (char *)&check, sizeof(check)) != sizeof(check)) {
X				perror("master read failed");
X				exit(1);
X			}
X			if (check != iter) {
X				printf("Master sync error: expect %d, got %d\n",
X					iter, check);
X				exit(2);
X			}
X			iter--;
X		}
X	}
X	else {
X		/* slave, read p1 & write p2 */
X		close(p1[1]); close(p2[0]);
X		while (iter > 0) {
X			if (read(p1[0], (char *)&check, sizeof(check)) != sizeof(check)) {
X				perror("slave read failed");
X				exit(1);
X			}
X			if (check != iter) {
X				printf("Slave sync error: expect %d, got %d\n",
X					iter, check);
X				exit(2);
X			}
X			if (write(p2[1], (char *)&iter, sizeof(iter)) != sizeof(check)) {
X				perror("slave write failed");
X				exit(1);
X			}
X			iter--;
X		}
X	}
X	exit(0);
X}
END_OF_FILE
if test 2031 -ne `wc -c <'context1.c'`; then
    echo shar: \"'context1.c'\" unpacked with wrong size!
fi
chmod +x 'context1.c'
# end of 'context1.c'
fi
if test -f 'dbprep' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dbprep'\"
else
echo shar: Extracting \"'dbprep'\" \(960 characters\)
sed "s/^X//" >'dbprep' <<'END_OF_FILE'
X#! /bin/sh
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 2
X#          Module: dbprep   SID: 2.3 4/17/90 16:45:41
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	ben@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X###############################################################################
X#  Modification Log:
X#
X###############################################################################
XID="@(#)dbprep:2.3 -- 4/17/90 16:45:41";
Xrm -f $1  			# remove the old file
X
Xif test -f $1			# be sure it is gone - don't want
Xthen 				# to change file size by appending to it
X   exit 1
Xfi
X
Xif ${BINDIR}/buildbms $1 $2	# build the data file
Xthen
X   ${BINDIR}/dbmserv $1 $3 &    # start the database server
Xelse
X   echo "dbprep error"
X   exit 1
Xfi
END_OF_FILE
if test 960 -ne `wc -c <'dbprep'`; then
    echo shar: \"'dbprep'\" unpacked with wrong size!
fi
chmod +x 'dbprep'
# end of 'dbprep'
fi
if test -f 'dc.date' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dc.date'\"
else
echo shar: Extracting \"'dc.date'\" \(143 characters\)
sed "s/^X//" >'dc.date' <<'END_OF_FILE'
X99
Xk
X2
Xv
Xp
Xq
X[ calculate the sqrt(2) to 99 decimal places ... John Lions Test ]
X[ $Header: dc.dat,v 1.1 87/06/22 14:28:28 kjmcdonell Beta $ ]
X
END_OF_FILE
if test 143 -ne `wc -c <'dc.date'`; then
    echo shar: \"'dc.date'\" unpacked with wrong size!
fi
chmod +x 'dc.date'
# end of 'dc.date'
fi
if test -f 'dhry.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dhry.awk'\"
else
echo shar: Extracting \"'dhry.awk'\" \(1696 characters\)
sed "s/^X//" >'dhry.awk' <<'END_OF_FILE'
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 2
X#          Module: dhry.awk   SID: 2.3 4/17/90 16:45:41
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	ben@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X###############################################################################
X#  Modification Log:
X#        added geometric mean 8/6/89 -ben
X#
X###############################################################################
XBEGIN { FS=":"; tsum = 0.000; t2sum = 0.000; t_product = 0.0000;
X	dsum = 0.000; d2sum = 0.000; d_product = 0.0000;
X	iter = 0;
X	}
X/real/	{ next }  # don't use these times
X/user/	{ next }
X/sys/	{ next }
X/^$/	{ next } 
X/^Microseconds/ { 
X	t=$2; 
X	tsum += t;
X	t2sum += t*t;
X	if (t) { t_product += log(t); }
X        }
X/^Dhrystones/ { 
X	d=$2; 
X	dsum += d;
X	d2sum += d*d;
X	if (t) { d_product += log(d); }
X	iter ++;
X        }
XEND {
X	if (iter > 0) { 
X	    printf "                       Arithmetric        Geometric         Variance\n";
X	    printf "                              Mean             Mean         (%d tests)\n",iter
X	    printf "Microseconds/loop:       %9.0f        %9.0f         ",tsum/iter,exp(t_product/iter);
X	    if (iter > 1) printf "%9.2f\n",(t2sum-tsum*tsum/iter)/(iter-1);
X	    else printf "n/a\n"
X	    printf "Dhrystones/sec:          %9.0f        %9.0f         ",dsum/iter,exp(d_product/iter);
X	    if (iter > 1) printf "%9.2f\n",(d2sum-dsum*dsum/iter)/(iter-1);
X	    }
X	else { 
X	    print " -- no measured results --"; 
X	    }
X    }
END_OF_FILE
if test 1696 -ne `wc -c <'dhry.awk'`; then
    echo shar: \"'dhry.awk'\" unpacked with wrong size!
fi
chmod +x 'dhry.awk'
# end of 'dhry.awk'
fi
if test -f 'execl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'execl.c'\"
else
echo shar: Extracting \"'execl.c'\" \(1397 characters\)
sed "s/^X//" >'execl.c' <<'END_OF_FILE'
X
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: execl.c   SID: 2.4 4/17/90 16:45:33
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: execl.c,v 3.5 87/06/22 15:37:08 kjmcdonell Beta $
X *
X ******************************************************************************/
X/*
X *  Execing
X *
X */
X
Xchar	bss[8*1024];	/* something worthwhile */
X
X#define main dummy
X			/* some reasonable code etc. */
X#include "big.c"
X
X#undef main
X
X/* added by BYTE */
Xchar fullpath[81] = {"./execl"};
Xchar *getenv();
X
Xmain(argc, argv)	/* the real program */
Xint	argc;
Xchar	*argv[];
X{
X	char *ptr; /* BYTE */
X	int	iter;
X	char	count[6];
X
X	if (argc != 2) {
X		printf("Usage: %s count\n", argv[0]);
X		exit(1);
X	}
X
X	/* added by BYTE */
X	if((ptr = getenv("BINDIR")) != NULL)
X		sprintf(fullpath,"%s/execl",ptr);
X
X	iter = atoi(argv[1]);
X
X	if (iter) {
X		sprintf(count, "%d", --iter);
X		execl(fullpath, fullpath, count, 0);
X		printf("Exec failed at iteration %d\n", iter);
X		perror("Reason");
X		exit(1);
X	}
X	exit(0);
X}
END_OF_FILE
if test 1397 -ne `wc -c <'execl.c'`; then
    echo shar: \"'execl.c'\" unpacked with wrong size!
fi
chmod +x 'execl.c'
# end of 'execl.c'
fi
if test -f 'fs.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fs.awk'\"
else
echo shar: Extracting \"'fs.awk'\" \(2188 characters\)
sed "s/^X//" >'fs.awk' <<'END_OF_FILE'
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 2
X#          Module: fs.awk   SID: 2.5 4/17/90 16:45:40
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	ben@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X###############################################################################
X#  Modification Log:
X#       added geometric mean 8/6/89 -ben
X#       modified for new version of fstime 11/15/89
X#
X###############################################################################
XBEGIN   { w_product = 0.0000;
X	r_product = 0.0000;
X	c_product = 0.0000;
X	iter=0;
X	w_too_quick=0;
X	r_too_quick=0;
X	c_too_quick=0;
X	}
X/real/	{ iter++; ok++; next; }
X/user/	{ next; }
X/sys/	{ next; }
X/^$/	{ next; } 
X/fstime/ {
X         print "** Iteration ",iter," Failed: ",$0; 
X	 ok--;
X         fail=1;
X         } 
X/write/ { if (!fail) {
X	       w+=$1;
X	       w2+=$1*$1;
X	       w_product += log($1); 
X	       }
X        }
X/read/  { if (!fail) {
X	       r+=$1;
X	       r2+=$1*$1;
X	       r_product += log($1); 
X	       }
X        }
X/copy/  { if (!fail) {
X	       c+=$1;
X	       c2+=$1*$1;
X	       c_product += log($1);
X	       }
X	}
XEND {
X	if (ok != iter) {
X	   printf "For %d successful iterations from %d attempts ...\n",ok,iter;
X	}
X	if (ok > 0) {
X	    printf "                       Arithmetric        Geometric         Variance\n";
X	    printf "                              Mean             Mean         (%d tests)\n",ok
X	    printf "Read (Kbytes/sec):        %9.0f        %9.0f         ",r/ok,exp(r_product/ok);
X	    if (ok > 1) printf "%9.2f\n",(r2-r*r/ok)/(ok-1);
X	    else printf "n/a\n"
X	    printf "Write (Kbytes/sec):       %9.0f        %9.0f         ",w/ok,exp(w_product/ok);
X	    if (ok > 1) printf "%9.2f\n",(w2-w*w/ok)/(ok-1);
X	    else printf "n/a\n"
X	    printf "Copy (Kbytes/sec):        %9.0f        %9.0f         ",c/ok,exp(c_product/ok);
X	    if (ok > 1) printf "%9.2f\n",(c2-c*c/ok)/(ok-1);
X	    else printf "n/a\n"
X	} else {
X	    print "-- no measured results --"
X	}
X    }
END_OF_FILE
if test 2188 -ne `wc -c <'fs.awk'`; then
    echo shar: \"'fs.awk'\" unpacked with wrong size!
fi
chmod +x 'fs.awk'
# end of 'fs.awk'
fi
if test -f 'getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt.c'\"
else
echo shar: Extracting \"'getopt.c'\" \(2468 characters\)
sed "s/^X//" >'getopt.c' <<'END_OF_FILE'
X/*
X**	@(#)getopt.c	2.5 (smail) 9/15/87
X*/
X
X/*
X * Here's something you've all been waiting for:  the AT&T public domain
X * source for getopt(3).  It is the code which was given out at the 1985
X * UNIFORUM conference in Dallas.  I obtained it by electronic mail
X * directly from AT&T.  The people there assure me that it is indeed
X * in the public domain.
X * 
X * There is no manual page.  That is because the one they gave out at
X * UNIFORUM was slightly different from the current System V Release 2
X * manual page.  The difference apparently involved a note about the
X * famous rules 5 and 6, recommending using white space between an option
X * and its first argument, and not grouping options that have arguments.
X * Getopt itself is currently lenient about both of these things White
X * space is allowed, but not mandatory, and the last option in a group can
X * have an argument.  That particular version of the man page evidently
X * has no official existence, and my source at AT&T did not send a copy.
X * The current SVR2 man page reflects the actual behavor of this getopt.
X * However, I am not about to post a copy of anything licensed by AT&T.
X */
X
X/* This include is needed only to get "index" defined as "strchr" on Sys V. */
X#include "defs.h"
X
X/*LINTLIBRARY*/
X#define NULL	0
X#define EOF	(-1)
X#define ERR(s, c)	if(opterr){\
X	extern int write();\
X	char errbuf[2];\
X	errbuf[0] = c; errbuf[1] = '\n';\
X	(void) write(2, argv[0], (unsigned)strlen(argv[0]));\
X	(void) write(2, s, (unsigned)strlen(s));\
X	(void) write(2, errbuf, 2);}
X
Xextern char *index();
X
Xint	opterr = 1;
Xint	optind = 1;
Xint	optopt;
Xchar	*optarg;
X
Xint
Xgetopt(argc, argv, opts)
Xint	argc;
Xchar	**argv, *opts;
X{
X	static int sp = 1;
X	register int c;
X	register char *cp;
X
X	if(sp == 1)
X		if(optind >= argc ||
X		   argv[optind][0] != '-' || argv[optind][1] == '\0')
X			return(EOF);
X		else if(strcmp(argv[optind], "--") == NULL) {
X			optind++;
X			return(EOF);
X		}
X	optopt = c = argv[optind][sp];
X	if(c == ':' || (cp=index(opts, c)) == NULL) {
X		ERR(": illegal option -- ", c);
X		if(argv[optind][++sp] == '\0') {
X			optind++;
X			sp = 1;
X		}
X		return('?');
X	}
X	if(*++cp == ':') {
X		if(argv[optind][sp+1] != '\0')
X			optarg = &argv[optind++][sp+1];
X		else if(++optind >= argc) {
X			ERR(": option requires an argument -- ", c);
X			sp = 1;
X			return('?');
X		} else
X			optarg = argv[optind++];
X		sp = 1;
X	} else {
X		if(argv[optind][++sp] == '\0') {
X			sp = 1;
X			optind++;
X		}
X		optarg = NULL;
X	}
X	return(c);
X}
END_OF_FILE
if test 2468 -ne `wc -c <'getopt.c'`; then
    echo shar: \"'getopt.c'\" unpacked with wrong size!
fi
chmod +x 'getopt.c'
# end of 'getopt.c'
fi
if test -f 'hanoi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hanoi.c'\"
else
echo shar: Extracting \"'hanoi.c'\" \(1293 characters\)
sed "s/^X//" >'hanoi.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: hanoi.c   SID: 2.4 4/17/90 16:45:34
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: hanoi.c,v 3.5 87/08/06 08:11:14 kenj Exp $
X *
X ******************************************************************************/
X
Xchar SCCSid[] = "@(#) @(#)hanoi.c:2.4 -- 4/17/90 16:45:34";
X#define PRINT 0
X#define DISK 3
X#define other(i,j) (6-(i+j))
Xint num[4];
Xlong cnt;
Xmain(argc,argv)
Xchar **argv;
X{
X	int disk;
X	disk  = DISK;
X	if(argc > 1)disk = atoi(argv[1]);
X	num[1] = disk;
X	if(PRINT)printf("Start %d on A\n",disk);
X	mov(disk,1,3);
X	printf("For %d disks, %ld moves\n",disk,cnt);
X
X	exit(0);
X}
X
Xmov(n,f,t)
X{
X	int o;
X	if(n == 1) {
X		num[f]--;
X		num[t]++;
X		if(PRINT)printf("Move from %d to %d, result: A:%d B:%d C%d\n",
X			f,t,num[1],num[2],num[3]);
X		cnt++;
X		return;
X	}
X	o = other(f,t);
X	mov(n-1,f,o);
X	mov(1,f,t);
X	mov(n-1,o,t);
X	return;
X}
END_OF_FILE
if test 1293 -ne `wc -c <'hanoi.c'`; then
    echo shar: \"'hanoi.c'\" unpacked with wrong size!
fi
chmod +x 'hanoi.c'
# end of 'hanoi.c'
fi
if test -f 'limit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'limit.c'\"
else
echo shar: Extracting \"'limit.c'\" \(3268 characters\)
sed "s/^X//" >'limit.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: limit.c   SID: 2.4 4/17/90 16:45:34
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: limit.c,v 3.4 87/06/22 14:25:11 kjmcdonell Beta $
X *
X ******************************************************************************/
Xchar SCCSid[] = "@(#) @(#)limit.c:2.4 -- 4/17/90 16:45:34";
X/*
X *  Force a UNIX system to the per process and per user limits
X *
X */
X
X#define	CLICK	1024
X#define	MAXCHN	100
X
X#include <signal.h>
X#include <setjmp.h>
X
Xint	parent;		/* parent's pid */
Xint	child;		/* child's pid */
Xint	pid[MAXCHN];
Xint	ncall;
Xint	level;
Xjmp_buf	env;
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	char	*top;
X	int	pad;
X	int	end;
X	int	i;
X	int	status;
X	float	f;
X	int	flag();
X	int	wakeup();
X	long	last;
X
X	/* open files (file descriptors) */
X	for (i = 3; open(".", 0) > 0; i++) ;
X	printf("Maximum open files per process: %d\n", i);
X	while (--i > 2)
X		close(i);
X
X	/* process address space */
X	top = (char *)sbrk(0);
X#if debug
X	printf("inital top of program: 0x%x\n", top);
X#endif
X	pad = (((int)top+CLICK-1)/CLICK)*CLICK - (int)top;
X	sbrk(pad);
X	for (i = 0; (char *)sbrk(CLICK) != (char *)-1; i++) ;
X#if debug
X	printf("final top of program: 0x%x\n", sbrk(0));
X#endif
X	brk(top);
X#if debug
X	printf("top of program restored to: 0x%x\n", sbrk(0));
X#endif
X	end = (((int)top+pad)/CLICK) + i;
X	f = ((float)end * CLICK) / 1024;
X	printf("Process address space limit: ");
X	if (f < 1024)
X		printf("%.2f Kbytes\n", f);
X	else {
X		f /= 1024;
X		printf("%.2f Mbytes\n", f);
X	}
X
X	/* process creations */
X	printf("Maximum number of child processes:");
X	i = 0;
X	while (1) {
X#if debug
X		printf("about to fork\n");
X#endif
X		if ((pid[i] = fork()) == -1) {
X#if debug
X			perror("fork failed");
X#endif
X			break;
X		} else if (pid[i] != 0) {
X#if debug
X			printf("child %d: pid=%d\n", i+1, pid[i]);
X#endif
X			i++;
X			if (i >= MAXCHN) {
X				printf(" more than");
X				break;
X			}
X		} else {
X#if debug
X			printf("child %d pausing\n", getpid());
X#endif
X			pause();
X#if debug
X			printf("child %d exiting\n", getpid());
X#endif
X			exit(1);
X		}
X	}
X	printf(" %d\n", i);
X	while (--i >= 0) {
X		kill(pid[i], SIGKILL);
X		wait(0);
X	}
X
X	ncall = level = 0;
X	parent = getpid();
X	signal(SIGTERM, flag);
X	if ((child = fork()) == 0) {
X		signal(SIGALRM, wakeup);
X		recurse();
X		exit(4);
X	}
X	while ((i = wait(&status)) == -1) {
X	}
X	printf("Estimated maximum stack size: %d Kbytes\n", level);
X	exit(0);
X}
X
Xrecurse()
X{
X	int	temp[1024 / sizeof(int)];
X#if debug
X	printf("recursion @ level %d\n", ncall);
X#endif
X	temp[1024 / sizeof(int) - 1] = 1;
X	ncall++;
X	kill(parent, SIGTERM);
X	while (ncall > level) {
X		alarm(2);
X		pause();
X	}
X	if (ncall < 8000)
X		/* less than 8M bytes of temp storage! */
X		recurse();
X	else
X		/* give up! */
X		exit(0);
X}
X
Xflag()
X{
X	signal(SIGTERM, flag);
X	level++;
X	if (child != 0)
X		kill(child, SIGTERM);
X}
X
Xwakeup()
X{
X	signal(SIGALRM, wakeup);
X}
END_OF_FILE
if test 3268 -ne `wc -c <'limit.c'`; then
    echo shar: \"'limit.c'\" unpacked with wrong size!
fi
chmod +x 'limit.c'
# end of 'limit.c'
fi
if test -f 'mkperm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mkperm.c'\"
else
echo shar: Extracting \"'mkperm.c'\" \(1389 characters\)
sed "s/^X//" >'mkperm.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: mkperm.c   SID: 2.4 4/17/90 16:45:35
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: mkperm.c,v 1.2 87/06/22 14:32:26 kjmcdonell Beta $
X *
X ******************************************************************************/
Xchar SCCSid[] = "@(#) @(#)mkperm.c:2.4 -- 4/17/90 16:45:35";
X#include <stdio.h>
X#ifndef lint
X#endif
X
X/* define rand and srand if you have random() from USENET */
X/* #define rand random */
X/* #define srand srandom */
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	int	n;	/* generate a permutation of {1,2,3,...,n} */
X	int	i;
X	int	t;
X	char	*mask;
X
X	if (argc > 2 && strcmp(argv[1], "-s") == 0) {
X		t = atoi(argv[2]);
X		if (t < 16)
X			t = 1 << t;
X		srand(t);
X		argv++;
X		argv++;
X	}
X	n = atoi(argv[1]);
X	mask = (char *)malloc(n);
X
X	for (i=0; i<n; i++)
X		mask[i] = '\0';
X	for (i=0; i<n; i++) {
X		do {
X			t = rand() % n;
X		} while (mask[t]);
X		mask[t] = '\1';
X		printf("%d ", t+1);
X	}
X	putchar('\n');
X	exit(0);
X}
END_OF_FILE
if test 1389 -ne `wc -c <'mkperm.c'`; then
    echo shar: \"'mkperm.c'\" unpacked with wrong size!
fi
chmod +x 'mkperm.c'
# end of 'mkperm.c'
fi
if test -f 'multi.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'multi.sh'\"
else
echo shar: Extracting \"'multi.sh'\" \(704 characters\)
sed "s/^X//" >'multi.sh' <<'END_OF_FILE'
X#! /bin/sh
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 2
X#          Module: multi.sh   SID: 2.3 4/17/90 16:45:41
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	ben@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X###############################################################################
X#  Modification Log:
X#
X###############################################################################
XID="@(#)multi.sh:2.3 -- 4/17/90 16:45:41";
Xfor i
Xdo
X	/bin/sh $BINDIR/tst.sh &
Xdone
Xwait
X
END_OF_FILE
if test 704 -ne `wc -c <'multi.sh'`; then
    echo shar: \"'multi.sh'\" unpacked with wrong size!
fi
chmod +x 'multi.sh'
# end of 'multi.sh'
fi
if test -f 'pipe.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pipe.c'\"
else
echo shar: Extracting \"'pipe.c'\" \(1212 characters\)
sed "s/^X//" >'pipe.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: pipe.c   SID: 2.4 4/17/90 16:45:35
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: pipe.c,v 3.5 87/06/22 14:32:36 kjmcdonell Beta $
X *
X ******************************************************************************/
Xchar SCCSid[] = "@(#) @(#)pipe.c:2.4 -- 4/17/90 16:45:35";
X/*
X *  pipe  -- test single process pipe throughput (no context switching)
X *
X */
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	char	buf[512];
X	int	iter = 2048;	/* 1M byte */
X	int	pvec[2];
X
X	pipe(pvec);
X	close(0); dup(pvec[0]); close(pvec[0]);
X	close(1); dup(pvec[1]); close(pvec[1]);
X
X	while (iter-- > 0) {
X		if (write(1, buf, sizeof(buf)) != sizeof(buf))
X			perror("write failed");
X		if (read(0, buf, sizeof(buf)) != sizeof(buf))
X			perror("read failed");
X	}
X	exit(0);
X}
END_OF_FILE
if test 1212 -ne `wc -c <'pipe.c'`; then
    echo shar: \"'pipe.c'\" unpacked with wrong size!
fi
chmod +x 'pipe.c'
# end of 'pipe.c'
fi
if test -f 'spawn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spawn.c'\"
else
echo shar: Extracting \"'spawn.c'\" \(1390 characters\)
sed "s/^X//" >'spawn.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: spawn.c   SID: 2.4 4/17/90 16:45:35
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: spawn.c,v 3.4 87/06/22 14:32:48 kjmcdonell Beta $
X *
X ******************************************************************************/
Xchar SCCSid[] = "@(#) @(#)spawn.c:2.4 -- 4/17/90 16:45:35";
X/*
X *  Process creation
X *
X */
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	int	iter;
X	int	slave;
X	int	status;
X
X	if (argc != 2) {
X		printf("Usage: %s count\n", argv[0]);
X		exit(1);
X	}
X
X	iter = atoi(argv[1]);
X
X	while (iter-- > 0) {
X		if ((slave = fork()) == 0) {
X			/* slave .. boring */
X#if debug
X			printf("fork OK\n");
X#endif
X			exit(0);
X		} else if (slave < 0) {
X			/* woops ... */
X			printf("Fork failed at iteration %d\n", iter);
X			perror("Reason");
X			exit(2);
X		} else
X			wait(&status);
X		if (status != 0) {
X			printf("Bad wait status: 0x%x\n", status);
X			exit(2);
X		}
X#if debug
X		printf("Child %d done.\n", slave);
X#endif
X	}
X	exit(0);
X}
END_OF_FILE
if test 1390 -ne `wc -c <'spawn.c'`; then
    echo shar: \"'spawn.c'\" unpacked with wrong size!
fi
chmod +x 'spawn.c'
# end of 'spawn.c'
fi
if test -f 'syscall.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'syscall.c'\"
else
echo shar: Extracting \"'syscall.c'\" \(1061 characters\)
sed "s/^X//" >'syscall.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: syscall.c   SID: 2.4 4/17/90 16:45:36
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: syscall.c,v 3.4 87/06/22 14:32:54 kjmcdonell Beta $
X *
X ******************************************************************************/
Xchar SCCSid[] = "@(#) @(#)syscall.c:2.4 -- 4/17/90 16:45:36";
X/*
X *  syscall  -- sit in a loop calling the system
X *
X */
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	int	iter;
X	int	i;
X
X	if (argc != 2) {
X		printf("Usage: %s count\n", argv[0]);
X		exit(1);
X	}
X
X	iter = atoi(argv[1]);
X
X	while (iter-- > 0) {
X		close(dup(0));
X		getpid();
X		getuid();
X		umask(022);
X	}
X	exit(0);
X}
END_OF_FILE
if test 1061 -ne `wc -c <'syscall.c'`; then
    echo shar: \"'syscall.c'\" unpacked with wrong size!
fi
chmod +x 'syscall.c'
# end of 'syscall.c'
fi
if test -f 'time.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'time.awk'\"
else
echo shar: Extracting \"'time.awk'\" \(2196 characters\)
sed "s/^X//" >'time.awk' <<'END_OF_FILE'
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 2
X#          Module: time.awk   SID: 2.3 4/17/90 16:45:40
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	ben@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X###############################################################################
X#  Modification Log:
X#       added geometric mean 8/6/89 -ben
X#
X###############################################################################
XBEGIN      { r_product = 0.0000; s_product = 0.0000 ; u_product = 0.0000 }
X/^cctest.c$/	{ next }
X/^[Rr]eal/ {
X	if (!fail) {
X	    l=length($2); m=substr($2,1,l-5); s=substr($2,l-3,4)
X	    t=m*60+s; real+=t; r2+=t*t; ok++;
X	    if (t) {r_product += log(t);}
X	}
X	iter++; fail=0; next }
X/^[Uu]ser/ {
X	l=length($2); m=substr($2,1,l-5); s=substr($2,l-3,4)
X	t=m*60+s; user+=t; cpu=t; u2+=t*t;
X	if (t) { u_product += log(t);}
X	next; }
X/^[Ss]ys/ {
X	l=length($2); m=substr($2,1,l-5); s=substr($2,l-3,4)
X	t=m*60+s; sys+=t; s2+=t*t; 
X	if (t) { s_product += log(t);}
X	next; }
X/^$/	{ next }
X	{ print "** Iteration ",iter+1," Failed: ",$0; fail=1 }
XEND {
X	if (fail) iter++
X	if (ok != iter) {
X	    printf "For %d successful iterations from %d attempts ...\n",ok,iter
X	    iter=ok;
X	}
X	if (ok > 0) {
X	    printf "                       Arithmetric        Geometric         Variance\n";
X	    printf "                              Mean             Mean         (%d tests)\n",ok
X	    printf "User Time (secs):        %9.2f        %9.2f         ",user/ok,exp(u_product/ok);
X	    if (ok > 1) printf "%9.2f\n",(u2-user*user/ok)/(ok-1);
X	    else printf "n/a\n"
X	    printf "System Time (secs):      %9.2f        %9.2f         ",sys/ok,exp(s_product/ok);
X	    if (ok > 1) printf "%9.2f\n",(s2-sys*sys/ok)/(ok-1);
X	    else printf "n/a\n"
X	    printf "Real Time (secs):        %9.2f        %9.2f         ",real/ok,exp(r_product/ok);
X	    if (ok > 1) printf "%9.2f\n",(r2-real*real/ok)/(ok-1);
X	    else printf "n/a\n"
X	} else {
X	    print "-- no measured results --"
X	}
X    }
END_OF_FILE
if test 2196 -ne `wc -c <'time.awk'`; then
    echo shar: \"'time.awk'\" unpacked with wrong size!
fi
chmod +x 'time.awk'
# end of 'time.awk'
fi
if test -f 'tst.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tst.sh'\"
else
echo shar: Extracting \"'tst.sh'\" \(785 characters\)
sed "s/^X//" >'tst.sh' <<'END_OF_FILE'
X#! /bin/sh
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 2
X#          Module: tst.sh   SID: 2.3 4/17/90 16:45:41
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	ben@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X###############################################################################
X#  Modification Log:
X#
X###############################################################################
XID="@(#)tst.sh:2.3 -- 4/17/90 16:45:41";
Xsort >sort.$$ <sort.src
Xod sort.$$ | sort -n +1 > od.$$
Xgrep the sort.$$ | tee grep.$$ | wc > wc.$$
Xrm sort.$$ grep.$$ od.$$ wc.$$
END_OF_FILE
if test 785 -ne `wc -c <'tst.sh'`; then
    echo shar: \"'tst.sh'\" unpacked with wrong size!
fi
chmod +x 'tst.sh'
# end of 'tst.sh'
fi
echo shar: End of archive 1 \(of 5\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
exit 0 # Just in case...
