Subject:  v22i029:  Byte Unix benchmarks, Part02/05
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 7bdcf645 c4412bf6 22ef7144 85377d6b

Submitted-by: "Ben Smith @ BYTE" <ben@bytepb.byte.com>
Posting-number: Volume 22, Issue 29
Archive-name: byte-benchmarks/part02

[  Look out for the BEL characters on line 94 of Run, and line 30 of sort.src. ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 5)."
# Contents:  Makefile Run dummy.c fstime.c precision.c sort.src
# Wrapped by rsalz@papaya.bbn.com on Tue May  8 08:55:29 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(7106 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X##############################################################################
X#  The BYTE UNIX Benchmarks - Release 2
X#          Module: Makefile   SID: 2.10 4/17/90 16:45:28
X#          
X##############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	bensmith@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X##############################################################################
X#  Modification Log: 7/28/89 cleaned out workload files
X#                    4/17/90 added routines for installing from shar mess
X#
X##############################################################################
XID="@(#)Makefile:2.10 -- 4/17/90 16:45:28";
XSHELL = /bin/sh
XUNIX = -DSysV     #may be: SysV, BSD4v1, BSD4v2
XCFLAGS = $(UNIX) -DHZ=50
XOPTON = -O        #optimization on (give it your best shot) 
X                  #            -- check your compiler man
XOPTOFF = -Od      #optimization off -- check your compiler man
X# local directories
XBINDIR = ./pgms
XSRCDIR = ./src
XDOCDIR = ./doc
XTESTDIR = ./testdir
XRESULTDIR = ./resultdir
XTMPDIR = ./tmpdir
X# other directories
XINCLDIR = /usr/include
XLIBDIR = /lib
XSCRIPTS = BSDtime.awk SysVtime.awk byte.logo \
X	cleanup dbprep dhry.awk \
X	fs.awk multi.sh \
X	time.awk tst.sh
XSOURCES = arith.c big.c buildbms.c \
X	clock.c context1.c \
X	dbmscli.c dbmserv.c dhry.c \
X	dhry.h dummy.c execl.c \
X	fstime.c getopt.c hanoi.c \
X	limit.c mkperm.c \
X	pipe.c precision.c spawn.c \
X	syscall.c 
XDOCS = bench.doc
XTESTS = sort.src cctest.c 
XPROGS = $(BINDIR)/arithoh $(BINDIR)/register $(BINDIR)/short \
X	$(BINDIR)/int $(BINDIR)/long $(BINDIR)/float $(BINDIR)/double \
X	$(BINDIR)/hanoi \
X	$(BINDIR)/fstime $(BINDIR)/syscall $(BINDIR)/context1 \
X	$(BINDIR)/pipe $(BINDIR)/spawn $(BINDIR)/execl \
X	$(BINDIR)/dhry2 $(BINDIR)/dhry2reg $(BINDIR)/limit \
X	$(BINDIR)/clock $(BINDIR)/precision $(BINDIR)/mkperm \
X	$(BINDIR)/buildbms $(BINDIR)/dbmserv $(BINDIR)/dbmscli 
X
X# ######################### the big ALL ############################
Xall: distr programs
X
X# distribute the files out to subdirectories if they are in this one
Xdistr: 
X	# scripts
X	if  test ! -d  $(BINDIR) \
X        ; then  \
X           mkdir $(BINDIR) \
X           ; mv $(SCRIPTS) $(BINDIR) \
X        ; else \
X           echo "$(BINDIR)  exists" \
X        ; fi
X	# C sources
X	if  test ! -d  $(SRCDIR) \
X        ; then  \
X           mkdir $(SRCDIR) \
X           ; mv $(SOURCES) $(SRCDIR) \
X        ; else \
X           echo "$(SRCDIR)  exists" \
X        ; fi
X	# test data
X	if  test ! -d  $(TESTDIR) \
X        ; then  \
X           mkdir $(TESTDIR) \
X           ; mv $(TESTS) $(TESTDIR) \
X        ; else \
X           echo "$(TESTDIR)  exists" \
X        ; fi
X	# documents directory
X	if  test ! -d  $(DOCDIR) \
X        ; then  \
X           mkdir $(DOCDIR) \
X	   ; mv $(DOCS) $(DOCDIR) \
X        ; else \
X           echo "$(DOCDIR)  exists" \
X        ; fi
X	# temporary work directory
X	if  test ! -d  $(TMPDIR) \
X        ; then  \
X           mkdir $(TMPDIR) \
X        ; else \
X           echo "$(TMPDIR)  exists" \
X        ; fi
X	# directory for results
X	if  test ! -d  $(RESULTDIR) \
X        ; then  \
X           mkdir $(RESULTDIR) \
X        ; else \
X           echo "$(RESULTDIR)  exists" \
X        ; fi
X	chmod 744 * $(SRCDIR)/* $(BINDIR)/* $(TESTDIR)/* $(DOCDIR)/*
X
Xprograms: $(PROGS)
X
X# Individual programs
X$(BINDIR)/arithoh:	$(SRCDIR)/arith.c
X	cc -o $(BINDIR)/arithoh ${CFLAGS} ${OPTON} -Darithoh $(SRCDIR)/arith.c
X$(BINDIR)/register: $(SRCDIR)/arith.c
X	cc -o $(BINDIR)/register ${CFLAGS} ${OPTON} -Ddatum=register $(SRCDIR)/arith.c
X$(BINDIR)/short: $(SRCDIR)/arith.c
X	cc -o $(BINDIR)/short ${CFLAGS} ${OPTON} -Ddatum=short $(SRCDIR)/arith.c
X$(BINDIR)/int: $(SRCDIR)/arith.c
X	cc -o $(BINDIR)/int ${CFLAGS} ${OPTON} -Ddatum=int $(SRCDIR)/arith.c
X$(BINDIR)/long: $(SRCDIR)/arith.c
X	cc -o $(BINDIR)/long ${CFLAGS} ${OPTON} -Ddatum=long $(SRCDIR)/arith.c
X$(BINDIR)/float: $(SRCDIR)/arith.c
X	cc -o $(BINDIR)/float ${CFLAGS} ${OPTON} -Ddatum=float $(SRCDIR)/arith.c
X$(BINDIR)/double: $(SRCDIR)/arith.c
X	cc -o $(BINDIR)/double ${CFLAGS} ${OPTON} -Ddatum=double $(SRCDIR)/arith.c
X$(BINDIR)/hanoi: $(SRCDIR)/hanoi.c
X	cc -o $(BINDIR)/hanoi ${CFLAGS} ${OPTON} $(SRCDIR)/hanoi.c
X$(BINDIR)/fstime: $(SRCDIR)/fstime.c
X	cc -o $(BINDIR)/fstime ${CFLAGS} ${OPTON} -Dawk=1 $(SRCDIR)/fstime.c
X$(BINDIR)/syscall: $(SRCDIR)/syscall.c
X	cc -o $(BINDIR)/syscall ${CFLAGS} ${OPTON} $(SRCDIR)/syscall.c
X$(BINDIR)/context1: $(SRCDIR)/context1.c
X	cc -o $(BINDIR)/context1 ${CFLAGS} ${OPTON} $(SRCDIR)/context1.c
X$(BINDIR)/pipe: $(SRCDIR)/pipe.c
X	cc -o $(BINDIR)/pipe ${CFLAGS} ${OPTON} $(SRCDIR)/pipe.c
X$(BINDIR)/spawn: $(SRCDIR)/spawn.c
X	cc -o $(BINDIR)/spawn ${CFLAGS} ${OPTON} $(SRCDIR)/spawn.c
X$(BINDIR)/execl: $(SRCDIR)/execl.c $(SRCDIR)/big.c
X	cc -o $(BINDIR)/execl ${CFLAGS} ${OPTON} $(SRCDIR)/execl.c
X$(BINDIR)/keyb: $(SRCDIR)/keyb.c
X	cc -o $(BINDIR)/keyb ${CFLAGS} ${OPTON} $(SRCDIR)/keyb.c
X$(BINDIR)/limit: $(SRCDIR)/limit.c
X	cc -o $(BINDIR)/limit ${CFLAGS} ${OPTON} $(SRCDIR)/limit.c
X$(BINDIR)/dhry2: $(SRCDIR)/dhry.c $(SRCDIR)/dhry.h
X	cc -o $(BINDIR)/dhry2 ${CFLAGS} ${OPTON} $(SRCDIR)/dhry.c
X$(BINDIR)/dhry2reg: $(SRCDIR)/dhry.c $(SRCDIR)/dhry.h
X	cc -o $(BINDIR)/dhry2reg -DREG=register ${CFLAGS} ${OPTON} $(SRCDIR)/dhry.c
X$(BINDIR)/clock: $(SRCDIR)/clock.c
X	cc -o $(BINDIR)/clock ${CFLAGS} ${OPTON} $(SRCDIR)/clock.c
X$(BINDIR)/precision: $(SRCDIR)/precision.c
X	cc -o $(BINDIR)/precision ${CFLAGS} ${OPTON} $(SRCDIR)/precision.c
X$(BINDIR)/ttychk: $(SRCDIR)/ttychk.c
X	cc -o $(BINDIR)/ttychk ${CFLAGS} ${OPTON} $(SRCDIR)/ttychk.c
X$(BINDIR)/mkperm: $(SRCDIR)/mkperm.c
X	cc -o $(BINDIR)/mkperm ${CFLAGS} ${OPTON} $(SRCDIR)/mkperm.c
X$(BINDIR)/buildbms: $(SRCDIR)/buildbms.c
X	cc -o $(BINDIR)/buildbms ${CFLAGS} ${OPTON} $(SRCDIR)/buildbms.c
X$(BINDIR)/dbmserv: $(SRCDIR)/dbmserv.c
X	cc -o $(BINDIR)/dbmserv ${CFLAGS} ${OPTON} $(SRCDIR)/dbmserv.c
X$(BINDIR)/dbmscli: $(SRCDIR)/dbmscli.c
X	cc -o $(BINDIR)/dbmscli ${CFLAGS} ${OPTON} $(SRCDIR)/dbmscli.c
X$(BINDIR)/autokb: $(SRCDIR)/autokb.c
X	cc -o $(BINDIR)/autokb ${CFLAGS} ${OPTON} $(SRCDIR)/autokb.c
X
X# SCCS stuff
X
Xdelta:
X	delta -y"development step" sccs/s.Run sccs/s.README
X	cd src; delta -y"development step" sccs
X	cd pgms; delta -y"development step" sccs
X	cd testdir; delta -y"development step" sccs
X	cd doc; delta -y"development step" sccs
Xget:
X	get -e sccs/s.Run sccs/s.README
X	cd src; get -e sccs
X	cd pgms; get -e sccs
X	cd testdir; get -e sccs
X	cd doc; get -e sccs
X	chmod 744 $(SRCDIR)/* $(DATAFILES)
X	chmod 755 $(BINDIR)/* *
Xrel:
X	#cd bench; find . -type f -print | rm -f
X	cd bench; get ../sccs
X	cd bench/src; get ../../src/sccs
X	cd bench/pgms; get ../../pgms/sccs
X	cd bench/testdir; get ../../testdir/sccs
X	cd bench/doc; get ../../doc/sccs
X	cd bench; chmod 744 src/* testdir/*
X	cd bench; chmod 755 * pgms/*
X
Xtar48:
X	format /dev/rdsk/f05d9t 
X	tar cfb /dev/rdsk/f05d9t 20 bench
X	tar tf /dev/rdsk/f05d9t 
X
Xtar96:
X	format /dev/rdsk/f05ht
X	tar cfb /dev/rdsk/f05ht 20 bench
X	tar tf /dev/rdsk/f05ht
X
Xtar135:
X	format /dev/rdsk/f13dt
X	tar cfb /dev/rdsk/f13dt 20 bench
X	tar tf /dev/rdsk/f13dt
END_OF_FILE
if test 7106 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
chmod +x 'Makefile'
# end of 'Makefile'
fi
if test -f 'Run' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Run'\"
else
echo shar: Extracting \"'Run'\" \(13521 characters\)
sed "s/^X//" >'Run' <<'END_OF_FILE'
X#! /bin/sh
X#################### set your default list of tests here ##############
X
XFULL_SUITE="dhry2 dhry2reg arithoh register short int long float double syscall pipe context1 spawn execl fstime shell dc hanoi"
X
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 2
X#          Module: Run   SID: 2.6 4/17/90 16:45:27
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith,        Rick Grehan, or      Tom Yager at BYTE Magazine
X#	ben@bytepb.UUCP   rick_g@bytepb.UUCP   tyager@bytepb.UUCP
X# BIX:  bensmith          rick_g               tyager
X#
X###############################################################################
X#  Modification Log:
X# $Header: run,v 5.2 88/01/12 06:23:43 kenj Exp $
X#     Ken McDonell, Computer Science, Monash University
X#     August 1, 1983
X# 3/89 - Ben Smith - BYTE: globalized many variables, modernized syntax
X# 5/89 - commented and modernized. Removed workload items till they
X#        have been modernized. Added database server test.
X# 11/14/89 - Made modifications to reflect new version of fstime
X#        and elimination of mem tests.
X#
X###############################################################################
XID="@(#)Run:2.6 -- 4/17/90 16:45:27";
Xversion="2.6"
X#######################################################################
X# General Purpose Benchmark
X# based on the work by Ken McDonell, Computer Science, Monash University
X#
X#  You will need ...
X#	awk cat cc chmod comm cp date dc df echo ed expr
X#	kill ls make mkdir rm sed test time touch tty umask who
X#
X#  The following variables may be assigned external values to overide defaults
X#
X#  Test		Variable	Default		Use
X#  all		iterations	6		repeat count for timing
X#  dhry		dhryloops	10000		no. of loops to test
X#  arithmetic	arithloop	10000		no. of summations
X#  hanoi	ndisk		17		list of nos. of disks
X#  syscall	ncall		4000		no. iterations, each of
X#  						5 system calls
X#  context1	switch1		500		no. of switches
X#  pipe		io		2048		no. 512 byte blocks to read
X#  						and write
X#  spawn	children	100		no. of child processes
X#  execl	nexecs		100		no. of execs
X#  fstime	seconds		1 10 20         seconds
X#
Xumask 022    # at least mortals can read root's files this way
X# establish full paths to directories
XPWD=`pwd`
XHOMEDIR=${HOMEDIR-.}
Xcd $HOMEDIR
XHOMEDIR=`pwd`
Xcd $PWD
X
XBINDIR=${BINDIR-${HOMEDIR}/pgms}
Xcd $BINDIR
XBINDIR=`pwd`
Xcd $PWD
X# let's extend the path to this directory
XPATH="${PATH}:${BINDIR}"
X
XSCRPDIR=${SCRPDIR-${HOMEDIR}/pgms}
Xcd $SCRPDIR
XSCRPDIR=`pwd`
Xcd $PWD
X
XTMPDIR=${HOMEDIR}/tmp
Xcd $TMPDIR
XTMPDIR=`pwd`
Xcd $PWD
X
XRESULTDIR=${RESULTDIR-${HOMEDIR}/results}
Xcd $RESULTDIR
XRESULTDIR=`pwd`
Xcd $PWD
X
XTIMEACCUM=${TIMEACCUM-${RESULTDIR}/times}
X
XTESTDIR=${TESTDIR-${HOMEDIR}/testdir}
Xcd $TESTDIR
XTESTDIR=`pwd`
Xcd $PWD
X
Xexport BINDIR TMPDIR RESULTDIR PATH TESTDIR TIMEACCUM
X#
Xbell=""
Xbreak1="============================================================================="
Xbreak2="-----------------------------------------------------------------------------"
X#
Xcat ${BINDIR}/byte.logo # display banner
Xrm -f ${TIMEACCUM}      # clean out old time accumulation file
Xecho "kill -9 $$" > ${TMPDIR}/kill_run ; chmod u+x ${TMPDIR}/kill_run
X#
Xarithmetic="arithoh register short int long float double"
Xsystem="syscall pipe context1 spawn execl"
Xmisc="C dc hanoi"
Xdhry="dhry2 dhry2reg" # dhrystone loops
Xload="shell" # cummulative load tests
Xdb="dbmscli" # add to as new database engines are developed
X#
Xargs="" # the accumulator for the bench units to be run
Xrunoption="N"
X# generate list of bench programs
Xfor word
Xdo  # do level 1
X    case $word
X    in
X  all)
X      ;;
X  arithmetic)
X      args="$args $arithmetic"
X      ;;
X  db)
X      args="$args $db"
X      ;;
X  dhry)
X      args="$args $dhry"
X      ;;
X  load)
X      args="$args $load"
X      ;;
X  misc)
X      args="$args $misc"
X      ;;
X  speed)
X      args="$args $arithmetic $system"
X      ;;
X  system)
X      args="$args $system"
X      ;;
X  -q|-Q)
X      runoption="Q" #quiet
X      ;;
X  -v|-V)
X      runoption="V" #verbose
X      ;;
X  -d|-D)
X      runoption="D" #debug
X      ;;
X  *)
X      args="$args $word"
X      ;;
X    esac
X
Xdone # end do level 1
X#if no benchmark units have be specified, do them all 
X# the - option of set implies no options; any list following
X# becomes the line arguments (replacing any that may exist)
Xset - $args
Xif test $# -eq 0  #no arguments specified
X   then
X   set - $FULL_SUITE
Xfi
X
Xif test "$runoption" = 'D'
Xthen
X  set -x
X  set -v
Xfi
X
Xdate=`date`
Xtmp=${TMPDIR}/$$.tmp
Xtimeaccum=${TMPDIR}/time.accum
XLOGFILE=${RESULTDIR}/log
X#add old log to accumulated log or move it
Xif test -w ${RESULTDIR}/log
Xthen
X   if test -w ${RESULTDIR}/log.accum
X   then
X      cat ${RESULTDIR}/log >> ${RESULTDIR}/log.accum
X      rm ${RESULTDIR}/log
X   else
X      mv ${RESULTDIR}/log ${RESULTDIR}/log.accum
X   fi
Xfi
Xecho "Start Benchmark Run (BYTE Version $version)" >>$LOGFILE
Xecho "  $date " >>$LOGFILE
Xecho " " `who | wc -l` "interactive users." >>$LOGFILE
X#if SysV use 'uname -a' -- if BSD use 'hostname'
Xuname -a >>$LOGFILE
X# hostname >>$LOGFILE
X#
X#if not specified, do each bench 6 iterations
Xiter=${iterations-6}
Xif test $iter -eq 6
Xthen
X  longloop="1 2 3 4 5 6"
X  shortloop="1 2 3"
Xelse  # generate list of loop numbers
X  short=`expr \( $iter + 1 \) / 2`
X  longloop=""
X  shortloop=""
X  while test $iter -gt 0
X  do # do level 1
X       longloop="$iter $longloop"
X       if test $iter -le $short
X       then
X         shortloop="$iter $shortloop"
X       fi
X       iter=`expr $iter - 1`
X  done # end do level 1
Xfi #loop list genration
X####################################################################
X############## the major control loop ##############################
X####################################################################
Xfor bench # line argument processing
Xdo # do level 1
X    # set some default values
X    prog=${BINDIR}/$bench  # the bench name is default program
X    need=$prog             # we need the at least the program
X    paramlist="#"          # a dummy parameter to make anything run
X    testdir="${TESTDIR}"   # the directory in which to run the test
X    prepcmd=""             # preparation command or script
X    parammsg=""
X    repeat="$longloop"
X    stdout="$LOGFILE"
X    stdin=""
X    cleanopt="-t $tmp"
X    bgnumber=""
X    trap "${SCRPDIR}/cleanup -l $LOGFILE -a; exit" 1 2 3 15
X    if [ $runoption != 'Q' ]
X    then
X       echo "$bench: \c"
X    fi
X    echo "" >>$LOGFILE
X    ###################### select the bench specific values ##########
X    case $bench
X    in
X  dhry2)
X    options=${dhryloops-10000}
X    logmsg="Dhrystone 2 without register variables"
X    cleanopt="-d $tmp"
X    ;;
X
X  dhry2reg)
X    options=${dhryloops-10000}
X    logmsg="Dhrystone 2 using register variables"
X    cleanopt="-d $tmp"
X    ;;
X
X  arithoh|register|short|int|long)
X    options=${arithloop-10000}
X    logmsg="Arithmetic Test (type = $bench): $options Iterations"
X    ;;
X
X  float|double)
X    options=${arithloop-10000}
X    logmsg="Arithmetic Test (type = $bench): $options Iterations"
X    ;;
X
X  dc)  need=dc.dat
X    prog=dc
X    options=""
X    stdin=dc.dat
X    stdout=/dev/null
X    logmsg="Arithmetic Test (sqrt(2) with dc to 99 decimal places)"
X    ;;
X
X  hanoi)  options='$param'
X    stdout=/dev/null
X    logmsg="Recursion Test: Tower of Hanoi Problem"
X    paramlist="${ndisk-17}"
X    parammsg='$param Disk Problem:'
X    ;;
X
X  syscall)
X    options=${ncall-4000}
X    logmsg="System Call Overhead Test: 5 x $options Calls"
X    ;;
X
X  context1)
X    options=${switch1-500}
X    logmsg="Pipe-based Context Switching Test: 2 x $options Switches"
X    ;;
X
X  pipe)   options=${io-2048}
X    logmsg="Pipe Throughput Test: read & write $options x 512 byte blocks"
X    ;;
X
X  spawn)  options=${children-100}
X    logmsg="Process Creation Test: $options forks"
X    ;;
X
X  execl)  options=${nexecs-100}
X    logmsg="Execl Throughput Test: $options execs"
X    ;;
X
X  fstime) 
X    where=${where-${TMPDIR}}
X    options='$param '"$where"
X    logmsg="Filesystem Throughput Test:"
X    paramlist=${seconds-"1 10 20"}
X    parammsg='Test Time: $param secs'
X    cleanopt="-f $tmp"
X    ;;
X
X  C)   need=cctest.c
X    prog=cc
X    options='$param'
X    stdout=/dev/null
X    repeat="$shortloop"
X    logmsg="C Compiler Test:"
X    paramlist="cctest.c"
X    parammsg='cc $param'
X    rm -f a.out
X    ;;
Xdbmscli)
X    repeat="$shortloop"
X    need="db.dat"
X                          #                   records queuespace
X    prepcmd='${BINDIR}/dbprep ${testdir}/db.dat 1000    1024'
X    paramlist=${clients-"1 2 4 8"}
X    parammsg='$param client processes.'
X    logmsg="Client/Server Database Engine:"
X    options='${testdir}/db.dat $param 0 1000'  # $param clients;
X					       # 0 sleep; 1000 iterations
X    ;;
Xshell)
X    prog="multi.sh"
X    repeat="$shortloop"
X    logmsg="Bourne shell script and Unix utilities"
X    paramlist=${background-"1 2 4 8 "}
X    parammsg='$param concurrent background processes'
X    bgnumber='$param'
X    ;;
X  *)   ${BINDIR}/cleanup -l $LOGFILE -r "run: unknown benchmark \"$bench\"" -a
X    exit 1
X    ;;
Xesac
X################################################################
X###################### the main task ###########################
X###################### run the bench ###########################
X################################################################
X# each of those variables are now used in a general way
X#
Xecho "$break1" >>$LOGFILE                 # break between bench pgms
Xecho "$logmsg" >>$LOGFILE                 # benchmark name
X    for param in $paramlist
X    do   # level 2
X      param=`echo $param | sed 's/_/ /g'` # be sure that spaces are used
X					  # underscore can couple params
X      if [ "$runoption" != "Q" ]
X      then
X         echo "\n   [$param] -\c"           # generate message to user
X      fi
X      eval msg='"'$parammsg'"'            # the eval is used to
X      echo "$break2" >>$LOGFILE           # break between bench pgms
X      if test "$msg"                      # evaluate any embedded
X      then                                # variables in the parammsg
X          echo "$msg" >>$LOGFILE
X      fi
X
X      eval opt='"'$options'"'		 # evaluate any vars in options
X      eval prep='"'$prepcmd'"'		 # evaluate any prep command
X      eval bg='"'$bgnumber'"'		 # evaluate bgnumber string
X      rm -f $tmp			 # remove any tmp files
X
X      # if the test requires mulitple concurrent processes,
X      # prepare the background process string (bgstr)
X      # this is just a string of "+"s that will provides a
X      # parameter count for a "for" loop
X      bgstr=""
X      if test "$bg" != ""
X      then
X	  count=`expr "$bg"`
X          while test $count -gt 0
X          do
X	      bgstr="+ $bgstr"
X	      count=`expr $count - 1`
X	  done
X      fi
X      #
X      for i in $repeat			 # loop for the specified number
X      do  # do depth 3
X          if [ "$runoption" != 'D' ]  # level 1
X	  then
X	    # regular Run - set logfile to go on signal
X            trap "${BINDIR}/cleanup -l $LOGFILE -i $i $cleanopt -a; exit" 1 2 3 15
X	  else
X            trap "exit" 1 2 3 15
X	  fi #end level 1
X          if [ "$runoption" != 'Q' ]
X	  then
X	      echo " $i\c"                  # display repeat number
X	  fi
X	  pwd=`pwd`                     # remember where we are
X	  cd $testdir                   # move to the test directory
X	  if [ "$runoption" = "V" ]
X	  then
X		echo
X		echo "BENCH COMMAND TO BE EXECUTED:"
X		echo "$prog $opt"
X	  fi
X
X	  # execute any prepratory command string
X	  if [ -n "$prep" ]
X	  then
X	    $prep 2>&1 >>$stdout 
X	  fi
X	  ############ THE BENCH IS TIMED ##############
X          if test "$stdin" = ""  
X          then # without redirected stdin
X             time $prog $opt $bgstr 2>>$tmp >>$stdout
X          else # with redirected stdin
X             time $prog $opt $bgstr <$stdin 2>>$tmp >>$stdout
X          fi 
X	  time $benchcmd
X	  ###############################################
X	  cd $pwd                    # move back home
X          status=$?                  # save the result code
X          if test $status != 0 # must have been an error
X          then
X           if test -f $tmp # is there an error file ?
X           then
X                cp $tmp ${TMPDIR}/save.$bench.$param
X            ${SCRPDIR}/cleanup -l $LOGFILE -i $i $cleanopt -r \
X	       "run: bench=$bench param=$param fatalstatus=$status" -a
X           else
X            ${SCRPDIR}/cleanup -l $LOGFILE -r \
X	       "run: bench=$bench param=$param fatalstatus=$status" -a
X           fi 
X           exit # leave the script if there are errors
X          fi # end  level 1
X      done # end do depth 3 - repeat of bench
X      if [ "$runoption" != 'D' ]
X      then
X        ${SCRPDIR}/cleanup -l $LOGFILE $cleanopt # finalize this bench
X						 # with these options
X						 # & calculate results
X      fi
X    done # end do depth 2 - end of all options for this bench
X
X    ########### some specific cleanup routines ##############
X    case $bench
X    in
X      C)
X      rm -f cctest.o a.out
X      ;;
X
X      fstime)
X      sync; sleep 20
X      ;;
X    esac
X    if [ "$runoption" != 'Q' ]
X    then
X       echo ""
X    fi
Xdone # end do level 1  - all benchmarks requested
X########## a few last items for the end ##############
Xecho "" >>$LOGFILE
Xecho " " `who | wc -l` "interactive users." >>$LOGFILE
Xecho "End Benchmark Run ($date) ...." >>$LOGFILE
Xif [ "$runoption" != 'Q' ]
Xthen
X  pg $LOGFILE
Xfi
Xexit
X########################### Amen ######################
END_OF_FILE
echo shar: 1 control character may be missing from \"'Run'\"
if test 13521 -ne `wc -c <'Run'`; then
    echo shar: \"'Run'\" unpacked with wrong size!
fi
chmod +x 'Run'
# end of 'Run'
fi
if test -f 'dummy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dummy.c'\"
else
echo shar: Extracting \"'dummy.c'\" \(7461 characters\)
sed "s/^X//" >'dummy.c' <<'END_OF_FILE'
X
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: dummy.c   SID: 2.4 4/17/90 16:45:32
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *
X ******************************************************************************/
Xchar SCCSid[] = "@(#) @(#)dummy.c:2.4 -- 4/17/90 16:45:32";
X/*
X *  Hacked up C program for use in the standard shell.? scripts of
X *  the multiuser test.  This is based upon makework.c, and is typically
X *  edited using edscript.2 before compilation.
X *
X * $Header: dummy.c,v 3.4 87/06/23 15:54:53 kjmcdonell Beta $
X */
X
X#include <stdio.h>
X#include <signal.h>
X
X#define DEF_RATE	5.0
X#define GRANULE		5
X#define CHUNK		60
X#define MAXCHILD	12
X#define MAXWORK		10
X
Xfloat	thres;
Xfloat	est_rate = DEF_RATE;
Xint	nusers;		/* number of concurrent users to be simulated by
X			 * this process */
Xint	firstuser;	/* ordinal identification of first user for this
X			 * process */
Xint	nwork = 0;	/* number of job streams */
Xint	exit_status = 0;	/* returned to parent */
Xint	sigpipe;	/* pipe write error flag */
X
Xstruct st_work {
X	char	*cmd;		/* name of command to run */
X	char	**av;		/* arguments to command */
X	char	*input;		/* standard input buffer */
X	int	inpsize;	/* size of standard input buffer */
X} work[MAXWORK];
X
Xstruct {
X	int	xmit;	/* # characters sent */
X	char	*bp;	/* std input buffer pointer */
X	int	blen;	/* std input buffer length */
X	int	fd;	/* stdin to command */
X	int	pid;	/* child PID */
X	char	*line;	/* start of input line */ 
X	int	firstjob;	/* inital piece of work */
X	int	thisjob;	/* current piece of work */
X} child[MAXCHILD], *cp;
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X    int		i;
X    int		l;
X    int		fcopy = 0;	/* fd for copy output */
X    int		master = 1;	/* the REAL master, == 0 for clones */
X    int		nchild;		/* no. of children for a clone to run */
X    int		done;		/* count of children finished */
X    int		output;		/* aggregate output char count for all
X				   children */
X    int		c;
X    int		thiswork = 0;	/* next job stream to allocate */
X    int		nch;		/* # characters to write */
X    int		written;	/* # characters actully written */
X    char	logname[15];	/* name of the log file(s) */
X    int		onalarm();
X    int		pipeerr();
X    int		wrapup();
X    int		grunt();
X    char	*malloc();
X    int		pvec[2];	/* for pipes */
X    char	*p;
X    char	*prog;		/* my name */
X
X#if ! debug
X    freopen("masterlog.00", "a", stderr);
X#endif
X    fprintf(stderr, "*** New Run ***  ");
X    prog = argv[0];
X    while (argc > 1 && argv[1][0] == '-')  {
X	p = &argv[1][1];
X	argc--;
X	argv++;
X	while (*p) {
X	    switch (*p) {
X	    case 'r':
X			/* code DELETED here */
X			argc--;
X			argv++;
X			break;
X
X	    case 'c':
X			/* code DELETED here */
X			lseek(fcopy, 0L, 2);	/* append at end of file */
X			break;
X
X	    default:
X		fprintf(stderr, "%s: bad flag '%c'\n", prog, *p);
X			exit(4);
X	    }
X	    p++;
X	}
X    }
X    
X    if (argc < 2) {
X	fprintf(stderr, "%s: missing nusers\n", prog);
X	exit(4);
X    }
X
X    nusers = atoi(argv[1]);
X    if (nusers < 1) {
X	fprintf(stderr, "%s: impossible nusers (%d<-%s)\n", prog, nusers, argv[1]);
X	exit(4);
X    }
X    fprintf(stderr, "%d Users\n", nusers);
X    argc--;
X    argv++;
X
X    /* build job streams */
X    getwork();
X#if debug
X    dumpwork();
X#endif
X
X    /* clone copies of myself to run up to MAXCHILD jobs each */
X    firstuser = MAXCHILD;
X    fprintf(stderr, "master pid %d\n", getpid());
X    fflush(stderr);
X    while (nusers > MAXCHILD) {
X	fflush(stderr);
X	if (nusers >= 2*MAXCHILD)
X	    /* the next clone must run MAXCHILD jobs */
X	    nchild = MAXCHILD;
X	else
X	    /* the next clone must run the leftover jobs */
X	    nchild = nusers - MAXCHILD;
X	if ((l = fork()) == -1) {
X	    /* fork failed */
X	    fatal("** clone fork failed **\n");
X	    goto bepatient;
X	} else if (l > 0) {
X	    fprintf(stderr, "master clone pid %d\n", l);
X	    /* I am the master with nchild fewer jobs to run */
X	    nusers -= nchild;
X	    firstuser += MAXCHILD;
X	    continue;
X	} else {
X	    /* I am a clone, run MAXCHILD jobs */
X#if ! debug
X	    sprintf(logname, "masterlog.%02d", firstuser/MAXCHILD);
X	    freopen(logname, "w", stderr);
X#endif
X	    master = 0;
X	    nusers = nchild;
X	    break;
X	}
X    }
X    if (master)
X	firstuser = 0;
X
X    close(0);
X
X    /* code DELETED here */
X
X    fflush(stderr);
X
X    srand(time(0));
X    thres = 0;
X    done = output = 0;
X    for (i = 0; i < nusers; i++) {
X	if (child[i].blen == 0)
X	    done++;
X	else
X	    thres += est_rate * GRANULE;
X    }
X    est_rate = thres;
X
X    signal(SIGALRM, onalarm);
X    signal(SIGPIPE, pipeerr);
X    alarm(GRANULE);
X    while (done < nusers) {
X	for (i = 0; i < nusers; i++) {
X	    cp = &child[i];
X	    if (cp->xmit >= cp->blen) continue;
X	    l = rand() % CHUNK + 1;	/* 1-CHUNK chars */
X	    if (l == 0) continue;
X	    if (cp->xmit + l > cp->blen)
X		l = cp->blen - cp->xmit;
X	    p = cp->bp;
X	    cp->bp += l;
X	    cp->xmit += l;
X#if debug
X	    fprintf(stderr, "child %d, %d processed, %d to go\n", i, cp->xmit, cp->blen - cp->xmit);
X#endif
X	    while (p < cp->bp) {
X		if (*p == '\n' || (p == &cp->bp[-1] && cp->xmit >= cp->blen)) {
X		    /* write it out */
X		    nch = p - cp->line + 1;
X		    if ((written = write(cp->fd, cp->line, nch)) != nch) {
X
X			/* code DELETED here */
X
X		    }
X		    if (fcopy)
X			write(fcopy, cp->line, p - cp->line + 1);
X#if debug
X		    fprintf(stderr, "child %d gets \"", i);
X		    {
X			char *q = cp->line;
X			while (q <= p) {
X				if (*q >= ' ' && *q <= '~')
X					fputc(*q, stderr);
X				else
X					fprintf(stderr, "\\%03o", *q);
X				q++;
X			}
X		    }
X		    fputc('"', stderr);
X#endif
X		    cp->line = &p[1];
X		}
X		p++;
X	    }
X	    if (cp->xmit >= cp->blen) {
X		done++;
X		close(cp->fd);
X#if debug
X	fprintf(stderr, "child %d, close std input\n", i);
X#endif
X	    }
X	    output += l;
X	}
X	while (output > thres) {
X	    pause();
X#if debug
X	    fprintf(stderr, "after pause: output, thres, done %d %.2f %d\n", output, thres, done);
X#endif
X	}
X    }
X
Xbepatient:
X    alarm(0);
X/****
X *  If everything is going OK, we should simply be able to keep
X *  looping unitil 'wait' fails, however some descendent process may
X *  be in a state from which it can never exit, and so a timeout
X *  is used.
X *  5 minutes should be ample, since the time to run all jobs is of
X *  the order of 5-10 minutes, however some machines are painfully slow,
X *  so the timeout has been set at 20 minutes (1200 seconds).
X ****/
X
X    /* code DELETED here */
X
X}
X
Xonalarm()
X{
X    thres += est_rate;
X    signal(SIGALRM, onalarm);
X    alarm(GRANULE);
X}
X
Xgrunt()
X{
X    /* timeout after label "bepatient" in main */
X    exit_status = 4;
X    wrapup();
X}
X
Xpipeerr()
X{
X	sigpipe++;
X}
X
Xwrapup()
X{
X    /* DUMMY, real code dropped */
X}
X
Xgetwork()
X{
X
X    /* DUMMY, real code dropped */
X    gets();
X    strncpy();
X    malloc(); realloc();
X    open(); close();
X}
X
Xfatal(s)
Xchar *s;
X{
X    int	i;
X    fprintf(stderr, s);
X    fflush(stderr);
X    perror("Reason?");
X    for (i = 0; i < nusers; i++) {
X	if (child[i].pid > 0 && kill(child[i].pid, SIGKILL) != -1)
X	    fprintf(stderr, "pid %d killed off\n", child[i].pid);
X    }
X    fflush(stderr);
X    exit_status = 4;
X    return;
X}
END_OF_FILE
if test 7461 -ne `wc -c <'dummy.c'`; then
    echo shar: \"'dummy.c'\" unpacked with wrong size!
fi
chmod +x 'dummy.c'
# end of 'dummy.c'
fi
if test -f 'fstime.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fstime.c'\"
else
echo shar: Extracting \"'fstime.c'\" \(4801 characters\)
sed "s/^X//" >'fstime.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: fstime.c   SID: 2.8 4/17/90 16:45:33
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X * $Header: fstime.c,v 3.4 87/06/22 14:23:05 kjmcdonell Beta $
X * 10/19/89 - rewrote timing calcs and added clock check (Ben Smith)
X * 10/26/89 - simplify timing, change defaults (Tom Yager)
X * 11/16/89 - added better error handling and changed output format (Ben Smith)
X * 11/17/89 - changed the whole thing around (Ben Smith)
X ******************************************************************************/
Xchar SCCSid[] = "@(#) @(#)fstime.c:2.8 -- 4/17/90 16:45:33";
X
X#include <stdio.h>
X#include <signal.h>
X#include <errno.h>
X
X#define SECONDS 10
X#define BUFF_SIZE 1024
X
X/****************** GLOBALS ***************************/
Xchar buf[BUFF_SIZE];
Xint			seconds = SECONDS;
Xint			f;
Xint			g;
Xint			i;
Xint			stop_count();
Xint			clean_up();
Xint			sigalarm = 0;
X
X/******************** MAIN ****************************/
X
Xmain(argc, argv)
Xchar **argv;
X{
X
X/**** initialize ****/
X    if (argc > 1)
X	seconds = atoi(argv[1]);
X    if (argc == 3 && chdir(argv[2]) == -1) 
X	    {
X	    perror("fstime: chdir");
X	    exit(1);
X	    }
X    if((f = creat("dummy0", 0600)) != -1)
X            close(f);
X    else
X	    {
X	    perror("fstime: creat");
X	    exit(1);
X	    }
X    if((g = creat("dummy1", 0600)) != -1)
X            close(g);
X    else
X	    {
X	    perror("fstime: creat");
X	    exit(1);
X	    }
X    if((f = open("dummy0", 2)) == -1)
X	    {
X	    perror("fstime: open");
X	    exit(1);
X	    }
X    if((g = open("dummy1", 2)) == -1)
X	    {
X	    perror("fstime: open");
X	    exit(1);
X	    }
X    /* fill buffer */
X    for (i = 0; i < BUFF_SIZE; i++)
X	buf[i] = i & 0177;
X    /*** run the tests ****/
X    signal(SIGKILL,clean_up);
X    if(w_test())
X	{
X	clean_up();
X	exit(1);
X	}
X    if(r_test())
X	{
X	clean_up();
X	exit(1);
X	}
X    if(c_test())
X	{
X	clean_up();
X	exit(1);
X	}
X    clean_up();
X    exit(0);
X}
X
Xw_test() 
X/* write test */
X{
X    long n_blocks = 0L;
X    extern int sigalarm;
X
X    sync();
X    sleep(5); /* to insure the sync */
X
X    signal(SIGALRM,stop_count);
X    sigalarm = 0; /* reset alarm flag */
X    alarm(seconds);
X    while(!sigalarm)
X	{
X	if (write(f, buf, BUFF_SIZE) <= 0)
X	    {
X            if (errno != EINTR) {
X	        perror("fstime: write");
X	        return(-1);
X                } else stop_count();
X	    }
X	++ n_blocks;
X        }
X    /* stop clock */
X    fprintf(stderr, "%ld Kbytes/sec write (%d second sample)\n", 
X         (long) n_blocks / (long) seconds, seconds);
Xreturn(0);
X}
X
Xr_test() 
X/* read test */
X{
X    long n_blocks = 0L;
X    extern int sigalarm;
X    extern int errno;
X
X    /* rewind */
X    sync();
X    sleep(5);
X    lseek(f, 0L, 0);
X
X    signal(SIGALRM,stop_count);
X    sigalarm = 0; /* reset alarm flag */
X    alarm(seconds);
X    while(!sigalarm)
X	{
X	if (read(f, buf, BUFF_SIZE) <= 0)
X	    {
X            if (errno == EINVAL) {
X                lseek(f, 0L, 0);  /* rewind at end of file */
X            } else {
X                if (errno != EINTR) {
X                   perror("fstime: read");
X	           return(-1);
X                   } else stop_count();
X	        }
X            }
X	++ n_blocks;
X        }
X    /* stop clock */
X    fprintf(stderr, "%ld Kbytes/sec read (%d second sample)\n", 
X         (long) n_blocks / (long) seconds, seconds);
Xreturn(0);
X}
X
X
Xc_test() 
X/* copy test */
X{
X    long n_blocks = 0L;
X    extern int sigalarm;
X
X    /* rewind */
X    sync();
X    sleep(5); /* to insure the sync */
X    lseek(f, 0L, 0);
X
X    signal(SIGALRM,stop_count);
X    sigalarm = 0; /* reset alarm flag */
X    alarm(seconds);
X    while(!sigalarm)
X	{
X	if (read(f, buf, BUFF_SIZE) <= 0)
X	    {
X            if (errno == EINVAL) {
X                lseek(f, 0L, 0);  /* rewind at end of file */
X            } else {
X                if (errno != EINTR) {
X                    perror("fstime: read");
X	            return(-1);
X                    } else stop_count();
X	        }
X            }
X	if (write(g, buf, BUFF_SIZE) <= 0)
X	    {
X            if (errno != EINTR) {
X	        perror("fstime: write in copy");
X	        return(-1);
X                } else stop_count();
X	    }
X	++ n_blocks;
X        }
X    /* stop clock */
X    fprintf(stderr, "%ld Kbytes/sec copy (%d second sample)\n", 
X         (long) n_blocks / (long) seconds, seconds);
Xreturn(0);
X}
X
Xstop_count()
X{
Xextern int sigalarm;
Xsigalarm = 1;
Xreturn(0);
X}
X
Xclean_up()
X{
Xunlink(f);
Xunlink(g);
Xreturn(0);
X}
END_OF_FILE
if test 4801 -ne `wc -c <'fstime.c'`; then
    echo shar: \"'fstime.c'\" unpacked with wrong size!
fi
chmod +x 'fstime.c'
# end of 'fstime.c'
fi
if test -f 'precision.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'precision.c'\"
else
echo shar: Extracting \"'precision.c'\" \(5691 characters\)
sed "s/^X//" >'precision.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 2
X *          Module: precision.c   SID: 2.4 4/17/90 16:45:35
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: precision.c,v 3.5 87/08/06 08:10:59 kenj Exp $
X *
X ******************************************************************************/
Xchar SCCSid[] = "@(#) @(#)precision.c:2.4 -- 4/17/90 16:45:35";
X/* Program to determine properties of the arithmetic available. */
X/* Makes certain assumptions about the likely format of numbers */
X/*								*/
X/* Author: Steven Pemberton, CWI, Amsterdam. steven@mcvax	*/
X/*								*/
X/* If your C system is not unix but does have signal/setjmp,	*/
X/*    add a #define unix					*/
X/* You may also need to change the #include <sys/signal.h> line */
X/*    and add some calls to signal().				*/
X/*
X */
X
X#ifdef unix
X
X#define SIGNAL
X
X#include <sys/signal.h>
X#include <setjmp.h>
X
Xjmp_buf lab;
Xoverflow(sig) int sig; { /*what to do on overflow*/
X	signal(sig, overflow);
X	longjmp(lab, 1);
X}
X
X#endif
X
Xint tenlog(v) double v; {
X	/*The largest power of ten less than v*/
X	int p=0;
X	while (v>10) { p++; v/=10; }
X	return p;
X}
X
Xint two(v) int v; {
X	/* (the closest power of two to v)-1 */
X	int t=1, s;
X	while (t<v) t=t*2+1;
X	s=(t-1)/2;
X	if ((v-s)>(t-v)) return(t);
X	return(s);
X}
X
Xdouble twopower(n, e) int n, *e; {
X	/* Calculate 2**n without overflow worries */
X	/* Result is r*10**e */
X	double r=1.0; *e=0;
X	while (n-- > 0) {
X		r*=2.0;
X		if (r>10.0) { r/=10.0; (*e)++; }
X	}
X	return(r);
X}
X
Xmain() {
X	short maxshort, newshort;
X	int maxint, newint, i, maxfexp, maxdexp, bits,
X	    fmantis, dmantis, ddmantis,
X	    shortpower, intpower, longpower,
X	    fpower, dpower, fipower, dipower, ddipower, lpower, base;
X	long maxlong, newlong;
X	float maxfloat, newfloat, sum, f, maxifloat;
X	double maxdouble, newdouble, maxidouble, maxiexpr,
X	       d, incr, dsum;
X
X#ifdef SIGNAL
X	signal(SIGFPE, overflow); /*signal(SIGOVER, overflow);*/
X#endif
X
X/****** Calculate max short *********************************************/
X/*      Calculate 2**n-1 until overflow - then use the previous value	*/
X
X	newshort=1; maxshort=0;
X#ifdef SIGNAL
X	if (setjmp(lab)==0)
X#endif
X	for(shortpower=0; newshort>maxshort; shortpower++) {
X		maxshort=newshort;
X		newshort=newshort*2+1;
X	}
X	bits= (shortpower+1)/sizeof(short);
X	printf("maxshort=%d (=2**%d-1)\n", maxshort, shortpower);
X
X/****** Calculate max int by the same method ***************************/
X
X	newint=1; maxint=0;
X#ifdef SIGNAL
X	if (setjmp(lab)==0)
X#endif
X	for(intpower=0; newint>maxint; intpower++) {
X		maxint=newint;
X		newint=newint*2+1;
X	}
X	printf("maxint=%d (=2**%d-1)\n", maxint, intpower);
X
X/****** Calculate max long by the same method ***************************/
X
X	newlong=1; maxlong=0;
X#ifdef SIGNAL
X	if (setjmp(lab)==0)
X#endif
X	for(longpower=0; newlong>maxlong; longpower++) {
X		maxlong=newlong;
X		newlong=newlong*2+1;
X	}
X	printf("maxlong=%ld (=2**%d-1)\n", maxlong, longpower);
X
X/****** Calculate max float, assuming it's a power of two ***************/
X/*	Calculate 2**i until it overflows, and then use the nearest	*/
X/*	power of two (some machines overflow early, some late)		*/
X
X	newfloat=1; maxfloat=0;
X#ifdef SIGNAL
X	if (setjmp(lab)==0)
X#endif
X	for(i=0;newfloat>maxfloat;i++) {
X		maxfloat=newfloat;
X		newfloat=newfloat*2;
X	}
X	maxfexp=two(i); maxfloat=twopower(maxfexp, &fpower);
X	printf("maxfloat=~%fE%d (=~2**%d) (%d bits)\n",
X			maxfloat, fpower, maxfexp, sizeof(float)*bits);
X
X/****** Calculate max double, assuming it's a power of two **************/
X
X	newdouble=1; maxdouble=0;
X#ifdef SIGNAL
X	if (setjmp(lab)==0)
X#endif
X	for(i=0;newdouble>maxdouble;i++) {
X		maxdouble=newdouble;
X		newdouble*=2;
X	}
X#ifdef SIGNAL
X	if (setjmp(lab)!=0) { printf("\nUnexpected overflow\n"); exit(1); }
X#endif
X	maxdexp=two(i); maxdouble=twopower(maxdexp, &dpower);
X	printf("maxdouble=~%fE%d (=~2**%d) (%d bits)\n",
X			maxdouble, dpower, maxdexp, sizeof(double)*bits);
X
X/****** Calculate the accuracy for float, double, and expressions *******/
X/*	maxintfloat and maxintdouble are the largest values that can	*/
X/*	still be integer values; ie such that (x+1)-x=1.		*/
X/*	Some systems really do use extra precision in expressions	*/
X
X	f=2.0; incr=1.0; sum=f+incr;
X	for (fmantis=0; sum>2.0; fmantis++) { incr/=2; sum=f+incr; }
X	printf("max float exp=%d mantissa bits=%d\n", maxfexp, fmantis);
X
X	d=2.0; incr=1.0; dsum=d+incr;
X	for (dmantis=0; dsum>2.0; dmantis++) { incr/=2; dsum=d+incr; }
X	printf("max double exp=%d mantissa bits=%d\n", maxdexp, dmantis);
X
X	d=2.0; incr=1.0;
X	for (ddmantis=0; d+incr>2.0; ddmantis++) incr/=2;
X
X	maxifloat=twopower(fmantis, &fipower);
X	printf("maxintfloat=~%fE%d (=2**%d-1) (%d digit precision)\n",
X			maxifloat, fipower, fmantis, fipower);
X
X	maxidouble=twopower(dmantis, &dipower);
X	printf("maxintdouble=~%fE%d (=2**%d-1) (%d digit precision)\n",
X			maxidouble, dipower, dmantis, dipower);
X
X	maxiexpr=twopower(ddmantis, &ddipower);
X	printf("maxint for expressions=~%fE%d (=2**%d-1) (%d digit precision)\n",
X			maxiexpr, ddipower, ddmantis, ddipower);
X
X/****** BASE is the largest power of ten such that BASE*BASE can be	*/
X/*	computed exactly as a double, and BASE+BASE as a long, useful	*/
X/*	for multi-length arithmetic					*/
X
X	lpower= tenlog((double)(maxlong/2));
X	base= (dipower/2)>lpower?lpower:(dipower/2);
X	printf("BASE=1E%d\n", base);
X	
X	exit(0);
X}
END_OF_FILE
if test 5691 -ne `wc -c <'precision.c'`; then
    echo shar: \"'precision.c'\" unpacked with wrong size!
fi
chmod +x 'precision.c'
# end of 'precision.c'
fi
if test -f 'sort.src' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sort.src'\"
else
echo shar: Extracting \"'sort.src'\" \(8555 characters\)
sed "s/^X//" >'sort.src' <<'END_OF_FILE'
Xversion="1.2"
Xumask 022    # at least mortals can read root's files this way
XPWD=`pwd`
XHOMEDIR=${HOMEDIR:-.}
Xcd $HOMEDIR
XHOMEDIR=`pwd`
Xcd $PWD
XBINDIR=${BINDIR:-${HOMEDIR}/pgms}
Xcd $BINDIR
XBINDIR=`pwd`
Xcd $PWD
XPATH="${PATH}:${BINDIR}"
XSCRPDIR=${SCRPDIR:-${HOMEDIR}/pgms}
Xcd $SCRPDIR
XSCRPDIR=`pwd`
Xcd $PWD
XTMPDIR=${HOMEDIR}/tmp
Xcd $TMPDIR
XTMPDIR=`pwd`
Xcd $PWD
XRESULTDIR=${RESULTDIR:-${HOMEDIR}/results}
Xcd $RESULTDIR
XRESULTDIR=`pwd`
Xcd $PWD
XTESTDIR=${TESTDIR:-${HOMEDIR}/testdir}
Xcd $TESTDIR
XTESTDIR=`pwd`
Xcd $PWD
Xexport BINDIR TMPDIR RESULTDIR PATH
Xbell=""
Xecho "kill -9 $$" > ${TMPDIR}/kill_run ; chmod u+x ${TMPDIR}/kill_run
Xarithmetic="arithoh register short int long float double dc"
Xsystem="syscall pipe context1 spawn execl fstime"
Xmem="seqmem randmem"
Xmisc="C shell"
Xdhry="dhry2 dhry2reg" # dhrystone loops
Xdb="dbmscli" # add to as new database engines are developed
Xload="shell" # cummulative load tests
Xargs="" # the accumulator for the bench units to be run
Xrunoption="N"
Xfor word
Xdo  # do level 1
Xcase $word
Xin
Xall)
X;;
Xarithmetic)
Xargs="$args $arithmetic"
X;;
Xdb)
Xargs="$args $db"
X;;
Xdhry)
Xargs="$args $dhry"
X;;
Xload)
Xargs="$args $load"
X;;
Xmem)
Xargs="$args $mem"
X;;
Xmisc)
Xargs="$args $misc"
X;;
Xspeed)
Xargs="$args $arithmetic $system"
X;;
Xsystem)
Xargs="$args $system"
X;;
X-q|-Q)
Xrunoption="Q" #quiet
X;;
X-v|-V)
Xrunoption="V" #verbose
X;;
X-d|-D)
Xrunoption="D" #debug
X;;
X*)
Xargs="$args $word"
X;;
Xesac
Xdone # end do level 1
Xset - $args
Xif test $# -eq 0  #no arguments specified
Xthen
Xset - $dhry $arithmetic $system $misc  # db and work not included
Xfi
Xif test "$runoption" = 'D'
Xthen
Xset -x
Xset -v
Xfi
Xdate=`date`
Xtmp=${TMPDIR}/$$.tmp
XLOGFILE=${RESULTDIR}/log
Xif test -w ${RESULTDIR}/log
Xthen
Xif test -w ${RESULTDIR}/log.accum
Xthen
Xcat ${RESULTDIR}/log >> ${RESULTDIR}/log.accum
Xrm ${RESULTDIR}/log
Xelse
Xmv ${RESULTDIR}/log ${RESULTDIR}/log.accum
Xfi
Xecho "Start Benchmark Run (BYTE Version $version)" >>$LOGFILE
Xecho "  $date (long iterations $iter times)" >>$LOGFILE
Xecho " " `who | wc -l` "interactive users." >>$LOGFILE
Xuname -a >>$LOGFILE
Xiter=${iterations-6}
Xif test $iter -eq 6
Xthen
Xlongloop="1 2 3 4 5 6"
Xshortloop="1 2 3"
Xelse  # generate list of loop numbers
Xshort=`expr \( $iter + 1 \) / 2`
Xlongloop=""
Xshortloop=""
Xwhile test $iter -gt 0
Xdo # do level 1
Xlongloop="$iter $longloop"
Xif test $iter -le $short
Xthen
Xshortloop="$iter $shortloop"
Xfi
Xiter=`expr $iter - 1`
Xdone # end do level 1
Xfi #loop list genration
Xfor bench # line argument processing
Xdo # do level 1
X# set some default values
Xprog=${BINDIR}/$bench  # the bench name is default program
Xneed=$prog             # we need the at least the program
Xparamlist="#"          # a dummy parameter to make anything run
Xtestdir="${TESTDIR}"   # the directory in which to run the test
Xprepcmd=""             # preparation command or script
Xparammsg=""
Xrepeat="$longloop"
Xstdout="$LOGFILE"
Xstdin=""
Xcleanopt="-t $tmp"
Xbgnumber=""
Xtrap "${SCRPDIR}/cleanup -l $LOGFILE -a; exit" 1 2 3 15
Xif [ $runoption != 'Q' ]
Xthen
Xecho "$bench: \c"
Xfi
Xecho "" >>$LOGFILE
X###################### select the bench specific values ##########
Xcase $bench
Xin
Xdhry2)
Xoptions=${dhryloops-10000}
Xlogmsg="Dhrystone 2 without register variables"
Xcleanopt="-d $tmp"
X;;
Xdhry2reg)
Xoptions=${dhryloops-10000}
Xlogmsg="Dhrystone 2 using register variables"
Xcleanopt="-d $tmp"
X;;
Xarithoh|register|short|int|long|float|double)
Xoptions=${arithloop-10000}
Xlogmsg="Arithmetic Test (type = $bench): $options Iterations"
X;;
Xdc)  need=dc.dat
Xprog=dc
Xoptions=""
Xstdin=dc.dat
Xstdout=/dev/null
Xlogmsg="Arithmetic Test (sqrt(2) with dc to 99 decimal places)"
X;;
Xhanoi)  options='$param'
Xstdout=/dev/null
Xlogmsg="Recursion Test: Tower of Hanoi Problem"
Xparamlist="${ndisk-17}"
Xparammsg='$param Disk Problem:'
X;;
Xsyscall)
Xoptions=${ncall-4000}
Xlogmsg="System Call Overhead Test: 5 x $options Calls"
X;;
Xcontext1)
Xoptions=${switch1-500}
Xlogmsg="Pipe-based Context Switching Test: 2 x $options Switches"
X;;
Xpipe)   options=${io-2048}
Xlogmsg="Pipe Throughput Test: read & write $options x 512 byte blocks"
X;;
Xspawn)  options=${children-100}
Xlogmsg="Process Creation Test: $options forks"
X;;
Xexecl)  options=${nexecs-100}
Xlogmsg="Execl Throughput Test: $options execs"
X;;
Xrandmem|seqmem)
Xif test $bench = seqmem
Xthen
Xtype=Sequential
Xelse
Xtype=Random
Xfi
Xpoke=${poke-1000000}
Xoptions='-s$param '"-n$poke"
Xlogmsg="$type Memory Access Test: $poke Accesses"
Xparamlist=${arrays-"512 1024 2048 8192 16384"}
Xparammsg='Array Size: $param bytes'
Xcleanopt="-m $tmp"
X;;
Xfstime) repeat="$shortloop"
Xwhere=${where-${TMPDIR}}
Xoptions='$param '"$where"
Xlogmsg="Filesystem Throughput Test:"
Xparamlist=${blocks-"512 1024 2048 8192"}
Xparammsg='File Size: $param blocks'
Xcleanopt="-f $tmp"
X;;
XC)   need=cctest.c
Xprog=cc
Xoptions='$param'
Xstdout=/dev/null
Xrepeat="$shortloop"
Xlogmsg="C Compiler Test:"
Xparamlist="cctest.c"
Xparammsg='cc $param'
Xrm -f a.out
X;;
Xdbmscli)
Xrepeat="$shortloop"
Xneed="db.dat"
Xprepcmd='${BINDIR}/dbprep ${testdir}/db.dat 10000'
Xparamlist=${clients-"1 2 4 8"}
Xparammsg='$param client processes. (filesize `cat ${testdir}/db.dat|wc -c` bytes)'
Xlogmsg="Client/Server Database Engine:"
Xoptions='${testdir}/db.dat $param 0 1000'  # $param clients;
X# 0 sleep; 1000 iterations
X;;
Xshell)
Xprog="multi.sh"
Xrepeat="$shortloop"
Xlogmsg="Bourne shell script and Unix utilities"
Xparamlist=${background-"1 2 4 8"}
Xparammsg='$param concurrent background processes'
Xbgnumber='$param'
Xtestdir="shelldir"
X;;
X*)   ${BINDIR}/cleanup -l $LOGFILE -r "run: unknown benchmark \"$bench\"" -a
Xexit 1
X;;
Xesac
Xecho "$logmsg" >>$LOGFILE
Xfor param in $paramlist
Xdo   # level 2
Xparam=`echo $param | sed 's/_/ /g'` # be sure that spaces are used
X# underscore can couple params
Xif [ "$runoption" != "Q" ]
Xthen
Xecho "\n   [$param] -\c"           # generate message to user
Xfi
Xeval msg='"'$parammsg'"'            # the eval is used to
Xif test "$msg"                      # evaluate any embedded
Xthen                                # variables in the parammsg
Xecho "" >>$LOGFILE
Xecho "$msg" >>$LOGFILE
Xfi
Xeval opt='"'$options'"'   # evaluate any vars in options
Xeval prep='"'$prepcmd'"'   # evaluate any prep command
Xeval bg='"'$bgnumber'"'   # evaluate bgnumber string
Xrm -f $tmp    # remove any tmp files
X# if the test requires mulitple concurrent processes,
X# prepare the background process string (bgstr)
X# this is just a string of "+"s that will provides a
X# parameter count for a "for" loop
Xbgstr=""
Xif test "$bg" != ""
Xthen
Xcount=`expr "$bg"`
Xwhile test $count -gt 0
Xdo
Xbgstr="+ $bgstr"
Xcount=`expr $count - 1`
Xdone
Xfi
X#
Xfor i in $repeat    # loop for the specified number
Xdo  # do depth 3
Xif [ "$runoption" != 'D' ]  # level 1
Xthen
X# regular Run - set logfile to go on signal
Xtrap "${SCRPDIR}/cleanup -l $LOGFILE -i $i $cleanopt -a; exit" 1 2 3 15
Xelse
Xtrap "exit" 1 2 3 15
Xfi #end level 1
Xif [ "$runoption" != 'Q' ]
Xthen
Xecho " $i\c"                  # display repeat number
Xfi
Xpwd=`pwd`                     # remember where we are
Xcd $testdir                   # move to the test directory
Xif [ "$runoption" = "V" ]
Xthen
Xecho
Xecho "BENCH COMMAND TO BE EXECUTED:"
Xecho "$prog $opt"
Xfi
X# execute any prepratory command string
Xif [ -n "$prep" ]
Xthen
X$prep >>$stdout 
Xfi
X############ THE BENCH IS TIMED ##############
Xif test "$stdin" = ""  
Xthen # without redirected stdin
Xtime $prog $opt $bgstr 2>>$tmp >>$stdout
Xelse # with redirected stdin
Xtime $prog $opt $bgstr <$stdin 2>>$tmp >>$stdout
Xfi 
Xtime $benchcmd
X###############################################
Xcd $pwd                    # move back home
Xstatus=$?                  # save the result code
Xif test $status != 0 # must have been an error
Xthen
Xif test -f $tmp # is there an error file ?
Xthen
Xcp $tmp ${TMPDIR}/save.$bench.$param
X${SCRPDIR}/cleanup -l $LOGFILE -i $i $cleanopt -r \
X"run: bench=$bench param=$param fatalstatus=$status" -a
Xelse
X${SCRPDIR}/cleanup -l $LOGFILE -r \
X"run: bench=$bench param=$param fatalstatus=$status" -a
Xfi 
Xexit # leave the script if there are errors
Xfi # end  level 1
Xdone # end do depth 3 - repeat of bench
Xif [ "$runoption" != 'D' ]
Xthen
X${SCRPDIR}/cleanup -l $LOGFILE $cleanopt # finalize this bench
X# with these options
X# & calculate results
Xfi
Xdone # end do depth 2 - end of all options for this bench
X########### some specific cleanup routines ##############
Xcase $bench
Xin
XC)
Xrm -f cctest.o a.out
X;;
Xesac
Xif [ "$runoption" != 'Q' ]
Xthen
Xecho ""
Xfi
Xdone # end do level 1  - all benchmarks requested
Xecho "" >>$LOGFILE
Xecho " " `who | wc -l` "interactive users." >>$LOGFILE
Xecho "End Benchmark Run ($date) ...." >>$LOGFILE
Xif [ "$runoption" != 'Q' ]
Xthen
Xpg $LOGFILE
Xfi
Xexit
END_OF_FILE
echo shar: 1 control character may be missing from \"'sort.src'\"
if test 8555 -ne `wc -c <'sort.src'`; then
    echo shar: \"'sort.src'\" unpacked with wrong size!
fi
chmod +x 'sort.src'
# end of 'sort.src'
fi
echo shar: End of archive 2 \(of 5\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
exit 0 # Just in case...
