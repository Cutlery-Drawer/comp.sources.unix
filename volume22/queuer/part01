Subject:  v22i007:  Multi-system program queueing package, Part01/03
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 35b29043 43ba7a34 81580e88 692c2095

Submitted-by: Scott Bradner <sob@harvisr.harvard.edu>
Posting-number: Volume 22, Issue 7
Archive-name: queuer/part01

	These programs implement a mostly-transparent queueing and
remote-execution system for programs that do not require tty-level
access to the user.  That is, standard input and output can be
copied as with rsh, but ioctls and the like will fail.  The entire
package is extremely dependent on 4.[23] networking operations and
may have some remaining localisms; however, it has been used without
much trouble on recent Ultrix and SunOS machines.  There is at least
one assumption that may require attention:  when using a remote file
system, paths of the form /r/hostname/ are assumed to reach the root
of the remote host.  Worse, some assumptions that the same path name
is valid from different hosts have probably crept in.  Finally,
NFS became popular sometime in the early evolution of the queuer so
the modes of operation that do not require a remote file system
were not fully developed.  These restrictions aside, we have found
this package quite useful.
	In operation, a program to be queued is made non-executable
by the general public and a link is established from the queue program
to the name of the program in another directory on the user's path.
Alternately, the original program can be renamed and the link
established in the same directory as the original program.  A configuration
file is created in /usr/lib/queued with the same name as the queued
program.  Access to the original program is controlled by briefly
enabling world execution using the semantics of vfork() to minimize
the window; this has proved adequate in our environment.
	A list of potential execution hosts is specified in the
configuration file and these are tried in order of least load
(as determined by examining the rwho spool files) with the local
host being used as a last resort (unless specifically disabled).
This rather autonomous behavior can be can be made more deterministic
through the use of the qmaster program.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  BGLIM.reg BIMED BIMED.check BIMED.long BLIMDEP
#   BLIMDEP.long DONEMSG GGLIM.long GGLIM.reg GLIMDEP GLIMDEP.long
#   GSPSSX.check GSPSSX.long GSPSSX.reg MANIFEST Makefile QUEUES
#   README SPSSX.check SPSSX.long SPSSX.psy1995 SPSSX.reg SPSSX2.check
#   SPSSX2.long SPSSX2.reg STUFF bcc bcsh bcsh.long bsh bsh.long cat
#   cc compiler cspawn.c defer defer.long f77 fort getload.c
#   getrload.c getstr.c gistat gistat.check gistat.long infile.c ipm
#   lock.c newstring.c nroff optcmp.c otroff qrm.1 qs.1 qs.c queue.h
#   queued.8 spell stat stat.check stat.long test titroff tp.troff
#   usr.lib.queued.shar wordproc xfputs.c
# Wrapped by rsalz@coconut.bbn.com on Tue May  1 17:18:17 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'BGLIM.reg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BGLIM.reg'\"
else
echo shar: Extracting \"'BGLIM.reg'\" \(124 characters\)
sed "s/^X//" >'BGLIM.reg' <<'END_OF_FILE'
Xprogram BGLIM.reg /usr/vendor/bin/BGLIM
Xhost burrhus
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 1800
Xmode interactive
Xqueue stat
END_OF_FILE
if test 124 -ne `wc -c <'BGLIM.reg'`; then
    echo shar: \"'BGLIM.reg'\" unpacked with wrong size!
fi
# end of 'BGLIM.reg'
fi
if test -f 'BIMED' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BIMED'\"
else
echo shar: Extracting \"'BIMED'\" \(285 characters\)
sed "s/^X//" >'BIMED' <<'END_OF_FILE'
Xprogram BIMED /usr/bmdp/exes/bmdp_mstr
Xhost burrhus
Xoption -D ignore ARG1
Xoption -F ignore ARG1
Xoption -T ignore ARG1
Xoption -b ignore ARG1
Xoption -o ignore ARG1
Xoption -n
Xoption -B
Xoption /usr/bmdp/exes/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxrun 1
Xmaxcpu 900
Xmode interactive
Xqueue stat
END_OF_FILE
if test 285 -ne `wc -c <'BIMED'`; then
    echo shar: \"'BIMED'\" unpacked with wrong size!
fi
# end of 'BIMED'
fi
if test -f 'BIMED.check' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BIMED.check'\"
else
echo shar: Extracting \"'BIMED.check'\" \(297 characters\)
sed "s/^X//" >'BIMED.check' <<'END_OF_FILE'
Xprogram BIMED.check /usr/bmdp/exes/bmdp_mstr
Xhost burrhus
Xoption -D ignore ARG1
Xoption -F ignore ARG1
Xoption -T ignore ARG1
Xoption -b ignore ARG1
Xoption -o ignore ARG1
Xoption -n
Xoption -B
Xoption /usr/bmdp/exes/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxrun 1
Xmaxcpu 180
Xmode interactive
Xqueue stat.check
END_OF_FILE
if test 297 -ne `wc -c <'BIMED.check'`; then
    echo shar: \"'BIMED.check'\" unpacked with wrong size!
fi
# end of 'BIMED.check'
fi
if test -f 'BIMED.long' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BIMED.long'\"
else
echo shar: Extracting \"'BIMED.long'\" \(297 characters\)
sed "s/^X//" >'BIMED.long' <<'END_OF_FILE'
Xprogram BIMED.long /usr/bmdp/exes/bmdp_mstr
Xhost burrhus
Xoption -D ignore ARG1
Xoption -F ignore ARG1
Xoption -T ignore ARG1
Xoption -b ignore ARG1
Xoption -o ignore ARG1
Xoption -n
Xoption -B
Xoption /usr/bmdp/exes/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxrun 1
Xmaxcpu 14400
Xmode interactive
Xqueue stat.long
END_OF_FILE
if test 297 -ne `wc -c <'BIMED.long'`; then
    echo shar: \"'BIMED.long'\" unpacked with wrong size!
fi
# end of 'BIMED.long'
fi
if test -f 'BLIMDEP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BLIMDEP'\"
else
echo shar: Extracting \"'BLIMDEP'\" \(124 characters\)
sed "s/^X//" >'BLIMDEP' <<'END_OF_FILE'
Xprogram BLIMDEP /usr/vendor/bin/BLIMDEP
Xhost burrhus
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 1800
Xmode interactive
Xqueue stat
END_OF_FILE
if test 124 -ne `wc -c <'BLIMDEP'`; then
    echo shar: \"'BLIMDEP'\" unpacked with wrong size!
fi
# end of 'BLIMDEP'
fi
if test -f 'BLIMDEP.long' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BLIMDEP.long'\"
else
echo shar: Extracting \"'BLIMDEP.long'\" \(135 characters\)
sed "s/^X//" >'BLIMDEP.long' <<'END_OF_FILE'
Xprogram BLIMDEP.long /usr/vendor/bin/BLIMDEP
Xhost burrhus
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 14400
Xmode interactive
Xqueue stat.long
END_OF_FILE
if test 135 -ne `wc -c <'BLIMDEP.long'`; then
    echo shar: \"'BLIMDEP.long'\" unpacked with wrong size!
fi
# end of 'BLIMDEP.long'
fi
if test -f 'DONEMSG' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'DONEMSG'\"
else
echo shar: Extracting \"'DONEMSG'\" \(28 characters\)
sed "s/^X//" >'DONEMSG' <<'END_OF_FILE'
XYour batch job is finished.
END_OF_FILE
if test 28 -ne `wc -c <'DONEMSG'`; then
    echo shar: \"'DONEMSG'\" unpacked with wrong size!
fi
# end of 'DONEMSG'
fi
if test -f 'GGLIM.long' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'GGLIM.long'\"
else
echo shar: Extracting \"'GGLIM.long'\" \(141 characters\)
sed "s/^X//" >'GGLIM.long' <<'END_OF_FILE'
Xprogram GGLIM.long /usr/vendor/bin/glim
Xhost generali
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 14400
Xmode interactive
Xqueue gistat.long
Xnolocal
END_OF_FILE
if test 141 -ne `wc -c <'GGLIM.long'`; then
    echo shar: \"'GGLIM.long'\" unpacked with wrong size!
fi
# end of 'GGLIM.long'
fi
if test -f 'GGLIM.reg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'GGLIM.reg'\"
else
echo shar: Extracting \"'GGLIM.reg'\" \(134 characters\)
sed "s/^X//" >'GGLIM.reg' <<'END_OF_FILE'
Xprogram GGLIM.reg /usr/vendor/bin/glim
Xhost generali
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 1800
Xmode interactive
Xqueue gistat
Xnolocal
END_OF_FILE
if test 134 -ne `wc -c <'GGLIM.reg'`; then
    echo shar: \"'GGLIM.reg'\" unpacked with wrong size!
fi
# end of 'GGLIM.reg'
fi
if test -f 'GLIMDEP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'GLIMDEP'\"
else
echo shar: Extracting \"'GLIMDEP'\" \(134 characters\)
sed "s/^X//" >'GLIMDEP' <<'END_OF_FILE'
Xprogram GLIMDEP /usr/vendor/bin/limdep
Xhost generali
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 1800
Xmode interactive
Xqueue gistat
Xnolocal
END_OF_FILE
if test 134 -ne `wc -c <'GLIMDEP'`; then
    echo shar: \"'GLIMDEP'\" unpacked with wrong size!
fi
# end of 'GLIMDEP'
fi
if test -f 'GLIMDEP.long' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'GLIMDEP.long'\"
else
echo shar: Extracting \"'GLIMDEP.long'\" \(145 characters\)
sed "s/^X//" >'GLIMDEP.long' <<'END_OF_FILE'
Xprogram GLIMDEP.long /usr/vendor/bin/limdep
Xhost generali
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 14400
Xmode interactive
Xqueue gistat.long
Xnolocal
END_OF_FILE
if test 145 -ne `wc -c <'GLIMDEP.long'`; then
    echo shar: \"'GLIMDEP.long'\" unpacked with wrong size!
fi
# end of 'GLIMDEP.long'
fi
if test -f 'GSPSSX.check' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'GSPSSX.check'\"
else
echo shar: Extracting \"'GSPSSX.check'\" \(170 characters\)
sed "s/^X//" >'GSPSSX.check' <<'END_OF_FILE'
Xprogram GSPSSX.check /usr/spss/spssx0/SPSSX
Xhost generali
Xoption /usr/spss/spssx0/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 180
Xmode interactive
Xqueue gistat.check
Xnolocal
END_OF_FILE
if test 170 -ne `wc -c <'GSPSSX.check'`; then
    echo shar: \"'GSPSSX.check'\" unpacked with wrong size!
fi
# end of 'GSPSSX.check'
fi
if test -f 'GSPSSX.long' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'GSPSSX.long'\"
else
echo shar: Extracting \"'GSPSSX.long'\" \(170 characters\)
sed "s/^X//" >'GSPSSX.long' <<'END_OF_FILE'
Xprogram GSPSSX.long /usr/spss/spssx0/SPSSX
Xhost generali
Xoption /usr/spss/spssx0/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 14400
Xmode interactive
Xqueue gistat.long
Xnolocal
END_OF_FILE
if test 170 -ne `wc -c <'GSPSSX.long'`; then
    echo shar: \"'GSPSSX.long'\" unpacked with wrong size!
fi
# end of 'GSPSSX.long'
fi
if test -f 'GSPSSX.reg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'GSPSSX.reg'\"
else
echo shar: Extracting \"'GSPSSX.reg'\" \(162 characters\)
sed "s/^X//" >'GSPSSX.reg' <<'END_OF_FILE'
Xprogram GSPSSX.reg /usr/spss/spssx0/SPSSX
Xhost generali
Xoption /usr/spss/spssx0/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 900
Xmode interactive
Xqueue gistat
Xnolocal
END_OF_FILE
if test 162 -ne `wc -c <'GSPSSX.reg'`; then
    echo shar: \"'GSPSSX.reg'\" unpacked with wrong size!
fi
# end of 'GSPSSX.reg'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2594 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X BGLIM.reg                  1	
X BIMED                      1	
X BIMED.check                1	
X BIMED.long                 1	
X BLIMDEP                    1	
X BLIMDEP.long               1	
X DONEMSG                    1	
X GGLIM.long                 1	
X GGLIM.reg                  1	
X GLIMDEP                    1	
X GLIMDEP.long               1	
X GSPSSX.check               1	
X GSPSSX.long                1	
X GSPSSX.reg                 1	
X MANIFEST                   1	This shipping list
X Makefile                   1	
X QUEUES                     1	
X README                     1	
X SPSSX.check                1	
X SPSSX.long                 1	
X SPSSX.psy1995              1	
X SPSSX.reg                  1	
X SPSSX2.check               1	
X SPSSX2.long                1	
X SPSSX2.reg                 1	
X STUFF                      1	
X bcc                        1	
X bcsh                       1	
X bcsh.long                  1	
X bsh                        1	
X bsh.long                   1	
X cat                        1	
X cc                         1	
X com.c                      2	
X compiler                   1	
X cspawn.c                   1	
X defer                      1	
X defer.c                    2	
X defer.long                 1	
X dequeue.c                  2	
X enqueue.c                  3	
X f77                        1	
X fort                       1	
X getload.c                  1	
X getrload.c                 1	
X getstr.c                   1	
X gistat                     1	
X gistat.check               1	
X gistat.long                1	
X infile.c                   1	
X ipm                        1	
X lock.c                     1	
X newstring.c                1	
X nroff                      1	
X optcmp.c                   1	
X otroff                     1	
X qmaster.c                  3	
X qrm.1                      1	
X qrm.c                      2	
X qs.1                       1	
X qs.c                       1	
X queue.1                    2	
X queue.c                    2	
X queue.h                    1	
X queued.5                   2	
X queued.8                   1	
X queued.c                   2	
X readconf.c                 2	
X selhost.c                  2	
X showqueue.c                2	
X spell                      1	
X stat                       1	
X stat.check                 1	
X stat.long                  1	
X test                       1	
X titroff                    1	
X tp.troff                   1	
X usr.lib.queued.shar        1	
X wordproc                   1	
X xfputs.c                   1	
END_OF_FILE
if test 2594 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(934 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
XOBJ=queue queued qs qrm qmaster defer
X
Xall: ${OBJ}
X
Xqueue: queue.o optcmp.o com.o readconf.o cspawn.o lock.o \
X	newstring.o infile.o getrload.o selhost.o xfputs.o
X	${CC} -o queue queue.o com.o optcmp.o readconf.o cspawn.o lock.o \
X		newstring.o infile.o getrload.o selhost.o xfputs.o
X
Xqueued: queued.o readconf.o enqueue.o newstring.o getstr.o \
X	cspawn.o lock.o showqueue.o dequeue.o infile.o xfputs.o \
X	getload.o
X	${CC} -o queued queued.o readconf.o enqueue.o newstring.o getstr.o \
X		cspawn.o lock.o showqueue.o dequeue.o infile.o xfputs.o \
X		getload.o
X
Xqs: qs.o com.o readconf.o newstring.o
X	${CC} -o qs qs.o com.o readconf.o newstring.o
X
Xqrm: qrm.o com.o readconf.o newstring.o
X	${CC} -o qrm qrm.o com.o readconf.o newstring.o
X
Xqmaster: qmaster.o readconf.o newstring.o getrload.o infile.o
X	${CC} -o qmaster qmaster.o readconf.o newstring.o getrload.o infile.o
X
Xdefer: defer.o
X	${CC} -o defer defer.o
X
Xclean:
X	rm -f *.o ${OBJ}
END_OF_FILE
if test 934 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'QUEUES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'QUEUES'\"
else
echo shar: Extracting \"'QUEUES'\" \(85 characters\)
sed "s/^X//" >'QUEUES' <<'END_OF_FILE'
Xcompiler
Xwordproc
Xstat
Xstat.check
Xstat.long
Xtest
Xgistat
Xgistat.long
Xdefer
Xdefer.long
END_OF_FILE
if test 85 -ne `wc -c <'QUEUES'`; then
    echo shar: \"'QUEUES'\" unpacked with wrong size!
fi
# end of 'QUEUES'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1915 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X	These programs implement a mostly-transparent queueing and
Xremote-execution system for programs that do not require tty-level
Xaccess to the user.  That is, standard input and output can be
Xcopied as with rsh, but ioctls and the like will fail.  The entire
Xpackage is extremely dependent on 4.[23] networking operations and
Xmay have some remaining localisms; however, it has been used without
Xmuch trouble on recent Ultrix and SunOS machines.  There is at least
Xone assumption that may require attention:  when using a remote file
Xsystem, paths of the form /r/hostname/ are assumed to reach the root
Xof the remote host.  Worse, some assumptions that the same path name
Xis valid from different hosts have probably crept in.  Finally,
XNFS became popular sometime in the early evolution of the queuer so
Xthe modes of operation that do not require a remote file system
Xwere not fully developed.  These restrictions aside, we have found
Xthis package quite useful.
X	In operation, a program to be queued is made non-executable
Xby the general public and a link is established from the queue program
Xto the name of the program in another directory on the user's path.
XAlternately, the original program can be renamed and the link
Xestablished in the same directory as the original program.  A configuration
Xfile is created in /usr/lib/queued with the same name as the queued
Xprogram.  Access to the original program is controlled by briefly
Xenabling world execution using the semantics of vfork() to minimize
Xthe window; this has proved adequate in our environment.
X	A list of potential execution hosts is specified in the
Xconfiguration file and these are tried in order of least load
X(as determined by examining the rwho spool files) with the local
Xhost being used as a last resort (unless specifically disabled).
XThis rather autonomous behavior can be can be made more deterministic
Xthrough the use of the qmaster program.
END_OF_FILE
if test 1915 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'SPSSX.check' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'SPSSX.check'\"
else
echo shar: Extracting \"'SPSSX.check'\" \(152 characters\)
sed "s/^X//" >'SPSSX.check' <<'END_OF_FILE'
Xprogram SPSSX.check /usr/spss/SPSSX
Xhost burrhus
Xoption /usr/spss/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 180
Xmode interactive
Xqueue stat.check
Xnolocal
END_OF_FILE
if test 152 -ne `wc -c <'SPSSX.check'`; then
    echo shar: \"'SPSSX.check'\" unpacked with wrong size!
fi
# end of 'SPSSX.check'
fi
if test -f 'SPSSX.long' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'SPSSX.long'\"
else
echo shar: Extracting \"'SPSSX.long'\" \(152 characters\)
sed "s/^X//" >'SPSSX.long' <<'END_OF_FILE'
Xprogram SPSSX.long /usr/spss/SPSSX
Xhost burrhus
Xoption /usr/spss/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 14400
Xmode interactive
Xqueue stat.long
Xnolocal
END_OF_FILE
if test 152 -ne `wc -c <'SPSSX.long'`; then
    echo shar: \"'SPSSX.long'\" unpacked with wrong size!
fi
# end of 'SPSSX.long'
fi
if test -f 'SPSSX.psy1995' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'SPSSX.psy1995'\"
else
echo shar: Extracting \"'SPSSX.psy1995'\" \(141 characters\)
sed "s/^X//" >'SPSSX.psy1995' <<'END_OF_FILE'
Xprogram SPSSX.psy1995 /usr/spss/SPSSX
Xhost burrhus
Xoption /usr/spss/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 1800
Xmode interactive
Xqueue stat
END_OF_FILE
if test 141 -ne `wc -c <'SPSSX.psy1995'`; then
    echo shar: \"'SPSSX.psy1995'\" unpacked with wrong size!
fi
# end of 'SPSSX.psy1995'
fi
if test -f 'SPSSX.reg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'SPSSX.reg'\"
else
echo shar: Extracting \"'SPSSX.reg'\" \(144 characters\)
sed "s/^X//" >'SPSSX.reg' <<'END_OF_FILE'
Xprogram SPSSX.reg /usr/spss/SPSSX
Xhost burrhus
Xoption /usr/spss/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 900
Xmode interactive
Xqueue stat
Xnolocal
END_OF_FILE
if test 144 -ne `wc -c <'SPSSX.reg'`; then
    echo shar: \"'SPSSX.reg'\" unpacked with wrong size!
fi
# end of 'SPSSX.reg'
fi
if test -f 'SPSSX2.check' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'SPSSX2.check'\"
else
echo shar: Extracting \"'SPSSX2.check'\" \(160 characters\)
sed "s/^X//" >'SPSSX2.check' <<'END_OF_FILE'
Xprogram SPSSX.check /usr/spss.old/SPSSX
Xhost burrhus
Xoption /usr/spss.old/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 180
Xmode interactive
Xqueue stat.check
Xnolocal
END_OF_FILE
if test 160 -ne `wc -c <'SPSSX2.check'`; then
    echo shar: \"'SPSSX2.check'\" unpacked with wrong size!
fi
# end of 'SPSSX2.check'
fi
if test -f 'SPSSX2.long' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'SPSSX2.long'\"
else
echo shar: Extracting \"'SPSSX2.long'\" \(160 characters\)
sed "s/^X//" >'SPSSX2.long' <<'END_OF_FILE'
Xprogram SPSSX.long /usr/spss.old/SPSSX
Xhost burrhus
Xoption /usr/spss.old/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 14400
Xmode interactive
Xqueue stat.long
Xnolocal
END_OF_FILE
if test 160 -ne `wc -c <'SPSSX2.long'`; then
    echo shar: \"'SPSSX2.long'\" unpacked with wrong size!
fi
# end of 'SPSSX2.long'
fi
if test -f 'SPSSX2.reg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'SPSSX2.reg'\"
else
echo shar: Extracting \"'SPSSX2.reg'\" \(153 characters\)
sed "s/^X//" >'SPSSX2.reg' <<'END_OF_FILE'
Xprogram SPSSX2.reg /usr/spss.old/SPSSX
Xhost burrhus
Xoption /usr/spss.old/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 900
Xmode interactive
Xqueue stat
Xnolocal
END_OF_FILE
if test 153 -ne `wc -c <'SPSSX2.reg'`; then
    echo shar: \"'SPSSX2.reg'\" unpacked with wrong size!
fi
# end of 'SPSSX2.reg'
fi
if test -f 'STUFF' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'STUFF'\"
else
echo shar: Extracting \"'STUFF'\" \(261 characters\)
sed "s/^X//" >'STUFF' <<'END_OF_FILE'
XFri Jun 16 12:40:12 EDT 1989
XFri Jun 16 12:40:13 EDT 1989
XFri Jun 16 12:40:13 EDT 1989
XFri Jun 16 12:40:13 EDT 1989
XFri Jun 16 12:40:14 EDT 1989
XFri Jun 16 12:40:14 EDT 1989
XFri Jun 16 12:40:15 EDT 1989
XFri Jun 16 12:40:15 EDT 1989
XFri Jun 16 12:40:15 EDT 1989
END_OF_FILE
if test 261 -ne `wc -c <'STUFF'`; then
    echo shar: \"'STUFF'\" unpacked with wrong size!
fi
# end of 'STUFF'
fi
if test -f 'bcc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bcc'\"
else
echo shar: Extracting \"'bcc'\" \(342 characters\)
sed "s/^X//" >'bcc' <<'END_OF_FILE'
Xprogram bcc /usr/local/bin/bcc
Xqueue compiler
Xoption -c copyout *.o
Xoption -g
Xoption -go
Xoption -v
Xoption -w
Xoption -p
Xoption -pg
Xoption -O
Xoption -R
Xoption -S copyout *.s
Xoption -E
Xoption -C
Xoption -o copyout ARG1
Xoption -D*
Xoption -U*
Xoption -I*
Xoption -B*
Xoption -t*
Xoption DEFAULT copyin ARG0
Xcopyout a.out
Xmaxrun 1
Xmagic
Xmode background
END_OF_FILE
if test 342 -ne `wc -c <'bcc'`; then
    echo shar: \"'bcc'\" unpacked with wrong size!
fi
# end of 'bcc'
fi
if test -f 'bcsh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bcsh'\"
else
echo shar: Extracting \"'bcsh'\" \(112 characters\)
sed "s/^X//" >'bcsh' <<'END_OF_FILE'
Xprogram bcsh /bin/csh
Xqueue defer
Xload 300 450
Xmaxrun 1
Xmaxcpu 1800
Xmode batch
Xefs
Xmagic
Xrestart
Xoption DEFAULT
END_OF_FILE
if test 112 -ne `wc -c <'bcsh'`; then
    echo shar: \"'bcsh'\" unpacked with wrong size!
fi
# end of 'bcsh'
fi
if test -f 'bcsh.long' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bcsh.long'\"
else
echo shar: Extracting \"'bcsh.long'\" \(134 characters\)
sed "s/^X//" >'bcsh.long' <<'END_OF_FILE'
Xprogram bcsh.long /bin/csh
Xqueue defer.long
Xload 200 350
Xminnice 10
Xmaxrun 1
Xmaxcpu 36000
Xmode batch
Xefs
Xmagic
Xrestart
Xoption DEFAULT
END_OF_FILE
if test 134 -ne `wc -c <'bcsh.long'`; then
    echo shar: \"'bcsh.long'\" unpacked with wrong size!
fi
# end of 'bcsh.long'
fi
if test -f 'bsh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bsh'\"
else
echo shar: Extracting \"'bsh'\" \(110 characters\)
sed "s/^X//" >'bsh' <<'END_OF_FILE'
Xprogram bsh /bin/sh
Xqueue defer
Xload 300 450
Xmaxrun 1
Xmaxcpu 1800
Xmode batch
Xefs
Xmagic
Xrestart
Xoption DEFAULT
END_OF_FILE
if test 110 -ne `wc -c <'bsh'`; then
    echo shar: \"'bsh'\" unpacked with wrong size!
fi
# end of 'bsh'
fi
if test -f 'bsh.long' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bsh.long'\"
else
echo shar: Extracting \"'bsh.long'\" \(132 characters\)
sed "s/^X//" >'bsh.long' <<'END_OF_FILE'
Xprogram bsh.long /bin/sh
Xqueue defer.long
Xload 200 350
Xminnice 10
Xmaxrun 1
Xmaxcpu 36000
Xmode batch
Xefs
Xmagic
Xrestart
Xoption DEFAULT
END_OF_FILE
if test 132 -ne `wc -c <'bsh.long'`; then
    echo shar: \"'bsh.long'\" unpacked with wrong size!
fi
# end of 'bsh.long'
fi
if test -f 'cat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cat'\"
else
echo shar: Extracting \"'cat'\" \(92 characters\)
sed "s/^X//" >'cat' <<'END_OF_FILE'
Xprogram cat /bin/cat
Xqueue test
Xoption DEFAULT copyin ARG0
Xmode interactive
Xqmaster harvisr
END_OF_FILE
if test 92 -ne `wc -c <'cat'`; then
    echo shar: \"'cat'\" unpacked with wrong size!
fi
# end of 'cat'
fi
if test -f 'cc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cc'\"
else
echo shar: Extracting \"'cc'\" \(325 characters\)
sed "s/^X//" >'cc' <<'END_OF_FILE'
Xprogram cc /bin/cc
Xqueue compiler
Xoption -c copyout *.o
Xoption -g
Xoption -go
Xoption -v
Xoption -w
Xoption -p
Xoption -pg
Xoption -O
Xoption -R
Xoption -S copyout *.s
Xoption -E
Xoption -C
Xoption -o copyout ARG1
Xoption -D*
Xoption -U*
Xoption -I*
Xoption -B*
Xoption -t*
Xoption DEFAULT copyin ARG0
Xcopyout a.out
Xmaxrun 1
Xmode interactive
END_OF_FILE
if test 325 -ne `wc -c <'cc'`; then
    echo shar: \"'cc'\" unpacked with wrong size!
fi
# end of 'cc'
fi
if test -f 'compiler' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compiler'\"
else
echo shar: Extracting \"'compiler'\" \(331 characters\)
sed "s/^X//" >'compiler' <<'END_OF_FILE'
Xprogram compiler /bin/cc
Xqueue compiler
Xoption -c copyout *.o
Xoption -g
Xoption -go
Xoption -v
Xoption -w
Xoption -p
Xoption -pg
Xoption -O
Xoption -R
Xoption -S copyout *.s
Xoption -E
Xoption -C
Xoption -o copyout ARG1
Xoption -D*
Xoption -U*
Xoption -I*
Xoption -B*
Xoption -t*
Xoption DEFAULT copyin ARG0
Xcopyout a.out
Xmaxrun 1
Xmode interactive
END_OF_FILE
if test 331 -ne `wc -c <'compiler'`; then
    echo shar: \"'compiler'\" unpacked with wrong size!
fi
# end of 'compiler'
fi
if test -f 'cspawn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cspawn.c'\"
else
echo shar: Extracting \"'cspawn.c'\" \(1448 characters\)
sed "s/^X//" >'cspawn.c' <<'END_OF_FILE'
X/* Copyright 1990  The President and Fellows of Harvard University
X
XPermission to use, copy, modify, and distribute this program for any
Xpurpose and without fee is hereby granted, provided that this
Xcopyright and permission notice appear on all copies and supporting
Xdocumentation, the name of Harvard University not be used in advertising
Xor publicity pertaining to distribution of the program, or to results
Xderived from its use, without specific prior written permission, and notice
Xbe given in supporting documentation that copying and distribution is by
Xpermission of Harvard University.  Harvard University makes no
Xrepresentations about the suitability of this software for any purpose.
XIt is provided "as is" without express or implied warranty.	*/
X
X/* cspawn.c - Dan Lanciani '85 */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <sys/time.h>
X#include <sys/resource.h>
X#include <stdio.h>
X
X#include "queue.h"
X
Xcspawn(prog, v)
Xregister char *prog, **v;
X{
X	register int pid;
X	struct stat statb;
X	struct rlimit rlimit;
X
X	if(stat(prog, &statb))
X		return(-1);
X	if(chmod(prog, statb.st_mode | 0111))
X		return(-1);
X	if((pid = vfork()) < 0)
X		return(-1);
X	if(!pid) {
X		if(maxcpu) {
X			rlimit.rlim_cur = rlimit.rlim_max = maxcpu;
X			setrlimit(RLIMIT_CPU, &rlimit);
X		}
X		if(minnice)
X			nice(minnice);
X		setuid(getuid());
X		if(!getpgrp(0))
X			setpgrp(0, getpid());
X		execv(prog, v);
X		exit(1);
X	}
X	chmod(prog, statb.st_mode);
X	return(pid);
X}
END_OF_FILE
if test 1448 -ne `wc -c <'cspawn.c'`; then
    echo shar: \"'cspawn.c'\" unpacked with wrong size!
fi
# end of 'cspawn.c'
fi
if test -f 'defer' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defer'\"
else
echo shar: Extracting \"'defer'\" \(112 characters\)
sed "s/^X//" >'defer' <<'END_OF_FILE'
Xprogram defer /bin/sh
Xqueue defer
Xload 300 450
Xmaxrun 1
Xmaxcpu 1800
Xmode batch
Xefs
Xmagic
Xrestart
Xoption DEFAULT
END_OF_FILE
if test 112 -ne `wc -c <'defer'`; then
    echo shar: \"'defer'\" unpacked with wrong size!
fi
# end of 'defer'
fi
if test -f 'defer.long' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defer.long'\"
else
echo shar: Extracting \"'defer.long'\" \(134 characters\)
sed "s/^X//" >'defer.long' <<'END_OF_FILE'
Xprogram defer.long /bin/sh
Xqueue defer.long
Xload 200 350
Xminnice 10
Xmaxrun 1
Xmaxcpu 36000
Xmode batch
Xefs
Xmagic
Xrestart
Xoption DEFAULT
END_OF_FILE
if test 134 -ne `wc -c <'defer.long'`; then
    echo shar: \"'defer.long'\" unpacked with wrong size!
fi
# end of 'defer.long'
fi
if test -f 'f77' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'f77'\"
else
echo shar: Extracting \"'f77'\" \(372 characters\)
sed "s/^X//" >'f77' <<'END_OF_FILE'
Xprogram f77 /usr/bin/f77
Xqueue compiler
Xoption -c copyout *.o
Xoption -g
Xoption -o copyout ARG1
Xoption -p
Xoption -pg
Xoption -w
Xoption -D*
Xoption -I*
Xoption -O
Xoption -S copyout *.s
Xoption -i2
Xoption -m
Xoption -onetrip
Xoption -u
Xoption -v
Xoption -C
Xoption -F
Xoption -E*
Xoption -R*
Xoption -N*
Xoption -U
Xoption DEFAULT copyin ARG0
Xcopyout a.out
Xmaxrun 1
Xmagic
Xmode background
END_OF_FILE
if test 372 -ne `wc -c <'f77'`; then
    echo shar: \"'f77'\" unpacked with wrong size!
fi
# end of 'f77'
fi
if test -f 'fort' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fort'\"
else
echo shar: Extracting \"'fort'\" \(385 characters\)
sed "s/^X//" >'fort' <<'END_OF_FILE'
Xprogram fort /usr/bin/fort
Xqueue compiler
Xhost harvisr
Xoption -c copyout *.o
Xoption -g
Xoption -o copyout ARG1
Xoption -p
Xoption -pg
Xoption -w
Xoption -D*
Xoption -I*
Xoption -O
Xoption -S copyout *.s
Xoption -i2
Xoption -m
Xoption -onetrip
Xoption -u
Xoption -v
Xoption -C
Xoption -F
Xoption -E*
Xoption -R*
Xoption -N*
Xoption -U
Xoption DEFAULT copyin ARG0
Xcopyout a.out
Xmaxrun 1
Xefs
Xmode background
END_OF_FILE
if test 385 -ne `wc -c <'fort'`; then
    echo shar: \"'fort'\" unpacked with wrong size!
fi
# end of 'fort'
fi
if test -f 'getload.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getload.c'\"
else
echo shar: Extracting \"'getload.c'\" \(1238 characters\)
sed "s/^X//" >'getload.c' <<'END_OF_FILE'
X/* Copyright 1990  The President and Fellows of Harvard University
X
XPermission to use, copy, modify, and distribute this program for any
Xpurpose and without fee is hereby granted, provided that this
Xcopyright and permission notice appear on all copies and supporting
Xdocumentation, the name of Harvard University not be used in advertising
Xor publicity pertaining to distribution of the program, or to results
Xderived from its use, without specific prior written permission, and notice
Xbe given in supporting documentation that copying and distribution is by
Xpermission of Harvard University.  Harvard University makes no
Xrepresentations about the suitability of this software for any purpose.
XIt is provided "as is" without express or implied warranty.	*/
X
X
X/* getload.c - Dan Lanciani '85 */
X
X#include <nlist.h>
X
Xstruct	nlist nl[] = {
X	{ "_avenrun" },
X#define	X_AVENRUN	0
X	{ "" },
X};
X
Xint	kmem = -1;
Xdouble	avenrun[3];
X
Xgetload()
X{
X	if(kmem < 0 && (kmem = open("/dev/kmem", 0)) < 0)
X		return(0);
X	if(!nl[0].n_type) {
X		nlist("/vmunix", nl);
X		if(!nl[0].n_type)
X			return(0);
X	}
X	lseek(kmem, (long)nl[X_AVENRUN].n_value, 0);
X	if(read(kmem, avenrun, sizeof(avenrun)) != sizeof(avenrun))
X		return(0);
X	return((int)(100.0 * avenrun[0]));
X}
END_OF_FILE
if test 1238 -ne `wc -c <'getload.c'`; then
    echo shar: \"'getload.c'\" unpacked with wrong size!
fi
# end of 'getload.c'
fi
if test -f 'getrload.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getrload.c'\"
else
echo shar: Extracting \"'getrload.c'\" \(1246 characters\)
sed "s/^X//" >'getrload.c' <<'END_OF_FILE'
X/* Copyright 1990  The President and Fellows of Harvard University
X
XPermission to use, copy, modify, and distribute this program for any
Xpurpose and without fee is hereby granted, provided that this
Xcopyright and permission notice appear on all copies and supporting
Xdocumentation, the name of Harvard University not be used in advertising
Xor publicity pertaining to distribution of the program, or to results
Xderived from its use, without specific prior written permission, and notice
Xbe given in supporting documentation that copying and distribution is by
Xpermission of Harvard University.  Harvard University makes no
Xrepresentations about the suitability of this software for any purpose.
XIt is provided "as is" without express or implied warranty.	*/
X
X
X/* getrload.c - Dan Lanciani '89 */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <protocols/rwhod.h>
X
Xgetrload(h)
Xchar *h;
X{
X	register int f;
X	char buf[200];
X	struct whod awhod;
X	struct stat statb;
X	time_t t, time();
X
X	sprintf(buf, "/usr/spool/rwho/whod.%s", h);
X	if((f = open(buf, 0)) < 0)
X		return(10000);
X	fstat(f, &statb);
X	time(&t);
X	if(t - statb.st_mtime > 5*60) {
X		close(f);
X		return(1000);
X	}
X	read(f, &awhod, sizeof(awhod));
X	close(f);
X	return(awhod.wd_loadav[0]);
X}
END_OF_FILE
if test 1246 -ne `wc -c <'getrload.c'`; then
    echo shar: \"'getrload.c'\" unpacked with wrong size!
fi
# end of 'getrload.c'
fi
if test -f 'getstr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getstr.c'\"
else
echo shar: Extracting \"'getstr.c'\" \(1112 characters\)
sed "s/^X//" >'getstr.c' <<'END_OF_FILE'
X/* Copyright 1990  The President and Fellows of Harvard University
X
XPermission to use, copy, modify, and distribute this program for any
Xpurpose and without fee is hereby granted, provided that this
Xcopyright and permission notice appear on all copies and supporting
Xdocumentation, the name of Harvard University not be used in advertising
Xor publicity pertaining to distribution of the program, or to results
Xderived from its use, without specific prior written permission, and notice
Xbe given in supporting documentation that copying and distribution is by
Xpermission of Harvard University.  Harvard University makes no
Xrepresentations about the suitability of this software for any purpose.
XIt is provided "as is" without express or implied warranty.	*/
X
X
X/* getstr.c - Dan Lanciani '85 */
X
X#include <stdio.h>
X
Xchar *
Xgetstr(n, buf)
Xchar *buf;
X{
X	register char *p = buf;
X
X	do
X		if(read(n, p, 1) != 1)
X			exit(1);
X	while(*p++);
X	return(buf);
X}
X
Xchar *
Xfgetstr(n, buf)
XFILE *n;
Xchar *buf;
X{
X	register int c;
X	register char *p = buf;
X
X	do
X		if((c = getc(n)) == EOF)
X			exit(1);
X	while(*p++ = c);
X	return(buf);
X}
END_OF_FILE
if test 1112 -ne `wc -c <'getstr.c'`; then
    echo shar: \"'getstr.c'\" unpacked with wrong size!
fi
# end of 'getstr.c'
fi
if test -f 'gistat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gistat'\"
else
echo shar: Extracting \"'gistat'\" \(243 characters\)
sed "s/^X//" >'gistat' <<'END_OF_FILE'
Xprogram gistat /usr/lib/queued/statjob
Xhost generali
Xoption -F ignore ARG1
Xoption -T ignore ARG1
Xoption -b ignore ARG1
Xoption -o ignore ARG1
Xoption -n
Xoption -B
Xoption -s
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 900
Xmode interactive
Xqueue gistat
END_OF_FILE
if test 243 -ne `wc -c <'gistat'`; then
    echo shar: \"'gistat'\" unpacked with wrong size!
fi
# end of 'gistat'
fi
if test -f 'gistat.check' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gistat.check'\"
else
echo shar: Extracting \"'gistat.check'\" \(256 characters\)
sed "s/^X//" >'gistat.check' <<'END_OF_FILE'
X
Xprogram gistat.check /usr/lib/queued/statjob
Xhost generali
Xoption -F ignore ARG1
Xoption -T ignore ARG1
Xoption -b ignore ARG1
Xoption -o ignore ARG1
Xoption -n
Xoption -B
Xoption -s
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 180
Xmode interactive
Xqueue gistat.check
END_OF_FILE
if test 256 -ne `wc -c <'gistat.check'`; then
    echo shar: \"'gistat.check'\" unpacked with wrong size!
fi
# end of 'gistat.check'
fi
if test -f 'gistat.long' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gistat.long'\"
else
echo shar: Extracting \"'gistat.long'\" \(255 characters\)
sed "s/^X//" >'gistat.long' <<'END_OF_FILE'
Xprogram gistat.long /usr/lib/queued/statjob
Xhost generali
Xoption -F ignore ARG1
Xoption -T ignore ARG1
Xoption -b ignore ARG1
Xoption -o ignore ARG1
Xoption -n
Xoption -B
Xoption -s
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 14400
Xmode interactive
Xqueue gistat.long
END_OF_FILE
if test 255 -ne `wc -c <'gistat.long'`; then
    echo shar: \"'gistat.long'\" unpacked with wrong size!
fi
# end of 'gistat.long'
fi
if test -f 'infile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'infile.c'\"
else
echo shar: Extracting \"'infile.c'\" \(1098 characters\)
sed "s/^X//" >'infile.c' <<'END_OF_FILE'
X/* Copyright 1990  The President and Fellows of Harvard University
X
XPermission to use, copy, modify, and distribute this program for any
Xpurpose and without fee is hereby granted, provided that this
Xcopyright and permission notice appear on all copies and supporting
Xdocumentation, the name of Harvard University not be used in advertising
Xor publicity pertaining to distribution of the program, or to results
Xderived from its use, without specific prior written permission, and notice
Xbe given in supporting documentation that copying and distribution is by
Xpermission of Harvard University.  Harvard University makes no
Xrepresentations about the suitability of this software for any purpose.
XIt is provided "as is" without express or implied warranty.	*/
X
X
X/* infile.c - Dan Lanciani '85 */
X
X#include <stdio.h>
X
Xinfile(file, name)
Xregister char *file, *name;
X{
X	char buf[BUFSIZ];
X	register FILE *n;
X
X	if(!(n = fopen(file, "r")))
X		return(0);
X	while(fgets(buf, sizeof(buf), n)) {
X		buf[strlen(buf)-1] = '\0';
X		if(!strcmp(buf, name)) {
X			fclose(n);
X			return(1);
X		}
X	}
X	fclose(n);
X	return(0);
X}
END_OF_FILE
if test 1098 -ne `wc -c <'infile.c'`; then
    echo shar: \"'infile.c'\" unpacked with wrong size!
fi
# end of 'infile.c'
fi
if test -f 'ipm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ipm'\"
else
echo shar: Extracting \"'ipm'\" \(277 characters\)
sed "s/^X//" >'ipm' <<'END_OF_FILE'
Xprogram ipm /usr/bmdp/exes/ipm
Xhost burrhus
Xoption -D ignore ARG1
Xoption -F ignore ARG1
Xoption -T ignore ARG1
Xoption -b ignore ARG1
Xoption -o ignore ARG1
Xoption -n
Xoption -B
Xoption /usr/bmdp/exes/*
Xoption DEFAULT copyin ARG0
Xefs
Xmaxrun 1
Xmaxcpu 900
Xmode interactive
Xqueue stat
END_OF_FILE
if test 277 -ne `wc -c <'ipm'`; then
    echo shar: \"'ipm'\" unpacked with wrong size!
fi
# end of 'ipm'
fi
if test -f 'lock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lock.c'\"
else
echo shar: Extracting \"'lock.c'\" \(1299 characters\)
sed "s/^X//" >'lock.c' <<'END_OF_FILE'
X/* Copyright 1990  The President and Fellows of Harvard University
X
XPermission to use, copy, modify, and distribute this program for any
Xpurpose and without fee is hereby granted, provided that this
Xcopyright and permission notice appear on all copies and supporting
Xdocumentation, the name of Harvard University not be used in advertising
Xor publicity pertaining to distribution of the program, or to results
Xderived from its use, without specific prior written permission, and notice
Xbe given in supporting documentation that copying and distribution is by
Xpermission of Harvard University.  Harvard University makes no
Xrepresentations about the suitability of this software for any purpose.
XIt is provided "as is" without express or implied warranty.	*/
X
X
X/* lock.c - Dan Lanciani '85 */
X
X#include <stdio.h>
X
X#include "queue.h"
X#include <signal.h>
X
Xstatic int ccnt = 0;
X
Xlock(p)
Xregister char *p;
X{
X	char lock[BUFSIZ];
X	register int i;
X
X	close(creat(LOCKNODE, 0644));
X	strcpy(lock, p);
X	strcat(lock, ".lock");
X	for(i = 0; i < 60; i++) {
X		if(!link(LOCKNODE, lock)) {
X			if(!ccnt++)
X				signal(SIGTERM, SIG_IGN);
X			return;
X		}
X		sleep(1);
X	}
X}
X
Xunlock(p)
Xregister char *p;
X{
X	char lock[BUFSIZ];
X
X	strcpy(lock, p);
X	strcat(lock, ".lock");
X	unlink(lock);
X	if(!--ccnt)
X		signal(SIGTERM, SIG_DFL);
X}
END_OF_FILE
if test 1299 -ne `wc -c <'lock.c'`; then
    echo shar: \"'lock.c'\" unpacked with wrong size!
fi
# end of 'lock.c'
fi
if test -f 'newstring.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newstring.c'\"
else
echo shar: Extracting \"'newstring.c'\" \(1071 characters\)
sed "s/^X//" >'newstring.c' <<'END_OF_FILE'
X/* Copyright 1990  The President and Fellows of Harvard University
X
XPermission to use, copy, modify, and distribute this program for any
Xpurpose and without fee is hereby granted, provided that this
Xcopyright and permission notice appear on all copies and supporting
Xdocumentation, the name of Harvard University not be used in advertising
Xor publicity pertaining to distribution of the program, or to results
Xderived from its use, without specific prior written permission, and notice
Xbe given in supporting documentation that copying and distribution is by
Xpermission of Harvard University.  Harvard University makes no
Xrepresentations about the suitability of this software for any purpose.
XIt is provided "as is" without express or implied warranty.	*/
X
X
X/* newstring.c - Dan Lanciani '85 */
X
Xchar *malloc();
X
Xchar *
Xxmalloc(size)
X{
X	register char *p;
X
X	if(p = malloc(size))
X		return(p);
X	write(2, "Out of memory\n", 14);
X	exit(1);
X	/*NOTREACHED*/
X}
X
Xchar *
Xnewstring(s)
Xregister char *s;
X{
X	register char *p;
X
X	p = xmalloc(strlen(s)+1);
X	strcpy(p, s);
X	return(p);
X}
END_OF_FILE
if test 1071 -ne `wc -c <'newstring.c'`; then
    echo shar: \"'newstring.c'\" unpacked with wrong size!
fi
# end of 'newstring.c'
fi
if test -f 'nroff' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nroff'\"
else
echo shar: Extracting \"'nroff'\" \(318 characters\)
sed "s/^X//" >'nroff' <<'END_OF_FILE'
Xprogram nroff /usr/bin/nroff
Xqueue wordproc
Xqmaster harvisr
Xhost /etc/cluster
Xoption -
Xoption -o*
Xoption -n*
Xoption -s*
Xoption -m*
Xoption -r*
Xoption -i
Xoption -q
Xoption -T*
Xoption -e
Xoption -h
Xoption -t
Xoption -f
Xoption -w
Xoption -b
Xoption -a
Xoption -p*
Xoption -F*
Xoption DEFAULT copyin ARG0
Xmaxrun 2
Xmode interactive
END_OF_FILE
if test 318 -ne `wc -c <'nroff'`; then
    echo shar: \"'nroff'\" unpacked with wrong size!
fi
# end of 'nroff'
fi
if test -f 'optcmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'optcmp.c'\"
else
echo shar: Extracting \"'optcmp.c'\" \(982 characters\)
sed "s/^X//" >'optcmp.c' <<'END_OF_FILE'
X/* Copyright 1990  The President and Fellows of Harvard University
X
XPermission to use, copy, modify, and distribute this program for any
Xpurpose and without fee is hereby granted, provided that this
Xcopyright and permission notice appear on all copies and supporting
Xdocumentation, the name of Harvard University not be used in advertising
Xor publicity pertaining to distribution of the program, or to results
Xderived from its use, without specific prior written permission, and notice
Xbe given in supporting documentation that copying and distribution is by
Xpermission of Harvard University.  Harvard University makes no
Xrepresentations about the suitability of this software for any purpose.
XIt is provided "as is" without express or implied warranty.	*/
X
X
X/* optcmp.c - Dan Lanciani '85 */
X
X#include <stdio.h>
X
Xoptcmp(pat, str)
Xregister char *pat, *str;
X{
X	register int i;
X
X	if(pat[i = strlen(pat)-1] == '*')
X		return(!strncmp(pat, str, i));
X	else
X		return(!strcmp(pat, str));
X}
END_OF_FILE
if test 982 -ne `wc -c <'optcmp.c'`; then
    echo shar: \"'optcmp.c'\" unpacked with wrong size!
fi
# end of 'optcmp.c'
fi
if test -f 'otroff' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'otroff'\"
else
echo shar: Extracting \"'otroff'\" \(302 characters\)
sed "s/^X//" >'otroff' <<'END_OF_FILE'
Xprogram otroff /usr/bin/otroff
Xqueue wordproc
Xqmaster harvisr
Xoption -
Xoption -o*
Xoption -n*
Xoption -s*
Xoption -m*
Xoption -r*
Xoption -i
Xoption -q
Xoption -T*
Xoption -e
Xoption -h
Xoption -t
Xoption -f
Xoption -w
Xoption -b
Xoption -a
Xoption -p*
Xoption -F*
Xoption DEFAULT copyin ARG0
Xmaxrun 2
Xmode interactive
END_OF_FILE
if test 302 -ne `wc -c <'otroff'`; then
    echo shar: \"'otroff'\" unpacked with wrong size!
fi
# end of 'otroff'
fi
if test -f 'qrm.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'qrm.1'\"
else
echo shar: Extracting \"'qrm.1'\" \(1230 characters\)
sed "s/^X//" >'qrm.1' <<'END_OF_FILE'
X.TH QRM 1 "11 September 1985"
X.UC 4
X.SH NAME
Xqrm  \- remove local and remote queue entries
X.SH SYNOPSIS
X.B qrm
Xprogram pid|user|all
X.PP
X.SH DESCRIPTION
X.I Qrm
Xremoves an entry from a system execution queue, killing the running
Xprocess if necessary.  The pid of a job may be obtained from the qs(1)
Xcommand.  If a user is specified, all jobs owned by that user will
Xbe removed from the queue.  If the reserved user ``all'' is specified,
Xall jobs will be removed from the queue.
XOnly the owner of the job or the super-user may remove a job.
X.SH "FILES (/usr/lib/queued/)"
XQUEUES		list of active, local queues
X.br
X``program''	configuration file for ``program''
X.SH "FILES (/usr/spool/queued/)"
XLOCK			master lock node
X.br
X``queue''		current information for ``queue''
X.br
X``queue''.lock	lock on ``queue''
X.br
X``queue''.tmp	used for rewriting ``queue''
X.br
X``pid''		current information for ``pid''
X.br
X``pid''.dir	temporary execution directory
X.br
X``pid''.batch	output of batch execution process
X.SH "FILES (Other)"
X/usr/adm/qacct	queue accounting file
X.br
X/etc/hosts.efs	hosts with extended file system
X.br
X/etc/hosts.flat	hosts with one-to-one uid mapping
X.SH "SEE ALSO"
Xqs(1), queue(1), queued(5), queued(8)
X.SH AUTHOR
XDan Lanciani
END_OF_FILE
if test 1230 -ne `wc -c <'qrm.1'`; then
    echo shar: \"'qrm.1'\" unpacked with wrong size!
fi
# end of 'qrm.1'
fi
if test -f 'qs.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'qs.1'\"
else
echo shar: Extracting \"'qs.1'\" \(1385 characters\)
sed "s/^X//" >'qs.1' <<'END_OF_FILE'
X.TH QS 1 "11 September 1985"
X.UC 4
X.SH NAME
Xqs  \- display the status of system execution queues
X.SH SYNOPSIS
X.B qs
X[
X.B program
X]
X.PP
X.SH DESCRIPTION
X.I Qs
Xdisplays useful information about running and waiting processes in the
Xsystem execution queues.  With no arguments, 
X.I qs
Xreports on all queues active on the local host.  If the single argument
X.B program
Xis supplied, 
X.I qs
Xlocates and displays the queue associated with
X.B program
Xon any host.
X.PP
XFor each job in a queue, 
X.I qs
Xprints the control pid (as used by qrm(1)), the current state of the
Xprocess, the user who owns the entry, and the command itself.  The
Xdisplay is headed by the queue with which the jobs are associated.
X.SH "FILES (/usr/lib/queued/)"
XQUEUES		list of active, local queues
X.br
X``program''	configuration file for ``program''
X.SH "FILES (/usr/spool/queued/)"
XLOCK			master lock node
X.br
X``queue''		current information for ``queue''
X.br
X``queue''.lock	lock on ``queue''
X.br
X``queue''.tmp	used for rewriting ``queue''
X.br
X``pid''		current information for ``pid''
X.br
X``pid''.dir	temporary execution directory
X.br
X``pid''.batch	output of batch execution process
X.SH "FILES (Other)"
X/usr/adm/qacct	queue accounting file
X.br
X/etc/hosts.efs	hosts with extended file system
X.br
X/etc/hosts.flat	hosts with one-to-one uid mapping
X.SH "SEE ALSO"
Xqrm(1), queue(1), queued(5), queued(8)
X.SH AUTHOR
XDan Lanciani
END_OF_FILE
if test 1385 -ne `wc -c <'qs.1'`; then
    echo shar: \"'qs.1'\" unpacked with wrong size!
fi
# end of 'qs.1'
fi
if test -f 'qs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'qs.c'\"
else
echo shar: Extracting \"'qs.c'\" \(2372 characters\)
sed "s/^X//" >'qs.c' <<'END_OF_FILE'
X/* Copyright 1990  The President and Fellows of Harvard University
X
XPermission to use, copy, modify, and distribute this program for any
Xpurpose and without fee is hereby granted, provided that this
Xcopyright and permission notice appear on all copies and supporting
Xdocumentation, the name of Harvard University not be used in advertising
Xor publicity pertaining to distribution of the program, or to results
Xderived from its use, without specific prior written permission, and notice
Xbe given in supporting documentation that copying and distribution is by
Xpermission of Harvard University.  Harvard University makes no
Xrepresentations about the suitability of this software for any purpose.
XIt is provided "as is" without express or implied warranty.	*/
X
X
X/* qs.c - Dan Lanciani '85 */
X
X#include <stdio.h>
X#include <errno.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <netdb.h>
X
X#include "queue.h"
X
Xextern int errno;
Xstruct servent *sp;
X
Xmain(argc, argv)
Xchar **argv;
X{
X	register int i, error = 0;
X
X	if(argc < 1 || argc > 2) {
X		fprintf(stderr, "Usage: %s [program]\n", argv[0]);
X		exit(1);
X	}
X	if(!(sp = getservbyname("queue", "tcp"))) {
X		fprintf(stderr, "queue: Bad service?!?\n");
X		exit(1);
X	}
X	if(argc == 2) {
X		if(readconf(argv[1])) {
X			fprintf(stderr, "Unknown configuration\n");
X			exit(1);
X		}
X		if(*qm) {
X			if((sp = getservbyname("qmaster", "tcp"))
X				&& !show(qm, queue))
X				exit(0);
X			sp = getservbyname("queue", "tcp");
X		}
X	}
X	else {
X		gethostname(host, sizeof(host));
X		show(host, "");
X		exit(0);
X	}
X	for(i = 0; i < hcnt; i++)
X		error |= show(hosts[i], queue);
X	if(error) {
X		gethostname(host, sizeof(host));
X		show(host, queue);
X	}
X}
X
Xshow(h, p)
Xchar *h, *p;
X{
X	struct sockaddr_in sin;
X	register struct hostent *hp;
X	int s, trys, i;
X
X	if(!(hp = gethostbyname(h))) {
X		fprintf(stderr, "%s: Unknown host?!?\n", h);
X		return(1);
X	}
X	trys = 0;
X	i = IPPORT_RESERVED - 1;
Xretry:
X	if((s = rresvport(&i)) < 0) {
X		perror("rresvport");
X		return(1);
X	}
X	sin.sin_family = hp->h_addrtype;
X	sin.sin_port = sp->s_port;
X	bcopy(hp->h_addr, &sin.sin_addr, hp->h_length);
X	if(connect(s, &sin, sizeof(sin))) {
X		close(s);
X		if(trys++ < 5) {
X			sleep(trys);
X			i--;
X			goto retry;
X		}
X		perror("connect");
X		return(1);
X	}
X	write(s, "\1", 1);
X	write(s, p, strlen(p)+1);
X	mode = QM_BACKGROUND;
X	com(s, -1);
X	close(s);
X	return(0);
X}
END_OF_FILE
if test 2372 -ne `wc -c <'qs.c'`; then
    echo shar: \"'qs.c'\" unpacked with wrong size!
fi
# end of 'qs.c'
fi
if test -f 'queue.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'queue.h'\"
else
echo shar: Extracting \"'queue.h'\" \(1251 characters\)
sed "s/^X//" >'queue.h' <<'END_OF_FILE'
X/* queue.h - Dan Lanciani '85 '89 */
X
X#define LIBDIR "/usr/lib/queued"
X#define QUEUES "/usr/lib/queued/QUEUES"
X
X#define SPOOLDIR "/usr/spool/queued"
X#define LOCKNODE "/usr/spool/queued/LOCK"
X#define UNID "/usr/spool/queued/UNID"
X
X#define QACCT "/usr/adm/qacct"
X
X#define FLATFILE "/etc/hosts.flat"
X#define EFSFILE "/etc/hosts.efs"
X#define EQUIVFILE "/etc/hosts.equiv"
X
X#define QUEUEGROUP "queued"
X
X#define NOBODY -2
X#define XGROUPS 32
X#define MAXUQ 4
X#define MAXHCNT 50
X
Xstruct optent {
X	struct optent *op_next;
X	char *op_name;
X	int op_action;
X	char *op_arg;
X};
X
X#define OPA_IGNORE 0
X#define OPA_COPYIN 1
X#define OPA_COPYOUT 2
X
X#define QM_BATCH 0
X#define QM_BACKGROUND 1
X#define QM_INTERACTIVE 2
X
Xextern char prog[BUFSIZ], host[BUFSIZ], qm[BUFSIZ], queue[BUFSIZ], *hosts[];
Xextern int maxcpu, minnice, maxrun, maxload, minload, mode, priv, efs, restart;
Xextern int hcnt, maxtime, nolocal, maxperu;
Xextern struct optent *copyin;
Xextern struct optent *copyout;
Xextern struct optent *option;
X
X#define malloc xmalloc
X#define FIRSTUNID (256L * 65536L)
X#define LASTUNID (32767L * 65536L)
X#define isunid(p) ((p) >= FIRSTUNID && (p) <= LASTUNID)
X
Xchar *getenv();
Xchar *malloc(), *index(), *rindex();
Xchar *newstring();
Xchar *getstr(), *fgetstr();
Xlong atol();
END_OF_FILE
if test 1251 -ne `wc -c <'queue.h'`; then
    echo shar: \"'queue.h'\" unpacked with wrong size!
fi
# end of 'queue.h'
fi
if test -f 'queued.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'queued.8'\"
else
echo shar: Extracting \"'queued.8'\" \(1790 characters\)
sed "s/^X//" >'queued.8' <<'END_OF_FILE'
X.TH QUEUED 8 "19 January 1986"
X.UC 4
X.SH NAME
Xqueued  \- transparently execute remote and local queue processes
X.SH SYNOPSIS
X/etc/queued
X.PP
X.SH DESCRIPTION
X.I Queued
Xaccepts virtual connections from
X.B queue
Xand creates a server process to run a remote or local job.  When the
Xjob eventually finishes,
X.B queued
Xcleans up any files and awakens any other servers waiting for access
Xto the queue.  For these reasons,
X.B queued
Xmust not be invoked by the inet daemon.  Information necessary to run
Xprocesses is found in the queue configuration file.
X.PP
XIf the file /usr/adm/qacct exists and is writable by the
X.B queued
Xprocess, an accounting record will be written for every program run
Xon the local machine.  An accounting record consists of a single line
Xwith tab\-separated fields.  The fields are the user and system cpu time,
Xthe program run, and the user/group/host identification of the person
Xwho requested that the program be run.
X.PP
X.B Queued
Xalso accepts requests to display the current queues and to
Xremove entries from a queue.  These functions are used by qs(1) and
Xqrm(1) respectively.
X.SH "FILES (/usr/lib/queued/)"
XQUEUES		list of active, local queues
X.br
X``program''	configuration file for ``program''
X.SH "FILES (/usr/spool/queued/)"
XLOCK			master lock node
X.br
X``queue''		current information for ``queue''
X.br
X``queue''.lock	lock on ``queue''
X.br
X``queue''.tmp	used for rewriting ``queue''
X.br
X``pid''		current information for ``pid''
X.br
X``pid''.dir	temporary execution directory
X.br
X``pid''.batch	output of batch execution process
X.SH "FILES (Other)"
X/usr/adm/qacct	queue accounting file
X.br
X/etc/hosts.efs	hosts with extended file system
X.br
X/etc/hosts.flat	hosts with one-to-one uid mapping
X.SH "SEE ALSO"
Xqrm(1), qs(1), queue(1), queued(5)
X.SH AUTHOR
XDan Lanciani
END_OF_FILE
if test 1790 -ne `wc -c <'queued.8'`; then
    echo shar: \"'queued.8'\" unpacked with wrong size!
fi
# end of 'queued.8'
fi
if test -f 'spell' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spell'\"
else
echo shar: Extracting \"'spell'\" \(233 characters\)
sed "s/^X//" >'spell' <<'END_OF_FILE'
Xprogram spell /usr/bin/spell
Xqueue wordproc
Xqmaster harvisr
Xhost /etc/cluster
Xoption -v
Xoption -b
Xoption -x
Xoption -d ignore ARG1
Xoption -s ignore ARG1
Xoption -h ignore ARG1
Xoption DEFAULT copyin ARG0
Xmaxrun 2
Xmagic
Xmode interactive
END_OF_FILE
if test 233 -ne `wc -c <'spell'`; then
    echo shar: \"'spell'\" unpacked with wrong size!
fi
# end of 'spell'
fi
if test -f 'stat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stat'\"
else
echo shar: Extracting \"'stat'\" \(238 characters\)
sed "s/^X//" >'stat' <<'END_OF_FILE'
Xprogram stat /usr/lib/queued/statjob
Xhost burrhus
Xoption -F ignore ARG1
Xoption -T ignore ARG1
Xoption -b ignore ARG1
Xoption -o ignore ARG1
Xoption -n
Xoption -B
Xoption -s
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 900
Xmode interactive
Xqueue stat
END_OF_FILE
if test 238 -ne `wc -c <'stat'`; then
    echo shar: \"'stat'\" unpacked with wrong size!
fi
# end of 'stat'
fi
if test -f 'stat.check' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stat.check'\"
else
echo shar: Extracting \"'stat.check'\" \(264 characters\)
sed "s/^X//" >'stat.check' <<'END_OF_FILE'
Xprogram stat.check /usr/lib/queued/statjob
Xhost burrhus
Xhost generali
Xoption -F ignore ARG1
Xoption -T ignore ARG1
Xoption -b ignore ARG1
Xoption -o ignore ARG1
Xoption -n
Xoption -B
Xoption -s
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 180
Xmode interactive
Xqueue stat.check
END_OF_FILE
if test 264 -ne `wc -c <'stat.check'`; then
    echo shar: \"'stat.check'\" unpacked with wrong size!
fi
# end of 'stat.check'
fi
if test -f 'stat.long' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stat.long'\"
else
echo shar: Extracting \"'stat.long'\" \(250 characters\)
sed "s/^X//" >'stat.long' <<'END_OF_FILE'
Xprogram stat.long /usr/lib/queued/statjob
Xhost burrhus
Xoption -F ignore ARG1
Xoption -T ignore ARG1
Xoption -b ignore ARG1
Xoption -o ignore ARG1
Xoption -n
Xoption -B
Xoption -s
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 14400
Xmode interactive
Xqueue stat.long
END_OF_FILE
if test 250 -ne `wc -c <'stat.long'`; then
    echo shar: \"'stat.long'\" unpacked with wrong size!
fi
# end of 'stat.long'
fi
if test -f 'test' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test'\"
else
echo shar: Extracting \"'test'\" \(114 characters\)
sed "s/^X//" >'test' <<'END_OF_FILE'
Xprogram test /usr/lib/queued/loop
Xqueue test
Xoption DEFAULT copyin ARG0
Xmode interactive
Xqmaster harvisr
Xmaxcpu 1
END_OF_FILE
if test 114 -ne `wc -c <'test'`; then
    echo shar: \"'test'\" unpacked with wrong size!
fi
# end of 'test'
fi
if test -f 'titroff' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'titroff'\"
else
echo shar: Extracting \"'titroff'\" \(329 characters\)
sed "s/^X//" >'titroff' <<'END_OF_FILE'
Xprogram titroff /usr/vendor/bin/titroff
Xqueue wordproc
Xqmaster harvisr
Xhost /etc/cluster
Xoption -
Xoption -o*
Xoption -n*
Xoption -s*
Xoption -m*
Xoption -r*
Xoption -i
Xoption -q
Xoption -T*
Xoption -e
Xoption -h
Xoption -t
Xoption -f
Xoption -w
Xoption -b
Xoption -a
Xoption -p*
Xoption -F*
Xoption DEFAULT copyin ARG0
Xmaxrun 2
Xmode interactive
END_OF_FILE
if test 329 -ne `wc -c <'titroff'`; then
    echo shar: \"'titroff'\" unpacked with wrong size!
fi
# end of 'titroff'
fi
if test -f 'tp.troff' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tp.troff'\"
else
echo shar: Extracting \"'tp.troff'\" \(331 characters\)
sed "s/^X//" >'tp.troff' <<'END_OF_FILE'
Xprogram tp.troff /usr/vendor/bin/tp.troff
Xqueue wordproc
Xqmaster harvisr
Xhost /etc/cluster
Xoption -
Xoption -o*
Xoption -n*
Xoption -s*
Xoption -m*
Xoption -r*
Xoption -i
Xoption -q
Xoption -T*
Xoption -e
Xoption -h
Xoption -t
Xoption -f
Xoption -w
Xoption -b
Xoption -a
Xoption -p*
Xoption -F*
Xoption DEFAULT copyin ARG0
Xmaxrun 2
Xmode interactive
END_OF_FILE
if test 331 -ne `wc -c <'tp.troff'`; then
    echo shar: \"'tp.troff'\" unpacked with wrong size!
fi
# end of 'tp.troff'
fi
if test -f 'usr.lib.queued.shar' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'usr.lib.queued.shar'\"
else
echo shar: Extracting \"'usr.lib.queued.shar'\" \(1078 characters\)
sed "s/^X//" >'usr.lib.queued.shar' <<'END_OF_FILE'
X#! /bin/sh
X# This is a shell archive, meaning:
X# 1. Remove everything above the #! /bin/sh line.
X# 2. Save the resulting text in a file.
X# 3. Execute the file with /bin/sh (not csh) to create the files:
X#	BGLIM.long
X#	BGLIM.reg
X#	BIMED
X#	BIMED.check
X#	BIMED.long
X#	BLIMDEP
X#	BLIMDEP.long
X#	DONEMSG
X#	GGLIM.long
X#	GGLIM.reg
X#	GLIMDEP
X#	GLIMDEP.long
X#	GSPSSX.check
X#	GSPSSX.long
X#	GSPSSX.reg
X#	QUEUES
X#	SPSSX.check
X#	SPSSX.long
X#	SPSSX.psy1995
X#	SPSSX.reg
X#	SPSSX2.check
X#	SPSSX2.long
X#	SPSSX2.reg
X#	STUFF
X#	bcc
X#	bcsh
X#	bcsh.long
X#	bsh
X#	bsh.long
X#	cat
X#	cc
X#	compiler
X#	defer
X#	defer.long
X#	f77
X#	fort
X#	gistat
X#	gistat.check
X#	gistat.long
X#	ipm
X#	nroff
X#	otroff
X#	spell
X#	stat
X#	stat.check
X#	stat.long
X#	test
X#	titroff
X#	tp.troff
X#	wordproc
X# This archive created: Fri Mar  2 00:30:40 1990
Xexport PATH; PATH=/bin:$PATH
Xif test -f 'BGLIM.long'
Xthen
X	echo shar: will not over-write existing file "'BGLIM.long'"
Xelse
Xcat << \SHAR_EOF > 'BGLIM.long'
Xprogram BGLIM.long /usr/vendor/bin/BGLIM
Xhost burrhus
Xoption DEFAULT copyin ARG0
Xefs
Xmaxcpu 14400
Xmode interactive
Xqueue stat.long
END_OF_FILE
if test 1078 -ne `wc -c <'usr.lib.queued.shar'`; then
    echo shar: \"'usr.lib.queued.shar'\" unpacked with wrong size!
fi
# end of 'usr.lib.queued.shar'
fi
if test -f 'wordproc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wordproc'\"
else
echo shar: Extracting \"'wordproc'\" \(236 characters\)
sed "s/^X//" >'wordproc' <<'END_OF_FILE'
Xprogram wordproc /usr/bin/spell
Xqueue wordproc
Xqmaster harvisr
Xhost /etc/cluster
Xoption -v
Xoption -b
Xoption -x
Xoption -d ignore ARG1
Xoption -s ignore ARG1
Xoption -h ignore ARG1
Xoption DEFAULT copyin ARG0
Xmaxrun 2
Xmagic
Xmode interactive
END_OF_FILE
if test 236 -ne `wc -c <'wordproc'`; then
    echo shar: \"'wordproc'\" unpacked with wrong size!
fi
# end of 'wordproc'
fi
if test -f 'xfputs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xfputs.c'\"
else
echo shar: Extracting \"'xfputs.c'\" \(888 characters\)
sed "s/^X//" >'xfputs.c' <<'END_OF_FILE'
X/* Copyright 1990  The President and Fellows of Harvard University
X
XPermission to use, copy, modify, and distribute this program for any
Xpurpose and without fee is hereby granted, provided that this
Xcopyright and permission notice appear on all copies and supporting
Xdocumentation, the name of Harvard University not be used in advertising
Xor publicity pertaining to distribution of the program, or to results
Xderived from its use, without specific prior written permission, and notice
Xbe given in supporting documentation that copying and distribution is by
Xpermission of Harvard University.  Harvard University makes no
Xrepresentations about the suitability of this software for any purpose.
XIt is provided "as is" without express or implied warranty.	*/
X
X
X/* xfputs.c - Dan Lanciani '85 */
X
X#include <stdio.h>
X
Xxfputs(p, n)
Xchar *p;
Xregister FILE *n;
X{
X	fputs(p, n);
X	putc('\0', n);
X}
END_OF_FILE
if test 888 -ne `wc -c <'xfputs.c'`; then
    echo shar: \"'xfputs.c'\" unpacked with wrong size!
fi
# end of 'xfputs.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
exit 0 # Just in case...
