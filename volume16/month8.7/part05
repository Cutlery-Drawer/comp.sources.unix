Subject:  v16i058:  A visual calendar and appointment system, Part05/06
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Michael Morrell <hplabs!hpda!morrell>
Posting-number: Volume 16, Issue 58
Archive-name: month8.7/part05

# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# This archive contains:
#	monthd.c	xmonthd.c	chmonth.c	
LANG=""; export LANG

echo x - monthd.c
cat >monthd.c <<'@EOF'
#ifndef lint
static char rcsid[] = "$Header: monthd.c,v 8.5 88/04/04 11:09:01 hull Exp $";
#endif

#include <stdio.h>
#include <signal.h>
#include <sys/types.h>
#include <ctype.h>
#include "month.h"

short dhour, dminute, dsecond;
short days;
short my_file = 1;
short month_start;
unsigned short file_owner;
char *month_dir = NULL;
char *prog_name;
int dint = 15 * 60;	/* default wake-up interval is 15 minutes */
int user_id;
int parent_pid;
int fd;
FILE *tty;
struct date_rec current_date, todays_date;
struct event_rec events = {{0, 0, 0}, 0, 0, 0, {0, 0, 0, 0, 0, 0, 0},
0, 0, 0, {0, 0}, {0, 0}, {0, 0}, {0, 0}, 0, 0, 0, 0, 0, {0, 0, 0}, 0};

extern char *get_home_dir();
extern alarm_t alarm();
extern unsigned short getuid();

main(argc, argv)
int argc;
char *argv[];
{
	int sig_terminate();

	prog_name = argv[0];
	user_id = (int) getuid();
	parent_pid = getppid();
	tty = fopen("/dev/tty", "w");
	/*
	fprintf(tty, "%s: pid = %d\n", prog_name, getpid());
	fprintf(tty, "%s: parent_pid = %d\n", prog_name, parent_pid);
	fprintf(tty, "%s: pgrp = %d\n", prog_name, getpgrp());
	*/
	month_dir = get_home_dir(user_id);
	check_args(argc, argv);
	close(0); close(1); close(2);	/* close stdin, stdout, stderr */
	if (fork() == 0) {
	    signal(SIGHUP, sig_terminate);	/* child process */
	    signal(SIGTERM, sig_terminate);
	    signal(SIGINT, SIG_IGN);
	    signal(SIGQUIT, SIG_IGN);
#ifdef SIGTSTP
	    signal(SIGTSTP, SIG_IGN);
	    signal(SIGTTIN, SIG_IGN);
	    signal(SIGTTOU, SIG_IGN);
#endif
	    /*
	    fprintf(tty, "%s: child pid = %d\n", prog_name, getpid());
	    fprintf(tty, "%s: child pgrp before setpgrp2 = %d\n",
		prog_name, getpgrp());
	    */
#ifdef SIGTSTP
#ifdef hpux
	    setpgrp2(0, parent_pid);
#else
	    setpgrp(0, parent_pid);
#endif
#endif
	    inf_loop();
	}

	/*
	fprintf(tty, "%s: parent exiting\n", prog_name);
	*/
	exit(0);
	/* NOTREACHED */
}

check_args(argc, argv)
int argc;
char *argv[];
{
	int err_flag = 0, c;
	extern char *optarg;
	extern int optind;

	while ((c = getopt(argc, argv, "i:")) != EOF) {
	    switch (c) {
	    case 'i':
		if (isdigit(optarg[0]) && (optarg[0] > '0'))
			dint = atoi(optarg) * 60;
		else {
		    fprintf(stderr, "%s: invalid number -- %s\n",
			prog_name, optarg);
		    err_flag++;
		}
		break;
	    case '?':
	        err_flag++;
		break;
	    }
	}

	if (err_flag) {
	    fprintf(stderr, "Usage: %s [-in]\n", prog_name);
	    exit(1);
	}
}

inf_loop()
{
	int stat, do_nothing();
	struct event_rec *eptr;
	short minutes, eminutes, wminutes, diff;
	alarm_t seconds;

	for (;;) {
	    signal(SIGALRM, do_nothing);
	    if (get_todays_date() != 0) {
		fprintf(tty, "%s: Cannot get today's date\n", prog_name);
		exit(1);
	    }
	    seconds = dint - ((60 * dminute + dsecond) % dint);
	    if (seconds < 60)
		seconds += dint;
	    alarm(seconds);
	    minutes = (60 * dhour) + dminute;
	    current_date.month = todays_date.month;
	    current_date.day = todays_date.day;
	    current_date.year = todays_date.year;
	    month_start = get_month_start(current_date.month,
		current_date.year);
	    days = days_in(current_date.month, current_date.year);
	    if (stat = read_schedule(month_dir, READ_ONLY))
		terminate(stat);

	    eptr = events.next_event;

	    while (eptr) {
		if (event_today(eptr)) {
		    eminutes = (((short)60) * eptr->start_time.hour) +
			eptr->start_time.minute;
		    wminutes = (((short)60) * eptr->warning.hour)
			+ eptr->warning.minute;
		    diff = eminutes - minutes;
		    if ((diff >= 0) && (diff <= wminutes))
			print_reminder(eptr->event_string, diff);
		}
		eptr = eptr->next_event;
	    }
	    pause();
	    if (logged_out())
		terminate(0);
	}
}

sig_terminate(sig)
int sig;
{
	signal(SIGHUP, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	alarm((alarm_t) 0);

	/*
	fprintf(tty, "%s: terminate(%d)\n", prog_name, sig);
	*/
	exit(sig);
	/* NOTREACHED */
}

terminate(code)
int code;
{
	signal(SIGHUP, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	alarm((alarm_t) 0);

	if (code < 0)
	    fprintf(tty, "%s: cannot open .month\n", prog_name);
	else if (code > 0)
	    fprintf(tty, "%s: cannot read .month version %d\n",
		prog_name, code);
	exit(code);
	/* NOTREACHED */
}

print_reminder(str, minutes)
char *str;
int minutes;
{
	int hours;

	hours = minutes / 60;
	minutes = minutes % 60;
	fprintf(tty, "\r\n%s   \r\n", str);

	if ((hours == 0) && (minutes == 0))
	    fprintf(tty, "Right now");
	else {
	    fprintf(tty, "In");
	    if (hours > 1)
		fprintf(tty, " %d hours", hours);
	    else if (hours == 1)
		fprintf(tty, " 1 hour");

	    if (minutes > 1)
		fprintf(tty, " %d minutes", minutes);
	    else if (minutes == 1)
		fprintf(tty, " 1 minute");
	}

	fprintf(tty, ".   \r\n\007");
}

logged_out()
{
	/*
	fprintf(tty, "%s: child pgrp = %d\n", prog_name, getpgrp());
	*/
#if SYS5
	return(getpgrp() == 0);	/* pgrp is 0 after logout */
#else
	return(getpgrp(0) == 0);/* pgrp is 0 after logout */
#endif
}

do_nothing()
{
}
@EOF

chmod 644 monthd.c

echo x - xmonthd.c
cat >xmonthd.c <<'@EOF'
#ifndef lint
static char rcsid[] = "$Header: xmonthd.c,v 1.4 88/04/04 11:11:18 hull Exp $";
#endif

#include <stdio.h>
#include <signal.h>
#if SYS5
#include <time.h>
#else
#include <sys/time.h>
#endif
#include <sys/types.h>
#include <X/Xlib.h>
#include "month.h"

#ifndef DEF_BORDER
#define DEF_BORDER	2
#endif
#ifndef DEF_INTBORDER
#define DEF_INTBORDER	2
#endif
#ifndef DEF_FONT
#define DEF_FONT	"vtsingle"
#endif
#ifndef DEF_DELAY
#define DEF_DELAY	5
#endif
#ifndef NUM_FLASH
#define NUM_FLASH	10
#endif

#define MAX_EVENT_TIME_LENGTH	24
#define MAX(a, b)	((a) > (b) ? (a) : (b))

struct remind_rec {
	char event_string[MAX_EVENT_STRING_LENGTH];
	char time_string[MAX_EVENT_TIME_LENGTH];
	int time;
	struct remind_rec *next;
};

short dhour, dminute, dsecond;
short days;
short my_file = 1;
short month_start;
unsigned short file_owner;
char *month_dir = NULL;
char *prog_name;
char *geom = NULL;
char *display = NULL;
char *Base_font = DEF_FONT;
char *Fore_color;
char *Back_color;
char *Brdr_color;
int reverse = 0;
int num_flash = NUM_FLASH;
FontInfo *base_font;
int border = DEF_BORDER;
int int_border = DEF_INTBORDER;
int delay = DEF_DELAY;
int fore_color;
int back_color;
int brdr_color;
int width;
int height;
int xneg;
int yneg;
Window win;
int have_new;
int dint = 15 * 60;	/* default wake-up interval is 15 minutes */
int user_id;
int fd;
struct remind_rec *remind_list = 0;
struct date_rec current_date, todays_date;
struct event_rec events = {{0, 0, 0}, 0, 0, 0, {0, 0, 0, 0, 0, 0, 0},
0, 0, 0, {0, 0}, {0, 0}, {0, 0}, {0, 0}, 0, 0, 0, 0, 0, {0, 0, 0}, 0};

#if !SYS5
#define strchr index
#endif
extern char *strcat(), *strcpy(), *strchr();
extern char *get_home_dir();
extern alarm_t alarm();
extern unsigned short getuid();

main(argc, argv)
int argc;
char *argv[];
{
	char default_geom[20];
	int mask, x, y, sig_terminate();
	Color cdef;
	OpaqueFrame frame;

	prog_name = argv[0];
	user_id = (int) getuid();
	month_dir = get_home_dir(user_id);
	check_Xdefaults();
	check_args(argc, argv);
	close(0); close(1);	/* close stdin, stdout */
	if (fork() == 0) {
	    signal(SIGHUP, sig_terminate);	/* child process */
	    signal(SIGTERM, sig_terminate);
	    signal(SIGINT, SIG_IGN);
	    signal(SIGQUIT, SIG_IGN);
#ifdef SIGTSTP
	    signal(SIGTSTP, SIG_IGN);
	    signal(SIGTTIN, SIG_IGN);
	    signal(SIGTTOU, SIG_IGN);
#endif

	    /* Open X display. */

	    if (XOpenDisplay(display) == NULL) {
		fprintf(stderr, "%s: cannot open display\n", prog_name);
		exit(1);
	    }

	    /* Set up colors and pixmaps. */

	    if (DisplayCells() > 2 &&
		Brdr_color != NULL &&
		XParseColor(Brdr_color, &cdef) &&
		XGetHardwareColor(&cdef)
	    ) brdr_color = cdef.pixel;
	    else if (reverse) brdr_color = WhitePixel;
	    else brdr_color = BlackPixel;

	    if (DisplayCells() > 2 &&
		Fore_color != NULL &&
		XParseColor(Fore_color, &cdef) &&
		XGetHardwareColor(&cdef)
	    ) fore_color = cdef.pixel;
	    else if (reverse) fore_color = WhitePixel;
	    else fore_color = BlackPixel;

	    if (DisplayCells() > 2 &&
		Back_color != NULL &&
		XParseColor(Back_color, &cdef) &&
		XGetHardwareColor(&cdef)
	    ) back_color = cdef.pixel;
	    else if (reverse) back_color = BlackPixel;
	    else back_color = WhitePixel;

	    /* Open the font */

	    if ((base_font = XOpenFont(Base_font)) == NULL) {
                fprintf(stderr, "%s: cannot open font \"%s\"\n",
		    prog_name, Base_font);
		exit(1);
	    }

	    /* Determine if either xoffset and/or yoffset were negative */

	    mask = XParseGeometry(geom, &x, &y, &width, &height);
	    xneg = mask & XNegative;
	    yneg = mask & YNegative;

	    /* Create the window */

	    width = base_font->width*MAX_EVENT_STRING_LENGTH + int_border*2;
	    height = base_font->height*2 + int_border*2;
	    sprintf(default_geom, "=%dx%d+0+0", width, height);
	    frame.bdrwidth = border;
	    frame.border = XMakeTile(brdr_color);
	    frame.background = XMakeTile(back_color);
	    if ((win = XCreate("month events", prog_name, geom, default_geom,
              &frame, width, height)) == 0) {
                fprintf(stderr, "%s: cannot open window\n", prog_name);
		exit(1);
	    }

	    XSelectInput(win, ButtonPressed|ButtonReleased|ExposeWindow);
	    check_sched();
	    inf_loop();
	}
	exit(0);
	/* NOTREACHED */
}

check_Xdefaults()
{
	char *def_val;

	def_val = XGetDefault(prog_name, "Delay");
	if (def_val != NULL) delay = atoi(def_val);

	def_val = XGetDefault(prog_name, "Flashes");
	if (def_val != NULL) num_flash = atoi(def_val);

	def_val = XGetDefault(prog_name, "Geometry");
	if (def_val != NULL) geom = def_val;

	def_val = XGetDefault(prog_name, "InternalBorder");
	if (def_val != NULL) int_border = atoi(def_val);

	def_val = XGetDefault(prog_name, "Interval");
	if (def_val != NULL) dint = atoi(def_val) * 60;

	def_val = XGetDefault(prog_name, "BorderWidth");
	if (def_val != NULL) border = atoi(def_val);

	def_val = XGetDefault(prog_name, "BaseFont");
	if (def_val != NULL) Base_font = def_val;

	Fore_color = XGetDefault(prog_name, "Foreground");
	Back_color = XGetDefault(prog_name, "Background");
	Brdr_color = XGetDefault(prog_name, "Border");

	def_val = XGetDefault(prog_name, "ReverseVideo");
	if (def_val != NULL && strcmp(def_val, "on") == 0) reverse++;
}

check_args(argc, argv)
int argc;
char *argv[];
{
	int i;

	for (i = 1; i < argc; i++) {
	    if (argv[i][0] == '=') {
		geom = argv[i];
		continue;
	    }
	    if (strchr(argv[i], ':') != (char *)NULL) {
		display = argv[i];
		continue;
	    }
	    fprintf(stderr, "Usage: %s [=geometry] [host:display]\n", prog_name);
	    exit(1);
	}
}

inf_loop()
{
	XEvent event;

	for (;;) {
	    XNextEvent(&event);

	    switch(event.type) {
	    case ExposeWindow:
		if (have_new) {
		    flash_window(num_flash);
		    have_new = 0;
		} else
		    draw_window();
		break;
	    case ButtonPressed:
		XUnmapWindow(win);
		break;
	    }
	}
}

sig_terminate(sig)
int sig;
{
	signal(SIGHUP, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	alarm((alarm_t) 0);

	/*
	fprintf(stderr, "%s: terminate(%d)\n", prog_name, sig);
	*/
	exit(sig);
	/* NOTREACHED */
}

terminate(code)
int code;
{
        signal(SIGHUP, SIG_IGN);
        signal(SIGTERM, SIG_IGN);
        alarm((alarm_t) 0);

        if (code < 0)
            fprintf(stderr, "%s: cannot open .month\n", prog_name);
        else if (code > 0)
            fprintf(stderr, "%s: cannot read .month version %d\n",
                prog_name, code);
        exit(code);
        /* NOTREACHED */
}

struct remind_rec *
link_reminder(str, minutes)
char *str;
int minutes;
{
	int hours;
	char buf[12];
	struct remind_rec *remind;

	remind = (struct remind_rec *)malloc(sizeof(struct remind_rec));
	strcpy(remind->event_string, str);
	remind->time = minutes;
	hours = minutes / 60;
	minutes = minutes % 60;

	if ((hours == 0) && (minutes == 0))
	    strcpy(remind->time_string, "Right now");
	else {
	    strcpy(remind->time_string, "In");
	    if (hours > 1) {
		sprintf(buf, " %d hours", hours);
		strcat(remind->time_string, buf);
	    } else if (hours == 1)
		strcat(remind->time_string, " 1 hour");

	    if (minutes > 1) {
		sprintf(buf, " %d minutes", minutes);
		strcat(remind->time_string, buf);
	    } else if (minutes == 1)
		strcat(remind->time_string, " 1 minute");
	}

	strcat(remind->time_string, ".");
	remind->next = (struct remind_rec *)0;
	return(remind);
}

free_reminders(list)
struct remind_rec *list;
{
	struct remind_rec *p;

	while (list) {
	    p = list->next;
	    free((char *) list);
	    list = p;
	}
}
	    
sort_reminders()
{
	/* algorithm assumes at least one element in list */
	struct remind_rec *o, *p, *q;
	int swap;

	for (;;) {
	    o = (struct remind_rec *) 0;
	    p = remind_list;
	    q = p->next;
	    swap = 0;
	    while (q) {
		if (p->time > q->time) {
		    p->next = q->next;
		    q->next = p;
		    if (o)
			o->next = q;
		    else
			remind_list = q;
		    swap = 1;
		    o = q;
		    q = p->next;
		} else {
		    o = p;
		    p = q;
		    q = q->next;
		}
	    }
	    if (swap == 0)
		break;
	}
}

check_sched()
{
	int stat;
	struct event_rec *eptr;
	struct remind_rec *rptr;
	short minutes, eminutes, wminutes, diff;
	alarm_t seconds;

	signal(SIGALRM, check_sched);
	if (get_todays_date() != 0) {
	    fprintf(stderr, "%s: Cannot get today's date\n", prog_name);
	    exit(1);
	}
	seconds = dint - ((60 * dminute + dsecond) % dint);
	if (seconds < 60)
	    seconds += dint;
	alarm(seconds);
	minutes = (60 * dhour) + dminute;
	current_date.month = todays_date.month;
	current_date.day = todays_date.day;
	current_date.year = todays_date.year;
	month_start = get_month_start(current_date.month,
	    current_date.year);
	days = days_in(current_date.month, current_date.year);
	if (stat = read_schedule(month_dir, READ_ONLY))
	    terminate(stat);

	eptr = events.next_event;
	have_new = 0;

	while (eptr) {
	    if (event_today(eptr)) {
		eminutes = (((short)60) * eptr->start_time.hour) +
		    eptr->start_time.minute;
		wminutes = (((short)60) * eptr->warning.hour)
		    + eptr->warning.minute;
		diff = eminutes - minutes;
		if ((diff >= 0) && (diff <= wminutes)) {
		    if (have_new++) {
			rptr->next = link_reminder(eptr->event_string, diff);
			rptr = rptr->next;
		    } else {
			free_reminders(remind_list);
			remind_list = link_reminder(eptr->event_string, diff);
			rptr = remind_list;
		    }
		}
	    }
	    eptr = eptr->next_event;
	}

	if (have_new) {
	    sort_reminders();
	    map_window(have_new);
	}
}

map_window(num_events)
int num_events;
{
	struct remind_rec *rptr = remind_list;
	WindowInfo wininfo;

	width = 0;
	while (rptr) {
	    width = MAX(width, XStringWidth(rptr->event_string, base_font,
		0, 0));
	    width = MAX(width, XStringWidth(rptr->time_string, base_font,
		0, 0));
	    rptr = rptr->next;
	}

	width += (2 * int_border);
	height = (3 * num_events - 1) * base_font->height + 2 * int_border;

	XQueryWindow(win, &wininfo);

	if (xneg)
	    wininfo.x += (wininfo.width - width);
	if (yneg)
	    wininfo.y += (wininfo.height - height);

	XConfigureWindow(win, (int)wininfo.x, (int)wininfo.y, width, height);
	XMapWindow(win);
	XFeep(0);
	XFlush();
}

draw_window()
{
	struct remind_rec *rptr = remind_list;
	int x = int_border;
	int y = int_border;
	int yline;

	XPixSet (win, 0, 0, width, height, back_color);

	while (rptr) {
	    XText(win, x, y, rptr->event_string, strlen(rptr->event_string),
		base_font->id, fore_color, back_color);
	    y += base_font->height;
	    XText(win, x, y, rptr->time_string, strlen(rptr->time_string),
		base_font->id, fore_color, back_color);
	    y += 2*base_font->height;
	    yline = y - base_font->height / 2;
	    if (y < height)
		XLine(win, 0, yline, width - 1, yline, 1, 1,
		    brdr_color, GXcopy, AllPlanes);
	    rptr = rptr->next;
	}
}

flash_window(num)
int num;
{
	int i, j;
	int temp_color;
#if defined(hpux) || !SYS5
	static struct timeval delaytime;

	delaytime.tv_sec = 0;
	delaytime.tv_usec = delay * 10000;
#endif

	for (i = 0; i < num; i++) {
	    for (j = 0; j < 2; j++) {
		temp_color = fore_color;
		fore_color = back_color;
		back_color = temp_color;
		draw_window();
		XFlush();
#if defined(hpux) || !SYS5
		(void) select (0, (fd_type *)0, (fd_type *)0, (fd_type *)0,
			&delaytime);
#endif
	    }
	}
}
@EOF

chmod 644 xmonthd.c

echo x - chmonth.c
cat >chmonth.c <<'@EOF'
#ifndef lint
static char rcsid[] = "$Header: chmonth.c,v 8.3 88/01/15 10:58:19 hull Exp $";
#endif

#include <stdio.h>
#include <sys/types.h>
#if LOCKF
#include <fcntl.h>
#include <unistd.h>
#endif LOCKF
#if FLOCK
#include <sys/file.h>
#endif FLOCK
#include <pwd.h>
#include "month.h"
#include "month2.h"
#include "month3.h"
#include "month4.h"
#include "month5.h"
#include "month6.h"
#include "month7.h"

short updating, update_schedule = 1, keep_old = 1;
int user_id, fd;
char *month_dir = NULL;
struct date_rec todays_date;
struct event_rec2 events2 = {0, 0, 0, 0, 0, 0, {0, 0, 0, 0, 0, 0, 0},
0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
struct event_rec3 events3 = {0, 0, 0, 0, 0, 0, {0, 0, 0, 0, 0, 0, 0},
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
struct event_rec4 events4 = {0, 0, 0, 0, 0, 0, {0, 0, 0, 0, 0, 0, 0},
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
struct event_rec5 events5 = {0, 0, 0, 0, 0, 0, {0, 0, 0, 0, 0, 0, 0},
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
struct event_rec6 events6 = {0, 0, 0, 0, 0, 0, {0, 0, 0, 0, 0, 0, 0},
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
struct event_rec7 events7 = {{0, 0, 0}, 0, 0, 0, {0, 0, 0, 0, 0, 0, 0},
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0}, 0};
struct event_rec events = {{0, 0, 0}, 0, 0, 0, {0, 0, 0, 0, 0, 0, 0},
0, 0, 0, {0, 0}, {0, 0}, {0, 0}, {0, 0}, 0, 0, 0, 0, 0, {0, 0, 0}, 0};
extern char *strcat(), *strcpy();
extern unsigned short getuid();
extern float get_version();

char *
get_user()
{
	struct passwd *pw;

	user_id = (int) getuid();

	if ((pw = getpwuid(user_id)) == NULL)
	    return(NULL);
	else
	    return(pw->pw_dir);
}

char *
get_user_arg(arg)
char *arg;
{
	struct passwd *pw;

	if ((pw = getpwnam(arg)) == NULL)
	    return(NULL);
	else {
	    user_id = pw->pw_uid;
	    return(pw->pw_dir);
	}
}

check_args(argc, argv)
int argc;
char *argv[];
{
	switch(argc) {
	case 1:
		if ((month_dir = get_user()) == NULL) {
			printf("%s: No passwd entry\n", argv[0]);
			printf("Usage: %s [user]\n", argv[0]);
			exit(1);
		}
		user_id = (int) getuid();
		break;
	case 2:
		if ((month_dir = get_user_arg(argv[1])) == NULL) {
			printf("%s: No such user -- %s\n", argv[0], argv[1]);
			printf("Usage: %s [user]\n", argv[0]);
			exit(1);
		}
		break;
	default:
		printf("Usage: %s [user]\n", argv[0]);
		exit(1);

	}
}

main(argc, argv)
int argc;
char *argv[];
{
	int ret;

	check_args(argc, argv);
	if ((ret = read_schedule7(month_dir)) == 0)
	    convert_schedule7();
	else if ((ret = read_schedule6(month_dir)) == 0)
	    convert_schedule6();
	else if ((ret = read_schedule5(month_dir)) == 0)
	    convert_schedule5();
	else if ((ret = read_schedule4(month_dir)) == 0)
	    convert_schedule4();
	else if ((ret = read_schedule3(month_dir)) == 0)
	    convert_schedule3();
	else
	    if (ret == -2) {
		printf(".month file locked\n");
		exit(1);
	    } else if (ret == -1) {
		printf("cannot open .month\n");
		exit(1);
	    } else if (ret == (int) get_version()) {
		printf(".month file is up-to-date\n");
		exit(2);
	    } else
		if ((ret = read_schedule2(month_dir)) == 0)
		    convert_schedule2();
		else
		    if (ret == -2) {
			printf(".month file locked\n");
			exit(1);
		    } else if (ret == -1) {
			printf("cannot open .month\n");
			exit(1);
		    }

	if (write_schedule() < 0) {
	    printf("cannot write .month\n");
	    exit(1);
	}

	exit(0);
	/* NOTREACHED */
}

read_schedule2(m_dir)
char *m_dir;
{
	char *schedule_file_name;
	unsigned rec_size;
	struct event_rec2 event_buf, *event_ptr, *chain_ptr;

#ifdef DEBUG
	printf("reading schedule");
#endif
	events2.next_event = 0;

	schedule_file_name = malloc((unsigned) strlen(m_dir)+8);
	strcpy(schedule_file_name, m_dir);
	strcat(schedule_file_name, "/.month");
#ifdef DEBUG
	printf(" %s\n", schedule_file_name);
#endif

	rec_size = sizeof(struct event_rec2);

#if MULTIUSER
	if ((fd = open(schedule_file_name, O_RDWR|O_CREAT)) != -1)
#if LOCKF
	    if (lockf(fd, F_TLOCK, 0L) == -1)
#else
#if FLOCK
	    if (flock(fd, LOCK_EX | LOCK_NB) == -1)
#endif FLOCK
#endif LOCKF
		return(-2);
#else
	fd = open(schedule_file_name, O_RDWR|O_CREAT);
#endif MULTIUSER

	if (fd != -1) {
		chain_ptr = &events2;

		while (read(fd, &event_buf, rec_size) == rec_size) {
			if (event_ptr = (struct event_rec2 *) malloc(rec_size)) {
				chain_ptr->next_event = event_ptr;
				chain_ptr = event_ptr;
				*chain_ptr = event_buf;
				chain_ptr->next_event = (struct event_rec2 *)0;
			} else
				break;
		}
		return(0);
	}
	return(-1);
}

convert_schedule2()
{
	struct event_rec *chain_ptr, *event_ptr;
	struct event_rec2 *chain_ptr2;

#ifdef DEBUG
	printf("converting schedule\n");
#endif
	chain_ptr = &events;
	chain_ptr2 = events2.next_event;

	while (chain_ptr2) {
		if (event_ptr = (struct event_rec *) malloc(sizeof(struct event_rec))) {
			chain_ptr->next_event = event_ptr;
			chain_ptr = event_ptr;
			copy_event2(chain_ptr2, chain_ptr);
			chain_ptr->next_event = (struct event_rec *)0;
		} else
			break;
		chain_ptr2 = chain_ptr2->next_event;
	}
}

copy_event2(event_ptr2, event_ptr)
struct event_rec2 *event_ptr2;
struct event_rec *event_ptr;
{
	int i;

	event_ptr->start_date.month = event_ptr2->event_month;
	event_ptr->start_date.day = event_ptr2->event_day;
	event_ptr->start_date.year = event_ptr2->event_year;
	event_ptr->monthly = event_ptr2->monthly;
	event_ptr->yearly = event_ptr2->yearly;
	event_ptr->every = event_ptr2->every;
	for (i = 0; i < 7; i++)
	    event_ptr->smtwtfs[i] = event_ptr2->smtwtfs[i];
	event_ptr->nth = event_ptr2->nth;
	event_ptr->last = event_ptr2->last;
	event_ptr->nth_is_on = event_ptr2->nth_is_on;
	event_ptr->start_time.hour = event_ptr2->hour;
	event_ptr->start_time.minute = event_ptr2->minute;
	event_ptr->duration.hour = event_ptr2->duration_hours;
	event_ptr->duration.minute = event_ptr2->duration_minutes;
	event_ptr->warning.hour = 0;
	event_ptr->warning.minute = 15;
	event_ptr->end_time.minute = event_ptr->start_time.minute +
	    event_ptr->duration.minute;
	event_ptr->end_time.hour = (event_ptr->start_time.hour +
	    event_ptr->duration.hour + (event_ptr->end_time.minute / 60)) % 24;
	event_ptr->end_time.minute %= 60;
	for (i = 0; i < MAX_EVENT_STRING_LENGTH; i++)
	    event_ptr->event_string[i] = event_ptr2->event_string[i];
	event_ptr->private = event_ptr2->private;
	event_ptr->event_owner = user_id;
	event_ptr->until = 0;
	event_ptr->until_date.month = event_ptr2->event_month;
	event_ptr->until_date.day = event_ptr2->event_day;
	event_ptr->until_date.year = event_ptr2->event_year;
}

read_schedule3(m_dir)
char *m_dir;
{
	char *schedule_file_name;
	unsigned rec_size;
	short file_version;
	struct event_rec3 event_buf, *event_ptr, *chain_ptr;

#ifdef DEBUG
	printf("reading schedule");
#endif
	schedule_file_name = malloc((unsigned) strlen(m_dir)+8);
	strcpy(schedule_file_name, m_dir);
	strcat(schedule_file_name, "/.month");
#ifdef DEBUG
	printf(" %s\n", schedule_file_name);
#endif

	rec_size = sizeof(struct event_rec3);
	umask(0);

#if MULTIUSER
	if ((fd = open(schedule_file_name, O_RDWR|O_CREAT)) != -1)
#if LOCKF
	    if (lockf(fd, F_TLOCK, 0L) == -1)
#else
#if FLOCK
	    if (flock(fd, LOCK_EX | LOCK_NB) == -1)
#endif FLOCK
#endif LOCKF
		return(-2);
#else
	fd = open(schedule_file_name, O_RDWR|O_CREAT);
#endif MULTIUSER

	if (fd != -1) {
		events3.next_event = 0;

		if (read(fd, (char *) &file_version, sizeof(file_version)) !=
		    sizeof(file_version))
			return(-1);
		if (file_version != 3)
			return(file_version);

		chain_ptr = &events3;

		while (read(fd, &event_buf, rec_size) == rec_size) {
			if (event_ptr = (struct event_rec3 *) malloc(rec_size)) {
				chain_ptr->next_event = event_ptr;
				chain_ptr = event_ptr;
				*chain_ptr = event_buf;
				chain_ptr->next_event = (struct event_rec3 *)0;
			} else
				break;
		}
		return(0);
	}
	return(-1);
}

convert_schedule3()
{
	struct event_rec *chain_ptr, *event_ptr;
	struct event_rec3 *chain_ptr3;

#ifdef DEBUG
	printf("converting schedule\n");
#endif
	chain_ptr = &events;
	chain_ptr3 = events3.next_event;

	while (chain_ptr3) {
		if (event_ptr = (struct event_rec *) malloc(sizeof(struct event_rec))) {
			chain_ptr->next_event = event_ptr;
			chain_ptr = event_ptr;
			copy_event3(chain_ptr3, chain_ptr);
			chain_ptr->next_event = (struct event_rec *)0;
		} else
			break;
		chain_ptr3 = chain_ptr3->next_event;
	}
}

copy_event3(event_ptr3, event_ptr)
struct event_rec3 *event_ptr3;
struct event_rec *event_ptr;
{
	int i;

	event_ptr->start_date.month = event_ptr3->event_month;
	event_ptr->start_date.day = event_ptr3->event_day;
	event_ptr->start_date.year = event_ptr3->event_year;
	event_ptr->monthly = event_ptr3->monthly;
	event_ptr->yearly = event_ptr3->yearly;
	event_ptr->every = event_ptr3->every;
	for (i = 0; i < 7; i++)
	    event_ptr->smtwtfs[i] = event_ptr3->smtwtfs[i];
	event_ptr->nth = event_ptr3->nth;
	event_ptr->last = event_ptr3->last;
	event_ptr->nth_is_on = event_ptr3->nth_is_on;
	event_ptr->start_time.hour = event_ptr3->hour;
	event_ptr->start_time.minute = event_ptr3->minute;
	event_ptr->duration.hour = event_ptr3->duration_hours;
	event_ptr->duration.minute = event_ptr3->duration_minutes;
	event_ptr->warning.hour = 0;
	event_ptr->warning.minute = 15;
	event_ptr->end_time.minute = event_ptr->start_time.minute +
	    event_ptr->duration.minute;
	event_ptr->end_time.hour = (event_ptr->start_time.hour +
	    event_ptr->duration.hour + (event_ptr->end_time.minute / 60)) % 24;
	event_ptr->end_time.minute %= 60;
	for (i = 0; i < MAX_EVENT_STRING_LENGTH; i++)
	    event_ptr->event_string[i] = event_ptr3->event_string[i];
	event_ptr->private = event_ptr3->private;
	event_ptr->event_owner = event_ptr3->event_owner;
	event_ptr->until = 0;
	event_ptr->until_date.month = event_ptr3->event_month;
	event_ptr->until_date.day = event_ptr3->event_day;
	event_ptr->until_date.year = event_ptr3->event_year;
}

read_schedule4(m_dir)
char *m_dir;
{
	char *schedule_file_name;
	unsigned rec_size;
	short file_version;
	struct event_rec4 event_buf, *event_ptr, *chain_ptr;

#ifdef DEBUG
	printf("reading schedule");
#endif
	schedule_file_name = malloc((unsigned) strlen(m_dir)+8);
	strcpy(schedule_file_name, m_dir);
	strcat(schedule_file_name, "/.month");
#ifdef DEBUG
	printf(" %s\n", schedule_file_name);
#endif

	rec_size = sizeof(struct event_rec4);
	umask(0);

#if MULTIUSER
	if ((fd = open(schedule_file_name, O_RDWR|O_CREAT)) != -1)
#if LOCKF
	    if (lockf(fd, F_TLOCK, 0L) == -1)
#else
#if FLOCK
	    if (flock(fd, LOCK_EX | LOCK_NB) == -1)
#endif FLOCK
#endif LOCKF
		return(-2);
#else
	fd = open(schedule_file_name, O_RDWR|O_CREAT);
#endif MULTIUSER

	if (fd != -1) {
		events4.next_event = 0;

		if (read(fd, (char *) &file_version, sizeof(file_version)) !=
		    sizeof(file_version))
			return(-1);
		if (file_version != 4)
			return(file_version);

		chain_ptr = &events4;

		while (read(fd, &event_buf, rec_size) == rec_size) {
			if (event_ptr = (struct event_rec4 *) malloc(rec_size)) {
				chain_ptr->next_event = event_ptr;
				chain_ptr = event_ptr;
				*chain_ptr = event_buf;
				chain_ptr->next_event = (struct event_rec4 *)0;
			} else
				break;
		}
		return(0);
	}
	return(-1);
}

convert_schedule4()
{
	struct event_rec *chain_ptr, *event_ptr;
	struct event_rec4 *chain_ptr4;

#ifdef DEBUG
	printf("converting schedule\n");
#endif
	chain_ptr = &events;
	chain_ptr4 = events4.next_event;

	while (chain_ptr4) {
		if (event_ptr = (struct event_rec *) malloc(sizeof(struct event_rec))) {
			chain_ptr->next_event = event_ptr;
			chain_ptr = event_ptr;
			copy_event4(chain_ptr4, chain_ptr);
			chain_ptr->next_event = (struct event_rec *)0;
		} else
			break;
		chain_ptr4 = chain_ptr4->next_event;
	}
}

copy_event4(event_ptr4, event_ptr)
struct event_rec4 *event_ptr4;
struct event_rec *event_ptr;
{
	int i;

	event_ptr->start_date.month = event_ptr4->start_month;
	event_ptr->start_date.day = event_ptr4->start_day;
	event_ptr->start_date.year = event_ptr4->start_year;
	event_ptr->monthly = event_ptr4->monthly;
	event_ptr->yearly = event_ptr4->yearly;
	event_ptr->every = event_ptr4->every;
	for (i = 0; i < 7; i++)
	    event_ptr->smtwtfs[i] = event_ptr4->smtwtfs[i];
	event_ptr->nth = event_ptr4->nth;
	event_ptr->last = event_ptr4->last;
	event_ptr->nth_is_on = event_ptr4->nth_is_on;
	event_ptr->start_time.hour = event_ptr4->hour;
	event_ptr->start_time.minute = event_ptr4->minute;
	event_ptr->duration.hour = event_ptr4->duration_hours;
	event_ptr->duration.minute = event_ptr4->duration_minutes;
	event_ptr->warning.hour = 0;
	event_ptr->warning.minute = 15;
	event_ptr->end_time.minute = event_ptr->start_time.minute +
	    event_ptr->duration.minute;
	event_ptr->end_time.hour = (event_ptr->start_time.hour +
	    event_ptr->duration.hour + (event_ptr->end_time.minute / 60)) % 24;
	event_ptr->end_time.minute %= 60;
	for (i = 0; i < MAX_EVENT_STRING_LENGTH; i++)
	    event_ptr->event_string[i] = event_ptr4->event_string[i];
	event_ptr->private = event_ptr4->private;
	event_ptr->event_owner = event_ptr4->event_owner;
	event_ptr->until = event_ptr4->until;
	event_ptr->until_date.month = event_ptr4->until_month;
	event_ptr->until_date.day = event_ptr4->until_day;
	event_ptr->until_date.year = event_ptr4->until_year;
}

read_schedule5(m_dir)
char *m_dir;
{
	char *schedule_file_name;
	unsigned rec_size;
	short file_version;
	struct event_rec5 event_buf, *event_ptr, *chain_ptr;

#ifdef DEBUG
	printf("reading schedule");
#endif
	schedule_file_name = malloc((unsigned) strlen(m_dir)+8);
	strcpy(schedule_file_name, m_dir);
	strcat(schedule_file_name, "/.month");
#ifdef DEBUG
	printf(" %s\n", schedule_file_name);
#endif

	rec_size = sizeof(struct event_rec5);
	umask(0);

#if MULTIUSER
	if ((fd = open(schedule_file_name, O_RDWR|O_CREAT)) != -1)
#if LOCKF
	    if (lockf(fd, F_TLOCK, 0L) == -1)
#else
#if FLOCK
	    if (flock(fd, LOCK_EX | LOCK_NB) == -1)
#endif FLOCK
#endif LOCKF
		return(-2);
#else
	fd = open(schedule_file_name, O_RDWR|O_CREAT);
#endif MULTIUSER

	if (fd != -1) {
		events5.next_event = 0;

		if (read(fd, (char *) &file_version, sizeof(file_version)) !=
		    sizeof(file_version))
			return(-1);
		if (file_version != 5)
			return(file_version);

		chain_ptr = &events5;

		while (read(fd, &event_buf, rec_size) == rec_size) {
			if (event_ptr = (struct event_rec5 *) malloc(rec_size)) {
				chain_ptr->next_event = event_ptr;
				chain_ptr = event_ptr;
				*chain_ptr = event_buf;
				chain_ptr->next_event = (struct event_rec5 *)0;
			} else
				break;
		}
		return(0);
	}
	return(-1);
}

convert_schedule5()
{
	struct event_rec *chain_ptr, *event_ptr;
	struct event_rec5 *chain_ptr5;

#ifdef DEBUG
	printf("converting schedule\n");
#endif
	chain_ptr = &events;
	chain_ptr5 = events5.next_event;

	while (chain_ptr5) {
		if (event_ptr = (struct event_rec *) malloc(sizeof(struct event_rec))) {
			chain_ptr->next_event = event_ptr;
			chain_ptr = event_ptr;
			copy_event5(chain_ptr5, chain_ptr);
			chain_ptr->next_event = (struct event_rec *)0;
		} else
			break;
		chain_ptr5 = chain_ptr5->next_event;
	}
}

copy_event5(event_ptr5, event_ptr)
struct event_rec5 *event_ptr5;
struct event_rec *event_ptr;
{
	int i;

	event_ptr->start_date.month = event_ptr5->start_month;
	event_ptr->start_date.day = event_ptr5->start_day;
	event_ptr->start_date.year = event_ptr5->start_year;
	event_ptr->monthly = event_ptr5->monthly;
	event_ptr->yearly = event_ptr5->yearly;
	event_ptr->every = event_ptr5->every;
	for (i = 0; i < 7; i++)
	    event_ptr->smtwtfs[i] = event_ptr5->smtwtfs[i];
	event_ptr->nth = event_ptr5->nth;
	event_ptr->last = event_ptr5->last;
	event_ptr->nth_is_on = event_ptr5->nth_is_on;
	event_ptr->start_time.hour = event_ptr5->hour;
	event_ptr->start_time.minute = event_ptr5->minute;
	event_ptr->duration.hour = event_ptr5->duration_hours;
	event_ptr->duration.minute = event_ptr5->duration_minutes;
	event_ptr->warning.hour = event_ptr5->warning_hours;
	event_ptr->warning.minute = event_ptr5->warning_minutes;
	event_ptr->end_time.minute = event_ptr->start_time.minute +
	    event_ptr->duration.minute;
	event_ptr->end_time.hour = (event_ptr->start_time.hour +
	    event_ptr->duration.hour + (event_ptr->end_time.minute / 60)) % 24;
	event_ptr->end_time.minute %= 60;
	for (i = 0; i < MAX_EVENT_STRING_LENGTH; i++)
	    event_ptr->event_string[i] = event_ptr5->event_string[i];
	event_ptr->private = event_ptr5->private;
	event_ptr->anti = 0;
	event_ptr->event_owner = event_ptr5->event_owner;
	event_ptr->until = event_ptr5->until;
	event_ptr->until_date.month = event_ptr5->until_month;
	event_ptr->until_date.day = event_ptr5->until_day;
	event_ptr->until_date.year = event_ptr5->until_year;
}

read_schedule6(m_dir)
char *m_dir;
{
	char *schedule_file_name;
	unsigned rec_size;
	short file_version;
	struct event_rec6 event_buf, *event_ptr, *chain_ptr;

#ifdef DEBUG
	printf("reading schedule");
#endif
	schedule_file_name = malloc((unsigned) strlen(m_dir)+8);
	strcpy(schedule_file_name, m_dir);
	strcat(schedule_file_name, "/.month");
#ifdef DEBUG
	printf(" %s\n", schedule_file_name);
#endif

	rec_size = sizeof(struct event_rec6);
	umask(0);

#if MULTIUSER
	if ((fd = open(schedule_file_name, O_RDWR|O_CREAT)) != -1)
#if LOCKF
	    if (lockf(fd, F_TLOCK, 0L) == -1)
#else
#if FLOCK
	    if (flock(fd, LOCK_EX | LOCK_NB) == -1)
#endif FLOCK
#endif LOCKF
		return(-2);
#else
	fd = open(schedule_file_name, O_RDWR|O_CREAT);
#endif MULTIUSER

	if (fd != -1) {
		events6.next_event = 0;

		if (read(fd, (char *) &file_version, sizeof(file_version)) !=
		    sizeof(file_version))
			return(-1);
		if (file_version != 6)
			return(file_version);

		chain_ptr = &events6;

		while (read(fd, &event_buf, rec_size) == rec_size) {
			if (event_ptr = (struct event_rec6 *) malloc(rec_size)) {
				chain_ptr->next_event = event_ptr;
				chain_ptr = event_ptr;
				*chain_ptr = event_buf;
				chain_ptr->next_event = (struct event_rec6 *)0;
			} else
				break;
		}
		return(0);
	}
	return(-1);
}

convert_schedule6()
{
	struct event_rec *chain_ptr, *event_ptr;
	struct event_rec6 *chain_ptr6;

#ifdef DEBUG
	printf("converting schedule\n");
#endif
	chain_ptr = &events;
	chain_ptr6 = events6.next_event;

	while (chain_ptr6) {
		if (event_ptr = (struct event_rec *) malloc(sizeof(struct event_rec))) {
			chain_ptr->next_event = event_ptr;
			chain_ptr = event_ptr;
			copy_event6(chain_ptr6, chain_ptr);
			chain_ptr->next_event = (struct event_rec *)0;
		} else
			break;
		chain_ptr6 = chain_ptr6->next_event;
	}
}

copy_event6(event_ptr6, event_ptr)
struct event_rec6 *event_ptr6;
struct event_rec *event_ptr;
{
	int i;

	event_ptr->start_date.month = event_ptr6->start_month;
	event_ptr->start_date.day = event_ptr6->start_day;
	event_ptr->start_date.year = event_ptr6->start_year;
	event_ptr->monthly = event_ptr6->monthly;
	event_ptr->yearly = event_ptr6->yearly;
	event_ptr->every = event_ptr6->every;
	for (i = 0; i < 7; i++)
	    event_ptr->smtwtfs[i] = event_ptr6->smtwtfs[i];
	event_ptr->nth = event_ptr6->nth;
	event_ptr->last = event_ptr6->last;
	event_ptr->nth_is_on = event_ptr6->nth_is_on;
	event_ptr->start_time.hour = event_ptr6->hour;
	event_ptr->start_time.minute = event_ptr6->minute;
	event_ptr->duration.hour = event_ptr6->duration_hours;
	event_ptr->duration.minute = event_ptr6->duration_minutes;
	event_ptr->warning.hour = event_ptr6->warning_hours;
	event_ptr->warning.minute = event_ptr6->warning_minutes;
	event_ptr->end_time.minute = event_ptr->start_time.minute +
	    event_ptr->duration.minute;
	event_ptr->end_time.hour = (event_ptr->start_time.hour +
	    event_ptr->duration.hour + (event_ptr->end_time.minute / 60)) % 24;
	event_ptr->end_time.minute %= 60;
	for (i = 0; i < MAX_EVENT_STRING_LENGTH; i++)
	    event_ptr->event_string[i] = event_ptr6->event_string[i];
	event_ptr->private = event_ptr6->private;
	event_ptr->anti = event_ptr6->anti;
	event_ptr->event_owner = event_ptr6->event_owner;
	event_ptr->until = event_ptr6->until;
	event_ptr->until_date.month = event_ptr6->until_month;
	event_ptr->until_date.day = event_ptr6->until_day;
	event_ptr->until_date.year = event_ptr6->until_year;
}

read_schedule7(m_dir)
char *m_dir;
{
	char *schedule_file_name;
	unsigned rec_size;
	short file_version;
	struct event_rec7 event_buf, *event_ptr, *chain_ptr;

#ifdef DEBUG
	printf("reading schedule");
#endif
	schedule_file_name = malloc((unsigned) strlen(m_dir)+8);
	strcpy(schedule_file_name, m_dir);
	strcat(schedule_file_name, "/.month");
#ifdef DEBUG
	printf(" %s\n", schedule_file_name);
#endif

	rec_size = sizeof(struct event_rec7);
	umask(0);

#if MULTIUSER
	if ((fd = open(schedule_file_name, O_RDWR|O_CREAT)) != -1)
#if LOCKF
	    if (lockf(fd, F_TLOCK, 0L) == -1)
#else
#if FLOCK
	    if (flock(fd, LOCK_EX | LOCK_NB) == -1)
#endif FLOCK
#endif LOCKF
		return(-2);
#else
	fd = open(schedule_file_name, O_RDWR|O_CREAT);
#endif MULTIUSER

	if (fd != -1) {
		events7.next_event = 0;

		if (read(fd, (char *) &file_version, sizeof(file_version)) !=
		    sizeof(file_version))
			return(-1);
		if (file_version != 7)
			return(file_version);

		chain_ptr = &events7;

		while (read(fd, &event_buf, rec_size) == rec_size) {
			if (event_ptr = (struct event_rec7 *) malloc(rec_size)) {
				chain_ptr->next_event = event_ptr;
				chain_ptr = event_ptr;
				*chain_ptr = event_buf;
				chain_ptr->next_event = (struct event_rec7 *)0;
			} else
				break;
		}
		return(0);
	}
	return(-1);
}

convert_schedule7()
{
	struct event_rec *chain_ptr, *event_ptr;
	struct event_rec7 *chain_ptr7;

#ifdef DEBUG
	printf("converting schedule\n");
#endif
	chain_ptr = &events;
	chain_ptr7 = events7.next_event;

	while (chain_ptr7) {
		if (event_ptr = (struct event_rec *) malloc(sizeof(struct event_rec))) {
			chain_ptr->next_event = event_ptr;
			chain_ptr = event_ptr;
			copy_event7(chain_ptr7, chain_ptr);
			chain_ptr->next_event = (struct event_rec *)0;
		} else
			break;
		chain_ptr7 = chain_ptr7->next_event;
	}
}

copy_event7(event_ptr7, event_ptr)
struct event_rec7 *event_ptr7;
struct event_rec *event_ptr;
{
	int i;

	event_ptr->start_date.month = event_ptr7->start_date.month;
	event_ptr->start_date.day = event_ptr7->start_date.day;
	event_ptr->start_date.year = event_ptr7->start_date.year;
	event_ptr->monthly = event_ptr7->monthly;
	event_ptr->yearly = event_ptr7->yearly;
	event_ptr->every = event_ptr7->every;
	for (i = 0; i < 7; i++)
	    event_ptr->smtwtfs[i] = event_ptr7->smtwtfs[i];
	event_ptr->nth = event_ptr7->nth;
	event_ptr->last = event_ptr7->last;
	event_ptr->nth_is_on = event_ptr7->nth_is_on;
	event_ptr->start_time.hour = event_ptr7->hour;
	event_ptr->start_time.minute = event_ptr7->minute;
	event_ptr->duration.hour = event_ptr7->duration_hours;
	event_ptr->duration.minute = event_ptr7->duration_minutes;
	event_ptr->warning.hour = event_ptr7->warning_hours;
	event_ptr->warning.minute = event_ptr7->warning_minutes;
	event_ptr->end_time.minute = event_ptr->start_time.minute +
	    event_ptr->duration.minute;
	event_ptr->end_time.hour = (event_ptr->start_time.hour +
	    event_ptr->duration.hour + (event_ptr->end_time.minute / 60)) % 24;
	event_ptr->end_time.minute %= 60;
	for (i = 0; i < MAX_EVENT_STRING_LENGTH; i++)
	    event_ptr->event_string[i] = event_ptr7->event_string[i];
	event_ptr->private = event_ptr7->private;
	event_ptr->anti = event_ptr7->anti;
	event_ptr->event_owner = event_ptr7->event_owner;
	event_ptr->until = event_ptr7->until;
	event_ptr->until_date.month = event_ptr7->until_date.month;
	event_ptr->until_date.day = event_ptr7->until_date.day;
	event_ptr->until_date.year = event_ptr7->until_date.year;
}

/* ARGSUSED */
delete_event(event)
struct event_rec *event;
{
/* dummy routine to satisfy reference in write_schedule */
}
@EOF

chmod 644 chmonth.c

exit 0

