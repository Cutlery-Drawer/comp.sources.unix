Subject:  v16i048:  Terminal emulator for NeWS window system, Part01/04
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: hoptoad!gnu@uunet.uu.net
Posting-number: Volume 16, Issue 48
Archive-name: psterm/part01

The Grasshopper Group took Sun's psterm and worked it over to make a
much better terminal emulator for NeWS.  We also worked with Sun to
clarify the copyright to make it clear that it can be redistributed by
anyone on any machine.

This psterm has:

	scroll bars
	whole screen font changes and variable width fonts
	whole screen point size changes
	resizing can change rows/cols *or* point size
	rectangular and "hot" selections
	numerous bug fixes (more will be needed)

We encourage you to use and improve it; send us back the changes.  Send
flowers, brickbats, picture postcards and diff files to: tech@toad.com
or to Grasshopper Group, 212 Clayton St., San Francisco, CA  94117.

: psterm part 1 of 4
: To unbundle, sh this file
echo README
cat >README <<'@@@ Fin de README'
Psterm is a terminal emulator that runs under the NeWS window system.
Terminal-oriented applications (like the Unix shell) run inside it.
It displays their output, manages their input, and handles their
interaction with other programs that share the user's screen.
It will try to emulate any terminal described by "termcap", though due
to limitations in the termcap model it often fails at this;
it's best to use the "psterm" termcap entry unless you have special
requirements.

This is release Grass-1 of psterm from the Grasshopper Group.  The
original source from Sun Microsystems' NeWS 1.1 release is freely
distributable under Sun's copyright, reproduced below.  (Sun modified
the copyright after the release, and supplied us the revised wording
that is used here.)  The modifications to that source which were made at
the Grasshopper Group are in the public domain.

The Grasshopper Group sells and supports NeWS-related products.  Our
first product is MacNews, a port of NeWS for A/UX on the Macintosh-II.
Psterm is our second "product", though it is offered freely to the public
to make NeWS more usable on all systems, and to advertise our company.
You can reach us at:

	Grasshopper Group
	212 Clayton St.
	San Francisco, CA  94117

+1 408 978 7616	  orders, business questions, 830-5 Pacific	 orders@toad.com
+1 415 668 5998	  technical questions,	      afternoons Pacific   tech@toad.com

The Grasshopper Group modifications to psterm are by Eric Messick, from
designs by ||ugh Daniel & Eric Messick.  Please send questions,
comments, bugs, fixes, etc... to tech@toad.com.


			Installation

Unpack the four shar files in an empty directory.

The installation has been tested on SunOS 4.0 on Sparc and 68020, and
on A/UX on the Macintosh-II.  It should be fairly easy to port it
to other Unix systems.  If you do such a port, please send back the
changes required, as complete source files or "context diffs", to
the Grasshopper Group at tech@toad.com.  We will integrate your fixes and
post patches as required.

Some of the source files include <ref/config.h>.  The directory "ref"
is included, with sample config.h files.  Most of the effort of porting
psterm to another system, is in modifying one of these config files to
match the local programming environment.  Create a symlink to the
appropriate one as follows, replacing XXX with "sunos" or "aux".  If
your system doesn't have symbolic links, just link it or copy it
instead.

	cd ref
	ln -s config_XXX config.h
	cd ..

Now you should be ready to:

	make

to create the binary program "psterm".  Then:

	make install

to install the psterm binary in /usr/NeWS/bin/psterm, the PostScript
code in /usr/NeWS/lib/psterm.ps, and the man page in /usr/man/manl/psterm.l.
Edit the Makefile if this is inappropriate on your system.

A tutorial called UsingPSTerm is also included.

You should also install a new terminal type in /etc/termcap which
was designed specifically for psterm.  You will have to do this step,
and the next (terminfo) step if required, as root:

	mv /etc/termcap /etc/termcap.orig
	cat psterm.tcap /etc/termcap.orig > /etc/termcap

If your system uses terminfo, you'll have to update your terminfo database as
well...  so, as root:

	tic psterm.tinfo

Tic is in /usr/5bin if you have installed "System V Compatability"
under SunOS.  Remember to update the terminal descriptions on all of
the systems in your network, and to compile the psterm binary for all
machines, even if there is no news_server (or screen!) on machines like
Vaxen or Amdahls.

Note: the termcap and terminfo updates also include nterm descriptions.

That should be it... have fun.

If you find bugs, first read the BUGS file in this release.  Then, if
your bug is news to us (or if you have a fix for it), send email to
"tech@toad.com" describing which psterm you have (including the patch
level from patchlevel.h), how to reproduce the bug, what happens when
you reproduce it, and how to fix it if you know.


			Table Of Contents

  This set of shar files contains the following files:

BUGS		Text file containing known bug descriptions
Makefile	Makefile
README		This file
UsingPSTerm	Ascii text tutorial
bsd.c		bsd operating system interface
display.c	screen maintainence
io.c		low level input/output
main.c		argument processing, main()
patchlevel.h	revision level
psterm.1	man page
psterm.ps	PostScript code
psterm.tcap	termcap entries
psterm.tinfo	terminfo entries
ref/config_aux	A/UX specific configuration information
ref/config_sunos	SunOS configuration information
sampl.pstermrc	example .pstermrc file
sampl.user.ps	example user.ps file
screen.h	description of screen data structures
selection.c	text selection handling routines
slave.c		process forking routines
sys5.c		System V operating system interface
tcap.cps	C to PostScript interface routines
tcap_ops.c	termcap screen manipulation functions
tcap_parse.c	termcap escape sequence parsing code
termcap.h	description of termcap data structures



			Notes

NeWS has urgently needed a good terminal emulator for some time.  We at
the Grasshopper Group hope that this version of psterm can fill that
gap for a while.  There are, however, several fundamental problems with
psterm which limit its potential usefulness.  Many of the problems with
the original version of psterm have been dealt with, but the program
has been stretched far beyond the original concept, and is approching
the limits of its design.

There is a fundamental conceptual problem with the idea of emulating a
terminal by reading its termcap entry.  The termcap entry describes how
to get a terminal to perform a certain set of tasks.  It does NOT
describe how the given terminal will respond to a sequence of
characters.  This is the information needed by a terminal emulator.  As
an example, consider the vt100 termcap entry.  Clearing the screen on a
vt100 does not home the cursor.  Unfortunately, the termcap string for
screen clearing (cs) is defined to both clear the screen and home the
cursor.  To cope with this, the termcap entry for clearing the screen
on a vt100 emits two escape sequences:  one for homing the cursor, and
one for clearing the screen.  BUT THERE IS NO WAY FOR PSTERM TO KNOW
THIS!  Psterm thinks that in order to clear the screen, this double
sequence must be recieved, and WILL NOT RECOGNIZE JUST THE CLEAR SCREEN
SEQUENCE.  There is a similar problem with the h19 entry.  Codes which
are transmitted by the ``enter screen mode'' string are not defined
elsewhere in the termcap entry, so there is NO WAY for psterm to know
what to do with these.

A more serious (though much more subtle) problem concerns the design of
the program itself.  It is not a good example of how to divide the
labor between the client side and the server side.  This is important
because we desperately need good examples of this poorly understood
aspect of NeWS programming.  The power and flexibility of a fully
programmable graphics server depend on programmers correctly dividing
tasks between client and server.  Psterm relies too heavily on the
client program for repainting the screen and repairing damage.  On the
other hand, the other common NeWS terminal emulator, Nterm, does too
much of its terminal emulation in PostScript, and its performance
suffers as a result.  The correct division point lies somewhere between
these two attempts.  As a result of the incorrect division of labor of
psterm, the addition of scrollbars was a difficult and painful task.
If the division had been made at the proper point, I am confident that
implementing scrollbars would have been painless and quick.


			Sun's copyright notice

The original copyright notice on Sun's NeWS 1.1 client program sources
required that it be distributed "as part of a product or program
developed by the user."  This prohibited a variety of noncommercial
distributions, like Usenet postings, source archives like uunet's, or
tape collections like Usenix's or Sun User Group's.  Sun graciously
modified their copyright and authorized us to replace the previous
notice with their new notice, which will be in their next NeWS release.
The whole thing is below (the relevant line is the fourth):

/*
 * This file is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.
 * Users may copy, modify or distribute this file at will.
 * 
 * THIS FILE IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * This file is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY THIS FILE
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even
 * if Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
 */

@(#)$Header: README,v 2.4 88/10/04 19:17:18 eric Release $
@@@ Fin de README
echo BUGS
cat >BUGS <<'@@@ Fin de BUGS'
#		Psterm Bug List
# @(#)$Header: BUGS,v 1.3 88/10/03 18:57:58 gnu Release $

PSTerm was an experiment in general purpose terminal emulators.  It
was a very interesting experiment, and taught us how to do a few
things.  I feel that it has taught us how NOT to do many more things
in the NeWS environment, and that is has served as a good lesson.

We have made PSTerm useful; it serves as a working
"emulator" of the psterm termcap.  Further work on psterm seems
pointless, as more would be gained from a completely new terminal
program.

If you wish to hack on it, be warned that we have pushed it
beyond its design already, and that it may be hard going.  We
will not be putting more effort into it except to fold in bug fixes
that are sent in to us (to "tech@toad.com").

Thanks to David Rosenthal for creating the original psterm;
it was a wondrous idea.

   ---

Window placement is in pixel units.  This would perhaps best be fixed by a
parser for units on the command line, though currently NeWS does not
know the dimensions of its screen in inches or dots per inch.  A
related problem is that although units are specified in points, the
resulting measurements are actually pixels.

Termcaps cannot describe how to emulate a terminal adequately.  The
information in the termcap or terminfo files is not explicit enough to
let psterm emulate most terminals.  Many termcap entries are written in
ways that depend on the inner workings of a terminal in such a way that
just looking at the termcap will not allow psterm to deal with a
program that knows more or different things about the emulated
terminal.  An example is given in the README file.  Terminfo is
somewhat better, but psterm does not use it.  A proper job would
require more information than provided by both termcap and terminfo.

Display slowness.  Sometimes when displaying a full screen of text,
psterm will display it in several chunks, with visible pauses between.
This may have to do with the default psio buffer size of 1K.

Some problems are in the fact that NeWS is young:  on some servers, the
icon text gets cleared as soon as it is drawn because of a math 'off by
one' bug (edge condition) that is different for each machine.  See
psterm.ps for new twiddle values to take care of this.

Sound (Control G, Beep) is not supported.

Sometimes the input focus hilight is on but typing is ignored;
this is a LiteWindows (LiteUI) bug.

Fixed width fonts don't scale much of the time because there is
no font matrix information (fontname.fm files) for them.

There is a 64k limit to strings in NeWS 1.1, but due to typecheck bugs,
psterm.ps limits selections to 32k.

Some problems are just hard work, but it is not clear that psterm is
worth the extra effort to fix.

See the README file for more discussion of problems with the psterm concept.
@@@ Fin de BUGS
echo patchlevel.h
cat >patchlevel.h <<'@@@ Fin de patchlevel.h'
#define PATCHLEVEL 0
@@@ Fin de patchlevel.h
echo Makefile
cat >Makefile <<'@@@ Fin de Makefile'
#
# This file is a product of Sun Microsystems, Inc. and is provided for
# unrestricted use provided that this legend is included on all tape
# media and as a part of the software program in whole or part.
# Users may copy, modify or distribute this file at will.
# 
# THIS FILE IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
# WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
# PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
# 
# This file is provided with no support and without any obligation on the
# part of Sun Microsystems, Inc. to assist in its use, correction,
# modification or enhancement.
# 
# SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
# INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY THIS FILE
# OR ANY PART THEREOF.
# 
# In no event will Sun Microsystems, Inc. be liable for any lost revenue
# or profits or other special, indirect and consequential damages, even
# if Sun has been advised of the possibility of such damages.
# 
# Sun Microsystems, Inc.
# 2550 Garcia Avenue
# Mountain View, California  94043
#
#
# @(#)Makefile.psterm 9.9 88/01/19
# @(#)$Header: Makefile,v 2.4 88/10/04 19:17:36 eric Release $
#
# Copyright (c) 1987 by Sun Microsystems, Inc.
#
# Modifications to the original Sun Microsystems, Inc. source code
# made by the Grasshopper Group are in the Public Domain.
#
# Extensions to this file by Eric Messick of the Grasshopper Group.
#
# Grasshopper Group
# 212 Clayton St
# San Francisco, CA 94117
#

SHELL=/bin/sh

# Global macro definitions
NEWSHOME=/usr/NeWS
INSDIR=${NEWSHOME}
BINDIR=${INSDIR}/bin
INCLUDE=${INSDIR}/include
LIBDIR=${INSDIR}/lib
MANDIR=/usr/man/manl
MANEXT=l

# --- Global macro definitions ---
OPT=-O
TARGET_ARCH=
OSI=REF
SYSV_NETWORK=
BYTES=
TERMFLAG=
SYSV_NETLIB=
TERMLIB=-ltermcap
PREPROC=-I. -I${INCLUDE} -D${OSI} -DUTMP ${TERMFLAG} ${SYSV_NETWORK}

COPTS= ${BYTES}
CPS= ${BINDIR}/cps
LIBCPS= ${LIBDIR}/libcps.a

CFLAGS=${OPT} ${COPTS} ${PREPROC}

# Too many lints -- pick your own lint flags.
#LINT=/usr/5bin/lint
LOPTS=-abch
#LOPTS=
LINTOPTS=${LOPTS} ${PREPROC}

LIBS=${TERMLIB} ${LIBCPS} ${SYSV_NETLIB}

# When adding files, also modify 'make shar' below.
SRCS = 	display.c \
	selection.c \
	io.c \
	main.c \
	slave.c \
	tcap_ops.c \
	tcap_parse.c \
	bsd.c \
	sys5.c

OBJS = 	display.o \
	selection.o \
	io.o \
	main.o \
	slave.o \
	tcap_ops.o \
	tcap_parse.o \
	bsd.o \
	sys5.o

HDRS = 	screen.h \
	tcap.h \
	termcap.h

SHAR1 =	README \
	BUGS \
	patchlevel.h \
	Makefile \
	psterm.1 \
	UsingPSTerm \
	bsd.c \
	screen.h
SHAR2 =	sampl.pstermrc \
	sampl.user.ps \
	psterm.tcap \
	psterm.tinfo \
	slave.c \
	io.c \
	main.c \
	display.c
SHAR3 =	ref/config_aux \
	ref/config_sunos \
	psterm.ps \
	selection.c \
	sys5.c
SHAR4 = tcap.cps \
	tcap_ops.c \
	tcap_parse.c \
	termcap.h

all:	psterm

lint:	tcap.h
	${LINT} ${LINTOPTS} ${SRCS} | grep -v _CPS

psterm:	${OBJS}
	${CC} ${CFLAGS} -o psterm ${OBJS} ${LIBS}

tcap.h: tcap.cps

install: psterm psterm.ps
	rm -f ${BINDIR}/psterm ${LIBDIR}/psterm.ps
	cp psterm ${BINDIR}
	cp psterm.ps ${LIBDIR}/psterm.ps
	cp psterm.1 ${MANDIR}/psterm.${MANEXT}

clean:
	rm -f *.o psterm tcap tcap.h *.BAK *~

shar:
	echo ": psterm part 1 of 4" > psterm.shar.1
	shar ${SHAR1}    >> psterm.shar.1
	echo ": psterm part 2 of 4" > psterm.shar.2
	shar ${SHAR2}    >> psterm.shar.2
	echo ": psterm part 3 of 4" > psterm.shar.3
	echo "echo ref"  >> psterm.shar.3
	echo "mkdir ref" >> psterm.shar.3
	shar ${SHAR3}    >> psterm.shar.3
	echo ": psterm part 4 of 4" > psterm.shar.4
	shar ${SHAR4}    >> psterm.shar.4

depend: ${HDRS} ${SRCS}
	${INSDIR}/clientsrc/makedepend ". -I${INCLUDE}"

.SUFFIXES: .h .cps
.cps.h:
	${CPS} $*.cps

# START OF AUTOMATICALLY GENERATED DEPENDENCIES 
bsd.o: bsd.c
display.o: display.c screen.h tcap.h
io.o: io.c
main.o: main.c
selection.o: screen.h selection.c tcap.h
slave.o: slave.c
sys5.o: sys5.c
tcap_ops.o: screen.h tcap.h tcap_ops.c termcap.h
tcap_parse.o: tcap_parse.c termcap.h
@@@ Fin de Makefile
echo psterm.1
cat >psterm.1 <<'@@@ Fin de psterm.1'
.\" @(#)psterm.1 9.2 88/01/19 Copyright 1987 Sun Micro
.\" @(#)$Header: psterm.1,v 2.3 88/10/04 05:59:48 gnu Release $
.TH PSTERM 1  "28 July 1988"
.SH NAME
psterm \(em NeWS terminal emulator
.SH SYNOPSIS
.B psterm
[
options
]
[
command
]
.IX psterm#(1) "" "\fLpsterm\fP(1) \(em NeWS terminal emulator"
.SH DESCRIPTION
.I psterm
is a
.IR termcap -based
terminal emulator program for NeWS.  When invoked,  it reads the
.I /etc/termcap
entry for the terminal named
.I psterm
or the termcap named by the
.B -t
option, and arranges to emulate the behavior of that
terminal.  It forks an instance of
.I command
(or, by default,  the program specified by the
.B SHELL
environment variable, or
.I csh 
if this is undefined),
routing keyboard input to the program and displaying its output.
.LP
It responds to (most of) the particular escape sequences that
.I termcap
defines for that terminal.
.SH OPTIONS
.TP
.B \-bg
causes
.I psterm
to place itself in the background by
disassociating itself from the parent process and the controlling terminal.
If
.I psterm
is invoked with
.IR rsh (1),
this option will cause the
rsh command to complete immediately, rather than hang around until
.I psterm
exits.
This is the default if
.I psterm
is invoked with
.I stdin
not connected to a
.I tty.
.TP
.B \-C
route
.I /dev/console
messages to this window, if supported by the operating system.
.TP
.B \-co "\fIcolumns\fP
specifies the width of the window in characters.
.TP
.B \-F font
overrides the default terminal font.
.TP
.B \-f
Ignored.  For compatibility with older versions.
.TP
.B \-fg
forces 
.I psterm
not to fork, thus leaving you in the forground.
.TP
.B \-fl "\fIframe label\fP"
Use the specified string for the frame label.
.TP
.B \-fs fontsize
overrides the default terminal font point size.
.TP
.B \-ic
forces 
.I psterm
to come up iconic instead of as an open window.
.TP
.B \-il "\fIicon label\fP"
Use the specified string for the icon label.  The icon label normally defaults
to the name of the host on which
.I psterm
is running.
.TP
.B \-ixy x y
sets the initial icon location.
Similar to 
.B \-xy x y.
.TP
.B \-li "\fIlines\fP"
specifies the height of the window in characters.
.TP
.B \-ls
causes
.I psterm
to invoke the shell as a login shell.  In addition, any
specified
.I command
will be passed to the shell with a
.B \-c
option,
rather than being invoked directly, so that the shell can establish any
environment variables that may be needed by the command.  Further, if
.I psterm
is invoked via
.IR rsh (1),
the host at the other end of the
.I rsh
socket will be used as the server, unless a NEWSSERVER
environment variable is present.
.TP
.B \-pm
specifies that a 
.I psterm
should enable 
.IR "page mode" .
When page mode is enabled and a command produces
more lines of output that can fit on the screen at once,
.I psterm
will stop scrolling, hide the cursor, and wait until the
user types a character before resuming output.  
When 
.I psterm
is blocked with a screenfull of data,
typing a carriage return or space will cause
scrolling to proceed by one line or one screenful, respectively; any other
character will cause the next screenfull
to appear and be passed through as normal
input.  
This mode can also be enabled or disabled interactively, using the
.I "Page Mode"
menu item.
.TP
.B \-r
forces 
.I psterm
to reload the 
.I psterm.rc
file and the
.I .pstermrc
file.
Normally, 
.I psterm
checks and if the dictionary
.B PSTermDict
exists in 
.B systemdict,
it does not bother reloading the
.I PostScript
files.
.TP
.B \-sl savelines
specify the length of the scroll region.
Defaults to 0, which turns scrollbars off.
.TP
.B \-t term
specify a particular terminal type to override the
.B TERM
environment variable.
Some types work well, others do not.
The terminal type ``psterm'' was designed specifically for use with
.I psterm,
and works quite well.
.TP
.B \-ui userinit
.I psterm
will execute 
.I userinit
as a
.I PostScript
function before creating the terminal window.
This allows the overriding of terminal characteristics on an
individual window basis.
The only function currently defined for this purpose is
.I \-ui StretchOpen
which requests a sizing box on window creation instead of a fixed size window.
See the example
.I \.pstermrc
file for more code that can be called from here.
.TP
.B \-w
wait around after the
.I command
terminates.
.TP
.B \-xy "\fIx y\fP"
specifies the location of the lower left hand corner of the
window (in screen pixel coordinates).

.SH "SELECTION"
.LP
Clicking the left mouse button over a character selects that character.
Dragging the mouse extends the selection.
Clicking or dragging beyond the end of the line
selects the newline at the end of that line.
Clicking the middle mouse button over a character
when a selection does not exist in that window
selects that character.
Clicking the middle mouse button over a character
when a selection does exist in that window
extends or shrinks the selection to that character.
Dragging the mouse still extends the selection.
.LP
Clicking and dragging with a shift key down selects a
.I rectangle
of text, padded with spaces if necessary.
.LP
The Copy key (L6) copies the 
selection to the
.IR shelf .
The Paste key (L8) copies the contents of the
.I shelf
to the
.I "insertion point".
.LP
Copy and Paste of selections
works across separate invocations of
.I psterm.
They do not work between
.I psterm
and SunView.
However, a mechanism does exist for transferring a SunView
selection to the \*(Sd shelf, and vice versa. See the description
of 
.I Selection Transfer
in 
.IR news_server (1).
.SH "MENU ITEMS"
.I psterm
creates a client menu with entries to
.I stuff
the current selection to the insertion point,
get at the normal
.I frame
menu, and get at a
.I config
menu for changing some parameters of a running 
.I psterm.
Under the
.I config
menu, are other sub-menus changing various parameters.
.LP
Config... Lines x Cols...  This menu sets the terminal size to the
indicated number of lines and columns.  By default, this will change
the window size to fit.
.LP
Config... Points...  This menu sets the font point size.  By default,
this will change the window size to fit.
.LP
Config... Fonts...  This menu sets the terminal font to one of the
standard fixed width fonts.  This is likely to change the size of the
characters, and behaves as thought the font size had been changed.
Note that /Screen font (the default) only scales to a few
predetermined sizes.  Selecting a new point size is likely to have no
effect until a fully scalable font is selected.  Several other fonts
exibit this behavior.  See More Fonts!... below.
.LP
Config... More Fonts!...  This menu lists all fonts known to the
system at the time the psterm was started.  Note that some of these
are likely to be silly.  The width of the letter ``m'' in the font is
used to determine the spacing between characters.  Some fonts have no
``m'' character.  See Config... Toggles... Var Width Fonts below.
.LP
Config... Resizing stuff...  This menu is strange.  Under it are three
pairs of toggles.  These toggles control the behavior of psterm when
one of three parameters is changed.  Basically, there are three
parameters used to determine the way the terminal is displayed, and
they are all interdependant.  The three parameters are Font Size,
Lines/Cols, and Window Size.  Fixing values for any two of these
determines the third value.  When you change one of these parameters,
psterm consults this menu to determine which of the other two
parameters should stay the same, and which should change.  The
parameter with the ``*'' next to it will be the one which changes.
Select the menu entry for the unstarred parameter to cause it to
become the new starred parameter.  Remember that you choose among
three independant pairs of values.  Now, go play.
.LP
Config... Save Lines...  This menu selects the number of lines saved.
If you select a value other than zero, a scrollbar will appear
allowing you to scroll through the saved region.  Selecting zero will
remove the scrollbar.  Saving a large number of lines takes a lot of
memory, and possibly several seconds to set up.
.LP
Config... Toggles...  This menu controls the on/off state of several
items.  Select the item to toggle it.  If there is an ``*'' next to an
item, it is on now, and selecting it will turn it off.  The first item
is Page Mode.  See the -pm option above.  The second item is Auto
Margins.  The initial state of this item is determined from the
termcap entry for the terminal being emulated.  If Auto Margins is on,
when the terminal's cursor is in the rightmost column and another
character needs to be displayed, a newline will automatically be
inserted.  If Auto Margins is off, the cursor will ``stick'' to the
right of the window.  The third item is Var Width Fonts, and defaults
to on.  This item is only of importance if the current font is not a
fixed width font.  Basically, if it is off, all fonts are forced to be
fixed width.  With Var Width Fonts on, normal output will be more
readable under a variable width font, like /Times-Roman, but columns
of text will not line up properly, and cursor motion and selection of
text can produce wierd effects.  This should be fun to play with.
The fourth item is Fast Repaint, defaulting to on.  If you turn it off,
then every repaint will be seen, even if another is already in progress.
The fifth item is Scrolling Allowed, defaulting to on.  This is here
in case your server can repaint faster than it can do a copyarea.
On a Silicon Graphics, you might want to turn this off by default.
Just set DefaultUseCopyArea to false in your .pstermrc file.
.LP
Config... Set Labels...  This menu allows you to set the value of the
frame label, the icon label, or both.  Label values are set to the contents
of the current selection.  You can also set the frame label to a string
indicating what version of psterm you are running.
.SH FILES
.PD 0
.TP 1.5i
.I /etc/termcap
to find the terminal description.
.TP
.IB /usr/NeWS/lib/psterm.ps
containing most of the PostScript code.
.TP
.IB ~/.pstermrc
to customize the terminal on startup.
.PD
.SH "SEE ALSO"
.IR news_server (1)
.LP
.I "NeWS Manual"
.SH BUGS
.LP
A bug in liteUI causes keyboard events to be distributed to the wrong
place.
This may cause characters that you type to not go to the terminal that
your mouse pointer is inside of.  To redirect the keyboard properly,
move the mouse out of the window, and back in.
This is often necessary when initially starting
.I psterm.
.LP
Another obscure bug in liteUI can cause NeWS to think that your shift
key is permanently stuck down.  It is triggered by holding the shift
key down, and clicking on the mouse while dragging it across canvas
boundries as you might while making rectangular selections.
If this happens, you will have to exit NeWS to reset it.
As an emergency measure, it is suggested that you have an alias
in your .cshrc file to set the
.I lcase
tty parameter.
.LP
alias STTY stty lcase
.LP
will work for this.
.LP
Emulating some terminal types works better than others, largely because
there are incomplete
.I /etc/termcap
entries for them.
.LP
A large number of
.I termcap
fields have yet to be implemented.
.LP
.I "Page Mode"
gets easily confused.
.LP
See the BUGS and README files distributed with the source.

@@@ Fin de psterm.1
echo UsingPSTerm
cat >UsingPSTerm <<'@@@ Fin de UsingPSTerm'


				UsingPSTerm

		A user guide for the new psterm program

				by Eric Messick

 @(#)$Header: UsingPSTerm,v 2.1 88/10/03 18:17:14 eric Release $

	Starting psterm.

If you're using psterm, chances are quite good that you are in NeWS.
This probably means that the directory /usr/NeWS/bin has found its way
into your $PATH.  If not, it's time it migrated in there, because
that's the directory where you'll find the psterm binary.  Just
starting psterm from the shell (your command interpreter) will get you
a reasonable set of default starting conditions.  With no command line
options, the following things will happen:

	psterm will look at various portions of your environment and
will question your tty driver and build up a picture of what your
current terminal type is and how big it is.

	psterm will then try to talk to your news_server.  Hopefully,
it will succeed.

	psterm next opens a window on your screen.  This window will
have its lower left corner in the lower left corner of your screen.
Text in the window will be presented in 12 point /Screen font by
default.  The window will be sized so that precisely the proper number
of rows and columns of text appear inside the window borders.

	A shell is then started, and the shell's prompt should appear
in the terminal window.

	Moving the NeWS cursor into the terminal window will allow you
to type to the shell.

	Typing the ``exit'' command into the window's shell will cause
the window to go away.


Now, let's take a look at the command line options that are available
to change the behavior of psterm.  If you enter an illegal option on
the command line, psterm will print a usage line that looks something
like this:

Usage: psterm [-bg] [-C] [-co columns] [-F font] [-f] [-fg] [-fl framelabel] \
        [-fs fontsize] [-ic] [-il iconlabel] [-ixy x y] [-li lines] \
        [-ls] [-pm] [-r] [-sl savelines] [-t termtype] [-ui userinit] [-w] \
        [-xy x y] [command]

As you can see, psterm has quite a few options.  Let's take a closer
look at them.

-bg	Forces psterm to fork, even when not connected to a tty.
		Normally, psterm will not bother to fork unless
		connected to a tty.

-C	Redirects the console output to the psterm window.  Note:
		this does not work under A/UX.

-co columns
	Overrides the termcap entry and tty driver for deciding how
		many columns the emulated terminal has.

-F font	Overrides the default terminal font.

-f	Ignored.  For compatability with older versions.

-fg	Forces psterm not to fork, thus leaving you in the forground.
		Normally, psterm will fork if its stdin is connected
		to a tty, and not bother otherwise.

-fl framelabel
	Sets the frame label.  Default is either the host name if -ls
		is specified, or a string indicating the terminal
		type.

-fs fontsize
	Overrides the default terminal font point size.

-ic	Forces psterm to come up iconic instead of as an open window.

-il iconlabel
	Sets the icon label.  Default is the host name.

-ixy x y
	Sets the position of the icon.  Similar to -xy x y.

-li lines
	Similar to -co.

-ls	Creates a login shell instead of a normal shell.  Sets a few
		environment variables and executes your .login file.

-pm	Turns on page mode.  Causes psterm to stop output when a full
		page has been displayed since the last input.  Space
		and return are munched when output is stopped and any
		character continues output.

-r	Forces psterm to reload the psterm.ps file and the .pstermrc
		file.  Normally, psterm checks and if the dictionary
		PSTermDict exists in systemdict, it does not bother
		reloading the PostScript files.  If you make a change
		in psterm.ps or your .pstermrc, you will probably have
		to use this option to get your changes to be loaded.

-sl savelines
	Specifies the number of lines to save in memory.  If this is
		non-zero, a scrollbar will appear, allowing you to
		scroll through the saved lines.

-t termtype
	Overrides the environment variable $TERM in specifying what
		kind of terminal psterm will emulate.  psterm looks in
		the file /etc/termcap to find a description of the
		terminal that it is trying to emulate, and does that
		the best that it can.  Some types work well, others do
		not.  The terminal type ``psterm'' was designed
		specifically for use with psterm, and works perfectly.

-ui userinit
	psterm will execute userinit as a PostScript function before
		creating the terminal window.  This allows the
		overriding of terminal characteristics on an
		individual window basis.  The only function currently
		defined for this purpose is -ui StretchOpen which
		requests a sizing box on window creation instead of a
		fixed size window.  See the example .pstermrc file for
		more code that can be called from here.

-w	wait around after the shell exits before deleting the window.

-xy x y	Sets the lower left corner of the window position.


Following the other command line options, you can specify a command
and arguments to be executed in lieu of your shell.




	Starting psterm from a Menu

The default root menu has entries for starting a psterm.  These just
consist of a string of options on a command line that is sent to the
forkunix NeWS function.  NeWS forks a process to execute the psterm,
and redirects its stdin stdout and stderr, generally to /dev/null.
When psterm sees that it has been started this way, it doesn't bother
to fork itself (see -fg and -bg, above).  You can create your own menu
entries to do this in your .litewin.rc file.  See the example files.



	Starting a psterm on a Remote Machine

Ok, let's get some terms streight.  You're sitting in front of a
screen connected to a computer.  That computer is your local system.
Programs run there are run locally.  Your computer is connected to a
network that has other machines hooked up to it.  You want to run a
psterm on one of those machines.  The other machine is the remote
machine, and the psterm running on the remote machine is the remote
psterm.  Your news_server is running on your local machine.  Ok?

If psterm is started on a remote system, it will do it's best to find
the news_server that it was started from and connect to it.  This
gives you a transparent way to access other machines.  There are a few
things that may confuse or thwart it in its efforts for you.  You
should be aware of these if you have a computer network.  First, you
need to know that under SysV the remote execution command is called
remsh, while under other systems it is called rsh.  Next, you should
be sure that you have your .rhosts file set up correctly so that you
can start remote programs on the remote machine in the first place.
Once your local system has connected to the remote system, it needs to
be able to get to the psterm program.  Does it exist on the remote
system?  Will the path set in your .cshrc file find the right binary?
Does the remote system use a different binary format than your local
one?  If so, you may need a way to change your $PATH in a way that
depends on which remote system you are starting the psterm on.  You
also need to make certain that the terminal type that you've asked for
exists in the remote machine's /etc/termcap file (setting your
$TERMCAP variable in your .cshrc file could take care of this also).
If your local machine is running multiple news_servers, a remote
psterm may have trouble determining which one you are on.  Currently,
it picks the first one.  Once it figures out which news_server it
wants to talk to, you need to make sure that the news_server is
willing to talk back.  You have to either get the remote host into the
list of hosts that your local server will talk to, or set
/NetSecurityWanted to false in you .litewin.rc.  See the example
files.



	Getting Around in psterm

Ok, you've started your psterm.  Now what?  Well, you can type into
your shell, and get responses back out, but you knew that already.
Remember that the cursor has to be in the window that you are typing
into (unless you have set click to type).  But let's find out what
other nifty things you can do.

When using the mouse, what matters is where you click it.  Let's talk
about the different places that you can click on.

First, there's the ``frame''.  It's the border just outside of where
the window text actually goes.  It looks like the frame around a
picture.  The frame holds three things.  Most importantly, it holds
the terminal canvas, which is where the window text goes.  This area
is big and obvious -- right in the center, with a border line going
all the way around it.  Next, there's the close gadget.  It's in the
upper left hand corner of the frame, and it looks like two arrows
pointing at each other.  Finally, there's the stretch gadget.  It's in
the lower right hand corner of the frame.  If your frame borders are
very narrow, you may not be able to see the stretch gadget (it looks
like part of an arrow facing down and to the right), but it is still
there and you can still hit it with the mouse, although you will have
to be very accurate with your mouse placement.

Ok, so what happens when we click on these things?  Well, that depends
on what mouse button you use.  Unless you've changed them, the three
mouse buttons, called the PointButton, AdjustButton, and MenuButton,
will be set to the LeftMouseButton, MiddleMouseButton, and
RightMouseButton, respectively.  On the Mac, the LeftMouseButon means
that you have to hold down the ``option'' key when you press the mouse
button.  Likewise, the MiddleMouseButton on the Mac is generated by
holding down the ``point of interest'' key (it looks like a clover,
and is just to the right of the option key) when clicking on the
mouse.  So, on the Mac, PointButton means option, AdjustButton means
point of interest, and MenuButton means normal.  Got that?

The close gadget and stretch gadget have special behavior on the Mac.
You can use any of the mouse buttons on them to activate them.  On the
Sun, use the PointButton.  Clicking on the close gadget turns the
window into an icon.  The icon will be a tiny copy of the screen that
you're displaying on the full size window.  Each character in the icon
will be represented by a single pixel (actually, a 1pt by 1pt square).
You can still type into the window (if the cursor is inside the icon),
and you will be able to see the response (although reading it is
likely to be difficult).  The MenuButton will bring up the icon's
menu, which is standard.  The AdjustButton will drag the icon around
the screen, also standard. Finally, the PointButton turns the icon
back into a window, also standard.

Now that you're back with a window again, what does the stretch gadget
do?  Clicking down on the stretch gadget allows you to ``pick up'' the
lower right hand corner of the window and stretch it around.  When
you're done playing, and release the mouse button, the window will
resize itself to fit inside of the rectangle you specified.
Generally, this will mean changing the number of rows and columns in
the window.  Whenever this happens, psterm makes sure that your tty
driver finds out about this, so that smart programs can repaint
themselves to the new size.  Note that many programs won't be able to
deal with this very well.  That's about it for the gadgets.

Let's turn to the frame itself next.  The PointButton clicked in the
frame will bring the window to the front of the screen.  Handy.  The
AdjustButton lets you drag the window around.  The MenuButton brings
up the standard frame menu.  There.  That wasn't so hard.

Now for the terminal canvas itself.  The PointButton and the
AdjustButton work together here to allow you to select pieces of text
that appear on the window.  The PointButton always starts a new
selection, while the AdjustButton extends the current selection, or
starts a new one if there isn't a selection going on right now.
That's the only difference between them.  Now, how do they work?  More
clicking and dragging here, folks.  Push and hold the PointButton and
a new selection is started.  What you have selected so far will have a
line drawn around it.  Dragging the mouse around changes the size of
the text selected.  When you release the mouse, the selection area
stops changing in response to your mouse movements.  After the
selection has been reported to the server, its hilighting is changed
to reverse video.  If one of the ends of your selection is not quite
what you want, use the AdjustButton to adjust it.  Just click down and
drag the mouse to the spot you want.  It's quite easy when you get
used to it.

So, what do you use the selected text for?  Here we come to using the
MenuButton in the terminal canvas.  It brings up the terminal menu.
There are three entries in the terminal menu.  The first is ``Stuff''.
Stuff takes whatever text is selected and stuffs it into your
terminal.  Basically, it pretends to type it for you.  It doesn't
matter which window you've selected text in, stuff can find it.  It's
real easy to grab some text in one window and move it to another with
stuff.  Once you've made a selection, it remains the current selection
even if it's not on the screen anymore.  Neat stuff.

The second entry in the terminal menu is ``Frame...''  Under here is a
copy of the standard frame menu.

The third entry in the terminal menu is ``Config...''  Here things get
fun.  Each of the submenus under Config... also has a submenu.  We
will deal with them individually.

Config... Lines x Cols...  This menu sets the terminal size to the
indicated number of lines and columns.  By default, this will change
the window size to fit.

Config... Points...  This menu sets the font point size.  By default,
this will change the window size to fit.

Config... Fonts...  This menu sets the terminal font to one of the
standard fixed width fonts.  This is likely to change the size of the
characters, and behaves as thought the font size had been changed.
Note that /Screen font (the default) only scales to a few
predetermined sizes.  Selecting a new point size is likely to have no
effect until a fully scalable font is selected.  Several other fonts
exibit this behavior.  See More Fonts!... below.

Config... More Fonts!...  This menu lists all fonts known to the
system at the time the psterm was started.  Note that some of these
are likely to be silly.  The width of the letter ``m'' in the font is
used to determine the spacing between characters.  Some fonts have no
``m'' character.  See Config... Toggles... Var Width Fonts below.

Config... Resizing stuff...  This menu is strange.  Under it are three
pairs of toggles.  These toggles control the behavior of psterm when
one of three parameters is changed.  Basically, there are three
parameters used to determine the way the terminal is displayed, and
they are all interdependant.  The three parameters are Font Size,
Lines/Cols, and Window Size.  Fixing values for any two of these
determines the third value.  When you change one of these parameters,
psterm consults this menu to determine which of the other two
parameters should stay the same, and which should change.  The
parameter with the ``*'' next to it will be the one which changes.
Select the menu entry for the unstarred parameter to cause it to
become the new starred parameter.  Remember that you choose among
three independant pairs of values.  Now, go play.

Config... Save Lines...  This menu selects the number of lines saved.
If you select a value other than zero, a scrollbar will appear
allowing you to scroll through the saved region.  Selecting zero will
remove the scrollbar.  Saving a large number of lines takes a lot of
memory, and possibly several seconds to set up.

Config... Toggles...  This menu controls the on/off state of several
items.  Select the item to toggle it.  If there is an ``*'' next to an
item, it is on now, and selecting it will turn it off.  The first item
is Page Mode.  See the -pm option above.  The second item is Auto
Margins.  The initial state of this item is determined from the
termcap entry for the terminal being emulated.  If Auto Margins is on,
when the terminal's cursor is in the rightmost column and another
character needs to be displayed, a newline will automatically be
inserted.  If Auto Margins is off, the cursor will ``stick'' to the
right of the window.  The third item is Var Width Fonts, and defaults
to on.  This item is only of importance if the current font is not a
fixed width font.  Basically, if it is off, all fonts are forced to be
fixed width.  With Var Width Fonts on, normal output will be more
readable under a variable width font, like /Times-Roman, but columns
of text will not line up properly, and cursor motion and selection of
text can produce wierd effects.  This should be fun to play with.
The fourth item is Fast Repaint, defaulting to on.  If you turn it off,
then every repaint will be seen, even if another is already in progress.
The fifth item is Scrolling Allowed, defaulting to on.  This is here
in case your server can repaint faster than it can do a copyarea.
On a Silicon Graphics, you might want to turn this off by default.
Just set DefaultUseCopyArea to false in your .pstermrc file.

Config... Set Labels...  This menu allows you to set the value of the
frame label, the icon label, or both.  Label values are set to the contents
of the current selection.  You can also set the frame label to a string
indicating what version of psterm you are running.


Well, we've wound our way all the way through the menu tree, and that
completes what you can do with the mouse in psterm.  Getting around in
psterm can be quite amusing... have fun.



	Customizing psterm

It's easy to feed new PostScript code to psterm.  Just put the code
inside a file in your home directory called ``.pstermrc''.  psterm
will automatically load the contents of this file whenever it starts
up freshly (or you specify -r).  You can use this to override defaults
for all of your terminal sessions, or to set up custom code to be run
only for certain sessions (via the -ui userinit option).  See the
example .pstermrc files and the top of psterm.ps for more information.
@@@ Fin de UsingPSTerm
echo bsd.c
cat >bsd.c <<'@@@ Fin de bsd.c'
/*
 * This file is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.
 * Users may copy, modify or distribute this file at will.
 * 
 * THIS FILE IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * This file is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY THIS FILE
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even
 * if Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
 *
 * Modifications to the original Sun Microsystems, Inc. source code
 * made by the Grasshopper Group are in the Public Domain.
 *
 * Extensions to this file by Eric Messick of the Grasshopper Group.
 *
 * Grasshopper Group
 * 212 Clayton St
 * San Francisco, CA 94117
 *
 */

#ifdef REF
#include <ref/config.h>
#endif

#ifndef lint
static  char sccsid[] = "@(#)bsd.c 9.5 88/01/19 SMI";
static	char RCSid[] = "@(#)$Header: bsd.c,v 2.2 88/10/04 05:11:14 eric Release $";
#endif

/*
 * Copyright (c) 1987 by Sun Microsystems, Inc.
 */

#ifdef HAVE_BSD_TTYS
/*
 * BSD Support Routines.
 */
#include <sys/types.h>
#include <sgtty.h>
#include <sys/file.h>
#include <signal.h>
#include <stdio.h>

extern void perror();
#ifndef bzero
extern void bzero();
#endif
extern char *strncpy();
extern long time();
extern long lseek();

/* Tty mode statics */
static	struct tchars tc;
static	struct ltchars ltc;
static	struct sgttyb sg;
static	int lm;			/* localmodes */
static	int ld;			/* ldisc */

/* Default settings for tty mode stuff */
static	struct tchars tc_df =
    { CINTR, CQUIT, CSTART, CSTOP, CEOF, CBRK };
static	struct ltchars ltc_df =
    { CSUSP, CDSUSP, CRPRNT, CFLUSH, CWERASE, CLNEXT };
static	struct sgttyb sg_df =
    { B9600, B9600, CERASE, CKILL, ANYP|ECHO|CRMOD };
static	int lm_df = LCRTBS|LCRTERA|LCRTKIL|LCTLECH;
static	int ld_df = NTTYDISC;

extern	int console;
extern	int CharsPerLine;
extern	int LinesPerScreen;

static void get_tty_util();

GetTTYDefaults()
{
    int fd;

    /* Get settings of controlling terminal */
    fd = open("/dev/tty", O_RDWR);
    get_tty_util(fd);
    if (fd > 0)
	close(fd);
#ifdef sun
    /*
     * Modify setting with data passed thru the environment.
     * Read environment variable WINDOW_TTYPARMS
     */
    if(we_getptyparms(&ld, &lm, &sg, &tc, &ltc) == -1) {
	/*
	 * Try to get the tty parameters from stderr (2).
	 * Using stdin (0) fails when being started in the background
	 *   because csh redirects stdin from the tty to /dev/null.
	 */
	fd = 2;
	if (!isatty(fd)) {
	    fd = open("/dev/console", 2);
	}
	get_tty_util(fd);
	if (fd != 2)
	    (void) close(fd);
   }
#endif
}

static void
get_tty_util(fd)
    int fd;
{
    if (fd > 0) {
	if(ioctl(fd, TIOCGETP, &sg) == 0 || (sg.sg_flags&ECHO) == 0)
	    sg = sg_df;
	(void) ioctl(fd, TIOCGETC, &tc);
	if (tc.t_quitc == 0)
	    tc = tc_df;
	(void) ioctl(fd, TIOCGETD, &ld);
	if (ld == 0)
	    ld = ld_df;
	(void) ioctl(fd, TIOCLGET, &lm);
	if (lm == 0)
	    lm = lm_df;
	(void) ioctl(fd, TIOCGLTC, &ltc);
	if (ltc.t_suspc == 0)
	    ltc = ltc_df;
	(void) ioctl(fd, TIOCNOTTY, 0);
    } else {
	/* Last resort...use some default values */
	tc = tc_df;
	ld = ld_df;
	lm = lm_df;
	ltc = ltc_df;
	sg = sg_df;
    }
}

SetTTYState(fd)
    int fd;
{
    (void) ioctl(fd, TIOCHPCL, 0);
    (void) ioctl(fd, TIOCSETD, &ld);
    if ((sg.sg_flags & ECHO) == 0)
	sg = sg_df;
    (void) ioctl(fd, TIOCSETP, &sg);
    (void) ioctl(fd, TIOCSETC, &tc);
    (void) ioctl(fd, TIOCSLTC, &ltc);
    (void) ioctl(fd, TIOCLSET, &lm);
#ifdef TIOCSWINSZ
    { struct winsize ws;
      ws.ws_row = LinesPerScreen; ws.ws_col = CharsPerLine;
      (void) ioctl(fd, TIOCSWINSZ, &ws);
    }
#endif
#ifdef TIOCSSIZE
    { struct ttysize ts;
      ts.ts_lines = LinesPerScreen; ts.ts_cols = CharsPerLine;
      (void) ioctl(fd, TIOCSSIZE, &ts);
    }
#endif
    if (console) {
#ifdef TIOCCONS
	if (ioctl(fd, TIOCCONS, 0) < 0)
	    perror("tcap(TIOCCONS)");
#endif
    }
}

DisAssociateTTY()
{
    int fd;

    if (( fd = open("/dev/tty", O_RDWR)) >= 0) {
	ioctl(fd, TIOCNOTTY, 0);
	close(fd);
    }
}

AssociateTTY()
{

}

/*ARGSUSED*/
SetupControllingTTY(line)
   char line[];
{
    int fd, pid;

    if ((fd = open("/dev/tty", O_RDWR)) < 0) {
	(void) setpgrp(0, 0);
	(void) close(open(line, O_RDWR));
    } else {
	close(fd);
    }
    (void) setpgrp(0, pid = getpid());
    (void) ioctl(0, TIOCSPGRP, &pid);
}

#include <utmp.h>
#include <pwd.h>

#define SCPYN(a, b)	strncpy(a, b, sizeof(a))
#define SCMPN(a, b)	strncmp(a, b, sizeof(a))

static	char utmpf[] = "/etc/utmp";
static	char wtmpf[] = "/usr/adm/wtmp";
static	int tslot = -1;
static	struct utmp utmp;

addut(uid, line)
    int uid;
    char line[];
{
#ifdef UTMP
    struct passwd *pw;
    int i;

    /*
     * Record entry in /etc/utmp if possible.
     */
    tslot = ttyslot();
    pw = getpwuid(uid);
    if (tslot > 0 && pw && (i = open(utmpf, O_RDWR)) >= 0) {
	char *cp, *p, *getenv(), *index();

	bzero((char *)&utmp, sizeof (utmp));
	SCPYN(utmp.ut_line, &line[5]);
	SCPYN(utmp.ut_name, pw->pw_name);
	if ((cp = getenv("NEWSSERVER")) == NULL)
	    cp = "";
	if ((p = index(cp, ';')) && p[1] != '\0')
	    cp = p+1;
	SCPYN(utmp.ut_host, cp);
	(void) time(&utmp.ut_time);
	(void) lseek(i, (long)(tslot * sizeof (utmp)), L_SET);
	(void) write(i, (char *)&utmp, sizeof (utmp));
	(void) close(i);
	if ((i = open(wtmpf, O_WRONLY|O_APPEND)) >= 0) {
		write(i, (char *)&utmp, sizeof(utmp));
		close(i);
	}
    }
#endif
}

rmut()
{
#ifdef UTMP
    int fd;
    struct utmp wtmp;

    if (tslot >= 0 && (fd = open(utmpf, O_WRONLY)) >= 0) {
	wtmp = utmp;
	bzero((char *)&utmp, sizeof (utmp));
	(void) lseek(fd, (long)(tslot * sizeof (utmp)), L_SET);
	(void) write(fd, (char *)&utmp, sizeof (utmp));
	(void) close(fd);
	fd = open(wtmpf, O_WRONLY|O_APPEND);
	if (fd >= 0) {
	    SCPYN(wtmp.ut_name, "");
	    SCPYN(wtmp.ut_host, "");
	    time(&wtmp.ut_time);
	    write(fd, (char *)&wtmp, sizeof(wtmp));
	    close(fd);
	}
    }
#endif
}
#endif /* !HAVE_BSD_TTYS */

#ifdef sun
#define	WE_TTYPARMS	"WINDOW_TTYPARMS"

/*
 * Get tty settings from environment.
 */
int
we_getptyparms(ldisc, localmodes, mode, tchars, ltchars)
	int *ldisc, *localmodes;
	struct sgttyb *mode;
	struct tchars *tchars;
	struct ltchars *ltchars;
{
	char *str, *getenv();
	short temps[16];	/* Needed for sscanf as there is no %hhd */

	if((str = getenv(WE_TTYPARMS)) == NULL) {
		return (-1);
	} else {
		if (sscanf(str,
  "%ld,%ld,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd",
		    ldisc, localmodes, &temps[0], &temps[1], &temps[2],
		    &temps[3], &mode->sg_flags, &temps[4], &temps[5], &temps[6],
		    &temps[7], &temps[8], &temps[9], &temps[10], &temps[11],
		    &temps[12], &temps[13], &temps[14], &temps[15])
		     != 19)
			return (-1);
		    mode->sg_ispeed = temps[0];
		    mode->sg_ospeed = temps[1];
		    mode->sg_erase = temps[2];
		    mode->sg_kill = temps[3];
		    tchars->t_intrc = temps[4];
		    tchars->t_quitc = temps[5];
		    tchars->t_startc = temps[6];
		    tchars->t_stopc = temps[7];
		    tchars->t_eofc = temps[8];
		    tchars->t_brkc = temps[9];
		    ltchars->t_suspc = temps[10];
		    ltchars->t_dsuspc = temps[11];
		    ltchars->t_rprntc = temps[12];
		    ltchars->t_flushc = temps[13];
		    ltchars->t_werasc = temps[14];
		    ltchars->t_lnextc = temps[15];
		/*
		 * Always clear
		 */
		(void)unsetenv(WE_TTYPARMS);
		return (0);
	}
}
#endif	/* of !HAVE_BST_TTYS */

@@@ Fin de bsd.c
echo screen.h
cat >screen.h <<'@@@ Fin de screen.h'
/*
 * This file is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.
 * Users may copy, modify or distribute this file at will.
 * 
 * THIS FILE IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * This file is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY THIS FILE
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even
 * if Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
 *
 * Modifications to the original Sun Microsystems, Inc. source code
 * made by the Grasshopper Group are in the Public Domain.
 *
 * Extensions to this file by Eric Messick of the Grasshopper Group.
 *
 * Grasshopper Group
 * 212 Clayton St
 * San Francisco, CA 94117
 *
 */

/*
 * "@(#)screen.h 9.4 88/01/19
 * "@(#)$Header: screen.h,v 2.1 88/10/04 05:59:52 gnu Release $
 *
 * Copyright (c) 1985 by Sun Microsystems, Inc.
 */



struct line {
    u_short	length;		/* chars zero through length are meaningful */
    u_short	buffer_length;	/* body has this many chars allocated */
    u_short	changeposition;	/* we've scribbled on stuff right of this pos */
    u_short	end_of_changes;	/* we haven't scribbled past this point */
    int		usedtobe;	/* this line was scrolled from line usedtobe */
    int		flags;		/* attributes of this line */
    char *	body;		/* chars to display */
    u_char *	prop;		/* how to display them (attributes) */
};

/* values for flags */
#define LINE_WRAPPED	1	/* newline at end of line caused by autowrap */

struct line **screen, **lines;

struct pair {
    short	x, y;
};

struct range {
    struct pair	first, last_plus_one;
};

/*
 * Values for struct line -> prop
 */
#define	InsertMode	0x0100
#define AutoMarginMode	0x0200
#define IgnoreNewlineAfterWrapMode 0x0400
#define WrapJustHappenedMode	0x0800
#define	ReverseVideoMode	0x0001
#define	UnderlineMode	0x0002
#define	BoldMode	0x0004
#define	BlinkMode	0x0008
#define StandOutMode	ReverseVideoMode
#define	Attributes	(ReverseVideoMode|UnderlineMode|BoldMode|BlinkMode)

#define PrimSelMode	0x0010
#define SecnSelMode	0x0020
#define ReverseVideoLook	(ReverseVideoMode|PrimSelMode)
#define UnderlineLook		(UnderlineMode|SecnSelMode)
#define MaxCharsPerLine	2048
#define MaxLinesPerScreen 2048

#define bugprintf(fmt, a1, a2, a3) \
	{ \
		char errors[1024]; \
		\
		sprintf(errors, fmt, a1, a2, a3); \
		PopMsg(errors); \
		FlushPostScript(); \
	}
@@@ Fin de screen.h
exit 0

