Subject:  v16i066:  Turn 4.2BSD lint into a prototype generator
Newsgroups: comp.sources.unix,comp.lang.c,comp.lang.c++
Followup-To: comp.sources.d
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: leech@cs.unc.edu
Posting-number: Volume 16, Issue 66
Archive-name: lint-proto.pch

[  This is a set of patches to the 4.2BSD lint sources.  It can be
   merged into the 4.3 or a SunOS sources by hand (they're not that
   extensive) and probably an ATT Unix also, although I've not tried that.
   --r$  ]

	The following shar file contains patches to 4.2 BSD 'lint'
to create a prototype generator. The modified BSD source is
included as context diffs to (hopefully) get around copyright problems.
	Thanks!
	Jon Leech (leech@cs.unc.edu)
	__@/
#!/bin/sh
# shar:	Shell Archiver
#	Run the following text with /bin/sh to create:
#	README
#	print.c
#	proto
#	proto.1
#	Makefile.diff
#	lint.c.diff
#	lmanifest.h.diff
echo shar: extracting README '(2658 characters)'
cat << \SHAR_EOF > README


	PROTO - C prototype generator for BSD


DESCRIPTION

    These files contain changes to 4.2 BSD lint to create a prototype
generator. This was done by modifying lint pass 1. Normally lint
creates an intermediate file in pass 1 including information on the
types and parameters of functions in its input files. This
intermediate file is read by lint pass 2 and used to check intermodule
calls (among other purposes).

    The prototype generator changes the portions of lint pass 1 where
the intermediate file is generated, gathering information on functions
and printing it in prototype format (actually there are 3 possible
output formats - see the man page for 'proto'). Warning messages
generated by pass 1 have not all been suppressed; this is a cosmetic
issue as the warnings are directed to standard error. The changes to
lint pass 1 have been #ifdef'ed so that either the old or new versions
may be created from the same source with appropriate flags to the C
preprocessor.

    The generator consists of a frontend shell script, 'proto', and
the modified lint pass 1, called 'proto1' by analogy to the two lint
passes. The shell script gathers C preprocessor arguments and runs cpp
over any input files, passing the result to proto1.

INSTALLATION

    Since source to BSD may not be distributed, proto is supplied in
the form of context diffs (diff -c) to the changed files, and several
added files. The patches to Makefile, lint.c, and lmanifest.h must be
made, then print.c, proto, and proto.1 placed in your lint source
directory. The files in this archive are:

    README	     - this file
    Makefile.diff    - context diffs to Makefile
    lint.c.diff      - context diffs to lint.c
    lmanifest.h.diff - context diffs to lmanifest.h
    print.c	     - new functions to print out prototypes
    proto	     - shell script frontend
    proto.1	     - man page

    Proto was generated from 4.2 BSD VAX source to lint.  It may also
be compiled on Sun-3 and -4 workstations, with the proviso that, if
the file /usr/include/pcc.h and the source directories for the
portable C compiler are not in the expected places, the Makefile must
be modified to reflect this (change the make variables M, P, and
PCCH).

    The 'install' target in Makefile has been modified to install
proto and proto1 as well as the previous lint binaries. This has not
been tested, however. The man page 'proto.1' should be installed in
/usr/man by hand. Note that the man page should be run through 'tbl'
before installation.

    Please direct a copy of enhancements, bug fixes, etc. to the
author.

    Enjoy!

    Jon Leech (leech@cs.unc.edu)
    10/23/88
    __@/
SHAR_EOF
echo shar: extracting print.c '(7335 characters)'
cat << \SHAR_EOF > print.c
/* print.c - C-style output functions for lint pass 1
 *
 *			   COPYRIGHT NOTICE
 *
 * Copyright 1988 Jonathan P. Leech
 *
 * Permission is granted to reproduce and distribute this
 *  software by any means so long as this notice is always retained
 *  in the copies and so long as no fee is charged for copying.
 *
 * All other rights are reserved except as explicitly granted
 *  by written permission of the author.
 *
 */
#include <stdio.h>
#include <ctype.h>
#include "pass1.h"
#include "lmanifest.h"

extern char *malloc();
char *atype_name(),
     *type_name(),
     *flag_name(),
     *Arg[MAX_ARG] = { NULL };
int   ArgLine = -1;
extern int FuncMode, PrintVars;

rec_print(rec, size, d, s)
union rec *rec;
{
    int i;

    switch (rec->l.decflag) {
	case LST:    /* static */
	case LDI:    /* initialized */
	case LIB:    /* library */
	case LDC:    /* global */
	case LDX:    /* global: if ! pflag, same as LDI     */
	    {
		char *tname = atype_name(&rec->l.type, d, s, rec->l.name);

		/* Store function name for later use by func_decl() */
		if (ISFTN(rec->l.type.aty)) {
		    if (!(Arg[0] = malloc(strlen(tname) + 10))) {
			fprintf(stderr, "out of memory in rec_print()\n");
			exit(1);
		    }
		    if (rec->l.decflag == LST)
			sprintf(Arg[0], "static %s", tname);
		    else
			strcpy(Arg[0], tname);
		    /* Save line on which function was defined */
		    ArgLine = rec->l.fline;
		} else if (PrintVars) {
		    /* Variable, just print its declaration */
		    if (rec->l.decflag == LST)
			printf("static ");

		    fputs(tname, stdout);
		    fputs(";\n", stdout);
		}
	    }
	    break;
	case LFN:   /* library name */
	case LRV:   /* function returning a value */
	case LUV:   /* function/value context */
	case LUE:   /* function/effects context */
	case LUM:   /* mentioned somewhere other than at the declaration */
	default:    /* combinations of flags, don't seem to happen */
	    break;
    }
}

#define NTYPE 40
/* Get a string from the static pool (will not be reused for NTYPE calls) */
char *buf_next() {
    /* Allow up to NTYPE different strings */
    static char buf[NTYPE][100];
    static int	bufptr = 0;

    char *tmp = buf[bufptr];
    bufptr = (bufptr + 1) % NTYPE;
    *tmp = '\0';
    return tmp;
}

/* Print a type t in canonical (C) format
 *  d & s are the dimoff & sizoff members from the corresponding
 *  symbol table entry for the type member.
 */
char *type_name(t, d, s, var_name, struct_name)
TWORD t;	    /* Type in PCC internal form */
int   d,	    /* symtab->dimoff */
      s;	    /* symtab->sizoff */
char *var_name;     /* Name of variable of this type (usually '%s' for printf) */
char *struct_name;  /* Name of structure/union/enum(?) of base type */
{
    static char *tnames[] = {
	"undef",
	"farg",
	"char",
	"short",
	"int",
	"long",
	"float",
	"double",
	"struct",
	"union",
	"enum",
	"moety",    /* member of enum. type? */
	"unsigned char",
	"unsigned short",
	"unsigned",
	"unsigned long",
	"?", "?"
    };
    char *buf = buf_next(),
	 *altbuf = buf_next(),
	 *this = buf,
	 *next;
    int   i, sptr = 0, stack[100];  /* Stack of type modifiers for type t */
#define VOID 0200   /* See "pcclocal.h"; this should not clash */

    /* Stack type modifiers up for easy access */
    do {
	if (ISPTR(t))
	    stack[sptr++] = PTR;
	else if (ISFTN(t))
	    stack[sptr++] = FTN;
	else if (ISARY(t))
	    stack[sptr++] = ARY;
	else {
	/* Watch out for void modifiers, no base type (?) */
	    stack[sptr++] = t;
	    break;
	}
    } while ((t = DECREF(t)));

    /* If no base type is supplied, must be a void (heuristic) */
    if (sptr && (stack[sptr-1] == PTR ||
		 stack[sptr-1] == FTN ||
		 stack[sptr-1] == ARY))
	stack[sptr++] = VOID;

    /* Nonsense type on stack to indicate an identifier */
    stack[sptr] = 0;

    /* Initialize buffer with variable name */
    strcpy(this, var_name);

    if (struct_name == NULL)
	struct_name = "<Unknown tag>";

    /* For each layer of type, wrap the C-style declaration
     *	of the type around it.
     */
    for (i = 0; i < sptr; i++) {
	/* Where to build next buffer */
	next = (this == buf) ? altbuf : buf;
	switch (stack[i]) {
	    case PTR:
		/*	*(*x)	-> **x
		 *	(*x)[]	-> (*x)[]
		 *	(*x)()	-> (*x)()
		 */
		if (stack[i+1] == FTN || stack[i+1] == ARY) {
		    strcpy(next, "(*");
		    strcat(next, this);
		    strcat(next, ")");
		} else {
		    strcpy(next, "*");
		    strcat(next, this);
		}
		break;
	    case FTN:
		/*	*(x())	-> *x()
		 *	(x())[] -> x()[]    // illegal
		 *	(x())() -> x()()    // illegal
		 */
		strcpy(next, this);
		strcat(next, "()");
		break;
	    case ARY:
		/*	*(x[])	-> *x[]
		 *	(x[])[] -> x[][]
		 *	(x[])() -> x[]())   // illegal
		 */
		if (dimtab[d]) {
		    sprintf(next, "%s[%d]", this, dimtab[d]);
		} else {
		    /* Unknown dimension */
		    strcpy(next, this);
		    strcat(next, "[]");
		}
		d++;
		break;
	    case STRTY:
		sprintf(next, "struct %s %s", struct_name, this);
		break;
	    case UNIONTY:
		sprintf(next, "union %s %s", struct_name, this);
		break;
	    case ENUMTY:
		sprintf(next, "enum %s %s", struct_name, this);
		break;
	    case MOETY:
		sprintf(next, "(enum member ?%s?) %s", struct_name, this);
		break;
	    case VOID:
		sprintf(next, "void %s", this);
		break;
	    default:
		/* Scalar type */
		if (this[0] != '\0')
		    sprintf(next, "%s %s", tnames[t], this);
		else
		    strcpy(next, tnames[t]);
		break;
	}
	/* Swap buffers */
	this = next;
    }

    /* Return the formed type string */
    return next;
}

/* Routine to form symbolic name of a type.
 *  t - type
 *  d - dimoff from symbol table
 *  s - sizoff from symbol table
 *  varname - variable name to generate (can use "" for none)
 */
char *atype_name(t, d, s, varname)
ATYPE *t;
int    d, s;
char  *varname;
{
    char *ptr = buf_next();

    /* Size of type is in t->extra, if it's nonzero */
    strcpy(ptr, type_name(t->aty, d, s, varname, t->extra1));

    return ptr;
}

/* Return a new copy of a string */
char *str_copy(s)
char *s;
{
    char *t = malloc(strlen(s) + 1);

    if (!t) {
	fprintf(stderr, "Out of memory in print.c:str_copy()\n");
	exit(1);
    }

    strcpy(t, s);
    return t;
}

/* Print out a function declaration using information on function
 *  arguments stored away earlier in parsing.
 * Comment out arguments in the prototype if Comment is true.
 */
void func_decl(nargs)
int nargs;
{
    int i;
    char *fname = Arg[0];

    /* Write function name */
    if (!fname)
	fname = "<Unknown function>";
    else
	fname[strlen(fname)-2] = '\0';	/* Dispose of trailing () */

    switch (FuncMode) {
	case OLD_C:
	    printf("%s(/* ", fname);
	    break;
	case MIXED:
	    printf("DECL(%s,(", fname);
	    break;
	case C_PLUSPLUS:
	    printf("%s(", fname);
	    break;
    }

    if (Arg[0] != NULL) {
	free(Arg[0]);		/* Free it */
	Arg[0] = NULL;		/* Mark empty slot for future calls */
    }

    /* Write out each argument type & free associated space */
    /* Note argument indices are 1-based */

    for (i = 1; i <= nargs; i++) {
	fputs(Arg[i], stdout);
	free(Arg[i]);
	if (i < nargs) {
	    fputs(", ", stdout);
	}
    }

    switch (FuncMode) {
	case OLD_C:
	    fputs(" */);\n", stdout);
	    break;
	case MIXED:
	    fputs("));\n", stdout);
	    break;
	case C_PLUSPLUS:
	    fputs(");\n", stdout);
	    break;
    }
}
SHAR_EOF
echo shar: extracting proto '(420 characters)'
cat << \SHAR_EOF > proto
#! /bin/sh
#
#  proto.sh - frontend for prototype generator
#  collects CPP arguments and preprocesses source files before
#   running proto1 over them.

proto=proto1
propts=
cppopts=
for opt in $* ; do
    case $opt in
    -[IDU]*)
	    cppopts="$cppopts $opt"
	    ;;
    -*)     propts="$propts $opt"
	    ;;
    *)	    echo 1>&2 "$opt:"
	    /lib/cpp $cppopts $opt | $proto $propts 2>/dev/null
	    ;;
    esac
done
SHAR_EOF
echo shar: extracting proto.1 '(2585 characters)'
cat << \SHAR_EOF > proto.1
.\"% tbl proto.1 | nroff -man | less
.de Fs
.sp
.in +0.5i
.nf
.ft CW
..
.de Fe
.ft P
.fi
.in -0.5i
.sp
..
.TH PROTO 1 "October 23 1988"
.SH NAME
proto - generate function prototypes from C source
.SH SYNOPSIS
\fBproto\fP [ -m[c+M] -V ]
.br
.SH DESCRIPTION
\fIproto\fP is a modified version of Berkeley lint. It reads C source
files and prints a declaration of all functions and (optionally)
global variables defined therein. Function declarations are in the form of
prototypes which may be used in C++ or an ANSI C compiler.
.LP
The \fB-m\fP option controls the style in which prototypes are printed.
There are three possibilities: old-C style (\fB-mc\fP), C++ style
(\fB-m+\fP), or mixed style (\fB-mM\fP). The default is C++ style.
.LP
Given as input a function defined as follows:
.Fs
int f(i, d) int i; double d; { return d + i; }
.Fe
the output of \fIproto\fP for each style will be:
.sp
.in +0.5i
.TS
tab(@);
l l
l l
lb l.
Style@Form of \fIproto\fP output
_@_
-mc@int f(/* int i, double d */);
-m+@int f(int i, double d);
-mM@DECL(int f,(int i, double d));
.TE
.in -0.5i
.sp
.LP
Output produced in old-C style is legal input to a C compiler which
does not understand prototypes. The prototype information is commented
out. Output in C++ style is legal input to C++ or a C compiler
which does understand prototypes.
Output in mixed style generates a definition of the macro DECL,
such that the function prototype for f will appear in old-C or C++ style
when the output of \fIproto\fP is read by the corresponding compiler.
This relies on the macro \fBc_plusplus\fP being defined by a C++
compiler, as does the AT&T C++ compiler \fIcfront\fP.
.LP
Normally, declarations for variables are not generated by \fIproto\fP.
This may be overridden with the -V flag.
.LP
When a \fBtypedef\fP appears, the 'typedef name' of the type is
not propagated through \fIproto\fP. Instead, the equivalent
complex type appears in the output. For example, the following
input:
.Fs
typedef char *STRING;
STRING str_copy(s) STRING s; { return s; }
.Fe
generates the output:
.Fs
char *str_copy(char *s);
.Fe
If a \fBstruct\fP, \fBunion\fP, or \fBenum\fP is \fBtypedef\fP'ed
without a tag, \fIproto\fP will be unable to determine the
correct output form for a variable of or function returning that type.
.SH AUTHOR
Modifications to Berkeley lint by Jon Leech (leech@cs.unc.edu).
.SH BUGS
Someone with sufficient knowledge of PCC and lint could probably fix
\fIproto\fP to generate typedef names instead of the corresponding
type. This is the most annoying problem at present.
.SH SEE ALSO
cc(1), lint(1)
SHAR_EOF
echo shar: extracting Makefile.diff '(4215 characters)'
cat << \SHAR_EOF > Makefile.diff
diff -bc ./Makefile 4.2_lint/Makefile
*** ./Makefile	Sun Oct 23 17:39:59 1988
--- 4.2_lint/Makefile	Sat Mar 29 16:23:07 1986
***************
*** 3,22 ****
  #
  M=/usr/src/lib/mip
  P=/usr/src/lib/pcc
! # PCCH = /usr/include/pcc.h on BSD systems with this file.
! # Otherwise it must be copied from such a system.
! PCCH=pcc.h
! CFLAGS=-O -I$M -I.
  LINTLIBS=llib-port.ln llib-lc.ln llib-lcurses.ln llib-ldbm.ln llib-lm.ln \
	llib-lmp.ln llib-lplot.ln llib-ltermcap.ln
  SRCS= $M/cgram.y $M/common.c $M/optim.c $M/pftn.c $M/scan.c $M/trees.c \
	$M/xdefs.c lint.c hash.c $M/pass1.h $M/manifest.h macdefs.h \
	lpass2.c
- # Object files for prototype generation
- POBJS= cgram.o rodata.o comm1.o optim.o pftn.o scan.o trees.o xdefs.o \
-	 lint_proto.o hash.o print.o

! all:	lpass1 lpass2 proto1 $(LINTLIBS)

  lpass1: cgram.o rodata.o comm1.o optim.o pftn.o scan.o trees.o xdefs.o \
	lint.o hash.o
--- 3,16 ----
  #
  M=/usr/src/lib/mip
  P=/usr/src/lib/pcc
! CFLAGS=-O
  LINTLIBS=llib-port.ln llib-lc.ln llib-lcurses.ln llib-ldbm.ln llib-lm.ln \
	llib-lmp.ln llib-lplot.ln llib-ltermcap.ln
  SRCS= $M/cgram.y $M/common.c $M/optim.c $M/pftn.c $M/scan.c $M/trees.c \
	$M/xdefs.c lint.c hash.c $M/pass1.h $M/manifest.h macdefs.h \
	lpass2.c

! all:	lpass1 lpass2 ${LINTLIBS}

  lpass1: cgram.o rodata.o comm1.o optim.o pftn.o scan.o trees.o xdefs.o \
	lint.o hash.o
***************
*** 23,32 ****
	${CC} ${CFLAGS} cgram.o rodata.o comm1.o optim.o pftn.o scan.o \
		trees.o xdefs.o lint.o hash.o -o lpass1

- # Proto is much like lpass1, but must recompile lint.c with -DPROTO
- proto1: $(POBJS)
-	${CC} ${CFLAGS} $(POBJS) -o proto1
-
  cgram.o: $M/manifest.h $M/pass1.h pcclocal.h macdefs.h cgram.c
	$(CC) -c $(CFLAGS) -I$M -I. cgram.c

--- 17,22 ----
***************
*** 34,40 ****
	$(CC) -c $(CFLAGS) -R rodata.c

  comm1.o: $M/manifest.h $M/pass1.h pcclocal.h $M/common.c macdefs.h
!	ln -s $M/common.c comm1.c
	$(CC) -c $(CFLAGS) -I$M -I. -DPASS1COMMON comm1.c
	rm -f comm1.c

--- 24,30 ----
	$(CC) -c $(CFLAGS) -R rodata.c

  comm1.o: $M/manifest.h $M/pass1.h pcclocal.h $M/common.c macdefs.h
!	ln $M/common.c comm1.c
	$(CC) -c $(CFLAGS) -I$M -I. -DPASS1COMMON comm1.c
	rm -f comm1.c

***************
*** 62,89 ****

  GREP= egrep

! pcclocal.h: $P/localdefs.h $(PCCH)
	rm -f pcclocal.h
!	cat $(PCCH) $P/localdefs.h | $(GREP) '^#[	]*(define[	][	]*PCC(F|T|TM|OM)?_|ifdef|ifndef|endif)' | sed -e 's/PCC[A-Z]*_//' > pcclocal.h

! pcctokens: $P/localdefs.h $(PCCH)
	rm -f pcctokens
!	cat $(PCCH) $P/localdefs.h | $(GREP) '^#[	]*define[	][	]*PCC_' | sed -e 's/^#[		]*define[	][	]*PCC_/%term	/' > pcctokens

  lint.o: $M/manifest.h macdefs.h $M/pass1.h lmanifest.h
	${CC} -c ${CFLAGS} -I$M -I. lint.c

- # lint_proto is a version of lint.c with alternate output methods enabled
- #   by defining PROTO.
- lint_proto.o: $M/manifest.h macdefs.h $M/pass1.h lmanifest.h lint.c
-	${CC} -c -DPROTO ${CFLAGS} lint_proto.c
-
- print.o: $M/pass1.h lmanifest.h
-	${CC} -c -DPROTO ${CFLAGS} print.c
-
- lint_proto.c:
-	ln -s lint.c lint_proto.c
-
  llib-port.ln: llib-port lpass1
	-(/lib/cpp -C -Dlint llib-port | ./lpass1 -puv > llib-port.ln )

--- 52,68 ----

  GREP= egrep

! pcclocal.h: $P/localdefs.h /usr/include/pcc.h
	rm -f pcclocal.h
!	cat /usr/include/pcc.h $P/localdefs.h | $(GREP) '^#[	]*(define[	][	]*PCC(F|T|TM|OM)?_|ifdef|ifndef|endif)' | sed -e 's/PCC[A-Z]*_//' > pcclocal.h

! pcctokens: $P/localdefs.h /usr/include/pcc.h
	rm -f pcctokens
!	cat /usr/include/pcc.h $P/localdefs.h | $(GREP) '^#[	]*define[	][	]*PCC_' | sed -e 's/^#[		]*define[	][	]*PCC_/%term	/' > pcctokens

  lint.o: $M/manifest.h macdefs.h $M/pass1.h lmanifest.h
	${CC} -c ${CFLAGS} -I$M -I. lint.c

  llib-port.ln: llib-port lpass1
	-(/lib/cpp -C -Dlint llib-port | ./lpass1 -puv > llib-port.ln )

***************
*** 121,128 ****
  install: all SHELL
	install -s lpass1 ${DESTDIR}/usr/lib/lint/lint1
	install -s lpass2 ${DESTDIR}/usr/lib/lint/lint2
-	install -s proto1 ${DESTDIR}/usr/lib/lint/proto1
-	install -c proto ${DESTDIR}/usr/lib/lint/proto
	for i in llib-*; do install -c -m 644 $$i ${DESTDIR}/usr/lib/lint; done
	-rm -f ${DESTDIR}/usr/lib/lint/llib-ltermlib*
	ln -s llib-ltermcap ${DESTDIR}/usr/lib/lint/llib-ltermlib
--- 100,105 ----
SHAR_EOF
echo shar: extracting lint.c.diff '(6691 characters)'
cat << \SHAR_EOF > lint.c.diff
diff -bc ./lint.c 4.2_lint/lint.c
*** ./lint.c	Tue Oct  4 20:37:13 1988
--- 4.2_lint/lint.c	Tue Nov 24 14:30:03 1987
***************
*** 39,48 ****
  int aflag = 0;	/* used to check precision of assignments */
  int zflag = 0;	/* no 'structure never defined' error */
  int Cflag = 0;	/* filter out certain output, for generating libraries */
- #ifdef PROTO
- int FuncMode = C_PLUSPLUS;  /* Comment out function argument types in prototypes */
- int PrintVars = 0;	    /* Whether to print out variable declarations */
- #endif	/* PROTO */
  char *libname = 0;  /* name of the library we're generating */

	/* flags for the "outdef" function */
--- 39,44 ----
***************
*** 57,66 ****
	short lid, flgs;
	}  lnames[LNAMES], *lnp;

- #ifdef PROTO
- char *X_NONAME = "<Unnamed struct/union>";
- #endif	/* PROTO */
-
  contx( p, down, pl, pr ) register NODE *p; register *pl, *pr; {

	*pl = *pr = VAL;
--- 53,58 ----
***************
*** 179,190 ****

  astype( t, i ) ATYPE *t; {
	TWORD tt;
!	int j, k=0;
! #ifndef PROTO
!	int l = 0;
! #else
!	char *l = NULL;
! #endif	/* PROTO */

	if( (tt=BTYPE(t->aty))==STRTY || tt==UNIONTY ){
		if( i<0 || i>= DIMTABSZ-3 ){
--- 171,177 ----

  astype( t, i ) ATYPE *t; {
	TWORD tt;
!	int j, k=0, l=0;

	if( (tt=BTYPE(t->aty))==STRTY || tt==UNIONTY ){
		if( i<0 || i>= DIMTABSZ-3 ){
***************
*** 194,204 ****
			j = dimtab[i+3];
			if( j<0 || j>SYMTSZ ){
				k = dimtab[i];
- #ifndef PROTO
				l = X_NONAME | stab[j].suse;
- #else
-				l = X_NONAME;
- #endif	/* PROTO */
				}
			else {
				if( stab[j].suse <= 0 ) {
--- 181,187 ----
***************
*** 211,239 ****
					}
				else {
					k = dimtab[i];
- #ifndef PROTO
  #ifdef FLEXNAMES
					l = hashstr(stab[j].sname);
  #else
					l = hashstr(stab[j].sname, LCHNM);
  #endif
- #else
-					l = stab[j].sname;
- #endif	/* PROTO */
					}
				}
			}

		t->extra = k;
- #ifndef PROTO
		t->extra1 = l;
- #else
- #ifdef FLEXNAMES
-		t->extra1 = l;
- #else
-		strncpy(t->extra1, l, LCHNM);
- #endif	/* FLEXNAMES */
- #endif	/* PROTO */
		return( 1 );
		}
	else return( 0 );
--- 194,210 ----
***************
*** 292,314 ****

					}
				}
! #ifndef PROTO
!			fwrite((char *)&t, sizeof(ATYPE), 1, stdout);
! #else /* PROTO */
!			/* Save argument i */
!			if (i < MAX_ARG-1)
!			    Arg[i+1] = str_copy(atype_name(&t, cfp->dimoff, cfp->sizoff, ""));
!			else
!			    fprintf(stderr, "Can't save argument %d\n", i);
! #endif
			}
		}
- #ifdef PROTO
-		/* Function name & all argument types are accumulated;
-		 *  generate prototype.
-		 */
-		func_decl(n);
- #endif	/* PROTO */
	}

  ctargs( p ) NODE *p; {
--- 263,271 ----

					}
				}
!			fwrite( (char *)&t, sizeof(ATYPE), 1, stdout );
			}
		}
	}

  ctargs( p ) NODE *p; {
***************
*** 362,377 ****
				break;
			}
		}
! #ifndef PROTO
!	fwrite((char *)&t, sizeof(ATYPE), 1, stdout);
! #else
!	/* This type of declaration is an internal function call,
!	 *  *not* a definition. Ignore it for prototype purposes.
!	 */
!	/*
!	printf("(lpta) %s\n", atype_name(&t, -1, -1, ""));
!	 */
! #endif
	}

  # define VALSET 1
--- 319,325 ----
				break;
			}
		}
!	fwrite( (char *)&t, sizeof(ATYPE), 1, stdout );
	}

  # define VALSET 1
***************
*** 885,905 ****
		fsname.f.fn = s;
  #endif
		fsname.f.decflag = LFN;
- #ifndef PROTO
		fwrite( (char *)&fsname, sizeof(fsname), 1, stdout );
- #else
-		rec_print(&fsname, sizeof(fsname), -1, -1);
- #endif	/* PROTO */
  #ifdef FLEXNAMES
		/* if generating a library, prefix with the library name */
		/* only do this for flexnames */
- #ifndef PROTO
		if( libname ){
!		    fwrite(libname, strlen(libname), 1, stdout);
!		    putchar(':');
		}
!		fwrite((char *)&fsname.f.fn, strlen(fsname.f.fn)+1, 1, stdout);
! #endif	/* PROTO */
  #endif
		}
	}
--- 833,847 ----
		fsname.f.fn = s;
  #endif
		fsname.f.decflag = LFN;
		fwrite( (char *)&fsname, sizeof(fsname), 1, stdout );
  #ifdef FLEXNAMES
		/* if generating a library, prefix with the library name */
		/* only do this for flexnames */
		if( libname ){
!			fwrite( libname, strlen(libname), 1, stdout );
!			putchar( ':' );
			}
!		fwrite( fsname.f.fn, strlen(fsname.f.fn)+1, 1, stdout );
  #endif
		}
	}
***************
*** 1436,1475 ****
				while( p[1] ) p++;
				continue;

- #ifdef PROTO
-			/* Set function prototype output mode.
-			 * Options are:
-			 *  -mc     old-c compatible (comment arguments)
-			 *  -m+     C++ compatible (no comments)
-			 *  -mM     mixed mode, selectable with #define
-			 */
-			case 'm':
-			    switch (p[1]) {
-				case 'c':
-				case 'C':
-				    FuncMode = OLD_C;
-				    break;
-				case '+':
-				    FuncMode = C_PLUSPLUS;
-				    break;
-				case 'm':
-				case 'M':
-				    FuncMode = MIXED;
-				    break;
				default:
-				    fprintf(stderr, "%s: Unknown option %s (-mc, -m+, -mm allowed)\n",
-					argv[0], p);
-				    exit(1);
-			    }
-			    continue;
-
-			case 'V':
-				PrintVars = 1;
-				continue;
-
- #endif	/* PROTO */
-
-			default:
				uerror( "illegal option: %c", *p );
				continue;

--- 1378,1384 ----
***************
*** 1476,1501 ****
				}
			}

- #ifdef PROTO
-	/* Print out a header for mixed-mode prototypes */
-	if (FuncMode == MIXED) {
-	    int i;
-	    static char *def_decl[] = {
-		"#ifndef DECL",
-		"#ifdef c_plusplus",
-		"#define DECL(func,args) func args",
-		"#else",
-		"#define DECL(func,args) func()",
-		"#endif\t/* c_plusplus */",
-		"#endif\t/* DECL */",
-	    };
-
-	    for (i = 0; i < sizeof(def_decl) / sizeof(char *); i++)
-		puts(def_decl[i]);
-
-	}
- #endif	/* PROTO */
-
	if( !pflag ){  /* set sizes to sizes of target machine */
  # ifdef gcos
		SZCHAR = ALCHAR = 9;
--- 1385,1390 ----
***************
*** 1597,1605 ****
		}
	fsave( fname );
  #ifndef FLEXNAMES
!	strncpy( rc.l.name, p->sname, LCHNM );
! #else
!	rc.l.name = p->sname;
  #endif
	rc.l.decflag = lty;
	t = p->stype;
--- 1486,1492 ----
		}
	fsave( fname );
  #ifndef FLEXNAMES
!	strncpy( rc.l.name, exname(p->sname), LCHNM );
  #endif
	rc.l.decflag = lty;
	t = p->stype;
***************
*** 1610,1623 ****
	astype( &rc.l.type, p->sizoff );
	rc.l.nargs = (mode>USUAL) ? mode : 0;
	rc.l.fline = line;
- #ifndef PROTO
	fwrite( (char *)&rc, sizeof(rc), 1, stdout );
  #ifdef FLEXNAMES
!	fwrite((char *)&rc.l.name, strlen(rc.l.name)+1, 1, stdout);
  #endif
- #else
-	rec_print(&rc, sizeof(rc), p->dimoff, p->sizoff);
- #endif	/* PROTO */
	}
  int proflg;
  int gdebug;
--- 1497,1507 ----
	astype( &rc.l.type, p->sizoff );
	rc.l.nargs = (mode>USUAL) ? mode : 0;
	rc.l.fline = line;
	fwrite( (char *)&rc, sizeof(rc), 1, stdout );
  #ifdef FLEXNAMES
!	rc.l.name = exname(p->sname);
!	fwrite( rc.l.name, strlen(rc.l.name)+1, 1, stdout );
  #endif
	}
  int proflg;
  int gdebug;
SHAR_EOF
echo shar: extracting lmanifest.h.diff '(1072 characters)'
cat << \SHAR_EOF > lmanifest.h.diff
diff -bc ./lmanifest.h 4.2_lint/lmanifest.h
*** ./lmanifest.h	Mon Oct 10 00:45:59 1988
--- 4.2_lint/lmanifest.h	Fri Apr  5 19:40:13 1985
***************
*** 33,54 ****
  typedef struct ty {
	TWORD aty;
	short extra;
- #ifndef PROTO
	short extra1;
- #else
- #ifndef FLEXNAMES
-	char extra1[LCHNM];
- #else
-	char *extra1;
- #endif	/* FLEXNAMES */
- #endif	/* PROTO */
	} ATYPE;

- #ifndef PROTO
  #define X_NONAME 0x8000		/* for extra1, if structure has no name */
- #else
- extern char *X_NONAME;	    /* for extra1, if structure has no name */
- #endif	/* PROTO */

  typedef struct line {
	short decflag;
--- 33,42 ----
***************
*** 73,91 ****
  #endif
		} f;
	};
-
- #ifdef PROTO
- /* Maximum # of arguments to a function. Arg 0 is function name */
- #define MAX_ARG 21
- extern
- char *Arg[MAX_ARG],	/* Function argument types in symbolic form */
-      *X_NONAME,
-      *atype_name(),
-      *str_copy();
-
- /* Possible function prototype output modes. */
- #define OLD_C    0
- #define C_PLUSPLUS 1
- #define MIXED    2
-
- #endif	/* PROTO */
--- 61,63 ----
SHAR_EOF
#	End of shell archive
exit 0


