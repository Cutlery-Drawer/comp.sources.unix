Path: uunet!bbn.com!rsalz
From: rsalz@uunet.uu.net (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v16i016:  Public lineprinter spooler package, Part03/16
Message-ID: <1069@fig.bbn.com>
Date: 14 Sep 88 20:14:44 GMT
Lines: 1745
Approved: rsalz@uunet.UU.NET

Submitted-by: papowell@julius.cs.umn.edu
Posting-number: Volume 16, Issue 16
Archive-name: plp/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 16)."
# Contents:  Copyright LICENSE doc/PLP/LICENSE filters/vdmp.c man/lpq.1
#   man/lprm.1 src/errormsg.c src/lprm.c src/remote_ops.c
#   src/sendmail.c src/setup_filter.c
# Wrapped by papowell@attila on Wed Aug 10 10:44:49 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Copyright' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Copyright'\"
else
echo shar: Extracting \"'Copyright'\" \(3940 characters\)
sed "s/^X//" >'Copyright' <<'END_OF_FILE'
Public Line Printer (PLP) Software License Agreement
X
Copyright 1988 (C) Patrick Powell
X
Patrick Powell,
Dept. of Computer Science,
University of Minnesota,
Minneapolis, Minnesota.
Wed Apr 13 14:53:36 CDT 1988
X
The PLP software is available for use, and may be copied and distributed.
Sale of the software without the explicit permission of the author
is forbidden.
X
X			COPYING POLICIES
X
X  1. You may copy and distribute verbatim copies of PLP Software source
code as you receive it, in any medium, provided that you conspicuously
and appropriately publish on each file a valid copyright notice such
as "Copyright (C) 1988 Patrick Powell", containing the year of
last change and name of copyright holder for the file in question;
keep intact the notices on all files that refer to this License
Agreement and to the absence of any warranty; and give any other
recipients of the PLP Software program a copy of this License Agreement
along with the program.  You may charge a distribution fee for the
physical act of transferring a copy.
X
X  2. You may modify your copy or copies of PLP Software source code or
any portion of it, and copy and distribute such modifications under
the terms of Paragraph 1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating
X    who last changed such files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish,
X    that in whole or in part contains or is a derivative of PLP Software
X    or any part thereof, to be licensed at no charge to all third
X    parties on terms identical to those contained in this License
X    Agreement (except that you may choose to grant more extensive
X    warranty protection to third parties, at your option).
X
X  3. You may not copy, sublicense, distribute or transfer PLP Software
except as expressly provided under this License Agreement.  Any attempt
otherwise to copy, sublicense, distribute or transfer PLP Software is void and
your rights to use PLP Software under this License agreement shall be
automatically terminated.  However, parties who have received computer
software programs from you with this License Agreement will not have
their licenses terminated so long as such parties remain in full compliance.
X
X  4. If you wish to incorporate parts of PLP Software into other programs
whose distribution conditions are different, write to the University of
Minnesota.  Donations are gratefully received.
X
X			   NO WARRANTY
X
X  BECAUSE PLP SOFTWARE IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY
NO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT
WHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC,
PATRICK POWELL AND/OR OTHER PARTIES PROVIDE PLP SOFTWARE "AS IS"
WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
XFITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY
AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PLP SOFTWARE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
SERVICING, REPAIR OR CORRECTION.
X
X IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL THE UNIVERSITY OF
MINNESOTA, PATRICK POWELL, AND/OR ANY OTHER PARTY WHO MAY
MODIFY AND REDISTRIBUTE PLP SOFTWARE AS PERMITTED ABOVE, BE LIABLE TO YOU
XFOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR OTHER
SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR A
XFAILURE OF THE PROGRAM TO OPERATE WITH PROGRAMS NOT DISTRIBUTED BY
XFREE SOFTWARE FOUNDATION, INC.) THE PROGRAM, EVEN IF YOU HAVE BEEN
ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY
OTHER PARTY.
X
X
Basically:
X	1. It's Free.
X	2. You can give it away.
X	3. If it bites you,  don't blame us!
X
Patrick Powell
END_OF_FILE
if test 3940 -ne `wc -c <'Copyright'`; then
    echo shar: \"'Copyright'\" unpacked with wrong size!
fi
# end of 'Copyright'
fi
if test -f 'LICENSE' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LICENSE'\"
else
echo shar: Extracting \"'LICENSE'\" \(3940 characters\)
sed "s/^X//" >'LICENSE' <<'END_OF_FILE'
Public Line Printer (PLP) Software License Agreement
X
Copyright 1988 (C) Patrick Powell
X
Patrick Powell,
Dept. of Computer Science,
University of Minnesota,
Minneapolis, Minnesota.
Wed Apr 13 14:53:36 CDT 1988
X
The PLP software is available for use, and may be copied and distributed.
Sale of the software without the explicit permission of the author
is forbidden.
X
X			COPYING POLICIES
X
X  1. You may copy and distribute verbatim copies of PLP Software source
code as you receive it, in any medium, provided that you conspicuously
and appropriately publish on each file a valid copyright notice such
as "Copyright (C) 1988 Patrick Powell", containing the year of
last change and name of copyright holder for the file in question;
keep intact the notices on all files that refer to this License
Agreement and to the absence of any warranty; and give any other
recipients of the PLP Software program a copy of this License Agreement
along with the program.  You may charge a distribution fee for the
physical act of transferring a copy.
X
X  2. You may modify your copy or copies of PLP Software source code or
any portion of it, and copy and distribute such modifications under
the terms of Paragraph 1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating
X    who last changed such files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish,
X    that in whole or in part contains or is a derivative of PLP Software
X    or any part thereof, to be licensed at no charge to all third
X    parties on terms identical to those contained in this License
X    Agreement (except that you may choose to grant more extensive
X    warranty protection to third parties, at your option).
X
X  3. You may not copy, sublicense, distribute or transfer PLP Software
except as expressly provided under this License Agreement.  Any attempt
otherwise to copy, sublicense, distribute or transfer PLP Software is void and
your rights to use PLP Software under this License agreement shall be
automatically terminated.  However, parties who have received computer
software programs from you with this License Agreement will not have
their licenses terminated so long as such parties remain in full compliance.
X
X  4. If you wish to incorporate parts of PLP Software into other programs
whose distribution conditions are different, write to the University of
Minnesota.  Donations are gratefully received.
X
X			   NO WARRANTY
X
X  BECAUSE PLP SOFTWARE IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY
NO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT
WHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC,
PATRICK POWELL AND/OR OTHER PARTIES PROVIDE PLP SOFTWARE "AS IS"
WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
XFITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY
AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PLP SOFTWARE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
SERVICING, REPAIR OR CORRECTION.
X
X IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL THE UNIVERSITY OF
MINNESOTA, PATRICK POWELL, AND/OR ANY OTHER PARTY WHO MAY
MODIFY AND REDISTRIBUTE PLP SOFTWARE AS PERMITTED ABOVE, BE LIABLE TO YOU
XFOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR OTHER
SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR A
XFAILURE OF THE PROGRAM TO OPERATE WITH PROGRAMS NOT DISTRIBUTED BY
XFREE SOFTWARE FOUNDATION, INC.) THE PROGRAM, EVEN IF YOU HAVE BEEN
ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY
OTHER PARTY.
X
X
Basically:
X	1. It's Free.
X	2. You can give it away.
X	3. If it bites you,  don't blame us!
X
Patrick Powell
END_OF_FILE
if test 3940 -ne `wc -c <'LICENSE'`; then
    echo shar: \"'LICENSE'\" unpacked with wrong size!
fi
# end of 'LICENSE'
fi
if test -f 'doc/PLP/LICENSE' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/PLP/LICENSE'\"
else
echo shar: Extracting \"'doc/PLP/LICENSE'\" \(3940 characters\)
sed "s/^X//" >'doc/PLP/LICENSE' <<'END_OF_FILE'
Public Line Printer (PLP) Software License Agreement
X
Copyright 1988 (C) Patrick Powell
X
Patrick Powell,
Dept. of Computer Science,
University of Minnesota,
Minneapolis, Minnesota.
Wed Apr 13 14:53:36 CDT 1988
X
The PLP software is available for use, and may be copied and distributed.
Sale of the software without the explicit permission of the author
is forbidden.
X
X			COPYING POLICIES
X
X  1. You may copy and distribute verbatim copies of PLP Software source
code as you receive it, in any medium, provided that you conspicuously
and appropriately publish on each file a valid copyright notice such
as "Copyright (C) 1988 Patrick Powell", containing the year of
last change and name of copyright holder for the file in question;
keep intact the notices on all files that refer to this License
Agreement and to the absence of any warranty; and give any other
recipients of the PLP Software program a copy of this License Agreement
along with the program.  You may charge a distribution fee for the
physical act of transferring a copy.
X
X  2. You may modify your copy or copies of PLP Software source code or
any portion of it, and copy and distribute such modifications under
the terms of Paragraph 1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating
X    who last changed such files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish,
X    that in whole or in part contains or is a derivative of PLP Software
X    or any part thereof, to be licensed at no charge to all third
X    parties on terms identical to those contained in this License
X    Agreement (except that you may choose to grant more extensive
X    warranty protection to third parties, at your option).
X
X  3. You may not copy, sublicense, distribute or transfer PLP Software
except as expressly provided under this License Agreement.  Any attempt
otherwise to copy, sublicense, distribute or transfer PLP Software is void and
your rights to use PLP Software under this License agreement shall be
automatically terminated.  However, parties who have received computer
software programs from you with this License Agreement will not have
their licenses terminated so long as such parties remain in full compliance.
X
X  4. If you wish to incorporate parts of PLP Software into other programs
whose distribution conditions are different, write to the University of
Minnesota.  Donations are gratefully received.
X
X			   NO WARRANTY
X
X  BECAUSE PLP SOFTWARE IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY
NO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT
WHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC,
PATRICK POWELL AND/OR OTHER PARTIES PROVIDE PLP SOFTWARE "AS IS"
WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
XFITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY
AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PLP SOFTWARE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
SERVICING, REPAIR OR CORRECTION.
X
X IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL THE UNIVERSITY OF
MINNESOTA, PATRICK POWELL, AND/OR ANY OTHER PARTY WHO MAY
MODIFY AND REDISTRIBUTE PLP SOFTWARE AS PERMITTED ABOVE, BE LIABLE TO YOU
XFOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR OTHER
SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR A
XFAILURE OF THE PROGRAM TO OPERATE WITH PROGRAMS NOT DISTRIBUTED BY
XFREE SOFTWARE FOUNDATION, INC.) THE PROGRAM, EVEN IF YOU HAVE BEEN
ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY
OTHER PARTY.
X
X
Basically:
X	1. It's Free.
X	2. You can give it away.
X	3. If it bites you,  don't blame us!
X
Patrick Powell
END_OF_FILE
if test 3940 -ne `wc -c <'doc/PLP/LICENSE'`; then
    echo shar: \"'doc/PLP/LICENSE'\" unpacked with wrong size!
fi
# end of 'doc/PLP/LICENSE'
fi
if test -f 'filters/vdmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'filters/vdmp.c'\"
else
echo shar: Extracting \"'filters/vdmp.c'\" \(4799 characters\)
sed "s/^X//" >'filters/vdmp.c' <<'END_OF_FILE'
X/***************************************************************************
X * U. Minnesota LPD Software * Copyright 1987, 1988, Patrick Powell
X ***************************************************************************
X * MODULE: vdmp.c
X ***************************************************************************
X * Revision History: Created (Well, sort of) Fri Mar  4 19:15:16 CST 1988
X * $Log:	vdmp.c,v $
X * Revision 2.1  88/05/09  10:12:17  papowell
X * *** empty log message ***
X * 
X ***************************************************************************/
X#ifndef lint
static char id_str1[] =
X	"$Header: vdmp.c,v 2.1 88/05/09 10:12:17 papowell Exp $ PLP Copyright 1988 Patrick Powell";
X#endif lint
X/*
X *  reads raster file created by cifplot or plot and dumps it onto the
X *  Varian or Versatec plotter.   Originally derived from the 1984
X *  Berkeley VLSI Tools Distribution.  Has been mangled horribly ever
X *  since.  This code has little redeeming social value.
X *
X *  Note that the number of bits per raster line is given by xwidth.
X *  If vdmp is invoked with -Zr flag, it runs in raw mode, and does not
X *  check for header.
X *  If vdmp is invoked with -Zw flag, it puts out a couple of lines
X *	at end, otherwise a page eject (FF).
X *  It is assumed that BLOCK, the numbers of bytes in the header,
X *  fits in BUFSIZE.
X */
X#include <stdio.h>
X#include <sys/vcmd.h>
X#include <sys/types.h>
X#include <sys/signal.h>
X
X#define IN	0	/* input fcd */
X#define OUT	1	/* output fcd */
X
X#define MAGIC_WORD	0xA5CF4DFA		/* hardwired to the VAX, no doubt */
char magic_string[4] = { 0xFA, 0x4D, 0xCF, 0xA5 };
X
X#define BLOCK		1024
X#define BUFSIZE		BLOCK*128
X
X
int	plotmd[] = { VPLOT };
int	prtmd[]	= { VPRINT };
X
char	buf[BUFSIZE];
int	lines;		/* number of scan lines */
X
int	raw;			/* 1 if -Zr, no check for header */
int	wide;			/* 1 if -Zw, terminate with couple of lines, else FF */
int	nscanbytes;		/* number of bytes per raster line. */
extern int xwidth;		/* width in pixcels */
extern int ylength;		/* number of raster lines per page. */
extern int npages;		/* number of billable pages */
extern int errorcode;		/* 1 = retry, 2 = give up */
extern char *zopts, *index();	/* -Z options to LPR */
X
int	timeout();
X#define	TIMEOUT	(5*60)		/* 5 minutes */
time_t	t, time();
X
filter()
X{
X	int n;
X	char *trailer;
X
X	if( xwidth <= 0 ){
X		fatal( "bad xwidth value %d", xwidth );
X	}
X	if( ylength <= 0 ){
X		fatal( "bad ylength value %d", ylength );
X	}
X	nscanbytes = xwidth / 8;
X	
X	/*
X	 * check for -Zrw (raw and wide flag);
X	 */
X	if( zopts && index( zopts, 'r' ) ){
X		raw = 1;
X	}
X	if( zopts && index( zopts, 'w' ) ){
X		wide = 1;
X	}
X	/*
X	 * check the start of the file for a Magic Word
X	 * if there is one, print the string in the header
X	 */
X
X	errorcode = 2;	/* no retry */
X
X	if( raw == 0 ){
X		(void)signal(SIGALRM, timeout);
X		if( (n = read(IN, buf, BLOCK)) < 0 ){
X			logerr_die( "read error from file" );
X		}
X
X		errorcode = 1;	/* retry on error */
X
X		if( n==BLOCK && bcmp( buf, magic_string, 4 ) == 0 ){
X			(void) alarm(TIMEOUT);
X			buf[BLOCK] = 0;
X			if( ioctl(OUT, VSETSTATE, prtmd) < 0 ){
X				logerr_die( "ioctl for print mode failed" );
X			}
X			write(OUT, buf+4, strlen(buf+4));
X			if( write(OUT, "\n", 1) != 1 ){
X				logerr_die( "write of header failed" );
X			}
X			(void)alarm(0);
X		} else if( lseek(IN, 0L, 0) ){
X			/* dump file not formatted */
X			logerr_die( "lseek failed" );
X		}
X	}
X
X	errorcode = 1;	/* retry on error */
X	n = putplot();
X	if( lines ){
X		++npages;
X	}
X
X	/* page feed */
X	(void)alarm(TIMEOUT);
X	if( ioctl(OUT, VSETSTATE, prtmd) < 0 ){
X		logerr_die( "ioctl failed" );
X	}
X	if (wide)
X		trailer = "\n\n\n\n\n";
X	else
X		trailer = "\f";
X	if( write( OUT, trailer, strlen(trailer) ) != strlen(trailer) ){
X		logerr_die( "trailer write failed" );
X	}
X	(void)alarm(0);
X}
X
putplot()
X{
X	int bytes, n;
X
X	bytes = 0;
X	(void)alarm(TIMEOUT);
X	if( ioctl(OUT, VSETSTATE, plotmd) < 0 ){
X		logerr_die( "ioctl to plot mode failed" );
X	}
X	(void)alarm(0);
X	while ((n = read(IN, buf, sizeof(buf))) > 0) {
X		(void)alarm(TIMEOUT);
X		if (write(OUT,buf, n) != n)
X			logerr_die( "write failed" );
X		(void)alarm(0);
X		bytes += n;
X		while( bytes >= nscanbytes ){
X			++lines;
X			if( lines >= ylength ){
X				++npages;
X				lines -= ylength;
X			}
X			bytes -= nscanbytes;
X		}
X	}
X	/*
X	 * Make sure we send complete raster lines.
X	 */
X	if (bytes > 0) {
X		n = nscanbytes - bytes;
X		if (n > 0){
X			bzero(buf, n);
X			(void)alarm(TIMEOUT);
X			if (write(OUT, buf, n) != n)
X				logerr_die( "write failed" );
X			(void)alarm(0);
X			bytes += n;
X		}
X		while( bytes >= nscanbytes ){
X			++lines;
X			if( lines >= ylength ){
X				++npages;
X				lines -= ylength;
X			}
X			bytes -= nscanbytes;
X		}
X	}
X}
X
X/*
X *	Die on timeout
X */
timeout()
X    {
X	errorcode = 1;
X	logerr_die( "timeout" );
X    }
X
cleanup() {}	/* dummy for error actions */
END_OF_FILE
if test 4799 -ne `wc -c <'filters/vdmp.c'`; then
    echo shar: \"'filters/vdmp.c'\" unpacked with wrong size!
fi
# end of 'filters/vdmp.c'
fi
if test -f 'man/lpq.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/lpq.1'\"
else
echo shar: Extracting \"'man/lpq.1'\" \(3795 characters\)
sed "s/^X//" >'man/lpq.1' <<'END_OF_FILE'
X.TH LPQ 1 "19 Mar 1988" "U-MN PLP"
X.ig
X$Header: lpq.1,v 2.2 88/07/01 15:42:26 papowell Exp $
X$Log:	lpq.1,v $
Revision 2.2  88/07/01  15:42:26  papowell
Modified description
X
Revision 2.1  88/05/09  10:08:36  papowell
PLP: Released Version
X
Revision 1.1  88/04/28  10:58:52  papowell
Initial revision
X
X..
X.SH NAME
lpq \- spool queue examination program
X.SH SYNOPSIS
X.B lpq
X[\-Pprinter ]*[\-a][\-l][+[n]][\-D[n]][\-X][ job # ... ][ user ... ]
X.SH DESCRIPTION
X.I lpq
examines the spooling area used by
X.IR lpd (8)
for printing
files on the line printer, and reports the status of the specified jobs or
all jobs associated with a user. 
X.I lpq
invoked without any arguments
reports on the printer given by the default printer
X(see
X.B \-P
option).
XFor each job submitted (i.e. invocation of 
X.IR lpr (1))
X.I lpq
reports the user's name, current rank in the queue, the
names of files comprising the job, the job identifier (a number which
may be supplied to
X.IR lprm (1)
for removing a specific job), and the total size in bytes.
Job ordering is dependent on
the algorithm used to scan the spooling directory and is
XFIFO (First in First Out),
in order of priority level.
XFile names comprising a job may be unavailable
X(when
X.IR lpr (1)
is used as a sink in a pipeline) in which case the file
is indicated as ``(stdin)''.
The following options are available.
X.IP "\fB\-P \fIprinter\fR"
Specifies a particular printer, otherwise the default line printer
is used (or the value of the PRINTER variable in the environment).
If PRINTER is not defined,
then the first entry in the
X.IR /etc/printcap (5)
file is reported.
Multiple printers can be displayed by specifying more than one
X\-P option.
X.IP "\fB\-a\fR"
All printers listed in
X.IR /etc/printcap (5)
file are reported.
X.IP "\fB\-l\fR"
An a\fBl\fRternate display format is used,
which simply reports the user,
jobnumber,
and originating host.
X.IP "[\fB+\fR[\fIn\fR]]"
XForces
X.I lpq
to periodically display the spool queues.
Supplying a number
immediately after the
X.B \+
sign indicates that
X.I lpq
should sleep \fIn\fR seconds in between scans of the queue.
X.IP "\fB\-D\fR[\fIn\fR]"
XEnables display of debugging information.
The 
X.B \-D\fIn\fR
X\fRselects level
X.I n
X(n is a single digit).
X.IP "\fB\-X"
Use an Xperimental version of LPD if the software has been compiled
with the appropriate support;
ignored otherwise.
X.IP "[ job # ... ][ user ... ]"
The options are followed by
a list of user names or job numbers which
are used to select jobs of interest.
X.PP
The
X.I lpq
will report the status of the spool queue (enabled for spooling,
disabled for unspooling),
and the abscense of a server if unspooling is enabled.
The
X.IR lpc (1)
command
X.I "lpc restart <printer>"
may be used to start the server if this is the case.
X.SH FILES
X.nf
X.ta \w'/etc/termcap      'u +.5i +.5i
X/etc/termcap	for manipulating the screen for repeated display
X/etc/printcap	to determine printer characteristics
X/etc/printer_perms	printer permissions
X/usr/spool/*	the spooling directory, as determined from printcap
X/usr/spool/*/cf*	control files specifying jobs
X/usr/spool/*/lock	the lock file to obtain the currently active job 
X.fi
X.SH DIAGNOSTICS
X.br
XExcrutiatingly verbose.
If you are interested in tracing the exact execution,
try setting debug level to 5 (-D5) to see exactly what happens as you run LPQ.
X.SH "SEE ALSO"
lpr(1),
lprm(1),
lpc(1),
lpd(8),
X.br
X.I "PLP - The Public Line Printer Spooler",
by
Patrick Powell,
University of Minnesota.
X.fi
X.SH "HISTORY"
X.PP
The PLP is a reverse engineered version of the Berkeley 4.3BSD Line Printer
Spooler,
done in 1988 at the University of Minnesota.
It has many advanced features which are described in
X.I "PLP - The Public Line Printer Spooler"
by
Patrick Powell,
Department of Computer Science,
University of Minnesota.
END_OF_FILE
if test 3795 -ne `wc -c <'man/lpq.1'`; then
    echo shar: \"'man/lpq.1'\" unpacked with wrong size!
fi
# end of 'man/lpq.1'
fi
if test -f 'man/lprm.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/lprm.1'\"
else
echo shar: Extracting \"'man/lprm.1'\" \(3449 characters\)
sed "s/^X//" >'man/lprm.1' <<'END_OF_FILE'
X.TH LPRM 1 "19 Mar 1988" "U-MN PLP"
X.ig
X$Header: lprm.1,v 2.1 88/05/09 10:08:45 papowell Exp $
X$Log:	lprm.1,v $
Revision 2.1  88/05/09  10:08:45  papowell
PLP: Released Version
X
Revision 1.1  88/04/28  10:58:55  papowell
Initial revision
X
X..
X.SH NAME
lprm \- remove jobs from the line printer spooling queue
X.SH SYNOPSIS
X.B lprm
X[
X.BI \-P printer
X] [
X.B \-
X] [
X.BI \-D n
X] [
X.B \-X
X] [
job # ...
X] [
user ...
X]
X.SH DESCRIPTION
X.I Lprm
will remove jobs
from a spool queue.
Since the spooling directory and files in it are
owned by 
X.I daemon,
using
X.I lprm
is normally the only method by which a user may remove a job.
X.PP
The use must specify the job to be removed by providing a job
number or user name.
Ordinary users may remove jobs which are submitted by themselves;
users with
X.I Control
permissions in the 
X.I printer_perms
file may remove other users jobs.
Root can remove jobs on the local host and jobs submitted from the
local host.
X.PP
If the
X.B \-
flag is specified, 
X.I lprm
will remove all jobs which a user owns.
If a user with
X.I control
permissions uses this flag,
the spool queue will be emptied entirely.
The submitter of a job is determined by the information returned by
X.IR getpwent (3)
for the real userid of the process,
and the host name by the information returned by
X.IR gethostent (3).
X.PP
Specifying a user's name or list of user names will cause
X.I lprm
to attempt to remove any jobs queued belonging to that user
X(or users). 
This form of invoking
X.I lprm
is useful only to the super-user or users with
X.I control
permissions.
X.PP
A user may dequeue an individual job by specifying its job number.
This number may be obtained by using
X.IR lpq (1).
X.I Lprm
will announce the names of any files it removes and is silent if
there are no jobs in the queue which match the request list.
X.PP
If necessary,
X.I lprm
will kill off an active spool queue server
which is processing a job to be removed.
After jobs have been removed,
the server will be restarted.
X.IP \fB\-P\fP\ printer
The
X.B \-P
option specifies the spooling queue.
If it is not provided,
the default printer is the
the value of the PRINTER environment variable and then the
first printer in the
X.I printcap
database.
X.IP \fB\-D\fR[\fIn\fR]
The
X.B \-D\fIn\fR
X\fRselects debugging level
X.I n
X(n is a single digit).
This may be used to produce a trace of the actions of
X.IR lprm .
X.IP \fB\-X\fR
The \fB\-X
option uses an Xperimental version of lpd if the software has been compiled
with the appropriate support;
ignored otherwise.
X.SH FILES
X.nf
X.ta \w'/usr/spool/*/lock   'u
X/etc/printcap	printer characteristics file
X/etc/printer_perms	printer permissions
X/usr/spool/*	spooling directories
X/usr/spool/*/lock	lock file used to obtain the pid of the current
X	daemon and the job number of the currently active job
X.fi
X.SH BUGS
Since there are race conditions possible in the update of the lock file,
the currently active job may be incorrectly identified;
thus the need to specify the job number to be removed.
X.SH "SEE ALSO"
lpr(1),
lpq(1),
lpd(8)
X.br
X.I "PLP - The Public Line Printer Spooler",
by
Patrick Powell,
University of Minnesota.
X.fi
X.SH "HISTORY"
X.PP
The PLP is a reverse engineered version of the Berkeley 4.3BSD Line Printer
Spooler,
done in 1988 at the University of Minnesota.
It has many advanced features which are described in
X.I "PLP - The Public Line Printer Spooler"
by
Patrick Powell,
Department of Computer Science,
University of Minnesota.
END_OF_FILE
if test 3449 -ne `wc -c <'man/lprm.1'`; then
    echo shar: \"'man/lprm.1'\" unpacked with wrong size!
fi
# end of 'man/lprm.1'
fi
if test -f 'src/errormsg.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/errormsg.c'\"
else
echo shar: Extracting \"'src/errormsg.c'\" \(5344 characters\)
sed "s/^X//" >'src/errormsg.c' <<'END_OF_FILE'
X/***************************************************************************
X * U. Minnesota LPD Software * Copyright 1987, 1988, Patrick Powell
X ***************************************************************************
X * MODULE: Errormsg.c
X * error messages and logging
X * log:
X *  --message on stderr and on stdout if "Echo_on_stdout" is set
X *  --if the severity is high enough, will also log using syslog().
X *  --saves the last "non-Debug" log message
X * logerr:
X *  --formats the error message corresponding to "errno" and calls log();
X * fatal:
X *  -- log() and exit() with Errorcode
X * logerr_die:
X *  -- logerr() and exit() with Errorcode
X ***************************************************************************
X * Revision History: Created Sun Jan  3 18:41:01 CST 1988
X * $Log:	errormsg.c,v $
X * Revision 3.1  88/06/18  09:34:09  papowell
X * Version 3.0- Distributed Sat Jun 18 1988
X * 
X * Revision 2.1  88/05/09  10:08:01  papowell
X * PLP: Released Version
X * 
X * Revision 1.4  88/04/26  15:46:11  papowell
X * Added a datestamp to all messages
X * 
X * Revision 1.3  88/04/06  12:12:43  papowell
X * Minor updates, changes in error message formats.
X * Elimination of the AF_UNIX connections, use AF_INET only.
X * Better error messages.
X * 
X * Revision 1.2  88/03/25  14:59:24  papowell
X * Debugged Version:
X * 1. Added the PLP control file first transfer
X * 2. Checks for MX during file transfers
X * 3. Found and fixed a mysterious bug involving the SYSLOG facilities;
X * 	apparently they open files and then assume that they will stay
X * 	open.
X * 4. Made sure that stdin, stdout, stderr was available at all times.
X * 
X * Revision 1.1  88/03/01  11:08:23  papowell
X * Initial revision
X * 
X ***************************************************************************/
X#ifndef lint
static char id_str1[] =
X	"$Header: errormsg.c,v 3.1 88/06/18 09:34:09 papowell Exp $ PLP Copyright 1988 Patrick Powell";
X#endif lint
X
X#include "lp.h"
X
X/*
X * Errormsg( err ) returns a printable form of the errormessage
X * corresponding to errno.
X */
X
char *
XErrormsg( err )
X	int err;
X{
X	char *cp;
X	static char msgbuf[30];
X
X	if( err >= 0 && err <= sys_nerr ){
X		cp = sys_errlist[err];
X	} else {
X		(void)sprintf(msgbuf,"errno=%d",err);
X		cp = msgbuf;
X	}
X	return(cp);
X}
X
struct msgkind {
X	int *var;
X	char *str;
X};
static struct msgkind msg_name[] = {
X	{ &XLOG_ERR, "LOG_ERR" },
X	{ &XLOG_CRIT, "LOG_CRIT" },
X	{ &XLOG_WARNING, "LOG_WARNING" },
X	{ &XLOG_NOTICE, "LOG_NOTICE" },
X	{ &XLOG_INFO, "LOG_INFO" },
X	{ &XLOG_DEBUG, "LOG_DEBUG" },
X	{ 0 }
X};
X
static
char *
logmsg( kind )
X	int kind;
X{
X	int i;
X	static char b[35];
X
X	for( i = 0; msg_name[i].var; ++i ){
X		if( *msg_name[i].var == kind ){
X			return( msg_name[i].str );
X		}
X	}
X	(void)sprintf(b, "bad message type %d",  kind );
X	return(b);
X}
X
X/*
X * log( int severity; char *msg; args )
X *  	1. format the message; msg and args are similar to printf
X *		2. output on stderr
X *		3. if "Echo_on_stdout" output on stdout
X *		4. if severity high enough,  log using syslog()
X *		5. if not a Debug message, save in Last_errormsg[]
X */
X/*VARARGS2*/
log(kind, msg, a1, a2, a3, a4, a5, a6, a7, a8, a9)
X	char *msg, *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8, *a9;
X{
X	char buf[BUFSIZ];
X	int omask;
X
X	omask = sigblock(sigmask(SIGCHLD)|sigmask(SIGHUP)
X		|sigmask(SIGINT)|sigmask(SIGQUIT)|sigmask(SIGTERM));
X	buf[0] = 0;
X	if(Name && *Name){
X		(void)sprintf(buf+strlen(buf),"%s: ", Name);
X	}
X	if(Printer && *Printer){
X		(void)sprintf(buf+strlen(buf),"%s- ", Printer);
X	}
X	if(Debug){
X		(void)sprintf(buf+strlen(buf),"pid=%d, %s, ",getpid(),logmsg(kind));
X	}
X	(void)sprintf(buf+strlen(buf), msg, a1, a2, a3, a4, a5, a6, a7, a8, a9);
X	(void)sprintf(buf+strlen(buf)," at %s",Time_str() );
X
X	if(Echo_on_stdout){
X		(void)fprintf(stdout,"%s\n", buf);
X		(void)fflush(stdout);
X	}
X	(void)fprintf(stderr,"%s\n", buf);
X	(void)fflush(stderr);
X	if( kind <= XLOG_INFO ){
X		use_syslog( kind, buf);
X	}
X	if( kind != XLOG_DEBUG ){
X		(void)strcpy( Last_errormsg, buf );
X	}
X	(void)sigsetmask(omask);
X}
X
X/*VARARGS2*/
fatal(kind, msg, a1, a2, a3, a4, a5, a6, a7, a8, a9)
X	char *msg, *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8, *a9;
X{
X	log( kind, msg, a1, a2, a3, a4, a5, a6, a7, a8, a9);
X	cleanup();
X	exit(Errorcode);
X}
X
X/*VARARGS2*/
logerr( kind,msg, a1, a2, a3, a4, a5, a6, a7, a8, a9)
X	char *msg, *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8, *a9;
X{
X	int err = errno;
X	char buf1[BUFSIZ];
X
X	(void)sprintf(buf1, msg, a1, a2, a3, a4, a5, a6, a7, a8, a9);
X	log( kind,"%s - %s", buf1, Errormsg(err) );
X	errno = err;
X}
X
X/*VARARGS2*/
logerr_die( kind,msg, a1, a2, a3, a4, a5, a6, a7, a8, a9)
X	char *msg, *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8, *a9;
X{
X	logerr( kind,msg, a1, a2, a3, a4, a5, a6, a7, a8, a9);
X	cleanup();
X	exit(Errorcode);
X}
X
X/*
X * use the syslog(8) deamon to do our logging
X */
X#ifdef NOSYSLOG
static FILE *f;
X#else NOSYSLOG
X#include <syslog.h>
X#endif NOSYSLOG
static int init;
X
use_syslog( kind, msg )
X	int kind;
X	char * msg;
X{
X	if(Debug>7){
X		(void)fprintf(stderr, "syslog: %s\n", msg );
X		(void)fflush(stderr);
X	}
X#ifdef NOSYSLOG
X	if( f != NULL || (f = fopen( "/dev/console", "w" ) ) != NULL ){
X		(void)fprintf( f, "syslog: LPD %s\n", msg );
X		(void)fflush(f);
X	}
X#else NOSYSLOG
X	if(init == 0 ){
X		init = 1;
X	}
X#	ifdef IS_SUN
X		(void)syslog(kind, "%s", msg);
X#	endif
X#	ifdef IS_VAX
X		(void)syslog(LOG_LPR|kind, msg);
X#	endif
X#endif NOSYSLOG
X}
END_OF_FILE
if test 5344 -ne `wc -c <'src/errormsg.c'`; then
    echo shar: \"'src/errormsg.c'\" unpacked with wrong size!
fi
# end of 'src/errormsg.c'
fi
if test -f 'src/lprm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lprm.c'\"
else
echo shar: Extracting \"'src/lprm.c'\" \(5292 characters\)
sed "s/^X//" >'src/lprm.c' <<'END_OF_FILE'
X/***************************************************************************
X * U. Minnesota LPD Software * Copyright 1987, 1988, Patrick Powell
X ***************************************************************************
X * MODULE: lprm.c
X * lprm- remove files
X ***************************************************************************
X * Revision History: Created Mon Jan 25 14:04:26 CST 1988
X * $Log:	lprm.c,v $
X * Revision 3.1  88/06/18  09:35:07  papowell
X * Version 3.0- Distributed Sat Jun 18 1988
X * 
X * Revision 2.2  88/05/14  10:20:53  papowell
X * Modified -X flag handling
X * 
X * Revision 2.1  88/05/09  10:09:32  papowell
X * PLP: Released Version
X * 
X * Revision 1.6  88/04/27  18:02:41  papowell
X * The SIGCHLD signal has an odd behaviour on some systems.  Modified so that
X * it will not get set UNLESS processes are started;  also,  it is reset
X * to SIG_DFL, not SIG_IGN.
X * 
X * Revision 1.5  88/04/15  13:06:06  papowell
X * Std_environ() call added, to ensure that fd 0 (stdin), 1 (stdout), 2(stderr)
X * have valid file descriptors;  if not open, then /dev/null is used.
X * 
X * Revision 1.4  88/04/06  12:12:39  papowell
X * Minor updates, changes in error message formats.
X * Elimination of the AF_UNIX connections, use AF_INET only.
X * Better error messages.
X * 
X * Revision 1.3  88/03/25  15:00:48  papowell
X * Debugged Version:
X * 1. Added the PLP control file first transfer
X * 2. Checks for MX during file transfers
X * 3. Found and fixed a mysterious bug involving the SYSLOG facilities;
X * 	apparently they open files and then assume that they will stay
X * 	open.
X * 4. Made sure that stdin, stdout, stderr was available at all times.
X * 
X * Revision 1.2  88/03/11  19:27:59  papowell
X * Minor Changes, Updates
X * 
X * Revision 1.1  88/03/01  11:08:55  papowell
X * Initial revision
X * 
X ***************************************************************************/
X#ifndef lint
static char id_str1[] =
X	"$Header: lprm.c,v 3.1 88/06/18 09:35:07 papowell Exp $ PLP Copyright 1988 Patrick Powell";
X#endif lint
X#include "lp.h"
X
extern int cleanup();
X
main(argc, argv)
X	int argc;
X	char **argv;
X{
X	struct passwd *pw_ent;		/* user entry in /etc/passwd */
X
X	/*
X	 * set umask to avoid problems with user umask
X	 */
X	(void)umask(0);
X	/*
X	 * Set fd 0, 1, 2 to /dev/null if not open
X	 */
X	Std_environ();
X#	ifdef XPERIMENT
X		Setup_test();
X#	endif XPERIMENT
X	/*
X     * set up the pathnames for information files
X	 */
X	Tailor_names();
X	/*
X	 * set up the From information
X	 */
X	From = Host;
X	/*
X	 * get the user information
X	 */
X	if( (pw_ent = getpwuid( getuid() )) == 0 ){
X		logerr_die( XLOG_INFO, "getpwuid failed on uid %d", getuid());
X	}
X	(void)strcpy( LOGNAME, pw_ent->pw_name );
X	Person = LOGNAME;
X	if( getuid() == 0 ){
X		/* we are being invoked by root */
X		Is_root = 1;
X	}
X	/*
X	 * setup parameters
X	 */
X	Lprm_parms(argc, argv);
X	/*
X	 * set signals
X	 */
X	(void)signal(SIGPIPE, SIG_IGN);
X	(void)signal(SIGHUP, cleanup);
X	(void)signal(SIGINT, cleanup);
X	(void)signal(SIGQUIT, cleanup);
X	(void)signal(SIGTERM, cleanup);
X	if( Parmcount != 0 ){
X		rmjob();
X	}
X	exit( 0 );
X}
X
X/***************************************************************************
X * cleanup()
X * remove the temp files
X ***************************************************************************/
X
cleanup()
X{
X	exit( 1 );
X}
X
X/***************************************************************************
X * Lprm_parms( int arc, char **argv )
X * 1. pick off the options
X * 2. set up the parameters
X ***************************************************************************/
X
static char *optstr = "P:D:Xa";
static int Xpert;
static int all_flag;
Lprm_parms( argc, argv )
X	int argc;
X	char **argv;
X{
X	int option;
X	char *s;
X	int i;
X
X	while( (option = Getopt(argc,argv,optstr)) != EOF ){
X		switch( option ){
X		case 'D':
X			if(Debug){
X				Diemsg("Duplicate -D option");
X			}
X			if( sscanf( Optarg, "%d", &Debug ) != 1 || Debug <= 0){
X				Diemsg("-D parameter is not positive integer" );
X			}
X			break;
X		case 'X':
X			if( Xpert ){
X				Diemsg("Duplicate -X option");
X			}
X#			ifdef DEBUG
X				Setup_test();
X				Tailor_names();
X#			else
X				Diemsg( "-X not allowed" );
X#			endif DEBUG
X			break;
X		case 'P':
X			if( Printer ){
X				Diemsg("Duplicate -P option");
X			}
X			Printer = Optarg;
X			break;
X		case 'a':
X			if( all_flag ){
X				Diemsg("Duplicate -a option");
X			}
X			all_flag = 1;
X			break;
X		case '?':
X			break;
X		default:
X			fatal(XLOG_INFO, "Lprm_parms: badparm %c", option );
X		}
X	}
X
X	/*
X	 * set up the Parms[] array
X	 */
X	for( ; Optind < argc; ++Optind ){
X		if( Parmcount < MAXPARMS ){
X			s = argv[Optind];
X			Parms[Parmcount].str = s;
X			if( isdigit( *s )){
X				Parms[Parmcount].num = atoi(s);
X			} else {
X				Parms[Parmcount].num = -1;
X			}
X			++Parmcount;
X		} else {
X			Diemsg( "too many files to print; break job up" );
X		}
X	}
X	/*
X	 * get the default printer
X	 */
X	Get_Printer(0);
X	/*
X	 * check for the all option
X	 */
X	if( all_flag ){
X		if( Parmcount > 0 ){
X			Diemsg("-a cannot be combined with other options" );
X		}
X		Parms[0].str = "-all";
X		Parmcount = 1;
X	}
X	if(Debug>4){
X		(void)fprintf(stdout,"Printer %s, Parmcount %d ", Printer, Parmcount );
X		for( i = 0; i < Parmcount; ++i )
X			(void)fprintf(stdout," '%s'(%d)",Parms[i].str, Parms[i].num ); 
X		(void)fprintf(stdout,"\n"); (void)fflush(stdout);
X	}
X}
END_OF_FILE
if test 5292 -ne `wc -c <'src/lprm.c'`; then
    echo shar: \"'src/lprm.c'\" unpacked with wrong size!
fi
# end of 'src/lprm.c'
fi
if test -f 'src/remote_ops.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/remote_ops.c'\"
else
echo shar: Extracting \"'src/remote_ops.c'\" \(5087 characters\)
sed "s/^X//" >'src/remote_ops.c' <<'END_OF_FILE'
X/***************************************************************************
X * U. Minnesota LPD Software * Copyright 1987, 1988, Patrick Powell
X ***************************************************************************
X * MODULE: Remote_ops.c
X * intiate remote operations from the local machine
X ***************************************************************************
X * Revision History: Created Sun Jan 17 19:55:38 CST 1988
X * $Log:	remote_ops.c,v $
X * Revision 3.3  88/07/06  17:32:41  papowell
X * Added retry for status connection.  Sigh.
X * 
X * Revision 3.2  88/06/24  17:55:38  papowell
X * MODS for VAX 4.3BSD UNIX
X * 
X * Revision 3.1  88/06/18  09:35:29  papowell
X * Version 3.0- Distributed Sat Jun 18 1988
X * 
X * Revision 2.1  88/05/09  10:10:01  papowell
X * PLP: Released Version
X * 
X * Revision 1.4  88/04/06  12:12:58  papowell
X * Minor updates, changes in error message formats.
X * Elimination of the AF_UNIX connections, use AF_INET only.
X * Better error messages.
X * 
X * Revision 1.3  88/03/25  15:01:23  papowell
X * Debugged Version:
X * 1. Added the PLP control file first transfer
X * 2. Checks for MX during file transfers
X * 3. Found and fixed a mysterious bug involving the SYSLOG facilities;
X * 	apparently they open files and then assume that they will stay
X * 	open.
X * 4. Made sure that stdin, stdout, stderr was available at all times.
X * 
X * Revision 1.2  88/03/11  19:27:55  papowell
X * Minor Changes, Updates
X * 
X * Revision 1.1  88/03/01  11:09:08  papowell
X * Initial revision
X * 
X ***************************************************************************/
X#ifndef lint
static char id_str1[] =
X	"$Header: remote_ops.c,v 3.3 88/07/06 17:32:41 papowell Locked $ PLP Copyright 1988 Patrick Powell";
X#endif lint
X
X#include "lp.h"
X
X/***************************************************************************
X * Remote_status()
X * get the status from the remote Host RM for Printer RP
X ***************************************************************************/
Remote_status()
X{
X	char buf[BUFSIZ];
X
X	if( RP == 0 || *RP == 0 ){
X		fatal(XLOG_INFO, "no RP specified for RM (%s)", RM );
X	}
X	(void)sprintf( buf, "%c%s\n",  Short_format? REQ_DSHORT : REQ_DLONG,RP);
X	if(Debug>3)log(XLOG_DEBUG,"Remote_status: %s, '%d'%s",RM,buf[0],buf+1);
X	if( JSUCC == Link_line( 3, buf )){
X		if(Debug>4)log(XLOG_DEBUG,"request sent");
X		Link_get();
X	} else {
X		(void)fprintf( stdout, "Remote connect to '%s' (%s) failed: %s\n",
X			RP, RM, Errormsg(errno));
X	}
X	Link_close();
X}
X
X/***************************************************************************
X * Remote_remove()
X * send a remote remove request to the remote Host
X ***************************************************************************/
Remote_remove( )
X{
X	char buf[BUFSIZ];		/* holds command */
X	char *bp, *ep;			/* ACME Pointers, Inc. */
X	int i;					/* ACME Integers, Inc. */
X	static char *xsp = " ";	/* needs a space */
X
X	/*
X	 * set up the remote command format:
X	 * <REQ_REMOVE>Printer Person [Parms]
X	 */
X	bp = buf; ep = buf+sizeof(buf);
X	*bp++ = REQ_REMOVE;
X	if( RP == 0 || *RP == 0 ){
X		fatal( XLOG_INFO, "no RP specified for RM %s", RM );
X	}
X	bp = estrcp( bp, RP, ep );
X	bp = estrcp( bp, xsp, ep );
X	bp = estrcp( bp, Person, ep );
X	for( i = 0; i < Parmcount; ++i ){
X		bp = estrcp( bp, xsp, ep );
X		bp = estrcp( bp, Parms[i].str, ep );
X	}
X	bp = estrcp( bp, "\n", ep );
X	/*
X	 * check command line for length
X	 */
X	if( bp == 0 ){
X		fatal( XLOG_INFO, "Remote_remove: command line too long '%s'");
X	}
X	/*
X	 * send command
X	 */
X	if(Debug>3)log(XLOG_DEBUG,"Remote_remove: %s, '%d'%s",RM,buf[0],buf+1);
X	if( JSUCC == Link_line( 3, buf )){
X		if(Debug>3)log(XLOG_DEBUG,"request sent");
X		Link_get();
X	}
X	Link_close();
X}
X
X/***************************************************************************
X * Remote_control(cmd)
X * send the remote command to the printer
X * This has the form: \006person command RP
X ***************************************************************************/
Remote_control(cmd)
X	char *cmd;
X{
X	char buf[BUFSIZ];
X
X	if( RP == 0 || *RP == 0 ){
X		fatal(XLOG_INFO, "no RP specified for RM (%s)", RM );
X	}
X	(void)sprintf( buf, "%c%s %s %s\n",  REQ_CONTROL,Person,cmd,RP);
X	if(Debug>3)log(XLOG_DEBUG,"Remote_control:%s '%d%'%s'",RM,buf[0],buf+1);
X	if( JSUCC == Link_line( 3, buf )){
X		if(Debug>4)log(XLOG_DEBUG,"request sent");
X		Link_get();
X	} else {
X		(void)fprintf( stdout, "Remote connect to '%s' (%s) failed: %s\n",
X			RP, RM, Errormsg(errno));
X	}
X	Link_close();
X}
X
X/***************************************************************************
X * Remote_start()
X * start the remote printer
X ***************************************************************************/
Remote_start()
X{
X	char buf[BUFSIZ];
X	int succ;
X
X	if( RP == 0 || *RP == 0 ){
X		fatal(XLOG_INFO, "no RP specified for RM (%s)", RM );
X	}
X	(void)sprintf( buf, "%c%s\n", REQ_START, RP);
X	if(Debug>3)log(XLOG_DEBUG,"Remote_start:%s '%d%'%s'",RM,buf[0],buf+1);
X	succ = Link_line( 3, buf );
X	if( JSUCC == succ){
X		if(Debug>4)log(XLOG_DEBUG,"request sent");
X		(void)Link_confirm();
X	}
X	Link_close();
X	return( JSUCC == succ );
X}
END_OF_FILE
if test 5087 -ne `wc -c <'src/remote_ops.c'`; then
    echo shar: \"'src/remote_ops.c'\" unpacked with wrong size!
fi
# end of 'src/remote_ops.c'
fi
if test -f 'src/sendmail.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/sendmail.c'\"
else
echo shar: Extracting \"'src/sendmail.c'\" \(3436 characters\)
sed "s/^X//" >'src/sendmail.c' <<'END_OF_FILE'
X/***************************************************************************
X * U. Minnesota LPD Software * Copyright 1987, 1988, Patrick Powell
X ***************************************************************************
X * MODULE: sendmail.c
X * send mail to user on completion of a job
X ***************************************************************************
X * Revision History: Created Fri Jan 15 15:17:10 CST 1988
X * $Log:	sendmail.c,v $
X * Revision 3.1  88/06/18  09:35:36  papowell
X * Version 3.0- Distributed Sat Jun 18 1988
X * 
X * Revision 2.1  88/05/09  10:10:13  papowell
X * PLP: Released Version
X * 
X * Revision 1.3  88/04/06  12:13:55  papowell
X * Minor updates, changes in error message formats.
X * Elimination of the AF_UNIX connections, use AF_INET only.
X * Better error messages.
X * 
X * Revision 1.2  88/03/25  15:01:36  papowell
X * Debugged Version:
X * 1. Added the PLP control file first transfer
X * 2. Checks for MX during file transfers
X * 3. Found and fixed a mysterious bug involving the SYSLOG facilities;
X * 	apparently they open files and then assume that they will stay
X * 	open.
X * 4. Made sure that stdin, stdout, stderr was available at all times.
X * 
X * Revision 1.1  88/03/01  11:09:14  papowell
X * Initial revision
X * 
X ***************************************************************************/
X#ifndef lint
static char id_str1[] =
X	"$Header: sendmail.c,v 3.1 88/06/18 09:35:36 papowell Exp $ PLP Copyright 1988 Patrick Powell";
X#endif lint
X
X#include "lp.h"
X
X/*
X * sendmail ---
X *   tell people about job completion
X * 1. fork a sendmail process
X * 2. if successful, send the good news
X * 3. if unsuccessful, send the bad news
X */
sendmail(q, status)
X	struct queue *q;
X	int status;
X{
X	static int p[2];	/* pipe */
X	int i;				/* ACME Integer, Inc. */
X	char buf[100];
X	FILE *mail;			/* mail file */
X	int pid;			/* sendmail process */
X	union wait stat;	/* daughter status */
X
X	(void)sprintf(buf, "%s %s", MAIL, MAILNAME );
X	if(Debug>3)log( XLOG_DEBUG, "mail command: %s", buf );
X	if( pipe(p) < 0 ){
X		logerr_die( XLOG_NOTICE, "pipe failed for sendmail" );
X	}
X	/*
X	 * start up sendmail process
X	 */
X	if((pid = fork()) == 0){
X		if( p[0] ){
X			if( dup2(p[0], 0) < 0 ){
X				logerr_die( XLOG_NOTICE, "dup2 failed in sendmail child" );
X			}
X			(void)close(p[0]);
X		}
X		(void)close(p[1]);
X		mexecv(buf);
X		logerr_die(XLOG_INFO, "exec mail failed: %s", buf);
X	} else if(pid < 0) {				/* parent */
X		logerr_die( XLOG_NOTICE, "sendmail: fork failed" );
X	}
X	(void)close(p[0]);
X	if( (mail = fdopen(p[1], "w")) == NULL ){
X		logerr_die( XLOG_NOTICE, "sendmail: fdopen failed" );
X	}
X	(void)fprintf(mail,"To: %s@%s\n", q->q_user, &q->q_from);
X	(void)fprintf(mail,"Subject: %s printer job\n\n", Printer);
X	(void)fprintf(mail,"Your %s printer job %d (%s)",Printer,
X		q->q_num, q->q_data);
X	switch(  status ){
X		case JSUCC:
X			(void)fprintf( mail, " was successful.\n" );
X			break;
X		case JFAIL:
X			(void)fprintf( mail, " failed, and retry count was exceeded.\n" );
X			(void)fprintf( mail, "%s\n", Last_errormsg );
X			break;
X		default:
X			(void)fprintf( mail, " died a horrible death.\n");
X			(void)fprintf( mail, "%s\n", Last_errormsg );
X			break;
X	}
X	(void) fflush(mail);
X	(void) fclose(mail);
X	while ((i = wait(&stat)) > 0 && i != pid){
X		if(Debug>3)log( XLOG_DEBUG, "sendmail: caught %d, (%s)", i,
X			Decode_status(&stat));
X	}
X	if(Debug>3)log( XLOG_DEBUG, "sendmail: %d finished (%s)",
X		i,Decode_status(&stat) );
X}
END_OF_FILE
if test 3436 -ne `wc -c <'src/sendmail.c'`; then
    echo shar: \"'src/sendmail.c'\" unpacked with wrong size!
fi
# end of 'src/sendmail.c'
fi
if test -f 'src/setup_filter.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/setup_filter.c'\"
else
echo shar: Extracting \"'src/setup_filter.c'\" \(4073 characters\)
sed "s/^X//" >'src/setup_filter.c' <<'END_OF_FILE'
X/***************************************************************************
X * U. Minnesota LPD Software * Copyright 1987, 1988, Patrick Powell
X ***************************************************************************
X * MODULE: Setup_filter.c
X ***************************************************************************
X * Revision History: Created Sat Jan  9 16:57:59 CST 1988
X * $Log:	setup_filter.c,v $
X * Revision 3.1  88/06/18  09:35:45  papowell
X * Version 3.0- Distributed Sat Jun 18 1988
X * 
X * Revision 2.1  88/05/09  10:10:24  papowell
X * PLP: Released Version
X * 
X * Revision 1.1  88/03/01  11:09:19  papowell
X * Initial revision
X * 
X ***************************************************************************/
X#ifndef lint
static char id_str1[] =
X	"$Header: setup_filter.c,v 3.1 88/06/18 09:35:45 papowell Exp $ PLP Copyright 1988 Patrick Powell";
X#endif lint
X
X/**********************************************************************
X *Setup_filter(int format; char *filtername )
X * create the command line to invoke a filter
X *  format: the format type of the data the filter will be invoked with
X *           (a single (char) letter identifies the type).
X *  filtername: an string containing the filter Name and arguments
X *  prog: address of a pointer which will be set to the program Name
X *
X * Actions:
X *  creates a string which contains the command to invoke a filter.
X *  The command be of the form:
X *  filtername arguments \   <- from filtername
X *      -PPrinter -wwidth -llength -xwidth -ylength [-c] [-iindent] \
X *		[-Zoptions] [-Cclass] [-Jjob] [-Raccntname] -nlogin -hHost
X *      -Fformat [affile]
X *  The 'o' (of filter) only gets the -w, -l, -x, -y and -F options
X **********************************************************************/
X
X#include "lp.h"
char *add_stropt(), *add_numopt(), *add_chropt();
X
char *
Setup_filter(format, filtername)
X	int format;
X	char *filtername;
X{
X	static char cmd[BUFSIZ];	/* the command buffer */
X	char *bp, *ep;		/* buffer pointer and general purpose pointer */
X
X	if (!filtername || !*filtername) {
X		log(XLOG_INFO,"format %c has no filter",format);
X		return ( (char *)0 );
X	}
X
X	/* set up end of buffer pointer for error detection */
X	ep = cmd + sizeof(cmd);
X
X	/* First copy the filter progname and its fixed args */
X
X	bp = estrcp( cmd, filtername, ep );
X	bp = add_stropt(bp,ep," -P",Printer);
X	if( PWIDTH[0] == 0 ){
X		(void)sprintf( PWIDTH, "%d", PW );
X	}
X	bp = add_stropt(bp,ep," -w",PWIDTH);
X	bp = add_numopt(bp,ep," -l",PL);
X	bp = add_numopt(bp,ep," -x",PX);
X	bp = add_numopt(bp,ep," -y",PY);
X
X	if (format == 'o') {	/* of format */
X		bp = add_chropt(bp,ep," -F",format);
X		if( bp == 0 ){
X			log( XLOG_INFO, "filter command too long '%s'", cmd );
X			return( 0 );
X		}
X		return(cmd);
X	}
X
X	/*
X	 * -PPrinter -wwidth -llength -xwidth -ylength [-c] [-iindent] \
X	 *  [-Zoptions] [-Cclass] [-Jjob] -nlogin -hHost -Fformat [affile]
X	 */
X	if (format == 'l'){	/* add literal flag */
X		bp = add_stropt( bp,ep, " -c", "" );
X	}
X	if( INDENT[0] ){
X		bp = add_stropt(bp,ep," -i",INDENT);
X	}
X	if( ZOPTS[0] ){
X		bp = add_stropt(bp,ep," -Z",ZOPTS);
X	}
X	if( ACCNTNAME[0] ){
X		bp = add_stropt(bp,ep," -R",ACCNTNAME);
X	}
X	if( CLASSNAME[0] ){
X		bp = add_stropt(bp,ep," -C",CLASSNAME);
X	}
X	if( JOBNAME[0] ){
X		bp = add_stropt(bp,ep," -J",JOBNAME);
X	}
X	bp = add_stropt(bp,ep," -n",LOGNAME);
X	bp = add_stropt(bp,ep," -h",FROMHOST);
X	/*
X	 * accounting_filename
X	 */
X	bp = add_chropt(bp,ep," -F",format);
X	if( AF && *AF ){
X		bp = add_stropt(bp,ep," ",AF);
X	}
X	if( bp == 0 ){
X		log( XLOG_INFO, "filter command too long '%s'", cmd );
X	}
X	return(cmd);
X}
X
X
static char *
add_stropt( s, e, s1, s2 )
X	char *s, *e, *s1, *s2;
X{
X	s = estrcp( s, s1, e );
X	s = estrcp( s, s2, e );
X	return( s );
X}
X
static char *
add_numopt( s, e, s1, n )
X	char *s, *e, *s1;
X	int n;
X{
X	char b[10];
X	(void)sprintf(b, "%d", n);
X	s = estrcp( s, s1, e );
X	s = estrcp( s, b, e );
X	return( s );
X}
X
static char *
add_chropt( s, e, s1, n )
X	char *s, *e, *s1;
X	int n;
X{
X	char b[2];
X	b[0]=n; b[1] = 0;
X	s = estrcp( s, s1, e );
X	s = estrcp( s, b, e );
X	return( s );
X}
END_OF_FILE
if test 4073 -ne `wc -c <'src/setup_filter.c'`; then
    echo shar: \"'src/setup_filter.c'\" unpacked with wrong size!
fi
# end of 'src/setup_filter.c'
fi
echo shar: End of archive 3 \(of 16\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

-- 
Please send comp.sources.unix-related mail to rsalz@uunet.uu.net.
