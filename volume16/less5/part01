Subject:  v16i030:  Less, a pager that's more than more, Part01/04
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: ctnews!UNIX386!mark
Posting-number: Volume 16, Issue 30
Archive-name: less5/part01

Less is a pager, like more or pg, except that it has more features
than either one of them, including the ability to scroll backward
and forward along files and pipes, and to set marks and return to
them like vi and company.

#! /bin/sh
# This is a shell archive.
# Remove anything before this line, then unpack it
# by saving it into a file and typing "sh file".

echo shar: Extracting \"output.c\"
sed "s/^X//" >'output.c' <<'END_OF_FILE'
X/*
X * High level routines dealing with the output to the screen.
X */
X
X#include "less.h"
X
Xpublic int errmsgs;	/* Count of messages displayed by error() */
X
Xextern int sigs;
Xextern int sc_width, sc_height;
Xextern int ul_width, ue_width;
Xextern int so_width, se_width;
Xextern int bo_width, be_width;
Xextern int tabstop;
Xextern int twiddle;
Xextern int screen_trashed;
Xextern int any_display;
Xextern char *line;
Xextern char *first_cmd;
X
X/*
X * Display the line which is in the line buffer.
X */
X	public void
Xput_line()
X{
X	register char *p;
X	register int c;
X	register int column;
X	extern int auto_wrap, ignaw;
X
X	if (sigs)
X	{
X		/*
X		 * Don't output if a signal is pending.
X		 */
X		screen_trashed = 1;
X		return;
X	}
X
X	if (line == NULL)
X		line = (twiddle) ? "~" : "";
X
X	column = 0;
X	for (p = line;  *p != '\0';  p++)
X	{
X		switch (c = *p)
X		{
X		case UL_CHAR:
X			ul_enter();
X			column += ul_width;
X			break;
X		case UE_CHAR:
X			ul_exit();
X			column += ue_width;
X			break;
X		case BO_CHAR:
X			bo_enter();
X			column += bo_width;
X			break;
X		case BE_CHAR:
X			bo_exit();
X			column += be_width;
X			break;
X		case '\t':
X			do
X			{
X				putchr(' ');
X				column++;
X			} while ((column % tabstop) != 0);
X			break;
X		case '\b':
X			putbs();
X			column--;
X			break;
X		default:
X			if (c & 0200)
X			{
X				/*
X				 * Control characters arrive here as the
X				 * normal character [carat_char(c)] with
X				 * the 0200 bit set.  See pappend().
X				 */
X				putchr('^');
X				putchr(c & 0177);
X				column += 2;
X			} else
X			{
X				putchr(c);
X				column++;
X			}
X		}
X	}
X	if (column < sc_width || !auto_wrap || ignaw)
X		putchr('\n');
X}
X
X/*
X * Is a given character a "control" character?
X * {{ ASCII DEPENDENT }}
X */
X	public int
Xcontrol_char(c)
X	int c;
X{
X	return (c < ' ' || c == '\177');
X}
X
X/*
X * Return the printable character used to identify a control character
X * (printed after a carat; e.g. '\3' => "^C").
X * {{ ASCII DEPENDENT }}
X */
X	public int
Xcarat_char(c)
X	int c;
X{
X	return ((c == '\177') ? '?' : (c | 0100));
X}
X
X
Xstatic char obuf[1024];
Xstatic char *ob = obuf;
X
X/*
X * Flush buffered output.
X */
X	public void
Xflush()
X{
X	register int n;
X
X	n = ob - obuf;
X	if (n == 0)
X		return;
X	if (write(1, obuf, n) != n)
X		screen_trashed = 1;
X	ob = obuf;
X}
X
X/*
X * Discard buffered output.
X */
X	public void
Xdropout()
X{
X	ob = obuf;
X}
X
X/*
X * Output a character.
X */
X	public void
Xputchr(c)
X	int c;
X{
X	if (ob >= &obuf[sizeof(obuf)])
X		flush();
X	*ob++ = c;
X}
X
X/*
X * Output a string.
X */
X	public void
Xputstr(s)
X	register char *s;
X{
X	while (*s != '\0')
X		putchr(*s++);
X}
X
X/*
X * Output a message in the lower left corner of the screen
X * and wait for carriage return.
X */
X
Xstatic char return_to_continue[] = "  (press RETURN)";
X
X	public void
Xerror(s)
X	char *s;
X{
X	register int c;
X	static char buf[2];
X
X	errmsgs++;
X	if (!any_display)
X	{
X		/*
X		 * Nothing has been displayed yet.
X		 * Output this message on error output (file
X		 * descriptor 2) and don't wait for a keystroke
X		 * to continue.
X		 *
X		 * This has the desirable effect of producing all
X		 * error messages on error output if standard output
X		 * is directed to a file.  It also does the same if
X		 * we never produce any real output; for example, if
X		 * the input file(s) cannot be opened.  If we do
X		 * eventually produce output, code in edit() makes
X		 * sure these messages can be seen before they are
X		 * overwritten or scrolled away.
X		 */
X		write(2, s, strlen(s));
X		write(2, "\n", 1);
X		return;
X	}
X
X	lower_left();
X	clear_eol();
X	so_enter();
X	putstr(s);
X	putstr(return_to_continue);
X	so_exit();
X
X#if ONLY_RETURN
X	while ((c = getchr()) != '\n' && c != '\r')
X		bell();
X#else
X	c = getchr();
X	if (c != '\n' && c != '\r' && c != ' ' && c != READ_INTR)
X	{
X		buf[0] = c;
X		first_cmd = buf;
X	}
X#endif
X	lower_left();
X
X	if (strlen(s) + sizeof(return_to_continue) + 
X		so_width + se_width + 1 > sc_width)
X		/*
X		 * Printing the message has probably scrolled the screen.
X		 * {{ Unless the terminal doesn't have auto margins,
X		 *    in which case we just hammered on the right margin. }}
X		 */
X		repaint();
X
X	flush();
X}
X
Xstatic char intr_to_abort[] = "... (interrupt to abort)";
X
X	public void
Xierror(s)
X	char *s;
X{
X
X	lower_left();
X	clear_eol();
X	so_enter();
X	putstr(s);
X	putstr(intr_to_abort);
X	so_exit();
X	flush();
X}
END_OF_FILE
echo shar: Extracting \"decode.c\"
sed "s/^X//" >'decode.c' <<'END_OF_FILE'
X/*
X * Routines to decode user commands.
X *
X * This is all table driven.
X * A command table is a sequence of command descriptors.
X * Each command descriptor is a sequence of bytes with the following format:
X *	<c1><c2>...<cN><0><action>
X * The characters c1,c2,...,cN are the command string; that is,
X * the characters which the user must type.
X * It is terminated by a null <0> byte.
X * The byte after the null byte is the action code associated
X * with the command string.
X *
X * The default commands are described by cmdtable.
X * User-defined commands are read into usertable.
X */
X
X#include "less.h"
X#include "cmd.h"
X
X/*
X * Command table is ordered roughly according to expected
X * frequency of use, so the common commands are near the beginning.
X */
Xstatic char cmdtable[] =
X{
X	'\r',0,				A_F_LINE,
X	'\n',0,				A_F_LINE,
X	'e',0,				A_F_LINE,
X	'j',0,				A_F_LINE,
X	CONTROL('E'),0,			A_F_LINE,
X	CONTROL('N'),0,			A_F_LINE,
X	'k',0,				A_B_LINE,
X	'y',0,				A_B_LINE,
X	CONTROL('Y'),0,			A_B_LINE,
X	CONTROL('K'),0,			A_B_LINE,
X	CONTROL('P'),0,			A_B_LINE,
X	'd',0,				A_F_SCROLL,
X	CONTROL('D'),0,			A_F_SCROLL,
X	'u',0,				A_B_SCROLL,
X	CONTROL('U'),0,			A_B_SCROLL,
X	' ',0,				A_F_SCREEN,
X	'f',0,				A_F_SCREEN,
X	CONTROL('F'),0,			A_F_SCREEN,
X	CONTROL('V'),0,			A_F_SCREEN,
X	'b',0,				A_B_SCREEN,
X	CONTROL('B'),0,			A_B_SCREEN,
X	CONTROL('['),'v',0,		A_B_SCREEN,
X	'R',0,				A_FREPAINT,
X	'r',0,				A_REPAINT,
X	CONTROL('R'),0,			A_REPAINT,
X	CONTROL('L'),0,			A_REPAINT,
X	'g',0,				A_GOLINE,
X	'<',0,				A_GOLINE,
X	CONTROL('['),'<',0,		A_GOLINE,
X	'p',0,				A_PERCENT,
X	'%',0,				A_PERCENT,
X	'G',0,				A_GOEND,
X	CONTROL('['),'>',0,		A_GOEND,
X	'>',0,				A_GOEND,
X
X	'0',0,				A_DIGIT,
X	'1',0,				A_DIGIT,
X	'2',0,				A_DIGIT,
X	'3',0,				A_DIGIT,
X	'4',0,				A_DIGIT,
X	'5',0,				A_DIGIT,
X	'6',0,				A_DIGIT,
X	'7',0,				A_DIGIT,
X	'8',0,				A_DIGIT,
X	'9',0,				A_DIGIT,
X
X	'=',0,				A_STAT,
X	CONTROL('G'),0,			A_STAT,
X	'/',0,				A_F_SEARCH,
X	'?',0,				A_B_SEARCH,
X	'n',0,				A_AGAIN_SEARCH,
X	'm',0,				A_SETMARK,
X	'\'',0,				A_GOMARK,
X	CONTROL('X'),CONTROL('X'),0,	A_GOMARK,
X	'E',0,				A_EXAMINE,
X	':','e',0,			A_EXAMINE,
X	CONTROL('X'),CONTROL('V'),0,	A_EXAMINE,
X	'N',0,				A_NEXT_FILE,
X	'P',0,				A_PREV_FILE,
X	':','n',0,			A_NEXT_FILE,
X	':','p',0,			A_PREV_FILE,
X	'-',0,				A_TOGGLE_OPTION,
X	'_',0,				A_DISP_OPTION,
X	'v',0,				A_VISUAL,
X	'!',0,				A_SHELL,
X	'+',0,				A_FIRSTCMD,
X
X	'H',0,				A_HELP,
X	'h',0,				A_HELP,
X	'V',0,				A_VERSION,
X	'q',0,				A_QUIT,
X	':','q',0,			A_QUIT,
X	'Z','Z',0,			A_QUIT
X};
X
Xchar *cmdendtable = cmdtable + sizeof(cmdtable);
X
Xstatic char usertable[MAX_USERCMD];
Xchar *userendtable = usertable;
X
Xstatic char kbuf[MAX_CMDLEN+1];
Xstatic char *kp = kbuf;
X
X/*
X * Decode a command character and return the associated action.
X */
X	public int
Xcmd_decode(c)
X	int c;
X{
X	register int action = A_INVALID;
X
X	/*
X	 * Append the new command character to the command string in kbuf.
X	 */
X	*kp++ = c;
X	*kp = '\0';
X
X#if USERFILE
X	/*
X	 * Look first for any user-defined commands.
X	 */
X	action = cmd_search(usertable, userendtable);
X#endif
X	/*
X	 * If didn't find user-defined command,
X	 * try the normal default commands.
X	 */
X	if (action == A_INVALID)
X		action = cmd_search(cmdtable, cmdendtable);
X
X	if (action != A_PREFIX)
X		/*
X		 * This is not a prefix character.
X		 */
X		noprefix();
X
X	return (action);
X}
X
X/*
X * Indicate that we're not in a prefix command
X * by resetting the command buffer pointer.
X */
X	public void
Xnoprefix()
X{
X	kp = kbuf;
X}
X
X/*
X * Search a command table for the current command string (in kbuf).
X */
X	static int
Xcmd_search(table, endtable)
X	char *table;
X	char *endtable;
X{
X	register char *p;
X	register char *q;
X
X	for (p = table, q = kbuf;  p < endtable;  p++, q++)
X	{
X		if (*p == *q)
X		{
X			/*
X			 * Current characters match.
X			 * If we're at the end of the string, we've found it.
X			 * Return the action code, which is the character
X			 * after the null at the end of the string
X			 * in the command table.
X			 */
X			if (*p == '\0')
X				return (p[1]);
X		} else if (*q == '\0')
X		{
X			/*
X			 * Hit the end of the user's command,
X			 * but not the end of the string in the command table.
X			 * The user's command is incomplete.
X			 */
X			return (A_PREFIX);
X		} else
X		{
X			/*
X			 * Not a match.
X			 * Skip ahead to the next command in the
X			 * command table, and reset the pointer
X			 * to the user's command.
X			 */
X			while (*p++ != '\0') ;
X			q = kbuf-1;
X		}
X	}
X	/*
X	 * No match found in the entire command table.
X	 */
X	return (A_INVALID);
X}
X
X/*
X * Initialize the user command table.
X */
X	public void
Xinit_cmd()
X{
X#if USERFILE
X	char *filename;
X	char *homedir;
X	int f;
X	int n;
X	extern char *getenv();
X
X	/*
X	 * Try to open "$HOME/.less"
X	 * If we can't, return without doing anything.
X	 */
X	homedir = getenv("HOME");
X	if (homedir == NULL)
X		return;
X	filename = calloc(strlen(homedir)+7, sizeof(char));
X	if (filename == NULL)
X		return;
X	sprintf(filename, "%s/%s", homedir, ".less");
X	f = open(filename, 0);
X	free(filename);
X	if (f < 0)
X		return;
X
X	/*
X	 * Read the file into the user table.
X	 * {{ Minimal error checking is done here.
X	 *    A garbage .less file will produce strange results.
X	 *    To avoid a large amount of error checking code here, we
X	 *    rely on the lesskey program to generate a good .less file. }}
X	 */
X	n = read(f, (char *)usertable, MAX_USERCMD);
X	if (n < 3 || usertable[n-2] != '\0')
X	{
X		/*
X		 * Several error cases are lumped together here:
X		 * - Cannot read user file (n < 0).
X		 * - User file is too short (a valid file must
X		 *   have at least 3 chars: one char command string,
X		 *   the terminating null byte, and the action byte).
X		 * - The final entry in the user file is bad (it
X		 *   doesn't have a null byte in the proper place).
X		 * Many other error cases are not caught, such as
X		 * invalid format in any except the last entry,
X		 * invalid action codes, command strings too long, etc.
X		 */
X		error("invalid user key file");
X		n = 0;
X	}
X	userendtable = usertable + n;
X	close(f);
X#endif
X}
END_OF_FILE
echo shar: Extracting \"tags.c\"
sed "s/^X//" >'tags.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "less.h"
X
X#define	WHITESP(c)	((c)==' ' || (c)=='\t')
X
X#if TAGS
X
Xpublic char *tagfile;
Xpublic char *tagpattern;
X
Xstatic char *tags = "tags";
X
Xextern int linenums;
Xextern int sigs;
Xextern char *line;
X
X/*
X * Find a tag in the "tags" file.
X * Sets "tagfile" to the name of the file containing the tag,
X * and "tagpattern" to the search pattern which should be used
X * to find the tag.
X */
X	public int
Xfindtag(tag)
X	register char *tag;
X{
X	register char *p;
X	register FILE *f;
X	register int taglen;
X	int search_char;
X	static char tline[200];
X
X	if ((f = fopen(tags, "r")) == NULL)
X	{
X		error("No tags file");
X		tagfile = NULL;
X		return;
X	}
X
X	taglen = strlen(tag);
X
X	/*
X	 * Search the tags file for the desired tag.
X	 */
X	while (fgets(tline, sizeof(tline), f) != NULL)
X	{
X		if (strncmp(tag, tline, taglen) != 0 || !WHITESP(tline[taglen]))
X			continue;
X
X		/*
X		 * Found it.
X		 * The line contains the tag, the filename and the
X		 * pattern, separated by white space.
X		 * The pattern is surrounded by a pair of identical
X		 * search characters.
X		 * Parse the line and extract these parts.
X		 */
X		tagfile = tagpattern = NULL;
X
X		/*
X		 * Skip over the whitespace after the tag name.
X		 */
X		for (p = tline;  !WHITESP(*p) && *p != '\0';  p++)
X			continue;
X		while (WHITESP(*p))
X			p++;
X		if (*p == '\0')
X			/* File name is missing! */
X			continue;
X
X		/*
X		 * Save the file name.
X		 * Skip over the whitespace after the file name.
X		 */
X		tagfile = p;
X		while (!WHITESP(*p) && *p != '\0')
X			p++;
X		*p++ = '\0';
X		while (WHITESP(*p))
X			p++;
X		if (*p == '\0')
X			/* Pattern is missing! */
X			continue;
X
X		/*
X		 * Save the pattern.
X		 * Skip to the end of the pattern.
X		 * Delete the initial "^" and the final "$" from the pattern.
X		 */
X		search_char = *p++;
X		if (*p == '^')
X			p++;
X		tagpattern = p;
X		while (*p != search_char && *p != '\0')
X			p++;
X		if (p[-1] == '$')
X			p--;
X		*p = '\0';
X
X		fclose(f);
X		return;
X	}
X	fclose(f);
X	error("No such tag in tags file");
X	tagfile = NULL;
X}
X
X/*
X * Search for a tag.
X * This is a stripped-down version of search().
X * We don't use search() for several reasons:
X *   -	We don't want to blow away any search string we may have saved.
X *   -	The various regular-expression functions (from different systems:
X *	regcmp vs. re_comp) behave differently in the presence of 
X *	parentheses (which are almost always found in a tag).
X */
X	public int
Xtagsearch()
X{
X	POSITION pos, linepos;
X	int linenum;
X
X	pos = (POSITION)0;
X	linenum = find_linenum(pos);
X
X	for (;;)
X	{
X		/*
X		 * Get lines until we find a matching one or 
X		 * until we hit end-of-file.
X		 */
X		if (sigs)
X			return (1);
X
X		/*
X		 * Read the next line, and save the 
X		 * starting position of that line in linepos.
X		 */
X		linepos = pos;
X		pos = forw_raw_line(pos);
X		if (linenum != 0)
X			linenum++;
X
X		if (pos == NULL_POSITION)
X		{
X			/*
X			 * We hit EOF without a match.
X			 */
X			error("Tag not found");
X			return (1);
X		}
X
X		/*
X		 * If we're using line numbers, we might as well
X		 * remember the information we have now (the position
X		 * and line number of the current line).
X		 */
X		if (linenums)
X			add_lnum(linenum, pos);
X
X		/*
X		 * Test the line to see if we have a match.
X		 */
X		if (strcmp(tagpattern, line) == 0)
X			break;
X	}
X
X	jump_loc(linepos);
X	return (0);
X}
X
X#endif
END_OF_FILE
echo shar: Extracting \"version.c\"
sed "s/^X//" >'version.c' <<'END_OF_FILE'
X/*
X *		less
X *	Copyright (c) 1984,1985  Mark Nudelman
X *
X *	This program may be freely used and/or modified, 
X *	with the following provisions:
X *	1. This notice and the above copyright notice must remain intact.
X *	2. Neither this program, nor any modification of it,
X *	   may be sold for profit without written consent of the author.
X *
X *	-----------------------------------------------------------------
X *
X *	This program is a paginator similar to "more", 
X *	but allows you to move both forward and backward in the file.  
X *	Commands are based on "more" and "vi".
X *
X *	----------------------- CHANGES ---------------------------------
X *
X *	    Allowed use on standard input		1/29/84   markn
X *	    Added E, N, P commands			2/1/84    markn
X *	    Added '=' command, 'stop' signal handling	4/17/84   markn
X *	    Added line folding				4/20/84   markn
X *	v2: Fixed '=' command to use BOTTOM_PLUS_ONE, 
X *	    instead of TOP, added 'p' & 'v' commands	4/27/84   markn
X *	v3: Added -m and -t options, '-' command	5/3/84    markn
X *	v4: Added LESS environment variable		5/3/84    markn
X *	v5: New comments, fixed '-' command slightly	5/3/84    markn
X *	v6: Added -Q, visual bell			5/15/84   markn
X *	v7: Fixed jump_back(n) bug: n should count real
X *	    lines, not folded lines.  Also allow number
X *	    on G command.				5/24/84   markn
X *	v8: Re-do -q and -Q commands			5/30/84   markn
X *	v9: Added "+<cmd>" argument			9/25/84   markn
X *	v10: Fixed bug in -b<n> argument processing	10/10/84  markn
X *	v11: Made error() ring bell if \n not entered.	10/18/84  markn
X *	-----------------------------------------------------------------
X *	v12: Reorganized signal handling and made
X *	     portable to 4.2bsd.			2/13/85   mark
X *	v13: Reword error message for '-' command.	2/16/85   mark
X *	v14: Added -bf and -bp variants of -b.		2/22/85   mark
X *	v15: Miscellaneous changes.			2/25/85   mark
X *	v16: Added -u flag for backspace processing.	3/13/85   mark
X *	v17: Added j and k commands, 
X *		changed -t default.			4/13/85   mark
X *	v18: Rewrote signal handling code.		4/20/85   mark
X *	v19: Got rid of "verbose" eq_message().		5/2/85    mark
X *	     Made search() scroll in some cases.
X *	v20: Fixed screen.c ioctls for System V.	5/21/85   mark
X *	v21: Fixed some first_cmd bugs.			5/23/85   mark
X *	v22: Added support for no RECOMP nor REGCMP.	5/24/85   mark
X * 	v23: Miscellanous changes and prettying up.	5/25/85   mark
X *		Posted to USENET.
X *	-----------------------------------------------------------------
X *      v24: Added ti,te terminal init & de-init       6/3/85 Mike Kersenbrock
X *	v25: Added -U flag, standout mode underlining.	6/8/85    mark
X *	v26: Added -M flag.				6/9/85    mark
X *	     Use underline termcap (us) if it exists.
X *	v27: Renamed some variables to make unique in	6/15/85   mark
X *	     6 chars.  Minor fix to -m.
X *	v28: Fixed right margin bug.			6/28/85   mark
X *	v29: Incorporated M.Rose's changes to signal.c	6/28/85   mark
X *	v30: Fixed stupid bug in argument processing.	6/29/85   mark
X *	v31: Added -p flag, changed repaint algorithm.  7/15/85   mark
X *	     Added kludge for magic cookie terminals.
X *	v32: Added cat_file if output not a tty.	7/16/85   mark
X *	v33: Added -e flag and EDITOR.			7/23/85   mark
X *	v34: Added -s flag.				7/26/85   mark
X *	v35: Rewrote option handling; added option.c.	7/27/85   mark
X *	v36: Fixed -e flag to work if not last file.	7/29/85   mark
X *	v37: Added -x flag.				8/10/85   mark
X *	v38: Changed prompting; created prompt.c.	8/19/85   mark
X *	v39: (Not -p) does not initially clear screen.	8/24/85   mark
X *	v40: Added "skipping" indicator in forw().	8/26/85   mark
X *		Posted to USENET.
X *	-----------------------------------------------------------------
X *	v41: ONLY_RETURN, control char commands,	9/17/85   mark
X *	     faster search, other minor fixes.
X *	v42: Added ++ command line syntax;		9/25/85   mark
X *	     ch_fsize for pipes.
X *	v43: Added -h flag, changed prim.c algorithms.	10/15/85  mark
X *	v44: Made END print in all cases of eof;	10/16/85  mark
X *	     ignore SIGTTOU after receiving SIGTSTP.
X *	v45: Never print backspaces unless -u.		10/16/85  mark
X *	v46: Backwards scroll in jump_loc.		10/24/85  mark
X *	v47: Fixed bug in edit(): *first_cmd==0		10/30/85  mark
X *	v48: Use TIOCSETN instead of TIOCSETP.		11/16/85  mark
X *	     Added marks (m and ' commands).
X *		Posted to USENET.
X *	-----------------------------------------------------------------
X *	v49: Fixed bug: signal didn't clear mcc.	1/9/86    mark
X *	v50: Added ' (quote) to gomark.			1/15/86   mark
X *	v51: Added + cmd, fixed problem if first_cmd
X *	     fails, made g cmd sort of "work" on pipes
X *	     even if bof is no longer buffered.		1/16/86   mark
X *	v52: Made short files work better.		1/17/86   mark
X *	v53: Added -P option.				1/20/86   mark
X *	v54: Changed help to use HELPFILE.		1/20/86   mark
X *	v55: Messages work better if not tty output.	1/23/86   mark
X *	v56: Added -l option.				1/24/86   mark
X *	v57: Fixed -l to get confirmation before
X *	     overwriting an existing file.		1/31/86   mark
X *	v58: Added filename globbing.			8/28/86   mark
X *	v59: Fixed some bugs with very long filenames.	9/15/86   mark
X *	v60: Incorporated changes from Leith (Casey)
X *	     Leedom for boldface and -z option.		9/26/86   mark
X *	v61: Got rid of annoying repaints after ! cmd.	9/26/86   mark
X *		Posted to USENET.
X *	-----------------------------------------------------------------
X *	v62: Added is_directory(); change -z default to
X *	     -1 instead of 24; cat-and-exit if -e and
X *	     file is less than a screenful.		12/23/86  mark
X *	v63: Fixed bug in cat-and-exit if > 1 file.	1/8/87    mark
X *	v64: Changed puts/putstr, putc/putchr, 
X *	     getc/getchr to avoid name conflict with 
X *	     stdio functions.				1/12/87  mark
X *	v65: Allowed '-' command to change NUMBER
X *	     valued options (thanks to Gary Puckering)	1/26/87  mark
X *	v66: Fixed bug: prepaint should use force=1.	2/13/87  mark
X *	v67: Added !! and % expansion to ! command.	2/24/87  mark
X *	v68: Added SIGWINCH and TIOCGWINSZ support;
X *	     changed is_directory to bad_file.
X *	     (thanks to J. Robert Ward)			2/25/87  mark
X *	v69: Added SIGWIND and WIOCGETD (for Unix PC).	2/25/87  mark
X *	v70: Changed help cmd from 'h' to 'H'; better 
X *	     error msgs in bad_file, errno_message.	3/13/87  mark
X *	v71: Changed -p to -c, made triple -c/-C
X *	     for clear-eol like more's -c.		5/11/87  mark
X *	v72: Added -E, -L, use $SHELL in lsystem().	6/26/87  mark
X *	     (thanks to Steve Spearman)
X *	v73: Allow Examine "#" for previous file.	6/26/87  mark
X *		Posted to USENET 8/25/87.
X *	-----------------------------------------------------------------
X *	v74: Fix conflict in EOF symbol with stdio.h,	9/18/87  mark
X *	     Make os.c more portable to BSD.
X *	v75: Fix problems in get_term (thanks to 	9/23/87  mark
X *	     Paul Eggert); new backwards scrolling in
X *	     jump_loc (thanks to Marion Hakanson).
X *	v76: Added -i flag; allow single "!" to		9/23/87  mark
X *	     invoke a shell (thanks to Franco Barber).
X *	v77: Added -n flag and line number support.	9/24/87  mark
X *	v78: Fixed problem with prompts longer than	9/25/87  mark
X *	     the screen width.	
X *	v79: Added the _ command.			9/29/87  mark
X *	v80: Allow signal to break out of linenum scan.	10/6/87  mark
X *	v81: Allow -b to be changed from within less.	10/6/87  mark
X *	v82: Add cmd_decode to use a table for key	10/7/87  mark
X *	     binding (thanks to David Nason).
X *	v83: Allow .less file for user-defined keys.	10/9/87  mark
X *	v84: Fix -e/-E problems (thanks to Felix Lee).	10/11/87 mark
X *	v85: Search now keeps track of line numbers.	10/15/87 mark
X *	v86: Added -B option and autobuf; fixed		10/20/87 mark
X *	     "pipe error" bug.
X *	v87: Fix bug re BSD signals while reading file.	3/1/88   mark
X *	v88: Use new format for -P option (thanks to	3/12/88  mark
X *	     der Mouse), allow "+-c" without message,
X *	     fix bug re BSD hangup.
X *	v89: Turn off line numbers if linenum scan	3/18/88  mark
X *	     is interrupted.
X *	v90: Allow -P from within less.			3/30/88  mark
X *	v91: Added tags file support (new -t option)	3/30/88  mark
X *	     (thanks to Brian Campbell).
X *	v92: Added -+option syntax.			4/4/88   mark
X *	v93: Add support for slow input (thanks to	4/11/88  mark
X *	     Joe Orost & apologies for taking almost
X *	     3 years to get this in!)
X *	v94: Redo reading/signal stuff.			4/11/88  mark
X *	v95: Repaint screen better after signal.	4/20/88  mark
X *	v96: Add /! and ?! commands.			4/21/88  mark
X *	v97: Allow -l/-L from within less.		5/17/88  mark
X *	     Eliminate some static arrays (use calloc).
X */
X
Xchar version[] = "@(#) less  version 97";
END_OF_FILE
echo shar: Extracting \"less.man\"
sed "s/^X//" >'less.man' <<'END_OF_FILE'
X
X
X
X     LLLLEEEESSSSSSSS((((1111))))                     UUUUNNNNIIIIXXXX 5555....0000                      LLLLEEEESSSSSSSS((((1111))))
X
X
X
X     NNNNAAAAMMMMEEEE
X          less - opposite of more
X
X     SSSSYYYYNNNNOOOOPPPPSSSSIIIISSSS
X          lllleeeessssssss [[[[----[[[[++++]]]]aaaaAAAABBBBccccCCCCddddeeeeEEEEiiiimmmmMMMMnnnnqqqqQQQQuuuuUUUUsssswwww]]]] [[[[----bbbb_N]]]] [[[[----hhhh_N]]]] [[[[----xxxx_N]]]] [[[[----[[[[zzzz]]]]_N]]]]
X               [[[[----PPPP[[[[mmmmMMMM====]]]]_s_t_r_i_n_g]]]] [[[[----[[[[llllLLLL]]]]_l_o_g_f_i_l_e]]]] [[[[++++_c_m_d]]]]
X               [[[[----tttt_t_a_g]]]] [[[[_f_i_l_e_n_a_m_e]]]]............
X
X     DDDDEEEESSSSCCCCRRRRIIIIPPPPTTTTIIIIOOOONNNN
X          _L_e_s_s is a program similar to _m_o_r_e (1), but which allows
X          backwards movement in the file as well as forward movement.
X          Also, _l_e_s_s does not have to read the entire input file
X          before starting, so with large input files it starts up
X          faster than text editors like _v_i (1).  _L_e_s_s uses termcap (or
X          terminfo on some systems), so it can run on a variety of
X          terminals.  There is even limited support for hardcopy
X          terminals.  (On a hardcopy terminal, lines which should be
X          printed at the top of the screen are prefixed with an up-
X          arrow.)
X
X          Commands are based on both _m_o_r_e and _v_i. Commands may be
X          preceeded by a decimal number, called N in the descriptions
X          below.  The number is used by some commands, as indicated.
X
X
X     CCCCOOOOMMMMMMMMAAAANNNNDDDDSSSS
X          In the following descriptions, ^X means control-X.  ESC
X          stands for the ESCAPE key; for example ESC-v means the two
X          character sequence "ESCAPE", then "v".
X
X          H    Help: display a summary of these commands.  If you
X               forget all the other commands, remember this one.
X
X          SPACE or f or ^F or ^V
X               Scroll forward N lines, default one window (see option
X               -z below).  If N is more than the screen size, only the
X               final screenful is displayed.  Warning: some systems
X               use ^V as a special literalization character.
X
X          b or ^B or ESC-v
X               Scroll backward N lines, default one window (see option
X               -z below).  If N is more than the screen size, only the
X               final screenful is displayed.
X
X          RETURN or ^N or e or ^E or j or ^J
X               Scroll forward N lines, default 1.  The entire N lines
X               are displayed, even if N is more than the screen size.
X
X          y or ^Y or ^P or k or ^K
X               Scroll backward N lines, default 1.  The entire N lines
X               are displayed, even if N is more than the screen size.
X               Warning: some systems use ^Y as a special job control
X
X
X
X     Page 1                                          (printed 7/19/88)
X
X
X
X
X
X
X     LLLLEEEESSSSSSSS((((1111))))                     UUUUNNNNIIIIXXXX 5555....0000                      LLLLEEEESSSSSSSS((((1111))))
X
X
X
X               character.
X
X          d or ^D
X               Scroll forward N lines, default one half of the screen
X               size.  If N is specified, it becomes the new default
X               for subsequent d and u commands.
X
X          u or ^U
X               Scroll backward N lines, default one half of the screen
X               size.  If N is specified, it becomes the new default
X               for subsequent d and u commands.
X
X          r or ^R or ^L
X               Repaint the screen.
X
X          R    Repaint the screen, discarding any buffered input.
X               Useful if the file is changing while it is being
X               viewed.
X
X          g or < or ESC-<
X               Go to line N in the file, default 1 (beginning of
X               file).  (Warning: this may be slow if N is large.)
X
X          G or > or ESC->
X               Go to line N in the file, default the end of the file.
X               (Warning: this may be slow if N is large, or if N is
X               not specified and standard input, rather than a file,
X               is being read.)
X
X          p or %
X               Go to a position N percent into the file.  N should be
X               between 0 and 100.  (This works if standard input is
X               being read, but only if _l_e_s_s has already read to the
X               end of the file.  It is always fast, but not always
X               useful.)
X
X          m    Followed by any lowercase letter, marks the current
X               position with that letter.
X
X          '    (Single quote.) Followed by any lowercase letter,
X               returns to the position which was previously marked
X               with that letter.  Followed by another single quote,
X               returns to the postion at which the last "large"
X               movement command was executed.  All marks are lost when
X               a new file is examined.
X
X          ^X^X Same as single quote.
X
X          /pattern
X               Search forward in the file for the N-th line containing
X               the pattern.  N defaults to 1.  The pattern is a
X               regular expression, as recognized by _e_d. The search
X
X
X
X     Page 2                                          (printed 7/19/88)
X
X
X
X
X
X
X     LLLLEEEESSSSSSSS((((1111))))                     UUUUNNNNIIIIXXXX 5555....0000                      LLLLEEEESSSSSSSS((((1111))))
X
X
X
X               starts at the second line displayed (but see the -a
X               option, which changes this).
X
X          ?pattern
X               Search backward in the file for the N-th line
X               containing the pattern.  The search starts at the line
X               immediately before the top line displayed.
X
X          /!pattern
X               Like /, but the search is for the N-th line which does
X               NOT contain the pattern.
X
X          ?!pattern
X               Like ?, but the search is for the N-th line which does
X               NOT contain the pattern.
X
X          n    Repeat previous search, for N-th line containing the
X               last pattern (or NOT containing the last pattern, if
X               the previous search was /! or ?!).
X
X          E [filename]
X               Examine a new file.  If the filename is missing, the
X               "current" file (see the N and P commands below) from
X               the list of files in the command line is re-examined.
X               If the filename is a pound sign (#), the previously
X               examined file is re-examined.
X
X          ^X^V or :e
X               Same as E.  Warning: some systems use ^V as a special
X               literalization character.
X
X          N or :n
X               Examine the next file (from the list of files given in
X               the command line).  If a number N is specified (not to
X               be confused with the command N), the N-th next file is
X               examined.
X
X          P or :p
X               Examine the previous file.  If a number N is specified,
X               the N-th previous file is examined.
X
X          = or ^G
X               Prints some information about the file being viewed,
X               including its name and the line number and byte offset
X               of the bottom line being displayed.  If possible, it
X               also prints the length of the file and the percent of
X               the file above the last displayed line.
X
X          -    Followed by one of the command line option letters (see
X               below), this will change the setting of that option and
X               print a message describing the new setting.  If the
X               option letter has a numeric value (such as -b or -h),
X
X
X
X     Page 3                                          (printed 7/19/88)
X
X
X
X
X
X
X     LLLLEEEESSSSSSSS((((1111))))                     UUUUNNNNIIIIXXXX 5555....0000                      LLLLEEEESSSSSSSS((((1111))))
X
X
X
X               or a string value (such as -P or -t), a new value may
X               be entered after the option letter.
X
X          _    (Underscore.) Followed by one of the command line
X               option letters (see below), this will print a message
X               describing the current setting of that option.  The
X               setting of the option is not changed.
X
X          +cmd Causes the specified cmd to be executed each time a new
X               file is examined.  For example, +G causes _l_e_s_s to
X               initially display each file starting at the end rather
X               than the beginning.
X
X          V    Prints the version number of _l_e_s_s being run.
X
X          q or :q or ZZ
X               Exits _l_e_s_s.
X
X          The following two commands may or may not be valid,
X          depending on your particular installation.
X
X          v    Invokes an editor to edit the current file being
X               viewed.  The editor is taken from the environment
X               variable EDITOR, or defaults to "vi".
X
X          ! shell-command
X               Invokes a shell to run the shell-command given.  A
X               percent sign in the command is replaced by the name of
X               the current file.  "!!" repeats the last shell command.
X               "!" with no shell command simply invokes a shell.  In
X               all cases, the shell is taken from the environment
X               variable SHELL, or defaults to "sh".
X
X     OOOOPPPPTTTTIIIIOOOONNNNSSSS
X          Command line options are described below.  Most options may
X          be changed while _l_e_s_s is running, via the "-" command.
X
X          Options are also taken from the environment variable "LESS".
X          For example, to avoid typing "less -options ..." each time
X          _l_e_s_s is invoked, you might tell _c_s_h:
X
X          setenv LESS "-options"
X
X          or if you use _s_h:
X
X          LESS="-options"; export LESS
X
X          The environment variable is parsed before the command line,
X          so command line options override the LESS environment
X          variable.  If an option appears in the LESS variable, it can
X          be reset to its default on the command line by beginning the
X          command line option with "-+".
X
X
X
X     Page 4                                          (printed 7/19/88)
X
X
X
X
X
X
X     LLLLEEEESSSSSSSS((((1111))))                     UUUUNNNNIIIIXXXX 5555....0000                      LLLLEEEESSSSSSSS((((1111))))
X
X
X
X          A dollar sign ($) may be used to signal the end of an option
X          string.  This is important only for options like -P which
X          take a following string.
X
X          -a   Normally, forward searches start just after the top
X               displayed line (that is, at the second displayed line).
X               Thus, forward searches include the currently displayed
X               screen.  The -a option causes forward searches to start
X               just after the bottom line displayed, thus skipping the
X               currently displayed screen.
X
X          -A   The -A option causes searches to start at the second
X               SCREEN line displayed, as opposed to the default which
X               is to start at the second REAL line displayed.  For
X               example, suppose a long real line occupies the first
X               three screen lines.  The default search will start at
X               the second real line (the fourth screen line), while
X               the -A option will cause the search to start at the
X               second screen line (in the midst of the first real
X               line).  (This option is rarely useful.)
X
X          -b   The -b_n option tells _l_e_s_s to use a non-standard number
X               of buffers.  Buffers are 1K, and normally 10 buffers
X               are used (except if data in coming from standard input;
X               see the -B option).  The number _n specifies a different
X               number of buffers to use.
X
X          -B   Normally, when data is coming from standard input,
X               buffers are allocated automatically as needed, to avoid
X               loss of data.  The -B option disables this feature, so
X               that only the default number of buffers are used.  If
X               more data is read than will fit in the buffers, the
X               oldest data is discarded.
X
X          -c   Normally, _l_e_s_s will repaint the screen by scrolling
X               from the bottom of the screen.  If the -c option is
X               set, when _l_e_s_s needs to change the entire display, it
X               will paint from the top line down.
X
X          -C   The -C option is like -c, but the screen is cleared
X               before it is repainted.
X
X          -d   Normally, _l_e_s_s will complain if the terminal is dumb;
X               that is, lacks some important capability, such as the
X               ability to clear the screen or scroll backwards.  The
X               -d option suppresses this complaint (but does not
X               otherwise change the behavior of the program on a dumb
X               terminal).
X
X          -e   Normally the only way to exit less is via the "q"
X               command.  The -e option tells less to automatically
X               exit the second time it reaches end-of-file.
X
X
X
X     Page 5                                          (printed 7/19/88)
X
X
X
X
X
X
X     LLLLEEEESSSSSSSS((((1111))))                     UUUUNNNNIIIIXXXX 5555....0000                      LLLLEEEESSSSSSSS((((1111))))
X
X
X
X          -E   The -E flag causes less to exit the first time it
X               reaches end-of-file.
X
X          -h   Normally, _l_e_s_s will scroll backwards when backwards
X               movement is necessary.  The -h option specifies a
X               maximum number of lines to scroll backwards.  If it is
X               necessary to move backwards more than this many lines,
X               the screen is repainted in a forward direction.  (If
X               the terminal does not have the ability to scroll
X               backwards, -h0 is implied.)
X
X          -i   The -i option causes searches to ignore case; that is,
X               uppercase and lowercase are considered identical.
X               Also, text which is overstruck or underlined can be
X               searched for.
X
X          -l   The -l option, followed immediately by a filename, will
X               cause _l_e_s_s to copy its input to the named file as it is
X               being viewed.  This applies only when the input file is
X               a pipe, not an ordinary file.  If the file already
X               exists, less will ask for confirmation before
X               overwriting it.
X
X          -L   The -L option is like -l, but it will overwrite an
X               existing file without asking for confirmation.
X
X               If no log file has been specified, the -l and -L
X               options can be used from within less to specify a log
X               file.  Without a file name, they will simply report the
X               name of the log file.
X
X          -m   Normally, _l_e_s_s prompts with a colon.  The -m option
X               causes _l_e_s_s to prompt verbosely (like _m_o_r_e), with the
X               percent into the file.
X
X          -M   The -M option causes _l_e_s_s to prompt even more verbosely
X               than _m_o_r_e.
X
X          -n   The -n flag suppresses line numbers.  The default (to
X               use line numbers) may cause _l_e_s_s to run more slowly in
X               some cases, especially with a very large input file.
X               Suppressing line numbers with the -n flag will avoid
X               this problem.  Using line numbers means: the line
X               number will be displayed in the verbose prompt and in
X               the = command, and the v command will pass the current
X               line number to the editor.
X
X          -P   The -P option provides a way to tailor the three prompt
X               styles to your own preference.  You would normally put
X               this option in your LESS environment variable, rather
X               than type it in with each less command.  Such an option
X               must either be the last option in the LESS variable, or
X
X
X
X     Page 6                                          (printed 7/19/88)
X
X
X
X
X
X
X     LLLLEEEESSSSSSSS((((1111))))                     UUUUNNNNIIIIXXXX 5555....0000                      LLLLEEEESSSSSSSS((((1111))))
X
X
X
X               be terminated by a dollar sign.  -P followed by a
X               string changes the default (short) prompt to that
X               string.  -Pm changes the medium (-m) prompt to the
X               string, and -PM changes the long (-M) prompt.  Also,
X               -P= changes the message printed by the = command to the
X               given string.  All prompt strings consist of a sequence
X               of letters and special escape sequences.  See the
X               section on PROMPTS for more details.
X
X          -q   Normally, if an attempt is made to scroll past the end
X               of the file or before the beginning of the file, the
X               terminal bell is rung to indicate this fact.  The -q
X               option tells _l_e_s_s not to ring the bell at such times.
X               If the terminal has a "visual bell", it is used
X               instead.
X
X          -Q   Even if -q is given, _l_e_s_s will ring the bell on certain
X               other errors, such as typing an invalid character.  The
X               -Q option tells _l_e_s_s to be quiet all the time; that is,
X               never ring the terminal bell.  If the terminal has a
X               "visual bell", it is used instead.
X
X          -s   The -s option causes consecutive blank lines to be
X               squeezed into a single blank line.  This is useful when
X               viewing _n_r_o_f_f output.
X
X          -t   The -t option, followed immediately by a TAG, will edit
X               the file containing that tag.  For this to work, there
X               must be a file called "tags" in the current directory,
X               which was previously built by the _c_t_a_g_s (1) command.
X               This option may also be specified from within less
X               (using the - command) as a way of examining a new file.
X
X          -u   If the -u option is given, backspaces are treated as
X               printable characters; that is, they are sent to the
X               terminal when they appear in the input.
X
X          -U   If the -U option is given, backspaces are printed as
X               the two character sequence "^H".
X
X               If neither -u nor -U is given, backspaces which appear
X               adjacent to an underscore character are treated
X               specially: the underlined text is displayed using the
X               terminal's hardware underlining capability.  Also,
X               backspaces which appear between two identical
X               characters are treated specially: the overstruck text
X               is printed using the terminal's hardware boldface
X               capability.  Other backspaces are deleted, along with
X               the preceeding character.
X
X          -w   Normally, _l_e_s_s uses a tilde character to represent
X               lines past the end of the file.  The -w option causes
X
X
X
X     Page 7                                          (printed 7/19/88)
X
X
X
X
X
X
X     LLLLEEEESSSSSSSS((((1111))))                     UUUUNNNNIIIIXXXX 5555....0000                      LLLLEEEESSSSSSSS((((1111))))
X
X
X
X               blank lines to be used instead.
X
X          -x   The -x_n option sets tab stops every _n positions.  The
X               default for _n is 8.
X
X          -[z] When given a backwards or forwards window command, _l_e_s_s
X               will by default scroll backwards or forwards one
X               screenful of lines. The -z_n option changes the default
X               scrolling window size to _n lines.  Note that the "z" is
X               optional for compatibility with _m_o_r_e.
X
X          +    If a command line option begins with ++++, the remainder
X               of that option is taken to be an initial command to
X               _l_e_s_s. For example, +G tells _l_e_s_s to start at the end of
X               the file rather than the beginning, and +/xyz tells it
X               to start at the first occurence of "xyz" in the file.
X               As a special case, +<number> acts like +<number>g; that
X               is, it starts the display at the specified line number
X               (however, see the caveat under the "g" command above).
X               If the option starts with ++++++++, the initial command
X               applies to every file being viewed, not just the first
X               one.  The + command described previously may also be
X               used to set (or change) an initial command for every
X               file.
X
X
X     KKKKEEEEYYYY BBBBIIIINNNNDDDDIIIINNNNGGGGSSSS
X          You may define your own less commands by using the program
X          _l_e_s_s_k_e_y (1) to create a file called ".less" in your home
X          directory.  This file specifies a set of command keys and an
X          action associated with each key.  See the _l_e_s_s_k_e_y manual
X          page for more details.
X
X
X     PPPPRRRROOOOMMMMPPPPTTTTSSSS
X          The -P option allows you to tailor the prompt to your
X          preference.  The string given to the -P option replaces the
X          specified prompt string.  Certain characters in the string
X          are interpreted specially.  The prompt mechanism is rather
X          complicated to provide flexibility, but the ordinary user
X          need not understand the details of constructing personalized
X          prompt strings.
X
X          A percent sign followed by a single character is expanded
X          according to what the following character is:
X
X          %bX  Replaced by the byte offset into the current input
X               file.  The b is followed by a single character (shown
X               as X above) which specifies the line whose byte offset
X               is to be used.  If the character is a "t", the byte
X               offset of the top line in the display is used, an "m"
X               means use the middle line, a "b" means use the bottom
X
X
X
X     Page 8                                          (printed 7/19/88)
X
X
X
X
X
X
X     LLLLEEEESSSSSSSS((((1111))))                     UUUUNNNNIIIIXXXX 5555....0000                      LLLLEEEESSSSSSSS((((1111))))
X
X
X
X               line, and a "B" means use the line just after the
X               bottom line.
X
X          %f   Replaced by the name of the current input file.
X
X          %i   Replaced by the index of the current file in the list
X               of input files.
X
X          %lX  Replaced by the line number of a line in the input
X               file.  The line to be used is determined by the X, as
X               with the %b option.
X
X          %m   Replaced by the total number of input files.
X
X          %pX  Replaced by the percent into the current input file.
X               The line used is determined by the X as with the %b
X               option.
X
X          %s   Replaced by the size of the current input file.
X
X          %t   Causes any trailing spaces to be removed.  Usually used
X               at the end of the string, but may appear anywhere.
X
X          %x   Replaced by the name of the next input file in the
X               list.
X
X          If any item is unknown (for example, the file size if input
X          is a pipe), a question mark is printed instead.
X
X          The format of the prompt string can be changed depending on
X          certain conditions.  A question mark followed by a single
X          character acts like an "IF": depending on the following
X          character, a condition is evaluated.  If the condition is
X          true, any characters following the question mark and
X          condition character, up to a period, are included in the
X          prompt.  If the condition is false, such characters are not
X          included.  A colon appearing between the question mark and
X          the period can be used to establish an "ELSE": any
X          characters between the colon and the period are included in
X          the string if and only if the IF condition is false.
X          Condition characters (which follow a question mark) may be:
X
X          ?a   True if any characters have been included in the prompt
X               so far.
X
X          ?bX  True if the byte offset of the specified line is known.
X
X          ?e   True if at end-of-file.
X
X          ?f   True if there is an input filename (that is, if input
X               is not a pipe).
X
X
X
X
X     Page 9                                          (printed 7/19/88)
X
X
X
X
X
X
X     LLLLEEEESSSSSSSS((((1111))))                     UUUUNNNNIIIIXXXX 5555....0000                      LLLLEEEESSSSSSSS((((1111))))
X
X
X
X          ?lX  True if the line number of the specified line is known.
X
X          ?m   True if there is more than one input file.
X
X          ?n   True if this is the first prompt in a new input file.
X
X          ?pX  True if the percent into the current input file of the
X               specified line is known.
X
X          ?s   True if the size of current input file is known.
X
X          ?x   True if there is a next input file (that is, if the
X               current input file is not the last one).
X
X          Any characters other than the special ones (question mark,
X          colon, period, percent, and backslash) become literally part
X          of the prompt.  Any of the special characters may be
X          included in the prompt literally by preceeding it with a
X          backslash.
X
X          Some examples:
X
X          ?f%f:Standard input.
X
X          This prompt prints the filename, if known; otherwise the
X          string "Standard input".
X
X          ?f%f .?ltLine %lt:?pt%pt:?btByte %bt:-...
X
X          This prompt would print the filename, if known.  The
X          filename is followed by the line number, if known, otherwise
X          the percent if known, otherwise the byte offset if known.
X          Otherwise, a dash is printed.  Notice how each question mark
X          has a matching period, and how the % after the %pt is
X          included literally by escaping it with a backslash.
X
X          ?n?f%f .?m(file %i of %m) ..?e(END) ?x- Next\: %x..%t
X
X          This prints the filename if this is the first prompt in a
X          file, followed by the "file N of N" message if there is more
X          than one input file.  Then, if we are at end-of-file, the
X          string "(END)" is printed followed by the name of the next
X          file, if there is one.  Finally, any trailing spaces are
X          truncated.  This is the default prompt.  For reference, here
X          are the defaults for the other two prompts (-m and -M
X          respectively).  Each is broken into two lines here for
X          readability only.
X
X          ?n?f%f .?m(file %i of %m) ..?e(END) ?x- Next\: %x.:
X               ?pB%pB\%:byte %bB?s/%s...%t
X
X          ?f%f .?n?m(file %i of %m) ..?ltline %lt :byte %bB?s/%s ..
X
X
X
X     Page 10                                         (printed 7/19/88)
X
X
X
X
X
X
X     LLLLEEEESSSSSSSS((((1111))))                     UUUUNNNNIIIIXXXX 5555....0000                      LLLLEEEESSSSSSSS((((1111))))
X
X
X
X               ?e(END) ?x- Next\: %x.:?pB%pB\%..%t
X
X          And here is the default message produced by the = command:
X
X          ?f%f .?m(file %i of %m) .?ltline %lt .
X               byte %bB?s/%s. ?e(END) :?pB%pB\%..%t
X
X
X     SSSSEEEEEEEE AAAALLLLSSSSOOOO
X          lesskey(1)
X
X
X     WWWWAAAARRRRNNNNIIIINNNNGGGGSSSS
X          The = command and prompts (unless changed by -P) report the
X          line number of the line at the top of the screen, but the
X          byte and percent of the line at the bottom of the screen.
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X     Page 11                                         (printed 7/19/88)
X
X
X
END_OF_FILE
echo shar: Extracting \"README\"
sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is the distribution of "less", a paginator similar to "more" or "pg".
XThe manual page is in less.man (nroff source in less.nro).
X
XINSTALLATION:
X
X1. Move the distributed source to its own directory and 
X   unpack it by running "sh" on the distribution files,
X   if you have not already done so.
X
X2. Type "sh linstall" and answer the questions it asks.
X   This will generate a makefile and a defines.h.
X
X   If you choose not to include some features in your version,
X   you may wish to edit the manual page "less.nro" and the help
X   page "less.help" to remove the references to the appropriate 
X   commands or options.
X
X3. It is a good idea to look over the generated makefile 
X   and make sure it looks ok.
X
X4. Type "make" and watch the fun.
X
X5. If the make succeeds, it will generate a program "less"
X   in your current directory.  Test the generated program.
X
X6. When satisfied that it works, if you wish to install it
X   in a public place, type "make install".
X
XIf you have any problems building or running "less", 
Xsuggestions, complaints, etc., you may mail to the 
Xauthor via USENET at:
X	sun	 \
X	decwrl	  } !pyramid!ctnews!UNIX386!mark
X	hplabs   /
X
X
XNote to hackers: comments noting possible improvements are enclosed
Xin double curly brackets {{ like this }}.
END_OF_FILE
echo shar: Extracting \"less.help\"
sed "s/^X//" >'less.help' <<'END_OF_FILE'
X      Commands marked with * may be preceeded by a number, N.
X
X  H              Display this help.
X  q              Exit.
X
X  f, SPACE    *  Forward  N lines, default one screen.
X  b           *  Backward N lines, default one screen.
X  e, j, CR    *  Forward  N lines, default 1 line.
X  y, k        *  Backward N lines, default 1 line.
X  d           *  Forward  N lines, default half screen or last N to d/u.
X  u           *  Backward N lines, default half screen or last N to d/u.
X  r              Repaint screen.
X  R              Repaint screen, discarding buffered input.
X
X  /pattern    *  Search forward for N-th line containing the pattern.
X  ?pattern    *  Search backward for N-th line containing the pattern.
X  n           *  Repeat previous search (for N-th occurence).
X
X  g           *  Go to line N, default 1.
X  G           *  Like g, but default is last line in file.
X  p, %        *  Position to N percent into the file.
X  m<letter>      Mark the current position with <letter>.
X  '<letter>      Return to a previously marked position.
X  ''             Return to previous position.
X
X  E [file]       Examine a new file.
X  N           *  Examine the next file (from the command line).
X  P           *  Examine the previous file (from the command line).
X  =              Print current file name.
X  V              Print version number of "less".
X
X  -<flag>        Toggle a command line flag.
X  _<flag>        Display the setting of a command line flag.
X  +cmd           Execute the less cmd each time a new file is examined.
X
X  !command       Passes the command to the system to be executed (by $SHELL).
X  v              Edit the current file (with $EDITOR).
END_OF_FILE
echo shar: Extracting \"mkfuncs.awk\"
sed "s/^X//" >'mkfuncs.awk' <<'END_OF_FILE'
XBEGIN { FS="("; state = 0 }
X
X/^	public/ { ftype = $0; state = 1 }
X
X{ if (state == 1)
X	state = 2
X  else if (state == 2)
X	{ print ftype,$1,"();"; state = 0 }
X}
END_OF_FILE


