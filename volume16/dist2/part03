Subject:  v16i036:  Larry Wall's Configure generator, etc., Part03/07
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: lwall@jpl-devvax.jpl.nasa.gov (Larry Wall)
Posting-number: Volume 16, Issue 36
Archive-name: dist/part03

#! /bin/sh

# Make a new directory for the dist sources, cd to it, and run kits 1
# thru 7 through sh.  When all 7 kits have been run, read README.

echo "This is dist 2.0 kit 3 (of 7).  If kit 3 is complete, the line"
echo '"'"End of kit 3 (of 7)"'" will echo at the end.'
echo ""
export PATH || (echo "You didn't use sh, you clunch." ; kill $$)
mkdir kit mcon mcon/U pat 2>/dev/null
echo Extracting kit/makedist.SH
sed >kit/makedist.SH <<'!STUFFY!FUNK!' -e 's/X//'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X	echo "Using config.sh from above..."
X    fi
X    . ./config.sh
X    ;;
Xesac
Xecho "Extracting makedist (with variable substitutions)"
X: This section of the file will have variable substitutions done on it.
X: Move anything that needs config subs from !NO!SUBS! section to !GROK!THIS!.
X: Protect any dollar signs and backticks that you do not want interpreted
X: by putting a backslash in front.
Xcat >makedist <<!GROK!THIS!
X#!/usr/bin/perl
X	eval "exec /usr/bin/perl -S \$0 \$*"
X		if \$running_under_some_shell;
X
X# $Header: makedist.SH,v 2.0 88/06/28 23:12:17 lwall Locked $
X#
X# $Log:	makedist.SH,v $
X# Revision 2.0  88/06/28  23:12:17  lwall
X# Baseline.
X# 
X
X\$DIST='`pwd`';
X\$ENV{'DIST'} = \$DIST;
X!GROK!THIS!
X
X: In the following dollars and backticks do not need the extra backslash.
X$spitshell >>makedist <<'!NO!SUBS!'
X
Xdo 'getopt.pl';
Xdo Getopt("s");
X
X$MAXKITSIZE = 50000 unless $MAXKITSIZE = $opt_s;
X$KITOVERHEAD = 1700;
X$FILEOVERHEAD = 90;
X$NEWMANI = 'MANIFEST.new';
X$MANI = 'MANIFEST';
X
Xdo readpackage();
X
X$ENV{'package'} = $package;
X$ENV{'baserev'} = $baserev;
X
Xunlink <$package.kit? $package.kit??>;
X
Xdo manifake();
X
Xsub manifake {
X    # make MANIFEST and MANIFEST.new say the same thing
X    if (! -f $NEWMANI) {
X	if (-f $MANI) {
X	    open(IN,$MANI) || die "Can't open $MANI";
X	    open(OUT,">$NEWMANI") || die "Can't create $NEWMANI";
X	    while (<IN>) {
X		next if 1 .. /---/;
X		s/(\s+)[0-9]*\s*/$1/;
X	    }
X	    close IN; close OUT;
X	}
X	else {
Xdie "You need to make a MANIFEST.new file, with names and descriptions.\n";
X	}
X    }
X}
X
Xdo kitlists();
X
Xsub kitlists {
X    open(IN,$NEWMANI) || die "Can't open $NEWMANI";
X    @files = <IN>;
X    close IN;
X    for (@files) {
X	s/\s.*\n//;
X	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
X	   $blksize,$blocks) = stat($_);
X	$size += 1000000 if /README/;
X	$size{$_} = $size;
X    }
X
X    sub revnum { $size{$a} < $size{$b} ? 1 : $size{$a} > $size{$b} ? -1 : 0; }
X    @files = sort revnum @files;
X
X    for (@files) {
X	$size = $size{$_};
X	$size -= 1000000 if /README/;
X	$i=1;
X	while (($newtot = int($tot[$i] + $size + $size/40 + $FILEOVERHEAD)) >
X	    $MAXKITSIZE-$KITOVERHEAD && $tot[$i]) {
X	      $i++;
X	}
X	$tot[$i] = $newtot;
X	print "Adding $_ to kit $i giving $newtot bytes\n" if $opt_v;
X	$kit{$_} = $i;
X	$list[$i] .= " $_";
X    }
X}
X
Xdo manimake();
X
X# make MANIFEST and MANIFEST.new say the same thing
Xsub manimake {
X    die "You don't have a $NEWMANI file.  Run manifake.\n"
X	unless -f "$NEWMANI";
X    open(NEWMANI,$NEWMANI) || die "Can't read $NEWMANI";
X    while (<NEWMANI>) {
X	($key,$val) = ($_,'') unless ($key,$val) = /^(\S+)\s+(.*)/;
X	$comment{$key} = $val;
X    }
X    close NEWMANI;
X
X    open(MANI,">$MANI") || die "Can't create $MANI.\n";
X    print MANI
X"After all the $package kits are run you should have the following files:
X
XFilename		Kit Description
X--------		--- -----------
X";
X    for (sort keys(comment)) {
X	printf MANI "%-24s%2s %s\n",$_,$kit{$_},$comment{$_};
X    }
X    close MANI;
X}
X
X$numkits = $#list;
Xif ($numkits > 9) {
X    $sp = '%02d';
X}
Xelse {
X    $sp = '%d';
X}
X
Xfor ($kitnum = 1; $kitnum <= $numkits; $kitnum++) {
X    $list = $list[$kitnum];
X    $kit = sprintf("$package.kit" . $sp,$kitnum);
X    print "*** Making $kit ***\n" if $opt_v;
X    open(KIT,">$kit") || die "Can't create $kit.\n";
X
X    do kitleader();
X
X    @files = split(' ',$list);
X    reset 'X';
X    for $file (@files) {
X	$_ = $file;
X	while (s|^(.*)/.*$|$1|) {
X	    push(@Xdirs,$_) unless $Xseen{$_}++;
X	}
X    }
X    print KIT "mkdir ",join(' ', sort @Xdirs)," 2>/dev/null\n";
X
X    foreach $file (@files) {
X	print "\t",$file,"\n" if $opt_v;
X	print KIT "echo Extracting $file\n";
X	print KIT "sed >$file <<'!STUFFY!FUNK!' -e 's/X//'\n";
X	open file;
X	while (<file>) {
X	    print KIT 'X',$_;
X	}
X	close file;
X	print KIT "!STUFFY!FUNK!\n";
X    }
X    do kittrailer();
X    chmod 0755, $kit;
X}
X
Xsub kitleader {
X    print KIT
X"#! /bin/sh
X
X# Make a new directory for the $package sources, cd to it, and run kits 1
X# thru $numkits through sh.  When all $numkits kits have been run, read README.
X
Xecho \"This is $package $baserev kit $kitnum (of $numkits).  If kit $kitnum is complete, the line\"
Xecho '\"'\"End of kit $kitnum (of $numkits)\"'\" will echo at the end.'
Xecho \"\"
Xexport PATH || (echo \"You didn't use sh, you clunch.\" ; kill \$\$)
X";
X}
X
Xsub kittrailer {
X    $rangelist = '';
X    for ($i = 1; $i <= $numkits; $i++) {
X	$rangelist .= ' ' . $i;
X    }
X    print KIT
X"echo \"\"
Xecho \"End of kit $kitnum (of $numkits)\"
Xcat /dev/null >kit${kitnum}isdone
Xrun=''
Xconfig=''
Xfor iskit in$rangelist; do
X    if test -f kit\${iskit}isdone; then
X	run=\"\$run \$iskit\"
X    else
X	todo=\"\$todo \$iskit\"
X    fi
Xdone
Xcase \$todo in
X    '')
X	echo \"You have run all your kits.  Please read README and then type Configure.\"
X	chmod 755 Configure
X	;;
X    *)  echo \"You have run\$run.\"
X	echo \"You still need to run\$todo.\"
X	;;
Xesac
X: Someone might mail this, so...
Xexit
X";
X}
X!NO!SUBS!
Xcat ../pl/package.pl >>makedist
Xchmod +x makedist
X$eunicefix makedist
!STUFFY!FUNK!
echo Extracting mcon/U/locdist.U
sed >mcon/U/locdist.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: locdist.U,v 2.0 88/06/28 23:16:59 lwall Locked $
X?RCS: $Log:	locdist.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:59  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:locdist orgdist citydist statedist cntrydist contdist: test newslibexp sed hostname cat echo n c rm Myread Oldconfig
X?MAKE:	-pick add $@ %*
X?S:locdist:
X?S:	This variable contains the eventual value of the LOCDIST symbol,
X?S:	which is the local organization's distribution name for news.
X?S:.
X?S:orgdist:
X?S:	This variable contains the eventual value of the ORGDIST symbol,
X?S:	which is the organization's distribution name for news.
X?S:.
X?S:citydist:
X?S:	This variable contains the eventual value of the CITYDIST symbol,
X?S:	which is the city's distribution name for news.
X?S:.
X?S:statedist:
X?S:	This variable contains the eventual value of the STATEDIST symbol,
X?S:	which is the state's or province's distribution name for news.
X?S:.
X?S:cntrydist:
X?S:	This variable contains the eventual value of the CNTRYDIST symbol,
X?S:	which is the country's distribution name for news.
X?S:.
X?S:contdist:
X?S:	This variable contains the eventual value of the CONTDIST symbol,
X?S:	which is the continent's distribution name for news.
X?S:.
X?C:LOCDIST:
X?C:	This symbol contains the distribution name for the news system that
X?C:	restricts article distribution to the local organization.
X?C:.
X?C:ORGDIST:
X?C:	This symbol contains the distribution name for the news system that
X?C:	restricts article distribution to the organization.
X?C:.
X?C:CITYDIST:
X?C:	This symbol contains the distribution name for the news system that
X?C:	restricts article distribution to the city.
X?C:.
X?C:STATEDIST:
X?C:	This symbol contains the distribution name for the news system that
X?C:	restricts article distribution to the state or province.
X?C:.
X?C:CNTRYDIST:
X?C:	This symbol contains the distribution name for the news system that
X?C:	restricts article distribution to the country.
X?C:.
X?C:CONTDIST:
X?C:	This symbol contains the distribution name for the news system that
X?C:	restricts article distribution to the continent.
X?C:.
X?H:?%1:#define LOCDIST "$locdist"		/**/
X?H:?%1:#define ORGDIST "$orgdist"		/**/
X?H:?%1:#define CITYDIST "$citydist"		/**/
X?H:?%1:#define STATEDIST "$statedist"		/**/
X?H:?%1:#define CNTRYDIST "$cntrydist"		/**/
X?H:?%1:#define CONTDIST "$contdist"		/**/
X?H:?%1:
X: get the local distributions
Xif $test -f $newslibexp/sys ; then
X    $sed -n -e "s/^$hostname://p" <$newslibexp/sys | \
X    $sed -e "s/:.*//" -e "s/,/ /g" | tr ' ' '\012' | \
X    $sed -e "/^to./d" -e "/^net$/d" -e "/^fa$/d" -e "/^mod$/d" -e "/^world$/d" \
X       -e "/^comp$/d" -e "/^news$/d" -e "/^misc$/d" -e "/^soc$/d" \
X       -e "/^talk$/d" -e "/^sci$/d" -e "/^rec$/d" > .distlist
Xfi
X
X$cat <<'EOH'
X 
XDistribution groups are the things you use on the Distribution line to limit
Xwhere an article will go to.  You are likely to be a member of several
Xdistribution groups, such as organization, city, state, province, country,
Xcontinent, etc.  For example, Los Angeles has the distribution code "la",
XNew Jersey has the code "nj", and Europe has the code "eunet".
X
XThe categories you will be asked are: 
X
Xlocal organization	(Could be just one machine or a cluster or an office)
Xorganization		att, dec, kgb, ...
Xcity			la, ny, mosc, ...
Xstate/province		ca, nj, bc, ...
Xcountry			usa, can, rok, whatever
Xcontinent		na (North America, not "Not Applicable"), asia, etc.
X
X(If you don't have a distribution code in any of these categories then
Xjust hit return.)
X
XEOH
Xif $test -f .distlist; then
X    distlist=`tr '\012' ' ' <.distlist`
X    if $test "$distlist" ; then
X	echo "(These are the distributions in your sys file: $distlist)"
X	echo " "
X    fi
Xfi
Xrp="[Hit return to continue]"
X$echo $n "$rp $c"
X. myread
Xif test -f $newslibexp/distributions; then
X    echo "Here is your distributions file:"
X    echo " "
X    cat $newslibexp/distributions
X    echo " "
Xfi
Xcase "$locdist" in
X'') dflt="none";;
X*)  dflt="$locdist";;
Xesac
Xrp="What is the distribution code for your local organization? [$dflt]"
X$echo $n "$rp $c"
X. myread
Xlocdist="$ans"
Xcase "$orgdist" in
X'') dflt="none";;
X*)  dflt="$orgdist";;
Xesac
Xrp="What is the distribution code for your organization? [$dflt]"
X$echo $n "$rp $c"
X. myread
Xorgdist="$ans"
Xcase "$citydist" in
X'') dflt="none";;
X*)  dflt="$citydist";;
Xesac
Xrp="What is the distribution code for your city? [$dflt]"
X$echo $n "$rp $c"
X. myread
Xcitydist="$ans"
Xcase "$statedist" in
X'') dflt="none";;
X*)  dflt="$statedist";;
Xesac
Xrp="What is the distribution code for your state/province? [$dflt]"
X$echo $n "$rp $c"
X. myread
Xstatedist="$ans"
Xcase "$cntrydist" in
X'') dflt="none";;
X*)  dflt="$cntrydist";;
Xesac
Xrp="What is the distribution code for your country? [$dflt]"
X$echo $n "$rp $c"
X. myread
Xcntrydist="$ans"
Xcase "$contdist" in
X'') dflt="none";;
X*)  dflt="$contdist";;
Xesac
Xrp="What is the distribution code for your continent? [$dflt]"
X$echo $n "$rp $c"
X. myread
Xcontdist="$ans"
X
X$cat <'EOM'
X  
XIf you have any other distribution groups you will need to edit Pnews
Xand newsetup to add them.
X 
XEOM
X$rm -f .distlist
X
!STUFFY!FUNK!
echo Extracting pat/patmake.SH
sed >pat/patmake.SH <<'!STUFFY!FUNK!' -e 's/X//'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X	echo "Using config.sh from above..."
X    fi
X    . ./config.sh
X    ;;
Xesac
X: This forces SH files to create target in same directory as SH file.
X: This is so that make depend always knows where to find SH derivatives.
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting patmake (with variable substitutions)"
Xcat >patmake <<!GROK!THIS!
X#!/usr/bin/perl
X        eval "exec /usr/bin/perl -S \$0 \$*"
X                if \$running_under_some_shell;
X
X# $Header: patmake.SH,v 2.0 88/06/28 23:19:46 lwall Locked $
X#
X# $Log:	patmake.SH,v $
X# Revision 2.0  88/06/28  23:19:46  lwall
X# Baseline.
X# 
X# 
X
X\$defeditor='$defeditor';
X!GROK!THIS!
X
X: In the following dollars and backticks do not need the extra backslash.
Xcat >>patmake <<'!NO!SUBS!'
X
Xdo readpackage();
X
Xif (-f 'patchlevel.h') {
X    open(PL,"patchlevel.h") || die "Can't open patchlevel.h\n";
X    while (<PL>) {
X        $last = $1 if /^#define\s+PATCHLEVEL\s+(\d+)/;
X    }
X    die "Malformed patchlevel.h file.\n" if $last eq '';
X    $bnum = $last + 1;
X}
Xelse {
X    $bnum = 1;
X    $last = '';
X}
X
X$mf = `grep '^[a-z]*:' [Mm]akefile* 2>&1`;
X$* = 1;
X$after = '';
X$after .= "\t\tConfigure -d\n" if -f 'Configure';
X$after .= "\t\tmake depend\n" if $mf =~ /^depend:/;
X$after .= "\t\tmake\n" if $mf;
X$after .= "\t\tmake test\n" if $mf =~ /^test:/;
X$after .= "\t\tmake install\n" if $mf =~ /^install:/;
X$* = 0;
X
Xchdir 'bugs' if -d 'bugs';
X
Xdie "Patch #$bnum already exists.\n" if -f "patch$bnum";
X
X@patlist=<*.$bnum>;
Xdie "No diff files for patch #$bnum.\n" if $patlist[0] =~ /^\*/;
X
Xif (-s ".logs$bnum") {
X    $logs = '';
X    open(LOGS,".logs$bnum");
X    while (<LOGS>) {
X	$logs .= $_ unless $logseen{$_};
X	$logseen{$_} = 1;
X    }
X    close LOGS;
X    $subs = $logs;
X    $* = 1;
X    $logs =~ s/^patch\d+:\s*/\t/g;
X    $logs =~ s/\n/\n\n/g;
X    $subs =~ s/^patch\d+:\s*/Subject: /g;
X    $* = 0;
X}
Xelse {
X    $subs = "Subject: \n";
X}
X
X$hah = " (hah!)" if $bnum == 1;
X
Xopen(PATCH,">patch$bnum") || die "Can't create patch";
Xprint PATCH
X"System: $package version $baserev
XPatch #: $bnum
XPriority: 
X${subs}From:
X
XDescription:
X$logs
XRepeat-By:
X
XFix:	From rn, say \"| patch -p -N -d DIR\", where DIR is your $package source
X	directory.  Outside of rn, say \"cd DIR; patch -p -N <thisarticle\".
X	If you don't have the patch program, apply the following by hand,
X	or get patch (version 2.0, latest patchlevel).
X
X	After patching:
X$after
X	If patch indicates that patchlevel is the wrong version, you may need
X	to apply one or more previous patches, or the patch may already
X	have been applied.  See the patchlevel.h file to find out what has or
X	has not been applied.  In any event, don't continue with the patch.
X
X	If you are missing previous patches$hah they can be obtained from me:
X
X	$maintname
X	$maintloc
X
X	If you send a mail message of the following form it will greatly speed
X	processing:
X
X	Subject: Command
X	@SH mailpatch PATH $package $baserev LIST
X		   ^ note the c
X
X	where PATH is a return path FROM ME TO YOU either in Internet notation,
X	or in bang notation from some well-known host, and LIST is the number
X	of one or more patches you need, separated by spaces, commas, and/or
X	hyphens.  Saying 35- says everything from 35 to the end.
X
X";
Xif ($ftpsite) {
X    print PATCH "
X	You can also get the patches via anonymous FTP from
X	$ftpsite.
X";
X}
Xprint PATCH "
XIndex: patchlevel.h
X";
X
Xif ($last eq '') {
X    `echo "#define PATCHLEVEL 1" >patchlevel.h`;
X    `cp /dev/null patchlevel.h.null`;
X    print PATCH `diff -c patchlevel.h.null patchlevel.h`;
X    unlink 'patchlevel.h', 'patchlevel.h.null';
X}
Xelse {
X    print PATCH
X"Prereq: $last
X1c1
X< #define PATCHLEVEL $last
X---
X> #define PATCHLEVEL $bnum
X";
X}
X
X@ARGV = @patlist;
Xwhile (<>) { print PATCH; }
Xclose PATCH;
X
X$editor = $ENV{'VISUAL'};
X$editor = $ENV{'EDITOR'} unless $editor;
X$editor = $defeditor unless $editor;
X$editor = 'vi' unless $editor;
Xsystem $editor, "patch$bnum";
Xif (-s "patch$bnum") {
X    `echo "#define PATCHLEVEL $bnum" >../patchlevel.h`;
X    open(PL,"patchlevel.h") || die "Can't open patchlevel.h\n";
X    while (<PL>) {
X	$bnum = $1 if /^#define\s+PATCHLEVEL\s+(\d+)/;
X    }
X    die "Malformed patchlevel.h file.\n" if $bnum eq '';
X    
X    if ($newsgroups) {
X	print "\nDo you wish to post patch #$bnum to $newsgroups? [y] ";
X	$ans = <stdin>;
X	system 'patpost', $bnum unless $ans =~ /^n/i;
X    }
X    if ($recipients) {
X	print "\nDo you wish to send patch #$bnum to $recipients? [y] ";
X	$ans = <stdin>;
X	system 'patsend', $bnum, $recipients unless $ans =~ /^n/i;
X    }
X    if ($ftpdir) {
X	print "\nDo you wish to copy patch #$bnum to $ftpdir? [y] ";
X	$ans = <stdin>;
X	system 'patftp', $bnum unless $ans =~ /^n/i;
X    }
X    utime time, time, 'patchlevel.h';
X}
Xelse {
X    unlink "patch$bnum";
X    die "Aborted.\n";
X}
X
X!NO!SUBS!
Xcat ../pl/package.pl >>patmake
Xchmod +x patmake
X$eunicefix patmake
!STUFFY!FUNK!
echo Extracting mcon/U/hostname.U
sed >mcon/U/hostname.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: hostname.U,v 2.0 88/06/28 23:16:46 lwall Locked $
X?RCS: $Log:	hostname.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:46  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:hostname phostname mydomain: echo contains sed test n c Myread Oldconfig Guess
X?MAKE:	-pick add $@ %*
X?S:hostname:
X?S:	This variable contains the eventual value of the HOSTNAME symbol,
X?S:	which is the name of the host the program is going to run on.
X?S:	The domain is not kept with hostname, but must be gotten from mydomain.
X?S:	The dot comes with mydomain, and need not be supplied by the program.
X?S:.
X?S:mydomain:
X?S:	This variable contains the eventual value of the MYDOMAIN symbol,
X?S:	which is the domain of the host the program is going to run on.
X?S:	The domain must be appended to hostname to form a complete host name.
X?S:	The dot comes with mydomain, and need not be supplied by the program.
X?S:.
X?S:phostname:
X?S:	This variable contains the eventual value of the PHOSTNAME symbol,
X?S:	which is a command that can be fed to popen() to get the host name.
X?S:	The program should probably not presume that the domain is or isn't
X?S:	there already.
X?S:.
X?C:HOSTNAME:
X?C:	This symbol contains name of the host the program is going to run on.
X?C:	The domain is not kept with hostname, but must be gotten from MYDOMAIN.
X?C:	The dot comes with MYDOMAIN, and need not be supplied by the program.
X?C:	If gethostname() or uname() exist, HOSTNAME may be ignored.
X?C:.
X?C:MYDOMAIN:
X?C:	This symbol contains the domain of the host the program is going to
X?C:	run on.  The domain must be appended to HOSTNAME to form a complete
X?C:	host name.  The dot comes with MYDOMAIN, and need not be supplied by
X?C:	the program.  If the host name is derived from PHOSTNAME, the domain
X?C:	may or may not already be there, and the program should check.
X?C:.
X?H:?%1:#define HOSTNAME "$hostname"		/**/
X?H:?%1:#define MYDOMAIN "$mydomain"		/**/
X?H:?%1:
X: now get the host name
Xecho " "
Xecho "Figuring out host name..."
Xecho 'Maybe "hostname" will work...'
Xif ans=`sh -c hostname 2>&1` ; then
X    hostname=$ans
X    phostname=hostname
Xelse
X    echo 'Oh, dear.  Maybe "/etc/systemid" is the key...'
X    if ans=`cat /etc/systemid 2>&1` ; then
X	hostname=$ans
X	phostname='cat /etc/systemid'
X	if xenix; then
X	    echo "Whadyaknow.  Xenix always was a bit strange..."
X	else
X	    echo "What is a non-Xenix system doing with /etc/systemid?"
X	fi
X    else
X	echo 'No, maybe "uuname -l" will work...'
X	if ans=`sh -c 'uuname -l' 2>&1` ; then
X	    hostname=$ans
X	    phostname='uuname -l'
X	else
X	    echo 'Strange.  Maybe "uname -n" will work...'
X	    if ans=`sh -c 'uname -n' 2>&1` ; then
X		hostname=$ans
X		phostname='uname -n'
X	    else
X		echo 'Oh well, maybe I can mine it out of whoami.h...'
X		if ans=`sh -c $contains' sysname /usr/include/whoami.h' 2>&1` ; then
X		    hostname=`echo "$ans" | $sed 's/^.*"\(.*\)"/\1/'`
X		    phostname="sed -n -e '"'/sysname/s/^.*\"\\(.*\\)\"/\1/{'"' -e p -e q -e '}' </usr/include/whoami.h"
X		else
X		    case "$hostname" in
X		    '') echo "Does this machine have an identity crisis or something?"
X			phostname=''
X			;;
X		    *)  echo "Well, you said $hostname before...";;
X		    esac
X		fi
X	    fi
X	fi
X    fi
Xfi
X: you do not want to know about this
Xset $hostname
Xhostname=$1
X
X: translate upper to lower if necessary
Xcase "$hostname" in
X    *[A-Z]*)
X	hostname=`echo $hostname | tr '[A-Z]' '[a-z]'`
X	echo "(Normalizing case in your host name)"
X	;;
Xesac
X
X: verify guess
Xif $test "$hostname" ; then
X    dflt=y
X    echo 'Your host name appears to be "'$hostname'".'
X    $echo $n "Is this correct? [$dflt] $c"
X    rp="Sitename is $hostname? [$dflt]"
X    . myread
X    case "$ans" in
X      y*)  ;;
X      *)      hostname='' ;;
X    esac
Xfi
X
X: bad guess or no guess
Xwhile $test "X$hostname" = X ; do
X    dflt=''
X    rp="Please type the (one word) name of your host:"
X    $echo $n "$rp $c"
X    . myread
X    hostname="$ans"
Xdone
X
Xecho " "
Xcase "$hostname" in
X*.*)
X    dflt=`expr "X$hostname" : "X[^.]*\(\..*\)"`
X    hostname=`expr "X$hostname" : "X\([^.]*\)\."`
X    echo "(Trimming domain name from host name--host name is now $hostname)"
X    ;;
X*)
X    dflt='.uucp'
X    ;;
Xesac
Xrp="What is your domain name? [$dflt]"
X$echo $n "$rp $c"
X. myread
Xcase "$ans" in
X'') ;;
X.*) ;;
X*) ans=".$ans";;
Xesac
Xmydomain="$ans"
X
X: a little sanity check here
Xcase "$phostname" in
X'') ;;
X*)  case `$phostname` in
X    $hostname$mydomain|$hostname) ;;
X    *)
X	case "$phostname" in
X	sed*)
X	    echo "(That doesn't agree with your whoami.h file, by the way.)"
X	    ;;
X	*)
X	    echo "(That doesn't agree with your $phostname command, by the way.)"
X	    ;;
X	esac
X	phostname=''
X	;;
X    esac
X    ;;
Xesac
X
!STUFFY!FUNK!
echo Extracting pat/patdiff.SH
sed >pat/patdiff.SH <<'!STUFFY!FUNK!' -e 's/X//'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X    fi
X    . ./config.sh
X    ;;
Xesac
X: This forces SH files to create target in same directory as SH file.
X: This is so that make depend always knows where to find SH derivatives.
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting patdiff (with variable substitutions)"
Xcat >patdiff <<!GROK!THIS!
X#!/usr/bin/perl
X        eval "exec /usr/bin/perl -S \$0 \$*"
X                if \$running_under_some_shell;
X
X# $Header: patdiff.SH,v 2.0 88/06/28 23:19:39 lwall Locked $
X#
X# $Log:	patdiff.SH,v $
X# Revision 2.0  88/06/28  23:19:39  lwall
X# Baseline.
X# 
X# 
X
X!GROK!THIS!
X
X: In the following dollars and backticks do not need the extra backslash.
Xcat >>patdiff <<'!NO!SUBS!'
X
X$RCSEXT = ',v' unless $RCSEXT;
X
Xdie "patdiff [files]\n" unless $#ARGV >= 0;
X
Xdo readpackage();
X
Xsystem 'mkdir', 'bugs' unless -d 'bugs';
X
Xif (-f 'patchlevel.h') {
X    open(PL,"patchlevel.h") || die "Can't open patchlevel.h\n";
X    while (<PL>) {
X        $bnum = $1 if /^#define\s+PATCHLEVEL\s+(\d+)/;
X    }
X    die "Malformed patchlevel.h file.\n" if $bnum eq '';
X    ++$bnum;
X}
Xelse {
X    $bnum=1;
X}
X
X$update = 1;
Xwhile ($ARGV[0] =~ /^-/) {
X    $_ = shift;
X    last if /--/;
X    if ($_ eq '-n') {
X        $update = 0;
X    }
X    elsif ($_ eq '-a') {
X        $all++;
X    }
X    else {
X        die "Unrecognized switch: $_\n";
X    }
X}
X
Xif ($all) {
X    open(MANI,"MANIFEST.new") || die "No MANIFEST.new found.\n";
X    @ARGV = ();
X    while (<MANI>) {
X        chop;
X	($_) = split(' ');
X        push(@ARGV,$_);
X    }
X    close MANI;
X}
X
Xforeach $file (@ARGV) {
X    if (! -f $file) {
X	print "$file not found.\n";
X    }
X    else {
X	$files = do rcsargs($file);
X	@files = split(' ',$files);
X	$new='';
X	$revs=0;
X	$rlog = `rlog -rlastpat- $files 2>&1`;
X	($lastpat) = ($rlog =~ /lastpat: ([\d.]+)/);
X	($revs) = ($rlog =~ /selected revisions: (\d+)/);
X	if (!$revs) {
X	    print "No cil has been done on $file.\n" ;;
X	}
X	elsif ($revs == 1) {
X	    ($base) = ($rlog =~ /.*\nrevision\s+(\S+)/);
X	    ($a,$b,$c,$d) = split(/\./,$base);
X	    if ($d ne '') {
X		if ($update) {
X		    print "No changes in $file since last patch.  (Did you cil it?)\n";
X		}
X		else {
X		    $new='foo';
X		}
X	    }
X	    else {
X		$revs=0;
X		$rlog = `rlog -r$revbranch- $files 2>&1`;
X		($revs) = ($rlog =~ /selected revisions: (\d+)/);
X		if (!$revs) {
X		    print "No changes in $file since base version.  (Did you cil it?)\n";
X		}
X		else {
X		    ($new) = ($rlog =~ /\nrevision\s*(\d+\.\d+\.\d+\.\d+)/);
X		}
X	    }
X	}
X	else {
X	    ($new) = ($rlog =~ /\nrevision\s*(\d+\.\d+\.\d+\.\d+)/);
X	}
X	if ($new ne '') {
X	    ($fname = $file) =~ s|.*/||;
X	    open(PATCH,">>bugs/$fname.$bnum") || die "Can't make patch";
X	    print PATCH "\nIndex: $file\n";
X	    open(CO,"co -p -rlastpat $files 2>/dev/null |");
X	    while (<CO>) {
X		if (/\$Header/) {
X		    print PATCH "Prereq: $lastpat\n";
X		    last;
X		}
X	    }
X	    close CO;
X	    if ($update) {
X		if ($mydiff eq '') {
X		    open(DIFF,"rcsdiff -c -rlastpat -r$new $files |") ||
X			die "Can't run rcsdiff";
X		    while (<DIFF>) {
X			if ($. == 1) {s|\*\*\* \S+	|*** $file.old	|;}
X			if ($. == 2) {s|--- \S+	|--- $file	|;}
X			print PATCH;
X		    }
X		    close DIFF;
X		    system 'rcs', "-Nlastpat:$new", @files;
X		}
X		else {
X		    system "co -p -rlastpat $files >/tmp/pdo$$";
X		    system "co -p -r$new $files >/tmp/pdn$$";
X		    open(DIFF, "$mydiff /tmp/pdo$$ /tmp/pdn$$ |") ||
X			die "Can't run $mydiff";
X		    while (<DIFF>) {
X			if ($. == 1) {s|\*\*\* \S+	|*** $file.old	|;}
X			if ($. == 2) {s|--- \S+	|--- $file	|;}
X			print PATCH;
X		    }
X		    close DIFF;
X		    system 'rcs', "-Nlastpat:$new", @files;
X		    unlink "/tmp/pdn$$", "/tmp/pdo$$";
X		}
X	    }
X	    else {
X		if ($mydiff eq '') {
X		    open(DIFF,"rcsdiff -c -rlastpat $files |") ||
X			die "Can't run rcsdiff";
X		    while (<DIFF>) {
X			if ($. == 1) {s|\*\*\* \S+	|*** $file.old	|;}
X			if ($. == 2) {s|--- \S+	|--- $file	|;}
X			print PATCH;
X		    }
X		    close DIFF;
X		}
X		else {
X		    system "co -p -rlastpat $files >/tmp/pdo$$";
X		    system "cp $file /tmp/pdn$$";
X		    open(DIFF, "$mydiff /tmp/pdo$$ /tmp/pdn$$ |") ||
X			die "Can't run $mydiff";
X		    while (<DIFF>) {
X			if ($. == 1) {s|\*\*\* \S+	|*** $file.old	|;}
X			if ($. == 2) {s|--- \S+	|--- $file	|;}
X			print PATCH;
X		    }
X		    close DIFF;
X		    unlink "/tmp/pdn$$", "/tmp/pdo$$";
X		}
X	    }
X	}
X    }
X}
Xunlink ".rlog$$";
X
X!NO!SUBS!
Xcat ../pl/package.pl >>patdiff
Xcat ../pl/rcsargs.pl >>patdiff
Xchmod +x patdiff
X$eunicefix patdiff
!STUFFY!FUNK!
echo Extracting mcon/U/d_gethname.U
sed >mcon/U/d_gethname.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_gethname.U,v 2.0 88/06/28 23:14:41 lwall Locked $
X?RCS: $Log:	d_gethname.U,v $
X?RCS: Revision 2.0  88/06/28  23:14:41  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_gethname d_douname d_phostname: contains echo phostname cat hostname package d_portable n c d_whoami Myread libc
X?MAKE:	-pick add $@ %*
X?S:d_gethname:
X?S:	This variable conditionally defines the GETHOSTNAME symbol, which
X?S:	indicates to the C program that the gethostname() routine may be
X?S:	used to derive the host name.
X?S:.
X?S:d_douname:
X?S:	This variable conditionally defines the DOUNAME symbol, which
X?S:	indicates to the C program that the uname() routine may be
X?S:	used to derive the host name.
X?S:.
X?S:d_phostname:
X?S:	This variable conditionally defines the PHOSTNAME symbol, which
X?S:	contains the shell command which, when fed to popen(), may be
X?S:	used to derive the host name.
X?S:.
X?C:GETHOSTNAME:
X?C:	This symbol, if defined, indicates that the C program may use the
X?C:	gethostname() routine to derive the host name.  See also DOUNAME
X?C:	and PHOSTNAME.
X?C:.
X?C:DOUNAME:
X?C:	This symbol, if defined, indicates that the C program may use the
X?C:	uname() routine to derive the host name.  See also GETHOSTNAME and
X?C:	PHOSTNAME.
X?C:.
X?C:PHOSTNAME:
X?C:	This symbol, if defined, indicates that the C program may use the
X?C:	contents of PHOSTNAME as a command to feed to the popen() routine
X?C:	to derive the host name.  See also GETHOSTNAME and DOUNAME.
X?C:.
X?H:?%1:#$d_gethname	GETHOSTNAME	/**/
X?H:?%1:#$d_douname	DOUNAME		/**/
X?H:?%1:#$d_phostname	PHOSTNAME "$phostname"	/**/
X?H:?%1:
X: see how we will look up host name
Xecho " "
Xd_douname="$undef"
Xd_gethname="$undef"
Xd_phostname="$undef"
X
Xif xenix; then
X    echo " "
X    echo "(Assuming Xenix uname() is broken.)"
Xelif $contains '^gethostname$' libc.list >/dev/null 2>&1 ; then
X    echo "gethostname() found."
X    d_gethname="$define"
X    ans=gethostname
Xelif $contains '^uname$' libc.list >/dev/null 2>&1 ; then
X    echo "uname() found."
X    d_douname="$define"
X    ans=uname
Xfi
X
Xcase "$d_douname$d_gethname" in
X*define*)
X    dflt=n
X    cat <<EOM
X 
XEvery now and then someone has a $ans() that lies about the hostname
Xbut can't be fixed for political or economic reasons.  Would you like to
XEOM
X    rp="pretend $ans() isn't there and maybe compile in the hostname? [$dflt]"
X    $echo $n "$rp $c"
X    . myread
X    case "$ans" in
X    y*) d_douname="$undef" d_gethname="$undef"
X	$echo $n "Okay... $c"
X	;;
X    esac
X    ;;
Xesac
X
Xcase "$d_douname$d_gethname" in
X*define*) ;;
X*)
X    case "$phostname" in
X      '') ;;
X      *)
X	$cat <<EOT
X 
XThere is no gethostname() or uname() on this system.  You have two
Xpossibilities at this point:
X
X1)  You can have your host name ($hostname) compiled into $package, which
X    lets $package start up faster, but makes your binaries non-portable, or
X2)  you can have $package use a
X	
X	popen("$phostname","r")
X
X    which will start slower but be more portable.
X
XOption 1 will give you the option of using whoami.h if you have one.  If you
Xwant option 2 but with a different command, you can edit config.sh at the
Xend of this shell script.
X
XEOT
X	case "$d_phostname" in
X	"$define") dflt=n;;
X	"$undef")  dflt=y;;
X	'')
X	    case "$d_portable" in
X	    "$define") dflt=n ;;
X	    *)      dflt=y ;;
X	    esac
X	    ;;
X	esac
X	rp="Do you want your host name compiled in? [$dflt]"
X	$echo $n "$rp $c"
X	. myread
X	case "$ans" in
X	  n*) d_phostname="$define" ;;
X	  *)  phostname=''
X	      d_phostname="$undef"
X	      ;;
X	esac
X	;;
X    esac
X    case "$phostname" in
X      '')
X	case "$d_whoami" in
X	  "$define")
X	    dflt=y
X	    $cat <<EOM
X 
XNo hostname function--you can either use the whoami.h file, which has this line:
X
X	`grep sysname /usr/include/whoami.h`
X
Xor you can have the name we came up with earlier ($hostname) hardwired in.
XEOM
X	    rp="Use whoami.h to get hostname? [$dflt]"
X	    $echo $n "$rp $c"
X	    . myread
X	    case "$ans" in
X	    n*) d_whoami="$undef";;
X	    esac
X	    ;;
X	  "$undef")
X	    echo 'No hostname function and no whoami.h--hardwiring "'$hostname'".'
X	    ;;
X	esac
X	;;
X    esac
X    ;;
Xesac
X
!STUFFY!FUNK!
echo Extracting mcon/U/nametype.U
sed >mcon/U/nametype.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: nametype.U,v 2.0 88/06/28 23:17:33 lwall Locked $
X?RCS: $Log:	nametype.U,v $
X?RCS: Revision 2.0  88/06/28  23:17:33  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:nametype d_passnames d_berknames d_usgnames passcat: echo n c Myread Guess Oldconfig test contains
X?MAKE:	-pick add $@ %*
X?S:nametype:
X?S:	This variable indicates how full names are stored on this system.
X?S:	Values are bsd, usg, and other.
X?S:.
X?S:d_passnames:
X?S:	This variable conditionally defines the PASSNAMES symbol,
X?S:	which indicates to the C program that full names are stored in
X?S:	the /etc/passwd file.
X?S:.
X?S:d_berknames:
X?S:	This variable conditionally defines the PASSNAMES symbol,
X?S:	which indicates to the C program that full names are stored in
X?S:	the /etc/passwd file in Berkeley format.
X?S:.
X?S:d_usgnames:
X?S:	This variable conditionally defines the PASSNAMES symbol,
X?S:	which indicates to the C program that full names are stored in
X?S:	the /etc/passwd file in USG format.
X?S:.
X?S:passcat:
X?S:	This variable contains a command that produces the text of the
X?S:	/etc/passwd file.  This is normally "cat passwd", but can be
X?S:	"ypcat passwd" on suns.
X?S:.
X?C:PASSNAMES:
X?C:	This symbol, if defined, indicates that full names are stored in
X?C:	the /etc/passwd file.
X?C:.
X?C:BERKNAMES:
X?C:	This symbol, if defined, indicates that full names are stored in
X?C:	the /etc/passwd file in Berkeley format (name first thing, everything
X?C:	up to first comma, with & replaced by capitalized login id, yuck).
X?C:.
X?C:USGNAMES:
X?C:	This symbol, if defined, indicates that full names are stored in
X?C:	the /etc/passwd file in USG format (everything after - and before ( is
X?C:	the name).
X?C:.
X?H:?%1:#$d_passnames	PASSNAMES /*  (undef to take name from ~/.fullname) */
X?H:?%1:#$d_berknames	BERKNAMES /* (that is, ":name,stuff:") */
X?H:?%1:#$d_usgnames	USGNAMES  /* (that is, ":stuff-name(stuff):") */
X?H:?%1:
X: find out how to find out full name
Xecho " "
Xcase "$d_berknames" in
X"$define")
X    dflt=y;;
X"$undef")
X    dflt=n;;
X*)
X    if bsd; then
X	dflt=y
X    else
X	dflt=n
X    fi
X    ;;
Xesac
Xecho "Does your /etc/passwd file keep full names in Berkeley/V7 format (name first"
X$echo $n "thing after ':' in GCOS field)? [$dflt] $c"
Xrp="Berkeley/V7 format full name? [$dflt]"
X. myread
Xcase "$ans" in
X  y*)
X    d_passnames="$define"
X    d_berknames="$define"
X    d_usgnames="$undef"
X    nametype=bsd
X    ;;
X  *)
X    echo " "
X    case "$d_usgnames" in
X    "$define")
X	dflt=y;;
X    "$undef")
X	dflt=n;;
X    *)
X	if usg; then
X	    dflt=y
X	else
X	    dflt=n
X	fi
X	;;
X    esac
X    echo "Does your passwd file keep full names in USG format (name sandwiched"
X    $echo $n "between a '-' and a '(')? [$dflt] $c"
X    rp="USG format full name? [$dflt]"
X    . myread
X    case "$ans" in
X      n*)
X	echo "Full name will be taken from ~/.fullname"
X	d_passnames="$undef"
X	d_berknames="$undef"
X	d_usgnames="$undef"
X	nametype=other
X	;;
X      *)
X	d_passnames="$define"
X	d_berknames="$undef"
X	d_usgnames="$define"
X	nametype=usg
X	;;
X    esac
X    ;;
Xesac
X
X: see if we have to deal with yellow pages
Xif $test -d /usr/etc/yp; then
X    if $contains '^\+:' /etc/passwd; then
X	dflt=y
X    else
X	dflt=n
X    fi
X    rp="Are you getting the passwd file via yellow pages? [$dflt]"
X    $echo $n "$rp $c"
X    . myread
X    case "$ans" in
X    y*) passcat='ypcat passwd';;
X    *) passcat='cat /etc/passwd';;
X    esac
Xelse
X    passcat='cat /etc/passwd'
Xfi
X
!STUFFY!FUNK!
echo Extracting config.h.SH
sed >config.h.SH <<'!STUFFY!FUNK!' -e 's/X//'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X	echo "Using config.sh from above..."
X    fi
X    . ./config.sh
X    ;;
Xesac
Xecho "Extracting config.h (with variable substitutions)"
Xsed <<!GROK!THIS! >config.h -e 's!^#undef!/\*#undef!'
X/* config.h
X * This file was produced by running the config.h.SH script, which
X * gets its values from config.sh, which is generally produced by
X * running Configure.
X *
X * Feel free to modify any of this as the need arises.  Note, however,
X * that running config.h.SH again will wipe out any changes you've made.
X * For a more permanent change edit config.sh and rerun config.h.SH.
X */
X
X
X/* EUNICE:
X *	This symbol, if defined, indicates that the program is being compiled
X *	under the EUNICE package under VMS.  The program will need to handle
X *	things like files that don't go away the first time you unlink them,
X *	due to version numbering.  It will also need to compensate for lack
X *	of a respectable link() command.
X */
X/* VMS:
X *	This symbol, if defined, indicates that the program is running under
X *	VMS.  It is currently only set in conjunction with the EUNICE symbol.
X */
X#$d_eunice	EUNICE		/**/
X#$d_eunice	VMS		/**/
X
X/* DEFEDITOR:
X *	This symbol contains the name of the default editor.
X */
X#define DEFEDITOR "$defeditor"		/**/
X
X/* HOSTNAME:
X *	This symbol contains name of the host the program is going to run on.
X *	The domain is not kept with hostname, but must be gotten from MYDOMAIN.
X *	The dot comes with MYDOMAIN, and need not be supplied by the program.
X *	If gethostname() or uname() exist, HOSTNAME may be ignored.
X */
X/* MYDOMAIN:
X *	This symbol contains the domain of the host the program is going to
X *	run on.  The domain must be appended to HOSTNAME to form a complete
X *	host name.  The dot comes with MYDOMAIN, and need not be supplied by
X *	the program.  If the host name is derived from PHOSTNAME, the domain
X *	may or may not already be there, and the program should check.
X */
X#define HOSTNAME "$hostname"		/**/
X#define MYDOMAIN "$mydomain"		/**/
X
X/* PASSNAMES:
X *	This symbol, if defined, indicates that full names are stored in
X *	the /etc/passwd file.
X */
X/* BERKNAMES:
X *	This symbol, if defined, indicates that full names are stored in
X *	the /etc/passwd file in Berkeley format (name first thing, everything
X *	up to first comma, with & replaced by capitalized login id, yuck).
X */
X/* USGNAMES:
X *	This symbol, if defined, indicates that full names are stored in
X *	the /etc/passwd file in USG format (everything after - and before ( is
X *	the name).
X */
X#$d_passnames	PASSNAMES /*  (undef to take name from ~/.fullname) */
X#$d_berknames	BERKNAMES /* (that is, ":name,stuff:") */
X#$d_usgnames	USGNAMES  /* (that is, ":stuff-name(stuff):") */
X
X/* ORGNAME:
X *	This symbol contains either the organizaton name or the full pathname
X *	of a file containing the organization name, which the program must
X *	be prepared to open and substitute the contents of.
X */
X#define ORGNAME "$orgname"		/**/
X
X!GROK!THIS!
!STUFFY!FUNK!
echo Extracting mcon/U/Guess.U
sed >mcon/U/Guess.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: Guess.U,v 2.0 88/06/28 23:13:08 lwall Locked $
X?X: 
X?X: This unit hazards some guesses as to what the general nature of the system
X?X: is.  The information it collects here is used primarily to establish default
X?X: answers to other questions.
X?X: 
X?RCS: $Log:	Guess.U,v $
X?RCS: Revision 2.0  88/06/28  23:13:08  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:Guess d_eunice eunicefix: n c contains libc
X?MAKE:	-pick add $@ %*
X?S:d_eunice:
X?S:	This variable conditionally defines the symbols EUNICE and VAX, which
X?S:	alerts the C program that it must deal with ideosyncracies of VMS.
X?S:.
X?S:eunicefix:
X?S:	When running under Eunice this variable contains a command which will
X?S:	convert a shell script to the proper form of text file for it to be
X?S:	executable by the shell.  On other systems it is a no-op.
X?S:.
X?C:EUNICE:
X?C:	This symbol, if defined, indicates that the program is being compiled
X?C:	under the EUNICE package under VMS.  The program will need to handle
X?C:	things like files that don't go away the first time you unlink them,
X?C:	due to version numbering.  It will also need to compensate for lack
X?C:	of a respectable link() command.
X?C:.
X?C:VMS:
X?C:	This symbol, if defined, indicates that the program is running under
X?C:	VMS.  It is currently only set in conjunction with the EUNICE symbol.
X?C:.
X?H:?%1:#$d_eunice	EUNICE		/**/
X?H:?%1:#$d_eunice	VMS		/**/
X?H:?%1:
X: make some quick guesses about what we are up against
Xecho " "
X$echo $n "Hmm...  $c"
Xif $contains SIGTSTP /usr/include/signal.h >/dev/null 2>&1 ; then
X    echo "Looks kind of like a BSD system, but we'll see..."
X    echo exit 0 >bsd
X    echo exit 1 >usg
X    echo exit 1 >v7
Xelif $contains '^fcntl$' libc.list >/dev/null 2>&1 ; then
X    echo "Looks kind of like a USG system, but we'll see..."
X    echo exit 1 >bsd
X    echo exit 0 >usg
X    echo exit 1 >v7
Xelse
X    echo "Looks kind of like a version 7 system, but we'll see..."
X    echo exit 1 >bsd
X    echo exit 1 >usg
X    echo exit 0 >v7
Xfi
Xif $contains '^vmssystem$' libc.list >/dev/null 2>&1 ; then
X    cat <<'EOI'
XThere is, however, a strange, musty smell in the air that reminds me of
Xsomething...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
XEOI
X    echo "exit 0" >eunice
X    eunicefix=unixtovms
X    d_eunice="$define"
X: it so happens the Eunice I know will not run shell scripts in Unix format
Xelse
X    echo " "
X    echo "Congratulations.  You aren't running Eunice."
X    eunicefix=':'
X    d_eunice="$undef"
X    echo "exit 1" >eunice
Xfi
Xif test -f /xenix; then
X    echo "Actually, this looks more like a XENIX system..."
X    echo "exit 0" >xenix
Xelse
X    echo " "
X    echo "It's not Xenix..."
X    echo "exit 1" >xenix
Xfi
Xchmod +x xenix
X$eunicefix xenix
Xif test -f /venix; then
X    echo "Actually, this looks more like a VENIX system..."
X    echo "exit 0" >venix
Xelse
X    echo " "
X    if xenix; then
X	: null
X    else
X	echo "Nor is it Venix..."
X    fi
X    echo "exit 1" >venix
Xfi
Xchmod +x bsd usg v7 eunice venix
X$eunicefix bsd usg v7 eunice venix
Xrmlist="$rmlist bsd usg v7 eunice venix xenix"
X
!STUFFY!FUNK!
echo Extracting mcon/U/voidflags.U
sed >mcon/U/voidflags.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: voidflags.U,v 2.0 88/06/28 23:18:38 lwall Locked $
X?RCS: $Log:	voidflags.U,v $
X?RCS: Revision 2.0  88/06/28  23:18:38  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:voidflags defvoidused: echo n c cat rm contains
X?MAKE:	-pick add $@ %*
X?S:voidflags:
X?S:	This variable contains the eventual value of the VOIDFLAGS symbol,
X?S:	which indicates how much support of the void type is given by this
X?S:	compiler.  See VOIDFLAGS for more info.
X?S:.
X?C:VOIDFLAGS:
X?C:	This symbol indicates how much support of the void type is given by this
X?C:	compiler.  What various bits mean:
X?C:
X?C:	    1 = supports declaration of void
X?C:	    2 = supports arrays of pointers to functions returning void
X?C:	    4 = supports comparisons between pointers to void functions and
X?C:		    addresses of void functions
X?C:
X?C:	The package designer should define VOIDUSED to indicate the requirements
X?C:	of the package.  This can be done either by #defining VOIDUSED before
X?C:	including config.h, or by defining defvoidused in Myinit.U.  If the
X?C:	level of void support necessary is not present, defines void to int.
X?C:.
X?H:?%1:#ifndef VOIDUSED
X?H:?%1:#define VOIDUSED $defvoidused
X?H:?%1:#endif
X?H:?%1:#define VOIDFLAGS $voidflags
X?H:?%1:#if (VOIDFLAGS & VOIDUSED) != VOIDUSED
X?H:?%1:#$define void int		/* is void to be avoided? */
X?H:?%1:#$define M_VOID		/* Xenix strikes again */
X?H:?%1:#endif
X?H:?%1:
X?INIT:defvoidused=7
X: check for void type
Xecho " "
X$cat <<EOM
XChecking to see how well your C compiler groks the void type...
X
X  Support flag bits are:
X    1: basic void declarations.
X    2: arrays of pointers to functions returning void.
X    4: operations between pointers to and addresses of void functions.
X
XEOM
Xcase "$voidflags" in
X'')
X    $cat >try.c <<'EOCP'
X#if TRY & 1
Xvoid main() {
X#else
Xmain() {
X#endif
X	extern void *moo();
X	void *(*goo)();
X#if TRY & 2
X	void (*foo[10])();
X#endif
X
X#if TRY & 4
X	if(*goo == moo) {
X		exit(0);
X	}
X#endif
X	exit(0);
X}
XEOCP
X    if cc -S -DTRY=7 try.c >.out 2>&1 ; then
X	voidflags=7
X	echo "It appears to support void fully."
X	if $contains warning .out >/dev/null 2>&1; then
X	    echo "However, you might get some warnings that look like this:"
X	    $cat .out
X	fi
X    else
X	echo "Hmm, you compiler has some difficulty with void.  Checking further..."
X	if cc -S -DTRY=1 try.c >/dev/null 2>&1 ; then
X	    echo "It supports 1..."
X	    if cc -S -DTRY=3 try.c >/dev/null 2>&1 ; then
X		voidflags=3
X		echo "And it supports 2 but not 4."
X	    else
X		echo "It doesn't support 2..."
X		if cc -S -DTRY=3 try.c >/dev/null 2>&1 ; then
X		    voidflags=5
X		    echo "But it supports 4."
X		else
X		    voidflags=1
X		    echo "And it doesn't support 4."
X		fi
X	    fi
X	else
X	    echo "There is no support at all for void."
X	    voidflags=0
X	fi
X    fi
Xesac
Xdflt="$voidflags";
Xrp="Your void support flags add up to what? [$dflt]"
X$echo $n "$rp $c"
X. myread
Xvoidflags="$ans"
X$rm -f try.* .out
X
!STUFFY!FUNK!
echo Extracting pat/patpost.SH
sed >pat/patpost.SH <<'!STUFFY!FUNK!' -e 's/X//'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X	echo "Using config.sh from above..."
X    fi
X    . ./config.sh
X    ;;
Xesac
X: This forces SH files to create target in same directory as SH file.
X: This is so that make depend always knows where to find SH derivatives.
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting patpost (with variable substitutions)"
Xcat >patpost <<!GROK!THIS!
X#!/usr/bin/perl
X	eval "exec /usr/bin/perl -S \$0 \$*"
X		if \$running_under_some_shell;
X
X# $Header: patpost.SH,v 2.0 88/06/28 23:19:50 lwall Locked $
X#
X# $Log:	patpost.SH,v $
X# Revision 2.0  88/06/28  23:19:50  lwall
X# Baseline.
X# 
X
X\$inews='${inews-/usr/lib/news/inews}';
X\$orgname='$orgname';
X!GROK!THIS!
X
X: In the following dollars and backticks do not need the extra backslash.
Xcat >>patpost <<'!NO!SUBS!'
Xif ($inews eq 'inews') {
X    $inews = '/usr/lib/news/inews' if -f '/usr/lib/news/inews';
X}
X
Xchdir '..' if -f '../.package';
X
Xdo readpackage();
X
Xchop($orgname = `cat $orgname`) if $orgname =~ m|^/|;
X
Xif ($ARGV[0] eq '-r') {
X    shift; $repost = ' (REPOST)';
X}
X
Xwhile ($_ = shift) {
X    if (/^(patch)?[1-9][\d\-]*$/) {
X	s/^patch//;
X	push(@argv,$_);
X    }
X    else {
X	push(@newsgroups,$_);
X    }
X}
X$newsgroups = join(',',@newsgroups) unless $#newsgroups < 0;
Xdie "patpost newsgroups [patches]\n" unless $newsgroups;
X
X@ARGV = @argv;
Xopen(PL,"patchlevel.h") || die "Can't open patchlevel.h\n";
Xwhile (<PL>) {
X    $maxnum = $1 if /^#define\s+PATCHLEVEL\s+(\d+)/;
X}
Xclose PL;
Xdie "Malformed patchlevel.h file.\n" if $maxnum eq '';
X
Xif ($#ARGV < 0) {
X    $argv = $maxnum;
X    @ARGV = $argv;
X}
Xelse {
X    $argv = do rangeargs(@ARGV);
X    @ARGV = split(' ',$argv);
X}
X
X$argv =~ s/ $//;
X
Xif ($#ARGV < 0) {
X    die "No patches specified.\n";
X}
Xelsif ($#ARGV) {
X    print "Posting $package $baserev patches $argv to $newsgroups...\n";
X}
Xelse {
X    print "Posting $package $baserev patch $argv to $newsgroups...\n";
X}
X
Xchdir 'bugs' || die "Can't cd to bugs\n";
X
Xfork && exit;
X
Xuntil ($#ARGV < 0) {
X    $patnum = shift;
X    open(XHEAD,">.xhead$$") || die "Can't create temp file.\n";
X    print XHEAD
X"Newsgroups: $newsgroups
XSubject: $package $baserev patch #$patnum$repost
XSummary: This is an official patch for $package $baserev.  Please apply it.
XExpires: 
XReferences: 
XSender: 
XDistribution: 
XOrganization: $orgname
XKeywords: 
X
X";
X    open(PATCH,"patch$patnum") || die "Can't open patch$_\n";
X    while (<PATCH>) {
X	print XHEAD;
X    }
X    close XHEAD;
X    system "$inews -h <.xhead$$";
X}
Xunlink ".xhead$$";
X
X!NO!SUBS!
Xcat ../pl/package.pl >>patpost
Xcat ../pl/rangeargs.pl >>patpost
Xchmod +x patpost
X$eunicefix patpost
!STUFFY!FUNK!
echo Extracting mcon/makegloss
sed >mcon/makegloss <<'!STUFFY!FUNK!' -e 's/X//'
X#!/usr/bin/perl
Xopen(G,">Glossary") || die "Can't create Glossary.\n";
Xprint G
X'[This Glossary is automatically generated from the Unit files.  Do not edit
Xthis file or your changes will be lost.  Edit the appropriate Unit instead.]
X
XThis file contains a listing of all the C preprocessor symbols and shell
Xvariables whose value can be determined by a Configure script.  For the
Xmost part, any symbol in UPPERCASE is a C preprocessor symbol, and
Xwill be defined in config.h.  Symbols in lowercase are shell variables,
Xand are defined in config.sh.
X
XIf you write your shell scripts and C programs in terms of these symbols,
Xmetaconfig can automatically build you a Configure script that will determine
Xthe value of those symbols.  See the README file for a description of how
Xto use metaconfig.
X
XIn the following listing, the Unit: line indicates the name of the unit
Xwhere this symbol is defined, and the Wants: line indicates what other
Xsymbols must be determined in order to figure out the value of this one.
XIf there is an "(Also defines ...)" entry, it indicates what other symbols
Xare defined by the Unit other than the one corresponding to the unit name.
X
XVariable of the form d_* either have the value "define" or "/*undef", and
Xcontrol whether some C preprocessor symbol gets defined or not.
X
X';
X
X@ARGV = <U/*.U>;
Xwhile (<>) {
X    if (/^\?MAKE:.*:/) {
X	($unit,$also,$wants) = /^\?MAKE:\s*(\w+)\s*(.*):\s*(.*)/;
X	$head = '';
X	$_ = "Unit: $unit";
X	$_ .= " (Also defines $also)" if $also;
X	while (length($_) > 70) {
X	    $tmp = substr($_,0,70);
X	    $tmp =~ s/^(.*) .*/$1/;
X	    $head .= "\t$tmp\n";
X	    $_ = ' ' . substr($_,length($tmp),9999);
X	}
X	$head .= "\t$_\n";
X	$_ = "Wants: $wants";
X	while (length($_) > 70) {
X	    $tmp = substr($_,0,70);
X	    $tmp =~ s/^(.*) .*/$1/;
X	    $head .= "\t$tmp\n";
X	    $_ = ' ' . substr($_,length($tmp),9999);
X	}
X	$head .= "\t$_\n\n";
X    }
X    if (s/^\?[CS]:(\w+):*[ 	]*$/$1:/) {
X	$sym = $1;
X	push(@syms,$sym);
X	$def{$sym} .= $_ . $head;
X    }
X    elsif (s/^\?[CS]://) {
X	if (/^\.$/) {
X	    $def{$sym} .= "\n";
X	    $sym = '';
X	}
X	else {
X	    s/^(\t|  ? ? ? ? ? ? ?)//;
X	    $def{$sym} .= "\t" . $_;
X	}
X    }
X}
X
Xforeach $sym (sort @syms) {
X    print G $def{$sym};
X}
Xclose G;
!STUFFY!FUNK!
echo Extracting patchlevel.h
sed >patchlevel.h <<'!STUFFY!FUNK!' -e 's/X//'
X#define PATCHLEVEL 0
!STUFFY!FUNK!
echo ""
echo "End of kit 3 (of 7)"
cat /dev/null >kit3isdone
run=''
config=''
for iskit in 1 2 3 4 5 6 7; do
    if test -f kit${iskit}isdone; then
	run="$run $iskit"
    else
	todo="$todo $iskit"
    fi
done
case $todo in
    '')
	echo "You have run all your kits.  Please read README and then type Configure."
	chmod 755 Configure
	;;
    *)  echo "You have run$run."
	echo "You still need to run$todo."
	;;
esac
: Someone might mail this, so...
exit

