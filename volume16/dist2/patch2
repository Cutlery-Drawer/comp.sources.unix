Subject:  v16i042:  Larry Wall's Configure generator, etc., Patch2
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Larry Wall <lwall@jpl-devvax.jpl.nasa.gov>
Posting-number: Volume 16, Issue 42
Archive-name: dist2/patch2

[  This is the second of two patches; that's all there's been, so far.  --r$  ]

[The latest patch for dist version 2.0 is #1.]

System: dist version 2.0
Patch #: 2
Subject: patch 1 continued

Description:
	See patch 1.

Fix:	From rn, say "| patch -p -N -d DIR", where DIR is your dist source
	directory.  Outside of rn, say "cd DIR; patch -p -N <thisarticle".
	If you don't have the patch program, apply the following by hand,
	or get patch (version 2.0, latest patchlevel).

	After patching:
		Configure -d
		make
		make install

	If patch indicates that patchlevel is the wrong version, you may need
	to apply one or more previous patches, or the patch may already
	have been applied.  See the patchlevel.h file to find out what has or
	has not been applied.  In any event, don't continue with the patch.

	If you are missing previous patches they can be obtained from me:

	Larry Wall
	lwall@jpl-devvax.Jpl.Nasa.Gov

	If you send a mail message of the following form it will greatly speed
	processing:

	Subject: Command
	@SH mailpatch PATH dist 2.0 LIST
		   ^ note the c

	where PATH is a return path FROM ME TO YOU either in Internet notation,
	or in bang notation from some well-known host, and LIST is the number
	of one or more patches you need, separated by spaces, commas, and/or
	hyphens.  Saying 35- says everything from 35 to the end.


	You can also get the patches via anonymous FTP from
	jpl-devvax.Jpl.Nasa.Gov.  (128.149.8.43)

Index: patchlevel.h
Prereq: 1
1c1
< #define PATCHLEVEL 1
---
> #define PATCHLEVEL 2

Index: mcon/U/d_sigvec.U
*** mcon/U/d_sigvec.U.old	Fri Aug  5 00:54:56 1988
--- mcon/U/d_sigvec.U	Fri Aug  5 00:54:58 1988
***************
*** 0 ****
--- 1,49 ----
+ ?RCS: $Header: d_sigvec.U,v 2.0.1.1 88/08/05 00:48:08 lwall Exp $
+ ?X: d_sigvec.U, from d_ftime.U 1.0
+ ?X:
+ ?RCS: $Log:	d_sigvec.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:48:08  lwall
+ ?RCS: patch1: created
+ ?RCS: 
+ ?MAKE:d_sigvec d_sigvectr: contains libc
+ ?MAKE:	-pick add $@ %*
+ ?S:d_sigvec:
+ ?S:	This variable conditionally defines the SIGVEC symbol, which indicates
+ ?S:	that BSD reliable signals are supported.
+ ?S:.
+ ?S:d_sigvectr:
+ ?S:	This variable conditionally defines the SIGVECTOR symbol, which
+ ?S:	indicates that the sigvec() routine is called sigvector() instead, for
+ ?S:	reasons known only to Hewlett-Packard.
+ ?S:.
+ ?C:SIGVEC:
+ ?C:	This symbol, if defined, indicates that BSD reliable signals are
+ ?C:	supported.
+ ?C:.
+ ?C:SIGVECTOR:
+ ?C:	This symbol, if defined, indicates that the sigvec() routine is called
+ ?C:	sigvector() instead, and that sigspace() is provided instead of
+ ?C:	sigstack().  This is probably only true for HP-UX.
+ ?C:.
+ ?H:?%1:#$d_sigvec	SIGVEC		/**/
+ ?H:?%1:
+ ?H:?%1:#$d_sigvectr	SIGVECTOR	/**/
+ ?H:?%1:
+ : see if sigvector exists -- since sigvec will match the substring
+ echo " "
+ if $contains sigvector libc.list >/dev/null 2>&1; then
+     echo 'sigvector() found--you must be running HP-UX.'
+     d_sigvectr="$define"
+     d_sigvec="$define"
+ else
+ : try the original name
+     d_sigvectr="$undef"
+     if $contains sigvec libc.list >/dev/null 2>&1; then
+ 	echo 'sigvec() found.'
+ 	d_sigvec="$define"
+     else
+ 	echo 'sigvec() not found--race conditions with signals may occur.'
+ 	d_sigvec="$undef"
+     fi
+ fi
+ 

Index: mcon/U/d_socket.U
*** mcon/U/d_socket.U.old	Fri Aug  5 00:55:01 1988
--- mcon/U/d_socket.U	Fri Aug  5 00:55:02 1988
***************
*** 0 ****
--- 1,88 ----
+ ?RCS: $Header: d_socket.U,v 2.0.1.1 88/08/05 00:48:30 lwall Exp $
+ ?X: d_socket.U, from d_ftime.U 1.0
+ ?X:
+ ?RCS: $Log:	d_socket.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:48:30  lwall
+ ?RCS: patch1: created
+ ?RCS: 
+ ?RCS: 
+ ?MAKE:d_socket d_oldsock socketlib sockethdr: contains libc
+ ?MAKE:	-pick add $@ %*
+ ?S:d_socket:
+ ?S:	This variable conditionally defines the SOCKET symbol, which indicates
+ ?S:	that the BSD socket interface is supported.
+ ?S:.
+ ?S:d_oldsock:
+ ?S:	This variable conditionally defines the OLDSOCKET symbol, which
+ ?S:	indicates that the BSD socket interface is based on 4.1c and not 4.2.
+ ?S:.
+ ?S:socketlib:
+ ?S:	This variable has the names of any libraries needed for socket support.
+ ?S:.
+ ?S:sockethdr:
+ ?S:	This variable has any cpp -I flags needed for socket support.
+ ?S:.
+ ?C:SOCKET:
+ ?C:	This symbol, if defined, indicates that the BSD socket interface is
+ ?C:	supported.
+ ?C:.
+ ?C:OLDSOCKET:
+ ?C:	This symbol, if defined, indicates that the 4.1c BSD socket interface
+ ?C:	is supported instead of the 4.2/4.3 BSD socket interface.
+ ?C:.
+ ?H:?%1:#$d_socket	SOCKET		/**/
+ ?H:?%1:
+ ?H:?%1:#$d_oldsock	OLDSOCKET	/**/
+ ?H:?%1:
+ socketlib=''
+ sockethdr=''
+ : see whether socket exists
+ echo " "
+ if $contains socket libc.list >/dev/null 2>&1; then
+     echo "Looks like you have Berkeley networking support."
+     d_socket="$define"
+     : now check for advanced features
+     if $contains setsockopt libc.list >/dev/null 2>&1; then
+ 	d_oldsock="$undef"
+     else
+ 	echo "...but it uses the old 4.1c interface, rather than 4.2"
+ 	d_oldsock="$define"
+     fi
+ else
+     : hpux, for one, puts all the socket stuff in socklib.o
+     if $contains socklib libc.list >/dev/null 2>&1; then
+ 	echo "Looks like you have Berkeley networking support."
+ 	d_socket="$define"
+ 	: we will have to assume that it supports the 4.2 BSD interface
+ 	d_oldsock="$undef"
+     else
+ 	echo "Hmmm...you don't have Berkeley networking in libc.a..."
+ 	: look for an optional networking library
+ 	if test -f /usr/lib/libnet.a; then
+ 	    (ar t /usr/lib/libnet.a ||
+ 		nm -g /usr/lib/libnet.a) 2>/dev/null >> libc.list
+ 	    if $contains socket libc.list >/dev/null 2>&1; then
+ 		echo "but the Wollongong group seems to have hacked it in."
+ 		socketlib="-lnet"
+ 		sockethdr="-I/usr/netinclude"
+ 		d_socket="$define"
+ 		: now check for advanced features
+ 		if $contains setsockopt libc.list >/dev/null 2>&1; then
+ 		    d_oldsock="$undef"
+ 		else
+ 		    echo "...using the old 4.1c interface, rather than 4.2"
+ 		    d_oldsock="$define"
+ 		fi
+ 	    else
+ 		echo "or even in libnet.a, which is peculiar."
+ 		d_socket="$undef"
+ 		d_oldsock="$undef"
+ 	    fi
+ 	else
+ 	    echo "or anywhere else I see."
+ 	    d_socket="$undef"
+ 	    d_oldsock="$undef"
+ 	fi
+     fi
+ fi
+ 

Index: mcon/U/d_strctcpy.U
Prereq: 2.0
*** mcon/U/d_strctcpy.U.old	Fri Aug  5 00:55:06 1988
--- mcon/U/d_strctcpy.U	Fri Aug  5 00:55:06 1988
***************
*** 1,9 ****
! ?RCS:$Header: d_strctcpy.U,v 2.0 88/06/28 23:16:02 lwall Exp $
  ?RCS: $Log:	d_strctcpy.U,v $
  ?RCS: Revision 2.0  88/06/28  23:16:02  lwall
  ?RCS: Baseline.
  ?RCS: 
! ?MAKE:d_strctcpy: cat rm
  ?MAKE:	-pick add $@ %*
  ?S:d_strctcpy:
  ?S:	This variable conditionally defines the STRUCTCOPY symbol, which
--- 1,12 ----
! ?RCS:$Header: d_strctcpy.U,v 2.0.1.1 88/08/05 00:16:28 lwall Exp $
  ?RCS: $Log:	d_strctcpy.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:16:28  lwall
+ ?RCS: patch1: made depend on cc
+ ?RCS: 
  ?RCS: Revision 2.0  88/06/28  23:16:02  lwall
  ?RCS: Baseline.
  ?RCS: 
! ?MAKE:d_strctcpy: cat rm cc
  ?MAKE:	-pick add $@ %*
  ?S:d_strctcpy:
  ?S:	This variable conditionally defines the STRUCTCOPY symbol, which
***************
*** 30,36 ****
  	foo = bar;
  }
  EOCP
! if cc -c try.c >/dev/null 2>&1 ; then
      d_strctcpy="$define"
      echo "Yup, it can."
  else
--- 33,39 ----
  	foo = bar;
  }
  EOCP
! if $cc -c try.c >/dev/null 2>&1 ; then
      d_strctcpy="$define"
      echo "Yup, it can."
  else

Index: mcon/U/fpu.U
Prereq: 2.0
*** mcon/U/fpu.U.old	Fri Aug  5 00:55:09 1988
--- mcon/U/fpu.U	Fri Aug  5 00:55:10 1988
***************
*** 1,5 ****
! ?RCS:$Header: fpu.U,v 2.0 88/06/28 23:16:43 lwall Exp $
  ?RCS: $Log:	fpu.U,v $
  ?RCS:Revision 2.0  88/06/28  23:16:43  lwall
  ?RCS:Baseline.
  ?RCS:
--- 1,8 ----
! ?RCS:$Header: fpu.U,v 2.0.1.1 88/08/05 00:17:02 lwall Exp $
  ?RCS: $Log:	fpu.U,v $
+ ?RCS:Revision 2.0.1.1  88/08/05  00:17:02  lwall
+ ?RCS:patch1: not all Suns have the 68881
+ ?RCS:
  ?RCS:Revision 2.0  88/06/28  23:16:43  lwall
  ?RCS:Baseline.
  ?RCS:
***************
*** 7,13 ****
  ?RCS: Revision 1.0  87/05/22  12:32:25  siegel
  ?RCS: Initial revision
  ?RCS: 
! ?MAKE:fpu: contains echo n Myread c
  ?MAKE:	-pick add $@ %*
  ?S:fpu:
  ?S:	set to be the compile flag for the local floating point unit.
--- 10,16 ----
  ?RCS: Revision 1.0  87/05/22  12:32:25  siegel
  ?RCS: Initial revision
  ?RCS: 
! ?MAKE:fpu: contains echo n Myread c cc
  ?MAKE:	-pick add $@ %*
  ?S:fpu:
  ?S:	set to be the compile flag for the local floating point unit.
***************
*** 24,30 ****
  	cat>fpa.c << GOOP
  	main(){return(1);}
  GOOP
! 	cc -ffpa fpa.c -o fpa
  	fpa > fpa.out 2>&1
  	if test ! -s fpa.out; then
  		dflt='y'
--- 27,33 ----
  	cat>fpa.c << GOOP
  	main(){return(1);}
  GOOP
! 	$cc -ffpa fpa.c -o fpa
  	fpa > fpa.out 2>&1
  	if test ! -s fpa.out; then
  		dflt='y'
***************
*** 51,57 ****
  	if $test -r /usr/etc/mc68881version; then
  		dflt='y'
  		$echo "There also seems to be the pieces for a 68881. If"
! 		$echo "I compile this in, it will work on all Sun 3's..."
  		$echo $n "Should I compile for a 68881? [$dflt] $c"
  		rp="use 68881? [$dflt] "
  		. myread
--- 54,61 ----
  	if $test -r /usr/etc/mc68881version; then
  		dflt='y'
  		$echo "There also seems to be the pieces for a 68881. If"
! 		$echo "I compile this in, it will work on almost all Sun 3's"
! 		$echo "except for a few Sun-3/50s without a 68881..."
  		$echo $n "Should I compile for a 68881? [$dflt] $c"
  		rp="use 68881? [$dflt] "
  		. myread

Index: mcon/U/inc.U
*** mcon/U/inc.U.old	Fri Aug  5 00:55:12 1988
--- mcon/U/inc.U	Fri Aug  5 00:55:13 1988
***************
*** 0 ****
--- 1,43 ----
+ ?RCS: $Header: inc.U,v 2.0.1.1 88/08/05 00:49:14 lwall Exp $
+ ?X: inc.U from bin.U 1.0
+ ?RCS: $Log:	inc.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:49:14  lwall
+ ?RCS: patch1: created
+ ?RCS: 
+ ?MAKE:inc: test echo n c Myread Loc Filexp Oldconfig
+ ?MAKE:	-pick add $@ %*
+ ?S:inc:
+ ?S:	This variable holds the name of the directory in which the user wants
+ ?S:	to put public header files for the package in question.  It is most
+ ?S:	often a local directory such as /usr/local/include.
+ ?S:.
+ : determine where public header files go
+ case "$inc" in
+ '')
+     dflt=`loc . "." /usr/local/include /usr/include/local /usr/include`
+     ;;
+ *)  dflt="$inc"
+     ;;
+ esac
+ cont=true
+ while $test "$cont" ; do
+     echo " "
+     rp="Where do you want to put the public header files? [$dflt]"
+     $echo $n "$rp $c"
+     . myread
+     inc="$ans"
+     inc=`filexp $inc`
+     if test -d "$inc"; then
+ 	cont=''
+     else
+ 	dflt=n
+ 	rp="Directory $inc doesn't exist.  Use that name anyway? [$dflt]"
+ 	$echo $n "$rp $c"
+ 	. myread
+ 	dflt=''
+ 	case "$ans" in
+ 	y*) cont='';;
+ 	esac
+     fi
+ done
+ 

Index: mcon/U/lib.U
*** mcon/U/lib.U.old	Fri Aug  5 00:55:16 1988
--- mcon/U/lib.U	Fri Aug  5 00:55:17 1988
***************
*** 0 ****
--- 1,78 ----
+ ?RCS: $Header: lib.U,v 2.0.1.1 88/08/05 00:49:30 lwall Exp $
+ ?X: lib.U from bin.U 1.0
+ ?RCS: $Log:	lib.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:49:30  lwall
+ ?RCS: patch1: created
+ ?RCS: 
+ ?MAKE:lib lintlib: test echo n c Myread Loc Filexp Oldconfig
+ ?MAKE:	-pick add $@ %*
+ ?S:lib:
+ ?S:	This variable holds the name of the directory in which the user wants
+ ?S:	to put public library files for the package in question.  It is most
+ ?S:	often a local directory such as /usr/local/lib.
+ ?S:.
+ ?S:lintlib:
+ ?S:	This variable holds the name of the directory in which the user wants
+ ?S:	to put public lint-library files for the package in question.  It is
+ ?S:	most often a local directory such as /usr/local/lib/lint.
+ ?S:.
+ : determine where public libraries go
+ case "$lib" in
+ '')
+     dflt=`loc . "." /usr/local/lib /usr/lib /lib`
+     ;;
+ *)  dflt="$lib"
+     ;;
+ esac
+ cont=true
+ while $test "$cont" ; do
+     echo " "
+     rp="Where do you want to put the public libraries? [$dflt]"
+     $echo $n "$rp $c"
+     . myread
+     lib="$ans"
+     lib=`filexp $lib`
+     if test -d "$lib"; then
+ 	cont=''
+     else
+ 	dflt=n
+ 	rp="Directory $lib doesn't exist.  Use that name anyway? [$dflt]"
+ 	$echo $n "$rp $c"
+ 	. myread
+ 	dflt=''
+ 	case "$ans" in
+ 	y*) cont='';;
+ 	esac
+     fi
+ done
+ 
+ : determine where public lint libraries go
+ case "$lintlib" in
+ '')
+     dflt=`loc . "." /usr/local/lib/lint /usr/lib/lint /usr/lib`
+     ;;
+ *)  dflt="$lintlib"
+     ;;
+ esac
+ cont=true
+ while $test "$cont" ; do
+     echo " "
+     rp="Where do you want to put the public lint libraries? [$dflt]"
+     $echo $n "$rp $c"
+     . myread
+     lintlib="$ans"
+     lintlib=`filexp $lintlib`
+     if test -d "$lintlib"; then
+ 	cont=''
+     else
+ 	dflt=n
+ 	rp="Directory $lintlib doesn't exist.  Use that name anyway? [$dflt]"
+ 	$echo $n "$rp $c"
+ 	. myread
+ 	dflt=''
+ 	case "$ans" in
+ 	y*) cont='';;
+ 	esac
+     fi
+ done
+ 

Index: mcon/U/libc.U
Prereq: 2.0
*** mcon/U/libc.U.old	Fri Aug  5 00:55:19 1988
--- mcon/U/libc.U	Fri Aug  5 00:55:20 1988
***************
*** 1,5 ****
! ?RCS:$Header: libc.U,v 2.0 88/06/28 23:16:50 lwall Exp $
  ?RCS: $Log:	libc.U,v $
  ?RCS: Revision 2.0  88/06/28  23:16:50  lwall
  ?RCS: Baseline.
  ?RCS: 
--- 1,8 ----
! ?RCS:$Header: libc.U,v 2.0.1.1 88/08/05 00:20:06 lwall Exp $
  ?RCS: $Log:	libc.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:20:06  lwall
+ ?RCS: patch1: now a little smarter about different nm formats
+ ?RCS: 
  ?RCS: Revision 2.0  88/06/28  23:16:50  lwall
  ?RCS: Baseline.
  ?RCS: 
***************
*** 46,56 ****
  fi
  echo " "
  $echo $n "Extracting names from $libc for later perusal...$c"
! nm $libc 2>/dev/null | sed -n -e 's/^.* T _//p' -e 's/^.* T //p' > libc.list
  if $contains '^printf$' libc.list >/dev/null 2>&1; then
      echo "done"
  else
!     nm $libc 2>/dev/null | sed -n -e 's/^.* D _//p' -e 's/^.* D //p' > libc.list
      if $contains '^printf$' libc.list >/dev/null 2>&1; then
  	echo "done"
      else
--- 49,63 ----
  fi
  echo " "
  $echo $n "Extracting names from $libc for later perusal...$c"
! nm $libc 2>/dev/null >libc.tmp
! sed -n -e 's/^.* [AT] _//p' -e 's/^.* [AT] //p' <libc.tmp >libc.list
  if $contains '^printf$' libc.list >/dev/null 2>&1; then
      echo "done"
  else
!     sed -n -e 's/^.* D _//p' -e 's/^.* D //p' <libc.tmp >libc.list
!     $contains '^printf$' libc.list >/dev/null 2>&1 || \
!        sed -n -e 's/^_//' \
! 	      -e 's/^\([a-zA-Z_0-9]*\).*xtern.*text.*/\1/p' <libc.tmp >libc.list
      if $contains '^printf$' libc.list >/dev/null 2>&1; then
  	echo "done"
      else
***************
*** 57,63 ****
  	echo " "
  	echo "nm didn't seem to work right."
  	echo "Trying ar instead..."
- 	rmlist="$rmlist libc.tmp"
  	if ar t $libc > libc.tmp; then
  	    sed -e 's/\.o$//' < libc.tmp > libc.list
  	    echo "Ok."
--- 64,69 ----
***************
*** 73,77 ****
  	fi
      fi
  fi
! rmlist="$rmlist libc.list"
  
--- 79,83 ----
  	fi
      fi
  fi
! rmlist="$rmlist libc.tmp libc.list"
  

Index: kit/makedist.SH
Prereq: 2.0
*** kit/makedist.SH.old	Fri Aug  5 00:53:47 1988
--- kit/makedist.SH	Fri Aug  5 00:53:48 1988
***************
*** 16,28 ****
  : Protect any dollar signs and backticks that you do not want interpreted
  : by putting a backslash in front.
  cat >makedist <<!GROK!THIS!
! #!/usr/bin/perl
! 	eval "exec /usr/bin/perl -S \$0 \$*"
  		if \$running_under_some_shell;
  
! # $Header: makedist.SH,v 2.0 88/06/28 23:12:17 lwall Exp $
  #
  # $Log:	makedist.SH,v $
  # Revision 2.0  88/06/28  23:12:17  lwall
  # Baseline.
  # 
--- 16,32 ----
  : Protect any dollar signs and backticks that you do not want interpreted
  : by putting a backslash in front.
  cat >makedist <<!GROK!THIS!
! #!$perlpath
! 	eval "exec $perlpath -S \$0 \$*"
  		if \$running_under_some_shell;
  
! # $Header: makedist.SH,v 2.0.1.1 88/08/04 23:55:14 lwall Exp $
  #
  # $Log:	makedist.SH,v $
+ # Revision 2.0.1.1  88/08/04  23:55:14  lwall
+ # 
+ # patch1: depends on perlpath now
+ # 
  # Revision 2.0  88/06/28  23:12:17  lwall
  # Baseline.
  # 

Index: mcon/makegloss
*** mcon/makegloss.old	Fri Aug  5 00:55:55 1988
--- mcon/makegloss	Fri Aug  5 00:55:55 1988
***************
*** 1,4 ****
--- 1,6 ----
  #!/usr/bin/perl
+ eval "exec /usr/bin/perl -S $0 $*"
+ 	if $running_under_some_shell;
  open(G,">Glossary") || die "Can't create Glossary.\n";
  print G
  '[This Glossary is automatically generated from the Unit files.  Do not edit

Index: mcon/U/mansrc.U
Prereq: 2.0
*** mcon/U/mansrc.U.old	Fri Aug  5 00:55:23 1988
--- mcon/U/mansrc.U	Fri Aug  5 00:55:23 1988
***************
*** 1,5 ****
! ?RCS:$Header: mansrc.U,v 2.0 88/06/28 23:17:17 lwall Exp $
  ?RCS: $Log:	mansrc.U,v $
  ?RCS: Revision 2.0  88/06/28  23:17:17  lwall
  ?RCS: Baseline.
  ?RCS: 
--- 1,8 ----
! ?RCS:$Header: mansrc.U,v 2.0.1.1 88/08/05 00:20:49 lwall Exp $
  ?RCS: $Log:	mansrc.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:20:49  lwall
+ ?RCS: patch1: can now default to manl
+ ?RCS: 
  ?RCS: Revision 2.0  88/06/28  23:17:17  lwall
  ?RCS: Baseline.
  ?RCS: 
***************
*** 18,24 ****
  : determine where manual pages go
  case "$mansrc" in
  '')
!     dflt=`loc . /usr/man/man1 /usr/man/mann /usr/man/local/man1 /usr/man/u_man/man1 /usr/man/man1`
      ;;
  *)  dflt="$mansrc"
      ;;
--- 21,27 ----
  : determine where manual pages go
  case "$mansrc" in
  '')
!     dflt=`loc . /usr/man/man1 /usr/man/mann /usr/man/manl /usr/man/local/man1 /usr/man/u_man/man1 /usr/man/man1`
      ;;
  *)  dflt="$mansrc"
      ;;

Index: mcon/metaconfig.SH
Prereq: 2.0
*** mcon/metaconfig.SH.old	Fri Aug  5 00:55:59 1988
--- mcon/metaconfig.SH	Fri Aug  5 00:56:00 1988
***************
*** 17,29 ****
  esac
  echo "Extracting metaconfig (with variable substitutions)"
  cat >metaconfig <<!GROK!THIS!
! #!/usr/bin/perl
!         eval "exec /usr/bin/perl -S \$0 \$*"
  		if \$running_under_some_shell;
  
! # $Header: metaconfig.SH,v 2.0 88/06/28 23:18:46 lwall Exp $
  #
  # $Log:	metaconfig.SH,v $
  # Revision 2.0  88/06/28  23:18:46  lwall
  # Baseline.
  # 
--- 17,32 ----
  esac
  echo "Extracting metaconfig (with variable substitutions)"
  cat >metaconfig <<!GROK!THIS!
! #!$perlpath
!         eval "exec $perlpath -S \$0 \$*"
  		if \$running_under_some_shell;
  
! # $Header: metaconfig.SH,v 2.0.1.1 88/08/05 00:27:27 lwall Exp $
  #
  # $Log:	metaconfig.SH,v $
+ # Revision 2.0.1.1  88/08/05  00:27:27  lwall
+ # patch1: now depends on perlpath
+ # 
  # Revision 2.0  88/06/28  23:18:46  lwall
  # Baseline.
  # 

Index: mcon/U/mkdep.U
*** mcon/U/mkdep.U.old	Fri Aug  5 00:55:26 1988
--- mcon/U/mkdep.U	Fri Aug  5 00:55:27 1988
***************
*** 0 ****
--- 1,126 ----
+ ?RCS: $Header: mkdep.U,v 2.0.1.1 88/08/05 00:49:54 lwall Exp $
+ ?X: mkdep.U
+ ?X: 
+ ?RCS: $Log:	mkdep.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:49:54  lwall
+ ?RCS: patch1: created
+ ?RCS: 
+ ?MAKE:mkdep: spitshell startsh cpp grep contains sed sort Oldconfig
+ ?MAKE:	-pick add $@ %*
+ ?S:mkdep:
+ ?S:	This variable holds the name of a command to generate makefile
+ ?S:	dependencies on the standard output.  Usual values are "/lib/cpp -M"
+ ?S:	or the pathname of the mkdep script.
+ ?S:.
+ : see if we have the 4.3 /lib/cpp -M feature
+ echo " "
+ echo "Checking how to generate makefile dependencies on your machine..."
+ $cat >dep.c <<'EOCP'
+ #include "dep.h"
+ EOCP
+ $cat >dep.h <<'EOCP'
+ EOCP
+ if $cpp -M dep.c >dep.out 2>/dev/null </dev/null &&
+ 	$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
+ then
+ 	echo "$cpp -M seems to work here."
+ 	mkdep="$cpp -M"
+ else
+ 	echo $n "$cpp -M doesn't seem to work...$c"
+ 	case "$mkdep" in
+ 	'') ;;
+ 	`pwd`/mkdep)
+ 		mkdep=
+ 		;;
+ 	*)
+ 		if $mkdep dep.c >dep.out 2>/dev/null &&
+ 			$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
+ 		then
+ 			echo "but $mkdep does, as you said before."
+ 		else
+ 			mkdep=
+ 		fi
+ 		;;
+ 	esac
+ 	if test -z "$mkdep"; then
+ 		$spitshell >mkdep <<EOS
+ $startsh
+ for srcfile
+ do
+ 	filebase=\`basename \$srcfile .c\`
+ 	$sed -n -e '/^#/!d' -e 's|/\*.*$||' -e p \$srcfile | \\
+ 	$cpp $cppminus | \\
+ 	$sed -e '/^# *[0-9]/!d' \\
+ 		-e 's/^.*"\(.*\)".*\$/'\$filebase'.o: \1/' \\
+ 		-e 's|: \./|: |' \\
+ 		-e 's|: *$|: '\$srcfile'|' | \\
+ 	$sort -u
+ done
+ EOS
+ 		chmod +x mkdep
+ 		mkdep=`pwd`/mkdep
+ 		if $mkdep dep.c >dep.out 2>/dev/null &&
+ 			$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
+ 		then
+ 			echo "but a shell script using $cpp does."
+ 		else
+ 			echo " "
+ 			echo "in fact, $cpp doesn't seem to be any use at all."
+ 			$spitshell >mkdep2 <<EOS
+ $startsh
+ for srcfile
+ do
+ 	echo \`basename \$srcfile .c\`.o: \$srcfile
+ 	$grep '^#[  ]*include' \$srcfile /dev/null || true | 
+ 	$sed -e 's,<\(.*\)>,"/usr/include/\1",' \\
+ 		-e 's/:[^"]*"\([^"]*\)".*/: \1/' \\
+ 		-e 's/\.c:/\.o:/'
+ done
+ EOS
+ 			chmod +x mkdep2
+ 			mkdep=${mkdep}2
+ 			if $mkdep dep.c >dep.out 2>/dev/null &&
+ 			    $contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
+ 			then
+ 				cat << EOM
+ I can use a script with grep instead, but it will make some incorrect
+ dependencies, since it doesn't understand about conditional compilation.
+ If you have a program which generates makefile dependencies, you may want
+ to use it.  If not, you can use the script and edit the Makefile by hand
+ if you need to.
+ EOM
+ 			else
+ 				mkdep=
+ 				cat << EOM
+ I can't seem to generate makefile dependencies at all!  Perhaps you have a
+ program which does?  If you don't, you might look in `pwd` at the
+ mkdep and mkdep2 scripts to see if you can create one which works.
+ EOM
+ 			fi
+ 		fi	
+ 	fi
+ 	cont=true
+ 	dflt="$mkdep"
+ 	while $test "$cont" ; do
+ 		echo " "
+ 	rp="Name of program to make makefile dependencies? [$dflt]"
+ 	$echo $n "$rp $c"
+ 	. myread
+ 	mkdep="$ans"
+ 	mkdep=`filexp $mkdep`
+ 	if test -f "$mkdep"; then
+ 		cont=''
+ 	else
+ 		dflt=n
+ 		rp="$mkdep doesn't exist.  Use that name anyway? [$dflt]"
+ 		$echo $n "$rp $c"
+ 		. myread
+ 		dflt=''
+ 		case "$ans" in
+ 		y*) cont='';;
+ 		esac
+ 	fi
+ done
+ fi
+ rm -f dep.c dep.h dep.o dep.out
+ 

Index: mcon/U/models.U
Prereq: 2.0
*** mcon/U/models.U.old	Fri Aug  5 00:55:31 1988
--- mcon/U/models.U	Fri Aug  5 00:55:33 1988
***************
*** 1,9 ****
! ?RCS:$Header: models.U,v 2.0 88/06/28 23:17:24 lwall Exp $
  ?RCS: $Log:	models.U,v $
  ?RCS: Revision 2.0  88/06/28  23:17:24  lwall
  ?RCS: Baseline.
  ?RCS: 
! ?MAKE:models split small medium large huge ccflags ldflags: test cat echo n c Myread Cppsym
  ?MAKE:	-pick add $@ %*
  ?S:models:
  ?S:	This variable contains the list of memory models supported by this
--- 1,12 ----
! ?RCS:$Header: models.U,v 2.0.1.1 88/08/05 00:21:57 lwall Exp $
  ?RCS: $Log:	models.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:21:57  lwall
+ ?RCS: patch1: incorporated old cc unit
+ ?RCS: 
  ?RCS: Revision 2.0  88/06/28  23:17:24  lwall
  ?RCS: Baseline.
  ?RCS: 
! ?MAKE:models split small medium large huge ccflags ldflags cc: test cat echo n c Myread mansrc Mcc Guess Oldconfig Loc
  ?MAKE:	-pick add $@ %*
  ?S:models:
  ?S:	This variable contains the list of memory models supported by this
***************
*** 46,55 ****
  ?S:	This variable contains any additional C loader flags desired by
  ?S:	the user.  It is up to the Makefile to use this.
  ?S:.
  : see what memory models we can support
  case "$models" in
  '')
!     if Cppsym pdp11; then
  	dflt='unsplit split'
      else
  	ans=`loc . X /lib/small /lib/large /usr/lib/small /usr/lib/large /lib/medium /usr/lib/medium /lib/huge`
--- 49,75 ----
  ?S:	This variable contains any additional C loader flags desired by
  ?S:	the user.  It is up to the Makefile to use this.
  ?S:.
+ ?S:cc:
+ ?S:	This variable holds the name of a command to execute a C compiler which
+ ?S:	can resolve multiple global references that happen to have the same
+ ?S:	name.  Usual values are "cc", "Mcc", "cc -M", and "gcc".
+ ?S:.
  : see what memory models we can support
  case "$models" in
  '')
!     : We may not use Cppsym or we get a circular dependency through cc.
!     : But this should work regardless of which cc we eventually use.
!     cat >pdp11.c <<'EOP'
! main() {
! #ifdef pdp11
!     exit(0);
! #else
!     exit(1);
! #endif
! }
! EOP
!     cc -o pdp11 pdp11.c >/dev/null 2>&1
!     if pdp11 2>/dev/null; then
  	dflt='unsplit split'
      else
  	ans=`loc . X /lib/small /lib/large /usr/lib/small /usr/lib/large /lib/medium /usr/lib/medium /lib/huge`
***************
*** 191,196 ****
--- 211,269 ----
      ;;
  esac
  
+ : see if we need a special compiler
+ echo " "
+ if usg; then
+     case "$cc" in
+     '')
+ 	case "$Mcc" in
+ 	/*) dflt='Mcc'
+ 	    ;;
+ 	*)
+ 	    case "$large" in
+ 	    -M*)
+ 		dflt='cc'
+ 		;;
+ 	    *)
+ 		if $contains '\-M' $mansrc/cc.1 >/dev/null 2>&1 ; then
+ 		    dflt='cc -M'
+ 		else
+ 		    dflt='cc'
+ 		fi
+ 		;;
+ 	    esac
+ 	    ;;
+ 	esac
+ 	;;
+     *)  dflt="$cc";;
+     esac
+     $cat <<'EOM'
+  
+ On some systems the default C compiler will not resolve multiple global
+ references that happen to have the same name.  On some such systems the
+ "Mcc" command may be used to force these to be resolved.  On other systems
+ a "cc -M" command is required.  (Note that the -M flag on other systems
+ indicates a memory model to use!)  If you have the Gnu C compiler, you
+ might wish to use that instead.  What command will force resolution on
+ EOM
+     $echo $n "this system? [$dflt] $c"
+     rp="Command to resolve multiple refs? [$dflt]"
+     . myread
+     cc="$ans"
+ else
+     case "$cc" in
+     '') dflt=cc;;
+     *) dflt="$cc";;
+     esac
+     rp="Use which C compiler? [$dflt]"
+     $echo $n "$rp $c"
+     . myread
+     cc="$ans"
+ fi
+ case "$cc" in
+ gcc*) cpp=`loc gcc-cpp $cpp $pth`;;
+ esac
+ 
  case "$ccflags" in
  '') dflt='none';;
  *) dflt="$ccflags";;
***************
*** 221,224 ****
--- 294,298 ----
  none) ans='';
  esac
  ldflags="$ans"
+ rmlist="$rmlist pdp11"
  

Index: mcon/U/orderlib.U
*** mcon/U/orderlib.U.old	Fri Aug  5 00:55:35 1988
--- mcon/U/orderlib.U	Fri Aug  5 00:55:36 1988
***************
*** 0 ****
--- 1,45 ----
+ ?RCS: $Header: orderlib.U,v 2.0.1.1 88/08/05 00:50:17 lwall Exp $
+ ?X: orderlib.U
+ ?X: 
+ ?RCS: $Log:	orderlib.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:50:17  lwall
+ ?RCS: patch1: created
+ ?RCS: 
+ ?MAKE:orderlib ranlib:
+ ?MAKE:	-pick add $@ %*
+ ?S:orderlib:
+ ?S:	This variable is "true" if the components of libraries must be ordered
+ ?S:	(with `lorder $* | tsort`) before placing them in an archive.  Set to
+ ?S:	"false" if ranlib or ar can generate random libraries.
+ ?S:.
+ ?S:ranlib:
+ ?S:	This variable is set to the pathname of the ranlib program, if it is
+ ?S:	needed to generate random libraries.  Set to ":" if ar can generate
+ ?S:	random libraries or if random libraries are not supported
+ ?S:.
+ : see if ar generates random libraries by itself
+ echo " "
+ echo "Checking how to generate random libraries on your machine..."
+ ar rc ran.a /dev/null
+ if ar ts ran.a >/dev/null 2>&1; then
+ 	echo "ar appears to generate random libraries itself."
+ 	orderlib=false
+ 	ranlib=":"
+ else
+ 	if test -f /usr/bin/ranlib; then
+ 		ranlib=/usr/bin/ranlib
+ 	elif test -f /bin/ranlib; then
+ 		ranlib=/bin/ranlib
+ 	fi
+ 
+ 	if test -n "$ranlib"; then
+ 		echo "your system has $ranlib; we'll use that."
+ 		orderlib=false
+ 	else
+ 		echo "your system doesn't seem to support random libraries"
+ 		echo "so we'll use lorder and tsort to order the libraries."
+ 		orderlib=true
+ 		ranlib=":"
+ 	fi
+ fi
+ 

Index: packinit.SH
Prereq: 2.0
*** packinit.SH.old	Fri Aug  5 00:56:06 1988
--- packinit.SH	Fri Aug  5 00:56:06 1988
***************
*** 16,28 ****
  esac
  echo "Extracting packinit (with variable substitutions)"
  cat >packinit <<!GROK!THIS!
! #!/usr/bin/perl
! 	eval "exec /usr/bin/perl -S \$0 \$*"
  		if \$running_under_some_shell;
  
! # $Header: packinit.SH,v 2.0 88/06/28 23:18:55 lwall Exp $
  #
  # $Log:	packinit.SH,v $
  # Revision 2.0  88/06/28  23:18:55  lwall
  # Baseline.
  # 
--- 16,31 ----
  esac
  echo "Extracting packinit (with variable substitutions)"
  cat >packinit <<!GROK!THIS!
! #!$perlpath
! 	eval "exec $perlpath -S \$0 \$*"
  		if \$running_under_some_shell;
  
! # $Header: packinit.SH,v 2.0.1.1 88/08/05 00:27:49 lwall Exp $
  #
  # $Log:	packinit.SH,v $
+ # Revision 2.0.1.1  88/08/05  00:27:49  lwall
+ # patch1: now depends on perlpath
+ # 
  # Revision 2.0  88/06/28  23:18:55  lwall
  # Baseline.
  # 

Index: pat/pat.SH
Prereq: 2.0
*** pat/pat.SH.old	Fri Aug  5 00:56:10 1988
--- pat/pat.SH	Fri Aug  5 00:56:11 1988
***************
*** 17,29 ****
  esac
  echo "Extracting pat (with variable substitutions)"
  cat >pat <<!GROK!THIS!
! #!/usr/bin/perl
! 	eval "exec /usr/bin/perl -S \$0 \$*"
  		if \$running_under_some_shell;
  
! # $Header: pat.SH,v 2.0 88/06/28 23:19:17 lwall Exp $
  #
  # $Log:	pat.SH,v $
  # Revision 2.0  88/06/28  23:19:17  lwall
  # Baseline.
  # 
--- 17,32 ----
  esac
  echo "Extracting pat (with variable substitutions)"
  cat >pat <<!GROK!THIS!
! #!$perlpath
! 	eval "exec $perlpath -S \$0 \$*"
  		if \$running_under_some_shell;
  
! # $Header: pat.SH,v 2.0.1.1 88/08/05 00:28:32 lwall Exp $
  #
  # $Log:	pat.SH,v $
+ # Revision 2.0.1.1  88/08/05  00:28:32  lwall
+ # patch1: now depends on perlpath
+ # 
  # Revision 2.0  88/06/28  23:19:17  lwall
  # Baseline.
  # 

Index: pat/patbase.SH
Prereq: 2.0
*** pat/patbase.SH.old	Fri Aug  5 00:56:15 1988
--- pat/patbase.SH	Fri Aug  5 00:56:16 1988
***************
*** 16,28 ****
  esac
  echo "Extracting patbase (with variable substitutions)"
  cat >patbase <<!GROK!THIS!
! #!/usr/bin/perl
!         eval "exec /usr/bin/perl -S \$0 \$*"
                  if \$running_under_some_shell;
  
! # $Header: patbase.SH,v 2.0 88/06/28 23:19:25 lwall Exp $
  #
  # $Log:	patbase.SH,v $
  # Revision 2.0  88/06/28  23:19:25  lwall
  # Baseline.
  # 
--- 16,31 ----
  esac
  echo "Extracting patbase (with variable substitutions)"
  cat >patbase <<!GROK!THIS!
! #!$perlpath
!         eval "exec $perlpath -S \$0 \$*"
                  if \$running_under_some_shell;
  
! # $Header: patbase.SH,v 2.0.1.1 88/08/05 00:29:09 lwall Exp $
  #
  # $Log:	patbase.SH,v $
+ # Revision 2.0.1.1  88/08/05  00:29:09  lwall
+ # patch1: now depends on perlpath
+ # 
  # Revision 2.0  88/06/28  23:19:25  lwall
  # Baseline.
  # 

Index: pat/patcil.SH
Prereq: 2.0
*** pat/patcil.SH.old	Fri Aug  5 00:56:19 1988
--- pat/patcil.SH	Fri Aug  5 00:56:20 1988
***************
*** 15,27 ****
  esac
  echo "Extracting patcil (with variable substitutions)"
  $cat >patcil <<!GROK!THIS!
! #!/usr/bin/perl -i~
!         eval "exec /usr/bin/perl -S \$0 \$*"
                  if \$running_under_some_shell;
  
! # $Header: patcil.SH,v 2.0 88/06/29 00:21:39 lwall Exp $
  #
  # $Log:	patcil.SH,v $
  # Revision 2.0  88/06/29  00:21:39  lwall
  # Baseline.
  # 
--- 15,33 ----
  esac
  echo "Extracting patcil (with variable substitutions)"
  $cat >patcil <<!GROK!THIS!
! #!$perlpath -i~
!         eval "exec $perlpath -S \$0 \$*"
                  if \$running_under_some_shell;
  
! # $Header: patcil.SH,v 2.0.1.2 88/08/05 00:51:51 lwall Exp $
  #
  # $Log:	patcil.SH,v $
+ # Revision 2.0.1.2  88/08/05  00:51:51  lwall
+ # patch1: created
+ # 
+ # Revision 2.0.1.1  88/08/05  00:29:17  lwall
+ # patch1: now depends on perlpath
+ # 
  # Revision 2.0  88/06/29  00:21:39  lwall
  # Baseline.
  # 
***************
*** 198,204 ****
  	}
  	if ($patching && !$total) {	# check in null as trunk revision
  	    rename($file, "$file.xxx");
! 	    `cp /dev/null $file` unless -f "$file.xxx";
  	    if (system 'ci', "-l$baserev", @sw, @files) {
  		print "Trying again...\n";
  		system 'ci', "-r$baserev", @sw, @files;
--- 204,210 ----
  	}
  	if ($patching && !$total) {	# check in null as trunk revision
  	    rename($file, "$file.xxx");
! 	    `cp /dev/null $file` unless -f $file;
  	    if (system 'ci', "-l$baserev", @sw, @files) {
  		print "Trying again...\n";
  		system 'ci', "-r$baserev", @sw, @files;

Index: pat/patdiff.SH
Prereq: 2.0
*** pat/patdiff.SH.old	Fri Aug  5 00:56:25 1988
--- pat/patdiff.SH	Fri Aug  5 00:56:25 1988
***************
*** 16,28 ****
  esac
  echo "Extracting patdiff (with variable substitutions)"
  cat >patdiff <<!GROK!THIS!
! #!/usr/bin/perl
!         eval "exec /usr/bin/perl -S \$0 \$*"
                  if \$running_under_some_shell;
  
! # $Header: patdiff.SH,v 2.0 88/06/28 23:19:39 lwall Exp $
  #
  # $Log:	patdiff.SH,v $
  # Revision 2.0  88/06/28  23:19:39  lwall
  # Baseline.
  # 
--- 16,31 ----
  esac
  echo "Extracting patdiff (with variable substitutions)"
  cat >patdiff <<!GROK!THIS!
! #!$perlpath
!         eval "exec $perlpath -S \$0 \$*"
                  if \$running_under_some_shell;
  
! # $Header: patdiff.SH,v 2.0.1.1 88/08/05 00:29:42 lwall Exp $
  #
  # $Log:	patdiff.SH,v $
+ # Revision 2.0.1.1  88/08/05  00:29:42  lwall
+ # patch1: now depends on perlpath
+ # 
  # Revision 2.0  88/06/28  23:19:39  lwall
  # Baseline.
  # 

Index: pat/patftp.SH
Prereq: 2.0
*** pat/patftp.SH.old	Fri Aug  5 00:56:29 1988
--- pat/patftp.SH	Fri Aug  5 00:56:30 1988
***************
*** 17,29 ****
  esac
  echo "Extracting patftp (with variable substitutions)"
  cat >patftp <<!GROK!THIS!
! #!/usr/bin/perl
!         eval "exec /usr/bin/perl -S \$0 \$*"
                  if \$running_under_some_shell;
  
! # $Header: patftp.SH,v 2.0 88/06/28 23:19:57 lwall Exp $
  #
  # $Log:	patftp.SH,v $
  # Revision 2.0  88/06/28  23:19:57  lwall
  # Baseline.
  # 
--- 17,32 ----
  esac
  echo "Extracting patftp (with variable substitutions)"
  cat >patftp <<!GROK!THIS!
! #!$perlpath
!         eval "exec $perlpath -S \$0 \$*"
                  if \$running_under_some_shell;
  
! # $Header: patftp.SH,v 2.0.1.1 88/08/05 00:29:52 lwall Exp $
  #
  # $Log:	patftp.SH,v $
+ # Revision 2.0.1.1  88/08/05  00:29:52  lwall
+ # patch1: now depends on perlpath
+ # 
  # Revision 2.0  88/06/28  23:19:57  lwall
  # Baseline.
  # 

Index: pat/patmake.SH
Prereq: 2.0
*** pat/patmake.SH.old	Fri Aug  5 00:56:33 1988
--- pat/patmake.SH	Fri Aug  5 00:56:34 1988
***************
*** 17,29 ****
  esac
  echo "Extracting patmake (with variable substitutions)"
  cat >patmake <<!GROK!THIS!
! #!/usr/bin/perl
!         eval "exec /usr/bin/perl -S \$0 \$*"
                  if \$running_under_some_shell;
  
! # $Header: patmake.SH,v 2.0 88/06/28 23:19:46 lwall Exp $
  #
  # $Log:	patmake.SH,v $
  # Revision 2.0  88/06/28  23:19:46  lwall
  # Baseline.
  # 
--- 17,32 ----
  esac
  echo "Extracting patmake (with variable substitutions)"
  cat >patmake <<!GROK!THIS!
! #!$perlpath
!         eval "exec $perlpath -S \$0 \$*"
                  if \$running_under_some_shell;
  
! # $Header: patmake.SH,v 2.0.1.1 88/08/05 00:30:00 lwall Exp $
  #
  # $Log:	patmake.SH,v $
+ # Revision 2.0.1.1  88/08/05  00:30:00  lwall
+ # patch1: now depends on perlpath
+ # 
  # Revision 2.0  88/06/28  23:19:46  lwall
  # Baseline.
  # 
***************
*** 50,56 ****
      $last = '';
  }
  
! $mf = `grep '^[a-z]*:' [Mm]akefile* 2>&1`;
  $* = 1;
  $after = '';
  $after .= "\t\tConfigure -d\n" if -f 'Configure';
--- 53,63 ----
      $last = '';
  }
  
! @ARGV = <[Mm]akefile*>;
! $mf = '';
! while (<>) {
!     $mf .= $_ if /^[a-z]+:/;
! }
  $* = 1;
  $after = '';
  $after .= "\t\tConfigure -d\n" if -f 'Configure';
***************
*** 165,171 ****
  $editor = 'vi' unless $editor;
  system $editor, "patch$bnum";
  if (-s "patch$bnum") {
!     `echo "#define PATCHLEVEL $bnum" >../patchlevel.h`;
      open(PL,"patchlevel.h") || die "Can't open patchlevel.h\n";
      while (<PL>) {
  	$bnum = $1 if /^#define\s+PATCHLEVEL\s+(\d+)/;
--- 172,179 ----
  $editor = 'vi' unless $editor;
  system $editor, "patch$bnum";
  if (-s "patch$bnum") {
!     chdir '..';
!     `echo "#define PATCHLEVEL $bnum" >patchlevel.h`;
      open(PL,"patchlevel.h") || die "Can't open patchlevel.h\n";
      while (<PL>) {
  	$bnum = $1 if /^#define\s+PATCHLEVEL\s+(\d+)/;

Index: pat/patpost.SH
Prereq: 2.0
*** pat/patpost.SH.old	Fri Aug  5 00:56:38 1988
--- pat/patpost.SH	Fri Aug  5 00:56:39 1988
***************
*** 17,29 ****
  esac
  echo "Extracting patpost (with variable substitutions)"
  cat >patpost <<!GROK!THIS!
! #!/usr/bin/perl
! 	eval "exec /usr/bin/perl -S \$0 \$*"
  		if \$running_under_some_shell;
  
! # $Header: patpost.SH,v 2.0 88/06/28 23:19:50 lwall Exp $
  #
  # $Log:	patpost.SH,v $
  # Revision 2.0  88/06/28  23:19:50  lwall
  # Baseline.
  # 
--- 17,32 ----
  esac
  echo "Extracting patpost (with variable substitutions)"
  cat >patpost <<!GROK!THIS!
! #!$perlpath
! 	eval "exec $perlpath -S \$0 \$*"
  		if \$running_under_some_shell;
  
! # $Header: patpost.SH,v 2.0.1.1 88/08/05 00:30:10 lwall Exp $
  #
  # $Log:	patpost.SH,v $
+ # Revision 2.0.1.1  88/08/05  00:30:10  lwall
+ # patch1: now depends on perlpath
+ # 
  # Revision 2.0  88/06/28  23:19:50  lwall
  # Baseline.
  # 

Index: pat/patsend.SH
Prereq: 2.0
*** pat/patsend.SH.old	Fri Aug  5 00:56:42 1988
--- pat/patsend.SH	Fri Aug  5 00:56:43 1988
***************
*** 17,29 ****
  esac
  echo "Extracting patsend (with variable substitutions)"
  cat >patsend <<!GROK!THIS!
! #!/usr/bin/perl
!         eval "exec /usr/bin/perl -S \$0 \$*"
                  if \$running_under_some_shell;
  
! # $Header: patsend.SH,v 2.0 88/06/28 23:19:54 lwall Exp $
  #
  # $Log:	patsend.SH,v $
  # Revision 2.0  88/06/28  23:19:54  lwall
  # Baseline.
  # 
--- 17,32 ----
  esac
  echo "Extracting patsend (with variable substitutions)"
  cat >patsend <<!GROK!THIS!
! #!$perlpath
!         eval "exec $perlpath -S \$0 \$*"
                  if \$running_under_some_shell;
  
! # $Header: patsend.SH,v 2.0.1.1 88/08/05 00:30:17 lwall Exp $
  #
  # $Log:	patsend.SH,v $
+ # Revision 2.0.1.1  88/08/05  00:30:17  lwall
+ # patch1: now depends on perlpath
+ # 
  # Revision 2.0  88/06/28  23:19:54  lwall
  # Baseline.
  # 
***************
*** 90,107 ****
      $patnum = shift;
      open(XHEAD,">.xhead$$") || die "Can't create temp file.\n";
      print XHEAD
! "Subject: $package $baserev patch #$patnum
  Organization: $orgname
  
  [The latest patch for $package version $baserev is #$maxnum.]
  
  ";
!     open(PATCH,"patch$patnum") || die "Can't open patch$_\n";
      while (<PATCH>) {
          print XHEAD;
      }
      close XHEAD;
!     system "/bin/mail $dest <.xhead$$";
  }
  unlink ".xhead$$";
  
--- 93,111 ----
      $patnum = shift;
      open(XHEAD,">.xhead$$") || die "Can't create temp file.\n";
      print XHEAD
! "To: $dest
! Subject: $package $baserev patch #$patnum
  Organization: $orgname
  
  [The latest patch for $package version $baserev is #$maxnum.]
  
  ";
!     open(PATCH,"patch$patnum") || die "Can't open patch$patnum\n";
      while (<PATCH>) {
          print XHEAD;
      }
      close XHEAD;
!     system "/usr/lib/sendmail -odq -t <.xhead$$";
  }
  unlink ".xhead$$";
  

Index: mcon/U/perlpath.U
*** mcon/U/perlpath.U.old	Fri Aug  5 00:55:39 1988
--- mcon/U/perlpath.U	Fri Aug  5 00:55:40 1988
***************
*** 0 ****
--- 1,58 ----
+ ?RCS:$Header: perlpath.U,v 2.0.1.1 88/08/05 00:50:43 lwall Exp $
+ ?X: The purpose of this unit is to locate perl good enough to construct a #!
+ ?RCS: $Log:	perlpath.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:50:43  lwall
+ ?RCS: patch1: created
+ ?RCS: 
+ ?MAKE:perlpath: test echo n c Myread Oldconfig Loc perl
+ ?MAKE:	-pick add $@ %*
+ ?S:perlpath:
+ ?S:	This variable contains the eventual value of the PERLPATH symbol,
+ ?S:	which contains the absolute location of the perl interpeter.
+ ?S:.
+ ?C:PERLPATH:
+ ?C:	This symbol contains the absolute location of the perl interpeter.
+ ?C:.
+ ?H:?%1:#define PERLPATH "$perlpath"		/**/
+ ?H:?%1:
+ : determine default editor
+ case "$perlpath" in
+ '')
+     if test -f /usr/bin/perl; then
+ 	dflt=/usr/bin/perl
+     else
+ 	case "$_perl" in
+ 	*/*) dflt="$_perl";;
+ 	*) dflt=/usr/bin/perl;;
+ 	esac
+     fi
+     ;;
+ *)  dflt="$perlpath"
+     ;;
+ esac
+ cont=true
+ while $test "$cont" ; do
+     echo " "
+     rp="Where is perl located on your system? [$dflt]"
+     $echo $n "$rp $c"
+     . myread
+     perlpath="$ans"
+     case "$ans" in
+     /*) if test -f $ans; then
+ 	    cont=''
+ 	else
+ 	    dflt=n
+ 	    rp="File $ans doesn't exist.  Use that name anyway? [$dflt]"
+ 	    $echo $n "$rp $c"
+ 	    . myread
+ 	    dflt=''
+ 	    case "$ans" in
+ 	    y*) cont='';;
+ 	    esac
+ 	fi
+ 	;;
+     *) echo "Please use an absolute path name."
+ 	;;
+     esac
+ done
+ 

Index: mcon/U/randbits.U
Prereq: 2.0
*** mcon/U/randbits.U.old	Fri Aug  5 00:55:43 1988
--- mcon/U/randbits.U	Fri Aug  5 00:55:43 1988
***************
*** 1,9 ****
! ?RCS:$Header: randbits.U,v 2.0 88/06/28 23:18:07 lwall Exp $
  ?RCS: $Log:	randbits.U,v $
  ?RCS: Revision 2.0  88/06/28  23:18:07  lwall
  ?RCS: Baseline.
  ?RCS: 
! ?MAKE:randbits: cat rm Myread echo n c
  ?MAKE:	-pick add $@ %*
  ?S:randbits:
  ?S:	This variable contains the eventual value of the RANDBITS symbol,
--- 1,12 ----
! ?RCS:$Header: randbits.U,v 2.0.1.1 88/08/05 00:24:40 lwall Exp $
  ?RCS: $Log:	randbits.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:24:40  lwall
+ ?RCS: patch1: max wasn't initialized
+ ?RCS: 
  ?RCS: Revision 2.0  88/06/28  23:18:07  lwall
  ?RCS: Baseline.
  ?RCS: 
! ?MAKE:randbits: cat rm Myread echo n c cc
  ?MAKE:	-pick add $@ %*
  ?S:randbits:
  ?S:	This variable contains the eventual value of the RANDBITS symbol,
***************
*** 27,33 ****
  {
      register int i;
      register unsigned long tmp;
!     register unsigned long max;
  
      for (i=1000; i; i--) {
  	tmp = (unsigned long)rand();
--- 30,36 ----
  {
      register int i;
      register unsigned long tmp;
!     register unsigned long max = 0L;
  
      for (i=1000; i; i--) {
  	tmp = (unsigned long)rand();
***************
*** 38,44 ****
      printf("%d\n",i);
  }
  EOCP
!     if cc try.c -o try >/dev/null 2>&1 ; then
  	dflt=`try`
      else
  	dflt='?'
--- 41,47 ----
      printf("%d\n",i);
  }
  EOCP
!     if $cc try.c -o try >/dev/null 2>&1 ; then
  	dflt=`try`
      else
  	dflt='?'

Index: mcon/U/sunscanf.U
Prereq: 2.0
*** mcon/U/sunscanf.U.old	Fri Aug  5 00:55:46 1988
--- mcon/U/sunscanf.U	Fri Aug  5 00:55:47 1988
***************
*** 1,9 ****
! ?RCS:$Header: sunscanf.U,v 2.0 88/06/28 23:18:31 lwall Exp $
  ?RCS: $Log:	sunscanf.U,v $
  ?RCS:Revision 2.0  88/06/28  23:18:31  lwall
  ?RCS:Baseline.
  ?RCS:
! ?MAKE:sunscanf: cat rm Myread echo n c
  ?MAKE:	-pick add $@ %*
  ?S:sunscanf:
  ?S:	This variable is set if this system runs with the Sun version
--- 1,12 ----
! ?RCS:$Header: sunscanf.U,v 2.0.1.1 88/08/05 00:25:24 lwall Exp $
  ?RCS: $Log:	sunscanf.U,v $
+ ?RCS:Revision 2.0.1.1  88/08/05  00:25:24  lwall
+ ?RCS:patch1: made depend on cc
+ ?RCS:
  ?RCS:Revision 2.0  88/06/28  23:18:31  lwall
  ?RCS:Baseline.
  ?RCS:
! ?MAKE:sunscanf: cat rm Myread echo n c cc
  ?MAKE:	-pick add $@ %*
  ?S:sunscanf:
  ?S:	This variable is set if this system runs with the Sun version
***************
*** 27,33 ****
          printf("%d\n",value==4.5);
  }
  EOCP
! if cc scanf.c -o scanf >/dev/null 2>&1 ; then
  	$echo " "
  	if $test `scanf` = 0; then
  		$echo "Hmm.. seems your not running the USG flavor.."
--- 30,36 ----
          printf("%d\n",value==4.5);
  }
  EOCP
! if $cc scanf.c -o scanf >/dev/null 2>&1 ; then
  	$echo " "
  	if $test `scanf` = 0; then
  		$echo "Hmm.. seems your not running the USG flavor.."

Index: mcon/U/voidflags.U
Prereq: 2.0
*** mcon/U/voidflags.U.old	Fri Aug  5 00:55:50 1988
--- mcon/U/voidflags.U	Fri Aug  5 00:55:51 1988
***************
*** 1,9 ****
! ?RCS:$Header: voidflags.U,v 2.0 88/06/28 23:18:38 lwall Exp $
  ?RCS: $Log:	voidflags.U,v $
  ?RCS: Revision 2.0  88/06/28  23:18:38  lwall
  ?RCS: Baseline.
  ?RCS: 
! ?MAKE:voidflags defvoidused: echo n c cat rm contains
  ?MAKE:	-pick add $@ %*
  ?S:voidflags:
  ?S:	This variable contains the eventual value of the VOIDFLAGS symbol,
--- 1,12 ----
! ?RCS:$Header: voidflags.U,v 2.0.1.1 88/08/05 00:26:03 lwall Exp $
  ?RCS: $Log:	voidflags.U,v $
+ ?RCS: Revision 2.0.1.1  88/08/05  00:26:03  lwall
+ ?RCS: patch1: fixed a few bugs
+ ?RCS: 
  ?RCS: Revision 2.0  88/06/28  23:18:38  lwall
  ?RCS: Baseline.
  ?RCS: 
! ?MAKE:voidflags defvoidused: echo n c cat rm contains cc
  ?MAKE:	-pick add $@ %*
  ?S:voidflags:
  ?S:	This variable contains the eventual value of the VOIDFLAGS symbol,
***************
*** 22,27 ****
--- 25,31 ----
  ?C:	The package designer should define VOIDUSED to indicate the requirements
  ?C:	of the package.  This can be done either by #defining VOIDUSED before
  ?C:	including config.h, or by defining defvoidused in Myinit.U.  If the
+ ?C:	latter approach is taken, only those flags will be tested.  If the
  ?C:	level of void support necessary is not present, defines void to int.
  ?C:.
  ?H:?%1:#ifndef VOIDUSED
***************
*** 53,66 ****
  #else
  main() {
  #endif
! 	extern void *moo();
! 	void *(*goo)();
  #if TRY & 2
  	void (*foo[10])();
  #endif
  
  #if TRY & 4
! 	if(*goo == moo) {
  		exit(0);
  	}
  #endif
--- 57,70 ----
  #else
  main() {
  #endif
! 	extern void moo();	/* function returning void */
! 	void (*goo)();		/* ptr to func returning void */
  #if TRY & 2
  	void (*foo[10])();
  #endif
  
  #if TRY & 4
! 	if(goo == moo) {
  		exit(0);
  	}
  #endif
***************
*** 67,89 ****
  	exit(0);
  }
  EOCP
!     if cc -S -DTRY=7 try.c >.out 2>&1 ; then
! 	voidflags=7
! 	echo "It appears to support void fully."
  	if $contains warning .out >/dev/null 2>&1; then
  	    echo "However, you might get some warnings that look like this:"
  	    $cat .out
  	fi
      else
! 	echo "Hmm, you compiler has some difficulty with void.  Checking further..."
! 	if cc -S -DTRY=1 try.c >/dev/null 2>&1 ; then
  	    echo "It supports 1..."
! 	    if cc -S -DTRY=3 try.c >/dev/null 2>&1 ; then
  		voidflags=3
  		echo "And it supports 2 but not 4."
  	    else
  		echo "It doesn't support 2..."
! 		if cc -S -DTRY=3 try.c >/dev/null 2>&1 ; then
  		    voidflags=5
  		    echo "But it supports 4."
  		else
--- 71,93 ----
  	exit(0);
  }
  EOCP
!     if $cc -S -DTRY=$defvoidused try.c >.out 2>&1 ; then
! 	voidflags=$defvoidused
! 	echo "It appears to support void."
  	if $contains warning .out >/dev/null 2>&1; then
  	    echo "However, you might get some warnings that look like this:"
  	    $cat .out
  	fi
      else
! 	echo "Hmm, your compiler has some difficulty with void.  Checking further..."
! 	if $cc -S -DTRY=1 try.c >/dev/null 2>&1 ; then
  	    echo "It supports 1..."
! 	    if $cc -S -DTRY=3 try.c >/dev/null 2>&1 ; then
  		voidflags=3
  		echo "And it supports 2 but not 4."
  	    else
  		echo "It doesn't support 2..."
! 		if $cc -S -DTRY=5 try.c >/dev/null 2>&1 ; then
  		    voidflags=5
  		    echo "But it supports 4."
  		else

