Subject:  v16i037:  Larry Wall's Configure generator, etc., Part04/07
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: lwall@jpl-devvax.jpl.nasa.gov (Larry Wall)
Posting-number: Volume 16, Issue 37
Archive-name: dist2/part04

#! /bin/sh

# Make a new directory for the dist sources, cd to it, and run kits 1
# thru 7 through sh.  When all 7 kits have been run, read README.

echo "This is dist 2.0 kit 4 (of 7).  If kit 4 is complete, the line"
echo '"'"End of kit 4 (of 7)"'" will echo at the end.'
echo ""
export PATH || (echo "You didn't use sh, you clunch." ; kill $$)
mkdir kit mcon mcon/U pat 2>/dev/null
echo Extracting mcon/U/d_news.U
sed >mcon/U/d_news.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_news.U,v 2.0 88/06/28 23:15:12 lwall Locked $
X?RCS: 
X?RCS: Revision 1.0  87/05/22  12:30:34  siegel
X?RCS: This unit looks to see what window system you are using
X?RCS: Initial revision
X?RCS: 
X?MAKE:d_news d_news0 d_newshome d_textcan: contains echo n Myread c
X?MAKE:	-pick add $@ %*
X?INIT:d_newshome="../../NeWS"
X?S:d_news:
X?S:	Set if running NeWS 1.1
X?S:.
X?S:d_news0:
X?S:	Set if running NeWS 1.0
X?S:.
X?S:d_newshome:
X?S:	Path to the top directory of the NeWS structure.
X?S:.
X?S:d_textcan:
X?S:	Path to where the textcan.ps stuff is...
X?S:.
X?C:NEWS1_1:
X?C:	This symbol defined if running NeWS 1.1.
X?C:.
X?C:NEWS1_0:
X?C:	This symbol defined if running NeWS 1.0.
X?C:.
X?C:TEXTCAN:
X?C:	Tells path to where the textcan.ps stuff is...
X?C:.
X?H:?%1:#$d_news            NEWS1_1     /**/
X?H:?%1:#$d_news0        NEWS1_0     /**/
X?H:?%1:#define TEXTCAN	$d_textcan /**/
X?H:?%1:
X: Check to see what version of NeWS is being run?
Xcd ..
Xecho " "
X$echo "Now for the interesting stuff... Lets see what kind of NeWS"
X$echo "they grow round here...."
Xecho " "
X
Xdflt='y'
X
Xans='foobar'
X
Xif $test -d $d_newshome; then
Xd_newshome=`(cd $d_newshome ; /bin/pwd)`
X$echo "Ah...found myself a NeWS in $d_newshome..."
X$echo $n "Is this the NeWS you want your children to grow up with? [$dflt] $c"
Xrp="use $d_newshome? [$dflt] "
X. UU/myread
Xfi
X
Xwhile $test $ans = "n" -o ! -d $d_newshome; do
X    ans='y'
X    $echo $n "Path to NeWS you want [$d_newshome] $c"
X    rp="NeWS to use [$d_newshome] "
X    . UU/myread
X    d_newshome=$ans
X    if $test ! -d $d_newshome; then
X    $echo "No directory with the name of $d_newshome.."
X    fi
X    ans='y'
Xdone
X
Xecho " "
Xif $test ! -d $d_newshome/lib; then
X    $echo "ARG!  No lib directory in $d_newshome!!!"
X    $rm -f kit*isdone
X    $rm -rf UU
X    set -t; $echo " sorry... no NeWS is bad news..."
Xfi
X
Xif $test -r $d_newshome/lib/NeWS/colors.ps ; then
X    $echo 'Ahh... your running NeWS 1.1!  Boy... that makes stuff'
X    $echo 'easy....'
X    echo " "
X    d_news="$define" 
X    d_news0="$undef"
X    if $test -r $d_newshome/lib/NeWS/textcan.ps; then
X	d_textcan=$d_newshome/lib/NeWS
X	$echo "The textcan.ps stuff seems to be in :"
X	$echo $n "   "
X	$echo $d_textcan
X    else
X	d_textcan=$d_newshome/clientsrc/client/nterm
X	if $test ! -r $d_textcan/textcan.ps; then
X    	    d_news="$undef"
X    	    d_news0="$define"
X	    $echo 'Hmm... must have been fooled... gotta be NeWS 1.1 beta!'
X	else
X	    $echo "The textcan.ps stuff seems to be in :"
X	    $echo $n "   "
X	    $echo $d_textcan
X	fi
X    fi
Xelse
X    $echo 'snif... snif... I smell the dilapidated smell of NeWS 1.0..'
X    $echo 'Some things will not work under NeWS 1.0...'
X    echo " "
X    d_news="$undef"
X    d_news0="$define"
Xfi
Xcd UU
X
!STUFFY!FUNK!
echo Extracting pat/mailagent
sed >pat/mailagent <<'!STUFFY!FUNK!' -e 's/X//'
X#!/usr/bin/perl
X
X# You'll need to set up a .forward file that feeds your mail to this script.
X# Mine looks like this:
X#   "| /a/lwall/bin/mailagent /a/lwall lwall Larry >>/usr/spool/mail/lwall 2>&1"
X# Actually, this doesn't work real good, since I don't lock the mail file.
X# Someday I'll fix this.  For now, put something like
X#   lwall, "| /a/lwall/bin/mailagent /a/lwall lwall Larry >>/a/lwall/.bak 2>&1"
X
X($HOME, $USER, $NAME) = @ARGV;
X
X$ENV{'PATH'}="$1:/bin:/usr/bin:/usr/ucb";
X$ENV{'IFS'} = '' if $ENV{'IFS'};
X
X$hostname = `hostname`;
X
Xexec '/bin/cat' unless $NAME;
Xexec '/bin/cat' unless chdir $HOME;
Xexec '/bin/cat' unless $hostname =~ /vax/;
X
X$HOME=`pwd`;
Xchop($HOME);
X$ENV{'HOME'} = $HOME;
X$ENV{'USER'} = $USER;
X$ENV{'NAME'} = $NAME;
X
Xumask(022);
X
Xif (open(commands,".commands")) {
X    while (<commands>) {
X	chop;
X	$command{$_} = 1;
X    }
X    close(commands);
X}
X
X$dest = $USER;
X$cmd = "set -x\n";
Xline: while (<stdin>) {
X    $all .= $_;
X    s/^From ([^ 	]*).*$/$1/ && ($dest = $1);
X    /@RR/ && ($ack = 1);
X    if (1 .. /^$/) {
X	if (/^Apparently-To:.*admin/) { $admin = 1; }
X	if (/^To:.*admin/) { $admin = 1; }
X	if (/^Cc:.*admin/) { $admin = 1; }
X    }
X    if (/^Subject:[ \t]*(.*)/) { $subj = $1; }
X    if (/^Title:[ \t]*(.*)/) { $subj = $1; }
X    if (/^Subject:[ 	]*[Cc]ommand[ 	]*$/ .. 99) {
X	s/^	@SH/@SH/;
X	if (/^@SH/) {
X	    s/\\!/!/g;
X	    if (/[=$^&*([{}`\\|;>?]/) {
X		s/^@SH/bad cmd:/;
X		$bad .= $_;
X		next line;
X	    }
X	    s/ PATH/ $dest/;
X	    s/SH mailpath/SH mailpatch/;
X	    s/@SH[ 	]*//;
X	    if (/^([^ \t]+)[ \t]/) {
X		$first = $1;
X	    }
X	    else {
X		$first = $_;
X		chop($first);
X	    }
X	    if (!$command{$first}) {
X		s/^/unk cmd: /;
X		$bad .= $_;
X		next line;
X	    }
X	    $cmd .= $_;
X	}
X    }
X}
X
Xif ($dest ne $USER) {
X
X    if ($cmd ne "set -x\n") {
X	open(cmd,">/tmp/mess.cmd$$");
X	print cmd $cmd;
X	close cmd;
X	$tmp = `sh -x /tmp/mess.cmd$$ 2>&1`;
X	if ($?) {
X	    open(mailer,"|/bin/mail $dest $USER");
X	    print mailer
X"Subject: the following returned a non-zero status
XTo: $dest
X
X$tmp
X
Xmailagent speaking for $USER
X";
X	    close mailer;
X	}
X	unlink "/tmp/mess.cmd$$";
X    }
X
X    if ($ack) {
X	open(mailer,"|/bin/mail $dest $USER");
X	print mailer
X"Subject: $subj
XTo: $dest
X
XHere is the receipt you requested.
X
Xmailagent speaking for $USER
X";
X	close mailer;
X    }
X
X    if ($bad) {
X	open(mailer,"|/bin/mail $dest $USER");
X	print mailer
X"Subject: the following commands were not executed
XTo: $dest
X
X$bad
X
XIf $NAME can figure out what you wanted he may do it anyway.
X
Xmailagent speaking for $USER
X";
X	close mailer;
X    }
X}
X
Xif ($admin) {
X    open(out,">>.junk");
X    select(out);
X}
X
Xprint $all,"\n\n";
X
!STUFFY!FUNK!
echo Extracting mcon/U/registers.U
sed >mcon/U/registers.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: registers.U,v 2.0 88/06/28 23:18:11 lwall Locked $
X?RCS: $Log:	registers.U,v $
X?RCS: Revision 2.0  88/06/28  23:18:11  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:registers reg1 reg2 reg3 reg4 reg5 reg6 reg7 reg8 reg9 reg10 reg11 reg12 reg13 reg14 reg15 reg16: Cppsym echo n c Myread Oldconfig
X?MAKE:	-pick add $@ %*
X?S:registers:
X?S:	This variable contains the number of register declarations paid
X?S:	attention to by the C compiler.
X?S:.
X?S:reg1:
X?S:	This variable, along with reg2, reg3, etc. contains the eventual
X?S:	value for the symbols Reg1, Reg2, Reg3, etc.  It has either the
X?S:	value "register" or is null.
X?S:.
X?C:Reg1:
X?C:	This symbol, along with Reg2, Reg3, etc. is either the word "register"
X?C:	or null, depending on whether the C compiler pays attention to this
X?C:	many register declarations.  The intent is that you don't have to
X?C:	order your register declarations in the order of importance, so you
X?C:	can freely declare register variables in sub-blocks of code and as
X?C:	function parameters.  Do not use Reg<n> more than once per routine.
X?C:.
X?H:?%1:
X?H:?%1:#define Reg1 $reg1		/**/
X?H:?%1:#define Reg2 $reg2		/**/
X?H:?%1:#define Reg3 $reg3		/**/
X?H:?%1:#define Reg4 $reg4		/**/
X?H:?%1:#define Reg5 $reg5		/**/
X?H:?%1:#define Reg6 $reg6		/**/
X?H:?%1:#define Reg7 $reg7		/**/
X?H:?%1:#define Reg8 $reg8		/**/
X?H:?%1:#define Reg9 $reg9		/**/
X?H:?%1:#define Reg10 $reg10		/**/
X?H:?%1:#define Reg11 $reg11		/**/
X?H:?%1:#define Reg12 $reg12		/**/
X?H:?%1:#define Reg13 $reg13		/**/
X?H:?%1:#define Reg14 $reg14		/**/
X?H:?%1:#define Reg15 $reg15		/**/
X?H:?%1:#define Reg16 $reg16		/**/
X?H:?%1:
X: see how many register declarations we want to use
Xcase "$registers" in
X'')
X    if Cppsym vax; then
X	dflt=6
X    elif Cppsym sun mc68000; then
X	dflt=10
X    elif Cppsym pyr; then
X	dflt=14
X    elif Cppsym ns32000 ns16000; then
X	dflt=5
X    elif Cppsym $smallmach; then
X	dflt=3
X    else
X	: if you have any other numbers for me, send them in
X	dflt=6
X    fi
X    ;;
X*)  dflt=$registers ;;
Xesac
Xcat <<EOM
X 
XDifferent C compilers on different machines pay attention to different
Xnumbers of register declarations.  About how many register declarations in
XEOM
X$echo $n "each routine does your C compiler pay attention to? (OK to guess) [$dflt] $c"
Xrp="# register declarations used? [$dflt]"
X. myread
Xregisters=$ans
Xreg1=''
Xawk "BEGIN { for (i=1; i<=16; i++) printf \"reg%d=''\n\", i}" </dev/null >.foo
X. .foo
Xawk "BEGIN { for (i=1; i<=$registers; i++) printf \"reg%d=register\n\", i}" \
X	</dev/null >.foo
X. .foo
Xrm -f .foo
X
!STUFFY!FUNK!
echo Extracting pat/pat.SH
sed >pat/pat.SH <<'!STUFFY!FUNK!' -e 's/X//'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X	echo "Using config.sh from above..."
X    fi
X    . ./config.sh
X    ;;
Xesac
X: This forces SH files to create target in same directory as SH file.
X: This is so that make depend always knows where to find SH derivatives.
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting pat (with variable substitutions)"
Xcat >pat <<!GROK!THIS!
X#!/usr/bin/perl
X	eval "exec /usr/bin/perl -S \$0 \$*"
X		if \$running_under_some_shell;
X
X# $Header: pat.SH,v 2.0 88/06/28 23:19:17 lwall Locked $
X#
X# $Log:	pat.SH,v $
X# Revision 2.0  88/06/28  23:19:17  lwall
X# Baseline.
X# 
X# 
X
X!GROK!THIS!
X
X: In the following dollars and backticks do not need the extra backslash.
Xcat >>pat <<'!NO!SUBS!'
X
Xdie "pat [files]\n" unless $#ARGV >= 0;
X
Xdo readpackage();
X
Xif ($ARGV[0] eq '-n') {
X    open(FIND, "find . -type f -newer patchlevel.h -print | sort |") ||
X	die "Can't run find.\n";
X    open(NEWER,">.newer") || die "Can't create .newer.\n";
X    open(MANI,"MANIFEST.new");
X    while (<MANI>) {
X	    ($name,$foo) = split;
X	    $mani{$name} = 1;
X    }
X    close MANI;
X    while (<FIND>) {
X	s|^\./||;
X	chop;
X	if (!$mani{$_}) {
X		next if m|^MANIFEST.new$|;
X		next if m|^Wanted$|;
X		next if m|^bugs|;
X		next if m|^UU/|;
X		next if m|^RCS/|;
X		next if m|/RCS/|;
X		next if m|^config.sh$|;
X		next if m|/config.sh$|;
X		next if m|^make.out$|;
X		next if m|/make.out$|;
X		next if m|^all$|;
X		next if m|/all$|;
X		next if m|^core$|;
X		next if m|/core$|;
X		next if m|^foo|;
X		next if m|/foo|;
X		next if m|^blurfl|;
X		next if m|/blurfl|;
X		next if m|^\.|;
X		next if m|/\.|;
X		next if m|\.o$|;
X		next if m|\.old$|;
X		next if m|\.orig$|;
X		next if $mani{$_ . ".SH"};
X		next if m|(.*)\.c$| && $mani{$1 . ".y"};
X		next if -x $_;
X	}
X	print NEWER $_,"\n";
X    }
X    close FIND;
X    close NEWER;
X    print "Please remove unwanted files...\n";
X    sleep(2);
X    system '${EDITOR-vi} .newer';
X    @ARGV = split(' ',`cat .newer`);
X}
Xelsif ($ARGV[0] eq '-a') {
X    open(MANI,"MANIFEST.new") || die "No MANIFEST.new found.\n";
X    @ARGV = ();
X    while (<MANI>) {
X	chop;
X	($_) = split(' ');
X	push(@ARGV,$_);
X    }
X    close MANI;
X}
X
Xunlink <bugs/*.[1-9] bugs/*.[1-9][0-9]>;
X
Xsystem 'perl', '-S', 'patcil', '-p', @ARGV;
Xsystem 'perl', '-S', 'patdiff', @ARGV;
Xsystem 'perl', '-S', 'patmake';
X
X!NO!SUBS!
Xcat ../pl/package.pl >>pat
Xchmod +x pat
X$eunicefix pat
!STUFFY!FUNK!
echo Extracting pat/patsend.SH
sed >pat/patsend.SH <<'!STUFFY!FUNK!' -e 's/X//'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X	echo "Using config.sh from above..."
X    fi
X    . ./config.sh
X    ;;
Xesac
X: This forces SH files to create target in same directory as SH file.
X: This is so that make depend always knows where to find SH derivatives.
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting patsend (with variable substitutions)"
Xcat >patsend <<!GROK!THIS!
X#!/usr/bin/perl
X        eval "exec /usr/bin/perl -S \$0 \$*"
X                if \$running_under_some_shell;
X
X# $Header: patsend.SH,v 2.0 88/06/28 23:19:54 lwall Locked $
X#
X# $Log:	patsend.SH,v $
X# Revision 2.0  88/06/28  23:19:54  lwall
X# Baseline.
X# 
X
X\$orgname='$orgname';
X!GROK!THIS!
X
X: In the following dollars and backticks do not need the extra backslash.
Xcat >>patsend <<'!NO!SUBS!'
X
Xchop($orgname = `cat $orgname`) if $orgname =~ m|^/|;
X
Xchdir '..' if -f '../.package';
X
Xdo readpackage();
X
Xwhile ($_ = shift) {
X    if (/^(patch)?[1-9][\d,-]*$/) {
X	s/^patch//;
X	push(@argv,$_);
X    }
X    else {
X	push(@dest,$_);
X    }
X}
X$dest = join(' ',@dest);
Xdie "patsend dest [patches]\n" unless $dest;
X
X@ARGV = @argv;
X
Xopen(PL,"patchlevel.h") || die "Can't open patchlevel.h\n";
Xwhile (<PL>) {
X    $maxnum = $1 if /^#define\s+PATCHLEVEL\s+(\d+)/;
X}
Xclose PL;
Xdie "Malformed patchlevel.h file.\n" if $maxnum eq '';
X
Xif ($#ARGV < 0) {
X    $argv = $maxnum;
X    @ARGV = $argv;
X}
Xelse {
X    $argv = do rangeargs(@ARGV);
X    @ARGV = split(' ',$argv);
X}
X
X$argv =~ s/ $//;
X
Xif ($#ARGV < 0) {
X    die "No patches specified.\n";
X}
Xelsif ($#ARGV) {
X    print "Sending $package $baserev patches $argv to $dest...\n";
X}
Xelse {
X    print "Sending $package $baserev patch $argv to $dest...\n";
X}
X
Xchdir 'bugs' || die "Can't cd to bugs\n";
X
Xfork && exit;
X
Xuntil ($#ARGV < 0) {
X    $patnum = shift;
X    open(XHEAD,">.xhead$$") || die "Can't create temp file.\n";
X    print XHEAD
X"Subject: $package $baserev patch #$patnum
XOrganization: $orgname
X
X[The latest patch for $package version $baserev is #$maxnum.]
X
X";
X    open(PATCH,"patch$patnum") || die "Can't open patch$_\n";
X    while (<PATCH>) {
X        print XHEAD;
X    }
X    close XHEAD;
X    system "/bin/mail $dest <.xhead$$";
X}
Xunlink ".xhead$$";
X
X!NO!SUBS!
Xcat ../pl/package.pl >>patsend
Xcat ../pl/rangeargs.pl >>patsend
Xchmod +x patsend
X$eunicefix patsend
!STUFFY!FUNK!
echo Extracting mcon/U/d_havetlib.U
sed >mcon/U/d_havetlib.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_havetlib.U,v 2.0 88/06/28 23:14:50 lwall Locked $
X?RCS: $Log:	d_havetlib.U,v $
X?RCS: Revision 2.0  88/06/28  23:14:50  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_havetlib termlib: echo contains n c Myread Loc Filexp Oldconfig
X?MAKE:	-pick add $@ %*
X?S:d_havetlib:
X?S:	This variable conditionally defines the HAVETERMLIB symbol, which
X?S:	indicates to the C program that termlib-style routines are available.
X?S:.
X?S:termlib:
X?S:	This variable contains the argument to pass to the loader to get
X?S:	termlib-style routines.  It is up to the Makefile.SH to make sure
X?S:	the value gets to the right command.  Note that on many systems the
X?S:	termlib routines are emulated by the curses or terminfo library.
X?S:.
X?C:HAVETERMLIB:
X?C:	This symbol, when defined, indicates that termlib-style routines
X?C:	are available.  There is nothing to include.
X?C:.
X?H:?%1:#$d_havetlib	HAVETERMLIB	/**/
X?H:?%1:
X: where do we get termlib routines from
Xecho " "
Xans=`loc libcurses.a x $libpth`
Xcase "$ans" in
X/*)
X    ar t $ans >grimble
X    if $contains tputs.o grimble >/dev/null 2>&1; then
X	termlib='-lcurses'
X	d_havetlib="$define"
X	echo "Terminfo library found."
X    else
X	ans=x
X    fi
X    rm -f grimble
X    ;;
Xesac
Xcase "$ans" in
Xx)
X    ans=`loc libtermlib.a x $libpth`
X    case "$ans" in
X    /usr/lib*|/lib*)
X	termlib='-ltermlib'
X	d_havetlib="$define"
X	echo "Termlib library found."
X	;;
X    /*)
X	termlib="$ans"
X	d_havetlib="$define"
X	echo "Termlib library found."
X	;;
X    *)
X	ans=`loc libtermcap.a x $libpth`
X	case "$ans" in
X	/usr/lib*|/lib*)
X	    termlib='-ltermcap'
X	    d_havetlib="$define"
X	    echo "Termcap library found."
X	    ;;
X	/*)
X	    termlib="$ans"
X	    d_havetlib="$define"
X	    echo "Termcap library found."
X	    ;;
X	*)
X	    case "$termlib" in
X	    '')
X		dflt=y
X		rp="Your system appears to NOT have termlib-style routines.  Is this true? [$dflt]"
X		$echo $n "$rp $c"
X		. myread
X		case "$ans" in
X		    n*|f*) d_havetlib="$define"
X			  echo "Then where are the termlib-style routines kept (specify either -llibname"
X			  $echo $n " or full pathname (~name ok))? $c"
X			  rp='Specify termlib:'
X			  . myread
X			  termlib=`filexp $ans`
X			  ;;
X		    *)    d_havetlib="$undef"
X			  termlib=''
X			  echo "You will have to play around with term.c then."
X			  ;;
X		esac
X		echo " "
X		;;
X	    *)  echo "You said termlib was $termlib before."
X		;;
X	    esac
X	    ;;
X	esac
X	;;
X    esac
X    ;;
Xesac
X
!STUFFY!FUNK!
echo Extracting mcon/U/Instruct.U
sed >mcon/U/Instruct.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: Instruct.U,v 2.0 88/06/28 23:13:21 lwall Locked $
X?X: 
X?X: This unit spew out the directions that we want everyone to read.  I try to
X?X: keep the first "pagefull" much less than a page since they don't know it
X?X: isn't going to go shooting off the top of the screen, and we don't want
X?X: to panic them yet.
X?X: 
X?RCS: $Log:	Instruct.U,v $
X?RCS: Revision 2.0  88/06/28  23:13:21  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:Instruct: package n c Myread
X?MAKE:	-pick add $@ %*
X: general instructions
Xcat <<EOH
X 
XThis installation shell script will examine your system and ask you questions
Xto determine how the $package package should be installed.  If you get stuck
Xon a question, you may use a ! shell escape to start a subshell or execute
Xa command.  Many of the questions will have default answers in square
Xbrackets--typing carriage return will give you the default.
X
XOn some of the questions which ask for file or directory names you are
Xallowed to use the ~name construct to specify the login directory belonging
Xto "name", even if you don't have a shell which knows about that.  Questions
Xwhere this is allowed will be marked "(~name ok)".
X
XEOH
Xrp="[Type carriage return to continue]"
X?X: echo not set yet so use builtin, not $echo
Xecho $n "$rp $c"
X. myread
Xcat <<EOH
X
XMuch effort has been expended to ensure that this shell script will run
Xon any Unix system.  If despite that it blows up on you, your best bet is
Xto edit Configure and run it again. Also, let me (lwall@jpl-devvax.jpl.nasa.gov)
Xknow how I blew it.  If you can't run Configure for some reason, you'll have
Xto generate a config.sh file by hand.
X
XThis installation script affects things in two ways: 1) it may do direct
Xvariable substitutions on some of the files included in this kit, and
X2) it builds a config.h file for inclusion in C programs.  You may edit
Xany of these files as the need arises after running this script.
X
XIf you make a mistake on a question, there is no easy way to back up to it
Xcurrently.  The easiest thing to do is to edit config.sh and rerun all the
XSH files.  Configure will offer to let you do this before it runs the SH files.
X
XEOH
Xrp="[Type carriage return to continue]"
Xecho $n "$rp $c"
X. myread
X
!STUFFY!FUNK!
echo Extracting pat/mailpatch
sed >pat/mailpatch <<'!STUFFY!FUNK!' -e 's/X//'
X#!/bin/sh
X
X# You'll have to customize this to know about your own packages.  Also, copy
X# rangeargs to your private bin directory, or change invocations below.
X
Xcmd=`date`"  $@ "
Xcd $HOME
X
Xdest=$1
Xshift
Xsystem=$1
Xshift
Xversion=$1
Xshift
Xcase "$system" in
Xdist)
X    cd /u/sfoc/lwall/src/dist/bugs
X    maxnum=`/bin/sed -n -e 's/^[^0-9]*\([1-9][0-9]*\).*$/\1/p' ../patchlevel.h`
X    curversion='1.0'
X    ;;
Xperl)
X    cd /usr/local/src/perl/bugs
X    maxnum=`/bin/sed -n -e 's/^[^0-9]*\([1-9][0-9]*\).*$/\1/p' ../patchlevel.h`
X    curversion='2.0'
X    ;;
Xrn)
X    cd /u/sfoc/lwall/src/rn/bugs
X    maxnum=`/bin/sed -n -e 's/^[^0-9]*\([1-9][0-9]*\).*$/\1/p' ../patchlevel`
X    curversion='4.3'
X    ;;
Xpatch)
X    cd /u/sfoc/lwall/src/patch/bugs
X    maxnum=`/bin/sed -n -e 's/^[^0-9]*\([1-9][0-9]*\).*$/\1/p' ../patchlevel.h`
X    curversion='2.0'
X    ;;
Xwarp)
X    cd /u/sfoc/lwall/src/warp/bugs
X    maxnum=`/bin/sed -n -e 's/^[^0-9]*\([1-9][0-9]*\).*$/\1/p' ../patchlevel.h`
X    curversion='7.0'
X    ;;
Xcdiff)
X    cd /u/sfoc/lwall/src/cdiff/bugs
X    maxnum=`/bin/sed -n -e 's/^[^0-9]*\([1-9][0-9]*\).*$/\1/p' ../patchlevel.h`
X    curversion='1.1'
X    ;;
X*)
X    /bin/mail $dest $USER <<EOM
XI don't know how to send patches for a program called $system.  Sorry.
X
XIf $NAME can figure out what you meant you'll get the patches anyway.
X
Xmailpatch speaking for $USER
XEOM
X    echo $cmd FAILED >> $HOME/.patchlog
X    exit 1
X    ;;
Xesac
X
Xcase "$version" in
X$curversion) ;;
X*)
X    /bin/mail $dest $USER <<EOM
XI don't know how to send patches for version $version of $system.  Sorry.
X
XIf $NAME can figure out what you meant you'll get the patches anyway.
X
Xmailpatch speaking for $USER
XEOM
X    echo $cmd FAILED >> $HOME/.patchlog
X    exit 1
X    ;;
Xesac
X
Xargs="$*"
X
Xset `$HOME/bin/rangeargs -m "$maxnum" $*`
X
Xcase $# in
X0) set `$HOME/bin/rangeargs -m 100 $args`
X    set $1
X    ;;
Xesac
X
Xfor num do
X    /bin/cat <<EOM >/tmp/mp$$
XSubject: $system version $version patch #$num
X
X[The latest patch for $system version $version is #$maxnum.]
X
Xmailpatch speaking for $USER
X
XEOM
X    if test -f patch$num; then
X	/bin/cat <patch$num >>/tmp/mp$$
X    fi
X    /bin/mail $dest </tmp/mp$$
Xdone
Xrm -f /tmp/mp$$
Xecho $cmd OK >> $HOME/.patchlog
!STUFFY!FUNK!
echo Extracting kit/makedist.man
sed >kit/makedist.man <<'!STUFFY!FUNK!' -e 's/X//'
X.rn '' }`
X''' $Header: makedist.man,v 2.0 88/06/28 23:12:21 lwall Locked $
X''' 
X''' $Log:	makedist.man,v $
X''' Revision 2.0  88/06/28  23:12:21  lwall
X''' Baseline.
X''' 
X''' 
X.de Sh
X.br
X.ne 5
X.PP
X\fB\\$1\fR
X.PP
X..
X.de Sp
X.if t .sp .5v
X.if n .sp
X..
X'''
X'''     Set up \*(-- to give an unbreakable dash;
X'''     string Tr holds user defined translation string.
X'''     Bell System Logo is used as a dummy character.
X'''
X.ie n \{\
X.tr \(*W-\*(Tr
X.ds -- \(*W-
X.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
X.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
X.ds L" ""
X.ds R" ""
X.ds L' '
X.ds R' '
X'br\}
X.el\{\
X.ds -- \(em\|
X.tr \*(Tr
X.ds L" ``
X.ds R" ''
X.ds L' `
X.ds R' '
X'br\}
X.TH MAKEDIST 1 LOCAL
X.SH NAME
Xmakedist - a distribution kit maker
X.SH SYNOPSIS
X.B makedist
X[options] 
X.SH DESCRIPTION
X.I Makedist
Xis a rather simpleminded shar program that knows how to pack files
Xinto multiple kits of approximately 50000 bytes each.
XThe shar scripts produced assume very little about the target machine;
Xthere is correspondingly little error checking done compared to other
Xshar programs.
X.PP
XIn order to run makedist you have to do two things:
X.IP 1) 4
XCreate a .package file in the package's top-level directory by running packinit.
XThis program will ask you about your package and remember what you tell
Xit so that all the dist programs can be smart.
X.IP 2) 4
XCreate a MANIFEST.new file in your top-level directory that lists all the
Xfiles in your package.
XThe filename should be the first field on each line.
XAfter some whitespace you can add a comment which will end up in MANIFEST.
X.PP
XThe only option is a \-v, which turns on verbose mode.
XAfter running makedist, you will have a set of kits in your top-level directory.
XIf your package name is "foo", they will be named foo.kit1, foo.kit2, etc.
X.SH AUTHOR
XLarry Wall <lwall@jpl-devvax.jpl.nasa.gov>
X.SH ENVIRONMENT
XNo environment variables are used by
X.IR makedist .
X.SH FILES
XCreates ./$package.kit*.
X.SH SEE ALSO
Xpat(1)
X.br
Xmetaconfig(1)
X.SH DIAGNOSTICS
X.SH BUGS
XIt ought to know how to split and recombine files longer than 50000 bytes.
X.rn }` ''
!STUFFY!FUNK!
echo Extracting pat/patbase.SH
sed >pat/patbase.SH <<'!STUFFY!FUNK!' -e 's/X//'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X    fi
X    . ./config.sh
X    ;;
Xesac
X: This forces SH files to create target in same directory as SH file.
X: This is so that make depend always knows where to find SH derivatives.
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting patbase (with variable substitutions)"
Xcat >patbase <<!GROK!THIS!
X#!/usr/bin/perl
X        eval "exec /usr/bin/perl -S \$0 \$*"
X                if \$running_under_some_shell;
X
X# $Header: patbase.SH,v 2.0 88/06/28 23:19:25 lwall Locked $
X#
X# $Log:	patbase.SH,v $
X# Revision 2.0  88/06/28  23:19:25  lwall
X# Baseline.
X# 
X# 
X
X!GROK!THIS!
X
X: In the following dollars and backticks do not need the extra backslash.
Xcat >>patbase <<'!NO!SUBS!'
X
Xdie "pat [files]\n" unless $#ARGV >= 0;
X
Xdo readpackage();
X
X$RCSEXT = ',v' unless $RCSEXT;
X
Xif ($ARGV[0] eq '-a') {
X    open(MANI,"MANIFEST.new") || die "No MANIFEST.new found.\n";
X    @ARGV = ();
X    while (<MANI>) {
X        chop;
X	($_) = split(' ');
X        push(@ARGV,$_);
X    }
X    close MANI;
X}
X
Xforeach $file (@ARGV) {
X    $files = do rcsargs($file);
X    @files = split(' ',$files);
X    $revs=0;
X    $rlog = `rlog -r$baserev -r$revbranch $files 2>&1`;
X    ($revs) = ($rlog =~ /selected revisions: (\d+)/);
X    if (!$revs) {
X	print "patbase: $file has never been checked in--checking in...\n";
X	$comment = rcscomment($file);
X	system 'rcs', '-i', "-c$comment", @files if $comment;
X	(system 'ci', "-l$baserev", @files) ||
X	  (system 'rcs', "-Nlastpat:$baserev", @files);
X    }
X    elsif ($revs == 1) {
X	print "Last revision for $file is $baserev.\n";
X	system 'rcs', "-Nlastpat:$baserev", @files;
X    }
X    else {
X	($lastrev) = ($rlog =~ /revision $revbranch\.(\d+)/);
X	print "Last revision for $file is $revbranch.$lastrev.\n";
X	system 'rcs', "-Nlastpat:$revbranch.$lastrev", @files;
X    }
X}
Xunlink ".rlog$$";
X
X!NO!SUBS!
Xcat ../pl/package.pl >>patbase
Xcat ../pl/rcsargs.pl >>patbase
Xcat ../pl/comment.pl >>patbase
Xchmod +x patbase
X$eunicefix patbase
!STUFFY!FUNK!
echo Extracting mcon/U/Finish.U
sed >mcon/U/Finish.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: Finish.U,v 2.0 88/06/28 23:13:02 lwall Locked $
X?X: 
X?X: This unit is the very last one in the Configure script.  It runs all the
X?X: SH files, which among other things produce config.h and (usually) Makefile.
X?X: It offers to do a make depend if the Makefile contains that target.
X?X: 
X?RCS: $Log:	Finish.U,v $
X?RCS: Revision 2.0  88/06/28  23:13:02  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:Finish: grep echo n c rm contains Myread Config_sh Config_h expr
X?MAKE:	-pick add $@ %*
XCONFIG=true
X
Xecho " "
Xdflt=''
Xfastread=''
Xecho "If you didn't make any mistakes, then just type a carriage return here."
Xrp="If you need to edit config.sh, do it as a shell escape here:"
X$echo $n "$rp $c"
X. UU/myread
Xcase "$ans" in
X'') ;;
X*) : in case they cannot read
X    eval $ans;;
Xesac
X. ./config.sh
X
Xecho " "
Xecho "Doing variable substitutions on .SH files..."
Xset x `awk '{print $1}' <MANIFEST | $grep '\.SH'`
Xshift
Xcase $# in
X0) set x *.SH; shift;;
Xesac
Xif test ! -f $1; then
X    shift
Xfi
Xfor file in $*; do
X    case "$file" in
X    */*)
X	dir=`$expr X$file : 'X\(.*\)/'`
X	file=`$expr X$file : 'X.*/\(.*\)'`
X	(cd $dir && . $file)
X	;;
X    *)
X	. $file
X	;;
X    esac
Xdone
Xif test -f config.h.SH; then
X    if test ! -f config.h; then
X	: oops, they left it out of MANIFEST, probably, so do it anyway.
X	. config.h.SH
X    fi
Xfi
X
Xif $contains '^depend:' Makefile >/dev/null 2>&1; then
X    dflt=n
X    $cat <<EOM
X
XNow you need to generate make dependencies by running "make depend".
XYou might prefer to run it in background: "make depend > makedepend.out &"
XIt can take a while, so you might not want to run it right now.
X
XEOM
X    rp="Run make depend now? [$dflt]"
X    $echo $n "$rp $c"
X    . UU/myread
X    case "$ans" in
X    y*) make depend
X	echo "Now you must run a make."
X	;;
X    *)  echo "You must run 'make depend' then 'make'."
X	;;
X    esac
Xelif test -f Makefile; then
X    echo " "
X    echo "Now you must run a make."
Xelse
X    echo "Done."
Xfi
X
X$rm -f kit*isdone
X: the following is currently useless
Xcd UU && $rm -f $rmlist
X: since this removes it all anyway
Xcd .. && $rm -rf UU
X: end of Configure
!STUFFY!FUNK!
echo Extracting mcon/U/libc.U
sed >mcon/U/libc.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: libc.U,v 2.0 88/06/28 23:16:50 lwall Locked $
X?RCS: $Log:	libc.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:50  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:libc: echo n c Myread Oldconfig Loc
X?MAKE:	-pick add $@ %*
X?S:libc:
X?S:	This variable contains the location of the C library.
X?S:.
X: get list of predefined functions in a handy place
Xecho " "
Xif test -f /lib/libc.a; then
X    echo "Your C library is in /lib/libc.a.  You're normal."
X    libc=/lib/libc.a
Xelse
X    ans=`loc libc.a blurfl/dyick $libpth`
X    if test ! -f $ans; then
X	ans=`loc clib blurfl/dyick $libpth`
X    fi
X    if test ! -f $ans; then
X	ans=`loc libc blurfl/dyick $libpth`
X    fi
X    if test -f $ans; then
X	echo "Your C library is in $ans, of all places."
X	libc=$ans
X    else
X	if test -f "$libc"; then
X	    echo "Your C library is in $libc, like you said before."
X	else
X	    cat <<EOM
X 
XI can't seem to find your C library.  I've looked in the following places:
X
X	$libpth
X
XNone of these seems to contain your C library.  What is the full name
XEOM
X	    dflt=None
X	    $echo $n "of your C library? $c"
X	    rp='C library full name?'
X	    . myread
X	    libc="$ans"
X	fi
X    fi
Xfi
Xecho " "
X$echo $n "Extracting names from $libc for later perusal...$c"
Xnm $libc 2>/dev/null | sed -n -e 's/^.* T _//p' -e 's/^.* T //p' > libc.list
Xif $contains '^printf$' libc.list >/dev/null 2>&1; then
X    echo "done"
Xelse
X    nm $libc 2>/dev/null | sed -n -e 's/^.* D _//p' -e 's/^.* D //p' > libc.list
X    if $contains '^printf$' libc.list >/dev/null 2>&1; then
X	echo "done"
X    else
X	echo " "
X	echo "nm didn't seem to work right."
X	echo "Trying ar instead..."
X	rmlist="$rmlist libc.tmp"
X	if ar t $libc > libc.tmp; then
X	    sed -e 's/\.o$//' < libc.tmp > libc.list
X	    echo "Ok."
X	else
X	    echo "ar didn't seem to work right."
X	    echo "Maybe this is a Cray...trying bld instead..."
X	    if bld t $libc | sed -e 's/.*\///' -e 's/\.o:.*$//' > libc.list; then
X		echo "Ok."
X	    else
X	    	echo "That didn't work either.  Giving up."
X	    	exit 1
X	    fi
X	fi
X    fi
Xfi
Xrmlist="$rmlist libc.list"
X
!STUFFY!FUNK!
echo Extracting mcon/U/Cppsym.U
sed >mcon/U/Cppsym.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: Cppsym.U,v 2.0 88/06/28 23:12:50 lwall Locked $
X?X: 
X?X: This unit produces a shell script called Cppsym, which can be used to
X?X: determine whether any in a list of symbols is defined by the C preprocessor.
X?X: It can determine the status of any symbol, though the symbols in attrlist
X?X: are more easily determined.  If you want to add to attrlist you can do
X?X: it in Myinit.U.
X?X: 
X?RCS: $Log:	Cppsym.U,v $
X?RCS: Revision 2.0  88/06/28  23:12:50  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:Cppsym: eunicefix Guess cppstdin cat tr sed rm
X?MAKE:	-pick add $@ %*
X?INIT:attrlist="mc68000 sun gcos unix ibm gimpel interdata tss os mert pyr"
X?INIT:attrlist="$attrlist vax pdp11 i8086 z8000 u3b2 u3b5 u3b20 u3b200"
X?INIT:attrlist="$attrlist ns32000 ns16000 iAPX286 mc300 mc500 mc700 sparc"
X?INIT:attrlist="$attrlist nsc32000 sinix xenix venix posix ansi M_XENIX"
X?INIT:attrlist="$attrlist $mc68k __STDC__"
X: get C preprocessor symbols handy
Xecho " "
Xecho $attrlist | $tr '[ - ]' '[\012-\012]' >Cppsym.know
X$cat <<EOSS >Cppsym
X$startsh
Xcase "\$1" in
X-l) list=true
X    shift
X    ;;
Xesac
Xunknown=''
Xcase "\$list\$#" in
X1|2)
X    for sym do
X	if $contains "^\$1$" Cppsym.true >/dev/null 2>&1; then
X	    exit 0
X	elif $contains "^\$1$" Cppsym.know >/dev/null 2>&1; then
X		:
X	else
X	    unknown="\$unknown \$sym"
X	fi
X    done
X    set X \$unknown
X    shift
X    ;;
Xesac
Xcase \$# in
X0) exit 1;;
Xesac
Xecho \$* | $tr '[ - ]' '[\012-\012]' | $sed -e 's/\(.*\)/\\
X#ifdef \1\\
Xexit 0; _ _ _ _\1\\	 \1\\
X#endif\\
X/' >/tmp/Cppsym\$\$
Xecho exit 1 >>/tmp/Cppsym\$\$
X$cppstdin $cppminus </tmp/Cppsym\$\$ >/tmp/Cppsym2\$\$
Xcase "\$list" in
Xtrue) awk 'NF > 5 {print substr(\$6,2,100)}' </tmp/Cppsym2\$\$ ;;
X*)
X    sh /tmp/Cppsym2\$\$
X    status=\$?
X    ;;
Xesac
X$rm -f /tmp/Cppsym\$\$ /tmp/Cppsym2\$\$
Xexit \$status
XEOSS
Xchmod +x Cppsym
X$eunicefix Cppsym
Xecho "Your C preprocessor defines the following symbols:"
XCppsym -l $attrlist >Cppsym.true
Xcat Cppsym.true
Xrmlist="$rmlist Cppsym Cppsym.know Cppsym.true"
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_nolnbuf.U
sed >mcon/U/d_nolnbuf.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_nolnbuf.U,v 2.0 88/06/28 23:15:22 lwall Locked $
X?RCS: $Log:	d_nolnbuf.U,v $
X?RCS: Revision 2.0  88/06/28  23:15:22  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_nolnbuf: Guess n c echo test Myread
X?MAKE:	-pick add $@ %*
X?S:d_nolnbuf:
X?S:	This variable conditionally defines the NOLINEBUF symbol, which
X?S:	indicates to the C program that stdout is not buffered, so that
X?S:	the program can call setbuf() or setlinebuf() for efficiency.
X?S:.
X?C:NOLINEBUF:
X?C:	This symbol, if defined, indicates that stdout is not buffered, so that
X?C:	the program can call setbuf() or setlinebuf() for efficiency.
X?C:.
X?H:?%1:#$d_nolnbuf	NOLINEBUF	/**/
X?H:?%1:
X: check for buffering of stdout
Xecho " "
Xcase "$d_nolnbuf" in
X'')
X    cat <<'EOT' >blurfl.c
X#include <stdio.h>
Xmain()
X{
X    int i;
X
X    for (i=0; i<5; i++) {
X	putchar(i+'a');
X	sleep(1);
X    }
X    putchar('\n');
X}
XEOT
X    cc blurfl.c -o blurfl
X    rm -f blurfl.c
X    cat <<'EOM'
XChecking for buffering of stdout to terminal.
X
XObserve the following characters as they are printed out, to see whether they
Xprint out all at once, or with a 1 second pause between each of them.  If they
Xprint out one by one, you don't have buffering.  If they print together (after
Xabout a 5 second pause), you do have buffering.
X
XEOM
X    rp="Type return to start printing the test characters:"
X    $echo $n "$rp $c"
X    . myread
X    ans=y
X    while $test "$ans" = 'y'; do
X	blurfl
X	dflt=n
X	rp='Would you like to see that again? [n]'
X	$echo $n "$rp $c"
X	. myread
X    done
X    dflt=y
X    rp="Do you have buffering (printed all at once)? [$dflt]"
X    $echo $n "$rp $c"
X    . myread
X    case "$ans" in
X    n*) d_nolnbuf="$define";;
X    *)  d_nolnbuf="$undef";;
X    esac
X    ;;
X*)
X    case "$d_nolnbuf" in
X    "$define") dflt=n;;
X    *)	    dflt=y;;
X    esac
X    rp="Do you have buffering on stdout to terminals? [$dflt]"
X    $echo $n "$rp $c"
X    . myread
X    case "$ans" in
X    n*) d_nolnbuf="$define";;
X    *)  d_nolnbuf="$undef";;
X    esac
X    ;;
Xesac
X
!STUFFY!FUNK!
echo Extracting pat/Makefile.SH
sed >pat/Makefile.SH <<'!STUFFY!FUNK!' -e 's/X//'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X	echo "Using config.sh from above..."
X    fi
X    . ./config.sh
X    ;;
Xesac
X: This forces SH files to create target in same directory as SH file.
X: This is so that make depend always knows where to find SH derivatives.
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting Makefile (with variable substitutions)"
Xcat >Makefile <<!GROK!THIS!
X# $Header: Makefile.SH,v 2.0 88/06/28 23:19:00 lwall Locked $
X#
X# $Log:	Makefile.SH,v $
X# Revision 2.0  88/06/28  23:19:00  lwall
X# Baseline.
X# 
X
Xbin = $bin
Xmansrc = $mansrc
Xmanext = $manext
X
X!GROK!THIS!
Xcat >>Makefile <<'!NO!SUBS!'
X
Xpublic = pat patcil patbase patdiff patmake patpost patsend patftp \
X	patindex
Xprivate = 
Xmanpages = pat.man
Xutil = Makefile
X
Xc = 
X
Xobj = 
X
Xaddedbyconf = pat patmake patpost patsend
X
X# grrr
XSHELL = /bin/sh
X
Xall: $(public) $(private) $(util)
X	touch all
Xpat: pat.SH ../pl/package.pl
X	sh pat.SH
X
Xpatbase: patbase.SH ../pl/package.pl ../pl/rcsargs.pl ../pl/comment.pl
X	sh patbase.SH
X
Xpatcil: patcil.SH ../pl/package.pl ../pl/rcsargs.pl ../pl/comment.pl
X	sh patcil.SH
X
Xpatdiff: patdiff.SH ../pl/package.pl ../pl/rcsargs.pl
X	sh patdiff.SH
X
Xpatmake: patmake.SH ../pl/package.pl
X	sh patmake.SH
X
Xpatpost: patpost.SH ../pl/package.pl ../pl/rangeargs.pl
X	sh patpost.SH
X
Xpatsend: patsend.SH ../pl/package.pl ../pl/rangeargs.pl
X	sh patsend.SH
X
Xpatftp: patftp.SH ../pl/package.pl ../pl/rangeargs.pl
X	sh patftp.SH
X
XMakefile: Makefile.SH
X	sh Makefile.SH
X
X# won't work with csh
Xinstall: $(public)
X	export PATH || exit 1
X	- if test `pwd` != $(bin); then cp $(public) $(bin); fi
X	cd $(bin); chmod +x $(public)
X	- if test `pwd` != $(mansrc); then \
Xfor page in $(manpages); do \
Xcp $$page $(mansrc)/`basename $$page .man`.$(manext); \
Xdone; \
Xfi
X
Xclean:
X
Xrealclean:
X	rm -f core $(addedbyconf)
X
X!NO!SUBS!
X$eunicefix Makefile
!STUFFY!FUNK!
echo Extracting mcon/U/d_dosuid.U
sed >mcon/U/d_dosuid.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_dosuid.U,v 2.0 88/06/29 00:18:20 lwall Locked $
X?RCS: $Log:	d_dosuid.U,v $
X?RCS: Revision 2.0  88/06/29  00:18:20  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_dosuid: echo contains sed test n c Myread Oldconfig Guess
X?MAKE:	-pick add $@ %*
X?S:d_dosuid:
X?S:	This variable conditionally defines the symbol DOSUID, which
X?S:	tells the C program that it should insert setuid emulation code
X?S:	on hosts which have setuid #! scripts disabled.
X?S:.
X?C:DOSUID:
X?C:	This symbol, if defined, indicates that the C program should
X?C:	check the script that it is executing for setuid/setgid bits, and
X?C:	attempt to emulate setuid/setgid on systems that have disabled
X?C:	setuid #! scripts because the kernel can't do it securely.
X?C:	It is up to the package designer to make sure that this emulation
X?C:	is done securely.  Among other things, it should do an fstat on
X?C:	the script it just opened to make sure it really is a setuid/setgid
X?C:	script, it should make sure the arguments passed correspond exactly
X?C:	to the argument on the #! line, and it should not trust any
X?C:	subprocesses to which it must pass the filename rather than the
X?C:	file descriptor of the script to be executed.
X?C:.
X?H:?%1:#$d_dosuid DOSUID		/**/
X?H:?%1:
X: now see if they want to do setuid emulation
Xcase "$d_dosuid" in
X'') if bsd; then
X	dflt=y
X    else
X	dflt=n
X    fi
X    ;;
X*undef*) dflt=n;;
X*) dflt=y;;
Xesac
Xcat <<EOM
X 
XSome sites have disabled setuid #! scripts because of a bug in the kernel
Xthat prevents them from being secure.  If you are on such a system, the
Xsetuid/setgid bits on scripts are currently useless.  It is possible for
X$package to detect those bits and emulate setuid/setgid in a secure fashion
Xuntil a better solution is devised for the kernel problem.
X
XEOM
Xrp="Do you want to do setuid/setgid emulation? [$dflt]"
Xecho $n "$rp $c"
X. myread
Xcase "$ans" in
X'') $ans="$dflt";;
Xesac
Xcase "$ans" in
Xy*)  d_dosuid="$define";;
X*) d_dosuid="$undef";;
Xesac
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_hidnet.U
sed >mcon/U/d_hidnet.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_hidnet.U,v 2.0 88/06/28 23:14:54 lwall Locked $
X?RCS: $Log:	d_hidnet.U,v $
X?RCS: Revision 2.0  88/06/28  23:14:54  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_hidnet hiddennet: echo contains sed test n c Myread Oldconfig Guess
X?MAKE:	-pick add $@ %*
X?S:d_hidnet:
X?S:	This variable conditionally defines the symbol HIDDENNET, which
X?S:	tells the C program that it should pretend it is on a different
X?S:	host for purposes of advertising a mailing address.
X?S:.
X?S:hiddennet:
X?S:	This variable contains the value eventually given to the symbol
X?S:	HIDDENNET, if d_hidnet defines it.  If defined, it's the name
X?S:	of the host which serves as the mail server for a network that
X?S:	is invisible to the outside world.
X?S:.
X?C:HIDDENNET:
X?C:	This symbol, if defined, contains the host name that you want to
X?C:	advertise to the outside world.  This name can be different from
X?C:	your actual host name, as long as the machine you specify knows
X?C:	how to forward mail to you.
X?C:.
X?H:?%1:#$d_hidnet HIDDENNET "$hiddennet"	/**/
X?H:?%1:
X: now get the host name to advertise as our mailing address
Xcase "$hiddennet" in
X'') dflt=n;;
X*) dflt=y;;
Xesac
Xcat <<EOM
X 
XSome sites are on "hidden" networks, in the sense that the network appears
Xto the outside world as a single machine.  The advertised name of any host
Xon this hidden network is the name of one machine on the local network which
Xknows how to forward mail to any other host on the hidden network.
X
XDo you wish to advertise a different hostname to the world than the one your
XEOM
Xrp="own host ($hostname$mydomain) has? [$dflt]"
Xecho $n "$rp $c"
Xrp="Use HIDDENNET? [$dflt]"
X. myread
Xcase "$ans" in
Xn*) d_hidnet="$undef" hiddennet='';;
X*)
X    d_hidnet="$define"
X    echo " "
X    case "$hiddennet" in
X    '') dflt='???';;
X    *) dflt="$hiddennet";;
X    esac
X    rp="What hostname do you wish to advertise? [$dflt]"
X    echo $n "$rp $c"
X    . myread
X    hiddennet="$ans"
X    ;;
Xesac
X
!STUFFY!FUNK!
echo Extracting pat/patftp.SH
sed >pat/patftp.SH <<'!STUFFY!FUNK!' -e 's/X//'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X	echo "Using config.sh from above..."
X    fi
X    . ./config.sh
X    ;;
Xesac
X: This forces SH files to create target in same directory as SH file.
X: This is so that make depend always knows where to find SH derivatives.
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting patftp (with variable substitutions)"
Xcat >patftp <<!GROK!THIS!
X#!/usr/bin/perl
X        eval "exec /usr/bin/perl -S \$0 \$*"
X                if \$running_under_some_shell;
X
X# $Header: patftp.SH,v 2.0 88/06/28 23:19:57 lwall Locked $
X#
X# $Log:	patftp.SH,v $
X# Revision 2.0  88/06/28  23:19:57  lwall
X# Baseline.
X# 
X
X\$orgname='$orgname';
X!GROK!THIS!
X
X: In the following dollars and backticks do not need the extra backslash.
Xcat >>patftp <<'!NO!SUBS!'
X
Xchop($orgname = `cat $orgname`) if $orgname =~ m|^/|;
X
Xchdir '..' if -f '../.package';
X
Xdo readpackage();
X
Xif ($#ARGV < 0) {
X    open(PL,"patchlevel.h") || die "Can't open patchlevel.h\n";
X    while (<PL>) {
X        $argv = $1 if /^#define\s+PATCHLEVEL\s+(\d+)/;
X    }
X    close PL;
X    die "Malformed patchlevel.h file.\n" if $argv eq '';
X    @ARGV = $argv;
X}
Xelse {
X    for (@ARGV) {
X	s/^patch//;
X    }
X    $argv = do rangeargs(@ARGV);
X    @ARGV = split(' ',$argv);
X}
X
Xif ($#ARGV < 0) {
X    die "No patches specified.\n";
X}
Xelsif ($#ARGV) {
X    print "Copying $package $baserev patches $argv to $ftpdir...\n";
X}
Xelse {
X    print "Copying $package $baserev patch $argv to $ftpdir...\n";
X}
X
Xchdir 'bugs' || die "Can't cd to bugs\n";
X
Xuntil ($#ARGV < 0) {
X    $patnum = shift;
X    `cp patch$patnum $ftpdir`;
X}
X
X!NO!SUBS!
Xcat ../pl/package.pl >>patftp
Xcat ../pl/rangeargs.pl >>patftp
Xchmod +x patftp
X$eunicefix patftp
!STUFFY!FUNK!
echo Extracting mcon/U/newslib.U
sed >mcon/U/newslib.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: newslib.U,v 2.0 88/06/28 23:17:41 lwall Locked $
X?RCS: $Log:	newslib.U,v $
X?RCS: Revision 2.0  88/06/28  23:17:41  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:newslib newslibexp: test echo n c d_portable inews Myread Filexp Oldconfig
X?MAKE:	-pick add $@ %*
X?S:newslib:
X?S:	This variable contains the eventual value of the NEWSLIB symbol,
X?S:	which holds the name of the directory serving as the news library.
X?S:	It may have a ~ on the front.  See newslibexp for expanded version.
X?S:.
X?S:newslibexp
X?S:	This variable contains the ~ expanded name of the news library
X?S:	directory.  See newslib.
X?S:.
X?C:NEWSLIB
X?C:	This symbol contains the name of the directory serving as the news
X?C:	library.  The program must be prepared to do ~ expansion on it.
X?C:.
X?H:?%1:#define NEWSLIB "$newslib"		/**/
X?H:?%1:
X: figure out news library
Xcase "$newslib" in
X'')
X    dflt=/usr/lib/news
X    ;;
X*)  dflt=$newslib ;;
Xesac
Xnewslibexp=$newslib
Xnewslibexp='blurfl/dyick'
Xcont=true
Xwhile $test "$cont"; do
X    echo " "
X    rp="Where is your news library (~name okay)? [$dflt]"
X    $echo $n "$rp $c"
X    . myread
X    newslib="$ans"
X    case "$newslib" in
X    ~*)
X	newslibexp=`filexp $newslib`
X	echo "(That is $newslibexp on this particular system.)"
X	case "$d_portable" in
X	  "$undef") newslib=$newslibexp ;;
X	esac
X	;;
X    *)
X	newslibexp=$newslib
X	;;
X    esac
X    if test -d $newslibexp; then
X	cont=''
X    else
X	dflt=n
X	rp="Directory $newslibexp doesn't exist.  Use that name anyway? [$dflt]"
X	$echo $n "$rp $c"
X	. myread
X	dflt=''
X	case "$ans" in
X	y*) cont='';;
X	esac
X    fi
Xdone
Xif $test -f $newslibexp/inews; then
X    echo "Aha!  Inews is really in $newslibexp!  Maybe this is 2.10.2..."
X    case "$inews" in
X    inews) 
X	: null
X	;;
X    *)
X	echo "(Make sure $inews isn't an old version.)"
X	;;
X    esac
X    inews=$newslibexp/inews
Xfi
X
!STUFFY!FUNK!
echo Extracting kit/Makefile.SH
sed >kit/Makefile.SH <<'!STUFFY!FUNK!' -e 's/X//'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X	echo "Using config.sh from above..."
X    fi
X    . ./config.sh
X    ;;
Xesac
X: This forces SH files to create target in same directory as SH file.
X: This is so that make depend always knows where to find SH derivatives.
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting Makefile (with variable substitutions)"
Xcat >Makefile <<!GROK!THIS!
X# $Header: Makefile.SH,v 2.0 88/06/28 23:12:03 lwall Locked $
X#
X# $Log:	Makefile.SH,v $
X# Revision 2.0  88/06/28  23:12:03  lwall
X# Baseline.
X# 
X
Xbin = $bin
Xmansrc = $mansrc
Xmanext = $manext
XCFLAGS = -O
XLDFLAGS = $iandd
X
X!GROK!THIS!
Xcat >>Makefile <<'!NO!SUBS!'
X
XCC = cc
Xpublic = makedist makeSH
Xprivate = 
Xmanpages = makedist.man
Xutil = Makefile
X
Xc =
X
Xobj =
X
Xlintflags = -phbvxac
X
Xaddedbyconf = Makefile makedist
X
X# grrr
XSHELL = /bin/sh
X
X.c.o:
X	$(CC) -c $(CFLAGS) $*.c
X
Xall: $(public) $(private) $(util)
X	touch all
X
Xmakedist: makedist.SH
X	sh makedist.SH
X
X# won't work with csh
Xinstall: $(public)
X	export PATH || exit 1
X	- if test `pwd` != $(bin); then cp $(public) $(bin); fi
X	cd $(bin); chmod +x $(public)
X	- if test `pwd` != $(mansrc); then \
Xfor page in $(manpages); do \
Xcp $$page $(mansrc)/`basename $$page .man`.$(manext); \
Xdone; \
Xfi
X
Xclean:
X	rm -f *.o
X
Xrealclean:
X	rm -f kitlists *.o core $(addedbyconf)
X
X# The following lint has practically everything turned on.  Unfortunately,
X# you have to wade through a lot of mumbo jumbo that can't be suppressed.
X# If the source file has a /*NOSTRICT*/ somewhere, ignore the lint message
X# for that spot.
X
Xlint:
X	lint $(lintflags) $(defs) $(c) > kitlists.fuzz
X
X!NO!SUBS!
X$eunicefix Makefile
!STUFFY!FUNK!
echo Extracting mcon/U/d_usendir.U
sed >mcon/U/d_usendir.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_usendir.U,v 2.0 88/06/28 23:16:19 lwall Locked $
X?RCS: $Log:	d_usendir.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:19  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_usendir d_libndir ndirc ndiro: test contains libc
X?MAKE:	-pick add $@ %*
X?S:d_usendir:
X?S:	This variable conditionally defines the USENDIR symbol, which
X?S:	indicates to the C program that it should compile the ndir.c code
X?S:	provided with the package.
X?S:.
X?S:d_libndir:
X?S:	This variable conditionally defines the LIBNDIR symbol, which
X?S:	indicates to the C program that it should include the system's
X?S:	version of ndir.h, rather than the one with this package.
X?S:.
X?C:USENDIR:
X?C:	This symbol, if defined, indicates that the program should compile
X?C:	the ndir.c code provided with the package.
X?C:.
X?C:LIBNDIR:
X?C:	This symbol, if defined, indicates that the program should include the
X?C:	system's version of ndir.h, rather than the one with this package.
X?C:.
X?H:?%1:#$d_usendir	USENDIR		/**/
X?H:?%1:#$d_libndir	LIBNDIR		/**/
X?H:?%1:
X: see if there are directory access routines out there
Xecho " "
Xif $test -r /usr/include/ndir.h && \
X      ( $test -r /usr/lib/libndir.a || $test -r /usr/local/lib/libndir.a ); then
X    echo "Ndir library found."
X    if $test -r /usr/lib/libndir.a; then
X	ndirlib='-lndir'
X    else
X	ndirlib="/usr/local/lib/libndir.a"
X    fi
X    d_libndir="$define"
X    d_usendir="$undef"
X    ndirc=''
X    ndiro=''
Xelse
X    ndirlib=''
X    d_libndir="$undef"
X    if bsd && $contains '^readdir$' libc.list >/dev/null 2>&1 ; then
X	echo "No ndir library found, but you have readdir() so we'll use that."
X	d_usendir="$undef"
X	ndirc=''
X	ndiro=''
X    else
X	echo "No ndir library found--using ./ndir.c."
X	d_usendir="$define"
X	ndirc='ndir.c'
X	ndiro='ndir.o'
X    fi
Xfi
X
!STUFFY!FUNK!
echo Extracting Makefile
sed >Makefile <<'!STUFFY!FUNK!' -e 's/X//'
Xall:
X	cd mcon && make
X	cd pat && make
X	cd kit && make
X
Xinstall:
X	cd mcon && make install
X	cd pat && make install
X	cd kit && make install
!STUFFY!FUNK!
echo ""
echo "End of kit 4 (of 7)"
cat /dev/null >kit4isdone
run=''
config=''
for iskit in 1 2 3 4 5 6 7; do
    if test -f kit${iskit}isdone; then
	run="$run $iskit"
    else
	todo="$todo $iskit"
    fi
done
case $todo in
    '')
	echo "You have run all your kits.  Please read README and then type Configure."
	chmod 755 Configure
	;;
    *)  echo "You have run$run."
	echo "You still need to run$todo."
	;;
esac
: Someone might mail this, so...
exit

