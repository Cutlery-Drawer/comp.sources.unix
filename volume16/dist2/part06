Subject:  v16i039:  Larry Wall's Configure generator, etc., Part06/07
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: lwall@jpl-devvax.jpl.nasa.gov (Larry Wall)
Posting-number: Volume 16, Issue 39
Archive-name: dist2/part06

#! /bin/sh

# Make a new directory for the dist sources, cd to it, and run kits 1
# thru 7 through sh.  When all 7 kits have been run, read README.

echo "This is dist 2.0 kit 6 (of 7).  If kit 6 is complete, the line"
echo '"'"End of kit 6 (of 7)"'" will echo at the end.'
echo ""
export PATH || (echo "You didn't use sh, you clunch." ; kill $$)
mkdir mcon mcon/U pl 2>/dev/null
echo Extracting mcon/U/uidtype.U
sed >mcon/U/uidtype.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: uidtype.U,v 1.0 87/05/22 12:33:47 lwall Exp $
X?RCS: $Log:	uidtype.U,v $
X?RCS: Revision 1.0  87/05/22  12:33:47  lwall
X?RCS: Initial revision
X?RCS: 
X?MAKE:uidtype: echo n c Myread Oldconfig Loc contains
X?MAKE:	-pick add $@ %*
X?S:uidtype:
X?S:	This variable defines UIDTYPE to be something like uid_t, int, 
X?S:	ushort, or whatever type is used to declare user ids in the kernel.
X?S:.
X?C:UIDTYPE:
X?C:	This symbol has a value like uid_t, int, ushort, or whatever type is
X?C:	used to declare user ids in the kernel.
X?C:.
X?H:?%1:#define UIDTYPE $uidtype		/**/
X?H:?%1:
X: see what type uids are declared as in the kernel
Xcase "$uidtype" in
X'')
X    if $contains 'uid_t;' /usr/include/sys/types.h >/dev/null 2>&1 ; then
X	dflt='uid_t';
X    else
X	set `grep '_ruid;' /usr/include/sys/user.h 2>/dev/null` unsigned short
X	case $1 in
X	unsigned) dflt="$1 $2" ;;
X	*) dflt="$1" ;;
X	esac
X    fi
X    ;;
X*)  dflt="$uidtype"
X    ;;
Xesac
Xcont=true
Xecho " "
Xrp="What type are user ids on this system declared as? [$dflt]"
X$echo $n "$rp $c"
X. myread
Xuidtype="$ans"
X
!STUFFY!FUNK!
echo Extracting mcon/U/defeditor.U
sed >mcon/U/defeditor.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: defeditor.U,v 2.0 88/06/28 23:16:36 lwall Locked $
X?RCS: $Log:	defeditor.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:36  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:defeditor: test echo n c Myread Oldconfig Loc vi
X?MAKE:	-pick add $@ %*
X?S:defeditor:
X?S:	This variable contains the eventual value of the DEFEDITOR symbol,
X?S:	which contains the name of the default editor.
X?S:.
X?C:DEFEDITOR:
X?C:	This symbol contains the name of the default editor.
X?C:.
X?H:?%1:#define DEFEDITOR "$defeditor"		/**/
X?H:?%1:
X: determine default editor
Xcase "$defeditor" in
X'')
X    case "$_vi" in
X    */*) dflt="$_vi";;
X    *) dflt=/usr/ucb/vi;;
X    esac
X    ;;
X*)  dflt="$defeditor"
X    ;;
Xesac
Xcont=true
Xwhile $test "$cont" ; do
X    echo " "
X    rp="What is the default editor on your system? [$dflt]"
X    $echo $n "$rp $c"
X    . myread
X    defeditor="$ans"
X    if test -f $ans; then
X	cont=''
X    else
X	dflt=n
X	rp="File $ans doesn't exist.  Use that name anyway? [$dflt]"
X	$echo $n "$rp $c"
X	. myread
X	dflt=''
X	case "$ans" in
X	y*) cont='';;
X	esac
X    fi
Xdone
X
!STUFFY!FUNK!
echo Extracting mcon/U/sunscanf.U
sed >mcon/U/sunscanf.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: sunscanf.U,v 2.0 88/06/28 23:18:31 lwall Locked $
X?RCS: $Log:	sunscanf.U,v $
X?RCS:Revision 2.0  88/06/28  23:18:31  lwall
X?RCS:Baseline.
X?RCS:
X?MAKE:sunscanf: cat rm Myread echo n c
X?MAKE:	-pick add $@ %*
X?S:sunscanf:
X?S:	This variable is set if this system runs with the Sun version
X?S:	of scanf.
X?S:.
X?C:SUNSCANF:
X?C:	This variable is set if this system runs with the Sun version
X?C:	of scanf.
X?C:.
X?H:?%1:#$sunscanf 	SUNSCANF  /**/
X?H:?%1:
X: check to see what kinda scanf your using.
Xecho " "
Xecho $n "Checking to see what flavor of scanf you have..."
X$cat >scanf.c <<'EOCP'
Xmain()
X{
X        float value;
X
X        sscanf("4.5","%g",&value);
X        printf("%d\n",value==4.5);
X}
XEOCP
Xif cc scanf.c -o scanf >/dev/null 2>&1 ; then
X	$echo " "
X	if $test `scanf` = 0; then
X		$echo "Hmm.. seems your not running the USG flavor.."
X		sunscanf="$undef"
X	else
X		$echo "Uh... your running the USG flavor of scanf"
X		sunscanf="$define"
X	fi
Xelse
X	$echo "     I can't seem to compile the test program... "
X	sunscanf="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/contains.U
sed >mcon/U/contains.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: contains.U,v 2.0 88/06/28 23:14:11 lwall Locked $
X?RCS: $Log:	contains.U,v $
X?RCS: Revision 2.0  88/06/28  23:14:11  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:contains: Myinit
X?MAKE:	-pick add $@ %*
X?S:contains:
X?S:	This variable holds the command to do a grep with a proper return
X?S:	status.  On most sane systems it is simply "grep".  On insane systems
X?S:	it is a grep followed by a cat followed by a test.  This variable
X?S:	is primarily for the use of other Configure units.
X?S:.
X: some greps do not return status, grrr.
Xecho "grimblepritz" >grimble
Xif grep blurfldyick grimble >/dev/null 2>&1 ; then
X    contains=contains
Xelif grep grimblepritz grimble >/dev/null 2>&1 ; then
X    contains=grep
Xelse
X    contains=contains
Xfi
Xrm -f grimble
X: the following should work in any shell
Xcase "$contains" in
Xcontains*)
X    echo " "
X    echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
X    cat >contains <<'EOSS'
Xgrep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
XEOSS
Xchmod +x contains
Xesac
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_sgndchr.U
sed >mcon/U/d_sgndchr.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_sgndchr.U,v 2.0 88/06/28 23:15:43 lwall Locked $
X?RCS: $Log:	d_sgndchr.U,v $
X?RCS: Revision 2.0  88/06/28  23:15:43  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_sgndchr: cat rm
X?MAKE:	-pick add $@ %*
X?S:d_sgndchr:
X?S:	This variable conditionally defines the SIGNEDCHAR symbol, which
X?S:	indicates to the C program that signed characters are available.
X?S:.
X?C:SIGNEDCHAR:
X?C:	This symbol, if defined, indicates that characters are a signed type.
X?C:	If not defined, things declared as signed characters (and that make
X?C:	use of negative values) should probably be declared as shorts instead.
X?C:.
X?H:?%1:#$d_sgndchr	SIGNEDCHAR	/**/
X?H:?%1:
X: check for signed chars
Xecho " "
Xecho "Checking to see if your C compiler can do signed chars..."
X$cat >try.c <<'EOCP'
Xmain()
X{
X	char c = 0;
X
X	c--;
X	exit(c >= 0);
X}
XEOCP
Xcc -o a.out try.c
Xif a.out; then
X    d_sgndchr="$define"
X    echo "It certainly can."
Xelse
X    d_sgndchr="$undef"
X    echo "It can't.  I'll have to make some things type short."
Xfi
X$rm -f try.* a.out
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_voidsig.U
sed >mcon/U/d_voidsig.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_voidsig.U,v 2.0 88/06/28 23:16:29 lwall Locked $
X?RCS: $Log:	d_voidsig.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:29  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_voidsig: contains
X?MAKE:	-pick add $@ %*
X?S:d_voidsig:
X?S:	This variable conditionally defines VOIDSIG if this system
X?S:	declares "void (*signal())()" in signal.h.  The old way was to
X?S:	declare it as "int (*signal())()".
X?S:.
X?C:VOIDSIG:
X?C:	This symbol is defined if this system declares "void (*signal())()" in
X?C:	signal.h.  The old way was to declare it as "int (*signal())()".  It
X?C:	is up to the package author to declare things correctly based on the
X?C:	symbol.
X?C:.
X?H:?%1:#$d_voidsig	VOIDSIG 	/**/
X?H:?%1:
X: see if signal is declared as pointer to function returning int or void
Xecho " "
Xif $contains 'void.*signal' /usr/include/signal.h >/dev/null 2>&1 ; then
X    echo "You have void (*signal())() instead of int."
X    d_voidsig="$define"
Xelse
X    echo "You have int (*signal())() instead of void."
X    d_voidsig="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/n.U
sed >mcon/U/n.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: n.U,v 2.0 88/06/28 23:17:30 lwall Locked $
X?RCS: $Log:	n.U,v $
X?RCS: Revision 2.0  88/06/28  23:17:30  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:n c: contains
X?MAKE:	-pick add $@ %*
X?S:n:
X?S:	This variable contains the -n flag if that is what causes the echo
X?S:	command to suppress newline.  Otherwise it is null.  Correct usage is
X?S:	    $echo $n "prompt for a question: $c".
X?S:.
X?S:c:
X?S:	This variable contains the \c string if that is what causes the echo
X?S:	command to suppress newline.  Otherwise it is null.  Correct usage is
X?S:	    $echo $n "prompt for a question: $c".
X?S:.
X: first determine how to suppress newline on echo command
Xecho "Checking echo to see how to suppress newlines..."
X(echo "hi there\c" ; echo " ") >.echotmp
Xif $contains c .echotmp >/dev/null 2>&1 ; then
X    echo "...using -n."
X    n='-n'
X    c=''
Xelse
X    cat <<'EOM'
X...using \c
XEOM
X    n=''
X    c='\c'
Xfi
Xecho $n "Type carriage return to continue.  Your cursor should be here-->$c"
Xread ans
Xrm -f .echotmp
X
!STUFFY!FUNK!
echo Extracting mcon/U/bin.U
sed >mcon/U/bin.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: bin.U,v 2.0 88/06/28 23:14:02 lwall Locked $
X?RCS: $Log:	bin.U,v $
X?RCS: Revision 2.0  88/06/28  23:14:02  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:bin: test echo n c Myread Loc Filexp Oldconfig
X?MAKE:	-pick add $@ %*
X?S:bin:
X?S:	This variable holds the name of the directory in which the user wants
X?S:	to put publicly executable images for the package in question.  It
X?S:	is most often a local directory such as /usr/local/bin.
X?S:.
X: determine where public executables go
Xcase "$bin" in
X'')
X    dflt=`loc . /bin /usr/local/bin /usr/lbin /usr/local /usr/bin`
X    ;;
X*)  dflt="$bin"
X    ;;
Xesac
Xcont=true
Xwhile $test "$cont" ; do
X    echo " "
X    rp="Where do you want to put the public executables? [$dflt]"
X    $echo $n "$rp $c"
X    . myread
X    bin="$ans"
X    bin=`filexp $bin`
X    if test -d $bin; then
X	cont=''
X    else
X	dflt=n
X	rp="Directory $bin doesn't exist.  Use that name anyway? [$dflt]"
X	$echo $n "$rp $c"
X	. myread
X	dflt=''
X	case "$ans" in
X	y*) cont='';;
X	esac
X    fi
Xdone
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_strctcpy.U
sed >mcon/U/d_strctcpy.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_strctcpy.U,v 2.0 88/06/28 23:16:02 lwall Locked $
X?RCS: $Log:	d_strctcpy.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:02  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_strctcpy: cat rm
X?MAKE:	-pick add $@ %*
X?S:d_strctcpy:
X?S:	This variable conditionally defines the STRUCTCOPY symbol, which
X?S:	indicates to the C program that this C compiler knows how to copy
X?S:	structures.
X?S:.
X?C:STRUCTCOPY:
X?C:	This symbol, if defined, indicates that this C compiler knows how
X?C:	to copy structures.  If undefined, you'll need to use a block copy
X?C:	routine of some sort instead.
X?C:.
X?H:?%1:#$d_strctcpy	STRUCTCOPY	/**/
X?H:?%1:
X: check for structure copying
Xecho " "
Xecho "Checking to see if your C compiler can copy structs..."
X$cat >try.c <<'EOCP'
Xmain()
X{
X	struct blurfl {
X	    int dyick;
X	} foo, bar;
X
X	foo = bar;
X}
XEOCP
Xif cc -c try.c >/dev/null 2>&1 ; then
X    d_strctcpy="$define"
X    echo "Yup, it can."
Xelse
X    d_strctcpy="$undef"
X    echo "Nope, it can't."
Xfi
X$rm -f try.*
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_rdchk.U
sed >mcon/U/d_rdchk.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_rdchk.U,v 2.0 88/06/28 23:15:35 lwall Locked $
X?RCS: $Log:	d_rdchk.U,v $
X?RCS: Revision 2.0  88/06/28  23:15:35  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_rdchk: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_rdchk:
X?S:	This variable conditionally defines the RDCHK symbol, which
X?S:	indicates to the C program that the rdchk() routine is available
X?S:	to find out if there is input pending on an IO channel.
X?S:.
X?C:RDCHK:
X?C:	This symbol, if defined, indicates that the rdchk routine is available
X?C:	to find out if there is input pending on an IO channel.  Generally
X?C:	the routine is used only if FIONREAD and O_NDELAY aren't available.
X?C:.
X?H:?%1:#$d_rdchk	RDCHK		/**/
X?H:?%1:
X: see if rdchk exists
Xecho " "
Xif $contains '^rdchk$' libc.list >/dev/null 2>&1; then
X    echo 'rdchk() found.'
X    d_rdchk="$define"
Xelse
X    if v7; then
X	echo "rdchk() not found--you'd better have FIONREAD or O_NDELAY."
X    else
X	echo 'rdchk() not found.'
X    fi
X    d_rdchk="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/Myread.U
sed >mcon/U/Myread.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: Myread.U,v 2.0 88/06/28 23:13:39 lwall Locked $
X?X: 
X?X: This unit produces a bit of shell code that must be dotted in in order
X?X: to do a read.  It allows for shell escapes and default assignment.
X?X: 
X?RCS: $Log:	Myread.U,v $
X?RCS: Revision 2.0  88/06/28  23:13:39  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:Myread: n c
X?MAKE:	-pick add $@ %*
X: now set up to do reads with possible shell escape and default assignment
Xcat <<EOSC >myread
Xcase "\$fastread" in
Xyes) ans=''; echo " " ;;
X*) ans='!';;
Xesac
Xwhile expr "X\$ans" : "X!" >/dev/null; do
X    read ans
X    case "\$ans" in
X    !)
X	sh
X	echo " "
X?X: The $n and $c below are substituted before Loc does its silly echo check
X?X: so don't put a $ on the echo below so we get builtin, even if $echo is
X?X: pointing to /bin/echo.
X	echo $n "\$rp $c"
X	;;
X    !*)
X	set \`expr "X\$ans" : "X!\(.*\)\$"\`
X	sh -c "\$*"
X	echo " "
X	echo $n "\$rp $c"
X	;;
X    esac
Xdone
Xrp='Your answer:'
Xcase "\$ans" in
X'') ans="\$dflt";;
Xesac
XEOSC
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_tminsys.U
sed >mcon/U/d_tminsys.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_tminsys.U,v 2.0 88/06/28 23:16:11 lwall Locked $
X?RCS: $Log:	d_tminsys.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:11  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_tminsys: contains
X?MAKE:	-pick add $@ %*
X?S:d_tminsys:
X?S:	This variable conditionally defines TMINSYS if this system
X?S:	declares "struct tm" in <sys/time.h> rather than <time.h>.
X?S:.
X?C:TMINSYS:
X?C:	This symbol is defined if this system declares "struct tm" in
X?C:	in <sys/time.h> rather than <time.h>.  We can't just say
X?C:	-I/usr/include/sys because some systems have both time files, and
X?C:	the -I trick gets the wrong one.
X?C:.
X?H:?%1:#$d_tminsys	TMINSYS 	/**/
X?H:?%1:
X: see if struct tm is defined in sys/time.h
Xecho " "
Xif $contains 'struct tm' /usr/include/time.h >/dev/null 2>&1 ; then
X    echo "You have struct tm defined in <time.h> rather than <sys/time.h>."
X    d_tminsys="$undef"
Xelse
X    echo "You have struct tm defined in <sys/time.h> rather than <time.h>."
X    d_tminsys="$define"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_statblks.U
sed >mcon/U/d_statblks.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_statblks.U,v 2.0 88/06/28 23:15:54 lwall Locked $
X?RCS: $Log:	d_statblks.U,v $
X?RCS: Revision 2.0  88/06/28  23:15:54  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_statblks: contains
X?MAKE:	-pick add $@ %*
X?S:d_statblks:
X?S:	This variable conditionally defines STATBLOCKS if this system
X?S:	has a stat structure declaring st_blksize and st_blocks.
X?S:.
X?C:STATBLOCKS:
X?C:	This symbol is defined if this system has a stat structure declaring
X?C:	st_blksize and st_blocks.
X?C:.
X?H:?%1:#$d_statblks	STATBLOCKS 	/**/
X?H:?%1:
X: see if stat knows about block sizes
Xecho " "
Xif $contains 'st_blocks;' /usr/include/sys/stat.h >/dev/null 2>&1 ; then
X    if $contains 'st_blksize;' /usr/include/sys/stat.h >/dev/null 2>&1 ; then
X	echo "Your stat knows about block sizes."
X	d_statblks="$define"
X    else
X	echo "Your stat doesn't know about block sizes."
X	d_statblks="$undef"
X    fi
Xelse
X    echo "Your stat doesn't know about block sizes."
X    d_statblks="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_raster.U
sed >mcon/U/d_raster.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_raster.U,v 2.0 88/06/28 23:15:32 lwall Locked $
X?RCS: $Log:	d_raster.U,v $
X?RCS:Revision 2.0  88/06/28  23:15:32  lwall
X?RCS:Baseline.
X?RCS:
X?RCS: 
X?RCS: Revision 1.0  87/05/22  12:32:25  siegel
X?RCS: Initial revision
X?RCS: 
X?MAKE:d_raster: contains echo n Myread c
X?MAKE:	-pick add $@ %*
X?S:d_raster:
X?S:	set to be the compile flag if this is a raster tech machine
X?S:.
X?C:RASTER_TEK:
X?C:	Defined if this is a rastertech machine.
X?C:.
X?H:?%1:#$d_raster RASTER_TEK /**/
X?H:?%1:
X
X: See if this is a raster tech machine.
X
Xecho " "
Xd_raster='/*undef'
Xif $test -r /dev/mirage; then
X	$echo "You seem to have a mirage device... this is normally"
X	$echo "associated with a raster technologies graphics workstation."
X	$echo " "
X	$echo "Is that what this is, and if it is,"
X
X	dflt='y'
X	$echo $n "should I compile it in? [$dflt] $c"
X	rp="use raster tech? [$dflt] "
X	. myread
X	if $test $ans = "y"; then
X		d_raster='define'
X	fi
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/Init.U
sed >mcon/U/Init.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: Init.U,v 2.0 88/06/28 23:13:17 lwall Locked $
X?X: 
X?X: This file initializes certain default variables used by Configure.  They
X?X: may be overridden or added to by definitions in Myinit.U.
X?X: 
X?RCS: $Log:	Init.U,v $
X?RCS: Revision 2.0  88/06/28  23:13:17  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:Init define: Null package
X?MAKE:	-pick add $@ %*
X?MAKE:	-pick weed $@ ./.Init
Xecho " "
Xecho "Beginning of configuration questions for $package kit."
X: Eunice requires " " instead of "", can you believe it
Xecho " "
X
Xdefine='define'
Xundef='undef'
Xlibpth='/usr/lib /usr/local/lib /lib'
Xsmallmach='pdp11 i8086 z8000 i80286 iAPX286'
Xrmlist='kit[1-9]isdone kit[1-9][0-9]isdone'
Xtrap 'echo " "; rm -f $rmlist; exit 1' 1 2 3
X
X: We must find out about Eunice early
Xeunicefix=':'
Xif test -f /etc/unixtovms; then
X    eunicefix=/etc/unixtovms
Xfi
Xif test -f /etc/unixtovms.exe; then
X    eunicefix=/etc/unixtovms.exe
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_stdstdio.U
sed >mcon/U/d_stdstdio.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_stdstdio.U,v 2.0 88/06/28 23:15:58 lwall Locked $
X?RCS: $Log:	d_stdstdio.U,v $
X?RCS: Revision 2.0  88/06/28  23:15:58  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_stdstdio: contains
X?MAKE:	-pick add $@ %*
X?S:d_stdstdio:
X?S:	This variable conditionally defines STDSTDIO if this system
X?S:	has a FILE structure declaring _ptr and _cnt in stdio.h.
X?S:.
X?C:STDSTDIO:
X?C:	This symbol is defined if this system has a FILE structure declaring
X?C:	_ptr and _cnt in stdio.h.
X?C:.
X?H:?%1:#$d_stdstdio	STDSTDIO 	/**/
X?H:?%1:
X: see if stdio is really std
Xecho " "
Xif $contains 'char.*_ptr;' /usr/include/stdio.h >/dev/null 2>&1 ; then
X    if $contains '_cnt;' /usr/include/stdio.h >/dev/null 2>&1 ; then
X	echo "Your stdio is pretty std."
X	d_stdstdio="$define"
X    else
X	echo "Your stdio isn't very std."
X	d_stdstdio="$undef"
X    fi
Xelse
X    echo "Your stdio isn't very std."
X    d_stdstdio="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_getgrps.U
sed >mcon/U/d_getgrps.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_getgrps.U,v 2.0 88/06/29 00:18:51 lwall Locked $
X?RCS: $Log:	d_getgrps.U,v $
X?RCS: Revision 2.0  88/06/29  00:18:51  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_getgrps: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_getgrps:
X?S:	This variable conditionally defines the GETGROUPS symbol, which
X?S:	indicates to the C program that the getgroups() routine is available
X?S:	to get the list of process groups.
X?S:.
X?C:GETGROUPS:
X?C:	This symbol, if defined, indicates that the getgroups() routine is
X?C:	available to get the list of process groups.  If unavailable, multiple
X?C:	groups are probably not supported.
X?C:.
X?H:?%1:#$d_getgrps	GETGROUPS		/**/
X?H:?%1:
X: see if getgroups exists
Xecho " "
Xif $contains '^getgroups$' libc.list >/dev/null 2>&1; then
X    echo 'getgroups() found.'
X    d_getgrps="$define"
Xelse
X    echo 'getgroups() not found.'
X    d_getgrps="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/maildir.U
sed >mcon/U/maildir.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: maildir.U,v 2.0 88/06/28 23:17:02 lwall Locked $
X?RCS: $Log:	maildir.U,v $
X?RCS: Revision 2.0  88/06/28  23:17:02  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:maildir: test echo n c Myread Loc Filexp Oldconfig
X?MAKE:	-pick add $@ %*
X?S:maildir:
X?S:	This variable contains the name of the directory in which mail is
X?S:	spooled.
X?S:.
X: determine where mail is spooled
Xcase "$maildir" in
X'')
X    dflt=`loc . /usr/spool/mail /usr/spool/mail /usr/mail`
X    ;;
X*)  dflt="$maildir"
X    ;;
Xesac
Xcont=true
Xwhile $test "$cont" ; do
X    echo " "
X    rp="Where is yet-to-be-read mail spooled? [$dflt]"
X    $echo $n "$rp $c"
X    . myread
X    maildir=`filexp "$ans"`
X    if test -d $maildir; then
X	cont=''
X    else
X	dflt=n
X	rp="Directory $maildir doesn't exist.  Use that name anyway? [$dflt]"
X	$echo $n "$rp $c"
X	. myread
X	dflt=''
X	case "$ans" in
X	y*) cont='';;
X	esac
X    fi
Xdone
X
!STUFFY!FUNK!
echo Extracting pl/rcsargs.pl
sed >pl/rcsargs.pl <<'!STUFFY!FUNK!' -e 's/X//'
Xsub rcsargs {
X    local($result) = '';
X    local($_);
X    while ($_ = shift(@_)) {
X	if ($_ =~ /^-/) {
X	    $result .= $_ . ' ';
X	}
X	elsif ($#_ >= 0 && do equiv($_,$_[0])) {
X	    $result .= $_ . ' ' . $_[0] . ' ';
X	    shift(@_);
X	}
X	else {
X	    $result .= $_ . ' ' . do other($_) . ' ';
X	}
X    }
X    $result;
X}
X
Xsub equiv {
X    local($s1, $s2) = @_;
X    $s1 =~ s|.*/||;
X    $s2 =~ s|.*/||;
X    if ($s1 eq $s2) {
X	0;
X    }
X    elsif ($s1 =~ s/$RCSEXT$// || $s2 =~ s/$RCSEXT$//) {
X	$s1 eq $s2;
X    }
X    else {
X	0;
X    }
X}
X
Xsub other {
X    local($s1) = @_;
X    ($dir,$file) = ('./',$s1) unless local($dir,$file) = ($s1 =~ m|(.*/)(.*)|);
X    local($wasrcs) = ($file =~ s/$RCSEXT$//);
X    if ($wasrcs) {
X	`mkdir $dir` unless -d $dir;
X	$dir =~ s|RCS/||;
X    }
X    else {
X	$dir .= 'RCS/';
X	`mkdir $dir` unless -d $dir;
X	$file .= $RCSEXT;
X    }
X    "$dir$file";
X}
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_memcpy.U
sed >mcon/U/d_memcpy.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_memcpy.U,v 2.0 88/06/29 00:19:17 lwall Locked $
X?RCS: $Log:	d_memcpy.U,v $
X?RCS: Revision 2.0  88/06/29  00:19:17  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_memcpy: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_memcpy:
X?S:	This variable conditionally defines the MEMCPY symbol, which
X?S:	indicates to the C program that the memcpy() routine is available
X?S:	to copy blocks of memory.
X?S:.
X?C:MEMCPY:
X?C:	This symbol, if defined, indicates that the memcpy routine is available
X?C:	to copy blocks of memory.  Otherwise you should probably use bcopy().
X?C:	If neither is defined, roll your own.
X?C:.
X?H:?%1:#$d_memcpy	MEMCPY		/**/
X?H:?%1:
X: see if memcpy exists
Xecho " "
Xif $contains '^memcpy$' libc.list >/dev/null 2>&1; then
X    echo 'memcpy() found.'
X    d_memcpy="$define"
Xelse
X    echo 'memcpy() not found.'
X    d_memcpy="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_killpg.U
sed >mcon/U/d_killpg.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_killpg.U,v 2.0 88/06/29 00:19:10 lwall Locked $
X?RCS: $Log:	d_killpg.U,v $
X?RCS: Revision 2.0  88/06/29  00:19:10  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_killpg: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_killpg:
X?S:	This variable conditionally defines the KILLPG symbol, which
X?S:	indicates to the C program that the killpg() routine is available
X?S:	to kill process groups.
X?S:.
X?C:KILLPG:
X?C:	This symbol, if defined, indicates that the killpg routine is available
X?C:	to kill process groups.  If unavailable, you probably should use kill
X?C:	with a negative process number.
X?C:.
X?H:?%1:#$d_killpg	KILLPG		/**/
X?H:?%1:
X: see if killpg exists
Xecho " "
Xif $contains '^killpg$' libc.list >/dev/null 2>&1; then
X    echo 'killpg() found.'
X    d_killpg="$define"
Xelse
X    echo 'killpg() not found.'
X    d_killpg="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_seteuid.U
sed >mcon/U/d_seteuid.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_seteuid.U,v 2.0 88/06/29 00:19:46 lwall Locked $
X?RCS: $Log:	d_seteuid.U,v $
X?RCS: Revision 2.0  88/06/29  00:19:46  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_seteuid: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_seteuid:
X?S:	This variable conditionally defines the SETEUID symbol, which
X?S:	indicates to the C program that the seteuid() routine is available
X?S:	to change the effective uid of the current program.
X?S:.
X?C:SETEUID:
X?C:	This symbol, if defined, indicates that the seteuid routine is available
X?C:	to change the effective uid of the current program.
X?C:.
X?H:?%1:#$d_seteuid	SETEUID		/**/
X?H:?%1:
X: see if seteuid exists
Xecho " "
Xif $contains '^seteuid$' libc.list >/dev/null 2>&1; then
X    echo 'seteuid() found.'
X    d_seteuid="$define"
Xelse
X    echo 'seteuid() not found.'
X    d_seteuid="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_getpwent.U
sed >mcon/U/d_getpwent.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_getpwent.U,v 2.0 88/06/28 23:14:47 lwall Locked $
X?RCS: $Log:	d_getpwent.U,v $
X?RCS: Revision 2.0  88/06/28  23:14:47  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_getpwent: contains libc
X?MAKE:	-pick add $@ %*
X?S:d_getpwent:
X?S:	This variable conditionally defines the GETPWENT symbol, which
X?S:	indicates to the C program that it should use the getpwent()
X?S:	routine instead of the getpw() routine.
X?S:.
X?C:GETPWENT:
X?C:	This symbol, if defined, indicates that the getpwent() routine
X?C:	should be used instead of the getpw() routine.
X?C:.
X?H:?%1:#$d_getpwent	GETPWENT	/**/
X?H:?%1:
X: see if there is a getpw
Xecho " "
Xif $contains '^getpw$' libc.list >/dev/null 2>&1 ; then
X    echo "getpw() found."
X    d_getpwent="$undef"
Xelse
X    echo "No getpw() found--will use getpwent() instead."
X    d_getpwent="$define"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_setegid.U
sed >mcon/U/d_setegid.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_setegid.U,v 2.0 88/06/29 00:19:34 lwall Locked $
X?RCS: $Log:	d_setegid.U,v $
X?RCS: Revision 2.0  88/06/29  00:19:34  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_setegid: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_setegid:
X?S:	This variable conditionally defines the SETEGID symbol, which
X?S:	indicates to the C program that the setegid() routine is available
X?S:	to change the effective gid of the current program.
X?S:.
X?C:SETEGID:
X?C:	This symbol, if defined, indicates that the setegid routine is available
X?C:	to change the effective gid of the current program.
X?C:.
X?H:?%1:#$d_setegid	SETEGID		/**/
X?H:?%1:
X: see if setegid exists
Xecho " "
Xif $contains '^setegid$' libc.list >/dev/null 2>&1; then
X    echo 'setegid() found.'
X    d_setegid="$define"
Xelse
X    echo 'setegid() not found.'
X    d_setegid="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_setruid.U
sed >mcon/U/d_setruid.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_setruid.U,v 2.0 88/06/29 00:19:56 lwall Locked $
X?RCS: $Log:	d_setruid.U,v $
X?RCS: Revision 2.0  88/06/29  00:19:56  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_setruid: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_setruid:
X?S:	This variable conditionally defines the SETRUID symbol, which
X?S:	indicates to the C program that the setruid() routine is available
X?S:	to change the real uid of the current program.
X?S:.
X?C:SETRUID:
X?C:	This symbol, if defined, indicates that the setruid routine is available
X?C:	to change the real uid of the current program.
X?C:.
X?H:?%1:#$d_setruid	SETRUID		/**/
X?H:?%1:
X: see if setruid exists
Xecho " "
Xif $contains '^setruid$' libc.list >/dev/null 2>&1; then
X    echo 'setruid() found.'
X    d_setruid="$define"
Xelse
X    echo 'setruid() not found.'
X    d_setruid="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_setrgid.U
sed >mcon/U/d_setrgid.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_setrgid.U,v 2.0 88/06/29 00:19:52 lwall Locked $
X?RCS: $Log:	d_setrgid.U,v $
X?RCS: Revision 2.0  88/06/29  00:19:52  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_setrgid: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_setrgid:
X?S:	This variable conditionally defines the SETRGID symbol, which
X?S:	indicates to the C program that the setrgid() routine is available
X?S:	to change the real gid of the current program.
X?S:.
X?C:SETRGID:
X?C:	This symbol, if defined, indicates that the setrgid routine is available
X?C:	to change the real gid of the current program.
X?C:.
X?H:?%1:#$d_setrgid	SETRGID		/**/
X?H:?%1:
X: see if setrgid exists
Xecho " "
Xif $contains '^setrgid$' libc.list >/dev/null 2>&1; then
X    echo 'setrgid() found.'
X    d_setrgid="$define"
Xelse
X    echo 'setrgid() not found.'
X    d_setrgid="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_fchown.U
sed >mcon/U/d_fchown.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_fchown.U,v 2.0 88/06/29 00:18:44 lwall Locked $
X?RCS: $Log:	d_fchown.U,v $
X?RCS: Revision 2.0  88/06/29  00:18:44  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_fchown: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_fchown:
X?S:	This variable conditionally defines the FCHOWN symbol, which
X?S:	indicates to the C program that the fchown() routine is available
X?S:	to change ownership of opened files.
X?S:.
X?C:FCHOWN:
X?C:	This symbol, if defined, indicates that the fchown routine is available
X?C:	to change ownership of opened files.  If unavailable, use chown().
X?C:.
X?H:?%1:#$d_fchown	FCHOWN		/**/
X?H:?%1:
X: see if fchown exists
Xecho " "
Xif $contains '^fchown$' libc.list >/dev/null 2>&1; then
X    echo 'fchown() found.'
X    d_fchown="$define"
Xelse
X    echo 'fchown() not found.'
X    d_fchown="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_rename.U
sed >mcon/U/d_rename.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_rename.U,v 2.0 88/06/29 00:19:24 lwall Locked $
X?RCS: $Log:	d_rename.U,v $
X?RCS: Revision 2.0  88/06/29  00:19:24  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_rename: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_rename:
X?S:	This variable conditionally defines the RENAME symbol, which
X?S:	indicates to the C program that the rename() routine is available
X?S:	to rename files.
X?S:.
X?C:RENAME:
X?C:	This symbol, if defined, indicates that the rename routine is available
X?C:	to rename files.  Otherwise you should do the unlink(), link(), unlink()
X?C:	trick.
X?C:.
X?H:?%1:#$d_rename	RENAME		/**/
X?H:?%1:
X: see if rename exists
Xecho " "
Xif $contains '^rename$' libc.list >/dev/null 2>&1; then
X    echo 'rename() found.'
X    d_rename="$define"
Xelse
X    echo 'rename() not found.'
X    d_rename="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/stdchar.U
sed >mcon/U/stdchar.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: stdchar.U,v 2.0 88/06/28 23:18:26 lwall Locked $
X?RCS: $Log:	stdchar.U,v $
X?RCS: Revision 2.0  88/06/28  23:18:26  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:stdchar: contains
X?MAKE:	-pick add $@ %*
X?S:stdchar:
X?S:	This variable conditionally defines STDCHAR to be the type of char
X?S:	used in stdio.h.  It has the values "unsigned char" or "char".
X?S:.
X?C:STDCHAR:
X?C:	This symbol is defined to be the type of char used in stdio.h.
X?C:	It has the values "unsigned char" or "char".
X?C:.
X?H:?%1:#define STDCHAR $stdchar	/**/
X?H:?%1:
X: see what type of char stdio uses.
Xecho " "
Xif $contains 'unsigned.*char.*_ptr;' /usr/include/stdio.h >/dev/null 2>&1 ; then
X    echo "Your stdio uses unsigned chars."
X    stdchar="unsigned char"
Xelse
X    echo "Your stdio uses signed chars."
X    stdchar="char"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/Oldconfig.U
sed >mcon/U/Oldconfig.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: Oldconfig.U,v 2.0 88/06/28 23:13:47 lwall Locked $
X?X: 
X?X: This unit tries to remember what we did last time we ran Configure, mostly
X?X: for the sake of setting defaults.
X?X: 
X?RCS: $Log:	Oldconfig.U,v $
X?RCS: Revision 2.0  88/06/28  23:13:47  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:Oldconfig: Instruct Myread
X?MAKE:	-pick add $@ %*
X: get old answers, if there is a config file out there
Xif test -f ../config.sh; then
X    echo " "
X    dflt=y
X    rp="I see a config.sh file.  Did Configure make it on THIS system? [$dflt]"
X?X: No $echo wanted here.
X    echo $n "$rp $c"
X    . myread
X    case "$ans" in
X    n*) echo "OK, I'll ignore it.";;
X    *)  echo "Fetching default answers from your old config.sh file..."
X	tmp="$n"
X	ans="$c"
X        . ../config.sh
X	n="$tmp"
X	c="$ans"
X	;;
X    esac
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_fchmod.U
sed >mcon/U/d_fchmod.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_fchmod.U,v 2.0 88/06/29 00:18:32 lwall Locked $
X?RCS: $Log:	d_fchmod.U,v $
X?RCS: Revision 2.0  88/06/29  00:18:32  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_fchmod: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_fchmod:
X?S:	This variable conditionally defines the FCHMOD symbol, which
X?S:	indicates to the C program that the fchmod() routine is available
X?S:	to change mode of opened files.
X?S:.
X?C:FCHMOD:
X?C:	This symbol, if defined, indicates that the fchmod routine is available
X?C:	to change mode of opened files.  If unavailable, use chmod().
X?C:.
X?H:?%1:#$d_fchmod	FCHMOD		/**/
X?H:?%1:
X: see if fchmod exists
Xecho " "
Xif $contains '^fchmod$' libc.list >/dev/null 2>&1; then
X    echo 'fchmod() found.'
X    d_fchmod="$define"
Xelse
X    echo 'fchmod() not found.'
X    d_fchmod="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/startsh.U
sed >mcon/U/startsh.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: startsh.U,v 2.0 88/06/28 23:18:22 lwall Locked $
X?RCS: $Log:	startsh.U,v $
X?RCS: Revision 2.0  88/06/28  23:18:22  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:startsh: sharpbang eunicefix
X?MAKE:	-pick add $@ %*
X?S:startsh:
X?S:	This variable contains the string to put on the front of a shell
X?S:	script to make sure (hopefully) that it runs with sh and not some
X?S:	other shell.
X?S:.
X: figure out how to guarantee sh startup
Xecho " "
Xecho "Checking out how to guarantee sh startup..."
Xstartsh=$sharpbang'/bin/sh'
Xecho "Let's see if '$startsh' works..."
Xcat >try <<EOSS
X$startsh
Xset abc
Xtest "$?abc" != 1
XEOSS
X
Xchmod +x try
X$eunicefix try
Xif try; then
X    echo "Yup, it does."
Xelse
X    echo "Nope.  You may have to fix up the shell scripts to make sure sh runs them."
Xfi
Xrm -f try today
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_bcopy.U
sed >mcon/U/d_bcopy.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_bcopy.U,v 2.0 88/06/28 23:14:16 lwall Locked $
X?RCS: $Log:	d_bcopy.U,v $
X?RCS: Revision 2.0  88/06/28  23:14:16  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_bcopy: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_bcopy:
X?S:	This variable conditionally defines the BCOPY symbol, which
X?S:	indicates to the C program that the bcopy() routine is available
X?S:	to copy blocks of memory.
X?S:.
X?C:BCOPY:
X?C:	This symbol, if defined, indicates that the bcopy routine is available
X?C:	to copy blocks of memory.  Otherwise you should probably use memcpy().
X?C:.
X?H:?%1:#$d_bcopy	BCOPY		/**/
X?H:?%1:
X: see if bcopy exists
Xecho " "
Xif $contains '^bcopy$' libc.list >/dev/null 2>&1; then
X    echo 'bcopy() found.'
X    d_bcopy="$define"
Xelse
X    echo 'bcopy() not found.'
X    d_bcopy="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_ioctl.U
sed >mcon/U/d_ioctl.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_ioctl.U,v 2.0 88/06/28 23:15:08 lwall Locked $
X?RCS: $Log:	d_ioctl.U,v $
X?RCS: Revision 2.0  88/06/28  23:15:08  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_ioctl: test
X?MAKE:	-pick add $@ %*
X?S:d_ioctl:
X?S:	This variable conditionally defines the IOCTL symbol, which
X?S:	indicates to the C program that sys/ioctl.h exists and should
X?S:	be included.
X?S:.
X?C:IOCTL:
X?C:	This symbol, if defined, indicates that sys/ioctl.h exists and should
X?C:	be included.
X?C:.
X?H:?%1:#$d_ioctl	IOCTL		/**/
X?H:?%1:
X: see if ioctl defs are in sgtty/termio or sys/ioctl
Xecho " "
Xif $test -r /usr/include/sys/ioctl.h ; then
X    d_ioctl="$define"
X    echo "sys/ioctl.h found."
Xelse
X    d_ioctl="$undef"
X    echo "sys/ioctl.h not found, assuming ioctl args are defined in sgtty.h."
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_symlink.U
sed >mcon/U/d_symlink.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_symlink.U,v 2.0 88/06/28 23:16:06 lwall Locked $
X?RCS: $Log:	d_symlink.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:06  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_symlink: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_symlink:
X?S:	This variable conditionally defines the SYMLINK symbol, which
X?S:	indicates to the C program that the symlink() routine is available
X?S:	to create symbolic links.
X?S:.
X?C:SYMLINK:
X?C:	This symbol, if defined, indicates that the symlink routine is available
X?C:	to create symbolic links.
X?C:.
X?H:?%1:#$d_symlink	SYMLINK		/**/
X?H:?%1:
X: see if symlink exists
Xecho " "
Xif $contains '^symlink$' libc.list >/dev/null 2>&1; then
X    echo 'symlink() found.'
X    d_symlink="$define"
Xelse
X    echo 'symlink() not found.'
X    d_symlink="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/libnm.U
sed >mcon/U/libnm.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: libnm.U,v 2.0 88/06/28 23:16:55 lwall Locked $
X?RCS: $Log:	libnm.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:55  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:libnm: test Loc
X?MAKE:	-pick add $@ %*
X?S:libnm
X?S:	This variable contains the argument to pass to the loader in order
X?S:	to get the new math library routines.  If there is no new math
X?S:	library, it is null.
X?S:.
X: see if we should include -lnm
Xecho " "
Xif $test -r /usr/lib/libnm.a || $test -r /usr/local/lib/libnm.a ; then
X    echo "New math library found."
X    libnm='-lnm'
Xelse
X    ans=`loc libnm.a x $libpth`
X    case "$ans" in
X    x)
X	echo "No nm library found--the normal math library will have to do."
X	libnm=''
X	;;
X    *)
X	echo "New math library found in $ans."
X	libnm="$ans"
X	;;
X    esac
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_crypt.U
sed >mcon/U/d_crypt.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_crypt.U,v 2.0 88/06/28 23:14:25 lwall Locked $
X?RCS: $Log:	d_crypt.U,v $
X?RCS: Revision 2.0  88/06/28  23:14:25  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_crypt: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_crypt:
X?S:	This variable conditionally defines the CRYPT symbol, which
X?S:	indicates to the C program that the crypt() routine is available
X?S:	to encrypt passwords and the like.
X?S:.
X?C:CRYPT:
X?C:	This symbol, if defined, indicates that the crypt routine is available
X?C:	to encrypt passwords and the like.
X?C:.
X?H:?%1:#$d_crypt	CRYPT		/**/
X?H:?%1:
X: see if crypt exists
Xecho " "
Xif $contains '^crypt$' libc.list >/dev/null 2>&1; then
X    echo 'crypt() found.'
X    d_crypt="$define"
Xelse
X    echo 'crypt() not found.'
X    d_crypt="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_strcspn.U
sed >mcon/U/d_strcspn.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_strcspn.U,v 2.0 88/06/29 00:20:02 lwall Locked $
X?RCS: $Log:	d_strcspn.U,v $
X?RCS: Revision 2.0  88/06/29  00:20:02  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_strcspn: contains Guess
X?MAKE:	-pick add $@ %*
X?S:d_strcspn:
X?S:	This variable conditionally defines the STRCSPN symbol, which
X?S:	indicates to the C program that the strcspn() routine is available
X?S:	to scan strings.
X?S:.
X?C:STRCSPN:
X?C:	This symbol, if defined, indicates that the strcspn routine is available
X?C:	to scan strings.
X?C:.
X?H:?%1:#$d_strcspn	STRCSPN		/**/
X?H:?%1:
X: see if strcspn exists
Xecho " "
Xif $contains '^strcspn$' libc.list >/dev/null 2>&1; then
X    echo 'strcspn() found.'
X    d_strcspn="$define"
Xelse
X    echo 'strcspn() not found.'
X    d_strcspn="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_ftime.U
sed >mcon/U/d_ftime.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_ftime.U,v 2.0 88/06/28 23:14:37 lwall Locked $
X?RCS: $Log:	d_ftime.U,v $
X?RCS: Revision 2.0  88/06/28  23:14:37  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_ftime: contains
X?MAKE:	-pick add $@ %*
X?S:d_ftime:
X?S:	This variable conditionally defines the FTIMER symbol, which indicates
X?S:	that the ftime() routine exists.  The ftime() routine is basically
X?S:	a sub-second accuracy clock.
X?S:.
X?C:FTIMER:
X?C:	This symbol, if defined, indicates that the ftime() routine exists.
X?C:.
X?H:?%1:#$d_ftime	FTIMER		/**/
X?H:?%1:
X: see if ftime exists
Xecho " "
Xif $contains '^ftime$' libc.list >/dev/null 2>&1; then
X    echo 'ftime() found.'
X    d_ftime="$define"
Xelse
X    echo 'ftime() not found--timing may be less accurate.'
X    d_ftime="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_vfork.U
sed >mcon/U/d_vfork.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_vfork.U,v 2.0 88/06/28 23:16:24 lwall Locked $
X?RCS: $Log:	d_vfork.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:24  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_vfork: contains libc
X?MAKE:	-pick add $@ %*
X?S:d_vfork:
X?S:	This variable conditionally defines the vfork symbol, which
X?S:	redefines vfork to fork if the vfork() routine doesn't exist.
X?S:.
X?C:vfork:
X?C:	This symbol, if defined, remaps the vfork routine to fork if the
X?C:	vfork() routine isn't supported here.
X?C:.
X?H:?%1:#$d_vfork	vfork fork	/**/
X?H:?%1:
X: see if there is a vfork
Xecho " "
Xif $contains '^vfork$' libc.list >/dev/null 2>&1 ; then
X    echo "vfork() found."
X    d_vfork="$undef"
Xelse
X    echo "No vfork() found--will use fork() instead."
X    d_vfork="$define"
Xfi
X
!STUFFY!FUNK!
echo Extracting pl/fullname.pl
sed >pl/fullname.pl <<'!STUFFY!FUNK!' -e 's/X//'
Xsub getfullname {
X    local($logname) = @_;
X    local($foo,$bar);
X    if ($ENV{'NAME'}) {
X	$ENV{'NAME'};
X    }
X    else {
X	open(PASSWD,'/etc/passwd') || die "Can't open /etc/passwd";
X	while (<PASSWD>) {
X	    /(\w+):/;
X	    last if $1 eq $logname;
X	}
X	close PASSWD;
X	local($login,$passwd,$uid,$gid,$gcos,$home,$shell) = split(/:/);
X	if (-f "$home/.fullname") {
X	    open(FN,"$home/.fullname");
X	    chop($foo = <FN>);
X	    close FN;
X	    $foo;
X	}
X	elsif ($nametype eq 'bsd') {
X	    $gcos =~ s/[,;].*//;
X	    if ($gcos =~ /&/) {		# oh crud
X		($foo,$bar) = ($logname =~ /(.)(.*)/);
X		$foo =~ y/a-z/A-Z/;
X		$gcos =~ s/&/$foo$bar/;
X	    }
X	    $gcos;
X	}
X	else {
X	    $gcos =~ s/[(].*//;
X	    $gcos =~ s/.*-//;
X	    $gcos;
X	}
X    }
X}
!STUFFY!FUNK!
echo Extracting mcon/U/Warn_v7EXT.U
sed >mcon/U/Warn_v7EXT.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: Warn_v7EXT.U,v 2.0 88/06/28 23:13:50 lwall Locked $
X?X: 
X?X: This unit issues warnings to V7 sites that they are living dangerously.
X?X: This unit needs to get mentioned in End.U to get included.
X?X: 
X?RCS: $Log:	Warn_v7EXT.U,v $
X?RCS: Revision 2.0  88/06/28  23:13:50  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:Warn_v7EXT: package Guess 
X?MAKE:	-pick add $@ %*
X: Warnings
Xif v7; then
X    cat <<'EOM'
X 
XNOTE: the V7 compiler may ignore some #undefs that $package uses.  If so,
Xyou may get messages about redefining EXT.  Some V7 compilers also have
Xdifficulties with #defines near buffer boundaries, so beware.  You may have
Xto play with the spacing in some .h files, believe it or not.
XEOM
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/d_fcntl.U
sed >mcon/U/d_fcntl.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_fcntl.U,v 2.0 88/06/28 23:14:29 lwall Locked $
X?RCS: $Log:	d_fcntl.U,v $
X?RCS: Revision 2.0  88/06/28  23:14:29  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_fcntl: test
X?MAKE:	-pick add $@ %*
X?S:d_fcntl:
X?S:	This variable conditionally defines the FCNTL symbol, and indicates
X?S:	whether a C program should include fcntl.h.
X?S:.
X?C:FCNTL:
X?C:	This symbol, if defined, indicates to the C program that it should
X?C:	include fcntl.h.
X?C:.
X?H:?%1:#$d_fcntl	FCNTL		/**/
X?H:?%1:
X: see if this is an fcntl system
Xecho " "
Xif $test -r /usr/include/fcntl.h ; then
X    d_fcntl="$define"
X    echo "fcntl.h found."
Xelse
X    d_fcntl="$undef"
X    echo "No fcntl.h found, but that's ok."
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/Config_sh.U
sed >mcon/U/Config_sh.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: Config_sh.U,v 2.0 88/06/28 23:12:46 lwall Locked $
X?X: 
X?X: This unit produces ends up producing the config.sh script, which contains
X?X: all the definitions figured out by Configure.  The add.Config_sh script
X?X: knows what variables need to be remembered.  It also adds the EOT.
X?X: 
X?RCS: $Log:	Config_sh.U,v $
X?RCS: Revision 2.0  88/06/28  23:12:46  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:Config_sh: spitshell startsh End
X?MAKE:	-pick add.Config_sh $@ %*
X: create config.sh file
Xecho " "
Xif test -d ../UU; then
X    cd ..
Xfi
Xecho "Creating config.sh..."
X$spitshell <<EOT >config.sh
X$startsh
X# config.sh
X# This file was produced by running the Configure script.
X
!STUFFY!FUNK!
echo Extracting pl/rangeargs.pl
sed >pl/rangeargs.pl <<'!STUFFY!FUNK!' -e 's/X//'
Xsub rangeargs {
X    local($result) = '';
X    local($min,$max,$_);
X    open(PL,"patchlevel.h") || die "Can't open patchlevel.h\n";
X    while (<PL>) {
X        $maxspec = $1 if /^#define\s+PATCHLEVEL\s+(\d+)/;
X    }
X    close PL;
X    die "Malformed patchlevel.h file.\n" if $maxspec eq '';
X    while ($#_ >= 0) {
X	$_ = shift(@_);
X	while (/^\s*\d/) {
X	    s/^\s*(\d+)//;
X	    $min = $1;
X	    if (s/^,//) {
X		$max = $min;
X	    }
X	    elsif (s/^-(\d*)//) {
X		$max = $1;
X		if ($max == 0 && $maxspec) {
X		    $max = $maxspec;
X		}
X		s/^[^,],?//;
X	    }
X	    else {
X		$max = $min;
X	    }
X	    for ($i = $min; $i <= $max; ++$i) {
X		$result .= $i . ' ';
X	    }
X	}
X    }
X    $result;
X}
!STUFFY!FUNK!
echo Extracting mcon/U/d_whoami.U
sed >mcon/U/d_whoami.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: d_whoami.U,v 2.0 88/06/28 23:16:33 lwall Locked $
X?RCS: $Log:	d_whoami.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:33  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:d_whoami: test
X?MAKE:	-pick add $@ %*
X?S:d_whoami:
X?S:	This variable conditionally defines the WHOAMI symbol, which
X?S:	indicates to the C program that it should include whoami.h.
X?S:.
X?C:WHOAMI:
X?C:	This symbol, if defined, indicates that the program may include
X?C:	whoami.h.
X?C:.
X?H:?%1:#$d_whoami	WHOAMI		/**/
X?H:?%1:
X: see if there is a whoami file
Xecho " "
Xif $test -r /usr/include/whoami.h ; then
X    d_whoami="$define"
X    echo "whoami.h found."
Xelse
X    d_whoami="$undef"
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/rootid.U
sed >mcon/U/rootid.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: rootid.U,v 2.0 88/06/28 23:18:15 lwall Locked $
X?RCS: $Log:	rootid.U,v $
X?RCS: Revision 2.0  88/06/28  23:18:15  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:rootid: sed
X?MAKE:	-pick add $@ %*
X?S:rootid:
X?S:	This variable contains the eventual value of the ROOTID symbol,
X?S:	which is the uid of root.
X?S:.
X?C:ROOTID:
X?C:	This symbol contains the uid of root, normally 0.
X?C:.
X?H:?%1:#define ROOTID $rootid		/**/
X?H:?%1:
X: determine root id
Xecho " "
Xrootid=`$sed -e "/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*"'$'"/\1/" -e "q" -e "}" -e "d" </etc/passwd`
Xcase "$rootid" in
X  '') rootid=0 ;;
X  *)  echo "Root uid = $rootid" ;;
Xesac
X
!STUFFY!FUNK!
echo Extracting mcon/U/Warn_v7ND.U
sed >mcon/U/Warn_v7ND.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: Warn_v7ND.U,v 2.0 88/06/28 23:13:54 lwall Locked $
X?X: 
X?X: This unit warns V7 sites that they may not have a non-blocking read.
X?X: This unit needs to be mentioned in End.U to get included.
X?X: 
X?RCS: $Log:	Warn_v7ND.U,v $
X?RCS: Revision 2.0  88/06/28  23:13:54  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:Warn_v7ND: package Guess 
X?MAKE:	-pick add $@ %*
X: Warnings
Xif v7; then
X    cat <<'EOM'
X
XNOTE: many V7 systems do not have a way to do a non-blocking read.  If you
Xdon't have any of FIONREAD, O_NDELAY, or rdchk(), the $package package
Xmay not work as well as it might.  It might not work at all.
XEOM
Xfi
X
!STUFFY!FUNK!
echo Extracting mcon/U/End.U
sed >mcon/U/End.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: End.U,v 2.0 88/06/28 23:12:54 lwall Locked $
X?X: 
X?X: This unit serves as the goal which forces make to choose all the units that
X?X: ask questions.  The $W on the ?MAKE: line is the list of all symbols wanted.
X?X: To force any unit to be included, copy this unit to your private U directory
X?X: and add the name of the unit desired to the ?MAKE: dependency line.
X?X: 
X?RCS: $Log:	End.U,v $
X?RCS: Revision 2.0  88/06/28  23:12:54  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:End: $W
X?MAKE:	-pick add $@ %*
Xecho " "
Xecho "End of configuration questions."
Xecho " "
X
!STUFFY!FUNK!
echo Extracting pl/package.pl
sed >pl/package.pl <<'!STUFFY!FUNK!' -e 's/X//'
Xsub readpackage {
X    if (! -f '.package') {
X        if (-f '../.package' || -f '../../.package') {
X            die "Run in top level directory only.\n";
X        }
X        else {
X            die "No .package file!  Run packinit.\n";
X        }
X    }
X    open(package,'.package');
X    while (<package>) {
X        next if /^:/;
X        next if /^#/;
X        if (($var,$val) = /^\s*(\w+)=(.*)/) {
X            $val = "\"$val\"" unless $val =~ /^['"]/;
X            eval "\$$var = $val;";
X        }
X    }
X    close package;
X}
X
!STUFFY!FUNK!
echo Extracting mcon/U/filexp.U
sed >mcon/U/filexp.U <<'!STUFFY!FUNK!' -e 's/X//'
X?RCS:$Header: filexp.U,v 2.0 88/06/28 23:16:40 lwall Locked $
X?RCS: $Log:	filexp.U,v $
X?RCS: Revision 2.0  88/06/28  23:16:40  lwall
X?RCS: Baseline.
X?RCS: 
X?MAKE:filexp: privlib
X?MAKE:	-pick add $@ %*
X?S:filexp:
X?S:	This symbol contains the full pathname of the filexp script, in case we
X?S:	are saving the script for posterity.
X?S:.
X: must not allow self reference
Xcase "$privlib" in
X  /*)
X    filexp=$privlib/filexp
X    ;;
X  *)
X    filexp=`pwd`/filexp
X    ;;
Xesac
X
!STUFFY!FUNK!
echo Extracting pl/comment.pl
sed >pl/comment.pl <<'!STUFFY!FUNK!' -e 's/X//'
Xsub rcscomment {
X    local($file) = @_;
X    local($comment) = '';
X    open(FILE,$file);
X    while (<FILE>) {
X	if (/^(.*)\$Log[:\$]/) {		# they know better than us (hopefully)
X	    $comment = $1;
X	    last;
X	}
X    }
X    close FILE;
X    unless ($comment) {
X	if ($file =~ /\.SH$|[Mm]akefile/) {
X	    $comment = '# ';
X	}
X	elsif ($file =~ /\.U$/) {
X	    $comment = '?RCS: ';
X	}
X	elsif ($file =~ /\.man$/) {
X	    $comment = "''' ";
X	}
X    }
X    $comment;
X}
X
!STUFFY!FUNK!
echo ""
echo "End of kit 6 (of 7)"
cat /dev/null >kit6isdone
run=''
config=''
for iskit in 1 2 3 4 5 6 7; do
    if test -f kit${iskit}isdone; then
	run="$run $iskit"
    else
	todo="$todo $iskit"
    fi
done
case $todo in
    '')
	echo "You have run all your kits.  Please read README and then type Configure."
	chmod 755 Configure
	;;
    *)  echo "You have run$run."
	echo "You still need to run$todo."
	;;
esac
: Someone might mail this, so...
exit

