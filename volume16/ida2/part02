Subject:  v16i074:  IDA Sendmail kit, Part02/08
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Lennart Lovstrand <lovstran@arisia.xerox.com>
Posting-number: Volume 16, Issue 74
Archive-name: ida2/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 8)."
# Contents:  ida/INSTALL ida/doc/announcement-1.0
#   ida/doc/announcement-1.2 ida/doc/dbm.1 ida/lib/Makefile.ida
#   ida/lib/domaintable ida/lib/pathtable ida/patches/MDBM.diffs
#   ida/patches/macro.c.diff ida/patches/readcf.c.diff
#   ida/patches/savemail.c.diff ida/patches/srvrsmtp.c.diff
#   ida/patches/usersmtp.c.diff ida/patches/util.c.diff
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f ida/INSTALL -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/INSTALL\"
else
echo shar: Extracting \"ida/INSTALL\" \(3437 characters\)
sed "s/^X//" >ida/INSTALL <<'END_OF_ida/INSTALL'
X#
X#  INSTALL -- The IDA Sendmail Enhancement Kit.
X#  Copyright (c) 1987, 1988 Lennart Lovstrand
X#  CIS Dept, Univ of Linkoping, Sweden
X#
X#  Use it, abuse it, but don't sell it.
X#
X
XINSTALLATION INSTRUCTIONS
X
XThese instructions will tell you step-by-step how to install and bring
Xthe Kit's sendmail system up.  The source code modifications are given
Xas context diffs, based on the BSD 4.3 release of sendmail version 5.59,
Xready to be installed using Larry Wall's eminent patch program.  You
Xwill also need the latest version of BIND (4.8) to compile and link
Xsendmail with MX support.  The option of using Maryland's mdbm library
Xis still open, although it has not been tested with this version of
Xsendmail.  Finally, in order to automatically produce routing tables,
Xyou will need Peter Honeyman's pathalias program.  Both of the latter
Xare available from your nearest USENET comp.sources.unix archive.
X
X [1] Unpack the Kit in the sendmail directory (preferably).  This should
X     give you a new ida subdirectory with all the Kit's files.  (Hmm,
X     perhaps you've already done this since you are reading this file.)
X
X [2] Goto sendmail/ida and check that you agree with the Makefile's
X     definitions.  If you change anything, do a "make configure" to
X     propagate those changes to the subdirectories' Makefiles.
X
X [3] Goto sendmail/ida/doc.  Do "make doc" to print out the accompanying
X     paper and "make man" to print the manual pages.  Do "make install"
X     to install the latter in your man directory.
X
X [4] Goto sendmail/ida/patches and do "make backup".  This will create a
X     backup copy of sendmail/src/*.[hc] and sendmail/doc/op.me in
X     Backup.tar.  You can restore them if necessary by performing "make
X     restore", still in the patches directory.
X
X [5] Do "make patch" to install the IDA enhancements.  You will need
X     patch(1), for this or else edit the files by hand.  Look out for
X     rejected patches; that will indicate that you aren't patching the
X     generic sendmail 5.59.
X
X [6] Goto sendmail/src and recompile sendmail.  You'll need to do a
X     "make depend" before you can do "make".  See that it still works.
X     Your old configuration file should still work unless you depend on
X     some obscure side effects.
X
X [7] Goto sendmail/ida/aux and do "make" to compile the auxiliary
X     programs.  Try them out, guided with the newly printed manual
X     pages.
X
X [8] Do "make install" to install the programs in BINDIR (/usr/local/bin
X     by default; but another choice would be /usr/lib/mail if you only
X     intend to use them with this kit).  It's also about time to
X     (manually) create a symbolic link from /usr/ucb/bsmtp to
X     /usr/lib/sendmail if you intend to receive batched SMTP mail.
X
X [9] Goto sendmail/ida/cf and inspect the supplied m4(1) configuration
X     definitions.  Send Sendmail.mc to your line printer and study it.
X     Do "make" to see how the sample configurations look expanded.
X
X[10] Goto sendmail/ida/lib and inspect the supplied sample data files.
X     Try applying the xalparse program on the xaliases file if you feel
X     like it.
X
X[11] Determine your site's routing capabilities and create your corre-
X     sponding data files in LIBDIR.  Go back to sendmail/ida/cf and
X     create your own m4(1) configuration file using the samples as
X     templates.  Produce an actual, personal sendmail.cf file.
X
X[12] Try out your new sendmail system.
X     Good Luck!
END_OF_ida/INSTALL
if test 3437 -ne `wc -c <ida/INSTALL`; then
    echo shar: \"ida/INSTALL\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/doc/announcement-1.0 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/doc/announcement-1.0\"
else
echo shar: Extracting \"ida/doc/announcement-1.0\" \(2761 characters\)
sed "s/^X//" >ida/doc/announcement-1.0 <<'END_OF_ida/doc/announcement-1.0'
XPath: liuida!lel
XFrom: lel@ida.liu.se (Lennart Lovstrand)
XNewsgroups: comp.mail.uucp,comp.mail.misc
XSubject: The IDA Sendmail Enhancement Kit
XMessage-ID: <579@prefix.liu.se>
XDate: 10 Jun 87 16:55:29 GMT
XSender: lenlo@prefix.liu.se
XLines: 54
XXref: liuida comp.mail.uucp:464 comp.mail.misc:268
X
XThe IDA Sendmail Enhancement Kit was finally sent off to Rich Salz of
Xcomp.sources.unix today.  He still has problems receiving sources for
Xthe newsgroup after his relocation, but I'm afraid I couldn't wait any
Xlonger.  At the end of this week, I'm off for a new job in another
Xcountry.  I hope it won't take too long for the Kit to appear in the
Xnewsgroup.  For those of you who have ARPANET access and don't want to
Xwait, thanks to Dorab Patel of UCLA there is a copy on the host
Xulysses.cs.ucla.edu [128.97.2.19] in the file ~ftp/pub/ida.tar.Z
Xavailable for anonymous FTP.  If anyone is really desperate, I can
Xprobably send copy by mail too (330 Kbyte in 7 shars).  But you will
Xhave to react quickly then...
X
XThe Kit includes a set of source code modifications to the BSD 4.3
Xsendmail program (version 5.11).  The changes will enable sendmail to
Xhave direct access to dbm(3) files, separate envelope/header rewriting
Xrulesets, and multi-token class matches among other things.
X
XAs a separate part of the Kit is the IDA Sendmail Master Configuration
Xfile and a sample setup used at the CIS Dept, U of Linkoping.  The
Xconfiguration file together with the supplied data files and utility
Xprograms, implement such nice features as pathalias based systems
Xrouting within sendmail, fully !-/@-translating rulesets, and generic
Xlocal user addresses.
X
XThe new sendmail functions are breifly listed below and further
Xdescribed in the accompanying paper, which in addition discusses
Xelectronic mail addressing in general and hybrid addresses in
Xparticular.
X
X   Nameserver Default Argument
X   Direct Access to Dbm(3) Files
X   Batched SMTP Support
X   Separate Envelope/Header Rewriting Rulesets
X   Separate Local UUCP Host Name
X   Return Path for UUCP Mailers
X   UUCP Header Address Relativization
X   Support for Multi-Token Matches
X   Support for Embedded Subruleset Calls
X   Elaborate Matching Algorithm for Unknown Local Recipients
X   Support for Maryland's Mdbm Package
X   Improved Test Mode Output
X   Better To: and Cc: Headers of Returned Messages
X   Queue Bug Fixed
X   Shared Input SMTP Bug Tentatively Fixed
X   Optional BSD 2.9 and 4.2 Compatibility Code
X & Miscellaneous Changes
X
XEnjoy!
X--Lennart
X(soon at Xerox EuroPARC, Cambridge, U.K.)
X--
XDept of Computer and Information Science, University of Linkoping, Sweden
XInternet: Lennart.Lovstrand@IDA.LiU.SE       EAN/X.400: lel@ida.liu.sunet
XUUCP: {mcvax,munnari,seismo}!enea!liuida!lel    EARN/BITNET: LEL@SELIUI51
X
X
END_OF_ida/doc/announcement-1.0
if test 2761 -ne `wc -c <ida/doc/announcement-1.0`; then
    echo shar: \"ida/doc/announcement-1.0\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/doc/announcement-1.2 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/doc/announcement-1.2\"
else
echo shar: Extracting \"ida/doc/announcement-1.2\" \(2830 characters\)
sed "s/^X//" >ida/doc/announcement-1.2 <<'END_OF_ida/doc/announcement-1.2'
XPath: liuida!lel
XFrom: Lennart_Lovstrand.EuroPARC@Xerox.COM
XNewsgroups: comp.mail.sendmail
XSubject: Re: sendmail with MX and IDA-enhancements
XMessage-Id: <884@majestix.liu.se>
XDate: 26 Aug 88 20:53:47 GMT
XReferences: <298@pvab.UUCP> <450@comdesign.CDI.COM>
XOrganization: Rank Xerox EuroPARC, Cambridge, England
XSender: lenlo@majestix.liu.se
XLines: 59
X
XIn article <450@comdesign.CDI.COM> pst@comdesign.CDI.COM (Paul Traina) writes:
X> From article <298@pvab.UUCP>, by robert@pvab.UUCP (Robert Claeson):
X> | In article <553@laura.UUCP>, ap@laura.UUCP (Axel Pawlik) writes:
X> |>   has anybody out there already merged the MX-sendmail
X> |> with Lennard Loevstrand's IDA-enhancements?
X> | And added Sun's enhancements (being able to query YP for known hosts
X> | and the like)?
X> Ditto please, I'm torn between runing old 4.12 and hacking 5.59 to have
X> the YP support.
X
XGentlemen and -women, it does indeed exist!
X
XPlease welcome the IDA Sendmail Enhancement Kit v1.2 for sendmail 5.59
Xwith MX and Yellow Pages support.  It has tonight been made available on
XArisia.Xerox.COM in ~ftp/pub1/ida.tar.Z (available via anonymous ftp)
Xand will be sent to comp.sources.unix shortly.
X
XThe major change is that of Yellow Pages support, but others include dbm
Xfile update locking, setting classes from programs (eg. FU|uuname),
Xdelayed macro evaluation (from the net), rfc822 quoted macro expansion,
Xaddress rewriting loop detection and an extra compile-time frozen file
Xcheck; the latter ones contributed by Guy Middleton @ Waterloo.
X
XThere has also been some bug fixes and slight improvements on the IDA
Xconfiguration file and associated files.
X
XAll the old enhancements still apply, with the exception of BSD2.9 and
X4.2 support, although it will compile and run under SunOS 3.x given that
Xyou have bind 4.8 as well.
X
XFor those of you who haven't heard of this before, the IDA Enhancement
XKit is a set of changes to the standard Berkeley mailer which implements
Xthe following features:
X
X  o  Nameserver Default Argument
X  o  Direct Access to Dbm(3) Files
X  o  Batched SMTP Support
X  o  Separate Envelope/Header Rewriting Rulesets
X  o  Separate Local UUCP Host Name
X  o  Return Path for UUCP Mailers
X  o  UUCP Header Address Relativization
X  o  Support for Multi-Token Matches
X  o  Support for Embedded Subruleset Calls
X  o  Elaborate Matching Algorithm for Unknown Local Recipients
X  o  Support for Maryland's Mdbm Package
X  o  Improved Test Mode Output
X  o  Better To: and Cc: Headers of Returned Messages
X
XIt also comes with the IDA Configuration Kit, which has pathalias based
Xsystems routing within sendmail, fully !-/@-translating rulesets,
Xgeneric localuser addresses, and more.
X
XEnjoy!
X
X--Lennart Lovstrand
X  Rank Xerox EuroPARC, Cambridge, England
X
X  DARPA Internet: Lovstrand.EuroPARC@Xerox.COM
X  Xerox Internet: Lovstrand:EuroPARC:RX
END_OF_ida/doc/announcement-1.2
if test 2830 -ne `wc -c <ida/doc/announcement-1.2`; then
    echo shar: \"ida/doc/announcement-1.2\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/doc/dbm.1 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/doc/dbm.1\"
else
echo shar: Extracting \"ida/doc/dbm.1\" \(4959 characters\)
sed "s/^X//" >ida/doc/dbm.1 <<'END_OF_ida/doc/dbm.1'
X.TH DBM 1 "24 April 1987"				\" -*- nroff -*-
X.SH NAME
Xdbm \- general
X.IR dbm (3)
Xdatabase management tool
X.SH SYNOPSIS
X.BR dbm
X.RB [\| \-AILNRSU \|]
X.RB [\| \-d
X.IR dbm_file \|]
X.RB [\| \-m
X.IR mode \|]
X.RB [\| \-o 
X.IR output_file \|]
X.I command
X.RI [\| args\|.\|.\|. \|]
X.SH DESCRIPTION
X.I Dbm
Xis used to manage
X.IR dbm (3)
Xtype databases.  Its function is controlled by the dbm
X.I command
Xgiven on the command line, possibly with additional arguments.  Its
Xtypical usage is to load a
X.I dbm
Xdatabase from a input file or to dump it to a readable format.  It may
Xalso be used to probe for selected keys or add specific key/value pairs. 
XIn addition,
X.I dbm
Xprovides parsing routines for an extended textual format, suitable for
Xbuilding tables or various kinds.  The format is further described in
Xthe section about the
X.B parse
Xcommand below. 
X.SH OPTIONS
X.TP
X.B \-A
XAppend mode, don't automatically clear the database on the
X.BR load
Xand
X.B make
Xoperations. 
X.TP
X.B \-I
XInsert mode; will supply the \s-1DBM_INSERT\s+1 flag to all
X.I dbm_store
Xoperations.  This means that if two entries with equal keys are given,
Xonly the first will actually be entered to the database (default) and no
Xwarning will be given. 
X.TP
X.B \-L
XLowercase mode.  Change all keys to lowercase before reading from or writing
Xto the database.
X.TP
X.B \-R
XReplace mode; will supply the \s-1DBM_REPLACE\s+1 flag to all
X.I dbm_store
Xoperations.  This means that if two entries with equal keys are given,
Xonly the last will actually be entered to the database and no warning
Xmessages are given. 
X.TP
X.B \-S
XAdd a
X.B @@@
Xsenteniel after the last entry has been written to the database. 
X.TP
X.B \-U
XUppercase mode.  Turn all keys to uppercase before reading from or
Xwriting to the database.
X.TP
X.BI \-d " dbm_file"
XPerform all operations on the named database file.  If no
X.B \-d
Xoption is given, the last argument after the
X.I command
Xwill be used as the
X.IR dbm_file. 
X.TP
X.BI \-m " mode"
XUse the given
X.I mode
Xwhen creating new databases. 
X.TP
X.BI \-o " output_file"
XSend all output from the
X.B dump
Xand
X.B parse
Xoperations to the named output file instead of stdout. 
X.SH COMMANDS
X.PP
X.TP
X.B clear
XCreats an empty
X.I dbm
Xdatabase, either by clearing an old one or by creating a new.
X.TP
X.BR delete " key \fR[\|.\|.\|.\|]\fP"
XRemoves entries with the specified keys from the database.
X.TP
X.B dump
XDumps the
X.I dbm
Xdatabase to stdout (or to
X.IR output_file ,
Xif the 
X.B \-o
Xoption is used).  The output will consist of one entry per line with a
Xtab between each key and value. 
X.TP
X.BI fetch " key \fR[\|.\|.\|.\|]\fP"
X.B Fetch
Xwill search for the
X.I key
Xin the database and print both key and value in
X.B dump
Xformat if found on the standard output.  Non-existing
X.IR keys
Xwill be signalled by a [\s-1NOT_FOUND\s+1] message. 
X.TP
X.BR load " [\|\fIfile\fP\|.\|.\|.\|]"
XLoad the database with entries from the specified
X.IR files .
XIf no
X.I files
Xare given or if a file is specified as `-', the database will be loaded
Xfrom standard input.  Each line of the file should have a key and value
Xseparated by a tab.  (Incidentally, this is the same format as
X.B dump
Xand
X.IR pathalias (1)
Xwill produce.)  The database is first cleared unless the append
X(\fB\-A\fP) switch has been given. 
X.TP
X.BR make " [\|\fIfile\fP\|.\|.\|.\|]"
X.B Make
Xcombines the operations of
X.B parse
Xand
X.BR load
X(q.v.), by storing each record after it has been parsed. 
X.TP
X.BR parse " [\|\fIfile\fP\|.\|.\|.\|]"
XThis command will parse the contents of the specified
X.IR files
X(or stdin if no
X.I files
Xare given or when a file is `-'), according to the following syntax:
X.in +\n()Iu
Xvalue key key .\|.\|. 
X.in -\n()Iu
XWhitespace delimit tokens and sharp signs (\fB#\fP) anywhere on a line
Xbegins comments unless any of them are quoted by a backslash (\fB\\\fP)
Xor put inside double quotes (\fB"\fP\|.\|.\|.\|\fB"\fP) or angle
Xbrackets (\fB<\fP\|.\|.\|.\|\fB>\fP).  Lines beginning with whitespace
Xare considered to be continuations of the previous line.
X.TP
X.BI store " key value \fR[\|\fI key value \fR\|.\|.\|.\|]\fI"
XStore one or more key/value pairs explicitly mentioned on the command
Xline.
X.SH EXAMPLES
X.nf
X.ta \w'dbm parse xfile | dbm -AI load foo'u+6n
Xdbm -d foo clear	\fIcreate the database foo\fP
Xcat infile | dbm load foo	\fIload it from the infile\fP
Xdbm parse xfile | dbm -AI load foo	\fIadd keys from the xfile...\fP
X.I "(or, shorter)	\fI...not already present...\fP"
Xdbm -I make xfile foo	\fI...in the database\fP
Xdbm fetch keya keyb foo	\fIfetch values for the keys\fP
Xdbm -R store keyc valuec foo	\fIoverwrite previous value for keyc\fP
X.fi
X.SH AUTHOR
X.nf
XLennart Lovstrand <lel@ida.liu.se>
XCIS Dept, Univ of Linkoping, Sweden
X.fi
X.SH "SEE ALSO"
X.IR pathalias (1),
X.IR dbm (3),
X.IR ndbm (3)
X.SH BUGS
XShould probably remove the senteniel when opening the database for write
Xaccess (provided that the
X.B \-S
Xflag has been given).
X.br
XRequires
X.IR ndbm (3)
Xor
X.IR mdbm (3)
Xsupport for no real reason. 
END_OF_ida/doc/dbm.1
if test 4959 -ne `wc -c <ida/doc/dbm.1`; then
    echo shar: \"ida/doc/dbm.1\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/lib/Makefile.ida -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/lib/Makefile.ida\"
else
echo shar: Extracting \"ida/lib/Makefile.ida\" \(2514 characters\)
sed "s/^X//" >ida/lib/Makefile.ida <<'END_OF_ida/lib/Makefile.ida'
X#
X#  MAKEFILE -- Library Files.
X#  Copyright (c) 1987, 1988 Lennart Lovstrand
X#  CIS Dept, Univ of Linkoping, Sweden
X#
X#  Use it, abuse it, but don't sell it.
X#
X#  Special IDA version with DECnet.
X
X
XLOCALDOMAINS=	liu.se ida.liu.se sunet.se UUCP	# only if domaintable is used
XPATHFLAGS=	-C25 -i -lIDA-TCP-NET
XSENDMAIL=	/usr/lib/sendmail
XSKILL=		/usr/local/bin/skill		# not required
XTABLES=		$(YP)domaintable$(DBMDIREXT) $(YP)generics$(DBMDIREXT) \
X		$(YP)pathtable$(DBMDIREXT) $(YP)aliases$(DBMDIREXT) \
X		mailertable$(DBMDIREXT) uucp/xtable$(DBMDIREXT) \
X		decnet/nodes decnet/xtable$(DBMDIREXT) uucp/xtable$(DBMDIREXT)
XUUCPNODES=	/usr/lib/uucp/L.sys
X# Prefix for YP dbm files; remove this if you won't be using YP databases
XYP=		#/etc/yp/ida/mail.
X
X# Where to find a fresh list of DECnet nodes {in TOPS-20 NCP format}
XNODE_DATA=	/usr/lisbet/ps/system/node-data.cmd
X
X
X#  The following definitions are inserted by ../Makefile
X#  Change them there--not here!
XDBMDIREXT=	.dir
XDBMPAGEXT=	.pag
X
X
X#  Update all dbm tables
Xall:	$(TABLES)
X
Xaliases generics:	xaliases
X	xalparse xaliases aliases generics
X
X$(YP)aliases$(DBMDIREXT):	aliases newaliases.cf $(YP)domaintable$(DBMDIREXT)
X	$(SENDMAIL) -Cnewaliases.cf -bi
X	if [ -n "$(YP)" ]; then \
X		mv aliases.dir $(YP)aliases.dir; \
X		mv aliases.pag $(YP)aliases.pag; \
X	fi
X
X$(YP)generics$(DBMDIREXT):	generics
X	dbm -L make generics $(YP)generics
X
X# Note: Local fix here to make all DECnet nodes belong in .SUNET.SE
X$(YP)domaintable$(DBMDIREXT):	domaintable decnet/nodes
X	(dbm parse domaintable; \
X	 awk '{printf "%s.sunet.se\t%s.sunet.se\n", $$1, $$1}' decnet/nodes) |\
X		mkdomext $(LOCALDOMAINS) | dbm -IL load $(YP)domaintable
X
X$(YP)pathtable$(DBMDIREXT):	pathtable
X	pathalias $(PATHFLAGS) pathtable | dbm load $(YP)pathtable
X
Xmailertable$(DBMDIREXT):	mailertable
X	dbm -L make mailertable mailertable
X
Xuucp/xtable$(DBMDIREXT):	uucp/xtable $(UUCPNODES)
X	(dbm parse uucp/xtable; \
X	 awk '{printf "%s.UUCP\t%s\n", $$1, $$1}' $(UUCPNODES)) | \
X	 dbm -IL load uucp/xtable
X
X# Note: Local fix here for making all DECnet nodes belong in .SUNET.SE
Xdecnet/xtable$(DBMDIREXT):	decnet/xtable decnet/nodes
X	(dbm parse decnet/xtable; \
X	 awk '{printf "%s.sunet.se\t%s\n", $$1, $$1}' decnet/nodes) | \
X		dbm -IL load decnet/xtable
X
Xdecnet/nodes:		$(NODE_DATA)
X	cp decnet/nodes decnet/nodes.old
X	scanf -i " set node %*s name %s" $(NODE_DATA) >$@
X
Xstop:
X	-$(SKILL) sendmail
X
Xrestart:	stop
X	$(SENDMAIL) -bd -q30m
X
Xclean:
X	-rm -f \#* *~ *.dir *.pag *.map *.dat */*.dir */*.pag */*.map */*.dat
END_OF_ida/lib/Makefile.ida
if test 2514 -ne `wc -c <ida/lib/Makefile.ida`; then
    echo shar: \"ida/lib/Makefile.ida\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/lib/domaintable -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/lib/domaintable\"
else
echo shar: Extracting \"ida/lib/domaintable\" \(4149 characters\)
sed "s/^X//" >ida/lib/domaintable <<'END_OF_ida/lib/domaintable'
X#
X#	Primitive name server table -- version 3.0 of 20-Apr-87
X#
X#	Format is <official-name> <nickname-1> .. <nickname-n>,
X#	where the <nicnames> are optional.  Comments start with
X#	a sharp sign (#).  A line beginning with whitespace is
X#	assumed to be a continuation of the previous line.
X#
X#	The order in which the names are givin is significant;
X#	early entries will hide later entries with coinciding
X#	nicknames.
X#
X
X#	Misc known nodes
X#
X		# Direct UUCP nodes
Xenea.se		enea	enea.UUCP
Xerilin.UUCP	erilin
Xerix.ericsson.se erix	erix.UUCP
Xliutde.UUCP	liutde
Xrainier.UUCP	rainier
X		# UUCP Major Relays & Backbones
Xcbosgd.UUCP	cbosgd
Xcernvax.UUCP	cernvax
Xdecvax.UUCP	decvax
Xdiku.UUCP	diku
Xenea.se		enea	enea.UUCP
Xi2unix.UUCP	i2unix
Xinria.UUCP	inria
Xmcvax.cwi.nl	mcvax	mcvax.UUCP
Xpenet.UUCP	penet
Xprlb2.UUCP	prlb2
Xukc.UUCP	ukc
Xunido.UUCP	unido
Xvmars.UUCP	vmars
X
X#
X#	These are just here to help people through the ARPAnet name change
X#
X
Xseismo.CSS.GOV		SEISMO.ARPA
XHARVARD.HARVARD.EDU	HARVARD.ARPA
Xucbvax.BERKELEY.EDU	UCB-VAX.ARPA
XWISCVM.WISC.EDU		WISCVM.ARPA
XAI.AI.MIT.EDU		MIT-AI.ARPA
XMC.LCS.MIT.EDU		MIT-MC.ARPA
XKL.SRI.COM		SRI-KL.ARPA
X# NIC.SRI.COM		SRI-NIC.ARPA		# Not yet
XSAIL.STANFORD.EDU	SU-AI.ARPA
XSCORE.STANFORD.EDU	SU-SCORE.ARPA
XA.CS.CMU.EDU		CMU-CS-A.ARPA
XC.CS.CMU.EDU		CMU-CS-C.ARPA
XR20.UTEXAS.EDU		UTEXAS-20.ARPA
XSALLY.UTEXAS.EDU	UT-SALLY.ARPA
XRELAY.CS.NET		CSNET-RELAY.ARPA
XSUMEX-AIM.STANFORD.EDU	SUMEX-AIM.ARPA
XCSLI.STANFORD.EDU	CSLI.ARPA
XXerox.COM		Xerox.ARPA
X
X#
X#	Nodes within LiU.SE -- The University of Linkoping, Sweden
X#
X			# The IDA domain -- Dept of Comp and Info Science
XIDA.LiU.SE		liuida.UUCP	liuida.liu.se	liuida.ida.liu.se
X			# DECsystems
XALADIN.LiU.SE		ALADIN.SUNET.SE
XCLOVER.LiU.SE		CLOVER.SUNET.SE
XDAISY.LiU.SE		DAISY.SUNET.SE
XELINOR.LiU.SE		ELINOR.SUNET.SE
XHAZEL.LiU.SE		HAZEL.SUNET.SE			HAZEL.IDA.LiU.SE
XJINJIN.LiU.SE		JINJIN.SUNET.SE
XLINA.LiU.SE		LINA.SUNET.SE
XLINNEA.LiU.SE		LINNEA.SUNET.SE
XLINUS.LiU.SE		LINUSE.SUNET.SE			LINUS.IDA.LiU.SE
XLISBET.LiU.SE		LISBET.SUNET.SE			LISBET.IDA.LiU.SE
XLUDVIG.LiU.SE		LUDVIG.SUNET.SE
XMINMIN.LiU.SE		MINMIN.SUNET.SE
XP13L00.LiU.SE		P13L00.SUNET.SE
XTURTLE.LiU.SE		TURTLE.SUNET.SE
XVIKTOR.LiU.SE		VIKTOR.SUNET.SE
XWEIWEI.LiU.SE		WEIWEI.SUNET.SE
X			# Unix systems
Xasterix.liu.se		asterix.liu.uucp		asterix.ida.liu.se
Xcrabbofix.liu.se					crabbofix.ida.liu.se
Xlillefix.liu.se						lillefix.ida.liu.se
Xmajestix.liu.se						majestix.ida.liu.se
Xmiraculix.liu.se					miraculix.ida.liu.se
Xobelix.liu.se		obelix.UUCP obelix.liu.uucp	obelix.ida.liu.se
Xportofix.liu.se						portofix.ida.liu.se
Xprefix.liu.se						prefix.ida.liu.se
Xsenilix.liu.se						senilix.ida.liu.se
Xsmidefix.liu.se						smidefix.ida.liu.se
Xtragicomix.liu.se					tragicomix.ida.liu.se
X
X#	Nodes within QZ.SE -- The Stockholm University Computing Center
X#
XFREJA.QZ.SE		FREJA.SUNET.SE
X
X#	Nodes within UU.SE -- University of Uppsala, Sweden
X#
XAIDA.UU.SE		AIDA.SUNET.SE			AIDA.UPPSALA.SE
XBMC1.UU.SE		BMC1.SUNET.SE
XCARMEN.UU.SE		CARMEN.SUNET.SE			CARMEN.UPPSALA.SE
XCARTUS.UU.SE		CARTUS.SUNET.SE
XCELL.UU.SE		CELL.SUNET.SE
XESCIL.UU.SE		ESCIL.SUNET.SE
Xemil.uu.se
XEVA.UU.SE		EVA.SUNET.SE
XFARFAR.UU.SE		FARFAR.SUNET.SE
XGRAPH.UU.SE		GRAPH.SUNET.SE
XGWAX1.UU.SE		GWAX1.SUNET.SE
XGWAX2.UU.SE		GWAX2.SUNET.SE
XIMMUNA.UU.SE		IMMUNA.SUNET.SE
XIMUNIS.UU.SE		IMUNIS.SUNET.SE
XKEMIST.UU.SE		KEMIST.SUNET.SE
Xkuling.uu.se		kuling.UUCP			kuling.uppsala.se
XKVAX1.UU.SE		KVAX1.SUNET.SE
XKVAX2.UU.SE		KVAX2.SUNET.SE
XLABAN.UU.SE		LABAN.SUNET.SE
XLAPSE.UU.SE		LAPSE.SUNET.SE
XMAJA.UU.SE		MAJA.SUNET.SE
XMALIN.UU.SE		MALIN.SUNET.SE
XMAX.UU.SE		MAX.SUNET.SE			MAX.UPPSALA.SE
XMINC.UU.SE		MINC.SUNET.SE
XNIMBUS.UU.SE		NIMBUS.SUNET.SE
Xnumax.uu.se
XPAX.UU.SE		PAX.SUNET.SE
XPELLE.UU.SE		PELLE.SUNET.SE
XPICTOR.UU.SE		PICTOR.SUNET.SE
XRTR18A.UU.SE		RTR18A.SUNET.SE
XSIGURD.UU.SE		SIGURD.SUNET.SE
XSILVER.UU.SE		SILVER.SUNET.SE
XTEKLA.UU.SE		TEKLA.SUNET.SE
XTLU.UU.SE		TLU.SUNET.SE
XXRAY.UU.SE		XRAY.SUNET.SE
X
X#	Nodes within LU.SE -- Universtiy of Lund, Sweden
X#
XAGATON.LU.SE		AGATON.SUNET.SE
XPANDOR.LU.SE		PANDOR.SUNET.SE
X
X#	Nodes within SUNET.SE -- The Swedish University Network (DECnet)
X#	are automatically inserted here.
X
XATHENA.SUNET.SE		# This one is not in the DECnet tables
END_OF_ida/lib/domaintable
if test 4149 -ne `wc -c <ida/lib/domaintable`; then
    echo shar: \"ida/lib/domaintable\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/lib/pathtable -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/lib/pathtable\"
else
echo shar: Extracting \"ida/lib/pathtable\" \(3889 characters\)
sed "s/^X//" >ida/lib/pathtable <<'END_OF_ida/lib/pathtable'
X#########################################################################
X###  Pathalias Route Database	##############################  v3.0  ###
X#########################################################################
X# Edited by Lennart.Lovstrand@IDA.LiU.SE Fri Apr 17 19:37:39 MET DST 1987
X
X###				#########################################
X#	Special Links							#
X###				#########################################
X
Xasterix.liu.se		obelix.liu.se(DIRECT)		# UUCP/TTY
Xmajestix.liu.se		alp.UUCP(DAILY),		# UUCP/modem-1200
X			enea.se(DEMAND),		# UUCP/modem-2400
X			erilin.UUCP(DIRECT),		# UUCP/modem-2400
X			erix.UUCP(DEMAND),		# UUCP/modem-2400
X			kuling.uu.se(HOURLY),		# UUCP/modem-2400?
X			liutde.UUCP(DAILY),		# UUCP/modem-1200
X			prosys.UUCP(HOURLY),		# UUCP/modem-2400
X			rainier.UUCP(HOURLY),		# UUCP/modem-2400?
X			ida.liu.se(0),			# via aliases dbm
X			IDA-TCP-NET			# SMTP/TCP-IP
Xrainier.UUCP		carola.UUCP, adams.UUCP		# SMTP/TCP-IP
Xaida.uu.se		carmen.uu.se			# Cafard/TTY
Xathena.sunet.se		aida.uu.se			# Cafard/UPNET
X
X
X###				#########################################
X#	Physical Networks						#
X###				#########################################
X
XIDA-TCP-NET = {
X	asterix.liu.se,		# Gould
X	crabbofix.liu.se,	# Sun-3/75M
X	lillefix.liu.se,	# Sun-3/52
X	lisbet.liu.se,		# DEC-2060
X	majestix.liu.se,	# Sun-3/160 FS
X	miraculix.liu.se,	# Sun-3/75C
X	portofix.liu.se,	# Sun-3/75M
X	prefix.liu.se,		# Sun-3/75M
X	senilix.liu.se,		# Sun-3/75M
X	smidefix.liu.se,	# Sun-3/75M
X	tragicomix.liu.se}	# Sun-3/75M
X
X##  The SUNET-xx definitions includes only nodes that know about DECnet
X##  area addressing.
X
XSUNET = {
X	.sunet.se, SUNET-08, SUNET-13, SUNET-18, SUNET-46}
X
XSUNET-08 = {
X	freja.qz.se, vera.sunet.se}
X
XSUNET-13 = {
X	aladin.liu.se, clover.liu.se, daisy.liu.se, elinor.liu.se,
X	hazel.liu.se, jinjin.liu.se, lina.liu.se, linus.liu.se,
X	linnea.liu.se, lisbet.liu.se, liuida.sunet.se, ludvig.liu.se,
X	minmin.liu.se, p13l00.liu.se, turtle.liu.se, viktor.liu.se,
X	weiwei.liu.se}
X
XSUNET-18 = {
X	malin.uu.se, tekla.uu.se, cartus.uu.se, pelle.uu.se, pictor.uu.se,
X	tlu.uu.se, max.uu.se, kvax1.uu.se, kvax2.uu.se, sigurd.uu.se,
X	escil.uu.se, gwax1.uu.se, gwax2.uu.se, kemist.uu.se, cell.uu.se,
X	minc.uu.se, silver.uu.se, lapse.uu.se, maja.uu.se, rtr18a.uu.se,
X	imunis.uu.se, xray.uu.se, graph.uu.se, immuna.uu.se, bmc1.uu.se,
X	farfar.uu.se, eva.uu.se, nimbus.uu.se, laban.uu.se, pax.uu.se}
X
XSUNET-46 = {
X	agaton.lu.se, pandor.lu.se}
X
X##  DECNET-xx defintions include both area-addressing nodes (which
X##  may serve as gateways) and non-area-addressing nodes.
X
XDECNET-08 = {
X	athena.sunet.se, freja.qz.se, vera.sunet.se}
X
X
X###				#########################################
X#	Domain Gateways							#
X###				#########################################
X
Xenea.se		.ARPA, .BITNET, .CSNET, .DEC, .JUNET, .MAILNET, .UUCP,
X		.com, .edu, .gov, .mil, .net, .org,
X		.au, .ca, .de, .fi, .fr, .gb, .il, .jp, .kr, .nl, .no, .nz,
X		.se, .uk, .us,
X		.cdn, .oz
Xerix.UUCP	.ericsson, .ericsson.se
Xlisbet.liu.se	.sunet.se
Xliuida.sunet.se	.psi
Xmajestix.liu.se	.liu, .liu.se, .ida, .ida.liu, .ida.liu.se,
X		.qz, .qz.se, .uu, .uu.se, .uppsala, .uppsala.se
Xnta-vax.ARPA	.Uninett
X
X
X###				#########################################
X#	Implicit links							#
X###				#########################################
X
Xenea.se			calgary.UUCP, relay.cs.net, nta-vax.ARPA,
X			uoregon.UUCP, ohio-state.arpa
Xlisbet.liu.se		freja.qz.se
X
X###				#########################################
X#	Other explict links						#
X###				#########################################
X
Xkuling.uu.se		emil.uu.se
Xrelay.cs.net		csri.toronto.edu, isc.intel.com
Xuoregon.UUCP		drizzle.UUCP
Xcalgary.UUCP		vuw90x.UUCP
Xohio-state.arpa		OSU-20.OHIO-STATE.EDU
X
X###				#########################################
X#	Useful synonyms							#
X###				#########################################
X
Xida.liu.se	= liuida.UUCP
Xobelix.liu.se	= obelix.UUCP
X.ericsson	= .erix
X.ericsson.se	= .erix.se
END_OF_ida/lib/pathtable
if test 3889 -ne `wc -c <ida/lib/pathtable`; then
    echo shar: \"ida/lib/pathtable\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/MDBM.diffs -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/MDBM.diffs\"
else
echo shar: Extracting \"ida/patches/MDBM.diffs\" \(2627 characters\)
sed "s/^X//" >ida/patches/MDBM.diffs <<'END_OF_ida/patches/MDBM.diffs'
X*** alias.c.old	Fri Aug 26 18:30:22 1988
X--- alias.c	Fri Aug 26 19:14:16 1988
X***************
X*** 578,583 ****
X--- 578,586 ----
X  	(void) fclose(af);
X  	CurEnv->e_to = NULL;
X  	FileName = NULL;
X+ #ifdef MDBM
X+ 	(void) mdbm_sync(AliasDbm);
X+ #endif MDBM
X  	message(Arpa_Info, "%d aliases, longest %d bytes, %d bytes total",
X  			naliases, longest, bytes);
X  # ifdef LOG
X*** conf.h.old	Fri Aug 26 18:30:27 1988
X--- conf.h	Fri Aug 26 19:07:48 1988
X***************
X*** 48,53 ****
X--- 48,54 ----
X  
X  # define DBM		1	/* use DBM library (requires -ldbm) */
X  # define NDBM		1	/* new DBM library available (requires DBM) */
X+ # define MDBM		1	/* subst Maryland's mdbm package for ndbm */
X  # define YP		1	/* enable Yellow Pages code */
X  # define DEBUG		1	/* enable debugging */
X  # define LOG		1	/* enable logging */
X*** sendmail.h.old	Fri Aug 26 18:30:56 1988
X--- sendmail.h	Fri Aug 26 19:06:19 1988
X***************
X*** 493,499 ****
X   */
X  #define	MAX_ERRNO	100
X  /*
X! **  Database ([n]dbm) definitions.
X  */
X  
X  #ifdef DBM
X--- 493,499 ----
X   */
X  #define	MAX_ERRNO	100
X  /*
X! **  Database ([mn]dbm) definitions.
X  */
X  
X  #ifdef DBM
X***************
X*** 503,517 ****
X  	int	dsize;
X  } DATUM;
X  
X! # define DB_DIREXT	".dir"
X! # define DB_PAGEXT	".pag"
X  
X! # ifdef NDBM
X  
X! #  undef DBM			/* while including ndbm.h */
X! #  include <ndbm.h>		/* DBM is typedef'ed here */
X  typedef DBM DBMFILE;		/* move typedef to DBMFILE */
X! #  define DBM			/* and restore DBM definition */
X  #  include <fcntl.h>		/* needed for dbm_open */
X  
X  #  define DATUM datum		/* use the definition in ndbm.h */
X--- 503,526 ----
X  	int	dsize;
X  } DATUM;
X  
X! # ifdef MDBM
X! #  define DB_DIREXT	".map"
X! #  define DB_PAGEXT	".dat"
X! # else MDBM
X! #  define DB_DIREXT	".dir"
X! #  define DB_PAGEXT	".pag"
X! # endif MDBM
X  
X! # if defined(NDBM) || defined(MDBM)
X  
X! #  ifdef MDBM
X! #   include "mdbm_compat.h"	/* mdbm compatibility file */
X! #  else MDBM
X! #   undef DBM			/* while including ndbm.h */
X! #   include <ndbm.h>		/* DBM is typedef'ed here */
X  typedef DBM DBMFILE;		/* move typedef to DBMFILE */
X! #   define DBM			/* and restore DBM definition */
X! #  endif MDBM
X  #  include <fcntl.h>		/* needed for dbm_open */
X  
X  #  define DATUM datum		/* use the definition in ndbm.h */
X***************
X*** 529,535 ****
X  #  define AliasFile	DbmTab[DB_ALIAS].db_name
X  #  define AliasDbm	DbmTab[DB_ALIAS].db_dbm
X  
X! # endif NDBM
X  #endif DBM
X  /*
X  **  Global variables.
X--- 538,544 ----
X  #  define AliasFile	DbmTab[DB_ALIAS].db_name
X  #  define AliasDbm	DbmTab[DB_ALIAS].db_dbm
X  
X! # endif NDBM || MDBM
X  #endif DBM
X  /*
X  **  Global variables.
END_OF_ida/patches/MDBM.diffs
if test 2627 -ne `wc -c <ida/patches/MDBM.diffs`; then
    echo shar: \"ida/patches/MDBM.diffs\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/macro.c.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/macro.c.diff\"
else
echo shar: Extracting \"ida/patches/macro.c.diff\" \(2896 characters\)
sed "s/^X//" >ida/patches/macro.c.diff <<'END_OF_ida/patches/macro.c.diff'
X*** macro.c.orig	Mon Mar 14 03:53:58 1988
X--- macro.c	Fri Aug 26 03:59:36 1988
X***************
X*** 47,52 ****
X--- 47,53 ----
X  	register char *q;
X  	bool skipping;		/* set if conditionally skipping output */
X  	bool recurse = FALSE;	/* set if recursion required */
X+ 	bool quote, inquote, inescape;
X  	int i;
X  	char xbuf[BUFSIZ];
X  	extern char *macvalue();
X***************
X*** 73,78 ****
X--- 74,80 ----
X  		*/
X  
X  		q = NULL;
X+ 		quote = FALSE;
X  		c = *s;
X  		switch (c)
X  		{
X***************
X*** 89,99 ****
X--- 91,106 ----
X  			skipping = FALSE;
X  			continue;
X  
X+ 		  case QUOTE822:
X+ 			quote = TRUE;
X+ 			/*FALLTHROUGH*/
X  		  case '\001':		/* macro interpolation */
X  			c = *++s;
X  			q = macvalue(c & 0177, e);
X  			if (q == NULL)
X  				continue;
X+ 			if (quote && !mustquote(q))
X+ 				quote = FALSE;
X  			break;
X  		}
X  
X***************
X*** 103,108 ****
X--- 110,117 ----
X  
X  		if (skipping || xp >= &xbuf[sizeof xbuf])
X  			continue;
X+ 		inquote = FALSE;
X+ 		inescape = FALSE;
X  		if (q == NULL)
X  			*xp++ = c;
X  		else
X***************
X*** 112,119 ****
X--- 121,144 ----
X  			{
X  				if (iscntrl(c) && !isspace(c))
X  					recurse = TRUE;
X+ 				if (quote) {
X+ 					if (!inquote) {
X+ 						*xp++ = '"';
X+ 						inquote = TRUE;
X+ 					}
X+ 					if (c == '"' && !inescape)
X+ 						*xp++ = '\\';
X+ 					if (c == '\\')
X+ 						inescape = !inescape;
X+ 					else
X+ 						inescape = FALSE;
X+ 				}
X  				*xp++ = c;
X  			}
X+ 			if (inescape && xp < &xbuf[sizeof xbuf - 1])
X+ 				*xp++ = '\\';
X+ 			if (quote && xp < &xbuf[sizeof xbuf - 1])
X+ 				*xp++ = '"';
X  		}
X  	}
X  	*xp = '\0';
X***************
X*** 174,179 ****
X--- 199,205 ----
X  **		$h   to host
X  **		$i   queue id
X  **		$j   official SMTP hostname, used in messages+
X+ **		$k   our UUCP host name, if different from $w
X  **		$l   UNIX-style from line+
X  **		$n   name of sendmail ("MAILER-DAEMON" on local
X  **		     net typically)+
X***************
X*** 239,247 ****
X--- 265,307 ----
X  	{
X  		register char *p = e->e_macro[n];
X  
X+ 		if (p == MACNULL)
X+ 			/* shadowing null */
X+ 			return (NULL);
X  		if (p != NULL)
X  			return (p);
X  		e = e->e_parent;
X  	}
X  	return (NULL);
X+ }
X+ /*
X+ **  MUSTQUOTE -- Check if string contains special RFC-822 chars.
X+ **
X+ **	Parameters:
X+ **		s -- the string to be checked.
X+ **
X+ **	Returns:
X+ **		TRUE if string is in need to be quoted, FALSE otherwise.
X+ **
X+ **	Side Effects:
X+ **		none.
X+ **
X+ **	Does this string contain any characters that RFC 822 says
X+ **	must be quoted?
X+ **	This is not strictly correct, since we consider ' ' non-special.
X+ **	Otherwise we'd quote "My Name", which is just too ugly.
X+ */
X+ mustquote(s)
X+ 	register char *s;
X+ {
X+ 	register int c;
X+ 	extern char *index();
X+ 
X+ 	while (c = *s++) {
X+ 		c &= 0177;
X+ 		if (c <= 037 || c == 0177 || 		/* CTLs */
X+ 		    index(".()<>@,;:\\\"[]", c) != NULL)/* 822 specials */
X+ 			return TRUE;
X+ 	}
X+ 	return FALSE;
X  }
END_OF_ida/patches/macro.c.diff
if test 2896 -ne `wc -c <ida/patches/macro.c.diff`; then
    echo shar: \"ida/patches/macro.c.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/readcf.c.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/readcf.c.diff\"
else
echo shar: Extracting \"ida/patches/readcf.c.diff\" \(2959 characters\)
sed "s/^X//" >ida/patches/readcf.c.diff <<'END_OF_ida/patches/readcf.c.diff'
X*** readcf.c.orig	Sat Apr  2 01:51:11 1988
X--- readcf.c	Fri Sep 16 19:23:34 1988
X***************
X*** 309,315 ****
X  	FILE *f;
X  	char buf[MAXLINE];
X  
X! 	f = fopen(filename, "r");
X  	if (f == NULL)
X  	{
X  		syserr("cannot open %s", filename);
X--- 309,318 ----
X  	FILE *f;
X  	char buf[MAXLINE];
X  
X! 	if (filename[0] == '|')
X! 		f = popen(&filename[1], "r");
X! 	else
X! 		f = fopen(filename, "r");
X  	if (f == NULL)
X  	{
X  		syserr("cannot open %s", filename);
X***************
X*** 357,363 ****
X  		}
X  	}
X  
X! 	(void) fclose(f);
X  }
X  /*
X  **  MAKEMAILER -- define a new mailer.
X--- 360,369 ----
X  		}
X  	}
X  
X! 	if (filename[0] == '|')
X! 		(void) pclose(f);
X! 	else
X! 		(void) fclose(f);
X  }
X  /*
X  **  MAKEMAILER -- define a new mailer.
X***************
X*** 440,447 ****
X  				setbitn(*p, m->m_flags);
X  			break;
X  
X! 		  case 'S':		/* sender rewriting ruleset */
X! 		  case 'R':		/* recipient rewriting ruleset */
X  			i = atoi(p);
X  			if (i < 0 || i >= MAXRWSETS)
X  			{
X--- 446,453 ----
X  				setbitn(*p, m->m_flags);
X  			break;
X  
X! 		  case 'S':		/* sender rewriting ruleset(s) */
X! 		  case 'R':		/* recipient rewriting ruleset(s) */
X  			i = atoi(p);
X  			if (i < 0 || i >= MAXRWSETS)
X  			{
X***************
X*** 448,457 ****
X  				syserr("invalid rewrite set, %d max", MAXRWSETS);
X  				return;
X  			}
X! 			if (fcode == 'S')
X! 				m->m_s_rwset = i;
X! 			else
X! 				m->m_r_rwset = i;
X  			break;
X  
X  		  case 'E':		/* end of line string */
X--- 454,482 ----
X  				syserr("invalid rewrite set, %d max", MAXRWSETS);
X  				return;
X  			}
X! 			/* default envelope ruleset for header ruleset */
X! 			if (fcode == 'S') {
X! 				m->m_se_rwset = i;
X! 				m->m_sh_rwset = i;
X! 			} else {
X! 				m->m_re_rwset = i;
X! 				m->m_rh_rwset = i;
X! 			}
X! 			/* look for specific header rewriting ruleset */
X! 			while (*p != '\0' && *p != ',' && *p != '/') p++;
X! 			if (*p++ == '/') {
X! 				i = atoi(p);
X! 				if (i < 0 || i >= MAXRWSETS)
X! 				{
X! 					syserr("invalid rewrite set, %d max",
X! 					       MAXRWSETS);
X! 					return;
X! 				}
X! 				if (fcode == 'S')
X! 					m->m_sh_rwset = i;
X! 				else
X! 					m->m_rh_rwset = i;
X! 			}
X  			break;
X  
X  		  case 'E':		/* end of line string */
X***************
X*** 803,809 ****
X  	  case 'i':		/* ignore dot lines in message */
X  		IgnrDot = atobool(val);
X  		break;
X! 
X  	  case 'L':		/* log level */
X  		LogLevel = atoi(val);
X  		break;
X--- 828,839 ----
X  	  case 'i':		/* ignore dot lines in message */
X  		IgnrDot = atobool(val);
X  		break;
X! # ifdef NDBM
X! 	  case 'K':		/* keyed database file */
X! 		if (*val != '\0')
X! 			DbmTab[*val & 0177].db_name = newstr(&val[1]);
X! 		break;
X! # endif NDBM
X  	  case 'L':		/* log level */
X  		LogLevel = atoi(val);
X  		break;
X***************
X*** 909,914 ****
X--- 939,948 ----
X  
X  	  case 'Z':		/* work time factor */
X  		WkTimeFact = atoi(val);
X+ 		break;
X+ 
X+ 	  case '/':		/* use split envelope/header rewriting */
X+ 		SplitRewriting = TRUE;
X  		break;
X  
X  	  default:
END_OF_ida/patches/readcf.c.diff
if test 2959 -ne `wc -c <ida/patches/readcf.c.diff`; then
    echo shar: \"ida/patches/readcf.c.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/savemail.c.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/savemail.c.diff\"
else
echo shar: Extracting \"ida/patches/savemail.c.diff\" \(2370 characters\)
sed "s/^X//" >ida/patches/savemail.c.diff <<'END_OF_ida/patches/savemail.c.diff'
X*** savemail.c.orig	Mon Mar 14 03:54:08 1988
X--- savemail.c	Thu Sep  1 20:32:33 1988
X***************
X*** 371,377 ****
X  	extern ENVELOPE *newenvelope();
X  	ENVELOPE errenvelope;
X  	static int returndepth;
X! 	register ADDRESS *q;
X  
X  # ifdef DEBUG
X  	if (tTd(6, 1))
X--- 371,379 ----
X  	extern ENVELOPE *newenvelope();
X  	ENVELOPE errenvelope;
X  	static int returndepth;
X! 	register ADDRESS *p, *q;
X! 	char *to, *cc;
X! 	int len;
X  
X  # ifdef DEBUG
X  	if (tTd(6, 1))
X***************
X*** 396,411 ****
X  	define('g', "\001f", CurEnv);
X  	ee = newenvelope(&errenvelope);
X  	define('a', "\001b", ee);
X  	ee->e_puthdr = putheader;
X  	ee->e_putbody = errbody;
X  	ee->e_flags |= EF_RESPONSE;
X  	ee->e_sendqueue = returnq;
X  	openxscript(ee);
X! 	for (q = returnq; q != NULL; q = q->q_next)
X! 	{
X! 		if (q->q_alias == NULL)
X! 			addheader("to", q->q_paddr, ee);
X  	}
X  
X  	(void) sprintf(buf, "Returned mail: %s", msg);
X  	addheader("subject", buf, ee);
X--- 398,447 ----
X  	define('g', "\001f", CurEnv);
X  	ee = newenvelope(&errenvelope);
X  	define('a', "\001b", ee);
X+ 	/* undefine sending host & proto for error msg */
X+ 	define('s', MACNULL, ee);
X+ 	define('r', MACNULL, ee);
X  	ee->e_puthdr = putheader;
X  	ee->e_putbody = errbody;
X  	ee->e_flags |= EF_RESPONSE;
X  	ee->e_sendqueue = returnq;
X  	openxscript(ee);
X! 
X! 	/* put the recipients in the to: header (cc: for PostMasterCopy) */
X! 	cc = NULL;
X! 	to = buf;
X! 	for (q = returnq; q != NULL; q = q->q_next) {
X! 	    if (q->q_alias == NULL)
X! 		if (strcmp(q->q_paddr, PostMasterCopy) == 0)
X! 		    cc = q->q_paddr;
X! 		else {
X! 		    /* Not Postmaster; already on the To: line? */
X! 		    for (p = returnq; p != q; p = p->q_next)
X! 			if (strcasecmp(p->q_paddr, q->q_paddr) == 0)
X! 			    break;
X! 		    if (p == q) {
X! 			/* No, add it */
X! 			*to++ = ',';
X! 			*to++ = ' ';
X! 
X! 			len = strlen(q->q_paddr);
X! 			if (q->q_paddr[0] == '<' && q->q_paddr[len-1] == '>' &&
X! 			    q->q_paddr[1] != '@') {
X! 			    /* Remove angle brackets; they aren't needed */
X! 			    strncpy(to, q->q_paddr+1, len-2);
X! 			    to += len-2;
X! 			} else {
X! 			    strcpy(to, q->q_paddr, len);
X! 			    to += len;
X! 			}
X! 		    }
X! 		}
X  	}
X+ 	*to = '\0';
X+ 	if (to != buf)
X+ 	    addheader("to", buf+2, ee);
X+ 	if (cc)
X+ 	    addheader("cc", cc, ee);
X  
X  	(void) sprintf(buf, "Returned mail: %s", msg);
X  	addheader("subject", buf, ee);
END_OF_ida/patches/savemail.c.diff
if test 2370 -ne `wc -c <ida/patches/savemail.c.diff`; then
    echo shar: \"ida/patches/savemail.c.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/srvrsmtp.c.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/srvrsmtp.c.diff\"
else
echo shar: Extracting \"ida/patches/srvrsmtp.c.diff\" \(4658 characters\)
sed "s/^X//" >ida/patches/srvrsmtp.c.diff <<'END_OF_ida/patches/srvrsmtp.c.diff'
X*** srvrsmtp.c.orig	Mon Mar 14 05:31:55 1988
X--- srvrsmtp.c	Thu Aug 25 13:57:07 1988
X***************
X*** 101,107 ****
X  
X  #define EX_QUIT		22		/* special code for QUIT command */
X  
X! smtp()
X  {
X  	register char *p;
X  	register struct cmd *c;
X--- 101,108 ----
X  
X  #define EX_QUIT		22		/* special code for QUIT command */
X  
X! smtp(batched)
X! 	bool batched;			/* running non-interactively? */
X  {
X  	register char *p;
X  	register struct cmd *c;
X***************
X*** 114,119 ****
X--- 115,121 ----
X  	char inp[MAXLINE];
X  	char cmdbuf[100];
X  	extern char Version[];
X+ 	char hostbuf[MAXNAME];		/* for host name transformations */
X  	extern tick();
X  	extern bool iswiz();
X  	extern char *arpadate();
X***************
X*** 201,207 ****
X  		  case CMDHELO:		/* hello -- introduce yourself */
X  			SmtpPhase = "HELO";
X  			setproctitle("%s: %s", CurHostName, inp);
X! 			if (!strcasecmp(p, MyHostName))
X  			{
X  				/* connected to an echo server */
X  				message("553", "%s I refuse to talk to myself",
X--- 203,212 ----
X  		  case CMDHELO:		/* hello -- introduce yourself */
X  			SmtpPhase = "HELO";
X  			setproctitle("%s: %s", CurHostName, inp);
X! 			/* find canonical name */
X! 			strcpy(hostbuf, p);
X! 			maphostname(hostbuf, sizeof(hostbuf));
X! 			if (!strcasecmp(hostbuf, MyHostName))
X  			{
X  				/* connected to an echo server */
X  				message("553", "%s I refuse to talk to myself",
X***************
X*** 208,224 ****
X  					MyHostName);
X  				break;
X  			}
X! 			if (RealHostName != NULL && strcasecmp(p, RealHostName))
X  			{
X- 				char hostbuf[MAXNAME];
X- 
X  				(void) sprintf(hostbuf, "%s (%s)", p, RealHostName);
X  				sendinghost = newstr(hostbuf);
X! 			}
X! 			else
X  				sendinghost = newstr(p);
X! 			message("250", "%s Hello %s, pleased to meet you",
X! 				MyHostName, p);
X  			break;
X  
X  		  case CMDMAIL:		/* mail -- designate sender */
X--- 213,228 ----
X  					MyHostName);
X  				break;
X  			}
X! 			if (RealHostName != NULL && strcasecmp(hostbuf, RealHostName))
X  			{
X  				(void) sprintf(hostbuf, "%s (%s)", p, RealHostName);
X  				sendinghost = newstr(hostbuf);
X! 				message("250", "Hello %s, why do you call yourself %s?",
X! 					RealHostName, p);
X! 			} else {
X  				sendinghost = newstr(p);
X! 				message("250", "Hello %s, pleased to meet you", p);
X! 			}
X  			break;
X  
X  		  case CMDMAIL:		/* mail -- designate sender */
X***************
X*** 243,248 ****
X--- 247,253 ----
X  			/* fork a subprocess to process this command */
X  			if (runinchild("SMTP-MAIL") > 0)
X  				break;
X+ 			define('r', "SMTP", CurEnv);
X  			define('s', sendinghost, CurEnv);
X  			initsys();
X  			setproctitle("%s %s: %s", CurEnv->e_id,
X***************
X*** 268,274 ****
X  				CurHostName, inp);
X  			if (setjmp(TopFrame) > 0)
X  			{
X! 				CurEnv->e_flags &= ~EF_FATALERRS;
X  				break;
X  			}
X  			QuickAbort = TRUE;
X--- 273,280 ----
X  				CurHostName, inp);
X  			if (setjmp(TopFrame) > 0)
X  			{
X! 				if (!batched)
X! 					CurEnv->e_flags &= ~EF_FATALERRS;
X  				break;
X  			}
X  			QuickAbort = TRUE;
X***************
X*** 299,311 ****
X  			SmtpPhase = "DATA";
X  			if (!hasmail)
X  			{
X! 				message("503", "Need MAIL command");
X! 				break;
X  			}
X  			else if (CurEnv->e_nrcpts <= 0)
X  			{
X! 				message("503", "Need RCPT (recipient)");
X! 				break;
X  			}
X  
X  			/* collect the text of the message */
X--- 305,323 ----
X  			SmtpPhase = "DATA";
X  			if (!hasmail)
X  			{
X! 				message("503", "Need valid MAIL command");
X! 				if (batched)
X! 					Errors++;
X! 				else
X! 					break;
X  			}
X  			else if (CurEnv->e_nrcpts <= 0)
X  			{
X! 				message("503", "Need valid RCPT (recipient)");
X! 				if (batched)
X! 					Errors++;
X! 				else
X! 					break;
X  			}
X  
X  			/* collect the text of the message */
X***************
X*** 335,347 ****
X  			*/
X  
X  			SmtpPhase = "delivery";
X! 			if (CurEnv->e_nrcpts != 1)
X  			{
X  				HoldErrs = TRUE;
X  				ErrorMode = EM_MAIL;
X  			}
X! 			CurEnv->e_flags &= ~EF_FATALERRS;
X! 			CurEnv->e_xfp = freopen(queuename(CurEnv, 'x'), "w", CurEnv->e_xfp);
X  
X  			/* send to all recipients */
X  			sendall(CurEnv, SM_DEFAULT);
X--- 347,362 ----
X  			*/
X  
X  			SmtpPhase = "delivery";
X! 			if (CurEnv->e_nrcpts != 1 || batched)
X  			{
X  				HoldErrs = TRUE;
X  				ErrorMode = EM_MAIL;
X  			}
X! 			if (!batched) {
X! 				CurEnv->e_flags &= ~EF_FATALERRS;
X! 				CurEnv->e_xfp = freopen(queuename(CurEnv, 'x'),
X! 							"w", CurEnv->e_xfp);
X! 			}
X  
X  			/* send to all recipients */
X  			sendall(CurEnv, SM_DEFAULT);
X***************
X*** 681,687 ****
X  	}
X  
X  	/* open alias database */
X! 	initaliases(AliasFile, FALSE);
X  
X  	return (0);
X  }
X--- 696,702 ----
X  	}
X  
X  	/* open alias database */
X! 	initaliases(FALSE);
X  
X  	return (0);
X  }
END_OF_ida/patches/srvrsmtp.c.diff
if test 4658 -ne `wc -c <ida/patches/srvrsmtp.c.diff`; then
    echo shar: \"ida/patches/srvrsmtp.c.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/usersmtp.c.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/usersmtp.c.diff\"
else
echo shar: Extracting \"ida/patches/usersmtp.c.diff\" \(3370 characters\)
sed "s/^X//" >ida/patches/usersmtp.c.diff <<'END_OF_ida/patches/usersmtp.c.diff'
X*** usersmtp.c.orig	Mon Mar 14 03:54:14 1988
X--- usersmtp.c	Thu Sep 15 22:03:01 1988
X***************
X*** 37,42 ****
X--- 37,43 ----
X  
X  #define REPLYTYPE(r)	((r) / 100)		/* first digit of reply code */
X  #define REPLYCLASS(r)	(((r) / 10) % 10)	/* second digit of reply code */
X+ #define SMTPGOODREPLY	250			/* positive SMTP response */
X  #define SMTPCLOSING	421			/* "Service Shutting Down" */
X  
X  char	SmtpMsgBuffer[MAXLINE];		/* buffer for commands */
X***************
X*** 112,124 ****
X  			{
X  				p = statstring(ExitStat);
X  				fprintf(CurEnv->e_xfp,
X! 					"%.3s %s.%s... %s\n",
X  					p, pvp[1], m->m_name, p);
X  			}
X  			else
X  			{
X  				fprintf(CurEnv->e_xfp,
X! 					"421 %s.%s... Deferred: %s\n",
X  					pvp[1], m->m_name, errstring(errno));
X  			}
X  		}
X--- 113,125 ----
X  			{
X  				p = statstring(ExitStat);
X  				fprintf(CurEnv->e_xfp,
X! 					"%.3s %s (%s)... %s\n",
X  					p, pvp[1], m->m_name, p);
X  			}
X  			else
X  			{
X  				fprintf(CurEnv->e_xfp,
X! 					"421 %s (%s)... Deferred: %s\n",
X  					pvp[1], m->m_name, errstring(errno));
X  			}
X  		}
X***************
X*** 244,250 ****
X  	register int r;
X  	extern char *remotename();
X  
X! 	smtpmessage("RCPT To:<%s>", m, remotename(to->q_user, m, FALSE, TRUE));
X  
X  	SmtpPhase = "RCPT wait";
X  	r = reply(m);
X--- 245,260 ----
X  	register int r;
X  	extern char *remotename();
X  
X! 	/* DISABLED since I didn't understand why further rewriting
X! 	   should be necessary.  Since it doesn't go through ruleset 0
X! 	   on this second rewriting (which it should since it's a
X! 	   envelope recipient address) there is even the risk that it
X! 	   gets screwed up.
X! 						-- lel@ida.liu.se
X! 	smtpmessage("RCPT To:<%s>", m, remotename(to->q_user, m, FALSE, TRUE,
X! 						  FALSE));
X! 	*/
X! 	smtpmessage("RCPT To:<%s>", m, to->q_user);
X  
X  	SmtpPhase = "RCPT wait";
X  	r = reply(m);
X***************
X*** 294,300 ****
X  		return (EX_TEMPFAIL);
X  	else if (r == 554)
X  		return (EX_UNAVAILABLE);
X! 	else if (r != 354)
X  		return (EX_PROTOCOL);
X  
X  	/* now output the actual message */
X--- 304,310 ----
X  		return (EX_TEMPFAIL);
X  	else if (r == 554)
X  		return (EX_UNAVAILABLE);
X! 	else if (r != 354 && r != 250)
X  		return (EX_PROTOCOL);
X  
X  	/* now output the actual message */
X***************
X*** 381,386 ****
X--- 391,399 ----
X  	if (tTd(18, 1))
X  		printf("reply\n");
X  
X+ 	if (bitnset(M_BSMTP, m->m_flags))
X+ 		return (SMTPGOODREPLY);
X+ 
X  	/*
X  	**  Read the input line, being careful not to hang.
X  	*/
X***************
X*** 413,419 ****
X  				errno = EPIPE;
X  # endif ECONNRESET
X  
X! 			message(Arpa_TSyserr, "reply: read error");
X  # ifdef DEBUG
X  			/* if debugging, pause so we can see state */
X  			if (tTd(18, 100))
X--- 426,432 ----
X  				errno = EPIPE;
X  # endif ECONNRESET
X  
X! 			message(Arpa_TSyserr, "Connection ended prematurely");
X  # ifdef DEBUG
X  			/* if debugging, pause so we can see state */
X  			if (tTd(18, 100))
X***************
X*** 431,436 ****
X--- 444,453 ----
X  		if (CurEnv->e_xfp != NULL && index("45", SmtpReplyBuffer[0]) != NULL)
X  		{
X  			/* serious error -- log the previous command */
X+ 			/* also record who we were talking before first error */
X+ 			if (SmtpError[0] == '\0')
X+ 				fprintf(CurEnv->e_xfp, "While talking to %s:\n",
X+ 					CurHostName);
X  			if (SmtpMsgBuffer[0] != '\0')
X  				fprintf(CurEnv->e_xfp, ">>> %s\n", SmtpMsgBuffer);
X  			SmtpMsgBuffer[0] = '\0';
END_OF_ida/patches/usersmtp.c.diff
if test 3370 -ne `wc -c <ida/patches/usersmtp.c.diff`; then
    echo shar: \"ida/patches/usersmtp.c.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ida/patches/util.c.diff -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ida/patches/util.c.diff\"
else
echo shar: Extracting \"ida/patches/util.c.diff\" \(2377 characters\)
sed "s/^X//" >ida/patches/util.c.diff <<'END_OF_ida/patches/util.c.diff'
X*** util.c.orig	Mon Mar 14 05:23:49 1988
X--- util.c	Fri Aug 26 03:56:07 1988
X***************
X*** 19,24 ****
X--- 19,26 ----
X  # include <errno.h>
X  # include "sendmail.h"
X  
X+ bool catPrint = FALSE;		/* xputs: print strings for catenation */
X+ 
X  /*
X  **  STRIPQUOTES -- Strip quotes & quote bits from a string.
X  **
X***************
X*** 260,272 ****
X  	register char *s;
X  {
X  	register char c;
X  
X  	if (s == NULL)
X  	{
X  		printf("<null>");
X  		return;
X  	}
X! 	(void) putchar('"');
X  	while ((c = *s++) != '\0')
X  	{
X  		if (!isascii(c))
X--- 262,292 ----
X  	register char *s;
X  {
X  	register char c;
X+ 	register struct metamac *m;
X  
X+ 	if (s == MACNULL)
X+ 	{
X+ 		printf("<macnull>");
X+ 		return;
X+ 	}
X  	if (s == NULL)
X  	{
X  		printf("<null>");
X  		return;
X  	}
X! 
X! 	if (s[0] == MATCHREPL && isdigit(s[1]) && s[2] == '\0') {
X! 	  printf("$%c", s[1]);
X! 	  return;
X! 	} else
X! 	  for (m = MetaMacros; m->metaname != '\0'; m++)
X! 	    if (m->metaval == *s) {
X! 	      printf("$%c%s", m->metaname, &s[1]);
X! 	      return;
X! 	    }
X! 
X! 	if (!catPrint)
X! 		(void) putchar('"');
X  	while ((c = *s++) != '\0')
X  	{
X  		if (!isascii(c))
X***************
X*** 281,287 ****
X  		}
X  		(void) putchar(c);
X  	}
X! 	(void) putchar('"');
X  	(void) fflush(stdout);
X  }
X  /*
X--- 301,308 ----
X  		}
X  		(void) putchar(c);
X  	}
X! 	if (!catPrint)
X! 		(void) putchar('"');
X  	(void) fflush(stdout);
X  }
X  /*
X***************
X*** 305,315 ****
X  	register char *p;
X  {
X  	register char c;
X  
X  	if (p == NULL)
X  		return;
X  	for (; (c = *p) != '\0'; p++)
X! 		if (isascii(c) && isupper(c))
X  			*p = c - 'A' + 'a';
X  }
X  /*
X--- 326,339 ----
X  	register char *p;
X  {
X  	register char c;
X+ 	register bool quoted_string = FALSE;
X  
X  	if (p == NULL)
X  		return;
X  	for (; (c = *p) != '\0'; p++)
X! 		if (c == '"')
X! 			quoted_string = !quoted_string;
X! 		else if (!quoted_string && isascii(c) && isupper(c))
X  			*p = c - 'A' + 'a';
X  }
X  /*
X***************
X*** 861,864 ****
X--- 885,911 ----
X  		if (map[i] != 0)
X  			return (FALSE);
X  	return (TRUE);
X+ }
X+ 
X+ /*
X+ **	PRINTCAV -- Print concatenated argument vector
X+ **
X+ **	Parameters:
X+ **		av -- argument vector.
X+ **
X+ **	Returns:
X+ **		none.
X+ **
X+ **	Side Effects:
X+ **		prints av.
X+ */
X+ 
X+ printcav(av)
X+      register char **av;
X+ {
X+   bool oldCatPrint = catPrint;
X+ 
X+   catPrint = TRUE;
X+   printav(av);
X+   catPrint = oldCatPrint;
X  }
END_OF_ida/patches/util.c.diff
if test 2377 -ne `wc -c <ida/patches/util.c.diff`; then
    echo shar: \"ida/patches/util.c.diff\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 2 \(of 8\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    echo "See ida/README and ida/INSTALL for further directions."
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

