Path: bbn.com!rsalz
From: rsalz@uunet.uu.net (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v16i011:  Modem communications package, Part06/08
Message-ID: <1063@fig.bbn.com>
Date: 13 Sep 88 16:44:47 GMT
Lines: 2004
Approved: rsalz@uunet.UU.NET

Submitted-by: Emmet P Gray <fthood!egray>
Posting-number: Volume 16, Issue 11
Archive-name: pcomm2/part06

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	s_axfer.c
#	s_gen.c
#	s_menu.c
#	s_modem.c
#	s_prompt.c
#	s_term.c
#	s_tty.c
#	screen.c
#	st_line.c
#	strings.c
#	terminal.c
export PATH; PATH=/bin:/usr/bin:$PATH
echo shar: "extracting 's_axfer.c'" '(3938 characters)'
if test -f 's_axfer.c'
then
	echo shar: "will not over-write existing file 's_axfer.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_axfer.c'
X/*
X * Display the ASCII transfer setup, query for changes.  A return code
X * of 1 means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X#include "param.h"
X
Xint
Xaxfer_setup()
X{
X	extern char *v_yes[];
X	WINDOW *x_win, *newwin();
X	int i, ret_code, num;
X	char *ans, *menu_prompt(), *strdup();
X	void free_ptr();
X	static char *v_cr[4] = {"NONE", "STRIP", "ADD LF", NULL};
X	static char *v_lf[4] = {"NONE", "STRIP", "ADD CR", NULL};
X	static char *v_delay[4] = {"0", "100", "150", NULL};
X
X	x_win = newwin(23, 80, 0, 0);
X
X	horizontal(x_win, 0, 0, 28);
X	mvwattrstr(x_win, 0, 29, A_BOLD, "ASCII Transfer Setup");
X	horizontal(x_win, 0, 50, 29);
X	mvwaddstr(x_win, 3, 34, "ASCII UPLOAD");
X	mvwprintw(x_win, 5, 22, "1) Echo locally ........... %s", param->lecho);
X	mvwprintw(x_win, 6, 22, "2) Expand blank lines ..... %s", param->expand);
X	mvwprintw(x_win, 7, 22, "3) CR delay (ms) .......... %d", param->cr_delay);
X	mvwprintw(x_win, 8, 22, "4) Pace the output ........ %s", param->pace);
X	mvwprintw(x_win, 9, 22, "5) CR translation ......... %s", param->cr_up);
X	mvwprintw(x_win, 10, 22, "6) LF translation ......... %s", param->lf_up);
X	mvwaddstr(x_win, 12, 32, "ASCII DOWNLOAD");
X	mvwprintw(x_win, 14, 22, "7) Transfer timeout (sec) . %d", param->timer);
X	mvwprintw(x_win, 15, 22, "8) CR translation ......... %s", param->cr_dn);
X	mvwprintw(x_win, 16, 22, "9) LF translation ......... %s", param->lf_dn);
X	horizontal(x_win, 19, 0, 80);
X	mvwattrstr(x_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(x_win, 20, 58, "Press <ESC> to return");
X	wmove(x_win, 20, 12);
X	touchwin(x_win);
X	wrefresh(x_win);
X					/* get the option number */
X	ret_code = 0;
X	while ((i = get_num(x_win, 1)) != -1) {
X		switch (i) {
X			case 1:
X				if ((ans = menu_prompt(x_win, 5, 50, "Echo locally", v_yes)) != NULL) {
X					free_ptr(param->lecho);
X					param->lecho = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 2:
X				if ((ans = menu_prompt(x_win, 6, 50, "Expand blank lines", v_yes)) != NULL) {
X					free_ptr(param->expand);
X					param->expand = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 3:
X				if ((ans = menu_prompt(x_win, 7, 50, "CR delay (ms)", v_delay)) != NULL) {
X					param->cr_delay = atoi(ans);
X					ret_code++;
X				}
X				break;
X			case 4:
X				if ((ans = menu_prompt(x_win, 8, 50, "Pace the output", v_yes)) != NULL) {
X					free_ptr(param->pace);
X					param->pace = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 5:
X				if ((ans = menu_prompt(x_win, 9, 50, "CR translation (upload)", v_cr)) != NULL) {
X					free_ptr(param->cr_up);
X					param->cr_up = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 6:
X				if ((ans = menu_prompt(x_win, 10, 50, "LF translation (upload)", v_lf)) != NULL) {
X					free_ptr(param->lf_up);
X					param->lf_up = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 7:
X				if ((num = num_prompt(x_win, 14, 50, "Transfer timeout", "(in seconds)")) != -1) {
X					if (num > MAX_TIMER || num < MIN_TIMER) {
X						beep();
X					/* some reasonable range of values */
X						if (num < MIN_TIMER)
X							num = MIN_TIMER;
X						else
X							num = MAX_TIMER;
X						mvwaddstr(x_win, 14, 50, "   ");
X						wrefresh(x_win);
X						mvwattrnum(x_win, 14, 50, A_BOLD, num);
X						wrefresh(x_win);
X					}
X					param->timer = num;
X					ret_code++;
X				}
X				break;
X			case 8:
X				if ((ans = menu_prompt(x_win, 15, 50, "CR translation (download)", v_cr)) != NULL) {
X					free_ptr(param->cr_dn);
X					param->cr_dn = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 9:
X				if ((ans = menu_prompt(x_win, 16, 50, "LF translation (download)", v_lf)) != NULL) {
X					free_ptr(param->lf_dn);
X					param->lf_dn = strdup(ans);
X					ret_code++;
X				}
X				break;
X			default:
X				beep();
X		}
X		mvwaddch(x_win, 20, 12, (chtype) ' ');
X		clear_line(x_win, 21, 0, 0);
X		clear_line(x_win, 22, 0, 0);
X		wmove(x_win, 20, 12);
X		wrefresh(x_win);
X	}
X	delwin(x_win);
X	return(ret_code);
X}
SHAR_EOF
if test 3938 -ne "`wc -c < 's_axfer.c'`"
then
	echo shar: "error transmitting 's_axfer.c'" '(should have been 3938 characters)'
fi
fi
echo shar: "extracting 's_gen.c'" '(4457 characters)'
if test -f 's_gen.c'
then
	echo shar: "will not over-write existing file 's_gen.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_gen.c'
X/*
X * Display the general setup, query for changes.  A return code of 1
X * means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X#include "param.h"
X
Xint
Xgen_setup()
X{
X	extern char *v_yes[];
X	WINDOW *g_win, *newwin();
X	int i, num, ret_code;
X	char c, *ans, *str_prompt(), *menu_prompt(), chr_prompt();
X	char *strdup();
X	void free_ptr(), line_set();
X	static char *v_abort[3] = {"KEEP", "DELETE", NULL};
X
X	g_win = newwin(23, 80, 0, 0);
X
X	horizontal(g_win, 0, 0, 32);
X	mvwattrstr(g_win, 0, 33, A_BOLD, "General Setup");
X	horizontal(g_win, 0, 47, 32);
X	mvwprintw(g_win, 3, 22, "1) Default log file ....... %s", param->logfile);
X	mvwprintw(g_win, 4, 22, "2) Screen dump file ....... %s", param->dumpfile);
X	mvwprintw(g_win, 6, 22, "3) Strip high bit  ........ %s", param->strip);
X	mvwprintw(g_win, 8, 22, "4) Pause character ........ %c", param->pause_char);
X	mvwprintw(g_win, 9, 22, "5) CR character ........... %c", param->cr_char);
X	mvwprintw(g_win, 10, 22, "6) CTRL character ......... %c", param->ctrl_char);
X	mvwprintw(g_win, 11, 22, "7) ESC character .......... %c", param->esc_char);
X	mvwprintw(g_win, 12, 22, "8) Break character ........ %c", param->brk_char);
X	mvwprintw(g_win, 14, 22, "9) Aborted downloads ...... %s", param->abort);
X	mvwprintw(g_win, 16, 21, "10) Connect delay (sec) .... %d", param->c_delay);
X	mvwprintw(g_win, 17, 21, "11) Redial delay (sec) ..... %d", param->r_delay);
X	horizontal(g_win, 19, 0, 80);
X	mvwattrstr(g_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(g_win, 20, 58, "Press <ESC> to return");
X	wmove(g_win, 20, 12);
X	touchwin(g_win);
X	wrefresh(g_win);
X					/* get the option number */
X	ret_code = 0;
X	while ((i = get_num(g_win, 2)) != -1) {
X		switch (i) {
X			case 1:
X				if ((ans = str_prompt(g_win, 3, 50, "Default log file", "")) != NULL) {
X					free_ptr(param->logfile);
X					param->logfile = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 2:
X				if ((ans = str_prompt(g_win, 4, 50, "Default screen dump file", "")) != NULL) {
X					free_ptr(param->dumpfile);
X					param->dumpfile = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 3:
X				if ((ans = menu_prompt(g_win, 6, 50, "Strip high bit?", v_yes)) != NULL) {
X					free_ptr(param->strip);
X					param->strip = strdup(ans);
X					line_set();
X					ret_code++;
X				}
X				break;
X			case 4:
X				if ((c = chr_prompt(g_win, 8, 50, "Pause character", "1 second")) != NULL) {
X					param->pause_char = c;
X					ret_code++;
X				}
X				break;
X			case 5:
X				if ((c = chr_prompt(g_win, 9, 50, "CR character", "(carriage return)")) != NULL) {
X					param->cr_char = c;
X					ret_code++;
X				}
X				break;
X			case 6:
X				if ((c = chr_prompt(g_win, 10, 50, "CTRL character", "(control)")) != NULL) {
X					param->ctrl_char = c;
X					ret_code++;
X				}
X				break;
X			case 7:
X				if ((c = chr_prompt(g_win, 11, 50, "ESC character", "(escape)")) != NULL) {
X					param->esc_char = c;
X					ret_code++;
X				}
X				break;
X			case 8:
X				if ((c = chr_prompt(g_win, 12, 50, "Break character", "")) != NULL) {
X					param->brk_char = c;
X					ret_code++;
X				}
X			case 9:
X				if ((ans = menu_prompt(g_win, 14, 50, "Aborted downloads", v_abort)) != NULL) {
X					free_ptr(param->abort);
X					param->abort = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 10:
X				if ((num = num_prompt(g_win, 16, 50, "Connect delay time", "(in seconds)")) != -1) {
X					if (num > MAX_CDELAY || num < MIN_CDELAY) {
X						beep();
X					/* some reasonable range of values */
X						if (num < MIN_CDELAY)
X							num = MIN_CDELAY;
X						else
X							num = MAX_CDELAY;
X						mvwaddstr(g_win, 16, 50, "   ");
X						wrefresh(g_win);
X						mvwattrnum(g_win, 16, 50, A_BOLD, num);
X						wrefresh(g_win);
X					}
X					param->c_delay = num;
X					ret_code++;
X				}
X				break;
X			case 11:
X				if ((num = num_prompt(g_win, 17, 50, "Redial delay time", "(in seconds)")) != -1) {
X					if (num > MAX_PAUSE || num < MIN_PAUSE) {
X						beep();
X					/* some reasonable range */
X						if (num < MIN_PAUSE)
X							num = MIN_PAUSE;
X						else
X							num = MAX_PAUSE;
X						mvwaddstr(g_win, 17, 50, "    ");
X						wrefresh(g_win);
X						mvwattrnum(g_win, 17, 50, A_BOLD, num);
X						wrefresh(g_win);
X					}
X					param->r_delay = num;
X					ret_code++;
X				}
X				break;
X			default:
X				beep();
X		}
X		mvwaddstr(g_win, 20, 12, "  ");
X		clear_line(g_win, 21, 0, 0);
X		clear_line(g_win, 22, 0, 0);
X		wmove(g_win, 20, 12);
X		wrefresh(g_win);
X	}
X	delwin(g_win);
X	return(ret_code);
X}
SHAR_EOF
if test 4457 -ne "`wc -c < 's_gen.c'`"
then
	echo shar: "error transmitting 's_gen.c'" '(should have been 4457 characters)'
fi
fi
echo shar: "extracting 's_menu.c'" '(2732 characters)'
if test -f 's_menu.c'
then
	echo shar: "will not over-write existing file 's_menu.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_menu.c'
X/*
X * Display the setup menu, prompts for a bunch of other menus.  A return
X * code of 1 means we have to restart the input routine.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X
Xint
Xsetup_menu()
X{
X	extern int fd, xmc;
X	WINDOW *s_win, *newwin();
X	char *ans, *get_str();
X	int param_flag, modem_flag, ret_code;
X	void top_line();
X
X	s_win = newwin(23, 80, 0, 0);
X
X	top_line(s_win);
X	mvwaddstr(s_win, 4, 30, "1) TTY Setup");
X	mvwaddstr(s_win, 6, 30, "2) Modem Setup");
X	mvwaddstr(s_win, 8, 30, "3) Terminal Setup");
X	mvwaddstr(s_win, 10, 30, "4) General Setup");
X	mvwaddstr(s_win, 12, 30, "5) ASCII Transfer Setup");
X	mvwaddstr(s_win, 14, 30, "S) Save setup to disk");
X	horizontal(s_win, 19, 0, 80);
X	mvwattrstr(s_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(s_win, 20, 58, "  Press <ESC> to exit");
X	wmove(s_win, 20, 12);
X	touchwin(s_win);
X	wrefresh(s_win);
X
X	param_flag = 0;
X	modem_flag = 0;
X	ret_code = 0;
X					/* get the options */
X	while ((ans = get_str(s_win, 1, "12345Ss", "")) != NULL) {
X		if (xmc > 0) {
X			clear_line(s_win, 0, 0, 0);
X			wrefresh(s_win);
X		}
X		switch (*ans) {
X			case '1':
X				if (tty_setup())
X					modem_flag++;
X				break;
X			case '2':
X				if (modem_setup())
X					modem_flag++;
X				break;
X			case '3':
X				if (ret_code = term_setup()) {
X					ret_code--;
X					param_flag++;
X				}
X				break;
X			case '4':
X				if (gen_setup())
X					param_flag++;
X				break;
X			case '5':
X				if (axfer_setup())
X					param_flag++;
X				break;
X			case 's':
X			case 'S':
X				if (xmc > 0)
X					top_line(s_win);
X				if (param_flag || modem_flag) {
X					wmove(s_win, 22, 27);
X					/*
X					 * Writes to disk are not critical,
X					 * the changes are made in memory.
X					 */
X					if (param_flag) {
X						wattrstr(s_win, A_BLINK, "Updating Parameter File");
X						wrefresh(s_win);
X						wait_key(s_win, 3);
X						if (up_param()) {
X							touchwin(s_win);
X							wrefresh(s_win);
X						}
X					}
X					if (modem_flag) {
X						wattrstr(s_win, A_BLINK, "Updating Modem Database");
X						wrefresh(s_win);
X						wait_key(s_win, 3);
X						if (up_modem()) {
X							touchwin(s_win);
X							wrefresh(s_win);
X						}
X					}
X					clear_line(s_win, 22, 27, 0);
X					wrefresh(s_win);
X				}
X				break;
X			default:
X				beep();
X		}
X		touchwin(s_win);
X		if (xmc > 0)
X			top_line(s_win);
X
X		mvwaddch(s_win, 20, 12, (chtype) ' ');
X		wmove(s_win, 20, 12);
X		wrefresh(s_win);
X	}
X	if (fd == -1) {
X		werase(s_win);
X		wrefresh(s_win);
X	}
X	delwin(s_win);
X	return(ret_code);
X}
X
X/*
X * Put the top line on the window.
X */
X
Xvoid
Xtop_line(win)
XWINDOW *win;
X{
X	clear_line(win, 0, 0, 0);
X	wrefresh(win);
X	horizontal(win, 0, 0, 33);
X	mvwattrstr(win, 0, 34, A_BOLD, "Setup Menu");
X	horizontal(win, 0, 45, 34);
X	wrefresh(win);
X	return;
X}
SHAR_EOF
if test 2732 -ne "`wc -c < 's_menu.c'`"
then
	echo shar: "error transmitting 's_menu.c'" '(should have been 2732 characters)'
fi
fi
echo shar: "extracting 's_modem.c'" '(6867 characters)'
if test -f 's_modem.c'
then
	echo shar: "will not over-write existing file 's_modem.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_modem.c'
X/*
X * Display the modem setup, query for changes.  A return code of 1 means
X * something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X#include "modem.h"
X
Xint
Xmodem_setup()
X{
X	WINDOW *mo_win, *newwin();
X	int i, j, ret_code, mod_prompt();
X	char *ans, *strdup(), *str_prompt(), *menu_prompt();
X	void disp_modem(), free_ptr();
X	static char *v_yn[3] = {"Y", "N", NULL};
X					/* the current modem */
X	j = 0;
X	if (modem->m_cur != -1)
X		j = modem->m_cur;
X
X	mo_win = newwin(23, 80, 0, 0);
X
X	horizontal(mo_win, 0, 0, 33);
X	mvwattrstr(mo_win, 0, 34, A_BOLD, "Modem Setup");
X	horizontal(mo_win, 0, 46, 34);
X					/* display the current settings */
X	disp_modem(mo_win, j);
X	horizontal(mo_win, 19, 0, 80);
X	mvwattrstr(mo_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(mo_win, 20, 58, "Press <ESC> to return");
X	wmove(mo_win, 20, 12);
X	touchwin(mo_win);
X	wrefresh(mo_win);
X					/* get the option number */
X	ret_code = 0;
X	while ((i = get_num(mo_win, 2)) != -1) {
X		switch (i) {
X			case 1:
X				j = mod_prompt(mo_win);
X				break;
X			case 2:
X				if ((ans = str_prompt(mo_win, 3, 40, "Modem init string", "sent to the modem once")) != NULL) {
X					free_ptr(modem->init[j]);
X					modem->init[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 3:
X				if ((ans = str_prompt(mo_win, 4, 40, "Dialing command", "")) != NULL) {
X					free_ptr(modem->dial[j]);
X					modem->dial[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 4:
X				if ((ans = str_prompt(mo_win, 5, 40, "Dialing cmd suffix", "typically the <CR> character")) != NULL) {
X					free_ptr(modem->suffix[j]);
X					modem->suffix[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 5:
X				if ((ans = str_prompt(mo_win, 6, 40, "Hang up string", "")) != NULL) {
X					free_ptr(modem->hang_up[j]);
X					modem->hang_up[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 6:
X				if ((ans = menu_prompt(mo_win, 7, 40, "Auto Baud detect", v_yn)) != NULL) {
X					modem->auto_baud[j] = *ans;
X					ret_code++;
X				}
X				break;
X			case 7:
X				if ((ans = str_prompt(mo_win, 8, 40, "300 baud connect string", "")) != NULL) {
X					free_ptr(modem->con_3[j]);
X					modem->con_3[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 8:
X				if ((ans = str_prompt(mo_win, 9, 40, "1200 baud connect string", "")) != NULL) {
X					free_ptr(modem->con_12[j]);
X					modem->con_12[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 9:
X				if ((ans = str_prompt(mo_win, 10, 40, "2400 baud connect string", "")) != NULL) {
X					free_ptr(modem->con_24[j]);
X					modem->con_24[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 10:
X				if ((ans = str_prompt(mo_win, 11, 40, "4800 baud connect string", "")) != NULL) {
X					free_ptr(modem->con_48[j]);
X					modem->con_48[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 11:
X				if ((ans = str_prompt(mo_win, 12, 40, "9600 baud connect string", "")) != NULL) {
X					free_ptr(modem->con_96[j]);
X					modem->con_96[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 12:
X				if ((ans = str_prompt(mo_win, 13, 40, "19200 baud connect string", "")) != NULL) {
X					free_ptr(modem->con_192[j]);
X					modem->con_192[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 13:
X				if ((ans = str_prompt(mo_win, 14, 40, "No connect string 1", "")) != NULL) {
X					free_ptr(modem->no_con1[j]);
X					modem->no_con1[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 14:
X				if ((ans = str_prompt(mo_win, 15, 40, "No connect string 2", "")) != NULL) {
X					free_ptr(modem->no_con2[j]);
X					modem->no_con2[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 15:
X				if ((ans = str_prompt(mo_win, 16, 40, "No connect string 3", "")) != NULL) {
X					free_ptr(modem->no_con3[j]);
X					modem->no_con3[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			case 16:
X				if ((ans = str_prompt(mo_win, 17, 40, "No connect string 4", "")) != NULL) {
X					free_ptr(modem->no_con4[j]);
X					modem->no_con4[j] = strdup(ans);
X					ret_code++;
X				}
X				break;
X			default:
X				beep();
X		}
X					/* clear the previous prompts */
X		mvwaddstr(mo_win, 20, 12, "   ");
X		clear_line(mo_win, 21, 0, 0);
X		clear_line(mo_win, 22, 0, 0);
X		wmove(mo_win, 20, 12);
X		wrefresh(mo_win);
X	}
X	delwin(mo_win);
X	return(ret_code);
X}
X
X/*
X * Prompts for the modem name.  The user selects the currently showing
X * choice by hitting a carriage return.  Returns the modem entry number.
X * DOES NOT change the value of modem->m_cur.
X */
X
Xstatic int
Xmod_prompt(win)
XWINDOW *win;
X{
X	char ans;
X	int i;
X					/* print prompt lines */
X	mvwaddstr(win, 22, 0, "Press any key to change, or <CR> to accept");
X	mvwaddstr(win, 21, 0, "Modem name: ");
X					/* show current choice */
X	i = 0;
X	if (modem->m_cur != -1)
X		i = modem->m_cur;
X	mvwprintw(win, 21, 12, "%-30.30s", modem->mname[i]);
X	wmove(win, 21, 12);
X	wrefresh(win);
X					/* show the choices one at a time */
X	while ((ans = wgetch(win)) != '\r') {
X		i++;
X		if (*modem->mname[i] == NULL)
X			i = 0;
X		if (ans == ESC)
X			return(0);
X		mvwprintw(win, 21, 12, "%-30.30s", modem->mname[i]);
X		wmove(win, 21, 12);
X		wrefresh(win);
X	}
X					/* display the new values */
X	disp_modem(win, i);
X					/* display the name in bold */
X	clear_line(win, 2, 40, 0);
X	wrefresh(win);
X	mvwattrstr(win, 2, 40, A_BOLD, modem->mname[i]);
X	mvwprintw(win, 2, 26, "(%d of %d) ", i+1, modem->m_entries);
X
X	return(i);
X}
X
X/*
X * Show the current settings for the given modem entry number.
X */
X
Xstatic void
Xdisp_modem(w, i)
XWINDOW *w;
Xint i;
X{
X	mvwprintw(w, 2, 12, "1) Modem name ............. %-39.39s", modem->mname[i]);
X	mvwprintw(w, 2, 26, "(%d of %d) ", i+1, modem->m_entries);
X	mvwprintw(w, 3, 12, "2) Modem init string ...... %-39.39s", modem->init[i]);
X	mvwprintw(w, 4, 12, "3) Dialing command ........ %-39.39s", modem->dial[i]);
X	mvwprintw(w, 5, 12, "4) Dialing cmd suffix ..... %-39.39s", modem->suffix[i]);
X	mvwprintw(w, 6, 12, "5) Hang up string ......... %-39.39s", modem->hang_up[i]);
X	mvwprintw(w, 7, 12, "6) Auto baud detect ....... %c", modem->auto_baud[i]);
X	mvwprintw(w, 8, 12, "7) 300 baud connect ....... %-39.39s", modem->con_3[i]);
X	mvwprintw(w, 9, 12, "8) 1200 baud connect ...... %-39.39s", modem->con_12[i]);
X	mvwprintw(w, 10, 12, "9) 2400 baud connect ...... %-39.39s", modem->con_24[i]);
X	mvwprintw(w, 11, 11, "10) 4800 baud connect ...... %-39.39s", modem->con_48[i]);
X	mvwprintw(w, 12, 11, "11) 9600 baud connect ...... %-39.39s", modem->con_96[i]);
X	mvwprintw(w, 13, 11, "12) 19200 baud connect ..... %-39.39s", modem->con_192[i]);
X	mvwprintw(w, 14, 11, "13) No connect string 1 .... %-39.39s", modem->no_con1[i]);
X	mvwprintw(w, 15, 11, "14) No connect string 2 .... %-39.39s", modem->no_con2[i]);
X	mvwprintw(w, 16, 11, "15) No connect string 3 .... %-39.39s", modem->no_con3[i]);
X	mvwprintw(w, 17, 11, "16) No connect string 4 .... %-39.39s", modem->no_con4[i]);
X	return;
X}
SHAR_EOF
if test 6867 -ne "`wc -c < 's_modem.c'`"
then
	echo shar: "error transmitting 's_modem.c'" '(should have been 6867 characters)'
fi
fi
echo shar: "extracting 's_prompt.c'" '(2972 characters)'
if test -f 's_prompt.c'
then
	echo shar: "will not over-write existing file 's_prompt.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_prompt.c'
X/*
X * Prompting routines used in the setup menus.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X
X/*
X * Prompt for a string at line 21 (with optional line 22 for additional
X * information).  Display the new string in bold at its original location
X * in the menu.  Used in virtually all of the *_setup() routines.
X */
X
Xchar *
Xstr_prompt(win, y, x, p1, p2)
XWINDOW *win;
Xint y, x;
Xchar *p1, *p2;
X{
X	extern char *null_ptr;
X	char *ans, *get_str();
X					/* print first prompt last */
X	mvwaddstr(win, 22, 0, p2);
X	mvwaddstr(win, 21, 0, p1);
X	waddstr(win, ": ");
X	wrefresh(win);
X
X	if ((ans = get_str(win, 39, "", "")) == NULL)
X		return(NULL);
X					/* check the value */
X	if (!strcmp(ans, " "))
X		ans = null_ptr;
X					/* display the value in bold */
X	clear_line(win, y, x, 0);
X	wattrstr(win, A_BOLD, ans);
X
X	return(ans);
X}
X
X/*
X * Same as above, except we return a single character.
X */
X
Xchar
Xchr_prompt(win, y, x, p1, p2)
XWINDOW *win;
Xint y, x;
Xchar *p1, *p2;
X{
X	char *ans, *get_str();
X					/* print first prompt last */
X	mvwaddstr(win, 22, 0, p2);
X	mvwaddstr(win, 21, 0, p1);
X	waddstr(win, ": ");
X	wrefresh(win);
X
X	if ((ans = get_str(win, 1, "", "")) == NULL)
X		return(NULL);
X					/* display the value in bold */
X	mvwaddstr(win, y, x, "  ");
X	wrefresh(win);
X	mvwattrstr(win, y, x, A_BOLD, ans);
X
X	return(*ans);
X}
X
X/*
X * Same as above, except that it prompts for a three digit number.
X */
X
Xint
Xnum_prompt(win, y, x, p1, p2)
XWINDOW *win;
Xint y, x;
Xchar *p1, *p2;
X{
X	int i;
X					/* print first prompt last */
X	mvwaddstr(win, 22, 0, p2);
X	mvwaddstr(win, 21, 0, p1);
X	waddstr(win, ": ");
X	wrefresh(win);
X
X	if ((i = get_num(win, 3)) == -1)
X		return(-1);
X					/* display the value in bold */
X	mvwaddstr(win, y, x, "    ");
X	wrefresh(win);
X	mvwattrnum(win, y, x, A_BOLD, i);
X					/* return the number */
X	return(i);
X}
X
X/*
X * Prompts for a selection from a menu.  We display the prompt lines,
X * and show the choices one at a time.  The user selects the currently
X * showing choice by hitting a carriage return.  Unlike the similar
X * routines in d_prompt(), the first choice shown is not necessarily
X * the current.
X */
X
Xchar *v_yes[3] = {"YES", "NO", NULL};
X
Xchar *
Xmenu_prompt(win, y, x, p, menu)
XWINDOW *win;
Xint y, x;
Xchar *p, *menu[];
X{
X	char ans;
X	int i, cy, cx;
X					/* print first prompt last */
X	mvwaddstr(win, 22, 0, "Press any key to change, or <CR> to accept");
X	mvwaddstr(win, 21, 0, p);
X	waddstr(win, ": ");
X					/* show first choice */
X	i = 0;
X	getyx(win, cy, cx);
X	mvwprintw(win, cy, cx, "%-30.30s", menu[i]);
X	wmove(win, cy, cx);
X	wrefresh(win);
X					/* show the choices one at a time */
X	while ((ans = wgetch(win)) != '\r') {
X		i++;
X		if (menu[i] == NULL)
X			i = 0;
X		if (ans == ESC)
X			return(NULL);
X		mvwprintw(win, cy, cx, "%-30.30s", menu[i]);
X		wmove(win, cy, cx);
X		wrefresh(win);
X	}
X					/* display the value in bold */
X	clear_line(win, y, x, 0);
X	wattrstr(win, A_BOLD, menu[i]);
X					/* return the value */
X	return(menu[i]);
X}
SHAR_EOF
if test 2972 -ne "`wc -c < 's_prompt.c'`"
then
	echo shar: "error transmitting 's_prompt.c'" '(should have been 2972 characters)'
fi
fi
echo shar: "extracting 's_term.c'" '(3172 characters)'
if test -f 's_term.c'
then
	echo shar: "will not over-write existing file 's_term.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_term.c'
X/*
X * Display the terminal setup, query for changes.  A return code of 1
X * means something was changed, 2 means we have to kill and restart
X * the input routine.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X#include "param.h"
X#include "status.h"
X
Xint
Xterm_setup()
X{
X	WINDOW *t_win, *newwin();
X	int i, num, ret_code;
X	char *ans, *strdup(), *str_prompt(), *menu_prompt();
X	void free_ptr(), input_off(), line_set();
X	static char *v_crio[3] = {"CR", "CR/LF", NULL};
X	static char *v_duplex[3] = {"FULL", "HALF", NULL};
X	static char *v_flow[3] = {"NONE", "XON/XOFF", NULL};
X
X	t_win = newwin(23, 80, 0, 0);
X
X	horizontal(t_win, 0, 0, 32);
X	mvwattrstr(t_win, 0, 33, A_BOLD, "Terminal Setup");
X	horizontal(t_win, 0, 48, 32);
X	mvwprintw(t_win, 4, 22, "1) Hot key (decimal) ...... %d", param->hot);
X	mvwprintw(t_win, 6, 22, "2) ASCII version of hot ... %s", param->ascii_hot);
X	mvwprintw(t_win, 9, 22, "3) Duplex ................. %s", param->d_duplex);
X	mvwprintw(t_win, 11, 22, "4) Flow control ........... %s", param->flow);
X	mvwprintw(t_win, 13, 22, "5) CR translation (in) .... %s", param->cr_in);
X	mvwprintw(t_win, 15, 22, "6) CR translation (out) ... %s", param->cr_out);
X	horizontal(t_win, 19, 0, 80);
X	mvwattrstr(t_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(t_win, 20, 58, "Press <ESC> to return");
X	wmove(t_win, 20, 12);
X	touchwin(t_win);
X	wrefresh(t_win);
X					/* get the option number */
X	ret_code = 0;
X	while ((i = get_num(t_win, 1)) != -1) {
X		switch (i) {
X			case 1:
X				if ((num = num_prompt(t_win, 4, 50, "Hot key", "decimal code for the hot key")) != -1) {
X					param->hot = num;
X					ret_code = 1;
X				}
X				break;
X			case 2:
X				if ((ans = str_prompt(t_win, 6, 50, "ASCII version of hot key", "(printable version)")) != NULL) {
X					free_ptr(param->ascii_hot);
X					param->ascii_hot = strdup(ans);
X					ret_code = 1;
X				}
X				break;
X			case 3:
X				if ((ans = menu_prompt(t_win, 9, 50, "Duplex", v_duplex)) != NULL ) {
X					free_ptr(param->d_duplex);
X					param->d_duplex = strdup(ans);
X					ret_code = 1;
X				}
X				break;
X			case 4:
X				if ((ans = menu_prompt(t_win, 11, 50, "Flow control", v_flow)) != NULL ) {
X					free_ptr(param->flow);
X					param->flow = strdup(ans);
X					line_set();
X					ret_code = 1;
X				}
X				break;
X			case 5:
X				if ((ans = menu_prompt(t_win, 13, 50, "CR translation (in)", v_crio)) != NULL ) {
X					free_ptr(param->cr_in);
X
X					/*
X					 * the "add lf to cr" function is
X					 * performed by the input routine
X					 */
X					param->cr_in = strdup(ans);
X					if (!strcmp(ans, "CR/LF"))
X						status->add_lf = 1;
X					else
X						status->add_lf = 0;
X#ifdef SHAREDMEM
X					ret_code = 1;
X#else /* SHAREDMEM */
X					input_off();
X					ret_code = 2;
X#endif /* SHAREDMEM */
X				}
X				break;
X			case 6:
X				if ((ans = menu_prompt(t_win, 15, 50, "CR translation (out)", v_crio)) != NULL ) {
X					free_ptr(param->cr_out);
X					param->cr_out = strdup(ans);
X					ret_code = 1;
X				}
X				break;
X			default:
X				beep();
X		}
X		mvwaddch(t_win, 20, 12, (chtype) ' ');
X		clear_line(t_win, 21, 0, 0);
X		clear_line(t_win, 22, 0, 0);
X		wmove(t_win, 20, 12);
X		wrefresh(t_win);
X	}
X	delwin(t_win);
X	return(ret_code);
X}
SHAR_EOF
if test 3172 -ne "`wc -c < 's_term.c'`"
then
	echo shar: "error transmitting 's_term.c'" '(should have been 3172 characters)'
fi
fi
echo shar: "extracting 's_tty.c'" '(4800 characters)'
if test -f 's_tty.c'
then
	echo shar: "will not over-write existing file 's_tty.c'"
else
sed 's/^X//' << \SHAR_EOF > 's_tty.c'
X/*
X * Display the TTY setup, query for changes.  A return code of 1
X * means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X#include "modem.h"
X
Xint
Xtty_setup()
X{
X	extern char *null_ptr;
X	WINDOW *tt_win, *newwin();
X	char *strdup(), message[80];
X	int num, i, j, ret_code;
X	void disp_tty(), create_modem(), del_modem(), error_win();
X	void del_tty();
X
X	tt_win = newwin(23, 80, 0, 0);
X
X	horizontal(tt_win, 0, 0, 34);
X	mvwattrstr(tt_win, 0, 35, A_BOLD, "TTY Setup");
X	horizontal(tt_win, 0, 45, 34);
X	mvwaddstr(tt_win, 2, 22, "TTY name");
X	mvwaddstr(tt_win, 2, 37, "Modem name");
X	mvwaddstr(tt_win, 2, 51, "Init speed");
X					/* display the current TTY list */
X	disp_tty(tt_win);
X					/* prompt for options */
X	mvwprintw(tt_win, 15, 20, "%d) Add a TTY entry", NUM_TTY+1);
X	mvwprintw(tt_win, 16, 20, "%d) Delete a TTY entry", NUM_TTY+2);
X	horizontal(tt_win, 19, 0, 80);
X	mvwattrstr(tt_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(tt_win, 20, 58, "Press <ESC> to return");
X	wmove(tt_win, 20, 12);
X	touchwin(tt_win);
X	wrefresh(tt_win);
X					/* get the option number */
X	ret_code = 0;
X	while ((i = get_num(tt_win, 2)) != -1) {
X					/* if beyond t_entries, fake it */
X		if (i > modem->t_entries && i <= NUM_TTY)
X			i=999;
X					/* change an entry  */
X		if (i >= 1 && i <= NUM_TTY) {
X			if (tty_prompt(tt_win, i-1))
X				break;
X					/* requires modem update? */
X			create_modem(modem->tname[i-1]);
X			del_modem();
X
X			ret_code++;
X		}
X					/* add a entry */
X		if (i == NUM_TTY+1) {
X			if (modem->t_entries == NUM_TTY) {
X				sprintf(message, "'%s'", modem->m_path);
X				error_win(0, "No empty TTY slots in modem/TTY database", message);
X				continue;
X			}
X					/* prompt for info */
X			j = modem->t_entries;
X			if (tty_prompt(tt_win, j))
X				break;
X					/* add modem entry? */
X			modem->t_entries++;
X			create_modem(modem->tname[j]);
X
X			ret_code++;
X		}
X					/* delete an entry */
X		if (i == NUM_TTY+2) {
X			mvwaddstr(tt_win, 21, 0, "Entry number to delete: ");
X			wrefresh(tt_win);
X			while ((num = get_num(tt_win, 4)) != -1) {
X					/* valid range */
X				if (!num || num>modem->t_entries) {
X					beep();
X					mvwaddstr(tt_win, 21, 24, "   ");
X					wmove(tt_win, 21, 24);
X					wrefresh(tt_win);
X					continue;
X				}
X				del_tty(num-1);
X				del_modem();
X
X					/* show the new list */
X				disp_tty(tt_win);
X				ret_code++;
X				break;
X			}
X		}
X		if (i == 0 || i>NUM_TTY+2)
X			beep();
X		mvwaddstr(tt_win, 20, 12, "  ");
X		clear_line(tt_win, 21, 0, 0);
X		clear_line(tt_win, 22, 0, 0);
X		wmove(tt_win, 20, 12);
X		wrefresh(tt_win);
X	}
X	delwin(tt_win);
X	return(ret_code);
X}
X
X/*
X * Display the current TTY list.  No scrolling yet, so if your NUM_TTY is
X * greater than ten, this routine will need some work.
X */
X
Xstatic void
Xdisp_tty(win)
XWINDOW *win;
X{
X	int i;
X
X	for (i=0; i<NUM_TTY; i++)
X		mvwprintw(win, i+4, 20, "%2d) %-14.14s %-14.14s  %d\n",
X		 i+1, modem->tty[i], modem->tname[i], modem->init_sp[i]);
X	return;
X}
X
X/*
X * Prompt the user for the TTY database info.  A return code of 1 means a
X * user abort.  The second argument is the zero based index.
X */
X
Xstatic int
Xtty_prompt(win, i)
XWINDOW *win;
Xint i;
X{
X	char *ans, *temp_tty, *temp_tname, *str_prompt(), *menu_prompt();
X	void free_ptr();
X	static char *v_baud[8] = {"0", "300", "1200", "2400", "4800", "9600",
X	 "19200", NULL};
X					/* get temp TTY */
X	if ((ans = str_prompt(win, i+4, 24, "TTY name", "")) == NULL)
X		return(1);
X
X	temp_tty = strdup(ans);
X	clear_line(win, 21, 0, 0);
X
X					/* get temp tname */
X	if ((ans = str_prompt(win, i+4, 39, "Modem name", "")) == NULL)
X		return(1);
X
X	temp_tname = strdup(ans);
X	clear_line(win, 21, 0, 0);
X
X					/* get maximum baud */
X	if ((ans = menu_prompt(win, i+4, 55, "Init speed", v_baud)) == NULL)
X		return(1);
X
X	wrefresh(win);
X					/* store 'em for real */
X	free_ptr(modem->tty[i]);
X	free_ptr(modem->tname[i]);
X
X	modem->tty[i] = strdup(temp_tty);
X	modem->tname[i] = strdup(temp_tname);
X	modem->init_sp[i] = atoi(ans);
X
X	free_ptr(temp_tty);
X	free_ptr(temp_tname);
X	return(0);
X}
X
X/*
X * Delete a TTY entry.  Since the list must be contiguous, we collapse the
X * list to cover the hole we made.
X */
X
Xstatic void
Xdel_tty(i)
Xint i;
X{
X	extern char *null_ptr;
X	int j;
X	char *strdup();
X	void free_ptr();
X					/* collapse the list */
X	for (j=i; j<modem->t_entries-1; j++) {
X		free_ptr(modem->tty[j]);
X		free_ptr(modem->tname[j]);
X		modem->tty[j] = strdup(modem->tty[j+1]);
X		modem->tname[j] = strdup(modem->tname[j+1]);
X		modem->init_sp[j] = modem->init_sp[j+1];
X	}
X	j = modem->t_entries-1;
X					/* zap the entry */
X	free_ptr(modem->tty[j]);
X	free_ptr(modem->tname[j]);
X	modem->tty[j] = null_ptr;
X	modem->tname[j] = null_ptr;
X	modem->init_sp[j] = 0;
X					/* update the count */
X	modem->t_entries--;
X	if (modem->t_cur >= modem->t_entries)
X		modem->t_cur = -1;
X	return;
X}
SHAR_EOF
if test 4800 -ne "`wc -c < 's_tty.c'`"
then
	echo shar: "error transmitting 's_tty.c'" '(should have been 4800 characters)'
fi
fi
echo shar: "extracting 'screen.c'" '(2074 characters)'
if test -f 'screen.c'
then
	echo shar: "will not over-write existing file 'screen.c'"
else
sed 's/^X//' << \SHAR_EOF > 'screen.c'
X/*
X * Routines to read and copy the virtual screen image file.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "param.h"
X#include "status.h"
X
X/*
X * Do a screen dump.  Actually, the screen is already dumped, all we
X * do is copy the file.
X */
X
Xvoid
Xscreen_dump()
X{
X	FILE *fp_out, *my_fopen();
X	char buf[MAX_COL+2];
X	void error_win();
X#ifdef SHAREDMEM
X	int i;
X#else /* SHAREDMEM */
X	FILE *fp_in;
X#endif /* SHAREDMEM */
X					/* open for append */
X	if (!(fp_out = my_fopen(param->dumpfile, "a"))) {
X		sprintf(buf, "'%s' for write", param->dumpfile);
X		error_win(0, "Can't open screen dump file", buf);
X		return;
X	}
X#ifdef SHAREDMEM
X	for (i=0; i<LINES; i++)
X		fprintf(fp_out, "%s\n", status->vs[i]);
X
X#else /* SHAREDMEM */
X					/* not guaranteed to exist yet */
X	if (!(fp_in = my_fopen(status->vs_path, "r"))) {
X		fclose(fp_in);
X		return;
X	}
X					/* skip the x, y coordinates */
X	fgets(buf, 10, fp_in);
X
X	while (fgets(buf, MAX_COL+2, fp_in) != NULL)
X		fputs(buf, fp_out);
X
X	fclose(fp_in);
X#endif /* SHAREDMEM */
X	fclose(fp_out);
X
X	return;
X}
X
X/*
X * Read the virtual screen and paint its contents to the stdscr using
X * curses(3).  Move the cursor where it belongs.
X */
X
Xvoid
Xload_vs()
X{
X	register int i;
X#ifndef SHAREDMEM
X	FILE *fp, *my_fopen();
X	int row, col;
X	char buf[MAX_COL+2];
X#endif /* SHAREDMEM */
X
X	clearok(curscr, TRUE);
X	erase();
X#ifdef SHAREDMEM
X	for (i=0; i<LINES; i++)
X		mvaddstr(i, 0, status->vs[i]);
X
X	move(status->row, status->col);
X#else /* SHAREDMEM */
X					/* not guaranteed to exist yet */
X	if (!(fp = my_fopen(status->vs_path, "r")))
X		return;
X					/* get the x, y coordinates */
X	fgets(buf, 10, fp);
X	sscanf(buf, "%d,%d\n", &row, &col);
X
X	i = 0;
X	while (fgets(buf, MAX_COL+2, fp) != NULL) {
X					/* zap the line feed */
X		buf[COLS] = NULL;
X		mvaddstr(i++, 0, buf);
X	}
X	fclose(fp);
X	move(row, col);
X#endif /* SHAREDMEM */
X
X	refresh();
X	return;
X}
X
X/*
X * Zap the virtual screen file (or clear it)
X */
X
Xvoid
Xzap_vs()
X{
X#ifdef SHAREDMEM
X	status->clr = 1;
X#else /* SHAREDMEM */
X	unlink(status->vs_path);
X#endif /* SHAREDMEM */
X	return;
X}
SHAR_EOF
if test 2074 -ne "`wc -c < 'screen.c'`"
then
	echo shar: "error transmitting 'screen.c'" '(should have been 2074 characters)'
fi
fi
echo shar: "extracting 'st_line.c'" '(2103 characters)'
if test -f 'st_line.c'
then
	echo shar: "will not over-write existing file 'st_line.c'"
else
sed 's/^X//' << \SHAR_EOF > 'st_line.c'
X/*
X * Display the status line.  Up to now, we've never really cared how
X * large the physical screen was... but now we want the status line
X * on the bottom.
X */
X
X#include <curses.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "misc.h"
X#include "modem.h"
X#include "param.h"
X#include "status.h"
X
Xvoid
Xst_line(message)
Xchar *message;
X{
X	extern int xmc;
X	WINDOW *sl_win, *newwin();
X	int d, x, y;
X	static char *dn[2] = {"FDX", "HDX"};
X	static char *ln[2] = {"LOG OFF", "LOG ON"};
X	static char *pn[2] = {"PTR OFF", "PTR ON "};
X	char buf[80], field_one[15], *cur_tty;
X
X					/* is anybody missing? */
X	if (dir == NULL || modem == NULL || param == NULL)
X		return;
X					/* remember where we parked the car.. */
X	getyx(stdscr, y, x);
X
X	sl_win = newwin(1, 80, LINES-1, 0);
X					/* duplex message */
X	d = 0;
X	if (dir->duplex[dir->d_cur] == 'H')
X		d++;
X					/* the current TTY */
X	cur_tty = "No TTY";
X	if (modem->t_cur != -1)
X		cur_tty = modem->tty[modem->t_cur];
X
X	/*
X	 * The philosophy is:  If you press a command sequence that
X	 * doesn't generate a window on the screen, then show the user
X	 * what's going on in the status line.
X	 */
X	if (*message == NULL)
X		sprintf(field_one, " %4.4s-0 HELP  ", param->ascii_hot);
X	else
X		sprintf(field_one, " %-13.13s", message);
X
X#ifdef XMC_BROKE
X	if (xmc > 0)
X		sprintf(buf, "%s | %-9.9s| %s | %5d %c%d%d | %-7.7s | %-7.7s | %-5.5s|%-5.5s",
X		 field_one, cur_tty, dn[d], dir->baud[dir->d_cur],
X		 dir->parity[dir->d_cur], dir->dbits[dir->d_cur],
X		 dir->sbits[dir->d_cur], ln[status->log], pn[status->print],
X		 param->cr_in, param->cr_out);
X	else
X#endif /* XMC_BROKE */
X		sprintf(buf, "%s | %-9.9s| %s | %5d %c%d%d | %-7.7s | %-7.7s | %-5.5s| %-5.5s",
X		 field_one, cur_tty, dn[d], dir->baud[dir->d_cur],
X		 dir->parity[dir->d_cur], dir->dbits[dir->d_cur],
X		 dir->sbits[dir->d_cur], ln[status->log], pn[status->print],
X		 param->cr_in, param->cr_out);
X
X	if (xmc > 0) {
X		touchwin(sl_win);
X		werase(sl_win);
X		wrefresh(sl_win);
X	}
X	wattrstr(sl_win, A_STANDOUT, buf);
X	wrefresh(sl_win);
X					/* go ahead and delete it now */
X	delwin(sl_win);
X	move(y, x);
X	return;
X}
SHAR_EOF
if test 2103 -ne "`wc -c < 'st_line.c'`"
then
	echo shar: "error transmitting 'st_line.c'" '(should have been 2103 characters)'
fi
fi
echo shar: "extracting 'strings.c'" '(1329 characters)'
if test -f 'strings.c'
then
	echo shar: "will not over-write existing file 'strings.c'"
else
sed 's/^X//' << \SHAR_EOF > 'strings.c'
X/*
X * Miscellaneous string routines.
X */
X
X#include <stdio.h>
X
X/*
X * Do a fancy string copy.  If NULL, return null.  If pointer to NULL, then
X * return the special "null_ptr" variable.  If a normal copy, allocate
X * memory first.
X */
X
Xchar *
Xstrdup(str)
Xchar *str;
X{
X	extern char *null_ptr;
X	char *ret, *malloc(), *strcpy();
X
X	if (str == NULL)
X		return(NULL);
X					/* if pointer to null */
X	if (*str == NULL)
X		return(null_ptr);
X
X	ret = malloc((unsigned int) strlen(str)+1);
X	strcpy(ret, str);
X	return(ret);
X}
X
X/*
X * Perform the free(2) function, but check for NULL and the special
X * "null_ptr" variable first.
X */
X
Xvoid
Xfree_ptr(str)
Xchar *str;
X{
X	extern char *null_ptr;
X	void free();
X
X	if (str != NULL && str != null_ptr)
X		free(str);
X	return;
X}
X
X/*
X * This routine is similar to strtok(3).  But our version handles null
X * strings and takes a single separator character as an argument.
X * Returns a NULL on end of string or error.
X */
X
Xchar *
Xstr_tok(str, c)
Xchar *str, c;
X{
X	extern char *null_ptr;
X	char *strchr();
X	static char *ptr, *sep;
X					/* start at beginning */
X	if (str != NULL)
X		ptr = str;
X	else
X		ptr = sep;
X					/* at the end? */
X	if (*ptr == NULL)
X		return(NULL);
X					/* no separator? */
X	if (!(sep = strchr(ptr, c)))
X		return(NULL);
X					/* zap the sep, move past it */
X	*sep = NULL;
X	sep++;
X
X	return(ptr);
X}
SHAR_EOF
if test 1329 -ne "`wc -c < 'strings.c'`"
then
	echo shar: "error transmitting 'strings.c'" '(should have been 1329 characters)'
fi
fi
echo shar: "extracting 'terminal.c'" '(9686 characters)'
if test -f 'terminal.c'
then
	echo shar: "will not over-write existing file 'terminal.c'"
else
sed 's/^X//' << \SHAR_EOF > 'terminal.c'
X/*
X * Start the terminal dialogue, fork the input routine, watch for the
X * hot key so we can execute an option.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include <signal.h>
X#include "config.h"
X#ifdef OLDCURSES
X#include <termio.h>
X#endif /* OLDCURSES */
X#ifdef UNIXPC
X#include <sys/phone.h>
X#include <fcntl.h>
X#endif /* UNIXPC */
X#include "dial_dir.h"
X#include "misc.h"
X#include "modem.h"
X#include "param.h"
X#include "status.h"
X
Xstatic int pid = -1;
X
Xterminal(input_status)
Xint input_status;
X{
X	extern int fd;
X	int i, k, cr_lf;
X	char c, lf=10, *strdup();
X	void help_screen(), line_set(), n_shell(), load_vs(), send_str();
X	void hang_up(), do_input(), list_dir(), pexit(), zap_vs();
X	void st_line(), chg_dir(), screen_dump(), input_off(), suspend();
X	void info(), term_mode();
X
X					/* if starting out in command mode */
X	if (!input_status)
X		st_line("");
X					/* put stdin/stdout in terminal mode */
X	resetterm();
X	term_mode();
X
X	if (input_status)
X		do_input();
X
X	while (1) {
X		read(0, &c, 1);
X					/* is it the hot key? */
X		if (c == param->hot) {
X					/* suspend input */
X			input_status = 0;
X			suspend(1);
X
X			/*
X			 * Put in terminal in the curses mode, load the
X			 * virtual screen and add the status line at the bottom.
X			 */
X			fixterm();
X			load_vs();
X			st_line("");
X#ifndef OLDCURSES
X			keypad(stdscr, TRUE);
X#endif /* OLDCURSES */
X			i = wgetch(stdscr);
X					/* map an additional hot key to -1 */
X			if (i == param->hot)
X				i = -1;
X					/* look for options */
X			k = -1;
X			switch (i) {
X				case -1:	/* 2 "hots" means send 1 */
X					k = param->hot;
X					break;
X				case '0':	/* help screen */
X					help_screen(param->ascii_hot);
X					break;
X				case 'd':
X				case 'D':	/* dialing directory */
X					if (dial_menu())
X						input_status = dial_win();
X					break;
X				case 'r':
X				case 'R':	/* redial */
X					if (redial())
X						input_status = dial_win();
X					break;
X				case 'm':
X				case 'M':	/* keyboard macros */
X					macro();
X					break;
X				case 'p':
X				case 'P':	/* line settings */
X					if (ls_menu())
X						line_set();
X					break;
X				case 'x':
X				case 'X':	/* exit */
X					pexit();
X					break;
X				case '4':	/* Unix gateway */
X					n_shell();
X					break;
X				case 'i':
X				case 'I':	/* Program info screen */
X					info(0);
X					break;
X				case 's':	/* setup menu */
X				case 'S':
X					input_status = setup_menu();
X					break;
X				case 'c':	/* clear the screen */
X				case 'C':
X					zap_vs();
X					erase();
X					break;
X				case 'b':
X				case 'B':	/* Change directory */
X					chg_dir();
X					break;
X				case 'e':
X				case 'E':	/* toggle duplex */
X					if (dir->duplex[dir->d_cur] == 'F')
X						dir->duplex[dir->d_cur] = 'H';
X					else
X						dir->duplex[dir->d_cur] = 'F';
X
X						/* show changes */
X					st_line("");
X					k = wait_key(stdscr, 2);
X					break;
X				case 'h':
X				case 'H':	/* hang up phone */
X					hang_up(1);
X					input_off();
X					break;
X				case 'l':
X				case 'L':	/* toggle printer */
X					status->print = status->print ? 0 : 1;
X#ifndef SHAREDMEM
X					if (pid != -1)
X						kill(pid, SIGUSR2);
X#endif /* SHAREDMEM */
X						/* show changes */
X					st_line("");
X					k = wait_key(stdscr, 2);
X					break;
X				case '3':	/* toggle CR - CR/LF */
X					if (!strcmp(param->cr_in, "CR")) {
X						param->cr_in = strdup("CR/LF");
X						status->add_lf = 1;
X					}
X					else {
X						param->cr_in = strdup("CR");
X						status->add_lf = 0;
X					}
X#ifndef SHAREDMEM
X					input_off();
X					input_status++;
X#endif /* SHAREDMEM */
X						/* show changes */
X					st_line("");
X					k = wait_key(stdscr, 2);
X					break;
X				case '7':	/* break key */
X					if (fd != -1)
X						ioctl(fd, TCSBRK, 0);
X
X					st_line("   break");
X					break;
X#ifndef OLDCURSES
X				case KEY_UP:
X#endif /* OLDCURSES */
X				case 'u':
X				case 'U':	/* send files */
X					input_status = xfer_menu(1);
X					break;
X#ifndef OLDCURSES
X				case KEY_DOWN:
X				case '\n':
X#endif /* OLDCURSES */
X				case 'n':
X				case 'N':	/* receive files */
X					input_status = xfer_menu(0);
X					break;
X				case 't':
X				case 'T':
X					input_status = pass_thru();
X					break;
X				case 'f':
X				case 'F':	/* list directory */
X					list_dir();
X					break;
X				case 'g':	/* screen dump */
X				case 'G':
X					screen_dump();
X					st_line(" screen dump");
X					k = wait_key(stdscr, 2);
X					break;
X				case '1':	/* data logging */
X					input_status = data_logging();
X					break;
X				case '2':	/* toggle log */
X					if (!strcmp(status->log_path, "NOT_DEFINED")) {
X						beep();
X						st_line(" no log file");
X						k = wait_key(stdscr, 2);
X						break;
X					}
X					status->log = status->log ? 0 : 1;
X#ifndef SHAREDMEM
X					if (pid != -1)
X						kill(pid, SIGUSR1);
X#endif /* SHAREDMEM */
X						/* show changes */
X					st_line("");
X					k = wait_key(stdscr, 2);
X					break;
X				/*
X				 * The following are the keyboard macros
X				 * corresponding to the shifted number keys.
X				 * (Too many keys... [control] [A] [shift] [1]
X				 * is hardly a shortcut!)
X				 */
X				case '!':
X					send_str(param->mac_1);
X					break;
X				case '@':
X					send_str(param->mac_2);
X					break;
X				case '#':
X					send_str(param->mac_3);
X					break;
X				case '$':
X					send_str(param->mac_4);
X					break;
X				case '%':
X					send_str(param->mac_5);
X					break;
X				case '^':
X					send_str(param->mac_6);
X					break;
X				case '&':
X					send_str(param->mac_7);
X					break;
X				case '*':
X					send_str(param->mac_8);
X					break;
X				case '(':
X					send_str(param->mac_9);
X					break;
X				case ')':
X					send_str(param->mac_0);
X					break;
X				default:
X					fputc(BEL, stderr);
X					break;
X			}
X
X			/*
X			 * Repaint the stdscr (if we are already talking),
X			 * get the stdin/stdout out of the curses mode and
X			 * into the terminal mode.
X			 */
X			if (fd != -1) {
X				touchwin(stdscr);
X				refresh();
X			}
X			resetterm();
X			term_mode();
X
X			/*
X			 * Some of the output processing options have to be
X			 * faked...  Unfortunately, adding a LF to CR on
X			 * output is one of them.
X			 */
X			cr_lf = !strcmp(param->cr_out, "CR/LF");
X
X					/* re-start input routine */
X			if (input_status)
X				do_input();
X			else
X				suspend(0);
X
X			/*
X			 * If you pressed a key during one of the sleeping
X			 * periods (typically the delay to see the status
X			 * line change), let the keyboard value fall thru
X			 * to the write() below.
X			 */
X			if (k == -1)
X				continue;
X			c = k;
X		}
X					/* ignore errors if fd == -1 */
X		write(fd, &c, 1);
X					/* map cr to cr_lf? */
X		if (c == '\r' && cr_lf)
X			write(fd, &lf, 1);
X	}
X}
X
X/*
X * Put the stdin/stdout in terminal mode.  We've divided up the
X * responsibility for the line settings options between the serial port
X * and the stdin and stdout.
X */
X
Xvoid
Xterm_mode()
X{
X	struct termio tbuf;
X
X	ioctl(0, TCGETA, &tbuf);
X
X	tbuf.c_cc[4] = 1;		/* VMIN */
X	tbuf.c_cc[5] = 0;		/* VTIME */
X	tbuf.c_iflag = 0;
X	tbuf.c_oflag = 0;
X	tbuf.c_lflag = 0;
X					/* duplex */
X	if (dir->duplex[dir->d_cur] == 'H')
X		tbuf.c_lflag = ECHO;
X
X	ioctl(0, TCSETA, &tbuf);
X	ioctl(0, TCFLSH, 2);
X	return;
X}
X
X/*
X * Fire up the input routine...
X */
X
Xstatic void
Xdo_input()
X{
X	extern int fd;
X	void error_win();
X	char first[(sizeof(int)*8)+1];
X#ifdef SHAREDMEM
X	extern int shm_id;
X#else /* SHAREDMEM */
X	char add_lf[2], log[2], print[2];
X#endif /* SHAREDMEM */
X					/* if no TTY, or already on */
X	if (pid != -1 || fd == -1)
X		return;
X
X	status->fd = fd;
X	if (!strcmp(param->cr_in, "CR/LF"))
X		status->add_lf = 1;
X	else
X		status->add_lf = 0;
X
X#ifdef SHAREDMEM
X	sprintf(first, "%d", shm_id);
X#else /* SHAREDMEM */
X	sprintf(first, "%d", status->fd);
X	sprintf(add_lf, "%d", status->add_lf);
X	sprintf(log, "%d", status->log);
X	sprintf(print, "%d", status->print);
X#endif /* SHAREDMEM */
X
X					/* fork the input routine */
X	if (!(pid = fork())) {
X#ifdef SETUGID
X		setuid(getuid());
X		setgid(getgid());
X#endif /* SETUGID */
X#ifdef SHAREDMEM
X		execlp("pcomm_input", "pcomm_input", first, (char *) 0);
X#else /* SHAREDMEM */
X		execlp("pcomm_input", "pcomm_input", first, add_lf, log,
X		 print, status->log_path, status->vs_path, (char *) 0);
X#endif /* SHAREDMEM */
X		error_win(1, "Cannot find (or execute) the 'pcomm_input' program", "");
X	}
X
X	return;
X}
X
X/*
X * shut it down...
X */
X
Xvoid
Xinput_off()
X{
X	if (pid != -1) {
X		kill(pid, SIGTERM);
X		pid = -1;
X	}
X	return;
X}
X
X/*
X * Hang up the phone but remain in the Pcomm command state.  Uses the
X * hang_up string only, does *not* drop the DTR!
X */
X
Xvoid
Xhang_up(verbose)
Xint verbose;
X{
X	extern int fd;
X	void send_str(), st_line(), line_set();
X#ifdef UNIXPC
X	char buf[40], *strcpy(), *ttyname();
X#endif /* UNIXPC */
X					/* sanity checking */
X	if (modem == NULL)
X		return;
X					/* anything to hang up? */
X	if (modem->m_cur == -1 || fd == -1)
X		return;
X
X	if (verbose)
X		st_line("disconnecting");
X					/* special case for OBM */
X#ifdef UNIXPC
X	if (!strcmp(modem->mname[modem->m_cur], "OBM")) {
X		ioctl(fd, PIOCDISC);
X		/*
X		 * The PIOCDISC ioctl screws up the file descriptor!!!
X		 * No other phone(7) ioctl can fix it.  Whatever it does,
X		 * it seems to escape detection with PIOCGETA and TCGETA.
X		 * The best I can do is close the port and start over.
X		 */
X		strcpy(buf, ttyname(fd));
X		close(fd);
X		fd = open(buf, O_RDWR|O_NDELAY);
X		fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~O_NDELAY);
X		line_set();
X	}
X	else
X#endif /* UNIXPC */
X		send_str(modem->hang_up[modem->m_cur]);
X
X	if (verbose)
X		st_line("");
X	return;
X}
X
X/*
X * Suspend or un-suspend the input routine.  The argument is used in
X * non-shared memory configurations to give the vs_path file a fighting
X * chance of being written to disk before load_vs() reads it.
X */
X
X/*ARGSUSED*/
Xvoid
Xsuspend(on)
Xint on;
X{
X	unsigned int sleep();
X
X	if (pid == -1)
X		return;
X	kill(pid, SIGINT);
X#ifndef SHAREDMEM
X	if (on)
X		sleep(1);
X#endif /* SHAREDMEM */
X	return;
X}
SHAR_EOF
if test 9686 -ne "`wc -c < 'terminal.c'`"
then
	echo shar: "error transmitting 'terminal.c'" '(should have been 9686 characters)'
fi
fi
exit 0
#	End of shell archive

-- 
Please send comp.sources.unix-related mail to rsalz@uunet.uu.net.
