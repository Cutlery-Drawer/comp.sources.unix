From: "George W. Sherouse" <seismo!mcnc.CSNET!godot!sherouse>
Subject: lib_term - datum entry using termcap
Newsgroups: mod.sources
Approved: jpn@panda.UUCP

Mod.sources:  Volume 3, Issue 102
Submitted by: "George W. Sherouse" <seismo!mcnc.CSNET!godot!sherouse>


--------------------------- cut here ----------------------------
#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	README
#	makefile
#	term.l
#	term.h
#	ClearEOL.c
#	GetBool.c
#	GetFloat.c
#	GetHospNum.c
#	GetInt.c
#	GetString.c
#	InitTerm.c
#	MenuPick.c
#	PickOne.c
#	StandOut.c
#	TermRewind.c
#	TermSetUp.c
#	center.c
#	examp.c
#	gotoxy.c
#	page.c
#	underline.c
# This archive created: Sat Jan 25 11:42:29 1986
export PATH; PATH=/bin:$PATH
echo shar: extracting "'README'" '(984 characters)'
if test -f 'README'
then
	echo shar: will not over-write existing file "'README'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'README'
	XThis directory contains the source for a library of bullet-proof
	Xdatum-entry routines which uses the termcap library directly.  This
	Xlibrary (which I call libterm) also contains simple cursor
	Xmanipulation routines which make it a viable alternative to curses for
	Xapplications which don't require the power and overhead of curses.
	XAnother version exists which rides on top on curses (libc_term).
	X
	XThe code is rather a mess and in some cases rather inefficient.  That
	Xis a statement not an apology.  This was some of my first C code and
	Xhas been used extensively here and elsewhere with *NO* bug reports.
	XThis same code was posted to net.sources about 18 months ago and a
	Xtrickle of requests has continued since then.  If it ain't broke don't
	Xfix it.
	X
	XPermission is granted to copy and redistribute this code as long as no
	Xmoney changes hands and this notice and the authorship notes remain
	Xintact.  Let me know if you find/fix any bugs.  Enjoy.
	X
	X- George
	X<decvax!mcnc!godot!sherouse>
	X
SHAR_AND_ENJOY
if test 984 -ne "`wc -c < 'README'`"
then
	echo shar: error transmitting "'README'" '(should have been 984 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'makefile'" '(1154 characters)'
if test -f 'makefile'
then
	echo shar: will not over-write existing file "'makefile'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'makefile'
	XINCDIR = /usr/include
	XMANDIR = /usr/man/manl
	XLIBDIR = /usr/local/lib
	X
	XCFLAGS = -O
	X
	XOBJS = ClearEOL.o GetBool.o GetFloat.o GetHospNum.o GetInt.o GetString.o\
	X	InitTerm.o MenuPick.o PickOne.o StandOut.o TermRewind.o TermSetUp.o\
	X	center.o gotoxy.o page.o underline.o
	X
	Xlibterm.a: $(OBJS) makefile
	X	ar rvu libterm.a $(OBJS)
	X	ranlib libterm.a
	X
	XClearEOL.o: ClearEOL.c makefile
	XGetBool.o: GetBool.c makefile
	XGetFloat.o: GetFloat.c makefile
	XGetHospNum.o: GetHospNum.c makefile
	XGetInt.o: GetInt.c makefile
	XGetString.o: GetString.c makefile
	XInitTerm.o: InitTerm.c makefile
	XMenuPick.o: MenuPick.c makefile
	XPickOne.o: PickOne.c makefile
	XStandOut.o: StandOut.c makefile
	XTermRewind.o: TermRewind.c makefile
	XTermSetUp.o: TermSetUp.c makefile
	Xcenter.o: center.c makefile
	Xgotoxy.o: gotoxy.c makefile
	Xpage.o: page.c makefile
	Xunderline.o: underline.c makefile
	X
	Xexamp: examp.c $(INCDIR)/term.h $(LIBDIR)/libterm.a makefile
	X	cc $(CFLAGS) -o examp examp.c -lterm -ltermcap
	X
	Xinstall: libterm.a
	X	mv libterm.a $(LIBDIR)
	X	ranlib $(LIBDIR)/libterm.a
	X	cp term.h $(INCDIR)
	X
	Xinstall_man: term.l
	X	cp term.l $(MANDIR)
	X	chmod 444 $(MANDIR)/term.l
	X
	Xclean:
	X	rm -f *.o a.out core libterm.a
SHAR_AND_ENJOY
if test 1154 -ne "`wc -c < 'makefile'`"
then
	echo shar: error transmitting "'makefile'" '(should have been 1154 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'term.l'" '(5472 characters)'
if test -f 'term.l'
then
	echo shar: will not over-write existing file "'term.l'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'term.l'
	X.TH TERM L "Radiation Oncology, NCMH"
	X.UC 4
	X.SH NAME
	Xterm \- "crash-proof" datum entry routines using termcap(3x)
	X.SH SYNOPSIS
	X#include <term.h>
	X.sp
	X.B cc
	X[ flags ] files
	X.B \-lterm \-ltermcap
	X[ libraries ]
	X.SH DESCRIPTION
	XThese routines look after datum entry for the basic datum
	Xtypes and provide some cursor control.
	XA call to
	X.I InitTerm
	Xinitializes the 
	X.I term
	Xpackage by 
	Xgetting the terminal type from environment variable TERM
	Xand by reading the appropriate 
	X.I termcap
	Xentry.
	XIn typical use, the calling program would paint a screen
	Xand place the cursor at the beginning of a datum field
	Xusing 
	X.I page, gotoxy,
	Xand
	X.I printf
	Xand would then call the appropriate 
	X.I term
	Xroutine to enter or edit that datum.
	XThe field is highlighted using underline mode and the default value, if any,
	Xis displayed.
	XThe user may then enter a new value of the datum under strict field size
	Xenforcement or accept the default.
	XAcceptance of the displayed value is indicated by a RETURN.
	XThe default value can be retrieved by ^X.
	XNo abort is possible.
	XWhen the value is accepted, the field is rewritten in normal mode and with the
	Xnew value of the datum, and the cursor is left at the end of the field.
	X
	XExceptions to the above are
	X.I GetBool
	Xfor which valid inputs are n, N, y, Y, SPACE, and RETURN, for
	Xno, yes, toggle, and accept respectively,
	X.I PickOne
	Xwhich understands ^ for previous value, SPACE for next value, and RETURN
	Xfor accept,
	Xand
	X.I MenuPick
	Xwhich understands ^ for previous value, SPACE for next value, 
	X> for next page, and RETURN
	Xfor accept.
	X
	XMagic cookies are dealt with
	Xproperly but with the result that the 
	Xfield on the screen is wider
	Xthan the requested datum field
	X.I "during entry".
	XThe requested field size is used when the field is rewritten
	Xin normal mode after acceptance
	Xof a datum value.
	XThis is a feature of
	X.I term
	Xand a bug in the terminals with magic cookies.
	X.I Curses(3x)
	Xdeals with this problem by just not allowing standout mode.
	XWhich would you rather buy?
	X.SH SEE ALSO
	Xtermcap(3x)
	X.br
	Xc_term(l), if you have it
	X.SH AUTHOR
	X.nf
	XGeorge W. Sherouse
	XRadiation Oncology
	XNorth Carolina Memorial Hospital
	XUniversity of North Carolina, Chapel Hill
	X.SH FUNCTIONS
	XInitialize term.
	XReturns 0 if successful, -1 if getenv fails, -2 if tgetent cannot
	Xopen termcap file, -3 if tgetent cannot find entry for terminal.
	XIf the return is not zero, do not pass GO.
	X.br
	X	int InitTerm();
	X
	XGet a floating point number.  Imagine %(field_width).(places)f
	Xin a printf.
	X.br
	X	float GetFloat(default, field_width, places);
	X.br
	X	float default;
	X.br
	X	int field_width;
	X.br
	X	int places;
	X
	XGet an integer.
	X.br
	X	int GetInt(default, field_width);
	X.br
	X	int default;
	X.br
	X	int field_width;
	X
	XGet a boolean.
	X.br
	X	int GetBool(default);
	X.br
	X	int default;
	X
	XGet a string.  String should be at least field_size + 1 long
	Xto accomodate the appended null.  Null_ok is a boolean which
	Xdeclares whether or not a string of length zero is acceptable.
	X.br
	X	void GetString(string, field_size, null_ok);
	X.br
	X	char *string;
	X.br
	X	int field_size;
	X.br
	X	int null_ok;
	X
	XGet a hospital number in the format 00-00-00.
	X.br
	X	void GetHospNum(hosp_num);
	X.br
	X	char *hosp_num
	X
	XPick one string from a list of strings by displaying one choice at a time in
	Xthe field.
	X.br
	X	int PickOne(list, choice_count);
	X.br
	X	char **list;
	X.br
	X	int choice_count;
	X
	XA full-screen version of PickOne.  The page is cleared, the prompt is displayed
	Xat the top of the page and the first <some number> choices are displayed.
	XThe user may step through the choices with ^ and SPACE.
	XIf there are more than <some number> choices, the user may also change pages
	Xwith >.
	XRETURN accepts currently highlighted value.
	X.br
	X	int MenuPick(prompt, list, choice_count);
	X.br
	X	char *prompt;
	X.br
	X	char **list;
	X.br
	X	int choice_count;
	X
	XClear the screen.
	X.br
	X	void page();
	X
	XMove cursor.  Coordinates are 1-indexed from upper left.
	X.br
	X	void gotoxy(col, line);
	X.br
	X	int col;
	X.br
	X	int line;
	X
	XClear to end of line.
	X.br
	X	void ClearEOL();
	X
	XPrint string centered on line.  Mode == 0 requests normal print, == 1 requests
	Xunderline, and == 2 requests standout.
	X.br
	X	void center(line, string, mode);
	X.br
	X	int line;
	X.br
	X	char *string;
	X.br
	X	int mode;
	X
	XSet or clear standout mode.  Not very useful at the applications level.
	X.br
	X	void StandOut(on_or_off);
	X.br
	X	int on_or_off;
	X
	XSet or clear underline mode.  Not very useful at the applications level.
	X.br
	X	void underline(on_or_off);
	X.br
	X	int on_or_off;
	X
	XIssue some backspaces.  Not very interesting at the applications level.
	X.br
	X	void TermRewind(count);
	X.br
	X	int count;
	X
	XPlace stdin into raw mode with no echo on odd calls and restore original modes
	Xon even calls.
	XReturn the terminal's erase character.
	XNot intended for use at the applications level.
	X.br
	X	char TermSetUp();
	X.SH BUGS
	XMany sorts of stupidity are not checked for.
	XThese include but are not limited to string longer than terminal width in
	X.I center,
	Xline or col out of bounds in
	X.I center
	Xor
	X.I gotoxy,
	Xfractional part longer than field_size in
	X.I GetFloat,
	Xand 0 or negative field_size anywhere.
	X
	XSome unreasonable assumptions are made regarding sanity in the termcap.
	XYou will know what they are if you violate them.
	XI apologize in advance.
	X
	X.I GetFloat
	Xdoes not support scientific notation.
	XIt also does not let you back up over the decimal point once it has placed
	Xit.
	XThis is no great hardship since you can always ^X to restart.
	X
	XSome of the code is a little ugly, having been hacked unmercifully through many
	Xrevisions.
	XIt does seem to work, though.
SHAR_AND_ENJOY
if test 5472 -ne "`wc -c < 'term.l'`"
then
	echo shar: error transmitting "'term.l'" '(should have been 5472 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'term.h'" '(263 characters)'
if test -f 'term.h'
then
	echo shar: will not over-write existing file "'term.h'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'term.h'
	Xvoid ClearEOL();
	Xint GetBool();
	Xfloat GetFloat();
	Xvoid GetHospNum();
	Xint GetInt();
	Xvoid GetString();
	Xint InitTerm();
	Xint MenuPick();
	Xint PickOne();
	Xvoid StandOut();
	Xvoid TermRewind();
	Xchar TermSetUp();
	Xvoid center();
	Xvoid gotoxy();
	Xvoid page();
	Xvoid underline();
SHAR_AND_ENJOY
if test 263 -ne "`wc -c < 'term.h'`"
then
	echo shar: error transmitting "'term.h'" '(should have been 263 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'ClearEOL.c'" '(832 characters)'
if test -f 'ClearEOL.c'
then
	echo shar: will not over-write existing file "'ClearEOL.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'ClearEOL.c'
	X
	Xvoid ClearEOL()
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X 	30 March 1984 - GWS
	X 
	X 
	X   NAME
	X 	ClearEOL - clear to the end of line
	X 
	X   SYNOPSIS
	X	void ClearEOL() 
	X 
	X   DESCRIPTION
	X	Uses termcap(3x) routines to clear terminal screen. 
	X 
	X   SEE ALSO
	X	termcap(3) 
	X 
	X   DIAGNOSTICS
	X	If the screen doesn't clear, it didn't work. 
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	30 March 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X    static called = 0;
	X    static char id[] = "ce", page_str[10];
	X    static char *point = page_str, **point2 = &point;
	X    extern char bp[1024];
	X    int tgetent(), tputs();
	X    int putchar();
	X
	X    if (!called)
	X    {
	X	tgetstr(id, point2);
	X	called++;
	X    }
	X
	X    (void) tputs(page_str, 1, putchar);
	X    return;
	X}
SHAR_AND_ENJOY
if test 832 -ne "`wc -c < 'ClearEOL.c'`"
then
	echo shar: error transmitting "'ClearEOL.c'" '(should have been 832 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'GetBool.c'" '(1495 characters)'
if test -f 'GetBool.c'
then
	echo shar: will not over-write existing file "'GetBool.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'GetBool.c'
	X#include <stdio.h>
	X#include <ctype.h>
	X
	Xint GetBool(Default)
	Xint Default;
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X	16 November 1984 - GWS
	X	Ignore XON, XOFF
	X
	X 	11 April 1984 - GWS
	X 
	X 
	X   NAME
	X 	GetBool - "crash-proof" routine for terminal input of boolean
	X 
	X   SYNOPSIS
	X	int GetHospNum(Default)
	X	int Default;
	X 
	X   DESCRIPTION
	X	This routine prompts and nudges the user through entry of a
	X	boolean value.
	X 
	X   SEE ALSO
	X 
	X 
	X   DIAGNOSTICS
	X	none 
	X 
	X   BUGS
	X	none known
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	11 April 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X    int c;
	X    char erase;
	X    int val;
	X    int cookie;
	X
	X    void underline();
	X    int tgetnum();
	X    char TermSetUp();
	X    void TermRewind();
	X
	X    if ((cookie = tgetnum("ug")) < 0)
	X	cookie = 0;
	X
	X    underline(1);
	X    printf("   ");
	X
	X    if (cookie)
	X    {
	X	underline(0);
	X	TermRewind(cookie);
	X    }
	X
	X    erase = TermSetUp();	/* set no echo, single char input */
	X    				/* get erase character */
	X    val = Default;
	X    while (1)
	X    {
	X	    if (val)
	X		printf("\b\b\byes");
	X	    else
	X		printf("\b\b\bno ");
	X
	X	switch (c = (getchar() & 0177))
	X	{
	X	case '\015':
	X	    underline(0);
	X	    TermSetUp();
	X	    return(val);
	X	case ' ':
	X	    val = !val;
	X	    break;
	X	case 'y':
	X	case 'Y':
	X	    val = 1;
	X	    break;
	X	case 'n':
	X	case 'N':
	X	    val = 0;
	X	    break;
	X	case '\021':
	X	case '\023':
	X	    break;
	X	default:
	X	    printf("%c", '\007');
	X	}
	X    }
	X}
SHAR_AND_ENJOY
if test 1495 -ne "`wc -c < 'GetBool.c'`"
then
	echo shar: error transmitting "'GetBool.c'" '(should have been 1495 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'GetFloat.c'" '(4407 characters)'
if test -f 'GetFloat.c'
then
	echo shar: will not over-write existing file "'GetFloat.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'GetFloat.c'
	X#include <stdio.h>
	X#include <ctype.h>
	X
	Xfloat GetFloat(Default, field_width, places)
	Xfloat Default;
	Xint field_width, places;
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X	16 November 1984 - GWS
	X	Ignore XON, XOFF
	X
	X 	11 April 1984 - GWS
	X 
	X 
	X   NAME
	X 	GetFloat - "crash-proof" float from keyboard routine
	X 
	X   SYNOPSIS
	X	float GetFloat(Default, field_width, places)
	X	float Default;
	X	int field_width, places;
	X
	X   DESCRIPTION
	X	On a good day this routine will get a real value from the
	X	keyboard and return it safely.  The terminal is placed in raw
	X	mode and most non-digit values are beeped at and discarded.  Entry
	X	is terminated by filling the field or by CR.  CR as first character
	X	assumes Default.  ^X restarts.
	X 
	X   SEE ALSO
	X 
	X 
	X   DIAGNOSTICS
	X	none - cannot fail :-) 
	X 
	X   BUGS
	X	Doesn't check for silly things like Default too big to fit in
	X	field_width, etc.  Watch out for that minus sign!!
	X	
	X	Exponential notation is not supported.
	X
	X	This version does not let you erase over the decimal point if
	X	the integer part of the field is already full.  This is not a
	X	terrible hardship because you are free to ^X and start over,
	X	but it really should be fixed.
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	9 April 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X	int c;
	X	float val;
	X	int loop;
	X	char line_buff[20];
	X	char Format[80];
	X	char erase, pad;
	X	int point, frac_count;
	X	int count;
	X	int cookie;
	X	int int_part;
	X
	X	void underline();
	X	void f_clean_up();
	X	char TermSetUp();
	X	int tgetnum();
	X	void TermRewind();
	X
	X	pad = ' ';
	X	point = 0;
	X	frac_count = 0 ;
	X	if ((cookie = tgetnum("ug")) < 0)
	X	    cookie = 0;
	X
	X	underline(1);
	X
	X	for (loop = 0; loop < field_width; loop++)
	X	    printf(" ");
	X	if (cookie)
	X	{
	X	    underline(0);
	X	    TermRewind(cookie);
	X	}
	X	TermRewind(field_width);
	X
	X	sprintf(Format, "%%%d.%df", field_width, places);
	X	printf(Format, Default);
	X	TermRewind(field_width);
	X	for (loop = 0; loop <= field_width; loop++)
	X	    line_buff[loop] = 0;
	X
	X	erase = TermSetUp();	/* set no echo, single char input */
	X				/* get erase character */
	X	count = 0;
	X	int_part = field_width - places - 1;
	X	while (1)
	X	{
	X	    if (!point && count == int_part)
	X	    {
	X		printf(".");
	X		line_buff[count++] = '.';
	X		point++;
	X		continue;
	X	    }
	X
	X	    switch (c = (getchar() & 0177))
	X	    {
	X	    case '\015':
	X		if (count && line_buff[count - 1] != '-')
	X		{
	X		    sscanf(line_buff, "%f", &val);
	X		    f_clean_up(count, field_width, Format, val);
	X		    return(val);
	X		}
	X		else
	X		{
	X		    f_clean_up(count, field_width, Format, Default);
	X		    return(Default);
	X		}
	X		break;
	X	    case 030:
	X		TermRewind(count);
	X		for (loop = 0; loop < field_width; loop++)
	X		    line_buff[loop] = 0;
	X		count = frac_count = point = 0;
	X		printf(Format, Default);
	X		TermRewind(field_width);
	X		break;
	X	    case '.':
	X		if (!point)
	X		{
	X		    if (!count)
	X		    {
	X			for (loop = 0; loop < field_width; loop++)
	X			    printf("%c", pad);
	X			TermRewind(field_width);
	X			for (loop = 0; loop < field_width; loop++)
	X			    line_buff[loop] = 0;
	X		    }
	X		    printf(".");
	X		    line_buff[count++] = '.';
	X		    point++;
	X		    break;
	X		}
	X	    case '\021':
	X	    case '\023':
	X		break;
	X	    default:
	X		if (c == erase && count)
	X		{
	X		    printf("\b%c\b", pad);
	X		    if (point)
	X		    {
	X			if (frac_count)
	X			    frac_count--;
	X			else
	X			    point--;
	X		    }
	X		    line_buff[--count] = 0;
	X		    break;
	X		}
	X
	X		if (!count && c == '-')
	X		{
	X		    for (loop = 0; loop < field_width; loop++)
	X			printf("%c", pad);
	X		    TermRewind(field_width);
	X		    for (loop = 0; loop < field_width; loop++)
	X		        line_buff[loop] = 0;
	X
	X		    line_buff[count++] = (char) c;
	X		    printf("-");
	X		    break;
	X		}
	X
	X		if (isdigit(c) && count < field_width && frac_count < places)
	X		{
	X		    if (!count)
	X		    {
	X			for (loop = 0; loop < field_width; loop++)
	X			    printf("%c", pad);
	X			TermRewind(field_width);
	X			for (loop = 0; loop < field_width; loop++)
	X			    line_buff[loop] = 0;
	X		    }
	X		    printf("%c", c);
	X		    line_buff[count++] = (char) c;
	X		    if (point)
	X			frac_count++;
	X		}
	X		else
	X		    printf("%c", '\007');
	X	    }
	X	}
	X}
	X
	Xvoid f_clean_up(count, field_width, Format, val)
	Xint count, field_width;
	Xchar *Format;
	Xfloat val;
	X
	X{
	X    int loop;
	X    void underline();
	X    char TermSetUp();
	X    void TermRewind();
	X
	X    TermRewind(count);
	X    printf(Format, val);
	X
	X    underline(0);
	X    (void) TermSetUp();
	X}
SHAR_AND_ENJOY
if test 4407 -ne "`wc -c < 'GetFloat.c'`"
then
	echo shar: error transmitting "'GetFloat.c'" '(should have been 4407 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'GetHospNum.c'" '(2127 characters)'
if test -f 'GetHospNum.c'
then
	echo shar: will not over-write existing file "'GetHospNum.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'GetHospNum.c'
	X#include <stdio.h>
	X#include <ctype.h>
	X
	Xvoid GetHospNum(HospNum)
	Xchar *HospNum;
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X	16 November 1984 - GWS
	X	Ignore XON, XOFF
	X
	X 	11 April 1984 - GWS
	X 
	X 
	X   NAME
	X 	GetHospNum - "crash-proof" routine for terminal input of ##-##-##
	X 
	X   SYNOPSIS
	X	void GetHospNum(HospNum)
	X	char *HospNum;
	X 
	X   DESCRIPTION
	X	This routine prompts and nudges the user through entry of a
	X	hospital number in the proper format.
	X 
	X   SEE ALSO
	X 
	X 
	X   DIAGNOSTICS
	X	none 
	X 
	X   BUGS
	X	Doesn't do any validity checking on the number, only the format. 
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	9 April 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X    int c;
	X    char erase;
	X    int count;
	X    int cookie;
	X
	X    void underline();
	X    int tgetnum();
	X    char TermSetUp();
	X    void TermRewind();
	X
	X    if ((cookie = tgetnum("ug")) < 0)
	X	cookie = 0;
	X
	X    underline(1);
	X
	X    printf("  -  -  ");
	X    if (cookie)
	X    {
	X	underline(0);
	X	TermRewind(cookie);
	X    }
	X    TermRewind(8);
	X
	X    erase = TermSetUp();	/* set no echo, single char input */
	X    				/* get erase character */
	X    count = 0;
	X    while (1)
	X    {
	X	switch (count)
	X	{
	X	case 2:
	X	case 5:
	X	    printf("-");
	X	    HospNum[count++] = '-';
	X	    break;
	X	default:
	X	    switch (c = (getchar() & 0177))
	X	    {
	X	    case '\015':
	X		if (count == 8)
	X		{
	X		    HospNum[8] = (char) 0;
	X		    underline(0);
	X		    TermSetUp();
	X		    return;
	X		}
	X		else
	X		{
	X		    printf("%c", '\007');
	X		    break;
	X		}
	X	    case 030:
	X		TermRewind(count);
	X		printf("  -  -  ");
	X		count = 0;
	X		TermRewind(8);
	X		break;
	X	    case '\021':
	X	    case '\023':
	X		break;
	X	    default:
	X		if (c == erase && count)
	X		{
	X		    switch (count)
	X		    {
	X		    case 3:
	X		    case 6:
	X			printf("\b");
	X			count--;
	X		    case 1:
	X		    case 2:
	X		    case 4:
	X		    case 5:
	X		    case 7:
	X		    case 8:
	X			printf("\b \b");
	X			HospNum[--count] = 0;
	X			break;
	X		    }
	X		    break;
	X		}
	X
	X		if (isdigit(c) && count < 8)
	X		{
	X		    printf("%c", c);
	X		    HospNum[count++] = (char) c;
	X		}
	X		else
	X		    printf("%c", '\007');
	X	    }
	X	}
	X    }
	X}
SHAR_AND_ENJOY
if test 2127 -ne "`wc -c < 'GetHospNum.c'`"
then
	echo shar: error transmitting "'GetHospNum.c'" '(should have been 2127 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'GetInt.c'" '(3374 characters)'
if test -f 'GetInt.c'
then
	echo shar: will not over-write existing file "'GetInt.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'GetInt.c'
	X#include <stdio.h>
	X#include <ctype.h>
	X
	Xint GetInt(Default, field_width)
	Xint Default, field_width;
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X	16 November 1984 - GWS
	X	Ignore XON, XOFF
	X
	X 	11 April 1984 - GWS
	X 
	X 
	X   NAME
	X 	GetInt - "crash-proof" integer from keyboard routine
	X 
	X   SYNOPSIS
	X	int GetInt(Default, field_width)
	X	int Default, field_width;
	X 
	X   DESCRIPTION
	X	On a good day this routine will get an integer value from the
	X	keyboard and return it safely.  The terminal is placed in raw
	X	mode and most non-digit values are beeped at and discarded.  Entry
	X	is terminated by filling the field or by CR.  CR as first character
	X	assumes Default.  ^X restarts.
	X 
	X   SEE ALSO
	X	TermSetUp, TermRewind 
	X 
	X   DIAGNOSTICS
	X	none - cannot fail :-) 
	X 
	X   BUGS
	X	Doesn't check for silly things like Default too big to fit in
	X	field_width, etc.  Let's be particularly careful out there.
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	6 April 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X	int c, val;
	X	int loop;
	X	char line_buff[20];
	X	char Format[80];
	X	char erase, pad;
	X	int count;
	X	int cookie;
	X
	X	void underline();
	X	void clean_up();
	X	int tgetnum();
	X	char TermSetUp();
	X	void TermRewind();
	X
	X	pad = ' ';
	X	if ((cookie = tgetnum("ug")) < 0)
	X	    cookie = 0;
	X
	X	underline(1);
	X
	X	for (loop = 0; loop < field_width; loop++)
	X	    printf(" ");
	X	if (cookie)
	X	{
	X	    underline(0);
	X	    TermRewind(cookie);
	X	}
	X	TermRewind(field_width);
	X
	X	sprintf(Format, "%%%dd", field_width);
	X	printf(Format, Default);
	X	TermRewind(field_width);
	X	for (loop = 0; loop <= field_width; loop++)
	X	    line_buff[loop] = 0;
	X
	X	erase = TermSetUp();	/* set no echo, single char input */
	X				/* get erase character */
	X	count = 0;
	X	while (1)
	X	{
	X	    switch (c = (getchar() & 0177))
	X	    {
	X	    case '\015':
	X		if (count && line_buff[count - 1] != '-')
	X		{
	X		    sscanf(line_buff, "%d", &val);
	X		    clean_up(count, field_width, Format, val);
	X		    return(val);
	X		}
	X		else
	X		{
	X		    clean_up(count, field_width, Format, Default);
	X		    return(Default);
	X		}
	X		break;
	X	    case 030:
	X		TermRewind(count);
	X		for (loop = 0; loop < field_width; loop++)
	X		    line_buff[loop] = 0;
	X		count = 0;
	X		printf(Format, Default);
	X		TermRewind(field_width);
	X		break;
	X	    case '\021':
	X	    case '\023':
	X		break;
	X	    default:
	X		if (c == erase && count)
	X		{
	X		    printf("\b%c\b", pad);
	X		    line_buff[--count] = 0;
	X		    break;
	X		}
	X
	X		if (!count && c == '-')
	X		{
	X		    for (loop = 0; loop < field_width; loop++)
	X			printf("%c", pad);
	X		    TermRewind(field_width);
	X		    for (loop = 0; loop < field_width; loop++)
	X		        line_buff[loop] = 0;
	X
	X		    line_buff[count++] = (char) c;
	X		    printf("-");
	X		    break;
	X		}
	X
	X		if (isdigit(c) && count < field_width)
	X		{
	X		    if (!count)
	X		    {
	X			for (loop = 0; loop < field_width; loop++)
	X			    printf("%c", pad);
	X			TermRewind(field_width);
	X			for (loop = 0; loop < field_width; loop++)
	X			    line_buff[loop] = 0;
	X		    }
	X		    printf("%c", c);
	X		    line_buff[count++] = (char) c;
	X		}
	X		else
	X		    printf("%c", '\007');
	X	    }
	X	}
	X}
	X
	Xvoid clean_up(count, field_width, Format, val)
	Xint count, field_width;
	Xchar *Format;
	Xint val;
	X
	X{
	X    int loop;
	X    void underline();
	X    char TermSetUp();
	X    void TermRewind();
	X
	X    TermRewind(count);
	X    printf(Format, val);
	X
	X    underline(0);
	X    (void) TermSetUp();
	X}
SHAR_AND_ENJOY
if test 3374 -ne "`wc -c < 'GetInt.c'`"
then
	echo shar: error transmitting "'GetInt.c'" '(should have been 3374 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'GetString.c'" '(2149 characters)'
if test -f 'GetString.c'
then
	echo shar: will not over-write existing file "'GetString.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'GetString.c'
	X#include <stdio.h>
	X#include <ctype.h>
	X
	Xvoid GetString(string, size, nullOK)
	Xchar *string;
	Xint size;
	Xint nullOK;
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X	16 November 1984 - GWS
	X	Ignore XON, XOFF
	X
	X 	11 April 1984 - GWS
	X 
	X 
	X   NAME
	X 	GetString - "crash-proof" routine for terminal input of string
	X 
	X   SYNOPSIS
	X	void GetString(string, size, nullOK)
	X	char *string;
	X	int size;
	X	int nullOK;
	X 
	X   DESCRIPTION
	X	This routine prompts and nudges the user through entry of a
	X	character string.  'Size' is the number of characters in'string'.
	X	'String' should therefore be dimensioned to size + 1.
	X	'NullOK' is a boolean that tells us whether a null string is
	X	acceptable.
	X 
	X   SEE ALSO
	X 
	X 
	X   DIAGNOSTICS
	X	none 
	X 
	X   BUGS
	X	none known
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	11 April 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X    int c;
	X    char erase;
	X    int loop;
	X    int cookie;
	X    int count;
	X
	X    void underline();
	X    int tgetnum();
	X    char TermSetUp();
	X    void TermRewind();
	X
	X    if ((cookie = tgetnum("ug")) < 0)
	X	cookie = 0;
	X
	X    underline(1);
	X    for (loop = 0; loop < size; loop++)
	X    {
	X	printf(" ");
	X	string[loop] = (char) 0;
	X    }
	X    string[size] = (char) 0;
	X
	X    if (cookie)
	X    {
	X	underline(0);
	X	TermRewind(cookie);
	X    }
	X    TermRewind(size);
	X
	X    erase = TermSetUp();	/* set no echo, single char input */
	X    				/* get erase character */
	X
	X    count = 0;
	X    while (1)
	X    {
	X	switch (c = (getchar() & 0177))
	X	{
	X	case '\015':
	X	    if (count || nullOK)
	X	    {
	X		for (loop = count; loop < size; loop++)
	X		    printf(" ");
	X		underline(0);
	X		(void) TermSetUp();
	X		return;
	X	    }
	X	    else
	X	    {
	X		printf("%c", '\007');
	X		break;
	X	    }
	X	case '\030':
	X	    while (count)
	X	    {
	X		string[--count] = (char) 0;
	X		printf("\b \b");
	X	    }
	X	    break;
	X	case '\021':
	X	case '\023':
	X	    break;
	X	default:
	X	    if (count && c == erase)
	X	    {
	X		printf("\b \b");
	X		string[--count] = (char) 0;
	X		break;
	X	    }
	X
	X	    if (isprint(c) && count < size)
	X	    {
	X		printf("%c", c);
	X		string[count++] = c;
	X		break;
	X	    }
	X
	X	    printf("%c", '\007');
	X	}
	X    }
	X}
SHAR_AND_ENJOY
if test 2149 -ne "`wc -c < 'GetString.c'`"
then
	echo shar: error transmitting "'GetString.c'" '(should have been 2149 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'InitTerm.c'" '(1074 characters)'
if test -f 'InitTerm.c'
then
	echo shar: will not over-write existing file "'InitTerm.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'InitTerm.c'
	X#include <stdio.h>
	X
	Xchar bp[1024];
	X
	Xint InitTerm()
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X 	30 March 1984 - GWS
	X 
	X 
	X   NAME
	X 	InitTerm - initialize data area for screen handling routines
	X 
	X   SYNOPSIS
	X	InitTerm() 
	X 
	X   DESCRIPTION
	X	Calls getenv to find out what terminal type to use and
	X	then calls tgetent to initialize the string containing
	X	the termcap.
	X 
	X   SEE ALSO
	X	termcap(3x), page, gotoxy, underline, stand_out, clear_eol 
	X 
	X   DIAGNOSTICS
	X	Returns 0 if successful
	X	       -1 if getenv fails
	X	       -2 if tgetent cannot open termcap file
	X	       -3 if tgetent cannot find entry for terminal
	X 
	X   BUGS
	X	none known 
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	30 March 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X
	X{
	X    int tgetent(), ret;
	X    char *getenv(), *cret;
	X
	X    cret = getenv("TERM");
	X    if (cret == NULL)
	X	return(-1);
	X
	X    ret = tgetent(bp, cret);
	X    switch (ret)
	X    {
	X    case -1:
	X	return(-2);
	X    case 0:
	X	return(-3);
	X    case 1:
	X	return(0);
	X    }
	X}
SHAR_AND_ENJOY
if test 1074 -ne "`wc -c < 'InitTerm.c'`"
then
	echo shar: error transmitting "'InitTerm.c'" '(should have been 1074 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'MenuPick.c'" '(4175 characters)'
if test -f 'MenuPick.c'
then
	echo shar: will not over-write existing file "'MenuPick.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'MenuPick.c'
	X#include <stdio.h>
	X#include <ctype.h>
	X#include <strings.h>
	X#include "term.h"
	X
	X#define TRUE 1
	X#define FALSE 0
	X#define BASE 3
	X
	Xint MenuPick(Prompt, ChoiceList, ChoiceCount)
	Xchar *Prompt;
	Xchar **ChoiceList;
	Xint ChoiceCount;
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X 	23 October 1984 - GWS
	X 
	X 
	X   NAME
	X 	MenuPick - "crash-proof" routine for picking one of a list of strings
	X 
	X   SYNOPSIS
	X	int MenuPick(Prompt, ChoiceList, ChoiceCount)
	X	char *Prompt;
	X	char **ChoiceList;
	X	int ChoiceCount;
	X 
	X   DESCRIPTION
	X	This routine prompts and nudges the user through selection of a
	X	string from a table of strings - useful for choosing an item
	X	from a menu for instance.  The options are displayed in a menu
	X	format with one at a time highlighted.  The current item is
	X	selected by pressing RETURN.  The space bar advances, the 
	X	up-arrow backs up.  The return value of the function is the
	X	index of the chosen string (0 indexed).
	X 
	X   SEE ALSO
	X 
	X 
	X   DIAGNOSTICS
	X	none 
	X 
	X   BUGS
	X	none known
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	22 October 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X	int	c,
	X		start,
	X		stop,
	X		select;
	X
	X/*
	XIn the silly case where there is only one choice, just return the index 0.
	X*/
	X    if (ChoiceCount == 1)
	X	return(0);
	X
	X    select = 0;
	X    paint_screen(Prompt, ChoiceList, ChoiceCount, &start, &stop, select, TRUE);
	X    while (1)
	X    {
	X	switch (c = (getchar() & 0x7f))
	X	{
	X	case '\015':
	X	    TermSetUp();
	X	    return(select);
	X	case ' ':
	X	    if (++select == ChoiceCount)
	X		select = 0;
	X	    paint_screen(Prompt, ChoiceList, ChoiceCount, &start, &stop,
	X			select, FALSE);
	X	    break;
	X	case '^':
	X	    if (--select < 0)
	X		select = ChoiceCount - 1;
	X	    paint_screen(Prompt, ChoiceList, ChoiceCount, &start, &stop,
	X			select, FALSE);
	X	    break;
	X	case '>':
	X	    select = stop + 1;
	X	    if (select == ChoiceCount)
	X		select = 0;
	X	    paint_screen(Prompt, ChoiceList, ChoiceCount, &start, &stop,
	X			select, FALSE);
	X	    break;
	X	case '\021':
	X	case '\023':
	X	    break;
	X	default:
	X	    printf("%c", '\007');
	X	}
	X    }
	X}
	X
	Xpaint_screen(Prompt, ChoiceList, ChoiceCount, start, stop, select, first)
	Xchar *Prompt;
	Xchar **ChoiceList;
	Xint ChoiceCount;
	Xint *start;
	Xint *stop;
	Xint select;
	Xint first;
	X
	X{
	X    int		tgetnum();
	X
	X    static int	too_many = FALSE,
	X		current,
	X		previous,
	X		old_start,
	X		cookie;
	X
	X    int		loop,
	X		loop1,
	X		line,
	X		temp;
	X
	X    char	erase;
	X
	X    if (first)
	X    {
	X
	X/*
	XFind out if we need to cope with magic cookies.
	X*/
	X	if ((cookie = tgetnum("ug")) < 0)
	X	    cookie = 0;
	X
	X	if (ChoiceCount > 15)
	X	    too_many = TRUE;
	X
	X	current = old_start = -1;
	X	previous = *start = 0;
	X	if (too_many)
	X	    *stop = 14;
	X	else
	X	    *stop = ChoiceCount - 1;
	X
	X	erase = TermSetUp();	/* set no echo, single char input */
	X    				/* get erase character */
	X
	X	first = FALSE;
	X    }
	X    else
	X    {
	X	if (select < *start)
	X	    *start -= 15;
	X	if (select > *stop)
	X	    *start += 15;
	X	if (*start >= ChoiceCount)
	X	    *start = 0;
	X	if (*start < 0)
	X	    *start = ((ChoiceCount - 1) / 15) * 15;
	X
	X	*stop = *start + 14;
	X	if (*stop >= ChoiceCount)
	X	    *stop = ChoiceCount - 1;
	X    }
	X
	X/*
	XClear the stage for the action
	X*/
	X    if (*start == old_start)
	X    {
	X	gotoxy(1, BASE + previous);
	X	ClearEOL();
	X	gotoxy(1, BASE + previous);
	X	for (loop = 0; loop < cookie; loop++)
	X	    printf(" ");
	X	printf("%s", ChoiceList[*start + previous]);
	X
	X	current = select - *start;
	X	gotoxy(1, BASE + current);
	X	ClearEOL();
	X	gotoxy(1, BASE + current);
	X	underline(TRUE);
	X	printf("%s", ChoiceList[*start + current]);
	X	underline(FALSE);
	X
	X	previous = current;
	X    }
	X    else
	X    {
	X	page();
	X	center(1, Prompt, 1);
	X	line = BASE;
	X
	X	for (loop = *start; loop <= *stop; loop++)
	X	{
	X	    gotoxy(1, line++);
	X	    if (loop == select)
	X	    {
	X		underline(TRUE);
	X		printf("%s", ChoiceList[loop]);
	X		underline(FALSE);
	X	    }
	X	    else
	X	    {
	X		for (loop1 = 0; loop1 < cookie; loop1++)
	X		    printf(" ");
	X		printf("%s", ChoiceList[loop]);
	X	    }
	X	}
	X	previous = select - *start;
	X	old_start = *start;
	X    }
	X
	X    gotoxy(1, 23);
	X    printf("Press RETURN to accept, SPACE to step forward, ^ to back up");
	X    if (too_many)
	X	printf(", > for next page");
	X}
SHAR_AND_ENJOY
if test 4175 -ne "`wc -c < 'MenuPick.c'`"
then
	echo shar: error transmitting "'MenuPick.c'" '(should have been 4175 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'PickOne.c'" '(2497 characters)'
if test -f 'PickOne.c'
then
	echo shar: will not over-write existing file "'PickOne.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'PickOne.c'
	X#include <stdio.h>
	X#include <ctype.h>
	X#include <strings.h>
	X
	Xint PickOne(ChoiceList, ChoiceCount)
	Xchar **ChoiceList;
	Xint ChoiceCount;
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X	16 November 1984 - GWS
	X	Ignore XON, XOFF
	X
	X 	12 April 1984 - GWS
	X 
	X 
	X   NAME
	X 	PickOne - "crash-proof" routine for picking one of a list of
	X		  list of strings
	X 
	X   SYNOPSIS
	X	int PickOne(ChoiceList, ChoiceCount)
	X	char **ChoiceList;
	X	int ChoiceCount;
	X 
	X   DESCRIPTION
	X	This routine prompts and nudges the user through selection of a
	X	string from a table of strings - useful for choosing an item
	X	from a menu for instance.  The options are displayed one at a
	X	time.  The current item is selected by pressing return.  The
	X	space bar advances, the up-arrow backs up.  The return
	X	value of the function is the index of the chosen string.
	X 
	X   SEE ALSO
	X 
	X 
	X   DIAGNOSTICS
	X	none 
	X 
	X   BUGS
	X	none known
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	11 April 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X    int c;
	X    char erase;
	X    int val;
	X    int cookie;
	X    int biggest;
	X    int temp;
	X    int loop;
	X    char Format[80];
	X
	X    void underline();
	X    int tgetnum();
	X    char TermSetUp();
	X    void TermRewind();
	X    int strlen();
	X
	X/*
	XIn the silly case where there is only one choice, just print it
	Xand return the index 0.
	X*/
	X    if (ChoiceCount == 1)
	X    {
	X	underline(1);
	X	printf("%s", ChoiceList[0]);
	X	underline(0);
	X	return(0);
	X    }
	X/*
	XFind the longest string in the bunch
	X*/
	X    biggest = strlen(ChoiceList[0]);
	X    for (loop = 1; loop < ChoiceCount; loop++)
	X	if ((temp = strlen(ChoiceList[loop])) > biggest)
	X	    biggest = temp;
	X
	X/*
	XFind out if we need to cope with magic cookies.
	X*/
	X    if ((cookie = tgetnum("ug")) < 0)
	X	cookie = 0;
	X
	X    underline(1);
	X    for (loop = 0; loop < biggest; loop++)
	X	printf(" ");
	X
	X    if (cookie)
	X    {
	X	underline(0);
	X	TermRewind(cookie);
	X    }
	X
	X    erase = TermSetUp();	/* set no echo, single char input */
	X    				/* get erase character */
	X    sprintf(Format, "%%-%ds", biggest);
	X
	X    val = 0;
	X    while (1)
	X    {
	X	TermRewind(biggest);
	X	printf(Format, ChoiceList[val]);
	X
	X	switch (c = (getchar() & 0177))
	X	{
	X	case '\015':
	X	    underline(0);
	X	    TermSetUp();
	X	    return(val);
	X	case ' ':
	X	    if (++val == ChoiceCount)
	X		val = 0;
	X	    break;
	X	case '^':
	X	    if (--val < 0)
	X		val = ChoiceCount - 1;
	X	    break;
	X	case '\021':
	X	case '\023':
	X	    break;
	X	default:
	X	    printf("%c", '\007');
	X	}
	X    }
	X}
SHAR_AND_ENJOY
if test 2497 -ne "`wc -c < 'PickOne.c'`"
then
	echo shar: error transmitting "'PickOne.c'" '(should have been 2497 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'StandOut.c'" '(1086 characters)'
if test -f 'StandOut.c'
then
	echo shar: will not over-write existing file "'StandOut.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'StandOut.c'
	X
	Xvoid StandOut(on_or_off)
	Xint on_or_off;
	X
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X 	30 March 1984 - GWS
	X 
	X 
	X   NAME
	X 	StandOut - set or clear terminal stand-out mode
	X 
	X   SYNOPSIS
	X	void StandOut(on_or_off) 
	X	int on_or_off;
	X 
	X   DESCRIPTION
	X	Uses termcap(3x) routines to set terminal mode. 
	X 
	X   SEE ALSO
	X	termcap(3) 
	X 
	X   DIAGNOSTICS
	X	If the mode doesn't change, it didn't work. 
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	30 March 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X    static called = 0;
	X    static char so_id[] = "so", se_id[] = "se", so_str[10], se_str[10];
	X    static char *so_point = so_str, **so_point2 = &so_point;
	X    static char *se_point = se_str, **se_point2 = &se_point;
	X    extern char bp[1024];
	X    int tgetent(), tputs();
	X    int putchar();
	X
	X    if (!called)
	X    {
	X	tgetstr(so_id, so_point2);
	X	tgetstr(se_id, se_point2);
	X	called++;
	X    }
	X
	X    if (on_or_off)
	X    	(void) tputs(so_str, 1, putchar);
	X    else
	X    	(void) tputs(se_str, 1, putchar);
	X    return;
	X}
SHAR_AND_ENJOY
if test 1086 -ne "`wc -c < 'StandOut.c'`"
then
	echo shar: error transmitting "'StandOut.c'" '(should have been 1086 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'TermRewind.c'" '(209 characters)'
if test -f 'TermRewind.c'
then
	echo shar: will not over-write existing file "'TermRewind.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'TermRewind.c'
	X
	X#include <stdio.h>
	X
	Xvoid TermRewind(count)
	Xint count;
	X/*
	X
	Xvoid TermRewind(count)
	Xint count;
	X
	XBacks up the cursor 'count' spaces
	X
	X*/
	X
	X{
	X    int loop;
	X
	X    for (loop = 0; loop < count; loop++)
	X	printf("\b");
	X}
SHAR_AND_ENJOY
if test 209 -ne "`wc -c < 'TermRewind.c'`"
then
	echo shar: error transmitting "'TermRewind.c'" '(should have been 209 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'TermSetUp.c'" '(1713 characters)'
if test -f 'TermSetUp.c'
then
	echo shar: will not over-write existing file "'TermSetUp.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'TermSetUp.c'
	X#include <stdio.h>
	X#include <sgtty.h>
	X#include <sys/ioctl.h>
	X
	Xchar TermSetUp()
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X 	11 April 1984 - GWS
	X 
	X 
	X   NAME
	X 	TermSetUp - set/clear terminal no echo, raw mode
	X 
	X   SYNOPSIS
	X	char TermSetUp()
	X 
	X   DESCRIPTION
	X	This routine is a toggle function which places the terminal
	X	into RAW and !ECHO modes on odd calls and back to the original
	X	state on even-number calls.  The return character is the terminal's
	X	erase character.
	X 
	X   SEE ALSO
	X 
	X 
	X   DIAGNOSTICS
	X	Will exit(1) on any error. 
	X 
	X   BUGS
	X	none known 
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	9 April 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X    struct sgttyb params;
	X    int ret;
	X    static int count=0;
	X    static struct sgttyb old_params;
	X    int ioctl();
	X
	X    if (!count)
	X    {
	X	ret = ioctl(0, TIOCGETP, &old_params);
	X	if (ret == -1)
	X	{
	X	    fprintf(stderr, "ioctl fail\n");
	X	    perror("TermSetUp");
	X	    exit(1);
	X	}
	X	ret = ioctl(0, TIOCGETP, &params);
	X	if (ret == -1)
	X	{
	X	    fprintf(stderr, "ioctl fail\n");
	X	    perror("TermSetUp");
	X	    exit(1);
	X	}
	X
	X	/* single-character activation, disable all character processing */
	X	params.sg_flags |= RAW;
	X	if (params.sg_flags & ECHO)
	X	    params.sg_flags ^= ECHO;
	X	ret = ioctl(0, TIOCSETP, &params);
	X	if (ret == -1)
	X	{
	X	    fprintf(stderr, "ioctl fail\n");
	X	    perror("TermSetUp");
	X	    exit(1);
	X	}
	X	count++;
	X    }
	X    else
	X    {
	X/* put it back the way you found it */
	X	ret = ioctl(0, TIOCSETP, &old_params);
	X	if (ret == -1)
	X	{
	X	    fprintf(stderr, "ioctl fail\n");
	X	    perror("TermSetUp");
	X	    exit(1);
	X	}
	X	count = 0;
	X    }
	X
	X    return(params.sg_erase);
	X}
SHAR_AND_ENJOY
if test 1713 -ne "`wc -c < 'TermSetUp.c'`"
then
	echo shar: error transmitting "'TermSetUp.c'" '(should have been 1713 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'center.c'" '(1845 characters)'
if test -f 'center.c'
then
	echo shar: will not over-write existing file "'center.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'center.c'
	X#include <strings.h>
	X
	Xvoid center(line, string, mode)
	Xint line;
	Xchar *string;
	Xint mode;
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X	17 January 1985 - GWS
	X	Change to use screen width from termcap.
	X
	X 	2 April 1984 - GWS
	X 
	X 
	X   NAME
	X 	center - center string in screen on specified line
	X 
	X   SYNOPSIS
	X	void center(line, string, mode)
	X	int line;
	X	char *string;
	X	int mode;
	X 
	X   DESCRIPTION
	X	This routine uses the termcap(3x) routines to center and
	X	optionally emphasize a string.  'Line' is the terminal line
	X	number on which the string is to be placed, numbered starting
	X	with 1.  'Mode' takes one of three values:
	X		0 - no control characters sent
	X		1 - underline mode turned on before and off after 'string'
	X		2 - stand-out mode turned on before and off after 'string'
	X	A call to InitTerm must be made before the first call to center.
	X 
	X   SEE ALSO
	X	termcap(3x), InitTerm, underline, StandOut 
	X 
	X   DIAGNOSTICS
	X	none 
	X 
	X   BUGS
	X	does not check for string too long to fit on one line 
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	31 March 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X    int col;
	X    int cookie;
	X
	X    int strlen();
	X    void gotoxy();
	X    void underline();
	X    void StandOut();
	X
	X    col = (tgetnum("co") - strlen(string)) / 2;
	X    switch (mode)
	X    {
	X    case 0:
	X	break;
	X    case 1:
	X	cookie = tgetnum("ug");
	X	if (cookie > 0)
	X	    col -= cookie;
	X	break;
	X    case 2:
	X	cookie = tgetnum("sg");
	X	if (cookie > 0)
	X	    col -= cookie;
	X	break;
	X    }
	X    gotoxy(col, line);
	X    switch (mode)
	X    {
	X    case 0:
	X	break;
	X    case 1:
	X	underline(1);
	X	break;
	X    case 2:
	X	StandOut(1);
	X	break;
	X    }
	X
	X    printf(string);
	X
	X    switch (mode)
	X    {
	X    case 0:
	X	break;
	X    case 1:
	X	underline(0);
	X	break;
	X    case 2:
	X	StandOut(0);
	X	break;
	X    }
	X    return;
	X}
SHAR_AND_ENJOY
if test 1845 -ne "`wc -c < 'center.c'`"
then
	echo shar: error transmitting "'center.c'" '(should have been 1845 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'examp.c'" '(1999 characters)'
if test -f 'examp.c'
then
	echo shar: will not over-write existing file "'examp.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'examp.c'
	X#include <stdio.h>
	X#include <term.h>
	X
	Xmain()
	X
	X{
	X    int num1, num2;
	X    float fnum1, fnum2;
	X    char HospNum[9];
	X    char text[20];
	X    static char *table[] =
	X	{
	X	"Number one",
	X	"Number two",
	X	"And even yet another",
	X	"two turtle moves",
	X	"a partridge in a directory tree"
	X	};
	X
	X
	X    if(InitTerm() != 0)
	X	printf("InitTerm failed\n");
	X    page();
	X
	X    printf("Here are your choices -->");
	X    num1 = PickOne(table, 5);
	X    printf("<--\nNumber %d was chosen\n", num1);
	X
	X    printf("Here are your choices -->");
	X    num1 = PickOne(table, 1);
	X    printf("<--\nNumber %d was chosen\n", num1);
	X
	X    printf("Enter a string -->");
	X    GetString(text, 15, 0);
	X    printf("<--\nString is %s\n", text);
	X
	X    printf("yes or no ? -->");
	X    num1 = GetBool(1);
	X    printf(",");
	X    num2 = GetBool(num1);
	X    printf("<---\n");
	X    printf("Booleans are %d, %d\n", num1, num2);
	X
	X    printf("Enter a number --->");
	X    num1 = GetInt(50, 4);
	X    printf(",");
	X    num2 = GetInt(num1, 6);
	X    printf("<---\n");
	X    printf("Numbers were %d, %d\n", num1, num2);
	X
	X    printf("Enter a number --->");
	X    fnum1 = GetFloat(50.0, 8, 5);
	X    printf(",");
	X    fnum2 = GetFloat(fnum1, 6, 2);
	X    printf("<---\n");
	X    printf("Numbers were %f, %f\n", fnum1, fnum2);
	X
	X    printf("Enter hospital number --->");
	X    GetHospNum(HospNum);
	X    printf("<---\n");
	X    printf("Number is %s\n", HospNum);
	X
	X    fflush(stdout);
	X    sleep(2);
	X
	X    page();
	X    num1 = MenuPick("This is a demo of MenuPick", table, 5);
	X    printf("<--\nNumber %d was chosen\n", num1);
	X    sleep(2);
	X
	X
	X    page();
	X    gotoxy(15, 15);
	X    center(1, "I am normal text centered on line 1", 0);
	X    center(10, "I am underlined text centered on line 10", 1);
	X    center(20, "I am standout text centered on line 20", 2);
	X    gotoxy(1, 1);
	X    printf("+");
	X    gotoxy(80, 1);
	X    printf("+");
	X    gotoxy(40, 12);
	X    printf("+");
	X    gotoxy(1, 24);
	X    printf("+");
	X    gotoxy(79, 24);
	X    printf("+");
	X    fflush(stdout);
	X
	X    sleep(2);
	X    gotoxy(1, 24);
	X    exit(0);
	X}
SHAR_AND_ENJOY
if test 1999 -ne "`wc -c < 'examp.c'`"
then
	echo shar: error transmitting "'examp.c'" '(should have been 1999 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'gotoxy.c'" '(1077 characters)'
if test -f 'gotoxy.c'
then
	echo shar: will not over-write existing file "'gotoxy.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'gotoxy.c'
	X
	Xvoid gotoxy(col, line)
	Xint col, line;
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X 	29 March 1984 - GWS
	X 
	X 
	X   NAME
	X 	gotoxy - move the cursor to the requested position
	X 
	X   SYNOPSIS
	X	void gotoxy(col, line) 
	X	int col, line;
	X 
	X   DESCRIPTION
	X	Uses termcap(3x) routines to move cursor.  The columns and
	X	lines are numbered starting with 1.
	X 
	X   SEE ALSO
	X	termcap(3) 
	X 
	X   DIAGNOSTICS
	X	If the cursor doesn't move, it didn't work. 
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	29 March 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X    static called = 0;
	X    static char id[] = "cm", cm_str[20];
	X    static char *point = cm_str, **point2 = &point;
	X    extern char bp[1024];
	X    int tgetent();
	X    int tputs();
	X    int putchar();
	X    char *tgoto();
	X    char str[20];
	X    int loop;
	X
	X    if (!called)
	X    {
	X	tgetstr(id, point2);
	X	called++;
	X    }
	X
	X    for (loop = 0; loop < 20; loop++)
	X	str[loop] = cm_str[loop];
	X
	X
	X    (void) tputs(tgoto(str, col - 1, line - 1), 1, putchar);
	X    return;
	X}
SHAR_AND_ENJOY
if test 1077 -ne "`wc -c < 'gotoxy.c'`"
then
	echo shar: error transmitting "'gotoxy.c'" '(should have been 1077 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'page.c'" '(813 characters)'
if test -f 'page.c'
then
	echo shar: will not over-write existing file "'page.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'page.c'
	X
	Xvoid page()
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X 	29 March 1984 - GWS
	X 
	X 
	X   NAME
	X 	page - page the terminal
	X 
	X   SYNOPSIS
	X	void page() 
	X 
	X   DESCRIPTION
	X	Uses termcap(3x) routines to clear terminal screen. 
	X 
	X   SEE ALSO
	X	termcap(3) 
	X 
	X   DIAGNOSTICS
	X	If the screen doesn't clear, it didn't work. 
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	29 March 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X    static called = 0;
	X    static char id[] = "cl", page_str[10];
	X    static char *point = page_str, **point2 = &point;
	X    extern char bp[1024];
	X    int tgetent(), tputs();
	X    int putchar();
	X
	X    if (!called)
	X    {
	X	tgetstr(id, point2);
	X	called++;
	X    }
	X
	X    (void) tputs(page_str, 1, putchar);
	X    return;
	X}
SHAR_AND_ENJOY
if test 813 -ne "`wc -c < 'page.c'`"
then
	echo shar: error transmitting "'page.c'" '(should have been 813 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'underline.c'" '(1093 characters)'
if test -f 'underline.c'
then
	echo shar: will not over-write existing file "'underline.c'"
else
sed 's/^	X//' << \SHAR_AND_ENJOY > 'underline.c'
	X
	Xvoid underline(on_or_off)
	Xint on_or_off;
	X
	X
	X/*
	X ---------------------------------------------------------------------------
	X 
	X   Last revision - 
	X 	30 March 1984 - GWS
	X 
	X 
	X   NAME
	X 	underline - set or clear terminal underline mode
	X 
	X   SYNOPSIS
	X	void underline(on_or_off) 
	X	int on_or_off;
	X 
	X   DESCRIPTION
	X	Uses termcap(3x) routines to set terminal mode. 
	X 
	X   SEE ALSO
	X	termcap(3) 
	X 
	X   DIAGNOSTICS
	X	If the mode doesn't change, it didn't work. 
	X 
	X   AUTHOR
	X 	George W. Sherouse
	X 	30 March 1984
	X 
	X ---------------------------------------------------------------------------
	X*/
	X
	X{
	X    static int called = 0;
	X    static char us_id[] = "us", ue_id[] = "ue", us_str[10], ue_str[10];
	X    static char *us_point = us_str, **us_point2 = &us_point;
	X    static char *ue_point = ue_str, **ue_point2 = &ue_point;
	X    extern char bp[1024];
	X    int tgetent(), tputs();
	X    int putchar();
	X
	X    if (!called)
	X    {
	X	tgetstr(us_id, us_point2);
	X	tgetstr(ue_id, ue_point2);
	X	called++;
	X    }
	X
	X    if (on_or_off)
	X    	(void) tputs(us_str, 1, putchar);
	X    else
	X    	(void) tputs(ue_str, 1, putchar);
	X    return;
	X}
SHAR_AND_ENJOY
if test 1093 -ne "`wc -c < 'underline.c'`"
then
	echo shar: error transmitting "'underline.c'" '(should have been 1093 characters)'
fi
fi # end of overwriting check
#	End of shell archive
exit 0


