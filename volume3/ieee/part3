From: genrad!decvax!decwrl!sun!dgh!dgh (David Hough)
Subject: IEEE Calculator (part 3 of 6)
Newsgroups: mod.sources
Approved: jpn@panda.UUCP

Mod.sources:  Volume 3, Issue 5
Submitted by: decvax!decwrl!sun!dgh!dgh (David Hough)

#! /bin/sh
: make a directory, cd to it, and run this through sh
echo If this kit is complete, "End of Kit" will echo at the end
echo Extracting calcdouble.h
cat >calcdouble.h <<'End-Of-File'
procedure todouble ( var x : internal ; var y : cdouble ) ; external ;
procedure unpackdouble ( y : cdouble ; var x : internal ) ; external ;
 
End-Of-File
echo Extracting calcsingle.h
cat >calcsingle.h <<'End-Of-File'
procedure tosingle ( var x : internal ; var y : csingle ) ; external ;
procedure unpacksingle ( y : csingle ; var x : internal ) ; external ;
End-Of-File
echo Extracting calctest.h
cat >calctest.h <<'End-Of-File'

(* File calctest.h, Version 5 October 1984. *)

(* This version of the calculator test unit is a dummy to provide
constant and type declarations only.  *)

(* Global constant, type, and variable declarations for  Calc. *)

const
stickybit = 66 ; (* position of sticky bit in internal representation *)

type

arithtype = ( i16, i32, i64, flt32, f64, ext80, unrounded  ) ; 
        (* types of arithmetic operands *)

fpmodetype = record (* floating point mode record *)
round : rmode (* roundmodetype *) ;
precision : extprec ;
clos : closure(*type*) ;
norm : denorm ;
end ;

fpstype  = record (* complete status of floating point unit *)
mode : fpmodetype ;
curexcep : excepset ; (* Set of exceptions generated by current op.  *)
excep : excepset ;
trap : excepset end ;

internal = record (* internal extended format *)
(* unlike external extended, most significant bit represents 0.5,
not 1.0 *)
sign : boolean ;
exponent : integer ; (* range is -2**15 to 2**15-1 *)
significand :   array [0..stickybit] of boolean ; 
        (* bit stickybit-2 is guard ;
bit (stickybit-1) is round ; bit stickybit is sticky *)
end ;
        
        (* Following are temporary calculator internal types which use 
        logical bytes, which may not be the same as the physical bytes
        specified in x80modes.  *)
csingle = array [0..3] of byt ;
cdouble = array [0..7] of byt ;
cextended = array [0..9] of byt ;
cint64 = array [0..7] of byt ;

procedure pretest ( var storemode : arithtype )  ;  external ;
procedure swapmode ( var e : fpmodetype ) ;  external ;
procedure swaptrap ( var e : excepset ) ;  external ;
procedure swapexcep ( var e : excepset ) ;  external ;

procedure tneg ( x : internal ; var z : internal ) ;  external ;
procedure tabs ( x : internal ; var z : internal ) ;  external ;
procedure tsqrt ( x : internal ; var z : internal ) ;  external ;

procedure tadd ( x, y : internal ; var z : internal ) ;  external ;
procedure tsub ( x, y : internal ; var z : internal ) ;  external ;
procedure tmul ( x, y : internal ; var z : internal ) ;  external ;
procedure tdiv ( x, y : internal ; var z : internal ) ;  external ;
procedure trem ( x, y : internal ; var z : internal ) ;  external ;

procedure tcompare ( x, y : internal ; var cc : conditioncode ) ;  external ;
procedure tstore ( storagemode : arithtype ; var z : internal ) ;  external ;
procedure tconvert ( x : internal ; var z : internal ; a : arithtype ) ;  external ;

procedure tintconvert ( x : internal ; var z : internal ; a : arithtype ) ;  external ;

procedure tdisplay ( x : internal ) ;   external ;
procedure tdecbin ( s : fpstring ; var x : internal ; var error : boolean ) ;  external ;

procedure ffloat_ ; external ;
procedure ffunc_  ; external ;
procedure sfloat_ ; external ;
procedure sfunc_  ; external ;

End-Of-File
echo Extracting oldfplib.h
cat >oldfplib.h <<'End-Of-File'
	const

	maxfpstring = 80 ;

	invop = invalid;
	overfl = overflow;
	underfl = underflow;
	div0 = divbyzero;
	inxact = inexact;
	cvtovfl = invalid ;

	type

	byt = 0..255 ;

	fpstring = packed array [0..maxfpstring] of char ;

	roundtype = ( rnear, rzero, rpos, rneg, rout ) ;
	rmode = rnear .. rneg ;
	closure = (proj, affine) ;
	denorm = ( warning, normalizing ) ;
	extprec = ( xprec, sprec, dprec ) ;
	
	xcpn = exception ;
	excepset = set of exception ;

	fp_cc = ( equal, lesser, greater, notord ) ;
	conditioncode = fp_cc ;

End-Of-File
echo Extracting sane.h
cat >sane.h <<'End-Of-File'
type

longint = integer ;
integer = -32768..32767 ;
single = array [0..1] of integer ;
double = array [0..3] of integer ;
comp = array [0..3] of integer ;
extended = array [0..4] of integer ;

environ = integer ;
rounddir = ( tonearest, upward, downward, towardzero ) ;
relop = ( gt, lt, gl, eq, ge, le, gel, unord ) ;
exception = ( invalid, underflow, overflow, divbyzero, inexact ) ;
numclass = ( snan, qnan, infinite, zero, normal, denormal ) ;

roundprecision = ( extprecision, dblprecision, realprecision ) ;

procedure SetRnd ( r : rounddir ) ; external ;
function GetRnd : rounddir ; external ;
procedure SetXcp ( x : exception; onoff : boolean ); external ;
function TestXcp ( x : exception ) : boolean   ; external ;

End-Of-File
echo ""
echo "End of Kit"
exit

