Subject: RFS: remote file system (part 5 of 7)
Newsgroups: mod.sources
Approved: jpn@panda.UUCP

Mod.sources:  Volume 3, Issue 81
Submitted by: tektronix!tekcrl!toddb

#!/bin/sh
#
# RFS, a kernel-resident remote file system.  Shar 5 of 7
#
#
# This is a shell archive, meaning:
# 1. Remove everything above the #!/bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	remote/usr.sys.PYR2.5/h/errno.h.diff
#	remote/usr.sys.VAX4.2/h/param.h.diff
#	remote/usr.sys.VAX4.3/h/param.h.diff
#	remote/usr.sys.PYR2.5/h/param.h.diff
#	remote/usr.sys.PYR2.5/h/user.h.diff
#	remote/usr.sys.PYR2.5/sys
#	remote/usr.sys.PYR2.5/sys/init_sysent.c.diff
#	remote/usr.sys.PYR2.5/sys/kern_exec.c.diff
#	remote/usr.sys.PYR2.5/sys/kern_exit.c.diff
#	remote/usr.sys.PYR2.5/sys/kern_trap.c.diff
#	remote/usr.sys.PYR2.5/sys/sys_inode.c.diff
#	remote/usr.sys.PYR2.5/sys/ufs_nami.c.diff
#	remote/usr.sys.PYR2.5/sys/ufs_syscalls.c.diff
#	remote/usr.sys.PYR2.5/sys/uipc_socket.c.diff
#	remote/usr.sys.VAX4.2
#	remote/usr.sys.VAX4.2/conf
#	remote/usr.sys.VAX4.3/conf/files.diff
#	remote/usr.sys.VAX4.2/conf/files.diff
#	remote/usr.sys.VAX4.2/conf/makefile.vax.diff
#	remote/usr.sys.VAX4.2/h
#	remote/usr.sys.VAX4.3/h/errno.h.diff
#	remote/usr.sys.VAX4.2/h/errno.h.diff
#	remote/usr.sys.VAX4.2/h/user.h.diff
#	remote/usr.sys.VAX4.2/machine
#	remote/usr.sys.VAX4.2/machine/trap.c.diff
#	remote/usr.sys.VAX4.2/sys
#	remote/usr.sys.VAX4.2/sys/init_sysent.c.diff
#	remote/usr.sys.VAX4.2/sys/kern_exec.c.diff
#	remote/usr.sys.VAX4.2/sys/kern_exit.c.diff
#	remote/usr.sys.VAX4.2/sys/sys_inode.c.diff
#	remote/usr.sys.VAX4.2/sys/ufs_nami.c.diff
#	remote/usr.sys.VAX4.2/sys/ufs_syscalls.c.diff
#	remote/usr.sys.VAX4.2/sys/uipc_socket.c.diff
#	remote/usr.sys.VAX4.3
#	remote/usr.sys.VAX4.3/conf
#	remote/usr.sys.VAX4.3/conf/Makefile.vax.diff
#	remote/usr.sys.VAX4.3/conf/makefile.vax.diff
#	remote/usr.sys.VAX4.3/h
#	remote/usr.sys.VAX4.3/h/user.h.diff
#	remote/usr.sys.VAX4.3/machine
#	remote/usr.sys.VAX4.3/machine/trap.c.diff
#	remote/usr.sys.VAX4.3/sys
#	remote/usr.sys.VAX4.3/sys/init_sysent.c.diff
#
# remote/usr.sys.PYR2.5/sys
#
mkdir remote/usr.sys.PYR2.5/sys
chmod 775 remote/usr.sys.PYR2.5/sys
#
# remote/usr.sys.VAX4.2
#
mkdir remote/usr.sys.VAX4.2
chmod 775 remote/usr.sys.VAX4.2
#
# remote/usr.sys.VAX4.2/conf
#
mkdir remote/usr.sys.VAX4.2/conf
chmod 775 remote/usr.sys.VAX4.2/conf
#
# remote/usr.sys.VAX4.2/h
#
mkdir remote/usr.sys.VAX4.2/h
chmod 775 remote/usr.sys.VAX4.2/h
#
# remote/usr.sys.VAX4.2/machine
#
mkdir remote/usr.sys.VAX4.2/machine
chmod 775 remote/usr.sys.VAX4.2/machine
#
# remote/usr.sys.VAX4.2/sys
#
mkdir remote/usr.sys.VAX4.2/sys
chmod 775 remote/usr.sys.VAX4.2/sys
#
# remote/usr.sys.VAX4.3
#
mkdir remote/usr.sys.VAX4.3
chmod 775 remote/usr.sys.VAX4.3
#
# remote/usr.sys.VAX4.3/conf
#
mkdir remote/usr.sys.VAX4.3/conf
chmod 775 remote/usr.sys.VAX4.3/conf
#
# remote/usr.sys.VAX4.3/h
#
mkdir remote/usr.sys.VAX4.3/h
chmod 775 remote/usr.sys.VAX4.3/h
#
# remote/usr.sys.VAX4.3/machine
#
mkdir remote/usr.sys.VAX4.3/machine
chmod 775 remote/usr.sys.VAX4.3/machine
#
# remote/usr.sys.VAX4.3/sys
#
mkdir remote/usr.sys.VAX4.3/sys
chmod 775 remote/usr.sys.VAX4.3/sys
#
# remote/usr.sys.PYR2.5/h/errno.h.diff
#
if [ -f remote/usr.sys.PYR2.5/h/errno.h.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/h/errno.h.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.PYR2.5/h/errno.h.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.PYR2.5/h/errno.h.diff
XThese changes add three new error numbers for the sake of RFS.
X***************
X*** 90,95
X  #define	EUSERS		68		/* Too many users */
X  #define	EDQUOT		69		/* Disc quota exceeded */
X  
X  
X  /*-----------------System V unique errno's----------------------*/
X  #define	ENOMSG	100	/* No message of desired type		*/
X
X--- 90,99 -----
X  #define	EUSERS		68		/* Too many users */
X  #define	EDQUOT		69		/* Disc quota exceeded */
X  
X+ /* remote fs stuff */
X+ #define EISREMOTE	70		/* file is on a remote system */
X+ #define ETOOMANYREMOTE	71		/* too many remote file systems */
X+ #define	ENOREMOTEFS	72		/* no remote file system */
X  
X  /*-----------------System V unique errno's----------------------*/
X  #define	ENOMSG	100	/* No message of desired type		*/
SHAREOF
chmod 664 remote/usr.sys.PYR2.5/h/errno.h.diff
#
# remote/usr.sys.PYR2.5/h/param.h.diff
#
if [ -f remote/usr.sys.PYR2.5/h/param.h.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/h/param.h.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.PYR2.5/h/param.h.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.PYR2.5/h/param.h.diff
XThis addition defines NREMOTE, the number of remote mount points.
X***************
X*** 26,27
X   * Machine-independent constants
X   */
X
X--- 26,30 -----
X   * Machine-independent constants
X   */
X+ #ifdef REMOTEFS
X+ #define	NREMOTE	8		/* number of remote file systems */
X+ #endif REMOTEFS
SHAREOF
chmod 664 remote/usr.sys.PYR2.5/h/param.h.diff
if [ -f remote/usr.sys.VAX4.2/h/param.h.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/h/param.h.diff or ^C to quit' 
	read ans 
	rm -rf remote/usr.sys.VAX4.2/h/param.h.diff 
fi
ln remote/usr.sys.PYR2.5/h/param.h.diff remote/usr.sys.VAX4.2/h/param.h.diff
if [ -f remote/usr.sys.VAX4.3/h/param.h.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/h/param.h.diff or ^C to quit' 
	read ans 
	rm -rf remote/usr.sys.VAX4.3/h/param.h.diff 
fi
ln remote/usr.sys.PYR2.5/h/param.h.diff remote/usr.sys.VAX4.3/h/param.h.diff
#
# remote/usr.sys.PYR2.5/h/user.h.diff
#
if [ -f remote/usr.sys.PYR2.5/h/user.h.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/h/user.h.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.PYR2.5/h/user.h.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.PYR2.5/h/user.h.diff
XThese changes keep track of the per-process RFS information.
X***************
X*** 169,174
X  		dev_t nc_dev;		/* dev of cached directory */
X  		time_t nc_time;		/* time stamp for cache entry */
X  	} u_ncache;
X  	int	u_stack[1];
X  };
X  
X
X--- 169,184 -----
X  		dev_t nc_dev;		/* dev of cached directory */
X  		time_t nc_time;		/* time stamp for cache entry */
X  	} u_ncache;
X+ #ifdef REMOTEFS
X+ 	short	u_rmtoffset[2];		/* path offset for local segment */
X+ 	short	u_rmtcdir;		/* system # of remote current dir */
X+ 	long	u_rmtsys;		/* room for 32 systems */
X+ 					/* one bit for each remote system */
X+ #ifdef pyr /* Pyramid */
X+ 	int	u_ap;
X+ #define		u_arg	u_ap
X+ #endif pyr
X+ #endif REMOTEFS
X  	int	u_stack[1];
X  };
X  
SHAREOF
chmod 664 remote/usr.sys.PYR2.5/h/user.h.diff
#
# remote/usr.sys.PYR2.5/sys/init_sysent.c.diff
#
if [ -f remote/usr.sys.PYR2.5/sys/init_sysent.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/sys/init_sysent.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.PYR2.5/sys/init_sysent.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.PYR2.5/sys/init_sysent.c.diff
XThese two changes add in the new RFS systems calls, remoteon(), remoteoff()
Xand  remotename().  If the second hunk fails, then you have some system
Xcall numbers that are not in standard Pyramid 2.5.
X***************
X*** 124,129
X   */
X  int	setuniverse(), ugetcsbase();
X  
X  /* BEGIN JUNK */
X  int	profil();		/* 'cuz sys calls are interruptible */
X  int	vhangup();		/* should just do in exit() */
X
X--- 124,138 -----
X   */
X  int	setuniverse(), ugetcsbase();
X  
X+ #ifdef REMOTEFS
X+ /*
X+  * remote file sys stuff (toddb@du)
X+  */
X+ int	remoteon(),
X+ 	remoteoff(),
X+ 	remotename();
X+ #endif REMOTEFS
X+ 
X  /* BEGIN JUNK */
X  int	profil();		/* 'cuz sys calls are interruptible */
X  int	vhangup();		/* should just do in exit() */
X***************
X*** 324,329
X  #endif NSA
X  	{ setprocesshost, 1},	/* 166 = setprocesshost */
X  	{ getprocesshost, 1},	/* 167 = getprocesshost */
X  };
X  int	nsysent = sizeof (sysent) / sizeof (sysent[0]);
X  
X
X--- 333,347 -----
X  #endif NSA
X  	{ setprocesshost, 1},	/* 166 = setprocesshost */
X  	{ getprocesshost, 1},	/* 167 = getprocesshost */
X+ #ifdef REMOTEFS
X+ 	{ remoteon, 4 },	/* 168 = remoteon */
X+ 	{ remoteoff, 1 },	/* 169 = remoteoff */
X+ 	{ remotename, 5 },	/* 170 = remotename */
X+ #else REMOTEFS
X+ 	{ nosys, 0},		/* 168 = reserved for REMOTEFS */
X+ 	{ nosys, 0},		/* 169 = reserved for REMOTEFS */
X+ 	{ nosys, 0},		/* 170 = reserved for REMOTEFS */
X+ #endif REMOTEFS
X  };
X  int	nsysent = sizeof (sysent) / sizeof (sysent[0]);
X  
SHAREOF
chmod 664 remote/usr.sys.PYR2.5/sys/init_sysent.c.diff
#
# remote/usr.sys.PYR2.5/sys/kern_exec.c.diff
#
if [ -f remote/usr.sys.PYR2.5/sys/kern_exec.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/sys/kern_exec.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.PYR2.5/sys/kern_exec.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.PYR2.5/sys/kern_exec.c.diff
XThe following changes implement local execution of an object file that
Xlives on another host.
X***************
X*** 58,63
X  #include "../h/cmap.h"
X  #include "../h/vmmac.h"
X  #include "../h/debug.h"
X  
X  int  *swapstack();
X  
X
X--- 58,69 -----
X  #include "../h/cmap.h"
X  #include "../h/vmmac.h"
X  #include "../h/debug.h"
X+ #ifdef REMOTEFS
X+ /*
X+  * needed only if EISREMOTE isn't in /usr/include/errno.h
X+  */
X+ #include "../h/errno.h"
X+ #endif REMOTEFS
X  
X  int  *swapstack();
X  
X***************
X*** 76,81
X  	register char *cp;
X  	register struct buf *bp;
X  	register int na, ne, ucp, ap, c, i;
X  	register int indir, uid, gid;
X  	register char *sharg;
X  	register struct inode *ip;
X
X--- 82,93 -----
X  	register char *cp;
X  	register struct buf *bp;
X  	register int na, ne, ucp, ap, c, i;
X+ #ifdef REMOTEFS
X+ 	register int indir;
X+ 	int uid, gid; /* have to take address */
X+ 	struct inode *ip; /* have to take address */
X+ 	int	remote = -1;
X+ #else REMOTEFS
X  	register int indir, uid, gid;
X  	register struct inode *ip;
X  #endif REMOTEFS
X***************
X*** 77,83
X  	register struct buf *bp;
X  	register int na, ne, ucp, ap, c, i;
X  	register int indir, uid, gid;
X- 	register char *sharg;
X  	register struct inode *ip;
X  	register swblk_t bno;
X  	char cfname[MAXNAMLEN + 1];
X
X--- 89,94 -----
X  	int	remote = -1;
X  #else REMOTEFS
X  	register int indir, uid, gid;
X  	register struct inode *ip;
X  #endif REMOTEFS
X  	register char *sharg;
X***************
X*** 79,84
X  	register int indir, uid, gid;
X  	register char *sharg;
X  	register struct inode *ip;
X  	register swblk_t bno;
X  	char cfname[MAXNAMLEN + 1];
X  	char cfarg[SHSIZE];
X
X--- 90,97 -----
X  #else REMOTEFS
X  	register int indir, uid, gid;
X  	register struct inode *ip;
X+ #endif REMOTEFS
X+ 	register char *sharg;
X  	register swblk_t bno;
X  	char cfname[MAXNAMLEN + 1];
X  	char cfarg[SHSIZE];
X***************
X*** 105,110
X   *	(7) do a ret
X   */
X  	if ((ip = namei(uchar, LOOKUP, 1)) == NULL)
X  		return;
X  	sysVinfo.sV_sysexec++;
X  	bno = 0;
X
X--- 118,128 -----
X   *	(7) do a ret
X   */
X  	if ((ip = namei(uchar, LOOKUP, 1)) == NULL)
X+ #ifdef REMOTEFS
X+ 		if (u.u_error == EISREMOTE)
X+ 			remote = remote_execinfo(&ip, &uid, &gid, fname);
X+ 	if (u.u_error)
X+ #endif REMOTEFS
X  		return;
X  	sysVinfo.sV_sysexec++;
X  	bno = 0;
X***************
X*** 110,115
X  	bno = 0;
X  	bp = 0;
X  	indir = 0;
X  	uid = u.u_uid;
X  	gid = u.u_gid;
X  	if (ip->i_mode & ISUID)
X
X--- 128,136 -----
X  	bno = 0;
X  	bp = 0;
X  	indir = 0;
X+ #ifdef REMOTEFS
X+ if (remote < 0) {
X+ #endif REMOTEFS
X  	uid = u.u_uid;
X  	gid = u.u_gid;
X  	if (ip->i_mode & ISUID)
X***************
X*** 148,153
X  	if (u.u_error)
X  		goto bad;
X  	u.u_count = resid;
X  #ifndef lint
X  	if (resid > sizeof(u.u_exdata) - sizeof(u.u_exdata.Ux_A) &&
X  	    u.u_exdata.ux_shell[0] != '#') {
X
X--- 169,180 -----
X  	if (u.u_error)
X  		goto bad;
X  	u.u_count = resid;
X+ #ifdef REMOTEFS
X+ }
X+ 
X+ remote_again:
X+ 
X+ #endif REMOTEFS
X  #ifndef lint
X  	if (resid > sizeof(u.u_exdata) - sizeof(u.u_exdata.Ux_A) &&
X  	    u.u_exdata.ux_shell[0] != '#') {
X***************
X*** 224,229
X  		    (unsigned)(u.u_dent.d_namlen + 1));
X  		cfname[MAXCOMLEN] = 0;
X  		indir = 1;
X  		iput(ip);
X  		/* Security hole fix: don't allow SUID-root exec'able
X  		   scripts whose name starts with '-'.... allows
X
X--- 251,259 -----
X  		    (unsigned)(u.u_dent.d_namlen + 1));
X  		cfname[MAXCOMLEN] = 0;
X  		indir = 1;
X+ #ifdef REMOTEFS
X+ 		if (remote < 0)
X+ #endif REMOTEFS
X  		iput(ip);
X  		/* Security hole fix: don't allow SUID-root exec'able
X  		   scripts whose name starts with '-'.... allows
X***************
X*** 233,238
X  			return;
X  		}
X  		ip = namei(schar, LOOKUP, 1);
X  		if (ip == NULL)
X  			return;
X  		goto again;
X
X--- 263,280 -----
X  			return;
X  		}
X  		ip = namei(schar, LOOKUP, 1);
X+ #ifdef REMOTEFS
X+ 		if (ip == NULL) {
X+ 			if (u.u_error == EISREMOTE)
X+ 				remote = remote_execinfo(&ip, 0, 0, 0);
X+ 			if (u.u_error)
X+ 				return;
X+ 			if (ip == NULL)
X+ 				goto remote_again;
X+ 		}
X+ 		else
X+ 			remote = -1;
X+ #else REMOTEFS
X  		if (ip == NULL)
X  			return;
X  #endif REMOTEFS
X***************
X*** 235,240
X  		ip = namei(schar, LOOKUP, 1);
X  		if (ip == NULL)
X  			return;
X  		goto again;
X  	}
X  
X
X--- 277,283 -----
X  #else REMOTEFS
X  		if (ip == NULL)
X  			return;
X+ #endif REMOTEFS
X  		goto again;
X  	}
X  
X***************
X*** 332,337
X  		bcopy((caddr_t)cfname, (caddr_t)u.u_dent.d_name,
X  		    (unsigned)(u.u_dent.d_namlen + 1));
X  	}
X  	getxfile(ip, (int)(nc + (na+4)*NBPW), uid, gid);
X  	if (u.u_error) {
X  badarg:
X
X--- 375,383 -----
X  		bcopy((caddr_t)cfname, (caddr_t)u.u_dent.d_name,
X  		    (unsigned)(u.u_dent.d_namlen + 1));
X  	}
X+ #ifdef REMOTEFS
X+ 	getxfile(ip, (int)(nc + (na+4)*NBPW), uid, gid, remote);
X+ #else REMOTEFS
X  	getxfile(ip, (int)(nc + (na+4)*NBPW), uid, gid);
X  #endif REMOTEFS
X  	if (u.u_error) {
X***************
X*** 333,338
X  		    (unsigned)(u.u_dent.d_namlen + 1));
X  	}
X  	getxfile(ip, (int)(nc + (na+4)*NBPW), uid, gid);
X  	if (u.u_error) {
X  badarg:
X  		for (c = 0; c < nc; c += CLSIZE*PAGSIZ) {
X
X--- 379,385 -----
X  	getxfile(ip, (int)(nc + (na+4)*NBPW), uid, gid, remote);
X  #else REMOTEFS
X  	getxfile(ip, (int)(nc + (na+4)*NBPW), uid, gid);
X+ #endif REMOTEFS
X  	if (u.u_error) {
X  badarg:
X  		for (c = 0; c < nc; c += CLSIZE*PAGSIZ) {
X***************
X*** 627,632
X   * Set up page tables and other structures for the process to be
X   * executed, and read in from the file.
X   */
X  getxfile(ip, nargc, uid, gid)
X  	register struct inode *ip;
X  {
X
X--- 674,682 -----
X   * Set up page tables and other structures for the process to be
X   * executed, and read in from the file.
X   */
X+ #ifdef REMOTEFS
X+ getxfile(ip, nargc, uid, gid, remote)
X+ #else REMOTEFS
X  getxfile(ip, nargc, uid, gid)
X  #endif REMOTEFS
X  	register struct inode *ip;
X***************
X*** 628,633
X   * executed, and read in from the file.
X   */
X  getxfile(ip, nargc, uid, gid)
X  	register struct inode *ip;
X  {
X  	register size_t ts, ds, uss, css;
X
X--- 678,684 -----
X  getxfile(ip, nargc, uid, gid, remote)
X  #else REMOTEFS
X  getxfile(ip, nargc, uid, gid)
X+ #endif REMOTEFS
X  	register struct inode *ip;
X  {
X  	register size_t ts, ds, uss, css;
X***************
X*** 632,637
X  {
X  	register size_t ts, ds, uss, css;
X  	register int pagi;
X  	register struct proc *p;
X  	register struct file *fp;
X  	register int flag;		/* used to keep proc flags */
X
X--- 683,691 -----
X  {
X  	register size_t ts, ds, uss, css;
X  	register int pagi;
X+ #ifdef REMOTEFS
X+ 	register int	oldtextsize;
X+ #endif REMOTEFS
X  	register struct proc *p;
X  	register struct file *fp;
X  	register int flag;		/* used to keep proc flags */
X***************
X*** 650,655
X  		pagi = SPAGI;
X  	else
X  		pagi = 0;
X  	if (u.u_exdata.ux_tsize!=0 && (ip->i_xflag&ITEXTFILE)==0 &&
X  						ip->i_count!=1) {
X  		SPINLOCK(&file_lock);
X
X--- 704,720 -----
X  		pagi = SPAGI;
X  	else
X  		pagi = 0;
X+ #ifdef REMOTEFS
X+ 	if (remote >= 0) {
X+ 		/*
X+ 		 * Prevent xalloc() from making a shared or paged text.
X+ 		 */
X+ 		pagi = 0;
X+ 		oldtextsize = u.u_exdata.ux_tsize;
X+ 		u.u_exdata.ux_dsize += u.u_exdata.ux_tsize;
X+ 		u.u_exdata.ux_tsize = 0;
X+ 	}
X+ #endif REMOTEFS
X  	if (u.u_exdata.ux_tsize!=0 && (ip->i_xflag&ITEXTFILE)==0 &&
X  						ip->i_count!=1) {
X  		SPINLOCK(&file_lock);
X***************
X*** 802,807
X  	 * Read in the data segment if we are not going to page in this
X  	 * process.
X  	 */
X  	if (pagi == 0) {
X  		u.u_error =
X  		    rdwri(UIO_READ, ip,
X
X--- 867,877 -----
X  	 * Read in the data segment if we are not going to page in this
X  	 * process.
X  	 */
X+ #ifdef REMOTEFS
X+ 	if (remote >= 0)
X+ 		u.u_error = remote_execread(remote, oldtextsize);
X+ 	else
X+ #endif REMOTEFS
X  	if (pagi == 0) {
X  		u.u_error =
X  		    rdwri(UIO_READ, ip,
SHAREOF
chmod 664 remote/usr.sys.PYR2.5/sys/kern_exec.c.diff
#
# remote/usr.sys.PYR2.5/sys/kern_exit.c.diff
#
if [ -f remote/usr.sys.PYR2.5/sys/kern_exit.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/sys/kern_exit.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.PYR2.5/sys/kern_exit.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.PYR2.5/sys/kern_exit.c.diff
XThe following changes ensure that upon exit, a process notifies any remote
Xservers that may know about him, that he is indeed dead.
X***************
X*** 59,64
X  #include "../h/quota.h"
X  #include "../h/cmap.h"
X  #include "../h/text.h"
X  
X  /*
X   * Exit system call: pass back caller's arg
X
X--- 59,67 -----
X  #include "../h/quota.h"
X  #include "../h/cmap.h"
X  #include "../h/text.h"
X+ #ifdef REMOTEFS
X+ #include "../remote/remotefs.h"
X+ #endif REMOTEFS
X  
X  /*
X   * Exit system call: pass back caller's arg
X***************
X*** 99,104
X  	vmsizmon();
X  #endif
X  	p = u.u_procp;
X  
X  	gpid = p->p_gpid;
X  	/*
X
X--- 102,114 -----
X  	vmsizmon();
X  #endif
X  	p = u.u_procp;
X+ #ifdef REMOTEFS
X+ 	/*
X+ 	 * First, release our server.
X+ 	 */
X+ 	if (p->p_flag & SREMOTE)
X+ 		remote_exit();
X+ #endif REMOTEFS
X  
X  	gpid = p->p_gpid;
X  	/*
SHAREOF
chmod 664 remote/usr.sys.PYR2.5/sys/kern_exit.c.diff
#
# remote/usr.sys.PYR2.5/sys/kern_trap.c.diff
#
if [ -f remote/usr.sys.PYR2.5/sys/kern_trap.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/sys/kern_trap.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.PYR2.5/sys/kern_trap.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.PYR2.5/sys/kern_trap.c.diff
XThese changes enable syscall() to start up a remote version of a system
Xcall if the normal system call fails with error == EISREMOTE.
X***************
X*** 47,52
X  #include "../h/vmmac.h"
X  #include "../h/vmmeter.h"
X  #include "../h/debug.h"
X  
X  extern int kernstrt;
X  #define	USER	040		/* user-mode flag added to type */
X
X--- 47,59 -----
X  #include "../h/vmmac.h"
X  #include "../h/vmmeter.h"
X  #include "../h/debug.h"
X+ #ifdef REMOTEFS
X+ #include "../remote/remotefs.h"
X+ /*
X+  * needed only if EISREMOTE isn't in /usr/include/errno.h
X+  */
X+ #include "../h/errno.h"
X+ #endif REMOTEFS
X  
X  extern int kernstrt;
X  #define	USER	040		/* user-mode flag added to type */
X***************
X*** 395,400
X  	register long syst_sec, syst_usec;
X  	register int s;
X  	register int onslave = 0;
X  
X  	SETGR9();	/* for dual cpu, put mastercpu into gr9 */
X  	spl0();		/* move up to system base priority level */
X
X--- 402,411 -----
X  	register long syst_sec, syst_usec;
X  	register int s;
X  	register int onslave = 0;
X+ #ifdef REMOTEFS
X+ 	extern u_char remote_sysmap[];
X+ 	register int rmt_syscall, runremote, rmtcalled, rmtcnt;
X+ #endif REMOTEFS
X  
X  	SETGR9();	/* for dual cpu, put mastercpu into gr9 */
X  	spl0();		/* move up to system base priority level */
X***************
X*** 418,424
X  		if (u.u_error == 0 && u.u_eosys == JUSTRETURN)
X  			u.u_error = EINTR;
X  	} else {
X! 		(*(callproc->sy_call))(arg1, arg2, arg3, arg4, arg5, arg6);
X  	}
X  
X  	if (u.u_eosys != RESTARTSYS)
X
X--- 429,461 -----
X  		if (u.u_error == 0 && u.u_eosys == JUSTRETURN)
X  			u.u_error = EINTR;
X  	} else {
X! #ifdef REMOTEFS
X! 		if (index < 512) {
X! 			rmt_syscall = remote_sysmap[ index ];
X! 			rmtcalled = FALSE;
X! 			rmtcnt = 0;
X! 
X! 			u.u_eosys = JUSTRETURN;
X! 			while (! rmtcalled) {
X! 				runremote = (rmt_syscall != RSYS_nosys
X! 					    && u.u_procp->p_flag & SREMOTE);
X! 				if (runremote)
X! 					rmtcalled = remote_startup(rmtcnt,
X! 						rmt_syscall, arg1, arg2, arg3,
X! 						arg4, arg5, arg6);
X! 				if (! rmtcalled) {
X! 					(*callproc->sy_call)(arg1, arg2, arg3,
X! 						arg4, arg5, arg6);
X! 					if (u.u_error != EISREMOTE)
X! 						rmtcalled = TRUE;
X! 					else
X! 						rmtcnt++;
X! 				}
X! 			}
X! 		} else
X! #endif REMOTEFS
X! 			(*(callproc->sy_call))(arg1, arg2, arg3,
X! 				arg4, arg5, arg6);
X  	}
X  
X  	if (u.u_eosys != RESTARTSYS)
SHAREOF
chmod 664 remote/usr.sys.PYR2.5/sys/kern_trap.c.diff
#
# remote/usr.sys.PYR2.5/sys/sys_inode.c.diff
#
if [ -f remote/usr.sys.PYR2.5/sys/sys_inode.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/sys/sys_inode.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.PYR2.5/sys/sys_inode.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.PYR2.5/sys/sys_inode.c.diff
XThis change repairs a semantic change in ino_close() that assumes
Xthe only other file descriptor type is DTYPE_SOCKET.  If patch tells
Xyou
X	Reversed (or previously applied) patch detected!
XThen you already have the fix and you must undo what patch does.
X***************
X*** 516,522
X  	for (ffp = file; ffp < fileNFILE; ffp++) {
X  		if (ffp == fp)
X  			continue;
X! 		if (ffp->f_type == DTYPE_SOCKET)		/* XXX */
X  			continue;
X  		if (ffp->f_count && (ip = (struct inode *)ffp->f_data) &&
X  		    ip->i_rdev == dev && (ip->i_mode&IFMT) == mode)
X
X--- 516,522 -----
X  	for (ffp = file; ffp < fileNFILE; ffp++) {
X  		if (ffp == fp)
X  			continue;
X! 		if (ffp->f_type != DTYPE_INODE)	/* semantic fix (toddb@du) */
X  			continue;
X  		if (ffp->f_count && (ip = (struct inode *)ffp->f_data) &&
X  		    ip->i_rdev == dev && (ip->i_mode&IFMT) == mode)
SHAREOF
chmod 664 remote/usr.sys.PYR2.5/sys/sys_inode.c.diff
#
# remote/usr.sys.PYR2.5/sys/ufs_nami.c.diff
#
if [ -f remote/usr.sys.PYR2.5/sys/ufs_nami.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/sys/ufs_nami.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.PYR2.5/sys/ufs_nami.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.PYR2.5/sys/ufs_nami.c.diff
XThese changes are the primary hook into the operating system for detecting
Xa "remote" file.
X***************
X*** 145,150
X  	unsigned hash;			/* value of name hash for entry */
X  	union nchash *nhp;		/* cache chain head for entry */
X  	int isdotdot;			/* != 0 if current name is ".." */
X  
X  	sysVinfo.sV_namei++;
X  	lockparent = flag & LOCKPARENT;
X
X--- 145,153 -----
X  	unsigned hash;			/* value of name hash for entry */
X  	union nchash *nhp;		/* cache chain head for entry */
X  	int isdotdot;			/* != 0 if current name is ".." */
X+ #ifdef REMOTEFS
X+ 	long    remote;
X+ #endif REMOTEFS
X  
X  	sysVinfo.sV_namei++;
X  	lockparent = flag & LOCKPARENT;
X***************
X*** 189,194
X  	 * Check accessiblity of directory.
X  	 */
X  	if ((dp->i_mode&IFMT) != IFDIR) {
X  		u.u_error = ENOTDIR;
X  		goto bad;
X  	}
X
X--- 192,214 -----
X  	 * Check accessiblity of directory.
X  	 */
X  	if ((dp->i_mode&IFMT) != IFDIR) {
X+ #ifdef REMOTEFS
X+ 		remote = isremote(dp, cp, nbp->b_un.b_addr);
X+ 
X+ 		/*
X+ 		 * If it is really local, then start again at the root.
X+ 		 */
X+ 		if (remote < 0) {
X+ 			iput(dp);
X+ 			dp = rootdir;
X+ 			ilockx(dp);
X+ 			dp->i_count++;
X+ 			fs = dp->i_fs;
X+ 			cp = nbp->b_un.b_addr;
X+ 			goto dirloop2;
X+ 		}
X+ 		else if (! remote)
X+ #endif REMOTEFS
X  		u.u_error = ENOTDIR;
X  		goto bad;
X  	}
X***************
X*** 604,609
X  					u.u_error = EPERM;
X  					goto bad;
X  				}
X  			}
X  		}
X  #ifdef NSA
X
X--- 624,640 -----
X  					u.u_error = EPERM;
X  					goto bad;
X  				}
X+ #ifdef REMOTEFS
X+ 				/*
X+ 				 * don't allow anyone to remove a remote mount
X+ 				 * point.
X+ 				 */
X+ 				if (rmt_host(dp, &i)) {
X+ 					iput(u.u_pdir);
X+ 					u.u_error = EBUSY;
X+ 					goto bad;
X+ 				}
X+ #endif REMOTEFS
X  			}
X  		}
X  #ifdef NSA
X***************
X*** 786,791
X  
X  		if (len + pathlen >= MAXPATHLEN - 1 ||
X  		    ++nlink > MAXSYMLINKS) {
X  			u.u_error = ELOOP;
X  			goto bad2;
X  		}
X
X--- 817,824 -----
X  
X  		if (len + pathlen >= MAXPATHLEN - 1 ||
X  		    ++nlink > MAXSYMLINKS) {
X+ 			printf("nlink=%d,len=%d,pathlen=%d:LOOP\n",
X+ 				nlink, len, pathlen);
X  			u.u_error = ELOOP;
X  			goto bad2;
X  		}
SHAREOF
chmod 664 remote/usr.sys.PYR2.5/sys/ufs_nami.c.diff
#
# remote/usr.sys.PYR2.5/sys/ufs_syscalls.c.diff
#
if [ -f remote/usr.sys.PYR2.5/sys/ufs_syscalls.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/sys/ufs_syscalls.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.PYR2.5/sys/ufs_syscalls.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.PYR2.5/sys/ufs_syscalls.c.diff
XThese changes modify chdirec(), which is called by chroot() and chdir(),
Xso that you can be allowed to do a chdir() to a remote mount point.
XIn addition, the changes ensure that we adjust internal pointers when doing
Xa chdir() OUT of a remote mount point.
X***************
X*** 104,109
X  	register struct inode **ipp;
X  {
X  	register struct inode *ip;
X  
X  	ip = namei(uchar, LOOKUP, 1);
X  	if (ip == NULL)
X
X--- 104,112 -----
X  	register struct inode **ipp;
X  {
X  	register struct inode *ip;
X+ #ifdef REMOTEFS
X+ 	int	i;
X+ #endif REMOTEFS
X  
X  	ip = namei(uchar, LOOKUP, 1);
X  	if (ip == NULL)
X***************
X*** 109,114
X  	if (ip == NULL)
X  		return;
X  	if ((ip->i_mode&IFMT) != IFDIR) {
X  		u.u_error = ENOTDIR;
X  		goto bad;
X  	}
X
X--- 112,123 -----
X  	if (ip == NULL)
X  		return;
X  	if ((ip->i_mode&IFMT) != IFDIR) {
X+ #ifdef REMOTEFS
X+ 		if (rmt_hostdir(ip, &i) != NULL)
X+ 			u.u_error = remotechdir(i);
X+ 		else
X+ 			u.u_error = ENOTDIR;
X+ #else REMOTEFS
X  		u.u_error = ENOTDIR;
X  #endif REMOTEFS
X  		goto bad;
X***************
X*** 110,115
X  		return;
X  	if ((ip->i_mode&IFMT) != IFDIR) {
X  		u.u_error = ENOTDIR;
X  		goto bad;
X  	}
X  	if (access(ip, IEXEC))
X
X--- 119,125 -----
X  			u.u_error = ENOTDIR;
X  #else REMOTEFS
X  		u.u_error = ENOTDIR;
X+ #endif REMOTEFS
X  		goto bad;
X  	}
X  	if (access(ip, IEXEC))
X***************
X*** 114,119
X  	}
X  	if (access(ip, IEXEC))
X  		goto bad;
X  	iunlock(ip);
X  	if (*ipp)
X  		irele(*ipp);
X
X--- 124,132 -----
X  	}
X  	if (access(ip, IEXEC))
X  		goto bad;
X+ #ifdef REMOTEFS
X+ 	remotechdir(-1);
X+ #endif REMOTEFS
X  	iunlock(ip);
X  	if (*ipp)
X  		irele(*ipp);
SHAREOF
chmod 664 remote/usr.sys.PYR2.5/sys/ufs_syscalls.c.diff
#
# remote/usr.sys.PYR2.5/sys/uipc_socket.c.diff
#
if [ -f remote/usr.sys.PYR2.5/sys/uipc_socket.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.PYR2.5/sys/uipc_socket.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.PYR2.5/sys/uipc_socket.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.PYR2.5/sys/uipc_socket.c.diff
XThese changes Fix a bug in soreceive() that caused infinite loop if a
Xpacket was received while doing uiomove() and the MSG_PEEK flag was set.
XIf you have this fix, then patch will tell you:
X
X        Reversed (or previously applied) patch detected!
X
XIf it does, you should just reinstall your original uipc_socket.c.
XIf you have a different version of the fix or another modification that
Xaffects this code, then patch will tell you that "Hunk #1 failed"; you
Xmust install the patch by hand.
X***************
X*** 659,665
X  		error =
X  		    uiomove(mtod(m, caddr_t) + moff, (int)len, UIO_READ, uio);
X  		s = splnet();
X! 		if (len == m->m_len) {
X  			eor = (int)m->m_act;
X  			if (flags & MSG_PEEK)
X  				m = m->m_next;
X
X--- 659,665 -----
X  		error =
X  		    uiomove(mtod(m, caddr_t) + moff, (int)len, UIO_READ, uio);
X  		s = splnet();
X! 		if (moff+len == m->m_len) { /* infinite loop fix (toddb@du) */
X  			eor = (int)m->m_act;
X  			if (flags & MSG_PEEK)
X  				m = m->m_next;
SHAREOF
chmod 664 remote/usr.sys.PYR2.5/sys/uipc_socket.c.diff
#
# remote/usr.sys.VAX4.2/conf/files.diff
#
if [ -f remote/usr.sys.VAX4.2/conf/files.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/conf/files.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.2/conf/files.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.2/conf/files.diff
XThe files added here identify the RFS source code.
X***************
X*** 107,108
X  sys/vm_swp.c		standard
X  sys/vm_text.c		standard
X
X--- 107,118 -----
X  sys/vm_swp.c		standard
X  sys/vm_text.c		standard
X+ remote/rmt_data.c	optional remotefs
X+ remote/rmt_exec.c	optional remotefs
X+ remote/rmt_final.c	optional remotefs
X+ remote/rmt_general.c	optional remotefs
X+ remote/rmt_generic.c	optional remotefs
X+ remote/rmt_io.c		optional remotefs
X+ remote/rmt_subr.c	optional remotefs
X+ remote/rmt_syscall1.c	optional remotefs
X+ remote/rmt_syscall2.c	optional remotefs
X+ remote/rmt_syscall3.c	optional remotefs
SHAREOF
chmod 664 remote/usr.sys.VAX4.2/conf/files.diff
if [ -f remote/usr.sys.VAX4.3/conf/files.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/conf/files.diff or ^C to quit' 
	read ans 
	rm -rf remote/usr.sys.VAX4.3/conf/files.diff 
fi
ln remote/usr.sys.VAX4.2/conf/files.diff remote/usr.sys.VAX4.3/conf/files.diff
#
# remote/usr.sys.VAX4.2/conf/makefile.vax.diff
#
if [ -f remote/usr.sys.VAX4.2/conf/makefile.vax.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/conf/makefile.vax.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.2/conf/makefile.vax.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.2/conf/makefile.vax.diff
XThis change teaches the makefile how to make rmt_data.c from
X../remote/remotefs.h, ../remote/rmt_data_template and ../sys/init_sysent.c.
X***************
X*** 166,168
X  
X  %RULES
X  
X
X--- 166,175 -----
X  
X+ ../remote/rmt_data.c: ../remote/rmt_data_template ../remote/remotefs.h \
X+     ../sys/init_sysent.c
X+ 	cat ../remote/rmt_data_template > ../remote/nrmt_data.c
X+ 	/lib/cpp ${CFLAGS} ../sys/init_sysent.c | sh ../remote/remote_mkdata \
X+ 		../remote/remotefs.h >> ../remote/nrmt_data.c
X+ 	mv ../remote/nrmt_data.c ../remote/rmt_data.c
X+ 
X  %RULES
X  
SHAREOF
chmod 664 remote/usr.sys.VAX4.2/conf/makefile.vax.diff
#
# remote/usr.sys.VAX4.2/h/errno.h.diff
#
if [ -f remote/usr.sys.VAX4.2/h/errno.h.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/h/errno.h.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.2/h/errno.h.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.2/h/errno.h.diff
XThese changes add three new error numbers for the sake of RFS.
X***************
X*** 94,96
X  #define	EPROCLIM	67		/* Too many processes */
X  #define	EUSERS		68		/* Too many users */
X  #define	EDQUOT		69		/* Disc quota exceeded */
X
X--- 94,101 -----
X  #define	EPROCLIM	67		/* Too many processes */
X  #define	EUSERS		68		/* Too many users */
X  #define	EDQUOT		69		/* Disc quota exceeded */
X+ 
X+ /* remote fs stuff */
X+ #define EISREMOTE	70		/* file is on a remote system */
X+ #define ETOOMANYREMOTE	71		/* too many remote file systems */
X+ #define	ENOREMOTEFS	72		/* no remote file system */
SHAREOF
chmod 664 remote/usr.sys.VAX4.2/h/errno.h.diff
if [ -f remote/usr.sys.VAX4.3/h/errno.h.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/h/errno.h.diff or ^C to quit' 
	read ans 
	rm -rf remote/usr.sys.VAX4.3/h/errno.h.diff 
fi
ln remote/usr.sys.VAX4.2/h/errno.h.diff remote/usr.sys.VAX4.3/h/errno.h.diff
#
# remote/usr.sys.VAX4.2/h/user.h.diff
#
if [ -f remote/usr.sys.VAX4.2/h/user.h.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/h/user.h.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.2/h/user.h.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.2/h/user.h.diff
XThese changes keep track of the per-process RFS information.
X***************
X*** 140,145
X  		unsigned pr_off;	/* pc offset */
X  		unsigned pr_scale;	/* pc scaling */
X  	} u_prof;
X  	int	u_stack[1];
X  };
X  
X
X--- 140,155 -----
X  		unsigned pr_off;	/* pc offset */
X  		unsigned pr_scale;	/* pc scaling */
X  	} u_prof;
X+ #ifdef REMOTEFS
X+ 	short	u_rmtoffset[2];		/* path offset for local segment */
X+ 	short	u_rmtcdir;		/* system # of remote current dir */
X+ 	long	u_rmtsys;		/* room for 32 systems */
X+ 					/* one bit for each remote system */
X+ #ifdef pyr /* Pyramid */
X+ 	int	*u.u_ap;
X+ #define		u_arg	u_ap
X+ #endif pyr
X+ #endif REMOTEFS
X  	int	u_stack[1];
X  };
X  
SHAREOF
chmod 664 remote/usr.sys.VAX4.2/h/user.h.diff
#
# remote/usr.sys.VAX4.2/machine/trap.c.diff
#
if [ -f remote/usr.sys.VAX4.2/machine/trap.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/machine/trap.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.2/machine/trap.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.2/machine/trap.c.diff
XThese changes enable syscall() to start up a remote version of a system
Xcall if the normal system call fails with error == EISREMOTE.
X***************
X*** 25,30
X  #ifdef SYSCALLTRACE
X  #include "../sys/syscalls.c"
X  #endif
X  
X  #include "../vax/mtpr.h"
X  
X
X--- 25,37 -----
X  #ifdef SYSCALLTRACE
X  #include "../sys/syscalls.c"
X  #endif
X+ #ifdef REMOTEFS
X+ #include "../remote/remotefs.h"
X+ /*
X+  * needed only if EISREMOTE isn't in /usr/include/errno.h
X+  */
X+ #include "../h/errno.h"
X+ #endif REMOTEFS
X  
X  #include "../vax/mtpr.h"
X  
X***************
X*** 193,198
X  	register struct proc *p;
X  	int opc;
X  	struct timeval syst;
X  
X  	syst = u.u_ru.ru_stime;
X  	if (!USERMODE(locr0[PS]))
X
X--- 200,214 -----
X  	register struct proc *p;
X  	int opc;
X  	struct timeval syst;
X+ #ifdef REMOTEFS
X+ 	/*
X+ 	 * It is imperative that these declarations come after other register
X+ 	 * declarations, because the (standard) code below depends upon the
X+ 	 * order of allocation.
X+ 	 */
X+ 	extern u_char remote_sysmap[];
X+ 	register long rmt_syscall, runremote, rmt_called, rmt_cnt;
X+ #endif REMOTEFS
X  
X  	syst = u.u_ru.ru_stime;
X  	if (!USERMODE(locr0[PS]))
X***************
X*** 233,238
X  		if (u.u_error == 0 && u.u_eosys == JUSTRETURN)
X  			u.u_error = EINTR;
X  	} else {
X  		u.u_eosys = JUSTRETURN;
X  #ifdef SYSCALLTRACE
X  		if (syscalltrace) {
X
X--- 249,258 -----
X  		if (u.u_error == 0 && u.u_eosys == JUSTRETURN)
X  			u.u_error = EINTR;
X  	} else {
X+ #ifdef REMOTEFS
X+ 		rmt_syscall = remote_sysmap[ code ];
X+ 		rmt_called = FALSE;
X+ 		rmt_cnt = 0;
X  		u.u_eosys = JUSTRETURN;
X  		while (! rmt_called) {
X  			runremote = (rmt_syscall != RSYS_nosys
X***************
X*** 234,239
X  			u.u_error = EINTR;
X  	} else {
X  		u.u_eosys = JUSTRETURN;
X  #ifdef SYSCALLTRACE
X  		if (syscalltrace) {
X  			register int i;
X
X--- 254,275 -----
X  		rmt_called = FALSE;
X  		rmt_cnt = 0;
X  		u.u_eosys = JUSTRETURN;
X+ 		while (! rmt_called) {
X+ 			runremote = (rmt_syscall != RSYS_nosys
X+ 				    && u.u_procp->p_flag & SREMOTE);
X+ 			if (runremote)
X+ 				rmt_called = remote_startup(rmt_cnt,
X+ 					rmt_syscall);
X+ 			if (! rmt_called) {
X+ 				(*callp->sy_call)();
X+ 				if (u.u_error != EISREMOTE)
X+ 					rmt_called = TRUE;
X+ 				else
X+ 					rmt_cnt++;
X+ 			}
X+ 		}
X+ #else REMOTEFS
X+ 		u.u_eosys = JUSTRETURN;
X  #ifdef SYSCALLTRACE
X  		if (syscalltrace) {
X  			register int i;
X***************
X*** 254,259
X  		}
X  #endif
X  		(*(callp->sy_call))();
X  	}
X  	locr0[PS] &= ~PSL_C;
X  	if (u.u_eosys == RESTARTSYS)
X
X--- 290,296 -----
X  		}
X  #endif
X  		(*(callp->sy_call))();
X+ #endif REMOTEFS
X  	}
X  	locr0[PS] &= ~PSL_C;
X  	if (u.u_eosys == RESTARTSYS)
SHAREOF
chmod 664 remote/usr.sys.VAX4.2/machine/trap.c.diff
#
# remote/usr.sys.VAX4.2/sys/init_sysent.c.diff
#
if [ -f remote/usr.sys.VAX4.2/sys/init_sysent.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/sys/init_sysent.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.2/sys/init_sysent.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.2/sys/init_sysent.c.diff
XThese two changes add in the new RFS systems calls, remoteon(), remoteoff()
Xand  remotename().  If the second hunk fails, then you have some system
Xcall numbers that are not in standard 4.2BSD.
X***************
X*** 99,99
X  /* BEGIN JUNK */
X
X--- 99,107 -----
X+ #ifdef REMOTEFS
X+ /*
X+  * remote file sys stuff (toddb@du)
X+  */
X+ int	remoteon(),		/* remote file sys stuff */
X+ 	remoteoff(),
X+ 	remotename();
X+ #endif REMOTEFS
X  /* BEGIN JUNK */
X***************
X*** 270,274
X  	2, setquota,			/* 148 = quota */
X  	4, qquota,			/* 149 = qquota */
X  	3, getsockname,			/* 150 = getsockname */
X  };
X  int	nsysent = sizeof (sysent) / sizeof (sysent[0]);
X
X--- 278,291 -----
X  	2, setquota,			/* 148 = quota */
X  	4, qquota,			/* 149 = qquota */
X  	3, getsockname,			/* 150 = getsockname */
X+ #ifdef REMOTEFS
X+ 	4, remoteon,			/* 151 = remoteon */
X+ 	1, remoteoff,			/* 152 = remoteoff */
X+ 	4, remotename,			/* 153 = remotename */
X+ #else REMOTEFS
X+ 	0, nosys,			/* 151 = nosys */
X+ 	0, nosys,			/* 152 = nosys */
X+ 	0, nosys,			/* 153 = nosys */
X+ #endif REMOTEFS
X  };
X  int	nsysent = sizeof (sysent) / sizeof (sysent[0]);
SHAREOF
chmod 664 remote/usr.sys.VAX4.2/sys/init_sysent.c.diff
#
# remote/usr.sys.VAX4.2/sys/kern_exec.c.diff
#
if [ -f remote/usr.sys.VAX4.2/sys/kern_exec.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/sys/kern_exec.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.2/sys/kern_exec.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.2/sys/kern_exec.c.diff
XThe following changes implement local execution of an object file that
Xlives on another host.
X***************
X*** 28,33
X  #include "../h/uio.h"
X  #include "../h/nami.h"
X  #include "../h/acct.h"
X  
X  #ifdef vax
X  #include "../vax/mtpr.h"
X
X--- 28,39 -----
X  #include "../h/uio.h"
X  #include "../h/nami.h"
X  #include "../h/acct.h"
X+ #ifdef REMOTEFS
X+ /*
X+  * needed only if EISREMOTE isn't in /usr/include/errno.h
X+  */
X+ #include "../h/errno.h"
X+ #endif REMOTEFS
X  
X  #ifdef vax
X  #include "../vax/mtpr.h"
X***************
X*** 57,62
X  	int na, ne, ucp, ap, c;
X  	int indir, uid, gid;
X  	char *sharg;
X  	struct inode *ip;
X  	swblk_t bno;
X  	char cfname[MAXCOMLEN + 1];
X
X--- 63,72 -----
X  	int na, ne, ucp, ap, c;
X  	int indir, uid, gid;
X  	char *sharg;
X+ #ifdef REMOTEFS
X+ 	struct inode *ip; /* have to take address */
X+ 	int	remote = -1;
X+ #else REMOTEFS
X  	struct inode *ip;
X  #endif REMOTEFS
X  	swblk_t bno;
X***************
X*** 58,63
X  	int indir, uid, gid;
X  	char *sharg;
X  	struct inode *ip;
X  	swblk_t bno;
X  	char cfname[MAXCOMLEN + 1];
X  	char cfarg[SHSIZE];
X
X--- 68,74 -----
X  	int	remote = -1;
X  #else REMOTEFS
X  	struct inode *ip;
X+ #endif REMOTEFS
X  	swblk_t bno;
X  	char cfname[MAXCOMLEN + 1];
X  	char cfarg[SHSIZE];
X***************
X*** 64,69
X  	int resid;
X  
X  	if ((ip = namei(uchar, LOOKUP, 1)) == NULL)
X  		return;
X  	bno = 0;
X  	bp = 0;
X
X--- 75,86 -----
X  	int resid;
X  
X  	if ((ip = namei(uchar, LOOKUP, 1)) == NULL)
X+ #ifdef REMOTEFS
X+ 		if (u.u_error == EISREMOTE)
X+ 			remote = remote_execinfo(&ip, &uid, &gid,
X+ 				((struct execa *)u.u_ap)->fname);
X+ 	if (u.u_error)
X+ #endif REMOTEFS
X  		return;
X  	bno = 0;
X  	bp = 0;
X***************
X*** 68,73
X  	bno = 0;
X  	bp = 0;
X  	indir = 0;
X  	uid = u.u_uid;
X  	gid = u.u_gid;
X  	if (ip->i_mode & ISUID)
X
X--- 85,93 -----
X  	bno = 0;
X  	bp = 0;
X  	indir = 0;
X+ #ifdef REMOTEFS
X+ if (remote < 0) {
X+ #endif REMOTEFS
X  	uid = u.u_uid;
X  	gid = u.u_gid;
X  	if (ip->i_mode & ISUID)
X***************
X*** 106,111
X  	if (u.u_error)
X  		goto bad;
X  	u.u_count = resid;
X  #ifndef lint
X  	if (u.u_count > sizeof(u.u_exdata) - sizeof(u.u_exdata.Ux_A) &&
X  	    u.u_exdata.ux_shell[0] != '#') {
X
X--- 126,137 -----
X  	if (u.u_error)
X  		goto bad;
X  	u.u_count = resid;
X+ #ifdef REMOTEFS
X+ }
X+ 
X+ remote_again:
X+ 
X+ #endif REMOTEFS
X  #ifndef lint
X  	if (u.u_count > sizeof(u.u_exdata) - sizeof(u.u_exdata.Ux_A) &&
X  	    u.u_exdata.ux_shell[0] != '#') {
X***************
X*** 171,176
X  		    (unsigned)(u.u_dent.d_namlen + 1));
X  		cfname[MAXCOMLEN] = 0;
X  		indir = 1;
X  		iput(ip);
X  		ip = namei(schar, LOOKUP, 1);
X  		if (ip == NULL)
X
X--- 197,205 -----
X  		    (unsigned)(u.u_dent.d_namlen + 1));
X  		cfname[MAXCOMLEN] = 0;
X  		indir = 1;
X+ #ifdef REMOTEFS
X+ 		if (remote < 0)
X+ #endif REMOTEFS
X  		iput(ip);
X  		ip = namei(schar, LOOKUP, 1);
X  #ifdef REMOTEFS
X***************
X*** 173,178
X  		indir = 1;
X  		iput(ip);
X  		ip = namei(schar, LOOKUP, 1);
X  		if (ip == NULL)
X  			return;
X  		goto again;
X
X--- 202,219 -----
X  #endif REMOTEFS
X  		iput(ip);
X  		ip = namei(schar, LOOKUP, 1);
X+ #ifdef REMOTEFS
X+ 		if (ip == NULL) {
X+ 			if (u.u_error == EISREMOTE)
X+ 				remote = remote_execinfo(&ip, 0, 0, 0);
X+ 			if (u.u_error)
X+ 				return;
X+ 			if (ip == NULL)
X+ 				goto remote_again;
X+ 		}
X+ 		else
X+ 			remote = -1;
X+ #else REMOTEFS
X  		if (ip == NULL)
X  			return;
X  #endif REMOTEFS
X***************
X*** 175,180
X  		ip = namei(schar, LOOKUP, 1);
X  		if (ip == NULL)
X  			return;
X  		goto again;
X  	}
X  
X
X--- 216,222 -----
X  #else REMOTEFS
X  		if (ip == NULL)
X  			return;
X+ #endif REMOTEFS
X  		goto again;
X  	}
X  
X***************
X*** 244,249
X  		bcopy((caddr_t)cfname, (caddr_t)u.u_dent.d_name,
X  		    (unsigned)(u.u_dent.d_namlen + 1));
X  	}
X  	getxfile(ip, nc + (na+4)*NBPW, uid, gid);
X  	if (u.u_error) {
X  badarg:
X
X--- 286,294 -----
X  		bcopy((caddr_t)cfname, (caddr_t)u.u_dent.d_name,
X  		    (unsigned)(u.u_dent.d_namlen + 1));
X  	}
X+ #ifdef REMOTEFS
X+ 	getxfile(ip, nc + (na+4)*NBPW, uid, gid, remote);
X+ #else REMOTEFS
X  	getxfile(ip, nc + (na+4)*NBPW, uid, gid);
X  #endif REMOTEFS
X  	if (u.u_error) {
X***************
X*** 245,250
X  		    (unsigned)(u.u_dent.d_namlen + 1));
X  	}
X  	getxfile(ip, nc + (na+4)*NBPW, uid, gid);
X  	if (u.u_error) {
X  badarg:
X  		for (c = 0; c < nc; c += CLSIZE*NBPG) {
X
X--- 290,296 -----
X  	getxfile(ip, nc + (na+4)*NBPW, uid, gid, remote);
X  #else REMOTEFS
X  	getxfile(ip, nc + (na+4)*NBPW, uid, gid);
X+ #endif REMOTEFS
X  	if (u.u_error) {
X  badarg:
X  		for (c = 0; c < nc; c += CLSIZE*NBPG) {
X***************
X*** 303,308
X  /*
X   * Read in and set up memory for executed file.
X   */
X  getxfile(ip, nargc, uid, gid)
X  	register struct inode *ip;
X  	int nargc, uid, gid;
X
X--- 349,357 -----
X  /*
X   * Read in and set up memory for executed file.
X   */
X+ #ifdef REMOTEFS
X+ getxfile(ip, nargc, uid, gid, remote)
X+ #else REMOTEFS
X  getxfile(ip, nargc, uid, gid)
X  #endif REMOTEFS
X  	register struct inode *ip;
X***************
X*** 304,309
X   * Read in and set up memory for executed file.
X   */
X  getxfile(ip, nargc, uid, gid)
X  	register struct inode *ip;
X  	int nargc, uid, gid;
X  {
X
X--- 353,359 -----
X  getxfile(ip, nargc, uid, gid, remote)
X  #else REMOTEFS
X  getxfile(ip, nargc, uid, gid)
X+ #endif REMOTEFS
X  	register struct inode *ip;
X  	int nargc, uid, gid;
X  {
X***************
X*** 309,314
X  {
X  	register size_t ts, ds, ss;
X  	int pagi;
X  
X  	if (u.u_exdata.ux_mag == 0413)
X  		pagi = SPAGI;
X
X--- 359,367 -----
X  {
X  	register size_t ts, ds, ss;
X  	int pagi;
X+ #ifdef REMOTEFS
X+ 	int	oldtextsize;
X+ #endif REMOTEFS
X  
X  	if (u.u_exdata.ux_mag == 0413)
X  		pagi = SPAGI;
X***************
X*** 314,319
X  		pagi = SPAGI;
X  	else
X  		pagi = 0;
X  	if (u.u_exdata.ux_tsize!=0 && (ip->i_flag&ITEXT)==0 &&
X  	    ip->i_count!=1) {
X  		register struct file *fp;
X
X--- 367,383 -----
X  		pagi = SPAGI;
X  	else
X  		pagi = 0;
X+ #ifdef REMOTEFS
X+ 	if (remote >= 0) {
X+ 		/*
X+ 		 * Prevent xalloc() from making a shared or paged text.
X+ 		 */
X+ 		pagi = 0;
X+ 		oldtextsize = u.u_exdata.ux_tsize;
X+ 		u.u_exdata.ux_dsize += u.u_exdata.ux_tsize;
X+ 		u.u_exdata.ux_tsize = 0;
X+ 	}
X+ #endif REMOTEFS
X  	if (u.u_exdata.ux_tsize!=0 && (ip->i_flag&ITEXT)==0 &&
X  	    ip->i_count!=1) {
X  		register struct file *fp;
X***************
X*** 370,375
X  	u.u_smap = u.u_csmap;
X  	vgetvm(ts, ds, ss);
X  
X  	if (pagi == 0)
X  		u.u_error =
X  		    rdwri(UIO_READ, ip,
X
X--- 434,444 -----
X  	u.u_smap = u.u_csmap;
X  	vgetvm(ts, ds, ss);
X  
X+ #ifdef REMOTEFS
X+ 	if (remote >= 0)
X+ 		u.u_error = remote_execread(remote, oldtextsize);
X+ 	else
X+ #endif REMOTEFS
X  	if (pagi == 0)
X  		u.u_error =
X  		    rdwri(UIO_READ, ip,
SHAREOF
chmod 664 remote/usr.sys.VAX4.2/sys/kern_exec.c.diff
#
# remote/usr.sys.VAX4.2/sys/kern_exit.c.diff
#
if [ -f remote/usr.sys.VAX4.2/sys/kern_exit.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/sys/kern_exit.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.2/sys/kern_exit.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.2/sys/kern_exit.c.diff
XThe following changes ensure that upon exit, a process notifies any remote
Xservers that may know about him, that he is indeed dead.
X***************
X*** 33,38
X  #include "../h/file.h"
X  #include "../h/mbuf.h"
X  #include "../h/inode.h"
X  
X  /*
X   * Exit system call: pass back caller's arg
X
X--- 33,41 -----
X  #include "../h/file.h"
X  #include "../h/mbuf.h"
X  #include "../h/inode.h"
X+ #ifdef REMOTEFS
X+ #include "../remote/remotefs.h"
X+ #endif REMOTEFS
X  
X  /*
X   * Exit system call: pass back caller's arg
X***************
X*** 66,71
X  	vmsizmon();
X  #endif
X  	p = u.u_procp;
X  	p->p_flag &= ~(STRC|SULOCK);
X  	p->p_flag |= SWEXIT;
X  	p->p_sigignore = ~0;
X
X--- 69,81 -----
X  	vmsizmon();
X  #endif
X  	p = u.u_procp;
X+ #ifdef REMOTEFS
X+ 	/*
X+ 	 * First, release our server.
X+ 	 */
X+ 	if (p->p_flag & SREMOTE)
X+ 		remote_exit();
X+ #endif REMOTEFS
X  	p->p_flag &= ~(STRC|SULOCK);
X  	p->p_flag |= SWEXIT;
X  	p->p_sigignore = ~0;
SHAREOF
chmod 664 remote/usr.sys.VAX4.2/sys/kern_exit.c.diff
#
# remote/usr.sys.VAX4.2/sys/sys_inode.c.diff
#
if [ -f remote/usr.sys.VAX4.2/sys/sys_inode.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/sys/sys_inode.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.2/sys/sys_inode.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.2/sys/sys_inode.c.diff
XThis change repairs a semantic change in ino_close() that assumes
Xthe only other file descriptor type is DTYPE_SOCKET.  If patch tells
Xyou
X	Reversed (or previously applied) patch detected!
XThen you already have the fix and you must undo what patch does.
X
X***************
X*** 351,357
X  	 * two different inodes.
X  	 */
X  	for (fp = file; fp < fileNFILE; fp++) {
X! 		if (fp->f_type == DTYPE_SOCKET)		/* XXX */
X  			continue;
X  		if (fp->f_count && (ip = (struct inode *)fp->f_data) &&
X  		    ip->i_rdev == dev && (ip->i_mode&IFMT) == mode)
X
X--- 351,357 -----
X  	 * two different inodes.
X  	 */
X  	for (fp = file; fp < fileNFILE; fp++) {
X! 		if (fp->f_type != DTYPE_INODE)	/* XXX */
X  			continue;
X  		if (fp->f_count && (ip = (struct inode *)fp->f_data) &&
X  		    ip->i_rdev == dev && (ip->i_mode&IFMT) == mode)
SHAREOF
chmod 664 remote/usr.sys.VAX4.2/sys/sys_inode.c.diff
#
# remote/usr.sys.VAX4.2/sys/ufs_nami.c.diff
#
if [ -f remote/usr.sys.VAX4.2/sys/ufs_nami.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/sys/ufs_nami.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.2/sys/ufs_nami.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.2/sys/ufs_nami.c.diff
XThese changes are the primary hook into the operating system for detecting
Xa "remote" file.
X***************
X*** 97,102
X  	struct inode *pdp;		/* saved dp during symlink work */
X  	int i;
X  	int lockparent;
X  
X  	lockparent = flag & LOCKPARENT;
X  	flag &= ~LOCKPARENT;
X
X--- 97,105 -----
X  	struct inode *pdp;		/* saved dp during symlink work */
X  	int i;
X  	int lockparent;
X+ #ifdef REMOTEFS
X+ 	long	remote;
X+ #endif REMOTEFS
X  
X  	lockparent = flag & LOCKPARENT;
X  	flag &= ~LOCKPARENT;
X***************
X*** 145,150
X  	 * Check accessiblity of directory.
X  	 */
X  	if ((dp->i_mode&IFMT) != IFDIR) {
X  		u.u_error = ENOTDIR;
X  		goto bad;
X  	}
X
X--- 148,169 -----
X  	 * Check accessiblity of directory.
X  	 */
X  	if ((dp->i_mode&IFMT) != IFDIR) {
X+ #ifdef REMOTEFS
X+ 		remote = isremote(dp, cp, nbp->b_un.b_addr);
X+ 		/*
X+ 		 * If it is really local, then start again at the root.
X+ 		 */
X+ 		if (remote < 0) {
X+ 			iput(dp);
X+ 			dp = rootdir;
X+ 			ilock(dp);
X+ 			dp->i_count++;
X+ 			fs = dp->i_fs;
X+ 			cp = nbp->b_un.b_addr;
X+ 			goto dirloop2;
X+ 		}
X+ 		else if (! remote)
X+ #endif REMOTEFS
X  		u.u_error = ENOTDIR;
X  		goto bad;
X  	}
X***************
X*** 382,387
X  					iput(u.u_pdir);
X  					goto bad;
X  				}
X  			}
X  		}
X  		brelse(nbp);
X
X--- 401,417 -----
X  					iput(u.u_pdir);
X  					goto bad;
X  				}
X+ #ifdef REMOTEFS
X+ 				/*
X+ 				 * don't allow anyone to remove a remote mount
X+ 				 * point.
X+ 				 */
X+ 				if (rmt_host(dp, &i)) {
X+ 					iput(u.u_pdir);
X+ 					u.u_error = EBUSY;
X+ 					goto bad;
X+ 				}
X+ #endif REMOTEFS
X  			}
X  		}
X  		brelse(nbp);
SHAREOF
chmod 664 remote/usr.sys.VAX4.2/sys/ufs_nami.c.diff
#
# remote/usr.sys.VAX4.2/sys/ufs_syscalls.c.diff
#
if [ -f remote/usr.sys.VAX4.2/sys/ufs_syscalls.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/sys/ufs_syscalls.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.2/sys/ufs_syscalls.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.2/sys/ufs_syscalls.c.diff
XThese changes modify chdirec(), which is called by chroot() and chdir(),
Xso that you can be allowed to do a chdir() to a remote mount point.
XIn addition, the changes ensure that we adjust internal pointers when doing
Xa chdir() OUT of a remote mount point.
X
X***************
X*** 67,72
X  chdirec(ipp)
X  	register struct inode **ipp;
X  {
X  	register struct inode *ip;
X  	struct a {
X  		char	*fname;
X
X--- 67,75 -----
X  chdirec(ipp)
X  	register struct inode **ipp;
X  {
X+ #ifdef REMOTEFS
X+ 	int	i;
X+ #endif REMOTEFS
X  	register struct inode *ip;
X  	struct a {
X  		char	*fname;
X***************
X*** 76,81
X  	if (ip == NULL)
X  		return;
X  	if ((ip->i_mode&IFMT) != IFDIR) {
X  		u.u_error = ENOTDIR;
X  		goto bad;
X  	}
X
X--- 79,89 -----
X  	if (ip == NULL)
X  		return;
X  	if ((ip->i_mode&IFMT) != IFDIR) {
X+ #ifdef REMOTEFS
X+ 		if (rmt_hostdir(ip, &i) != NULL)
X+ 			u.u_error = remotechdir(i);
X+ 		else
X+ #endif REMOTEFS
X  		u.u_error = ENOTDIR;
X  		goto bad;
X  	}
X***************
X*** 81,86
X  	}
X  	if (access(ip, IEXEC))
X  		goto bad;
X  	iunlock(ip);
X  	if (*ipp)
X  		irele(*ipp);
X
X--- 89,97 -----
X  	}
X  	if (access(ip, IEXEC))
X  		goto bad;
X+ #ifdef REMOTEFS
X+ 	remotechdir(-1);
X+ #endif REMOTEFS
X  	iunlock(ip);
X  	if (*ipp)
X  		irele(*ipp);
SHAREOF
chmod 664 remote/usr.sys.VAX4.2/sys/ufs_syscalls.c.diff
#
# remote/usr.sys.VAX4.2/sys/uipc_socket.c.diff
#
if [ -f remote/usr.sys.VAX4.2/sys/uipc_socket.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.2/sys/uipc_socket.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.2/sys/uipc_socket.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.2/sys/uipc_socket.c.diff
XThese changes Fix a bug in soreceive() that caused infinite loop if a
Xpacket was received while doing uiomove() and the MSG_PEEK flag was set.
XIf you have this fix, then patch will tell you:
X
X	Reversed (or previously applied) patch detected!
X
XIf it does, you should just reinstall your original uipc_socket.c.
XIf you have a different version of the fix or another modification that
Xaffects this code, then patch will tell you that "Hunk #1 failed"; you
Xmust install the patch by hand.
X
X***************
X*** 546,552
X  		error =
X  		    uiomove(mtod(m, caddr_t) + moff, (int)len, UIO_READ, uio);
X  		s = splnet();
X! 		if (len == m->m_len) {
X  			eor = (int)m->m_act;
X  			if (flags & MSG_PEEK)
X  				m = m->m_next;
X
X--- 550,556 -----
X  		error =
X  		    uiomove(mtod(m, caddr_t) + moff, (int)len, UIO_READ, uio);
X  		s = splnet();
X! 		if (moff+len == m->m_len) {
X  			eor = (int)m->m_act;
X  			if (flags & MSG_PEEK)
X  				m = m->m_next;
SHAREOF
chmod 664 remote/usr.sys.VAX4.2/sys/uipc_socket.c.diff
#
# remote/usr.sys.VAX4.3/conf/Makefile.vax.diff
#
if [ -f remote/usr.sys.VAX4.3/conf/Makefile.vax.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.3/conf/Makefile.vax.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.3/conf/Makefile.vax.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.3/conf/Makefile.vax.diff
XThis change teaches the Makefile how to make remote/rmt_data.c from
Xsys/init_sysent.c and remote/rmt_data_template.
X***************
X*** 145,150
X  param.o: param.c Makefile
X  	${CC} -c ${CFLAGS} ${PARAM} param.c
X  
X  %RULES
X  
X  # DO NOT DELETE THIS LINE -- make depend uses it
X
X--- 145,157 -----
X  param.o: param.c Makefile
X  	${CC} -c ${CFLAGS} ${PARAM} param.c
X  
X+ ../remote/rmt_data.c: ../remote/rmt_data_template ../remote/remotefs.h \
X+     ../sys/init_sysent.c
X+ 	cat ../remote/rmt_data_template > ../remote/nrmt_data.c
X+ 	/lib/cpp ${CFLAGS} ../sys/init_sysent.c | sh ../remote/remote_mkdata \
X+ 		../remote/remotefs.h >> ../remote/nrmt_data.c
X+ 	mv ../remote/nrmt_data.c ../remote/rmt_data.c
X+ 
X  %RULES
X  
X  # DO NOT DELETE THIS LINE -- make depend uses it
SHAREOF
chmod 664 remote/usr.sys.VAX4.3/conf/Makefile.vax.diff
#
# remote/usr.sys.VAX4.3/conf/makefile.vax.diff
#
if [ -f remote/usr.sys.VAX4.3/conf/makefile.vax.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.3/conf/makefile.vax.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.3/conf/makefile.vax.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.3/conf/makefile.vax.diff
XThis change teaches the Makefile how to make remote/rmt_data.c from
Xsys/init_sysent.c and remote/rmt_data_template.
X***************
X*** 145,150
X  param.o: param.c makefile
X  	${CC} -c ${CFLAGS} ${PARAM} param.c
X  
X  %RULES
X  
X  # DO NOT DELETE THIS LINE -- make depend uses it
X
X--- 145,157 -----
X  param.o: param.c Makefile
X  	${CC} -c ${CFLAGS} ${PARAM} param.c
X  
X+ ../remote/rmt_data.c: ../remote/rmt_data_template ../remote/remotefs.h \
X+     ../sys/init_sysent.c
X+ 	cat ../remote/rmt_data_template > ../remote/nrmt_data.c
X+ 	/lib/cpp ${CFLAGS} ../sys/init_sysent.c | sh ../remote/remote_mkdata \
X+ 		../remote/remotefs.h >> ../remote/nrmt_data.c
X+ 	mv ../remote/nrmt_data.c ../remote/rmt_data.c
X+ 
X  %RULES
X  
X  # DO NOT DELETE THIS LINE -- make depend uses it
SHAREOF
chmod 664 remote/usr.sys.VAX4.3/conf/makefile.vax.diff
#
# remote/usr.sys.VAX4.3/h/user.h.diff
#
if [ -f remote/usr.sys.VAX4.3/h/user.h.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.3/h/user.h.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.3/h/user.h.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.3/h/user.h.diff
XThese changes keep track of the per-process RFS information.
X***************
X*** 121,126
X  	} u_ncache;
X  	struct	nameidata u_nd;
X  
X  	int	u_stack[1];
X  };
X  
X
X--- 121,137 -----
X  	} u_ncache;
X  	struct	nameidata u_nd;
X  
X+ #ifdef REMOTEFS
X+ 	short	u_rmtoffset[2];		/* path offset for local segment */
X+ 	short	u_rmtcdir;		/* system # of remote current dir */
X+ 	long	u_rmtsys;		/* room for 32 systems */
X+ 					/* one bit for each remote system */
X+ #ifdef pyr /* Pyramid */
X+ 	int	*u.u_ap;
X+ #define		u_arg	u_ap
X+ #endif pyr
X+ #endif REMOTEFS
X+ 
X  	int	u_stack[1];
X  };
X  
SHAREOF
chmod 664 remote/usr.sys.VAX4.3/h/user.h.diff
#
# remote/usr.sys.VAX4.3/machine/trap.c.diff
#
if [ -f remote/usr.sys.VAX4.3/machine/trap.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.3/machine/trap.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.3/machine/trap.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.3/machine/trap.c.diff
XThese changes enable syscall() to start up a remote version of a system
Xcall if the normal system call fails with error == EISREMOTE.
X***************
X*** 23,28
X  #ifdef SYSCALLTRACE
X  #include "../sys/syscalls.c"
X  #endif
X  
X  #include "mtpr.h"
X  
X
X--- 23,35 -----
X  #ifdef SYSCALLTRACE
X  #include "../sys/syscalls.c"
X  #endif
X+ #ifdef REMOTEFS
X+ #include "../remote/remotefs.h"
X+ /*
X+  * needed only if EISREMOTE isn't in /usr/include/errno.h
X+  */
X+ #include "../h/errno.h"
X+ #endif REMOTEFS
X  
X  #include "mtpr.h"
X  
X***************
X*** 191,196
X  	register struct proc *p;
X  	int opc;
X  	struct timeval syst;
X  
X  	syst = u.u_ru.ru_stime;
X  	if (!USERMODE(locr0[PS]))
X
X--- 198,212 -----
X  	register struct proc *p;
X  	int opc;
X  	struct timeval syst;
X+ #ifdef REMOTEFS
X+ 	/*
X+ 	 * It is imperative that these declarations come after other register
X+ 	 * declarations, because the (standard) code below depends upon the
X+ 	 * order of allocation.
X+ 	 */
X+ 	extern u_char remote_sysmap[];
X+ 	register long rmt_syscall, runremote, rmt_called, rmt_cnt;
X+ #endif REMOTEFS
X  
X  	syst = u.u_ru.ru_stime;
X  	if (!USERMODE(locr0[PS]))
X***************
X*** 223,228
X  		if (u.u_error == 0 && u.u_eosys != RESTARTSYS)
X  			u.u_error = EINTR;
X  	} else {
X  		u.u_eosys = NORMALRETURN;
X  #ifdef SYSCALLTRACE
X  		if (syscalltrace) {
X
X--- 239,248 -----
X  		if (u.u_error == 0 && u.u_eosys != RESTARTSYS)
X  			u.u_error = EINTR;
X  	} else {
X+ #ifdef REMOTEFS
X+ 		rmt_syscall = remote_sysmap[ code ];
X+ 		rmt_called = FALSE;
X+ 		rmt_cnt = 0;
X  		u.u_eosys = NORMALRETURN;
X  		while (! rmt_called) {
X  			runremote = (rmt_syscall != RSYS_nosys
X***************
X*** 224,229
X  			u.u_error = EINTR;
X  	} else {
X  		u.u_eosys = NORMALRETURN;
X  #ifdef SYSCALLTRACE
X  		if (syscalltrace) {
X  			register int i;
X
X--- 244,265 -----
X  		rmt_called = FALSE;
X  		rmt_cnt = 0;
X  		u.u_eosys = NORMALRETURN;
X+ 		while (! rmt_called) {
X+ 			runremote = (rmt_syscall != RSYS_nosys
X+ 				    && u.u_procp->p_flag & SREMOTE);
X+ 			if (runremote)
X+ 				rmt_called = remote_startup(rmt_cnt,
X+ 					rmt_syscall);
X+ 			if (! rmt_called) {
X+ 				(*callp->sy_call)();
X+ 				if (u.u_error != EISREMOTE)
X+ 					rmt_called = TRUE;
X+ 				else
X+ 					rmt_cnt++;
X+ 			}
X+ 		}
X+ #else REMOTEFS
X+ 		u.u_eosys = NORMALRETURN;
X  #ifdef SYSCALLTRACE
X  		if (syscalltrace) {
X  			register int i;
X***************
X*** 244,249
X  		}
X  #endif
X  		(*(callp->sy_call))();
X  	}
X  	if (u.u_eosys == NORMALRETURN) {
X  		if (u.u_error) {
X
X--- 280,286 -----
X  		}
X  #endif
X  		(*(callp->sy_call))();
X+ #endif REMOTEFS
X  	}
X  	if (u.u_eosys == NORMALRETURN) {
X  		if (u.u_error) {
SHAREOF
chmod 664 remote/usr.sys.VAX4.3/machine/trap.c.diff
#
# remote/usr.sys.VAX4.3/sys/init_sysent.c.diff
#
if [ -f remote/usr.sys.VAX4.3/sys/init_sysent.c.diff ]; then 
	echo -n 'Hit <return> to overwrite remote/usr.sys.VAX4.3/sys/init_sysent.c.diff or ^C to quit' 
	read ans 
	rm -f remote/usr.sys.VAX4.3/sys/init_sysent.c.diff 
fi 
 
sed -e 's/^.//' << \SHAREOF > remote/usr.sys.VAX4.3/sys/init_sysent.c.diff
XThese two changes add in the new RFS systems calls, remoteon(), remoteoff()
Xand  remotename().  If the second hunk fails, then you have some system
Xcall numbers that are not in standard 4.2BSD.
X***************
X*** 95,100
X  #define	compat(n, name)	0, nosys
X  #endif
X  
X  /* BEGIN JUNK */
X  #ifdef vax
X  int	resuba();
X
X--- 95,108 -----
X  #define	compat(n, name)	0, nosys
X  #endif
X  
X+ #ifdef REMOTEFS
X+ /*
X+  * remote file sys stuff (toddb@du)
X+  */
X+ int	remoteon(),		/* remote file sys stuff */
X+ 	remoteoff(),
X+ 	remotename();
X+ #endif REMOTEFS
X  /* BEGIN JUNK */
X  #ifdef vax
X  int	resuba();
X***************
X*** 269,274
X  	2, setquota,			/* 148 = quota */
X  	4, qquota,			/* 149 = qquota */
X  	3, getsockname,			/* 150 = getsockname */
X  	0, nosys,			/* 151 = nosys */
X  	0, nosys,			/* 152 = nosys */
X  	0, nosys,			/* 153 = nosys */
X
X--- 277,287 -----
X  	2, setquota,			/* 148 = quota */
X  	4, qquota,			/* 149 = qquota */
X  	3, getsockname,			/* 150 = getsockname */
X+ #ifdef REMOTEFS
X+ 	4, remoteon,			/* 151 = remoteon */
X+ 	1, remoteoff,			/* 152 = remoteoff */
X+ 	4, remotename,			/* 153 = remotename */
X+ #else REMOTEFS
X  	0, nosys,			/* 151 = nosys */
X  	0, nosys,			/* 152 = nosys */
X  	0, nosys,			/* 153 = nosys */
X***************
X*** 272,277
X  	0, nosys,			/* 151 = nosys */
X  	0, nosys,			/* 152 = nosys */
X  	0, nosys,			/* 153 = nosys */
X  	0, nosys,			/* 154 = nosys */
X  };
X  int	nsysent = sizeof (sysent) / sizeof (sysent[0]);
X
X--- 285,291 -----
X  	0, nosys,			/* 151 = nosys */
X  	0, nosys,			/* 152 = nosys */
X  	0, nosys,			/* 153 = nosys */
X+ #endif REMOTEFS
X  	0, nosys,			/* 154 = nosys */
X  };
X  int	nsysent = sizeof (sysent) / sizeof (sysent[0]);
SHAREOF
chmod 664 remote/usr.sys.VAX4.3/sys/init_sysent.c.diff

