Subject:  v13i087:  Sun RPC, release 3.9, Part10/15
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Stephen X. Nahm <sxn@Sun.COM>
Posting-number: Volume 13, Issue 87
Archive-name: rpc3.9/part10

#! /bin/sh
# This is a shell archive. To extract, remove the header and type "sh filename"
#
echo x - man
echo creating directory man
mkdir man
cd man
echo x - man1
echo creating directory man1
mkdir man1
cd man1
echo x - rpcgen.1
sed -e 's/^X//' > rpcgen.1 <<'Funky_Stuff'
X.\" @(#)rpcgen.1	1.2 87/11/27 3.9 RPCSRC
X.TH RPCGEN 1 "3 November 1987"
X.SH NAME
rpcgen \- an RPC protocol compiler
X.SH SYNOPSIS
\fBrpcgen\fP \fIinfile\fP
X.br
\fBrpcgen\fP \fB-h\fP \fB[-o \fIoutfile\fP]\fP \fB[\fIinputfile\fP]\fP
X.br
\fBrpcgen\fP \fB-c\fP \fB[-o \fIoutfile\fP]\fP \fB[\fIinfile\fP]\fP
X.br
\fBrpcgen\fP \fB-s\fP \fItransport\fP \fB[-o\fP \fIoutfile\fP]\fP \fB[\fIinfile\fP]\fP
X.br
\fBrpcgen\fP \fB-l\fP \fB[-o\fP \fIoutfile\fP]\fP \fB[\fIinfile\fP]\fP
X.br
\fBrpcgen\fP \fB-m\fP \fB[-o\fP \fIoutfile\fP]\fP \fB[\fIinfile\fP]\fP
X.br
X.SH DESCRIPTION
X.IX "compilers" rpcgen "" "\fLrpcgen\fR \(em generate RPC protocols, C header files"
X.IX rpcgen "" "\fLrpcgen\fR \(em generate RPC protocol, C header files, and server skeleton"
X.IX RPC "generate protocols \(em \fLrpcgen\fR"
\fIrpcgen\fP is a tool that generates
X.B C
code to implement an
X.SM RPC
protocol.  The input to \fIrpcgen\fP is a language similar
X.B C 
known as RPC Language (Remote Procedure Call Language).  Information
about the syntax of RPC Language is available in the \fI`rpcgen' 
Programming Guide\fP.
X.LP
X.I rpcgen 
is normally used as in the first synopsis where it takes an input file
and generates four output files. If the \fIinfile\fP is named \fIproto.x\fP,
then \fIrpcgen\fP will generate a header file in \fIproto.h\fP, XDR
routines in \fIproto_xdr.c\fP, server-side stubs in \fIproto_svc.c\fP
and client-side stubs if \fIproto_clnt.c\fP.  
X.LP
The other synopses shown above are used when one does not want to 
generate all the output files, but only a particular one.  Their
usage is described in the \fBUSAGE\fP section below.
X.LP
The C-preprocessor, \fIcpp(1)\fP, is run on all input files before they are
actually
interpreted by \fIrpcgen\fP, so all the cpp directives are legal within
an \fIrpcgen\fP input file.  For each type of output file, \fIrpcgen\fP defines
a special cpp symbol for use by the \fIrpcgen\fP programmer:
X.PP
X.PD 0
X.TP
X.SM RPC_HDR
defined when compiling into header files
X.TP
X.SM RPC_XDR
defined when compiling into XDR routines
X.TP
X.SM RPC_SVC
defined when compiling into server-side stubs
X.TP
X.SM RPC_CLNT
defined when compiling into client-side stubs
X.PD
X.PP
In addition, \fIrpcgen\fP does a little preprocessing of its own. Any line
beginning with `%' is passed directly into the output file, uninterpreted
by \fIrpcgen\fP.  
X.LP
You can customize some of your XDR routines by leaving those data
types undefined.  For every data type that is undefined, \fIrpcgen\fP 
will assume that there exists a routine with the name `xdr_' prepended
to the name of the undefined type. 
X.SH OPTIONS
X.IP \fB-c\fP
Compile into XDR routines.
X.IP \fB-h\fP
Compile into
X.B C 
data-definitions (a header file)
X.IP "\fB-l\fP
Compile into a client-side stubs.
X.IP "\fB-s\fP \fItransport\fP"
Compile into server-side stubs, using the the given transport.  The
supported transports
are \fBudp\fP and \fBtcp\fP. This option may be invoked more than once
so as to compile a server that serves multiple transports.
X.IP "\fB-m\fP
Compile into a server-side stubs, but do not produce a \fImain()\fP routine.
This option is useful if you want to supply your own \fImain()\fP.
X.IP "\fB-o\fP \fIoutfile\fP"
Specify the name of the output file.  If none is specified, standard
output is used (\fB-c\fP, \fB-h\fP, \fB-l\fP and \fB-s\fP modes only).
X.SH "SEE ALSO"
\fI`rpcgen' Programming Guide\fP
X.SH BUGS
Nesting is not supported. As a work-around, structures can be declared at
top-level, and their name used inside other structures in order to achieve 
the same effect.
X.LP
Name clashes can occur when using program definitions, since the apparent
scoping does not really apply. Most of these can be avoided by giving 
unique names for programs, versions, procedures and types.

Funky_Stuff
len=`wc -c < rpcgen.1`
if [ $len !=     3769 ] ; then
  echo error: rpcgen.1 was $len bytes long, should have been     3769
fi
cd ..
echo done with directory man1
echo x - man3
echo creating directory man3
mkdir man3
cd man3
echo x - bindresvport.3n
sed -e 's/^X//' > bindresvport.3n <<'Funky_Stuff'
X.\" @(#)bindresvport.3n	1.2 87/11/13 3.9 RPCSRC
X.\" @(#)bindresvport.3n 1.2 87/10/06 SMI;
X.TH BINDRESVPORT 3N  "6 October 1987"
X.SH NAME
bindresvport \- bind a socket to a privileged IP port
X.SH SYNOPSIS
X.nf
X.B #include <sys/types.h>
X.B #include <netinet/in.h>
X.LP
X.B bindresvport(sd, sin)
X.B	int sd;
X.B	struct sockaddr_in *sin;
X.fi
X.SH DESCRIPTION
X.B bindresvport
is used to bind a socket descriptor to a privileged
X.SM IP
port, that is, a
port number in the range 0-1023.
The routine returns 0 if it is successful,
otherwise \-1 is returned and
X.I errno
set to reflect the cause of the error.
X.LP
Only root can bind to a privileged port; this call will fail for any
other users.
Funky_Stuff
len=`wc -c < bindresvport.3n`
if [ $len !=      681 ] ; then
  echo error: bindresvport.3n was $len bytes long, should have been      681
fi
echo x - getrpcent.3n
sed -e 's/^X//' > getrpcent.3n <<'Funky_Stuff'
X.\" @(#)getrpcent.3n	1.2 87/11/13 3.9 RPCSRC
X.\" @(#)getrpcent.3n 1.6 87/10/06 SMI;
X.TH GETRPCENT 3N "6 October 1987"
X.SH NAME
getrpcent, getrpcbyname, getrpcbynumber \- get RPC entry
X.SH SYNOPSIS
X.nf
X.ft B
#include <netdb.h>
X.LP
X.ft B
struct rpcent *getrpcent(\|)
X.LP
X.ft B
struct rpcent *getrpcbyname(name)
char *name;
X.LP
X.ft B
struct rpcent *getrpcbynumber(number)
int number;
X.LP
X.ft B
setrpcent (stayopen)
int stayopen
X.LP
X.ft B
endrpcent (\|)
X.fi
X.IX  get "RPC program entry \(em \fLgetrpcent\fR"
X.IX  set "RPC program entry \(em \fLsetrpcent\fR"
X.IX  "RPC program entry, get \(em \fLgetrpcent\fR"
X.IX  "getrpcent function"  ""  "\fLgetrpcent\fP \(em get RPC entry"
X.IX  "getrpcbynumber function"  ""  "\fLgetrpcbynumber\fP \(em get RPC entry"
X.IX  "getrpcbyname function"  ""  "\fLgetrpcbyname\fP \(em get RPC entry"
X.IX  "setrpcent function"  ""  "\fLsetrpcent\fP \(em get RPC entry"
X.IX  "endrpcent function"  ""  "\fLendrpcent\fP \(em get RPC entry"
X.SH DESCRIPTION
X.BR getrpcent ,
X.BR getrpcbyname ,
and
X.B getrpcbynumber
each return a pointer to an object with the
following structure
containing the broken-out
fields of a line in the rpc program number data base,
X.BR /etc/rpc .
X.RS
X.LP
X.nf
X.ft B
struct	rpcent {
	char	*r_name;	/* name of server for this rpc program */
	char	**r_aliases;	/* alias list */
	long	r_number;	/* rpc program number */
};
X.ft R
X.fi
X.RE
X.LP
The members of this structure are:
X.RS
X.PD 0
X.TP 20
X.B r_name
The name of the server for this rpc program.
X.TP 20
X.B r_aliases
A zero terminated list of alternate names for the rpc program.
X.TP  20
X.B r_number
The rpc program number for this service.
X.PD
X.RE
X.LP
X.B getrpcent
reads the next line of the file, opening the file if necessary.
X.LP
X.B getrpcent
opens and rewinds the file.  If the
X.I stayopen
flag is non-zero,
the net data base will not be closed after each call to
X.B getrpcent
(either directly, or indirectly through one of
the other \*(lqgetrpc\*(rq calls).
X.LP
X.B endrpcent
closes the file.
X.LP
X.B getrpcbyname
and
X.B getrpcbynumber
sequentially search from the beginning
of the file until a matching rpc program name or
program number is found, or until
X.SM EOF
is encountered.
X.SH FILES
X.PD 0
X.TP 20
X.B /etc/rpc
X.PD
X.SH "SEE ALSO"
X.BR rpc (5),
X.BR rpcinfo (8),
X.SH DIAGNOSTICS
Null pointer
X.BR  (0) 
returned on EOF or error.
X.SH BUGS
All information
is contained in a static area
so it must be copied if it is
to be saved.
Funky_Stuff
len=`wc -c < getrpcent.3n`
if [ $len !=     2425 ] ; then
  echo error: getrpcent.3n was $len bytes long, should have been     2425
fi
echo x - getrpcport.3r
sed -e 's/^X//' > getrpcport.3r <<'Funky_Stuff'
X.\" @(#)getrpcport.3r	1.2 87/11/13 3.9 RPCSRC
X.\" @(#)getrpcport.3r 1.9 87/10/06 SMI;
X.TH GETRPCPORT 3R "6 October 1987"
X.SH NAME
getrpcport \- get RPC port number
X.SH SYNOPSIS
X.ft B
X.nf
int getrpcport(host, prognum, versnum, proto)
	char *host;
	int prognum, versnum, proto;
X.fi
X.SH DESCRIPTION
X.IX getrpcport "" "\fLgetrpcport\fR \(em get RPC port number"
X.B getrpcport
returns the port number for version
X.I versnum
of the RPC program
X.I prognum
running on
X.I host
and using protocol
X.IR proto .
It returns 0 if it cannot contact the portmapper, or if
X.I prognum
is not registered.  If
X.I prognum
is registered but not with version
X.IR versnum ,
it will still return a port number (for some version of the program)
indicating that the program is indeed registered.
The version mismatch will be detected upon the first call to the service.
Funky_Stuff
len=`wc -c < getrpcport.3r`
if [ $len !=      842 ] ; then
  echo error: getrpcport.3r was $len bytes long, should have been      842
fi
echo x - rpc.3n
sed -e 's/^X//' > rpc.3n <<'Funky_Stuff'
X.\" @(#)rpc.3n	1.2 87/11/24 3.9 RPCSRC
X.TH RPC 3N "3 November 1987"
X.SH NAME
rpc \- library routines for remote procedure calls
X.IX rpc "" "RPC routines"
X.IX "remote procedure calls"
X.IX rpc "" "RPC routines"
X.IX "remote procedure calls"
X.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
X.LP
X.ft B
X.nf
X.sp .5
#include <rpc/rpc.h>
X.fi
X.ft R
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
X.fi
X.ft R
X.IP
A macro that destroys the authentication information associated with
X.BR auth .
Destruction usually involves deallocation of private data
structures. The use of
X.B auth
is undefined after calling
X.BR auth_destroy .
X.br
X.if t .ne 6
X.LP
X.ft B
X.nf
X.sp .5
\s-1AUTH\s0 *
authnone_create()
X.fi
X.ft R
X.IP
Creates and returns an
X.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
X.SM RPC.
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
X.fi
X.ft R
X.IP
Creates and returns an
X.SM RPC
authentication handle that contains
X.UX
authentication information.
The parameter
X.B host
is the name of the machine on which the information was
created;
X.B uid
is the user's user
X.SM ID ;
X.B gid
is the user's current group
X.SM ID ;
X.B len
and
X.B aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
X.br
X.if t .ne 5
X.LP
X.ft B
X.nf
X.sp .5
\s-1AUTH\s0 *
authunix_create_default()
X.fi
X.ft R
X.IP
Calls
X.B authunix_create
with the appropriate parameters.
X.br
X.if t .ne 13
X.LP
X.ft B
X.nf
X.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
X.fi
X.ft R
X.IP
Calls the remote procedure associated with
X.BR prognum ,
X.BR versnum ,
and
X.B procnum
on the machine,
X.BR host .
The parameter
X.B in
is the address of the procedure's argument(s), and
X.B out
is the address of where to place the result(s);
X.B inproc
is used to encode the procedure's parameters, and
X.B outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
X.B "enum clnt_stat"
cast to an integer if it fails.
The routine
X.B clnt_perrno
is handy for translating failure statuses into messages.
X.IP
Warning: calling remote procedures with this routine
uses
X.SM UDP/IP
as a transport; see
X.B clntudp_create
for restrictions.
You do not have control of timeouts or authentication using
this routine.
X.br
X.if t .ne 16
X.LP
X.ft B
X.nf
X.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
X.fi
X.ft R
X.IP
Like
X.BR callrpc ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
X.BR eachresult ,
whose form is:
X.RS 1i
X.ft B
X.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
X.ft R
X.fi
X.RE
X.IP
where
X.B out
is the same as
X.B out
passed to 
X.BR clnt_broadcast ,
except that the remote procedure's output is decoded there;
X.B addr
points to the address of the machine that sent the results.
If
X.B eachresult
returns zero,
X.B clnt_broadcast
waits for more replies; otherwise it returns with appropriate
status.
X.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
X.br
X.if t .ne 13
X.LP
X.ft B
X.nf
X.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt; u_long procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
X.fi
X.ft R
X.IP
A macro that calls the remote procedure
X.B procnum
associated with the client handle,
X.BR clnt ,
which is obtained with an
X.SM RPC
client creation routine such as
X.BR clnt_create .
The parameter
X.B in
is the address of the procedure's argument(s), and
X.B out
is the address of where to place the result(s);
X.B inproc
is used to encode the procedure's parameters, and
X.B outproc
is used to decode the procedure's results;
X.B tout
is the time allowed for results to come back.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
X.fi
X.ft R
X.IP
A macro that destroys the client's
X.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
X.B clnt
itself.  Use of
X.B clnt
is undefined after calling
X.BR clnt_destroy .
If the
X.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
\s-1CLIENT\s0 *
clnt_create (host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
X.fi
X.ft R
X.IP
Generic client creation routine.
X.B host
identifies the name of the remote host where the server
is located.
X.B proto
indicates which kind of transport protocol to use. The
currently supported values for this field are ``udp''
and ``tcp''.
Default timeouts are set, but can be modified using
X.B clnt_control.
X.IP
Warning: Using
X.SM UDP
has its shortcomings.  Since
X.SM UDP\s0-based
X.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
X.fi
X.ft R
X.IP
A macro used to change or retrieve various information
about a client object.
X.B req
indicates the type of operation, and
X.B info
is a pointer to the information. For both
X.SM UDP
and
X.SM TCP,
the supported values of
X.B req
and their argument types and what they do are:
X.nf
X.ta +2.0i +2.0i +2.0i
X.SM CLSET_TIMEOUT	struct timeval	set total timeout
X.SM CLGET_TIMEOUT	struct timeval	get total timeout
X.fi
X.IP
Note: if you set the timeout using
X.BR clnt_control ,
the timeout parameter passed to
X.B clnt_call
will be ignored in all future calls.
X.nf
X.SM CLGET_SERVER_ADDR	struct sockaddr	get server's address
X.fi
X.br
The following operations are valid for
X.SM UDP
only:
X.nf
X.ta +2.0i ; +2.0i ; +2.0i
X.SM CLSET_RETRY_TIMEOUT		struct timeval	set the retry timeout
X.SM CLGET_RETRY_TIMEOUT		struct timeval	get the retry timeout
X.fi
X.br
The retry timeout is the time that
X.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
X.fi
X.ft R
X.IP
A macro that frees any data allocated by the
X.SM RPC/XDR
system when it decoded the results of an
X.SM RPC
call.  The
parameter
X.B out   
is the address of the results, and
X.B outproc
is the
X.SM XDR
routine describing the results in simple primitives.
This routine returns one if the results were successfully
freed,
and zero otherwise.
X.br
X.if t .ne 6
X.LP
X.ft B
X.nf
X.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
X.fi
X.ft R
X.IP
A macro that copies the error structure out of the client
handle
to the structure at address
X.BR errp .
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
void
clnt_pcreateerror(s)
char *s;
X.fi
X.ft R
X.IP
Prints a message to standard error indicating
why a client
X.SM RPC
handle could not be created.
The message is prepended with string
X.B s
and a colon.
Used when a
X.BR clnt_create ,
X.BR clntraw_create ,
X.BR clnttcp_create ,
or
X.B clntudp_create
call fails.
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
X.fi
X.ft R
X.IP
Prints a message to standard error corresponding
to the condition indicated by
X.BR stat .
Used after
X.BR callrpc .
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
X.fi
X.ft R
X.IP
Prints a message to standard error indicating why an
X.SM RPC
call failed;
X.B clnt
is the handle used to do the call.
The message is prepended with string
X.B s
and a colon.
Used after
X.BR clnt_call .
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
char *
clnt_spcreateerror
char *s;
X.fi
X.ft R
X.IP
Like
X.BR clnt_pcreateerror ,
except that it returns a string
instead of printing to the standard error.
X.IP
Bugs: returns pointer to static data that is overwritten
on each call.
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
X.fi
X.ft R
X.IP
Takes the same arguments as
X.BR clnt_perrno ,
but instread of sending a message to the standard error
indicating why an
X.SM RPC
call failed, it returns a pointer to a string which contains
the
message.  The string ends with a newline.
X.IP
X.B clnt_sperrno
is used instead of
X.B clnt_perrno
if the program doesn't have a standard error (as a program
running as a server quite likely doesn't), or if the
programmer
doesn't want the message to be output with
X.BR printf ,
or if a message format different than that supported by
X.B clnt_perrno   
is to be used.
Note: unlike
X.B clnt_sperror
and
X.BR clnt_spcreaterror ,
X.B clnt_sperrno
does not return pointer to static data so the
result will not get overwritten on each call.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
X.fi
X.ft R
X.IP
Like
X.BR clnt_perror ,
except that (like
X.BR clnt_sperrno )
it returns a string instead of printing to standard error.
X.IP
Bugs: returns pointer to static data that is overwritten
on each call.
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
X.fi
X.ft R
X.IP
This routine creates a toy
X.SM RPC
client for the remote program
X.BR prognum ,
version
X.BR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
X.SM RPC
server should live in the same address space; see
X.BR svcraw_create .
This allows simulation of
X.SM RPC
and acquisition of
X.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
X.SM NULL
if it fails.
X.br
X.if t .ne 15
X.LP
X.ft B
X.nf
X.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
X.fi
X.ft R
X.IP
This routine creates an
X.SM RPC
client for the remote program
X.BR prognum ,
version
X.BR versnum ;
the client uses
X.SM TCP/IP
as a transport. The remote program is located at Internet
address
X.BR *addr .
If
X.B addr->sin_port
is zero, then it is set to the actual port that the remote
program is listening on (the remote
X.B portmap
service is consulted for this information). The parameter
X.B sockp 
is a socket; if it is
X.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
X.BR sockp .
Since
X.SM TCP\s0-based
X.SM RPC
uses buffered
X.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
X.B sendsz
and
X.BR recvsz ;
values of zero choose suitable defaults.
This routine returns
X.SM NULL
if it fails.
X.br
X.if t .ne 15
X.LP
X.ft B
X.nf
X.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, pronum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
X.fi
X.ft R
X.IP
This routine creates an
X.SM RPC
client for the remote program
X.BR prognum ,
version
X.BR versnum ;
the client uses use
X.SM UDP/IP
as a transport. The remote program is located at Internet
address
X.BR addr .
If
X.B addr->sin_port
is zero, then it is set to actual port that the remote
program is listening on (the remote
X.B portmap
service is consulted for this information). The parameter
X.B sockp 
is a socket; if it is
X.B
X.SM RPC_ANYSOCK
, then this routine opens a new one and sets
X.BR sockp .
The
X.SM UDP
transport resends the call message in intervals of
X.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
X.BR clnt_call .
X.IP
Warning: since
X.SM UDP\s0-based
X.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
X.fi
X.ft R
X.IP
Stuffs the machine's
X.SM IP  
address into
X.BR *addr ,
without consulting the library routines that deal with
X.br
X.BR /etc/hosts .
The port number is always set to
X.BR htons (
X.SM PMAPPORT
).
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
X.fi
X.ft R
X.IP
A user interface to the
X.B portmap
service, which returns a list of the current
X.SM RPC
program-to-port mappings
on the host located at
X.SM IP
address
X.BR *addr .
This routine can return
X.SM NULL .
The command
X.B "rpcinfo -p"
uses this routine.
X.br
X.if t .ne 12
X.LP
X.ft B
X.nf
X.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
X.fi
X.ft R
X.IP
A user interface to the
X.B portmap
service, which returns the port number
on which waits a service that supports program number
X.BR prognum ,
version
X.BR versnum ,
and speaks the transport protocol associated with
X.BR protocol .
The value of
X.B protocol
is most likely
X.B
X.SM IPPROTO_UDP
or 
X.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
X.SM RPC
system failured to contact the remote
X.B portmap
service.  In the latter case, the global variable
X.B rpc_createerr
contains the
X.SM RPC
status.
X.br
X.if t .ne 15
X.LP
X.ft B
X.nf
X.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
X.fi
X.ft R
X.IP
A user interface to the
X.B portmap
service, which instructs
X.B portmap
on the host at
X.SM IP
address
X.B *addr
to make an RPC call on your behalf to a procedure on that
host.
The parameter
X.B *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
X.B callrpc
and
X.BR clnt_call .
This procedure should be used for a ``ping'' and nothing
else.
See also
X.BR clnt_broadcast .
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
X.fi
X.ft R
X.IP
A user interface to the
X.B portmap
service, which establishes a mapping between the triple
X.RB [ prognum,versnum,protocol ]
and
X.B port
on the machine's
X.B portmap
service. The value of
X.B protocol
is most likely
X.B
X.SM IPPROTO_UDP
or 
X.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
X.BR svc_register .
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
X.fi
X.ft R
X.IP
A user interface to the
X.B portmap
service, which destroys all mapping between the triple
X.RB [ "prognum, versnum, *" ]
and 
X.B ports
on the machine's
X.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
X.br
X.if t .ne 15
X.LP
X.ft B
X.nf
X.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) () ;
xdrproc_t inproc, outproc;
X.fi
X.ft R
X.IP
Registers procedure
X.B procname
with the
X.SM RPC
service package.  If a request arrives for program
X.BR prognum ,
version
X.BR versnum ,
and procedure
X.BR procnum ,
X.B procname
is called with a pointer to its parameter(s);
X.B progname
should return a pointer to its static result(s);
X.B inproc
is used to decode the parameters while
X.B outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
X.IP
Warning: remote procedures registered in this form
are accessed using the
X.SM UDP/IP
transport; see
X.B svcudp_create
for restrictions.
X.br
X.if t .ne 5
X.LP
X.ft B
X.nf
X.sp .5
struct rpc_createerr     rpc_createerr;
X.fi
X.ft R
X.IP
A global variable whose value is set by any
X.SM RPC
client creation routine
that does not succeed.  Use the routine
X.B clnt_pcreateerror
to print the reason why.
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 * xprt;
X.fi
X.ft R
X.IP
A macro that destroys the
X.SM RPC
service transport handle,
X.BR xprt .
Destruction usually involves deallocation
of private data structures, including
X.B xprt
itself.  Use of
X.B xprt
is undefined after calling this routine.
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
fd_set svc_fdset;
X.fi
X.ft R
X.IP
A global variable reflecting the
X.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
X.B select
system call. This is only of interest
if a service implementor does not call
X.BR svc_run ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
X.BR select !),
yet it may change after calls to
X.B svc_getreqset
or any creation routines.
X.br
X.if t .ne 6
X.LP
X.ft B
X.nf
X.sp .5
int svc_fds;
X.fi
X.ft R
X.IP
Similar to
X.BR svc_fedset ,
but limited to 32 descriptors. This
interface is obsoleted by
X.BR svc_fdset .
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
X.fi
X.ft R
X.IP
A macro that frees any data allocated by the
X.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
X.BR svc_getargs .
This routine returns one if the results were successfully
freed,
and zero otherwise.
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
X.fi
X.ft R
X.IP
A macro that decodes the arguments of an
X.SM RPC
request
associated with the
X.SM RPC
service transport handle,
X.B xprt .
The parameter
X.B in
is the address where the arguments will be placed;
X.B inproc
is the
X.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
struct sockaddr_in
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
X.fi
X.ft R
X.IP
The approved way of getting the network address of the caller
of a procedure associated with the
X.SM RPC
service transport handle,
X.BR xprt .
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
X.fi
X.ft R
X.IP
This routine is only of interest if a service implementor
does not call
X.BR svc_run ,
but instead implements custom asynchronous event processing.
It is called when the
X.B select
system call has determined that an
X.SM RPC
request has arrived on some
X.SM RPC
socket(s);
X.B rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
X.B rdfds
have been serviced.
X.br
X.if t .ne 6
X.LP
X.ft B
X.nf
X.sp .5
svc_getreq(rdfds)
int rdfds;
X.fi
X.ft R
X.IP
Similar to 
X.BR svc_getreqset ,
but limited to 32 descriptors. This interface is obsoleted by
X.BR svc_getreqset .
X.br
X.if t .ne 17
X.LP
X.ft B
X.nf
X.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) ();
u_long protocol;
X.fi
X.ft R
X.IP
Associates
X.B prognum
and
X.B versnum
with the service dispatch procedure,
X.BR dispatch .
If
X.B protocol
is zero, the service is not registered with the
X.B portmap
service.  If
X.B protocol
is non-zero, then a mapping of the triple
X.RB [ "prognum, versnum, protocol" ]
to
X.B xprt->xp_port
is established with the local
X.B portmap
service (generally
X.B protocol
is zero,
X.B
X.SM IPPROTO_UDP
or 
X.B
X.SM IPPROTO_TCP
).
The procedure
X.B dispatch
has the following form:
X.RS 1i
X.ft B
X.nf 
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
X.ft R
X.fi
X.RE
X.IP
The
X.B svc_register
routine returns one if it succeeds, and zero otherwise.
X.br
X.if t .ne 6
X.LP
X.ft B
X.nf
X.sp .5
svc_run()
X.fi
X.ft R
X.IP
This routine never returns. It waits for 
X.SM RPC 
requests to arrive, and calls the appropriate service
procedure using
X.B svc_getreq
when one arrives. This procedure is usually waiting for a
X.B select
system call to return.
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
X.fi
X.ft R
X.IP
Called by an
X.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
X.B xprt  
is the request's associated transport handle;
X.B outproc
is the
X.SM XDR
routine which is used to encode the results; and
X.B out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
X.fi
X.ft R
X.IP
Removes all mapping of the double
X.RB [ "prognum, versnum" ]
to dispatch routines, and of the triple
X.RB [ "prognum, versnum, *" ]
to port number.
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
X.fi
X.ft R
X.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
X.fi
X.ft R
X.IP
Called by a service dispatch routine that can't successfully
decode its parameters. See also
X.BR svc_getargs .
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
X.fi
X.ft R
X.IP
Called by a service dispatch routine that doesn't implement
the procedure number that the caller requests.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
X.fi
X.ft R
X.IP
Called when the desired program is not registered with the
X.SM RPC 
package. Service implementors usually don't need this routine.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
X.fi
X.ft R
X.IP
Called when the desired version of a program is not registered 
with the
X.SM RPC
package. Service implementors usually don't need this routine.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
X.fi
X.ft R
X.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
X.fi
X.ft R
X.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient (but correct)
authentication parameters.  The routine calls
X.B "svcerr_auth(xprt, "
X.B
X.SM AUTH_TOOWEAK
) .
X.br
X.if t .ne 11
X.LP
X.ft B
X.nf
X.sp .5
\s-1SVCXPRT\s0 *
svcraw_create()
X.fi
X.ft R
X.IP
This routine creates a toy
X.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space, 
so the corresponding 
X.SM RPC 
client should live in the same 
address space; 
see 
X.BR clntraw_create . 
This routine allows simulation of 
X.SM RPC 
and acquisition of 
X.SM RPC 
overheads (such as round trip times), without any kernel 
interference. 
This routine returns 
X.SM NULL 
if it fails. 
X.br
X.if t .ne 11
X.LP
X.ft B
X.nf
X.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
X.fi
X.ft R
X.IP
This routine creates a
X.SM TCP/IP\s0-based
X.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
X.BR sock ,
which may be
X.B
X.SM RPC_ANYSOCK ,
in which case a new socket is created.
If the socket is not bound to a local
X.SM TCP
port, then this routine binds it to an arbitrary port. Upon
completion,
X.B xprt->xp_sock
is the transport's socket number, and
X.B xprt->xp_port
is the transport's port number.
This routine returns
X.SM NULL
if it fails. Since
X.SM TCP\s0-based
X.SM RPC
uses buffered
X.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
X.br
X.if t .ne 11
X.LP
X.ft B
X.nf
X.sp .5
void
svcfd_create(fd, sensize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
X.fi
X.ft R
X.IP
Creates a service on top of any open desciptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
X.SM TCP .
X.B sendsize
and
X.B recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
\s-1SVCXPRT\s0 *
svcudp_create(sock)
int sock;
X.fi
X.ft R
X.IP
This routine creates a
X.SM UDP/IP\s0-based
X.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
X.BR sock ,
which may be
X.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
X.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
X.B xprt->xp_sock
is the transport's socket number, and
X.B xprt->xp_port
is the transport's port number.
This routine returns
X.SM NULL
if it fails.
X.IP
Warning: since
X.SM UDP\s0-based
X.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
X.fi
X.ft R
X.IP
Used for describing
X.SM RPC
messages, externally. This routine is useful for users who
wish
to generate
\s-1RPC\s0-style
messages without using the
X.SM RPC
package.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
X.fi
X.ft R
X.IP
Used for describing
X.SM UNIX
credentials, externally. This routine is useful for users
who wish to generate these credentials without using the
X.SM RPC
authentication package.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
X.fi
X.ft R
X.IP
Used for describing
X.SM RPC
messages, externally.
This routine is useful for users who wish to generate
X.SM RPC\s0-style
messages without using the
X.SM RPC
package.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
X.fi
X.ft R
X.IP
Used for describing
X.SM RPC
messages, externally.
This routine is useful for users who wish to generate
X.SM RPC\s0-style
messages without using the
X.SM RPC
package.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
X.fi
X.ft R
X.IP
Used for describing
X.SM RPC
messages, externally.
This routine is useful for users who wish to generate
X.SM RPC\s0-style
messages without using the
X.SM RPC
package.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
X.fi
X.ft R
X.IP
Used for describing parameters to various
X.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
X.B pmap
interface.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
X.fi
X.ft R
X.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
X.B pmap
interface.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
X.fi
X.ft R
X.IP
Used for describing
X.SM RPC
messages, externally.
This routine is useful for users who wish to generate
X.SM RPC\s0-style
messages without using the
X.SM RPC
package.
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
X.fi
X.ft R
X.IP
Used for describing
X.SM RPC
messages, externally.
This routine is useful for users who wish to generate
X.SM RPC
style messages without using the
X.SM RPC
package.
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
X.fi
X.ft R
X.IP
After
X.SM RPC
service transport handles are created,
they should register themselves with the
X.SM RPC
service package.
This routine modifies the global variable
X.BR svc_fds .
Service implementors usually don't need this routine.
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
X.fi
X.ft R
X.IP
Before an
X.SM RPC
service transport handle is destroyed,
it should unregister itself with the
X.SM RPC
service package.
This routine modifies the global variable
X.BR svc_fds .
Service implementors usually don't need this routine.
X.SH SEE ALSO
X.BR \s-1XDR\s0 (3N)
X.br
The following manuals:
X.RS
X.ft I
Remote Procedure Calls: Protocol Specification
X.br
Remote Procedure Call Programming Guide
X.br
rpcgen Programming Guide
X.br
X.ft R
X.RE

Funky_Stuff
len=`wc -c < rpc.3n`
if [ $len !=    28619 ] ; then
  echo error: rpc.3n was $len bytes long, should have been    28619
fi
echo x - xdr.3n
sed -e 's/^X//' > xdr.3n <<'Funky_Stuff'
X.\" @(#)xdr.3n	1.1 87/11/04 3.9 RPCSRC
X.TH XDR 3N "3 November 1987"
X.SH NAME
xdr \- library routines for external data representation
X.SH SYNOPSIS AND DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
X.LP
X.ft B
X.nf
X.sp .5
xdr_array(xdrs, arrp, sizep, maxsize, elsize, elproc)
\s-1XDR\s0 *xdrs;
char **arrp;
u_int *sizep, maxsize, elsize;
xdrproc_t elproc;
X.fi
X.ft R
X.IP
A filter primitive that translates between variable-length
arrays
and their corresponding external representations. The
parameter
X.B arrp
is the address of the pointer to the array, while
X.B sizep
is the address of the element count of the array;
this element count cannot exceed
X.BR maxsize .
The parameter
X.B elsize
is the
X.B sizeof
each of the array's elements, and
X.B elproc
is an
X.SM XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
xdr_bool(xdrs, bp)
\s-1XDR\s0 *xdrs;
bool_t *bp;
X.fi
X.ft R
X.IP
A filter primitive that translates between booleans (C
integers)
and their external representations. When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
xdr_bytes(xdrs, sp, sizep, maxsize)
\s-1XDR\s0 *xdrs;
char **sp;
u_int *sizep, maxsize;
X.fi
X.ft R
X.IP
A filter primitive that translates between counted byte
strings and their external representations.
The parameter
X.B sp
is the address of the string pointer. The length of the
string is located at address
X.BR sizep ;
strings cannot be longer than
X.BR maxsize .
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_char(xdrs, cp)
\s-1XDR\s0 *xdrs;
char *cp;
X.fi
X.ft R
X.IP
A filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes
each. For arrays of characters, it is worthwhile to
consider
X.BR xdr_bytes ,
X.BR xdr_opaque or
X.BR xdr_string .
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
void
xdr_destroy(xdrs)
\s-1XDR\s0 *xdrs;
X.fi
X.ft R
X.IP
A macro that invokes the destroy routine associated with the
X.SM XDR
stream,
X.BR xdrs .
Destruction usually involves freeing private data structures
associated with the stream.  Using
X.B xdrs
after invoking
X.B xdr_destroy
is undefined.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_double(xdrs, dp)
\s-1XDR\s0 *xdrs;
double *dp;
X.fi
X.ft R
X.IP
A filter primitive that translates between C
X.B double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_enum(xdrs, ep)
\s-1XDR\s0 *xdrs;
enum_t *ep;
X.fi
X.ft R
X.IP
A filter primitive that translates between C
X.BR enum s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
xdr_float(xdrs, fp)
\s-1XDR\s0 *xdrs;
float *fp;
X.fi
X.ft R
X.IP
A filter primitive that translates between C
X.BR float s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
void
xdr_free(proc, objp)
xdrproc_t proc;
char *objp;
X.fi
X.ft R
X.IP
Generic freeing routine. The first argument is the
X.SM XDR
routine for the object being freed. The second argument
is a pointer to the object itself. Note: the pointer passed
to this routine is
X.I not
freed, but what it points to
X.I is
freed (recursively).
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
u_int
xdr_getpos(xdrs)
\s-1XDR\s0 *xdrs;
X.fi
X.ft R
X.IP
A macro that invokes the get-position routine
associated with the
X.SM XDR
stream,
X.BR xdrs .
The routine returns an unsigned integer,
which indicates the position of the
X.SM XDR
byte stream.
A desirable feature of
X.SM XDR
streams
is that simple arithmetic works with this number,
although the
X.SM XDR
stream instances need not guarantee this.
X.br
X.if t .ne 4
X.LP
X.ft B
X.nf
X.sp .5
X.br
long *
xdr_inline(xdrs, len)
\s-1XDR\s0 *xdrs;
int len;
X.fi
X.ft R
X.IP
A macro that invokes the in-line routine associated with the
X.SM XDR
stream,
X.BR xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
X.B len
is the byte length of the desired buffer.
Note that pointer is cast to
X.BR "long *" .
X.IP
Warning:
X.B xdr_inline
may return
X.SM NULL
(0) if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_int(xdrs, ip)
\s-1XDR\s0 *xdrs;
int *ip;
X.fi
X.ft R
X.IP
A filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_long(xdrs, lp)
\s-1XDR\s0 *xdrs;
long *lp;
X.fi
X.ft R
X.IP
A filter primitive that translates between C
X.B long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 12
X.LP
X.ft B
X.nf
X.sp .5
void
xdrmem_create(xdrs, addr, size, op)
\s-1XDR\s0 *xdrs;
char *addr;
u_int size;
enum xdr_op op;
X.fi
X.ft R
X.IP
This routine initializes the
X.SM XDR
stream object pointed to by
X.BR xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
X.B addr
whose length is no more than
X.B size
bytes long.  The
X.B op
determines the direction of the
X.SM XDR
stream
(either
X.BR \s-1XDR_ENCODE\s0 ,
X.BR \s-1XDR_DECODE\s0 ,
or
X.B
X.SM XDR_FREE
).
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
xdr_opaque(xdrs, cp, cnt)
\s-1XDR\s0 *xdrs;
char *cp;
u_int cnt;
X.fi
X.ft R
X.IP
A filter primitive that translates between fixed size opaque
data
and its external representation.
The parameter
X.B cp
is the address of the opaque object, and
X.B cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
xdr_pointer(xdrs, objpp, objsize, xdrobj)
\s-1XDR\s0 *xdrs;
char **objpp;
u_int objsize;
xdrproc_t xdrobj;
X.fi
X.ft R
X.IP
Like
X.B xdr_reference
in that it
X.SM XDR
's pointers, but the difference is that
X.B xdr_pointer
serializes
X.SM NULL
pointers, whereas
X.B xdr_reference
does not. Thus
X.B xdr_pointer
can
X.SM XDR
recursive data structures, such as binary trees or
linked lists, correctly, whereas
X.B xdr_reference
will fail.
X.br
X.if t .ne 15
X.LP
X.ft B
X.nf
X.sp .5
void
xdrrec_create(xdrs, sendsize, recvsize, handle, readit, writeit)
\s-1XDR\s0 *xdrs;
u_int sendsize, recvsize;
char *handle;
int (*readit)(), (*writeit)();
X.fi
X.ft R
X.IP
This routine initializes the
X.SM XDR
stream object pointed to by
X.BR xdrs .
The stream's data is written to a buffer of size
X.BR sendsize ;
a value of zero indicates the system should use a suitable
default. The stream's data is read from a buffer of size
X.BR recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
X.B writeit
is called.  Similarly, when a stream's input buffer is empty,
X.B readit
is called.  The behavior of these two routines is similar to
the
X.SM UNIX
system calls
X.B read
and
X.BR write ,
except that
X.B handle
is passed to the former routines as the first parameter.
Note that the
X.SM XDR
stream's
X.B op
field must be set by the caller.
X.IP
Warning: this
X.SM XDR
stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
xdrrec_endofrecord(xdrs, sendnow)
\s-1XDR\s0 *xdrs;
int sendnow;
X.fi
X.ft R
X.IP
This routine can be invoked only on streams created by
X.BR xdrrec_create .
The data in the output buffer is marked as a completed
record,
and the output buffer is optionally written out if
X.B sendnow
is non-zero. This routine returns one if it succeeds, zero
otherwise.
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
xdrrec_eof(xdrs)
\s-1XDR\s0 *xdrs;
int empty;
X.fi
X.ft R
X.IP
This routine can be invoked only on streams created by
X.BR xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
X.br
X.if t .ne 3
X.LP
X.ft B
X.nf
X.sp .5
xdrrec_skiprecord(xdrs)
\s-1XDR\s0 *xdrs;
X.fi
X.ft R
X.IP
This routine can be invoked only on streams created by
X.BR xdrrec_create .
It tells the
X.SM XDR
implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 11
X.LP
X.ft B
X.nf
X.sp .5
xdr_reference(xdrs, pp, size, proc)
\s-1XDR\s0 *xdrs;
char **pp;
u_int size;
xdrproc_t proc;
X.fi
X.ft R
X.IP
A primitive that provides pointer chasing within structures.
The parameter
X.B pp
is the address of the pointer;
X.B size
is the
X.B sizeof
the structure that
X.B *pp
points to; and
X.B proc
is an
X.SM XDR
procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
X.IP
Warning: this routine does not understand
X.SM NULL
pointers. Use
X.B xdr_pointer
instead.
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
xdr_setpos(xdrs, pos)
\s-1XDR\s0 *xdrs;
u_int pos;
X.fi
X.ft R
X.IP
A macro that invokes the set position routine associated with
the
X.SM XDR
stream
X.BR xdrs .
The parameter
X.B pos
is a position value obtained from
X.BR xdr_getpos .
This routine returns one if the
X.SM XDR
stream could be repositioned,
and zero otherwise.
X.IP
Warning: it is difficult to reposition some types of
X.SM XDR
streams,
so this routine may fail with one type of stream and succeed
with
another.
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
xdr_short(xdrs, sp)
\s-1XDR\s0 *xdrs;
short *sp;
X.fi
X.ft R
X.IP
A filter primitive that translates between C
X.B short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
void
xdrstdio_create(xdrs, file, op)
\s-1XDR\s0 *xdrs;
FILE *file;
enum xdr_op op;
X.fi
X.ft R
X.IP
This routine initializes the
X.SM XDR
stream object pointed to by
X.BR xdrs .
The
X.SM XDR
stream data is written to, or read from, the Standard
X.B I/O
stream
X.BR file .
The parameter
X.B op
determines the direction of the
X.SM XDR
stream (either
X.B
X.SM XDR_ENCODE
,
X.B
X.SM XDR_DECODE
,
or
X.B
X.SM XDR_FREE
).
X.IP
Warning: the destroy routine associated with such
X.SM XDR
streams calls
X.B fflush
on the
X.B file
stream, but never
X.BR fclose .
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
xdr_string(xdrs, sp, maxsize)
\s-1XDR\s0 *xdrs;
char **sp;
u_int maxsize;
X.fi
X.ft R
X.IP
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
X.BR maxsize .
Note that
X.B sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 8
X.LP
X.ft B
X.nf
X.sp .5
xdr_u_char(xdrs, ucp)
\s-1XDR\s0 *xdrs;
unsigned char *ucp;
X.fi
X.ft R
X.IP
A filter primitive that translates between
X.B unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 9
X.LP
X.ft B
X.nf
X.sp .5
xdr_u_int(xdrs, up)
\s-1XDR\s0 *xdrs;
unsigned *up;
X.fi
X.ft R
X.IP
A filter primitive that translates between C
X.B unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_u_long(xdrs, ulp)
\s-1XDR\s0 *xdrs;
unsigned long *ulp;
X.fi
X.ft R
X.IP
A filter primitive that translates between C
X.B "unsigned long"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 7
X.LP
X.ft B
X.nf
X.sp .5
xdr_u_short(xdrs, usp)
\s-1XDR\s0 *xdrs;
unsigned short *usp;
X.fi
X.ft R
X.IP
A filter primitive that translates between C
X.B "unsigned short"
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 16
X.LP
X.ft B
X.nf
X.sp .5
xdr_union(xdrs, dscmp, unp, choices, dfault)
\s-1XDR\s0 *xdrs;
int *dscmp;
char *unp;
struct xdr_discrim *choices;
bool_t (*defaultarm)();  /* may equal \s-1NULL\s0 */
X.fi
X.ft R
X.IP
A filter primitive that translates between a discriminated C
X.B union
and its corresponding external representation. It first
translates the discriminant of the union located at
X.BR dscmp .
This discriminant is always an
X.BR enum_t .
Next the union located at
X.B unp
is translated.  The parameter
X.B choices
is a pointer to an array of
X.B xdr_discrim
structures. Each structure contains an ordered pair of
X.BR "[value, proc]" .
If the union's discriminant is equal to the associated
X.BR value ,
then the
X.B proc
is called to translate the union.  The end of the
X.B xdr_discrim
structure array is denoted by a routine of value
X.SM NULL .
If the discriminant is not found in the
X.B choices
array, then the
X.B defaultarm
procedure is called (if it's not
X.SM NULL
).
Returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 6
X.LP
X.ft B
X.nf
X.sp .5
xdr_vector(xdrs, arrp, size, elsize, elproc)
\s-1XDR\s0 *xdrs;
char *arrp;
u_int size, elsize;
xdrproc_t elproc;
X.fi
X.ft R
X.IP
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.  The
parameter
X.B arrp
is the address of the pointer to the array, while
X.B size
is is the element count of the array.  The parameter
X.B elsize
is the
X.B sizeof
each of the array's elements, and
X.B elproc
is an
X.SM XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
X.br
X.if t .ne 5
X.LP
X.ft B
X.nf
X.sp .5
xdr_void()
X.fi
X.ft R
X.IP
This routine always returns one.
It may be passed to
X.SM RPC
routines that require a function parameter,
where nothing is to be done.
X.br
X.if t .ne 10
X.LP
X.ft B
X.nf
X.sp .5
xdr_wrapstring(xdrs, sp)
\s-1XDR\s0 *xdrs;
char **sp;
X.fi
X.ft R
X.IP
A primitive that calls
X.B "xdr_string(xdrs, sp, "
X.B
X.SM MAXUN.UNSIGNED
);
where
X.B
X.SM MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
X.B xdr_wrapstring
is handy because the
X.SM RPC
package passes a maximum of two
X.SM XDR
routines as parameters, and
X.BR xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
X.SH SEE ALSO
X.BR \s-1RPC\s0 (3N)
X.br
The followin manuals:
X.RS
X.ft I
eXternal Data Representation Standard: Protocol Specification
X.br
eXternal Data Representation: Sun Technical Notes
X.ft R
X.br
X.IR "\s-1XDR\s0: External Data Representation Standard" ,
X.SM RFC1014, Sun Microsystems, Inc.,
X.SM USC-ISI\s0.
Funky_Stuff
len=`wc -c < xdr.3n`
if [ $len !=    14790 ] ; then
  echo error: xdr.3n was $len bytes long, should have been    14790
fi
cd ..
echo done with directory man3
echo x - man5
echo creating directory man5
mkdir man5
cd man5
echo x - rpc.5
sed -e 's/^X//' > rpc.5 <<'Funky_Stuff'
X.\" @(#)rpc.5	1.3 87/12/02 3.9 RPCSRC
X.\" @(#)rpc.5 1.4 87/11/27 SMI;
X.TH RPC 5  "26 September 1985"
X.SH NAME
rpc \- rpc program number data base
X.SH SYNOPSIS
X.B /etc/rpc
X.SH DESCRIPTION
X.IX  "rpc program number file"  ""  "\fLrpc\fP \(em rpc name data base"
The
X.I rpc
file contains user readable names that
can be used in place of rpc program numbers.
Each line has the following information:
X.HP 10
name of server for the rpc program
X.br
X.ns
X.HP 10
rpc program number
X.br
X.ns
X.HP 10
aliases
X.LP
Items are separated by any number of blanks and/or
tab characters.
A ``#'' indicates the beginning of a comment; characters up to the end of
the line are not interpreted by routines which search the file.
X.LP
Here is an example of the \fI/etc/rpc\fP file from the Sun RPC Source
distribution.
X.nf
X.ta 1.0i +1.0i +1.0i +1.0i
#
# rpc 87/12/02 3.9 RPCSRC
#
portmapper	100000	portmap sunrpc
rstat_svc		100001	rstatd rstat rup perfmeter
rusersd		100002	rusers
nfs		100003	nfsprog
ypserv		100004	ypprog
mountd		100005	mount showmount
ypbind		100007
walld		100008	rwall shutdown
yppasswdd	100009	yppasswd
etherstatd	100010	etherstat
rquotad		100011	rquotaprog quota rquota
sprayd		100012	spray
3270_mapper	100013
rje_mapper	100014
selection_svc	100015	selnsvc
database_svc	100016
rexd		100017	rex
alis		100018
sched		100019
llockmgr	100020
nlockmgr	100021
x25.inr		100022
statmon		100023
status		100024
bootparam	100026
ypupdated	100028	ypupdate
keyserv		100029	keyserver
X.fi
X.DT
X.SH FILES
/etc/rpc
X.SH "SEE ALSO"
getrpcent(3N)
Funky_Stuff
len=`wc -c < rpc.5`
if [ $len !=     1519 ] ; then
  echo error: rpc.5 was $len bytes long, should have been     1519
fi
cd ..
echo done with directory man5
echo x - man8
echo creating directory man8
mkdir man8
cd man8
echo x - portmap.8c
sed -e 's/^X//' > portmap.8c <<'Funky_Stuff'
X.\" @(#)portmap.8c	1.1 87/11/04 3.9 RPCSRC
X.TH PORTMAP 8C "9 September 1987"
X.SH NAME
portmap \- DARPA port to RPC program number mapper
X.SH SYNOPSIS
X.B /usr/etc/rpc.portmap
X.SH DESCRIPTION
X.IX  "portmap command"  ""  "\fLportmap\fP \(em DARPA to RPC mapper"
X.IX  DARPA "to RPC mapper \(em \fLportmap\fP"
X.B portmap
is a server that converts
X.SM RPC
program numbers into
X.SM DARPA
protocol port numbers.
It must be running in order to make
X.SM RPC
calls.
X.LP
When an
X.SM RPC
server is started, it will tell
X.B portmap
what port number it is listening to, and what
X.SM RPC
program numbers it is prepared to serve.
When a client wishes to make an
X.SM RPC
call to a given program number,
it will first contact
X.B portmap
on the server machine to determine
the port number where
X.SM RPC
packets should be sent.
X.LP
Normally, standard
X.SM RPC
servers are started by
X.BR inetd (8C),
so
X.B portmap
must be started before
X.B inetd
is invoked.
X.SH "SEE ALSO"
X.BR servers (5),
X.BR rpcinfo (8),
X.BR inetd (8)
X.SH BUGS
If
X.B portmap
crashes, all servers must be restarted.
Funky_Stuff
len=`wc -c < portmap.8c`
if [ $len !=     1061 ] ; then
  echo error: portmap.8c was $len bytes long, should have been     1061
fi
echo x - rpcinfo.8c
sed -e 's/^X//' > rpcinfo.8c <<'Funky_Stuff'
X.\" @(#)rpcinfo.8c	1.1 87/11/04 3.9 RPCSRC
X.TH RPCINFO 8C "3 November 1987"
X.SH NAME
rpcinfo \- report RPC information
X.SH SYNOPSIS
X.B "rpcinfo \-p"
[
X.I host
]
X.LP
X.B "rpcinfo \-u"
X.I host
X.I program
[
X.I version
]
X.LP
X.B "rpcinfo \-t"
X.I host
X.I program
[
X.I version
]
X.LP
X.B "rpcinfo \-b"
X.I program
X.I version
X.SH DESCRIPTION
X.IX  "rpcinfo command"  ""  "\fLrpcinfo\fP \(em report RPC information"
X.IX RPC "report RPC information \(em \fLrpcinfo\fR"
X.B rpcinfo
makes an
X.SM RPC
call to an
X.SM RPC
server and reports what it finds.
X.SH OPTIONS
X.TP
X.B \-p
Probe the portmapper on
X.IR host ,
and print a list of all registered
X.SM RPC
programs.  If
X.I host
is not specified, it defaults to the value returned by
X.BR hostname (1).
X.TP
X.B \-u
Make an
X.SM RPC
call to procedure 0 of
X.I program
on the specified
X.I host
using
X.SM UDP\s0,
and report whether a response was received.
X.TP
X.B \-t
Make an
X.SM RPC
call to procedure 0 of
X.I program
on the specified
X.I host
using
X.SM TCP\s0,
and report whether a response was received.
X.TP
X.B \-b
Make an
X.SM RPC
broadcast to procedure 0 of the specified
X.I program
and
X.I version
using
X.SM UDP
and report all hosts that respond.
X.LP
The
X.I program
argument can be either a name or a number.
X.LP
If a
X.I version
is specified,
X.B rpcinfo
attempts to call that version of the specified
X.IR program .
Otherwise,
X.B rpcinfo
attempts to find all the registered version
numbers for the specified
X.I program
by calling version 0 (which is presumed not
to exist; if it does exist,
X.B rpcinfo
attempts to obtain this information by calling
an extremely high version
number instead) and attempts to call each registered version.
Note: the version number is required for the
X.B \-b
option.
X.SH EXAMPLES
To show all of the
X.SM RPC
services registered on the local machine use:
X.IP
X.B example% rpcinfo -p
X.LP
To show all of the
X.SM RPC
services registered on the machine named
X.B klaxon
use:
X.IP
X.B example% rpcinfo -p klaxon
X.LP
To show all machines on the local net that are running the Yellow Pages
service use:
X.IP
X.B "example% rpcinfo -b ypserv 'version' | uniq"
X.LP
where 'version' is the current Yellow Pages version obtained from the
results of the
X.B \-p
switch above.
X.SH "SEE ALSO"
X.BR rpc (5),
X.BR portmap (8C)
X.LP
X.I "\s-1RPC\s0 Programming Guide"
in
X.TX NETP
X.SH BUGS
In releases prior to Sun\s-1OS\s0
3.0, the Network File System (\s-1NFS\s0) did not
register itself with the
portmapper;
X.B rpcinfo
cannot be used to make
X.SM RPC
calls to the
X.SM NFS
server on hosts running such releases.
Funky_Stuff
len=`wc -c < rpcinfo.8c`
if [ $len !=     2533 ] ; then
  echo error: rpcinfo.8c was $len bytes long, should have been     2533
fi
echo x - rstat_svc.8c
sed -e 's/^X//' > rstat_svc.8c <<'Funky_Stuff'
X.\" @(#)rstat_svc.8c	1.2 87/11/24 3.9 RPCSRC
X.\" @(#)rstatd.8c 1.10 87/09/09 SMI
X.TH RSTAT_SVC 8C "24 November 1987"
X.SH NAME
rstat_svc \- kernel statistics server
X.SH SYNOPSIS
X.B /etc/rstat_svc
X.SH DESCRIPTION
X.IX  "rstat_svc command"  ""  "\fLrstat_svc\fP \(em kernel statistics server"
X.IX  statistics  rstat_svc  ""  "\fLrstat_svc\fP \(em kernel statistics server"
X.IX  servers  rstat_svc  ""  "\fLrstat_svc\fP \(em kernel statistics server"
X.LP
X.B rstat_svc
is a server which returns performance statistics
obtained from the kernel.
These statistics are graphically displayed by the Sun Microsystems program,
X.BR perfmeter (1).
The
X.B rstat_svc
daemon is normally invoked at boot time through /etc/rc.local.
X.PP
X.B rstat_svc
uses an RPC protocol defined in /usr/include/rpcsvc/rstat.x.
Funky_Stuff
len=`wc -c < rstat_svc.8c`
if [ $len !=      791 ] ; then
  echo error: rstat_svc.8c was $len bytes long, should have been      791
fi
cd ..
echo done with directory man8
cd ..
echo done with directory man
exit
