Subject:  v13i012:  Perl patches 6 to 10, Patch6-Patch10
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Rich $alz <rsalz@bbn.com>
Posting-number: Volume 13, Issue 12
Archive-name: perl/patches6-10

This is the second of two files containing the first 10 official patches 
to perl.  They are copies of the articles as I received them on my 
machine. 
 
When you unpack this you will get five separate patch files, each of
which will have to be fed through patch.  Make sure to install all 
10 patches. 
	 /r$

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  patch6 patch7 patch8 patch9 patch10
# Wrapped by rsalz@fig.bbn.com on Sun Jan 31 13:12:45 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch6'\"
else
echo shar: Extracting \"'patch6'\" \(3112 characters\)
sed "s/^X//" >'patch6' <<'END_OF_FILE'
XPath: bbn.com!bbn!husc6!cmcl2!beta!hc!ames!elroy!devvax!lroot
XFrom: lroot@devvax.JPL.NASA.GOV (The Superuser)
XNewsgroups: comp.sources.bugs
XSubject: perl 1.0 patch #6
XSummary: This is an official patch for perl 1.0.  Please apply it.
XMessage-ID: <1156@devvax.JPL.NASA.GOV>
XDate: 26 Jan 88 20:35:04 GMT
XOrganization: Jet Propulsion Laboratory, Pasadena, CA
XLines: 97
X
XSystem: perl version 1.0
XPatch #: 6
XPriority: LOW
XSubject: printf doesn't finish processing format string when out of args.
XFrom: isis!aburt (Andrew Burt)
X
XDescription:
X	printf "%% %d %%", 1;  produces "% 1 %%", which is counterintuitive.
X
XFix:	From rn, say "| patch -d DIR", where DIR is your perl source
X	directory.  Outside of rn, say "cd DIR; patch <thisarticle".
X	If you don't have the patch program, apply the following by hand,
X	or get patch.
X
X	If patch indicates that patchlevel is the wrong version, you may need
X	to apply one or more previous patches, or the patch may already
X	have been applied.  See the patchlevel.h file to find out what has or
X	has not been applied.  In any event, don't continue with the patch.
X
X	If you are missing previous patches they can be obtained from me:
X
X	Larry Wall
X	lwall@jpl-devvax.jpl.nasa.gov
X
X	If you send a mail message of the following form it will greatly speed
X	processing:
X
X	Subject: Command
X	@SH mailpatch PATH perl 1.0 LIST
X		   ^ note the c
X
X	where PATH is a return path FROM ME TO YOU in Internet notation, and
X	LIST is the number of one or more patches you need, separated by spaces,
X	commas, and/or hyphens.  Saying 35- says everything from 35 to the end.
X
X	You can also get the patches via anonymous FTP from
X	jpl-devvax.jpl.nasa.gov (128.149.8.43).
X
XIndex: patchlevel.h
XPrereq: 5
X1c1
X< #define PATCHLEVEL 5
X---
X> #define PATCHLEVEL 6
X 
XIndex: arg.c
XPrereq: 1.0.1.2
X*** arg.c.old	Tue Jan 26 12:31:23 1988
X--- arg.c	Tue Jan 26 12:31:25 1988
X***************
X*** 1,6 ****
X! /* $Header: arg.c,v 1.0.1.2 88/01/24 03:52:34 root Exp $
X   *
X   * $Log:	arg.c,v $
X   * Revision 1.0.1.2  88/01/24  03:52:34  root
X   * patch 2: added STATBLKS dependencies.
X   * 
X--- 1,9 ----
X! /* $Header: arg.c,v 1.0.1.3 88/01/26 12:30:33 root Exp $
X   *
X   * $Log:	arg.c,v $
X+  * Revision 1.0.1.3  88/01/26  12:30:33  root
X+  * patch 6: sprintf didn't finish processing format string when out of args.
X+  * 
X   * Revision 1.0.1.2  88/01/24  03:52:34  root
X   * patch 2: added STATBLKS dependencies.
X   * 
X***************
X*** 646,656 ****
X      register char *t;
X      bool dolong;
X      char ch;
X  
X      str_set(str,"");
X      len--;			/* don't count pattern string */
X      sarg++;
X!     for (s = str_get(*(sarg++)); *sarg && *s && len; len--) {
X  	dolong = FALSE;
X  	for (t = s; *t && *t != '%'; t++) ;
X  	if (!*t)
X--- 649,664 ----
X      register char *t;
X      bool dolong;
X      char ch;
X+     static STR *sargnull = &str_no;
X  
X      str_set(str,"");
X      len--;			/* don't count pattern string */
X      sarg++;
X!     for (s = str_get(*(sarg++)); *s; len--) {
X! 	if (len <= 0 || !*sarg) {
X! 	    sarg = &sargnull;
X! 	    len = 0;
X! 	}
X  	dolong = FALSE;
X  	for (t = s; *t && *t != '%'; t++) ;
X  	if (!*t)
END_OF_FILE
if test 3112 -ne `wc -c <'patch6'`; then
    echo shar: \"'patch6'\" unpacked with wrong size!
fi
# end of 'patch6'
fi
if test -f 'patch7' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch7'\"
else
echo shar: Extracting \"'patch7'\" \(7604 characters\)
sed "s/^X//" >'patch7' <<'END_OF_FILE'
XPath: bbn.com!bbn!uwmcsd1!ig!agate!pasteur!ames!elroy!devvax!lroot
XFrom: lroot@devvax.JPL.NASA.GOV (The Superuser)
XNewsgroups: comp.sources.bugs
XSubject: perl 1.0 patch #7
XSummary: This is an official patch for perl 1.0.  Please apply it.
XMessage-ID: <1158@devvax.JPL.NASA.GOV>
XDate: 26 Jan 88 23:04:26 GMT
XOrganization: Jet Propulsion Laboratory, Pasadena, CA
XLines: 273
X
XSystem: perl version 1.0
XPatch #: 7
XPriority: HIGH if malloc.c doesn't compile
XSubject: use of included malloc.c should be optional
XFrom: gatech!skeeve!arnold (Arnold D. Robbins)
X
XDescription:
X	The version of malloc.c that comes with perl was not really intended
X	to be used everywhere--it was included mostly for debugging purposes.
X	It's a nice little package, however, so I'm making it optional (via
X	Configure) as to whether you want it or not.
X
XFix:	From rn, say "| patch -p0 -d DIR", where DIR is your perl source
X	directory.  Outside of rn, say "cd DIR; patch -p0 <thisarticle".
X	If you don't have the patch program, apply the following by hand,
X	or get patch.
X
X>>> You must say -p0 to patch, or it will try to patch ./Makefile.SH twice,
X>>> instead of patching both ./Makefile.SH and x2p/Makefile.SH.
X
X	If patch indicates that patchlevel is the wrong version, you may need
X	to apply one or more previous patches, or the patch may already
X	have been applied.  See the patchlevel.h file to find out what has or
X	has not been applied.  In any event, don't continue with the patch.
X
X	If you are missing previous patches they can be obtained from me:
X
X	Larry Wall
X	lwall@jpl-devvax.jpl.nasa.gov
X
X	If you send a mail message of the following form it will greatly speed
X	processing:
X
X	Subject: Command
X	@SH mailpatch PATH perl 1.0 LIST
X		   ^ note the c
X
X	where PATH is a return path FROM ME TO YOU in Internet notation, and
X	LIST is the number of one or more patches you need, separated by spaces,
X	commas, and/or hyphens.  Saying 35- says everything from 35 to the end.
X
X	You can also get the patches via anonymous FTP from
X	jpl-devvax.jpl.nasa.gov (128.149.8.43).
X
XIndex: patchlevel.h
XPrereq: 6
X1c1
X< #define PATCHLEVEL 6
X---
X> #define PATCHLEVEL 7
X 
XIndex: Configure
XPrereq: 1.0.1.2
X*** Configure.old	Tue Jan 26 14:16:00 1988
X--- Configure	Tue Jan 26 14:16:05 1988
X***************
X*** 8,14 ****
X  # and edit it to reflect your system.  Some packages may include samples
X  # of config.h for certain machines, so you might look for one of those.)
X  #
X! # $Header: Configure,v 1.0.1.2 88/01/24 03:51:55 root Exp $
X  #
X  # Yes, you may rip this off to use in other distribution packages.
X  # (Note: this Configure script was generated automatically.  Rather than
X--- 8,14 ----
X  # and edit it to reflect your system.  Some packages may include samples
X  # of config.h for certain machines, so you might look for one of those.)
X  #
X! # $Header: Configure,v 1.0.1.3 88/01/26 14:14:14 root Exp $
X  #
X  # Yes, you may rip this off to use in other distribution packages.
X  # (Note: this Configure script was generated automatically.  Rather than
X***************
X*** 79,84 ****
X--- 79,87 ----
X  d_voidsig=''
X  libc=''
X  libnm=''
X+ mallocsrc=''
X+ mallocobj=''
X+ usemymalloc=''
X  mansrc=''
X  manext=''
X  models=''
X***************
X*** 1249,1255 ****
X--- 1252,1283 ----
X      esac
X  fi
X  
X+ : determine which malloc to compile in
X  echo " "
X+ case "$usemymalloc" in
X+ '')
X+     if bsd || v7; then
X+ 	dflt='y'
X+     else
X+ 	dflt='n'
X+     fi
X+     ;;
X+ *)  dflt="$usemymalloc"
X+     ;;
X+ esac
X+ rp="Do you wish to attempt to use the malloc that comes with $package? [$dflt]"
X+ $echo $n "$rp $c"
X+ . myread
X+ case "$ans" in
X+ '') ans=$dflt;;
X+ esac
X+ usemymalloc="$ans"
X+ case "$ans" in
X+ y*) mallocsrc='malloc.c'; mallocobj='malloc.o';;
X+ *) mallocsrc=''; mallocobj='';;
X+ esac
X+ 
X+ echo " "
X  echo "End of configuration questions."
X  echo " "
X  
X***************
X*** 1309,1314 ****
X--- 1337,1345 ----
X  d_voidsig='$d_voidsig'
X  libc='$libc'
X  libnm='$libnm'
X+ mallocsrc='$mallocsrc'
X+ mallocobj='$mallocobj'
X+ usemymalloc='$usemymalloc'
X  mansrc='$mansrc'
X  manext='$manext'
X  models='$models'
X 
XIndex: Makefile.SH
XPrereq: 1.0.1.2
X*** Makefile.SH.old	Tue Jan 26 14:55:03 1988
X--- Makefile.SH	Tue Jan 26 14:15:06 1988
X***************
X*** 14,22 ****
X  esac
X  echo "Extracting Makefile (with variable substitutions)"
X  cat >Makefile <<!GROK!THIS!
X! # $Header: Makefile.SH,v 1.0.1.2 88/01/26 08:46:04 root Exp $
X  #
X  # $Log:	Makefile.SH,v $
X  # Revision 1.0.1.2  88/01/26  08:46:04  root
X  # patch 4: make depend didn't work right if . wasn't in PATH.
X  # 
X--- 14,25 ----
X  esac
X  echo "Extracting Makefile (with variable substitutions)"
X  cat >Makefile <<!GROK!THIS!
X! # $Header: Makefile.SH,v 1.0.1.3 88/01/26 14:14:52 root Exp $
X  #
X  # $Log:	Makefile.SH,v $
X+ # Revision 1.0.1.3  88/01/26  14:14:52  root
X+ # Added mallocsrc stuff.
X+ # 
X  # Revision 1.0.1.2  88/01/26  08:46:04  root
X  # patch 4: make depend didn't work right if . wasn't in PATH.
X  # 
X***************
X*** 36,41 ****
X--- 39,46 ----
X  LDFLAGS = $ldflags
X  SMALL = $small
X  LARGE = $large $split
X+ mallocsrc = $mallocsrc
X+ mallocobj = $mallocobj
X  
X  libs = $libnm -lm
X  !GROK!THIS!
X***************
X*** 57,68 ****
X  
X  h = $(h1) $(h2)
X  
X! c1 = arg.c array.c cmd.c dump.c form.c hash.c malloc.c
X  c2 = search.c stab.c str.c util.c version.c
X  
X  c = $(c1) $(c2)
X  
X! obj1 = arg.o array.o cmd.o dump.o form.o hash.o malloc.o
X  obj2 = search.o stab.o str.o util.o version.o
X  
X  obj = $(obj1) $(obj2)
X--- 62,73 ----
X  
X  h = $(h1) $(h2)
X  
X! c1 = arg.c array.c cmd.c dump.c form.c hash.c $(mallocsrc)
X  c2 = search.c stab.c str.c util.c version.c
X  
X  c = $(c1) $(c2)
X  
X! obj1 = arg.o array.o cmd.o dump.o form.o hash.o $(mallocobj)
X  obj2 = search.o stab.o str.o util.o version.o
X  
X  obj = $(obj1) $(obj2)
X
XIf this complains below, perhaps you neglected to say patch -p0.
XIf so, patch is trying to apply this patch to ./Makefile.SH instead
Xof x2p/Makefile.SH.  Abort this patch and reapply as you did before
Xonly this time add both -p0 and -N, e.g.
X    patch -p0 -N -d DIR < thisarticle
X
XIndex: x2p/Makefile.SH
XPrereq: 1.0
X*** x2p/Makefile.SH.old	Tue Jan 26 14:16:41 1988
X--- x2p/Makefile.SH	Tue Jan 26 14:17:13 1988
X***************
X*** 12,22 ****
X  case "$0" in
X  */*) cd `expr X$0 : 'X\(.*\)/'` ;;
X  esac
X  echo "Extracting x2p/Makefile (with variable substitutions)"
X  cat >Makefile <<!GROK!THIS!
X! # $Header: Makefile.SH,v 1.0 87/12/18 17:50:17 root Exp $
X  #
X  # $Log:	Makefile.SH,v $
X  # Revision 1.0  87/12/18  17:50:17  root
X  # Initial revision
X  # 
X--- 12,29 ----
X  case "$0" in
X  */*) cd `expr X$0 : 'X\(.*\)/'` ;;
X  esac
X+ case "$mallocsrc" in
X+ '') ;;
X+ *) mallocsrc="../$mallocsrc";;
X+ esac
X  echo "Extracting x2p/Makefile (with variable substitutions)"
X  cat >Makefile <<!GROK!THIS!
X! # $Header: Makefile.SH,v 1.0.1.1 88/01/26 14:15:24 root Exp $
X  #
X  # $Log:	Makefile.SH,v $
X+ # Revision 1.0.1.1  88/01/26  14:15:24  root
X+ # Added mallocsrc stuff.
X+ # 
X  # Revision 1.0  87/12/18  17:50:17  root
X  # Initial revision
X  # 
X***************
X*** 31,36 ****
X--- 38,45 ----
X  LDFLAGS = $ldflags
X  SMALL = $small
X  LARGE = $large $split
X+ mallocsrc = $mallocsrc
X+ mallocobj = $mallocobj
X  
X  libs = $libnm -lm
X  !GROK!THIS!
X***************
X*** 49,57 ****
X  
X  h = EXTERN.h INTERN.h config.h handy.h hash.h a2p.h str.h util.h
X  
X! c = hash.c ../malloc.c str.c util.c walk.c
X  
X! obj = hash.o malloc.o str.o util.o walk.o
X  
X  lintflags = -phbvxac
X  
X--- 58,66 ----
X  
X  h = EXTERN.h INTERN.h config.h handy.h hash.h a2p.h str.h util.h
X  
X! c = hash.c $(mallocsrc) str.c util.c walk.c
X  
X! obj = hash.o $(mallocobj) str.o util.o walk.o
X  
X  lintflags = -phbvxac
X  
END_OF_FILE
if test 7604 -ne `wc -c <'patch7'`; then
    echo shar: \"'patch7'\" unpacked with wrong size!
fi
# end of 'patch7'
fi
if test -f 'patch8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch8'\"
else
echo shar: Extracting \"'patch8'\" \(35848 characters\)
sed "s/^X//" >'patch8' <<'END_OF_FILE'
XPath: bbn.com!bbn!uwmcsd1!ig!agate!pasteur!ames!elroy!devvax!lroot
XFrom: lroot@devvax.JPL.NASA.GOV (The Superuser)
XNewsgroups: comp.sources.bugs
XSubject: perl 1.0 patch #8
XSummary: This is an official patch for perl 1.0.  Please apply it.
XMessage-ID: <1174@devvax.JPL.NASA.GOV>
XDate: 28 Jan 88 19:44:05 GMT
XOrganization: Jet Propulsion Laboratory, Pasadena, CA
XLines: 1437
X
XSystem: perl version 1.0
XPatch #: 8
XPriority: ENHANCEMENT
XSubject: perl needed an eval operator and a symbolic debugger
XFrom: lwall@jpl-devvax.jpl.nasa.gov (Larry Wall)
X
XDescription:
X	I didn't add an eval operator to the original perl because
X	I hadn't thought of any good uses for it.  Recently I thought
X	of some.  Along with creating the eval operator, this patch
X	introduces a symbolic debugger for perl scripts, which makes
X	use of eval to interpret some debugging commands.  Having eval
X	also lets me emulate awk's FOO=bar command line behavior with
X	a line such as the one a2p now inserts at the beginning of
X	translated scripts.
X
XFix:	From rn, say "| patch -p0 -d DIR", where DIR is your perl source
X			      ^^^
X	directory.  Outside of rn, say "cd DIR; patch -p0 <thisarticle".
X	If you don't have the patch program, apply the following by hand,
X	or get patch.
X
X>>>>	YOU MUST USE THE -p0 SWITCH ABOVE OR PATCH WON'T WORK RIGHT.   <<<<
X
X	If patch indicates that patchlevel is the wrong version, you may need
X	to apply one or more previous patches, or the patch may already
X	have been applied.  See the patchlevel.h file to find out what has or
X	has not been applied.  In any event, don't continue with the patch.
X
X	If you are missing previous patches they can be obtained from me:
X
X	Larry Wall
X	lwall@jpl-devvax.jpl.nasa.gov
X
X	If you send a mail message of the following form it will greatly speed
X	processing:
X
X	Subject: Command
X	@SH mailpatch PATH perl 1.0 LIST
X		   ^ note the c
X
X	where PATH is a return path FROM ME TO YOU in Internet notation, and
X	LIST is the number of one or more patches you need, separated by spaces,
X	commas, and/or hyphens.  Saying 35- says everything from 35 to the end.
X
X	You can also get the patches via anonymous FTP from
X	jpl-devvax.jpl.nasa.gov (128.149.8.43).
X
XIndex: patchlevel.h
XPrereq: 7
X1c1
X< #define PATCHLEVEL 7
X---
X> #define PATCHLEVEL 8
X 
XIndex: Makefile.SH
XPrereq: 1.0.1.3
X*** Makefile.SH.old	Thu Jan 28 11:08:32 1988
X--- Makefile.SH	Thu Jan 28 11:08:33 1988
X***************
X*** 14,22 ****
X  esac
X  echo "Extracting Makefile (with variable substitutions)"
X  cat >Makefile <<!GROK!THIS!
X! # $Header: Makefile.SH,v 1.0.1.3 88/01/26 14:14:52 root Exp $
X  #
X  # $Log:	Makefile.SH,v $
X  # Revision 1.0.1.3  88/01/26  14:14:52  root
X  # Added mallocsrc stuff.
X  # 
X--- 14,25 ----
X  esac
X  echo "Extracting Makefile (with variable substitutions)"
X  cat >Makefile <<!GROK!THIS!
X! # $Header: Makefile.SH,v 1.0.1.4 88/01/28 10:17:59 root Exp $
X  #
X  # $Log:	Makefile.SH,v $
X+ # Revision 1.0.1.4  88/01/28  10:17:59  root
X+ # patch8: added perldb.man
X+ # 
X  # Revision 1.0.1.3  88/01/26  14:14:52  root
X  # Added mallocsrc stuff.
X  # 
X***************
X*** 47,57 ****
X  
X  cat >>Makefile <<'!NO!SUBS!'
X  
X! public = perl
X  
X  private = 
X  
X! manpages = perl.man
X  
X  util =
X  
X--- 50,60 ----
X  
X  cat >>Makefile <<'!NO!SUBS!'
X  
X! public = perl perldb
X  
X  private = 
X  
X! manpages = perl.man perldb.man
X  
X  util =
X  
XIf you are sitting there wondering why patch didn't find x2p/a2py.c, perhaps
Xit is because you didn't say -p0 to patch.  If so, abort patch now and run
Xit again as you did, but add the following switches: -p0 -N
X
XIndex: x2p/a2py.c
XPrereq: 1.0
X*** x2p/a2py.c.old	Thu Jan 28 11:18:17 1988
X--- x2p/a2py.c	Thu Jan 28 11:18:18 1988
X***************
X*** 1,6 ****
X! /* $Header: a2py.c,v 1.0 87/12/18 17:50:33 root Exp $
X   *
X   * $Log:	a2py.c,v $
X   * Revision 1.0  87/12/18  17:50:33  root
X   * Initial revision
X   * 
X--- 1,9 ----
X! /* $Header: a2py.c,v 1.0.1.1 88/01/28 11:07:08 root Exp $
X   *
X   * $Log:	a2py.c,v $
X+  * Revision 1.0.1.1  88/01/28  11:07:08  root
X+  * patch8: added support for FOO=bar switches using eval.
X+  * 
X   * Revision 1.0  87/12/18  17:50:33  root
X   * Initial revision
X   * 
X***************
X*** 114,119 ****
X--- 117,126 ----
X  
X      tmpstr = walk(0,0,root,&i);
X      str = str_make("#!/bin/perl\n\n");
X+     str_cat(str,
X+       "eval '$'.$1.'$2;' while $ARGV[0] =~ /^([A-Za-z_]+=)(.*)/ && shift;\n");
X+     str_cat(str,
X+       "			# process any FOO=bar switches\n\n");
X      if (do_opens && opens) {
X  	str_scat(str,opens);
X  	str_free(opens);
X 
XIndex: arg.c
XPrereq: 1.0.1.3
X*** arg.c.old	Thu Jan 28 11:08:43 1988
X--- arg.c	Thu Jan 28 11:08:46 1988
X***************
X*** 1,8 ****
X! /* $Header: arg.c,v 1.0.1.3 88/01/26 12:30:33 root Exp $
X   *
X   * $Log:	arg.c,v $
X!  * Revision 1.0.1.3  88/01/26  12:30:33  root
X!  * patch 6: sprintf didn't finish processing format string when out of args.
X   * 
X   * Revision 1.0.1.2  88/01/24  03:52:34  root
X   * patch 2: added STATBLKS dependencies.
X--- 1,8 ----
X! /* $Header: arg.c,v 1.0.1.4 88/01/28 10:22:06 root Exp $
X   *
X   * $Log:	arg.c,v $
X!  * Revision 1.0.1.4  88/01/28  10:22:06  root
X!  * patch8: added eval operator.
X   * 
X   * Revision 1.0.1.2  88/01/24  03:52:34  root
X   * patch 2: added STATBLKS dependencies.
X***************
X*** 1190,1195 ****
X--- 1190,1196 ----
X      opargs[O_UNSHIFT] =		A(1,0,0);
X      opargs[O_LINK] =		A(1,1,0);
X      opargs[O_REPEAT] =		A(1,1,0);
X+     opargs[O_EVAL] =		A(1,0,0);
X  }
X  
X  #ifdef VOIDSIG
X***************
X*** 2091,2096 ****
X--- 2092,2102 ----
X  	    astore(ary,0,str);
X  	}
X  	value = (double)(ary->ary_fill + 1);
X+ 	break;
X+     case O_EVAL:
X+ 	str_sset(str,
X+ 	    do_eval(arg[1].arg_type != A_NULL ? sarg[1] : defstab->stab_val) );
X+ 	STABSET(str);
X  	break;
X      }
X  #ifdef DEBUGGING
X 
XIndex: arg.h
XPrereq: 1.0
X*** arg.h.old	Thu Jan 28 11:08:59 1988
X--- arg.h	Thu Jan 28 11:09:00 1988
X***************
X*** 1,6 ****
X! /* $Header: arg.h,v 1.0 87/12/18 13:04:39 root Exp $
X   *
X   * $Log:	arg.h,v $
X   * Revision 1.0  87/12/18  13:04:39  root
X   * Initial revision
X   * 
X--- 1,9 ----
X! /* $Header: arg.h,v 1.0.1.1 88/01/28 10:22:40 root Exp $
X   *
X   * $Log:	arg.h,v $
X+  * Revision 1.0.1.1  88/01/28  10:22:40  root
X+  * patch8: added eval operator.
X+  * 
X   * Revision 1.0  87/12/18  13:04:39  root
X   * Initial revision
X   * 
X***************
X*** 111,117 ****
X  #define O_UNSHIFT 102
X  #define O_LINK 103
X  #define O_REPEAT 104
X! #define MAXO 105
X  
X  #ifndef DOINIT
X  extern char *opname[];
X--- 114,121 ----
X  #define O_UNSHIFT 102
X  #define O_LINK 103
X  #define O_REPEAT 104
X! #define O_EVAL 105
X! #define MAXO 106
X  
X  #ifndef DOINIT
X  extern char *opname[];
X***************
X*** 222,228 ****
X      "UNSHIFT",
X      "LINK",
X      "REPEAT",
X!     "105"
X  };
X  #endif
X  
X--- 226,233 ----
X      "UNSHIFT",
X      "LINK",
X      "REPEAT",
X!     "EVAL",
X!     "106"
X  };
X  #endif
X  
X 
XIndex: t/base.lex
XPrereq: 1.0
X*** t/base.lex.old	Thu Jan 28 11:17:55 1988
X--- t/base.lex	Thu Jan 28 11:17:56 1988
X***************
X*** 1,8 ****
X  #!./perl
X  
X! # $Header: base.lex,v 1.0 87/12/18 13:11:51 root Exp $
X  
X! print "1..4\n";
X  
X  $ # this is the register <space>
X  = 'x';
X--- 1,8 ----
X  #!./perl
X  
X! # $Header: base.lex,v 1.0.1.1 88/01/28 10:37:00 root Exp $
X  
X! print "1..6\n";
X  
X  $ # this is the register <space>
X  = 'x';
X***************
X*** 21,23 ****
X--- 21,32 ----
X  $x = '\\'; # ';
X  
X  if (length($x) == 1) {print "ok 4\n";} else {print "not ok 4\n";}
X+ 
X+ eval 'while (0) {
X+     print "foo\n";
X+ }
X+ /^/ && (print "ok 5\n");
X+ ';
X+ 
X+ eval '$foo{1} / 1;';
X+ if (!$@) {print "ok 6\n";} else {print "not ok 6\n";}
X 
XIndex: cmd.h
XPrereq: 1.0
X*** cmd.h.old	Thu Jan 28 11:09:05 1988
X--- cmd.h	Thu Jan 28 11:09:06 1988
X***************
X*** 1,6 ****
X! /* $Header: cmd.h,v 1.0 87/12/18 13:04:59 root Exp $
X   *
X   * $Log:	cmd.h,v $
X   * Revision 1.0  87/12/18  13:04:59  root
X   * Initial revision
X   * 
X--- 1,9 ----
X! /* $Header: cmd.h,v 1.0.1.1 88/01/28 10:23:07 root Exp $
X   *
X   * $Log:	cmd.h,v $
X+  * Revision 1.0.1.1  88/01/28  10:23:07  root
X+  * patch8: added eval_root for eval operator.
X+  * 
X   * Revision 1.0  87/12/18  13:04:59  root
X   * Initial revision
X   * 
X***************
X*** 106,111 ****
X--- 109,115 ----
X  #define Nullcmd Null(CMD*)
X  
X  EXT CMD *main_root INIT(Nullcmd);
X+ EXT CMD *eval_root INIT(Nullcmd);
X  
X  EXT struct compcmd {
X      CMD *comp_true;
X 
XIndex: t/op.eval
X*** t/op.eval.old	Thu Jan 28 11:18:04 1988
X--- t/op.eval	Thu Jan 28 11:18:04 1988
X***************
X*** 0 ****
X--- 1,20 ----
X+ #!./perl
X+ 
X+ print "1..6\n";
X+ 
X+ eval 'print "ok 1\n";';
X+ 
X+ if ($@ eq '') {print "ok 2\n";} else {print "not ok 2\n";}
X+ 
X+ eval "\$foo\n    = # this is a comment\n'ok 3';";
X+ print $foo,"\n";
X+ 
X+ eval "\$foo\n    = # this is a comment\n'ok 4\n';";
X+ print $foo;
X+ 
X+ eval '
X+ $foo =';		# this tests for a call through yyerror()
X+ if ($@ =~ /line 2/) {print "ok 5\n";} else {print "not ok 5\n";}
X+ 
X+ eval '$foo = /';	# this tests for a call through fatal()
X+ if ($@ =~ /Search/) {print "ok 6\n";} else {print "not ok 6\n";}
X 
XIndex: perl.h
XPrereq: 1.0.1.2
X*** perl.h.old	Thu Jan 28 11:09:13 1988
X--- perl.h	Thu Jan 28 11:09:14 1988
X***************
X*** 1,6 ****
X! /* $Header: perl.h,v 1.0.1.2 88/01/24 03:53:47 root Exp $
X   *
X   * $Log:	perl.h,v $
X   * Revision 1.0.1.2  88/01/24  03:53:47  root
X   * patch 2: hid str_peek() in #ifdef DEBUGGING.
X   * 
X--- 1,9 ----
X! /* $Header: perl.h,v 1.0.1.3 88/01/28 10:24:17 root Exp $
X   *
X   * $Log:	perl.h,v $
X+  * Revision 1.0.1.3  88/01/28  10:24:17  root
X+  * patch8: added eval operator.
X+  * 
X   * Revision 1.0.1.2  88/01/24  03:53:47  root
X   * patch 2: hid str_peek() in #ifdef DEBUGGING.
X   * 
X***************
X*** 103,109 ****
X  STR *arg_to_str();
X  STR *str_new();
X  STR *stab_str();
X! STR *eval();
X  
X  FCMD *load_format();
X  
X--- 106,113 ----
X  STR *arg_to_str();
X  STR *str_new();
X  STR *stab_str();
X! STR *eval();		/* this evaluates expressions */
X! STR *do_eval();		/* this evaluates eval operator */
X  
X  FCMD *load_format();
X  
X***************
X*** 164,169 ****
X--- 168,174 ----
X  EXT char tokenbuf[256];
X  EXT int expectterm INIT(TRUE);
X  EXT int lex_newlines INIT(FALSE);
X+ EXT int in_eval INIT(FALSE);
X  
X  FILE *popen();
X  /* char *str_get(); */
X***************
X*** 196,201 ****
X--- 201,207 ----
X  EXT int loop_ptr INIT(-1);
X  
X  EXT jmp_buf top_env;
X+ EXT jmp_buf eval_env;
X  
X  EXT char *goto_targ INIT(Nullch);	/* cmd_exec gets strange when set */
X  
X 
XIndex: perl.y
XPrereq: 1.0
X*** perl.y.old	Thu Jan 28 11:09:22 1988
X--- perl.y	Thu Jan 28 11:09:24 1988
X***************
X*** 1,6 ****
X! /* $Header: perl.y,v 1.0 87/12/18 15:48:59 root Exp $
X   *
X   * $Log:	perl.y,v $
X   * Revision 1.0  87/12/18  15:48:59  root
X   * Initial revision
X   * 
X--- 1,9 ----
X! /* $Header: perl.y,v 1.0.1.1 88/01/28 10:25:31 root Exp $
X   *
X   * $Log:	perl.y,v $
X+  * Revision 1.0.1.1  88/01/28  10:25:31  root
X+  * patch8: added eval operator.
X+  * 
X   * Revision 1.0  87/12/18  15:48:59  root
X   * Initial revision
X   * 
X***************
X*** 97,103 ****
X  %% /* RULES */
X  
X  prog	:	lineseq
X! 			{ main_root = block_head($1); }
X  	;
X  
X  compblock:	block CONTINUE block
X--- 100,109 ----
X  %% /* RULES */
X  
X  prog	:	lineseq
X! 			{ if (in_eval)
X! 				eval_root = block_head($1);
X! 			    else
X! 				main_root = block_head($1); }
X  	;
X  
X  compblock:	block CONTINUE block
X 
XIndex: perldb
X*** perldb.old	Thu Jan 28 11:17:03 1988
X--- perldb	Thu Jan 28 11:17:04 1988
X***************
X*** 0 ****
X--- 1,296 ----
X+ #!/bin/perl
X+ 
X+ # $Header: perldb,v 1.0.1.1 88/01/28 10:27:16 root Exp $
X+ #
X+ # $Log:	perldb,v $
X+ # Revision 1.0.1.1  88/01/28  10:27:16  root
X+ # patch8: created this file.
X+ # 
X+ #
X+ 
X+ $tmp = "/tmp/pdb$$";		# default temporary file, -o overrides.
X+ 
X+ # parse any switches
X+ 
X+ while ($ARGV[0] =~ /^-/) {
X+     $_ = shift;
X+     /^-o$/ && ($tmp = shift,next);
X+     die "Unrecognized switch: $_";
X+ }
X+ 
X+ $filename = shift;
X+ die "Usage: perldb [-o output] scriptname arguments" unless $filename;
X+ 
X+ open(script,$filename) || die "Can't find $filename";
X+ 
X+ open(tmp, ">$tmp") || die "Can't make temp script";
X+ 
X+ $perl = '/bin/perl';
X+ $init = 1;
X+ $state = 'statement';
X+ 
X+ # now translate script to contain DB calls at the appropriate places
X+ 
X+ while (<script>) {
X+     chop;
X+     if ($. == 1) {
X+ 	if (/^#! *([^ \t]*) (-[^ \t]*)/) {
X+ 	    $perl = $1;
X+ 	    $switch = $2;
X+ 	}
X+ 	elsif (/^#! *([^ \t]*)/) {
X+ 	    $perl = $1;
X+ 	}
X+     }
X+     s/ *$//;
X+     push(@script,$_);		# remember line for DBinit
X+     $line = $_;
X+     next if /^$/;		# blank lines are uninteresting
X+     next if /^[ \t]*#/;		# likewise comment lines
X+     if ($init) {
X+ 	print tmp "do DBinit($.);"; $init = '';
X+     }
X+     if ($inform) {		# skip formats
X+ 	if (/^\.$/) {
X+ 	    $inform = '';
X+ 	    $state = 'statement';
X+ 	}
X+ 	next;
X+     }
X+     if (/^[ \t]*format /) {
X+ 	$inform++;
X+ 	next;
X+     }
X+     if ($state eq 'statement' && !/^[ \t]*}/) {
X+ 	if (s/^([ \t]*[A-Za-z_0-9]+:)//) {
X+ 	    $label = $1;
X+ 	}
X+ 	else {
X+ 	    $label = '';
X+ 	}
X+ 	$line = $label . "do DB($.); " . $_;	# all that work for this line
X+     }
X+     else {
X+ 	$script[$#script - 1] .= ' ';	# mark line as having continuation
X+     }
X+     do parse();				# set $state to correct eol value
X+ }
X+ continue {
X+     print tmp $line,"\n";
X+ }
X+ 
X+ # now put out our debugging subroutines.  First the one that's called all over.
X+ 
X+ print tmp '
X+ sub DB {
X+     push(@DB,$. ,$@, $!, $[, $,, $/, $\ );
X+     $[ = 0; $, = ""; $/ = "\n"; $\ = "";
X+     $DBline=pop(@_);
X+     if ($DBsingle || $DBstop[$DBline] || $DBtrace) {
X+ 	print "$DBline:\t",$DBline[$DBline],"\n";
X+ 	for ($DBi = $DBline; $DBline[$DBi++] =~ / $/; ) {
X+ 	    print "$DBi:\t",$DBline[$DBi],"\n";
X+ 	}
X+     }
X+     if ($DBaction[$DBline]) {
X+ 	eval $DBaction[$DBline];  print $@;
X+     }
X+     if ($DBstop[$DBline] || $DBsingle) {
X+ 	for (;;) {
X+ 	    print "perldb> ";
X+ 	    $DBcmd = <stdin>;
X+ 	    last if $DBcmd =~ /^$/;
X+ 	    if ($DBcmd =~ /^q$/) {
X+ 		exit 0;
X+ 	    }
X+ 	    if ($DBcmd =~ /^h$/) {
X+ 		print "
X+ s		Single step.
X+ c		Continue.
X+ <CR>		Repeat last s or c.
X+ l min-max	List lines.
X+ l line		List line.
X+ l		List the whole program.
X+ L		List breakpoints.
X+ t		Toggle trace mode.
X+ b line		Set breakpoint.
X+ d line		Delete breakpoint.
X+ d		Delete breakpoint at this line.
X+ a line command	Set an action for this line.
X+ q		Quit.
X+ command		Execute as a perl statement.
X+ 
X+ ";
X+ 		next;
X+ 	    }
X+ 	    if ($DBcmd =~ /^t$/) {
X+ 		$DBtrace = !$DBtrace;
X+ 		print "Trace = $DBtrace\n";
X+ 		next;
X+ 	    }
X+ 	    if ($DBcmd =~ /^l (.*)[-,](.*)/) {
X+ 		for ($DBi = $1; $DBi <= $2; $DBi++) {
X+ 		    print "$DBi:\t", $DBline[$DBi], "\n";
X+ 		}
X+ 		next;
X+ 	    }
X+ 	    if ($DBcmd =~ /^l (.*)/) {
X+ 		print "$1:\t", $DBline[$1], "\n";
X+ 		next;
X+ 	    }
X+ 	    if ($DBcmd =~ /^l$/) {
X+ 		for ($DBi = 1; $DBi <= $DBmax ; $DBi++) {
X+ 		    print "$DBi:\t", $DBline[$DBi], "\n";
X+ 		}
X+ 		next;
X+ 	    }
X+ 	    if ($DBcmd =~ /^L$/) {
X+ 		for ($DBi = 1; $DBi <= $DBmax ; $DBi++) {
X+ 		    print "$DBi:\t", $DBline[$DBi], "\n" if $DBstop[$DBi];
X+ 		}
X+ 		next;
X+ 	    }
X+ 	    if ($DBcmd =~ /^b (.*)/) {
X+ 		$DBi = $1;
X+ 		if ($DBline[$DBi-1] =~ / $/) {
X+ 		    print "Line $DBi not breakable.\n";
X+ 		}
X+ 		else {
X+ 		    $DBstop[$DBi] = 1;
X+ 		}
X+ 		next;
X+ 	    }
X+ 	    if ($DBcmd =~ /^d (.*)/) {
X+ 		$DBstop[$1] = 0;
X+ 		next;
X+ 	    }
X+ 	    if ($DBcmd =~ /^d$/) {
X+ 		$DBstop[$DBline] = 0;
X+ 		next;
X+ 	    }
X+ 	    if ($DBcmd =~ /^a ([0-9]+)[ \t]+(.*)/) {
X+ 		$DBi = $1;
X+ 		$DBaction = $2;
X+ 		$DBaction .= ";" unless $DBaction =~ /[;}]$/;
X+ 		$DBaction[$DBi] = $DBaction;
X+ 		next;
X+ 	    }
X+ 	    if ($DBcmd =~ /^s$/) {
X+ 		$DBsingle = 1;
X+ 		last;
X+ 	    }
X+ 	    if ($DBcmd =~ /^c$/) {
X+ 		$DBsingle = 0;
X+ 		last;
X+ 	    }
X+ 	    chop($DBcmd);
X+ 	    $DBcmd .= ";" unless $DBcmd =~ /[;}]$/;
X+ 	    eval $DBcmd;
X+ 	    print $@,"\n";
X+ 	}
X+     }
X+     $\ = pop(@DB);
X+     $/ = pop(@DB);
X+     $, = pop(@DB);
X+     $[ = pop(@DB);
X+     $! = pop(@DB);
X+     $@ = pop(@DB);
X+     $. = pop(@DB);
X+ }
X+ 
X+ sub DBinit {
X+     $DBstop[$_[0]] = 1;
X+ ';
X+ print tmp "    \$0 = '$script';\n";
X+ print tmp "    \$DBmax = $.;\n";
X+ print tmp "    unlink '/tmp/pdb$$';\n";		# expected to fail on -o.
X+ for ($i = 1; $#script >= 0; $i++) {
X+     $_ = shift(@script);
X+     s/'/\\'/g;
X+     print tmp "    \$DBline[$i] = '$_';\n";
X+ }
X+ print tmp '}
X+ ';
X+ 
X+ close tmp;
X+ 
X+ # prepare to run the new script
X+ 
X+ unshift(@ARGV,$tmp);
X+ unshift(@ARGV,$switch) if $switch;
X+ unshift(@ARGV,$perl);
X+ exec @ARGV;
X+ 
X+ # This routine tokenizes one perl line good enough to tell what state we are
X+ # in by the end of the line, so we can tell if the next line should contain
X+ # a call to DB or not.
X+ 
X+ sub parse {
X+     until ($_ eq '') {
X+ 	$ord = ord($_);
X+ 	if ($quoting) {
X+ 	    if ($quote == $ord) {
X+ 		$quoting--;
X+ 	    }
X+ 	    s/^.//			if /^[\\]/;
X+ 	    s/^.//;
X+ 	    last if $_ eq "\n";
X+ 	    $state = 'term'		unless $quoting;
X+ 	    next;
X+ 	}
X+ 	if ($ord > 64) {
X+ 	    do quote(ord($1),1), next	if s/^m\b(.)//;
X+ 	    do quote(ord($1),2), next	if s/^s\b(.)//;
X+ 	    do quote(ord($1),2), next	if s/^y\b(.)//;
X+ 	    do quote(ord($1),2), next	if s/^tr\b(.)//;
X+ 	    next			if s/^[A-Za-z_][A-Za-z_0-9]*://;
X+ 	    $state = 'term', next	if s/^eof\b//;
X+ 	    $state = 'term', next	if s/^shift\b//;
X+ 	    $state = 'term', next	if s/^split\b//;
X+ 	    $state = 'term', next	if s/^tell\b//;
X+ 	    $state = 'term', next	if s/^write\b//;
X+ 	    $state = 'operator', next	if s/^[A-Za-z_][A-Za-z_0-9]*//;
X+ 	    $state = 'operator', next	if s/^[~^|]+//;
X+ 	    $state = 'statement', next	if s/^{//;
X+ 	    $state = 'statement', next	if s/^}[ \t]*$//;
X+ 	    $state = 'statement', next	if s/^}[ \t]*#/#/;
X+ 	    $state = 'term', next	if s/^}//;
X+ 	    $state = 'operator', next	if s/^\[//;
X+ 	    $state = 'term', next	if s/^]//;
X+ 	    die "Illegal character $_";
X+ 	}
X+ 	elsif ($ord < 33) {
X+ 	    next if s/[ \t\n]+//;
X+ 	    die "Illegal character $_";
X+ 	}
X+ 	else {
X+ 	    $state = 'statement', next	if s/^;//;
X+ 	    $state = 'term', next	if s/^\.[0-9eE]+//;
X+ 	    $state = 'term', next	if s/^[0-9][0-9xaAbBcCddeEfF.]*//;
X+ 	    $state = 'term', next	if s/^\$[A-Za-z_][A-Za-z_0-9]*//;
X+ 	    $state = 'term', next	if s/^\$.//;
X+ 	    $state = 'term', next	if s/^@[A-Za-z_][A-Za-z_0-9]*//;
X+ 	    $state = 'term', next	if s/^@.//;
X+ 	    $state = 'term', next	if s/^<[A-Za-z_0-9]*>//;
X+ 	    next			if s/^\+\+//;
X+ 	    next			if s/^--//;
X+ 	    $state = 'operator', next	if s/^[(!%&*-=+:,.<>]//;
X+ 	    $state = 'term', next	if s/^\)+//;
X+ 	    do quote($ord,1), next	if s/^'//;
X+ 	    do quote($ord,1), next	if s/^"//;
X+ 	    if (s|^[/?]||) {
X+ 		if ($state =~ /stat|oper/) {
X+ 		    $state = 'term';
X+ 		    do quote($ord,1), next;
X+ 		}
X+ 		$state = 'operator', next;
X+ 	    }
X+ 	    next			if s/^#.*//;
X+ 	}
X+     }
X+ }
X+ 
X+ sub quote {
X+     ($quote,$quoting) = @_;
X+     $state = 'quote';
X+ }
X 
XIndex: perldb.man
X*** perldb.man.old	Thu Jan 28 11:17:11 1988
X--- perldb.man	Thu Jan 28 11:17:12 1988
X***************
X*** 0 ****
X--- 1,119 ----
X+ .rn '' }`
X+ ''' $Header: perldb.man,v 1.0.1.1 88/01/28 10:28:19 root Exp $
X+ ''' 
X+ ''' $Log:	perldb.man,v $
X+ ''' Revision 1.0.1.1  88/01/28  10:28:19  root
X+ ''' patch8: created this file.
X+ ''' 
X+ ''' 
X+ .de Sh
X+ .br
X+ .ne 5
X+ .PP
X+ \fB\\$1\fR
X+ .PP
X+ ..
X+ .de Sp
X+ .if t .sp .5v
X+ .if n .sp
X+ ..
X+ .de Ip
X+ .br
X+ .ie \\n.$>=3 .ne \\$3
X+ .el .ne 3
X+ .IP "\\$1" \\$2
X+ ..
X+ '''
X+ '''     Set up \*(-- to give an unbreakable dash;
X+ '''     string Tr holds user defined translation string.
X+ '''     Bell System Logo is used as a dummy character.
X+ '''
X+ .tr \(bs-|\(bv\*(Tr
X+ .ie n \{\
X+ .ds -- \(bs-
X+ .if (\n(.H=4u)&(1m=24u) .ds -- \(bs\h'-12u'\(bs\h'-12u'-\" diablo 10 pitch
X+ .if (\n(.H=4u)&(1m=20u) .ds -- \(bs\h'-12u'\(bs\h'-8u'-\" diablo 12 pitch
X+ .ds L" ""
X+ .ds R" ""
X+ .ds L' '
X+ .ds R' '
X+ 'br\}
X+ .el\{\
X+ .ds -- \(em\|
X+ .tr \*(Tr
X+ .ds L" ``
X+ .ds R" ''
X+ .ds L' `
X+ .ds R' '
X+ 'br\}
X+ .TH PERLDB 1 LOCAL
X+ .SH NAME
X+ perldb - Perl Debugger
X+ .SH SYNOPSIS
X+ .B perldb [-o output] perlscript arguments
X+ .SH DESCRIPTION
X+ .I Perldb
X+ is a symbolic debugger for
X+ .I perl
X+ scripts.
X+ Run your script just as you normally would, only prepend \*(L"perldb\*(R" to
X+ the command.
X+ (On systems where #! doesn't work, put any perl switches into the #! line
X+ anyway\*(--perldb will pass them off to perl when it runs the script.)
X+ Perldb copies your script to a temporary file, instrumenting it in the process
X+ and adding a debugging monitor.
X+ It then executes the instrumented script for
X+ you and stops at the first statement so you can set any breakpoints or actions
X+ you desire.
X+ .PP
X+ There is only one switch: \-o, which tells perldb to put its temporary file
X+ in the filename you specify, and to refrain from deleting the file.
X+ Use this switch if you intend to rerun the instrumented script, or want to
X+ look at it for some reason.
X+ .PP
X+ These are the debugging commands:
X+ .Ip s 8
X+ Single step.
X+ Subsequent carriage returns will single step.
X+ .Ip c 8
X+ Continue.
X+ Turns off single step mode and runs till the next break point.
X+ Subsequent carriage returns will continue.
X+ .Ip <CR> 8
X+ Repeat last s or c.
X+ .Ip "l min-max" 8
X+ List lines in the indicated range.
X+ .Ip "l line" 8
X+ List indicated line.
X+ .Ip l 8
X+ List the whole program.
X+ .Ip L 8
X+ List breakpoints.
X+ .Ip t 8
X+ Toggle trace mode.
X+ .Ip "b line" 8
X+ Set breakpoint at indicated line.
X+ .Ip "d line" 8
X+ Delete breakpoint at indicated line.
X+ .Ip d 8
X+ Delete breakpoint at this line.
X+ .Ip "a line command" 8
X+ Set an action for indicated line.
X+ The command must be a valid perl command, except that a missing trailing ;
X+ will be supplied.
X+ .Ip q 8
X+ Quit.
X+ .Ip command 8
X+ Execute command as a perl statement.
X+ A missing trailing ; will be supplied if necessary.
X+ .SH ENVIRONMENT
X+ No environment variables are used by perldb.
X+ .SH AUTHOR
X+ Larry Wall <lwall@jpl-devvax.Jpl.Nasa.Gov>
X+ .SH FILES
X+ /tmp/pdb$$	temporary file for instrumented script
X+ .SH SEE ALSO
X+ perl	
X+ .SH DIAGNOSTICS
X+ .SH BUGS
X+ .rn }` ''
X 
XIndex: perly.c
XPrereq: 1.0.1.2
X*** perly.c.old	Thu Jan 28 11:17:22 1988
X--- perly.c	Thu Jan 28 11:17:25 1988
X***************
X*** 1,6 ****
X! char rcsid[] = "$Header: perly.c,v 1.0.1.2 88/01/24 00:06:03 root Exp $";
X  /*
X   * $Log:	perly.c,v $
X   * Revision 1.0.1.2  88/01/24  00:06:03  root
X   * patch 2: s/(abc)/\1/ grandfathering didn't work right.
X   * 
X--- 1,9 ----
X! char rcsid[] = "$Header: perly.c,v 1.0.1.3 88/01/28 10:28:31 root Exp $";
X  /*
X   * $Log:	perly.c,v $
X+  * Revision 1.0.1.3  88/01/28  10:28:31  root
X+  * patch8: added eval operator.  Also fixed expectterm following right curly.
X+  * 
X   * Revision 1.0.1.2  88/01/24  00:06:03  root
X   * patch 2: s/(abc)/\1/ grandfathering didn't work right.
X   * 
X***************
X*** 16,21 ****
X--- 19,25 ----
X  bool assume_n = FALSE;
X  bool assume_p = FALSE;
X  bool doswitches = FALSE;
X+ bool allstabs = FALSE;		/* init all customary symbols in symbol table?*/
X  char *filename;
X  char *e_tmpname = "/tmp/perl-eXXXXXX";
X  FILE *e_fp = Nullfp;
X***************
X*** 161,172 ****
X  	    str_numset(stabent(argv[0]+1,TRUE)->stab_val,(double)1.0);
X  	}
X      }
X!     if (argvstab = stabent("ARGV",FALSE)) {
X  	for (; argc > 0; argc--,argv++) {
X  	    apush(argvstab->stab_array,str_make(argv[0]));
X  	}
X      }
X!     if (envstab = stabent("ENV",FALSE)) {
X  	for (; *env; env++) {
X  	    if (!(s = index(*env,'=')))
X  		continue;
X--- 165,176 ----
X  	    str_numset(stabent(argv[0]+1,TRUE)->stab_val,(double)1.0);
X  	}
X      }
X!     if (argvstab = stabent("ARGV",allstabs)) {
X  	for (; argc > 0; argc--,argv++) {
X  	    apush(argvstab->stab_array,str_make(argv[0]));
X  	}
X      }
X!     if (envstab = stabent("ENV",allstabs)) {
X  	for (; *env; env++) {
X  	    if (!(s = index(*env,'=')))
X  		continue;
X***************
X*** 177,188 ****
X  	    *--s = '=';
X  	}
X      }
X!     sigstab = stabent("SIG",FALSE);
X  
X      magicalize("!#?^~=-%0123456789.+&*(),\\/[|");
X  
X!     (tmpstab = stabent("0",FALSE)) && str_set(STAB_STR(tmpstab),filename);
X!     (tmpstab = stabent("$",FALSE)) &&
X  	str_numset(STAB_STR(tmpstab),(double)getpid());
X  
X      tmpstab = stabent("stdin",TRUE);
X--- 181,192 ----
X  	    *--s = '=';
X  	}
X      }
X!     sigstab = stabent("SIG",allstabs);
X  
X      magicalize("!#?^~=-%0123456789.+&*(),\\/[|");
X  
X!     (tmpstab = stabent("0",allstabs)) && str_set(STAB_STR(tmpstab),filename);
X!     (tmpstab = stabent("$",allstabs)) &&
X  	str_numset(STAB_STR(tmpstab),(double)getpid());
X  
X      tmpstab = stabent("stdin",TRUE);
X***************
X*** 198,203 ****
X--- 202,209 ----
X      tmpstab = stabent("stderr",TRUE);
X      tmpstab->stab_io = stio_new();
X      tmpstab->stab_io->fp = stderr;
X+     safefree(filename);
X+     filename = "(eval)";
X  
X      setjmp(top_env);	/* sets goto_targ on longjump */
X  
X***************
X*** 225,231 ****
X  
X      sym[1] = '\0';
X      while (*sym = *list++) {
X! 	if (stab = stabent(sym,FALSE)) {
X  	    stab->stab_flags = SF_VMAGIC;
X  	    stab->stab_val->str_link.str_magic = stab;
X  	}
X--- 231,237 ----
X  
X      sym[1] = '\0';
X      while (*sym = *list++) {
X! 	if (stab = stabent(sym,allstabs)) {
X  	    stab->stab_flags = SF_VMAGIC;
X  	    stab->stab_val->str_link.str_magic = stab;
X  	}
X***************
X*** 322,328 ****
X  	    filename = savestr(s);
X  	    s = str_get(linestr);
X  	}
X! 	*s = '\0';
X  	if (lex_newlines)
X  	    RETURN('\n');
X  	goto retry;
X--- 328,342 ----
X  	    filename = savestr(s);
X  	    s = str_get(linestr);
X  	}
X! 	if (in_eval) {
X! 	    while (*s && *s != '\n')
X! 		s++;
X! 	    if (*s)
X! 		s++;
X! 	    line++;
X! 	}
X! 	else
X! 	    *s = '\0';
X  	if (lex_newlines)
X  	    RETURN('\n');
X  	goto retry;
X***************
X*** 350,358 ****
X  	OPERATOR(tmp);
X      case ')':
X      case ']':
X-     case '}':
X  	tmp = *s++;
X  	TERM(tmp);
X      case '&':
X  	s++;
X  	tmp = *s++;
X--- 364,378 ----
X  	OPERATOR(tmp);
X      case ')':
X      case ']':
X  	tmp = *s++;
X  	TERM(tmp);
X+     case '}':
X+ 	tmp = *s++;
X+ 	for (d = s; *d == ' ' || *d == '\t'; d++) ;
X+ 	if (*d == '\n' || *d == '#')
X+ 	    OPERATOR(tmp);		/* block end */
X+ 	else
X+ 	    TERM(tmp);			/* associative array end */
X      case '&':
X  	s++;
X  	tmp = *s++;
X***************
X*** 508,513 ****
X--- 528,537 ----
X  	    OPERATOR(SEQ);
X  	if (strEQ(d,"exit"))
X  	    UNI(O_EXIT);
X+ 	if (strEQ(d,"eval")) {
X+ 	    allstabs = TRUE;		/* must initialize everything since */
X+ 	    UNI(O_EVAL);		/* we don't know what will be used */
X+ 	}
X  	if (strEQ(d,"eof"))
X  	    TERM(FEOF);
X  	if (strEQ(d,"exp"))
X***************
X*** 1480,1487 ****
X  	strcpy(tname,"^?");
X      else
X  	sprintf(tname,"%c",yychar);
X!     printf("%s in file %s at line %d, next token \"%s\"\n",
X        s,filename,line,tname);
X  }
X  
X  char *
X--- 1504,1515 ----
X  	strcpy(tname,"^?");
X      else
X  	sprintf(tname,"%c",yychar);
X!     sprintf(tokenbuf, "%s in file %s at line %d, next token \"%s\"\n",
X        s,filename,line,tname);
X+     if (in_eval)
X+ 	str_set(stabent("@",TRUE)->stab_val,tokenbuf);
X+     else
X+ 	fputs(tokenbuf,stderr);
X  }
X  
X  char *
X***************
X*** 1964,1970 ****
X  	    str_numset(str, (double)str_len(s1));
X  	    break;
X  	case O_SUBSTR:
X! 	    if (arg[3].arg_type != A_SINGLE || stabent("[",FALSE)) {
X  		str_free(str);		/* making the fallacious assumption */
X  		str = Nullstr;		/* that any $[ occurs before substr()*/
X  	    }
X--- 1992,1998 ----
X  	    str_numset(str, (double)str_len(s1));
X  	    break;
X  	case O_SUBSTR:
X! 	    if (arg[3].arg_type != A_SINGLE || stabent("[",allstabs)) {
X  		str_free(str);		/* making the fallacious assumption */
X  		str = Nullstr;		/* that any $[ occurs before substr()*/
X  	    }
X***************
X*** 2463,2466 ****
X--- 2491,2619 ----
X      bufptr = str_get(linestr);
X      yyerror("Format not terminated");
X      return froot.f_next;
X+ }
X+ 
X+ STR *
X+ do_eval(str)
X+ STR *str;
X+ {
X+     int retval;
X+     CMD *myroot;
X+ 
X+     in_eval++;
X+     str_set(stabent("@",TRUE)->stab_val,"");
X+     line = 1;
X+     str_sset(linestr,str);
X+     bufptr = str_get(linestr);
X+     if (setjmp(eval_env))
X+ 	retval = 1;
X+     else
X+ 	retval = yyparse();
X+     myroot = eval_root;		/* in case cmd_exec does another eval! */
X+     if (retval)
X+ 	str = &str_no;
X+     else {
X+ 	str = cmd_exec(eval_root);
X+ 	cmd_free(myroot);	/* can't free on error, for some reason */
X+     }
X+     in_eval--;
X+     return str;
X+ }
X+ 
X+ cmd_free(cmd)
X+ register CMD *cmd;
X+ {
X+     register CMD *tofree;
X+     register CMD *head = cmd;
X+ 
X+     while (cmd) {
X+ 	if (cmd->c_label)
X+ 	    safefree(cmd->c_label);
X+ 	if (cmd->c_first)
X+ 	    str_free(cmd->c_first);
X+ 	if (cmd->c_spat)
X+ 	    spat_free(cmd->c_spat);
X+ 	if (cmd->c_expr)
X+ 	    arg_free(cmd->c_expr);
X+ 	switch (cmd->c_type) {
X+ 	case C_WHILE:
X+ 	case C_BLOCK:
X+ 	case C_IF:
X+ 	    if (cmd->ucmd.ccmd.cc_true)
X+ 		cmd_free(cmd->ucmd.ccmd.cc_true);
X+ 	    if (cmd->c_type == C_IF && cmd->ucmd.ccmd.cc_alt)
X+ 		cmd_free(cmd->ucmd.ccmd.cc_alt,Nullcmd);
X+ 	    break;
X+ 	case C_EXPR:
X+ 	    if (cmd->ucmd.acmd.ac_stab)
X+ 		arg_free(cmd->ucmd.acmd.ac_stab);
X+ 	    if (cmd->ucmd.acmd.ac_expr)
X+ 		arg_free(cmd->ucmd.acmd.ac_expr);
X+ 	    break;
X+ 	}
X+ 	tofree = cmd;
X+ 	cmd = cmd->c_next;
X+ 	safefree((char*)tofree);
X+ 	if (cmd && cmd == head)		/* reached end of while loop */
X+ 	    break;
X+     }
X+ }
X+ 
X+ arg_free(arg)
X+ register ARG *arg;
X+ {
X+     register int i;
X+ 
X+     for (i = 1; i <= arg->arg_len; i++) {
X+ 	switch (arg[i].arg_type) {
X+ 	case A_NULL:
X+ 	    break;
X+ 	case A_LEXPR:
X+ 	case A_EXPR:
X+ 	    arg_free(arg[i].arg_ptr.arg_arg);
X+ 	    break;
X+ 	case A_CMD:
X+ 	    cmd_free(arg[i].arg_ptr.arg_cmd);
X+ 	    break;
X+ 	case A_STAB:
X+ 	case A_LVAL:
X+ 	case A_READ:
X+ 	case A_ARYLEN:
X+ 	    break;
X+ 	case A_SINGLE:
X+ 	case A_DOUBLE:
X+ 	case A_BACKTICK:
X+ 	    str_free(arg[i].arg_ptr.arg_str);
X+ 	    break;
X+ 	case A_SPAT:
X+ 	    spat_free(arg[i].arg_ptr.arg_spat);
X+ 	    break;
X+ 	case A_NUMBER:
X+ 	    break;
X+ 	}
X+     }
X+     free_arg(arg);
X+ }
X+ 
X+ spat_free(spat)
X+ register SPAT *spat;
X+ {
X+     register SPAT *sp;
X+ 
X+     if (spat->spat_runtime)
X+ 	arg_free(spat->spat_runtime);
X+     if (spat->spat_repl) {
X+ 	arg_free(spat->spat_repl);
X+     }
X+     free_compex(&spat->spat_compex);
X+ 
X+     /* now unlink from spat list */
X+     if (spat_root == spat)
X+ 	spat_root = spat->spat_next;
X+     else {
X+ 	for (sp = spat_root; sp->spat_next != spat; sp = sp->spat_next) ;
X+ 	sp->spat_next = spat->spat_next;
X+     }
X+ 
X+     safefree((char*)spat);
X  }
X 
XIndex: search.c
XPrereq: 1.0.1.1
X*** search.c.old	Thu Jan 28 11:17:36 1988
X--- search.c	Thu Jan 28 11:17:37 1988
X***************
X*** 1,6 ****
X! /* $Header: search.c,v 1.0.1.1 88/01/24 03:55:05 root Exp $
X   *
X   * $Log:	search.c,v $
X   * Revision 1.0.1.1  88/01/24  03:55:05  root
X   * patch 2: made depend on perl.h.
X   * 
X--- 1,9 ----
X! /* $Header: search.c,v 1.0.1.2 88/01/28 10:30:46 root Exp $
X   *
X   * $Log:	search.c,v $
X+  * Revision 1.0.1.2  88/01/28  10:30:46  root
X+  * patch8: uncommented free_compex for use with eval operator.
X+  * 
X   * Revision 1.0.1.1  88/01/24  03:55:05  root
X   * patch 2: made depend on perl.h.
X   * 
X***************
X*** 107,113 ****
X      compex->subbase = Nullch;
X  }
X  
X- #ifdef NOTUSED
X  void
X  free_compex(compex)
X  register COMPEX *compex;
X--- 110,115 ----
X***************
X*** 121,127 ****
X  	compex->subbase = Nullch;
X      }
X  }
X- #endif
X  
X  static char *gbr_str = Nullch;
X  static int gbr_siz = 0;
X--- 123,128 ----
X 
XIndex: stab.c
XPrereq: 1.0
X*** stab.c.old	Thu Jan 28 11:17:44 1988
X--- stab.c	Thu Jan 28 11:17:45 1988
X***************
X*** 1,6 ****
X! /* $Header: stab.c,v 1.0 87/12/18 13:06:14 root Exp $
X   *
X   * $Log:	stab.c,v $
X   * Revision 1.0  87/12/18  13:06:14  root
X   * Initial revision
X   * 
X--- 1,9 ----
X! /* $Header: stab.c,v 1.0.1.1 88/01/28 10:35:17 root Exp $
X   *
X   * $Log:	stab.c,v $
X+  * Revision 1.0.1.1  88/01/28  10:35:17  root
X+  * patch8: changed some stabents to support eval operator.
X+  * 
X   * Revision 1.0  87/12/18  13:06:14  root
X   * Initial revision
X   * 
X***************
X*** 169,180 ****
X  	case '^':
X  	    safefree(curoutstab->stab_io->top_name);
X  	    curoutstab->stab_io->top_name = str_get(str);
X! 	    curoutstab->stab_io->top_stab = stabent(str_get(str),FALSE);
X  	    break;
X  	case '~':
X  	    safefree(curoutstab->stab_io->fmt_name);
X  	    curoutstab->stab_io->fmt_name = str_get(str);
X! 	    curoutstab->stab_io->fmt_stab = stabent(str_get(str),FALSE);
X  	    break;
X  	case '=':
X  	    curoutstab->stab_io->page_len = (long)str_gnum(str);
X--- 172,183 ----
X  	case '^':
X  	    safefree(curoutstab->stab_io->top_name);
X  	    curoutstab->stab_io->top_name = str_get(str);
X! 	    curoutstab->stab_io->top_stab = stabent(str_get(str),TRUE);
X  	    break;
X  	case '~':
X  	    safefree(curoutstab->stab_io->fmt_name);
X  	    curoutstab->stab_io->fmt_name = str_get(str);
X! 	    curoutstab->stab_io->fmt_stab = stabent(str_get(str),TRUE);
X  	    break;
X  	case '=':
X  	    curoutstab->stab_io->page_len = (long)str_gnum(str);
X***************
X*** 274,280 ****
X      ARRAY *savearray;
X      STR *str;
X  
X!     stab = stabent(str_get(hfetch(sigstab->stab_hash,sig_name[sig])),FALSE);
X      savearray = defstab->stab_array;
X      defstab->stab_array = anew();
X      str = str_new(0);
X--- 277,283 ----
X      ARRAY *savearray;
X      STR *str;
X  
X!     stab = stabent(str_get(hfetch(sigstab->stab_hash,sig_name[sig])),TRUE);
X      savearray = defstab->stab_array;
X      defstab->stab_array = anew();
X      str = str_new(0);
X 
XIndex: util.c
XPrereq: 1.0
X*** util.c.old	Thu Jan 28 11:18:10 1988
X--- util.c	Thu Jan 28 11:18:10 1988
X***************
X*** 1,6 ****
X! /* $Header: util.c,v 1.0 87/12/18 13:06:30 root Exp $
X   *
X   * $Log:	util.c,v $
X   * Revision 1.0  87/12/18  13:06:30  root
X   * Initial revision
X   * 
X--- 1,9 ----
X! /* $Header: util.c,v 1.0.1.1 88/01/28 11:06:35 root Exp $
X   *
X   * $Log:	util.c,v $
X+  * Revision 1.0.1.1  88/01/28  11:06:35  root
X+  * patch8: changed fatal() to support eval operator with exiting.
X+  * 
X   * Revision 1.0  87/12/18  13:06:30  root
X   * Initial revision
X   * 
X***************
X*** 205,210 ****
X--- 208,218 ----
X      extern FILE *e_fp;
X      extern char *e_tmpname;
X  
X+     if (in_eval) {
X+ 	sprintf(tokenbuf,pat,a1,a2,a3,a4);
X+ 	str_set(stabent("@",TRUE)->stab_val,tokenbuf);
X+ 	longjmp(eval_env,1);
X+     }
X      fprintf(stderr,pat,a1,a2,a3,a4);
X      if (e_fp)
X  	UNLINK(e_tmpname);
X 
XIndex: x2p/walk.c
XPrereq: 1.0
X*** x2p/walk.c.old	Thu Jan 28 11:18:25 1988
X--- x2p/walk.c	Thu Jan 28 11:18:26 1988
X***************
X*** 1,6 ****
X! /* $Header: walk.c,v 1.0 87/12/18 13:07:40 root Exp $
X   *
X   * $Log:	walk.c,v $
X   * Revision 1.0  87/12/18  13:07:40  root
X   * Initial revision
X   * 
X--- 1,9 ----
X! /* $Header: walk.c,v 1.0.1.1 88/01/28 11:07:56 root Exp $
X   *
X   * $Log:	walk.c,v $
X+  * Revision 1.0.1.1  88/01/28  11:07:56  root
X+  * patch8: changed some misleading comments.
X+  * 
X   * Revision 1.0  87/12/18  13:07:40  root
X   * Initial revision
X   * 
X***************
X*** 68,80 ****
X  	    str_cat(str,"';\t\t# field separator from -F switch\n");
X  	}
X  	else if (saw_FS && !const_FS) {
X! 	    str_cat(str,"$FS = '[ \\t\\n]+';\t\t# default field separator\n");
X  	}
X  	if (saw_OFS) {
X! 	    str_cat(str,"$, = ' ';\t\t# default output field separator\n");
X  	}
X  	if (saw_ORS) {
X! 	    str_cat(str,"$\\ = \"\\n\";\t\t# default output record separator\n");
X  	}
X  	if (str->str_cur > 20)
X  	    str_cat(str,"\n");
X--- 71,83 ----
X  	    str_cat(str,"';\t\t# field separator from -F switch\n");
X  	}
X  	else if (saw_FS && !const_FS) {
X! 	    str_cat(str,"$FS = '[ \\t\\n]+';\t\t# set field separator\n");
X  	}
X  	if (saw_OFS) {
X! 	    str_cat(str,"$, = ' ';\t\t# set output field separator\n");
X  	}
X  	if (saw_ORS) {
X! 	    str_cat(str,"$\\ = \"\\n\";\t\t# set output record separator\n");
X  	}
X  	if (str->str_cur > 20)
X  	    str_cat(str,"\n");
END_OF_FILE
if test 35848 -ne `wc -c <'patch8'`; then
    echo shar: \"'patch8'\" unpacked with wrong size!
fi
# end of 'patch8'
fi
if test -f 'patch9' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch9'\"
else
echo shar: Extracting \"'patch9'\" \(6348 characters\)
sed "s/^X//" >'patch9' <<'END_OF_FILE'
XPath: bbn.com!bbn!husc6!hao!ames!elroy!devvax!lroot
XFrom: lroot@devvax.JPL.NASA.GOV (The Superuser)
XNewsgroups: comp.sources.bugs
XSubject: perl 1.0 patch #9
XSummary: This is an official patch for perl 1.0.  Please apply it.
XMessage-ID: <1187@devvax.JPL.NASA.GOV>
XDate: 30 Jan 88 17:16:02 GMT
XOrganization: Jet Propulsion Laboratory, Pasadena, CA
XLines: 198
X
XSystem: perl version 1.0
XPatch #: 9
XPriority: HIGH for SysV sites
XSubject: 3 portability problems
XFrom: pttesac!Marnix!vanam (Marnix (ain't unix!) A.  van\ Ammers)
X
XDescription:
X	There's a #define YYDEBUG; in perl.h that ought to be
X	#define YYDEBUG 1.  Interesting that it works the former way on
X	any systems at all.
X
X	Patch 2 was defective and introduced a couple of lines with missing
X	right parens.  Learn something old every day...
X
X	Some awks can't handle
X	    awk '$6 != "" {print substr($6,2,100)}' </tmp/Cppsym2$$ ;;
X	if field 6 doesn't exist.  Changed conditional to NF > 5.
X
X	There was also a problem that I fixed in metaconfig that involved
X	Configure grepping .SH files out of MANIFEST when the .SH was only
X	in the commentary.  This doesn't affect perl's Configure because
X	there aren't any comments containing .SH in the MANIFEST file.
X	But that's the nice thing about metaconfig--you generate a new
X	Configure script and also get the changes you don't need (yet).
X
XFix:	From rn, say "| patch -d DIR", where DIR is your perl source
X	directory.  Outside of rn, say "cd DIR; patch <thisarticle".
X	If you don't have the patch program, apply the following by hand,
X	or get patch.
X
X	If patch indicates that patchlevel is the wrong version, you may need
X	to apply one or more previous patches, or the patch may already
X	have been applied.  See the patchlevel.h file to find out what has or
X	has not been applied.  In any event, don't continue with the patch.
X
X	If you are missing previous patches they can be obtained from me:
X
X	Larry Wall
X	lwall@jpl-devvax.jpl.nasa.gov
X
X	If you send a mail message of the following form it will greatly speed
X	processing:
X
X	Subject: Command
X	@SH mailpatch PATH perl 1.0 LIST
X		   ^ note the c
X
X	where PATH is a return path FROM ME TO YOU in Internet notation, and
X	LIST is the number of one or more patches you need, separated by spaces,
X	commas, and/or hyphens.  Saying 35- says everything from 35 to the end.
X
X	You can also get the patches via anonymous FTP from
X	jpl-devvax.jpl.nasa.gov (128.149.8.43).
X
XIndex: patchlevel.h
XPrereq: 8
X1c1
X< #define PATCHLEVEL 8
X---
X> #define PATCHLEVEL 9
X 
XIndex: Configure
XPrereq: 1.0.1.3
X*** Configure.old	Sat Jan 30 08:57:50 1988
X--- Configure	Sat Jan 30 08:57:54 1988
X***************
X*** 8,14 ****
X  # and edit it to reflect your system.  Some packages may include samples
X  # of config.h for certain machines, so you might look for one of those.)
X  #
X! # $Header: Configure,v 1.0.1.3 88/01/26 14:14:14 root Exp $
X  #
X  # Yes, you may rip this off to use in other distribution packages.
X  # (Note: this Configure script was generated automatically.  Rather than
X--- 8,14 ----
X  # and edit it to reflect your system.  Some packages may include samples
X  # of config.h for certain machines, so you might look for one of those.)
X  #
X! # $Header: Configure,v 1.0.1.4 88/01/30 08:51:49 root Exp $
X  #
X  # Yes, you may rip this off to use in other distribution packages.
X  # (Note: this Configure script was generated automatically.  Rather than
X***************
X*** 998,1004 ****
X  echo exit 1 >>/tmp/Cppsym\$\$
X  $cpp $cppminus </tmp/Cppsym\$\$ >/tmp/Cppsym2\$\$
X  case "\$list" in
X! true) awk '\$6 != "" {print substr(\$6,2,100)}' </tmp/Cppsym2\$\$ ;;
X  *)
X      sh /tmp/Cppsym2\$\$
X      status=\$?
X--- 998,1004 ----
X  echo exit 1 >>/tmp/Cppsym\$\$
X  $cpp $cppminus </tmp/Cppsym\$\$ >/tmp/Cppsym2\$\$
X  case "\$list" in
X! true) awk 'NF > 5 {print substr(\$6,2,100)}' </tmp/Cppsym2\$\$ ;;
X  *)
X      sh /tmp/Cppsym2\$\$
X      status=\$?
X***************
X*** 1379,1385 ****
X  
X  echo " "
X  echo "Doing variable substitutions on .SH files..."
X! set x `$grep '\.SH' <MANIFEST | awk '{print $1}'`
X  shift
X  case $# in
X  0) set x *.SH; shift;;
X--- 1379,1385 ----
X  
X  echo " "
X  echo "Doing variable substitutions on .SH files..."
X! set x `awk '{print $1}' <MANIFEST | $grep '\.SH'`
X  shift
X  case $# in
X  0) set x *.SH; shift;;
X 
XIndex: arg.c
XPrereq: 1.0.1.4
X*** arg.c.old	Sat Jan 30 08:58:14 1988
X--- arg.c	Sat Jan 30 08:58:19 1988
X***************
X*** 1,6 ****
X! /* $Header: arg.c,v 1.0.1.4 88/01/28 10:22:06 root Exp $
X   *
X   * $Log:	arg.c,v $
X   * Revision 1.0.1.4  88/01/28  10:22:06  root
X   * patch8: added eval operator.
X   * 
X--- 1,9 ----
X! /* $Header: arg.c,v 1.0.1.5 88/01/30 08:53:16 root Exp $
X   *
X   * $Log:	arg.c,v $
X+  * Revision 1.0.1.5  88/01/30  08:53:16  root
X+  * patch9: fixed some missing right parens introduced (?) by patch 2
X+  * 
X   * Revision 1.0.1.4  88/01/28  10:22:06  root
X   * patch8: added eval operator.
X   * 
X***************
X*** 552,559 ****
X  	    apush(ary,str_nmake((double)statbuf.st_blksize));
X  	    apush(ary,str_nmake((double)statbuf.st_blocks));
X  #else
X! 	    apush(ary,str_make("");
X! 	    apush(ary,str_make("");
X  #endif
X  	}
X  	sarg = (STR**)safemalloc((max+2)*sizeof(STR*));
X--- 555,562 ----
X  	    apush(ary,str_nmake((double)statbuf.st_blksize));
X  	    apush(ary,str_nmake((double)statbuf.st_blocks));
X  #else
X! 	    apush(ary,str_make(""));
X! 	    apush(ary,str_make(""));
X  #endif
X  	}
X  	sarg = (STR**)safemalloc((max+2)*sizeof(STR*));
X 
XIndex: perl.h
XPrereq: 1.0.1.3
X*** perl.h.old	Sat Jan 30 08:58:36 1988
X--- perl.h	Sat Jan 30 08:58:36 1988
X***************
X*** 1,6 ****
X! /* $Header: perl.h,v 1.0.1.3 88/01/28 10:24:17 root Exp $
X   *
X   * $Log:	perl.h,v $
X   * Revision 1.0.1.3  88/01/28  10:24:17  root
X   * patch8: added eval operator.
X   * 
X--- 1,9 ----
X! /* $Header: perl.h,v 1.0.1.4 88/01/30 08:54:00 root Exp $
X   *
X   * $Log:	perl.h,v $
X+  * Revision 1.0.1.4  88/01/30  08:54:00  root
X+  * patch9: changed #define YYDEBUG; to #define YYDEBUG 1
X+  * 
X   * Revision 1.0.1.3  88/01/28  10:24:17  root
X   * patch8: added eval operator.
X   * 
X***************
X*** 184,190 ****
X  EXT int dlevel INIT(0);
X  EXT char debname[40];
X  EXT char debdelim[40];
X! #define YYDEBUG;
X  extern int yydebug;
X  #endif
X  
X--- 187,193 ----
X  EXT int dlevel INIT(0);
X  EXT char debname[40];
X  EXT char debdelim[40];
X! #define YYDEBUG 1
X  extern int yydebug;
X  #endif
X  
END_OF_FILE
if test 6348 -ne `wc -c <'patch9'`; then
    echo shar: \"'patch9'\" unpacked with wrong size!
fi
# end of 'patch9'
fi
if test -f 'patch10' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch10'\"
else
echo shar: Extracting \"'patch10'\" \(3233 characters\)
sed "s/^X//" >'patch10' <<'END_OF_FILE'
XPath: bbn.com!bbn!husc6!rutgers!ames!elroy!devvax!lroot
XFrom: lroot@devvax.JPL.NASA.GOV (The Superuser)
XNewsgroups: comp.sources.bugs
XSubject: perl 1.0 patch #10
XSummary: This is an official patch for perl 1.0.  Please apply it.
XMessage-ID: <1188@devvax.JPL.NASA.GOV>
XDate: 30 Jan 88 17:25:46 GMT
XOrganization: Jet Propulsion Laboratory, Pasadena, CA
XLines: 84
X
XSystem: perl version 1.0
XPatch #: 10
XPriority: LOW
XSubject: if your libc is in a strange place, Configure blows up
XFrom: Peter E. Yee <yee@trident.arc.nasa.gov>
X
XDescription:
X	There's a line in Configure that says libc=ans which should say
X	libc=$ans.  This only shows up if libc.a isn't in /lib.
X
XFix:	From rn, say "| patch -d DIR", where DIR is your perl source
X	directory.  Outside of rn, say "cd DIR; patch <thisarticle".
X	If you don't have the patch program, apply the following by hand,
X	or get patch.
X
X	If patch indicates that patchlevel is the wrong version, you may need
X	to apply one or more previous patches, or the patch may already
X	have been applied.  See the patchlevel.h file to find out what has or
X	has not been applied.  In any event, don't continue with the patch.
X
X	If you are missing previous patches they can be obtained from me:
X
X	Larry Wall
X	lwall@jpl-devvax.jpl.nasa.gov
X
X	If you send a mail message of the following form it will greatly speed
X	processing:
X
X	Subject: Command
X	@SH mailpatch PATH perl 1.0 LIST
X		   ^ note the c
X
X	where PATH is a return path FROM ME TO YOU in Internet notation, and
X	LIST is the number of one or more patches you need, separated by spaces,
X	commas, and/or hyphens.  Saying 35- says everything from 35 to the end.
X
X	You can also get the patches via anonymous FTP from
X	jpl-devvax.jpl.nasa.gov (128.149.8.43).
X
XIndex: patchlevel.h
XPrereq: 9
X1c1
X< #define PATCHLEVEL 9
X---
X> #define PATCHLEVEL 10
X 
XIndex: Configure
XPrereq: 1.0.1.4
X*** Configure.old	Sat Jan 30 09:22:10 1988
X--- Configure	Sat Jan 30 09:22:13 1988
X***************
X*** 8,14 ****
X  # and edit it to reflect your system.  Some packages may include samples
X  # of config.h for certain machines, so you might look for one of those.)
X  #
X! # $Header: Configure,v 1.0.1.4 88/01/30 08:51:49 root Exp $
X  #
X  # Yes, you may rip this off to use in other distribution packages.
X  # (Note: this Configure script was generated automatically.  Rather than
X--- 8,14 ----
X  # and edit it to reflect your system.  Some packages may include samples
X  # of config.h for certain machines, so you might look for one of those.)
X  #
X! # $Header: Configure,v 1.0.1.5 88/01/30 09:21:20 root Exp $
X  #
X  # Yes, you may rip this off to use in other distribution packages.
X  # (Note: this Configure script was generated automatically.  Rather than
X***************
X*** 398,404 ****
X      ans=`loc libc.a blurfl/dyick $libpth`
X      if test -f $ans; then
X  	echo "Your C library is in $ans, of all places."
X! 	libc=ans
X      else
X  	if test -f "$libc"; then
X  	    echo "Your C library is in $libc, like you said before."
X--- 398,404 ----
X      ans=`loc libc.a blurfl/dyick $libpth`
X      if test -f $ans; then
X  	echo "Your C library is in $ans, of all places."
X! 	libc=$ans
X      else
X  	if test -f "$libc"; then
X  	    echo "Your C library is in $libc, like you said before."
END_OF_FILE
if test 3233 -ne `wc -c <'patch10'`; then
    echo shar: \"'patch10'\" unpacked with wrong size!
fi
# end of 'patch10'
fi
echo shar: End of shell archive.
exit 0
