Subject:  v13i069:  Nroff driver table utility
Newsgroups: comp.sources.unix,comp.text
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: utzoo!bnr-vpa!bruce
Posting-number: Volume 13, Issue 69
Archive-name: nroff-driver


	What follows is a shar of the latest version of my nroff driver
table facility, which has been used in two previous incarnations by a
core group of die-hard nroff users.  This version fixes some bugs, adds
some functionality, and accomodates HP's latest perversion of nroff.

Bruce Townsend (bnr-vpa!bruce)	Phone:	(613) 726-3008
Bell-Northern Research		Usenet: {utzoo, utcs}!bnr-vpa!bruce
P.O. Box 3511, Station C, Ottawa, Ontario, Canada, K1Y 4H7

#!/bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #!/bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	README
#	Makefile
#	table.5
#	elbat.c
#	table.c
#	table.h
#	tabljet.c
export PATH; PATH=/bin:$PATH
echo shar: extracting "'README'" '(4429 characters)'
if test -f 'README'
then
	echo shar: over-writing existing file "'README'"
fi
sed 's/^X//' << \SHAR_EOF > 'README'
X	Nroff Driver Table Compiler/De-compiler Utility
X	-----------------------------------------------
X
X	There are two programs in this package.  Table compiles an
Xnroff terminal driver table from source, and elbat, the inverse
Xoperator, de-compiles an existing formatted table to produce a
Xsource.  There is also a sample driver source, kindly provided by
XBo Thide', for the HP LaserJet+ using a Math Elite font cartridge.
XA man page, a Makefile, and this README file are also provided.
X
X	This is version 2.0 of the table utility, superceding versions
X1.1 and 1.2.  New features of version 2.0 are:
X-  Support for Kanji characters.  There is a new element in the table
X   called Kchar.  This is a feature of HP's latest release for their
X   9000 series computers.
X-  A better Makefile.
X-  A -d debug option for elbat.
X-  The compiled table should now be bit-for-bit identical to that
X   supplied with your system, given the same source file.  To test this,
X   decompile a supplied tabfile with elbat, recompile the resultant
X   source, and cmp the result with the supplied tabfile.  This is true
X   at least for the files on my system (HP9000 series 520, HPUX 5.2)
X-  Several bugs fixed.
X-  A man page, table.5
X
X	Sources for the tab files are in 'C', and consist simply of
Xan initialized structure.  This structure is compiled and linked to
Xthe main program module, table.o (compiled from table.c), to
Xproduce an executable a.out file.  This file when executed produces
Xthe compiled tab file.
X	A Makefile is provided to formalize this procedure.  The
Xsources for the various terminals (all files named tabXXXX.c, where
XXXXX is replaced by a short acronym for the terminal: e.g. tab450.c)
Xare included the the SOURCES definition in the Makefile.  Typing
X"make" or "make all" compiles these sources, and runs the executable
Xa.out files to produce the compiled tab files, calling them tabXXXX.tab.
XTyping "make install" renames the tabXXXX.tab files to tabXXXX, and
Xcopies them to the /usr/lib/term directory, where nroff will find
Xthem when the -TXXXX option is used.
X	Typing "make elbat" makes the elbat program, which can take
Xa compiled tabXXXX file and produce a source tabXXXX.c file.  Using
Xthe -d (debug) option with elbat produces a dump of the actual
Xcharacter data in the file.
X	Be VERY CAREFUL with "make install" (try "make -n install
Xfirst).  You don't likely want to delete system-supplied tab files!
X
X	The table.5 man page contains more information.
X
XIF YOU HAVE PROBLEMS...
X	It is quite possible that the tab file format on your machine
Xdiffers in minor or major ways from that embodied by this utility.  Since
Xthe tabfile format was inferred from careful examination of a small number
Xof supplied tab files on one system only, there is no guarantee that it
Xwill work on all systems.  One major potential problem is in the
Xinclusion/exculsion of the Kchar (Kanji) element in the tabfile structure.
XUse elbat to decompile an existing tabfile; it should tell you if the
Xtabfile size is inconsistent with the content.  If this is so, change
Xthe "#define KANJI" line in the Makefile, and try again.
X
XAcknowledgements:
X	Ian Darwin tested out the first (very buggy) version of
Xthis utility, and suggested many useful changes, including the
Xintroduction of the Makefile.
X
X	Matt Crawford wrote the elbat program originally for
XBerkeley systems.
X
XCaveat:
X	This utility was written to permit the author to configure nroff
Xon his machine for terminals/fonts unsupported by the supplied tabfiles.
XIt was not intended as a universal utility applicable to all machines
Xor versions of unix.  It has been released without any guarantee whatsoever.
XThe author does not intend to support this software to any extent, and
Xusers should understand that future changes to their system software may
Xbreak this utility.  This being so, it would be foolish to depend too
Xheavily on the functionality that this utility provides.
X
X	Copyright (c) 1987 by Bruce Townsend and Bell-Northern Research.
X	Permission is granted to use and distribute, except for profit,
X	providing this copyright notice and the author's name is included.
X	No warranty of any kind is expressed or implied, and no liability of
X	any kind is assumed by either the author or Bell-Northern Research.
X
X---
XBruce Townsend (bnr-vpa!bruce)	Phone:	(613) 726-3008
XBell-Northern Research		Usenet: {utzoo, utcs}!bnr-vpa!bruce
XP.O. Box 3511, Station C, Ottawa, Ontario, Canada, K1Y 4H7
SHAR_EOF
if test 4429 -ne "`wc -c 'README'`"
then
	echo shar: error transmitting "'README'" '(should have been 4429 characters)'
fi
echo shar: extracting "'Makefile'" '(2020 characters)'
if test -f 'Makefile'
then
	echo shar: over-writing existing file "'Makefile'"
fi
sed 's/^X//' << \SHAR_EOF > 'Makefile'
X###############################################################################
X#
X#	table (version 2.0) - a utility for creating nroff driver tables.
X#
X#	Makefile for nroff driver tables under USG UNIX.
X#	Written by Bruce Townsend Oct, 1987.
X#
X#	Copyright (c) 1987 by Bruce Townsend and Bell-Northern Research.
X#	Permission is granted to use and distribute, except for profit,
X#	providing this copyright notice and the author's name is included.
X#	No warranty of any kind is expressed or implied, and no liability of
X#	any kind is assumed by either the author or Bell-Northern Research.
X#
X###############################################################################
X
X###############################################################################
X#	User-Configurable Section
X#
XSOURCES =	tabljet.c
X
XDESTDIR =	/usr/lib/term
X# Include the KANJI flag if your nroff supports Kanji characters
X# CFLAGS =	-O -DKANJI
XCFLAGS =	-O
XLDFLAGS =	-s
X#
X#	End of User-Configurable Section
X###############################################################################
X
XTABFILES =	$(SOURCES:.c=.tab)
XTABS =		$(SOURCES:.c=)
XLINTSRC =	tabXXX.c
XSHELL =		/bin/sh
X
X.SUFFIXES:	.tab
X
X.o.tab:
X	cc $(LDFLAGS) table.o $*.o
X	./a.out $@
X
X.c.tab:
X	cc -c $(CFLAGS) $<
X	cc $(LDFLAGS) table.o $*.o
X	./a.out $@
X
X
Xall:		$(TABFILES)
X
Xtable:		$(TABFILES)
X
X$(TABFILES):	table.o
X
X$(TABS):	$(TABFILES)
X		cp $@.tab $@
X
Xtable.o:	table.c table.h
X		cc -c $(CFLAGS) table.c
X
Xinstall:	$(TABS)
X		cp $(TABS) $(DESTDIR)
X		rm $(TABS)
X
Xlint:		table.c elbat.c structure.c table.h
X		lint $(LFLAGS) table.c $(LINTSRC)
X		lint $(LFLAGS) elbat.c structure.c
X
Xelbat:		elbat.o structure.o
X	    	cc $(LDFLAGS) -o elbat elbat.o structure.o
X
Xstructure.c:	table.h
X		echo 'char	*structure = "\' > structure.c
X		sed -n -e '1,/zzz/s/$$/\\n\\/p' table.h >> structure.c
X		echo '";' >> structure.c
X
Xshar:
X		shar -a README Makefile table.5 elbat.c table.c table.h \
X			$(SOURCES) > TABLE.shar
X
Xclean:
X		rm -f a.out *.o core structure.c
X
Xrealclean:	clean
X		rm -f $(TABFILES) $(TABS) elbat
SHAR_EOF
if test 2020 -ne "`wc -c 'Makefile'`"
then
	echo shar: error transmitting "'Makefile'" '(should have been 2020 characters)'
fi
echo shar: extracting "'table.5'" '(8271 characters)'
if test -f 'table.5'
then
	echo shar: over-writing existing file "'table.5'"
fi
sed 's/^X//' << \SHAR_EOF > 'table.5'
X.TH TABLE 5
X.SH NAME
Xtable, elbat \- compile/de-compile terminal driver tables for nroff
X.SH SYNOPSIS
X.B elbat
X[
X.B \-d
X]
X.BI tab name
X>
X.BI tab name .c
X.br
X.B make
X[
X.B all
X] [
X.B install
X]
X.br
X.SH DESCRIPTION
X.IR Nroff (1)
Xuses driver tables to customize its output for various types of
Xoutput devices, such as terminals, special printers (such as Diablo),
Xor special output filter programs.
XDriving tables are normally supplied for a small number of devices,
Xbut no utility is normally supplied to create or modify additional
Xdriver tables, at least for USG systems.
X(Berkeley systems apparently have this capability supplied.)
XThe
X.I table
Xutility allows a user to compile and de-compile
X.I nroff
Xdriver tables.
X.PP
XThe
X.I nroff
X\fB-T\fIname\fR
Xoption
Xtells nroff to use the driver table
X.BI /usr/lib/term/tab name
Xto format the output for a particular printer.
XThe driver table is specified by a structure
X.B t
Xwhich is given by a source file
X.BI tab name .c.
XThe structure of
X.B t
Xis as follows:
X.PP
X.nf
X.ta 5m 10m 15m 20m 25m 30m 35m 40m 45m 50m 55m 60m
X#define	INCH	240
X
Xstruct t {
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X#ifdef KANJI
X	int Kchar;
X#endif KANJI
X	int Em;
X	int Halfline;
X	int Adj;
X	char *twinit;
X	char *twrest;
X	char *twnl;
X	char *hlr;
X	char *hlf;
X	char *flr;
X	char *bdon;
X	char *bdoff;
X	char *iton;
X	char *itoff;
X	char *ploton;
X	char *plotoff;
X	char *up;
X	char *down;
X	char *right;
X	char *left;
X	char *codetab[256-32];
X	char *zzz;
X	} t;
X.fi
X.DT
X.PP
XThe meanings of the various fields are as follows:
X.TP 10
X.I bset\^
Xbits to set in the
X.I c_oflag\^
Xfield of the
X.I termio\^
Xstructure (see
X.IR tty (4))
Xbefore output.
X.TP 10
X.I breset\^
Xbits to reset in the
X.I c_oflag\^
Xfield of the
X.I termio\^
Xstructure
Xbefore output.
X.TP 10
X.I Hor\^
Xhorizontal resolution in fractions of an inch.
X.TP 10
X.I Vert\^
Xvertical resolution in fractions of an inch.
X.TP 10
X.I Newline\^
Xspace moved by a newline (linefeed) character in fractions
Xof an inch.
X.TP 10
X.I Char\^
Xquantum of character sizes, in fractions of an inch.
X(i.e., a character is a multiple of Char units wide)
X.TP 10
X.I Kchar\^
Xquantum of Kanji character sizes, in fractions of an inch.
X(i.e., a Kanji character is a multiple of Kchar units wide)
XMany systems do not have this element included in the structure.
X.TP 10
X.I Em\^
Xsize of an em in fractions of an inch.
X.TP 10
X.I Halfline\^
Xspace moved by a half-linefeed (or half-reverse-linefeed)
Xcharacter in fractions of an inch.
X.TP 10
X.I Adj\^
Xquantum of white space, in fractions of an inch.
X(i.e., white spaces are a multiple of Adj units wide)
X.IP
XNote: if this is less than the size of the space
Xcharacter (in units of Char; see below for how the
Xsizes of characters are defined),
X.I nroff\^
Xwill output
Xfractional spaces using plot mode.  Also, if the
X.B \-e
Xswitch to
X.I nroff\^
Xis used, Adj is set equal to Hor by
X.IR nroff .
X.TP 10
X.I twinit\^
Xset of characters used to initialize the terminal
Xin a mode suitable for
X.IR nroff .
X.TP 10
X.I twrest\^
Xset of characters used to restore the terminal to
Xnormal mode.
X.TP 10
X.I twnl\^
Xset of characters used to move down one line.
X.TP 10
X.I hlr\^
Xset of characters used to move up one-half line.
X.TP 10
X.I hlf\^
Xset of characters used to move down one-half line.
X.TP 10
X.I flr\^
Xset of characters used to move up one line.
X.TP 10
X.I bdon\^
Xset of characters used to turn on hardware boldface mode,
Xif any.
X.I Nroff\^
Xassumes that boldface mode is reset automatically by the
X.I twnl\^
Xstring, because many letter-quality printers reset the boldface
Xmode when they receive a carriage return;
Xthe
X.I twnl\^
Xstring should include whatever characters are necessary to
Xreset the boldface mode.
X.TP 10
X.I bdoff\^
Xset of characters used to turn off hardware boldface mode,
Xif any.
X.TP 10
X.I iton\^
Xset of characters used to turn on hardware italics mode,
Xif any.
X.TP 10
X.I itoff\^
Xset of characters used to turn off hardware italics mode,
Xif any.
X.TP 10
X.I ploton\^
Xset of characters used to turn on hardware plot mode
X(for Diablo type mechanisms), if any.
X.TP 10
X.I plotoff\^
Xset of characters used to turn off hardware plot mode
X(for Diablo type mechanisms), if any.
X.TP 10
X.I up\^
Xset of characters used to move up one resolution unit
X(Vert) in plot mode, if any.
X.TP 10
X.I down\^
Xset of characters used to move down one resolution unit
X(Vert) in plot mode, if any.
X.TP 10
X.I right\^
Xset of characters used to move right one resolution unit
X(Hor) in plot mode, if any.
X.TP 10
X.I left\^
Xset of characters used to move left one resolution unit
X(Hor) in plot mode, if any.
X.TP 10
X.I codetab\^
Xdefinition of characters needed to print an
X.I nroff\^
Xcharacter
Xon the terminal.
XThe first byte is the number of character units (Char) needed to hold the
Xcharacter; i.e., ``\\001'' is one unit wide, ``\\002'' is two
Xunits wide, etc.  The high-order bit (0200) is on if
Xthe character is to be underlined in underline mode
X(.ul).
XThis byte can be zero, indicating zero-length characters (accents, etc),
Xwith the remaining string being non-null.
XThis means that a null character must be expressed as "\\000\\0",
Xnot merely "".
X.B "The latter will cause serious problems for \fInroff\fR!"
XThe rest of the bytes are the characters used to produce the character in
Xquestion.  If the character has the sign (0200) bit on,
Xit is a code to move the terminal in plot mode.  It is
Xencoded as:
X.RS
X.IP "0100 bit on" 15
Xvertical motion.
X.IP "0100 bit off" 15
Xhorizontal motion.
X.IP "040 bit on" 15
Xnegative (up or left) motion.
X.IP "040 bit off" 15
Xpositive (down or right) motion.
X.IP "037 bits" 15
Xnumber of such motions to make.
X.RE
X.TP 10
X.I zzz\^
Xa zero terminator at the end.
X.PP
XAll quantities which are in units of fractions of an inch should
Xbe expressed as
X.RI INCH* num / denom ,
Xwhere
X.I num\^
Xand
X.I denom\^
Xare respectively the numerator and denominator of the fraction; i.e.,
X1/48 of an inch would be written as ``INCH/48''.
X.PP
XIf any sequence of characters does not pertain to the output device,
Xthat sequence should be given as a null string (""),
Xexcept for null \fIcodetab\fR strings,
Xwhich must be given as "\\000\\0".
X.PP
X.SH USAGE
XSource files are prepared for the drivers by using an editor to
Xcreate a
X.BI tab name .c
Xfile which contains an initialized
X.B t
Xstructure,
Xor by first using
X.I elbat
Xto de-compile an existing system driver table into source,
Xand modifying that source to suit.
XThe
X.BI tab name .c
Xfile is placed in the
X.I table
Xutility source directory,
Xand the
X.B Makefile
Xis edited to include
X.BI tab name .c
Xin the
X.B SOURCES
Xdefinition.
XTyping
X.I make
Xmakes all the driver tables.
XTyping
X.I make install
Xinstalls them in the
X.B /usr/lib/term
Xdirectory.
X.P
X.I Elbat
X.BI /usr/lib/term/tab name
Xdecompiles that driver table,
Xand puts the source code to standard output.
XThe
X.B -d
Xoption includes as comments extensive debug information.
X.SH FORMAT
XThe structure of the driver tables is a single integer
X.IR c_size ,
Xfollowed by a structure
X.IR t_stor ,
Xfollowed by an array of character data
X.I c_data
Xof
X.I c_size
Xbytes.
XThe size of the driver table in bytes is therefore:
X.br
X.nf
X     \fBsizeof (\fIint\fB) + \fBsizeof (\fIstruct t_stor\fB) + \fIc_size\fR.
X.fi
XThe structure t_stor is identical to the structure
X.B t
Xexcept that all character pointers are replaced by integer values
Xwhich index into the c_data character array to indicate the start
Xof each string:
X.PP
X.nf
X.ta 5m 10m 15m 20m 25m 30m 35m 40m 45m 50m 55m 60m
Xstruct t_stor {
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X#ifdef KANJI
X	int Kchar;
X#endif KANJI
X	int Em;
X	int Halfline;
X	int Adj;
X	int twinit;
X	int twrest;
X	int twnl;
X	int hlr;
X	int hlf;
X	int flr;
X	int bdon;
X	int bdoff;
X	int iton;
X	int itoff;
X	int ploton;
X	int plotoff;
X	int up;
X	int down;
X	int right;
X	int left;
X	int codetab[256-32];
X	int zzz;
X};
X.SH BUGS
XBecause the binary format of the
X.I nroff
Xdriver tables has been inferred from a small number of samples of
Xsupplied tables on only one system,
Xthe portability of the
X.I table
Xutility is not assured.
X.fi
X.DT
X.PP
X.SH FILES
X/usr/lib/term/tab\fIname\fR	driver tables accessible to nroff
X.br
Xtab\fIname\fR.c				source for driver tables
X.br
Xtab\fIname\fR.tab			compiled driver tables
X.SH AUTHOR
XBruce Townsend (bnr-vpa!bruce)
X.SH SEE ALSO
Xnroff(1)
SHAR_EOF
if test 8271 -ne "`wc -c 'table.5'`"
then
	echo shar: error transmitting "'table.5'" '(should have been 8271 characters)'
fi
echo shar: extracting "'elbat.c'" '(6793 characters)'
if test -f 'elbat.c'
then
	echo shar: over-writing existing file "'elbat.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'elbat.c'
X/*
X	table (version 2.0) - a utility for creating nroff driver tables.
X
X	elbat:  a program to de-compile nroff terminal driver tables.
X		Written by Bruce Townsend Oct, 1987.
X		Based on a program by:
X		Matt Crawford, University of Chicago, 10 May 1984
X
X	Copyright (c) 1987 by Bruce Townsend and Bell-Northern Research.
X	Permission is granted to use and distribute, except for profit,
X	providing this copyright notice and the author's name is included.
X	No warranty of any kind is expressed or implied, and no liability of
X	any kind is assumed by either the author or Bell-Northern Research.
X*/
X
X#include <stdio.h>
X#include <ctype.h>
X#include <fcntl.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include "table.h"
X
Xextern char	*structure;
X
Xchar	*codelabel[] = {
X	"space",	"!",	"\"",	"#",	"$",	"%",	"&",
X	"' close",	"(",	")",	"*",	"+",	",",	"- hyphen",
X	".",	"/",	"0",	"1",	"2",	"3",	"4",	"5",
X	"6",	"7",	"8",	"9",	":",	";",	"<",	"=",
X	">",	"?",	"@",	"A",	"B",	"C",	"D",	"E",
X	"F",	"G",	"H",	"I",	"J",	"K",	"L",	"M",
X	"N",	"O",	"P",	"Q",	"R",	"S",	"T",	"U",
X	"V",	"W",	"X",	"Y",	"Z",	"[",	"\\",	"]",
X	"^",	"_ dash",	"` open",	"a",	"b",	"c",
X	"d",	"e",	"f",	"g",	"h",	"i",	"j",	"k",
X	"l",	"m",	"n",	"o",	"p",	"q",	"r",	"s",
X	"t",	"u",	"v",	"w",	"x",	"y",	"z",	"{",
X	"|",	"}",	"~",	"narrow sp",	"hyphen",	"bullet",
X	"square",	"3/4 em",	"rule",	"1/4",	"1/2",	"3/4",
X	"minus",	"fi",	"fl",	"ff",	"ffi",	"ffl",	"degree",
X	"dagger",	"section",	"foot mark",	"acute accent",
X	"grave accent",	"underrule",	"slash (longer)",
X	"half narrow space",	"unpaddable space",	"alpha",
X	"beta",	"gamma",	"delta",	"epsilon",	"zeta",
X	"eta",	"theta",	"iota",	"kappa",	"lambda",
X	"mu",	"nu",	"xi",	"omicron",	"pi",	"rho",	"sigma",
X	"tau",	"upsilon",	"phi",	"chi",	"psi",	"omega",
X	"Gamma",	"Delta",	"Theta",	"Lambda",
X	"Xi",	"Pi",	"Sigma",	"Tau",	"Upsilon",	"Phi",
X	"Psi",	"Omega",	"square root",	"terminal sigma",
X	"root en",	">=",	"<=",	"identically equal",
X	"equation minus",	"approx =",	"approximates",
X	"not equal",	"right arrow",	"left arrow",	"up arrow",
X	"down arrow",	"eqn equals",	"multiply",	"divide",
X	"plus-minus",	"cup (union)",	"cap (intersection)",	"subset of",
X	"superset of",	"improper subset",	" improper superset",
X	"infinity",	"pt deriv",	"gradient",	"not",	"integral",
X	"proportional to",	"empty set",	"member of",
X	"equation plus",	"registration mk",	"copyright mk",
X	"box rule",	"cent sign",	"dbl dagger",	"right hand",
X	"left hand",	"math * ",	"bell system sign",
X	"or (was star)",	"circle",	"left top of big curly",
X	"left bottom of big curly",	"right top of big curly",
X	"right bottom of big curly",	"left center of big curly",
X	"right center of big curly",	"bold vertical rule",
X	"left bottom of big bracket",	"right bottom of big bracket",
X	"left top of big bracket",	"right top of big bracket",
X	"???",	"???",	"???",	"???",	"???",	"???",	"???",	"???",
X	"???",	"???",	"???",	"???",	"???",	/* The last 13 are unused */
X};
X
Xstruct t t;
Xstruct t_stor t_stor;
Xchar	*mptr;		/* Pointer to the character data */
Xint	c_size;		/* The amount of character data in bytes */
Xint	debug;
X
X#define intshow(memb)	printf ("/*%-8s*/\t\t%d,\n", "memb", t.memb)
X#define show(memb)	printf ("/*%-8s*/\t\t\"", "memb");\
X			vprint (t.memb);\
X			if (debug) printf("\",\t\t/*\t%d\t*/\n", t_stor.memb);\
X			else printf ("\",\n")
X#define getptr(memb)	t.memb = mptr + t_stor.memb
X
Xmain(argc, argv)
Xchar	**argv;
X{
X	int	c, i;
X	char	labelbuf[64];
X
X	if (argc == 3 && argv[1][0] == '-' && argv[1][1] == 'd') debug = 1;
X	if (argc != 2 && !debug) {
X	    fprintf (stderr, "Usage: elbat [-d] tabfile > tabfile.c\n");
X	    exit(1);
X	}
X
X	loadtab(argv[argc - 1]);
X	
X	printf ("%s} t =\t{\n", structure);
X	printf ("/*bset    */\t\t0%o,\n", t.bset);
X	printf ("/*breset  */\t\t0%o,\n", t.breset);
X	intshow (Hor);
X	intshow (Vert);
X	intshow (Newline);
X	intshow (Char);
X#ifdef KANJI
X	intshow (Kchar);
X#endif KANJI
X	intshow (Em);
X	intshow (Halfline);
X	intshow (Adj);
X	if (debug) printf ("/* name\t\t\tstring\t\t\tindex into c_data */\n");
X	show (twinit);
X	show (twrest);
X	show (twnl);
X	show (hlr);
X	show (hlf);
X	show (flr);
X	show (bdon);
X	show (bdoff);
X	show (iton);
X	show (itoff);
X	show (ploton);
X	show (plotoff);
X	show (up);
X	show (down);
X	show (right);
X	show (left);
X
X	for (c = 0; c < 256 - 32 - 13; c++) {
X	    sprintf (labelbuf, "/* %s */", codelabel[c]);
X	    printf ("%-20s\t\"", labelbuf);
X	    if (t.codetab[c][0])
X		vprint (t.codetab[c]);
X	    else if (t.codetab[c][1]) {
X		printf ("\\000");
X		vprint (t.codetab[c]+1);
X	    }
X	    else
X		printf ("\\000\\0");
X
X	    if (debug) printf("\",\t\t/*\t%d\t*/\n", t_stor.codetab[c]);
X	    else printf ("\",\n");
X	}
X	printf ("};\n");
X
X	if (debug) {
X	    printf ("\n/* Character data dump: Size = %d bytes\n", c_size);
X	    for (i = 0; i < c_size; i++) {
X		if (! (i % 10)) printf ("\n%6d  ", i);
X		chprint ((unsigned char) mptr[i]);
X	    }
X	    printf ("\n*/\n");
X	}
X
X	exit (0);
X}
X
Xvprint (str)
Xchar	*str;
X{
X	if (!str) return;
X	while (*str) {
X	    char	c[5];
X
X	    if (isascii (*str) && isprint (*str)
X			       && *str != '\\' && *str != '"' ) {
X		c[0] = *str;
X		c[1] = '\0';
X	    }
X	    else {
X		switch (*str) {
X		case '\\':
X		    strcpy (c, "\\\\");
X		    break;
X		case '"':
X		    strcpy (c, "\\\"");
X		    break;
X		case '\b':
X		    strcpy (c, "\\b");
X		    break;
X		case '\t':
X		    strcpy (c, "\\t");
X		    break;
X		case '\n':
X		    strcpy (c, "\\n");
X		    break;
X		case '\r':
X		    strcpy (c, "\\r");
X		    break;
X		default:
X		    sprintf (c, "\\%3.3o", (int)*str & 0377);
X		    break;
X		}
X	    }
X	printf ("%s", c);
X	str++;
X	}
X}
X
Xchprint (c)
Xunsigned char	c;
X{
X	if (isascii (c) && isgraph (c)) printf ("    %c", c);
X	else if (c) printf (" \\%.3o", c);
X	else printf (" ----");
X}
X
Xloadtab (tname)
Xchar	*tname;
X{
X	int	tfd, c;
X	char	*malloc();
X	struct stat	statbuf;
X
X	if ((tfd=open (tname, O_RDONLY)) < 0 ) {
X	    perror (tname);
X	    exit (1);
X	}
X	fstat (tfd, &statbuf);
X	read (tfd, &c_size, sizeof (int));
X	read (tfd, &t_stor, sizeof (t_stor));
X	mptr = malloc (c_size);
X	read (tfd, mptr, c_size);
X	c = sizeof (int) + sizeof (t_stor) + c_size;
X	if (c != statbuf.st_size) fprintf (stderr,
X	"WARNING: %s size: %d bytes (should be %d), output likely corrupt\n",
X	    tname, statbuf.st_size, c);
X
X	t.bset = t_stor.bset;
X	t.breset = t_stor.breset;
X	t.Hor = t_stor.Hor;
X	t.Vert = t_stor.Vert;
X	t.Newline = t_stor.Newline;
X	t.Char = t_stor.Char;
X#ifdef KANJI
X	t.Kchar = t_stor.Kchar;
X#endif KANJI
X	t.Em = t_stor.Em;
X	t.Halfline = t_stor.Halfline;
X	t.Adj = t_stor.Adj;
X	getptr (twinit);
X	getptr (twrest);
X	getptr (twnl);
X	getptr (hlr);
X	getptr (hlf);
X	getptr (flr);
X	getptr (bdon);
X	getptr (bdoff);
X	getptr (iton);
X	getptr (itoff);
X	getptr (ploton);
X	getptr (plotoff);
X	getptr (up);
X	getptr (down);
X	getptr (right);
X	getptr (left);
X
X	for (c = 0; c < 256 - 32; c++)
X	    getptr (codetab[c]);
X}
SHAR_EOF
if test 6793 -ne "`wc -c 'elbat.c'`"
then
	echo shar: error transmitting "'elbat.c'" '(should have been 6793 characters)'
fi
echo shar: extracting "'table.c'" '(5011 characters)'
if test -f 'table.c'
then
	echo shar: over-writing existing file "'table.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'table.c'
X/*
X	table (version 2.0) - a utility for creating nroff driver tables.
X
X	table:  a program to compile nroff terminal driver tables.
X		Written by Bruce Townsend Oct, 1987.
X
X	Copyright (c) 1987 by Bruce Townsend and Bell-Northern Research.
X	Permission is granted to use and distribute, except for profit,
X	providing this copyright notice and the author's name is included.
X	No warranty of any kind is expressed or implied, and no liability of
X	any kind is assumed by either the author or Bell-Northern Research.
X
X	The contributions of Ian Darwin are gratefully acknowledged.
X*/
X
X#define C_SIZE	20000	/* The maximum amount of character data allowed
X			   in the initialized structure t - increase if
X			   necessary */
X
X#include <stdio.h>
X#include "table.h"	/* This file contains the definition of the
X			   the structures t and t_stor */
X
X/*	The compiled tab file contains three primary elements:
X	-  An integer (c_size) which gives the size in bytes of the character
X	   data (the third element of the file).
X	-  The structure t_stor, which contains integer data and integer
X	   indices into the character data that follows.
X	-  c_size bytes of character data.
X	Note that the file size in bytes is therefore:
X	c_size + sizeof (int) + sizeof (t_stor)
X*/
X
Xextern struct t t;	/* Defined in the tab file source */
Xstruct t_stor t_stor;	/* This structure is stored in the compiled tab file */
X
Xchar	c_data[C_SIZE];	/* The character data to be stored in the tab file */
Xint	c_size;		/* The amount of character data in bytes */
X
Xmain (argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	FILE	*table;
X	int	i;
X
X	if (argc != 2) {	/* Need a file name argument */
X	    fprintf (stderr, "Usage: table tabfilename\n");
X	    exit (1);
X	}
X
X	if ((table = fopen (argv[1], "w")) == NULL) {	/* Open the file */
X	    fprintf (stderr, "Could not open file %s for writing\n", argv[1]);
X	    exit (1);
X	}
X
X	/* Copy the integer values from the initialized structure t
X	   to the storage structure t_stor */
X	t_stor.bset = t.bset;
X	t_stor.breset = t.breset;
X	t_stor.Hor = t.Hor;
X	t_stor.Vert = t.Vert;
X	t_stor.Newline = t.Newline;
X	t_stor.Char = t.Char;
X#ifdef KANJI
X	t_stor.Kchar = t.Kchar;
X#endif KANJI
X	t_stor.Em = t.Em;
X	t_stor.Halfline = t.Halfline;
X	t_stor.Adj = t.Adj;
X
X	/* Find each string in the character data table c_data, or add it to
X	   the table if it is not there, and provide an index to it which
X	   is stored in t_stor */
X	t_stor.twinit = addstring (t.twinit);
X	t_stor.twrest = addstring (t.twrest);
X	t_stor.twnl = addstring (t.twnl);
X	t_stor.hlr = addstring (t.hlr);
X	t_stor.hlf = addstring (t.hlf);
X	t_stor.flr = addstring (t.flr);
X	t_stor.bdon = addstring (t.bdon);
X	t_stor.bdoff = addstring (t.bdoff);
X	t_stor.iton = addstring (t.iton);
X	t_stor.itoff = addstring (t.itoff);
X	t_stor.ploton = addstring (t.ploton);
X	t_stor.plotoff = addstring (t.plotoff);
X	t_stor.up = addstring (t.up);
X	t_stor.down = addstring (t.down);
X	t_stor.right = addstring (t.right);
X	t_stor.left = addstring (t.left);
X	for (i = 0; i < 256 - 32; i++)
X	    t_stor.codetab[i] = addchar (t.codetab[i]);
X	t_stor.zzz = 0;		/* The null terminator */
X
X	/* Write to the tab file the amount of character data in bytes,
X	   the structure t_stor, and the character data */
X	if (fwrite (&c_size, sizeof (c_size), 1, table) != 1 ||
X	    fwrite (&t_stor, sizeof (t_stor), 1, table) != 1 ||
X	    fwrite (c_data, sizeof (*c_data), c_size, table) != c_size) {
X	    fprintf (stderr, "Write to file failed\n");
X	    exit (1);
X	}
X
X	/* Close the tab file */
X	if (fclose (table)) {
X	    fprintf (stderr, "File %s not closed properly\n", argv[1]);
X	    exit (1);
X	}
X}
X
Xaddstring (string)
Xchar	*string;
X{
X	if (string)	/* If pointer is non-zero add string to table */
X	    return (string_search (string, strlen (string) + 1));
X
X	else		/* If pointer is zero return 0 index */
X	    return (0);
X}
X
Xaddchar (string)
Xchar	*string;
X{
X	if (string)	/* If pointer is non-zero add string to table */
X			/* Note that the string is at least 2 chars long
X			   and that the first 2 bytes may be null */
X	    return (string_search (string, strlen (string + 2) + 3));
X
X	else		/* If pointer is zero return 0 index */
X	    return (0);
X}
X
X/*	string_search searches through the character array c_data to
X	find the string.  If found, the routine returns an integer
X	index that locates the string in c_data.  If it is not
X	found, the string is added to c_data, and c_size, the amount
X	of data in c_data, is updated.
X*/
Xstring_search (string, length)
Xchar	*string;	/* The string to find in or add to the table */
Xint	length;		/* The string length including the null terminator */
X{
X	int	s_index, c_index, match;
X	char	*pointer;
X
X	for (s_index = 0; s_index <= c_size - length; s_index++) {
X	    pointer = string;
X	    match = 1;
X	    for (c_index = s_index; c_index < s_index + length;) {
X		if (*pointer++ != c_data[c_index++]) {
X		    match = 0;
X		    break;
X		}
X	    }
X	    if (match) return (s_index);
X	}
X
X	s_index = c_size;
X	while (length--)
X	    c_data[c_size++] = *string++;
X
X	return (s_index); 
X}
SHAR_EOF
if test 5011 -ne "`wc -c 'table.c'`"
then
	echo shar: error transmitting "'table.c'" '(should have been 5011 characters)'
fi
echo shar: extracting "'table.h'" '(876 characters)'
if test -f 'table.h'
then
	echo shar: over-writing existing file "'table.h'"
fi
sed 's/^X//' << \SHAR_EOF > 'table.h'
X#ifndef	INCH
X#define	INCH	240
X#endif
X
Xstruct t {
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X#ifdef KANJI
X	int Kchar;
X#endif KANJI
X	int Em;
X	int Halfline;
X	int Adj;
X	char *twinit;
X	char *twrest;
X	char *twnl;
X	char *hlr;
X	char *hlf;
X	char *flr;
X	char *bdon;
X	char *bdoff;
X	char *iton;
X	char *itoff;
X	char *ploton;
X	char *plotoff;
X	char *up;
X	char *down;
X	char *right;
X	char *left;
X	char *codetab[256-32];
X	char *zzz;
X	};
X
Xstruct t_stor {		/* This structure will be stored in the tab file */
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X#ifdef KANJI
X	int Kchar;
X#endif KANJI
X	int Em;
X	int Halfline;
X	int Adj;
X	int twinit;
X	int twrest;
X	int twnl;
X	int hlr;
X	int hlf;
X	int flr;
X	int bdon;
X	int bdoff;
X	int iton;
X	int itoff;
X	int ploton;
X	int plotoff;
X	int up;
X	int down;
X	int right;
X	int left;
X	int codetab[256-32];
X	int zzz;
X};
SHAR_EOF
if test 876 -ne "`wc -c 'table.h'`"
then
	echo shar: error transmitting "'table.h'" '(should have been 876 characters)'
fi
echo shar: extracting "'tabljet.c'" '(9806 characters)'
if test -f 'tabljet.c'
then
	echo shar: over-writing existing file "'tabljet.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'tabljet.c'
X 	/*****************************************************************
X	*                                                                *
X	*   The following is an initialization for an HP Laserjet+ with  *
X	*   a Math Elite font cartridge.  The produced table will make   *
X	*   nroff(1) behave very similar to troff(1) except that only    *
X	*   one font size is available in nroff(1).  So, for instance,   *
X	*   is underlining (.ul and .cu) replaced by italic since this   *
X        *   is what troff(1) does.  Maximum allowed nroff(1) resolution  *
X	*   (1/240 inch) is utilized.  Pity, since Laserjet+ really has  *
X	*   1/720 inch resolution.                                       *
X	*                                                                *
X	*   This version is for fixed character spacing.                 *
X	*                                                                *
X	*   1987-10-31 -- Bo Thide', Swedish Institute of Space Physics, *
X	*   S-755 90 Uppsala, Sweden.  UUCP: ....enea!kuling!irfu!bt     *
X	*                                                                *
X	*****************************************************************/
X
X#ifndef	INCH
X#define	INCH	240
X#endif
X
Xstruct t {
X	int bset;
X	int breset;
X	int Hor;
X	int Vert;
X	int Newline;
X	int Char;
X#ifdef KANJI
X	int Kchar;
X#endif KANJI
X	int Em;
X	int Halfline;
X	int Adj;
X	char *twinit;
X	char *twrest;
X	char *twnl;
X	char *hlr;
X	char *hlf;
X	char *flr;
X	char *bdon;
X	char *bdoff;
X	char *iton;
X	char *itoff;
X	char *ploton;
X	char *plotoff;
X	char *up;
X	char *down;
X	char *right;
X	char *left;
X	char *codetab[256-32];
X	char *zzz;
X} t =	{
X/*bset    */		00,
X/*breset  */		054,
X/*Hor     */		1,
X/*Vert    */		1,
X/*Newline */		40,
X/*Char    */		20,
X#ifdef KANJI
X/*Kchar   */		40,
X#endif KANJI
X/*Em      */		20,
X/*Halfline*/		20,
X/*Adj     */		20,
X/*twinit  */		"\033&l0O\033&l66F\033&l6D\033&l3E\033&a0L\033(8U\033)0A",
X/*twrest  */		"\033&l6D",
X/*twnl    */		"\n",
X/*hlr     */		"\033&a-.5R",
X/*hlf     */		"\033=",
X/*flr     */		"\033&a-1R",
X/*bdon    */		"\033(ss5B",
X/*bdoff   */		"\033(s0B",
X/*iton    */		"\033(sb1S",
X/*itoff   */		"\033(s0S",
X/*ploton  */		"\033&l6D",
X/*plotoff */		"\033&l6D",
X/*up      */		"\033&a-3V",
X/*down    */		"\033&a+3V",
X/*right   */		"\033&a+3H",
X/*left    */		"\033&a-3H",
X/* space */         	"\001 ",
X/* ! */             	"\201!",
X/* " */             	"\201\"",
X/* # */             	"\201#",
X/* $ */             	"\201$",
X/* % */             	"\201%",
X/* & */             	"\201&",
X/* ' close */       	"\201'",
X/* ( */             	"\201(",
X/* ) */             	"\201)",
X/* * */             	"\001*",
X/* + */             	"\001+",
X/* , */             	"\201,",
X/* - hyphen */      	"\001-",
X/* . */             	"\001.",
X/* / */             	"\201/",
X/* 0 */             	"\0010",
X/* 1 */             	"\0011",
X/* 2 */             	"\0012",
X/* 3 */             	"\0013",
X/* 4 */             	"\0014",
X/* 5 */             	"\0015",
X/* 6 */             	"\0016",
X/* 7 */             	"\0017",
X/* 8 */             	"\0018",
X/* 9 */             	"\0019",
X/* : */             	"\201:",
X/* ; */             	"\201;",
X/* < */             	"\001<",
X/* = */             	"\001=",
X/* > */             	"\001>",
X/* ? */             	"\201?",
X/* @ */             	"\201@",
X/* A */             	"\201A",
X/* B */             	"\201B",
X/* C */             	"\201C",
X/* D */             	"\201D",
X/* E */             	"\201E",
X/* F */             	"\201F",
X/* G */             	"\201G",
X/* H */             	"\201H",
X/* I */             	"\201I",
X/* J */             	"\201J",
X/* K */             	"\201K",
X/* L */             	"\201L",
X/* M */             	"\201M",
X/* N */             	"\201N",
X/* O */             	"\201O",
X/* P */             	"\201P",
X/* Q */             	"\201Q",
X/* R */             	"\201R",
X/* S */             	"\201S",
X/* T */             	"\201T",
X/* U */             	"\201U",
X/* V */             	"\201V",
X/* W */             	"\201W",
X/* X */             	"\201X",
X/* Y */             	"\201Y",
X/* Z */             	"\201Z",
X/* [ */             	"\001[",
X/* \ */             	"\001\\",
X/* ] */             	"\001]",
X/* ^ */             	"\201^",
X/* _ dash */        	"\201_",
X/* ` open */        	"\201`",
X/* a */             	"\201a",
X/* b */             	"\201b",
X/* c */             	"\201c",
X/* d */             	"\201d",
X/* e */             	"\201e",
X/* f */             	"\201f",
X/* g */             	"\201g",
X/* h */             	"\201h",
X/* i */             	"\201i",
X/* j */             	"\201j",
X/* k */             	"\201k",
X/* l */             	"\201l",
X/* m */             	"\201m",
X/* n */             	"\201n",
X/* o */             	"\201o",
X/* p */             	"\201p",
X/* q */             	"\201q",
X/* r */             	"\201r",
X/* s */             	"\201s",
X/* t */             	"\201t",
X/* u */             	"\201u",
X/* v */             	"\201v",
X/* w */             	"\201w",
X/* x */             	"\201x",
X/* y */             	"\201y",
X/* z */             	"\201z",
X/* { */             	"\001{",
X/* | */             	"\201|",
X/* } */             	"\001}",
X/* ~ */             	"\201~",
X/* narrow sp */     	"\200",
X/* hyphen */        	"\001-",
X/* bullet */        	"\001\033(1QL\033(0@",
X/* square */        	"\001\033(2Ql\033(0@",
X/* 3/4 em */        	"\001\033(0Q-\033(0@",
X/* rule */          	"\001_",
X/* 1/4 */           	"\001\033(0Ew\033(0@",
X/* 1/2 */           	"\001\033(0Ex\033(0@",
X/* 3/4 */           	"\0033/4",
X/* minus */         	"\001\033(0Q-\033(0@",
X/* fi */            	"\202fi",
X/* fl */            	"\202fl",
X/* ff */            	"\202ff",
X/* ffi */           	"\203ffi",
X/* ffl */           	"\203ffl",
X/* degree */        	"\001\033(0Q#\033(0@",
X/* dagger */        	"\001\016>\017",
X/* section */       	"\001\033(0E=\033(0@",
X/* foot mark */     	"\001\033(0Q'\033(0@",
X/* acute accent */  	"\001'",
X/* grave accent */  	"\001`",
X/* underrule */     	"\001_",
X/* slash (longer) */	"\001/",
X/* half narrow space */	"\200",
X/* unpaddable space */	"\001 ",
X/* alpha */         	"\001\016a\017",
X/* beta */          	"\001\016b\017",
X/* gamma */         	"\001\016q\017",
X/* delta */         	"\001\016w\017",
X/* epsilon */       	"\001\016e\017",
X/* zeta */          	"\001\016z\017",
X/* eta */           	"\001\016h\017",
X/* theta */         	"\001\033(0Qh\033(0@",
X/* iota */          	"\001\016i\017",
X/* kappa */         	"\001\016k\017",
X/* lambda */        	"\001\016g\017",
X/* mu */            	"\001\016m\017",
X/* nu */            	"\001\016n\017",
X/* xi */            	"\001\016u\017",
X/* omicron */       	"\001\033(0Qo\033(0@",
X/* pi */            	"\001\016p\017",
X/* rho */           	"\001\016o\017",
X/* sigma */         	"\001\016s\017",
X/* tau */           	"\001\016t\017",
X/* upsilon */       	"\001\016y\017",
X/* phi */           	"\001\016d\017",
X/* chi */           	"\001\016k\017",
X/* psi */           	"\001\016c\017",
X/* omega */         	"\001\016l\017",
X/* Gamma */         	"\001\016+\017",
X/* Delta */         	"\001\016v\017",
X/* Theta */         	"\001\016j\017",
X/* Lambda */        	"\001\016;\017",
X/* Xi */            	"\001\016/\017",
X/* Pi */            	"\001\016*\017",
X/* Sigma */         	"\001\016?\017",
X/* Tau */           	"\001T",
X/* Upsilon */       	"\001\016]\017",
X/* Phi */           	"\001\016.\017",
X/* Psi */           	"\001\016,\017",
X/* Omega */         	"\001\016:\017",
X/* square root */   	"\001\016!\017",
X/* terminal sigma */	"\001\033(0Q[\033(0@",
X/* root en */       	"\001\033(1Q0\033(0@",
X/* >= */            	"\001\033(0Q^\033(0@",
X/* <= */            	"\001\033(0Q\\\033(0@",
X/* identically equal */	"\001\016-\017",
X/* equation minus */	"\001\033(0Q-\033(0@",
X/* approx = */      	"\001\033(0Q?\033(0@",
X/* approximates */  	"\001~",
X/* not equal */     	"\001\033(0Q]\033(0@",
X/* right arrow */   	"\001\016|\017",
X/* left arrow */    	"\001\016~\017",
X/* up arrow */      	"\001\016{\017",
X/* down arrow */    	"\001\016_\017",
X/* eqn equals */    	"\001=",
X/* multiply */      	"\001\033(0Q*\033(0@",
X/* divide */        	"\001\016(\017",
X/* plus-minus */    	"\001\016%\017",
X/* cup (union) */   	"\001\033(1Q5\033(0@",
X/* cap (intersection) */	"\001\033(1Q6\033(0@",
X/* subset of */     	"\001\033(1Q:\033(0@",
X/* superset of */   	"\001\033(1Q;\033(0@",
X/* improper subset */	"\001\033(1Q>\033(0@",
X/*  improper superset */	"\001\033(1Q?\033(0@",
X/* infinity */      	"\001\016<\017",
X/* pt deriv */      	"\001\016F\017",
X/* gradient */      	"\001\016$\017",
X/* not */           	"\001\033(1QH\033(0@",
X/* integral */      	"\001\033(1QU\033(0@",
X/* proportional to */	"\001\016&\017",
X/* empty set */     	"\001\033(1QX\033(0@",
X/* member of */     	"\001\033(1Q7\033(0@",
X/* equation plus */ 	"\001+",
X/* registration mk */	"\001\033(2Q,\033(0@",
X/* copyright mk */  	"\001\033(2Q-\033(0@",
X/* box rule */      	"\001\033(1Qv\033(0@",
X/* cent sign */     	"\001\033(0E?\033(0@",
X/* dbl dagger */    	"\001\033(1QO\033(0@",
X/* right hand */    	"\001\033(1Q&\033(0@",
X/* left hand */     	"\001\033(1Q(\033(0@",
X/* math *  */       	"\001*",
X/* bell system sign */	"\001\033(2QS\033(0@",
X/* or (was star) */ 	"\001|",
X/* circle */        	"\001\033(1QM\033(0@",
X/* left top of big curly */	"\001\033(1Qb\033(0@",
X/* left bottom of big curly */	"\001\033(1Qd\033(0@",
X/* right top of big curly */	"\001\033(1Qr\033(0@",
X/* right bottom of big curly */	"\001\033(1Qt\033(0@",
X/* left center of big curly */	"\001\033(1Qc\033(0@",
X/* right center of big curly */	"\001\033(1Qs\033(0@",
X/* bold vertical rule */	"\001\033(1Qu\033(0@",
X/* left bottom of big bracket */	"\001\033(1Qa\033(0@",
X/* right bottom of big bracket */	"\001\033(1Qq\033(0@",
X/* left top of big bracket */	"\001\033(1Q`\033(0@",
X/* right top of big bracket */	"\001\033(1Qp\033(0@",
X};
SHAR_EOF
if test 9806 -ne "`wc -c 'tabljet.c'`"
then
	echo shar: error transmitting "'tabljet.c'" '(should have been 9806 characters)'
fi
#	End of shell archive
exit 0




