Subject:  v13i049:  Screen-oriented rolodex program, Part01/04
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Dave Ihnat <ihnp4!homebru!ignatz>
Posting-number: Volume 13, Issue 49
Archive-name: rolodex/part01

[  I repacked things.  --r$ ]

This is a much-hacked version of the rolodex program posted to the net
some time ago.  Steve Steiner and I have cleaned up a lot of glitches,
ported and verified it on a *lot* of new environments, added the
pretty-print option, etc.  Although there are a number of things I'd like
to still clean up--especially the memory manager!--I'm done with it for
the forseeable future, and so is Steve, so it's probably proper to post it
at this time.  Many thanks to the original author...

	Dave Ihnat     -     Steve Steiner
	Analysts International Corporation
	ihnp4!homebru!ignatz ihnp4!aicchi!steiner

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 4)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f './Makefile.bsd' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Makefile.bsd'\"
else
echo shar: Extracting \"'./Makefile.bsd'\" \(1524 characters\)
sed "s/^X//" >'./Makefile.bsd' <<'END_OF_FILE'
X# Makefile for rolo - UNIX version BSD 4.2
X# Configure for your type of terminal capability database.  
X#  if you have termcap,  set TERMSTUFF= -DTERMCAP,  and LIBS= -ltermcap
X#  if you have terminfo, set TERMSTUFF= -DTERMINFO, and LIBS= -lterminfo
X#  if you don't have either, leave them both blank (only "clear_screen" is used)
XTERMSTUFF= -DTERMCAP
XLIBS= -lcurses -ltermcap
X#
XCC = cc
XRLIB    = /usr/local/lib/rolo
XROLOLIB = \"$(RLIB)\"
XTOOLDIR = ./toolsdir
XCFLAGS = -DBSD -DUNIX -DROLOLIB=$(ROLOLIB) $(TERMSTUFF) -I$(TOOLDIR) -O -s
X#CFLAGS = -DBSD -DUNIX -DROLOLIB=$(ROLOLIB) $(TERMSTUFF) -I$(TOOLDIR) -g
X#DBGFLAG = -g
XDBGFLAG = 
XSOURCES = clear.c io.c menuaux.c operatns.c options.c \
X	rlist.c rolo.c search.c update.c
XOBJECTS = clear.o io.o menuaux.o operatns.o options.o \
X	rlist.o rolo.o search.o update.o
XTOOLOBJ = $(TOOLDIR)/mem.o $(TOOLDIR)/args.o $(TOOLDIR)/ctools.o \
X	$(TOOLDIR)/menu.o
X
XBIN = /usr/local/bin
XMANDIR = /usr/man/lman/man1
XPROG = rolo
XMAN = rolo.1
X
Xrolo: $(OBJECTS)
X	cd $(TOOLDIR) ; make ; cd .. 
X	$(CC) -o rolo $(DBGFLAG) $(CFLAGS) $(OBJECTS) $(TOOLOBJ) $(LIBS)
X
Xinstall:	$(PROG) $(MAN)
X	install -s -o bin -g bin -m 111 $(PROG) $(BIN)
X	install -c -o bin -g bin -m 444 $(MAN) $(MANDIR)
X
X	- mkdir $(RLIB)
X	chown bin $(RLIB)
X	chgrp bin $(RLIB)
X	cp helplib/*.* $(RLIB)
X	chown bin $(RLIB)/*.*
X	chgrp bin $(RLIB)/*.*
X	chmod 444 $(RLIB)/*.*
X
Xclean:
X	rm -f $(OBJECTS) rolo *~ foo $(TOOLDIR)/*.o
X
Xshar:
X	cshar README rolo.1 Makefile helplib > roloshar1
X	cshar *.[ch] > roloshar2
X	cshar toolsdir > roloshar3
END_OF_FILE
if test 1524 -ne `wc -c <'./Makefile.bsd'`; then
    echo shar: \"'./Makefile.bsd'\" unpacked with wrong size!
fi
# end of './Makefile.bsd'
fi
if test -f './Makefile.msc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Makefile.msc'\"
else
echo shar: Extracting \"'./Makefile.msc'\" \(1939 characters\)
sed "s/^X//" >'./Makefile.msc' <<'END_OF_FILE'
X# Makefile for Rolodex - PC/MS-DOS version (Microsoft C)
X#
X# :ts=8
X# :bk=0
X# :ma=1
X#
X
X# Configure for your type of terminal capability database.  
XTERMSTUFF=
X#
XCC = msc
XLIBDIR= d:
XROLOLIB = "rololib"
XTOOLDIR = toolsdir
X#OPTDBG = /Zi
XOPTDBG = /Os
XCFLAGS = /DMSC /DMSDOS /DROLOLIB=$(ROLOLIB) $(TERMSTUFF) /I$(TOOLDIR) $(OPTDBG)
XLDFLAGS =  /CODEVIEW
X
XSOURCES = clear.c io.c menuaux.c operatns.c options.c \
X	rlist.c rolo.c search.c update.c
X
XOBJECTS = clear.obj io.obj menuaux.obj operatns.obj options.obj \
X	rlist.obj rolo.obj search.obj update.obj
X
XTOOLLIB = $(TOOLDIR)/tools
X
X.c.obj:
X	$(CC) $(CFLAGS) $*.c;
X
Xclear.obj:	clear.c
X
Xio.obj:		io.c $(TOOLDIR)\ctools.h rolofilz.h datadef.h
X
Xmenuaux.obj:	menuaux.c $(TOOLDIR)\ctools.h $(TOOLDIR)\args.h $(TOOLDIR)\menu.h rolofilz.h rolodefs.h datadef.h
X
Xoperatns.obj:	operatns.c $(TOOLDIR)\ctools.h $(TOOLDIR)\args.h $(TOOLDIR)\menu.h $(TOOLDIR)\mem.h rolofilz.h rolodefs.h datadef.h choices.h
X
Xoptions.obj:	options.c $(TOOLDIR)\ctools.h $(TOOLDIR)\args.h $(TOOLDIR)\menu.h $(TOOLDIR)\mem.h rolofilz.h rolodefs.h datadef.h choices.h
X
Xrlist.obj:	rlist.c datadef.h
X
Xrolo.obj:	rolo.c $(TOOLDIR)\ctools.h $(TOOLDIR)\args.h $(TOOLDIR)\menu.h $(TOOLDIR)\mem.h rolofilz.h rolodefs.h datadef.h
X
Xsearch.obj:	search.c $(TOOLDIR)\ctools.h $(TOOLDIR)\args.h $(TOOLDIR)\menu.h $(TOOLDIR)\mem.h rolofilz.h rolodefs.h datadef.h choices.h
X
Xupdate.obj:	update.c $(TOOLDIR)\ctools.h $(TOOLDIR)\args.h $(TOOLDIR)\menu.h $(TOOLDIR)\mem.h rolofilz.h rolodefs.h datadef.h choices.h
X
X#
X# Please note that the 'link' line is very Microsoft-C dependent.  Modify as
X# needed for your linker.  For Microsoft-C, you must make a file
X# named 'respfile', consisting of the object filenames for
X# $(OBJECTS) and $(TOOLOBJ), with
X# the subordinate directory 'toolsdir' as part of the name.
X#
Xrolo: $(OBJECTS) respfile
X	cd $(TOOLDIR)
X	del tools.lib
X	make makefile.msc
X	cd ..
X	link $(LDFLAGS) @respfile,rolo.exe,,$(TOOLDIR)\tools;
END_OF_FILE
if test 1939 -ne `wc -c <'./Makefile.msc'`; then
    echo shar: \"'./Makefile.msc'\" unpacked with wrong size!
fi
# end of './Makefile.msc'
fi
if test -f './Makefile.tc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Makefile.tc'\"
else
echo shar: Extracting \"'./Makefile.tc'\" \(1347 characters\)
sed "s/^X//" >'./Makefile.tc' <<'END_OF_FILE'
X# Makefile for Rolodex - PC/MS-DOS version (Turbo-C)
X
X# Configure for your type of terminal capability database.  
X#  if you have termcap,  set TERMSTUFF= -DTERMCAP,  and LIBS= -ltermcap
X#  if you have terminfo, set TERMSTUFF= -DTERMINFO, and LIBS= -lterminfo
X#  if you dont have either, leave them both blank (only "clear_screen" is used)
X#TERMSTUFF= -DTERMCAP
XTERMSTUFF=
X#LIBS= -lcurses -ltermcap
X#
XCC = tcc
XMODEL= s
XLIBDIR= d:
XROLOLIB = "rololib"
XTOOLDIR = toolsdir
XCFLAGS = -DMSDOS -DROLOLIB=$(ROLOLIB) $(TERMSTUFF) -I$(TOOLDIR) -O
XDBGFLAG = 
X
XSOURCES = clear.c io.c menuaux.c operatns.c options.c \
X	rlist.c rolo.c search.c update.c
X
XOBJECTS = clear.obj io.obj menuaux.obj operatns.obj options.obj \
X	rlist.obj rolo.obj search.obj update.obj
X
XTOOLOBJ = $(TOOLDIR)/mem.obj $(TOOLDIR)/args.obj $(TOOLDIR)/ctools.obj \
X	$(TOOLDIR)/menu.obj
X
X.c.obj:
X	$(CC) $(CFLAGS) -c $<
X
X#
X# Please note that the 'tlink' line is very Turbo-C dependent.  Modify as
X# needed for your linker.  For Turbo-C, you must make a file named 'respfile',
X# consisting of the object filenames for $(OBJECTS) and $(TOOLOBJ), with
X# the subordinate directory 'toolsdir' as part of the name.
X#
Xrolo: $(OBJECTS) respfile
X	cd $(TOOLDIR)
X	make -fmakefile.dos tools
X	cd ..
X	tlink /c /x $(LIBDIR)c0$(MODEL) @respfile,rolo.exe,,$(LIBDIR)emu $(LIBDIR)math$(MODEL) $(LIBDIR)C$(MODEL)
END_OF_FILE
if test 1347 -ne `wc -c <'./Makefile.tc'`; then
    echo shar: \"'./Makefile.tc'\" unpacked with wrong size!
fi
# end of './Makefile.tc'
fi
if test -f './Makefile.unx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Makefile.unx'\"
else
echo shar: Extracting \"'./Makefile.unx'\" \(1606 characters\)
sed "s/^X//" >'./Makefile.unx' <<'END_OF_FILE'
X# Makefile for rolo - UNIX generic version
X
X# Configure for your type of terminal capability database.  
X#  if you have termcap,  set TERMSTUFF= -DTERMCAP,  and LIBS= -ltermcap
X#  if you have terminfo, set TERMSTUFF= -DTERMINFO, and LIBS= -lterminfo
X#  if you don't have either, leave them both blank (only "clear_screen" is used)
XTERMSTUFF= -DTERMINFO
XLIBS= -lcurses
X#
XCC = cc
XRLIB    = /usr/local/lib/rolo
XROLOLIB = \"$(RLIB)\"
XTOOLDIR = ./toolsdir
XCFLAGS = -DUNIX -DROLOLIB=$(ROLOLIB) $(TERMSTUFF) -I$(TOOLDIR) -O -s
XDBGFLAG =
XSOURCES = clear.c io.c menuaux.c operatns.c options.c \
X	rlist.c rolo.c search.c update.c
XOBJECTS = clear.o io.o menuaux.o operatns.o options.o \
X	rlist.o rolo.o search.o update.o
XTOOLOBJ = $(TOOLDIR)/mem.o $(TOOLDIR)/args.o $(TOOLDIR)/ctools.o \
X	$(TOOLDIR)/menu.o
X
XBIN = /usr/local/bin
XMS = 1
XMAN = /usr/man/local/man$(MS)
X
Xrolo: $(OBJECTS)
X	cd $(TOOLDIR) ; make tools ; cd ..
X	$(CC) -o rolo $(DBGFLAG) $(CFLAGS) $(OBJECTS) $(TOOLOBJ) $(LIBS)
Xinstall: rolo
X	rm -f $(BIN)/rolo
X	mv rolo $(BIN)/rolo
X	chown bin $(BIN)/rolo
X	chgrp bin $(BIN)/rolo
X	chmod 111 $(BIN)/rolo
X
X	- mkdir $(RLIB)
X	- rm -f $(RLIB)/*.*
X	chown bin $(RLIB)
X	chgrp bin $(RLIB)
X	chmod 775 $(RLIB)
X
X	cp helplib/*.* $(RLIB)
X	chown bin $(RLIB)/*.*
X	chgrp bin $(RLIB)/*.*
X	chmod 444 $(RLIB)/*.*
X
Xman: 
X	rm -f $(MAN)/rolo.1
X	cp rolo.1 $(MAN)/rolo.$(MS)
X	chown bin $(MAN)/rolo.$(MS)
X	chgrp bin $(MAN)/rolo.$(MS)
X	chmod 444 $(MAN)/rolo.$(MS)
X	man rolo
X
Xclean:
X	rm -f $(OBJECTS) rolo *~ foo $(TOOLDIR)/*.o
X
Xshar:
X	cshar README rolo.1 Makefile helplib > roloshar1
X	cshar *.[ch] > roloshar2
X	cshar toolsdir > roloshar3
END_OF_FILE
if test 1606 -ne `wc -c <'./Makefile.unx'`; then
    echo shar: \"'./Makefile.unx'\" unpacked with wrong size!
fi
# end of './Makefile.unx'
fi
if test -f './Part01' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Part01'\"
else
echo shar: Extracting \"'./Part01'\" \(0 characters\)
sed "s/^X//" >'./Part01' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'./Part01'`; then
    echo shar: \"'./Part01'\" unpacked with wrong size!
fi
# end of './Part01'
fi
if test -f './README.Z' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./README.Z'\"
else
echo shar: Extracting \"'./README.Z'\" \(0 characters\)
sed "s/^X//" >'./README.Z' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'./README.Z'`; then
    echo shar: \"'./README.Z'\" unpacked with wrong size!
fi
# end of './README.Z'
fi
if test -f './choices.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./choices.h'\"
else
echo shar: Extracting \"'./choices.h'\" \(703 characters\)
sed "s/^X//" >'./choices.h' <<'END_OF_FILE'
X/* choices.h */
Xtypedef enum { P_CONTINUE, P_NEXT_PERSON, P_ABORT, P_HELP } P_Choices;
X
Xtypedef enum { 
X        
X        M_SEARCH_BY_OTHER, AM_SEARCH_BY_NAME, M_PRINT_TO_LASER_PRINTER,
X        M_HELP, M_EXIT, M_PERUSE, M_SAVE, M_ADD
X
X      } Main_Choices;
X
Xtypedef enum { 
X
X        A_ABORT_ADD, A_BACKUP, A_FILL_IN_REST,
X        AA_ABORT_ROLO, A_HELP, A_NO_DATA
X
X      } Add_Choices;
X
Xtypedef enum { 
X        
X        E_ABORT, E_UPDATE, E_DELETE, E_CONTINUE, E_PREV, E_HELP, E_SCAN
X        
X      } E_Choices;
X
Xtypedef enum { U_ABORT, U_HELP, U_END_UPDATE } U_Choices;
X
Xtypedef enum { S_ABORT, S_HELP, S_SCAN_ONE_BY_ONE } S_Choices;
X
Xtypedef enum { O_ABORT, O_HELP, O_BACKUP, O_DONE_OTHERS } O_Choices;
END_OF_FILE
if test 703 -ne `wc -c <'./choices.h'`; then
    echo shar: \"'./choices.h'\" unpacked with wrong size!
fi
# end of './choices.h'
fi
if test -f './clear.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./clear.c'\"
else
echo shar: Extracting \"'./clear.c'\" \(1884 characters\)
sed "s/^X//" >'./clear.c' <<'END_OF_FILE'
X/* clear.c */
X#include <stdio.h>
X#ifdef TERMINFO
X#include <term.h>
X#endif
X#undef putchar
X
Xint putchar();
X
X#ifdef TERMCAP
Xstatic int ok_to_clear;
X#endif
X
X#ifdef TERMINFO
Xstatic int ok_to_clear;
X#endif
X
X#ifdef TERMCAP
Xstatic char clear_screen[128] = 0;
Xstatic int lines;
X#endif
X
X#ifdef MSDOS
X/*
X * IF we assume the standard ANSI terminal driver, we can't go TOO far wrong...
X * but allow a bailout.  Making this assumption, we realize that it's a
X * VT-100 sequence, so for this one file...
X */
X#ifndef GENERIC_SCR
X#define VMS
X#endif
X#endif
X
X#ifdef VMS
X/*
X * VMS is so heavily targeted to VT-100 screens that we can assume...
X */
Xstatic char vt100_clear[128] = { '\033','[','H','\033','[','2','J','\0' };
X#endif
X
X
X#ifdef GENERIC_SCR
X/* This is pretty generic... */
X#define CLR_LINES	30
X#endif
X
Xclearinit ()
X{
X#ifdef TERMINFO
X  int i;        
X  char *getenv();
X  char *name = "TERM";
X/* setupterm(getenv(name),1,&i); *//* As of at least SVID Issue 2, Vol. 2 */
X  i = setterm(getenv(name));
X  ok_to_clear = (i == 1) ? 1 : 0;
X  if (i != 1) {
X     fprintf(stderr,"Warning: Terminal type unknown\n");
X  }
X  return (i == 1) ? 0 : -1;
X#endif
X#ifdef TERMCAP
X  char tc[1024];
X  char *ptr = clear_screen;
X  char *getenv();
X  char *name = "TERM";
X  
X  if (tgetent(tc, getenv(name)) < 1) {
X    ok_to_clear = 0;
X    return;
X  }
X  tgetstr("cl", &ptr);
X  lines = tgetnum("li");
X  ok_to_clear = (clear_screen[0] != 0 && lines > 0);
X
X#endif
X}        
X        
Xclear_the_screen ()
X{
X#ifdef TERMINFO
X  if (!ok_to_clear) return;        
X  tputs(clear_screen,lines,putchar);
X  fflush(stdout);
X#endif
X#ifdef TERMCAP
X  if (!ok_to_clear) return;
X  tputs(clear_screen,lines,putchar);
X  fflush(stdout);
X#endif
X
X#ifdef VMS
X  fputs(vt100_clear,stdout);
X  fflush(stdout);
X#endif
X#ifdef GENERIC_SCR
X  {
X	register int index;
X
X	for(index = 0;index < CLR_LINES ;index++)
X		putchar('\n');
X  }
X  fflush(stdout);
X#endif
X}
END_OF_FILE
if test 1884 -ne `wc -c <'./clear.c'`; then
    echo shar: \"'./clear.c'\" unpacked with wrong size!
fi
# end of './clear.c'
fi
if test ! -d './helplib' ; then
    echo shar: Creating directory \"'./helplib'\"
    mkdir './helplib'
fi
if test -f './helplib/addhelp.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/addhelp.hlp'\"
else
echo shar: Extracting \"'./helplib/addhelp.hlp'\" \(1408 characters\)
sed "s/^X//" >'./helplib/addhelp.hlp' <<'END_OF_FILE'
XYou are adding a new entry to your rolodex database.  If you want to
Xget back to the main menu type the character '\' followed by RETURN.
X
XEach entry is composed of 7 fixed items, which are Name, Work Phone,
XHome Phone, Company, Work Address, Home Address, and Remarks.  You are
Xbeing prompted to give a value to each item, one after the other.  Simply
Xtype in some characters and end with a RETURN.  If you realize you've made
Xa mistake after hitting RETURN, type '^' RETURN, which will prompt you
Xagain for the item you just entered.  If you have no information for a 
Xparticular item, simply type RETURN and you will be prompted for the next
Xitem.   Finally, the program will prompt you with 'Other fields? '.   At
Xthis point type 'no' RETURN unless you know what you are doing (see below).
X
X     (Advanced feature) If you have entered all the information about a person
Xyou have, and the program is still prompting you for fields, type '!' RETURN
Xand it will assume that all the remaining fields are to be left empty.
X     (Advanced feature) You can add items in addition to those listed above.
XTo do so answer 'yes' to the 'Other fields? ' prompt and then ask for help.
X     (Advanced feature) The character ';' is used as a line separator.  If
Xyou typed in '245 First St.,; Cambridge, MA 02139', when this information was
Xdisplayed the street address and city/state would print out on different lines.
END_OF_FILE
if test 1408 -ne `wc -c <'./helplib/addhelp.hlp'`; then
    echo shar: \"'./helplib/addhelp.hlp'\" unpacked with wrong size!
fi
# end of './helplib/addhelp.hlp'
fi
if test -f './helplib/addinfo.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/addinfo.hlp'\"
else
echo shar: Extracting \"'./helplib/addinfo.hlp'\" \(67 characters\)
sed "s/^X//" >'./helplib/addinfo.hlp' <<'END_OF_FILE'
XAdd a rolodex entry:  (? for help, ^ to back up, \ to abort add)
X
X
END_OF_FILE
if test 67 -ne `wc -c <'./helplib/addinfo.hlp'`; then
    echo shar: \"'./helplib/addinfo.hlp'\" unpacked with wrong size!
fi
# end of './helplib/addinfo.hlp'
fi
if test -f './helplib/confirm.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/confirm.hlp'\"
else
echo shar: Extracting \"'./helplib/confirm.hlp'\" \(98 characters\)
sed "s/^X//" >'./helplib/confirm.hlp' <<'END_OF_FILE'
XYou are being asked to confirm your decision.  Enter either a 'y' to continue,
Xor a 'n' to abort.
END_OF_FILE
if test 98 -ne `wc -c <'./helplib/confirm.hlp'`; then
    echo shar: \"'./helplib/confirm.hlp'\" unpacked with wrong size!
fi
# end of './helplib/confirm.hlp'
fi
if test -f './helplib/entrymnu.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/entrymnu.hlp'\"
else
echo shar: Extracting \"'./helplib/entrymnu.hlp'\" \(223 characters\)
sed "s/^X//" >'./helplib/entrymnu.hlp' <<'END_OF_FILE'
X
X   RETURN  : continue the scan.             %   : scan rolodex from this point.
X   +       : update or add to the entry.    <   : display previous entry.
X   -       : delete the entire entry.       \   : abort the scan.
X
X
END_OF_FILE
if test 223 -ne `wc -c <'./helplib/entrymnu.hlp'`; then
    echo shar: \"'./helplib/entrymnu.hlp'\" unpacked with wrong size!
fi
# end of './helplib/entrymnu.hlp'
fi
if test -f './helplib/escan.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/escan.hlp'\"
else
echo shar: Extracting \"'./helplib/escan.hlp'\" \(847 characters\)
sed "s/^X//" >'./helplib/escan.hlp' <<'END_OF_FILE'
XThe rolodex program is displaying each entry in your rolodex database
X(the entries are ordered alphabetically) one by one.  After an entry
Xhas been displayed, you have the option to
X
X  -- have the next entry displayed (type RETURN)
X  -- have the previous entry displayed by (type '<' RETURN)
X  -- delete the entry from your rolodex (type '-' RETURN)
X  -- change the information contained in this entry (type '+' RETURN)
X  -- abort this sequential display mode and go back to the main menu 
X     (type '\' RETURN)
X
XIf you elect to delete the entry, the message 'Entry deleted' will be
Xdisplayed briefly, and then the next entry will be displayed.
X
XIf you elect to update the entry, after you have completed the update
Xoperation the message 'Displaying next entry in scan list' will be
Xdisplayed briefly, and then the next entry will be displayed.
X
END_OF_FILE
if test 847 -ne `wc -c <'./helplib/escan.hlp'`; then
    echo shar: \"'./helplib/escan.hlp'\" unpacked with wrong size!
fi
# end of './helplib/escan.hlp'
fi
if test -f './helplib/esearch.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/esearch.hlp'\"
else
echo shar: Extracting \"'./helplib/esearch.hlp'\" \(1072 characters\)
sed "s/^X//" >'./helplib/esearch.hlp' <<'END_OF_FILE'
XThe rolodex program is displaying each entry that matches the search string
Xyou provided, one by one.  After an entry has been displayed, you have
Xthe option to
X
X  -- have the next entry displayed (type RETURN)
X  -- have the previous entry displayed by (type '<' RETURN)
X  -- delete the entry from your rolodex (type '-' RETURN)
X  -- change the information contained in this entry (type '+' RETURN)
X  -- abort this sequential display mode and go back to the main menu 
X     (type '\' RETURN)
X
X     If you elect to delete the entry, the message 'Entry deleted' will
Xbe displayed briefly, and then the next entry will be displayed.
X     If you elect to update the entry, after you have completed the
Xupdate operation the message 'Displaying next entry in scan list' will
Xbe displayed briefly, and then the next entry will be displayed.
X     If only one entry matched your search string, or the entry being
Xdisplayed is the last entry which matches, if you try to continue the
Xprogram will inform you that there are no more matching entries and
Xreturn you to the main menu.
X
END_OF_FILE
if test 1072 -ne `wc -c <'./helplib/esearch.hlp'`; then
    echo shar: \"'./helplib/esearch.hlp'\" unpacked with wrong size!
fi
# end of './helplib/esearch.hlp'
fi
if test -f './helplib/fldsrch.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/fldsrch.hlp'\"
else
echo shar: Extracting \"'./helplib/fldsrch.hlp'\" \(1035 characters\)
sed "s/^X//" >'./helplib/fldsrch.hlp' <<'END_OF_FILE'
XYou have asked to search the rolodex database by some other item than name.
XFor instance, if you wanted to find people who worked in Cambridge, you could
Xselect the 'Work Address' item and use as a search string 'Cambridge'.  If
Xthis is not what you want to do type '\' RETURN to get back to the main menu.
X
XTo select an item to search by, type the number of the item.  It will
Xthen prompt you for a search string.  Type in what you want to search
Xfor followed by RETURN.  The program will then show you the entries that
Xit has found that match your search criteria.
X
X(Advanced feature) You can search by items which you have defined, as well as
Xthe standard items.  The last choice is not a standard item but an option to
Xallow you to type in the name of your own user-defined item name.  For
Xinstance, if your rolodex database contained 'Net Address' items, you could
Xsearch for Net Addresses containing 'ihnp4' by selecting the last choice
Xand typing in 'Net Address' RETURN, followed by 'ihnp4' RETURN at the
Xappropriate prompts.
X
END_OF_FILE
if test 1035 -ne `wc -c <'./helplib/fldsrch.hlp'`; then
    echo shar: \"'./helplib/fldsrch.hlp'\" unpacked with wrong size!
fi
# end of './helplib/fldsrch.hlp'
fi
if test -f './helplib/lockinfo.dos' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/lockinfo.dos'\"
else
echo shar: Extracting \"'./helplib/lockinfo.dos'\" \(583 characters\)
sed "s/^X//" >'./helplib/lockinfo.dos' <<'END_OF_FILE'
XYour rolodex is already in use!
X
XEither someone else on a networked DOS system is using and possibly modifying
Xyour rolodex, or else you forgot to properly exit a previous use of your
Xrolodex, or possibly the system crashed while you were using your rolodex the
Xlast time.
X
XYou can check on the lock file by typing:
X
XDIR <d:>\ROLODATA.LCK  (Where <d:> is your current disk drive, i.e., A:)
X
XIf you're on a networked system, and this file is present and you're not
Xrunning rolodex, find out who may be running it.  Otherwise, you can clean up
Xby simply typing:
X
XDEL <d:>\ROLODATA.LCK
END_OF_FILE
if test 583 -ne `wc -c <'./helplib/lockinfo.dos'`; then
    echo shar: \"'./helplib/lockinfo.dos'\" unpacked with wrong size!
fi
# end of './helplib/lockinfo.dos'
fi
if test -f './helplib/lockinfo.unx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/lockinfo.unx'\"
else
echo shar: Extracting \"'./helplib/lockinfo.unx'\" \(735 characters\)
sed "s/^X//" >'./helplib/lockinfo.unx' <<'END_OF_FILE'
XYour rolodex is already in use!
X
XEither someone else is using and possibly modifying your rolodex, or else
Xyou forgot to exit a previous use of your rolodex, or possibly the system
Xcrashed while you were using your rolodex the last time.
X
XYou can find out who is using your rolodex by typing
X
Xls -l ~/.rolodexdata.lock
X
XThe third column of the output will be a user's name.  If the name is
Xnot yours, then you should find out what that person is doing with your
Xrolodex and ask him/her to let you know when they are finished.
X
XIf the name is your own, then it is probably safe to remove the lock file.
X(It is possible that someone else is logged in as you, however...)
XType
X
Xrm ~/.rolodexdata.lock
X
Xand then you can use your rolodex.
X
END_OF_FILE
if test 735 -ne `wc -c <'./helplib/lockinfo.unx'`; then
    echo shar: \"'./helplib/lockinfo.unx'\" unpacked with wrong size!
fi
# end of './helplib/lockinfo.unx'
fi
if test -f './helplib/lockinfo.vms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/lockinfo.vms'\"
else
echo shar: Extracting \"'./helplib/lockinfo.vms'\" \(811 characters\)
sed "s/^X//" >'./helplib/lockinfo.vms' <<'END_OF_FILE'
XYour rolodex is already in use!
X
XEither someone else is using and possibly modifying your rolodex, or else
Xyou forgot to exit a previous use of your rolodex, or possibly the system
Xcrashed while you were using your rolodex the last time.
X
XYou can find out who is using your rolodex by typing
X
XDIR/OWN SYS$LOGIN:ROLODEXDATA.LOCK
X
XThe last item on the line will be [GROUP,OWNER], where OWNER is the login
Xof the person owning the lock file.  If the login is not yours, then you
Xshould find out what that person is doing with your rolodex and ask
Xhim/her to let you know when they are finished.
X
XIf the name is your own, then it is probably safe to remove the lock file.
X(It is possible that someone else is logged in as you, however...)
XType
X
XDEL SYS$LOGIN:ROLODEXDATA.LOCK;*
X
Xand then you can use your rolodex.
X
END_OF_FILE
if test 811 -ne `wc -c <'./helplib/lockinfo.vms'`; then
    echo shar: \"'./helplib/lockinfo.vms'\" unpacked with wrong size!
fi
# end of './helplib/lockinfo.vms'
fi
if test -f './helplib/mainmenu.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/mainmenu.hlp'\"
else
echo shar: Extracting \"'./helplib/mainmenu.hlp'\" \(396 characters\)
sed "s/^X//" >'./helplib/mainmenu.hlp' <<'END_OF_FILE'
X        TOP LEVEL MENU
X
X  +  :  add a new entry
X  %  :  scan the rolodex entry by entry
X  $  :  search by some item other than 'Name'
X  *  :  save any changes made so far
X  !  :  pretty print the rolodex database to a disk file
X  \  :  exit (any changes you've made will be saved)
X
XTo search for an entry by name, just type in the name.
XTo update or delete an entry, first find it by searching.
X
END_OF_FILE
if test 396 -ne `wc -c <'./helplib/mainmenu.hlp'`; then
    echo shar: \"'./helplib/mainmenu.hlp'\" unpacked with wrong size!
fi
# end of './helplib/mainmenu.hlp'
fi
if test -f './helplib/mnymtch.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/mnymtch.hlp'\"
else
echo shar: Extracting \"'./helplib/mnymtch.hlp'\" \(370 characters\)
sed "s/^X//" >'./helplib/mnymtch.hlp' <<'END_OF_FILE'
XRolodex found too many field entries matching your search string to display
Xeach record on the screen and allow you to select each one by number.  Instead,
Xyou may view the entire list, one-by-one, by entering 'v' at the prompt;
Xor, you may abort this search by entering '\', and request another search
Xusing a more unique search string to reduce the number of matches.
END_OF_FILE
if test 370 -ne `wc -c <'./helplib/mnymtch.hlp'`; then
    echo shar: \"'./helplib/mnymtch.hlp'\" unpacked with wrong size!
fi
# end of './helplib/mnymtch.hlp'
fi
if test -f './helplib/moption.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/moption.hlp'\"
else
echo shar: Extracting \"'./helplib/moption.hlp'\" \(1391 characters\)
sed "s/^X//" >'./helplib/moption.hlp' <<'END_OF_FILE'
X     This is the TMC Rolodex, an online way to store and retrieve information
Xabout people you know, and other important pieces of data.
X     Data is stored in units called entries..  There will generally be an entry
Xfor each person in your rolodex.  Inside entries are items.  Items store such
Xthings as a person's name, his phone number(s), and address(es).  You can
Xchange items or add new ones.  You can create or delete entire entries also.
X     At any time you can type the character '\' followed by RETURN to abort
Xwhat you are currently doing.  Most of the time '?' or 'help' followed by
XRETURN will get you more information on what you are expected to type in next.
X     If for some reason you wish to terminate the rolodex program without
Xsaving any changes you have made, hold down the CTRL key and type 'c'.
X
X     When you are searching for information, typing in any part of the
Xinformation that uniquely identifies it is good enough.  For instance, if you
Xwere looking for John Finklesnort, typing 'John' is probably not a good idea
Xbecause you probably have a few names that contain 'John', but typing 'Finkle'
Xor 'snort' will probably uniquely identify the entry you want.  The search
Xprogram is completely case-insensitive.
X     The rolodex search is completely case-insensitive (e.g., searching for
X'Finkle' is the same as searching for 'finkle' is the same as 'fInKLe').
X
END_OF_FILE
if test 1391 -ne `wc -c <'./helplib/moption.hlp'`; then
    echo shar: \"'./helplib/moption.hlp'\" unpacked with wrong size!
fi
# end of './helplib/moption.hlp'
fi
if test -f './helplib/moptions.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/moptions.hlp'\"
else
echo shar: Extracting \"'./helplib/moptions.hlp'\" \(748 characters\)
sed "s/^X//" >'./helplib/moptions.hlp' <<'END_OF_FILE'
XThis is the TMC Rolodex, an online way to store and retrieve information
Xabout people you know, and other important pieces of data.
X
XAt any time you can type the character '\' followed by RETURN to abort
Xwhat you are currently doing.  Most of the time '?' or 'help' followed by
XRETURN will get you more information on what you are expected to type in
Xnext.
X
XAt the Top Level Menu, which you are currently at, you can type the following:
X
X'+'     to begin entering information about a new person.
X'%'     to begin scanning your rolodex, entry by entry.
X'!'     to print out your rolodex in a nice format.
X'*'     to save any changes you have made to your rolodex.
X'\'     to exit the rolodex program.
X
XIf you wish to find an already existing entry
X
END_OF_FILE
if test 748 -ne `wc -c <'./helplib/moptions.hlp'`; then
    echo shar: \"'./helplib/moptions.hlp'\" unpacked with wrong size!
fi
# end of './helplib/moptions.hlp'
fi
if test -f './helplib/moreflds.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/moreflds.hlp'\"
else
echo shar: Extracting \"'./helplib/moreflds.hlp'\" \(423 characters\)
sed "s/^X//" >'./helplib/moreflds.hlp' <<'END_OF_FILE'
XAll basic fields for the new entry have either been entered or skipped at
Xthis point.  You may either save the entry now, or you may create your own
Xcustom fields, consisting of user-defined field names and contents.  These
Xfields can be selected later by name for content searches in the same way
Xas the basic fields.
X
XTo create user fields, answer 'y' to the prompt.
XTo terminate the entry now, answer 'n' to the prompt.
END_OF_FILE
if test 423 -ne `wc -c <'./helplib/moreflds.hlp'`; then
    echo shar: \"'./helplib/moreflds.hlp'\" unpacked with wrong size!
fi
# end of './helplib/moreflds.hlp'
fi
if test -f './helplib/newadd.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/newadd.hlp'\"
else
echo shar: Extracting \"'./helplib/newadd.hlp'\" \(195 characters\)
sed "s/^X//" >'./helplib/newadd.hlp' <<'END_OF_FILE'
XAt this point, you have the choice of adding the newly-created entry to
Xthe Rolodex database, or aborting this action.  If you abort, all information
Xentered for the new entry will be discarded.
END_OF_FILE
if test 195 -ne `wc -c <'./helplib/newadd.hlp'`; then
    echo shar: \"'./helplib/newadd.hlp'\" unpacked with wrong size!
fi
# end of './helplib/newadd.hlp'
fi
if test -f './helplib/otherfmt.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/otherfmt.hlp'\"
else
echo shar: Extracting \"'./helplib/otherfmt.hlp'\" \(770 characters\)
sed "s/^X//" >'./helplib/otherfmt.hlp' <<'END_OF_FILE'
XIn addition to the fixed fields in a Rolodex entry, you may add an arbitrary
Xnumber of fields for which you choose the field name and meaning.  The way
Xyou define these fields is slightly different than for the fixed fields,
Xsince you must provide not only the field contents but also the name of
Xthe field; this is done by typing the name, followed by a colon (:), and
Xthen the contents of the field as for the basic items.  Note that you may
Xelect only to create the field with no contents, by typing the name and
Xa colon.  To terminate creation of new fields, simply type a return with
Xno field name or delimiter.
X
XAt the "<name>: data" prompt, you may also enter the following responses:
X
X	\:	Abort
X	?:	This help menu
X	^:	Delete the last user-defined field entered
X
END_OF_FILE
if test 770 -ne `wc -c <'./helplib/otherfmt.hlp'`; then
    echo shar: \"'./helplib/otherfmt.hlp'\" unpacked with wrong size!
fi
# end of './helplib/otherfmt.hlp'
fi
if test -f './helplib/pkentry.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/pkentry.hlp'\"
else
echo shar: Extracting \"'./helplib/pkentry.hlp'\" \(399 characters\)
sed "s/^X//" >'./helplib/pkentry.hlp' <<'END_OF_FILE'
XAfter requesting a field search, you have been presented with a menu of
Xmatching entries.  You may enter the following responses:
X
XCarriage return :       Scan the entries, one by one, in the order given.
X
XEntry number    :       Each entry is numbered; examine the entry for which
X                        you've entered the corresponding number.
X
X\               :       Return to the main menu.
X
X
END_OF_FILE
if test 399 -ne `wc -c <'./helplib/pkentry.hlp'`; then
    echo shar: \"'./helplib/pkentry.hlp'\" unpacked with wrong size!
fi
# end of './helplib/pkentry.hlp'
fi
if test -f './helplib/pkntmenu.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/pkntmenu.hlp'\"
else
echo shar: Extracting \"'./helplib/pkntmenu.hlp'\" \(131 characters\)
sed "s/^X//" >'./helplib/pkntmenu.hlp' <<'END_OF_FILE'
XType number of the entry you wish to view,
Xor type RETURN to view each entry one by one,
Xor type '\' to go back to the main menu.
X
END_OF_FILE
if test 131 -ne `wc -c <'./helplib/pkntmenu.hlp'`; then
    echo shar: \"'./helplib/pkntmenu.hlp'\" unpacked with wrong size!
fi
# end of './helplib/pkntmenu.hlp'
fi
if test -f './helplib/poptions.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/poptions.hlp'\"
else
echo shar: Extracting \"'./helplib/poptions.hlp'\" \(649 characters\)
sed "s/^X//" >'./helplib/poptions.hlp' <<'END_OF_FILE'
XAt this point you can type the following:
X
Xthe RETURN key.
Xthe 'n' key followed by RETURN.
Xthe '\' (backslash) key followed by RETURN.
X
XIf you used the rolodex program by typing something like 'rolo john'
Xthen typing RETURN will find for you the next person in your rolodex
Xwho has the letters 'john' as part of their name.
X
XIf you used the rolodex program by typing something like 'rolo john mary'
Xthen typing 'n' after the program had displayed one of the people whose
Xname contained 'john' would stop the program from looking for any more
X'john's and start looking for 'mary'.
X
XIf you just wish to exit the program type the backslash character.
X
END_OF_FILE
if test 649 -ne `wc -c <'./helplib/poptions.hlp'`; then
    echo shar: \"'./helplib/poptions.hlp'\" unpacked with wrong size!
fi
# end of './helplib/poptions.hlp'
fi
if test -f './helplib/poptmenu.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/poptmenu.hlp'\"
else
echo shar: Extracting \"'./helplib/poptmenu.hlp'\" \(151 characters\)
sed "s/^X//" >'./helplib/poptmenu.hlp' <<'END_OF_FILE'
XOPTIONS:
X   RETURN  -- continue looking for same name.
X   'n'     -- look for the next name you asked about.
X   '\'     -- abort the rolodex program.
X
END_OF_FILE
if test 151 -ne `wc -c <'./helplib/poptmenu.hlp'`; then
    echo shar: \"'./helplib/poptmenu.hlp'\" unpacked with wrong size!
fi
# end of './helplib/poptmenu.hlp'
fi
if test -f './helplib/srchstr.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/srchstr.hlp'\"
else
echo shar: Extracting \"'./helplib/srchstr.hlp'\" \(242 characters\)
sed "s/^X//" >'./helplib/srchstr.hlp' <<'END_OF_FILE'
XYou are being asked to enter a character string to be used for a field content
Xsearch.  This string may either be the entire value to be found, or any
Xsubstring; it is case-insensitive.  Please note the you do NOT have wildcard
Xcapabilities.
END_OF_FILE
if test 242 -ne `wc -c <'./helplib/srchstr.hlp'`; then
    echo shar: \"'./helplib/srchstr.hlp'\" unpacked with wrong size!
fi
# end of './helplib/srchstr.hlp'
fi
if test -f './helplib/update.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/update.hlp'\"
else
echo shar: Extracting \"'./helplib/update.hlp'\" \(1254 characters\)
sed "s/^X//" >'./helplib/update.hlp' <<'END_OF_FILE'
XYou have asked to change some information contained in the entry that was
Xbeing displayed before you typed '+'.  If this is not what you want type '\'
XRETURN to get back to the main menu.
X
XCurrently, the program is displaying the name of each item in the entry and
Xits contents (some items may have no contents).  Each item is numbered.
XSimply type the number of the item whose contents you wish to change.  The
Xprogram will then display the old contents of the item and ask you to type in
Xsome text which will become the new contents.  Once you have done this for
Xeach item you wish to change, type RETURN when it again asks for you an item
Xnumber.  It will then print out the revised entry one more time, and ask you
Xto confirm all your changes.  You can abort all your changes for this entry at
Xany time by typing '\' RETURN.
X
XYou can also add new items to this entry.  The last numbered choice is not an
Xitem name but an option to allow you to do this.  Type this number (now 8) and
Xyou will be prompted for the name and contents of a new field.  For instance
Xyou might want to add an item called 'Net Address' with a value 'cca!alex'.
XWhen prompted you would type 'Net Address: cca!alex' RETURN.  You stop adding
Xnew items by typing just a RETURN.
X
END_OF_FILE
if test 1254 -ne `wc -c <'./helplib/update.hlp'`; then
    echo shar: \"'./helplib/update.hlp'\" unpacked with wrong size!
fi
# end of './helplib/update.hlp'
fi
if test -f './helplib/updatmnu.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/updatmnu.hlp'\"
else
echo shar: Extracting \"'./helplib/updatmnu.hlp'\" \(126 characters\)
sed "s/^X//" >'./helplib/updatmnu.hlp' <<'END_OF_FILE'
XType number of the item you wish to change,
Xor type RETURN to finalize your changes,
Xor type '\' to cancel all your changes.
X
END_OF_FILE
if test 126 -ne `wc -c <'./helplib/updatmnu.hlp'`; then
    echo shar: \"'./helplib/updatmnu.hlp'\" unpacked with wrong size!
fi
# end of './helplib/updatmnu.hlp'
fi
if test -f './helplib/usrfld.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./helplib/usrfld.hlp'\"
else
echo shar: Extracting \"'./helplib/usrfld.hlp'\" \(644 characters\)
sed "s/^X//" >'./helplib/usrfld.hlp' <<'END_OF_FILE'
XYou may enter the name of any user-defined field to use as the search target
Xfield; you will then be asked for a search string in the field.  While the
Xfield name entered must match exactly the user-defined field name in spelling
Xand length, it is case-insensitive; thus, field name 'Site' will be matched
Xif you ask for 'SITE','site', or 'SiTe'.
X
XThere is no way, within the rolodex program, of determining the existence
Xof a particular user field name; it is therefore the user's responsibility
Xto remember what names have been used.  (Examining the rolodex database,
Xor printing it out, will, however, allow examination of all user fields.)
END_OF_FILE
if test 644 -ne `wc -c <'./helplib/usrfld.hlp'`; then
    echo shar: \"'./helplib/usrfld.hlp'\" unpacked with wrong size!
fi
# end of './helplib/usrfld.hlp'
fi
if test -f './makefile.vms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./makefile.vms'\"
else
echo shar: Extracting \"'./makefile.vms'\" \(970 characters\)
sed "s/^X//" >'./makefile.vms' <<'END_OF_FILE'
X# Makefile for rolo - VAX/VMS Specific version
X
X#TERMSTUFF= /DEFINE=(TERMCAP)
XTERMSTUFF=
X#
X
XTOOLDIR = gal_usrdisk:[ignatz.src.rolo.toolsdir]
X
X#CDBGFLAG = /DEBUG/NOOPT
XCDBFLAG =
X
X#LDBGFLAG = /DEBUG
XLDBGFLAG  =
X
XCFLAGS = $(TERMSTUFF) $(CDBGFLAG)
XLDFLAGS= $(LDBGFLAG)
X                    
XSOURCES = clear.c,io.c,menuaux.c,operatns.c,options.c, -
X	rlist.c,rolo.c,search.c,update.c
X
XOBJECTS = clear.obj,io.obj,menuaux.obj,operatns.obj,options.obj, -
X	rlist.obj,rolo.obj,search.obj,update.obj
X
XTOOLOBJ = $(TOOLDIR)mem.obj,$(TOOLDIR)args.obj,$(TOOLDIR)ctools.obj, -
X	$(TOOLDIR)menu.obj
X
XBIN = $gal_usrdisk:[ignatz.bin]
X
XLIBS = lib:libutils/lib
X
Xrolo : setup,$(OBJECTS)
X	set default $(TOOLDIR)
X	mms tools/descrip=makefile.vms
X	set default [-]
X	link /exec=rolo.exe $(LDFLAGS) $(OBJECTS),$(TOOLOBJ),$(LIBS)
X
Xsetup :
X	cinclude local $(TOOLDIR)
X	clib curses
X
Xinstall : rolo
X	del $(BIN)rolo.exe;*
X	rename rolo.exe $(BIN)rolo.exe
X
Xclean :
X	del $(OBJECTS),rolo.exe,foo,$(TOOLDIR)*.obj
END_OF_FILE
if test 970 -ne `wc -c <'./makefile.vms'`; then
    echo shar: \"'./makefile.vms'\" unpacked with wrong size!
fi
# end of './makefile.vms'
fi
if test -f './menuaux.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./menuaux.c'\"
else
echo shar: Extracting \"'./menuaux.c'\" \(1450 characters\)
sed "s/^X//" >'./menuaux.c' <<'END_OF_FILE'
X/* menuaux.c */
X#include <stdio.h>
X#include <ctype.h>
X
X#ifdef TMC
X#include <ctools.h>
X#else
X#include "ctools.h"
X#endif
X#include "args.h"
X#include "menu.h"
X
X#include "rolofilz.h"
X#include "rolodefs.h"
X#include "datadef.h"
X
X
Xrolo_menu_yes_no (prompt,rtn_default,help_allowed,helpidx,subject)
X
X  char *prompt;
X  int rtn_default;
X  int help_allowed;
X  int helpidx;
X  char *subject;
X  
X{
X  int rval;
X  reask :
X  rval = menu_yes_no_abort_or_help (
X              prompt,ABORTSTRING,help_allowed,rtn_default
X           );
X  switch (rval) {
X    case MENU_EOF :
X      user_eof();
X      break;
X    case MENU_HELP : 
X      cathelpfile(helpidx,subject,1);
X      goto reask;
X      /* break; */
X    default :
X      return(rval);
X      /* break; */
X  }
X
X  return(0);
X}
X  
X
Xrolo_menu_data_help_or_abort (prompt,helpidx,subject,ptr_response)
X
X  char *prompt;
X  int helpidx;
X  char *subject;
X  char **ptr_response;
X  
X{ 
X  int rval;
X  reask :
X  rval = menu_data_help_or_abort(prompt,ABORTSTRING,ptr_response);
X  if (rval == MENU_EOF) user_eof();
X  if (rval == MENU_HELP) {
X     cathelpfile(helpidx,subject,1);
X     goto reask;
X  }     
X  return(rval);
X}
X     
X
Xrolo_menu_number_help_or_abort (prompt,low,high,ptr_ival)
X
X  char *prompt;
X  int low,high,*ptr_ival;
X  
X{  
X  int rval;
X  if (MENU_EOF == (rval = menu_number_help_or_abort (
X                               prompt,ABORTSTRING,low,high,ptr_ival
X                           )))
X     user_eof();
X  return(rval);
X}
END_OF_FILE
if test 1450 -ne `wc -c <'./menuaux.c'`; then
    echo shar: \"'./menuaux.c'\" unpacked with wrong size!
fi
# end of './menuaux.c'
fi
if test -f './respfile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./respfile'\"
else
echo shar: Extracting \"'./respfile'\" \(1326 characters\)
sed "s/^X//" >'./respfile' <<'END_OF_FILE'
XFrom steiner%bvaxb.decnet@bvaxa Mon Nov 16 10:19:09 1987
XReturn-Path: <steiner%bvaxb.decnet@bvaxa>
XReceived: from bvaxa by risuna.com (3.2/SMI-3.2)
X	id AA09220; Mon, 16 Nov 87 10:19:06 CST
XMessage-Id: <8711161619.AA09220@risuna.com>
XDate: 16 Nov 87 10:11:00 CDT
XFrom: "BVAXB::STEINER" <steiner%bvaxb.decnet@bvaxa>
XSubject: respfile
XTo: "steiner" <steiner@risuna.com>
XReply-To: "BVAXB::STEINER" <steiner%bvaxb.decnet@bvaxa>
XStatus: R
X
X
XCLEAR.OBJ+
XIO.OBJ+
XMENUAUX.OBJ+
XOPERATNS.OBJ+
XOPTIONS.OBJ+
XRLIST.OBJ+
XROLO.OBJ+
XSEARCH.OBJ+
XUPDATE.OBJ+
XTOOLSDIR\ARGS.OBJ+
XTOOLSDIR\CTOOLS.OBJ+
XTOOLSDIR\CTOOLS.OBJ+
XTOOLSDIR\MEM.OBJ+
XTOOLSDIR\MENU.OBJ+
XTOOLSDIR\MENU.OBJ
X------
X
XFrom steiner%bvaxb.decnet@bvaxa Mon Nov 16 10:19:09 1987
XReturn-Path: <steiner%bvaxb.decnet@bvaxa>
XReceived: from bvaxa by risuna.com (3.2/SMI-3.2)
X	id AA09220; Mon, 16 Nov 87 10:19:06 CST
XMessage-Id: <8711161619.AA09220@risuna.com>
XDate: 16 Nov 87 10:11:00 CDT
XFrom: "BVAXB::STEINER" <steiner%bvaxb.decnet@bvaxa>
XSubject: respfile
XTo: "steiner" <steiner@risuna.com>
XReply-To: "BVAXB::STEINER" <steiner%bvaxb.decnet@bvaxa>
XStatus: R
X
X
XCLEAR.OBJ+
XIO.OBJ+
XMENUAUX.OBJ+
XOPERATNS.OBJ+
XOPTIONS.OBJ+
XRLIST.OBJ+
XROLO.OBJ+
XSEARCH.OBJ+
XUPDATE.OBJ+
XTOOLSDIR\ARGS.OBJ+
XTOOLSDIR\CTOOLS.OBJ+
XTOOLSDIR\CTOOLS.OBJ+
XTOOLSDIR\MEM.OBJ+
XTOOLSDIR\MENU.OBJ+
XTOOLSDIR\MENU.OBJ
X------
X
END_OF_FILE
if test 1326 -ne `wc -c <'./respfile'`; then
    echo shar: \"'./respfile'\" unpacked with wrong size!
fi
# end of './respfile'
fi
if test -f './rolodefs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rolodefs.h'\"
else
echo shar: Extracting \"'./rolodefs.h'\" \(722 characters\)
sed "s/^X//" >'./rolodefs.h' <<'END_OF_FILE'
X/* rolodefs.h */
X#define VERSION "2.0.2"
X
X#ifdef VMS
X#define CHUNKSIZE 100000        /* storage size for holding data file */
X#endif
X
X#ifdef UNIX
X#define CHUNKSIZE ((unsigned)100000) /* storage size for holding data file */
X#endif
X
X#ifdef MSDOS
X#define CHUNKSIZE ((unsigned)50000)  /* storage size for holding data file */
X#endif
X
X#define NOLOCKFLAG 'l'
X#define SUMMARYFLAG 's'
X#define OTHERUSERFLAG 'u'
X#define READONLYFLAG 'r'
X
X#define LEGAL_OPTIONS "lsru"
X#ifdef VMS
X#define USAGE "rolo [ person1 person2 ...] [ -l -s -r -u use_dir ] "
X#endif
X
X#ifdef UNIX
X#define USAGE "rolo [ person1 person2 ...] [ -l -s -r -u user ] "
X#endif
X
X#ifdef MSDOS
X#define USAGE "rolo [ person1 person2 ...] [ -l -s -r -u use_dir ] "
X#endif
END_OF_FILE
if test 722 -ne `wc -c <'./rolodefs.h'`; then
    echo shar: \"'./rolodefs.h'\" unpacked with wrong size!
fi
# end of './rolodefs.h'
fi
if test -f './rolofilz.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rolofilz.h'\"
else
echo shar: Extracting \"'./rolofilz.h'\" \(2280 characters\)
sed "s/^X//" >'./rolofilz.h' <<'END_OF_FILE'
X/* rolofilz.h */
X#ifdef UNIX
X#define ROLOBAK ".rolodex~"
X#define ROLODATA ".rolodex.dat"
X#define ROLOPRINT "roloprint.text"
X#define ROLOLOCK ".rolodexdata.lock"
X#define ROLOTEMP ".rolotemp"
X#define ROLOCOPY ".rolocopy"
X#endif
X
X#ifdef VMS
X#define ROLOBAK "rolodex.bak"
X#define ROLODATA "rolodex.data"
X#define ROLOPRINT "roloprint.text"
X#define ROLOLOCK "rolodexdata.lock"
X#define ROLOTEMP "rolotemp.data"
X#define ROLOCOPY "rolocopy.data"
X#endif
X
X#ifdef MSDOS
X#define ROLOBAK "rolodex.bak"
X#define ROLODATA "rolodex.dat"
X#define ROLOPRINT "roloprnt.txt"
X#define ROLOLOCK "rolodata.lck"
X#define ROLOTEMP "rolotemp.dat"
X#define ROLOCOPY "rolocopy.dat"
X#endif
X
X/* This is now defined in the Makefile (except for VMS) */
X
X/*  #define ROLOLIB "/usr/local/lib/rolo"  */
X#ifdef VMS
X#define	ROLOLIB "gal_usrdisk:[ignatz.lib.rololib]"
X#endif
X
X/*
X * These definitions go with the hlpfiles[] array in IO.C; do *not* change
X * the value any of these definitions, or funny things will happen to your
X * help definitions!  These values are actually array index values to that
X * array, and as such, modification will cause the help routine to point
X * the wrong file...
X *
X * Adding help files consists of both defining the offset here, and entering
X * the filename in hlpfiles[] in IO.C.
X */
X#define	ADDHELP			0
X#define ADDINFO 		(ADDHELP + 1)
X#define	CONFIRMHELP		(ADDINFO + 1)
X#define ENTRYMENU		(CONFIRMHELP + 1)
X#define	ESCANHELP		(ENTRYMENU + 1)
X#define	ESEARCHHELP		(ESCANHELP + 1)
X#define	FIELDSEARCHHELP		(ESEARCHHELP + 1)
X#define	LOCKINFO		(FIELDSEARCHHELP + 1)
X#define	MAINMENU    		(LOCKINFO + 1)
X#define	MANYMATCHHELP		(MAINMENU + 1)
X#define	MOPTIONHELP		(MANYMATCHHELP + 1)
X#define	MOPTIONSHELP		(MOPTIONHELP + 1)
X#define	MOREFIELDSHELP		(MOPTIONSHELP + 1)
X#define	NEWADDHELP		(MOREFIELDSHELP + 1)
X#define	OTHERFORMATHELP		(NEWADDHELP + 1)
X#define	PICKENTRYHELP  		(OTHERFORMATHELP + 1)
X#define	PICKENTRYMENU		(PICKENTRYHELP + 1)
X#define	POPTIONMENU		(PICKENTRYMENU + 1)
X#define	POPTIONSHELP		(POPTIONMENU + 1)
X#define	SEARCHSTRINGHELP	(POPTIONSHELP + 1)
X#define	UPDATEHELP		(SEARCHSTRINGHELP + 1)
X#define	UPDATEMENU		(UPDATEHELP + 1)
X#define	USERFIELDHELP		(UPDATEMENU + 1)
X
X/* Use this to validate given index values */
X#define LAST_HELP ((sizeof(hlpfiles) / sizeof(char *)) - 1)
END_OF_FILE
if test 2280 -ne `wc -c <'./rolofilz.h'`; then
    echo shar: \"'./rolofilz.h'\" unpacked with wrong size!
fi
# end of './rolofilz.h'
fi
if test ! -d './toolsdir' ; then
    echo shar: Creating directory \"'./toolsdir'\"
    mkdir './toolsdir'
fi
if test -f './toolsdir/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./toolsdir/Makefile'\"
else
echo shar: Extracting \"'./toolsdir/Makefile'\" \(191 characters\)
sed "s/^X//" >'./toolsdir/Makefile' <<'END_OF_FILE'
X# Rolodex Tools makefile - Generic UNIX
XCC = ccsh
XCFLAGS  = -DSYS5 -DUNIX -O
XDBGFLAG =
XSOURCES = mem.c ctools.c args.c menu.c
XOBJECTS = mem.o ctools.o args.o menu.o
XLIBS =
X
Xtools: $(OBJECTS)
END_OF_FILE
if test 191 -ne `wc -c <'./toolsdir/Makefile'`; then
    echo shar: \"'./toolsdir/Makefile'\" unpacked with wrong size!
fi
# end of './toolsdir/Makefile'
fi
if test -f './toolsdir/Makefile.msc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./toolsdir/Makefile.msc'\"
else
echo shar: Extracting \"'./toolsdir/Makefile.msc'\" \(553 characters\)
sed "s/^X//" >'./toolsdir/Makefile.msc' <<'END_OF_FILE'
X# Rolodex Tools makefile - PC/MS-DOS Version (Microsoft C)
X#
X# :ts=8
X# :bk=0
X# :ma=1
X#
XCC = msc
X#OPTDBG = /Zi
XOPTDBG = /Os
XCFLAGS  = /DMSDOS /DSYS5 $(OPTDBG)
XDBGFLAG = 
XSOURCES = ctools.c menu.c args.c mem.c
XOBJECTS = ctools.obj menu.obj args.obj mem.obj
XLIBOBJECTS = ctools.obj+menu.obj+args.obj+mem.obj
XLIBS =
X
X.c.obj:
X	$(CC) $(CFLAGS) $*.c;
X
Xmem.obj:		mem.c sys5.h
X
Xctools.obj:	ctools.c sys5.h ctools.h basics.h
X
Xargs.obj:		args.c basics.h args.h sys5.h
X
Xmenu.obj:		menu.c basics.h ctools.h menu.h sys5.h
X
Xtools:	$(OBJECTS)
X	lib tools $(LIBOBJECTS);
END_OF_FILE
if test 553 -ne `wc -c <'./toolsdir/Makefile.msc'`; then
    echo shar: \"'./toolsdir/Makefile.msc'\" unpacked with wrong size!
fi
# end of './toolsdir/Makefile.msc'
fi
if test -f './toolsdir/Makefile.tc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./toolsdir/Makefile.tc'\"
else
echo shar: Extracting \"'./toolsdir/Makefile.tc'\" \(247 characters\)
sed "s/^X//" >'./toolsdir/Makefile.tc' <<'END_OF_FILE'
X# Rolodex Tools makefile - PC/MS-DOS Version (Turbo-C)
XCC = tcc
XCFLAGS  = -O -DMSDOS -DSYS5
XDBGFLAG = 
XSOURCES = mem.c ctools.c args.c menu.c
XOBJECTS = mem.obj ctools.obj args.obj menu.obj
XLIBS =
X
X.c.obj:
X	$(CC) $(CFLAGS) -c $<
X
Xtools: $(OBJECTS)
END_OF_FILE
if test 247 -ne `wc -c <'./toolsdir/Makefile.tc'`; then
    echo shar: \"'./toolsdir/Makefile.tc'\" unpacked with wrong size!
fi
# end of './toolsdir/Makefile.tc'
fi
if test -f './toolsdir/Makefile.unx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./toolsdir/Makefile.unx'\"
else
echo shar: Extracting \"'./toolsdir/Makefile.unx'\" \(189 characters\)
sed "s/^X//" >'./toolsdir/Makefile.unx' <<'END_OF_FILE'
X# Rolodex Tools makefile - Generic UNIX
XCC = cc
XCFLAGS  = -DSYS5 -DUNIX -O
XDBGFLAG =
XSOURCES = mem.c ctools.c args.c menu.c
XOBJECTS = mem.o ctools.o args.o menu.o
XLIBS =
X
Xtools: $(OBJECTS)
END_OF_FILE
if test 189 -ne `wc -c <'./toolsdir/Makefile.unx'`; then
    echo shar: \"'./toolsdir/Makefile.unx'\" unpacked with wrong size!
fi
# end of './toolsdir/Makefile.unx'
fi
if test -f './toolsdir/Makefile.vms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./toolsdir/Makefile.vms'\"
else
echo shar: Extracting \"'./toolsdir/Makefile.vms'\" \(228 characters\)
sed "s/^X//" >'./toolsdir/Makefile.vms' <<'END_OF_FILE'
X# Makefile - rolo tools (VAX/VMS Version)
XCFLAGS  = /DEFINE=(SYS5)
XDBGFLAG = 
XSOURCES = mem.c,ctools.c,args.c,menu.c
XOBJECTS = mem.obj,ctools.obj,args.obj,menu.obj
XLIBS =
X
Xtools : $(OBJECTS)
X	@ write sys$output "Tools updated."
END_OF_FILE
if test 228 -ne `wc -c <'./toolsdir/Makefile.vms'`; then
    echo shar: \"'./toolsdir/Makefile.vms'\" unpacked with wrong size!
fi
# end of './toolsdir/Makefile.vms'
fi
if test -f './toolsdir/args.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./toolsdir/args.h'\"
else
echo shar: Extracting \"'./toolsdir/args.h'\" \(2401 characters\)
sed "s/^X//" >'./toolsdir/args.h' <<'END_OF_FILE'
X/* You must include "basics.h" to use this */
X
X/* To use this package, first call get_args, then call the various other */
X/* routines to see which options were given, etc. */
X
X#define NIL 0                          /* null pointer  */
X
X#define ARG_ERROR -1
X#define NO_ARGS 0
X#define ARGS_PRESENT 1
X
X#define MAX_OPTIONS 52                 /* a-z A-Z */
X#define NO_OPTION -1
X
X/* an argument and the option it is associated with */
X
Xtypedef struct argument {
X        char *option;
X        int option_index;
X        struct argument *next;
X} Cmd_Arg, *Ptr_Cmd_Arg;
X
X/* all the arguments (in a list) and a toggle for every possible option */
X
Xtypedef struct {
X        Ptr_Cmd_Arg non_dash_arg_list; 
X        int dash_options[MAX_OPTIONS];
X} Cmd_Line, *Ptr_Cmd_Line;
X
X/*--------------------------------------------------------------------------*/
X        
Xextern char *malloc();
X
Xextern int get_args();
X
X        /* int argc; char **argv; Bool dup_error; Bool print_msg; */
X        /* returns one of ARG_ERROR, NO_ARGS, or ARGS_PRESENT */
X        /* if dup_error, then having two identical options on the command */
X        /* line will cause an error.  If print_msg, then  any error that */
X        /* is noticed is printed out to stderr.  If !dup_error then */
X        /* 'foo -a 3 4 -b -a 5' is equivalent to 'foo -a 3 4 5 -b' */
X        
X        
Xextern Bool any_option_present();
X
X        /* no arguments */
X
Xextern Bool option_present();
X
X        /* char achar; */
X
Xextern char * option_arg();
X
X        /* char achar; int n; */
X
Xextern char * non_option_arg();
X
X        /* int n; */
X
Xextern int n_option_args();
X
X        /* char achar; */
X
Xextern int n_non_option_args();
X
X        /* no arguments */
X
Xextern int n_non_dash_args();
X
X        /* no arguments */
X
Xextern Bool check_option_args();        
X
X        /* char achar; int min; int max; */
X
X#define ALL_LEGAL 0
X
Xextern char legal_options();
X
X        /* char *legaloptions; */
X        /* legaloptions should be a string of characters all in the range */
X        /* a-zA-Z.   Returns ALL_LEGAL if every option parsed in included */
X        /* in the legaloptions string, otherwise returns the first option */
X        /* character not in the string. */
X
Xextern set_option();
X
X        /* char achar */
X
Xextern error_message();
X
X        /* char *progname; char **argv; int index; char *usage; */
X
Xextern print_args();
X
X        /* debugging routine */
END_OF_FILE
if test 2401 -ne `wc -c <'./toolsdir/args.h'`; then
    echo shar: \"'./toolsdir/args.h'\" unpacked with wrong size!
fi
# end of './toolsdir/args.h'
fi
if test -f './toolsdir/basics.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./toolsdir/basics.h'\"
else
echo shar: Extracting \"'./toolsdir/basics.h'\" \(596 characters\)
sed "s/^X//" >'./toolsdir/basics.h' <<'END_OF_FILE'
X#define T 1
X#define F 0
X
X#define True 1
X#define False 0
X
X#define SUCCESS 1
X#define FAILURE 0
X#define ERROR -1
X
X#define Bool int
X
X#ifdef VMS
X#ifndef MAXINT
X#define MAXINT 2147483647
X#endif
X
X#ifndef MAXINTSTR
X#define MAXINTSTR "2147483647"
X#endif
X#endif
X
X
X#ifdef UNIX
X#ifndef MAXINT
X#define MAXINT 2147483647
X#endif
X
X#ifndef MAXINTSTR
X#define MAXINTSTR "2147483647"
X#endif
X#endif
X
X#ifdef  MSDOS
X#ifndef MAXINTSTR
Xextern char *itoa();
Xextern char maxintstr[];
X
X#define MAXINT (~(1 << ((sizeof(int) * 8 - 1))))
X#define MAXINTSTR ((*maxintstr=='\0')?itoa(MAXINT,maxintstr,10):maxintstr)
X#endif
X#endif
END_OF_FILE
if test 596 -ne `wc -c <'./toolsdir/basics.h'`; then
    echo shar: \"'./toolsdir/basics.h'\" unpacked with wrong size!
fi
# end of './toolsdir/basics.h'
fi
if test -f './toolsdir/mem.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./toolsdir/mem.c'\"
else
echo shar: Extracting \"'./toolsdir/mem.c'\" \(2261 characters\)
sed "s/^X//" >'./toolsdir/mem.c' <<'END_OF_FILE'
X/**************************************************************************/
X/**************************************************************************/
X
X
X                  /***** Block Memory Allocator *****/
X
X
X/**************************************************************************/
X/**************************************************************************/
X
X/* Author: JP Massar */
X
X#include <stdio.h>
X
X#include "sys5.h"
X
X#ifdef BSD42
X#include <strings.h>
X#endif
X
X#define NO_MORE_MEMORY -1
X
Xstatic int bytes_left;                  /* space left in current block */
Xstatic char *ptr_next_byte;             /* next free byte */
Xstatic char *ptr_space;                 /* current block */
Xstatic unsigned chunk_size;                  /* size of block last allocated */
X
Xextern char *malloc();
X
X
Xunsigned allocate_memory_chunk(space) 
Xunsigned space;
X
X/* malloc up a new block of memory.  Set our static variables */
X/* returns NO_MORE_MEMORY if can't allocate block. */
X
X{ 
X#ifdef MSDOS
X  if ((char *)NULL == (ptr_space = malloc(space))) {
X#else
X  if (0 == (ptr_space = malloc(space))) {
X#endif
X        fprintf(stderr,"fatal error, no more memory\n");
X        return(NO_MORE_MEMORY);
X  }
X  ptr_next_byte = ptr_space;
X  bytes_left = space;
X  chunk_size = space;
X  return(0);
X}
X
X
Xchar * get_memory_chunk (size) unsigned size;
X
X/* allocate a small segment out of our large block of memory.  If we */
X/* run out allocate another block.  Adjust our static variables. */
X/* returns 0 if no more memory. */
X
X{ char *rval;
X        
X  if (size > chunk_size) {
X        fprintf(stderr,"attempt to allocate too large a chunk\n");
X        return(0);
X  }
X        
X  if (size > bytes_left) {
X        if (NO_MORE_MEMORY == allocate_memory_chunk(chunk_size)) {
X                return(0);
X        }
X        return(get_memory_chunk(size));
X  }
X
X  rval = ptr_next_byte;
X  ptr_next_byte += size;
X  bytes_left -= size;
X  return(rval);
X  
X}
X
X
Xchar * store_string (str,len) char *str; unsigned len;
X
X/* put copy of a string into storage in a memory block.  Return a pointer to */
X/* the copied string.  Returns 0 if out of memory. */
X
X{ char *ptr_space;
X
X  if (0 == (ptr_space = get_memory_chunk(len+1))) {
X        return(0);
X  }
X  strcpy(ptr_space,str);
X  return(ptr_space);
X}
END_OF_FILE
if test 2261 -ne `wc -c <'./toolsdir/mem.c'`; then
    echo shar: \"'./toolsdir/mem.c'\" unpacked with wrong size!
fi
# end of './toolsdir/mem.c'
fi
if test -f './toolsdir/mem.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./toolsdir/mem.h'\"
else
echo shar: Extracting \"'./toolsdir/mem.h'\" \(209 characters\)
sed "s/^X//" >'./toolsdir/mem.h' <<'END_OF_FILE'
Xextern int allocate_memory_chunk();     /* arg1: int space */
X       
Xextern char * get_memory_chunk();       /* arg1: int size */
X
Xextern char * store_string();           /* arg1: char *str, arg2: int len */
END_OF_FILE
if test 209 -ne `wc -c <'./toolsdir/mem.h'`; then
    echo shar: \"'./toolsdir/mem.h'\" unpacked with wrong size!
fi
# end of './toolsdir/mem.h'
fi
if test -f './toolsdir/sys5.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./toolsdir/sys5.h'\"
else
echo shar: Extracting \"'./toolsdir/sys5.h'\" \(102 characters\)
sed "s/^X//" >'./toolsdir/sys5.h' <<'END_OF_FILE'
X#ifdef SYS5
X#define rindex strrchr
X#define index strchr
X#ifndef VMS
X#include <string.h>
X#endif
X#endif
END_OF_FILE
if test 102 -ne `wc -c <'./toolsdir/sys5.h'`; then
    echo shar: \"'./toolsdir/sys5.h'\" unpacked with wrong size!
fi
# end of './toolsdir/sys5.h'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2094 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X .                         1	
X ./Makefile.bsd            1	
X ./Makefile.msc            1	
X ./Makefile.tc             1	
X ./Makefile.unx            1	
X ./Part01                  1	
X ./README.Z                1	
X ./choices.h               1	
X ./clear.c                 1	
X ./datadef.h               2	
X ./helplib                 1	
X ./helplib/addhelp.hlp     1	
X ./helplib/addinfo.hlp     1	
X ./helplib/confirm.hlp     1	
X ./helplib/entrymnu.hlp    1	
X ./helplib/escan.hlp       1	
X ./helplib/esearch.hlp     1	
X ./helplib/fldsrch.hlp     1	
X ./helplib/lockinfo.dos    1	
X ./helplib/lockinfo.unx    1	
X ./helplib/lockinfo.vms    1	
X ./helplib/mainmenu.hlp    1	
X ./helplib/mnymtch.hlp     1	
X ./helplib/moption.hlp     1	
X ./helplib/moptions.hlp    1	
X ./helplib/moreflds.hlp    1	
X ./helplib/newadd.hlp      1	
X ./helplib/otherfmt.hlp    1	
X ./helplib/pkentry.hlp     1	
X ./helplib/pkntmenu.hlp    1	
X ./helplib/poptions.hlp    1	
X ./helplib/poptmenu.hlp    1	
X ./helplib/srchstr.hlp     1	
X ./helplib/update.hlp      1	
X ./helplib/updatmnu.hlp    1	
X ./helplib/usrfld.hlp      1	
X ./io.c                    3	
X ./makefile.vms            1	
X ./menuaux.c               1	
X ./operatns.c              3	
X ./options.c               2	
X ./respfile                1	
X ./rlist.c                 2	
X ./rolo.1                  2	
X ./rolo.c                  3	
X ./rolodefs.h              1	
X ./rolofilz.h              1	
X ./search.c                2	
X ./toolsdir                1	
X ./toolsdir/Makefile       1	
X ./toolsdir/Makefile.msc   1	
X ./toolsdir/Makefile.tc    1	
X ./toolsdir/Makefile.unx   1	
X ./toolsdir/Makefile.vms   1	
X ./toolsdir/args.c         2	
X ./toolsdir/args.h         1	
X ./toolsdir/basics.h       1	
X ./toolsdir/ctools.c       4	
X ./toolsdir/ctools.h       3	
X ./toolsdir/mem.c          1	
X ./toolsdir/mem.h          1	
X ./toolsdir/menu.c         2	
X ./toolsdir/menu.h         2	
X ./toolsdir/sys5.h         1	
X ./update.c                2	
X MANIFEST                  1	This shipping list
END_OF_FILE
if test 2094 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
