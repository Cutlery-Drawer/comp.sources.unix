Subject:  v15i064:  A window manager for X, Part01/04
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Tom LaStrange <esunix!tlastran>
Posting-number: Volume 15, Issue 64
Archive-name: twm/part01


Here is my first source posting to comp.unix.sources.  I hope this is the
appropriate place for this code.  There are 3 shar files for "twm".  Twm
is a window manager for X11.

Twm has never been compiled or run on a System V machine.  All development
was done on a Sun 3 running Release 3.4 of the operating system.  It has
also been run on a VaxStation II and a VaxStation 8000.

Nothing real special you should have to do to compile it.  If you are
running X11R1, you will have to link in the resource manager library in
addition to libX11.a.

We here at E&S have been using twm for almost 6 months now in various
states of development.  I hope you find it to be useful tool.  Twm is my
first, and so far, only X program.  If I'm doing anything blatently wrong,
forgive me.

I would appreciate hearing from those who like it as well as those who
dislike it.

--
Tom LaStrange
Evans & Sutherland Computer Corporation

UUCP Address:  {ihnp4,seismo}!utah-cs!utah-gr!uplherc!esunix!tlastran
Alternate:     {ihnp4,decvax}!decwrl!esunix!tlastran

-------------------------------------------
#! /bin/sh
# This is a shell archive, meaning:
# 1.  Remove everything above the #! /bin/sh line.
# 2.  Save the resulting test in a file
# 3.  Execute the file with /bin/sh (not csh) to create the files:
#
#Makefile
#README
#Sample.twmrc
#gram.y
#lex.l
#add_window.c
#gc.c
#list.c
#twm.c
#parse.c
#
# Created by tlastran (Tom LaStrange) on Fri Apr 15 07:22:56 MDT 1988
#
if test -f 'Makefile'
then
    echo shar: will not over-write existing file "Makefile"
else
echo extracting "Makefile"
sed 's/^X//' >Makefile <<'SHAR_EOF'
X#**********************************************************************
X#
X#  twm Makefile
X#
X#**********************************************************************
X
X.SUFFIXES: .y .o
X
X.y.o:
X	yacc -d $*.y
X	mv y.tab.c $*.c
X	mv y.tab.h $*.h
X	$(CC) -c $(CFLAGS) $*.c
X
X#
X#  If you are running X11R1, then you must use the resource manager
X#  library in addition to libX11.a
X#
X#LIBS= -lX11 -lXrm
XLIBS= -lX11
X
XCFLAGS= -O
XLDFLAGS=
X
XO_FILES=\
X        gram.o\
X        lex.o\
X        add_window.o\
X        gc.o\
X        list.o\
X        twm.o\
X        parse.o\
X        menus.o\
X        events.o\
X        resize.o\
X        util.o\
X        version.o
X
X
Xtwm:	$(O_FILES)
X	cc $(LDFLAGS) -o twm $(O_FILES) $(LIBS)
X
X#
X#  Dependencies
X#
Xgram.o: \
X	twm.h \
X	menus.h \
X	list.h
Xlex.o: \
X	gram.h
Xutil.o: \
X	twm.h \
X	gram.h
Xresize.o: \
X	twm.h \
X	util.h \
X	resize.h \
X	resize.bm \
X	focus.bm
Xevents.o: \
X	twm.h \
X	add_window.h \
X	menus.h \
X	events.h \
X	resize.h \
X	gram.h \
X	twm.bm
Xmenus.o: \
X	twm.h \
X	gc.h \
X	menus.h \
X	events.h \
X	util.h \
X	gram.h \
X	pull.bm
Xparse.o: \
X	twm.h \
X	menus.h \
X	util.h
Xtwm.o: \
X	twm.h \
X	add_window.h \
X	gc.h \
X	parse.h \
X	version.h \
X	menus.h \
X	events.h \
X	util.h \
X	twm.bm
Xlist.o: \
X	twm.h \
X	gram.h
Xgc.o: \
X	twm.h
Xadd_window.o: \
X	twm.h \
X	util.h \
X	resize.h \
X	gram.h \
X	list.h \
X	iconify.bm \
X	resize.bm \
X	xterm.bm \
X	focus.bm \
X	hilite.bm
Xlex.o: \
X	gram.h
Xgram.o: \
X	twm.h \
X	menus.h \
X	list.h
SHAR_EOF
if test 1405 -ne "`wc -c < Makefile`"
then
    echo shar: error transmitting "Makefile" '(should have been 1405 characters)'
fi
fi
if test -f 'README'
then
    echo shar: will not over-write existing file "README"
else
echo extracting "README"
sed 's/^X//' >README <<'SHAR_EOF'
XApril 15, 1988
X
XHere you go, here are some things I can think of.
X
XTwm has never been compiled or run on a System V machine.  All
Xdevelopment was done on a Sun 3 running Release 3.4 of the operating system. 
XIt has also been run on a VaxStation II and a VaxStation 8000.  
X
XNothing real special you should have to do to compile it.  If you are
Xrunning X11R1, you will have to link in the resource manager library
Xin addition to libX11.a.
X
XWe here at E&S have been using twm for almost 6 months now in various
Xstates of development.  I hope you find it to be useful tool.
XTwm is my first, and so far, only X program.  If I'm doing anything
Xblatently wrong, forgive me.
X
XI would appreciate hearing from those who like it as well as those who
Xdislike it.
X
X--
XTom LaStrange
X"if you don't like it, don't use it"
X
XEvans & Sutherland Computer Corporation
X
XUUCP Address:  {ihnp4,seismo}!utah-cs!utah-gr!uplherc!esunix!tlastran
XAlternate:     {ihnp4,decvax}!decwrl!esunix!tlastran
SHAR_EOF
if test 972 -ne "`wc -c < README`"
then
    echo shar: error transmitting "README" '(should have been 972 characters)'
fi
fi
if test -f 'Sample.twmrc'
then
    echo shar: will not over-write existing file "Sample.twmrc"
else
echo extracting "Sample.twmrc"
sed 's/^X//' >Sample.twmrc <<'SHAR_EOF'
X#**********************************************************************
X#
X#    .twmrc
X#
X#**********************************************************************
X
X# ReverseVideo
XWarpCursor
XUnknownIcon	"/usr/ias_soft/tlastrange/.icon"
XBorderWidth	2
XTitleFont	"8x13"
XMenuFont	"8x13"
XIconFont	"8x13"
XResizeFont	"fg-22"
X
XButton1		f.menu "button1"
XButton2		f.menu "button2"
XButton3		f.menu "button3"
XButton4		f.nop
XButton5		f.nop
X
XTitleButton1	t.raise
XTitleButton2	t.move
XTitleButton3	t.lower
XTitleButton4	t.nop
XTitleButton5	t.nop
X
XNoTitle
X{
X  "xclock"
X  "xckmail"
X}
X
XAutoRaise
X{
X  "xterm"	# auto-raise all my xterm windows
X}
X
Xmenu "button1"
X{
X"Other Logins"	f.title
X"iguana 24"	!"xterm -T xterm_iguana_24 =80x24+100+100 -e rlogin iguana &"
X"iguana 48"	!"xterm -T xterm_iguana_48 =80x48+50+50 -e rlogin iguana &"
X"worm 24"	!"xterm -T xterm_worm_24 =80x24+100+100 &"
X"worm 48"	!"xterm -T xterm_worm_48 =80x48+50+50 &"
X"shiva"		!"xterm -T xterm_shiva =80x24+200+200 -e rlogin shiva &"
X"tegus"		!"xterm -T xterm_tegus =80x24+200+200 -e rlogin tegus &"
X"shade"		!"xterm -T xterm_shade =80x24+200+200 -e rlogin shade &"
X"bilbo"		!"xterm -T xterm_bilbo =80x24+250+250 -e rlogin bilbo &"
X"frodo"		!"xterm -T xterm_frodo =80x24+300+300 -e rlogin frodo &"
X"esunix"	!"xterm -T xterm_esunix =80x24+350+350 -e rlogin esunix &"
X"lynx8"		!"xterm -T xterm_lynx8 =80x24+370+370 -e rlogin lynx8 &"
X"lynx13"	!"xterm -T xterm_lynx13 =80x24+390+390 -e rlogin lynx13 &"
X"zephyr"	!"xterm -T xterm_zephyr =80x24+390+390 -e rlogin zephyr &"
X}
X
Xmenu "button2"
X{
X"Window Ops"		f.title
X"Refresh"		f.refresh
X"Focus on Root"		f.focus
X"Source .twmrc"		f.twmrc
X"Source blob"		f.source "blob"
X"Cut File"		f.cutfile
X"twm Version"		f.version
X"Kill twm"		f.quit
X}
X
Xmenu "button3"
X{
X"Cut Buffer"		f.title
X"Procedure Header"	f.file "/usr/ias_soft/tlastrange/src/proc.twm"
X"File Header"		f.file "/usr/ias_soft/tlastrange/src/file.twm"
X"pull right"		f.menu "blob"
X}
X
Xmenu "blob"
X{
X"pull right"		f.menu "final"
X"another"		^"some text"
X}
X
Xmenu "final"
X{
X"Cut Buffer"		f.title
X"Procedure Header"	f.file "/usr/ias_soft/tlastrange/src/proc.twm"
X"File Header"		f.file "/usr/ias_soft/tlastrange/src/file.twm"
X}
X
Xmenu "one"
X{
X"refresh" f.refresh
X}
SHAR_EOF
if test 2194 -ne "`wc -c < Sample.twmrc`"
then
    echo shar: error transmitting "Sample.twmrc" '(should have been 2194 characters)'
fi
fi
if test -f 'gram.y'
then
    echo shar: will not over-write existing file "gram.y"
else
echo extracting "gram.y"
sed 's/^X//' >gram.y <<'SHAR_EOF'
X/*****************************************************************************/
X/**       Copyright 1988 by Evans & Sutherland Computer Corporation,        **/
X/**                          Salt Lake City, Utah                           **/
X/**                                                                         **/
X/**                           All Rights Reserved                           **/
X/**                                                                         **/
X/**    Permission to use, copy, modify, and distribute this software and    **/
X/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
X/**    granted, provided that the above copyright notice appear  in  all    **/
X/**    copies and that both  that  copyright  notice  and  this  permis-    **/
X/**    sion  notice appear in supporting  documentation,  and  that  the    **/
X/**    name  of Evans & Sutherland  not be used in advertising or publi-    **/
X/**    city pertaining to distribution  of the software without  specif-    **/
X/**    ic, written prior permission.                                        **/
X/**                                                                         **/
X/**    EVANS  & SUTHERLAND  DISCLAIMS  ALL  WARRANTIES  WITH  REGARD  TO    **/
X/**    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILI-    **/
X/**    TY AND FITNESS, IN NO EVENT SHALL EVANS &  SUTHERLAND  BE  LIABLE    **/
X/**    FOR  ANY  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY  DAM-    **/
X/**    AGES  WHATSOEVER RESULTING FROM  LOSS OF USE,  DATA  OR  PROFITS,    **/
X/**    WHETHER   IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS    **/
X/**    ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE  OR PER-    **/
X/**    FORMANCE OF THIS SOFTWARE.                                           **/
X/*****************************************************************************/
X
X/***********************************************************************
X *
X * $Header: gram.y,v 1.15 88/04/15 07:09:34 tlastran Exp $
X *
X * .twmrc command grammer
X *
X * 07-Jan-86 Thomas E. LaStrange	File created
X *
X ***********************************************************************/
X
X%{
Xstatic char RCSinfo[]=
X"$Header: gram.y,v 1.15 88/04/15 07:09:34 tlastran Exp $";
X
X#include <stdio.h>
X#include "twm.h"
X#include "menus.h"
X#include "list.h"
X
Xstatic char *Action = "";
Xstatic MenuRoot	*root,
X		*pull = NULL;
X
XMenuRoot *GetRoot();
X
Xstatic char *ptr;
Xstatic int Button;
Xstatic int list;
X
Xextern int yylineno;
X%}
X
X%union
X{
X    int num;
X    char *ptr;
X};
X
X%token <num> LB RB MENUS MENU BUTTON TBUTTON
X%token <num> F_MENU F_FOCUS F_REFRESH F_FILE F_TWMRC F_CIRCLEUP F_QUIT
X%token <num> F_NOP F_TITLE F_VERSION F_EXEC F_CUT F_CIRCLEDOWN F_SOURCE
X%token <num> F_CUTFILE
X%token <num> T_NOP T_RAISE T_LOWER T_MOVE
X%token <num> WARPCURSOR NUMBER BORDERWIDTH TITLE_FONT REVERSE_VIDEO
X%token <num> RESIZE_FONT NO_TITLE AUTO_RAISE
X%token <num> MENU_FONT ICON_FONT UNKNOWN_ICON
X%token <ptr> STRING
X
X%type <ptr> string
X%type <num> action button number tbutton taction
X
X%start twmrc 
X
X%%
Xtwmrc		: stmts
X		;
X
Xstmts		: /* Empty */
X		| stmts stmt
X		;
X
Xstmt		: error
X		| REVERSE_VIDEO		{ if (FirstTime) ReverseVideo = TRUE; }
X		| ICON_FONT string	{ if (FirstTime) IconFontName = $2; }
X		| RESIZE_FONT string	{ if (FirstTime) SizeFontName = $2; }
X		| MENU_FONT string	{ if (FirstTime) MenuFontName = $2; }
X		| TITLE_FONT string	{ if (FirstTime) TitleBarFontName=$2; }
X		| UNKNOWN_ICON string	{ if (FirstTime) GetUnknownIcon($2); }
X		| WARPCURSOR		{ if (FirstTime) WarpCursor = TRUE; }
X		| BORDERWIDTH number	{ if (FirstTime) BorderWidth = $2; }
X		| button string		{ root = GetRoot($2);
X					  Menu[$1] = root;
X					  Item[$1] = NULL;
X					}
X		| button action		{ if ($2 == F_MENU)
X					  {
X						pull->prev = NULL;
X						Menu[$1] = pull;
X						Item[$1] = NULL;
X					  }
X					  else
X					  {
X						root = GetRoot(TWM_ROOT);
X					   	Item[$1] =
X						AddToMenu(root,"x",Action,0,$2);
X						Menu[$1] = NULL;
X					  }
X					  Action = "";
X					  pull = NULL;
X					}
X		| tbutton taction	{ TitleButton[$1] = $2; }
X		| NO_TITLE		{ list = NO_TITLE; }
X		  win_list
X		| AUTO_RAISE		{ list = AUTO_RAISE; }
X		  win_list
X		| MENU string		{ root = GetRoot($2); }
X		  menu
X		;
X
X
Xwin_list	: LB win_entries RB
X		;
X
Xwin_entries	: /* Empty */
X		| win_entries win_entry
X		;
X
Xwin_entry	: string		{ if (FirstTime) AddToList(list, $1); }
X		;
X
Xmenu		: LB menu_entries RB
X		;
X
Xmenu_entries	: /* Empty */
X		| menu_entries menu_entry
X		;
X
Xmenu_entry	: string action		{ AddToMenu(root, $1, Action, pull, $2);
X					  Action = "";
X					  pull = NULL;
X					}
X		;
X
Xaction		: F_NOP			{ $$ = F_NOP; }
X		| F_QUIT		{ $$ = F_QUIT; }
X		| F_FOCUS		{ $$ = F_FOCUS; }
X		| F_REFRESH		{ $$ = F_REFRESH; }
X		| F_SOURCE string	{ Action = $2; $$ = F_TWMRC; }
X		| F_TWMRC		{ $$ = F_TWMRC; }
X		| F_VERSION		{ $$ = F_VERSION; }
X		| F_TITLE		{ $$ = F_TITLE; }
X		| F_CIRCLEUP		{ $$ = F_CIRCLEUP; }
X		| F_CIRCLEDOWN		{ $$ = F_CIRCLEDOWN; }
X		| F_CUTFILE		{ $$ = F_CUTFILE; }
X		| F_MENU string		{ pull = GetRoot($2);
X					  pull->prev = root;
X					  $$ = F_MENU;
X					}
X		| F_FILE string		{ Action = $2; $$ = F_FILE; }
X		| F_EXEC string		{ Action = $2; $$ = F_EXEC; }
X		| F_CUT string		{ Action = $2; $$ = F_CUT; }
X		;
X
Xtaction		: T_RAISE		{ $$ = T_RAISE; }
X		| T_LOWER		{ $$ = T_LOWER; }
X		| T_MOVE		{ $$ = T_MOVE; }
X		| T_NOP			{ $$ = T_NOP; }
X		;
X
Xbutton		: BUTTON		{ $$ = $1;
X					  if ($1 == 0)
X						yyerror();
X
X					  if ($1 > MAX_BUTTONS)
X					  {
X						$$ = 0;
X						yyerror();
X					  }
X					}
X		;
Xtbutton		: TBUTTON		{ $$ = $1;
X					  if ($1 == 0)
X						yyerror();
X
X					  if ($1 > MAX_BUTTONS)
X					  {
X						$$ = 0;
X						yyerror();
X					  }
X					}
X		;
X
Xstring		: STRING		{ ptr = (char *)malloc(strlen($1)+1);
X					  strcpy(ptr, $1);
X					  RemoveDQuote(ptr);
X					  $$ = ptr;
X					}
Xnumber		: NUMBER		{ $$ = $1; }
X		;
X
X%%
Xyyerror(s) char *s;
X{
X    fprintf(stderr, "twm: syntax error, line %d\n", yylineno);
X    ParseError = 1;
X}
XRemoveDQuote(str)
Xchar *str;
X{
X    strcpy(str, &str[1]);
X    str[strlen(str)-1] = '\0';
X}
X
XMenuRoot *
XGetRoot(name)
Xchar *name;
X{
X    MenuRoot *tmp;
X
X    tmp = FindMenuRoot(name);
X    if (tmp == NULL)
X	tmp = NewMenuRoot(name);
X
X    return tmp;
X}
X
SHAR_EOF
if test 6242 -ne "`wc -c < gram.y`"
then
    echo shar: error transmitting "gram.y" '(should have been 6242 characters)'
fi
fi
if test -f 'lex.l'
then
    echo shar: will not over-write existing file "lex.l"
else
echo extracting "lex.l"
sed 's/^X//' >lex.l <<'SHAR_EOF'
X%{
X/*****************************************************************************/
X/**       Copyright 1988 by Evans & Sutherland Computer Corporation,        **/
X/**                          Salt Lake City, Utah                           **/
X/**                                                                         **/
X/**                           All Rights Reserved                           **/
X/**                                                                         **/
X/**    Permission to use, copy, modify, and distribute this software and    **/
X/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
X/**    granted, provided that the above copyright notice appear  in  all    **/
X/**    copies and that both  that  copyright  notice  and  this  permis-    **/
X/**    sion  notice appear in supporting  documentation,  and  that  the    **/
X/**    name  of Evans & Sutherland  not be used in advertising or publi-    **/
X/**    city pertaining to distribution  of the software without  specif-    **/
X/**    ic, written prior permission.                                        **/
X/**                                                                         **/
X/**    EVANS  & SUTHERLAND  DISCLAIMS  ALL  WARRANTIES  WITH  REGARD  TO    **/
X/**    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILI-    **/
X/**    TY AND FITNESS, IN NO EVENT SHALL EVANS &  SUTHERLAND  BE  LIABLE    **/
X/**    FOR  ANY  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY  DAM-    **/
X/**    AGES  WHATSOEVER RESULTING FROM  LOSS OF USE,  DATA  OR  PROFITS,    **/
X/**    WHETHER   IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS    **/
X/**    ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE  OR PER-    **/
X/**    FORMANCE OF THIS SOFTWARE.                                           **/
X/*****************************************************************************/
X
X/***********************************************************************
X *
X * $Header: lex.l,v 1.19 88/04/15 07:09:32 tlastran Exp $
X *
X * .twmrc lex file
X *
X * 12-Nov-87 Thomas E. LaStrange		File created
X *
X ***********************************************************************/
X
Xstatic char RCSinfo[]=
X"$Header: lex.l,v 1.19 88/04/15 07:09:32 tlastran Exp $";
X
X#include <stdio.h>
X#include "gram.h"
X
Xextern int ParseError;
X
X%}
Xqstring				\"[^"]*\"
Xnumber				[0-9]+
Xbutton				[Bb][Uu][Tt][Tt][Oo][Nn]
Xtbutton				[Tt][Ii][Tt][Ll][Ee][Bb][Uu][Tt][Tt][Oo][Nn]
X%%
X"{"				{ return LB; }
X"}"				{ return RB; }
X
X{button}{number}		{ (void)sscanf(&yytext[6], "%d", &yylval.num);
X				  return (BUTTON);
X				}
X{tbutton}{number}		{ (void)sscanf(&yytext[11], "%d", &yylval.num);
X				  return (TBUTTON);
X				}
X[Mm][Ee][Nn][Uu]		{ return MENU; }
X
Xf.nop				{ return F_NOP; }
Xf.quit				{ return F_QUIT; }
Xf.title				{ return F_TITLE ; }
Xf.menu				{ return F_MENU; }
Xf.focus				{ return F_FOCUS; }
Xf.refresh			{ return F_REFRESH; }
Xf.file				{ return F_FILE; }
Xf.twmrc				{ return F_TWMRC; }
Xf.version			{ return F_VERSION; }
Xf.circleup			{ return F_CIRCLEUP; }
Xf.circledown			{ return F_CIRCLEDOWN; }
Xf.source			{ return F_SOURCE; }
Xf.cutfile			{ return F_CUTFILE; }
X"!"				{ return F_EXEC; }
X"^"				{ return F_CUT; }
X
Xt.nop				{ return T_NOP; }
Xt.raise				{ return T_RAISE; }
Xt.lower				{ return T_LOWER; }
Xt.move				{ return T_MOVE; }
X
X[Uu][Nn][Kk][Nn][Oo][Ww][Nn][Ii][Cc][Oo][Nn] { return UNKNOWN_ICON; }
X[Ww][Aa][Rr][Pp][Cc][Uu][Rr][Ss][Oo][Rr] { return WARPCURSOR; }
X[Bb][Oo][Rr][Dd][Ee][Rr][Ww][Ii][Dd][Tt][Hh] { return BORDERWIDTH; }
X[Tt][Ii][Tt][Ll][Ee][Ff][Oo][Nn][Tt] { return (TITLE_FONT); }
X[Mm][Ee][Nn][Uu][Ff][Oo][Nn][Tt] { return (MENU_FONT); }
X[Ii][Cc][Oo][Nn][Ff][Oo][Nn][Tt] { return (ICON_FONT); }
X[Rr][Ee][Ss][Ii][Zz][Ee][Ff][Oo][Nn][Tt] { return (RESIZE_FONT); }
X[Rr][Ee][Vv][Ee][Rr][Ss][Ee][Vv][Ii][Dd][Ee][Oo] { return (REVERSE_VIDEO); }
X[Nn][Oo][Tt][Ii][Tt][Ll][Ee]	{ return (NO_TITLE); }
X[Aa][Uu][Tt][Oo][Rr][Aa][Ii][Ss][Ee]	{ return (AUTO_RAISE); }
X
X{qstring}			{ yylval.ptr = yytext; return STRING; }
X{number}			{ (void)sscanf(yytext, "%d", &yylval.num);
X				  return (NUMBER);
X				}
X\#[^\n]*\n			{;}
X[\n\t ]				{;}
X.				{
X				  fprintf(stderr,
X					"twm: bad character `%s', line %d\n",
X					yytext, yylineno);
X				  ParseError = 1;
X				}
X%%
Xyywrap() { return(1);}
X
X#define unput(c)	TwmUnput(c)
X#define input()		TwmInput()
X#define output(c)	TwmOutput(c)
SHAR_EOF
if test 4392 -ne "`wc -c < lex.l`"
then
    echo shar: error transmitting "lex.l" '(should have been 4392 characters)'
fi
fi
if test -f 'add_window.c'
then
    echo shar: will not over-write existing file "add_window.c"
else
echo extracting "add_window.c"
sed 's/^X//' >add_window.c <<'SHAR_EOF'
X/*****************************************************************************/
X/**       Copyright 1988 by Evans & Sutherland Computer Corporation,        **/
X/**                          Salt Lake City, Utah                           **/
X/**                                                                         **/
X/**                           All Rights Reserved                           **/
X/**                                                                         **/
X/**    Permission to use, copy, modify, and distribute this software and    **/
X/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
X/**    granted, provided that the above copyright notice appear  in  all    **/
X/**    copies and that both  that  copyright  notice  and  this  permis-    **/
X/**    sion  notice appear in supporting  documentation,  and  that  the    **/
X/**    name  of Evans & Sutherland  not be used in advertising or publi-    **/
X/**    city pertaining to distribution  of the software without  specif-    **/
X/**    ic, written prior permission.                                        **/
X/**                                                                         **/
X/**    EVANS  & SUTHERLAND  DISCLAIMS  ALL  WARRANTIES  WITH  REGARD  TO    **/
X/**    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILI-    **/
X/**    TY AND FITNESS, IN NO EVENT SHALL EVANS &  SUTHERLAND  BE  LIABLE    **/
X/**    FOR  ANY  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY  DAM-    **/
X/**    AGES  WHATSOEVER RESULTING FROM  LOSS OF USE,  DATA  OR  PROFITS,    **/
X/**    WHETHER   IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS    **/
X/**    ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE  OR PER-    **/
X/**    FORMANCE OF THIS SOFTWARE.                                           **/
X/*****************************************************************************/
X
X/**********************************************************************
X *
X * $Header: add_window.c,v 1.7 88/04/15 07:10:05 tlastran Exp $
X *
X * Add a new window, put the titlbar and other stuff around
X * the window
X *
X * 31-Mar-88 Tom LaStrange        Initial Version.
X *
X **********************************************************************/
X
X#ifndef lint
Xstatic char RCSinfo[]=
X"$Header: add_window.c,v 1.7 88/04/15 07:10:05 tlastran Exp $";
X#endif lint
X
X#include <stdio.h>
X#include "twm.h"
X#include "util.h"
X#include "resize.h"
X#include "gram.h"
X#include "list.h"
X
X#include "iconify.bm"
X#include "resize.bm"
X#include "xterm.bm"
X#include "focus.bm"
X#include "hilite.bm"
X
Xstatic char NoName[] = "No Name"; /* name if no name is specified */
X
X/***********************************************************************
X *
X *  Procedure:
X *	AddWindow - add a new window to the twm list
X *
X *  Returned Value:
X *	(TwmWindow *) - pointer to the TwmWindow structure
X *
X *  Inputs:
X *	w	- the window id of the window to add
X *
X ***********************************************************************
X */
X
XTwmWindow *
XAddWindow(w)
XWindow w;
X{
X    TwmWindow *tmp_win;			/* new twm window structure */
X    unsigned long valuemask;		/* mask for create windows */
X    XSetWindowAttributes attributes;	/* attributes for create windows */
X    int icon_width;		/* width of the icon pixmap */
X    int icon_height;		/* height of the icon pixmap */
X    int width;			/* tmp variable */
X    int x;
X    Pixmap pm;			/* tmp pixmap variable */
X    XWindowChanges xwc;		/* change window structure */
X    unsigned int xwcm;		/* change window mask */
X
X#ifdef DEBUG
X    fprintf(stderr, "AddWindow: w = 0x%x\n", w);
X#endif
X
X    /* allocate space for the twm window */
X    tmp_win = (TwmWindow *)malloc(sizeof(TwmWindow));
X    tmp_win->w = w;
X
X    XGetWindowAttributes(dpy, tmp_win->w, &tmp_win->attr);
X    XFetchName(dpy, tmp_win->w, &tmp_win->name);
X#ifdef DEBUG
X    fprintf(stderr, "  name = \"%s\"\n", tmp_win->name);
X#endif
X    tmp_win->wmhints = XGetWMHints(dpy, tmp_win->w);
X    if (XGetNormalHints(dpy, tmp_win->w, &tmp_win->hints) == 0)
X	tmp_win->hints.flags = 0;
X
X    if (tmp_win->hints.flags & PSize)
X    {
X#ifdef DEBUG
X	fprintf(stderr, "  program specified hints\n");
X#endif
X	tmp_win->attr.x = tmp_win->hints.x;
X	tmp_win->attr.y = tmp_win->hints.y;
X	tmp_win->attr.width = tmp_win->hints.width;
X	tmp_win->attr.height = tmp_win->hints.height;
X    }
X    if (tmp_win->hints.flags & USSize)
X    {
X#ifdef DEBUG
X	fprintf(stderr, "  user specified hints\n");
X#endif
X	tmp_win->attr.x = tmp_win->hints.x;
X	tmp_win->attr.y = tmp_win->hints.y;
X	tmp_win->attr.width = tmp_win->hints.width;
X	tmp_win->attr.height = tmp_win->hints.height;
X    }
X
X    if (tmp_win->name == NULL)
X	tmp_win->name = NoName;
X
X    tmp_win->auto_raise = LookInList(AUTO_RAISE, tmp_win->name);
X    if (LookInList(NO_TITLE, tmp_win->name))
X    {
X	tmp_win->title_height = 0;
X    }
X    else
X    {
X	tmp_win->title_height = TITLE_BAR_HEIGHT + BorderWidth;
X    }
X
X    if (tmp_win->attr.y < tmp_win->title_height)
X	tmp_win->attr.y = tmp_win->title_height;
X
X    xwcm = CWX | CWY | CWWidth | CWHeight | CWBorderWidth;
X
X#ifdef DEBUG
X	fprintf(stderr, "  position window  %d, %d  %dx%d\n", 
X	    tmp_win->attr.x,
X	    tmp_win->attr.y,
X	    tmp_win->attr.width,
X	    tmp_win->attr.height);
X#endif
X    xwc.x = tmp_win->attr.x + tmp_win->attr.border_width;
X    xwc.y = tmp_win->attr.y + tmp_win->attr.border_width;
X    xwc.width = tmp_win->attr.width;
X    xwc.height = tmp_win->attr.height;
X    xwc.border_width = 0;
X
X    XConfigureWindow(dpy, tmp_win->w, xwcm, &xwc);
X
X
X    tmp_win->full_name = tmp_win->name;
X
X    if (strncmp("xterm", tmp_win->name, 5) == 0 ||
X	strncmp("yterm", tmp_win->name, 5) == 0 ||
X	strncmp("console", tmp_win->name, 7) == 0 ||
X	strncmp("login", tmp_win->name, 5) == 0)
X	tmp_win->xterm = TRUE;
X    else
X	tmp_win->xterm = FALSE;
X
X    if (strncmp("xterm_", tmp_win->name, 6) == 0)
X	tmp_win->name = &tmp_win->name[6];
X
X    tmp_win->name_width = XTextWidth(TitleBarFont, tmp_win->name,
X	strlen(tmp_win->name));
X    tmp_win->icon_name = tmp_win->name;
X
X    tmp_win->iconified = FALSE;
X    tmp_win->icon = FALSE;
X
X    /* add the window into the twm list */
X    tmp_win->next = TwmRoot.next;
X    if (TwmRoot.next != NULL)
X	TwmRoot.next->prev = tmp_win;
X    tmp_win->prev = &TwmRoot;
X    TwmRoot.next = tmp_win;
X
X    /* create windows */
X
X    tmp_win->frame_x = tmp_win->attr.x;
X    tmp_win->frame_y = tmp_win->attr.y - tmp_win->title_height;
X
X    tmp_win->frame = XCreateSimpleWindow(dpy, Root,
X	tmp_win->frame_x,
X	tmp_win->frame_y,
X	tmp_win->attr.width,
X	tmp_win->attr.height + tmp_win->title_height,
X	BorderWidth,
X	Foreground, Background);
X
X    tmp_win->title_w = XCreateSimpleWindow(dpy, tmp_win->frame,
X	-BorderWidth, -BorderWidth,
X	tmp_win->attr.width, TITLE_BAR_HEIGHT,
X	BorderWidth,
X	Foreground, Background);
X
X    /* the three buttons have the pixmap as the background of the
X     * window, that way I don't have to worry about repainting them
X     * on expose events.
X     */
X
X    valuemask = CWEventMask | CWBackPixmap;
X    attributes.event_mask = ButtonPressMask;
X    attributes.background_pixmap = MakePixmap(tmp_win->title_w, TitleNormalGC,
X	iconify_bits, iconify_width, iconify_height);
X
X    tmp_win->iconify_w = XCreateWindow(dpy, tmp_win->title_w,
X	TITLE_BAR_SPACE, TITLE_BAR_SPACE,
X	iconify_width, iconify_height,
X	0, DefaultDepth(dpy, 0), CopyFromParent, DefaultVisual(dpy,0),
X	valuemask, &attributes);
X
X    attributes.background_pixmap = MakePixmap(tmp_win->title_w, TitleNormalGC,
X	focus_bits, focus_width, focus_height);
X
X    tmp_win->focus_w = XCreateWindow(dpy, tmp_win->title_w,
X	tmp_win->attr.width - resize_width -3 - focus_width, TITLE_BAR_SPACE,
X	iconify_width, iconify_height,
X	0, DefaultDepth(dpy, 0), CopyFromParent, DefaultVisual(dpy,0),
X	valuemask, &attributes);
X
X    attributes.background_pixmap = MakePixmap(tmp_win->title_w, TitleNormalGC,
X	resize_bits, resize_width, resize_height);
X
X    tmp_win->resize_w = XCreateWindow(dpy, tmp_win->title_w,
X	tmp_win->attr.width - resize_width - 1,
X	TITLE_BAR_SPACE,
X	resize_width, resize_height,
X	0, DefaultDepth(dpy, 0), CopyFromParent, DefaultVisual(dpy,0),
X	valuemask, &attributes);
X	
X    valuemask = CWBackPixmap;
X    attributes.background_pixmap = MakePixmap(tmp_win->title_w, TitleNormalGC,
X	hilite_bits, hilite_width, hilite_height);
X
X    tmp_win->hilite_w = XCreateWindow(dpy, tmp_win->title_w,
X	TitleBarX, 1,
X	10, hilite_height,
X	0, DefaultDepth(dpy, 0), CopyFromParent, DefaultVisual(dpy,0),
X	valuemask, &attributes);
X	
X    XDefineCursor(dpy, tmp_win->title_w, ArrowCursor);
X    XDefineCursor(dpy, tmp_win->iconify_w, ButtonCursor);
X    XDefineCursor(dpy, tmp_win->focus_w, ButtonCursor);
X    XDefineCursor(dpy, tmp_win->resize_w, ButtonCursor);
X
X    XSelectInput(dpy, tmp_win->w, StructureNotifyMask);
X    XSelectInput(dpy, tmp_win->frame,
X	ButtonPressMask | EnterWindowMask | LeaveWindowMask);
X
X    XSelectInput(dpy, tmp_win->title_w, 
X	ButtonPressMask | ButtonReleaseMask |
X	ExposureMask | ButtonMotionMask);
X
X    XAddToSaveSet(dpy, tmp_win->w);
X    XReparentWindow(dpy, tmp_win->w, tmp_win->frame, 0, tmp_win->title_height);
X
X    SetupWindow(tmp_win,
X	tmp_win->frame_x,
X	tmp_win->frame_y,
X	tmp_win->attr.width,
X	tmp_win->attr.height + tmp_win->title_height);
X
X    pm = NULL;
X    if (tmp_win->wmhints && tmp_win->wmhints->flags & IconPixmapHint)
X    {
X	XGetGeometry(dpy, tmp_win->wmhints->icon_pixmap,
X	    &JunkRoot, &JunkX, &JunkY,
X	    &icon_width, &icon_height, &JunkBW,
X	    &JunkDepth);
X
X	pm = XCreatePixmap(dpy, Root, icon_width, icon_height,
X	    DefaultDepth(dpy, 0));
X
X	XCopyPlane(dpy, tmp_win->wmhints->icon_pixmap, pm, MenuNormalGC,
X	    0,0, icon_width, icon_height, 0, 0, 1 );
X    }
X    else
X    {
X	if (tmp_win->xterm)
X	{
X	    pm = MakePixmap(Root, MenuNormalGC,
X		xterm_bits, xterm_width, xterm_height);
X	    icon_width = xterm_width;
X	    icon_height = xterm_height;
X	}
X	else if (UnknownPm != NULL)
X	{
X	    XImage *image;
X	    unsigned mask;
X
X	    icon_width = UnknownWidth;
X	    icon_height = UnknownHeight;
X	    mask = Foreground ^ Background;
X	    image = XGetImage(dpy, UnknownPm, 0, 0, icon_width, icon_height,
X		mask, XYPixmap);
X
X	    pm = XCreatePixmap(dpy, Root, icon_width, icon_height,
X		DefaultDepth(dpy, 0));
X
X	    XPutImage(dpy, pm, TitleNormalGC,
X		image, 0, 0, 0, 0, icon_width, icon_height);
X	}
X    }
X
X    if (pm == NULL)
X    {
X	icon_height = 0;
X	icon_width = 0;
X	valuemask = 0;
X    }
X    else
X    {
X	valuemask = CWBackPixmap;
X	attributes.background_pixmap = pm;
X    }
X
X    width = XTextWidth(IconFont,
X	tmp_win->icon_name, strlen(tmp_win->icon_name));
X
X    width += 6;
X    if (width < icon_width)
X    {
X	tmp_win->icon_x = (icon_width - width)/2;
X	tmp_win->icon_x += 3;
X	width = icon_width;
X    }
X    else
X    {
X	tmp_win->icon_x = 3;
X    }
X    tmp_win->icon_y = icon_height + IconFontHeight;
X
X    if (tmp_win->wmhints && tmp_win->wmhints->flags & IconWindowHint)
X    {
X	tmp_win->icon_w = tmp_win->wmhints->icon_window;
X    }
X    else
X    {
X	tmp_win->icon_w = XCreateSimpleWindow(dpy, Root,
X	    0,0,
X	    width,
X	    icon_height + IconFontHeight + 4,
X	    2, Foreground, Background);
X    }
X
X    XSelectInput(dpy, tmp_win->icon_w,
X	ButtonPressMask | ExposureMask);
X
X    if (pm != NULL)
X    {
X	if (width == icon_width)
X	    x = 0;
X	else
X	    x = (width - icon_width)/2;
X
X	XCreateWindow(dpy, tmp_win->icon_w,
X	    x, 0,
X	    icon_width, icon_height,
X	    0, DefaultDepth(dpy, 0), CopyFromParent,
X	    DefaultVisual(dpy,0),
X	    valuemask, &attributes);
X    }
X
X    XDefineCursor(dpy, tmp_win->icon_w, ArrowCursor);
X
X    XSaveContext(dpy, tmp_win->w, TwmContext, tmp_win);
X    XSaveContext(dpy, tmp_win->frame, TwmContext, tmp_win);
X    XSaveContext(dpy, tmp_win->title_w, TwmContext, tmp_win);
X    XSaveContext(dpy, tmp_win->iconify_w, TwmContext, tmp_win);
X    XSaveContext(dpy, tmp_win->resize_w, TwmContext, tmp_win);
X    XSaveContext(dpy, tmp_win->icon_w, TwmContext, tmp_win);
X    XSaveContext(dpy, tmp_win->focus_w, TwmContext, tmp_win);
X    XSaveContext(dpy, tmp_win->hilite_w, TwmContext, tmp_win);
X
X    return (tmp_win);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	MappedNotOverride - checks to see if we should really
X *		put a twm frame on the window
X *
X *  Returned Value:
X *	TRUE	- go ahead and frame the window
X *	FALSE	- don't frame the window
X *
X *  Inputs:
X *	w	- the window to check
X *
X ***********************************************************************
X */
X
Xint
XMappedNotOverride(w)
X    Window w;
X{
X    XWindowAttributes wa;
X
X    XGetWindowAttributes(dpy, w, &wa);
X    return ((wa.map_state != IsUnmapped) && (wa.override_redirect != True));
X}
SHAR_EOF
if test 12604 -ne "`wc -c < add_window.c`"
then
    echo shar: error transmitting "add_window.c" '(should have been 12604 characters)'
fi
fi
if test -f 'gc.c'
then
    echo shar: will not over-write existing file "gc.c"
else
echo extracting "gc.c"
sed 's/^X//' >gc.c <<'SHAR_EOF'
X/*****************************************************************************/
X/**       Copyright 1988 by Evans & Sutherland Computer Corporation,        **/
X/**                          Salt Lake City, Utah                           **/
X/**                                                                         **/
X/**                           All Rights Reserved                           **/
X/**                                                                         **/
X/**    Permission to use, copy, modify, and distribute this software and    **/
X/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
X/**    granted, provided that the above copyright notice appear  in  all    **/
X/**    copies and that both  that  copyright  notice  and  this  permis-    **/
X/**    sion  notice appear in supporting  documentation,  and  that  the    **/
X/**    name  of Evans & Sutherland  not be used in advertising or publi-    **/
X/**    city pertaining to distribution  of the software without  specif-    **/
X/**    ic, written prior permission.                                        **/
X/**                                                                         **/
X/**    EVANS  & SUTHERLAND  DISCLAIMS  ALL  WARRANTIES  WITH  REGARD  TO    **/
X/**    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILI-    **/
X/**    TY AND FITNESS, IN NO EVENT SHALL EVANS &  SUTHERLAND  BE  LIABLE    **/
X/**    FOR  ANY  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY  DAM-    **/
X/**    AGES  WHATSOEVER RESULTING FROM  LOSS OF USE,  DATA  OR  PROFITS,    **/
X/**    WHETHER   IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS    **/
X/**    ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE  OR PER-    **/
X/**    FORMANCE OF THIS SOFTWARE.                                           **/
X/*****************************************************************************/
X
X/**********************************************************************
X *
X * $Header: gc.c,v 1.3 88/04/15 07:09:38 tlastran Exp $
X *
X * Open the fonts and create the GCs
X *
X * 31-Mar-88 Tom LaStrange        Initial Version.
X *
X **********************************************************************/
X
X#ifndef lint
Xstatic char RCSinfo[]=
X"$Header: gc.c,v 1.3 88/04/15 07:09:38 tlastran Exp $";
X#endif lint
X
X#include <stdio.h>
X#include "twm.h"
X
X/***********************************************************************
X *
X *  Procedure:
X *	CreateGCs - open fonts and create all the needed GC's.  I only
X *		    want to do this once, hence the first_time flag.
X *
X ***********************************************************************
X */
X
Xvoid
XCreateGCs()
X{
X    static int first_time = TRUE;
X    XGCValues	    gcv;
X    unsigned long   gcm, mask;
X
X    if (!first_time)
X	return;
X
X    first_time = FALSE;
X
X    /* open fonts */
X
X    TitleBarFont = XLoadQueryFont(dpy, TitleBarFontName);
X    TitleBarFontHeight = TitleBarFont->ascent + TitleBarFont->descent;
X    if (TitleBarFontHeight < TITLE_BAR_FONT_HEIGHT)
X    {
X	TitleBarY = (TITLE_BAR_FONT_HEIGHT - TitleBarFontHeight)/2 +
X	    TITLE_BAR_SPACE + TitleBarFont->ascent;
X    }
X    else
X    {
X	TitleBarY = TITLE_BAR_SPACE + TitleBarFont->ascent;
X    }
X
X    MenuFont = XLoadQueryFont(dpy, MenuFontName);
X    MenuFontHeight = MenuFont->ascent + MenuFont->descent;
X    MenuY = MenuFont->ascent + 1;
X
X    IconFont = XLoadQueryFont(dpy, IconFontName);
X    IconFontHeight = IconFont->ascent + IconFont->descent;
X
X    VersionFont = XLoadQueryFont(dpy, VersionFontName);
X    VersionFontHeight = VersionFont->ascent + VersionFont->descent;
X
X    SizeFont = XLoadQueryFont(dpy, SizeFontName);
X    SizeFontHeight = SizeFont->ascent + SizeFont->descent;
X
X    /* create GC's */
X
X    if (ReverseVideo)
X    {
X	Background = BlackPixel(dpy, DefaultScreen(dpy));
X	Foreground = WhitePixel(dpy, DefaultScreen(dpy));
X    }
X    else
X    {
X	Foreground = BlackPixel(dpy, DefaultScreen(dpy));
X	Background = WhitePixel(dpy, DefaultScreen(dpy));
X    }
X    mask = Foreground ^ Background;
X
X    gcm = 0;
X    gcm |= GCFont;	    gcv.font = TitleBarFont->fid;
X    gcm |= GCPlaneMask;	    gcv.plane_mask = mask;
X    gcm |= GCForeground;    gcv.foreground = Foreground;
X    gcm |= GCBackground;    gcv.background = Background;
X
X    TitleNormalGC = XCreateGC(dpy, Root, gcm, &gcv);
X
X    gcm = 0;
X    gcm |= GCFont;	    gcv.font = MenuFont->fid;
X    gcm |= GCPlaneMask;	    gcv.plane_mask = mask;
X    gcm |= GCForeground;    gcv.foreground = Foreground;
X    gcm |= GCBackground;    gcv.background = Background;
X
X    MenuNormalGC = XCreateGC(dpy, Root, gcm, &gcv);
X
X    gcv.foreground = Background;
X    gcv.background = Foreground;
X
X    MenuReverseGC = XCreateGC(dpy, Root, gcm, &gcv);
X
X    gcm = 0;
X    gcm |= GCFunction;	    gcv.function = GXxor;
X    gcm |= GCFont;	    gcv.font = MenuFont->fid;
X    gcm |= GCPlaneMask;	    gcv.plane_mask = mask;
X    gcm |= GCForeground;    gcv.foreground = mask;
X    gcm |= GCBackground;    gcv.background = Background;
X
X    MenuXorGC = XCreateGC(dpy, Root, gcm, &gcv);
X
X    gcm = 0;
X    gcm |= GCFunction;	    gcv.function = GXxor;
X    gcm |= GCLineWidth;	    gcv.line_width = 0;
X    gcm |= GCForeground;    gcv.foreground = mask;
X    gcm |= GCPlaneMask;	    gcv.plane_mask = mask;
X    gcm |= GCSubwindowMode; gcv.subwindow_mode = IncludeInferiors;
X
X    DrawGC = XCreateGC(dpy, Root, gcm, &gcv);
X
X    gcm = 0;
X    gcm |= GCFont;	    gcv.font = IconFont->fid;
X    gcm |= GCPlaneMask;	    gcv.plane_mask = mask;
X    gcm |= GCForeground;    gcv.foreground = Foreground;
X    gcm |= GCBackground;    gcv.background = Background;
X
X    IconNormalGC = XCreateGC(dpy, Root, gcm, &gcv);
X
X    gcm = 0;
X    gcm |= GCFont;	    gcv.font = VersionFont->fid;
X    gcm |= GCPlaneMask;	    gcv.plane_mask = mask;
X    gcm |= GCForeground;    gcv.foreground = Foreground;
X    gcm |= GCBackground;    gcv.background = Background;
X
X    VersionNormalGC = XCreateGC(dpy, Root, gcm, &gcv);
X
X    gcm = 0;
X    gcm |= GCFont;	    gcv.font = SizeFont->fid;
X    gcm |= GCPlaneMask;	    gcv.plane_mask = mask;
X    gcm |= GCForeground;    gcv.foreground = Foreground;
X    gcm |= GCBackground;    gcv.background = Background;
X
X    SizeNormalGC = XCreateGC(dpy, Root, gcm, &gcv);
X}
SHAR_EOF
if test 6215 -ne "`wc -c < gc.c`"
then
    echo shar: error transmitting "gc.c" '(should have been 6215 characters)'
fi
fi
if test -f 'list.c'
then
    echo shar: will not over-write existing file "list.c"
else
echo extracting "list.c"
sed 's/^X//' >list.c <<'SHAR_EOF'
X/*****************************************************************************/
X/**       Copyright 1988 by Evans & Sutherland Computer Corporation,        **/
X/**                          Salt Lake City, Utah                           **/
X/**                                                                         **/
X/**                           All Rights Reserved                           **/
X/**                                                                         **/
X/**    Permission to use, copy, modify, and distribute this software and    **/
X/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
X/**    granted, provided that the above copyright notice appear  in  all    **/
X/**    copies and that both  that  copyright  notice  and  this  permis-    **/
X/**    sion  notice appear in supporting  documentation,  and  that  the    **/
X/**    name  of Evans & Sutherland  not be used in advertising or publi-    **/
X/**    city pertaining to distribution  of the software without  specif-    **/
X/**    ic, written prior permission.                                        **/
X/**                                                                         **/
X/**    EVANS  & SUTHERLAND  DISCLAIMS  ALL  WARRANTIES  WITH  REGARD  TO    **/
X/**    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILI-    **/
X/**    TY AND FITNESS, IN NO EVENT SHALL EVANS &  SUTHERLAND  BE  LIABLE    **/
X/**    FOR  ANY  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY  DAM-    **/
X/**    AGES  WHATSOEVER RESULTING FROM  LOSS OF USE,  DATA  OR  PROFITS,    **/
X/**    WHETHER   IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS    **/
X/**    ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE  OR PER-    **/
X/**    FORMANCE OF THIS SOFTWARE.                                           **/
X/*****************************************************************************/
X
X/**********************************************************************
X *
X * $Header: list.c,v 1.2 88/04/15 07:09:53 tlastran Exp $
X *
X * TWM code to deal with the name lists for the NoTitle list and
X * the AutoRaise list
X *
X * 11-Apr-88 Tom LaStrange        Initial Version.
X *
X **********************************************************************/
X
X#ifndef lint
Xstatic char RCSinfo[]=
X"$Header: list.c,v 1.2 88/04/15 07:09:53 tlastran Exp $";
X#endif lint
X
X#include <stdio.h>
X#include "twm.h"
X#include "gram.h"
X
Xtypedef struct name_list name_list;
X
Xstruct name_list
X{
X    name_list *next;		/* pointer to the next name */
X    char *name;			/* the name of the window */
X};
X
Xname_list *NoTitle = NULL;	/* list of window names with no title bar */
Xname_list *AutoRaise = NULL;	/* list of window names to auto-raise */
X
X/***********************************************************************
X *
X *  Procedure:
X *	AddToList - add a window name to the appropriate list
X *
X *  Inputs:
X *	list	- a #define to identify the list
X *	name	- a pointer to the name of the window 
X *
X ***********************************************************************
X */
X
Xvoid
XAddToList(list, name)
Xint list;
Xchar *name;
X{
X    name_list *ptr;
X
X    ptr = (name_list *)malloc(sizeof(name_list));
X    if (ptr == NULL)
X    {
X	fprintf(stderr, "twm: out of memory\n");
X	exit(1);
X    }
X
X    ptr->name = name;
X
X    switch (list)
X    {
X    case AUTO_RAISE:
X	ptr->next = AutoRaise;
X	AutoRaise = ptr;
X	break;
X
X    case NO_TITLE:
X	ptr->next = NoTitle;
X	NoTitle = ptr;
X	break;
X    }
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	LookInList - look through a list for a window name
X *
X *  Returned Value:
X *	TRUE	- the window was found in the list
X *	FALSE	- the window was not found in the list
X *
X *  Inputs:
X *	list	- a #define to identify the list
X *	name	- a pointer to the name to look for
X *
X ***********************************************************************
X */
X
Xint
XLookInList(list, name)
Xint list;
Xchar *name;
X{
X    name_list *l;
X    name_list *ptr;
X
X    switch (list)
X    {
X    case AUTO_RAISE:
X	l = AutoRaise;
X	break;
X
X    case NO_TITLE:
X	l = NoTitle;
X	break;
X    }
X
X    for (ptr = l; ptr != NULL; ptr = ptr->next)
X    {
X	int len;
X
X	len = strlen(ptr->name);
X	if (strncmp(name, ptr->name, len) == 0)
X	    return (TRUE);
X    }
X    return (FALSE);
X}
SHAR_EOF
if test 4301 -ne "`wc -c < list.c`"
then
    echo shar: error transmitting "list.c" '(should have been 4301 characters)'
fi
fi
if test -f 'twm.c'
then
    echo shar: will not over-write existing file "twm.c"
else
echo extracting "twm.c"
sed 's/^X//' >twm.c <<'SHAR_EOF'
X/*****************************************************************************/
X/**       Copyright 1988 by Evans & Sutherland Computer Corporation,        **/
X/**                          Salt Lake City, Utah                           **/
X/**                                                                         **/
X/**                           All Rights Reserved                           **/
X/**                                                                         **/
X/**    Permission to use, copy, modify, and distribute this software and    **/
X/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
X/**    granted, provided that the above copyright notice appear  in  all    **/
X/**    copies and that both  that  copyright  notice  and  this  permis-    **/
X/**    sion  notice appear in supporting  documentation,  and  that  the    **/
X/**    name  of Evans & Sutherland  not be used in advertising or publi-    **/
X/**    city pertaining to distribution  of the software without  specif-    **/
X/**    ic, written prior permission.                                        **/
X/**                                                                         **/
X/**    EVANS  & SUTHERLAND  DISCLAIMS  ALL  WARRANTIES  WITH  REGARD  TO    **/
X/**    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILI-    **/
X/**    TY AND FITNESS, IN NO EVENT SHALL EVANS &  SUTHERLAND  BE  LIABLE    **/
X/**    FOR  ANY  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY  DAM-    **/
X/**    AGES  WHATSOEVER RESULTING FROM  LOSS OF USE,  DATA  OR  PROFITS,    **/
X/**    WHETHER   IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS    **/
X/**    ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE  OR PER-    **/
X/**    FORMANCE OF THIS SOFTWARE.                                           **/
X/*****************************************************************************/
X
X/***********************************************************************
X *
X * $Header: twm.c,v 1.23 88/04/15 07:09:30 tlastran Exp $
X *
X * twm - "Tom's Window Manager"
X *
X * 27-Oct-87 Thomas E. LaStrange	File created
X *
X ***********************************************************************/
X
X#ifndef lint
Xstatic char RCSinfo[] =
X"$Header: twm.c,v 1.23 88/04/15 07:09:30 tlastran Exp $";
X#endif
X
X#include <stdio.h>
X#include <signal.h>
X#include <fcntl.h>
X#include "twm.h"
X#include "add_window.h"
X#include "gc.h"
X#include "parse.h"
X#include "version.h"
X#include "menus.h"
X#include "events.h"
X#include "util.h"
X
X#include "twm.bm"
X
XTwmWindow TwmRoot;		/* the head of the twm window list */
X
XDisplay *dpy;			/* which display are we talking to */
X
XWindow Root;			/* the root window */
XWindow VersionWindow;		/* the twm version window */
XWindow SizeWindow;		/* the resize dimensions window */
XWindow ResizeWindow;		/* the window we are resizing */
X
XXFontStruct *TitleBarFont;	/* title bar font structure */
XXFontStruct *MenuFont;		/* menu font structure */
XXFontStruct *IconFont;		/* icon font structure */
XXFontStruct *SizeFont;		/* resize font structure */
XXFontStruct *VersionFont;	/* version font structure */
X
Xchar *TitleBarFontName = "8x13";/* default title bar font */
Xchar *MenuFontName = "8x13";	/* default menu font */
Xchar *IconFontName = "8x13";	/* default icon font */
Xchar *SizeFontName = "fg-22";	/* default resize font */
Xchar *VersionFontName = "8x13";	/* default version font */
X
Xint TitleBarFontHeight;		/* height of title bar font */
Xint MenuFontHeight;		/* height of menu font */
Xint IconFontHeight;		/* height of icon font */
Xint SizeFontHeight;		/* height of resize font */
Xint VersionFontHeight;		/* height of version font */
X
XCursor ArrowCursor;		/* title bar cursor */
XCursor ButtonCursor;		/* title bar button cursor */
XCursor MoveCursor;		/* move and resize cursor */
XCursor ClockCursor;		/* wait a while cursor */
XCursor RightArrowCursor;	/* menu cursor */
X
XGC TitleNormalGC;		/* GC for title bar */
XGC MenuNormalGC;		/* normal GC for menus */
XGC MenuReverseGC;		/* reverse video GC for menus */
XGC MenuXorGC;			/* XOR GC for menus */
XGC IconNormalGC;		/* GC for icons */
XGC VersionNormalGC;		/* GC for the version window */
XGC SizeNormalGC;		/* GC for the resize window */
XGC DrawGC;			/* GC to draw lines for move and resize */
X
XXContext TwmContext;		/* context for twm windows */
XXContext MenuContext;		/* context for all menu windows */
X
Xint BorderWidth = BW;		/* border width of twm windows */
Xunsigned long Foreground;	/* foreground color for all windows */
Xunsigned long Background;	/* background color for all windows */
X
Xchar Version[100];		/* place to build the version string */
XPixmap UnknownPm = NULL;	/* the unknown icon pixmap */
Xint UnknownWidth = 0;		/* width of the unknown icon */
Xint UnknownHeight = 0;		/* height of the unknown icon */
Xint FirstTime = TRUE;		/* first time we've read .twmrc */
Xint ReverseVideo = FALSE;	/* flag to do reverse video */
Xint FocusRoot = TRUE;		/* is the input focus on the root ? */
XTwmWindow *Focus = NULL;	/* the twm window that has focus */
Xint WarpCursor = FALSE;		/* warp cursor on de-iconify ? */
Xint ParseError;			/* error parsing the .twmrc file */
X
Xint TitleButton[MAX_BUTTONS + 1];	/* title button functions */
X
Xint TitleBarY;			/* y coordinate to start text in the title */
Xint TitleBarX = TITLE_BAR_HEIGHT + 4;	/* x coordinate ditto */
Xint MenuY;			/* y coordiante for text in menus */
X
XWindow JunkRoot;		/* junk window */
XWindow JunkChild;		/* junk window */
Xint JunkX;			/* junk variable */
Xint JunkY;			/* junk variable */
Xint JunkWidth;			/* junk variable */
Xint JunkHeight;			/* junk variable */
Xint JunkDepth;			/* junk variable */
Xint JunkBW;			/* junk variable */
Xint JunkMask;			/* junk variable */
X
X/***********************************************************************
X *
X *  Procedure:
X *	main - start of twm
X *
X ***********************************************************************
X */
X
Xmain(argc, argv)
X    int argc;
X    char *argv[];
X{
X    Window root, parent, *children;
X    int nchildren, i;
X    int m, d, y;
X    char *display_name;
X    unsigned long valuemask;	/* mask for create windows */
X    XSetWindowAttributes attributes;	/* attributes for create windows */
X
X    display_name = NULL;
X
X    if (argc != 1 && argc != 3)
X    {
X	fprintf(stderr, "Usage: twm [-display display]\n");
X	exit(1);
X    }
X
X    if (argc == 3)
X    {
X	if (strncmp(argv[1], "-d", 2) == 0)
X	    display_name = argv[2];
X	else
X	{
X	    fprintf(stderr, "Usage: twm [-display display]\n");
X	    exit(1);
X	}
X    }
X
X    signal(SIGINT, Done);
X    signal(SIGQUIT, Done);
X    signal(SIGHUP, Done);
X    signal(SIGTERM, Done);
X
X    TwmRoot.next = NULL;
X    TwmRoot.prev = NULL;
X    TwmRoot.w = NULL;
X    TwmRoot.title_w = NULL;
X    TwmRoot.iconify_w = NULL;
X    TwmRoot.resize_w = NULL;
X
X    if ((dpy = XOpenDisplay(display_name)) == NULL)
X    {
X	fprintf(stderr, "twm: can't open the display\n");
X	exit(1);
X    }
X
X
X    if (fcntl(ConnectionNumber(dpy), F_SETFD, 1) == -1)
X    {
X	fprintf(stderr, "twm: child cannot disinherit TCP fd\n");
X	exit(1);
X    }
X
X    Root = RootWindow(dpy, DefaultScreen(dpy));
X
X    XSetErrorHandler(Other);
X    XSelectInput(dpy, Root,
X	SubstructureRedirectMask |
X	ButtonPressMask | ButtonReleaseMask |
X	ExposureMask | ButtonMotionMask);
X    XSync(dpy, 0);
X
X    XSetErrorHandler(Error);
X    XSetInputFocus(dpy, Root, RevertToPointerRoot, CurrentTime);
X
X    TwmContext = XUniqueContext();
X    MenuContext = XUniqueContext();
X
X    /* define cursors */
X
X    ArrowCursor = XCreateFontCursor(dpy, XC_top_left_arrow);
X    MoveCursor = XCreateFontCursor(dpy, XC_fleur);
X    RightArrowCursor = XCreateFontCursor(dpy, XC_sb_right_arrow);
X    ButtonCursor = XCreateFontCursor(dpy, XC_center_ptr);
X    ClockCursor = XCreateFontCursor(dpy, XC_watch);
X
X    XGrabServer(dpy);
X    XSync(dpy, 0);
X    XQueryTree(dpy, Root, &root, &parent, &children, &nchildren);
X
X    ParseTwmrc(NULL);
X    FirstTime = FALSE;
X    CreateGCs();
X
X    for (i = 0; i < nchildren; i++)
X    {
X	if (MappedNotOverride(children[i]))
X	{
X	    AddWindow(children[i]);
X	}
X    }
X
X    /* contruct the version string */
X    sprintf(Version, "%s", &Revision[1]);
X    Version[strlen(Version) - 1] = '\0';
X    sscanf(&Date[7], "%d/%d/%d", &y, &m, &d);
X    sprintf(Version, "%s  Date: %d/%d/%d %s", Version, m, d, y, &Date[16]);
X    Version[strlen(Version) - 2] = '\0';
X
X    VersionWindow = XCreateSimpleWindow(dpy, Root,
X	0, 0,
X	twm_width + XTextWidth(VersionFont, Version, strlen(Version)) + 20,
X	VersionFontHeight + 4,
X	BW,
X	Foreground, Background);
X
X    valuemask = CWBackPixmap;
X    attributes.background_pixmap = MakePixmap(VersionWindow, TitleNormalGC,
X	twm_bits, twm_width, twm_height);
X
X    XCreateWindow(dpy, VersionWindow,
X	4, 1,
X	twm_width, twm_height,
X	0, DefaultDepth(dpy, 0), CopyFromParent, DefaultVisual(dpy, 0),
X	valuemask, &attributes);
X
X    XSelectInput(dpy, VersionWindow, ExposureMask);
X    XMapSubwindows(dpy, VersionWindow);
X    XMapWindow(dpy, VersionWindow);
X
X    SizeWindow = XCreateSimpleWindow(dpy, Root,
X	0, 0,
X	100,
X	SizeFontHeight + 4,
X	BW,
X	Foreground, Background);
X
X
X    XUngrabServer(dpy);
X
X    HandleEvents();
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	Done - cleanup and exit twm
X *
X *  Returned Value:
X *	none
X *
X *  Inputs:
X *	none
X *
X *  Outputs:
X *	none
X *
X *  Special Considerations:
X *	none
X *
X ***********************************************************************
X */
X
Xvoid
XDone()
X{
X    TwmWindow *tmp;			/* temp twm window structure */
X    unsigned x, y;
X    XWindowChanges xwc;		/* change window structure */
X    unsigned int xwcm;		/* change window mask */
X
X    /* put a border back around all windows */
X
X    for (tmp = TwmRoot.next; tmp != NULL; tmp = tmp->next)
X    {
X	XGetGeometry(dpy, tmp->w, &JunkRoot, &x, &y, &JunkWidth, &JunkHeight,
X	    &JunkBW, &JunkDepth);
X
X	xwcm = CWX | CWY | CWBorderWidth;
X
X	xwc.x = x - (2 * BorderWidth);
X	xwc.y = y - (2 * BorderWidth);
X	xwc.border_width = BorderWidth;
X
X	XConfigureWindow(dpy, tmp->w, xwcm, &xwc);
X    }
X
X    XSetInputFocus(dpy, Root, RevertToPointerRoot, CurrentTime);
X    XCloseDisplay(dpy);
X    exit(0);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	Error - X error handler.  Print the error and exit.
X *
X *  Inputs:
X *	dpy	- the connection to the X server
X *	event	- the error event structure
X *
X ***********************************************************************
X */
X
Xvoid
XError(dpy, event)
XDisplay *dpy;
XXErrorEvent *event;
X{
X    char buffer[BUFSIZ];
X
X    XGetErrorText(dpy, event->error_code, buffer, BUFSIZ);
X    (void) fprintf(stderr, "X Error: %s\n", buffer);
X    (void) fprintf(stderr, "  Request Major code: %d\n", event->request_code);
X    (void) fprintf(stderr, "  Request Minor code: %d\n", event->minor_code);
X    (void) fprintf(stderr, "  ResourceId 0x%x\n", event->resourceid);
X    (void) fprintf(stderr, "  Error Serial #%d\n", event->serial);
X    (void) fprintf(stderr, "  Current Serial #%d\n", dpy->request);
X
X    Done();
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	Other - error handler called if something else has set 
X *		the attributes on the root window.  Typically
X *		another window manager.
X *
X ***********************************************************************
X */
X
Xvoid
XOther(dpy, event)
XDisplay *dpy;
XXErrorEvent *event;
X{
X    fprintf(stderr, "twm: Are you running another window manager?\n");
X    exit(1);
X}
SHAR_EOF
if test 11469 -ne "`wc -c < twm.c`"
then
    echo shar: error transmitting "twm.c" '(should have been 11469 characters)'
fi
fi
if test -f 'parse.c'
then
    echo shar: will not over-write existing file "parse.c"
else
echo extracting "parse.c"
sed 's/^X//' >parse.c <<'SHAR_EOF'
X/*****************************************************************************/
X/**       Copyright 1988 by Evans & Sutherland Computer Corporation,        **/
X/**                          Salt Lake City, Utah                           **/
X/**                                                                         **/
X/**                           All Rights Reserved                           **/
X/**                                                                         **/
X/**    Permission to use, copy, modify, and distribute this software and    **/
X/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
X/**    granted, provided that the above copyright notice appear  in  all    **/
X/**    copies and that both  that  copyright  notice  and  this  permis-    **/
X/**    sion  notice appear in supporting  documentation,  and  that  the    **/
X/**    name  of Evans & Sutherland  not be used in advertising or publi-    **/
X/**    city pertaining to distribution  of the software without  specif-    **/
X/**    ic, written prior permission.                                        **/
X/**                                                                         **/
X/**    EVANS  & SUTHERLAND  DISCLAIMS  ALL  WARRANTIES  WITH  REGARD  TO    **/
X/**    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILI-    **/
X/**    TY AND FITNESS, IN NO EVENT SHALL EVANS &  SUTHERLAND  BE  LIABLE    **/
X/**    FOR  ANY  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY  DAM-    **/
X/**    AGES  WHATSOEVER RESULTING FROM  LOSS OF USE,  DATA  OR  PROFITS,    **/
X/**    WHETHER   IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS    **/
X/**    ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE  OR PER-    **/
X/**    FORMANCE OF THIS SOFTWARE.                                           **/
X/*****************************************************************************/
X
X/***********************************************************************
X *
X * $Header: parse.c,v 1.13 88/04/15 07:09:29 tlastran Exp $
X *
X * parse the .twmrc file
X *
X * 17-Nov-87 Thomas E. LaStrange		File created
X *
X ***********************************************************************/
X
X#ifndef lint
Xstatic char RCSinfo[]=
X"$Header: parse.c,v 1.13 88/04/15 07:09:29 tlastran Exp $";
X#endif
X
X#include <stdio.h>
X#include "twm.h"
X#include "menus.h"
X#include "util.h"
X
X#define BUF_LEN 300
X
Xstatic FILE *twmrc;
Xstatic int ptr = 0;
Xstatic int len = 0;
Xstatic char buff[BUF_LEN+1];
Xextern int yylineno;
X
X/***********************************************************************
X *
X *  Procedure:
X *	ParseTwmrc - parse the .twmrc file
X *
X *  Inputs:
X *	filename  - the filename to parse.  A NULL indicates $HOME/.twmrc
X *
X ***********************************************************************
X */
X
Xvoid
XParseTwmrc(filename)
Xchar *filename;
X{
X    char *home;
X    char init_file[200];
X
X    InitMenus();
X    InitButtons();
X
X    if (filename == NULL)
X    {
X	home = (char *)getenv("HOME");
X	strcpy(init_file, home);
X	strcat(init_file, "/.twmrc");
X    }
X    else
X	strcpy(init_file, filename);
X
X    if ((twmrc = fopen(init_file, "r")) == NULL)
X    {
X	fprintf(stderr, "twm: couldn't open \"%s\"\n", init_file);
X    	return;
X    }
X
X    ptr = 0;
X    len = 0;
X    yylineno = 0;
X    ParseError = FALSE;
X
X    yyparse();
X
X    fclose(twmrc);
X
X    if (ParseError)
X    {
X	fprintf(stderr, "twm: errors found in \"%s\", twm aborting\n",
X	    init_file);
X	Done();
X    }
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	TwmInput - redefinition of the lex input routine
X *
X *  Returned Value:
X *	the next input character
X *
X ***********************************************************************
X */
X
Xchar
XTwmInput()
X{
X    while (ptr == len)
X    {
X	if (fgets(buff, BUF_LEN, twmrc) == NULL)
X	    return NULL;
X
X	yylineno++;
X
X	ptr = 0;
X	len = strlen(buff);
X    }
X    return (buff[ptr++]);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	TwmUnput - redefinition of the lex unput routine
X *
X *  Inputs:
X *	c	- the character to push back onto the input stream
X *
X ***********************************************************************
X */
X
Xvoid
XTwmUnput(c)
X{
X    buff[--ptr] = c;
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	TwmOutput - redefinition of the lex output routine
X *
X *  Inputs:
X *	c	- the character to print
X *
X ***********************************************************************
X */
X
Xvoid
XTwmOutput(c)
X{
X    putchar(c);
X}
SHAR_EOF
if test 4582 -ne "`wc -c < parse.c`"
then
    echo shar: error transmitting "parse.c" '(should have been 4582 characters)'
fi
fi
# end of shell archive
exit 0

