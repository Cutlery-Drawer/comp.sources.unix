Subject:  v15i065:  A window manager for X, Part02/04
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Tom LaStrange <esunix!tlastran>
Posting-number: Volume 15, Issue 65
Archive-name: twm/part02



#! /bin/sh
# This is a shell archive, meaning:
# 1.  Remove everything above the #! /bin/sh line.
# 2.  Save the resulting test in a file
# 3.  Execute the file with /bin/sh (not csh) to create the files:
#
#menus.c
#events.c
#resize.c
#util.c
#version.c
#
#
if test -f 'menus.c'
then
    echo shar: will not over-write existing file "menus.c"
else
echo extracting "menus.c"
sed 's/^X//' >menus.c <<'SHAR_EOF'
X/*****************************************************************************/
X/**       Copyright 1988 by Evans & Sutherland Computer Corporation,        **/
X/**                          Salt Lake City, Utah                           **/
X/**                                                                         **/
X/**                           All Rights Reserved                           **/
X/**                                                                         **/
X/**    Permission to use, copy, modify, and distribute this software and    **/
X/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
X/**    granted, provided that the above copyright notice appear  in  all    **/
X/**    copies and that both  that  copyright  notice  and  this  permis-    **/
X/**    sion  notice appear in supporting  documentation,  and  that  the    **/
X/**    name  of Evans & Sutherland  not be used in advertising or publi-    **/
X/**    city pertaining to distribution  of the software without  specif-    **/
X/**    ic, written prior permission.                                        **/
X/**                                                                         **/
X/**    EVANS  & SUTHERLAND  DISCLAIMS  ALL  WARRANTIES  WITH  REGARD  TO    **/
X/**    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILI-    **/
X/**    TY AND FITNESS, IN NO EVENT SHALL EVANS &  SUTHERLAND  BE  LIABLE    **/
X/**    FOR  ANY  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY  DAM-    **/
X/**    AGES  WHATSOEVER RESULTING FROM  LOSS OF USE,  DATA  OR  PROFITS,    **/
X/**    WHETHER   IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS    **/
X/**    ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE  OR PER-    **/
X/**    FORMANCE OF THIS SOFTWARE.                                           **/
X/*****************************************************************************/
X
X/***********************************************************************
X *
X * $Header: menus.c,v 1.20 88/04/15 07:09:54 tlastran Exp $
X *
X * twm menu code
X *
X * 17-Nov-87 Thomas E. LaStrange		File created
X *
X ***********************************************************************/
X
X#ifndef lint
Xstatic char RCSinfo[] =
X"$Header: menus.c,v 1.20 88/04/15 07:09:54 tlastran Exp $";
X#endif
X
X#include <stdio.h>
X#include <signal.h>
X#include "twm.h"
X#include "gc.h"
X#include "menus.h"
X#include "events.h"
X#include "util.h"
X#include "gram.h"
X
X#include "pull.bm"
X
XMenuRoot *Menu[MAX_BUTTONS + 1];	/* one root per button */
XMenuItem *Item[MAX_BUTTONS + 1];	/* one action per button */
XMenuRoot *MenuList = NULL;		/* head of the menu list */
XMenuRoot *LastMenu = NULL;		/* the last menu */
XMenuRoot *ActiveMenu = NULL;		/* the active menu */
XMenuItem *ActiveItem = NULL;		/* the active menu item */
X
X/***********************************************************************
X *
X *  Procedure:
X *	InitMenus - initialize menu roots
X *
X ***********************************************************************
X */
X
Xvoid
XInitMenus()
X{
X    int i;
X
X    for (i = 0; i < (MAX_BUTTONS + 1); i++)
X    {
X	Menu[i] = NULL;
X	Item[i] = NULL;
X    }
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	NewMenuRoot - create a new menu root
X *
X *  Returned Value:
X *	(MenuRoot *)
X *
X *  Inputs:
X *	name	- the name of the menu root
X *
X ***********************************************************************
X */
X
XMenuRoot *
XNewMenuRoot(name)
X    char *name;
X{
X    MenuRoot *tmp;
X
X    CreateGCs();
X
X    tmp = (MenuRoot *) malloc(sizeof(MenuRoot));
X    tmp->name = name;
X    tmp->prev = NULL;
X    tmp->first = NULL;
X    tmp->last = NULL;
X    tmp->items = 0;
X    tmp->width = 0;
X    tmp->mapped = FALSE;
X    tmp->pull = FALSE;
X    tmp->active = TRUE;
X    tmp->shadow = XCreateSimpleWindow(dpy, Root,
X	0, 0, 10, 10, 1, Foreground, Foreground);
X    tmp->w = XCreateSimpleWindow(dpy, Root,
X	0, 0, 10, 10, 1, Foreground, Background);
X    XSelectInput(dpy, tmp->w, LeaveWindowMask);
X
X    if (MenuList == NULL)
X    {
X	MenuList = tmp;
X	MenuList->next = NULL;
X    }
X
X    if (LastMenu == NULL)
X    {
X	LastMenu = tmp;
X	LastMenu->next = NULL;
X    }
X    else
X    {
X	LastMenu->next = tmp;
X	LastMenu = tmp;
X	LastMenu->next = NULL;
X    }
X
X    return (tmp);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	AddToMenu - add an item to a root menu
X *
X *  Returned Value:
X *	(MenuItem *)
X *
X *  Inputs:
X *	menu	- pointer to the root menu to add the item
X *	item	- the text to appear in the menu
X *	action	- the string to possibly execute
X *	sub	- the menu root if it is a pull-right entry
X *	func	- the numeric function
X *
X ***********************************************************************
X */
X
XMenuItem *
XAddToMenu(menu, item, action, sub, func)
X    MenuRoot *menu;
X    char *item, *action;
X    MenuRoot *sub;
X    int func;
X{
X    unsigned long valuemask;
X    XSetWindowAttributes attributes;
X    MenuItem *tmp;
X    int width;
X
X#ifdef DEBUG
X    fprintf(stderr, "adding menu item=\"%s\", action=%s, sub=%d, f=%d\n",
X	item, action, sub, func);
X#endif
X
X    tmp = (MenuItem *) malloc(sizeof(MenuItem));
X    tmp->root = menu;
X
X    if (menu->first == NULL)
X    {
X	menu->first = tmp;
X	tmp->prev = NULL;
X    }
X    else
X    {
X	menu->last->next = tmp;
X	tmp->prev = menu->last;
X    }
X    menu->last = tmp;
X
X    tmp->item = item;
X    tmp->action = action;
X    tmp->next = NULL;
X    tmp->sub = NULL;
X    tmp->pull = NULL;
X    tmp->state = 0;
X    tmp->func = func;
X
X    width = XTextWidth(MenuFont, item, strlen(item));
X    if (width > menu->width)
X	menu->width = width;
X
X    if (tmp->func != F_TITLE)
X    {
X	tmp->w = XCreateSimpleWindow(dpy, menu->w,
X	    0, menu->items * (MenuFontHeight + 4),
X	    width, MenuFontHeight + 4,
X	    0,
X	    Foreground, Background);
X	XSelectInput(dpy, tmp->w, EnterWindowMask
X	    | LeaveWindowMask | ExposureMask);
X    }
X    else
X    {
X	tmp->w = XCreateSimpleWindow(dpy, menu->w,
X	    -1, menu->items * (MenuFontHeight + 4),
X	    width, MenuFontHeight + 2,
X	    1,
X	    Foreground, Background);
X	XSelectInput(dpy, tmp->w, ExposureMask);
X    }
X
X    if (sub != NULL)
X    {
X	Pixmap pm;
X
X	tmp->sub = sub;
X	pm = MakePixmap(tmp->w, MenuNormalGC,
X	    pull_bits, pull_width, pull_height);
X
X	valuemask = CWEventMask | CWBackPixmap;
X	attributes.background_pixmap = pm;
X	attributes.event_mask = EnterWindowMask | LeaveWindowMask;
X
X	tmp->pull = XCreateWindow(dpy, tmp->w,
X	    0, 0,
X	    pull_width, pull_height,
X	    0, DefaultDepth(dpy, 0), CopyFromParent, DefaultVisual(dpy, 0),
X	    valuemask, &attributes);
X
X	XMapWindow(dpy, tmp->pull);
X
X	menu->pull = TRUE;
X	XSaveContext(dpy, tmp->pull, MenuContext, tmp);
X    }
X    menu->items += 1;
X
X    XSaveContext(dpy, tmp->w, MenuContext, tmp);
X
X    if (menu->items == 1)
X	XSaveContext(dpy, tmp->root->w, MenuContext, tmp);
X
X    return (tmp);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	PopUpMenu - pop up a pull down menu
X *
X *  Inputs:
X *	menu	- the root pointer of the menu to pop up
X *	x	- the x location of the mouse
X *	y	- the y location of the mouse
X *
X ***********************************************************************
X */
X
Xvoid
XPopUpMenu(menu, x, y)
X    MenuRoot *menu;
X    int x, y;
X{
X    int d_width, d_height, m_height;
X    XWindowChanges xwc, pwc;
X    unsigned int xwcm, pwcm;
X    MenuItem *tmp;
X
X    if (ActiveMenu != NULL)
X	ActiveMenu->active = FALSE;
X
X    menu->active = TRUE;
X    ActiveMenu = menu;
X    if (menu->mapped != TRUE)
X    {
X	if (menu->pull == TRUE)
X	{
X	    menu->width += pull_width + 10;
X	}
X
X	xwcm = 0;
X	xwcm |= CWWidth;
X	xwc.width = menu->width + 10;
X
X	pwcm = 0;
X	pwcm |= CWX;
X	pwc.x = xwc.width - pull_width;
X
X	for (tmp = menu->first; tmp != NULL; tmp = tmp->next)
X	{
X	    XConfigureWindow(dpy, tmp->w, xwcm, &xwc);
X	    if (tmp->pull != NULL)
X	    {
X		XConfigureWindow(dpy, tmp->pull, pwcm, &pwc);
X	    }
X	    if (tmp->func != F_TITLE)
X		tmp->y = 5;
X	    else
X	    {
X		tmp->y = xwc.width - XTextWidth(MenuFont, tmp->item,
X		    strlen(tmp->item));
X		tmp->y /= 2;
X	    }
X	}
X    }
X    menu->mapped = TRUE;
X
X    d_width = DisplayWidth(dpy, DefaultScreen(dpy));
X    d_height = DisplayHeight(dpy, DefaultScreen(dpy));
X    m_height = menu->items * (MenuFontHeight + 4);
X
X    if ((x + menu->width + 10) > d_width)
X	x = (d_width - menu->width - 20);
X
X    if ((y + m_height + 10) > d_height)
X	y = (d_height - m_height - 20);
X
X    xwcm = 0;
X    xwcm |= CWX;
X    xwc.x = x - 1;
X    xwcm |= CWY;
X    xwc.y = y - ((MenuFontHeight + 4) / 2);
X    xwcm |= CWWidth;
X    xwc.width = menu->width + 10;
X    xwcm |= CWHeight;
X    xwc.height = m_height;
X
X    XConfigureWindow(dpy, menu->w, xwcm, &xwc);
X
X    xwc.x = xwc.x + 5;
X    xwc.y = xwc.y + 5;
X    /* xwc.width -= 20; xwc.height -= 20; */
X
X    XConfigureWindow(dpy, menu->shadow, xwcm, &xwc);
X    XWarpPointer(dpy, None, menu->w, 0, 0, 0, 0, 1, (MenuFontHeight + 4) / 2);
X    XMapSubwindows(dpy, menu->w);
X    XRaiseWindow(dpy, menu->shadow);
X    XMapRaised(dpy, menu->w);
X    XMapWindow(dpy, menu->shadow);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	FindMenuRoot - look for a menu root
X *
X *  Returned Value:
X *	(MenuRoot *)  - a pointer to the menu root structure 
X *
X *  Inputs:
X *	name	- the name of the menu root 
X *
X ***********************************************************************
X */
X
XMenuRoot *
XFindMenuRoot(name)
X    char *name;
X{
X    MenuRoot *tmp;
X
X    for (tmp = MenuList; tmp != NULL; tmp = tmp->next)
X    {
X	if (strcmp(name, tmp->name) == 0)
X	    return (tmp);
X    }
X    return NULL;
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	ExecuteFunction - execute a twm root function
X *
X *  Inputs:
X *	menu - the menu item to execute 
X *
X ***********************************************************************
X */
X
Xvoid
XExecuteFunction(menu)
X    MenuItem *menu;
X{
X    Window w;
X    unsigned long black;
X    char tmp[200];
X    char *ptr;
X    int len;
X    char buff[MAX_FILE_SIZE];
X    int count, fd;
X    MenuRoot *root, *tmp_root;
X    MenuItem *item, *tmp_item;
X
X    XGrabPointer(dpy, Root, True,
X	ButtonReleaseMask | ButtonMotionMask,
X	GrabModeAsync, GrabModeSync,
X	Root, ClockCursor, CurrentTime);
X
X    switch (menu->func)
X    {
X    case F_NOP:
X    case F_TITLE:
X	break;
X
X    case F_CIRCLEUP:
X	XCirculateSubwindowsUp(dpy, Root);
X	break;
X
X    case F_CIRCLEDOWN:
X	XCirculateSubwindowsDown(dpy, Root);
X	break;
X
X    case F_VERSION:
X	XMapRaised(dpy, VersionWindow);
X	break;
X
X    case F_EXEC:
X	Execute(menu->action);
X	break;
X
X    case F_FOCUS:
X	FocusOnRoot();
X	break;
X
X    case F_CUT:
X	strcpy(tmp, menu->action);
X	strcat(tmp, "\n");
X	XStoreBytes(dpy, tmp, strlen(tmp));
X	break;
X
X    case F_CUTFILE:
X	ptr = XFetchBytes(dpy, &count);
X	if (count != 0)
X	{
X	    if (sscanf(ptr, "%s", tmp) == 1)
X	    {
X		fd = open(tmp, 0);
X		if (fd >= 0)
X		{
X		    count = read(fd, buff, MAX_FILE_SIZE - 1);
X		    if (count > 0)
X			XStoreBytes(dpy, buff, strlen(buff));
X
X		    close(fd);
X		}
X		else
X		{
X		    fprintf(stderr, "twm: couldn't open \"%s\"\n", tmp);
X		}
X	    }
X	    XFree(ptr);
X	}
X	else
X	{
X	    fprintf(stderr, "twm: nothing in the cut buffer\n");
X	}
X	break;
X
X    case F_FILE:
X	fd = open(menu->action, 0);
X	if (fd >= 0)
X	{
X	    count = read(fd, buff, MAX_FILE_SIZE - 1);
X	    if (count > 0)
X		XStoreBytes(dpy, buff, strlen(buff));
X
X	    close(fd);
X	}
X	else
X	{
X	    fprintf(stderr, "twm: couldn't open \"%s\"\n", menu->action);
X	}
X	break;
X
X    case F_TWMRC:
X	len = strlen(menu->action);
X	if (len == 0)
X	    ptr = NULL;
X	else
X	{
X	    ptr = (char *)malloc(len+1);
X	    if (ptr == NULL)
X	    {
X		fprintf(stderr, "twm: out of memory\n");
X		exit(1);
X	    }
X	    strcpy(ptr, menu->action);
X	}
X
X	/* first get rid of the existing menu structure and destroy all
X	 * windows */
X	for (root = MenuList; root != NULL;)
X	{
X	    for (item = root->last; item != NULL;)
X	    {
X		if (item->pull != NULL)
X		{
X		    XDeleteContext(dpy, item->pull, MenuContext);
X		    XDestroyWindow(dpy, item->pull);
X		}
X		XDeleteContext(dpy, item->w, MenuContext);
X		XDestroyWindow(dpy, item->w);
X
X		free(item->item);
X		free(item->action);
X
X		tmp_item = item;
X		item = item->prev;
X		free(tmp_item);
X	    }
X
X	    XDeleteContext(dpy, root->w, MenuContext);
X	    XDestroyWindow(dpy, root->shadow);
X	    XDestroyWindow(dpy, root->w);
X	    free(root->name);
X
X	    tmp_root = root;
X	    root = root->next;
X	    free(tmp_root);
X	}
X	MenuList = NULL;
X	LastMenu = NULL;
X	ActiveMenu = NULL;
X	ActiveItem = NULL;
X
X	ParseTwmrc(ptr);
X	break;
X
X    case F_REFRESH:
X	black = BlackPixel(dpy, DefaultScreen(dpy));
X	w = XCreateSimpleWindow(dpy, Root,
X	    0, 0, 9999, 9999, 0, black, black);
X	XMapWindow(dpy, w);
X	XDestroyWindow(dpy, w);
X	XFlush(dpy);
X	break;
X
X    case F_QUIT:
X	Done();
X	break;
X    }
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	Execute - execute the string by /bin/sh
X *
X *  Inputs:
X *	s	- the string containing the command
X *
X ***********************************************************************
X */
X
Xvoid
XExecute(s)
X    char *s;
X{
X    int status, pid, w;
X    register int (*istat) (), (*qstat) ();
X
X    if ((pid = vfork()) == 0)
X    {
X	signal(SIGINT, SIG_DFL);
X	signal(SIGQUIT, SIG_DFL);
X	signal(SIGHUP, SIG_DFL);
X	execl("/bin/sh", "sh", "-c", s, 0);
X	_exit(127);
X    }
X    istat = signal(SIGINT, SIG_IGN);
X    qstat = signal(SIGQUIT, SIG_IGN);
X    while ((w = wait(&status)) != pid && w != -1);
X    if (w == -1)
X	status = -1;
X    signal(SIGINT, istat);
X    signal(SIGQUIT, qstat);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	FocusOnRoot - put input focus on the root window
X *
X ***********************************************************************
X */
X
Xvoid
XFocusOnRoot()
X{
X    XSetInputFocus(dpy, Root, RevertToPointerRoot, CurrentTime);
X    if (Focus != NULL)
X    {
X	XUnmapWindow(dpy, Focus->hilite_w);
X    }
X    Focus = NULL;
X    FocusRoot = TRUE;
X}
SHAR_EOF
if test 13977 -ne "`wc -c < menus.c`"
then
    echo shar: error transmitting "menus.c" '(should have been 13977 characters)'
fi
fi
if test -f 'events.c'
then
    echo shar: will not over-write existing file "events.c"
else
echo extracting "events.c"
sed 's/^X//' >events.c <<'SHAR_EOF'
X/*****************************************************************************/
X/**       Copyright 1988 by Evans & Sutherland Computer Corporation,        **/
X/**                          Salt Lake City, Utah                           **/
X/**                                                                         **/
X/**                           All Rights Reserved                           **/
X/**                                                                         **/
X/**    Permission to use, copy, modify, and distribute this software and    **/
X/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
X/**    granted, provided that the above copyright notice appear  in  all    **/
X/**    copies and that both  that  copyright  notice  and  this  permis-    **/
X/**    sion  notice appear in supporting  documentation,  and  that  the    **/
X/**    name  of Evans & Sutherland  not be used in advertising or publi-    **/
X/**    city pertaining to distribution  of the software without  specif-    **/
X/**    ic, written prior permission.                                        **/
X/**                                                                         **/
X/**    EVANS  & SUTHERLAND  DISCLAIMS  ALL  WARRANTIES  WITH  REGARD  TO    **/
X/**    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILI-    **/
X/**    TY AND FITNESS, IN NO EVENT SHALL EVANS &  SUTHERLAND  BE  LIABLE    **/
X/**    FOR  ANY  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY  DAM-    **/
X/**    AGES  WHATSOEVER RESULTING FROM  LOSS OF USE,  DATA  OR  PROFITS,    **/
X/**    WHETHER   IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS    **/
X/**    ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE  OR PER-    **/
X/**    FORMANCE OF THIS SOFTWARE.                                           **/
X/*****************************************************************************/
X
X/***********************************************************************
X *
X * $Header: events.c,v 1.31 88/04/15 07:09:47 tlastran Exp $
X *
X * twm event handling
X *
X * 17-Nov-87 Thomas E. LaStrange		File created
X *
X ***********************************************************************/
X
X#ifndef lint
Xstatic char RCSinfo[]=
X"$Header: events.c,v 1.31 88/04/15 07:09:47 tlastran Exp $";
X#endif
X
X#include <stdio.h>
X#include "twm.h"
X#include "add_window.h"
X#include "menus.h"
X#include "events.h"
X#include "resize.h"
X#include "gram.h"
X
X#include "twm.bm"
X
Xstatic event_proc EventHandler[LASTEvent]; /* event handler jump table */
Xstatic XEvent event;		/* the current event */
Xstatic TwmWindow *tmp_win;	/* the current twm window */
Xstatic Window w;		/* the window that caused the event */
X
Xstatic int ConstMove = FALSE;	/* constrained move variables */
Xstatic int ConstMoveDir;
Xstatic int ConstMoveX;
Xstatic int ConstMoveY;
Xstatic int ConstMoveXL;
Xstatic int ConstMoveXR;
Xstatic int ConstMoveYT;
Xstatic int ConstMoveYB;
X
X#define MOVE_NONE	0	/* modes of constrained move */
X#define MOVE_VERT	1
X#define MOVE_HORIZ	2
X
Xstatic Window DragWindow;	/* variables used in moving windows */
Xstatic int DragX;
Xstatic int DragY;
Xstatic int DragWidth;
Xstatic int DragHeight;
Xstatic int enter_flag;
X
X
X/***********************************************************************
X *
X *  Procedure:
X *	InitEvents - initialize the event jump table
X *
X ***********************************************************************
X */
X
Xvoid
XInitEvents()
X{
X    int i;
X
X    ResizeWindow = NULL;
X    DragWindow = NULL;
X    enter_flag = FALSE;
X
X    for (i = 0; i < LASTEvent; i++)
X	EventHandler[i] = HandleUnknown;
X
X    EventHandler[Expose] = HandleExpose;
X    EventHandler[DestroyNotify] = HandleDestroyNotify;
X    EventHandler[MapRequest] = HandleMapRequest;
X    EventHandler[MapNotify] = HandleMapNotify;
X    EventHandler[UnmapNotify] = HandleUnmapNotify;
X    EventHandler[MotionNotify] = HandleMotionNotify;
X    EventHandler[ButtonRelease] = HandleButtonRelease;
X    EventHandler[ButtonPress] = HandleButtonPress;
X    EventHandler[EnterNotify] = HandleEnterNotify;
X    EventHandler[LeaveNotify] = HandleLeaveNotify;
X    EventHandler[ConfigureNotify] = HandleConfigureNotify;
X    EventHandler[ClientMessage] = HandleClientMessage;
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleEvents - handle X events
X *
X ***********************************************************************
X */
X
Xvoid
XHandleEvents()
X{
X    InitEvents();
X
X    while (TRUE)
X    {
X	XNextEvent(dpy, &event);
X	w = event.xany.window;
X	if (XFindContext(dpy, w, TwmContext, &tmp_win) == XCNOENT)
X	    tmp_win = NULL;
X
X#ifdef DEBUG
X	if (event.type != MotionNotify)
X	if (tmp_win != NULL)
X	{
X	    fprintf(stderr, "Event w=%x, t->w=%x, t->frame=%x, t->title=%x, ",
X		w, tmp_win->w, tmp_win->frame, tmp_win->title_w);
X	}
X	else
X	{
X	    fprintf(stderr, "Event w=%x, ", w);
X	}
X#endif
X	if (event.type >= 0 && event.type < LASTEvent)
X	    (*EventHandler[event.type])();
X    }
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleClientMessage - client message event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleClientMessage()
X{
X#ifdef DEBUG
X    fprintf(stderr, "ClientMessage\n");
X#endif
X
X    enter_flag = FALSE;
X}
X/***********************************************************************
X *
X *  Procedure:
X *	HandleExpose - expose event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleExpose()
X{
X    MenuItem *tmp;
X
X#ifdef DEBUG
X    fprintf(stderr, "Expose %d\n", event.xexpose.count);
X#endif
X
X    if (event.xexpose.count != 0)
X	return;
X
X    if (w == VersionWindow)
X    {
X	XDrawImageString(dpy, VersionWindow, VersionNormalGC,
X	    twm_width + 10,
X	    2 + VersionFont->ascent, Version, strlen(Version));
X    }
X
X    if (tmp_win != NULL)
X    {
X	if (tmp_win->title_w == w)
X	{
X	    XDrawImageString(dpy, tmp_win->title_w,
X		TitleNormalGC,
X		TitleBarX, TitleBarY,
X		tmp_win->name, strlen(tmp_win->name));
X	    return;
X	}
X
X	if (tmp_win->icon_w == w)
X	{
X	    XDrawImageString(dpy, tmp_win->icon_w,
X		IconNormalGC,
X		tmp_win->icon_x, tmp_win->icon_y,
X		tmp_win->icon_name, strlen(tmp_win->icon_name));
X	    return;
X	}
X    }
X
X    if (XFindContext(dpy, w, MenuContext, &tmp) == 0)
X    {
X	if (tmp->state)
X	    XDrawImageString(dpy,w, MenuReverseGC, tmp->y, MenuY,
X		tmp->item, strlen(tmp->item));
X	else
X	    XDrawImageString(dpy,w, MenuNormalGC, tmp->y, MenuY,
X		tmp->item, strlen(tmp->item));
X
X	return;
X    }
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleDestroyNotify - DestroyNotify event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleDestroyNotify()
X{
X#ifdef DEBUG
X    fprintf(stderr, "DestroyNotify\n");
X#endif
X    if (tmp_win == NULL)
X	return;
X
X    if (tmp_win == Focus)
X    {
X	FocusOnRoot();
X    }
X    XDeleteContext(dpy, tmp_win->w, TwmContext);
X    XDeleteContext(dpy, tmp_win->frame, TwmContext);
X    XDeleteContext(dpy, tmp_win->title_w, TwmContext);
X    XDeleteContext(dpy, tmp_win->iconify_w, TwmContext);
X    XDeleteContext(dpy, tmp_win->resize_w, TwmContext);
X    XDeleteContext(dpy, tmp_win->icon_w, TwmContext);
X    XDeleteContext(dpy, tmp_win->focus_w, TwmContext);
X    XDeleteContext(dpy, tmp_win->hilite_w, TwmContext);
X
X    XDestroyWindow(dpy, tmp_win->frame);
X    XDestroyWindow(dpy, tmp_win->icon_w);
X    tmp_win->prev->next = tmp_win->next;
X    if (tmp_win->next != NULL)
X	tmp_win->next->prev = tmp_win->prev;
X
X    free((char *)tmp_win);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleMapRequest - MapRequest event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleMapRequest()
X{
X    int stat;
X    XWindowChanges xwc;
X    unsigned int   xwcm;
X
X#ifdef DEBUG
X    fprintf(stderr, "MapRequest\n");
X#endif
X
X    stat = XFindContext(dpy, event.xmaprequest.window, TwmContext, &tmp_win);
X    if (stat == XCNOENT)
X	tmp_win = NULL;
X
X    if (tmp_win == NULL)
X    {
X	tmp_win = AddWindow(event.xmaprequest.window);
X	if (tmp_win->wmhints && (tmp_win->wmhints->flags & StateHint))
X	{
X	    switch (tmp_win->wmhints->initial_state)
X	    {
X		case DontCareState:
X		case NormalState:
X		case ZoomState:
X		case InactiveState:
X		    XMapWindow(dpy, event.xmaprequest.window);
X		    XMapRaised(dpy, tmp_win->frame);
X		    break;
X
X		case IconicState:
X		    xwcm = 0;
X		    xwcm |= CWX;
X		    xwcm |= CWY;
X
X		    xwc.x = 0;
X		    xwc.y = 0;
X
X		    if (tmp_win->wmhints->flags & IconPositionHint)
X		    {
X			xwc.x = tmp_win->wmhints->icon_x;
X			xwc.y = tmp_win->wmhints->icon_y;
X		    }
X
X		    XConfigureWindow(dpy, tmp_win->icon_w, xwcm, &xwc);
X		    XMapSubwindows(dpy, tmp_win->icon_w);
X		    XMapRaised(dpy, tmp_win->icon_w);
X		    tmp_win->iconified = TRUE;
X		    tmp_win->icon = TRUE;
X		    break;
X	    }
X	}
X	else
X	{
X	    if (!tmp_win->icon)
X	    {
X		XMapWindow(dpy, event.xmaprequest.window);
X		XMapRaised(dpy, tmp_win->frame);
X	    }
X	}
X    }
X    else
X    {
X	if (!tmp_win->icon)
X	{
X	    XMapWindow(dpy, event.xmaprequest.window);
X	    XMapRaised(dpy, tmp_win->frame);
X	}
X    }
X    XRaiseWindow(dpy, VersionWindow);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleMapNotify - MapNotify event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleMapNotify()
X{
X#ifdef DEBUG
X    fprintf(stderr, "MapNotify\n");
X#endif
X    if (tmp_win == NULL)
X	return;
X
X    XMapSubwindows(dpy, tmp_win->title_w);
X    XMapSubwindows(dpy, tmp_win->frame);
X    XUnmapWindow(dpy, tmp_win->hilite_w);
X
X    if (tmp_win->title_height == 0)
X	XUnmapWindow(dpy, tmp_win->title_w);
X
X    XMapRaised(dpy, tmp_win->frame);
X    tmp_win->mapped = TRUE;
X    XRaiseWindow(dpy, VersionWindow);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleUnmapNotify - UnmapNotify event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleUnmapNotify()
X{
X#ifdef DEBUG
X    fprintf(stderr, "UnmapNotify\n");
X#endif
X    if (tmp_win == NULL)
X	return;
X
X    XUnmapWindow(dpy, tmp_win->frame);
X    tmp_win->mapped = FALSE;
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleMotionNotify - MotionNotify event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleMotionNotify()
X{
X#ifdef DEBUG
X    /*
X    fprintf(stderr, "MotionNotify\n");
X    */
X#endif
X    /*XUnmapWindow(dpy, VersionWindow);*/
X    if (ConstMove)
X    {
X	switch (ConstMoveDir)
X	{
X	    case MOVE_NONE:
X		if (event.xbutton.x_root < ConstMoveXL ||
X		    event.xbutton.x_root > ConstMoveXR)
X		    ConstMoveDir = MOVE_HORIZ;
X
X		if (event.xbutton.y_root < ConstMoveYT ||
X		    event.xbutton.y_root > ConstMoveYB)
X		    ConstMoveDir = MOVE_VERT;
X
X		XQueryPointer(dpy, DragWindow, &JunkRoot, &JunkChild,
X		    &JunkX, &JunkY, &DragX, &DragY, &JunkMask);
X		break;
X
X	    case MOVE_VERT:
X		ConstMoveY = event.xbutton.y_root - DragY - BorderWidth;
X		break;
X
X	    case MOVE_HORIZ:
X		ConstMoveX= event.xbutton.x_root - DragX - BorderWidth;
X		break;
X	}
X
X	if (ConstMoveDir != MOVE_NONE)
X	{
X	    MoveOutline(event.xbutton.root,
X		ConstMoveX, ConstMoveY,
X		DragWidth + 2 * BorderWidth,
X		DragHeight + 2 * BorderWidth);
X	}
X	return;
X    }
X
X    if (DragWindow != NULL)
X    {
X	MoveOutline(event.xbutton.root,
X	    event.xbutton.x_root - DragX - BorderWidth,
X	    event.xbutton.y_root - DragY - BorderWidth,
X	    DragWidth + 2 * BorderWidth,
X	    DragHeight + 2 * BorderWidth);
X
X	return;
X    }
X
X    if (ResizeWindow != NULL)
X    {
X	XFindContext(dpy, ResizeWindow, TwmContext, &tmp_win);
X	DoResize(event, tmp_win);
X    }
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleButtonRelease - ButtonRelease event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleButtonRelease()
X{
X#ifdef DEBUG
X    fprintf(stderr, "ButtonRelease\n");
X#endif
X    XUngrabPointer(dpy, CurrentTime);
X    XUngrabServer(dpy);
X    EventHandler[EnterNotify] = HandleEnterNotify;
X    EventHandler[LeaveNotify] = HandleLeaveNotify;
X
X    if (DragWindow != NULL)
X    {
X	XEvent client_event;
X	XWindowChanges xwc;
X	unsigned int   xwcm;
X
X	MoveOutline(event.xbutton.root, 0, 0, 0, 0);
X
X	xwcm = 0;
X	xwcm |= CWX;
X	xwcm |= CWY;
X
X	xwc.x = event.xbutton.x_root - DragX - BorderWidth;
X	xwc.y = event.xbutton.y_root - DragY - BorderWidth;
X
X	if (ConstMove)
X	{
X	    if (ConstMoveDir == MOVE_HORIZ)
X		xwc.y = ConstMoveY;
X
X	    if (ConstMoveDir == MOVE_VERT)
X		xwc.x = ConstMoveX;
X
X	    if (ConstMoveDir == MOVE_NONE)
X	    {
X		xwc.y = ConstMoveY;
X		xwc.x = ConstMoveX;
X	    }
X	}
X	
X	XFindContext(dpy, DragWindow, TwmContext, &tmp_win);
X	tmp_win->frame_x = xwc.x;
X	tmp_win->frame_y = xwc.y;
X
X	XConfigureWindow(dpy, DragWindow, xwcm, &xwc);
X	XRaiseWindow(dpy, DragWindow);
X	DragWindow = NULL;
X	ConstMove = FALSE;
X
X	enter_flag = TRUE;
X	client_event.type = ClientMessage;
X	XSendEvent(dpy, tmp_win->frame, False, 0, &client_event);
X
X	return;
X    }
X
X    if (ResizeWindow != NULL)
X    {
X	EndResize();
X	EventHandler[EnterNotify] = HandleEnterNotify;
X	EventHandler[LeaveNotify] = HandleLeaveNotify;
X    }
X
X    if (w == Root)
X    {
X	MenuRoot *tmp;
X
X	/*
X	if (ActiveItem != NULL)
X	{
X	    int i;
X
X	    for (i = 0; i < 4; i++)
X		XFillRectangle(dpy, ActiveItem->w,
X		    MenuXorGC,0,0,1000, 100);
X
X	    XFlush();
X	}
X	*/
X	for (tmp = ActiveMenu; tmp != NULL; tmp = tmp->prev)
X	{
X	    XUnmapWindow(dpy, tmp->shadow);
X	    XUnmapWindow(dpy, tmp->w);
X	}
X	XFlush(dpy);
X	ActiveMenu = NULL;
X
X	if (ActiveItem != NULL)
X	{
X	    ActiveItem->state = 0;
X	    ExecuteFunction(ActiveItem);
X	    ActiveItem = NULL;
X	    XUngrabPointer(dpy, CurrentTime);
X	}
X
X	return;
X    }
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleButtonPress - ButtonPress event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleButtonPress()
X{
X
X#ifdef DEBUG
X    fprintf(stderr, "ButtonPress\n");
X#endif
X
X    XUnmapWindow(dpy, VersionWindow);
X
X    if (w == Root)
X    {
X	if (Menu[event.xbutton.button] != NULL)
X	{
X	    XGrabPointer(dpy, Root, True,
X		ButtonReleaseMask | ButtonMotionMask,
X		GrabModeAsync, GrabModeSync,
X		Root, RightArrowCursor, CurrentTime);
X
X	    PopUpMenu(Menu[event.xbutton.button], 
X		event.xbutton.x, event.xbutton.y);
X	}
X	else if (Item[event.xbutton.button] != NULL)
X	{
X	    ExecuteFunction(Item[event.xbutton.button]);
X	}
X
X	return;
X    }
X
X    if (tmp_win == NULL)
X	return;
X
X    if (w == tmp_win->frame || w == tmp_win->title_w || w == tmp_win->icon_w)
X    {
X	if (w != tmp_win->icon_w)
X	    w = tmp_win->frame;
X
X	HandleTitleButton(w, tmp_win, event);
X
X	return;
X    }
X
X    if (w == tmp_win->iconify_w)
X    {
X	if (!tmp_win->iconified)
X	{
X	    XWindowChanges xwc;
X	    unsigned int   xwcm;
X
X	    xwcm = 0;
X	    xwcm |= CWX;
X	    xwcm |= CWY;
X
X	    if (tmp_win->wmhints && tmp_win->wmhints->flags & IconPositionHint)
X	    {
X		xwc.x = tmp_win->wmhints->icon_x;
X		xwc.y = tmp_win->wmhints->icon_y;
X	    }
X	    else
X	    {
X		xwc.x = event.xbutton.x_root - 5;
X		xwc.y = event.xbutton.y_root - 5;
X	    }
X
X	    XConfigureWindow(dpy, tmp_win->icon_w, xwcm, &xwc);
X	    tmp_win->iconified = TRUE;
X	}
X
X	XUnmapWindow(dpy, tmp_win->frame);
X	XMapSubwindows(dpy, tmp_win->icon_w);
X	XMapRaised(dpy, tmp_win->icon_w);
X	if (tmp_win == Focus)
X	{
X	    XSetInputFocus(dpy, Root, RevertToPointerRoot,
X		CurrentTime);
X	    Focus = NULL;
X	    FocusRoot = TRUE;
X	}
X	return;
X    }
X
X    if (w == tmp_win->resize_w)
X    {
X	EventHandler[EnterNotify] = HandleUnknown;
X	EventHandler[LeaveNotify] = HandleUnknown;
X	StartResize(event, tmp_win);
X    }
X
X    if (w == tmp_win->focus_w)
X    {
X	if (Focus != NULL && Focus != tmp_win)
X	{
X	    XUnmapWindow(dpy, Focus->hilite_w);
X	}
X	XMapWindow(dpy, tmp_win->hilite_w);
X	XSetInputFocus(dpy, tmp_win->w, RevertToPointerRoot,
X		CurrentTime);
X	FocusRoot = FALSE;
X	Focus = tmp_win;
X
X	return;
X    }
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleEnterNotify - EnterNotify event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleEnterNotify()
X{
X    MenuItem *tmp;
X
X#ifdef DEBUG
X    fprintf(stderr, "EnterNotify\n");
X#endif
X
X    if (ActiveMenu == NULL && tmp_win != NULL)
X    {
X	if (FocusRoot && tmp_win->mapped)
X	{
X	    if (Focus != NULL && Focus != tmp_win)
X		XUnmapWindow(dpy, Focus->hilite_w);
X
X	    XMapWindow(dpy, tmp_win->hilite_w);
X	    XSetInputFocus(dpy, tmp_win->w, RevertToPointerRoot,
X		    CurrentTime);
X	    Focus = tmp_win;
X	}
X	if (enter_flag == FALSE && tmp_win->auto_raise)
X	{
X	    XEvent client_event;
X
X	    XRaiseWindow(dpy, tmp_win->frame);
X	    enter_flag = TRUE;
X	    client_event.type = ClientMessage;
X	    XSendEvent(dpy, tmp_win->frame, False, 0, &client_event);
X	}
X	return;
X    }
X
X
X    if (XFindContext(dpy, w, MenuContext, &tmp) != 0)
X	return;
X
X    if (w == tmp->w && tmp->root == ActiveMenu)
X    {
X	if (ActiveItem != NULL && ActiveItem->state != 0)
X	{
X#ifdef DEBUG
X	    fprintf(stderr, "turning off \"%s\"\n", ActiveItem->item);
X#endif
X	    XFillRectangle(dpy, ActiveItem->w,MenuXorGC,0,0,1000, 100);
X	    if (tmp->pull != NULL)
X		XFillRectangle(dpy, ActiveItem->pull, MenuXorGC,0,0,1000, 100);
X	    ActiveItem->state = 0;
X	}
X
X	if (tmp->state == 0)
X	{
X#ifdef DEBUG
X	    fprintf(stderr, "turning on \"%s\"\n", tmp->item);
X#endif
X	    XFillRectangle(dpy, tmp->w,MenuXorGC,0,0,1000, 100);
X	    if (tmp->pull)
X		XFillRectangle(dpy, tmp->pull, MenuXorGC,0,0,1000, 100);
X	    tmp->state = 1;
X	}
X	ActiveItem = tmp;
X
X	return;
X    }
X
X    if (w == tmp->pull && tmp->root == ActiveMenu)
X    {
X	XGrabServer(dpy);
X	PopUpMenu(tmp->sub, event.xcrossing.x_root,
X	    event.xcrossing.y_root);
X	XUngrabServer(dpy);
X
X	return;
X    }
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleLeaveNotify - LeaveNotify event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleLeaveNotify()
X{
X    MenuItem *tmp;
X
X#ifdef DEBUG
X    fprintf(stderr, "LeaveNotify\n");
X#endif
X    if (tmp_win != NULL)
X    {
X	XUnmapWindow(dpy, VersionWindow);
X	if (FocusRoot)
X	{
X	    if (event.xcrossing.detail != NotifyInferior)
X	    {
X		XUnmapWindow(dpy, tmp_win->hilite_w);
X		XSetInputFocus(dpy, Root, RevertToPointerRoot,
X			CurrentTime);
X		Focus = NULL;
X	    }
X	}
X	return;
X    }
X
X    if (XFindContext(dpy, w, MenuContext, &tmp) != 0)
X	return;
X
X    if (w == tmp->root->w)
X    {
X	int rootx, rooty, x, y;
X	int wx, wy, ww, wh;
X
X	/* see if the mouse really left the window
X	 * or just crossed into a sub-window
X	 */
X
X	XQueryPointer(dpy, w, &JunkRoot,
X	    &JunkChild, &rootx, &rooty, &x, &y, &JunkMask);
X
X	XGetGeometry(dpy, w, &JunkRoot, &wx, &wy,
X	    &ww, &wh, &JunkBW,
X	    &JunkDepth);
X	
X	if (rootx < wx ||
X	    rootx > (wx + ww) ||
X	    rooty < wy ||
X	    rooty > (wy + wh))
X	{
X	    ActiveItem = NULL;
X	    if (tmp->root->prev != NULL)
X	    {
X		if (ActiveMenu == tmp->root)
X		{
X		    XUnmapWindow(dpy, ActiveMenu->shadow);
X		    XUnmapWindow(dpy, ActiveMenu->w);
X		    ActiveMenu = tmp->root->prev;
X		}
X	    }
X	}
X	return;
X    }
X
X    if (w == tmp->w);
X    {
X	if (tmp == ActiveItem)
X	    ActiveItem = NULL;
X
X	if (tmp->state != 0)
X	{
X#ifdef DEBUG
X	    fprintf(stderr, "turning off \"%s\"\n", tmp->item);
X#endif
X	    XFillRectangle(dpy, tmp->w,MenuXorGC,0,0,1000, 100);
X	    if (tmp->pull != NULL)
X		XFillRectangle(dpy, tmp->pull, MenuXorGC,0,0,1000, 100);
X	    tmp->state = 0;
X	}
X
X	return;
X    }
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleConfigureNotify - ConfigureNotify event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleConfigureNotify()
X{
X#ifdef DEBUG
X    fprintf(stderr, "ConfigureNotify\n");
X#endif
X    if (tmp_win == NULL)
X	return;
X
X    if (event.xconfigure.override_redirect)
X	return;
X
X    SetupWindow(tmp_win,
X	tmp_win->frame_x + event.xconfigure.x,
X	tmp_win->frame_y + event.xconfigure.y - TITLE_BAR_HEIGHT - BorderWidth,
X	event.xconfigure.width,
X	event.xconfigure.height + TITLE_BAR_HEIGHT + BorderWidth);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleUnknown - unknown event handler
X *
X ***********************************************************************
X */
X
Xvoid
XHandleUnknown()
X{
X#ifdef DEBUG
X    fprintf(stderr, "type = %d\n", event.type);
X#endif
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	HandleTitleButton - handle a button press event in the title bar
X *
X *  Inputs:
X *	w	- the window effected by the button press
X *	tmp_win	- the TwmWindow structure
X *	event	- the X event structure for the button press
X *
X ***********************************************************************
X */
X
XHandleTitleButton(w, tmp_win, event)
XWindow w;
XTwmWindow *tmp_win ;
XXEvent event;
X{
X    static Time last_time = 0;
X
X    if (event.xbutton.button > MAX_BUTTONS)
X	return;
X
X    switch (TitleButton[event.xbutton.button])
X    {
X    case T_NOP:
X	break;
X	 
X    case T_RAISE:
X	if (w == tmp_win->icon_w)
X	{
X	    XUnmapWindow(dpy, tmp_win->icon_w);
X	    XMapWindow(dpy, tmp_win->w);
X	    XMapRaised(dpy, tmp_win->frame);
X	    if (WarpCursor)
X	    {
X		XWarpPointer(dpy, None, tmp_win->frame,
X		    0, 0, 0, 0, 30, 8);
X	    }
X	    tmp_win->icon = FALSE;
X	}
X	else
X	    XRaiseWindow(dpy, tmp_win->frame);
X	break;
X
X    case T_LOWER:
X	XLowerWindow(dpy, w);
X	break;
X
X    case T_MOVE:
X	EventHandler[EnterNotify] = HandleUnknown;
X	EventHandler[LeaveNotify] = HandleUnknown;
X	XGrabServer(dpy);
X	XGrabPointer(dpy, event.xbutton.root, True,
X	    ButtonReleaseMask | ButtonMotionMask,
X	    GrabModeAsync, GrabModeSync,
X	    Root, MoveCursor, CurrentTime);
X
X	DragWindow = w;
X
X	DragX = event.xbutton.x;
X	DragY = event.xbutton.y;
X
X	XGetGeometry(dpy, w, &JunkRoot, &JunkX, &JunkY,
X	    &DragWidth, &DragHeight, &JunkBW,
X	    &JunkDepth);
X
X	MoveOutline((Window)event.xbutton.root,
X	    event.xbutton.x_root-DragX-BorderWidth,
X	    event.xbutton.y_root-DragY-BorderWidth,
X	    DragWidth + 2 * BorderWidth,
X	    DragHeight + 2 * BorderWidth);
X
X	if ((event.xbutton.time - last_time) < 400)
X	{
X	    int width, height;
X
X	    ConstMove = TRUE;
X	    ConstMoveDir = MOVE_NONE;
X	    ConstMoveX = event.xbutton.x_root - DragX - BorderWidth;
X	    ConstMoveY = event.xbutton.y_root - DragY - BorderWidth;
X	    width = DragWidth + 2 * BorderWidth;
X	    height = DragHeight + 2 * BorderWidth;
X	    ConstMoveXL = ConstMoveX + width/3;
X	    ConstMoveXR = ConstMoveX + 2*(width/3);
X	    ConstMoveYT = ConstMoveY + height/3;
X	    ConstMoveYB = ConstMoveY + 2*(height/3);
X
X	    XWarpPointer(dpy, None, w,
X		0, 0, 0, 0, DragWidth/2, DragHeight/2);
X
X	    XQueryPointer(dpy, DragWindow, &JunkRoot, &JunkChild,
X		&JunkX, &JunkY, &DragX, &DragY, &JunkMask);
X	}
X	last_time = event.xbutton.time;
X	break;
X
X    }
X}
SHAR_EOF
if test 23151 -ne "`wc -c < events.c`"
then
    echo shar: error transmitting "events.c" '(should have been 23151 characters)'
fi
fi
if test -f 'resize.c'
then
    echo shar: will not over-write existing file "resize.c"
else
echo extracting "resize.c"
sed 's/^X//' >resize.c <<'SHAR_EOF'
X/*****************************************************************************/
X/**       Copyright 1988 by Evans & Sutherland Computer Corporation,        **/
X/**                          Salt Lake City, Utah                           **/
X/**                                                                         **/
X/**                           All Rights Reserved                           **/
X/**                                                                         **/
X/**    Permission to use, copy, modify, and distribute this software and    **/
X/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
X/**    granted, provided that the above copyright notice appear  in  all    **/
X/**    copies and that both  that  copyright  notice  and  this  permis-    **/
X/**    sion  notice appear in supporting  documentation,  and  that  the    **/
X/**    name  of Evans & Sutherland  not be used in advertising or publi-    **/
X/**    city pertaining to distribution  of the software without  specif-    **/
X/**    ic, written prior permission.                                        **/
X/**                                                                         **/
X/**    EVANS  & SUTHERLAND  DISCLAIMS  ALL  WARRANTIES  WITH  REGARD  TO    **/
X/**    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILI-    **/
X/**    TY AND FITNESS, IN NO EVENT SHALL EVANS &  SUTHERLAND  BE  LIABLE    **/
X/**    FOR  ANY  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY  DAM-    **/
X/**    AGES  WHATSOEVER RESULTING FROM  LOSS OF USE,  DATA  OR  PROFITS,    **/
X/**    WHETHER   IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS    **/
X/**    ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE  OR PER-    **/
X/**    FORMANCE OF THIS SOFTWARE.                                           **/
X/*****************************************************************************/
X
X/***********************************************************************
X *
X * $Header: resize.c,v 1.6 88/04/15 07:09:35 tlastran Exp $
X *
X * window resizing borrowed from the "wm" window manager
X *
X * 11-Dec-87 Thomas E. LaStrange		File created
X *
X ***********************************************************************/
X
X#ifndef lint
Xstatic char RCSinfo[]=
X"$Header: resize.c,v 1.6 88/04/15 07:09:35 tlastran Exp $";
X#endif
X
X#include <stdio.h>
X#include "twm.h"
X#include "util.h"
X#include "resize.h"
X#include "resize.bm"
X#include "focus.bm"
X
X#define MINHEIGHT 32
X#define MINWIDTH 60
X
Xstatic int dragx;	/* all these variables are used */
Xstatic int dragy;	/* in resize operations */
Xstatic int dragWidth;
Xstatic int dragHeight;
X
Xstatic int origx;
Xstatic int origy;
Xstatic int origWidth;
Xstatic int origHeight;
X
Xstatic int clampTop;
Xstatic int clampBottom;
Xstatic int clampLeft;
Xstatic int clampRight;
X
X/***********************************************************************
X *
X *  Procedure:
X *	StartResize - begin a window resize operation
X *
X *  Inputs:
X *	ev	- the event structure (button press)
X *	tmp_win	- the TwmWindow pointer
X *
X ***********************************************************************
X */
X
Xvoid
XStartResize(ev, tmp_win)
XXEvent ev;
XTwmWindow *tmp_win;
X{
X    Window      junkRoot;
X    int         junkbw, junkDepth;
X
X    XMapRaised(dpy, SizeWindow);
X    ResizeWindow = tmp_win->frame;
X    XGrabServer(dpy);
X    XGrabPointer(dpy, ev.xbutton.root, True,
X	ButtonReleaseMask | PointerMotionMask,
X	GrabModeAsync, GrabModeSync,
X	Root, MoveCursor, CurrentTime);
X
X    XGetGeometry(dpy, (Drawable) tmp_win->frame, &junkRoot,
X	&dragx, &dragy, &dragWidth, &dragHeight, &junkbw,
X		 &junkDepth);
X    dragx += BorderWidth;
X    dragy += BorderWidth;
X    origx = dragx;
X    origy = dragy;
X    origWidth = dragWidth;
X    origHeight = dragHeight;
X    clampTop = clampBottom = clampLeft = clampRight = 0;
X
X    DisplaySize(tmp_win, origWidth, origHeight);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	DoResize - move the rubberband around.  This is called for
X *		   each motion event when we are resizing 
X *
X *  Inputs:
X *	ev	- the event structure for the motion event
X *	tmp_win	- the current twm window
X *
X ***********************************************************************
X */
X
Xvoid
XDoResize(ev, tmp_win)
XXEvent ev;
XTwmWindow *tmp_win;
X{
X    int action;
X
X    action = 0;
X
X    if (clampTop) {
X	int         delta = ev.xmotion.y_root - dragy;
X	if (dragHeight - delta < MINHEIGHT) {
X	    delta = dragHeight - MINHEIGHT;
X	    clampTop = 0;
X	}
X	dragy += delta;
X	dragHeight -= delta;
X	action = 1;
X    }
X    else if (ev.xmotion.y_root <= dragy/* ||
X	     ev.xmotion.y_root == findRootInfo(root)->rooty*/) {
X	dragy = ev.xmotion.y_root;
X	dragHeight = origy + origHeight -
X	    ev.xmotion.y_root;
X	clampBottom = 0;
X	clampTop = 1;
X	action = 1;
X    }
X    if (clampLeft) {
X	int         delta = ev.xmotion.x_root - dragx;
X	if (dragWidth - delta < MINWIDTH) {
X	    delta = dragWidth - MINWIDTH;
X	    clampLeft = 0;
X	}
X	dragx += delta;
X	dragWidth -= delta;
X	action = 1;
X    }
X    else if (ev.xmotion.x_root <= dragx/* ||
X	     ev.xmotion.x_root == findRootInfo(root)->rootx*/) {
X	dragx = ev.xmotion.x_root;
X	dragWidth = origx + origWidth -
X	    ev.xmotion.x_root;
X	clampRight = 0;
X	clampLeft = 1;
X	action = 1;
X    }
X    if (clampBottom) {
X	int         delta = ev.xmotion.y_root - dragy - dragHeight;
X	if (dragHeight + delta < MINHEIGHT) {
X	    delta = MINHEIGHT - dragHeight;
X	    clampBottom = 0;
X	}
X	dragHeight += delta;
X	action = 1;
X    }
X    else if (ev.xmotion.y_root >= dragy + dragHeight - 1/* ||
X	   ev.xmotion.y_root == findRootInfo(root)->rooty
X	   + findRootInfo(root)->rootheight - 1*/) {
X	dragy = origy;
X	dragHeight = 1 + ev.xmotion.y_root - dragy;
X	clampTop = 0;
X	clampBottom = 1;
X	action = 1;
X    }
X    if (clampRight) {
X	int         delta = ev.xmotion.x_root - dragx - dragWidth;
X	if (dragWidth + delta < MINWIDTH) {
X	    delta = MINWIDTH - dragWidth;
X	    clampRight = 0;
X	}
X	dragWidth += delta;
X	action = 1;
X    }
X    else if (ev.xmotion.x_root >= dragx + dragWidth - 1/* ||
X	     ev.xmotion.x_root == findRootInfo(root)->rootx +
X	     findRootInfo(root)->rootwidth - 1*/) {
X	dragx = origx;
X	dragWidth = 1 + ev.xmotion.x_root - origx;
X	clampLeft = 0;
X	clampRight = 1;
X	action = 1;
X    }
X    if (action) {
X	MoveOutline(Root,
X		    dragx - BorderWidth,
X		    dragy - BorderWidth,
X		    dragWidth + 2 * BorderWidth,
X		    dragHeight + 2 * BorderWidth);
X    }
X
X    DisplaySize(tmp_win, dragWidth, dragHeight);
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	DisplaySize - display the size in the dimensions window
X *
X *  Inputs:
X *	tmp_win - the current twm window 
X *	width	- the width of the rubber band
X *	height	- the height of the rubber band
X *
X ***********************************************************************
X */
X
Xvoid
XDisplaySize(tmp_win, width, height)
XTwmWindow *tmp_win;
Xint width;
Xint height;
X{
X    char str[100];
X    int dwidth;
X    int dheight;
X
X    dwidth = width;
X    dheight = height - tmp_win->title_height;
X
X    if (tmp_win->hints.flags&PMinSize && tmp_win->hints.flags & PResizeInc)
X    {
X	dwidth -= tmp_win->hints.min_width;
X	dheight -= tmp_win->hints.min_height;
X    }
X
X    if (tmp_win->hints.flags & PResizeInc)
X    {
X	dwidth /= tmp_win->hints.width_inc;
X	dheight /= tmp_win->hints.height_inc;
X    }
X
X    sprintf(str, "%d x %d", dwidth, dheight);
X
X    width = XTextWidth(SizeFont, str, strlen(str)) + 20,
X    strcat(str, "        ");
X    XResizeWindow(dpy, SizeWindow, width, SizeFontHeight + 4);
X    XRaiseWindow(dpy, SizeWindow);
X    XDrawImageString(dpy, SizeWindow, SizeNormalGC,
X	10, 2 + SizeFont->ascent, str, strlen(str));
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	EndResize - finish the resize operation
X *
X ***********************************************************************
X */
X
Xvoid
XEndResize()
X{
X    TwmWindow *tmp_win;
X
X    XUnmapWindow(dpy, SizeWindow);
X    MoveOutline(Root, 0, 0, 0, 0);
X
X    XFindContext(dpy, ResizeWindow, TwmContext, &tmp_win);
X
X    dragHeight = dragHeight - tmp_win->title_height;
X
X    if (tmp_win->hints.flags&PMinSize && tmp_win->hints.flags & PResizeInc)
X    {
X	dragWidth -= tmp_win->hints.min_width;
X	dragHeight -= tmp_win->hints.min_height;
X    }
X
X    if (tmp_win->hints.flags & PResizeInc)
X    {
X	dragWidth /= tmp_win->hints.width_inc;
X	dragHeight /= tmp_win->hints.height_inc;
X
X	dragWidth *= tmp_win->hints.width_inc;
X	dragHeight *= tmp_win->hints.height_inc;
X    }
X
X    if (tmp_win->hints.flags&PMinSize && tmp_win->hints.flags & PResizeInc)
X    {
X	dragWidth += tmp_win->hints.min_width;
X	dragHeight += tmp_win->hints.min_height;
X    }
X
X    dragHeight = dragHeight + tmp_win->title_height;
X
X    SetupWindow(tmp_win,
X	dragx - BorderWidth,
X	dragy - BorderWidth,
X	dragWidth, dragHeight);
X
X    XRaiseWindow(dpy, ResizeWindow);
X    ResizeWindow = NULL;
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	SetupWindow - set window sizes, this was called from either
X *		AddWindow, EndResize, or HandleConfigureNotify.
X *
X *  Inputs:
X *	tmp_win	- the TwmWindow pointer
X *	x	- the x coordinate of the frame window
X *	y	- the y coordinate of the frame window
X *	w	- the width of the frame window
X *	h	- the height of the frame window
X *
X ***********************************************************************
X */
X
Xvoid
XSetupWindow(tmp_win, x, y, w, h)
XTwmWindow *tmp_win;
Xint x, y, w, h;
X{
X    XWindowChanges xwc;
X    unsigned int   xwcm;
X    int width;
X
X    tmp_win->frame_x = x;
X    tmp_win->frame_y = y;
X
X    xwcm = CWX | CWY | CWWidth | CWHeight;
X
X    xwc.x = x;
X    xwc.y = y;
X    xwc.width = w;
X    xwc.height = h;
X    XConfigureWindow(dpy, tmp_win->frame, xwcm, &xwc);
X
X    xwcm = CWWidth;
X    XConfigureWindow(dpy, tmp_win->title_w, xwcm, &xwc);
X
X    xwcm |= CWX | CWY | CWHeight;
X    xwc.x = 0;
X    xwc.y = tmp_win->title_height;
X    xwc.height = h - tmp_win->title_height;
X    XConfigureWindow(dpy, tmp_win->w, xwcm, &xwc);
X
X    xwcm = CWX;
X    xwc.x = w - resize_width - 1;
X    XConfigureWindow(dpy, tmp_win->resize_w, xwcm, &xwc);
X
X    xwc.x = w - resize_width - focus_width - 3;
X    XConfigureWindow(dpy, tmp_win->focus_w, xwcm, &xwc);
X
X    width = w - TitleBarX - focus_width - resize_width - 5 -
X	tmp_win->name_width - 10;
X
X    if (width <= 0)
X    {
X	xwc.x = 3000;
X	xwc.width = 1;
X    }
X    else
X    {
X	xwc.x = TitleBarX + tmp_win->name_width + 6;
X	xwc.width = width;
X    }
X
X    xwcm = CWX | CWWidth;
X    XConfigureWindow(dpy, tmp_win->hilite_w, xwcm, &xwc);
X}
SHAR_EOF
if test 10581 -ne "`wc -c < resize.c`"
then
    echo shar: error transmitting "resize.c" '(should have been 10581 characters)'
fi
fi
if test -f 'util.c'
then
    echo shar: will not over-write existing file "util.c"
else
echo extracting "util.c"
sed 's/^X//' >util.c <<'SHAR_EOF'
X/*****************************************************************************/
X/**       Copyright 1988 by Evans & Sutherland Computer Corporation,        **/
X/**                          Salt Lake City, Utah                           **/
X/**                                                                         **/
X/**                           All Rights Reserved                           **/
X/**                                                                         **/
X/**    Permission to use, copy, modify, and distribute this software and    **/
X/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
X/**    granted, provided that the above copyright notice appear  in  all    **/
X/**    copies and that both  that  copyright  notice  and  this  permis-    **/
X/**    sion  notice appear in supporting  documentation,  and  that  the    **/
X/**    name  of Evans & Sutherland  not be used in advertising or publi-    **/
X/**    city pertaining to distribution  of the software without  specif-    **/
X/**    ic, written prior permission.                                        **/
X/**                                                                         **/
X/**    EVANS  & SUTHERLAND  DISCLAIMS  ALL  WARRANTIES  WITH  REGARD  TO    **/
X/**    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILI-    **/
X/**    TY AND FITNESS, IN NO EVENT SHALL EVANS &  SUTHERLAND  BE  LIABLE    **/
X/**    FOR  ANY  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY  DAM-    **/
X/**    AGES  WHATSOEVER RESULTING FROM  LOSS OF USE,  DATA  OR  PROFITS,    **/
X/**    WHETHER   IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS    **/
X/**    ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE  OR PER-    **/
X/**    FORMANCE OF THIS SOFTWARE.                                           **/
X/*****************************************************************************/
X
X/***********************************************************************
X *
X * $Header: util.c,v 1.10 88/04/15 07:09:43 tlastran Exp $
X *
X * utility routines for twm
X *
X * 28-Oct-87 Thomas E. LaStrange	File created
X *
X ***********************************************************************/
X
X#ifndef lint
Xstatic char RCSinfo[]=
X"$Header: util.c,v 1.10 88/04/15 07:09:43 tlastran Exp $";
X#endif
X
X#include <stdio.h>
X#include "twm.h"
X#include "gram.h"
X
X/***********************************************************************
X *
X *  Procedure:
X *	InitButtons - initialize the title bar buttons
X *
X ***********************************************************************
X */
X
Xvoid
XInitButtons()
X{
X    int i;
X
X    for (i = 0; i < (MAX_BUTTONS + 1); i++)
X	TitleButton[i] = T_NOP;
X
X    TitleButton[1] = T_RAISE;
X    TitleButton[2] = T_MOVE;
X    TitleButton[3] = T_LOWER;
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	MoveOutline - move a window outline
X *
X *  Inputs:
X *	root	    - the window we are outlining
X *	x	    - upper left x coordinate
X *	y	    - upper left y coordinate
X *	width	    - the width of the rectangle
X *	height	    - the height of the rectangle
X *
X ***********************************************************************
X */
X
Xvoid
XMoveOutline(root, x, y, width, height)
X    Window root;
X    int x, y, width, height;
X{
X    static int	lastx = 0;
X    static int	lasty = 0;
X    static int	lastWidth = 0;
X    static int	lastHeight = 0;
X    int		xl, xr, yt, yb;
X    int		xthird, ythird;
X    XSegment	outline[16];
X    XSegment	*r = outline;
X
X    if (x == lastx && y == lasty && width == lastWidth && height == lastHeight)
X	return;
X    
X    xthird = lastWidth/3;
X    ythird = lastHeight/3;
X    xl = lastx;
X    xr = lastx + lastWidth - 1;
X    yt = lasty;
X    yb = lasty + lastHeight - 1;
X
X    if (lastWidth || lastHeight)
X    {
X	r->x1 = xl;
X	r->y1 = yt;
X	r->x2 = xr;
X	r++->y2 = yt;
X
X	r->x1 = xl;
X	r->y1 = yb;
X	r->x2 = xr;
X	r++->y2 = yb;
X
X	r->x1 = xl;
X	r->y1 = yt;
X	r->x2 = xl;
X	r++->y2 = yb;
X
X	r->x1 = xr;
X	r->y1 = yt;
X	r->x2 = xr;
X	r++->y2 = yb;
X
X	r->x1 = xl + xthird;
X	r->y1 = yt;
X	r->x2 = r->x1;
X	r++->y2 = yb;
X
X	r->x1 = xl + (2 * xthird);
X	r->y1 = yt;
X	r->x2 = r->x1;
X	r++->y2 = yb;
X
X	r->x1 = xl;
X	r->y1 = yt + ythird;
X	r->x2 = xr;
X	r->y2 = r->y1;
X	r++;
X
X	r->x1 = xl;
X	r->y1 = yt + (2 * ythird);
X	r->x2 = xr;
X	r->y2 = r->y1;
X	r++;
X    }
X
X    lastx = x;
X    lasty = y;
X    lastWidth = width;
X    lastHeight = height;
X    xthird = lastWidth/3;
X    ythird = lastHeight/3;
X    xl = lastx;
X    xr = lastx + lastWidth - 1;
X    yt = lasty;
X    yb = lasty + lastHeight - 1;
X
X    if (lastWidth || lastHeight)
X    {
X	r->x1 = xl;
X	r->y1 = yt;
X	r->x2 = xr;
X	r++->y2 = yt;
X
X	r->x1 = xl;
X	r->y1 = yb;
X	r->x2 = xr;
X	r++->y2 = yb;
X
X	r->x1 = xl;
X	r->y1 = yt;
X	r->x2 = xl;
X	r++->y2 = yb;
X
X	r->x1 = xr;
X	r->y1 = yt;
X	r->x2 = xr;
X	r++->y2 = yb;
X
X	r->x1 = xl + xthird;
X	r->y1 = yt;
X	r->x2 = r->x1;
X	r++->y2 = yb;
X
X	r->x1 = xl + (2 * xthird);
X	r->y1 = yt;
X	r->x2 = r->x1;
X	r++->y2 = yb;
X
X	r->x1 = xl;
X	r->y1 = yt + ythird;
X	r->x2 = xr;
X	r->y2 = r->y1;
X	r++;
X
X	r->x1 = xl;
X	r->y1 = yt + (2 * ythird);
X	r->x2 = xr;
X	r->y2 = r->y1;
X	r++;
X    }
X    if (r != outline)
X    {
X	XDrawSegments(dpy, root, DrawGC, outline, r - outline);
X    }
X}
X
X/***********************************************************************
X *
X *  Procedure:
X *	MakePixmap - make a pixmap
X *
X *  Returned Value:
X *	pid	- the pixmap id
X *
X *  Inputs:
X *	w	- the window to associate the pixmap with
X *	gc	- the graphics context to use
X *	data	- pointer to the pixmap data
X *	width	- the width of the pixmap
X *	height	- the height of the pixmap
X *
X ***********************************************************************
X */
X
XPixmap
XMakePixmap(w, gc, data, width, height)
X    Drawable w;
X    GC gc;
X    short *data;
X    int width, height;
X{
X    XImage ximage;
X    Pixmap pid;
X
X    pid = XCreatePixmap(dpy, w, width, height, DefaultDepth(dpy, 0));
X
X    ximage.height = height;
X    ximage.width = width;
X    ximage.xoffset = 0;
X    ximage.format = XYBitmap;
X    ximage.data = (char *) data;
X    ximage.byte_order = LSBFirst;
X    ximage.bitmap_unit = 16;
X    ximage.bitmap_bit_order = LSBFirst;
X    ximage.bitmap_pad = 16;
X    ximage.bytes_per_line = (width + 15) / 16 * 2;
X    ximage.depth = 1;
X
X    XPutImage(dpy, pid, gc, &ximage, 0, 0, 0, 0, width, height);
X    return (pid);
X}
X
XGetUnknownIcon(name)
Xchar *name;
X{
X    int status, junk_hotx, junk_hoty;
X
X    status = XReadBitmapFile(dpy, Root, name, &UnknownWidth,
X	&UnknownHeight, &UnknownPm, &junk_hotx, &junk_hoty);
X
X    switch(status)
X    {
X	case BitmapSuccess:
X	    break;
X
X	case BitmapFileInvalid:
X	    fprintf(stderr, ".twmrc: invalid bitmap file\n");
X	    break;
X
X	case BitmapNoMemory:
X	    fprintf(stderr, ".twmrc: out of memory\n");
X	    break;
X
X	case BitmapOpenFailed:
X	    fprintf(stderr, ".twmrc: failed to open bitmap file\n");
X	    break;
X
X	default:
X	    fprintf(stderr,".twmrc: bitmap error = 0x%x\n", status);
X	    break;
X    }
X
X    if (status != BitmapSuccess)
X	UnknownPm = NULL;
X}
SHAR_EOF
if test 6974 -ne "`wc -c < util.c`"
then
    echo shar: error transmitting "util.c" '(should have been 6974 characters)'
fi
fi
if test -f 'version.c'
then
    echo shar: will not over-write existing file "version.c"
else
echo extracting "version.c"
sed 's/^X//' >version.c <<'SHAR_EOF'
X/*****************************************************************************/
X/**       Copyright 1988 by Evans & Sutherland Computer Corporation,        **/
X/**                          Salt Lake City, Utah                           **/
X/**                                                                         **/
X/**                           All Rights Reserved                           **/
X/**                                                                         **/
X/**    Permission to use, copy, modify, and distribute this software and    **/
X/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
X/**    granted, provided that the above copyright notice appear  in  all    **/
X/**    copies and that both  that  copyright  notice  and  this  permis-    **/
X/**    sion  notice appear in supporting  documentation,  and  that  the    **/
X/**    name  of Evans & Sutherland  not be used in advertising or publi-    **/
X/**    city pertaining to distribution  of the software without  specif-    **/
X/**    ic, written prior permission.                                        **/
X/**                                                                         **/
X/**    EVANS  & SUTHERLAND  DISCLAIMS  ALL  WARRANTIES  WITH  REGARD  TO    **/
X/**    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILI-    **/
X/**    TY AND FITNESS, IN NO EVENT SHALL EVANS &  SUTHERLAND  BE  LIABLE    **/
X/**    FOR  ANY  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY  DAM-    **/
X/**    AGES  WHATSOEVER RESULTING FROM  LOSS OF USE,  DATA  OR  PROFITS,    **/
X/**    WHETHER   IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS    **/
X/**    ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE  OR PER-    **/
X/**    FORMANCE OF THIS SOFTWARE.                                           **/
X/*****************************************************************************/
X
X/***********************************************************************
X *
X * $Header: version.c,v 2.0 88/04/15 07:00:36 tlastran Exp $
X *
X * twm version number
X *
X * 14-Dec-87 Thomas E. LaStrange		File created
X *
X ***********************************************************************/
X
Xstatic char RCSinfo[]=
X"$Header: version.c,v 2.0 88/04/15 07:00:36 tlastran Exp $";
X
Xchar *Revision = "$Revision: 2.0 $";
Xchar *Date = "$Date: 88/04/15 07:00:36 $";
SHAR_EOF
if test 2376 -ne "`wc -c < version.c`"
then
    echo shar: error transmitting "version.c" '(should have been 2376 characters)'
fi
fi
# end of shell archive
exit 0

