Subject:  v15i016:  Ditroff to PostScript translator, Part04/05
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Axel Mahler <axel%coma.UUCP%TUB.BITNET@mitvma.mit.edu>
Posting-number: Volume 15, Issue 16
Archive-name: tpscript/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 5)."
# Wrapped by rsalz@fig.bbn.com on Thu May 26 13:02:27 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f './READ_ME.TOO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./READ_ME.TOO'\"
else
echo shar: Extracting \"'./READ_ME.TOO'\" \(7623 characters\)
sed "s/^X//" >'./READ_ME.TOO' <<'END_OF_FILE'
GENERAL REMARKS			(by Axel Mahler, axel@coma.uucp)
X
This is 'tpscript', a free ditroff to PostScript filter package.
Tpscript was originally written by Stephen Frede who was with the
University of New South Wales, Australia, when he wrote the programs.
X
Stephen posted the whole package to net.sources about two years ago.
A while ago, I made a first attempt to repost the 'tpscript' package
X(and some local improvements), but failed due to mail problems.
However, I asked Stephen for permission, and this is what he answered:
X
X>Date: 26 Nov 86 12:24:44 +1100 (Wed)
X>From: tub!unido!gris.oz!stephenf (Stephen Frede)
X>To: coma!axel
X>Subject: Re: posting of tpscript modifications
X>
X>By all means, post the modified sources. Since I posted the original
X>version, I have moved from university to private industry, and the
X>company I work for (Softway) now sells a much enhanced version of the
X>original package, which incidentally allows external graphics objects
X>to be incorporated, as well as many more features not present in the
X>original version. Needless to say, the latest version is very much
X>protected and will not be distributed over the net. But the first
X>version was developed under an educational UNIX license, and under
X>the terms of that license, any software developed must be made freely
X>available (NOT public domain - no-one else can sell it). So go ahead
X>and post.
X>
X>Thanks for checking with me - I look forward to seeing your
X>modifications.
X>
X>By the way, if you are ever looking for UNIX software such as an
X>enhanced PostScript driver or whatever, consider the advantages of
X>buying from Australia - the exchange rate makes us quite cheap
X>compared to European and US vendors. In fact if you send me your
X>real mail address, I'll mail you some samples from the latest
X>version.
X>
X>						Stephen Frede
X>
X>				...!seismo!softway.oz!stephenf
X>
X>				Softway Pty Ltd
X>				P.O. Box 305
X>				Strawberry Hills NSW 2012
X>				AUSTRALIA
X>
X>				Phone +61 2 698 2322
X>
X>
X>
X
X(Sorry that it took so long to really repost the stuff.)
X
X
ABOUT THIS DISTRIBUTION
X
There's a main Makefile (I never used it), a shell script that facilitates
the invocation of ditroff (I never used it either) and three directories:
X
X  - opscript: contains a plain ascii to PostScript conversion program
X	(lpscript), and a bitmap to PostScript conversion program (ipscript).
X	'lpscript' is suitable for use as an output filter for the
X	lineprinter spooler system. 'ipscript' has seldomly been used
X	and (if I recall it right) caused some trouble. 
X
X  - tpscript: contains the ditroff to PostScript conversion program,
X	'tpscript'. We use 'tpscript' extensively, literally every day.
X	The operating environment we have is a MicroVAX II, running
X	4.3BSD with DWB 1.0 (or 1.2, I'm not certain) (di)troff, and 
X	an Apple LaserWriter Plus. However, there's nothing BSD specific
X	that would keep 'tpscript' from running on any sensible Unix
X	system. 
X	The subdirectory tpscript/devalw contains the font width tables
X	for the standard-fonts. 
X
X  - pscript: contains a collection of PostScript source files. These
X	files are either demos/samples or little utilities for producing
X	font descriptions or page setups.
X
X
IMPRESSION / REVIEW OF TPSCRIPT	
X
X'tpscript' is a great piece of software, and we are most gratefull to
Stephen Frede for writing and publishing it. We have used it on a daily
basis for about two years now, and are nothing but satisfied. (In fact,
some colleagues at our department, who distrusted 'netware', and kept
faith in 'supported products', had a lot more trouble with a major
product in the field on a SUN 3 network.) 
X
I have a vague memory of a problem with our troff, not being able
to hold enough font slots. This imposed a hard limit on the number
of different types accessible from within a troff source file. We
fixed that in our troff version (DWB 1.0 or so). I hope this gotcha
is fixed with more recent releases of ditroff.
X
X
XFEATURES
X
XFeatures of 'ipscript' and 'lpscript' are described in corresponding 
manual entries. 'tpscript' is used as a filter, i.e. it reads its input
from stdin and sends its output to stdout. The fonts used are the most
commonly available on PostScript devices: Times, Helvetica and Courier.
With some fiddling around it is possible to add support for other fonts
X(we did that for the Bookman family of fonts).
X
Besides some minor fixes to the program, the most notable enhancement
we added with respect to the original 'tpscript' version is the 
X'E' directive. This directive allows to specify a unix command (with 
arguments) to be invoked by 'tpscript', and insert the output of
that command into the output stream of 'tpscript'. The 'E' directive
facilitates inclusion, and appropriate scaling of externally created
PostScript images (e.g. MacDraw or GemDraw) in troff-formatted documents.
X_______________________________________________________________________________
X| The typical use of this feature is illustrated by a macro that we           |
X| wrote for this purpose (to be used with ms):				      |
X| 									      |
X| .nr Ph 1		\" Initialize picture-numbering-		      |
X| .nr Pn 0		\"			registers		      |
X| .if '\\*(Fg'' .ds Fg Abb.						      |
X| .de Pc	\" Insert Picture --- .Pc title height filename alignment     |
X| .KS				\" ms dependent keep			      |
X| .sp \\$2+2v			\" vertical space for picture (2 lines frame) |
X| .if !\\n(Ph=\\n(H1 \{ .nr Ph \\n(H1 \" if new chapter - save chapter number |
X| .nr Pn 0 \}			\"	- initialize Picture-number	      |
X| .nr Pn \\n(Pn+1			\" increase picture-number	      |
X| .ce 									      |
X| \f3\*(Fg \\n(Ph.\\n(Pn.\f1 \\$1	\" write picture Title		      |
X| .KE				\" release keep				      |
X| .if !'\\$3'' \{			\" if a filename is given	      |
X| .if \\n(.P \{			\" and if page should be printed	      |
X| .nr Vp \\n(nl-\\$2-2v		\" In,Vp upper left corner of picture	      |
X| .nr In \\n(.o-32+\\n(.i		\" 32 is a LW+-correction	      |
X| .nr He \\$2			\" Picture height given by caller	      |
X| .nr Wi \\n(.l-\\n(.i		\" Picture width (line len. - cur. indent)    |
X| \!E /usr/local/lib/gem2ps -V\\n(Vp -I\\n(In -H\\n(He -W\\n(Wi -A\\$4 \\$3   |
X| .rr Vp								      |
X| .rr In								      |
X| .rr He								      |
X| .rr Wi								      |
X| \}									      |
X| \}									      |
X| .br									      |
X| ..									      |
X|_____________________________________________________________________________|
X
X
INSTALLATION AND CONFIGURATION
X
There are two important entries in 'tpscript's Makefile: 'tpscript' and
X'tpsgem'. "make tpscript" will produce the default tpscript version, just
a ditroff to PostScript filter. It includes full support for PIC but no
explicit support for any kind of externally generated PostScript code.
If you "make tpsgem", you'll obtain a slightly different version of
X'tpscript', including a specially modified PostScript prolog supporting
PostScript images produced by 'gem2ps', our local GEM metafile to 
PostScript conversion utility (this is a variant of the program 'mfps'
which has been posted to comp.sys.atari.st). 'tpsgem' has no support
for PIC graphics ! 
X
X> In case you want to include images produced on a Mac, you'll have to
X> modify 'tpscript.c' (contains most of the prolog). Basically, you'll have
X> to swap 'Gem2PsDict' with an equivalent 'LaserPrep'.
X
This situation is kind of unsatisfying, but for me, there has always
been some other task that had to be accomplished. It would clearly be
desirable to have some sort of library for various PostScript prologs
that would be selected depending on an option. Maybe somebody finds
the time to add this to the program.
X
END_OF_FILE
if test 7623 -ne `wc -c <'./READ_ME.TOO'`; then
    echo shar: \"'./READ_ME.TOO'\" unpacked with wrong size!
fi
# end of './READ_ME.TOO'
fi
if test -f './opscript/ipscript.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./opscript/ipscript.c'\"
else
echo shar: Extracting \"'./opscript/ipscript.c'\" \(9061 characters\)
sed "s/^X//" >'./opscript/ipscript.c' <<'END_OF_FILE'
X/*
X *	ipscript.c - version 3.2
X *
X *	Convert bitmap image to postscript
X *
X *		- Stephen Frede, UNSW, Australia (stephenf@elecvax.oz)
X *			...!seismo!munnari!elecvax!stephenf
X *		- fixes MWR, UNSW (michaelr@elecvax.oz)
X */
X
X#ifndef	lint
static char id[] = "ipscript - version 3.2; UNSW, Australia";
X#endif	lint
X
X#include	<stdio.h>
X#include	"pscript.h"
X
X/* default values for the input bitmap data */
X#define	N_SCANSPERIMAGE	256	/* no. scan lines */
X#define	N_PIXELSPERSCAN	256	/* pixels per scanline */
X#define	N_SCANRES	8	/* no. bits per pixel (input) */
X#define	PAPERWIDTH	19.3	/* width (short axis) of paper (cm) */
X#define	PAPERLENGTH	28.3	/* length (long axis) of paper (cm) */
X
X/* possible input formats */
X#define	I_BYTE		'b'
X#define	I_HEX		'x'
X
X#define	BITSINBYTE	8
X
int	ScansPerImage = N_SCANSPERIMAGE,	/* no. lines in image */
X	PixelsPerScan = N_PIXELSPERSCAN,	/* no. pixels in each line */
X	scanres = N_SCANRES,		/* input resolution (no. grey levels) */
X	CellsPerInch = 60,		/* halftone cells/inch */
X	outres = 8,			/* 2^outres output grey levels */
X	CellRotation = 45,		/* halftone cell rotation */
X	rotation = 0,			/* image rotation */
X	headerskip = 0,			/* no. bytes to skip at start */
X	greyoffset = 0,			/* brightness */
X	PaperType =
X#ifdef	ALW
X		PT_A4,
X#else
X		PT_DEFAULT,
X#endif	ALW
X	inpformat = I_BYTE;		/* format of input data */
float	aspect = 1.5,		/* aspect ratio (x:y) */
X	width = 0.0,		/* output width (cm) */
X	height = 0.0;		/* output height (cm) */
bool	ManualFeed = FALSE,	/* manual or auto (paper tray) feed */
X	NegativeImage = FALSE;	/* reverse black and white */
X
double	atof();
X
X/* ARGSUSED */
main(argc, argv)
int	argc;
char	**argv;
X{
X	char	c;
X	bool	filesgiven = FALSE,
X		status = 0;
X
X	postr = stdout;
X	ScansPerImage = N_SCANSPERIMAGE;
X	PixelsPerScan = N_PIXELSPERSCAN;
X	argv++;		/* skip command name */
X
X	while(*argv)
X	{
X		if(**argv == '-')
X		{
X			(*argv)++;	/* skip the '-' */
X			c = **argv;	/* command arg */
X			(*argv)++;	/* skip arg letter */
X			switch(c)
X			{
X			case 'i':	/* input format */
X				if(**argv == 'b')
X					inpformat = I_BYTE;
X				else if(**argv == 'x')
X					inpformat = I_HEX;
X				else
X				{
X					fprintf(stderr, "input format (-i option) only allows 'b' or 'x'\n");
X					status++;
X					break;
X				}
X				(*argv)++;
X				if(**argv == '\0')
X				{
X					fprintf(stderr, "input format - expected scan resolution (bits) after `-%c'\n", (*argv)[-1]);
X					status++;
X					break;
X				}
X				scanres = atoi(*argv);
X				if(scanres < 1 || scanres > 8)
X				{
X					fprintf(stderr, "input format: illegal scan resolution must be in range 1 - 8\n");
X					status++;
X				}
X				break;
X
X			case 's':
X				headerskip = atoi(*argv);
X				break;
X
X			case 'g':	/* grey offset (brightness) */
X				greyoffset = atoi(*argv);
X				break;
X
X			case 'b':	/* bits resolution out */
X				outres=atoi(*argv);
X				if(outres != 1 && outres != 2 &&
X					outres != 4 && outres != 8)
X				{
X					fprintf(stderr,
X						"Illegal output resolution - must be 1, 2, 4 or 8 bits\n");
X					status++;
X				}
X				break;
X
X			case 'y':	/* no. scan lines input */
X				ScansPerImage=atoi(*argv);
X				break;
X
X			case 'x':	/* pixels per scanline */
X				PixelsPerScan = atoi(*argv);
X				break;
X
X			case 'a':	/* aspect ratio */
X				aspect = atof(*argv);
X				break;
X
X			case 'w':	/* width (cm) */
X				width = atof(*argv);
X				break;
X
X			case 'h':	/* height (cm) */
X				height = atof(*argv);
X				break;
X
X			case 'f':	/* output pixels/inch */
X				CellsPerInch = atoi(*argv);
X				break;
X
X			case 'p':	/* pixel rotation */
X				CellRotation = atoi(*argv);
X				break;
X
X			case 'r':	/* image rotation */
X				if(**argv)
X					rotation = atoi(*argv);
X				else
X					rotation = 90;
X				break;
X
X			case 'L':	/* 'legal' paper size */
X				PaperType = PT_LEGAL;
X				break;
X
X			case 'n':	/* negative image */
X				NegativeImage = TRUE;
X				break;
X
X			case 'S':	/* manual feed */
X				ManualFeed = TRUE;
X				break;
X
X			default:
X				fprintf(stderr, "Unknown option '%c'\n", c);
X				status++;
X			}
X		}
X		else
X		{
X			if(status)
X				usage();
X			filesgiven = TRUE;
X			status += DoImage(*argv);
X		}
X		argv++;
X	}
X	if(status && ! filesgiven)
X		usage();
X	if(! filesgiven)
X		status += DoImage("-");
X
X	exit(status);
X	/* NOTREACHED */
X}
X
char	*usagetab[] = {
X	"Usage: ipscript option file ...",
X	"valid options:",
X	"\t-r[angle]		output image rotation (degrees)",
X	"\t-wWidth			output image width (in cm)",
X	"\t-hHeight		output image height (in cm)",
X	"\t-aAspect		aspect ratio (width/height)",
X	"\t-yScanlines		no. scan lines in input",
X	"\t-xScanlength		no. pixels in an input scan line",
X	"\t-iFormat		input format: {'b'|'x'}bitsresolution",
X	"\t-sSkip			no. bytes header to skip",
X	"\t-gGrey			output grey level offset (signed)",
X	"\t-bbits			output resolution = 2^bits greylevels",
X	"\t-fFrequency		output frequency (pixels/inch)",
X	"\t-pAngle			pixel grid rotation (degrees)",
X	"\t-fFrequency		output frequency (dots/inch)",
X	"\t-n			negative image",
X	"\t-S			Use manual feed",
X	(char *) 0
X};
X
usage()
X{
X	char	**p;
X
X	p = usagetab;
X	while(*p)
X		fprintf(stderr, "%s\n", *p++);
X	exit(1);
X	/* NOTREACHED */
X}
X
X/* postscript initialisation for options currently in effect
X * Assumes default LaserWriter conditions (ie start of job)
X */
init(filename, BytesPerScan)
char	*filename;
int	BytesPerScan;
X{
X	pcomminit(0.0, (float) rotation, PaperType, ManualFeed,
X		"", filename, "ipscript bit image");
X	fprintf(postr, "gsave %d %d translate\n", rotation == 0 ? 25 : 18,
X						  rotation == 0 ? 0  : 5);
X
X	if(height == 0.0 && width == 0.0)
X		width = rotation == 0 ? PAPERWIDTH : PAPERLENGTH;
X	if(height == 0.0)
X		height = width / aspect;
X	else if(width == 0.0)
X		width = height * aspect;
X	fprintf(postr, "%.1f %.1f scale\n", width * PU_CM, height * PU_CM);
X
X	fprintf(postr, "0 setlinewidth\n");
X	fprintf(postr, "/picstr %d string def\n", BytesPerScan);
X	fprintf(postr, "/doimage {\n");
X	fprintf(postr, "%d %d %d [ %d 0 0 %d 0 %d ]\n",
X		PixelsPerScan, ScansPerImage, outres,
X		PixelsPerScan, - ScansPerImage, ScansPerImage);
X	fprintf(postr, "{ currentfile picstr readhexstring pop } image\n");
X	fprintf(postr, "} def\n");
X	if(CellsPerInch != PD_PFREQUENCY || CellRotation != PD_PROTATION)
X		fprintf(postr, "%d %d {dup mul exch dup mul add 1 exch sub} setscreen\n", CellsPerInch, CellRotation);
X	if(NegativeImage)
X		fprintf(postr, "{1 exch sub} settransfer\n");
X}
X
DoImage(filename)
char	*filename;
X{
X	register int	outval,
X			PixelInByte,
X			ByteInScan,
X			PixelInScan,
X			ScanInImage;
X	int		div,
X			inval,
X			max;
X	FILE		*istr;
X	int		BytesPerScan;	/* no. bytes/scanline output */
X	int		PixelsInByte;	/* no. pixels/byte output */
X	bool		OutRange = FALSE;
X
X	if(strcmp(filename, "-") == 0)
X		istr = stdin;
X	else if((istr = fopen(filename, "r")) == NULL)
X	{
X		perror(filename);
X		return(1);
X	}
X
X	PixelsInByte = BITSINBYTE / outres;
X	BytesPerScan = (PixelsPerScan + PixelsInByte - 1) / PixelsInByte;
X
X	init(filename, BytesPerScan);
X	max = 1 << scanres;
X	div = scanres - outres;
X
X	fprintf(postr, "%% Resolution: %d bits\n",
X		outres);
X	fprintf(postr, "(bit image start ...\\n) ps\n");
X	fprintf(postr, "%%%%EndProlog\n");
X	fprintf(postr, "%%%%Page 1 1\n");
X
X	fprintf(postr, "doimage\n");
X
X	for(ByteInScan = 0; ByteInScan < headerskip; ByteInScan++)
X		getc(istr);
X
X	for(ScanInImage = 0; ScanInImage < ScansPerImage; ScanInImage++)
X	{
X		for(ByteInScan = 0, PixelInScan = 0;
X			ByteInScan < BytesPerScan; ByteInScan++)
X		{
X			outval = 0;
X			/* build up an output byte */
X			for(PixelInByte = 0;
X				PixelInByte < PixelsInByte && PixelInScan < PixelsPerScan;
X				PixelInByte++, PixelInScan++)
X			{
X				if(inpformat == I_BYTE)
X					inval = getc(istr);
X				else
X				{	/* I_HEX */
X					if(scanres <= 4)
X						fscanf(istr, "%1X", &inval);
X					else
X						fscanf(istr, "%2X", &inval);
X				}
X				if(feof(istr))
X				{
X					fprintf(stderr, "Error: insufficient input\n");
X					return(1);
X				}
X				if(greyoffset)
X				inval += greyoffset;
X				if(inval < 0)
X				{
X					inval = 0;
X					OutRange = TRUE;
X				}
X				else if(inval >= max)
X				{
X					inval = max-1;
X					OutRange = TRUE;
X				}
X				if(div >= 0)
X					outval = (outval << outres) | (inval >> div);
X				else
X					outval = (outval << outres) | (inval << -div);
X			}
X			/* make up a whole byte at the end of a scan line */
X			for(; PixelInByte < PixelsInByte; PixelInByte++)
X				outval = outval << outres;
X			/* do a little bit of formatting to make it readable */
X			if(ByteInScan % 10 == 0)
X				if(ByteInScan % 30 == 0) putc('\n', postr);
X				else putc(' ', postr);
X			fprintf(postr, "%X%X", outval >> 4, outval & 017);
X		}
X		/* end of a scan line */
X		fprintf(postr, "\n");
X	}
X
X	/* draw a border around the picture */
X	if(NegativeImage)
X		fprintf(postr, "{} settransfer\n");	/* restore transfer func */
X	fprintf(postr,
X		"newpath 0 0 moveto 1 0 lineto 1 1 lineto 0 1 lineto closepath stroke\n");
X
X	fprintf(postr, "\ngrestore\nshowpage\n");
X	pcommfinish(-1, "");
X	if(getc(istr) != EOF)
X		fprintf(stderr,
X			"Warning: input data after end of image\n");
X	if(OutRange)
X		fprintf(stderr,
X			"Warning: input greyscale range too large - change 'i' or 'g' options\n");
X	return(0);
X}
END_OF_FILE
if test 9061 -ne `wc -c <'./opscript/ipscript.c'`; then
    echo shar: \"'./opscript/ipscript.c'\" unpacked with wrong size!
fi
# end of './opscript/ipscript.c'
fi
if test -f './opscript/lpscript.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./opscript/lpscript.c'\"
else
echo shar: Extracting \"'./opscript/lpscript.c'\" \(5717 characters\)
sed "s/^X//" >'./opscript/lpscript.c' <<'END_OF_FILE'
X/*
X *	lpscript - version 3.1
X *
X *	Convert plain text to postscript
X *
X *		- Stephen Frede, UNSW, Australia (stephenf@elecvax.oz)
X *			...!seismo!munnari!elecvax!stephenf
X */
X
X#ifndef	lint
static char id[] = "lpscript - version 3.1; Stephen Frede, UNSW, Australia";
X#endif	lint
X
X#include	<stdio.h>
X#include	"pscript.h"
X
X#define	PAGEOFFSET	(1.0*PU_CM)
X#define	FONTSIZE	10.0		/* default font size (in points) */
X#define	TABSIZE		8
X#define	FONT		"Courier"
X#define	DOUBLESPACE	1.8		/* line spacing for double spacing */
X
X
char	usage[] = "Valid lpscript options:\n\t-o[offset]\n\t-r[rotation]\n\
X\t-s[fontsize]\n\t-a[fontaspect]\n\t-p[pitch]\n\t-f[font]\n\t-t[tabsize]\n\
X\t-h[horizontal_spacing]\n\t[-S]\t(manual feed)\n\t[-L]\t(legal paper type)\n";
int	tabsize = TABSIZE;		/* in character positions */
X
double	atof();
X
X/* ARGSUSED */
main(argc, argv)
int	argc;
char	**argv;
X{
X	int	status = 0;	/* exit status (no. errors occured) */
X	float	pageoffset = 18.0,
X		fontsize = FONTSIZE,
X		aspect = 1.0,
X		linepitch = 0,
X		spacing = 0.0,
X		rotation = PD_ROTATION;
X	char	*fontname = FONT;
X	FILE	*istr;
X	bool	manualfeed = FALSE,
X		doublespace = FALSE;
X	int	pagetype	=
X#ifdef	ALW
X				PT_A4;
X#else	ALW
X				PT_DEFAULT;
X#endif	ALW
X
X	postr = stdout;
X	argv++;		/* skip program name */
X	while(*argv && **argv == '-')
X	{
X		char	c;
X
X		(*argv)++;	/* skip the '-' */
X		c = **argv;	/* option letter */
X		(*argv)++;	/* skip option letter */
X		switch(c)
X		{
X			case 'o':	/* offset */
X				if(**argv == '\0')
X					pageoffset = PAGEOFFSET;
X				else
X					pageoffset = atof(*argv) * PU_CM;
X				break;
X
X			case 'r':	/* rotation */
X				if(**argv == '\0')
X					rotation = 90.0;
X				else
X					rotation = atof(*argv);
X				break;
X
X			case 'p':	/* pitch (line spacing) */
X				if(**argv == '\0')
X					doublespace = TRUE;
X				else
X					linepitch = atof(*argv);
X				break;
X
X			case 's':	/* font size */
X				if(**argv == '\0')
X					fontsize = 12.0;
X				else
X					fontsize = atof(*argv);
X				break;
X
X			case 't':	/* tab size */
X				if(**argv == '\0')
X					tabsize = 4;
X				else
X					tabsize = (int) atof(*argv);
X				break;
X
X			case 'f':	/* font */
X				if(**argv == '\0')
X					fontname = "Times-Roman";
X				else
X					fontname = *argv;
X				break;
X
X			case 'h':	/* horizontal spacing */
X				if(**argv == '\0')
X					spacing = 0.25;
X				else
X					spacing = atof(*argv);
X				break;
X
X			case 'a':	/* character aspect ratio */
X				if(**argv == '\0')
X					aspect = 1.0;
X				else
X					aspect = atof(*argv);
X				break;
X
X			case 'S':	/* manual feed */
X				manualfeed = TRUE;
X				break;
X
X			case 'L':	/* legal paper type */
X				pagetype = PT_LEGAL;
X				break;
X
X			default:
X				fprintf(stderr, "Unknown option: '%c'\n", c);
X				status++;
X				break;
X		}
X		argv++;
X	}
X	if(status)
X	{
X		fprintf(stderr, usage);
X		exit(status);
X		/* NOTREACHED */
X	}
X	if(doublespace)
X		linepitch = fontsize * DOUBLESPACE;
X	if(linepitch == 0)
X		linepitch = fontsize;
X	spacing *= fontsize;
X	init(fontsize, aspect, pageoffset, linepitch, rotation, fontname,
X		spacing, manualfeed, pagetype);
X	if(! *argv)
X	{
X		fprintf(postr, "(stdin ...\\n) ps\n");
X		process(stdin);
X	}
X	else while(*argv)
X	{
X		if((istr = fopen(*argv, "r")) == NULL)
X		{
X			perror(*argv);
X			status++;
X		}
X		else
X		{
X			fprintf(postr, "('%s' ...\\n) ps\n", *argv);
X			process(istr);
X			fclose(istr);
X		}
X		argv++;
X	}
X	pcommfinish(-1, (char *)0);
X	putc('\004', postr);
X	exit(status);
X	/* NOTREACHED */
X}
X
process(istr)
XFILE	*istr;
X{
X	register int	ch;
X	register int	x;	/* used for tab calculations */
X	register int	prefix;
X
X	x = 0;
X	prefix = 0;
X	while((ch=getc(istr)) != EOF)
X	{
X		if(!prefix)
X		{
X			putc('(', postr);
X			prefix = 1;
X		}
X		if(ch < ' ' && ch != '\t' && ch != '\n' && ch != '\r' && ch != '\f')
X			ch = '?';
X		switch(ch)
X		{	
X		case '\t':
X			{
X			int	n = x + tabsize - (x % tabsize);
X
X			while(x < n)
X				pch(' '), x++;
X			}
X			break;	
X		case '\n':
X			x = 0;
X			fprintf(postr, ")n\n");
X			prefix = 0;
X			break;
X		case '\r':
X			x = 0;
X			fprintf(postr, ")r\n");
X			prefix = 0;
X			break;
X		case '\f':
X			x = 0;
X			fprintf(postr, ")n dpage\n");
X			prefix = 0;
X			break;
X		default:
X			pch(ch);
X			x++;
X		}
X	}
X	if(prefix)
X		fprintf(postr, ")n\n");
X	fprintf(postr, "dpage ( ---\\n) ps\n");
X}
X
char	*inittab[] = {
X	/* current y coord */
X	"/y { currentpoint exch pop } def",
X
X	/* var to prevent trailing blank page */
X	"/dopage false def",
X
X	/* print a new page */
X	"/dpage { dopage { page /dopage false def } if } def",
X
X	/* print a line then move to the next */
X	"/n",
X	"{ spacing 0 3 -1 roll ashow",
X	"  0 y linepitch add moveto",
X	"  /dopage true def",
X	"  y pgbot lt { dpage } if",
X	"} def",
X
X	/* print a line - then return to start */
X	"/r",
X	"{ spacing 0 3 -1 roll ashow",
X	"  0 y moveto",
X	"  /dopage true def",
X	"} def",
X
X	(char *)0 };
X
init(fontsize, aspect, pageoffset, linepitch, rotation, fontname,
X	spacing, manualfeed, pagetype)
float	fontsize,
X	aspect,
X	pageoffset,
X	linepitch,
X	spacing,
X	rotation;
char	*fontname;
bool	manualfeed;
int	pagetype;
X{
X	register char	**p;
X
X	pcomminit(0.0, rotation, pagetype, manualfeed,
X			fontname, (char *)0, "lpscript");
X	p = inittab;
X	while(*p)
X		fprintf(postr, "%s\n", *p++);
X	fprintf(postr, "/%s findfont [ %.1f 0 0 %.1f 0 0 ] makefont setfont\n",
X		fontname, fontsize, fontsize * aspect);
X	fprintf(postr, "/linepitch %.1f def\n", -linepitch);
X	fprintf(postr, "/spacing %.1f def\n", spacing);
X	/* subtract linespacing (add -'ve) to get top text baseline */
X	fprintf(postr, "/pgtop pgtop linepitch add def\n");
X	/* calculate bottom text baseline */
X	fprintf(postr, "/pgbot currentfont /FontBBox get 1 get neg 1000 div %.1f mul def\n", fontsize * aspect);
X	/* apply horizontal offset, if any */
X	fprintf(postr, "%.1f 0 translate\n", pageoffset);
X
X	/* save state */
X	endinit();
X}
END_OF_FILE
if test 5717 -ne `wc -c <'./opscript/lpscript.c'`; then
    echo shar: \"'./opscript/lpscript.c'\" unpacked with wrong size!
fi
# end of './opscript/lpscript.c'
fi
if test -f './opscript/pcom.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./opscript/pcom.c'\"
else
echo shar: Extracting \"'./opscript/pcom.c'\" \(6439 characters\)
sed "s/^X//" >'./opscript/pcom.c' <<'END_OF_FILE'
X/* LINTLIBRARY */
X/*
X *	pcom.c
X *
X *	Some common code for programs which generate postscript.
X *
X *	We assume that the lineprinter software brackets jobs with EOF,
X *	and possibly sets jobname etc., so we don't do it ourselves.
X *	The program that calls these routines should do any necessary
X *	scaling first.
X *	We will set the following variables:
X *	/pgtop		top of page 
X *	/stm		job start time in ms
X *	/spg		pages at start of job
X *	/jobname	string - name of current job
X *	We define the following postscript routines:
X *	/mf		enable manual feed
X *	/af		enable auto feed
X *	/ps		print string on output stream
X *	/a4		set a4 page size	(Apple LaserWriter Only)
X *
X */
X
X#include	"pscript.h"
X#include	<stdio.h>
X#if	VERBOSE 
X#if	BSD
X#include	<sys/time.h>
X#else	BSD
X#include	<time.h>
X#endif	BSD
X#if	AUSAM
X#include	<passwd.h>
X#else	AUSAM
X#include	<pwd.h>
X#endif	AUSAM
X#if	SYSV
X#include	<sys/utsname.h>
X#endif	SYSV
X#if	UNSW
X#include	<table.h>
X#endif	UNSW
X#endif	VERBOSE
X
X	/* output stream on which postscript appears */
XFILE		*postr = NULL;
X
long	time();
char	*ctime(),
X	*getuser(),
X	*systemid();
X
char	*ptstr[] = {
X	"",		/* default - usually determined by paper tray */
X	"letter",
X	"legal",
X	"note",
X#ifdef	ALW
X	"a4",		/* on Apple LaserWriter ONLY */
X#endif	ALW
X};
X
char	*pcom0tab[] = {
X	"initmatrix",
X#ifdef	ALW
X	"/a4 [ [300 72 div 0 0 -300 72 div -52 3436 ] 292 3365",
X#ifndef ALWPLUS
X	"{statusdict /jobstate (printing) put 0 setblink",
X	"margins exch 157 add exch 245 add 8 div round cvi frametoroket",
X	"statusdict /jobstate (busy) put 1 setblink} /framedevice load",
X#endif  ALWPLUS
X	"60 45 {dup mul exch dup mul add 1.0 exch sub} /setscreen load",
X	"{} /settransfer load /initgraphics load /erasepage load ] cvx",
X	"statusdict begin bind end readonly def",
X#endif	ALW
X	(char *)0
X};
X
char	*pcom1tab[] = {
X#if	VERBOSE
X	/* job start time in ms */
X	"/stm usertime def",
X	/* remember total pages used */
X	"/pgc statusdict begin pagecount end def",
X#endif	VERBOSE
X	/* move origin up page so bottom is bottom of imageable region */
X	"clippath pathbbox pop pop exch pop 0 exch translate",
X	/* save top of page */
X	"clippath pathbbox /pgtop exch def pop pop pop",
X#if	VERBOSE
X	/* routine to print strings on output stream */
X	"/ps { print flush } def",
X#endif
X	/* routine to print a page and begin a new one */
X	/* the restore/save pair is important - it ensures that VM garbage
X	 * collection is done at least once every page. The user program
X	 * (ie lpscript, tpscript, etc.) MUST call endinit() as the
X	 * last part of its initialisation - this prints an initial
X	 * "save".
X	 */
X	"/page { copypage erasepage restore save home } def",
X	/* routine to initialise a path */
X	"/home { newpath 0 pgtop moveto } def",
X	/* routines to select manual or auto feed */
X	"/mf { statusdict /manualfeed true put",
X#ifdef	ALW
X	/* fix for manual feed bug (see p. 29 Appendix D Inside LaserWriter) */
X	" usertime 5000 add { dup usertime lt { pop exit } if } loop",
X#endif	ALW
X	" } def",
X	"/af { statusdict /manualfeed false put } def",
X	(char *)0
X};
X
pcomminit(scale, rotation, papertype, manualfeed, font, title, creator)
float	rotation,
X	scale;
int	papertype;
bool	manualfeed;
char	*font,
X	*title,
X	*creator;
X{
X	register char	**ptab;
X	long		clock;
X#if	VERBOSE
X	char		*user;
X	char		jobname[100];
X#endif	VERBOSE
X
X	fprintf(postr, "%%!PS-Adobe-1.0\n");
X	time(&clock);
X#if	VERBOSE
X	user = getuser();
X	if(title)
X		strcpy(jobname, title);
X	else
X	{
X		strcpy(jobname, user);
X		strcat(jobname, "/");
X		strcat(jobname, creator);
X	}
X	fprintf(postr, "%%%%Title: %s\n", jobname);
X#endif	VERBOSE
X	fprintf(postr, "%%%%DocumentFonts: %s\n",
X		font ? font : "");
X	fprintf(postr, "%%%%Creator: %s\n", creator);
X	fprintf(postr, "%%%%CreationDate: %s", ctime(&clock));
X	fprintf(postr, "%%%%Pages: (atend)\n");
X#if	VERBOSE
X	fprintf(postr, "%%%%For: %s\n", user);
X#endif	VERBOSE
X	fprintf(postr, "%%%%EndComments\n");
X	ptab = pcom0tab;
X	while(*ptab)
X		fprintf(postr, "%s\n", *ptab++);
X	fprintf(postr, "%s\n", ptstr[papertype]);
X	if(rotation != PD_ROTATION)
X		fprintf(postr, "%.1f rotate\n", rotation);
X	if(scale != 1.0 && scale != 0.0)
X		fprintf(postr, "%.4f dup scale\n", scale);
X	ptab = pcom1tab;
X	while(*ptab)
X		fprintf(postr, "%s\n", *ptab++);
X#if	VERBOSE
X	fprintf(postr, "/jobname (%s) def\n", jobname);
X	fprintf(postr, "userdict /jobname jobname put\n");
X	fprintf(postr, "( :: '%s' :: job starts\\n) ps\n", jobname);
X#endif	VERBOSE
X	fprintf(postr, "%s\n", manualfeed ? "mf" : "af");
X}
X
endinit()
X{
X	/* this save is for the restore/save pairs in page */
X	fprintf(postr, "\nsave\n");
X	/* all variable assignments are now local to a page */
X
X	/* initialise current path - move to top of page */
X	fprintf(postr, "home\n");
X	fprintf(postr, "%%%%EndProlog\n");
X}
X
pch(ch)
int	ch;
X{
X	if(ch < ' ' || ch > '~')
X		fprintf(postr, "\\%03o", ch);
X	else
X	{
X		if(ch == '(' || ch == ')' || ch == '\\')
X			putc('\\', postr);
X		putc(ch, postr);
X	}
X}
X
pcommfinish(pages, fonts)
int pages;
char *fonts;
X{
X	fprintf(postr, "\n%%%%Trailer\n");
X#if	VERBOSE
X	fprintf(postr, "jobname ps (: Job finished:\\n) ps\n");
X	fprintf(postr, "(\\ttime (s) = ) ps usertime stm sub 1000 div ==\n");
X	fprintf(postr, "(\\tpages = ) ps statusdict begin pagecount end pgc sub == flush\n");
X	if(pages >= 0)
X		fprintf(postr, "%%%%Pages: %d\n", pages);
X#endif	VERBOSE
X	if(fonts)
X		fprintf(postr, "%%%%DocumentFonts: %s\n");
X}
X
X#if	VERBOSE
char *
getuser()
X{
X	char		*lname;
X	static char	username[100];
X#if	AUSAM
X	char		sbuf[SSIZ];
X	struct pwent	pe;
X	extern int	getpwlog();
X
X	pe.pw_limits.l_uid = getuid();
X	if(getpwlog(&pe, sbuf, sizeof(sbuf)) == PWERROR)
X		lname = (char *)0;
X	else
X		lname = pe.pw_strings[LNAME];
X	pwclose();
X	if(lname == (char *)0)
X		lname = "?";
X	strcpy(username, lname);
X
X#else	/* ! AUSAM */
X	extern	char		*getlogin();
X	extern	struct passwd	*getpwuid();
X	struct	passwd		*pwdp;
X
X	if ( ( lname = getlogin() ) != NULL )
X		strcpy( username, lname );
X	else
X	{
X		if ( ( pwdp = getpwuid( getuid() ) ) == (struct passwd *)0 )
X			sprintf( username, "User%d", getuid() );
X		else
X			strcpy( username, pwdp->pw_name );
X	}
X#endif	/* ! AUSAM */
X	strcat(username, "@");
X	strcat(username, systemid());
X	return(username);
X}
X
char *
systemid()
X{
X	static char	sysname[100] = "";
X
X#if	UNSW
X	getaddr(G_SYSNAME, sysname);
X#endif	UNSW
X
X#if	BSD
X	gethostname( sysname, sizeof(sysname) );
X#endif	BSD
X
X#if	SYSV
X	struct utsname	un;
X
X	uname(&un);
X	strcpy(sysname, un.nodename);
X#endif	SYSV
X
X	return(sysname);
X}
X#endif	VERBOSE
END_OF_FILE
if test 6439 -ne `wc -c <'./opscript/pcom.c'`; then
    echo shar: \"'./opscript/pcom.c'\" unpacked with wrong size!
fi
# end of './opscript/pcom.c'
fi
if test -f './tpscript/pcom.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./tpscript/pcom.c'\"
else
echo shar: Extracting \"'./tpscript/pcom.c'\" \(7314 characters\)
sed "s/^X//" >'./tpscript/pcom.c' <<'END_OF_FILE'
X/* LINTLIBRARY */
X/*
X *	pcom.c
X *
X *	Some common code for programs which generate postscript.
X *
X *	We assume that the lineprinter software brackets jobs with EOF,
X *	and possibly sets jobname etc., so we don't do it ourselves.
X *	The program that calls these routines should do any necessary
X *	scaling first.
X *	We will set the following variables:
X *	/pgtop		top of page 
X *	/stm		job start time in ms
X *	/spg		pages at start of job
X *	/jobname	string - name of current job
X *	We define the following postscript routines:
X *	/mf		enable manual feed
X *	/af		enable auto feed
X *	/ps		print string on output stream
X *	/a4		set a4 page size	(Apple LaserWriter Only)
X *
X */
X
X#include	"pscript.h"
X#include	<stdio.h>
X#if	VERBOSE 
X#if	BSD
X#include	<sys/time.h>
X#else	BSD
X#include	<time.h>
X#endif	BSD
X#if	AUSAM
X#include	<passwd.h>
X#else	AUSAM
X#include	<pwd.h>
X#endif	AUSAM
X#if	SYSV
X#include	<sys/utsname.h>
X#endif	SYSV
X#if	UNSW
X#include	<table.h>
X#endif	UNSW
X#endif	VERBOSE
X
X	/* output stream on which postscript appears */
XFILE		*postr = NULL;
X
long	time();
char	*ctime(),
X	*getuser(),
X	*systemid();
X
char	*ptstr[] = {
X	"",		/* default - usually determined by paper tray */
X	"letter",
X	"legal",
X	"note",
X#ifndef GEMPRINT
X#ifdef	ALW
X	"a4",		/* on Apple LaserWriter ONLY */
X#endif	ALW
X#endif GEMPRINT
X};
X
char	*pcom0tab[] = {
X	"initmatrix",
X#ifndef GEMPRINT
X#ifdef	ALW
X	"/a4 [ [300 72 div 0 0 -300 72 div -52 3436 ] 292 3365",
X#ifndef ALWPLUS
X	"{statusdict /jobstate (printing) put 0 setblink",
X	"margins exch 157 add exch 245 add 8 div round cvi frametoroket",
X	"statusdict /jobstate (busy) put 1 setblink} /framedevice load",
X#endif  ALWPLUS
X	"60 45 {dup mul exch dup mul add 1.0 exch sub} /setscreen load",
X	"{} /settransfer load /initgraphics load /erasepage load ] cvx",
X	"statusdict begin bind end readonly def",
X#endif	ALW
X#endif GEMPRINT
X	(char *)0
X};
X
char	*pcom1tab[] = {
X#if	VERBOSE
X	/* job start time in ms */
X	"/stm usertime def",
X	/* remember total pages used */
X	"/pgc statusdict begin pagecount end def",
X#endif	VERBOSE
X	/* move origin up page so bottom is bottom of imageable region */
X	"clippath pathbbox pop pop exch pop 0 exch translate",
X	/* save top of page */
X	"clippath pathbbox /pgtop exch def pop pop pop",
X#if	VERBOSE
X	/* routine to print strings on output stream */
X	"/ps { print flush } def",
X#endif
X	/* routine to print a page and begin a new one */
X	/* the restore/save pair is important - it ensures that VM garbage
X	 * collection is done at least once every page. The user program
X	 * (ie lpscript, tpscript, etc.) MUST call endinit() as the
X	 * last part of its initialisation - this prints an initial
X	 * "save".
X	 */
X	"/page { copypage erasepage restore save home } def",
X	/* routine to initialise a path */
X	"/home { newpath 0 pgtop moveto } def",
X	/* routines to select manual or auto feed */
X	"/mf { statusdict /manualfeed true put",
X#ifdef	ALW
X	/* fix for manual feed bug (see p. 29 Appendix D Inside LaserWriter) */
X	" usertime 5000 add { dup usertime lt { pop exit } if } loop",
X#endif	ALW
X	" } def",
X	"/af { statusdict /manualfeed false put } def",
X	(char *)0
X};
X
pcomminit(scale, rotation, papertype, manualfeed, font, title, creator)
float	rotation,
X	scale;
int	papertype;
bool	manualfeed;
char	*font,
X	*title,
X	*creator;
X{
X	register char	**ptab;
X	long		clock;
X#if	VERBOSE
X	char		*user;
X	char		jobname[100];
X#endif	VERBOSE
X
X	fprintf(postr, "%%!PS-Adobe-1.0\n");
X
X	time(&clock);
X#if	VERBOSE
X	user = getuser();
X	if(title)
X		strcpy(jobname, title);
X	else
X	{
X		strcpy(jobname, user);
X		strcat(jobname, "/");
X		strcat(jobname, creator);
X	}
X	fprintf(postr, "%%%%Title: %s\n", jobname);
X#endif	VERBOSE
X	fprintf(postr, "%%%%DocumentFonts: %s\n",
X		font ? font : "");
X	fprintf(postr, "%%%%Creator: %s\n", creator);
X	fprintf(postr, "%%%%CreationDate: %s", ctime(&clock));
X	fprintf(postr, "%%%%Pages: (atend)\n");
X#if	VERBOSE
X	fprintf(postr, "%%%%For: %s\n", user);
X#endif	VERBOSE
X	fprintf(postr, "%%%%EndComments\n");
X
X/* This is the complementary statement for the end of pcommfinish. */
X/* The LaserWriter's VMstate is saved to avoid choking on multiple */
X/* subsequent printjobs. This is neccesary because the LW does not notice */
X/* end-of-file condition. 08/06/87 --- axel@coma.uucp */
X#ifdef VMSAVE
X	fprintf(postr, "/vmstat save def\n");
X#endif VMSAVE
X
X	ptab = pcom0tab;
X	while(*ptab)
X		fprintf(postr, "%s\n", *ptab++);
X#ifndef GEMPRINT
X	fprintf(postr, "%s\n", ptstr[papertype]);
X#endif GEMPRINT
X	if(rotation != PD_ROTATION)
X		fprintf(postr, "%.1f rotate\n", rotation);
X	if(scale != 1.0 && scale != 0.0)
X		fprintf(postr, "%.4f dup scale\n", scale);
X	ptab = pcom1tab;
X	while(*ptab)
X		fprintf(postr, "%s\n", *ptab++);
X#if	VERBOSE
X	fprintf(postr, "/jobname (%s) def\n", jobname);
X	fprintf(postr, "userdict /jobname jobname put\n");
X	fprintf(postr, "( :: '%s' :: job starts\\n) ps\n", jobname);
X#endif	VERBOSE
X	fprintf(postr, "%s\n", manualfeed ? "mf" : "af");
X}
X
endinit()
X{
X	/* this save is for the restore/save pairs in page */
X	fprintf(postr, "\nsave\n");
X	/* all variable assignments are now local to a page */
X
X	/* initialise current path - move to top of page */
X	fprintf(postr, "home\n");
X	fprintf(postr, "%%%%EndProlog\n");
X}
X
pch(ch)
int	ch;
X{
X	if(ch < ' ' || ch > '~')
X		fprintf(postr, "\\%03o", ch);
X	else
X	{
X		if(ch == '(' || ch == ')' || ch == '\\')
X			putc('\\', postr);
X		putc(ch, postr);
X	}
X}
X
pcommfinish(pages, fonts)
int pages;
char *fonts;
X{
X	fprintf(postr, "\n%%%%Trailer\n");
X#if	VERBOSE
X	fprintf(postr, "jobname ps (: Job finished:\\n) ps\n");
X	fprintf(postr, "(\\ttime (s) = ) ps usertime stm sub 1000 div ==\n");
X	fprintf(postr, "(\\tpages = ) ps statusdict begin pagecount end pgc sub == flush\n");
X	if(pages >= 0)
X		fprintf(postr, "%%%%Pages: %d\n", pages);
X#endif	VERBOSE
X	if(fonts)
X		fprintf(postr, "%%%%DocumentFonts: %s\n");
X
X/* This is the complementary statement for the beginnig of pcomminit */
X/* The LaserWriter's VMstate is reset to avoid choking on multiple */
X/* subsequent printjobs. This is neccesary because the LW does not notice */
X/* end-of-file condition. 08/06/87 --- axel@coma.uucp */
X#ifdef VMSAVE
X	fprintf (postr, 
X	          "count { pop } repeat %% a little cleanup is necessary\n");
X	fprintf (postr, "vmstat restore\n");
X#endif VMSAVE
X}
X
X#if	VERBOSE
char *
getuser()
X{
X	char		*lname;
X	static char	username[100];
X#if	AUSAM
X	char		sbuf[SSIZ];
X	struct pwent	pe;
X	extern int	getpwlog();
X
X	pe.pw_limits.l_uid = getuid();
X	if(getpwlog(&pe, sbuf, sizeof(sbuf)) == PWERROR)
X		lname = (char *)0;
X	else
X		lname = pe.pw_strings[LNAME];
X	pwclose();
X	if(lname == (char *)0)
X		lname = "?";
X	strcpy(username, lname);
X
X#else	/* ! AUSAM */
X	extern	char		*getlogin();
X	extern	struct passwd	*getpwuid();
X	struct	passwd		*pwdp;
X
X	if ( ( lname = getlogin() ) != NULL )
X		strcpy( username, lname );
X	else
X	{
X		if ( ( pwdp = getpwuid( getuid() ) ) == (struct passwd *)0 )
X			sprintf( username, "User%d", getuid() );
X		else
X			strcpy( username, pwdp->pw_name );
X	}
X#endif	/* ! AUSAM */
X	strcat(username, "@");
X	strcat(username, systemid());
X	return(username);
X}
X
char *
systemid()
X{
X	static char	sysname[100] = "";
X
X#if	UNSW
X	getaddr(G_SYSNAME, sysname);
X#endif	UNSW
X
X#if	BSD
X	gethostname( sysname, sizeof(sysname) );
X#endif	BSD
X
X#if	SYSV
X	struct utsname	un;
X
X	uname(&un);
X	strcpy(sysname, un.nodename);
X#endif	SYSV
X
X	return(sysname);
X}
X#endif	VERBOSE
END_OF_FILE
if test 7314 -ne `wc -c <'./tpscript/pcom.c'`; then
    echo shar: \"'./tpscript/pcom.c'\" unpacked with wrong size!
fi
# end of './tpscript/pcom.c'
fi
if test -f './tpscript/sfont2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./tpscript/sfont2.c'\"
else
echo shar: Extracting \"'./tpscript/sfont2.c'\" \(6079 characters\)
sed "s/^X//" >'./tpscript/sfont2.c' <<'END_OF_FILE'
X/*
X * sfont2.c
X * routines for manipulating special font 2 (the characters generated
X * specifically to match troff requirements - because kludging the available
X * bracket chars could never be made to work completely properly)
X */
X
X#include	"tpscript.h"
X
X#include	"sfont2defs.h"
X
struct spcdefs {
X	short	s2_index;	/* index in encoding structure == value in width tables */
X	short	s2_width;	/* width of char as in width tables */
X	char	*s2_name;	/* troff 2(?)-char name */
X	char	*s2_def;	/* the postscript definition to build the char */
X};
X
X		/*
X		 * if chars are wider than this then you cannot use the
X		 * default C.setC procedure for calling setcachedevice
X		 * This comes about because, while I could just call
X		 * setcachedevice with the values in FontBBox, I assume that
X		 * I will save caching memory if i dont use a value which is
X		 * twice as big as I really need for most chars.
X		 * ... But do I really save anything since the definition is
X		 * now a bit bigger? - probably I do, since the space defined
X		 * by the bounding box at 10 pt is about 2400 pixels
X		 * (~ 300 bytes)
X		 */
X#define	DFLT_CACHE_WIDTH	50
X
X	/*
X	 * note - I really should look up the width in the width tables and
X	 * just use that but when we run s2init() we havent read in the
X	 * tables yet - and while about it i should probably read in the
X	 * index value as well.
X	 */
X
typedef	struct	spcdefs	S2DEF;
X
S2DEF	s2defs[]  = {
X	{ 0101, 50, "bv", "C.bv" },
X	{ 0102, 50, "lt", DEF_lt },
X	{ 0103, 50, "lk", DEF_lk },
X	{ 0104, 50, "lb", DEF_lb },
X	{ 0105, 50, "rt", DEF_rt },
X	{ 0106, 50, "rk", DEF_rk },
X	{ 0107, 50, "rb", DEF_rb },
X	{ 0110, 50, "lc", DEF_lc },
X	{ 0111, 50, "lf", DEF_lf },
X	{ 0112, 50, "rc", DEF_rc },
X	{ 0113, 50, "rf", DEF_rf },
X	{ 0114, 0, "br",  DEF_br },
X	{ 0115, 50, "rn", DEF_rn },
X	{ 0116, 100, "ci", DEF_ci },
X	{ 0117, 17,  "||", DEF_sp_6 },
X	{ 0120, 8,   "^^", DEF_sp_12 },
X	{ 0121, 80,  "r1", DEF_r1 },
X	{ 0122, 80,  "r2", DEF_r2 },
X	{ 0, 0,    "",   "" }
X};
X#define	NUM_S2DEFS	(sizeof s2defs/sizeof(S2DEF) -1)
X
X	/*
X	 * bracket font initialisation
X	 */
char	*bf_0init[] = {
X	"/BracketFontDict 9 dict def /$workingdict 10 dict def",
X	"BracketFontDict begin",
X		/* locally defined font */
X	"/FontType 3 def",
X		/* give it a name like the built-in fonts */
X	"/FontName (Bracket) cvn def",
X		/* the standard matrix for font definitions */
X	"/FontMatrix [ 0.001 0 0 0.001 0 0] def",
X	"/FontBBox [ -50 -250 1000 1000 ] def",
X		/* will be a sparse array so fill initally with .notdef */
X	"/Encoding 256 array def 0 1 255 { Encoding exch /.notdef put } for",
X	"Encoding",
X	(char *) 0 };
X		/* at this point we put the real encoding and the procedures for
X		* building the chars
X		*/
X
X		/*
X		 * predefined common routines for inclusion in CharProcs
X		 */
char	*bf_CPinit[] = {
X			/*
X			 * define setcachedevice with default width passed
X			 * as argument (on stack)
X			 */
X	"/setC { 0 -50 -250 500 1000 setcachedevice} def",
X			/*
X			 * common stuff for solid vert bar (\(bv)
X			 * also used for floor and ceilings
X			 */
X	"/C.bv {220 -250 moveto 0 1000 rlineto",
X		"60 0 rlineto 0 -1000 rlineto fill } def",
X			/*
X			 * stuff for horiz bar for ceiling
X			 * X coord passed as arg
X			 */
X	"/C.barc { 750 moveto 180 0 rlineto 0 -60 rlineto -180 0 rlineto fill } def",
X			/*
X			 * stuff for horiz bar for floor
X			 */
X	"/C.barf { -250 moveto 180 0 rlineto 0 60 rlineto -180 0 rlineto fill } def",
X			/*
X			 * common routine for drawing the end parts of brackets
X			 * e.g. \(lt, \(lb
X			 * start with starting x,y on stack
X			 * draw line and then curve to tip
X			 */
X	"/C.brk.end { 1 setlinewidth moveto rlineto rcurveto",
X			/* back to start, over by width of line */
X			/* draw line and then curve to near tip */
X		"reversepath 60 0 rlineto rlineto rcurveto fill } def",
X
X			/*
X			 * set the linewidth rounded to the nearest pixel
X			 * We need a dummy y entry as well but ignore it.
X			 * The reason for using the X rounded value is only
X			 * relevant when ( x-scale != y-scale ):
X			 * since troff keeps char width constant and scales
X			 * the height up/down, we also scale relative to the
X			 * width.
X			 */
X	"/C.setl {dup dtransform exch round exch idtransform pop setlinewidth } def",
X
X	(char *) 0 };
X
X#define	N_CP_PROCS	6	/* number of extra common procs */
X
X		/*
X		 * the mandatory BuildChar routine for the font description
X		 */
char	*bf_1init[] = {
X	"/BuildChar",
X	"{",
X	"	$workingdict begin",
X	"	/charcode exch def",
X	"	/fontdict exch def",
X	"	fontdict /CharProcs get begin",
X	"	fontdict /Encoding get",
X	"	charcode get load",
X	"	gsave",
X	"	0 setlinecap 0 setgray newpath",
X	"	exec",
X	"	grestore",
X	"	end end",
X	"} def end",
X	"/BracketFont BracketFontDict definefont pop",
X	(char *) 0 };
X
X		/*
X		 * setup the definitions for building our own special font
X		 * for the characters that the laserwriter does not do
X		 * properly
X		 */
s2init()
X{
X	register	char	**ptab;
X	register	S2DEF	*s2p;
X
X	ptab = bf_0init;
X	while(*ptab)
X		fprintf(postr, "%s\n", *ptab++);
X			/*
X			 * now put the entries in the encoding table
X			 */
X	for ( s2p = &s2defs[0] ; s2p->s2_index != 0 ; s2p++ )
X		fprintf( postr, "dup %d /C%s put\n",
X				s2p->s2_index, s2p->s2_name);
X			/*
X			 * define the CharProcs dictionary which contains
X			 * the procedures required by BuildChar to construct
X			 * the characters
X			 */
X	fprintf( postr, "pop\n/CharProcs %d dict dup begin\n",
X			NUM_S2DEFS + N_CP_PROCS );
X
X	ptab = bf_CPinit;
X	while(*ptab)
X		fprintf(postr, "%s\n", *ptab++);
X
X	for ( s2p = &s2defs[0] ; s2p->s2_index != 0 ; s2p++ )
X	{
X		if ( s2p->s2_width == DFLT_CACHE_WIDTH )
X			fprintf( postr, "/C%s {\n%d setC\n%s\n} def\n",
X				s2p->s2_name,
X				(int)(s2p->s2_width * respunits),
X					/* this is unwise because it assumes
X					 * unitwidth 10 in DESC file
X					 */
X				s2p->s2_def);
X		else
X			fprintf( postr,
X				"/C%s {\n%d 0 -50 -250 %d 1000 setcachedevice\n%s\n} def\n",
X				s2p->s2_name,
X				(int)(s2p->s2_width * respunits),
X				(int)(s2p->s2_width * respunits),
X				s2p->s2_def);
X	}
X	fputs( "end def\n", postr);
X	ptab = bf_1init;
X	while(*ptab)
X		fprintf(postr, "%s\n", *ptab++);
X}
X
END_OF_FILE
if test 6079 -ne `wc -c <'./tpscript/sfont2.c'`; then
    echo shar: \"'./tpscript/sfont2.c'\" unpacked with wrong size!
fi
# end of './tpscript/sfont2.c'
fi
echo shar: End of archive 4 \(of 5\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
