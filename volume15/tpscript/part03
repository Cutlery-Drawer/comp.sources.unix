Subject:  v15i015:  Ditroff to PostScript translator, Part03/05
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Axel Mahler <axel%coma.UUCP%TUB.BITNET@mitvma.mit.edu>
Posting-number: Volume 15, Issue 15
Archive-name: tpscript/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 5)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f './READ_ME' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./READ_ME'\"
else
echo shar: Extracting \"'./READ_ME'\" \(5305 characters\)
sed "s/^X//" >'./READ_ME' <<'END_OF_FILE'
Copyright:	1985, Stephen Frede, UNSW Australia
X	Use it and copy it as much as you want, but don't pretend you
X	wrote it, or sell it for profit.
X
Authorship:	Originally by Stephen Frede.
X		Various extensive changes by
X			Cameron Davidson and Michael Rourke.
X		GEM support added and reliability of PostScript output
X		improved by Axel Mahler and Andreas Lampen.
X		(axel@coma.uucp/andy@coma.uucp).
X
Contents:
X	0) File 'READ_ME', directories 'src', 'src/tpscript',
X		'src/opscript', 'src/pscript', 'man', 'devalw'
X
X	1) Source for a back end to ditroff which converts ditroff
X	   output to PostScript (src/tpscript).
X
X	2) Font code and width tables suitable for use with ditroff (devalw).
X
X	3) A program (lpscript) which converts plain text into postscript.
X	   various options allow selection of font, size and rotation, etc.
X
X	4) A program (ipscript) which converts bitmap images of various sorts
X	   into postscript.
X
X	5) Manual entries for lpscript and ipscript.
X
X	6) The directory src/pscript contains some random postscript
X	   programs that may or may not be useful.
X
X
NOTES:
X	The sources should be pretty much bug free. They have been run on
X	a few different systems, but I have no doubt that upon releasing it
X	to the world, some will come to light. Please mail suggestions
X	and fixes directly to me at the address given above.
X
X	The troff names for many of the characters were taken from a paper
X	about such things from:
X		"Adventures with Typesetter Independent Troff", by
X	Mark Kahrs and Lee Moore, Dept. Computer Science, University
X	of Rochester, Rochester, NY 14627. TR159; June, 1985.
X
X	Work is in progress to allow down-line loading of fonts other than
X	those available by default in the LaserWriter (or whatever), such
X	as the Berkeley fonts.
X
X	They have never been run on anything other than a LaserWriter, but
X	I don't know of any inherent machine dependencies (other than those
X	indicated by "#if ALW").
X
X	There are some further changes made by Cameron Davidson to fine tune
X	some problems with rounding to pixel boundaries on the LaserWriter
X	that are not included in this release.
X
X	There are two basica possible approaches to generating postscript
X	from some other format. The first is to generate a postscript
X	program which then reads input and does the conversion itself.
X	The alternative is to do as much of the translation as possible
X	first, generating relatively simple postscript commands. This
X	is the way these programs work. I have not seen Transcript, by
X	Adobe Systems, but I suspect they do it the first way.
X
X	Add an entry to the "magic" file that the file(1) command uses
X	to look for the characters "%!" at the start of a file.
X	This indicates that a file is "PostScript".
X
Installation:
X	First you must have ditroff, a device independant troff from ATT,
X	requiring a licence. This most usually comes with Documenter's
X	WorkBench (DWB). This should include the program "makedev", used
X	to "compile" the ascii font tables into binary, so that troff and
X	tpscript can read them.
X
X	Put all of this stuff into a directory somewhere.
X	Edit the Makefile in the top directory and set SYS= one of the
X	systems indicated there (AUSAM, V7, SYS5, BSD).
X	Then set VERBOSE=1 if you want some needless extra frills. This
X	is mainly just identifying jobs by username, etc.
X	Set MAKEDEV to be the pathname of the makedev program (in the
X	troff source directory ?).
X	Then compile it all by saying "make" in the top directory.
X	This should generate tpscript, ipscript and lpscript.
X	Install them manually in whatever way is appropriate for your system.
X	Possibly change the Makefiles to do this. Also note that the
X	Makefiles will not do anything smart about .o files or anything
X	like that.
X	We have installed the real troff in /bin/ditroff and made troff a
X	shell script that invokes the appropriate back end. The shell script
X	is included here as src/troff.sh, use it if you want.
X	Install the manual entries for ipscript and lpscript (from the man
X	directory).
X
Possible problems:
X	First read the problems section in "Inside LaserWriter".
X	Note the various patches from Adobe that have come over USENET.
X
X	On some versions of Unix, if the LaserWriter is connected to
X	a tty port, and a daemon of some sort continually sends stuff to
X	the LaserWriter, but never reads anything, and the LaserWriter
X	sends messages back (which aren't read by anyone), then when
X	the total number of unread characters reaches a certain amount
X	(TTYHOG, 256 or 512 usually), both the input AND output queues
X	are flushed, so some characters to the LaserWriter get dropped,
X	probably causing a syntax error and the rest of the job to be
X	flushed. A good thing to do (even if you don't have this problem)
X	is to collect all the output from that line and save it in a file.
X	This makes looking at error and other messages from the LaserWriter
X	quite easy (tail /tmp/laserout). On BSD machines one may e.g. add
X	a line "/usr/ucb/tail +0cf /dev/ttyLW > /usr/spool/lpd/lw/lw-log &"
X	to /etc/rc.local.
X
X	Note a bug in many versions of eqn(1) which causes a right large
X	square bracket to be made of '|' characters instead of "\(bv" chars.
X	If you have the source, this is easy to fix.
X
X	I don't know what some of the Berkeley ditroff output means.
X	If someone would like to fill me in, I'll add it to tpscript.
END_OF_FILE
if test 5305 -ne `wc -c <'./READ_ME'`; then
    echo shar: \"'./READ_ME'\" unpacked with wrong size!
fi
# end of './READ_ME'
fi
if test -f './man/ipscript.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./man/ipscript.1'\"
else
echo shar: Extracting \"'./man/ipscript.1'\" \(3990 characters\)
sed "s/^X//" >'./man/ipscript.1' <<'END_OF_FILE'
X.TH IPSCRIPT 1
X.SH NAME
ipscript \- convert bit image into postscript
X.SH SYNOPSIS
X.B ipscript
X[option] ... [file] ...
X.SH DESCRIPTION
X.I Ipscript
reads bit images from standard input (or files if specified) and produces
postscript output, suitable for sending to any postscript device (such
as an Apple Laserwriter) or for using with any program that expects
postscript input (such as a postscript interpreter used to drive some
other raster device).
In the output, grey levels are represented by a halftoning technique,
whereby a grid of halftone cells is produced from the input data.
The default frequency of halftone cells is 60 per inch, and an angle of 45 degrees.
X(Alterable using the
X.B \-f
and
X.B \-p
options.)
The following options are understood:
X.TP
X.B \-wWidth
The image produced will be the given width (in cm).
This may be a real number.
The default is 18 cm.
X.TP
X.B \-hHeight
The image will be produced with the given height (in cm).
This may be a real number.
The default is 12cm.
X.TP
X.B \-aAspect
The image will be produced with the given aspect ratio.
The default aspect ratio is 1.5 (width/height).
If both width and height are specified on the command line,
the aspect ratio will be determined from these, rather than
this argument.
X.TP
X.B \-bBits
This argument controls the output resolution (ie the number of grey
levels used).
It may be any of 1, 2, 4, or 8 for 2, 4, 16 or 256 output grey
levels respectively.
The default is 8 bits.
X.TP
X.B \-gGrey
This (signed integer) value can be used to offset the input grey level by
a fixed amount.
It can be used to brighten or darken images.
X.TP
X.B \-yScanlines
This value determines the number of pixels along the Y axis of
the input image.
This is the number of scanlines of the input.
The default is 256.
X.TP
X.B \-xScanlength
This value is the number of pixels along the X axis of the input image.
This is the length of an input scanline.
The default is 256.
X.TP
X.B \-fFrequency
This value determines the output frequency in halftone cells/inch.
The default is device dependant, but is 60 for the Apple LaserWriter.
X.TP
X.B \-pAngle
Specifies the angle (in degrees) at which the output halftone cell
grid is rotated.
The default is device dependant, but is 45 for the Apple LaserWriter.
X.TP
X.B \-iFormat
This argument specifies the input format and resolution.
It consists of a character ('b' or 'x') followed by a value.
The character specifies the form of the input: whether input data
is given in raw bytes or in hex notation.
The following value gives the input greyscale resolution - the number
of bits representing the image which may appear in the input.
If hex input format is being used and the greyscale resolution is
less than or equal to 4 bits, single hex bytes are read, otherwise pairs
of hex bytes are read to achieve a resolution of up to 8 bits.
The default is 'b8' - bytes with a possible value of from 0 to 255.
Input is scaled using this information and the number of output
grey levels (if necessary).
X.TP
X.B \-sSkip
Directs \fIipscript\fP to skip the given no. of bytes at the start
of the input file.
This is useful for files which have headers at the beginning.
XFor example, Macquarie Uni satellite photos have a 128 byte header.
X.TP
X.B \-r[angle]
This argument specifies an image rotation in degrees.
If '-r' is given with no value, 90 is assumed, which results in landscape
mode being used (long axis of paper horizontal).
The default is 0, which is portrait mode (long axis of paper vertical).
X.TP
X.B \-n
Print the negative of the image. That is, reverse black and white.
X.TP
X.B \-S
Use manual feed instead of feeding from the paper tray.
X.TP
X.B \-L
Print using legal page type - 17.8 by 31.8 cm (7 by 12.5 inches) imageable
region, centred
on a 21.6 by 35.6 cm (8.5 by 14 inch) page.
The default (letter) paper type uses a 20.3 by 26.7 cm (8 by 10.5 inch)
imageable region, centred on a 21.6 by 27.9 cm (8.5 by 11 inch) page.
X.SH SEE ALSO
ditroff(1)
X.SH AUTHOR
Stephen Frede, UNSW, Australia
END_OF_FILE
if test 3990 -ne `wc -c <'./man/ipscript.1'`; then
    echo shar: \"'./man/ipscript.1'\" unpacked with wrong size!
fi
# end of './man/ipscript.1'
fi
if test -f './man/lpscript.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./man/lpscript.1'\"
else
echo shar: Extracting \"'./man/lpscript.1'\" \(3778 characters\)
sed "s/^X//" >'./man/lpscript.1' <<'END_OF_FILE'
X.TH LPSCRIPT 1
X.SH NAME
lpscript \- convert text to postscript
X.SH SYNOPSIS
X.B lpscript
X[-o[offset]] [-r[rotation]] [-s[fontsize]] [-f[font]]
X[-p[pitch]] [-t[tabsize]] [-h[horizontal_spacing]] [-S] [-L] [file ...]
X.SH DESCRIPTION
X.I Lpscript
reads text from standard input (or files if specified) and produces
postscript output, suitable for sending to any postscript device (such
as an Apple Laserwriter) or for using with any program that expects
postscript input (such as a postscript interpreter used to drive some
other raster device).
Text is normally aligned at the top and left with the imageable region
of the page (probably slightly smaller than the physical page size),
and a new page is taken whenever text would fall below this imageable
region.
The following options are understood, with all values able to be given
as integer or real:
X.TP
X.B \-o[distance]
Offset the text from the left edge of the imageable region, by the given
distance (in centimeters).
If \fB-o\fP is specified without a distance, 1 cm is assumed.
X.TP
X.B \-r[angle]
Rotate the page by the given angle, specified in degrees.
If no angle is specified, 90 degrees is assumed.
Normally, the page will be printed in portrait mode, ie with the
long axis vertical.
This option allows printing in landscape mode
X(with the long axis horizontal).
Note that specifying an angle other than 0 or 90 will almost
certainly cause part of the text to fall outside the imageable region,
which serves you right for trying to be silly.
X.TP
X.B \-s[size]
Set the font size to the value given (in points) (72 points = 1 inch).
If a size is omitted, 12 is assumed.
The default point size without using this option is 10.
Specifying point sizes greater than 200 is probably silly and
certainly wastes toner.
X.TP
X.B \-t[tabsize]
Set the tab size to the value given (in characters).
If a value is omitted, 4 is assumed (the default is 8).
This option allows printing of program listings etc., to fit across
the page.
X.TP
X.B \-p[pitch]
Set the line spacing of printed text to this value.
Giving a value here will cause the line spacing to be set to that
value, in points (72 points = 1 inch).
If this argument is given without a value, double spacing is selected.
The default spacing is 0.
X.TP
X.B \-f[fontname]
Set the font used to the name given.
The default font is `Courier'.
If this argument is given without a fontname, `Times-Roman' is used.
The list of available fonts (for the Apple Laser-Writer) is: `Times-Roman'
X; `Times-Italic'
X; `Times-Bold'; `Times-BoldItalic'; `Courier'; `Courier-Oblique'
X; `Courier-Bold'; `Courier-BoldOblique'; `Helvetica'; `Helvetica-Bold'
X; `Helvetica-Oblique'; `Helvetica-BoldOblique'.
Note that only the Courier family is a fixed-width font; all the others
are variable width, and so program listings or columns of data will
not line up.
X.TP
X.B \-h[space]
Increase the horizontal spacing of characters by the given fraction of
the current font size.
XFor example, using `-h0.25' with a font size of 12 points in effect,
would cause an increase of horizontal spacing by 3 points.
By default, the characters are placed next to each other, using the
natural width of the characters.
Negative values (eg. -h-0.1) cause horizontal spacing to be decreased.
X.TP
X.B \-a[aspect-ratio]
Set the aspect ratio (height:width) of each character to the given value
X(default 1).
X.TP
X.B \-S
Use manual feed instead of feeding from the paper tray.
X.TP
X.B \-L
Print using legal page type - 17.8 by 31.8 cm (7 by 12.5 inches) imageable
region, centred
on a 21.6 by 35.6 cm (8.5 by 14 inch) page.
The default (letter) paper type uses a 20.3 by 26.7 cm (8 by 10.5 inch)
imageable region, centred on a 21.6 by 27.9 cm (8.5 by 11 inch) page.
X.SH SEE ALSO
ditroff(1)
X.SH AUTHOR
Stephen Frede, UNSW, Australia
END_OF_FILE
if test 3778 -ne `wc -c <'./man/lpscript.1'`; then
    echo shar: \"'./man/lpscript.1'\" unpacked with wrong size!
fi
# end of './man/lpscript.1'
fi
if test -f './pscript/demo.ps' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./pscript/demo.ps'\"
else
echo shar: Extracting \"'./pscript/demo.ps'\" \(4966 characters\)
sed "s/^X//" >'./pscript/demo.ps' <<'END_OF_FILE'
X%!
X% a demo of lots of nifty things you can do on a LaserWriter
X% - Stephen Frede
X
X(demo starting) print flush
X/cm { 28.3465 mul } def
X/ps { print flush } def
X
clippath pathbbox pop pop translate 10 10 translate
clippath pathbbox /pgtop exch def /pgright exch def pop pop
X
X
X% greyscale
X
X/width 1 cm def
X/step 0.5 cm def
X/greyscale {
X	/left exch def
X	0 step pgtop
X	{
X		/val exch def
X		val pgtop div setgray
X		newpath
X		% draw a box
X		left val moveto
X		width 0 rlineto
X		0 step rlineto
X		0 width sub 0 rlineto
X		closepath
X		fill
X	} for
X	0 setgray
X} def
X
X0 greyscale
X
X60 15 { dup mul exch dup mul add 1 exch sub } setscreen
X1.5 cm greyscale
X100 45 { dup mul exch dup mul add 1 exch sub } setscreen
X3 cm greyscale
X10 45 { dup mul exch dup mul add 1.0 exch sub } setscreen
X4.5 cm greyscale
X60 45 { dup mul exch dup mul add 1 exch sub } setscreen
X
X
X6 cm 0 translate
X
X% available fonts
X
X/x 1 cm def /y pgtop 1 cm sub def
X/s { show /y y 20 sub def } def
X/m { x y moveto } def
X/f { findfont 15 scalefont setfont } def
X/fm { f m } def
X/Times-Roman fm (Times Roman (R)) s
X/Times-Bold fm (Times Bold (B)) s
X/Times-Italic fm (Times Italic (I)) s
X/Times-BoldItalic fm (Times Bold Italic (BI)) s
X/Helvetica fm (Helvetica (H)) s
X/Helvetica-Bold fm (Helvetica Bold (HB)) s
X/Helvetica-Oblique fm (Helvetica Oblique (HO)) s
X/Helvetica-BoldOblique fm (Helvetica Bold Oblique (HX)) s
X/Courier fm (Courier (C)) s
X/Courier-Bold fm (Courier Bold (CB)) s
X/Courier-Oblique fm (Courier Oblique (CO)) s
X/Courier-BoldOblique fm (Courier Bold Oblique (CX)) s
X/Symbol fm (abcdefg ABCDEFG ) show /Times-Roman f ((S)) s
X
X% sizes
X
x 10 moveto
X/currfont /Helvetica findfont def
X/r { /txt exch def currfont exch scalefont setfont txt show } def
X
X3 (A) r
X4 (B) r
X6 (C) r
X8 (D) r
X10 (E) r
X15 (F) r
X20 (G) r
X30 (H) r
X50 (I) r
X70 (J) r
X
X% white on black
X
X20 0 rmoveto
currentpoint pop /x exch def
x 0 moveto
X0 80 rlineto x 0 rlineto 0 -80 rlineto closepath fill
X/currfont /Times-Bold findfont def
X1 setgray
x 10 moveto
X70 (K) r
X50 (L) r
X30 (M) r
X20 (N) r
X15 (O) r
X10 (P) r
X8 (Q) r
X6 (R) r
X4 (S) r
X3 (T) r
X
X0 setgray
X
X% shadow
X
X/shadow
X{
X	/text exch def
X	1 -0.1 -0.1
X	{
X		setgray -0.7 0.7 rmoveto
X		currentpoint text show moveto
X	} for
X	0 setgray
X} def
X
X/Times-Roman findfont 30 scalefont setfont
X7 cm 26 cm moveto
X(Shadow) shadow
X
gsave
X/Times-Italic findfont 30 scalefont setfont
X/printzip
X{ 0 0 moveto (Zip) show } def
X12 cm 26 cm translate
X.95 -.05 0 { setgray printzip -1 .5 translate} for
X1 setgray printzip
grestore
X
X% outline
X8 cm 25 cm moveto
X
X/makeoutlinedict 5 dict def
makeoutlinedict begin
X/basefontdict /Times-Roman findfont def
X/outfontdict basefontdict maxlength 1 add dict def
basefontdict
X{
X	exch dup /FID ne
X	{ exch outfontdict 3 1 roll put }
X	{ pop pop }
X	ifelse
X} forall
outfontdict /FontName /Times_Out put
outfontdict /PaintType 2 put
outfontdict /StrokeWidth 3 put
X/Times_Out outfontdict definefont pop end
X/Times_Out findfont 30 scalefont setfont
X
X(Outline) show
X
X% ellipse
X
X/ellipsedict 8 dict def ellipsedict /mtrx matrix put
X/ellipse {
X	ellipsedict begin
X	/yrad exch def /xrad exch def /y exch def /x exch def
X	/savematrix mtrx currentmatrix def
X	x y translate xrad yrad scale
X	newpath 0 0 1 0 360 arc
X	savematrix setmatrix
X	end
X} def
X
X% Star Lines
X
X/Times-BoldItalic findfont 27 scalefont setfont
X/rays {
X	0 1.5 179
X	{ gsave
X		rotate 0 0 moveto 108 0 lineto stroke grestore
X	} for
X} def
X
gsave
X10 cm 15 cm moveto
X(StarLines) true charpath clip
newpath 54 -15 translate rays
grestore
X
X% circle laser
X/Helvetica-Bold findfont 30 scalefont setfont
X/oshow	% stack: (string)
X{ true charpath stroke } def
X/circleofAdobe
X{
X	15 15 345
X	{
X		gsave rotate 0 0 moveto (Adobe) oshow grestore
X	} for
X} def
gsave
X4 cm 10 cm translate
X0.5 setlinewidth
circleofAdobe
X0 0 moveto (Adobe Systems) true charpath gsave 1 setgray fill grestore stroke
grestore
X
X% star lines
X/Times-BoldItalic findfont 2 cm scalefont setfont
X/rays
X  { 0 1.5 179
X    { gsave rotate 0 0 moveto 5 cm 0 lineto stroke grestore } for
X} def
gsave
X1 cm 3.5 cm translate
X.25 setlinewidth
newpath 0 0 moveto (StarLines) true charpath clip
newpath 3.9 cm -0.5 cm translate rays
grestore
X
X
X% pattern
X
X/bitison
X{
X	/ybit exch def /xbit exch def
X	bstring ybit bwidth mul
X	xbit 8 idiv add get
X	1 7 xbit 8 mod sub bitshift
X	and 0 ne
X} def
X
X/setpattern
X{
X	/freq exch def
X	/bwidth exch def
X	/bpside exch def
X	/bstring exch def
X	/onbits 0 def /offbits 0 def
X	freq 0 {
X		/y exch def /x exch def
X		/xindex x 1 add 2 div bpside mul cvi def
X		/yindex y 1 add 2 div bpside mul cvi def
X		xindex yindex bitison
X		{ /onbits onbits 1 add def 1 }
X		{ /offbits offbits 1 add def 0 }
X		ifelse
X		} setscreen
X	{} settransfer
X	offbits offbits onbits add div setgray
X} def
X
X<d1e3c5885c3e1d88> 8 1 300 32 div setpattern
X
X5 cm 15 cm 4 cm 1.5 cm ellipse fill
X
X<3e418080e3140808> 8 1 300 32 div setpattern
X
X12 cm 22 cm moveto 14 cm 1 cm -6 cm rlineto -2 cm 0 rlineto closepath fill
X
X3 { copypage } repeat erasepage
X
X(demo finished) print flush
X
X
X% ---- %
X
X??
END_OF_FILE
if test 4966 -ne `wc -c <'./pscript/demo.ps'`; then
    echo shar: \"'./pscript/demo.ps'\" unpacked with wrong size!
fi
# end of './pscript/demo.ps'
fi
if test -f './pscript/floor.ps' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./pscript/floor.ps'\"
else
echo shar: Extracting \"'./pscript/floor.ps'\" \(4398 characters\)
sed "s/^X//" >'./pscript/floor.ps' <<'END_OF_FILE'
X%!
X% Machine room floorplan at UNSW
X% 1 grid square is a floor tile on the false floor
X
X(floor starts\n) print flush
X/a4
X	[
X		[ 300 72 div 0 0 -300 72 div -72 3436 ]
X		292 3365
X		{statusdict /jobstate (printing) put 0 setblink
X		margins exch 142 add exch 256 add 8 div round cvi frametoroket
X		statusdict /jobstate (busy) put
X		1 setblink }
X		/framedevice load
X		60 45 {dup mul exch dup mul add 1.0 exch sub } /setscreen load
X		{} /settransfer load
X		/initgraphics load
X		/erasepage load
X	] cvx
statusdict begin bind end readonly def
X
a4
X
X/metre { 0.608 div } def
X/neg { 0 exch sub } def
X
clippath pathbbox pop pop translate newpath
clippath pathbbox newpath /ymax exch def /xmax exch def pop pop
X/xlen 14 def
X/ylen 30.5 def
X
ymax ylen 1 add div dup scale
X2 setlinecap
X0.01 setlinewidth
X/boxfill 0.99 def	% 0 for black, 1 for white, in-between for grey
X/textsize 0.2 def
X/x0 0.5 def /y0 0.5 def
X/xmax x0 xlen add def /ymax y0 ylen add def
X/Times-Roman findfont textsize scalefont setfont
X
X/xline { currentpoint xlen 0 rlineto stroke moveto } def
X/yline { currentpoint 0 ylen rlineto stroke moveto } def
X/doorwid 0.71 metre def
X
X/room
X{
X	% label x axis
X	1 1 14 {
X		/x exch def
X		x 0.05 sub 0.1 moveto x 2 string cvs show
X		x 0.05 sub ymax 0.2 add moveto x 2 string cvs show
X	} for
X	% label y axis
X	1 1 30 {
X		/y exch def
X		0.1 y 0.05 sub moveto y 2 string cvs show
X		xmax 0.2 add y 0.05 sub moveto y 2 string cvs show
X	} for
X	% doors
X	[ 0.1 0.1 ] 0 setdash
X	xmax 13.1 moveto currentpoint doorwid 90 180 arc closepath stroke
X	xmax 15.4 moveto currentpoint doorwid 180 270 arc closepath stroke
X	xmax 22.6 moveto currentpoint doorwid 0 90 arc closepath stroke
X	xmax 24.9 moveto currentpoint doorwid 270 360 arc closepath stroke
X	[ ] 0 setdash
X	% room boundary
X	0.5 2 moveto
X	5.6 2 lineto
X	5.6 0.5 lineto
X	xmax 0.5 lineto
X	xmax ymax lineto
X	1 ymax lineto 0 -0.5 rlineto -0.5 0 rlineto
X	x0 21.1 lineto 0.5 0 rlineto 0 -0.7 rlineto -0.5 0 rlineto
X	x0 12.3 lineto 0.5 0 rlineto 0 -2 rlineto -0.5 0 rlineto
X	closepath
X	gsave 0.1 setlinewidth stroke grestore
X	clip
X} def
X
X/grid
X{
X	gsave 0.01 setlinewidth
X	1 y0 moveto
X	14 { yline 1 0 rmoveto } repeat
X	x0 1 moveto
X	30 { xline 0 1 rmoveto } repeat
X} def
X
X% arguments to box: rotation xpos ypos xlen ylen name
X/box
X{
X	/name exch def
X	/y exch def
X	/x exch def
X	gsave
X	translate
X	rotate
X	newpath
X	0 0 moveto
X	x 0 lineto x y lineto 0 y lineto closepath
X	% comment out next line to avoid filling boxes
X	gsave boxfill setgray fill grestore % fill the box
X	stroke	% draw outline
X	name stringwidth y exch sub 2 div 0.05 sub /y exch def
X		x exch sub 2 div y moveto
X		name show
X	grestore
X} def
X
X/power1x10	% single 10-amp single phase
X{
X	/name exch def
X	/l 0.2 def
X	gsave translate
X	0 l moveto
X	0 0 moveto 0 l lineto l l lineto l 0 lineto closepath stroke
X} def
X
X% arguments to furniture are:
X% rotation xpos ypos
X% (rotation 0 == front facing window; pos is front left corner)
X/compactus { 5.3 1.5 (compactus) box } def
X/modem { 1 1 (modem) box } def
X/mss { 2 1 (MSS) box } def
X/poweroutlet { /n exch def 0.3 0.2 n box } def
X/vax750 { 1.3 1.3 (750) box } def
X/karri { 2.2 1.3 (karri) box } def
X/cdc { 1 1.5 (cdc) box } def
X/rp04 { 1.3 1.3 (rp04) box } def
X/elecvax { 5.3 1.3 (elecvax) box } def
X/rp06 { 1.3 1.3 (rp06) box } def
X/cheops { 1 1.8 (cheops) box } def
X/rackwidth 0.9 def
X/rackdepth 1.2 def
X/rack { rackwidth rackdepth } def
X/elec35 { rack (35) box } def
X/dsl { rack (dsl) box } def
X/rk07 { 0.9 1.2 (rk07) box } def
X/cadvax { 4.2 1.3 (cadvax) box } def
X/pdp { rackwidth 3 mul rackdepth 3 -1 roll box } def
X/elec70a { (70a) pdp } def
X/elec70b { (70b) pdp } def
X
X% fixed power conduits
X/fixedconduit
X{
X	6.09 30.1 moveto 10 { 0 -8 rlineto 0.09 8 rmoveto } repeat stroke
X} def
X
X/fixedoutlets
X{
X	0 4.3 16.3 (2) poweroutlet
X} def
X
room grid
X% fixed items
X0 1 30.7 2 0.3 (power) box
X-90 14.3 20.5 0.6 0.15 (telecom) box
X-90 14.3 10.2 0.6 0.15 (thermo) box
X0 9.5 29.6 modem
X0 11.5 30 mss
X90 2 3 compactus
X% fixedoutlets
X% movable items
X90 5 4 rp04 90 5 5.3 rp04
X90 5 7 cdc
X90 5 9.4 elecvax
X90 5 16.1 rp06 90 5 17.4 rp06 90 5 18.7 rp06
X90 5 21 cheops
X90 5 23.05 elec35
X90 5 25.05 dsl
X90 5 26 rk07 90 5 26.9 rk07 90 5 27.8 rk07 90 5 28.7 rk07
X0 6.4 27 rp06 0 7.7 27 rp06
X0 6.8 24 karri
X-90 11 27.6 rp06 -90 11 26.3 rp06
X-90 11 23.1 cadvax
X-90 11 18 cdc
X-90 11 17 rk07
X-90 11 12 elec70b
X-90 11 9.3 elec70a
X
X(floor finished\n) print flush
X4 { copypage } repeat
showpage
END_OF_FILE
if test 4398 -ne `wc -c <'./pscript/floor.ps'`; then
    echo shar: \"'./pscript/floor.ps'\" unpacked with wrong size!
fi
# end of './pscript/floor.ps'
fi
if test -f './tpscript/devalw/PB' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./tpscript/devalw/PB'\"
else
echo shar: Extracting \"'./tpscript/devalw/PB'\" \(2918 characters\)
sed "s/^X//" >'./tpscript/devalw/PB' <<'END_OF_FILE'
X# Palatino-Bold
name PB
internalname PalatinoB
ligatures fi fl ff ffi ffl 0
spacewidth 25
charset
X# 
X# not yet updated
X# 
X!	28	2	041
X"	37	2	042
X#	61	2	043
X$	50	3	044
X%	84	2	045
X&	78	2	046
X'	28	2	047
X(	33	3	050
X)	33	3	051
X*	39	2	052
X+	61	0	053
X,	25	1	054
X-	33	0	055
hy	"
X.	25	0	056
X/	61	2	057
sl	"
X0	50	2	060
X1	50	2	061
X2	50	2	062
X3	50	2	063
X4	50	2	064
X5	50	2	065
X6	50	2	066
X7	50	2	067
X8	50	2	070
X9	50	2	071
X:	25	0	072
X;	25	1	073
X<	61	0	074
X=	61	0	075
X>	61	0	076
X?	40	2	077
X@	75	3	0100
A	78	2	0101
B	61	2	0102
C	71	2	0103
D	77	2	0104
E	61	2	0105
XF	56	2	0106
G	76	2	0107
H	83	2	0110
I	34	2	0111
J	33	3	0112
K	73	2	0113
L	61	2	0114
M	95	2	0115
N	83	2	0116
O	79	2	0117
P	60	2	0120
Q	79	3	0121
R	67	2	0122
S	53	2	0123
T	61	2	0124
U	78	2	0125
V	72	2	0126
W	100	2	0127
XX	67	2	0130
Y	67	2	0131
Z	67	2	0132
X[	33	3	0133
X\	61	2	0134
X]	33	3	0135
a^	61	2	0136	asciicircum
X_	50	1	0137
ru	"
X`	28	2	0140
a	50	0	0141
b	55	2	0142
c	44	0	0143
d	61	2	0144
e	48	0	0145
f	33	2	0146
g	56	1	0147
h	58	2	0150
i	29	2	0151
j	23	3	0152
k	56	2	0153
l	29	2	0154
m	88	0	0155
n	58	0	0156
o	50	0	0157
p	60	1	0160
q	56	1	0161
r	40	0	0162
s	42	0	0163
t	33	2	0164
u	60	0	0165
v	57	0	0166
w	83	0	0167
x	52	0	0170
y	56	1	0171
z	50	0	0172
X{	33	3	0173
X|	60	3	0174
X}	33	3	0175
a~	60	0	0176	asciitilde
I!	28	3	0241	exclamdown
ct	50	3	0242	cent
po	50	2	0243	sterling
X$J	50	2	0245	yen
sc	50	3	0247	section
fm	21	2	0251	quotesingle
n'	"
lq	50	2	0252	quotedblleft
d<	50	0	0253	guillemotleft
l<	33	0	0254	guilsinglleft
r>	33	0	0255	guilsinglright
fi	61	2	0256	fi
fl	61	2	0257	fl
X\-	50	0	0261	endash
dg	50	3	0262	dagger
dd	50	3	0263	daggerdbl
pp	63	3	0266	paragraph
bu	61	0	0267	bullet
rq	50	2	0272	quotedblright
d>	50	0	0273	guillemotright
pm	114	2	0275	perthousand
I?	40	1	0277	questiondown
ga	33	2	0301	grave
X\`	"
aa	33	2	0302	acute
X\'	"
X^	33	2	0303	circumflex
X~	33	2	0304	tilde
ma	33	2	0305	macron
be	33	2	0306	breve
dt	25	2	0307	dotaccent
X..	33	2	0310	dieresis
um	"
ri	33	2	0312	ring
cd	33	1	0313	cedilla
X''	38	2	0315	hungarumlaut
og	31	1	0316	ogonek
hc	33	2	0317	caron
em	100	0	0320	emdash
a:	50	2	0321	adieresis
o:	50	2	0322	odieresis
u:	60	2	0323	udieresis
A:	77	2	0324	Adieresis
O:	79	2	0325	Odieresis
U:	78	2	0326	Udieresis
AE	94	2	0341	AE
PL	61	2	0350	Lslash
O/	83	3	0351	Oslash
OE	100	2	0352	OE
ae	76	0	0361	ae
ui	29	0	0365	dotlessi
Pl	29	2	0370	lslash
o/	56	3	0371	oslash
oe	83	0	0372	oe
ss	56	2	0373	germandbls
X# rest not modified
ff	61	2	0100	ff ligature - faked
XFi	84	2	0100	Fi ligature - faked
XFl	84	2	0100	Fl ligature - faked
X12	67	2	0100	1/2 faked - code is irrelevent
X13	67	2	0100	1/3 faked - code is irrelevent
X14	67	2	0100	1/4 faked - code is irrelevent
X18	67	2	0100	1/8 faked - code is irrelevent
X23	67	2	0100	2/3 faked - code is irrelevent
X34	67	2	0100	3/4 faked - code is irrelevent
X38	67	2	0100	3/8 faked - code is irrelevent
X58	67	2	0100	5/8 faked - code is irrelevent
X78	67	2	0100	7/8 faked - code is irrelevent
sq	100	3	0100	square box
X
END_OF_FILE
if test 2918 -ne `wc -c <'./tpscript/devalw/PB'`; then
    echo shar: \"'./tpscript/devalw/PB'\" unpacked with wrong size!
fi
# end of './tpscript/devalw/PB'
fi
if test -f './tpscript/hash.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./tpscript/hash.c'\"
else
echo shar: Extracting \"'./tpscript/hash.c'\" \(4821 characters\)
sed "s/^X//" >'./tpscript/hash.c' <<'END_OF_FILE'
X#include	"tpscript.h"
X#include	"hash.h"
X
X/*
X * the non-acsii character names are now hashed and the elements of the
X * hash structure also contain information about whether this particular
X * character can be directly printed where troff thinks it is going
X * or whether it needs special massaging or even contruction from other
X * characters.
X */
X
X
HASH_ELEMENT	*hash_free = NOHASH,	/* points to next available entry */
X		*hash_tab[HASH_SIZE];	/* starting entries */
X
hash_init()
X{
X	register	SPECIAL_NAME	*snp;
X	register	HASH_ELEMENT	*hep, **hpp;
X	register	int		i;
X	char				*s;
X
X	hash_free = (HASH_ELEMENT *)emalloc( ncharname * sizeof(HASH_ELEMENT));
X
X	for( i = 0 ; i < ncharname ; i++ ) {
X		s = &charname[ chartab[ i ] ];
X		hpp = & hash_tab[ hash_it(s) ];
X			/*
X			 * skip through the entries already with this hash value
X			 */
X		while( *hpp != NOHASH )
X			hpp = &( (*hpp)->hash_next );
X		*hpp = hep = hash_free++;
X		hep->hash_next = NOHASH;
X		hep->hash_index = i;
X		hep->hash_special = NOSPECIAL;	/* assume nothing special */
X			/*
X			 * now find if it is one of the special names
X			 */
X		for ( snp = &specnames[0] ; snp->troff_name != NULL ; snp++ ) {
X			if ( strcmp( s, snp->troff_name ) == 0 ) {
X				hep->hash_special = snp;
X				break;
X			}
X		}
X	}
X
X}
X
dumphash( n )
X	int n;
X{
X	register	int i;
X
X	if ( n >= 0 && n < HASH_SIZE )
X		dhsh( n );
X	else
X		for ( i = 0 ; i < HASH_SIZE ; i++ )
X			dhsh( i );
X}
X
dhsh( i )
X	int	i;
X{
X	register	HASH_ELEMENT *hep;
X
X	hep = hash_tab[i];
X	fprintf( stderr, "hashed at %d:\n\t", i );
X	while ( hep != NOHASH )
X	{
X		fprintf( stderr, "%s ",
X			&( charname[ chartab[ hep->hash_index ] ] ));
X		hep = hep->hash_next;
X	}
X	fprintf( stderr, "\n" );
X}
X
X	/*
X	 * hashing function
X	 */
hash_it( s )
X	register	char	*s;
X{
X	register	int	i;
X
X	i = 0;
X	while( *s )
X		i += *s++;
X	return( i % HASH_SIZE );
X}
X
X
putspec(specstr)
char	*specstr;
X{
X	register HASH_ELEMENT		*hep;
X	register int			i = 0,
X					n;
X	register struct fontdesc	*fd;
X
X	fd = tfp.fp_font;
X	for ( hep = hash_tab[ hash_it( specstr ) ] ; hep != NOHASH ; hep = hep->hash_next )
X	{
X		if ( strcmp ( specstr, &charname[ chartab[ hep->hash_index ] ] ) == 0 )
X			break;
X	}
X	if ( hep == NOHASH )
X	{
X		sprintf(errbuf, "special character '%s' unknown", specstr);
X		error(ERR_WARN, errbuf);
X		return;
X	}
X
X	i = hep->hash_index;
X	i += NASCPRINT;			/* skip ordinary chars */
X			/* check std font */
X	if((n = fd->f_fitab[i] & BMASK) != 0)
X		; 		/* ok - must be in current font */
X				/* otherwise check special font */
X	else if( (spcfnt1 != NOFONTDESC) && (n = spcfnt1->f_fitab[i] & BMASK) != 0)
X	{
X		fd = spcfnt1;
X	}
X				/* try the locally defined special font */
X	else if( (spcfnt2 != NOFONTDESC) && (n = spcfnt2->f_fitab[i] & BMASK) != 0)
X	{
X		fd = spcfnt2;
X	}
X	else
X	{
X		sprintf(errbuf,
X			"Special char '%s' not in current (%d) or special fonts\n",
X			specstr, currtfont);
X		error(ERR_WARN, errbuf);
X		return;
X	}
X	width_pending += GETWIDTH( fd, n );
X
X	if ( hep->hash_special != NOSPECIAL )
X	{
X		register	SPECIAL_NAME	*snp;
X
X		setfont( FALSE );	/* ensure size is setup */
X		CLOSEWORD();		/* may or may not have been done
X					** in setfont()
X					*/
X
X		snp = hep->hash_special;
X		if ( ( snp->sn_flags & SN_DEFINED ) == 0 )
X		{
X			snp->sn_flags |= SN_DEFINED;
X			fprintf( postr, "\n/C%s { %s } def\n",
X				snp->troff_name, snp->definition );
X			if ( snp->sn_flags & SN_ANY_MULTIPLE )
X				putmultdef( snp );
X#ifdef notdef
X			if ( snp->sn_flags & SN_FRACTION )
X				putfractdef( snp );
X			else if ( snp->sn_flags & SN_BRK_ROUNDING )
X				putbrackdef( snp );
X			else if ( snp->sn_flags & SN_BRACKET )
X				putbrackdef( snp );
X#endif
X		}
X		fprintf( postr, "\nC%s", snp->troff_name );
X		return;
X	}
X
X	if( fd != tfp.fp_font )
X	{
X		struct fontdesc	*font;
X
X		font = tfp.fp_font;
X		tfp.fp_font = fd;
X		putch(fd->f_codetab[n] & BMASK);
X		tfp.fp_font = font;
X	}
X	else
X	{
X		putch(fd->f_codetab[n] & BMASK );
X	}
X}
X
X	/*
X	 * setup definition used in more than one special char
X	 * - e.g. Cfrac used for \(12, \(14 etc
X	 * first time through we scan through the special names list for
X	 * a definition of the pseudo-name "fraction" which is used for the
X	 * others
X	 */
putmultdef( snp )
X	register	SPECIAL_NAME *snp;
X{
X	register	SPECIAL_NAME *mnp;
X	register	int	type;
X
X
X	type = snp->sn_flags & SN_ANY_MULTIPLE;
X
X	for ( mnp = &multdefs[0] ; mnp->troff_name != (char *)0 ; mnp++ ) {
X		if ( type == (mnp->sn_flags & SN_ANY_MULTIPLE ) )
X		{
X			if ( ( mnp->sn_flags & SN_DEFINED ) == 0 )
X			{
X				fprintf( postr, "\n/C%s{%s}def",
X						mnp->troff_name, mnp->definition);
X				mnp->sn_flags |= SN_DEFINED;
X			}
X			break;
X		}
X	}
X}
X
X
resetspcl()
X{
X	register	SPECIAL_NAME	*snp;
X
X	for ( snp = &specnames[0] ; snp->troff_name != (char *)0 ; snp++ )
X		snp->sn_flags &= ~SN_DEFINED;
X	for ( snp = &multdefs[0] ; snp->troff_name != (char *)0 ; snp++ )
X		snp->sn_flags &= ~SN_DEFINED;
X}
END_OF_FILE
if test 4821 -ne `wc -c <'./tpscript/hash.c'`; then
    echo shar: \"'./tpscript/hash.c'\" unpacked with wrong size!
fi
# end of './tpscript/hash.c'
fi
if test -f './tpscript/sfont2defs.H' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./tpscript/sfont2defs.H'\"
else
echo shar: Extracting \"'./tpscript/sfont2defs.H'\" \(3557 characters\)
sed "s/^X//" >'./tpscript/sfont2defs.H' <<'END_OF_FILE'
X#	sfont2defs.H
X#	source file for definitions of special characters in the second
X#	locally-defined special font
X#	this file is processed by sed to produce sfont2defs.h
X#	syntax is:
X#	troff-name <white-space> { definition including optional comments
X#		terminated by "}" on a line of its own
X#		white space is minimised on output
X#	anything following `#' is ignored
X#	a line commencing with `#' is deleted
X#	as are blank lines
X#	note `\` should be escaped as "\\"
X
X
X#	The bracket end pieces just load the stack with values which are then
X#	used by the common procedure C.brk.end which does a
X#	moveto rlineto rcurveto (then back to the start and across by 60)
X#		rlineto rcurveto fill
X#	This is only done to save the output file size and to make it
X#	more confusing to interpret what is going on.
X#	Remember the stack is loaded last in first out
X
lt	{
X	0 150	   50 210	140 250		# inside rcurve to just below tip
X	0 730
X	0 150	   50 250	200 250		# outside rcurve to tip
X	0 750				# rline up
X	220 -250			# starting point
X	C.brk.end
X}
X
lb	{
X	0 -150	   50 -210	140 -250	# inside rcurve to just below tip
X	0 -730
X	0 -150	   50 -250	200 -250	# outside rcurve to tip
X	0 -750				# rline up
X	220 750			# starting point
X	C.brk.end
X}
X
lk	{
X	1 setlinewidth
X	220 -250 moveto
X	0 400 rlineto
X	0 50    -50 100     -100 100  rcurveto
X	50 0     100 50       100 100  rcurveto
X	0 400 rlineto
X	60 0 rlineto
X	0 -400 rlineto
X	0 -50    -50 -100     -100 -100  rcurveto
X	50 0     100 -50       100 -100  rcurveto
X	0 -400 rlineto
X	closepath fill
X}
X
rt	{
X	0 150	   -50 250	-200 250	# outside rcurve to tip
X	0 750				# rline up
X	0 150	   -50 210	-140 250	# inside rcurve to just below tip
X	0 730
X	220 -250			# starting point
X	C.brk.end
X}
X
rb	{
X	0 -150	   -50 -250	-200 -250	# outside rcurve to tip
X	0 -750				# rline up
X	0 -150	   -50 -210	-140 -250	# inside rcurve to just below tip
X	0 -730
X	220 750			# starting point
X	C.brk.end
X}
X
rk	{
X	1 setlinewidth
X	220 -250 moveto
X	0 400 rlineto
X	0 50    50 100       100 100  rcurveto
X	-50 0     -100 50     -100 100  rcurveto
X	0 400 rlineto
X	60 0 rlineto
X	0 -400 rlineto
X	0 -50    50 -100       100 -100  rcurveto
X	-50 0     -100 -50     -100 -100  rcurveto
X	0 -400 rlineto
X	fill
X}
X
X
X#		the floor and ceiling bracket parts are made up with two
X#		procedures defined within the context of the font:
X#			C.bv	which draws the bold vertical
X#			C.barc	which adds the horizontal piece to the ceiling;
X#				the X coord on the stack should be set to the
X#				left edge of where the bar is to be put
X#			C.barf	likewise for floor
X
lc	{
X	C.bv				# draw the bv part
X	280 				# move to bottom right edge of vert bar
X	C.barc				# and draw in horizontal bar
X}
X
lf	{
X	C.bv 280 C.barf
X}
X
rc	{
X	C.bv 40 C.barc
X}
X
rf	{
X	C.bv 40 C.barf
X}
X
br	{
X	40 C.setl
X	0 -250 moveto
X	0 1000 rlineto
X	stroke
X}
X
rn	{
X	40 C.setl
X	0 895 moveto
X	500 0 rlineto
X	stroke
X}
X
ci	{
X	40 C.setl
X	500 250 				# centre
X	400					# radius
X	0 360 arc				# draw circle
X	stroke
X}
X
sp_6	{		# 1/6 em narrow space
X			# do nothing, the width is all that is needed
X}
X
sp_12	{		# 1/12 em narrow space
X			# null op
X}
X
r1	{		# reversible chemical reaction
X	40 C.setl
X	0 setlinejoin
X	700 180 moveto -650 currentlinewidth add 0 rlineto 200 -200 rlineto
X	50 360 moveto 650 currentlinewidth sub 0 rlineto -200 200 rlineto
X	stroke
X}
X
r2	{		# reversible reaction with full arrowheads
X	40 C.setl
X	2 setlinejoin
X	217 18 moveto
X					# left arrowhead
X	-150 150 rlineto 150 150 rlineto -150 -150 rlineto
X	633 0 rlineto
X	50 360 moveto
X	633 0 rlineto
X	-150 150 rlineto 150 -150 rlineto -150 -150 rlineto
X	stroke
X}
END_OF_FILE
if test 3557 -ne `wc -c <'./tpscript/sfont2defs.H'`; then
    echo shar: \"'./tpscript/sfont2defs.H'\" unpacked with wrong size!
fi
# end of './tpscript/sfont2defs.H'
fi
if test -f './tpscript/spline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./tpscript/spline.c'\"
else
echo shar: Extracting \"'./tpscript/spline.c'\" \(5159 characters\)
sed "s/^X//" >'./tpscript/spline.c' <<'END_OF_FILE'
X/*
X * spline.c
X * routine for converting troff's idea of splines into
X * the form that the postscript device can easily construct.
X * This means that the actual curves are not precisely those that would
X * be drawn on an other machine, but at least they fit the general
X * description and intention (see Pic manual, section 8).
X * The technique used here takes the starting point, the mid-points
X * of all intermediate lines, and the end point and uses these to construct
X * bezier spline fragments
X * If there are only two defining lines, i.e. two coordinate pairs, we have the
X * minimun requirements and use rcurveto from currentpoint to endpoint with
X * interpolation of the two midpoints of the lines as postcript's control
X * points.
X * With more than this we use several rcurveto instructions; the first and last
X * go from each end to the midpoint of the line second from each end, using
X * the midpoint and other end of the respective end lines as control points.
X * All other segments go from one midpoint to the next using the point where
X * the lines join for both control points
X *
X * It should be possible to get closer approximation by suitably chosing
X * control points at some other fraction of the way along the line,
X * rather than just taking mid- and endpoints. For example, the end
X * sections of multiple curves are not actually tangent at the mid-point
X * at the moment and are a bit lopsided.
X *
X */
X
X#include	"tpscript.h"
X
X#include	<ctype.h>
X
X#define		MAXLINE		512		/* max len of D~ input line */
X#define		MAXCOORD	50		/* max num x,y pairs */
X
X		/*
X		 * coordinates of each defining point in units, relative
X		 * to the starting point
X		 * the rounding errors are not cumulative so I don't think
X		 * it needs to be floating point
X		 */
typedef	struct	{
X	int	x,
X		y;
X} COORD;
X
static	char	splineformat[] = "\n%d %d %d %d %d %d spln";
X
draw_spline( istr )
X	FILE	*istr;
X{
X	register	int	nnums;
X	register	char	*s;
X	register	COORD	*cp;
X	char	buf[MAXLINE];
X	COORD	coord[MAXCOORD],
X		current,
X		next;
X
X	fgets(buf, MAXLINE, istr);
X	s = buf;
X	cp = &coord[0];
X		/*
X		 * scan the input line for an indeterminate number of dx,dy
X		 * pairs - some compilers cark if given sscanf with lots of
X		 * args
X		 */
X	for( ; s < &buf[MAXLINE] && cp < &coord[MAXCOORD] ; cp++ )
X	{
X		while ( isspace( *s ) )
X			s++;
X		if ( *s == '\0' )
X			break;		/* done */
X		cp->x = atoi( s );
X		while ( ! isspace( *s ) )
X			s++;
X		while ( isspace( *s ) )
X			s++;
X		if ( *s == '\0' )
X			break;		/* done */
X		cp->y = atoi( s );
X		while ( ! isspace( *s ) )
X			s++;
X	}
X	nnums = cp - &coord[0];
X		/*
X		 * now we go through and change all coordinate references to
X		 * be relative to the starting point, rather than relative to
X		 * each previous point - this assists conversion to postscript
X		 * where each coordinate to an rcurveto is relative to the
X		 * starting point (of each rcurveto)
X		 * There is a bug in pic which only returns negatively
X		 * one unit less than it went forward - this may lead to
X		 * accumulating errors in a hideously complicated spline
X		 * I dont want to *fix* pic in case that is only a fix(ughh)
X		 * for a bug elsewhere
X		 */
X	for ( cp = &coord[1] ; cp < &coord[nnums] ; cp++ )
X	{
X		if ( cp->x < 0 )
X			cp->x--;
X		cp->x += cp[-1].x;
X		if ( cp->y < 0 )
X			cp->y--;
X		cp->y += cp[-1].y;
X	}
X
X#ifdef	debug
X	fprintf( stderr, "spline with %d coords to ", nnums );
X	for ( cp = &coord[0] ; cp < &coord[nnums] ; cp++ )
X		fprintf( stderr, "%d %d, ", cp->x, cp->y );
X	putc( '\n', stderr);
X#endif
X
X	current.x = 0;
X	current.y = 0;
X		/*
X		 * note: the starting point is always relative 0,0, and coord[0]
X		 * is the other end of the first line
X		 */
X	cp = &coord[0];
X	if ( nnums < 2 )
X	{
X		error( ERR_WARN, "Too few points in spline" );
X		return;
X	}
X	if ( nnums == 2 )
X	{
X			/*
X			 * remember: the positive y direction in troff is
X			 * negative in postscript
X			 */
X		fprintf
X		(
X			postr, splineformat,
X			cp->x/2, -(cp->y/2),
X			(cp->x + coord[1].x)/2, -(cp->y + coord[1].y)/2,
X			coord[1].x, -(coord[1].y)
X		);
X		return;
X	}
X		/*
X		 * next current point will be middle of second line
X		 */
X	current.x = (cp->x + coord[1].x) / 2;
X	current.y = (cp->y + coord[1].y) / 2;
X	fprintf
X	(
X		postr, splineformat,
X		cp->x/2, -(cp->y/2),
X		cp->x, -(cp->y),
X		current.x, -current.y
X	);
X	cp++;
X	while( --nnums > 2 )
X	{
X			/*
X			 * this defines the end of this curve section and the
X			 * start of the following section ( relative to
X			 * the starting point)
X			 */
X		next.x = (cp->x + cp[1].x) / 2;
X		next.y = (cp->y + cp[1].y) / 2;
X			/*
X			 * note that each rcurveto must be done relative to
X			 * the new currentpoint, thus the input relative
X			 * values need to be adjusted
X			 */
X		fprintf
X		(
X			postr, splineformat,
X			cp->x - current.x, current.y - cp->y,
X			cp->x - current.x, current.y - cp->y,
X			next.x - current.x, current.y - next.y
X		);
X		cp++;
X		current = next;		/* set new current point */
X	}
X
X		/*
X		 * finally we draw the last section
X		 */
X	fprintf
X	(
X		postr, splineformat,
X		cp->x - current.x, current.y - cp->y,
X		(cp->x + cp[1].x)/2 - current.x,
X		current.y - (cp->y + cp[1].y)/2,
X		cp[1].x - current.x, current.y - cp[1].y
X	);
X	return;
X}
X
END_OF_FILE
if test 5159 -ne `wc -c <'./tpscript/spline.c'`; then
    echo shar: \"'./tpscript/spline.c'\" unpacked with wrong size!
fi
# end of './tpscript/spline.c'
fi
if test -f './tpscript/tpscript.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./tpscript/tpscript.h'\"
else
echo shar: Extracting \"'./tpscript/tpscript.h'\" \(3837 characters\)
sed "s/^X//" >'./tpscript/tpscript.h' <<'END_OF_FILE'
X/*
X *	tpscript.h
X *	header definitions for tpscript.c:
X *		Troff post-processor for postscript devices
X */
X
X#include	<stdio.h>
X#include	"dev.h"
X#include	"pscript.h"
X
X#define	ERR_WARN	1	/* an input error - continue processing */
X#define	ERR_FATAL	2	/* an input error - abort processing */
X#define	ERR_SNARK	3	/* a program error - abort processing */
X#define	UNDEFINED	-1
X
X#define	BMASK		0xFF	/* low order byte */
X
X#define	NASCII		128	/* no. ascii characters */
X#define	NUNPRINT	32	/* no. unprintable characters */
X#define	NASCPRINT	(NASCII-NUNPRINT)	/* no. printable ascii chars */
X#define	MAXCHARS	255	/* max no. character codes */
X
X#define	DEF_FONT	1	/* default initial font */
X#define DEF_SIZE	10	/* default initial point size */
X#define	DEF_DEV		"alw"	/* default device - apple laser-writer */
X
extern int	errno;
extern char	*sys_errlist[];
X
extern	FILE	*Debug ;
extern	char	*ifile;		/* current input file name */
extern	int	lineno,			/* line no. in current input file */
X	npages;			/* no. pages printed so far */
extern	char	device[100],
X	errbuf[100];		/* tmp buffer for error messages */
extern	int
X	hpos,		/* current horizontal position */
X	vpos;		/* current vertical position (rel. TOP pg.) */
extern	int	
X	res,		/* resolution in THINGS/inch */
X	hor_res,		/* min horizontal movement (in THINGS) */
X	vert_res,		/* min vertical movement (in THINGS) */
X	respunits;
float 	rotation;		/* page orientation (degrees) */
extern	int	currtfont,	/* current font number selected by troff */
X	papertype; 		/* paper type (different imageable regions) */
X
X/* font parameters */
struct	fontparam {
X	int	fp_size;	/* character point size */
X	float	fp_height,	/* character height (points) */
X		fp_slant;	/* character slant (degrees) */
X	struct fontdesc *
X		fp_font;	/* font style */
X};
extern	struct	fontparam
X	tfp,		/* current troff font parameters */
X	pfp;		/* current postscript font parameters */
X
X#define	NOFONTDESC	((struct fontdesc *)NULL )
X
X/* table of font descriptions */
struct fontdesc {
X	char	*f_intname;	/* postscript name */
X	char	*f_extname;	/* troff name */
X	int	f_nent;		/* no. entries for this font */
X	char	*f_widthtab;	/* character width tables */
X	char	*f_codetab;	/* code table for this font */
X	char	*f_fitab;	/* font index for this font */
X	bool	f_mounted;	/* whether font is mounted or not */
X};
X
extern struct fontdesc	*fontd,
X			*spcfnt1,	/* special font */
X			*spcfnt2;	/* special font 2 */
X
X/* font mount table - array of pointers to font descriptions */
extern	struct fontdesc	**fontmount;
X
X/* mapping between troff font names and builtin font names
X * This should go in the internal name part of the font description
X * itself, but there is only 10 bytes allocated (see dev.h).
X */
struct fontmap {
X	char	*fm_extname;	/* Troff font name */
X	char	*fm_intname;	/* Postscript font name */
X};
extern	struct	fontmap fontmap[];
X
X#define	NFONT	(sizeof(fontmap)/sizeof(fontmap[0]))
X
extern	struct dev	dev;
X
extern	short	*chartab;	/* char's index in charname array */
extern	char	*charname;	/* special character names */
extern	int	ncharname;		/* no. special character names */
extern	int	nfonts;		/* no. of fonts mounted */
extern	int	nfontmount;		/* no. of font mount positions */
X
X
X#define	GETWIDTH(fdp, index)	\
X  ((tfp.fp_size * ((fdp)->f_widthtab[ (index) ] & BMASK) + (respunits>>1)) / respunits)
X
X	/*
X	 * this is the width that the printer will have moved following
X	 * the last printed character, if troff then says to move a
X	 * different amount we will shift the difference
X	 */
extern	int	width_pending;
X
extern	bool	word_started;	/* we are in middle of word string */
X
X#define	CLOSEWORD()	{if ( word_started == TRUE ) {	\
X				fputs( ")s", postr );	\
X				word_started = FALSE;	\
X				}			\
X			}
X
X
extern	int		strcmp();
extern	char		*emalloc();
extern	struct fontdesc *findfont();
extern	struct fontmap	*getfmap();
X
END_OF_FILE
if test 3837 -ne `wc -c <'./tpscript/tpscript.h'`; then
    echo shar: \"'./tpscript/tpscript.h'\" unpacked with wrong size!
fi
# end of './tpscript/tpscript.h'
fi
echo shar: End of archive 3 \(of 5\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
