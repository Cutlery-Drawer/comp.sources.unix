Subject:  v15i075:  A bitmap editor for suns, Patch1
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Raymond T Kreisel <rayk@sbcs.sunysb.edu>
Posting-number: Volume 15, Issue 75
Archive-name: touchup/patch1
 
 Here are the patches that will move Touchup, a bitmap editor for
 Sun workstations, from version 2.2 to version 2.3. The new version
 includes a few new commands, bug fixes and most of the old commands
 now run faster. The patches consist of two shar files. 
 

                                        ray


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  DIFFS.1 README_UPDATE
# Wrapped by rayk@sbmiclr on Fri Jun 17 00:31:54 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f DIFFS.1 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"DIFFS.1\"
else
echo shar: Extracting \"DIFFS.1\" \(57931 characters\)
sed "s/^X//" >DIFFS.1 <<'END_OF_DIFFS.1'
Xdiff -c ./interface.c ../../Ver2.3/source/interface.c
X*** ./interface.c	Mon Jun 13 23:53:36 1988
X--- ../../Ver2.3/source/interface.c	Fri Jun 17 00:27:22 1988
X***************
X*** 29,65 ****
X  		date:	Tue Mar 22 22:04:58 EST 1988
X  		author:	rayk
X  		changes:add comments
X  **************************************************************************/
X  
X  #include"header.h"
X! 
X! 
X  Cursor fat_cursor;
X  
X- 
X  static short icon_data[] = {
X  #include "touchup.icon"
X  };
X  static mpr_static(touchup_pr, 64, 64, 1, icon_data);
X  
X- static short cursor_data[] = {
X- #include "fat_cursor"
X- };
X- static mpr_static(my_fat_cursor, 16, 16, 1, cursor_data);
X  
X! 
X! 
X!     Frame base_frame,fat_frame,color_frame,command_frame;
X      Canvas canvas,fat_canvas,color_canvas;
X      Pixwin *pw,*fat_pw,*color_pw;
X- static Scrollbar	vertical_sb, horizontal_sb;
X      Panel       panel,fat_panel,color_panel,pattern_panel,
X  		brush_panel,region_panel,command_panel;
X!     Panel_item magnify_cycle,grid_cycle,view_cycle;
X      Panel_item  file_panel,brush_choice,mono_cycle,save_cycle,border_cycle,
X  		msg_string,color_button,text_panel,current_pattern,
X  		load_cycle,pattern_choice,command_choice,region_choice,
X! 		compress_cycle,text_size_item,undo_button;
X  
X     struct pixrect *pattern[PATTERN_NO];
X     struct pixrect *brushes[BRUSH_NO];
X--- 29,65 ----
X  		date:	Tue Mar 22 22:04:58 EST 1988
X  		author:	rayk
X  		changes:add comments
X+ 
X+ 		date:	Fri Apr 15 01:18:05 EDT 1988
X+ 		author:	rayk
X+ 		changes:added scroll by line to drawing area
X  **************************************************************************/
X  
X  #include"header.h"
X! extern void yes_no();
X  Cursor fat_cursor;
X  
X  static short icon_data[] = {
X  #include "touchup.icon"
X  };
X  static mpr_static(touchup_pr, 64, 64, 1, icon_data);
X  
X  
X!     Frame base_frame,fat_frame,color_frame;
X!     Frame confirmer;
X      Canvas canvas,fat_canvas,color_canvas;
X      Pixwin *pw,*fat_pw,*color_pw;
X      Panel       panel,fat_panel,color_panel,pattern_panel,
X  		brush_panel,region_panel,command_panel;
X!     Panel_item magnify_cycle,grid_cycle,view_cycle,ROP_cycle;
X      Panel_item  file_panel,brush_choice,mono_cycle,save_cycle,border_cycle,
X  		msg_string,color_button,text_panel,current_pattern,
X  		load_cycle,pattern_choice,command_choice,region_choice,
X! 		compress_cycle,text_size_item,undo_button,width_text,
X! 		height_text,resize_button,yes_button,no_button,
X! 		lasso_remove;
X!    Panel	con_panel;
X!    Panel_item con_msg_string;
X  
X     struct pixrect *pattern[PATTERN_NO];
X     struct pixrect *brushes[BRUSH_NO];
X***************
X*** 68,104 ****
X  /*
X   * Build all of the window that we need for touchup
X   */
X! init_windows(argc,argv) int argc; char *argv[];
X  {
X  
X      base_frame = window_create(NULL,FRAME,
X! 		FRAME_ARGS,	argc,argv,
X! 		FRAME_LABEL,    "TouchUp version 2.2",
X  		FRAME_ICON,	    icon_create(ICON_IMAGE, &touchup_pr, 0),
X  		FRAME_INHERIT_COLORS,  TRUE,
X  		WIN_FONT,	main_font,
X  		WIN_WIDTH,	1030,
X! 		WIN_HEIGHT,	675+ATTR_ROW(10),
X  		WIN_X,		10,
X  		WIN_Y,		10,
X  		0);
X      panel = window_create(base_frame, PANEL,
X  	     PANEL_LABEL_BOLD,    	 TRUE,
X  	     WIN_FONT,		 	 main_font,
X  	     WIN_X,			 0,
X  	     WIN_Y,			 3,
X! 	     WIN_HEIGHT,		 ATTR_ROW(5),
X  		0);
X  
X  
X- 
X-     vertical_sb = scrollbar_create((char*)0);
X-     horizontal_sb = scrollbar_create((char*)0);
X- 
X      canvas = 
X          window_create(base_frame, CANVAS, 
X! 	    WIN_VERTICAL_SCROLLBAR,	vertical_sb,
X! 	    WIN_HORIZONTAL_SCROLLBAR,	horizontal_sb,
X  	    WIN_CONSUME_PICK_EVENTS,	WIN_NO_EVENTS,WIN_MOUSE_BUTTONS,
X  					LOC_DRAG,
X  					LOC_MOVE, 
X--- 68,104 ----
X  /*
X   * Build all of the window that we need for touchup
X   */
X! init_windows(argcp,argvp) int *argcp; char **argvp;
X  {
X  
X      base_frame = window_create(NULL,FRAME,
X! 		FRAME_LABEL,    "TouchUp version 2.3",
X  		FRAME_ICON,	    icon_create(ICON_IMAGE, &touchup_pr, 0),
X+ 		FRAME_ARGC_PTR_ARGV,	argcp,argvp,
X  		FRAME_INHERIT_COLORS,  TRUE,
X  		WIN_FONT,	main_font,
X  		WIN_WIDTH,	1030,
X! 		WIN_HEIGHT,	675+ATTR_ROW(11),
X  		WIN_X,		10,
X  		WIN_Y,		10,
X  		0);
X+ 
X      panel = window_create(base_frame, PANEL,
X+ /*	     WIN_VERTICAL_SCROLLBAR,     scrollbar_create(SCROLL_LINE_HEIGHT,20,0), */
X  	     PANEL_LABEL_BOLD,    	 TRUE,
X  	     WIN_FONT,		 	 main_font,
X  	     WIN_X,			 0,
X  	     WIN_Y,			 3,
X! /*	     PANEL_PAINT,		 PANEL_NO_CLEAR, */
X! 	     WIN_HEIGHT,		 ATTR_ROW(6),
X!  	     PANEL_HEIGHT,		 ATTR_ROW(11),
X  		0);
X  
X  
X      canvas = 
X          window_create(base_frame, CANVAS, 
X! 	    WIN_VERTICAL_SCROLLBAR,	scrollbar_create(SCROLL_LINE_HEIGHT,20,0),
X! 	    WIN_HORIZONTAL_SCROLLBAR,	scrollbar_create(SCROLL_LINE_HEIGHT,20,0),
X  	    WIN_CONSUME_PICK_EVENTS,	WIN_NO_EVENTS,WIN_MOUSE_BUTTONS,
X  					LOC_DRAG,
X  					LOC_MOVE, 
X***************
X*** 107,117 ****
X  	    WIN_WIDTH,			780,
X  /*	    WIN_HEIGHT,		 	650, */
X  	    WIN_X,			PATTERN_SIZE*2+70,
X! 	    WIN_Y,			ATTR_ROW(7)+12,
X  	    CANVAS_AUTO_SHRINK,		FALSE,
X  	    CANVAS_AUTO_EXPAND,		FALSE,
X  	    CANVAS_FIXED_IMAGE,		FALSE,
X! 	    CANVAS_RETAINED,		TRUE,
X  	    CANVAS_WIDTH,		image_wid,
X  	    CANVAS_HEIGHT,		image_hgt,
X  	    WIN_BELOW,			panel,
X--- 107,117 ----
X  	    WIN_WIDTH,			780,
X  /*	    WIN_HEIGHT,		 	650, */
X  	    WIN_X,			PATTERN_SIZE*2+70,
X! 	    WIN_Y,			ATTR_ROW(8)+12,
X  	    CANVAS_AUTO_SHRINK,		FALSE,
X  	    CANVAS_AUTO_EXPAND,		FALSE,
X  	    CANVAS_FIXED_IMAGE,		FALSE,
X! 	    CANVAS_RETAINED,		FALSE,
X  	    CANVAS_WIDTH,		image_wid,
X  	    CANVAS_HEIGHT,		image_hgt,
X  	    WIN_BELOW,			panel,
X***************
X*** 124,131 ****
X      command_panel = window_create(base_frame, PANEL,
X  	     WIN_FONT,			main_font,
X  /*	     WIN_X,			 1000-(COMMAND_SIZE*2+32), */
X! 	     WIN_Y,			 ATTR_ROW(6)+12,
X  	     WIN_WIDTH,			 COMMAND_SIZE*2+5,
X  	     WIN_HEIGHT,		 COMMAND_SIZE*COMMAND_NO/2+9,
X  	     WIN_RIGHT_OF,		 canvas,
X  	     WIN_BELOW,			 panel,
X--- 124,132 ----
X      command_panel = window_create(base_frame, PANEL,
X  	     WIN_FONT,			main_font,
X  /*	     WIN_X,			 1000-(COMMAND_SIZE*2+32), */
X! 	     WIN_Y,			 ATTR_ROW(7)+12,
X  	     WIN_WIDTH,			 COMMAND_SIZE*2+5,
X+ 
X  	     WIN_HEIGHT,		 COMMAND_SIZE*COMMAND_NO/2+9,
X  	     WIN_RIGHT_OF,		 canvas,
X  	     WIN_BELOW,			 panel,
X***************
X*** 171,177 ****
X  	     WIN_FONT,			main_font,
X  	     WIN_SHOW,			TRUE,
X  	     WIN_X,			 1000-(COMMAND_SIZE*2+32),
X! 	     WIN_Y,			 COMMAND_SIZE*COMMAND_NO/2+9+ATTR_ROW(6)+14,
X  	     WIN_WIDTH,			 COMMAND_SIZE*2+5,
X  /*	     WIN_HEIGHT,		 COMMAND_SIZE*4+15, */
X  	     WIN_BELOW,			 command_panel,
X--- 172,178 ----
X  	     WIN_FONT,			main_font,
X  	     WIN_SHOW,			TRUE,
X  	     WIN_X,			 1000-(COMMAND_SIZE*2+32),
X! 	     WIN_Y,			 COMMAND_SIZE*COMMAND_NO/2+9+ATTR_ROW(7)+14,
X  	     WIN_WIDTH,			 COMMAND_SIZE*2+5,
X  /*	     WIN_HEIGHT,		 COMMAND_SIZE*4+15, */
X  	     WIN_BELOW,			 command_panel,
X***************
X*** 223,229 ****
X  	     WIN_FONT,			main_font,
X  	     WIN_SHOW,			FALSE,
X  	     WIN_X,			 1000-(COMMAND_SIZE*2+32),
X! 	     WIN_Y,			 COMMAND_SIZE*COMMAND_NO/2+9+ATTR_ROW(6)+14,
X  	     WIN_WIDTH,			 COMMAND_SIZE*2+5,
X  /*	     WIN_HEIGHT,		 COMMAND_SIZE*4+4, */
X  	     WIN_BELOW,			 command_panel,
X--- 224,230 ----
X  	     WIN_FONT,			main_font,
X  	     WIN_SHOW,			FALSE,
X  	     WIN_X,			 1000-(COMMAND_SIZE*2+32),
X! 	     WIN_Y,			 COMMAND_SIZE*COMMAND_NO/2+9+ATTR_ROW(7)+14,
X  	     WIN_WIDTH,			 COMMAND_SIZE*2+5,
X  /*	     WIN_HEIGHT,		 COMMAND_SIZE*4+4, */
X  	     WIN_BELOW,			 command_panel,
X***************
X*** 234,240 ****
X  	     PANEL_LABEL_BOLD,    	 TRUE,
X  	     PANEL_SHOW_MENU,		 FALSE,
X  	     PANEL_LAYOUT,		PANEL_VERTICAL,
X! 	     PANEL_VALUE, 		5,
X  	     PANEL_LABEL_X,		10,
X  	     PANEL_LABEL_Y,		4,
X  	     PANEL_DISPLAY_LEVEL,	PANEL_ALL,
X--- 235,241 ----
X  	     PANEL_LABEL_BOLD,    	 TRUE,
X  	     PANEL_SHOW_MENU,		 FALSE,
X  	     PANEL_LAYOUT,		PANEL_VERTICAL,
X! 	     PANEL_VALUE, 		PASTE,
X  	     PANEL_LABEL_X,		10,
X  	     PANEL_LABEL_Y,		4,
X  	     PANEL_DISPLAY_LEVEL,	PANEL_ALL,
X***************
X*** 241,250 ****
X  	     PANEL_FEEDBACK,		PANEL_INVERTED,
X  	     PANEL_CHOICE_IMAGES,	&reg_command2_pr,&reg_command3_pr,
X  					&reg_command4_pr,&reg_command7_pr,
X! 					&reg_command5_pr,&reg_command6_pr,
X  					&reg_command8_pr,&reg_command1_pr,
X  					0,
X! 	     PANEL_CHOICE_XS,		1,51,1,51,1,51,1,51,
X  					0,
X  	     
X  	     PANEL_CHOICE_YS,		1,1,
X--- 242,252 ----
X  	     PANEL_FEEDBACK,		PANEL_INVERTED,
X  	     PANEL_CHOICE_IMAGES,	&reg_command2_pr,&reg_command3_pr,
X  					&reg_command4_pr,&reg_command7_pr,
X! 					&reg_command5_pr,&reg_command9_pr,
X  					&reg_command8_pr,&reg_command1_pr,
X+ 					&reg_command6_pr,
X  					0,
X! 	     PANEL_CHOICE_XS,		1,51,1,51,1,51,1,51,51,
X  					0,
X  	     
X  	     PANEL_CHOICE_YS,		1,1,
X***************
X*** 251,256 ****
X--- 253,259 ----
X  					50,50,
X  					99,99,
X  					148,148,
X+ 					197,
X  					0,
X  	     PANEL_NOTIFY_PROC, 	region_handle,
X  	     0);
X***************
X*** 259,265 ****
X      pattern_panel = window_create(base_frame, PANEL,
X  	     WIN_FONT,			main_font,
X  	     WIN_X,			 0,
X! 	     WIN_Y,			ATTR_ROW(6)+12,
X   	     WIN_BELOW,			panel,
X  	     WIN_WIDTH,			 PATTERN_SIZE*2+65,
X  /*	     WIN_HEIGHT,		 PATTERN_SIZE*PATTERN_NO/2+22, */
X--- 262,268 ----
X      pattern_panel = window_create(base_frame, PANEL,
X  	     WIN_FONT,			main_font,
X  	     WIN_X,			 0,
X! 	     WIN_Y,			ATTR_ROW(7)+12,
X   	     WIN_BELOW,			panel,
X  	     WIN_WIDTH,			 PATTERN_SIZE*2+65,
X  /*	     WIN_HEIGHT,		 PATTERN_SIZE*PATTERN_NO/2+22, */
X***************
X*** 363,371 ****
X       PANEL_LABEL_IMAGE, &pattern1_pr,
X       0);
X  
X!     color_frame = window_create(base_frame,FRAME,
X  		FRAME_LABEL,    "Color Pallet",
X  	        FRAME_SHOW_LABEL, TRUE,
X  		WIN_FONT,	main_font,
X  		WIN_WIDTH,	PALET_BLOCK*16+9,
X  		WIN_HEIGHT,	PALET_BLOCK*(16+3)+20+ATTR_ROW(2),
X--- 366,378 ----
X       PANEL_LABEL_IMAGE, &pattern1_pr,
X       0);
X  
X!   image_depth = pw->pw_pixrect->pr_depth;
X!   if (image_depth > 1)
X!     {
X!          color_frame = window_create(base_frame,FRAME,
X  		FRAME_LABEL,    "Color Pallet",
X  	        FRAME_SHOW_LABEL, TRUE,
X+ 		FRAME_INHERIT_COLORS,  TRUE,
X  		WIN_FONT,	main_font,
X  		WIN_WIDTH,	PALET_BLOCK*16+9,
X  		WIN_HEIGHT,	PALET_BLOCK*(16+3)+20+ATTR_ROW(2),
X***************
X*** 373,383 ****
X  		WIN_Y,		10,
X  		0);
X  
X!     color_canvas = 
X!         window_create(color_frame, CANVAS, 
X! 	    WIN_CONSUME_PICK_EVENTS,	WIN_NO_EVENTS, WIN_MOUSE_BUTTONS,
X! 					LOC_DRAG,
X! 					LOC_MOVE, 
X  					0,
X  	    WIN_EVENT_PROC, 		color_handle_event,
X  		WIN_X,		0,
X--- 380,388 ----
X  		WIN_Y,		10,
X  		0);
X  
X!           color_canvas = 
X!             window_create(color_frame, CANVAS, 
X! 	    WIN_CONSUME_PICK_EVENTS, 	WIN_NO_EVENTS,WIN_MOUSE_BUTTONS,
X  					0,
X  	    WIN_EVENT_PROC, 		color_handle_event,
X  		WIN_X,		0,
X***************
X*** 391,399 ****
X  	    CANVAS_RESIZE_PROC,		draw_colormap,
X  	    0),
X  
X!     color_pw = canvas_pixwin(color_canvas);
X  
X!     color_panel = window_create(color_frame, PANEL,
X  	     PANEL_LABEL_BOLD,    	 TRUE,
X  		WIN_FONT,	main_font,
X  	     WIN_X,			 0,
X--- 396,404 ----
X  	    CANVAS_RESIZE_PROC,		draw_colormap,
X  	    0),
X  
X!     	color_pw = canvas_pixwin(color_canvas);
X  
X!     	color_panel = window_create(color_frame, PANEL,
X  	     PANEL_LABEL_BOLD,    	 TRUE,
X  		WIN_FONT,	main_font,
X  	     WIN_X,			 0,
X***************
X*** 403,422 ****
X  		0);
X  
X  
X!    (void)panel_create_item(color_panel, PANEL_BUTTON, 
X!      PANEL_ITEM_X, ATTR_COL(0),
X!      PANEL_ITEM_Y, ATTR_ROW(0),
X!      PANEL_LABEL_IMAGE, panel_button_image(color_panel, "done", 5, (Pixfont *)0),
X!      PANEL_NOTIFY_PROC, color_done,
X!      0);
X  
X  
X- 
X     
X      fat_frame = window_create(base_frame,FRAME,
X  		FRAME_LABEL,    "Big bits",
X  	        FRAME_SHOW_LABEL, TRUE,
X! 		WIN_CURSOR,	cursor_create(CURSOR_IMAGE, &my_fat_cursor,0),
X  		WIN_FONT,	main_font,
X  		WIN_WIDTH,	ATTR_COL(31),
X  		WIN_HEIGHT,	ATTR_ROW(24),
X--- 408,427 ----
X  		0);
X  
X  
X!    	(void)panel_create_item(color_panel, PANEL_BUTTON, 
X!      	PANEL_ITEM_X, ATTR_COL(0),
X!      	PANEL_ITEM_Y, ATTR_ROW(0),
X!      	PANEL_LABEL_IMAGE, panel_button_image(color_panel, "done", 5, (Pixfont *)0),
X!      	PANEL_NOTIFY_PROC, color_done,
X!      	0);
X!     }
X  
X  
X     
X      fat_frame = window_create(base_frame,FRAME,
X  		FRAME_LABEL,    "Big bits",
X  	        FRAME_SHOW_LABEL, TRUE,
X! 		FRAME_INHERIT_COLORS,  TRUE,
X  		WIN_FONT,	main_font,
X  		WIN_WIDTH,	ATTR_COL(31),
X  		WIN_HEIGHT,	ATTR_ROW(24),
X***************
X*** 430,436 ****
X  					LOC_DRAG,
X  					LOC_MOVE, 
X  					0,
X- 	    WIN_CURSOR,			cursor_create(CURSOR_IMAGE, &my_fat_cursor,0),
X  	    WIN_EVENT_PROC, 		fat_handle_event,
X  		WIN_X,		0,
X  		WIN_Y,		ATTR_ROW(2)+5,
X--- 435,440 ----
X***************
X*** 527,533 ****
X  	    PANEL_ITEM_X, ATTR_COL(53),
X  	    PANEL_ITEM_Y, ATTR_ROW(1),
X  	    PANEL_LABEL_STRING, "Save:",
X! 	    PANEL_CHOICE_STRINGS, "Standard format","Compressed",0,
X  	    PANEL_VALUE, 0,
X  	    0);
X  
X--- 531,537 ----
X  	    PANEL_ITEM_X, ATTR_COL(53),
X  	    PANEL_ITEM_Y, ATTR_ROW(1),
X  	    PANEL_LABEL_STRING, "Save:",
X! 	    PANEL_CHOICE_STRINGS, "Standard format","Byte_Encoded",0,
X  	    PANEL_VALUE, 0,
X  	    0);
X  
X***************
X*** 545,550 ****
X--- 549,564 ----
X       PANEL_NOTIFY_PROC, undo_screen,
X       0);
X  
X+     ROP_cycle =
X+ 	panel_create_item(panel, PANEL_CYCLE,
X+ 	    PANEL_ITEM_X, ATTR_COL(0),
X+ 	    PANEL_ITEM_Y, ATTR_ROW(3),
X+ 	    PANEL_LABEL_STRING, "Bitmap OP:",
X+ 	    PANEL_CHOICE_STRINGS, "default","XOR","AND","OR","SRC",0,
X+ 	    PANEL_VALUE, grid_size,
X+ 	    PANEL_NOTIFY_PROC, change_parms,
X+ 	    0);
X+ 
X      grid_cycle =
X  	panel_create_item(panel, PANEL_CYCLE,
X  	    PANEL_ITEM_X, ATTR_COL(8),
X***************
X*** 571,581 ****
X       PANEL_VALUE_DISPLAY_LENGTH, 35,
X       PANEL_LABEL_STRING, "Filename:",
X       PANEL_NOTIFY_PROC, make_new_name,
X!      PANEL_NOTIFY_STRING, "\033",
X       PANEL_VALUE_STORED_LENGTH, MAX_FILE_NAME,
X       PANEL_SHOW_MENU, FALSE,
X       0);
X  
X     text_panel=panel_create_item(panel, PANEL_TEXT, 
X       PANEL_ITEM_X, ATTR_COL(80),
X       PANEL_ITEM_Y, ATTR_ROW(1),
X--- 585,604 ----
X       PANEL_VALUE_DISPLAY_LENGTH, 35,
X       PANEL_LABEL_STRING, "Filename:",
X       PANEL_NOTIFY_PROC, make_new_name,
X!      PANEL_NOTIFY_STRING, "\033\r",
X       PANEL_VALUE_STORED_LENGTH, MAX_FILE_NAME,
X       PANEL_SHOW_MENU, FALSE,
X       0);
X  
X+    lasso_remove=panel_create_item(panel, PANEL_TOGGLE, 
X+      PANEL_ITEM_X, ATTR_COL(111),
X+      PANEL_ITEM_Y, ATTR_ROW(2),
X+      PANEL_SHOW_MENU, FALSE,
X+      PANEL_LABEL_STRING, "lasso clear:",
X+      PANEL_CHOICE_STRINGS, "",0,
X+      PANEL_TOGGLE_VALUE, 0, TRUE,
X+      0);
X+ 
X     text_panel=panel_create_item(panel, PANEL_TEXT, 
X       PANEL_ITEM_X, ATTR_COL(80),
X       PANEL_ITEM_Y, ATTR_ROW(1),
X***************
X*** 584,589 ****
X--- 607,614 ----
X       PANEL_LABEL_STRING, "Text string:",
X       PANEL_VALUE_STORED_LENGTH, MAX_FILE_NAME,
X       PANEL_SHOW_MENU, FALSE,
X+      PANEL_NOTIFY_PROC, make_new_name,
X+      PANEL_NOTIFY_STRING, "\r",
X       0);
X  
X  
X***************
X*** 656,666 ****
X  
X     msg_string = panel_create_item(panel, PANEL_MESSAGE, 
X       PANEL_ITEM_X, ATTR_COL(0),
X!      PANEL_ITEM_Y, ATTR_ROW(4),
X       PANEL_LABEL_BOLD,    TRUE,
X       PANEL_LABEL_STRING, "",
X       0);
X  
X    fat_cursor = window_get(canvas,WIN_CURSOR);
X    cursor_set(fat_cursor,CURSOR_OP,PIX_SRC^PIX_DST,0);
X    window_set(canvas,WIN_CURSOR,fat_cursor,0);
X--- 681,761 ----
X  
X     msg_string = panel_create_item(panel, PANEL_MESSAGE, 
X       PANEL_ITEM_X, ATTR_COL(0),
X!      PANEL_ITEM_Y, ATTR_ROW(5),
X       PANEL_LABEL_BOLD,    TRUE,
X       PANEL_LABEL_STRING, "",
X       0);
X  
X+ 
X+ /*
X+  * Confirmer window
X+  */
X+    confirmer = window_create(base_frame, FRAME, 
X+                 WIN_WIDTH,      300,
X+                 WIN_HEIGHT,     150,
X+ 		WIN_SHOW,	FALSE,
X+ 		WIN_X,		1152/2 - 390/2,
X+ 		WIN_Y,		900/2 - 140/2,
X+                 FRAME_SHOW_LABEL, FALSE,
X+                                   0);
X+ 
X+    con_panel = window_create(confirmer, PANEL,
X+                 WIN_WIDTH,      390,
X+                 WIN_HEIGHT,     60,
X+                                  0);
X+ 
X+    con_msg_string = panel_create_item(con_panel, PANEL_MESSAGE,
X+ 		  PANEL_ITEM_X, 0,
X+ 		  PANEL_ITEM_Y, 10,
X+                   PANEL_LABEL_STRING, "",
X+                                         0);
X+ 
X+    panel_create_item(con_panel, PANEL_BUTTON,
X+                   PANEL_ITEM_X, 130,
X+                   PANEL_ITEM_Y, 35,
X+                   PANEL_LABEL_IMAGE, panel_button_image(con_panel,"NO",3,0),
X+                   PANEL_CLIENT_DATA, FALSE,
X+                   PANEL_NOTIFY_PROC, yes_no,
X+                   0);
X+ 
X+    panel_create_item(con_panel, PANEL_BUTTON,
X+                   PANEL_ITEM_X, 205,
X+                   PANEL_ITEM_Y, 35,
X+                   PANEL_LABEL_IMAGE, panel_button_image(con_panel, "YES", 3, 0),
X+                   PANEL_CLIENT_DATA, TRUE,
X+                   PANEL_NOTIFY_PROC, yes_no,
X+                   0);
X+ 
X+    window_fit(confirmer);
X+ 
X+    
X+    resize_button = panel_create_item(panel, PANEL_BUTTON, 
X+      PANEL_ITEM_X, ATTR_COL(30),
X+      PANEL_ITEM_Y, ATTR_ROW(3),
X+      PANEL_LABEL_IMAGE, panel_button_image(panel, "resize", 5, (Pixfont *)0),
X+      PANEL_NOTIFY_PROC, resize_canvas,
X+      0);
X+ 
X+    width_text=panel_create_item(panel, PANEL_TEXT, 
X+      PANEL_ITEM_X, ATTR_COL(39),
X+      PANEL_ITEM_Y, ATTR_ROW(3),
X+      PANEL_VALUE, "1152",
X+      PANEL_VALUE_DISPLAY_LENGTH, 6,
X+      PANEL_LABEL_STRING, "Width:",
X+      PANEL_VALUE_STORED_LENGTH, 6,
X+      PANEL_SHOW_MENU, FALSE,
X+      0);
X+ 
X+    height_text=panel_create_item(panel, PANEL_TEXT, 
X+      PANEL_ITEM_X, ATTR_COL(53),
X+      PANEL_ITEM_Y, ATTR_ROW(3),
X+      PANEL_VALUE, "900",
X+      PANEL_VALUE_DISPLAY_LENGTH, 6,
X+      PANEL_LABEL_STRING, "Heigth:",
X+      PANEL_VALUE_STORED_LENGTH, 6,
X+      PANEL_SHOW_MENU, FALSE,
X+      0);
X+ 
X    fat_cursor = window_get(canvas,WIN_CURSOR);
X    cursor_set(fat_cursor,CURSOR_OP,PIX_SRC^PIX_DST,0);
X    window_set(canvas,WIN_CURSOR,fat_cursor,0);
X***************
X*** 670,673 ****
X--- 765,772 ----
X    window_set(fat_canvas,WIN_CURSOR,fat_cursor,0);
X  
X  }
X+ 
X+ 
X+ 
X+ 
X  
Xdiff -c ./oval.c ../../Ver2.3/source/oval.c
X*** ./oval.c	Mon Jun 13 23:53:38 1988
X--- ../../Ver2.3/source/oval.c	Fri Jun 17 00:27:22 1988
X***************
X*** 37,47 ****
X  /*
X   * draw an oval by making the sides by vectors and ends by semicircles
X   */
X!      draw_oval(pw, center_x,center_y, curr_pos_x,curr_pos_y,flag)
X  
X         Pixwin            *pw;
X         int		 center_x,center_y,curr_pos_x,curr_pos_y;
X!        int                flag;
X     
X       {    
X         struct  pr_pos     center,
X--- 37,47 ----
X  /*
X   * draw an oval by making the sides by vectors and ends by semicircles
X   */
X!      draw_oval(pw, center_x,center_y, curr_pos_x,curr_pos_y,ROP,flag)
X  
X         Pixwin            *pw;
X         int		 center_x,center_y,curr_pos_x,curr_pos_y;
X!        int                flag,ROP;
X     
X       {    
X         struct  pr_pos     center,
X***************
X*** 49,66 ****
X          int             x, y, radius,
X  			error, npts,
X  		        h_width, h_height,
X! 			x_off, y_off,ROP;
X  
X- 	if (flag)
X- 	 {
X- 	  if (image_depth > 1)
X-   	    ROP = PIX_SRC;
X- 	  else
X- 	    ROP = PIX_SET;
X- 	 }
X-         else
X- 	   ROP = PIX_XOR;
X- 
X  	center.x = center_x;
X  	center.y = center_y;
X  	curr_pos.x = curr_pos_x;
X--- 49,56 ----
X          int             x, y, radius,
X  			error, npts,
X  		        h_width, h_height,
X! 			x_off, y_off;
X  
X  	center.x = center_x;
X  	center.y = center_y;
X  	curr_pos.x = curr_pos_x;
X***************
X*** 119,124 ****
X             ptlist[npts].x=center.x-(x+x_off); ptlist[npts++].y=center.y-(y+y_off);
X            }
X            if (flag)
X! 		my_pw_polypoint(pw,0,0,npts,ptlist,ROP);
X  }  /* end of function draw_oval() */
X  
X--- 109,114 ----
X             ptlist[npts].x=center.x-(x+x_off); ptlist[npts++].y=center.y-(y+y_off);
X            }
X            if (flag)
X! 		my_pw_polypoint(0,0,npts,ptlist,ROP);
X  }  /* end of function draw_oval() */
X  
XOnly in ../../Ver2.3/source: scale.cicon
Xdiff -c ./touchup.c ../../Ver2.3/source/touchup.c
X*** ./touchup.c	Mon Jun 13 23:53:42 1988
X--- ../../Ver2.3/source/touchup.c	Fri Jun 17 00:27:28 1988
X***************
X*** 1,4 ****
X--- 1,5 ----
X  
X+ 
X  /**************************************************************************
X     Touchup a bitmap graphics editor for the Sun Workstation running SunView
X     Copyright (c) 1988 by Raymond Kreisel
X***************
X*** 30,35 ****
X--- 31,73 ----
X  		date:	Tue Mar 22 22:04:58 EST 1988
X  		author:	rayk
X  		changes:add comments
X+ 
X+ 		date:	Fri Apr 15 00:33:52 EDT 1988
X+ 		author:	rayk
X+ 		changes:added user definable ROPs and default ROPs
X+ 
X+ 		date:	Tue Apr 19 21:45:52 EDT 1988
X+ 		author:	rayk
X+ 		changes:added LOC_TRAJECTORY for paint command so that
X+ 			it does not skip that much when you move the cursor
X+ 			quickly
X+ 
X+ 		date:	Thu Apr 21 20:14:58 EDT 1988
X+ 		author:	rayk
X+ 		changes:change the interface to text, so that you can
X+ 			drag the text
X+ 
X+ 		date:	Thu Apr 25 3:02:23  EDT 1988
X+ 		author:	rainbow
X+ 		changes:made "undo" so that it toggle between buffers
X+ 
X+ 		date:	Mon May  2 22:18:11 EDT 1988
X+ 		author:	rayk
X+ 		changes:corrected a bug of not setting the correct
X+ 			colormap fields on boot up, bug noted by:
X+ 			   mcgill-vision!amadeus!gamin
X+ 
X+ 		date:	Fri Jun  3 22:13:11 EDT 1988
X+ 		author:	rayk
X+ 		changes:corrected a bug of returning the pointer
X+ 			to a pixrect in my_mem_create, bug noted by:
X+ 			   weiser.pa@Xerox.com
X+ 			
X+ 		date:	Wed Jun 15 22:04:25 EDT 1988
X+ 		author:	juang@aloft.att.com
X+ 		changes:fixed SunView command line arguments that
X+ 			are passsed to the base frame
X+ 
X  **************************************************************************/
X  
X  #include "header.h"
X***************
X*** 43,48 ****
X--- 81,87 ----
X  int select_pt_x=0-1,select_pt_y=0-1;
X  int old_x=0; old_y=0;
X  int start_x=0; start_y=0;
X+ int paint_first=TRUE;
X  char file_name[MAX_FILE_NAME];
X  struct pixrect *cut_buffer_pr=NULL,
X  		*undo_pr=NULL;
X***************
X*** 49,55 ****
X--- 88,145 ----
X  
X  struct pixfont *main_font=NULL;
X  
X+ 
X  /*
X+  * this event proc will resize the canvas the size given in
X+  * width_text and height_text, in the EXPERT command panel
X+  */
X+ resize_canvas()
X+ {
X+ int width, height;
X+ 
X+   width = atoi((char*)panel_get_value(width_text));
X+   height = atoi((char*)panel_get_value(height_text));
X+ 
X+   if ((width > 0) &&
X+      (height > 0) &&
X+      (width < 10000) &&
X+      (height < 10000))
X+   {
X+ 	image_wid = width;
X+ 	image_hgt = height;
X+         (void)window_set(canvas,
X+ 	  	CANVAS_WIDTH,		image_wid,
X+ 	    	CANVAS_HEIGHT,		image_hgt,
X+ 	    	0);
X+ 	if (undo_flag)
X+ 	  {
X+ 	     MY_pr_destroy(undo_pr);
X+ 	     undo_pr = my_mem_create(image_wid,image_hgt,image_depth);
X+ 	  }
X+   }
X+   else
X+  	ERROR("Bad canvas size, either too small or too large");
X+ }
X+ 
X+ 
X+ /*
X+  * Get_ROP: this function will get the check user specified bitmap OP
X+  * sot that we know how to paint the new objects on to the bitmap
X+  */
X+ int get_current_ROP()
X+ {
X+   switch((int)panel_get_value(ROP_cycle)) {
X+      case 0 : return(0);
X+      case 1 : return(PIX_XOR);
X+      case 2 : return(PIX_SRC & PIX_DST);
X+      case 3 : return(PIX_SRC | PIX_DST);
X+      case 4 : return(PIX_SRC);
X+   }
X+ }
X+ 
X+ 
X+ 
X+ /*
X   * this is the event handler for the special cut/paste command menu
X   */
X  region_handle(item, event)
X***************
X*** 83,88 ****
X--- 173,181 ----
X  	case MOVE:
X  		print_msg("Hold down the RIGHT mouse button and drag the object.");
X  			break;
X+ 	case SCALE:
X+ 		scale_region();
X+                         break;
X      }
X  
X  }
X***************
X*** 96,110 ****
X  Event           *event;
X  {
X    hide_msg();
X    if ((int)panel_get_value(command_choice) != GET_PT)
X  	{
X  	  (void)window_set(region_panel, WIN_SHOW, FALSE, 0);
X! 	  panel_set(region_choice,PANEL_VALUE,5,0);
X  	}
X    (void)window_set(brush_panel, WIN_SHOW, FALSE, 0);
X      switch((int)panel_get_value(command_choice)) {
X  	case TEXT:
X! 		  draw_text();
X  			break;
X  	case LASO:
X  		  print_msg("Hold down the LEFT mouse button and encircle a object.");
X--- 189,221 ----
X  Event           *event;
X  {
X    hide_msg();
X+ 			   
X+ 
X+   /*
X+    * if we were just in paint mode and we change reset the events for
X+    * the canvas and get rid of LOC_TRAJ
X+    */
X+   if (!paint_first)
X+   {
X+     window_set(canvas,WIN_CONSUME_PICK_EVENTS,
X+ 	WIN_NO_EVENTS,
X+ 	WIN_MOUSE_BUTTONS,
X+ 	LOC_DRAG,
X+ 	LOC_MOVE, 
X+ 	0,0);
X+         paint_first = TRUE;
X+   }
X+ 
X    if ((int)panel_get_value(command_choice) != GET_PT)
X  	{
X  	  (void)window_set(region_panel, WIN_SHOW, FALSE, 0);
X! 	  panel_set(region_choice,PANEL_VALUE,PASTE,0);
X  	}
X    (void)window_set(brush_panel, WIN_SHOW, FALSE, 0);
X      switch((int)panel_get_value(command_choice)) {
X  	case TEXT:
X! 		  print_msg("Hold down the RIGHT mouse button and drag text to proper place.");
X! 		  mouse_parms();
X  			break;
X  	case LASO:
X  		  print_msg("Hold down the LEFT mouse button and encircle a object.");
X***************
X*** 128,133 ****
X--- 239,245 ----
X  			break;
X  	case FFILL:
X  		  fill_mode(item, event);
X+   		  panel_set(command_choice,PANEL_VALUE, GET_PT,0);
X  		  mouse_parms();
X  			break;
X  	case OVAL:
X***************
X*** 159,164 ****
X--- 271,277 ----
X  	    	      bottom_x = image_wid;
X  		      bottom_y = image_hgt;
X  		      select_region(pw,top_x,top_y,bottom_x,bottom_y);
X+ 		      print_msg("Entire drawing area is now selected.");
X  		    }
X  		  else
X  		    {
X***************
X*** 175,184 ****
X  		  if ((mouse_left == ERASE) &&  (confirm("Erase entire drawing area ?")))
X  		    {
X  		    clear_screen();
X- 		    (void)window_set(canvas,
X- 	    		  CANVAS_WIDTH,		DEFAULT_IMAGE_WID,
X- 		          CANVAS_HEIGHT,	DEFAULT_IMAGE_HGT,
X- 	   		 0);
X  		    }
X  		  else
X                      if (top_x || top_y || bottom_x || bottom_y)
X--- 288,293 ----
X***************
X*** 218,223 ****
X--- 327,333 ----
X  Panel_item      item;
X  Event           *event;
X  {
X+ 
X    if (undo_flag)
X    {
X      clean_region();
X***************
X*** 224,235 ****
X      clean_point();
X      clean_poly();
X      fat_done();
X!     pw_write(pw,0,0, image_wid,image_hgt, PIX_SRC, undo_pr,0,0);
X    }
X  }     
X  
X  
X  
X  /*
X   * clear the drawing area
X   */
X--- 334,387 ----
X      clean_point();
X      clean_poly();
X      fat_done();
X!     pw_batch_on(pw);
X!     pr_swap(pw,undo_pr);
X!     pw_batch_off(pw);
X    }
X  }     
X  
X  
X+ /*
X+  * this funxtion was written by rainbow@sbcs.sunsb.edu (Hong Min)
X+  *
X+  * this function will swap the pixrect "pr2" with the pixwin "pw" by
X+  * coping 25 lines at a time. This is needed so that full size color
X+  * pixwins (1 meg of memory) can be exchanged with out the need of
X+  * a third buffer
X+  */
X+ pr_swap(pw, pr2)
X+ 	Pixwin		 *pw;
X+ 	struct pixrect	 *pr2;
X+ {
X+ 	struct pixrect		*buf;
X+ 	int 	i, start, loop, rem, width, height, buf_size;
X  
X+ 	width = pr2->pr_size.x;
X+ 	height = pr2->pr_size.y;
X+ 	buf_size = 25;
X+ 
X+ 	buf = mem_create(width, buf_size, image_depth);
X+ 
X+ 	loop = height / buf_size;
X+ 	rem = height % buf_size;
X+ 	
X+ 	for(i=0; i<loop; i++)
X+ 	{
X+ 	   pr_rop(buf, 0, 0, width, buf_size, PIX_SRC, pw->pw_prretained, 0, i*buf_size);
X+ 	   pw_rop(pw, 0, i*buf_size, width, buf_size, PIX_SRC, pr2, 0, i*buf_size);
X+ 	   pr_rop(pr2, 0, i*buf_size, width, buf_size, PIX_SRC, buf, 0, 0);
X+ 	}
X+ 
X+ 	if (rem != 0)
X+ 	{
X+ 	   start = (loop-1)*buf_size;
X+ 	   pr_rop(buf, 0, 0, width, rem, PIX_SRC, pw->pw_prretained, 0, start);
X+ 	   pw_rop(pw, 0, start, width, rem, PIX_SRC, pr2, 0, start);
X+ 	   pr_rop(pr2, 0, start, width, rem, PIX_SRC, buf, 0, 0);
X+ 	}
X+ }
X+ 
X+ 
X  /*
X   * clear the drawing area
X   */
X***************
X*** 308,314 ****
X--- 460,468 ----
X  caddr_t arg;
X  {
X      Pixwin      *pw     = canvas_pixwin(canvas_local);
X+     int ROP;
X  
X+ 
X      if (grid_size)
X       {
X  	event_set_x(event,event_x(event) + grid_size/2 - (event_x(event)%grid_size));
X***************
X*** 319,352 ****
X  	{
X     	 if (event_id(event) == MS_LEFT)
X  		{
X! 		if ((mouse_left == RECT_H) || (mouse_left == RECT_F))
X! 		   draw_rectangle(start_x,start_y,event_x(event), event_y(event));
X! 		if (mouse_left == LINE)
X! 		   draw_line(start_x,start_y,event_x(event), event_y(event),PIX_SRC,cur_color);
X! 		if (mouse_left == ERASE)
X! 		     {
X  	               select_region(pw,top_x,top_y,top_x+PATTERN_SIZE,top_y+PATTERN_SIZE);
X  		       reset_region();
X! 		     }
X  
X! 		if (mouse_left == CIRCLE)
X!                      {
X!  		        draw_line(start_x,start_y,old_x,old_y,PIX_XOR,1);
X! 		        draw_circle(pw,start_x,start_y,distance(old_x,old_y,start_x,start_y),1,PIX_SET);
X! 		     }
X  
X! 		if (mouse_left == OVAL)
X! 		   draw_oval(pw,start_x,start_y,old_x,old_y,TRUE);
X  
X!                 if (fat_source_x != -1)
X!                    fat_update(0,0);
X! 		if (mouse_left == GET_PT)
X! 		 {
X    		   select_pt_x = event_x(event);
X  		   select_pt_y = event_y(event);
X! 		 }
X! 		if (mouse_left == LASO)
X! 		{
X  		   laso_cut_paste();
X  		   panel_set(region_choice,PANEL_VALUE,MOVE,0);
X  		   panel_set(command_choice,PANEL_VALUE,SEL_REG,0);
X--- 473,517 ----
X  	{
X     	 if (event_id(event) == MS_LEFT)
X  		{
X! 		switch(mouse_left) {
X! 		case RECT_H :
X! 		case RECT_F :
X! 		   draw_rectangle(start_x,start_y,event_x(event), event_y(event),ROP);
X! 		   break;
X! 
X! 		case LINE :
X! 		   if (!(ROP = get_current_ROP()))
X! 			ROP = PIX_SRC | PIX_DST;
X! 		   if (ROP != (PIX_XOR))
X! 		        draw_line(start_x,start_y,event_x(event), event_y(event),ROP,cur_color);
X! 		   break;
X! 
X! 		case ERASE :
X  	               select_region(pw,top_x,top_y,top_x+PATTERN_SIZE,top_y+PATTERN_SIZE);
X  		       reset_region();
X! 		   break;
X  
X! 		case CIRCLE :
X! 		   if (!(ROP = get_current_ROP()))
X! 			ROP = PIX_SRC;
X!  		   draw_line(start_x,start_y,old_x,old_y,PIX_XOR,1);
X! 		   draw_circle(pw,start_x,start_y,distance(old_x,old_y,start_x,start_y),ROP);
X! 		   break;
X  
X! 		case OVAL :
X! 		   if (!(ROP = get_current_ROP()))
X! 			ROP = PIX_SRC;
X! 		   if (ROP == (PIX_XOR))
X! 		        draw_oval(pw,start_x,start_y,old_x,old_y,ROP,FALSE);
X! 		   draw_oval(pw,start_x,start_y,old_x,old_y,ROP,TRUE);
X! 		   break;
X  
X! 		case GET_PT :
X    		   select_pt_x = event_x(event);
X  		   select_pt_y = event_y(event);
X! 		   break;
X! 
X! 		case LASO :
X  		   laso_cut_paste();
X  		   panel_set(region_choice,PANEL_VALUE,MOVE,0);
X  		   panel_set(command_choice,PANEL_VALUE,SEL_REG,0);
X***************
X*** 354,365 ****
X--- 519,543 ----
X  	           (void)window_set(region_panel, WIN_SHOW,TRUE, 0);
X  		   print_msg("Object copied to Cut/Paste buffer. Hold down the RIGHT mouse button to drag the object.");
X  		   mouse_parms();
X+ 		   break;
X  		}
X+                 if (fat_source_x != -1)
X+                    fat_update(0,0);
X  	      }
X     	 if (event_id(event) == MS_RIGHT)
X  		{
X+ 		  if (mouse_left == TEXT)
X+ 		    {
X+ 		     if (!(ROP = get_current_ROP()))
X+ 			ROP = PIX_SRC;
X+ 		     if (ROP != (PIX_XOR))
X+ 		        draw_text(event_x(event), event_y(event),ROP);
X+ 		    }
X+ 		  else
X                    if (((int)panel_get_value(region_choice) == MOVE) && (cut_buffer_pr != NULL))
X  			{
X+ 		         if (!(ROP = get_current_ROP()))
X+ 				ROP = PIX_SRC | PIX_DST;
X  		         pw_write(pw,old_x- cut_buffer_pr->pr_size.x/2,
X  				     old_y- cut_buffer_pr->pr_size.y/2,
X  				     cut_buffer_pr->pr_size.x,
X***************
X*** 369,375 ****
X  				   event_y(event)-cut_buffer_pr->pr_size.y/2,
X  				 cut_buffer_pr->pr_size.x,
X  				 cut_buffer_pr->pr_size.y,
X! 				 PIX_SRC | PIX_DST, cut_buffer_pr,0,0);
X  			}
X  		}
X           return;
X--- 547,553 ----
X  				   event_y(event)-cut_buffer_pr->pr_size.y/2,
X  				 cut_buffer_pr->pr_size.x,
X  				 cut_buffer_pr->pr_size.y,
X! 				 ROP, cut_buffer_pr,0,0);
X  			}
X  		}
X           return;
X***************
X*** 380,387 ****
X  			save_screen();
X  		old_x = event_x(event);
X  		old_y = event_y(event);
X! 		start_x = event_x(event);
X! 		start_y = event_y(event);
X  		switch(mouse_left) {
X  
X  		case LINE:
X--- 558,565 ----
X  			save_screen();
X  		old_x = event_x(event);
X  		old_y = event_y(event);
X! 		start_x = old_x;
X! 		start_y = old_y;
X  		switch(mouse_left) {
X  
X  		case LINE:
X***************
X*** 398,403 ****
X--- 576,592 ----
X  			   draw_point(pw,event_x(event), event_y(event));
X  			   break;
X  		case PAINT:
X+ 			   if (paint_first)
X+ 			   {
X+ 			     window_set(canvas,WIN_CONSUME_PICK_EVENTS,
X+ 					WIN_NO_EVENTS,
X+ 					WIN_MOUSE_BUTTONS,
X+ 					LOC_DRAG,
X+ 					LOC_MOVE, 
X+ 					LOC_TRAJECTORY,
X+ 					0,0);
X+ 		             paint_first = FALSE;
X+ 			   }
X  			   draw_brush(pw, event_x(event), event_y(event));
X  			   break;
X  		case ERASE:
X***************
X*** 409,415 ****
X   		           draw_line(start_x,start_y,old_x,old_y,PIX_XOR,1);
X  			   break;
X  		case OVAL:
X! 		           draw_oval(pw,start_x,start_y,old_x,old_y,FALSE);
X  			   break;
X  		case GET_PT:
X    		   	   if (select_pt_x != -1)
X--- 598,604 ----
X   		           draw_line(start_x,start_y,old_x,old_y,PIX_XOR,1);
X  			   break;
X  		case OVAL:
X! 		           draw_oval(pw,start_x,start_y,old_x,old_y,PIX_XOR,FALSE);
X  			   break;
X  		case GET_PT:
X    		   	   if (select_pt_x != -1)
X***************
X*** 452,457 ****
X--- 641,657 ----
X  		}	  
X  		break;
X            case MS_RIGHT:
X+ 		if (mouse_left== TEXT)
X+ 			{
X+ 			   save_screen();
X+ 	  		   old_x = event_x(event);
X+ 			   old_y = event_y(event);
X+ 			   if ((char*)panel_get_value(text_panel)[0] == 0)
X+ 			       ERROR("The current TEXT STRING is empty.");
X+ 			   draw_text(old_x,old_y,PIX_XOR);
X+ 			}
X+ 		else
X+ 
X  		if (((mouse_left==POLY_F) || (mouse_left ==POLY_H))
X  		   && (poly_points[0].x != -1))
X  		 {
X***************
X*** 488,504 ****
X--- 688,708 ----
X  			erase_brush(pw, event_x(event), event_y(event));
X  			break;
X  		case LINE:
X+ 			   pw_batch_on(pw);
X  			   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X    			   old_x = event_x(event);
X  			   old_y = event_y(event);
X  			   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X+ 			   pw_batch_off(pw);
X  			break;
X  		case RECT_F :
X  		case RECT_H :
X+ 			   pw_batch_on(pw);
X  			   select_region(pw,old_x,old_y,start_x,start_y);
X  	  		   old_x = event_x(event);
X  			   old_y = event_y(event);
X  			   select_region(pw,old_x,old_y,start_x,start_y);
X+ 			   pw_batch_off(pw);
X  			break;
X  		case CIRCLE:
X  			   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X***************
X*** 507,516 ****
X  			   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X  			break;
X  		case OVAL:
X! 			   draw_oval(pw,start_x,start_y,old_x,old_y,FALSE);
X  	  		   old_x = event_x(event);
X  			   old_y = event_y(event);
X! 			   draw_oval(pw,start_x,start_y,old_x,old_y,FALSE);
X  			break;
X  		case GET_PT:
X  			   select_point(old_x,old_y);
X--- 711,722 ----
X  			   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X  			break;
X  		case OVAL:
X! 			   pw_batch_on(pw);
X! 			   draw_oval(pw,start_x,start_y,old_x,old_y,PIX_XOR,FALSE);
X  	  		   old_x = event_x(event);
X  			   old_y = event_y(event);
X! 			   draw_oval(pw,start_x,start_y,old_x,old_y,PIX_XOR,FALSE);
X! 			   pw_batch_off(pw);
X  			break;
X  		case GET_PT:
X  			   select_point(old_x,old_y);
X***************
X*** 521,530 ****
X--- 727,738 ----
X  			   select_point(old_x,old_y);
X  			break;
X  		case SEL_REG:
X+ 			  pw_batch_on(pw);
X  			  select_region(pw,top_x,top_y,bottom_x,bottom_y);
X    	        	  bottom_x = event_x(event);
X  			  bottom_y = event_y(event);
X  		 	  select_region(pw,top_x,top_y,bottom_x,bottom_y);
X+ 			  pw_batch_off(pw);
X  			break;
X  		case LASO:
X  			   laso_addpt(ptlist,event_x(event),event_y(event));
X***************
X*** 541,546 ****
X--- 749,764 ----
X  		  }
X              if (window_get(canvas_local, WIN_EVENT_STATE, MS_RIGHT))
X  		{
X+ 		if (mouse_left == TEXT)
X+ 		     {
X+ 			   pw_batch_on(pw);
X+ 			   draw_text(old_x,old_y,PIX_XOR);
X+   			   old_x = event_x(event);
X+ 			   old_y = event_y(event);
X+ 			   draw_text(old_x,old_y,PIX_XOR);
X+ 			   pw_batch_off(pw);
X+ 		     }
X+ 		else
X                  if ((int)panel_get_value(region_choice) == MOVE)
X  			{
X  			  move_region(old_x,old_y,event_x(event),event_y(event));
X***************
X*** 597,631 ****
X   */
X  main(argc,argv) int argc; char *argv[];
X  {
X  char *s;
X  
X  /*
X!  * do some agr checking
X   */
X!      while (--argc > 0 && (*++argv)[0] == '-')
X! 	for (s = argv[0]+1;*s != '\0';s++)
X!                 switch (*s) {
X! 		  case 'n':
X! 			    undo_flag = FALSE;
X! 			    break;
X! 		  case 'p':
X! 			    image_hgt = DEFAULT_IMAGE_WID;
X! 			    image_wid = DEFAULT_IMAGE_HGT;
X! 			    break;
X! 		  case 'y': ++argv; argc--;
X! 			    image_hgt = atoi(argv[0]);
X! 			    break;
X! 		  case 'x': ++argv; argc--;
X! 		   	    image_wid = atoi(argv[0]);
X! 		  	    break;
X! 		  default:  printf("Usage: touchup [-x width] [-y height] [-n] [-p]\n");
X! 			    exit(0);
X! 		}
X!   if (argc > 0)
X!     {
X!       printf("Usage: touchup [-x width] [-y height] [-n] [-p]\n");
X!       exit(0);
X!     }
X  
X    clean_poly();
X  
X--- 815,854 ----
X   */
X  main(argc,argv) int argc; char *argv[];
X  {
X+ int targc;
X+ char **targv;
X  char *s;
X+ char temp_str[10];
X+ extern colormap_t colormap;
X  
X  /*
X!  * get the options
X   */
X!         targc = argc; targv = argv;
X!         while (--argc > 0 && (*++argv)[0] == '-')
X!                 for (s = argv[0]+1;*s != '\0';s++)
X!           switch (*s) {
X!                   case 'n':
X!                             undo_flag = FALSE;
X!                             break;
X!                   case 'p':
X!                             image_hgt = DEFAULT_IMAGE_WID;
X!                             image_wid = DEFAULT_IMAGE_HGT;
X!                             break;
X!                   case 'y':
X!                                 ++argv; argc--;
X!                             image_hgt = atoi(argv[0]);
X!                             break;
X!                   case 'x':
X!                                 ++argv; argc--;
X!                             image_wid = atoi(argv[0]);
X!                             break;
X!                   default:
X!                             break;
X! 	  }
X! /*
X!  * leftovers are potential window option arguments
X!  */
X  
X    clean_poly();
X  
X***************
X*** 642,667 ****
X    init_font();
X    getcwd(file_name,MAX_FILE_NAME-2);
X    strcat(file_name,"/");
X!   init_windows(argc,argv);
X    /*
X     * are we on a color machine ????
X     */
X    image_depth = pw->pw_pixrect->pr_depth;
X!   if (image_depth == 8)
X      {
X  	init_colortable();
X  	my_put_colormap();
X  	set_color();
X      }
X    else
X  	set_mono();
X  
X    if (undo_flag)
X       undo_pr = my_mem_create(image_wid,image_hgt,image_depth);
X    else
X       panel_set(undo_button,PANEL_SHOW_ITEM, FALSE,0);
X  
X    init_mag();
X    window_main_loop(base_frame);
X  }
X  
X--- 865,929 ----
X    init_font();
X    getcwd(file_name,MAX_FILE_NAME-2);
X    strcat(file_name,"/");
X!   init_windows(&targc,targv);
X! 
X! /*
X!  * some sanity check for option arguments
X!  */
X!         while (--targc > 0 && (*++targv)[0] == '-')
X!                 for (s = targv[0]+1;*s != '\0';s++)
X!           switch (*s) {
X!                   case 'n':
X!                   case 'p':
X!                             break;
X!                   case 'y':
X!                   case 'x':
X!                                 ++targv; targc--;
X!                             break;
X!                   default:
X!                         printf("Usage: touchup [-x width] [-y height] [-n] [-p]\n");
X!                                 exit(0);
X!                             break;
X! 	  }
X!   if (targc > 0)
X!     {
X!       printf("Usage: touchup [-x width] [-y height] [-n] [-p]\n");
X!       exit(0);
X!     }
X! 			    
X!   sprintf(temp_str,"%d",image_hgt);
X!   panel_set(height_text,PANEL_VALUE,temp_str,0);
X!   sprintf(temp_str,"%d",image_wid);
X!   panel_set(width_text,PANEL_VALUE,temp_str,0);
X    /*
X     * are we on a color machine ????
X     */
X    image_depth = pw->pw_pixrect->pr_depth;
X!   if (image_depth > 1)
X      {
X  	init_colortable();
X  	my_put_colormap();
X  	set_color();
X+ 	colormap.map[0] = red;
X+ 	colormap.map[1] = green;
X+ 	colormap.map[2] = blue;
X+ 	colormap.type = RMT_EQUAL_RGB;
X+ 	colormap.length = 256;
X      }
X    else
X  	set_mono();
X  
X+   window_set(canvas, CANVAS_RETAINED, TRUE, 0);
X+ 
X    if (undo_flag)
X       undo_pr = my_mem_create(image_wid,image_hgt,image_depth);
X    else
X       panel_set(undo_button,PANEL_SHOW_ITEM, FALSE,0);
X  
X+   brush_temp_pr = my_mem_create(PATTERN_SIZE,PATTERN_SIZE,1);
X    init_mag();
X+   print_msg("Press the LEFT mouse button to PAINT.");
X+ 
X    window_main_loop(base_frame);
X  }
X  
X***************
X*** 775,778 ****
X--- 1037,1041 ----
X    	printf("Not enough memory, memory allocation problems!!!\n");
X    	exit(0);
X          }
X+     return(temp_pr);  /* this is line that was missing in version 2.2 */
X  }
Xdiff -c ./touchup.man ../../Ver2.3/source/touchup.man
X*** ./touchup.man	Mon Jun 13 23:52:05 1988
X--- ../../Ver2.3/source/touchup.man	Fri Jun 17 00:25:36 1988
X***************
X*** 1,4 ****
X! .TH Touchup 1 "26 March 1988"
X  .SH NAME
X  touchup \- a bitmap graphics editor for Sun raster files
X  .SH SYNOPSIS
X--- 1,4 ----
X! .TH TOUCHUP 1 "4 June 1988"
X  .SH NAME
X  touchup \- a bitmap graphics editor for Sun raster files
X  .SH SYNOPSIS
X***************
X*** 34,40 ****
X  will require less memory.  The use of this
X  option will make the color version much more
X  usable, by freeing up a large amount of the memory.
X- 
X  .SH COMMANDS
X  .LP
X  To edit a bitmap, type `\fBtouchup\fP'.  
X--- 34,39 ----
X***************
X*** 74,80 ****
X  .IP "\fBSave:standard format\fP" 10
X  When the save cycle is set to this mode the current image
X  will be saved out in the standard Sun raster file format.
X! .IP "\fBSave:compress\fP" 10
X  When the save cycle is set to this mode the current image 
X  will be saved out in the Sun raster file
X  BYTE_ENCODED format.  This will often compress the file to one half
X--- 73,79 ----
X  .IP "\fBSave:standard format\fP" 10
X  When the save cycle is set to this mode the current image
X  will be saved out in the standard Sun raster file format.
X! .IP "\fBSave:Byte_Encoded\fP" 10
X  When the save cycle is set to this mode the current image 
X  will be saved out in the Sun raster file
X  BYTE_ENCODED format.  This will often compress the file to one half
X***************
X*** 90,102 ****
X  When Grid is set to some value other that "none" every bitmap operation
X  will be forced to the closest grid point.  The number after Grid is the number of
X  pixels between each grid point.  The actual grid is not visible.
X  .IP "\fB(undo)\fP"
X! When this button pressed the last operation effecting the drawing area will be removed.
X  .IP "\fB(view)\fP"
X  When this button is pressed a window will be displayed containing
X  one of two possible images, depending on the "view" cycle.
X  .IP "\fBview:man page\fP"
X! This will set the view to the manual page entry for Touchup, so that when
X  the "view" button is pressed, a window containing the manual page
X  will be displayed.
X  .IP "\fBview:Cut/Paste\fP"
X--- 89,116 ----
X  When Grid is set to some value other that "none" every bitmap operation
X  will be forced to the closest grid point.  The number after Grid is the number of
X  pixels between each grid point.  The actual grid is not visible.
X+ .IP "\fBBitmap OP: default\fP"
X+ The BITMAP OP setting determines what boolean operation is to be performed
X+ between the drawing primitive and the destination bitmap. The possible
X+ boolean operations are default, which uses default settings for each
X+ command, XOR which does a exclusive-or (invert), AND which will do
X+ a AND between the bits in the drawing area and the ones you are drawing,
X+ OR which will just set bits in the drawing area but not rest any bits,
X+ and SRC, which will just copy the source drawing directly on to the
X+ drawing area.
X+ For example,
X+ if you wanted to place white text in to a black region of the drawing area.
X+ You would first set BITMAP OP to XOR (exlusive or) and do the normal
X+ commands to place text in the drawing area.
X  .IP "\fB(undo)\fP"
X! When this button pressed the last operation effecting the drawing area will be removed. If this button is pressed again, the last operation effecting the drawing area will be redisplayed.
X  .IP "\fB(view)\fP"
X  When this button is pressed a window will be displayed containing
X  one of two possible images, depending on the "view" cycle.
X  .IP "\fBview:man page\fP"
X! This will set the view to the manual page entry for
X! .IR Touchup ,
X! so that when
X  the "view" button is pressed, a window containing the manual page
X  will be displayed.
X  .IP "\fBview:Cut/Paste\fP"
X***************
X*** 104,112 ****
X  the "view" button is pressed, a window with current Cut/Paste buffer
X  will be displayed.
X  .IP "\fBview:Touchup info\fP"
X! This will set the view to the copyright notice for touchup, so that when
X  the "view" button is pressed, a window with the copyright notice
X  will appear.
X  .IP "\fBBorders:Yes\fP"
X  This cycle determines is borders are drawn on filled reactangles
X  and filled polygons.
X--- 118,138 ----
X  the "view" button is pressed, a window with current Cut/Paste buffer
X  will be displayed.
X  .IP "\fBview:Touchup info\fP"
X! This will set the view to the copyright notice for
X! .IR Touchup ,
X! so that when
X  the "view" button is pressed, a window with the copyright notice
X  will appear.
X+ .IP "\fB(resize)\fP"
X+ When this button is pressed the current value of the "height" and "width"
X+ fields will be used to resize the drawing area.  For example if you want to
X+ change the drawing area to a space of 512 by 512 pixels, you would simple
X+ select the "height" field and type in 512 and then select the "width" field
X+ and type 512 then press the "resize" button.
X+ .IP "\fBHeight: xxx\fP"
X+ This field displays the current height of the drawing area in pixels.
X+ .IP "\fBWidth: xxx\fP"
X+ This field displays the current width of the drawing area in pixels.
X  .IP "\fBBorders:Yes\fP"
X  This cycle determines is borders are drawn on filled reactangles
X  and filled polygons.
X***************
X*** 117,122 ****
X--- 143,157 ----
X  This is the string that is copied to the bitmap when the TEXT command is used.
X  .IP "\fBfonts:ABC\fP"
X  This cycle determines the font for the text when the TEXT command is used.
X+ .IP "\fBlasso clear:X\fP"
X+ If this option is turned on (it turned on by default),
X+ then when a region is selected
X+ with the LASSO it will first copy the region to the Cut/Paste
X+ buffer and then it will clear the selected region.  If you place the
X+ mouse on top of the box after "lasso clear" and press the LEFT mouse
X+ button you can toggle this
X+ option on and off.  When this option is turned off the region that
X+ selected by LASSO is not cleared.
X  .IP "\fBMessages\fP"
X  The bottom line of this window is a message subwindow, which displays
X  messages, prompts, and warnings.
X***************
X*** 140,149 ****
X  mouse button.
X  .IP "\fBTEXT\fP" 10
X  First move to the Text string field in the topmost window and type in the
X! text that you wish to place on the bitmap.  Then use the SELECT POINT mode
X! to select a point within the drawing area.  Once both of these two things are
X! done press the TEXT command icon with "ABC" on it, and the current
X! text string will be placed on to the bitmap in the currently selected font.
X  .IP "\fBMAGNIFY\fP" 10
X  First use the SELECT POINT mode to select a point within the drawing area that
X  you wish to look at in detail.  Then press the command icon for MAGNIFY
X--- 175,185 ----
X  mouse button.
X  .IP "\fBTEXT\fP" 10
X  First move to the Text string field in the topmost window and type in the
X! text that you wish to place on the bitmap.  Then press the TEXT command icon
X! with "ABC" on it, move the cursor to the drawing and hold down the
X! RIGHT mouse button. You can then drag the text to the desired location
X! on the drawing area, release the RIGHT button when you want to place a copy
X! of the text on to the bitmap.
X  .IP "\fBMAGNIFY\fP" 10
X  First use the SELECT POINT mode to select a point within the drawing area that
X  you wish to look at in detail.  Then press the command icon for MAGNIFY
X***************
X*** 227,233 ****
X  and then release the LEFT mouse button.
X  .IP "\fBOVAL\fP"
X  Like \fBCIRCLE\fP except draws a oval.
X- 
X  .IP "\fBPOLYGON\fP"
X  Once this command is selected, move to the drawing area and press the LEFT mouse
X  button when the cursor is at the first vertex of the polygon that
X--- 263,268 ----
X***************
X*** 257,267 ****
X  .IP "\fBCOPY\fP"
X  This command will place a copy of the currently selected region into the
X  Cut/Paste buffer.
X! .IP "\fBPASTE\fP"
X! First use the SELECT POINT command to select the upper right hand corner
X! of where you wish to place the Cut/Paste buffer.  Then press the PASTE
X! command icon and the contents of the current Cut/Paste buffer will be copied
X! to the drawing area.
X  .IP "\fBMOVE\fP"
X  First use either COPY, CUT, or Load:Cut/Paste buffer to put an image into
X  the current Cut/Paste buffer.  Once the MOVE command has been selected,
X--- 292,306 ----
X  .IP "\fBCOPY\fP"
X  This command will place a copy of the currently selected region into the
X  Cut/Paste buffer.
X! .IP "\fBSCALE\fP"
X! First use either COPY, CUT, or Load:Cut/Paste buffer to put an image into
X! the current Cut/Paste buffer.  Then press SELECT REGION so that you will
X! in the correct mode.  Now hold down the LEFT mouse button and select
X! the destination region for the Cut/Paste buffer.  If the size of the
X! destination region is different from the size of the original image
X! then the image will be SCALED to the fix into the destination area.
X! In this way the SCALE command can be used to enlarge, shrink, and stretch
X! images.
X  .IP "\fBMOVE\fP"
X  First use either COPY, CUT, or Load:Cut/Paste buffer to put an image into
X  the current Cut/Paste buffer.  Once the MOVE command has been selected,
X***************
X*** 269,278 ****
X--- 308,328 ----
X  As long as the RIGHT mouse button is held down, you can position the image
X  where you like.  Then let go of the RIGHT mouse button to place a copy of
X  the image on the drawing area.
X+ NOTE: If you are using the MOVE command with a color image you will
X+ probabilly want to set the "Bitmap OP" to "SRC" so that the colors are
X+ not messed up when the Cut/Paste buffer is copied onto the bitmap.
X  .IP "\fBCUT\fP"
X  This command will place a copy of the currently selected region into the
X  Cut/Paste buffer and then it will fill the selected region with the
X  currently selected pattern.
X+ .IP "\fBPASTE\fP"
X+ First use the SELECT POINT command to select the upper right hand corner
X+ of where you wish to place the Cut/Paste buffer.  Then press the PASTE
X+ command icon and the contents of the current Cut/Paste buffer will be copied
X+ to the drawing area.
X+ NOTE: If you are using the PASTE command with a color image you will
X+ probabilly want to set the "Bitmap OP" to "SRC" so that the colors are
X+ not messed up when the Cut/Paste buffer is copied onto the bitmap.
X  .IP "5)" 5
X  The last subwindow is the drawing area, which is in the center of the main
X  window.
X***************
X*** 282,304 ****
X  Save a image out to a file and use the following Unix command to
X  dump the image to a full page picture on an Apple Laser Writer or any
X  other PostScript laser printer, where
X! file_name is the file name of an image created in Touchup.
X! 
X  .LP
X  When the picture is wider than it is high use the following command:
X  
X! 	 % pssun -s 8 10.5 -r file_name | lpr -Plw
X! 
X! 
X  .LP
X  When the picture is higher than it is wide use this command:
X  
X! 	 % pssun -s 8 10.5 file_name | lpr -Plw
X! 
X  .LP
X  When the picture is part of a document use this command:
X  
X!      	 % pssun -S 6 -l 1.5 3 file_name | lpr -Plw
X  .LP
X  Images can also to sent to a IMPRESS laser printers with a command
X  similar to the following, where "/u5/sr/local/bin/imPf2" is the location
X--- 332,351 ----
X  Save a image out to a file and use the following Unix command to
X  dump the image to a full page picture on an Apple Laser Writer or any
X  other PostScript laser printer, where
X! file_name is the file name of an image created in
X! .IR Touchup .
X  .LP
X  When the picture is wider than it is high use the following command:
X  
X! 	 % pssun -s 8 10.5 -r file_name | lpr -Plw 
X  .LP
X  When the picture is higher than it is wide use this command:
X  
X! 	 % pssun -s 8 10.5 file_name | lpr -Plw 
X  .LP
X  When the picture is part of a document use this command:
X  
X!      	 % pssun -S 6 -l 1.5 3 file_name | lpr -Plw 
X  .LP
X  Images can also to sent to a IMPRESS laser printers with a command
X  similar to the following, where "/u5/sr/local/bin/imPf2" is the location
X***************
X*** 320,336 ****
X  
X  .IP "\fBHow do I merge two different pictures in to one picture ???\fP" 5
X  .LP
X! When booting up Touchup the default drawing area is 1152 x 900,
X  which is the full screen size of the Sun graphics screen.  When
X  you load a new picture
X  the drawing area is restricted to the size of the picture that you loaded.
X! What you need to do is start up Touchup and load the first picture
X  into the Cut/Paste buffer by changing the cycle next to the load
X  button from "Load: Entire image" to "Load: Cut/Paste buffer" and then
X  press the load button.  The file will then be in the cut/paste
X  buffer and you can PASTE it or MOVE it to where ever you like.
X  Then load the second picture into the Cut/Paste buffer and PASTE that
X! picture where ever you like.
X  
X  
X  .IP "\fBHow do I make part of a picture into an icon ???\fP" 5
X--- 367,387 ----
X  
X  .IP "\fBHow do I merge two different pictures in to one picture ???\fP" 5
X  .LP
X! When booting up
X! .IR Touchup ,
X! the default drawing area is 1152 x 900,
X  which is the full screen size of the Sun graphics screen.  When
X  you load a new picture
X  the drawing area is restricted to the size of the picture that you loaded.
X! What you need to do is start up
X! .I Touchup
X! and load the first picture
X  into the Cut/Paste buffer by changing the cycle next to the load
X  button from "Load: Entire image" to "Load: Cut/Paste buffer" and then
X  press the load button.  The file will then be in the cut/paste
X  buffer and you can PASTE it or MOVE it to where ever you like.
X  Then load the second picture into the Cut/Paste buffer and PASTE that
X! picture whereever you like.
X  
X  
X  .IP "\fBHow do I make part of a picture into an icon ???\fP" 5
X***************
X*** 338,347 ****
X  .LP
X  Use a program such as the "The Portable Bitmap Toolkit" by Jef
X  Poskanzer(jef@lbl-rtsg.arpa)
X! This can be ftped from zap.mit.edu, I also have a copy
X  rolled out on tape if you do not have access to zap.mit.edu.
X  
X  
X  .IP "\fBHow do I convert other image format to Sun rasterfile format ???\fP" 5
X  .IP "\fBHow do I convert Sun rasterfile format to other image formats ???\fP" 5
X  
X--- 389,414 ----
X  .LP
X  Use a program such as the "The Portable Bitmap Toolkit" by Jef
X  Poskanzer(jef@lbl-rtsg.arpa)
X! This can be
X! .IR ftp ed
X! from zap.mit.edu, I also have a copy
X  rolled out on tape if you do not have access to zap.mit.edu.
X  
X  
X+ .IP "\fBHow do I make my own paint or brush patterns ???\fP" 5
X+ 
X+ .LP
X+ First find a pattern that you want to change, they are in
X+ standard icon format files names 'patternXX.icon'.  Then load the pattern
X+ file into iconedit and make any modifications (NOTE: the paint patterns
X+ only use the upper lefthand quarter of the drawing space in iconedit).
X+ After you have changed the pattern file, just type 'touch pattern.c ;
X+ strip_icon32x32 ; make' to recompile
X+ .IR Touchup .
X+ You can do the same thing to change the brush patterns, the brushes
X+ are in the files 'brushX.icon'.
X+ 
X+ 
X  .IP "\fBHow do I convert other image format to Sun rasterfile format ???\fP" 5
X  .IP "\fBHow do I convert Sun rasterfile format to other image formats ???\fP" 5
X  
X***************
X*** 348,358 ****
X  .LP
X  Use a program such as the "The Portable Bitmap Toolkit" by Jef
X  Poskanzer(jef@lbl-rtsg.arpa)
X! This can be ftped from zap.mit.edu, I also have a copy
X  rolled out on tape if you do not have access to zap.mit.edu.
X  
X  
X! .IP "\fBWhat does SAVE COMPRESSED mean ???\fP" 5
X  
X  .LP
X  This means that the image will be saved out in the Sun rasterfile
X--- 415,427 ----
X  .LP
X  Use a program such as the "The Portable Bitmap Toolkit" by Jef
X  Poskanzer(jef@lbl-rtsg.arpa)
X! This can be
X! .IR ftp ed
X! from zap.mit.edu, I also have a copy
X  rolled out on tape if you do not have access to zap.mit.edu.
X  
X  
X! .IP "\fBWhat does SAVE Byte_Encoded mean ???\fP" 5
X  
X  .LP
X  This means that the image will be saved out in the Sun rasterfile
X***************
X*** 373,382 ****
X  .IR rasterfile (5)
X  .SH BUGS
X  .LP
X! Touchup has not been totally debugged for use with color images.
X  .LP
X  If you try to FLOOD FILL an area that has a VERY complex pattern and covers
X! a large area it is possible to over flow the stack and cause a core dump.
X  .SH Author
X   Ray Kreisel
X   Computer Science Department
X--- 442,452 ----
X  .IR rasterfile (5)
X  .SH BUGS
X  .LP
X! .I Touchup
X! has not been totally debugged for use with color images.
X  .LP
X  If you try to FLOOD FILL an area that has a VERY complex pattern and covers
X! a large area it is possible to overflow the stack and cause a core dump.
X  .SH Author
X   Ray Kreisel
X   Computer Science Department
X***************
X*** 383,390 ****
X--- 453,464 ----
X   SUNY at Stony Brook
X   Stony Brook NY 11794
X  .LP
X+  PLEASE send comments and bug reports to one of the following addresses:
X+ 
X   UUCP: {allegra, philabs, pyramid, research}!sbcs!rayk   
X   ARPA-Internet: rayk@sbcs.sunysb.edu
X   CSnet: rayk@suny-sb
X+  (If nobody is home at any of the above addresses try:
X+ 	S72QKRE@TOWSONVX.BITNET       )
X  .LP
X  "If I get home before daylight, I just might get some sleep tonight...."
END_OF_DIFFS.1
if test 57931 -ne `wc -c <DIFFS.1`; then
    echo shar: \"DIFFS.1\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f README_UPDATE -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"README_UPDATE\"
else
echo shar: Extracting \"README_UPDATE\" \(990 characters\)
sed "s/^X//" >README_UPDATE <<'END_OF_README_UPDATE'
X
X	These diff files will move touchup version 2.2 to version 2.3.
X	Unpack the two shar files into the "touchup" source directory.
X	Then do the followng:
X
X
X		% patch < DIFFS.1
X
X		% patch < DIFFS.2
X
X		% make install
X
X		% make
X
X
X	If during any of the patches a "hunk" fails, that section
X	of the diffs will have to be applyed by hand.
X
X	If for some reason you have problems appling the diff files
X	you can get the full sources for touchup version 2.3 from
X	me by e-mail (soon they should be in the sun-spots archives,
X	which you reach by an anonymous ftp to titan.rice.edu)
X
X
X				ray
X
X
X---------------------------------------------------------------------------
X Ray Kreisel   CS Dept., SUNY at Stony Brook, Stony Brook NY 11794
XUUCP: {allegra, philabs, pyramid, research}!sbcs!rayk   
XARPA-Internet: rayk@sbcs.sunysb.edu			CSnet: rayk@suny-sb
X "If I get home before daylight, I just might get some sleep tonight...."
X---------------------------------------------------------------------------
END_OF_README_UPDATE
if test 990 -ne `wc -c <README_UPDATE`; then
    echo shar: \"README_UPDATE\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

