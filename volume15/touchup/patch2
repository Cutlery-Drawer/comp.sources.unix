Subject:  v15i076:  A bitmap editor for suns, Patch2
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Raymond T Kreisel <rayk@sbcs.sunysb.edu>
Posting-number: Volume 15, Issue 76
Archive-name: touchup/patch2

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 2)."
# Contents:  DIFFS.2 scale.cicon
# Wrapped by rayk@sbmiclr on Fri Jun 17 00:32:01 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f DIFFS.2 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"DIFFS.2\"
else
echo shar: Extracting \"DIFFS.2\" \(61044 characters\)
sed "s/^X//" >DIFFS.2 <<'END_OF_DIFFS.2'
Xdiff -c ./INSTALL ../../Ver2.3/source/INSTALL
X*** ./INSTALL	Mon Jun 13 23:52:01 1988
X--- ../../Ver2.3/source/INSTALL	Fri Jun 17 00:25:31 1988
X***************
X*** 35,38 ****
X  
X  	If you are using Touchup on a color Sun you may want to
X  	use the -n option (you can read about this in the man page)
X! 	so the it will run faster.
X--- 35,48 ----
X  
X  	If you are using Touchup on a color Sun you may want to
X  	use the -n option (you can read about this in the man page)
X! 	so that it will run faster.
X! 
X! 	After you have installed touchup, these are the files
X! 	you must have in order to run the execuatble code:
X! 
X! 		touchup*
X! 		info.image
X! 		touchup.cat
X! 
X! 	The rest of the files can be removed.
X! 
Xdiff -c ./Makefile ../../Ver2.3/source/Makefile
X*** ./Makefile	Mon Jun 13 23:52:00 1988
X--- ../../Ver2.3/source/Makefile	Fri Jun 17 00:25:29 1988
X***************
X*** 1,6 ****
X! CFLAGS = -O
X! OPTIONS =
X! LIBS = -lsuntool -lsunwindow -lpixrect -lm
X  EXE = touchup
X  OBJ =   ffill.o cms_rainbow.o oval.o circle.o confirmer.o fat.o touchup.o \
X  	info.o fonts.o brush.o command.o color_palet.o \
X--- 1,6 ----
X! CFLAGS = -g
X! OPTIONS = -DSunOS_3.4
X! LIBS = -lsuntool -lsunwindow -lpixrect
X  EXE = touchup
X  OBJ =   ffill.o cms_rainbow.o oval.o circle.o confirmer.o fat.o touchup.o \
X  	info.o fonts.o brush.o command.o color_palet.o \
X***************
X*** 20,25 ****
X--- 20,29 ----
X  ################################################################
X  #   change these dirs if you move the files
X  ################################################################
X+ # next line must be hard coded if not using csh; no trailing space!
X+ # remove the comment at the begining of the next line if you are
X+ # not using csh and set the path to the path of the dir that touchup is in.
X+ #PWD=/usr/yourlogin/src/touchup	
X  BASE_DIR = $(PWD)
X  PATTERNS_DIR = $(BASE_DIR)
X  COMMANDS_DIR = $(BASE_DIR)
X***************
X*** 30,63 ****
X  
X  
X  $(EXE): $(OBJ) touchup.cat
X! 	cc $(CFLAGS) -o $(EXE) $(OBJ) $(OPTIONS) $(LIBS)
X  
X  
X- 
X  lint_it: $(SRC)
X  	lint $(SRC) $(OPTIONS) $(LIBS)
X  
X  
X  interface.o :
X! 	cc $(CFLAGS)  -mc68020 -c  interface.c -I$(PATTERNS_DIR)
X  
X  pattern.o:
X! 	cc $(CFLAGS)  -mc68020 -c  pattern.c -I$(PATTERNS_DIR)
X  
X  brush.o:
X! 	cc $(CFLAGS)  -mc68020 -c  brush.c -I$(PATTERNS_DIR)
X  
X  command.o:
X! 	cc $(CFLAGS)  -mc68020 -c  command.c -I$(COMMANDS_DIR)
X  
X  fat.o:
X! 	cc $(CFLAGS)  -mc68020 -c fat.c $(OPTIONS) -DNO_FASTAN
X  
X  info.o:
X! 	cc $(CFLAGS)  -mc68020 -c info.c $(OPTIONS) -DINFO_IMAGE='"$(INFO_PICTURE)"' -DHELP_FILE='"$(MAN_PAGE)"'
X  
X  touchup.o:
X! 	cc $(CFLAGS)  -mc68020 -c touchup.c $(OPTIONS)
X  
X  
X  touchup.cat: touchup.man
X--- 34,70 ----
X  
X  
X  $(EXE): $(OBJ) touchup.cat
X! 	$(CC) $(CFLAGS) -o $(EXE) $(OBJ) $(OPTIONS) $(LIBS)
X! 	strip touchup 			#final version
X  
X  
X  lint_it: $(SRC)
X  	lint $(SRC) $(OPTIONS) $(LIBS)
X  
X  
X  interface.o :
X! 	$(CC) $(CFLAGS)  -c  interface.c -I$(PATTERNS_DIR) $(OPTIONS)
X  
X  pattern.o:
X! 	$(CC) $(CFLAGS)  -c  pattern.c -I$(PATTERNS_DIR) $(OPTIONS)
X  
X  brush.o:
X! 	$(CC) $(CFLAGS)  -c  brush.c -I$(PATTERNS_DIR) $(OPTIONS)
X  
X  command.o:
X! 	$(CC) $(CFLAGS)  -c  command.c -I$(COMMANDS_DIR) $(OPTIONS)
X  
X  fat.o:
X! 	$(CC) $(CFLAGS)  -c fat.c $(OPTIONS) -DNO_FASTAN
X  
X+ circle.o:
X+ 	$(CC) $(CFLAGS)  -c circle.c $(OPTIONS)
X+ 
X  info.o:
X! 	$(CC) $(CFLAGS)  -c info.c $(OPTIONS) -DINFO_IMAGE='"$(INFO_PICTURE)"' -DHELP_FILE='"$(MAN_PAGE)"'
X  
X  touchup.o:
X! 	$(CC) $(CFLAGS)  -c touchup.c $(OPTIONS)
X  
X  
X  touchup.cat: touchup.man
X***************
X*** 66,82 ****
X  
X  shar:
X  	uuencode info.image info.image > temp_image
X! 	shar -b -n1 -e6 *.h Makefile INSTALL README touchup.man \
X  		fixman.sed temp_image touchup.icon \
X  			$(SH_PATTERNS_DIR)/fat_cursor \
X  			$(SH_PATTERNS_DIR)/strip_icon32x32 \
X  			$(SH_COMMANDS_DIR)/strip_icon48x48 > touchup.shar1
X! 	shar -b -n2 -e6 $(SH_COMMANDS_DIR)/*.cicon > touchup.shar2
X! 	shar -b -n3 -e6 $(SH_PATTERNS_DIR)/pattern[1-2]*.icon > touchup.shar3
X! 	shar -b -n4 -e6 $(SH_PATTERNS_DIR)/pattern[3-9]*.icon \
X  			$(SH_PATTERNS_DIR)/brush[1-9].icon > touchup.shar4
X! 	shar -b -n5 -e6 [a-h]*.c > touchup.shar5
X! 	shar -b -n6 -e6 [h-z]*.c > touchup.shar6
X  	rm -f temp_image
X  
X  install:
X--- 73,90 ----
X  
X  shar:
X  	uuencode info.image info.image > temp_image
X! 	shar -b -n1 -e7 *.h Makefile INSTALL README touchup.man \
X  		fixman.sed temp_image touchup.icon \
X  			$(SH_PATTERNS_DIR)/fat_cursor \
X  			$(SH_PATTERNS_DIR)/strip_icon32x32 \
X  			$(SH_COMMANDS_DIR)/strip_icon48x48 > touchup.shar1
X! 	shar -b -n2 -e7 $(SH_COMMANDS_DIR)/*.cicon > touchup.shar2
X! 	shar -b -n3 -e7 $(SH_PATTERNS_DIR)/pattern[1-2]*.icon > touchup.shar3
X! 	shar -b -n4 -e7 $(SH_PATTERNS_DIR)/pattern[3-9]*.icon \
X  			$(SH_PATTERNS_DIR)/brush[1-9].icon > touchup.shar4
X! 	shar -b -n5 -e7 [a-d]*.c > touchup.shar5
X! 	shar -b -n6 -e7 [e-n]*.c > touchup.shar6
X! 	shar -b -n7 -e7 [o-z]*.c > touchup.shar7
X  	rm -f temp_image
X  
X  install:
Xdiff -c ./README ../../Ver2.3/source/README
X*** ./README	Mon Jun 13 23:52:02 1988
X--- ../../Ver2.3/source/README	Fri Jun 17 00:25:33 1988
X***************
X*** 21,40 ****
X  
X  **************************************************************************/
X  
X! 	Be sure to read the instructions in INSTALL first.
X  
X! 	There in is a manual in file touchup.man
X  
X  
X! 	After you have installed touchup these are the files
X! 	you must have in order to run the execuatble code:
X  
X- 		touchup*
X- 		info.image
X- 		touchup.cat
X- 
X- 
X- 	The rest of the files can be removed.
X  
X  	If you are using Touchup on a color Sun you may want to
X  	use the -n option (you can read about this in the man page)
X--- 21,45 ----
X  
X  **************************************************************************/
X  
X! =====>	Be sure to read the instructions in INSTALL first.  <=====
X  
X! 	Touchup is a public domain bitmap editor for Sun workstations
X! 	that is very useful for "fixing" screen dumps and doing other
X! 	types of bitmap editing.  Touchup is a powerful bitmap editor,
X! 	a few of the capabilities are listed below:
X  
X+ 		- paint with different textures
X+ 		- draw circles, rectangles, ovals, lines, and polygons
X+ 		- examine and modify a region at magnification 1-20
X+ 		- use text in many fonts
X+ 		- flood fill an area
X+ 		- lasso a free form region within a bitmap
X+ 		- scale-stretch a region of a bitmap
X+ 		- rotate a region
X+ 		- move a region
X  
X! 	There in is a manual in file touchup.man
X  
X  
X  	If you are using Touchup on a color Sun you may want to
X  	use the -n option (you can read about this in the man page)
Xdiff -c ./circle.c ../../Ver2.3/source/circle.c
X*** ./circle.c	Mon Jun 13 23:53:10 1988
X--- ../../Ver2.3/source/circle.c	Fri Jun 17 00:27:03 1988
X***************
X*** 25,31 ****
X  /**************************************************************************
X  	file: circle.c
X  	purpose: This file contains that routines that draw circles
X! 		on the screen. A UNDOCUMENTED Sunview function "pw_polypoint"
X  		is used to get the list of points that make the circle
X  		on to the screen AMAZINGLY FAST.
X  		The points that make up the circle are calculated with
X--- 25,31 ----
X  /**************************************************************************
X  	file: circle.c
X  	purpose: This file contains that routines that draw circles
X! 		on the screen. A Sunview 3.4 function "pw_polypoint"
X  		is used to get the list of points that make the circle
X  		on to the screen AMAZINGLY FAST.
X  		The points that make up the circle are calculated with
X***************
X*** 35,40 ****
X--- 35,44 ----
X  		date:	Tue Mar 22 22:04:58 EST 1988
X  		author:	rayk
X  		changes:add comments
X+ 
X+ 		date:	Fri Apr 22 17:11:02 EDT 1988
X+ 		author:	rayk
X+ 		changes:added pw_batching and bitops
X  **************************************************************************/
X  
X  #include "header.h"
X***************
X*** 74,79 ****
X--- 78,88 ----
X               else
X                  error = error + ((x-y--) << 2) + 10;
X               x++;
X+ 	     if (numpts > MAX_PTS-8)
X+  	     {
X+ 		ERROR("Circle is too larege !");
X+ 		return(0);
X+ 	     }
X             }  /* end of while (x , y) */
X     
X             if (x == y)
X***************
X*** 84,111 ****
X               ptlist[numpts].x=center.x-x;   ptlist[numpts++].y=center.y-y;
X             }
X  
X! 	   my_pw_polypoint(pw,0,0,numpts,ptlist,PIX_SET);
X  }  /* end of function draw_circle() */   
X  
X  
X  
X! my_pw_polypoint(temp_pw,off_x,off_y,count_pts,ptlist, ROP)
X! Pixwin *temp_pw;
X  int off_x,off_y,count_pts;
X  struct pr_pos ptlist[];
X  int ROP;
X  {
X  
X!   if (image_depth > 1)
X    {
X      while(--count_pts > 0)
X      {
X!       pw_rop(temp_pw,off_x+ptlist[count_pts].x,off_y+ptlist[count_pts].y,1,1
X!   	,PIX_COLOR(cur_color) | PIX_SRC ,pattern[0],0,0);
X      }
X    }
X    else
X    {
X!     pw_polypoint(temp_pw,off_x,off_y,count_pts,ptlist,ROP);
X    }
X  }
X--- 93,129 ----
X               ptlist[numpts].x=center.x-x;   ptlist[numpts++].y=center.y-y;
X             }
X  
X! 	   my_pw_polypoint(0,0,numpts,ptlist,ROP);
X  }  /* end of function draw_circle() */   
X  
X  
X  
X! my_pw_polypoint(off_x,off_y,count_pts,ptlist, ROP)
X  int off_x,off_y,count_pts;
X  struct pr_pos ptlist[];
X  int ROP;
X  {
X  
X!   if (((ROP == (PIX_SRC)) || (ROP == (PIX_SRC | PIX_DST)))
X!       && (image_depth == 1))
X! 	 ROP = PIX_SET;
X! 
X! #ifdef SunOS_3.4
X!   if ((image_depth > 1) || (ROP != (PIX_SET)))
X    {
X+ #endif
X+     pw_batch_on(pw);
X      while(--count_pts > 0)
X      {
X!       pw_rop(pw,off_x+ptlist[count_pts].x,off_y+ptlist[count_pts].y,1,1
X!   	,PIX_COLOR(cur_color) | ROP ,pattern[0],0,0);
X      }
X+     pw_batch_off(pw);
X+ #ifdef SunOS_3.4
X    }
X    else
X    {
X!     pw_polypoint(pw,off_x,off_y,count_pts,ptlist,PIX_SET);
X    }
X+ #endif
X  }
Xdiff -c ./cms_rainbow.c ../../Ver2.3/source/cms_rainbow.c
X*** ./cms_rainbow.c	Mon Jun 13 23:53:12 1988
X--- ../../Ver2.3/source/cms_rainbow.c	Fri Jun 17 00:27:05 1988
X***************
X*** 30,35 ****
X--- 30,39 ----
X  		date:	Tue Mar 22 22:04:58 EST 1988
X  		author:	rayk
X  		changes:add comments
X+ 
X+ 		date:	Sat Jun  4 13:22:45 EST 1988
X+ 		author:	rayk
X+ 		changes:fixed color pallet so that it was continious
X  **************************************************************************/
X  
X  extern unsigned char red[256],green[256],blue[256];
X***************
X*** 52,104 ****
X      red = blue = green = 0;
X  
X      for (i = 2; i < 30; i++) {
X! 	red += 9;
X! 	set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(30, 255, 0, 0);	/* red */
X      red = 255; blue = green = 0;
X      for (i = 30; i < 62; i++) {
X! 	green += 6;
X! 	set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(62, 255, 195, 0);	/* orange */ /* note diff = 33 */
X!     red = 255; blue = 0; green = 195;
X      for (i = 63; i < 96; i++) {
X! 	green += 2;
X! 	set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(96, 255, 255, 0);	/* yellow */
X      red = 255; blue = 0; green = 255;
X      for (i = 97; i < 133; i++) {
X! 	red -= 7;
X! 	set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(133, 0, 255, 0);	/* green */
X      red = blue = 0; green = 255;
X      for (i = 134; i < 165; i++) {
X! 	green -= 8;
X! 	blue += 8;
X! 	set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(165, 0, 0, 255);	/* blue */
X      red = green = 0; blue = 255;
X      for (i = 165; i < 202; i++) {
X! 	red += 7;
X! 	set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(202, 255, 0, 255);	/* violet */
X      red = blue = 255; green = 0;
X      for (i = 203; i < 239; i++) {
X! 	green += 7;
X! 	set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(239, 255, 255, 255);	/* white */
X      red = blue = green = 255;
X      for (i = 239; i <= 255; i++) {
X! 	green -= 9;
X! 	red -= 9;
X! 	blue -= 9;
X! 	set_colorentry(i, red, green, blue);
X      }
X  }
X- 
X--- 56,108 ----
X      red = blue = green = 0;
X  
X      for (i = 2; i < 30; i++) {
X!         red += 9;
X!         set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(30, 255, 0, 0);      /* red */
X      red = 255; blue = green = 0;
X      for (i = 30; i < 62; i++) {
X!         green += 6;
X!         set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(62, 255, 188, 0);    /* orange */ /* note diff = 33 */
X!     red = 255; blue = 0; green = 188;
X      for (i = 63; i < 96; i++) {
X!         green += 2;
X!         set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(96, 255, 255, 0);    /* yellow */
X      red = 255; blue = 0; green = 255;
X      for (i = 97; i < 133; i++) {
X!         red -= 7;
X!         set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(133, 0, 255, 0);     /* green */
X      red = blue = 0; green = 255;
X      for (i = 134; i < 165; i++) {
X!         green -= 8;
X!         blue += 8;
X!         set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(165, 0, 0, 255);     /* blue */
X      red = green = 0; blue = 255;
X      for (i = 165; i < 202; i++) {
X!         red += 7;
X!         set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(201, 255, 0, 255);   /* violet */
X!     set_colorentry(202, 255, 0, 255);   /* violet */
X      red = blue = 255; green = 0;
X      for (i = 203; i < 239; i++) {
X!         green += 7;
X!         set_colorentry(i, red, green, blue);
X      }
X!     set_colorentry(239, 255, 255, 255); /* white */
X      red = blue = green = 255;
X      for (i = 239; i <= 255; i++) {
X!         green -= 9;
X!         red -= 9;
X!         blue -= 9;
X!         set_colorentry(i, red, green, blue);
X      }
X  }
Xdiff -c ./color_palet.c ../../Ver2.3/source/color_palet.c
X*** ./color_palet.c	Mon Jun 13 23:53:13 1988
X--- ../../Ver2.3/source/color_palet.c	Fri Jun 17 00:27:06 1988
X***************
X*** 30,35 ****
X--- 30,43 ----
X  		date:	Tue Mar 22 22:04:58 EST 1988
X  		author:	rayk
X  		changes:add comments
X+ 
X+ 		date:	Thu Jun 16 21:02:52 EDT 1988
X+ 		author:	tnosoes!tom@mcvax.cwi.nl
X+ 		changes:corrected problems with FRAME_INHERIT_COLOR
X+ 			and the problem of the color table flashing
X+ 			on and off when you move the mouse between
X+ 			window.
X+ 
X  **************************************************************************/
X  
X  #include "header.h"
X***************
X*** 52,60 ****
X   */
X  set_mono()
X  {
X! /* set the color map to mono ******** */
X!   cms_monochromeload(red,green,blue);
X!   my_put_colormap();
X    panel_set(color_button,PANEL_SHOW_ITEM, FALSE,0);
X    panel_set(mono_cycle,PANEL_SHOW_ITEM, TRUE,0);
X  }
X--- 60,73 ----
X   */
X  set_mono()
X  {
X!   /*
X!    * set the color map to mono
X!    */
X!   if ((pw->pw_pixrect->pr_depth) > 1)
X!    {
X!      cms_monochromeload(red,green,blue);
X!      my_put_colormap();
X!    }
X    panel_set(color_button,PANEL_SHOW_ITEM, FALSE,0);
X    panel_set(mono_cycle,PANEL_SHOW_ITEM, TRUE,0);
X  }
X***************
X*** 78,83 ****
X--- 91,97 ----
X    bcopy(red,temp_red,256);
X    bcopy(green,temp_green,256);
X    bcopy(blue,temp_blue,256);
X+ 
X    temp_red[0] = -1;
X    temp_green[0] = -1;
X    temp_blue[0] = -1;
X***************
X*** 85,110 ****
X    temp_green[1] = 0;
X    temp_blue[1] = 0;
X  
X    temp_pw = (Pixwin *)window_get(panel, WIN_PIXWIN);
X    pw_setcmsname(temp_pw, "ray kreisel");
X!   pw_putcolormap(temp_pw, 0,256,red,green,blue);
X  
X    temp_pw = (Pixwin *)window_get(command_panel, WIN_PIXWIN);
X    pw_setcmsname(temp_pw, "ray kreisel");
X!   pw_putcolormap(temp_pw, 0,256,red,green,blue);
X  
X    temp_pw = (Pixwin *)window_get(region_panel, WIN_PIXWIN);
X    pw_setcmsname(temp_pw, "ray kreisel");
X!   pw_putcolormap(temp_pw, 0,256,red,green,blue);
X  
X    temp_pw = (Pixwin *)window_get(pattern_panel, WIN_PIXWIN);
X    pw_setcmsname(temp_pw, "ray kreisel");
X!   pw_putcolormap(temp_pw, 0,256,red,green,blue);
X  
X    temp_pw = (Pixwin *)window_get(brush_panel, WIN_PIXWIN);
X    pw_setcmsname(temp_pw, "ray kreisel");
X!   pw_putcolormap(temp_pw, 0,256,red,green,blue);
X  
X  }
X  
X  color_mode(item, event)
X--- 99,150 ----
X    temp_green[1] = 0;
X    temp_blue[1] = 0;
X  
X+   temp_red[255] = 0;
X+   temp_green[255] = 0;
X+   temp_blue[255] = 0;
X+   temp_red[254] = -1;
X+   temp_green[254] = -1;
X+   temp_blue[254] = -1;
X+ 
X+   temp_pw = (Pixwin *)window_get(base_frame, WIN_PIXWIN);
X+   pw_setcmsname(temp_pw, "ray kreisel");
X+   pw_putcolormap(temp_pw, 0,256,temp_red,temp_green,temp_blue);
X+ 
X    temp_pw = (Pixwin *)window_get(panel, WIN_PIXWIN);
X    pw_setcmsname(temp_pw, "ray kreisel");
X!   pw_putcolormap(temp_pw, 0,256,temp_red,temp_green,temp_blue);
X  
X    temp_pw = (Pixwin *)window_get(command_panel, WIN_PIXWIN);
X    pw_setcmsname(temp_pw, "ray kreisel");
X!   pw_putcolormap(temp_pw, 0,256,temp_red,temp_green,temp_blue);
X  
X    temp_pw = (Pixwin *)window_get(region_panel, WIN_PIXWIN);
X    pw_setcmsname(temp_pw, "ray kreisel");
X!   pw_putcolormap(temp_pw, 0,256,temp_red,temp_green,temp_blue);
X  
X    temp_pw = (Pixwin *)window_get(pattern_panel, WIN_PIXWIN);
X    pw_setcmsname(temp_pw, "ray kreisel");
X!   pw_putcolormap(temp_pw, 0,256,temp_red,temp_green,temp_blue);
X  
X    temp_pw = (Pixwin *)window_get(brush_panel, WIN_PIXWIN);
X    pw_setcmsname(temp_pw, "ray kreisel");
X!   pw_putcolormap(temp_pw, 0,256,temp_red,temp_green,temp_blue);
X  
X+   temp_pw = (Pixwin *)window_get(color_frame, WIN_PIXWIN);
X+   pw_setcmsname(temp_pw, "ray kreisel");
X+   pw_putcolormap(temp_pw, 0,256,temp_red,temp_green,temp_blue);
X+ 
X+   temp_pw = (Pixwin *)window_get(color_panel, WIN_PIXWIN);
X+   pw_setcmsname(temp_pw, "ray kreisel");
X+   pw_putcolormap(temp_pw, 0,256,temp_red,temp_green,temp_blue);
X+ 
X+   temp_pw = (Pixwin *)window_get(fat_frame, WIN_PIXWIN);
X+   pw_setcmsname(temp_pw, "ray kreisel");
X+   pw_putcolormap(temp_pw, 0,256,temp_red,temp_green,temp_blue);
X+ 
X+   temp_pw = (Pixwin *)window_get(fat_panel, WIN_PIXWIN);
X+   pw_setcmsname(temp_pw, "ray kreisel");
X+   pw_putcolormap(temp_pw, 0,256,temp_red,temp_green,temp_blue);
X  }
X  
X  color_mode(item, event)
X***************
X*** 150,162 ****
X  Event   *event;
X  caddr_t arg;
X  {
X!     if (event_is_up(event))
X!        return;
X!     switch (event_id(event)) {
X! 	 case MS_LEFT:
X! 		update_cur_color(event_x(event),event_y(event),0);
X! 		break;
X! 	}
X  }
X  
X  
X--- 190,197 ----
X  Event   *event;
X  caddr_t arg;
X  {
X!     if (event_id(event) == MS_LEFT)
X! 	update_cur_color(event_x(event),event_y(event),0);
X  }
X  
X  
Xdiff -c ./command.c ../../Ver2.3/source/command.c
X*** ./command.c	Mon Jun 13 23:53:14 1988
X--- ../../Ver2.3/source/command.c	Fri Jun 17 00:27:08 1988
X***************
X*** 152,159 ****
X  };
X  static mpr_static(reg_command7_pr, 48, 48, 1, reg_command7_data);
X  
X- 
X  static short reg_command8_data[] = {
X  #include "move.cicon.pat"
X  };
X  static mpr_static(reg_command8_pr, 48, 48, 1, reg_command8_data);
X--- 152,163 ----
X  };
X  static mpr_static(reg_command7_pr, 48, 48, 1, reg_command7_data);
X  
X  static short reg_command8_data[] = {
X  #include "move.cicon.pat"
X  };
X  static mpr_static(reg_command8_pr, 48, 48, 1, reg_command8_data);
X+ 
X+ static short reg_command9_data[] = {
X+ #include "scale.cicon.pat"
X+ };
X+ static mpr_static(reg_command9_pr, 48, 48, 1, reg_command9_data);
Xdiff -c ./confirmer.c ../../Ver2.3/source/confirmer.c
X*** ./confirmer.c	Mon Jun 13 23:53:16 1988
X--- ../../Ver2.3/source/confirmer.c	Fri Jun 17 00:27:09 1988
X***************
X*** 28,50 ****
X  		date:	Tue Mar 22 22:04:58 EST 1988
X  		author:	rayk
X  		changes:add comments
X- **************************************************************************/
X  
X! #include <stdio.h>
X! #include <sys/file.h>
X! #include <suntool/sunview.h>
X! #include <suntool/panel.h>
X! #include <suntool/canvas.h>
X! #include <suntool/walkmenu.h>
X! #include <suntool/scrollbar.h>
X! #include <math.h>
X! #include <pixrect/pixrect_hs.h>
X  
X- extern Panel panel;
X  
X! static Frame  init_confirmer();
X! static void yes_no();
X  
X  /***************************************************************
X          confirm
X          purpose: To display a window on the base_frame Sunwindow
X--- 28,45 ----
X  		date:	Tue Mar 22 22:04:58 EST 1988
X  		author:	rayk
X  		changes:add comments
X  
X! 		date:	Sun May 15 21:21:01 EDT 1988
X! 		author:	rayk
X! 		changes:rewrote the confirmer so that it is NOT created
X! 			dynamiclly to try to advoid the error in the
X! 			window creation (no more file descriptors)
X  
X  
X! **************************************************************************/
X  
X+ #include "header.h"
X+ 
X  /***************************************************************
X          confirm
X          purpose: To display a window on the base_frame Sunwindow
X***************
X*** 56,164 ****
X  		1 : if the user answered YES
X  		0 : if the user answered NO
X   ***************************************************************/
X  int confirm(message)
X  char     *message; 
X  {
X! 	Frame     confirmer;
X! 	int       answer;
X  
X- /* create the confirmer */
X- 	confirmer = init_confirmer(message);
X- 	window_bell(panel);
X- /* make the user answer */
X-  	answer = (int) window_loop(confirmer);
X  
X! /* destroy the confirmer */
X! 	window_set(confirmer, FRAME_NO_CONFIRM, TRUE, 0);
X! 	window_destroy(confirmer);
X! 
X!     	return answer;
X  }
X  
X- static Frame
X- init_confirmer(message)
X- char     *message; 
X- { 
X- extern   Frame  base_frame;
X- Frame           confirmer;
X- Panel           panel;
X- Panel_item      message_item;
X- int 	        left, top, width, height;
X- Rect	        *r;
X- struct pixrect  *pr;
X  
X- /* create the confirmer base frame */
X- 	confirmer = window_create(base_frame, FRAME, 
X-                                   FRAME_SHOW_LABEL, FALSE,
X- 				  0);
X  
X! /* create the single panel subwindow */
X! 	panel = window_create(confirmer, PANEL, 0);
X! 
X! /* put in the message */
X! 	message_item = panel_create_item(panel, PANEL_MESSAGE,
X! 					PANEL_LABEL_STRING, message,
X! 					0);
X! 
X! 	pr = panel_button_image(panel, "NO", 3, 0);
X! 	width = 2 * pr->pr_width + 10;
X! 
X!   	r = (Rect *) panel_get(message_item, PANEL_ITEM_RECT);
X! 
X! /* center the yes/no buttons under the message */
X! 	left = (r->r_width - width) / 2;
X! 	if (left < 0)
X! 	    left = 0;
X! 	top = rect_bottom(r) + 5;
X! 
X!         panel_create_item(panel, PANEL_BUTTON,
X!                   PANEL_ITEM_X, left,
X! 	          PANEL_ITEM_Y, top,
X! 	          PANEL_LABEL_IMAGE, pr,
X! 	          PANEL_CLIENT_DATA, FALSE,
X! 		  PANEL_NOTIFY_PROC, yes_no,
X! 		  0);
X!  
X!         panel_create_item(panel, PANEL_BUTTON,
X! 	          PANEL_LABEL_IMAGE, panel_button_image(panel, "YES", 3, 0),
X! 	          PANEL_CLIENT_DATA, TRUE,
X! 		  PANEL_NOTIFY_PROC, yes_no,
X! 		  0);
X!  
X! 
X! 	window_fit(panel);
X! 	window_fit(confirmer);
X! 
X! /* center the confirmer frame in the base frame */
X! 	r = (Rect *) window_get(base_frame, WIN_RECT);
X! 
X! 	width = (int) window_get(confirmer, WIN_WIDTH);
X! 	height = (int) window_get(confirmer, WIN_HEIGHT);
X! 
X! 	left = (r->r_width - width) / 2;
X! 	top = (r->r_height - height) / 3;
X! 
X!         if (left < 0) 
X!             left = 0; 
X!  	if (top < 0)
X! 	    top = 0;
X! 
X! 	window_set(confirmer, WIN_X, left, WIN_Y, top,
X! 			0);
X! 
X!         left = left + (width - width/3);
X!         top = top + height / 2;      
X! 	window_set(base_frame, WIN_MOUSE_XY, left, top,  0);
X! 
X! 	return confirmer;
X! }
X! 
X! /* yes/no notify proc */
X! static void
X! yes_no(item, event)
X  Panel_item   item;
X  Event        *event;
X  {
X! 	window_return(panel_get(item, PANEL_CLIENT_DATA));
X  }
X- 
X--- 51,94 ----
X  		1 : if the user answered YES
X  		0 : if the user answered NO
X   ***************************************************************/
X+ extern Panel_item con_msg_string;
X+ 
X  int confirm(message)
X  char     *message; 
X  {
X!    window_bell(panel);
X!    confirm_msg(message);
X!    return((int)window_loop(confirmer));
X! }
X  
X  
X! confirm_msg(string)
X! char *string;
X! {
X! char temp_space[55];
X! char *temp_pt;
X! int i;
X!   
X!   if (strlen(string) < 50)
X!   {
X!     for(i=0;i<50;i++)
X!       temp_space[i]= ' ';
X!     temp_pt = temp_space + (50-strlen(string))/2;
X!     strcpy(temp_pt,string);
X!     panel_set(con_msg_string,PANEL_LABEL_STRING,temp_space,0);
X!   }
X!   else
X!     panel_set(con_msg_string,PANEL_LABEL_STRING,string,0);
X  }
X  
X  
X  
X! /*
X!  * yes/no notify proc 
X!  */
X! void yes_no(item, event)
X  Panel_item   item;
X  Event        *event;
X  {
X!         window_return(panel_get(item, PANEL_CLIENT_DATA));
X  }
Xdiff -c ./disk_io.c ../../Ver2.3/source/disk_io.c
X*** ./disk_io.c	Mon Jun 13 23:53:19 1988
X--- ../../Ver2.3/source/disk_io.c	Fri Jun 17 00:27:12 1988
X***************
X*** 30,35 ****
X--- 30,54 ----
X  		date:	Tue Mar 22 22:04:58 EST 1988
X  		author:	rayk
X  		changes:add comments
X+ 
X+ 		date:	Thu Apr 21 20:14:58 EDT 1988
X+ 		author:	rayk
X+ 		changes:when you hit return in filename the caret moves
X+ 			to textstring
X+ 
X+ 		date:	Thu Apr 21 20:14:58 EDT 1988
X+ 		author:	rayk
X+ 		changes:when you do a load cut/paste buffer it will
X+ 			automagicly bring up the cut/paste command menu
X+ 
X+ 		date:	Wed Jun 1 1:22:18 EDT 1988
X+ 		author:	rayk
X+ 		changes:fixed bug in resize color canvases
X+ 
X+ 		date:	Wed Jun 15 14:40:48 EDT 1988
X+ 		author:	rayk
X+ 		changes:added a check in file save to check is the
X+ 			current filename is a directory
X  **************************************************************************/
X  
X  #include "header.h"
X***************
X*** 38,43 ****
X--- 57,63 ----
X  #include <sys/dir.h>
X  #include <sys/file.h>
X  #include <pwd.h>
X+ #include <sys/stat.h>
X  
X  colormap_t colormap;
X  
X***************
X*** 48,57 ****
X  Panel_item      item;
X  Event           *event;
X  {
X!   strcpy(file_name,(char*)panel_get_value(file_panel));
X!   if (complete(file_name))
X! 	  window_bell(panel);
X!   panel_set(file_panel,PANEL_VALUE,file_name,0);
X  }
X  
X  
X--- 68,87 ----
X  Panel_item      item;
X  Event           *event;
X  {
X!   if (item == text_panel)
X! 	window_set(panel,PANEL_CARET_ITEM,file_panel,0);
X!   else
X!   {
X!       if ((char)event_id(event) == '\r')
X!     	window_set(panel,PANEL_CARET_ITEM,text_panel,0);
X!       else
X!       {
X!         strcpy(file_name,(char*)panel_get_value(file_panel));
X!         if (complete(file_name))
X!       	  window_bell(panel);
X!         panel_set(file_panel,PANEL_VALUE,file_name,0);
X!       }
X!   }
X  }
X  
X  
X***************
X*** 388,393 ****
X--- 418,428 ----
X         {
X  	my_put_colormap();
X  	set_color();
X+ /**** new fix for color retained canvases */
X+         (void)window_set(canvas,
X+ 	    CANVAS_WIDTH,		file_header.ras_width,
X+ 	    CANVAS_HEIGHT,		file_header.ras_height,
X+ 	    0);
X         }
X       else
X         {
X***************
X*** 402,407 ****
X--- 437,446 ----
X       image_hgt = file_header.ras_height;
X       image_depth = file_header.ras_depth;
X       pw_write(pw,0,0, image_wid,image_hgt, PIX_SRC, undo_pr,0,0);
X+      sprintf(temp_file,"%d",image_hgt);
X+      panel_set(height_text,PANEL_VALUE,temp_file,0);
X+      sprintf(temp_file,"%d",image_wid);
X+      panel_set(width_text,PANEL_VALUE,temp_file,0);
X      }
X    else
X      {
X***************
X*** 414,419 ****
X--- 453,464 ----
X  			PIX_SRC,undo_pr,0,0);
X      MY_pr_destroy(undo_pr);
X      undo_pr = my_mem_create(image_wid,image_hgt,image_depth);
X+     panel_set(region_choice,PANEL_VALUE,MOVE,0);
X+     panel_set(command_choice,PANEL_VALUE,SEL_REG,0);
X+     (void)window_set(brush_panel, WIN_SHOW,FALSE, 0);
X+     (void)window_set(region_panel, WIN_SHOW,TRUE, 0);
X+     print_msg("Object copied to Cut/Paste buffer. Hold down the RIGHT mouse button to drag the object.");
X+     mouse_parms();
X      }
X  }
X  
X***************
X*** 432,437 ****
X--- 477,483 ----
X  int copy_flag = TRUE;
X  char temp_file[MAX_FILE_NAME];
X  
X+  hide_msg();
X   /*
X    * Is the raster file to be run-length encode or not
X    */
X***************
X*** 445,453 ****
X     */
X   strcpy(temp_file,(char*)panel_get_value(file_panel));
X   get_full_path(temp_file,file_name);
X   if (file_exist(file_name))
X  	{
X!          if (!confirm("Over write existing file ?"))
X  	 return(0);
X  	}
X   /*
X--- 491,506 ----
X     */
X   strcpy(temp_file,(char*)panel_get_value(file_panel));
X   get_full_path(temp_file,file_name);
X+ 
X+  if (file_is_dir(file_name))
X+ 	{
X+          ERROR("The current filename is a directory !");
X+ 	 return(0);
X+ 	}
X+ 
X   if (file_exist(file_name))
X  	{
X!          if (!confirm("Overwrite existing file ?"))
X  	 return(0);
X  	}
X   /*
X***************
X*** 461,467 ****
X  	 return(0);
X  	}
X   /*
X!   * Save the whole drawing are out to the disk file
X    */
X   if (SAVE_ALL == (int)panel_get_value(save_cycle))
X     {
X--- 514,520 ----
X  	 return(0);
X  	}
X   /*
X!   * Save the whole drawing area out to the disk file
X    */
X   if (SAVE_ALL == (int)panel_get_value(save_cycle))
X     {
X***************
X*** 471,477 ****
X       save_screen();
X  
X       if (!undo_pr)
X! 	undo_pr = my_mem_create(image_wid,image_hgt,image_depth);
X       pr_rop(undo_pr,0,0,image_wid,image_hgt,PIX_SRC,pw->pw_prretained,0,0);
X       pr_dump(undo_pr,fp,&colormap,type,copy_flag);
X     }
X--- 524,530 ----
X       save_screen();
X  
X       if (!undo_pr)
X!         undo_pr = my_mem_create(image_wid,image_hgt,image_depth);
X       pr_rop(undo_pr,0,0,image_wid,image_hgt,PIX_SRC,pw->pw_prretained,0,0);
X       pr_dump(undo_pr,fp,&colormap,type,copy_flag);
X     }
X***************
X*** 505,510 ****
X--- 558,584 ----
X  	return(TRUE);
X    else
X  	return(FALSE);
X+ }
X+ 
X+ 
X+ /*
X+  * Check if the file is a directory
X+  */
X+ file_is_dir(file_name)
X+ char *file_name;
X+ {
X+ struct stat buf;
X+ 
X+   if (file_exist(file_name))
X+   {
X+     stat(file_name,&buf);
X+     if (buf.st_mode & S_IFDIR)
X+ 	return(TRUE);
X+     else
X+ 	return(FALSE);
X+   }
X+   else
X+       return(FALSE);
X  }
X  
X  
Xdiff -c ./drawing.c ../../Ver2.3/source/drawing.c
X*** ./drawing.c	Mon Jun 13 23:53:22 1988
X--- ../../Ver2.3/source/drawing.c	Fri Jun 17 00:27:15 1988
X***************
X*** 30,35 ****
X--- 30,63 ----
X  		date:	Tue Mar 22 22:04:58 EST 1988
X  		author:	rayk
X  		changes:add comments
X+ 
X+ 		date:	Fri Apr 15 02:08:11 EDT 1988
X+ 		author:	rayk
X+ 		changes:added scale cut/paste
X+ 
X+ 		date:	Tue Apr 19 14:05:10 EDT 1988
X+ 		author:	rayk
X+ 		changes:fixed no-borders on polygons
X+ 
X+ 		date:	Fri Apr 22 03:05:28 EDT 1988
X+ 		author:	rainbow
X+ 		changes:added FAST rotate
X+ 
X+ 		date:	Fri Apr 22 17:11:02 EDT 1988
X+ 		author:	rayk
X+ 		changes:added pw_batch to make things much FASTER
X+ 
X+ 		date:	Wed Jun 15 14:40:48 EDT 1988
X+ 		author:	juang@aloft.att.com
X+ 		changes:worked around bug in pw_stencil that
X+ 			would not display color paint brushes properly
X+ 			on Sun 3/160 & Sun 3/260
X+ 
X+ 		date:	Wed Jun 15 16:49:43 EDT 1988
X+ 		author:	rayk
X+ 		changes:added toggle to make it so that
X+ 			lasso will clear the area that has been selected
X+ 
X  **************************************************************************/
X  
X  #include"header.h"
X***************
X*** 85,109 ****
X   * Take the current text string and put that Baby up on the bitmap
X   * in the right font
X   */
X! draw_text()
X  {
X! int x,y;
X! 
X!   if (select_pt_x != -1)
X!     {
X!       x = select_pt_x;
X!       y = select_pt_y;
X!       clean_point();
X!       save_screen();
X!       pw_text(pw,x,y,PIX_COLOR(cur_color) | PIX_SRC,font_array[(int)panel_get_value(text_size_item)],
X  		(char*)panel_get_value(text_panel));
X-     }
X-   else
X-     {
X-       ERROR("Select a point first, fill in TEXT STRING, then select ABC.");
X-       window_set(panel,PANEL_CARET_ITEM,text_panel,0);
X-       set_select_mode();
X-     }
X  }
X  
X  
X--- 113,123 ----
X   * Take the current text string and put that Baby up on the bitmap
X   * in the right font
X   */
X! draw_text(x,y,ROP)
X! int x,y,ROP;
X  {
X!       pw_text(pw,x,y,PIX_COLOR(cur_color) | ROP,font_array[(int)panel_get_value(text_size_item)],
X  		(char*)panel_get_value(text_panel));
X  }
X  
X  
X***************
X*** 123,128 ****
X--- 137,144 ----
X  draw_rectangle(x1,y1,x2,y2)
X  int x1,y1,x2,y2;
X  {
X+ int ROP;
X+ 
X    top_x = x1;
X    top_y = y1;
X    bottom_x = x2;
X***************
X*** 131,142 ****
X  	fill_region();
X    else
X  	reset_region();
X!   if ((int)panel_get_value(border_cycle))
X    {
X!     pw_vector(pw,x1,y1,x2,y1,PIX_SRC,cur_color);
X!     pw_vector(pw,x2,y1,x2,y2,PIX_SRC,cur_color);
X!     pw_vector(pw,x2,y2,x1,y2,PIX_SRC,cur_color);
X!     pw_vector(pw,x1,y2,x1,y1,PIX_SRC,cur_color);
X    }
X  }
X  
X--- 147,162 ----
X  	fill_region();
X    else
X  	reset_region();
X!   if (!(ROP = get_current_ROP()))
X!       ROP = PIX_SRC;
X!   if (((( (int)panel_get_value(border_cycle))
X!        || (int)panel_get_value(command_choice)==RECT_H))
X!        && (ROP != (PIX_XOR)))
X    {
X!     pw_vector(pw,x1,y1,x2,y1,ROP,cur_color);
X!     pw_vector(pw,x2,y1,x2,y2,ROP,cur_color);
X!     pw_vector(pw,x2,y2,x1,y2,ROP,cur_color);
X!     pw_vector(pw,x1,y2,x1,y1,ROP,cur_color);
X    }
X  }
X  
X***************
X*** 187,220 ****
X  struct pixwin *pw;
X  int x,y;
X  {
X    if (brush_temp_pr == NULL)
X!     brush_temp_pr = my_mem_create(PATTERN_SIZE,PATTERN_SIZE,1);
X  
X  
X    if (((int)panel_get_value(pattern_choice) != 39) || (image_depth == 1))
X    {
X! 	if (brush_temp_pr->pr_depth != 1)
X! 	{
X!    	  MY_pr_destroy(brush_temp_pr);
X!   	  brush_temp_pr = my_mem_create(PATTERN_SIZE,PATTERN_SIZE,1);
X! 	}
X! 	pr_replrop(brush_temp_pr,0,0,PATTERN_SIZE,PATTERN_SIZE, PIX_SRC,pattern[(int)panel_get_value(pattern_choice)],x,y);
X!         pw_stencil(pw,x-PATTERN_SIZE/2,y-PATTERN_SIZE/2,PATTERN_SIZE,PATTERN_SIZE,PIX_COLOR(cur_color) | PIX_SRC,
X! 	brushes[(int)panel_get_value(brush_choice)],0,0,brush_temp_pr,0,0);
X    }
X    else
X    {
X! 	if (brush_temp_pr->pr_depth != image_depth)
X! 	{
X!    	  MY_pr_destroy(brush_temp_pr);
X!   	  brush_temp_pr = my_mem_create(PATTERN_SIZE,PATTERN_SIZE,image_depth);
X! 	}
X! 	pr_replrop(brush_temp_pr,0,0,PATTERN_SIZE,PATTERN_SIZE, PIX_SRC,pattern[(int)panel_get_value(pattern_choice)],x,y);
X!         pw_stencil(pw,x-PATTERN_SIZE/2,y-PATTERN_SIZE/2,PATTERN_SIZE,PATTERN_SIZE, PIX_SRC,
X! 	brushes[(int)panel_get_value(brush_choice)],0,0,brush_temp_pr,0,0);
X! 
X    }
X  
X  }
X  
X  
X--- 207,237 ----
X  struct pixwin *pw;
X  int x,y;
X  {
X+ int ROP;
X+ 
X+   if (!(ROP = get_current_ROP()))
X+     ROP = PIX_SRC;
X+ 
X    if (brush_temp_pr == NULL)
X!     brush_temp_pr = my_mem_create(PATTERN_SIZE,PATTERN_SIZE,image_depth);
X  
X+   if (brush_temp_pr->pr_depth != image_depth)
X+   {
X+         MY_pr_destroy(brush_temp_pr);
X+         brush_temp_pr = my_mem_create(PATTERN_SIZE,PATTERN_SIZE,image_depth);
X+   }
X  
X    if (((int)panel_get_value(pattern_choice) != 39) || (image_depth == 1))
X    {
X!         pr_replrop(brush_temp_pr,0,0,PATTERN_SIZE,PATTERN_SIZE, PIX_COLOR(cur_color) | PIX_SRC,pattern[(int)panel_get_value(pattern_choice)],x,y);
X    }
X    else
X    {
X!         pr_replrop(brush_temp_pr,0,0,PATTERN_SIZE,PATTERN_SIZE, PIX_SRC,pattern[(int)panel_get_value(pattern_choice)],x,y);
X    }
X  
X+   pw_stencil(pw,x-PATTERN_SIZE/2,y-PATTERN_SIZE/2,PATTERN_SIZE,PATTERN_SIZE,
X+   ROP, brushes[(int)panel_get_value(brush_choice)],0,0,brush_temp_pr,0,0);
X  }
X  
X  
X***************
X*** 247,256 ****
X--- 264,275 ----
X  struct pixwin *pw;
X  int x,y;
X  {
X+   pw_batch_on(pw);
X    select_region(pw,top_x,top_y,top_x+PATTERN_SIZE,top_y+PATTERN_SIZE);
X    pw_rop(pw,x-PATTERN_SIZE/2,y-PATTERN_SIZE/2,PATTERN_SIZE,PATTERN_SIZE, PIX_SRC,0,0,0);
X    top_x = x-PATTERN_SIZE/2; top_y= y-PATTERN_SIZE/2;
X    select_region(pw,top_x,top_y,top_x+PATTERN_SIZE,top_y+PATTERN_SIZE);
X+   pw_batch_off(pw);
X  }
X  
X  
X***************
X*** 300,329 ****
X  
X  /*
X   * take a currently selected region and rotate around the center
X!  * point.  SLOW !!
X   */
X  rotate_region()
X  {
X! register i,j,t1,t2;
X  
X    if (top_x || top_y || bottom_x || bottom_y)
X      {
X       select_region(pw,top_x,top_y,bottom_x,bottom_y);
X       region_fix();
X!      MY_pr_destroy(cut_buffer_pr);
X!      cut_buffer_pr = my_mem_create(bottom_x-top_x,bottom_y-top_y,image_depth);
X!      pr_rop(cut_buffer_pr,0,0,bottom_x-top_x,bottom_y-top_y,
X! 		PIX_SRC,pw->pw_prretained,top_x,top_y);
X!      t1 = top_x + cut_buffer_pr->pr_size.x/2+ cut_buffer_pr->pr_size.y/2;
X!      t2 = top_y - cut_buffer_pr->pr_size.x/2+ cut_buffer_pr->pr_size.y/2;
X!      for (j = 0; j < cut_buffer_pr->pr_size.y; j++)
X!        for (i = 0; i < cut_buffer_pr->pr_size.x; i++)
X! 	    pw_rop(pw, t1-j, t2+i, 1,1, PIX_SRC, cut_buffer_pr,i,j);
X  
X!      top_x = top_x + cut_buffer_pr->pr_size.x/2 - cut_buffer_pr->pr_size.y/2;
X!      top_y = top_y - cut_buffer_pr->pr_size.x/2 + cut_buffer_pr->pr_size.y/2;
X!      bottom_x = top_x + cut_buffer_pr->pr_size.y;
X!      bottom_y = top_y + cut_buffer_pr->pr_size.x;
X       select_region(pw,top_x,top_y,bottom_x,bottom_y);
X      }
X    else
X--- 319,365 ----
X  
X  /*
X   * take a currently selected region and rotate around the center
X!  * point.  New FAST version that rotates in 3n bitblt where n is
X!  * number of raster lines in the source
X   */
X  rotate_region()
X  {
X! int	i, width, height, new_x, new_y, y1, y2, n;
X! struct pixrect	*tmp1, *tmp2;
X  
X    if (top_x || top_y || bottom_x || bottom_y)
X      {
X       select_region(pw,top_x,top_y,bottom_x,bottom_y);
X       region_fix();
X!      width = bottom_x - top_x;
X!      height = bottom_y - top_y;
X!      new_x = top_x + (width - height) / 2;
X!      new_y = top_y + (height - width ) /2;
X!      tmp1 = my_mem_create(width+height-1, height, image_depth);
X!      tmp2 = my_mem_create(width+height-1, width, image_depth);
X  
X!      for(i=0; i<height; i++)
X! 	   pr_rop(tmp1, i, i, width, 1, PIX_SRC, pw->pw_prretained, top_x, top_y+i);
X! 
X!      for(i=0; i<=width+height-1; i++)
X!         {
X! 	   n = (i+1<height) ? i+1 : ((i>=width) ? (width+height-1-i) : height);
X!            y1 = (i<width) ? (width-1-i) : 0;
X!            y2 = (i>=width) ? (i-width+1) : 0;
X!            pr_rop(tmp2, i, y1, 1, n, PIX_SRC, tmp1, i, y2);
X!         }
X! 
X!      pw_batch_on(pw);
X!      for(i=0; i<width; i++)
X! 	   pw_rop(pw, new_x, new_y+i, height, 1, PIX_SRC, tmp2, width-1-i, i);
X!      pw_batch_off(pw);
X!      MY_pr_destroy(tmp1);
X!      MY_pr_destroy(tmp2);
X! 
X!      top_x = new_x;
X!      top_y = new_y;
X!      bottom_x = new_x+height;
X!      bottom_y = new_y+width;
X       select_region(pw,top_x,top_y,bottom_x,bottom_y);
X      }
X    else
X***************
X*** 350,360 ****
X--- 386,398 ----
X       cut_buffer_pr = my_mem_create(bottom_x-top_x,bottom_y-top_y,image_depth);
X       pr_rop(cut_buffer_pr,0,0,bottom_x-top_x,bottom_y-top_y,
X  		PIX_SRC,pw->pw_prretained,top_x,top_y);
X+      pw_batch_on(pw);
X       for (i = 0; i < cut_buffer_pr->pr_size.x; i++) {
X  	    pw_rop(pw, top_x+(cut_buffer_pr->pr_size.x - i)-1,top_y,
X  			1,cut_buffer_pr->pr_size.y, PIX_SRC, cut_buffer_pr,i,0);
X  	}
X       select_region(pw,top_x,top_y,bottom_x,bottom_y);
X+      pw_batch_off(pw);
X      }
X    else
X      {
X***************
X*** 377,382 ****
X--- 415,421 ----
X       region_fix();
X       MY_pr_destroy(cut_buffer_pr);
X       cut_buffer_pr = my_mem_create(bottom_x-top_x,bottom_y-top_y,image_depth);
X+      pw_batch_on(pw);
X       pr_rop(cut_buffer_pr,0,0,bottom_x-top_x,bottom_y-top_y,
X  		PIX_SRC,pw->pw_prretained,top_x,top_y);
X       for (i = 0; i < cut_buffer_pr->pr_size.y; i++) {
X***************
X*** 384,389 ****
X--- 423,429 ----
X  			cut_buffer_pr->pr_size.x, 1, PIX_SRC, cut_buffer_pr, 0, i);
X  	}
X       select_region(pw,top_x,top_y,bottom_x,bottom_y);
X+      pw_batch_off(pw);
X      }
X    else
X      {
X***************
X*** 394,406 ****
X  }
X  
X  
X  
X  /*
X   * grab what is in the Cut/Paste buffer and put it up on the drawing area
X   */
X  paste_region()
X  {
X! int ROP=PIX_SRC;
X  
X    if (select_pt_x == -1)
X       {
X--- 434,490 ----
X  }
X  
X  
X+ /*
X+  * take a current Cut/Paste and scale it
X+  */
X+ scale_region()
X+ {
X+ int ROP;
X+ float inc,count;
X+ register line;
X+ struct pixrect  *temp_pix;
X  
X+   if ((top_x || top_y || bottom_x || bottom_y) && cut_buffer_pr)
X+     {
X+      if (!(ROP = get_current_ROP()))
X+ 	ROP = PIX_SRC;
X+      select_region(pw,top_x,top_y,bottom_x,bottom_y);
X+      region_fix();
X+ 
X+      temp_pix = my_mem_create(cut_buffer_pr->pr_size.x,bottom_y-top_y,image_depth);
X+      inc = ((float)cut_buffer_pr->pr_size.y)/(float)(bottom_y-top_y);
X+      for (count = 0.0,line = 0; count < cut_buffer_pr->pr_size.y ; count +=inc, line++)
X+         {
X+ 	   pr_rop(temp_pix,0,line,
X+ 	     cut_buffer_pr->pr_size.x, 1, ROP, cut_buffer_pr, 0, (int)count);
X+ 	}
X+      inc = ((float)cut_buffer_pr->pr_size.x)/(float)(bottom_x-top_x);
X+      pw_batch_on(pw);
X+      for (count = 0.0, line = 0; count < cut_buffer_pr->pr_size.x;  count +=inc, line++)
X+         {
X+ 	    pw_rop(pw,top_x + line,top_y,
X+ 		1,temp_pix->pr_size.y, ROP,temp_pix,(int)count,0);
X+ 	}
X+      pw_batch_off(pw);
X+      reset_region();
X+      MY_pr_destroy(temp_pix);
X+     }
X+   else
X+     {
X+      ERROR("Select a destination region first, then select SCALE.");
X+      panel_set(command_choice,PANEL_VALUE,SEL_REG,0);
X+      mouse_parms();
X+     }
X+ }
X+ 
X+ 
X+ 
X  /*
X   * grab what is in the Cut/Paste buffer and put it up on the drawing area
X   */
X  paste_region()
X  {
X! int ROP;
X  
X    if (select_pt_x == -1)
X       {
X***************
X*** 410,415 ****
X--- 494,501 ----
X       }
X    if (cut_buffer_pr)
X    {
X+      if (!(ROP = get_current_ROP()))
X+ 	ROP = PIX_SRC;
X       select_point(select_pt_x,select_pt_y);
X       save_screen();
X       pw_write(pw,select_pt_x,select_pt_y,cut_buffer_pr->pr_size.x,cut_buffer_pr->pr_size.y, ROP, cut_buffer_pr,0,0);
X***************
X*** 487,492 ****
X--- 573,579 ----
X  {
X    if (cut_buffer_pr)
X      {
X+      pw_batch_on(pw);
X       pw_write(pw,old_x-cut_buffer_pr->pr_size.x/2,
X  		 old_y-cut_buffer_pr->pr_size.y/2,
X  		 cut_buffer_pr->pr_size.x,
X***************
X*** 498,503 ****
X--- 585,591 ----
X  		 cut_buffer_pr->pr_size.x,
X  		 cut_buffer_pr->pr_size.y,
X  		 PIX_XOR, cut_buffer_pr,0,0);
X+      pw_batch_off(pw);
X      }
X     else
X      {
X***************
X*** 513,523 ****
X  Panel_item      item;
X  Event           *event;
X  {
X     if (top_x || top_y || bottom_x || bottom_y)
X      {
X        select_region(pw,top_x,top_y,bottom_x,bottom_y);
X        region_fix();
X!       pw_replrop(pw,top_x,top_y,bottom_x-top_x,bottom_y-top_y,PIX_COLOR(cur_color) | PIX_SRC,pattern[(int)panel_get_value(pattern_choice)],0,0);
X        reset_region();
X      }
X  }
X--- 601,615 ----
X  Panel_item      item;
X  Event           *event;
X  {
X+ int ROP;
X+ 
X     if (top_x || top_y || bottom_x || bottom_y)
X      {
X        select_region(pw,top_x,top_y,bottom_x,bottom_y);
X        region_fix();
X!       if (!(ROP = get_current_ROP()))
X! 	ROP = PIX_SRC;
X!       pw_replrop(pw,top_x,top_y,bottom_x-top_x,bottom_y-top_y,PIX_COLOR(cur_color) | ROP,pattern[(int)panel_get_value(pattern_choice)],0,0);
X        reset_region();
X      }
X  }
X***************
X*** 542,550 ****
X    while ((i<MAX_PTS) && (ptlist[i++].x != -1));
X    no_points = --i;
X    npts[0] = no_points; 
X-   pw_polygon_2(pw,0,0,1,npts,ptlist,PIX_XOR,pattern[0],0,0);
X-   pw_polygon_2(pw,0,0,1,npts,ptlist,PIX_XOR,pattern[0],0,0);
X  
X    for (i=0;i < no_points;i++)
X      {
X          top_x = MIN(top_x,ptlist[i].x);
X--- 634,650 ----
X    while ((i<MAX_PTS) && (ptlist[i++].x != -1));
X    no_points = --i;
X    npts[0] = no_points; 
X  
X+   /*
X+    * if the user booted with a '-l' option then clear the area in the lasso
X+    * if not then just XOR the area in the lasso
X+    */
X+   if (!(int)panel_get(lasso_remove, PANEL_TOGGLE_VALUE,0))
X+   {
X+     pw_polygon_2(pw,0,0,1,npts,ptlist,PIX_XOR,pattern[0],0,0);
X+     pw_polygon_2(pw,0,0,1,npts,ptlist,PIX_XOR,pattern[0],0,0);
X+   }
X+ 
X    for (i=0;i < no_points;i++)
X      {
X          top_x = MIN(top_x,ptlist[i].x);
X***************
X*** 563,568 ****
X--- 663,673 ----
X    MY_pr_destroy(cut_buffer_pr);
X    cut_buffer_pr = my_mem_create(bottom_x-top_x,bottom_y-top_y,image_depth);
X    pr_polygon_2(cut_buffer_pr,0,0,1,npts,ptlist,PIX_SRC,pw->pw_prretained,top_x,top_y);
X+ 
X+   if ((int)panel_get(lasso_remove, PANEL_TOGGLE_VALUE,0))
X+   {
X+     pw_polygon_2(pw,top_x,top_y,1,npts,ptlist,PIX_CLR,0,0,0);
X+   }
X    reset_region();
X    print_msg("The selected area is now in the Cut/Paste buffer.");
X  }
X***************
X*** 582,590 ****
X  int i;
X  int npts[1];
X  
X!   found =0;
X    i=0;
X!   while (i<MAX_PTS && !found)
X      {
X        if (py_pts[i++].x == -1)
X  	found=TRUE;
X--- 687,695 ----
X  int i;
X  int npts[1];
X  
X!   found = FALSE;
X    i=0;
X!   while ((i<MAX_PTS) && (!found))
X      {
X        if (py_pts[i++].x == -1)
X  	found=TRUE;
X***************
X*** 631,637 ****
X  
X  
X  /*
X!  * take the list of currnet vertexs and draw up the
X   * the polygon and fill it with the current paint pattern
X   */
X  draw_poly(py_pts)
X--- 736,742 ----
X  
X  
X  /*
X!  * take the list of current vertexs and draw up the
X   * the polygon and fill it with the current paint pattern
X   */
X  draw_poly(py_pts)
X***************
X*** 639,645 ****
X  {
X  int npts[1];
X  int found;
X! int i;
X  
X    if (py_pts[0].x == 0-1)
X  	return(0);
X--- 744,750 ----
X  {
X  int npts[1];
X  int found;
X! int i,ROP;
X  
X    if (py_pts[0].x == 0-1)
X  	return(0);
X***************
X*** 656,681 ****
X    npts[0] =i;
X  
X    /*
X     * do we want this baby filled ????
X     */ 
X    if ((int)panel_get_value(command_choice)==POLY_F)
X! 	   pw_polygon_2(pw,0,0,1,npts,py_pts,PIX_COLOR(cur_color) | PIX_SRC,pattern[(int)panel_get_value(pattern_choice)],0,0);
X  
X    /*
X     * do we want to wrap the polygon up in a vector border
X     */
X!   if ((int)panel_get_value(border_cycle))
X    {
X        i=1;
X        while (i<MAX_POLY && (py_pts[i].x != -1))
X          {
X      	pw_vector(pw,py_pts[i].x,py_pts[i].y,
X!     		     py_pts[i-1].x,py_pts[i-1].y,PIX_SRC,cur_color);
X      	i++;
X          }
X        i--;
X        pw_vector(pw,py_pts[i].x,py_pts[i].y,
X!     		     py_pts[0].x,py_pts[0].y,PIX_SRC,cur_color);
X    }
X    clean_poly();
X  }
X--- 761,820 ----
X    npts[0] =i;
X  
X    /*
X+    * get the current ROP for drawing or default PIX_SRC
X+    */
X+   if (!(ROP = get_current_ROP()))
X+ 	ROP = PIX_SRC;
X+ 
X+   /*
X+    * erase the orginal vectors in the poly, if filled and
X+    * the no-border option is set
X+    */
X+ /*****
X+   if ((((int)panel_get_value(command_choice)==POLY_F) &&
X+      	((int)panel_get_value(border_cycle) == 0)) ||
X+       ((int)panel_get_value(command_choice)==POLY_H) &&
X+ 	(ROP != PIX_SRC))
X+ *******/
X+   {
X+       i=1;
X+       while (i<MAX_POLY && (py_pts[i].x != -1))
X+         {
X+     	pw_vector(pw,py_pts[i].x,py_pts[i].y,
X+     		     py_pts[i-1].x,py_pts[i-1].y, PIX_XOR,1);
X+     	i++;
X+         }
X+   }
X+ 
X+ 
X+   /*
X     * do we want this baby filled ????
X     */ 
X    if ((int)panel_get_value(command_choice)==POLY_F)
X!        {
X!            if (!(ROP = get_current_ROP()))
X! 		ROP = PIX_SRC;
X  
X+ 	   pw_polygon_2(pw,0,0,1,npts,py_pts,PIX_COLOR(cur_color) | ROP,pattern[(int)panel_get_value(pattern_choice)],0,0);
X+        }
X+ 
X    /*
X     * do we want to wrap the polygon up in a vector border
X+    * but if we on unfilled-poly then always do vectors
X     */
X!   if (((int)panel_get_value(border_cycle)) || 
X! 	((int)panel_get_value(command_choice)==POLY_H))
X    {
X        i=1;
X        while (i<MAX_POLY && (py_pts[i].x != -1))
X          {
X      	pw_vector(pw,py_pts[i].x,py_pts[i].y,
X!     		     py_pts[i-1].x,py_pts[i-1].y,PIX_COLOR(cur_color) | ROP,cur_color);
X      	i++;
X          }
X        i--;
X        pw_vector(pw,py_pts[i].x,py_pts[i].y,
X!     		     py_pts[0].x,py_pts[0].y,PIX_COLOR(cur_color) | ROP,cur_color);
X    }
X    clean_poly();
X  }
Xdiff -c ./fat.c ../../Ver2.3/source/fat.c
X*** ./fat.c	Mon Jun 13 23:53:24 1988
X--- ../../Ver2.3/source/fat.c	Fri Jun 17 00:27:13 1988
X***************
X*** 30,35 ****
X--- 30,40 ----
X  		date:	Tue Mar 22 22:04:58 EST 1988
X  		author:	rayk
X  		changes:add comments
X+ 
X+ 		date:	Sun Jun  5 23:47:42 EDT 1988
X+ 		author:	rayk
X+ 		changes:fixed bug in magnify, so that it does
X+ 			a save_screen when you go into fat_mode
X  **************************************************************************/
X  
X  #include "header.h"
X***************
X*** 57,62 ****
X--- 62,68 ----
X      fat_source_x = select_pt_x- (int)window_get(fat_canvas, CANVAS_WIDTH)/magnify_fac/2;
X      fat_source_y = select_pt_y- (int)window_get(fat_canvas, CANVAS_HEIGHT)/magnify_fac/2;
X      clean_point();
X+     save_screen();
X      (void)window_set(fat_frame, WIN_SHOW, TRUE, 0);
X      select_fat_region();
X      fat_update(0,0);
X***************
X*** 137,143 ****
X  {
X    x = fat_source_x + x/magnify_fac;
X    y = fat_source_y + y/magnify_fac;
X!   update_cur_color(0,0,pw_get(pw,x,y));
X  }
X  
X  
X--- 143,150 ----
X  {
X    x = fat_source_x + x/magnify_fac;
X    y = fat_source_y + y/magnify_fac;
X!   if (pw->pw_pixrect->pr_depth > 1)
X!     update_cur_color(0,0,pw_get(pw,x,y));
X  }
X  
X  
Xdiff -c ./ffill.c ../../Ver2.3/source/ffill.c
X*** ./ffill.c	Mon Jun 13 23:53:25 1988
X--- ../../Ver2.3/source/ffill.c	Fri Jun 17 00:27:15 1988
X***************
X*** 76,83 ****
X  ffill(x,y,n)
X  int x,y,n;
X  {
X! int flag;
X! register i,j,k,bx;
X  
X          if (window_get(canvas, WIN_EVENT_STATE, MS_RIGHT))
X              return(FILL_CANCEL);
X--- 76,83 ----
X  ffill(x,y,n)
X  int x,y,n;
X  {
X! int flag,bx;
X! register i,j,k;
X  
X          if (window_get(canvas, WIN_EVENT_STATE, MS_RIGHT))
X              return(FILL_CANCEL);
X***************
X*** 91,98 ****
X--- 91,141 ----
X  			bx = i;
X  		else 
X  		    {
X+ 			break;
X+ 		    }
X+ 		}
X+ 	for (j=x+1;j<image_wid;j++)
X+ 		if (pw_get(pw,j,y)!=n)
X+ 			bx = j;
X+ 		else 
X+ 		     {
X  			pw_vector(pw,bx,y,x,y, PIX_SRC,n);
X  			break;
X+ 		     }
X+ 
X+         flag = 0;
X+ 	for (k=i+1;k<j;k++)
X+ 	{
X+ 		if (pr_get(pw->pw_prretained,k,y-1)!=n)
X+ 		   flag = ffill(k-1,y-1,n);
X+ 		if (pr_get(pw->pw_prretained,k,y+1)!=n)
X+ 		   flag = ffill(k-1,y+1,n);
X+                 if (flag) break;
X+ 	}
X+ return(flag);
X+ }
X+ 
X+ /******************************************************
X+ ffill(x,y,n)
X+ int x,y,n;
X+ {
X+ int flag,bx;
X+ register i,j,k;
X+ 
X+         if (window_get(canvas, WIN_EVENT_STATE, MS_RIGHT))
X+             return(FILL_CANCEL);
X+ 
X+ 	if (x<0 || x>=image_wid || y<0 || y>=image_hgt || pw_get(pw,x,y)==n)
X+ 		return(0);
X+ 	pw_put(pw,x,y,n);
X+         bx = x-1;
X+ 	for (i=x-1;i>=0;i--) {
X+ 		if (pw_get(pw,i,y)!=n)
X+ 			bx = i;
X+ 		else 
X+ 		    {
X+ 			pw_vector(pw,bx,y,x,y, PIX_SRC,n);
X+ 			break;
X  		    }
X  		}
X          bx = x+1;
X***************
X*** 117,119 ****
X--- 160,163 ----
X  return(flag);
X  }
X  
X+ **********************************************************/
Xdiff -c ./header.h ../../Ver2.3/source/header.h
X*** ./header.h	Mon Jun 13 23:51:58 1988
X--- ../../Ver2.3/source/header.h	Fri Jun 17 00:25:27 1988
X***************
X*** 37,43 ****
X  #include <suntool/canvas.h>
X  #include <suntool/walkmenu.h>
X  #include <suntool/scrollbar.h>
X- #include <math.h>
X  #include <pixrect/pixrect_hs.h>
X  
X  
X--- 37,42 ----
X***************
X*** 67,75 ****
X  #define INVERSE 2
X  #define ROTATE 3
X  #define COPY 4
X! #define PASTE 5
X  #define MOVE 6
X  #define CUT 7
X  
X  #define PIX_XOR PIX_SRC^PIX_DST
X  #define MAX_PTS 3000
X--- 66,75 ----
X  #define INVERSE 2
X  #define ROTATE 3
X  #define COPY 4
X! #define SCALE 5
X  #define MOVE 6
X  #define CUT 7
X+ #define PASTE 8
X  
X  #define PIX_XOR PIX_SRC^PIX_DST
X  #define MAX_PTS 3000
X***************
X*** 128,133 ****
X--- 128,135 ----
X  extern char file_name[MAX_FILE_NAME];
X  extern struct pixrect *cut_buffer_pr,*undo_pr;
X  extern struct pixfont *main_font;
X+ extern struct pixrect *brush_temp_pr;
X+ extern struct pixrect *brush_temp_pr2;
X  extern struct pixrect *pattern[];
X  extern struct pixrect *brushes[];
X  extern struct  pixfont  *font_array[];
X***************
X*** 160,175 ****
X  
X  
X  extern Frame base_frame,fat_frame,color_frame;
X  extern Canvas canvas,fat_canvas,color_canvas;
X  extern Pixwin *pw,*fat_pw,*color_pw;
X  extern Scrollbar	vertical_sb, horizontal_sb;
X  extern Panel       panel,fat_panel,color_panel,pattern_panel,
X  		brush_panel,region_panel,command_panel;
X! extern Panel_item magnify_cycle, command_choice,text_size_item;
X  extern Panel_item  text_panel,file_panel,brush_choice,mono_cycle,save_cycle,
X  	msg_string,color_button,border_cycle,view_cycle,current_pattern,
X  		load_cycle,pattern_choice,region_choice,grid_cycle,
X! 		compress_cycle,undo_button;
X  
X  extern struct pixrect			brush1_pr,brush2_pr,brush3_pr,
X  					brush4_pr,brush5_pr,brush6_pr;
X--- 162,179 ----
X  
X  
X  extern Frame base_frame,fat_frame,color_frame;
X+ extern Frame confirmer;
X  extern Canvas canvas,fat_canvas,color_canvas;
X  extern Pixwin *pw,*fat_pw,*color_pw;
X  extern Scrollbar	vertical_sb, horizontal_sb;
X  extern Panel       panel,fat_panel,color_panel,pattern_panel,
X  		brush_panel,region_panel,command_panel;
X! extern Panel_item magnify_cycle, command_choice,text_size_item,height_text,width_text;
X! extern Panel_item lasso_remove;
X  extern Panel_item  text_panel,file_panel,brush_choice,mono_cycle,save_cycle,
X  	msg_string,color_button,border_cycle,view_cycle,current_pattern,
X  		load_cycle,pattern_choice,region_choice,grid_cycle,
X! 		compress_cycle,undo_button,ROP_cycle,yes_button,no_button;
X  
X  extern struct pixrect			brush1_pr,brush2_pr,brush3_pr,
X  					brush4_pr,brush5_pr,brush6_pr;
X***************
X*** 209,215 ****
X  extern struct pixrect			reg_command1_pr,reg_command2_pr,
X  					reg_command3_pr,reg_command4_pr,
X  					reg_command5_pr,reg_command6_pr,
X! 					reg_command7_pr,reg_command8_pr;
X  
X  extern char *malloc();
X  extern quit();
X--- 213,220 ----
X  extern struct pixrect			reg_command1_pr,reg_command2_pr,
X  					reg_command3_pr,reg_command4_pr,
X  					reg_command5_pr,reg_command6_pr,
X! 					reg_command7_pr,reg_command8_pr,
X! 					reg_command9_pr;
X  
X  extern char *malloc();
X  extern quit();
X***************
X*** 234,240 ****
X  extern poly_addpt();
X  extern clear_screen();
X  extern clean_poly();
X! extern confirmer();
X  extern draw_circle();
X  extern draw_oval();
X  extern init_colortable();
X--- 239,245 ----
X  extern poly_addpt();
X  extern clear_screen();
X  extern clean_poly();
X! extern confirm();
X  extern draw_circle();
X  extern draw_oval();
X  extern init_colortable();
X***************
X*** 251,253 ****
X--- 256,263 ----
X  extern select_pattern();
X  extern char *expand_file_name();
X  extern make_new_name();
X+ extern int get_current_ROP();
X+ extern resize_canvas();
X+ extern return_true();
X+ extern return_false();
X+ 
Xdiff -c ./info.c ../../Ver2.3/source/info.c
X*** ./info.c	Mon Jun 13 23:53:33 1988
X--- ../../Ver2.3/source/info.c	Fri Jun 17 00:27:19 1988
X***************
X*** 32,37 ****
X--- 32,43 ----
X  		date:	Tue Mar 22 22:04:58 EST 1988
X  		author:	rayk
X  		changes:add comments
X+ 
X+ 		date:	Wed Jun 15 18:12:16 EDT 1988
X+ 		author:	rayk
X+ 		changes:changed error messages for "info" and "help"
X+ 			suggested by ian%sq.sq.com@RELAY.CS.NET
X+ 
X  **************************************************************************/
X  
X  #include "header.h"
X***************
X*** 58,64 ****
X     fp = fopen(INFO_IMAGE,"r");
X     if (!fp)
X     {
X!       ERROR("I Could not find the information file !!!!");
X        view_flag = FALSE;
X        fclose(fp);
X        return(0);
X--- 64,70 ----
X     fp = fopen(INFO_IMAGE,"r");
X     if (!fp)
X     {
X!       ERRORstr("I Could not find the information file : ",INFO_IMAGE);
X        view_flag = FALSE;
X        fclose(fp);
X        return(0);
X***************
X*** 66,72 ****
X     temp_pr = (struct pixrect *)pr_load(fp,color_map);
X     if (!temp_pr)
X     {
X!       ERROR("I Could not find the information file !!!!");
X        view_flag = FALSE;
X        fclose(fp);
X        return(0);
X--- 72,78 ----
X     temp_pr = (struct pixrect *)pr_load(fp,color_map);
X     if (!temp_pr)
X     {
X!       ERRORstr("I could not load the information file : ",INFO_IMAGE);
X        view_flag = FALSE;
X        fclose(fp);
X        return(0);
X***************
X*** 136,141 ****
X--- 142,148 ----
X  char *frame_label;
X  {
X  Rect *r;
X+ Pixwin *temp_pw;
X  
X     if (view_flag)
X     {
X***************
X*** 146,203 ****
X      r = (Rect *) window_get(base_frame, WIN_RECT);
X      view_frame = window_create(base_frame,FRAME,
X  		FRAME_LABEL,    frame_label,
X  	        FRAME_SHOW_LABEL, TRUE,
X- 		WIN_SHOW,	TRUE,
X  		WIN_FONT,	main_font,
X- 		WIN_WIDTH,	view_pr->pr_size.x+20,
X- 		WIN_HEIGHT,	view_pr->pr_size.y+60,
X  	        WIN_X,		(r->r_width - view_pr->pr_size.x+20)/2,
X  	        WIN_Y,		(r->r_height - view_pr->pr_size.y+50)/4,
X  		0);
X  
X      view_canvas = 
X          window_create(view_frame, CANVAS, 
X! 	    WIN_CONSUME_PICK_EVENTS,	WIN_NO_EVENTS,WIN_MOUSE_BUTTONS,
X! 					LOC_DRAG, LOC_WINENTER,
X! 					LOC_MOVE, 
X! 					0,
X! 		WIN_X,		0,
X! 		WIN_Y,		ATTR_ROW(2)+5,
X! 	    CANVAS_WIDTH,		view_pr->pr_size.x+5,
X! 	    CANVAS_HEIGHT,		view_pr->pr_size.y+5,
X! 	    CANVAS_AUTO_SHRINK,		TRUE,
X! 	    CANVAS_FIXED_IMAGE,		FALSE,
X! 	    CANVAS_AUTO_EXPAND,		TRUE,
X! 	    CANVAS_RETAINED,		TRUE,
X! 	    0),
X! 
X      view_pw = canvas_pixwin(view_canvas);
X  
X      if (view_pr->pr_depth > 1)
X      {
X  	pw_setcmsname(view_pw, "ray kreisel");
X  	pw_putcolormap(view_pw, 0,256,temp_red,temp_green,temp_blue);
X      }
X  
X-     view_panel = window_create(view_frame, PANEL,
X- 	     PANEL_LABEL_BOLD,    	 TRUE,
X- 		WIN_FONT,	main_font,
X- 	     WIN_X,			 0,
X- 	     WIN_Y,			 3,
X- 	     WIN_HEIGHT,		 ATTR_ROW(1)+4,
X- 		0);
X-    
X-    (void)panel_create_item(view_panel, PANEL_BUTTON, 
X-      PANEL_ITEM_X, ATTR_COL(0),
X-      PANEL_ITEM_Y, ATTR_ROW(0),
X-      PANEL_LABEL_IMAGE, panel_button_image(view_panel, "done", 5, (Pixfont *)0),
X-      PANEL_NOTIFY_PROC, view_done,
X-      0);
X  
X    /* write the image files to the canvas */
X  
X     pw_write(view_pw,0,0,view_pr->pr_size.x,
X  		 view_pr->pr_size.y,PIX_SRC, view_pr,0,0);
X  }   
X  
X  
X--- 153,221 ----
X      r = (Rect *) window_get(base_frame, WIN_RECT);
X      view_frame = window_create(base_frame,FRAME,
X  		FRAME_LABEL,    frame_label,
X+                 FRAME_INHERIT_COLORS,   TRUE,
X  	        FRAME_SHOW_LABEL, TRUE,
X  		WIN_FONT,	main_font,
X  	        WIN_X,		(r->r_width - view_pr->pr_size.x+20)/2,
X  	        WIN_Y,		(r->r_height - view_pr->pr_size.y+50)/4,
X  		0);
X  
X+     view_panel = window_create(view_frame, PANEL,
X+              PANEL_LABEL_BOLD,           TRUE,
X+                 WIN_FONT,       main_font,
X+                 0);
X+    
X+    (void)panel_create_item(view_panel, PANEL_BUTTON, 
X+      PANEL_ITEM_X, ATTR_COL(0),
X+      PANEL_ITEM_Y, ATTR_ROW(0),
X+      PANEL_LABEL_IMAGE, panel_button_image(view_panel, "done", 5, (Pixfont *)0),
X+      PANEL_NOTIFY_PROC, view_done,
X+      0);
X+     window_fit(view_panel);
X+ 
X      view_canvas = 
X          window_create(view_frame, CANVAS, 
X!             WIN_CONSUME_PICK_EVENTS,    WIN_NO_EVENTS,WIN_MOUSE_BUTTONS,
X!                                         LOC_DRAG, LOC_WINENTER,
X!                                         LOC_MOVE, 
X!                                         0,
X!                 WIN_X,          0,
X!                 WIN_BELOW,      view_panel,
X!             WIN_WIDTH,          view_pr->pr_size.x,
X!             WIN_HEIGHT,         view_pr->pr_size.y,
X!             CANVAS_WIDTH,               view_pr->pr_size.x,
X!             CANVAS_HEIGHT,              view_pr->pr_size.y,
X!             CANVAS_AUTO_SHRINK,         FALSE,
X!             CANVAS_FIXED_IMAGE,         TRUE,
X!             CANVAS_AUTO_EXPAND,         FALSE,
X!             CANVAS_RETAINED,            TRUE,
X!             0),
X!  
X      view_pw = canvas_pixwin(view_canvas);
X  
X+ 
X      if (view_pr->pr_depth > 1)
X      {
X  	pw_setcmsname(view_pw, "ray kreisel");
X  	pw_putcolormap(view_pw, 0,256,temp_red,temp_green,temp_blue);
X+ 
X+   	temp_pw = (Pixwin *)window_get(view_frame, WIN_PIXWIN);
X+   	pw_setcmsname(temp_pw, "ray kreisel");
X+   	pw_putcolormap(temp_pw, 0,256,temp_red,temp_green,temp_blue);
X+ 
X+   	temp_pw = (Pixwin *)window_get(view_panel, WIN_PIXWIN);
X+   	pw_setcmsname(temp_pw, "ray kreisel");
X+   	pw_putcolormap(temp_pw, 0,256,temp_red,temp_green,temp_blue);
X      }
X  
X  
X    /* write the image files to the canvas */
X  
X     pw_write(view_pw,0,0,view_pr->pr_size.x,
X  		 view_pr->pr_size.y,PIX_SRC, view_pr,0,0);
X+ 
X+    window_fit(view_frame);
X+    window_set(view_frame, WIN_SHOW, TRUE, 0);
X  }   
X  
X  
X***************
X*** 211,217 ****
X  
X     if (!file_exist(HELP_FILE))
X     {
X!       ERROR("I cannot find the man page for touchup !!!");
X        return(0);
X     }
X  
X--- 229,235 ----
X  
X     if (!file_exist(HELP_FILE))
X     {
X!       ERRORstr("I cannot find the man page for touchup : ",HELP_FILE);
X        return(0);
X     }
X  
X***************
X*** 231,237 ****
X      view_frame = window_create(base_frame,FRAME,
X  		FRAME_LABEL,    "Help window",
X  	        FRAME_SHOW_LABEL, TRUE,
X- 		WIN_SHOW,	TRUE,
X  		WIN_FONT,	main_font,
X  	        WIN_X,		(r->r_width - 600+20)/2,
X  	        WIN_Y,		(r->r_height - 512+50)/4,
X--- 249,254 ----
X***************
X*** 258,264 ****
X                  WIN_X,                  0,
X  		WIN_Y,			ATTR_ROW(2)+5,
X                  WIN_HEIGHT,             512,
X!                 WIN_WIDTH,              600,
X  		TEXTSW_FONT,		main_font,
X                  TEXTSW_IGNORE_LIMIT,    TEXTSW_INFINITY,
X                  TEXTSW_AUTO_INDENT,     TRUE,
X--- 275,281 ----
X                  WIN_X,                  0,
X  		WIN_Y,			ATTR_ROW(2)+5,
X                  WIN_HEIGHT,             512,
X!                 WIN_WIDTH,              620,
X  		TEXTSW_FONT,		main_font,
X                  TEXTSW_IGNORE_LIMIT,    TEXTSW_INFINITY,
X                  TEXTSW_AUTO_INDENT,     TRUE,
X***************
X*** 269,274 ****
X--- 286,292 ----
X                  0);
X  
X    window_fit(view_frame);
X+   window_set(view_frame, WIN_SHOW, TRUE, 0);
X  }   
X  
X  
X
END_OF_DIFFS.2
if test 61044 -ne `wc -c <DIFFS.2`; then
    echo shar: \"DIFFS.2\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f scale.cicon -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"scale.cicon\"
else
echo shar: Extracting \"scale.cicon\" \(1933 characters\)
sed "s/^X//" >scale.cicon <<'END_OF_scale.cicon'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0xFFFF,0xFFFF,0xFFFF,0x0000,0x8000,0x0000,0x0001,0x0000,
X	0x8000,0x0000,0x0001,0x0000,0x8000,0x0000,0x0001,0x0000,
X	0x8000,0x0000,0x0001,0x0000,0x8000,0x0000,0x0001,0x0000,
X	0x8000,0x0000,0x0001,0x0000,0x8000,0x0000,0x0001,0x0000,
X	0x8000,0x0000,0x0001,0x0000,0x8000,0x0000,0x0001,0x0000,
X	0x8000,0x0000,0x0001,0x0000,0x8000,0x0000,0x0001,0x0000,
X	0x8000,0x0000,0x0001,0x0000,0x8000,0x0000,0x0001,0x0000,
X	0xB366,0x6000,0x0001,0x0000,0xA000,0x2000,0x0001,0x0000,
X	0x80F8,0x0000,0x0001,0x0000,0x8306,0x0001,0xDB61,0x0000,
X	0xA401,0x2001,0x1E21,0x0000,0xA800,0xA001,0x2121,0x0000,
X	0x898C,0x8040,0x4081,0x0000,0x918C,0x4061,0xB361,0x0000,
X	0xB000,0x6FF1,0xB361,0x0000,0xB000,0x6FF8,0x8041,0x0000,
X	0x9000,0x4FF1,0xA161,0x0000,0x9104,0x4061,0x9E61,0x0000,
X	0xA8F8,0xA040,0x4081,0x0000,0xA800,0xA001,0x2121,0x0000,
X	0x8401,0x0001,0x1E21,0x0000,0x8306,0x0001,0xDB61,0x0000,
X	0xA0F8,0x2000,0x0001,0x0000,0xA000,0x2000,0x0001,0x0000,
X	0xB666,0x6000,0x0001,0x0000,0x8000,0x0000,0x0001,0x0000,
X	0x8000,0x0000,0x0001,0x0000,0x8000,0x0000,0x0001,0x0000,
X	0x8018,0x0006,0x0001,0x0000,0x8024,0x7182,0x1801,0x0000,
X	0x8010,0x8042,0x2401,0x0000,0x8008,0x81C2,0x3801,0x0000,
X	0x8024,0x8242,0x2001,0x0000,0x8018,0x7142,0x1C01,0x0000,
X	0x8000,0x0000,0x0001,0x0000,0x8000,0x0000,0x0001,0x0000,
X	0x8000,0x0000,0x0001,0x0000,0x8000,0x0000,0x0001,0x0000,
X	0x8000,0x0000,0x0001,0x0000,0xFFFF,0xFFFF,0xFFFF,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
END_OF_scale.cicon
if test 1933 -ne `wc -c <scale.cicon`; then
    echo shar: \"scale.cicon\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

