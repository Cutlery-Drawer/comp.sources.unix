Newsgroups: comp.sources.unix
Subject: v15i063:  A bitmap editor for Suns, Part06/06
Approved: rsalz@uunet.UU.NET

Submitted-by: Raymond T Kreisel <rayk@sbcs.sunysb.edu>
Posting-number: Volume 15, Issue 63
Archive-name: touchup/part06

THIS IS A COMPLETE REPOSTING OF THE ENTIRE PACKAGE.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 6)."
# Wrapped by rayk@sbcolor1 on Fri Apr  1 16:49:38 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f info.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"info.c\"
else
echo shar: Extracting \"info.c\" \(6537 characters\)
sed "s/^X//" >info.c <<'END_OF_info.c'
X
X/**************************************************************************
X   Touchup a bitmap graphics editor for the Sun Workstation running SunView
X   Copyright (c) 1988 by Raymond Kreisel
X   1/22/88 @ Suny Stony Brook
X
X   This program may be redistributed without fee as long as this copyright
X   notice is intact.
X
X==> PLEASE send comments and bug reports to one of the following addresses:
X
X	   Ray Kreisel
X	   CS Dept., SUNY at Stony Brook, Stony Brook NY 11794
X
X	   UUCP: {allegra, philabs, pyramid, research}!sbcs!rayk   
X	   ARPA-Internet: rayk@sbcs.sunysb.edu			
X	   CSnet: rayk@suny-sb
X	   (If nobody is home at any of the above addresses try:
X		S72QKRE@TOWSONVX.BITNET			        )
X
X "If I get home before daylight, I just might get some sleep tonight...."
X
X**************************************************************************/
X/**************************************************************************
X	file: info.c
X	purpose: this file has the functions that had the "view" pop up
X		window.  You can view the "man page", copyright notice
X		with the picture of the author (me), and the cut/paste
X   		buffer
X
X	modifications:
X		date:	Tue Mar 22 22:04:58 EST 1988
X		author:	rayk
X		changes:add comments
X**************************************************************************/
X
X#include "header.h"
X
X#include <suntool/textsw.h>
X
XFrame view_frame;
XCanvas view_canvas;
XPixwin *view_pw;
XPanel view_panel;
Xint view_flag=FALSE;
X
X
X/*
X * this function will read in the copyright notice
X * with my picture on it and display it in a new window
X */
Xinfo_init()
X{
XFILE *fp,*fopen();
Xint color_map=NULL;
Xstruct pixrect *temp_pr;
X
X   fp = fopen(INFO_IMAGE,"r");
X   if (!fp)
X   {
X      ERROR("I Could not find the information file !!!!");
X      view_flag = FALSE;
X      fclose(fp);
X      return(0);
X   }
X   temp_pr = (struct pixrect *)pr_load(fp,color_map);
X   if (!temp_pr)
X   {
X      ERROR("I Could not find the information file !!!!");
X      view_flag = FALSE;
X      fclose(fp);
X      return(0);
X   }
X   view_init(temp_pr,"Information on Touchup");
X   MY_pr_destroy(temp_pr);
X   fclose(fp);
X}
X
X
X/*
X * this function will let you view the cut/paste buffer
X * in a seperate window
X */
Xview_cut_paste()
X{
X   if (cut_buffer_pr)
X   {
X     view_init(cut_buffer_pr,"The current Cut/Paste Buffer");
X   }
X   else
X   {
X     ERROR("The CUT/PASTE buffer is empty.");
X   }
X}
X
X
X/*
X * we got a button click on "view"
X * check out what we need to view
X */
X#define VIEW_INFO 0
X#define VIEW_HELP 1
X#define VIEW_CUT_PASTE 2
Xviewer()
X{
X   switch((int)panel_get_value(view_cycle)) {
X	case VIEW_INFO: info_init();
X	  	   break;
X	case VIEW_CUT_PASTE: view_cut_paste();
X	  		break;
X	case VIEW_HELP: view_help();
X   }
X}
X
X
X/*
X * close up the view window
X */
Xview_done()
X{
X   if (view_flag)
X   {
X     window_set(view_frame, FRAME_NO_CONFIRM, TRUE, 0);
X     window_destroy(view_frame);
X     view_flag = FALSE;  
X   }
X}
X
X
X/*
X * this function will take a pixrect and create a new window
X * which we can view it in
X */
Xview_init(view_pr,frame_label)
Xstruct pixrect *view_pr;
Xchar *frame_label;
X{
XRect *r;
X
X   if (view_flag)
X   {
X      view_done();
X   }
X   view_flag = TRUE;
X
X    r = (Rect *) window_get(base_frame, WIN_RECT);
X    view_frame = window_create(base_frame,FRAME,
X		FRAME_LABEL,    frame_label,
X	        FRAME_SHOW_LABEL, TRUE,
X		WIN_SHOW,	TRUE,
X		WIN_FONT,	main_font,
X		WIN_WIDTH,	view_pr->pr_size.x+20,
X		WIN_HEIGHT,	view_pr->pr_size.y+60,
X	        WIN_X,		(r->r_width - view_pr->pr_size.x+20)/2,
X	        WIN_Y,		(r->r_height - view_pr->pr_size.y+50)/4,
X		0);
X
X    view_canvas = 
X        window_create(view_frame, CANVAS, 
X	    WIN_CONSUME_PICK_EVENTS,	WIN_NO_EVENTS,WIN_MOUSE_BUTTONS,
X					LOC_DRAG, LOC_WINENTER,
X					LOC_MOVE, 
X					0,
X		WIN_X,		0,
X		WIN_Y,		ATTR_ROW(2)+5,
X	    CANVAS_WIDTH,		view_pr->pr_size.x+5,
X	    CANVAS_HEIGHT,		view_pr->pr_size.y+5,
X	    CANVAS_AUTO_SHRINK,		TRUE,
X	    CANVAS_FIXED_IMAGE,		FALSE,
X	    CANVAS_AUTO_EXPAND,		TRUE,
X	    CANVAS_RETAINED,		TRUE,
X	    0),
X
X    view_pw = canvas_pixwin(view_canvas);
X
X    if (view_pr->pr_depth > 1)
X    {
X	pw_setcmsname(view_pw, "ray kreisel");
X	pw_putcolormap(view_pw, 0,256,temp_red,temp_green,temp_blue);
X    }
X
X    view_panel = window_create(view_frame, PANEL,
X	     PANEL_LABEL_BOLD,    	 TRUE,
X		WIN_FONT,	main_font,
X	     WIN_X,			 0,
X	     WIN_Y,			 3,
X	     WIN_HEIGHT,		 ATTR_ROW(1)+4,
X		0);
X   
X   (void)panel_create_item(view_panel, PANEL_BUTTON, 
X     PANEL_ITEM_X, ATTR_COL(0),
X     PANEL_ITEM_Y, ATTR_ROW(0),
X     PANEL_LABEL_IMAGE, panel_button_image(view_panel, "done", 5, (Pixfont *)0),
X     PANEL_NOTIFY_PROC, view_done,
X     0);
X
X  /* write the image files to the canvas */
X
X   pw_write(view_pw,0,0,view_pr->pr_size.x,
X		 view_pr->pr_size.y,PIX_SRC, view_pr,0,0);
X}   
X
X
X/*
X * this function is used to view the man page
X */
X#define VIEW_HELP_FLAG 2
Xview_help()
X{
XRect *r;
X
X   if (!file_exist(HELP_FILE))
X   {
X      ERROR("I cannot find the man page for touchup !!!");
X      return(0);
X   }
X
X   if (view_flag == VIEW_HELP_FLAG)
X   {
X      (void)window_set(view_frame, WIN_SHOW, TRUE, 0);
X      return(0);
X   }
X   else
X   {
X      if (view_flag)
X 	 view_done();
X   }
X   view_flag = VIEW_HELP_FLAG;
X
X    r = (Rect *) window_get(base_frame, WIN_RECT);
X    view_frame = window_create(base_frame,FRAME,
X		FRAME_LABEL,    "Help window",
X	        FRAME_SHOW_LABEL, TRUE,
X		WIN_SHOW,	TRUE,
X		WIN_FONT,	main_font,
X	        WIN_X,		(r->r_width - 600+20)/2,
X	        WIN_Y,		(r->r_height - 512+50)/4,
X		0);
X
X    view_panel = window_create(view_frame, PANEL,
X	     PANEL_LABEL_BOLD,    	 TRUE,
X		WIN_FONT,	main_font,
X	     WIN_X,			 0,
X	     WIN_Y,			 3,
X	     WIN_HEIGHT,		 ATTR_ROW(1)+4,
X		0);
X   
X   (void)panel_create_item(view_panel, PANEL_BUTTON, 
X     PANEL_ITEM_X, ATTR_COL(0),
X     PANEL_ITEM_Y, ATTR_ROW(0),
X     PANEL_LABEL_IMAGE, panel_button_image(view_panel, "done", 5, (Pixfont *)0),
X     PANEL_NOTIFY_PROC, view_done,
X     0);
X
X
X    (void)window_create(view_frame, TEXTSW,
X		WIN_ERROR_MSG, 		"I cannot find the man page for touchup",
X                WIN_X,                  0,
X		WIN_Y,			ATTR_ROW(2)+5,
X                WIN_HEIGHT,             512,
X                WIN_WIDTH,              600,
X		TEXTSW_FONT,		main_font,
X                TEXTSW_IGNORE_LIMIT,    TEXTSW_INFINITY,
X                TEXTSW_AUTO_INDENT,     TRUE,
X                TEXTSW_BROWSING,        TRUE,
X                TEXTSW_DISABLE_LOAD,    TRUE,
X                TEXTSW_DISABLE_CD,      TRUE,
X        	TEXTSW_FILE,    	HELP_FILE,
X                0);
X
X  window_fit(view_frame);
X}   
X
X
END_OF_info.c
if test 6537 -ne `wc -c <info.c`; then
    echo shar: \"info.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f interface.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"interface.c\"
else
echo shar: Extracting \"interface.c\" \(20307 characters\)
sed "s/^X//" >interface.c <<'END_OF_interface.c'
X
X/**************************************************************************
X   Touchup a bitmap graphics editor for the Sun Workstation running SunView
X   Copyright (c) 1988 by Raymond Kreisel
X   1/22/88 @ Suny Stony Brook
X
X   This program may be redistributed without fee as long as this copyright
X   notice is intact.
X
X==> PLEASE send comments and bug reports to one of the following addresses:
X
X	   Ray Kreisel
X	   CS Dept., SUNY at Stony Brook, Stony Brook NY 11794
X
X	   UUCP: {allegra, philabs, pyramid, research}!sbcs!rayk   
X	   ARPA-Internet: rayk@sbcs.sunysb.edu			
X	   CSnet: rayk@suny-sb
X	   (If nobody is home at any of the above addresses try:
X		S72QKRE@TOWSONVX.BITNET			        )
X
X "If I get home before daylight, I just might get some sleep tonight...."
X
X**************************************************************************/
X/**************************************************************************
X	file: interface.c
X	purpose: this file contains all of the window defs for touchup
X
X	modifications:
X		date:	Tue Mar 22 22:04:58 EST 1988
X		author:	rayk
X		changes:add comments
X**************************************************************************/
X
X#include"header.h"
X
X
XCursor fat_cursor;
X
X
Xstatic short icon_data[] = {
X#include "touchup.icon"
X};
Xstatic mpr_static(touchup_pr, 64, 64, 1, icon_data);
X
Xstatic short cursor_data[] = {
X#include "fat_cursor"
X};
Xstatic mpr_static(my_fat_cursor, 16, 16, 1, cursor_data);
X
X
X
X    Frame base_frame,fat_frame,color_frame,command_frame;
X    Canvas canvas,fat_canvas,color_canvas;
X    Pixwin *pw,*fat_pw,*color_pw;
Xstatic Scrollbar	vertical_sb, horizontal_sb;
X    Panel       panel,fat_panel,color_panel,pattern_panel,
X		brush_panel,region_panel,command_panel;
X    Panel_item magnify_cycle,grid_cycle,view_cycle;
X    Panel_item  file_panel,brush_choice,mono_cycle,save_cycle,border_cycle,
X		msg_string,color_button,text_panel,current_pattern,
X		load_cycle,pattern_choice,command_choice,region_choice,
X		compress_cycle,text_size_item,undo_button;
X
X   struct pixrect *pattern[PATTERN_NO];
X   struct pixrect *brushes[BRUSH_NO];
X  
X
X/*
X * Build all of the window that we need for touchup
X */
Xinit_windows(argc,argv) int argc; char *argv[];
X{
X
X    base_frame = window_create(NULL,FRAME,
X		FRAME_ARGS,	argc,argv,
X		FRAME_LABEL,    "TouchUp version 2.2",
X		FRAME_ICON,	    icon_create(ICON_IMAGE, &touchup_pr, 0),
X		FRAME_INHERIT_COLORS,  TRUE,
X		WIN_FONT,	main_font,
X		WIN_WIDTH,	1030,
X		WIN_HEIGHT,	675+ATTR_ROW(10),
X		WIN_X,		10,
X		WIN_Y,		10,
X		0);
X    panel = window_create(base_frame, PANEL,
X	     PANEL_LABEL_BOLD,    	 TRUE,
X	     WIN_FONT,		 	 main_font,
X	     WIN_X,			 0,
X	     WIN_Y,			 3,
X	     WIN_HEIGHT,		 ATTR_ROW(5),
X		0);
X
X
X
X    vertical_sb = scrollbar_create((char*)0);
X    horizontal_sb = scrollbar_create((char*)0);
X
X    canvas = 
X        window_create(base_frame, CANVAS, 
X	    WIN_VERTICAL_SCROLLBAR,	vertical_sb,
X	    WIN_HORIZONTAL_SCROLLBAR,	horizontal_sb,
X	    WIN_CONSUME_PICK_EVENTS,	WIN_NO_EVENTS,WIN_MOUSE_BUTTONS,
X					LOC_DRAG,
X					LOC_MOVE, 
X					0,
X	    WIN_EVENT_PROC, 		handle_event,
X	    WIN_WIDTH,			780,
X/*	    WIN_HEIGHT,		 	650, */
X	    WIN_X,			PATTERN_SIZE*2+70,
X	    WIN_Y,			ATTR_ROW(7)+12,
X	    CANVAS_AUTO_SHRINK,		FALSE,
X	    CANVAS_AUTO_EXPAND,		FALSE,
X	    CANVAS_FIXED_IMAGE,		FALSE,
X	    CANVAS_RETAINED,		TRUE,
X	    CANVAS_WIDTH,		image_wid,
X	    CANVAS_HEIGHT,		image_hgt,
X	    WIN_BELOW,			panel,
X	    0),
X
X
X    pw = canvas_pixwin(canvas);
X
X
X    command_panel = window_create(base_frame, PANEL,
X	     WIN_FONT,			main_font,
X/*	     WIN_X,			 1000-(COMMAND_SIZE*2+32), */
X	     WIN_Y,			 ATTR_ROW(6)+12,
X	     WIN_WIDTH,			 COMMAND_SIZE*2+5,
X	     WIN_HEIGHT,		 COMMAND_SIZE*COMMAND_NO/2+9,
X	     WIN_RIGHT_OF,		 canvas,
X	     WIN_BELOW,			 panel,
X		0);
X
X   command_choice = panel_create_item(command_panel, PANEL_CHOICE, 
X	     PANEL_LABEL_BOLD,    	 TRUE,
X	     PANEL_SHOW_MENU,		 FALSE,
X	     PANEL_LAYOUT,		PANEL_VERTICAL,
X	     PANEL_VALUE, 		6,
X	     PANEL_LABEL_X,		10,
X	     PANEL_LABEL_Y,		4,
X	     PANEL_DISPLAY_LEVEL,	PANEL_ALL,
X	     PANEL_FEEDBACK,		PANEL_INVERTED,
X	     PANEL_CHOICE_IMAGES,	&command12_pr,&command5_pr,
X					&command13_pr,&command14_pr,
X					&command1_pr,&command6_pr,
X					&command15_pr,&command3_pr,
X					&command4_pr,&command16_pr,
X					&command11_pr,&command10_pr,
X					&command2_pr,&command7_pr,
X					&command9_pr,&command8_pr,
X					0,
X	     PANEL_CHOICE_XS,		1,51,1,51,1,51,
X					1,51,1,51,1,51,
X					1,51,1,51,
X					0,
X	     
X	     PANEL_CHOICE_YS,		1,1,
X					50,50,
X					99,99,
X					148,148,
X					197,197,
X					246,246,
X					295,295,
X					344,344,
X					0,
X	     PANEL_NOTIFY_PROC, 	command_handle,
X	     0);
X
X
X    brush_panel = window_create(base_frame, PANEL,
X	     WIN_FONT,			main_font,
X	     WIN_SHOW,			TRUE,
X	     WIN_X,			 1000-(COMMAND_SIZE*2+32),
X	     WIN_Y,			 COMMAND_SIZE*COMMAND_NO/2+9+ATTR_ROW(6)+14,
X	     WIN_WIDTH,			 COMMAND_SIZE*2+5,
X/*	     WIN_HEIGHT,		 COMMAND_SIZE*4+15, */
X	     WIN_BELOW,			 command_panel,
X	     WIN_RIGHT_OF,		 canvas,
X		0);
X
X   brush_choice = panel_create_item(brush_panel, PANEL_CHOICE, 
X	     PANEL_LABEL_BOLD,    	 TRUE,
X	     PANEL_SHOW_MENU,		 FALSE,
X	     PANEL_LAYOUT,		PANEL_VERTICAL,
X	     PANEL_VALUE, 		3,
X	     PANEL_LABEL_X,		10,
X	     PANEL_LABEL_Y,		4,
X	     PANEL_DISPLAY_LEVEL,	PANEL_ALL,
X	     PANEL_FEEDBACK,		PANEL_MARKED,
X	     PANEL_CHOICE_IMAGES,	&brush1_pr,&brush2_pr,
X					&brush3_pr,&brush4_pr,
X					&brush5_pr,&brush6_pr,
X					0,
X	     PANEL_CHOICE_XS,		51,51,51,51,51,51,
X					0,
X	     
X	     PANEL_CHOICE_YS,		1,
X					35,69,
X					103,137,
X					171,
X					0,
X	     PANEL_MARK_XS,		3,
X					0,
X	     
X	     PANEL_MARK_YS,		1,
X					35,69,
X					103,137,
X					171,
X					0,
X	     0);
X
X  brushes[0] = &brush1_pr;
X  brushes[1] = &brush2_pr;
X  brushes[2] = &brush3_pr;
X  brushes[3] = &brush4_pr;
X  brushes[4] = &brush5_pr;
X  brushes[5] = &brush6_pr;
X
X
X
X
X    region_panel = window_create(base_frame, PANEL,
X	     WIN_FONT,			main_font,
X	     WIN_SHOW,			FALSE,
X	     WIN_X,			 1000-(COMMAND_SIZE*2+32),
X	     WIN_Y,			 COMMAND_SIZE*COMMAND_NO/2+9+ATTR_ROW(6)+14,
X	     WIN_WIDTH,			 COMMAND_SIZE*2+5,
X/*	     WIN_HEIGHT,		 COMMAND_SIZE*4+4, */
X	     WIN_BELOW,			 command_panel,
X	     WIN_RIGHT_OF,		 canvas,
X		0);
X
X   region_choice = panel_create_item(region_panel, PANEL_CHOICE, 
X	     PANEL_LABEL_BOLD,    	 TRUE,
X	     PANEL_SHOW_MENU,		 FALSE,
X	     PANEL_LAYOUT,		PANEL_VERTICAL,
X	     PANEL_VALUE, 		5,
X	     PANEL_LABEL_X,		10,
X	     PANEL_LABEL_Y,		4,
X	     PANEL_DISPLAY_LEVEL,	PANEL_ALL,
X	     PANEL_FEEDBACK,		PANEL_INVERTED,
X	     PANEL_CHOICE_IMAGES,	&reg_command2_pr,&reg_command3_pr,
X					&reg_command4_pr,&reg_command7_pr,
X					&reg_command5_pr,&reg_command6_pr,
X					&reg_command8_pr,&reg_command1_pr,
X					0,
X	     PANEL_CHOICE_XS,		1,51,1,51,1,51,1,51,
X					0,
X	     
X	     PANEL_CHOICE_YS,		1,1,
X					50,50,
X					99,99,
X					148,148,
X					0,
X	     PANEL_NOTIFY_PROC, 	region_handle,
X	     0);
X
X
X    pattern_panel = window_create(base_frame, PANEL,
X	     WIN_FONT,			main_font,
X	     WIN_X,			 0,
X	     WIN_Y,			ATTR_ROW(6)+12,
X 	     WIN_BELOW,			panel,
X	     WIN_WIDTH,			 PATTERN_SIZE*2+65,
X/*	     WIN_HEIGHT,		 PATTERN_SIZE*PATTERN_NO/2+22, */
X		0);
X
X   (void)panel_create_item(pattern_panel, PANEL_BUTTON, 
X     PANEL_ITEM_X, ATTR_COL(0),
X     PANEL_ITEM_Y, PATTERN_SIZE*PATTERN_NO/2+40,
X     PANEL_LABEL_IMAGE, panel_button_image(panel, "define pattern", 14, (Pixfont *)0),
X     PANEL_NOTIFY_PROC, pattern_define,
X     0);
X
X   pattern_choice = panel_create_item(pattern_panel, PANEL_CHOICE, 
X	     PANEL_LABEL_BOLD,    	 TRUE,
X	     PANEL_SHOW_MENU,		 FALSE,
X	     PANEL_LAYOUT,		PANEL_VERTICAL,
X	     PANEL_LABEL_X,		10,
X	     PANEL_LABEL_Y,		4,
X	     PANEL_VALUE, 		0,
X	     PANEL_DISPLAY_LEVEL,	PANEL_ALL,
X	     PANEL_FEEDBACK,		PANEL_MARKED,
X	     PANEL_NOTIFY_PROC, 	select_pattern,
X	     PANEL_CHOICE_IMAGES,	&pattern1_pr,&pattern2_pr,&pattern3_pr,
X					&pattern4_pr,&pattern5_pr,
X					&pattern6_pr,&pattern7_pr,
X					&pattern8_pr,&pattern9_pr,
X					&pattern10_pr,
X	     				&pattern11_pr,&pattern12_pr,&pattern13_pr,
X					&pattern14_pr,&pattern15_pr,
X					&pattern16_pr,&pattern17_pr,
X					&pattern18_pr,&pattern19_pr,
X					&pattern20_pr,
X	     				&pattern21_pr,&pattern22_pr,&pattern23_pr,
X					&pattern24_pr,&pattern25_pr,
X					&pattern26_pr,&pattern27_pr,
X					&pattern28_pr,&pattern29_pr,
X					&pattern30_pr,
X	     				&pattern31_pr,&pattern32_pr,&pattern33_pr,
X					&pattern34_pr,&pattern35_pr,
X					&pattern36_pr,&pattern37_pr,
X					&pattern38_pr,&pattern39_pr,
X					&pattern40_pr,0,
X	     PANEL_CHOICE_XS,		25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,0,
X	     
X	     PANEL_CHOICE_YS,		1+35,33+35,65+35,97+35,129+35,161+35,193+35,225+35,257+35,289+35,
X					321+35,353+35,385+35,417+35,449+35,481+35,513+35,545+35,577+35,609+35,
X	     				1+35,33+35,65+35,97+35,129+35,161+35,193+35,225+35,257+35,289+35,
X					321+35,353+35,385+35,417+35,449+35,481+35,513+35,545+35,577+35,609+35,0,
X	     PANEL_MARK_XS,		3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,0,
X	     PANEL_MARK_YS,		8+35,40+35,72+35,104+35,136+35,168+35,200+35,232+35,266+35,296+35,
X					328+35,360+35,392+35,426+35,456+35,488+35,520+35,552+35,584+35,616+35,
X	     				8+35,40+35,72+35,104+35,136+35,168+35,200+35,232+35,266+35,296+35,
X					328+35,360+35,392+35,426+35,456+35,488+35,520+35,552+35,584+35,616+35,0,
X
X     0);
X
X  pattern[0] = &pattern1_pr;
X  pattern[1] = &pattern2_pr;
X  pattern[2] = &pattern3_pr;
X  pattern[3] = &pattern4_pr;
X  pattern[4] = &pattern5_pr;
X  pattern[5] = &pattern6_pr;
X  pattern[6] = &pattern7_pr;
X  pattern[7] = &pattern8_pr;
X  pattern[8] = &pattern9_pr;
X  pattern[9] = &pattern10_pr;
X  pattern[10] = &pattern11_pr;
X  pattern[11] = &pattern12_pr;
X  pattern[12] = &pattern13_pr;
X  pattern[13] = &pattern14_pr;
X  pattern[14] = &pattern15_pr;
X  pattern[15] = &pattern16_pr;
X  pattern[16] = &pattern17_pr;
X  pattern[17] = &pattern18_pr;
X  pattern[18] = &pattern19_pr;
X  pattern[19] = &pattern20_pr;
X  pattern[20] = &pattern21_pr;
X  pattern[21] = &pattern22_pr;
X  pattern[22] = &pattern23_pr;
X  pattern[23] = &pattern24_pr;
X  pattern[24] = &pattern25_pr;
X  pattern[25] = &pattern26_pr;
X  pattern[26] = &pattern27_pr;
X  pattern[27] = &pattern28_pr;
X  pattern[28] = &pattern29_pr;
X  pattern[29] = &pattern30_pr;
X  pattern[30] = &pattern31_pr;
X  pattern[31] = &pattern32_pr;
X  pattern[32] = &pattern33_pr;
X  pattern[33] = &pattern34_pr;
X  pattern[34] = &pattern35_pr;
X  pattern[35] = &pattern36_pr;
X  pattern[36] = &pattern37_pr;
X  pattern[37] = &pattern38_pr;
X  pattern[38] = &pattern39_pr;
X  pattern[39] = &pattern40_pr;
X
X   current_pattern = panel_create_item(pattern_panel, PANEL_MESSAGE, 
X     PANEL_ITEM_X, ATTR_COL(6),
X     PANEL_ITEM_Y, 3,
X     PANEL_LABEL_IMAGE, &pattern1_pr,
X     0);
X
X    color_frame = window_create(base_frame,FRAME,
X		FRAME_LABEL,    "Color Pallet",
X	        FRAME_SHOW_LABEL, TRUE,
X		WIN_FONT,	main_font,
X		WIN_WIDTH,	PALET_BLOCK*16+9,
X		WIN_HEIGHT,	PALET_BLOCK*(16+3)+20+ATTR_ROW(2),
X		WIN_X,		650,
X		WIN_Y,		10,
X		0);
X
X    color_canvas = 
X        window_create(color_frame, CANVAS, 
X	    WIN_CONSUME_PICK_EVENTS,	WIN_NO_EVENTS, WIN_MOUSE_BUTTONS,
X					LOC_DRAG,
X					LOC_MOVE, 
X					0,
X	    WIN_EVENT_PROC, 		color_handle_event,
X		WIN_X,		0,
X		WIN_Y,		ATTR_ROW(2)+5,
X	    CANVAS_WIDTH,		PALET_BLOCK*16,
X	    CANVAS_HEIGHT,		PALET_BLOCK*(16+3),
X	    CANVAS_AUTO_SHRINK,		FALSE,
X	    CANVAS_FIXED_IMAGE,		FALSE,
X	    CANVAS_AUTO_EXPAND,		TRUE,
X	    CANVAS_REPAINT_PROC,	draw_colormap,
X	    CANVAS_RESIZE_PROC,		draw_colormap,
X	    0),
X
X    color_pw = canvas_pixwin(color_canvas);
X
X    color_panel = window_create(color_frame, PANEL,
X	     PANEL_LABEL_BOLD,    	 TRUE,
X		WIN_FONT,	main_font,
X	     WIN_X,			 0,
X	     WIN_Y,			 3,
X	     WIN_WIDTH,			 PALET_BLOCK*16+1,
X	     WIN_HEIGHT,		 ATTR_ROW(1)+4,
X		0);
X
X
X   (void)panel_create_item(color_panel, PANEL_BUTTON, 
X     PANEL_ITEM_X, ATTR_COL(0),
X     PANEL_ITEM_Y, ATTR_ROW(0),
X     PANEL_LABEL_IMAGE, panel_button_image(color_panel, "done", 5, (Pixfont *)0),
X     PANEL_NOTIFY_PROC, color_done,
X     0);
X
X
X
X   
X    fat_frame = window_create(base_frame,FRAME,
X		FRAME_LABEL,    "Big bits",
X	        FRAME_SHOW_LABEL, TRUE,
X		WIN_CURSOR,	cursor_create(CURSOR_IMAGE, &my_fat_cursor,0),
X		WIN_FONT,	main_font,
X		WIN_WIDTH,	ATTR_COL(31),
X		WIN_HEIGHT,	ATTR_ROW(24),
X	     WIN_X,			 0,
X	     WIN_Y,			ATTR_ROW(8)+12,
X		0);
X
X    fat_canvas = 
X        window_create(fat_frame, CANVAS, 
X	    WIN_CONSUME_PICK_EVENTS,	WIN_NO_EVENTS,WIN_MOUSE_BUTTONS,
X					LOC_DRAG,
X					LOC_MOVE, 
X					0,
X	    WIN_CURSOR,			cursor_create(CURSOR_IMAGE, &my_fat_cursor,0),
X	    WIN_EVENT_PROC, 		fat_handle_event,
X		WIN_X,		0,
X		WIN_Y,		ATTR_ROW(2)+5,
X	    CANVAS_WIDTH,		ATTR_COL(30),
X	    CANVAS_HEIGHT,		ATTR_ROW(14),
X	    CANVAS_AUTO_SHRINK,		TRUE,
X	    CANVAS_FIXED_IMAGE,		FALSE,
X	    CANVAS_AUTO_EXPAND,		TRUE,
X	    CANVAS_RETAINED,		TRUE,
X	    0),
X
X    fat_pw = canvas_pixwin(fat_canvas);
X
X    fat_panel = window_create(fat_frame, PANEL,
X	     PANEL_LABEL_BOLD,    	 TRUE,
X		WIN_FONT,	main_font,
X	     WIN_X,			 0,
X	     WIN_Y,			 3,
X	     WIN_WIDTH,			 ATTR_COL(30),
X	     WIN_HEIGHT,		 ATTR_ROW(1)+4,
X		0);
X   
X    magnify_cycle = 
X	panel_create_item(fat_panel, PANEL_CYCLE,
X	    PANEL_ITEM_X, ATTR_COL(8),
X	    PANEL_ITEM_Y, ATTR_ROW(0),
X	    PANEL_LABEL_STRING, "Magnification:",
X	    PANEL_CHOICE_STRINGS, "1x", "2x","3x","4x",
X				  "5x","6x","7x","8x","9x",
X				  "10x","11x","12x","13x","14x",
X				  "15x","16x","17x","18x","19x",
X				  "20x", 0,
X	    PANEL_VALUE, 8,
X	    PANEL_NOTIFY_PROC, fat_parms,
X	    0);
X
X   (void)panel_create_item(fat_panel, PANEL_BUTTON, 
X     PANEL_ITEM_X, ATTR_COL(0),
X     PANEL_ITEM_Y, ATTR_ROW(0),
X     PANEL_LABEL_IMAGE, panel_button_image(fat_panel, "done", 5, (Pixfont *)0),
X     PANEL_NOTIFY_PROC, fat_done,
X     0);
X
X
X   (void)panel_create_item(panel, PANEL_BUTTON, 
X     PANEL_ITEM_X, ATTR_COL(8),
X     PANEL_ITEM_Y, ATTR_ROW(1),
X     PANEL_LABEL_IMAGE, panel_button_image(panel, "view", 5, (Pixfont *)0),
X     PANEL_NOTIFY_PROC, viewer,
X     0);
X
X    view_cycle =
X	panel_create_item(panel, PANEL_CYCLE,
X	    PANEL_ITEM_X, ATTR_COL(16),
X	    PANEL_ITEM_Y, ATTR_ROW(1),
X	    PANEL_LABEL_STRING, "View:",
X	    PANEL_CHOICE_STRINGS, "Touchup info", "man page (help)", "Cut/Paste buffer", 0,
X	    PANEL_VALUE, 1,
X	    0);
X
X   (void)panel_create_item(panel, PANEL_BUTTON, 
X     PANEL_ITEM_X, ATTR_COL(8),
X     PANEL_ITEM_Y, ATTR_ROW(0),
X     PANEL_LABEL_IMAGE, panel_button_image(panel, "load", 5, (Pixfont *)0),
X     PANEL_NOTIFY_PROC, load_file,
X     0);
X    load_cycle =
X	panel_create_item(panel, PANEL_CYCLE,
X	    PANEL_ITEM_X, ATTR_COL(16),
X	    PANEL_ITEM_Y, ATTR_ROW(0),
X	    PANEL_LABEL_STRING, "Load:",
X	    PANEL_CHOICE_STRINGS, "entire image", "Cut/Paste buffer", 0,
X	    PANEL_VALUE, LOAD_ALL,
X	    0);
X
X   (void)panel_create_item(panel, PANEL_BUTTON, 
X     PANEL_ITEM_X, ATTR_COL(45),
X     PANEL_ITEM_Y, ATTR_ROW(0),
X     PANEL_LABEL_IMAGE, panel_button_image(panel, "save", 5, (Pixfont *)0),
X     PANEL_NOTIFY_PROC, save_file,
X     0);
X
X    save_cycle =
X	panel_create_item(panel, PANEL_CYCLE,
X	    PANEL_ITEM_X, ATTR_COL(53),
X	    PANEL_ITEM_Y, ATTR_ROW(0),
X	    PANEL_LABEL_STRING, "Save:",
X	    PANEL_CHOICE_STRINGS, "entire image", "Cut/Paste buffer", 0,
X	    PANEL_VALUE, SAVE_ALL,
X	    0);
X
X    compress_cycle =
X	panel_create_item(panel, PANEL_CYCLE,
X	    PANEL_ITEM_X, ATTR_COL(53),
X	    PANEL_ITEM_Y, ATTR_ROW(1),
X	    PANEL_LABEL_STRING, "Save:",
X	    PANEL_CHOICE_STRINGS, "Standard format","Compressed",0,
X	    PANEL_VALUE, 0,
X	    0);
X
X   (void)panel_create_item(panel, PANEL_BUTTON, 
X     PANEL_ITEM_X, ATTR_COL(0),
X     PANEL_ITEM_Y, ATTR_ROW(0),
X     PANEL_LABEL_IMAGE, panel_button_image(panel, "quit", 5, (Pixfont *)0),
X     PANEL_NOTIFY_PROC, quit,
X     0);
X
X   undo_button = panel_create_item(panel, PANEL_BUTTON, 
X     PANEL_ITEM_X, ATTR_COL(0),
X     PANEL_ITEM_Y, ATTR_ROW(2),
X     PANEL_LABEL_IMAGE, panel_button_image(panel, "undo", 5, (Pixfont *)0),
X     PANEL_NOTIFY_PROC, undo_screen,
X     0);
X
X    grid_cycle =
X	panel_create_item(panel, PANEL_CYCLE,
X	    PANEL_ITEM_X, ATTR_COL(8),
X	    PANEL_ITEM_Y, ATTR_ROW(2),
X	    PANEL_LABEL_STRING, "Grid size:",
X	    PANEL_CHOICE_STRINGS, "none","5","10","15","20","25","30",0,
X	    PANEL_VALUE, grid_size,
X	    PANEL_NOTIFY_PROC, change_parms,
X	    0);
X
X    border_cycle =
X	panel_create_item(panel, PANEL_CYCLE,
X	    PANEL_ITEM_X, ATTR_COL(30),
X	    PANEL_ITEM_Y, ATTR_ROW(2),
X	    PANEL_LABEL_STRING, "Borders:",
X	    PANEL_CHOICE_STRINGS, "No","Yes",0,
X	    PANEL_VALUE, 1,
X	    0);
X
X   file_panel=panel_create_item(panel, PANEL_TEXT, 
X     PANEL_ITEM_X, ATTR_COL(80),
X     PANEL_ITEM_Y, ATTR_ROW(0),
X     PANEL_VALUE, file_name,
X     PANEL_VALUE_DISPLAY_LENGTH, 35,
X     PANEL_LABEL_STRING, "Filename:",
X     PANEL_NOTIFY_PROC, make_new_name,
X     PANEL_NOTIFY_STRING, "\033",
X     PANEL_VALUE_STORED_LENGTH, MAX_FILE_NAME,
X     PANEL_SHOW_MENU, FALSE,
X     0);
X
X   text_panel=panel_create_item(panel, PANEL_TEXT, 
X     PANEL_ITEM_X, ATTR_COL(80),
X     PANEL_ITEM_Y, ATTR_ROW(1),
X     PANEL_VALUE, "",
X     PANEL_VALUE_DISPLAY_LENGTH, 32,
X     PANEL_LABEL_STRING, "Text string:",
X     PANEL_VALUE_STORED_LENGTH, MAX_FILE_NAME,
X     PANEL_SHOW_MENU, FALSE,
X     0);
X
X
X        text_size_item = panel_create_item(panel,PANEL_CYCLE,
X                                          PANEL_ITEM_X, ATTR_COL(80),
X                                          PANEL_ITEM_Y, ATTR_ROW(2),
X					  PANEL_LABEL_STRING, "Fonts:",
X                                          PANEL_CHOICE_STRINGS, "ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X								"ABC abc 123",
X                                                                0,
X                                          PANEL_CHOICE_FONTS, 
X                                         		      cour_r_10,
X                                                              cour_r_12,
X                                                              cour_r_16,
X                                                              cour_r_24,
X							      cour_b_10,
X                                                              cour_b_12,
X                                                              cour_b_16,
X                                                              cour_b_24,
X                                                              serif_r_10,
X                                                              serif_r_11,
X                                                              serif_r_16,
X							      screen_r_7,
X							      screen_r_11,
X							      screen_r_12,
X							      screen_r_14,
X							      screen_b_12,
X							      screen_b_14,
X							      pcfont_b_14,
X							      pcfont_r_14,
X                                                              0,
X                                          0);
X
X
X    mono_cycle =
X	panel_create_item(panel, PANEL_CYCLE,
X	    PANEL_ITEM_X, ATTR_COL(48),
X	    PANEL_ITEM_Y, ATTR_ROW(2),
X	    PANEL_LABEL_STRING, "Draw color",
X	    PANEL_CHOICE_STRINGS, "WHITE", "BLACK",
X				   0,
X	    PANEL_VALUE, 1,
X	    PANEL_NOTIFY_PROC, change_parms,
X	    0);
X
X   color_button = panel_create_item(panel, PANEL_BUTTON, 
X     PANEL_ITEM_X, ATTR_COL(52),
X     PANEL_ITEM_Y, ATTR_ROW(2),
X     PANEL_SHOW_ITEM, FALSE,
X     PANEL_LABEL_IMAGE, panel_button_image(panel, "color", 5, (Pixfont *)0),
X     PANEL_NOTIFY_PROC, color_mode,
X     0);
X
X   msg_string = panel_create_item(panel, PANEL_MESSAGE, 
X     PANEL_ITEM_X, ATTR_COL(0),
X     PANEL_ITEM_Y, ATTR_ROW(4),
X     PANEL_LABEL_BOLD,    TRUE,
X     PANEL_LABEL_STRING, "",
X     0);
X
X  fat_cursor = window_get(canvas,WIN_CURSOR);
X  cursor_set(fat_cursor,CURSOR_OP,PIX_SRC^PIX_DST,0);
X  window_set(canvas,WIN_CURSOR,fat_cursor,0);
X
X  fat_cursor = window_get(fat_canvas,WIN_CURSOR);
X  cursor_set(fat_cursor,CURSOR_OP,PIX_SRC^PIX_DST,0);
X  window_set(fat_canvas,WIN_CURSOR,fat_cursor,0);
X
X}
X
END_OF_interface.c
if test 20307 -ne `wc -c <interface.c`; then
    echo shar: \"interface.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f magnify.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"magnify.c\"
else
echo shar: Extracting \"magnify.c\" \(1789 characters\)
sed "s/^X//" >magnify.c <<'END_OF_magnify.c'
X#include "header.h"
X
X/*
X *  Magnifying glass		(for Sun-3 workstations)
X *
X *  Copyright 1986, 1987 by Scott Schwartz
X *  This program may be copied with the provision that this copyright 
X *  message remains, and that further distribution of this code and it's 
X *  derivatives is not subject to additional restrictions.
X * 
X *  Lots of changes, but no Copyright, by Mark Weiser.
X * 
X *  compile with -lsuntool -lsunwindow -lpixrect
X *
X */
X
X
X/* global vars */
Xstatic struct pixrect	*tmpdst=NULL;
X
X
Xquit_mag()
X{
X MY_pr_destroy(tmpdst);
X}
X
X
Xinit_mag()
X{
X MY_pr_destroy(tmpdst);
X tmpdst = my_mem_create(SCREEN_MAX_X, SCREEN_MAX_Y, image_depth);
X}
X
X
X/*
X * pw_mag copies a magnified view of spr to dpw using pixel replication.
X * the arguments are the same as those to the pw_rop library call, except
X * that magnification is passed instead of raster-op.
X */
Xvoid pw_mag(dpw, dx, dy, w, h, mag, spr, sx, sy)
X	Pixwin *dpw;	/* destination pixwin */
X	int dx, dy;  	/* destination x,y */
X	int w, h;	/* width and height of block to copy */
X	int mag; 	/* magnification */
X	struct pixrect *spr;	/* source pixrect */
X	int sx,sy;	/* location in source to copy from */
X{
X	/* locals */
X	register short jmax = h/mag + 1, imax = w/mag + 1;
X	register short x, y, delta;
X
X	struct pixrect r;	/* holds the size of the drawing region when */
X			/* gaining access to the screen */
X	r.pr_size.x = w;
X	r.pr_size.y = h;
X
X	for (x = 0; x < imax; x += 1) {
X		for (delta = 0; delta < mag; delta += 1) {
X			pr_rop(tmpdst, x*mag+delta, 0, 1, jmax, PIX_SRC|PIX_DONTCLIP, spr, sx+x, sy);
X		}
X	}
X	for (y = jmax; y >= 0; y -= 1) {
X		for (delta = 0; delta < mag; delta += 1) {
X			pr_rop(tmpdst, 0, y*mag+delta, w, 1, PIX_SRC|PIX_DONTCLIP, tmpdst, 0, y);
X		}
X	}
X
X	/* draw */
X	pw_rop(dpw, dx, dy, w, h, PIX_SRC, tmpdst, 0, 0);
X}
END_OF_magnify.c
if test 1789 -ne `wc -c <magnify.c`; then
    echo shar: \"magnify.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f oval.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"oval.c\"
else
echo shar: Extracting \"oval.c\" \(4269 characters\)
sed "s/^X//" >oval.c <<'END_OF_oval.c'
X
X/**************************************************************************
X   Touchup a bitmap graphics editor for the Sun Workstation running SunView
X   Copyright (c) 1988 by Raymond Kreisel
X   1/22/88 @ Suny Stony Brook
X
X   This program may be redistributed without fee as long as this copyright
X   notice is intact.
X
X==> PLEASE send comments and bug reports to one of the following addresses:
X
X	   Ray Kreisel
X	   CS Dept., SUNY at Stony Brook, Stony Brook NY 11794
X
X	   UUCP: {allegra, philabs, pyramid, research}!sbcs!rayk   
X	   ARPA-Internet: rayk@sbcs.sunysb.edu			
X	   CSnet: rayk@suny-sb
X	   (If nobody is home at any of the above addresses try:
X		S72QKRE@TOWSONVX.BITNET			        )
X
X "If I get home before daylight, I just might get some sleep tonight...."
X
X**************************************************************************/
X/**************************************************************************
X	file: oval.c
X	purpose: this file contain the functions that draw ovals
X
X	modifications:
X		date:	Tue Mar 22 22:04:58 EST 1988
X		author:	rayk
X		changes:add comments
X**************************************************************************/
X
X#include"header.h"
X
X
X/*
X * draw an oval by making the sides by vectors and ends by semicircles
X */
X     draw_oval(pw, center_x,center_y, curr_pos_x,curr_pos_y,flag)
X
X       Pixwin            *pw;
X       int		 center_x,center_y,curr_pos_x,curr_pos_y;
X       int                flag;
X   
X     {    
X       struct  pr_pos     center,
X                         curr_pos;
X        int             x, y, radius,
X			error, npts,
X		        h_width, h_height,
X			x_off, y_off,ROP;
X
X	if (flag)
X	 {
X	  if (image_depth > 1)
X  	    ROP = PIX_SRC;
X	  else
X	    ROP = PIX_SET;
X	 }
X        else
X	   ROP = PIX_XOR;
X
X	center.x = center_x;
X	center.y = center_y;
X	curr_pos.x = curr_pos_x;
X	curr_pos.y = curr_pos_y;
X
X          h_width = abs(curr_pos.x - center.x);
X          h_height = abs(curr_pos.y - center.y);
X          radius = MIN(h_width, h_height);
X  
X         /*
X	  * draw line section of oval
X          */
X          if (radius == h_height)
X           { x_off = h_width-radius;   y_off = 0;
X             pw_vector(pw, center.x-x_off, center.y+radius,
X                       center.x+x_off, center.y+radius, ROP, cur_color);
X             pw_vector(pw, center.x-x_off, center.y-radius,
X                       center.x+x_off, center.y-radius, ROP, cur_color);
X           }
X          else
X           { x_off = 0;   y_off = h_height-radius;
X             pw_vector(pw, center.x-radius, center.y-y_off,
X                       center.x-radius, center.y+y_off, ROP, cur_color);
X             pw_vector(pw, center.x+radius, center.y-y_off,
X                       center.x+radius, center.y+y_off, ROP, cur_color);
X           }
X	   /*
X	    * draw rounded corners of oval
X	    */
X	   x = 0;  y = radius; npts = 0;
X	   error = 3 - (radius << 1);
X
X         while (x < y)
X         {
X           ptlist[npts].x=center.x+(x+x_off); ptlist[npts++].y=center.y+(y+y_off);
X           ptlist[npts].x=center.x-(x+x_off); ptlist[npts++].y=center.y+(y+y_off);
X           ptlist[npts].x=center.x+(x+x_off); ptlist[npts++].y=center.y-(y+y_off);
X           ptlist[npts].x=center.x-(x+x_off); ptlist[npts++].y=center.y-(y+y_off);
X           ptlist[npts].x=center.x+(y+x_off); ptlist[npts++].y=center.y+(x+y_off);
X           ptlist[npts].x=center.x-(y+x_off); ptlist[npts++].y=center.y+(x+y_off);
X           ptlist[npts].x=center.x+(y+x_off); ptlist[npts++].y=center.y-(x+y_off);
X           ptlist[npts].x=center.x-(y+x_off); ptlist[npts++].y=center.y-(x+y_off);
X             
X           if (error < 0)
X              error = error + (x << 2) + 6;
X           else
X              error = error + ((x-y--) << 2) + 10;
X           x++;
X          }  /* end of while (x , y) */
X 
X          if (x == y)
X          {
X           ptlist[npts].x=center.x+(x+x_off); ptlist[npts++].y=center.y+(y+y_off);
X           ptlist[npts].x=center.x-(x+x_off); ptlist[npts++].y=center.y+(y+y_off);
X           ptlist[npts].x=center.x+(x+x_off); ptlist[npts++].y=center.y-(y+y_off);
X           ptlist[npts].x=center.x-(x+x_off); ptlist[npts++].y=center.y-(y+y_off);
X          }
X          if (flag)
X		my_pw_polypoint(pw,0,0,npts,ptlist,ROP);
X}  /* end of function draw_oval() */
X
END_OF_oval.c
if test 4269 -ne `wc -c <oval.c`; then
    echo shar: \"oval.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pattern.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pattern.c\"
else
echo shar: Extracting \"pattern.c\" \(6279 characters\)
sed "s/^X//" >pattern.c <<'END_OF_pattern.c'
X
X/**************************************************************************
X   Touchup a bitmap graphics editor for the Sun Workstation running SunView
X   Copyright (c) 1988 by Raymond Kreisel
X   1/22/88 @ Suny Stony Brook
X
X   This program may be redistributed without fee as long as this copyright
X   notice is intact.
X
X==> PLEASE send comments and bug reports to one of the following addresses:
X
X	   Ray Kreisel
X	   CS Dept., SUNY at Stony Brook, Stony Brook NY 11794
X
X	   UUCP: {allegra, philabs, pyramid, research}!sbcs!rayk   
X	   ARPA-Internet: rayk@sbcs.sunysb.edu			
X	   CSnet: rayk@suny-sb
X	   (If nobody is home at any of the above addresses try:
X		S72QKRE@TOWSONVX.BITNET			        )
X
X "If I get home before daylight, I just might get some sleep tonight...."
X
X**************************************************************************/
X/**************************************************************************
X	file: pattern.c
X	purpose: this file has all of the paint patterns
X
X	modifications:
X		date:	Tue Mar 22 22:04:58 EST 1988
X		author:	rayk
X		changes:add comments
X**************************************************************************/
X
X#include <pixrect/pixrect_hs.h>
X
X
Xstatic short pattern1_data[] = {
X#include "pattern1.icon.pat"
X};
Xstatic mpr_static(pattern1_pr, 32, 32, 1, pattern1_data);
X
Xstatic short pattern2_data[] = {
X#include "pattern2.icon.pat"
X};
Xstatic mpr_static(pattern2_pr, 32, 32, 1, pattern2_data);
X
Xstatic short pattern3_data[] = {
X#include "pattern3.icon.pat"
X};
Xstatic mpr_static(pattern3_pr, 32, 32, 1, pattern3_data);
X
Xstatic short pattern4_data[] = {
X#include "pattern4.icon.pat"
X};
Xstatic mpr_static(pattern4_pr, 32, 32, 1, pattern4_data);
X
Xstatic short pattern5_data[] = {
X#include "pattern5.icon.pat"
X};
Xstatic mpr_static(pattern5_pr, 32, 32, 1, pattern5_data);
X
Xstatic short pattern6_data[] = {
X#include "pattern6.icon.pat"
X};
Xstatic mpr_static(pattern6_pr, 32, 32, 1, pattern6_data);
X
Xstatic short pattern7_data[] = {
X#include "pattern7.icon.pat"
X};
Xstatic mpr_static(pattern7_pr, 32, 32, 1, pattern7_data);
X
Xstatic short pattern8_data[] = {
X#include "pattern8.icon.pat"
X};
Xstatic mpr_static(pattern8_pr, 32, 32, 1, pattern8_data);
X
Xstatic short pattern9_data[] = {
X#include "pattern9.icon.pat"
X};
Xstatic mpr_static(pattern9_pr, 32, 32, 1, pattern9_data);
X
Xstatic short pattern10_data[] = {
X#include "pattern10.icon.pat"
X};
Xstatic mpr_static(pattern10_pr, 32, 32, 1, pattern10_data);
X
Xstatic short pattern11_data[] = {
X#include "pattern11.icon.pat"
X};
Xstatic mpr_static(pattern11_pr, 32, 32, 1, pattern11_data);
X
Xstatic short pattern12_data[] = {
X#include "pattern12.icon.pat"
X};
Xstatic mpr_static(pattern12_pr, 32, 32, 1, pattern12_data);
X
Xstatic short pattern13_data[] = {
X#include "pattern13.icon.pat"
X};
Xstatic mpr_static(pattern13_pr, 32, 32, 1, pattern13_data);
X
Xstatic short pattern14_data[] = {
X#include "pattern14.icon.pat"
X};
Xstatic mpr_static(pattern14_pr, 32, 32, 1, pattern14_data);
X
Xstatic short pattern15_data[] = {
X#include "pattern15.icon.pat"
X};
Xstatic mpr_static(pattern15_pr, 32, 32, 1, pattern15_data);
X
Xstatic short pattern16_data[] = {
X#include "pattern16.icon.pat"
X};
Xstatic mpr_static(pattern16_pr, 32, 32, 1, pattern16_data);
X
Xstatic short pattern17_data[] = {
X#include "pattern17.icon.pat"
X};
Xstatic mpr_static(pattern17_pr, 32, 32, 1, pattern17_data);
X
Xstatic short pattern18_data[] = {
X#include "pattern18.icon.pat"
X};
Xstatic mpr_static(pattern18_pr, 32, 32, 1, pattern18_data);
X
Xstatic short pattern19_data[] = {
X#include "pattern19.icon.pat"
X};
Xstatic mpr_static(pattern19_pr, 32, 32, 1, pattern19_data);
X
Xstatic short pattern20_data[] = {
X#include "pattern20.icon.pat"
X};
Xstatic mpr_static(pattern20_pr, 32, 32, 1, pattern20_data);
X
Xstatic short pattern21_data[] = {
X#include "pattern21.icon.pat"
X};
Xstatic mpr_static(pattern21_pr, 32, 32, 1, pattern21_data);
X
Xstatic short pattern22_data[] = {
X#include "pattern22.icon.pat"
X};
Xstatic mpr_static(pattern22_pr, 32, 32, 1, pattern22_data);
X
Xstatic short pattern23_data[] = {
X#include "pattern23.icon.pat"
X};
Xstatic mpr_static(pattern23_pr, 32, 32, 1, pattern23_data);
X
Xstatic short pattern24_data[] = {
X#include "pattern24.icon.pat"
X};
Xstatic mpr_static(pattern24_pr, 32, 32, 1, pattern24_data);
X
Xstatic short pattern25_data[] = {
X#include "pattern25.icon.pat"
X};
Xstatic mpr_static(pattern25_pr, 32, 32, 1, pattern25_data);
X
Xstatic short pattern26_data[] = {
X#include "pattern26.icon.pat"
X};
Xstatic mpr_static(pattern26_pr, 32, 32, 1, pattern26_data);
X
Xstatic short pattern27_data[] = {
X#include "pattern27.icon.pat"
X};
Xstatic mpr_static(pattern27_pr, 32, 32, 1, pattern27_data);
X
Xstatic short pattern28_data[] = {
X#include "pattern28.icon.pat"
X};
Xstatic mpr_static(pattern28_pr, 32, 32, 1, pattern28_data);
X
Xstatic short pattern29_data[] = {
X#include "pattern29.icon.pat"
X};
Xstatic mpr_static(pattern29_pr, 32, 32, 1, pattern29_data);
X
Xstatic short pattern30_data[] = {
X#include "pattern30.icon.pat"
X};
Xstatic mpr_static(pattern30_pr, 32, 32, 1, pattern30_data);
X
Xstatic short pattern31_data[] = {
X#include "pattern31.icon.pat"
X};
Xstatic mpr_static(pattern31_pr, 32, 32, 1, pattern31_data);
X
Xstatic short pattern32_data[] = {
X#include "pattern32.icon.pat"
X};
Xstatic mpr_static(pattern32_pr, 32, 32, 1, pattern32_data);
X
Xstatic short pattern33_data[] = {
X#include "pattern33.icon.pat"
X};
Xstatic mpr_static(pattern33_pr, 32, 32, 1, pattern33_data);
X
Xstatic short pattern34_data[] = {
X#include "pattern34.icon.pat"
X};
Xstatic mpr_static(pattern34_pr, 32, 32, 1, pattern34_data);
X
Xstatic short pattern35_data[] = {
X#include "pattern35.icon.pat"
X};
Xstatic mpr_static(pattern35_pr, 32, 32, 1, pattern35_data);
X
Xstatic short pattern36_data[] = {
X#include "pattern36.icon.pat"
X};
Xstatic mpr_static(pattern36_pr, 32, 32, 1, pattern36_data);
X
Xstatic short pattern37_data[] = {
X#include "pattern37.icon.pat"
X};
Xstatic mpr_static(pattern37_pr, 32, 32, 1, pattern37_data);
X
Xstatic short pattern38_data[] = {
X#include "pattern38.icon.pat"
X};
Xstatic mpr_static(pattern38_pr, 32, 32, 1, pattern38_data);
X
Xstatic short pattern39_data[] = {
X#include "pattern39.icon.pat"
X};
Xstatic mpr_static(pattern39_pr, 32, 32, 1, pattern39_data);
X
Xstatic short pattern40_data[] = {
X#include "pattern40.icon.pat"
X};
Xstatic mpr_static(pattern40_pr, 32, 32, 1, pattern40_data);
X
X
END_OF_pattern.c
if test 6279 -ne `wc -c <pattern.c`; then
    echo shar: \"pattern.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f touchup.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"touchup.c\"
else
echo shar: Extracting \"touchup.c\" \(19131 characters\)
sed "s/^X//" >touchup.c <<'END_OF_touchup.c'
X
X/**************************************************************************
X   Touchup a bitmap graphics editor for the Sun Workstation running SunView
X   Copyright (c) 1988 by Raymond Kreisel
X   1/22/88 @ Suny Stony Brook
X
X   This program may be redistributed without fee as long as this copyright
X   notice is intact.
X
X==> PLEASE send comments and bug reports to one of the following addresses:
X
X	   Ray Kreisel
X	   CS Dept., SUNY at Stony Brook, Stony Brook NY 11794
X
X	   UUCP: {allegra, philabs, pyramid, research}!sbcs!rayk   
X	   ARPA-Internet: rayk@sbcs.sunysb.edu			
X	   CSnet: rayk@suny-sb
X	   (If nobody is home at any of the above addresses try:
X		S72QKRE@TOWSONVX.BITNET			        )
X
X "If I get home before daylight, I just might get some sleep tonight...."
X
X**************************************************************************/
X/**************************************************************************
X	file: touchup.c
X	purpose: this file has misc functions that do different crap
X		but mostly the event handler for the main drawing
X		area
X	modifications:
X		date:	Tue Mar 22 22:04:58 EST 1988
X		author:	rayk
X		changes:add comments
X**************************************************************************/
X
X#include "header.h"
X
Xunsigned char red[256],green[256],blue[256];
Xint image_wid= DEFAULT_IMAGE_WID,image_hgt= DEFAULT_IMAGE_HGT,image_depth=1;
Xint top_x=0,top_y=0,bottom_x=0,bottom_y=0;
Xint cur_color=1,grid_size=0;
Xint magnify_fac=8,fat_x,fat_y,fat_source_x=0-1,fat_source_y=0-1;
Xint mouse_left=PAINT,undo_flag=TRUE;
Xint select_pt_x=0-1,select_pt_y=0-1;
Xint old_x=0; old_y=0;
Xint start_x=0; start_y=0;
Xchar file_name[MAX_FILE_NAME];
Xstruct pixrect *cut_buffer_pr=NULL,
X		*undo_pr=NULL;
X
Xstruct pixfont *main_font=NULL;
X
X/*
X * this is the event handler for the special cut/paste command menu
X */
Xregion_handle(item, event)
XPanel_item      item;
XEvent           *event;
X{
X    switch((int)panel_get_value(region_choice)) {
X	case CUT:
X		cut_region();
X			break;
X	case COPY:
X		print_msg("Region copied to Cut/Paste buffer. Hold down the RIGHT mouse button to drag the object.");
X		panel_set(region_choice,PANEL_VALUE,MOVE,0);
X		copy_region();
X			break;
X	case FLIP_HOR:
X		flip_hor_region();
X			break;
X	case FLIP_VER:
X		flip_ver_region();
X			break;
X	case ROTATE:
X		rotate_region();
X			break;
X	case INVERSE:
X		inverse_region();
X			break;
X	case PASTE:
X                paste_region();
X			break;
X	case MOVE:
X		print_msg("Hold down the RIGHT mouse button and drag the object.");
X			break;
X    }
X
X}
X
X
X/*
X * this is the event handler for the main comand menu
X */
Xcommand_handle(item, event)
XPanel_item      item;
XEvent           *event;
X{
X  hide_msg();
X  if ((int)panel_get_value(command_choice) != GET_PT)
X	{
X	  (void)window_set(region_panel, WIN_SHOW, FALSE, 0);
X	  panel_set(region_choice,PANEL_VALUE,5,0);
X	}
X  (void)window_set(brush_panel, WIN_SHOW, FALSE, 0);
X    switch((int)panel_get_value(command_choice)) {
X	case TEXT:
X		  draw_text();
X			break;
X	case LASO:
X		  print_msg("Hold down the LEFT mouse button and encircle a object.");
X		  mouse_parms();
X			break;
X	case CIRCLE:
X		  print_msg("Hold down the LEFT mouse button and extend to radius of the circle.");
X		  mouse_parms();
X			break;
X	case DRAW:
X		  print_msg("Press the LEFT mouse button to DRAW.");
X		  mouse_parms();
X			break;
X	case LINE:
X		  print_msg("Hold down the LEFT mouse button and extend to end of the line.");
X		  mouse_parms();
X			break;
X	case MAGNIFY:
X		  print_msg("Use LEFT button to draw, hold down MIDDLE button to move.");
X		  fat_mode();
X			break;
X	case FFILL:
X		  fill_mode(item, event);
X		  mouse_parms();
X			break;
X	case OVAL:
X   		  print_msg("Hold down the LEFT mouse button and extend to edge of the oval.");
X		  mouse_parms();
X			break;
X	case POLY_F:
X	case POLY_H:
X		  print_msg("Press the LEFT mouse button to select a vertex.");
X		  mouse_parms();
X			break;
X	case RECT_F:
X	case RECT_H:
X		  print_msg("Hold down the LEFT mouse button and extend to the opposite corner.");
X		  mouse_parms();
X			break;
X	case PAINT:
X		  print_msg("Press the LEFT mouse button to PAINT.");
X		  mouse_parms();
X		  (void)window_set(brush_panel, WIN_SHOW, TRUE, 0);
X			break;
X	case SEL_REG:
X		  print_msg("Hold down the LEFT mouse button and extend to the opposite corner.");
X		  if (mouse_left == SEL_REG)
X		    {
X		      clean_region();
X		      top_x = 0;
X		      top_y = 0;
X	    	      bottom_x = image_wid;
X		      bottom_y = image_hgt;
X		      select_region(pw,top_x,top_y,bottom_x,bottom_y);
X		    }
X		  else
X		    {
X		      mouse_parms();
X		    }
X		  (void)window_set(region_panel, WIN_SHOW, TRUE, 0);
X		  break;
X	case GET_PT:
X		  print_msg("Press the LEFT mouse button to select a point.");
X		  mouse_parms();
X			break;
X	case ERASE:
X		  print_msg("Press the LEFT MOUSE button to ERASE.");
X		  if ((mouse_left == ERASE) &&  (confirm("Erase entire drawing area ?")))
X		    {
X		    clear_screen();
X		    (void)window_set(canvas,
X	    		  CANVAS_WIDTH,		DEFAULT_IMAGE_WID,
X		          CANVAS_HEIGHT,	DEFAULT_IMAGE_HGT,
X	   		 0);
X		    }
X		  else
X                    if (top_x || top_y || bottom_x || bottom_y)
X        	    {
X		     select_region(pw,top_x,top_y,bottom_x,bottom_y);
X  		     region_fix();
X  	  	     pw_rop(pw,top_x,top_y,bottom_x-top_x,bottom_y-top_y,PIX_SRC,0,0,0);
X		     reset_region();
X        	    }
X		  mouse_parms();
X			break;
X
X    }
X
X}     
X
X
X
X/*
X * save the screen to a temp bitmap for the undo command
X */
Xsave_screen()
X{
X  if (undo_flag)
X  {
X    if (undo_pr == NULL)
X  	undo_pr =my_mem_create(image_wid,image_hgt,image_depth);
X    pr_rop(undo_pr,0,0,image_wid,image_hgt,PIX_SRC,pw->pw_prretained,0,0);
X  }
X}     
X
X
X/*
X * go back to the last saved bitmap
X */
Xundo_screen(item, event)
XPanel_item      item;
XEvent           *event;
X{
X  if (undo_flag)
X  {
X    clean_region();
X    clean_point();
X    clean_poly();
X    fat_done();
X    pw_write(pw,0,0, image_wid,image_hgt, PIX_SRC, undo_pr,0,0);
X  }
X}     
X
X
X
X/*
X * clear the drawing area
X */
Xclear_screen(item, event)
XPanel_item      item;
XEvent           *event;
X{
X  clean_point();
X  clean_region();
X  save_screen();
X  fat_done();
X  pw_write( pw,0,0,1280,1280,PIX_SRC,0,0,0);
X  pw_write( fat_pw,0,0,1280,1280,PIX_SRC,0,0,0);
X}
X
X
X/*
X * if there is a region that is select the deselect it
X */
Xclean_region()
X{
X  if (top_x || top_y || bottom_x || bottom_y)
X    {
X     select_region(pw,top_x,top_y,bottom_x,bottom_y);
X     reset_region();
X    }
X}
X
X
X/*
X * if there is a point that is selected then deselecte it
X */
Xclean_point()
X{
X  if (select_pt_x != -1)
X    {
X     select_point(select_pt_x,select_pt_y);
X     select_pt_x = -1;
X     select_pt_y = -1;
X    }
X}
X
X
X/*
X * deselect any points and regions and get the current command mode
X */
Xmouse_parms(item, event)
XPanel_item      item;
XEvent           *event;
X{
X  clean_point();
X  clean_region();
X  fat_done();
X  mouse_left = (int)panel_get_value(command_choice);
X}
X
X
X/*
X * set it to select a point mode
X */
Xset_select_mode()
X{
X  panel_set(command_choice,PANEL_VALUE, GET_PT,0);
X  mouse_parms();
X}
X
X
X
X/*
X * this the main event handler that makes the whole thing go
X * this event handle is for that canvas that is the main drawing area
X */
Xhandle_event(canvas_local, event, arg)
XCanvas  canvas_local;
XEvent   *event;
Xcaddr_t arg;
X{
X    Pixwin      *pw     = canvas_pixwin(canvas_local);
X
X    if (grid_size)
X     {
X	event_set_x(event,event_x(event) + grid_size/2 - (event_x(event)%grid_size));
X        event_set_y(event,event_y(event) + grid_size/2 - (event_y(event)%grid_size));
X     }
X
X    if (event_is_up(event))
X	{
X   	 if (event_id(event) == MS_LEFT)
X		{
X		if ((mouse_left == RECT_H) || (mouse_left == RECT_F))
X		   draw_rectangle(start_x,start_y,event_x(event), event_y(event));
X		if (mouse_left == LINE)
X		   draw_line(start_x,start_y,event_x(event), event_y(event),PIX_SRC,cur_color);
X		if (mouse_left == ERASE)
X		     {
X	               select_region(pw,top_x,top_y,top_x+PATTERN_SIZE,top_y+PATTERN_SIZE);
X		       reset_region();
X		     }
X
X		if (mouse_left == CIRCLE)
X                     {
X 		        draw_line(start_x,start_y,old_x,old_y,PIX_XOR,1);
X		        draw_circle(pw,start_x,start_y,distance(old_x,old_y,start_x,start_y),1,PIX_SET);
X		     }
X
X		if (mouse_left == OVAL)
X		   draw_oval(pw,start_x,start_y,old_x,old_y,TRUE);
X
X                if (fat_source_x != -1)
X                   fat_update(0,0);
X		if (mouse_left == GET_PT)
X		 {
X  		   select_pt_x = event_x(event);
X		   select_pt_y = event_y(event);
X		 }
X		if (mouse_left == LASO)
X		{
X		   laso_cut_paste();
X		   panel_set(region_choice,PANEL_VALUE,MOVE,0);
X		   panel_set(command_choice,PANEL_VALUE,SEL_REG,0);
X	           (void)window_set(brush_panel, WIN_SHOW,FALSE, 0);
X	           (void)window_set(region_panel, WIN_SHOW,TRUE, 0);
X		   print_msg("Object copied to Cut/Paste buffer. Hold down the RIGHT mouse button to drag the object.");
X		   mouse_parms();
X		}
X	      }
X   	 if (event_id(event) == MS_RIGHT)
X		{
X                  if (((int)panel_get_value(region_choice) == MOVE) && (cut_buffer_pr != NULL))
X			{
X		         pw_write(pw,old_x- cut_buffer_pr->pr_size.x/2,
X				     old_y- cut_buffer_pr->pr_size.y/2,
X				     cut_buffer_pr->pr_size.x,
X				     cut_buffer_pr->pr_size.y,
X				     PIX_XOR, cut_buffer_pr,0,0);
X		       pw_write(pw,event_x(event)-cut_buffer_pr->pr_size.x/2,
X				   event_y(event)-cut_buffer_pr->pr_size.y/2,
X				 cut_buffer_pr->pr_size.x,
X				 cut_buffer_pr->pr_size.y,
X				 PIX_SRC | PIX_DST, cut_buffer_pr,0,0);
X			}
X		}
X         return;
X	}
X    switch (event_id(event)) {
X	 case MS_LEFT:
X		if ((mouse_left != POLY_H) && (mouse_left != POLY_F) && (mouse_left != GET_PT) && (mouse_left != SEL_REG))
X			save_screen();
X		old_x = event_x(event);
X		old_y = event_y(event);
X		start_x = event_x(event);
X		start_y = event_y(event);
X		switch(mouse_left) {
X
X		case LINE:
X			   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X			   break;
X		case POLY_F:
X		case POLY_H:
X			   if (poly_points[0].x == -1)
X				save_screen();			
X			   poly_addpt(poly_points,start_x,start_y);
X			   print_msg("Press the LEFT button to select a vertex or press the RIGHT mouse button to end the polygon.");
X			   break;
X		case DRAW:
X			   draw_point(pw,event_x(event), event_y(event));
X			   break;
X		case PAINT:
X			   draw_brush(pw, event_x(event), event_y(event));
X			   break;
X		case ERASE:
X			   top_x = event_x(event)-PATTERN_SIZE/2; top_y= event_y(event)-PATTERN_SIZE/2;
X			   select_region(pw,top_x,top_y,top_x+PATTERN_SIZE,top_y+PATTERN_SIZE);
X			   erase_brush(pw, event_x(event), event_y(event));
X			   break;
X		case CIRCLE:
X 		           draw_line(start_x,start_y,old_x,old_y,PIX_XOR,1);
X			   break;
X		case OVAL:
X		           draw_oval(pw,start_x,start_y,old_x,old_y,FALSE);
X			   break;
X		case GET_PT:
X  		   	   if (select_pt_x != -1)
X  			      select_point(select_pt_x,select_pt_y);
X    		   	   old_x = event_x(event);
X  		           old_y = event_y(event);
X  		           select_point(old_x,old_y);
X			   break;
X
X		case SEL_REG:
X		  	   if (top_x || top_y || bottom_x || bottom_y)
X		      		select_region(pw,top_x,top_y,bottom_x,bottom_y);
X			   save_screen();
X  	          	   top_x = event_x(event);
X		 	   top_y = event_y(event);
X  	          	   bottom_x = event_x(event);
X		 	   bottom_y = event_y(event);
X	 	 	   select_region(pw,top_x,top_y,bottom_x,bottom_y);
X			   break;
X		case LASO:
X			   ptlist[0].x = -1;
X			   ptlist[0].y = -1;
X			   laso_addpt(ptlist,start_x,start_y);
X			   break;
X		}
X
X		break;
X
X          case MS_MIDDLE:
X		switch(mouse_left) {
X		case SEL_REG:
X			if (top_x || top_y || bottom_x || bottom_y)
X			{
X			  select_region(pw,top_x,top_y,bottom_x,bottom_y);
X  	        	  bottom_x = event_x(event);
X			  bottom_y = event_y(event);
X		 	  select_region(pw,top_x,top_y,bottom_x,bottom_y);
X			}
X			break;
X		}	  
X		break;
X          case MS_RIGHT:
X		if (((mouse_left==POLY_F) || (mouse_left ==POLY_H))
X		   && (poly_points[0].x != -1))
X		 {
X			   poly_addpt(poly_points,event_x(event),event_y(event));
X			   draw_poly(poly_points);
X		 }
X                if (((int)panel_get_value(region_choice) == MOVE) && (cut_buffer_pr != NULL))
X			{
X			clean_region();
X			clean_point();
X			save_screen();
X			old_x = event_x(event);
X			old_y = event_y(event);
X			start_x = old_x;
X			start_y = old_y;
X		        pw_write(pw,old_x - cut_buffer_pr->pr_size.x/2,
X				    old_y - cut_buffer_pr->pr_size.y/2,
X				    cut_buffer_pr->pr_size.x,
X				    cut_buffer_pr->pr_size.y,
X				    PIX_XOR, cut_buffer_pr,0,0);
X			}
X		break;
X          case LOC_DRAG:
X            if (window_get(canvas_local, WIN_EVENT_STATE, MS_LEFT))
X		{
X		switch(mouse_left) {
X		case PAINT:
X			draw_brush(pw, event_x(event), event_y(event));
X			break;
X		case DRAW:
X			draw_point(pw,event_x(event), event_y(event));
X			break;
X		case ERASE :
X			erase_brush(pw, event_x(event), event_y(event));
X			break;
X		case LINE:
X			   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X  			   old_x = event_x(event);
X			   old_y = event_y(event);
X			   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X			break;
X		case RECT_F :
X		case RECT_H :
X			   select_region(pw,old_x,old_y,start_x,start_y);
X	  		   old_x = event_x(event);
X			   old_y = event_y(event);
X			   select_region(pw,old_x,old_y,start_x,start_y);
X			break;
X		case CIRCLE:
X			   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X	  		   old_x = event_x(event);
X			   old_y = event_y(event);
X			   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X			break;
X		case OVAL:
X			   draw_oval(pw,start_x,start_y,old_x,old_y,FALSE);
X	  		   old_x = event_x(event);
X			   old_y = event_y(event);
X			   draw_oval(pw,start_x,start_y,old_x,old_y,FALSE);
X			break;
X		case GET_PT:
X			   select_point(old_x,old_y);
X  		   	   select_pt_x = event_x(event);
X		   	   select_pt_y = event_y(event);
X	  		   old_x = event_x(event);
X			   old_y = event_y(event);
X			   select_point(old_x,old_y);
X			break;
X		case SEL_REG:
X			  select_region(pw,top_x,top_y,bottom_x,bottom_y);
X  	        	  bottom_x = event_x(event);
X			  bottom_y = event_y(event);
X		 	  select_region(pw,top_x,top_y,bottom_x,bottom_y);
X			break;
X		case LASO:
X			   laso_addpt(ptlist,event_x(event),event_y(event));
X			}
X		case POLY_F:
X		case POLY_H:
X			if (poly_points[0].x != -1)
X		 	{
X			   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X	  		   old_x = event_x(event);
X			   old_y = event_y(event);
X			   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X			}
X		  }
X            if (window_get(canvas_local, WIN_EVENT_STATE, MS_RIGHT))
X		{
X                if ((int)panel_get_value(region_choice) == MOVE)
X			{
X			  move_region(old_x,old_y,event_x(event),event_y(event));
X	  		  old_x = event_x(event);
X			  old_y = event_y(event);
X			}
X		}
X	    break;
X          case LOC_MOVE:
X		if (((mouse_left == POLY_F) || (mouse_left == POLY_H)) &&
X			 (poly_points[0].x != -1))
X		 {
X		   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X  		   old_x = event_x(event);
X		   old_y = event_y(event);
X		   draw_line(old_x,old_y,start_x,start_y,PIX_XOR,1);
X		 }
X	    break;
X	}
X}
X
X
X
X/*
X * we got a "quit" button, say bye bye
X */
Xquit(item, event)
XPanel_item      item;
XEvent           *event;
X
X{
X  window_done(base_frame);
X}
X
X
X/*
X * get all the current values for some stuff
X */
Xchange_parms(item, event)
XPanel_item      item;
XEvent           *event;
X{
X  if (image_depth == 1)
X     cur_color = (int)panel_get_value(mono_cycle);
X  magnify_fac = (int)panel_get_value(magnify_cycle) + 1;
X  grid_size = (int)panel_get_value(grid_cycle)*5;
X}
X
X
X
X/*
X * this is the main that start the show and then goes into
X * window main loop
X */
Xmain(argc,argv) int argc; char *argv[];
X{
Xchar *s;
X
X/*
X * do some agr checking
X */
X     while (--argc > 0 && (*++argv)[0] == '-')
X	for (s = argv[0]+1;*s != '\0';s++)
X                switch (*s) {
X		  case 'n':
X			    undo_flag = FALSE;
X			    break;
X		  case 'p':
X			    image_hgt = DEFAULT_IMAGE_WID;
X			    image_wid = DEFAULT_IMAGE_HGT;
X			    break;
X		  case 'y': ++argv; argc--;
X			    image_hgt = atoi(argv[0]);
X			    break;
X		  case 'x': ++argv; argc--;
X		   	    image_wid = atoi(argv[0]);
X		  	    break;
X		  default:  printf("Usage: touchup [-x width] [-y height] [-n] [-p]\n");
X			    exit(0);
X		}
X  if (argc > 0)
X    {
X      printf("Usage: touchup [-x width] [-y height] [-n] [-p]\n");
X      exit(0);
X    }
X
X  clean_poly();
X
X  /*
X   * get the font used in all of the panels
X   */
X  main_font = pf_open(MAIN_FONT);
X  if (!main_font)
X    {
X     printf("ERROR loading the main font !!!!\n");
X     exit(1);
X    }
X
X  init_font();
X  getcwd(file_name,MAX_FILE_NAME-2);
X  strcat(file_name,"/");
X  init_windows(argc,argv);
X  /*
X   * are we on a color machine ????
X   */
X  image_depth = pw->pw_pixrect->pr_depth;
X  if (image_depth == 8)
X    {
X	init_colortable();
X	my_put_colormap();
X	set_color();
X    }
X  else
X	set_mono();
X
X  if (undo_flag)
X     undo_pr = my_mem_create(image_wid,image_hgt,image_depth);
X  else
X     panel_set(undo_button,PANEL_SHOW_ITEM, FALSE,0);
X
X  init_mag();
X  window_main_loop(base_frame);
X}
X
X
X
X/***************************************************************
X        hide_msg
X        purpose: To clear the masssage display area.
X        parameter:
X        returns:
X ***************************************************************/
Xhide_msg()
X{
X         panel_set(msg_string,PANEL_LABEL_STRING,"",0);
X}
X
X
X/***************************************************************
X        print_msg
X        purpose: To print a message on the window and center it
X        parameter:
X                string: The string to be printed.
X        returns:
X ***************************************************************/
Xprint_msg(string)
Xchar *string;
X{
Xchar temp_space[132];
Xchar *temp_pt;
Xint i;
X  
X  if (strlen(string) < 132)
X  {
X    for(i=0;i<132;i++)
X      temp_space[i]= ' ';
X    temp_pt = temp_space + (132-strlen(string))/2;
X    strcpy(temp_pt,string);
X    panel_set(msg_string,PANEL_LABEL_STRING,temp_space,0);
X  }
X  else
X    panel_set(msg_string,PANEL_LABEL_STRING,string,0);
X}
X
XERROR(msg)
Xchar *msg;
X{ 
X  print_msg(msg);
X  window_bell(panel);
X}
X
XERRORstr(msg,str)
Xchar *msg,*str;
X{
Xchar temp[200];
X  strcpy(temp,msg);
X  print_msg(strcat(temp,str));
X  window_bell(panel);
X}
X
X
X
X/***************************************************************
X	sqrt_fast
X        purpose: To do a fast integer square root
X        parameter:
X		n :  the int to take the sqrt of
X        returns: 
X		the integer square root of n
X ***************************************************************/
Xint sqrt_fast(n)
Xint n;
X{
X   int a,b,c;
X   a = n;
X   b = n;
X   if (n>1){
X        while (a>0) {
X            a = a >> 2;
X            b = b >> 1;
X	}
X        do {
X            a = b;
X            c = n / b;
X            b = (c + a) >> 1;
X	} while ( (a-c)<-1 || (a-c)>1 );
X   }
X    return(b);
X}
X
X/*
X * find the distance between any two points
X */
Xdistance(x1,y1,x2,y2)
Xint x1,y1,x2,y2;
X{
X  return(sqrt_fast((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));
X}
X
X
X/*
X * check if we have enough memory to create those LARGE bitmap
X */
Xstruct pixrect *my_mem_create(wid,hgt,dep)
Xint wid,hgt,dep;
X{
Xstruct pixrect* temp_pr;
X
X    temp_pr = mem_create(wid,hgt,dep);
X    if (temp_pr== NULL)
X        {
X  	printf("Not enough memory, memory allocation problems!!!\n");
X  	exit(0);
X        }
X}
END_OF_touchup.c
if test 19131 -ne `wc -c <touchup.c`; then
    echo shar: \"touchup.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 6 \(of 6\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
