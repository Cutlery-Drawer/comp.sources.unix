Subject:  v15i028:  Monthly apointment calendar, for Suns, Part02/02
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: cognos!sarahm
Posting-number: Volume 15, Issue 28
Archive-name: monthtool/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 2)."
# Contents:  monthtool.c
# Wrapped by rsalz@fig.bbn.com on Thu Jun  2 15:04:55 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'monthtool.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'monthtool.c'\"
else
echo shar: Extracting \"'monthtool.c'\" \(43509 characters\)
sed "s/^X//" >'monthtool.c' <<'END_OF_FILE'
X/*  @(#)monthtool.c	5.1 2/20/88 */
X 
X/*
X	Name:		monthtool
X  
X	Purpose: 	visual appointment calendar 
X  
X	Author:		Sarah Metcalfe apres Mike Essex & Rich Burridge
X  
X	Discussion: Displays a calendar to the screen for a given month.  
X				User may move the mouse to any day of the
X				month and view or enter appointments for that date. 
X
X	Modifications:
X				10 Oct 87:	Sarah Metcalfe
X							Allow weekly appointments.
X							Automatically save on close and reload on open.
X							Automatically switch to today on open.
X				 9 Nov 87:	D. Brent Chapman (capmkt!brent) 
X							Set the "DEFAULT_FONT" environment variable to 
X							the monthtool font, so that the program works 
X							properly under SunOS 3.4.
X				25 Nov 87:	Steve Schlaifer (jplgodo!steve) 
X							Better fix for above problem.
X				25 Nov 87:	Sarah Metcalfe 
X							Create half-shaded date boxes for days with only
X							yearly, monthly, weekly appts.
X				20 Feb 88:	Sarah Metcalfe 
X							Fix message length bug (at least somewhat).
X
X*/
X
X
X
X
X#include "monthtool.h"
X
static Notify_value	 openCloseEvent();
X
void			 dateEvent();
X
void			 monthEvent();
void			 todayBtnHit();
void			 upBtnHit();
void			 downBtnHit();
void			 monthBackgroundHit();
X
void			 notesBackgroundHit();
void			 notesPanelEvent();
void			 notesRadioHit();
X
Canvas			 datesDsply;
Textsw			 notesDsply;
Panel			 monthPanel,
X				 notesPanel;
XFrame			 frame;
Menu			 mainMenu,
X				 fileMenu;
Panel_item		 monthItem,
X				 notesTypeItem;
Pixwin			*datesCrayon;
struct pixfont 	*font,
X				*notesFont;
X
X
short			 dayIcon[] = {
X	0xFFFF,0xFFFF,0xFF00,0x0000,0x8000,0x0000,0x0100,0x0000,
X	0x8000,0x0000,0x0100,0x0000,0x8000,0x0000,0x0100,0x0000,
X	0x8000,0x0000,0x0100,0x0000,0x8000,0x0000,0x0100,0x0000,
X	0x8000,0x0000,0x0100,0x0000,0x8000,0x0000,0x0100,0x0000,
X	0x8000,0x0000,0x0100,0x0000,0x8000,0x0000,0x0100,0x0000,
X	0x8000,0x0000,0x0100,0x0000,0x8000,0x0000,0x0100,0x0000,
X	0x8000,0x0000,0x0100,0x0000,0x8000,0x0000,0x0100,0x0000,
X	0x8000,0x0000,0x0100,0x0000,0x8000,0x0000,0x0100,0x0000,
X	0x8000,0x0000,0x0100,0x0000,0x8000,0x0000,0x0100,0x0000,
X	0x8000,0x0000,0x0100,0x0000,0x8000,0x0000,0x0100,0x0000,
X	0x8000,0x0000,0x0100,0x0000,0x8000,0x0000,0x0100,0x0000,
X	0x8000,0x0000,0x0100,0x0000,0x8000,0x0000,0x0100,0x0000,
X	0x8000,0x0000,0x0100,0x0000,0xFFFF,0xFFFF,0xFF00,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
X};
mpr_static(dayPr, 64, 64, 1, dayIcon);
X
short			 halfDayIcon[] = {
X    0xFFFF,0xFFFF,0xFF00,0x0000,0x8000,0x0000,0x0100,0x0000,
X    0xBFFF,0xFFFF,0xFD00,0x0000,0xA000,0x0000,0x0500,0x0000,
X    0xA000,0x0000,0x0500,0x0000,0xA000,0x0000,0x0500,0x0000,
X    0xA000,0x0000,0x0500,0x0000,0xA000,0x0000,0x0500,0x0000,
X    0xA000,0x0000,0x0500,0x0000,0xA000,0x0000,0x0500,0x0000,
X    0xA000,0x0000,0x0500,0x0000,0xA000,0x0000,0x0500,0x0000,
X    0xA000,0x0000,0x0500,0x0000,0xA000,0x0000,0x0500,0x0000,
X    0xA000,0x0000,0x0500,0x0000,0xA000,0x0000,0x0500,0x0000,
X    0xA000,0x0000,0x0500,0x0000,0xA000,0x0000,0x0500,0x0000,
X    0xA000,0x0000,0x0500,0x0000,0xA000,0x0000,0x0500,0x0000,
X    0xA000,0x0000,0x0500,0x0000,0xA000,0x0000,0x0500,0x0000,
X    0xA000,0x0000,0x0500,0x0000,0xBFFF,0xFFFF,0xFD00,0x0000,
X    0x8000,0x0000,0x0100,0x0000,0xFFFF,0xFFFF,0xFF00,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
X};
mpr_static(halfDayPr, 64, 64, 1, halfDayIcon);
X
short			 fullDayIcon[] = {
X	0xFFFF,0xFFFF,0xFF00,0x0000,0xFFFF,0xFFFF,0xFF00,0x0000,
X	0xFFFF,0xFFFF,0xFF00,0x0000,0xE000,0x0000,0x0700,0x0000,
X	0xE000,0x0000,0x0700,0x0000,0xE000,0x0000,0x0700,0x0000,
X	0xE000,0x0000,0x0700,0x0000,0xE000,0x0000,0x0700,0x0000,
X	0xE000,0x0000,0x0700,0x0000,0xE000,0x0000,0x0700,0x0000,
X	0xE000,0x0000,0x0700,0x0000,0xE000,0x0000,0x0700,0x0000,
X	0xE000,0x0000,0x0700,0x0000,0xE000,0x0000,0x0700,0x0000,
X	0xE000,0x0000,0x0700,0x0000,0xE000,0x0000,0x0700,0x0000,
X	0xE000,0x0000,0x0700,0x0000,0xE000,0x0000,0x0700,0x0000,
X	0xE000,0x0000,0x0700,0x0000,0xE000,0x0000,0x0700,0x0000,
X	0xE000,0x0000,0x0700,0x0000,0xE000,0x0000,0x0700,0x0000,
X	0xE000,0x0000,0x0700,0x0000,0xFFFF,0xFFFF,0xFF00,0x0000,
X	0xFFFF,0xFFFF,0xFF00,0x0000,0xFFFF,0xFFFF,0xFF00,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
X};
mpr_static(fullDayPr, 64, 64, 1, fullDayIcon);
X
short			 daySelIcon[] = {
X	0xFFFF,0xFFFF,0xFF00,0x0000,0xA222,0x2222,0x2300,0x0000,
X	0xC444,0x4444,0x4500,0x0000,0x9111,0x1111,0x1100,0x0000,
X	0x8888,0x8888,0x8900,0x0000,0xA222,0x2222,0x2300,0x0000,
X	0xC444,0x4444,0x4500,0x0000,0x9111,0x1111,0x1100,0x0000,
X	0x8888,0x8888,0x8900,0x0000,0xA222,0x2222,0x2300,0x0000,
X	0xC444,0x4444,0x4500,0x0000,0x9111,0x1111,0x1100,0x0000,
X	0x8888,0x8888,0x8900,0x0000,0xA222,0x2222,0x2300,0x0000,
X	0xC444,0x4444,0x4500,0x0000,0x9111,0x1111,0x1100,0x0000,
X	0x8888,0x8888,0x8900,0x0000,0xA222,0x2222,0x2300,0x0000,
X	0xC444,0x4444,0x4500,0x0000,0x9111,0x1111,0x1100,0x0000,
X	0x8888,0x8888,0x8900,0x0000,0xA222,0x2222,0x2300,0x0000,
X	0xC444,0x4444,0x4500,0x0000,0x9111,0x1111,0x1100,0x0000,
X	0x8888,0x8888,0x8900,0x0000,0xFFFF,0xFFFF,0xFF00,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
X};
mpr_static(daySelPr, 64, 64, 1, daySelIcon);
X
short			 halfDaySelIcon[] = {
X    0xFFFF,0xFFFF,0xFF00,0x0000,0x8000,0x0000,0x0100,0x0000,
X    0xBFFF,0xFFFF,0xFD00,0x0000,0xB111,0x1111,0x1500,0x0000,
X    0xA888,0x8888,0x8D00,0x0000,0xA222,0x2222,0x2500,0x0000,
X    0xA444,0x4444,0x4500,0x0000,0xB111,0x1111,0x1500,0x0000,
X    0xA888,0x8888,0x8D00,0x0000,0xA222,0x2222,0x2500,0x0000,
X    0xA444,0x4444,0x4500,0x0000,0xB111,0x1111,0x1500,0x0000,
X    0xA888,0x8888,0x8D00,0x0000,0xA222,0x2222,0x2500,0x0000,
X    0xA444,0x4444,0x4500,0x0000,0xB111,0x1111,0x1500,0x0000,
X    0xA888,0x8888,0x8D00,0x0000,0xA222,0x2222,0x2500,0x0000,
X    0xA444,0x4444,0x4500,0x0000,0xB111,0x1111,0x1500,0x0000,
X    0xA888,0x8888,0x8D00,0x0000,0xA222,0x2222,0x2500,0x0000,
X    0xA444,0x4444,0x4500,0x0000,0xBFFF,0xFFFF,0xFD00,0x0000,
X    0x8000,0x0000,0x0100,0x0000,0xFFFF,0xFFFF,0xFF00,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
X};
mpr_static(halfDaySelPr, 64, 64, 1, halfDaySelIcon);
X
short			 fullDaySelIcon[] = {
X	0xFFFF,0xFFFF,0xFF00,0x0000,0xFFFF,0xFFFF,0xFF00,0x0000,
X	0xFFFF,0xFFFF,0xFF00,0x0000,0xF111,0x1111,0x1700,0x0000,
X	0xE888,0x8888,0x8F00,0x0000,0xE222,0x2222,0x2700,0x0000,
X	0xE444,0x4444,0x4700,0x0000,0xF111,0x1111,0x1700,0x0000,
X	0xE888,0x8888,0x8F00,0x0000,0xE222,0x2222,0x2700,0x0000,
X	0xE444,0x4444,0x4700,0x0000,0xF111,0x1111,0x1700,0x0000,
X	0xE888,0x8888,0x8F00,0x0000,0xE222,0x2222,0x2700,0x0000,
X	0xE444,0x4444,0x4700,0x0000,0xF111,0x1111,0x1700,0x0000,
X	0xE888,0x8888,0x8F00,0x0000,0xE222,0x2222,0x2700,0x0000,
X	0xE444,0x4444,0x4700,0x0000,0xF111,0x1111,0x1700,0x0000,
X	0xE888,0x8888,0x8F00,0x0000,0xE222,0x2222,0x2700,0x0000,
X	0xE444,0x4444,0x4700,0x0000,0xFFFF,0xFFFF,0xFF00,0x0000,
X	0xFFFF,0xFFFF,0xFF00,0x0000,0xFFFF,0xFFFF,0xFF00,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
X};
mpr_static(fullDaySelPr, 64, 64, 1, fullDaySelIcon);
X
X
short			 upBtnIcon[] = {
X	0x3FFF,0xE000,0x7FFF,0xF000,
X	0xE000,0x3800,0xC000,0x1800,
X	0xC020,0x1800,0xC070,0x1800,
X	0xC0F8,0x1800,0xC1FC,0x1800,
X	0xC3FE,0x1800,0xC7FF,0x1800,
X	0xCFFF,0x9800,0xC0F8,0x1800,
X	0xC0F8,0x1800,0xC0F8,0x1800,
X	0xC0F8,0x1800,0xC000,0x1800,
X	0xE000,0x3800,0x7FFF,0xF000,
X	0x3FFF,0xE000,0x0000,0x0000
X};
mpr_static(upBtnPr, BTN_WIDTH, BTN_HEIGHT, 1, upBtnIcon);
X
short			 downBtnIcon[] = {
X	0x3FFF,0xE000,0x7FFF,0xF000,
X	0xE000,0x3800,0xC000,0x1800,
X	0xC0F8,0x1800,0xC0F8,0x1800,
X	0xC0F8,0x1800,0xC0F8,0x1800,
X	0xCFFF,0x9800,0xC7FF,0x1800,
X	0xC3FE,0x1800,0xC1FC,0x1800,
X	0xC0F8,0x1800,0xC070,0x1800,
X	0xC020,0x1800,0xC000,0x1800,
X	0xE000,0x3800,0x7FFF,0xF000,
X	0x3FFF,0xE000,0x0000,0x0000
X};
mpr_static(downBtnPr, BTN_WIDTH, BTN_HEIGHT, 1, downBtnIcon);
X
X
short			 toolIcon[] = {
X	0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8C08,0x87C2,0x21F0,0xF031,
X	0x920D,0x8102,0x2040,0x8049,0x880A,0x8102,0xA040,0xE021,
X	0x840A,0x8102,0xA040,0x8011,0x9208,0x8103,0x6040,0x8049,
X	0x8C08,0x8102,0x2040,0x8031,0xFFFF,0xFFFF,0xFFFF,0xFFFF,
X	0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8040,0x2010,0x0804,0x0201,
X	0x8040,0x2814,0x0A05,0x0281,0x8040,0x2814,0x0A05,0x0281,
X	0x8040,0x2010,0x0804,0x0201,0x8040,0x2010,0x0804,0x0201,
X	0x8040,0x2013,0xA804,0x0201,0x8040,0x2010,0x0804,0x0201,
X	0x8040,0x2016,0x8804,0x0201,0x8040,0x2010,0x0804,0x0201,
X	0x8040,0x2010,0x0804,0x0201,0xFFFF,0xFFFF,0xFFFF,0xFFFF,
X	0x8040,0x2010,0x0804,0x0201,0xA050,0x2814,0x0B05,0x82C1,
X	0xA050,0x2814,0x0B05,0x82C1,0x8040,0x2010,0x0804,0x0201,
X	0x8040,0x2010,0x0804,0x0201,0x8040,0x2010,0x0805,0xD201,
X	0x8040,0x2010,0x0804,0x0201,0x8040,0x2010,0x0804,0x0201,
X	0x8040,0x2010,0x0804,0x0201,0x8040,0x2010,0x0804,0x0201,
X	0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8040,0x2010,0x0804,0x0201,
X	0xB058,0x2C16,0x0B05,0x82C1,0xB058,0x2C16,0x0B05,0x82C1,
X	0x8040,0x2010,0x0804,0x0201,0x8040,0x2F50,0x0804,0x0201,
X	0x8040,0x2010,0x0804,0x0201,0x8040,0x2D50,0x0804,0x0201,
X	0x8040,0x2010,0x0804,0x0201,0x8040,0x2010,0x0804,0x0201,
X	0x8040,0x2010,0x0804,0x0201,0xFFFF,0xFFFF,0xFFFF,0xFFFF,
X	0x8040,0x2010,0x0804,0x0201,0xB058,0x2C16,0x0B05,0x82C1,
X	0xB058,0x2C16,0x0B05,0x82C1,0x8040,0x2010,0x0804,0x0201,
X	0x8040,0x2010,0x0BE4,0x0201,0x8040,0x2010,0x0804,0x0201,
X	0x8040,0x2010,0x0BA4,0x0201,0x8040,0x2010,0x0804,0x0201,
X	0x8040,0x2010,0x0804,0x0201,0x8040,0x2010,0x0804,0x0201,
X	0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8040,0x2010,0x0804,0x0201,
X	0xB058,0x2C16,0x0B04,0x0201,0xB058,0x2C16,0x0B04,0x0201,
X	0x8040,0x2010,0x0804,0x0201,0x8040,0x2010,0x0804,0x0201,
X	0xBA40,0x2017,0xC804,0x0201,0x8040,0x2010,0x0804,0x0201,
X	0x8040,0x2013,0xC804,0x0201,0x9240,0x2010,0x0804,0x0201,
X	0x8040,0x2010,0x0804,0x0201,0xFFFF,0xFFFF,0xFFFF,0xFFFF
X};
DEFINE_ICON_FROM_IMAGE(monthIcon, toolIcon);
X
X
X
struct dateBox		 monthBoxes[DATE_ROWS][DATE_COLS];
X
X
struct apptsData 	*firstApptRecord[NUM_NOTES_TYPE + 1 /*for NOTES_ERROR*/];
struct apptsData 	*lastApptRecord[NUM_NOTES_TYPE + 1 /*for NOTES_ERROR*/];
X
X	
int					 tmonth, tday, tyear;
int					 firstDow;
X
int					 yearToShow, monthToShow;
int					 dayToShow = 0;
int					 dateNumToShow[NUM_NOTES_TYPE];
X
int					 editCount = 0;
int					 notesModified = 0;
int					 hasWeeklyNotes;
X
char				 toolFile[80];
struct stat			 lastStatus;
X
char				 typeChar[NUM_NOTES_TYPE] = { 0x90, 0x91, 0x92, 0x93, 0x94 }; 
char				 typeMark[3] = "  ";
X							
char				*smon[] = { "January", "February", "March",
X								"April", "May", "June",
X								"July", "August", "September",
X								"October", "November", "December"
X							  };
int					 mon[] = { 0, 	31, 29, 31, 
X									30, 31, 30,
X									31, 31, 30, 
X									31, 30, 31, 
X							  };
X
X
main(argc, argv)
X
int		 argc;
char	*argv[];
X
X{
X	char	fontString[80];
X	char	choiceString[2];
X	int		type;
X
X	/* set default font */
X
X	strcpy(fontString, FONTDIR);
X	strcat(fontString, NORMALFONT);
X
X	font = pf_open(LARGEFONT);              /* Open large sized font. */
X	notesFont = pf_open(fontString);        /* Open regular sized font. */
X
X	/* Set up menus */
X						
X	fileMenu = menu_create(MENU_ITEM,
X								MENU_STRING,	"Save",
X								MENU_VALUE,		 MENU_SAVE,
X								0,
X							MENU_ITEM,
X								MENU_STRING,	"Reload",
X								MENU_VALUE,		 MENU_RELOAD,
X								0,
X							0);
X
X	mainMenu = menu_create(MENU_ITEM,
X								MENU_STRING,	"Close (with Save)",
X								MENU_VALUE,		 MENU_CLOSE,
X								0,
X							MENU_ITEM,
X								MENU_STRING,	"Update Appts.",
X								MENU_PULLRIGHT,	 fileMenu,
X								0,
X							MENU_ITEM,
X								MENU_STRING,	"Quit (with Save)",
X								MENU_VALUE,		 MENU_QUIT,
X								0,
X							0);
X						
X
X	/*	Set up windows */
X
X	frame = window_create(0, FRAME,
X				FRAME_ICON, &monthIcon,
X				FRAME_SHOW_LABEL, FALSE,
X				FRAME_SUBWINDOWS_ADJUSTABLE, FALSE,
X				FRAME_NO_CONFIRM, FALSE,
X				WIN_HEIGHT, DATES_HEIGHT + MONTH_HEIGHT + 
X					NOTES_PANEL_HEIGHT + NOTES_HEIGHT + 25,
X				WIN_WIDTH, WINDOW_WIDTH + 10,
X				FRAME_ARGS, argc, argv,
X				0);
X	(void) notify_interpose_event_func( frame, openCloseEvent, NOTIFY_SAFE );
X
X	monthPanel = window_create(frame, PANEL,
X				WIN_X, 0,
X				WIN_Y, 0,
X				WIN_HEIGHT, MONTH_HEIGHT,
X				WIN_WIDTH, WINDOW_WIDTH,
X				WIN_FONT, font,
X				PANEL_BACKGROUND_PROC, monthBackgroundHit,
X				PANEL_EVENT_PROC, monthEvent,
X				0);
X
X	datesDsply = window_create(frame, CANVAS,
X				WIN_X, 0,
X				WIN_BELOW, monthPanel,
X				WIN_HEIGHT, DATES_HEIGHT,
X				WIN_WIDTH, WINDOW_WIDTH,
X				WIN_FONT, font,
X				WIN_EVENT_PROC, dateEvent,
X				WIN_CONSUME_KBD_EVENTS, WIN_ASCII_EVENTS, WIN_LEFT_KEYS, 0,
X				0);
X
X	datesCrayon = canvas_pixwin(datesDsply);
X
X	notesPanel = window_create(frame, PANEL,
X				WIN_X, 0,
X				WIN_BELOW, datesDsply,
X				WIN_HEIGHT, NOTES_PANEL_HEIGHT,
X				WIN_WIDTH, WINDOW_WIDTH,
X				WIN_FONT, notesFont,
X				PANEL_BACKGROUND_PROC, notesBackgroundHit,
X				PANEL_EVENT_PROC, notesPanelEvent,
X				0);
X
X	notesDsply = window_create(frame, TEXTSW,
X				WIN_X, 0,
X				WIN_BELOW, notesPanel,
X				WIN_HEIGHT, WIN_EXTEND_TO_EDGE,
X				WIN_WIDTH, 10000 /* very large number, cuts to actual width */,
X				WIN_FONT, notesFont,
X				TEXTSW_IGNORE_LIMIT, TEXTSW_INFINITY,
X				0);
X	/* For bug in Sun Version 3.4 */
X	window_set( notesDsply, WIN_FONT, notesFont, 0);
X
X	/* Set up panels */
X
X
X	monthItem = panel_create_item(monthPanel, PANEL_MESSAGE,
X					PANEL_LABEL_X, 5,
X					PANEL_LABEL_Y, 10,
X				  0);
X						
X
X	panel_create_item( monthPanel, PANEL_BUTTON,
X						PANEL_ITEM_X, WINDOW_WIDTH - 2 * (BTN_WIDTH + GAP) - 55,
X						PANEL_ITEM_Y, 10,
X  						PANEL_NOTIFY_PROC, todayBtnHit, 
X                       	PANEL_LABEL_IMAGE,
X							panel_button_image(monthPanel,"Today",0,notesFont),
X						0);
X
X	panel_create_item( monthPanel, PANEL_BUTTON,
X						PANEL_ITEM_X, WINDOW_WIDTH - 2 * (BTN_WIDTH + GAP),
X						PANEL_ITEM_Y, 10,
X  						PANEL_NOTIFY_PROC, upBtnHit, 
X                       	PANEL_LABEL_IMAGE, &upBtnPr,
X						0);
X
X	panel_create_item( monthPanel, PANEL_BUTTON,
X						PANEL_ITEM_X, WINDOW_WIDTH - (BTN_WIDTH + GAP),
X						PANEL_ITEM_Y, 10,
X  						PANEL_NOTIFY_PROC, downBtnHit, 
X                       	PANEL_LABEL_IMAGE, &downBtnPr,
X						0);
X
X
X	notesTypeItem = panel_create_item( notesPanel, PANEL_CHOICE,
X						PANEL_LABEL_STRING, "Reminder Types:",
X						PANEL_FEEDBACK, PANEL_NONE,
X						PANEL_NOTIFY_PROC, notesRadioHit,
X					0);
X	choiceString[1] = '\0';
X	for (type = 0; type < NUM_NOTES_TYPE; type++) {
X		choiceString[0] = typeChar[type];
X		panel_set( notesTypeItem, PANEL_CHOICE_STRING, type, choiceString, 0);
X		panel_set( notesTypeItem, PANEL_CHOICE_X, type, 100 + 35*(type+1), 0);
X		panel_set( notesTypeItem, PANEL_CHOICE_Y, type, 4, 0);
X	}
X	panel_set( notesTypeItem, PANEL_LABEL_X, 4, 0);
X	panel_set( notesTypeItem, PANEL_LABEL_Y, 4, 0);
X
X	/* Get monthtool filename */
X
X	strcpy(toolFile, getenv("HOME"));
X	strcat(toolFile, "/.monthtool");
X
X	/* Get today's date */
X
X	todaySet();
X	yearToShow = tyear;
X	monthToShow = tmonth;
X
X	/* Load the appointments file and show this month's calendar */
X	
X	loadData();	
X	firstDowSet();
X	dayHit(tday);	
X
X	/* Wait for events */
X
X	window_main_loop(frame);
X
X	/* When done, leave */
X
X	freeData();
X	exit(0);
X
X}
X
static Notify_value	openCloseEvent(frame, event, arg, type)
X
XFrame				 frame;
XEvent				*event;
Notify_arg			 arg;
Notify_event_type	 type;
X
X{
X	int					initialClosed, finalClosed;
X	Notify_value		value;
X
X	initialClosed = (int) window_get( frame, FRAME_CLOSED );
X	value = notify_next_event_func( frame, event, arg, type );
X	finalClosed = (int) window_get( frame, FRAME_CLOSED );
X
X	if ( initialClosed != finalClosed ) {
X		if ( finalClosed ) {
X			saveData();
X		}else{
X			reloadData();
X			todaySet();
X			monthToShow = tmonth;
X			yearToShow = tyear;
X			monthDisplay();
X			dayHit(tday);
X		}
X	}
X
X	return( value );
X		
X}
X
static void	monthEvent(item, event)
X
Panel_item	 item;
XEvent		*event;
X
X{
X	switch (event_id(event)) {
X	case MS_RIGHT:
X		if (event_is_down(event)) {
X			rootMenuDisplay(monthPanel,event);
X		}
X		break;
X	case MS_LEFT:
X		panel_default_handle_event(item,event);
X		break;
X	default:
X		return;
X	}
X
X}
X
static void	todayBtnHit(item, event)
X
Panel_item	 item;
XEvent		*event;
X
X{
X	todaySet();
X	if ( (monthToShow != tmonth) || (yearToShow != tyear) ) {
X		notesSave();
X		monthToShow = tmonth;
X		yearToShow = tyear;
X		monthDisplay();
X		dayHit(tday);
X	}else{
X		if (dayToShow != tday) {
X			notesSave();
X			dayHit(tday);
X		}
X	}
X}
X
static void	upBtnHit(item, event)
X
Panel_item	 item;
XEvent		*event;
X
X{
X	notesSave();
X	if (--monthToShow < 1) {
X		monthToShow = 12;
X		yearToShow--;
X	}
X	monthDisplay();
X	dayHit(1);
X
X}
X
static void	downBtnHit(item, event)
X
Panel_item	 item;
XEvent		*event;
X
X{
X	notesSave();
X	if (++monthToShow == 13) {
X		monthToShow = 1;
X		yearToShow++;
X	}
X	monthDisplay();
X	dayHit(1);
X
X}
X
static void	monthBackgroundHit(panel, event)
X
Panel		 panel;
XEvent		*event;
X
X{
X	switch (event_id(event)) {
X	case MS_RIGHT:
X		if (event_is_down(event)) {
X			rootMenuDisplay(monthPanel,event);
X		}
X		break;
X	default:
X		return;
X	}
X
X}
X
static void	dateEvent(win, event, arg)
X
Canvas		 win;
XEvent		*event;
caddr_t		 arg;
X
X{
X	int			column,
X				row;
X
X	if (event_is_up(event)) {
X		return;
X	}
X
X	switch (event_id(event)) {
X	case MS_LEFT:
X		notesSave();
X		column = event_x(event) / (DATE_BOX_WIDTH + GAP);
X		row = (event_y(event)) / (DATE_BOX_HEIGHT + GAP);
X		dayHit(monthBoxes[row][column].date);
X		break;
X	case MS_RIGHT:
X		rootMenuDisplay(win,event);
X		break;
X	case WIN_REPAINT:
X		notesSave();
X		monthDisplay();
X		dayHit(dayToShow);
X		break;
X	default:
X		return;
X	}
X
X}
X
dayHit(date)
X
int	date;
X
X{
X	int					 row,
X						 column;
X 
X	if (date != 0) {
X		if (dayToShow != 0) {
X			for (row = 0; row < DATE_ROWS; row++) {
X				for (column = 0; column < DATE_COLS; column++) {
X					if (dayToShow == monthBoxes[row][column].date) {
X						dateBoxDisplay(row, column, NOHIGHLIGHT);
X					}
X				}
X			}
X		}
X		for (row = 0; row < DATE_ROWS; row++) {
X			for (column = 0; column < DATE_COLS; column++) {
X				if (date == monthBoxes[row][column].date) {
X					dateBoxDisplay(row, column, HIGHLIGHT);
X				}
X			}
X		}
X
X		dayToShow = date;
X
X		dateNumToShow[NOTES_ALL_ALL_ALL] = 0;
X
X		dateNumToShow[NOTES_D_ALL_ALL] = dayToShow;
X
X		dateNumToShow[NOTES_D_M_ALL] = dayToShow + 100 * monthToShow;
X
X		dateNumToShow[NOTES_WEEKLY] = ((dayToShow + firstDow) % DATE_COLS);		
X		if ( dateNumToShow[NOTES_WEEKLY] == 0 ) {
X			dateNumToShow[NOTES_WEEKLY] = DATE_COLS;
X		}
X		dateNumToShow[NOTES_WEEKLY] += 100 * 99;
X
X		dateNumToShow[NOTES_D_M_Y] = dayToShow + 100 * monthToShow + 10000 * yearToShow;
X
X		notesDisplay();
X
X	}
X
X}
X
static void	notesPanelEvent(item, event)
X
Panel_item	 item;
XEvent		*event;
X
X{
X
X	switch (event_id(event)) {
X	case MS_RIGHT:
X		if (event_is_down(event)) {
X			rootMenuDisplay(notesPanel,event);
X		}
X		break;
X	case MS_LEFT:
X		panel_default_handle_event(item,event);
X		break;
X	default:
X		return;
X	}
X
X}
X
static void	notesRadioHit(item, value, event)
X
Panel_item	 item;
int			 value;
XEvent		*event;
X
X{
X	int			caretIndex,
X				endIndex,
X				lineStartIndex,
X				nextLineStartIndex,
X				ptrnStartIndex,
X				ptrnEndIndex,
X				ptrnLen,
X				type,
X				result,
X				lineNo;
X
X	typeMark[0] = typeChar[value];
X	ptrnLen = strlen(typeMark);
X
X	caretIndex = (int)window_get( notesDsply, TEXTSW_INSERTION_POINT );
X
X	lineNo = 0;
X	lineStartIndex = 0;
X	while (1) {
X		nextLineStartIndex = (int)textsw_index_for_file_line(notesDsply, lineNo+1);
X		if ( (nextLineStartIndex < 0) || (nextLineStartIndex > caretIndex) ) {
X			break;
X		}
X		lineNo++;
X		lineStartIndex = nextLineStartIndex;
X	}
X
X	window_set( notesDsply, TEXTSW_INSERTION_POINT, lineStartIndex, 0 );
X	textsw_insert( notesDsply, typeMark, ptrnLen );
X	caretIndex += ptrnLen;
X
X	endIndex = (int)window_get( notesDsply, TEXTSW_LENGTH );
X	if ( (nextLineStartIndex < 0) || (nextLineStartIndex > endIndex) ) {
X		nextLineStartIndex = endIndex + 1;
X	}
X	
X	lineStartIndex += strlen(typeMark);
X	for (type = 0; type < NUM_NOTES_TYPE; type++) {
X
X		typeMark[0] = typeChar[type];
X		ptrnLen = strlen(typeMark);
X		while ( ptrnLen ) {
X			do {
X				ptrnStartIndex = lineStartIndex;
X				result = textsw_find_bytes(notesDsply, &ptrnStartIndex, &ptrnEndIndex,
X					typeMark, ptrnLen, 0);
X				if (result != -1) {
X					if ((ptrnEndIndex < nextLineStartIndex) && (ptrnStartIndex >= lineStartIndex)) {
X						textsw_erase(notesDsply, ptrnStartIndex, ptrnEndIndex);
X						caretIndex -= ptrnLen;
X					}else{
X						result = -1;
X					}
X				}
X			} while (result != -1);
X			ptrnLen--;
X		}
X			
X	}
X
X	window_set( notesDsply, TEXTSW_INSERTION_POINT, caretIndex, 0);
X
X}
X
static void	notesBackgroundHit(panel, event)
X
Panel		 panel;
XEvent		*event;
X
X{
X	switch (event_id(event)) {
X	case MS_RIGHT:
X		if (event_is_down(event)) {
X			rootMenuDisplay(notesPanel,event);
X		}
X		break;
X	default:
X		return;
X	}
X
X}
X
rootMenuDisplay(window, event)
X
Window		 window;
XEvent		*event;
X
X{
X
X	switch( (int)menu_show(mainMenu, window, event, 0) ) {
X	case MENU_SAVE:
X		saveData();
X		break;
X	case MENU_RELOAD:
X		reloadData();
X		monthDisplay();
X		dayHit(dayToShow);
X		break;
X	case MENU_CLOSE:
X		saveData();
X		window_set(frame, FRAME_CLOSED, TRUE, 0);
X		break;
X	case MENU_QUIT:
X		saveData();
X		window_destroy(frame);
X		break;
X	}
X
X}
X
monthDisplay()
X
X
X{				
X	int					 column,
X						 row;
X	int					 i, day;
X	char				 monthString[20];
X	struct apptsData 	*cur ;
X	struct dateBox		*thisBox;
X
X	sprintf(monthString, "%s %4u", smon[monthToShow-1], yearToShow);
X	panel_set(monthItem, PANEL_LABEL_STRING, monthString, 0);
X
X	firstDowSet();
X
X	row = 0;
X	for (column = 0; column < firstDow; column++) {
X		monthBoxes[row][column].date = 0;
X		monthBoxes[row][column].boxOutline = NO_OUTLINE;
X	}
X
X	for ( day = 1; day <= mon[monthToShow]; day++) {
X		monthBoxes[row][column].date = day;
X		monthBoxes[row][column].boxOutline = NO_OUTLINE;
X		if (column >= (DATE_COLS-1)) {
X			row++;
X			column = 0;
X		}else{
X			column++;
X		}
X	}
X
X	for (; row < DATE_ROWS; row++) {
X		for (; column < DATE_COLS; column++) {
X			monthBoxes[row][column].date = 0;
X			monthBoxes[row][column].boxOutline = NO_OUTLINE;
X		}
X		column = 0;		
X	}
X
X	for (i = 0; i < NUM_NOTES_TYPE; i++) {
X		if  ( i == NOTES_WEEKLY ) { 
X			for ( cur = firstApptRecord[i]; cur != NULL; cur = cur->next) {
X				if ( cur->month == 99 ) {
X					for (row = 0; row < DATE_ROWS; row++) {
X						if (monthBoxes[row][cur->day-1].boxOutline != FULL_OUTLINE) {
X							monthBoxes[row][cur->day-1].boxOutline = HALF_OUTLINE;
X		 				}
X		 			}
X				}
X			}
X		}else if  ( i != NOTES_ALL_ALL_ALL ) {  
X			for (cur = firstApptRecord[i]; cur != NULL; cur = cur->next) {
X				if (	i==NOTES_D_ALL_ALL ||
X				( 			cur->month==monthToShow &&  
X				(				 i==NOTES_D_M_ALL ||
X				( 					cur->year==yearToShow 
X				)))) { 
X					thisBox = &monthBoxes[(cur->day + firstDow-1) / DATE_COLS]
X						                 [(cur->day + firstDow-1) % DATE_COLS];
X					if ( i == NOTES_D_M_Y ) {
X						thisBox->boxOutline = FULL_OUTLINE;
X					}else if ( i != NOTES_ALL_ALL_ALL ) {
X						if (thisBox->boxOutline != FULL_OUTLINE) {
X							thisBox->boxOutline = HALF_OUTLINE;
X						}
X					}
X				}
X			}
X		}
X	}
X
X	pw_writebackground(datesCrayon, 0, 0, WINDOW_WIDTH, DATES_HEIGHT, PIX_CLR);
X
X	for (row = 0; row < DATE_ROWS; row++) {
X		for (column = 0; column < DATE_COLS; column++) {
X			dateBoxDisplay(row, column, NOHIGHLIGHT);
X		}
X	}
X
X}
X
firstDowSet()
X
X{
X	int			i;
X
X	firstDow = jan1Set(yearToShow);
X	mon[2] = 29;
X	mon[9] = 30;
X	switch ((jan1Set(yearToShow + 1) + 7 - firstDow) % 7) {
X	case 1:				/* non-leap year */
X		mon[2] = 28;
X		break;
X	case 2:				/* leap year */
X		break;
X	default:			/* 1752 */
X		mon[9] = 19;
X		break;
X	}
X	for (i = 1; i < monthToShow; i++) {	
X		firstDow += mon[i];
X	}
X	firstDow %= 7;
X
X}
X
X
X
X
X
jan1Set(year)
X
int             year;
X
X{
X
X	register        y, dow;
X
X	/* normal gregorian calendar one extra day per four years */
X
X	y = year;
X	dow = 4 + y + (y + 3) / 4;
X
X	/* julian calendar regular gregorian less three days per 400 */
X
X	if (y > 1800) {
X		dow -= (y - 1701) / 100;
X		dow += (y - 1601) / 400;
X	}
X
X	/* great calendar changeover instant */
X
X	if (y > 1752)
X		dow += 3;
X
X	return (dow % 7);
X
X} 
X
todaySet()
X
X
X{
X	struct tm      *tp;		/* time structure */
X	long            tloc;	/* number of seconds since 1970 */
X
X	time(&tloc);		
X	tp = localtime(&tloc);
X	tyear = tp->tm_year;
X	tmonth = tp->tm_mon + 1;
X	tday = tp->tm_mday;
X	tyear += 1900;
X
X}
X
dateBoxDisplay(row, column, hilite)
X
int              row;
int              column;
int              hilite;
X
X{
X	char			dateString[4];
X
X	if (monthBoxes[row][column].date == 0) {
X		pw_write(datesCrayon, 
X			column * DATE_BOX_WIDTH + DATE_BORDER + (column * GAP),
X			row * DATE_BOX_HEIGHT + DATE_BORDER + (row * GAP),
X			DATE_BOX_WIDTH, DATE_BOX_HEIGHT, PIX_SRC, &dayPr, 0, 0);
X		pw_text(datesCrayon, 
X			column * DATE_BOX_WIDTH + DATE_BORDER + (column * GAP) + 8,
X			row * DATE_BOX_HEIGHT + DATE_BORDER + (row * GAP) + 20,
X			PIX_SRC | PIX_DST, font, "  ");
X	}else{
X		switch (monthBoxes[row][column].boxOutline) {
X		case FULL_OUTLINE:
X			pw_write(datesCrayon, 
X				column * DATE_BOX_WIDTH + DATE_BORDER + (column * GAP),
X				row * DATE_BOX_HEIGHT + DATE_BORDER + (row * GAP),
X				DATE_BOX_WIDTH, DATE_BOX_HEIGHT, PIX_SRC, 
X				hilite ? &fullDaySelPr : &fullDayPr, 
X				0, 0);
X			break;
X		case HALF_OUTLINE:
X			pw_write(datesCrayon, 
X				column * DATE_BOX_WIDTH + DATE_BORDER + (column * GAP),
X				row * DATE_BOX_HEIGHT + DATE_BORDER + (row * GAP),
X				DATE_BOX_WIDTH, DATE_BOX_HEIGHT, PIX_SRC, 
X				hilite ? &halfDaySelPr : &halfDayPr, 
X				0, 0);
X			break;
X		case NO_OUTLINE:
X			pw_write(datesCrayon, 
X				column * DATE_BOX_WIDTH + DATE_BORDER + (column * GAP),
X				row * DATE_BOX_HEIGHT + DATE_BORDER + (row * GAP),
X				DATE_BOX_WIDTH, DATE_BOX_HEIGHT, PIX_SRC, 
X				hilite ? &daySelPr : &dayPr, 
X				0, 0);
X			break;
X		}
X		sprintf(dateString, "%2u", monthBoxes[row][column].date);
X		pw_text(datesCrayon, 
X			column * DATE_BOX_WIDTH + DATE_BORDER + (column * GAP) + 8,
X			row * DATE_BOX_HEIGHT + DATE_BORDER + (row * GAP) + 20,
X			PIX_SRC | PIX_DST, font, dateString);
X	}
X
X}
X
notesDisplay()
X
X
X{
X	int					 type,
X					 	 i;
X	char				 timeString[7];
X	struct apptsData 	*cur;
X
X	hasWeeklyNotes = 0;
X
X	i = (int)window_get(notesDsply, TEXTSW_LENGTH);
X	if ( i > 0 ) {
X		textsw_erase( notesDsply, 0, i + 1 );
X	}
X
X	for (type = 0; type < NUM_NOTES_TYPE; type++) {
X
X		typeMark[0] = typeChar[type];
X
X		cur = firstApptRecord[type];
X		while ( (cur != NULL) && (cur->dateNum < dateNumToShow[type]) ) {
X			cur = cur->next;					
X		}
X
X		while ( (cur != NULL) && (cur->dateNum == dateNumToShow[type]) ) {
X			
X			textsw_insert( notesDsply, typeMark, 2 );
X			if (cur->time != 0) {
X				sprintf(timeString, "%d:%02d ", 
X					(int)(cur->time / 100), (cur->time % 100));
X				textsw_insert( notesDsply, timeString, strlen(timeString) );
X			}
X			textsw_insert( notesDsply, cur->apptMsg, strlen(cur->apptMsg) );
X			textsw_insert( notesDsply, "\n", 1 );
X			cur = cur->next;	
X			if ( type == NOTES_WEEKLY ) {				
X				hasWeeklyNotes = 1;
X			}
X
X		}
X	
X	}
X
X	editCount = (int)window_get(notesDsply, TEXTSW_EDIT_COUNT);
X	window_set(notesDsply, TEXTSW_FIRST_LINE, 0, 0);
X	window_set(notesDsply, TEXTSW_UPDATE_SCROLLBAR, 0);
X
X}
X
notesSave()
X
X
X{
X	int					 bufLen,
X						 row, column,
X						 notesFound,
X						 nowHasWeeklyNotes,
X						 type,
X						 newEditCount,
X						 thisTime, thisYear, thisMonth, thisDay;
X	char				*thisMsg,
X						*untypedMsg,
X						*notesBuffer;
X	struct apptsData 	*cur,
X						*new,
X						*old,
X						*nextAppt[NUM_NOTES_TYPE];
X
X	newEditCount = (int)window_get(notesDsply, TEXTSW_EDIT_COUNT);
X	if (newEditCount <= editCount) {
X		return;
X	}
X	editCount = newEditCount;
X
X	for (type = 0; type < NUM_NOTES_TYPE; type++) {
X
X		cur = firstApptRecord[type];
X		while ( (cur != NULL) && (cur->dateNum < dateNumToShow[type]) ) {
X			cur = cur->next;					
X		}
X
X		while ( (cur != NULL) && (cur->dateNum == dateNumToShow[type]) ) {
X			if (cur->prev != NULL) {
X				cur->prev->next = cur->next;
X			}else{
X				firstApptRecord[type] = cur->next;
X			}
X			if (cur->next != NULL) {
X				cur->next->prev = cur->prev;
X			}else{
X				lastApptRecord[type] = cur->prev;
X			}
X			old = cur;		
X			cur = cur->next;		
X			free(old->apptMsg);
X			free(old);			
X		}
X		nextAppt[type] = cur;
X
X	}
X
X	notesFound = NO_OUTLINE;
X	nowHasWeeklyNotes = 0;
X	bufLen = (int)window_get(notesDsply, TEXTSW_LENGTH);
X	
X	if (bufLen > 0) {
X
X		notesBuffer = (char *)malloc( bufLen + 1 );
X		if ( notesBuffer == (char *)0 ) {
X			fprintf(stderr, "Monthtool error:  Out of memory.\n");
X			exit(4);
X		}
X		window_get( notesDsply, TEXTSW_CONTENTS, 0, notesBuffer, bufLen + 1 );
X	
X		thisMsg = strtok( notesBuffer, "\n" );
X
X		while ( thisMsg != NULL ) {
X	
X			stripType(thisMsg, &untypedMsg, &type);
X			findTime(&untypedMsg, &thisTime);
X				
X			if (strlen (untypedMsg) != 0) {
X
X				thisYear = thisMonth = thisDay = 0;
X				switch (type) {
X					case NOTES_D_M_Y:
X						thisYear = yearToShow;
X					case NOTES_D_M_ALL:
X						thisMonth = monthToShow;
X					case NOTES_D_ALL_ALL:
X						thisDay = dayToShow;
X						break;
X					case NOTES_WEEKLY:
X						thisMonth = 99;
X						thisDay = (dayToShow + firstDow) % DATE_COLS;
X						if ( thisDay == 0 ) {
X							thisDay = DATE_COLS;
X						}
X						nowHasWeeklyNotes = 1;
X				}
X
X				new = (struct apptsData *)malloc( sizeof( struct apptsData ) );
X				if ( new == (struct apptsData *)0 ) {
X					fprintf(stderr, "Monthtool error:  Out of memory.\n");
X					exit(4);
X				}
X				new->year = thisYear;
X				new->month = thisMonth;
X				new->day = thisDay;
X				new->dateNum = dateNumToShow[type];
X				new->time = thisTime;
X				new->apptMsg = (char *)malloc( strlen(untypedMsg) + 1 );
X				if ( new->apptMsg  == (char *)0 ) {
X					fprintf(stderr, "Monthtool error:  Out of memory.\n");
X					exit(4);
X				}
X				strcpy( new->apptMsg, untypedMsg );
X
X				if (nextAppt[type] != NULL) {
X					new->prev = nextAppt[type]->prev;
X					if (new->prev != NULL) {
X						new->prev->next = new;
X					}else{
X						firstApptRecord[type] = new;
X					}				
X					new->next = nextAppt[type];
X					if (new->next != NULL) {
X						new->next->prev = new;
X					}else{
X						lastApptRecord[type] = new;
X					}				
X				}else{	
X					if ( lastApptRecord[type] != NULL ) {
X						new->next = NULL;
X						new->prev = lastApptRecord[type];
X						lastApptRecord[type]->next = new;
X						lastApptRecord[type] = new;
X					}else{				
X						firstApptRecord[type] = lastApptRecord[type] = new;
X						new->prev = new->next = NULL;
X					}
X				}	
X	
X				if (type == NOTES_D_M_Y) {	
X					notesFound = FULL_OUTLINE;
X				}else if (type != NOTES_ALL_ALL_ALL) {	
X					if (notesFound != FULL_OUTLINE) {
X						notesFound = HALF_OUTLINE;
X					}
X				}
X
X			}
X			free(untypedMsg);
X			thisMsg = strtok( NULL, "\n" );
X
X		}
X
X		free(notesBuffer);
X
X	}
X
X	if (hasWeeklyNotes == nowHasWeeklyNotes) {
X		for (row = 0; row < DATE_ROWS; row++) {
X			for (column = 0; column < DATE_COLS; column++) {
X				if (dayToShow == monthBoxes[row][column].date) {
X					monthBoxes[row][column].boxOutline = notesFound;
X					dateBoxDisplay(row, column, HIGHLIGHT);
X				}
X			}
X		}
X	}else{
X		monthDisplay();
X	}
X
X	notesModified = 1; 
X	hasWeeklyNotes = nowHasWeeklyNotes;
X
X}
X
int 	stripType( oldMsg, newMsg, type )
X
char		 *oldMsg;
char		**newMsg;
int			 *type;
X
X{
X	int			 i,j,
X				 typeFound, thisIsTypeChar;
X 
X	*newMsg = (char *)malloc( strlen(oldMsg) + 1 );
X	if ( *newMsg  == (char *)0 ) {
X		fprintf(stderr, "Monthtool error:  Out of memory.\n");
X		exit(4);
X	}
X
X	i = 0;
X	typeFound = 0;
X
X	while ( *oldMsg != '\0' ) {
X		thisIsTypeChar = 0;
X		for (j = 0; j < NUM_NOTES_TYPE; j++) {
X			if ( *oldMsg == typeChar[j] ) {
X				*type = j;
X				thisIsTypeChar = 1;
X				typeFound = 1;
X			}
X		}			
X		if (thisIsTypeChar) {
X			oldMsg++;
X			while (*oldMsg == ' ') {
X				oldMsg++;
X			}
X		}else{
X			(*newMsg)[i] = *oldMsg;
X			oldMsg++;
X			i++;
X		}		
X	} 
X	(*newMsg)[i] = '\0';
X
X	if ( !typeFound ) {
X		*type = NOTES_D_M_Y;
X	}
X
X}
X
findTime(msg, time)
X
char 	**msg;
int		 *time;
X
X{
X	char	 timeString[5];
X	char	*curChar;
X	int		 timeFound;
X
X	curChar = *msg;						
X	while (*curChar == ' ') {
X		curChar++;
X	}
X
X	if (strlen(curChar) >= 4) {		
X
X		timeFound = 1;
X		if (*(curChar+1) == ':') {
X			timeString[0] = '0';	
X		}else if (*(curChar+2) == ':') {
X			if (isdigit(*curChar)) {
X				timeString[0] = *curChar;
X				curChar++;
X			}else{
X				timeFound = 0;
X			}
X		}else{
X			timeFound = 0;
X		}
X
X		if (timeFound) {
X			if ( isdigit(*curChar) && isdigit(*(curChar+2)) && isdigit(*(curChar+3)) &&
X					( (*(curChar+4) == ' ') || (*(curChar+4) == '\0') ) ) {
X				timeString[1] = *curChar;
X				timeString[2] = *(curChar+2);
X				timeString[3] = *(curChar+3);
X				timeString[4] = '\0';						
X			}else{
X				timeFound = 0;
X			}
X		}
X	}else{
X		timeFound = 0;
X	}
X
X	if (timeFound) {
X		*time = atoi( timeString );
X		if ( ( (int)(*time / 100) >= 24 ) || ( (*time % 100 ) >= 60 ) ) {
X			*time = 0;
X		}else{
X			curChar += 4;
X			while (*curChar == ' ') {
X				curChar++;
X			}
X			*msg = curChar;
X		}
X	}else{
X		*time = 0;
X	}
X										 
X}
X
loadData()
X
X
X{
X	FILE				*fptr;
X
X	char				 basedata[MAX_MSG_LEN+100];
X	char				*timestr;
X	char				*apptstring;
X
X	int					 i;
X	struct apptsData 	*new;
X
X
X	if ((fptr = fopen(toolFile, "r")) != NULL) {
X
X		for ( i = 0; i < (NUM_NOTES_TYPE + 1 /*for NOTES_ERROR*/); i++ ){
X			firstApptRecord[i] = lastApptRecord[i] = NULL;
X		}
X
X		while ((fgets(basedata, MAX_MSG_LEN+100, fptr) != NULL)) {
X
X			basedata[MAX_MSG_LEN+99] = NULL;
X
X			new = (struct apptsData *)malloc( sizeof( struct apptsData ) );
X			if ( new == (struct apptsData *)0 ) {
X				fprintf(stderr, "Monthtool error:  Out of memory.\n");
X				exit(4);
X			}
X
X			new->month = atoi( strtok(basedata, ",") );
X			new->day = atoi( strtok(NULL, ",") );
X			new->year = atoi( strtok(NULL, ",") );
X			new->dateNum = 10000 * new->year + 100 * new->month + new->day;
X
X			timestr = strtok(NULL,","); 
X			if (strcmp(timestr, "    ") == 0) {
X				new->time = 0;
X			}else{
X				new->time = atoi(timestr);
X			} 	
X
X			apptstring = strtok(NULL, "\n" );
X			new->apptMsg = (char *)malloc(strlen(apptstring) + 1);
X			if ( new->apptMsg == (char *)0 ) {
X				fprintf(stderr, "Monthtool error:  Out of memory.\n");
X				exit(4);
X			}
X			strcpy(new->apptMsg, apptstring);
X
X			if ( new->year != 0 ) {
X				if ( new->month != 0 ) {
X					if ( new->day != 0 ) {
X						i = NOTES_D_M_Y;
X					}else{
X						i = NOTES_ERROR;    /* *mmyyyy */
X					}
X				}else{
X					i = NOTES_ERROR;		/* dd*yyyy or **yyyy */
X				}
X			}else{
X				if ( new->month == 99 ) {
X					if ( (new->day >= 1) &&  (new->day <= 7) ) {
X						i = NOTES_WEEKLY;
X					}else{
X						i = NOTES_ERROR;    
X					}
X				}else if ( new->month != 0 ) {
X					if ( new->day != 0 ) {
X						i = NOTES_D_M_ALL;
X					}else{
X						i = NOTES_ERROR;    /* *mm* */
X					}
X				}else{
X					if ( new->day != 0 ) {
X						i = NOTES_D_ALL_ALL;
X					}else{
X						i = NOTES_ALL_ALL_ALL;   
X					}
X				}
X			}
X				
X			if ( i == NOTES_ERROR ) {
X				fprintf(stderr, "Monthtool warning! Invalid record: %u,%u,%4u,",
X					new->month, new->day, new->year );
X				if (new->time != 0) {
X					fprintf(stderr, "%04u", new->time);
X				}else{
X					fprintf(stderr, "    ");
X				}
X				fprintf(stderr, ",%s\n", new->apptMsg );
X			}
X
X			insertApptRecord(new, i);
X						
X		}
X
X		fclose(fptr);
X		stat( toolFile, &lastStatus );
X	}
X
X} 
X
insertApptRecord(new, type)
X
struct apptsData 	*new;
int					 type;
X
X{
X	struct apptsData 	*cur;
X	int					 inserted;
X
X	if (lastApptRecord[type] == NULL) {
X		firstApptRecord[type] = lastApptRecord[type] = new;
X		new->prev = NULL;				
X		new->next = NULL;	
X	}else{
X		inserted = 0;
X		cur = lastApptRecord[type];
X		do {
X			if (new->dateNum >= cur->dateNum) {
X				if (cur->next != NULL) {
X					cur->next->prev = new;
X				}else{
X					lastApptRecord[type] = new;
X				}
X				new->next = cur->next;
X				new->prev = cur;
X				cur->next = new;
X				inserted = 1;
X			}else{
X				cur = cur->prev;
X			}
X		} while ( !inserted && cur != NULL );
X		if (!inserted) {
X			new->next = firstApptRecord[type];
X			new->prev = NULL;
X			firstApptRecord[type]->prev = new;
X			firstApptRecord[type] = new;
X		}						
X	}
X
X}
X
reloadData()
X
X
X{
X	struct stat			statusNow;
X
X
X	stat( toolFile, &statusNow );
X	if ( statusNow.st_mtime > lastStatus.st_mtime ) {
X		loadData();
X	}
X
X}
X
saveData()
X
X
X{
X	FILE				*fptr;
X
X	int					 i;
X	struct apptsData 	*cur;
X
X
X	notesSave();
X
X	if (notesModified) {
X
X		if ((fptr = fopen(toolFile, "w")) == NULL) {
X			fprintf(stderr, "Monthtool error:  Cannot open %s file", toolFile);
X			return;
X		}
X
X		for ( i = 0; i < (NUM_NOTES_TYPE + 1 /*for NOTES_ERROR*/); i++ ) {
X			for (cur = firstApptRecord[i]; cur != NULL; cur = cur->next) {
X				fprintf(fptr, "%u,%u,%u,", cur->month, cur->day, cur->year );
X				if (cur->time != 0) {
X					fprintf(fptr, "%04u", cur->time);
X				}else{
X					fprintf(fptr, "    ");
X				}
X				if ( strlen(cur->apptMsg) > (MAX_MSG_LEN-1) ) {
X					cur->apptMsg[MAX_MSG_LEN-1] = NULL;
X					fprintf(stderr, "Monthtool warning! Record truncated: %u,%u,%4u,",
X						cur->month, cur->day, cur->year );
X					if (cur->time != 0) {
X						fprintf(stderr, "%04u", cur->time);
X					}else{
X						fprintf(stderr, "    ");
X					}
X					fprintf(stderr, ",%s\n", cur->apptMsg );
X				}
X				fprintf(fptr, ",%s\n", cur->apptMsg );
X			}
X		}
X
X		fclose(fptr);
X		stat( toolFile, &lastStatus );
X
X		notesModified = 0;
X
X	}
X
X}
X
freeData()
X
X
X{
X
X	int					 i;
X	struct apptsData 	*cur ;
X
X	for ( i = 0; i < (NUM_NOTES_TYPE + 1 /*for NOTES_ERROR*/); i++ ) {
X		while( firstApptRecord[i] != NULL) {
X			cur = firstApptRecord[i]; 
X			firstApptRecord[i] = firstApptRecord[i]->next;
X			free(cur->apptMsg);
X			free( cur );
X		}
X	}
X	
X}
X	
END_OF_FILE
if test 43509 -ne `wc -c <'monthtool.c'`; then
    echo shar: \"'monthtool.c'\" unpacked with wrong size!
fi
# end of 'monthtool.c'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
