Subject:  v15i092:  Perl, release 2, Part03/15
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Larry Wall <lwall@jpl-devvax.jpl.nasa.gov>
Posting-number: Volume 15, Issue 92
Archive-name: perl2/part03

#! /bin/sh

# Make a new directory for the perl sources, cd to it, and run kits 1
# thru 15 through sh.  When all 15 kits have been run, read README.

echo "This is perl 2.0 kit 3 (of 15).  If kit 3 is complete, the line"
echo '"'"End of kit 3 (of 15)"'" will echo at the end.'
echo ""
export PATH || (echo "You didn't use sh, you clunch." ; kill $$)
mkdir eg eg/g t 2>/dev/null
echo Extracting perl.man.2
sed >perl.man.2 <<'!STUFFY!FUNK!' -e 's/X//'
X''' Beginning of part 2
X''' $Header: perl.man.2,v 2.0 88/06/05 00:09:30 root Exp $
X'''
X''' $Log:	perl.man.2,v $
X''' Revision 2.0  88/06/05  00:09:30  root
X''' Baseline version 2.0.
X''' 
X'''
X.Ip "goto LABEL" 8 6
XFinds the statement labeled with LABEL and resumes execution there.
XCurrently you may only go to statements in the main body of the program
Xthat are not nested inside a do {} construct.
XThis statement is not implemented very efficiently, and is here only to make
Xthe sed-to-perl translator easier.
XUse at your own risk.
X.Ip "hex(EXPR)" 8 2
XReturns the decimal value of EXPR interpreted as an hex string.
X(To interpret strings that might start with 0 or 0x see oct().)
X.Ip "index(STR,SUBSTR)" 8 4
XReturns the position of SUBSTR in STR, based at 0, or whatever you've
Xset the $[ variable to.
XIf the substring is not found, returns one less than the base, ordinarily -1.
X.Ip "int(EXPR)" 8 3
XReturns the integer portion of EXPR.
X.Ip "join(EXPR,LIST)" 8 8
X.Ip "join(EXPR,ARRAY)" 8
XJoins the separate strings of LIST or ARRAY into a single string with fields
Xseparated by the value of EXPR, and returns the string.
XExample:
X.nf
X    
X    $_ = join(\|':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);
X
X.fi
XSee
X.IR split .
X.Ip "keys(ASSOC_ARRAY)" 8 6
XReturns a normal array consisting of all the keys of the named associative
Xarray.
XThe keys are returned in an apparently random order, but it is the same order
Xas either the values() or each() function produces (given that the associative array
Xhas not been modified).
XHere is yet another way to print your environment:
X.nf
X
X.ne 5
X	@keys = keys(ENV);
X	@values = values(ENV);
X	while ($#keys >= 0) {
X		print pop(keys),'=',pop(values),"\en";
X	}
X
Xor how about sorted by key:
X
X.ne 3
X	foreach $key (sort keys(ENV)) {
X		print $key,'=',$ENV{$key},"\en";
X	}
X
X.fi
X.Ip "kill LIST" 8 2
XSends a signal to a list of processes.
XThe first element of the list must be the (numerical) signal to send.
XReturns the number of processes successfully signaled.
X.nf
X
X	$cnt = kill 1,$child1,$child2;
X	kill 9,@goners;
X
X.fi
XIf the signal is negative, kills process groups instead of processes.
X(On System V, a negative \fIprocess\fR number will also kill process groups,
Xbut that's not portable.)
X.Ip "last LABEL" 8 8
X.Ip "last" 8
XThe
X.I last
Xcommand is like the
X.I break
Xstatement in C (as used in loops); it immediately exits the loop in question.
XIf the LABEL is omitted, the command refers to the innermost enclosing loop.
XThe
X.I continue
Xblock, if any, is not executed:
X.nf
X
X.ne 4
X	line: while (<stdin>) {
X		last line if /\|^$/;	# exit when done with header
X		.\|.\|.
X	}
X
X.fi
X.Ip "length(EXPR)" 8 2
XReturns the length in characters of the value of EXPR.
X.Ip "link(OLDFILE,NEWFILE)" 8 2
XCreates a new filename linked to the old filename.
XReturns 1 for success, 0 otherwise.
X.Ip "local(LIST)" 8 4
XDeclares the listed (scalar) variables to be local to the enclosing block,
Xsubroutine or eval.
X(The "do 'filename';" operator also counts as an eval.)
XThis operator works by saving the current values of those variables in LIST
Xon a hidden stack and restoring them upon exiting the block, subroutine or eval.
XThe LIST may be assigned to if desired, which allows you to initialize
Xyour local variables.
XCommonly this is used to name the parameters to a subroutine.
XExamples:
X.nf
X
X.ne 13
X	sub RANGEVAL {
X		local($min, $max, $thunk) = @_;
X		local($result) = '';
X		local($i);
X
X		# Presumably $thunk makes reference to $i
X
X		for ($i = $min; $i < $max; $i++) {
X			$result .= eval $thunk;
X		}
X
X		$result;
X	}
X
X.fi
X.Ip "localtime(EXPR)" 8 4
XConverts a time as returned by the time function to a 9-element array with
Xthe time analyzed for the local timezone.
XTypically used as follows:
X.nf
X
X.ne 3
X    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)
X       = localtime(time);
X
X.fi
XAll array elements are numeric, and come straight out of a struct tm.
XIn particular this means that $mon has the range 0..11 and $wday has the
Xrange 0..6.
X.Ip "log(EXPR)" 8 3
XReturns logarithm (base e) of EXPR.
X.Ip "next LABEL" 8 8
X.Ip "next" 8
XThe
X.I next
Xcommand is like the
X.I continue
Xstatement in C; it starts the next iteration of the loop:
X.nf
X
X.ne 4
X	line: while (<stdin>) {
X		next line if /\|^#/;	# discard comments
X		.\|.\|.
X	}
X
X.fi
XNote that if there were a
X.I continue
Xblock on the above, it would get executed even on discarded lines.
XIf the LABEL is omitted, the command refers to the innermost enclosing loop.
X.Ip "oct(EXPR)" 8 2
XReturns the decimal value of EXPR interpreted as an octal string.
X(If EXPR happens to start off with 0x, interprets it as a hex string instead.)
XThe following will handle decimal, octal and hex in the standard notation:
X.nf
X
X	$val = oct($val) if $val =~ /^0/;
X
X.fi
X.Ip "open(FILEHANDLE,EXPR)" 8 8
X.Ip "open(FILEHANDLE)" 8
X.Ip "open FILEHANDLE" 8
XOpens the file whose filename is given by EXPR, and associates it with
XFILEHANDLE.
XIf FILEHANDLE is an expression, its value is used as the name of the
Xreal filehandle wanted.
XIf EXPR is omitted, the scalar variable of the same name as the FILEHANDLE
Xcontains the filename.
XIf the filename begins with \*(L">\*(R", the file is opened for output.
XIf the filename begins with \*(L">>\*(R", the file is opened for appending.
XIf the filename begins with \*(L"|\*(R", the filename is interpreted
Xas a command to which output is to be piped, and if the filename ends
Xwith a \*(L"|\*(R", the filename is interpreted as command which pipes
Xinput to us.
X(You may not have a command that pipes both in and out.)
XOpening '\-' opens stdin and opening '>\-' opens stdout.
XOpen returns 1 upon success, '' otherwise.
XExamples:
X.nf
X    
X.ne 3
X	$article = 100;
X	open article || die "Can't find article $article";
X	while (<article>) {\|.\|.\|.
X
X	open(LOG, '>>/usr/spool/news/twitlog'\|);	# (log is reserved)
X
X	open(article, "caeser <$article |"\|);		# decrypt article
X
X	open(extract, "|sort >/tmp/Tmp$$"\|);		# $$ is our process#
X
X.ne 7
X	# process argument list of files along with any includes
X
X	foreach $file (@ARGV) {
X		do process($file,'fh00');	# no pun intended
X	}
X
X	sub process {{
X		local($filename,$input) = @_;
X		$input++;		# this is a string increment
X		unless (open($input,$filename)) {
X			print stderr "Can't open $filename\en";
X			last;		# note block inside sub
X		}
X		while (<$input>) {		# note the use of indirection
X			if (/^#include "(.*)"/) {
X				do process($1,$input);
X				next;
X			}
X			.\|.\|.		# whatever
X		}
X	}}
X
X.fi
XYou may also, in the Bourne shell tradition, specify an EXPR beginning
Xwith ">&", in which case the rest of the string
Xis interpreted as the name of a filehandle
X(or file descriptor, if numeric) which is to be duped and opened.
XHere is a script that saves, redirects, and restores stdout and stdin:
X.nf
X
X.ne 21
X	#!/usr/bin/perl
X	open(saveout,">&stdout");
X	open(saveerr,">&stderr");
X
X	open(stdout,">foo.out") || die "Can't redirect stdout";
X	open(stderr,">&stdout") || die "Can't dup stdout";
X
X	select(stderr); $| = 1;		# make unbuffered
X	select(stdout); $| = 1;		# make unbuffered
X
X	print stdout "stdout 1\en";	# this works for
X	print stderr "stderr 1\en";	# subprocesses too
X
X	close(stdout);
X	close(stderr);
X
X	open(stdout,">&saveout");
X	open(stderr,">&saveerr");
X
X	print stdout "stdout 2\en";
X	print stderr "stderr 2\en";
X
X.fi
XIf you open a pipe on the command "-", i.e. either "|-" or "-|",
Xthen there is an implicit fork done, and the return value of open
Xis the pid of the child within the parent process, and 0 within the child
Xprocess.
XThe filehandle behaves normally for the parent, but i/o to that
Xfilehandle is piped from/to the stdout/stdin of the child process.
XIn the child process the filehandle isn't opened--i/o happens from/to
Xthe new stdout or stdin.
XTypically this is used like the normal piped open when you want to exercise
Xmore control over just how the pipe command gets executed, such as when
Xyou are running setuid, and don't want to have to scan shell commands
Xfor metacharacters.
XThe following pairs are equivalent:
X.nf
X
X.ne 5
X	open(FOO,"|tr '[a-z]' '[A-Z]'");
X	open(FOO,"|-") || exec 'tr', '[a-z]', '[A-Z]';
X
X	open(FOO,"cat -n $file|");
X	open(FOO,"-|") || exec 'cat', '-n', $file;
X
X.fi
XExplicitly closing the filehandle causes the parent process to wait for the
Xchild to finish, and returns the status value in $?.
X.Ip "ord(EXPR)" 8 3
XReturns the ascii value of the first character of EXPR.
X.Ip "pop ARRAY" 8 6
X.Ip "pop(ARRAY)" 8
XPops and returns the last value of the array, shortening the array by 1.
XHas the same effect as
X.nf
X
X	$tmp = $ARRAY[$#ARRAY]; $#ARRAY--;
X
X.fi
X.Ip "print FILEHANDLE LIST" 8 9
X.Ip "print LIST" 8
X.Ip "print" 8
XPrints a string or a comma-separated list of strings.
XFILEHANDLE may be a scalar variable name, in which case the variable contains
Xthe name of the filehandle, thus introducing one level of indirection.
XIf FILEHANDLE is omitted, prints by default to standard output (or to the
Xlast selected output channel\*(--see select()).
XIf LIST is also omitted, prints $_ to stdout.
XTo set the default output channel to something other than stdout use the select operation.
X.Ip "printf FILEHANDLE LIST" 8 9
X.Ip "printf LIST" 8
XEquivalent to a "print FILEHANDLE sprintf(LIST)".
X.Ip "push(ARRAY,LIST)" 8 7
XTreats ARRAY (@ is optional) as a stack, and pushes the values of LIST
Xonto the end of ARRAY.
XThe length of ARRAY increases by the length of LIST.
XHas the same effect as
X.nf
X
X    for $value (LIST) {
X	    $ARRAY[$#ARRAY+1] = $value;
X    }
X
X.fi
Xbut is more efficient.
X.Ip "redo LABEL" 8 8
X.Ip "redo" 8
XThe
X.I redo
Xcommand restarts the loop block without evaluating the conditional again.
XThe
X.I continue
Xblock, if any, is not executed.
XIf the LABEL is omitted, the command refers to the innermost enclosing loop.
XThis command is normally used by programs that want to lie to themselves
Xabout what was just input:
X.nf
X
X.ne 16
X	# a simpleminded Pascal comment stripper
X	# (warning: assumes no { or } in strings)
X	line: while (<stdin>) {
X		while (s|\|({.*}.*\|){.*}|$1 \||) {}
X		s|{.*}| \||;
X		if (s|{.*| \||) {
X			$front = $_;
X			while (<stdin>) {
X				if (\|/\|}/\|) {	# end of comment?
X					s|^|$front{|;
X					redo line;
X				}
X			}
X		}
X		print;
X	}
X
X.fi
X.Ip "rename(OLDNAME,NEWNAME)" 8 2
XChanges the name of a file.
XReturns 1 for success, 0 otherwise.
X.Ip "reset EXPR" 8 3
XGenerally used in a
X.I continue
Xblock at the end of a loop to clear variables and reset ?? searches
Xso that they work again.
XThe expression is interpreted as a list of single characters (hyphens allowed
Xfor ranges).
XAll variables and arrays beginning with one of those letters are reset to
Xtheir pristine state.
XIf the expression is omitted, one-match searches (?pattern?) are reset to
Xmatch again.
XAlways returns 1.
XExamples:
X.nf
X
X.ne 3
X    reset 'X';	\h'|2i'# reset all X variables
X    reset 'a-z';\h'|2i'# reset lower case variables
X    reset;	\h'|2i'# just reset ?? searches
X
X.fi
XNote: resetting "A-Z" is not recommended since you'll wipe out your ARGV and ENV
Xarrays.
X.Ip "s/PATTERN/REPLACEMENT/gi" 8 3
XSearches a string for a pattern, and if found, replaces that pattern with the
Xreplacement text and returns the number of substitutions made.
XOtherwise it returns false (0).
XThe \*(L"g\*(R" is optional, and if present, indicates that all occurences
Xof the pattern are to be replaced.
XThe \*(L"i\*(R" is also optional, and if present, indicates that matching
Xis to be done in a case-insensitive manner.
XAny delimiter may replace the slashes; if single quotes are used, no
Xinterpretation is done on the replacement string.
XIf no string is specified via the =~ or !~ operator,
Xthe $_ string is searched and modified.
X(The string specified with =~ must be a scalar variable, an array element,
Xor an assignment to one of those, i.e. an lvalue.)
XIf the pattern contains a $ that looks like a variable rather than an
Xend-of-string test, the variable will be interpolated into the pattern at
Xrun-time.
XSee also the section on regular expressions.
XExamples:
X.nf
X
X    s/\|\e\|bgreen\e\|b/mauve/g;		# don't change wintergreen
X
X    $path \|=~ \|s|\|/usr/bin|\|/usr/local/bin|;
X
X    s/Login: $foo/Login: $bar/; # run-time pattern
X
X    s/\|([^ \|]*\|) *\|([^ \|]*\|)\|/\|$2 $1/;	# reverse 1st two fields
X
X    ($foo = $bar) =~ s/bar/foo/;
X
X.fi
X(Note the use of $ instead of \|\e\| in the last example.  See section
Xon regular expressions.)
X.Ip "seek(FILEHANDLE,POSITION,WHENCE)" 8 3
XRandomly positions the file pointer for FILEHANDLE, just like the fseek()
Xcall of stdio.
XFILEHANDLE may be an expression whose value gives the name of the filehandle.
XReturns 1 upon success, 0 otherwise.
X.Ip "select(FILEHANDLE)" 8 3
XSets the current default filehandle for output.
XThis has two effects: first, a
X.I write
Xor a
X.I print
Xwithout a filehandle will default to this FILEHANDLE.
XSecond, references to variables related to output will refer to this output
Xchannel.
XFor example, if you have to set the top of form format for more than
Xone output channel, you might do the following:
X.nf
X
X.ne 4
X    select(report1);
X    $^ = 'report1_top';
X    select(report2);
X    $^ = 'report2_top';
X
X.fi
XSelect happens to return TRUE if the file is currently open and FALSE otherwise,
Xbut this has no effect on its operation.
XFILEHANDLE may be an expression whose value gives the name of the actual filehandle.
X.Ip "shift(ARRAY)" 8 6
X.Ip "shift ARRAY" 8
X.Ip "shift" 8
XShifts the first value of the array off and returns it,
Xshortening the array by 1 and moving everything down.
XIf ARRAY is omitted, shifts the ARGV array.
XSee also unshift(), push() and pop().
XShift() and unshift() do the same thing to the left end of an array that push()
Xand pop() do to the right end.
X.Ip "sleep EXPR" 8 6
X.Ip "sleep" 8
XCauses the script to sleep for EXPR seconds, or forever if no EXPR.
XMay be interrupted by sending the process a SIGALARM.
XReturns the number of seconds actually slept.
X.Ip "sort SUBROUTINE LIST" 8 7
X.Ip "sort LIST" 8
XSorts the LIST and returns the sorted array value.
XNonexistent values of arrays are stripped out.
XIf SUBROUTINE is omitted, sorts in standard string comparison order.
XIf SUBROUTINE is specified, gives the name of a subroutine that returns
Xa -1, 0, or 1, depending on how the elements of the array are to be ordered.
XIn the interests of efficiency the normal calling code for subroutines
Xis bypassed, with the following effects: the subroutine may not be a recursive
Xsubroutine, and the two elements to be compared are passed into the subroutine
Xnot via @_ but as $a and $b (see example below).
XSUBROUTINE may be a scalar variable name, in which case the value provides
Xthe name of the subroutine to use.
XExamples:
X.nf
X
X.ne 4
X	sub byage {
X	    $age{$a} < $age{$b} ? -1 : $age{$a} > $age{$b} ? 1 : 0;
X	}
X	@sortedclass = sort byage @class;
X
X.ne 9
X	sub reverse { $a lt $b ? 1 : $a gt $b ? -1 : 0; }
X	@harry = ('dog','cat','x','Cain','Abel');
X	@george = ('gone','chased','yz','Punished','Axed');
X	print sort @harry;
X		# prints AbelCaincatdogx
X	print sort reverse @harry;
X		# prints xdogcatCainAbel
X	print sort @george,'to',@harry;
X		# prints AbelAxedCainPunishedcatchaseddoggonetoxyz
X
X.fi
X.Ip "split(/PATTERN/,EXPR)" 8 8
X.Ip "split(/PATTERN/)" 8
X.Ip "split" 8
XSplits a string into an array of strings, and returns it.
XIf EXPR is omitted, splits the $_ string.
XIf PATTERN is also omitted, splits on whitespace (/[\ \et\en]+/).
XAnything matching PATTERN is taken to be a delimiter separating the fields.
X(Note that the delimiter may be longer than one character.)
XTrailing null fields are stripped, which potential users of pop() would
Xdo well to remember.
XA pattern matching the null string (not to be confused with a null pattern)
Xwill split the value of EXPR into separate characters at each point it
Xmatches that way.
XFor example:
X.nf
X
X	print join(':',split(/ */,'hi there'));
X
X.fi
Xproduces the output 'h:i:t:h:e:r:e'.
X
XThe pattern /PATTERN/ may be replaced with an expression to specify patterns
Xthat vary at runtime.
XAs a special case, specifying a space ('\ ') will split on white space
Xjust as split with no arguments does, but leading white space does NOT
Xproduce a null first field.
XThus, split('\ ') can be used to emulate awk's default behavior, whereas
Xsplit(/\ /) will give you as many null initial fields as there are
Xleading spaces.
X.sp
XExample:
X.nf
X
X.ne 5
X	open(passwd, '/etc/passwd');
X	while (<passwd>) {
X.ie t \{\
X		($login, $passwd, $uid, $gid, $gcos, $home, $shell) = split(\|/\|:\|/\|);
X'br\}
X.el \{\
X		($login, $passwd, $uid, $gid, $gcos, $home, $shell)
X			= split(\|/\|:\|/\|);
X'br\}
X		.\|.\|.
X	}
X
X.fi
X(Note that $shell above will still have a newline on it.  See chop().)
XSee also
X.IR join .
X.Ip "sprintf(FORMAT,LIST)" 8 4
XReturns a string formatted by the usual printf conventions.
XThe * character is not supported.
X.Ip "sqrt(EXPR)" 8 3
XReturn the square root of EXPR.
X.Ip "stat(FILEHANDLE)" 8 6
X.Ip "stat(EXPR)" 8
XReturns a 13-element array giving the statistics for a file, either the file
Xopened via FILEHANDLE, or named by EXPR.
XTypically used as follows:
X.nf
X
X.ne 3
X    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
X       $atime,$mtime,$ctime,$blksize,$blocks)
X           = stat($filename);
X
X.fi
X.Ip "study(SCALAR)" 8 6
X.Ip "study"
XTakes extra time to study SCALAR ($_ if unspecified) in anticipation of
Xdoing many pattern matches on the string before it is next modified.
XThis may or may not save time, depending on the nature and number of patterns
Xyou are searching on\*(--you probably want to compare runtimes with and
Xwithout it to see which runs faster.
XThose loops which scan for many short constant strings (including the constant
Xparts of more complex patterns) will benefit most.
XFor example, a loop which inserts index producing entries before an line
Xcontaining a certain pattern:
X.nf
X
X.ne 8
X	while (<>) {
X		study;
X		print ".IX foo\en" if /\ebfoo\eb/;
X		print ".IX bar\en" if /\ebbar\eb/;
X		print ".IX blurfl\en" if /\ebblurfl\eb/;
X		.\|.\|.
X		print;
X	}
X
X.fi
X.Ip "substr(EXPR,OFFSET,LEN)" 8 2
XExtracts a substring out of EXPR and returns it.
XFirst character is at offset 0, or whatever you've set $[ to.
X.Ip "system LIST" 8 6
XDoes exactly the same thing as \*(L"exec LIST\*(R" except that a fork
Xis done first, and the parent process waits for the child process to complete.
XNote that argument processing varies depending on the number of arguments.
XThe return value is the exit status of the program as returned by the wait()
Xcall.
XTo get the actual exit value divide by 256.
XSee also exec.
X.Ip "symlink(OLDFILE,NEWFILE)" 8 2
XCreates a new filename symbolically linked to the old filename.
XReturns 1 for success, 0 otherwise.
XOn systems that don't support symbolic links, produces a fatal error at
Xrun time.
XTo check for that, use eval:
X.nf
X
X	$symlink_exists = (eval 'symlink("","");', $@ eq '');
X
X.fi
X.Ip "tell(FILEHANDLE)" 8 6
X.Ip "tell" 8
XReturns the current file position for FILEHANDLE.
XFILEHANDLE may be an expression whose value gives the name of the actual
Xfilehandle.
XIf FILEHANDLE is omitted, assumes the file last read.
X.Ip "time" 8 4
XReturns the number of seconds since January 1, 1970.
XSuitable for feeding to gmtime() and localtime().
X.Ip "times" 8 4
XReturns a four-element array giving the user and system times, in seconds, for this
Xprocess and the children of this process.
X.sp
X    ($user,$system,$cuser,$csystem) = times;
X.sp
X.Ip "tr/SEARCHLIST/REPLACEMENTLIST/" 8 5
X.Ip "y/SEARCHLIST/REPLACEMENTLIST/" 8
XTranslates all occurences of the characters found in the search list with
Xthe corresponding character in the replacement list.
XIt returns the number of characters replaced.
XIf no string is specified via the =~ or !~ operator,
Xthe $_ string is translated.
X(The string specified with =~ must be a scalar variable, an array element,
Xor an assignment to one of those, i.e. an lvalue.)
XFor
X.I sed
Xdevotees,
X.I y
Xis provided as a synonym for
X.IR tr .
XExamples:
X.nf
X
X    $ARGV[1] \|=~ \|y/A-Z/a-z/;	\h'|3i'# canonicalize to lower case
X
X    $cnt = tr/*/*/;		\h'|3i'# count the stars in $_
X
X    ($HOST = $host) =~ tr/a-z/A-Z/;
X
X.fi
X.Ip "umask(EXPR)" 8 3
XSets the umask for the process and returns the old one.
X.Ip "unlink LIST" 8 2
XDeletes a list of files.
XReturns the number of files successfully deleted.
X.nf
X
X.ne 2
X	$cnt = unlink 'a','b','c';
X	unlink @goners;
X
X.fi
XNote: unlink will not delete directories unless you are superuser and the \-U
Xflag is supplied to perl.
X.ne 7
X.Ip "unshift(ARRAY,LIST)" 8 4
XDoes the opposite of a shift.
XOr the opposite of a push, depending on how you look at it.
XPrepends list to the front of the array, and returns the number of elements
Xin the new array.
X.nf
X
X	unshift(ARGV,'-e') unless $ARGV[0] =~ /^-/;
X
X.fi
X.Ip "utime LIST" 8 2
XChanges the access and modification times on each file of a list of files.
XThe first two elements of the list must be the NUMERICAL access and
Xmodification times, in that order.
XReturns the number of files successfully changed.
XThe inode modification time of each file is set to the current time.
XExample of a "touch" command:
X.nf
X
X.ne 3
X	#!/usr/bin/perl
X	$now = time;
X	utime $now,$now,@ARGV;
X
X.fi
X.Ip "values(ASSOC_ARRAY)" 8 6
XReturns a normal array consisting of all the values of the named associative
Xarray.
XThe values are returned in an apparently random order, but it is the same order
Xas either the keys() or each() function produces (given that the associative array
Xhas not been modified).
XSee also keys() and each().
X.Ip "wait" 8 6
XWaits for a child process to terminate and returns the pid of the deceased
Xprocess.
XThe status is returned in $?.
X.Ip "write(FILEHANDLE)" 8 6
X.Ip "write(EXPR)" 8
X.Ip "write(\|)" 8
XWrites a formatted record (possibly multi-line) to the specified file,
Xusing the format associated with that file.
XBy default the format for a file is the one having the same name is the
Xfilehandle, but the format for the current output channel (see
X.IR select )
Xmay be set explicitly
Xby assigning the name of the format to the $~ variable.
X.sp
XTop of form processing is handled automatically:
Xif there is insufficient room on the current page for the formatted 
Xrecord, the page is advanced, a special top-of-page format is used
Xto format the new page header, and then the record is written.
XBy default the top-of-page format is \*(L"top\*(R", but it
Xmay be set to the
Xformat of your choice by assigning the name to the $^ variable.
X.sp
XIf FILEHANDLE is unspecified, output goes to the current default output channel,
Xwhich starts out as stdout but may be changed by the
X.I select
Xoperator.
XIf the FILEHANDLE is an EXPR, then the expression is evaluated and the
Xresulting string is used to look up the name of the FILEHANDLE at run time.
XFor more on formats, see the section on formats later on.
X.Sh "Precedence"
XPerl operators have the following associativity and precedence:
X.nf
X
Xnonassoc\h'|1i'print printf exec system sort
X\h'1.5i'chmod chown kill unlink utime
Xleft\h'|1i',
Xright\h'|1i'=
Xright\h'|1i'?:
Xnonassoc\h'|1i'..
Xleft\h'|1i'||
Xleft\h'|1i'&&
Xleft\h'|1i'| ^
Xleft\h'|1i'&
Xnonassoc\h'|1i'== != eq ne
Xnonassoc\h'|1i'< > <= >= lt gt le ge
Xnonassoc\h'|1i'chdir die exit eval reset sleep
Xnonassoc\h'|1i'-r -w -x etc.
Xleft\h'|1i'<< >>
Xleft\h'|1i'+ - .
Xleft\h'|1i'* / % x
Xleft\h'|1i'=~ !~ 
Xright\h'|1i'! ~ and unary minus
Xnonassoc\h'|1i'++ --
Xleft\h'|1i''('
X
X.fi
XActually, the precedence of list operators such as print, sort or chmod is
Xeither very high or very low depending on whether you look at the left
Xside of operator or the right side of it.
XFor example, in
X
X	@ary = (1, 3, sort 4, 2);
X	print @ary;		# prints 1324
X
Xthe commas on the right of the sort are evaluated before the sort, but
Xthe commas on the left are evaluated after.
XIn other words, list operators tend to gobble up all the arguments that
Xfollow them, and then act like a simple term with regard to the preceding
Xexpression.
X.Sh "Subroutines"
XA subroutine may be declared as follows:
X.nf
X
X    sub NAME BLOCK
X
X.fi
X.PP
XAny arguments passed to the routine come in as array @_,
Xthat is ($_[0], $_[1], .\|.\|.).
XThe return value of the subroutine is the value of the last expression
Xevaluated.
XTo create local variables see the "local" operator.
X.PP
XA subroutine is called using the
X.I do
Xoperator.
X.nf
X
X.ne 12
XExample:
X
X	sub MAX {
X		local($max) = pop(@_);
X		foreach $foo (@_) {
X			$max = $foo \|if \|$max < $foo;
X		}
X		$max;
X	}
X
X	.\|.\|.
X	$bestday = do MAX($mon,$tue,$wed,$thu,$fri);
X
X.ne 21
XExample:
X
X	# get a line, combining continuation lines
X	#  that start with whitespace
X	sub get_line {
X		$thisline = $lookahead;
X		line: while ($lookahead = <stdin>) {
X			if ($lookahead \|=~ \|/\|^[ \^\e\|t]\|/\|) {
X				$thisline \|.= \|$lookahead;
X			}
X			else {
X				last line;
X			}
X		}
X		$thisline;
X	}
X
X	$lookahead = <stdin>;	# get first line
X	while ($_ = get_line(\|)) {
X		.\|.\|.
X	}
X
X.fi
X.nf
X.ne 6
XUse array assignment to local list to name your formal arguments:
X
X	sub maybeset {
X		local($key,$value) = @_;
X		$foo{$key} = $value unless $foo{$key};
X	}
X
X.fi
XSubroutines may be called recursively.
X.Sh "Regular Expressions"
XThe patterns used in pattern matching are regular expressions such as
Xthose supplied in the Version 8 regexp routines.
X(In fact, the routines are derived from Henry Spencer's freely redistributable
Xreimplementation of the V8 routines.)
XIn addition, \ew matches an alphanumeric character (including "_") and \eW a nonalphanumeric.
XWord boundaries may be matched by \eb, and non-boundaries by \eB.
XA whitespace character is matched by \es, non-whitespace by \eS.
XA numeric character is matched by \ed, non-numeric by \eD.
XYou may use \ew, \es and \ed within character classes.
XAlso, \en, \er, \ef, \et and \eNNN have their normal interpretations.
XWithin character classes \eb represents backspace rather than a word boundary.
XThe bracketing construct \|(\ .\|.\|.\ \|) may also be used, in which case \e<digit>
Xmatches the digit'th substring, where digit can range from 1 to 9.
X(Outside of patterns, use $ instead of \e in front of the digit.
XThe scope of $<digit> extends to the end of the enclosing BLOCK, or to
Xthe next pattern match with subexpressions.)
X$+ returns whatever the last bracket match matched.
X$& returns the entire matched string.
X($0 normally returns the same thing, but don't depend on it.)
XAlternatives may be separated by |.
XExamples:
X.nf
X    
X	s/\|^\|([^ \|]*\|) \|*([^ \|]*\|)\|/\|$2 $1\|/;	# swap first two words
X
X.ne 5
X	if (/\|Time: \|(.\|.\|):\|(.\|.\|):\|(.\|.\|)\|/\|) {
X		$hours = $1;
X		$minutes = $2;
X		$seconds = $3;
X	}
X
X.fi
XBy default, the ^ character matches only the beginning of the string, and
X.I perl
Xdoes certain optimizations with the assumption that the string contains
Xonly one line.
XYou may, however, wish to treat a string as a multi-line buffer, such that
Xthe ^ will match after any newline within the string.
XAt the cost of a little more overhead, you can do this by setting the variable
X$* to 1.
XSetting it back to 0 makes
X.I perl
Xrevert to its old behavior.
X.PP
XTo facilitate multi-line substitutions, the . character never matches a newline.
XIn particular, the following leaves a newline on the $_ string:
X.nf
X
X	$_ = <stdin>;
X	s/.*(some_string).*/$1/;
X
XIf the newline is unwanted, try one of
X
X	s/.*(some_string).*\en/$1/;
X	s/.*(some_string)[^\000]*/$1/;
X	s/.*(some_string)(.|\en)*/$1/;
X	chop; s/.*(some_string).*/$1/;
X	/(some_string)/ && ($_ = $1);
X
X.fi
X.Sh "Formats"
XOutput record formats for use with the
X.I write
Xoperator may declared as follows:
X.nf
X
X.ne 3
X    format NAME =
X    FORMLIST
X    .
X
X.fi
XIf name is omitted, format \*(L"stdout\*(R" is defined.
XFORMLIST consists of a sequence of lines, each of which may be of one of three
Xtypes:
X.Ip 1. 4
XA comment.
X.Ip 2. 4
XA \*(L"picture\*(R" line giving the format for one output line.
X.Ip 3. 4
XAn argument line supplying values to plug into a picture line.
X.PP
XPicture lines are printed exactly as they look, except for certain fields
Xthat substitute values into the line.
XEach picture field starts with either @ or ^.
XThe @ field (not to be confused with the array marker @) is the normal
Xcase; ^ fields are used
Xto do rudimentary multi-line text block filling.
XThe length of the field is supplied by padding out the field
Xwith multiple <, >, or | characters to specify, respectively, left justfication,
Xright justification, or centering.
XIf any of the values supplied for these fields contains a newline, only
Xthe text up to the newline is printed.
XThe special field @* can be used for printing multi-line values.
XIt should appear by itself on a line.
X.PP
XThe values are specified on the following line, in the same order as
Xthe picture fields.
XThey must currently be either scalar variable names or literals (or
Xpseudo-literals).
XCurrently you can separate values with spaces, but commas may be placed
Xbetween values to prepare for possible future versions in which full expressions
Xare allowed as values.
X.PP
XPicture fields that begin with ^ rather than @ are treated specially.
XThe value supplied must be a scalar variable name which contains a text
Xstring.
X.I Perl
Xputs as much text as it can into the field, and then chops off the front
Xof the string so that the next time the variable is referenced,
Xmore of the text can be printed.
XNormally you would use a sequence of fields in a vertical stack to print
Xout a block of text.
XIf you like, you can end the final field with .\|.\|., which will appear in the
Xoutput if the text was too long to appear in its entirety.
X.PP
XSince use of ^ fields can produce variable length records if the text to be
Xformatted is short, you can suppress blank lines by putting the tilde (~)
Xcharacter anywhere in the line.
X(Normally you should put it in the front if possible.)
XThe tilde will be translated to a space upon output.
X.PP
XExamples:
X.nf
X.lg 0
X.cs R 25
X
X.ne 10
X# a report on the /etc/passwd file
Xformat top =
X\&                        Passwd File
XName                Login    Office   Uid   Gid Home
X------------------------------------------------------------------
X\&.
Xformat stdout =
X@<<<<<<<<<<<<<<<<<< @||||||| @<<<<<<@>>>> @>>>> @<<<<<<<<<<<<<<<<<
X$name               $login   $office $uid $gid  $home
X\&.
X
X.ne 29
X# a report from a bug report form
Xformat top =
X\&                        Bug Reports
X@<<<<<<<<<<<<<<<<<<<<<<<     @|||         @>>>>>>>>>>>>>>>>>>>>>>>
X$system;                      $%;         $date
X------------------------------------------------------------------
X\&.
Xformat stdout =
XSubject: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
X\&         $subject
XIndex: @<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
X\&       $index                        $description
XPriority: @<<<<<<<<<< Date: @<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
X\&          $priority         $date    $description
XFrom: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
X\&      $from                          $description
XAssigned to: @<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
X\&             $programmer             $description
X\&~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
X\&                                     $description
X\&~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
X\&                                     $description
X\&~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
X\&                                     $description
X\&~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
X\&                                     $description
X\&~                                    ^<<<<<<<<<<<<<<<<<<<<<<<...
X\&                                     $description
X\&.
X
X.cs R
X.lg
XIt is possible to intermix prints with writes on the same output channel,
Xbut you'll have to handle $\- (lines left on the page) yourself.
X.fi
X.PP
XIf you are printing lots of fields that are usually blank, you should consider
Xusing the reset operator between records.
XNot only is it more efficient, but it can prevent the bug of adding another
Xfield and forgetting to zero it.
X.Sh "Predefined Names"
XThe following names have special meaning to
X.IR perl .
XI could have used alphabetic symbols for some of these, but I didn't want
Xto take the chance that someone would say reset "a-zA-Z" and wipe them all
Xout.
XYou'll just have to suffer along with these silly symbols.
XMost of them have reasonable mnemonics, or analogues in one of the shells.
X.Ip $_ 8
XThe default input and pattern-searching space.
XThe following pairs are equivalent:
X.nf
X
X.ne 2
X	while (<>) {\|.\|.\|.	# only equivalent in while!
X	while ($_ = <>) {\|.\|.\|.
X
X.ne 2
X	/\|^Subject:/
X	$_ \|=~ \|/\|^Subject:/
X
X.ne 2
X	y/a-z/A-Z/
X	$_ =~ y/a-z/A-Z/
X
X.ne 2
X	chop
X	chop($_)
X
X.fi 
X(Mnemonic: underline is understood in certain operations.)
X.Ip $. 8
XThe current input line number of the last filehandle that was read.
XReadonly.
XRemember that only an explicit close on the filehandle resets the line number.
XSince <> never does an explicit close, line numbers increase across ARGV files
X(but see examples under eof).
X(Mnemonic: many programs use . to mean the current line number.)
X.Ip $/ 8
XThe input record separator, newline by default.
XWorks like awk's RS variable, including treating blank lines as delimiters
Xif set to the null string.
XIf set to a value longer than one character, only the first character is used.
X(Mnemonic: / is used to delimit line boundaries when quoting poetry.)
X.Ip $, 8
XThe output field separator for the print operator.
XOrdinarily the print operator simply prints out the comma separated fields
Xyou specify.
XIn order to get behavior more like awk, set this variable as you would set
Xawk's OFS variable to specify what is printed between fields.
X(Mnemonic: what is printed when there is a , in your print statement.)
X.Ip $\e 8
XThe output record separator for the print operator.
XOrdinarily the print operator simply prints out the comma separated fields
Xyou specify, with no trailing newline or record separator assumed.
XIn order to get behavior more like awk, set this variable as you would set
Xawk's ORS variable to specify what is printed at the end of the print.
X(Mnemonic: you set $\e instead of adding \en at the end of the print.
XAlso, it's just like /, but it's what you get \*(L"back\*(R" from perl.)
X.Ip $# 8
XThe output format for printed numbers.
XThis variable is a half-hearted attempt to emulate awk's OFMT variable.
XThere are times, however, when awk and perl have differing notions of what
Xis in fact numeric.
XAlso, the initial value is %.20g rather than %.6g, so you need to set $#
Xexplicitly to get awk's value.
X(Mnemonic: # is the number sign.)
X.Ip $% 8
XThe current page number of the currently selected output channel.
X(Mnemonic: % is page number in nroff.)
X.Ip $= 8
XThe current page length (printable lines) of the currently selected output
Xchannel.
XDefault is 60.
X(Mnemonic: = has horizontal lines.)
X.Ip $\- 8
XThe number of lines left on the page of the currently selected output channel.
X(Mnemonic: lines_on_page - lines_printed.)
X.Ip $~ 8
XThe name of the current report format for the currently selected output
Xchannel.
X(Mnemonic: brother to $^.)
X.Ip $^ 8
XThe name of the current top-of-page format for the currently selected output
Xchannel.
X(Mnemonic: points to top of page.)
X.Ip $| 8
XIf set to nonzero, forces a flush after every write or print on the currently
Xselected output channel.
XDefault is 0.
XNote that stdout will typically be line buffered if output is to the
Xterminal and block buffered otherwise.
XSetting this variable is useful primarily when you are outputting to a pipe,
Xsuch as when you are running a perl script under rsh and want to see the
Xoutput as it's happening.
X(Mnemonic: when you want your pipes to be piping hot.)
X.Ip $$ 8
XThe process number of the
X.I perl
Xrunning this script.
X(Mnemonic: same as shells.)
X.Ip $? 8
XThe status returned by the last backtick (``) command or system operator.
XNote that this is the status word returned by the wait() system
Xcall, so the exit value of the subprocess is actually ($? >> 8).
X$? & 255 gives which signal, if any, the process died from, and whether
Xthere was a core dump.
X(Mnemonic: similar to sh and ksh.)
X.Ip $& 8 4
XThe string matched by the last pattern match.
X(Mnemonic: like & in some editors.)
X.Ip $+ 8 4
XThe last bracket matched by the last search pattern.
XThis is useful if you don't know which of a set of alternative patterns
Xmatched.
XFor example:
X.nf
X
X    /Version: \|(.*\|)|Revision: \|(.*\|)\|/ \|&& \|($rev = $+);
X
X.fi
X(Mnemonic: be positive and forward looking.)
X.Ip $* 8 2
XSet to 1 to do multiline matching within a string, 0 to assume strings contain
Xa single line.
XDefault is 0.
X(Mnemonic: * matches multiple things.)
X.Ip $0 8
XContains the name of the file containing the
X.I perl
Xscript being executed.
XThe value should be copied elsewhere before any pattern matching happens, which
Xclobbers $0.
X(Mnemonic: same as sh and ksh.)
X.Ip $<digit> 8
XContains the subpattern from the corresponding set of parentheses in the last
Xpattern matched, not counting patterns matched in nested blocks that have
Xbeen exited already.
X(Mnemonic: like \edigit.)
X.Ip $[ 8 2
XThe index of the first element in an array, and of the first character in
Xa substring.
XDefault is 0, but you could set it to 1 to make
X.I perl
Xbehave more like
X.I awk
X(or Fortran)
Xwhen subscripting and when evaluating the index() and substr() functions.
X(Mnemonic: [ begins subscripts.)
X.Ip $! 8 2
XIf used in a numeric context, yields the current value of errno, with all the
Xusual caveats.
XIf used in a string context, yields the corresponding system error string.
XYou can assign to $! in order to set errno
Xif, for instance, you want $! to return the string for error n, or you want
Xto set the exit value for the die operator.
X(Mnemonic: What just went bang?)
X.Ip $@ 8 2
XThe error message from the last eval command.
XIf null, the last eval parsed and executed correctly.
X(Mnemonic: Where was the syntax error "at"?)
X.Ip $< 8 2
XThe real uid of this process.
X(Mnemonic: it's the uid you came FROM, if you're running setuid.)
X.Ip $> 8 2
XThe effective uid of this process.
XExample:
X.nf
X
X	$< = $>;	# set real uid to the effective uid
X
X.fi
X(Mnemonic: it's the uid you went TO, if you're running setuid.)
X.Ip $( 8 2
XThe real gid of this process.
XIf you are on a machine that supports membership in multiple groups
Xsimultaneously, gives a space separated list of groups you are in.
XThe first number is the one returned by getgid(), and the subsequent ones
Xby getgroups(), one of which may be the same as the first number.
X(Mnemonic: parens are used to GROUP things.
XThe real gid is the group you LEFT, if you're running setgid.)
X.Ip $) 8 2
XThe effective gid of this process.
XIf you are on a machine that supports membership in multiple groups
Xsimultaneously, gives a space separated list of groups you are in.
XThe first number is the one returned by getegid(), and the subsequent ones
Xby getgroups(), one of which may be the same as the first number.
X(Mnemonic: parens are used to GROUP things.
XThe effective gid is the group that's RIGHT for you, if you're running setgid.)
X.Sp
XNote: $<, $>, $( and $) can only be set on machines that support the
Xcorresponding set[re][ug]id() routine.
X.Ip @ARGV 8 3
XThe array ARGV contains the command line arguments intended for the script.
XNote that $#ARGV is the generally number of arguments minus one, since
X$ARGV[0] is the first argument, NOT the command name.
XSee $0 for the command name.
X.Ip @INC 8 3
XThe array INC contains the list of places to look for perl scripts to be
Xevaluated by the "do EXPR" command.
XIt initially consists of the arguments to any -I command line switches, followed
Xby the default perl library, probably "/usr/local/lib/perl".
X.Ip $ENV{expr} 8 2
XThe associative array ENV contains your current environment.
XSetting a value in ENV changes the environment for child processes.
X.Ip $SIG{expr} 8 2
XThe associative array SIG is used to set signal handlers for various signals.
XExample:
X.nf
X
X.ne 12
X	sub handler {	# 1st argument is signal name
X		local($sig) = @_;
X		print "Caught a SIG$sig--shutting down\en";
X		close(LOG);
X		exit(0);
X	}
X
X	$SIG{'INT'} = 'handler';
X	$SIG{'QUIT'} = 'handler';
X	.\|.\|.
X	$SIG{'INT'} = 'DEFAULT';	# restore default action
X	$SIG{'QUIT'} = 'IGNORE';	# ignore SIGQUIT
X
X.fi
X.SH ENVIRONMENT
X.I Perl
Xcurrently uses no environment variables, except to make them available
Xto the script being executed, and to child processes.
XHowever, scripts running setuid would do well to execute the following lines
Xbefore doing anything else, just to keep people honest:
X.nf
X
X.ne 3
X    $ENV{'PATH'} = '/bin:/usr/bin';    # or whatever you need
X    $ENV{'SHELL'} = '/bin/sh' if $ENV{'SHELL'};
X    $ENV{'IFS'} = '' if $ENV{'IFS'};
X
X.fi
X.SH AUTHOR
XLarry Wall <lwall@jpl-devvax.Jpl.Nasa.Gov>
X.SH FILES
X/tmp/perl\-eXXXXXX	temporary file for
X.B \-e
Xcommands.
X.SH SEE ALSO
Xa2p	awk to perl translator
X.br
Xs2p	sed to perl translator
X.br
Xperldb	interactive perl debugger
X.SH DIAGNOSTICS
XCompilation errors will tell you the line number of the error, with an
Xindication of the next token or token type that was to be examined.
X(In the case of a script passed to
X.I perl
Xvia
X.B \-e
Xswitches, each
X.B \-e
Xis counted as one line.)
X.SH TRAPS
XAccustomed awk users should take special note of the following:
X.Ip * 4 2
XSemicolons are required after all simple statements in perl.  Newline
Xis not a statement delimiter.
X.Ip * 4 2
XCurly brackets are required on ifs and whiles.
X.Ip * 4 2
XVariables begin with $ or @ in perl.
X.Ip * 4 2
XArrays index from 0 unless you set $[.
XLikewise string positions in substr() and index().
X.Ip * 4 2
XYou have to decide whether your array has numeric or string indices.
X.Ip * 4 2
XAssociative array values do not spring into existence upon mere reference.
X.Ip * 4 2
XYou have to decide whether you want to use string or numeric comparisons.
X.Ip * 4 2
XReading an input line does not split it for you.  You get to split it yourself
Xto an array.
XAnd split has different arguments.
X.Ip * 4 2
XThe current input line is normally in $_, not $0.
XIt generally does not have the newline stripped.
X($0 is initially the name of the program executed, then the last matched
Xstring.)
X.Ip * 4 2
XThe current filename is $ARGV, not $FILENAME.
XNR, RS, ORS, OFS, and OFMT have equivalents with other symbols.
XFS doesn't have an equivalent, since you have to be explicit about
Xsplit statements.
X.Ip * 4 2
X$<digit> does not refer to fields--it refers to substrings matched by the last
Xmatch pattern.
X.Ip * 4 2
XThe print statement does not add field and record separators unless you set
X$, and $\e.
X.Ip * 4 2
XYou must open your files before you print to them.
X.Ip * 4 2
XThe range operator is \*(L"..\*(R", not comma.
X(The comma operator works as in C.)
X.Ip * 4 2
XThe match operator is \*(L"=~\*(R", not \*(L"~\*(R".
X(\*(L"~\*(R" is the one's complement operator.)
X.Ip * 4 2
XThe concatenation operator is \*(L".\*(R", not the null string.
X(Using the null string would render \*(L"/pat/ /pat/\*(R" unparseable,
Xsince the third slash would be interpreted as a division operator\*(--the
Xtokener is in fact slightly context sensitive for operators like /, ?, and <.
XAnd in fact, . itself can be the beginning of a number.)
X.Ip * 4 2
XNext, exit, and continue work differently.
X.Ip * 4 2
XWhen in doubt, run the awk construct through a2p and see what it gives you.
X.PP
XCerebral C programmers should take note of the following:
X.Ip * 4 2
XCurly brackets are required on ifs and whiles.
X.Ip * 4 2
XYou should use \*(L"elsif\*(R" rather than \*(L"else if\*(R"
X.Ip * 4 2
XBreak and continue become last and next, respectively.
X.Ip * 4 2
XThere's no switch statement.
X.Ip * 4 2
XVariables begin with $ or @ in perl.
X.Ip * 4 2
XPrintf does not implement *.
X.Ip * 4 2
XComments begin with #, not /*.
X.Ip * 4 2
XYou can't take the address of anything.
X.Ip * 4 2
XARGV must be capitalized.
X.Ip * 4 2
XThe \*(L"system\*(R" calls link, unlink, rename, etc. return nonzero for success, not 0.
X.Ip * 4 2
XSignal handlers deal with signal names, not numbers.
X.PP
XSeasoned sed programmers should take note of the following:
X.Ip * 4 2
XBackreferences in substitutions use $ rather than \e.
X.Ip * 4 2
XThe pattern matching metacharacters (, ), and | do not have backslashes in front.
X.Ip * 4 2
XThe range operator is .. rather than comma.
X.PP
XSharp shell programmers should take note of the following:
X.Ip * 4 2
XThe backtick operator does variable interpretation without regard to the
Xpresence of single quotes in the command.
X.Ip * 4 2
XThe backtick operator does no translation of the return value, unlike csh.
X.Ip * 4 2
XShells (especially csh) do several levels of substitution on each command line.
XPerl does substitution only in certain constructs such as double quotes,
Xbackticks, angle brackets and search patterns.
X.Ip * 4 2
XShells interpret scripts a little bit at a time.
XPerl compiles the whole program before executing it.
X.Ip * 4 2
XThe arguments are available via @ARGV, not $1, $2, etc.
X.Ip * 4 2
XThe environment is not automatically made available as variables.
X.SH BUGS
X.PP
XYou can't currently dereference arrays or array elements inside a
Xdouble-quoted string.
XYou must assign them to a scalar and interpolate that.
X.PP
XAssociative arrays really ought to be first class objects.
X.PP
XPerl is at the mercy of the C compiler's definitions of various operations
Xsuch as % and atof().
XIn particular, don't trust % on negative numbers.
X.PP
X.I Perl
Xactually stands for Pathologically Eclectic Rubbish Lister, but don't tell
Xanyone I said that.
X.rn }` ''
!STUFFY!FUNK!
echo Extracting stab.h
sed >stab.h <<'!STUFFY!FUNK!' -e 's/X//'
X/* $Header: stab.h,v 2.0 88/06/05 00:11:05 root Exp $
X *
X * $Log:	stab.h,v $
X * Revision 2.0  88/06/05  00:11:05  root
X * Baseline version 2.0.
X * 
X */
X
Xstruct stab {
X    struct stab *stab_next;
X    char	*stab_name;
X    STR		*stab_val;
X    struct stio *stab_io;
X    FCMD	*stab_form;
X    ARRAY	*stab_array;
X    HASH	*stab_hash;
X    SUBR	*stab_sub;
X    char	stab_flags;
X};
X
X#define SF_VMAGIC 1		/* call routine to dereference STR val */
X#define SF_MULTI 2		/* seen more than once */
X
Xstruct stio {
X    FILE	*fp;
X    long	lines;
X    long	page;
X    long	page_len;
X    long	lines_left;
X    char	*top_name;
X    STAB	*top_stab;
X    char	*fmt_name;
X    STAB	*fmt_stab;
X    short	subprocess;
X    char	type;
X    char	flags;
X};
X
X#define IOF_ARGV 1	/* this fp iterates over ARGV */
X#define IOF_START 2	/* check for null ARGV and substitute '-' */
X#define IOF_FLUSH 4	/* this fp wants a flush after write op */
X
Xstruct sub {
X    CMD		*cmd;
X    char	*filename;
X    long	depth;	/* >= 2 indicates recursive call */
X    ARRAY	*tosave;
X};
X
X#define Nullstab Null(STAB*)
X
X#define STAB_STR(s) (tmpstab = (s), tmpstab->stab_flags & SF_VMAGIC ? stab_str(tmpstab) : tmpstab->stab_val)
X#define STAB_GET(s) (tmpstab = (s), str_get(tmpstab->stab_flags & SF_VMAGIC ? stab_str(tmpstab) : tmpstab->stab_val))
X#define STAB_GNUM(s) (tmpstab = (s), str_gnum(tmpstab->stab_flags & SF_VMAGIC ? stab_str(tmpstab) : tmpstab->stab_val))
X
XEXT STAB *tmpstab;
X
XEXT STAB *stab_index[128];
X
XEXT char *envname;	/* place for ENV name being assigned--gross cheat */
XEXT char *signame;	/* place for SIG name being assigned--gross cheat */
X
XEXT unsigned short statusvalue;
X
XSTAB *aadd();
XSTAB *hadd();
!STUFFY!FUNK!
echo ""
echo "End of kit 3 (of 15)"
cat /dev/null >kit3isdone
run=''
config=''
for iskit in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
    if test -f kit${iskit}isdone; then
	run="$run $iskit"
    else
	todo="$todo $iskit"
    fi
done
case $todo in
    '')
	echo "You have run all your kits.  Please read README and then type Configure."
	chmod 755 Configure
	;;
    *)  echo "You have run$run."
	echo "You still need to run$todo."
	;;
esac
: Someone might mail this, so...
exit

