Subject:  v15i068:  Graphics benchmark toolkit for X, Part01/02
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Craig Dunwoody <dunwoody@lurch.stanford.edu>
Posting-number: Volume 15, Issue 68
Archive-name: gbench/part01

Gbench is a graphics benchmark tool.  It currently supports 2D
immediate-mode graphics and runs on top of the X Window System (both
Version 10 and Version 11) and Unix.  It is written in C and it directly
calls the low-level window system client library; no toolkit is used.  It
is being developed by Craig Dunwoody and Mark Linton at Stanford
University's Computer Systems Lab under the Quantum project, through a
gift from Digital Equipment Corporation.  It may be freely distributed
under the conditions listed in the accompanying copyright notice.

Gbench is not a graphics benchmark.  Rather, it is a tool that lets you
construct and run your own benchmarks.  When gbench starts up, it creates
an X window and reads commands from standard input, one per line.  Each
command directs gbench to repeatedly perform a particular drawing
operation.  Gbench copies the command line to standard output, executes
the command, and prints on standard output the host load average, the time
for each iteration, and the number of iterations per second.  All times
are measured in real (wall-clock) time.


Thanks a lot,
Craig Dunwoody
Internet:   dunwoody@lurch.stanford.edu
USEnet:     {ucbvax,decvax}!decwrl!lurch.stanford.edu!dunwoody
Phone:      (415) 725-3733

--------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  COPYRIGHT Makefile-dist README cmds.c exec.c gbench.h
#   main.c utils.c
# Wrapped by rsalz@fig.bbn.com on Mon Jun 13 15:32:46 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'COPYRIGHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COPYRIGHT'\"
else
echo shar: Extracting \"'COPYRIGHT'\" \(702 characters\)
sed "s/^X//" >'COPYRIGHT' <<'END_OF_FILE'
XCopyright (c) 1988 by The Board of Trustees
Xof the Leland Stanford Junior University.
X
XPermission to use, copy, modify, and distribute this
Xsoftware and its documentation for any purpose and without
Xfee is hereby granted, provided that the above copyright
Xnotice appear in all copies and that both that copyright
Xnotice and this permission notice appear in supporting
Xdocumentation, and that the name of Stanford not be used in
Xadvertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.
X
XStanford makes no representations about the suitability of
Xthis software for any purpose.  The Software is provided "as is"
Xwithout express or implied warranty.
END_OF_FILE
if test 702 -ne `wc -c <'COPYRIGHT'`; then
    echo shar: \"'COPYRIGHT'\" unpacked with wrong size!
fi
# end of 'COPYRIGHT'
fi
if test -f 'Makefile-dist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile-dist'\"
else
echo shar: Extracting \"'Makefile-dist'\" \(407 characters\)
sed "s/^X//" >'Makefile-dist' <<'END_OF_FILE'
X.SILENT:
X
XMACHINE = VAX
XXVERSION= X11
X
X# for gprof profiling, put -DGPROF in CFLAGS and -pg in LDFLAGS
X
XCC	= cc
XCFLAGS 	= -O -I. -D${MACHINE} -D${XVERSION}
XLD	= cc
XLDFLAGS	=
XLIBS	= -l${XVERSION} -lm
XOBJS	= cmds.o exec.o main.o ops.o utils.o
XPROG	= gbench
X
X.c.o:
X	echo compiling $*.c
X	${CC} ${CFLAGS} -c $*.c
X
X${PROG}: ${OBJS}
X	echo linking ${PROG}
X	${LD} ${LDFLAGS} -o $@ ${OBJS} ${LIBS}
X
X${OBJS}: gbench.h
END_OF_FILE
if test 407 -ne `wc -c <'Makefile-dist'`; then
    echo shar: \"'Makefile-dist'\" unpacked with wrong size!
fi
# end of 'Makefile-dist'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(4386 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
Xgbench Version 1.0
X
XGbench is a graphics benchmark tool.  It currently supports 2D immediate-mode
Xgraphics and runs on top of the X Window System (both Version 10 and Version
X11) and Unix.  It is written in C and it directly calls the low-level window
Xsystem client library; no toolkit is used.  It is being developed by Craig
XDunwoody and Mark Linton at Stanford University's Computer Systems Lab under
Xthe Quantum project, through a gift from Digital Equipment Corporation.  It may
Xbe freely distributed under the conditions listed in the accompanying copyright
Xnotice.
X
XGbench is not a graphics benchmark.  Rather, it is a tool that lets you
Xconstruct and run your own benchmarks.  When gbench starts up, it creates an X
Xwindow and reads commands from standard input, one per line.  Each command
Xdirects gbench to repeatedly perform a particular drawing operation.  Gbench
Xcopies the command line to standard output, executes the command, and prints on
Xstandard output the host load average, the time for each iteration, and the
Xnumber of iterations per second.  All times are measured in real (wall-clock)
Xtime.
X
XYou can use gbench either interactively, by typing commands and viewing
Xthe results immediately, or in batch mode, with standard input redirected
Xto a script file and output redirected to a log file.  If you don't want to
Xcreate your own script file, there is a built-in default script.
X
XGbench is primarily intended as a benchmarking tool.  You may also find it
Xuseful as a graphics system exerciser.  If you are developing an application
Xprogram, and some graphics operation isn't behaving properly, you may be able
Xto use gbench to find out if the underlying graphics system implementation is
Xdoing the right thing.  Gbench is NOT, however, intended as a graphics system
Xverification tool.  It allows you to exercise most of the drawing functions
Xsupported by the graphics server, but for any given function, the only
Xparameters that gbench lets you vary are those (such as size) that we
Xconsider to be likely to affect performance.
X
XIn the future, we hope to extend gbench and provide tools for combining and
Xformatting raw log files.  Proposed extensions include 3D graphics and
Xintegration with a more comprehensive set of workstation benchmarks.  If there
Xis interest, we are willing to act as a clearinghouse for benchmark scripts and
Xresults.
X
XVersion 1.0 of gbench represents our first attempt to address the problem of
Xcharacterizing graphics performance in a distributed environment.  There are
Xmany complex issues in this area that remain unresolved, and we expect that we
Xwill be able to substantially improve gbench as we learn more.  By making
Xgbench widely available, we hope to hasten the process of making it as
Xportable, bug-free, complete, and fair as possible.
X
XSpeaking of bugs, there is apparently a bug in the beta release of the
Xawm window manager for X11R2 that causes the "map" command to hang
X\fIgbench\fP.  For this reason, we have removed "map" from the default
Xscript.  We have not found this problem under any of the other X11R2
Xwindow managers, including the standard uwm.
X
XWe would be most pleased to receive any comments, bugfixes, scripts, or results
Xthat you might have.  Our address is:
X
XInternet:  gbench@lurch.stanford.edu
XUSEnet:    {ucbvax,decvax}!decwrl!lurch.stanford.edu!gbench
X
XGbench source code is available in compressed and uncompressed shar and tar
Xformats through anonymous FTP to lurch.stanford.edu (36.22.0.14).
X
XTo build gbench:
X
X1.  Copy Makefile-dist to Makefile.
X
X2.  In Makefile, set MACHINE to your machine type.  Gbench has been tested
X    with X10 and X11 on machine types VAX, SUN3, and SUN4.  The code should
X    be quite portable.  The difference between the VAX and SUN versions
X    is in the definition of GetLoad() in utils.c.  When there is a more
X    reasonable way to get the load (suggestions are welcome), this problem
X    will go away.
X
X3.  In Makefile, set XVERSION to X10 or X11 as appropriate.
X
X4.  In Makefile, add the indicated flags to CFLAGS and LDFLAGS if you want
X    to do gprof profiling.
X
X5.  If your X header files are not in /usr/include/${XVERSION},
X    create the  symbolic link "X10" or "X11", pointing to the appropriate
X    X header file directory, in the main gbench directory.
X
X6.  Make sure that lib${XVERSION}.a exists in your standard library
X    directory.
X
X7.  "make"
END_OF_FILE
if test 4386 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'cmds.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cmds.c'\"
else
echo shar: Extracting \"'cmds.c'\" \(7415 characters\)
sed "s/^X//" >'cmds.c' <<'END_OF_FILE'
X#include <gbench.h>
X
XResult ParseOpts(os,sfp,ofp)
X    char*	os;
X    OptFlags*	sfp;
X    OptFlags*	ofp;
X{
X    int		i;
X    char	ps[MaxStr];
X    bool*	ofa = (bool*)ofp;
X    char*	osp = os;
X    Result	result = Succeeded;
X    bool*	sfa = (bool*)sfp;
X    char*	t;
X    TokenState	ts;
X
X    for (i=0;i<(sizeof(OptFlags)/sizeof(bool));i++) ofa[i] = false;
X    strcpy(ps,osp);
X    *osp = '\0';
X    if (t=StrToken(ps,",",&ts)) do {
X	i = -1;
X	if (!strcmp(t,"ac")) i = &ofp->altcolor-ofa;
X	else if (!strcmp(t,"af")) i = &ofp->altfont-ofa;
X	else if (!strcmp(t,"ag")) i = &ofp->altgc-ofa;
X	else if (!strcmp(t,"aw")) i = &ofp->altwin-ofa;
X	else if (!strcmp(t,"d")) i = &ofp->drag-ofa;
X	else if (!strcmp(t,"f")) i = &ofp->fill-ofa;
X	else if (!strcmp(t,"i")) i = &ofp->invert-ofa;
X	else if (!strcmp(t,"m")) i = &ofp->profile-ofa;
X	else if (!strcmp(t,"o")) i = &ofp->overlap-ofa;
X	else if (!strcmp(t,"os")) i = &ofp->offsrc-ofa;
X	else if (!strcmp(t,"od")) i = &ofp->offdest-ofa;
X	else if (!strcmp(t,"p")) i = &ofp->poll-ofa;
X	else if (!strcmp(t,"ps")) i = &ofp->polyself-ofa;
X	else if (!strcmp(t,"pw")) i = &ofp->polywind-ofa;
X	else if (!strcmp(t,"r")) i = &ofp->setdefaults-ofa;
X	else if (!strcmp(t,"s")) i = &ofp->stipple-ofa;
X	else if (!strcmp(t,"t")) i = &ofp->tile-ofa;
X	else if (!strcmp(t,"u")) i = &ofp->unbatched-ofa;
X	if ((i>=0)&&!ofa[i]) {
X	    if (!sfa[i]) result = OptNotSupported;
X	    ofa[i] = true;
X	    sprintf(osp,"%s,",t);
X	    osp += strlen(osp);
X	}
X    } while (t=StrToken(nil,",",&ts));
X    if (osp>os) *--osp = '\0';
X    return result;
X}
X
Xchar* GetToken(sp,first)
X    State*  sp;
X    bool    first;
X{
X    if (!sp->strinput) {
X	if (first) {
X	    while((sp->argindex<sp->argc)&&(*sp->argv[sp->argindex]!='-')) {
X		sp->argindex++;
X	    }
X	    if (sp->argindex>=sp->argc) return nil;
X	    else return sp->argv[sp->argindex++];
X	}
X	else {
X	    if (*sp->argv[sp->argindex]=='-') return nil;
X	    else return sp->argv[sp->argindex++];
X	}
X    }
X    else return StrToken(first?sp->instr:nil," ",&sp->ts);
X}
X
Xint ScanInt(s,min,max)
X    char*   s;
X    int	    min;
X    int	    max;
X{
X    int i;
X
X    sscanf(s,"%d",&i);
X    return i = Limit(i,min,max);
X}
X
Xvoid SetParam(sp,pp,n,v,concat)
X    State*  sp;
X    Params* pp;
X    char*   n;
X    char*   v;
X    bool    concat;
X{
X    if (!strcmp(n,"angle")) pp->angle = ScanInt(v,0,360);
X    else if (!strcmp(n,"aspect")) {
X	sscanf(v,"%f",&pp->aspect);
X	if (pp->aspect<MinAspect) pp->aspect = MinAspect;
X    }
X    else if (!strcmp(n,"count")) pp->count = ScanInt(v,0,MaxNum);
X    else if (!strcmp(n,"fonts")) strcpy(pp->fonts,v);
X    else if (!strcmp(n,"lwidth")) pp->lwidth = ScanInt(v,0,_DisplayWidth);
X    else if (!strcmp(n,"maxshift")) pp->maxshift = ScanInt(v,0,_DisplayWidth);
X    else if (!strcmp(n,"nchar")) pp->nchar = ScanInt(v,0,MaxStr);
X    else if (!strcmp(n,"nvert")) pp->nvert = ScanInt(v,3,MaxVert);
X    else if (!strcmp(n,"nwin")) pp->nwin = ScanInt(v,0,MaxNum);
X    else if (!strcmp(n,"offset")) sscanf(v,"%f",&pp->offset);
X    else if (!strcmp(n,"opts")) {
X	if (concat) {
X	    if (strlen(pp->opts)&&strlen(v)) strcat(pp->opts,",");
X	    strcat(pp->opts,v);
X	}
X	else strcpy(pp->opts,v);
X    }
X    else if (!strcmp(n,"outfile")) strcpy(pp->outfile,v);
X    else if (!strcmp(n,"ptsize")) pp->ptsize = ScanInt(v,0,_DisplayHeight);
X    else if (!strcmp(n,"size")) pp->size = ScanInt(v,0,_DisplayWidth);
X    else if (!strcmp(n,"tag")) strcpy(pp->tag,v);
X    else if (!strcmp(n,"timegoal")) pp->timegoal = ScanInt(v,0,MaxNum);
X    else if (!strcmp(n,"winsize")) pp->winsize = ScanInt(v,1,_DisplayHeight);
X}
X
Xvoid ParseParams(sp,cp,pp,print)
X    State*	sp;
X    Cmd*	cp;
X    Params*	pp;
X    bool	print;
X{
X    int	    i;
X    char*   t = nil;
X    char*   v;
X
X    if (cp->index!=NilIndex) {
X	for (
X	    i=0;
X	    (i<MaxPositional)&&OpNames[(int)cp->index][1+i]&&
X		(t=GetToken(sp,false))&&!strchr(t,'=');
X	    i++
X	) {
X	    SetParam(sp,pp,OpNames[(int)cp->index][1+i],t,true);
X	}
X    }
X    do if (t&&(v=strchr(t,'='))) {
X	*v++ = '\0';
X	SetParam(sp,pp,t,v,false);
X	if (print) PrintParam(Out(sp,cp),pp,"  ",t,"");
X	*--v = '=';
X    } while (t=GetToken(sp,false));
X    if (print) {
X	putc('\n',Out(sp,cp));
X	fflush(Out(sp,cp));
X    }
X    if (strcmp(sp->fonts,pp->fonts)) SetFonts(sp,pp);
X    if (strcmp(sp->outfile,pp->outfile)) SetOutfile(sp,pp);
X    if (sp->winsize!=pp->winsize) SetWinsize(sp,pp);
X    if (ParseOpts(pp->opts,&sp->supopts,&cp->o)!=Succeeded) {
X	cp->result = OptNotSupported;
X    }
X}
X
Xvoid ParseCmd(sp,cp)
X    State*  sp;
X    Cmd*    cp;
X{
X    cp->result = sp->supcmds[(int)cp->index]?Succeeded:CmdNotSupported;
X    ParseParams(sp,cp,&cp->p,false);
X    cp->func = cp->o.invert?GXinvert:GXcopy;
X    sp->previndex = cp->index;
X    CopyParams(&sp->prevparams,&cp->p);
X    if (cp->o.setdefaults) CopyParams(&sp->defaults,&cp->p);
X}
X
Xvoid PushInput(sp,fn)
X    State*  sp;
X    char*   fn;
X{
X    if ((sp->indepth<MaxIndepth)&&!(sp->infds[++sp->indepth]=fopen(fn,"r"))) {
X	sp->indepth--;
X    }
X}
X
Xbool PopInput(sp)
X    State*  sp;
X{
X    bool nonempty = (bool)(sp->indepth>0);
X
X    if (nonempty) sp->indepth--;
X    return nonempty;
X}
X
Xvoid PrintComment(sp,cp,t)
X    State*  sp; 
X    Cmd*    cp;
X    char*   t;
X{
X    char* te;
X
X    if (sp->strinput) {
X	te = t+strlen(t);
X 	if (te<sp->ts.end) *te = ' ';
X	fprintf(Out(sp,cp),"%s\n",t);
X    }
X    else {
X	do fprintf(Out(sp,cp),"%s ",t); while (t=GetToken(sp,false));
X	putc('\n',Out(sp,cp));
X    }
X}
X
Xbool GetLine(sp)
X    State*  sp;
X{
X    char* cp;
X
X    if (sp->scriptindex>=0) {
X	strcpy(sp->instr,Script[sp->scriptindex]);
X	if (!Script[++sp->scriptindex]) sp->scriptindex = -1;
X	sp->strinput = true;
X    }
X    else if (sp->argindex>=sp->argc) {
X	while (!fgets(sp->instr,MaxStr,sp->infds[sp->indepth])) {
X	    if (!PopInput(sp)) return false;
X	}
X	if (cp=strchr(sp->instr,'\n')) *cp='\0';
X	sp->strinput = true;
X    }
X    else sp->strinput = false;
X    return true;
X}
X
Xbool GetCmd(sp,cp)
X    State*  sp;
X    Cmd*    cp;
X{
X    char*   t;
X    int     tlen;
X
X    while (true) {
X	cp->index = NilIndex;
X	if (!GetLine(sp)) return false;
X	if (t=GetToken(sp,true)) {
X	    if (*t=='-') t++;
X	    if (*t=='@') {
X		t++;
X		cp->o.silent = true;
X	    }
X	    else cp->o.silent = false;
X	    tlen = strlen(t);
X	    if (!strncmp(t,"config",tlen)) {
X		fprintf(Out(sp,cp),"config\n");
X		PrintConfig(Out(sp,cp),sp);
X		putc('\n',Out(sp,cp));
X	    }
X	    else if (!strncmp(t,"defaults",tlen)) {
X		fprintf(Out(sp,cp),"defaults");
X		ParseParams(sp,cp,&sp->defaults,true);
X		PrintParams(stderr,sp,&sp->defaults);
X		putc('\n',stderr);
X	    }
X	    else if (!strncmp(t,"help",tlen)) {
X		PrintHelp(Out(sp,cp));
X		putc('\n',stderr);
X	    }
X	    else if (!strncmp(t,"init",tlen)) {
X		fprintf(Out(sp,cp),"init\n");
X		InitParams(sp,&sp->defaults);
X		PrintParams(stderr,sp,&sp->defaults);
X		putc('\n',stderr);
X	    }
X	    else if (!strncmp(t,"quit",tlen)) {
X		return false;
X	    }
X	    else if (!strncmp(t,"script",tlen)) {
X		fprintf(Out(sp,cp),"script");
X		if (t=GetToken(sp,false)) fprintf(Out(sp,cp)," %s",t);
X		putc('\n',Out(sp,cp));
X		if (t) PushInput(sp,t);
X		else sp->scriptindex = 0;
X	    }
X	    else if (*t=='#') {
X		PrintComment(sp,cp,t);
X	    }
X	    else if ((*t=='!')&&((cp->index=sp->previndex)!=NilIndex)) {
X		CopyParams(&cp->p,&sp->prevparams);
X		ParseCmd(sp,cp);
X		return true;
X	    }
X	    else if ((cp->index=GetOpIndex(t))!=NilIndex) {
X		CopyParams(&cp->p,&sp->defaults);
X		ParseCmd(sp,cp);
X		return true;
X	    }
X	}
X	else putchar('\n');
X    }
X}
END_OF_FILE
if test 7415 -ne `wc -c <'cmds.c'`; then
    echo shar: \"'cmds.c'\" unpacked with wrong size!
fi
# end of 'cmds.c'
fi
if test -f 'exec.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'exec.c'\"
else
echo shar: Extracting \"'exec.c'\" \(6770 characters\)
sed "s/^X//" >'exec.c' <<'END_OF_FILE'
X#include <gbench.h>
X
Xvoid Start(sp,cp)
X    State*  sp;
X    Cmd*    cp;
X{
X    int i;
X    int	style;
X
X    cp->colorfg = _WhitePixel;
X    cp->colorbg = _BlackPixel;
X    if (cp->p.maxshift>0) cp->dx = cp->dy = 1;
X    else cp->dx = cp->dy = 0;
X    cp->gc = sp->gc1;
X    cp->shift = 0;
X    cp->w = sp->w1;
X    sp->dest1 = sp->w1;
X    sp->src1 = sp->w1;
X#   ifdef X11
X	if (cp->o.offdest||cp->o.offsrc) {
X	    if (!sp->offpix) {
X		cp->o.offdest = cp->o.offsrc = false;
X		cp->result = NoOffscreenMem;
X	    }
X	    else {
X		if (cp->o.offdest) sp->dest1 = sp->offpix;
X		if (cp->o.offsrc) sp->src1 = sp->offpix;
X		XFillRectangle(
X		    sp->d,sp->offpix,DefaultGC(sp->d,DefaultScreen(sp->d)),0,0,
X		    sp->winsize,sp->winsize
X		);
X	    }
X	}
X#   endif X11
X    cp->dest = sp->dest1;
X    cp->src = sp->src1;
X    fprintf(Out(sp,cp),"%s",OpNames[(int)cp->index][0]);
X    for (i=0;(i<MaxPositional)&&OpNames[(int)cp->index][1+i];i++) {
X	PrintParam(Out(sp,cp),&cp->p,"  ",OpNames[(int)cp->index][1+i],"");
X    }
X    PrintParam(Out(sp,cp),&cp->p,"  ","count","\n");
X    fflush(Out(sp,cp));
X    if (cp->o.altwin&&!sp->altwin) {
X	MapWin(sp,sp->w2);
X	sp->altwin = true;
X    }
X    else if (sp->altwin&&!cp->o.altwin) {
X	UnmapWin(sp,sp->w2);
X	sp->altwin = false;
X    }
X    if (cp->o.overlap) {
X	XMapWindow(DARGC sp->cw1);
X	if (cp->o.altwin) XMapWindow(DARGC sp->cw2);
X    }
X    XClearWindow(DARGC sp->w1);
X    XClearWindow(DARGC sp->w2);
X    XRaiseWindow(DARGC sp->w1);
X    if (cp->o.altwin) XRaiseWindow(DARGC sp->w2);
X    XSelectInput(DARGC sp->w1,InputMask(cp));
X    if (cp->o.altwin) XSelectInput(DARGC sp->w2,InputMask(cp));
X#   ifdef X11
X	XSetBackground(sp->d,sp->gc1,cp->colorbg);
X	XSetForeground(sp->d,sp->gc1,cp->colorfg);
X	XSetFunction(sp->d,sp->gc1,cp->func);
X	XSetFunction(sp->d,sp->gc2,cp->func);
X	if (cp->o.stipple&&cp->o.tile) style = FillOpaqueStippled;
X	else if (cp->o.stipple) style = FillStippled;
X	else if (cp->o.tile) style = FillTiled;
X	else style = FillSolid;
X	XSetFillStyle(sp->d,sp->gc1,style);
X	XSetFillStyle(sp->d,sp->gc2,style);
X	if (cp->o.stipple) style = LineOnOffDash;
X	else if (cp->o.tile) style = LineDoubleDash;
X	else style = LineSolid;
X	XSetLineAttributes(sp->d,sp->gc1,cp->p.lwidth,style,CapButt,JoinMiter);
X	XSetLineAttributes(sp->d,sp->gc2,cp->p.lwidth,style,CapButt,JoinMiter);
X#   endif X11
X    XSync(DARGC 1);
X    if (cp->o.profile) ProfControl(1);
X}
X
Xvoid StartIteration(sp,cp)
X    State*  sp;
X    Cmd*    cp;
X{
X    Pixel colortemp;
X
X    if (!cp->o.drag) {
X	cp->shift += cp->dx;
X	if ((cp->shift<0)||(cp->shift>cp->p.maxshift)) {
X	    cp->dx = -cp->dx;
X	    cp->dy = -cp->dy;
X	    cp->shift += 2*cp->dx;
X	}
X	cp->x += cp->dx;
X	cp->y += cp->dy;
X    }
X    if (cp->o.altcolor) {
X	colortemp = cp->colorbg;
X	cp->colorbg = cp->colorfg;
X	cp->colorfg = colortemp;
X#	ifdef X11
X	    XSetBackground(sp->d,sp->gc1,cp->colorbg);
X	    XSetForeground(sp->d,sp->gc1,cp->colorfg);
X#	endif X11
X    }
X    if ((cp->o.altgc)&&(cp->gc==sp->gc1)) cp->gc = sp->gc2;
X    else cp->gc = sp->gc1;
X    if ((cp->o.altwin)&&(cp->w==sp->w1)) {
X	cp->dest = sp->dest2;
X	cp->src = sp->src2;
X	cp->w = sp->w2;
X    }
X    else {
X	cp->dest = sp->dest1;
X	cp->src = sp->src1;
X	cp->w = sp->w1;
X    }
X    if (cp->o.unbatched) XFlush(DARG);
X}
X
Xvoid Erase(sp,cp)
X    State*  sp;
X    Cmd*    cp;
X{
X    int x = cp->x;
X    int y = cp->y;
X    int bbx = cp->bbx;
X    int bby = cp->bby;
X
X    if (cp->bbx<0) {
X	x += cp->bbx;
X	bbx = -bbx;
X    }
X    if (cp->bby<0) {
X	y += cp->bby;
X	bby = -bby;
X    }
X#   ifdef X10
X	XPixFill(cp->w,x,y,bbx,bby,_BlackPixel,0,GXcopy,AllPlanes);
X#   else
X	XFillRectangle(
X	    sp->d,cp->dest,DefaultGC(sp->d,DefaultScreen(sp->d)),x,y,bbx,bby
X	);
X#   endif
X}
X
Xvoid Finish(sp,cp)
X    State*  sp;
X    Cmd*    cp;
X{
X    int	    i;
X
X    if (cp->o.profile) ProfControl(0);
X    if (cp->o.overlap) {
X	XUnmapWindow(DARGC sp->cw1);
X	if (cp->o.altwin) XUnmapWindow(DARGC sp->cw2);
X    }
X#   ifdef X11
X	if (cp->o.offdest) {
X	    XCopyArea(
X		sp->d,sp->offpix,sp->w1,sp->gc1,0,0,sp->winsize,sp->winsize,0,0
X	    );
X	}
X#   endif X11
X    XSync(DARGC 0);
X    fprintf(Out(sp,cp),"# ");
X    if (cp->result!=Succeeded) {
X	fprintf(Out(sp,cp),"result=%s",ResultMsgs[(int)cp->result]);
X    }
X    else {
X	fprintf(
X	    Out(sp,cp),"hload=%.1f  time=%.3fmsec  rate=%.1f/sec",GetLoad(),
X	    cp->time*1000/cp->iterations,cp->iterations/cp->time
X	);
X    }
X    if (strlen(cp->p.tag)) fprintf(Out(sp,cp),"  tag=%s  ",cp->p.tag);
X    putc('\n',Out(sp,cp));
X    putc('\n',stderr);
X    fflush(Out(sp,cp));
X    fflush(stderr);
X    if (strcmp(sp->fonts,sp->defaults.fonts)) SetFonts(sp,&sp->defaults);
X    if (strcmp(sp->outfile,sp->defaults.outfile)) SetOutfile(sp,&sp->defaults);
X    if (sp->winsize!=sp->defaults.winsize) SetWinsize(sp,&sp->defaults);
X}
X
Xvoid ExecDrag(sp,cp)
X    State*  sp;
X    Cmd*    cp;
X{
X    XEvent	    e;
X    int		    i;
X    XMotionEvent*   mep;
X    double	    t1;
X    Window	    qw;
X
X#   ifdef X10
X	mep = (XMotionEvent*)&e;
X#   else
X	mep = &e.xmotion;
X#   endif
X    cp->iterations = 0;
X    cp->o.altwin = false;
X    XClearWindow(DARGC sp->w1);
X    (*Ops[(int)cp->index][(int)StartOp])(sp,cp);
X    Help(
X	stderr,
X	"    Drag test: move cursor in window while pressing a mouse button"
X    );
X    fflush(stderr);
X    XDefineCursor(DARGC cp->w,sp->cursor);
X    do XNextEvent(DARGC &e); while (e.type!=ButtonPress);
X    t1 = GetTime(sp);
X    while (e.type!=ButtonRelease) {
X	XSync(DARGC false);
X	if (cp->o.poll) {
X	    if (!XCheckMaskEvent(DARGC ButtonReleaseMask,&e)) {
X		e.type = MotionNotify;
X#		ifdef X10
X		    XQueryMouse(cp->w,&mep->x,&mep->y,&qw);
X#		else
X		    XQueryPointer(
X			sp->d,cp->w,&qw,&qw,&i,&i,&mep->x,&mep->y,&i
X		    );
X#		endif
X	    }
X	}
X	else do {
X	    XNextEvent(DARGC &e);
X	} while (QLength(DARG) && (e.type==MotionNotify));
X	(*Ops[(int)cp->index][(int)EraseOp])(sp,cp);
X	cp->dx = mep->x-cp->x;
X	cp->dy = mep->y-cp->y;
X	cp->x = mep->x;
X	cp->y = mep->y;
X	(*Ops[(int)cp->index][(int)DoOp])(sp,cp);
X	cp->iterations++;
X    }
X    cp->time = GetTime(sp)-t1;
X    XUndefineCursor(DARGC cp->w);
X    (*Ops[(int)cp->index][(int)FinishOp])(sp,cp);
X    XFlush(DARG);
X}
X
Xvoid ExecOp(sp,cp)
X    State*  sp;
X    Cmd*    cp;
X{
X    
X    bool    done;
X    int	    i;
X    double  t1;
X
X    (*Ops[(int)cp->index][(int)StartOp])(sp,cp);
X    cp->iterations = 1;
X    done = (bool)(cp->result!=Succeeded);
X    while (!done) {
X	t1 = GetTime(sp);
X	for (i=0;i<cp->iterations;i++) {
X	    (*Ops[(int)cp->index][(int)DoOp])(sp,cp);
X	}
X	cp->time = GetTime(sp)-t1;
X	if (((int)cp->time)>=cp->p.timegoal) done = true;
X	else {
X	    cp->iterations =
X		(int)(cp->iterations*cp->p.timegoal/(cp->time+.0001))+1;
X	}
X    }
X    (*Ops[(int)cp->index][(int)FinishOp])(sp,cp);
X}
X
Xvoid ExecCmds(sp)
X    State* sp;
X{
X    Cmd	c;
X
X    while (GetCmd(sp,&c)) {
X	if (c.o.drag) ExecDrag(sp,&c);
X	else ExecOp(sp,&c);
X    }
X}
END_OF_FILE
if test 6770 -ne `wc -c <'exec.c'`; then
    echo shar: \"'exec.c'\" unpacked with wrong size!
fi
# end of 'exec.c'
fi
if test -f 'gbench.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gbench.h'\"
else
echo shar: Extracting \"'gbench.h'\" \(5690 characters\)
sed "s/^X//" >'gbench.h' <<'END_OF_FILE'
X#include <ctype.h>
X#include <nlist.h>
X#include <math.h>
X#include <stdio.h>
X#include <string.h>
X#include <sys/time.h>
X
X#ifdef SUN3
X#define FIXLOAD
X#endif
X#ifdef SUN4
X#define FIXLOAD
X#endif
X
X#ifdef X10
X#   include <X10/Xlib.h>
X#   define _BlackPixel		BlackPixel
X#   define ButtonPress		ButtonPressed
X#   define ButtonPressMask	ButtonPressed
X#   define ButtonRelease	ButtonReleased
X#   define ButtonReleaseMask	ButtonReleased
X#   define DARG
X#   define DARGC
X#   define DefaultFonts		"4x6,6x10,6x13,9x15,ice34"
X#   define _DisplayHeight	DisplayHeight()
X#   define _DisplayWidth	DisplayWidth()
X#   define Drawable		Window
X#   define ExposeRegionMask	ExposeRegion
X#   define ExposureMask		ExposeCopy
X#   define GC			int
X#   define MotionNotify		MouseMoved
X#   define PointerMotionMask	MouseMoved
X#   define _RootWindow		RootWindow
X#   define _WhitePixel		WhitePixel
X#   define XClearWindow		XClear
X#   define XCreateSimpleWindow	XCreateWindow
X#   define XFontStruct		FontInfo
X#   define XFreeFont		XCloseFont
X#   define XGraphicsExposeEvent	XExposeEvent
X#   define XPoint		Vertex
X#   define XTextItem		char
X#   define XMotionEvent		XMouseMovedEvent
X#else
X#   include <X11/Xlib.h>
X#   include <X11/X.h>
X#   include <X11/Xutil.h>
X#   include <X11/cursorfont.h>
X#   define _BlackPixel		BlackPixel(sp->d,DefaultScreen(sp->d))
X#   define BlackPixmap		_BlackPixel
X#   define DARG			sp->d
X#   define DARGC		DARG,
X#   define DefaultFonts		"vg-??"
X#   define _DisplayHeight	DisplayHeight(sp->d,DefaultScreen(sp->d))
X#   define _DisplayWidth	DisplayWidth(sp->d,DefaultScreen(sp->d))
X#   define ExposeRegionMask	0
X#   define Pattern		int
X#   define _RootWindow		DefaultRootWindow(sp->d)
X#   define _WhitePixel		WhitePixel(sp->d,DefaultScreen(sp->d))
X#   define WhitePixmap		_WhitePixel
X#endif
X
X#define Border		10
X#define DefaultAngle	350
X#define DefaultAspect	1.
X#define DefaultLwidth   1
X#define DefaultMaxshift	32
X#define DefaultNchar	10
X#define DefaultNvert	4
X#define DefaultNwin	10
X#define DefaultOffset	.5
X#define DefaultPtsize	12
X#define DefaultSize	100
X#define DefaultTimegoal	1
X#define DefaultWinsize  _DisplayWidth/2
X#define MaxIndepth	10
X#define MaxNum		1000000
X#define MaxPositional	5
X#define MaxStr		120
X#define MaxVert		31
X#define MaxFonts	16
X#define MinAspect	.1
X#define nil		0
X#define NumOps		9
X#define OverlapSize	2
X#define Pi		3.141592654
X#define PolyAngle	Pi/18
X#define Version         1.0
X
X#define Sign(x) ((x)>=0?1:-1)
X
Xtypedef enum {false,true} bool;
X
Xtypedef double Load;
X
Xtypedef void (*Op)();
X
Xtypedef enum {
X    NilIndex = -1,
X    ArcIndex,
X    BlitIndex,
X    MapIndex,
X    NopIndex,
X    PointIndex,
X    PolyIndex,
X    RectIndex,
X    TextIndex,
X    VecIndex
X} OpIndex;
X
Xtypedef enum {StartOp,DoOp,EraseOp,FinishOp} OpType;
X
Xtypedef struct {
X    bool    altcolor;
X    bool    altfont;
X    bool    altgc;
X    bool    altwin;
X    bool    drag;
X    bool    fill;
X    bool    invert;
X    bool    offdest;
X    bool    offsrc;
X    bool    overlap;
X    bool    poll;
X    bool    polyself;
X    bool    polywind;
X    bool    profile;
X    bool    setdefaults;
X    bool    silent;
X    bool    stipple;
X    bool    tile;
X    bool    unbatched;
X} OptFlags;
X
Xtypedef struct {
X    int	    angle;
X    float   aspect;
X    int	    count;
X    char    fonts[MaxStr];
X    int	    ptsize;
X    int	    lwidth;
X    int	    maxshift;
X    float   offset;
X    int	    nchar;
X    int	    nwin;
X    int	    nvert;
X    char    opts[MaxStr];
X    char    outfile[MaxStr];
X    int	    size;
X    char    tag[MaxStr];
X    int	    timegoal;
X    int	    winsize;
X} Params;
X
Xtypedef unsigned long Pixel;
X
Xtypedef enum {
X    Succeeded,
X    CmdNotSupported,
X    OptNotSupported,
X    NoFonts,
X    NoOffscreenMem
X} Result;
X
Xtypedef double Rtime;
X
Xtypedef struct {
X    char*   cur;
X    char*   end;
X} TokenState;
X
Xtypedef struct {
X    int		bbx;
X    int		bby;
X    Pixel	colorbg;
X    Pixel	colorfg;
X    Drawable	dest;
X    int		dx;
X    int		dy;
X    Font	fontid;
X    int		func;
X    GC		gc;
X    OpIndex	index;
X    int		iterations;
X    OptFlags	o;
X    Params	p;
X    Result	result;
X    int		shift;
X    int		size[3];
X    Drawable	src;
X    double	time;
X    Window	w;
X    int		x;
X    int		y;
X} Cmd;
X
Xtypedef struct {
X    bool	    altwin;
X    int		    argc;
X    int		    argindex;
X    char**	    argv;
X    Cursor	    cursor;
X    Window	    cw1;
X    Window	    cw2;
X    Display*	    d;
X    Params	    defaults;
X    Drawable	    dest1;
X    Drawable	    dest2;
X    char	    disphost[MaxStr];
X    char	    fonts[MaxStr];
X    XFontStruct*    fontinfo[MaxFonts];
X    GC		    gc1;
X    GC		    gc2;
X    char*	    gxname;
X    char	    host[MaxStr];
X    int		    indepth;
X    FILE*	    infds[MaxIndepth+1];
X    char	    instr[MaxStr+1];
X    Drawable	    offpix;
X    FILE*	    outfd;
X    char	    outfile[MaxStr+1];
X    char	    outstr[MaxStr+1];
X    Pattern	    pattern;
X    OpIndex	    previndex;
X    Params	    prevparams;
X    int		    scriptindex;
X    Drawable	    src1;
X    Drawable	    src2;
X    bool	    strinput;
X    bool	    supcmds[NumOps];
X    OptFlags	    supopts;
X    XTextItem	    texts[MaxStr];
X    Pixmap	    tile;
X    TokenState	    ts;
X    XPoint	    v[MaxVert+1];
X    Window	    w1;
X    Window	    w2;
X    int		    winsize;
X} State;
X
Xbool	GetCmd();
XLoad	GetLoad();
XOpIndex	GetOpIndex();
XRtime	GetTime();
XFILE*	Out();
Xvoid	Start(),Erase(),Finish();
Xvoid	StartArc(),DoArc();
Xvoid	StartBlit(),DoBlit();
Xvoid	StartMap(),DoMap(),FinishMap();
Xvoid	DoNop();
Xvoid	StartPoint(),DoPoint();
Xvoid	StartPoly(),DoPoly();
Xvoid	StartRect(),DoRect();
Xvoid	StartText(),DoText();
Xvoid	StartVec(),DoVec();
Xchar*	StrToken();
X
Xextern char*	OpNames[NumOps][1+MaxPositional];
Xextern Op	Ops[NumOps][4];
Xextern char*	ResultMsgs[];
Xextern char*	Script[];
END_OF_FILE
if test 5690 -ne `wc -c <'gbench.h'`; then
    echo shar: \"'gbench.h'\" unpacked with wrong size!
fi
# end of 'gbench.h'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(8226 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X#include <gbench.h>
X
X#ifdef X10
X#   include <X10/bitmaps/gray1.bitmap>
X#   include <X10/cursors/target.cursor>
X#   include <X10/cursors/target_mask.cursor>
X#else
X#   include <X11/bitmaps/dot>
X#   include <X11/bitmaps/gray1>
X#endif
X
Xchar* OpNames[NumOps][1+MaxPositional] = {
X    {"arc",	"opts",	"size",	"aspect",   "angle",	"lwidth"},
X    {"blit",    "opts",	"size", "offset",   nil,	nil},
X    {"map",	"opts",	"size", "nwin",	    nil,	nil},
X    {"nop",     "opts",	nil,	nil,	    nil,	nil},
X    {"point",	"opts",	nil,	nil,	    nil,	nil},
X    {"poly",	"opts",	"size",	"nvert",    "lwidth",   nil},
X    {"rect",	"opts",	"size",	"lwidth",    nil,	nil},
X    {"text",	"opts",	"nchar","ptsize",   nil,	nil},
X    {"vec",	"opts",	"size",	"angle",    "lwidth",   nil}
X};
X
XOp Ops[NumOps][4] = {
X    {StartArc,	DoArc,	Erase,  Finish},
X    {StartBlit,	DoBlit,	Erase,  Finish},
X    {StartMap,	DoMap,	Erase,  FinishMap},
X    {Start,	DoNop,	Erase,  Finish},
X    {StartPoint,DoPoint,Erase,	Finish},
X    {StartPoly,	DoPoly,	Erase,  Finish},
X    {StartRect, DoRect,	Erase,  Finish},
X    {StartText, DoText,	Erase,  Finish},
X    {StartVec,	DoVec,	Erase,  Finish}
X};
X
Xchar* ResultMsgs[] = {
X    "Succeeded",
X    "CmdNotSupported",
X    "OptNotSupported",
X    "NoFonts",
X    "NoOffscreenMem"
X};
X
Xchar* Script[] = {
X    "@# Starting script",
X    "c",
X    "a",
X    "a f 10",
X    "a f 100",
X    "b",
X    "n",
X    "point",
X    "poly",
X    "poly f 10",
X    "poly f 100",
X    "r",
X    "r f 10",
X    "r f 100",
X    "t n 1",
X    "t n 10",
X    "v n 10",
X    "v n 100",
X    "@# End of script",
X    nil
X};
X
Xstatic char* pname = "gbench";
X
Xvoid SetFonts(sp,pp)
X    State*  sp;
X    Params* pp;
X{
X    int		findex = 0;
X    int		foundcount;
X    char**	foundlist;
X    int		i;
X    char*	name;
X    char*	np = pp->fonts;
X    char	nlist[MaxStr];
X    TokenState	ts;
X
X    strcpy(nlist,pp->fonts);
X    for (i=0;(i<MaxFonts)&&sp->fontinfo[i];i++) {
X	XFreeFont(DARGC sp->fontinfo[i]);
X	sp->fontinfo[i] = nil;
X    }
X    if (name=StrToken(nlist,",",&ts)) do {
X#	ifdef X10
X	    if (sp->fontinfo[findex]=XOpenFont(name)) {
X		sp->fontinfo[findex]->width = XQueryWidth("AA",
X		    sp->fontinfo[findex]->id)/2+1;
X		sprintf(np,"%s,",name);
X		np += strlen(np);
X		findex++;
X	    }
X#	else
X	    foundlist = XListFonts(sp->d,name,MaxFonts,&foundcount);
X	    for (i=0;(i<foundcount)&&(findex<MaxFonts);i++)
X		if (sp->fontinfo[findex]=XLoadQueryFont(sp->d,foundlist[i])) {
X		    sprintf(np,"%s,",foundlist[i]);
X		    np += strlen(np);
X		    findex++;
X		}
X	    XFreeFontNames(foundlist);
X#	endif
X    } while ((findex<MaxFonts)&&(name=StrToken(nil,",",&ts)));
X    if (np>pp->fonts) *--np = '\0';
X    strcpy(sp->fonts,pp->fonts);
X}
X
Xvoid SetOutfile(sp,pp)
X    State*  sp;
X    Params* pp;
X{
X    if (sp->outfd!=stdout) fclose(sp->outfd);
X    if (!strcmp(pp->outfile,"stdout")) sp->outfd = stdout;
X    else if (!(sp->outfd=fopen(pp->outfile,"a"))) {
X	sp->outfd = stdout;
X	strcpy(pp->outfile,"stdout");
X    }
X    strcpy(sp->outfile,pp->outfile);
X}
X
Xvoid SetWinsize(sp,pp)
X    State*  sp;
X    Params* pp;
X{
X#   ifdef X11
X	XSizeHints sh;
X#   endif X11
X
X#   ifdef X10
X	XChangeWindow(sp->w1,pp->winsize,pp->winsize);
X	XChangeWindow(sp->w2,pp->winsize,pp->winsize);
X#   else
X	sh.flags = USSize|PAspect;
X	sh.width = sh.height = pp->winsize;
X	sh.min_aspect.x = sh.max_aspect.x = sh.width;
X	sh.min_aspect.y = sh.max_aspect.y = sh.height;
X	XResizeWindow(sp->d,sp->w1,pp->winsize,pp->winsize);
X	XSetNormalHints(sp->d,sp->w1,&sh);
X	XResizeWindow(sp->d,sp->w2,pp->winsize,pp->winsize);
X	XSetNormalHints(sp->d,sp->w2,&sh);
X	if (pp->winsize>sp->winsize||!sp->offpix) {
X	    if (sp->offpix) XFreePixmap(sp->d,sp->offpix);
X	    sp->offpix = XCreatePixmap(
X		sp->d,_RootWindow,pp->winsize,pp->winsize,
X		DefaultDepth(sp->d,DefaultScreen(sp->d))
X	    );
X	}
X#   endif
X    sp->winsize = pp->winsize;
X    XFlush(DARG);
X}
X
Xvoid InitParams(sp,pp)
X    State*  sp;
X    Params* pp;
X{
X    pp->angle = DefaultAngle;
X    pp->aspect = DefaultAspect;
X    pp->count = 1;
X    strcpy(pp->fonts,DefaultFonts);
X    pp->ptsize = DefaultPtsize;
X    pp->lwidth = DefaultLwidth;
X    pp->maxshift = DefaultMaxshift;
X    pp->offset = DefaultOffset;
X    pp->nchar = DefaultNchar;
X    pp->nwin = DefaultNwin;
X    pp->nvert = DefaultNvert;
X    *pp->opts = '\0';
X    strcpy(pp->outfile,"stdout");
X    pp->size = DefaultSize;
X    *pp->tag = '\0';
X    pp->timegoal = DefaultTimegoal;
X    pp->winsize = DefaultWinsize;
X    if (strcmp(sp->fonts,pp->fonts)) SetFonts(sp,pp);
X    if (strcmp(sp->outfile,pp->outfile)) SetOutfile(sp,pp);
X    if (sp->winsize!=pp->winsize) SetWinsize(sp,pp);
X}
X
Xvoid InitState(sp)
X    State* sp;
X{
X    char*   cp;
X    int	    i;
X    int	    j;
X#   ifdef X11
X	XGCValues   gcv;
X	XSizeHints  sh;
X#   endif X11
X
X    sp->altwin = false;
X    sp->argindex = 1;
X    *sp->fonts = '\0';
X    for (i=0;i<MaxFonts;i++) sp->fontinfo[i] = nil;
X    sp->infds[0] = stdin;
X    sp->indepth = 0;
X    sp->offpix = nil;
X    sp->outfd = stdout;
X    strcpy(sp->outfile,"stdout");
X    sp->winsize = DefaultWinsize;
X    InitParams(sp,&sp->defaults);
X    sp->previndex = NilIndex;
X    InitParams(sp,&sp->prevparams);
X    gethostname(sp->host,MaxStr);
X    strncpy(sp->disphost,getenv("DISPLAY"),MaxStr);
X    if (cp=strchr(sp->disphost,':')) *cp = '\0';
X    if (!strcmp(sp->disphost,"unix")) strcpy(sp->disphost,sp->host);
X    for (i=0;i<MaxStr;i++) sp->outstr[i] = 'A'+(i%26);
X    sp->scriptindex = -1;
X    sp->w1 = XCreateSimpleWindow(
X	DARGC _RootWindow,0,0,sp->winsize,sp->winsize,2,WhitePixmap,BlackPixmap
X    );
X    sp->cw1 = XCreateSimpleWindow(
X	DARGC sp->w1,0,0,OverlapSize,OverlapSize,1,WhitePixmap,BlackPixmap
X    );
X    sp->w2 = XCreateSimpleWindow(
X	DARGC _RootWindow,sp->winsize,0,sp->winsize,sp->winsize,2,WhitePixmap,
X	BlackPixmap
X    );
X    sp->cw2 = XCreateSimpleWindow(
X	DARGC sp->w2,0,0,OverlapSize,OverlapSize,1,WhitePixmap,BlackPixmap
X    );
X    sp->dest1 = sp->w1;
X    sp->src1 = sp->w1;
X    sp->dest2 = sp->w2;
X    sp->src2 = sp->w2;
X    for (i=0;i<NumOps;i++) sp->supcmds[i] = true;
X    for (i=0;i<(sizeof(OptFlags)/sizeof(bool));i++) {
X	((bool*)&sp->supopts)[i] = true;
X    }
X#   ifdef X10
X	sp->supcmds[(int)ArcIndex] = false;
X	sp->supcmds[(int)NopIndex] = false;
X	sp->supcmds[(int)PointIndex] = false;
X	sp->supopts.altfont = false;
X	sp->supopts.altgc = false;
X	sp->supopts.offdest = false;
X	sp->supopts.offsrc =false;
X	sp->supopts.polywind = false;
X	sp->cursor = XCreateCursor(
X	    target_width,target_height,target_bits,target_mask_bits,
X	    target_x_hot,target_y_hot,_WhitePixel,_BlackPixel,GXcopy
X	);
X	sp->gxname = "X10";
X	sp->offpix = sp->w1;
X	sp->pattern = XMakePattern(1,2,4);
X	sp->tile = XMakePixmap(
X	    XStoreBitmap(gray1_width,gray1_height,gray1_bits),_WhitePixel,
X	    _BlackPixel
X	);
X#   else
X	sp->cursor = XCreateFontCursor(sp->d,XC_target);
X	gcv.foreground = _WhitePixel;
X	gcv.background = _BlackPixel;
X	gcv.tile = XCreatePixmapFromBitmapData(
X	    sp->d,_RootWindow,gray1_bits,gray1_width,gray1_height,_WhitePixel,
X	    _BlackPixel,DefaultDepth(sp->d,DefaultScreen(sp->d))
X	);
X	gcv.stipple = XCreateBitmapFromData(
X	    sp->d,_RootWindow,dot_bits,dot_width,dot_height
X	);
X	sp->gc1 = XCreateGC(
X	    sp->d,_RootWindow,GCForeground|GCBackground|GCTile|GCStipple,&gcv
X	);
X	sp->gc2 = XCreateGC(
X	    sp->d,_RootWindow,GCForeground|GCBackground|GCTile|GCStipple,&gcv
X	);
X	sp->gxname = "X11";
X	sh.flags = USPosition|USSize|PAspect;
X	sh.x = sh.y = 0;
X	sh.width = sh.height = sp->winsize;
X	sh.min_aspect.x = sh.max_aspect.x = sh.width;
X	sh.min_aspect.y = sh.max_aspect.y = sh.height;
X	XSetStandardProperties(
X	    sp->d,sp->w1,"gbench w1","gbench w1",None,sp->argv,sp->argc,&sh
X	);
X	sh.x = sp->winsize;
X	XSetStandardProperties(
X	    sp->d,sp->w2,"gbench w2","gbench w2",None,sp->argv,sp->argc,&sh
X	);
X	for (i=0;i<MaxStr;i++) {
X	    sp->texts[i].chars = sp->outstr+i;
X	    sp->texts[i].nchars = 1;
X	    sp->texts[i].delta = 0;
X	}
X#   endif
X    MapWin(sp,sp->w1);
X    XClearWindow(DARGC sp->w1);
X    XFlush(DARG);
X}
X
Xint main(argc,argv)
X    int	    argc;
X    char*   argv[];
X{
X    State   s;
X    State*  sp = &s;
X
X    s.argc = argc;
X    s.argv = argv;
X    ProfControl(0);
X    if (!(s.d=XOpenDisplay(0))) Fatal(pname,"Couldn't open display");
X    InitState(&s);
X    ExecCmds(&s);
X    XFlush(DARG);
X    return 0;
X}
END_OF_FILE
if test 8226 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'utils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils.c'\"
else
echo shar: Extracting \"'utils.c'\" \(8321 characters\)
sed "s/^X//" >'utils.c' <<'END_OF_FILE'
X#include <gbench.h>
X
Xint Abs(n)
X    int n;
X{
X    return n>=0?n:-n;
X}
X
Xvoid CopyParams(dp,sp)
X    Params* dp;
X    Params* sp;
X
X{
X    bcopy(sp,dp,sizeof(Params));
X}
X
Xvoid Fatal(p,e)
X    char*   p;
X    char*   e;
X{
X    fprintf(stderr,"%s:  ",p);
X    fprintf(stderr,e,p);
X    putc('\n',stderr);
X    exit(1);
X}
X
Xint FontIndex(sp,sizep)
X    State*  sp;
X    int*    sizep;
X{
X    int i;
X    int	mindist = _DisplayHeight;
X    int minindex = -1;
X    int minsize = *sizep;
X    int newsize;
X
X    for (i=0;(i<MaxFonts)&&sp->fontinfo[i];i++) {
X#	ifdef X10
X	    newsize = sp->fontinfo[i]->height;
X#	else
X	    newsize = sp->fontinfo[i]->ascent;
X#	endif
X	if (Abs(*sizep-newsize)<mindist) {
X	    mindist = Abs(*sizep-newsize);
X	    minindex = i;
X	    minsize = newsize;
X	}
X    }
X    *sizep = minsize;
X    return minindex;
X}
X
XLoad GetLoad()
X{
X    int		    kmem;
X    struct nlist    nl[2];
X#   ifdef FIXLOAD
X	long	    load;
X#   else
X	double	    load;
X#   endif
X
X    nl[0].n_name = "_avenrun";
X    nl[1].n_name = nil;
X    nlist("/vmunix",nl);
X    if (!nl[0].n_type) return 0.;
X    if ((kmem=open("/dev/kmem",0))<0) return 0.;
X    lseek(kmem,nl[0].n_value,0);
X    read(kmem,&load,sizeof(load));
X#   ifdef FIXLOAD
X	return load/256.;
X#   else
X	return load;
X#   endif
X}
X
XOpIndex GetOpIndex(opname)
X    char* opname;
X{
X    int i;
X    
X    for (i=0;i<NumOps;i++) {
X	if (!strncmp(opname,OpNames[i][0],strlen(opname))) return (OpIndex)i;
X    }
X    return NilIndex;
X}
X
XRtime GetTime(sp)
X    State*  sp;
X{
X    struct timeval t;
X
X    XSync(DARGC true);
X    gettimeofday(&t,0);
X    return t.tv_sec+t.tv_usec/1000000.;
X}
X
Xvoid Help(f,s)
X    FILE*   f;
X    char*   s;
X{
X    putc('#',f);
X    fputs(s,f);
X    putc('\n',f);
X}
X
Xint InputMask(cp)
X    Cmd* cp;
X{
X    int im = 0;
X    
X    if (cp->o.drag) im |= (ButtonPressMask|ButtonReleaseMask);
X    if (!cp->o.poll) im |= PointerMotionMask;
X    if (cp->o.overlap) im |= (ExposeRegionMask|ExposureMask);
X    return im;
X}
X
Xint Limit(n,min,max)
X    int	n;
X    int	min;
X    int	max;
X{
X    if (n<min) n = min;
X    else if (n>max) n = max;
X    return n;
X}
X
Xvoid MapWin(sp,w)
X    State*  sp;
X    Window  w;
X{
X#   ifdef X11
X        XEvent e;
X        XSelectInput(sp->d,w,StructureNotifyMask);
X#   endif X11
X    XMapWindow(DARGC w);
X#   ifdef X11
X        do
X            XNextEvent(sp->d,&e);
X        while (e.type!=MapNotify);
X#   endif X11
X}
X
Xvoid MoveClip(sp,cp,x,y)
X    State*  sp;
X    Cmd*    cp;
X    int	    x;
X    int	    y;
X{
X    if (cp->o.overlap) {
X	x += cp->p.maxshift/2-OverlapSize/2;
X	y += cp->p.maxshift/2-OverlapSize/2;
X	XMoveWindow(DARGC sp->cw1,x,y);
X	XMoveWindow(DARGC sp->cw2,x,y);
X    }
X}
X
Xvoid MoveVert(sp,cp,vcount)
X    State*  sp;
X    Cmd*    cp;
X    int	    vcount;
X{
X    int i;
X    
X    if (cp->dx||cp->dy) for (i=0;i<=vcount;i++) {
X	sp->v[i].x += cp->dx;
X	sp->v[i].y += cp->dy;
X    }
X}
X
XFILE* Out(sp,cp)
X    State*  sp;
X    Cmd*    cp;
X{
X    if (cp->o.silent) return stderr;
X    else return sp->outfd;
X}
X
Xvoid PrintConfig(f,sp)
X    FILE*   f;
X    State*  sp;
X{
X    int t = time(0);
X
X    fprintf(f,"# host=%s\n",sp->host);
X    fprintf(f,"# display=%s\n",getenv("DISPLAY"));
X    fprintf(f,"# graphics=%s\n",sp->gxname);
X    fprintf(f,"# time=%s",ctime(&t));
X    fprintf(f,"# version=%.1f\n",Version);
X    fprintf(f,"# tag=%s\n",sp->defaults.tag);
X}
X
Xvoid PrintParam(f,pp,pre,name,post)
X    FILE*   f;
X    Params* pp;
X    char*   pre;
X    char*   name;
X    char*   post;
X{
X    fprintf(f,"%s",pre);
X    if (!strcmp(name,"angle")) fprintf(f,"%s=%d",name,pp->angle);
X    else if (!strcmp(name,"aspect")) fprintf(f,"%s=%.1f",name,pp->aspect);
X    else if (!strcmp(name,"count")) fprintf(f,"%s=%d",name,pp->count);
X    else if (!strcmp(name,"fonts")) fprintf(f,"%s=%s",name,pp->fonts);
X    else if (!strcmp(name,"ptsize")) fprintf(f,"%s=%d",name,pp->ptsize);
X    else if (!strcmp(name,"lwidth")) fprintf(f,"%s=%d",name,pp->lwidth);
X    else if (!strcmp(name,"maxshift")) fprintf(f,"%s=%d",name,pp->maxshift);
X    else if (!strcmp(name,"offset")) fprintf(f,"%s=%.1f",name,pp->offset);
X    else if (!strcmp(name,"nchar")) fprintf(f,"%s=%d",name,pp->nchar);
X    else if (!strcmp(name,"nwin")) fprintf(f,"%s=%d",name,pp->nwin);
X    else if (!strcmp(name,"nvert")) fprintf(f,"%s=%d",name,pp->nvert);
X    else if (!strcmp(name,"opts")) fprintf(f,"%s=%s",name,pp->opts);
X    else if (!strcmp(name,"outfile")) fprintf(f,"%s=%s",name,pp->outfile);
X    else if (!strcmp(name,"size")) fprintf(f,"%s=%d",name,pp->size);
X    else if (!strcmp(name,"tag")) fprintf(f,"%s=%s",name,pp->tag);
X    else if (!strcmp(name,"timegoal")) fprintf(f,"%s=%d",name,pp->timegoal);
X    else if (!strcmp(name,"winsize")) fprintf(f,"%s=%d",name,pp->winsize);
X    fprintf(f,"%s",post);
X}
X
Xvoid PrintParams(f,sp,pp)
X    FILE*   f;
X    State*  sp;
X    Params* pp;
X{
X    int i;
X
X    PrintParam(f,pp,"# ","angle","\n");
X    PrintParam(f,pp,"# ","aspect","\n");
X    PrintParam(f,pp,"# ","count","\n");
X    PrintParam(f,pp,"# ","fonts","\n");
X    PrintParam(f,pp,"# ","ptsize","\n");
X    PrintParam(f,pp,"# ","lwidth","\n");
X    PrintParam(f,pp,"# ","maxshift","\n");
X    PrintParam(f,pp,"# ","offset","\n");
X    PrintParam(f,pp,"# ","nchar","\n");
X    PrintParam(f,pp,"# ","nwin","\n");
X    PrintParam(f,pp,"# ","nvert","\n");
X    PrintParam(f,pp,"# ","opts","\n");
X    PrintParam(f,pp,"# ","outfile","\n");
X    PrintParam(f,pp,"# ","size","\n");
X    PrintParam(f,pp,"# ","tag","\n");
X    PrintParam(f,pp,"# ","timegoal","\n");
X    PrintParam(f,pp,"# ","winsize","\n");
X}
X
Xvoid PrintHelp(f)
X    FILE* f;
X{
X    int	    i;
X    int	    j;
X
X    Help(f,"Commands:");
X    for (i=0;i<NumOps;i++) {
X	fprintf(f,"#  %-8s",OpNames[i][0]);
X	for (j=0;(j<MaxPositional)&&OpNames[i][1+j];j++) {
X	    fprintf(f," [%-6s]",OpNames[i][1+j]);
X	}
X	fprintf(f," [n=v]*\n");
X    }
X    Help(f,"  config");
X    Help(f,"  defaults [n=v]*");
X    Help(f,"  help");
X    Help(f,"  init");
X    Help(f,"  script   [filename]");
X    Help(f,"  quit");
X    Help(f,"  !");
X    Help(f,"  #");
X    Help(f,"Options:");
X    Help(f,"  ac    Alternate colors");
X    Help(f,"  af    Alternate fonts");
X    Help(f,"  ag    Alternate graphics contexts");
X    Help(f,"  aw    Alternate windows");
X    Help(f,"  d     Drag");
X    Help(f,"  f     Fill");
X    Help(f,"  i     Invert");
X    Help(f,"  m     Monitor for profiling");
X    Help(f,"  n     No options");
X    Help(f,"  o     Overlap");
X    Help(f,"  os    Offscreen source");
X    Help(f,"  od    Offscreen destination");
X    Help(f,"  p     Poll");
X    Help(f,"  ps    Polygon self-intersecting");
X    Help(f,"  pw    Polygon winding number fill");
X    Help(f,"  r     Reset defaults");
X    Help(f,"  s     Stipple");
X    Help(f,"  t     Tile");
X    Help(f,"  u     Unbatched");
X}
X
Xvoid ProfControl(i)
X    int i;
X{
X# ifdef GPROF
X    moncontrol(i);
X# endif GPROF
X}
X
Xchar* StrToken(s1,s2,tsp)
X    char*	s1;
X    char*	s2;
X    TokenState*	tsp;
X{
X    char* bp;
X
X    if (s1) {
X	tsp->cur = s1;
X	tsp->end = s1+strlen(s1);
X    }
X    else {
X	tsp->cur += strlen(tsp->cur)+1;
X	if (tsp->cur>=tsp->end) return nil;
X    }
X    tsp->cur += strspn(tsp->cur,s2);
X    if (bp=strpbrk(tsp->cur,s2)) *bp = '\0';
X    if (tsp->cur>=tsp->end) return nil;
X    else return tsp->cur;
X}
X
Xvoid UnmapWin(sp,w)
X    State*  sp;
X    Window  w;
X{
X#   ifdef X11
X        XEvent e;
X        XSelectInput(sp->d,w,StructureNotifyMask);
X#   endif X11
X    XUnmapWindow(DARGC w);
X#   ifdef X11
X        do
X            XNextEvent(sp->d,&e);
X        while (e.type!=UnmapNotify);
X#   endif X11
X}
X
X#ifdef X10
Xvoid X10Draw(sp,cp,vcount)
X    State*  sp;
X    Cmd*    cp;
X    int	    vcount;
X{
X    if (cp->o.fill) {
X	if (cp->o.tile) {
X	    XDrawTiled(cp->w,sp->v,vcount,sp->tile,cp->func,AllPlanes);
X	}
X	else XDrawFilled(cp->w,sp->v,vcount,cp->colorfg,cp->func,AllPlanes);
X    }
X    else {
X	if (cp->o.stipple) {
X	    XDrawDashed(
X		cp->w,sp->v,vcount,cp->p.lwidth,cp->p.lwidth,cp->colorfg,
X		sp->pattern,cp->func,AllPlanes
X	    );
X	}
X	else if (cp->o.tile) {
X	    XDrawPatterned(
X		cp->w,sp->v,vcount,cp->p.lwidth,cp->p.lwidth,cp->colorfg,
X		cp->colorbg,sp->pattern,cp->func,AllPlanes
X	    );
X	}
X	else if (vcount==2) {
X	    XLine(
X		cp->w,sp->v[0].x,sp->v[0].y,sp->v[1].x,sp->v[1].y,cp->p.lwidth,
X		cp->p.lwidth,cp->colorfg,cp->func,AllPlanes
X	    );
X	}
X	else {
X	    XDraw(
X		cp->w,sp->v,vcount,cp->p.lwidth,cp->p.lwidth,cp->colorfg,
X		cp->func,AllPlanes
X	    );
X	}
X    }
X}
X#endif X10
END_OF_FILE
if test 8321 -ne `wc -c <'utils.c'`; then
    echo shar: \"'utils.c'\" unpacked with wrong size!
fi
# end of 'utils.c'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
