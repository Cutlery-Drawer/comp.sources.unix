Subject:  v15i052:  VN April, 1988, upgrade kit, Part01/02
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Bob McQueer <rtech!weevil!bobm>
Posting-number: Volume 15, Issue 52
Archive-name: vn.april.pch/part01

[  VN is an alternate newsreader that was most recently released in January.
   This is a shar file containing that will create patch1, either unshar
   this and then run patch, or bring your version of patch up to the
   current revision level.  -r$  ]

There are a couple of minor new features and bugfixes here.  The main
difference is the addition of some new hooks to allow the server interface
to use marks and implement additional commands.  See server.doc.

Something I AM serious about with this program is to attempt to keep
the user interface cleanly divided from the news server by the interface
described in server.doc.  These additions are backwards compatible,
since the all take the form of function pointers which the server
interface may optionally set.  These are hooks intended to hang
enhancements from, such as:

	1) Alternate massaging of articles to save them in files.

	2) Use of the marks by the server interface.  This would be
	   the intended way to implement features such as retaining
	   selected articles for reading at the next session.  To
	   use vn as a mailer, the natural thing to do here would
	   be to selectively RETAIN in your mailbox, and selectively
	   DELETE in your mail folders.

	3) News format specific functions such as which header lines
	   to display, etc.

The server interface routines are all contained in the std.c file in
the distributed version, and the other .c files define the interface,
which should not reflect any news-server specific things (the digest
feature is a violation, since it knows about "header" lines in the
article text - consider that it comes in under some sort of backwards-
compatibility clause - I don't want to propogate any more such things)

There are several people interested in modifying this program in
various ways - I would like to request that the server / user interface
division stay clean.

I generated the diffs with "rcsdiff -c -r6.0 RCS/*", revision 6.0
being the 1/88 version (yes, I know about symbolic names).  Hopefully,
this doesn't create too many problems for various "patchamatic"'s.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  patch1
# Wrapped by rsalz@fig.bbn.com on Wed Jun  8 15:55:46 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch1'\"
else
echo shar: Extracting \"'patch1'\" \(42380 characters\)
sed "s/^X//" >'patch1' <<'END_OF_FILE'
X--------
XRCS file: RCS/config.h,v
Xretrieving revision 6.0
Xdiff -c -r6.0 config.h
X*** /tmp/,RCSt1029201	Sat May 28 13:07:53 1988
X--- config.h	Mon Apr 11 17:35:21 1988
X***************
X*** 41,46
X  #define NOJOB_FG 1
X  
X  /*
X  ** arrow key treatment.  If PAGEARROW is defined, right and left arrow
X  ** keys will be synonyms for <return> (next-page) and <backspace> (previous).
X  ** Otherwise, the right arrow will function as down, and the left as up.
X
X--- 41,57 -----
X  #define NOJOB_FG 1
X  
X  /*
X+ ** bit mask for interpreting command characters.  Set it to 0xff, and
X+ ** we should be able to handle 8 bit characters for control keys -
X+ ** leaving it 0x7f protects against possible parity bits in ascii
X+ ** characters.  A lot of the general paranoia about character handling
X+ ** in raw mode comes from one of the earliest versions which was
X+ ** run on an amdahl using an IBM series 1 front end - it had a very
X+ ** brain damaged implementation of ioctl().
X+ */
X+ #define CHMASK 0x7f
X+ 
X+ /*
X  ** arrow key treatment.  If PAGEARROW is defined, right and left arrow
X  ** keys will be synonyms for <return> (next-page) and <backspace> (previous).
X  ** Otherwise, the right arrow will function as down, and the left as up.
X===================================================================
XRCS file: RCS/envir_set.c,v
Xretrieving revision 6.0
Xdiff -c -r6.0 envir_set.c
X*** /tmp/,RCSt1029201	Sat May 28 13:07:55 1988
X--- envir_set.c	Mon Apr 11 17:40:10 1988
X***************
X*** 111,117
X  	char in,out,*ptr;
X  	char *index(), xln_str();
X  
X! 	for (i=0; i < 128; ++i)
X  		Cxitop[i] = Cxitor[i] = Cxptoi[i] = Cxrtoi[i] = i;
X  
X  	if ((fp = fopen(fname,"r")) != NULL)
X
X--- 111,117 -----
X  	char in,out,*ptr;
X  	char *index(), xln_str();
X  
X! 	for (i=0; i < CHMASK+1; ++i)
X  		Cxitop[i] = Cxitor[i] = Cxptoi[i] = Cxrtoi[i] = i;
X  
X  	if ((fp = fopen(fname,"r")) != NULL)
X***************
X*** 152,157
X  char *s;
X  {
X  	if (*s < '0' || *s > '9')
X! 		return(*s & 0x7f);
X! 	return((char)(atoi(s) & 0x7f));
X  }
X
X--- 152,157 -----
X  char *s;
X  {
X  	if (*s < '0' || *s > '9')
X! 		return(*s & CHMASK);
X! 	return((char)(atoi(s) & CHMASK));
X  }
X===================================================================
XRCS file: RCS/getch.c,v
Xretrieving revision 6.0
Xdiff -c -r6.0 getch.c
X*** /tmp/,RCSt1029201	Sat May 28 13:07:56 1988
X--- getch.c	Mon Apr 11 17:40:18 1988
X***************
X*** 7,12
X  */
X  #include <stdio.h>
X  #include <setjmp.h>
X  #include "config.h"
X  #include "vn.h"
X  
X
X--- 7,13 -----
X  */
X  #include <stdio.h>
X  #include <setjmp.h>
X+ #include <ctype.h>
X  #include "config.h"
X  #include "vn.h"
X  
X***************
X*** 27,33
X  	static char	ckseq[32];
X  
X  	/* Check for leading count */
X! 	for (i = 0; (*c = getchar() & 0x7f) >= '0' && *c <= '9'; i = i * 10 + *c - '0')
X  		;
X  
X  	/* @#$!!! flakey front ends that won't map newlines in raw mode */
X
X--- 28,34 -----
X  	static char	ckseq[32];
X  
X  	/* Check for leading count */
X!  	for (i = 0; isdigit(*c = getchar() & CHMASK); i = i * 10 + *c - '0')
X  		;
X  
X  	/* @#$!!! flakey front ends that won't map newlines in raw mode */
X***************
X*** 54,60
X  			if( strcmp(ckseq, Kl) == 0 ) { *c = UP; break; }
X  			if( strcmp(ckseq, Kr) == 0 ) { *c = DOWN; break; }
X  #endif
X! 			*c = (getchar() & 0x7f);
X  			ckseq[++j] = *c; ckseq[j+1] = '\0';
X  		}
X  	}
X
X--- 55,61 -----
X  			if( strcmp(ckseq, Kl) == 0 ) { *c = UP; break; }
X  			if( strcmp(ckseq, Kr) == 0 ) { *c = DOWN; break; }
X  #endif
X! 			*c = (getchar() & CHMASK);
X  			ckseq[++j] = *c; ckseq[j+1] = '\0';
X  		}
X  	}
X***************
X*** 73,79
X  getnoctl ()
X  {
X  	char c;
X! 	while ((c = getchar() & 0x7f) < ' ' || c == '\177')
X  	{
X  		if (c == '\015' || c == '\012')
X  			c = '\n';
X
X--- 74,80 -----
X  getnoctl ()
X  {
X  	char c;
X!  	while (iscntrl(c = getchar() & CHMASK))
X  	{
X  		if (c == '\015' || c == '\012')
X  			c = '\n';
X===================================================================
XRCS file: RCS/help.c,v
Xretrieving revision 6.0
Xdiff -c -r6.0 help.c
X*** /tmp/,RCSt1029201	Sat May 28 13:07:59 1988
X--- help.c	Tue Apr 12 10:51:21 1988
X***************
X*** 21,26
X  extern char *Contstr;
X  extern char Cxptoi[], Cxrtoi[];
X  
X  /*
X  	Help message table.  Character for command, plus its help
X  	message.  Table order is order of presentation to user.
X
X--- 21,29 -----
X  extern char *Contstr;
X  extern char Cxptoi[], Cxrtoi[];
X  
X+ extern int (*Hookfunc)();
X+ extern char *(*Hookhelp)();
X+ 
X  /*
X  	Help message table.  Character for command, plus its help
X  	message.  Table order is order of presentation to user.
X***************
X*** 43,48
X  	{ BACK, "previous page [number of pages]", 1, NULL},
X  	{ FORWARD, "next page [number of pages]", 1, NULL},
X  #endif
X  	{ TOPMOVE, "move to top of page", 1, NULL},
X  	{ BOTMOVE, "move to bottom of page", 1, NULL},
X  	{ ALTBOTTOM, "move to bottom of page (alternate L)", 1, NULL},
X
X--- 46,53 -----
X  	{ BACK, "previous page [number of pages]", 1, NULL},
X  	{ FORWARD, "next page [number of pages]", 1, NULL},
X  #endif
X+ 	{ GRPBACK, "previous newsgroup [number of newsgroups]", 0, NULL },
X+ 	{ GRPFORWARD, "next newsgroup [number of newsgroups]", 0, NULL },
X  	{ TOPMOVE, "move to top of page", 1, NULL},
X  	{ BOTMOVE, "move to bottom of page", 1, NULL},
X  	{ ALTBOTTOM, "move to bottom of page (alternate L)", 1, NULL},
X***************
X*** 71,76
X  	{ MARK, "mark/unmark article [number of articles]", 1, NULL},
X  	{ ART_MARK, "mark/unmark article [number of articles]", 1, NULL},
X  	{ UNMARK, "erase marks on articles", 1, NULL},
X  	{ HEADTOG, "toggle flag for display of headers when reading", 1, NULL},
X  	{ SETROT, "toggle rotation for reading", 1, NULL},
X  	{ REDRAW, "redraw screen", 1, NULL},
X
X--- 76,82 -----
X  	{ MARK, "mark/unmark article [number of articles]", 1, NULL},
X  	{ ART_MARK, "mark/unmark article [number of articles]", 1, NULL},
X  	{ UNMARK, "erase marks on articles", 1, NULL},
X+ 	{ MARKSTRING, "specify articles to mark/unmark", 1, NULL},
X  	{ HEADTOG, "toggle flag for display of headers when reading", 1, NULL},
X  	{ SETROT, "toggle rotation for reading", 1, NULL},
X  	{ REDRAW, "redraw screen", 1, NULL},
X***************
X*** 86,92
X  */
X  help ()
X  {
X! 	int i,lcount,lim; 
X  	term_set (ERASE);
X  	lim = L_allow + RECBIAS - 2;
X  	printf("%s\n",HELP_HEAD);
X
X--- 92,101 -----
X  */
X  help ()
X  {
X! 	int i,lcount,lim;
X! 	char *hs;
X! 	char c;
X! 
X  	term_set (ERASE);
X  	lim = L_allow + RECBIAS - 2;
X  	printf("%s\n",HELP_HEAD);
X***************
X*** 91,97
X  	lim = L_allow + RECBIAS - 2;
X  	printf("%s\n",HELP_HEAD);
X  	lcount = HHLINES;
X! 	for (i=0; i < (sizeof(Helptab))/(sizeof(struct HELPTAB)); ++i)
X  	{
X  		if (Digest && !(Helptab[i].dig))
X  			continue;
X
X--- 100,106 -----
X  	lim = L_allow + RECBIAS - 2;
X  	printf("%s\n",HELP_HEAD);
X  	lcount = HHLINES;
X! 	for (i=0; i < HTSIZE; ++i)
X  	{
X  		if (Digest && !(Helptab[i].dig))
X  			continue;
X***************
X*** 95,100
X  	{
X  		if (Digest && !(Helptab[i].dig))
X  			continue;
X  		++lcount;
X  		if (Digest && Helptab[i].amsg != NULL)
X  			h_print (Cxptoi[Helptab[i].cmd],Helptab[i].amsg);
X
X--- 104,111 -----
X  	{
X  		if (Digest && !(Helptab[i].dig))
X  			continue;
X+ 		if (Hookfunc != NULL && (*Hookfunc)(Helptab[i].cmd,0,0) >= 0)
X+ 			continue;
X  		++lcount;
X  		if (Digest && Helptab[i].amsg != NULL)
X  			h_print (Cxptoi[Helptab[i].cmd],Helptab[i].amsg);
X***************
X*** 111,116
X  			lcount = 0;
X  		}
X  	}
X  	if (lcount > 0)
X  	{
X  		printf ("\n%s",Contstr);
X
X--- 122,146 -----
X  			lcount = 0;
X  		}
X  	}
X+ 	if (Hookhelp != NULL)
X+ 	{
X+ 		for (hs=(*Hookhelp)(0,1,&c);
X+ 				hs != NULL; hs = (*Hookhelp)(0,0,&c))
X+ 		{
X+ 			++lcount;
X+ 			h_print (Cxptoi[c],hs);
X+ 			if (lcount >= lim)
X+ 			{
X+ 				printf ("\n%s",Contstr);
X+ 				getnoctl ();
X+ 				term_set (MOVE,0,lim+1);
X+ 				term_set (ZAP,0,strlen(Contstr));
X+ 				term_set (MOVE,0,lim-1);
X+ 				putchar ('\n');
X+ 				lcount = 0;
X+ 			}
X+ 		}
X+ 	}
X  	if (lcount > 0)
X  	{
X  		printf ("\n%s",Contstr);
X***************
X*** 123,142
X  */
X  help_rd()
X  {
X! 	h_print (Cxrtoi[PG_NEXT],HPG_NEXT);
X! 	h_print (Cxrtoi[PG_QUIT],HPG_QUIT);
X! 	h_print (Cxrtoi[PG_FLIP],HPG_FLIP);
X! 	h_print (Cxrtoi[PG_REWIND],HPG_REWIND);
X! 	h_print (Cxrtoi[PG_WIND],HPG_WIND);
X! 	h_print (Cxrtoi[PG_SEARCH],HPG_SEARCH);
X! 	h_print (Cxrtoi[PG_STEP],HPG_STEP);
X! 	h_print (Cxrtoi[PG_REPLY],HPG_REPLY);
X! 	h_print (Cxrtoi[PG_FOLLOW],HPG_FOLLOW);
X! 	h_print (Cxrtoi[SAVE],HPG_SAVE);
X! 	h_print (Cxrtoi[PRINT],HPG_PRINT);
X! 	h_print (Cxrtoi[SETROT],HPG_ROT);
X! 	h_print (Cxrtoi[HEADTOG],HPG_HEAD);
X! 	h_print (Cxrtoi[PG_HELP],HPG_HELP);
X  	printf ("%s\n",HPG_DEF);
X  }
X  
X
X--- 153,183 -----
X  */
X  help_rd()
X  {
X! 	char *hs;
X! 	char c;
X! 
X! 	printf("\n");	/* "confused" tab expansion on first line */
X! 
X! 	hr_print (Cxrtoi[PG_NEXT],HPG_NEXT);
X! 	hr_print (Cxrtoi[PG_QUIT],HPG_QUIT);
X! 	hr_print (Cxrtoi[PG_FLIP],HPG_FLIP);
X! 	hr_print (Cxrtoi[PG_REWIND],HPG_REWIND);
X! 	hr_print (Cxrtoi[PG_WIND],HPG_WIND);
X! 	hr_print (Cxrtoi[PG_SEARCH],HPG_SEARCH);
X! 	hr_print (Cxrtoi[PG_STEP],HPG_STEP);
X! 	hr_print (Cxrtoi[PG_REPLY],HPG_REPLY);
X! 	hr_print (Cxrtoi[PG_FOLLOW],HPG_FOLLOW);
X! 	hr_print (Cxrtoi[SAVE],HPG_SAVE);
X! 	hr_print (Cxrtoi[PRINT],HPG_PRINT);
X! 	hr_print (Cxrtoi[SETROT],HPG_ROT);
X! 	hr_print (Cxrtoi[HEADTOG],HPG_HEAD);
X! 	hr_print (Cxrtoi[PG_HELP],HPG_HELP);
X! 	if (Hookhelp != NULL)
X! 	{
X! 		for (hs=(*Hookhelp)(1,1,&c);
X! 				hs != NULL; hs = (*Hookhelp)(1,0,&c))
X! 			h_print (Cxrtoi[c],hs);
X! 	}
X  	printf ("%s\n",HPG_DEF);
X  }
X  
X***************
X*** 138,143
X  	h_print (Cxrtoi[HEADTOG],HPG_HEAD);
X  	h_print (Cxrtoi[PG_HELP],HPG_HELP);
X  	printf ("%s\n",HPG_DEF);
X  }
X  
X  srch_help(c,dig)
X
X--- 179,192 -----
X  			h_print (Cxrtoi[c],hs);
X  	}
X  	printf ("%s\n",HPG_DEF);
X+ }
X+ 
X+ hr_print(c,msg)
X+ char c;
X+ char *msg;
X+ {
X+ 	if (Hookfunc == NULL || (*Hookfunc)(c,1,0) < 0)
X+ 		h_print(c,msg);
X  }
X  
X  srch_help(c,dig)
X===================================================================
XRCS file: RCS/pagefile.c,v
Xretrieving revision 6.0
Xdiff -c -r6.0 pagefile.c
X*** /tmp/,RCSt1029201	Sat May 28 13:08:01 1988
X--- pagefile.c	Mon Apr 11 17:40:55 1988
X***************
X*** 7,12
X  */
X  
X  #include <stdio.h>
X  
X  #ifdef SYSV
X  #include <sys/types.h>
X
X--- 7,13 -----
X  */
X  
X  #include <stdio.h>
X+ #include <ctype.h>
X  
X  #ifdef SYSV
X  #include <sys/types.h>
X***************
X*** 47,53
X  	Lrec = -1;
X  	tmpnam (tmpart);
X  	Pgsize = sizeof (HEAD) + L_allow * sizeof(BODY);
X! 	if ((Tdes = open(tmpart,O_RDWR|O_CREAT)) < 0)
X  		printex ("can't open %s",tmpart);
X  	unlink (tmpart);
X  }
X
X--- 48,54 -----
X  	Lrec = -1;
X  	tmpnam (tmpart);
X  	Pgsize = sizeof (HEAD) + L_allow * sizeof(BODY);
X! 	if ((Tdes = open(tmpart,O_RDWR|O_CREAT,0600)) < 0)
X  		printex ("can't open %s",tmpart);
X  	unlink (tmpart);
X  }
X***************
X*** 217,224
X  {
X  	while (*s != '\0')
X  	{
X! 		if (*s < ' ')
X! 			*s += 'A' - 1;
X  		++s;
X  	}
X  }
X
X--- 218,225 -----
X  {
X  	while (*s != '\0')
X  	{
X! 		if (iscntrl(*s))
X! 			*s = '?';
X  		++s;
X  	}
X  }
X===================================================================
XRCS file: RCS/reader.c,v
Xretrieving revision 6.0
Xdiff -c -r6.0 reader.c
X*** /tmp/,RCSt1029201	Sat May 28 13:08:04 1988
X--- reader.c	Tue Apr 12 10:51:27 1988
X***************
X*** 8,13
X  
X  #include <stdio.h>
X  #include <sys/types.h>
X  #include "tty.h"
X  #include "config.h"
X  #include "tune.h"
X
X--- 8,14 -----
X  
X  #include <stdio.h>
X  #include <sys/types.h>
X+ #include <ctype.h>
X  #include "tty.h"
X  #include "config.h"
X  #include "tune.h"
X***************
X*** 33,38
X  extern char *Rotoff_msg;
X  extern char *Hdon_msg;
X  extern char *Hdoff_msg;
X  
X  extern PAGE Page;
X  
X
X--- 34,40 -----
X  extern char *Rotoff_msg;
X  extern char *Hdon_msg;
X  extern char *Hdoff_msg;
X+ extern char *Def_smode;
X  
X  extern PAGE Page;
X  
X***************
X*** 39,44
X  extern int (*Massage)();
X  extern int (*Postfunc)();
X  extern int (*Mailfunc)();
X  
X  extern char Cxrtoi[], Cxitor[];
X  
X
X--- 41,48 -----
X  extern int (*Massage)();
X  extern int (*Postfunc)();
X  extern int (*Mailfunc)();
X+ extern int (*Savemode)();
X+ extern int (*Hookfunc)();
X  
X  extern char Cxrtoi[], Cxitor[];
X  
X***************
X*** 201,207
X  			*/
X  			if (Headflag)
X  			{
X! 				top = (Rlines-2)*100;
X  				bottom = hdr.lines + Hlines;
X  			}
X  			else
X
X--- 205,211 -----
X  			*/
X  			if (Headflag)
X  			{
X! 				top = (Rlines-2);
X  				bottom = hdr.lines + Hlines;
X  			}
X  			else
X***************
X*** 206,212
X  			}
X  			else
X  			{
X! 				top = (Rlines-Hlines-2)*100;
X  				bottom = hdr.lines;
X  			}
X  			/*
X
X--- 210,216 -----
X  			}
X  			else
X  			{
X! 				top = (Rlines-Hlines-2);
X  				bottom = hdr.lines;
X  			}
X  			/*
X***************
X*** 216,222
X  			** know the percentage is obviously wrong.
X  			*/
X  			if (bottom != 0)
X! 				percent = top/bottom;
X  			else
X  				percent = 999;
X  			sprintf (pstr,PAGE_MID,percent);
X
X--- 220,226 -----
X  			** know the percentage is obviously wrong.
X  			*/
X  			if (bottom != 0)
X! 				percent = (top*100L)/bottom;
X  			else
X  				percent = 999;
X  			sprintf (pstr,PAGE_MID,percent);
X***************
X*** 330,335
X  {
X  	char c;
X  	int ic;
X  	term_set (ONREVERSE);
X  	printf("%s\015",prompt);
X  	term_set (OFFREVERSE);
X
X--- 334,342 -----
X  {
X  	char c;
X  	int ic;
X+ 	int i;
X+ 	char mbuf[RECLEN];
X+ 
X  	term_set (ONREVERSE);
X  	printf("%s\015",prompt);
X  	term_set (OFFREVERSE);
X***************
X*** 335,341
X  	term_set (OFFREVERSE);
X  	while ((ic=getnoctl()) != EOF)
X  	{
X! 		switch (c = Cxitor[ic])
X  		{
X  		case SETROT:
X  			term_set (ZAP,0,PPR_MAX);
X
X--- 342,349 -----
X  	term_set (OFFREVERSE);
X  	while ((ic=getnoctl()) != EOF)
X  	{
X! 		c = Cxitor[ic];
X! 		if (Hookfunc != NULL && (i = (*Hookfunc)(c,1,1,mbuf)) >= 0)
X  		{
X  			if (i == 0)
X  			{
X***************
X*** 337,342
X  	{
X  		switch (c = Cxitor[ic])
X  		{
X  		case SETROT:
X  			term_set (ZAP,0,PPR_MAX);
X  			if (Rot == 0)
X
X--- 345,362 -----
X  		c = Cxitor[ic];
X  		if (Hookfunc != NULL && (i = (*Hookfunc)(c,1,1,mbuf)) >= 0)
X  		{
X+ 			if (i == 0)
X+ 			{
X+ 				term_set (ZAP,0,PPR_MAX);
X+ 				printf("%s\n",mbuf);
X+ 			}
X+ 			term_set (ONREVERSE);
X+ 			printf("%s\015",prompt);
X+ 			term_set (OFFREVERSE);
X+ 			continue;
X+ 		}
X+ 		switch (c)
X+ 		{
X  		case SETROT:
X  			term_set (ZAP,0,PPR_MAX);
X  			if (Rot == 0)
X***************
X*** 588,594
X  {
X  	for ( ; *s != '\0'; ++s)
X  	{
X! 		if (*s >= 'A' && *s <= 'Z')
X  		{
X  			*s += Rot;
X  			if (*s > 'Z')
X
X--- 608,614 -----
X  {
X  	for ( ; *s != '\0'; ++s)
X  	{
X! 		if (isupper(*s))
X  		{
X  			*s += Rot;
X  			if (!isupper(*s))
X***************
X*** 591,597
X  		if (*s >= 'A' && *s <= 'Z')
X  		{
X  			*s += Rot;
X! 			if (*s > 'Z')
X  				*s -= 26;
X  			continue;
X  		}
X
X--- 611,617 -----
X  		if (isupper(*s))
X  		{
X  			*s += Rot;
X! 			if (!isupper(*s))
X  				*s -= 26;
X  			continue;
X  		}
X***************
X*** 595,601
X  				*s -= 26;
X  			continue;
X  		}
X! 		if (*s >= 'a' && *s <= 'z')
X  		{
X  			*s += Rot;
X  			if (*s > 'z')
X
X--- 615,621 -----
X  				*s -= 26;
X  			continue;
X  		}
X! 		if (islower(*s))
X  		{
X  			*s += Rot;
X  			if (!islower(*s))
X***************
X*** 598,604
X  		if (*s >= 'a' && *s <= 'z')
X  		{
X  			*s += Rot;
X! 			if (*s > 'z')
X  				*s -= 26;
X  		}
X  	}
X
X--- 618,624 -----
X  		if (islower(*s))
X  		{
X  			*s += Rot;
X! 			if (!islower(*s))
X  				*s -= 26;
X  		}
X  	}
X***************
X*** 615,621
X  **	bell - pass through with zero width
X  **	newline - end of record.
X  **	del - turns into '_'
X! **	other control - 'A' - 1 added ('01' = ctl-A).  Makes escape = "[".
X  **		(prevents "letter bombs" containing inappropriate control
X  **			sequences for the terminal).
X  **
X
X--- 635,641 -----
X  **	bell - pass through with zero width
X  **	newline - end of record.
X  **	del - turns into '_'
X! **	other control - turned into '?'
X  **		(prevents "letter bombs" containing inappropriate control
X  **			sequences for the terminal).
X  **
X***************
X*** 670,677
X  				++len;
X  				break;
X  			default:
X! 				if (*s < ' ')
X! 					*s += 'A' - 1;
X  				++len;		/* fall through */
X  			case '\07':
X  				break;
X
X--- 690,697 -----
X  				++len;
X  				break;
X  			default:
X!  				if (iscntrl(*s))
X! 					*s = '?';
X  				++len;		/* fall through */
X  			case '\07':
X  				break;
X===================================================================
XRCS file: RCS/server.doc,v
Xretrieving revision 6.0
Xdiff -c -r6.0 server.doc
X*** /tmp/,RCSt1029201	Sat May 28 13:08:08 1988
X--- server.doc	Tue Apr 12 11:44:47 1988
X***************
X*** 15,29
X  		interact with the user prior to editing the reply file
X  		on mail replies.  See vns_aopen().
X  
X- 	(*Headedit)()
X- 
X- 		If set, will be called instead of the default action when
X- 		the user chooses the "toggle header flag" command.  This
X- 		is intended to allow the server interface to implement a
X- 		user selection of which headers to display when reading
X- 		an article.  If this is set, note that the reader code will
X- 		never rewind an article past the point set by vns_aopen().
X- 
X  	(*Postfunc)(hdr,fn)
X  	(*Mailfunc)(hdr,fn)
X  	ARTHEADER *hdr;
X
X--- 15,20 -----
X  		interact with the user prior to editing the reply file
X  		on mail replies.  See vns_aopen().
X  
X  	(*Postfunc)(hdr,fn)
X  	(*Mailfunc)(hdr,fn)
X  	ARTHEADER *hdr;
X***************
X*** 37,42
X  		well set up postcmd / mailcmd, and let vn do it.  fn is
X  		the name of a file containing the user's article or mail
X  		reply.
X  
X  	All of the procedures will be called with the user's terminal in
X  	raw mode and will be expected to leave it that way on return.
X
X--- 28,167 -----
X  		well set up postcmd / mailcmd, and let vn do it.  fn is
X  		the name of a file containing the user's article or mail
X  		reply.
X+ 
X+ 	FILE *(*Saveopen)(fn,msg,mode)
X+ 	char *fn;
X+ 	char *msg,
X+ 	char **mode;
X+ 
X+ 		If set, this function allows the server interface to
X+ 		implement its own semantics for the savefile string
X+ 		typed by the user.  It should return an open file
X+ 		pointer, NULL for failure.  msg is a message buffer
X+ 		which will be displayed to the user, replacing the
X+ 		normal "can't open ..." or "appended|created ..."
X+ 		messages.  It MUST be filled in.  mode is a returned
X+ 		pointer to the mode the file was opened with, and
X+ 		will only really be used to pass on to vns_asave(),
X+ 		so it may not really matter.  If untouched, it will
X+ 		be "a".  Note that if this function is defined, the
X+ 		user still can specify a pipe by typing "|<stuff>", but
X+ 		all other interpretation of the savefile string such as
X+ 		expansion of tildes becomes the responsibility of this
X+ 		routine.  This is really intended as the hook to hang
X+ 		something like the concept of "mail-folders" from.
X+ 
X+ 	(*Digsaver)(x,fp,count,name,mode)
X+ 	char *x;
X+ 	FILE *fp;
X+ 	int count;
X+ 	char *name;
X+ 	char *mode;
X+ 
X+ 		If defined, this will be use to save digest extraction
X+ 		articles.  For digest extractions, this will be called
X+ 		instead of vns_asave, and will have to be defined to
X+ 		perform any special massaging similar to vns_asave if
X+ 		the features are expected to work for digest extractions.
X+ 		If not defined, vn will simply shovel digest extractions
X+ 		out to fp with no massaging.  x is the name of a temporary
X+ 		file containing the extracted "article", the other arguments
X+ 		are as for vns_asave.
X+ 
X+ 	char (*Marker)(group,art,oldmark,userkey)
X+ 	NODE *group;
X+ 	int art;
X+ 	char oldmark;
X+ 	char userkey;
X+ 
X+ 		This allows the server interface access to user mark
X+ 		operations.  If defined, it will be called whenever the
X+ 		user marks an article.  It returns the new mark to be
X+ 		placed on the article, which should be a printable
X+ 		character.  The space character is to be used to mean
X+ 		that the article is unmarked.  This is the intended hook
X+ 		to allow the server interface to implement any special
X+ 		actions based on the user marks, such as retention of
X+ 		marked articles when vns_write() is called.  The user
X+ 		will still print/save/read all marked articles by
X+ 		specifying "*", whatever the actual mark returned by
X+ 		this routine, "marked" meaning marked with something
X+ 		other than <space>.  Userkey is the character entered
X+ 		by the user which resulted in the mark action ('x', '^x',
X+ 		'X' or '*').  Remember that 'X' means "unmark".
X+ 
X+ 	(*Hookfunc)(key,reader,go,msg)
X+ 	char key;
X+ 	int reader;
X+ 	int go;
X+ 	char *msg;
X+ 
X+ 		This allows the vns_ layer to hook arbitrary commands
X+ 		into the vn interaction.  If defined, this will be called
X+ 		with every user command key.  reader will be TRUE if called
X+ 		from reading interaction, FALSE if called from page.
X+ 
X+ 		Since this will be called with EVERY user command key, if
X+ 		defined, it is very important that it return <0 for all
X+ 		unrecognized keys, or vn won't be able to do anything.
X+ 
X+ 		Attempts to define most control keys as commands will be
X+ 		ineffective from the reader - they simply will not
X+ 		reach Hookfunc.  They are OK from the page display.
X+ 		You may not use <escape> or numeric characters as commands.
X+ 
X+ 		If go is FALSE, msg argument should not be used, and no
X+ 		real action should be taken.  In this case, the routine
X+ 		should return >= 0 if the key is an additional command,
X+ 		< 0 otherwise.  This is the call vn may make to see if
X+ 		the vns_ layer has a use for a key, without wanting to
X+ 		really invoke that action.
X+ 
X+ 		If go is TRUE, the action is actually to be taken, if
X+ 		applicable.  Return < 0 for undefined key.  If it returns 0,
X+ 		this indicates that the procedure did nothing to the screen,
X+ 		and msg MUST be filled in with a message to display.  This
X+ 		is the way to implement a simple toggle.  If interaction
X+ 		with the user is desired, this routine should call
X+ 		term_set(ERASE), which clears the screen, and return
X+ 		> 0 after performing the interaction.  It should leave
X+ 		the cursor in the desired screen location for continuation
X+ 		when called while reading an article.
X+ 
X+ 		This hook can be used to implement user interaction for
X+ 		any purpose which is server specific.  The one currently
X+ 		being contemplated is control of the way in which articles
X+ 		are saved in files (mailbox format feature).
X+ 
X+ 		Another which suggests itself is allowing the edit of
X+ 		which header lines to display.  In this case, it is OK
X+ 		to take "h" key which only handles this function in a
X+ 		rudimentary fashion.  If this is done, be sure to take
X+ 		the key BOTH on the page display and in the reader - vn
X+ 		will never rewind an article past the point returned by
X+ 		vns_aopen if this is done.
X+ 
X+ 	char *
X+ 	(*Hookhelp)(reader,first,key)
X+ 	int reader, first;
X+ 	char *key;
X+ 
X+ 		This allows help messages for the commands set by Hookfunc,
X+ 		to be shown.  reader is TRUE if from reading an article,
X+ 		FALSE if from page.  first is set TRUE to start list.
X+ 		returns help message, and places corresponding key character
X+ 		in key.  vn will keep calling with first = FALSE until
X+ 		a NULL return indicates the end of the list.
X+ 
X+ 		Note that command keys defined by vns_ layer may be
X+ 		translated via a user .vnkeys file just like the other
X+ 		commands.  These routines work strictly in terms of the
X+ 		translated keys - vn will handle translating back to
X+ 		the users keys for the help display.
X+ 
X+ 		If you define a key already used by vn, it works, but
X+ 		is obviously not a good practice.  Only the "quit" key from
X+ 		the page display can't be superceded.
X  
X  	All of the procedures will be called with the user's terminal in
X  	raw mode and will be expected to leave it that way on return.
X===================================================================
XRCS file: RCS/session.c,v
Xretrieving revision 6.0
Xdiff -c -r6.0 session.c
X*** /tmp/,RCSt1029201	Sat May 28 13:08:12 1988
X--- session.c	Tue Apr 12 14:42:41 1988
X***************
X*** 7,12
X  */
X  #include <stdio.h>
X  #include <setjmp.h>
X  #include "config.h"
X  #include "tty.h"
X  #include "brk.h"
X
X--- 7,13 -----
X  */
X  #include <stdio.h>
X  #include <setjmp.h>
X+ #include <ctype.h>
X  #include "config.h"
X  #include "tty.h"
X  #include "brk.h"
X***************
X*** 38,44
X  extern char *List_sep;
X  extern char *Version, *Vns_version;
X  
X! extern int (*Headedit)();
X  
X  static int C_info;
X  static int Dskip, Drec;
X
X--- 39,46 -----
X  extern char *List_sep;
X  extern char *Version, *Vns_version;
X  
X! extern char (*Marker)();
X! extern int (*Hookfunc)();
X  
X  static int C_info;
X  static int Dskip, Drec;
X***************
X*** 58,64
X  session ()
X  {
X  	char alist [RECLEN], c;
X! 	int newg, i, count;
X  	jmp_buf brkbuf;
X  
X  	newg = new_groups();
X
X--- 60,66 -----
X  session ()
X  {
X  	char alist [RECLEN], c;
X! 	int newg, i, j, count;
X  	jmp_buf brkbuf;
X  
X  	newg = new_groups();
X***************
X*** 105,110
X  	 */
X  	for (count = getkey(&c); c != QUIT; count = getkey(&c))
X  	{
X  		if ( srch_help(c,&i) != 0 || (Digest != 0 && i == 0))
X  		{
X  			preinfo (UDKFORM,Cxptoi[HELP]);
X
X--- 107,128 -----
X  	 */
X  	for (count = getkey(&c); c != QUIT; count = getkey(&c))
X  	{
X+ 		if (Hookfunc != NULL)
X+ 		{
X+ 			if ((i = (*Hookfunc)(c,0,1,alist)) >= 0)
X+ 			{
X+ 				if (i == 0)
X+ 					prinfo(alist);
X+ 				else
X+ 				{
X+ 					term_set(ERASE);
X+ 					show();
X+ 				}
X+ 				term_set (MOVE,0,Crec);
X+ 				continue;
X+ 			}
X+ 		}
X+ 
X  		if ( srch_help(c,&i) != 0 || (Digest != 0 && i == 0))
X  		{
X  			preinfo (UDKFORM,Cxptoi[HELP]);
X***************
X*** 115,128
X  		switch (c)
X  		{
X  		case HEADTOG:
X- 			if (Headedit != NULL)
X- 			{
X- 				term_set(ERASE);
X- 				(*Headedit)();
X- 				show();
X- 				term_set (MOVE,0,Crec);
X- 				break;
X- 			}
X  			if (Headflag)
X  			{
X  				Headflag = FALSE;
X
X--- 133,138 -----
X  		switch (c)
X  		{
X  		case HEADTOG:
X  			if (Headflag)
X  			{
X  				Headflag = FALSE;
X***************
X*** 237,242
X  			else
X  				putchar ('\07');
X  			break;
X  		case MARK:
X  		case ART_MARK:
X  			count += Crec - 1;
X
X--- 247,259 -----
X  			else
X  				putchar ('\07');
X  			break;
X+ 		case MARKSTRING:
X+ 			(Page.h.group)->flags |= FLG_ACC;
X+ 			userlist (alist);
X+ 			markstr (alist,c);
X+ 			term_set (MOVE, 0, Crec);
X+ 			write_page ();
X+ 			break;
X  		case MARK:
X  		case ART_MARK:
X  			genlist (alist,Crec-RECBIAS,count);
X***************
X*** 239,259
X  			break;
X  		case MARK:
X  		case ART_MARK:
X! 			count += Crec - 1;
X! 			if (count >= Highrec)
X! 				count = Highrec - 1;
X! 			for (i=Crec; i <= count; ++i)
X! 			{
X! 				if (Page.b[i-RECBIAS].art_mark != ART_MARK)
X! 					Page.b[i-RECBIAS].art_mark = ART_MARK;
X! 				else
X! 					Page.b[i-RECBIAS].art_mark = ' ';
X! 				if (i != Crec)
X! 					term_set (MOVE, 0, i);
X! 				printf ("%c\010",Page.b[i-RECBIAS].art_mark);
X! 			}
X! 			if (count != Crec)
X! 				term_set (MOVE, 0, Crec);
X  			write_page ();
X  			break;
X  		case UNMARK:
X
X--- 256,264 -----
X  			break;
X  		case MARK:
X  		case ART_MARK:
X! 			genlist (alist,Crec-RECBIAS,count);
X! 			markstr (alist,c);
X! 			term_set (MOVE, 0, Crec);
X  			write_page ();
X  			break;
X  		case UNMARK:
X***************
X*** 259,265
X  		case UNMARK:
X  			for (i=0; i < Page.h.artnum; ++i)
X  			{
X! 				if (Page.b[i].art_mark == ART_MARK)
X  				{
X  					Page.b[i].art_mark = ' ';
X  					term_set (MOVE, 0, i+RECBIAS);
X
X--- 264,270 -----
X  		case UNMARK:
X  			for (i=0; i < Page.h.artnum; ++i)
X  			{
X! 				if (Page.b[i].art_mark != ' ')
X  				{
X  					if (Marker == NULL)
X  						Page.b[i].art_mark = ' ';
X***************
X*** 261,267
X  			{
X  				if (Page.b[i].art_mark == ART_MARK)
X  				{
X! 					Page.b[i].art_mark = ' ';
X  					term_set (MOVE, 0, i+RECBIAS);
X  					putchar (' ');
X  				}
X
X--- 266,278 -----
X  			{
X  				if (Page.b[i].art_mark != ' ')
X  				{
X! 					if (Marker == NULL)
X! 						Page.b[i].art_mark = ' ';
X! 					else
X! 						Page.b[i].art_mark =
X! 						(*Marker)(Page.h.group,
X! 							Page.b[i].art_id,
X! 							Page.b[i].art_mark, c);
X  					term_set (MOVE, 0, i+RECBIAS);
X  					putchar (' ');
X  				}
X***************
X*** 278,283
X  				preinfo ("No more pages");
X  			term_set (MOVE,0,Crec);
X  			break;
X  		case DIGEST:
X  			if (Digest)
X  			{
X
X--- 289,332 -----
X  				preinfo ("No more pages");
X  			term_set (MOVE,0,Crec);
X  			break;
X+ 		case GRPBACK:
X+ 			j = (Page.h.group)->order;
X+ 			for (i = j-1; count > 0 && i >= 0; --i)
X+ 			{
X+ 				if ((Newsorder[i])->pages > 0)
X+ 				{
X+ 					j = i;
X+ 					--count;
X+ 				}
X+ 			}
X+ 			if (j == (Page.h.group)->order)
X+ 				preinfo ("No more newsgroups");
X+ 			else
X+ 			{
X+ 				forward ((Newsorder[j])->pnum - Cur_page);
X+ 				show();
X+ 			}
X+ 			term_set (MOVE,0,Crec);
X+ 			break;
X+ 		case GRPFORWARD:
X+ 			j = (Page.h.group)->order;
X+ 			for (i= j+1; count > 0 && i < Ncount; ++i)
X+ 			{
X+ 				if ((Newsorder[i])->pages > 0)
X+ 				{
X+ 					j = i;
X+ 					--count;
X+ 				}
X+ 			}
X+ 			if (j == (Page.h.group)->order)
X+ 				preinfo ("No more newsgroups");
X+ 			else
X+ 			{
X+ 				forward ((Newsorder[j])->pnum - Cur_page);
X+ 				show();
X+ 			}
X+ 			term_set (MOVE,0,Crec);
X+ 			break;
X  		case DIGEST:
X  			if (Digest)
X  			{
X***************
X*** 552,558
X  	if (*s != '\0')
X  	{
X  		tmpnam(fn);
X! 		if (art_xfer(fn,s,"w") != 0)
X  		{
X  			preinfo("Couldn't open temporary file");
X  			return;
X
X--- 601,607 -----
X  	if (*s != '\0')
X  	{
X  		tmpnam(fn);
X! 		if (art_xfer(fn,s,"w",NULL) != 0)
X  		{
X  			preinfo("Couldn't open temporary file");
X  			return;
X***************
X*** 795,800
X  char *defstr;
X  {
X  	int i,idx,len;
X  
X  	if (iline)
X  	{
X
X--- 844,850 -----
X  char *defstr;
X  {
X  	int i,idx,len;
X+ 	char c;
X  
X  	if (iline)
X  	{
X***************
X*** 811,817
X   	for (i=0; i < len; i++)
X   		s[i] = defstr[i];
X   
X! 	for (i=len; idx < C_allow && (s[i] = getchar() & 0x7f) != '\012' && s[i] != '\015'; ++i)
X  	{
X  		if (s[i] == Erasekey)
X  		{
X
X--- 861,867 -----
X   	for (i=0; i < len; i++)
X   		s[i] = defstr[i];
X   
X!  	for (i=len; idx < C_allow; ++i)
X  	{
X  		s[i] = getchar();
X  		c = s[i] & CHMASK;
X***************
X*** 813,819
X   
X  	for (i=len; idx < C_allow && (s[i] = getchar() & 0x7f) != '\012' && s[i] != '\015'; ++i)
X  	{
X! 		if (s[i] == Erasekey)
X  		{
X  			if (i > 0)
X  			{
X
X--- 863,873 -----
X   
X   	for (i=len; idx < C_allow; ++i)
X  	{
X! 		s[i] = getchar();
X! 		c = s[i] & CHMASK;
X! 		if (c == '\015' || c == '\012')
X! 			break;
X! 		if (c == Erasekey)
X  		{
X  			if (i > 0)
X  			{
X***************
X*** 825,831
X  				i = -1;
X  			continue;
X  		}
X! 		if (s[i] == Killkey)
X  		{
X   			if (iline)
X   			{
X
X--- 879,885 -----
X  				i = -1;
X  			continue;
X  		}
X! 		if (c == Killkey)
X  		{
X   			if (iline)
X   			{
X***************
X*** 843,849
X  			continue;
X  		}
X  		/* no leading spaces */
X! 		if (s[i] == ' ' && i == 0)
X  		{
X  			i = -1;
X  			putchar('\07');
X
X--- 897,903 -----
X  			continue;
X  		}
X  		/* no leading spaces */
X! 		if (c == ' ' && i == 0)
X  		{
X  			i = -1;
X  			putchar('\07');
X***************
X*** 850,856
X  			continue;
X  		}
X  		/* no controls */
X! 		if (s[i] < ' ' || s[i] == '\177')
X  		{
X  			--i;
X  			putchar('\07');
X
X--- 904,910 -----
X  			continue;
X  		}
X  		/* no controls */
X!  		if (iscntrl(c))
X  		{
X  			--i;
X  			putchar('\07');
X***************
X*** 867,873
X  
X  	s[i] = '\0';
X  }
X- 
X  /*
X  	print something on the information line,
X  	clearing any characters not overprinted.
X
X--- 921,926 -----
X  
X  	s[i] = '\0';
X  }
X  /*
X  	print something on the information line,
X  	clearing any characters not overprinted.
X***************
X*** 1027,1032
X  		{
X  			n->flags &= ~FLG_SUB;
X  			n->flags |= FLG_ECHG;
X  		}
X  	}
X  }
X
X--- 1080,1133 -----
X  		{
X  			n->flags &= ~FLG_SUB;
X  			n->flags |= FLG_ECHG;
X+ 		}
X+ 	}
X+ }
X+ 
X+ /*
X+ ** utility to mark articles.  depends on fact that article numbers are
X+ ** in ascending order on page.
X+ */
X+ static
X+ markstr (list,ckey)
X+ char *list;
X+ char ckey;
X+ {
X+ 	char *tok;
X+ 	int art, count;
X+ 	BODY *b;
X+ 
X+ 	count = 1;
X+ 	b = Page.b;
X+ 	for (tok = strtok(list,List_sep); tok != NULL;
X+ 					tok = strtok(NULL,List_sep))
X+ 	{
X+ 		art = atoi(tok);
X+ 		while (count < Page.h.artnum && b->art_id < art)
X+ 		{
X+ 			++count;
X+ 			++b;
X+ 		}
X+ 		if (b->art_id == art)
X+ 		{
X+ 			/*
X+ 			** Can't call Marker inside digests
X+ 			*/
X+ 			if (Marker == NULL || Digest)
X+ 			{
X+ 				if (b->art_mark != ART_MARK)
X+ 					b->art_mark = ART_MARK;
X+ 				else
X+ 					b->art_mark = ' ';
X+ 			}
X+ 			else
X+ 			{
X+ 				b->art_mark =
X+ 					(*Marker)(Page.h.group, art,
X+ 						b->art_mark, ckey);
X+ 			}
X+ 			term_set (MOVE, 0, count-1+RECBIAS);
X+ 			printf ("%c\010",b->art_mark);
X  		}
X  	}
X  }
X===================================================================
XRCS file: RCS/strings.c,v
Xretrieving revision 6.0
Xdiff -c -r6.0 strings.c
X*** /tmp/,RCSt1029201	Sat May 28 13:08:17 1988
X--- strings.c	Mon Apr 11 17:42:04 1988
X***************
X*** 10,16
X  #include "node.h"
X  #include "page.h"
X  
X! char *Version = "1/88";
X  
X  char *No_msg = "No articles";
X  char *Hdon_msg = "Headers being printed";
X
X--- 10,16 -----
X  #include "node.h"
X  #include "page.h"
X  
X! char *Version = "4/88";
X  
X  char *No_msg = "No articles";
X  char *Hdon_msg = "Headers being printed";
X===================================================================
XRCS file: RCS/svart.c,v
Xretrieving revision 6.0
Xdiff -c -r6.0 svart.c
X*** /tmp/,RCSt1029201	Sat May 28 13:08:18 1988
X--- svart.c	Mon Apr 11 17:42:21 1988
X***************
X*** 20,25
X  extern char *List_sep;
X  extern char *Home;
X  extern char *Savedir;
X  
X  /*
X  ** save article in file.  Called from reader and session both.
X
X--- 20,27 -----
X  extern char *List_sep;
X  extern char *Home;
X  extern char *Savedir;
X+ extern FILE *(*Saveopen)();
X+ extern int (*Digsaver)();
X  
X  /*
X  ** save article in file.  Called from reader and session both.
X***************
X*** 46,52
X  	if (*dest == '|')
X  	{
X  		tmpnam(fn);
X! 		if (art_xfer(fn,art,"w") != 0)
X  		{
X  			strcpy(msg,"Can't open temporary file");
X  			return (-1);
X
X--- 48,54 -----
X  	if (*dest == '|')
X  	{
X  		tmpnam(fn);
X! 		if (art_xfer(fn,art,"w",NULL) != 0)
X  		{
X  			strcpy(msg,"Can't open temporary file");
X  			return (-1);
X***************
X*** 59,64
X  		return (rstat);
X  	}
X  
X  	if ((colon = index(dest,':')) != NULL)
X  	{
X  		mode = dest;
X
X--- 61,69 -----
X  		return (rstat);
X  	}
X  
X+ 	if (Saveopen != NULL)
X+ 		return (art_xfer(dest,art,"a",msg));
X+ 
X  	if ((colon = index(dest,':')) != NULL)
X  	{
X  		mode = dest;
X***************
X*** 94,100
X  
X  	rstat = stat(dest,&sbuf);
X  
X! 	if (art_xfer(dest,art,mode) != 0)
X  	{
X  		sprintf(msg,"Can't open %s with mode %s",dest,mode);
X  		return(-1);
X
X--- 99,105 -----
X  
X  	rstat = stat(dest,&sbuf);
X  
X! 	if (art_xfer(dest,art,mode,msg) != 0)
X  	{
X  		sprintf(msg,"Can't open %s with mode %s",dest,mode);
X  		return(-1);
X***************
X*** 202,207
X  **
X  ** Called directly to copy a list of articles to a temp. file to
X  ** direct to printer.
X  */
X  art_xfer(fn,list,mode)
X  char *fn, *list, *mode;
X
X--- 207,219 -----
X  **
X  ** Called directly to copy a list of articles to a temp. file to
X  ** direct to printer.
X+ **
X+ ** NOTE:
X+ **	The msg argument only matters if Saveopen is not NULL.  If so, it
X+ **	is non-NULL if *Saveopen is to be called, and points to the message
X+ **	buffer.  Will be called with msg = NULL to fill temp. files rather
X+ **	than user named files.  If *Saveopen is called, mode argument is
X+ **	actually returned by it, and only matters for vns_asave call.
X  */
X  art_xfer(fn,list,mode,msg)
X  char *fn, *list, *mode, *msg;
X***************
X*** 203,210
X  ** Called directly to copy a list of articles to a temp. file to
X  ** direct to printer.
X  */
X! art_xfer(fn,list,mode)
X! char *fn, *list, *mode;
X  {
X  	char *p;
X  	FILE *fout, *fin;
X
X--- 215,222 -----
X  **	than user named files.  If *Saveopen is called, mode argument is
X  **	actually returned by it, and only matters for vns_asave call.
X  */
X! art_xfer(fn,list,mode,msg)
X! char *fn, *list, *mode, *msg;
X  {
X  	char *p;
X  	FILE *fout, *fin;
X***************
X*** 212,218
X  	char buf[RECLEN];
X  	char *strtok();
X  
X! 	if ((fout = fopen(fn,mode)) == NULL)
X  		return (-1);
X  
X  	count = 0;
X
X--- 224,234 -----
X  	char buf[RECLEN];
X  	char *strtok();
X  
X! 	if (Saveopen != NULL && msg != NULL)
X! 		fout = (*Saveopen)(fn,msg,&mode);
X! 	else
X! 		fout = fopen(fn,mode);
X! 	if (fout == NULL)
X  		return (-1);
X  
X  	count = 0;
X***************
X*** 220,225
X  	{
X  		if (Digest)
X  		{
X  			fin = fopen(p,"r");
X  			if (fin == NULL)
X  				continue;
X
X--- 236,247 -----
X  	{
X  		if (Digest)
X  		{
X+ 			if (Digsaver != NULL)
X+ 			{
X+ 				(*Digsaver)(p,fout,count,fn,mode);
X+ 				++count;
X+ 				continue;
X+ 			}
X  			fin = fopen(p,"r");
X  			if (fin == NULL)
X  				continue;
X===================================================================
XRCS file: RCS/userlist.c,v
Xretrieving revision 6.0
Xdiff -c -r6.0 userlist.c
X*** /tmp/,RCSt1029201	Sat May 28 13:08:20 1988
X--- userlist.c	Mon Apr 11 17:42:32 1988
X***************
X*** 67,73
X  		{
X  			for (i=0; i < Page.h.artnum; ++i)
X  			{
X! 				if (Page.b[i].art_mark == ART_MARK)
X  				{
X  					anum[acount] = Page.b[i].art_id;
X  					++acount;
X
X--- 67,73 -----
X  		{
X  			for (i=0; i < Page.h.artnum; ++i)
X  			{
X! 				if (Page.b[i].art_mark != ' ')
X  				{
X  					anum[acount] = Page.b[i].art_id;
X  					++acount;
X===================================================================
XRCS file: RCS/vn.c,v
Xretrieving revision 6.0
Xdiff -c -r6.0 vn.c
X*** /tmp/,RCSt1029201	Sat May 28 13:08:23 1988
X--- vn.c	Mon Apr 11 17:42:47 1988
X***************
X*** 187,192
X  		from Greg Earle, earle@mahendo.  Modified slightly for
X  		cosmetic reasons & to fix a small folded-line bug.
X  
X  Known bugs:
X  
X  	If your terminal init string contains a newline, I suspect you will
X
X--- 187,225 -----
X  		from Greg Earle, earle@mahendo.  Modified slightly for
X  		cosmetic reasons & to fix a small folded-line bug.
X  
X+ 	2/88 (bobm)
X+ 
X+ 		Put mode on open() call in temp_open, as per bug fix from
X+ 		Don Craig.  This has been working this way a long time on
X+ 		a lot of systems (the file is unlinked after creation, so
X+ 		the actual mode doesn't really matter, and as long as your
X+ 		open call doesn't check the unused bits a random argument
X+ 		works), but it was wrong, anyway.
X+ 
X+ 	4/88 (bobm)
X+ 
X+ 		Change server interface a bit to allow more control over
X+ 		saving features, and provide a more generalized interface
X+ 		for the vns_ routines to hang interactive hooks from.
X+ 		Allow vns_ layer knowledge of marks.  These changes
X+ 		should allow future implementation of selective lists,
X+ 		use of the interface for a mailer, extra functionality
X+ 		add-on at the vns level, etc.
X+ 
X+ 		incorporate changes to allow 8 bit intl. character set
X+ 		in user strings - came from Marius Olafsson, marius@rhi.
X+ 		Also made 0x7f a #define'ed mask in case you should want
X+ 		to try allowing 8 bit command chars.
X+ 
X+ 		Jay Maynard, splut!jay pointed out that the percentage
X+ 		calculation in reader overflowed for a 327+ line article
X+ 		on a 16 bit machine, and sent fix.
X+ 
X+ 		std.c - fix "all.all" bug (any newsgroup names with
X+ 		multiple "all"'s in them incorrectly converted into RE's
X+ 		which would match practically nothing).  Up vns_Version
X+ 		stamp to 1.2.
X+ 
X  Known bugs:
X  
X  	If your terminal init string contains a newline, I suspect you will
X***************
X*** 214,219
X  
X  	crash due to embedding $\(\) type substring specifiers in regular
X  	expressions.  Obscure and hard to fix in a proper and portable way.
X  */
X  #include <stdio.h>
X  #include "node.h"
X
X--- 247,256 -----
X  
X  	crash due to embedding $\(\) type substring specifiers in regular
X  	expressions.  Obscure and hard to fix in a proper and portable way.
X+ 
X+ 	Spool numbers are kept in int, not long - it would take quite
X+ 	a bit of scrubbing through the code to root out this 32-bit'ism.
X+ 	I wish I had typedef'ed the things.
X  */
X  #include <stdio.h>
X  #include "node.h"
X===================================================================
XRCS file: RCS/vn.h,v
Xretrieving revision 6.0
Xdiff -c -r6.0 vn.h
X*** /tmp/,RCSt1029201	Sat May 28 13:08:25 1988
X--- vn.h	Mon Apr 11 17:35:48 1988
X***************
X*** 15,21
X  #define ART_UNWRITTEN ' '
X  
X  
X- #define ANFORM ":%s - %c for help:\n"
X  #define ANFLINES 1
X  #define UDKFORM "undefined key - %c for help"
X  #define HELPFORM "%c for help"
X
X--- 15,20 -----
X  #define ART_UNWRITTEN ' '
X  
X  
X  #define ANFLINES 1
X  #define UDKFORM "undefined key - %c for help"
X  #define HELPFORM "%c for help"
X***************
X*** 31,36
X  #define DOWN 'j'
X  #define FORWARD '\012'
X  #define BACK '\010'
X  #define READ 'r'
X  #define ALTREAD ' '
X  #define READALL 'R'
X
X--- 30,37 -----
X  #define DOWN 'j'
X  #define FORWARD '\012'
X  #define BACK '\010'
X+ #define GRPFORWARD '>'
X+ #define GRPBACK '<'
X  #define READ 'r'
X  #define ALTREAD ' '
X  #define READALL 'R'
X***************
X*** 44,49
X  #define PRINTSTRING '\020'
X  #define MARK 'x'
X  #define UNMARK 'X'
X  #define REDRAW '\014'
X  #define QUIT 'q'
X  #define SSTAT '#'
X
X--- 45,51 -----
X  #define PRINTSTRING '\020'
X  #define MARK 'x'
X  #define UNMARK 'X'
X+ #define MARKSTRING '\030'
X  #define REDRAW '\014'
X  #define QUIT 'q'
X  #define SSTAT '#'
X===================================================================
XRCS file: RCS/vnglob.c,v
Xretrieving revision 6.0
Xdiff -c -r6.0 vnglob.c
X*** /tmp/,RCSt1029201	Sat May 28 13:08:28 1988
X--- vnglob.c	Tue Apr 12 14:43:01 1988
X***************
X*** 21,27
X  char *Editor, *Ps1, *Printer;
X  
X  int (*Massage)() = NULL;
X- int (*Headedit)() = NULL;
X  int (*Postfunc)() = NULL;
X  int (*Mailfunc)() = NULL;
X  
X
X--- 21,26 -----
X  char *Editor, *Ps1, *Printer;
X  
X  int (*Massage)() = NULL;
X  int (*Postfunc)() = NULL;
X  int (*Mailfunc)() = NULL;
X  char (*Marker)() = NULL;
X***************
X*** 24,29
X  int (*Headedit)() = NULL;
X  int (*Postfunc)() = NULL;
X  int (*Mailfunc)() = NULL;
X  
X  char Erasekey, Killkey;		/* user keys from stty */
X  char *Orgdir;			/* .newsrc file, and original pwd */
X
X--- 23,33 -----
X  int (*Massage)() = NULL;
X  int (*Postfunc)() = NULL;
X  int (*Mailfunc)() = NULL;
X+ char (*Marker)() = NULL;
X+ int (*Hookfunc)() = NULL;
X+ char *(*Hookhelp)() = NULL;
X+ FILE *(*Saveopen)() = NULL;
X+ int (*Digsaver)() = NULL;
X  
X  char Erasekey, Killkey;		/* user keys from stty */
X  char *Orgdir;			/* .newsrc file, and original pwd */
X***************
X*** 41,47
X  char *Ku, *Kd, *Kl, *Kr;	/* Cursor movement capabilities */
X  
X  /* character translation arrays for commands */
X! char Cxitop[128], Cxitor[128], Cxrtoi[128], Cxptoi[128];
X  
X  /*
X  	cur_page - current page displayed;
X
X--- 45,51 -----
X  char *Ku, *Kd, *Kl, *Kr;	/* Cursor movement capabilities */
X  
X  /* character translation arrays for commands */
X! char Cxitop[CHMASK+1], Cxitor[CHMASK+1], Cxrtoi[CHMASK+1], Cxptoi[CHMASK+1];
X  
X  /*
X  	cur_page - current page displayed;
X
X
END_OF_FILE
if test 42380 -ne `wc -c <'patch1'`; then
    echo shar: \"'patch1'\" unpacked with wrong size!
fi
# end of 'patch1'
fi
echo shar: End of shell archive.
exit 0
