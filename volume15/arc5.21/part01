Subject:  v15i077:  ARC (PC compression program), v5.21, Part01/05
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: hyc@math.lsa.umich.edu
Posting-number: Volume 15, Issue 77
Archive-name: arc5.21/part01

[  Howard Chu did a lot of work cleaning this up, porting it, and in
   general making it reasonable.  Some work will be needed for SystemV;
   I mailed Howard a copy of the missing routines, so perhaps whoever
   gets to him first will be able to get it from him.  John Gilmore
   made a tremendous effort in contacting Thom Henderson and figuring
   out what the legal obligations are to post this as NON SHAREWARE
   to Usenet.  Please take note of those two words:   ^^^ ^^^^^^^^^.
   Thanks to both of them (Howard and John, not the words :-).  --r$ ]

#--------------------------------CUT HERE-------------------------------------
#! /bin/sh
#
# This is a shell archive.  Save this into a file, edit it
# and delete all lines above this comment.  Then give this
# file to sh by executing the command "sh file".  The files
# will be extracted into the current directory owned by
# you with default permissions.
#
# The files contained herein are:
#
# -rw-r--r--  1 hyc          2269 Jun 18 03:39 Read.me
# -rw-rw-rw-  1 hyc          4064 Jun 13 04:32 Readme.too
# -rw-r--r--  1 hyc          2413 Jun 18 03:42 Manifest
# -rw-r--r--  1 hyc          1323 Jun  2 00:43 Make.tws
# -rw-r--r--  1 hyc          2644 Jun 18 03:36 Makefile
# -rw-r--r--  1 hyc          1892 May 14  1987 Changes.521
# -rw-r--r--  1 hyc          5577 Apr 11 19:15 Arcinfo
# -rw-r--r--  1 hyc         18327 Jun 13 04:09 Sysvarcstuf
# -rw-r--r--  1 hyc          2985 Jun 13 13:40 tws.h
#
echo 'x - Read.me'
if test -f Read.me; then echo 'shar: not overwriting Read.me'; else
sed 's/^X//' << '________This_Is_The_END________' > Read.me
XHello again,
X	herein you should be pleased to find the complete sources for the
Xlatest and greatest version of ARC, based on the sources for version 5.21
Xof the MSDOS ARC program. The patches to the previous release, 5.12, with
Xsquashing algorithm, have also been applied here. The code is known to
Xwork on a Sun 3 running SunOS 3.4, Apollo DN3000 running SR9.7 DOMAIN/IX,
XVax 750 running 4.3BSD, and IBM 3090 running MTS. It is also now working
Xon Atari STs, as well as Apollo DN3000 running SR10 DOMAIN/OS (Beta).
X
X	Also included is a detailed description of the format of a .ARC
Xfile directory entry, in the file named Arcinfo. Could be useful if you're
Xtrying to port ARC to any more esoteric systems...
X
X	Jon Zeeff has sent along some code he used to get this working on
XSys V style machines. Looks like scandir is all that's really missing. I
Xhaven't tried any of it out for myself yet, but the code is in the file
X"Sysvarcstuf" should you need it.
X
X	One final necessary inclusion: sources for libtws.a, which was
Xposted a long time ago to mod.sources as part of a package he called
X"phoon" - a program that calculated and displayed the PHase of the mOON.
XThe only thing I use the time routines for here is to convert an expanded
Xdate/time back into a Unix style time value, for keeping file modification
Xtimes straight.
X
X	Thanks to Leo Wilson (leo@cs.buffalo.edu) for sending his copy of
Xa man page for ARC. I've updated it for this version, and included it here
Xas well.
X
X	The default value of the (I)mage mode flag has changed. ARC will
Xnow treat files as binary files, unless the 'i' flag is given. Handling of
XCarriage Returns has been improved a bit. ARC is now a little smarter about
Xtemporary files as well.
X
XTo compile all this stuff... Edit Make.tws (shouldn't need to change anything
Xhere, really.) Edit arc.h. After that, just type make and wait a while...
X(Oh yeah - there's a few makefile macros that need redefining for Atari ST...)
XOk... Well, I've had this for a while, and it works for me, but if somehow
XI've goofed, let me know.
X	
X  /
X /_ , ,_.                      Howard Chu
X/ /(_/(__                University of Michigan
X    /           Computing Center          College of LS&A
X   '              Unix Project          Information Systems
________This_Is_The_END________
if test `wc -c < Read.me` -ne     2269; then
	echo 'shar: Read.me was damaged during transit (should have been     2269 bytes)'
fi
fi		; : end of overwriting check
echo 'x - Readme.too'
if test -f Readme.too; then echo 'shar: not overwriting Readme.too'; else
sed 's/^X//' << '________This_Is_The_END________' > Readme.too
XNotes for ARC 5.21                                        June 6, 1988
X 
XThis program is based on the MSDOS ARC program, version 5.21, plus
Xa few enhancements... 
X 
X o ARC also performs Huffman Squeezing on data. The Huffman Squeeze
X   algorithm was removed from MSDOS ARC after version 5.12. It turns
X   out to be more efficient than Lempel-Ziv style compression when
X   compressing graphic images. Squeeze analysis is always done now,
X   and the best of packing, squeezing, or crunching is used.
X 
X o Compresses and extracts Squashed files. "Squashing" was created
X   by Phil Katz in his PKxxx series of ARC utility programs for
X   MSDOS. Dan Lanciani wrote the original modifications to ARC's
X   Crunch code to handle Squashing. I've made minor changes since
X   then, mostly to reduce the amount of memory required. The 'q'
X   option flag must be specified to Squash files. The Squashing
X   algorithm will be used instead of the usual Crunch algorithm,
X   and will be compared against packing and squeezing, as before.
X 
XSystem specific notes:
X 
X   On MTS, an additional option flag, 'i' for "image mode," was
Xused. ARC assumes files are text, by default, and will translate
XMTS files from EBCDIC to ASCII before storing in an archive, and
Xtranslates from ASCII to EBCDIC upon extraction. Specifying the
X'i' flag will inhibit this translation. This would most commonly
Xbe used when shipping binary images such as TeX DVI files, other
X.ARC files stored within an archive, etc... The 'r' (run) command
Xis omitted. It just doesn't seem very useful. Also, ARC cannot
Xrestore MTS files with their original time stamps. (Maybe in a
Xfuture release...)
X 
X   On Unix(tm) systems, the 'i' flag is also present. Unix ARC
Xassumes a binary file, by default. Here the only translation
Xinvolved is in end-of-line processing. When storing text files, ARC will
Xchange '\n' to '\r\n', and does the opposite when extracting files.
XCarriage returns in any other location are preserved when extracting.
XThis translation only occurs if the 'i' flag is given.
X
X   On the Atari ST, the 'h' (for "hold screen") option is present,
Xwhich simply delays exiting the program. This is typically used when
Xexecuting ARC from the desktop, to allow reading all of ARC's output
Xbefore the screen is cleared and the desktop is redrawn. The program
Xwill prompt and wait for a keypress before exiting. Note that since
Xthere are no "options" for the MARC program, the "hold screen" option
Xis always active for MARC.
X 
X   On both Unix and Atari systems, ARC & MARC will search for an
Xenvironment variable named "ARCTEMP" or "TMPDIR." If present, any
Xtemporary files will be created in the specified directory. This is
Xprobably insignificant for Unix users, but can be handy on the Atari,
Xin combination with a RAMdisk. Highly recommended for floppy users.
X(Unfortunately, you can only take advantage of this when running some
Xform of command shell that allows setting environment variables. Thus,
Xyou won't see any speed gains when running from the desktop.)
X 
X 
XThat about covers things. The enclosed documentation is taken directly
Xfrom the MSDOS distribution of ARC. Unless specified differently here,
Xthe programs behave indentically. Note that ARC521.DOC is identical to
XARC520.DOC - the differences between the two versions are described in
Xthe file CHANGES.521.
X 
XOh yeah - this program may be distributed freely so long as you don't
Xmodify it in any way. You may not charge for distributing it. (Don't
Xfeel bad, I can't charge for it either. }-) It'd be nice if you kept
Xthis and the other enclosed doc files with it when distributing, but
XI'm not going to make a fuss about it. Most people are so familiar
Xwith the program by now that it wouldn't matter much anyway. You
Xshould keep this README file around, so bug reports & such will find
Xtheir way back to me. (Bugs? What bugs? Nah, there aren't any bugs...)
X 
X         /                 Howard Chu
X   ___  /_ , ,_.     University of Michigan
X       / /(_/(__     hyc@umix.cc.umich.edu
X           /                umix!hyc
X          '     
________This_Is_The_END________
if test `wc -c < Readme.too` -ne     4064; then
	echo 'shar: Readme.too was damaged during transit (should have been     4064 bytes)'
fi
fi		; : end of overwriting check
echo 'x - Manifest'
if test -f Manifest; then echo 'shar: not overwriting Manifest'; else
sed 's/^X//' << '________This_Is_The_END________' > Manifest
XContents of this distribution....
X   5577 Apr 11 19:15 Arcinfo	   Description of .ARC file format
X  54144 Jun 13 05:26 Arc521.doc	   Full program documentation, no CRs.
X   1892 May 14  1987 Changes.521   Differences between 5.20 and 5.21
X   1323 Apr 11 19:10 Make.tws	   Makefile for the time routine library
X   1731 Jun 13 03:58 Makefile	   Makefile for ARC
X   2413 Jun 13 05:29 Manifest	   This file
X   2269 Jun 18 03:39 Read.me	   Spiel
X   2190 Jun 13 04:23 Readme.too	   More spiel
X  18327 Jun 13 04:09 Sysvarcstuf   Useful for Sys V users.
X   7232 Jun 12 19:31 arc.1	   A man page, *roff source
X  11116 Jun 13 04:27 arc.c	   Main routine, option parser...
X   3318 Jun  1 19:59 arc.h	   System dependencies, externs
X   9286 Jun 13 00:31 arcadd.c	   Top level routine for adding to archive
X   1204 Jun  1 15:16 arccode.c	   Code for file encryption/decryption
X   3396 Jun  1 19:18 arccvt.c	   Convert to new packing method
X   2070 Jun 13 04:26 arcdata.c	   Declarations of externs from arc.h
X   2055 Apr 19 01:39 arcdel.c	   Delete files from archive
X   4970 Jun 13 00:41 arcdos.c	   OS specific file management routines
X   4897 Jun  1 20:18 arcext.c	   Top level routine for extraction
X   7384 Jun  2 16:27 arcio.c	   OS specific low-level I/O routines
X   4418 Jun  1 18:06 arclst.c	   List contents of archive
X  22109 Jun  1 20:01 arclzw.c	   Low-level Lempel-Zev compression
X   3026 Jun  1 19:41 arcmatch.c	   Pattern matching routines
X   8319 Jun 13 04:07 arcmisc.c	   OS specific miscellaneous functions
X   7376 Jun  2 16:27 arcpack.c	   Mid-level compression code
X   3838 Jun  1 19:57 arcrun.c	   Run files from archive
X   1645 Apr 17 18:53 arcs.h	   Declaration of .ARC header format
X  14613 Jun  2 16:27 arcsq.c	   Low-level Huffman Squeeze code
X  11587 Jun  1 20:02 arcsqs.c	   Low-level Squash code
X   4680 Jun 13 00:43 arcsvc.c	   .ARC file utilities
X   1284 Apr 19 01:40 arctst.c	   Test archive integrity
X   5325 Jun  7 03:16 arcunp.c	   Mid-level extraction code
X   2484 Jun  2 16:28 arcusq.c	   Low-level Huffman unSqueezer
X   9035 Apr 11 19:10 dtime.c	   sources for the time routine library...
X   7327 Apr 11 19:11 dtimep.lex
X    356 Apr 11 19:12 lexedit.sed
X   3765 Apr 11 19:12 lexstring.c
X   2241 Apr 11 19:13 libtws.3	   man page for the time routine library
X   9053 Jun  6 01:04 marc.c	   source for the marc program
X   2993 Jun  2 00:38 tws.h	   header file for the time routine library
________This_Is_The_END________
if test `wc -c < Manifest` -ne     2413; then
	echo 'shar: Manifest was damaged during transit (should have been     2413 bytes)'
fi
fi		; : end of overwriting check
echo 'x - Make.tws'
if test -f Make.tws; then echo 'shar: not overwriting Make.tws'; else
sed 's/^X//' << '________This_Is_The_END________' > Make.tws
X# Makefile for phoon, deltime, parsetime, and libtws (stolen from mh).
X
X# Valid options:
X#   BSD42      Set this if your system is BSD 4.2 or later.
X#   SYS5       Set this if your system is System V.
X#   EUROPE     Makes nn/nn/nn mean dd/mm/yy instead of mm/dd/yy.
X#   ATZ        This has something to do with alpha-numeric time zones.
X#   DSTXXX     This has something to do with daylight savings time.
X#   HUJI       I don't
X#   INETONLY           know what
X#   LEXDEBUG                     the rest of these
X#   ONECASE                                        do.
X#
X# Original posted to mod.sources by Jef Poskanzer. Cannibalized for use
X# with ARC by Howard Chu.
XOPTIONS	=	-DBSD42 -DATZ -DDSTXXX -DONECASE
X
X
XCC      =	cc
XCFLAGS  =	-O $(OPTIONS)
XLDFLAGS =	-ns
X
Xlibtws.a:	dtime.o dtimep.o lexstring.o
X		ar r libtws.a dtime.o dtimep.o lexstring.o
X# The following amusing bullshit makes sure that ranlib
X# gets executed if it is present, no matter which shell
X# make uses.  If there's a better way to do this, someone
X# please tell me!
X		-if test -r /usr/bin/ranlib ; then ranlib libtws.a ; fi
X		-if ( -r /usr/bin/ranlib ) ranlib libtws.a
X
Xdtime.o:	dtime.c tws.h
X
Xdtimep.o:	dtimep.c tws.h
X
Xdtimep.c:	dtimep.lex
X		lex -nt dtimep.lex | sed -f lexedit.sed > dtimep.c
X
Xlexstring.o:	lexstring.c
X		$(CC) $(CFLAGS) -c lexstring.c
________This_Is_The_END________
if test `wc -c < Make.tws` -ne     1323; then
	echo 'shar: Make.tws was damaged during transit (should have been     1323 bytes)'
fi
fi		; : end of overwriting check
echo 'x - Makefile'
if test -f Makefile; then echo 'shar: not overwriting Makefile'; else
sed 's/^X//' << '________This_Is_The_END________' > Makefile
X#
X#       Makefile for Hack-attack 1.3
X#       VAX 11/780 BSD4.2 "ARC" utility
X#
X# Originals from Dan Lanciani, James Turner, and others...
X#
X# Modified to support squashing, also added targets for the time routine
X# library.  -- Howard Chu, hyc@umix.cc.umich.edu, 4-11-88
X#
X# I put SRCDIR on a real disk on the ST, but copy the makefile to a
X# RAMdisk and compile from there. Makes things go a bit quicker...
X# This has to be done in the shell, to get the trailing backslash
X# specified correctly. e.g., setenv SRCDIR='d:\src\arc\'
XSRCDIR = 
X
XHEADER = $(SRCDIR)arc.h
X
X# Add a ".TTP" suffix to the executable files on an ST.
X#PROG = .ttp
XPROG =
X
X# TWSLIB is only needed on Unix systems. Likewise for TWHEAD.
X#TWSLIB =
X#TWHEAD =
XTWSLIB = libtws.a
XTWHEAD = tws.h
X
X# For MWC 3.0 on the Atari ST, use:
X#CFLAGS = -VCOMPAC -VPEEP
XCFLAGS = -O
X
XOBJS = arc.o arcadd.o arccode.o arccvt.o arcdata.o arcdel.o arcdos.o \
Xarcext.o arcio.o arclst.o arclzw.o arcmatch.o arcpack.o arcrun.o \
Xarcsq.o arcsqs.o arcsvc.o arctst.o arcunp.o arcusq.o arcmisc.o
X
XMOBJ = marc.o arcdata.o arcdos.o arcio.o arcmatch.o arcmisc.o
X
Xarc$(PROG):	$(OBJS) $(TWSLIB)
X	cc -o arc$(PROG) $(OBJS) $(TWSLIB)
X
Xmarc$(PROG):	$(MOBJ) $(TWSLIB)
X	cc -o marc$(PROG) $(MOBJ) $(TWSLIB)
X
Xclean:
X	-rm *.o arc$(PROG) marc$(PROG) $(TWSLIB)
X
X$(HEADER):	$(SRCDIR)arcs.h
X	touch $(HEADER)
X
Xarc.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arc.c
Xmarc.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)marc.c
Xarcadd.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcadd.c
Xarccode.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arccode.c
Xarccvt.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arccvt.c
Xarcdata.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcdata.c
Xarcdel.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcdel.c
Xarcdir.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcdir.c
Xarcdos.o:	$(HEADER) $(TWHEAD)
X	cc $(CFLAGS) -c $(SRCDIR)arcdos.c
Xarcext.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcext.c
Xarcio.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcio.c
Xarclst.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arclst.c
Xarclzw.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arclzw.c
Xarcmatch.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcmatch.c
Xarcmisc.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcmisc.c
Xarcpack.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcpack.c
Xarcrun.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcrun.c
Xarcsq.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcsq.c
Xarcsqs.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcsqs.c
Xarcsvc.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcsvc.c
Xarctst.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arctst.c
Xarcunp.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcunp.c
Xarcusq.o:	$(HEADER)
X	cc $(CFLAGS) -c $(SRCDIR)arcusq.c
X
Xlibtws.a:
X	make -f Make.tws libtws.a
________This_Is_The_END________
if test `wc -c < Makefile` -ne     2644; then
	echo 'shar: Makefile was damaged during transit (should have been     2644 bytes)'
fi
fi		; : end of overwriting check
echo 'x - Changes.521'
if test -f Changes.521; then echo 'shar: not overwriting Changes.521'; else
sed 's/^X//' << '________This_Is_The_END________' > Changes.521
X                        CHANGES IN VERSION 5.21
X
X
XThe following changes have been made in ARC version 5.21, but have not
Xyet been included in the manual:
X
Xo   When adding files to an archive, ARC now shows the stowage facter
X    achieved on each file.
X
Xo   A bug was found that would keep an archive entry from being
X    encrypted if it was stored without compression.  This has now been
X    fixed.
X
Xo   If changes are made to a corrupted archive, the corrupted entries
X    are discarded.  This makes it possible to lose data accidentally.
X    ARC will now only make changes to a corrupted archive if the W
X    (suppress Warnings) option has been given.
X
Xo   The N (suppress Notes) option now suppresses the "Creating
X    archive" note when a new archive is being created.
X
Xo   The N (suppress Notes) option formerly did nothing useful when
X    used with the L (List files) command.  It now causes a terse
X    listing of filenames only, suitable for use with pipes and
X    redirection.
X
Xo   The list of filenames given to ARC may now include indirect
X    references.  If a filename begins with an "at sign" ("@"), it is
X    taken to be the name of a file which contains a list of file
X    names.  The list of file names may include further indirection.
X    If no extension is given, ".CMD" is assumed.  For example, the
X    command:
X
X         arc a waste junk.txt @trash
X
X    would cause ARC to add JUNK.TXT plus all files listed in the file
X    TRASH.CMD to an archive named WASTE.ARC.  If no file is specified,
X    then the list is read from standard input.  For example, the
X    command:
X
X         arc ln waste | arc a trash @
X
X    would cause ARC to add files to TRASH.ARC based on the names of
X    the files stored in WASTE.ARC.  It is probably a good idea to give
X    the O (Overwrite) option if you are extracting files this way.
X
X    Version 5.21 of MARC also allows for indirection.
________This_Is_The_END________
if test `wc -c < Changes.521` -ne     1892; then
	echo 'shar: Changes.521 was damaged during transit (should have been     1892 bytes)'
fi
fi		; : end of overwriting check
echo 'x - Arcinfo'
if test -f Arcinfo; then echo 'shar: not overwriting Arcinfo'; else
sed 's/^X//' << '________This_Is_The_END________' > Arcinfo
X
XARC-FILE.INF, created by Keith Petersen, W8SDZ, 21-Sep-86, extracted
Xfrom UNARC.INF by Robert A. Freed.
X
XFrom:     Robert A. Freed
XSubject:  Technical Information for ARC files
XDate:     June 24, 1986
X
XNote: In the following discussion, UNARC refers to my CP/M-80 program
Xfor extracting files from MSDOS ARCs.  The definitions of the ARC file
Xformat are based on MSDOS ARC512.EXE.
X
XARCHIVE FILE FORMAT
X-------------------
X
XComponent files are stored sequentially within an archive.  Each entry
Xis preceded by a 29-byte header, which contains the directory
Xinformation.  There is no wasted space between entries.  (This is in
Xcontrast to the centralized directory used by Novosielski libraries.
XAlthough random access to subfiles within an archive can be noticeably
Xslower than with libraries, archives do have the advantage of not
Xrequiring pre-allocation of directory space.)
X
XArchive entries are normally maintained in sorted name order.  The
Xformat of the 29-byte archive header is as follows:
X
XByte 1:  1A Hex.
X         This marks the start of an archive header.  If this byte is not found 
X         when expected, UNARC will scan forward in the file (up to 64K bytes) 
X         in an attempt to find it (followed by a valid compression version).  
X         If a valid header is found in this manner, a warning message is 
X         issued and archive file processing continues.  Otherwise, the file is 
X         assumed to be an invalid archive and processing is aborted.  (This is 
X         compatible with MS-DOS ARC version 5.12).  Note that a special 
X         exception is made at the beginning of an archive file, to accomodate 
X         "self-unpacking" archives (see below).
X
XByte 2:  Compression version, as follows:
X
X         0 = end of file marker (remaining bytes not present)
X         1 = unpacked (obsolete)
X         2 = unpacked
X         3 = packed
X         4 = squeezed (after packing)
X         5 = crunched (obsolete)
X         6 = crunched (after packing) (obsolete)
X         7 = crunched (after packing, using faster hash algorithm) (obsolete)
X         8 = crunched (after packing, using dynamic LZW variations)
X
XBytes 3-15:  ASCII file name, nul-terminated.
X
X(All of the following numeric values are stored low-byte first.)
X
XBytes 16-19:  Compressed file size in bytes.
X
XBytes 20-21:  File date, in 16-bit MS-DOS format:
X              Bits 15:9 = year - 1980
X              Bits  8:5 = month of year
X              Bits  4:0 = day of month
X              (All zero means no date.)
X
XBytes 22-23:  File time, in 16-bit MS-DOS format:
X              Bits 15:11 = hour (24-hour clock)
X              Bits 10:5  = minute
X              Bits  4:0  = second/2 (not displayed by UNARC)
X
XBytes 24-25:  Cyclic redundancy check (CRC) value (see below).
X
XBytes 26-29:  Original (uncompressed) file length in bytes.
X              (This field is not present for version 1 entries, byte 2 = 1.  
X              I.e., in this case the header is only 25 bytes long.  Because 
X              version 1 files are uncompressed, the value normally found in 
X              this field may be obtained from bytes 16-19.)
X
X
XSELF-UNPACKING ARCHIVES
X-----------------------
X
XA "self-unpacking" archive is one which can be renamed to a .COM file
Xand executed as a program.  An example of such a file is the MS-DOS
Xprogram ARC512.COM, which is a standard archive file preceded by a
Xthree-byte jump instruction.  The first entry in this file is a simple
X"bootstrap" program in uncompressed form, which loads the subfile
XARC.EXE (also uncompressed) into memory and passes control to it.  In
Xanticipation of a similar scheme for future distribution of UNARC, the
Xprogram permits up to three bytes to precede the first header in an
Xarchive file (with no error message).
X
X
XCRC COMPUTATION
X---------------
X
XArchive files use a 16-bit cyclic redundancy check (CRC) for error
Xcontrol.  The particular CRC polynomial used is x^16 + x^15 + x^2 + 1,
Xwhich is commonly known as "CRC-16" and is used in many data
Xtransmission protocols (e.g. DEC DDCMP and IBM BSC), as well as by
Xmost floppy disk controllers.  Note that this differs from the CCITT
Xpolynomial (x^16 + x^12 + x^5 + 1), which is used by the XMODEM-CRC
Xprotocol and the public domain CHEK program (although these do not
Xadhere strictly to the CCITT standard).  The MS-DOS ARC program does
Xperform a mathematically sound and accurate CRC calculation.  (We
Xmention this because it contrasts with some unfortunately popular
Xpublic domain programs we have witnessed, which from time immemorial
Xhave based their calculation on an obscure magazine article which
Xcontained a typographical error!)
X
XAdditional note (while we are on the subject of CRC's): The validity
Xof using a 16-bit CRC for checking an entire file is somewhat
Xquestionable.  Many people quote the statistics related to these
Xfunctions (e.g. "all two-bit errors, all single burst errors of 16 or
Xfewer bits, 99.997% of all single 17-bit burst errors, etc."), without
Xrealizing that these claims are valid only if the total number of bits
Xchecked is less than 32767 (which is why they are used in small-packet
Xdata transmission protocols).  I.e., for file sizes in excess of about
X4K bytes, a 16-bit CRC is not really as good as what is often claimed.
XThis is not to say that it is bad, but there are more reliable methods
Xavailable (e.g. the 32-bit AUTODIN-II polynomial).  (End of lecture!)
X
X                           Bob Freed
X                           62 Miller Road
X                           Newton Centre, MA  02159
X                           Telephone (617) 332-3533
X
X
________This_Is_The_END________
if test `wc -c < Arcinfo` -ne     5577; then
	echo 'shar: Arcinfo was damaged during transit (should have been     5577 bytes)'
fi
fi		; : end of overwriting check
echo 'x - Sysvarcstuf'
if test -f Sysvarcstuf; then echo 'shar: not overwriting Sysvarcstuf'; else
sed 's/^X//' << '________This_Is_The_END________' > Sysvarcstuf
XTo: Howard_Chu%um.cc.umich.edu%umix.uucp@umix.cc.umich.edu
XDate: Fri, 15 Apr 88 19:12:24 EST
XFrom: Jon Zeeff <zeeff%b-tech.UUCP@umix.cc.umich.edu>
XIn-Reply-To: Message from "um.cc.umich.edu!Howard_Chu" of Apr 15
XX-Mailer: Elm [version 1.7]
XMessage-Id: <8804151912.AA00417@b-tech.UUCP>
X 
X 
XHere is what I believe to be all the routines needed to run your arc on
XSys V.3.  Sys V.2 people will also need the directory routines that
Xwere posted in comp.sources.unix Vol 9 as gwyn-dir-lib.
X 
X 
X#! /bin/sh
X# This is a shell archive.  Remove anything before this line, then unpack
X# it by saving it into a file and typing "sh file".  To overwrite existing
X# files, type "sh file -c".  You can also feed this as standard input via
X# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
X# will see the following message at the end:
X#             "End of shell archive."
X# Contents:  getwd.c scandir.sh utimes.c
X# Wrapped by root@b-tech on Fri Apr 15 19:05:49 1988
XPATH=/bin:/usr/bin:/usr/ucb ; export PATH
Xif test -f getwd.c -a "${1}" != "-c" ; then
X  echo shar: Will not over-write existing file \"getwd.c\"
Xelse
Xecho shar: Extracting \"getwd.c\" \(726 characters\)
Xsed "s/^X//" >getwd.c <<'END_OF_getwd.c'
XX/*
XX * 4.2bsd getwd simulation for Sys V.3
XX */
XX
XX#include <stdio.h>
XX
XX#define SYSV3
XX
XX#define MAXWD 1024           /* limited by 4.2 getwd(2) */
XX
XX#ifdef SYSV3
XX
XXchar *getcwd();
XX
XXchar *
XXgetwd(path)
XXchar *path;
XX{
XX    return(getcwd(path,MAXWD));
XX}
XX
XX#else
XX
XX/*
XX * 4.2bsd getwd simulation for Sys V.2
XX */
XX
XX#include <stdio.h>
XX
XX#define MAXWD 1024           /* limited by 4.2 getwd(2) */
XX
XXchar *
XXgetwd(path)
XXchar *path;
XX{
XX     char *nlp;
XX     FILE *fp;
XX     FILE *popen();
XX     char *strrchr();
XX
XX        putenv("IFS= \t\n");
XX     fp = popen("PATH=/bin:/usr/bin pwd", "r");
XX     if (fp == NULL)
XX             return 0;
XX     if (fgets(path, MAXWD, fp) == NULL) {
XX             (void) pclose(fp);
XX             return 0;
XX     }
XX     if ((nlp = strrchr(path, '\n')) != NULL)
XX             *nlp = '\0';
XX     (void) pclose(fp);
XX     return path;
XX}
XX#endif
XX
XEND_OF_getwd.c
Xif test 726 -ne `wc -c <getwd.c`; then
X    echo shar: \"getwd.c\" unpacked with wrong size!
Xfi
X# end of overwriting check
Xfi
Xif test -f scandir.sh -a "${1}" != "-c" ; then
X  echo shar: Will not over-write existing file \"scandir.sh\"
Xelse
Xecho shar: Extracting \"scandir.sh\" \(13502 characters\)
Xsed "s/^X//" >scandir.sh <<'END_OF_scandir.sh'
XXPath: uunet!husc6!hao!oddjob!gargoyle!ihnp4!cbosgd!mandrill!hal!ncoast!allbery
XXFrom: rsalz@pebbles.bbn.com
XXNewsgroups: comp.sources.misc
XXSubject: scandir, ftw REDUX
XXMessage-ID: <6943@ncoast.UUCP>
XXDate: 1 Jan 88 00:47:01 GMT
XXSender: allbery@ncoast.UUCP
XXLines: 505
XXApproved: allbery@ncoast.UUCP
XXX-Archive: comp.sources.misc/8712/15
XX
XXForget my previous message -- I just decided for completeness's sake to
XXimplement the SysV ftw(3) routine, too.
XX
XXTo repeat, these are public-domain implementations of the SystemV ftw()
XXroutine, the BSD scandir() and alphasort() routines, and documentation for
XXsame.  The FTW manpage could be more readable, but so it goes.
XX
XXAnyhow, feel free to post these, and incorporate them into your existing
XXpackages.  I have readdir() routiens for MSDOS and the Amiga if anyone
XXwants them, and should have them for VMS by the end of January; let me
XXknow if you want copies.
XX
XXYours in filesystems,
XX     /r$
XX
XXAnyhow, feel free to post
XX#! /bin/sh
XX# This is a shell archive.  Remove anything before this line, then unpack
XX# it by saving it into a file and typing "sh file".  To overwrite existing
XX# files, type "sh file -c".  You can also feed this as standard input via
XX# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
XX# will see the following message at the end:
XX#            "End of shell archive."
XX# Contents:  alphasort.c ftw.3 ftw.c ftw.h scandir.3 scandir.c
XX# Wrapped by rsalz@fig.bbn.com on Tue Dec 29 21:39:01 1987
XXPATH=/bin:/usr/bin:/usr/ucb ; export PATH
XXif test -f 'alphasort.c' -a "${1}" != "-c" ; then
XX  echo shar: Will not clobber existing file \"'alphasort.c'\"
XXelse
XXecho shar: Extracting \"'alphasort.c'\" \(425 characters\)
XXsed "s/^X//" >'alphasort.c' <<'END_OF_FILE'
XXX/*
XXX**  ALPHASORT
XXX**  Trivial sorting predicate for scandir; puts entries in alphabetical order.
XXX*/
XXX#include <sys/types.h>
XXX#include <sys/dir.h>
XXX#ifdef      RCSID
XXXstatic char RCS[] = "$Header: alphasort.c,v 1.1 87/12/29 21:35:59 rsalz Exp $";
XXX#endif      /* RCSID */
XXX
XXX/* A convenient shorthand. */
XXXtypedef struct direct        ENTRY;
XXX
XXXint
XXXalphasort(d1, d2)
XXX    ENTRY   **d1;
XXX    ENTRY   **d2;
XXX{
XXX    return(strcmp(d1[0]->d_name, d2[0]->d_name));
XXX}
XXEND_OF_FILE
XXif test 425 -ne `wc -c <'alphasort.c'`; then
XX    echo shar: \"'alphasort.c'\" unpacked with wrong size!
XXfi
XX# end of 'alphasort.c'
XXfi
XXif test -f 'ftw.3' -a "${1}" != "-c" ; then
XX  echo shar: Will not clobber existing file \"'ftw.3'\"
XXelse
XXecho shar: Extracting \"'ftw.3'\" \(2139 characters\)
XXsed "s/^X//" >'ftw.3' <<'END_OF_FILE'
XXX.TH FTW 3
XXX.\" $Header: ftw.3,v 1.1 87/12/29 21:34:29 rsalz Exp $
XXX.SH NAME
XXXftw \- walk a file tree
XXX.SH SYNOPSIS
XXX.ft B
XXX.nf
XXX#include <ftw.h>
XXX
XXXint
XXXftw(directory, funcptr, depth)
XXX    char *directory;
XXX    int (*funcptr)();
XXX    int depth;
XXX
XXX#include <sys/stat.h>
XXX
XXXint
XXXfuncptr(item, sb, flag)
XXX    char *item;
XXX    struct stat *sb;
XXX    int flag;
XXX.fi
XXX.ft R
XXX.SH DESCRIPTION
XXX.I Ftw
XXXwalks through the directory tree starting from the indicated
XXX.IR path .
XXXFor every entry it finds in the tree, it calls the user-supplied
XXX.I funcptr
XXXwith the calling sequence given in the synopsis above.
XXXThe first argument is the full pathname of the entry (rooted from
XXXthe
XXX.I directory
XXXparameter given to
XXX.IR ftw );
XXXthe second argument is a pointer to the
XXX.IR stat (2)
XXXstructure for the entry;
XXXand the third argument is one of the #define's in the header file.
XXXThis value will be one of the following:
XXX.RS
XXX.ta \w'FTW_DNR  'u
XXX.nf
XXXFTW_F       Item is a normal file
XXXFTW_D       Item is a directory
XXXFTW_NS      The stat failed on the item
XXXFTW_DNR     Item is a directory which can't be read
XXX.fi
XXX.RE
XXXNote, however, that FTW_F is a misnomer; anything other than directories
XXXare (e.g., symbolic links) get the FTW_F tag.
XXX.PP
XXX.I Ftw
XXXrecursively calls itself when it encounters a directory.
XXXTo avoid using up all a program's file descriptors, the
XXX.I depth
XXXargument specifies the number of simultaneous open directories to maintain.
XXXWhen the depth is exceeded, the routine will become noticeably
XXXslower because directories are closed in ``most-recently-used'' order.
XXX.PP
XXXTo stop the tree walk, the user-supplied function should return a
XXXnon\-zero value; this value will become the return value of
XXX.IR ftw .
XXXOtherwise,
XXX.I ftw
XXXwill continue until it has scanned the entire tree, in which case it will
XXXreturn zero, or until it hits an error such as a
XXX.IR malloc (3)
XXXfailure, in which case it will return \-1.
XXX.PP
XXXBecause
XXX.I ftw
XXXuses dynamic data structures, the only safe way to exit out of a tree
XXXwalk is to return a non-zero value.
XXXTo handle interrupts, for example, mark that the interrupt occured
XXXand return a non\-zero value\(em don't use
XXX.I longjmp (3)
XXXunless the program is going to terminate.
XXX.SH SEE ALSO
XXXstat(2)
XXEND_OF_FILE
XXif test 2139 -ne `wc -c <'ftw.3'`; then
XX    echo shar: \"'ftw.3'\" unpacked with wrong size!
XXfi
XX# end of 'ftw.3'
XXfi
XXif test -f 'ftw.c' -a "${1}" != "-c" ; then
XX  echo shar: Will not clobber existing file \"'ftw.c'\"
XXelse
XXecho shar: Extracting \"'ftw.c'\" \(2455 characters\)
XXsed "s/^X//" >'ftw.c' <<'END_OF_FILE'
XXX/*
XXX**  FTW
XXX**  Walk a directory hierarchy from a given point, calling a user-supplied
XXX**  function at each thing we find.  If we go below a specified depth,
XXX**  recycle file descriptors.
XXX*/
XXX#include <stdio.h>
XXX#include <sys/types.h>
XXX#include <sys/stat.h>
XXX#include <sys/dir.h>
XXX#include <ftw.h>
XXX#ifdef      RCSID
XXXstatic char RCS[] = "$Header: ftw.c,v 1.1 87/12/29 21:38:52 rsalz Exp $";
XXX#endif      /* RCSID */
XXX
XXX/* Handy shorthand. */
XXX#define EQ(a, b)    (strcmp((a), (b)) == 0)
XXX
XXX/* Linked in later. */
XXXextern char         *malloc();
XXXextern char         *strcpy();
XXX
XXX
XXXint
XXXftw(directory, funcptr, depth)
XXX    char             *directory;
XXX    int                     (*funcptr)();
XXX    int                       depth;
XXX{
XXX    register DIR     *Dp;
XXX    register char    *p;
XXX    register int      i;
XXX    struct direct    *E;
XXX    struct stat               Sb;
XXX    long              seekpoint;
XXX    char             *fullpath;
XXX
XXX    /* If can't stat, tell the user so. */
XXX    if (stat(directory, &Sb) < 0)
XXX    return((*funcptr)(directory, &Sb, FTW_NS));
XXX
XXX    /* If it's not a directory, call the user's function. */
XXX    if ((Sb.st_mode & S_IFMT) != S_IFDIR)
XXX    /* Saying "FTW_F" here is lying, what if this is a symlink? */
XXX    return((*funcptr)(directory, &Sb, FTW_F));
XXX
XXX    /* Open directory; and if we can't tell the user so. */
XXX    if ((Dp = opendir(directory)) == NULL)
XXX    return((*funcptr)(directory, &Sb, FTW_DNR));
XXX
XXX    /* See if user wants to go further. */
XXX    if (i = (*funcptr)(directory, &Sb, FTW_D)) {
XXX    closedir(Dp);
XXX    return(i);
XXX    }
XXX
XXX    /* Get ready to hold the full paths. */
XXX    i = strlen(directory);
XXX    if ((fullpath = malloc(i + 1 + MAXNAMLEN + 1)) == NULL) {
XXX    closedir(Dp);
XXX    return(-1);
XXX    }
XXX    (void)strcpy(fullpath, directory);
XXX    p = &fullpath[i];
XXX    if (i && p[-1] != '/')
XXX    *p++ = '/';
XXX
XXX    /* Read all entries in the directory.. */
XXX    while (E = readdir(Dp))
XXX    if (!EQ(E->d_name, ".") && !EQ(E->d_name, "..")) {
XXX        if (depth <= 1) {
XXX            /* Going too deep; checkpoint and close this directory. */
XXX            seekpoint = telldir(Dp);
XXX            closedir(Dp);
XXX            Dp = NULL;
XXX        }
XXX
XXX        /* Process the file. */
XXX        (void)strcpy(p, E->d_name);
XXX        if (i = ftw(fullpath, funcptr, depth - 1)) {
XXX            /* User's finished; clean up. */
XXX            free(fullpath);
XXX            if (Dp)
XXX                closedir(Dp);
XXX            return(i);
XXX        }
XXX
XXX        /* Reopen the directory if necessary. */
XXX        if (Dp == NULL) {
XXX            if ((Dp = opendir(directory)) == NULL) {
XXX                /* WTF? */
XXX                free(fullpath);
XXX                return(-1);
XXX            }
XXX            seekdir(Dp, seekpoint);
XXX        }
XXX    }
XXX
XXX    /* Clean up. */
XXX    free(fullpath);
XXX    closedir(Dp);
XXX    return(0);
XXX}
XXEND_OF_FILE
XXif test 2455 -ne `wc -c <'ftw.c'`; then
XX    echo shar: \"'ftw.c'\" unpacked with wrong size!
XXfi
XX# end of 'ftw.c'
XXfi
XXif test -f 'ftw.h' -a "${1}" != "-c" ; then
XX  echo shar: Will not clobber existing file \"'ftw.h'\"
XXelse
XXecho shar: Extracting \"'ftw.h'\" \(358 characters\)
XXsed "s/^X//" >'ftw.h' <<'END_OF_FILE'
XXX/*
XXX**  <FTW.H>
XXX**  Header values for the third parameter to the user-supplied function
XXX**  for ftw().
XXX**
XXX**  $Header: ftw.h,v 1.1 87/12/29 21:34:34 rsalz Exp $
XXX*/
XXX
XXX#define FTW_NS              100     /* Something stat(2) failed on          */
XXX#define FTW_DNR             200     /* Something opendir(3) failed on       */
XXX#define FTW_F               300     /* A normal file                        */
XXX#define FTW_D               400     /* A directory                          */
XXEND_OF_FILE
XXif test 358 -ne `wc -c <'ftw.h'`; then
XX    echo shar: \"'ftw.h'\" unpacked with wrong size!
XXfi
XX# end of 'ftw.h'
XXfi
XXif test -f 'scandir.3' -a "${1}" != "-c" ; then
XX  echo shar: Will not clobber existing file \"'scandir.3'\"
XXelse
XXecho shar: Extracting \"'scandir.3'\" \(2350 characters\)
XXsed "s/^X//" >'scandir.3' <<'END_OF_FILE'
XXX.TH SCANDIR 3
XXX.\" $Header: scandir.3,v 1.1 87/12/29 21:35:54 rsalz Exp $
XXX.SH NAME
XXXscandir, alphasort \- scan a directory
XXX.SH SYNOPSIS
XXX.nf
XXX.ft B
XXX#include <sys/types.h>
XXX#include <sys/dir.h>
XXX
XXXint
XXXscandir(name, list, selector, sorter)
XXX.in +4n
XXXchar *name;
XXXstruct direct ***list;
XXXint (*selector)();
XXXint (*sorter)();
XXX.in -4n
XXX
XXXint
XXXalphasort(d1, d2)
XXX.in +4n
XXXstruct direct **d1;
XXXstruct direct **d2;
XXX.in -4n
XXX.ft R
XXX.fi
XXX.SH DESCRIPTION
XXX.I Scandir
XXXreads the directory
XXX.I name
XXXand builds a NULL\-terminated array of pointers to the entries found
XXXin that directory.
XXXThis array is put into the location pointed to by the
XXX.I list
XXXparameter.
XXX.PP
XXXIf the
XXX.I selector
XXXparameter is non\-NULL, it is taken to be a pointer to a function called
XXXwith each entry, to determine whether or not it should be included in
XXXthe returned list.
XXXIf the parameter is NULL, all entries are included.
XXX.PP
XXXAs an added feature, the entries can be sorted (with
XXX.IR qsort (3))
XXXbefore the list is returned.
XXXIf the
XXX.I sorter
XXXparameter is non\-NULL, it is passed to qsort to use as the comparison
XXXfunction.
XXXThe
XXX.I alphasort
XXXroutine is provided to sort the array alphabetically.
XXX.PP
XXXThe array pointed to by
XXX.I list
XXXand the items it points to are all space obtained through
XXX.IR malloc (3),
XXXand their storage can be reclaimed as shown in the example below.
XXX.SH "EXAMPLE"
XXXHere is a small
XXX.IR ls (1)\-like
XXXprogram:
XXX.ne 50
XXX.RS
XXX.nf
XXX#include <stdio.h>
XXX#include <sys/types.h>
XXX#include <sys/stat.h>
XXX#include <sys/dir.h>
XXX
XXXextern int alphasort();
XXX
XXXstatic int
XXXfilesonly(e)
XXX    struct direct *e;
XXX{
XXX    struct stat sb;
XXX
XXX    return(stat(e->d_name, &sb) >= 0 && (sb.st_mode & S_IFMT) == S_IFREG);
XXX}
XXX
XXXmain(ac, av)
XXX    int ac;
XXX    char *av[];
XXX{
XXX    register int i;
XXX    register int j;
XXX    struct direct **list;
XXX
XXX    if (ac != 2) {
XXX            fprintf(stderr, "usage: %s dirname\n", av[0]);
XXX            exit(1);
XXX    }
XXX    if (chdir(av[1]) < 0) {
XXX            perror(av[1]);
XXX            exit(1);
XXX    }
XXX    if ((i = scandir(".", &list, filesonly, alphasort)) < 0) {
XXX            perror("Error reading directory");
XXX            exit(1);
XXX    }
XXX    for (j = 0; j < i; j++)
XXX            printf("%s\n", list[j]->d_name);
XXX    for (j = 0; j < i; j++)
XXX            free((char *)list[j]);
XXX    free((char *)list);
XXX    exit(0);
XXX}
XXX.fi
XXX.RE
XXX.SH "SEE ALSO"
XXXdirectory(3), qsort(3)
XXX.SH DIAGNOSTICS
XXXReturns the number of entries in the ``list,'' or \-1 if the directory
XXXcould not be opened or a memory allocation failed.
XXX.SH BUGS
XXXThe routine can be slightly wasteful of space.
XXEND_OF_FILE
XXif test 2350 -ne `wc -c <'scandir.3'`; then
XX    echo shar: \"'scandir.3'\" unpacked with wrong size!
XXfi
XX# end of 'scandir.3'
XXfi
XXif test -f 'scandir.c' -a "${1}" != "-c" ; then
XX  echo shar: Will not clobber existing file \"'scandir.c'\"
XXelse
XXecho shar: Extracting \"'scandir.c'\" \(1777 characters\)
XXsed "s/^X//" >'scandir.c' <<'END_OF_FILE'
XXX/*
XXX**  SCANDIR
XXX**  Scan a directory, collecting all (selected) items into a an array.
XXX*/
XXX#include <sys/types.h>
XXX#include <sys/dir.h>
XXX#ifdef      RCSID
XXXstatic char RCS[] = "$Header: scandir.c,v 1.1 87/12/29 21:35:56 rsalz Exp $";
XXX#endif      /* RCSID */
XXX
XXX/* Initial guess at directory size. */
XXX#define INITIAL_SIZE        20
XXX
XXX/* A convenient shorthand. */
XXXtypedef struct direct        ENTRY;
XXX
XXX/* Linked in later. */
XXXextern char         *malloc();
XXXextern char         *realloc();
XXXextern char         *strcpy();
XXX
XXX
XXXint
XXXscandir(Name, List, Selector, Sorter)
XXX    char              *Name;
XXX    ENTRY           ***List;
XXX    int                      (*Selector)();
XXX    int                      (*Sorter)();
XXX{
XXX    register ENTRY   **names;
XXX    register ENTRY    *E;
XXX    register DIR      *Dp;
XXX    register int       i;
XXX    register int       size;
XXX
XXX    /* Get initial list space and open directory. */
XXX    size = INITIAL_SIZE;
XXX    if ((names = (ENTRY **)malloc(size * sizeof names[0])) == NULL
XXX     || (Dp = opendir(Name)) == NULL)
XXX    return(-1);
XXX
XXX    /* Read entries in the directory. */
XXX    for (i = 0; E = readdir(Dp); )
XXX    if (Selector == NULL || (*Selector)(E)) {
XXX        /* User wants them all, or he wants this one. */
XXX        if (++i >= size) {
XXX            size <<= 1;
XXX            names = (ENTRY **)realloc((char *)names, size * sizeof names[0]);
XXX            if (names == NULL) {
XXX                closedir(Dp);
XXX                return(-1);
XXX            }
XXX        }
XXX
XXX        /* Copy the entry. */
XXX        if ((names[i - 1] = (ENTRY *)malloc(DIRSIZ(E))) == NULL) {
XXX            closedir(Dp);
XXX            return(-1);
XXX        }
XXX        names[i - 1]->d_ino = E->d_ino;
XXX        names[i - 1]->d_reclen = E->d_reclen;
XXX        names[i - 1]->d_namlen = E->d_namlen;
XXX        (void)strcpy(names[i - 1]->d_name, E->d_name);
XXX    }
XXX
XXX    /* Close things off. */
XXX    names[i] = NULL;
XXX    *List = names;
XXX    closedir(Dp);
XXX
XXX    /* Sort? */
XXX    if (i && Sorter)
XXX    qsort((char *)names, i, sizeof names[0], Sorter);
XXX
XXX    return(i);
XXX}
XXEND_OF_FILE
XXif test 1777 -ne `wc -c <'scandir.c'`; then
XX    echo shar: \"'scandir.c'\" unpacked with wrong size!
XXfi
XX# end of 'scandir.c'
XXfi
XXecho shar: End of shell archive.
XXexit 0
XEND_OF_scandir.sh
Xif test 13502 -ne `wc -c <scandir.sh`; then
X    echo shar: \"scandir.sh\" unpacked with wrong size!
Xfi
X# end of overwriting check
Xfi
Xif test -f utimes.c -a "${1}" != "-c" ; then
X  echo shar: Will not over-write existing file \"utimes.c\"
Xelse
Xecho shar: Extracting \"utimes.c\" \(373 characters\)
Xsed "s/^X//" >utimes.c <<'END_OF_utimes.c'
XX
XX/* bsd utimes emulation for Sys V */
XX/* by Jon Zeeff */
XX
XX#include <sys/types.h>
XX
XXstruct utimbuf {
XX     time_t  actime;
XX     time_t  modtime;
XX};
XX
XXstruct timeval {
XX     long    tv_sec;
XX     long    tv_usec;
XX};
XX
XXutimes(path,tvp)
XXchar *path;
XXstruct timeval tvp[2];
XX{
XX
XXstruct utimbuf times;
XX
XXtimes.actime = (time_t) tvp[0].tv_sec;
XXtimes.modtime = (time_t) tvp[1].tv_sec;
XX
XXreturn utime(path,times);
XX
XX}
XEND_OF_utimes.c
Xif test 373 -ne `wc -c <utimes.c`; then
X    echo shar: \"utimes.c\" unpacked with wrong size!
Xfi
X# end of overwriting check
Xfi
Xecho shar: End of shell archive.
Xexit 0
X
________This_Is_The_END________
if test `wc -c < Sysvarcstuf` -ne    18327; then
	echo 'shar: Sysvarcstuf was damaged during transit (should have been    18327 bytes)'
fi
fi		; : end of overwriting check
echo 'x - tws.h'
if test -f tws.h; then echo 'shar: not overwriting tws.h'; else
sed 's/^X//' << '________This_Is_The_END________' > tws.h
X/* tws.h - header file for libtws date/time library 
X   (from mod.sources, Volume 8, Issue 81.)
X
X{Second distribution of phoon, deltime, and libtws - 24feb87.
X     Jef Poskanzer, UniSoft Systems, Berkeley
X	 unisoft!jef@ucbvax.Berkeley.Edu
X	      ...ucbvax!unisoft!jef
X		  (415)644-1230	}
X
XThis library is used to allow date stamping of files in Unix. The
Xstandard time routines in Unix do not provide routines to convert a
Xparsed time into a time(3) clock value, so.... If you don't have this
Xcode, and can't get it, take out the references to it in arcdos.c,
Xand remove the reference to tws.h and libtws.a in the Makefile.
X
X			-- Howard Chu, March 3, 1987
X			   University of Michigan Computing Center
X			   hyc@umix.cc.umich.edu
X			   ...uunet!umix!hyc	*/
X
X
X/* Definition of the tws data structure. */
X
Xstruct tws {
X    int     tw_sec;
X    int     tw_min;
X    int     tw_hour;
X
X    int     tw_mday;
X    int     tw_mon;
X    int     tw_year;
X
X    int     tw_wday;
X    int     tw_yday;
X
X    int     tw_zone;
X
X    long    tw_clock;
X
X    int     tw_flags;
X#define TW_NULL 0x0000
X#define TW_SDAY 0x0007		/* how day-of-week was determined */
X#define   TW_SNIL 0x0000	/*   not given */
X#define   TW_SEXP 0x0001	/*   explicitly given */
X#define   TW_SIMP 0x0002	/*   implicitly given */
X#define TW_DST  0x0010		/* daylight savings time */
X#define TW_ZONE 0x0020		/* use numeric timezones only */
X#define TW_JUNK 0x0040		/* date string contained junk */
X};
X
X
X/* Declarations of routines. */
X
Xvoid twscopy( );
X	/* twscopy( &totws, &fromtws ) copies a tws */
Xint twsort( );
X	/* twsort( &tws1, &tws2 ) compares two tws's: 1 means tws1 is
X	   later; -1 means tws1 is earlier; 0 means they are equal */
Xlong twclock( );
X	/* twclock( &tws ) turns a tws into a time(3)-style clock value */
Xlong twjuliandate( );
X	/* twjuliandate( &tws ) returns the Julian day number of a tws */
Xlong twsubtract( );
X	/* twsubtract( &tws1, &tws2 ) returns seconds of difference */
X
X/* These routines are functionally similar to the ctime(3) routines
X   in the standard Unix library. */
Xchar *dctime( );
X	/* dctime( &tws ) returns a string for the date/time passed in */
Xstruct tws *dlocaltime( );
X	/* dlocaltime( &clock ) turns a time(3) clock value into a tws */
Xstruct tws *dgmtime( );
X	/* dgmtime( &clock ) turns a time(3) clock value into a tws */
Xchar *dasctime( );
X	/* dasctime( &tws, flags ) turns a tws into a string */
Xchar *dtimezone( );
X	/* dtimezone( offset, flags ) returns the name of the time zone */
X
Xchar *dtimenow( );
X	/* dtimenow( ) returns a string for the current date/time */
X
Xstruct tws *dparsetime( );
X	/* dparsetime( &str ) turns a string into a tws */
X
Xstruct tws *dtwstime( );
X	/* dtwstime( ) returns a tws for the current date/time */
X
X#ifdef ATZ
X#define dtime(cl) dasctime( dlocaltime( cl ), TW_NULL )
X#else
X#define dtime(cl) dasctime( dlocaltime( cl ), TW_ZONE )
X#endif
X
X#define dtwszone(tw) dtimezone( tw -> tw_zone, tw -> tw_flags )
X
X
Xextern char   *tw_dotw[], *tw_ldotw[], *tw_moty[];
________This_Is_The_END________
if test `wc -c < tws.h` -ne     2985; then
	echo 'shar: tws.h was damaged during transit (should have been     2985 bytes)'
fi
fi		; : end of overwriting check
exit 0

