Subject:  v09i037:  MicroEMACS, version 3.8b, Part05/14
Newsgroups: mod.sources
Approved: rs@mirror.TMC.COM

Submitted by: ihnp4!itivax!duncan!lawrence (Daniel Lawrence)
Mod.sources: Volume 9, Issue 37
Archive-name: uemacs3.8b/Part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If this archive is complete, you will see the message:
#		"End of archive 5 (of 14)."
# Contents:  basic.c efunc.h termio.c
# Wrapped by rs@mirror on Fri Mar 13 13:23:57 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"basic.c\" \(12220 characters\)
if test -f basic.c ; then 
  echo shar: Will not over-write existing file \"basic.c\"
else
sed "s/^X//" >basic.c <<'END_OF_basic.c'
X/*
X * The routines in this file move the cursor around on the screen. They
X * compute a new value for the cursor, then adjust ".". The display code
X * always updates the cursor location, so only moves between lines, or
X * functions that adjust the top line in the window and invalidate the
X * framing, are hard.
X */
X#include        <stdio.h>
X#include	"estruct.h"
X#include        "edef.h"
X
X#if	MEGAMAX & ST520
Xoverlay	"basic"
X#endif
X
X/*
X * Move the cursor to the
X * beginning of the current line.
X * Trivial.
X */
Xgotobol(f, n)
X{
X        curwp->w_doto  = 0;
X        return (TRUE);
X}
X
X/*
X * Move the cursor backwards by "n" characters. If "n" is less than zero call
X * "forwchar" to actually do the move. Otherwise compute the new cursor
X * location. Error if you try and move out of the buffer. Set the flag if the
X * line pointer for dot changes.
X */
Xbackchar(f, n)
Xregister int    n;
X{
X        register LINE   *lp;
X
X        if (n < 0)
X                return (forwchar(f, -n));
X        while (n--) {
X                if (curwp->w_doto == 0) {
X                        if ((lp=lback(curwp->w_dotp)) == curbp->b_linep)
X                                return (FALSE);
X                        curwp->w_dotp  = lp;
X                        curwp->w_doto  = llength(lp);
X                        curwp->w_flag |= WFMOVE;
X                } else
X                        curwp->w_doto--;
X        }
X        return (TRUE);
X}
X
X/*
X * Move the cursor to the end of the current line. Trivial. No errors.
X */
Xgotoeol(f, n)
X{
X        curwp->w_doto  = llength(curwp->w_dotp);
X        return (TRUE);
X}
X
X/*
X * Move the cursor forwwards by "n" characters. If "n" is less than zero call
X * "backchar" to actually do the move. Otherwise compute the new cursor
X * location, and move ".". Error if you try and move off the end of the
X * buffer. Set the flag if the line pointer for dot changes.
X */
Xforwchar(f, n)
Xregister int    n;
X{
X        if (n < 0)
X                return (backchar(f, -n));
X        while (n--) {
X                if (curwp->w_doto == llength(curwp->w_dotp)) {
X                        if (curwp->w_dotp == curbp->b_linep)
X                                return (FALSE);
X                        curwp->w_dotp  = lforw(curwp->w_dotp);
X                        curwp->w_doto  = 0;
X                        curwp->w_flag |= WFMOVE;
X                } else
X                        curwp->w_doto++;
X        }
X        return (TRUE);
X}
X
Xgotoline(f, n)		/* move to a particular line.
X			   argument (n) must be a positive integer for
X			   this to actually do anything		*/
X
X{
X	register int status;	/* status return */
X	char arg[NSTRING];	/* buffer to hold argument */
X
X	/* get an argument if one doesnt exist */
X	if (f == FALSE) {
X		if ((status = mlreply("Line to GOTO: ", arg, "")) != TRUE) {
X			mlwrite("[Aborted]");
X			return(status);
X		}
X		n = atoi(arg);
X	}
X
X	if (n < 1)		/* if a bogus argument...then leave */
X		return(FALSE);
X
X	/* first, we go to the start of the buffer */
X        curwp->w_dotp  = lforw(curbp->b_linep);
X        curwp->w_doto  = 0;
X	return(forwline(f, n-1));
X}
X
X/*
X * Goto the beginning of the buffer. Massive adjustment of dot. This is
X * considered to be hard motion; it really isn't if the original value of dot
X * is the same as the new value of dot. Normally bound to "M-<".
X */
Xgotobob(f, n)
X{
X        curwp->w_dotp  = lforw(curbp->b_linep);
X        curwp->w_doto  = 0;
X        curwp->w_flag |= WFHARD;
X        return (TRUE);
X}
X
X/*
X * Move to the end of the buffer. Dot is always put at the end of the file
X * (ZJ). The standard screen code does most of the hard parts of update.
X * Bound to "M->".
X */
Xgotoeob(f, n)
X{
X        curwp->w_dotp  = curbp->b_linep;
X        curwp->w_doto  = 0;
X        curwp->w_flag |= WFHARD;
X        return (TRUE);
X}
X
X/*
X * Move forward by full lines. If the number of lines to move is less than
X * zero, call the backward line function to actually do it. The last command
X * controls how the goal column is set. Bound to "C-N". No errors are
X * possible.
X */
Xforwline(f, n)
X{
X        register LINE   *dlp;
X
X        if (n < 0)
X                return (backline(f, -n));
X
X	/* if we are on the last line as we start....fail the command */
X	if (curwp->w_dotp == curbp->b_linep)
X		return(FALSE);
X
X	/* if the last command was not note a line move,
X	   reset the goal column */
X        if ((lastflag&CFCPCN) == 0)
X                curgoal = getccol(FALSE);
X
X	/* flag this command as a line move */
X        thisflag |= CFCPCN;
X
X	/* and move the point down */
X        dlp = curwp->w_dotp;
X        while (n-- && dlp!=curbp->b_linep)
X                dlp = lforw(dlp);
X
X	/* reseting the current position */
X        curwp->w_dotp  = dlp;
X        curwp->w_doto  = getgoal(dlp);
X        curwp->w_flag |= WFMOVE;
X        return (TRUE);
X}
X
X/*
X * This function is like "forwline", but goes backwards. The scheme is exactly
X * the same. Check for arguments that are less than zero and call your
X * alternate. Figure out the new line and call "movedot" to perform the
X * motion. No errors are possible. Bound to "C-P".
X */
Xbackline(f, n)
X{
X        register LINE   *dlp;
X
X        if (n < 0)
X                return (forwline(f, -n));
X
X
X	/* if we are on the last line as we start....fail the command */
X	if (lback(curwp->w_dotp) == curbp->b_linep)
X		return(FALSE);
X
X	/* if the last command was not note a line move,
X	   reset the goal column */
X        if ((lastflag&CFCPCN) == 0)
X                curgoal = getccol(FALSE);
X
X	/* flag this command as a line move */
X        thisflag |= CFCPCN;
X
X	/* and move the point up */
X        dlp = curwp->w_dotp;
X        while (n-- && lback(dlp)!=curbp->b_linep)
X                dlp = lback(dlp);
X
X	/* reseting the current position */
X        curwp->w_dotp  = dlp;
X        curwp->w_doto  = getgoal(dlp);
X        curwp->w_flag |= WFMOVE;
X        return (TRUE);
X}
X
X#if	WORDPRO
Xgotobop(f, n)	/* go back to the beginning of the current paragraph
X		   here we look for a <NL><NL> or <NL><TAB> or <NL><SPACE>
X		   combination to delimit the beginning of a paragraph	*/
X
Xint f, n;	/* default Flag & Numeric argument */
X
X{
X	register int suc;	/* success of last backchar */
X
X	if (n < 0)	/* the other way...*/
X		return(gotoeop(f, -n));
X
X	while (n-- > 0) {	/* for each one asked for */
X
X		/* first scan back until we are in a word */
X		suc = backchar(FALSE, 1);
X		while (!inword() && suc)
X			suc = backchar(FALSE, 1);
X		curwp->w_doto = 0;	/* and go to the B-O-Line */
X
X		/* and scan back until we hit a <NL><NL> or <NL><TAB>
X		   or a <NL><SPACE>					*/
X		while (lback(curwp->w_dotp) != curbp->b_linep)
X			if (llength(curwp->w_dotp) != 0 &&
X			    lgetc(curwp->w_dotp, curwp->w_doto) != TAB &&
X			    lgetc(curwp->w_dotp, curwp->w_doto) != ' ')
X				curwp->w_dotp = lback(curwp->w_dotp);
X			else
X				break;
X
X		/* and then forward until we are in a word */
X		suc = forwchar(FALSE, 1);
X		while (suc && !inword())
X			suc = forwchar(FALSE, 1);
X	}
X	curwp->w_flag |= WFMOVE;	/* force screen update */
X	return(TRUE);
X}
X
Xgotoeop(f, n)	/* go forword to the end of the current paragraph
X		   here we look for a <NL><NL> or <NL><TAB> or <NL><SPACE>
X		   combination to delimit the beginning of a paragraph	*/
X
Xint f, n;	/* default Flag & Numeric argument */
X
X{
X	register int suc;	/* success of last backchar */
X
X	if (n < 0)	/* the other way...*/
X		return(gotobop(f, -n));
X
X	while (n-- > 0) {	/* for each one asked for */
X
X		/* first scan forward until we are in a word */
X		suc = forwchar(FALSE, 1);
X		while (!inword() && suc)
X			suc = forwchar(FALSE, 1);
X		curwp->w_doto = 0;	/* and go to the B-O-Line */
X		if (suc)	/* of next line if not at EOF */
X			curwp->w_dotp = lforw(curwp->w_dotp);
X
X		/* and scan forword until we hit a <NL><NL> or <NL><TAB>
X		   or a <NL><SPACE>					*/
X		while (curwp->w_dotp != curbp->b_linep) {
X			if (llength(curwp->w_dotp) != 0 &&
X			    lgetc(curwp->w_dotp, curwp->w_doto) != TAB &&
X			    lgetc(curwp->w_dotp, curwp->w_doto) != ' ')
X				curwp->w_dotp = lforw(curwp->w_dotp);
X			else
X				break;
X		}
X
X		/* and then backward until we are in a word */
X		suc = backchar(FALSE, 1);
X		while (suc && !inword()) {
X			suc = backchar(FALSE, 1);
X		}
X		curwp->w_doto = llength(curwp->w_dotp);	/* and to the EOL */
X	}
X	curwp->w_flag |= WFMOVE;	/* force screen update */
X	return(TRUE);
X}
X#endif
X
X/*
X * This routine, given a pointer to a LINE, and the current cursor goal
X * column, return the best choice for the offset. The offset is returned.
X * Used by "C-N" and "C-P".
X */
Xgetgoal(dlp)
Xregister LINE   *dlp;
X{
X        register int    c;
X        register int    col;
X        register int    newcol;
X        register int    dbo;
X
X        col = 0;
X        dbo = 0;
X        while (dbo != llength(dlp)) {
X                c = lgetc(dlp, dbo);
X                newcol = col;
X                if (c == '\t')
X                        newcol |= 0x07;
X                else if (c<0x20 || c==0x7F)
X                        ++newcol;
X                ++newcol;
X                if (newcol > curgoal)
X                        break;
X                col = newcol;
X                ++dbo;
X        }
X        return (dbo);
X}
X
X/*
X * Scroll forward by a specified number of lines, or by a full page if no
X * argument. Bound to "C-V". The "2" in the arithmetic on the window size is
X * the overlap; this value is the default overlap value in ITS EMACS. Because
X * this zaps the top line in the display window, we have to do a hard update.
X */
Xforwpage(f, n)
Xregister int    n;
X{
X        register LINE   *lp;
X
X        if (f == FALSE) {
X                n = curwp->w_ntrows - 2;        /* Default scroll.      */
X                if (n <= 0)                     /* Forget the overlap   */
X                        n = 1;                  /* if tiny window.      */
X        } else if (n < 0)
X                return (backpage(f, -n));
X#if     CVMVAS
X        else                                    /* Convert from pages   */
X                n *= curwp->w_ntrows;           /* to lines.            */
X#endif
X        lp = curwp->w_linep;
X        while (n-- && lp!=curbp->b_linep)
X                lp = lforw(lp);
X        curwp->w_linep = lp;
X        curwp->w_dotp  = lp;
X        curwp->w_doto  = 0;
X        curwp->w_flag |= WFHARD;
X        return (TRUE);
X}
X
X/*
X * This command is like "forwpage", but it goes backwards. The "2", like
X * above, is the overlap between the two windows. The value is from the ITS
X * EMACS manual. Bound to "M-V". We do a hard update for exactly the same
X * reason.
X */
Xbackpage(f, n)
Xregister int    n;
X{
X        register LINE   *lp;
X
X        if (f == FALSE) {
X                n = curwp->w_ntrows - 2;        /* Default scroll.      */
X                if (n <= 0)                     /* Don't blow up if the */
X                        n = 1;                  /* window is tiny.      */
X        } else if (n < 0)
X                return (forwpage(f, -n));
X#if     CVMVAS
X        else                                    /* Convert from pages   */
X                n *= curwp->w_ntrows;           /* to lines.            */
X#endif
X        lp = curwp->w_linep;
X        while (n-- && lback(lp)!=curbp->b_linep)
X                lp = lback(lp);
X        curwp->w_linep = lp;
X        curwp->w_dotp  = lp;
X        curwp->w_doto  = 0;
X        curwp->w_flag |= WFHARD;
X        return (TRUE);
X}
X
X/*
X * Set the mark in the current window to the value of "." in the window. No
X * errors are possible. Bound to "M-.".
X */
Xsetmark(f, n)
X{
X        curwp->w_markp = curwp->w_dotp;
X        curwp->w_marko = curwp->w_doto;
X        mlwrite("[Mark set]");
X        return (TRUE);
X}
X
X/*
X * Swap the values of "." and "mark" in the current window. This is pretty
X * easy, bacause all of the hard work gets done by the standard routine
X * that moves the mark about. The only possible error is "no mark". Bound to
X * "C-X C-X".
X */
Xswapmark(f, n)
X{
X        register LINE   *odotp;
X        register int    odoto;
X
X        if (curwp->w_markp == NULL) {
X                mlwrite("No mark in this window");
X                return (FALSE);
X        }
X        odotp = curwp->w_dotp;
X        odoto = curwp->w_doto;
X        curwp->w_dotp  = curwp->w_markp;
X        curwp->w_doto  = curwp->w_marko;
X        curwp->w_markp = odotp;
X        curwp->w_marko = odoto;
X        curwp->w_flag |= WFMOVE;
X        return (TRUE);
X}
END_OF_basic.c
if test 12220 -ne `wc -c <basic.c`; then
    echo shar: \"basic.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"efunc.h\" \(14637 characters\)
if test -f efunc.h ; then 
  echo shar: Will not over-write existing file \"efunc.h\"
else
sed "s/^X//" >efunc.h <<'END_OF_efunc.h'
X/*	EFUNC.H:	MicroEMACS function declarations and names
X
X		This file list all the C code functions used by MicroEMACS
X	and the names to use to bind keys to them. To add functions,
X	declare it here in both the extern function list and the name
X	binding table.
X
X*/
X
X/*	External function declarations		*/
X
Xextern  int     ctrlg();                /* Abort out of things          */
Xextern  int     quit();                 /* Quit                         */
Xextern  int     ctlxlp();               /* Begin macro                  */
Xextern  int     ctlxrp();               /* End macro                    */
Xextern  int     ctlxe();                /* Execute macro                */
Xextern  int     fileread();             /* Get a file, read only        */
Xextern  int     filefind();		/* Get a file, read write       */
Xextern  int     filewrite();            /* Write a file                 */
Xextern  int     filesave();             /* Save current file            */
Xextern  int     filename();             /* Adjust file name             */
Xextern  int     getccol();              /* Get current column           */
Xextern  int     gotobol();              /* Move to start of line        */
Xextern  int     forwchar();             /* Move forward by characters   */
Xextern  int     gotoeol();              /* Move to end of line          */
Xextern  int     backchar();             /* Move backward by characters  */
Xextern  int     forwline();             /* Move forward by lines        */
Xextern  int     backline();             /* Move backward by lines       */
Xextern  int     forwpage();             /* Move forward by pages        */
Xextern  int     backpage();             /* Move backward by pages       */
Xextern  int     gotobob();              /* Move to start of buffer      */
Xextern  int     gotoeob();              /* Move to end of buffer        */
Xextern  int     setfillcol();           /* Set fill column.             */
Xextern  int     setmark();              /* Set mark                     */
Xextern  int     swapmark();             /* Swap "." and mark            */
Xextern  int     forwsearch();           /* Search forward               */
Xextern  int     backsearch();           /* Search backwards             */
Xextern	int	sreplace();		/* search and replace		*/
Xextern	int	qreplace();		/* search and replace w/query	*/
Xextern  int     showcpos();             /* Show the cursor position     */
Xextern  int     nextwind();             /* Move to the next window      */
Xextern  int     prevwind();             /* Move to the previous window  */
Xextern  int     onlywind();             /* Make current window only one */
Xextern  int     splitwind();            /* Split current window         */
Xextern  int     mvdnwind();             /* Move window down             */
Xextern  int     mvupwind();             /* Move window up               */
Xextern  int     enlargewind();          /* Enlarge display window.      */
Xextern  int     shrinkwind();           /* Shrink window.               */
Xextern  int     listbuffers();          /* Display list of buffers      */
Xextern  int     usebuffer();            /* Switch a window to a buffer  */
Xextern  int     killbuffer();           /* Make a buffer go away.       */
Xextern  int     reposition();           /* Reposition window            */
Xextern  int     refresh();              /* Refresh the screen           */
Xextern  int     twiddle();              /* Twiddle characters           */
Xextern  int     tab();                  /* Insert tab                   */
Xextern  int     newline();              /* Insert CR-LF                 */
Xextern  int     indent();               /* Insert CR-LF, then indent    */
Xextern  int     openline();             /* Open up a blank line         */
Xextern  int     deblank();              /* Delete blank lines           */
Xextern  int     quote();                /* Insert literal               */
Xextern  int     backword();             /* Backup by words              */
Xextern  int     forwword();             /* Advance by words             */
Xextern  int     forwdel();              /* Forward delete               */
Xextern  int     backdel();              /* Backward delete              */
Xextern  int     killtext();             /* Kill forward                 */
Xextern  int     yank();                 /* Yank back from killbuffer.   */
Xextern  int     upperword();            /* Upper case word.             */
Xextern  int     lowerword();            /* Lower case word.             */
Xextern  int     upperregion();          /* Upper case region.           */
Xextern  int     lowerregion();          /* Lower case region.           */
Xextern  int     capword();              /* Initial capitalize word.     */
Xextern  int     delfword();             /* Delete forward word.         */
Xextern  int     delbword();             /* Delete backward word.        */
Xextern  int     killregion();           /* Kill region.                 */
Xextern  int     copyregion();           /* Copy region to kill buffer.  */
Xextern  int     spawncli();             /* Run CLI in a subjob.         */
Xextern  int     spawn();                /* Run a command in a subjob.   */
X#if	BSD
Xextern	int	bktoshell();		/* suspend emacs to parent shell*/
Xextern	int	rtfrmshell();		/* return from a suspended state*/
X#endif
Xextern  int     quickexit();            /* low keystroke style exit.    */
Xextern	int	setmode();		/* set an editor mode		*/
Xextern	int	delmode();		/* delete a mode		*/
Xextern	int	gotoline();		/* go to a numbered line	*/
Xextern	int	namebuffer();		/* rename the current buffer	*/
X#if	WORDPRO
Xextern	int	gotobop();		/* go to beginning/paragraph	*/
Xextern	int	gotoeop();		/* go to end/paragraph		*/
Xextern	int	fillpara();		/* fill current paragraph	*/
X#endif
Xextern	int	help();			/* get the help file here	*/
Xextern	int	deskey();		/* describe a key's binding	*/
Xextern	int	viewfile();		/* find a file in view mode	*/
Xextern	int	insfile();		/* insert a file		*/
Xextern	int	scrnextup();		/* scroll next window back	*/
Xextern	int	scrnextdw();		/* scroll next window down	*/
Xextern	int	bindtokey();		/* bind a function to a key	*/
Xextern	int	unbindkey();		/* unbind a key's function	*/
Xextern	int	namedcmd();		/* execute named command	*/
Xextern	int	desbind();		/* describe bindings		*/
Xextern	int	execcmd();		/* execute a command line	*/
Xextern	int	execbuf();		/* exec commands from a buffer	*/
Xextern	int	execfile();		/* exec commands from a file	*/
Xextern	int	nextbuffer();		/* switch to the next buffer	*/
X#if	WORDPRO
Xextern	int	killpara();		/* kill the current paragraph	*/
X#endif
Xextern	int	setgmode();		/* set a global mode		*/
Xextern	int	delgmode();		/* delete a global mode		*/
Xextern	int	insspace();		/* insert a space forword	*/
Xextern	int	forwhunt();		/* hunt forward for next match	*/
Xextern	int	backhunt();		/* hunt backwards for next match*/
Xextern	int	pipe();			/* pipe command into buffer	*/
Xextern	int	filter();		/* filter buffer through dos	*/
Xextern	int	delwind();		/* delete the current window	*/
Xextern	int	cbuf1();		/* execute numbered comd buffer */
Xextern	int	cbuf2();
Xextern	int	cbuf3();
Xextern	int	cbuf4();
Xextern	int	cbuf5();
Xextern	int	cbuf6();
Xextern	int	cbuf7();
Xextern	int	cbuf8();
Xextern	int	cbuf9();
Xextern	int	cbuf10();
Xextern	int	cbuf11();
Xextern	int	cbuf12();
Xextern	int	cbuf13();
Xextern	int	cbuf14();
Xextern	int	cbuf15();
Xextern	int	cbuf16();
Xextern	int	cbuf17();
Xextern	int	cbuf18();
Xextern	int	cbuf19();
Xextern	int	cbuf20();
Xextern	int	cbuf21();
Xextern	int	cbuf22();
Xextern	int	cbuf23();
Xextern	int	cbuf24();
Xextern	int	cbuf25();
Xextern	int	cbuf26();
Xextern	int	cbuf27();
Xextern	int	cbuf28();
Xextern	int	cbuf29();
Xextern	int	cbuf30();
Xextern	int	cbuf31();
Xextern	int	cbuf32();
Xextern	int	cbuf33();
Xextern	int	cbuf34();
Xextern	int	cbuf35();
Xextern	int	cbuf36();
Xextern	int	cbuf37();
Xextern	int	cbuf38();
Xextern	int	cbuf39();
Xextern	int	cbuf40();
Xextern	int	storemac();		/* store text for macro		*/
Xextern	int	resize();		/* resize current window	*/
Xextern	int	clrmes();		/* clear the message line	*/
Xextern	int	meta();			/* meta prefix dummy function	*/
Xextern	int	cex();			/* ^X prefix dummy function	*/
Xextern	int	unarg();		/* ^U repeat arg dummy function	*/
Xextern	int	istring();		/* insert string in text	*/
Xextern	int	unmark();		/* unmark current buffer	*/
X#if	ISRCH
Xextern	int	fisearch();		/* forward incremental search	*/
Xextern	int	risearch();		/* reverse incremental search	*/
X#endif
X#if	WORDPRO
Xextern	int	wordcount();		/* count words in region	*/
X#endif
Xextern	int	savewnd();		/* save current window		*/
Xextern	int	restwnd();		/* restore current window	*/
Xextern	int	upscreen();		/* force screen update		*/
Xextern	int	writemsg();		/* write text on message line	*/
X#if	FLABEL
Xextern	int	fnclabel();		/* set function key label	*/
X#endif
X#if	APROP
Xextern	int	apro();			/* apropos fuction		*/
X#endif
X#if	CRYPT
Xextern	int	setkey();		/* set encryption key		*/
X#endif
Xextern	int	wrapword();		/* wordwrap function		*/
X#if	CFENCE
Xextern	int	getfence();		/* move cursor to a matching fence */
X#endif
Xextern	int	newsize();		/* change the current screen size */
Xextern	int	setvar();		/* set a variables value */
Xextern	int	newwidth();		/* change the current screen width */
X
X/*	Name to function binding table
X
X		This table gives the names of all the bindable functions
X	end their C function address. These are used for the bind-to-key
X	function.
X*/
X
XNBIND	names[] = {
X	{"abort-command",		ctrlg},
X	{"add-mode",			setmode},
X	{"add-global-mode",		setgmode},
X#if	APROP
X	{"apropos",			apro},
X#endif
X	{"backward-character",		backchar},
X	{"begin-macro",			ctlxlp},
X	{"beginning-of-file",		gotobob},
X	{"beginning-of-line",		gotobol},
X	{"bind-to-key",			bindtokey},
X	{"buffer-position",		showcpos},
X	{"case-region-lower",		lowerregion},
X	{"case-region-upper",		upperregion},
X	{"case-word-capitalize",	capword},
X	{"case-word-lower",		lowerword},
X	{"case-word-upper",		upperword},
X	{"change-file-name",		filename},
X	{"change-screen-size",		newsize},
X	{"change-screen-width",		newwidth},
X	{"clear-and-redraw",		refresh},
X	{"clear-message-line",		clrmes},
X	{"copy-region",			copyregion},
X#if	WORDPRO
X	{"count-words",			wordcount},
X#endif
X	{"ctlx-prefix",			cex},
X	{"delete-blank-lines",		deblank},
X	{"delete-buffer",		killbuffer},
X	{"delete-mode",			delmode},
X	{"delete-global-mode",		delgmode},
X	{"delete-next-character",	forwdel},
X	{"delete-next-word",		delfword},
X	{"delete-other-windows",	onlywind},
X	{"delete-previous-character",	backdel},
X	{"delete-previous-word",	delbword},
X	{"delete-window",		delwind},
X	{"describe-bindings",		desbind},
X	{"describe-key",		deskey},
X	{"end-macro",			ctlxrp},
X	{"end-of-file",			gotoeob},
X	{"end-of-line",			gotoeol},
X	{"exchange-point-and-mark",	swapmark},
X	{"execute-buffer",		execbuf},
X	{"execute-command-line",	execcmd},
X	{"execute-file",		execfile},
X	{"execute-macro",		ctlxe},
X	{"execute-macro-1",		cbuf1},
X	{"execute-macro-2",		cbuf2},
X	{"execute-macro-3",		cbuf3},
X	{"execute-macro-4",		cbuf4},
X	{"execute-macro-5",		cbuf5},
X	{"execute-macro-6",		cbuf6},
X	{"execute-macro-7",		cbuf7},
X	{"execute-macro-8",		cbuf8},
X	{"execute-macro-9",		cbuf9},
X	{"execute-macro-10",		cbuf10},
X	{"execute-macro-11",		cbuf11},
X	{"execute-macro-12",		cbuf12},
X	{"execute-macro-13",		cbuf13},
X	{"execute-macro-14",		cbuf14},
X	{"execute-macro-15",		cbuf15},
X	{"execute-macro-16",		cbuf16},
X	{"execute-macro-17",		cbuf17},
X	{"execute-macro-18",		cbuf18},
X	{"execute-macro-19",		cbuf19},
X	{"execute-macro-20",		cbuf20},
X	{"execute-macro-21",		cbuf21},
X	{"execute-macro-22",		cbuf22},
X	{"execute-macro-23",		cbuf23},
X	{"execute-macro-24",		cbuf24},
X	{"execute-macro-25",		cbuf25},
X	{"execute-macro-26",		cbuf26},
X	{"execute-macro-27",		cbuf27},
X	{"execute-macro-28",		cbuf28},
X	{"execute-macro-29",		cbuf29},
X	{"execute-macro-30",		cbuf30},
X	{"execute-macro-31",		cbuf31},
X	{"execute-macro-32",		cbuf32},
X	{"execute-macro-33",		cbuf33},
X	{"execute-macro-34",		cbuf34},
X	{"execute-macro-35",		cbuf35},
X	{"execute-macro-36",		cbuf36},
X	{"execute-macro-37",		cbuf37},
X	{"execute-macro-38",		cbuf38},
X	{"execute-macro-39",		cbuf39},
X	{"execute-macro-40",		cbuf40},
X	{"execute-named-command",	namedcmd},
X	{"exit-emacs",			quit},
X#if	WORDPRO
X	{"fill-paragraph",		fillpara},
X#endif
X	{"filter-buffer",		filter},
X	{"find-file",			filefind},
X	{"forward-character",		forwchar},
X	{"goto-line",			gotoline},
X#if	CFENCE
X	{"goto-matching-fence",		getfence},
X#endif
X	{"grow-window",			enlargewind},
X	{"handle-tab",			tab},
X	{"hunt-forward",		forwhunt},
X	{"hunt-backward",		backhunt},
X	{"help",			help},
X	{"i-shell",			spawncli},
X#if	ISRCH
X	{"incremental-search",		fisearch},
X#endif
X	{"insert-file",			insfile},
X	{"insert-space",		insspace},
X	{"insert-string",		istring},
X#if	WORDPRO
X	{"kill-paragraph",		killpara},
X#endif
X	{"kill-region",			killregion},
X	{"kill-to-end-of-line",		killtext},
X#if	FLABEL
X	{"label-function-key",		fnclabel},
X#endif
X	{"list-buffers",		listbuffers},
X	{"meta-prefix",			meta},
X	{"move-window-down",		mvdnwind},
X	{"move-window-up",		mvupwind},
X	{"name-buffer",			namebuffer},
X	{"newline",			newline},
X	{"newline-and-indent",		indent},
X	{"next-buffer",			nextbuffer},
X	{"next-line",			forwline},
X	{"next-page",			forwpage},
X#if	WORDPRO
X	{"next-paragraph",		gotoeop},
X#endif
X	{"next-window",			nextwind},
X	{"next-word",			forwword},
X	{"open-line",			openline},
X	{"pipe-command",		pipe},
X	{"previous-line",		backline},
X	{"previous-page",		backpage},
X#if	WORDPRO
X	{"previous-paragraph",		gotobop},
X#endif
X	{"previous-window",		prevwind},
X	{"previous-word",		backword},
X	{"query-replace-string",	qreplace},
X	{"quick-exit",			quickexit},
X	{"quote-character",		quote},
X	{"read-file",			fileread},
X	{"redraw-display",		reposition},
X	{"resize-window",		resize},
X	{"restore-window",		restwnd},
X	{"replace-string",		sreplace},
X#if	ISRCH
X	{"reverse-incremental-search",	risearch},
X#endif
X	{"save-file",			filesave},
X	{"save-window",			savewnd}X	{"search-forward",		forwsearch},
X	{"search-reverse",		backsearch},
X	{"select-buffer",		usebuffer},
X	{"set",				setvar},
X#if	CRYPT
X	{"set-encryption-key",		setkey},
X#endif
X	{"set-fill-column",		setfillcol},
X	{"set-mark",			setmark},
X	{"shell-command",		spawn},
X	{"shrink-window",		shrinkwind},
X	{"split-current-window",	splitwind},
X	{"store-macro",			storemac},
X#if	BSD
X	{"suspend-emacs",		bktoshell},
X#endif
X	{"transpose-characters",	twiddle},
X	{"unbind-key",			unbindkey},
X	{"universal-argument",		unarg},
X	{"unmark-buffer",		unmark},
X	{"update-screen",		upscreen},
X	{"view-file",			viewfile},
X	{"wrap-word",			wrapword},
X	{"write-file",			filewrite},
X	{"write-message",		writemsg},
X	{"yank",			yank},
X
X	{"",			NULL}
X};
END_OF_efunc.h
if test 14637 -ne `wc -c <efunc.h`; then
    echo shar: \"efunc.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"termio.c\" \(12539 characters\)
if test -f termio.c ; then 
  echo shar: Will not over-write existing file \"termio.c\"
else
sed "s/^X//" >termio.c <<'END_OF_termio.c'
X/*
X * The functions in this file negotiate with the operating system for
X * characters, and write characters in a barely buffered fashion on the display.
X * All operating systems.
X */
X#include        <stdio.h>
X#include	"estruct.h"
X#include        "edef.h"
X
X#if	MEGAMAX & ST520
Xoverlay	"termio"
X#endif
X
X#if     AMIGA
X#define NEW 1006
X#define AMG_MAXBUF      1024L
Xstatic long terminal;
Xstatic char     scrn_tmp[AMG_MAXBUF+1];
Xstatic long     scrn_tmp_p = 0;
X#endif
X
X#if ST520
X#include <osbind.h>
X	int STscancode = 0;	
X#endif
X
X#if     VMS
X#include        <stsdef.h>
X#include        <ssdef.h>
X#include        <descrip.h>
X#include        <iodef.h>
X#include        <ttdef.h>
X#include	<tt2def.h>
X
X#define NIBUF   128                     /* Input buffer size            */
X#define NOBUF   1024                    /* MM says bug buffers win!     */
X#define EFN     0                       /* Event flag                   */
X
Xchar    obuf[NOBUF];                    /* Output buffer                */
Xint     nobuf;                  /* # of bytes in above    */
Xchar    ibuf[NIBUF];                    /* Input buffer          */
Xint     nibuf;                  /* # of bytes in above  */
Xint     ibufi;                  /* Read index                   */
Xint     oldmode[3];                     /* Old TTY mode bits            */
Xint     newmode[3];                     /* New TTY mode bits            */
Xshort   iochan;                  /* TTY I/O channel             */
X#endif
X
X#if     CPM
X#include        <bdos.h>
X#endif
X
X#if     MSDOS & (LATTICE | MSC | AZTEC | MWC86)
Xunion REGS rg;		/* cpu register for use of DOS calls */
Xint nxtchar = -1;	/* character held from type ahead    */
X#endif
X
X#if RAINBOW
X#include "rainbow.h"
X#endif
X
X#if	USG			/* System V */
X#include	<signal.h>
X#include	<termio.h>
Xstruct	termio	otermio;	/* original terminal characteristics */
Xstruct	termio	ntermio;	/* charactoristics to use inside */
X#endif
X
X#if V7 | BSD
X#undef	CTRL
X#include        <sgtty.h>        /* for stty/gtty functions */
X#include	<signal.h>
Xstruct  sgttyb  ostate;          /* saved tty state */
Xstruct  sgttyb  nstate;          /* values for editor mode */
Xstruct tchars	otchars;	/* Saved terminal special character set */
Xstruct tchars	ntchars = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
X				/* A lot of nothing */
X#if BSD
X#include <sys/ioctl.h>		/* to get at the typeahead */
Xextern	int rtfrmshell();	/* return from suspended shell */
X#define	TBUFSIZ	128
Xchar tobuf[TBUFSIZ];		/* terminal output buffer */
X#endif
X#endif
X
X/*
X * This function is called once to set up the terminal device streams.
X * On VMS, it translates TT until it finds the terminal, then assigns
X * a channel to it and sets it raw. On CPM it is a no-op.
X */
Xttopen()
X{
X#if     AMIGA
X        terminal = Open("RAW:1/1/639/199/MicroEMACS 3.7/Amiga", NEW);
X#endif
X#if     VMS
X        struct  dsc$descriptor  idsc;
X        struct  dsc$descriptor  odsc;
X        char    oname[40];
X        int     iosb[2];
X        int     status;
X
X        odsc.dsc$a_pointer = "TT";
X        odsc.dsc$w_length  = strlen(odsc.dsc$a_pointer);
X        odsc.dsc$b_dtype        = DSC$K_DTYPE_T;
X        odsc.dsc$b_class        = DSC$K_CLASS_S;
X        idsc.dsc$b_dtype        = DSC$K_DTYPE_T;
X        idsc.dsc$b_class        = DSC$K_CLASS_S;
X        do {
X                idsc.dsc$a_pointer = odsc.dsc$a_pointer;
X                idsc.dsc$w_length  = odsc.dsc$w_length;
X                odsc.dsc$a_pointer = &oname[0];
X                odsc.dsc$w_length  = sizeof(oname);
X                status = LIB$SYS_TRNLOG(&idsc, &odsc.dsc$w_length, &odsc);
X                if (status!=SS$_NORMAL && status!=SS$_NOTRAN)
X                        exit(status);
X                if (oname[0] == 0x1B) {
X                        odsc.dsc$a_pointer += 4;
X                        odsc.dsc$w_length  -= 4;
X                }
X        } while (status == SS$_NORMAL);
X        status = SYS$ASSIGN(&odsc, &iochan, 0, 0);
X        if (status != SS$_NORMAL)
X                exit(status);
X        status = SYS$QIOW(EFN, iochan, IO$_SENSEMODE, iosb, 0, 0,
X                          oldmode, sizeof(oldmode), 0, 0, 0, 0);
X        if (status!=SS$_NORMAL || (iosb[0]&0xFFFF)!=SS$_NORMAL)
X                exit(status);
X        newmode[0] = oldmode[0];
X        newmode[1] = oldmode[1] | TT$M_NOECHO;
X        newmode[1] &= ~(TT$M_TTSYNC|TT$M_HOSTSYNC);
X        newmode[2] = oldmode[2] | TT2$M_PASTHRU;
X        status = SYS$QIOW(EFN, iochan, IO$_SETMODE, iosb, 0, 0,
X                          newmode, sizeof(newmode), 0, 0, 0, 0);
X        if (status!=SS$_NORMAL || (iosb[0]&0xFFFF)!=SS$_NORMAL)
X                exit(status);
X        term.t_nrow = (newmode[1]>>24) - 1;
X        term.t_ncol = newmode[0]>>16;
X
X#endif
X#if     CPM
X#endif
X
X#if     MSDOS & (HP150 == 0) & LATTICE
X	/* kill the ctrl-break interupt */
X	rg.h.ah = 0x33;		/* control-break check dos call */
X	rg.h.al = 1;		/* set the current state */
X	rg.h.dl = 0;		/* set it OFF */
X	intdos(&rg, &rg);	/* go for it! */
X#endif
X
X#if	USG
X	ioctl(0, TCGETA, &otermio);	/* save old settings */
X	ntermio.c_iflag = 0;		/* setup new settings */
X	ntermio.c_oflag = 0;
X	ntermio.c_cflag = otermio.c_cflag;
X	ntermio.c_lflag = 0;
X	ntermio.c_line = otermio.c_line;
X	ntermio.c_cc[VMIN] = 1;
X	ntermio.c_cc[VTIME] = 0;
X	ioctl(0, TCSETA, &ntermio);	/* and activate them */
X#endif
X
X#if     V7 | BSD
X        gtty(0, &ostate);                       /* save old state */
X        gtty(0, &nstate);                       /* get base of new state */
X        nstate.sg_flags |= RAW;
X        nstate.sg_flags &= ~(ECHO|CRMOD);       /* no echo for now... */
X        stty(0, &nstate);                       /* set mode */
X	ioctl(0, TIOCGETC, &otchars);		/* Save old characters */
X	ioctl(0, TIOCSETC, &ntchars);		/* Place new character into K */
X#if	BSD
X	/* provide a smaller terminal output buffer so that
X	   the type ahead detection works better (more often) */
X	setbuffer(stdout, &tobuf[0], TBUFSIZ);
X	signal(SIGTSTP,SIG_DFL);	/* set signals so that we can */
X	signal(SIGCONT,rtfrmshell);	/* suspend & restart emacs */
X#endif
X#endif
X	/* on all screens we are not sure of the initial position
X	   of the cursor					*/
X	ttrow = 999;
X	ttcol = 999;
X}
X
X/*
X * This function gets called just before we go back home to the command
X * interpreter. On VMS it puts the terminal back in a reasonable state.
X * Another no-operation on CPM.
X */
Xttclose()
X{
X#if     AMIGA
X        amg_flush();
X        Close(terminal);
X#endif
X#if     VMS
X        int     status;
X        int     iosb[1];
X
X        ttflush();
X        status = SYS$QIOW(EFN, iochan, IO$_SETMODE, iosb, 0, 0,
X                 oldmode, sizeof(oldmode), 0, 0, 0, 0);
X        if (status!=SS$_NORMAL || (iosb[0]&0xFFFF)!=SS$_NORMAL)
X                exit(status);
X        status = SYS$DASSGN(iochan);
X        if (status != SS$_NORMAL)
X                exit(status);
X#endif
X#if     CPM
X#endif
X#if     MSDOS & (HP150 == 0) & LATTICE
X	/* restore the ctrl-break interupt */
X	rg.h.ah = 0x33;		/* control-break check dos call */
X	rg.h.al = 1;		/* set the current state */
X	rg.h.dl = 1;		/* set it ON */
X	intdos(&rg, &rg);	/* go for it! */
X#endif
X
X#if	USG
X	ioctl(0, TCSETA, &otermio);	/* restore terminal settings */
X#endif
X
X#if     V7 | BSD
X        stty(0, &ostate);
X	ioctl(0, TIOCSETC, &otchars);	/* Place old character into K */
X#endif
X}
X
X/*
X * Write a character to the display. On VMS, terminal output is buffered, and
X * we just put the characters in the big array, after checking for overflow.
X * On CPM terminal I/O unbuffered, so we just write the byte out. Ditto on
X * MS-DOS (use the very very raw console output routine).
X */
Xttputc(c)
X#if     AMIGA | ST520
X        char c;
X#endif
X{
X#if     AMIGA
X        scrn_tmp[scrn_tmp_p++] = c;
X        if(scrn_tmp_p>=AMG_MAXBUF)
X                amg_flush();
X#endif
X#if	ST520
X	Bconout(2,c);
X#endif
X#if     VMS
X        if (nobuf >= NOBUF)
X                ttflush();
X        obuf[nobuf++] = c;
X#endif
X
X#if     CPM
X        bios(BCONOUT, c, 0);
X#endif
X
X#if     MSDOS & MWC86
X        putcnb(c);
X#endif
X
X#if	MSDOS & (LATTICE | AZTEC) & ~IBMPC
X	bdos(6, c, 0);
X#endif
X
X#if RAINBOW
X        Put_Char(c);                    /* fast video */
X#endif
X
X
X#if     V7 | USG | BSD
X        fputc(c, stdout);
X#endif
X}
X
X#if	AMIGA
Xamg_flush()
X{
X        if(scrn_tmp_p)
X                Write(terminal,scrn_tmp,scrn_tmp_p);
X        scrn_tmp_p = 0;
X}
X#endif
X
X/*
X * Flush terminal buffer. Does real work where the terminal output is buffered
X * up. A no-operation on systems where byte at a time terminal I/O is done.
X */
Xttflush()
X{
X#if     AMIGA
X        amg_flush();
X#endif
X#if     VMS
X        int     status;
X        int     iosb[2];
X
X        status = SS$_NORMAL;
X        if (nobuf != 0) {
X                status = SYS$QIOW(EFN, iochan, IO$_WRITELBLK|IO$M_NOFORMAT,
X                         iosb, 0, 0, obuf, nobuf, 0, 0, 0, 0);
X                if (status == SS$_NORMAL)
X                        status = iosb[0] & 0xFFFF;
X                nobuf = 0;
X        }
X        return (status);
X#endif
X
X#if     CPM
X#endif
X
X#if     MSDOS
X#endif
X
X#if     V7 | USG | BSD
X        fflush(stdout);
X#endif
X}
X
X/*
X * Read a character from the terminal, performing no editing and doing no echo
X * at all. More complex in VMS that almost anyplace else, which figures. Very
X * simple on CPM, because the system can do exactly what you want.
X */
Xttgetc()
X{
X#if     AMIGA
X        char ch;
X        amg_flush();
X        Read(terminal, &ch, 1L);
X        return(255 & (int)ch);
X#endif
X#if	ST520
X	long ch;
X/*
X * blink the cursor only if nothing is happening, this keeps the
X * cursor on steadily during movement making it easier to track
X */
X	STcurblink(TRUE);  /* the cursor blinks while we wait */
X	ch = Bconin(2);
X	STcurblink(FALSE); /* the cursor is steady while we work */
X	STscancode = (ch >> 16) & 0xff;
X       	return(255 & (int)ch);
X#endif
X#if     VMS
X        int     status;
X        int     iosb[2];
X        int     term[2];
X
X        while (ibufi >= nibuf) {
X                ibufi = 0;
X                term[0] = 0;
X                term[1] = 0;
X                status = SYS$QIOW(EFN, iochan, IO$_READLBLK|IO$M_TIMED,
X                         iosb, 0, 0, ibuf, NIBUF, 0, term, 0, 0);
X                if (status != SS$_NORMAL)
X                        exit(status);
X                status = iosb[0] & 0xFFFF;
X                if (status!=SS$_NORMAL && status!=SS$_TIMEOUT)
X                        exit(status);
X                nibuf = (iosb[0]>>16) + (iosb[1]>>16);
X                if (nibuf == 0) {
X                        status = SYS$QIOW(EFN, iochan, IO$_READLBLK,
X                                 iosb, 0, 0, ibuf, 1, 0, term, 0, 0);
X                        if (status != SS$_NORMAL
X                        || (status = (iosb[0]&0xFFFF)) != SS$_NORMAL)
X                                exit(status);
X                        nibuf = (iosb[0]>>16) + (iosb[1]>>16);
X                }
X        }
X        return (ibuf[ibufi++] & 0xFF);    /* Allow multinational  */
X#endif
X
X#if     CPM
X        return (biosb(BCONIN, 0, 0));
X#endif
X
X#if RAINBOW
X        int Ch;
X
X        while ((Ch = Read_Keyboard()) < 0);
X
X        if ((Ch & Function_Key) == 0)
X                if (!((Ch & 0xFF) == 015 || (Ch & 0xFF) == 0177))
X                        Ch &= 0xFF;
X
X        return Ch;
X#endif
X
X#if     MSDOS & MWC86
X        return (getcnb());
X#endif
X
X#if	MSDOS & (LATTICE | MSC | AZTEC)
X	int c;		/* character read */
X
X	/* if a char already is ready, return it */
X	if (nxtchar >= 0) {
X		c = nxtchar;
X		nxtchar = -1;
X		return(c);
X	}
X
X	/* call the dos to get a char */
X	rg.h.ah = 7;		/* dos Direct Console Input call */
X	intdos(&rg, &rg);
X	c = rg.h.al;		/* grab the char */
X	return(c & 255);
X#endif
X
X#if     V7 | USG | BSD
X        return(127 & fgetc(stdin));
X#endif
X}
X
X#if	TYPEAH
X/* typahead:	Check to see if any characters are already in the
X		keyboard buffer
X*/
X
Xtypahead()
X
X{
X#if	MSDOS & (LATTICE | AZTEC | MWC86)
X	int c;		/* character read */
X	int flags;	/* cpu flags from dos call */
X
X#if	MSC
X	if (kbhit() != 0)
X		return(TRUE);
X	else
X		return(FALSE);
X#endif
X
X	if (nxtchar >= 0)
X		return(TRUE);
X
X	rg.h.ah = 6;	/* Direct Console I/O call */
X	rg.h.dl = 255;	/*         does console input */
X#if	LATTICE | AZTEC
X	flags = intdos(&rg, &rg);
X#else
X	intcall(&rg, &rg, 0x21);
X	flags = rg.x.flags;
X#endif
X	c = rg.h.al;	/* grab the character */
X
X	/* no character pending */
X	if ((flags & 64) != 0)
X		return(FALSE);
X
X	/* save the character and return true */
X	nxtchar = c;
X	return(TRUE);
X#endif
X
X#if	BSD
X	int x;	/* holds # of pending chars */
X
X	return((ioctl(0,FIONREAD,&x) < 0) ? 0 : x);
X#endif
X	return(FALSE);
X}
X#endif
X
END_OF_termio.c
if test 12539 -ne `wc -c <termio.c`; then
    echo shar: \"termio.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 5 \(of 14\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    echo "See the readme file"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
