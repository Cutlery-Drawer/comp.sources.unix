Subject:  v09i033:  MicroEMACS, version 3.8b, Part01/14
Approved: rs@mirror.TMC.COM
Path: mirror!sources-request
From: sources-request@mirror.TMC.COM
Newsgroups: comp.sources.unix
Message-ID: <2284@mirror.TMC.COM>
Sender: rs@mirror.TMC.COM
Approved: rs@mirror.TMC.COM
Lines: 2497

Submitted by: ihnp4!itivax!duncan!lawrence (Daniel Lawrence)
Mod.sources: Volume 9, Issue 33
Archive-name: uemacs3.8b/Part01

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If this archive is complete, you will see the message:
#		"End of archive 1 (of 14)."
# Contents:  MANIFEST Makefile ansi.c azmap.cmd bdata.cmd dg10.c
#   emacs.rc epath.h esearch.h evar.h fileio.c hp110.c ibmfn.lst
#   lock.c magic.doc me110.rc me150.rc tcap.c vt52.c
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"MANIFEST\" \(1764 characters\)
if test -f MANIFEST ; then 
  echo shar: Will not over-write existing file \"MANIFEST\"
else
sed "s/^X//" >MANIFEST <<'END_OF_MANIFEST'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                  1	This shipping list
X Makefile                  1	
X ansi.c                    1	
X azmap.cmd                 1	
X basic.c                   5	
X bdata.cmd                 1	
X bind.c                    6	
X buffer.c                  6	
X crypt.c                   2	
X dg10.c                    1	
X display.c                11	
X ebind.h                   4	
X edef.h                    3	
X efunc.h                   5	
X egapc.c                   2	
X emacs.hlp                 3	
X emacs.key                 2	
X emacs.rc                  1	
X emacs.tut                11	
X emacs1.mss               14	
X epath.h                   1	
X esearch.h                 1	
X estruct.h                 8	
X eval.c                    4	
X evar.h                    1	
X exec.c                    7	
X file.c                    9	
X fileio.c                  1	
X hp110.c                   1	
X hp150.c                   3	
X ibmfn.lst                 1	
X ibmpc.c                   2	
X input.c                   3	
X isearch.c                 9	
X line.c                   10	
X lock.c                    1	
X magic.doc                 1	
X main.c                   13	
X me110.rc                  1	
X me150.rc                  1	
X menu.cmd                  4	
X menu1                     3	
X random.c                 10	
X readme                    8	
X region.c                  2	
X search.c                 12	
X spawn.c                   7	
X st520.c                   4	
X tcap.c                    1	
X termio.c                  5	
X tipc.c                    2	
X vmsvt.c                   2	
X vt52.c                    1	
X window.c                  7	
X word.c                    6	
END_OF_MANIFEST
if test 1764 -ne `wc -c <MANIFEST`; then
    echo shar: \"MANIFEST\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"Makefile\" \(585 characters\)
if test -f Makefile ; then 
  echo shar: Will not over-write existing file \"Makefile\"
else
sed "s/^X//" >Makefile <<'END_OF_Makefile'
XCFLAGS=		-O
X
XOFILES=		ansi.o basic.o bind.o buffer.o display.o file.o \
X		fileio.o hp150.o line.o lock.c main.o random.o region.o \
X		search.o spawn.o tcap.o termio.o vt52.o window.o word.o \
X		exec.o eval.o isearch.o
X
XCFILES=		ansi.c basic.c bind.c buffer.c display.c  file.c \
X		fileio.c hp150.c line.c lock.c main.c random.c region.c \
X		search.c spawn.c tcap.c termio.c vt52.c window.c word.c \
X		exec.c eval.c isearch.c
X
XHFILES=		estruct.h edef.h efunc.h epath.h ebind.h evar.h esearch.h
X
Xemacs:		$(OFILES)
X		$(CC) $(CFLAGS) $(OFILES) -ltermcap -lc -o emacs
X
X$(OFILES):	$(HFILES)
END_OF_Makefile
if test 585 -ne `wc -c <Makefile`; then
    echo shar: \"Makefile\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"ansi.c\" \(4419 characters\)
if test -f ansi.c ; then 
  echo shar: Will not over-write existing file \"ansi.c\"
else
sed "s/^X//" >ansi.c <<'END_OF_ansi.c'
X/*
X * The routines in this file provide support for ANSI style terminals
X * over a serial line. The serial I/O services are provided by routines in
X * "termio.c". It compiles into nothing if not an ANSI device.
X */
X
X#define	termdef	1			/* don't define "term" external */
X
X#include        <stdio.h>
X#include	"estruct.h"
X#include        "edef.h"
X
X#if     ANSI
X
X#if	AMIGA
X#define NROW    23                      /* Screen size.                 */
X#define NCOL    77                      /* Edit if you want to.         */
X#else
X#define NROW    25                      /* Screen size.                 */
X#define NCOL    80                      /* Edit if you want to.         */
X#endif
X#define	NPAUSE	100			/* # times thru update to pause */
X#define	MARGIN	8			/* size of minimim margin and	*/
X#define	SCRSIZ	64			/* scroll size for extended lines */
X#define BEL     0x07                    /* BEL character.               */
X#define ESC     0x1B                    /* ESC character.               */
X
Xextern  int     ttopen();               /* Forward references.          */
Xextern  int     ttgetc();
Xextern  int     ttputc();
Xextern  int     ttflush();
Xextern  int     ttclose();
Xextern  int     ansimove();
Xextern  int     ansieeol();
Xextern  int     ansieeop();
Xextern  int     ansibeep();
Xextern  int     ansiopen();
Xextern	int	ansirev();
Xextern	int	ansiclose();
Xextern	int	ansikopen();
Xextern	int	ansikclose();
Xextern	int	ansicres();
X
X#if	COLOR
Xextern	int	ansifcol();
Xextern	int	ansibcol();
X
Xint	cfcolor = -1;		/* current forground color */
Xint	cbcolor = -1;		/* current background color */
X#endif
X
X/*
X * Standard terminal interface dispatch table. Most of the fields point into
X * "termio" code.
X */
XTERM    term    = {
X	NROW-1,
X        NROW-1,
X        NCOL,
X        NCOL,
X	MARGIN,
X	SCRSIZ,
X	NPAUSE,
X        ansiopen,
X        ansiclose,
X	ansikopen,
X	ansikclose,
X        ttgetc,
X        ttputc,
X        ttflush,
X        ansimove,
X        ansieeol,
X        ansieeop,
X        ansibeep,
X	ansirev,
X	ansicres
X#if	COLOR
X	, ansifcol,
X	ansibcol
X#endif
X};
X
X#if	COLOR
Xansifcol(color)		/* set the current output color */
X
Xint color;	/* color to set */
X
X{
X	if (color == cfcolor)
X		return;
X	ttputc(ESC);
X	ttputc('[');
X	ansiparm(color+30);
X	ttputc('m');
X	cfcolor = color;
X}
X
Xansibcol(color)		/* set the current background color */
X
Xint color;	/* color to set */
X
X{
X	if (color == cbcolor)
X		return;
X	ttputc(ESC);
X	ttputc('[');
X	ansiparm(color+40);
X	ttputc('m');
X        cbcolor = color;
X}
X#endif
X
Xansimove(row, col)
X{
X        ttputc(ESC);
X        ttputc('[');
X        ansiparm(row+1);
X        ttputc(';');
X        ansiparm(col+1);
X        ttputc('H');
X}
X
Xansieeol()
X{
X        ttputc(ESC);
X        ttputc('[');
X        ttputc('K');
X}
X
Xansieeop()
X{
X#if	COLOR
X	ansifcol(gfcolor);
X	ansibcol(gbcolor);
X#endif
X        ttputc(ESC);
X        ttputc('[');
X        ttputc('J');
X}
X
Xansirev(state)		/* change reverse video state */
X
Xint state;	/* TRUE = reverse, FALSE = normal */
X
X{
X#if	COLOR
X	int ftmp, btmp;		/* temporaries for colors */
X#endif
X
X	ttputc(ESC);
X	ttputc('[');
X	ttputc(state ? '7': '0');
X	ttputc('m');
X#if	COLOR
X	if (state == FALSE) {
X		ftmp = cfcolor;
X		btmp = cbcolor;
X		cfcolor = -1;
X		cbcolor = -1;
X		ansifcol(ftmp);
X		ansibcol(btmp);
X	}
X#endif
X}
X
Xansicres()	/* change screen resolution */
X
X{
X	return(TRUE);
X}
X
Xansibeep()
X{
X        ttputc(BEL);
X        ttflush();
X}
X
Xansiparm(n)
Xregister int    n;
X{
X        register int q,r;
X
X        q = n/10;
X        if (q != 0) {
X		r = q/10;
X		if (r != 0) {
X			ttputc((r%10)+'0');
X		}
X		ttputc((q%10) + '0');
X        }
X        ttputc((n%10) + '0');
X}
X
Xansiopen()
X{
X#if     V7 | USG | BSD
X        register char *cp;
X        char *getenv();
X
X        if ((cp = getenv("TERM")) == NULL) {
X                puts("Shell variable TERM not defined!");
X                exit(1);
X        }
X        if (strcmp(cp, "vt100") != 0) {
X                puts("Terminal type not 'vt100'!");
X                exit(1);
X        }
X#endif
X	strcpy(sres, "NORMAL");
X	revexist = TRUE;
X        ttopen();
X}
X
Xansiclose()
X
X{
X#if	COLOR
X	ansifcol(7);
X	ansibcol(0);
X#endif
X	ttclose();
X}
X
Xansikopen()	/* open the keyboard (a noop here) */
X
X{
X}
X
Xansikclose()	/* close the keyboard (a noop here) */
X
X{
X}
X
X#if	FLABEL
Xfnclabel(f, n)		/* label a function key */
X
Xint f,n;	/* default flag, numeric argument [unused] */
X
X{
X	/* on machines with no function keys...don't bother */
X	return(TRUE);
X}
X#endif
X#else
Xansihello()
X{
X}
X#endif
END_OF_ansi.c
if test 4419 -ne `wc -c <ansi.c`; then
    echo shar: \"ansi.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"azmap.cmd\" \(521 characters\)
if test -f azmap.cmd ; then 
  echo shar: Will not over-write existing file \"azmap.cmd\"
else
sed "s/^X//" >azmap.cmd <<'END_OF_azmap.cmd'
X;	AZMAP.CMD:	MicroEMACS Macro file
X;			to translate an AZTEC C .SYM map file into
X;			the form needed to read it into ADDSYMS
X;			to be used with Pheonix's PFIX plus (C) debugger
X;
X;			written 6/5/86 by Daniel Lawrence
X
Xbeginning-of-file
Xnewline
Xprevious-line
Xreplace-string "~n" "~n 0000:"
Xbeginning-of-line
Xkill-to-end-of-line
Xnewline
Xnewline
Xnewline
Xbeginning-of-file
Xnewline
Xinsert-string "  Address         Publics by Name"
Xnewline
Xset-mark
Xend-of-file
Xcase-region-upper
Xbeginning-of-file
Xreplace-string "_~n" "~n"
X
END_OF_azmap.cmd
if test 521 -ne `wc -c <azmap.cmd`; then
    echo shar: \"azmap.cmd\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"bdata.cmd\" \(502 characters\)
if test -f bdata.cmd ; then 
  echo shar: Will not over-write existing file \"bdata.cmd\"
else
sed "s/^X//" >bdata.cmd <<'END_OF_bdata.cmd'
X;Create a block of DATA statements for a BASIC program
X; within MicroEMACS 3.8
X
X	insert-string "1000 DATA "
X	set %linenum 1000
X
X*nxtin
X	update-screen		;make sure we see the changes
X	set %data @"Next number[0 to end]: "
X	!if &equal %data 0
X		!goto finish
X	!endif
X
X	!if &greater $curcol 60
X		2 delete-previous-character
X		newline
X		set %linenum &add %linenum 10
X		insert-string &cat %linenum " DATA "
X	!endif
X
X	insert-string &cat %data ", "
X	!goto nxtin
X
X*finish
X
X	2 delete-previous-character
X	newline
X
X
END_OF_bdata.cmd
if test 502 -ne `wc -c <bdata.cmd`; then
    echo shar: \"bdata.cmd\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"dg10.c\" \(3266 characters\)
if test -f dg10.c ; then 
  echo shar: Will not over-write existing file \"dg10.c\"
else
sed "s/^X//" >dg10.c <<'END_OF_dg10.c'
X/*
X * The routines in this file provide support for the Data General Model 10
X * Microcomputer.
X */
X
X#define	termdef	1			/* don't define "term" external */
X
X#include        <stdio.h>
X#include	"estruct.h"
X#include        "edef.h"
X
X#if     DG10
X
X#define NROW    24                      /* Screen size.                 */
X#define NCOL    80                      /* Edit if you want to.         */
X#define	NPAUSE	100			/* # times thru update to pause */
X#define	MARGIN	8			/* size of minimim margin and	*/
X#define	SCRSIZ	64			/* scroll size for extended lines */
X#define BEL     0x07                    /* BEL character.               */
X#define ESC     30                      /* DG10 ESC character.          */
X
Xextern  int     ttopen();               /* Forward references.          */
Xextern  int     ttgetc();
Xextern  int     ttputc();
Xextern  int     ttflush();
Xextern  int     ttclose();
Xextern	int	dg10kopen();
Xextern	int	dg10kclose();
Xextern  int     dg10move();
Xextern  int     dg10eeol();
Xextern  int     dg10eeop();
Xextern  int     dg10beep();
Xextern  int     dg10open();
Xextern	int	dg10rev();
Xextern	int	dg10close();
Xextern	int	dg10cres();
X
X#if	COLOR
Xextern	int	dg10fcol();
Xextern	int	dg10bcol();
X
Xint	cfcolor = -1;		/* current forground color */
Xint	cbcolor = -1;		/* current background color */
Xint	ctrans[] = {		/* emacs -> DG10 color translation table */
X	0, 4, 2, 6, 1, 5, 3, 7};
X#endif
X
X/*
X * Standard terminal interface dispatch table. Most of the fields point into
X * "termio" code.
X */
XTERM    term    = {
X	NROW-1,
X        NROW-1,
X        NCOL,
X        NCOL,
X	MARGIN,
X	SCRSIZ,
X	NPAUSE,
X        dg10open,
X        dg10close,
X	dg10kopen,
X	dg10kclose,
X        ttgetc,
X        ttputc,
X        ttflush,
X        dg10move,
X        dg10eeol,
X        dg10eeop,
X        dg10beep,
X	dg10rev,
X	dg10cres
X#if	COLOR
X	, dg10fcol,
X	dg10bcol
X#endif
X};
X
X#if	COLOR
Xdg10fcol(color)		/* set the current output color */
X
Xint color;	/* color to set */
X
X{
X	if (color == cfcolor)
X		return;
X	ttputc(ESC);
X	ttputc(0101);
X	ttputc(ctrans[color]);
X	cfcolor = color;
X}
X
Xdg10bcol(color)		/* set the current background color */
X
Xint color;	/* color to set */
X
X{
X	if (color == cbcolor)
X		return;
X	ttputc(ESC);
X	ttputc(0102);
X	ttputc(ctrans[color]);
X        cbcolor = color;
X}
X#endif
X
Xdg10move(row, col)
X{
X	ttputc(16);
X        ttputc(col);
X	ttputc(row);
X}
X
Xdg10eeol()
X{
X        ttputc(11);
X}
X
Xdg10eeop()
X{
X#if	COLOR
X	dg10fcol(gfcolor);
X	dg10bcol(gbcolor);
X#endif
X        ttputc(ESC);
X        ttputc(0106);
X        ttputc(0106);
X}
X
Xdg10rev(state)		/* change reverse video state */
X
Xint state;	/* TRUE = reverse, FALSE = normal */
X
X{
X#if	COLOR
X	if (state == TRUE) {
X		dg10fcol(0);
X		dg10bcol(7);
X	}
X#else
X	ttputc(ESC);
X	ttputc(state ? 0104: 0105);
X#endif
X}
X
Xdg10cres()	/* change screen resolution */
X
X{
X	return(TRUE);
X}
X
Xdg10beep()
X{
X        ttputc(BEL);
X        ttflush();
X}
X
Xdg10open()
X{
X	strcpy(sres, "NORMAL");
X	revexist = TRUE;
X        ttopen();
X}
X
Xdg10close()
X
X{
X#if	COLOR
X	dg10fcol(7);
X	dg10bcol(0);
X#endif
X	ttclose();
X}
X
Xdg10kopen()
X
X{
X}
X
Xdg10kclose()
X
X{
X}
X
X#if	FLABEL
Xfnclabel(f, n)		/* label a function key */
X
Xint f,n;	/* default flag, numeric argument [unused] */
X
X{
X	/* on machines with no function keys...don't bother */
X	return(TRUE);
X}
X#endif
X#else
Xdg10hello()
X{
X}
X#endif
END_OF_dg10.c
if test 3266 -ne `wc -c <dg10.c`; then
    echo shar: \"dg10.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"emacs.rc\" \(4818 characters\)
if test -f emacs.rc ; then 
  echo shar: Will not over-write existing file \"emacs.rc\"
else
sed "s/^X//" >emacs.rc <<'END_OF_emacs.rc'
X;	EMACS.RC:	Startup file for MicroEMACS 3.8
X;
X;			This file is executed everytime the
X;			editor is entered
X
X; If you screen "SNOWS", uncomment this line
X;	set $flicker "TRUE"
X
X;	***** Rebind the Function key group
X
Xbind-to-key search-forward		FN;
Xbind-to-key search-reverse		FN<
Xbind-to-key hunt-forward		FN=
Xbind-to-key hunt-backward		FN>
Xbind-to-key next-window			FN?
Xbind-to-key execute-macro		FN@
Xbind-to-key find-file			FNA
Xbind-to-key execute-file		FNB
Xbind-to-key save-file			FNC
Xbind-to-key exit-emacs			FND
X
Xbind-to-key apropos			FNV
Xbind-to-key describe-key		FNW
Xbind-to-key fill-paragraph		FNX
Xbind-to-key shell-command		FN\
Xbind-to-key i-shell			FN]
X
X;	set screen colors
Xadd-global-mode "blue"
X
X;	toggle function key window off
X1 store-macro
X	save-window
X	1 next-window
X	!if &sequal "Function Keys" $cbufname
X		delete-window
X	!endif
X	bind-to-key execute-macro-14 FNT
X!force	restore-window
X	write-message "[Function key window OFF]"
X!endm
X
X;	toggle function key window back on
X14 store-macro
X	1 next-window
X	!if &sequal $cbufname "emacs.hlp"
X		execute-macro-11
X	!endif
X	!if &not &sequal $cbufname "Function Keys"
X		1 split-current-window
X		select-buffer "Function Keys"
X		add-mode "red"
X!force		5 resize-window
X		beginning-of-file
X	!endif
X	bind-to-key execute-macro-1 FNT
X	2 next-window
X	write-message "[Function key window ON]"
X!endm
X
X;	Enter Help
X2 store-macro
X	1 next-window		;Make sure the function key window isn't up!
X	!if &sequal $cbufname "Function Keys"
X		delete-window
X		bind-to-key execute-macro-14 FNT
X	!endif
X	help
X	8 resize-window
X	bind-to-key execute-macro-12 FNI
X	bind-to-key execute-macro-13 FNQ
X	bind-to-key execute-macro-11 FNU
X	bind-to-key execute-macro-15 ^XO
X	bind-to-key execute-macro-15 ^XP
X	bind-to-key execute-macro-15 FN?
X	add-mode "red"
X	beginning-of-file
X	2 forward-character
X	clear-message-line
X!endm
X
X;	Exit Help
X11 store-macro
X	bind-to-key previous-page FNI
X	bind-to-key next-page FNQ
X	bind-to-key execute-macro-2 FNU
X	bind-to-key next-window ^XO
X	bind-to-key previous-window ^XP
X	bind-to-key next-window FN?
X	delete-window
X	clear-message-line
X!endm
X
X;	don't allow these commands from within the HELP screen
X15	store-macro
X	write-message "[Use F2 to exit HELP]!!"
X!endm
X
X;	last help page
X12 store-macro
X	beginning-of-line
X	search-reverse "=>"
X	1 redraw-display
X!endm
X
X;	next help page
X13 store-macro
X	beginning-of-line
X	2 forward-character
X	search-forward "=>"
X	1 redraw-display
X!endm
X
X;	reformat indented paragraph
X
X6 store-macro
X	write-message "                    [Fixing paragraph]"
X	kill-region
X	2 split-current-window
X	select-buffer "[temp]"
X	yank
X	beginning-of-file
X	replace-string "~n	" "~n"
X	write-message "                    [Fixing paragraph]"
X	66 set-fill-column
X	write-message "                    [Fixing paragraph]"
X	fill-paragraph
X	77 set-fill-column
X	beginning-of-file
X	handle-tab
X	replace-string ~n "~n	"
X	write-message "                    [Fixing paragraph]"
X	end-of-file
X	2 delete-previous-character
X	beginning-of-file
X	set-mark
X	write-message "                    [Fixing paragraph]"
X	end-of-file
X	kill-region
X	unmark-buffer
X	delete-window
X	yank
X	delete-buffer "[temp]"
X	write-message "                    [Fixed paragraph]"
X!endm
X
X;	indent region
X
X7 store-macro
X	write-message "                    [Indenting region]"
X	kill-region
X	2 split-current-window
X	select-buffer "[temp]"
X	yank
X	beginning-of-file
X	handle-tab
X	replace-string "~n" "~n	"
X	end-of-file
X	4 delete-previous-character
X	beginning-of-file
X	set-mark
X	write-message "                    [Indenting region]"
X	end-of-file
X	kill-region
X	unmark-buffer
X	delete-window
X	yank
X	delete-buffer "[temp]"
X	write-message "                    [Region Indented]"
X!endm
X
X;	undent region
X
X8 store-macro
X	write-message "                    [Undenting region]"
X	kill-region
X	2 split-current-window
X	select-buffer "[temp]"
X	yank
X	beginning-of-file
X	delete-next-character
X	replace-string "~n	" "~n"
X	end-of-file
X	2 delete-previous-character
X	beginning-of-file
X	set-mark
X	write-message "                    [Undenting region]"
X	end-of-file
X	kill-region
X	unmark-buffer
X	delete-window
X	yank
X	delete-buffer "[temp]"
X	write-message "                    [Region undented]"
X!endm
X
X;	bring up the function key window
X
X	1 split-current-window
X	select-buffer "Function Keys"
X	add-mode "red"
X	5 resize-window
X	insert-string "f1 search      f2 search back | F1 toggle function list F2 toggle help file~n"
X	insert-string "f3 hunt        f4 hunt back   | F3 find command/apropos F4 describe key~n"
X	insert-string "f5 next window f6 exec macro  | F5 reformat paragraph   F6 ref undented region~n"
X	insert-string "f7 find file   f8 exec file   | F7 indent region        F8 undent region~n"
X	insert-string "f9 save file  f10 exit emacs  | F9 execute DOS command F10 shell up~n"
X	beginning-of-file
X	unmark-buffer
X	next-window
END_OF_emacs.rc
if test 4818 -ne `wc -c <emacs.rc`; then
    echo shar: \"emacs.rc\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"epath.h\" \(780 characters\)
if test -f epath.h ; then 
  echo shar: Will not over-write existing file \"epath.h\"
else
sed "s/^X//" >epath.h <<'END_OF_epath.h'
X/*	PATH:	This file contains certain info needed to locate the
X		MicroEMACS files on a system dependant basis.
X
X									*/
X
X/*	possible names and paths of help files under different OSs	*/
X
Xchar *pathname[] =
X
X#if	AMIGA
X{
X	".emacsrc",
X	"emacs.hlp",
X	"",
X	":c/",
X	":t/"
X};
X#endif
X
X#if	ST520
X{
X	"emacs.rc",
X	"emacs.hlp",
X	"\\",
X	"\\bin\\",
X	"\\util\\",
X	""
X};
X#endif
X
X#if	FINDER
X{
X	"emacs.rc",
X	"emacs.hlp",
X	"/bin",
X	"/sys/public",
X	""
X};
X#endif
X
X#if	MSDOS
X{
X	"emacs.rc",
X	"emacs.hlp",
X	"\\sys\\public\\",
X	"\\usr\\bin\\",
X	"\\bin\\",
X	"\\",
X	""
X};
X#endif
X
X#if	V7 | BSD | USG
X{
X	".emacsrc",
X	"emacs.hlp",
X	"/usr/local/",
X	"/usr/lib/",
X	""
X};
X#endif
X
X#if	VMS
X{
X	"emacs.rc",
X	"emacs.hlp",
X	"",
X	"sys$sysdevice:[vmstools]"
X};
X#endif
X
X#define	NPNAMES	(sizeof(pathname)/sizeof(char *))
END_OF_epath.h
if test 780 -ne `wc -c <epath.h`; then
    echo shar: \"epath.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"esearch.h\" \(2286 characters\)
if test -f esearch.h ; then 
  echo shar: Will not over-write existing file \"esearch.h\"
else
sed "s/^X//" >esearch.h <<'END_OF_esearch.h'
X/*
X * ESEARCH.H
X *
X * Defines, typdefs, and global variables that are of use for the
X * routines in search.c and isearch.c.
X *
X */
X
X/*
X * PTBEG, PTEND, FORWARD, and REVERSE are all toggle-able values for
X * the scan routines.
X */
X#define	PTBEG	0	/* Leave the point at the beginning on search.*/
X#define	PTEND	1	/* Leave the point at the end on search.*/
X
X#if	MAGIC
X
X/*
X * Defines for the metacharacters in the regular expressions.
X */
X
X#define	MCNIL		0	/* Like the '\0' for strings.*/
X#define	LITCHAR		1
X#define	ANY		2
X#define	CCL		3
X#define	NCCL		4
X#define	BOL		5
X#define	EOL		6
X#define	CLOSURE		256	/* An or-able value.*/
X#define	MASKCL		CLOSURE - 1
X
X#define	MC_ANY		'.'	/* 'Any' character (except newline).*/
X#define	MC_CCL		'['	/* Character class.*/
X#define	MC_NCCL		'^'	/* Negate character class.*/
X#define	MC_RCCL		'-'	/* Range in character class.*/
X#define	MC_ECCL		']'	/* End of character class.*/
X#define	MC_BOL		'^'	/* Beginning of line.*/
X#define	MC_EOL		'$'	/* End of line.*/
X#define	MC_CLOSURE	'*'	/* Closure - does not extend past newline.*/
X
X#define	MC_ESC		'\\'	/* Escape - suppress meta-meaning.*/
X
X#define	BIT(n)		(1 << (n))	/* An integer with one bit set.*/
X#define	CHCASE(c)	((c) ^ DIFCASE)	/* Toggle the case of a letter.*/
X
X/* HICHAR - 1 is the largest character we will deal with.
X * HIBYTE represents the number of bytes in the bitmap.
X */
X
X#define	HICHAR		256
X#define	HIBYTE		HICHAR >> 3
X
Xtypedef char	*BITMAP;
X
Xtypedef	struct {
X	short int	mc_type;
X	union {
X		int	lchar;
X		BITMAP	cclmap;
X	} u;
X} MC;
X#endif
X
X/* Incremental search defines.
X */
X#if	ISRCH
X#define	CMDBUFLEN	256	/* Length of our command buffer */
X
X#define	IS_ABORT	0x07	/* Abort the isearch */
X#define IS_BACKSP	0x08	/* Delete previous char */
X#define	IS_TAB		0x09	/* Tab character (allowed search char) */
X#define IS_NEWLINE	0x0D	/* New line from keyboard (Carriage return) */
X#define	IS_QUOTE	0x11	/* Quote next character */
X#define IS_REVERSE	0x12	/* Search backward */
X#define	IS_FORWARD	0x13	/* Search forward */
X#define	IS_VMSQUOTE	0x16	/* VMS quote character */
X#define	IS_VMSFORW	0x18	/* Search forward for VMS */
X#define	IS_QUIT		0x1B	/* Exit the search */
X#define	IS_RUBOUT	0x7F	/* Delete previous character */
X
X/* IS_QUIT is no longer used, the variable metac is used instead */
X
X#endif
END_OF_esearch.h
if test 2286 -ne `wc -c <esearch.h`; then
    echo shar: \"esearch.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"evar.h\" \(2763 characters\)
if test -f evar.h ; then 
  echo shar: Will not over-write existing file \"evar.h\"
else
sed "s/^X//" >evar.h <<'END_OF_evar.h'
X/*	EVAR.H:	Environment and user variable definitions
X		for MicroEMACS
X
X		written 1986 by Daniel Lawrence
X*/
X
X/*	structure to hold user variables and their definitions	*/
X
Xtypedef struct UVAR {
X	char u_name[NVSIZE + 1];		/* name of user variable */
X	char *u_value;				/* value (string) */
X} UVAR;
X
X/*	current user variables (This structure will probably change)	*/
X
X#define	MAXVARS		100
X
XUVAR uv[MAXVARS];	/* user variables */
X
X/*	list of recognized environment variables	*/
X
Xchar *envars[] = {
X	"fillcol",		/* current fill column */
X	"pagelen",		/* number of lines used by editor */
X	"curcol",		/* current column pos of cursor */
X	"curline",		/* current line in file */
X	"ram",			/* ram in use by malloc */
X	"flicker",		/* flicker supression */
X	"curwidth",		/* current screen width */
X	"cbufname",		/* current buffer name */
X	"cfname",		/* current file name */
X	"sres",			/* current screen resolution */
X	"debug",		/* macro debugging */
X	"status",		/* returns the status of the last command */
X};
X
X#define	NEVARS	sizeof(envars) / sizeof(char *)
X
X/* 	and its preprocesor definitions		*/
X
X#define	EVFILLCOL	0
X#define	EVPAGELEN	1
X#define	EVCURCOL	2
X#define	EVCURLINE	3
X#define	EVRAM		4
X#define	EVFLICKER	5
X#define	EVCURWIDTH	6
X#define	EVCBUFNAME	7
X#define	EVCFNAME	8
X#define	EVSRES		9
X#define	EVDEBUG		10
X#define	EVSTATUS	11
X
X/*	list of recognized user functions	*/
X
Xtypedef struct UFUNC {
X	char *f_name;	/* name of function */
X	int f_type;	/* 1 = monamic, 2 = dynamic */
X} UFUNC;
X
X#define	MONAMIC		1
X#define	DYNAMIC		2
X#define	TRINAMIC	3
X
XUFUNC funcs[] = {
X	"add", DYNAMIC,		/* add two numbers together */
X	"sub", DYNAMIC,		/* subtraction */
X	"tim", DYNAMIC,		/* multiplication */
X	"div", DYNAMIC,		/* division */
X	"mod", DYNAMIC,		/* mod */
X	"neg", MONAMIC,		/* negate */
X	"cat", DYNAMIC,		/* concatinate string */
X	"lef", DYNAMIC,		/* left string(string, len) */
X	"rig", DYNAMIC,		/* right string(string, pos) */
X	"mid", TRINAMIC,	/* mid string(string, pos, len) */
X	"not", MONAMIC,		/* logical not */
X	"equ", DYNAMIC,		/* logical equality check */
X	"les", DYNAMIC,		/* logical less than */
X	"gre", DYNAMIC,		/* logical greater than */
X	"seq", DYNAMIC,		/* string logical equality check */
X	"sle", DYNAMIC,		/* string logical less than */
X	"sgr", DYNAMIC,		/* string logical greater than */
X	"ind", MONAMIC,		/* evaluate indirect value */
X};
X
X#define	NFUNCS	sizeof(funcs) / sizeof(char *)
X
X/* 	and its preprocesor definitions		*/
X
X#define	UFADD		0
X#define	UFSUB		1
X#define	UFTIMES		2
X#define	UFDIV		3
X#define	UFMOD		4
X#define	UFNEG		5
X#define	UFCAT		6
X#define	UFLEFT		7
X#define	UFRIGHT		8
X#define	UFMID		9
X#define	UFNOT		10
X#define	UFEQUAL		11
X#define	UFLESS		12
X#define	UFGREATER	13
X#define	UFSEQUAL	14
X#define	UFSLESS		15
X#define	UFSGREAT	16
X#define	UFIND		17
END_OF_evar.h
if test 2763 -ne `wc -c <evar.h`; then
    echo shar: \"evar.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"fileio.c\" \(3492 characters\)
if test -f fileio.c ; then 
  echo shar: Will not over-write existing file \"fileio.c\"
else
sed "s/^X//" >fileio.c <<'END_OF_fileio.c'
X/*
X * The routines in this file read and write ASCII files from the disk. All of
X * the knowledge about files are here. A better message writing scheme should
X * be used.
X */
X#include        <stdio.h>
X#include	"estruct.h"
X#include        "edef.h"
X
X#if	MEGAMAX
Xoverlay "fileio"
X#endif
X
XFILE    *ffp;                           /* File pointer, all functions. */
X
X/*
X * Open a file for reading.
X */
Xffropen(fn)
Xchar    *fn;
X{
X        if ((ffp=fopen(fn, "r")) == NULL)
X                return (FIOFNF);
X        return (FIOSUC);
X}
X
X/*
X * Open a file for writing. Return TRUE if all is well, and FALSE on error
X * (cannot create).
X */
Xffwopen(fn)
Xchar    *fn;
X{
X#if     VMS
X        register int    fd;
X
X        if ((fd=creat(fn, 0666, "rfm=var", "rat=cr")) < 0
X        || (ffp=fdopen(fd, "w")) == NULL) {
X#else
X        if ((ffp=fopen(fn, "w")) == NULL) {
X#endif
X                mlwrite("Cannot open file for writing");
X                return (FIOERR);
X        }
X        return (FIOSUC);
X}
X
X/*
X * Close a file. Should look at the status in all systems.
X */
Xffclose()
X{
X#if	MSDOS & CTRLZ
X	fputc(26, ffp);		/* add a ^Z at the end of the file */
X#endif
X	
X#if     V7 | USG | BSD | (MSDOS & (LATTICE | MSC))
X        if (fclose(ffp) != FALSE) {
X                mlwrite("Error closing file");
X                return(FIOERR);
X        }
X        return(FIOSUC);
X#else
X        fclose(ffp);
X        return (FIOSUC);
X#endif
X}
X
X/*
X * Write a line to the already opened file. The "buf" points to the buffer,
X * and the "nbuf" is its length, less the free newline. Return the status.
X * Check only at the newline.
X */
Xffputline(buf, nbuf)
Xchar    buf[];
X{
X        register int    i;
X#if	CRYPT
X	char c;		/* character to translate */
X
X	if (cryptflag) {
X	        for (i = 0; i < nbuf; ++i) {
X			c = buf[i] & 0xff;
X			crypt(&c, 1);
X			fputc(c, ffp);
X		}
X	} else
X	        for (i = 0; i < nbuf; ++i)
X        	        fputc(buf[i]&0xFF, ffp);
X#else
X        for (i = 0; i < nbuf; ++i)
X                fputc(buf[i]&0xFF, ffp);
X#endif
X
X#if	ST520
X        fputc('\r', ffp);
X#endif        
X        fputc('\n', ffp);
X
X        if (ferror(ffp)) {
X                mlwrite("Write I/O error");
X                return (FIOERR);
X        }
X
X        return (FIOSUC);
X}
X
X/*
X * Read a line from a file, and store the bytes in the supplied buffer. The
X * "nbuf" is the length of the buffer. Complain about long lines and lines
X * at the end of the file that don't have a newline present. Check for I/O
X * errors too. Return status.
X */
Xffgetline(buf, nbuf)
Xregister char   buf[];
X{
X        register int    c;
X        register int    i;
X
X        i = 0;
X
X        while ((c = fgetc(ffp)) != EOF && c != '\n') {
X                if (i >= nbuf-2) {
X			buf[nbuf - 2] = c;	/* store last char read */
X			buf[nbuf - 1] = 0;	/* and terminate it */
X                        mlwrite("File has long line");
X#if	CRYPT
X			if (cryptflag)
X				crypt(buf, strlen(buf));
X#endif
X                        return (FIOLNG);
X                }
X                buf[i++] = c;
X        }
X
X#if	ST520
X	if(buf[i-1] == '\r')
X		i--;
X#endif
X        if (c == EOF) {
X                if (ferror(ffp)) {
X                        mlwrite("File read error");
X                        return (FIOERR);
X                }
X
X                if (i != 0) {
X                	buf[i] = 0;
X                        return(FIOFUN);
X                }
X
X                return (FIOEOF);
X        }
X
X        buf[i] = 0;
X#if	CRYPT
X	if (cryptflag)
X		crypt(buf, strlen(buf));
X#endif
X        return (FIOSUC);
X}
END_OF_fileio.c
if test 3492 -ne `wc -c <fileio.c`; then
    echo shar: \"fileio.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"hp110.c\" \(3687 characters\)
if test -f hp110.c ; then 
  echo shar: Will not over-write existing file \"hp110.c\"
else
sed "s/^X//" >hp110.c <<'END_OF_hp110.c'
X/*
X *	HP110:	Hewlett Packard 110 Screen Driver
X */
X
X#define	termdef	1			/* don't define "term" external */
X
X#include        <stdio.h>
X#include	"estruct.h"
X#include        "edef.h"
X
X#if     HP110
X
X#define NROW    16                      /* Screen size.                 */
X#define NCOL    80                      /* Edit if you want to.         */
X#define	NPAUSE	100			/* # times thru update to pause */
X#define	MARGIN	8			/* size of minimim margin and	*/
X#define	SCRSIZ	64			/* scroll size for extended lines */
X#define BEL     0x07                    /* BEL character.               */
X#define ESC     0x1B                    /* ESC character.               */
X
Xextern  int     ttopen();               /* Forward references.          */
Xextern  int     ttgetc();
Xextern  int     ttputc();
Xextern  int     ttflush();
Xextern  int     ttclose();
Xextern  int     h110move();
Xextern  int     h110eeol();
Xextern  int     h110eeop();
Xextern  int     h110beep();
Xextern  int     h110open();
Xextern	int	h110rev();
Xextern	int	h110cres();
Xextern	int	h110close();
Xextern	int	h110kopen();
Xextern	int	h110kclose();
X
X#if	COLOR
Xextern	int	h110fcol();
Xextern	int	h110bcol();
X
Xint	cfcolor = -1;		/* current forground color */
Xint	cbcolor = -1;		/* current background color */
X#endif
X
X/*
X * Standard terminal interface dispatch table. Most of the fields point into
X * "termio" code.
X */
XTERM    term    = {
X	NROW-1,
X        NROW-1,
X        NCOL,
X        NCOL,
X	MARGIN,
X	SCRSIZ,
X	NPAUSE,
X        h110open,
X        h110close,
X	h110kopen,
X	h110kclose,
X        ttgetc,
X        ttputc,
X        ttflush,
X        h110move,
X        h110eeol,
X        h110eeop,
X        h110beep,
X	h110rev,
X	h110cres
X#if	COLOR
X	, h110fcol,
X	h110bcol
X#endif
X};
X
X#if	COLOR
Xh110fcol(color)		/* set the current output color */
X
Xint color;	/* color to set */
X
X{
X	if (color == cfcolor)
X		return;
X	ttputc(ESC);
X	ttputc('[');
X	h110parm(color+30);
X	ttputc('m');
X	cfcolor = color;
X}
X
Xh110bcol(color)		/* set the current background color */
X
Xint color;	/* color to set */
X
X{
X	if (color == cbcolor)
X		return;
X	ttputc(ESC);
X	ttputc('[');
X	h110parm(color+40);
X	ttputc('m');
X        cbcolor = color;
X}
X#endif
X
Xh110move(row, col)
X{
X        ttputc(ESC);
X        ttputc('[');
X        h110parm(row+1);
X        ttputc(';');
X        h110parm(col+1);
X        ttputc('H');
X}
X
Xh110eeol()
X{
X        ttputc(ESC);
X        ttputc('[');
X	ttputc('0');
X        ttputc('K');
X}
X
Xh110eeop()
X{
X#if	COLOR
X	h110fcol(gfcolor);
X	h110bcol(gbcolor);
X#endif
X        ttputc(ESC);
X        ttputc('[');
X	ttputc('0');
X        ttputc('J');
X}
X
Xh110rev(state)		/* change reverse video state */
X
Xint state;	/* TRUE = reverse, FALSE = normal */
X
X{
X#if	COLOR
X	int ftmp, btmp;		/* temporaries for colors */
X#endif
X
X	ttputc(ESC);
X	ttputc('[');
X	ttputc(state ? '7': '0');
X	ttputc('m');
X#if	COLOR
X	if (state == FALSE) {
X		ftmp = cfcolor;
X		btmp = cbcolor;
X		cfcolor = -1;
X		cbcolor = -1;
X		h110fcol(ftmp);
X		h110bcol(btmp);
X	}
X#endif
X}
X
Xh110cres()	/* change screen resolution */
X
X{
X	return(TRUE);
X}
X
Xh110beep()
X{
X        ttputc(BEL);
X        ttflush();
X}
X
Xh110parm(n)
Xregister int    n;
X{
X        register int q,r;
X
X        q = n/10;
X        if (q != 0) {
X		r = q/10;
X		if (r != 0) {
X			ttputc((r%10)+'0');
X		}
X		ttputc((q%10) + '0');
X        }
X        ttputc((n%10) + '0');
X}
X
Xh110open()
X{
X	strcpy(sres, "15LINE");
X	revexist = TRUE;
X        ttopen();
X}
X
Xh110close()
X
X{
X#if	COLOR
X	h110fcol(7);
X	h110bcol(0);
X#endif
X	ttclose();
X}
X
Xh110kopen()
X
X{
X}
X
Xh110kclose()
X
X{
X}
X
X#if	FLABEL
Xfnclabel(f, n)		/* label a function key */
X
Xint f,n;	/* default flag, numeric argument [unused] */
X
X{
X	/* on machines with no function keys...don't bother */
X	return(TRUE);
X}
X#endif
X#else
Xh110hello()
X{
X}
X#endif
END_OF_hp110.c
if test 3687 -ne `wc -c <hp110.c`; then
    echo shar: \"hp110.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"ibmfn.lst\" \(593 characters\)
if test -f ibmfn.lst ; then 
  echo shar: Will not over-write existing file \"ibmfn.lst\"
else
sed "s/^X//" >ibmfn.lst <<'END_OF_ibmfn.lst'
X			IBM PC function keys in MicroEmacs
X
X	function	Function	^function	Alt-function
X f1)	  FN;		  FNT		  FN^		  FNh
X f2)	  FN<		  FNU		  FN_		  FNi
X f3)	  FN=		  FNV		  FN`		  FNj
X f4)	  FN>		  FNW		  FNa		  FNk
X f5)	  FN?		  FNX		  FNb		  FNl
X f6)	  FN@		  FNY		  FNc		  FNm
X f7)	  FNA		  FNZ		  FNd		  FNn
X f8)	  FNB		  FN[		  FNe		  FNo
X f9)	  FNC		  FN\		  FNf		  FNp
Xf10)	  FND		  FN]		  FNg		  FNq
X
Xhome)	  FNG				  FNw
XCuUp)	  FNH
XPgUp)	  FNI				  FN^D {Alt 132}
XCuLf)	  FNK				  FNs
X 5  )
XCuRt)	  FNM				  FNt
X End)	  FNO				  FNu
XCuDn)	  FNP
XPgDn)	  FNQ				  FNv
X Ins)	  FNR
X Del)	  FNS
END_OF_ibmfn.lst
if test 593 -ne `wc -c <ibmfn.lst`; then
    echo shar: \"ibmfn.lst\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"lock.c\" \(3565 characters\)
if test -f lock.c ; then 
  echo shar: Will not over-write existing file \"lock.c\"
else
sed "s/^X//" >lock.c <<'END_OF_lock.c'
X/*	LOCK:	File locking command routines for MicroEMACS
X		written by Daniel Lawrence
X								*/
X
X#include <stdio.h>
X#include "estruct.h"
X#include "edef.h"
X
X#if	FILOCK
X#if	BSD
X#include <sys/errno.h>
X
Xextern int sys_nerr;		/* number of system error messages defined */
Xextern char *sys_errlist[];	/* list of message texts */
Xextern int errno;		/* current error */
X
Xchar *lname[NLOCKS];	/* names of all locked files */
Xint numlocks;		/* # of current locks active */
X
X/* lockchk:	check a file for locking and add it to the list */
X
Xlockchk(fname)
X
Xchar *fname;	/* file to check for a lock */
X
X{
X	register int i;		/* loop indexes */
X	register int status;	/* return status */
X	char *undolock();
X
X	/* check to see if that file is already locked here */
X	if (numlocks > 0)
X		for (i=0; i < numlocks; ++i)
X			if (strcmp(fname, lname[i]) == 0)
X				return(TRUE);
X
X	/* if we have a full locking table, bitch and leave */
X	if (numlocks == NLOCKS) {
X		mlwrite("LOCK ERROR: Lock table full");
X		return(ABORT);
X	}
X
X	/* next, try to lock it */
X	status = lock(fname);
X	if (status == ABORT)	/* file is locked, no override */
X		return(ABORT);
X	if (status == FALSE)	/* locked, overriden, dont add to table */
X		return(TRUE);
X
X	/* we have now locked it, add it to our table */
X	lname[++numlocks - 1] = (char *)malloc(strlen(fname) + 1);
X	if (lname[numlocks - 1] == NULL) {	/* malloc failure */
X		undolock(fname);		/* free the lock */
X		mlwrite("Cannot lock, out of memory");
X		--numlocks;
X		return(ABORT);
X	}
X
X	/* everthing is cool, add it to the table */
X	strcpy(lname[numlocks-1], fname);
X	return(TRUE);
X}
X
X/*	lockrel:	release all the file locks so others may edit */
X
Xlockrel()
X
X{
X	register int i;		/* loop index */
X	register int status;	/* status of locks */
X	register int s;		/* status of one unlock */
X
X	status = TRUE;
X	if (numlocks > 0)
X		for (i=0; i < numlocks; ++i) {
X			if ((s = unlock(lname[i])) != TRUE)
X				status = s;
X			free(lname[i]);
X		}
X	numlocks = 0;
X	return(status);
X}
X
X/* lock:	Check and lock a file from access by others
X		returns	TRUE = files was not locked and now is
X			FALSE = file was locked and overridden
X			ABORT = file was locked, abort command
X*/
X
Xlock(fname)
X
Xchar *fname;	/* file name to lock */
X
X{
X	register char *locker;	/* lock error message */
X	register int status;	/* return status */
X	char msg[NSTRING];	/* message string */
X	char *dolock();
X
X	/* attempt to lock the file */
X	locker = dolock(fname);
X	if (locker == NULL)	/* we win */
X		return(TRUE);
X
X	/* file failed...abort */
X	if (strncmp(locker, "LOCK", 4) == 0) {
X		lckerror(locker);
X		return(ABORT);
X	}
X
X	/* someone else has it....override? */
X	strcpy(msg, "File in use by ");
X	strcat(msg, locker);
X	strcat(msg, ", overide?");
X	status = mlyesno(msg);		/* ask them */
X	if (status == TRUE)
X		return(FALSE);
X	else
X		return(ABORT);
X}
X
X/*	unlock:	Unlock a file
X		this only warns the user if it fails
X							*/
X
Xunlock(fname)
X
Xchar *fname;	/* file to unlock */
X
X{
X	register char *locker;	/* undolock return string */
X	char *undolock();
X
X	/* unclock and return */
X	locker = undolock(fname);
X	if (locker == NULL)
X		return(TRUE);
X
X	/* report the error and come back */
X	lckerror(locker);
X	return(FALSE);
X}
X
Xlckerror(errstr)	/* report a lock error */
X
Xchar *errstr;		/* lock error string to print out */
X
X{
X	char obuf[NSTRING];	/* output buffer for error message */
X
X	strcpy(obuf, errstr);
X	strcat(obuf, " - ");
X	if (errno < sys_nerr)
X		strcat(obuf, sys_errlist[errno]);
X	else
X		strcat(obuf, "[can not get system error message]");
X	mlwrite(obuf);
X}
X#endif
X#else
Xlckhello()	/* dummy function */
X{
X}
X#endif
END_OF_lock.c
if test 3565 -ne `wc -c <lock.c`; then
    echo shar: \"lock.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"magic.doc\" \(3923 characters\)
if test -f magic.doc ; then 
  echo shar: Will not over-write existing file \"magic.doc\"
else
sed "s/^X//" >magic.doc <<'END_OF_magic.doc'
X
X		Some notes on the MAGIC mode.
X
X     In the MAGIC mode of MicroEmacs (versions 3.8 and up),
Xcertain characters gain special meanings when used in a search
Xpattern.  Collectively they are know as regular expressions,
Xand a limited number of them are supported in MicroEmacs.
XThey grant greater flexability when using the search command.
XHowever, they do not affect the incremental search command.
X
X     The symbols that have special meaning in MAGIC mode are
X^, $, ., *, [ (and ], used with it), and \.
X
X     The characters ^ and $ fix the search pattern to the
Xbeginning and end of line, respectively.  The ^ character
Xmust appear at the beginning of the search string, and the
X$ must appear at the end, otherwise they loose their
Xmeaning and are treated just like any other character.
XFor example, in MAGIC mode, searching for the pattern
X"t$" would put the cursor at the end of any line that ended
Xwith the letter 't'.  Note that this is different than
Xsearching for "t<NL>", that is, 't' followed by a newline
Xcharacter.  The character $ (and ^, for that matter) matches
Xa position, not a character, so the cursor remains at the end
Xof the line.  But a newline is a character that must be matched,
Xjust like any other character, which means that the cursor is
Xplaced just after it - on the beginning of the next line.
X
X     The character . has a very simple meaning - it matches
Xany single character, except the newline.  Thus a search for
X"bad.er" could match "badger", "badder" (slang), or up to the
X'r' of "bad error".
X
X     The character * is known as closure, and means that zero
Xor more of the preceding character will match.  If there is
Xno character preceding, * has no special meaning, and since
Xit will not match with a newline, * will have no special
Xmeaning if preceded by the beginning of line symbol ^ or
Xthe literal newline character <NL>.
X     The notion of zero or more characters is important.
XIf, for example, your cursor was on the line
X
X	This line is missing two vowels.
X
Xand a search was made for "a*", the cursor would not move,
Xbecause it is guarenteed to match no letter 'a' , which
Xsatifies the search conditions.  If you wanted to search
Xfor one or more of the letter 'a', you would search for
X"aa*", which would match the letter a, then zero or more of
Xthem.
X
X     The character [ indicates the beginning of a character
Xclass.  It is similar to the 'any' character ., but you get
Xto choose which characters you want to match.  The character
Xclass is ended with the character ].  So, while a search for
X"ba.e" will match "bane", "bade", "bale", "bate", et cetera,
Xyou can limit it to matching "babe" and "bake" by searching
Xfor "ba[bk]e".  Only one of the characters inside the [ and ]
Xwill match a character.  If in fact you want to match any
Xcharacter except those in the character class, you can put
Xa ^ as the first character.  It must be the first character
Xof the class, or else it has no special meaning.  So, a
Xsearch for [^aeiou] will match any character except a vowel,
Xbut a search for [aeiou^] will match any vowel or a ^.
XIf you have a lot of characters in order that you want to
Xput in the character class, you may use a dash (-) as a
Xrange character.  So, [a-z] will match any letter (or any
Xlower case letter if EXACT mode is on), and [0-9a-f] will
Xmatch any digit or any letter 'a' through 'f', which happen
Xto be the characters for hexadecimal numbers.  If the dash is
Xat the beginning or end of a character class, it is taken to
Xbe just a dash.
X
X     The escape character \ is for those times when you want to be in
XMAGIC mode, but also want to use a regular expression character
Xto be just a character.  It turns off the special meaning of the
Xcharacter.  So a search for "it\." will search for a line with "it.",
Xand not "it" followed by any other character.  The escape character
Xwill also let you put ^, -, or ] inside a character class with no
Xspecial side effects.
X
END_OF_magic.doc
if test 3923 -ne `wc -c <magic.doc`; then
    echo shar: \"magic.doc\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"me110.rc\" \(1627 characters\)
if test -f me110.rc ; then 
  echo shar: Will not over-write existing file \"me110.rc\"
else
sed "s/^X//" >me110.rc <<'END_OF_me110.rc'
X;	EMACS.RC:	Startup file for MicroEMACS 3.8 (HP 110) 
X;
X;			This file is executed everytime the
X;			editor is entered
X
X;	***** Rebind the Function key group
X
Xbind-to-key search-forward		FN;
Xbind-to-key search-reverse		FN<
Xbind-to-key next-window			FN=
Xbind-to-key execute-macro		FN>
Xbind-to-key find-file			FN?
Xbind-to-key view-file			FN@
Xbind-to-key save-file			FNA
Xbind-to-key exit-emacs			FNB
Xbind-to-key describe-key		FND
Xbind-to-key meta-prefix			`
Xbind-to-key beginning-of-file		FNs
Xbind-to-key end-of-file			FNt
X
X;	Enter Help
X1 store-macro
X	delete-other-windows
X	help
X	8 resize-window
X	bind-to-key execute-macro-12 FNH
X	bind-to-key execute-macro-13 FNP
X	bind-to-key execute-macro-11 FNT
X	beginning-of-file
X	2 forward-character
X	clear-message-line
X!endm
X
X;	consult file
X2 store-macro
X	2 split-current-window
X	previous-window
X	view-file @"File to Consult: "
X	8 resize-window
X	next-window
X!endm
X
X;	Exit Help
X11 store-macro
X	bind-to-key previous-line FNH
X	bind-to-key next-line FNP
X	bind-to-key execute-macro-1 FNT
X	delete-window
X	clear-message-line
X!endm
X
X;	last help page
X12 store-macro
X	beginning-of-line
X	search-reverse "=>"
X	1 redraw-display
X!endm
X
X;	next help page
X13 store-macro
X	beginning-of-line
X	2 forward-character
X	search-forward "=>"
X	1 redraw-display
X!endm
X
X;	bring up the function key window
X
X	2 split-current-window
X	select-buffer "Function Keys"
X	2 resize-window
X	insert-string " F1 search     | F2 search back | F3 next wind   | F4 Exec Macro  | MENU Help"
X	newline
X	insert-string "SYS desc key   | F5 Find file   | F6 view file   | F7 save file   | F8 exit"
X	beginning-of-file
X	unmark-buffer
X	next-window
END_OF_me110.rc
if test 1627 -ne `wc -c <me110.rc`; then
    echo shar: \"me110.rc\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"me150.rc\" \(1491 characters\)
if test -f me150.rc ; then 
  echo shar: Will not over-write existing file \"me150.rc\"
else
sed "s/^X//" >me150.rc <<'END_OF_me150.rc'
X;	EMACS.RC:	Startup file for MicroEMACS 3.4
X;
X;			This file is executed everytime the
X;			editor is entered
X
X;	***** Rebind the Function key group
X
Xbind-to-key hunt-forward		FN^@
X1 label-function-key "hunt     forward"
Xbind-to-key hunt-backward		FN^A
X2 label-function-key "hunt    backward"
Xbind-to-key next-window			FN^B
X3 label-function-key "next      window"
Xbind-to-key execute-macro		FN^C
X4 label-function-key "exec       macro"
Xbind-to-key find-file			FN^D
X5 label-function-key "find       file"
Xbind-to-key view-file			FN^E
X6 label-function-key "view       file"
Xbind-to-key save-file			FN^F
X7 label-function-key "save       file"
Xbind-to-key exit-emacs			FN^G
X8 label-function-key "exit      emacs"
X
X;	Enter Help
X1 store-macro
X	help
X	8 resize-window
X	bind-to-key execute-macro-12 FNI
X	bind-to-key execute-macro-13 FNQ
X	bind-to-key execute-macro-11 FNT
X	add-mode "red"
X	begining-of-file
X	2 forward-character
X	clear-message-line
X!endm
X
X;	consult file
X2 store-macro
X	2 split-current-window
X	previous-window
X	view-file "@File to Consult: "
X	8 resize-window
X	add-mode "green"
X	add-mode "Black"
X	next-window
X!endm
X
X;	Exit Help
X11 store-macro
X	bind-to-key previous-page FNI
X	bind-to-key next-page FNQ
X	bind-to-key execute-macro-1 FNT
X	delete-window
X	clear-message-line
X!endm
X
X;	last help page
X12 store-macro
X	begining-of-line
X	search-reverse "=>"
X	1 redraw-display
X!endm
X
X;	next help page
X13 store-macro
X	begining-of-line
X	2 forward-character
X	search-forward "=>"
X	1 redraw-display
X!endm
X
X
END_OF_me150.rc
if test 1491 -ne `wc -c <me150.rc`; then
    echo shar: \"me150.rc\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"tcap.c\" \(3889 characters\)
if test -f tcap.c ; then 
  echo shar: Will not over-write existing file \"tcap.c\"
else
sed "s/^X//" >tcap.c <<'END_OF_tcap.c'
X/*	tcap:	Unix V5, V7 and BS4.2 Termcap video driver
X		for MicroEMACS
X*/
X
X#define	termdef	1			/* don't define "term" external */
X
X#include <stdio.h>
X#include	"estruct.h"
X#include        "edef.h"
X
X#if TERMCAP
X
X#define	MARGIN	8
X#define	SCRSIZ	64
X#define	NPAUSE	10			/* # times thru update to pause */
X#define BEL     0x07
X#define ESC     0x1B
X
Xextern int      ttopen();
Xextern int      ttgetc();
Xextern int      ttputc();
Xextern int	tgetnum();
Xextern int      ttflush();
Xextern int      ttclose();
Xextern int	tcapkopen();
Xextern int	tcapkclose();
Xextern int      tcapmove();
Xextern int      tcapeeol();
Xextern int      tcapeeop();
Xextern int      tcapbeep();
Xextern int	tcaprev();
Xextern int	tcapcres();
Xextern int      tcapopen();
Xextern int      tput();
Xextern char     *tgoto();
X#if	COLOR
Xextern	int	tcapfcol();
Xextern	int	tcapbcol();
X#endif
X
X#define TCAPSLEN 315
Xchar tcapbuf[TCAPSLEN];
Xchar *UP, PC, *CM, *CE, *CL, *SO, *SE;
X
XTERM term = {
X	NULL,	/* these four values are set dynamically at open time */
X	NULL,
X	NULL,
X	NULL,
X	MARGIN,
X	SCRSIZ,
X	NPAUSE,
X        tcapopen,
X        ttclose,
X        tcapkopen,
X        tcapkclose,
X        ttgetc,
X        ttputc,
X        ttflush,
X        tcapmove,
X        tcapeeol,
X        tcapeeop,
X        tcapbeep,
X        tcaprev,
X        tcapcres
X#if	COLOR
X	, tcapfcol,
X	tcapbcol
X#endif
X};
X
Xtcapopen()
X
X{
X        char *getenv();
X        char *t, *p, *tgetstr();
X        char tcbuf[1024];
X        char *tv_stype;
X        char err_str[72];
X
X        if ((tv_stype = getenv("TERM")) == NULL)
X        {
X                puts("Environment variable TERM not defined!");
X                exit(1);
X        }
X
X        if ((tgetent(tcbuf, tv_stype)) != 1)
X        {
X                sprintf(err_str, "Unknown terminal type %s!", tv_stype);
X                puts(err_str);
X                exit(1);
X        }
X
X 
X       if ((term.t_nrow=(short)tgetnum("li")-1) == -1){
X               puts("termcap entry incomplete (lines)");
X               exit(1);
X       }
X	term.t_mrow =  term.t_nrow;
X
X       if ((term.t_ncol=(short)tgetnum("co")) == -1){
X               puts("Termcap entry incomplete (columns)");
X               exit(1);
X       }
X	term.t_mcol = term.t_ncol;
X
X        p = tcapbuf;
X        t = tgetstr("pc", &p);
X        if(t)
X                PC = *t;
X
X        CL = tgetstr("cl", &p);
X        CM = tgetstr("cm", &p);
X        CE = tgetstr("ce", &p);
X        UP = tgetstr("up", &p);
X	SE = tgetstr("se", &p);
X	SO = tgetstr("so", &p);
X	if (SO != NULL)
X		revexist = TRUE;
X
X        if(CL == NULL || CM == NULL || UP == NULL)
X        {
X                puts("Incomplete termcap entry\n");
X                exit(1);
X        }
X
X	if (CE == NULL)		/* will we be able to use clear to EOL? */
X		eolexist = FALSE;
X		
X        if (p >= &tcapbuf[TCAPSLEN])
X        {
X                puts("Terminal description too big!\n");
X                exit(1);
X        }
X        ttopen();
X}
X
Xtcapkopen()
X
X{
X	strcpy(sres, "NORMAL");
X}
X
Xtcapkclose()
X
X{
X}
X
Xtcapmove(row, col)
Xregister int row, col;
X{
X        putpad(tgoto(CM, col, row));
X}
X
Xtcapeeol()
X{
X        putpad(CE);
X}
X
Xtcapeeop()
X{
X        putpad(CL);
X}
X
Xtcaprev(state)		/* change reverse video status */
X
Xint state;		/* FALSE = normal video, TRUE = reverse video */
X
X{
X	static int revstate = FALSE;
X	if (state) {
X		if (SO != NULL)
X			putpad(SO);
X	} else
X		if (SE != NULL)
X			putpad(SE);
X}
X
Xtcapcres()	/* change screen resolution */
X
X{
X	return(TRUE);
X}
X
X#if	COLOR
Xtcapfcol()	/* no colors here, ignore this */
X{
X}
X
Xtcapbcol()	/* no colors here, ignore this */
X{
X}
X#endif
X
Xtcapbeep()
X{
X	ttputc(BEL);
X}
X
Xputpad(str)
Xchar    *str;
X{
X	tputs(str, 1, ttputc);
X}
X
Xputnpad(str, n)
Xchar    *str;
X{
X	tputs(str, n, ttputc);
X}
X
X
X#if	FLABEL
Xfnclabel(f, n)		/* label a function key */
X
Xint f,n;	/* default flag, numeric argument [unused] */
X
X{
X	/* on machines with no function keys...don't bother */
X	return(TRUE);
X}
X#endif
X#else
X
Xhello()
X{
X}
X
X#endif TERMCAP
END_OF_tcap.c
if test 3889 -ne `wc -c <tcap.c`; then
    echo shar: \"tcap.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"vt52.c\" \(3194 characters\)
if test -f vt52.c ; then 
  echo shar: Will not over-write existing file \"vt52.c\"
else
sed "s/^X//" >vt52.c <<'END_OF_vt52.c'
X/*
X * The routines in this file
X * provide support for VT52 style terminals
X * over a serial line. The serial I/O services are
X * provided by routines in "termio.c". It compiles
X * into nothing if not a VT52 style device. The
X * bell on the VT52 is terrible, so the "beep"
X * routine is conditionalized on defining BEL.
X */
X#define	termdef	1			/* don't define "term" external */
X
X#include        <stdio.h>
X#include        "estruct.h"
X#include	"edef.h"
X
X#if     VT52
X
X#define NROW    24                      /* Screen size.                 */
X#define NCOL    80                      /* Edit if you want to.         */
X#define	MARGIN	8			/* size of minimim margin and	*/
X#define	SCRSIZ	64			/* scroll size for extended lines */
X#define	NPAUSE	100			/* # times thru update to pause */
X#define BIAS    0x20                    /* Origin 0 coordinate bias.    */
X#define ESC     0x1B                    /* ESC character.               */
X#define BEL     0x07                    /* ascii bell character         */
X
Xextern  int     ttopen();               /* Forward references.          */
Xextern  int     ttgetc();
Xextern  int     ttputc();
Xextern  int     ttflush();
Xextern  int     ttclose();
Xextern  int     vt52move();
Xextern  int     vt52eeol();
Xextern  int     vt52eeop();
Xextern  int     vt52beep();
Xextern  int     vt52open();
Xextern	int	vt52rev();
Xextern	int	vt52kopen();
Xextern	int	vt52kclose();
X
X#if	COLOR
Xextern	int	vt52fcol();
Xextern	int	vt52bcol();
X#endif
X
X/*
X * Dispatch table. All the
X * hard fields just point into the
X * terminal I/O code.
X */
XTERM    term    = {
X	NROW-1,
X        NROW-1,
X        NCOL,
X        NCOL,
X	MARGIN,
X	SCRSIZ,
X	NPAUSE,
X        &vt52open,
X        &ttclose,
X	&vt52kopen,
X	&vt52kclose,
X        &ttgetc,
X        &ttputc,
X        &ttflush,
X        &vt52move,
X        &vt52eeol,
X        &vt52eeop,
X        &vt52beep,
X        &vt52rev
X#if	COLOR
X	, &vt52fcol,
X	&vt52bcol
X#endif
X};
X
Xvt52move(row, col)
X{
X        ttputc(ESC);
X        ttputc('Y');
X        ttputc(row+BIAS);
X        ttputc(col+BIAS);
X}
X
Xvt52eeol()
X{
X        ttputc(ESC);
X        ttputc('K');
X}
X
Xvt52eeop()
X{
X        ttputc(ESC);
X        ttputc('J');
X}
X
Xvt52rev(status)	/* set the reverse video state */
X
Xint status;	/* TRUE = reverse video, FALSE = normal video */
X
X{
X	/* can't do this here, so we won't */
X}
X
X#if	COLOR
Xvt52fcol()	/* set the forground color [NOT IMPLIMENTED] */
X{
X}
X
Xvt52bcol()	/* set the background color [NOT IMPLIMENTED] */
X{
X}
X#endif
X
Xvt52beep()
X{
X#ifdef  BEL
X        ttputc(BEL);
X        ttflush();
X#endif
X}
X
Xvt52open()
X{
X#if     V7 | BSD
X        register char *cp;
X        char *getenv();
X
X        if ((cp = getenv("TERM")) == NULL) {
X                puts("Shell variable TERM not defined!");
X                exit(1);
X        }
X        if (strcmp(cp, "vt52") != 0 && strcmp(cp, "z19") != 0) {
X                puts("Terminal type not 'vt52'or 'z19' !");
X                exit(1);
X        }
X#endif
X        ttopen();
X}
X
Xvt52kopen()
X
X{
X}
X
Xvt52kclose()
X
X{
X}
X
X
X#if	FLABEL
Xfnclabel(f, n)		/* label a function key */
X
Xint f,n;	/* default flag, numeric argument [unused] */
X
X{
X	/* on machines with no function keys...don't bother */
X	return(TRUE);
X}
X#endif
X#else
X
Xvt52hello()
X
X{
X}
X
X#endif
END_OF_vt52.c
if test 3194 -ne `wc -c <vt52.c`; then
    echo shar: \"vt52.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 1 \(of 14\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    echo "See the readme file"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
