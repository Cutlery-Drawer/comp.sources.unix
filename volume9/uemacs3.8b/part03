Subject:  v09i035:  MicroEMACS, version 3.8b, Part03/14
Path: mirror!sources-request
From: sources-request@mirror.TMC.COM
Newsgroups: comp.sources.unix
Message-ID: <2286@mirror.TMC.COM>
Sender: rs@mirror.TMC.COM
Approved: rs@mirror.TMC.COM
Lines: 1528

Submitted by: ihnp4!itivax!duncan!lawrence (Daniel Lawrence)
Mod.sources: Volume 9, Issue 35
Archive-name: uemacs3.8b/Part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If this archive is complete, you will see the message:
#		"End of archive 3 (of 14)."
# Contents:  edef.h emacs.hlp hp150.c input.c menu1
# Wrapped by rs@mirror on Fri Mar 13 13:23:33 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"edef.h\" \(8520 characters\)
if test -f edef.h ; then 
  echo shar: Will not over-write existing file \"edef.h\"
else
sed "s/^X//" >edef.h <<'END_OF_edef.h'
X/*	EDEF:		Global variable definitions for
X			MicroEMACS 3.2
X
X			written by Dave G. Conroy
X			modified by Steve Wilhite, George Jones
X			greatly modified by Daniel Lawrence
X*/
X
X/* some global fuction declarations */
X
Xchar *malloc();
Xchar *strcpy();
Xchar *strcat();
Xchar *strncpy();
Xchar *itoa();
Xchar *getval();
Xchar *gtenv();
Xchar *gtusr();
Xchar *gtfun();
Xchar *token();
Xchar *ltos();
Xchar *flook();
X
X#ifdef	maindef
X
X/* for MAIN.C */
X
X/* initialized global definitions */
X
Xint     fillcol = 72;                   /* Current fill column          */
Xshort   kbdm[NKBDM];			/* Macro                        */
Xchar    pat[NPAT];                      /* Search pattern		*/
Xchar	rpat[NPAT];			/* replacement pattern		*/
Xchar	*execstr = NULL;		/* pointer to string to execute	*/
Xchar	golabel[NPAT] = "";		/* current line to go to	*/
Xint	execlevel = 0;			/* execution IF level		*/
Xint	eolexist = TRUE;		/* does clear to EOL exist	*/
Xint	revexist = FALSE;		/* does reverse video exist?	*/
Xint	flickcode = FALSE;		/* do flicker supression?	*/
Xchar	*modename[] = {			/* name of modes		*/
X	"WRAP", "CMODE", "SPELL", "EXACT", "VIEW", "OVER", "MAGIC", "CRYPT"};
Xchar	modecode[] = "WCSEVOMY";	/* letters to represent modes	*/
Xint	gmode = 0;			/* global editor mode		*/
Xint	gfcolor = 7;			/* global forgrnd color (white)	*/
Xint	gbcolor	= 0;			/* global backgrnd color (black)*/
Xint     sgarbf  = TRUE;                 /* TRUE if screen is garbage	*/
Xint     mpresf  = FALSE;                /* TRUE if message in last line */
Xint	clexec	= FALSE;		/* command line execution flag	*/
Xint	mstore	= FALSE;		/* storing text to macro flag	*/
Xstruct	BUFFER *bstore = NULL;		/* buffer to store macro text to*/
Xint     vtrow   = 0;                    /* Row location of SW cursor */
Xint     vtcol   = 0;                    /* Column location of SW cursor */
Xint     ttrow   = HUGE;                 /* Row location of HW cursor */
Xint     ttcol   = HUGE;                 /* Column location of HW cursor */
Xint	lbound	= 0;			/* leftmost column of current line
X					   being displayed */
Xint	taboff	= 0;			/* tab offset for display	*/
Xint	metac = CTRL | '[';		/* current meta character */
Xint	ctlxc = CTRL | 'X';		/* current control X prefix char */
Xint	reptc = CTRL | 'U';		/* current universal repeat char */
Xint	abortc = CTRL | 'G';		/* current abort command char	*/
X
Xint	quotec = 0x11;			/* quote char during mlreply() */
Xchar	*cname[] = {			/* names of colors		*/
X	"BLACK", "RED", "GREEN", "YELLOW", "BLUE",
X	"MAGENTA", "CYAN", "WHITE"};
XKILL *kbufp  = NULL;		/* current kill buffer chunk pointer	*/
XKILL *kbufh  = NULL;		/* kill buffer header pointer		*/
Xint kused = KBLOCK;		/* # of bytes used in kill buffer	*/
XWINDOW *swindow = NULL;		/* saved window pointer			*/
Xint cryptflag = FALSE;		/* currently encrypting?		*/
Xshort	*kbdptr;		/* current position in keyboard buf */
Xshort	*kbdend = &kbdm[0];	/* ptr to end of the keyboard */
Xint	kbdmode = STOP;		/* current keyboard macro mode	*/
Xint	kbdrep = 0;		/* number of repetitions	*/
Xint	restflag = FALSE;	/* restricted use?		*/
Xlong	envram = 0l;	/* # of bytes current in use by malloc */
Xint	macbug = FALSE;		/* macro debuging flag		*/
Xchar	errorm[] = "ERROR";	/* error literal		*/
Xchar	truem[] = "TRUE";	/* true literal			*/
Xchar	falsem[] = "FALSE";	/* false litereal		*/
Xint	cmdstatus = TRUE;	/* last command status		*/
X
X/* uninitialized global definitions */
X
Xint     currow;                 /* Cursor row                   */
Xint     curcol;                 /* Cursor column                */
Xint     thisflag;               /* Flags, this command          */
Xint     lastflag;               /* Flags, last command          */
Xint     curgoal;                /* Goal for C-P, C-N            */
XWINDOW  *curwp;                 /* Current window               */
XBUFFER  *curbp;                 /* Current buffer               */
XWINDOW  *wheadp;                /* Head of list of windows      */
XBUFFER  *bheadp;                /* Head of list of buffers      */
XBUFFER  *blistp;                /* Buffer for C-X C-B           */
X
XBUFFER  *bfind();               /* Lookup a buffer by name      */
XWINDOW  *wpopup();              /* Pop up window creation       */
XLINE    *lalloc();              /* Allocate a line              */
Xchar	sres[NBUFN];		/* current screen resolution	*/
X
X#else
X
X/* for all the other .C files */
X
X/* initialized global external declarations */
X
Xextern  int     fillcol;                /* Fill column                  */
Xextern  short   kbdm[];                 /* Holds kayboard macro data    */
Xextern  char    pat[];                  /* Search pattern               */
Xextern	char	rpat[];			/* Replacement pattern		*/
Xextern	char	*execstr;		/* pointer to string to execute	*/
Xextern	char	golabel[];		/* current line to go to	*/
Xextern	int	execlevel;		/* execution IF level		*/
Xextern	int	eolexist;		/* does clear to EOL exist?	*/
Xextern	int	revexist;		/* does reverse video exist?	*/
Xextern	int	flickcode;		/* do flicker supression?	*/
Xextern	char *modename[];		/* text names of modes		*/
Xextern	char	modecode[];		/* letters to represent modes	*/
Xextern	KEYTAB keytab[];		/* key bind to functions table	*/
Xextern	NBIND names[];			/* name to function table	*/
Xextern	int	gmode;			/* global editor mode		*/
Xextern	int	gfcolor;		/* global forgrnd color (white)	*/
Xextern	int	gbcolor;		/* global backgrnd color (black)*/
Xextern  int     sgarbf;                 /* State of screen unknown      */
Xextern  int     mpresf;                 /* Stuff in message line        */
Xextern	int	clexec;			/* command line execution flag	*/
Xextern	int	mstore;			/* storing text to macro flag	*/
Xextern	struct	BUFFER *bstore;		/* buffer to store macro text to*/
Xextern	int     vtrow;                  /* Row location of SW cursor */
Xextern	int     vtcol;                  /* Column location of SW cursor */
Xextern	int     ttrow;                  /* Row location of HW cursor */
Xextern	int     ttcol;                  /* Column location of HW cursor */
Xextern	int	lbound;			/* leftmost column of current line
X					   being displayed */
Xextern	int	taboff;			/* tab offset for display	*/
Xextern	int	metac;			/* current meta character */
Xextern	int	ctlxc;			/* current control X prefix char */
Xextern	int	reptc;			/* current universal repeat char */
Xextern	int	abortc;			/* current abort command char	*/
X
Xextern	int	quotec;			/* quote char during mlreply() */
Xextern	char	*cname[];		/* names of colors		*/
Xextern KILL *kbufp;			/* current kill buffer chunk pointer */
Xextern KILL *kbufh;			/* kill buffer header pointer	*/
Xextern int kused;			/* # of bytes used in KB        */
Xextern WINDOW *swindow;			/* saved window pointer		*/
Xextern int cryptflag;			/* currently encrypting?	*/
Xextern	short	*kbdptr;		/* current position in keyboard buf */
Xextern	short	*kbdend;		/* ptr to end of the keyboard */
Xextern	int kbdmode;			/* current keyboard macro mode	*/
Xextern	int kbdrep;			/* number of repetitions	*/
Xextern	int restflag;			/* restricted use?		*/
Xextern	long envram;		/* # of bytes current in use by malloc */
Xextern	int	macbug;			/* macro debuging flag		*/
Xextern	char	errorm[];		/* error literal		*/
Xextern	char	truem[];		/* true literal			*/
Xextern	char	falsem[];		/* false litereal		*/
Xextern	int	cmdstatus;		/* last command status		*/
X
X/* uninitialized global external declarations */
X
Xextern  int     currow;                 /* Cursor row                   */
Xextern  int     curcol;                 /* Cursor column                */
Xextern  int     thisflag;               /* Flags, this command          */
Xextern  int     lastflag;               /* Flags, last command          */
Xextern  int     curgoal;                /* Goal for C-P, C-N            */
Xextern  WINDOW  *curwp;                 /* Current window               */
Xextern  BUFFER  *curbp;                 /* Current buffer               */
Xextern  WINDOW  *wheadp;                /* Head of list of windows      */
Xextern  BUFFER  *bheadp;                /* Head of list of buffers      */
Xextern  BUFFER  *blistp;                /* Buffer for C-X C-B           */
X
Xextern  BUFFER  *bfind();               /* Lookup a buffer by name      */
Xextern  WINDOW  *wpopup();              /* Pop up window creation       */
Xextern  LINE    *lalloc();              /* Allocate a line              */
Xextern	char	sres[NBUFN];		/* current screen resolution	*/
X
X#endif
X
X/* terminal table defined only in TERM.C */
X
X#ifndef	termdef
Xextern  TERM    term;                   /* Terminal information.        */
X#endif
X
X
END_OF_edef.h
if test 8520 -ne `wc -c <edef.h`; then
    echo shar: \"edef.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"emacs.hlp\" \(8644 characters\)
if test -f emacs.hlp ; then 
  echo shar: Will not over-write existing file \"emacs.hlp\"
else
sed "s/^X//" >emacs.hlp <<'END_OF_emacs.hlp'
X=>		MicroEMACS 3.8 Help screens		(01/18/87)
X
X	M-  means to use the <ESC> key prior to using another key
X	^A  means to use the control key at the same time as the A key
X
X^V or [Pg Dn]     Scroll down		M-< or <HOME>	Begining of file
X^Z or [Pg Up]     Scroll up		M-> or <END>	End of file
X
X-----------------------------------------------------------------------
X=>		(1) MOVING THE CURSOR
X
X^F  Forward character   M-F    Forward word		Keypad arrows
X^B  Backward character  M-B    Backward word		are active!
X^A  Front of line	M-G    Goto a line
X^E  End of line		
X^N  Next line		M-N    Front of paragraph
X^P  Previous line	M-P    End of paragraph
X-----------------------------------------------------------------------
X=>		(2) DELETING & INSERTING
X
X<--             Delete previous character
X^D or <DELETE>  Delete next character
X^C or <INSERT>  Insert a space
XM-<--           Delete previous word
XM-D             Delete next word
X^K              Close (delete) to end of line
X-----------------------------------------------------------------------
X=>		(2a) MORE DELETING & INSERTING
X
X<RETURN>   Insert a newline             <TAB>  Advance to next tab stop
X^J         Insert a newline and indent  M-^W   Delete paragraph
X^O         Open (insert) line
X^W         Delete region between mark (set using M-<spacebar>) and cursor
XM-W        Copy region to kill buffer
X^X ^O      Delete blank lines around cursor
X-----------------------------------------------------------------------
X=>		(3) SEARCHING
X
X^S	Search forward from cursor position.
X^R	Reverse search from cursor position.
X^X S	Forward incremental search
X^X R	Reverse incremental search
X<ALT> S	Search for the next occurence of the last string (IBM-PC only)
X<ALT> R	Search for the last occurence of the last string (IBM-PC only)
X-----------------------------------------------------------------------
X=>		(4) REPLACING
X
XM-R   Replace all instances of first typed-in string with second
X          typed-in string.  End each string with ESC.
XM-^R  Replace with query.  Answer with:
X	^G  cancel			.   exit to entry point
X	!   replace the rest		Y    replace & continue
X	?   Get a list of options	N   no replacement & continue
X-----------------------------------------------------------------------
X=>		(5) CAPITALIZING & TRANSPOSING
X
XM-U	UPPERCASE word
XM-C	Capitalize word		^T	Transpose characters
XM-L	lowercase word
X^X ^L	lowercase region
X^X ^U	uppercase region
X^Q	Quote next entry, so that control codes may be entered into text
X-----------------------------------------------------------------------
X=>		(6) REGIONS & THE KILL BUFFER
X
XM-<spacebar>	set MARK at current position
X^X ^X		eXchange mark and cursor
X
XA REGION will then be continuously-defined as the area between the mark and
Xthe current cursor position.  The KILL BUFFER is the text which has been
Xmost recently saved or deleted.
X-----------------------------------------------------------------------
X=>		(7) COPYING AND MOVING
X
X^W  Delete (Wipe) region		M-W	copy region to KILL buffer
X^Y  Yankback save buffer at cursor
XGenerally, the procedure for copying or moving text is:
X    1)  Mark a REGION using M-<spacebar> at beginning and cursor at end.
X    2)  Delete it (with ^W) or copy it (with M-W) into the KILL buffer.
X    3)  Move the cursor to the desired location and yank it back (with ^Y).
X-----------------------------------------------------------------------
X=>		(8) MODES OF OPERATION
X^X M	Add mode in buffer              M-M    Add global mode
X^X ^M   Delete mode in buffer           M-^M   Delete global mode
XOVER		Replaces (overwrites) rather than inserts characters
XWRAP		Turns on word wrap (automatic carraige return).
XVIEW		Allows viewing file without insertion and deletion.
XCMODE		Automatic indenting for C program entry
XEXACT/MAGIC	Changes how search and replace commands work (see next page)
X-----------------------------------------------------------------------
X=>		(9) SEARCH AND REPLACE MODES
X
XEXACT	Uppper/lower case is not ignored in searches
XMAGIC   Regular pattern matching characters are active
X    .   Matches any one character
X    *   Matches any any number of the preceding character
X    ^   Beginning of line        [ ]   Character class enclosure
X    $   End of line              \     Quote next character
X-----------------------------------------------------------------------
X=>		(10) ON-SCREEN FORMATTING
X
X^X F		Set fill column
XMn-<tab>	Set tab spacing to n charecters between tabs stops
XM-Q		Format paragraph so that text lies between margins
X^X =		Position report -- displays line number, char count,
X                                   file size and character under cursor
XM-^C		Count words/lines/chars in marked region
X-----------------------------------------------------------------------
X=>		(11) MULTIPLE WINDOWS
X
XMany WINDOWS may be active at once on the screen.  All windows may show
Xdifferent parts of the same buffer, or each may display a different one.
X^X 2	Split the current window in two	^X O	Change to next window
X^X 0    delete current window           ^X P    Change to previous window
X^X 1	delete all other windows        M-^V    Page down next window
X                                  	M-^Z	Page up other window
X-----------------------------------------------------------------------
X=>		(12) CONTROLLING WINDOWS AND THE SCREEN
X
X^X ^    Enlarge current window   M-<n> ^X W   Resize window to <n> lines
X^X ^Z   Shrink current window    M-<n> M-S    Change screen to <n> lines
X^X ^N   Move window down         M-<n> M-T    Change screen to <n> columns
X^X ^P   Move window up
XM-^L    Reposition window
X^L      Refresh the screen
X-----------------------------------------------------------------------
X=>		(13) MULTIPLE BUFFERS
XA BUFFER is a named area containing a document being edited.  Many buffers
Xmay be activated at once.
X^X B	Switch to another buffer.  <CR> = use just-previous buffer
X^X X	Switch to next buffer in buffer list
XM-^N    Change name of current buffer
X^X K	Delete a non-displayed buffer.
X^X ^B	Display buffer directory in a window
X-----------------------------------------------------------------------
X=>		(14) READING FROM DISK
X
X^X ^F	Find file; read into a new buffer created from filename.
X	(This is the usual way to begin editing a new file.)
X^X ^R	Read file into current buffer, erasing its previous contents.
X	No new buffer will be created.
X^X ^I	Insert file into current buffer at cursor's location.
X^X ^V	Find a file to make current in VIEW mode
X-----------------------------------------------------------------------
X=>		(15) SAVING TO DISK
X
X^X ^S	Save current buffer to disk
X^X ^W	Write current buffer to disk
X^X N    Change file name of current buffer
XM-Z	Write out all changed buffers and exit MicroEMACS
X
X
X-----------------------------------------------------------------------
X=>		(16) ACCESSING THE OPERATING SYSTEM
X
X^X !	Send one command to the operating system and return
X^X @	Pipe DOS command results to buffer
X^X #	Filter buffer through DOS filter program
X^X C	Start a new command processor under MicroEMACS
X^X D	Suspend MicroEMACS into the background (UNIX BSD4.2 only)
X^X ^C	Exit MicroEMACS
X-----------------------------------------------------------------------
X=>		(17) KEY BINDINGS AND COMMANDS
X
XM-K	Bind a key to a command        M-A  Describe a class of commands
XM-^K	Unbind a key from a command
X^X ?	Describe command bound to a key
XM-X	Execute a named (and possibly unbound) command
X{Describe-bindings}
X	Display a list of all commands and key bindings to a buffer
X-----------------------------------------------------------------------
X=>		(18) COMMAND EXECUTION
XCommands can be specified as command lines in the form:
X	<optional repeat count> {command-name} <optional arguments>
X{Execute-command-line}	execute a typed in command line
X{Execute-buffer}	executes commands lines in a buffer
X{Execute-file}		executes command lines from a file
X{clear-message-line}	clears the message line during execution
X   M-~			clears the change flag for a buffer
X-----------------------------------------------------------------------
X=>		(19) MACRO EXECUTION
X
X^X (	Start recording keyboard macro
X^X )	Stop recording keyboard macro
X^X E	Execute keyboard macro
XM-<n> {store-macro}	Start recording named macro
X      !endm		Stop recording named macro
X{execute-macro-n}	Execute macro n (where n is from 1 to 20)
X-----------------------------------------------------------------------
X=>		(20) SPECIAL KEYS
X
X^G		Cancel current command and return to top level of processing.
X^U or		Universal repeat.  May be followed by an integer (default = 4)
XM-<digit>	and repeats the next command that many times.
XM-X		Execute a named (and possibly unbound) command
X
X
END_OF_emacs.hlp
if test 8644 -ne `wc -c <emacs.hlp`; then
    echo shar: \"emacs.hlp\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"hp150.c\" \(9129 characters\)
if test -f hp150.c ; then 
  echo shar: Will not over-write existing file \"hp150.c\"
else
sed "s/^X//" >hp150.c <<'END_OF_hp150.c'
X/*
X * The routines in this file provide support for HP150 screens
X * and routines to access the Keyboard through KEYCODE mode.
X * It compiles into nothing if not an HP150 screen device.
X * added by Daniel Lawrence
X */
X
X#define	termdef	1			/* don't define "term" external */
X
X#include        <stdio.h>
X#include        "estruct.h"
X#include	"edef.h"
X
X#if     HP150
X
X#define NROW    24                      /* Screen size.                 */
X#define NCOL    80                      /* Edit if you want to.         */
X#define	MARGIN	8			/* size of minimim margin and	*/
X#define	SCRSIZ	64			/* scroll size for extended lines */
X#define	NPAUSE	15			/* # times thru update to pause */
X#define BEL     0x07                    /* BEL character.               */
X#define ESC     0x1B                    /* ESC character.               */
X
Xextern  int     openhp();               /* Forward references.          */
Xextern  int     ttgetc();
Xextern  int     ttputc();
Xextern  int     ttflush();
Xextern	int	hpflush();
Xextern  int     closehp();
Xextern	int	hp15kopen();
Xextern	int	hp15kclose();
Xextern  int     hp15move();
Xextern  int     hp15eeol();
Xextern  int     hp15eeop();
Xextern  int     hp15beep();
Xextern	int	gethpkey();
Xextern	int	hp15rev();
Xextern	int	hp15cres();
X#if	COLOR
Xextern	int	hp15fcol();
Xextern	int	hp15bcol();
X#endif
X
X/* weird to ascii translation table */
X
Xchar trans[][2] = {
X	0x24,	9,	/* tab */
X	0x25,	13,	/* ret */
X	0x27,	8,	/* backspace */
X	0x30,	48,	/* zero */
X	0x31,	49,	/* one */
X	0x32,	50,	/* two */
X	0x33,	51,	/* three */
X	0x34,	52,	/* four */
X	0x35,	53,	/* five */
X	0x36,	54,	/* six */
X	0x37,	55,	/* seven */
X	0x38,	56,	/* eight */
X	0x39,	57,	/* nine */
X	0x50,	13,	/* enter */
X	0x54,	27,	/* break -> ESC */
X	0x55,	27,	/* esc */
X	0x58,	24,	/* stop -> ^X */
X	0x70,	45,	/* N-minus */
X	0x71,	42,	/* N-asterisk */
X	0x72,	43,	/* N-plus */
X	0x73,	47,	/* N-slash */
X	0x74,	44,	/* N-comma */
X	0x75,	13,	/* N-enter */
X	0x76,	9,	/* N-tab */
X	0x77,	46	/* N-period */
X};
X
X#define NTRANS	sizeof(trans) / 2
X
Xunion REGS r;		/* register set for bios and dos (AGIOS) calls */
Xint capslock = 0;	/* caps lock flag */
X
X/*
X * Standard terminal interface dispatch table. Most of the fields point into
X * "termio" code.
X */
XTERM    term    = {
X	NROW-1,
X        NROW-1,
X        NCOL,
X        NCOL,
X	MARGIN,
X	SCRSIZ,
X	NPAUSE,
X	openhp,
X        closehp,
X	hp15kopen,
X	hp15kclose,
X	gethpkey,
X        ttputc,
X        hpflush,
X        hp15move,
X        hp15eeol,
X        hp15eeop,
X        hp15beep,
X        hp15rev,
X        hp15cres
X#if	COLOR
X	, hp15fcol,
X	hp15bcol
X#endif
X};
X
Xhp15move(row, col)
X{
X        ttputc(ESC);
X        ttputc('&');
X        ttputc('a');
X        hp15parm(col);
X        ttputc('c');
X        hp15parm(row);
X        ttputc('R');
X}
X
Xhpflush()
X
X{
X
X}
X
Xhp15eeol()
X{
X        ttputc(ESC);
X        ttputc('K');
X}
X
Xhp15eeop()
X{
X        ttputc(ESC);
X        ttputc('J');
X}
X
Xhp15rev(status)		/* change the reverse video status */
X
Xint status;	/* TRUE = on, FALSE = off */
X
X{
X	ttputc(ESC);
X	ttputc('&');
X	ttputc('d');
X	ttputc((status != FALSE) ? 'B': '@');
X}
X
Xhp15cres()	/* change screen resolution */
X
X{
X	return(TRUE);
X}
X
Xhp15beep()
X{
X        ttputc(BEL);
X        ttflush();
X}
X
Xhp15parm(n)
Xregister int    n;
X{
X        register int    q;
X
X        q = n/10;
X        if (q != 0)
X                hp15parm(q);
X        ttputc((n%10) + '0');
X}
X
X#if	COLOR
Xhp15fcol()	/* we really can't do colors here, so just ignore it */
X{
X}
X
Xhp15bcol()	/* we really can't do colors here, so just ignore it */
X{
X}
X#endif
X
Xgethpkey()	/* get a key from the HP keyboard while in keycode mode */
X
X{
X	static int keepflag = 0;	/* kept ahead char flag */
X	static int keepchar = 0;	/* kept ehead flag */
X	int c;
X	int devid;			/* device ID */
X	int ctype;			/* type of character gotten */
X	int shiftb;			/* state of shift keys */
X	int i;
X	
X	/* if we are in an extended char sequence, finish it */
X	if (keepflag != 0) {
X		keepflag = 0;
X		return(keepchar);
X	}
X
X	/* grab the next 4 char sequence */
Xnext:	shiftb = ttgetc();
X	devid = ttgetc();
X	c = ttgetc();
X	ttgetc();		/* skip null byte */
X	
X	/* make sure we are from the keyboard */
X	if (devid != 192)
X		goto next;
X
X	/* if normal ascii, return it */
X	if ((shiftb & 0x80) == 0) {
X		if (capslock && c >= 'a' && c <= 'z')
X			c -= 32;
X		return(c);
X	}
X
X	/* check specifically for the caps lock key */
X	if (c == 0x56) {
X		capslock = ~capslock;
X		goto next;
X	}
X
X	/* check to see if it needs translation */
X	for (i=0; i < NTRANS; i++)
X		if (trans[i][0] == c)
X			return((int)trans[i][1]);
X
X	/* other wise, shove it in the keep char and return the leadin code */
X	keepchar = c;
X	keepflag = 1;
X	return(0);
X}
X
Xopenhp()		/* open the HP150 screen for input */
X
X{
X	strcpy(sres, "NORMAL");
X	revexist = TRUE;
X}
X
Xclosehp()		/* close the HP150 screen for input */
X
X{
X}
X
Xhp15kopen()		/* open the HP150 keyboard for input */
X
X{
X	/* define key charectoristics with AGIOS call (0, 40) */
X	defkey();
X
X	/* Turn on RAW mode with MSDOS call 44h */
X	rawon();
X
X	/* Turn off Control-C checking  MS-DOS 33h */
X	ckeyoff();
X
X	/* Turn on keycode mode with AGIOS call (0,43) */
X	keycon();
X
X	/* display the application softkey labels */
X	dsplbls();
X}
X
Xhp15kclose()		/* close the HP150 keyboard for input */
X
X{
X	/* define key charectoristics with AGIOS call (0, 40) */
X	undefkey();
X	
X	/* Turn off RAW mode with MSDOS call 44h */
X	rawoff();
X
X	/* Turn on Control-C checking  MS-DOS 33h */
X	ckeyon();
X
X	/* Turn off keycode mode with AGIOS call (0,43) */
X	keycoff();
X}
X
Xrawon()		/* put the HP150 keyboard into RAW mode */
X
X{
X	/* get the IO control info */
X
X	r.x.ax = 0x4400;	/* IO ctrl get device information */
X	r.x.bx = 0x0001;	/* File handle; 1 for console */
X	intdos(&r, &r);		/* go fer it */
X
X	r.h.dh = 0;		/* clear high byte for put */
X	r.h.dl |= 0x20;		/* set raw bit */
X
X	/* and put it back */
X
X	r.x.ax = 0x4401;	/* IO ctrl put device information */
X	r.x.bx = 0x0001;	/* File handle; 1 for console */
X	intdos(&r, &r);		/* go fer it */
X}
X
Xrawoff()	/* put the HP150 keyboard into COOKED mode */
X
X{
X	/* get the IO control info */
X
X	r.x.ax = 0x4400;	/* IO ctrl get device information */
X	r.x.bx = 0x0001;	/* File handle; 1 for console */
X	intdos(&r, &r);		/* go fer it */
X
X	r.h.dh = 0;		/* clear high byte for put */
X	r.h.dl &= 0xdf;		/* set raw bit */
X
X	/* and put it back */
X
X	r.x.ax = 0x4401;	/* IO ctrl put device information */
X	r.x.bx = 0x0001;	/* File handle; 1 for console */
X	intdos(&r, &r);		/* go fer it */
X}
X
X
Xckeyoff()	/* turn control-C trapping off */
X
X{
X	r.h.ah = 0x33;	/* ctrl-break check */
X	r.h.al = 1;	/* set the state of the ctrl-break check */
X	r.h.dl = 0;	/* turn it off */
X	intdos(&r, &r);
X}
X
Xckeyon()	/* turn control-C trapping on */
X
X{
X	r.h.ah = 0x33;	/* ctrl-break check */
X	r.h.al = 1;	/* set the state of the ctrl-break check */
X	r.h.dl = 1;	/* turn it on */
X	intdos(&r, &r);
X}
X
Xagios(buf, len)	/* perform an AGIOS call */
X
Xchar *buf;	/* sequence of bytes in command */
Xint len;	/* length of command in bytes */
X
X{
X	r.x.ax = 0x4403;	/* I/O ctrl write */
X	r.x.bx = 1;		/* console handle */
X	r.x.cx = len;		/* buffer length */
X	r.x.dx = (unsigned)buf;	/* buffer address */
X	return(intdos(&r, &r));	/* do it */
X}
X
Xkeycon()	/* turn keycode mode on */
X
X{
X	static char cmd[] = {43, 0, 1};
X
X	return(agios(&cmd[0], 3));
X}
X
Xkeycoff()	/* turn keycode mode off */
X
X{
X	static char cmd[] = {43, 0, 0};
X
X	return(agios(&cmd[0], 3));
X}
X
Xdefkey()	/* change all special keys to intercept mode */
X
X{
X	static char cmd[] = {40, 0, 2, 0, 0xfe, 0};
X
X	return(agios(&cmd[0], 6));
X}
X
Xundefkey()	/* change all special keys to intercept mode */
X
X{
X	static char cmd[] = {40, 0, 0, 0, 0xfe, 0};
X
X	return(agios(&cmd[0], 6));
X}
X
Xdsplbls()	/* display the application softkey labels on the screen */
X
X{
X	static char cmd[] = {11, 0};
X
X	return(agios(&cmd[0], 2));
X}
X
X#if	FLABEL
Xfnclabel(f, n)		/* label a function key */
X
Xint f,n;	/* default flag, numeric argument */
X
X{
X	register int status;	/* return status */
X	register int i;		/* loop index */
X	char lbl[17];	/* returned label contents */
X	/* AGIOS command buffer */
X	static char cmd[] = {8, 0, 1, 0, 7, 7, 7, 7, 10, 0, 10, 0};
X	/*                   code  key#  ptr to      top    bottom
X	                                 label string  attribute */
X	union {		/* union to cast ptr into AGIOS arg string */
X		char *ptr;	/* pointer to arg string */
X		char cstr[4];
X	} ptru;
X
X	/* must have a numeric argument */
X	if (f == FALSE) {
X		mlwrite("%Need function key number");
X		return(FALSE);
X	}
X
X	/* and it must be a legal key number */
X	if (n < 1 || n > 8) {
X		mlwrite("%Function key number out of range");
X		return(FALSE);
X	}
X
X	/* get the string to send */
X	status = mlreply("Label contents: ", &lbl[0], 17);
X	if (status != TRUE)
X		return(status);
X
X	/* pad the label out */
X	for (i=0; i < 17; i++) {
X		if (lbl[i] == 0)
X			break;
X	}
X	for (; i < 16; i++)
X		lbl[i] = ' ';
X	lbl[16] = 0;
X
X	/* set up the parameters */
X	cmd[2] = n;			/* function key number */
X	ptru.ptr = &lbl[0];		/* set up pointer to label string */
Xforce:	cmd[4] = ptru.cstr[0];
X	cmd[5] = ptru.cstr[1];
X	cmd[6] = ptru.cstr[2];
X	cmd[7] = ptru.cstr[3];
X
X	/* and send it out */
X	agios(&cmd[0], 12);
X	return(TRUE);
X}
X#endif
X#else
X
Xh15hello()
X
X{
X}
X#endif
END_OF_hp150.c
if test 9129 -ne `wc -c <hp150.c`; then
    echo shar: \"hp150.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"input.c\" \(9854 characters\)
if test -f input.c ; then 
  echo shar: Will not over-write existing file \"input.c\"
else
sed "s/^X//" >input.c <<'END_OF_input.c'
X/*	INPUT:	Various input routines for MicroEMACS 3.7
X		written by Daniel Lawrence
X		5/9/86						*/
X
X#include	<stdio.h>
X#include	"estruct.h"
X#include	"edef.h"
X
X#if	MEGAMAX
Xoverlay "input"
X#endif
X
X/*
X * Ask a yes or no question in the message line. Return either TRUE, FALSE, or
X * ABORT. The ABORT status is returned if the user bumps out of the question
X * with a ^G. Used any time a confirmation is required.
X */
X
Xmlyesno(prompt)
X
Xchar *prompt;
X
X{
X	char c;			/* input character */
X	char buf[NPAT];		/* prompt to user */
X
X	for (;;) {
X		/* build and prompt the user */
X		strcpy(buf, prompt);
X		strcat(buf, " [y/n]? ");
X		mlwrite(buf);
X
X		/* get the responce */
X		c = tgetc();
X
X		if (c == ectoc(abortc))		/* Bail out! */
X			return(ABORT);
X
X		if (c=='y' || c=='Y')
X			return(TRUE);
X
X		if (c=='n' || c=='N')
X			return(FALSE);
X	}
X}
X
X/*
X * Write a prompt into the message line, then read back a response. Keep
X * track of the physical position of the cursor. If we are in a keyboard
X * macro throw the prompt away, and return the remembered response. This
X * lets macros run at full speed. The reply is always terminated by a carriage
X * return. Handle erase, kill, and abort keys.
X */
X
Xmlreply(prompt, buf, nbuf)
X    char *prompt;
X    char *buf;
X{
X	return(nextarg(prompt, buf, nbuf, ctoec('\n')));
X}
X
Xmlreplyt(prompt, buf, nbuf, eolchar)
X
Xchar *prompt;
Xchar *buf;
Xint eolchar;
X
X{
X	return(nextarg(prompt, buf, nbuf, eolchar));
X}
X
X/*	ectoc:	expanded character to character
X		colapse the CTRL and SPEC flags back into an ascii code   */
X
Xectoc(c)
X
Xint c;
X
X{
X	if (c & CTRL)
X		c = c & ~(CTRL | 0x40);
X	if (c & SPEC)
X		c= c & 255;
X	return(c);
X}
X
X/*	ctoec:	character to extended character
X		pull out the CTRL and SPEC prefixes (if possible)	*/
X
Xctoec(c)
X
Xint c;
X
X{
X        if (c>=0x00 && c<=0x1F)
X                c = CTRL | (c+'@');
X        return (c);
X}
X 
X/* get a command name from the command line. Command completion means
X   that pressing a <SPACE> will attempt to complete an unfinished command
X   name if it is unique.
X*/
X
Xint (*getname())()
X
X{
X	register int cpos;	/* current column on screen output */
X	register int c;
X	register char *sp;	/* pointer to string for output */
X	register NBIND *ffp;	/* first ptr to entry in name binding table */
X	register NBIND *cffp;	/* current ptr to entry in name binding table */
X	register NBIND *lffp;	/* last ptr to entry in name binding table */
X	char buf[NSTRING];	/* buffer to hold tentative command name */
X	int (*fncmatch())();
X
X	/* starting at the beginning of the string buffer */
X	cpos = 0;
X
X	/* if we are executing a command line get the next arg and match it */
X	if (clexec) {
X		if (macarg(buf) != TRUE)
X			return(FALSE);
X		return(fncmatch(&buf[0]));
X	}
X
X	/* build a name string from the keyboard */
X	while (TRUE) {
X		c = tgetc();
X
X		/* if we are at the end, just match it */
X		if (c == 0x0d) {
X			buf[cpos] = 0;
X
X			/* and match it off */
X			return(fncmatch(&buf[0]));
X
X		} else if (c == ectoc(abortc)) {	/* Bell, abort */
X			ctrlg(FALSE, 0);
X			TTflush();
X			return( (int (*)()) NULL);
X
X		} else if (c == 0x7F || c == 0x08) {	/* rubout/erase */
X			if (cpos != 0) {
X				TTputc('\b');
X				TTputc(' ');
X				TTputc('\b');
X				--ttcol;
X				--cpos;
X				TTflush();
X			}
X
X		} else if (c == 0x15) {	/* C-U, kill */
X			while (cpos != 0) {
X				TTputc('\b');
X				TTputc(' ');
X				TTputc('\b');
X				--cpos;
X				--ttcol;
X			}
X
X			TTflush();
X
X		} else if (c == ' ') {
X/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
X	/* attempt a completion */
X	buf[cpos] = 0;		/* terminate it for us */
X	ffp = &names[0];	/* scan for matches */
X	while (ffp->n_func != NULL) {
X		if (strncmp(buf, ffp->n_name, strlen(buf)) == 0) {
X			/* a possible match! More than one? */
X			if ((ffp + 1)->n_func == NULL ||
X			   (strncmp(buf, (ffp+1)->n_name, strlen(buf)) != 0)) {
X				/* no...we match, print it */
X				sp = ffp->n_name + cpos;
X				while (*sp)
X					TTputc(*sp++);
X				TTflush();
X				return(ffp->n_func);
X			} else {
X/* << << << << << << << << << << << << << << << << << */
X	/* try for a partial match against the list */
X
X	/* first scan down until we no longer match the current input */
X	lffp = (ffp + 1);
X	while ((lffp+1)->n_func != NULL) {
X		if (strncmp(buf, (lffp+1)->n_name, strlen(buf)) != 0)
X			break;
X		++lffp;
X	}
X
X	/* and now, attempt to partial complete the string, char at a time */
X	while (TRUE) {
X		/* add the next char in */
X		buf[cpos] = ffp->n_name[cpos];
X
X		/* scan through the candidates */
X		cffp = ffp + 1;
X		while (cffp <= lffp) {
X			if (cffp->n_name[cpos] != buf[cpos])
X				goto onward;
X			++cffp;
X		}
X
X		/* add the character */
X		TTputc(buf[cpos++]);
X	}
X/* << << << << << << << << << << << << << << << << << */
X			}
X		}
X		++ffp;
X	}
X
X	/* no match.....beep and onward */
X	TTbeep();
Xonward:;
X	TTflush();
X/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
X		} else {
X			if (cpos < NSTRING-1 && c > ' ') {
X				buf[cpos++] = c;
X				TTputc(c);
X			}
X
X			++ttcol;
X			TTflush();
X		}
X	}
X}
X
X/*	tgetc:	Get a key from the terminal driver, resolve any keyboard
X		macro action					*/
X
Xint tgetc()
X
X{
X	int c;	/* fetched character */
X
X	/* if we are playing a keyboard macro back, */
X	if (kbdmode == PLAY) {
X
X		/* if there is some left... */
X		if (kbdptr < kbdend)
X			return((int)*kbdptr++);
X
X		/* at the end of last repitition? */
X		if (--kbdrep < 1) {
X			kbdmode = STOP;
X#if	VISMAC == 0
X			/* force a screen update after all is done */
X			update(FALSE);
X#endif
X		} else {
X
X			/* reset the macro to the begining for the next rep */
X			kbdptr = &kbdm[0];
X			return((int)*kbdptr++);
X		}
X	}
X
X	/* fetch a character from the terminal driver */
X	c = TTgetc();
X
X	/* save it if we need to */
X	if (kbdmode == RECORD) {
X		*kbdptr++ = c;
X		kbdend = kbdptr;
X
X		/* don't overrun the buffer */
X		if (kbdptr == &kbdm[NKBDM - 1]) {
X			kbdmode = STOP;
X			TTbeep();
X		}
X	}
X
X	/* and finally give the char back */
X	return(c);
X}
X
X/*	GET1KEY:	Get one keystroke. The only prefixs legal here
X			are the SPEC and CTRL prefixes.
X								*/
X
Xget1key()
X
X{
X	int    c;
X#if	AMIGA
X	int	d;
X#endif
X
X	/* get a keystroke */
X        c = tgetc();
X
X#if	MSDOS
X	if (c == 0) {				/* Apply SPEC prefix	*/
X	        c = tgetc();
X	        if (c>=0x00 && c<=0x1F)		/* control key? */
X        	        c = CTRL | (c+'@');
X		return(SPEC | c);
X	}
X#endif
X
X#if	AMIGA
X	/* apply SPEC prefix */
X	if ((unsigned)c == 155) {
X		c = tgetc();
X
X		/* first try to see if it is a cursor key */
X		if ((c >= 'A' && c <= 'D') || c == 'S' || c == 'T')
X			return(SPEC | c);
X
X		/* next, a 2 char sequence */
X		d = tgetc();
X		if (d == '~')
X			return(SPEC | c);
X
X		/* decode a 3 char sequence */
X		c = d + 32;
X		/* if a shifted function key, eat the tilde */
X		if (d >= '0' && d <= '9')
X			d = tgetc();
X		return(SPEC | c);
X	}
X#endif
X
X#if  WANGPC
X	if (c == 0x1F) {			/* Apply SPEC prefix    */
X	        c = tgetc();
X		return(SPEC | c);
X	}
X#endif
X
X        if (c>=0x00 && c<=0x1F)                 /* C0 control -> C-     */
X                c = CTRL | (c+'@');
X        return (c);
X}
X
X/*	GETCMD:	Get a command from the keyboard. Process all applicable
X		prefix keys
X							*/
Xgetcmd()
X
X{
X	int c;		/* fetched keystroke */
X
X	/* get initial character */
X	c = get1key();
X
X	/* process META prefix */
X	if (c == metac) {
X		c = get1key();
X	        if (islower(c))		/* Force to upper */
X        	        c ^= DIFCASE;
X	        if (c>=0x00 && c<=0x1F)		/* control key */
X	        	c = CTRL | (c+'@');
X		return(META | c);
X	}
X
X	/* process CTLX prefix */
X	if (c == ctlxc) {
X		c = get1key();
X	        if (c>='a' && c<='z')		/* Force to upper */
X        	        c -= 0x20;
X	        if (c>=0x00 && c<=0x1F)		/* control key */
X	        	c = CTRL | (c+'@');
X		return(CTLX | c);
X	}
X
X	/* otherwise, just return it */
X	return(c);
X}
X
X/*	A more generalized prompt/reply function allowing the caller
X	to specify the proper terminator. If the terminator is not
X	a return ('\n') it will echo as "<NL>"
X							*/
Xgetstring(prompt, buf, nbuf, eolchar)
X
Xchar *prompt;
Xchar *buf;
Xint eolchar;
X
X{
X	register int cpos;	/* current character position in string */
X	register int c;
X	register int quotef;	/* are we quoting the next char? */
X
X	cpos = 0;
X	quotef = FALSE;
X
X	/* prompt the user for the input string */
X	mlwrite(prompt);
X
X	for (;;) {
X		/* get a character from the user */
X		c = get1key();
X
X		/* If it is a <ret>, change it to a <NL> */
X		if (c == (CTRL | 0x4d))
X			c = CTRL | 0x40 | '\n';
X
X		/* if they hit the line terminate, wrap it up */
X		if (c == eolchar && quotef == FALSE) {
X			buf[cpos++] = 0;
X
X			/* clear the message line */
X			mlwrite("");
X			TTflush();
X
X			/* if we default the buffer, return FALSE */
X			if (buf[0] == 0)
X				return(FALSE);
X
X			return(TRUE);
X		}
X
X		/* change from command form back to character form */
X		c = ectoc(c);
X
X		if (c == ectoc(abortc) && quotef == FALSE) {
X			/* Abort the input? */
X			ctrlg(FALSE, 0);
X			TTflush();
X			return(ABORT);
X		} else if ((c==0x7F || c==0x08) && quotef==FALSE) {
X			/* rubout/erase */
X			if (cpos != 0) {
X				outstring("\b \b");
X				--ttcol;
X
X				if (buf[--cpos] < 0x20) {
X					outstring("\b \b");
X					--ttcol;
X				}
X
X				if (buf[cpos] == '\n') {
X					outstring("\b\b  \b\b");
X					ttcol -= 2;
X				}
X				TTflush();
X			}
X
X		} else if (c == 0x15 && quotef == FALSE) {
X			/* C-U, kill */
X			while (cpos != 0) {
X				outstring("\b \b");
X				--ttcol;
X
X				if (buf[--cpos] < 0x20) {
X					outstring("\b \b");
X					--ttcol;
X				}
X			}
X			TTflush();
X
X		} else if (c == quotec && quotef == FALSE) {
X			quotef = TRUE;
X		} else {
X			quotef = FALSE;
X			if (cpos < nbuf-1) {
X				buf[cpos++] = c;
X
X				if ((c < ' ') && (c != '\n')) {
X					outstring("^");
X					++ttcol;
X					c ^= 0x40;
X				}
X
X				if (c != '\n')
X					TTputc(c);
X				else {	/* put out <NL> for <ret> */
X					outstring("<NL>");
X					ttcol += 3;
X				}
X				++ttcol;
X				TTflush();
X			}
X		}
X	}
X}
X
Xoutstring(s)	/* output a string of characters */
X
Xchar *s;	/* string to output */
X
X{
X	while (*s)
X		TTputc(*s++);
X}
END_OF_input.c
if test 9854 -ne `wc -c <input.c`; then
    echo shar: \"input.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"menu1\" \(7926 characters\)
if test -f menu1 ; then 
  echo shar: Will not over-write existing file \"menu1\"
else
sed "s/^X//" >menu1 <<'END_OF_menu1'
X--<<01>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 WORD CASE/SCREEN CONTROL   F2  PAGING/SCROLLING
X[Main Menu]         F3 CUT & PASTE                F4  SEARCH AND REPLACE
X                    F5 DELETION COMMANDS          F6  WORD PROCESSING
X                    F7 INSERTION COMMANDS         F8  EDITOR CONTROL
X 06/18/86           F9 CURSOR MOVEMENT            F10 exit MicroEMACS
X--<<02>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 BUFFER CONTROL             F2  MACROS
X[Editor control]    F3 COLOR CHANGES              F4  MODES
X                    F5 DOS COMMANDS               F6  SCRIPTS
X                    F7 FILE ACCESS                F8  WINDOWS
X                    F9 KEY BINDINGS               F10 exit to MAIN MENU
X--<<03>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 upper case a word          F2  upper case a region
X Word case &        F3 lower case a word          F4  lower case a region
X  Screen control    F5 capitilize a word
X                    F7 redraw the screen          F8  mark a region
X                    F9 center the current line    F10 exit to MAIN MENU
X--<<04>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1  mark a region
X  Cut & Paste       F3  delete the region
X                    F5  copy the region to the kill buffer
X                    F7  insert the kill buffer into the text here
X                                                  F10 exit to MAIN MENU
X--<<05>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 delete the last character
X  Deletions         F3 delete the next character
X                    F5 delete to the end of the current line
X                    F7 delete all the blank lines around the cursor
X                                                  F10 exit to MAIN MENU
X--<<06>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 open a blank line          F2  insert a prompted string
X  Insertion         F3 insert a tab               F4  quote the next character
X                    F5 insert a space             F6  transpose last 2 chars
X                    F7 insert a newline and indent like the last line
X                    F9 insert a newline           F10 exit to MAIN MENU
X--<<07>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 begining of the file       F2  up one line
X  Cursor Movement   F3 left                       F4  right
X        F^2         F5 end of the file            F6  down one line
X    F3 < + > F4     F7 begining of line           F8  end of line
X        FV6         F9 goto line                  F10 exit to MAIN MENU
X--<<08>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1  go up one page            F2  go down one page
X  Paging and        F3  scroll the screen up      F4  scroll the screen down
X     Scrolling      F5  make the next widow go up one page
X                    F7  make the next window go down one page
X                    F9  exchange cursor & mark    F10 exit to MAIN MENU
X--<<09>>-----------------------------------------------------------------------
XMicroEMACS 3.7      f1  search forward            f2  seach backwards
X  Search and        F3  hunt forward              f4  hunt backwards
X    Replace         F5  isearch forward           F6  isearch backward
X                    F7  replace string            F8  replace string w/query
X                                                  F10 exit to MAIN MENU
X--<<10>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 go back a word             F2  go forward a word
X  Word processing   F3 go back a paragraph        F4  go forward a paragraph
X                    F5 fill paragraph             F6  delete current paragraph
X                    F7 delete last word           F8  delete next word
X                    F9 count words in region      F10 exit to MAIN MENU
X--<<11>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 report position            F2  unmark buffer
X  Buffer Control    F3 delete buffer              F4  switch to next buffer
X                    F5 list all buffers           F6  filter buffer through
X                    F7 rename current buffer             DOS program
X                    F9 select buffer              F10 exit to CONTROL MENU
X--<<12>>-----------------------------------------------------------------------
XMicroEMACS 3.7      Colors:           |  F1 current window's forground color
X  Color changes       Black   Magenta |  F3 current window's background color
X                      Blue    Cyan    |  F5 global forground color
X                      Red     Yellow  |  F7 global background color
X                      Green   White   |           F10  exit to CONTROL MENU
X--<<13>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1  execute one DOS command
X  DOS commands      F3  pipe one DOS command to a buffer
X                    F5  shell up to a new command interpeter
X                    F7  QUICK exit (write out all changed buffers and exit)
X                    F9  exit MicroEMACS           F10 exit to CONTROL MENU
X--<<14>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 find file                  F2 save current file
X  File Access       F3 view file (in VIEW mode)   F4 write file w/ new name
X                    F5 read file into buffer      F6 change current file name
X                    F7 insert file into buffer
X                                                  F10  exit to CONTROL MENU
X--<<15>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 bind a function to a key
X  Key Bindings      F3 unbind a key
X                    F5 describe a key
X                    F7 describe all bindings
X                                                  F10  exit to CONTROL MENU
X--<<16>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 define macro         The keyboard macro only works
X  Keyboard Macro    F3 end macro            for standard commands, NOT for
X                    F5 execute macro        menu selections.
X
X                                                  F10  exit to CONTROL MENU
X--<<17>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 set mode                   F2  set global mode
X  Modes             F3 delete mode                F4  delete global mode
X            Standard modes are:                   F6  set fill column
X                WRAP  VIEW  CMODE  EXACT OVER MAGIC
X                                                  F10 exit to CONTROL MENU
X--<<18>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 execute script file        F2  execute script line
X  Script            F3 execute script in buffer   F4  execute command (by name)
X            Script line format:
X         {<repeat count>} <command name> {<argument(s)> | "<argument(s)>"}
X                                                  F10  exit to CONTROL MENU
X--<<19>>-----------------------------------------------------------------------
XMicroEMACS 3.7      F1 split current window       F2  delete all other windows
X  Windows           F3 resize window              F4  delete current window
X                    F5 shrink window              F6  enlarge window
X                    F7 next window                F8  previous window
X                                                  F10 exit to CONTROL MENU
X-------------------------------------------------------------------------------
END_OF_menu1
if test 7926 -ne `wc -c <menu1`; then
    echo shar: \"menu1\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 3 \(of 14\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    echo "See the readme file"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
