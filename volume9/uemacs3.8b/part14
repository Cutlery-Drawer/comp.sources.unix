Subject:  v09i046:  MicroEMACS, version 3.8b, Part14/14
Newsgroups: mod.sources
Approved: rs@mirror.TMC.COM

Submitted by: ihnp4!itivax!duncan!lawrence (Daniel Lawrence)
Mod.sources: Volume 9, Issue 46
Archive-name: uemacs3.8b/Part14

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If this archive is complete, you will see the message:
#		"End of archive 14 (of 14)."
# Contents:  emacs1.mss
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"emacs1.mss\" \(49811 characters\)
if test -f emacs1.mss ; then 
  echo shar: Will not over-write existing file \"emacs1.mss\"
else
sed "s/^X//" >emacs1.mss <<'END_OF_emacs1.mss'
X@chapter(INTRODUCTON)
X 
X     MicroEMACS, henceforth called EMACS, is a full screen editor (not a
Xword processor) which is available on a variety of computers (both micro
Xand mini/main frame).  As a general characteristic, EMACS is a function
Xdriven program wherein every keystroke is a "function" call; hence,
Xthere is no notion of input versus edit modes.  Thus, for example, the
Xkeystroke 'a' invokes the function "insert-character 'a'".  All visible
XASCII (8-bit) characters are self-inserting while the non-visible
X(control) characters are used as commands. 
X 
XThere is a tutorial file called emacs.tut on the distribution disk. 
XIt might be useful if you read this documentation after going through
Xthe tutorial.  To do this, type @b<emacs emacs.tut> when you get the DOS prompt.
XThis will start emacs, instructing it to read in the file emacs.tut
Xfrom the default disk into a standard buffer and put you into it.  You
Xcan then follow the instructions in it.  @i<In case of trouble, you
Xcan always abort a command with CTRL-G or abort emacs with CTRL-X CTRL-C.>
X
X     The command structure of EMACS is simple: commands are
Xsingle keystroke, double keystroke, or full command-spec. For
Xefficiency, single keystroke commands are the most used, followed
Xby 2-keystroke, and so on.
X 
X    Every command (where it makes sense) in EMACS allows for a numeric
Xargument in pre-fix notation.  Since decimal digits are also
Xself-inserting, arguments are passed to the command (including
Xself-insert commands) through two mechanisms.  First, an arbitrary
Xnumeric argument can be passed by ESC <number> where <number> is a
Xstandard decimal number and ESC is the ESCape character (control-[ or
Xthe ESC on your keyboard).  Thus, the sequence "esc 7 a" results in
Xaaaaaaaa.  Second, numeric arguments of powers of 4 can be passed by
Xprefixing a command with control-U's.  Each control-U increases the
Xpower by 1.  Hence control-U means 4, control-Ucontrol-U means 16,
Xcontrol-Ucontrol-Ucontrol-U means 64 and so on.  Thus,
X"control-Ucontrol-Ua" yields:aaaaaaaaaaaaaaaa.  If an explicit numeric
Xargument is not given, EMACS uses 1.  Note also that negative numeric
Xarguments can also be given and EMACS tries to behave intelligently
Xabout them. 
X 
X     The structure of this document is functional: i.e., each
Xsection is devoted to a set of common activities such as moving
Xaround, deleting, copying etc.
X@chapter(PRELIMINARIES)
X@section(REGION or POINT and MARK)
X
X     A region is a block of text to be acted upon by some EMACS
Xcommands.  It is demarcated by the POINT on one end and the MARK at
Xthe other.  The point is the primary location identifier where most
Xof the action takes place and is always @i(between) two characters. 
XThe point is indicated by the cursor position in that it is just
Xbehind the cursor.  The point is also significant in that it defines
Xone end of the region.  The mark, on the other hand, is invisible,
Xand is used to demarcate the other end of the region( see section
X@ref(regmov) or, to peek ahead, one denotes the mark by escape .). 
X 
X@section(BUFFERS)
X 
X     Buffers are regions of memory which are the primary units internal
Xto EMACS and where EMACS does its work. Thus, a file being edited
Xis located in a buffer. One can have multiple buffers, each with
Xa unique name, each of which can contain a file to be worked
Xupon.  The KILL buffer is a very special buffer that is always around
Xand which holds large pieces of deleted text.  While you cannot
Xdirectly work with the buffer, you use it indirectly in copying/moving
Xtext segments.
X
X@section(MODE)
X 
X     An EMACS mode specifies the general fashion in which EMACS
Xdeals with user input.  For example, how should EMACS deal with long
Xlines (> 79 characters)? The mode is associated with the buffer and
Xnot the file.  Hence, the mode has to be explicitly set (or removed)
Xeach time the file is to be edited.  However, since the mode is
Xassociated with the buffer, a new file read into the buffer will be
Xedited with the previously specified mode.  Also, standard (default)
Xmodes can be set for all buffers when EMACS is first started.  (See
X@ref(modes) for more information of modes.)
X 
X@section(WINDOWS)
X 
X     Windows are the visible portions of buffers. EMACS allows as
Xmany windows on the screen as can fit. Since windows are screen
Xobjects, the relationship of windows to buffers can be
Xmany-to-one. That is, one can have many windows per buffer or a
Xeach window could be into a different buffer.
X 
X@section(SCREEN)
X 
X     The screen is usually the 24 row by 80 column section of the
Xphysical screen that is available to EMACS.  The format is as
Xfollows.  The 24th row (the bottom line) is generally clear.  It is
Xused for EMACS prompts, user responses, and EMACS messages.  The
Xremainder of the screen (23 rows) is left for text display.  For
Xeach window that is open on the screen, the bottom line is used to
Xprovide information to the user.  Starting with the program's name
Xand version number, it contains the buffer mode(s) in parenthesis,
Xthe buffer name and, finally, the file name associated with theref
Xbuffer if there is one so associated. 
X 
X@section(OBJECTS)
X 
X     Objects are the entities upon which commands will operate. The most
Xcommon object is the character. Other objects are: words, lines, sentences,
Xparagraphs, screens, regions, and files.
X 
X@section(NOTATION)
X 
X      Standard visible characters are shown normally.  Control charactes
X(the so-called non-printing characters) are shown prefixed by a @b(^)
Xe.g., control-A as ^A.  NOTE: in 8-bit ASCII there are 32 non-printing
Xcharacters: @center<^@ ^A..^Z ^[ ^\ ^] ^^ ^_>
X
X	Control characters are case independent; i.e., ^A is the same as
X^a.  Further, the escape key which, technically, is ^[ is denoted by
XESC; most keyboards have a special key marked ESC.  In two-keystroke
Xcommands, the intervening blank space shown is for clarity and should
Xnot be typed.  Parameters to be supplied by you are indicated as
X[parameter-type].  Finally, special keys are denoted by <key-name>. 
X 
X@section(GETTING STARTED)
X
X	To start using EMACS, just type @b(EMACS [filename]) (where
X[filename] is the name of the file you wish to edit) from your operating
Xsystem's command prompt.  This will bring up EMACS and read in the file
Xyou wish to edit.  (@i[If you are using EMACS for the first time one
Xyour machine, read @ref<install> to learn how to install EMACS on your
Xmachine]).
X
X@chapter(INSERTING TEXT)
X 
X    All standard "printable" ASCII characters are self-inserting.  This
Xmeans for those of you who have "extended" characters (ASCII 128-255)
Xyou can type these in just as you any other character.  For example, on
Xthe IBM-PC, keeping the <Alt> key pressed down while typing in another
Xkey sequence will give you the "extended" character.  With the following
Xexceptions, all other non-printing characters are commands:
X 
X@begin(description)
X^I (or <TAB>)@/Handle-Tab: inserts the tab character or  spaces
Xto move the currently set tab distance (see @ref(tabset)).  When you first
Xstart EMACS, this character inserts itself and while you "see" spaces,
Xthere is just one character there.  However, if you use the set-tab
Xdistance command (by ESC [number] ^I) then the required tab distance is
Xobtained by inserting the requisite number of spaces and @i(now) the
Xspaces that you see are indeed spaces.
X
X^M (or <RETURN>)@/Insert-Newline.  insert a new-line
Xat point.  Note that this is a	
Xcharacter like any other and can be deleted or inserted at any place.  However
Xit looks different because it acts like the carriage-return line
Xfeed pair.
X
X^J (or <LINEFEED>)@/NewLine-Indent: like above but indent to previous
Xline's indentation
XHence, a ^J actually inserts a new-line and as many spaces as
Xrequired to move under the first character on the previous line.
X
X^O (oh)@/Open-Line: insert an open line at cursor for entering text.
XThis is a
Xvery useful command when you are going to be inserting more than a few
Xcharacters in between existing characters.  By using ^O you will not
Xbe forcing EMACS to shift other text around as you type and things
Xwill both go faster and look cleaner on the screen.  If you are going
Xto insert a lot of new text, use a numeric argument to get a lot of
Xblank lines after point.  You can use ^X ^O to clean up the
Xbuffer after you finish adding your text (see @ref(deblank)).
X
X^Q@/Quote-Next-Character.  If you wish certain control characters (non-printing) to
Xappear in your text, you can do so by "quoting" them with a ^Q. Hence
Xthe sequence:  ^Q [char] will insert the [char] into the text.
X
X^C@/Insert-Space.  This command inserts a space after point. 
XWhile not particularly useful in general (since the space-bar "key" does
Xthe same thing and more easily) it is very useful when you are in "insert
Xmode (see @ref(insertmode)).
X@end(description) 
X@chapter(MOVING AROUND)
X 
X     In this chapter, we cover ways of moving around in a variety
Xof contexts: the screen, region, and file.
X 
X@section(SCREEN)
X 
X     Movement commands work on pieces of text called objects.  Three objects
Xare involved in moving around the screen: character, word and paragraph.
X@subsection(Character Moving)
X@begin(description) 
X^F@/Forward-Charcter.  The point moves forward by one character 
Xhence the cursor also moves since the cursor is just after point.  Again
Xnote that since the new-line character is a character, you can "move"
Xover it just as you would any other character.  On the screen this
Xappears as a jump to the beginning of the next line.
X
X^B@/Backward-Character.  Just like Forward-Character but in the reverse
Xdirection.
X@end(description)@subsection(Line Moving)@begin(description)
X^P@/Previous-Line.  The point moves to the same column in the
Xprevious line if that is possible.  If there is no text for it to move to
Xit moves to the end of the line.  However, it "remembers" the column
Xit was in and moves to it when you return to the starting line.  If
Xthe point is on the top line of the screen, the screen scrolls
Xbackward so that the previous line of the text is centered on the new screen.
X
X^N@/Next-Line.  Like ^P but point moves to the next line.
X
X^E@/End-Of-Line.   The point moves after the last character
Xon the line and stays between it and the <new-line> character.  Hence
Xanother ^F (Forward-Character) would put you past the new-line, i.e.,
Xat the beginning of the next line.
X
X^A@/Start-Of-Line.  The point moves to the
Xbeginning of the line and is between the first character on the line
Xand the new-line character of the previous line.  A ^B (or
XBackward-Character), then, would put you at the end of the previous line.
X
XESC G@/To-Numbered-Line.  The cursor moves to the line
Xspecifed by the numeric argument.  If none is given, EMACS, as usual,
Xwould assume 1 and move you to the top of the buffer.
XUse ESC <number> to denote the target line where
Xthe first line is 1.  Hence, for example, if you wished to go to
Xthe 83 line you would type ESC 83 ESC G.
X@end(description)
X@section(Word Moving)
X@begin(description) 
XESC F@/Forward-Word.  The point is moved from its current location to the
Xbeginning of the next word.
XA word is defined to be contiguous characters separated by spaces or
Xpunctuation marks.  Hence if the point is currently in middle of two words
X(i.e., @i[in front of the space or the punctuation]) it is moved to the
Xbeginning of the next word.
X
XESC B@/Backward-Word.  Like forward word but in the reverse direction.
X@end(description)@section(Paragraph Moving)@begin(description)
XESC N@/Forward-Paragraph.  Move to the beginning of the next paragraph.
X
X	NOTE: A paragraph is defined as a section of text separated
Xfrom other text by 1) blank lines, 2) a line starting with
Xblanks, or 3) a line starting with a tab character (^I).@tag(paradef)
X
XESC N@/Backward-Paragraph.  Like forward-paragraph but in the reverse
Xdirection.
X@end(description)@section(Region Moving)@TAG(regmov)
X@begin(description)
X^X ^X@/Exchange-Point-And-Mark.  There is only one region available at
Xa time. Hence, moving
Xby regions is restricted to moving from one end of the region
Xto the other.  To reiterate, the region is defined by the point
X(behind the cursor) at one end and the mark (set by ESC . or ESC space)
Xat the other. Recall that @i<this> end of the region is where the cursor is.
XHence exchanging point and mark effectively moves you from one end of
Xthe region to the other.
X@end(description)@section<Screen Moving>@begin(description)
X^V or <NEXT>@/Next-Screen.  The screen is scrolled up so that the
Xnext set of lines can be shown in the window.  EMACS retains an
Xoverlap of two lines for continuity -- i.e., you do not get a new
Xscreen starting with the first previously invisible line but rather
Xthe new screen will start with two lines from the bottom of the
Xprevious screen. The point is left at the home position (top left hand corner).
X
XESC V or CTRL Z or <PREV>@/Previous-Screen.  Like above except that the previous
Xset of screen lines is displayed.
X@end(description)
X@section(Window Moving)
X@begin(description)
X
X^X O (oh)@/Next-Window.  Moves point to the
Xthe next window on the screen.  EMACS cycles through windows.  Thus, if you
Xare in the bottom window, you are moved to the top window.
X
X^X P@/Previous-Window.  Like above but in the opposite direction.
X@end(description)
X
XFor addtional information on windows, see @ref(windows).
X@section(Buffer Moving)@begin(description)
X
XESC < or <HOME>@/Top-Of-Buffer.  Moves point to the very beginning of
Xthe buffer.
X
XESC >or <shift-HOME>@/Bottom-Of-Buffer.  Moves point to the very end of the buffer.
X
XESC B@/To-Named-Buffer.  You will be prompted for a buffer name (see
X@ref(buflist) on how to find out about your buffers) and will be
Xswitched to it.  If the buffer does not exits, EMACS will create one
Xand put you into it.
X
X^X X@/Next-Buffer.  You will be put into the next buffer
Xin the buffer list.  Like with windows, EMACS cycles through the
Xbuffer list and hence if you are in the last buffer, you will be put
Xinto the first one.
X@end(description)
X
XFor additional information on buffers, see @ref(buffers).
X
X@section(File Moving)
XA file is a named collection of text and is associated with a buffer
Xin EMACS.  EMACS allows full filenames; hence the full path can be specifed.
XIn all cases of moving between files, you will be prompted for a filename
XType it in and hit <return>.
X@begin(description)
X
X^X ^R@/Read-File.  The file, if found, is read into the
Xcurrent buffer overwriting any text already in it. If the buffer has
Xbeen changed and you have not saved your changes, you will be asked to
Xconfirm the overwrite.  If the file is not found where specified, it
Xis assumed that you wish to create a new file with that name and your
Xcurrent buffer is merely emptied.
X
X^X ^F@/Find-File.  EMACS attempts first to find the
Xspecified file within one of the existing buffers.  If it finds the file
Xit merely switches you to that buffer.  If it does not, it will
Xcreate a new buffer, read the specified file if found into it, and
Xswitch you to the new buffer.  If the file is not found, a new buffer
Xis created and you will be put into it.
X
X^X ^V@/View-File.  Like find-a-file above except that the
XVIEW mode is automatically added to the buffer.  In this mode you are
Xonly allowed to move around the buffer and cannot make any changes.
X@end(description)
X 
X@chapter(DELETING)
XLike moving around, deleting is an action that can work with a variety
Xof objects:  characters, words, lines, paragraphs, regions, windows, and
Xbuffers.  It is worth reiterating that the object is defined relative
Xto the point and not the object as a whole.  Hence, if you are in the
Xmiddle of a word and issue a delete-forward-word command, the text
Xdeleted is actually from the point to the end of the word.
X@section(Character)@begin(description)
XCTRL-D@/Delete-Forward-Character.  Since the point is always just before
Xthe cursor, the character under the cursor is deleted.  When you are
Xat the end of a line, the point is just before the <newline>
Xcharacter and, therefore, a Delete-Forward-Character "eats" up the <newline> --
Xin effect this joins the next line to the current one.
X
XCTRL-H  or <BACKSPACE>@/Delete-Backward-Character.  This deletes the
Xcharacter before point.  At the beginning of a line, it deletes the
Xprevious <newline> character and hence joins the current line to the
Xprevious one.
X@end(description)@section(Word)@begin(description)
XESC D@/Delete-Forward-Word.  Deletes the text from the point to the
X@i<beginning> of the next word.  Hence, any punctuation separating the
Xwords is also deleted.
X
XESC <backspace> or ESC CTRL-H@/Delete-Backward-Word.  Like above but
Xin the reversse direction.
X@end(description)@section(Line)@begin(description)
XCTRL-K@/Delete-To-End-Of-Line (Kill line).  All characters from point to the end
Xof the line are deleted.  @i[The <new-line> character is NOT deleted.]
X
X	To delete a line completely from the buffer you would have to do the
Xfollowing: CTRL-A (Start-Of-Line) CTRL-K (Delete-To-End-Of-Line) CTRL-D
X(Delete-Forward-Character to delete the <newline> character).
X
X@tag(delete)
XAs with all major deletes (i.e., when more than a few characters are deleted
XEMACS places the deleted text in a KILLS buffer.  Hence, the deletion
Xcan be undone by "yanking" the text back at point (using CTRL-Y).
X
XCTRL-X CTRL-O (oh)@/Delete-Blank-Lines.  This command deletes all blank
X@i<lines> around the current line.  If there is only blank line after the
Xcurrent line it is @i<not> deleted.  However, if there are more than 1
Xblank lines after the current line, @i<all> of them are deleted.@tag(deblank)
X@end(description)@section(Region)
XThe region is an arbitrary area of the buffer demarcated by the point 
X(just before the cursor!) and the mark. The mark is invisible and is
Xset using ESC . or ESC <space>.  To see the other end of the region,
Xuse the Exchange-Point-And-Mark (CTRL-X XTRL-X) command.  Since the
Xregion has no direction associated with it, this effectively shows you
Xthe mark and all region commands work correctly.  Furthermore, since
Xthe region is completely arbitrary in size you could demarcate any
Xsized object from a single character all the way to the entire buffer.
X@description<
XCTRL-W@/Delete-Region (kill World!).  Deletes the region (between
Xpoint and mark) and places the killed text in the KILLS buffer to be "yanked"
Xback (with CTRL-Y) at the point.  Hence if you ever accidentally type CTRL-W
Xsimply undo it with an immediate CTRL-Y (strictly speaking this does
Xnot have to be done immediately since the KILLS buffer is overwritten
Xonly with the next big delete).>
X@section<Windows>@description<
XCTRL-X 1 (one)@/Close-All-Other-Windows.  This will close all windows on the
Xscreen except for the one you are in (issued the command from).>
X@section(Buffers)@description<
XCTRL-X K@/Delete-Buffer.  You will be prompted for the name of a buffer
XIf the buffer has been changed, you will be asked to confirm the
Xdeletion since killing the buffer would eliminated your changes.  To
Xfind out which buffers you have, use the CTRL-X CTRL-B command (see
X@tag<buflist>).  As always CTRL-G aborts the pending command -- which
Xmeans @i(before) you hit return after typing in the buffer name.>
X
X@section<Files>
X 
X     Files within EMACS are dealt with by dealing with the
Xassociated buffers. If you really want to deal with the
Xdisk based versions of files, escape to MSDOS, manage your files
Xand return to EMACS (see @ref(msdos) for a discussion on using MSDOS from
Xwithin EMACS).
X
X@chapter(MOVING/COPYING TEXT)
X 
X 
X     Transposing single characters is easy in EMACS.  CTRL-T does it. 
XLarger entities are dealt with via the KILLS buffer (see
X@ref(delete)).  Moving or copying text in EMACS is fundamentally
Xidentical.  The general procedure is as follows:
X@begin(enumerate) 
X
XIf pre-defined areas of text are the desired areas to move or copy use
Xthe appropriate delete command (delete-line,  delete para etc.) to get
Xa copy of the area into the KILLS buffer.  An immediate "yank" (CTRL-Y)
Xresults in an unchanged buffer.
X
XIf arbitrary areas of text are desired, the region is used.
XDemarcate the region to be moved/copied (to repeat:
Xat one end of the region use the set-mark command (with ESC .
Xor ESC <space>) and move the cursor to the other end.  Delete (CTRL-W for
Xmove) or copy (ESC W) the region into the KILLS buffer.
X 
XOnce the desired text is in the KILLS buffer, it can be inserted into
X@i(any) buffer by moving the point into the desired buffer at the desired
Xlocation and "yanking" (CTRL-Y) the text from the KILLS buffer.
X@end(enumerate)@begin(description)
XCTRL-W@/Kill-Region.  Delete text between point and mark and copy it
Xinto the KILLS buffer.
X
XESC W@/Copy-Region.  Copy text between point and mark into the KILLS buffer.
X
XCTRL-Y@/Yank-Text.  Insert a copy of the KILLS buffer into current
Xbuffer at point.  @i<If you accidently typed CTRL-W (the kill region command),
Ximmediately recover by typing in CTRL-Y (the yank text command).>
X@end(description)
X
XSince the KILLS buffer is an independent buffer, you can move text
Xbetween @i<files> by moving text between @i<buffers>.  Further, "yanking"
Xis a read-only operation; hence the text can be inserted as many
Xtimes as desired with repeated yanks.  However,  the KILLS buffer gets
Xoverwritten with each major delete (i.e., deletion of more than a few
Xcharacters at a time).  Consequently you cannot (as yet) accumulate
Xtext in the KILLS buffer with a sequence of kills.  If you need to
Xaccumulate text use a regular buffer (one that you ask for, see @ref(buffers))
Xto hold copies of the deleted (or copied) text.  If you are doing a
Xlot of accumulation, you might want to use a keyboard macro (see
X@ref(kbdmacro)).
X@chapter(SEARCH/REPLACE)
X 
XSearching and replacing occurs from the current cursor
Xposition towards the end of the buffers. 
XWhen either (forward or backward) search type is asked for, you will be
Xprompted for the search string on the prompt line. Type in the string
X(including carraige returns, control characters etc.) and finish
Xby hitting the ESC key which marks the end of the string.
XUnfortunately, this means that ESC itself cannot be part of the
Xstring.  The seach behaviour of EMACS depends upon the setting of the
Xexact mode of the buffer (see @ref(buffers) for details on modes).  If
Xexact mode is on, then the search is done on a case sensitive basis. 
XOtherwise, the case of the target is ignored.  Note that the default
Xfor every buffer is for the exact mode to be off (unless the global
Xmode is set to have exact on for each buffer, see @ref(globalmode). 
XObviously, no such constraint exists for the replacement string since
Xthe replacement is @i<always> exact.
XEMACS remembers the search and replace strings and
Xalways shows you the current stored string when it prompts you for a
Xstring .  This string is used if you respond to the prompt with a null
Xstring (i.e., if you simply hit ESC when prompted).
X
XThere are two ways to replace strings in EMACS: unconditional or query
Xreplace.  In the first, EMACS moves from point to the end of the buffer
Xreplacing @i<every> occurrence of the search string with the
Xreplacement string without pause.  In the second, EMACS pauses at
Xevery search string found and prompts you for an action command which
Xallows you to control exactly which occurrences of the search string
Xwill be replaced.  Because of the lack of control over the regular
Xreplace, it is strongly recommended that you be very sure of your
Xchanges before you use it.  In general, the query replace command
Xshould be used.  Procedurally, replacing strings with other strings
X(including the null string) is done as follows: first you are prompted
Xfor the search string and then for the replacement string.  EMACS then
Xmoves from the current position to the end of the buffer replacing (or
Xquerying) as it goes along.  Note that there is no control over the
Xdirection of the replacement -- EMACS always moves foward.  Hence, to
Xwork on the entire buffer, you need first to move to the top of the
Xbuffer and issue the replace command. 
X@begin(description)
X
XCTRL-S@/Search-Forward.  Search for input string (stored string if
Xinput string is null) from point towards the end of the buffer.  The
Xpoint is moved from the current location to the end of the found string.
X
XCTRL-R@/Search-Backward.  Like forward except in the opposite direction
Xi.e., towards the beginning of the buffer.  Note that there is no
Xdistinction made between forward and backward stored search strings.  Finally
Xif the search string is found, the point is moved to the beginning of
Xthe string.
X
XESC R@/Replace.  Replace @i<ALL> occurrences of the search string with
Xthe null string from point to end-of-buffer.
X
XESC CTRL-R@/Query-Replace.  Like above, but pause at each search
Xstring found and query for action.
XThe response expected from you and their effects are as follows:
X@begin(description)
XY(es) or <space>@/Make this replacement
X 
XN(o)@/Do not make this replacement but continue
X 
X!@/Do the rest of the replacements with no queries
X 
XCTRL-G@/Abort the replacement command.  NOTE:  This does not
Xundo any previous replacement that you had authorized.
X 
X.@/Exactly like CTRL-G except that the cursor returns to
Xthe point at which the replacement command was given.
X 
X?@/Help for query replacement
X@end(description)
X@end(description) 
X
X@chapter(DEALING WITH WINDOWS)
X
X@tag(windows)First of all, note that windows are literally that: they are
Xareas of text in a buffer that you can see on the screen.  On the other hand,
Xby moving between windows and visiting different buffers in each, you
Xcan effectively edit several files at the same time.  When you ask for
Xadditional windows, EMACS splits the @i<current> window into two and
Xleaves you in the window created over the current pointer.  Thus you
Xcan get multiple windows on the screen.  What is less obvious is that
Xyou are always in a window which means that all window commands
Xoperate even when you are in a single window.  Each window is similar
Xin that it has a text area and the mode line.  However the
Xinformation/prompt line is common to all windows (and buffers). 
XFurther the new window will be into the same buffer as the one from
Xwhich the create window command was given.  To move the window to
Xanother buffer, you will have to "visit" the desired buffer from the
Xdesired window.  Since files are associated with buffers, this lets
Xyou simultaneously edit several files.  Which leads us to the final
Xpoint: all commands issued to EMACS are executed on the current buffer
Xin the current window.
X@begin(description)
X
XCTRL-X O(oh)@/To-Next-Window.  The current point is moved into the next
X(i.e., towards the end of the screen) window.  Note that the editor
Xcycles through windows which means that if the command is issued from
Xthe bottommost window you are put into the top window.
X
XCTRL-XP@/To-Previous-Window.  Like above but works on the previous
Xwindow. 
X
XCTRL-X 2@/Open-Window.  The current window is split into two
Xwindows -- @i<IF> there is enough space on the screen (a minimum of 1
Xline of text and 1 mode line per window are required).
X
XCTRL-X 1@/Close-Windows.  This closes @i<all> windows except the one
Xfrom which you issued the command.
X 
XCTRL-X CTRL-N@/Scroll-Current-Window-Down.  This scrolls the current
Xwindow down one line; i.e., the top line of the window dissappears and
Xthe hitherto invisible "next" line becomes visible.  Hence the scroll
Xwindow commands work counter-intuitively in that ordinarily one moves
Xones head with a "real" window or one moves the paper while here one
Xis literally moving the window on to the buffer.
X
XCTRL-X CTRL-P@/Scroll-Current-Window-Up.  Like above except in the
Xopposite direction; i.e., the previously invisible line towards the
Xbeginning of the buffer is made visible and the bottom line
Xdissappears from the window. 
X
XECS ! or ESC CTRL-L@/Center-Cursor.  The window is moved such that the
Xline with the point (with the cursor) is at the center of the window.
X 
XCTRL-X ^ or CTRL-X Z@/Enlarge-Window.  The window with the
Xpointer is enlarged by one line and the nearest window is shrunk by
Xone line.
X
XCTRL-X CTRL-Z@/Shrink-Window.  Like above but the current
Xwindow is shrunk and the nearest window is enlarged.
X 
XCTRL-L@/Refresh-Screen.  The screen is blanked and redrawn.  Useful if
Xthe screen updates are out of sync with your  commands.
X@end(description) 
X
X@comment(chapter9to12)
X@chapter<DEALING WITH BUFFERS>@tag(buffers)
X
X     Buffers are the major internal entities in EMACS and are
Xcharacterized by three things: their names, their modes, and the
Xfile with which they are associated.  Furthermore, each buffer has its
Xown remembered mark and point which makes it easy to "visit" other
Xbuffers and return to the original location  in the "current" buffer.
XDealing with them requires the following commands:
X
X@begin(description)
XESC < or <HOME>@/Top-Of-Buffer.  Moves point to the very beginning of
Xthe buffer.
X
XESC >or <shift-HOME>@/Bottom-Of-Buffer.  Moves point to the very end of the buffer.
X
XESC B@/To-Named-Buffer.  You will be prompted for a buffer name (see
X@ref(buflist) on how to find out about your buffers) and will be
Xswitched to it.  If the buffer does not exits, EMACS will create one
Xand put you into it.
X
XCTRL-X X@/Next-Buffer.  You will be put into the next buffer
Xin the buffer list.  Like with windows, EMACS cycles through the
Xbuffer list and hence if you are in the last buffer, you will be put
Xinto the first one.
X 
XCTRL-X CTRL-B@/List-Buffers.  A new window is created into the "List"
Xbuffer which contains details about all the buffers currently known to EMACS.
XYou are left in the original buffer.  To close the new window issue
Xthe close-windows command (CTRL-X 1).  The "List" buffer contains
Xinformation about the set global modes, the "buffer changed" indicator
X(an asterisk in the 2nd column), the buffer specific modes, the
Xbuffer size, the buffer name, and the associated filename.
X 
X 
XCTRL-X K@/Delete-Buffer.  The specified buffer (as above) is
Xdeleted if found.  Since this is a destructive operation, you will
Xasked for confirmation if the buffer was changed and not saved. 
XAnswer Y(es) or N(o).  As usual, CTRL-G cancels the command.
X@end(description)
X
X@section(Modes) @tag(modes)
X     Modes are associated with buffers and govern the way EMACS reacts
Xto certain commands (to be described below).  Each buffer starts with
Xno modes set and this is indicated on the information line in parentheses
XHowever, you can set "global" modes which means that each new buffer
Xstarts off in the set global modes.  Alternatively, you can add and
Xdelete modes for each buffer separately.
X
XCurrently, EMACS has the following modes: normal, wrap, view,
Xoverwrite, exact, and C.  Note that the default for all buffers is to
Xbe placed with no modes unless global modes are set.
XIn this normal case, long lines are not folded
Xand the line shifts to the left to enable you to view lines longer
Xthan 79 characters.  A dollar sign in the last column indicates a line
Xthat is longer than 79 characters.  Furthermore, any text typed after
Xthe 79th character is inserted exactly as is thus enabling you to
Xenter very long lines into your buffer.  Also no other modes are set
Xand hence you have no wrapping, insert mode, and inexact match. 
X@begin(description)
X
XWrap@/When wrap mode is set, EMACS tries to fold (break) lines at
Xthe currently defined right margin. See @tag(wrap) for more details on
Xwrapping text.
X
XView@/View mode essentially puts
Xyou into a read only buffer to prevent accidental damage to
Xfiles.  Some special files, such as the help file, are automatically
Xput into view mode buffer.@tag(viewmode)
X
XOver@/In over(write) mode, the normal "insert" mode is toggled off
Xwhich means anything you type in that would normally have
Xinserted itself would now overwrite the existing text.  The
XInsert-Space command (currently bound to CTRL-C) is very useful in
Xthis mode since it is self-inserting.@tag(insertmode)
X
XExact@/The exact mode
Xcontrols the manner in which string searches are done:  if exact mode
Xis set, the search is case sensitive;  if it is off, the case of the
Xtarget is ignored.
XC@/This mode is
Xautomatically set if the file extension is .c or .h and does useful
Xthings for you when you are writing programs in C.
X@end(description)
X
X
XThe commands required to deal with modes are as follows:
X 
X@begin(description)
XCTRL-X M@/Add-Mode.  You will be prompted for the mode to add.  Type it
Xin and hit return.  The mode line will change to reflect the addition.
XAs always, CTRL-G gets you out.  NOTE: To set the right margin when in wrap
Xmode, use the set right margin command with the appropriate numerical prefix
Xargument with ESC <number> CTRL-X F.  Thus, for example, to set the right
Xmargin at column 68 you would type:  ESC 68 CTRL-X F.  (See @ref<setmargin>).
X
XCTRL-X CTRL-M@/Delete-Mode.  Like above but to remove a mode for the current
Xbuffer.
X 
XESC M@/Add-Global-Mode.  The specified global mode is marked as to-be-added
Xto any new buffer.  Hence, the modes for existing buffers do not
Xchange.@tag(globalmode)
X 
XESC CTRL-M@/Delete-Global-Mode.  The specified global mode is removed
Xfrom the modes to be added to new buffers.   Once again, existing
Xbuffers and their modes are not effected.
X@end(description)
X
X@chapter(DEALING WITH FILES)
XText files are usually thought of as named collections of text
Xresiding on disk (or some other storage medium).  In EMACS the disk
Xbased versions of files come into play only when reading into or
Xwriting out buffers.  The link between the physical file and the
Xbuffer is through the associated filename.  EMACS permits full filenames;
Xi.e., you can specify: disk:\directories\filename.extension.  If the
Xdisk and directories are not specified, the default disk is used. 
XBecause of the way EMACS deals with files, several points ought to be noted.
XFirst, without explicitly saving the buffer into a files, all your
Xedits would be gone upon leaving EMACS (you are asked to confirm
Xwhenever you are about to lose edits).  Second, EMACS (at least currently)
Xhas no mechanism for "protecting" your diskbased files from
Xoverwriting when it saves files.  When instructed to save a file, it
Xmerrily proceeds to dump the file to disk.  If it didn't previously
Xexist it is now created.  If it did, it is overwritten and the
Xprevious version is lost for ever.  Hence, if you are unsure of your
Xedits or for any other reason wish to keep older versions of files around,
Xthe safe procedure is to read the file into a buffer (with CTRL-X R),
Ximmediately change the associated file name (with CTRL-X N), and then
Xstart your edits.  However, if you do not wish to do any edits but
Xmerely peruse the file, add the view mode (see @ref(viewmode)) to the
Xbuffer or ask for the file to be read in for viewing only (with CTRL-X V).
XThe following are the file related commands in EMACS.
X@begin(description)
X 
XCTRL-X CTRL-S@/SAve-Buffer-Under-Current-Filename.  Saves the contents
Xof the current buffer with the associated filename on the default disk/directory
X(if not specified).  Note that  CTRL-X S also works.
X 
XCTRL-X CTRL-W@/Save-Buffer-Under-New-Name.  You will be prompted for a
Xfile name.  Type it in and hit <return>.   The buffer contents will be
Xsaved under the given name.
X 
XCTRL-X N@/Change-Associated-Filename.  The associated filename is
Xchanged (or associated if not previously specified) as specified.
X
XCTRL-X CTRL-F@/Find-A-File.  You will be prompted for a filename.  If the file has already been read into a buffer,
Xyou will be switch to it.  If not, it will be read into a new buffer and you
Xwill be put into that buffer.
X 
XCTRL-X CTRL-R@/Read-In-A-File.  You will be prompted for a filename.  If the
Xfile has already been read into another buffer,  you will be switched to it.
XIf not,  it will be read into the CURRENT buffer thus overwriting the
Xbuffer contents.  As always, you will be asked for confirmation of the
Xoverwrite if the buffer has been changed since the last save.
X 
XCTRL-X CTRL-V@/View-A-File.  Exactly like the above except that the
Xbuffer will automatically be put into view mode thus not allowing you
Xto make any changes to it. 
X@end(description)
X@chapter(FORMATTING)
X 
X     While, as said before, EMACS is not a word-processor, some
Xformatting facilities are available. In no particular order they
Xare:
X 
X@section(WRAPPING TEXT)
X 
X    Normally, EMACS allows you to type in long lines (longer than
Xthe screen width). However, if you wish it to automatically wrap
Xlines longer than a given width, you can do so by setting the
X@tag(setmargin)
XWRAP mode.
X@begin(description) 
XCTRL-X M [WRAP]@/Add-Wrap-Mode.  Add wrap mode to current buffer. 
XNote that [WRAP] means that you respong with WRAP when prompted.
X
XCTRL-X CTRL-M [WRAP]@/Delete-Wrap-Mode.  Removes wrap mode from
Xcurrent buffer.
X@end(description)
X
XWrap mode does not set the column (margin) at which wrapping is
Xsupposed to occur.  Hence, it is very important that along with
Xadding wrap mode to the buffer, you set the desired margin.  If you don't,
Xthe usual default value of 1 is used and the editor will behave very
Xstrangely since any text beyond the first column will be wrapped.
X
X@begin(description)
XCTRL-X F@/Set-Wrap-Margin.  Sets the wrap margin to the given numeric argument
XIf you do not precede this command with a numeric argument (with ESC <number>),
Xthe right margin is set at column 1 which is the default numeric argument. 
X@end(description)
X
XWhen in wrap mode, you can re-format a paragraph after extensive
Xediting as follows:
X@begin<description>
XESC Q@/Fill-Current-Paragraph.  See @ref(paradef) for a discussion of
Xwhat is considered to be a paragraph in EMACS.
X@end(description) 
X@section(Changing Case)
XChanging the case of the text in EMACS is also easy:
X
X@begin(description) 
XESC U@/Upper-Case-Word.  The text from point to the end of the word is
Xchanged to all uppercase.
X
XESC L@/Lower-Case-Word.  Like above except that text is changed to
Xlower case.
X
XESC C@/Capitalize-Word.  The first word after point is capitalized 
X(that is the first letter only is uppercased).  This means that if you
Xissued the command from within a word, the character after point is
Xcapitalized resulting in some wierd looking text.
X 
XESC CTRL-U@/Upper-Case-Region.  All of the text between point and mark (i.e.
Xin the region) is capitalized.
X
XESC CTRL-L@/Lower-Case-Region.  All of the text in the region (between
Xpoint and mark) is lower-cased.
X@end(description) 
X@section(Miscellaneous)
X@tag(tabset)
XSetting tabs to arbitray widths is possible in EMACS but you must be
Xaware of a subtle difference that it makes to your file and hence to
Xyour editing.  When you start EMACS, the tab width is set to the
Xdefault (usually every 8th column) for the tab character (CTRL-I).  As
Xlong as you stay with the default, every time you insert the tab
Xcharacter, a CTRL-I get inserted.  Hence, you logically have a single
Xcharacter which might appear to be several spaces on the screen (or
Xthe output) depending upon the column location of the tab character. 
XThis means that to remove the spacing you have to delete a @i<single>
Xcharacter -- the tab character.
X
XOn the other hand, the moment you explicitly set the tab interval
X(even if it is to the default value), EMACS handles the tab character
Xby expanding the character into the required number of spaces to move
Xyou to the appropriate column.   In this case, to remove the spacing
Xyou have to delete the appropriate number of spaces inserted by EMACS
Xto get you to the right column.
X
X@begin(description)
XCTRL-I@/Set-Tab-Interval.  The tab interval is set to the given
Xnumeric argument.  As always, the numeric argument preceeds the
Xcommand.  Hence to get tabs every 4 spaces you would type in@*
X@center[    ESC 4 CTRL-I]@*
Xor more generally: ESC [number] CTRL-I.
X@end(description)
X@chapter(GETTING OUT OF THINGS)
X 
X    Any pending commands can be aborted with CTRL-G. All this
Xdoes is cancel the command at its current level. Hence, for
Xexample, part of the way through a query replace, the abort will
Xnot undo the changes you have already allowed but will cancel the
Xremainder.
X 
X   Getting out of EMACS itself is possible in several ways:
X@begin(description) 
X
XCTRL-X CTRL-C.@/Hard-Abort.  This gets you out of EMACS and back to DOS.
XHowever if there are changed buffers which have not been
Xsaved, you  will be queried.
X 
XESC Z@/Quick-Exit.  This gets you out of EMACS but only @i<after> all
Xchanged buffers with legal filenames have been saved under the current
Xassociated filenames. Hence this could be a very dangerous command if
Xthere are changed buffers which will overwrite files you wished left
Xunchanged.  In general avoid this command. 
X@end(description)
X
X***********************************************************
X***                  W A R N I N G                      ***
X***                                                     ***
X*** AGAIN, PLEASE NOTE THAT ALL CHANGED BUFFERS WITH    ***
X*** FILENAMES WILL AUTOMATICALLY BE SAVED WITH ESC Z    ***
X***********************************************************
X
X@comment(ch13 to 16) 
X@chapter(Keyboard Macros)@tag(kbdmacro)
X 
X     A keyboard macro is a short hand way to repeat a series of
Xcommands.  In effect, a "recording" is started, with CTRL-X (,  of the
Xsequence of keys that you hit when defining a keyboard macro.  The
Xrecording is then repeated when you execute the keyboard macro. 
XHence, you could record any combination of character input and
Xcommands you like.  Once you stop recording your keystrokes(with
XCTRL-X ) ), the entire sequence is available to you to be repeated
Xstarting at the point at which the keyboard macro is invoked.  You
Xcould, therefore start recording at some location, move to another
Xpoint, and repeat the entire sequence at that location by invoking the
Xrecorded macro (with CTRL-X E). Since it is keystrokes that are being
Xsaved, you can freely intermix commands and text to be inserted  into
Xthe buffer.  Unfortunately, you cannot save a keyborad macro for
Xlater.  If you start another keyboard macro recording session, the previously
Xdefined macro is lost.  So make sure that you are done with the
Xcurrent keyboard macro before defining another one.  If you have a
Xseries of commands that you would like to "record" for later use, use
Xthe execute-file or execute-buffer commands (see @ref(execbuf) and/or 
X@ref(execfile)).
X@begin(description)
X
XCTRL-X (@/Start-Recording.  @b(All) keystrokes, commands and input are 
Xrecorded till the end-recording command is given.
X
XCTRL-X )@/End-Recording.    Stop recording keystrokes for macro.
XCTRL-X e@/Execute-Macro.  The entire sequence of recorded keystrokes
Xis repeated starting at the current point.  The result is exactly as if you 
Xwe retyping the sequence all over again.  A numeric argument prefixing
Xthe Execute-Macro command repeats the stored keystrokes that many times.
X@end(description) 
X 
X@chapter(Msdos And Emacs)@tag(msdos)
X 
X    There are two commands which will allow you to use MSDOS
Xwhile within EMACS. Procedurally, you will need to make sure that
Xthe "current" directory contains COMMAND.COM before you issue any
Xinternal commands (see the MSDOS manual). Also, external commands
Xor program may be run with some restrictions depending upon the
Xdegree to which the program "takes over" the computer or the amount of
Xmemory you have and the program size.  When you
Xuse either of the commands, EMACS pops you into MSDOS.  The key
Xdifference between the two commands is in how they act after the first
XMSDOS command has finished executing.  If you use the Run-DOS-Command command
Xa <RETURN> will put you back in EMACS exactly as you were before. 
XThe Run-CLI (run the Command Line Interpretor), on the other hand,
Xleaves you at the DOS command level (usually the A> prompt) so that
Xyou can continue issuing other commands; to return to EMACS, you need
Xto type in EXIT to leave the command line interpretor.
XNOTE: since EMACS is callable from the command line, you could easily have
Xseveral EMACS images in memory!  In general, this is a practice to be avoided
X
X@begin(description)
X
XCTRL-X !@/Run-DOS-Command.  Suspends EMACS and, if the file COMMAND.COM is
Xon the default drive,  allows one DOS command to be executed.  After
Xfinishing with that command, a <RETURN> will put you back in EMACS.
X
XCTRL-X C@/Run-CLI.  Like above execpt that multiple commands are
Xpermitted.  To return to EMACS, type in EXIT at the DOS prompt.
X@end(description)
X
XSUGGESTION: If you are going to run a program (or external MSDOS
Xcommand) from within EMACS for the first time, save your changed
Xbuffers (if you so desire) before you start. Once you are sure
Xthat the program will not damage EMACS, you need not take such
Xprecautions. As a favor to the user community, please inform the
XComputing Center of program that do and do not work and we will
Xtry to disseminate the information.
X 
XPROGRAMS AND EXTERNAL COMMANDS TESTED SO FAR: 
XXDIR@*
XPRINT@*
XKERMIT@*
XFINALWORD@*
XALL "INTERNAL" COMMANDS@*
X
X@chapter(Unbound Commands)
XIn this chapter we mention several commands that are not currently
Xbound to any keys.  If you find that you are using some of these
Xconsistently, you might want to bind them yourself either permanently
Xor temporarily (see @ref(customization)).
X
XTo execute an unbound (or for that matter a bound command) use the
Xcommand: Execute-Named-Command which is currently bound to ESC-X.
X@description[
XESC-X@/Execute-Named-Command.  You will be prompted (with a colon) on
Xthe prompt line for the named command to be executed.  Appendix A
Xcontains a list of the named comands that you could execute.  EMACS
Xattempts to complete the command if you hit the <SPACE> bar; i.e., if
Xthe information that you have typed in so far is sufficient to
Xidentify the command uniquely, EMACS finishes typing it in for you and
Xthen waits for the <RETURN> before executing the command.]
X
XUnbound commands are:
X@begin(description)
XHunt-Forward@/Repeat the last forward search command. Thus this is
Xidentical to you typing in CTRL-S (search-forward) and then defaulting
Xthe search string (by simply giving an ESC at the prompt line).
X
XHunt-Backward@/Repeat the last reverse search command. Thus this is
Xidentical to you typing in CTRL-R (search-reverse) and then defaulting
Xthe search string (by simply giving an ESC at the prompt line).
X
XExecute-Buffer@/You will be prompted for a buffer name.  If the buffer
Xexists, EMACS will assume that its contents are commands to be
Xexecuted by it before returning control to you.  If any of the
Xcommands are incorrect in the buffer, EMACS aborts the command and
Xreturns control to you immediately.  The syntax of commands in the
Xbuffer is as follows:@*
X	[numeric argument] named-command [string argument] [string argument]@*
Xwhere the only required parameter is the named-command itself.@tag(execbuf)
X
XExecute-File@/Very similar to the Execute-Buffer command except that
Xyou will be prompted for a file containing commands to be executed by
XEMACS. As in the above case, error will cause an immediate abort and
Xthe syntax of the commands is the same.@tag(execfile)
X
XExecute-Command-Line@/????
X@end(description)
X@chapter(Customization)
X@tag(customization)
XEMACS is extensively customizable in that the keystroke used to invoke
Xa command can be changed to suit your needs at will.  The connection
Xof a keystroke to a command is called key-binding.  Keybinding can be
Xdone temporarily or permanently -- by which we mean that the changed
Xkeybinding will last only during one editing session or will always be
Xeffective.  Furthermore, any keybinding can be removed permanently or during
Xan editing session.  We will cover temporary bindings and unbindings first.  
X
X@begin(description)
XESC K@/Bind-To-Key.  The Bind-To-Key command, currently bound to ESC
XK, will prompt you for the named command and the key to which it is to
Xbe bound.  The set of named commands is in Appendix A.  The key(s) to
Xwhich the command is to be bound are simply typed in exactly.  That
Xis, to bind a command to, say ESC D, type in the named command, a
Xspace, and then the keys ESC and D.
X
XESC CTRL-K@/Unbind-Key.  This command undoes the effect of the
Xprevious command or any built-in bindings.  As above you will be
Xprompted for the required information -- in this case the information
Xis simply the key to be unbound which is to be typed in exactly as
Xabove.
X@end(description)
X@i<@b[
XNOTE:  be very careful in binding and unbinding keys since you could
Xget into some very peculiar situations such as being unable to abort
Xour of a command (if you unbind CTRL-G or bind it to something else)
Xor recover from the bad binding/unbinding if you unbind Execute-Named-Command
Xor the Unbind-Key command.  As long as you leave yourself the
Xopportunity to do either of the last two commands, youc an recover
Xfrom disasterous bindings/unbindings.]>
X
XPermanent changes are done indirectly through the EMACS.RC file.  This
Xis a file that EMACS reads and executes (see @ref(execfile))
X@i<before> startup and hence results in the appearance of a permanent
Xchange in the keybindings.  The syntax of commands in the EMACS.RC
Xfile is described under the Execute-File command (@ref(execfile)).  Of
Xprincipal concern here are the two commands Bind-To-Key and
XUnbind-Key.  The primary difference between the way parameters are
Xpassed to these commands in the EMACS.RC file is that the keys are not
Xtyped in directly (as in the control-I key when you want CTRL-I) but
Xsymbolically using the following symbols:
X
X@description[
X
X^@/for control keys. For example to indicate control-I, you would type ^I.
X
XM@/for the escape key.  For example, to indicate ESC CTRL-K, you would
Xtype in M^I.
X
XFN@/for "function" keys.  The reason for the quotes is that for the
XHP150 the term function is expanded to include all of the special keys
Xsuch as the <INSERT-CHAR> key.  
X]
END_OF_emacs1.mss
if test 49811 -ne `wc -c <emacs1.mss`; then
    echo shar: \"emacs1.mss\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 14 \(of 14\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    echo "See the readme file"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
