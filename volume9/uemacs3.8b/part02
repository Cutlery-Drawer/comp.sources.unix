Subject:  v09i034:  MicroEMACS, verison 3.8b, Part02/14
Path: mirror!sources-request
From: sources-request@mirror.TMC.COM
Newsgroups: comp.sources.unix
Message-ID: <2285@mirror.TMC.COM>
Sender: rs@mirror.TMC.COM
Approved: rs@mirror.TMC.COM
Lines: 1890

Submitted by: ihnp4!itivax!duncan!lawrence (Daniel Lawrence)
Mod.sources: Volume 9, Issue 34
Archive-name: uemacs3.8b/Part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If this archive is complete, you will see the message:
#		"End of archive 2 (of 14)."
# Contents:  crypt.c egapc.c emacs.key ibmpc.c region.c tipc.c vmsvt.c
# Wrapped by rs@mirror on Fri Mar 13 13:23:23 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"crypt.c\" \(6931 characters\)
if test -f crypt.c ; then 
  echo shar: Will not over-write existing file \"crypt.c\"
else
sed "s/^X//" >crypt.c <<'END_OF_crypt.c'
X/*	Crypt:	Encryption routines for MicroEMACS
X		written by Dana Hoggatt and Daniel Lawrence
X*/
X
X#include	<stdio.h>
X#include	"estruct.h"
X#include	"edef.h"
X
X#if	CRYPT
X
X#if	MEGAMAX & ST520
Xoverlay	"crypt"
X#endif
X
Xsetkey(f, n)	/* reset encryption key of current buffer */
X
Xint f;		/* default flag */
Xint n;		/* numeric argument */
X
X{
X	register int status;	/* return status */
X	char key[NPAT];		/* new encryption string */
X
X	/* get the string to use as an encrytion string */
X        if ((status = mlreply("Encryption String: ", key, NPAT - 1)) != TRUE)
X                return(status);
X
X	/* and encrypt it */
X	crypt((char *)NULL, 0);
X	crypt(key, strlen(key));
X
X	/* and save it off */
X	strcpy(curbp->b_key, key);
X	mlwrite(" ");		/* clear it off the bottom line */
X	return(TRUE);
X}
X
X/**********
X *
X *	crypt - in place encryption/decryption of a buffer
X *
X *	(C) Copyright 1986, Dana L. Hoggatt
X *	1216, Beck Lane, Lafayette, IN
X *
X *	When consulting directly with the author of this routine, 
X *	please refer to this routine as the "DLH-POLY-86-B CIPHER".  
X *
X *	This routine was written for Dan Lawrence, for use in V3.8 of
X *	MICRO-emacs, a public domain text/program editor.  
X *
X *	I kept the following goals in mind when preparing this function:
X *
X *	    1.	All printable characters were to be encrypted back
X *		into the printable range, control characters and
X *		high-bit characters were to remain unaffected.  this
X *		way, encrypted would still be just as cheap to 
X *		transmit down a 7-bit data path as they were before.
X *
X *	    2.	The encryption had to be portable.  The encrypted 
X *		file from one computer should be able to be decrypted 
X *		on another computer.
X *
X *	    3.	The encryption had to be inexpensive, both in terms
X *		of speed and space.
X *
X *	    4.	The system needed to be secure against all but the
X *		most determined of attackers.
X *
X *	For encryption of a block of data, one calls crypt passing 
X *	a pointer to the data block and its length. The data block is 
X *	encrypted in place, that is, the encrypted output overwrites 
X *	the input.  Decryption is totally isomorphic, and is performed 
X *	in the same manner by the same routine.  
X *
X *	Before using this routine for encrypting data, you are expected 
X *	to specify an encryption key.  This key is an arbitrary string,
X *	to be supplied by the user.  To set the key takes two calls to 
X *	crypt().  First, you call 
X *
X *		crypt(NULL, vector)
X *
X *	This resets all internal control information.  Typically (and 
X *	specifically in the case on MICRO-emacs) you would use a "vector" 
X *	of 0.  Other values can be used to customize your editor to be 
X *	"incompatable" with the normally distributed version.  For 
X *	this purpose, the best results will be obtained by avoiding
X *	multiples of 95.
X *
X *	Then, you "encrypt" your password by calling 
X *
X *		crypt(pass, strlen(pass))
X *
X *	where "pass" is your password string.  Crypt() will destroy 
X *	the original copy of the password (it becomes encrypted), 
X *	which is good.  You do not want someone on a multiuser system 
X *	to peruse your memory space and bump into your password.  
X *	Still, it is a better idea to erase the password buffer to 
X *	defeat memory perusal by a more technical snooper.  
X *
X *	For the interest of cryptologists, at the heart of this 
X *	function is a Beaufort Cipher.  The cipher alphabet is the 
X *	range of printable characters (' ' to '~'), all "control" 
X *	and "high-bit" characters are left unaltered.
X *
X *	The key is a variant autokey, derived from a wieghted sum 
X *	of all the previous clear text and cipher text.  A counter 
X *	is used as salt to obiterate any simple cyclic behavior 
X *	from the clear text, and key feedback is used to assure 
X *	that the entire message is based on the original key, 
X *	preventing attacks on the last part of the message as if 
X *	it were a pure autokey system.
X *
X *	Overall security of encrypted data depends upon three 
X *	factors:  the fundamental cryptographic system must be 
X *	difficult to compromise; exhaustive searching of the key 
X *	space must be computationally expensive; keys and plaintext 
X *	must remain out of sight.  This system satisfies this set
X *	of conditions to within the degree desired for MicroEMACS.
X *
X *	Though direct methods of attack (against systems such as 
X *	this) do exist, they are not well known and will consume 
X *	considerable amounts of computing time.  An exhaustive
X *	search requires over a billion investigations, on average.
X *
X *	The choice, entry, storage, manipulation, alteration, 
X *	protection and security of the keys themselves are the 
X *	responsiblity of the user.  
X *
X **********/
X
Xcrypt(bptr, len)
Xregister char *bptr;	/* buffer of characters to be encrypted */
Xregister unsigned len;	/* number of characters in the buffer */
X{
X	register int cc;	/* current character being considered */
X
X	static long key = 0;	/* 29 bit encipherment key */
X	static int salt = 0;	/* salt to spice up key with */
X
X	if (!bptr) {		/* is there anything here to encrypt? */
X		key = len;	/* set the new key */
X		salt = len;	/* set the new salt */
X		return;
X	}
X	while (len--) {		/* for every character in the buffer */
X
X		cc = *bptr;	/* get a character out of the buffer */
X
X		/* only encipher printable characters */
X		if ((cc >= ' ') && (cc <= '~')) {
X
X/**  If the upper bit (bit 29) is set, feed it back into the key.  This 
X	assures us that the starting key affects the entire message.  **/
X
X			key &= 0x1FFFFFFFL;	/* strip off overflow */
X			if (key & 0x10000000L) {
X				key ^= 0x0040A001L;	/* feedback */
X			}
X
X/**  Down-bias the character, perform a Beaufort encipherment, and 
X	up-bias the character again.  We want key to be positive 
X	so that the left shift here will be more portable and the 
X	mod95() faster   **/
X
X			cc = mod95((int)(key % 95) - (cc - ' ')) + ' ';
X
X/**  the salt will spice up the key a little bit, helping to obscure 
X	any patterns in the clear text, particularly when all the 
X	characters (or long sequences of them) are the same.  We do 
X	not want the salt to go negative, or it will affect the key 
X	too radically.  It is always a good idea to chop off cyclics 
X	to prime values.  **/
X
X			if (++salt >= 20857) {	/* prime modulus */
X				salt = 0;
X			}
X
X/**  our autokey (a special case of the running key) is being 
X	generated by a wieghted checksum of clear text, cipher 
X	text, and salt.   **/
X
X			key = key + key + cc + *bptr + salt;
X		}
X		*bptr++ = cc;	/* put character back into buffer */
X	}
X	return;
X}
X
X#if	MEGAMAX & ST520
Xint mod95(val)
X#else
Xstatic int mod95(val)
X#endif
X
Xregister int val;
X
X{
X	/*  The mathematical MOD does not match the computer MOD  */
X
X	/*  Yes, what I do here may look strange, but it gets the
X		job done, and portably at that.  */
X
X	while (val >= 9500)
X		val -= 9500;
X	while (val >= 950)
X		val -= 950;
X	while (val >= 95)
X		val -= 95;
X	while (val < 0)
X		val += 95;
X	return (val);
X}
X#else
Xnocrypt()
X{
X}
X#endif
END_OF_crypt.c
if test 6931 -ne `wc -c <crypt.c`; then
    echo shar: \"crypt.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"egapc.c\" \(6871 characters\)
if test -f egapc.c ; then 
  echo shar: Will not over-write existing file \"egapc.c\"
else
sed "s/^X//" >egapc.c <<'END_OF_egapc.c'
X/*
X * The routines in this file provide support for the IBM-PC EGA and other
X * compatible terminals. It goes directly to the graphics RAM to do
X * screen output. It compiles into nothing if not an IBM-PC EGA driver
X */
X
X#define	termdef	1			/* don't define "term" external */
X
X#include        <stdio.h>
X#include	"estruct.h"
X#include        "edef.h"
X
X#if     EGA
X
X#define NROW    43                      /* Screen size.                 */
X#define NCOL    80                      /* Edit if you want to.         */
X#define	MARGIN	8			/* size of minimim margin and	*/
X#define	SCRSIZ	64			/* scroll size for extended lines */
X#define	NPAUSE	200			/* # times thru update to pause */
X#define BEL     0x07                    /* BEL character.               */
X#define ESC     0x1B                    /* ESC character.               */
X#define	SPACE	32			/* space character		*/
X#define	SCADD	0xb8000000L		/* address of screen RAM	*/
X
Xint *scptr[NROW];			/* pointer to screen lines	*/
Xint sline[NCOL];			/* screen line image		*/
X
Xextern  int     ttopen();               /* Forward references.          */
Xextern  int     ttgetc();
Xextern  int     ttputc();
Xextern  int     ttflush();
Xextern  int     ttclose();
Xextern	int	egakopen();
Xextern	int	egakclose();
Xextern  int     egamove();
Xextern  int     egaeeol();
Xextern  int     egaeeop();
Xextern  int     egabeep();
Xextern  int     egaopen();
Xextern	int	egarev();
Xextern	int	egacres();
Xextern	int	egaclose();
Xextern	int	egaputc();
X
X#if	COLOR
Xextern	int	egafcol();
Xextern	int	egabcol();
X
Xint	cfcolor = -1;		/* current forground color */
Xint	cbcolor = -1;		/* current background color */
Xint	ctrans[] =		/* ansi to ega color translation table */
X	{0, 4, 2, 6, 1, 5, 3, 7};
X#endif
X
X/*
X * Standard terminal interface dispatch table. Most of the fields point into
X * "termio" code.
X */
XTERM    term    = {
X	NROW-1,
X        NROW-1,
X        NCOL,
X        NCOL,
X	MARGIN,
X	SCRSIZ,
X	NPAUSE,
X        egaopen,
X        egaclose,
X	egakopen,
X	egakclose,
X        ttgetc,
X	egaputc,
X        ttflush,
X        egamove,
X        egaeeol,
X        egaeeop,
X        egabeep,
X	egarev,
X	egacres
X#if	COLOR
X	, egafcol,
X	egabcol
X#endif
X};
X
Xextern union REGS rg;
X
X#if	COLOR
Xegafcol(color)		/* set the current output color */
X
Xint color;	/* color to set */
X
X{
X	cfcolor = ctrans[color];
X}
X
Xegabcol(color)		/* set the current background color */
X
Xint color;	/* color to set */
X
X{
X        cbcolor = ctrans[color];
X}
X#endif
X
Xegamove(row, col)
X{
X	rg.h.ah = 2;		/* set cursor position function code */
X	rg.h.dl = col;
X	rg.h.dh = row;
X	rg.h.bh = 0;		/* set screen page number */
X	int86(0x10, &rg, &rg);
X}
X
Xegaeeol()	/* erase to the end of the line */
X
X{
X	int attr;	/* attribute byte mask to place in RAM */
X	int *lnptr;	/* pointer to the destination line */
X	int i;
X	int ccol;	/* current column cursor lives */
X	int crow;	/*	   row	*/
X
X	/* find the current cursor position */
X	rg.h.ah = 3;		/* read cursor position function code */
X	rg.h.bh = 0;		/* current video page */
X	int86(0x10, &rg, &rg);
X	ccol = rg.h.dl;		/* record current column */
X	crow = rg.h.dh;		/* and row */
X
X	/* build the attribute byte and setup the screen pointer */
X#if	COLOR
X	attr = (((cbcolor & 15) << 4) | (cfcolor & 15)) << 8;
X#else
X	attr = 0x0700;
X#endif
X	lnptr = &sline[0];
X	for (i=0; i < NCOL; i++)
X		*lnptr++ = SPACE | attr;
X
X	if (flickcode) {
X		/* wait for vertical retrace to be off */
X		while ((inp(0x3da) & 8))
X			;
X
X		/* and to be back on */
X		while ((inp(0x3da) & 8) == 0)
X			;
X	}
X
X	/* and send the string out */
X	movmem(&sline[0], scptr[crow]+ccol, (NCOL-ccol)*2);
X
X}
X
Xegaputc(ch)	/* put a character at the current position in the
X		   current colors */
X
Xint ch;
X
X{
X	rg.h.ah = 14;		/* write char to screen with current attrs */
X	rg.h.al = ch;
X#if	COLOR
X	rg.h.bl = cfcolor;
X#else
X	rg.h.bl = 0x07;
X#endif
X	int86(0x10, &rg, &rg);
X}
X
Xegaeeop()
X{
X	int attr;		/* attribute to fill screen with */
X
X	rg.h.ah = 6;		/* scroll page up function code */
X	rg.h.al = 0;		/* # lines to scroll (clear it) */
X	rg.x.cx = 0;		/* upper left corner of scroll */
X	rg.x.dx = 0x2a4f;	/* lower right corner of scroll */
X#if	COLOR
X	attr = ((ctrans[gbcolor] & 15) << 4) | (ctrans[gfcolor] & 15);
X#else
X	attr = 0;
X#endif
X	rg.h.bh = attr;
X	int86(0x10, &rg, &rg);
X}
X
Xegarev(state)		/* change reverse video state */
X
Xint state;	/* TRUE = reverse, FALSE = normal */
X
X{
X	/* This never gets used under the ega-PC driver */
X}
X
Xegacres()	/* change screen resolution */
X
X{
X	return(TRUE);
X}
X
Xegabeep()
X{
X	bdos(6, BEL, 0);
X}
X
Xegaopen()
X{
X	char buf;	/* buffer for peek/poke */
X
X	/* initialize pointers to the screen ram */
X	scinit();
X
X	/* and put the beast into EGA 43 row mode */
X	rg.x.ax = 3;
X	int86(0x10, &rg, &rg);
X
X	rg.x.ax = 0x1112;
X	rg.h.bl = 0;
X	int86(0x10, &rg, &rg);
X
X	peek(0x40, 0x87, &buf, 1);
X	buf |= 1;
X	poke(0x40, 0x87, &buf, 1);
X	buf = 0xf8;
X	poke(0x40, 0x88, &buf, 1);
X
X	rg.x.ax = 0x0100;
X	rg.h.bh = 0;
X	rg.x.cx = 0x0007;
X	int86(0x10, &rg, &rg);
X
X	buf = 0xf9;
X	poke(0x40, 0x88, &buf, 1);
X
X	strcpy(sres, "43LINE");
X	revexist = TRUE;
X        ttopen();
X}
X
Xegaclose()
X
X{
X	char buf;	/* buffer for peek/poke */
X
X#if	COLOR
X	egafcol(7);
X	egabcol(0);
X#endif
X	/* and put the beast into 80 column mode */
X	rg.x.ax = 0002;
X	int86(0x10, &rg, &rg);
X	ttclose();
X
X#if	0
X	peek(0x40, 0x87, &buf, 1);
X	buf--;
X	poke(0x40, 0x87, &buf, 1);
X#endif
X
X	/* and restore the normal cursor */
X	rg.x.ax = 0x0100;
X	rg.h.bl = 0;
X	rg.x.cx = 0x0b0d;
X	int86(0x10, &rg, &rg);
X}
X
Xegakopen()
X
X{
X}
X
Xegakclose()
X
X{
X}
X
Xscinit()	/* initialize the screen head pointers */
X
X{
X	union {
X		long laddr;	/* long form of address */
X		int *paddr;	/* pointer form of address */
X	} addr;
X	int i;
X
X	/* initialize the screen pointer array */
X	for (i = 0; i < NROW; i++) {
X		addr.laddr = SCADD + (long)(NCOL * i * 2);
X		scptr[i] = addr.paddr;
X	}
X}
X
Xscwrite(row, outstr, forg, bacg)	/* write a line out*/
X
Xint row;	/* row of screen to place outstr on */
Xchar *outstr;	/* string to write out (must be NCOL long) */
Xint forg;	/* forground color of string to write */
Xint bacg;	/* background color */
X
X{
X	int attr;	/* attribute byte mask to place in RAM */
X	int *lnptr;	/* pointer to the destination line */
X	int i;
X
X	/* build the attribute byte and setup the screen pointer */
X#if	COLOR
X	attr = (((ctrans[bacg] & 15) << 4) | (ctrans[forg] & 15)) << 8;
X#else
X	attr = (((bacg & 15) << 4) | (forg & 15)) << 8;
X#endif
X	lnptr = &sline[0];
X	for (i=0; i<term.t_ncol; i++)
X		*lnptr++ = (outstr[i] & 255) | attr;
X
X	if (flickcode) {
X		/* wait for vertical retrace to be off */
X		while ((inp(0x3da) & 8))
X			;
X
X		/* and to be back on */
X		while ((inp(0x3da) & 8) == 0)
X			;
X	}
X
X	/* and send the string out */
X	movmem(&sline[0], scptr[row],term.t_ncol*2);
X}
X
X#if	FLABEL
Xfnclabel(f, n)		/* label a function key */
X
Xint f,n;	/* default flag, numeric argument [unused] */
X
X{
X	/* on machines with no function keys...don't bother */
X	return(TRUE);
X}
X#endif
X#else
Xegahello()
X{
X}
X#endif
END_OF_egapc.c
if test 6871 -ne `wc -c <egapc.c`; then
    echo shar: \"egapc.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"emacs.key\" \(5313 characters\)
if test -f emacs.key ; then 
  echo shar: Will not over-write existing file \"emacs.key\"
else
sed "s/^X//" >emacs.key <<'END_OF_emacs.key'
X		Default Key Bindings for MicroEmacs 3.8b	(01/22/87)
X		========================================
X
X ^A   Move to start of line           ESC A   Apropos (list some commands)
X ^B   Move backward by characters     ESC B   Backup by words
X ^C   Insert space                    ESC C   Initial capitalize word
X ^D   Forward delete                  ESC D   Delete forward word
X ^E   Goto end of line                ESC E   Reset Encryption Key
X ^F   Move forward by characters      ESC F   Advance by words
X ^G   Abort out of things             ESC G   Go to a line
X ^H   Backward delete                 
X ^I   Insert tab/Set tab stops
X ^J   Insert CR-LF, then indent                     
X ^K   Kill forward                    ESC K   Bind Key to function
X ^L   Refresh the screen              ESC L   Lower case word
X ^M   Insert CR-LF                    ESC M   Add global mode
X ^N   Move forward by lines           ESC N   Goto End paragraph
X ^O   Open up a blank line            
X ^P   Move backward by lines          ESC P   Goto Begining of paragraph
X ^Q   Insert literal                  ESC Q   Fill current paragraph
X ^R   Search backwards                ESC R   Search and replace
X ^S   Search forward                  ESC S   Suspend MicroEMACS (BSD4.2 only)
X ^T   Transpose characters
X ^U   Repeat command four times       ESC U   Upper case word
X ^V   Move forward by pages           ESC V   Move backward by pages
X ^W   Kill region                     ESC W   Copy region to kill buffer
X ^Y   Yank back from killbuffer       ESC X   Execute named command
X ^Z   Move backward by pages          ESC Z   Save all buffers and exit
X
X ESC ^C   Count words in region       ESC ~   Unmark current buffer
X ESC ^F   Goto matching fence         ESC !   Reposition window
X ESC ^H   Delete backward word        ESC <   Move to start of buffer
X ESC ^K   Unbind Key from function    ESC >   Move to end of buffer
X ESC ^L   Reposition window           ESC .   Set mark
X ESC ^M   Delete global mode          ESC ?   Fetch HELP file to buffer
X ESC ^N   Rename current buffer       ESC space    Set mark
X ESC ^R   Search & replace w/query    ESC rubout   Delete backward word
X ESC ^S   Change screen rows              rubout   Backward delete
X ESC ^T   Change screen columns
X ESC ^V   Scroll next window down
X ESC ^W   Delete Paragraph
X ESC ^Z   Scroll next window up
X
X ^X ?   Describe a key             ^X !   Run 1 command in a subjob
X ^X =   Show the cursor position   ^X @   Pipe DOS command to buffer
X ^X ^   Enlarge display window     ^X #   Filter buffer thru DOS filter
X ^X 0   Delete current window      ^X (   Begin macro
X ^X 1   Delete other windows       ^X )   End macro
X ^X 2   Split current window
X                                   ^X A   Set variable value
X ^X ^B   Display buffer list       ^X B   Switch a window to a buffer
X ^X ^C   Exit MicroEMACS           ^X C   Start a new command processer
X                                   ^X D   Suspend MicroEMACS (BSD4.2 only)
X                                   ^X E   Execute macro
X ^X ^F   Find file                 ^X F   Set fill column
X ^X ^I   Insert file
X                                   ^X K   Delete buffer
X ^X ^L   Lower case region
X ^X ^M   Delete Mode               ^X M   Add a mode
X ^X ^N   Move window down          ^X N   Rename current filename
X ^X ^O   Delete blank lines        ^X O   Move to the next window
X ^X ^P   Move window up            ^X P   Move to the previous window
X ^X ^R   Get a file from disk      ^X R   Incremental reverse search
X ^X ^S   Save current file         ^X S   Incremental forward search
X ^X ^U   Upper case region
X ^X ^V   View file
X ^X ^W   Write a file to disk      ^X W   resize Window
X ^X ^X   Swap "." and mark         ^X X   Use next buffer
X ^X ^Z   Shrink window             ^X Z   Enlarge display window
X
XOnly under PCDOS:
X <ALT>-S Hunt forward        SHIFT <F1> - <F10>
X <ALT>-R Hunt backward           Execute macroes 1 - 10
X
XSome unbound commands:
X======================
Xexecute-buffer		execute a buffer od command lines
Xexecute-command-line	execute a command line (n <command> <args>)
Xexecute-file		execute a file of command lines
Xexecute-named-command	execute a command by name (w/command completion)
Xexecute-macro-[1-40]	execute macroes 1 thru 40
Xdescribe-bindings	pull the list of current bindings into a window
Xhunt-forward		find next occurance of search string
Xhunt-backward		find last occurance of search string
X
XUsable Modes
X============
XWRAP     Lines going past right margin "wrap" to a new line
XVIEW     Read-Only mode where no modifications are allowed
XCMODE    Change behavior of some commands to work with C better
XEXACT    Exact case matching on search strings
XOVER     Overwrite typed characters instead of inserting them
XCRYPT    Current buffer will be encrypted on write, decrypted on read
XMAGIC    Use regular expresion matching in searches
X
XWHITE/CYAN/MAGENTA/YELLOW/BLUE/RED/GREEN/BLACK	Sets foreground color
Xwhite/cyan/magenta/yellow/blue/red/green/black	Sets background color
X
XMAGIC MODE special characters
X=============================
X^	Anchor search at beginning of line
X$	Anchor search at end of line
X.	Match any character except <NL>
X*	Match zero or more of the preceeding character
X[]	Match a class of characters ([a-z] would be all alphabetics)
X\	Take next literally
X
END_OF_emacs.key
if test 5313 -ne `wc -c <emacs.key`; then
    echo shar: \"emacs.key\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"ibmpc.c\" \(7249 characters\)
if test -f ibmpc.c ; then 
  echo shar: Will not over-write existing file \"ibmpc.c\"
else
sed "s/^X//" >ibmpc.c <<'END_OF_ibmpc.c'
X/*
X * The routines in this file provide support for the IBM-PC and other
X * compatible terminals. It goes directly to the graphics RAM to do
X * screen output. It compiles into nothing if not an IBM-PC driver
X */
X
X#define	termdef	1			/* don't define "term" external */
X
X#include        <stdio.h>
X#include	"estruct.h"
X#include        "edef.h"
X
X#if     IBMPC
X
X#define NROW    25                      /* Screen size.                 */
X#define NCOL    80                      /* Edit if you want to.         */
X#define	MARGIN	8			/* size of minimim margin and	*/
X#define	SCRSIZ	64			/* scroll size for extended lines */
X#define	NPAUSE	200			/* # times thru update to pause */
X#define BEL     0x07                    /* BEL character.               */
X#define ESC     0x1B                    /* ESC character.               */
X#define	SPACE	32			/* space character		*/
X
X#define	SCADC	0xb8000000L		/* CGA address of screen RAM	*/
X#define	SCADM	0xb0000000L		/* MONO address of screen RAM	*/
X
X#define	CDCGA	0			/* color graphics card		*/
X#define	CDMONO	1			/* monochrome text card		*/
X#define	CDSENSE	9			/* detect the card type		*/
X
Xint dtype = CDCGA;			/* current display type		*/
Xlong scadd;				/* address of screen ram	*/
Xint *scptr[NROW];			/* pointer to screen lines	*/
Xint sline[NCOL];			/* screen line image		*/
Xextern union REGS rg;			/* cpu register for use of DOS calls */
X
Xextern  int     ttopen();               /* Forward references.          */
Xextern  int     ttgetc();
Xextern  int     ttputc();
Xextern  int     ttflush();
Xextern  int     ttclose();
Xextern  int     ibmmove();
Xextern  int     ibmeeol();
Xextern  int     ibmeeop();
Xextern  int     ibmbeep();
Xextern  int     ibmopen();
Xextern	int	ibmrev();
Xextern	int	ibmcres();
Xextern	int	ibmclose();
Xextern	int	ibmputc();
Xextern	int	ibmkopen();
Xextern	int	ibmkclose();
X
X#if	COLOR
Xextern	int	ibmfcol();
Xextern	int	ibmbcol();
X
Xint	cfcolor = -1;		/* current forground color */
Xint	cbcolor = -1;		/* current background color */
Xint	ctrans[] =		/* ansi to ibm color translation table */
X	{0, 4, 2, 6, 1, 5, 3, 7};
X#endif
X
X/*
X * Standard terminal interface dispatch table. Most of the fields point into
X * "termio" code.
X */
XTERM    term    = {
X	NROW-1,
X        NROW-1,
X        NCOL,
X        NCOL,
X	MARGIN,
X	SCRSIZ,
X	NPAUSE,
X        ibmopen,
X        ibmclose,
X	ibmkopen,
X	ibmkclose,
X        ttgetc,
X	ibmputc,
X        ttflush,
X        ibmmove,
X        ibmeeol,
X        ibmeeop,
X        ibmbeep,
X	ibmrev,
X	ibmcres
X#if	COLOR
X	, ibmfcol,
X	ibmbcol
X#endif
X};
X
Xextern union REGS rg;
X
X#if	COLOR
Xibmfcol(color)		/* set the current output color */
X
Xint color;	/* color to set */
X
X{
X	cfcolor = ctrans[color];
X}
X
Xibmbcol(color)		/* set the current background color */
X
Xint color;	/* color to set */
X
X{
X        cbcolor = ctrans[color];
X}
X#endif
X
Xibmmove(row, col)
X{
X	rg.h.ah = 2;		/* set cursor position function code */
X	rg.h.dl = col;
X	rg.h.dh = row;
X	rg.h.bh = 0;		/* set screen page number */
X	int86(0x10, &rg, &rg);
X}
X
Xibmeeol()	/* erase to the end of the line */
X
X{
X	int attr;	/* attribute byte mask to place in RAM */
X	int *lnptr;	/* pointer to the destination line */
X	int i;
X	int ccol;	/* current column cursor lives */
X	int crow;	/*	   row	*/
X
X	/* find the current cursor position */
X	rg.h.ah = 3;		/* read cursor position function code */
X	rg.h.bh = 0;		/* current video page */
X	int86(0x10, &rg, &rg);
X	ccol = rg.h.dl;		/* record current column */
X	crow = rg.h.dh;		/* and row */
X
X	/* build the attribute byte and setup the screen pointer */
X#if	COLOR
X	if (dtype == CDCGA)
X		attr = (((cbcolor & 15) << 4) | (cfcolor & 15)) << 8;
X	else
X		attr = 0x0700;
X#else
X	attr = 0x0700;
X#endif
X	lnptr = &sline[0];
X	for (i=0; i < term.t_ncol; i++)
X		*lnptr++ = SPACE | attr;
X
X	if (flickcode) {
X		/* wait for vertical retrace to be off */
X		while ((inp(0x3da) & 8))
X			;
X	
X		/* and to be back on */
X		while ((inp(0x3da) & 8) == 0)
X			;
X	}			
X
X	/* and send the string out */
X	movmem(&sline[0], scptr[crow]+ccol, (term.t_ncol-ccol)*2);
X
X}
X
Xibmputc(ch)	/* put a character at the current position in the
X		   current colors */
X
Xint ch;
X
X{
X	rg.h.ah = 14;		/* write char to screen with current attrs */
X	rg.h.al = ch;
X#if	COLOR
X	if (dtype == CDCGA)
X		rg.h.bl = cfcolor;
X	else
X		rg.h.bl = 0x07;
X#else
X	rg.h.bl = 0x07;
X#endif
X	int86(0x10, &rg, &rg);
X}
X
Xibmeeop()
X{
X	int attr;		/* attribute to fill screen with */
X
X	rg.h.ah = 6;		/* scroll page up function code */
X	rg.h.al = 0;		/* # lines to scroll (clear it) */
X	rg.x.cx = 0;		/* upper left corner of scroll */
X	rg.x.dx = 0x184f;	/* lower right corner of scroll */
X#if	COLOR
X	if (dtype == CDCGA)
X		attr = ((ctrans[gbcolor] & 15) << 4) | (ctrans[gfcolor] & 15);
X	else
X		attr = 0;
X#else
X	attr = 0;
X#endif
X	rg.h.bh = attr;
X	int86(0x10, &rg, &rg);
X}
X
Xibmrev(state)		/* change reverse video state */
X
Xint state;	/* TRUE = reverse, FALSE = normal */
X
X{
X	/* This never gets used under the IBM-PC driver */
X}
X
Xibmcres(res)	/* change screen resolution */
X
Xchar *res;	/* resolution to change to */
X
X{
X	if (strcmp(res, "CGA") == 0) {
X		scinit(CDCGA);
X		return(TRUE);
X	} else if (strcmp(res, "MONO") == 0) {
X		scinit(CDMONO);
X		return(TRUE);
X	} else
X		return(FALSE);
X}
X
Xibmbeep()
X{
X#if	MWC86
X	putcnb(BEL);
X#else
X	bdos(6, BEL, 0);
X#endif
X}
X
Xibmopen()
X{
X	scinit(CDSENSE);
X	revexist = TRUE;
X        ttopen();
X}
X
Xibmclose()
X
X{
X#if	COLOR
X	ibmfcol(7);
X	ibmbcol(0);
X#endif
X	ttclose();
X}
X
Xibmkopen()	/* open the keyboard */
X
X{
X}
X
Xibmkclose()	/* close the keyboard */
X
X{
X}
X
Xscinit(type)	/* initialize the screen head pointers */
X
Xint type;	/* type of adapter to init for */
X
X{
X	union {
X		long laddr;	/* long form of address */
X		int *paddr;	/* pointer form of address */
X	} addr;
X	int i;
X
X	/* if asked...find out what display is connected */
X	int86(0x11, &rg, &rg);
X	dtype = CDCGA;
X	scadd = SCADC;
X	strcpy(sres, "CGA");
X	if ((((rg.x.ax >> 4) & 11) == 3) || type == CDMONO) {
X		strcpy(sres, "MONO");
X		dtype = CDMONO;
X		scadd = SCADM;
X	}
X
X	/* initialize the screen pointer array */
X	for (i = 0; i < NROW; i++) {
X		addr.laddr = scadd + (long)(NCOL * i * 2);
X		scptr[i] = addr.paddr;
X	}
X}
X
Xscwrite(row, outstr, forg, bacg)	/* write a line out*/
X
Xint row;	/* row of screen to place outstr on */
Xchar *outstr;	/* string to write out (must be term.t_ncol long) */
Xint forg;	/* forground color of string to write */
Xint bacg;	/* background color */
X
X{
X	int attr;	/* attribute byte mask to place in RAM */
X	int *lnptr;	/* pointer to the destination line */
X	int i;
X
X	/* build the attribute byte and setup the screen pointer */
X#if	COLOR
X	if (dtype == CDCGA)
X		attr = (((ctrans[bacg] & 15) << 4) | (ctrans[forg] & 15)) << 8;
X	else
X		attr = (((bacg & 15) << 4) | (forg & 15)) << 8;
X#else
X	attr = (((bacg & 15) << 4) | (forg & 15)) << 8;
X#endif
X	lnptr = &sline[0];
X	for (i=0; i<term.t_ncol; i++)
X		*lnptr++ = (outstr[i] & 255) | attr;
X
X	if (flickcode) {
X		/* wait for vertical retrace to be off */
X		while ((inp(0x3da) & 8))
X			;
X	
X		/* and to be back on */
X		while ((inp(0x3da) & 8) == 0)
X			;
X	}
X
X	/* and send the string out */
X	movmem(&sline[0], scptr[row],term.t_ncol*2);
X}
X
X#if	FLABEL
Xfnclabel(f, n)		/* label a function key */
X
Xint f,n;	/* default flag, numeric argument [unused] */
X
X{
X	/* on machines with no function keys...don't bother */
X	return(TRUE);
X}
X#endif
X#else
Xibmhello()
X{
X}
X#endif
END_OF_ibmpc.c
if test 7249 -ne `wc -c <ibmpc.c`; then
    echo shar: \"ibmpc.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"region.c\" \(7029 characters\)
if test -f region.c ; then 
  echo shar: Will not over-write existing file \"region.c\"
else
sed "s/^X//" >region.c <<'END_OF_region.c'
X/*
X * The routines in this file
X * deal with the region, that magic space
X * between "." and mark. Some functions are
X * commands. Some functions are just for
X * internal use.
X */
X#include        <stdio.h>
X#include	"estruct.h"
X#include        "edef.h"
X
X#if	MEGAMAX & ST520
Xoverlay	"region"
X#endif
X
X/*
X * Kill the region. Ask "getregion"
X * to figure out the bounds of the region.
X * Move "." to the start, and kill the characters.
X * Bound to "C-W".
X */
Xkillregion(f, n)
X{
X        register int    s;
X        REGION          region;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        if ((s=getregion(&region)) != TRUE)
X                return (s);
X        if ((lastflag&CFKILL) == 0)             /* This is a kill type  */
X                kdelete();                      /* command, so do magic */
X        thisflag |= CFKILL;                     /* kill buffer stuff.   */
X        curwp->w_dotp = region.r_linep;
X        curwp->w_doto = region.r_offset;
X        return (ldelete(region.r_size, TRUE));
X}
X
X/*
X * Copy all of the characters in the
X * region to the kill buffer. Don't move dot
X * at all. This is a bit like a kill region followed
X * by a yank. Bound to "M-W".
X */
Xcopyregion(f, n)
X{
X        register LINE   *linep;
X        register int    loffs;
X        register int    s;
X        REGION          region;
X
X        if ((s=getregion(&region)) != TRUE)
X                return (s);
X        if ((lastflag&CFKILL) == 0)             /* Kill type command.   */
X                kdelete();
X        thisflag |= CFKILL;
X        linep = region.r_linep;                 /* Current line.        */
X        loffs = region.r_offset;                /* Current offset.      */
X        while (region.r_size--) {
X                if (loffs == llength(linep)) {  /* End of line.         */
X                        if ((s=kinsert('\n')) != TRUE)
X                                return (s);
X                        linep = lforw(linep);
X                        loffs = 0;
X                } else {                        /* Middle of line.      */
X                        if ((s=kinsert(lgetc(linep, loffs))) != TRUE)
X                                return (s);
X                        ++loffs;
X                }
X        }
X        return (TRUE);
X}
X
X/*
X * Lower case region. Zap all of the upper
X * case characters in the region to lower case. Use
X * the region code to set the limits. Scan the buffer,
X * doing the changes. Call "lchange" to ensure that
X * redisplay is done in all buffers. Bound to
X * "C-X C-L".
X */
Xlowerregion(f, n)
X{
X        register LINE   *linep;
X        register int    loffs;
X        register int    c;
X        register int    s;
X        REGION          region;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        if ((s=getregion(&region)) != TRUE)
X                return (s);
X        lchange(WFHARD);
X        linep = region.r_linep;
X        loffs = region.r_offset;
X        while (region.r_size--) {
X                if (loffs == llength(linep)) {
X                        linep = lforw(linep);
X                        loffs = 0;
X                } else {
X                        c = lgetc(linep, loffs);
X                        if (c>='A' && c<='Z')
X                                lputc(linep, loffs, c+'a'-'A');
X                        ++loffs;
X                }
X        }
X        return (TRUE);
X}
X
X/*
X * Upper case region. Zap all of the lower
X * case characters in the region to upper case. Use
X * the region code to set the limits. Scan the buffer,
X * doing the changes. Call "lchange" to ensure that
X * redisplay is done in all buffers. Bound to
X * "C-X C-L".
X */
Xupperregion(f, n)
X{
X        register LINE   *linep;
X        register int    loffs;
X        register int    c;
X        register int    s;
X        REGION          region;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        if ((s=getregion(&region)) != TRUE)
X                return (s);
X        lchange(WFHARD);
X        linep = region.r_linep;
X        loffs = region.r_offset;
X        while (region.r_size--) {
X                if (loffs == llength(linep)) {
X                        linep = lforw(linep);
X                        loffs = 0;
X                } else {
X                        c = lgetc(linep, loffs);
X                        if (c>='a' && c<='z')
X                                lputc(linep, loffs, c-'a'+'A');
X                        ++loffs;
X                }
X        }
X        return (TRUE);
X}
X
X/*
X * This routine figures out the
X * bounds of the region in the current window, and
X * fills in the fields of the "REGION" structure pointed
X * to by "rp". Because the dot and mark are usually very
X * close together, we scan outward from dot looking for
X * mark. This should save time. Return a standard code.
X * Callers of this routine should be prepared to get
X * an "ABORT" status; we might make this have the
X * conform thing later.
X */
Xgetregion(rp)
Xregister REGION *rp;
X{
X        register LINE   *flp;
X        register LINE   *blp;
X        long fsize;
X        long bsize;
X
X        if (curwp->w_markp == NULL) {
X                mlwrite("No mark set in this window");
X                return (FALSE);
X        }
X        if (curwp->w_dotp == curwp->w_markp) {
X                rp->r_linep = curwp->w_dotp;
X                if (curwp->w_doto < curwp->w_marko) {
X                        rp->r_offset = curwp->w_doto;
X                        rp->r_size = (long)(curwp->w_marko-curwp->w_doto);
X                } else {
X                        rp->r_offset = curwp->w_marko;
X                        rp->r_size = (long)(curwp->w_doto-curwp->w_marko);
X                }
X                return (TRUE);
X        }
X        blp = curwp->w_dotp;
X        bsize = (long)curwp->w_doto;
X        flp = curwp->w_dotp;
X        fsize = (long)(llength(flp)-curwp->w_doto+1);
X        while (flp!=curbp->b_linep || lback(blp)!=curbp->b_linep) {
X                if (flp != curbp->b_linep) {
X                        flp = lforw(flp);
X                        if (flp == curwp->w_markp) {
X                                rp->r_linep = curwp->w_dotp;
X                                rp->r_offset = curwp->w_doto;
X                                rp->r_size = fsize+curwp->w_marko;
X                                return (TRUE);
X                        }
X                        fsize += llength(flp)+1;
X                }
X                if (lback(blp) != curbp->b_linep) {
X                        blp = lback(blp);
X                        bsize += llength(blp)+1;
X                        if (blp == curwp->w_markp) {
X                                rp->r_linep = blp;
X                                rp->r_offset = curwp->w_marko;
X                                rp->r_size = bsize - curwp->w_marko;
X                                return (TRUE);
X                        }
X                }
X        }
X        mlwrite("Bug: lost mark");
X        return (FALSE);
X}
END_OF_region.c
if test 7029 -ne `wc -c <region.c`; then
    echo shar: \"region.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"tipc.c\" \(5241 characters\)
if test -f tipc.c ; then 
  echo shar: Will not over-write existing file \"tipc.c\"
else
sed "s/^X//" >tipc.c <<'END_OF_tipc.c'
X/*
X * The routines in this file provide support for the TI-PC and other
X * compatible terminals. It goes directly to the graphics RAM to do
X * screen output. It compiles into nothing if not a TI-PC driver
X */
X
X#define termdef 1                       /* don't define "term" external */
X
X#include        <stdio.h>
X#include        "estruct.h"
X#include        "edef.h"
X
X#if     TIPC
X
X#define NROW    25                      /* Screen size.                 */
X#define NCOL    80                      /* Edit if you want to.         */
X#define MARGIN  8                       /* size of minimim margin and   */
X#define SCRSIZ  64                      /* scroll size for extended lines */
X#define NPAUSE  200                     /* # times thru update to pause */
X#define BEL     0x07                    /* BEL character.               */
X#define ESC     0x1B                    /* ESC character.               */
X#define SPACE   32                      /* space character              */
X#define SCADD   0xDE000L                /* address of screen RAM        */
X
X#define CHAR_ENABLE     0x08            /* TI attribute to show char    */
X#define TI_REVERSE      0x10            /* TI attribute to reverse char */
X#define BLACK   0+CHAR_ENABLE           /* TI attribute for Black       */
X#define BLUE    1+CHAR_ENABLE           /* TI attribute for Blue        */
X#define RED     2+CHAR_ENABLE           /* TI attribute for Red         */
X#define MAGENTA 3+CHAR_ENABLE           /* TI attribute for Magenta     */
X#define GREEN   4+CHAR_ENABLE           /* TI attribute for Green       */
X#define CYAN    5+CHAR_ENABLE           /* TI attribute for Cyan        */
X#define YELLOW  6+CHAR_ENABLE           /* TI attribute for Yellow      */
X#define WHITE   7+CHAR_ENABLE           /* TI attribute for White       */
X
X
Xextern  int     ttopen();               /* Forward references.          */
Xextern  int     ttgetc();
Xextern  int     ttputc();
Xextern  int     ttflush();
Xextern  int     ttclose();
Xextern  int     timove();
Xextern  int     tieeol();
Xextern  int     tieeop();
Xextern  int     tibeep();
Xextern  int     tiopen();
Xextern  int     tirev();
Xextern	int	ticres();
Xextern  int     ticlose();
Xextern  int     tiputc();
X
X#if     COLOR
Xextern  int     tifcol();
Xextern  int     tibcol();
X
Xint     cfcolor = -1;           /* current forground color */
Xint     cbcolor = -1;           /* current background color */
Xint     ctrans[] =              /* ansi to ti color translation table */
X        {BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE};
X#endif
X
X/*
X * Standard terminal interface dispatch table. Most of the fields point into
X * "termio" code.
X */
XTERM    term    = {
X	NROW-1,
X        NROW-1,
X        NCOL,
X        NCOL,
X        MARGIN,
X        SCRSIZ,
X        NPAUSE,
X        tiopen,
X        ticlose,
X        ttgetc,
X        tiputc,
X        ttflush,
X        timove,
X        tieeol,
X        tieeop,
X        tibeep,
X        tirev,
X        ticres
X#if     COLOR
X        , tifcol,
X        tibcol
X#endif
X};
X
Xextern union REGS rg;
X
X#if     COLOR
Xsetatt( attr )
Xint attr;
X{
X        rg.h.ah = 0x16;         /* set the forground character attribute */
X        rg.h.bl = attr;
X        int86( 0x49, &rg, &rg );
X}
X
Xtifcol(color)           /* set the current output color */
X
Xint color;      /* color to set */
X
X{
X        cfcolor = ctrans[color];
X        setatt ( cfcolor );
X}
X
Xtibcol(color)           /* set the current background color */
X
Xint color;      /* color to set */
X
X{
X        cbcolor = ctrans[color];
X}
X#endif
X
Xtimove(row, col)
X{
X        rg.h.ah = 2;            /* set cursor position function code */
X        rg.h.dh = col;
X        rg.h.dl = row;
X        int86(0x49, &rg, &rg);
X}
X
Xtieeol()        /* erase to the end of the line */
X
X{
X        int ccol;       /* current column cursor lives */
X        int crow;       /*         row  */
X
X        /* find the current cursor position */
X        rg.h.ah = 3;            /* read cursor position function code */
X        int86(0x49, &rg, &rg);
X        ccol = rg.h.dh;         /* record current column */
X        crow = rg.h.dl;         /* and row */
X
X        rg.h.ah = 0x09;         /* Write character at cursor position */
X        rg.h.al = ' ';          /* Space */
X        rg.h.bl = cfcolor;
X        rg.x.cx = NCOL-ccol;    /* Number of characters to write */
X        int86(0x49, &rg, &rg);
X
X}
X
Xtiputc(ch)      /* put a character at the current position in the
X                   current colors */
X
Xint ch;
X
X{
X        rg.h.ah = 0x0E;         /* write char to screen with current attrs */
X        rg.h.al = ch;
X        int86(0x49, &rg, &rg);
X}
X
Xtieeop()                        /* Actually a clear screen */
X{
X
X        rg.h.ah = 0x13;         /* Clear Text Screen and Home Cursor */
X        int86(0x49, &rg, &rg);
X}
X
Xtirev(state)            /* change reverse video state */
X
Xint state;      /* TRUE = reverse, FALSE = normal */
X
X{
X        setatt( state ? cbcolor : cfcolor  );
X}
X
Xticres()	/* change screen resolution */
X
X{
X	return(TRUE);
X}
X
Xtibeep()
X{
X        bdos(6, BEL, 0);
X}
X
Xtiopen()
X{
X	strcpy(sres, "NORMAL");
X        revexist = TRUE;
X        ttopen();
X}
X
Xticlose()
X
X{
X#if     COLOR
X        tifcol(7);
X        tibcol(0);
X#endif
X        ttclose();
X}
X#else
Xtihello()
X{
X}
X#endif
X
END_OF_tipc.c
if test 5241 -ne `wc -c <tipc.c`; then
    echo shar: \"tipc.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"vmsvt.c\" \(6331 characters\)
if test -f vmsvt.c ; then 
  echo shar: Will not over-write existing file \"vmsvt.c\"
else
sed "s/^X//" >vmsvt.c <<'END_OF_vmsvt.c'
X/*
X *  VMS terminal handling routines
X *
X *  Known types are:
X *    VT52, VT100, and UNKNOWN (which is defined to be an ADM3a)
X *    written by Curtis Smith
X */
X
X#include        <stdio.h>
X#include        "estruct.h"
X#include	"edef.h"
X
X#if     VMSVT
X
X#define	termdef	1			/* don't define "term" external */
X
X#include <ssdef.h>		/* Status code definitions		*/
X#include <descrip.h>		/* Descriptor structures		*/
X#include <iodef.h>		/* IO commands				*/
X#include <ttdef.h>		/* tty commands				*/
X
Xextern  int     ttopen();               /* Forward references.          */
Xextern  int     ttgetc();
Xextern  int     ttputc();
Xextern  int     ttflush();
Xextern  int     ttclose();
Xextern  int	vmsopen();
Xextern	int	vmskopen();
Xextern	int	vmskclose();
Xextern  int	vmseeol();
Xextern  int	vmseeop();
Xextern  int	vmsbeep();
Xextern  int	vmsmove();
Xextern	int	vmsrev();
Xextern	int	vmscres();
Xextern  int	eolexist;
X#if	COLOR
Xextern	int	vmsfcol();
Xextern	int	vmsbcol();
X#endif
X
X#define	NROWS	24			/* # of screen rolls		*/
X#define	NCOLS	80			/* # of screen columns		*/
X#define	MARGIN	8			/* size of minimim margin and	*/
X#define	SCRSIZ	64			/* scroll size for extended lines */
X#define	NPAUSE	100			/* # times thru update to pause */
X
X/*
X * Dispatch table. All the
X * hard fields just point into the
X * terminal I/O code.
X */
XTERM    term    = {
X	NROWS - 1,
X	NROWS - 1,
X	NCOLS,
X	NCOLS,
X	MARGIN,
X	SCRSIZ,
X	NPAUSE,
X        &vmsopen,
X        &ttclose,
X	&vmskopen,
X	&vmskclose,
X        &ttgetc,
X        &ttputc,
X        &ttflush,
X        &vmsmove,
X        &vmseeol,
X        &vmseeop,
X        &vmsbeep,
X        &vmsrev,
X        &vmscres
X#if	COLOR
X	, &vmsfcol,
X	&vmsbcol
X#endif
X};
X
Xchar * termeop;			/* Erase to end of page string		*/
Xint eoppad;			/* Number of pad characters after eop	*/
Xchar * termeol;			/* Erase to end of line string		*/
Xint eolpad;			/* Number of pad characters after eol	*/
Xchar termtype;			/* Terminal type identifier		*/
X
X
X/*******
X *  ttputs - Send a string to ttputc
X *******/
X
Xttputs(string)
Xchar * string;
X{
X	while (*string != '\0')
X		ttputc(*string++);
X}
X
X
X/*******
X *  vmspad - Pad the output after an escape sequence
X *******/
X
Xvmspad(count)
Xint count;
X{
X	while (count-- > 0)
X		ttputc('\0');
X}
X
X
X/*******
X *  vmsmove - Move the cursor
X *******/
X
Xvmsmove(row, col)
X{
X	switch (termtype) {
X		case TT$_UNKNOWN:
X			ttputc('\033');
X			ttputc('=');
X			ttputc(row+' ');
X			ttputc(col+' ');
X			break;
X		case TT$_VT52:
X			ttputc('\033');
X			ttputc('Y');
X			ttputc(row+' ');
X			ttputc(col+' ');
X			break;
X                case TT$_VT100:         /* I'm assuming that all these  */
X                case TT$_VT101:         /* are a super set of the VT100 */
X                case TT$_VT102:         /* If I'm wrong, just remove    */
X                case TT$_VT105:         /* those entries that aren't.   */
X                case TT$_VT125:
X                case TT$_VT131:
X                case TT$_VT132:
X                case TT$_VT200_SERIES:
X			{
X				char buffer[24];
X
X				sprintf(buffer, "\033[%d;%dH", row+1, col+1);
X				ttputs(buffer);
X				vmspad(50);
X			}
X	}
X}
X
X/*******
X *  vmsrev - set the reverse video status
X *******/
X
Xvmsrev(status)
X
Xint status;	/* TRUE = reverse video, FALSE = normal video */
X{
X	switch (termtype) {
X		case TT$_UNKNOWN:
X			break;
X		case TT$_VT52:
X			break;
X		case TT$_VT100:
X			if (status) {
X				ttputc('\033');
X				ttputc('[');
X				ttputc('7');
X				ttputc('m');
X			} else {
X				ttputc('\033');
X				ttputc('[');
X				ttputc('m');
X			}
X			break;
X	}
X}
X
X/*******
X *  vmscres - Change screen resolution (which it doesn't)
X *******/
X
Xvmscres()
X
X{
X	return(TRUE);
X}
X
X#if	COLOR
X/*******
X *  vmsfcol - Set the forground color (not implimented)
X *******/
X 
Xvmsfcol()
X{
X}
X
X/*******
X *  vmsbcol - Set the background color (not implimented)
X *******/
X 
Xvmsbcol()
X{
X}
X#endif
X
X/*******
X *  vmseeol - Erase to end of line
X *******/
X
Xvmseeol()
X{
X	ttputs(termeol);
X	vmspad(eolpad);
X}
X
X
X/*******
X *  vmseeop - Erase to end of page (clear screen)
X *******/
X
Xvmseeop()
X{
X	ttputs(termeop);
X	vmspad(eoppad);
X}
X
X
X/*******
X *  vmsbeep - Ring the bell
X *******/
X
Xvmsbeep()
X{
X	ttputc('\007');
X}
X
X
X/*******
X *  vmsopen - Get terminal type and open terminal
X *******/
X
Xvmsopen()
X{
X	termtype = vmsgtty();
X	switch (termtype) {
X		case TT$_UNKNOWN:	/* Assume ADM3a	*/
X			eolexist = FALSE;
X			termeop = "\032";
X			eoppad = 0;
X			break;
X		case TT$_VT52:
X			termeol = "\033K";
X			eolpad = 0;
X			termeop = "\033H\033J";
X			eoppad = 0;
X			break;
X		case TT$_VT100:
X			revexist = TRUE;
X			termeol = "\033[K";
X			eolpad = 3;
X			termeop = "\033[;H\033[2J";
X			eoppad = 50;
X			break;
X		default:
X			puts("Terminal type not supported");
X			exit (SS$_NORMAL);
X	}
X	strcpy(sres, "NORMAL");
X        ttopen();
X}
X
X
Xstruct iosb {			/* I/O status block			*/
X	short	i_cond;		/* Condition value			*/
X	short	i_xfer;		/* Transfer count			*/
X	long	i_info;		/* Device information			*/
X};
X
Xstruct termchar {		/* Terminal characteristics		*/
X	char	t_class;	/* Terminal class			*/
X	char	t_type;		/* Terminal type			*/
X	short	t_width;	/* Terminal width in characters		*/
X	long	t_mandl;	/* Terminal's mode and length		*/
X	long	t_extend;	/* Extended terminal characteristics	*/
X};
X
X/*******
X *  vmsgtty - Get terminal type from system control block
X *******/
X
Xvmsgtty()
X{
X	short fd;
X	int status;
X	struct iosb iostatus;
X	struct termchar tc;
X	$DESCRIPTOR(devnam, "SYS$INPUT");
X
X	status = sys$assign(&devnam, &fd, 0, 0);
X	if (status != SS$_NORMAL)
X		exit (status);
X
X	status = sys$qiow(		/* Queue and wait		*/
X		0,			/* Wait on event flag zero	*/
X		fd,			/* Channel to input terminal	*/
X		IO$_SENSEMODE,		/* Get current characteristic	*/
X		&iostatus,		/* Status after operation	*/
X		0, 0,			/* No AST service		*/
X		&tc,			/* Terminal characteristics buf	*/
X		sizeof(tc),		/* Size of the buffer		*/
X		0, 0, 0, 0);		/* P3-P6 unused			*/
X
X					/* De-assign the input device	*/
X	if (sys$dassgn(fd) != SS$_NORMAL)
X		exit(status);
X
X	if (status != SS$_NORMAL)	/* Jump out if bad status	*/
X		exit(status);
X	if (iostatus.i_cond != SS$_NORMAL)
X		exit(iostatus.i_cond);
X
X	return tc.t_type;		/* Return terminal type		*/
X}
X
Xvmskopen()
X
X{
X}
X
Xvmskclose()
X
X{
X}
X
X#if	FLABEL
Xfnclabel(f, n)		/* label a function key */
X
Xint f,n;	/* default flag, numeric argument [unused] */
X
X{
X	/* on machines with no function keys...don't bother */
X	return(TRUE);
X}
X#endif
X#else
X
Xhellovms()
X
X{
X}
X
X#endif	VMSVT
END_OF_vmsvt.c
if test 6331 -ne `wc -c <vmsvt.c`; then
    echo shar: \"vmsvt.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 2 \(of 14\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    echo "See the readme file"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
