Subject:  v09i042:  MicroEMACS, version 3.8b, Part10/14
Newsgroups: mod.sources
Approved: rs@mirror.TMC.COM

Submitted by: ihnp4!itivax!duncan!lawrence (Daniel Lawrence)
Mod.sources: Volume 9, Issue 42
Archive-name: uemacs3.8b/Part10

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If this archive is complete, you will see the message:
#		"End of archive 10 (of 14)."
# Contents:  line.c random.c
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"line.c\" \(18858 characters\)
if test -f line.c ; then 
  echo shar: Will not over-write existing file \"line.c\"
else
sed "s/^X//" >line.c <<'END_OF_line.c'
X/*
X * The functions in this file are a general set of line management utilities.
X * They are the only routines that touch the text. They also touch the buffer
X * and window structures, to make sure that the necessary updating gets done.
X * There are routines in this file that handle the kill buffer too. It isn't
X * here for any good reason.
X *
X * Note that this code only updates the dot and mark values in the window list.
X * Since all the code acts on the current window, the buffer that we are
X * editing must be being displayed, which means that "b_nwnd" is non zero,
X * which means that the dot and mark values in the buffer headers are nonsense.
X */
X
X#include        <stdio.h>
X#include	"estruct.h"
X#include        "edef.h"
X
X#if	MEGAMAX
Xoverlay "line"
X#endif
X
XKILL *ykbuf;	/* ptr to current kill buffer chunk being yanked */
Xint ykboff;	/* offset into that chunk */
X
X/*
X * This routine allocates a block of memory large enough to hold a LINE
X * containing "used" characters. The block is always rounded up a bit. Return
X * a pointer to the new block, or NULL if there isn't any memory left. Print a
X * message in the message line if no space.
X */
XLINE    *
Xlalloc(used)
Xregister int    used;
X{
X        register LINE   *lp;
X        register int    size;
X	char *malloc();
X
X        size = (used+NBLOCK-1) & ~(NBLOCK-1);
X        if (size == 0)                          /* Assume that an empty */
X                size = NBLOCK;                  /* line is for type-in. */
X        if ((lp = (LINE *) malloc(sizeof(LINE)+size)) == NULL) {
X                mlwrite("Cannot allocate %d bytes", size);
X                return (NULL);
X        }
X        lp->l_size = size;
X        lp->l_used = used;
X        return (lp);
X}
X
X/*
X * Delete line "lp". Fix all of the links that might point at it (they are
X * moved to offset 0 of the next line. Unlink the line from whatever buffer it
X * might be in. Release the memory. The buffers are updated too; the magic
X * conditions described in the above comments don't hold here.
X */
Xlfree(lp)
Xregister LINE   *lp;
X{
X        register BUFFER *bp;
X        register WINDOW *wp;
X
X        wp = wheadp;
X        while (wp != NULL) {
X                if (wp->w_linep == lp)
X                        wp->w_linep = lp->l_fp;
X                if (wp->w_dotp  == lp) {
X                        wp->w_dotp  = lp->l_fp;
X                        wp->w_doto  = 0;
X                }
X                if (wp->w_markp == lp) {
X                        wp->w_markp = lp->l_fp;
X                        wp->w_marko = 0;
X                }
X                wp = wp->w_wndp;
X        }
X        bp = bheadp;
X        while (bp != NULL) {
X                if (bp->b_nwnd == 0) {
X                        if (bp->b_dotp  == lp) {
X                                bp->b_dotp = lp->l_fp;
X                                bp->b_doto = 0;
X                        }
X                        if (bp->b_markp == lp) {
X                                bp->b_markp = lp->l_fp;
X                                bp->b_marko = 0;
X                        }
X                }
X                bp = bp->b_bufp;
X        }
X        lp->l_bp->l_fp = lp->l_fp;
X        lp->l_fp->l_bp = lp->l_bp;
X        free((char *) lp);
X}
X
X/*
X * This routine gets called when a character is changed in place in the current
X * buffer. It updates all of the required flags in the buffer and window
X * system. The flag used is passed as an argument; if the buffer is being
X * displayed in more than 1 window we change EDIT t HARD. Set MODE if the
X * mode line needs to be updated (the "*" has to be set).
X */
Xlchange(flag)
Xregister int    flag;
X{
X        register WINDOW *wp;
X
X        if (curbp->b_nwnd != 1)                 /* Ensure hard.         */
X                flag = WFHARD;
X        if ((curbp->b_flag&BFCHG) == 0) {       /* First change, so     */
X                flag |= WFMODE;                 /* update mode lines.   */
X                curbp->b_flag |= BFCHG;
X        }
X        wp = wheadp;
X        while (wp != NULL) {
X                if (wp->w_bufp == curbp)
X                        wp->w_flag |= flag;
X                wp = wp->w_wndp;
X        }
X}
X
Xinsspace(f, n)	/* insert spaces forward into text */
X
Xint f, n;	/* default flag and numeric argument */
X
X{
X	linsert(n, ' ');
X	backchar(f, n);
X}
X
X/*
X * Insert "n" copies of the character "c" at the current location of dot. In
X * the easy case all that happens is the text is stored in the line. In the
X * hard case, the line has to be reallocated. When the window list is updated,
X * take special care; I screwed it up once. You always update dot in the
X * current window. You update mark, and a dot in another window, if it is
X * greater than the place where you did the insert. Return TRUE if all is
X * well, and FALSE on errors.
X */
Xlinsert(n, c)
X{
X        register char   *cp1;
X        register char   *cp2;
X        register LINE   *lp1;
X        register LINE   *lp2;
X        register LINE   *lp3;
X        register int    doto;
X        register int    i;
X        register WINDOW *wp;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        lchange(WFEDIT);
X        lp1 = curwp->w_dotp;                    /* Current line         */
X        if (lp1 == curbp->b_linep) {            /* At the end: special  */
X                if (curwp->w_doto != 0) {
X                        mlwrite("bug: linsert");
X                        return (FALSE);
X                }
X                if ((lp2=lalloc(n)) == NULL)    /* Allocate new line    */
X                        return (FALSE);
X                lp3 = lp1->l_bp;                /* Previous line        */
X                lp3->l_fp = lp2;                /* Link in              */
X                lp2->l_fp = lp1;
X                lp1->l_bp = lp2;
X                lp2->l_bp = lp3;
X                for (i=0; i<n; ++i)
X                        lp2->l_text[i] = c;
X                curwp->w_dotp = lp2;
X                curwp->w_doto = n;
X                return (TRUE);
X        }
X        doto = curwp->w_doto;                   /* Save for later.      */
X        if (lp1->l_used+n > lp1->l_size) {      /* Hard: reallocate     */
X                if ((lp2=lalloc(lp1->l_used+n)) == NULL)
X                        return (FALSE);
X                cp1 = &lp1->l_text[0];
X                cp2 = &lp2->l_text[0];
X                while (cp1 != &lp1->l_text[doto])
X                        *cp2++ = *cp1++;
X                cp2 += n;
X                while (cp1 != &lp1->l_text[lp1->l_used])
X                        *cp2++ = *cp1++;
X                lp1->l_bp->l_fp = lp2;
X                lp2->l_fp = lp1->l_fp;
X                lp1->l_fp->l_bp = lp2;
X                lp2->l_bp = lp1->l_bp;
X                free((char *) lp1);
X        } else {                                /* Easy: in place       */
X                lp2 = lp1;                      /* Pretend new line     */
X                lp2->l_used += n;
X                cp2 = &lp1->l_text[lp1->l_used];
X                cp1 = cp2-n;
X                while (cp1 != &lp1->l_text[doto])
X                        *--cp2 = *--cp1;
X        }
X        for (i=0; i<n; ++i)                     /* Add the characters   */
X                lp2->l_text[doto+i] = c;
X        wp = wheadp;                            /* Update windows       */
X        while (wp != NULL) {
X                if (wp->w_linep == lp1)
X                        wp->w_linep = lp2;
X                if (wp->w_dotp == lp1) {
X                        wp->w_dotp = lp2;
X                        if (wp==curwp || wp->w_doto>doto)
X                                wp->w_doto += n;
X                }
X                if (wp->w_markp == lp1) {
X                        wp->w_markp = lp2;
X                        if (wp->w_marko > doto)
X                                wp->w_marko += n;
X                }
X                wp = wp->w_wndp;
X        }
X        return (TRUE);
X}
X
X/*
X * Insert a newline into the buffer at the current location of dot in the
X * current window. The funny ass-backwards way it does things is not a botch;
X * it just makes the last line in the file not a special case. Return TRUE if
X * everything works out and FALSE on error (memory allocation failure). The
X * update of dot and mark is a bit easier then in the above case, because the
X * split forces more updating.
X */
Xlnewline()
X{
X        register char   *cp1;
X        register char   *cp2;
X        register LINE   *lp1;
X        register LINE   *lp2;
X        register int    doto;
X        register WINDOW *wp;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        lchange(WFHARD);
X        lp1  = curwp->w_dotp;                   /* Get the address and  */
X        doto = curwp->w_doto;                   /* offset of "."        */
X        if ((lp2=lalloc(doto)) == NULL)         /* New first half line  */
X                return (FALSE);
X        cp1 = &lp1->l_text[0];                  /* Shuffle text around  */
X        cp2 = &lp2->l_text[0];
X        while (cp1 != &lp1->l_text[doto])
X                *cp2++ = *cp1++;
X        cp2 = &lp1->l_text[0];
X        while (cp1 != &lp1->l_text[lp1->l_used])
X                *cp2++ = *cp1++;
X        lp1->l_used -= doto;
X        lp2->l_bp = lp1->l_bp;
X        lp1->l_bp = lp2;
X        lp2->l_bp->l_fp = lp2;
X        lp2->l_fp = lp1;
X        wp = wheadp;                            /* Windows              */
X        while (wp != NULL) {
X                if (wp->w_linep == lp1)
X                        wp->w_linep = lp2;
X                if (wp->w_dotp == lp1) {
X                        if (wp->w_doto < doto)
X                                wp->w_dotp = lp2;
X                        else
X                                wp->w_doto -= doto;
X                }
X                if (wp->w_markp == lp1) {
X                        if (wp->w_marko < doto)
X                                wp->w_markp = lp2;
X                        else
X                                wp->w_marko -= doto;
X                }
X                wp = wp->w_wndp;
X        }
X        return (TRUE);
X}
X
X/*
X * This function deletes "n" bytes, starting at dot. It understands how do deal
X * with end of lines, etc. It returns TRUE if all of the characters were
X * deleted, and FALSE if they were not (because dot ran into the end of the
X * buffer. The "kflag" is TRUE if the text should be put in the kill buffer.
X */
Xldelete(n, kflag)
X
Xlong n;		/* # of chars to delete */
Xint kflag;	/* put killed text in kill buffer flag */
X
X{
X        register char   *cp1;
X        register char   *cp2;
X        register LINE   *dotp;
X        register int    doto;
X        register int    chunk;
X        register WINDOW *wp;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        while (n != 0) {
X                dotp = curwp->w_dotp;
X                doto = curwp->w_doto;
X                if (dotp == curbp->b_linep)     /* Hit end of buffer.   */
X                        return (FALSE);
X                chunk = dotp->l_used-doto;      /* Size of chunk.       */
X                if (chunk > n)
X                        chunk = n;
X                if (chunk == 0) {               /* End of line, merge.  */
X                        lchange(WFHARD);
X                        if (ldelnewline() == FALSE
X                        || (kflag!=FALSE && kinsert('\n')==FALSE))
X                                return (FALSE);
X                        --n;
X                        continue;
X                }
X                lchange(WFEDIT);
X                cp1 = &dotp->l_text[doto];      /* Scrunch text.        */
X                cp2 = cp1 + chunk;
X                if (kflag != FALSE) {           /* Kill?                */
X                        while (cp1 != cp2) {
X                                if (kinsert(*cp1) == FALSE)
X                                        return (FALSE);
X                                ++cp1;
X                        }
X                        cp1 = &dotp->l_text[doto];
X                }
X                while (cp2 != &dotp->l_text[dotp->l_used])
X                        *cp1++ = *cp2++;
X                dotp->l_used -= chunk;
X                wp = wheadp;                    /* Fix windows          */
X                while (wp != NULL) {
X                        if (wp->w_dotp==dotp && wp->w_doto>=doto) {
X                                wp->w_doto -= chunk;
X                                if (wp->w_doto < doto)
X                                        wp->w_doto = doto;
X                        }
X                        if (wp->w_markp==dotp && wp->w_marko>=doto) {
X                                wp->w_marko -= chunk;
X                                if (wp->w_marko < doto)
X                                        wp->w_marko = doto;
X                        }
X                        wp = wp->w_wndp;
X                }
X                n -= chunk;
X        }
X        return (TRUE);
X}
X
X/*
X * Delete a newline. Join the current line with the next line. If the next line
X * is the magic header line always return TRUE; merging the last line with the
X * header line can be thought of as always being a successful operation, even
X * if nothing is done, and this makes the kill buffer work "right". Easy cases
X * can be done by shuffling data around. Hard cases require that lines be moved
X * about in memory. Return FALSE on error and TRUE if all looks ok. Called by
X * "ldelete" only.
X */
Xldelnewline()
X{
X        register char   *cp1;
X        register char   *cp2;
X        register LINE   *lp1;
X        register LINE   *lp2;
X        register LINE   *lp3;
X        register WINDOW *wp;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        lp1 = curwp->w_dotp;
X        lp2 = lp1->l_fp;
X        if (lp2 == curbp->b_linep) {            /* At the buffer end.   */
X                if (lp1->l_used == 0)           /* Blank line.          */
X                        lfree(lp1);
X                return (TRUE);
X        }
X        if (lp2->l_used <= lp1->l_size-lp1->l_used) {
X                cp1 = &lp1->l_text[lp1->l_used];
X                cp2 = &lp2->l_text[0];
X                while (cp2 != &lp2->l_text[lp2->l_used])
X                        *cp1++ = *cp2++;
X                wp = wheadp;
X                while (wp != NULL) {
X                        if (wp->w_linep == lp2)
X                                wp->w_linep = lp1;
X                        if (wp->w_dotp == lp2) {
X                                wp->w_dotp  = lp1;
X                                wp->w_doto += lp1->l_used;
X                        }
X                        if (wp->w_markp == lp2) {
X                                wp->w_markp  = lp1;
X                                wp->w_marko += lp1->l_used;
X                        }
X                        wp = wp->w_wndp;
X                }
X                lp1->l_used += lp2->l_used;
X                lp1->l_fp = lp2->l_fp;
X                lp2->l_fp->l_bp = lp1;
X                free((char *) lp2);
X                return (TRUE);
X        }
X        if ((lp3=lalloc(lp1->l_used+lp2->l_used)) == NULL)
X                return (FALSE);
X        cp1 = &lp1->l_text[0];
X        cp2 = &lp3->l_text[0];
X        while (cp1 != &lp1->l_text[lp1->l_used])
X                *cp2++ = *cp1++;
X        cp1 = &lp2->l_text[0];
X        while (cp1 != &lp2->l_text[lp2->l_used])
X                *cp2++ = *cp1++;
X        lp1->l_bp->l_fp = lp3;
X        lp3->l_fp = lp2->l_fp;
X        lp2->l_fp->l_bp = lp3;
X        lp3->l_bp = lp1->l_bp;
X        wp = wheadp;
X        while (wp != NULL) {
X                if (wp->w_linep==lp1 || wp->w_linep==lp2)
X                        wp->w_linep = lp3;
X                if (wp->w_dotp == lp1)
X                        wp->w_dotp  = lp3;
X                else if (wp->w_dotp == lp2) {
X                        wp->w_dotp  = lp3;
X                        wp->w_doto += lp1->l_used;
X                }
X                if (wp->w_markp == lp1)
X                        wp->w_markp  = lp3;
X                else if (wp->w_markp == lp2) {
X                        wp->w_markp  = lp3;
X                        wp->w_marko += lp1->l_used;
X                }
X                wp = wp->w_wndp;
X        }
X        free((char *) lp1);
X        free((char *) lp2);
X        return (TRUE);
X}
X
X/*
X * Delete all of the text saved in the kill buffer. Called by commands when a
X * new kill context is being created. The kill buffer array is released, just
X * in case the buffer has grown to immense size. No errors.
X */
Xkdelete()
X{
X	KILL *kp;	/* ptr to scan kill buffer chunk list */
X
X        if (kbufh != NULL) {
X
X		/* first, delete all the chunks */
X        	kbufp = kbufh;
X        	while (kbufp != NULL) {
X        		kp = kbufp->d_next;
X        		free(kbufp);
X        		kbufp = kp;
X        	}
X
X		/* and reset all the kill buffer pointers */
X		kbufh = kbufp = NULL;
X		kused = KBLOCK;        		
X        }
X}
X
X/*
X * Insert a character to the kill buffer, allocating new chunks as needed.
X * Return TRUE if all is well, and FALSE on errors.
X */
X
Xkinsert(c)
X
Xint c;		/* character to insert in the kill buffer */
X
X{
X	KILL *nchunk;	/* ptr to newly malloced chunk */
X
X	/* check to see if we need a new chunk */
X	if (kused >= KBLOCK) {
X		if ((nchunk = (KILL *)malloc(sizeof(KILL))) == NULL)
X			return(FALSE);
X		if (kbufh == NULL)	/* set head ptr if first time */
X			kbufh = nchunk;
X		if (kbufp != NULL)	/* point the current to this new one */
X			kbufp->d_next = nchunk;
X		kbufp = nchunk;
X		kbufp->d_next = NULL;
X		kused = 0;
X	}
X
X	/* and now insert the character */
X	kbufp->d_chunk[kused++] = c;
X	return(TRUE);
X}
X
X/*
X * Yank text back from the kill buffer. This is really easy. All of the work
X * is done by the standard insert routines. All you do is run the loop, and
X * check for errors. Bound to "C-Y".
X */
Xyank(f, n)
X{
X        register int    c;
X        register int    i;
X	register char	*sp;	/* pointer into string to insert */
X	KILL *kp;		/* pointer into kill buffer */
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        if (n < 0)
X                return (FALSE);
X	/* make sure there is something to yank */
X	if (kbufh == NULL)
X		return(TRUE);		/* not an error, just nothing */
X
X	/* for each time.... */
X        while (n--) {
X		kp = kbufh;
X		while (kp != NULL) {
X			if (kp->d_next == NULL)
X				i = kused;
X			else
X				i = KBLOCK;
X			sp = kp->d_chunk;
X			while (i--) {
X	                        if ((c = *sp++) == '\n') {
X        	                        if (lnewline(FALSE, 1) == FALSE)
X                	                        return (FALSE);
X	                        } else {
X        	                        if (linsert(1, c) == FALSE)
X                	                        return (FALSE);
X	                        }
X	                }
X	                kp = kp->d_next;
X                }
X        }
X        return (TRUE);
X}
X
X
END_OF_line.c
if test 18858 -ne `wc -c <line.c`; then
    echo shar: \"line.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"random.c\" \(23797 characters\)
if test -f random.c ; then 
  echo shar: Will not over-write existing file \"random.c\"
else
sed "s/^X//" >random.c <<'END_OF_random.c'
X/*
X * This file contains the command processing functions for a number of random
X * commands. There is no functional grouping here, for sure.
X */
X
X#include        <stdio.h>
X#include	"estruct.h"
X#include        "edef.h"
X
X#if	MEGAMAX & ST520
Xoverlay "random"
X
Xextern int STncolors;
X#endif
X
Xint     tabsize;                        /* Tab size (0: use real tabs)  */
X
X/*
X * Set fill column to n.
X */
Xsetfillcol(f, n)
X{
X        fillcol = n;
X	mlwrite("[Fill column is %d]",n);
X        return(TRUE);
X}
X
X/*
X * Display the current position of the cursor, in origin 1 X-Y coordinates,
X * the character that is under the cursor (in hex), and the fraction of the
X * text that is before the cursor. The displayed column is not the current
X * column, but the column that would be used on an infinite width display.
X * Normally this is bound to "C-X =".
X */
Xshowcpos(f, n)
X{
X        register LINE   *lp;		/* current line */
X        register long   numchars;	/* # of chars in file */
X        register int	numlines;	/* # of lines in file */
X        register long   predchars;	/* # chars preceding point */
X        register int	predlines;	/* # lines preceding point */
X        register int    curchar;	/* character under cursor */
X        int ratio;
X        int col;
X	int savepos;			/* temp save for current offset */
X	int ecol;			/* column pos/end of current line */
X
X	/* starting at the beginning of the buffer */
X        lp = lforw(curbp->b_linep);
X
X	/* start counting chars and lines */
X        numchars = 0;
X        numlines = 0;
X        while (lp != curbp->b_linep) {
X		/* if we are on the current line, record it */
X		if (lp == curwp->w_dotp) {
X			predlines = numlines;
X			predchars = numchars + curwp->w_doto;
X			if ((curwp->w_doto) == llength(lp))
X				curchar = '\n';
X			else
X				curchar = lgetc(lp, curwp->w_doto);
X		}
X		/* on to the next line */
X		++numlines;
X		numchars += llength(lp) + 1;
X		lp = lforw(lp);
X        }
X
X	/* if at end of file, record it */
X	if (curwp->w_dotp == curbp->b_linep) {
X		predlines = numlines;
X		predchars = numchars;
X	}
X
X	/* Get real column and end-of-line column. */
X	col = getccol(FALSE);
X	savepos = curwp->w_doto;
X	curwp->w_doto = llength(curwp->w_dotp);
X	ecol = getccol(FALSE);
X	curwp->w_doto = savepos;
X
X        ratio = 0;              /* Ratio before dot. */
X        if (numchars != 0)
X                ratio = (100L*predchars) / numchars;
X
X	/* summarize and report the info */
X	mlwrite("Line %d/%d Col %d/%d Char %D/%D (%d%%) char = 0x%x",
X		predlines+1, numlines+1, col, ecol,
X		predchars, numchars, ratio, curchar);
X        return (TRUE);
X}
X
Xgetcline()	/* get the current line number */
X
X{
X        register LINE   *lp;		/* current line */
X        register int	numlines;	/* # of lines before point */
X
X	/* starting at the beginning of the buffer */
X        lp = lforw(curbp->b_linep);
X
X	/* start counting lines */
X        numlines = 0;
X        while (lp != curbp->b_linep) {
X		/* if we are on the current line, record it */
X		if (lp == curwp->w_dotp)
X			break;
X		++numlines;
X		lp = lforw(lp);
X        }
X
X	/* and return the resulting count */
X	return(numlines + 1);
X}
X
X/*
X * Return current column.  Stop at first non-blank given TRUE argument.
X */
Xgetccol(bflg)
Xint bflg;
X{
X        register int c, i, col;
X        col = 0;
X        for (i=0; i<curwp->w_doto; ++i) {
X                c = lgetc(curwp->w_dotp, i);
X                if (c!=' ' && c!='\t' && bflg)
X                        break;
X                if (c == '\t')
X                        col |= 0x07;
X                else if (c<0x20 || c==0x7F)
X                        ++col;
X                ++col;
X        }
X        return(col);
X}
X
X/*
X * Set current column.
X */
Xsetccol(pos)
X
Xint pos;	/* position to set cursor */
X
X{
X        register int c;		/* character being scanned */
X	register int i;		/* index into current line */
X	register int col;	/* current cursor column   */
X	register int llen;	/* length of line in bytes */
X
X	col = 0;
X	llen = llength(curwp->w_dotp);
X
X	/* scan the line until we are at or past the target column */
X	for (i = 0; i < llen; ++i) {
X		/* upon reaching the target, drop out */
X		if (col >= pos)
X			break;
X
X		/* advance one character */
X                c = lgetc(curwp->w_dotp, i);
X                if (c == '\t')
X                        col |= 0x07;
X                else if (c<0x20 || c==0x7F)
X                        ++col;
X                ++col;
X        }
X	/* if not long enough... */
X	if (col < pos)
X		return(FALSE);
X
X	/* otherwise...set us at the new position */
X	curwp->w_doto = i;
X	return(TRUE);
X}
X
X/*
X * Twiddle the two characters on either side of dot. If dot is at the end of
X * the line twiddle the two characters before it. Return with an error if dot
X * is at the beginning of line; it seems to be a bit pointless to make this
X * work. This fixes up a very common typo with a single stroke. Normally bound
X * to "C-T". This always works within a line, so "WFEDIT" is good enough.
X */
Xtwiddle(f, n)
X{
X        register LINE   *dotp;
X        register int    doto;
X        register int    cl;
X        register int    cr;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        dotp = curwp->w_dotp;
X        doto = curwp->w_doto;
X        if (doto==llength(dotp) && --doto<0)
X                return (FALSE);
X        cr = lgetc(dotp, doto);
X        if (--doto < 0)
X                return (FALSE);
X        cl = lgetc(dotp, doto);
X        lputc(dotp, doto+0, cr);
X        lputc(dotp, doto+1, cl);
X        lchange(WFEDIT);
X        return (TRUE);
X}
X
X/*
X * Quote the next character, and insert it into the buffer. All the characters
X * are taken literally, with the exception of the newline, which always has
X * its line splitting meaning. The character is always read, even if it is
X * inserted 0 times, for regularity. Bound to "C-Q"
X */
Xquote(f, n)
X{
X        register int    s;
X        register int    c;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        c = tgetc();
X        if (n < 0)
X                return (FALSE);
X        if (n == 0)
X                return (TRUE);
X        if (c == '\n') {
X                do {
X                        s = lnewline();
X                } while (s==TRUE && --n);
X                return (s);
X        }
X        return (linsert(n, c));
X}
X
X/*
X * Set tab size if given non-default argument (n <> 1).  Otherwise, insert a
X * tab into file.  If given argument, n, of zero, change to true tabs.
X * If n > 1, simulate tab stop every n-characters using spaces. This has to be
X * done in this slightly funny way because the tab (in ASCII) has been turned
X * into "C-I" (in 10 bit code) already. Bound to "C-I".
X */
Xtab(f, n)
X{
X        if (n < 0)
X                return (FALSE);
X        if (n == 0 || n > 1) {
X                tabsize = n;
X                return(TRUE);
X        }
X        if (! tabsize)
X                return(linsert(1, '\t'));
X        return(linsert(tabsize - (getccol(FALSE) % tabsize), ' '));
X}
X
X/*
X * Open up some blank space. The basic plan is to insert a bunch of newlines,
X * and then back up over them. Everything is done by the subcommand
X * procerssors. They even handle the looping. Normally this is bound to "C-O".
X */
Xopenline(f, n)
X{
X        register int    i;
X        register int    s;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        if (n < 0)
X                return (FALSE);
X        if (n == 0)
X                return (TRUE);
X        i = n;                                  /* Insert newlines.     */
X        do {
X                s = lnewline();
X        } while (s==TRUE && --i);
X        if (s == TRUE)                          /* Then back up overtop */
X                s = backchar(f, n);             /* of them all.         */
X        return (s);
X}
X
X/*
X * Insert a newline. Bound to "C-M". If we are in CMODE, do automatic
X * indentation as specified.
X */
Xnewline(f, n)
X{
X	register int    s;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X	if (n < 0)
X		return (FALSE);
X
X	/* if we are in C mode and this is a default <NL> */
X	if (n == 1 && (curbp->b_mode & MDCMOD) &&
X	    curwp->w_dotp != curbp->b_linep)
X		return(cinsert());
X
X        /*
X         * If a newline was typed, fill column is defined, the argument is non-
X         * negative, wrap mode is enabled, and we are now past fill column,
X	 * and we are not read-only, perform word wrap.
X         */
X        if ((curwp->w_bufp->b_mode & MDWRAP) && fillcol > 0 &&
X	    getccol(FALSE) > fillcol &&
X	    (curwp->w_bufp->b_mode & MDVIEW) == FALSE)
X		execute(META|SPEC|'W', FALSE, 1);
X
X	/* insert some lines */
X	while (n--) {
X		if ((s=lnewline()) != TRUE)
X			return (s);
X	}
X	return (TRUE);
X}
X
Xcinsert()	/* insert a newline and indentation for C */
X
X{
X	register char *cptr;	/* string pointer into text to copy */
X	register int tptr;	/* index to scan into line */
X	register int bracef;	/* was there a brace at the end of line? */
X	register int i;
X	char ichar[NSTRING];	/* buffer to hold indent of last line */
X
X	/* grab a pointer to text to copy indentation from */
X	cptr = &curwp->w_dotp->l_text[0];
X
X	/* check for a brace */
X	tptr = curwp->w_doto - 1;
X	bracef = (cptr[tptr] == '{');
X
X	/* save the indent of the previous line */
X	i = 0;
X	while ((i < tptr) && (cptr[i] == ' ' || cptr[i] == '\t')
X		&& (i < NSTRING - 1)) {
X		ichar[i] = cptr[i];
X		++i;
X	}
X	ichar[i] = 0;		/* terminate it */
X
X	/* put in the newline */
X	if (lnewline() == FALSE)
X		return(FALSE);
X
X	/* and the saved indentation */
X	i = 0;
X	while (ichar[i])
X		linsert(1, ichar[i++]);
X
X	/* and one more tab for a brace */
X	if (bracef)
X		tab(FALSE, 1);
X
X	return(TRUE);
X}
X
Xinsbrace(n, c)	/* insert a brace into the text here...we are in CMODE */
X
Xint n;	/* repeat count */
Xint c;	/* brace to insert (always { for now) */
X
X{
X	register int ch;	/* last character before input */
X	register int i;
X	register int target;	/* column brace should go after */
X
X	/* if we are at the beginning of the line, no go */
X	if (curwp->w_doto == 0)
X		return(linsert(n,c));
X		
X	/* scan to see if all space before this is white space */
X	for (i = curwp->w_doto - 1; i >= 0; --i) {
X		ch = lgetc(curwp->w_dotp, i);
X		if (ch != ' ' && ch != '\t')
X			return(linsert(n, c));
X	}
X
X	/* delete back first */
X	target = getccol(FALSE);	/* calc where we will delete to */
X	target -= 1;
X	target -= target % (tabsize == 0 ? 8 : tabsize);
X	while (getccol(FALSE) > target)
X		backdel(FALSE, 1);
X
X	/* and insert the required brace(s) */
X	return(linsert(n, c));
X}
X
Xinspound()	/* insert a # into the text here...we are in CMODE */
X
X{
X	register int ch;	/* last character before input */
X	register int i;
X
X	/* if we are at the beginning of the line, no go */
X	if (curwp->w_doto == 0)
X		return(linsert(1,'#'));
X		
X	/* scan to see if all space before this is white space */
X	for (i = curwp->w_doto - 1; i >= 0; --i) {
X		ch = lgetc(curwp->w_dotp, i);
X		if (ch != ' ' && ch != '\t')
X			return(linsert(1, '#'));
X	}
X
X	/* delete back first */
X	while (getccol(FALSE) >= 1)
X		backdel(FALSE, 1);
X
X	/* and insert the required pound */
X	return(linsert(1, '#'));
X}
X
X/*
X * Delete blank lines around dot. What this command does depends if dot is
X * sitting on a blank line. If dot is sitting on a blank line, this command
X * deletes all the blank lines above and below the current line. If it is
X * sitting on a non blank line then it deletes all of the blank lines after
X * the line. Normally this command is bound to "C-X C-O". Any argument is
X * ignored.
X */
Xdeblank(f, n)
X{
X        register LINE   *lp1;
X        register LINE   *lp2;
X        long nld;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        lp1 = curwp->w_dotp;
X        while (llength(lp1)==0 && (lp2=lback(lp1))!=curbp->b_linep)
X                lp1 = lp2;
X        lp2 = lp1;
X        nld = 0;
X        while ((lp2=lforw(lp2))!=curbp->b_linep && llength(lp2)==0)
X                ++nld;
X        if (nld == 0)
X                return (TRUE);
X        curwp->w_dotp = lforw(lp1);
X        curwp->w_doto = 0;
X        return (ldelete(nld, FALSE));
X}
X
X/*
X * Insert a newline, then enough tabs and spaces to duplicate the indentation
X * of the previous line. Assumes tabs are every eight characters. Quite simple.
X * Figure out the indentation of the current line. Insert a newline by calling
X * the standard routine. Insert the indentation by inserting the right number
X * of tabs and spaces. Return TRUE if all ok. Return FALSE if one of the
X * subcomands failed. Normally bound to "C-J".
X */
Xindent(f, n)
X{
X        register int    nicol;
X        register int    c;
X        register int    i;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        if (n < 0)
X                return (FALSE);
X        while (n--) {
X                nicol = 0;
X                for (i=0; i<llength(curwp->w_dotp); ++i) {
X                        c = lgetc(curwp->w_dotp, i);
X                        if (c!=' ' && c!='\t')
X                                break;
X                        if (c == '\t')
X                                nicol |= 0x07;
X                        ++nicol;
X                }
X                if (lnewline() == FALSE
X                || ((i=nicol/8)!=0 && linsert(i, '\t')==FALSE)
X                || ((i=nicol%8)!=0 && linsert(i,  ' ')==FALSE))
X                        return (FALSE);
X        }
X        return (TRUE);
X}
X
X/*
X * Delete forward. This is real easy, because the basic delete routine does
X * all of the work. Watches for negative arguments, and does the right thing.
X * If any argument is present, it kills rather than deletes, to prevent loss
X * of text if typed with a big argument. Normally bound to "C-D".
X */
Xforwdel(f, n)
X{
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        if (n < 0)
X                return (backdel(f, -n));
X        if (f != FALSE) {                       /* Really a kill.       */
X                if ((lastflag&CFKILL) == 0)
X                        kdelete();
X                thisflag |= CFKILL;
X        }
X        return (ldelete((long)n, f));
X}
X
X/*
X * Delete backwards. This is quite easy too, because it's all done with other
X * functions. Just move the cursor back, and delete forwards. Like delete
X * forward, this actually does a kill if presented with an argument. Bound to
X * both "RUBOUT" and "C-H".
X */
Xbackdel(f, n)
X{
X        register int    s;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        if (n < 0)
X                return (forwdel(f, -n));
X        if (f != FALSE) {                       /* Really a kill.       */
X                if ((lastflag&CFKILL) == 0)
X                        kdelete();
X                thisflag |= CFKILL;
X        }
X        if ((s=backchar(f, n)) == TRUE)
X                s = ldelete((long)n, f);
X        return (s);
X}
X
X/*
X * Kill text. If called without an argument, it kills from dot to the end of
X * the line, unless it is at the end of the line, when it kills the newline.
X * If called with an argument of 0, it kills from the start of the line to dot.
X * If called with a positive argument, it kills from dot forward over that
X * number of newlines. If called with a negative argument it kills backwards
X * that number of newlines. Normally bound to "C-K".
X */
Xkilltext(f, n)
X{
X        register LINE   *nextp;
X        long chunk;
X
X	if (curbp->b_mode&MDVIEW)	/* don't allow this command if	*/
X		return(rdonly());	/* we are in read only mode	*/
X        if ((lastflag&CFKILL) == 0)             /* Clear kill buffer if */
X                kdelete();                      /* last wasn't a kill.  */
X        thisflag |= CFKILL;
X        if (f == FALSE) {
X                chunk = llength(curwp->w_dotp)-curwp->w_doto;
X                if (chunk == 0)
X                        chunk = 1;
X        } else if (n == 0) {
X                chunk = curwp->w_doto;
X                curwp->w_doto = 0;
X        } else if (n > 0) {
X                chunk = llength(curwp->w_dotp)-curwp->w_doto+1;
X                nextp = lforw(curwp->w_dotp);
X                while (--n) {
X                        if (nextp == curbp->b_linep)
X                                return (FALSE);
X                        chunk += llength(nextp)+1;
X                        nextp = lforw(nextp);
X                }
X        } else {
X                mlwrite("neg kill");
X                return (FALSE);
X        }
X        return(ldelete(chunk, TRUE));
X}
X
Xsetmode(f, n)	/* prompt and set an editor mode */
X
Xint f, n;	/* default and argument */
X
X{
X	adjustmode(TRUE, FALSE);
X}
X
Xdelmode(f, n)	/* prompt and delete an editor mode */
X
Xint f, n;	/* default and argument */
X
X{
X	adjustmode(FALSE, FALSE);
X}
X
Xsetgmode(f, n)	/* prompt and set a global editor mode */
X
Xint f, n;	/* default and argument */
X
X{
X	adjustmode(TRUE, TRUE);
X}
X
Xdelgmode(f, n)	/* prompt and delete a global editor mode */
X
Xint f, n;	/* default and argument */
X
X{
X	adjustmode(FALSE, TRUE);
X}
X
Xadjustmode(kind, global)	/* change the editor mode status */
X
Xint kind;	/* true = set,		false = delete */
Xint global;	/* true = global flag,	false = current buffer flag */
X{
X	register char *scan;		/* scanning pointer to convert prompt */
X	register int i;			/* loop index */
X#if	COLOR
X	register int uflag;		/* was modename uppercase?	*/
X#endif
X	char prompt[50];	/* string to prompt user with */
X	char cbuf[NPAT];		/* buffer to recieve mode name into */
X
X	/* build the proper prompt string */
X	if (global)
X		strcpy(prompt,"Global mode to ");
X	else
X		strcpy(prompt,"Mode to ");
X
X	if (kind == TRUE)
X		strcat(prompt, "add: ");
X	else
X		strcat(prompt, "delete: ");
X
X	/* prompt the user and get an answer */
X
X	mlreply(prompt, cbuf, NPAT - 1);
X
X	/* make it uppercase */
X
X	scan = cbuf;
X#if	COLOR
X	uflag = (*scan >= 'A' && *scan <= 'Z');
X#endif
X	while (*scan != 0) {
X		if (*scan >= 'a' && *scan <= 'z')
X			*scan = *scan - 32;
X		scan++;
X	}
X
X	/* test it first against the colors we know */
X	for (i=0; i<NCOLORS; i++) {
X		if (strcmp(cbuf, cname[i]) == 0) {
X			/* finding the match, we set the color */
X#if	COLOR
X			if (uflag)
X				if (global)
X					gfcolor = i;
X				else
X					curwp->w_fcolor = i;
X			else
X				if (global)
X					gbcolor = i;
X				else
X					curwp->w_bcolor = i;
X
X			curwp->w_flag |= WFCOLR;
X#endif
X			mlerase();
X			return(TRUE);
X		}
X	}
X
X	/* test it against the modes we know */
X
X	for (i=0; i < NUMMODES; i++) {
X		if (strcmp(cbuf, modename[i]) == 0) {
X			/* finding a match, we process it */
X			if (kind == TRUE)
X				if (global)
X					gmode |= (1 << i);
X				else
X					curwp->w_bufp->b_mode |= (1 << i);
X			else
X				if (global)
X					gmode &= ~(1 << i);
X				else
X					curwp->w_bufp->b_mode &= ~(1 << i);
X			/* display new mode line */
X			if (global == 0)
X				upmode();
X			mlerase();	/* erase the junk */
X			return(TRUE);
X		}
X	}
X
X	mlwrite("No such mode!");
X	return(FALSE);
X}
X
X/*	This function simply clears the message line,
X		mainly for macro usage			*/
X
Xclrmes(f, n)
X
Xint f, n;	/* arguments ignored */
X
X{
X	mlwrite("");
X	return(TRUE);
X}
X
X/*	This function writes a string on the message line
X		mainly for macro usage			*/
X
Xwritemsg(f, n)
X
Xint f, n;	/* arguments ignored */
X
X{
X	register char *sp;	/* pointer into buf to expand %s */
X	register char *np;	/* ptr into nbuf */
X	register int status;
X	char buf[NPAT];		/* buffer to recieve message into */
X	char nbuf[NPAT*2];	/* buffer to expand string into */
X
X	if ((status = mlreply("Message to write: ", buf, NPAT - 1)) != TRUE)
X		return(status);
X
X	/* expand all '%' to "%%" so mlwrite won't expect arguments */
X	sp = buf;
X	np = nbuf;
X	while (*sp) {
X		*np++ = *sp;
X		if (*sp++ == '%')
X			*np++ = '%';
X	}
X	*np = '\0';
X	mlwrite(nbuf);
X	return(TRUE);
X}
X
X#if	CFENCE
X/*	the cursor is moved to a matching fence	*/
X
Xgetfence(f, n)
X
Xint f, n;	/* not used */
X
X{
X	register LINE *oldlp;	/* original line pointer */
X	register int oldoff;	/* and offset */
X	register int sdir;	/* direction of search (1/-1) */
X	register int count;	/* current fence level count */
X	register char ch;	/* fence type to match against */
X	register char ofence;	/* open fence */
X	register char c;	/* current character in scan */
X
X	/* save the original cursor position */
X	oldlp = curwp->w_dotp;
X	oldoff = curwp->w_doto;
X
X	/* get the current character */
X	ch = lgetc(oldlp, oldoff);
X
X	/* setup proper matching fence */
X	switch (ch) {
X		case '(': ofence = ')'; sdir = FORWARD; break;
X		case '{': ofence = '}'; sdir = FORWARD; break;
X		case '[': ofence = ']'; sdir = FORWARD; break;
X		case ')': ofence = '('; sdir = REVERSE; break;
X		case '}': ofence = '{'; sdir = REVERSE; break;
X		case ']': ofence = '['; sdir = REVERSE; break;
X		default: TTbeep(); return(FALSE);
X	}
X
X	/* set up for scan */
X	count = 1;
X	if (sdir == REVERSE)
X		backchar(FALSE, 1);
X	else
X		forwchar(FALSE, 1);
X
X	/* scan until we find it, or reach the end of file */
X	while (count > 0) {
X		c = lgetc(curwp->w_dotp, curwp->w_doto);
X		if (c == ch)
X			++count;
X		if (c == ofence)
X			--count;
X		if (sdir == FORWARD)
X			forwchar(FALSE, 1);
X		else
X			backchar(FALSE, 1);
X		if (boundry(curwp->w_dotp, curwp->w_doto, sdir))
X			break;
X	}
X
X	/* if count is zero, we have a match, move the sucker */
X	if (count == 0) {
X		if (sdir == FORWARD)
X			backchar(FALSE, 1);
X		else
X			forwchar(FALSE, 1);
X		curwp->w_flag |= WFMOVE;
X		return(TRUE);
X	}
X
X	/* restore the current position */
X	curwp->w_dotp = oldlp;
X	curwp->w_doto = oldoff;
X	TTbeep();
X	return(FALSE);
X}
X#endif
X
X/*	Close fences are matched against their partners, and if
X	on screen the cursor briefly lights there		*/
X
Xfmatch(ch)
X
Xchar ch;	/* fence type to match against */
X
X{
X	register LINE *oldlp;	/* original line pointer */
X	register int oldoff;	/* and offset */
X	register LINE *toplp;	/* top line in current window */
X	register int count;	/* current fence level count */
X	register char opench;	/* open fence */
X	register char c;	/* current character in scan */
X	register int i;
X
X	/* first get the display update out there */
X	update(FALSE);
X
X	/* save the original cursor position */
X	oldlp = curwp->w_dotp;
X	oldoff = curwp->w_doto;
X
X	/* setup proper open fence for passed close fence */
X	if (ch == ')')
X		opench = '(';
X	else if (ch == '}')
X		opench = '{';
X	else
X		opench = '[';
X
X	/* find the top line and set up for scan */
X	toplp = curwp->w_linep->l_bp;
X	count = 1;
X	backchar(FALSE, 2);
X
X	/* scan back until we find it, or reach past the top of the window */
X	while (count > 0 && curwp->w_dotp != toplp) {
X		c = lgetc(curwp->w_dotp, curwp->w_doto);
X		if (c == ch)
X			++count;
X		if (c == opench)
X			--count;
X		backchar(FALSE, 1);
X		if (curwp->w_dotp == curwp->w_bufp->b_linep->l_fp &&
X		    curwp->w_doto == 0)
X			break;
X	}
X
X	/* if count is zero, we have a match, display the sucker */
X	/* there is a real machine dependant timing problem here we have
X	   yet to solve......... */
X	if (count == 0) {
X		forwchar(FALSE, 1);
X		for (i = 0; i < term.t_pause; i++)
X			update(FALSE);
X	}
X
X	/* restore the current position */
X	curwp->w_dotp = oldlp;
X	curwp->w_doto = oldoff;
X	return(TRUE);
X}
X
Xistring(f, n)	/* ask for and insert a string into the current
X		   buffer at the current point */
X
Xint f, n;	/* ignored arguments */
X
X{
X	register char *tp;	/* pointer into string to add */
X	register int status;	/* status return code */
X	char tstring[NPAT+1];	/* string to add */
X
X	/* ask for string to insert */
X	status = mlreplyt("String to insert<META>: ", tstring, NPAT, metac);
X	if (status != TRUE)
X		return(status);
X
X	if (f == FALSE)
X		n = 1;
X
X	if (n < 0)
X		n = - n;
X
X	/* insert it */
X	while (n--) {
X		tp = &tstring[0];
X		while (*tp) {
X			if (*tp == 0x0a)
X				status = lnewline();
X			else
X				status = linsert(1, *tp);
X			++tp;
X			if (status != TRUE)
X				return(status);
X		}
X	}
X		
X	return(TRUE);
X}
X
END_OF_random.c
if test 23797 -ne `wc -c <random.c`; then
    echo shar: \"random.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 10 \(of 14\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    echo "See the readme file"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
