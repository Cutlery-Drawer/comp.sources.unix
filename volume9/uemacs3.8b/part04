Subject:  v09i036:  MicroEMACS, version 3.8b, Part04/14
Newsgroups: mod.sources
Approved: rs@mirror.TMC.COM

Submitted by: ihnp4!itivax!duncan!lawrence (Daniel Lawrence)
Mod.sources: Volume 9, Issue 36
Archive-name: uemacs3.8b/Part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If this archive is complete, you will see the message:
#		"End of archive 4 (of 14)."
# Contents:  ebind.h eval.c menu.cmd st520.c
# Wrapped by rs@mirror on Fri Mar 13 13:23:45 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"ebind.h\" \(11355 characters\)
if test -f ebind.h ; then 
  echo shar: Will not over-write existing file \"ebind.h\"
else
sed "s/^X//" >ebind.h <<'END_OF_ebind.h'
X/*	EBIND:		Initial default key to function bindings for
X			MicroEMACS 3.7
X*/
X
X/*
X * Command table.
X * This table  is *roughly* in ASCII order, left to right across the
X * characters of the command. This expains the funny location of the
X * control-X commands.
X */
XKEYTAB  keytab[NBINDS] = {
X	{CTRL|'A',		gotobol},
X	{CTRL|'B',		backchar},
X	{CTRL|'C',		insspace},
X	{CTRL|'D',		forwdel},
X	{CTRL|'E',		gotoeol},
X	{CTRL|'F',		forwchar},
X	{CTRL|'G',		ctrlg},
X	{CTRL|'H',		backdel},
X	{CTRL|'I',		tab},
X	{CTRL|'J',		indent},
X	{CTRL|'K',		killtext},
X	{CTRL|'L',		refresh},
X	{CTRL|'M',		newline},
X	{CTRL|'N',		forwline},
X	{CTRL|'O',		openline},
X	{CTRL|'P',		backline},
X	{CTRL|'Q',		quote},
X	{CTRL|'R',		backsearch},
X	{CTRL|'S',		forwsearch},
X	{CTRL|'T',		twiddle},
X	{CTRL|'U',		unarg},
X	{CTRL|'V',		forwpage},
X	{CTRL|'W',		killregion},
X	{CTRL|'X',		cex},
X	{CTRL|'Y',		yank},
X	{CTRL|'Z',		backpage},
X	{CTRL|']',		meta},
X	{CTLX|CTRL|'B',		listbuffers},
X	{CTLX|CTRL|'C',		quit},          /* Hard quit.           */
X	{CTLX|CTRL|'F',		filefind},
X	{CTLX|CTRL|'I',		insfile},
X	{CTLX|CTRL|'L',		lowerregion},
X	{CTLX|CTRL|'M',		delmode},
X	{CTLX|CTRL|'N',		mvdnwind},
X	{CTLX|CTRL|'O',		deblank},
X	{CTLX|CTRL|'P',		mvupwind},
X	{CTLX|CTRL|'R',		fileread},
X	{CTLX|CTRL|'S',		filesave},
X	{CTLX|CTRL|'U',		upperregion},
X	{CTLX|CTRL|'V',		viewfile},
X	{CTLX|CTRL|'W',		filewrite},
X	{CTLX|CTRL|'X',		swapmark},
X	{CTLX|CTRL|'Z',		shrinkwind},
X	{CTLX|'?',		deskey},
X	{CTLX|'!',		spawn},
X	{CTLX|'@',		pipe},
X	{CTLX|'#',		filter},
X	{CTLX|'=',		showcpos},
X	{CTLX|'(',		ctlxlp},
X	{CTLX|')',		ctlxrp},
X	{CTLX|'^',		enlargewind},
X	{CTLX|'0',		delwind},
X	{CTLX|'1',		onlywind},
X	{CTLX|'2',		splitwind},
X	{CTLX|'A',		setvar},
X	{CTLX|'B',		usebuffer},
X	{CTLX|'C',		spawncli},
X#if	BSD
X	{CTLX|'D',		bktoshell},
X#endif
X	{CTLX|'E',		ctlxe},
X	{CTLX|'F',		setfillcol},
X	{CTLX|'K',		killbuffer},
X	{CTLX|'M',		setmode},
X	{CTLX|'N',		filename},
X	{CTLX|'O',		nextwind},
X	{CTLX|'P',		prevwind},
X#if	ISRCH
X	{CTLX|'R',		risearch},
X	{CTLX|'S',		fisearch},
X#endif
X	{CTLX|'W',		resize},
X	{CTLX|'X',		nextbuffer},
X	{CTLX|'Z',		enlargewind},
X#if	WORDPRO
X	{META|CTRL|'C',		wordcount},
X#endif
X#if	CFENCE
X	{META|CTRL|'F',		getfence},
X#endif
X	{META|CTRL|'H',		delbword},
X	{META|CTRL|'K',		unbindkey},
X	{META|CTRL|'L',		reposition},
X	{META|CTRL|'M',		delgmode},
X	{META|CTRL|'N',		namebuffer},
X	{META|CTRL|'R',		qreplace},
X	{META|CTRL|'S',		newsize},
X	{META|CTRL|'T',		newwidth},
X	{META|CTRL|'V',		scrnextdw},
X#if	WORDPRO
X	{META|CTRL|'W',		killpara},
X#endif
X	{META|CTRL|'Z',		scrnextup},
X	{META|' ',		setmark},
X	{META|'?',		help},
X	{META|'!',		reposition},
X	{META|'.',		setmark},
X	{META|'>',		gotoeob},
X	{META|'<',		gotobob},
X	{META|'~',		unmark},
X#if	APROP
X	{META|'A',		apro},
X#endif
X	{META|'B',		backword},
X	{META|'C',		capword},
X	{META|'D',		delfword},
X#if	CRYPT
X	{META|'E',		setkey},
X#endif
X	{META|'F',		forwword},
X	{META|'G',		gotoline},
X	{META|'K',		bindtokey},
X	{META|'L',		lowerword},
X	{META|'M',		setgmode},
X#if	WORDPRO
X	{META|'N',		gotoeop},
X	{META|'P',		gotobop},
X	{META|'Q',		fillpara},
X#endif
X	{META|'R',		sreplace},
X#if	BSD
X	{META|'S',		bktoshell},
X#endif
X	{META|'U',		upperword},
X	{META|'V',		backpage},
X	{META|'W',		copyregion},
X	{META|'X',		namedcmd},
X	{META|'Z',		quickexit},
X	{META|0x7F,              delbword},
X
X#if	MSDOS & (HP150 == 0) & (WANGPC == 0) & (HP110 == 0)
X	{SPEC|CTRL|'_',		forwhunt},
X	{SPEC|CTRL|'S',		backhunt},
X	{SPEC|71,		gotobob},
X	{SPEC|72,		backline},
X	{SPEC|73,		backpage},
X	{SPEC|75,		backchar},
X	{SPEC|77,		forwchar},
X	{SPEC|79,		gotoeob},
X	{SPEC|80,		forwline},
X	{SPEC|81,		forwpage},
X	{SPEC|82,		insspace},
X	{SPEC|83,		forwdel},
X	{SPEC|115,		backword},
X	{SPEC|116,		forwword},
X#if	WORDPRO
X	{SPEC|132,		gotobop},
X	{SPEC|118,		gotoeop},
X#endif
X	{SPEC|84,		cbuf1},
X	{SPEC|85,		cbuf2},
X	{SPEC|86,		cbuf3},
X	{SPEC|87,		cbuf4},
X	{SPEC|88,		cbuf5},
X	{SPEC|89,		cbuf6},
X	{SPEC|90,		cbuf7},
X	{SPEC|91,		cbuf8},
X	{SPEC|92,		cbuf9},
X	{SPEC|93,		cbuf10},
X#endif
X
X#if	HP150
X	{SPEC|32,		backline},
X	{SPEC|33,		forwline},
X	{SPEC|35,		backchar},
X	{SPEC|34,		forwchar},
X	{SPEC|44,		gotobob},
X	{SPEC|46,		forwpage},
X	{SPEC|47,		backpage},
X	{SPEC|82,		nextwind},
X	{SPEC|68,		openline},
X	{SPEC|69,		killtext},
X	{SPEC|65,		forwdel},
X	{SPEC|64,		ctlxe},
X	{SPEC|67,		refresh},
X	{SPEC|66,		reposition},
X	{SPEC|83,		help},
X	{SPEC|81,		deskey},
X#endif
X
X#if	HP110
X	{SPEC|0x4b,		backchar},
X	{SPEC|0x4d,		forwchar},
X	{SPEC|0x48,		backline},
X	{SPEC|0x50,		forwline},
X	{SPEC|0x43,		help},
X	{SPEC|0x73,		backword},
X	{SPEC|0x74,		forwword},
X	{SPEC|0x49,		backpage},
X	{SPEC|0x51,		forwpage},
X	{SPEC|84,		cbuf1},
X	{SPEC|85,		cbuf2},
X	{SPEC|86,		cbuf3},
X	{SPEC|87,		cbuf4},
X	{SPEC|88,		cbuf5},
X	{SPEC|89,		cbuf6},
X	{SPEC|90,		cbuf7},
X	{SPEC|91,		cbuf8},
X#endif
X
X#if	AMIGA
X	{SPEC|'?',		help},
X	{SPEC|'A',		backline},
X	{SPEC|'B',		forwline},
X	{SPEC|'C',		forwchar},
X	{SPEC|'D',		backchar},
X	{SPEC|'T',		backpage},
X	{SPEC|'S',		forwpage},
X	{SPEC|'a',		backword},
X	{SPEC|'`',		forwword},
X	{SPEC|'P',		cbuf1},
X	{SPEC|'Q',		cbuf2},
X	{SPEC|'R',		cbuf3},
X	{SPEC|'S',		cbuf4},
X	{SPEC|'T',		cbuf5},
X	{SPEC|'U',		cbuf6},
X	{SPEC|'V',		cbuf7},
X	{SPEC|'W',		cbuf8},
X	{SPEC|'X',		cbuf9},
X	{SPEC|'Y',		cbuf10},
X
X#endif
X
X#if	ST520
X	{SPEC|'?',		help},
X	{SPEC|'A',		backline},
X	{SPEC|'B',		forwline},
X	{SPEC|'C',		forwchar},
X	{SPEC|'D',		backchar},
X	{SPEC|'T',		backpage},
X	{SPEC|'S',		forwpage},
X	{SPEC|'a',		backword},
X	{SPEC|'`',		forwword},
X	{SPEC|'P',		cbuf1},
X	{SPEC|'Q',		cbuf2},
X	{SPEC|'R',		cbuf3},
X	{SPEC|'S',		cbuf4},
X	{SPEC|'T',		cbuf5},
X	{SPEC|'U',		cbuf6},
X	{SPEC|'V',		cbuf7},
X	{SPEC|'W',		cbuf8},
X	{SPEC|'X',		cbuf9},
X	{SPEC|'Y',		cbuf10},
X
X#endif
X
X#if  WANGPC
X	SPEC|0xE0,              quit,           /* Cancel */
X	SPEC|0xE1,              help,           /* Help */
X	SPEC|0xF1,              help,           /* ^Help */
X	SPEC|0xE3,              ctrlg,          /* Print */
X	SPEC|0xF3,              ctrlg,          /* ^Print */
X	SPEC|0xC0,              backline,       /* North */
X	SPEC|0xD0,              gotobob,        /* ^North */
X	SPEC|0xC1,              forwchar,       /* East */
X	SPEC|0xD1,              gotoeol,        /* ^East */
X	SPEC|0xC2,              forwline,       /* South */
X	SPEC|0xD2,              gotobop,        /* ^South */
X	SPEC|0xC3,              backchar,       /* West */
X	SPEC|0xD3,              gotobol,        /* ^West */
X	SPEC|0xC4,              ctrlg,          /* Home */
X	SPEC|0xD4,              gotobob,        /* ^Home */
X	SPEC|0xC5,              filesave,       /* Execute */
X	SPEC|0xD5,              ctrlg,          /* ^Execute */
X	SPEC|0xC6,              insfile,        /* Insert */
X	SPEC|0xD6,              ctrlg,          /* ^Insert */
X	SPEC|0xC7,              forwdel,        /* Delete */
X	SPEC|0xD7,              killregion,     /* ^Delete */
X	SPEC|0xC8,              backpage,       /* Previous */
X	SPEC|0xD8,              prevwind,       /* ^Previous */
X	SPEC|0xC9,              forwpage,       /* Next */
X	SPEC|0xD9,              nextwind,       /* ^Next */
X	SPEC|0xCB,              ctrlg,          /* Erase */
X	SPEC|0xDB,              ctrlg,          /* ^Erase */
X	SPEC|0xDC,              ctrlg,          /* ^Tab */
X	SPEC|0xCD,              ctrlg,          /* BackTab */
X	SPEC|0xDD,              ctrlg,          /* ^BackTab */
X	SPEC|0x80,              ctrlg,          /* Indent */
X	SPEC|0x90,              ctrlg,          /* ^Indent */
X	SPEC|0x81,              ctrlg,          /* Page */
X	SPEC|0x91,              ctrlg,          /* ^Page */
X	SPEC|0x82,              ctrlg,          /* Center */
X	SPEC|0x92,              ctrlg,          /* ^Center */
X	SPEC|0x83,              ctrlg,          /* DecTab */
X	SPEC|0x93,              ctrlg,          /* ^DecTab */
X	SPEC|0x84,              ctrlg,          /* Format */
X	SPEC|0x94,              ctrlg,          /* ^Format */
X	SPEC|0x85,              ctrlg,          /* Merge */
X	SPEC|0x95,              ctrlg,          /* ^Merge */
X	SPEC|0x86,              setmark,        /* Note */
X	SPEC|0x96,              ctrlg,          /* ^Note */
X	SPEC|0x87,              ctrlg,          /* Stop */
X	SPEC|0x97,              ctrlg,          /* ^Stop */
X	SPEC|0x88,              forwsearch,     /* Srch */
X	SPEC|0x98,              backsearch,     /* ^Srch */
X	SPEC|0x89,              sreplace,       /* Replac */
X	SPEC|0x99,              qreplace,       /* ^Replac */
X	SPEC|0x8A,              ctrlg,          /* Copy */
X	SPEC|0x9A,              ctrlg,          /* ^Copy */
X	SPEC|0x8B,              ctrlg,          /* Move */
X	SPEC|0x9B,              ctrlg,          /* ^Move */
X	SPEC|0x8C,              namedcmd,       /* Command */
X	SPEC|0x9C,              spawn,          /* ^Command */
X	SPEC|0x8D,              ctrlg,          /* ^ */
X	SPEC|0x9D,              ctrlg,          /* ^^ */
X	SPEC|0x8E,              ctrlg,          /* Blank */
X	SPEC|0x9E,              ctrlg,          /* ^Blank */
X	SPEC|0x8F,              gotoline,       /* GoTo */
X	SPEC|0x9F,              usebuffer,      /* ^GoTo */
X#endif
X 
X	{0x7F,			backdel},
X
X	/* special internal bindings */
X	SPEC|META|'W',		wrapword,	/* called on word wrap */
X
X	{0,			NULL}
X};
X
X#if RAINBOW
X
X#include "rainbow.h"
X
X/*
X * Mapping table from the LK201 function keys to the internal EMACS character.
X */
X
Xshort lk_map[][2] = {
X	Up_Key,                         CTRL+'P',
X	Down_Key,                       CTRL+'N',
X	Left_Key,                       CTRL+'B',
X	Right_Key,                      CTRL+'F',
X	Shift+Left_Key,                 META+'B',
X	Shift+Right_Key,                META+'F',
X	Control+Left_Key,               CTRL+'A',
X	Control+Right_Key,              CTRL+'E',
X	Prev_Scr_Key,                   META+'V',
X	Next_Scr_Key,                   CTRL+'V',
X	Shift+Up_Key,                   META+'<',
X	Shift+Down_Key,                 META+'>',
X	Cancel_Key,                     CTRL+'G',
X	Find_Key,                       CTRL+'S',
X	Shift+Find_Key,                 CTRL+'R',
X	Insert_Key,                     CTRL+'Y',
X	Options_Key,                    CTRL+'D',
X	Shift+Options_Key,              META+'D',
X	Remove_Key,                     CTRL+'W',
X	Shift+Remove_Key,               META+'W',
X	Select_Key,                     CTRL+'@',
X	Shift+Select_Key,               CTLX+CTRL+'X',
X	Interrupt_Key,                  CTRL+'U',
X	Keypad_PF2,                     META+'L',
X	Keypad_PF3,                     META+'C',
X	Keypad_PF4,                     META+'U',
X	Shift+Keypad_PF2,               CTLX+CTRL+'L',
X	Shift+Keypad_PF4,               CTLX+CTRL+'U',
X	Keypad_1,                       CTLX+'1',
X	Keypad_2,                       CTLX+'2',
X	Do_Key,                         CTLX+'E',
X	Keypad_4,                       CTLX+CTRL+'B',
X	Keypad_5,                       CTLX+'B',
X	Keypad_6,                       CTLX+'K',
X	Resume_Key,                     META+'!',
X	Control+Next_Scr_Key,           CTLX+'N',
X	Control+Prev_Scr_Key,           CTLX+'P',
X	Control+Up_Key,                 CTLX+CTRL+'P',
X	Control+Down_Key,               CTLX+CTRL+'N',
X	Help_Key,                       CTLX+'=',
X	Shift+Do_Key,                   CTLX+'(',
X	Control+Do_Key,                 CTLX+')',
X	Keypad_0,                       CTLX+'Z',
X	Shift+Keypad_0,                 CTLX+CTRL+'Z',
X	Main_Scr_Key,                   CTRL+'C',
X	Keypad_Enter,                   CTLX+'!',
X	Exit_Key,                       CTLX+CTRL+'C',
X	Shift+Exit_Key,                 CTRL+'Z'
X};
X
X#define lk_map_size     (sizeof(lk_map)/2)
X#endif
X
END_OF_ebind.h
if test 11355 -ne `wc -c <ebind.h`; then
    echo shar: \"ebind.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"eval.c\" \(10700 characters\)
if test -f eval.c ; then 
  echo shar: Will not over-write existing file \"eval.c\"
else
sed "s/^X//" >eval.c <<'END_OF_eval.c'
X/*	EVAL.C:	Expresion evaluation functions for
X		MicroEMACS
X
X	written 1986 by Daniel Lawrence				*/
X
X#include	<stdio.h>
X#include	"estruct.h"
X#include	"edef.h"
X#include	"evar.h"
X
X#if	MEGAMAX & ST520
Xoverlay	"eval"
X#endif
X
Xchar value[80];		/* buffer to return value in */
X
Xvarinit()		/* initialize the user variable list */
X
X{
X	register int i;
X
X	for (i=0; i < MAXVARS; i++)
X		uv[i].u_name[0] = 0;
X}
X
Xchar *gtfun(fname)	/* evaluate a function */
X
Xchar *fname;		/* name of function to evaluate */
X
X{
X	register int fnum;		/* index to function to eval */
X	register int status;		/* return status */
X	char arg1[NSTRING];		/* value of first argument */
X	char arg2[NSTRING];		/* value of second argument */
X	char arg3[NSTRING];		/* value of third argument */
X	static char result[2 * NSTRING];	/* string result */
X
X	/* look the function up in the function table */
X	fname[3] = 0;	/* only first 3 chars significant */
X	for (fnum = 0; fnum < NFUNCS; fnum++)
X		if (strcmp(fname, funcs[fnum].f_name) == 0)
X			break;
X
X	/* return errorm on a bad reference */
X	if (fnum == NFUNCS)
X		return(errorm);
X
X	/* retrieve the first argument */
X	if ((status = macarg(arg1)) != TRUE)
X		return(errorm);
X
X	/* if needed, retrieve the second argument */
X	if (funcs[fnum].f_type >= DYNAMIC) {
X		if ((status = macarg(arg2)) != TRUE)
X			return(errorm);
X
X		/* if needed, retrieve the third argument */
X		if (funcs[fnum].f_type >= TRINAMIC)
X			if ((status = macarg(arg3)) != TRUE)
X				return(errorm);
X	}
X
X	/* and now evaluate it! */
X	switch (fnum) {
X		case UFADD:	return(itoa(atoi(arg1) + atoi(arg2)));
X		case UFSUB:	return(itoa(atoi(arg1) - atoi(arg2)));
X		case UFTIMES:	return(itoa(atoi(arg1) * atoi(arg2)));
X		case UFDIV:	return(itoa(atoi(arg1) / atoi(arg2)));
X		case UFMOD:	return(itoa(atoi(arg1) % atoi(arg2)));
X		case UFNEG:	return(itoa(-atoi(arg1)));
X		case UFCAT:	strcpy(result, arg1);
X				return(strcat(result, arg2));
X		case UFLEFT:	return(strncpy(result, arg1, atoi(arg2)));
X		case UFRIGHT:	return(strcpy(result, &arg1[atoi(arg2)-1]));
X		case UFMID:	return(strncpy(result, &arg1[atoi(arg2)-1],
X					atoi(arg3)));
X		case UFNOT:	return(ltos(stol(arg1) == FALSE));
X		case UFEQUAL:	return(ltos(atoi(arg1) == atoi(arg2)));
X		case UFLESS:	return(ltos(atoi(arg1) < atoi(arg2)));
X		case UFGREATER:	return(ltos(atoi(arg1) > atoi(arg2)));
X		case UFSEQUAL:	return(ltos(strcmp(arg1, arg2) == 0));
X		case UFSLESS:	return(ltos(strcmp(arg1, arg2) < 0));
X		case UFSGREAT:	return(ltos(strcmp(arg1, arg2) > 0));
X		case UFIND:	return(getval(arg1));
X	}
X
X	exit(-11);	/* never should get here */
X}
X
Xchar *gtusr(vname)	/* look up a user var's value */
X
Xchar *vname;		/* name of user variable to fetch */
X
X{
X
X	register int vnum;	/* ordinal number of user var */
X
X	/* scan the list looking for the user var name */
X	for (vnum = 0; vnum < MAXVARS; vnum++)
X		if (strcmp(vname, uv[vnum].u_name) == 0)
X			break;
X
X	/* return errorm on a bad reference */
X	if (vnum == MAXVARS)
X		return(errorm);
X
X	return(uv[vnum].u_value);
X}
X
Xchar *gtenv(vname)
X
Xchar *vname;		/* name of environment variable to retrieve */
X
X{
X	register int vnum;	/* ordinal number of var refrenced */
X
X	/* scan the list, looking for the referenced name */
X	for (vnum = 0; vnum < NEVARS; vnum++)
X		if (strcmp(vname, envars[vnum]) == 0)
X			break;
X
X	/* return errorm on a bad reference */
X	if (vnum == NEVARS)
X		return(errorm);
X
X	/* otherwise, fetch the appropriate value */
X	switch (vnum) {
X		case EVFILLCOL:	return(itoa(fillcol));
X		case EVPAGELEN:	return(itoa(term.t_nrow + 1));
X		case EVCURCOL:	return(itoa(getccol(FALSE)));
X		case EVCURLINE: return(itoa(getcline()));
X		case EVRAM:	return(itoa((int)(envram / 1024l)));
X		case EVFLICKER:	return(ltos(flickcode));
X		case EVCURWIDTH:return(itoa(term.t_nrow));
X		case EVCBUFNAME:return(curbp->b_bname);
X		case EVCFNAME:	return(curbp->b_fname);
X		case EVSRES:	return(sres);
X		case EVDEBUG:	return(ltos(macbug));
X		case EVSTATUS:	return(ltos(cmdstatus));
X	}
X}
X
Xint setvar(f, n)		/* set a variable */
X
Xint f;		/* default flag */
Xint n;		/* numeric arg (can overide prompted value) */
X
X{
X	register int vnum;	/* ordinal number of var refrenced */
X	register int status;	/* status return */
X	register int vtype;	/* type of variable to set */
X	register char * sp;	/* scratch string pointer */
X	char var[NVSIZE+1];	/* name of variable to fetch */
X	char value[NSTRING];	/* value to set variable to */
X
X	/* first get the variable to set.. */
X	if (clexec == FALSE) {
X		status = mlreply("Variable to set: ", &var[0], NVSIZE);
X		if (status != TRUE)
X			return(status);
X	} else {	/* macro line argument */
X		/* grab token and skip it */
X		execstr = token(execstr, var);
X	}
X
X	/* check the legality and find the var */
Xsv01:	vtype = -1;
X	switch (var[0]) {
X
X		case '$': /* check for legal enviromnent var */
X			for (vnum = 0; vnum < NEVARS; vnum++)
X				if (strcmp(&var[1], envars[vnum]) == 0) {
X					vtype = TKENV;
X					break;
X				}
X			break;
X
X		case '%': /* check for existing legal user variable */
X			for (vnum = 0; vnum < MAXVARS; vnum++)
X				if (strcmp(&var[1], uv[vnum].u_name) == 0) {
X					vtype = TKVAR;
X					break;
X				}
X			if (vnum < MAXVARS)
X				break;
X
X			/* create a new one??? */
X			for (vnum = 0; vnum < MAXVARS; vnum++)
X				if (uv[vnum].u_name[0] == 0) {
X					vtype = TKVAR;
X					strcpy(uv[vnum].u_name, &var[1]);
X					break;
X				}
X			break;
X
X		case '&':	/* indirect operator? */
X			var[4] = 0;
X			if (strcmp(&var[1], "ind") == 0) {
X				/* grab token, and eval it */
X				execstr = token(execstr, var);
X				strcpy(var, getval(var));
X				goto sv01;
X			}
X	}
X
X	/* if its not legal....bitch */
X	if (vtype == -1) {
X		mlwrite("%%No such variable");
X		return(FALSE);
X	}
X
X	/* get the value for that variable */
X	if (f == TRUE)
X		strcpy(value, itoa(n));
X	else {
X		status = mlreply("Value: ", &value[0], NSTRING);
X		if (status != TRUE)
X			return(status);
X	}
X
X	/* and set the appropriate value */
X	status = TRUE;
X	switch (vtype) {
X	case TKVAR: /* set a user variable */
X		if (uv[vnum].u_value != NULL)
X			free(uv[vnum].u_value);
X		sp = malloc(strlen(value) + 1);
X		if (sp == NULL)
X			return(FALSE);
X		strcpy(sp, value);
X		uv[vnum].u_value = sp;
X		break;
X
X	case TKENV: /* set an environment variable */
X		status = TRUE;	/* by default */
X		switch (vnum) {
X		case EVFILLCOL:	fillcol = atoi(value);
X				break;
X		case EVPAGELEN:	status = newsize(TRUE, atoi(value));
X				break;
X		case EVCURCOL:	status = setccol(atoi(value));
X				break;
X		case EVCURLINE:	status = gotoline(TRUE, atoi(value));
X				break;
X		case EVRAM:	break;
X		case EVFLICKER:	flickcode = stol(value);
X				break;
X		case EVCURWIDTH:status = newwidth(TRUE, atoi(value));
X				break;
X		case EVCBUFNAME:strcpy(curbp->b_bname, value);
X				curwp->w_flag |= WFMODE;
X				break;
X		case EVCFNAME:	strcpy(curbp->b_fname, value);
X				curwp->w_flag |= WFMODE;
X				break;
X		case EVSRES:	status = TTrez(value);
X				break;
X		case EVDEBUG:	macbug = stol(value);
X				break;
X		case EVSTATUS:	cmdstatus = stol(value);
X				break;
X		}
X		break;
X	}
X	return(status);
X}
X
X/*	atoi:	ascii string to integer......This is too
X		inconsistant to use the system's	*/
X
Xatoi(st)
X
Xchar *st;
X
X{
X	int result;	/* resulting number */
X	int sign;	/* sign of resulting number */
X	char c;		/* current char being examined */
X
X	result = 0;
X	sign = 1;
X	while ((c = *st++)) {
X		if (c == '-')
X			sign *= -1;
X		if (c >= '0' && c <= '9')
X			result = result * 10 + c - '0';
X	}
X
X	return(result * sign);
X}
X
X/*	itoa:	integer to ascii string.......... This is too
X		inconsistant to use the system's	*/
X
Xchar *itoa(i)
X
Xint i;	/* integer to translate to a string */
X
X{
X	register int digit;		/* current digit being used */
X	register char *sp;		/* pointer into result */
X	register int sign;		/* sign of resulting number */
X	static char result[INTWIDTH+1];	/* resulting string */
X
X	/* eliminate the trivial 0 */
X	if (i == 0)
X		return("0");
X
X	/* record the sign...*/
X	sign = 1;
X	if (i < 0) {
X		sign = -1;
X		i = -i;
X	}
X
X	/* and build the string (backwards!) */
X	sp = result + INTWIDTH;
X	*sp = 0;
X	while (i) {
X		digit = i % 10;
X		*(--sp) = '0' + digit;	/* and install the new digit */
X		i = i / 10;
X	}
X
X	/* and fix the sign */
X	if (sign == -1) {
X		*(--sp) = '-';	/* and install the minus sign */
X	}
X
X	return(sp);
X}
X
Xint gettyp(token)	/* find the type of a passed token */
X
Xchar *token;	/* token to analyze */
X
X{
X	register char c;	/* first char in token */
X
X	/* grab the first char (this is all we need) */
X	c = *token;
X
X	/* no blanks!!! */
X	if (c == 0)
X		return(TKNUL);
X
X	/* a numeric literal? */
X	if (c >= '0' && c <= '9')
X		return(TKLIT);
X
X	switch (c) {
X		case '"':	return(TKSTR);
X
X		case '!':	return(TKDIR);
X		case '@':	return(TKARG);
X		case '#':	return(TKBUF);
X		case '$':	return(TKENV);
X		case '%':	return(TKVAR);
X		case '&':	return(TKFUN);
X		case '*':	return(TKLBL);
X
X		default:	return(TKCMD);
X	}
X}
X
Xchar *getval(token)	/* find the value of a token */
X
Xchar *token;		/* token to evaluate */
X
X{
X	register int status;	/* error return */
X	register BUFFER *bp;	/* temp buffer pointer */
X	register int blen;	/* length of buffer argument */
X	char buf[NSTRING];	/* string buffer for some returns */
X
X	switch (gettyp(token)) {
X		case TKNUL:	return("");
X
X		case TKARG:	/* interactive argument */
X				status = getstring(getval(&token[1]),
X					   buf, NSTRING, ctoec('\n'));
X				if (status == ABORT)
X					return(errorm);
X				return(buf);
X
X		case TKBUF:	/* buffer contents fetch */
X
X				/* grab the right buffer */
X				bp = bfind(getval(&token[1]), FALSE, 0);
X				if (bp == NULL)
X					return(errorm);
X		
X				/* make sure we are not at the end */
X				if (bp->b_linep == bp->b_dotp)
X					return(errorm);
X		
X				/* grab the line as an argument */
X				blen = bp->b_dotp->l_used;
X				if (blen > NSTRING)
X					blen = NSTRING;
X				strncpy(buf, bp->b_dotp->l_text, blen);
X				buf[blen] = 0;
X		
X				/* and step the buffer's line ptr ahead a line */
X				bp->b_dotp = bp->b_dotp->l_fp;
X				bp->b_doto = 0;
X
X				/* and return the spoils */
X				return(buf);		
X
X		case TKVAR:	return(gtusr(token+1));
X		case TKENV:	return(gtenv(token+1));
X		case TKFUN:	return(gtfun(token+1));
X		case TKDIR:	return(errorm);
X		case TKLBL:	return(itoa(gtlbl(token)));
X		case TKLIT:	return(token);
X		case TKSTR:	return(token+1);
X		case TKCMD:	return(token);
X	}
X}
X
Xgtlbl(token)	/* find the line number of the given label */
X
Xchar *token;	/* label name to find */
X
X{
X	return(1);
X}
X
Xint stol(val)	/* convert a string to a numeric logical */
X
Xchar *val;	/* value to check for stol */
X
X{
X	/* check for logical values */
X	if (val[0] == 'F')
X		return(FALSE);
X	if (val[0] == 'T')
X		return(TRUE);
X
X	/* check for numeric truth (!= 0) */
X	return((atoi(val) != 0));
X}
X
Xchar *ltos(val)		/* numeric logical to string logical */
X
Xint val;	/* value to translate */
X
X{
X	if (val)
X		return(truem);
X	else
X		return(falsem);
X}
END_OF_eval.c
if test 10700 -ne `wc -c <eval.c`; then
    echo shar: \"eval.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"menu.cmd\" \(11966 characters\)
if test -f menu.cmd ; then 
  echo shar: Will not over-write existing file \"menu.cmd\"
else
sed "s/^X//" >menu.cmd <<'END_OF_menu.cmd'
X;	MENU.CMD:	Menu learning system for MicroEMACS 3.7
X;
X;			This file is executed to activate MicroEMACS's
X;			menu interface code
X
X;	setup windows for use
X
X	add-global-mode "blue"
X	1 split-current-window
X	5 resize-window
X	add-mode "red"
X	view-file "menu1"
X	name-buffer "menu window"
X	change-file-name ""
X	add-mode "view"
X	next-window
X
X;	Load menu routines as needed
X
X;	Activate Main Menu
X
X1	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<01"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key execute-macro-3	FN;
X	bind-to-key execute-macro-4	FN<
X	bind-to-key execute-macro-5	FN=
X	bind-to-key execute-macro-6	FN>
X	bind-to-key execute-macro-7	FN?
X	bind-to-key execute-macro-8	FN@
X	bind-to-key execute-macro-9	FNA
X	bind-to-key execute-macro-2	FNB
X	bind-to-key execute-macro-10	FNC
X	bind-to-key exit-emacs		FND
X	clear-message-line
X!endm
X
X;	and bring that menu up
X
X	execute-macro-1
X	write-message "         [loading MENU system]"
X
X;	set up the editor control menu
X
X2	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<02"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key execute-macro-11	FN;
X	bind-to-key execute-macro-12	FN<
X	bind-to-key execute-macro-13	FN=
X	bind-to-key execute-macro-14	FN>
X	bind-to-key execute-macro-15	FN?
X	bind-to-key execute-macro-16	FN@
X	bind-to-key execute-macro-17	FNA
X	bind-to-key execute-macro-18	FNB
X	bind-to-key execute-macro-19	FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X!endm
X
X;	Activate word case/screen control Menu
X
X3	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<03"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key case-word-upper	FN;
X	bind-to-key case-region-upper	FN<
X	bind-to-key case-word-lower	FN=
X	bind-to-key case-region-lower	FN>
X	bind-to-key case-word-capitalize FN?
X	unbind-key FN@
X	bind-to-key clear-and-redraw	FNA
X	bind-to-key set-mark		FNB
X	bind-to-key redraw-display	FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X!endm
X
X;	Activate paging/scrolling Menu
X
X4	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<08"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key previous-page	FN;
X	bind-to-key next-page		FN<
X	bind-to-key move-window-down	FN=
X	bind-to-key move-window-up	FN>
X	bind-to-key scroll-next-up	FN?
X	unbind-key 			FN@
X	bind-to-key scroll-next-down	FNA
X	unbind-key 			FNB
X	bind-to-key exchange-point-and-mark FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X!endm
X
X;	Activate cut & paste Menu
X
X5	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<04"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key set-mark		FN;
X	unbind-key FN<
X	bind-to-key kill-region		FN=
X	unbind-key FN>
X	bind-to-key copy-region		FN?
X	unbind-key FN@
X	bind-to-key yank		FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X!endm
X
X;	Activate Search & replace Menu
X
X6	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<09"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key search-forward	FN;
X	bind-to-key search-reverse	FN<
X	bind-to-key hunt-forward	FN=
X	bind-to-key hunt-backward	FN>
X	bind-to-key incremental-search	FN?
X	bind-to-key reverse-incremental-search FN@
X	bind-to-key replace-string	FNA
X	bind-to-key query-replace-string FNB
X	unbind-key FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X!endm
X
X;	Activate Deletion Menu
X
X7	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<05"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key delete-previous-character FN;
X	unbind-key FN<
X	bind-to-key delete-next-character FN=
X	unbind-key FN>
X	bind-to-key kill-to-end-of-line	FN?
X	unbind-key FN@
X	bind-to-key delete-blank-lines	FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X!endm
X
X;	Activate Word procesing Menu
X
X8	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<10"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key previous-word	FN;
X	bind-to-key next-word		FN<
X	bind-to-key previous-paragraph	FN=
X	bind-to-key next-paragraph	FN>
X	bind-to-key fill-paragraph	FN?
X	bind-to-key kill-paragraph	FN@
X	bind-to-key delete-previous-word FNA
X	bind-to-key delete-next-word	FNB
X	bind-to-key count-words		FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X!endm
X
X;	Activate Insertion Menu
X
X9	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<06"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key open-line		FN;
X	bind-to-key insert-string	FN<
X	bind-to-key handle-tab		FN=
X	bind-to-key quote-character	FN>
X	bind-to-key insert-space	FN?
X	bind-to-key transpose-characters FN@
X	bind-to-key newline-and-indent	FNA
X	unbind-key FNB
X	bind-to-key newline		FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X!endm
X
X;	Activate Cursor movement Menu
X
X10	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<07"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key beginning-of-file	FN;
X	bind-to-key previous-line	FN<
X	bind-to-key backward-character	FN=
X	bind-to-key forward-character	FN>
X	bind-to-key end-of-file		FN?
X	bind-to-key next-line		FN@
X	bind-to-key beginning-of-line	FNA
X	bind-to-key end-of-line		FNB
X	bind-to-key execute-macro-21	FNC
X	bind-to-key execute-macro-1	FND
X	clear-message-line
X!endm
X
X21	store-macro
X	@"Line number to go to: " goto-line
X!endm
X
X;	Activate Buffer Menu
X
X11	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<11"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key buffer-position	FN;
X	bind-to-key unmark-buffer	FN<
X	bind-to-key delete-buffer	FN=
X	bind-to-key next-buffer		FN>
X	bind-to-key list-buffers	FN?
X	bind-to-key execute-macro-22	FN@
X	bind-to-key name-buffer		FNA
X	unbind-key FNB
X	bind-to-key select-buffer	FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X!endm
X
X22	store-macro
X	filter-buffer @"Name of DOS filter: "
X!endm
X;	Macro Menu
X
X12	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<11"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key begin-macro		FN;
X	unbind-key FN<
X	bind-to-key end-macro		FN=
X	unbind-key FN>
X	bind-to-key execute-macro	FN?
X	unbind-key FN@
X	unbind-key FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X!endm
X
X;	Color change Menu
X
X13	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<12"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key execute-macro-23	FN;
X	unbind-key FN<
X	bind-to-key execute-macro-24	FN=
X	unbind-key FN>
X	bind-to-key execute-macro-25	FN?
X	unbind-key FN@
X	bind-to-key execute-macro-26	FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X!endm
X
X;	Set forground color
X
X23	store-macro
X	save-window
X	1 next-window
X	select-buffer "[color]"
X	beginning-of-file
X	insert-string @"Color to change to: "
X	newline
X	beginning-of-file
X	case-word-upper
X	beginning-of-file
X	unmark-buffer
X	select-buffer "menu window"
X	1 redraw-display
X	restore-window
X	add-mode #"[color]"
X	delete-buffer "[color]"
X!endm
X
X;	Set background color
X
X24	store-macro
X	save-window
X	1 next-window
X	select-buffer "[color]"
X	beginning-of-file
X	insert-string @"Color to change to: "
X	newline
X	beginning-of-file
X	case-word-lower
X	beginning-of-file
X	unmark-buffer
X	select-buffer "menu window"
X	1 redraw-display
X	restore-window
X	add-mode #"[color]"
X	delete-buffer "[color]"
X!endm
X
X;	Set global forground color
X
X25	store-macro
X	save-window
X	1 next-window
X	select-buffer "[color]"
X	beginning-of-file
X	insert-string @"Color to change to: "
X	newline
X	beginning-of-file
X	case-word-upper
X	beginning-of-file
X	unmark-buffer
X	select-buffer "menu window"
X	1 redraw-display
X	restore-window
X	add-global-mode #"[color]"
X	delete-buffer "[color]"
X!endm
X
X;	Set global background color
X
X26	store-macro
X	save-window
X	1 next-window
X	select-buffer "[color]"
X	beginning-of-file
X	insert-string @"Color to change to: "
X	newline
X	beginning-of-file
X	case-word-lower
X	beginning-of-file
X	unmark-buffer
X	select-buffer "menu window"
X	1 redraw-display
X	restore-window
X	add-global-mode #"[color]"
X	delete-buffer "[color]"
X!endm
X
X;	set Mode Menu
X
X14	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<17"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key add-mode		FN;
X	bind-to-key add-global-mode	FN<
X	bind-to-key delete-mode		FN=
X	bind-to-key delete-global-mode	FN>
X	unbind-key FN?
X	bind-to-key execute-macro-27	FN@
X	unbind-key FNA
X	unbind-key FNB
X	bind-to-key select-buffer	FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X!endm
X
X27	store-macro
X	@"Column to fill to: " set-fill-column
X!endm
X
X;	DOS command Menu
X
X15	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<13"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key shell-command	FN;
X	unbind-key FN<
X	bind-to-key pipe-command	FN=
X	unbind-key FN>
X	bind-to-key i-shell		FN?
X	unbind-key FN@
X	bind-to-key quick-exit		FNA
X	unbind-key FNB
X	bind-to-key exit-emacs		FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X!endm
X
X;	Script Menu
X
X16	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<18"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key execute-file	FN;
X	bind-to-key execute-command-line FN<
X	bind-to-key execute-buffer	FN=
X	bind-to-key execute-named-command FN>
X	unbind-key FN?
X	unbind-key FN@
X	unbind-key FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X!endm
X
X;	File access Menu
X
X17	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<14"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key find-file		FN;
X	bind-to-key save-file		FN<
X	bind-to-key view-file		FN=
X	bind-to-key write-file		FN>
X	bind-to-key read-file		FN?
X	bind-to-key change-file-name	FN@
X	bind-to-key insert-file		FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X!endm
X
X;	Window Menu
X
X18	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<19"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key split-current-window FN;
X	bind-to-key delete-other-windows FN<
X	bind-to-key resize-window	FN=
X	bind-to-key delete-window	FN>
X	bind-to-key shrink-window	FN?
X	bind-to-key grow-window		FN@
X	bind-to-key next-window		FNA
X	bind-to-key previous-window	FNB
X	unbind-key FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X!endm
X
X;	key binding Menu
X
X19	store-macro
X	save-window
X	1 next-window
X	beginning-of-file
X	search-forward "<<15"
X	next-line
X	1 redraw-display
X	restore-window
X	update-screen
X
X;	***** Rebind the Function key group
X
X	bind-to-key bind-to-key		FN;
X	unbind-key FN<
X	bind-to-key unbind-key		FN=
X	unbind-key FN>
X	bind-to-key describe-key	FN?
X	unbind-key FN@
X	bind-to-key describe-bindings	FNA
X	unbind-key FNB
X	unbind-key FNC
X	bind-to-key execute-macro-2	FND
X	clear-message-line
X!endm
X
X	clear-message-line
END_OF_menu.cmd
if test 11966 -ne `wc -c <menu.cmd`; then
    echo shar: \"menu.cmd\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"st520.c\" \(10316 characters\)
if test -f st520.c ; then 
  echo shar: Will not over-write existing file \"st520.c\"
else
sed "s/^X//" >st520.c <<'END_OF_st520.c'
X/*
X
XThe routines in this file provide support for the Atari ST520 or 1040
Xusing VT52 emulation.  The I/O services are provided by routines in
X"termio.c".  It compiles into nothing if not a ST520 style device.  The
Xbell on the ST520 is terrible, so the "beep" routine is conditionalized
Xon defining BEL. 
X
X*/
X
X#define	termdef	1			/* don't define "term" external */
X
X#include        <stdio.h>
X#include        "estruct.h"
X#include	"edef.h"
X
X#if MEGAMAX
Xoverlay "st520"
X#endif
X
X#if     ATARI & ST520 & MEGAMAX
X#include	<osbind.h>
X#include	<ctype.h>
X
X#define LINEA_INIT 0xA000
X#define V_CEL_WR   -0x28
X#define V_CEL_MY   -0x2a
X#define V_CEL_HT   -0x2e
X#define V_FNT_AD   -0x16
X#define V_OFF_AD   -0x0a
X#define V_DISAB    -346
X
X#define NROW    24                      /* Screen size.                 */
X#define NCOL    80                      /* Edit if you want to.         */
X#define	MARGIN	8			/* size of minimim margin and	*/
X#define	SCRSIZ	64			/* scroll size for extended lines */
X#define	NPAUSE	25			/* # times thru update to pause */
X#define BIAS    0x20                    /* Origin 0 coordinate bias.    */
X#define ESC     0x1B                    /* ESC character.               */
X#define BEL     0x07                    /* ascii bell character         */
X
Xextern  int     ttopen();               /* Forward references.          */
Xextern  int     ttgetc();
Xextern  int     ttputc();
Xextern  int     ttflush();
Xextern  int     ttclose();
Xextern  int     st520move();
Xextern  int     st520eeol();
Xextern  int     st520eeop();
Xextern  int     st520beep();
Xextern  int     st520open();
Xextern	int	st520close();
Xextern	int	st520rev();
Xextern	int	st520cres();
Xextern  int st520kopen();
Xextern  int st520kclose();
X
X#if	COLOR
Xextern	int	st520fcol();
Xextern	int	st520bcol();
X
Xint		cfcolor = -1;		/* current fg (character) color */
Xint		cbcolor = -1;		/* current bg color */
Xint		oldpal[8];		/* pallette when emacs was invoked */
Xint		newpal[8] = {		/* default emacs pallette */
X	0x000, 0x700, 0x070, 0x770, 0x007, 0x707, 0x077, 0x777};
X#endif
X
Xint STncolors = 0;		/* number of colors  */
Xint STrez;			/* physical screen resolution */	
X
X/*
X * Dispatch table. All the
X * hard fields just point into the
X * terminal I/O code.
X */
XTERM    term    = {
X        NROW-1,
X        NCOL,
X	MARGIN,
X	MARGIN,
X	SCRSIZ,
X	NPAUSE,
X        &st520open,
X        &st520close,
X	&st520kopen,
X	&st520kclose,
X        &ttgetc,
X        &ttputc,
X        &ttflush,
X        &st520move,
X        &st520eeol,
X        &st520eeop,
X        &st520beep,
X        &st520rev,
X        &st520cres
X#if	COLOR
X	, &st520fcol,
X	&st520bcol
X#endif
X};
X	struct KBDvecs {
X		int (*midivec) ();
X		int (*vkbderr) ();
X		int (*vmiderr) ();
X		int (*statvec) ();
X		int (*mousevec) ();
X		int (*clockvec) ();
X		int (*joyvec) ();
X		int (*midisys) ();
X		int (*ikbdsys) ();
X	};
X	struct Param {
X		char topmode;
X		char buttons;
X		char xparam;
X		char yparam;
X		int xmax,ymax;
X		int xinitial,yinitial;
X	};
X	struct KBDvecs *kbdvecs;
X	struct Param *paramp;
X	char kbdcmds[25];
X
Xst520move(row, col)
X{
X        ttputc(ESC);
X        ttputc('Y');
X        ttputc(row+BIAS);
X        ttputc(col+BIAS);
X}
X
Xst520eeol()
X{
X        ttputc(ESC);
X        ttputc('K');
X}
X
Xst520eeop()
X{
X
X#if	COLOR
X		st520fcol(gfcolor);
X		st520bcol(gbcolor);
X#endif
X        ttputc(ESC);
X        ttputc('J');
X}
X
Xst520rev(status)	/* set the reverse video state */
X
Xint status;	/* TRUE = reverse video, FALSE = normal video */
X
X{
X
X	if(status) {
X		ttputc(ESC);
X		ttputc('p');
X	}
X	else {
X		ttputc(ESC);
X		ttputc('q');
X	}
X}
X
X#if	COLOR
Xst520fcol(color)
Xint color;	
X{
X		if(color == cfcolor || !STncolors)
X			return;
X		else {
X
X			ttputc(ESC);
X			ttputc('b');
X			ttputc(color & 0x0f);
X			cfcolor = color;
X		}
X}
X
Xst520bcol(color)
Xint color;
X{
X		if(color == cbcolor || !STncolors)
X			return;
X		else {
X			ttputc(ESC);
X			ttputc('c');
X			ttputc(color & 0x0f);
X			cbcolor = color;
X		}
X
X}
X#endif
X
Xst520beep()
X{
X#ifdef  BEL
X        ttputc(BEL);
X        ttflush();
X#endif
X}
X
Xst520open()
X{
X	int i,j,k;
X	long phys, log;	/* screen bases */
X	
X/* IMPORTANT: it is ABSOLUTELY necessary that the default resolution be the
X *	largest possible so that display will allocate (malloc) the maximum
X *	size for the VIDEO arrray
X */
X	STrez = Getrez();
X	switch(STrez) {
X		case 0: /* low res 25x40 16 colors */
X			strcpy(sres, "LOW");
X			phys = Physbase();
X			log  = Logbase();
X			Setscreen(log, phys, 1);
X			STrez = 1;
X			/* fall thru to med res */
X
X		case 1: /* med res 25x80 4 colors */
X			if (STrez == 1) strcpy(sres, "MEDIUM");
X			term.t_nrow = 25 - 1;
X			term.t_ncol  = 80;
X			grez = 1;
X#if	COLOR
X			STncolors = 4;
X			for(i=0;i<8;i++) {
X				oldpal[i] = Setcolor(i,newpal[i]);
X			}
X#endif
X			break;
X		case 2: /* high res 25x80 no colors */
X			strcpy(sres, "HIGH");
X			term.t_nrow  = 40 - 1;
X			term.t_ncol  = 80;
X			grez = 2;
X			make_8x10(); /* create a smaller font */
X			set_40();    /* and go to 40 line mode */
X#if	COLOR
X			STncolors = 0;
X#endif
X			break;
X	}
X
X	revexist = TRUE;
X	eolexist = TRUE;
X	paramp = (struct Param *)malloc(sizeof(struct Param));
X	kbdvecs = (struct KBDvecs *)Kbdvbase();
X	paramp -> topmode = 0;
X	paramp -> buttons = 4;
X	paramp -> xparam = 8;
X	paramp -> yparam = 10;
X	paramp -> xmax = 79;
X	paramp -> ymax = 23;
X	paramp -> xinitial = 0;
X	paramp -> yinitial = 0;
X	Initmous(1,paramp,kbdvecs -> mousevec);
X
X	i = 0;
X	kbdcmds[i++] = 0x0a;	/*set mouse keycode mode */
X	kbdcmds[i++] = 0x08;
X	kbdcmds[i++] = 0x0a;
X	Ikbdws(i-1,&kbdcmds[0]);
X	Cursconf(1,0);
X	Cursconf(3,0);
X	Cconout(27);Cconout('E');
X        ttopen();
X}
X
Xst520close()
X
X{
X	int i,j,k;
X
X	i = 0;
X	kbdcmds[i++] = 0x80;	/*reset mouse keycode mode */
X	kbdcmds[i++] = 0x01;
X	Ikbdws(i-1,&kbdcmds[0]);
X	if(grez == 2 && STrez == 2) /* b/w monitor in 40 row mode */
X		restore();
X
X#if		COLOR
X	for(i=0;i<STncolors;i++)
X		Setcolor(i,oldpal[i]);
X#endif
X	Cconout(27);Cconout('E');
X	paramp -> buttons = 0;
X	Initmous(2,paramp,kbdvecs -> mousevec);
X	i = 0;
X	kbdcmds[i++] = 0x80;	/*reset the keyboard*/
X	kbdcmds[i++] = 0x01;
X	Ikbdws(i-1,&kbdcmds[0]);
X	Cursconf(1,0);
X	ttclose();
X}
Xst520kopen()
X{
X
X}
Xst520kclose()
X{
X
X}
X
Xst520cres(res)		/* change screen resolution */
X
Xchar *res;		/* resolution to change to */
X
X{
X	register int nurez;	/* number of res to change to */
X	int ierr, i, j ,k;
X	long phys, log;	/* screen bases */
X	char dum[80]; /* for debugging only */
X
X	/* determine the needed resolution */
X	if (strcmp(res, "LOW") == 0)
X		nurez = 1;
X	else if (strcmp(res, "MEDIUM") == 0)
X		nurez = 2;
X	else if (strcmp(res, "HIGH") == 0)
X		nurez = 3;
X	else
X		return(FALSE);
X
X	if(grez == nurez)
X		return(TRUE);
X		
X	if(STrez == 2) { /* b/w monitor-only allow hi | med rez */
X		switch(nurez) {
X			case 2: /* high res */
X				term.t_nrow  = 40 - 1;
X				term.t_ncol  = 80;
X				make_8x10(); /* create a smaller font */
X				set_40();    /* and go to 40 line mode */
X				grez = 2;
X				sgarbf = TRUE;
X				onlywind(1,1);
X				strcpy(sres, "HIGH");
X				break;
X			case 1: /* med res */
X				term.t_nrow  = 25 - 1;
X				term.t_ncol  = 80;
X				restore();
X				grez = 1;
X				sgarbf = TRUE;
X				onlywind(1,1);
X				strcpy(sres, "MEDIUM");
X				break;
X			default:
X				mlwrite("Invalid resolution");
X				return(FALSE);
X				break;
X		}
X	}
X	else { /* color monitor-only allow low | medium resolution */
X		phys = Physbase();
X		log  = Logbase();
X		switch(nurez) {
X			case 1:
X				term.t_nrow  = 25 - 1;
X				term.t_ncol  = 80;
X				Setscreen(log, phys, 1);
X				STncolors = 4;
X				grez = 1;
X				sgarbf = TRUE;
X				onlywind(1,1);
X				strcpy(sres, "LOW");
X				break;
X			case 0:
X				term.t_nrow  = 25 - 1;
X				term.t_ncol  = 40;
X				Setscreen(log, phys, 0);
X				STncolors = 8;
X				grez = 0;
X				sgarbf = TRUE;
X				onlywind(1,1);
X				strcpy(sres, "MEDIUM");
X				break;
X			default:
X				mlwrite("%Invalid resolution");
X				return(FALSE);
X				break;
X		}
X	}
X	return(TRUE);
X}			
X
XSTcurblink(onoff)
Xint onoff;
X{
X	if(onoff)
X		Cursconf(2,0);
X	else
X		Cursconf(3,0);
X}
X
X
Xchar parm_save[28];
Xlong fnt_8x10[640];
X
Xmake_8x10()
X{
X	int i,j,k;
X	long savea23[2];
X	
X	for(i=0;i<640;i++)
X		fnt_8x10[i] = 0;
X		
X	asm {
X	movem.l	A2-A3,savea23(A6)
X	
X	dc.w	LINEA_INIT		;A1 -> array of font headers
X
X	lea	parm_save(A4),A2	;A2 -> parameters savearea
X	move.l	V_OFF_AD(A0),(A2)+
X	move.l	V_FNT_AD(A0),(A2)+
X	move.w	V_CEL_HT(A0),(A2)+
X	move.w	V_CEL_MY(A0),(A2)+
X	move.w	V_CEL_WR(A0),(A2)+
X
X
X	move.l	04(A1),A1		; A1 -> 8x8 font header
X	move.l	76(A1),A2		; A2 -> 8x8 font data
X	lea	fnt_8x10+0x100(A4),A3	; A3 -> 2nd line of font buffer
X	move.w	#0x200-1,D0		; D0 <- longword counter for font xfer
X
Xfnt_loop:
X
X	move.l	(A2)+,(A3)+
X	dbf	D0,fnt_loop
X		
X	movem.l	savea23(A6),A2-A3
X	}
X	
X}
X
Xset_40()
X{
X	long	savea23[2];
X	
X	asm {
X	
X;
X;  use the 8x10 character set: 40 line mode
X;
X
X	movem.l	A2-A3,savea23(A6)
X	
X	dc.w	LINEA_INIT
X
X	move.l	04(A1),A1		; A1 -> 8x8 font header
X	move.l	72(A1),V_OFF_AD(A0)	; v_off_ad <- 8x8  offset table addr
X	lea	fnt_8x10(A4),A2
X	move.l	A2,V_FNT_AD(A0)		; v_fnt_ad <- 8x10 font data addr
X
X	move.w	#10,V_CEL_HT(A0)	; v_cel_ht <- 10   8x10 cell height
X	move.w	#39,V_CEL_MY(A0)	; v_cel_my <- 39   maximum cell "Y"
X	move.w	#800,V_CEL_WR(A0)	; v_cel_wr <- 800  offset to cell Y+1
X
X	movem.l savea23,A2-A3
X	}
X}
X
Xset_20()
X{
X	long	savea23[2];
X
X	asm {
X		
X;
X;  use the 8x10 character set: 20 line mode
X;
X
X	movem.l	A2-A3,savea23(A6)
X	
X	dc.w	LINEA_INIT		; A0 -> line A variables
X
X	move.l	04(A1),A1		; A1 -> 8x8 font header
X	move.l	72(A1),V_OFF_AD(A0)	; v_off_ad <- 8x8  offset table addr
X	lea	fnt_8x10(A4),A2
X	move.l	A2,V_FNT_AD(A0)		; v_fnt_ad <- 8x10 font data addr
X
X	move.w	#10,V_CEL_HT(A0)	; v_cel_ht <- 10   8x10 cell height
X	move.w	#19,V_CEL_MY(A0)	; v_cel_my <- 19   maximum cell "Y"
X	move.w	#1600,V_CEL_WR(A0)	; v_cel_wr <- 800  offset to cell Y+1
X	
X	movem.l	savea23,A2-A3
X	}
X}
X
X
Xrestore()
X{
X	long savea23[2];
X	
X	asm {
X	
X;  return what was saved in parameter save zone	
X
X	movem.l	A2-A3,savea23(A6)
X
X	dc.w	LINEA_INIT		; a0 -> line A variables
X
X	lea	parm_save(A4),A2	; a2 -> parameter save area
X	move.l	(A2)+,V_OFF_AD(A0)
X	move.l	(A2)+,V_FNT_AD(A0)
X	move.w	(A2)+,V_CEL_HT(A0)
X	move.w	(A2)+,V_CEL_MY(A0)
X	move.w	(A2)+,V_CEL_WR(A0)
X	
X	movem.l	savea23(A6),A2-A3
X	}          
X}
XGetCurStat(onoff)
Xint	onoff;
X{
X	long savea23[2];
X
X	asm {
X	movem.l	A2-A3,savea23(A6)
X
X	dc.w	LINEA_INIT		; a0 -> line A variables
X	move.w	V_DISAB(A0),onoff(A6)	; 0 = cursor visible
X	moveq	#0,D0
X	move.w	V_DISAB(A0),D0	
X	movem.l	savea23(A6),A2-A3
X	}          
X}
X#else
Xsthello()
X{
X}
X#endif
X
END_OF_st520.c
if test 10316 -ne `wc -c <st520.c`; then
    echo shar: \"st520.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 4 \(of 14\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    echo "See the readme file"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
