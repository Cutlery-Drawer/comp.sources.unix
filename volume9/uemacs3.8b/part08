Subject:  v09i040:  MicroEMACS, version 3.8b, Part08/14
Newsgroups: mod.sources
Approved: rs@mirror.TMC.COM

Submitted by: ihnp4!itivax!duncan!lawrence (Daniel Lawrence)
Mod.sources: Volume 9, Issue 40
Archive-name: uemacs3.8b/Part08

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If this archive is complete, you will see the message:
#		"End of archive 8 (of 14)."
# Contents:  estruct.h readme
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"estruct.h\" \(18184 characters\)
if test -f estruct.h ; then 
  echo shar: Will not over-write existing file \"estruct.h\"
else
sed "s/^X//" >estruct.h <<'END_OF_estruct.h'
X/*	ESTRUCT:	Structure and preprocesser defined for
X			MicroEMACS 3.8
X
X			written by Dave G. Conroy
X			modified by Steve Wilhite, George Jones
X			greatly modified by Daniel Lawrence
X*/
X
X#ifdef	LATTICE
X#undef	LATTICE		/* don't use their definitions...use ours	*/
X#endif
X#ifdef	MSDOS
X#undef	MSDOS
X#endif
X#ifdef	CPM
X#undef	CPM
X#endif
X#ifdef	AMIGA
X#undef	AMIGA
X#endif
X
X/*	Version definition			*/
X
X#define	VERSION	"3.8b"
X
X/*	Machine/OS definitions			*/
X
X#define AMIGA   0                       /* AmigaDOS			*/
X#define ST520   0                       /* ST520, TOS                   */
X#define MSDOS   1                       /* MS-DOS                       */
X#define V7      0                       /* V7 UN*X or Coherent or BSD4.2*/
X#define	BSD	0			/* UNIX BSD 4.2	and ULTRIX	*/
X#define	USG	0			/* UNIX system V		*/
X#define VMS     0                       /* VAX/VMS                      */
X#define CPM     0                       /* CP/M-86                      */
X#define	FINDER	0			/* Macintosh OS			*/
X
X/*	Compiler definitions			*/
X#define MWC86   0	/* marc williams compiler */
X#define	LATTICE	0	/* Lattice 2.14 thruough 3.0 compilers */
X#define	AZTEC	1	/* Aztec C 3.20e */
X#define	MSC	0	/* MicroSoft C compile version 3 */
X#define MEGAMAX 0	/* Megamax C compiler */
X
X/*	Profiling options	*/
X#define	APROF	0	/* turn Aztec C profiling on? */
X#define	NBUCK	100	/* number of buckets to profile */
X#define	RAMSIZE	0	/* dynamic RAM memory usage tracking */
X#define	RAMSHOW	0	/* auto dynamic RAM reporting */
X
X/*   Special keyboard definitions            */
X
X#define WANGPC	0		/* WangPC - mostly escape sequences     */
X 
X/*	Terminal Output definitions		*/
X
X#define ANSI    0			/* ansi escape sequences	*/
X#define	HP150	0			/* HP150 screen driver		*/
X#define	HP110	0			/* HP110 screen driver		*/
X#define	VMSVT	0			/* various VMS terminal entries	*/
X#define VT52    0                       /* VT52 terminal (Zenith).      */
X#define VT100   0                       /* Handle VT100 style keypad.   */
X#define LK201   0                       /* Handle LK201 style keypad.   */
X#define RAINBOW 0                       /* Use Rainbow fast video.      */
X#define TERMCAP 0                       /* Use TERMCAP                  */
X#define	IBMPC	1			/* IBM-PC CGA/MONO driver	*/
X#define	EGA	0			/* EGA IBM-PC specific driver	*/
X#define	DG10	0			/* Data General system/10	*/
X#define	TIPC	0			/* TI Profesional PC driver	*/
X#define	MAC	0			/* Macintosh			*/
X#define	ATARI	0			/* Atari 520/1040ST screen	*/
X
X/*	Configuration options	*/
X
X#define CVMVAS  1	/* arguments to page forward/back in pages	*/
X#define	NFWORD	1	/* forward word jumps to beginning of word	*/
X#define	CLRMSG	0	/* space clears the message line with no insert	*/
X#define	ACMODE	1	/* auto CMODE on .C and .H files		*/
X#define	CFENCE	1	/* fench matching in CMODE			*/
X#define	TYPEAH	1	/* type ahead causes update to be skipped	*/
X#define DEBUGM	1	/* Global SPELL mode triggers macro debugging	*/
X#define	VISMAC	0	/* update display during keyboard macros	*/
X#define	CTRLZ	0	/* add a ^Z at end of files under MSDOS only	*/
X
X#define	REVSTA	1	/* Status line appears in reverse video		*/
X#define	COLOR	1	/* color commands and windows			*/
X
X#define	FILOCK	0	/* file locking under unix BSD 4.2		*/
X#define	ISRCH	1	/* Incremental searches like ITS EMACS		*/
X#define	WORDPRO	1	/* Advanced word processing features		*/
X#define	FLABEL	0	/* function key label code			*/
X#define	APROP	1	/* Add code for Apropos command			*/
X#define	CRYPT	1	/* file encryption enabled?			*/
X#define MAGIC	1	/* include regular expression matching?		*/
X
X#define ASCII	1	/* always using ASCII char sequences for now	*/
X#define EBCDIC	0	/* later IBM mainfraim versions will use EBCDIC	*/
X
X/*	System dependant library redefinitions, structures and includes	*/
X
X/*  Megamax C defines short to be 1 byte and int to be 2 bytes */
X#if	MEGAMAX & ST520
X#define SHORT int
X#else
X#define SHORT short
X#endif
X
X#if	AZTEC
X#undef	fputc
X#undef	fgetc
X#define	fputc	aputc
X#define	fgetc	agetc
X#define	int86	sysint
X#define	intdos(a, b)	sysint(33, a, b)
X#define	inp	inportb
X
Xstruct XREG {
X	int ax,bx,cx,dx,si,di;
X};
X
Xstruct HREG {
X	char al,ah,bl,bh,cl,ch,dl,dh;
X};
X
Xunion REGS {
X	struct XREG x;
X	struct HREG h;
X};
X#endif
X
X#if	MSDOS & MWC86
X#include	<dos.h>
X#define	int86(a, b, c)	intcall(b, c, a)
X#define	inp	in
X
Xstruct XREG {
X	int ax,bx,cx,dx,si,di,ds,es,flags;
X};
X
Xstruct HREG {
X	char al,ah,bl,bh,cl,ch,dl,dh;
X	int ds,es,flags;
X};
X
Xunion REGS {
X	struct XREG x;
X	struct HREG h;
X};
X#endif
X
X#if	MSDOS & MSC
X#include	<dos.h>
X#define	movmem(a, b, c)		memcpy(b, a, c)
X#endif
X
X#if	MSDOS & LATTICE
X#undef	CPM
X#undef	LATTICE
X#include	<dos.h>
X#undef	CPM
X#endif
X
X#if	VMS
X#define	unlink(a)	delete(a)
X#endif
X
X/*	define memory mapped flag	*/
X
X#define	MEMMAP	0
X
X#if	IBMPC
X#undef	MEMMAP
X#define	MEMMAP	1
X#endif
X
X#if	IBMMONO
X#undef	MEMMAP
X#define	MEMMAP	1
X#endif
X
X#if	EGA
X#undef	MEMMAP
X#define	MEMMAP	1
X#endif
X
X/*	internal constants	*/
X
X#define	NBINDS	256			/* max # of bound keys		*/
X#define NFILEN  80                      /* # of bytes, file name        */
X#define NBUFN   16                      /* # of bytes, buffer name      */
X#define NLINE   256                     /* # of bytes, line             */
X#define	NSTRING	128			/* # of bytes, string buffers	*/
X#define NKBDM   256                     /* # of strokes, keyboard macro */
X#define NPAT    128                     /* # of bytes, pattern          */
X#define HUGE    1000                    /* Huge number                  */
X#define	NLOCKS	100			/* max # of file locks active	*/
X#define	NCOLORS	8			/* number of supported colors	*/
X#define	KBLOCK	250			/* sizeof kill buffer chunks	*/
X#define	NBLOCK	16			/* line block chunk size	*/
X#define	NVSIZE	10			/* max #chars in a var name	*/
X
X#if	0
X#define AGRAVE  0x60                    /* M- prefix,   Grave (LK201)   */
X#define METACH  0x1B                    /* M- prefix,   Control-[, ESC  */
X#define CTMECH  0x1C                    /* C-M- prefix, Control-\       */
X#define EXITCH  0x1D                    /* Exit level,  Control-]       */
X#define CTRLCH  0x1E                    /* C- prefix,   Control-^       */
X#define HELPCH  0x1F                    /* Help key,    Control-_       */
X#endif
X
X#define CTRL    0x0100                  /* Control flag, or'ed in       */
X#define META    0x0200                  /* Meta flag, or'ed in          */
X#define CTLX    0x0400                  /* ^X flag, or'ed in            */
X#define	SPEC	0x0800			/* special key (function keys)	*/
X
X#define FALSE   0                       /* False, no, bad, etc.         */
X#define TRUE    1                       /* True, yes, good, etc.        */
X#define ABORT   2                       /* Death, ^G, abort, etc.       */
X#define	FAILED	3			/* not-quite fatal false return	*/
X#define	RET	4			/* a return from buffer		*/
X#define	GOLINE	5			/* exit flagging a GOTO		*/
X
X#define	STOP	0			/* keyboard macro not in use	*/
X#define	PLAY	1			/*		  playing	*/
X#define	RECORD	2			/*		  recording	*/
X
X#define	FORWARD	0			/* forward direction		*/
X#define REVERSE	1			/* backwards direction		*/
X
X#define FIOSUC  0                       /* File I/O, success.           */
X#define FIOFNF  1                       /* File I/O, file not found.    */
X#define FIOEOF  2                       /* File I/O, end of file.       */
X#define FIOERR  3                       /* File I/O, error.             */
X#define	FIOLNG	4			/* line longer than allowed len	*/
X#define	FIOFUN	5			/* File I/O, eod of file/bad line*/
X
X#define CFCPCN  0x0001                  /* Last command was C-P, C-N    */
X#define CFKILL  0x0002                  /* Last command was a kill      */
X
X#define	BELL	0x07			/* a bell character		*/
X#define	TAB	0x09			/* a tab character		*/
X
X#if	V7 | USG | BSD
X#define	PATHCHR	':'
X#else
X#define	PATHCHR	';'
X#endif
X
X#define	INTWIDTH	sizeof(int)/3 + 2
X
X/*	Macro argument token types					*/
X
X#define	TKNUL	0			/* end-of-string		*/
X#define	TKARG	1			/* interactive argument		*/
X#define	TKBUF	2			/* buffer argument		*/
X#define	TKVAR	3			/* user variables		*/
X#define	TKENV	4			/* environment variables	*/
X#define	TKFUN	5			/* function....			*/
X#define	TKDIR	6			/* directive			*/
X#define	TKLBL	7			/* line label			*/
X#define	TKLIT	8			/* numeric literal		*/
X#define	TKSTR	9			/* quoted string literal	*/
X#define	TKCMD	10			/* command name			*/
X
X/*	Internal defined functions					*/
X
X/* DIFCASE represents the integer difference between upper
X   and lower case letters.  It is an xor-able value, which is
X   fortunate, since the relative positions of upper to lower
X   case letters is the opposite of ascii in ebcdic.
X*/
X
X#ifdef	islower
X#undef	islower
X#endif
X
X#if	ASCII
X
X#define	DIFCASE		0x20
X#define isletter(c)	(('a' <= c && 'z' >= c) || ('A' <= c && 'Z' >= c))
X#define islower(c)	(('a' <= c && 'z' >= c))
X#endif
X
X#if	EBCDIC
X
X#define	DIFCASE		0x40
X#define isletter(c)	(('a' <= c && 'i' >= c) || ('j' <= c && 'r' >= c) || ('s' <= c && 'z' >= c) || ('A' <= c && 'I' >= c) || ('J' <= c && 'R' >= c) || ('S' <= c && 'Z' >= c))
X#define islower(c)	(('a' <= c && 'i' >= c) || ('j' <= c && 'r' >= c) || ('s' <= c && 'z' >= c))
X#endif
X
X/*	Dynamic RAM tracking and reporting redefinitions	*/
X
X#if	RAMSIZE
X#define	malloc	allocate
X#define	free	release
X#endif
X
X/*
X * There is a window structure allocated for every active display window. The
X * windows are kept in a big list, in top to bottom screen order, with the
X * listhead at "wheadp". Each window contains its own values of dot and mark.
X * The flag field contains some bits that are set by commands to guide
X * redisplay; although this is a bit of a compromise in terms of decoupling,
X * the full blown redisplay is just too expensive to run for every input
X * character.
X */
Xtypedef struct  WINDOW {
X        struct  WINDOW *w_wndp;         /* Next window                  */
X        struct  BUFFER *w_bufp;         /* Buffer displayed in window   */
X        struct  LINE *w_linep;          /* Top line in the window       */
X        struct  LINE *w_dotp;           /* Line containing "."          */
X        short   w_doto;                 /* Byte offset for "."          */
X        struct  LINE *w_markp;          /* Line containing "mark"       */
X        short   w_marko;                /* Byte offset for "mark"       */
X        char    w_toprow;               /* Origin 0 top row of window   */
X        char    w_ntrows;               /* # of rows of text in window  */
X        char    w_force;                /* If NZ, forcing row.          */
X        char    w_flag;                 /* Flags.                       */
X#if	COLOR
X	char	w_fcolor;		/* current forground color	*/
X	char	w_bcolor;		/* current background color	*/
X#endif
X}       WINDOW;
X
X#define WFFORCE 0x01                    /* Window needs forced reframe  */
X#define WFMOVE  0x02                    /* Movement from line to line   */
X#define WFEDIT  0x04                    /* Editing within a line        */
X#define WFHARD  0x08                    /* Better to a full display     */
X#define WFMODE  0x10                    /* Update mode line.            */
X#define	WFCOLR	0x20			/* Needs a color change		*/
X
X/*
X * Text is kept in buffers. A buffer header, described below, exists for every
X * buffer in the system. The buffers are kept in a big list, so that commands
X * that search for a buffer by name can find the buffer header. There is a
X * safe store for the dot and mark in the header, but this is only valid if
X * the buffer is not being displayed (that is, if "b_nwnd" is 0). The text for
X * the buffer is kept in a circularly linked list of lines, with a pointer to
X * the header line in "b_linep".
X * 	Buffers may be "Inactive" which means the files accosiated with them
X * have not been read in yet. These get read in at "use buffer" time.
X */
Xtypedef struct  BUFFER {
X        struct  BUFFER *b_bufp;         /* Link to next BUFFER          */
X        struct  LINE *b_dotp;           /* Link to "." LINE structure   */
X        short   b_doto;                 /* Offset of "." in above LINE  */
X        struct  LINE *b_markp;          /* The same as the above two,   */
X        short   b_marko;                /* but for the "mark"           */
X        struct  LINE *b_linep;          /* Link to the header LINE      */
X	char	b_active;		/* window activated flag	*/
X        char    b_nwnd;                 /* Count of windows on buffer   */
X        char    b_flag;                 /* Flags                        */
X	char	b_mode;			/* editor mode of this buffer	*/
X        char    b_fname[NFILEN];        /* File name                    */
X        char    b_bname[NBUFN];         /* Buffer name                  */
X#if	CRYPT
X	char	b_key[NPAT];		/* current encrypted key	*/
X#endif
X}       BUFFER;
X
X#define BFINVS  0x01                    /* Internal invisable buffer    */
X#define BFCHG   0x02                    /* Changed since last write     */
X
X/*	mode flags	*/
X#define	NUMMODES	8		/* # of defined modes		*/
X
X#define	MDWRAP	0x0001			/* word wrap			*/
X#define	MDCMOD	0x0002			/* C indentation and fence match*/
X#define	MDSPELL	0x0004			/* spell error parcing		*/
X#define	MDEXACT	0x0008			/* Exact matching for searches	*/
X#define	MDVIEW	0x0010			/* read-only buffer		*/
X#define MDOVER	0x0020			/* overwrite mode		*/
X#define MDMAGIC	0x0040			/* regular expresions in search */
X#define	MDCRYPT	0x0080			/* encrytion mode active	*/
X
X/*
X * The starting position of a region, and the size of the region in
X * characters, is kept in a region structure.  Used by the region commands.
X */
Xtypedef struct  {
X        struct  LINE *r_linep;          /* Origin LINE address.         */
X        short   r_offset;               /* Origin LINE offset.          */
X        long	r_size;                 /* Length in characters.        */
X}       REGION;
X
X/*
X * All text is kept in circularly linked lists of "LINE" structures. These
X * begin at the header line (which is the blank line beyond the end of the
X * buffer). This line is pointed to by the "BUFFER". Each line contains a the
X * number of bytes in the line (the "used" size), the size of the text array,
X * and the text. The end of line is not stored as a byte; it's implied. Future
X * additions will include update hints, and a list of marks into the line.
X */
Xtypedef struct  LINE {
X        struct  LINE *l_fp;             /* Link to the next line        */
X        struct  LINE *l_bp;             /* Link to the previous line    */
X        short   l_size;                 /* Allocated size               */
X        short   l_used;                 /* Used size                    */
X        char    l_text[1];              /* A bunch of characters.       */
X}       LINE;
X
X#define lforw(lp)       ((lp)->l_fp)
X#define lback(lp)       ((lp)->l_bp)
X#define lgetc(lp, n)    ((lp)->l_text[(n)]&0xFF)
X#define lputc(lp, n, c) ((lp)->l_text[(n)]=(c))
X#define llength(lp)     ((lp)->l_used)
X
X/*
X * The editor communicates with the display using a high level interface. A
X * "TERM" structure holds useful variables, and indirect pointers to routines
X * that do useful operations. The low level get and put routines are here too.
X * This lets a terminal, in addition to having non standard commands, have
X * funny get and put character code too. The calls might get changed to
X * "termp->t_field" style in the future, to make it possible to run more than
X * one terminal type.
X */
Xtypedef struct  {
X	short	t_mrow;			/* max number of rows allowable */
X        short   t_nrow;                 /* current number of rows used  */
X        short   t_mcol;                 /* max Number of columns.       */
X        short   t_ncol;                 /* current Number of columns.   */
X	short	t_margin;		/* min margin for extended lines*/
X	short	t_scrsiz;		/* size of scroll region "	*/
X	int	t_pause;		/* # times thru update to pause */
X        int     (*t_open)();            /* Open terminal at the start.  */
X        int     (*t_close)();           /* Close terminal at end.       */
X	int	(*t_kopen)();		/* Open keyboard		*/
X	int	(*t_kclose)();		/* close keyboard		*/
X        int     (*t_getchar)();         /* Get character from keyboard. */
X        int     (*t_putchar)();         /* Put character to display.    */
X        int     (*t_flush)();           /* Flush output buffers.        */
X        int     (*t_move)();            /* Move the cursor, origin 0.   */
X        int     (*t_eeol)();            /* Erase to end of line.        */
X        int     (*t_eeop)();            /* Erase to end of page.        */
X        int     (*t_beep)();            /* Beep.                        */
X	int	(*t_rev)();		/* set reverse video state	*/
X	int	(*t_rez)();		/* change screen resolution	*/
X#if	COLOR
X	int	(*t_setfor)();		/* set forground color		*/
X	int	(*t_setback)();		/* set background color		*/
X#endif
X}       TERM;
X
X/*	TEMPORARY macros for terminal I/O  (to be placed in a machine
X					    dependant place later)	*/
X
X#define	TTopen		(*term.t_open)
X#define	TTclose		(*term.t_close)
X#define	TTkopen		(*term.t_kopen)
X#define	TTkclose	(*term.t_kclose)
X#define	TTgetc		(*term.t_getchar)
X#define	TTputc		(*term.t_putchar)
X#define	TTflush		(*term.t_flush)
X#define	TTmove		(*term.t_move)
X#define	TTeeol		(*term.t_eeol)
X#define	TTeeop		(*term.t_eeop)
X#define	TTbeep		(*term.t_beep)
X#define	TTrev		(*term.t_rev)
X#define	TTrez		(*term.t_rez)
X#if	COLOR
X#define	TTforg		(*term.t_setfor)
X#define	TTbacg		(*term.t_setback)
X#endif
X
X/*	structure for the table of initial key bindings		*/
X
Xtypedef struct  {
X        short   k_code;                 /* Key code                     */
X        int     (*k_fp)();              /* Routine to handle it         */
X}       KEYTAB;
X
X/*	structure for the name binding table		*/
X
Xtypedef struct {
X	char *n_name;		/* name of function key */
X	int (*n_func)();	/* function name is bound to */
X}	NBIND;
X
X/*	The editor holds deleted text chunks in the KILL buffer. The
X	kill buffer is logically a stream of ascii characters, however
X	due to its unpredicatable size, it gets implemented as a linked
X	list of chunks. (The d_ prefix is for "deleted" text, as k_
X	was taken up by the keycode structure)			*/
X
Xtypedef	struct KILL {
X	struct KILL *d_next;	/* link to next chunk, NULL if last */
X	char d_chunk[KBLOCK];	/* deleted text */
X} KILL;
X
END_OF_estruct.h
if test 18184 -ne `wc -c <estruct.h`; then
    echo shar: \"estruct.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: Extracting \"readme\" \(20974 characters\)
if test -f readme ; then 
  echo shar: Will not over-write existing file \"readme\"
else
sed "s/^X//" >readme <<'END_OF_readme'
X		MicroEMACS 3.8b Release Notes
X
X**********************************************************************
X
X	(C)opyright 1987 by Daniel M. Lawrence
X	MicroEMACS 3.8 can be copied and distributed freely for any
X	non-commercial purposes. MicroEMACS 3.8 can only be incorporated
X	into commercial software with the permission of the current author.
X
X(	Notice the copyright.....a number of large companies decided to use
XMicroEMACS 3.7 and 3.7i as the shell of their products, and several of
Xthe ones I contacted were not even courteos enough to send me their
Xproduct for my personal use.  I am not out to make a fortune on this,
Xbut a little common courtesy would be appreciated.)
X
X**********************************************************************
X
X	It has been quite a while since the last realease and there are
Xa large number of new features and enhancements to old features.  There
Xis now a full extension language and there is also support nearly
Xcompleted for a number of newer 68000 machines.  The edit history at the
Xbeginning of the MAIN.C file details the changes. 
X
X	MicroEMACS 3.8 is availible in a couple of different ways. 
XFirst, it is availible via my bulletin board system..... 
X
X	The Programmer's Room
X	FIDO 201/2
X	(317) 742-5533
X	24 hours  300/1200 baud
X
X	Also it should be online on the following BBS's:
X
X	The Starship Trooper	Fido 201/1	(317) 423-2281	2400
X	Avatar			Fido 201/4	(317) 497-1970	1200
X
X	There it is arranged as three MSDOS .ARC files, EMACSDOC.ARC
Xwhich contains the documentation and command files, EMACSSRC.ARC which
Xcontains the sources and the UNIX Makefile, and EMACSEXE.EXE which
Xcontains the MSDOS executables.  Also all the various executables are
Xavailibile individualy. 
X
XEMACSDOC.ARC includes the files:
X
X	README		This file
X	
X	EMACS.RC	Standard startup file
X	ME110.RC	HP110 startup file
X	ME150.RC	HP150 startup file
X	
X	
X	EMACS.HLP	Online help file
X	EMACS.KEY	Cammond wallchart
X	EMACS.TUT	Online tutorial
X	EMACS.MSS       Emacs Introduction document
X	EMACS1.MSS	Emacs Reference guide
X	IBMFN.LST	IBM-PC function list
X	MAGIC.DOC	Regular partern matching bulletin
X	
X	AZMAP.CMD	Translate .SYM files to .MAP
X	BDATA.CMD	BASIS Data statement builder
X	MENU.CMD	Sample Menu system
X	MENU1		   datafile for menu syste
X
XEMACSSRC.ARC includes the files:
X
X	ANSI.C		ANSI screen driver
X	BASIC.C		basic cursor movement
X	BIND.C		key binding commands
X	BUFFER.C	buffer manipulation commands
X	CRYPT.C		encryption functions
X	DG10.C		Data General 10 screen driver
X	DISPLAY.C	main display driver
X	EBIND.H		binding list
X	EDEF.H		global variable declarations
X	EFUNC.H		function name list
X	EGAPC.C		EGA screen driver
X	EPATH.H		default path settings
X	ESEARCH.H	search global declarations
X	ESTRUCT.H	configuration and structure definitions
X	EVAL.C		expresion evaluator
X	EVAR.H		EMACS macro variable declarations
X	EXEC.C		macro execution functions
X	FILE.C		user file functions
X	FILEIO.C	low level file I/O driver
X	HP110.C		HP110 screen driver
X	HP150.C		HP150(A or C) screen driver
X	IBMPC.C		IBM-PC CGA and MONOCHROME driver
X	INPUT.C		low level user input driver
X	ISEARCH.C	incremental search functions
X	LINE.C		text line manipulation functions
X	LOCK.C		file locking functions
X	MAIN.C		argument parsing and command loop
X	RANDOM.C	other random user functions
X	REGION.C	region cut & paste functions
X	SEARCH.C	search and replace functions
X	SPAWN.C		OS interface driver
X	ST520.C		ATARI ST1040 screen driver [not verified]
X	TCAP.C		Termcap screen driver
X	TERMIO.C	low level I/O driver
X	TIPC.C		TI-PC screen driver
X	VMSVT.C		VMS screen driver
X	VT52.C		VT52 screen driver
X	WINDOW.C	window manipulation functions
X	WORD.C		word manipulation functions
X
XEMACSEXE.ARC includes the files:
X
X	MEIBM.EXE	IBM-PC CGA and MONO version
X	MEEGA.EXE	IBM-PC EGA version
X	MEANSI.EXE	MSDOS ANSI graphics version
X	ME110.EXE	HP110 portable version
X	ME150.EX	HP150 version
X
X	Also MicroEMACS should be availible from USENET via the
Xmod.sources notegroup, or its archives. A number of sites also make
XMicroEMACS availible via FTP. Watch USENET news for info on these.
X
X	MicroSCRIBE 1.0, which I had hoped to have ready by now, is only
Xabout half written.  MicroEMACS took up more of my time in updates then
XI had expected, however having this fairly advanced, and hopefully
Xfairly stable version, I can get back to getting MicroSCRIBE written. 
XAlso in the works for a later release is a spell checker (called
XMicroSPELL rather predictably) and sometime next year, a integrated
Xthesaurus program. 
X
X	A more customized MicroEMACS for the Macintosh, the Amiga and
Xthe 1040ST will probably become availible in the next couple of months. 
XSupport for the mouse, standard file boxes, pull down menus and
Xdifferent resolutions will be included.  If you can be of help in
Xgetting this ready, please contact me. 
X
X	As before, I will continue to support these programs, and
Xencourage everyone to spread them around as much as they can. If you
Xmake what you think are changes that are usefull to many, send me the
Xupdates, and as time permits, I will encorporate the ones I understand,
Xand agree with into the master sources. Being overswamped with mailers,
XI have discontinued my mailing offer, but if you have a special problem
Xgetting hold of MicroEMACS, contact me and we can work something out for
Xyou.
X
X	USmail:	Daniel Lawrence
X		617 New York St
X		Lafayette, IN 47901
X
X	UUCP:	ihnp4!pur-ee!pur-phy!duncan!lawrence
X	or	ihnp4!itivax!duncan!lawrence
X	ARPA:	nwd@j.cc.purdue.edu
X	FIDO:	The Programmer's Room 201/2
X		(317) 742-5533
X	ATT:	(317) 742-5153
X
X
X
X
X		New Features
X		============
X
X***	Path Searching
X
X	If the OS of the operating system MicroEMACS is running under
Xhas environmental variables, MicroEMACS will read in the PATH variable
Xas a list of directories in which to look for its startup and help
Xfiles, in place of the list in the epath.h file.
X
X***	Bindable Prefixes
X
X	All the prefix keys can now be rebound. This includes:
X
X		meta-prefix		<ESC>
X		ctlx-prefix		^X
X		universal-argument	^U
X		quote-character		^Q
X
X***	HP150 function keys
X
X	can now both be labeled and bound.
X
X***	New Help Function
X
X	The APROPOS (M-A) function prompts for a string, and then
Xprepares a list of all named functions that contain the string. This is
Xusefull for finding all comands that deal with one topic.
X
X***	File Encryption
X
X	Text files can now be encrypted (and decrypted <very useful>).
XThe encryption method (written by Dana Hoggat) results in ALL legal
Xprinting characters, leaving files suitable for mailing and moving
Xaround between systems. The -k <encryption key> command line switch
Xplaces the first file into the edit buffer using the named key. CRYPT is
Xa mode which can be set on any buffer, and set-encryption-key (M-E) sets
Xthe encryption key of the current buffer. If you attempt to write out a
Xbuffer in crypt mode without specifying the key, MicroEMACS will
Xautomatically prompt you for it.
X
X***	Keyboard Macros rewritten
X
X	The code for processing keyboard macros now records the responses
Xto all prompts as well as just the command keystrokes.
X
X***	Restrictive Mode
X
X	The -r command line switch prevents EMACS from executing many of
Xits commands which would allow you to break out of it, or edit files
Xother then the ones named on the command line.  This is usefull for
Xproducts that need to restrict access to the OS from inside the editor
X(for example, BBS systems).
X
X***	Word wrap made more flexible
X
X	When emacs determined it is time to word wrap (when in wrap
Xmode) it calls the function which is bound to the illegal keystroke,
XM-FNW. This keystroke is normally bound to wrap-word (M-FNW), but can be
Xrebound by the user so EMACS can do different things at wrap time (like
Xauto indention in different languages).
X
X***	Fence Matching
X
X	The goto-matching-fence (M-^F) command jumps the cursor to the
Xmatching fence, or beeps if there is none.
X
X***	Dynamic Screen Re-sizing
X
X	The size that EMACS uses for editing can be changed with the
Xchange-screen-size (M-^S) and change-screen-width (M-^T) commands. These
Xcan then be usefull in integrating EMACS on window based machines.
X
X***	IBMPC drivers combined...
X
X	The IBM-PC CGA and MONOCHROME drivers have been combined into
Xone driver which will look up the graphics adapter type at startup and
Xadjust accordingly.
X
X***	EXTENTION LANGUAGE
X
X	MicroEMACS is now equipped with a fully functional extention
Xlanguage in which to write macros.  These macros can be saved, recalled
Xand bound to keystrokes, thus allowing a high degree of customization. 
XWhat follows is an exerpt from what will become the new MicroEMACS
Xreference manual. 
X
XChapter x:		MicroEMACS Macros
X
X	Macros are programs that are used to customize the editor and to
Xperform complicated editing tasks.  They may be stored in files or
Xbuffers and may be executed using an appropriate command, or bound to a
Xparticular keystroke.  Portions of the standard start-up file are
Ximpliment via macros, as well as the example menu system.  The
Xexecute-macro-<n> editor commands cause the macros, numbered from 1 to
X40, to be executed.  Macros are stored by executing files that contain
Xthe store-macro command.
X
X	There are many different aspects to the macro langage within
XMicroEMACS.  Editor commands are the various commands that manipulate
Xtext, buffers, windows, etc, within the editor.  Directives are commands
Xwhich control what lines get executed within a macro.  Also there are
Xvarious types of variables.  Environmental variables both control and
Xreport on different aspects of the editor.  User variables hold string
Xvalues which may be changed and inspected.  Buffer variables allow text
Xto be placed into variables.  Interactive variable allow the program to
Xprompt the user for information.  Functions can be used to manipulate
Xall these variables. 
X
Xx.00	Variables
X
X	Variables in MicroEMACS can be used to return values within
Xexpressions, as repeat counts to editing commands, or as text to be
Xinserted into buffers and messages.  The value of these variables is set
Xusing the set (^X-A) command.  For example, to set the current fill
Xcolumn to 64 characters, the following macro line would be used:
X
X	set $fillcol 64
X
X	or to have the contents of %NAME inserted at the point in the
Xcurrent buffer, the command to use would be:
X
X	insert-string %name
X
X
Xx.01	Environmental Variables
X
X	"What good is a quote if you can't change it?"
X
X	These variables are used to change different aspects of the way
Xthe editor works.  Also they will return the current settings if used as
Xpart of an expresion.  All environmental variable names begin with a
Xdollar sign ($). 
X
X	$fillcol	Current fill column
X	$pagelen	Number of screen lines used currently
X	$curwidth	Number of columns used currently
X	$curcol		Current column of point in current buffer
X	$curline	Current line of point in current buffer
X	$flicker	Flicker Flag
X				set to TRUE if IBM CGA
X				set to FALSE for most others
X	$cbufname	Name of the current buffer
X	$cfname		File name of the current buffer
X	$sres		Current screen resolution
X			(CGA or MONO on the IBM-PC driver...
X			 EGA on the EGA driver
X			 LOW MEDIUM or HIGH on the Atari ST1040
X			 NORMAL on all others)
X	$debug		Flag to trigger macro debugging (try it...
X				you'll like it!)
X	$status		return status of the success of the last command
X			(TRUE or FALSE) usually used with !force
X
X	Obviously, many more of these variables will be availible in
Xfuture releases of MicroEMACS. (Yes, send a vote for your favorite new
Xenvironmental variables today).
X
Xx.02	User variables
X
X	User variables allow you, the user, to store strings and
Xmanipulate them.  These strings can be pieces of text, numbers (in text
Xform), or the logical values TRUE and FALSE.  These variables can be
Xcombined, tested, inserted into buffers, and otherwise used to control
Xthe way your macros execute. At the moment, up to 100 user variables may
Xbe in use in one editing session.  All users variable names must begin
Xwith a percent sign (%) and may contain any printing characters.  Only
Xthe first 10 characters are significant (ie differences beyond the tenth
Xcharacter are ignored). Most operators will truncate strings to a length
Xof 128 characters.
X
Xx.03	Buffer Variables
X
X	Buffer variables are special in that they can only be queried
Xand cannot be set.  What buffer variables are is a way to take text from
Xa buffer and place it in a variable. For example, if I have a buffer by
Xthe name of RIGEL2, and it contains the text:
X
X	Richmond
X	Lafayette
X	<*>Bloomington		(where <*> is the current point)
X	Indianapolis
X	Gary
X	=* MicroEMACS 3.8 (WRAP) == rigel2 == File: /data/rigel2.txt =====
X
X	and within a command I reference #rigel2, like:
X
X	insert-string #rigel2
X
X	MicroEMACS would start at the current point in the RIGEL2
Xbuffer and grab all the text up to the end of that line and pass that
Xback.  Then it would advance the point to the beginning of the next line.
XThus, after our last command executes, the string "Bloomington" gets
Xinserted into the current buffer, and the buffer RIGEL2 now looks like
Xthis:
X
X	Richmond
X	Lafayette
X	Bloomington
X	<*>Indianapolis		(where <*> is the current point)
X	Gary
X	=* MicroEMACS 3.8 (WRAP) == rigel2 == File: /data/rigel2.txt =====
X
X	as you have probably noticed, a buffer variable consists of the
Xbuffer name, preceded by a pound sign (#).
X
Xx.04	Interactive variables
X
X	Interactive variables are actually a method to prompt the user
Xfor a string.  This is done by using an at sign (@) followed either with
Xa quoted string, or a variable containing a string.  The string is the
Xplaced on the bottom line, and the editor waits for the user to type in
Xa string.  Then the string typed in by the users is returned as the
Xvalue of the interactive variable.  For example:
X
X	set %quest "What file? "
X	find-file @%quest
X
X	will ask the user for a file name, and then attempt to find it.
X
X
Xx.10	Functions
X
X	Functions can be used to manipulate variables in various ways. 
XFunctions can have one, two, or three arguments.  These arguments will
Xalways be placed after the function on the current command line.  For
Xexample, if we wanted to increase the current fill column by two, using
Xemacs's set (^X-A) command, we would write:
X
X	set $fillcol &add $fillcol 2
X         \      \      \      \     \____second operand
X           \      \      \      \________first operand
X             \      \      \_____________function to execute
X               \      \__________________variable to set
X                 \_______________________set (^X-A) command
X
X	Function names always begin with the ampresand (&) character,
Xand are only significant to the first three characters after the
Xampresand.  Functions will normal expect one of three types of
Xarguments, and will automatically convert types when needed.
X
X	<num>	an ascii string of digits which is interpeted as a
X		numeric value.  Any string which does not start with a
X		digit or a minus sign (-) will be considered zero.
X
X	<str>	An arbitrary string of characters.  At the moment,
X		strings are limited to 128 characters in length.
X
X	<log>	A logical value consisting of the string "TRUE" or
X		"FALSE". Numeric strings will also evaluate to "FALSE"
X		if they are equal to zero, and "TRUE" if they are
X		non-zero. Arbitrary text strings will have the value of
X		"FALSE".
X
X	A list of the currently availible functions follows: (Once
Xagain, send in those votes on what kind of functions you would like to
Xsee added!)
X
XNumeric Functions:	(returns <num>)
X
X&ADD		<num> <num>	Add two numbers
X&SUB		<num> <num>	Subtract the second number from the first
X&TIMes		<num> <num>	Multiply two numbers
X&DIVide		<num> <num>	Divide the first number by the second
X				giving an integer result
X&MOD		<num> <num>	Return the reminder of dividing the
X				first number by the second
X&NEGate		<neg>		Multiply the arg by -1
X
X
XString manipulation functions:	(returns <str>)
X
X&CAT		<str> <str>	Concatinate the two strings to form one
X&LEFt		<str> <num>	return the <num> leftmost characters
X				from <str>
X&RIGht		<str> <num>	return the <num> rightmost characters
X				from <str>
X&MID		<str> <num1> <num2>
X				Starting from <num1> position in <str>,
X				return <num2> characters.
X
XLogical Testing functions:	(returns <log>)
X
X&NOT		<log>		Return the opposite logical value
X&EQUal		<num> <num>	If <num> and <num> are numerically
X				equal, return TRUE
X&LESs		<num1> <num2>	If <num1> is less than <num2>, return
X				TRUE.
X&GREater	<num1> <num2>	If <num1> is greater than, or equal to
X				<num2>, return TRUE.
X&SEQual		<str1> <str2>	If the two strings are the same, return
X				TRUE.
X&SLEss		<str1> <str2>	If <str1> is less alphabetically than
X				<str2>, return TRUE.
X&SGReater	<str1> <str2>	If <str1> is alphabetically greater than
X				or equal to <str2>, return TRUE.
X
XSpecial Functions:
X
X&INDirect	<str>		Evaluate <str> as a variable.
X
X	This last function deserves more explaination. The &IND function
Xevaluates its argument, takes the resulting string, and then uses it as
Xa variable name.  For example, given the following code sequence:
X
X	; set up reference table
X
X	set %one	"elephant"
X	set %two 	"giraffe"
X	set %three 	"donkey"
X
X	set %index "two"
X	insert-string &ind %index
X
X	the string "giraffe" would have been inserted at the point in
Xthe current buffer.  This indirection can be safely nested up to about
X10 levels.
X
Xx.20	Directives
X
X	Directives are commands which only operate within an executing
Xmacro, ie they do not make sense as a single command. As such, they
Xcannot be called up singly or bound to keystroke. Used within macros,
Xthey control what lines are executed and in what order.
X
X	Directives always start with the exlaimation mark (!) character
Xand must be the first thing placed on a line. Directives executed singly
X(via the execute-command-line command) interactively will be ignored.
X
Xx.21	!ENDM Directive
X
X	This directive is used to terminate a macro being stored. For
Xexample, if a file is being executed contains the text:
X
X	;	Read in a file in view mode, and make the window red
X	26	store-macro
X		find-file @"File to view: "
X		add-mode "view"
X		add-mode "red"
X	!endm
X
X	write-message "[Consult macro has been loaded]"
X
X	only the lines between the store-macro command and the !ENDM
Xdirective are stored in macro 26.
X
Xx.22	!FORCE Directive
X
X	When MicroEMACS executes a macro, if any command fails, the
Xmacro is terminated at that point. If a line is preceeded by a !FORCE
Xdirective, execution continues weather the command succeeds or not. For
Xexample:
X
X	;	Merge the top two windows
X
X	save-window		;remember what window we are at
X	1 next-window		;go to the top window
X	delete-window		;merge it with the second window
X	!force restore-window	;This will continue irregardless
X	add-mode "red"
X
Xx.23	!IF, !ELSE, and !ENDIF Directives
X
X	This directive allows statements only to be executed if a
Xcondition specified in the directive is met.  Every line following the
X!IF directive, until the first !ELSE or !ENDIF directive, is only
Xexecuted if the expresion following the !IF directive evaluates to a
XTRUE value.  For example, the following macro segment creates the
Xportion of a text file automatically.  (yes believe me, this will be
Xeasier to understand then that last explaination....)
X
X	!if &sequal %curplace "timespace vortex"
X		insert-string "First, rematerialize~n"
X	!endif
X	!if &sequal %planet "earth"	;If we have landed on earth...
X		!if &sequal %time "late 20th century"  ;and we are then
X			write-message "Contact U.N.I.T."
X		!else
X			insert-string "Investigate the situation....~n"
X			insert-string "(SAY 'stay here Sara')~n"
X		!endif
X	!else
X		set %conditions @"Atmosphere conditions outside? "
X		!if &sequal %conditions "safe"
X			insert-string &cat "Go outside......" "~n"
X			insert-string "lock the door~n"
X		!else
X			insert-string "Dematerialize..try somewhen else"
X			newline
X		!endif
X	!endif
X
Xx.24	!GOTO Directive
X
X	Flow can be controlled within a MicroEMACS macro using the !GOTO
Xdirective. It takes as an argument a label. A label consists of a line
Xstarting with an asterick (*) and then an alphanumeric label.  Only
Xlabels in the currently executing macro can be jumped to, and trying to
Xjump to a non-existing label terminates execution of a macro.  For
Xexample..
X
X	;Create a block of DATA statements for a BASIC program
X
X		insert-string "1000 DATA "
X		set %linenum 1000
X
X	*nxtin
X		update-screen		;make sure we see the changes
X		set %data @"Next number: "
X		!if &equal %data 0
X			!goto finish
X		!endif
X
X		!if &greater $curcol 60
X			2 delete-previous-character
X			newline
X			set %linenum &add %linenum 10
X			insert-string &cat %linenum " DATA "
X		!endif
X
X		insert-string &cat %data ", "
X		!goto nxtin
X
X	*finish
X
X		2 delete-previous-character
X		newline
X
Xx.25	!RETURN Directive
X
X	The !RETURN Directive causes the current macro to exit, either
Xreturning to the caller (if any) or to interactive mode.  For example:
X
X	;	Check the monitor type and set %mtyp
X
X	!if &sres "CGA"
X		set %mtyp 1
X		!return
X	!else
X		set %mtyp 2
X	!endif
X
X	insert-string "You are on a MONOCHROME machine!~n"
X
X<<<END OF MANUAL EXCERPT>>>
END_OF_readme
if test 20974 -ne `wc -c <readme`; then
    echo shar: \"readme\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 8 \(of 14\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    echo "See the readme file"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
