Subject:  v09i025:  Z80 macro cross-assembler, Part02/02
Newsgroups: mod.sources
Approved: rs@mirror.TMC.COM

Submitted by: pyrnj!vu-vlsi!colin (Colin Kelley)
Mod.sources: Volume 9, Issue 25
Archive-name: zmac/Part02

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	zdis.c serial.z serial.hex
export PATH; PATH=/bin:$PATH
echo shar: extracting "'zdis.c'" '(37358 characters)'
if test -f 'zdis.c'
then
	echo shar: will not over-write existing file "'zdis.c'"
else
cat << \SHAR_EOF > 'zdis.c'
char undefined[] = "undefined";

struct opcode {
	char	*name;
	int	args;
};

struct opcode major[256] = {
	"nop",			0,		/* 00 */
	"ld	bc,%02x%02xh",	2,		/* 01 */
	"ld	bc,a",		0,		/* 02 */
	"inc	bc",		0,		/* 03 */
	"inc	b",		0,		/* 04 */
	"dec	b",		0,		/* 05 */
	"ld	b,%02xh",	1,		/* 06 */
	"rlc	a",		0,		/* 07 */

	"ex	af,af'",	0,		/* 08 */
	"add	hl,bc",		0,		/* 09 */
	"ld	a,(bc)",	0,		/* 0a */
	"dec	bc",		0,		/* 0b */
	"inc	c",		0,		/* 0c */
	"dec	c",		0,		/* 0d */
	"ld	c,%02xh",	1,		/* 0e */
	"rrc	a",		0,		/* 0f */

	"djnz	%02xh",		1,		/* 10 */
	"ld	de,%02x%02xh",	2,		/* 11 */
	"ld	(de),a",	0,		/* 12 */
	"inc	de",		0,		/* 13 */
	"inc	d",		0,		/* 14 */
	"dec	d",		0,		/* 15 */
	"ld	d,%02xh",	1,		/* 16 */
	"rla",			0,		/* 17 */

	"jr	%02xh",		1,		/* 18 */
	"add	hl,de",		0,		/* 19 */
	"ld	a,(de)",	0,		/* 1a */
	"dec	de",		0,		/* 1b */
	"inc	e",		0,		/* 1c */
	"dec	e",		0,		/* 1d */
	"ld	e,%02xh",	1,		/* 1e */
	"rra",			0,		/* 1f */

	"jr	nz,%02xh",	1,		/* 20 */
	"ld	hl,%02x%02xh",	2,		/* 21 */
	"ld	(%02x%02xh),hl",2,		/* 22 */
	"inc	hl",		0,		/* 23 */
	"inc	h",		0,		/* 24 */
	"dec	h",		0,		/* 25 */
	"ld	h,%02xh",	1,		/* 26 */
	"daa",			0,		/* 27 */

	"jr	z,%02xh",	1,		/* 28 */
	"add	hl,hl",		0,		/* 29 */
	"ld	hl,(%02x%02xh)",2,		/* 2a */
	"dec	hl",		0,		/* 2b */
	"inc	l",		0,		/* 2c */
	"dec	l",		0,		/* 2d */
	"ld	l,%02xh",	1,		/* 2e */
	"cpl",			0,		/* 2f */

	"jr	nc,%02xh",	1,		/* 30 */
	"ld	sp,%02x%02xh",	2,		/* 31 */
	"ld	(%02x%02xh),a",	2,		/* 32 */
	"inc	sp",		0,		/* 33 */
	"inc	(hl)",		0,		/* 34 */
	"dec	(hl)",		0,		/* 35 */
	"ld	(hl),%02xh",	1,		/* 36 */
	"scf",			0,		/* 37 */

	"jr	c,%02xh",	1,		/* 38 */
	"add	hl,sp",		0,		/* 39 */
	"ld	a,(%02x%02xh)",	2,		/* 3a */
	"dec	sp",		0,		/* 3b */
	"inc	a",		0,		/* 3c */
	"dec	a",		0,		/* 3d */
	"ld	a,%02xh",	1,		/* 3e */
	"ccf",			0,		/* 3f */

	"ld	b,b",		0,		/* 40 */
	"ld	b,c",		0,		/* 41 */
	"ld	b,d",		0,		/* 42 */
	"ld	b,e",		0,		/* 43 */
	"ld	b,h",		0,		/* 44 */
	"ld	b,l",		0,		/* 45 */
	"ld	b,(hl)",	0,		/* 46 */
	"ld	b,a",		0,		/* 47 */

	"ld	c,b",		0,		/* 48 */
	"ld	c,c",		0,		/* 49 */
	"ld	c,d",		0,		/* 4a */
	"ld	c,e",		0,		/* 4b */
	"ld	c,h",		0,		/* 4c */
	"ld	c,l",		0,		/* 4d */
	"ld	c,(hl)",	0,		/* 4e */
	"ld	c,a",		0,		/* 4f */

	"ld	d,b",		0,		/* 50 */
	"ld	d,c",		0,		/* 51 */
	"ld	d,d",		0,		/* 52 */
	"ld	d,e",		0,		/* 53 */
	"ld	d,h",		0,		/* 54 */
	"ld	d,l",		0,		/* 55 */
	"ld	d,(hl)",	0,		/* 56 */
	"ld	d,a",		0,		/* 57 */

	"ld	e,b",		0,		/* 58 */
	"ld	e,c",		0,		/* 59 */
	"ld	e,d",		0,		/* 5a */
	"ld	e,e",		0,		/* 5b */
	"ld	e,h",		0,		/* 5c */
	"ld	e,l",		0,		/* 5d */
	"ld	e,(hl)",	0,		/* 5e */
	"ld	e,a",		0,		/* 5f */

	"ld	h,b",		0,		/* 60 */
	"ld	h,c",		0,		/* 61 */
	"ld	h,d",		0,		/* 62 */
	"ld	h,e",		0,		/* 63 */
	"ld	h,h",		0,		/* 64 */
	"ld	h,l",		0,		/* 65 */
	"ld	h,(hl)",	0,		/* 66 */
	"ld	h,a",		0,		/* 67 */

	"ld	l,b",		0,		/* 68 */
	"ld	l,c",		0,		/* 69 */
	"ld	l,d",		0,		/* 6a */
	"ld	l,e",		0,		/* 6b */
	"ld	l,h",		0,		/* 6c */
	"ld	l,l",		0,		/* 6d */
	"ld	l,(hl)",	0,		/* 6e */
	"ld	l,a",		0,		/* 6f */

	"ld	(hl),b",	0,		/* 70 */
	"ld	(hl),c",	0,		/* 71 */
	"ld	(hl),d",	0,		/* 72 */
	"ld	(hl),e",	0,		/* 73 */
	"ld	(hl),h",	0,		/* 74 */
	"ld	(hl),l",	0,		/* 75 */
	"halt",			0,		/* 76 */
	"ld	(hl),a",	0,		/* 77 */

	"ld	a,b",		0,		/* 78 */
	"ld	a,c",		0,		/* 79 */
	"ld	a,d",		0,		/* 7a */
	"ld	a,e",		0,		/* 7b */
	"ld	a,h",		0,		/* 7c */
	"ld	a,l",		0,		/* 7d */
	"ld	a,(hl)",	0,		/* 7e */
	"ld	a,a",		0,		/* 7f */

	"add	a,b",		0,		/* 80 */
	"add	a,c",		0,		/* 81 */
	"add	a,d",		0,		/* 82 */
	"add	a,e",		0,		/* 83 */
	"add	a,h",		0,		/* 84 */
	"add	a,l",		0,		/* 85 */
	"add	a,(hl)",	0,		/* 86 */
	"add	a,a",		0,		/* 87 */

	"adc	a,b",		0,		/* 88 */
	"adc	a,c",		0,		/* 89 */
	"adc	a,d",		0,		/* 8a */
	"adc	a,e",		0,		/* 8b */
	"adc	a,h",		0,		/* 8c */
	"adc	a,l",		0,		/* 8d */
	"adc	a,(hl)",	0,		/* 8e */
	"adc	a,a",		0,		/* 8f */

	"sub	b",		0,		/* 90 */
	"sub	c",		0,		/* 91 */
	"sub	d",		0,		/* 92 */
	"sub	e",		0,		/* 93 */
	"sub	h",		0,		/* 94 */
	"sub	l",		0,		/* 95 */
	"sub	(hl)",		0,		/* 96 */
	"sub	a",		0,		/* 97 */

	"sbc	a,b",		0,		/* 98 */
	"sbc	a,c",		0,		/* 99 */
	"sbc	a,d",		0,		/* 9a */
	"sbc	a,e",		0,		/* 9b */
	"sbc	a,h",		0,		/* 9c */
	"sbc	a,l",		0,		/* 9d */
	"sbc	a,(hl)",	0,		/* 9e */
	"sbc	a,a",		0,		/* 9f */

	"and	b",		0,		/* a0 */
	"and	c",		0,		/* a1 */
	"and	d",		0,		/* a2 */
	"and	e",		0,		/* a3 */
	"and	h",		0,		/* a4 */
	"and	l",		0,		/* a5 */
	"and	(hl)",		0,		/* a6 */
	"and	a",		0,		/* a7 */

	"xor	b",		0,		/* a8 */
	"xor	c",		0,		/* a9 */
	"xor	d",		0,		/* aa */
	"xor	e",		0,		/* ab */
	"xor	h",		0,		/* ac */
	"xor	l",		0,		/* ad */
	"xor	(hl)",		0,		/* ae */
	"xor	a",		0,		/* af */

	"or	b",		0,		/* b0 */
	"or	c",		0,		/* b1 */
	"or	d",		0,		/* b2 */
	"or	e",		0,		/* b3 */
	"or	h",		0,		/* b4 */
	"or	l",		0,		/* b5 */
	"or	(hl)",		0,		/* b6 */
	"or	a",		0,		/* b7 */

	"cp	b",		0,		/* b8 */
	"cp	c",		0,		/* b9 */
	"cp	d",		0,		/* ba */
	"cp	e",		0,		/* bb */
	"cp	h",		0,		/* bc */
	"cp	l",		0,		/* bd */
	"cp	(hl)",		0,		/* be */
	"cp	a",		0,		/* bf */

	"ret	nz",		0,		/* c0 */
	"pop	bc",		0,		/* c1 */
	"jp	nz,%02x%02xh",	2,		/* c2 */
	"jp	%02x%02xh",	2,		/* c3 */
	"call	nz,%02x%02xh",	2,		/* c4 */
	"push	bc",		0,		/* c5 */
	"add	a,%02xh",	1,		/* c6 */
	"rst	0",		0,		/* c7 */

	"ret	z",		0,		/* c8 */
	"ret",			0,		/* c9 */
	"jp	z,%02x%02xh",	2,		/* ca */
	0,			0,		/* cb */
	"call	z,%02x%02xh",	2,		/* cc */
	"call	%02x%02xh",	2,		/* cd */
	"adc	a,%02xh",	1,		/* ce */
	"rst	8",		0,		/* cf */
	
	"ret	nc",		0,		/* d0 */
	"pop	de",		0,		/* d1 */
	"jp	nc,%02x%02xh",	2,		/* d2 */
	"out	(%02xh),a",	1,		/* d3 */
	"call	nc,%02x%02xh",	2,		/* d4 */
	"push	de",		0,		/* d5 */
	"sub	%02xh",		1,		/* d6 */
	"rst	10h",		0,		/* d7 */
	
	"ret	c",		0,		/* d8 */
	"exx",			0,		/* d9 */
	"jp	c,%02x%02xh",	2,		/* da */
	"in	a,(%02xh)",	1,		/* db */
	"call	c,%02x%02xh",	2,		/* dc */
	0,			1,		/* dd */
	"sbc	a,%02xh",	1,		/* de */
	"rst	18h",		0,		/* df */
	
	"ret	po",		0,		/* e0 */
	"pop	hl",		0,		/* e1 */
	"jp	po,%02x%02xh",	2,		/* e2 */
	"ex	(sp),hl",	0,		/* e3 */
	"call	po,%02x%02xh",	2,		/* e4 */
	"push	hl",		0,		/* e5 */
	"and	%02xh",		1,		/* e6 */
	"rst	20h",		0,		/* e7 */
	"ret	pe",		0,		/* e8 */
	
	"jp	(hl)",		0,		/* e9 */
	"jp	pe,%02x%02xh",	2,		/* ea */
	"ex	de,hl",		0,		/* eb */
	"call	pe,%02x%02xh",	2,		/* ec */
	0,			2,		/* ed */
	"xor	%02xh",		1,		/* ee */
	"rst	28h",		0,		/* ef */
	
	"ret	p",		0,		/* f0 */
	"pop	af",		0,		/* f1 */
	"jp	p,%02x%02xh",	2,		/* f2 */
	"di",			0,		/* f3 */
	"call	p,%02x%02xh",	2,		/* f4 */
	"push	af",		0,		/* f5 */
	"or	%02xh",		1,		/* f6 */
	"rst	30h",		0,		/* f7 */
	
	"ret	m",		0,		/* f8 */
	"ld	sp,hl",		0,		/* f9 */
	"jp	m,%02x%02xh",	2,		/* fa */
	"ei",			0,		/* fb */
	"call	m,%02x%02xh",	2,		/* fc */
	0,			3,		/* fd */
	"cp	%02xh",		1,		/* fe */
	"rst	38h",		0,		/* ff */
};

struct opcode minor[4][256] = {
							/* cb */
	"rlc	b",		0,		/* cb00 */
	"rlc	c",		0,		/* cb01 */
	"rlc	d",		0,		/* cb02 */
	"rlc	e",		0,		/* cb03 */
	"rlc	h",		0,		/* cb04 */
	"rlc	l",		0,		/* cb05 */
	"rlc	(hl)",		0,		/* cb06 */
	"rlc	a",		0,		/* cb07 */
	
	"rrc	b",		0,		/* cb08 */
	"rrc	c",		0,		/* cb09 */
	"rrc	d",		0,		/* cb0a */
	"rrc	e",		0,		/* cb0b */
	"rrc	h",		0,		/* cb0c */
	"rrc	l",		0,		/* cb0d */
	"rrc	(hl)",		0,		/* cb0e */
	"rrc	a",		0,		/* cb0f */
	
	"rl	b",		0,		/* cb10 */
	"rl	c",		0,		/* cb11 */
	"rl	d",		0,		/* cb12 */
	"rl	e",		0,		/* cb13 */
	"rl	h",		0,		/* cb14 */
	"rl	l",		0,		/* cb15 */
	"rl	(hl)",		0,		/* cb16 */
	"rl	a",		0,		/* cb17 */
	
	"rr	b",		0,		/* cb18 */
	"rr	c",		0,		/* cb19 */
	"rr	d",		0,		/* cb1a */
	"rr	e",		0,		/* cb1b */
	"rr	h",		0,		/* cb1c */
	"rr	l",		0,		/* cb1d */
	"rr	(hl)",		0,		/* cb1e */
	"rr	a",		0,		/* cb1f */
	
	"sla	b",		0,		/* cb20 */
	"sla	c",		0,		/* cb21 */
	"sla	d",		0,		/* cb22 */
	"sla	e",		0,		/* cb23 */
	"sla	h",		0,		/* cb24 */
	"sla	l",		0,		/* cb25 */
	"sla	(hl)",		0,		/* cb26 */
	"sla	a",		0,		/* cb27 */
	
	"sra	b",		0,		/* cb28 */
	"sra	c",		0,		/* cb29 */
	"sra	d",		0,		/* cb2a */
	"sra	e",		0,		/* cb2b */
	"sra	h",		0,		/* cb2c */
	"sra	l",		0,		/* cb2d */
	"sra	(hl)",		0,		/* cb2e */
	"sra	a",		0,		/* cb2f */
	
	undefined,		0,		/* cb30 */
	undefined,		0,		/* cb31 */
	undefined,		0,		/* cb32 */
	undefined,		0,		/* cb33 */
	undefined,		0,		/* cb34 */
	undefined,		0,		/* cb35 */
	undefined,		0,		/* cb36 */
	undefined,		0,		/* cb37 */
	
	"srl	b",		0,		/* cb38 */
	"srl	c",		0,		/* cb39 */
	"srl	d",		0,		/* cb3a */
	"srl	e",		0,		/* cb3b */
	"srl	h",		0,		/* cb3c */
	"srl	l",		0,		/* cb3d */
	"srl	(hl)",		0,		/* cb3e */
	"srl	a",		0,		/* cb3f */
	
	"bit	0,b",		0,		/* cb40 */
	"bit	0,c",		0,		/* cb41 */
	"bit	0,d",		0,		/* cb42 */
	"bit	0,e",		0,		/* cb43 */
	"bit	0,h",		0,		/* cb44 */
	"bit	0,l",		0,		/* cb45 */
	"bit	0,(hl)",	0,		/* cb46 */
	"bit	0,a",		0,		/* cb47 */
	
	"bit	1,b",		0,		/* cb48 */
	"bit	1,c",		0,		/* cb49 */
	"bit	1,d",		0,		/* cb4a */
	"bit	1,e",		0,		/* cb4b */
	"bit	1,h",		0,		/* cb4c */
	"bit	1,l",		0,		/* cb4d */
	"bit	1,(hl)",	0,		/* cb4e */
	"bit	1,a",		0,		/* cb4f */
	
	"bit	2,b",		0,		/* cb50 */
	"bit	2,c",		0,		/* cb51 */
	"bit	2,d",		0,		/* cb52 */
	"bit	2,e",		0,		/* cb53 */
	"bit	2,h",		0,		/* cb54 */
	"bit	2,l",		0,		/* cb55 */
	"bit	2,(hl)",	0,		/* cb56 */
	"bit	2,a",		0,		/* cb57 */
	
	"bit	3,b",		0,		/* cb58 */
	"bit	3,c",		0,		/* cb59 */
	"bit	3,d",		0,		/* cb5a */
	"bit	3,e",		0,		/* cb5b */
	"bit	3,h",		0,		/* cb5c */
	"bit	3,l",		0,		/* cb5d */
	"bit	3,(hl)",	0,		/* cb5e */
	"bit	3,a",		0,		/* cb5f */
	
	"bit	4,b",		0,		/* cb60 */
	"bit	4,c",		0,		/* cb61 */
	"bit	4,d",		0,		/* cb62 */
	"bit	4,e",		0,		/* cb63 */
	"bit	4,h",		0,		/* cb64 */
	"bit	4,l",		0,		/* cb65 */
	"bit	4,(hl)",	0,		/* cb66 */
	"bit	4,a",		0,		/* cb67 */
	
	"bit	5,b",		0,		/* cb68 */
	"bit	5,c",		0,		/* cb69 */
	"bit	5,d",		0,		/* cb6a */
	"bit	5,e",		0,		/* cb6b */
	"bit	5,h",		0,		/* cb6c */
	"bit	5,l",		0,		/* cb6d */
	"bit	5,(hl)",	0,		/* cb6e */
	"bit	5,a",		0,		/* cb6f */
	
	"bit	6,b",		0,		/* cb70 */
	"bit	6,c",		0,		/* cb71 */
	"bit	6,d",		0,		/* cb72 */
	"bit	6,e",		0,		/* cb73 */
	"bit	6,h",		0,		/* cb74 */
	"bit	6,l",		0,		/* cb75 */
	"bit	6,(hl)",	0,		/* cb76 */
	"bit	6,a",		0,		/* cb77 */
	
	"bit	7,b",		0,		/* cb78 */
	"bit	7,c",		0,		/* cb79 */
	"bit	7,d",		0,		/* cb7a */
	"bit	7,e",		0,		/* cb7b */
	"bit	7,h",		0,		/* cb7c */
	"bit	7,l",		0,		/* cb7d */
	"bit	7,(hl)",	0,		/* cb7e */
	"bit	7,a",		0,		/* cb7f */
	
	"res	0,b",		0,		/* cb80 */
	"res	0,c",		0,		/* cb81 */
	"res	0,d",		0,		/* cb82 */
	"res	0,e",		0,		/* cb83 */
	"res	0,h",		0,		/* cb84 */
	"res	0,l",		0,		/* cb85 */
	"res	0,(hl)",	0,		/* cb86 */
	"res	0,a",		0,		/* cb87 */
	
	"res	1,b",		0,		/* cb88 */
	"res	1,c",		0,		/* cb89 */
	"res	1,d",		0,		/* cb8a */
	"res	1,e",		0,		/* cb8b */
	"res	1,h",		0,		/* cb8c */
	"res	1,l",		0,		/* cb8d */
	"res	1,(hl)",	0,		/* cb8e */
	"res	1,a",		0,		/* cb8f */
	
	"res	2,b",		0,		/* cb90 */
	"res	2,c",		0,		/* cb91 */
	"res	2,d",		0,		/* cb92 */
	"res	2,e",		0,		/* cb93 */
	"res	2,h",		0,		/* cb94 */
	"res	2,l",		0,		/* cb95 */
	"res	2,(hl)",	0,		/* cb96 */
	"res	2,a",		0,		/* cb97 */
	
	"res	3,b",		0,		/* cb98 */
	"res	3,c",		0,		/* cb99 */
	"res	3,d",		0,		/* cb9a */
	"res	3,e",		0,		/* cb9b */
	"res	3,h",		0,		/* cb9c */
	"res	3,l",		0,		/* cb9d */
	"res	3,(hl)",	0,		/* cb9e */
	"res	3,a",		0,		/* cb9f */
	
	"res	4,b",		0,		/* cba0 */
	"res	4,c",		0,		/* cba1 */
	"res	4,d",		0,		/* cba2 */
	"res	4,e",		0,		/* cba3 */
	"res	4,h",		0,		/* cba4 */
	"res	4,l",		0,		/* cba5 */
	"res	4,(hl)",	0,		/* cba6 */
	"res	4,a",		0,		/* cba7 */
	
	"res	5,b",		0,		/* cba8 */
	"res	5,c",		0,		/* cba9 */
	"res	5,d",		0,		/* cbaa */
	"res	5,e",		0,		/* cbab */
	"res	5,h",		0,		/* cbac */
	"res	5,l",		0,		/* cbad */
	"res	5,(hl)",	0,		/* cbae */
	"res	5,a",		0,		/* cbaf */
	
	"res	6,b",		0,		/* cbb0 */
	"res	6,c",		0,		/* cbb1 */
	"res	6,d",		0,		/* cbb2 */
	"res	6,e",		0,		/* cbb3 */
	"res	6,h",		0,		/* cbb4 */
	"res	6,l",		0,		/* cbb5 */
	"res	6,(hl)",	0,		/* cbb6 */
	"res	6,a",		0,		/* cbb7 */
	
	"res	7,b",		0,		/* cbb8 */
	"res	7,c",		0,		/* cbb9 */
	"res	7,d",		0,		/* cbba */
	"res	7,e",		0,		/* cbbb */
	"res	7,h",		0,		/* cbbc */
	"res	7,l",		0,		/* cbbd */
	"res	7,(hl)",	0,		/* cbbe */
	"res	7,a",		0,		/* cbbf */
	
	"set	0,b",		0,		/* cbc0 */
	"set	0,c",		0,		/* cbc1 */
	"set	0,d",		0,		/* cbc2 */
	"set	0,e",		0,		/* cbc3 */
	"set	0,h",		0,		/* cbc4 */
	"set	0,l",		0,		/* cbc5 */
	"set	0,(hl)",	0,		/* cbc6 */
	"set	0,a",		0,		/* cbc7 */
	
	"set	1,b",		0,		/* cbc8 */
	"set	1,c",		0,		/* cbc9 */
	"set	1,d",		0,		/* cbca */
	"set	1,e",		0,		/* cbcb */
	"set	1,h",		0,		/* cbcc */
	"set	1,l",		0,		/* cbcd */
	"set	1,(hl)",	0,		/* cbce */
	"set	1,a",		0,		/* cbcf */
	
	"set	2,b",		0,		/* cbd0 */
	"set	2,c",		0,		/* cbd1 */
	"set	2,d",		0,		/* cbd2 */
	"set	2,e",		0,		/* cbd3 */
	"set	2,h",		0,		/* cbd4 */
	"set	2,l",		0,		/* cbd5 */
	"set	2,(hl)",	0,		/* cbd6 */
	"set	2,a",		0,		/* cbd7 */
	
	"set	3,b",		0,		/* cbd8 */
	"set	3,c",		0,		/* cbd9 */
	"set	3,d",		0,		/* cbda */
	"set	3,e",		0,		/* cbdb */
	"set	3,h",		0,		/* cbdc */
	"set	3,l",		0,		/* cbdd */
	"set	3,(hl)",	0,		/* cbde */
	"set	3,a",		0,		/* cbdf */
	
	"set	4,b",		0,		/* cbe0 */
	"set	4,c",		0,		/* cbe1 */
	"set	4,d",		0,		/* cbe2 */
	"set	4,e",		0,		/* cbe3 */
	"set	4,h",		0,		/* cbe4 */
	"set	4,l",		0,		/* cbe5 */
	"set	4,(hl)",	0,		/* cbe6 */
	"set	4,a",		0,		/* cbe7 */
	
	"set	5,b",		0,		/* cbe8 */
	"set	5,c",		0,		/* cbe9 */
	"set	5,d",		0,		/* cbea */
	"set	5,e",		0,		/* cbeb */
	"set	5,h",		0,		/* cbec */
	"set	5,l",		0,		/* cbed */
	"set	5,(hl)",	0,		/* cbee */
	"set	5,a",		0,		/* cbef */
	
	"set	6,b",		0,		/* cbf0 */
	"set	6,c",		0,		/* cbf1 */
	"set	6,d",		0,		/* cbf2 */
	"set	6,e",		0,		/* cbf3 */
	"set	6,h",		0,		/* cbf4 */
	"set	6,l",		0,		/* cbf5 */
	"set	6,(hl)",	0,		/* cbf6 */
	"set	6,a",		0,		/* cbf7 */
	
	"set	7,b",		0,		/* cbf8 */
	"set	7,c",		0,		/* cbf9 */
	"set	7,d",		0,		/* cbfa */
	"set	7,e",		0,		/* cbfb */
	"set	7,h",		0,		/* cbfc */
	"set	7,l",		0,		/* cbfd */
	"set	7,(hl)",	0,		/* cbfe */
	"set	7,a",		0,		/* cbff */
							/* dd */
	undefined,		0,		/* dd00 */
	undefined,		0,		/* dd01 */
	undefined,		0,		/* dd02 */
	undefined,		0,		/* dd03 */
	undefined,		0,		/* dd04 */
	undefined,		0,		/* dd05 */
	undefined,		0,		/* dd06 */
	undefined,		0,		/* dd07 */

	undefined,		0,		/* dd08 */
	"add	ix,bc",		0,		/* dd09 */
	undefined,		0,		/* dd0a */
	undefined,		0,		/* dd0b */
	undefined,		0,		/* dd0c */
	undefined,		0,		/* dd0d */
	undefined,		0,		/* dd0e */
	undefined,		0,		/* dd0f */

	undefined,		0,		/* dd10 */
	undefined,		0,		/* dd11 */
	undefined,		0,		/* dd12 */
	undefined,		0,		/* dd13 */
	undefined,		0,		/* dd14 */
	undefined,		0,		/* dd15 */
	undefined,		0,		/* dd16 */
	undefined,		0,		/* dd17 */

	undefined,		0,		/* dd18 */
	"add	ix,de",		0,		/* dd19 */
	undefined,		0,		/* dd1a */
	undefined,		0,		/* dd1b */
	undefined,		0,		/* dd1c */
	undefined,		0,		/* dd1d */
	undefined,		0,		/* dd1e */
	undefined,		0,		/* dd1f */

	undefined,		0,		/* dd20 */
	"ld	ix,%02x%02xh",	2,		/* dd21 */
	"ld	(%02x%02xh),ix",2,		/* dd22 */
	"inc	ix",		0,		/* dd23 */
	undefined,		0,		/* dd24 */
	undefined,		0,		/* dd25 */
	undefined,		0,		/* dd26 */
	undefined,		0,		/* dd27 */

	undefined,		0,		/* dd28 */
	"add	ix,ix",		0,		/* dd29 */
	"ld	ix,(%02x%02xh)",2,		/* dd2a */
	"dec	ix",		0,		/* dd2b */
	undefined,		0,		/* dd2c */
	undefined,		0,		/* dd2d */
	undefined,		0,		/* dd2e */
	undefined,		0,		/* dd2f */

	undefined,		0,		/* dd30 */
	undefined,		0,		/* dd31 */
	undefined,		0,		/* dd32 */
	undefined,		0,		/* dd33 */
	"inc	(ix+%02xh)",	1,		/* dd34 */
	"dec	(ix+%02xh)",	1,		/* dd35 */
	"ld	(ix+%02xh),%02xh",2,		/* dd36 */
	undefined,		0,		/* dd37 */

	undefined,		0,		/* dd38 */
	"add	ix,sp",		0,		/* dd39 */
	undefined,		0,		/* dd3a */
	undefined,		0,		/* dd3b */
	undefined,		0,		/* dd3c */
	undefined,		0,		/* dd3d */
	undefined,		0,		/* dd3e */
	undefined,		0,		/* dd3f */

	undefined,		0,		/* dd40 */
	undefined,		0,		/* dd41 */
	undefined,		0,		/* dd42 */
	undefined,		0,		/* dd43 */
	undefined,		0,		/* dd44 */
	undefined,		0,		/* dd45 */
	"ld	b,(ix+%02xh)",	1,		/* dd46 */
	undefined,		0,		/* dd47 */

	undefined,		0,		/* dd48 */
	undefined,		0,		/* dd49 */
	undefined,		0,		/* dd4a */
	undefined,		0,		/* dd4b */
	undefined,		0,		/* dd4c */
	undefined,		0,		/* dd4d */
	"ld	c,(ix+%02xh)",	1,		/* dd4e */
	undefined,		0,		/* dd4f */
	
	undefined,		0,		/* dd50 */
	undefined,		0,		/* dd51 */
	undefined,		0,		/* dd52 */
	undefined,		0,		/* dd53 */
	undefined,		0,		/* dd54 */
	undefined,		0,		/* dd55 */
	"ld	d,(ix+%02xh)",	1,		/* dd56 */
	undefined,		0,		/* dd57 */

	undefined,		0,		/* dd58 */
	undefined,		0,		/* dd59 */
	undefined,		0,		/* dd5a */
	undefined,		0,		/* dd5b */
	undefined,		0,		/* dd5c */
	undefined,		0,		/* dd5d */
	"ld	e,(ix+%02xh)",	1,		/* dd5e */
	undefined,		0,		/* dd5f */
	
	undefined,		0,		/* dd60 */
	undefined,		0,		/* dd61 */
	undefined,		0,		/* dd62 */
	undefined,		0,		/* dd63 */
	undefined,		0,		/* dd64 */
	undefined,		0,		/* dd65 */
	"ld	h,(ix+%02xh)",	1,		/* dd66 */
	undefined,		0,		/* dd67 */

	undefined,		0,		/* dd68 */
	undefined,		0,		/* dd69 */
	undefined,		0,		/* dd6a */
	undefined,		0,		/* dd6b */
	undefined,		0,		/* dd6c */
	undefined,		0,		/* dd6d */
	"ld	l,(ix+%02xh)",	1,		/* dd6e */
	undefined,		0,		/* dd6f */
	
	"ld	(ix+%02xh),b",	1,		/* dd70 */
	"ld	(ix+%02xh),c",	1,		/* dd71 */
	"ld	(ix+%02xh),d",	1,		/* dd72 */
	"ld	(ix+%02xh),e",	1,		/* dd73 */
	"ld	(ix+%02xh),h",	1,		/* dd74 */
	"ld	(ix+%02xh),l",	1,		/* dd75 */
	undefined,		0,		/* dd76 */
	"ld	(ix+%02xh),a",	1,		/* dd77 */

	undefined,		0,		/* dd78 */
	undefined,		0,		/* dd79 */
	undefined,		0,		/* dd7a */
	undefined,		0,		/* dd7b */
	undefined,		0,		/* dd7c */
	undefined,		0,		/* dd7d */
	"ld	a,(ix+%02xh)",	1,		/* dd7e */
	undefined,		0,		/* dd7f */

	undefined,		0,		/* dd80 */
	undefined,		0,		/* dd81 */
	undefined,		0,		/* dd82 */
	undefined,		0,		/* dd83 */
	undefined,		0,		/* dd84 */
	undefined,		0,		/* dd85 */
	"add	a,(ix+%02xh)",	1,		/* dd86 */
	undefined,		0,		/* dd87 */

	undefined,		0,		/* dd88 */
	undefined,		0,		/* dd89 */
	undefined,		0,		/* dd8a */
	undefined,		0,		/* dd8b */
	undefined,		0,		/* dd8c */
	undefined,		0,		/* dd8d */
	"adc	a,(ix+%02xh)",	1,		/* dd8e */
	undefined,		0,		/* dd8f */
	
	undefined,		0,		/* dd90 */
	undefined,		0,		/* dd91 */
	undefined,		0,		/* dd92 */
	undefined,		0,		/* dd93 */
	undefined,		0,		/* dd94 */
	undefined,		0,		/* dd95 */
	"sub	(ix+%02xh)",	1,		/* dd96 */
	undefined,		0,		/* dd97 */

	undefined,		0,		/* dd98 */
	undefined,		0,		/* dd99 */
	undefined,		0,		/* dd9a */
	undefined,		0,		/* dd9b */
	undefined,		0,		/* dd9c */
	undefined,		0,		/* dd9d */
	"sbc	a,(ix+%02xh)",	1,		/* dd9e */
	undefined,		0,		/* dd9f */
	
	undefined,		0,		/* dda0 */
	undefined,		0,		/* dda1 */
	undefined,		0,		/* dda2 */
	undefined,		0,		/* dda3 */
	undefined,		0,		/* dda4 */
	undefined,		0,		/* dda5 */
	"and	(ix+%02xh)",	1,		/* dda6 */
	undefined,		0,		/* dda7 */

	undefined,		0,		/* dda8 */
	undefined,		0,		/* dda9 */
	undefined,		0,		/* ddaa */
	undefined,		0,		/* ddab */
	undefined,		0,		/* ddac */
	undefined,		0,		/* ddad */
	"xor	(ix+%02xh)",	1,		/* ddae */
	undefined,		0,		/* ddaf */
	
	undefined,		0,		/* ddb0 */
	undefined,		0,		/* ddb1 */
	undefined,		0,		/* ddb2 */
	undefined,		0,		/* ddb3 */
	undefined,		0,		/* ddb4 */
	undefined,		0,		/* ddb5 */
	"or	(ix+%02xh)",	1,		/* ddb6 */
	undefined,		0,		/* ddb7 */

	undefined,		0,		/* ddb8 */
	undefined,		0,		/* ddb9 */
	undefined,		0,		/* ddba */
	undefined,		0,		/* ddbb */
	undefined,		0,		/* ddbc */
	undefined,		0,		/* ddbd */
	"cp	(ix+%02xh)",	1,		/* ddbe */
	undefined,		0,		/* ddbf */
	
	undefined,		0,		/* ddc0 */
	undefined,		0,		/* ddc1 */
	undefined,		0,		/* ddc2 */
	undefined,		0,		/* ddc3 */
	undefined,		0,		/* ddc4 */
	undefined,		0,		/* ddc5 */
	undefined,		0,		/* ddc6 */
	undefined,		0,		/* ddc7 */

	undefined,		0,		/* ddc8 */
	undefined,		0,		/* ddc9 */
	undefined,		0,		/* ddca */
	"dd cb	%02x,%02x",	2,		/* ddcb */
	undefined,		0,		/* ddcc */
	undefined,		0,		/* ddcd */
	undefined,		0,		/* ddce */
	undefined,		0,		/* ddcf */
	
	undefined,		0,		/* ddd0 */
	undefined,		0,		/* ddd1 */
	undefined,		0,		/* ddd2 */
	undefined,		0,		/* ddd3 */
	undefined,		0,		/* ddd4 */
	undefined,		0,		/* ddd5 */
	undefined,		0,		/* ddd6 */
	undefined,		0,		/* ddd7 */

	undefined,		0,		/* ddd8 */
	undefined,		0,		/* ddd9 */
	undefined,		0,		/* ddda */
	undefined,		0,		/* dddb */
	undefined,		0,		/* dddc */
	undefined,		0,		/* dddd */
	undefined,		0,		/* ddde */
	undefined,		0,		/* dddf */
	
	undefined,		0,		/* dde0 */
	"pop	ix",		0,		/* dde1 */
	undefined,		0,		/* dde2 */
	"ex	(sp),ix",	0,		/* dde3 */
	undefined,		0,		/* dde4 */
	"push	ix",		0,		/* dde5 */
	undefined,		0,		/* dde6 */
	undefined,		0,		/* dde7 */

	undefined,		0,		/* dde8 */
	"jp	(ix)",		0,		/* dde9 */
	undefined,		0,		/* ddea */
	undefined,		0,		/* ddeb */
	undefined,		0,		/* ddec */
	undefined,		0,		/* dded */
	undefined,		0,		/* ddee */
	undefined,		0,		/* ddef */
	
	undefined,		0,		/* ddf0 */
	undefined,		0,		/* ddf1 */
	undefined,		0,		/* ddf2 */
	undefined,		0,		/* ddf3 */
	undefined,		0,		/* ddf4 */
	undefined,		0,		/* ddf5 */
	undefined,		0,		/* ddf6 */
	undefined,		0,		/* ddf7 */

	undefined,		0,		/* ddf8 */
	"ld	sp,ix",		0,		/* ddf9 */
	undefined,		0,		/* ddfa */
	undefined,		0,		/* ddfb */
	undefined,		0,		/* ddfc */
	undefined,		0,		/* ddfd */
	undefined,		0,		/* ddfe */
	undefined,		0,		/* ddff */
							/* ed */
	undefined,		0,		/* ed00 */
	undefined,		0,		/* ed01 */
	undefined,		0,		/* ed02 */
	undefined,		0,		/* ed03 */
	undefined,		0,		/* ed04 */
	undefined,		0,		/* ed05 */
	undefined,		0,		/* ed06 */
	undefined,		0,		/* ed07 */

	undefined,		0,		/* ed08 */
	undefined,		0,		/* ed09 */
	undefined,		0,		/* ed0a */
	undefined,		0,		/* ed0b */
	undefined,		0,		/* ed0c */
	undefined,		0,		/* ed0d */
	undefined,		0,		/* ed0e */
	undefined,		0,		/* ed0f */

	undefined,		0,		/* ed10 */
	undefined,		0,		/* ed11 */
	undefined,		0,		/* ed12 */
	undefined,		0,		/* ed13 */
	undefined,		0,		/* ed14 */
	undefined,		0,		/* ed15 */
	undefined,		0,		/* ed16 */
	undefined,		0,		/* ed17 */

	undefined,		0,		/* ed18 */
	undefined,		0,		/* ed19 */
	undefined,		0,		/* ed1a */
	undefined,		0,		/* ed1b */
	undefined,		0,		/* ed1c */
	undefined,		0,		/* ed1d */
	undefined,		0,		/* ed1e */
	undefined,		0,		/* ed1f */

	undefined,		0,		/* ed20 */
	undefined,		0,		/* ed21 */
	undefined,		0,		/* ed22 */
	undefined,		0,		/* ed23 */
	undefined,		0,		/* ed24 */
	undefined,		0,		/* ed25 */
	undefined,		0,		/* ed26 */
	undefined,		0,		/* ed27 */

	undefined,		0,		/* ed28 */
	undefined,		0,		/* ed29 */
	undefined,		0,		/* ed2a */
	undefined,		0,		/* ed2b */
	undefined,		0,		/* ed2c */
	undefined,		0,		/* ed2d */
	undefined,		0,		/* ed2e */
	undefined,		0,		/* ed2f */

	undefined,		0,		/* ed30 */
	undefined,		0,		/* ed31 */
	undefined,		0,		/* ed32 */
	undefined,		0,		/* ed33 */
	undefined,		0,		/* ed34 */
	undefined,		0,		/* ed35 */
	undefined,		0,		/* ed36 */
	undefined,		0,		/* ed37 */

	undefined,		0,		/* ed38 */
	undefined,		0,		/* ed39 */
	undefined,		0,		/* ed3a */
	undefined,		0,		/* ed3b */
	undefined,		0,		/* ed3c */
	undefined,		0,		/* ed3d */
	undefined,		0,		/* ed3e */
	undefined,		0,		/* ed3f */

	"in	b,(c)",		0,		/* ed40 */
	"out	(c),b",		0,		/* ed41 */
	"sbc	hl,bc",		0,		/* ed42 */
	"ld	(%02x%02xh),bc",2,		/* ed43 */
	"neg",			0,		/* ed44 */
	"retn",			0,		/* ed45 */
	"im	0",		0,		/* ed46 */
	"ld	i,a",		0,		/* ed47 */
	
	"in	c,(c)",		0,		/* ed48 */
	"out	(c),c",		0,		/* ed49 */
	"adc	hl,bc",		0,		/* ed4a */
	"ld	bc,(%02x%02xh)",2,		/* ed4b */
	undefined,		0,		/* ed4c */
	"reti",			0,		/* ed4d */
	undefined,		0,		/* ed4e */
	undefined,		0,		/* ed4f */

	"in	d,(c)",		0,		/* ed50 */
	"out	(c),d",		0,		/* ed51 */
	"sbc	hl,de",		0,		/* ed52 */
	"ld	(%02x%02xh),de",2,		/* ed53 */
	undefined,		0,		/* ed54 */
	undefined,		0,		/* ed55 */
	"im	1",		0,		/* ed56 */
	"ld	a,i",		0,		/* ed57 */

	"in	e,(c)",		0,		/* ed58 */
	"out	(c),e",		0,		/* ed59 */
	"adc	hl,de",		0,		/* ed5a */
	"ld	de,(%02x%02xh)",2,		/* ed5b */
	undefined,		0,		/* ed5c */
	undefined,		0,		/* ed5d */
	"im	2",		0,		/* ed5e */
	undefined,		0,		/* ed5f */

	"in	h,(c)",		0,		/* ed60 */
	"out	(c),h",		0,		/* ed61 */
	"sbc	hl,hl",		0,		/* ed62 */
	undefined,		0,		/* ed63 */
	undefined,		0,		/* ed64 */
	undefined,		0,		/* ed65 */
	undefined,		0,		/* ed66 */
	"rrd",			0,		/* ed67 */

	"in	l,(c)",		0,		/* ed68 */
	"out	(c),l",		0,		/* ed69 */
	"adc	hl,hl",		0,		/* ed6a */
	undefined,		0,		/* ed6b */
	undefined,		0,		/* ed6c */
	undefined,		0,		/* ed6d */
	undefined,		0,		/* ed6e */
	"rld",			0,		/* ed6f */
	
	undefined,		0,		/* ed70 */
	undefined,		0,		/* ed71 */
	"sbc	hl,sp",		0,		/* ed72 */
	"ld	(%02x%02xh),sp",2,		/* ed73 */
	undefined,		0,		/* ed74 */
	undefined,		0,		/* ed75 */
	undefined,		0,		/* ed76 */
	undefined,		0,		/* ed77 */

	"in	a,(c)",		0,		/* ed78 */
	"out	(c),a",		0,		/* ed79 */
	"adc	hl,sp",		0,		/* ed7a */
	"ld	sp,(%02x%02xh)",2,		/* ed7b */
	undefined,		0,		/* ed7c */
	undefined,		0,		/* ed7d */
	undefined,		0,		/* ed7e */
	undefined,		0,		/* ed7f */

	undefined,		0,		/* ed80 */
	undefined,		0,		/* ed81 */
	undefined,		0,		/* ed82 */
	undefined,		0,		/* ed83 */
	undefined,		0,		/* ed84 */
	undefined,		0,		/* ed85 */
	undefined,		0,		/* ed86 */
	undefined,		0,		/* ed87 */

	undefined,		0,		/* ed88 */
	undefined,		0,		/* ed89 */
	undefined,		0,		/* ed8a */
	undefined,		0,		/* ed8b */
	undefined,		0,		/* ed8c */
	undefined,		0,		/* ed8d */
	undefined,		0,		/* ed8e */
	undefined,		0,		/* ed8f */

	undefined,		0,		/* ed90 */
	undefined,		0,		/* ed91 */
	undefined,		0,		/* ed92 */
	undefined,		0,		/* ed93 */
	undefined,		0,		/* ed94 */
	undefined,		0,		/* ed95 */
	undefined,		0,		/* ed96 */
	undefined,		0,		/* ed97 */

	undefined,		0,		/* ed98 */
	undefined,		0,		/* ed99 */
	undefined,		0,		/* ed9a */
	undefined,		0,		/* ed9b */
	undefined,		0,		/* ed9c */
	undefined,		0,		/* ed9d */
	undefined,		0,		/* ed9e */
	undefined,		0,		/* ed9f */

	"ldi",			0,		/* eda0 */
	"cpi",			0,		/* eda1 */
	"ini",			0,		/* eda2 */
	"outi",			0,		/* eda3 */
	undefined,		0,		/* eda4 */
	undefined,		0,		/* eda5 */
	undefined,		0,		/* eda6 */
	undefined,		0,		/* eda7 */

	"ldd",			0,		/* eda8 */
	"cpd",			0,		/* eda9 */
	"ind",			0,		/* edaa */
	"outd",			0,		/* edab */
	undefined,		0,		/* edac */
	undefined,		0,		/* edad */
	undefined,		0,		/* edae */
	undefined,		0,		/* edaf */

	"ldir",			0,		/* edb0 */
	"cpir",			0,		/* edb1 */
	"inir",			0,		/* edb2 */
	"otir",			0,		/* edb3 */
	undefined,		0,		/* edb4 */
	undefined,		0,		/* edb5 */
	undefined,		0,		/* edb6 */
	undefined,		0,		/* edb7 */

	"lddr",			0,		/* edb8 */
	"cpdr",			0,		/* edb9 */
	"indr",			0,		/* edba */
	"otdr",			0,		/* edbb */
	undefined,		0,		/* edbc */
	undefined,		0,		/* edbd */
	undefined,		0,		/* edbe */
	undefined,		0,		/* edbf */

	undefined,		0,		/* edc0 */
	undefined,		0,		/* edc1 */
	undefined,		0,		/* edc2 */
	undefined,		0,		/* edc3 */
	undefined,		0,		/* edc4 */
	undefined,		0,		/* edc5 */
	undefined,		0,		/* edc6 */
	undefined,		0,		/* edc7 */

	undefined,		0,		/* edc8 */
	undefined,		0,		/* edc9 */
	undefined,		0,		/* edca */
	undefined,		0,		/* edcb */
	undefined,		0,		/* edcc */
	undefined,		0,		/* edcd */
	undefined,		0,		/* edce */
	undefined,		0,		/* edcf */

	undefined,		0,		/* edd0 */
	undefined,		0,		/* edd1 */
	undefined,		0,		/* edd2 */
	undefined,		0,		/* edd3 */
	undefined,		0,		/* edd4 */
	undefined,		0,		/* edd5 */
	undefined,		0,		/* edd6 */
	undefined,		0,		/* edd7 */

	undefined,		0,		/* edd8 */
	undefined,		0,		/* edd9 */
	undefined,		0,		/* edda */
	undefined,		0,		/* eddb */
	undefined,		0,		/* eddc */
	undefined,		0,		/* eddd */
	undefined,		0,		/* edde */
	undefined,		0,		/* eddf */

	undefined,		0,		/* ede0 */
	undefined,		0,		/* ede1 */
	undefined,		0,		/* ede2 */
	undefined,		0,		/* ede3 */
	undefined,		0,		/* ede4 */
	undefined,		0,		/* ede5 */
	undefined,		0,		/* ede6 */
	undefined,		0,		/* ede7 */

	undefined,		0,		/* ede8 */
	undefined,		0,		/* ede9 */
	undefined,		0,		/* edea */
	undefined,		0,		/* edeb */
	undefined,		0,		/* edec */
	undefined,		0,		/* eded */
	undefined,		0,		/* edee */
	undefined,		0,		/* edef */

	undefined,		0,		/* edf0 */
	undefined,		0,		/* edf1 */
	undefined,		0,		/* edf2 */
	undefined,		0,		/* edf3 */
	undefined,		0,		/* edf4 */
	undefined,		0,		/* edf5 */
	undefined,		0,		/* edf6 */
	undefined,		0,		/* edf7 */

	undefined,		0,		/* edf8 */
	undefined,		0,		/* edf9 */
	undefined,		0,		/* edfa */
	undefined,		0,		/* edfb */
	undefined,		0,		/* edfc */
	undefined,		0,		/* edfd */
	undefined,		0,		/* edfe */
	undefined,		0,		/* edff */
							/* fd */
	undefined,		0,		/* fd00 */
	undefined,		0,		/* fd01 */
	undefined,		0,		/* fd02 */
	undefined,		0,		/* fd03 */
	undefined,		0,		/* fd04 */
	undefined,		0,		/* fd05 */
	undefined,		0,		/* fd06 */
	undefined,		0,		/* fd07 */

	undefined,		0,		/* fd08 */
	"add	iy,bc",		0,		/* fd09 */
	undefined,		0,		/* fd0a */
	undefined,		0,		/* fd0b */
	undefined,		0,		/* fd0c */
	undefined,		0,		/* fd0d */
	undefined,		0,		/* fd0e */
	undefined,		0,		/* fd0f */

	undefined,		0,		/* fd10 */
	undefined,		0,		/* fd11 */
	undefined,		0,		/* fd12 */
	undefined,		0,		/* fd13 */
	undefined,		0,		/* fd14 */
	undefined,		0,		/* fd15 */
	undefined,		0,		/* fd16 */
	undefined,		0,		/* fd17 */

	undefined,		0,		/* fd18 */
	"add	iy,de",		0,		/* fd19 */
	undefined,		0,		/* fd1a */
	undefined,		0,		/* fd1b */
	undefined,		0,		/* fd1c */
	undefined,		0,		/* fd1d */
	undefined,		0,		/* fd1e */
	undefined,		0,		/* fd1f */

	undefined,		0,		/* fd20 */
	"ld	iy,%02x%02xh",	2,		/* fd21 */
	"ld	(%02x%02xh),iy",2,		/* fd22 */
	"inc	iy",		0,		/* fd23 */
	undefined,		0,		/* fd24 */
	undefined,		0,		/* fd25 */
	undefined,		0,		/* fd26 */
	undefined,		0,		/* fd27 */

	undefined,		0,		/* fd28 */
	"add	iy,iy",		0,		/* fd29 */
	"ld	iy,(%02x%02xh)",2,		/* fd2a */
	"dec	iy",		0,		/* fd2b */
	undefined,		0,		/* fd2c */
	undefined,		0,		/* fd2d */
	undefined,		0,		/* fd2e */
	undefined,		0,		/* fd2f */

	undefined,		0,		/* fd30 */
	undefined,		0,		/* fd31 */
	undefined,		0,		/* fd32 */
	undefined,		0,		/* fd33 */
	"inc	(iy+%02xh)",	1,		/* fd34 */
	"dec	(iy+%02xh)",	1,		/* fd35 */
	"ld	(iy+%02xh),%02xh",2,		/* fd36 */
	undefined,		0,		/* fd37 */

	undefined,		0,		/* fd38 */
	"add	iy,sp",		0,		/* fd39 */
	undefined,		0,		/* fd3a */
	undefined,		0,		/* fd3b */
	undefined,		0,		/* fd3c */
	undefined,		0,		/* fd3d */
	undefined,		0,		/* fd3e */
	undefined,		0,		/* fd3f */

	undefined,		0,		/* fd40 */
	undefined,		0,		/* fd41 */
	undefined,		0,		/* fd42 */
	undefined,		0,		/* fd43 */
	undefined,		0,		/* fd44 */
	undefined,		0,		/* fd45 */
	"ld	b,(iy+%02xh)",	1,		/* fd46 */
	undefined,		0,		/* fd47 */

	undefined,		0,		/* fd48 */
	undefined,		0,		/* fd49 */
	undefined,		0,		/* fd4a */
	undefined,		0,		/* fd4b */
	undefined,		0,		/* fd4c */
	undefined,		0,		/* fd4d */
	"ld	c,(iy+%02xh)",	1,		/* fd4e */
	undefined,		0,		/* fd4f */
	
	undefined,		0,		/* fd50 */
	undefined,		0,		/* fd51 */
	undefined,		0,		/* fd52 */
	undefined,		0,		/* fd53 */
	undefined,		0,		/* fd54 */
	undefined,		0,		/* fd55 */
	"ld	d,(iy+%02xh)",	1,		/* fd56 */
	undefined,		0,		/* fd57 */

	undefined,		0,		/* fd58 */
	undefined,		0,		/* fd59 */
	undefined,		0,		/* fd5a */
	undefined,		0,		/* fd5b */
	undefined,		0,		/* fd5c */
	undefined,		0,		/* fd5d */
	"ld	e,(iy+%02xh)",	1,		/* fd5e */
	undefined,		0,		/* fd5f */
	
	undefined,		0,		/* fd60 */
	undefined,		0,		/* fd61 */
	undefined,		0,		/* fd62 */
	undefined,		0,		/* fd63 */
	undefined,		0,		/* fd64 */
	undefined,		0,		/* fd65 */
	"ld	h,(iy+%02xh)",	1,		/* fd66 */
	undefined,		0,		/* fd67 */

	undefined,		0,		/* fd68 */
	undefined,		0,		/* fd69 */
	undefined,		0,		/* fd6a */
	undefined,		0,		/* fd6b */
	undefined,		0,		/* fd6c */
	undefined,		0,		/* fd6d */
	"ld	l,(iy+%02xh)",	1,		/* fd6e */
	undefined,		0,		/* fd6f */
	
	"ld	(iy+%02xh),b",	1,		/* fd70 */
	"ld	(iy+%02xh),c",	1,		/* fd71 */
	"ld	(iy+%02xh),d",	1,		/* fd72 */
	"ld	(iy+%02xh),e",	1,		/* fd73 */
	"ld	(iy+%02xh),h",	1,		/* fd74 */
	"ld	(iy+%02xh),l",	1,		/* fd75 */
	undefined,		0,		/* fd76 */
	"ld	(iy+%02xh),a",	1,		/* fd77 */

	undefined,		0,		/* fd78 */
	undefined,		0,		/* fd79 */
	undefined,		0,		/* fd7a */
	undefined,		0,		/* fd7b */
	undefined,		0,		/* fd7c */
	undefined,		0,		/* fd7d */
	"ld	a,(iy+%02xh)",	1,		/* fd7e */
	undefined,		0,		/* fd7f */

	undefined,		0,		/* fd80 */
	undefined,		0,		/* fd81 */
	undefined,		0,		/* fd82 */
	undefined,		0,		/* fd83 */
	undefined,		0,		/* fd84 */
	undefined,		0,		/* fd85 */
	"add	a,(iy+%02xh)",	1,		/* fd86 */
	undefined,		0,		/* fd87 */

	undefined,		0,		/* fd88 */
	undefined,		0,		/* fd89 */
	undefined,		0,		/* fd8a */
	undefined,		0,		/* fd8b */
	undefined,		0,		/* fd8c */
	undefined,		0,		/* fd8d */
	"adc	a,(iy+%02xh)",	1,		/* fd8e */
	undefined,		0,		/* fd8f */
	
	undefined,		0,		/* fd90 */
	undefined,		0,		/* fd91 */
	undefined,		0,		/* fd92 */
	undefined,		0,		/* fd93 */
	undefined,		0,		/* fd94 */
	undefined,		0,		/* fd95 */
	"sub	(iy+%02xh)",	1,		/* fd96 */
	undefined,		0,		/* fd97 */

	undefined,		0,		/* fd98 */
	undefined,		0,		/* fd99 */
	undefined,		0,		/* fd9a */
	undefined,		0,		/* fd9b */
	undefined,		0,		/* fd9c */
	undefined,		0,		/* fd9d */
	"sbc	a,(iy+%02xh)",	1,		/* fd9e */
	undefined,		0,		/* fd9f */
	
	undefined,		0,		/* fda0 */
	undefined,		0,		/* fda1 */
	undefined,		0,		/* fda2 */
	undefined,		0,		/* fda3 */
	undefined,		0,		/* fda4 */
	undefined,		0,		/* fda5 */
	"and	(iy+%02xh)",	1,		/* fda6 */
	undefined,		0,		/* fda7 */

	undefined,		0,		/* fda8 */
	undefined,		0,		/* fda9 */
	undefined,		0,		/* fdaa */
	undefined,		0,		/* fdab */
	undefined,		0,		/* fdac */
	undefined,		0,		/* fdad */
	"xor	(iy+%02xh)",	1,		/* fdae */
	undefined,		0,		/* fdaf */
	
	undefined,		0,		/* fdb0 */
	undefined,		0,		/* fdb1 */
	undefined,		0,		/* fdb2 */
	undefined,		0,		/* fdb3 */
	undefined,		0,		/* fdb4 */
	undefined,		0,		/* fdb5 */
	"or	(iy+%02xh)",	1,		/* fdb6 */
	undefined,		0,		/* fdb7 */

	undefined,		0,		/* fdb8 */
	undefined,		0,		/* fdb9 */
	undefined,		0,		/* fdba */
	undefined,		0,		/* fdbb */
	undefined,		0,		/* fdbc */
	undefined,		0,		/* fdbd */
	"cp	(iy+%02xh)",	1,		/* fdbe */
	undefined,		0,		/* fdbf */
	
	undefined,		0,		/* fdc0 */
	undefined,		0,		/* fdc1 */
	undefined,		0,		/* fdc2 */
	undefined,		0,		/* fdc3 */
	undefined,		0,		/* fdc4 */
	undefined,		0,		/* fdc5 */
	undefined,		0,		/* fdc6 */
	undefined,		0,		/* fdc7 */

	undefined,		0,		/* fdc8 */
	undefined,		0,		/* fdc9 */
	undefined,		0,		/* fdca */
	"fd cb	%02x,%02x",	2,		/* fdcb */
	undefined,		0,		/* fdcc */
	undefined,		0,		/* fdcd */
	undefined,		0,		/* fdce */
	undefined,		0,		/* fdcf */
	
	undefined,		0,		/* fdd0 */
	undefined,		0,		/* fdd1 */
	undefined,		0,		/* fdd2 */
	undefined,		0,		/* fdd3 */
	undefined,		0,		/* fdd4 */
	undefined,		0,		/* fdd5 */
	undefined,		0,		/* fdd6 */
	undefined,		0,		/* fdd7 */

	undefined,		0,		/* fdd8 */
	undefined,		0,		/* fdd9 */
	undefined,		0,		/* fdda */
	undefined,		0,		/* fddb */
	undefined,		0,		/* fddc */
	undefined,		0,		/* fddd */
	undefined,		0,		/* fdde */
	undefined,		0,		/* fddf */
	
	undefined,		0,		/* fde0 */
	"pop	iy",		0,		/* fde1 */
	undefined,		0,		/* fde2 */
	"ex	(sp),iy",	0,		/* fde3 */
	undefined,		0,		/* fde4 */
	"push	iy",		0,		/* fde5 */
	undefined,		0,		/* fde6 */
	undefined,		0,		/* fde7 */

	undefined,		0,		/* fde8 */
	"jp	(iy)",		0,		/* fde9 */
	undefined,		0,		/* fdea */
	undefined,		0,		/* fdeb */
	undefined,		0,		/* fdec */
	undefined,		0,		/* fded */
	undefined,		0,		/* fdee */
	undefined,		0,		/* fdef */
	
	undefined,		0,		/* fdf0 */
	undefined,		0,		/* fdf1 */
	undefined,		0,		/* fdf2 */
	undefined,		0,		/* fdf3 */
	undefined,		0,		/* fdf4 */
	undefined,		0,		/* fdf5 */
	undefined,		0,		/* fdf6 */
	undefined,		0,		/* fdf7 */

	undefined,		0,		/* fdf8 */
	"ld	sp,iy",		0,		/* fdf9 */
	undefined,		0,		/* fdfa */
	undefined,		0,		/* fdfb */
	undefined,		0,		/* fdfc */
	undefined,		0,		/* fdfd */
	undefined,		0,		/* fdfe */
	undefined,		0,		/* fdff */
};

int	curaddr = 0;

main ()
{
	int	i, j, arg1, arg2;
	struct opcode	*code;
	int	addr;

	for (;;) {
		addr = curaddr;
		i = gethex();
		if (!major[i].name) {
			j = major[i].args;
			i = gethex();
			while (!minor[j][i].name) {
				j = minor[j][i].args;
				i = gethex ();
			}
			code = &minor[j][i];
		} else
			code = &major[i];
		printf ("%04x\t", addr);
		switch (code->args) {
		case 2:
			printf (code->name, gethex(), gethex());
			break;
		case 1:
			printf (code->name, gethex());
			break;
		case 0:
			printf (code->name);
			break;
		} 
		putchar ('\n');
	}
}

int	inline;
int	index;

char	linebuf[1024];

int	hexbuf[1024];

gethex ()
{
	if (index == inline) {
	again:	;
		if (gets (linebuf) == 0)
			exit (0);
		if (strlen (linebuf) < 9)
			goto again;
		inline = fromhex (linebuf+1);
		for (index = 0; index < inline; index++)
			hexbuf[index] = fromhex (linebuf+9 + 2 * index);
		index = 0;
	}
	++curaddr;
	return hexbuf[index++];
}

#define hexval(c)	(('0' <= (c) && (c) <= '9') ? (c) - '0' :\
			(('a' <= (c) && (c) <= 'f') ? (c) - 'a' + 10 :\
			(('A' <= (c) && (c) <= 'F') ? (c) - 'A' + 10 :\
				-1 ))) 

fromhex (c)
char	*c;
{
	return hexval(c[0]) * 16 + hexval(c[1]);
}
SHAR_EOF
if test 37358 -ne "`wc -c < 'zdis.c'`"
then
	echo shar: error transmitting "'zdis.c'" '(should have been 37358 characters)'
fi
chmod +x 'zdis.c'
fi # end of overwriting check
echo shar: extracting "'serial.z'" '(19313 characters)'
if test -f 'serial.z'
then
	echo shar: will not over-write existing file "'serial.z'"
else
cat << \SHAR_EOF > 'serial.z'

; SCCS flags:		serial.z	1.8	9/21/82


;
; This program is a quick and dirty controller program
; for the simple Z80 serial interface card for the Red
; display controller.
;
; It uses two 256 byte buffers to buffer data to and from the
; host. This helps make up for the obnoxiously slow rs232.
;
; History:
; jrp	3-18-82	v1.0 Initial version by John Providenza.
;
; jrp	3-22-82	v1.1 Added code to send a Xon (Cntrlq) at reset
;		if the dip switch is set to Xon/Xoff mode.
;
; jrp	4-20-82	v1.2 Added SCCS flags as comment in header and
;		as a "ascii" block after a reset jmp.
;
; jrp	4-20-82	v1.3 Changed crt modem flags to RLSD = Out Buf Full,
;		RI = In Buf Full.
;
; jrp	4-21-82	v1.4 Added diagnostic code to test ram, switches, and
;		uart.
;
; jrp	4-30-82	v1.5 Cleaned up some code, added some more comments.
;
; jrp	5-27-82	v1.6 Fixed bug that caused output buffer to overflow
;		in Hex mode.
;
; jrp	6-22-82	v1.7 Added 'end of message' command in hex mode.
;		This is active only in hex mode and only if a
;		non 0 byte count is specified (0 is default)
;		'l' is used to specify byte count, 'm' specifies
;		the eom char. Both expect 2 hex digits following
;		to specify the apropriate parameter.
;
; jrp	8-23-82	v1.8 Added code to allow send/recv in different modes.
;		Thus the host can send in raw mode and receive in hex
;		mode, allowing CntrlS/Q flow control.
;		Also added 's' command in 'hex' mode to reset the SWTCH
;		settings.
;		Also added break detect to reset the mode/baud to the
;		switch settings.
;			switch	dIN	dOUT	Flow Control.
;			7 6 5
;			0 0 0	raw	raw	No flow control.
;			0 0 1	raw	hex	Xon/Xoff sent to host.
;			0 1 0	hex	raw	Xon/Xoff received from host.
;			0 1 1	hex	hex	Full Xon/Xoff.
;			1 0 0	raw	raw	Full modem flow control.
;			1 0 1	raw	hex	Full modem flow control.
;			1 1 0	hex	raw	Full modem flow control.
;			1 1 1	hex	hex	Full modem flow control.
;
; SCCS flags:	serial.z 1.8 9/21/82
	eject	1
; Serial port equates.
Serial	equ	00H	; base address of 8250 controller.
Ier	equ	01H	; Interrupt Enable Reg
Iir	equ	02H	; Interrupt Ident Reg
Lcr	equ	03H	; Line Control Reg
Mcr	equ	04H	; Modem Control Reg
Lsr	equ	05H	; Line Status Reg
Msr	equ	06H	; Modem Status Reg

; These equates define bits in the Msr.
DsrIn	equ	05	; Data Set Ready input
CtsIn	equ	04	; Clear to Send input
InMt	equ	06	; No data from display controller = 1 (Ring In)
OutMt	equ	07	; Crt ready for next byte = 1 (Rcvd Line Signal Detct)

; These equates define bits in the Lsr
DataRdy	equ	00	; Input data ready.
Break	equ	04	; Break condition.
XmitMt	equ	05	; Xmitter buffer empty.

; These equates define bits in the Mcr
DtrOut	equ	00	; Data terminal ready output.
RtsOut	equ	01	; Request to send output.

; Misc definitions.
Crt	equ	80H	; Parallel port to display controller.
Baud	equ	40H	; Switches port.
Stack	equ	0FFFFH

; Mailbox equates.
Head	equ	0
Tail	equ	1
Count	equ	2
Base	equ	3
Status	equ	4
UnChar	equ	5	; Should be used only for CntrlS and CntrlQ

; Equates for the Queue status byte
XmitOff	equ	00		; xmitter is disabled.

; Baud/Switch equates.
Bmask	equ	0FH
Rawout	equ	020H
RObit	equ	5
Rawin	equ	040H
RIbit	equ	6
Xon	equ	080H
Xonbit	equ	7

; Some ASCII character equates.
CntrlS	equ	19		; Xoff
CntrlQ	equ	17		; Xon
Cr	equ	13		; Carriage return.
	eject	1
	ORG	0FC00H
RAM_START:
; Variable declarations
; Ram is in the top 1K of memory.

; Queues.
; These are the actual data buffers. The only routine that should use
; these labels re INIT_V to set the mailbox data pointers up.
; All I/O is via GETQ and PUTQ routines.
INBUF:	block	256		; input buffer q.
OUTBUF:	block	256		; output buffer q.

UNUSED:	block	256		; unused ram

; Now the ram for variables and stack.

SWTCH:	block	1		; Current baud/switches

; Variable for the H_to_Q routine
; It holds the upper nibble of hex until the lower one arrives.
; Bit 0 = 1 for empty, 0 for upper nibble full.
H_to_QV:	block	1

; End of message variables.
MESS_LEN:	block	1	; How long messages are.
MESS_CNT:	block	1	; Number of chars in current message.
EOM_CHAR:	block	1	; The end of message char.


; In and Out queues variables.
INBOX:	block	6
OUTBOX:	block	6
	eject	1
; Mainline loop.
	ORG	0
	JP	RESET		; Jmp to the code
				; Put in ID string
	ascii	'serial.z 1.8'
RESET:
	LD	SP, Stack
	CALL	CHECK		; Check the hardware out.
	CALL	INIT_HW		; Init the hardware devices.
	CALL	INIT_V		; Init the variables.

	LD	IX,OUTBOX	; Point to the outbox.
	LD	A,(SWTCH)	; Check if we're in Xon/Xoff mode.
	AND	Xon
	LD	A,Cntrlq	; Send a Xon to host if we're in that mode
	CALL	NZ,PUTQ

; Now loop checking for data available from host or display controller.
; Also check if we can send data to them.
LOOP:
	IN	A,(Lsr)		; Get the line status.
	LD	C,A
	IN	A,(Msr)		; Get the modem status.
	LD	B,A		; and save it
				; B = Msr, C = Lsr.
; Check for break condition.
	BIT	Break,C		; test the bit in the Lsr
	JR	Z,LOOP1
	CALL	SETBAUD		; reset the SWTCH variable.
	CALL	INIT_V		; reset all the variables
	JR	LOOP
LOOP1:
	CALL	HOST_IN
	CALL	DISP_IN
	CALL	DISP_OUT
	CALL	HOST_OUT
	JR	LOOP
	eject	1
; Check if data is ready from host.
HOST_IN:
	BIT	DataRdy,C	; Data ready?
	RET	Z		; Ret if no.
				; Handle a byte from the Host.
	LD	IX,INBOX	; data will go into the Input Q.
	LD	A,(SWTCH)	; check for Raw or encoded mode.
	LD	H,A
	AND	Rawin		; NZ for Raw mode
	IN	A,(Serial)	; get the data byte.
	JR	Z,HEX_IN	; Jmp if hex data in.
RAW_IN:				; Process Raw data
	CALL	PUTQ
	JP	STOP_IN		; stop the input if needed.
HEX_IN:
	AND	7FH		; Kill any parity bit.
	CP	' '		; Printable ASCII?
	JR	NC,PRINT	; Jmp if yes
; Control character.
	CP	Cr		; Carriage Ret?
	JR	NZ,IN_FLOW	; Jp if no.
	LD	A,1		; Set the H_to_Q variable to empty.
	LD	(H_to_QV),A	; This flushes any partially assembled byte.
	RET			; Done
; Test for Xon/Xoff commands.
IN_FLOW:
	BIT	Xonbit,H	; Are we sensitive to them?
	RET	Z		; Ret if no.
	LD	HL,OUTBOX+Status	; Get a pointer to our outbox status.
	CP	CntrlS		; Xoff our transmitter?
	JR	NZ,NOT_XOFF	; Jmp if no.
OFF:
	SET	XmitOff,(HL)
	RET
NOT_XOFF:
	CP	CntrlQ		; Xon our xmitter?
	RET	NZ		; ret if no.
ON:
	RES	XmitOff,(HL)
	RET
; Printable char received from host.
PRINT:				; Printable character received in hex mode.
	SET	5,A		; Convert to lower case.
	CP	'l'		; Message length command?
	JR	NZ,PRINT1	; Jmp if no.
	CALL	GET_HEX		; Get byte from UART
	LD	(MESS_LEN),A	; Set the message length.
	LD	(MESS_CNT),A	; Reset the number of chars sent so far.
	RET
PRINT1:
	CP	'm'		; EOM char set command?
	JR	NZ,PRINT2
	CALL	GET_HEX		; Get byte from UART
	LD	(EOM_CHAR),A
	RET
PRINT2:
	CP	's'		; change SWTCH command?
	JR	NZ,PRINT3
	CALL	GET_HEX		; Get byte from UART
	CPL			; Toggle them.
	LD	(SWTCH),A
	RET
PRINT3:
	CALL	H_to_Q		; Pack the encoded data into bytes.
	JP	STOP_IN		; stop the input if needed.
	eject	1
; Data ready from controller?
DISP_IN:
	BIT	InMt,B		; data from controller?
	RET	NZ		; ret if no.
	LD	IX,OUTBOX
	LD	A,(IX+Count)	; Get the Q count.
	ADD	A,3		; Check if Q has room for 3 more bytes.
	RET	C		; ret if no
	LD	A,(SWTCH)	; check if we need to encode the data.
	AND	Rawout
	IN	A,(Crt)		; get the data from the crt.
	JP	NZ,PUTQ		; send the raw data and return.
; hex data out to host.
	CALL	B_to_H		; convert byte to hex format and stick in Q.
				; Check if we need to stick an EOM char in.
	LD	A,(MESS_LEN)	; Get the length.
	AND	A
	RET	Z		; Zero means no EOM character to be sent.
	LD	HL,MESS_CNT	; Point to the counter.
	DEC	(HL)		; Time to send a EOM char?
	RET	NZ		; Ret if no.
	LD	(HL),A		; reset the length.
	LD	A,(EOM_CHAR)	; Get the char and stick it in the Q.
	JP	PUTQ		; and return when done
	eject	1
; Controller ready for data?
DISP_OUT:
	BIT	OutMt,B		; controller ready for data?
	RET	Z		; Jmp if no
	LD	IX,INBOX
	CALL	GETQ		; get a byte for controller.
	RET	C		; ret if no byte available.
	OUT	(Crt),A		; send char to display.
	JP	STRT_IN		; re-enable host xmitter if needed.
	eject	1
; Host ready for data?
HOST_OUT:
	BIT	XmitMt,C	; Uart xmitter empty?
	RET	Z		; ret if no.
	LD	IX,OUTBOX	; Get OutBox pointer.
	LD	A,(SWTCH)	; Check for Xon mode
	AND	Xon
	JR	NZ,H_O_Xon	; Jp if Xon mode.
	BIT	CtsIn,B		; Clear to send?
	RET	Z		; ret if no.
	JR	H_O_Send	; We are clear to send.
H_O_Xon:
	LD	A,(OUTBOX+UnChar)
	AND	A
	JR	NZ,H_O_Send	; Always send an 'UnChar'
	BIT	XmitOff,(IX+Status)
	RET	NZ		; ret if xmitter is disabled.
H_O_Send:
	CALL	GETQ
	RET	C		; Ret if no character available.
	OUT	(Serial),A
	RET
	eject	1
; Check the hardware out.
; Call this routine only after a external reset!!!!

CHECK:
; Check the baud switch (really crude).
	IN	A,(BAUD)	; Get the baud switch.
	LD	B,A		; Save it.
	IN	A,(BAUD)
	CP	B		; Same as last time?
BAD_B:	; Switch ERROR - Can't read switches twice in a row.
	JR	NZ,BAD_B	; Loop if no.
; Check the ram.
; Write the complement of the low byte of address out to all ram,
; then check if it stayed the same.
; Note that this destroys all ram contents.
	POP	DE		; Save the return address in a register.
	LD	HL,RAM_START	; Get the first address of ram.
	LD	B, NOT [RAM_START & 0FFH]
	LD	C,B		; Get complement of low address byte.
				; Load the ram with the pattern.
RAM1:
	LD	(HL),B
	DEC	B
	INC	HL
	LD	A,H		; Test for done.
	OR	L
	JR	NZ,RAM1		; Loop till all locations written.
	LD	HL,RAM_START	; Get the first address of ram.
; Check if ram agrees with what should be there.
RAM2:
	LD	A,(HL)		; Get the byte.
	XOR	C		; Same as its low address byte?
	JR	Z,RAM6		; Jmp if yes.
; Ram error. We have three loops: low bad, high bad, both bad.
	LD	B,A		; Save the symptom.
	AND	0FH		; Low nibble bad?
RAM3:	; Ram ERROR - bad high nibble.
	JR	Z,RAM3		; Jmp if no.
	LD	A,B		; get the symptom back.
	AND	0F0H		; High nibble bad too?
RAM4:	; Ram ERROR - bad low nibble.
	JR	Z,RAM4		; Loop if error.
RAM5:	; Ram ERROR - both nibbles bad.
	JR	RAM5
RAM6:
	DEC	C
	INC	HL
	LD	A,H		; Done?
	OR	L
	JR	NZ,RAM2		; Jmp if no.
	PUSH	DE		; Fix the stack back up.
; Check out the National Semi INS8250 Uart.
; Since we were reset, Lcr should be zero.
	IN	A,(Lcr)		; Get the Line Control reg
	AND	A
U0:	; Uart ERROR - Lcr not reset properly.
	JR	NZ,U0		; Loop if error.
	LD	A,80H
	OUT	(Lcr),A		; And set the Divisor access bit.
	IN	A,(Lcr)		; Check that it got set.
	CP	80H		; Still set?
U1:	; Uart ERROR - Lcr won't hold divisor access bit.
	JR	NZ,U1		; Loop if error.
	LD	A,3		; Try to set 38.4K baud
	OUT	(Serial),A	; Ld the divisor.
	IN	A,(Serial)	; Test that it loaded OK.
	SUB	3		; Check if same (also set A to zero)
U2:	; Uart ERROR - unexpected low divisor.
	JR	NZ,U2		; Loop if error.
	OUT	(Ier),A		; Set high byte to zero
	IN	A,(Ier)
	AND	A		; Still zero?
U3:	; Uart ERROR - unexpected high divisor.
	JR	NZ,U3		; Loop if no (ie, error).
	IN	A,(Lcr)		; Get the Line reg back.
	SUB	80H		; Is it the same as before?
U4:	; Uart ERROR - unexpected Lcr value after setting divisor.
	JR	NZ,U4		; loop if error.
	OUT	(Lcr),A		; Turn off divisor access bit.
	IN	A,(Lcr)		; Check it.
	AND	A
U5:	; Uart ERROR - Lcr won't reset after setting divisor.
	JR	NZ,U5
	LD	A,7
	OUT	(Lcr),A		; 8 bits, no parity, 2 stop bits
	IN	A,(Lcr)
	SUB	7		; Test if the same (also set A to zero)
U6:	; Uart ERROR - Can't set proper operating Lcr.
	JR	NZ,U6		; If we succeed, assume Lcr is Ok.
	OUT	(Ier),A		; Disable all 8250 interrupt conditions (set to 0).
	IN	A,(Ier)
	AND	A
U7:	; Uart ERROR - Can't reset Ier.
	JR	NZ,U7
	RET
	eject	1
; Init the hardware.
INIT_HW:
	CALL	SETBAUD		; Set the Uart baud
	LD	A,7
	OUT	(Lcr),A		; 8 bits, no parity, 2 stop bits
	XOR	A		; Disable all 8250 interrupt conditions.
	OUT	(Ier),A
	LD	A,3		; Dtr, Rts on.
	OUT	(Mcr),A

; Perform the I/O diagnostic with the controller.
; Wait for data from controller, then echo it back.
INITH1:
	IN	A,(Msr)		; Check if controller data ready.
	BIT	InMt,A		; Ready?
	JR	NZ,INITH1	; Jmp if no.
	IN	A,(Crt)		; Get the data.
	OUT	(Crt),A		; And send it back to controller.
	RET


; Init the variables.
INIT_V:
	XOR	A		; zero A

; Init the Q's
	LD	IX,INBOX	; Init the inbox.
	LD	(IX + Head),A
	LD	(IX + Tail),A
	LD	(IX + Count),A
	LD	HL,INBUF
	LD	(IX + Base),H
	LD	(IX + Status),A
	LD	(IX + UnChar),A

	LD	IX,OUTBOX	; Init the outbox.
	LD	(IX + Head),A
	LD	(IX + Tail),A
	LD	(IX + Count),A
	LD	HL,OUTBUF
	LD	(IX + Base),H
	LD	(IX + Status),A
	LD	(IX + UnChar),A

; Init the H_to_Q variable.
	LD	A,1
	LD	(H_to_QV),A

; init the 'end of message' stuff
	LD	A,Cr		; default r is a carriage return.
	LD	(EOM_CHAR),A
	XOR	A
	LD	(MESS_LEN),A
	LD	(MESS_CNT),A
	RET
	eject	1
; These routines handle the input and output queues.
; The Q pointer is passed in IX, result/source in A.
; Queues must be 256 bytes long. We use only 8 bit
; arithmetic for Q manipulation.
; A Q is defined as 6 bytes of status:
;	Tail	Offset for getting next char
;	Head	Offset for putting next char
;	Count	Number of chars in q
;	Base	High byte of the q origin
;	Status	Status of Q
;	UnChar	The 'un_get' char if non-zero
; and 256 bytes of storage.
;

GETQ:
; Get an element from the Q.
; entry	ix = Q pointer
; exit	a  = result
;	ca = set for empty Q, cleared for full Q.
;	bc & de are unchanged.
;	hl = garbage
;
	LD	A,(IX + UnChar) ; Get the unget char
	LD	(IX + UnChar),0	; Set the byte to 0 (empty).
	AND	A
	RET	NZ		; Ret if we got an unget char.
				; A == 0 here.
	CP	(IX + Count)	; Get the q count
	SCF
	RET	Z		; empty Q return (Count == 0).
	DEC	(IX + Count)	; one less item in the Q.
	LD	L,(IX + Tail)	; get a pointer to the element in the Q.
	LD	H,(IX + Base)
	INC	(IX + Tail)	; bump the pointer to the next char.
	OR	(HL)		; Get the element, and clear the carry.
	RET


PUTQ:
; Routine to put a char in a Q.
;entry	ix = pointer to Q structure.
;	a = char to put.
;exit	hl = garbage
;	a, bc & de unchanged.
;	Ca = 1 for Q full, character discarded.
;
	INC	(IX + Count)	; Bump the Q count.
QPUT_ERR:
	JR	Z,QPUT_ERR
QPUT1:
	LD	H,(IX + Base)
	LD	L,(IX + Head)
	LD	(HL),A		; Put the char in the Q
	INC	(IX + Head)
	AND	A		; Clear the carry bit
	RET
	eject	1
; These routines pack and unpack bytes into Hex
; suitable for sending as ASCII over a serial line.
; H_to_Q takes Hex characters
; and packs them into 8 bit bytes to send to the display.
; B_to_H takes bytes from the display and converts them into
; the Hex character stream.
;
; Both routines use Q calls. IX must be set up with the proper
; Q address.
;
;



H_to_Q:
;
; entry	A	= Ascii Hex char (0-9, a-f)
;	IX	= Q pointer
; exit	A, Hl	= Garbage
;	bc, de	= unchanged.
;	Ca	= 1 if Q too full.
;
	CALL	H_to_B		; convert the character to binary.
	LD	HL,H_to_QV	; Point hl to our variable
	BIT	0,(HL)		; check if the upper nibble is full.
	JR	Z,H_SEND	; Jmp if yes.
	ADD	A,A		; Move the nibble to the high 4 bits.
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	(HL),A		; Save away the high nibble with low nibble = 0.
	RET
H_SEND:
	OR	(HL)		; Merge in the upper nibble from ram.
	LD	(HL),1		; Set the variable to empty.
	JP	PUTQ		; Send the byte and return.
	eject	1



B_to_H:
; B_to_H takes the byte in A and splits it into two hex characters
; to be sent to the Q specified in IX.
;
; Entry	A	= byte of data to convert to Hex.
;	IX	= Q address.
; Exit	A E Hl	= garbage
;	D Bc Ix	= unchanged.
;

	LD	E,A		; Save the byte
	RRA			; Move the upper nibble to low nibble.
	RRA
	RRA
	RRA
	AND	0Fh		; Get only the upper nibble.
	CP	10		; 0 thru 9?
	JR	C,B_to_H1	; Jmp if yes.
	ADD	A,'A'-'0'-10
B_to_H1:
	ADD	A,'0'
	CALL	PUTQ
	LD	A,E		; Get the byte back
	AND	0Fh		; Mask for only low nibble.
	CP	10		; 0 thru 9?
	JR	C,B_to_H2	; Jmp if yes.
	ADD	A,'A'-'0'-10
B_to_H2:
	ADD	A,'0'
	JP	PUTQ		; Send and return.
	eject	1
GET_HEX:
; This routine gets two hex characters from the UART and
; munches them into a byte in A.
; Entry:	No Params.
; Exit: 	A=byte	H = trash
;		all others unchanged (except for flags)
	IN	A,(Lsr)		; Get the line status
	BIT	DataRdy,A	; Data ready from host?
	JR	Z,GET_HEX	; Jmp if no.
	IN	A,(Serial)	; get the data.
	CALL	H_to_B		; convert to binary.
	ADD	A,A		; Shift up 4 bits
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	H,A		; Save in B
GET_HX1:
	IN	A,(Lsr)		; Get the line status
	BIT	DataRdy,A	; Data ready from host?
	JR	Z,GET_HX1	; Jmp if no.
	IN	A,(Serial)	; get the data.
	CALL	H_to_B		; convert to binary.
	OR	H
	RET			; A = 2 input chars munched together.

; Convert hex char to binary.
H_to_B:
	SET	5,A		; convert to lower case.
	SUB	'0'		; less than 0?
	JR	C,HB_ERR	; Jmp if out of bounds.
	CP	10		; bigger than 9?
	RET	C		; Ret if no (0..9)
	SUB	'a'-'0'-10	; try to make it range 10-15
	CP	10
	JR	C,HB_ERR	; Jmp if out of bounds.
	CP	16
	RET	C		; Ret if hex.
HB_ERR:
	XOR	A		; Set to zero.
	RET

	eject	1
SETBAUD:
; This routine reads the BAUD switches and looks the code
; up in the BTABLE to set the baudrate of the 8250 serial chip.
;
; Entry	No parameters
; exit	A Hl De	= garbage.
	IN	A,(Lcr)	; Set the divisor access bit on
	OR	80H
	OUT	(Lcr),A
	IN	A,(Baud)	; Get the baud rate code
	LD	(SWTCH),A
	AND	Bmask		; Get only the baud specifier bits.
	ADD	A,A		; Double it to index into table.
	LD	HL,BTABLE	; Index into table to get the divisor
	LD	E,A
	LD	D,0
	ADD	HL,DE
	LD	A,(HL)		; Get the low order divisor byte
	OUT	(Serial),A
	INC	HL
	LD	A,(HL)		; Get the high divisor byte
	OUT	(Serial+1),A
	IN	A,(Lcr)	; Set the divisor access bit off
	AND	7FH
	OUT	(Lcr),A
	RET

; Baud rate look up table
; Only allow 16 entries.
BTABLE:
	WORD	5	; 38.4 Kbaud
	WORD	10	; 19.2
	WORD	20	; 9600
	WORD	27	; 7200
	WORD	40	; 4800
	WORD	53	; 3600
	WORD	80	; 2400
	WORD	107	; 1800
	WORD	160	; 1200
	WORD	320	; 600
	WORD	640	; 300
	WORD	1280	; 150
	WORD	1428	; 134.5
	WORD	1745	; 110
	WORD	2560	; 75
	WORD	3840	; 50
	eject	1
; STRT_IN and STOP_IN are called when the Input Q is may be too full/empty.
; They check and enable/disable the host xmitter apropriately.
;

STRT_IN:
; Entry	No registers set.
; Exit	A Ix Hl	= garbage.
;	Bc De	= unchanged.
;
	LD	IX,INBOX	; Point to the Q.
	BIT	XmitOff,(IX + Status)	; Is it off?
	RET	Z		; ret if no.
	LD	A,40		; Check if we've gone below low water mark.
	CP	(IX + Count)
	RET	C		; Ret if no, Q still too full.
	LD	A,(SWTCH)	; get the switch settings.
	BIT	Xonbit,A
	JR	Z,STRT_DTR	; Jmp if rs232 modem mode flow control.
; Try to use Xon/Xoff control flow methods.
	BIT	RObit,A		; Raw Output mode?
	RET	NZ		; No way to start/stop host xmitter.
	LD	HL,OUTBOX+UnChar
	LD	A,(HL)		; Anything in unget spot?
	AND	A
	RET	NZ		; Ret if yes.
	LD	(HL),CntrlQ	; 'unget' a control Q.
	JR	STRT_END
; Set DTR bit on.
STRT_DTR:
	IN	A,(Mcr)		; get the modem controls.
	SET	DtrOut,A
	OUT	(Mcr),A
STRT_END:
	RES	XmitOff,(IX + Status)	; Mark as enabled.
	RET


STOP_IN:
; Entry	No registers set.
; Exit	A Ix Hl	= garbage.
;	Bc De	= unchanged.
;
	LD	IX,INBOX	; Point to the Q.
	BIT	XmitOff,(IX + Status)	; Already disabled?
	RET	NZ		; ret if yes.
	LD	A,256-40	; Check if we've gone above high water mark.
	CP	(IX + Count)
	RET	NC		; Ret if no, Q still too empty.
	LD	A,(SWTCH)
	BIT	Xonbit,A	; test for Xon/Xoff vs. modem flow cntrl.
	JR	Z,STP_DTR	; jmp if rs232 modem mode
; try to send an Xoff to the host.
	BIT	RObit,A		; Are we in raw out?
	RET	NZ		; Can't control the host xmitter.
	LD	HL,OUTBOX+UnChar
	LD	A,(HL)		; Anything in unget spot?
	AND	A
	RET	NZ		; Ret if yes.
	LD	(HL),CntrlS	; 'unget' a control S.
	JR	STP_END
; Modem mode flow control, set DTR bit off.
STP_DTR:
	IN	A,(Mcr)		; get the modem controls.
	RES	DtrOut,A
	OUT	(Mcr),A
STP_END:
	SET	XmitOff,(IX + Status)	; Mark as disabled.
	RET

	END
SHAR_EOF
if test 19313 -ne "`wc -c < 'serial.z'`"
then
	echo shar: error transmitting "'serial.z'" '(should have been 19313 characters)'
fi
chmod +x 'serial.z'
fi # end of overwriting check
echo shar: extracting "'serial.hex'" '(2168 characters)'
if test -f 'serial.hex'
then
	echo shar: will not over-write existing file "'serial.hex'"
else
cat << \SHAR_EOF > 'serial.hex'
:10000000C30F0073657269616C2E7A20312E38310E
:10001000FFFFCD1001CD7F01CD9801DD210BFF3A0F
:1000200000FFE6803E11C4F901DB054FDB0647CB3C
:10003000612808CD7102CD980118EECD4900CDB0F0
:1000400000CDDB00CDEB0018E0CB41C8DD2105FF82
:100050003A00FF67E640DB002806CDF901C3E20263
:10006000E67FFE20301DFE0D20063E013201FFC955
:10007000CB7CC8210FFFFE132003CBC6C9FE11C0E5
:10008000CB86C9CBEFFE6C200ACD40023202FF3294
:1000900003FFC9FE6D2007CD40023204FFC9FE7385
:1000A0002008CD40022F3200FFC9CD0A02C3E20270
:1000B000CB70C0DD210BFFDD7E02C603D83A00FF06
:1000C000E620DB80C2F901CD20023A02FFA7C82159
:1000D00003FF35C0773A04FFC3F901CB78C8DD21AF
:1000E00005FFCDDD01D8D380C3B402CB69C8DD21C3
:1000F0000BFF3A00FFE6802005CB60C8180B3A10D2
:10010000FFA72005DDCB0446C0CDDD01D8D300C953
:10011000DB4047DB40B820FED12100FC06FF4870E1
:1001200005237CB520F92100FC7EA9280C47E60FA9
:1001300028FE78E6F028FE18FE0D237CB520EAD5CF
:10014000DB03A720FE3E80D303DB03FE8020FE3EC0
:1001500003D300DB00D60320FED301DB01A720FE82
:10016000DB03D68020FED303DB03A720FE3E07D3AC
:1001700003DB03D60720FED301DB01A720FEC9CD98
:1001800071023E07D303AFD3013E03D304DB06CB9A
:100190007720FADB80D380C9AFDD2105FFDD770052
:1001A000DD7701DD77022100FCDD7403DD7704DDFE
:1001B0007705DD210BFFDD7700DD7701DD7702219B
:1001C00000FDDD7403DD7704DD77053E013201FFBC
:1001D0003E0D3204FFAF3202FF3203FFC9DD7E0560
:1001E000DD360500A7C0DDBE0237C8DD3502DD6E95
:1001F00001DD6603DD3401B6C9DD340228FEDD66AB
:1002000003DD6E0077DD3400A7C9CD5D022101FF5B
:10021000CB4628068787878777C9B63601C3F90199
:100220005F1F1F1F1FE60FFE0A3802C607C630CD2C
:10023000F9017BE60FFE0A3802C607C630C3F90192
:10024000DB05CB4728FADB00CD5D02878787876710
:10025000DB05CB4728FADB00CD5D02B4C9CBEFD676
:1002600030380CFE0AD8D627FE0A3803FE10D8AF65
:10027000C9DB03F680D303DB403200FFE60F8721A2
:1002800094025F1600197ED300237ED301DB03E6C0
:100290007FD303C905000A0014001B0028003500A5
:1002A00050006B00A0004001800200059405D106BB
:1002B000000A000FDD2105FFDDCB0446C83E28DD26
:1002C000BE02D83A00FFCB7F280DCB6FC02110FFB4
:1002D0007EA7C036111806DB04CBC7D304DDCB04E0
:1002E00086C9DD2105FFDDCB0446C03ED8DDBE0258
:1002F000D03A00FFCB7F280DCB6FC02110FF7EA727
:10030000C036131806DB04CB87D304DDCB04C6C983
:0000000000
SHAR_EOF
if test 2168 -ne "`wc -c < 'serial.hex'`"
then
	echo shar: error transmitting "'serial.hex'" '(should have been 2168 characters)'
fi
chmod +x 'serial.hex'
fi # end of overwriting check
#	End of shell archive
exit 0

