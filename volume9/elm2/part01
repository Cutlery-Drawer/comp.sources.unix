Subject:  v09i001:  ELM Mail System, Part01/19
Newsgroups: mod.sources
Approved: rs@mirror.TMC.COM

Submitted by: Dave Taylor <hplabs!taylor>
Mod.sources: Volume 9, Issue 1
Archive-name: elm2/Part01

[  Dave tells me this is probably the final release of ELM; I hope
   not -- what will I use to start off Volume 10? :-)  --r$  ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If this archive is complete, you will see the message:
#		"End of archive 1 (of 19)."
# Contents:  bin doc doc/Elm.coversheet doc/answer.1 doc/autoreply.1
#   doc/checkalias.1 doc/elm-help.0 doc/elm-help.1 doc/elm-help.2
#   doc/elmrc.sample doc/filter.1 doc/from.1 doc/listalias.1
#   doc/messages.1 doc/newalias.1 doc/newmail.1 doc/printmail.1
#   doc/trim-headers.1 doc/wnewmail.1 filter filter/Makefile
#   filter/Makefile.mstr hdrs hdrs/curses.h hdrs/save_opts.h src
#   src/delete.c src/getopt.c src/output_utils.c src/pmalloc.c
#   src/quit.c src/remail.c src/signals.c src/string2.c
#   src/validname.c test test/test.empty utils utils/listalias.c
#   utils/mailrc.awk utils/trim-headers
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d bin ; then
    echo shar: Creating directory \"bin\"
    mkdir bin
fi
if test ! -d doc ; then
    echo shar: Creating directory \"doc\"
    mkdir doc
fi
echo shar: Extracting \"doc/Elm.coversheet\" \(526 characters\)
if test -f doc/Elm.coversheet ; then 
  echo shar: Will not over-write existing file \"doc/Elm.coversheet\"
else
sed "s/^X//" >doc/Elm.coversheet <<'END_OF_doc/Elm.coversheet'
X.PH ""
X\"
X\"  Cover sheet for the ELM mail system...
X\"  format with 'troff -mm Elm.coversheet > Coversheet.fmtd'
X\"  or something similar.
X\"  (C) Copyright 1986 Dave Taylor
X\"
X.PF ""
X.ds HF 3  3 
X.ds HP 12 12
X.SA 1
X.nr Hy 1
X.nr Pt 1
X.nr Pi 8
X.lg 1
X.HM 1 1
X.rs
X.sp 11
X.ce 99
X.ps 25
X\fBThe \s26Elm\s25 Mail System\fR
X.sp 2
X.ps 14
X\fIA Replacement Mailer for All Unix Systems\fR
X.sp 8
XDave Taylor
X.sp 2
XHewlett-Packard Laboratories
X1501 Page Mill Road
XPalo Alto CA
X94304
X.sp 2
Xemail: taylor\s12@\s14hplabs \ or \ hplabs!taylor
END_OF_doc/Elm.coversheet
if test 526 -ne `wc -c <doc/Elm.coversheet`; then
    echo shar: \"doc/Elm.coversheet\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/answer.1\" \(1814 characters\)
if test -f doc/answer.1 ; then 
  echo shar: Will not over-write existing file \"doc/answer.1\"
else
sed "s/^X//" >doc/answer.1 <<'END_OF_doc/answer.1'
X.TH ANSWER 1L 
X.ad b
X.SH NAME
Xanswer - phone message transcription system
X.SH SYNOPSIS
X.B answer
X.PP
X.SH HP-UX COMPATIBILITY
X.TP 10
XLevel:
XHP-UX/CONTRIBUTED
X.TP
XOrigin:
XHewlett-Packard
X.SH DESCRIPTION
X.I Answer\^
Xis a part of the 
X.B Elm
Xmail system and is designed for secretaries and the like
Xto allow them to answer phones and|or listen to phone message
Xmachines and quickly and easily transcribe the messages into
Xelectronic mail.
X.P
XThe program uses it's own alias set (usually a subset of the
Xsystem aliases, with more fields per user (ie unique first
Xnames, unique last names, first-initial lastname, and so on)).
XNote this means that you must create and then install, using
X.I newalias,
Xa separate alias table for the account this program is to 
Xbe run from.
X.P
XInterface-wise, the program is a breeze to use - type 'answer'
Xto start it up and then merely type a user name at the
X.nf
X	
X	Message to:
X
X.fi
Xprompt, and then enter the message, ending with a blank line.
XNames can be entered as 'Firstname Lastname' and the system
Xwill try to find a mail alias based on the first letter of the
Xfirst name plus the last name.  For example, 'Dave Taylor'
Xwill cause the program to search for an alias 'd_taylor' in
Xthe file (note the transliteration into lower case).   The 
Xprogram will loop until killed or quit.
X.P
X.I Answer
Xcan be easily exited by typing any of 'quit', 'exit' 'done', 
Xor 'bye' at the 'Message to:' prompt.
X.SH AUTHOR
XDave Taylor, Hewlett-Packard Laboratories
X.SH SEE ALSO
X.I "Elm Alias Users Guide", 
Xby Dave Taylor
X.sp
X.br
Xnewalias(1L), checkalias(1L), mail(1), mailx(1), from(1L), printmail(1L)
X.SH FILES
X$home/.alias_hash             individual alias hash table
X.br
X$home/.alias_data             individual alias data table
X.br
X/tmp/snd*                     edit buffer for outgoing mail
END_OF_doc/answer.1
if test 1814 -ne `wc -c <doc/answer.1`; then
    echo shar: \"doc/answer.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/autoreply.1\" \(1836 characters\)
if test -f doc/autoreply.1 ; then 
  echo shar: Will not over-write existing file \"doc/autoreply.1\"
else
sed "s/^X//" >doc/autoreply.1 <<'END_OF_doc/autoreply.1'
X.TH AUTOREPLY 1L 
X.ad b
X.SH NAME
Xautoreply - Automatic mail reply system
X.SH SYNOPSIS
X.B autoreply
X.br
X.B "autoreply off"
X.br
X.B autoreply
X<
X.B filename
X>
X.PP
X.SH HP-UX COMPATIBILITY
X.TP 10
XSystems:
XAT&T System V and Berkeley BSD
X.TP
XOrigin:
XHewlett-Packard
X.SH DESCRIPTION
X.I Autoreply\^
Xis a part of the 
X.B Elm
Xmail system and is designed to enable users to easily set up
Xan automatic response to all mail they receive.  This is
Xtypically during a vacation or some other period of time that
Xthe user is not available to reply to mail (although some
Xpeople get enough mail that they have it permanently running
Xto simply send an "ack" to each message)
X.PP
XThe system is quite easy to use...
XYou can type "autoreply" and be informed of your current
Xstatus in the system (on or off), or "autoreply off" will
Xturn your autoreplying off.
X.PP
XTo add yourself to the system, you need merely to compose a
Xform response in a file somewhere, then type "autoreply <file>"
Xwhere <file> is the name of the file.
X.SH "SPECIAL NOTE"
XFor this to function correctly, the program "arepdaemon" must
Xbe running as a daemon in background.  This program automatically
Xchecks all the currently enrolled users for new mail in their
Xmailboxes...
X.SH AUTHOR
XDave Taylor, Hewlett-Packard Laboratories.
X.SH SEE ALSO
X.I "Elm Users Guide", 
Xby Dave Taylor
X.sp
X.br
Xmail(1), mailx(1), elm(1L)
X.SH "BUGS"
XUnfortunately, this program isn't too brilliant about identifying
Xmail that shouldn't be responded to (like mail from other
Xdaemons, or your mother) but that's a more general problem anyway.
X.sp
XAlso, occasionally a user will remove themselves from the
Xautoreply system and the system won't turn their autoreply
Xoff.  This is a problem that hasn't been solved yet (obviously
Xsince it's in the "bugs" section!!) and any further information
Xwould be appreciated!
END_OF_doc/autoreply.1
if test 1836 -ne `wc -c <doc/autoreply.1`; then
    echo shar: \"doc/autoreply.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/checkalias.1\" \(941 characters\)
if test -f doc/checkalias.1 ; then 
  echo shar: Will not over-write existing file \"doc/checkalias.1\"
else
sed "s/^X//" >doc/checkalias.1 <<'END_OF_doc/checkalias.1'
X.TH CHECKALIAS 1L
X.ad b
X.SH NAME
Xcheckalias - check to see if an alias is defined.
X.SH SYNOPSIS
X.B checkalias
Xalias, alias, ...
X.SH HP-UX COMPATIBILITY
X.TP 10
XLevel:
XHP-UX/CONTRIBUTED
X.TP
XOrigin:
XHewlett-Packard
X.SH DESCRIPTION
X.I Checkalias
Xchecks the user file first, and then the system alias file
Xto try to find the specified alias or aliases.  If found, 
Xthe value of the alias is printed out, otherwise an error
Xis generated.
X.P
XNote: this is in fact a one-line shell script;
X.nf
X
X	elm -c $*
X
X.fi
X.SH AUTHOR
XDave Taylor, Hewlett-Packard Laboratories
X.SH SEE\ ALSO
Xnewalias(1L), elm(1L), mail(1), mailx(1)
X.SH BUGS
XNote that the precedence of aliases is user file then system
Xfile.  This means that a user can 'overload' an alias by having
Xone defined in the system file also defined in theirs.  This
Xshouldn't turn out to be a problem, but is something for
Xthe system administrator to keep in mind when creating the
Xsystem alias file.
END_OF_doc/checkalias.1
if test 941 -ne `wc -c <doc/checkalias.1`; then
    echo shar: \"doc/checkalias.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/elm-help.0\" \(1802 characters\)
if test -f doc/elm-help.0 ; then 
  echo shar: Will not over-write existing file \"doc/elm-help.0\"
else
sed "s/^X//" >doc/elm-help.0 <<'END_OF_doc/elm-help.0'
X
X        Command                 	Action
X
X	   | 		Pipe current message to ...
X	   !		Shell escape
X	   $		Resynchronize mailbox (force it)
X           ?            This screen of information
X           +, <SPACE>   Next page of headers
X           -            Previous page of headers
X           =            Set current message to 1
X	   *		Set current message to last message
X           <n>          Set current message to n
X	   /		Search from/subjects for pattern
X	   //		Search entire message bodies for pattern
X	   >		Save current message or tagged to file
X	   <		Scan current message for calendar entries
X
X           a            Alias, change to 'alias' mode 
X	   b		Bounce (remail) current message
X           c            Change current mail file
X           d            Delete current message
X	  ^D		Delete messages with specified patter
X	   e		Edit the current mailbox
X           f            Forward message to specified user
X	   g            Group (all recipients) reply to message
X	   h		Headers displayed with message
X           j		Increment current message by one
X	   k		Decrement current message by one
X           m            Mail to arbitrary user(s)
X           n            Next message (Read current, then increment)
X	   o		Change Elm options
X	   p            print current message
X           q            Quit - mail deleted, saved in mbox or left.
X           r            Reply to current message
X           s            Save message to specified file
X	   t		Tag a message for further operations
X	  ^T		Tag messages with specified pattern
X           u            Undelete current message
X           x            Exit - don't record as read, don't save...
X
X          ^L            Rewrite screen.
X	  <RETURN>	Read current message
X	  ^Q, DEL	Exit - don't record as read, don't save...
END_OF_doc/elm-help.0
if test 1802 -ne `wc -c <doc/elm-help.0`; then
    echo shar: \"doc/elm-help.0\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/elm-help.1\" \(847 characters\)
if test -f doc/elm-help.1 ; then 
  echo shar: Will not over-write existing file \"doc/elm-help.1\"
else
sed "s/^X//" >doc/elm-help.1 <<'END_OF_doc/elm-help.1'
X
X                Commands available from the Options Menu
X
XChar    Meaning
X----    -------
X  c     Change `calendar' file to the file specified.  See '<' at top level 
X        menu for more information on this.
X
X  d     Display pager.  `builtin' will use the built-in pager, or you
X        can put anything else you'd like, including "/bin/more"
X
X  e     Editor to use when composing messages
X
X  f     Folder directory.  This is what '=', '+', or '%' expands to.
X
X  s     Sorting criteria.  Step through with space, <return> selects.
X
X  o     Outbound mail file.  Where to save copies of outbound mail.
X
X  p     How to print messages.  '%s' can be used as a filename holder
X
X  y     Your fullname for outbound mail.
X
X  a     arrow cursor.  Changes from "->" to inverse bar and back
X
X  m     display mini-menus or not.  Expert users usually don't.
END_OF_doc/elm-help.1
if test 847 -ne `wc -c <doc/elm-help.1`; then
    echo shar: \"doc/elm-help.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/elm-help.2\" \(462 characters\)
if test -f doc/elm-help.2 ; then 
  echo shar: Will not over-write existing file \"doc/elm-help.2\"
else
sed "s/^X//" >doc/elm-help.2 <<'END_OF_doc/elm-help.2'
X
X                Commands available from the Alias Menu
X
XChar    Meaning
X----    -------
X
X  ?     help on a specific key, or this summary of commands.
X
X  a     Add return address of current message to alias database
X
X  m     Make new user alias, adding to alias database when done
X
X  r,x   return from the alias menu
X                      
X  p     check for a person in the alias database
X        
X  s     check for a system in the host routing/domain database
X
END_OF_doc/elm-help.2
if test 462 -ne `wc -c <doc/elm-help.2`; then
    echo shar: \"doc/elm-help.2\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/elmrc.sample\" \(1520 characters\)
if test -f doc/elmrc.sample ; then 
  echo shar: Will not over-write existing file \"doc/elmrc.sample\"
else
sed "s/^X//" >doc/elmrc.sample <<'END_OF_doc/elmrc.sample'
X#
X# .msgrc - automatic variable defines for the 'msg' mailer.
X#
X# Personalized for ??
X# 
X
X# where to save my mail to, default directory
Xmaildir  = ~/Mail
X
X# where to save messages to, default file
Xmailbox  = ~/Mail/mailbox
X
X# what editor to use
Xeditor   = $EDITOR
X
X# where to save mail if not specified somewhere else
Xsavemail = ~/Mail/mail.sent
X
X# how to print a message ('%s' is the filename)
Xprint    = /usr/local/bin/print -p lpn -f %s
X
X# prefix sequence for including message text in other messages...
Xprefix = > 
X
X# what headers I DON'T want to see, ever.
X
Xweedout  = "Via:"  "Sent:"  "Date:"  "Status:"  "Original"
X	   "From"  "Phase"  "Subject:"  "Fruit"  "Sun"
X	   "Lat"  "Buzzword"  "Return"  "Posted" "Telephone"
X	   "Postal-Address" "Origin" "X-Sent-By-Nmail-V"
X	   "Resent" "X-Location"  "Source" "Mood"  "Neuron"
X	   "Libido" "To:" "X-Mailer:"  "Full-Name:" "X-HPMAIL"
X	   "Cc:" "cc:" "Mmdf" "Network-"
X
X# automatically copy message being replied to into buffer? 
Xautocopy = OFF
X
X# save a copy of all outbound messages? 
Xcopy     = ON
X
X# emulate the mailx message increment mode (only increment after something
X# has been 'done' to a message, either saved or deleted)
Xresolve  = ON
X
X# enable the weedout list to be read...
Xweed     = ON
X
X# when messages are copied into the outbound buffer, don't include headers
Xnoheader = ON
X
X# display message title when displaying pages of message
Xtitles	 = ON
X
X# alternative addresses that I could receive mail from (usually a
X# forwarding mailbox)
X
X# alternatives = 
END_OF_doc/elmrc.sample
if test 1520 -ne `wc -c <doc/elmrc.sample`; then
    echo shar: \"doc/elmrc.sample\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/filter.1\" \(2330 characters\)
if test -f doc/filter.1 ; then 
  echo shar: Will not over-write existing file \"doc/filter.1\"
else
sed "s/^X//" >doc/filter.1 <<'END_OF_doc/filter.1'
X.TH FILTER 1L
X.ad b
X.SH NAME
Xfilter - filter incoming messages before adding to mailbox
X.SH SYNOPSIS
X.B filter
X[-a]
X[-v]
X.br
X.B filter
X[-n]
X.br
X.B filter
X[-r]
X.br
X.B filter
X[-c] [-s]
X.br
X.B filter
X[-c] [-S]
X.SH HP-UX COMPATIBILITY
X.TP 10
XLevel:
XHP-UX/CONTRIBUTED
X.TP
XOrigin:
XHewlett-Packard Laboratories
X.SH DESCRIPTION
X.I Filter
Xis a sophisticated program that allows incoming mail to be
Xfiltered against a wide set of criteria.  The format for the
Xrules, located in $HOME/.filter_rules, is;
X.nf
X	
X	if (\fIcondition\fR) then \fIaction\fR
X
X.fi
Xwhere \fIcondition\fR can be any number of occurances of 
X``\fIfield\fR \fIrelationship\fR "\fIvalue\fR"'' joined by
X\fBand\fR statements and optionally prepended with a \fBnot\fR
Xstatement.  Note that the \fBor\fR statement is not currently
Xsupported as a logical conjunction.
X.sp
X\fIField\fR can be ``from'', ``subject'', ``to'',
X``lines'' or ``contains'', \fIrelationship\fR can be either `='
Xor, for ``lines'', `<', `>', `<=', `>=', or '!=' too.
X.nf
X
X	delete
X	save	 \fIfoldername\fR
X	savecopy \fIfoldername\fR
X	execute  \fIcommand\fR
X	forward  \fIaddress\fR
X	leave
X
X.fi
XThe flags are;
X.TP 1.0i
X.B "-a"
XAudible.  Output a beep with each filter action message (use with \fB-v\fR).
X.TP
X.B "-c"
XClear Logs.  If this flag is used, the log files will be removed after
Xbeing summarized by either "-s" or "-S" (see below).
X.TP
X.B "-n"
XNot-Really.  Output what would happen if given message from standard
Xinput, but don't actually do anything with it.
X.TP
X.B "-r"
XRules.  List the rules currently being used.
X.TP
X.B "-s"
XSummarize.  List a summary of the messages filtered since the last summary
Xand zero the log file.
X.TP
X.B "-S"
XSummarize in a more verbose format.
X.TP
X.B "-v"
XVerbose.  Give output on standard out for each message filtered.  Useful
Xto have redirected to ``/dev/console'' and such.  (see \fB-a\fR too).
X.SH AUTHOR
XDave Taylor, Hewlett-Packard Laboratories.
X.SH FILES
X$HOME/.filter-rules     The ruleset for the users filter
X.br
X$HOME/.filterlog        A log of what has been done
X.br
X$HOME/.filtersum        A summary of what has been done
X.br
X/etc/passwd             Used to get users home directory
X.SH SEE\ ALSO
X\fIThe Elm Filter Guide\fR, by Dave Taylor.
X.br
Xreadmsg(1L), elm(1L), mail(1), mailx(1), sendmail(1,8)
X.SH COMMENTS
XNot real smart about pattern matching.  
END_OF_doc/filter.1
if test 2330 -ne `wc -c <doc/filter.1`; then
    echo shar: \"doc/filter.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/from.1\" \(1055 characters\)
if test -f doc/from.1 ; then 
  echo shar: Will not over-write existing file \"doc/from.1\"
else
sed "s/^X//" >doc/from.1 <<'END_OF_doc/from.1'
X.TH FROM 1L
X.ad b
X.SH NAME
Xfrom - list from and subject of all messages in mailbox or file
X.SH SYNOPSIS
X.B from
X[-n]
X[ filename ]
X.br
X.B from
X[-n]
X[ username ]
X.SH HP-UX COMPATIBILITY
X.TP 10
XLevel:
XHP-UX/CONTRIBUTED
X.TP
XOrigin:
XHewlett-Packard
X.SH DESCRIPTION
X.I From
Xoutputs a line per message in the current users mailbox 
Xof the form;
X.PP
X<from> [subject]
X.PP
XIf a filename is specified, the program reads that file
Xrather than the default file.  If the argument is a
X\fIusername\fR then look for that users mailbox.
X.PP
XFurthermore, if the \fI-n\fR flag is specified, the headers
Xwill be numbered using the same numbering scheme that, for
Xexample, \fIreadmsg\fR will understand.
X.PP
XFilename can be specified with the same notation as
Xwhen invoking the \fBElm\fR mailer.
X.SH AUTHOR
XDave Taylor, Hewlett-Packard Laboratories.
X.SH SEE\ ALSO
Xreadmsg(1L), elm(1L), mail(1), mailx(1)
X.SH BUGS
XOccasionally it gets confused about whether a message has
Xa subject or not.  This, unfortunately, is due to the
Xvast number of possible headers in the messages...
END_OF_doc/from.1
if test 1055 -ne `wc -c <doc/from.1`; then
    echo shar: \"doc/from.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/listalias.1\" \(806 characters\)
if test -f doc/listalias.1 ; then 
  echo shar: Will not over-write existing file \"doc/listalias.1\"
else
sed "s/^X//" >doc/listalias.1 <<'END_OF_doc/listalias.1'
X.TH LISTALIAS 1L
X.ad b
X.SH NAME
Xlistalias - list user and system aliases
X.SH SYNOPSIS
X.B listalias
X[ regular-expression ]
X.SH HP-UX COMPATIBILITY
X.TP 10
XLevel:
XHP-UX/CONTRIBUTED
X.TP
XOrigin:
XHewlett-Packard Laboratories
X.SH DESCRIPTION
X.I Listalias
Xoutputs a line per alias in both the user and the system 
Xaliases.  Each line is of the form;
X.nf
X   
X   <alias>     <address>  (<comment>)
X
X.fi
XIf an optional regular expression is used, just the aliases
Xthat match the specified expression are listed.  If not, 
Xthey are all listed.
X.sp
XEither way, the output is sorted.
X.SH AUTHOR
XDave Taylor, Hewlett-Packard Laboratories.
X.SH SEE\ ALSO
Xnewalias(1L), elm(1L), checkalias(1L)
X.SH BUGS
XSince the program uses a pipe to egrep, how expressions are evaluated is
Xa function of \fIthat\fR program, not this one!
END_OF_doc/listalias.1
if test 806 -ne `wc -c <doc/listalias.1`; then
    echo shar: \"doc/listalias.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/messages.1\" \(518 characters\)
if test -f doc/messages.1 ; then 
  echo shar: Will not over-write existing file \"doc/messages.1\"
else
sed "s/^X//" >doc/messages.1 <<'END_OF_doc/messages.1'
X.TH MESSAGES 1L
X.ad b
X.SH NAME
Xmessages - quick count of messages in mailbox or folder
X.SH SYNOPSIS
X.B messages
X.br
X.B messages
Xfolder-name
X.SH HP-UX COMPATIBILITY
X.TP 10
XLevel:
XHP-UX/CONTRIBUTED
X.TP
XOrigin:
XHewlett-Packard
X.SH DESCRIPTION
X.I Messages
Xcounts the occurances of "^From\ " in either the current incoming 
Xmailbox or the specified folder.
X.P
XThis is, in fact, a simple little shell script!!
X.SH AUTHOR
XDave Taylor, Hewlett-Packard Laboratories
X.SH SEE\ ALSO
Xfrom(1L), elm(1L)
X.SH BUGS
XDon't be foolish...
END_OF_doc/messages.1
if test 518 -ne `wc -c <doc/messages.1`; then
    echo shar: \"doc/messages.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/newalias.1\" \(2407 characters\)
if test -f doc/newalias.1 ; then 
  echo shar: Will not over-write existing file \"doc/newalias.1\"
else
sed "s/^X//" >doc/newalias.1 <<'END_OF_doc/newalias.1'
X.TH NEWALIAS 1L
X.ad b
X.SH NAME
Xnewalias - install new elm aliases for user and/or system
X.SH SYNOPSIS
X.B newalias
X[-q]
X.SH HP-UX COMPATIBILITY
X.TP 10
XLevel:
XHP-UX/CONTRIBUTED
X.TP
XOrigin:
XHewlett-Packard
X.SH DESCRIPTION
X.I Newalias
Xcreates new hash and data files from a text file.  If the
Xprogram is invoked by any account other than the superuser
Xaccount, the program looks for a file 
Xcalled $home/.alias_text
Xand, upon finding it, creates files $home/.alias_hash and
X$home/.alias_data for the 
X.I Elm
Xprogram.
X.PP
XIf the superuser invokes the program, they are given the
Xoption of either updating their personal alias files or
Xthe system alias files.
XThe question can be supressed, with the default being
Xthe user files for the superuser, if the ``-q'' flag is
Xpresent upon invokation.
X.PP
XThe format that the program expects is;
X.sp
X.nf
X	alias, alias, .. : comment : address
Xor
X	alias, alias, .. : comment : alias, alias, ...
X   
XThe first form is for an individual user such as;
X
X	dave, taylor : Dave Taylor : veeger!hpcnou!dat
X
Xand the second is for defining a group alias such as;
X
X	gurus : Unix Gurus : alan, john, dave, mike, richard,
X		             larry, t_richardson
X
X.fi
X.sp
XNote that lines can be continued at will, blank lines are accepted
Xwithout error, and that any line starting with '#' is considered a
Xcomment and is not processed.
X.PP
XThe comment field is thrown away by this program, but it is 
Xrecommended that it contain the name of the user who the alias
Xis for.
X.PP
XFinally, aliases can contain other aliases, and/or groups;
X.sp
X.nf
X	unix : Unix people : gurus, taylor, jonboy
X.fi
X' onto the next page, if you please
X.sp 3
X.SH FILES
X$home/.alias_text               alias source for user 
X.br
X$home/.alias_hash               alias hash table for user
X.br
X$home/.alias_data               alias data file for user
X.br
X/usr/mail/.alias_text           alias source for system
X.br
X/usr/mail/.alias_hash           alias hash table for system
X.br
X/usr/mail/.alias_data           alias data file for system
X.SH AUTHOR
XDave Taylor, Hewlett-Packard Laboratories.
X.SH SEE\ ALSO
Xelm(1L), checkalias(1L), mail(1), mailx(1)
X.SH DIAGNOSTICS
XNewalias has a couple of descriptive error messages which
Xdon't need to be detailed here.  It is, however, worth
Xnoting that the
X.I checkalias
Xprogram can be used to ensure that the aliases are in the
Xproper order and are available for the 
X.I Elm
Xsystem.
END_OF_doc/newalias.1
if test 2407 -ne `wc -c <doc/newalias.1`; then
    echo shar: \"doc/newalias.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/newmail.1\" \(1377 characters\)
if test -f doc/newmail.1 ; then 
  echo shar: Will not over-write existing file \"doc/newmail.1\"
else
sed "s/^X//" >doc/newmail.1 <<'END_OF_doc/newmail.1'
X.TH NEWMAIL 1L 
X.ad b
X.SH NAME
Xnewmail - daemon to asynchronously notify of new mail
X.SH SYNOPSIS
X.B newmail
X.br
X.B newmail
Xfilename
X.PP
X.SH HP-UX COMPATIBILITY
X.TP 10
XLevel:
XHP-UX/CONTRIBUTED
X.TP
XOrigin:
XHewlett-Packard
X.SH DESCRIPTION
X.I Newmail\^
Xis a daemon designed to run in background and every 60 seconds
Xcheck to see if there is any new mail for the user that
Xstarted it up.
X.P
XIf there is new mail, the program will asynchronously write to
Xthe terminal that it was started on a message of the form
X.nf
X
X   New mail from <name> - <subject>
X
X.fi
Xwhere <name> is either the name of the person sending it,
Xif available (the ARPA 'From:' line) or machine!login where
Xmachine is the machine the mail was sent from.  If there
Xis no subject, the message "<no subject>" will appear on
Xthe screen.
X.P
XIf the message is a \fIpriority\fR message (that is, it has a field
Xin the header "Priority:"), then the line will be "PRIORITY mail"
Xinstead of "New mail".
X.P
XThis program will run forever, and can internally reset 
Xitself if mail is deleted from the incoming mailbox while
Xtrying to monitor it.
X.P
XIf \fBnewmail\fR is started up with a filename, it will
Xperform exactly the same, but with the specified file as
Xthe one to check rather than the default users mailbox.
X.SH AUTHOR
XDave Taylor, Hewlett-Packard Laboratories.
X.SH SEE ALSO
Xnotify in sh(1) or csh(1), announce(1L)
END_OF_doc/newmail.1
if test 1377 -ne `wc -c <doc/newmail.1`; then
    echo shar: \"doc/newmail.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/printmail.1\" \(809 characters\)
if test -f doc/printmail.1 ; then 
  echo shar: Will not over-write existing file \"doc/printmail.1\"
else
sed "s/^X//" >doc/printmail.1 <<'END_OF_doc/printmail.1'
X.TH PRINTMAIL 1L
X.ad b
X.SH NAME
Xprintmail - format mail in a readable fashion for printing
X.SH SYNOPSIS
X.B printmail
X{-d}
X{filename}
X.SH HP-UX COMPATIBILITY
X.TP 10
XLevel:
XHP-UX/CONTRIBUTED
X.TP
XOrigin:
XHewlett-Packard
X.SH DESCRIPTION
X.I Printmail
Xcopies all messages from either the file specified or the
Xdefault user mailbox separated by form feeds to standard output.  
XWith the
X.B \-d
Xoption, the messages are separated by a dashed line
Xrather than the formfeed (for lots of little mail).
X.sp
X.P
XIf the program is given a file as standard input, it will
Xuse that instead of the default mailbox for the operation
Xspecified.
X.SH EXAMPLE
XA typical usage of this command is;
X.nf
X	printmail -d | print 
X.fi
X.SH AUTHOR
XDave Taylor, Hewlett-Packard Laboratories.
X.SH SEE\ ALSO
Xelm(1L), mail(1), mailx(1), from(1L)
END_OF_doc/printmail.1
if test 809 -ne `wc -c <doc/printmail.1`; then
    echo shar: \"doc/printmail.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/trim-headers.1\" \(958 characters\)
if test -f doc/trim-headers.1 ; then 
  echo shar: Will not over-write existing file \"doc/trim-headers.1\"
else
sed "s/^X//" >doc/trim-headers.1 <<'END_OF_doc/trim-headers.1'
X.TH TRIM-HEADERS 1L
X.ad b
X.SH NAME
Xtrim-headers - help keep mailbox files clean of trash headers
X.SH SYNOPSIS
Xcat \fIfilename\fR |
X.B trim-headers
X> \fIfilename2\fR
X.br
X.B trim-headers
Xfilename-list
X.SH HP-UX COMPATIBILITY
X.TP 10
XLevel:
XHP-UX/CONTRIBUTED
X.TP
XOrigin:
XHewlett-Packard Laboratories
X.SH DESCRIPTION
X.I Trim-headers
Xis a simple awk script that removes all headers from the specified
Xfolder, either standard input or one of a list of filenames, according
Xto how it's invoked.  The program knows about the following headers;
X.sp
X.nf
X	From 
X	From:
X	Subject:
X	To:
X	Cc:
X	Date:
X
X.fi
XAll other headers are considered extraneous and are removed.
X.SH AUTHOR
XDave Taylor, Hewlett-Packard Laboratories
X.SH SEE\ ALSO
Xawk(1), printmail(1L), readmsg(1L)
X.SH BUGS
XThe current incancation of the \fIawk\fR script doesn't understand
Xthe idea of multiple line header fields, so a message that has, say,
Xa three line To: list will only have the first line saved...
END_OF_doc/trim-headers.1
if test 958 -ne `wc -c <doc/trim-headers.1`; then
    echo shar: \"doc/trim-headers.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/wnewmail.1\" \(1502 characters\)
if test -f doc/wnewmail.1 ; then 
  echo shar: Will not over-write existing file \"doc/wnewmail.1\"
else
sed "s/^X//" >doc/wnewmail.1 <<'END_OF_doc/wnewmail.1'
X.TH WNEWMAIL 1L 
X.ad b
X.SH NAME
Xwnewmail - daemon to asynchronously notify of new mail
X.SH SYNOPSIS
X.B wnewmail
X.br
X.B wnewmail
Xfilename
X.PP
X.SH HP-UX COMPATIBILITY
X.TP 10
XLevel:
XHP-UX/CONTRIBUTED
X.TP
XOrigin:
XHewlett-Packard
X.SH DESCRIPTION
X.I Wnewmail\^
Xis a daemon designed to run in \fBa window\fR on a windowing
Xsystem (such as an HP or Sun system) and check every 10 seconds
Xto see if there is any new mail for the user that
Xstarted it up.
X.P
XIf there is new mail, the program will "beep", and write to
Xthe window for each of the new messages;
X.nf
X
X   Mail from <name> -- <subject>
X
X.fi
Xwhere <name> is either the name of the person sending it,
Xif available (the ARPA 'From:' line) or machine!login where
Xmachine is the machine the mail was sent from.  If there
Xis no subject, the message "<no subject>" will appear on
Xthe screen.
X.P
XIf the message is a \fIpriority\fR message (that is, the
Xheader contains a line "Priority:"), then the line output
Xwill be "PRIORITY mail from ..." rather than just "Mail from".
X.P
XThis program will run forever, and can internally reset 
Xitself if mail is deleted from the incoming mailbox while
Xtrying to monitor it.
X.P
XIf \fBwnewmail\fR is started up with a filename, it will
Xperform exactly the same, but with the specified file as
Xthe one to check rather than the default users mailbox.
X.SH AUTHOR
XDave Taylor, Hewlett-Packard Laboratories.
X.SH SEE ALSO
Xnotify in sh(1) or csh(1), newmail(1L)
X.SH NOTE
XThis is almost identical to the program \fBnewmail\fR...
END_OF_doc/wnewmail.1
if test 1502 -ne `wc -c <doc/wnewmail.1`; then
    echo shar: \"doc/wnewmail.1\" unpacked with wrong size!?
fi
# end of overwriting check
fi
if test ! -d filter ; then
    echo shar: Creating directory \"filter\"
    mkdir filter
fi
echo shar: Extracting \"filter/Makefile\" \(1172 characters\)
if test -f filter/Makefile ; then 
  echo shar: Will not over-write existing file \"filter/Makefile\"
else
sed "s/^X//" >filter/Makefile <<'END_OF_filter/Makefile'
X#
X#  Makefile for the Elm system filter program
X#
X#         (C) Copyright 1986, Dave Taylor
X#
X#  Last modification: Oct 7th, 1986
X
XSHELL=/bin/sh
X
XDEFINE= -DBSD
XLIB2  = -lcurses
X
XCFLAGS= -O -I../hdrs
XCC=	/bin/cc
XRM= 	/bin/rm -f
XECHO=  /bin/echo
X
XOBJ     =   ../bin/filter
XHDRS    =   ../hdrs/defs.h ../hdrs/sysdefs.h ../hdrs/filter.h
XBINARIES=   actions.o filter.o parse.o rules.o summarize.o utils.o utils2.o
XSRC     =   actions.c filter.c parse.c rules.c summarize.c utils.c utils2.c
X
Xall: ${OBJ}
X
X../bin/filter  : ${HDRS} ${BINARIES}
X	${CC} ${CFLAGS} ${DEFINE} ${BINARIES} -o ${OBJ}
X
Xactions.o : ${HDRS} actions.c
X	${CC} -c ${CFLAGS} ${DEFINE} actions.c
X
Xfilter.o : ${HDRS} filter.c
X	${CC} -c ${CFLAGS} ${DEFINE} filter.c
X
Xparse.o : ${HDRS} parse.c
X	${CC} -c ${CFLAGS} ${DEFINE} parse.c
X
Xutils.o : ${HDRS} utils.c
X	${CC} -c ${CFLAGS} ${DEFINE} utils.c
X
Xutils2.o : ${HDRS} utils2.c
X	${CC} -c ${CFLAGS} ${DEFINE} utils2.c
X
Xrules.o : ${HDRS} rules.c
X	${CC} -c ${CFLAGS} ${DEFINE} rules.c
X
Xsummarize.o : ${HDRS} summarize.c
X	${CC} -c ${CFLAGS} ${DEFINE} summarize.c
X
Xlint    : 
X	lint -I../hdrs ${SRC} > LINT.OUT
X
Xclean	:
X	${RM} ${BINARIES}
X
Xindex   :
X	index ${SRC} > INDEX
X
END_OF_filter/Makefile
if test 1172 -ne `wc -c <filter/Makefile`; then
    echo shar: \"filter/Makefile\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"filter/Makefile.mstr\" \(1167 characters\)
if test -f filter/Makefile.mstr ; then 
  echo shar: Will not over-write existing file \"filter/Makefile.mstr\"
else
sed "s/^X//" >filter/Makefile.mstr <<'END_OF_filter/Makefile.mstr'
X#
X#  Makefile for the Elm system filter program
X#
X#         (C) Copyright 1986, Dave Taylor
X#
X#  Last modification: Oct 7th, 1986
X
XSHELL=/bin/sh
X
XDEFINE= >os-define<
XLIB2  = >lib2<
X
XCFLAGS= -O -I../hdrs
XCC=	>cc<
XRM= 	>rm<
XECHO=  /bin/echo
X
XOBJ     =   ../bin/filter
XHDRS    =   ../hdrs/defs.h ../hdrs/sysdefs.h ../hdrs/filter.h
XBINARIES=   actions.o filter.o parse.o rules.o summarize.o utils.o utils2.o
XSRC     =   actions.c filter.c parse.c rules.c summarize.c utils.c utils2.c
X
Xall: ${OBJ}
X
X../bin/filter  : ${HDRS} ${BINARIES}
X	${CC} ${CFLAGS} ${DEFINE} ${BINARIES} -o ${OBJ}
X
Xactions.o : ${HDRS} actions.c
X	${CC} -c ${CFLAGS} ${DEFINE} actions.c
X
Xfilter.o : ${HDRS} filter.c
X	${CC} -c ${CFLAGS} ${DEFINE} filter.c
X
Xparse.o : ${HDRS} parse.c
X	${CC} -c ${CFLAGS} ${DEFINE} parse.c
X
Xutils.o : ${HDRS} utils.c
X	${CC} -c ${CFLAGS} ${DEFINE} utils.c
X
Xutils2.o : ${HDRS} utils2.c
X	${CC} -c ${CFLAGS} ${DEFINE} utils2.c
X
Xrules.o : ${HDRS} rules.c
X	${CC} -c ${CFLAGS} ${DEFINE} rules.c
X
Xsummarize.o : ${HDRS} summarize.c
X	${CC} -c ${CFLAGS} ${DEFINE} summarize.c
X
Xlint    : 
X	lint -I../hdrs ${SRC} > LINT.OUT
X
Xclean	:
X	${RM} ${BINARIES}
X
Xindex   :
X	index ${SRC} > INDEX
X
END_OF_filter/Makefile.mstr
if test 1167 -ne `wc -c <filter/Makefile.mstr`; then
    echo shar: \"filter/Makefile.mstr\" unpacked with wrong size!?
fi
# end of overwriting check
fi
if test ! -d hdrs ; then
    echo shar: Creating directory \"hdrs\"
    mkdir hdrs
fi
echo shar: Extracting \"hdrs/curses.h\" \(620 characters\)
if test -f hdrs/curses.h ; then 
  echo shar: Will not over-write existing file \"hdrs/curses.h\"
else
sed "s/^X//" >hdrs/curses.h <<'END_OF_hdrs/curses.h'
X/*** 			curses.h			***/
X
X/*** (C) Copyright 1986 Dave Taylor			***/
X
X     /*** Include file for seperate compilation.  ***/
X
X#define OFF		0
X#define ON 		1
X
Xint  InitScreen(),      /* This must be called before anything else!! */
X
X     ClearScreen(), 	 CleartoEOLN(),
X
X     MoveCursor(),
X     CursorUp(),         CursorDown(), 
X     CursorLeft(),       CursorRight(), 
X
X     StartBold(),        EndBold(), 
X     StartUnderline(),   EndUnderline(), 
X     StartHalfbright(),  EndHalfbright(),
X     StartInverse(),     EndInverse(),
X	
X     transmit_functions(),
X
X     Raw(),              ReadCh();
X
Xchar *return_value_of();
END_OF_hdrs/curses.h
if test 620 -ne `wc -c <hdrs/curses.h`; then
    echo shar: \"hdrs/curses.h\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"hdrs/save_opts.h\" \(2043 characters\)
if test -f hdrs/save_opts.h ; then 
  echo shar: Will not over-write existing file \"hdrs/save_opts.h\"
else
sed "s/^X//" >hdrs/save_opts.h <<'END_OF_hdrs/save_opts.h'
X/**			 save_opts.h 			**/
X
X/** Some crazy includes for the save-opts part of the Elm program!
X
X    (C) Copyright 1986, Dave Taylor
X**/
X
X#define ALTERNATIVES		0
X#define ALWAYSDELETE		1
X#define ALWAYSLEAVE		2
X#define ARROW			3
X#define AUTOCOPY		4
X#define BOUNCEBACK		5
X#define CALENDAR		6
X#define COPY			7
X#define EDITOR			8
X#define EDITOUT			9
X#define FORMS			10
X#define FULLNAME		11
X#define KEYPAD			12
X#define LOCALSIGNATURE		13
X#define MAILBOX			14
X#define MAILDIR			15
X#define MENU			16
X#define MOVEPAGE		17
X#define NAMES			18
X#define NOHEADER		19
X#define PAGER			20
X#define POINTNEW		21
X#define PREFIX			22
X#define PRINT			23
X#define REMOTESIGNATURE		24
X#define RESOLVE			25
X#define SAVEMAIL		26
X#define SAVENAME		27
X#define SHELL			28
X#define SIGNATURE		29
X#define SOFTKEYS		30
X#define SORTBY			31
X#define TIMEOUT			32
X#define TITLES			33
X#define USERLEVEL		34
X#define WARNINGS		35
X#define WEED			36
X#define WEEDOUT			37
X
X#define NUMBER_OF_SAVEABLE_OPTIONS	WEEDOUT+1
X
Xstruct save_info_recs { 
X	char 	name[NLEN]; 	/* name of instruction */
X	long 	offset;		/* offset into elmrc-info file */
X	} save_info[NUMBER_OF_SAVEABLE_OPTIONS] = 
X{
X { "alternatives", -1L }, { "alwaysdelete", -1L }, 	{ "alwaysleave", -1L },
X { "arrow", -1L},         { "autocopy", -1L },      	{ "bounceback", -1L },
X { "calendar", -1L }, 	  { "copy", -1L },          	{ "editor", -1L },
X { "editout", -1L }, 	  { "forms", -1L },         	{ "fullname", -1L },
X { "keypad", -1L }, 	  { "localsignature", -1L },	{ "mailbox", -1L }, 
X { "maildir", -1L }, 	  { "menu", -1L }, 		{ "movepage", -1L }, 
X { "names", -1L },        { "noheader", -1L }, 		{ "pager", -1L }, 
X { "pointnew", -1L},      { "prefix", -1L },       	{ "print", -1L }, 
X { "remotesignature",-1L},{ "resolve", -1L },       	{ "savemail", -1L }, 
X { "savename", -1L },     { "shell", -1L },         	{ "signature", -1L },
X { "softkeys", -1L },	  { "sortby", -1L }, 		{ "timeout", -1L },
X { "titles", -1L },       { "userlevel", -1L }, 	{ "warnings", -1L },
X { "weed", -1L },         { "weedout", -1L }
X};
END_OF_hdrs/save_opts.h
if test 2043 -ne `wc -c <hdrs/save_opts.h`; then
    echo shar: \"hdrs/save_opts.h\" unpacked with wrong size!?
fi
# end of overwriting check
fi
if test ! -d src ; then
    echo shar: Creating directory \"src\"
    mkdir src
fi
echo shar: Extracting \"src/delete.c\" \(2451 characters\)
if test -f src/delete.c ; then 
  echo shar: Will not over-write existing file \"src/delete.c\"
else
sed "s/^X//" >src/delete.c <<'END_OF_src/delete.c'
X/**		delete.c		**/
X
X/**  Delete or undelete files: just set flag in header record! 
X     Also tags specified message(s)...
X
X     (C) Copyright 1985  Dave Taylor
X**/
X
X#include "headers.h"
X
Xdelete_msg(real_del)
Xint real_del;
X{
X	/** Delete current message.  If real-del is false, then we're
X	    actually requested to toggle the state of the current
X	    message... **/
X
X	if (real_del)
X	  header_table[current-1].status |= DELETED;
X	else if (ison(header_table[current-1].status, DELETED))
X	  clearit(header_table[current-1].status, DELETED);
X	else
X	  setit(header_table[current-1].status, DELETED);
X
X	show_msg_status(current-1);
X}
X
Xundelete_msg()
X{
X	/** clear the deleted message flag **/
X
X	clearit(header_table[current-1].status, DELETED);
X
X	show_msg_status(current-1);
X}
X
Xshow_msg_status(msg)
Xint msg;
X{
X	/** show the status of the current message only.  **/
X
X	if (on_page(msg)) {
X	  MoveCursor((msg % headers_per_page) + 4, 3);
X	  if (msg == current && !arrow_cursor) {
X	    StartBold();
X	    Writechar( ison(header_table[msg].status, DELETED)? 'D' : ' ');
X	    EndBold();
X	  }
X	  else
X	    Writechar( ison(header_table[msg].status, DELETED)? 'D' : ' ');
X	}
X}
X
Xtag_message()
X{
X	/** Tag current message.  If already tagged, untag it. **/
X
X	if (ison(header_table[current-1].status, TAGGED))
X	  clearit(header_table[current-1].status, TAGGED);
X	else
X	  setit(header_table[current-1].status, TAGGED);
X
X	show_msg_tag(current-1);
X}
X
Xshow_msg_tag(msg)
Xint msg;
X{
X	/** show the tag status of the current message only.  **/
X
X	if (on_page(msg)) {
X	  MoveCursor((msg % headers_per_page) + 4, 4);
X	  if (msg == current && !arrow_cursor) {
X	    StartBold();
X	    Writechar( ison(header_table[msg].status, TAGGED)? '+' : ' ');
X	    EndBold();
X	  }
X	  else
X	    Writechar( ison(header_table[msg].status, TAGGED)? '+' : ' ');
X	}	
X}
X
Xshow_new_status(msg)
Xint msg;
X{
X	/** If the specified message is on this screen, show
X	    the new status (could be marked for deletion now,
X	    and could have tag removed...)
X	**/
X
X	if (on_page(msg)) 
X	  if (msg == current && !arrow_cursor) {
X	    StartBold();
X	    PutLine2((msg % headers_per_page) + 4, 3, "%c%c",
X		   ison(header_table[msg].status, DELETED)? 'D' : ' ',
X		   ison(header_table[msg].status, TAGGED )? '+' : ' ');
X	    EndBold();
X	  }
X	  else
X	    PutLine2((msg % headers_per_page) + 4, 3, "%c%c",
X		   ison(header_table[msg].status, DELETED)? 'D' : ' ',
X		   ison(header_table[msg].status, TAGGED )? '+' : ' ');
X}
END_OF_src/delete.c
if test 2451 -ne `wc -c <src/delete.c`; then
    echo shar: \"src/delete.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"src/getopt.c\" \(2152 characters\)
if test -f src/getopt.c ; then 
  echo shar: Will not over-write existing file \"src/getopt.c\"
else
sed "s/^X//" >src/getopt.c <<'END_OF_src/getopt.c'
X/**			getopt.c			**/
X
X/** starting argument parsing routine... 
X
X    (C) Copyright 1986 Dave Taylor
X**/
X
X#include "defs.h"
X
X#ifndef NULL
X# define NULL		0
X#endif
X
X#define DONE		0
X#define ERROR		-1
X
Xchar *optional_arg;			/* optional argument as we go */
Xint   opt_index;			/* argnum + 1 when we leave   */
X
X/***********************
X
X   Typical usage of this routine is exemplified by;
X
X	register int c;
X
X	while ((c = get_options(argc, argv, "ad:f:")) > 0) {
X	   switch (c) {
X	     case 'a' : arrow_cursor++;		break;
X	     case 'd' : debug = atoi(optional_arg);	break;
X	     case 'f' : strcpy(infile, optional_arg); 
X	                mbox_specified = 2;  break;
X	    }
X	 }
X
X	 if (c == ERROR) {
X	   printf("Usage: %s [a] [-d level] [-f file] <names>\n\n", argv[0]);
X	   exit(1);
X	}
X
X***********************/
X
Xint  _indx = 1, _argnum = 1;
X
Xint
Xget_options(argc, argv, options)
Xint argc;
Xchar *argv[], *options;
X{
X	/** Returns the character argument next, and optionally instantiates 
X	    "argument" to the argument associated with the particular option 
X	**/
X	
X	char        *word, *strchr();
X
X	if (_argnum >= argc) {	/* quick check first - no arguments! */
X	  opt_index = argc;
X	  return(DONE);
X	}
X
X	if (_indx >= strlen(argv[_argnum]) && _indx > 1) {
X	  _argnum++;
X	  _indx = 1;		/* zeroeth char is '-' */
X	}
X
X	if (_argnum >= argc) {
X	  opt_index = _argnum; /* no more args */
X	  return(DONE);
X	}
X
X	if (argv[_argnum][0] != '-') {
X	  opt_index = _argnum;
X	  return(DONE);
X	}
X
X        word = strchr(options, argv[_argnum][_indx++]);
X
X	if (word == NULL)
X	  return(ERROR);		/* Sun compatibility */
X
X	if (word == NULL || strlen(word) == 0) 
X	  return(ERROR);
X	
X	if (word[1] == ':') {
X
X	  /** Two possibilities - either tailing end of this argument or the 
X	      next argument in the list **/
X
X	  if (_indx < strlen(argv[_argnum])) { /* first possibility */
X	    optional_arg = (char *) (argv[_argnum] + _indx);
X	    _argnum++;
X	    _indx = 1;
X	  }
X	  else {				/* second choice     */
X	    if (++_argnum >= argc) 
X	      return(ERROR);			/* no argument!!     */
X
X	    optional_arg = (char *) argv[_argnum++];
X	    _indx = 1;
X	  }
X	}
X
X	return((int) word[0]);
X}
END_OF_src/getopt.c
if test 2152 -ne `wc -c <src/getopt.c`; then
    echo shar: \"src/getopt.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"src/output_utils.c\" \(2034 characters\)
if test -f src/output_utils.c ; then 
  echo shar: Will not over-write existing file \"src/output_utils.c\"
else
sed "s/^X//" >src/output_utils.c <<'END_OF_src/output_utils.c'
X/**			output_utils.c			**/
X
X/** This file contains routines used for output in the ELM program.
X
X    These routines (C) Copyright 1986 Dave Taylor
X**/
X
X#include "headers.h"
X
X
Xstatic char err_buffer[SLEN];		/* store last error message */
X
Xstatic char central_message_buffer[SLEN];
X
Xchar *strcpy();
X
Xshow_last_error()
X{
X	/** rewrite last error message! **/
X
X	error(err_buffer);
X}
X
Xclear_error()
X{
X	MoveCursor(LINES,0);
X	CleartoEOLN();
X	err_buffer[0] = '\0';
X}
X
Xset_error(s)
Xchar *s;
X{
X	strcpy(err_buffer, s);
X}
X
Xerror(s)
Xchar *s;
X{
X	/** outputs error 's' to screen at line 22, centered! **/
X
X	MoveCursor(LINES,0);
X	CleartoEOLN();
X	PutLine0(LINES,(COLUMNS-strlen(s))/2,s);
X	fflush(stdout);
X	strcpy(err_buffer, s);	/* save it too! */
X}
X
X/*VARARGS1*/
X
Xerror1(s, a)
Xchar *s, *a;
X{
X	/** same as error, but with a 'printf' argument **/
X	char buffer[SLEN];
X
X	sprintf(buffer,s,a);
X	error(buffer);
X}
X
X/*VARARGS1*/
X
Xerror2(s, a1, a2)
Xchar *s, *a1, *a2;
X{
X	/** same as error, but with two 'printf' arguments **/
X	char buffer[SLEN];
X
X	sprintf(buffer,s, a1, a2);
X	error(buffer);
X}
X
X/*VARARGS1*/
X
Xerror3(s, a1, a2, a3)
Xchar *s, *a1, *a2, *a3;
X{
X	/** same as error, but with three 'printf' arguments **/
X	char buffer[SLEN];
X
X	sprintf(buffer,s, a1, a2, a3);
X	error(buffer);
X}
X
Xlower_prompt(s)
Xchar *s;
X{
X	/** prompt user for input on LINES-1 line, left justified **/
X
X	PutLine0(LINES-1,0,s);
X	CleartoEOLN();
X}
X
Xprompt(s)
Xchar *s;
X{
X	/** prompt user for input on LINES-3 line, left justified **/
X
X	PutLine0(LINES-3,0,s);
X	CleartoEOLN();
X}
X
X
Xset_central_message(string, arg)
Xchar *string, *arg;
X{
X	/** set up the given message to be displayed in the center of
X	    the current window **/ 
X
X	sprintf(central_message_buffer, string, arg);
X}
X
Xdisplay_central_message()
X{
X	/** display the message if set... **/
X
X	if (central_message_buffer[0] != '\0') {
X	  ClearLine(LINES-15);
X	  Centerline(LINES-15, central_message_buffer);
X	  fflush(stdout);
X	}
X}
X
Xclear_central_message()
X{
X	/** clear the central message buffer **/
X
X	central_message_buffer[0] = '\0';
X}
END_OF_src/output_utils.c
if test 2034 -ne `wc -c <src/output_utils.c`; then
    echo shar: \"src/output_utils.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"src/pmalloc.c\" \(1249 characters\)
if test -f src/pmalloc.c ; then 
  echo shar: Will not over-write existing file \"src/pmalloc.c\"
else
sed "s/^X//" >src/pmalloc.c <<'END_OF_src/pmalloc.c'
X/**			pmalloc.c		**/
X
X/** This routine contains a cheap permanent version of the malloc call to 
X    speed up the initial allocation of the weedout headers and the uuname 
X    data.  
X
X      This routine is originally from Jim Davis of HP Labs, with some 
X    mods by me.
X**/
X
X#include <stdio.h>
X#include "defs.h"
X
X/*VARARGS0*/
X
Xchar *pmalloc(size)
Xint size; 
X{
X	/** return the address of a specified block **/
X
X	static char *our_block = NULL;
X	static int   free_mem  = 0;
X
X	char   *return_value, *malloc();
X
X	/** if bigger than our threshold, just do the real thing! **/
X
X	if (size > PMALLOC_THRESHOLD) 
X	   return(malloc(size));
X
X	/** if bigger than available space, get more, tossing what's left **/
X
X	if (size > free_mem) {
X	  if ((our_block = malloc(PMALLOC_BUFFER_SIZE)) == NULL) {
X	    fprintf(stderr, "\n\r\n\rCouldn't malloc %d bytes!!\n\r\n\r",
X		    PMALLOC_BUFFER_SIZE);
X	    leave();	
X          }
X	  our_block += 4;  /* just for safety, don't give back true address */
X	  free_mem = PMALLOC_BUFFER_SIZE-4;
X	}
X	
X	return_value  = our_block;	/* get the memory */
X	size = ((size+3)/4)*4;		/* Go to quad byte boundary */
X	our_block += size;		/* use it up      */
X	free_mem  -= size;		/*  and decrement */
X
X	return( (char *) return_value);
X}
END_OF_src/pmalloc.c
if test 1249 -ne `wc -c <src/pmalloc.c`; then
    echo shar: \"src/pmalloc.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"src/quit.c\" \(577 characters\)
if test -f src/quit.c ; then 
  echo shar: Will not over-write existing file \"src/quit.c\"
else
sed "s/^X//" >src/quit.c <<'END_OF_src/quit.c'
X/**		quit.c		**/
X
X/** quit: leave the current mailbox and quit the program.
X  
X    (C) Copyright 1985, Dave Taylor
X**/
X
X#include "headers.h"
X
Xlong bytes();
X
Xquit()
X{
X	/* a wonderfully short routine!! */
X
X	if (leave_mbox(1) == -1)
X	  return;			/* new mail!  (damn it)  resync */
X
X	leave();
X}
X
Xresync()
X{
X	/** Resync on the current mailbox... This is simple: simply call
X	   'newmbox' to read the file in again, set the size (to avoid
X	    confusion in the main loop) and refresh the screen!
X	**/
X
X	  newmbox(1, TRUE, TRUE);
X	  mailfile_size = bytes(infile);	
X	  showscreen();
X}
END_OF_src/quit.c
if test 577 -ne `wc -c <src/quit.c`; then
    echo shar: \"src/quit.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"src/remail.c\" \(2019 characters\)
if test -f src/remail.c ; then 
  echo shar: Will not over-write existing file \"src/remail.c\"
else
sed "s/^X//" >src/remail.c <<'END_OF_src/remail.c'
X/**			remail.c			**/
X
X/** For those cases when you want to have a message continue along
X    to another person in such a way as they end up receiving it with
X    the return address the person YOU received the mail from (does
X    this comment make any sense yet??)...
X
X    (C) Copyright 1986  Dave Taylor
X**/
X
X#include "headers.h"
X#include <errno.h>
X
Xextern int errno;
X
Xchar *error_name(), *error_description();
X
Xint
Xremail()
X{
X	/** remail a message... returns TRUE if new foot needed ... **/
X	
X	FILE *mailfd;
X	char entered[VERY_LONG_STRING], expanded[VERY_LONG_STRING];
X	char filename[SLEN], buffer[VERY_LONG_STRING];
X
X	entered[0] = '\0';
X
X	get_to(entered, expanded);
X	if (strlen(entered) == 0)
X	  return(0);
X
X	display_to(expanded);
X
X	/** now the munge... **/
X
X	sprintf(filename, "%s%d", temp_file, getpid());
X
X	if ((mailfd = fopen(filename, "w")) == NULL) {
X	  dprint1(1,"couldn't open temp file %s! (remail)\n", filename);
X	  dprint2(1,"** %s - %s **\n", error_name(errno),
X		  error_description(errno));
X	  sprintf(buffer, "Sorry - couldn't open file %s for writing (%s)",
X		  error_name(errno));
X	  set_error(buffer);
X	  return(1);
X	}
X
X	/** now let's copy the message into the newly opened
X	    buffer... **/
X
X	copy_message("", mailfd, FALSE, TRUE);  
X
X	fclose(mailfd);
X
X	/** Got the messsage, now let's ensure the person really wants to 
X	    remail it... **/
X
X	ClearLine(LINES-1);
X	ClearLine(LINES);
X	PutLine1(LINES-1,0,
X	    "Are you sure you want to remail this message (y/n) ? y%c",
X	    BACKSPACE);
X	fflush(stdin);
X	fflush(stdout);
X	if (tolower(ReadCh()) == 'n') { /* another day, another No... */
X	  Write_to_screen("No", 0);
X	  set_error("Bounce of message cancelled");
X          return(1);
X	}
X	Write_to_screen("Yes!", 0);
X
X	sprintf(buffer, "%s %s < %s", mailer, expanded, filename);
X
X	PutLine0(LINES,0,"resending mail...");
X
X	if ((errno = system_call(buffer, SH)) != 0) {
X	  sprintf(buffer, "Remail failed with error %d!", errno);
X	  set_error(buffer);
X	}
X	else
X	  set_error("mail resent");
X
X	return(1);
X}
END_OF_src/remail.c
if test 2019 -ne `wc -c <src/remail.c`; then
    echo shar: \"src/remail.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"src/signals.c\" \(1384 characters\)
if test -f src/signals.c ; then 
  echo shar: Will not over-write existing file \"src/signals.c\"
else
sed "s/^X//" >src/signals.c <<'END_OF_src/signals.c'
X/**			signals.c		**/
X
X/** This set of routines traps various signals and informs the
X    user of the error, leaving the program in a nice, graceful
X    manner.
X
X	(C) Copyright 1986 Dave Taylor
X**/
X
X#include "headers.h"
X#include <signal.h>
X
Xextern int pipe_abort;		/* set to TRUE if receive SIGPIPE */
X
Xquit_signal()
X{
X	dprint0(2,"\n\n** Received SIGQUIT **\n\n\n\n");
X	leave();
X}
X
Xterm_signal() 
X{
X	dprint0(2,"\n\n** Received SIGTERM **\n\n\n\n");
X	leave();
X}
X
Xill_signal()
X{
X	dprint0(1,"\n\n** Received SIGILL **\n\n\n\n");
X	PutLine0(LINES, 0, "\n\nIllegal Instruction signal!\n\n");
X	emergency_exit();
X}
X
Xfpe_signal()  
X{
X	dprint0(1,"\n\n** Received SIGFPE **\n\n\n\n");
X	PutLine0(LINES, 0,"\n\nFloating Point Exception signal!\n\n");
X	emergency_exit();
X}
X
Xbus_signal()
X{
X	dprint0(1,"\n\n** Received SIGBUS **\n\n\n\n");
X	PutLine0(LINES, 0,"\n\nBus Error signal!\n\n");
X	emergency_exit();
X}
X
Xsegv_signal()
X{
X	dprint0(1,"\n\n** Received SIGSEGV **\n\n\n\n");
X	PutLine0(LINES, 0,"\n\nSegment Violation signal!\n\n");
X	emergency_exit();
X}
X
Xalarm_signal()
X{	
X	/** silently process alarm signal for timeouts... **/
X
X	int alarm_signal();
X
X	signal(SIGALRM, alarm_signal);
X}
X
Xpipe_signal()
X{
X	/** silently process pipe signal... **/
X
X	int pipe_signal();
X
X	dprint0(2,"*** received SIGPIPE ***\n\n");
X	
X	pipe_abort = TRUE;	/* internal signal ... wheeee!  */
X
X	signal(SIGPIPE, pipe_signal);
X}
END_OF_src/signals.c
if test 1384 -ne `wc -c <src/signals.c`; then
    echo shar: \"src/signals.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"src/string2.c\" \(993 characters\)
if test -f src/string2.c ; then 
  echo shar: Will not over-write existing file \"src/string2.c\"
else
sed "s/^X//" >src/string2.c <<'END_OF_src/string2.c'
X/**			string2.c		**/
X
X/** This file contains string functions that are shared throughout the
X    various ELM utilities...
X
X    (C) Copyright 1986 Dave Taylor
X**/
X
X#ifndef TRUE
X#define TRUE		1
X#define FALSE		0
X#endif
X
Xint 
Xin_string(buffer, pattern)
Xchar *buffer, *pattern;
X{
X	/** Returns TRUE iff pattern occurs IN IT'S ENTIRETY in buffer. **/ 
X
X	register int i = 0, j = 0;
X	
X	while (buffer[i] != '\0') {
X	  while (buffer[i++] == pattern[j++]) 
X	    if (pattern[j] == '\0') 
X	      return(TRUE);
X	  i = i - j + 1;
X	  j = 0;
X	}
X	return(FALSE);
X}
X
Xint
Xchloc(string, ch)
Xchar *string, ch;
X{
X	/** returns the index of ch in string, or -1 if not in string **/
X	register int i;
X
X	for (i=0; i<strlen(string); i++)
X	  if (string[i] == ch) return(i);
X	return(-1);
X}
X
Xint
Xoccurances_of(ch, string)
Xchar ch, *string;
X{
X	/** returns the number of occurances of 'ch' in string 'string' **/
X
X	register int count = 0, i;
X
X	for (i=0; i<strlen(string); i++)
X	  if (string[i] == ch) count++;
X
X	return(count);
X}
END_OF_src/string2.c
if test 993 -ne `wc -c <src/string2.c`; then
    echo shar: \"src/string2.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"src/validname.c\" \(848 characters\)
if test -f src/validname.c ; then 
  echo shar: Will not over-write existing file \"src/validname.c\"
else
sed "s/^X//" >src/validname.c <<'END_OF_src/validname.c'
X/**			validname.c			**/
X
X/** This routine takes a single address, no machine hops or
X    anything, and returns 1 if it's valid and 0 if not.  The
X    algorithm it uses is the same one that uux uses, namely:
X
X	1. Is there a file '/usr/mail/%s'?  
X	2. Is there a password entry for %s?
X	
X   (C) Copyright 1986 Dave Taylor 
X**/
X
X#include "defs.h"
X
X#include <stdio.h>
X
X#ifndef NOCHECK_VALIDNAME
X#  ifdef BSD4.1
X#    include <sys/pwd.h>
X#  else
X#    include <pwd.h>
X#  endif
X#endif
X
Xint
Xvalid_name(name)
Xchar *name;
X{
X	/** does what it says above, boss! **/
X
X#ifdef NOCHECK_VALIDNAME
X
X	return(1);		/* always say it's okay! */
X
X#else
X	struct passwd *getpwname();
X	char filebuf[SLEN];
X
X	sprintf(filebuf,"%s/%s", mailhome, name);
X	
X	if (access(filebuf, ACCESS_EXISTS) == 0)
X	  return(1);
X
X	if (getpwnam(name) != NULL)
X	  return(1);
X
X	return(0);
X
X#endif
X
X}
END_OF_src/validname.c
if test 848 -ne `wc -c <src/validname.c`; then
    echo shar: \"src/validname.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
if test ! -d test ; then
    echo shar: Creating directory \"test\"
    mkdir test
fi
echo shar: Extracting \"test/test.empty\" \(0 character\)
if test -f test/test.empty ; then 
  echo shar: Will not over-write existing file \"test/test.empty\"
else
sed "s/^X//" >test/test.empty <<'END_OF_test/test.empty'
END_OF_test/test.empty
if test 0 -ne `wc -c <test/test.empty`; then
    echo shar: \"test/test.empty\" unpacked with wrong size!?
fi
# end of overwriting check
fi
if test ! -d utils ; then
    echo shar: Creating directory \"utils\"
    mkdir utils
fi
echo shar: Extracting \"utils/listalias.c\" \(1786 characters\)
if test -f utils/listalias.c ; then 
  echo shar: Will not over-write existing file \"utils/listalias.c\"
else
sed "s/^X//" >utils/listalias.c <<'END_OF_utils/listalias.c'
X/**			listalias.c			**/
X
X/** Program that lists all the available aliases.  This one uses the pipe 
X    command, feeding the stuff to egrep then sort, or just sort.
X
X    (C) Copyright 1986, Dave Taylor
X**/
X
X#include <stdio.h>
X#include <fcntl.h>
X
X#include "defs.h"
X
X#define alias_hash	".alias_hash"
X#define alias_data	".alias_data"
X
X#ifdef BSD
X  FILE *popen();
X#endif
X
Xchar *getenv();
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	FILE *datafile, *fd_pipe;
X	struct alias_rec hash_record;
X	int hashfile, count = 0;
X	char buffer[LONG_SLEN], fd_hash[SLEN], 
X	     fd_data[SLEN], *home;
X
X	if (argc > 2) {
X	  printf("Usage: listalias <optional-regular-expression>\n");
X	  exit(1);
X	}
X
X	home = getenv("HOME");
X
X	sprintf(fd_hash, "%s/%s", home, alias_hash);
X	sprintf(fd_data, "%s/%s", home, alias_data);
X
X	if (argc > 1)
X	  sprintf(buffer, "egrep \"%s\" | sort", argv[1]);
X	else
X	  sprintf(buffer, "sort");
X
X	if ((fd_pipe = popen(buffer, "w")) == NULL) {
X	  if (argc > 1) 
X	    printf("cannot open pipe to egrep program for expressions!\n");
X	  fd_pipe = stdout;
X	}
X
X	do {
X
X	  if ((hashfile = open(fd_hash, O_RDONLY)) > 0) {
X	    if ((datafile = fopen(fd_data, "r")) == NULL) {
X	      fprintf("Opened %s hash file, but couldn't open data file!\n",
X		       count? "system" : "user");
X	      goto next_file;
X	    }
X	
X	    /** Otherwise let us continue... **/
X
X	    while (read(hashfile, &hash_record, sizeof (hash_record)) != 0) {
X	      if (strlen(hash_record.name) > 0) {
X	        fseek(datafile, hash_record.byte, 0L);
X	        fgets(buffer, LONG_SLEN, datafile);
X	        fprintf(fd_pipe, "%-15s  %s", hash_record.name, buffer);
X	      }
X	    }
X	  }
X
Xnext_file: strcpy(fd_hash, system_hash_file);
X	   strcpy(fd_data, system_data_file);
X
X	} while (++count < 2);
X
X	pclose(fd_pipe);
X
X	exit(0);
X}
END_OF_utils/listalias.c
if test 1786 -ne `wc -c <utils/listalias.c`; then
    echo shar: \"utils/listalias.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"utils/mailrc.awk\" \(930 characters\)
if test -f utils/mailrc.awk ; then 
  echo shar: Will not over-write existing file \"utils/mailrc.awk\"
else
sed "s/^X//" >utils/mailrc.awk <<'END_OF_utils/mailrc.awk'
XBEGIN { 
X	print "# MSG alias_text file, from a .mailrc file..." 
X	print ""
X      }
X
Xnext_line == 1 { 
X
X	next_line = 0;
X        group = ""
X	for (i = 1; i <= NF; i++) {
X	  if (i == NF && $i == "\\") sep = ""
X	  else                       sep = ", "
X	
X	  if ($i == "\\") {
X	    group = sprintf("%s,", group)
X	    next_line = 1;
X	  }
X	  else if (length(group) > 0)
X	    group = sprintf("%s%s%s", group, sep, $i);
X	  else
X	    group = $i;
X	  }
X	  print "\t" group
X
X	}
X
X$1 ~ /[Aa]lias|[Gg]roup/ { 
X
X	if ( NF == 3)
X	  print $2 " : user alias : " $3;
X	else {
X	  group = ""
X	  for (i = 3; i <= NF; i++) {
X	    if (i == NF && $i == "\\") sep = ""
X	    else        sep = ", "
X	
X	    if ($i == "\\") {
X 	      group = sprintf("%s,", group)
X 	      next_line = 1;
X	    }
X	    else if (length(group) > 0) 
X 	      group = sprintf("%s%s%s", group, sep, $i);
X	    else
X 	      group = $i;
X	    }
X	    print $2 " : group alias : " group;
X	  }
X 	}
END_OF_utils/mailrc.awk
if test 930 -ne `wc -c <utils/mailrc.awk`; then
    echo shar: \"utils/mailrc.awk\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"utils/trim-headers\" \(1201 characters\)
if test -f utils/trim-headers ; then 
  echo shar: Will not over-write existing file \"utils/trim-headers\"
else
sed "s/^X//" >utils/trim-headers <<'END_OF_utils/trim-headers'
X: Use /bin/sh
X
X# This shell script is designed to be used either to trim the 'junk' headers
X# out of an archived/saved mailbox file or to trim the headers off a file 
X# that is being piped to it.  The program considers the following headers
X# to be worth saving - everything else is junked.
X#
X#	From <user> <date>
X#	From: name <address>
X#	Subject:
X#	To: 
X#	Cc:
X#	Date:
X#
X# all others are ignored and trashed.
X#
X# (C) Copyright 1986, Dave Taylor
X
X# first off, let's make the 'awk' script we'll be using...
X
Xcat << 'END_OF_AWK_SCRIPT' > /tmp/awk.$$
XBEGIN { in_body = 1 }
X{	if (in_body) {
X	  if ($1 == "From") in_body = 0;
X	  print $0
X	}
X	else if ($1 == "From:" || $1 == "Subject:" || $1 == "To:" || \
X	         $1 == "Cc:" || $1 == "Date:")
X	  print $0
X	else if (length($0) == 0) {
X	  in_body = 1;
X	  print $0
X	}
X}
XEND_OF_AWK_SCRIPT
X
X# next let's see if we're being piped to or if we've been handed
X# either a file name or list of file names...
X
Xif [ "$1" = "" ]
Xthen
X  cat - | awk -f /tmp/awk.$$ | uniq
X  rm -f /tmp/awk.$$
Xelse
X  for filename in $*
X  do
X    echo filtering file $filename
X    cat $filename | awk -f /tmp/awk.$$ | uniq > OUTFILE
X    mv OUTFILE $filename
X  done
X  echo done
Xfi
X  
Xexit 0 
END_OF_utils/trim-headers
if test 1201 -ne `wc -c <utils/trim-headers`; then
    echo shar: \"utils/trim-headers\" unpacked with wrong size!?
fi
chmod +x utils/trim-headers
# end of overwriting check
fi
echo shar: End of archive 1 \(of 19\).
cp /dev/null ark1isdone
DONE=true
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	echo shar: You still need to run archive ${I}.
	DONE=false
    fi
done
if test "$DONE" = "true" ; then
	echo You have unpacked all 19 archives.
	echo "See the Instructions file"
	rm -f ark[1-9]isdone ark[1-9][0-9]isdone
fi
##  End of shell archive.
exit 0
