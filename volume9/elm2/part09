Subject:  v09i009:  ELM Mail System, Part09/19
Newsgroups: mod.sources
Approved: rs@mirror.TMC.COM

Submitted by: Dave Taylor <hplabs!taylor>
Mod.sources: Volume 9, Issue 9
Archive-name: elm2/Part09

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If this archive is complete, you will see the message:
#		"End of archive 9 (of 19)."
# Contents:  Makefile Makefile.mstr src/forms.c src/return_addr.c
#   src/save_opts.c
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"Makefile\" \(9596 characters\)
if test -f Makefile ; then 
  echo shar: Will not over-write existing file \"Makefile\"
else
sed "s/^X//" >Makefile <<'END_OF_Makefile'
X#
X#  Makefile for the entire ELM mail system
X#
X#         (C) Copyright 1986, Dave Taylor
X#
X#  Last modification: October 8th, 1986
X
XSHELL=/bin/sh
X
X#########################
X#
X# The following entries need to be customized for the local site:  
X#    The first is the address of the data-cassette drive to allow
X# easy tape copies to be made, and the second is the final location 
X# that all the software should be installed in when 'make install'
X# is run.
X#
X#########################
X
XTAPE=   /dev/rct 
XDEST=   /usr/local/bin
X
XLIB=    /usr/local/lib
XMAN=	/usr/man/man1
XCATMAN= /usr/man/cat1
XSHAR=   /usr/local/bin/shar -s 60000
X
XDEFINE = -DBSD
XLIB2   = -lcurses
X
X#########################
X
XLIBS=   -ltermcap
XCFLAGS= -O
XCC=	/bin/cc
XRM=	/bin/rm -f
XMV=     /bin/mv -f
XCP=	/bin/cp
X
X# if you want to use "nroff", change this...
X
XFORMATTER = /usr/bin/troff
XTBL       = cat
X
XDOCS=   Alias.guide Config.guide Elm.coversheet Filter.guide Ref.guide     \
X	Forms.guide Users.guide answer.1 autoreply.1 checkalias.1          \
X	elm.1 fastmail.1 filter.1 from.1 listalias.1 messages.1 newalias.1 \
X	newmail.1 printmail.1 readmsg.1 trim-headers.1 wnewmail.1
X
XUTILSRC= utils/answer.c utils/arepdaemon.c utils/autoreply.c           \
X	utils/fastmail.c utils/from.c utils/newalias.c \
X	utils/newmail.c utils/printmail.c utils/readmsg.c utils/wnewmail.c \
X	utils/trim-headers
X
XFILTSRC= filter/actions.c filter/filter.c filter/parse.c filter/rules.c     \
X	filter/summarize.c filter/utils.c
X
XELMSRC=	src/addr_utils.c src/alias.c src/aliasdb.c src/aliaslib.c src/args.c  \
X	src/bounceback.c src/builtin.c src/calendar.c src/connect_to.c	      \
X	src/curses.c src/date.c src/delete.c src/domains.c src/edit.c	      \
X	src/editmsg.c src/elm.c src/encode.c src/errno.c src/file.c	      \
X	src/file_utils.c src/fileio.c src/forms.c src/getopt.c src/hdrconfg.c \
X	src/help.c src/initialize.c src/input_utils.c src/leavembox.c	      \
X	src/limit.c src/mailmsg1.c src/mailmsg2.c src/mailtime.c src/mkhdrs.c \
X	src/newmbox.c src/opt_utils.c src/options.c src/output_utils.c        \
X	src/pattern.c src/pmalloc.c src/quit.c src/read_rc.c src/remail.c     \
X	src/reply.c src/return_addr.c src/save_opts.c src/savecopy.c          \
X	src/screen.c src/showmsg.c src/signals.c src/softkeys.c src/sort.c    \
X	src/string2.c src/strings.c src/syscall.c src/utils.c src/validname.c
X
XMISCHDRS  = hdrs/defs.h hdrs/sysdefs.h
XELMHDRS   = hdrs/headers.h 
XFILTHDRS  = hdrs/filter.h
XMAINHDRS  = hdrs/elm.h
X
X################
X
Xall:	bin/elm filter utils 
X	@echo Everything is up to date!
X
Xdocumentation:  doc/Users.fmtd doc/Ref.fmtd doc/Config.fmtd doc/Alias.fmtd \
X		doc/Form.fmtd doc/Filter.fmtd
X	
Xdoc/Users.fmtd: doc/Users.guide
X	${TBL} doc/Users.guide | ${FORMATTER} -mm > doc/Users.fmtd
X
Xdoc/Form.fmtd: doc/Form.guide
X	${FORMATTER} -mm doc/Form.guide > doc/Form.fmtd
X
Xdoc/Filter.fmtd: doc/Filter.guide
X	${FORMATTER} -mm doc/Filter.guide > doc/Filter.fmtd
X
Xdoc/Ref.fmtd: doc/Ref.guide
X	${FORMATTER} -mm doc/Ref.guide > doc/Ref.fmtd
X
Xdoc/Config.fmtd:  doc/Config.guide
X	${TBL} doc/Config.guide | ${FORMATTER} -mm > doc/Config.fmtd
X
Xdoc/Alias.fmtd:  doc/Alias.guide
X	${FORMATTER} -mm doc/Alias.guide > doc/Alias.fmtd
X
Xbin/elm: ${ELMSRC} ${MISCHDRS} ${ELMHDRS} ${MAINHDRS}
X	cd src;make 'DEFINE=${DEFINE}' 'LIB2=${LIB2}' ../bin/elm
X	
Xbin/utils: ${UTILSRC} ${MISCHHDRS}
X	cd utils; make 'DEFINE=${DEFINE}' 'LIBS=${LIB2}' all
X
Xbin/filter: ${FILTSRC} ${FILTHDR}
X	cd filter; make 'DEFINE=${DEFINE}' 'LIBS=${LIB2}' all
X
Xinstall: all
X	${CP} bin/elm          ${DEST}/elm
X	${CP} bin/from         ${DEST}/from
X	${CP} bin/newalias     ${DEST}/newalias
X	${CP} bin/printmail    ${DEST}/printmail
X	${CP} bin/fastmail     ${DEST}/fastmail
X	${CP} bin/readmsg      ${DEST}/readmsg
X	${CP} bin/newmail      ${DEST}/newmail
X	${CP} bin/wnewmail     ${DEST}/wnewmail
X	${CP} bin/checkalias   ${DEST}/checkalias
X	${CP} bin/messages     ${DEST}/messages
X	${CP} bin/trim-headers ${DEST}/trim-headers
X	${CP} bin/arepdaemon   ${DEST}/arepdaemon
X	${CP} bin/autoreply    ${DEST}/autoreply
X	${CP} bin/listalias    ${DEST}/listalias
X	${CP} bin/filter       ${DEST}/filter
X	${RM} ${CATMAN}/elm.1 ${CATMAN}/from.1 \
X	      ${CATMAN}/newalias.1 ${CATMAN}/printmail.1 \
X	      ${CATMAN}/fastmail.1 ${CATMAN}/elm.1 \
X	      ${CATMAN}/readmsg.1 ${CATMAN}/answer.1 \
X	      ${CATMAN}/newmail.1 ${CATMAN}/checkalias.1 \
X	      ${CATMAN}/autoreply.1 ${CATMAN}/wnewmail.1 \
X	      ${CATMAN}/messages.1 ${CATMAN}/trim-headers.1 \
X	      ${CATMAN}/listalias.1 ${CATMAN}/filter.1
X	${CP} doc/elm.1        ${MAN}/elm.1
X	${CP} doc/from.1       ${MAN}/from.1
X	${CP} doc/newalias.1   ${MAN}/newalias.1
X	${CP} doc/printmail.1  ${MAN}/printmail.1
X	${CP} doc/fastmail.1   ${MAN}/fastmail.1
X	${CP} doc/checkalias.1 ${MAN}/checkalias.1
X	${CP} doc/messages.1   ${MAN}/messages.1
X	${CP} doc/trim-headers.1 ${MAN}/trim-headers.1
X	${CP} doc/autoreply.1  ${MAN}/autoreply.1
X	${CP} doc/answer.1     ${MAN}/answer.1
X	${CP} doc/readmsg.1    ${MAN}/readmsg.1
X	${CP} doc/newmail.1    ${MAN}/newmail.1
X	${CP} doc/wnewmail.1   ${MAN}/wnewmail.1
X	${CP} doc/listalias.1  ${MAN}/listalias.1
X	${CP} doc/filter.1     ${MAN}/filter.1
X	${CP} doc/elm-help.?   ${LIB}
X	${CP} doc/elmrc-info   ${LIB}
X	chmod a+rx ${DEST}/from ${DEST}/newalias \
X		   ${DEST}/printmail ${DEST}/fastmail \
X		   ${DEST}/readmsg ${DEST}/trim-headers \
X		   ${DEST}/checkalias ${DEST}/autoreply \
X		   ${DEST}/newmail ${DEST}/wnewmail ${DEST}/messages \
X		   ${DEST}/listalias
X	chgrp mail ${DEST}/elm ${DEST}/filter
X	chmod 2755 ${DEST}/elm ${DEST}/filter
X	@echo Done with installation.
X
Xrmt-install: remote-defined
X	@echo " "
X	@echo Warning: This assumes "install" has been done on the
X	@echo "         remote machine.  If this is not the case you"
X	@echo "         better hit BREAK quickly!"
X	@echo " "
X	${CP} ${REMOTE}${DEST}/elm          ${DEST}/elm
X	${CP} ${REMOTE}${DEST}/from         ${DEST}/from
X	${CP} ${REMOTE}${DEST}/newalias     ${DEST}/newalias
X	${CP} ${REMOTE}${DEST}/printmail    ${DEST}/printmail
X	${CP} ${REMOTE}${DEST}/fastmail     ${DEST}/fastmail
X	${CP} ${REMOTE}${DEST}/readmsg      ${DEST}/readmsg
X	${CP} ${REMOTE}${DEST}/wnewmail     ${DEST}/wnewmail
X	${CP} ${REMOTE}${DEST}/newmail      ${DEST}/newmail
X	${CP} ${REMOTE}${DEST}/checkalias   ${DEST}/checkalias
X	${CP} ${REMOTE}${DEST}/messages     ${DEST}/messages
X	${CP} ${REMOTE}${DEST}/arepdaemon   ${DEST}/arepdaemon
X	${CP} ${REMOTE}${DEST}/autoreply    ${DEST}/autoreply
X	${CP} ${REMOTE}${DEST}/listalias    ${DEST}/listalias
X	${RM} ${CATMAN}/elm.1 \
X	      ${CATMAN}/from.1 \
X              ${CATMAN}/newalias.1 \
X	      ${CATMAN}/printmail.1 \
X	      ${CATMAN}/fastmail.1 \
X              ${CATMAN}/checkalias.1 \
X              ${CATMAN}/autoreply.1 \
X	      ${CATMAN}/readmsg.1 \
X	      ${CATMAN}/answer.1 \
X	      ${CATMAN}/newmail.1 \
X	      ${CATMAN}/wnewmail.1 \
X	      ${CATMAN}/listalias.1 \
X              ${CATMAN}/elm.1
X	${CP} ${REMOTE}${MAN}/elm.1        ${MAN}/elm.1
X	${CP} ${REMOTE}${MAN}/from.1       ${MAN}/from.1
X	${CP} ${REMOTE}${MAN}/newalias.1   ${MAN}/newalias.1
X	${CP} ${REMOTE}${MAN}/printmail.1  ${MAN}/printmail.1
X	${CP} ${REMOTE}${MAN}/fastmail.1   ${MAN}/fastmail.1
X	${CP} ${REMOTE}${MAN}/checkalias.1 ${MAN}/checkalias.1
X	${CP} ${REMOTE}${MAN}/autoreply.1  ${MAN}/autoreply.1
X	${CP} ${REMOTE}${MAN}/readmsg.1    ${MAN}/readmsg.1
X	${CP} ${REMOTE}${MAN}/answer.1     ${MAN}/answer.1
X	${CP} ${REMOTE}${MAN}/wnewmail.1   ${MAN}/wnewmail.1
X	${CP} ${REMOTE}${MAN}/newmail.1    ${MAN}/newmail.1
X	${CP} ${REMOTE}${MAN}/listalias.1  ${MAN}/listalias.1
X	${CP} ${REMOTE}${LIB}/elm-help.?   ${LIB}
X	${CP} ${REMOTE}${LIB}/elmrc-info   ${LIB}
X	chmod a+rx ${DEST}/from ${DEST}/newalias ${DEST}/printmail \
X	           ${DEST}/fastmail ${DEST}/readmsg \
X		   ${DEST}/checkalias ${DEST}/autoreply ${DEST}/wnewmail \
X		   ${DEST}/newmail ${DEST}/messages ${DEST}/listalias
X	chgrp mail ${DEST}/elm
X	chmod 2755 ${DEST}/elm
X	@echo everything is installed based on files from ${REMOTE}
X
Xsource: 
X	tar cvf ${TAPE} bin/makelisting utils/*.c src/*.c doc/* hdrs/* \
X	Instructions Makefile* utils/Makefile* src/Makefile* test/*    \
X	utils/*.awk Overview filter/*.c filter/Makefile*
X
X# Note that the production for SHAR assumes a pretty snazzy shar program
X# that can break down the output into a number of files as needed...
X#   The current threshold is 60,000 bytes per file, for email/netnews
X
Xshar:   
X	${SHAR} *
X
Xlint:
X	lint ${UTILSRC} > lint.out
X
Xlisting:
X	@echo listing all source files 
X	@/bin/echo \\f > LISTING
X	@echo adding file 'README'...
X	@cat README >> LISTING
X	@/bin/echo \\f >> LISTING
X	@echo adding file 'Instructions...
X	@cat Instructions >> LISTING
X	@/bin/echo \\f >> LISTING
X	@echo adding file 'Makefile'...
X	@cat Makefile >> LISTING
X	@bin/makelisting Makefile ${UTILSRC} src/Makefile src/*.c hdrs/*.h \
X	${FILTSRC}
X	@echo LISTING generated.
X
Xelm-listing: 
X	@echo listing just the ELM system source files
X	@echo ' ' > src/LISTING
X	@cd src ; make listing ; cd ..
X	@echo LISTING generated \(in directory /src\).
X
Xclean:
X	@cd src ; make clean 
X	@cd utils; make clean
X	@cd filter; make clean
X	@echo All spurious files removed
X
Xelm: bin/elm
Xfilter: bin/filter
Xutils: bin/utils
Xutils/checkalias:
Xutils/messages:
Xdoc/Users.guide:
Xdoc/Ref.guide:
Xdoc/Alias.guide:
Xdoc/Config.guide:
X
Xremote-defined:
X	@if ( "${REMOTE}" == "" ) then; \
X	   echo " " ; \
X	   echo "You need to define 'REMOTE' as the remote file system" ; \
X	   echo "for this particular command.   The easiest way to do " ; \
X	   echo "this is to type:" ;\
X	   echo "    make -f <makefile> REMOTE=<remote file system> rmt-install" ; \
X	   echo " " ; \
X	 endif
X	@if ( "${REMOTE}" == "" ) exit 1
END_OF_Makefile
if test 9596 -ne `wc -c <Makefile`; then
    echo shar: \"Makefile\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"Makefile.mstr\" \(9581 characters\)
if test -f Makefile.mstr ; then 
  echo shar: Will not over-write existing file \"Makefile.mstr\"
else
sed "s/^X//" >Makefile.mstr <<'END_OF_Makefile.mstr'
X#
X#  Makefile for the entire ELM mail system
X#
X#         (C) Copyright 1986, Dave Taylor
X#
X#  Last modification: October 8th, 1986
X
XSHELL=/bin/sh
X
X#########################
X#
X# The following entries need to be customized for the local site:  
X#    The first is the address of the data-cassette drive to allow
X# easy tape copies to be made, and the second is the final location 
X# that all the software should be installed in when 'make install'
X# is run.
X#
X#########################
X
XTAPE=   >tapeunit< 
XDEST=   >dest-dir<
X
XLIB=    /usr/local/lib
XMAN=	/usr/man/man1
XCATMAN= /usr/man/cat1
XSHAR=   /usr/local/bin/shar -s 60000
X
XDEFINE = >os-define<
XLIB2   = >lib2<
X
X#########################
X
XLIBS=   >libs<
XCFLAGS= -O
XCC=	>cc<
XRM=	>rm<
XMV=     >mv<
XCP=	>cp<
X
X# if you want to use "nroff", change this...
X
XFORMATTER = >troff<
XTBL       = >tbl<
X
XDOCS=   Alias.guide Config.guide Elm.coversheet Filter.guide Ref.guide     \
X	Forms.guide Users.guide answer.1 autoreply.1 checkalias.1          \
X	elm.1 fastmail.1 filter.1 from.1 listalias.1 messages.1 newalias.1 \
X	newmail.1 printmail.1 readmsg.1 trim-headers.1 wnewmail.1
X
XUTILSRC= utils/answer.c utils/arepdaemon.c utils/autoreply.c           \
X	utils/fastmail.c utils/from.c utils/newalias.c \
X	utils/newmail.c utils/printmail.c utils/readmsg.c utils/wnewmail.c \
X	utils/trim-headers
X
XFILTSRC= filter/actions.c filter/filter.c filter/parse.c filter/rules.c     \
X	filter/summarize.c filter/utils.c
X
XELMSRC=	src/addr_utils.c src/alias.c src/aliasdb.c src/aliaslib.c src/args.c  \
X	src/bounceback.c src/builtin.c src/calendar.c src/connect_to.c	      \
X	src/curses.c src/date.c src/delete.c src/domains.c src/edit.c	      \
X	src/editmsg.c src/elm.c src/encode.c src/errno.c src/file.c	      \
X	src/file_utils.c src/fileio.c src/forms.c src/getopt.c src/hdrconfg.c \
X	src/help.c src/initialize.c src/input_utils.c src/leavembox.c	      \
X	src/limit.c src/mailmsg1.c src/mailmsg2.c src/mailtime.c src/mkhdrs.c \
X	src/newmbox.c src/opt_utils.c src/options.c src/output_utils.c        \
X	src/pattern.c src/pmalloc.c src/quit.c src/read_rc.c src/remail.c     \
X	src/reply.c src/return_addr.c src/save_opts.c src/savecopy.c          \
X	src/screen.c src/showmsg.c src/signals.c src/softkeys.c src/sort.c    \
X	src/string2.c src/strings.c src/syscall.c src/utils.c src/validname.c
X
XMISCHDRS  = hdrs/defs.h hdrs/sysdefs.h
XELMHDRS   = hdrs/headers.h 
XFILTHDRS  = hdrs/filter.h
XMAINHDRS  = hdrs/elm.h
X
X################
X
Xall:	bin/elm filter utils 
X	@echo Everything is up to date!
X
Xdocumentation:  doc/Users.fmtd doc/Ref.fmtd doc/Config.fmtd doc/Alias.fmtd \
X		doc/Form.fmtd doc/Filter.fmtd
X	
Xdoc/Users.fmtd: doc/Users.guide
X	${TBL} doc/Users.guide | ${FORMATTER} -mm > doc/Users.fmtd
X
Xdoc/Form.fmtd: doc/Form.guide
X	${FORMATTER} -mm doc/Form.guide > doc/Form.fmtd
X
Xdoc/Filter.fmtd: doc/Filter.guide
X	${TBL} doc/Filter.guide | ${FORMATTER} -mm > doc/Filter.fmtd
X
Xdoc/Ref.fmtd: doc/Ref.guide
X	${FORMATTER} -mm doc/Ref.guide > doc/Ref.fmtd
X
Xdoc/Config.fmtd:  doc/Config.guide
X	${TBL} doc/Config.guide | ${FORMATTER} -mm > doc/Config.fmtd
X
Xdoc/Alias.fmtd:  doc/Alias.guide
X	${FORMATTER} -mm doc/Alias.guide > doc/Alias.fmtd
X
Xbin/elm: ${ELMSRC} ${MISCHDRS} ${ELMHDRS} ${MAINHDRS}
X	cd src;make 'DEFINE=${DEFINE}' 'LIB2=${LIB2}' ../bin/elm
X	
Xbin/utils: ${UTILSRC} ${MISCHHDRS}
X	cd utils; make 'DEFINE=${DEFINE}' 'LIBS=${LIB2}' all
X
Xbin/filter: ${FILTSRC} ${FILTHDR}
X	cd filter; make 'DEFINE=${DEFINE}' 'LIBS=${LIB2}' all
X
Xinstall: all
X	${CP} bin/elm          ${DEST}/elm
X	${CP} bin/from         ${DEST}/from
X	${CP} bin/newalias     ${DEST}/newalias
X	${CP} bin/printmail    ${DEST}/printmail
X	${CP} bin/fastmail     ${DEST}/fastmail
X	${CP} bin/readmsg      ${DEST}/readmsg
X	${CP} bin/newmail      ${DEST}/newmail
X	${CP} bin/wnewmail     ${DEST}/wnewmail
X	${CP} bin/checkalias   ${DEST}/checkalias
X	${CP} bin/messages     ${DEST}/messages
X	${CP} bin/trim-headers ${DEST}/trim-headers
X	${CP} bin/arepdaemon   ${DEST}/arepdaemon
X	${CP} bin/autoreply    ${DEST}/autoreply
X	${CP} bin/listalias    ${DEST}/listalias
X	${CP} bin/filter       ${DEST}/filter
X	${RM} ${CATMAN}/elm.1 ${CATMAN}/from.1 \
X	      ${CATMAN}/newalias.1 ${CATMAN}/printmail.1 \
X	      ${CATMAN}/fastmail.1 ${CATMAN}/elm.1 \
X	      ${CATMAN}/readmsg.1 ${CATMAN}/answer.1 \
X	      ${CATMAN}/newmail.1 ${CATMAN}/checkalias.1 \
X	      ${CATMAN}/autoreply.1 ${CATMAN}/wnewmail.1 \
X	      ${CATMAN}/messages.1 ${CATMAN}/trim-headers.1 \
X	      ${CATMAN}/listalias.1 ${CATMAN}/filter.1
X	${CP} doc/elm.1        ${MAN}/elm.1
X	${CP} doc/from.1       ${MAN}/from.1
X	${CP} doc/newalias.1   ${MAN}/newalias.1
X	${CP} doc/printmail.1  ${MAN}/printmail.1
X	${CP} doc/fastmail.1   ${MAN}/fastmail.1
X	${CP} doc/checkalias.1 ${MAN}/checkalias.1
X	${CP} doc/messages.1   ${MAN}/messages.1
X	${CP} doc/trim-headers.1 ${MAN}/trim-headers.1
X	${CP} doc/autoreply.1  ${MAN}/autoreply.1
X	${CP} doc/answer.1     ${MAN}/answer.1
X	${CP} doc/readmsg.1    ${MAN}/readmsg.1
X	${CP} doc/newmail.1    ${MAN}/newmail.1
X	${CP} doc/wnewmail.1   ${MAN}/wnewmail.1
X	${CP} doc/listalias.1  ${MAN}/listalias.1
X	${CP} doc/filter.1     ${MAN}/filter.1
X	${CP} doc/elm-help.?   ${LIB}
X	${CP} doc/elmrc-info   ${LIB}
X	chmod a+rx ${DEST}/from ${DEST}/newalias \
X		   ${DEST}/printmail ${DEST}/fastmail \
X		   ${DEST}/readmsg ${DEST}/trim-headers \
X		   ${DEST}/checkalias ${DEST}/autoreply \
X		   ${DEST}/newmail ${DEST}/wnewmail ${DEST}/messages \
X		   ${DEST}/listalias
X	chgrp mail ${DEST}/elm ${DEST}/filter
X	chmod 2755 ${DEST}/elm ${DEST}/filter
X	@echo Done with installation.
X
Xrmt-install: remote-defined
X	@echo " "
X	@echo Warning: This assumes "install" has been done on the
X	@echo "         remote machine.  If this is not the case you"
X	@echo "         better hit BREAK quickly!"
X	@echo " "
X	${CP} ${REMOTE}${DEST}/elm          ${DEST}/elm
X	${CP} ${REMOTE}${DEST}/from         ${DEST}/from
X	${CP} ${REMOTE}${DEST}/newalias     ${DEST}/newalias
X	${CP} ${REMOTE}${DEST}/printmail    ${DEST}/printmail
X	${CP} ${REMOTE}${DEST}/fastmail     ${DEST}/fastmail
X	${CP} ${REMOTE}${DEST}/readmsg      ${DEST}/readmsg
X	${CP} ${REMOTE}${DEST}/wnewmail     ${DEST}/wnewmail
X	${CP} ${REMOTE}${DEST}/newmail      ${DEST}/newmail
X	${CP} ${REMOTE}${DEST}/checkalias   ${DEST}/checkalias
X	${CP} ${REMOTE}${DEST}/messages     ${DEST}/messages
X	${CP} ${REMOTE}${DEST}/arepdaemon   ${DEST}/arepdaemon
X	${CP} ${REMOTE}${DEST}/autoreply    ${DEST}/autoreply
X	${CP} ${REMOTE}${DEST}/listalias    ${DEST}/listalias
X	${RM} ${CATMAN}/elm.1 \
X	      ${CATMAN}/from.1 \
X              ${CATMAN}/newalias.1 \
X	      ${CATMAN}/printmail.1 \
X	      ${CATMAN}/fastmail.1 \
X              ${CATMAN}/checkalias.1 \
X              ${CATMAN}/autoreply.1 \
X	      ${CATMAN}/readmsg.1 \
X	      ${CATMAN}/answer.1 \
X	      ${CATMAN}/newmail.1 \
X	      ${CATMAN}/wnewmail.1 \
X	      ${CATMAN}/listalias.1 \
X              ${CATMAN}/elm.1
X	${CP} ${REMOTE}${MAN}/elm.1        ${MAN}/elm.1
X	${CP} ${REMOTE}${MAN}/from.1       ${MAN}/from.1
X	${CP} ${REMOTE}${MAN}/newalias.1   ${MAN}/newalias.1
X	${CP} ${REMOTE}${MAN}/printmail.1  ${MAN}/printmail.1
X	${CP} ${REMOTE}${MAN}/fastmail.1   ${MAN}/fastmail.1
X	${CP} ${REMOTE}${MAN}/checkalias.1 ${MAN}/checkalias.1
X	${CP} ${REMOTE}${MAN}/autoreply.1  ${MAN}/autoreply.1
X	${CP} ${REMOTE}${MAN}/readmsg.1    ${MAN}/readmsg.1
X	${CP} ${REMOTE}${MAN}/answer.1     ${MAN}/answer.1
X	${CP} ${REMOTE}${MAN}/wnewmail.1   ${MAN}/wnewmail.1
X	${CP} ${REMOTE}${MAN}/newmail.1    ${MAN}/newmail.1
X	${CP} ${REMOTE}${MAN}/listalias.1  ${MAN}/listalias.1
X	${CP} ${REMOTE}${LIB}/elm-help.?   ${LIB}
X	${CP} ${REMOTE}${LIB}/elmrc-info   ${LIB}
X	chmod a+rx ${DEST}/from ${DEST}/newalias ${DEST}/printmail \
X	           ${DEST}/fastmail ${DEST}/readmsg \
X		   ${DEST}/checkalias ${DEST}/autoreply ${DEST}/wnewmail \
X		   ${DEST}/newmail ${DEST}/messages ${DEST}/listalias
X	chgrp mail ${DEST}/elm
X	chmod 2755 ${DEST}/elm
X	@echo everything is installed based on files from ${REMOTE}
X
Xsource: 
X	tar cvf ${TAPE} bin/makelisting utils/*.c src/*.c doc/* hdrs/* \
X	Instructions Makefile* utils/Makefile* src/Makefile* test/*    \
X	utils/*.awk Overview filter/*.c filter/Makefile*
X
X# Note that the production for SHAR assumes a pretty snazzy shar program
X# that can break down the output into a number of files as needed...
X#   The current threshold is 60,000 bytes per file, for email/netnews
X
Xshar:   
X	${SHAR} *
X
Xlint:
X	lint ${UTILSRC} > lint.out
X
Xlisting:
X	@echo listing all source files 
X	@/bin/echo \\f > LISTING
X	@echo adding file 'README'...
X	@cat README >> LISTING
X	@/bin/echo \\f >> LISTING
X	@echo adding file 'Instructions...
X	@cat Instructions >> LISTING
X	@/bin/echo \\f >> LISTING
X	@echo adding file 'Makefile'...
X	@cat Makefile >> LISTING
X	@bin/makelisting Makefile ${UTILSRC} src/Makefile src/*.c hdrs/*.h \
X	${FILTSRC}
X	@echo LISTING generated.
X
Xelm-listing: 
X	@echo listing just the ELM system source files
X	@echo ' ' > src/LISTING
X	@cd src ; make listing ; cd ..
X	@echo LISTING generated \(in directory /src\).
X
Xclean:
X	@cd src ; make clean 
X	@cd utils; make clean
X	@cd filter; make clean
X	@echo All spurious files removed
X
Xelm: bin/elm
Xfilter: bin/filter
Xutils: bin/utils
Xutils/checkalias:
Xutils/messages:
Xdoc/Users.guide:
Xdoc/Ref.guide:
Xdoc/Alias.guide:
Xdoc/Config.guide:
X
Xremote-defined:
X	@if ( "${REMOTE}" == "" ) then; \
X	   echo " " ; \
X	   echo "You need to define 'REMOTE' as the remote file system" ; \
X	   echo "for this particular command.   The easiest way to do " ; \
X	   echo "this is to type:" ;\
X	   echo "    make -f <makefile> REMOTE=<remote file system> rmt-install" ; \
X	   echo " " ; \
X	 endif
X	@if ( "${REMOTE}" == "" ) exit 1
END_OF_Makefile.mstr
if test 9581 -ne `wc -c <Makefile.mstr`; then
    echo shar: \"Makefile.mstr\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"src/forms.c\" \(9070 characters\)
if test -f src/forms.c ; then 
  echo shar: Will not over-write existing file \"src/forms.c\"
else
sed "s/^X//" >src/forms.c <<'END_OF_src/forms.c'
X/**				forms.c				**/
X
X/** This set of files supports the 'forms' options (AT&T Mail Forms) to
X    the mail system.  The specs are drawn from a document from AT&T entitled
X    "Standard for Exchanging Forms on AT&T Mail", version 1.9.
X
X    (C) Copyright 1986, Dave Taylor
X**/
X
X/** Some notes on the format of a FORM;
X
X	First off, in AT&T Mail parlance, this program only supports SIMPLE
X	forms, currently.  This means that while each form must have three
X 	sections;
X
X		[options-section]
X		***
X		[form-image]
X		***
X		[rules-section]
X
X	this program will ignore the first and third sections completely.  The
X	program will assume that the user merely enteres the form-image section,
X	and will append and prepend the triple asterisk sequences that *MUST*
X	be part of the message.  The messages are also expected to have a 
X	specific header - "Content-Type: mailform" - which will be added on all
X	outbound mail and checked on inbound...
X**/
X
X#include "headers.h"
X#include <errno.h>
X
Xextern int errno;
X
Xchar *error_name(), *strcat(), *strcpy();
X
Xcheck_form_file(filename)
Xchar *filename;
X{
X	/** This routine returns the number of fields in the specified file,
X	    or -1 if an error is encountered. **/
X
X	FILE *form;
X	char buffer[SLEN];
X	register int field_count = 0;
X
X	if ((form = fopen(filename, "r")) == NULL) {
X	  error2("Error %s trying to open %s to check fields!",
X		  error_name(errno), filename);
X	  return(-1);
X	}
X	
X	while (fgets(buffer, SLEN, form) != NULL) {
X	  field_count += occurances_of(COLON, buffer);
X	}
X
X	fclose(form);
X
X	return(field_count);
X}
X
Xformat_form(filename)
Xchar *filename;
X{
X	/** This routine accepts a validated file that is the middle 
X	    section of a form message and prepends and appends the appropriate 
X	    instructions.  It's pretty simple. 
X	    This returns the number of forms in the file, or -1 on errors
X	**/
X	
X	FILE *form, *newform;
X	char  newfname[SLEN], buffer[SLEN];
X	register form_count = 0;
X
X	dprint1(4, "Formatting form file '%s'\n", filename);
X
X	/** first off, let's open the files... **/
X
X	if ((form = fopen(filename, "r")) == NULL) {
X	  error("Can't read the message to validate the form!");
X	  dprint2(1,
X              "** Error encountered opening file \"%s\" - %s (check_form) **\n",
X	      filename, error_name(errno));
X	  return(-1);
X	}
X
X	sprintf(newfname, "%s%d", temp_form_file, getpid());
X
X	if ((newform = fopen(newfname, "w")) == NULL) {
X	  error("Couldn't open newform file for form output!");
X	  dprint2(1,
X              "** Error encountered opening file \"%s\" - %s (check_form) **\n",
X	      newfname, error_name(errno));
X	  return(-1);
X	}
X
X	/** the required header... **/
X
X	/* these are actually the defaults, but let's be sure, okay? */
X
X	fprintf(newform, "WIDTH=78\nTYPE=SIMPLE\nOUTPUT=TEXT\n***\n");
X
X	/** and let's have some fun transfering the stuff across... **/
X
X	while (fgets(buffer, SLEN, form) != NULL) {
X	  fputs(buffer, newform);
X	  form_count += occurances_of(COLON, buffer);
X	}
X
X	fprintf(newform, "***\n");	/* that closing bit! */
X
X	fclose(form);
X	fclose(newform);
X
X	if (form_count > 0) {
X	  if (unlink(filename) != 0) {
X	    error2("Error %s unlinking file %s", error_name(errno), filename);
X	    return(-1);
X	  }
X	  if (link(newfname, filename)) {
X	    error3("Error %s linking %s to %s", error_name(errno), 
X		    newfname, filename);
X	    return(-1);
X	  }
X	}
X
X	if (unlink(newfname)) {
X	  error2("Error %s unlinking file %s", error_name(errno), newfname);
X	  return(-1);	
X	}
X
X	return(form_count);
X}
X
Xint
Xmail_filled_in_form(address, subject)
Xchar *address, *subject;
X{
X	/** This is the interesting routine.  This one will read the
X	    message and prompt the user, line by line, for each of
X	    the fields...returns non-zero if it succeeds
X	**/
X
X	FILE  	     *fd;
X	register int lines = 0, count;
X	char         buffer[SLEN], *ptr;
X
X	dprint2(4, "replying to form with;\n\taddress=%s and\n\t subject=%s\n",
X		   address, subject);
X
X        if (fseek(mailfile, header_table[current-1].offset, 0) == -1) {
X	  dprint3(1,"Error: seek %ld resulted in errno %s (%s)\n", 
X		   header_table[current-1].offset, error_name(errno), 
X		   "mail_filled_in_form");
X	  error2("ELM [seek] couldn't read %d bytes into file (%s)",
X	         header_table[current-1].offset, error_name(errno));
X	  return(0);
X        }
X 
X	/* now we can fly along and get to the message body... */
X
X	while ((ptr = fgets(buffer, SLEN, mailfile)) != NULL) {
X	  if (strlen(buffer) == 1)	/* <return> only */
X	    break;
X	  else if (strncmp(buffer,"From ", 5) == 0 && lines++ > 0) {
X	    error("No form in this message!?");
X	    return(0);
X	  }
X	}
X
X	if (ptr == NULL) {
X	  error("No form in this message!?");
X	  return(0);
X	}
X
X	dprint0(6,"- past header of form message -\n");
X	
X	/* at this point we're at the beginning of the body of the message */
X
X	/* now we can skip to the FORM-IMAGE section by reading through a 
X	   line with a triple asterisk... */
X
X	while ((ptr = fgets(buffer, SLEN, mailfile)) != NULL) {
X	  if (strcmp(buffer, "***\n") == 0)
X	    break;	/* we GOT it!  It's a miracle! */	
X	  else if (strncmp(buffer, "From ",5) == 0) {
X	    error("Badly constructed form.  Can't reply!");
X	    return(0);
X	  }
X	}
X
X	if (ptr == NULL) {
X	  error("Badly constructed form.  Can't reply!");
X	  return(0);
X	}
X
X	dprint0(6,"- skipped the non-forms-image stuff -\n");
X	
X	/* one last thing - let's open the tempfile for output... */
X	
X	sprintf(buffer, "%s%d", temp_form_file, getpid());
X
X	dprint1(2,"-- forms sending using file %s --\n", buffer);
X
X	if ((fd = fopen(buffer,"w")) == NULL) {
X	  error2("Can't open \"%s\" as output file! (%s)", buffer,
X		 error_name(errno));
X	  dprint2(1,"** Error %s encountered trying to open temp file %s;\n",
X		  error_name(errno), buffer);
X	  return(0);
X	}
X
X	/* NOW we're ready to read the form image in and start prompting... */
X
X	Raw(OFF);
X	ClearScreen();
X
X	while ((ptr = fgets(buffer, SLEN, mailfile)) != NULL) {
X	  dprint1(9,"- read %s", buffer);
X	  if (strcmp(buffer, "***\n") == 0) /* end of form! */
X	    break;
X	 
X	  switch ((count = occurances_of(COLON, buffer))) {
X	    case 0 : printf("%s", buffer);		/* output line */
X		     fprintf(fd, "%s", buffer); 	
X		     break;
X            case 1 : if (buffer[0] == COLON) {
X	             printf(
X"(Enter as many lines as needed, ending with a '.' by itself on a line)\n");
X                     while (gets(buffer) != NULL)
X	               if (strcmp(buffer, ".") == 0)
X	                 break;
X	               else 
X			 fprintf(fd,"%s\n", buffer);
X	             }
X	             else 
X		      prompt_for_entry(buffer, fd);
X	             break;
X            default: prompt_for_multiple_entries(buffer, fd, count);
X	  }
X	}
X
X	Raw(ON);
X	fclose(fd);
X
X	/** let's just mail this off now... **/
X
X	mail_form(address, subject);
X
X	return(1);
X}
X
Xprompt_for_entry(buffer, fd)
Xchar *buffer;
XFILE *fd;
X{
X	/** This is called with an entry of the form "prompt:" and will 
X	    display the prompt and save the prompt and the user reply
X	    in the file "fd"
X	**/
X	
X	char mybuffer[SLEN];
X
X	no_ret(buffer);
X
X	dprint1(7, "prompt-for-entry \"%s\"\n", buffer);
X
X	printf("%s ", buffer);	fflush(stdout);
X
X	gets(mybuffer);
X
X	fprintf(fd, "%s: %s", buffer, mybuffer);
X}
X
Xprompt_for_multiple_entries(buffer, fd, entries)
Xchar *buffer;
XFILE *fd;
Xint  entries;
X{
X	/** Almost the same as the above routine, this one deals with lines
X	    that have multiple colons on them.  It must first figure out how
X	    many spaces to allocate for each field then prompts the user, 
X	    line by line, for the entries...
X	**/
X
X	char mybuffer[SLEN], prompt[SLEN], spaces[SLEN];
X	register int  field_size, i, j, offset = 0, extra_tabs = 0;
X
X	dprint2(7, "prompt-for-multiple [%d] -entries \"%s\"\n", entries,
X		buffer);
X
X	strcpy(prompt, "No Prompt Available:");
X
X	while (entries--) {
X	  j=0; 
X	  i = chloc((char *) buffer + offset, COLON) + 1;
X	  while (j < i - 1) {
X	    prompt[j] = buffer[j+offset];
X	    j++;
X	  }
X	  prompt[j] = '\0';
X
X	  field_size = 0;
X
X	  while (whitespace(buffer[i+offset])) {
X	    if (buffer[i+offset] == TAB) {
X	      field_size += 8 - (i % 8);
X	      extra_tabs += (8 - (i % 8)) - 1;
X	    }
X	    else
X	      field_size += 1;
X	    i++;
X	  }
X
X	  offset += i;
X	
X	  if (field_size == 0) 	/* probably last prompt in line... */
X	    field_size = 80 - (offset + extra_tabs);
X
X	  prompt_for_sized_entry(prompt, mybuffer, field_size);
X
X	  spaces[0] = ' ';	/* always at least ONE trailing space... */
X	  spaces[1] = '\0';
X
X	  for (j = strlen(mybuffer); j < field_size; j++)
X	    strcat(spaces, " ");
X
X	  fprintf(fd, "%s: %s%s", prompt, mybuffer, spaces);
X	  fflush(fd);
X	}
X
X	fprintf(fd, "\n");
X}
X
Xprompt_for_sized_entry(prompt, buffer, field_size)
Xchar *prompt, *buffer;
Xint   field_size;
X{
X	/* This routine prompts for an entry of the size specified. */
X
X	register int i;
X
X	dprint2(7, "prompt-for-sized-entry \"%s\" %d chars\n", 
X		prompt, field_size);
X
X	printf("%s : ", prompt);
X	
X	for (i=0;i<field_size; i++)
X	  putchar('_');
X	for (i=0;i<field_size; i++)
X	  putchar(BACKSPACE);
X	fflush(stdout);
X
X	gets(buffer);
X
X	if (strlen(buffer) > field_size) buffer[field_size-1] = '\0';
X}
END_OF_src/forms.c
if test 9070 -ne `wc -c <src/forms.c`; then
    echo shar: \"src/forms.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"src/return_addr.c\" \(9579 characters\)
if test -f src/return_addr.c ; then 
  echo shar: Will not over-write existing file \"src/return_addr.c\"
else
sed "s/^X//" >src/return_addr.c <<'END_OF_src/return_addr.c'
X/**			return_addr.c			**/
X
X/** This set of routines is used to generate real return addresses
X    and also return addresses suitable for inclusion in a users
X    alias files (ie optimized based on the pathalias database).
X
X    Added: the ability to respond to messages that were originally
X    sent by the user (That is, the "savemail" file format messages)
X    by reading the return address, seeing the "To:" prefix and then
X    calling the "get_existing_return()" routine.  Currently this does
X    NOT include any "Cc" lines in the message, just the "To:" line(s).
X
X    Also added the PREFER_UUCP stuff for listing reasonable addresses
X    and such...*sigh*
X
X    These routines (C) Copyright 1986 Dave Taylor
X**/
X
X#include "headers.h"
X
X#include <errno.h>
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
Xchar *shift_lower();
X
Xextern int errno;
X
Xchar *error_name(), *strcat(), *strcpy();
X
X#ifndef DONT_OPTIMIZE_RETURN
X
Xoptimize_return(address)
Xchar *address;
X{
X	/** This routine tries to create an optimized address, that is,
X	    an address that has the minimal information needed to 
X	    route a message to this person given the current path
X	    database...
X	**/
X
X#ifdef PREFER_UUCP
X
X	/** first off, let's see if we need to strip off the localhost
X	    address crap... **/
X
X	/** if we have a uucp part (e.g.a!b) AND the bogus address...**/
X
X	if (chloc(address,'!') != -1 && in_string(address, BOGUS_INTERNET))
X	  address[strlen(address)-strlen(BOGUS_INTERNET)] = '\0';
X#endif
X
X	/** next step is to figure out what sort of address we have... **/
X
X	if (chloc(address, '%') != -1)
X	  optimize_cmplx_arpa(address);
X	else if (chloc(address, '@') != -1)
X	  optimize_arpa(address);
X	else
X	  optimize_usenet(address);
X}
X
Xoptimize_cmplx_arpa(address)
Xchar *address;
X{
X	/** Try to optimize a complex ARPA address.  A Complex address is one 
X	    that contains '%' (deferred '@').  For example:  
X		veeger!hpcnof!hplabs!joe%sytech@syte  
X	    is a complex address (no kidding, right?).  The algorithm for 
X	    trying to resolve it is to move all the way to the right, then 
X	    back up left until the first '!' then from there to the SECOND 
X	    metacharacter on the right is the name@host address...(in this 
X            example, it would be "joe%sytech").  Check this in the routing
X	    table.  If not present, keep backing out to the right until we
X	    find a host that is present, or we hit the '@' sign.  Once we
X	    have a 'normal' ARPA address, hand it to optimize_arpa().
X	**/
X
X	char name[SHORT_SLEN], buffer[SLEN], junk[SLEN];
X	char host[SHORT_SLEN], old_host[SHORT_SLEN];
X	register int i, loc, nloc = 0, hloc = 0, passes = 1;
X
X	/** first off, get the name%host... **/
X
X	for (loc = strlen(address)-1; address[loc] != '!' && loc > -1; loc--)
X	   ;
X
X	while (address[loc] != '\0') {
X
X	  if (passes == 1) {
X	    loc++;
X
X	    while (address[loc] != '%' && address[loc] != '@')
X	      name[nloc++] = address[loc++];
X	  }
X	  else {
X	    for (i=0; old_host[i] != '\0'; i++)
X	      name[nloc++] = old_host[i];
X	  }
X
X	  loc++;
X  
X	  while (address[loc] != '%' && address[loc] != '@')
X	    host[hloc++] = address[loc++];
X  
X	  host[hloc] = name[nloc] = '\0';
X
X	  strcpy(old_host, host);
X	  remove_domains(host);
X
X	  sprintf(buffer, "%s@%s", name, shift_lower(host));
X
X	  if (expand_site(buffer, junk) == 0) {
X	    strcpy(address, buffer);
X	    return;
X	  }
X	  else if (address[loc] == '@') {
X	    optimize_arpa(address);
X	    return;
X	  }
X	  else
X	    name[nloc++] = '%';	/* for next pass through */
X
X	}
X}
X
Xoptimize_arpa(address)
Xchar *address;
X{
X	/** Get an arpa address and simplify it to the minimal
X	    route needed to get mail to this person... **/
X
X	char name[SHORT_SLEN], buffer[SLEN], junk[SLEN];
X	char host[SHORT_SLEN];
X	register int loc, nloc = 0, hloc = 0, at_sign = 0;
X
X	for (loc = strlen(address)-1; address[loc] != '!' && loc > -1; loc--) {
X	  if (address[loc] == '@')
X	     at_sign++;	/* remember this spot! */
X	  else if (at_sign)
X	    name[nloc++] = address[loc];
X	  else
X	    host[hloc++] = address[loc];
X	}
X
X	name[nloc] = host[hloc] = '\0';
X
X	reverse(name);
X	reverse(host);
X
X	remove_domains(host);
X
X	sprintf(buffer,"%s@%s", name, shift_lower(host));
X
X	if (expand_site(buffer, junk) == 0) {
X	  strcpy(address, buffer);
X	  return;
X	}
X
X	optimize_usenet(address);	/* that didn't work... */
X}
X	
Xoptimize_usenet(address)
Xchar *address;
X{
X	/** optimize the return address IFF it's a standard usenet
X	    address...
X	**/
X
X	char name[SHORT_SLEN],  new_address[SLEN], buffer[SLEN], junk[SLEN];
X	register int loc, nloc = 0, aloc = 0, passes = 1;
X
X	for (loc = strlen(address)-1; address[loc] != '!' && loc > -1; loc--) 
X	  name[nloc++] = address[loc];
X	name[nloc] = '\0';
X
X	reverse(name);
X
X	new_address[0] = '\0';	
X
X	/* got name, now get machine until we can get outta here */
X
X	while (loc > -1) {
X
X	  new_address[aloc++] = address[loc--];	/* the '!' char */
X
X	  while (address[loc] != '!' && loc > -1)
X	    new_address[aloc++] = address[loc--];
X
X	  new_address[aloc] = '\0';
X
X	  strcpy(buffer, new_address);
X	  reverse(buffer);
X	
X	  if (expand_site(buffer, junk) == 0) {
X	    if (passes == 1 && chloc(name, '@') == -1) {
X	      buffer[strlen(buffer) - 1] = '\0';	/* remove '!' */
X	      sprintf(address, "%s@%s", name, buffer);
X	    }
X	    else 
X	      sprintf(address, "%s%s", buffer, name);
X	    return;		/* success! */
X	  }
X	  passes++;
X	}
X
X	return;		/* nothing to do! */
X}
X
X#endif	not DONT_OPTIMIZE_RETURN
X
Xget_return(buffer)
Xchar *buffer;
X{
X	/** reads 'current' message again, building up the full return 
X	    address including all machines that might have forwarded 
X	    the message.  **/
X
X    char buf[LONG_SLEN], name1[SLEN], name2[SLEN], lastname[SLEN];
X    char hold_return[LONG_SLEN], alt_name2[SLEN];
X    int ok = 1, lines;
X
X    /* now initialize all the char buffers [thanks Keith!] */
X
X    buf[0] = name1[0] = name2[0] = lastname[0] = '\0';
X    hold_return[0] = alt_name2[0] = '\0';
X
X    /** get to the first line of the message desired **/
X
X    if (fseek(mailfile, header_table[current-1].offset, 0) == -1) {
X	dprint3(1,"Error: seek %ld bytes into file hit errno %s (%s)", 
X		header_table[current-1].offset, error_name(errno), 
X	        "get_return");
X	error2("couldn't seek %d bytes into file (%s)",
X	       header_table[current-1].offset, error_name(errno));
X	return;
X    }
X 
X    /** okay!  Now we're there!  **/
X
X    lines = header_table[current-1].lines;
X    
X    buffer[0] = '\0';
X
X    while (ok && lines--) {
X      ok = (int) (fgets(buf, LONG_SLEN, mailfile) != NULL);
X      if (first_word(buf, "From ")) {
X	sscanf(buf, "%*s %s", hold_return);
X      }
X      else if (first_word(buf, ">From")) {
X	sscanf(buf,"%*s %s %*s %*s %*s %*s %*s %*s %*s %s %s", 
X	       name1, name2, alt_name2);
X	if (strcmp(name2, "from") == 0)
X	  strcpy(name2, alt_name2);
X	add_site(buffer, name2, lastname);
X      }
X
X#ifdef USE_EMBEDDED_ADDRESSES
X
X      else if (first_word(buf, "From:")) {
X	get_address_from("From:", buf, hold_return);
X      }
X      else if (first_word(buf, "Reply-To:")) {
X	get_address_from("Reply-To:", buf, buffer);
X	return;
X      }
X
X#endif
X
X      else if (strlen(buf) < 2)	/* done with header */
X         lines = 0; /* let's get outta here!  We're done!!! */
X     }
X
X    if (buffer[0] == '\0')
X      strcpy(buffer, hold_return); /* default address! */
X    else
X      add_site(buffer, name1, lastname);	/* get the user name too! */
X
X    if (first_word(buffer, "To:")) 		/* response to savecopy!  */
X       get_existing_address(buffer);
X    else 
X       /* if we have a space character, or we DON'T have '!' or '@' chars */
X
X       if (chloc(header_table[current-1].from, ' ') >= 0 ||
X	   (chloc(header_table[current-1].from, '!') < 0 &&
X	    chloc(header_table[current-1].from, '@') < 0)) {
X
X	 sprintf(name2, " (%s)", header_table[current-1].from);
X	 strcat(buffer, name2);
X       }
X
X}
X
Xget_existing_address(buffer)
Xchar *buffer;
X{
X	/** This routine is called when the message being responded to has
X	    "To:xyz" as the return address, signifying that this message is
X	    an automatically saved copy of a message previously sent.  The
X	    correct to address can be obtained fairly simply by reading the
X	    To: header from the message itself and (blindly) copying it to
X	    the given buffer.  Note that this header can be either a normal
X	    "To:" line (Elm) or "Originally-To:" (previous versions e.g.Msg)
X	**/
X
X	char mybuf[LONG_STRING];
X	register char ok = 1, in_to = 0;
X
X	buffer[0] = '\0';
X
X	/** first off, let's get to the beginning of the message... **/
X
X        if (fseek(mailfile, header_table[current-1].offset, 0) == -1) {
X	    dprint3(1,"Error: seek %ld bytes into file hit errno %s (%s)", 
X		    header_table[current-1].offset, error_name(errno), 
X		    "get_existing_address");
X	    error2("couldn't seek %d bytes into the file (%s)",
X	           header_table[current-1].offset, error_name(errno));
X	    return;
X        }
X 
X        /** okay!  Now we're there!  **/
X
X        while (ok) {
X          ok = (int) (fgets(mybuf, LONG_STRING, mailfile) != NULL);
X	  no_ret(mybuf);	/* remove return character */
X
X          if (first_word(mybuf, "To: ")) {
X	    in_to = TRUE;
X	    strcpy(buffer, (char *) mybuf + strlen("To: "));
X          }
X	  else if (first_word(mybuf, "Original-To:")) {
X	    in_to = TRUE;
X	    strcpy(buffer, (char *) mybuf + strlen("Original-To:"));
X	  }
X	  else if (in_to && whitespace(mybuf[0])) {
X	    strcat(buffer, " ");		/* tag a space in   */
X	    strcat(buffer, (char *) mybuf + 1);	/* skip 1 whitespace */
X	  }
X	  else if (strlen(mybuf) < 2)
X	    return;				/* we're done for!  */
X	  else
X	    in_to = 0;
X      }
X}
END_OF_src/return_addr.c
if test 9579 -ne `wc -c <src/return_addr.c`; then
    echo shar: \"src/return_addr.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"src/save_opts.c\" \(9187 characters\)
if test -f src/save_opts.c ; then 
  echo shar: Will not over-write existing file \"src/save_opts.c\"
else
sed "s/^X//" >src/save_opts.c <<'END_OF_src/save_opts.c'
X/**			save_opts.c			**/
X
X/** This file contains the routine needed to allow the users to change the
X    Elm parameters and then save the configuration in a ".elmrc" file in
X    their home directory.  With any luck this will allow them never to have
X    to actually EDIT the file!!
X
X    (C) Copyright 1986, Dave Taylor
X**/
X
X#include "headers.h"
X#include <errno.h>
X
X#undef onoff
X#define   onoff(n)	(n == 1? "ON":"OFF")
X
X#define absolute(x)		((x) < 0? -(x) : (x))
X
Xextern  int errno;
X
Xchar *error_name(), *nameof(), *sort_name();
Xlong  ftell();
X
X#include "save_opts.h"
X
XFILE *elminfo;		/* informational file as needed... */
X
Xsave_options()
X{
X	/** Save the options currently specified to a file.  This is a
X	    fairly complex routine since it tries to put in meaningful
X	    comments and such as it goes along.  The comments are
X	    extracted from the file ELMRC_INFO as defined in the sysdefs.h
X	    file.  THAT file has the format;
X
X		varname
X		  <comment>
X		  <comment>
X		<blank line>
X
X	    and each comment is written ABOVE the variable to be added.  This
X	    program also tries to make 'pretty' stuff like the alternatives
X	    and such.
X	**/
X
X	FILE *newelmrc; 
X	char  oldfname[SLEN], newfname[SLEN];
X
X	sprintf(newfname, "%s/%s", home, elmrcfile);
X	sprintf(oldfname, "%s/.old%s", home, elmrcfile);
X
X	/** first off, let's see if they already HAVE a .elmrc file **/
X
X	if (access(newfname, ACCESS_EXISTS) != -1) {
X	  /** YES!  Copy it to the file ".old.elmrc".. **/
X	  (void) unlink(oldfname);
X	  (void) link(newfname, oldfname);
X          (void) unlink(newfname);
X	  (void) chown(oldfname, userid, groupid);
X	}
X
X	/** now let's open the datafile if we can... **/
X
X	if ((elminfo = fopen(ELMRC_INFO, "r")) == NULL) 
X	  error1("Warning: saving without comments - can't get to %s", 
X		  ELMRC_INFO);
X
X	/** next, open the new .elmrc file... **/
X
X	if ((newelmrc = fopen(newfname, "w")) == NULL) {
X	   error2("Can't save configuration: can't write to %s [%s]",
X		   newfname, error_name(errno));
X	   return;
X	}
X	
X	save_user_options(elminfo, newelmrc);
X
X	error1("Options saved in file %s", newfname);
X}
X
Xsave_user_options(elminfo_fd, newelmrc)
XFILE *elminfo_fd, *newelmrc;
X{
X	/** save the information in the file.  If elminfo_fd == NULL don't look
X	    for comments!
X	**/
X
X	if (elminfo_fd != NULL) 
X	  build_offset_table(elminfo_fd);
X
X	fprintf(newelmrc, 	
X	          "#\n# .elmrc - options file for the Elm mail system\n#\n");
X
X	if (strlen(full_username) > 0)
X	  fprintf(newelmrc, "# Saved automatically by Elm %s for %s\n#\n\n",
X		  VERSION, full_username);
X	else
X	  fprintf(newelmrc, "# Saved automatically by Elm %s\n#\n\n", VERSION);
X
X	save_option_string(CALENDAR, calendar_file, newelmrc, FALSE);
X	save_option_string(EDITOR, editor, newelmrc, FALSE);
X	save_option_string(FULLNAME, full_username, newelmrc, FALSE);
X	save_option_string(MAILBOX, nameof(mailbox), newelmrc, FALSE);
X	save_option_string(MAILDIR, folders, newelmrc, FALSE);
X	save_option_string(PAGER, pager, newelmrc, FALSE);
X	save_option_string(PREFIX, prefixchars, newelmrc, TRUE);
X	save_option_string(PRINT, printout, newelmrc, FALSE);
X	save_option_string(SAVEMAIL, savefile, newelmrc, FALSE);
X	save_option_string(SHELL, shell, newelmrc, FALSE);
X
X	save_option_string(LOCALSIGNATURE, local_signature, newelmrc, FALSE);
X	save_option_string(REMOTESIGNATURE, remote_signature, newelmrc, FALSE);
X
X	save_option_sort(SORTBY, sortby, newelmrc);
X
X	save_option_on_off(ALWAYSDELETE, always_del, newelmrc);
X	save_option_on_off(ALWAYSLEAVE, always_leave, newelmrc);
X	save_option_on_off(ARROW, arrow_cursor, newelmrc);
X	save_option_on_off(AUTOCOPY, auto_copy, newelmrc);
X
X	save_option_number(BOUNCEBACK, bounceback, newelmrc);
X
X	save_option_on_off(COPY, auto_cc, newelmrc);
X/**	save_option_on_off(EDITOUT, edit_outbound, newelmrc);		     **/
X	save_option_on_off(FORMS, allow_forms, newelmrc);
X	save_option_on_off(KEYPAD, hp_terminal, newelmrc);
X	save_option_on_off(MENU, mini_menu, newelmrc);
X	save_option_on_off(MOVEPAGE, move_when_paged, newelmrc);
X	save_option_on_off(NAMES, names_only, newelmrc);
X	save_option_on_off(NOHEADER, noheader, newelmrc);
X	save_option_on_off(POINTNEW, point_to_new, newelmrc);
X	save_option_on_off(RESOLVE, resolve_mode, newelmrc);
X	save_option_on_off(SAVENAME, save_by_name, newelmrc);
X	save_option_on_off(SOFTKEYS, hp_softkeys, newelmrc);
X
X	save_option_number(TIMEOUT, timeout, newelmrc);
X
X	save_option_on_off(TITLES, title_messages, newelmrc);
X
X	save_option_number(USERLEVEL, user_level, newelmrc);
X
X	save_option_on_off(WARNINGS, warnings, newelmrc);
X	save_option_on_off(WEED, filter, newelmrc);
X
X	save_option_weedlist(WEEDOUT, weedlist, newelmrc);
X	save_option_alternatives(ALTERNATIVES, alternative_addresses, newelmrc);
X
X	fflush(elminfo_fd);	/* make sure we're clear... */
X	fclose(elminfo_fd);
X}
X
Xsave_option_string(index, value, fd, underscores)
Xint index, underscores;
Xchar *value;
XFILE *fd;
X{
X	/** Save a string option to the file... only subtlety is when we
X	    save strings with spaces in 'em - translate to underscores!
X	**/
X
X	register int i;
X	char     buffer[SLEN];
X	
X	if (strlen(value) == 0) return;		/* why bother? */
X
X	add_comment(index, fd);
X	
X	strcpy(buffer, value);
X
X	if (underscores)
X	  for (i=0; i < strlen(buffer); i++)
X	    if (buffer[i] == SPACE) buffer[i] = '_';
X
X	fprintf(fd, "%s = %s\n\n", save_info[index].name, buffer);
X}
X	   
Xsave_option_sort(index, value, fd)
Xint index;
Xchar *value;
XFILE *fd;
X{
X	/** save the current sorting option to a file **/
X
X	add_comment(index, fd);
X
X	fprintf(fd, "%s = %s\n\n", save_info[index].name,
X		sort_name(SHORT));
X}
X
Xsave_option_number(index, value, fd)
Xint index, value;
XFILE *fd;
X{
X	/** Save a binary option to the file - boy is THIS easy!! **/
X
X	add_comment(index, fd);
X	
X	fprintf(fd, "%s = %d\n\n", save_info[index].name, value);
X}
X
Xsave_option_on_off(index, value, fd)
Xint index, value;
XFILE *fd;
X{
X	/** Save a binary option to the file - boy is THIS easy!! **/
X
X	add_comment(index, fd);
X	
X	fprintf(fd, "%s = %s\n\n", save_info[index].name, onoff(value));
X}
X
Xsave_option_weedlist(index, list, fd)
Xint index;
Xchar *list[];
XFILE *fd;
X{
X	/** save a list of weedout headers to the file **/
X
X	int length_so_far = 0, i;
X
X	add_comment(index, fd);
X
X	length_so_far = strlen(save_info[index].name) + 4;
X
X	fprintf(fd, "%s = ", save_info[index].name);
X
X	/** first off, skip till we get past the default list **/
X
X	for (i = 0; i < weedcount; i++) 
X	  if (strcmp(weedlist[i],"*end-of-defaults*") == 0)
X	    break;
X
X	while (i < weedcount) {
X	  if (strlen(weedlist[i]) + length_so_far > 78) {
X	    fprintf(fd, "\n\t");
X	    length_so_far = 8;
X	  }
X	  fprintf(fd, "\"%s\" ", weedlist[i]);
X	  length_so_far += (strlen(weedlist[i]) + 4);
X	  i++;
X	}
X	fprintf(fd, "\n\n");
X}
X
Xsave_option_alternatives(index, list, fd)
Xint index;
Xstruct addr_rec *list;
XFILE *fd;
X{
X	/** save a list of options to the file **/
X	int length_so_far = 0;
X	struct addr_rec     *alternate;
X
X	if (list == NULL) return;	/* nothing to do! */
X
X	add_comment(index, fd);
X
X	alternate = list;	/* don't LOSE the top!! */
X
X	length_so_far = strlen(save_info[index].name) + 4;
X
X	fprintf(fd, "%s = ", save_info[index].name);
X
X	while (alternate != NULL) {
X	  if (strlen(alternate->address) + length_so_far > 78) {
X	    fprintf(fd, "\n\t");
X	    length_so_far = 8;
X	  }
X	  fprintf(fd, "%s  ", alternate->address);
X	  length_so_far += (strlen(alternate->address) + 3);
X	  alternate = alternate->next;
X	}
X	fprintf(fd, "\n\n");
X}
X
Xadd_comment(index, fd)
Xint index;
XFILE *fd;
X{	
X	/** get to and add the comment to the file **/
X	char buffer[SLEN];
X
X	/** first off, add the comment from the comment file, if available **/
X
X	if (save_info[index].offset > 0L) {
X	  if (fseek(elminfo, save_info[index].offset, 0)) {
X	    dprint2(1,"** error %s seeking to %ld in elm-info file!\n",
X		     error_name(errno), save_info[index].offset);
X	  }
X	  else while (fgets(buffer, SLEN, elminfo) != NULL) {
X	    if (buffer[0] != '#') 
X	       break;
X	    else
X	       fprintf(fd, "%s", buffer);
X	  }
X	}
X}
X
Xbuild_offset_table(elminfo_fd)
XFILE *elminfo_fd;
X{
X	/** read in the info file and build the table of offsets.
X	    This is a rather laborious puppy, but at least we can
X	    do a binary search through the array for each element and
X	    then we have it all at once!
X	**/
X
X	char line_buffer[SLEN];
X	
X	while (fgets(line_buffer, SLEN, elminfo_fd) != NULL) {
X	  if (strlen(line_buffer) > 1)
X	    if (line_buffer[0] != '#' && !whitespace(line_buffer[0])) {
X	       no_ret(line_buffer);
X	       if (find_and_store_loc(line_buffer, ftell(elminfo_fd))) {
X	         dprint1(1, "** Couldn't find and store \"%s\" **\n", 
X			 line_buffer);
X	       }
X	    }
X	}
X}
X
Xfind_and_store_loc(name, offset)
Xchar *name;
Xlong  offset;
X{
X	/** given the name and offset, find it in the table and store it **/
X
X	register int first = 0, last, middle, compare;
X
X	last = NUMBER_OF_SAVEABLE_OPTIONS;
X
X	while (first <= last) {
X
X	  middle = (first+last) / 2;
X
X	  if ((compare = strcmp(name, save_info[middle].name)) < 0) /* a < b */
X	    last = middle - 1;
X	  else if (compare == 0) {				    /* a = b */
X	    save_info[middle].offset = offset;
X	    return(0);
X	  }
X	  else  /* greater */					    /* a > b */
X	    first = middle + 1; 
X	}
X
X	return(-1);
X}
END_OF_src/save_opts.c
if test 9187 -ne `wc -c <src/save_opts.c`; then
    echo shar: \"src/save_opts.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: End of archive 9 \(of 19\).
cp /dev/null ark9isdone
DONE=true
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	echo shar: You still need to run archive ${I}.
	DONE=false
    fi
done
if test "$DONE" = "true" ; then
	echo You have unpacked all 19 archives.
	echo "See the Instructions file"
	rm -f ark[1-9]isdone ark[1-9][0-9]isdone
fi
##  End of shell archive.
exit 0
