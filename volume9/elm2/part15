Subject:  v09i015:  ELM Mail System, Part15/19
Newsgroups: mod.sources
Approved: rs@mirror.TMC.COM

Submitted by: Dave Taylor <hplabs!taylor>
Mod.sources: Volume 9, Issue 15
Archive-name: elm2/Part15

#! /bin/sh
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# If this archive is complete, you will see the message:
#		"End of archive 15 (of 19)."
# Contents:  doc/Alias.guide doc/Config.guide src/addr_utils.c
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"doc/Alias.guide\" \(16382 characters\)
if test -f doc/Alias.guide ; then 
  echo shar: Will not over-write existing file \"doc/Alias.guide\"
else
sed "s/^X//" >doc/Alias.guide <<'END_OF_doc/Alias.guide'
X.PH ""
X\"
X\"  A guide to the ELM alias system and so on.
X\"  format with 'troff -mm Config.guide > Config.format'
X\"  or something similar.
X\"  (C) Copyright 1986 Dave Taylor
X\"
X\"  Last modification: January 19th, 1987
X\"
X.SA 1
X.nr Hy 1
X.nr Pt 1
X.nr Pi 8
X.lg
X.HM 1 1
X.rs
X.ds HF 3  3  
X.ds HP 12 12 10 10 10
X.PF ""
X.ce 99
X.sp 5
X.ps 20
X\fBELM Alias Users Guide\fR
X.sp 4
X.ps 12
X\fIWhat aliases are and how to use them
Xin the \fBElm\fP mail system\fR
X.sp 2
XDave Taylor
X.sp
XHewlett-Packard Laboratories
X1501 Page Mill Road
XPalo Alto CA
X94304
X.sp 
Xemail: taylor@hplabs.HPL.HP.COM or hplabs!taylor
X.sp 7
X.ps 18
X\fB\(co\fR\s12 Copyright 1986, 1987 by Dave Taylor
X.ps 10
X.SK
X.sp 5
X.ps 14
X\fBElm Alias Users Guide\fR
X.PH "'Alias Users Guide''version 1.5'
X.PF "''Page \\\\nP''"
X.nr P 1
X.sp
X.ps 10
X(version 1.5)
X.sp 2
XDave Taylor
X.sp
XHewlett-Packard Laboratories
X1501 Page Mill Road
XPalo Alto CA
X94304
X.sp 
Xemail: taylor@hplabs.HPL.HP.COM or hplabs!taylor
X.sp 2
X\*(DT
X.ce 0
X.sp 3
X.P
XThis document is intended as a supplement to the \fIElm Users Guide\fR
Xand is only of interest to those users desiring more knowledge
Xabout how aliases work and how to create strange and exciting
Xaliases for their systems (alright, so it's not \fIthat\fR exciting!)
X.sp
X.P
XThis document is broken up into the following sections;
Xuser aliases,
Xgroup aliases,
Xsystem aliases,
Xediting and installing new aliases,
Xthe machine routing database,
Xthe domain routing database,
Xand general warnings and other chitchat.
X.sp
X.H 1 "User Aliases"
XThe most simple sort of aliases in the \fBElm\fR system are individual
Xuser aliases.  These are made up of three parts;
X.nf
X
X	\fIaliasname list\fR : \fIusername\fR : \fIaddress\fR
X
X.fi
XWhere the \fIaliasname list\fR is either a single aliasname\*F
X.FS
XPlease see the appendix for a full definition of what exactly an
Xaliasname consists of.
X.FE
Xor a list of aliasnames separated by commas.
X.P
X\fIUsername\fR is used to indicate the full "real name" of the user.  
XFor example, if you had an alias for "dat" to get to me, the 
X\fIusername\fR field would contain "Dave Taylor" or perhaps "Dave Taylor at HP"
Xor some other permutation.  Versions 1.2a and later of the \fBElm\fR
Xsystem use this information to add to the addresses of outbound mail
Xin the interest of more readable addresses.  It is recommended that this
Xfield contain peoples names only.
X.P
X\fIAddress\fR is either the users full electronic mail address or, if
Xthe machine routing database is installed, the minimum address needed
Xto specify the destination.  For example, say our routing database
Xcontained information on how to get to machine "hp-sdd" and I wanted
Xto have an address for my friend Ken there - I could have his address
Xspecified as simply "ken@hp-sdd" (or alternatively "hp-sdd!ken" since
Xthe two are functionally equivalent).
X.sp
X.P 0
XLet's get on to some examples, shall we?
X.sp
XConsider this excerpt from my own \fI.alias_text\fR file;
X.nf
X
Xwunder,walter : Walter Underwood: wunder@hpcea
Xlaubach       : Mark Laubach    : laubach@hpcea
Xmary          : Mary Hsia-Coron : hsia@hpindla
Xdecot         : Dave Decot      : decot@hpda
X 	
Xjeff	      : Jeff Wu         : hpcnoe!j_wu
Xdave	      : Dave Barrett    : hpcnof!d_barrett
X
X.fi
XNote that the alias for Walter Underwood has two \fIaliasnames\fR associated
Xwith it, \fIwunder\fR and \fIwalterf\R.  Also notice that the first four aliases
Xuse the Internet style naming convention (\fIuser@machine\fR) but the last two
Xuse the UUCP style convention (\fImachine!user\fR).  In this context it is
Xindependent.
X.P
XThe only time when it \fIdoes\fR make a difference which notation you
Xuse is if you have to specify more than the machine that the user is
Xreceiving mail on.  That is, say we have a friend who receives mail at
Xa machine called \fBtwinkie\fR and our best connection is through Georgia
XInstitute of Technology (``gatech'')...Our alias for them could be;
X.nf
X
X  buddy         : Our friend      : gatech!twinkie!buddy
X
Xor
X
X  buddy2        : Our friend      : gatech!buddy@twinkie
X
X.fi
Xbut not;
X.nf
X
X  buddy         : Our friend      : buddy@twinkie@gatech
X
X.fi
X(however, buddy%twinkie@gatech \fIwill\fR also work, but that's far
Xtoo bizarre a notation to be recommended!!) (besides there's no
Xguarantee that "gatech" will like it, nor the "buddy2" alias above!)
X.P
XAnyway, suffice to say that if you must specify any sort of route
Xthat you should use the uucp notation as much as possible to ensure
Xthat the system expands the correct machine name.
X.sp
X.H 1 "Group Aliases"
XAfter the confusion of user aliases, group aliases are even more 
Xfun!  For the most part the notation is very similar;
X.nf
X
X	\fIaliasname list\fR : \fIgroupname\fR : \fIlist of people\fR
X
X.fi
XWhere \fIaliasname list\fR and \fIgroupname\fR are exactly equivalent
Xto the corresponding fields in user aliases.
X.P
XThe interesting part is the \fIlist of people\fR field!  This
Xfield is actually in the same notation as the aliasname list,
Xso it's not quite as strange as I've lead you to believe.
XIt's best to illustrate by example;
X.nf
X
Xfriends, mypals, gang : The Gang of Six : joe, larry, mary, joanna,
X					  nancy, michael
X
X.fi
X(Notice that you can continue onto as many lines as you'd like so
Xlong as each additional line start with either a \s8SPACE\s10 or a \s8TAB\s10
Xcharacter)
X.P
XThe significant limitation with group aliases is that each of the
Xpeople in the list must be a \fIpreviously defined aliasname in either the
Xexisting alias file or the system alias file\fR or a valid destination
Xon the current machine.
X.P
XWhat does this mean?  This means that the following excerpt from an
Xalias file;
X.nf
X
Xhawaii : The Hawaiian Twins : joe@\s8RIT-CS.ARPA\s10, maoa
Xmaoa   : Maoa Lichtenski Jr : maoa@Hawaii.cs.uh.\s8ARPA\s10
X
X.fi
Xwill fail for two reasons - not only does the group \fIlist of people\fR
Xcontain a complex address, but it also contains an aliasname that is 
Xdefined \fIlater\fR in the \fI.alias_text\fR file!  \fB** \s8BEWARE\s10!!! **\fR
X.P
XThe correct way to have the previous alias in the file is to have it like;  
X.nf
X
Xjoe    : Joe Lichtenski     : joe@\s8RIT-CS\s10
Xmaoa   : Maoa Lichtenski Jr : maoa@Hawaii
Xhawaii : The Hawaiian Twins : joe, maoa
X
X.fi
Xwhich will then work correctly.
X.P 0
XThis isn't too hard now, is it?
X.sp
XFortunately, while this seems pretty tough, when you run \fInewalias\fR
Xto install the new aliases, it will give you relevent and meaningful
Xerror messages that will help you fix the list up correctly!
X.sp
X.H 1 "System Aliases"
XSystem aliases are functionally equivalent to the individual \fBElm\fR 
Xalias lists each \fBElm\fR user has (both user aliases and group aliases) 
Xbut are "read only" for everyone but the \fBElm\fR administrator.  The 
Xformat of the file is identical to the users file, and the only difference is
Xthat this file is expected to be located in the directory that contains
Xthe \fIsystem_hash_file\fR and \fIsystem_data_file\fR files (see the
X\fIElm Configuration Guide\fR for more details on these variables).
X.P
XSimply create a \fI.alias_text\fR file in the specific directory
Xas you would a normal file, and install it the same way (see the
Xfollowing section for more details on that).  
X.P
XVoila!!
X.sp
X.H 1 "Editing and Installing New Aliases"
XTo install new aliases, you need merely to create, or modify,
Xyour \fI.alias_text\fR file in your home directory until you're
Xsatisfied with it and it meets the requirements stated above.
XYou can then try to install it with the command;
X.nf
X
X	$ \fBnewalias\fR
X
X.fi
Xwhich will either report back the number of aliases installed into 
Xthe system or will report errors indicative of the changes that
Xthe program expects before it can accept the alias list.
X.P
XNote that blank lines are no problem and that comments are not only
Xallowed but actually encouraged, and must have `\fB#\fR' as the first
Xcharacter of each comment line.
X.sp
XFinally, if you find that you're hitting the ``Too many aliases'' error, 
Xthen you'll need to reconfigure the entire \fBElm\fR system (again,
Xsee the \fIElm Configuration Guide\fR).
X.sp
X.H 1 "The Hostname Routing Database"
XFloating about on the various networks is a rather nifty program by
Xa number of people, including Peter Honeyman and Steve Bellovin, 
Xcalled \fIpathalias\fR.  What this incredibly handy program does is 
Xtake the strange postings in netnews groups like "news.map" and massage
Xthem into a file of the form;
X.nf
X
X  \fIhostname\fR    <tab>    \fIaddress\fR
X
X.fi
Xwhich is then sorted alphabetically and stored in the file
Xpointed to by \fIpathfile\fR (guess where to look for more information!)
Xfor \fBElm\fR to use.
X.P
XIf you don't have the program, or don't want to use it, you can 
Xsimulate this file by listing machines in the same format.  The
Xexact format expected is;
X.nf
X
X  \fIhostname\fR<tab>\fImachine-address\fR
X
X.fi
Xwhere \fIhostname\fR is a limited identifier (no special characters) and
Xmachine-address MUST contain the sequence `%s' (and consequently
Xany other percent signs that appear in the address must be paired)
Xso that the call in the program ``sprintf(buffer, machine-address, username)''
Xwill generate a valid return address.
X.P 0
XBy way of example, here are a few entries from my own file;
X.nf
X
X \s8HPL\s10    hplabs!%s
X \s8PARC\s10   hplabs!%s@Xerox.\s8PA.COM\s10
X amc-hq     hplabs!%s@\s8AMC-HQ.ARPA\s10
X imsss	    hplabs!%s%%\s8IMSSS@SU-AI.ARPA\s10
X infopro    hpfcla!ihnp4!astrovax!infopro!%s
X interleaf  hpfcdc!hpda!sun!interleaf!%s
X jpl-vax    hplabs!%s@jpl-vax
X
X.fi
XAs you can see, the addresses can get pretty complicated!!  In fact
Xit's due purely to the complication that a database file of this
Xsort can be so wonderful!!
X.sp
XIf you'd like further information on the pathalias program, try
Xkeeping track of the entries in the netnews group \fImod.sources\fR - 
Xit's posted about once a year or so...
X.sp
X.H 1 "The Domain Routing Database"
XOne of the more interesting features of the 3.2 and above
X\fBElm\fR mailer is the domain routing database.  This is
Xthe same database (in the same strange format) as used by
Xthe most recent version of the \fIuumail\fR program.
X.P
XIn a nutshell, the file contains information of the form;
X.nf
X
X   \fIdomain\fR   \fIpathtogateway\fR  \fIrewrite-template\fR
X
X.fi
XThe \fIdomain\fR field must begin with a leading `.' and
Xshould be ordered in the same notation as the standard
Xdomain information (that is, "\s8.HP.COM\s10" not "\s8.COM.HP\s10").
X.P
X\fIPathtogateway\fR is routing information on how to get
Xto the particular gateway that this domain expects, and
Xalways is a machine/host name (to be found in the pathalias
Xdatabase, see the previous section) preceeded by a `>' 
Xcharacter.
X.P
X\fIRewrite-template\fR is the most interesting of the
Xthree, and is akin to a printf string for C.  The 
Xchanges are that instead of `%s' `%d' and so on, the
Xactual "percent" values represent various parts of 
Xthe address, namely;
X.nf
X
X	Symbol		Represents
X	------          ----------
X	  %U		The username in the To: address
X	  %N		The remote machine name
X	  %D		%N + domain information 
X	  %R		path to %N from pathalias
X	  %P		\fIpathtogateway\fR entry
X	  %S		Obsolete!
X	  %%		The `%' character
X
X.fi
Xwith this very intuitive setup, let's look at a few entries 
Xfrom the domains database and see how they work;
X.nf
X
X.ps 8
X  .EUR.UUCP,,,%R!%U
X  .ATT.UUCP,>\s10ihnp4\s8,,%P!%D!%U
X  .HP.COM,,,%R!%U
X  .UUCP,,,%R!%U
X  .COM,>\s10hplabs\s8,,%P!%U@%D
X  .CSNET,>\s10hplabs\s8,,%P!%U%%%D@CSNET-RELAY.ARPA
X  .ARPA,>\s10hplabs\s8,,%P!%U@%D
X.ps 10
X
X.fi
X(Note the presence of a third field that is always null.  This is
Xfor compatability with the "uumail" program, but this field is
Xnow always \fI\s8NULL\s10\fR)
X.P
XTo see how it all works, let's suppose that we want to send a message
Xto "jad@Purdue.\s8ARPA\s10".  This would break down into the following fields:
X.nf
X
X	%U = jad
X	%N = Purdue
X	%D = Purdue.\s8ARPA\s10
X	  
X.fi
XWhen the \fBelm\fR program matches the ".\s8ARPA\s10" entry
X.nf
X
X  .\s8ARPA\s10,>hplabs,,%P!%U@%D
X
X.fi
Xthe other fields instantiated would be:
X.nf
X
X	%P = <path to hplabs>
X  template = %P!%U@%D
X
X.fi
XAs is hopefully obvious, if our path to hplabs was "hpcnoe!hplabs" then
Xthe fully expanded address would be;
X.nf
X
X	hpcnoe!hplabs!jad@Purdue.\s8ARPA\s10
X
X.fi
XAnd so on.  
X.sp
X.P
XWhat does this mean to the average user?  It means that you can
Xfor the most part send mail to people on different gateways by
Xsimply using their full domain information, so that mail to 
Xaddresses like "Jack@\s8MIT.MIT.EDU\s10" will work, and mail 
Xto "SueAnn@\s8BBN.MAILNET\s10"
Xwill work and so on!!
X.sp
X.H 1 "Other Stuff not Covered Yet"
XProbably the biggest question you have in your mind right now is
X"But how the heck does this relate to the 'ole \fIBerkeley Mail\fR
Xaliases and the snazzo \fIsendmail\fR alias system??"  Well,
Xrest assured, \fIsendmail\fR fans, that if you \fIreally\fR want to have
Xyour aliases down in the transport you can.  No problem.  All you'll
Xneed to do is to turn off the address validation routine in \fBElm\fR
X(I'm not even going to bother to tell you where to look for this one!!).
X.P
XFor those \fIBerkeley Mail\fR fanatics out there, you can translate your 
Xaliases into the format that \fBElm\fR wants by running them
Xthrough the \fIawk\fR script listed in Appendix Two.
X.sp
X.P
XFinally, if you have any problems or questions, try looking in 
Xthe \fInewalias\fR manual entry, or dropping me a line at the
X"usual" email address (ask your administrator!).
X.SK
X.ce 99
XAppendix One
X
XA BNF of the Alias File Grammar
X.ce 0
X.sp 2
XIn this listing, items in <> brackets are non-terminals, items in {}
Xare optional, and items in \fBbold face\fR are terminals.
X.sp 2
X.nf
X
X<alias_file>  ::=  <line> { <alias_file> }
X
X<line>	      ::=  <comment> | <empty> | <alias>
X
X<comment>     ::=  .. any sequence of characters starting with '#' ..
X
X<empty>	      ::=  .. an empty line ..
X
X<alias>	      ::=  <user alias> | <group alias>
X
X<user alias>  ::=  <aliaslist> \fB:\fR { <comment> \fB:\fR } 
X		   {<whitespace>} <address>
X
X<group alias> ::=  <aliaslist> \fB:\fR { <comment> \fB:\fR } 
X		   {<whitespace>} <list of addresses>
X
X<aliaslist>   ::=  <aliasname> { \fB,\fR <aliaslist> }
X
X<aliasname>   ::=  <alpha-char> { <sequence-of-chars> }
X
X<comment>     ::=  .. anything other than ":" ..
X
X<address>     ::=  <username> | <arpa-address> | <uucp-address> | 
X		   <complex-address>
X
X<list-of-addresses> ::= <aliasname> { \fB,\fR <whitespace> } 
X			{ <list-of-addresses> }
X
X<username>    ::=  .. any valid mailbox name on the system ..
X
X<arpa-address> ::= <username> ( \fB@\fR <hostname> | <postfix> )
X
X<hostname>    ::=  .. any legal host machine name ..
X
X<uucp-address> ::= <hostname> \fB!\fR <username>
X
X<complex-address> ::= <prefix> ( <uucp-address> | <arpa-address> )
X
X<prefix>      ::= <hostname> \fB!\fR { <prefix> }
X
X<postfix>     ::= \fB%\fR <hostname> { <postfix> } \fB@\fR 
X		  <hostname>
X
X<sequence-of-chars> ::= .. any characters other than space, tab, 
X		           return, or colon ..
X
X<whitespace> ::= .. space, tab or newline followed by space or tab ..
X
X.fi
X.SK
X.ce 99
XAppendix Two
X
XAn AWK Script for 
XTranslating Aliases from a \fIBerkeley Mail\fR
X".mailrc" File to an \fIElm\fR ".alias_text" File
X.ce 0
X.sp 2
X.nf
X.ce
X-------------------------------------------------------------------
X
XBEGIN { print "# ELM alias_text file, from a .mailrc file..." 
X	print ""
X      }
X
Xnext_line == 1 { 
X	next_line = 0;
X        group = ""
X	for (i = 1; i <= NF; i++) {
X	  if (i == NF && $i == "\\\\") sep = ""
X	  else                       sep = ", "
X	  if ($i == "\\\\") {
X	    group = sprintf("%s,", group)
X	    next_line = 1;
X	  }
X	  else if (length(group) > 0)
X	    group = sprintf("%s%s%s", group, sep, $i);
X	  else
X	    group = $i;
X	  }
X	  print "\\t" group
X	}
X$1 ~ /[Aa]lias|[Gg]roup/ { 
X	if ( NF == 3)
X	  print $2 " : user alias : " $3;
X	else {
X	  group = ""
X	  for (i = 3; i <= NF; i++) {
X	    if (i == NF && $i == "\\\\") sep = ""
X	    else        sep = ", "
X	
X	    if ($i == "\\\\") {
X 	      group = sprintf("%s,", group)
X 	      next_line = 1;
X	    }
X	    else if (length(group) > 0) 
X 	      group = sprintf("%s%s%s", group, sep, $i);
X	    else
X 	      group = $i;
X	    }
X	    print $2 " : group alias : " group;
X	  }
X 	}
X
X.ce
X-------------------------------------------------------------------
X.fi
X.P
XNote: this script is contained in the release under the name 
X"mailrc.awk" in the utilities directory "utils".
END_OF_doc/Alias.guide
if test 16382 -ne `wc -c <doc/Alias.guide`; then
    echo shar: \"doc/Alias.guide\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"doc/Config.guide\" \(15488 characters\)
if test -f doc/Config.guide ; then 
  echo shar: Will not over-write existing file \"doc/Config.guide\"
else
sed "s/^X//" >doc/Config.guide <<'END_OF_doc/Config.guide'
X.PH ""
X\"
X\"  A guide to the configuration of the Elm mail system
X\"  format with 'troff -mm Config.guide > Config.format'
X\"  or something similar.
X\"  (C) Copyright 1986 Dave Taylor
X\"
X\"  Last modification: January 19th, 1987
X\"
X.SA 1
X.nr Hy 1
X.nr Pt 1
X.nr Pi 8
X.lg
X.HM 1 1
X.rs
X.ds HF 3  3
X.ds HP 12 12 10 10 10
X.PF ""
X.ce 99
X.sp 13
X.ps 20
X\fBElm Configuration Guide\fR
X.sp 4
X.ps 12
X\fIHow to install and customize the Elm mail system\fR
X.sp 2
XDave Taylor
X.sp
XHewlett-Packard Laboratories
X1501 Page Mill Road
XPalo Alto CA
X94304
X.sp 
Xemail: taylor@hplabs.HPL.HP.COM or hplabs!taylor
X.sp 7
X.ps 18
X\fB\(co\fR\s12 Copyright 1986,1987 by Dave Taylor
X.ps 10
X.SK
X.sp 5
X.ps 14
X\fBElm Configuration Guide\fR
X.PH "'Elm Configuration Guide''version 1.5'
X.PF "''Page \\\\nP''"
X.nr P 1
X.sp
X.ps 10
X(version 1.5)
X.sp 2
XDave Taylor
X.sp
XHewlett-Packard Laboratories
X1501 Page Mill Road
XPalo Alto CA
X94304
X.sp 
Xemail: taylor@hplabs.HPL.HP.COM or hplabs!taylor
X.sp 2
X\*(DT
X.ce 0
X.sp 3
X.P
XThis document is intended as a supplement to the \fIElm Users Guide\fR
Xand is only of interest to those people at a site either installing
Xor maintaining the source code to the \fBElm\fR mail system.
X.sp 2
X.P
XIt's \fIhighly\fR recommended that installation be done by using the
X\fIConfigure.sh\fR script supplied with the system.  Please see the
Xfile \fIInstructions\fR for further information.
X.sp 2
XThe remainder of this document will discuss the 
Xoptions available via direct editing of various files and
Xparameters.  As indicated above, 99.9% of the sites that install
X\fBElm\fR should find the \fIConfigure.sh\fR script sufficient.
X.sp 2
X.P
XThe first thing that needs to be decided when you're ready to install
Xthe program is what sort of operating system you're running on...
Xcurrently the choices are;
X.VL 14 3
X.LI "System V"
XThis is the default configuration, and should work on all Bell 
XSystem V Unix
X.FS ' '
X.br
XUnix is a Trademark of AT&T Bell Laboratories.
X.br
XHP-UX and Spectrum are Trademarks of Hewlett-Packard Company.
X.br
XUTS is a Trademark of Amdahl Corporation.
X.FE
Xsystems, including HP-UX (and the \fISpectrum\fR series!) or 
Xsimulations thereof.
X.LI "BSD"
XThis is for the Berkeley breed of Unix.
X.LI "UTS"
XThis is for the Amdahl version of Unix.
X.LI "SUN"
XThis is for the Sun workstations (This is a superset of the BSD
Xdefinition as the Sun appears to have some major crises when it
Xis asked to perform string functions and handed \fInull\fR addresses,
Xas opposed to a \fIpointer\fR to a \fInull\fR...)
X.LI "PYRAMID"
XThis is for the Pyramid 90x machines (This is the same as the
XBSD definition)
X.LE
X.sp
XOnce you've decided which is appropriate, edit the Makefile file
Xin the top level directory and alter the "DEFINE" there (about
Xline 33 or so) accordingly.  (Note: also use the associated
X"LIB2" define that's associated with each of the systems to ensure
Xthat the program uses the correct libraries when linking together!)
X.sp
XAn analogous change should be made in the Makefile in 'src' and 'utils'
Xtoo if you're planning on actually working on the programs rather than
Xjust installing them...
X.sp
XWhile you're at it, if you happen to be running \fIACSNET\fR, then
Xyou need to add the relevent define in the main Makefile and the
XMakefile in directory `src' too!
X.sp 2
XOnce that's done, all of the other installation dependent definitions
Xare contained in the file \fIhdrs/sysdefs.h\fR and are;
X.sp
X.VL 15 0
X.LI "USE_EMBEDDED_ADDRESSES"
XThis controls the mailers response to messages that contain 
X"Reply-To:" or "From:" lines that actually contain a return
Xaddress.  If it's defined, the mailer will attempt to use
Xthe address specified (overriding the return address built from the path that
Xthe mail took).  It will look the address up in the pathalias
Xdatabase (see the documentation on the alias system) for 
Xincomplete paths, but it is still recommended that this be left
Xundefined.  
X.P
XThis will, of course, make the mailer not be a standard 'RFC-822' 
Xmailer, since the mail system is defined to use the reply-to
Xif included rather than the return address, but, at least for
Xaddresses on the Internet, it ain't going to work a lot of the time!
X.LI "FIND_DELTA"
XThis is the delta that the binary search of the pathalias database
Xwill use to determine when it's slicing up a single line, rather than
Xa multitude of lines.   Ideally, this should be set to 1 byte less
Xthan the shortest line in the file...the default is 10 bytes.
X.LI MAX_SALIASES        
XThe number of system aliases allowed.  (It is recommended that
Xthis be a prime number to improve the performance of the 
Xhashing function (it's a complicated proof!))
X.LI MAX_UALIASES
XThe number of user aliases allowed.  (should be a prime number -
Xsee the comment above)
X.LI MAX_IN_WEEDLIST 
XThe maximum number of headers that can be specified in the weedout
Xlist of the .elmrc file.  A suggested alternative approach if this
Xnumber is too small is to specify initial substrings in the file
Xrather than increasing the number.  For example, say you want to 
Xweedout the headers "Latitude:" and "Latitudinal-Coords:", you
Xcould simply specify "Latitud" and match them both!  Furthermore
Xyou could also specify headers like "X-" and remove all the user
Xdefined headers!
X.LI MAX_HOPS
XWhen replying to a G)roup, this is the maximum number of hops that
Xa message can have taken.  This is used to try to optimize the 
Xreturn address (remove cyclic loops and so on) and regular use
Xshould show that the default of 35 is plenty more than you'll
Xever need!
X.LI MAX_ATTEMPTS
XWhen reading in the default mailbox (\fI/usr/mail/$username\fR) the mailer
Xcreates a file called \fI/usr/mail/$username.lock\fR to ensure that no
Xmail is added to the file while it's being either read, or replaced
X(ie written to).  Occasionally, this lock file will already be in
Xplace since someone is currently sending you mail.  If this occurs,
Xthe mailer will wait a few seconds and try to create the lock file
Xagain.  This parameter defines the number of tries the mailer should
Xtake before giving up.
X.LI REMOVE_AT_LAST
XWhen it does decide to give up after trying to create the lock file,
X(see MAX_ATTEMPTS, above) this will define how to act.  If it's 
Xdefined, the mailer will attempt to remove the lock file after the
XMAX_ATTEMPTS timeout.  On the other hand, if it's not defined (the
Xrecommended state) it'll simply quit the mailer, telling the user
Xto try again in a few minutes.
X.LI DEFAULT_BATCH_SUBJECT
XWhat the subject should be on messages that are from redirected input
Xbut don't have a subject specified...
X.LI NOCHECK_VALIDNAME
XThis disables the checking of validnames on the existing machine.
XOn machines that run a system such as \fIsendmail\fR and use the
Xsendmail alias feature, this should be defined.  On other systems
Xthis should be left as the default (not defined) to avoid users
Xgenerating \fIdead.letter\fR files...
X.LI NO_VM
XThis disables the calls to "vfork()" and replaces them will calls
Xto "fork()".  On machines where vfork() is available, this should
Xbe left undefined, as the virtual call is considerably faster (and
Xis only used when the spawned process doesn't need ALL the stuff
Xfrom the calling process!)
X.LI ALLOW_BCC
XIf you are running a mail transport agent that can properly deal 
Xwith the "Bcc" header in messages, you should define this variable.
XOtherwise you'll end up with strange stuff like people \fIknowing\fR
Xwho got "bcc"s of their mail...
X.LI LOOK_CLOSE_AFTER_SEARCH
XSome systems are set up in such a way as to have direct connections
Xto machines, but to have multi-machine hops be preferable for
Xrouting messages to/through that machine (an example is a connection
Xto "nbires" for the monthly mod.map information, but only connected
Xto once a month!).  If this option is defined, then the system will
Xtry to find a suitable path to the machine \fIbefore\fR it checks
Xagainst the \fIL.sys/uuname\fR list of systems that it can connect to.
X.LI USE_UUNAME
XThe mailer tries to get the list of machines that's its connected
Xto by looking in the \fIL.sys\fR file.  If it fails usually, it will
Xthen try to do a \fIuuname\fR command and then read the output of
Xthat command.  If this is defined, however, it will skip the \fIL.sys\fR
Xreading and immediately try the \fIuuname\fR call.
X.LI DONT_OPTIMIZE_RETURN
XWhen saving the return address of a current message, the program will
Xattempt to store the minimum possible path.  Oftentimes, however, this
Xisn't the ideal behaviour.  If you don't want the program to do this,
Xthen you should define this.
X.LI DONT_TOUCH_ADDRESSES
XWith the slow entrance of various delivery agents that can dynamically
Xroute things it becomes important that the mailer \fInot\fR touch 
Xaddresses as entered by the user.  If this is the case at your
Xsite (for example, if you're running \fIsmail\fR and \fIsendmail\fR as
Xa package) then you need to define this.
X.LI AUTO_BACKGROUND
XIf this is defined then the \fInewmail\fR program automatically puts 
Xitself into background as soon as it's invoked.  Otherwise, the
Xuser needs to have a trailing ampersand (as in \fBnewmail &\fR) to
Xget the same functionality.  (it seems reasonable to assume that
Xno-one would ever run the utility as a \fIforeground\fR process!!!)
X.LI DONT_ADD_FROM
XSome mail systems (like my own) add From: lines that are
Xactually different than the "default".  That is, the machine
XI send mail from is "hpldat" so my From: line would normally
Xbe "hpldat!taylor" but it should actually be "taylor@hplabs".
XMy sendmail will add this correctly, so this allows \fBElm\fR
Xto defer the addition until then.  This should only be used
Xif your system is running sendmail in such a way that it will
Xadd this header as needed ONLY!
X.LI INTERNET_ADDRESS_FORMAT
XFor systems that prefer the Internet addressing notation in the 
XFrom: line, defining this will force that.  The default is
Xto use Usenet notation (\fIhostname!username\fR) - this will change
Xit to Internet notation (\fIusername@hostname\fR).
X.LI PREFER_UUCP
XOn some mail systems, the local host automatically appends their
Xidentification \fIin Internet format\fR to the addresses you
Xreceive (e.g. ``ihnp4!snsvax!joe@hplabs.HP.COM'' is an address
Xform I see, being directly connection to HPLABS, all too often).
XThis will simple ensure that when displaying the return address 
Xof the message it will ignore the Internet part if there's also 
Xa UUCP part.  (This is a kludge.  One should never have to 
Xdeal with this in a mail system... *sigh*)
X.LI BOGUS_INTERNET
XAfter some serious thought, I came to the conclusion that the
Xeasiest way to deal with the dumb configuration here is to 
Xsimply strip off the local address part entirely whenever 
Xpossible.  Hence, this field defines the local address that
Xis added to the message addresses needlessly.  This is probably
Xthe single worst solution imaginable, but it works...
X.LI USE_DOMAIN
XDefine if you want to have the \fIDOMAIN\fR field added to the
X\fIhostname\fR in the From: field on outbound mail (note that this
Xonly makes sense on Internet mail...)
X.LI DOMAIN
XIf you choose to have the USE_DOMAIN define set, you
X\fIMUST DEFINE THIS ACCORDINGLY!!!\fR
XA typical entry would be;
X.DS
X#define DOMAINS        ".HP.COM"
X.DE
X.LI SAVE_GROUP_MAILBOX_ID
XIf you're running the mailer set group id (usually "setgid mail") then
Xthis'll ensure that the users mailbox, when altered, will always retain
Xits group id (obtained by the "getegid()" call, for those gurus out
Xthere who care).  
X.LI ENABLE_CALENDAR"
XIf you want to have users able to scan their mail for calendar entries
X(see the \fIElm Reference Guide\fR) then define this and the following
Xtoo.  (There is no reason not to have this, but power corrupts, right?)
X.LI "dflt_calendar_file"
XThe name of the default "calendar" file if the user doesn't specify
Xone in their \fI.elmrc\fR file.
X.LI NOTES_HEADER
XThis defines the first "word" of the line that a \fInotes\fR file entry
Xwould contain.
X.LI NOTES_FOOTER
XThis defines the footer line (in it's entirety).
X.LI system_hash_file
XThis is the file that contains the hashed version of the system 
Xaliases.  It is also used in the \fInewalias\fR command.  (note that
Xit is defined differently if you're running on a Berkeley system)
X.LI system_data_file
XThis is the other file the \fInewalias\fR command installs in the system
Xalias area.  (Note this is defined differently if you're runnnig
Xa bsd system)
X.LI pathfile
XThis defines the location of the pathalias datafile.  This file is in
Xthe format that \fIpathalias\fR generates, that is;
X.nf
X   
X    machine <tab> address
X
X.fi
XFor further information, please see the \fIElm Alias System\fR documentation.
X.LI domains
XThis defines the location of the the domains database file.  The format
Xfor this file and so on are fully discussed in the \fIElm Alias System\fR
Xdocument.
X.LI Lsys
XThis defines where the system \fIL.sys\fR file is kept.  This is used for the
Xmailer to quickly know what machines the current machine can talk to
Xdirectly (to avoid trying to search the pathalias database to route mail
Xto these machines).  
X.LI DEBUG
XThe name of the file to put in the users home directory if they choose to
Xuse the `-d' debug option. 
X.LI temp_file
XTemporary file for sending outbound messages.
X.LI temp_mbox
XPlace to keep copy of incoming mailbox to avoid collisions with newer
Xmail.
X.LI temp_print 
XFile to use when creating a printout of a message.
X.LI mailtime_file
XFile to compare date to to determine if a given message is New
Xsince the last time the mail was read or not.
X.LI readmsg_file
XFile to use when communicating with the \fIreadmsg\fR program (see
Xthat program for more information)
X.LI signature_file
XThe name of the file to search for in the users home directory
Xif they have \fIsignature\fR enabled in their \fI.elmrc\fR file.
X.LI default_editor
XIf no editor is specified in the users .elmrc file, this is which
Xeditor to use.  \s12 Ensure it is a valid editor on this machine!!\s10
X(Note that the default home for \fIvi\fR is different on BSD machines)
X.LI mailhome
XWhere all the incoming mailboxes are, and also where the 'lock'
Xfiles have to be put for the mailer to know not to add new
Xmail while we're reading/writing the mailfile.
X(note that mail is kept in a different directory on Berkeley 
Xsystems)
X.LI default_pager
XThis is the standard pager to use for reading messages.
X.LI sendmail
XDefines where \fIsendmail\fR is (if you have it on your system).
X.LI smflags 
XDefines the flags to hand to \fIsendmail\fR if and when the program
Xchooses to use it.
X.LI mailer
XIf you don't have \fIsendmail\fR, this is the mailer that'll be used.
X.LI mailx
XIf all else fails, this mailer can be used in a rather dumb way.
X.LI helphome
XWhere the help file is kept (soon to be help files!)
X.LI helpfile
XThe name of the main helpfile (kept in \fIhelphome\fR).
X.LI elmrcfile
XThe name of the automatic control file (currently \fI.elmrc\fR)
X.LI mailheaders 
XThe name of the optional file that users may have that will be
Xincluded in the headers of each outbound message.
X.LI unedited_mail
XIn the strange case when the mailer suddenly finds all the directories
Xit uses shut off (like \fI/usr/mail\fR and \fI/tmp\fR) 
Xthen it'll put the current
Xmailbox into this file in the users home directory.
X.LI newalias
XHow to install new aliases..(note: you MUST have the '-q' flag!)
X.LI remove
XHow to remove a file.
X.LI cat
XHow to display a file to stdout.
X.LI uuname
XHow to get a \fIuuname\fR listing (ie a listing of the machines that this
Xmachine connects to)
X.LE
END_OF_doc/Config.guide
if test 15488 -ne `wc -c <doc/Config.guide`; then
    echo shar: \"doc/Config.guide\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: Extracting \"src/addr_utils.c\" \(16530 characters\)
if test -f src/addr_utils.c ; then 
  echo shar: Will not over-write existing file \"src/addr_utils.c\"
else
sed "s/^X//" >src/addr_utils.c <<'END_OF_src/addr_utils.c'
X/**			addr_utils.c			**/
X
X/** This file contains addressing utilities 
X
X    (C) Copyright 1986 Dave Taylor 
X**/
X
X#include "headers.h"
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <ctype.h>
X
X#ifdef BSD
X#undef tolower
X#endif
X
Xchar *shift_lower(), *get_alias_address(), *get_token(), *strtok(),
X     *strchr(), *strcpy(), *strcat(), *strncpy();
X
Xint
Xtalk_to(sitename)
Xchar *sitename;
X{
X	/** If we talk to the specified site, return true, else
X	    we're going to have to expand this baby out, so 
X	    return false! **/
X
X	struct lsys_rec  *sysname;
X
X	sysname = talk_to_sys;
X
X	if (sysname == NULL) {
X	 dprint0(2,
X		"Warning - talk_to_sys is currently set to NULL! (talk_to)\n");
X	 return(0);
X	}
X
X	while (sysname != NULL) {
X	  if (strcmp(sysname->name, sitename) == 0)
X	    return(1);
X	  else
X	    sysname = sysname->next;
X	}
X
X	return(0);
X}
X
Xremove_domains(host)
Xchar *host;
X{
X	/** Remove all entries following the first '.' to ensure that
X	    entries like "MIT.ARPA" will match "MIT" in the database
X	**/
X
X	register int loc = 0;
X
X	while (host[loc] != '.' && host[loc] != '\0')
X	  loc++;
X
X	if (host[loc] == '.') host[loc] = '\0';
X}
X
Xadd_site(buffer, site, lastsite)
Xchar *buffer, *site, *lastsite;
X{
X	/** add site to buffer, unless site is 'uucp', current machine, or
X            site is the same as lastsite.   If not, set lastsite to
X            site.
X	**/
X
X	char local_buffer[LONG_SLEN];
X	char *strip_parens();
X
X	if (strcmp(site, "uucp") != 0)
X	  if (strcmp(site, lastsite) != 0) 
X	    if (strcmp(site, hostname) != 0) {
X	      if (buffer[0] == '\0')
X	        strcpy(buffer, strip_parens(site));         /* first in list! */
X	      else {
X	        sprintf(local_buffer,"%s!%s", buffer, strip_parens(site));
X	        strcpy(buffer, local_buffer);
X	      }
X	      strcpy(lastsite, strip_parens(site)); /* don't want THIS twice! */
X	    }
X}
X
X#ifdef USE_EMBEDDED_ADDRESSES
X
Xget_address_from(prefix, line, buffer)
Xchar *prefix, *line, *buffer;
X{
X	/** This routine extracts the address from either a 'From:' line
X	    or a 'Reply-To:' line...the algorithm is quite simple, too:
X	    increment 'line' past header, then check last character of 
X	    line.  If it's a '>' then the address is contained within '<>'
X	    and if it's a ')' then the address is in the 'clear'... **/
X
X	register int i, j = 0;
X	
X	no_ret(line);
X
X	line = (char *) (line + strlen(prefix) + 1);
X
X	if (line[strlen(line)-1] == '>') {
X	  for (i=strlen(line)-2; i > -1 && line[i] != '<'; i--)
X	    buffer[j++] = line[i];
X	  buffer[j] = 0;
X	  reverse(buffer);
X	}
X	else {	/* either ')' or address in the clear... */
X	  for (i=0; i < strlen(line) && line[i] != '('; i++)
X	    buffer[j++] = line[i];
X	  if (buffer[j-1] == '(') j--;
X	  buffer[j] = 0;
X	}
X}
X
X#endif
X
Xtranslate_return(addr, ret_addr)
Xchar *addr, *ret_addr;
X{
X	/** Return ret_addr to be the same as addr, but with the login 
X            of the person sending the message replaced by '%s' for 
X            future processing... 
X	    Fixed to make "%xx" "%%xx" (dumb 'C' system!) 
X	**/
X
X	register int loc, loc2, index = 0;
X	
X	loc2 = chloc(addr,'@');
X	if ((loc = chloc(addr, '%')) < loc2)
X	  loc2 = loc;
X
X	if (loc2 != -1) {	/* ARPA address. */
X	  /* algorithm is to get to '@' sign and move backwards until
X	     we've hit the beginning of the word or another metachar.
X	  */
X	  for (loc = loc2 - 1; loc > -1 && addr[loc] != '!'; loc--)
X	     ;
X	}
X	else {			/* usenet address */
X	  /* simple algorithm - find last '!' */
X
X	  loc2 = strlen(addr);	/* need it anyway! */
X
X	  for (loc = loc2; loc > -1 && addr[loc] != '!'; loc--)
X	      ;
X	}
X	
X	/** now copy up to 'loc' into destination... **/
X
X	while (index <= loc) {
X	  ret_addr[index] = addr[index];
X	  index++;
X	}
X
X	/** now append the '%s'... **/
X
X	ret_addr[index++] = '%';
X	ret_addr[index++] = 's';
X
X	/** and, finally, if anything left, add that **/
X
X	while (loc2 < strlen(addr)) {
X	  ret_addr[index++] = addr[loc2++];
X	  if (addr[loc2-1] == '%')	/* tweak for "printf" */
X	    ret_addr[index++] = '%';
X	}
X	
X	ret_addr[index] = '\0';
X}
X
Xbuild_address(to, full_to)
Xchar *to, *full_to;
X{
X	/** loop on all words in 'to' line...append to full_to as
X	    we go along, until done or length > len.  Modified to
X	    know that stuff in parens are comments... 
X	**/
X
X	register int i, changed = 0, in_parens = 0;
X	char word[SLEN], *ptr, buffer[SLEN];
X	char new_to_list[LONG_SLEN];
X	char *strpbrk(), *expand_system(), *strcat();
X
X	new_to_list[0] = '\0';
X
X	i = get_word(to, 0, word);
X
X	full_to[0] = '\0';
X
X	while (i > 0) {
X
X	  if (word[0] == '(' || in_parens) {
X	    in_parens = (word[strlen(word-1)] != ')');
X	    strcat(full_to, " ");
X	    strcat(full_to, word);
X	  }
X	  else if (strpbrk(word,"!@:") != NULL)
X#ifdef DONT_TOUCH_ADDRESS
X	    sprintf(full_to, "%s%s%s", full_to,
X                    full_to[0] != '\0'? ", " : "", word);
X#else
X	    sprintf(full_to, "%s%s%s", full_to,
X                    full_to[0] != '\0'? ", " : "", expand_system(word, 1));
X#endif
X	  else if ((ptr = get_alias_address(word, 1, 0)) != NULL)
X	    sprintf(full_to, "%s%s%s", full_to, 
X                    full_to[0] != '\0'? ", " : "", ptr);
X	  else if (strlen(word) > 0) {
X	    if (valid_name(word)) 
X	      sprintf(full_to, "%s%s%s", full_to,
X                      full_to[0] != '\0'? ", " : "", word);
X	    else if (check_only) {
X	      printf("(alias \"%s\" is unknown)\n\r", word);
X	      changed++;
X	    }
X	    else if (! isatty(fileno(stdin)) ) {	/* batch mode error! */
X	      fprintf(stderr,"Cannot expand alias '%s'!\n\r", word);
X	      fprintf(stderr,"Use \"checkalias\" to find valid addresses!\n\r");
X	      dprint1(1,
X		      "Can't expand alias %s - bailing out! (build_address)\n", 
X		      word);
X	      emergency_exit();
X	    }
X	    else {
X	      dprint1(2,"Entered unknown address %s (build_address)\n", word);
X	      sprintf(buffer, "'%s' is an unknown address.  Replace with: ", 
X	              word);
X	      word[0] = '\0';
X
X	      if (mail_only) 
X	        printf(buffer);
X	      else
X	        PutLine0(LINES, 0, buffer);
X		
X	      (void) optionally_enter(word, LINES, strlen(buffer), FALSE);
X	      if (strlen(word) > 0) {
X	        sprintf(new_to_list, "%s%s%s", new_to_list,
X			strlen(new_to_list) > 0? " ":"", word);
X	        dprint1(3,"Replaced with %s (build_address)\n", word);
X	      }
X	      else
X		dprint0(3,"Address removed from to list (build_address)\n");
X	      if (mail_only) printf("\n\r");
X	      changed++;
X	      clear_error();
X	      continue;
X	    }
X	  }
X
X	  i = get_word(to, i, word);
X	}
X
X	if (changed)
X	  strcpy(to, new_to_list);
X}
X
Xint
Xreal_from(buffer, entry)
Xchar *buffer;
Xstruct header_rec *entry;
X{
X	/***** Returns true iff 's' has the seven 'from' fields, (or
X	       8 - some machines include the TIME ZONE!!!)
X	       Initializing the date and from entries in the record 
X	       and also the message received date/time.  *****/
X
X	char junk[STRING], timebuff[STRING], holding_from[SLEN];
X	int  eight_fields = 0;
X
X	entry->year[0] = '\0';
X	junk[0] = '\0';
X
X	/* From <user> <day> <month> <day> <hr:min:sec> <year> */
X
X	sscanf(buffer, "%*s %*s %*s %*s %*s %s %*s %s", timebuff, junk);
X
X	if (timebuff[1] != ':' && timebuff[2] != ':') { 
X	  dprint1(3,"real_from returns FAIL [bad time field] on\n-> %s\n", 
X		  buffer);
X	  return(FALSE);
X	}
X	if (junk[0] != '\0') {	/* try for 8 field entry */
X	  junk[0] = '\0';
X	  sscanf(buffer, "%*s %*s %*s %*s %*s %s %*s %*s %s", timebuff, junk);
X	  if (junk[0] != '\0') {
X	    dprint1(3,"real_from returns FAIL [too many fields] on\n-> %s\n", 
X		    buffer);
X	    return(FALSE);
X	  }
X	  eight_fields++;
X	}
X
X	/** now get the info out of the record! **/
X
X	if (eight_fields) 
X	  sscanf(buffer, "%s %s %s %s %s %s %*s %s",
X	            junk, holding_from, entry->dayname, entry->month, 
X                    entry->day, entry->time, entry->year);
X	else
X	  sscanf(buffer, "%s %s %s %s %s %s %s",
X	            junk, holding_from, entry->dayname, entry->month, 
X                    entry->day, entry->time, entry->year);
X	
X	strncpy(entry->from, holding_from, STRING);
X	resolve_received(entry);
X	return(entry->year[0] != '\0');
X}
X
Xforwarded(buffer, entry)
Xchar *buffer;
Xstruct header_rec *entry;
X{
X	/** Change 'from' and date fields to reflect the ORIGINATOR of 
X	    the message by iteratively parsing the >From fields... 
X	    Modified to deal with headers that include the time zone
X	    of the originating machine... **/
X
X	char machine[SLEN], buff[SLEN], holding_from[SLEN];
X
X	machine[0] = '\0';
X
X	sscanf(buffer, "%*s %s %s %s %s %s %s %*s %*s %s",
X	            holding_from, entry->dayname, entry->month, 
X                    entry->day, entry->time, entry->year, machine);
X
X	if (isdigit(entry->month[0])) { /* try for veeger address */
X	  sscanf(buffer, "%*s %s %s%*c %s %s %s %s %*s %*s %s",
X	            holding_from, entry->dayname, entry->day, entry->month, 
X                    entry->year, entry->time, machine);
X	}
X	if (isalpha(entry->year[0])) { /* try for address including tz */
X	  sscanf(buffer, "%*s %s %s %s %s %s %*s %s %*s %*s %s",
X	            holding_from, entry->dayname, entry->month, 
X                    entry->day, entry->time, entry->year, machine);
X	}
X
X	if (machine[0] == '\0')
X	  sprintf(buff,"anonymous");
X	else
X	  sprintf(buff,"%s!%s", machine, holding_from);
X
X	strncpy(entry->from, buff, STRING);
X}
X
Xparse_arpa_from(buffer, newfrom)
Xchar *buffer, *newfrom;
X{
X	/** try to parse the 'From:' line given... It can be in one of
X	    two formats:
X		From: Dave Taylor <hplabs!dat>
X	    or  From: hplabs!dat (Dave Taylor)
X
X	    Added: removes quotes if name is quoted (12/12)
X	    Added: only copies STRING characters...
X	    Added: if no comment part, copy address instead! 
X	**/
X
X	char temp_buffer[SLEN], *temp;
X	register int i, j = 0;
X
X	temp = (char *) temp_buffer;
X	temp[0] = '\0';
X
X	no_ret(buffer);		/* blow away '\n' char! */
X
X	if (lastch(buffer) == '>') {
X	  for (i=strlen("From: "); buffer[i] != '\0' && buffer[i] != '<' &&
X	       buffer[i] != '('; i++)
X	    temp[j++] = buffer[i];
X	  temp[j] = '\0';
X	}
X	else if (lastch(buffer) == ')') {
X	  for (i=strlen(buffer)-2; buffer[i] != '\0' && buffer[i] != '(' &&
X	       buffer[i] != '<'; i--)
X	    temp[j++] = buffer[i];
X	  temp[j] = '\0';
X	  reverse(temp);
X	}
X
X#ifdef USE_EMBEDDED_ADDRESSES
X
X	/** if we have a null string at this point, we must just have a 
X	    From: line that contains an address only.  At this point we
X	    can have one of a few possibilities...
X
X		From: address
X		From: <address>
X		From: address ()
X	**/
X	  
X	if (strlen(temp) == 0) {
X	  if (lastch(buffer) != '>') {       
X	    for (i=strlen("From:");buffer[i] != '\0' && buffer[i] != '('; i++)
X	      temp[j++] = buffer[i];
X	    temp[j] = '\0';
X	  }
X	  else {	/* get outta '<>' pair, please! */
X	    for (i=strlen(buffer)-2;buffer[i] != '<' && buffer[i] != ':';i--)
X	      temp[j++] = buffer[i];
X	    temp[j] = '\0';
X	    reverse(temp);
X	  }
X	}
X#endif
X	  
X	if (strlen(temp) > 0) {		/* mess with buffer... */
X
X	  /* remove leading spaces and quotes... */
X
X	  while (whitespace(temp[0]) || quote(temp[0]))
X	    temp = (char *) (temp + 1);		/* increment address! */
X
X	  /* remove trailing spaces and quotes... */
X
X	  i = strlen(temp) - 1;
X
X	  while (whitespace(temp[i]) || quote(temp[i]))
X	   temp[i--] = '\0';
X
X	  /* if anything is left, let's change 'from' value! */
X
X	  if (strlen(temp) > 0)
X	    strncpy(newfrom, temp, STRING);
X	}
X}
X
Xparse_arpa_date(string, entry)
Xchar *string;
Xstruct header_rec *entry;
X{
X	/** Parse and figure out the given date format... return
X	    the entry fields changed iff it turns out we have a
X	    valid parse of the date!  **/
X
X	char word[15][NLEN], buffer[SLEN], *bufptr;
X	char *aword;
X	int  words = 0;
X
X	strcpy(buffer, string);
X	bufptr = (char *) buffer;
X
X	/** break the line down into words... **/
X
X	while ((aword = strtok(bufptr," \t '\"-/(),.")) != NULL) {
X	  strcpy(word[words++], aword);
X	  bufptr = NULL;
X	}
X
X	if (words < 6) {	/* strange format.  We're outta here! */
X	  dprint1(3,"parse_arpa_date failed [less than six fields] on\n-> %s\n",
X		  string);
X	  return;
X	}
X
X	/* There are now five possible combinations that we could have:
X	 
X	    Date: day_number month_name year_number time timezone
X	    Date: day_name day_number month_name year_number ...
X	    Date: day_name month_name day_number time year_number
X	    Date: day_name month_name day_number year_number time
X	    Date: day_number month_name year_number time timezone day_name
X
X	   Note that they are distinguishable by checking the first
X	   character of the second, third and fourth words... 
X	*/
X
X	if (isdigit(word[1][0])) {			/*** type one! ***/
X	  if (! valid_date(word[1], word[2], word[3])) {
X	    dprint4(3,"parse_arpa_date failed [bad date: %s/%s/%s] on\n-> %s\n",
X		  word[1], word[2], word[3], string);
X	    return;		/* strange date! */
X	  }
X	  strncpy(entry->day, word[1], 3);
X	  strncpy(entry->month, word[2], 3);
X	  strncpy(entry->year,  word[3], 4);
X	  strncpy(entry->time,  word[4], 10);
X	}
X	else if (isdigit(word[2][0])) {		        /*** type two! ***/
X	  if (! valid_date(word[2], word[3], word[4])) {
X	    dprint4(3,"parse_arpa_date failed [bad date: %s/%s/%s] on\n-> %s\n",
X		  word[2], word[3], word[4], string);
X	    return;		/* strange date! */
X	  }
X	  strncpy(entry->day, word[2], 3);
X	  strncpy(entry->month, word[3], 3);
X	  strncpy(entry->year,  word[4], 4);
X	  strncpy(entry->time,  word[5], 10);
X	}
X	else if (isdigit(word[3][0])) {		
X	  if (word[4][1] == ':' || 
X              word[4][2] == ':') {	               /*** type three! ***/
X	    if (! valid_date(word[3], word[2], word[5])) {
X	     dprint4(3,
X		"parse_arpa_date failed [bad date: %s/%s/%s] on\n-> %s\n",
X		    word[3], word[2], word[5], string);
X	      return;		/* strange date! */
X	    }
X	    strncpy(entry->year,  word[5], 4);
X	    strncpy(entry->time,  word[4], 10);
X	  }
X	  else {				       /*** type four!  ***/ 
X	    if (! valid_date(word[3], word[2], word[4])) {
X	     dprint4(3,"parse_arpa_date failed [bad date: %s/%s/%s] on\n-> %s\n",
X		    word[3], word[2], word[4], string);
X	      return;		/* strange date! */
X	    }
X	    strncpy(entry->year,  word[4], 4);
X	    strncpy(entry->time, word[5], 10);
X	  }
X	  strncpy(entry->day, word[3], 3);
X	  strncpy(entry->month, word[2], 3);
X	}
X}
X
Xfix_arpa_address(address)
Xchar *address;
X{
X	/** Given a pure ARPA address, try to make it reasonable.
X
X	    This means that if you have something of the form a@b@b make 
X            it a@b.  If you have something like a%b%c%b@x make it a%b@x...
X	**/
X
X	register int host_count = 0, i;
X	char     hosts[MAX_HOPS][2*NLEN];	/* array of machine names */
X	char     *host, *addrptr;
X
X	/*  break down into a list of machine names, checking as we go along */
X	
X	addrptr = (char *) address;
X
X	while ((host = get_token(addrptr, "%@", 2)) != NULL) {
X	  for (i = 0; i < host_count && ! equal(hosts[i], host); i++)
X	      ;
X
X	  if (i == host_count) {
X	    strcpy(hosts[host_count++], host);
X	    if (host_count == MAX_HOPS) {
X	       dprint0(2,
X              "Can't build return address - hit MAX_HOPS (fix_arpa_address)\n");
X	       error("Can't build return address - hit MAX_HOPS limit!");
X	       return(1);
X	    }
X	  }
X	  else 
X	    host_count = i + 1;
X	  addrptr = NULL;
X	}
X
X	/** rebuild the address.. **/
X
X	address[0] = '\0';
X
X	for (i = 0; i < host_count; i++)
X	  sprintf(address, "%s%s%s", address, 
X	          address[0] == '\0'? "" : 
X	 	    (i == host_count - 1 ? "@" : "%"),
X	          hosts[i]);
X
X	return(0);
X}
X
Xfigure_out_addressee(buffer, mail_to)
Xchar *buffer;
Xchar *mail_to;
X{
X	/** This routine steps through all the addresses in the "To:"
X	    list, initially setting it to the first entry (if mail_to
X	    is NULL) or, if the user is found (eg "alternatives") to
X	    the current "username".
X
X	    Modified to know how to read quoted names...
X	**/
X
X	char *address, *bufptr;
X	register int index = 0, index2 = 0;
X	
X	if (equal(mail_to, username)) return;	/* can't be better! */
X
X	bufptr = (char *) buffer;	/* use the string directly   */
X
X	if (strchr(buffer,'"') != NULL) {	/* we have a quoted string */
X	  while (buffer[index] != '"')
X	    index++;
X	  index++;	/* skip the leading quote */
X	  while (buffer[index] != '"' && index < strlen(buffer))
X	    mail_to[index2++] = buffer[index++];
X	  mail_to[index2] = '\0';
X	}
X	else while ((address = strtok(bufptr, " ,\t\n\r")) != NULL) {
X	  if (! okay_address(address, "don't match me!")) {
X	    strcpy(mail_to, username);	/* it's to YOU! */
X	    return;
X	  }
X	  else if (strlen(mail_to) == 0)	/* it's SOMEthing! */
X	    get_return_name(address, mail_to, FALSE);
X
X	  bufptr = (char *) NULL;	/* set to null */
X	}
X
X	return;
X}
END_OF_src/addr_utils.c
if test 16530 -ne `wc -c <src/addr_utils.c`; then
    echo shar: \"src/addr_utils.c\" unpacked with wrong size!?
fi
# end of overwriting check
fi
echo shar: End of archive 15 \(of 19\).
cp /dev/null ark15isdone
DONE=true
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	echo shar: You still need to run archive ${I}.
	DONE=false
    fi
done
if test "$DONE" = "true" ; then
	echo You have unpacked all 19 archives.
	echo "See the Instructions file"
	rm -f ark[1-9]isdone ark[1-9][0-9]isdone
fi
##  End of shell archive.
exit 0
