Subject:  v09i054:  Terminal emulator for X window system, Part01/07
Newsgroups: mod.sources
Approved: rs@mirror.TMC.COM

Submitted by: edmoy@opal.Berkeley.EDU
Mod.sources: Volume 9, Issue 54
Archive-name: xterm6.6b/Part01

This is part 1/7 of version 6.6B of xterm, a modified version of the X
version 10, release 4 xterm.  It has all the bug fixes I know of and has
some other clean up done.  Enjoy.

Edward Moy
Academic Computing Services
University of California
Berkeley, CA  94720

edmoy@opal.Berkeley.EDU
ucbvax!opal!edmoy
#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	CHANGES
#	CHANGES.resize
#	CHANGES.termcap
#	ONELINE
#	README
#	Tekparse.h
#	VTparse.h
#	bottom.ic
#	button.ic
#	dark.ic
#	data.h
#	downline.ic
#	downpage.ic
#	error.h
#	gray.ic
#	hilite.ic
#	icon.ic
#	light.ic
#	ptyx.h
#	saveoff.ic
#	saveon.ic
#	scrollbar.h
#	tek_icon.ic
#	top.ic
#	upline.ic
#	uppage.ic
#	wait.ic
#	waitmask.ic
if test -f CHANGES
then
	echo shar: will not overwrite existing file "'CHANGES'"
else
echo 'x - CHANGES'
cat << \RAZZLE!DAZZLE > CHANGES
VERSION X10/6.6B
------- --------

General
-------

vt102 and Tektronix 4015 emulation in separate windows, each with its own
mode menu (control middle button).

Switching between each mode can be done via the menus, or with escape
sequences:
	vt102 -- \E[?38h --> tek
	tek   -- \E\003  --> vt102

The windows hilite themselves when the mouse is with either window or when
one of these is the focus window.  The windows unhilite when the mouse moves
out of the window and neither is the focus window.  Hiliting appears as
windows with solid color borders and solid block cursors.  Unhiliting appears
as windows with "grayed" borders and a rectangle cursor.

The parser for both modes is table-driven and is much more efficient than the
original parsers.

If UTMP is define in the Makefile, then each instance of xterm makes an entry
in /etc/utmp and thus appears with the "who" command.

If both windows are visible and one is iconified, both disappear.  Deiconifing
causes both to appear again.

If the initial mode is vt102, /etc/termcap is searched, in order, for the
following termcaps, until one is found:
	xterms, xterm, vt102, vt100, ansi, dumb
If the vt102 window happens to be 80x24, then xterms is added to the begining
of the list.  If the initial mode is tek, the termcaps searched for are:
	tek4015, tek4014, tek4013, tek4010, dumb

The window size is passed to the operating system via TIOCSWINSZ (4.3) or
TIOCSSIZE (sun).  A SIGWINCH siganl is sent if the vt102 window is resized.

For login windows, menus are disabled until a user has successfully login.

A new menu (xterm) has been added (control left button) that gives the version
number.  The menu allows titlebars to be displayed (see below), the windows
redrawn, or for various signals to be sent to the process group of the command
xterm is executing.  The signals include SIGCONT, SIGTSTP,SIGHUP, SIGINT,
SIGTERM and SIGKILL.

Titlebars for the window can be turned on with .Xdefaults
"xterm.TitleBar on", with command line option -tb or via the xterm menu.

The titlebar font is, by default, vtsingle.  The font can be changed with
.Xdefaults "xterm.TitleFont helv12b" for helv12b font or via command line
option -ft helv12b.

The titlebar look like Macintosh titlebars.  A series of strips appears when the
window is hilited, and are gone when unhilited.

Both windows are visible and the mouse cursor is in either window, only the
active window is hilited (before both windows were hilited).

A time delay has been added for window hiliting/unhiliting so that the mouse
passing momentarily through a window will not cause it to hilite and then
unhilite when autoraise is on.

Automatic raising of windows has been added, so that the window is automatically
raised (after the time delay) when the mouse enters a window.  The mode is
turned on via .Xdefaults "xterm.AutoRaise on", via command line option -ar
or via the xterm menu.  This is a dubious feature.

Visual bell mode can be turned on via .Xdefaults "xterm.VisualBell on", via
command line option -vb and from the xterm menu.

If the NOWINDOWMENU is not defined, then
Control right button activates a windows menu that lists the visible (named)
windows in back to front order reading down.  Selecting a window name cause
that window to be raised to the top (useful for getting to a buried
window).  This feature does not belong in xterm, and will be
completely removed in V11 of X, where window managers can be more intellegent.

The tek window has the same name as the vt102 window, but with " (Tek)"
appended (before they were the same).

During startup, xterm tries to create unique window names so that the
windows menu will not contain ambiguous windows.  It does this by look
through the list of windows and if a name exist that is the same, " #N"
will be appended to make it unique (N is a number two or greater).

Some reorganization of the code and data has been done to put more data in
the text segment so many xterm processes can share the (read-only) data, rather
than having n copies in core.

There are several bug fixes including better sun compatibility and a problem
in the vt102 parse table.

With some mods to libX.a, xterm solves a problem of running xterm on a remote
host with a local window, when the remote host uses a different keymap (like
running on a remote microvax on a sun).  If the environment variable KEYBD
is set or the command line option "-kb name" is given, then a keymap file
with the given name is used, rather than the default of your .Xkeymap file.
Standard names for keymap files is yet to be made.  (This option is turned on
via defining KEYBD in the Makefile.)

Xterm now always creates its own icon(s), which includes the window's name.
The -i option now means startup showing the icon.  The option #[+-]x[+-]y
means to position the icon there instead of centered within the window.
The bitmap within the icon show the current active mode (either vt102 or
tek).  The icon reverse-videos with the windows.

By default, the icons are a miniture window and the window title.  The icon
can also be miniture versions of the window.  This is activated with .Xdefaults
"xterm.ActiveIcon on", -ai from the command line, or from the xterm menu.

The active icon does not normally allow input.  A menu selection in the xterm
menu will allow input to the icon.

When the mouse is in the stripped area of the titlebar, you can get any
of the three menus without pressing the control key.  Clicking in the
actual title iconifies.  Clicking in an icon deiconifies it.

Many mode option on the command line allow a '+' instead of '-' to indicate
turning off the indicated mode.

Color support has been improved, so that an unselected cursor is an empty
rectangle with the foreground color, and the selected cursor is a filled
rectangle with the cursor color.

A better and faster menu package has been added that supports (Mac-like)
checkmarks and dimmed (disabled and grayed) item, as well as line separator
items.

To conserve on resources, the unhilited border of the window(s) is now
always a gray pixmap, which is shared by the menu package.

Logging capability has been added, in which all characters sent to the
xterm window are recorded.  The mode is turned on by using .Xdefaults option
"xterm.Logging on", -l on the command line, from the xterm menu or the
escape sequence \E[?46h in vt102 mode.  Logging is turned off through the
xterm menu or \E[?46l in vt102 mode.  The default log file is XtermLog.XXXXX
(XXXXX is the process id of xterm) and is in the initial directory in which
xterm was started (the home directory for login xterms).  Each logging start
appends to the end of the loggin file, and each logging stop closes the file.

An alternate logging file may be given with .Xdefaults "xterm.LogFile file"
(file is the alternate filename) or with command line option "-lf file".
If the first character of the logfile name is `|', then the rest of the
name passed to the shell for execution and a pipe is created to the process.
In this case, each time the log is started, a new process is created and
when logging is turned off, the pipe is closed.  Thus, a logfile name of
"| lpr", will send text to the line printer each time logging is turned off.

Certain modes may be inhibited by specifying in the .Xdefaults file.  A
change to the initial logging mode may be prevented with "xterm.LogInhibit on",
which will prevent changes to logging from the menu or from escape sequences.
"xterm.SignalInhibit on" disables the xterm menu signal sending (Continue is
still allowed).  "xterm.TekInhibit on" prevents entering into Tektronix mode.

As per edjames@eros, xterm sets the environment variable WINDOWID, which
contains the Window id of the initial window (normally vt102, but could be
the tek window if the -t option were specified).  This "feature" is
bogus, as it may not always give you all information you need to
access a window.

The title in the title bar may be changed with the \E]0;new title\007 escape
sequence.  Any non-printing character terminates the title string.  The
windows and icons are also renamed, and the icons are resized to fit the
new title.

The log file may be changed with the \E]46;new log file\007 escape sequence.
If the log file name is empty, the default log file name is used.

In visual bell mode, the icons now flash on receipt of a control-G.

If xterm is iconified and new input comes in, a box is drawn around the
icon title.

The bitmap used for the icons is now user definable.  The VT102 bitmap may be
set with .Xdefaults "xterm.IconBitmap file" or with "-ib file" on the command
line.  The Tek bitmap may be set with .Xdefaults "xterm.TekIconBitmap file"
or with "-it file" on the command line.  These files are assumed to be
bitmap(1) format files.  If only one bitmap file is specified, it is used for
both modes.  If both are specified as null file names, then no bitmap is drawn.

Normally, the title text of the icon is displayed to the right of the
bitmap.  The text may be displayed under the bitmap by using .Xdefaults
"xterm.TextUnderIcon on" or with -ti on the command line.

The mouse may be automatically warpped to the xterm window when it is
deiconified by using .Xdefaults "xterm.DeiconifyWarp on" or using -dw on
the command line.  This is also of questionable merit.

The standard error output used by xterm is now improved.  Normally it will
be the same standard error when xterm is started.  For login xterms
(-L specified) then the standard error will be to /dev/console.

X error events are now intercepted so that xterm may cleanup before exiting
(like resetting the tty modes and clearing the /etc/utmp entry).

VT102
-----

vt102 emulation is much more complete than the original xterm.

Underlined characters is now supported.

A partial sun tty emulation is provided (x, y, w, h, c, r are numbers):
	\E[3;x;yt	move window to (x, y)
	\E[4;w;ht	resize window - width w, height h pixels
	\E[5t		raise window
	\E[6t		lower window
	\E[7t		redisplay window
	\E[8;r;ct	resize window - r rows, c columns
	\E[13t		send window position \E[3;x;yt
	\E[14t		send window size (pixel) \E[4;w;ht
	\E[18t		send window size (rows and columns) \E[8;r;ct

The text for reexcuting (shift-left button), copy (shift-middle button-drag)
and paste (shift-right button) is now hilited by reverse video.

Pasting text that was originally displayed as vt102 graphic characters now
returns the original ascii character (and not the internal representation).

Text that is scrolled off the top of the window can be saved and is accessable
via a scrollbar.  By default, saving is off and can be turned changed via
escape sequence \E[?43h (on) and \E[43l (off) or from the mode menu.  The
scrollbar is normally off, but may be made visible with .Xdefault option
"xterm.ScrollBar on" or command line option -sb.  The scrollbar state can
be changed via the mode menu or escape sequences \E[?42h (on) and \E[?42l
(off).

The scrollbar is composed of three parts (from top down), the scroll button,
the save button and the scroll region.  The scroll button changes what is
displayed in the window.  Left button pressed in the scroll button causes
the window to move one line up (the text scrolls one line down).  The right
button moves one line down.  Shift left button moves one screenful up and shift
right button moves one screenful down.  Control left button moves to the top
of the buffer, control right button moves to the bottom.  The visible area
is shown graphically in the scroll region, with the (usually) dark region
that part of the buffer that appears in the window.  Clicking the left or
right button in the scroll region cause the visible region to be position
with its top at the mouse position.  The save button shows the state of saving
or not saving lines.  By default, any input or output will return the
screen to the bottom.

The default maximum number of lines saved off the top is 64, but can be
specified in .Xdefaults as "xterm.SaveLines 100" for 100 lines, or as
a command line option "-sl 100".

The lines saved can be cleared via the mode menu.

A margin bell can be turned on via .Xdefaults "xterm.MarginBell on", command
line option -mb or mode menu.  The default number of columns from the right
margin is 10 and is settable via .Xdefaults "xterm.NMarginBell 15" for 15
columns, or via command line option -nb 15.  The mode may be changed by escape
sequence \E[?44h (on) and \E[?44l (off).

To emulate the vt102 switching between 80 and 132 columns, the mode may
be turned on via .Xdefaults "xterm.C132 on", via command line option -132 or
via the mode menu.  The mode may be changed by escape sequence \E[?40h (on)
and \E[?40l (off).

A mode that fixes a bug in curses (e.g. when using "more" on lines that have
lines that print on the last column of the line and the next line begins with
a tab) can be turned on .Xdefaults "xterm.Curses on", command line option
-cu or via the mode menu.  The mode may be changed by escape sequence
\E[?41h (on) and \E[?41l (off).

Auto linefeed mode and auto repeat are supported.

The mode menu is now more descriptive.

Most Dec Private mode settings can be save away internally using \E[?ns,
where n is the same number to set or reset the Dec Private mode.  The
mode can be restored using \E[?nr.  This can be used in termcap for vi, for
example, to turn off saving of lines, but restore whatever the original
state was on exit.

An optional status line (in reverse video) has been added to the bottom of
the vt102 window.  The following escape sequences work on the status line:
	\E[?S		show status line
	\E[?H		hide status line
	\E[?nT		enter status line, at column n
	\E[?F		return to the position before entry into status line
	\E[?E		erase status line
Also, the status line may be turned on via .Xdefaults "xterm.StatusLine on",
the -st commandline option or from the mode menu.

Reverse wraparound can be enabled with .Xdefaults "xterm.ReverseWrap on", via
command line option -rw or from the mode menu.  Also the escape sequences
\E[?45h turns on reverse wraparound and \E[?45l turns it off.  Reverse
wraparound only works when autowrap is also on and is useful, for instance,
when entering a long line that wraps to the shell and needing to erase
backwards to correct it.

The scrollbar code has been modified to use fewer pixmaps, and should work
better on the GPX.

An alternate screen buffer is now supported.  Entry into the alternate screen
buffer with \E[?47h will automatically inhibit lines from being saved off the
top of the window and \E[?47l returns to the normal screen buffer and restores
the original state of line saving.  The new termcap entry causes vi to use
the alternate screen buffer on entry and clears the alternate buffer before
returning to the regular buffer.

If the normal font is specified and the bold font isn't, then the bold font
is automatically created be overstring, ala dcmartin@ingres.

The scrollbar now has its own menu, available when the middle button is pressed
anywhere in the scrollbar.  The menu entries originally in the mode menu having
to do with the scrollbar have been moved to the scrollbar menu (except the
Scrollbar entry, to initially display the scrollbar).

The scroll bar may be repositioned automatically at the bottom when input comes
in by using .Xdefaults "xterm.ScrollInput on", using -si on the command line
or via the scrollbar menu.

The scroll bar may be repositioned automatically at the bottom when a key is
pressed by using .Xdefaults "xterm.ScrollKey on", using -sk on the command line
or via the scrollbar menu.

Normally the status line is displayed in reverse video.  A normal-video status
line may be obtained by using .Xdefaults "xterm.StatusNormal on", with
-sn on the command line or via the mode menu, or may be controlled with the
escape sequences \E[?48h (on) and \E[?48l (off).  In normal video mode, a
box is still drawn around the status line.

Page scroll mode may be activated by using .Xdefaults "xterm.PageScroll on",
using -ps on the command line or via the mode menu, or may be control by the
escape sequences \E[?49h (on) and \E[?49l (off).  In page scroll mode,
after a page of input has been displayed, further scrolling is disabled
and the text cursor is hidden.  Typing a carriage return allows another
line to be scrolled (the return is discarded).  Pressing the space bar (or any
other printable character) causes another page to be scrolled (the character
is discarded).  Typing a control character scrolls another page, but the
control character is sent (e.g., your interrupt character).

A page in page scroll mode is defined to be the number of lines in the current
scrolling region, minus the page overlap number.  The page overlap is one by
default, but may be set by .Xdefaults "xterm.PageOverlap 3" or via the
"-po 3" command line option.

Page scroll mode is automatically inhibited when using the alternate screen.

The icon windows are now named, with " (icon)" appended.  Thus, iconified
xterms now show up in the windows menu.

Tektronix
---------

Tek mode is much more complete than the original.

Tek standard two column mode is supported.

Four different character sizes are supported and can be changed via the
tek menu.

5 line types are supported (solid, dotted, short dashed, long dashed and
dot dashed).

All of the tek character sequences are stored and can be saved into a file
via the standard COPY escape sequence or from the mode menu.  The file created
is named COPYyy-mm-dd.hh:mm:ss (COPY plus the date and time) and is placed
in the initial directory in which xterm was started.  Login xterms use the
users home directory.

When the tek window is being refreshed, the mouse cursor shows a clock.

The X geometry of the Tek window can be given on the command line (independently
of the VT102 window) by using %geometry (`%' rather than `=').

In GIN mode, pressing a key will send the key and the mouse coordinates of
the cross cursor, similar to standard Tek GIN mode.  Pressing a mouse button
instead will send the character `l', `m' or `r' depending on whether the
left, middle or right button was pressed, respectively.  If the shift key was
down when the button was pressed, the corresponding upper case character is
sent.  To distinquish a button press from a key press, the high bit of the
character is set, but this is only useful if the tty mode is set to RAW to
pass all 8 bits.
RAZZLE!DAZZLE
fi	# End CHANGES
if test -f CHANGES.resize
then
	echo shar: will not overwrite existing file "'CHANGES.resize'"
else
echo 'x - CHANGES.resize'
cat << \RAZZLE!DAZZLE > CHANGES.resize
resize version X10/6.6
------ ------- -------

This version of resize uses the standard VT102 escape sequences as before.
In addition, there is a -s flag that will use the Sun tty emulation escape
sequences and allow the window to adjusted from the command line.  For example,
to change the window size to 35 rows by 80 columns, one can use:

	% set noglob; eval `resize -s 35 80`

The TERMCAP environment variable will be adjusted accordingly.

If a link is made from resize to sunsize, sunsize will use the sun emulation
exclusively (and should work under Suntools, also).

Before, resize could send an escape sequence and fscanf could returned before
xterm sends its escape sequence, thus failing.  Now the read is synchronized.

If no escape sequence is received from the terminal within 10 seconds, resize
terminates.
RAZZLE!DAZZLE
fi	# End CHANGES.resize
if test -f CHANGES.termcap
then
	echo shar: will not overwrite existing file "'CHANGES.termcap'"
else
echo 'x - CHANGES.termcap'
cat << \RAZZLE!DAZZLE > CHANGES.termcap
termcap version X10/6.4
------- ------- -------

This termcap contains the necessary modifications to access the status line
(by sysline, for instance) and to activate the alternate screen buffer when
entering vi.  Multiple insert and delete functions have been added.
RAZZLE!DAZZLE
fi	# End CHANGES.termcap
if test -f ONELINE
then
	echo shar: will not overwrite existing file "'ONELINE'"
else
echo 'x - ONELINE'
cat << \RAZZLE!DAZZLE > ONELINE
This is version X10/6.4 of xterm, the VT102/Tektronix 4014 terminal emulator.
RAZZLE!DAZZLE
fi	# End ONELINE
if test -f README
then
	echo shar: will not overwrite existing file "'README'"
else
echo 'x - README'
cat << \RAZZLE!DAZZLE > README
This is version X10/6.6 of xterm, the VT102/Tektronix 4014 terminal emulator.
This program has been greatly changed and enhanced by:

	Edward Moy
	Academic Computing Services
	University of California, Berkeley

	edmoy@opal.Berkeley.EDU
	ucbvax!opal!edmoy

Notable features in 6.6 include scrollbars, titlebars, new menus and a new
menu package, auto-raising of windows, visual bell, new icons, logging
capability, status line, reverse wraparound and an alternate screen buffer.
A more detailed description can be found in the CHANGES file.

Included here are the pre-compiled executables of xterm (and resize) for
the MicroVax (under Ultrix) and for Sun-3s.

NOTE:  I am keeping the official SCCS directory on my MicroVax.  Any changes
made here may not appear on later releases unless you tell me about them
and I feel they are useful (I'm fairly reasonable).
RAZZLE!DAZZLE
fi	# End README
if test -f Tekparse.h
then
	echo shar: will not overwrite existing file "'Tekparse.h'"
else
echo 'x - Tekparse.h'
cat << \RAZZLE!DAZZLE > Tekparse.h
/*
 *	$Source: /u1/X/xterm/RCS/Tekparse.h,v $
 *	$Header: Tekparse.h,v 10.100 86/12/01 14:39:07 jg Rel $
 */

/* @(#)Tekparse.h       X10/6.6B 12/26/86 */
#define	CASE_REPORT	0
#define	CASE_VT_MODE	(CASE_REPORT + 1)
#define	CASE_SPT_STATE	(CASE_VT_MODE + 1)
#define	CASE_GIN	(CASE_SPT_STATE + 1)
#define	CASE_BEL	(CASE_GIN + 1)
#define	CASE_BS		(CASE_BEL + 1)
#define	CASE_PT_STATE	(CASE_BS + 1)
#define	CASE_PLT_STATE	(CASE_PT_STATE + 1)
#define	CASE_TAB	(CASE_PLT_STATE + 1)
#define	CASE_IPL_STATE	(CASE_TAB + 1)
#define	CASE_ALP_STATE	(CASE_IPL_STATE + 1)
#define	CASE_UP		(CASE_ALP_STATE + 1)
#define	CASE_COPY	(CASE_UP + 1)
#define	CASE_PAGE	(CASE_COPY + 1)
#define	CASE_BES_STATE	(CASE_PAGE + 1)
#define	CASE_BYP_STATE	(CASE_BES_STATE + 1)
#define	CASE_IGNORE	(CASE_BYP_STATE + 1)
#define	CASE_ASCII	(CASE_IGNORE + 1)
#define	CASE_APL	(CASE_ASCII + 1)
#define	CASE_CHAR_SIZE	(CASE_APL + 1)
#define	CASE_BEAM_VEC	(CASE_CHAR_SIZE + 1)
#define	CASE_CURSTATE	(CASE_BEAM_VEC + 1)
#define	CASE_PENUP	(CASE_CURSTATE + 1)
#define	CASE_PENDOWN	(CASE_PENUP + 1)
#define	CASE_IPL_POINT	(CASE_PENDOWN + 1)
#define	CASE_PLT_VEC	(CASE_IPL_POINT + 1)
#define	CASE_PT_POINT	(CASE_PLT_VEC + 1)
#define	CASE_SPT_POINT	(CASE_PT_POINT + 1)
#define	CASE_CR		(CASE_SPT_POINT + 1)
#define	CASE_ESC_STATE	(CASE_CR + 1)
#define	CASE_LF		(CASE_ESC_STATE + 1)
#define	CASE_SP		(CASE_LF + 1)
#define	CASE_PRINT	(CASE_SP + 1)
#define	CASE_OSC	(CASE_PRINT + 1)
RAZZLE!DAZZLE
fi	# End Tekparse.h
if test -f VTparse.h
then
	echo shar: will not overwrite existing file "'VTparse.h'"
else
echo 'x - VTparse.h'
cat << \RAZZLE!DAZZLE > VTparse.h
/*
 *	$Source: /u1/X/xterm/RCS/VTparse.h,v $
 *	$Header: VTparse.h,v 10.101 86/12/01 21:49:38 jg Rel $
 */

/* @(#)VTparse.h       X10/6.6B 12/26/86 */
#define	CASE_GROUND_STATE	0
#define	CASE_IGNORE_STATE	(CASE_GROUND_STATE+1)
#define	CASE_IGNORE_ESC		(CASE_IGNORE_STATE+1)
#define	CASE_IGNORE		(CASE_IGNORE_ESC+1)
#define	CASE_BELL		(CASE_IGNORE+1)
#define	CASE_BS			(CASE_BELL+1)
#define	CASE_CR			(CASE_BS+1)
#define	CASE_ESC		(CASE_CR+1)
#define	CASE_VMOT		(CASE_ESC+1)
#define	CASE_TAB		(CASE_VMOT+1)
#define	CASE_SI			(CASE_TAB+1)
#define	CASE_SO			(CASE_SI+1)
#define	CASE_SCR_STATE		(CASE_SO+1)
#define	CASE_SCS0_STATE		(CASE_SCR_STATE+1)
#define	CASE_SCS1_STATE		(CASE_SCS0_STATE+1)
#define	CASE_SCS2_STATE		(CASE_SCS1_STATE+1)
#define	CASE_SCS3_STATE		(CASE_SCS2_STATE+1)
#define	CASE_ESC_IGNORE		(CASE_SCS3_STATE+1)
#define	CASE_ESC_DIGIT		(CASE_ESC_IGNORE+1)
#define	CASE_ESC_SEMI		(CASE_ESC_DIGIT+1)
#define	CASE_DEC_STATE		(CASE_ESC_SEMI+1)
#define	CASE_ICH		(CASE_DEC_STATE+1)
#define	CASE_CUU		(CASE_ICH+1)
#define	CASE_CUD		(CASE_CUU+1)
#define	CASE_CUF		(CASE_CUD+1)
#define	CASE_CUB		(CASE_CUF+1)
#define	CASE_CUP		(CASE_CUB+1)
#define	CASE_ED			(CASE_CUP+1)
#define	CASE_EL			(CASE_ED+1)
#define	CASE_IL			(CASE_EL+1)
#define	CASE_DL			(CASE_IL+1)
#define	CASE_DCH		(CASE_DL+1)
#define	CASE_DA1		(CASE_DCH+1)
#define	CASE_TBC		(CASE_DA1+1)
#define	CASE_SET		(CASE_TBC+1)
#define	CASE_RST		(CASE_SET+1)
#define	CASE_SGR		(CASE_RST+1)
#define	CASE_CPR		(CASE_SGR+1)
#define	CASE_DECSTBM		(CASE_CPR+1)
#define	CASE_SUN_EMU		(CASE_DECSTBM+1)
#define	CASE_DECREQTPARM	(CASE_SUN_EMU+1)
#define	CASE_DECSET		(CASE_DECREQTPARM+1)
#define	CASE_DECRST		(CASE_DECSET+1)
#define	CASE_HIDDEN		(CASE_DECRST+1)
#define	CASE_DECALN		(CASE_HIDDEN+1)
#define	CASE_GSETS		(CASE_DECALN+1)
#define	CASE_DECSC		(CASE_GSETS+1)
#define	CASE_DECRC		(CASE_DECSC+1)
#define	CASE_DECKPAM		(CASE_DECRC+1)
#define	CASE_DECKPNM		(CASE_DECKPAM+1)
#define	CASE_IND		(CASE_DECKPNM+1)
#define	CASE_NEL		(CASE_IND+1)
#define	CASE_HTS		(CASE_NEL+1)
#define	CASE_RI			(CASE_HTS+1)
#define	CASE_SS2		(CASE_RI+1)
#define	CASE_SS3		(CASE_SS2+1)
#define	CASE_CSI_STATE		(CASE_SS3+1)
#define	CASE_OSC		(CASE_CSI_STATE+1)
#define	CASE_RIS		(CASE_OSC+1)
#define	CASE_LS2		(CASE_RIS+1)
#define	CASE_LS3		(CASE_LS2+1)
#define	CASE_LS3R		(CASE_LS3+1)
#define	CASE_LS2R		(CASE_LS3R+1)
#define	CASE_LS1R		(CASE_LS2R+1)
#define	CASE_PRINT		(CASE_LS1R+1)
#define	CASE_TO_STATUS		(CASE_PRINT+1)
#define	CASE_FROM_STATUS	(CASE_TO_STATUS+1)
#define	CASE_SHOW_STATUS	(CASE_FROM_STATUS+1)
#define	CASE_HIDE_STATUS	(CASE_SHOW_STATUS+1)
#define	CASE_ERASE_STATUS	(CASE_HIDE_STATUS+1)
#define	CASE_XTERM_SAVE		(CASE_ERASE_STATUS+1)
#define	CASE_XTERM_RESTORE	(CASE_XTERM_SAVE+1)
RAZZLE!DAZZLE
fi	# End VTparse.h
if test -f bottom.ic
then
	echo shar: will not overwrite existing file "'bottom.ic'"
else
echo 'x - bottom.ic'
cat << \RAZZLE!DAZZLE > bottom.ic
/* @(#)bottom.ic       X10/6.6B 12/26/86 */
#define bottom_width 19
#define bottom_height 19
static short bottom_bits[] = {
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x8008, 0x0000,
   0x8008, 0x0000, 0x8008, 0x0000,
   0x8008, 0x0000, 0x8008, 0x0000,
   0x8708, 0x0000, 0x8708, 0x0000,
   0x9fc8, 0x0000, 0x8f88, 0x0000,
   0x8708, 0x0000, 0x8208, 0x0000,
   0xfff8, 0x0000, 0xfff8, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000};
RAZZLE!DAZZLE
fi	# End bottom.ic
if test -f button.ic
then
	echo shar: will not overwrite existing file "'button.ic'"
else
echo 'x - button.ic'
cat << \RAZZLE!DAZZLE > button.ic
/* @(#)button.ic       X10/6.6B 12/26/86 */
#define button_width 19
#define button_height 19
static short button_bits[] = {
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x0200, 0x0000,
   0x0700, 0x0000, 0x0f80, 0x0000,
   0x1fc0, 0x0000, 0x0700, 0x0000,
   0x0700, 0x0000, 0x0000, 0x0000,
   0x0700, 0x0000, 0x0700, 0x0000,
   0x1fc0, 0x0000, 0x0f80, 0x0000,
   0x0700, 0x0000, 0x0200, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000};
RAZZLE!DAZZLE
fi	# End button.ic
if test -f dark.ic
then
	echo shar: will not overwrite existing file "'dark.ic'"
else
echo 'x - dark.ic'
cat << \RAZZLE!DAZZLE > dark.ic
/* @(#)dark.ic       X10/6.6B 12/26/86 */
#define dark_width 16
#define dark_height 16
static short dark_bits[] = {
   0xeeee, 0xffff, 0xbbbb, 0xffff,
   0xeeee, 0xffff, 0xbbbb, 0xffff,
   0xeeee, 0xffff, 0xbbbb, 0xffff,
   0xeeee, 0xffff, 0xbbbb, 0xffff};
RAZZLE!DAZZLE
fi	# End dark.ic
if test -f data.h
then
	echo shar: will not overwrite existing file "'data.h'"
else
echo 'x - data.h'
cat << \RAZZLE!DAZZLE > data.h
/*
 *	$Source: /u1/X/xterm/RCS/data.h,v $
 *	$Header: data.h,v 10.101 86/12/01 16:57:37 swick Rel $
 */

/* @(#)data.h       X10/6.6B 12/26/86 */
extern Pixmap B_Pixmap;
extern Pixmap W_Pixmap;
extern TekLink *TekRefresh;
extern Terminal term;
extern Vertex T_box2[];
extern Vertex T_box3[];
extern Vertex T_boxlarge[];
extern Vertex T_boxsmall[];
extern Vertex T_boxicon[];
extern Vertex VTbox[];
extern Vertex icon_box[];
extern T_fontsize Tfontsize[];
extern Vertex status_box[];
extern char *T_geometry;
extern char *Tbptr;
extern char *Tbuffer;
extern char *Tpushb;
extern char *Tpushback;
extern char *back_color;
extern char *bptr;
extern char *curs_color;
extern char *f_b;
extern char *f_n;
extern char *f_i;
extern char *f_t;
extern char *fore_color;
extern char *geo_metry;
extern char *icon_geom;
extern char log_def_name[];
extern char *mous_color;
extern char *ptydev;
extern char *ttydev;
extern char *win_name;
extern char *xterm_name;
extern char buffer[];
extern int B_Pixel;
extern int L_flag;
extern int Select_mask;
extern int T_lastx;
extern int T_lasty;
extern int Tbcnt;
extern int Ttoggled;
extern int W_Pixel;
extern int X_mask;
extern int am_slave;
extern int bcnt;
#ifdef DEBUG
extern int debug;
#endif DEBUG
extern int errno;
extern int max_plus1;
extern int n_marginbell;
extern int pty_mask;
extern int re_verse;
extern int save_lines;
extern int switchfb[];
extern jmp_buf Tekend;
extern jmp_buf VTend;
RAZZLE!DAZZLE
fi	# End data.h
if test -f downline.ic
then
	echo shar: will not overwrite existing file "'downline.ic'"
else
echo 'x - downline.ic'
cat << \RAZZLE!DAZZLE > downline.ic
/* @(#)downline.ic       X10/6.6B 12/26/86 */
#define downline_width 19
#define downline_height 19
static short downline_bits[] = {
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0xef78, 0x0000, 0x0000, 0x0000,
   0xdbb8, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x0700, 0x0000,
   0x0700, 0x0000, 0x1fc0, 0x0000,
   0x0f80, 0x0000, 0x0700, 0x0000,
   0x0200, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000};
RAZZLE!DAZZLE
fi	# End downline.ic
if test -f downpage.ic
then
	echo shar: will not overwrite existing file "'downpage.ic'"
else
echo 'x - downpage.ic'
cat << \RAZZLE!DAZZLE > downpage.ic
/* @(#)downpage.ic       X10/6.6B 12/26/86 */
#define downpage_width 19
#define downpage_height 19
static short downpage_bits[] = {
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x7f00, 0x0000,
   0x4180, 0x0000, 0x4140, 0x0000,
   0x4120, 0x0000, 0x41f0, 0x0000,
   0x4710, 0x0000, 0x4710, 0x0000,
   0x5fd0, 0x0000, 0x4f90, 0x0000,
   0x4710, 0x0000, 0x4210, 0x0000,
   0x4010, 0x0000, 0x7ff0, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000};
RAZZLE!DAZZLE
fi	# End downpage.ic
if test -f error.h
then
	echo shar: will not overwrite existing file "'error.h'"
else
echo 'x - error.h'
cat << \RAZZLE!DAZZLE > error.h
/*
 *	$Source: /u1/X/xterm/RCS/error.h,v $
 *	$Header: error.h,v 10.100 86/12/01 14:39:28 jg Rel $
 */

/* @(#)error.h       X10/6.6B 12/26/86 */
/* main.c */
#define	ERROR_KMALLOC	10	/* main: malloc() failed for keyboardtype */
#define	ERROR_FIONBIO	11	/* main: ioctl() failed on FIONBIO */
#define	ERROR_TSLOT	12	/* spawn: tslot() failed and getty */
#define	ERROR_TSLOT2	13	/* spawn: tslot() failed and am_slave */
#define	ERROR_OPDEVTTY	14	/* spawn: open() failed on /dev/tty */
#define	ERROR_TIOCGETP	15	/* spawn: ioctl() failed on TIOCGETP */
#define	ERROR_TIOCGETC	16	/* spawn: ioctl() failed on TIOCGETC */
#define	ERROR_TIOCGETD	17	/* spawn: ioctl() failed on TIOCGETD */
#define	ERROR_TIOCGLTC	18	/* spawn: ioctl() failed on TIOCGLTC */
#define	ERROR_TIOCLGET	19	/* spawn: ioctl() failed on TIOCLGET */
#define	ERROR_TIOCCONS	20	/* spawn: ioctl() failed on TIOCCONS */
#define	ERROR_OPDEVTTY2	21	/* spawn: second open() failed on /dev/tty */
#define	ERROR_NOTTY	22	/* spawn: ioctl() failed on TIOCNOTTY */
#define	ERROR_TIOCSETP	23	/* spawn: ioctl() failed on TIOCSETP */
#define	ERROR_TIOCSETC	24	/* spawn: ioctl() failed on TIOCSETC */
#define	ERROR_TIOCSETD	25	/* spawn: ioctl() failed on TIOCSETD */
#define	ERROR_TIOCSLTC	26	/* spawn: ioctl() failed on TIOCSLTC */
#define	ERROR_TIOCLSET	27	/* spawn: ioctl() failed on TIOCLSET */
#define	ERROR_TSLOT3	28	/* spawn: tslot() failed  */
#define	ERROR_FORK	29	/* spawn: fork() failed */
#define	ERROR_EXEC	30	/* spawn: exec() failed */
#define	ERROR_OPDEVTTY3	31	/* spawn: third open() failed on /dev/tty */
#define	ERROR_PTYS	32	/* get_pty: not enough ptys */
#define	ERROR_NOX	33	/* get_terminal: can't connect to server */
#define	ERROR_NOX2	34	/* get_terminal: can't connect and getty */
#define	ERROR_TITLEFONT	35	/* get_terminal: can't open title font */
#define	ERROR_INIT	36	/* spawn: can't initialize window */
#define	ERROR_NOCO	37	/* resize: no `co' in termcap */
#define	ERROR_NOLI	38	/* resize: no `li' in termcap */
#define	ERROR_BORDER	39	/* get_terminal: can't make border tile */
#define	ERROR_BACK	40	/* get_terminal: can't make background tile */
/* charproc.c */
#define	ERROR_SELECT	50	/* in_put: select() failed */
#define	ERROR_CRTITLE	51	/* VTTitleInit: XCreateWindow() failed */
#define	ERROR_HILITE	52	/* VTTitleInit: make_hilite() failed */
#define	ERROR_CRLFRG	53	/* VTTitleInit: XCreateWindows() failed */
#define	ERROR_VINIT	54	/* VTInit: can't initialize window */
#define	ERROR_RTMALLOC1	55	/* VTRetitle: malloc failed */
#define	ERROR_RTMALLOC2	56	/* VTRetitle: malloc failed */
/* Tekproc.c */
#define	ERROR_TSELECT	60	/* Tinput: select() failed */
#define	ERROR_TCRTITLE	61	/* TekTitleInit: XCreateWindow() failed */
#define	ERROR_THILITE	62	/* TekTitleInit: make_hilite() failed */
#define	ERROR_TCRLFRG	63	/* TekTitleInit: XCreateWindows() failed */
#define	ERROR_TINIT	64	/* TekInit: can't initialize window */
#define	ERROR_TBACK	65	/* TekBackground: can't make background */
#define	ERROR_TWINNAME	66	/* TekInit: malloc failed */
/* button.c */
#define	ERROR_BMALLOC	70	/* GetRestOfLine: malloc() failed */
#define	ERROR_BMALLOC2	71	/* SaltTextAway: malloc() failed */
/* misc.c */
#define	ERROR_LOGEXEC	80	/* StartLog: exec() failed */
#define	ERROR_OPENBITMAP 81	/* IconInit: XReadBitmapFile returns zero */
#define	ERROR_SYNTAXBITMAP 82	/* IconInit: XReadBitmapFile returns negative */
#define	ERROR_XERROR	83	/* xerror: XError event */
#define	ERROR_XIOERROR	84	/* xioerror: X I/O error */
#define	ERROR_WINNAME	85	/* IconInit: malloc failed */
/* screen.c */
#define	ERROR_SCALLOC	90	/* Alloc: calloc() failed on base */
#define	ERROR_SCALLOC2	91	/* Alloc: calloc() failed on rows */
#define	ERROR_SREALLOC	92	/* ScreenResize: realloc() failed on alt base */
#define	ERROR_SREALLOC2	93	/* ScreenResize: realloc() failed on alt rows */
#define	ERROR_SREALLOC3	94	/* ScreenResize: realloc() failed on rows */
#define	ERROR_SREALLOC4	95	/* ScreenResize: realloc() failed on rows */
#define	ERROR_RESIZE	96	/* ScreenResize: malloc() or realloc() failed */
#define	ERROR_RESIZE2	97	/* ScreenResize: malloc() or realloc() failed */
#define	ERROR_RESIZROW	98	/* ScreenResize: realloc() failed on alt char */
#define	ERROR_RESIZROW2	99	/* ScreenResize: realloc() failed on alt attr */
#define	ERROR_RESIZROW3	100	/* ScreenResize: realloc() failed on attr */
#define	ERROR_RESIZROW4	101	/* ScreenResize: realloc() failed on attr */
/* scrollbar.c */
#define	ERROR_SBRALLOC	110	/* ScrollBarOn: realloc() failed on base */
#define	ERROR_SBRALLOC2	111	/* ScrollBarOn: realloc() failed on rows */
/* util.c */
#define	ERROR_UBACK	120	/* ReverseVideo: can't make background */
RAZZLE!DAZZLE
fi	# End error.h
if test -f gray.ic
then
	echo shar: will not overwrite existing file "'gray.ic'"
else
echo 'x - gray.ic'
cat << \RAZZLE!DAZZLE > gray.ic
/* @(#)gray.ic       X10/6.6B 12/26/86 */
#define gray_width 16
#define gray_height 16
static short gray_bits[] = {
   0x5555, 0xaaaa, 0x5555, 0xaaaa,
   0x5555, 0xaaaa, 0x5555, 0xaaaa,
   0x5555, 0xaaaa, 0x5555, 0xaaaa,
   0x5555, 0xaaaa, 0x5555, 0xaaaa};
RAZZLE!DAZZLE
fi	# End gray.ic
if test -f hilite.ic
then
	echo shar: will not overwrite existing file "'hilite.ic'"
else
echo 'x - hilite.ic'
cat << \RAZZLE!DAZZLE > hilite.ic
/* @(#)hilite.ic       X10/6.6B 12/26/86 */
#define hilite_width 16
#define hilite_height 16
static short hilite_bits[] = {
   0xffff, 0x0000, 0xffff, 0x0000,
   0xffff, 0x0000, 0xffff, 0x0000,
   0xffff, 0x0000, 0xffff, 0x0000,
   0xffff, 0x0000, 0xffff, 0x0000};
RAZZLE!DAZZLE
fi	# End hilite.ic
if test -f icon.ic
then
	echo shar: will not overwrite existing file "'icon.ic'"
else
echo 'x - icon.ic'
cat << \RAZZLE!DAZZLE > icon.ic
/* @(#)icon.ic       X10/6.6B 12/26/86 */
#define icon_width 32
#define icon_height 24
static short icon_bits[] = {
   0xffff, 0xffff, 0x5001, 0x8005,
   0xaffd, 0xbffa, 0x5001, 0x8005,
   0xffff, 0xffff, 0x0001, 0xd800,
   0xf33d, 0xa866, 0x0001, 0xf800,
   0x9e71, 0xa8f3, 0x0001, 0xd800,
   0xe77d, 0xf838, 0x0001, 0x8800,
   0x7339, 0x883d, 0x0001, 0x8800,
   0xde7d, 0x8873, 0x0001, 0x8800,
   0xfbb1, 0xd8f6, 0x0001, 0xa800,
   0x77bd, 0xd8ef, 0x0001, 0xa800,
   0xbbb9, 0xd877, 0x0001, 0xa800,
   0x0001, 0xd800, 0xffff, 0xffff};
RAZZLE!DAZZLE
fi	# End icon.ic
if test -f light.ic
then
	echo shar: will not overwrite existing file "'light.ic'"
else
echo 'x - light.ic'
cat << \RAZZLE!DAZZLE > light.ic
/* @(#)light.ic       X10/6.6B 12/26/86 */
#define light_width 16
#define light_height 16
static short light_bits[] = {
   0x1111, 0x0000, 0x4444, 0x0000,
   0x1111, 0x0000, 0x4444, 0x0000,
   0x1111, 0x0000, 0x4444, 0x0000,
   0x1111, 0x0000, 0x4444, 0x0000};
RAZZLE!DAZZLE
fi	# End light.ic
if test -f ptyx.h
then
	echo shar: will not overwrite existing file "'ptyx.h'"
else
echo 'x - ptyx.h'
cat << \RAZZLE!DAZZLE > ptyx.h
/*
 *	$Source: /u1/X/xterm/RCS/ptyx.h,v $
 *	$Header: ptyx.h,v 10.101 86/12/01 16:57:15 swick Rel $
 */

#include <X/mit-copyright.h>

/*	Copyright	Massachusetts Institute of Technology	1984, 1985 */

/* ptyx.h */
/* @(#)ptyx.h       X10/6.6B 12/26/86 */

#define	FALSE		0
#define	TRUE		1

#define MAX_COLS	200
#define MAX_ROWS	128

/*
 * The origin of a screen is 0, 0.  Therefore, the number of rows
 * on a screen is screen->max_row + 1, and similarly for columns.
 */

typedef char **ScrnBuf;

/*
 * ANSI emulation.
 */
#define INQ	0x05
#define	FF	0x0C			/* C0, C1 control names		*/
#define	LS1	0x0E
#define	LS0	0x0F
#define	CAN	0x18
#define	SUB	0x1A
#define	ESC	0x1B
#define US	0x1F
#define	DEL	0x7F
#define HTS     ('H'+0x40')
#define	SS2	0x8E
#define	SS3	0x8F
#define	DCS	0x90
#define	OLDID	0x9A			/* ESC Z			*/
#define	CSI	0x9B
#define	ST	0x9C
#define	OSC	0x9D
#define	PM	0x9E
#define	APC	0x9F
#define	RDEL	0xFF

#define	NBOX	5			/* Number of Vertices in box	*/
#define	NPARAM	10			/* Max. parameters		*/

#define	MINHILITE	32
#define	TITLEPAD	4

typedef struct {
	unsigned char	a_type;
	unsigned char	a_pintro;
	unsigned char	a_final;
	unsigned char	a_inters;
	char	a_nparam;		/* # of parameters		*/
	char	a_dflt[NPARAM];		/* Default value flags		*/
	short	a_param[NPARAM];	/* Parameters			*/
	char	a_nastyf;		/* Error flag			*/
} ANSI;

typedef struct {
	int		row;
	int		col;
	unsigned	flags;	/* Vt100 saves graphics rendition. Ugh! */
	char		curgl;
	char		curgr;
	char		gsets[4];
} SavedCursor;

#define	TEKNUMFONTS	5
/* Actually there are 5 types of lines, but four are non-solid lines */
#define	TEKNUMLINES	4

typedef struct {
	int	x;
	int	y;
	int	fontsize;
	int	linetype;
} Tmodes;

typedef struct {
	int Twidth;
	int Theight;
} T_fontsize;

typedef struct {
	Window tbar;			/* major window			*/
	Window left;			/* left hilited window		*/
	Window right;			/* right hilited window		*/
	int hilited;			/* in hilite state		*/
	int x;				/* x position of title		*/
	int y;				/* y position of title		*/
	int fullwidth;			/* full width of title		*/
	int width;			/* width of visible part of title */
} TitleBar;

typedef struct {
	short *bits;
	int x;
	int y;
	int width;
	int height;
} BitmapBits;

typedef struct {
/* These parameters apply to both windows */
	Display		*display;	/* X display for screen		*/
	int		respond;	/* socket for responses
					   (position report, etc.)	*/
	long		pid;		/* pid of process on far side   */
	int		uid;		/* user id of actual person	*/
	int		gid;		/* group id of actual person	*/
	int		color;		/* colors used			*/
	int		foreground;	/* foreground color		*/
	int		background;	/* Background color		*/
	int		cursorcolor;	/* Cursor color			*/
	int		mousecolor;	/* Mouse color			*/
	Pixmap		bgndtile;	/* background tile pixmap	*/
	int		border;		/* inner border			*/
	int 	    	borderwidth;	/* outer border	    	    	*/
	Pixmap		bordertile;	/* tile pixmap for border	*/
	Pixmap		graybordertile;	/* tile pixmap for border when
						window is unselected	*/
	Cursor		arrow;		/* arrow cursor			*/
	unsigned short	send_mouse_pos;	/* user wants mouse transition  */
					/* and position information	*/
	int		select;		/* xterm selected		*/
	struct timeval	*timeout;	/* timeout value for select	*/
	FontInfo	*titlefont;	/* font info for title font	*/
	int		titleheight;	/* height of title		*/
	int		title_n_size;	/* width on 'n' in title font	*/
	Pixmap		hilitetile;	/* tile pixmap for title hilite	*/
	int		autoraise;	/* auto raise window mode	*/
	Window		autowindow;	/* the window to autoraise	*/
	int		timer;		/* timer function		*/
	int		holdoff;	/* delay select and unselects	*/
	int		visualbell;	/* visual bell mode		*/
	int		icon_show;	/* icon currently showing	*/
        int             textundericon;  /* text under icon              */
        int             bitmapwidth;    /* width of icon bitmap         */
        int             bitmapheight;   /* height of icon bitmap        */
        int             icon_text_x;    /* x position of text           */
        int             icon_text_y;    /* y position of text           */
	BitmapBits	iconbitmap;	/* bitmap for icon		*/
        int             iconinput;      /* got input while iconified    */
	int		active_icon;	/* icon is miniature copy	*/
	int		deiconwarp;	/* warp mouse on deiconify	*/
	int		logging;	/* logging mode			*/
	int		logfd;		/* file descriptor of log	*/
	char		*logfile;	/* log file name		*/
	char		*logstart;	/* current start of log buffer	*/
	int		inhibit;	/* flags for inhibiting changes	*/

/* VT window parameters */
	int		show;		/* window showing		*/
	int		iconunmap;	/* unmapped because of icon	*/
	struct {
		Window	window;		/* X window id			*/
		int	width;		/* width of columns		*/
		int	height;		/* height of rows		*/
		int	fullwidth;	/* full width of window		*/
		int	fullheight;	/* full height of window	*/
		int	f_width;	/* width of fonts in pixels	*/
		int	f_height;	/* height of fonts in pixels	*/
		int	titlebar;	/* title bar(s) showing		*/
	} fullVwin, iconVwin, *mappedVwin;
	Font		fnt_icon;	/* icon font			*/
	int		minrows;	/* minimun number of rows to
						accommodate scrollbar	*/
	Cursor		curs;		/* cursor resource from X	*/
	/* Terminal fonts must be of the same size and of fixed width */
	Font		fnt_norm;	/* normal font of terminal	*/
	Font		fnt_bold;	/* bold font of terminal	*/
	int		enbolden;	/* overstrike for bold font	*/
	Vertex		*box;		/* draw unselected cursor	*/

	int		cursor_state;	/* ON or OFF			*/
	int		cursor_set;	/* requested state		*/
	int		cursor_col;	/* previous cursor column	*/
	int		cursor_row;	/* previous cursor row		*/
	int		cur_col;	/* current cursor column	*/
	int		cur_row;	/* current cursor row		*/
	int		max_col;	/* rightmost column		*/
	int		max_row;	/* bottom row			*/
	int		top_marg;	/* top line of scrolling region */
	int		bot_marg;	/* bottom line of  "	    "	*/
	int		scrollbar;	/* if > 0, width of scrollbar, and
						scrollbar showing	*/
	int		topline;	/* line number of top, <= 0	*/
	int		savelines;	/* number of lines off top to save */
	int		scrollinput;	/* scroll to bottom on input	*/
	int		scrollkey;	/* scroll to bottom on key	*/
	
	ScrnBuf		buf;		/* screen buffer (main)		*/
	ScrnBuf		allbuf;		/* screen buffer (may include
					   lines scrolled off top	*/
	ScrnBuf		altbuf;		/* alternate screen buffer	*/
	int		alternate;	/* true if using alternate buf	*/
	ScrollBar	*sb;		/* pointer to scrollbar struct	*/
	unsigned short	do_wrap;	/* true if cursor in last column
					   and character just output    */
	int		incopy;		/* 0 if no RasterCopy exposure
					   event processed since last
					   RasterCopy			*/
	int		c132;		/* allow change to 132 columns	*/
	int		curses;		/* cludge-ups for more and vi	*/
	int		marginbell;	/* true if margin bell on	*/
	int		nmarginbell;	/* columns from right margin	*/
	int		bellarmed;	/* cursor below bell margin	*/
#ifdef CROCKSCROLL
	int		scrollincr;	/* scroll increment		*/
#endif
	unsigned int	multiscroll;	/* true if multi-scroll		*/
	int		scrolls;	/* outstanding scroll count	*/
	SavedCursor	sc;		/* data for restore cursor	*/
	TitleBar	title;		/* title bar			*/
	int		statusline;	/* status line showing		*/
	int		statusheight;	/* status line height		*/
	int		instatus;	/* cursor in status line	*/
	SavedCursor	statussc;	/* status line restore cursor	*/
	int		reversestatus;	/* status line reversed		*/
	char		*winname;	/* name of window (and icons)	*/
	int		winnamelen;	/* length of window name	*/
	int		save_modes[19];	/* save dec private modes	*/
	int		pagemode;	/* true if page mode		*/
	int		pagecnt;	/* count of lines in page mode	*/
	int		pageoverlap;	/* lines to overlap (less one)	*/

	/* Improved VT100 emulation stuff.				*/
	char		gsets[4];	/* G0 through G3.		*/
	char		curgl;		/* Current GL setting.		*/
	char		curgr;		/* Current GR setting.		*/
	char		curss;		/* Current single shift.	*/
	int		scroll_amt;	/* amount to scroll		*/
	int		refresh_amt;	/* amount to refresh		*/
	int		jumpscroll;	/* whether we should jumpscroll */

/* Tektronix window parameters */
	int		Tforeground;	/* foreground color		*/
	int		Tbackground;	/* Background color		*/
	int		Tcursorcolor;	/* Cursor color			*/
	Pixmap		Tbgndtile;	/* background tile pixmap	*/
	int		Tcolor;		/* colors used			*/
	int		planeused;	/* is xorplane being used	*/
	int		cellsused;	/* are color cells being used	*/
	Color		colorcells[3];	/* color cells for Tek		*/
	int		Tshow;		/* Tek window showing		*/
	int		Ticonunmap;	/* unmapped because of icon	*/
	int		waitrefresh;	/* postpone refresh		*/
	struct {
		Window	window;		/* X window id			*/
		int	width;		/* width of columns		*/
		int	height;		/* height of rows		*/
		int	fullwidth;	/* full width of window		*/
		int	fullheight;	/* full height of window	*/
		int	titlebar;	/* title bar(s) showing		*/
		double	tekscale;	/* scale factor Tek -> vs100	*/
	} fullTwin, iconTwin, *mappedTwin;
	BitmapBits	Ticonbitmap;	/* bitmap for icon		*/
	Vertex		**Tbox;		/* draw unselected cursor	*/
	int		xorplane;	/* z plane for inverts		*/
	Pattern		linepat[TEKNUMLINES]; /* line patterns		*/
	Font		Tfont[TEKNUMFONTS]; /* Tek fonts		*/
	int		tobaseline[TEKNUMFONTS]; /* top to baseline for
							each font	*/
	int		TekEmu;		/* true if Tektronix emulation	*/
	int		cur_X;		/* current x			*/
	int		cur_Y;		/* current y			*/
	Tmodes		cur;		/* current tek modes		*/
	Tmodes		page;		/* starting tek modes on page	*/
	int		margin;		/* 0 -> margin 1, 1 -> margin 2	*/
	int		pen;		/* current Tektronix pen 0=up, 1=dn */
	char		*TekGIN;	/* nonzero if Tektronix GIN mode*/
	TitleBar	Ttitle;		/* title bar			*/
	char		*Twinname;	/* name of window		*/
	int		Twinnamelen;	/* length of window name	*/
} Screen;

/* meaning of bits in screen.select flag */
#define	INWINDOW	01	/* the mouse is in one of the windows */
#define	FOCUS		02	/* one of the windows is the focus window */

typedef struct
{
	unsigned	offset;		/* status of shift, control, meta */
#define SHIFT	0x0001
#define META	0x0002
#define CONTROL	0x0004

	unsigned	flags;
} Keyboard;

/* define masks for flags */
#define CAPS_LOCK	0x01
#define KYPD_APL	0x02
#define CURSOR_APL	0x04


#define N_MARGINBELL	10
#define MAX_TABS	320
#define TAB_ARRAY_SIZE	10	/* number of ints to provide MAX_TABS bits */

typedef unsigned Tabs [TAB_ARRAY_SIZE];


#define BUF_SIZE 4096

typedef struct
{
	Keyboard	keyboard;	/* terminal keyboard		*/
	Screen		screen;		/* terminal screeen		*/
	unsigned	flags;		/* mode flags			*/
	unsigned	initflags;	/* initial mode flags		*/
	Tabs		tabs;		/* tabstops of the terminal	*/
} Terminal;


/* masks for terminal flags */

#define INVERSE		0x01	/* invert the characters to be output */
#define UNDERLINE	0x02	/* true if underlining */
#define BOLD		0x04
#define WRAPAROUND	0x08
#define REVERSE_VIDEO	0x10	/* true if screen white on black */
#define ORIGIN		0x20	/* true if in origin mode */
#define INSERT		0x40	/* true if in insert mode */
#define SMOOTHSCROLL	0x80	/* true if in smooth scroll mode */
#define AUTOREPEAT	0x100	/* true if in autorepeat mode */
#define IN132COLUMNS	0x200	/* true if in 132 column mode */
#define LINEFEED	0x400
#define	REVERSEWRAP	0x800	/* true if reverse wraparound mode */
#define ICONINPUT	0x1000	/* true if mini icon accepts kbd input */

#define	ATTRIBUTES	0x07	/* attributes mask */
#define CHAR		0177

#define VWindow(screen)		(screen->mappedVwin->window)
#define TWindow(screen)		(screen->mappedTwin->window)
#define Width(screen)		(screen->mappedVwin->width)
#define Height(screen)		(screen->mappedVwin->height)
#define FullWidth(screen)	(screen->mappedVwin->fullwidth)
#define FullHeight(screen)	(screen->mappedVwin->fullheight)
#define FontWidth(screen)	(screen->mappedVwin->f_width)
#define FontHeight(screen)	(screen->mappedVwin->f_height)
#define TWidth(screen)		(screen->mappedTwin->width)
#define THeight(screen)		(screen->mappedTwin->height)
#define TFullWidth(screen)	(screen->mappedTwin->fullwidth)
#define TFullHeight(screen)	(screen->mappedTwin->fullheight)
#define TekScale(screen)	(screen->mappedTwin->tekscale)
#define Titlebar(screen)	(screen->mappedVwin->titlebar)
#define TTitlebar(screen)	(screen->mappedTwin->titlebar)
#define ActiveIcon(screen)	(screen->active_icon && \
				(screen->mappedVwin == &screen->iconVwin))
#define TActiveIcon(screen)	(screen->active_icon && \
				(screen->mappedTwin == &screen->iconTwin))

#define CursorX(screen,col) ((col) * FontWidth(screen) + screen->border)
#define CursorY(screen,row) ((screen->instatus ? \
			((row) * FontHeight(screen) + 1)\
			: (((row) - screen->topline) * FontHeight(screen))) +\
			screen->border + Titlebar(screen))

#define TICONWINDOWEVENTS  (ExposeWindow | ButtonPressed)

#define	ICONWINDOWEVENTS   (TICONWINDOWEVENTS | ExposeRegion | ExposeCopy)
				 
#define ICONINPUTEVENTS	(KeyPressed | EnterWindow | LeaveWindow | FocusChange)

#define	TWINDOWEVENTS	(KeyPressed | ExposeWindow | ButtonPressed |\
			 ButtonReleased | UnmapWindow | EnterWindow |\
			 LeaveWindow | FocusChange)

#define	WINDOWEVENTS	(TWINDOWEVENTS | ExposeRegion | ExposeCopy)

#define TEK_LINK_BLOCK_SIZE 1024

typedef struct Tek_Link
{
	struct Tek_Link	*next;	/* pointer to next TekLink in list
				   NULL <=> this is last TekLink */
	short count;
	char *ptr;
	char data [TEK_LINK_BLOCK_SIZE];
} TekLink;

/* flags for cursors */
#define	OFF		0
#define	ON		1
#define	CLEAR		0
#define	TOGGLE		1

/* flags for color */
#define	C_FOREGROUND	0x01
#define	C_BACKGROUND	0x02
#define	C_FBMASK	0x03
#define	C_CURSOR	0x04
#define	C_MOUSE		0x08
#define	C_BORDER	0x10

/* flags for inhibit */
#define	I_LOG		0x01
#define	I_SIGNAL	0x02
#define	I_TEK		0x04

extern Bitmap make_icon();
extern Cursor make_tcross();
extern Cursor make_xterm();
extern Cursor make_wait();
extern Cursor make_arrow();
RAZZLE!DAZZLE
fi	# End ptyx.h
if test -f saveoff.ic
then
	echo shar: will not overwrite existing file "'saveoff.ic'"
else
echo 'x - saveoff.ic'
cat << \RAZZLE!DAZZLE > saveoff.ic
/* @(#)saveoff.ic       X10/6.6B 12/26/86 */
#define saveoff_width 19
#define saveoff_height 19
static short saveoff_bits[] = {
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0x78f0, 0x0000, 0xa528, 0x0000,
   0xb568, 0x0000, 0xbde8, 0x0000,
   0xe538, 0x0000, 0x78f8, 0x0000,
   0x0008, 0x0000, 0x0008, 0x0000,
   0x0f88, 0x0000, 0x0f88, 0x0000,
   0x0f88, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000};
RAZZLE!DAZZLE
fi	# End saveoff.ic
if test -f saveon.ic
then
	echo shar: will not overwrite existing file "'saveon.ic'"
else
echo 'x - saveon.ic'
cat << \RAZZLE!DAZZLE > saveon.ic
/* @(#)saveon.ic       X10/6.6B 12/26/86 */
#define saveon_width 19
#define saveon_height 19
static short saveon_bits[] = {
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0x78f0, 0x0000, 0xa528, 0x0000,
   0xb568, 0x0000, 0xbde8, 0x0000,
   0xe538, 0x0000, 0xb8e8, 0x0000,
   0x4010, 0x0000, 0x2020, 0x0000,
   0x1fc0, 0x0000, 0x0f80, 0x0000,
   0x0f80, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000};
RAZZLE!DAZZLE
fi	# End saveon.ic
if test -f scrollbar.h
then
	echo shar: will not overwrite existing file "'scrollbar.h'"
else
echo 'x - scrollbar.h'
cat << \RAZZLE!DAZZLE > scrollbar.h
/*
 *	$Source: /u1/X/xterm/RCS/scrollbar.h,v $
 *	$Header: scrollbar.h,v 10.100 86/12/01 14:40:30 jg Rel $
 */

/* @(#)scrollbar.h       X10/6.6B 12/26/86 */
#define	BARSTART		(2 * BUTTONHEIGHT)
#define	BUTTONHEIGHT		SCROLLBARWIDTH
#define	HILITED			1
#define	MINSCROLLBARHEIGHT	(BARSTART + 32)
#define	NBUTTONBITMAPS		(BUTTON_NORMAL / 2 + 1)
#define	NSAVESTATES		2
#define	PAUSETIME		(1000000L / 5)
#define	SAVELINES		64
#define	SCROLLBARWIDTH		20
#define	STEPTIME		(1000000L / 10)

/*
 * the first four must be consecutive and at the bottom
 */
#define	BUTTON_UPLINE		0
#define	BUTTON_UPLINEHI		(BUTTON_UPLINE | HILITED)
#define	BUTTON_DOWNLINE		(BUTTON_UPLINE + 2)
#define	BUTTON_DOWNLINEHI	(BUTTON_DOWNLINE | HILITED)
#define	BUTTON_UPPAGE		(BUTTON_DOWNLINE + 2)
#define	BUTTON_UPPAGEHI		(BUTTON_UPPAGE | HILITED)
#define	BUTTON_DOWNPAGE		(BUTTON_UPPAGE + 2)
#define	BUTTON_DOWNPAGEHI	(BUTTON_DOWNPAGE | HILITED)
#define	BUTTON_TOP		(BUTTON_DOWNPAGE + 2)
#define	BUTTON_TOPHI		(BUTTON_TOP | HILITED)
#define	BUTTON_BOTTOM		(BUTTON_TOP + 2)
#define	BUTTON_BOTTOMHI		(BUTTON_BOTTOM | HILITED)
#define	BUTTON_NORMAL		(BUTTON_BOTTOM + 2)

#define	SAVE_OFF		0
#define	SAVE_ON			1

#define	HIDE			1
#define	NONE			0
#define	SHOW			2

#define	GetButtonState(sb)		(sb->buttonset)
#define	GetSaveState(sb)		(sb->saveset)
#define	GetScrollBarBottom(sb)		(sb->set.bottomvalue)
#define	GetScrollBarRegion(sb)		(sb->set.regionheight)
#define	GetScrollBarTop(sb)		(sb->set.topvalue)
#define	GetScrollBarValue(sb)		(sb->set.value)
#define	SetScrollBarBottom(sb,bot)	sb->set.bottomvalue = (bot)
#define	SetScrollBarRegion(sb,reg)	sb->set.regionheight = (reg)
#define	SetScrollBarTop(sb,top)		sb->set.topvalue = (top)
#define	SetScrollBarValue(sb,val)	sb->set.value = (val)

struct scroll_region {
	int value;			/* value at top of region */
	int regionheight;		/* region height below value */
	int topvalue;			/* of scroll area */
	int bottomvalue;		/* of scroll area */
	int height;			/* of scroll area */
	int y;				/* y position of region */
	int pixelheight;		/* height in pixel of region */
};

typedef struct scroll_bar {
	int visible;				/* scrollbar visible */
	int buttonstate;			/* current button state */
	int buttonset;				/* requested button state */
	int savestate;				/* current save state */
	int saveset;				/* requested save state */
	int regionvisible;			/* region visible */
	int action;				/* state is changing */
	Window bar;				/* main scrollbar window */
	Window button;				/* button window */
	Window save;				/* save state window */
	Window region;				/* region window */
	Cursor cursor;				/* scrollbar cursor */
	short *buttonbits[NBUTTONBITMAPS];	/* button state bitmaps */
	short *savebits[NSAVESTATES];		/* save state bitmaps */
	int fg;					/* foreground color */
	int bg;					/* background color */
	struct scroll_region state;		/* current region state */
	struct scroll_region set;		/* requested region state */
} ScrollBar;

ScrollBar *CreateScrollBar();
RAZZLE!DAZZLE
fi	# End scrollbar.h
if test -f tek_icon.ic
then
	echo shar: will not overwrite existing file "'tek_icon.ic'"
else
echo 'x - tek_icon.ic'
cat << \RAZZLE!DAZZLE > tek_icon.ic
/* @(#)tek_icon.ic       X10/6.6B 12/26/86 */
#define tek_icon_width 32
#define tek_icon_height 24
static short tek_icon_bits[] = {
   0xffff, 0xffff, 0x5001, 0x8005,
   0xaffd, 0xbffa, 0x5001, 0x8005,
   0xffff, 0xffff, 0x0001, 0x8000,
   0x0001, 0x8000, 0x0b89, 0x8000,
   0x2009, 0x8000, 0x4019, 0x9e00,
   0x8049, 0x8100, 0x0109, 0x8080,
   0x0409, 0x9082, 0x3819, 0x8440,
   0xce09, 0x8149, 0x2109, 0x805a,
   0x8089, 0x803c, 0x0059, 0x8025,
   0x0049, 0x8e80, 0x0009, 0x8000,
   0x8889, 0x8888, 0xfff9, 0x9fff,
   0x0001, 0x8000, 0xffff, 0xffff};
RAZZLE!DAZZLE
fi	# End tek_icon.ic
if test -f top.ic
then
	echo shar: will not overwrite existing file "'top.ic'"
else
echo 'x - top.ic'
cat << \RAZZLE!DAZZLE > top.ic
/* @(#)top.ic       X10/6.6B 12/26/86 */
#define top_width 19
#define top_height 19
static short top_bits[] = {
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0xfff8, 0x0000,
   0xfff8, 0x0000, 0x8208, 0x0000,
   0x8708, 0x0000, 0x8f88, 0x0000,
   0x9fc8, 0x0000, 0x8708, 0x0000,
   0x8708, 0x0000, 0x8008, 0x0000,
   0x8008, 0x0000, 0x8008, 0x0000,
   0x8008, 0x0000, 0x8008, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000};
RAZZLE!DAZZLE
fi	# End top.ic
if test -f upline.ic
then
	echo shar: will not overwrite existing file "'upline.ic'"
else
echo 'x - upline.ic'
cat << \RAZZLE!DAZZLE > upline.ic
/* @(#)upline.ic       X10/6.6B 12/26/86 */
#define upline_width 19
#define upline_height 19
static short upline_bits[] = {
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0200, 0x0000, 0x0700, 0x0000,
   0x0f80, 0x0000, 0x1fc0, 0x0000,
   0x0700, 0x0000, 0x0700, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0xef78, 0x0000, 0x0000, 0x0000,
   0xdbb8, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000};
RAZZLE!DAZZLE
fi	# End upline.ic
if test -f uppage.ic
then
	echo shar: will not overwrite existing file "'uppage.ic'"
else
echo 'x - uppage.ic'
cat << \RAZZLE!DAZZLE > uppage.ic
/* @(#)uppage.ic       X10/6.6B 12/26/86 */
#define uppage_width 19
#define uppage_height 19
static short uppage_bits[] = {
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000, 0x7f00, 0x0000,
   0x4180, 0x0000, 0x4140, 0x0000,
   0x4120, 0x0000, 0x41f0, 0x0000,
   0x4210, 0x0000, 0x4710, 0x0000,
   0x4f90, 0x0000, 0x5fd0, 0x0000,
   0x4710, 0x0000, 0x4710, 0x0000,
   0x4010, 0x0000, 0x7ff0, 0x0000,
   0x0000, 0x0000, 0x0000, 0x0000,
   0x0000, 0x0000};
RAZZLE!DAZZLE
fi	# End uppage.ic
if test -f wait.ic
then
	echo shar: will not overwrite existing file "'wait.ic'"
else
echo 'x - wait.ic'
cat << \RAZZLE!DAZZLE > wait.ic
/* @(#)wait.ic       X10/6.6B 12/26/86 */
#define wait_width 16
#define wait_height 16
#define wait_x_hot 7
#define wait_y_hot 7
static short wait_bits[] = {
   0x0000, 0x03e0, 0x0c18, 0x1084,
   0x1084, 0x2082, 0x2082, 0x2382,
   0x2002, 0x2002, 0x1004, 0x1004,
   0x0c18, 0x0ff8, 0x1ffc, 0x0000};
RAZZLE!DAZZLE
fi	# End wait.ic
if test -f waitmask.ic
then
	echo shar: will not overwrite existing file "'waitmask.ic'"
else
echo 'x - waitmask.ic'
cat << \RAZZLE!DAZZLE > waitmask.ic
/* @(#)waitmask.ic       X10/6.6B 12/26/86 */
#define waitmask_width 16
#define waitmask_height 16
#define waitmask_x_hot 7
#define waitmask_y_hot 7
static short waitmask_bits[] = {
   0x07f0, 0x0ff8, 0x1ffc, 0x3ffe,
   0x7fff, 0x7fff, 0x7fff, 0x7fff,
   0x7fff, 0x7fff, 0x7fff, 0x3ffe,
   0x1ffc, 0x3ffe, 0x3ffe, 0x3ffe};
RAZZLE!DAZZLE
fi	# End waitmask.ic
echo '***** End of' xterm 6.6B - Part 1 of 7 '*****'
exit

