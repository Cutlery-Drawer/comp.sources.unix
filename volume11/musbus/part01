Path: uunet!munnari!sources-request
From: sources-request@munnari.oz
Newsgroups: comp.sources.unix
Subject: v11i029:  MUSBUS 5.0 -- Monash University Benchmark, Part01/04
Message-ID: <1825@munnari.oz>
Date: 17 Sep 87 08:12:21 GMT
Sender: kre@munnari.oz
Lines: 1884
Approved: kre@munnari.oz.au

Submitted by: kenj@moncsbruce.oz.au (Ken McDonell)
Mod.sources: Volume 11, Issue 29
Archive-name: musbus/Part01

	[ This posting is way out of sequence with the rest of what's
	  happening in comp.sources.unix.  Sorry about that folks...
	  It was caused by a procedural screwup .. the numbers were
	  allocated way before the posting was ready.  So much for
	  attempting to streamline the posting process!  I think that
	  r$ and I have this dual moderator stuff in a much nicer state
	  now...  kre ]

MUSBUS Version 5.0 (Monash University Software for Benchmarking Unix Systems)

MUSBUS is a benchmarking tool that provides a test environment in which
a system or application specific worload profile is used to drive simulated
multi-user performance measurements; i.e. system throughput as seen by
a terminal user as a function of concurrent load.  Some raw speed tests are
also included for diagnostic and hypothesis formulation purposes.

MUSBUS has been used successfully in Australia, Europe and the USA 
by equipment purchasers for comparative performance evaluation, in
contractual acceptance tests, system shake-down to introduce stress
and by vendors for in-house performance instrumentation.

A paper at the June 1987 Phoenix USENIX Meeting describes the philosophy
underlying the MUSBUS design.

Complete documentation is in Intro.nr (no macros needed), whilst
musbus.1 and README provide abbreviated notes, hints and descriptions.

Ken J. McDonell
Department of Computer Science
Monash University
kenj@moncsbruce.oz.au	..!uunet!munnari!moncsbruce.oz!kenj

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	Adjust
#	BSDtime.awk
#	Config
#	Groan
#	Intro.nr
#	Makefile
#	Makefile,1
#	README
#	Results.files
#	SysVtime.awk
#	Tools.files
#	Workload.files
#	arith.c
# This archive created: Thu Sep 17 06:46:18 EST 1987
export PATH; PATH=/bin:$PATH
echo 'x - Adjust'
if test -f 'Adjust'
then
	echo 'shar: over-writing existing file Adjust'
fi
sed 's/^X//' > Adjust <<'End-of-File-Grunt'
X#! /bin/sh
X# $Header: Adjust,v 1.2 87/06/23 15:05:56 kjmcdonell Beta $
Xif test $# -lt 1
Xthen
X	echo Usage: $0 logfile ...
X	exit 1
Xfi
Xfor f
Xdo
X	awk '
X/sqrt/		     { print $0; flag=0; state=0; next }
X/Arith/ && /arithoh/ { state=1; print $0; next }
X/Elapse/ && state==1 { state=2; e=$3; print $0; next }
X/CPU/ && state==2    { state=3; c=$3; print $0; next }
X/Arith/ && state==3  { flag=1; print $0; next }
X/Elapse/ && flag==1 && !/\(Actual/  { printf "%s (Actual: %.2f )\n",$0,$3-e; next }
X/CPU/ && flag==1 && !/\(Actual/     { printf "%s (Actual: %.2f )\n",$0,$3-c; next }
X		     { flag=0; print $0 }
X	' $f > /tmp/Adj$$
X	if cmp $f /tmp/Adj$$ >/dev/null
X	then
X		echo No changes made.
X	else
X		chmod u+w $f
X		cp /tmp/Adj$$ $f
X		chmod u-w $f
X	fi
X	rm -f /tmp/Adj$$
Xdone
End-of-File-Grunt
if test 764 -ne `cat 'Adjust' | wc -c`
then
	echo 'shar: transmission error (expected 764 characters)'
fi
echo 'x - BSDtime.awk'
if test -f 'BSDtime.awk'
then
	echo 'shar: over-writing existing file BSDtime.awk'
fi
sed 's/^X//' > BSDtime.awk <<'End-of-File-Grunt'
X# $Header: BSDtime.awk,v 3.4 87/06/22 14:27:07 kjmcdonell Beta $
X/real/	{ if (!fail) {
X	    real+=$1; r2+=$1*$1; user+=$3; sys+=$5; c=$3+$5; c2+=c*c
X	    ok++
X	  }
X          iter++; fail=0; next
X	}
X	{ print "** Iteration ",iter+1," Failed: ",$0; fail=1 }
XEND {
X	if (fail) iter++
X	if (ok != iter) {
X	    printf "For %d successful iterations from %d attempts ...\n",ok,iter
X	    iter=ok
X	}
X	if (iter > 0) {
X	    printf "Elapsed Time: %.2f seconds",real/iter
X	    if (iter > 1) printf " (variance %.3f)",(r2-2*real*real/iter+real*real/iter)/(iter-1)
X	    cpu=sys+user
X	    printf "\nCPU Time: %.2f seconds [ %.2fu + %.2fs ]",cpu/iter,user/iter,sys/iter
X	    if (iter > 1) printf " (variance %.3f)",(c2-2*cpu*cpu/iter+cpu*cpu/iter)/(iter-1)
X	    print
X	} else {
X	    print "Elapsed Time: -- no measured results!!"
X	    print "CPU Time: -- no measured results!!"
X	}
X    }
End-of-File-Grunt
if test 867 -ne `cat 'BSDtime.awk' | wc -c`
then
	echo 'shar: transmission error (expected 867 characters)'
fi
echo 'x - Config'
if test -f 'Config'
then
	echo 'shar: over-writing existing file Config'
fi
sed 's/^X//' > Config <<'End-of-File-Grunt'
X#! /bin/sh
X# $Header: Config,v 3.4 87/06/23 13:53:05 kjmcdonell Beta $
X# sh script to extract useful configuration data
Xif test $# -ne 1
Xthen
X	echo "Usage: Config logfile"
X	exit 1
Xfi
Xtmp=/tmp/$$
Xecho "MUSBUS - Site Configuration Data for $1"
Xecho "" >>$tmp
Xecho "Please answer the following questions ..."
Xecho "CPU Make and Model Number?"
Xread x
Xecho "MC=\"$x\"" >>$tmp
Xecho "Hardware options, e.g. floating point unit?"
Xread x
Xecho "OPT=\"$x\"" >>$tmp
Xecho "Real Memory (M bytes)?"
Xread x
Xecho "MEM=\"$x\"" >>$tmp
Xecho "Type of UNIX (Vendor name, AT&T System V, BSD 4.x, etc)?"
Xread type
Xecho "UNIX Version or Revision Level?"
Xread version
Xecho "UNIX=\"$type $version\"" >>$tmp
Xecho "Disk Configuration (no. of spindles and their type(s))?"
Xread x
Xecho "DISKS=\"$x\"" >>$tmp
Xcat $tmp $1 > ${tmp}a
Xchmod u+w $1
Xmv ${tmp}a $1
Xchmod u-w $1
Xrm -f ${tmp}*
End-of-File-Grunt
if test 853 -ne `cat 'Config' | wc -c`
then
	echo 'shar: transmission error (expected 853 characters)'
fi
echo 'x - Groan'
if test -f 'Groan'
then
	echo 'shar: over-writing existing file Groan'
fi
sed 's/^X//' > Groan <<'End-of-File-Grunt'
X#! /bin/sh
X# $Header: Groan,v 3.4 86/12/24 08:56:45 kenj Beta $
X# run MUSBUS multiuser test continuously
Xrm -f nogroan
Xn=1
Xnusers="1 4 8 16 24 32 48 64"
Xttys="/dev/ttyi11 /dev/ttyi34 /dev/ttyi03"
Xdirs="/hon/Bench /tmp/Bench /u1/Bench"
Xexport nusers ttys dirs
Xfor t in $ttys
Xdo
X	stty 9600 -tabs -raw -nl >$t &
Xdone
Xfor d in $dirs
Xdo
X	if test -d $d
X	then
X		:
X	else
X		mkdir $d
X		echo $d created.
X	fi
Xdone
Xdate > log.groan
Xwhile test ! -f nogroan
Xdo
X	./run >> log.groan 2>&1
X	echo "Groan: Major Iteration $n Completed" >> log.groan
X	n=`expr $n + 1`
Xdone
End-of-File-Grunt
if test 550 -ne `cat 'Groan' | wc -c`
then
	echo 'shar: transmission error (expected 550 characters)'
fi
echo 'x - Intro.nr'
if test -f 'Intro.nr'
then
	echo 'shar: over-writing existing file Intro.nr'
fi
sed 's/^X//' > Intro.nr <<'End-of-File-Grunt'
X.\" This needs NO macro package, it is self-contained
X.\" $Header: Intro.nr,v 3.12 87/09/16 07:24:45 kenj Exp $
X.nr Pw 6.75i
X.nr Po 0i
X.ll \n(Pwu
X.ev 2
X.ll \n(Pwu
X.lt \n(Pwu
X.ev
X.po -\n(Po
X.hy 14
X.nr II 0
X.de SZ
X.ps \\$1
X.vs \\$1u*1.25p
X..
X.de NH
X.in 0
X.if t .sp 0.5v
X.if n .sp
X.ne 6v
X.SZ 12
X.ft B
X\\$1 \\$2
X.br
X.ft P
X.SZ 10
X..
X.de LP
X.in \\n(IIu
X.if t .sp 0.35v
X.if n .sp
X.ne 3v
X..
X.de IP
X.LP
X.in +4n
X.ta 4n
X.ti -4n
X\\$1	\\c
X..
X.de PR
X\\fI\\$1\\fP\\$2
X..
X.de FL
X\\fB\\$1\\fP\\$2
X..
X.de SC
X.ti +6n
X.if t .HS
X$ \\$1
X.br
X.if t .HE
X..
X.de SV
X\\fI$\\$1\\fP\\$2
X..
X.de RS
X.in +6n
X..
X.de RE
X.in -6n
X..
X.de HS
X.ft H
X.ps -1
X..
X.de HE
X.ps +1
X.ft R
X..
X.de VA
X.IP "\fIShell Variable:\fP \\fB\\$1\\fP  (default: \\$2)"
X.br
X..
X.de TN
X.IP "\fITest Name:\fP \\fB\\$1\\fP"
X.br
X..
X\&
X.sp 1i
X.de Fo
X'Hd
X..
X.de Hd
X.ev 2
X.bp
X.in 0
X.sp
X.tl 'MUSBUS Introduction''%.'
X.sp
X.ev
X..
X.wh -0.1i Fo
X.ad c
X.SZ 14
X.ft B
XAn Introduction to the Monash Benchmark Suite (MUSBUS)
X.if t .sp 0.5v
X.if n .sp
X.SZ 12
X.ft I
XKen J. McDonell
X.if t .sp 0.5v
X.if n .sp
X.SZ 10
X.ft R
XDepartment of Computer Science
X.br
XMonash University
X.br
XClayton, AUSTRALIA 3168
X.sp
XACSnet: kenj@moncskermit.oz
X.br
XUSENET: seismo!munnari!moncskermit.oz!kenj
X.br
XARPA: kenj%moncskermit.oz@seismo.arpa
X.sp
XRevised: 16 September, 1987
X.br
X.ad b
X.NH 1 Introduction
X.LP
XThe Monash University Suite for Benchmarking
XUNIX\v'-.5n'\(dg\v'+.5n'
X.de DF
X'FN
X.rm DF
X..
X.wh -0.7i DF
X.de FN
X.ev 2
X.in 0
X.sp
X\\l'1.5i\(ul'
X.sp 0.5v
X\v'-.5n'\(dg\v'+.5n' UNIX is a trademark of AT&T
X.sp 2
X.ev
X.rm FN
X.ch DF -0.01i
X..
XSystems (MUSBUS), has been developed
Xto assist in
X.IP (a)
Xidentifying bottlenecks and performance problems in new
XUNIX ports, and
X.IP (b)
Xproviding a robust test environment in which
Xthe performance of competing
XUNIX systems may be compared.
X.LP
XThis document provides an overview for \fBVersion\fP \fB5.0\fP of MUSBUS
Xand is intended for knowledgeable programmers trying to run
Xthe software on their own hardware.
X.NH 2 Preliminaries
X.NH 2.1 "Software Environment"
X.LP
XYou will require a system that supports Level 7, System V
Xor BSD
Xcompatibility, along with the following programs.
X.RS
X.PR sh
X(the Bourne shell)
X.br
X.PR awk
X.PR cat
X.PR cc
X.PR chmod
X.PR comm
X.PR cp
X.PR date
X.PR dc
X.PR df
X.PR echo
X.PR ed
X.PR expr
X.PR kill
X.PR ls
X.PR make
X.PR mkdir
X.PR rm
X.PR sed
X.PR test
X.PR time
X.PR touch
X.PR tty
X.PR who
X.RE
X.NH 2.2 "Getting Started"
X.LP
XAll the files are distributed in a single directory.
XOnce these have been retrieved from the distribution some initial housekeeping
Xand system specifics have to be sorted out.
X.LP
XWhen fully installed, MUSBUS contains files in several subdirectories
Xas follows,
X.IP \(bu
X.FL Results ,
Xlog files created by the command procedure
X.PR run .
X.IP \(bu
X.FL Tmp ,
Xtemporary files created by
X.PR run
Xand friends.
X.IP \(bu
X.FL Tools ,
Xpost processors to produce
X.PR tbl
Xinput from the log files.
X.IP \(bu
X.FL Workload ,
Xdescriptions of the workload profile, all associated data files and some
Xwork script manipulation tools.
X.LP
XTo explicitly
Xcreate these directories and distribute the required files into the
Xappropriate places you may
X.SC "make install"
Xhowever this will be done automatically by
X.PR run
Xas required.
X.LP
XThe file 
X.FL time.awk
Xis used by the command procedure
X.PR run
Xto average the
Xresults from several attempts to time a particular test and so
Xdepends upon the format of output from
X.PR /bin/time .
XThe results from multiple timing attempts are held temporarily
Xin the file 
X.FL Tmp/tmp.$$
X(where $$ is the pid of the
X.PR run
Xshell).
XTry
X.SC "/bin/time date"
Xand check the output from
X.PR /bin/time .
XIf it has a format like
X.ti +4n
X0.4 real         0.0 user         0.1 sys  
X.br
Xthen
X.SC "rm -f time.awk"
X.SC "ln BSDtime.awk time.awk"
X.LP
XIf the
X.PR /bin/time
Xoutput looks like
X.RS
X.ta 8n
X.nf
Xreal	0:00.4
Xuser	0:00.0
Xsys	0:00.1
X.fi
X.RE
Xthen
X.SC "rm -f time.awk"
X.SC "ln SysVtime.awk time.awk"
X.LP
XOtherwise create your own version of
X.FL time.awk
Xusing
X.FL *time.awk
Xas examples.
X.LP
XSome of the tests require system calls from the C code to measure
Xsmall elapsed times.
XThis is a real problem since there appears to be no 
Xuniversally correct way of doing this in the Unix
Xworld.
XThe particular source files are
X.FL clock.c ,
X.FL fstime.c
Xand
X.FL mem.c .
XIn the
X.FL Makefile ,
Xensure that you have \fBone\fP of the following
Xdefinitions included in the CFLAGS (in addition to the \(miO).
X.RS
X.ta 12n
X.nf
X.if t \fH\s-1\(miDSysV\s+1\fR	you are using a System V brand of Unix
X.if n \(miDSysV	you are using a System V brand of Unix
X.if t \fH\s-1\(miDBSD4v2\s+1\fR	you are using a Berkeley 4.2 or 4.3 system
X.if n \(miDBSD4v2	you are using a Berkeley 4.2 or 4.3 system
X.if t \fH\s-1\(miDBSD4v1\s+1\fR	you are using a Berkeley 4.1 system
X.if n \(miDBSD4v1	you are using a Berkeley 4.1 system
X.fi
X.RE
XFor example,
X.ti +6n
X.if t \fH\s-1CFLAGS = \(miO \(miDBSD4v2\s+1\fR
X.if n CFLAGS = -O -DBSD4v2
X.LP
XIf \fBnone\fP of these systems
Xis appropriate, the source files \fIwill not compile\fP
Xand you will have to decide on appropriate alternative calls
Xand coding to suit local conditions.
X.LP
XIf you don't have the public-domain random number generator \fIrandom\fP()
Xremove the #defines for \fBrand\fP and \fBsrand\fP in
X.FL mkperm.c.
X.LP
XCheck the
X.FL HISTORY
Xfile (if it exists) for notification of any changes, additions
Xor problems that may have been made or fixed subsequent to the version
Xof MUSBUS described in this document.
X.LP
XTry
X.SC "make programs"
Xto confirm that every necessary program can be compiled and
Xloaded correctly.
X.LP
XNow attempt to run all the tests once (this takes roughly 20 minutes).
XUsing the Bourne shell (\c
X.PR /bin/sh ),
X.SC "iterations=1"
X.SC "nusers=1"
X.SC "export iterations nusers"
X.SC "./run"
X.LP
XThis should demonstrate
Xthat all the 
X.PR sh,
X.PR awk,
X.PR sed
Xand 
X.PR ed
Xscripts
Xcan be made to work.
XVerification of the health of things to this point depends upon
Xchecking the output from
X.PR run
Xto ensure that no nasty errors
Xare reported, and in particular scrolling through the file
X.FL Results/log .
XEvery time
X.PR run
Xis used information is \f3appended\fP to
X.FL Results/log
Xand
X.FL Results/log.work ,
Xso make sure that these files are removed or renamed before you start
Xto do anything serious.
XThe contents of
X.FL Results/log
Xshould look something like
X.LP
X.RS
X.nf
X.HS
XStart Benchmark Run (MUSBUS Version X.Y)
X  Tue Jun 23 17:18:21 EDT 1987 (long iterations 6 times)
X  2 interactive users.
X
XArithmetic Test (type = arithoh): 1000 Iterations
XElapsed Time: 0.44 seconds (variance 0.003)
XCPU Time: 0.30 seconds [ 0.30u + 0.00s ] (variance 0.000)
X
XArithmetic Test (type = register): 1000 Iterations
XElapsed Time: 3.36 seconds (variance 0.008)
XCPU Time: 3.18 seconds [ 3.13u + 0.05s ] (variance 0.008)
X
X[ ... and lots more similar goodies ]
X
XOutput sent to ... /dev/ttyp0
XDirectories for temporary files ... Tmp
X
X.nf
X.ta 14n,+8n,+8n,+8n,+8n
XFilesystem	kbytes	used	avail capacity	Mounted on
X/dev/hp0a	\07419	\06202	\0\0475	93%	/
X/dev/hp0g	38383	33296	\01248	96%	/usr
X/dev/hp1a	\07419	\04169	\02508	62%	/jnk
X/dev/hp1b	15583	\03181	10843	23%	/usr/spool
X/dev/hp1g	38383	32579	\01965	94%	/mnt
X/dev/up1a	\07471	\0\0\010	6713	\00%	/tmp
X
XSIGALRM check:  12 x 5 sec delays takes 60.05 wallclock secs (error -0.08%)
XSimulated Multi-user Work Load Test:
X
X1 Concurrent Users, each with Input Keyboard Rate 2 chars / sec
XElapsed Time: 425.83 seconds (variance 0.125)
XCPU Time: 27.20 seconds [ 17.30u + 9.90s ] (variance 0.013)
X
X  1 interactive users.
XEnd Benchmark Run (Wed Jun 24 09:33:55 EDT 1987) ....
X.HE
X.fi
X.RE
X.LP
XBeware of lines with the following formats, they indicate something
Xis \fBwrong\fP.
X.if t .IP "\fH\s-1** Iteration x Failed: text\fR\s+1"
X.if n .IP "** Iteration x Failed: text"
X.br
XSomething (\fItext\fP) other than the normally anticipated output from 
X.PR /bin/time
Xwas found in the file
X.FL Tmp/tmp.$$ .
X.if t .IP "\fH\s-1Elapsed Time: -- no measured results!!\fR\s+1";
X.if n .IP "Elapsed Time: -- no measured results!!";
X.br
XNot a single valid timing result was found in
X.FL Tmp/tmp.$$ .
X.if t .IP "\fH\s-1Terminated during iteration n\fR\s+1"
X.if n .IP "Terminated during iteration n"
X.br
XPremature termination of a test, usually as the result of
Xa shell trap taken from
X.PR run .
XMost often this is symptomatic of an earlier
Xerror reported in
X.FL Results/log .
X.if t .IP "\fH\s-1* Apparent errors from makework ... *\fR\s+1"
X.if n .IP "* Apparent errors from makework ... *"
X.br
XAfter cleaning the log files from the multi-user test (using 
X.PR sed
Xand the script
X.FL check.sed )
Xsome lines remained that probably indicate
Xreal errors which forced the multi-user test to
Xterminate prematurely.
XDepending upon the formats of messages from programs (especially
Xin the multi-user workload),
X.FL check.sed
Xmay need some local fine tuning to remove lines,
Xthat do not reflect genuine error conditions, from
Xthe log files.
XIf this is not done,
Xthe tests will be aborted prematurely based upon the classification
Xof a spurious message as a real error condition.
X.if t .IP "\fH\s-1Reason?: text\fR\s+1"
X.if n .IP "Reason?: text"
X.br
X.PR Makework
X(the controlling program for the multi-user test)
Xhas detected an inconsistency and taken a fatal dive,
X\fItext\fP comes from
X.PR perror ()
Xand the previous line in
X.FL Results/log
Xwill contain 
X.PR makework "'s"
Xidea of what is wrong.
X.if t .IP "\fH\s-1* Benchmark Aborted .... *\fR\s+1"
X.if n .IP "* Benchmark Aborted .... *"
X.br
XJust what it says!
X.LP
XOther possible error reports in
X.FL Results/log
Xrelate to specific tests
Xand are either self explanatory (e.g. missing or illegal program
Xoptions) or described in the Sections below.
X.LP
XThe file
X.FL Results/log.work
Xcontains detailed logging of the multi-user test, and may contain
Xuseful information in the event that this test fails or terminates
Xprematurely.
XBesides logging process ids and file descriptor assignments for each
Xsimulated user's job stream, standard error output is trapped and
Xreported in
X.FL Results/log.work .
X.NH 3 "The Tests"
X.LP
XIf you are serious about the results produced, these tests should
Xbe run on a dedicated system without concurrent activity.
XWhen possible, an idle system in mult-iuser mode is
Xpreferable to a single user system.
X.LP
XAll the tests are controlled by shell variables used within the command
Xprocedure
X.PR run .
XBy setting environment variables of the same name, the default values
Xof the shell variables
Xmay be over-ridden, however if the defaults are consistently wrong for
Xparticular variables it is safer (i.e. less error prone) to modify
Xthe defaults in
X.PR run .
X.LP
X.PR Run
Xdoes its work for the most part silently, logging information to
Xcertain files, and providing a terse summary of the particular test(s)
Xbeing run on the tty from which
X.PR run
Xwas invoked.
X.LP
XA designated test may by run using the command
X.SC "./run thing"
Xwhere \fIthing\fP is one of the test names described in the following
XSections.
XThe commands
X.SC "./run"
Xor
X.SC "./run all"
Xwill run everything.
X.LP
X.PR Run
Xmay be interrupted from the keyboard (SIGINT)
Xif it is started in foreground
Xand after some fooling about it manages to shut things down and clean up files.
X.PR run
Xcreates a 
X.PR sh
Xcommand procedure
X.FL Tmp/kill_run
Xthat may be used to shut down a background
X.PR run
Xvia
X.SC "Tmp/kill_run"
X.VA iterations 6
XUnless otherwise stated,
Xthis variable controls the number of times each test is repeated for timing.
XAt the beginning of each iteration, the program
X.FL iamalive
Xwrites the iteration
Xnumber (without newline or carriage return)
Xon standard output.
X.NH 3.1 "Raw Speed Measures"
X.NH 3.1.1 "Specific Arithmetic"
X.LP
XThis family of tests computes the sum of a series of terms
Xsuch that the arithmetic is unbiased towards operator type
X(i.e. equal numbers of additions, subtractions, multiplications
Xand divisions).
XEach major loop in the computation involves summing 100 terms
Xof the series.
X.VA arithloop 1000
XNumber of major loops in the computation.
X.TN arithoh
XDo not compute the series, so measures the overhead in the
Xcomputation.
X.TN register
XArithmetic uses registers.
X.TN short
XArithmetic uses shorts.
X.TN int
XArithmetic uses ints.
X.TN long
XArithmetic uses longs.
X.TN float
XArithmetic uses floats.
X.TN double
XArithmetic uses doubles.
X.LP
XAfter all the arithmetic tests have been performed, the 
X.PR sh
Xscript
X.FL Tools/Adjust
Xshould be used with
X.FL Results/log ,
Xi.e.
X.SC "./Tools/Adjust Results/log"
Xto compute the \fBactual\fP
XCPU and elapsed times when the overhead measured by the test
X.PR arithoh
Xis subtracted.
XIt is these times (i.e. \fIminus the startup and loop overhead\fP)
Xthat have been published and circulated amongst MUSBUS users.
XFailure to run the 
X.PR Tools/Adjust
Xscript will make the machine
Xyou are testing look comparatively worse
Xthan it really is!
XNote that
X.PR Tools/Adjust
Xwill be run automatically by the log file postprocessors (\c
X.PR Tools/mktbl
Xand
X.PR Tools/mkcomp )
Xif the times have not already been adjusted.
XOnce the adjustment has been made, the relevant portion of
X.FL Results/log
Xshould look something like (note \fBActual\fP times in parentheses),
X.LP
X.RS
X.nf
X.HS
XStart Benchmark Run (MUSBUS Version X.Y)
X  Tue Jun 23 17:18:21 EDT 1987 (long iterations 6 times)
X  2 interactive users.
X
XArithmetic Test (type = arithoh): 1000 Iterations
XElapsed Time: 0.44 seconds (variance 0.003)
XCPU Time: 0.30 seconds [ 0.30u + 0.00s ] (variance 0.000)
X
XArithmetic Test (type = register): 1000 Iterations
XElapsed Time: 3.36 seconds (variance 0.008) (Actual: 2.92 )
XCPU Time: 3.18 seconds [ 3.13u + 0.05s ] (variance 0.008) (Actual: 2.88 )
X
X[ ... and lots more similar goodies ]
X
X.HE
X.fi
X.RE
X.NH 3.1.2 "General Purpose Arithmetic"
X.TN dc
XCompute the square root of 2 to 99 decimal places using 
X.PR dc .
XThe 
X.PR dc
Xinput is in
X.FL dc.dat .
XThis test is due to John Lions (University of New South Wales) who
Xhas suggested it as a good first order measure of raw system speed.
X.NH 3.1.3 Recursion
X.VA ndisk 17
X.TN hanoi
XA recursive solution to the classical Tower of Hanoi problem.
XWork increases as 2**(number of disks).
X.SV ndisk
Xprovides a \fIlist\fP of the number of disks for a
X\fBset\fP of problems, however the default setting is for a singular
Xset.
X.NH 3.1.4 "System Calls, Pipes, Forks, Execs and Context Switches"
X.VA ncall 4000
X.TN syscall
XSit in a hard loop of
X.SV ncall
Xiterations, making 5 system calls
Xper iteration.
XThe system calls (\c
X.PR dup (0),
X.PR close (i),
X.PR getpid (),
X.PR getuid ()
Xand
X.PR umask (i))
Xinvolve little work on the part of the UNIX kernel, so
Xthe test predominantly measures the overhead associated with
Xthe system call mechanism.
X.VA io 2048
X.TN pipe
XOne process (therefore no context switching) that writes and reads
Xa 512 byte block along a pipe
X.SV io
Xtimes.
X.VA children 100
X.TN spawn
XSimply repeat
X.SV children
Xtimes; fork a copy of yourself and wait for
Xthe child process to exit (which it should do immediately).
X.VA nexecl 100
X.TN execl
XPerform
X.SV nexecl
Xexecs using 
X.PR execl ().
XThe program to be exec'd has been artificially expanded to a reasonable
Xsize (on a VAX, 11264 text + 2048 data + 24388 bss).
X.VA switch1 500
X.TN context1
XPerform 2 x
X.SV switch1
Xcontext switches, using pipes for synchronization.
XThe test involves 2 processes connected via 2 pipes.
XOne process writes then reads a 4-byte (descending) sequence number, while
Xthe other process reads then writes a sequence number.
XSynchronization is validated at each swap by checking the values of the
Xsequence numbers read and written.
X.NH 3.1.5 "C Compilation and Loading"
X.TN C
XMeasure the time for each of
X.SC "cc -c cctest.c"
X.SC "cc cctest.o"
Xwhere 
X.FL cctest.c
Xcontains 124 lines of uninteresting C code (108
Xlines of real code after 
X.PR cpp ).
X.NH 3.1.6 "Memory Access Speed"
X.LP
XThese tests try to measure read accesses per real second into an array
Xof integers.
XBecause of inaccuracies in measuring small real times, the
Xresults of this test are subject to large variances and
Xcan not be interpreted with great confidence (e.g. negative
Xand infinite speeds have been observed).
XConsequently, these tests are best considered as a
Xhistorical curiosities from the days when MMUs were bottlenecks on
Xmicroporcessor-based systems, and \fBno\fP real significance should
Xbe attached to the observed times.
X.VA poke 100000
XNumber of array accesses.
X.VA arrays "8 64 512"
XList of array sizes in units of 1024 ints.
X.TN seqmem
XCyclic sequential access pattern, hitting each element of the array
Xin turn.
X.TN randmem
XRandom access patterns -- to give VM systems a chance to do something
Xbetter!
X.NH 3.1.7 "Filesystem Throughput"
X.VA blocks "62 125 250 500"
XA list of file sizes in Kbytes.
X.VA where .
XThe directory in which the files will be created.
XThis test requires at least
X2 x max(\c
X.SV blocks )
XKbytes of free space in the filesystem
Xcontaining
X.SV where .
X.TN fstime
XThis program attempts to measure file write time, file read time and
Xfile copy time.
XIt is assumed that BUFSIZ as defined in <stdio.h> is a good size for
Xphysical i/o, and all i/o is done via direct calls to 
X.PR read ()
Xand 
X.PR write ().
XThis test is performed (\c
X.SV iterations /2)
Xtimes.
X.LP
XBeware of the \fIwrite\fP time, since this can be influenced by the size
Xof the disk block cache in the kernel.
XBefore the reads are commenced there are a couple of 
X.PR sync ()s
Xand a 5 second sleep to try and flush the cache.
XThe times for small files are most sensitive to disk block
Xcaching.
X.LP
XReally the \fIcopy\fP time for the largest file
Xis the best indicator of throughput and reflects
Xthe type of disk activity most commonly generated by compilers, editors,
Xassemblers, etc.
XAlso the rates are measured against elapsed time, so there is some
Xscope for variance however the absolute times are usually long enough
Xto make this effect insignificant \fBprovided\fP
Xthere is no concurrent disk activity on the same spindle!
X.NH 3.2 "Emulated Multi-user Test"
X.VA nusers "1 4 8 16 24 32"
XA list of the number users to be emulated.
X.VA ttys /dev/tty
XA \fBlist\fP of tty devices
Xwhere the simulated tty output is sent -- there is a lot of this, and
Xyou should ensure that these tty lines are operating at the normal
Xbaud rate (e.g. 9600) for the test system.
XIf your CPU console does not use a standard serial multiplexer
X(e.g. a VAX, Pyramid, Gould, DG, etc.), then the tty output
Xshould be directed to \fIsome other\fP tty line(s) that \fBdo\fP use the
Xordinary serial port hardware.
X.VA dirs Tmp
XA \fBlist\fP of directories that will be used to create subdirectories
Xand temporary files to run the
Xuser job streams from.
X.VA rate 2
XUsers are assumed to type at a rate of
X.SV rate
Xcharacters per second.
X.TN work
XOf all the tests in MUSBUS,
Xthis is the by far the most complicated, most realistic and most likely
Xto fail.
XThis test is performed (\c
X.SV iterations /2)
Xtimes.
X.LP
XThe synthetic workload is created from a number of job streams, each
Xof which is described by a line in the file
X.FL Tmp/workload .
XEach line consists of
X.IP \(bu
Xthe home directory for the job stream,
X.IP \(bu
Xthe full pathname of the program to run,
X.IP \(bu
Xoptional arguments to that program,
X.IP \(bu
Xan optional source
Xof standard input to that program (a filename prefixed by ``<''), and
X.IP \(bu
Xan optional destination
Xfor standard output from that program (a filename prefixed by ``>'').
X.LP
X.FL Tmp/workload
Xis created automatically by the command script
X.PR run
Xbased upon
X.IP (a)
Xthe variables
X.SV dirs
Xand
X.SV ttys , and
X.IP (b)
Xthe workload profile
X.FL Workload/script.master
Xfrom which the script interpreter program name is extracted
Xand the individual input script files (\c
X.FL Tmp/script.? ).
X.LP
XWhen
X.FL Tmp/workload
Xis constructed, a cyclic scheme
Xis used to share user work amongst the
Xavailable directories and tty lines (as per
X.SV dirs
Xand
X.SV ttys ).
XIn this way, serial i/o bottlenecks for large numbers of simulated
Xusers, and unbalanced disk i/o across spindles may be avoided.
XAs a dynamic check, the program
X.PR ttychk
Xis used within
X.PR run
Xto check for potential bandwidth limitations on the serial i/o
Xlines, given the number of lines and the maximum number of job streams.
X.LP
XThe workload profile (\c
X.FL Workload/script.master )
Xhas the following format.
X.IP 1.
XThe first line must begin ``%W%'' followed by the full pathname of the
Xrelevant interpreter and any required options.
XFor example, if the script should be run by the Bourne shell, an
Xappropriate specification would be
X.RS
X.HS
X%W% /bin/sh -ie
X.HE
X.RE
X.IP 2.
XAll subsequent lines up to the first line beginning with ``%%''
Xare preamble commands that must appear at the \f3beginning\fP of \f3every\fP
Xscript.
X.IP 3.
XSequences of commands terminated by a line beginning with ``%%''
Xconstitute a job step.
XEach job step is an autonomous piece of work such that once the
Xpreamble has been executed, job steps may be executed in \f3any\fP order.
X.IP 4.
XAny lines following the last ``%%'' line form a postscript
Xthat must appear at the \f3end\fP of \f3every\fP
Xscript.
X.LP
XThe command procedure
X.PR mkscript
Xand the program
X.PR mkperm
Xare used (by
X.PR run )
Xto create several (usually 4) scripts from
X.FL Workload/script/master
Xwith random permutations
Xof the job steps.
XThese scripts reside in
X.FL Tmp/script.?
Xand are assigned in a cyclic manner to create the job streams.
XThe work for \fBeach\fP
Xsimulated user is generated from
X\fBone\fP job stream.
X.LP
XFor example the distributed 
X.FL Workload/script.master
Xis
X.LP
X.RS
X.nf
X.if t .HS
X.CK Workload/script.master
X%W% /bin/sh -ie
Xmkdir /tmp/$$ tmp
X%% 1 edit
X\&./keyb edscr1.dat | ed edit.dat
X: .......................................................
X: .    This is some filler of about the same            .
X: .    size as the file edscr1.dat, since the           .
X: .    emulated input proceeds in parallel, and         .
X: .    we want the real-time delay to be about right    .
X: .......................................................
Xchmod u+w temporary
Xrm temporary
X%% 2 ls
Xls -l
X%% 3 cat
Xcat cat.dat
X%% 4 compile
Xcc -c cctest.c 1>&2
Xrm *.o
X%% 5 edit, compile and link
Xchmod 444 dummy.c
X\&./keyb edscr2.dat | ed dummy.c
X: .  more textual and time filler for the second edscript file, edscr2.dat .
Xcc dummy.c 1>&2
Xrm a.* grunt.c
X%% 6 grep
Xgrep '[ 	]*nwork' grep.dat
X%% 7 file copying
Xcp *.c edit.dat /tmp/$$
Xcp /tmp/$$/* tmp
X%%
Xrm -rf tmp /tmp/$$
X.if t .HE
X.fi
X.RE
X.LP
XThis generates several job streams one of which (\c
X.FL Tmp/script.1 )
Xcontains,
X.LP
X.RS
X.nf
X.if t .HS
X.CK Tmp/script.1
Xmkdir /tmp/$$ tmp
Xcc -c cctest.c 1>&2
Xrm *.o
X\&./keyb edscr1.dat | ed edit.dat
X: .......................................................
X: .    This is some filler of about the same            .
X: .    size as the file edscr1.dat, since the           .
X: .    emulated input proceeds in parallel, and         .
X: .    we want the real-time delay to be about right    .
X: .......................................................
Xchmod u+w temporary
Xrm temporary
Xcat cat.dat
Xgrep '[ 	]*nwork' grep.dat
Xchmod 444 dummy.c
X\&./keyb edscr2.dat | ed dummy.c
X: .  more textual and time filler for the second edscript file, edscr2.dat .
Xcc dummy.c 1>&2
Xrm a.* grunt.c
Xcp *.c edit.dat /tmp/$$
Xcp /tmp/$$/* tmp
Xls -l
Xrm -rf tmp /tmp/$$
X.if t .HE
X.fi
X.RE
X.LP
XGiven the following environment variable assignments,
X.RS
X.nf
Xnusers=8
Xttys=/dev/ttyh0 /dev/ttyh8 /dev/ttyha
Xdirs=Tmp /usr/tmp
X.fi
X.RE
Xthe created workload description file (\c
X.FL Tmp/workload )
Xcontains
X.LP
X.RS
X.nf
X.if t .HS
XTmp/user1 /bin/sh -ie <Tmp/script.1 >/dev/ttyh0
X/usr/tmp/user2 /bin/sh -ie <Tmp/script.2 >/dev/ttyh8
XTmp/user3 /bin/sh -ie <Tmp/script.3 >/dev/ttyha
X/usr/tmp/user4 /bin/sh -ie <Tmp/script.4 >/dev/ttyh0
XTmp/user5 /bin/sh -ie <Tmp/script.1 >/dev/ttyh8
X/usr/tmp/user6 /bin/sh -ie <Tmp/script.2 >/dev/ttyha
XTmp/user7 /bin/sh -ie <Tmp/script.3 >/dev/ttyh0
X/usr/tmp/user8 /bin/sh -ie <Tmp/script.4 >/dev/ttyh8
X.if t .HE
X.fi
X.RE
X.LP
XIt is strongly recommended that you create your own workload
Xprofile for the multi-user test to reflect the anticipated
Xsystem usage.
XTo do this,
X.IP 1.
XUse the distributed files in the
X.FL Workload
Xdirectory as a guide.
X.IP 2.
XCreate a new
X.FL Workload/script.master
Xdescribing the required job steps.
X.IP 3.
XEnsure all required data files are in the
X.FL Workload
Xdirectory, because every job stream executes with the current
Xdirectory containing its own private copies of \f3all\fP the
Xfiles from
X.FL Workload .
X.IP 4.
XEnsure the makefile (\c
X.FL Workload/Makefile )
Xhas the following targets defined (they are assumed to exist by
X.PR run ).
X.RS
X.nr II 6n
X.IP (a)
Xcontext : ensure all files needed to run a script are present.
X.IP (b)
Xclean : remove any unnecessary temporary files, e.g. those created from
Xsomewhere else during a ``make context''.
X.IP (c)
Xscript.out : run a script and trap all the output; the file
X.FL script.out
Xshould contain the concatenation of the script input and the
Xscript output.
XThis file is used by
X.PR ttychk
Xto compute the output tty bandwidth requirements.
X.RE
X.nr II 0
X.LP
XThe program
X.PR makework
Xreads the
X.FL Tmp/workload
Xfile and builds data structures
Xfor each job stream (i.e. each simulated user) describing the home
Xdirectory, command interpreter and its options and standard input and
Xstandard output assignments.
XThereafter
X.PR makework
Xstarts the user program(s) (\c
X.PR /bin/sh
Xabove) and pumps
Xrandom chunks of input to them down pipes
Xso that the aggregate rate across all simulated users does not exceed
X.SV rate
X\(mu
X.SV nusers
Xcharacters per second.
X.LP
XBecause of process creation limits, this test
X\fBmust be run as root\fP.
X.LP
XBecause of open file limits,
X.PR makework
Xwill create \fIclones\fP of itself if
Xthere are too many users for it to simulate alone.
X.LP
XIf the standard input files to the job streams invoke interactive
Xprograms (e.g. \c
X.PR ed ),
Xthen substantial care must be taken that the data
Xpumped down the pipe by
X.PR makework
Xends up at the correct destination.
XThis has been the cause of some catastrophic problems in which only
Xparts of the job streams have been run by 
X.PR /bin/sh
Xand the rest has
Xbeen sucked up and thrown away by 
X.PR /bin/ed .
X.LP
XTo try and avoid these problems, the program
X.PR keyb
Xhas been
Xcreated to emulate one user typing at a terminal.
X.PR keyb
X(like
X.PR makework )
Xuses the environment variables
X.SV rate
Xand
X.SV tty
X(as set up by
X.PR run )
Xto know how fast to generate output and where the input
Xshould be echoed to.
X.LP
XOnce
X.PR run
Xwork has finished, it is \fBessential\fP
Xthat the following checks be performed.
X.IP (1)
XLook in the file
X.FL Results/log .
XCheck for wild variances in the execution times (a sign that not all job streams
Xare being run to completion), and any obscure error messages that would
Xhave been generated on stderr from
X.PR makework .
XMake sure that the execution times look reasonable.
XOne easy check is that the CPU time for ``n'' users
X\f2must be at least\fP
X\&``n'' times the CPU time for one simulated user, since the CPU times
Xshould be nearly the same for all users in a given run (although
Xthe CPU time per user is expected to rise as the number of concurrent
Xusers increases).
X.IP (2)
XCheck the file
X.FL Results/log.work
Xthat contains echoed comments, status information
Xand shell error output from the simulated user work.
X.nr II 4n
X.LP
XThe lines preceded by a line of the form ``Tmp/userlog.nnn:'' are copies of
Xthe shell error output for simulated user ``nnn''.
XThis should consist of a row of ``# ''s (assuming root's 
X.PR /bin/sh
Xprompt is ``# '').
X.LP
XThe lines preceded by a line of the form ``Tmp/masterlog.nnn:'' are
Xthe standard error output from master number ``nnn''.
XMaster 0 is the real master
X.PR makework
Xprocess, the others are clones.
XCheck that there are no messages of the forms,
X.RS
X.nf
X.if t .HS
Xmakework: cannot open %s for std output
Xmakework: chdir to "%s" failed!
Xuser %d job %d pid %d done exit code %d
Xuser %d job %d pid %d done status 0x%x
Xuser %d job %d pid %d done exit code %d status 0x%x
Xclone %d done, pid %d exit code %d
Xclone %d done, pid %d status 0x%x
Xclone %d done, pid %d exit code %d status 0x%x
Xuser %d job %d pid %d killed off
X\&... reason ... pid %d killed off
X.if t .HE
X.fi
X.RE
X\fBAny\fP these messages indicate something has gone terribly wrong.
X.LP
XOn the other hand, messages of the form
X.RS
X.nf
X.if t .HS
Xmaster pid %d
Xclone %d pid %d
Xuser %d job %d pid %d pipe fd %d
Xuser %d job %d pid %d done
Xclone %d done, pid %d
X.if t .HE
X.fi
X.RE
Xare just warm reassurance that everything is going well.
X.nr II 0
X.NH 3.3 Miscellaneous
X.TN x
XLike ``run work'', except the initial filesystem status reporting,
Xtty bandwidth check
Xand clock checks are omitted.
XUseful when using the multi-user test for diagnostic purposes, and the
Xinitial housekeeping is not needed.
X.NH 4 "The Complete Test"
X.LP
XWhen everything is apparently installed and operating correctly, 
Xlogin as root, choose another inactive terminal running at 9600 baud
X(/dev/ttyx below) and start the whole charade as follows.
X.SC tty=/dev/ttyx
X.SC "export tty"
X.SC "rm Report/log Report/log.work"
X.SC "./run &"
X.LP
XOn a 4 Mbyte VAX 11/780, simulating 1, 4, 8, 16, 24 and 32
Xusers in the multi-user test, this takes about 5 hours to run!
X.NH 5 "What Does It All Mean?"
X.LP
XFinally one should be in a position to contemplate the summaries in
Xthe
X.FL Results/log
Xfile.
XLook in
X.FL Tools
Xfor the scripts
X.PR mktbl
Xand
X.PR mkcomp
Xto create
X.PR tbl
Xinput directly from the log files
Xfor a single system or to compare two systems.
XThis is most useful in comparison to the same tests run on another
Xsystem, or on another version of the same system.
X.LP
XLots of things can influence the results, and people interpreting
Xthe results should be aware of the following (probably incomplete)
Xlist.
X.IP (1)
XAvailable real memory for the disk block cache and user processes.
X.IP (2)
XThe physical disk hardware; number and type of spindles, controller
Xtype and paths to devices.
X.IP (3)
XThe logical disk arrangement; allocation of critical directories such
Xas 
X.PR /tmp , 
X.PR /usr
Xand user filesystem across physical devices, the number
Xand distribution of swap partitions.
X.IP (4)
XStandard of C compiler and optimizer; everything tested is written
Xin C, any improvements here will help everything (even the kernel!).
X.IP (5)
XPhysical block size for swapping and paging; some of the test programs
Xare very small and so may incur large physical i/o costs.
X.IP (6)
XFlavour of UNIX you are using.
X.IP (7)
XThe accuracy of real time measurements and flow control in
X.PR makework .
XCheck the output from
X.PR clock
Xin
X.FL Results/log
Xat the start of the multi-user
Xtest to determine the extent to which a controlling SIGALRM loop
Xmeasures wallclock time -- this can influence elapsed time in the
Xmulti-user test particularly.
X.NH 6 "Caveat Emptor"
X.LP
XThe MUSBUS tests have been widely distributed, and in some cases
Xtheir owners have not treated them kindly.
XThe following list details known pitfalls in running the tests
Xand the subsequent application of the results.
X.IP (1)
XThere are several versions of the test suite, Version 3.3 (and later
Xversions) in particular
Xare very different to earlier versions and results obtained
Xwith different versions of the suite cannot be meaningfully
Xcompared.
XI make no claim for the long-term
Xstability of MUSBUS, and so this evolutionary
Xprocess is likely to continue with future releases of the test suite.
X.IP (2)
XThere is \fBno\fP reason to suspect that the distributed workload
Xfor the multi-user test (i.e. the files
X.FL Tmp/script.?
Xand
X.FL Tmp/workload )
Xare representative of the user work profile at \fByour\fP installation(s).
XBe prepared to alter or rebuild the workload to reflect your
Xexpected system usage.
X.IP (3)
XResults have been known to vary
Xdramatically between releases of the UNIX you
Xare testing.
XThis reflects vendor tuning (sometimes breaking) of the UNIX port
Xand MUSBUS is a useful diagnostic tool in this area, provided the
XMUSBUS version and workload profile remain fixed.
X.IP (4)
XPoints (1) to (3) suggest that uncontrolled and uninformed
Xcomparisons of
XMUSBUS results is dangerous in the extreme.
XThis is the main reason that I have not published the large
Xcollection of results accumulated to date.
X.IP (5)
XRemember that the tests described in Section 3.1 are intended
Xfor \fBdiagnostic\fP use.
XIf you are interested in \fBperformance\fP, you should focus
Xupon the multi-user test described in Section 3.2.
X.IP (6)
XBeware of simulating \fBtoo few\fP users in the multi-user
Xtest.
XUseful information about system throughput and performance
Xunder heavy load conditions can usually be obtained by
Xextrapolation of various measures computed from the
XCPU and elapsed times for the multi-user tests with
Xvarious numbers of users.
XHowever this assumes the machine has been sufficiently loaded to
Xmove out of the \fIlinear\fP part of the performance curves.
XFor very fast machines, this may require emulation of
Xa \fIlarge\fP number of users in the multi-user test.
X.IP (7)
XBeware of simulating \fBtoo many\fP users in the multi-user
Xtest.
XUsing the default value for
X.SV ttys ,
X\fBall\fP simulated
Xtty output is directed to a \fIsingle\fP serial port.
XAs you increase the number of simulated users in the multi-user
Xtest (in response to Point (6) above) the serial port
Xbandwidth may become the limiting resource!
XThis is easy to fix by adding a list of more tty devices to the 
Xvalue of
X.SV ttys .
X.IP (8)
XBe warned that the multi-user test has ``broken'' several UNIX
Xports.
XCauses have been identified as implementation (configuration)
Xlimits in the system being tested (e.g. proc slots), real
Xbugs in the port or MUSBUS errors.
XThis list is basically in order of decreasing probability.
X.LP
XCommunication on MUSBUS experiences is welcomed at the
Xelectronic addresses on the first page of this document.
XIf you have found a problem, or can suggest a better testing
Xtechnique please let me know, so that future versions might
Xoffer real (as opposed to cosmetic) enhancements.
End-of-File-Grunt
if test 33901 -ne `cat 'Intro.nr' | wc -c`
then
	echo 'shar: transmission error (expected 33901 characters)'
fi
echo 'x - Makefile'
if test -f 'Makefile'
then
	echo 'shar: over-writing existing file Makefile'
fi
sed 's/^X//' > Makefile <<'End-of-File-Grunt'
X# MUSBUS Makefile
X# $Header: Makefile,v 3.18 87/09/17 06:35:58 kenj Exp $
XCFLAGS = -O -DBSD4v2
XPROGS = arithoh register short int long float double hanoi \
X	randmem seqmem fstime \
X	syscall context1 pipe spawn execl makework keyb \
X	iamalive limit clock precision ttychk mkperm
XMOSTPROGS = arithoh register short int long float double hanoi \
X	randmem seqmem fstime \
X	syscall context1 pipe spawn execl limit precision \
X	mkperm
XDATAFILES = BSDtime.awk Groan Intro.nr SysVtime.awk \
X	check.sed cleanup dc.dat fs.awk mem.awk \
X	mkscript run time.awk README
XSOURCES = arith.c mem.c fstime.c syscall.c context1.c pipe.c spawn.c \
X	big.c execl.c makework.c util.c getwork.c keyb.c iamalive.c \
X	limit.c clock.c precision.c ttychk.c mkperm.c makework.h \
X	cctest.c hanoi.c \
X	mkdistrib mkinstall musbus.1
XTOOLS = Adjust Config comptbl.1 comptbl.2 comptbl.3 comptbl.4 comptbl.5 \
X	mk1 mk2 mkcomp mktbl tbl.1 tbl.2 tbl.3 tbl.4 tbl.5 
XWORKS = Makefile,1 cat.dat dummy.c edit.dat edscr1.dat edscr2.dat \
X	grep.dat mkprofile mkscript.out script.master
XMANIFESTS = Workload.files Results.files Tools.files
XXSCRIPTS = Tools/Adjust Tools/Config Tools/mk1 Tools/mk2 Tools/mkcomp \
X	Tools/mktbl \
X	Workload/mkprofile Workload/mkscript.out \
X	Groan cleanup mkdistrib mkinstall mkscript run
X# Create all the binaries
Xprograms:	source $(PROGS)
Xsource:	$(SOURCES) $(DATAFILES)
Xinstall:
X	@chmod 755 mkinstall
X	./mkinstall
X	@chmod 755 $(XSCRIPTS)
Xunrcs:	$(SOURCES) $(DATAFILES) $(TOOLS) $(WORKS) $(MANIFESTS)
X# Workload scripts
Xscript:	Tmp Tmp/script.1 Tmp/script.out
X# Individual programs
Xarithoh:	arith.c
X	cc -o arithoh ${CFLAGS} -Darithoh arith.c
Xregister:	arith.c
X	cc -o register ${CFLAGS} -Ddatum=register arith.c
Xshort:	arith.c
X	cc -o short ${CFLAGS} -Ddatum=short arith.c
Xint:	arith.c
X	cc -o int ${CFLAGS} -Ddatum=int arith.c
Xlong:	arith.c
X	cc -o long ${CFLAGS} -Ddatum=long arith.c
Xfloat:	arith.c
X	cc -o float ${CFLAGS} -Ddatum=float arith.c
Xdouble:	arith.c
X	cc -o double ${CFLAGS} -Ddatum=double arith.c
Xhanoi:	hanoi.c
X	cc -o hanoi ${CFLAGS} hanoi.c
Xrandmem:	mem.c
X	cc -o randmem ${CFLAGS} -Dawk -Drandom mem.c
Xseqmem:	mem.c
X	cc -o seqmem ${CFLAGS} -Dawk mem.c
Xfstime:	fstime.c
X	cc -o fstime ${CFLAGS} -Dawk=1 fstime.c
Xsyscall:	syscall.c
X	cc -o syscall ${CFLAGS} syscall.c
Xcontext1:	context1.c
X	cc -o context1 ${CFLAGS} context1.c
Xpipe:	pipe.c
X	cc -o pipe ${CFLAGS} pipe.c
Xspawn:	spawn.c
X	cc -o spawn ${CFLAGS} spawn.c
Xexecl:	execl.c big.c
X	cc -o execl ${CFLAGS} execl.c
Xmakework:	makework.o util.o getwork.o
X	cc -o makework $(CFLAGS) makework.o util.o getwork.o
Xmakework.o:	makework.c makework.h
Xutil.o:	util.c makework.h
Xgetwork.o:	getwork.c makework.h
Xkeyb:	keyb.c
X	cc -o keyb ${CFLAGS} keyb.c
Xiamalive:	iamalive.c
X	cc -o iamalive ${CFLAGS} iamalive.c
Xlimit:	limit.c
X	cc -o limit ${CFLAGS} limit.c
Xclock:	clock.c
X	cc -o clock ${CFLAGS} clock.c
Xprecision:	precision.c
X	cc -o precision ${CFLAGS} precision.c
Xttychk:	ttychk.c
X	cc -o ttychk ${CFLAGS} ttychk.c
Xmkperm:	mkperm.c
X	cc -o mkperm ${CFLAGS} mkperm.c
XTmp/script.1: 	Workload/script.master mkperm mkscript
X	./mkscript 4 Workload/script.master
X	rm -f Tmp/script.[1-4]
X	mv script.[1-4] Tmp
XTmp/script.out: 	Workload/script.master
X	cd Workload ; make script.out
X	rm -f Tmp/script.out
X	mv Workload/script.out Tmp
X# Clean out the unnecessary stuff before the multi-user test
Xinitwork:	clean
X	/bin/rm -f *.o core a.out ${MOSTPROGS}
X# Housekeeping
Xprint:
X	pr run *.c cleanup *.awk *.sed workload script.master edscript.? | lpr
Xmodes:
X	chmod 444 *.c *.awk
X	cd Work ; chmod 444 *.c *.dat script.* workload
X	chmod 444 Intro.nr Makefile check.sed
X	chmod 555 Config Groan cleanup run 
Xclean:	Tmp
X	@cd Tmp ; /bin/rm -f a.out core *.o *.tmp ed.hup script.?.time
X	@cd Tmp ; /bin/rm -f masterlog.* userlog.* loggederrs
Xpurge:	clean
X	@/bin/rm -f *.o core a.out ${PROGS}
X	@cd Tmp ; /bin/rm -rf *
XTmp:
X	@mkdir Tmp
X.DEFAULT:
X	co $@
End-of-File-Grunt
if test 3857 -ne `cat 'Makefile' | wc -c`
then
	echo 'shar: transmission error (expected 3857 characters)'
fi
echo 'x - Makefile,1'
if test -f 'Makefile,1'
then
	echo 'shar: over-writing existing file Makefile,1'
fi
sed 's/^X//' > Makefile,1 <<'End-of-File-Grunt'
X# $Header: Workload.make,v 1.1 87/06/23 15:14:00 kjmcdonell Beta $
XDUMMY	= aa.1.dat aa.2.dat aa.3.dat aa.4.dat aa.5.dat aa.6.dat \
X	mm.1.dat mm.2.dat mm.3.dat mm.4.dat mm.5.dat mm.6.dat \
X	zz.1.dat zz.2.dat zz.3.dat zz.4.dat zz.5.dat zz.6.dat
XDATA	= cat.dat cctest.c dummy.c edit.dat edscr1.dat edscr2.dat \
X	grep.dat script.master
X
Xcontext: $(DATA) $(DUMMY) keyb
X
Xclean:
X	rm -f $(DUMMY) core script.? script.out workload keyb cctest.c
X	rm -rf .tmp
X
Xscript.out:	script.master
X	./mkscript.out
X
X$(DUMMY):
X	touch $@
X
Xkeyb:	../keyb
X	cp ../keyb keyb
X../keyb:
X	cd .. ; make keyb
Xcctest.c:	../cctest.c
X	cp ../cctest.c .
X../cctest.c:
X	cd .. ; make cctest.c
X
X.DEFAULT:
X	co ../RCS/$@,v
End-of-File-Grunt
if test 676 -ne `cat 'Makefile,1' | wc -c`
then
	echo 'shar: transmission error (expected 676 characters)'
fi
echo 'x - README'
if test -f 'README'
then
	echo 'shar: over-writing existing file README'
fi
sed 's/^X//' > README <<'End-of-File-Grunt'
XMUSBUS - Monash University Software for Benchmarking Unix Systems
X
XMUSBUS Version 5.0 -- Installation Notes
X
X1) make install
X	- creates relevant subdirectories and moves files about
X	- if the distribution has already been unpacked, this
X	  will do nothing, so it cannot hurt!
X
X2) Format and read the installation notes and user guide, as in
X
X	[tn]roff Intro.nr | ...
X
X3) Follow the instructions therein.
X
X4) Note that the distributed workload profile (Workload/* when unpacked)
X   may not be representative of your system's current or anticipated
X   user profile, in which case the scripts and data files should be
X   changed -- see Intro.nr for details and implications.
End-of-File-Grunt
if test 672 -ne `cat 'README' | wc -c`
then
	echo 'shar: transmission error (expected 672 characters)'
fi
echo 'x - Results.files'
if test -f 'Results.files'
then
	echo 'shar: over-writing existing file Results.files'
fi
sed 's/^X//' > Results.files <<'End-of-File-Grunt'
Xlog.785
Xlog.sun3-50
Xlog.uVaxII
End-of-File-Grunt
if test 31 -ne `cat 'Results.files' | wc -c`
then
	echo 'shar: transmission error (expected 31 characters)'
fi
echo 'x - SysVtime.awk'
if test -f 'SysVtime.awk'
then
	echo 'shar: over-writing existing file SysVtime.awk'
fi
sed 's/^X//' > SysVtime.awk <<'End-of-File-Grunt'
X# $Header: SysVtime.awk,v 3.4 87/06/22 14:27:23 kjmcdonell Beta $
X/^[Rr]eal/ {
X	if (!fail) {
X	    l=length($2); m=substr($2,1,l-5); s=substr($2,l-3,4)
X	    t=m*60+s; real+=t; r2+=t*t; ok++
X	}
X	iter++; fail=0; next }
X/^[Uu]ser/ {
X	l=length($2); m=substr($2,1,l-5); s=substr($2,l-3,4)
X	t=m*60+s; user+=t; cpu=t; next }
X/^[Ss]ys/ {
X	l=length($2); m=substr($2,1,l-5); s=substr($2,l-3,4)
X	t=m*60+s; sys+=t; c2+=(cpu+t)*(cpu+t); next }
X/^$/	{ next }
X	{ print "** Iteration ",iter+1," Failed: ",$0; fail=1 }
XEND {
X	if (fail) iter++
X	if (ok != iter) {
X	    printf "For %d successful iterations from %d attempts ...\n",ok,iter
X	    iter=ok
X	}
X	if (iter > 0) {
X	    printf "Elapsed Time: %.2f seconds",real/iter
X	    if (iter > 1) printf " (variance %.3f)",(r2-2*real*real/iter+real*real/iter)/(iter-1)
X	    cpu=sys+user
X	    printf "\nCPU Time: %.2f seconds [ %.2fu + %.2fs ]",cpu/iter,user/iter,sys/iter
X	    if (iter > 1) printf " (variance %.3f)",(c2-2*cpu*cpu/iter+cpu*cpu/iter)/(iter-1)
X	    print
X	} else {
X	    print "Elapsed Time: -- no measured results!!"
X	    print "CPU Time: -- no measured results!!"
X	}
X    }
End-of-File-Grunt
if test 1113 -ne `cat 'SysVtime.awk' | wc -c`
then
	echo 'shar: transmission error (expected 1113 characters)'
fi
echo 'x - Tools.files'
if test -f 'Tools.files'
then
	echo 'shar: over-writing existing file Tools.files'
fi
sed 's/^X//' > Tools.files <<'End-of-File-Grunt'
XAdjust
XConfig
Xcomptbl.1
Xcomptbl.2
Xcomptbl.3
Xcomptbl.4
Xcomptbl.5
Xmk1
Xmk2
Xmkcomp
Xmktbl
Xtbl.1
Xtbl.2
Xtbl.3
Xtbl.4
Xtbl.5
End-of-File-Grunt
if test 115 -ne `cat 'Tools.files' | wc -c`
then
	echo 'shar: transmission error (expected 115 characters)'
fi
echo 'x - Workload.files'
if test -f 'Workload.files'
then
	echo 'shar: over-writing existing file Workload.files'
fi
sed 's/^X//' > Workload.files <<'End-of-File-Grunt'
XMakefile,1
Xcat.dat
Xdummy.c
Xedit.dat
Xedscr1.dat
Xedscr2.dat
Xgrep.dat
Xmkprofile
Xmkscript.out
Xscript.master
End-of-File-Grunt
if test 104 -ne `cat 'Workload.files' | wc -c`
then
	echo 'shar: transmission error (expected 104 characters)'
fi
echo 'x - arith.c'
if test -f 'arith.c'
then
	echo 'shar: over-writing existing file arith.c'
fi
sed 's/^X//' > arith.c <<'End-of-File-Grunt'
X
X/*
X *  arithmetic test
X *
X * $Header: arith.c,v 3.5 87/08/06 08:11:18 kenj Exp $
X */
X
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	int	iter;
X	int	i;
X#ifndef arithoh
X	datum	x, y, z;
X#endif
X
X	if (argc != 2) {
X		printf("Usage: %s count\n", argv[0]);
X		exit(1);
X	}
X
X	iter = atoi(argv[1]);
X
X	while (iter-- > 0) {
X#ifndef arithoh
X		z = 0;
X#endif
X		/*
X		 *     101
X		 * sum       i*i/(i*i-1)
X		 *     i=2
X		 */
X		for (i=2; i<=101; i++) {
X#ifndef arithoh
X			x = i;
X			y = x*x;
X			z += y/(y-1);
X#endif
X		}
X	}
X	exit(0);
X}
End-of-File-Grunt
if test 512 -ne `cat 'arith.c' | wc -c`
then
	echo 'shar: transmission error (expected 512 characters)'
fi
