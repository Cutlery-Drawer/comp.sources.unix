Subject:  v11i095:  Template mode for GNU Emacs, Part05/06
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: "Mark A. Ardis" <maa@sei.cmu.edu>
Posting-number: Volume 11, Issue 95
Archive-name: templates/part05

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	awk.el
#	bib.el
#	pascal.el
#	menu.el
#	symbol.el
#	tplreplace.el
export PATH; PATH=/bin:/usr/bin:$PATH
echo shar: "extracting 'awk.el'" '(686 characters)'
if test -f 'awk.el'
then
	echo shar: "will not over-write existing file 'awk.el'"
else
sed 's/^X//' << \SHAR_EOF > 'awk.el'
X;;; awk.el -- Awk mode for Gnuemacs
X;;; Copyright (C) 1987 Mark A. Ardis.
X
X(provide 'awk)
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defvar awk-mode-map nil
X  "Key map for Awk mode."
X  ) ; awk-mode-map
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun awk-mode ()
X  "Fundamental mode plus Awk templates:
X\\{awk-mode-map}
X"
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (setq major-mode 'awk-mode)
X    (setq mode-name "Awk")
X    (template-mode)
X    (setq awk-mode-map (current-local-map))
X    ) ; let
X  ) ; defun awk-mode
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X;;; end of awk.el
SHAR_EOF
if test 686 -ne "`wc -c < 'awk.el'`"
then
	echo shar: "error transmitting 'awk.el'" '(should have been 686 characters)'
fi
fi
echo shar: "extracting 'bib.el'" '(685 characters)'
if test -f 'bib.el'
then
	echo shar: "will not over-write existing file 'bib.el'"
else
sed 's/^X//' << \SHAR_EOF > 'bib.el'
X;;; bib.el -- Bib mode for Gnuemacs
X;;; Copyright (C) 1987 Mark A. Ardis.
X
X(provide 'bib)
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defvar bib-mode-map nil
X  "Keymap for Bib Mode."
X  ) ; bib-mode-map
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun bib-mode ()
X  "Fundamental mode plus Bib templates:
X\\{bib-mode-map}
X"
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (setq major-mode 'bib-mode)
X    (setq mode-name "Bib")
X    (template-mode)
X    (setq bib-mode-map (current-local-map))
X    ) ; let
X  ) ; defun bib-mode
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X;;; end of bib.el
SHAR_EOF
if test 685 -ne "`wc -c < 'bib.el'`"
then
	echo shar: "error transmitting 'bib.el'" '(should have been 685 characters)'
fi
fi
echo shar: "extracting 'pascal.el'" '(727 characters)'
if test -f 'pascal.el'
then
	echo shar: "will not over-write existing file 'pascal.el'"
else
sed 's/^X//' << \SHAR_EOF > 'pascal.el'
X;;; pascal.el -- Pascal mode for Gnuemacs
X;;; Copyright (C) 1987 Mark A. Ardis.
X
X(provide 'pascal)
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defvar pascal-mode-map nil
X  "Keymap for Pascal Mode."
X  ) ; pascal-mode-map
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun pascal-mode ()
X  "Fundamental mode plus Pascal templates:
X\\{pascal-mode-map}
X"
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (setq major-mode 'pascal-mode)
X    (setq mode-name "Pascal")
X    (template-mode)
X    (setq pascal-mode-map (current-local-map))
X    ) ; let
X  ) ; defun pascal-mode
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X;;; end of pascal.el
SHAR_EOF
if test 727 -ne "`wc -c < 'pascal.el'`"
then
	echo shar: "error transmitting 'pascal.el'" '(should have been 727 characters)'
fi
fi
echo shar: "extracting 'menu.el'" '(6276 characters)'
if test -f 'menu.el'
then
	echo shar: "will not over-write existing file 'menu.el'"
else
sed 's/^X//' << \SHAR_EOF > 'menu.el'
X;;; menu.el
X;;; Copyright (C) 1987 Mark A. Ardis.
X
X(provide 'menu)
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defvar menu-choice nil
X  "Item selected from menu."
X) ; menu-choice
X(make-variable-buffer-local 'menu-choice)
X
X(defvar menu-last-input ""
X  "String used for searching through menu."
X) ; menu-last-input
X(make-variable-buffer-local 'menu-last-input)
X(setq-default menu-last-input "")
X
X(defvar menu-mode-map nil "Key-map for Menu Mode.")
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun menu-mode ()
X  "Major mode for selecting an item from a menu.
X     Like View Mode, but with only the following commands:
X     Space, C-n   menu-next-item
X     Del, C-p     menu-previous-item
X     a,b,...,z    menu-next-match
X     Return, Linefeed, ESC C-c   exit.
X   Returns the line selected."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (or menu-mode-map
X	(menu-set-local-keys))
X    (use-local-map menu-mode-map)
X    (setq major-mode 'menu-mode)
X    (setq mode-name "Menu")
X    (setq case-fold-search t)
X    (setq menu-last-input "")
X					; Prompt for selection
X    (message "Position on selection and exit with Return (or ESC-^c).")
X					; Wait for user's selction
X    (setq menu-choice nil)
X    (unwind-protect
X	(recursive-edit)
X    ) ; unwind-protect
X					; Return selection
X    menu-choice
X  ) ; let
X) ; defun menu-mode
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun menu-abort-recursive-edit ()
X  "Abort recursive edit in menu-mode gracefully."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (setq menu-choice nil)
X    (exit-recursive-edit)
X  ) ; let
X) ; defun menu-abort-recursive-edit
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun menu-exit-recursive-edit ()
X  "Pick up selection and exit Menu-mode."
X  (interactive)
X					; Local Variables
X  (let (start stop)
X					; Body
X    (beginning-of-line)
X    (setq start (point))
X    (end-of-line)
X    (setq stop (point))
X    (setq menu-choice (buffer-substring start stop))
X    (exit-recursive-edit)
X  ) ; let
X) ; defun menu-exit-recursive-edit
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun menu-next-item ()
X  "Go to the next item in the menu (wrap around at end)."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (end-of-line)
X    (if (eobp)
X      (beginning-of-buffer)
X      (beginning-of-line 2)
X    ) ; if
X    (setq menu-last-input "")
X  ) ; let
X) ; defun menu-next-item
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun menu-next-match ()
X  "Find the next item with last-input-char leading character."
X  (interactive)
X					; Local Variables
X  (let (stop)
X					; Body
X    (setq menu-last-input
X	  (concat menu-last-input (char-to-string last-input-char)))
X    (beginning-of-line)
X    (if (not (re-search-forward (concat "^" menu-last-input) nil t))
X      (progn
X	(setq stop (point))
X	(beginning-of-buffer)
X	(if (not (re-search-forward (concat "^" menu-last-input) stop stop))
X	  (progn
X	    (message "No match for that character!")
X	    (ding)
X	    (setq menu-last-input "")
X	  ) ; progn
X	) ; if
X      ) ; progn
X    ) ; if
X  ) ; let
X) ; defun menu-next-match
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun menu-previous-item ()
X  "Go to the previous item in the menu (wrap around at beginning)."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (beginning-of-line)
X    (if (bobp)
X      (progn
X	(end-of-buffer)
X	(beginning-of-line)
X      ) ; progn
X      (beginning-of-line 0)
X    ) ; if
X    (setq menu-last-input "")
X  ) ; let
X) ; defun menu-previous-item
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun menu-set-local-keys ()
X  "Create key-map for Menu Mode."
X					; Local Variables
X  (let ()
X					; Body
X    (setq menu-mode-map (make-keymap))
X    (suppress-keymap menu-mode-map)
X    (define-key menu-mode-map "\C-g" 'menu-abort-recursive-edit)
X    (define-key menu-mode-map "\C-j" 'menu-exit-recursive-edit) ; LFD
X    (define-key menu-mode-map "\C-m" 'menu-exit-recursive-edit) ; CR
X    (define-key menu-mode-map "\e\C-c" 'menu-exit-recursive-edit)
X    (define-key menu-mode-map " " 'menu-next-item)
X    (define-key menu-mode-map "\C-n" 'menu-next-item)
X    (define-key menu-mode-map "\C-p" 'menu-previous-item)
X    (define-key menu-mode-map "\177" 'menu-previous-item) ; DEL
X    (define-key menu-mode-map "a" 'menu-next-match)
X    (define-key menu-mode-map "b" 'menu-next-match)
X    (define-key menu-mode-map "c" 'menu-next-match)
X    (define-key menu-mode-map "d" 'menu-next-match)
X    (define-key menu-mode-map "e" 'menu-next-match)
X    (define-key menu-mode-map "f" 'menu-next-match)
X    (define-key menu-mode-map "g" 'menu-next-match)
X    (define-key menu-mode-map "h" 'menu-next-match)
X    (define-key menu-mode-map "i" 'menu-next-match)
X    (define-key menu-mode-map "j" 'menu-next-match)
X    (define-key menu-mode-map "k" 'menu-next-match)
X    (define-key menu-mode-map "l" 'menu-next-match)
X    (define-key menu-mode-map "m" 'menu-next-match)
X    (define-key menu-mode-map "n" 'menu-next-match)
X    (define-key menu-mode-map "o" 'menu-next-match)
X    (define-key menu-mode-map "p" 'menu-next-match)
X    (define-key menu-mode-map "q" 'menu-next-match)
X    (define-key menu-mode-map "r" 'menu-next-match)
X    (define-key menu-mode-map "s" 'menu-next-match)
X    (define-key menu-mode-map "t" 'menu-next-match)
X    (define-key menu-mode-map "u" 'menu-next-match)
X    (define-key menu-mode-map "v" 'menu-next-match)
X    (define-key menu-mode-map "w" 'menu-next-match)
X    (define-key menu-mode-map "x" 'menu-next-match)
X    (define-key menu-mode-map "y" 'menu-next-match)
X    (define-key menu-mode-map "z" 'menu-next-match)
X  ) ; let
X) ; defun menu-set-local-keys
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun menu-undefined ()
X  "Catch all undefined keys for Menu Mode."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (ding)
X    (message "C-n for next, C-p for previous, Return (or ESC-^c) to quit.")
X    (setq menu-last-input "")
X  ) ; let
X) ; defun menu-undefined
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X;;; end of menu.el
SHAR_EOF
if test 6276 -ne "`wc -c < 'menu.el'`"
then
	echo shar: "error transmitting 'menu.el'" '(should have been 6276 characters)'
fi
fi
echo shar: "extracting 'symbol.el'" '(25432 characters)'
if test -f 'symbol.el'
then
	echo shar: "will not over-write existing file 'symbol.el'"
else
sed 's/^X//' << \SHAR_EOF > 'symbol.el'
X;;; symbol.el -- Identifier completion facilities
X;;; Copyright (C) 1987 Mark A. Ardis.
X
X(provide 'symbol)
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defvar sym-completion-buffer nil
X  "Buffer containing user-entered symbols for identifier completion."
X) ; sym-completion-buffer
X(make-variable-buffer-local 'sym-completion-buffer)
X
X(defvar sym-end-display "<<"
X  "*Display marker after string to be created in symbol mode."
X) ; sym-end-display
X
X(defvar sym-end-marker (make-marker)
X  "Marker at end of symbol."
X) ; sym-end-marker
X(make-variable-buffer-local 'sym-end-marker)
X(setq-default sym-end-marker (make-marker))
X
X(defvar sym-original nil
X  "Text string originally present, to be replaced in symbol-mode."
X) ; sym-original
X(make-variable-buffer-local 'sym-original)
X
X(defvar sym-start-display ">>"
X  "*Display marker before string to be created in symbol mode."
X) ; sym-start-display
X
X(defvar sym-start nil
X  "Position of start of symbol in buffer."
X) ; sym-start
X(make-variable-buffer-local 'sym-start)
X
X(defvar symbol-mode-map nil
X  "Key-map for Symbol Mode."
X) ; symbol-mode-map
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun symbol-mode ()
X  "Major mode for inserting symbols in place.  Like any other mode,
X    except that newline terminates it, and the following commands
X    are available:
X      TAB  attempt to complete last identifier typed
X    Meant to be called from sym-read-string, which initializes."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (or symbol-mode-map
X      (sym-set-local-keys))
X    (use-local-map symbol-mode-map)
X    (setq major-mode 'symbol-mode)
X    (setq mode-name "Symbol")
X  ) ; let
X) ; defun symbol-mode
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun add-symbol ()
X  "Add the symbol before point to the template-mode completion list."
X  (interactive)
X					; Local Variables
X  (let (start)
X					; Body
X    (forward-word -1)
X    (setq start (point))
X    (forward-word 1)
X    (sym-enter-id (buffer-substring start (point)))
X  ) ; let
X) ; defun add-symbol
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun expand-symbol ()
X  "Expand the symbol before point using the template-mode completion list."
X  (interactive)
X					; Local Variables
X  (let (start result)
X					; Body
X    (forward-word -1)
X    (setq start (point))
X    (forward-word 1)
X    (setq result (sym-complete-id (buffer-substring start (point))))
X    (backward-kill-word 1)
X    (insert-before-markers result)
X  ) ; let
X) ; defun expand-symbol
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-abort-recursive-edit ()
X  "Catch abort and repair entry."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (sym-reposition-point)
X    (if (< sym-start (marker-position sym-end-marker))
X      (progn
X	(delete-region sym-start (marker-position sym-end-marker))
X	(sym-reset-display)
X      ) ; progn
X    ) ; if
X    (abort-recursive-edit)
X  ) ; let
X) ; defun sym-illegal-command
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-backward-char ()
X  "Move point left one character, if possible."
X					; Local Variables
X  (interactive)
X  (let ()
X					; Body
X    (sym-reposition-point)
X    (if (> (point) sym-start)
X      (backward-char 1)
X					; else cannot advance
X      (ding)
X    ) ; if
X  ) ; let
X) ; defun sym-backward-char
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-backward-kill-word ()
X  "Delete the previous word in symbol-mode."
X					; Local Variables
X  (interactive)
X  (let ()
X					; Body
X    (sym-reposition-point)
X    (if (> (point) sym-start)
X      (progn
X	(backward-kill-word 1)
X					; If empty input, restore original
X	(sym-reset-display)
X      ) ; progn
X					; else cannot delete
X      (ding)
X    ) ; if
X  ) ; let
X) ; defun sym-backward-kill-word
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-backward-word ()
X  "Move point left one word, if possible."
X					; Local Variables
X  (interactive)
X  (let ()
X					; Body
X    (sym-reposition-point)
X    (if (> (point) sym-start)
X      (backward-word 1)
X					; else cannot advance
X      (ding)
X    ) ; if
X  ) ; let
X) ; defun sym-backward-word
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-complete-id (string)
X  "Expand the identifier STRING using the completion table."
X					; Local Variables
X  (let (start text-buffer)
X					; Body
X    (message "Expanding %s..." string)
X    (setq text-buffer (buffer-name))
X    (set-buffer sym-completion-buffer)
X					; Search for match
X    (goto-char (point-min))
X    (if (re-search-forward (concat "^" string) (point-max) t)
X      (progn
X	(beginning-of-line)
X	(setq start (point))
X	(end-of-line)
X	(setq string (buffer-substring start (point)))
X      ) ; progn
X    ) ; if
X    (set-buffer text-buffer)
X    (bury-buffer sym-completion-buffer)
X    (message "Expanding done.")
X					; Return expanded string
X    string
X  ) ; let
X) ; defun sym-complete-id
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-create-display ()
X  "Create the displayed string (if necessary) in symbol-mode."
X					; Local Variables
X  (let ()
X					; Body
X    (if (= sym-start (marker-position sym-end-marker))
X      (progn
X					; Remove the original string
X	(delete-char (length sym-original))
X					; Insert display
X	(insert-before-markers sym-start-display)
X	(insert-before-markers sym-end-display)
X	(search-backward sym-end-display)
X					; Reset the markers to empty
X	(set-marker sym-end-marker (point))
X	(setq sym-start (point))
X      ) ; progn
X    ) ; if
X  ) ; let
X) ; defun sym-create-display
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-delete-backward-char ()
X  "Delete the previous character created in symbol-mode."
X					; Local Variables
X  (interactive)
X  (let ()
X					; Body
X    (sym-reposition-point)
X    (if (> (point) sym-start)
X      (progn
X	(delete-backward-char 1)
X					; If empty input, restore original
X	(sym-reset-display)
X      ) ; progn
X					; else cannot delete
X      (ding)
X    ) ; if
X  ) ; let
X) ; defun sym-delete-backward-char
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-delete-char ()
X  "Delete the following character created in symbol-mode."
X					; Local Variables
X  (interactive)
X  (let ()
X					; Body
X    (sym-reposition-point)
X    (if (< (point) (marker-position sym-end-marker))
X      (progn
X	(delete-char 1)
X					; If empty input, restore original
X	(sym-reset-display)
X      ) ; progn
X					; else cannot delete
X      (ding)
X    ) ; if
X  ) ; let
X) ; defun sym-delete-char
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-enter-id (string)
X  "Enter STRING into the identifier completion table."
X  (interactive)
X					; Local Variables
X  (let (text-buffer prefix suffix found end-line)
X					; Body
X    (message "Adding %s..." string)
X    (setq text-buffer (buffer-name))
X    (set-buffer sym-completion-buffer)
X    (beginning-of-buffer)
X    (setq start (point))
X    (end-of-line nil)
X    (setq found (buffer-substring start (point)))
X    (setq more t)
X    (while (and more (string-lessp found string))
X      (if (not (eobp))
X	(progn
X	  (beginning-of-line 2)
X	  (setq start (point))
X	  (end-of-line nil)
X	  (setq found (buffer-substring start (point)))
X	) ; progn
X      ; else
X	(progn
X	  (setq more nil)
X	  (if (not (bobp))
X	    (newline)
X	  ) ; if
X	) ; progn
X      ) ; if
X    ) ; while
X    (if more
X      (if (not (string-equal found string))
X	(progn
X	  (beginning-of-line nil)
X	  (insert string "\n")
X	) ; progn
X      ) ; if not equal
X    ; else
X      (insert string)
X    ) ; if more
X    (set-buffer text-buffer)
X    (bury-buffer sym-completion-buffer)
X    (message "Adding Done." string)
X  ) ; let
X) ; defun sym-enter-id
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-expand-last-id ()
X  "Try to expand last identifier created in symbol-mode."
X  (interactive)
X					; Local Variables
X  (let (end-id string)
X					; Body
X    (sym-reposition-point)
X    (if (> (point) sym-start)
X      (progn
X	(setq end-id (point))
X	(re-search-backward "\\W")
X	(if (< (point) end-id)
X	  (forward-char 1)
X	) ; if
X	(if (< (point) sym-start)
X	  (goto-char sym-start)
X	) ; if
X	(setq string (buffer-substring (point) end-id))
X	(if (> (length string) 0)
X	  (progn
X	    (delete-char (length string))
X	    (setq string (sym-complete-id string))
X	    (insert-before-markers string)
X	  ) ; progn
X	) ; if
X      ) ; progn
X					; else cannot expand empty string
X      (ding)
X    ) ; if
X  ) ; let
X) ; defun sym-expand-last-id
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-forward-char ()
X  "Move point right one character, if possible."
X					; Local Variables
X  (interactive)
X  (let ()
X					; Body
X    (sym-reposition-point)
X    (if (< (point) (marker-position sym-end-marker))
X      (forward-char 1)
X					; else cannot advance
X      (ding)
X    ) ; if
X  ) ; let
X) ; defun sym-forward-char
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-forward-word ()
X  "Move point right one word, if possible."
X					; Local Variables
X  (interactive)
X  (let ()
X					; Body
X    (sym-reposition-point)
X    (if (< (point) (marker-position sym-end-marker))
X      (forward-word 1)
X					; else cannot advance
X      (ding)
X    ) ; if
X  ) ; let
X) ; defun sym-forward-word
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-illegal-command ()
X  "Catch all illegal symbol-mode commands."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (ding)
X    (message "That command is not allowed in symbol-mode.")
X  ) ; let
X) ; defun sym-illegal-command
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-kill-line ()
X  "Kill the current symbol line in symbol-mode"
X					; Local Variables
X  (interactive)
X  (let ()
X					; Body
X    (sym-reposition-point)
X    (if (< (point) (marker-position sym-end-marker))
X      (progn
X	(delete-region (point) (marker-position sym-end-marker))
X					; If empty input, restore original
X	(sym-reset-display)
X      ) ; progn
X					; else cannot delete
X      (ding)
X    ) ; if
X  ) ; let
X) ; defun sym-kill-line
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-kill-word ()
X  "Delete the following word in symbol-mode."
X					; Local Variables
X  (interactive)
X  (let ()
X					; Body
X    (sym-reposition-point)
X    (if (< (point) (marker-position sym-end-marker))
X      (progn
X	(kill-word 1)
X					; If empty input, restore original
X	(sym-reset-display)
X      ) ; progn
X					; else cannot delete
X      (ding)
X    ) ; if
X  ) ; let
X) ; defun sym-kill-word
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-position-end ()
X  "Position point at end of symbol line."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (goto-char (marker-position sym-end-marker))
X  ) ; let
X) ; defun sym-position-end
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-position-start ()
X  "Position point at start of symbol line."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (goto-char sym-start)
X  ) ; let
X) ; defun sym-position-start
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-read-string (prompt original)
X  "Read characters and insert them at point.  First arg PROMPT is a
X    message to prompt the user.  Second arg ORIGINAL is an initial
X    string to use if all input is deleted."
X					; Local Variables
X  (let (save-mode save-name save-keymap sym-input sym-valid-response)
X					; Body
X					; Initialize state
X    (setq sym-start (point))
X    (setq sym-end-marker (make-marker))
X    (set-marker sym-end-marker (point))
X    (setq sym-original original)
X					; Save mode variables
X    (setq save-mode major-mode)
X    (setq save-name mode-name)
X    (setq save-keymap (current-local-map))
X    (symbol-mode)
X    (message "%s" prompt)
X					; Wait for user's creation
X    (setq sym-input original)
X    (unwind-protect
X
X  (progn
X(setq sym-valid-response nil)
X(while (not sym-valid-response)
X  (recursive-edit)
X					; Pick up created string
X  (setq sym-input
X    (buffer-substring sym-start (marker-position sym-end-marker)))
X  (sym-reposition-point)
X					; If invalid try again
X  (if (and (boundp 'sym-check-validity-hook)
X    sym-check-validity-hook)
X  (progn
X    (setq sym-valid-response
X      (funcall sym-check-validity-hook sym-input))
X    ) ; progn
X  ; else
X    (setq sym-valid-response t)
X  ) ; if
X) ; while
X  ) ; progn
X					; Restore display string
X(if (< sym-start (marker-position sym-end-marker))
X  (progn
X    (goto-char sym-start)
X    (delete-backward-char (length sym-start-display))
X    (goto-char (marker-position sym-end-marker))
X    (delete-char (length sym-end-display))
X  ) ; progn
X) ; if
X					; Restore mode variables
X(setq major-mode save-mode)
X(setq mode-name save-name)
X(use-local-map save-keymap)
X) ; unwind-protect
X					; Return string entered
Xsym-input
X) ; let
X) ; defun sym-read-string
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-reposition-point ()
X  "Reposition point within the symbol line, if necessary."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (if (or (< (point) sym-start)
X      (> (point) (marker-position sym-end-marker)))
X    (goto-char (marker-position sym-end-marker))
X  ) ; if
X) ; let
X) ; defun sym-reposition-point
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-reset-display ()
X  "Reset the displayed string in symbol-mode."
X					; Local Variables
X  (let ()
X					; Body
X    (if (= sym-start (marker-position sym-end-marker))
X      (progn
X					; Remove the display markers
X	(delete-backward-char (length sym-start-display))
X	(delete-char (length sym-end-display))
X					; Insert original string
X	(insert-before-markers sym-original)
X	(search-backward sym-original)
X					; Reset the markers to empty
X	(set-marker sym-end-marker (point))
X	(setq sym-start (point))
X      ) ; progn
X    ) ; if
X  ) ; let
X) ; defun sym-reset-display
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-self-insert-command ()
X  "Insert this character in symbol-mode."
X  (interactive)
X					; Local Variables
X  (let (sym-char)
X					; Body
X    (setq sym-char (char-to-string last-input-char))
X    (sym-reposition-point)
X    (sym-create-display)
X    (insert-before-markers sym-char)
X    (if (and (= ?\) (char-syntax last-input-char))
X      blink-matching-paren)
X    (blink-matching-open)
X  ) ; if
X) ; let
X) ; defun sym-self-insert-command
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-set-local-keys ()
X  "Create key-map for Symbol Mode."
X					; Local Variables
X  (let (empty-keymap)
X					; Body
X    (setq empty-keymap (make-keymap))
X    (setq symbol-mode-map empty-keymap)
X    (suppress-keymap symbol-mode-map t)
X
X  (define-key symbol-mode-map "\177" 'sym-delete-backward-char) ; DEL
X
X					; Control keys
X  (define-key symbol-mode-map "\C-a" 'sym-position-start)
X  (define-key symbol-mode-map "\C-b" 'sym-backward-char)
X					; ^C is a prefix
X  (define-key symbol-mode-map "\C-d" 'sym-delete-char)
X  (define-key symbol-mode-map "\C-e" 'sym-position-end)
X  (define-key symbol-mode-map "\C-f" 'sym-forward-char)
X  (define-key symbol-mode-map "\C-g" 'sym-abort-recursive-edit)
X					; ^H is okay
X  (define-key symbol-mode-map "\C-i" 'sym-expand-last-id) ; TAB
X  (define-key symbol-mode-map "\C-j" 'exit-recursive-edit) ; LFD
X  (define-key symbol-mode-map "\C-k" 'sym-kill-line)
X					; ^L is okay
X  (define-key symbol-mode-map "\C-m" 'exit-recursive-edit) ; CR
X					; ^N is okay
X  (define-key symbol-mode-map "\C-o" 'sym-illegal-command)
X					; ^P is okay
X  (define-key symbol-mode-map "\C-q" 'sym-illegal-command)
X  (define-key symbol-mode-map "\C-r" 'sym-illegal-command)
X  (define-key symbol-mode-map "\C-s" 'sym-illegal-command)
X  (define-key symbol-mode-map "\C-t" 'sym-transpose-chars)
X
X
X  (define-key symbol-mode-map "\C-u" 'sym-illegal-command)
X					; ^V is okay
X  (define-key symbol-mode-map "\C-w" 'sym-illegal-command)
X					; ^X is a prefix
X  (define-key symbol-mode-map "\C-y" 'sym-illegal-command)
X					; ^Z is okay
X
X					; ^X prefix keys
X  (define-key symbol-mode-map "\C-x\t" 'sym-illegal-command)
X  (define-key symbol-mode-map "\C-x\C-l" 'sym-illegal-command)
X  (define-key symbol-mode-map "\C-x\C-o" 'sym-illegal-command)
X  (define-key symbol-mode-map "\C-x\C-t" 'sym-illegal-command)
X  (define-key symbol-mode-map "\C-x\C-u" 'sym-illegal-command)
X  (define-key symbol-mode-map "\C-xg" 'sym-illegal-command)
X  (define-key symbol-mode-map "\C-xi" 'sym-illegal-command)
X  (define-key symbol-mode-map "\C-xk" 'sym-illegal-command)
X  (define-key symbol-mode-map "\C-x\177" 'sym-illegal-command) ; ^X DEL
X
X					; ESC prefix keys
X  (define-key symbol-mode-map "\e\C-b" 'sym-backward-word)
X  (define-key symbol-mode-map "\e\C-c" 'exit-recursive-edit)
X  (define-key symbol-mode-map "\e\C-f" 'sym-forward-word)
X  (define-key symbol-mode-map "\e\C-k" 'sym-illegal-command)
X  (define-key symbol-mode-map "\e\C-o" 'sym-illegal-command)
X  (define-key symbol-mode-map "\e\C-s" 'sym-illegal-command)
X  (define-key symbol-mode-map "\e\C-t" 'sym-illegal-command)
X  (define-key symbol-mode-map "\e\C-w" 'sym-illegal-command)
X  (define-key symbol-mode-map "\e\C-\\" 'sym-illegal-command)
X  (define-key symbol-mode-map "\e " 'sym-illegal-command) ; ESC SPACE
X  (define-key symbol-mode-map "\e%" 'sym-illegal-command)
X  (define-key symbol-mode-map "\e(" 'sym-illegal-command)
X  (define-key symbol-mode-map "\e)" 'sym-illegal-command)
X  (define-key symbol-mode-map "\e;" 'sym-illegal-command)
X  (define-key symbol-mode-map "\e<" 'sym-position-start)
X  (define-key symbol-mode-map "\e>" 'sym-position-end)
X  (define-key symbol-mode-map "\e^" 'sym-illegal-command)
X  (define-key symbol-mode-map "\eb" 'sym-backward-word)
X  (define-key symbol-mode-map "\ed" 'sym-kill-word)
X  (define-key symbol-mode-map "\ef" 'sym-forward-word)
X  (define-key symbol-mode-map "\eg" 'sym-illegal-command)
X  (define-key symbol-mode-map "\ei" 'sym-illegal-command)
X  (define-key symbol-mode-map "\ej" 'sym-illegal-command)
X  (define-key symbol-mode-map "\ek" 'sym-illegal-command)
X  (define-key symbol-mode-map "\eq" 'sym-illegal-command)
X  (define-key symbol-mode-map "\et" 'sym-illegal-command)
X  (define-key symbol-mode-map "\ey" 'sym-illegal-command)
X  (define-key symbol-mode-map "\ez" 'sym-illegal-command)
X  (define-key symbol-mode-map "\e\177" 'sym-backward-kill-word) ; ESC DEL
X
X					; Self-inserting keys
X
X  (define-key symbol-mode-map " " 'sym-self-insert-command) ; SPACE
X  (define-key symbol-mode-map "!" 'sym-self-insert-command)
X  (define-key symbol-mode-map "\042" 'sym-self-insert-command) ; DOUBLE QUOTE
X  (define-key symbol-mode-map "#" 'sym-self-insert-command)
X  (define-key symbol-mode-map "$" 'sym-self-insert-command)
X  (define-key symbol-mode-map "%" 'sym-self-insert-command)
X  (define-key symbol-mode-map "&" 'sym-self-insert-command)
X  (define-key symbol-mode-map "\047" 'sym-self-insert-command) ; SINGLE QUOTE
X  (define-key symbol-mode-map "(" 'sym-self-insert-command)
X  (define-key symbol-mode-map ")" 'sym-self-insert-command)
X  (define-key symbol-mode-map "*" 'sym-self-insert-command)
X  (define-key symbol-mode-map "+" 'sym-self-insert-command)
X  (define-key symbol-mode-map "," 'sym-self-insert-command)
X  (define-key symbol-mode-map "-" 'sym-self-insert-command)
X  (define-key symbol-mode-map "." 'sym-self-insert-command)
X  (define-key symbol-mode-map "/" 'sym-self-insert-command)
X
X  (define-key symbol-mode-map "0" 'sym-self-insert-command)
X  (define-key symbol-mode-map "1" 'sym-self-insert-command)
X  (define-key symbol-mode-map "2" 'sym-self-insert-command)
X  (define-key symbol-mode-map "3" 'sym-self-insert-command)
X  (define-key symbol-mode-map "4" 'sym-self-insert-command)
X  (define-key symbol-mode-map "5" 'sym-self-insert-command)
X  (define-key symbol-mode-map "6" 'sym-self-insert-command)
X  (define-key symbol-mode-map "7" 'sym-self-insert-command)
X  (define-key symbol-mode-map "8" 'sym-self-insert-command)
X  (define-key symbol-mode-map "9" 'sym-self-insert-command)
X
X  (define-key symbol-mode-map ":" 'sym-self-insert-command)
X  (define-key symbol-mode-map ";" 'sym-self-insert-command)
X  (define-key symbol-mode-map "<" 'sym-self-insert-command)
X  (define-key symbol-mode-map "=" 'sym-self-insert-command)
X  (define-key symbol-mode-map ">" 'sym-self-insert-command)
X  (define-key symbol-mode-map "?" 'sym-self-insert-command)
X  (define-key symbol-mode-map "@" 'sym-self-insert-command)
X
X  (define-key symbol-mode-map "A" 'sym-self-insert-command)
X  (define-key symbol-mode-map "B" 'sym-self-insert-command)
X  (define-key symbol-mode-map "C" 'sym-self-insert-command)
X  (define-key symbol-mode-map "D" 'sym-self-insert-command)
X  (define-key symbol-mode-map "E" 'sym-self-insert-command)
X  (define-key symbol-mode-map "F" 'sym-self-insert-command)
X  (define-key symbol-mode-map "G" 'sym-self-insert-command)
X  (define-key symbol-mode-map "H" 'sym-self-insert-command)
X  (define-key symbol-mode-map "I" 'sym-self-insert-command)
X  (define-key symbol-mode-map "J" 'sym-self-insert-command)
X  (define-key symbol-mode-map "K" 'sym-self-insert-command)
X  (define-key symbol-mode-map "L" 'sym-self-insert-command)
X  (define-key symbol-mode-map "M" 'sym-self-insert-command)
X  (define-key symbol-mode-map "N" 'sym-self-insert-command)
X  (define-key symbol-mode-map "O" 'sym-self-insert-command)
X  (define-key symbol-mode-map "P" 'sym-self-insert-command)
X  (define-key symbol-mode-map "Q" 'sym-self-insert-command)
X  (define-key symbol-mode-map "R" 'sym-self-insert-command)
X  (define-key symbol-mode-map "S" 'sym-self-insert-command)
X  (define-key symbol-mode-map "T" 'sym-self-insert-command)
X  (define-key symbol-mode-map "U" 'sym-self-insert-command)
X  (define-key symbol-mode-map "V" 'sym-self-insert-command)
X  (define-key symbol-mode-map "W" 'sym-self-insert-command)
X  (define-key symbol-mode-map "X" 'sym-self-insert-command)
X  (define-key symbol-mode-map "Y" 'sym-self-insert-command)
X  (define-key symbol-mode-map "Z" 'sym-self-insert-command)
X
X  (define-key symbol-mode-map "[" 'sym-self-insert-command)
X  (define-key symbol-mode-map "\134" 'sym-self-insert-command) ; BACKSLASH
X  (define-key symbol-mode-map "]" 'sym-self-insert-command)
X  (define-key symbol-mode-map "^" 'sym-self-insert-command)
X  (define-key symbol-mode-map "_" 'sym-self-insert-command)
X  (define-key symbol-mode-map "`" 'sym-self-insert-command)
X
X  (define-key symbol-mode-map "a" 'sym-self-insert-command)
X  (define-key symbol-mode-map "b" 'sym-self-insert-command)
X  (define-key symbol-mode-map "c" 'sym-self-insert-command)
X  (define-key symbol-mode-map "d" 'sym-self-insert-command)
X  (define-key symbol-mode-map "e" 'sym-self-insert-command)
X  (define-key symbol-mode-map "f" 'sym-self-insert-command)
X  (define-key symbol-mode-map "g" 'sym-self-insert-command)
X  (define-key symbol-mode-map "h" 'sym-self-insert-command)
X  (define-key symbol-mode-map "i" 'sym-self-insert-command)
X  (define-key symbol-mode-map "j" 'sym-self-insert-command)
X  (define-key symbol-mode-map "k" 'sym-self-insert-command)
X  (define-key symbol-mode-map "l" 'sym-self-insert-command)
X  (define-key symbol-mode-map "m" 'sym-self-insert-command)
X  (define-key symbol-mode-map "n" 'sym-self-insert-command)
X  (define-key symbol-mode-map "o" 'sym-self-insert-command)
X  (define-key symbol-mode-map "p" 'sym-self-insert-command)
X  (define-key symbol-mode-map "q" 'sym-self-insert-command)
X  (define-key symbol-mode-map "r" 'sym-self-insert-command)
X  (define-key symbol-mode-map "s" 'sym-self-insert-command)
X  (define-key symbol-mode-map "t" 'sym-self-insert-command)
X  (define-key symbol-mode-map "u" 'sym-self-insert-command)
X  (define-key symbol-mode-map "v" 'sym-self-insert-command)
X  (define-key symbol-mode-map "w" 'sym-self-insert-command)
X  (define-key symbol-mode-map "x" 'sym-self-insert-command)
X  (define-key symbol-mode-map "y" 'sym-self-insert-command)
X  (define-key symbol-mode-map "z" 'sym-self-insert-command)
X
X  (define-key symbol-mode-map "{" 'sym-self-insert-command)
X  (define-key symbol-mode-map "|" 'sym-self-insert-command)
X  (define-key symbol-mode-map "}" 'sym-self-insert-command)
X  (define-key symbol-mode-map "~" 'sym-self-insert-command)
X
X  ) ; let
X) ; defun sym-set-local-keys
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun sym-transpose-chars ()
X  "Interchange characters arond point, moving forward one character.
X    If at end of symbol line, the previous two characters are exchanged."
X  (interactive)
X					; Local Variables
X  (let (save-position)
X					; Body
X    (sym-reposition-point)
X    (if (> (point) sym-start)
X      (if (< (point) (marker-position sym-end-marker))
X	(transpose-chars 1)
X      ; else
X	(if (> (point) (1+ sym-start))
X	  (progn
X					; transpose does not
X					;   insert-before-markers
X	    (setq save-position (marker-position sym-end-marker))
X	    (backward-char 1)
X	    (transpose-chars 1)
X	    (set-marker sym-end-marker save-position)
X	  ) ; progn
X	; else
X	  (ding)
X	) ; if
X      ) ; if
X    ; else
X      (ding)
X    ) ; if
X  ) ; let
X) ; defun sym-transpose-chars
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X;;; end of symbol.el
SHAR_EOF
if test 25432 -ne "`wc -c < 'symbol.el'`"
then
	echo shar: "error transmitting 'symbol.el'" '(should have been 25432 characters)'
fi
fi
echo shar: "extracting 'tplreplace.el'" '(3122 characters)'
if test -f 'tplreplace.el'
then
	echo shar: "will not over-write existing file 'tplreplace.el'"
else
sed 's/^X//' << \SHAR_EOF > 'tplreplace.el'
X;;; tplreplace.el -- Replace commands for Emacs.
X;;; Copyright (C) 1985 Richard M. Stallman.
X;;; Modified by Mark Ardis, Wang Institute, 12/14/86 for template-mode
X
X(provide 'tplreplace)
X
X(defun perform-replace-tpl (from-string to-string
X		        query-flag regexp-flag delimited-flag
X			search-function position-function replace-function
X			&optional reposition-function)
X  (let ((nocasify (not (and case-fold-search case-replace
X			    (string-equal from-string
X					  (downcase from-string)))))
X	(literal (not regexp-flag))
X	(search-string from-string)
X	(keep-going t)
X	(lastrepl nil)			;Position after last match considered.
X	(help-form
X	 '(concat "Query replacing "
X		  from-string " with " to-string ".\n\n"
X		  (substitute-command-keys query-replace-help))))
X    (push-mark)
X    (push-mark)
X    (while (and keep-going
X		(not (eobp))
X		(progn
X		 (set-mark (point))
X		 (funcall search-function search-string nil t)))
X      ;; Don't replace the null string 
X      ;; right after end of previous replacement.
X      (if (eq lastrepl (point))
X	  (forward-char 1)
X	(undo-boundary)
X	(if (not query-flag)
X	    (progn
X	      (setq tpl-query-flag nil)
X	      (funcall position-function)
X	      (funcall replace-function from-string to-string)
X	      )
X	  (let (done replaced)
X	    (setq tpl-query-flag t)
X	    (while (not done)
X	      (message "Query replacing %s with %s: " from-string to-string)
X	      ;; Preserve the match data.  Process filters and sentinels
X	      ;; could run inside read-char..
X	      (let ((data (match-data)))
X		(setq char (read-char))
X		(store-match-data data))
X	      (cond ((not (memq char '(?\e ?\ ?\, ?\. ?! ?\177 ?\C-r ?\C-w ?^)))
X		     (setq keep-going nil)
X		     (setq unread-command-char char)
X		     (setq done t))
X		    ((= char ?\e)
X		     (setq keep-going nil)
X		     (setq done t))
X		    ((= char ?^)
X		     (goto-char (mark))
X		     (setq replaced t))
X		    ((= char ?\ )
X		     (or replaced
X			 (progn
X			   (funcall position-function)
X			   (funcall replace-function from-string to-string)
X			   ))
X		     (setq done t))
X		    ((= char ?\.)
X		     (or replaced
X			 (progn
X			   (funcall position-function)
X			   (funcall replace-function from-string to-string)
X			   ))
X		     (setq keep-going nil)
X		     (setq done t))
X		    ((and (not replaced) (= char ?\,))
X		     (progn
X		       (funcall position-function)
X		       (funcall replace-function from-string to-string)
X		       )
X		     (setq replaced t))
X		    ((= char ?!)
X		     (or replaced
X			 (progn
X			   (funcall position-function)
X			   (funcall replace-function from-string to-string)
X			   ))
X		     (setq done t query-flag nil))
X		    ((= char ?\177)
X		     (setq done t))
X		    ((= char ?\C-r)
X		     (store-match-data
X		       (prog1 (match-data)
X			 (save-excursion (recursive-edit)))))
X		    ((= char ?\C-w)
X		     (delete-region (point) (mark))
X		     (save-excursion (recursive-edit))
X		     (setq replaced t)))
X	      )))
X	(setq lastrepl (point)))
X      (if reposition-function
X	  (funcall reposition-function)
X	) ; if
X      )
X    (pop-mark)
X    (message "Done")
X    (setq tpl-query-flag t)
X    keep-going))
SHAR_EOF
if test 3122 -ne "`wc -c < 'tplreplace.el'`"
then
	echo shar: "error transmitting 'tplreplace.el'" '(should have been 3122 characters)'
fi
fi
exit 0
#	End of shell archive


