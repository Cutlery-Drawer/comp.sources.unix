Subject:  v11i092:  Template-mode for GNU Emacs, Part02/06
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: "Mark A. Ardis" <maa@sei.cmu.edu>
Posting-number: Volume 11, Issue 92
Archive-name: templates/part02

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	template.el
#	tplvars.el
export PATH; PATH=/bin:/usr/bin:$PATH
echo shar: "extracting 'template.el'" '(26969 characters)'
if test -f 'template.el'
then
	echo shar: "will not over-write existing file 'template.el'"
else
sed 's/^X//' << \SHAR_EOF > 'template.el'
X;;; template.el -- generate and manipulate templates
X;;; Copyright (C) 1987 Mark A. Ardis.
X
X(require 'tplvars)
X(require 'menu)
X(require 'symbol)
X(require 'tplhelper)
X(require 'tplparse)
X(require 'tplreplace)
X(require 'tplscan)
X
X(provide 'template)
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X;;; All global variables are in "tplvars".
X;;; All non-interactive helper functions are in "tplhelper" or "tplscan".
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun template-mode ()
X  "Toggle template-mode, a minor mode for manipulation of text via templates.
X    Calls 'template-mode-hook' if it is defined."
X  (interactive)
X					; Local Variables
X  (let (file-name)
X					; Body
X    (setq template-mode (not template-mode))
X    (set-buffer-modified-p (buffer-modified-p))
X    (if template-mode
X	(progn
X	  (setq file-name (buffer-name))
X	  (setq sym-completion-buffer (concat "id-" file-name))
X	  (if tpl-save-identifier-file
X	      (find-file-noselect sym-completion-buffer)
X	    ; else
X	    (get-buffer-create sym-completion-buffer)
X	    ) ; if
X	  (bury-buffer sym-completion-buffer)
X	  (tpl-initialize-scan)
X	  (tpl-build-template-list)
X	  (tpl-make-keymap)
X	  (and (boundp 'template-mode-hook)
X	       template-mode-hook
X	       (funcall template-mode-hook))
X	  ) ; progn
X      ; else
X      (progn
X	(setq tpl-local-template-list nil)
X	(tpl-undo-keymap)
X	) ; progn
X      ) ; if
X    ) ; let
X  ) ; defun template-mode
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun compile-templates (template-file)
X  "Compile the templates in TEMPLATE-FILE into a Lisp structure."
X  (interactive	"Fcompile-templates: Template file? ")
X					; Local Variables
X  (let (file-list file-name file
X		  found root-name object-file)
X					; Body
X    (setq root-name (file-name-nondirectory template-file))
X    (if (and (> (length root-name) 4)
X	     (equal (substring root-name -4) ".tpl"))
X	(setq root-name (substring root-name 0 -4))
X      ) ; if
X    (setq object-file (concat (file-name-directory template-file)
X			      root-name "tpl.el"))
X    (setq file-list tpl-local-template-list)
X    (setq found nil)
X    (while (and file-list (not found))
X      (setq file (car file-list))
X      (setq file-list (cdr file-list))
X      (setq file-name (nth 0 file))
X      (if (equal file-name root-name)
X	  (setq found t)
X	) ; if (equal file-name root-name)
X      ) ; while file-list
X    (if found
X	(progn
X	  (save-window-excursion
X	    (set-buffer tpl-work-buffer)
X	    (erase-buffer)
X	    (message "Compiling templates into a lisp form...")
X	    (insert "(setq template-list '")
X	    (insert (prin1-to-string file))
X	    (insert ")")
X	    (newline)
X	    (write-region (point-min) (point-max) object-file)
X	    (byte-compile-file object-file)
X	    (delete-file object-file)
X	    ) ; save-window-excursion
X	  (bury-buffer tpl-work-buffer)
X	  ) ; progn
X      ; else
X      (progn
X	(error "Cannot find " template-file)
X	) ; progn
X      ) ; if found
X					; return
X    object-file
X    ) ; let
X  ) ; defun compile-templates
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun delete-placeholder ()
X  "Delete the placeholder at point."
X  (interactive)
X					; Local Variables
X  (let (start)
X					; Body
X    (if (looking-at tpl-pattern-placeholder)
X	(progn
X	  (setq start (point))
X	  (re-search-forward tpl-pattern-placeholder)
X	  (delete-region start (point))
X	  ) ; progn
X      ; else
X      (error "No placholder here!")
X      ) ; if (looking-at tpl-pattern-placeholder)
X    ) ; let
X  ) ; defun delete-placeholder
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun describe-template-mode ()
X  "Describe template-mode and its keybindings."
X  (interactive)
X					; Local Variables
X  (let (orig-buffer)
X					; Body
X    (setq orig-buffer (buffer-name))
X    (pop-to-buffer (get-buffer-create "*Help*"))
X    (erase-buffer)
X    (insert "Template-mode is a minor mode for manipulating regions of text\n")
X    (insert "called `templates'.  Templates have some of the attributes of\n")
X    (insert "productions in a context-free grammar.  They also have some of\n")
X    (insert "the attributes of rectangular pictures.  ")
X    (insert "For more information try:\n\n")
X    (insert "   C-h b  (describe-bindings)  Shows all of the new bindings.\n")
X    (insert "   C-h i  (info)  A user manual is available via `info'.\n")
X    (goto-char (point-min))
X    (pop-to-buffer orig-buffer)
X    ) ; let
X  ) ; defun describe-template-mode
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun expand-placeholder ()
X  "Expand the placeholder at point---interactive version."
X  (interactive)
X					; Local Variables
X  (let (start stop)
X					; Body
X    (if (looking-at tpl-pattern-placeholder)
X	(progn
X	  (setq start (point))
X	  (setq tpl-destination-needed t)
X	  (tpl-expand-placeholder nil)
X	  (setq stop (point))
X	  (if (not tpl-destination-needed)
X	      (progn
X		(goto-char (marker-position tpl-destination-marker))
X		(set-marker tpl-destination-marker nil)
X		) ; progn
X	    ; else
X	    (progn
X	      (setq tpl-destination-needed nil)
X	      (goto-char start)
X	      (if (re-search-forward tpl-pattern-placeholder stop stop)
X		  (re-search-backward tpl-pattern-placeholder)
X		) ; if
X	      ) ; progn
X	    ) ; if (not tpl-destination-needed)
X	  ) ; progn
X      ; else
X      (error "expand-placeholder: No placeholder at point!")
X      ) ; if
X    ) ; let
X  ) ; defun expand-placeholder
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun expand-placeholders-in-region (start stop)
X  "Expand each placeholder in the region between START and STOP."
X  (interactive "r")
X					; Local Variables
X  (let (stop-marker save)
X					; Body
X    (goto-char start)
X    (setq stop-marker (make-marker))
X    (set-marker stop-marker stop)
X					; (The check for out-of-bounds is
X					;   needed for a placeholder at
X					;   the end of the region.)
X    (while (and (< (point) (marker-position stop-marker))
X		(re-search-forward
X		 tpl-pattern-placeholder (marker-position stop-marker) t))
X      (re-search-backward tpl-pattern-placeholder)
X      (if (looking-at tpl-begin-optional)
X	  (if (or (equal t tpl-keep-optional-placeholders)
X		  (and tpl-keep-optional-placeholders
X		       (tpl-y-or-n-p "Keep optional placeholder? ")))
X	      (progn
X		(delete-char (length tpl-begin-optional))
X		(insert-before-markers tpl-begin-placeholder)
X		(re-search-backward tpl-begin-placeholder)
X		(if (or (< tpl-expansion-depth tpl-ask-expansion-depth)
X			(tpl-y-or-n-p "Expand? "))
X		    (progn
X		      (setq tpl-expansion-depth (1+ tpl-expansion-depth))
X		      (unwind-protect
X			  (tpl-expand-placeholder (marker-position stop-marker))
X			(setq tpl-expansion-depth (1- tpl-expansion-depth))
X			) ; unwind-protect
X		      ) ; progn
X		  ; else
X		  (progn
X		    (re-search-forward tpl-pattern-placeholder)
X		    ) ; progn
X		  ) ; if (tpl-y-or-n-p "Expand? ")
X		) ; progn
X	    ; else
X	    (progn
X	      (setq save (point))
X	      (re-search-forward tpl-pattern-placeholder)
X	      (delete-region save (point))
X	      (if (tpl-blank-line)
X		  (delete-indentation)
X		) ; if
X	      ) ; progn
X	    ) ; if (tpl-y-or-n-p "Keep optional placeholder? ")
X	; else
X	(if (or (< tpl-expansion-depth tpl-ask-expansion-depth)
X		(tpl-y-or-n-p "Expand? "))
X	    (progn
X	      (setq tpl-expansion-depth (1+ tpl-expansion-depth))
X	      (unwind-protect
X		  (tpl-expand-placeholder (marker-position stop-marker))
X		(setq tpl-expansion-depth (1- tpl-expansion-depth))
X		) ; unwind-protect
X	      ) ; progn
X	  ; else
X	  (progn
X	    (re-search-forward tpl-pattern-placeholder)
X	    ) ; progn
X	  ) ; if (tpl-y-or-n-p "Expand? ")
X	) ; if (looking-at tpl-begin-optional)
X      ) ; while (re-search-forward...)
X    (if (< (point) (marker-position stop-marker))
X	(goto-char (marker-position stop-marker))
X      ) ; if
X    (set-marker stop-marker nil)
X    ) ; let
X  ) ; defun expand-placeholders-in-region
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun generate-any-template ()
X  "Generate any template, by using the special all-templates-template."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (if (or tpl-all-templates-template-invalid
X	    (not (tpl-find-template tpl-all-templates-name)))
X	(if (y-or-n-p "Cannot find all-templates-template.  Rebuild? ")
X	    (progn
X	      (tpl-make-all-templates-template)
X	      (tpl-generate tpl-all-templates-name)
X	      ) ; progn
X	  ; else
X	  (error "Aborted.")
X	  ) ; if (y-or-n-p ...)
X      ; else
X      (tpl-generate tpl-all-templates-name)
X      ) ; if
X    ) ; let
X  ) ; defun generate-any-template
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun generate-template ()
X  "Complete template name and call tpl-generate."
X  (interactive)
X					; Local Variables
X  (let (name name-list)
X					; Body
X					; Build completion list
X    (setq name-list (tpl-make-completion-list))
X    ; Query for name and generate
X    (setq name
X	  (completing-read "generate-template: Name of template? "
X			   name-list nil t nil))
X    (tpl-generate name)
X    ) ; let
X  ) ; defun generate-template
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun load-tpl-buffer (&optional buffer)
X  "Load all of the templates (in the optional BUFFER).
X    Defaults to 'tpl-new-template-buffer."
X  (interactive)
X					; Local Variables
X  (let (root-name new-list)
X					; Body
X    (if (not buffer)
X	(setq buffer
X	      (read-buffer "load-tpl-buffer: Template buffer? "
X			   tpl-new-template-buffer t))
X      ) ; if (not buffer)
X    (setq new-list (tpl-make-template-list buffer t))
X    (setq tpl-local-template-list (append (list new-list) tpl-local-template-list))
X    (if tpl-rebuild-all-templates-template
X	(tpl-make-all-templates-template)
X      ; else
X      (setq tpl-all-templates-template-invalid t)
X      ) ; if
X    (if (interactive-p)
X	(if (y-or-n-p "Rebuild global template list with these new templates? ")
X	    (progn
X	      (setq mode-nm (read-string "Mode name for global template list? "))
X	      (tpl-rebuild-global-template-list mode-nm new-list)
X	      ) ; progn
X	  ) ; if (y-or-n-p ...)
X      ) ; if (interactive-p)
X    ) ; let
X  ) ; defun load-tpl-buffer
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun load-tpl-file (&optional file)
X  "Load all of the templates (in the optional FILE).
X    Uses file name completion in the current directory, and
X    defaults to 'tpl-new-template-buffer."
X  (interactive)
X					; Local Variables
X  (let (root-name new-list)
X					; Body
X    (if (not file)
X	(setq file
X	      (expand-file-name (read-file-name
X				 (concat "load-tpl-file: Template file? ("
X					 tpl-new-template-buffer ") ")
X				 nil tpl-new-template-buffer)))
X      ) ; if (not file)
X    (setq root-name (tpl-root-of-file-name (file-name-nondirectory file)))
X    (setq new-list (tpl-make-template-list file))
X    (setq tpl-local-template-list (append (list new-list) tpl-local-template-list))
X    (if tpl-rebuild-all-templates-template
X	(tpl-make-all-templates-template)
X      ; else
X      (setq tpl-all-templates-template-invalid t)
X      ) ; if
X    (if (interactive-p)
X	(if (y-or-n-p "Rebuild global template list with these new templates? ")
X	    (progn
X	      (setq mode-nm (read-string "Mode name for global template list? "))
X	      (tpl-rebuild-global-template-list mode-nm new-list)
X	      ) ; progn
X	  ) ; if (y-or-n-p ...)
X      ) ; if (interactive-p)
X    ) ; let
X  ) ; defun load-tpl-file
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun load-tpl-library (file &optional mode-nm)
X  "Find FILE and add all of the templates in it to the template list.
X    (Uses the 'tpl-load-path value to find the file.)  Optional second
X    argument MODE-NM is used to rebuild the global template list."
X  (interactive "sload-tpl-library: File name? ")
X					; Local Variables
X  (let (found head-template-list tail-template-list template-file file-name
X	      root-name template-list new-list)
X					; Body
X    (setq root-name (tpl-root-of-file-name (file-name-nondirectory file)))
X					; Look for file in existing list
X    (setq found nil)
X    (setq head-template-list nil)
X    (setq tail-template-list tpl-local-template-list)
X    (while (and tail-template-list (not found))
X      (setq template-file (car tail-template-list))
X      (setq tail-template-list (cdr tail-template-list))
X      (setq file-name (nth 0 template-file))
X      (if (equal file-name root-name)
X	  (setq found t)
X	; else
X	(setq head-template-list
X	      (append head-template-list (list template-file)))
X	) ; if (equal file-name file)
X      ) ; while (and tail-template-list (not found))
X					; If found, query about replacing
X    (if (and found
X	     (not (y-or-n-p "File already loaded.  Replace? ")))
X	(error "File already loaded.  Aborted.")
X      ) ; if
X    (setq tpl-local-template-list (append head-template-list tail-template-list))
X					; Find template file
X    (setq file (tpl-find-template-file root-name))
X    (if (and (> (length file) 4)
X	     (equal (substring file -4) ".elc"))
X	(progn
X	  (load file)
X	  (setq new-list template-list)
X	  ) ; progn
X      ; else
X      (progn
X	(setq new-list (tpl-make-template-list file))
X	) ; progn
X      ) ; if compiled
X    (setq tpl-local-template-list
X	  (append (list new-list)
X		  tpl-local-template-list))
X    (if tpl-rebuild-all-templates-template
X	(tpl-make-all-templates-template)
X      ; else
X      (setq tpl-all-templates-template-invalid t)
X      ) ; if
X    (if (interactive-p)
X	(if (y-or-n-p "Rebuild global template list with these new templates? ")
X	    (progn
X	      (setq mode-nm
X		    (read-minibuffer "Mode name for global template list? "))
X	      (tpl-rebuild-global-template-list mode-nm new-list)
X	      ) ; progn
X	  ) ; if
X      ; else
X      (tpl-rebuild-global-template-list mode-nm new-list)
X      ) ; if
X    ) ; let
X  ) ; defun load-tpl-library
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun next-placeholder ()
X  "Search forward for the next placeholder."
X  (interactive)
X					; Local Variables
X  (let (count)
X					; Body
X    (if (looking-at tpl-pattern-placeholder)
X	(setq count 2)
X      ; else
X      (setq count 1)
X      ) ; if (looking-at tpl-pattern-placeholder)
X    (re-search-forward tpl-pattern-placeholder (point-max) nil count)
X    (re-search-backward tpl-pattern-placeholder)
X    ) ; let
X  ) ; defun next-placeholder
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun previous-placeholder ()
X  "Search backward for the previous placeholder."
X  (interactive)
X					; Local Variables
X  (let ()
X					; Body
X    (re-search-backward tpl-pattern-placeholder)
X    ) ; let
X  ) ; defun previous-placeholder
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun query-replace-groups (start stop)
X  "Replace some lines after point, beginning with a line that
X    matches START, and ending before a line that matches STOP, with
X    temporary placeholders.  As each match is found, the user
X    must type a character saying what to do with it.  For directions,
X    type \\[help-command] at that time."
X  (interactive "squery-replace-groups starting with: \nsquery-replace-groups starting with %s ending with: ")
X					; Local Variables
X  (let ()
X					; Body
X    (setq tpl-end-group (concat "^" stop))
X    (perform-replace-tpl
X     (concat "^" start)
X     "placeholder" t nil nil
X     're-search-forward 'tpl-find-end-of-group 'tpl-replace-group
X     'tpl-find-next-group)
X    ) ; let
X  ) ; defun query-replace-groups
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun query-replace-lines (string)
X  "Replace some lines after point matching leading STRING with
X    temporary placeholders.  As each match is found, the user
X    must type a character saying what to do with it.  For directions,
X    type \\[help-command] at that time."
X  (interactive "squery-replace-lines with leading pattern: ")
X					; Local Variables
X  (let ()
X					; Body
X    (perform-replace-tpl
X     (concat "^" string)
X     "placeholder" t nil nil
X     're-search-forward 'beginning-of-line 'tpl-replace-line)
X    ) ; let
X  ) ; defun query-replace-lines
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun region-to-tpl (start stop &optional name file parse)
X  "Create a template with the text between START and STOP.
X    Optionally, call it NAME and put the template in FILE.
X    Optional fifth argument PARSE specifies whether the template
X    should be parsed: if t parse, if nil do not parse, if neither
X    t nor nil ask about parsing."
X  (interactive "r")
X					; Local Variables
X  (let (string column text-file template table parse name-place
X	       suggestion begin-body)
X					; Body
X    (if (not file)
X	(setq file
X	      (expand-file-name (read-file-name
X				 (concat "Template file? ("
X					 tpl-new-template-buffer ") ")
X				 nil tpl-new-template-buffer)))
X      ) ; if (not file)
X    (if (and parse (not (equal parse t)))
X	(setq parse (y-or-n-p "region-to-tpl: Parse the template? "))
X      ) ; if
X    (setq string (buffer-substring start stop))
X    (goto-char start)
X    (setq column (current-column))
X    (goto-char stop)
X    (setq text-file (buffer-file-name))
X    (if (not (equal file text-file))
X	(progn
X	  (find-file-other-window file)
X	  (goto-char (point-min))
X	  (open-line 1)
X	  (insert tpl-begin-template-definition " ")
X	  (setq name-place (point))
X	  (insert " ")
X	  (if parse
X	      (insert tpl-sequence-type)
X	    (insert tpl-string-type)
X	    ) ; if parse
X	  (beginning-of-line nil)
X	  (delete-char 1)		; Remove regexp anchor
X	  (setq name-place (1- name-place))
X	  (end-of-line nil)
X	  (newline)
X	  (insert tpl-begin-template-body)
X	  (newline)
X	  (beginning-of-line 0)
X	  (delete-char 1)		; Remove regexp anchor
X	  (beginning-of-line 2)
X					; Insert body of template
X	  (setq begin-body (point))
X	  (insert string)
X	  (newline)
X					; Fix indentation
X	  (indent-rigidly begin-body (point) (- 0 column))
X	  (insert tpl-end-template-body)
X	  (newline)
X	  (beginning-of-line 0)
X	  (delete-char 1)		; Remove regexp anchor
X	  (goto-char name-place)
X	  (if (not name)
X	      (if tpl-get-placeholder-name-in-context
X		  (progn
X		    (if tpl-form-placeholder-name-from-context
X			(setq suggestion tpl-formed-placeholder-name)
X		      ; else
X		      (progn
X			(setq suggestion tpl-next-placeholder-name)
X			(tpl-increment-next-placeholder-name)
X			) ; progn
X		      ) ; if tpl-form-placeholder-name-from-context
X		    (insert suggestion)
X		    (if tpl-query-flag
X			(progn
X			  (search-backward suggestion)
X			  (setq name
X				(sym-read-string "Placeholder name? "
X						 suggestion))
X			  (if (equal (length name) 0)
X			      (progn
X				(setq name suggestion)
X				) ; progn
X			    ) ; if
X			  ) ; progn
X		      ; else
X		      (setq name suggestion)
X		      ) ; if tpl-query-flag
X		    ) ; progn
X		; else
X		(progn
X		  (setq name (tpl-get-placeholder-name))
X		  (insert name)
X		  ) ; progn
X		) ; if tpl-get-placeholder-name-in-context
X	    ; else
X	    (insert name)
X	    ) ; if (not-name)
X	  ) ; progn
X      ; else
X      (error "Cannot reuse this file for templates!")
X      ) ; if (not (equal file text-file))
X					; return
X    name
X    ) ; let
X  ) ; defun region-to-tpl
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun replace-line-with-placeholder (count &optional name file parse)
X  "Replace the line containing point with a placeholder.
X    Prefix argument COUNT gives number of lines
X    (ending with current line).  Optional second argument NAME is used
X    for placeholder name.  Optional third argument FILE is used for
X    file to store template.  Optional fourth argument PARSE
X    specifies whether template should be parsed.  (See 'region-to-tpl
X    for interpretation.)"
X  (interactive "p")
X					; Local Variables
X  (let (start)
X					; Body
X    (if (interactive-p)
X	(progn
X	  (setq parse "ask")
X	  (setq file "new.tpl")
X	  ) ; progn
X      ) ; if
X    (setq count (1- count))
X    (forward-line (* count -1))
X    (setq start (point))
X    (forward-line count)
X    (end-of-line nil)
X    (replace-region-with-placeholder start (point) name file parse)
X    ) ; let
X  ) ; defun replace-line-with-placeholder
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun replace-region-with-placeholder (start stop &optional name file parse)
X  "Replace the region between START and STOP with a placeholder.
X    Optionally, call it NAME and put the template in FILE.
X    Optional fifth argument PARSE specifies whether template
X    should be parsed.  (See 'region-to-tpl for interpretation.)"
X  (interactive "r")
X					; Local Variables
X  (let (start-marker stop-marker)
X					; Body
X    (if (interactive-p)
X	(progn
X	  (setq parse "ask")
X	  (setq file "new.tpl")
X	  ) ; progn
X      ) ; if
X    (if (> (- stop start) 0)
X	(progn
X	  (save-window-excursion
X	    (setq start-marker (make-marker))
X	    (set-marker start-marker start)
X	    (setq stop-marker (make-marker))
X	    (set-marker stop-marker stop)
X	    (setq name (region-to-tpl start stop name file parse))
X	    (if tpl-auto-save-new-templates
X		(save-buffer)
X	      ) ; if tpl-auto-save-new-templates
X	    ) ; save-window-excursion
X	  (delete-region (marker-position start-marker)
X			 (marker-position stop-marker))
X	  (unwind-protect
X	      (if tpl-auto-load-new-templates
X		  (load-tpl-buffer (buffer-name (get-file-buffer file)))
X		) ; if
X	    (goto-char (marker-position start-marker))
X	    (set-marker start-marker nil)
X	    (set-marker stop-marker nil)
X	    (insert-before-markers
X	     tpl-begin-placeholder name tpl-end-placeholder))
X	  ) ; progn
X      ; else
X      (insert-before-markers
X       tpl-begin-placeholder name tpl-end-placeholder)
X      ) ; if (> (- stop start) 0)
X    ) ; let
X  ) ; defun replace-region-with-placeholder
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun rewrap-template-around-point ()
X  "Unwrap FIRST template around point and wrap with SECOND.
X    Template names are prompted for with completing-read.
X    A side effect of this function is to push-mark at the beginning of the
X    enclosed region."
X  (interactive)
X					; Local Variables
X  (let (name-list first second)
X					; Body
X					; Build completion list
X    (setq name-list (tpl-make-completion-list))
X					; Query for name to unwrap
X    (setq first
X	  (completing-read "rewrap-template: Name of enclosing template? "
X			   name-list nil t nil))
X					; Query for name to wrap
X    (setq second
X	  (completing-read "rewrap-template: Name of new template? "
X			   name-list nil t nil))
X    (tpl-unwrap-template first t)
X    (tpl-wrap-template (mark) (point) second)
X    ) ; let
X  ) ; defun rewrap-template-around-point
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun tpl-recompile-templates (template-dir)
X  "Compile a standard list of templates in TEMPLATE-DIR."
X  (interactive "Dtpl-recompile-templates: Template directory? ")
X					; Local Variables
X  (let (prefix)
X					; Body
X    (autoload 'awk-mode "awk")
X    (autoload 'bib-mode "bib")
X    (autoload 'pascal-mode "pascal")
X    (setq prefix template-dir)
X    (if (not (equal (substring prefix -1) "/"))
X	(setq prefix (concat prefix "/"))
X      ) ; if
X    (if (not template-mode)
X	(template-mode)
X      ) ; if
X    (compile-templates (concat prefix "generic.tpl"))
X    (awk-mode)
X    (template-mode)
X    (compile-templates (concat prefix "awk.tpl"))
X    (bib-mode)
X    (template-mode)
X    (compile-templates (concat prefix "bib.tpl"))
X    (c-mode)
X    (template-mode)
X    (compile-templates (concat prefix "c.tpl"))
X    (emacs-lisp-mode)
X    (template-mode)
X    (compile-templates (concat prefix "elisp.tpl"))
X    (latex-mode)
X    (template-mode)
X    (compile-templates (concat prefix "latex.tpl"))
X    (pascal-mode)
X    (template-mode)
X    (compile-templates (concat prefix "pascal.tpl"))
X    (scribe-mode)
X    (template-mode)
X    (compile-templates (concat prefix "scribe.tpl"))
X    (texinfo-mode)
X    (template-mode)
X    (compile-templates (concat prefix "texinfo.tpl"))
X  ) ; let
X) ; defun tpl-recompile-templates
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun unwrap-template-around-point (arg)
X  "Complete template name and call tpl-unwrap-template.  Prefix argument
X    ARG non-nil causes the mark to be set at the beginning of the resulting
X    region."
X  (interactive "P")
X					; Local Variables
X  (let (name name-list)
X					; Body
X					; Build completion list
X    (setq name-list (tpl-make-completion-list))
X					; Query for name and unwrap
X    (setq name
X	  (completing-read "unwrap-template-around-point: Name of template? "
X			   name-list nil t nil))
X    (tpl-unwrap-template name arg)
X    ) ; let
X  ) ; defun unwrap-template-around-point
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun wrap-template-around-line (count)
X  "Replace COUNT lines including point with TEMPLATE,
X    reinserting the replaced line at the destination placeholder.
X    Prefix argument indicates number of lines to wrap.
X    Second argument, TEMPLATE, is read with completing-read."
X  (interactive "p")
X					; Local Variables
X  (let (start)
X					; Body
X    (setq count (1- count))
X    (forward-line (* count -1))
X    (beginning-of-line nil)
X    (setq start (point))
X    (forward-line count)
X    (end-of-line nil)
X    (wrap-template-around-region start (point))
X    ) ; let
X  ) ; defun wrap-template-around-line
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun wrap-template-around-region (start stop)
X  "Replace the region between START and STOP with TEMPLATE,
X    reinserting the replaced region at the destination placeholder.
X    The region is indented rigidly at its insertion column.
X    The third argument, TEMPLATE, is read with completing-read."
X  (interactive "r")
X					; Local Variables
X  (let (name-list template)
X					; Body
X    (setq name-list (tpl-make-completion-list))
X    (setq template (completing-read "wrap-template: Name of template? "
X				    name-list nil t nil))
X    (tpl-wrap-template start stop template)
X    ) ; let
X  ) ; defun wrap-template-around-region
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(defun wrap-template-around-word (count)
X  "Replace COUNT words before point with TEMPLATE,
X    reinserting the replaced word at the destination placeholder.
X    Prefix argument indicates number of words to wrap.
X    Second argument, TEMPLATE, is read with completing-read."
X  (interactive "p")
X					; Local Variables
X  (let (start)
X					; Body
X    (forward-word (* count -1))
X    (setq start (point))
X    (forward-word count)
X    (wrap-template-around-region start (point))
X    ) ; let
X  ) ; defun wrap-template-around-word
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X(tpl-initialize-modes)
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X;;; end of template.el
SHAR_EOF
if test 26969 -ne "`wc -c < 'template.el'`"
then
	echo shar: "error transmitting 'template.el'" '(should have been 26969 characters)'
fi
fi
echo shar: "extracting 'tplvars.el'" '(11467 characters)'
if test -f 'tplvars.el'
then
	echo shar: "will not over-write existing file 'tplvars.el'"
else
sed 's/^X//' << \SHAR_EOF > 'tplvars.el'
X;;; tplvars.el -- Variables for template-mode.
X;;; Copyright (C) 1987 Mark A. Ardis.
X
X(provide 'tplvars)
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X;;; User Options
X
X(defvar tpl-ask-expansion-depth 1
X  "*Depth of recursive placeholder expansions at which to start asking
X    whether to expand.  Possible values are:
X      -1  delete all placeholders
X	0  don't expand or delete placeholders---leave them alone
X	1  ask about expansion at level 1
X	n  ask about expansion at level n of expanding
X      Defaults to 1, which means always ask."
X) ; tpl-ask-expansion-depth
X
X(defvar tpl-auto-load-new-templates nil
X  "*If non-nil load new templates after creating them with
X    'replace-wtih-placeholder.  Otherwise, loading must be done
X    by invoking 'load-tpl-file.  Defaults to nil."
X) ; tpl-auto-load-new-templates
X
X(defvar tpl-auto-save-new-templates nil
X  "*If non-nil save new templates after creating them with
X    'replace-wtih-placeholder.  Otherwise, saving must be done
X    by invoking 'save-buffer.  Defaults to nil."
X) ; tpl-auto-save-new-templates
X
X(defvar tpl-auto-template-alist nil
X  "*Global Alist of major modes and their associated template files.
X    Initialized by 'tpl-initialize-modes'."
X) ; tpl-auto-template-alist
X
X(defvar tpl-begin-placeholder "<"
X  "*Regular expression for beginning of placeholder."
X) ; tpl-begin-placeholder
X
X(defvar tpl-begin-template-body "^:begin"
X  "*Regular expression for beginning of template body."
X) ; tpl-begin-template-body
X(make-variable-buffer-local 'tpl-begin-template-body)
X(setq-default tpl-begin-template-body "^:begin")
X
X(defvar tpl-begin-template-definition "^Template"
X  "*Regular expression for beginning of template definition."
X) ; tpl-begin-template-definition
X(make-variable-buffer-local 'tpl-begin-template-definition)
X(setq-default tpl-begin-template-definition "^Template")
X
X(defvar tpl-destination-symbol "POINT"
X  "*Special symbol used as placeholder as location for point
X    after expanding a template."
X) ; tpl-destination-symbol
X
X(defvar tpl-display-begin ">>"
X  "*Delimiter marking beginning of a selected placeholder."
X) ; tpl-display-begin
X
X(defvar tpl-display-end "<<"
X  "*Delimiter marking end of a selected placeholder."
X) ; tpl-display-end
X
X(defvar tpl-end-placeholder ">"
X  "*Regular expression for end of placeholder."
X) ; tpl-end-placeholder
X
X(defvar tpl-end-template-body "^:end"
X  "*Regular expression for end of template body."
X) ; tpl-end-template-body
X(make-variable-buffer-local 'tpl-end-template-body)
X(setq-default tpl-end-template-body "^:end")
X
X(defvar tpl-fill-while-unscanning nil
X  "*If non-nil, use whatever fill mode is in effect while unscanning
X    (inserting) templates.  Defaults to nil, which ensures that template
X    formats are not disturbed by context."
X) ; tpl-fill-while-unscanning
X
X(defvar tpl-form-placeholder-name-from-context nil
X  "*Option to generate placeholder names by looking for the first symbol
X    after point.  Defaults to nil, which means use temporary names instead."
X) ; tpl-form-placeholder-name-from-context
X
X(defvar tpl-function-type "Function"
X  "*Name of function-type template type."
X) ; tpl-function-type
X
X(defvar tpl-get-placeholder-name-in-context t
X  "*If non-nil allow the user to type in the placeholder name within
X    the context of the template definition.  Otherwise, use temporary
X    names.  Defaults to t."
X) ; tpl-get-placeholder-name-in-context
X
X(defvar tpl-include-prefix-in-groups t
X  "*Option to include the prefix string (used to find the beginning of
X    a group) in the group."
X) ; tpl-include-prefix-in-groups
X
X(defvar tpl-indentation-size 2
X  "*Size of indentation units in columns."
X) ; tpl-indentation-size
X(make-variable-buffer-local 'tpl-indentation-size)
X(setq-default tpl-indentation-size 2)
X
X(defvar tpl-keep-optional-placeholders "ask"
X  "*Option to determine processing of optional placeholders in template-mode.
X    If t, then always keep them.  If nil, then always delete them.  If neither
X    t nor nil, then always ask."
X) ; tpl-keep-optional-placeholders
X
X(defvar tpl-lexical-type "Lexical"
X  "*Name of lexical-type template type."
X) ; tpl-lexical-type
X
X(defvar tpl-literal-whitespace nil
X  "*If non-nil leave leading whitespace in templates as-is.
X    Otherwise, calculate relative indentation units (see
X    'tpl-indentation-size' variable).  Defaults to nil."
X) ; tpl-literal-whitespace
X
X(defvar tpl-load-path (list nil "/faculty/ardis/Gnu/Template/Templates")
X  "*List of directories to search for template files to load.
X    Each element is a string (directory name) or nil (try default directory).
X    Use 'template-mode-load-hook to change this value."
X) ; tpl-load-path
X
X(defvar tpl-new-template-buffer "new.tpl"
X  "*Buffer containing new templates."
X) ; tpl-new-template-buffer
X
X(defvar tpl-next-placeholder-number 1
X  "*Counter used to generate unique temporary placeholder names."
X) ; tpl-next-placeholder-number
X
X(defvar tpl-pattern-optional "#"
X  "*Regular expression for all optional placeholders."
X) ; tpl-pattern-optional
X
X(defvar tpl-pattern-other "."
X  "*Regular expression for all other tokens."
X) ; tpl-pattern-other
X
X(defvar tpl-pattern-placeholder nil
X  "*Regular expression for placeholder."
X) ; tpl-pattern-placeholder
X
X(defvar tpl-pattern-punctuation "\\s.+"
X  "*Regular expression for at least one punctuation character."
X) ; tpl-pattern-punctuation
X
X(defvar tpl-pattern-string ".*"
X  "*Regular expression for any string."
X) ; tpl-pattern-string
X
X(defvar tpl-pattern-symbol "\\(\\sw\\|\\s_\\)+"
X  "*Regular expression for at least one symbol character."
X) ; tpl-pattern-symbol
X
X(defvar tpl-pattern-whitespace "[ 	]+"
X  "*Regular expression for at least one whitespace character."
X) ; tpl-pattern-whitespace
X
X(defvar tpl-pattern-word "\\sw+"
X  "*Regular expression for at least one word character."
X) ; tpl-pattern-word
X
X(defvar tpl-rebuild-all-templates-template nil
X  "*If non-nil rebuild the list of all templates after invoking
X    template-mode and after loading new templates.  Otherwise, do not
X    (improves performance of starting up).  Defaults to nil."
X) ; tpl-rebuild-all-templates-template
X
X(defvar tpl-repetition-type "Repetition"
X  "*Name of repetition-type template type."
X) ; tpl-repetition-type
X
X(defvar tpl-save-identifier-file nil
X  "*Option to save identifier table in a separate file.  Defaults
X    to nil, which means save only in a buffer."
X) ; tpl-save-identifier-file
X
X(defvar tpl-selection-type "Selection"
X  "*Name of selection-type template type."
X) ; tpl-selection-type
X
X(defvar tpl-sep-placeholder ":"
X  "*Regular expression for placeholder body separator."
X) ; tpl-sep-placeholder
X
X(defvar tpl-sequence-type "Sequence"
X  "*Name of sequence-type template type."
X) ; tpl-sequence-type
X
X(defvar tpl-string-type "String"
X  "*Name of string-type template type."
X) ; tpl-string-type
X
X(defvar tpl-temporary-placeholder-name "TEMP"
X  "*Root of temporary placeholder names."
X) ; tpl-temporary-placeholder-name
X
X(defvar tpl-verify-end-of-group nil
X  "*Option to verify (by positioning point) the end of each group
X    of lines in 'query-replace-groups."
X) ; tpl-verify-end-of-group
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X;;; Global Variables
X
X(defvar lex-patterns nil
X  "A list of regular expressions to be used in recognizing tokens."
X) ; lex-patterns
X
X(defvar string-patterns nil
X  "A list of string patterns to be used in recognizing tokens."
X) ; string-patterns
X
X(defvar template-mode nil
X  "Minor mode symbol."
X) ; template-mode
X(make-variable-buffer-local 'template-mode)
X
X(defvar template-mode-map nil
X  "Keymap for template-mode."
X) ; template-mode-map
X
X(defvar tpl-all-templates-file "ALLTEMPLATES"
X  "Name of dummy template file for all-templates-template."
X) ; tpl-all-templates-name
X
X(defvar tpl-all-templates-name "ALLTEMPLATES"
X  "Name of special template that is a selection of all other templates."
X) ; tpl-all-templates-name
X
X(defvar tpl-all-templates-template-invalid t
X  "Flag to indicate validity of all-templates-template."
X) ; tpl-all-templates-template-invalid
X
X(defvar tpl-begin-optional nil
X  "Regular expression for beginning of optional placeholder."
X) ; tpl-begin-optional
X
X(defvar tpl-buffer
X  "Current template buffer."
X) ; tpl-buffer
X
X(defvar tpl-comment-level 100
X  "Special value indicating alignment on comment column."
X) ; tpl-comment-level
X
X(defvar tpl-destination-marker (make-marker)
X  "Location (a marker) to leave point after expanding placeholder."
X) ; tpl-destination-marker
X(make-variable-buffer-local 'tpl-destination-marker)
X(setq-default tpl-destination-marker (make-marker))
X
X(defvar tpl-destination-needed nil
X  "Boolean flag used to signal whether a destination for point (after
X    expanding a placeholder) has been found yet."
X) ; tpl-destination-needed
X
X(defvar tpl-destination-placeholder nil
X  "Special placeholder used to place point after expanding a template."
X) ; tpl-destination-placeholder
X
X(defvar tpl-end-group nil
X  "Global variable to hold pattern for end of group."
X) ; tpl-end-group
X
X(defvar tpl-expansion-depth 1
X  "Current depth of recursive calls to expand placeholders.
X    Compared to tpl-ask-expansion-depth."
X) ; tpl-expansion-depth
X(make-variable-buffer-local 'tpl-expansion-depth)
X(setq-default tpl-expansion-depth 1)
X
X(defvar tpl-formed-placeholder-name nil
X  "Value formed by searching for next symbol after point."
X) ; tpl-formed-placeholder-name
X
X(defvar tpl-global-template-list nil
X  "Global Alist of major modes and their associated templates."
X) ; tpl-global-template-list
X
X(defvar tpl-indentation-type 'indentation
X  "Type of indentation terminals."
X) ; tpl-indentation-type
X
X(defvar tpl-local-template-list nil
X  "List of all templates and their tree values."
X) ; tpl-local-template-list
X(make-variable-buffer-local 'tpl-local-template-list)
X
X(defvar tpl-menu-buffer "Menu"
X  "Buffer used for making selections of templates."
X) ; tpl-menu-buffer
X
X(defvar tpl-newline-token nil
X  "Token indicating presence of a newline."
X) ; tpl-newline-token
X
X(defvar tpl-newline-type 'newline
X  "Type of newline terminals."
X) ; tpl-newline-type
X
X(defvar tpl-next-placeholder-name (concat tpl-temporary-placeholder-name
X					tpl-next-placeholder-number)
X  "Next unique name for temporary placeholder."
X) ; tpl-next-placeholder-number
X
X(defvar tpl-optional-type 'optional
X  "Type of optional placeholders."
X) ; tpl-optional-type
X
X(defvar tpl-other-type 'other
X  "Type of other terminals."
X) ; tpl-other-type
X
X(defvar tpl-placeholder-type 'placeholder
X  "Type of all placeholders."
X) ; tpl-placeholder-type
X
X(defvar tpl-punctuation-type 'punctuation
X  "Type of punctuation terminals."
X) ; tpl-punctuation-type
X
X(defvar tpl-query-flag t
X  "If non-nil query about placeholder names."
X) ; tpl-query-flag
X
X(defvar tpl-saved-map nil
X  "Local keymap to restore when turning off template-mode."
X) ; tpl-saved-map
X(make-variable-buffer-local 'tpl-saved-map)
X
X(defvar tpl-terminal-type 'terminal
X  "Type of all literal strings."
X) ; tpl-terminal-type
X
X(defvar tpl-textlong-buffer "Textlong"
X  "Buffer used for creating textlong values."
X) ; tpl-textlong-buffer
X
X(defvar tpl-whitespace-type 'whitespace
X  "Type of whitespace terminals."
X) ; tpl-whitespace-type
X
X(defvar tpl-word-type 'word
X  "Type of word terminals."
X) ; tpl-word-type
X
X(defvar tpl-work-buffer "Work"
X  "Buffer used for constructing temporary objects."
X) ; tpl-work-buffer
X
X;;;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
X
X;;; end of tplvars.el
SHAR_EOF
if test 11467 -ne "`wc -c < 'tplvars.el'`"
then
	echo shar: "error transmitting 'tplvars.el'" '(should have been 11467 characters)'
fi
fi
exit 0
#	End of shell archive


