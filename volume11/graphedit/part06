Subject:  v11i102:  Graphics editor for Suns, Part06/06
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: steinmetz!sbcs!nyfca1!chan (Douglas Chan)
Posting-number: Volume 11, Issue 102
Archive-name: graphedit/part06

# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
#
# Contents:  images/ images/arc.pr images/border.pr images/borderfill.pr
#	images/circle.pr images/dash.pr images/dot.pr images/dotdash.pr
#	images/ellipse.pr images/fill.pr images/norotate.pr images/polygon.pr
#	images/polyline.pr images/rect.pr images/rotate.pr images/solid.pr
#	images/text.pr images/trace.pr images/graphedit.icon ps.head
#	graphedit.l optmize.c misc.c ps2pic.c ps2plot.c optm.c
 
echo mkdir - images
mkdir images
chmod u=rwx,g=rx,o=rx images
 
echo x - images/arc.pr
sed 's/^@//' > "images/arc.pr" <<'@//E*O*F images/arc.pr//'
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x0000,0x0000,0x7C00,0x0300,0x00C0,0x0020,0x0020,0x0010,
	0x0010,0x0008,0x0008,0x0008,0x0008,0x0008,0x0000,0x0000
@//E*O*F images/arc.pr//
chmod u=r,g=r,o=r images/arc.pr
 
echo x - images/border.pr
sed 's/^@//' > "images/border.pr" <<'@//E*O*F images/border.pr//'
/* Format_version=1, Width=64, Height=14, Depth=1, Valid_bits_per_item=16
 */
	0x00FF,0xFFFF,0xFFFF,0xFF00,0x00FF,0xFFFF,0xFFFF,0xFF00,
	0x00C0,0x0000,0x0000,0x0300,0x00C0,0x0000,0x0000,0x0300,
	0x00C0,0x0000,0x0000,0x0300,0x00C0,0x0000,0x0000,0x0300,
	0x00C0,0x0000,0x0000,0x0300,0x00C0,0x0000,0x0000,0x0300,
	0x00C0,0x0000,0x0000,0x0300,0x00C0,0x0000,0x0000,0x0300,
	0x00C0,0x0000,0x0000,0x0300,0x00C0,0x0000,0x0000,0x0300,
	0x00FF,0xFFFF,0xFFFF,0xFF00,0x00FF,0xFFFF,0xFFFF,0xFF00
@//E*O*F images/border.pr//
chmod u=r,g=r,o=r images/border.pr
 
echo x - images/borderfill.pr
sed 's/^@//' > "images/borderfill.pr" <<'@//E*O*F images/borderfill.pr//'
/* Format_version=1, Width=64, Height=14, Depth=1, Valid_bits_per_item=16
 */
	0x00FF,0xFFFF,0xFFFF,0xFF00,0x00FF,0xFFFF,0xFFFF,0xFF00,
	0x00E2,0x2222,0x2222,0x2300,0x00E2,0x2222,0x2222,0x2300,
	0x00C8,0x8888,0x8888,0x8B00,0x00C8,0x8888,0x8888,0x8B00,
	0x00E2,0x2222,0x2222,0x2300,0x00E2,0x2222,0x2222,0x2300,
	0x00C8,0x8888,0x8888,0x8B00,0x00C8,0x8888,0x8888,0x8B00,
	0x00E2,0x2222,0x2222,0x2300,0x00E2,0x2222,0x2222,0x2300,
	0x00FF,0xFFFF,0xFFFF,0xFF00,0x00FF,0xFFFF,0xFFFF,0xFF00
@//E*O*F images/borderfill.pr//
chmod u=r,g=r,o=r images/borderfill.pr
 
echo x - images/circle.pr
sed 's/^@//' > "images/circle.pr" <<'@//E*O*F images/circle.pr//'
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x07C0,0x1830,0x2008,0x4004,0x4004,0x8002,0x8002,0x8002,
	0x8002,0x8002,0x4004,0x4004,0x2008,0x1830,0x07C0,0x0000
@//E*O*F images/circle.pr//
chmod u=r,g=r,o=r images/circle.pr
 
echo x - images/dash.pr
sed 's/^@//' > "images/dash.pr" <<'@//E*O*F images/dash.pr//'
/* Format_version=1, Width=64, Height=14, Depth=1, Valid_bits_per_item=16
 */
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0FC3,0xF0FC,0x3F0F,0xC3F0,0x0FC3,0xF0FC,0x3F0F,0xC3F0,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
@//E*O*F images/dash.pr//
chmod u=r,g=r,o=r images/dash.pr
 
echo x - images/dot.pr
sed 's/^@//' > "images/dot.pr" <<'@//E*O*F images/dot.pr//'
/* Format_version=1, Width=64, Height=14, Depth=1, Valid_bits_per_item=16
 */
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0C30,0xC30C,0x30C3,0x0C30,0x0C30,0xC30C,0x30C3,0x0C30,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
@//E*O*F images/dot.pr//
chmod u=r,g=r,o=r images/dot.pr
 
echo x - images/dotdash.pr
sed 's/^@//' > "images/dotdash.pr" <<'@//E*O*F images/dotdash.pr//'
/* Format_version=1, Width=64, Height=14, Depth=1, Valid_bits_per_item=16
 */
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0FC3,0x0FC3,0x0FC3,0x0FC0,0x0FC3,0x0FC3,0x0FC3,0x0FC0,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
@//E*O*F images/dotdash.pr//
chmod u=r,g=r,o=r images/dotdash.pr
 
echo x - images/ellipse.pr
sed 's/^@//' > "images/ellipse.pr" <<'@//E*O*F images/ellipse.pr//'
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x0000,0x07E0,0x1818,0x2004,0x4002,0x8001,0x8001,0x8001,
	0x8001,0x8001,0x4002,0x2004,0x1818,0x07E0,0x0000,0x0000
@//E*O*F images/ellipse.pr//
chmod u=r,g=r,o=r images/ellipse.pr
 
echo x - images/fill.pr
sed 's/^@//' > "images/fill.pr" <<'@//E*O*F images/fill.pr//'
/* Format_version=1, Width=64, Height=14, Depth=1, Valid_bits_per_item=16
 */
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0022,0x2222,0x2222,0x2000,0x0022,0x2222,0x2222,0x2000,
	0x0008,0x8888,0x8888,0x8800,0x0008,0x8888,0x8888,0x8800,
	0x0022,0x2222,0x2222,0x2000,0x0022,0x2222,0x2222,0x2000,
	0x0008,0x8888,0x8888,0x8800,0x0008,0x8888,0x8888,0x8800,
	0x0022,0x2222,0x2222,0x2000,0x0022,0x2222,0x2222,0x2000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
@//E*O*F images/fill.pr//
chmod u=r,g=r,o=r images/fill.pr
 
echo x - images/norotate.pr
sed 's/^@//' > "images/norotate.pr" <<'@//E*O*F images/norotate.pr//'
/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
 */
	0x01FF,0xFFFF,0xFFFF,0xFFF0,0x0100,0x4000,0x0000,0x0010,
	0x0100,0xE000,0x0000,0x0010,0x0100,0x4000,0x0000,0x0010,
	0x0101,0x0000,0x0000,0x0010,0x0101,0x0000,0x0000,0x0010,
	0x0101,0x6000,0x0000,0x0010,0x0101,0x9000,0x0000,0x0010,
	0x0101,0x1000,0x0000,0x0010,0x0101,0x1000,0x0000,0x0010,
	0x0101,0x9000,0x0000,0x0010,0x0101,0x6000,0x0000,0x0010,
	0x0100,0x0000,0x0000,0x0010,0x0100,0x4000,0x0000,0x0010,
	0x0118,0xE000,0x0000,0x0010,0x01A5,0x4000,0x0000,0x0010,
	0x019D,0xFFFF,0xFFFF,0xF110,0x01A5,0x4000,0x0000,0x1390,
	0x0124,0x4000,0x0000,0x1110,0x011A,0x4000,0x0000,0x1110,
	0x0100,0x4000,0x0000,0x1110,0x0100,0x4000,0x0000,0x1110,
	0x0100,0x4000,0x0000,0x1110,0x0100,0x4000,0x0000,0x1110,
	0x0100,0x4080,0x0000,0x1110,0x0100,0x53C0,0x0000,0x1110,
	0x0100,0x5280,0x0000,0x1110,0x0100,0x5280,0x0000,0x1010,
	0x0100,0x4E80,0x0000,0x1410,0x0100,0x4280,0x0000,0x1410,
	0x0100,0x5280,0x0000,0x1590,0x0100,0x4E80,0x0000,0x1650,
	0x0100,0x4080,0x0000,0x1450,0x0100,0x4080,0x0000,0x1450,
	0x0100,0x4080,0x0020,0x1450,0x0100,0x40FF,0xFFF0,0x1450,
	0x0100,0x4000,0x0020,0x1010,0x0100,0x4000,0x0000,0x1010,
	0x0100,0x4000,0x0110,0x1110,0x0100,0x4000,0x00A0,0x1110,
	0x0100,0x4000,0x0040,0x1110,0x0100,0x4000,0x00A0,0x1110,
	0x0100,0x4000,0x0110,0x1110,0x0100,0x4000,0x0000,0x1110,
	0x0100,0x4000,0x0000,0x1390,0x0100,0x7FFD,0xFFFF,0xF110,
	0x0100,0x0000,0x0000,0x0010,0x0100,0x0001,0x1000,0x0010,
	0x0100,0x2001,0x1000,0x2010,0x0100,0x7FF9,0x53FF,0xF010,
	0x0100,0x2001,0x5000,0x2010,0x0100,0x0001,0x5000,0x0010,
	0x0100,0x0000,0xA000,0x0010,0x0100,0x0000,0x0000,0x0010,
	0x0100,0x0000,0x0000,0x0010,0x0100,0x0000,0x0000,0x0010,
	0x0100,0x0000,0x0000,0x0010,0x0100,0x0000,0x0000,0x0010,
	0x0100,0x0000,0x0000,0x0010,0x0100,0x0000,0x0000,0x0010,
	0x0100,0x0000,0x0000,0x0010,0x0100,0x0000,0x0000,0x0010,
	0x0100,0x0000,0x0000,0x0010,0x01FF,0xFFFF,0xFFFF,0xFFF0
@//E*O*F images/norotate.pr//
chmod u=r,g=r,o=r images/norotate.pr
 
echo x - images/polygon.pr
sed 's/^@//' > "images/polygon.pr" <<'@//E*O*F images/polygon.pr//'
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x8003,0xE00D,0x9032,0x4CC2,0x4302,0x4002,0x4004,0x4004,
	0x2004,0x2008,0x2008,0x2008,0x2008,0x1010,0x11F0,0x1E00
@//E*O*F images/polygon.pr//
chmod u=r,g=r,o=r images/polygon.pr
 
echo x - images/polyline.pr
sed 's/^@//' > "images/polyline.pr" <<'@//E*O*F images/polyline.pr//'
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x8003,0xE00D,0x9032,0x4CC2,0x4302,0x4002,0x4004,0x4004,
	0x2004,0x2008,0x2008,0x2008,0x2008,0x1010,0x1010,0x1000
@//E*O*F images/polyline.pr//
chmod u=r,g=r,o=r images/polyline.pr
 
echo x - images/rect.pr
sed 's/^@//' > "images/rect.pr" <<'@//E*O*F images/rect.pr//'
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x0000,0x0000,0xFFFF,0x8001,0x8001,0x8001,0x8001,0x8001,
	0x8001,0x8001,0x8001,0x8001,0xFFFF,0x0000,0x0000,0x0000
@//E*O*F images/rect.pr//
chmod u=r,g=r,o=r images/rect.pr
 
echo x - images/rotate.pr
sed 's/^@//' > "images/rotate.pr" <<'@//E*O*F images/rotate.pr//'
/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
 */
	0x01FF,0xFFFF,0xFFFF,0xFFF0,0x0100,0x4000,0x0000,0x0010,
	0x0100,0xE000,0x0000,0x0010,0x0100,0x4000,0x0000,0x0010,
	0x0101,0x0000,0x0000,0x0010,0x0101,0x0000,0x0000,0x0010,
	0x0101,0x6000,0x0000,0x0010,0x0101,0x9000,0x0000,0x0010,
	0x0101,0x1000,0x0000,0x0010,0x0101,0x1000,0x0000,0x0010,
	0x0101,0x9000,0x0000,0x0010,0x0101,0x6000,0x0000,0x0010,
	0x0100,0x0000,0x0000,0x0010,0x0100,0x4000,0x0000,0x0010,
	0x0118,0xE000,0x0000,0x0010,0x01A5,0x4000,0x0000,0x0010,
	0x019D,0xFFFF,0xFFFF,0xF110,0x01A5,0x4000,0x0000,0x1390,
	0x0124,0x4000,0x0000,0x1110,0x011A,0x4000,0x0000,0x1110,
	0x0100,0x4000,0x0000,0x1110,0x0100,0x4000,0x0000,0x1110,
	0x0100,0x4000,0x0000,0x1110,0x0100,0x4000,0x0000,0x1110,
	0x0100,0x4000,0x0010,0x1110,0x0100,0x4000,0x0038,0x1110,
	0x0100,0x4000,0x0010,0x1110,0x0100,0x4000,0x0014,0x5010,
	0x0100,0x4000,0x0012,0x9410,0x0100,0x4000,0x0011,0x1410,
	0x0100,0x4000,0x0012,0x9590,0x0100,0x4000,0x0014,0x5650,
	0x0100,0x4000,0x0010,0x1450,0x0100,0x4000,0x0010,0x1450,
	0x0100,0x4040,0x0010,0x1450,0x0100,0x40FF,0xFFF0,0x1450,
	0x0100,0x4040,0x0000,0x1010,0x0100,0x4012,0x0000,0x1010,
	0x0100,0x4012,0x0000,0x1110,0x0100,0x4012,0x0000,0x1110,
	0x0100,0x400E,0x0000,0x1110,0x0100,0x4002,0x0000,0x1110,
	0x0100,0x4012,0x0000,0x1110,0x0100,0x400E,0x0000,0x1110,
	0x0100,0x4000,0x0000,0x1390,0x0100,0x7FFD,0xFFFF,0xF110,
	0x0100,0x0000,0x0000,0x0010,0x0100,0x0001,0x1000,0x0010,
	0x0100,0x2001,0x1000,0x2010,0x0100,0x7FF9,0x53FF,0xF010,
	0x0100,0x2001,0x5000,0x2010,0x0100,0x0001,0x5000,0x0010,
	0x0100,0x0000,0xA000,0x0010,0x0100,0x0000,0x0000,0x0010,
	0x0100,0x0000,0x0000,0x0010,0x0100,0x0000,0x0000,0x0010,
	0x0100,0x0000,0x0000,0x0010,0x0100,0x0000,0x0000,0x0010,
	0x0100,0x0000,0x0000,0x0010,0x0100,0x0000,0x0000,0x0010,
	0x0100,0x0000,0x0000,0x0010,0x0100,0x0000,0x0000,0x0010,
	0x0100,0x0000,0x0000,0x0010,0x01FF,0xFFFF,0xFFFF,0xFFF0
@//E*O*F images/rotate.pr//
chmod u=r,g=r,o=r images/rotate.pr
 
echo x - images/solid.pr
sed 's/^@//' > "images/solid.pr" <<'@//E*O*F images/solid.pr//'
/* Format_version=1, Width=64, Height=14, Depth=1, Valid_bits_per_item=16
 */
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0FFF,0xFFFF,0xFFFF,0xFFF0,0x0FFF,0xFFFF,0xFFFF,0xFFF0,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
@//E*O*F images/solid.pr//
chmod u=r,g=r,o=r images/solid.pr
 
echo x - images/text.pr
sed 's/^@//' > "images/text.pr" <<'@//E*O*F images/text.pr//'
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x0000,0x0000,0x0000,0x0040,0x0040,0x1858,0x2464,0x1C44,
	0x2444,0x2464,0x1A58,0x0000,0x0000,0x0000,0x0000,0x0000
@//E*O*F images/text.pr//
chmod u=r,g=r,o=r images/text.pr
 
echo x - images/trace.pr
sed 's/^@//' > "images/trace.pr" <<'@//E*O*F images/trace.pr//'
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
 */
	0x0100,0x0280,0x0440,0x0820,0x0810,0x0810,0x0410,0x0210,
	0x0220,0x8140,0x4080,0x2140,0x1221,0x0C12,0x000C,0x0000
@//E*O*F images/trace.pr//
chmod u=r,g=r,o=r images/trace.pr
 
echo x - images/graphedit.icon
sed 's/^@//' > "images/graphedit.icon" <<'@//E*O*F images/graphedit.icon//'
/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
 */
	0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8000,0x0000,0x0000,0x0001,
	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
	0x803F,0xFFFF,0xFFFF,0xC001,0x8020,0x0000,0x0000,0x4001,
	0x8020,0x0000,0x0000,0x4001,0x8020,0x0000,0x0000,0x4001,
	0x8020,0x0000,0x0000,0x4001,0x8020,0x0000,0x0000,0x4001,
	0x80FF,0xFFFF,0xF000,0x4001,0x808A,0xAAAA,0x2000,0x4001,
	0x8088,0x8888,0x4000,0x4001,0x8080,0x0000,0x8000,0x4001,
	0x80EF,0xFFE1,0x0000,0x4001,0x8088,0x0042,0x0000,0x4001,
	0x80C8,0x0084,0x0000,0x4001,0x8088,0x0108,0x0000,0x4001,
	0x80E8,0x0210,0x0000,0x4001,0x8088,0x0420,0x0000,0x4001,
	0x80C8,0x0840,0x0000,0x4001,0x8088,0x1080,0x0000,0x4001,
	0x80E8,0x2100,0x0000,0x4001,0x8088,0x4200,0x0400,0x4001,
	0x80C8,0x8400,0x0600,0x4001,0x8089,0x0800,0x0600,0x4001,
	0x80EA,0x1000,0x0500,0x4001,0x808C,0x2000,0x0500,0x4001,
	0x80C8,0x4000,0x0480,0x4001,0x8080,0x8000,0x0580,0x4001,
	0x80E1,0x0000,0x0740,0x4001,0x8082,0x0000,0x0340,0x4001,
	0x80C4,0x0000,0x02C0,0x4001,0x8088,0x0000,0x02A0,0x4001,
	0x8090,0x0000,0x01A0,0x4001,0x80A0,0x0000,0x0160,0x4001,
	0x80E0,0x0000,0x0150,0x4001,0x80A0,0x0000,0x00D0,0x4001,
	0x8020,0x0000,0x00B0,0x4001,0x8020,0x0000,0x00A8,0x4001,
	0x8000,0x0001,0x0068,0x4001,0x8000,0x0001,0x0058,0x4001,
	0x8D2C,0x30B1,0x6054,0x4001,0x9332,0x48C9,0x9034,0x4001,
	0x9120,0x3889,0x1034,0x4001,0x9120,0x4889,0x102A,0x4001,
	0x9320,0x48C9,0x101A,0x4001,0x8D20,0x34B1,0x101A,0x4001,
	0x8100,0x0080,0x0015,0x4001,0x9120,0x0080,0x000D,0x4001,
	0x8E20,0x0088,0x400D,0x4001,0x8020,0x0008,0x010A,0xC001,
	0x8020,0x3869,0xC3C6,0xC001,0x803F,0x4498,0x410E,0xC001,
	0x8000,0x7888,0x4105,0xC001,0x8000,0x4088,0x4103,0xC001,
	0x8000,0x4498,0x4123,0x4001,0x8000,0x3868,0x40C2,0x2001,
	0x8000,0x0000,0x0001,0x2001,0x8000,0x0000,0x0001,0x4001,
	0x8000,0x0000,0x0000,0x8001,0xFFFF,0xFFFF,0xFFFF,0xFFFF
@//E*O*F images/graphedit.icon//
chmod u=r,g=r,o=r images/graphedit.icon
 
echo x - ps.head
sed 's/^@//' > "ps.head" <<'@//E*O*F ps.head//'
%!
% @(#)ps.head	1.2	6/8/87 Copyright 1987 SBCS-chan
%
/$graphedit 100 dict def
$graphedit begin
/GE_X 512 array def
/GE_Y 512 array def
/GE_PI 3.1415927 def
/GE_FONT 0 def
/GE_CHARSIZE 12. def
/GE_FILL_VALUE 0 def
/GE_FONT_NAME [ /Courier /Times-Roman /Symbol
                /Times-BoldItalic /Helvetica-Bold ] def

/GE_LINE_STYLES [
   { [] 0 setdash }
   { [1 2] 1 setdash }
   { [5] 0 setdash }
   { [10 2 1 2] 0 setdash } ] def

/GE_DO_FILL {
   0 GE_FILL_VALUE eq
     {stroke}
     {1 GE_FILL_VALUE eq
       {greylevel setgray fill 0. setgray}
       {gsave greylevel setgray fill 0. setgray grestore stroke}
      ifelse
     }
   ifelse
   /GE_FILL_VALUE 0 def
} def
/GE_MOVE {
   moveto
} def
/GE_LINE {
   lineto currentpoint stroke moveto
} def
/GE_TEXT {
   0. GE_CHARSIZE -3. div rmoveto
   show
} def
/GE_DO_POLYLINE {
   newpath
   /GE_I 0 def
   0 1 GE_N {
     GE_X GE_I get
     GE_Y GE_I get lineto
     /GE_I GE_I 1 add def
     pop
   } for
   stroke
} def
/GE_DO_POLYGON {
   newpath
   /GE_I 1 def
   GE_X 0 get
   GE_Y 0 get moveto
   1 1 GE_N 1 sub {
     GE_X GE_I get
     GE_Y GE_I get lineto
     /GE_I GE_I 1 add def
     pop
   } for
   closepath GE_DO_FILL} def
/GE_POLYLINE {
   /GE_TMP_Y exch def
   /GE_TMP_X exch def
   /GE_N 0 def
   /GE_LASTINSTR { GE_DO_POLYLINE } def
   GE_X GE_N GE_TMP_X put
   GE_Y GE_N GE_TMP_Y put
   /GE_N GE_N 1 add def
} def
/GE_POLYGON {
   /GE_TMP_Y exch def
   /GE_TMP_X exch def
   /GE_N 0 def
   /GE_LASTINSTR { GE_DO_POLYGON } def
   GE_X GE_N GE_TMP_X put
   GE_Y GE_N GE_TMP_Y put
   /GE_N GE_N 1 add def
} def
/GE_CIRCLE {
   /GE_RADIUS exch def
   currentpoint newpath GE_RADIUS 0. 365. arc GE_DO_FILL
} def
/GE_ELLIPSE {
   /GE_B exch def
   /GE_A exch def
   gsave
   1. GE_B GE_A div scale
   currentpoint newpath 
   GE_A 0. 365. arc GE_DO_FILL
   grestore
} def
/GE_ARC {
   /GE_ANG2 exch 180. mul GE_PI div def
   /GE_ANG1 exch 180. mul GE_PI div def
} def
/GE_ARCEXT {
   /GE_RADIUS exch def
   currentpoint currentpoint newpath 
   GE_RADIUS GE_ANG1 GE_ANG2 arc stroke moveto
} def
/GE_CONT {
   /GE_TMP_Y exch def
   /GE_TMP_X exch def
   GE_X GE_N GE_TMP_X put
   GE_Y GE_N GE_TMP_Y put
   /GE_N GE_N 1 add def
} def
/GE_END {
   GE_LASTINSTR
} def
/GE_SET_FONT {
   /GE_FONT exch def
   GE_FONT_NAME GE_FONT get findfont
   GE_CHARSIZE scalefont setfont
} def
/GE_SET_LINESTYLE {
   /GE_LINESTYLE exch def
   GE_LINE_STYLES GE_LINESTYLE get exec
} def
/GE_SET_COLOR {
   1 add 12 div 1 exch sub /greylevel exch def
} def
/GE_SET_LINEWIDTH {
   2. div setlinewidth
} def
/GE_SET_CHARSIZE {
   1.5 mul /GE_CHARSIZE exch def
   GE_FONT_NAME GE_FONT get findfont
   GE_CHARSIZE scalefont setfont
} def
/GE_NEW_SEG {
   gsave
} def
/GE_END_SEG {
   grestore
} def
/GE_TRANSLATE {
   translate
} def
/GE_ROTATE {
   rotate
} def
/GE_SCALE {
   scale
} def
/GE_TERM {
  restore
  showpage
  end
} def
/GE_FILL {
   /GE_FILL_VALUE exch def
} def
save
initgraphics
1 setlinecap 1 setlinejoin
@//E*O*F ps.head//
chmod u=r,g=r,o=r ps.head
 
echo x - graphedit.l
sed 's/^@//' > "graphedit.l" <<'@//E*O*F graphedit.l//'
@.\" @(#)graphedit.l	1.2 6/8/87 Copyright 1987 SBCS-chan;
@.TH GRAPHEDIT 1 "18 May 1987"
@.SH NAME
graphedit \- a general purpose graphic editor
@.SH SYNOPSIS
\fBgraphedit\fP
@.SH DESCRIPTION
\fIGraphedit\fP is a general purpose graphic editor used to
create and edit diagrams, which may be printed on high quality
laser printers after convertion to format acceptable
by the printers.  Diagrams are saved and load in
PostScript, which can be printed directly on any PostScript printers
without any convertion.  Diagrams can also be written in
\fIrasterfile(5)\fP, \fIplot(5)\fP and as input to \fIpic(1)\fP.
@.LP
Each diagram by \fIgraphedit\fP consists of a number of segments.
Each segment may consists of any number of primitives such as
rectangles, circles, polygons and text strings.  Most editing are
performed as operations on segments.  Each primitive may be
drawn with some attributes, such as color, font, and line width.
@.LP
\fIGraphedit\fP must be started in the \fIsuntools(1)\fP environment.
It takes generic tool arguments.
A view surface and a control pad is displayed when \fIgraphedit\fP is started.
The view surface displays the diagram being edited.
At the upper left corner of the view surface, samples are displayed
to show the attributes currently selected.
@.LP
The control pad is used to display messages from \fIgraphedit\fP and to
select operations, attributes and options.  The control pad consists of
the message window, editor operations window, segment operations window,
primitives window and the attributes and options selection window
from top to bottom.
@.LP
Messages
@.RS
The first line of the message window displays messages from
\fIgraphedit\fP, while the second displays the effect of
pressing the Left, Middle, and Right buttons of the mouse inside
the view surface.
@.RE
@.LP
Editor Operations
@.RS
\fBSave\fP - Save diagram in <File> in PostScript.
@.LP
\fBLoad\fP - Load diagram from <File>.  <File> must be written by \fBSave\fP.
@.LP
\fBRedisplay\fP - Redislay diagram in view_surface.
@.LP
\fBQuit\fP - Exit from editor.
@.LP
\fBClear\fP - Clear diagram.  Unsaved diagram will be lost.
@.LP
\fBScale\fP - Scale the diagram to within a rectangular region on the view
surface.
@.LP
\fBOutput\fP - Write the diagram to <File> in a format other than PostScript.
<File> cannot be \fBLoad\fP.  Available formats are \fIrasterfile(5)\fP,
\fIplot(5)\fP, and \fIpic(1)\fP.  The format used is specified by the
\fBOutput Format\fP option.  Whole or part of the view surface can be
written in \fIrasterfile(5)\fP as specified by the \fBSelect Area for Raster\fP
option.
@.LP
\fBFile\fP - File name used in save,load and output of diagrams and segments.
@.RE
@.LP
Segment Operations
@.RS
\fBCreate\fP - Create a new segment to be the current segment.
@.LP
\fBEdit\fP - Select an existing segment to be the current segment.
@.LP
\fBDelete\fP - Delete a selected segment.
@.LP
\fBSave\fP - Save a selected segment in <File>.
@.LP
\fBLoad\fP - Load segment saved in <File>.
@.LP
\fBCopy\fP - Copy a selected segment to a new location.
@.LP
\fBMove\fP - Move a selected segment to a new location.
@.LP
\fBRotate\fP - Rotate a selected segment on where it is selected.  The
angle of rotation is adjusted by moving the cursor left and right.
@.LP
\fBScale\fP - Scale a selected segment on where it is selected.  Moving
the cursor right and up will increase the size of the segment, while moving
it left and down will decrease the size initially and eventually reverse
the segment.  Only moving the cursor right/left will increase/decrease the
size of the segment when the \fBProportional Scale\fP option is on.
@.LP
\fBJoin\fP - Join other segments selected to the first selected segment
to form a single segment.
@.LP
\fBBreak\fP - Break up a selected segment such that each individual primitive
in it will be a segment.
@.LP
\fBUndelete\fP - Undelete the last deleted segment.
@.RE
@.LP
Primitives
@.RS
Any primitive drawn will be added to the current segment with the
attributes currently selected.  If there is no current segment,
a new segment will be created before the primitive is drawn.
The current segment is redrawn every two seconds if the
\fBBlink Current Segment\fP option is on.
@.LP
The primitives on the first row, from left to right, are
\fBPolyline\fP, \fBPolygon\fP, \fBCircle\fP, \fBRectangle\fP,
\fBFreehand\fP, \fBEllipse\fP and \fBArc\fP.  The second row is
used by \fBText\fP.
@.LP
\fBPolyline\fP - Draw any number of connecting lines.
@.LP
\fBPolygon\fP - Draw a polygon. The last point will be connected to
the first point.
@.LP
\fBCircle\fP - Draw a circle before any scaling.  Appear as
an ellipse after it is scaled.
@.LP
\fBRectangle\fP - Draw a rectangle.
@.LP
\fBFreehand\fP - Draw a number of lines following the movement of the
cursor.
@.LP
\fBEllipse\fP - Draw an ellipse.
@.LP
\fBArc\fP - Draw an arc by giving the end points and a point
the arc will go through.
@.LP
\fBText\fP - Draw the text string specified on the right of the button.
@.RE
@.LP
Attributes and Options
@.RS
\fBLine width\fP - Specify the width of any line drawn in \fBPolyline\fP,
\fBPolygon\fP, \fBCircle\fP and \fBRectangle\fP.
@.LP
\fBGrid interval\fP - Specify the interval of the grid displayed and used
for alignment.
@.LP
\fBColor\fP - Specify the color used to fill \fBPolygon\fP, \fBCircle\fP,
\fBEllipse\fP
and \fBRectangle\fP.  It actually appears as lighter to darker patterns
on output from printer.
@.LP
\fBFont size\fP - Specify the size of characters used for \fBText\fP.
@.LP
\fBLine style\fP - Specify the style of any line drawn in \fBPolyline\fP,
\fBPolygon\fP, \fBCircle\fP, \fBRectangle\fP, \fBEllipse\fP, \fBFreehand\fP
and \fBArc\fP.
@.LP
\fBFont\fP - Specify the PostScript font used on printer output for
\fBText\fP drawn.  Only similar fonts are displayed on the view surface.
@.LP
\fBGrid\fP - The grid is displayed when it is on.  It is  independant to the
\fBAlign\fP option.
@.LP
\fBAlign\fP - When it is on, any point chosen when drawing any primitive
will be aligned to the closest point on the grid.  It also aligns the
movement of segments in \fBMove\fP and \fBCopy\fP.
It is independant to the \fBGrid\fP option.
@.LP
\fBShow Options/Options Done\fP - Show/Close the options window.
@.LP
The cycle below \fBShow Options/Options Done\fP is the \fBBorder/Fill\fP option.
It specifies whether \fBPolyline\fP, \fBCircle\fP,
\fBRectangle\fP, or \fBEllipse\fP  drawn will only have a border,
only be filled with \fBColor\fP, or both.
@.RE
@.LP
Options Window
@.RS
The Options Window consists of two parts.  The upper part specify how
the saved diagram will be positioned on 8.5 x 11 paper when it is
printed.  The lower part specify other options.
@.LP
\fBw\fP, \fBh\fP, \fBa\fP and \fBb\fP specify the width and height of the
diagram, and the offset from the upper left corner of the paper as shown in the
illustration in the window.
@.LP
\fBScale\fP/\fBFix Width\fP/\fBFix Height\fP specify whether the
diagram should be scaled to the specified width and height, adjusted to
the specified width, or adjusted to the specified height.
@.LP
\fBCenter\fP/\fBOffset a,b\fP specify whether the diagram will be centered
on the paper,  or at the specified offset.
@.LP
Clicking the left mouse button on the illustration will change the
direction of the x and y axis of the diagram on the paper.
@.LP
\fBAuto Create\fP - When it is on, a new segment will be created for every
primitive drawn.
@.LP
\fBContinous\fP - When it is on, \fIgraphedit\fP will repeat
the function chosen until the function is cancelled or no segment is selected.
Functions affected by this options are \fBMove\fP, \fBRotate\fP, \fBScale\fP,
\fBDelete\fP, \fBCopy\fP and all primitive functions.
@.LP
\fBProportional Scale\fP - When it is on, scale of segments will be done
proportionally along the x and y axis.  Moving the cursor to the right/left
will increase/decrease the size of the segment.
@.LP
\fBBlink Current Segment\fP - When it is on, \fIgraphedit\fP will blink
the current segment every two seconds. Default is on.
@.LP
\fBOptimize Before Save\fP - When it is on, \fIgraphedit\fP will run
an internal optimizer on the diagram before it is saved.  Default is on.
@.LP
\fBOutput Format\fP - Specify which output format to use for
\fBOutput\fP.  Can be \fIRaster\fP, \fIPic\fP or \fIPlot\fP.
@.LP
\fBSelect Area for Raster\fP - When it is on, \fIgraphedit\fP will
write the raster of a rectangular region on the view surface selected by the
user instead of the whole view surface.
@.LP
The environment GEDIR can be set to indicate the directory where
the required files for \fIgraphedit\fP are located.  A default
directory will be used otherwise.
@.SH "FILES"
@.LP
$GELIB/ps.head File included at beginning of saved diagram
@.SH "SEE ALSO"
suntools(1), pic(1), rasterfile(5), plot(5)
@.SH BUGS
@.LP
The correct location of the cursor in the view surface cannot
be read before the view surface is swapped in.  A crosshair is
displayed at the location read by \fIgraphedit\fP when there is
no other feedback. Moving the mouse slightly in the view suface
will let \fIgraphedit\fP read the current location of the cursor.
@.LP
Primitives such as \fBText\fP, \fBCircle\fP, \fBEllipse\fP
and \fBArc\fP in a segment
may appear differently when it is joined to another segment with 
different rotation and scale.
@.LP
Can \fBUndelete\fP only up to the last ten segments deleted.
@.LP
Fonts on view surface are different from PostScript fonts.
@.LP
Hidden regions on the view surface will be blackened in the
raster file written.
@.LP
Output in \fIpic(1)\fP or \fIplot(5)\fP
ignores attributes that \fIpic(1)\fP and \fIplot(5)\fP do not
support.  Output in pic(1) ignores \fBColor\fI and \fBBorder/Fill\fP.
Output in \fIplot(5)\fP ignores \fBLine width\fP,
\fBColor\fP, \fBFont size\fP, \fBFont\fP and \fBBorder/Fill\fP.
@//E*O*F graphedit.l//
chmod u=r,g=r,o=r graphedit.l
 
echo x - optmize.c
sed 's/^@//' > "optmize.c" <<'@//E*O*F optmize.c//'

static char SccsId[] = "@(#)optmize.c	1.1 6/8/87 Copyright 1987 SBCS-chan";

/*****************************************************************************

          (c) Copyright 1987 

          Lap-Tak Chan
          Computer Science Department
          State University of New York at Stony Brook
          Stony Brook, NY 11794

    This software and its documentation may be used, copied, and
  distributed, provided that this legend appear in all copies and
  that it is not copied or distributed for a profit.

  No representations is made about the suitability of this software
  for any purpose.  It is provided "as is" with no support and no
  express or implied warranty.

*****************************************************************************/

/*****************************************************************************

                      Instruction List Optimizer
                      ==========================

    This file contains routines which will optimize the instruction list
  of the user segments.  Currently, it will only try to eliminate
  unnecessary setting of attributes.

*****************************************************************************/

#include <stdio.h>
#include "display.h"

/* external routines and data structures from display.c */
extern struct list *ge_display_list();
extern int ge_seglist; /* segment list */
extern struct list ge_open[]; /* store display lists of segments */

/*****************************************************************************

    optimize will optimize the instruction lists of user segments by
  scanning the segment list and optimize each user segment with opt_seg().

*****************************************************************************/

optimize()
{
  int i;

  /* scan the segment list */
  for (i=ge_seglist; i; i=ge_open[i].next) {
    /* maybe it should also optimize deleted segment */
    if (ge_open[i].segno >= GE_MIN_SEG && ( ! ge_open[i].attr.deleted) ) {
      opt_seg(&(ge_open[i]));
    } /* if */
  } /* for */
  
} /* optimize */

#define UNDEFINE 100000 /* indicate that an attribute is undefined */
#define TMPSEG 100000 /* temporary segment used */

/*****************************************************************************

    opt_update will test whether an attribute need to be specified in the
  instruction list.  If it has to be specified, it will try to specify it
  as the initial attribute.  If the initial attribute has been specified,
  it will specify it on the instruction list.

  Input
    attrtype - type of attribute
    instr - the instruction used to set the attribute

*****************************************************************************/

#define opt_update(attrtype,instr) \
  if ( updated_attr.attrtype != UNDEFINE ) {\
    /* need to specify the new attribute */\
    if ( curr_attr.attrtype == UNDEFINE ) {\
      /* specify as initial attribute */\
      dlist->attr.attrtype = updated_attr.attrtype;\
    }\
    else {\
      /* change the attribute in the instruction list */\
      ge_graph(TMPSEG, instr, (float)updated_attr.attrtype, 0.);\
    }\
    curr_attr.attrtype = updated_attr.attrtype;\
    updated_attr.attrtype = UNDEFINE;\
  } /* opt_update */

/*****************************************************************************

    opt_attr will mark that a new attribute has been specified if it is
  different from the current attribute.

  Input
    attrtype - the attribute specified

*****************************************************************************/

#define opt_attr(attrtype) \
  { if (((int)ptr->x) != curr_attr.attrtype)\
      /* indicate that the attribute will have to be set */\
      updated_attr.attrtype = ptr->x;\
    else\
      /* no change of attribute is necessary */\
      updated_attr.attrtype = UNDEFINE;\
  } /* opt_attr */

/*****************************************************************************

    opt_seg will optimize the instruction list of a segment.  Currently it
  only try to eliminate unnecessary setting of attributes.  It is done
  by delaying the setting of attributes until they are used.

  Input
    dlist - pointer to display list of segment

*****************************************************************************/

opt_seg(dlist)
struct list *dlist;
{
  static struct attr undefined_attr =
    { 0.,0.,0.,1.,1.,
      UNDEFINE, UNDEFINE, UNDEFINE, UNDEFINE, UNDEFINE, 0, 0 };
  struct list *tmpdlist;
  struct attr curr_attr; /* current attributes of segment */
  struct attr updated_attr; /* attributes specified but not used yet */
  struct list_item *ptr;
  static int fill=0;

  /* no optimization necessary for empty instruction list */
  if ( !dlist->d_list )
    return;

  /* create temporary segment */
  make_new_seg(TMPSEG);
  tmpdlist = (struct list *)ge_display_list(TMPSEG);

  /* make current attribute undefined */
  curr_attr = undefined_attr;

  /* set initail attributes as attributes to be updated */
  updated_attr = dlist->attr;

  ptr = dlist->d_list->next;

  do {
    switch (ptr->instr) {
      /* set attribute */
      case GE_SETCOLOR:
        opt_attr(color);
        break;
      case GE_SETTYPELINE:
        opt_attr(linestyle);
        break;
      case GE_SETLINEWIDTH:
        opt_attr(linewidth);
        break;
      case GE_SETFONT:
        opt_attr(font);
        break;
      case GE_SETCHARSIZE:
        opt_attr(charsize);
        break;

      case GE_MOVE:
      case GE_CONT:
      case GE_PLOT:
      case GE_ARCEXT:
        /* just copy them to the instruction list of TMPSEG */
        ge_graph(TMPSEG, ptr->instr, ptr->x, ptr->y);
        break;

      case GE_FILL:
        /* save fill value which will be necessary for polygon, etc */
        fill = (int)ptr->x;
        ge_graph(TMPSEG, ptr->instr, ptr->x, ptr->y);
        break;

      case GE_LINE:
      case GE_ARC:
      case GE_POLYLINE:
        /* use line width and line style */
        opt_update(linewidth,GE_SETLINEWIDTH);
        opt_update(linestyle,GE_SETTYPELINE);
        ge_graph(TMPSEG, ptr->instr, ptr->x, ptr->y);
        break;

      case GE_TEXT:
        /* use font and character size */
        opt_update(font,GE_SETFONT);
        opt_update(charsize,GE_SETCHARSIZE);
        ge_graph(TMPSEG, ptr->instr, ptr->x, ptr->y);
        break;

      case GE_ELLIPSE:
      case GE_CIRCLE:
      case GE_POLYGON:
        /* use line width and line style for border */
        if ( (fill == GE_BORDERONLY) || (fill == GE_FILLBORDER) ) {
          opt_update(linewidth,GE_SETLINEWIDTH);
          opt_update(linestyle,GE_SETTYPELINE);
        }
        /* use color for fill */
        if ( (fill == GE_FILLONLY) || (fill == GE_FILLBORDER) ) {
          opt_update(color,GE_SETCOLOR);
        }

        fill = 0;
        ge_graph(TMPSEG, ptr->instr, ptr->x, ptr->y);
        break;

      /* check for instructions not properly handled */
      default:
        fprintf(stderr,
                "Internal Error-Action for instruction %d missing.\n",
                ptr->instr);
        break;
    } /* switch */

    ptr=ptr->next;
  } while ( ptr != dlist->d_list->next );

  /* exchange instruction list of segment and temporary segment */
  ptr = dlist->d_list;
  dlist->d_list = tmpdlist->d_list;
  tmpdlist->d_list = ptr;

  /* delete temporary segment */
  ge_delete_segment(TMPSEG);

} /* opt_seg */
@//E*O*F optmize.c//
chmod u=r,g=r,o=r optmize.c
 
echo x - misc.c
sed 's/^@//' > "misc.c" <<'@//E*O*F misc.c//'
 
static char SccsId[] = "%W% %G% Copyright 1987 SBCS-chan";
 
/*****************************************************************************

          (c) Copyright 1987 

          Lap-Tak Chan
          Computer Science Department
          State University of New York at Stony Brook
          Stony Brook, NY 11794

    This software and its documentation may be used, copied, and
  distributed, provided that this legend appear in all copies and
  that it is not copied or distributed for a profit.

  No representations is made about the suitability of this software
  for any purpose.  It is provided "as is" with no support and no
  express or implied warranty.

*****************************************************************************/

/*****************************************************************************

    This file contains a number of miscellaneous routines.

*****************************************************************************/

#include <math.h>
#define DELTA 0.0001

/*****************************************************************************

  ge_midline determine the equation of the line between (x1,y1) and
  (x2,y2) in the form of y=ax+b

  Input
    x1,y1 - one point
    x2,y2 - another point

  Output
    a,b - the equation is y=ax+b

*****************************************************************************/

ge_midline(x1,y1,x2,y2,a,b)
float x1, y1, x2, y2, *a, *b;
{

  *a = (x1-x2)/(y2-y1);
  *b = ((x2*x2-x1*x1)/(y2-y1)+y2+y1)/2;

} /* ge_midline */

/*****************************************************************************

  ge_intersect determine the intersection (x,y) of
    y=ax+b and y=cx+d

  Input
    a,b - one equation is y=ax+b
    c,d - the other equation is y=cx+d

  Output
    x,y - intersection of the two equations

*****************************************************************************/

ge_intersect(a,b,c,d,x,y)
float a,b,c,d,*x,*y;
{
  *x = (d-b)/(a-c);
  *y = a * *x +b;

} /* ge_intersect */

/*****************************************************************************

  ge_radius2 determine the radius of the arc joining (x1,y1), (x2,y2),
  (x3,y3)

  Input
    x1,y1 - starting point
    x2,y2 - point in the middle
    x3,y3 - end point

  Output
    x,y - center of arc
    Return radius of arc, will be 0 if points are on the same line

*****************************************************************************/

float ge_radius2(x1,y1,x2,y2,x3,y3,x,y)
float x1,y1,x2,y2,x3,y3,*x,*y;
{
  float a,b,c,d;

  /* abort if any two points are the same */
  if ( (x1==x2 && y1==y2) ||
       (x2==x3 && y2==y3) ||
       (x1==x3 && y1==y2) ||
       (y1==y2 && y1==y3) )
    return(0.);

  /* determine midlines between (x1,y1),(x2,y2) and (x2,y2),(x3,y3) */
  ge_midline(x1,y1,x2,y2,&a,&b);
  ge_midline(x2,y2,x3,y3,&c,&d);

  if ( y1 == y2 ) {
    /* midline between (x1,y1) and (x2,y2) is vertical */
    *x=(x1+x2)/2;
    *y=c * *x + d;
  }
  else {

    if ( y2 == y3) {
      /* midline between (x2,y2) and (x3,y3) is vertical */
      *x=(x2+x3)/2;
      *y=a * *x + b;
    }
    else {

      /* abort if slope of the midlines are the same */
      if ( fabs(a-c) < DELTA ) {
        return(0.);
      } /* if */

      /* find intersection of midlines */
      ge_intersect(a,b,c,d,x,y);

    }

  }

  /* return radius */
  return((float)sqrt((*x-x1)*(*x-x1)+(*y-y1)*(*y-y1)));

} /* ge_radius2 */

/*****************************************************************************

  ge_radius determine the radius of the arc joining (x1,y1), (x2,y2),
  (x3,y3)

  Input
    x1,y1 - starting point
    x2,y2 - point in the middle
    x3,y3 - end point

  Output
    Return radius of arc, will be 0 if points are on the same line

*****************************************************************************/

float ge_radius(x1,y1,x2,y2,x3,y3)
float x1,y1,x2,y2,x3,y3;
{
  float x,y;

  /* just call ge_radius2 and discard the returned (x,y) */
  return(ge_radius2(x1,y1,x2,y2,x3,y3,&x,&y));

} /* ge_radius */
@//E*O*F misc.c//
chmod u=rw,g=r,o=r misc.c
 
echo x - ps2pic.c
sed 's/^@//' > "ps2pic.c" <<'@//E*O*F ps2pic.c//'

static char SccsId[] = "@(#)ps2pic.c	1.1 6/8/87 Copyright 1987 SBCS-chan";

/*****************************************************************************

          (c) Copyright 1987 

          Lap-Tak Chan
          Computer Science Department
          State University of New York at Stony Brook
          Stony Brook, NY 11794

    This software and its documentation may be used, copied, and
  distributed, provided that this legend appear in all copies and
  that it is not copied or distributed for a profit.

  No representations is made about the suitability of this software
  for any purpose.  It is provided "as is" with no support and no
  express or implied warranty.

*****************************************************************************/

/*****************************************************************************

                      Pic Output Driver
                      =================

    This file contains a simple driver to run the pic output routine.  It
  just load the picture from standard input with psload and call
  the pic output routine to write the picture to standard output.

*****************************************************************************/

#include "display.h"
#include <stdio.h>

int segopen = 0;
int newseg = GE_MIN_SEG;
int opensegment = 0;
extern struct list *ge_display_list();

/* default parameters, currently unused */
struct saveattr save_attr=
  {1, 0, 65, 100, 1, 5, 5};

/*****************************************************************************

    main will initialize the display list, load the picture with ps_load,
  and write the picture to standard output with the pic output routine.

*****************************************************************************/

main(argc, argv)
int argc;
char **argv;
{
  /* initialize the display list */
  ge_init_display();

  /* load picture from standard input */
  if ( ps_load(stdin) ) {
    fprintf(stderr, "%s: Input is not saved picture\n", argv[0] );
    exit(1);
  }

  /* write pic output to standard output */
  pic_write(stdout);

  exit(0);

} /* main */

/*****************************************************************************

    make_new_seg is used by ps_load to create the display list
  of a new segment.

  Input
    segno - segment number of segment.

*****************************************************************************/

make_new_seg(segno)
int segno;
{
  struct list *dlist;

  if ( !segno ) {
    opensegment = newseg++;
    segno = opensegment;
    segopen = 1;
  }
  ge_new_segment(segno);
  dlist=ge_display_list(segno);
  dlist->attr.deleted=0;
  dlist->attr.tx=0.; dlist->attr.ty=0.;
  dlist->attr.sx=1.; dlist->attr.sy=1.;
  dlist->attr.ang=0.;
  return(segno);

} /* make_new_seg */

/*****************************************************************************

    ge_draw is a dummy routine which is called by ps_load to update the
  display of a segment on the screen.  It does not do anything here.

*****************************************************************************/

ge_draw(segno)
int segno;
{
  /* dummy routine */

} /* ge_draw */
@//E*O*F ps2pic.c//
chmod u=r,g=r,o=r ps2pic.c
 
echo x - ps2plot.c
sed 's/^@//' > "ps2plot.c" <<'@//E*O*F ps2plot.c//'

static char SccsId[] = "@(#)ps2plot.c	1.1 6/8/87 Copyright 1987 SBCS-achan";

/*****************************************************************************

          (c) Copyright 1987 

          Lap-Tak Chan
          Computer Science Department
          State University of New York at Stony Brook
          Stony Brook, NY 11794

    This software and its documentation may be used, copied, and
  distributed, provided that this legend appear in all copies and
  that it is not copied or distributed for a profit.

  No representations is made about the suitability of this software
  for any purpose.  It is provided "as is" with no support and no
  express or implied warranty.

*****************************************************************************/

/*****************************************************************************

                      Plot Output Driver
                      ==================

    This file contains a simple driver to run the plot output routine.  It
  just load the picture from standard input with psload and call
  the plot output routine to write the picture to standard output.

*****************************************************************************/

#include "display.h"
#include <stdio.h>

int segopen = 0;
int newseg = GE_MIN_SEG;
int opensegment = 0;
extern struct list *ge_display_list();
struct saveattr save_attr;

/*****************************************************************************

    main will initialize the display list, load the picture with ps_load,
  and write the picture to standard output with the plot output routine.

*****************************************************************************/

main(argc, argv)
int argc;
char **argv;
{
  /* initialize the display list */
  ge_init_display();

  /* load picture from standard input */
  if ( ps_load(stdin) ) {
    fprintf(stderr, "%s: Input is not saved picture\n", argv[0] );
    exit(1);
  }

  /* write plot output to standard output */
  plt_write();

  exit(0);

} /* main */

/*****************************************************************************

    make_new_seg is used by ps_load to create the display list
  of a new segment.

  Input
    segno - segment number of segment.

*****************************************************************************/

make_new_seg(segno)
int segno;
{
  struct list *dlist;

  if ( !segno ) {
    opensegment = newseg++;
    segno = opensegment;
    segopen = 1;
  }
  ge_new_segment(segno);
  dlist=ge_display_list(segno);
  dlist->attr.deleted=0;
  dlist->attr.tx=0.; dlist->attr.ty=0.;
  dlist->attr.sx=1.; dlist->attr.sy=1.;
  dlist->attr.ang=0.;
  return(segno);

} /* make_new_seg */

/*****************************************************************************

    ge_draw is a dummy routine which is called by ps_load to update the
  display of a segment on the screen.  It does not do anything here.

*****************************************************************************/

ge_draw(segno)
int segno;
{
  /* dummy routine */

} /* ge_draw */
@//E*O*F ps2plot.c//
chmod u=r,g=r,o=r ps2plot.c
 
echo x - optm.c
sed 's/^@//' > "optm.c" <<'@//E*O*F optm.c//'

static char SccsId[] = "@(#)optm.c	1.1 6/8/87 Copyright 1987 SBCS-chan";

/*****************************************************************************

          (c) Copyright 1987 

          Lap-Tak Chan
          Computer Science Department
          State University of New York at Stony Brook
          Stony Brook, NY 11794

    This software and its documentation may be used, copied, and
  distributed, provided that this legend appear in all copies and
  that it is not copied or distributed for a profit.

  No representations is made about the suitability of this software
  for any purpose.  It is provided "as is" with no support and no
  express or implied warranty.

*****************************************************************************/


/*****************************************************************************

                        Optimizer Driver
                        ================

    This file contains a simple driver to run the optimizer routine.  It
  just load the picture from standard input with psload, execute the 
  optimizer routine and save the picture to standard output.

*****************************************************************************/

#include "display.h"
#include <stdio.h>

int segopen = 0;
int newseg = GE_MIN_SEG;
int opensegment = 0;

extern struct list *ge_display_list();
struct saveattr save_attr;

/*****************************************************************************

    main will initialize the display list, load the picture with ps_load,
  run the optimizer, and save the picture with ps_save.

*****************************************************************************/

main(argc, argv)
int argc;
char **argv;
{
  /* initialize the display list */
  ge_init_display();

  /* load picture from standard input */
  if ( ps_load(stdin) ) {
    fprintf(stderr, "%s: Input is not saved picture\n", argv[0] );
    exit(1);
  }

  /* run the optimizer */
  optimize();

  /* save the picture to stardard output */
  ps_write(stdout);
  exit(0);

} /* main */

/*****************************************************************************

    make_new_seg is used by ps_load and optimize to create the display list
  of a new segment.

  Input
    segno - segment number of segment.

*****************************************************************************/

make_new_seg(segno)
int segno;
{
  struct list *dlist;

  if ( !segno ) {
    opensegment = newseg++;
    segno = opensegment;
    segopen = 1;
  }
  ge_new_segment(segno);
  dlist=ge_display_list(segno);
  dlist->attr.deleted=0;
  dlist->attr.tx=0.; dlist->attr.ty=0.;
  dlist->attr.sx=1.; dlist->attr.sy=1.;
  dlist->attr.ang=0.;
  return(segno);

} /* make_new_seg */

/*****************************************************************************

    ge_draw is a dummy routine which is called by ps_load to update the
  display of a segment on the screen.  It does not do anything here.

*****************************************************************************/

ge_draw(segno)
{
  /* dummy routine */

} /* ge_draw */
@//E*O*F optm.c//
chmod u=r,g=r,o=r optm.c
 
echo Inspecting for damage in transit...
temp=/tmp/shar$$; dtemp=/tmp/.shar$$
trap "rm -f $temp $dtemp; exit" 0 1 2 3 15
cat > $temp <<\!!!
       4       9     193 arc.pr
       9      14     483 border.pr
       9      14     483 borderfill.pr
       4       9     193 circle.pr
       9      14     483 dash.pr
       9      14     483 dot.pr
       9      14     483 dotdash.pr
       4       9     193 ellipse.pr
       9      14     483 fill.pr
      34      39    1933 norotate.pr
       4       9     193 polygon.pr
       4       9     193 polyline.pr
       4       9     193 rect.pr
      34      39    1933 rotate.pr
       9      14     483 solid.pr
       4       9     193 text.pr
       4       9     193 trace.pr
      34      39    1933 graphedit.icon
     160     459    2972 ps.head
     251    1536    9776 graphedit.l
     237     801    7398 optmize.c
     163     455    4031 misc.c
     115     340    3141 ps2pic.c
     112     327    3071 ps2plot.c
     115     326    3095 optm.c
    1350    4531   44208 total
!!!
wc  images/arc.pr images/border.pr images/borderfill.pr images/circle.pr images/dash.pr images/dot.pr images/dotdash.pr images/ellipse.pr images/fill.pr images/norotate.pr images/polygon.pr images/polyline.pr images/rect.pr images/rotate.pr images/solid.p


r images/text.pr images/trace.pr images/graphedit.icon ps.head graphedit.l optmize.c misc.c ps2pic.c ps2plot.c optm.c | sed 's=[^ ]*/==' | diff -b $temp - >$dtemp
if [ -s $dtemp ]
then echo "Ouch [diff of wc output]:" ; cat $dtemp
else echo "No problems found."
fi
exit 0


