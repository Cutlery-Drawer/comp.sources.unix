Subject:  v11i051:  Mail user's shell, Part01/12
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: island!argv@Sun.COM (Dan Heller)
Posting-number: Volume 11, Issue 51
Archive-name: mush5.7/Part01

[  It was only a matter of time.  This is a complete shell, similar
   in many ways to the C shell.  It's a mail program.  It's a SunTools
   program.  It's a Curses porgram.  It's a way of life.  See the
   README.  This is a biggie, and the weekend will cause a lag in the
   postings.  --r$  ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 12)."
# Contents:  MANIFEST README bindings.h check.pr coffee.cup.pr
#   config.h-dist cycle.pr dn.arrow.pr edit_menu.c envelope.pr expr.c
#   glasses.pr hdr_panel.c hdr_procs.c mail.icon.1 mail.icon.2
#   makefile.bsd makefile.sun makefile.sys.v print.c strings.h tool.c
#   up.arrow.pr write.pr
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1807 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                  1	This shipping list
X README                    1	
X aliases.c                 2	
X bind.c                    4	
X bindings.h                1	
X check.pr                  1	
X cmd_help                  5	
X coffee.cup.pr             1	
X commands.c                7	
X config.h-dist             1	
X curs_io.c                 2	
X curses.c                  6	
X cycle.pr                  1	
X dates.c                   2	
X dn.arrow.pr               1	
X doproc.c                  4	
X edit_menu.c               1	
X envelope.pr               1	
X execute.c                 2	
X expr.c                    1	
X fkeys.c                   5	
X folders.c                 2	
X glasses.pr                1	
X hdr_panel.c               1	
X hdr_procs.c               1	
X hdrs.c                    8	
X help.c                    3	
X init.c                    4	
X loop.c                    9	
X mail.c                   10	
X mail.icon.1               1	
X mail.icon.2               1	
X main.c                    3	
X main_panel.c              2	
X makefile.bsd              1	
X makefile.sun              1	
X makefile.sys.v            1	
X misc.c                    7	
X msgs.c                    6	
X mush.1.a                 11	FIRST HALF OF MANPAGE
X mush.1.b                 12	SECOND HALF OF MANPAGE
X mush.h                    6	
X pick.c                    3	
X print.c                   1	
X rite.c                    2	
X select.c                  5	
X setopts.c                 3	
X signals.c                 3	
X sort.c                    2	
X strings.h                 1	
X tool.c                    1	
X tool_help                 8	
X up.arrow.pr               1	
X viewopts.c                4	
X write.pr                  1	
END_OF_FILE
if test 1807 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(8085 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X/* @(#)README	2.4	(c) copyright 10/28/86	(Dan Heller) */
X
XAuthor:
X    Dan Heller
X
XNetwork address:
X    island!argv@sun.com   or   argv@spam.istc.sri.com
X
XContained is the source for "Mail User's Shell" (MUSH), an interface
Xfor the sending, viewing and managing of electronic mail on UNIX(tm) systems.
XRedistribution of this code is permitted as long as all copyright notices
Xremain intact and all other identifying notices remain in the code and
Xin the binary.  This includes message headers on outgoing mail and
Xthe startup message.  Failing to adhere to this reflects on your poor
Xsense of fair play and bad attitude -- you will probably fail in your
Xsocial and business affairs with little honor and respect from your peers.
X
XWith that out of the way...
X
XTo install Mush on your system, find the file that most closely resembles
X"config.h" (probably "config.h-dist") COPY it to config.h, edit it to reflect
Xthe system dependencines described there.  Decide which makefile applies
Xto you.  makefile.sun applies only to suns and creates a binary called
X"mush."  If the binary ends in "tool", then the graphics (tool) mode will
Xbe used by default on invocation. Otherwise, you must specify -t for toolmode
Xon sun workstations.  The SUNTOOL define must be set in the makefile.sun
Xin order to compile the suntools version.  You don't need to be running
Xsunview; old sunwindows (2.0+) may be used.
X
XIf you're on a BSD system and it's not a sun workstation, or if you're on a
Xsun workstation and know that you're not going to use the suntools mode then
Xyou should use makefile.bsd so that SUNTOOL won't be defined and unneccessary
Xfiles not be compiled so the binary will be made smaller.
X
Xmakefile.sys.v is for unix machines that are not running any flavor of
XBSD and probably running a system-v flavor of unix (Xenix, for example).
XThis makefile has the define, SYSV to indicate system V unix.  Some older
Xunix systems have SYSV defined in /usr/include/curses.h (which is used if
Xyou have CURSES defined in the makefile).  In most cases, these only
Xgenerate annoying warning messages and does not effect the compilation
Xof the code.
X
XMush was designed to use sendmail. However, other mail delivery subsystem have
Xworked.  The mail delivery subsystem you use should be defined in config.h
Xunder the MAIL_DELIVERY macro define. By default, /usr/lib/sendmail -i
Xis used -- the option, -i, tells sendmail not to exit on "." on a line
Xby itself.  Mush will pick that up by itself if you want that option
X(read the man page).
X
XIf your mailer does NOT have a verbose option, then you should not have
XVERBOSE_ARG defined.  Otherwise, define it to be whatever the
Xverbose argument is for your mailer.
X
XSendmail uses the -m argument to say, "metoo" -- when sending to mailing
Xlists, normally sendmail will send mail to mailing lists, but if you're
Xin that list, you are excluded from getting your own mail.  However, if
Xyou have the variable metoo set with your variables, then the METOO argument
Xis passed to sendmail to say, "I know I'm on this mailing list, but send
Xme a copy of my message even tho I sent it."  For sendmail, this is -m.
XIf your mailer uses something else, then define METOO_ARG in the config file.
XIf you don't have it (sys-v), then do not define this macro.
X
XIf you use "smail" and you're on a system-v small unix box, you might have
Xto increase your stack size (see makefile.sys.v) to prevent stack overflow.
XYou'll know you have to do this if you try sending mail (using smail as
Xthe mail delivery subsystem), mush core dumps and adb doesn't know where
Xthe stack pointer is.
X
XVPRINTF should be defined if your system has the vprintf functions. You
X*have* these functions if 1) you are running system V (xenix) or 2) you
Xare running a Sun release on or later than version 3.0.  If you are still not
Xsure, try the following command from your shell:
X
X% ar t /lib/libc.a | grep vprintf
X
XIf you have it, you'll probably get something like
Xvprintf.o
Xvsprintf.o
Xas output.  If you don't have it, you won't have any output.  If your
Xmain C-libraries are not in /lib/libc.a, then find where they are and
Xtry the same command using that file.
X
XA default mailrc should be installed for new users.  UCB mail's default
XMailrc works but no mailrc works as well. The location of the default
Xfile should be defined in config.h.  To have no default mailrc, set the
Xdefault to /dev/null.  For sun systems, the default .mailrc (/usr/lib/Mailrc)
Xdoes not work very well because sun's Mail is not standard /usr/ucb/Mail.
XFor this reason, sun has not changed the default mailrc file and still
Xresides in /usr/lib/Mail.rc (note this has the "." whereas the other file
Xdoes not).  The default config.h-dist reflects this.
X
XThe help files should be placed somewhere which is readable and accessible
Xby all. Failing to do so removes virtually the entire help facility's
Xability to help anyone.  There is a help file for command help ( `command -?'),
Xand the other is for the graphics mode (Sun workstations only).  You should
Xdefine where you want these files in "config.h" so at runtime, they can be
Xaccessed without error.
X
XThe default settings in config.h may be documented as the default values
Xin the help files.  Be aware that changing some default values may cause
Xinconsistencies with the help files and documentation.
X
XIf your system has *sys_siglist[], skip this paragraph.  If it doesn't,
Xor if your system has a non-standard list, you should edit signals.c at
Xthe top and build the table manually from the one given for System-V people.
XNote that most system-v unix systems need not change anything as long as
XSYSV is defined.
X
XMaintenance:
X
XIf you want to use dbx or any other debugger, the undocumented flag, -e
Xshould be used as command line argument when you run the binary under
Xthe debugger.  What this flag does is prevents your echo from being
Xturned off and leaving cbreak on, thus, keeping your tty in a sane state.
XBeware of curses mode tho, since it must be turned off for that -- e.g.
Xthe -e flag is overridden if you enter curses mode.  The -e flag can be
Xused in general usage anyway, but there's no difference known to the user
Xexcept for the fact that you can not type control characters.
X
XIf you have memory allocation checking and validation (sun 3.0+ ?) then
Xdefine M_DEBUG in the makefile (main.c) and add the library
X/usr/lib/debug/malloc.o to the library list. Do this only if you are
Xfind bugs in the program and suspect memory allocation errors. main.c
Xhas the code which sets the debugging level according to the value of
Xan environment variable.  Because malloc-debugging is so cpu intensive,
Xthe sunwindows program will get a SIGXCPU (cpu time limit exceeded)
Xbecause of the large amount of opening and closing large pixrects and
Xdevices.  For this reason, SIGXPCPU is is caught in main.c.
X
XIf you ever get "Message N has bad date: <date string>" then note
Xthe FORMAT of that date and edit dates.c.  There are a number of
X"sscanf"s which you can see match known date formats.  Use them as
Xexamples and insert the new date format you have.
X
XIf you ever add new variables, be sure to add them in viewopts.c and the
Xman page.
X
XIf Mush ever coredumps and you are suspicious about whether or not
Xyour folder (or spool directory) was removed.  Or, if you were editing
Xa letter, you should check for the files .mushXXXXXX and .edXXXXXXX.
XMush won't die without telling you that it's dying and it will ask if you
Xwant to save the .mush????? file and if you actually want it to dump core.
XNote that if you run mush from .suntools and there is a core dump, it
Xprobably wants to do some IO with the console and may hang (not exit)
Xbecause it doesn't know it can't talk to you.
X
XLast attempted, mush passed lint with a small number of errors indicating
Xthat fflush, fclose and other similar functions returned values which
Xwere always ignored.  Sorry.  I did not attempt lint on the suntools mode.
XCurses doesn't lint very well, but even when you lint mush with CURSES
Xdefined, it only complains about the unused curses globals in curses.h;
Xdon't let it discourage you.
END_OF_FILE
if test 8085 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'bindings.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bindings.h'\"
else
echo shar: Extracting \"'bindings.h'\" \(1492 characters\)
sed "s/^X//" >'bindings.h' <<'END_OF_FILE'
X/* bindings.h  -- command bindings */
X
X/* to see if a key sequece matches, prefixes or misses a set binding */
X#define NO_MATCH	0
X#define MATCH		1
X#define A_PREFIX_B	2
X#define B_PREFIX_A	3
X
X#define NULL_MAP	(struct cmd_map *)0
X#define C_NULL		0
X#define C_GOTO_MSG	1
X#define C_WRITE_MSG	2
X#define C_WRITE_LIST	3
X#define C_SAVE_MSG	4
X#define C_SAVE_LIST	5
X#define C_COPY_MSG	6
X#define C_COPY_LIST	7
X#define C_DELETE_MSG	8
X#define C_DELETE_LIST	9
X#define C_UNDEL_MSG	10
X#define C_UNDEL_LIST	11
X#define C_REVERSE	12
X#define C_REDRAW	13
X#define C_NEXT_MSG	14
X#define C_PREV_MSG	15
X#define C_FIRST_MSG	16
X#define C_LAST_MSG	17
X#define C_TOP_PAGE	18
X#define C_BOTTOM_PAGE	19
X#define C_NEXT_SCREEN	20
X#define C_PREV_SCREEN	21
X#define C_SHOW_HDR	22
X#define C_SOURCE	23
X#define C_SAVEOPTS	24
X#define C_NEXT_SEARCH	25
X#define C_PREV_SEARCH	26
X#define C_CONT_SEARCH	27
X#define C_PRESERVE	28
X#define C_SORT		29
X#define C_REV_SORT	30
X#define C_QUIT_HARD	31
X#define C_QUIT		32
X#define C_EXIT_HARD	33
X#define C_EXIT		34
X#define C_UPDATE	35
X#define C_FOLDER	36
X#define C_SHELL_ESC	37
X#define C_CURSES_ESC	38
X#define C_PRINT_MSG	39
X#define C_CHDIR		40
X#define C_VAR_SET	41
X#define C_IGNORE	42
X#define C_ALIAS		43
X#define C_OWN_HDR	44
X#define C_VERSION	45
X#define C_MAIL_FLAGS	46
X#define C_MAIL		47
X#define C_REPLY_SENDER	48
X#define C_REPLY_ALL	49
X#define C_DISPLAY_MSG	50
X#define C_TOP_MSG	51
X#define C_DISPLAY_NEXT	52
X#define C_BIND		53
X#define C_UNBIND	54
X#define C_HELP		55 /* THIS MUST BE THE LAST ITEM */
END_OF_FILE
if test 1492 -ne `wc -c <'bindings.h'`; then
    echo shar: \"'bindings.h'\" unpacked with wrong size!
fi
# end of 'bindings.h'
fi
if test -f 'check.pr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'check.pr'\"
else
echo shar: Extracting \"'check.pr'\" \(240 characters\)
sed "s/^X//" >'check.pr' <<'END_OF_FILE'
X/* "@(#)check.pr	2.2	9/3/86 (Dan Heller)"; */
X
X/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,0x0000,0x0001,0x0003,0x0007,0x000E,0x001C,0x0038,
X	0xC070,0xE0E0,0x71C0,0x3B80,0x1F00,0x0E00,0x0400,0x0000
END_OF_FILE
if test 240 -ne `wc -c <'check.pr'`; then
    echo shar: \"'check.pr'\" unpacked with wrong size!
fi
# end of 'check.pr'
fi
if test -f 'coffee.cup.pr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'coffee.cup.pr'\"
else
echo shar: Extracting \"'coffee.cup.pr'\" \(193 characters\)
sed "s/^X//" >'coffee.cup.pr' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0x0200,0x0100,0x0600,0x0800,0x0600,0x0100,0xFFF8,0x800C,
X	0x800A,0x4012,0x401C,0x2020,0x9048,0x7FF0,0x3FE0,0x0000
END_OF_FILE
if test 193 -ne `wc -c <'coffee.cup.pr'`; then
    echo shar: \"'coffee.cup.pr'\" unpacked with wrong size!
fi
# end of 'coffee.cup.pr'
fi
if test -f 'config.h-dist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h-dist'\"
else
echo shar: Extracting \"'config.h-dist'\" \(1634 characters\)
sed "s/^X//" >'config.h-dist' <<'END_OF_FILE'
X/* config.h 1.1	(c) copyright 1986 (Dan Heller) */
X
X#define MAILRC		".mushrc"
X#define ALTERNATE_RC	".mailrc"
X#define LIBDIR		"/usr/lib
X#define DEFAULT_RC	LIBDIR/Mail.rc"
X#define COMMAND_HELP	LIBDIR/cmd_help"
X#ifdef SUNTOOL
X#    define TOOL_HELP	LIBDIR/tool_help"
X#endif SUNTOOL
X#define ALTERNATE_HOME	"/tmp"       /* Path must be read/write to EVERYONE */
X#define EDFILE  	".edXXXXXX"  /* file/pathname added to user's "home" */
X
X/* mail delivery system */
X#define MAIL_DELIVERY	"/usr/lib/sendmail -i"
X#define VERBOSE_ARG	"-v"    /* undef if none exists */
X#define METOO_ARG	"-m"    /* man sendmail for more info. */
X
X#define	MAXMSGS		1000	/* maximum number of messages we can read */
X#ifndef MAXPATHLEN
X#define MAXPATHLEN 256
X#endif
X
X#define VPRINTF		/* If your system supports the vprintf() functions,
X			 * True for sys-v and later sun versions (3.0+ ?).
X			 */
X
X/* The maximum number of hostnames YOUR host may have (usually found in
X * /etc/hosts for BSD systems).  System-V/xenix doesn't use this (use 1).
X */
X#define MAX_HOST_NAMES  1
X
X#define LS_COMMAND	"ls"
X#define FORTUNE		"/usr/games/fortune"
X#define LPR		"lpr"
X#define SIGNATURE	".signature"
X#define MAILDIR		"/usr/spool/mail"
X
X/* default settings for some variable strings */
X#define DEF_PROMPT	"Msg %m of %t: "
X#define DEF_PAGER	"more"
X#define DEF_SHELL	"csh"
X#define DEF_EDITOR	"vi"
X#define DEF_FOLDER	"~/Mail"        /* default Mail folder */
X#define DEF_MBOX	"~/mbox"	/* default mbox */
X#define DEF_INDENT_STR	"> "		/* indent included mail */
X#define DEF_PRINTER	"lp"
X#define DEF_ESCAPE	"~"
X#define DEF_HDR_FMT	"%S %25f %7d (%l/%c) %25s" /* headers format string */
END_OF_FILE
if test 1634 -ne `wc -c <'config.h-dist'`; then
    echo shar: \"'config.h-dist'\" unpacked with wrong size!
fi
# end of 'config.h-dist'
fi
if test -f 'cycle.pr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cycle.pr'\"
else
echo shar: Extracting \"'cycle.pr'\" \(241 characters\)
sed "s/^X//" >'cycle.pr' <<'END_OF_FILE'
X/* "@(#)cycle.pr	2.2	9/3/86 (Dan Heller)"; */
X
X/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0x07C0,0x0FE0,0x1834,0x301C,0x601C,0x203C,0x0000,0x0000,
X	0x7808,0x700C,0x7018,0x5830,0x0FE0,0x07C0,0x0000,0x0000
X
END_OF_FILE
if test 241 -ne `wc -c <'cycle.pr'`; then
    echo shar: \"'cycle.pr'\" unpacked with wrong size!
fi
# end of 'cycle.pr'
fi
if test -f 'dn.arrow.pr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dn.arrow.pr'\"
else
echo shar: Extracting \"'dn.arrow.pr'\" \(243 characters\)
sed "s/^X//" >'dn.arrow.pr' <<'END_OF_FILE'
X/* "@(#)dn.arrow.pr	2.2	9/3/86 (Dan Heller)"; */
X
X/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0xFFFF,0x8001,0xBFFD,0xBFFD,0xBFFD,0x9FF9,0x8FF1,0x87E1,
X	0x83C1,0x8181,0xB825,0xA435,0xA42D,0xB825,0x8001,0xFFFF
END_OF_FILE
if test 243 -ne `wc -c <'dn.arrow.pr'`; then
    echo shar: \"'dn.arrow.pr'\" unpacked with wrong size!
fi
# end of 'dn.arrow.pr'
fi
if test -f 'edit_menu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'edit_menu.c'\"
else
echo shar: Extracting \"'edit_menu.c'\" \(3334 characters\)
sed "s/^X//" >'edit_menu.c' <<'END_OF_FILE'
X/* @(#)edit_menu.c	(c) copyright	10/18/86 (Dan Heller) */
X
X/* edit_menu.c
X * 
X * Routine which handles the menu you get when in the msg_win while editing
X * a letter.  This is just a fancy front end for ~ commands (nyuk, nyuk).
X */
X#include "mush.h"
X
X#define EDIT_IT     	(char *)'e'
X#define PAGE     	(char *)'p'
X#define INC 	 	(char *)'i'
X#define INC_HDR		(char *)'H'
X#define FWD_MSG		(char *)'f'
X#define TO_LIST		(char *)'t'
X#define SUBJECT		(char *)'s'
X#define CC_LIST		(char *)'c'
X#define BC_LIST		(char *)'b'
X#define ALL_HDR		(char *)'h'
X#define SIGN_IT		(char *)'S'
X#define NO_SIGN		(char *)'n'
X#define FORT		(char *)'F'
X#define NO_FORT		(char *)'N'
X#define ERASE   	(char *)'E'
X#define SEND	   	(char *)'X'
X#define ABORT   	(char *)'q'
X#define MENU_HELP	(char *)'?'
X
Xstatic struct menuitem edit_items[] = {
X    { MENU_IMAGESTRING,  "Enter Editor",	EDIT_IT  },
X    { MENU_IMAGESTRING,  "Send Letter",		SEND     },
X    { MENU_IMAGESTRING,  "Abort Letter",	ABORT    },
X    { MENU_IMAGESTRING,  "Review Letter",	PAGE     },
X    { MENU_IMAGESTRING,  "Include Message",	INC      },
X    { MENU_IMAGESTRING,  "Inc. msg w/hdr",	INC_HDR  },
X    { MENU_IMAGESTRING,  "Forward message",	FWD_MSG  },
X    { MENU_IMAGESTRING,  "Change To line",	TO_LIST  },
X    { MENU_IMAGESTRING,  "Change Subject",	SUBJECT  },
X    { MENU_IMAGESTRING,  "Change Cc list",	CC_LIST  },
X    { MENU_IMAGESTRING,  "Change Bcc list",	BC_LIST  },
X    { MENU_IMAGESTRING,  "Change All hdrs",	ALL_HDR  },
X    { MENU_IMAGESTRING,  "Add .signature",	SIGN_IT  },
X    { MENU_IMAGESTRING,  "No .signature",	NO_SIGN  },
X    { MENU_IMAGESTRING,  "Add a fortune",	FORT     },
X    { MENU_IMAGESTRING,  "No fortune",		NO_FORT  },
X    { MENU_IMAGESTRING,  "Erase Message",	ERASE    },
X    { MENU_IMAGESTRING,  "Help",		MENU_HELP  }
X};
X
Xstatic struct menu menu = {
X    MENU_IMAGESTRING, "Editing options",
X    sizeof (edit_items) / sizeof (struct menuitem), edit_items,
X    (struct menu *)NULL,
X    NULL
X};
X
Xedit_menu(event, fd)
Xstruct inputevent *event;
X{
X    static char buf[5];
X    struct menuitem *m_item;
X    register char *action, *p = buf+1;
X    struct menu *menu_ptr = &menu;
X
X    if (!(m_item = menu_display(&menu_ptr, event, fd)) || get_hdr_field) {
X	if (get_hdr_field)
X	    print("Finish the message header first.");
X	return;
X    }
X    action = m_item->mi_data;
X    if (txt.x > 5)
X	add_to_letter(rite('\n'));  /* flush line for him */
X
X    if (!msg_cnt && (action == INC || action == INC_HDR || action == FWD_MSG)) {
X	print("No messages to include");
X	return;
X    }
X    buf[0] = *escape;
X    switch(action) {
X	case EDIT_IT  : (void) strcpy(p, "v");
X	when PAGE     : (void) strcpy(p, "p");
X	when INC      : (void) strcpy(p, "i");
X	when INC_HDR  : (void) strcpy(p, "H");
X	when ALL_HDR  : (void) strcpy(p, "h");
X	when SUBJECT  : (void) strcpy(p, "s");
X	when TO_LIST  : (void) strcpy(p, "t");
X	when CC_LIST  : (void) strcpy(p, "c");
X	when BC_LIST  : (void) strcpy(p, "b");
X	when FWD_MSG  : (void) strcpy(p, "f");
X	when SIGN_IT  : (void) strcpy(p, "S");
X	when NO_SIGN  : (void) strcpy(p, "S!");
X	when FORT     : (void) strcpy(p, "F");
X	when NO_FORT  : (void) strcpy(p, "F!");
X	when ERASE    : (void) strcpy(p, "E");
X	when ABORT    : (void) strcpy(p, "q");
X	when SEND     : finish_up_letter(); return;
X	otherwise     : (void) strcpy(p, "?");
X    }
X    add_to_letter(buf);
X}
END_OF_FILE
if test 3334 -ne `wc -c <'edit_menu.c'`; then
    echo shar: \"'edit_menu.c'\" unpacked with wrong size!
fi
# end of 'edit_menu.c'
fi
if test -f 'envelope.pr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'envelope.pr'\"
else
echo shar: Extracting \"'envelope.pr'\" \(247 characters\)
sed "s/^X//" >'envelope.pr' <<'END_OF_FILE'
X/* "@(#)envelope.cursor	2.2	9/3/86 (Dan Heller)"; */
X
X/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,0x0000,0xFFFF,0xC003,0xA005,0x9009,0x8811,0x8421,
X	0x8241,0x8181,0x8001,0x8001,0x8001,0xFFFF,0x0000,0x0000
END_OF_FILE
if test 247 -ne `wc -c <'envelope.pr'`; then
    echo shar: \"'envelope.pr'\" unpacked with wrong size!
fi
# end of 'envelope.pr'
fi
if test -f 'expr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expr.c'\"
else
echo shar: Extracting \"'expr.c'\" \(4054 characters\)
sed "s/^X//" >'expr.c' <<'END_OF_FILE'
X/* @(#)expr.c	2.3	(c) copyright 10/15/86 (Dan Heller) */
X
X#include "mush.h"
X
Xchar *eval_expr();
X
X/* Parse a string (p) to interpret numbers and ranges of numbers (n-m)
X * delimited by whitespace or comma's. Set msg_list bitfields using
X * macros in mush.h.
X * Return the address of the end of whatever we parsed (in case there's
X * more that the calling routine cares to deal with).
X * Finally, remember that user specifies one more than actual message number
X */
Xchar *
Xdo_range(p, list1)
Xregister char *p, *list1;
X{
X    register int num1 = -1, num2 = -1, except = 0;
X    register char *p2;
X    char list2[MAXMSGS_BITS];
X
X    if (!p)
X	return "";
X    while (*p) {
X	if (isdigit(*p) || *p == '$' || *p == '.' || *p == '^') {
X	    if (isdigit(*p)) {
X		char c;
X		p2 = p;
X		skipdigits(0);  /* find the end of the digits */
X		c = *p, *p = 0; /* temporarily plug a null */
X		if (!(num2 = chk_msg(p2))) {
X		    clear_msg_list(list1);
X		    return NULL;
X		}
X		*p = c;
X	    } else if (*p == '$')
X		num2 = msg_cnt;
X	    else if (*p == '.')
X		p++, num2 = current_msg+1;
X	    else if (*p == '^')
X		p++, num2 = 1;
X	    if (except)
X		unset_msg_bit(list1, num2-1);
X	    else
X		set_msg_bit(list1, num2-1);
X	    if (num1 >= 0) {
X		if (num1 > num2) {
X		    print("syntax error: range sequence order reversed.\n");
X		    clear_msg_list(list1);
X		    return NULL;
X		}
X		while (++num1 < num2)
X		    if (except)
X			unset_msg_bit(list1, num1-1);
X		    else
X			set_msg_bit(list1, num1-1);
X		num1 = num2 = -1;
X	    }
X	}
X	/* expressions to evaluate start with a `
X	 * p2 points to first char passed the last char parsed.
X	 */
X	if (*p == '`') {
X	    clear_msg_list(list2);
X	    if (!(p = eval_expr(p, list2))) {
X		clear_msg_list(list1);
X		return NULL;
X	    } else {
X		if (except)
X		    bitput(list2, list1, msg_cnt, &=~) /* MACRO */
X		else
X		    bitput(list2, list1, msg_cnt, |=) /* MACRO */
X	    }
X	}
X	/* NOT operator: `* {5}' (everything except for 5)
X	 * `4-16 {8-10}'  (4 thru 16 except for 8,9,10)
X	 */
X	if (*p == '{' || *p == '}') {
X	    if (*p == '{' && (except || num1 >= 0))
X		break;
X	    if (*p == '}' && !except) {
X		print("syntax error: missing {\n"); /* } */
X		break;
X	    }
X	    except = !except;
X	} else if (*p == '-')
X	    if (num1 >= 0 || !index(" \t{},.*`$", *(p+1)) && !isdigit(*(p+1)))
X		break;
X	    else
X		num1 = num2;
X	else if (*p == ',' || *p == '*') {
X	    if (num1 >= 0)
X		break;
X	    else if (*p == '*') {
X		if (except)
X		    clear_msg_list(list1);
X		else
X		    for (num1 = 0; num1 < msg_cnt; num1++)
X			set_msg_bit(list1, num1);
X		num1 = -1;
X	    }
X	} else if (!index(" \t`", *p))
X	    break;
X	if (*p)
X	    skipspaces(1); /* don't make user type stuff squished together */
X    }
X    if (num1 >= 0 || except) {
X	if (except)
X  /* { */   print("syntax error: unmatched }\n");
X	else
X	    print("syntax error: unfinished range\n");
X	clear_msg_list(list1);
X	return NULL;
X    }
X    return p;
X}
X
X/* evaluate expressions:
X * mail> delete `pick -f root`     deletes all messages from root.
X * mail> save { `pick -s "Re:"` }  save all message that don't have "Re:"
X *				   in the subject header.
X * mail> save `pick -x -s "Re:"`   same
X * args as follows:
X *   p should point to the first ` -- check for it.
X *   on tells whether to turn bits on or off if messages match.
X */
Xchar *
Xeval_expr(p, new_list)
Xregister char *p, new_list[];
X{
X    register char *p2, **argv;
X    int 	  argc;
X    long	  save_flags = glob_flags;
X
X    if (!(p2 = index(++p, '`'))) {
X	print("unmatched backquote (`)\n");
X	return NULL;
X    }
X    *p2 = 0;
X
X    skipspaces(0);
X    if (!*p) {
X	print("Invalid null command\n");
X	return NULL;
X    }
X    turnon(glob_flags, DO_PIPE);
X    /* ignore sigs only because if user interrupts the do_command,
X     * the long jump will corrupt the stack and the program is hosed.
X     * fix is to have layers of jumpbuf's to return to different levels.
X     */
X    turnon(glob_flags, IGN_SIGS);
X    if (*p && (argv = make_command(p, TRPL_NULL, &argc)))
X	(void) do_command(argc, argv, new_list);
X    glob_flags = save_flags;
X    *p2 = '`';
X    return p2+1;
X}
END_OF_FILE
if test 4054 -ne `wc -c <'expr.c'`; then
    echo shar: \"'expr.c'\" unpacked with wrong size!
fi
# end of 'expr.c'
fi
if test -f 'glasses.pr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'glasses.pr'\"
else
echo shar: Extracting \"'glasses.pr'\" \(246 characters\)
sed "s/^X//" >'glasses.pr' <<'END_OF_FILE'
X/* "@(#)glasses.cursor	2.2	9/3/86 (Dan Heller)"; */
X
X/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,0x0000,0x0C06,0x1209,0x1209,0x2211,0x2010,0x4020,
X	0x4020,0x8C40,0xF3C0,0x8C40,0x8C40,0x8C40,0x7380,0x0000
END_OF_FILE
if test 246 -ne `wc -c <'glasses.pr'`; then
    echo shar: \"'glasses.pr'\" unpacked with wrong size!
fi
# end of 'glasses.pr'
fi
if test -f 'hdr_panel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdr_panel.c'\"
else
echo shar: Extracting \"'hdr_panel.c'\" \(4107 characters\)
sed "s/^X//" >'hdr_panel.c' <<'END_OF_FILE'
X/* @(#)hdr_panel.c	(c) copyright	10/18/86 (Dan Heller) */
X
X#include "mush.h"
X
Xmake_hdr_panel(choice_args, button_args)
Xchar **choice_args, **button_args;
X{
X    hdr_panel_sw = panel_create(tool,
X	PANEL_HEIGHT, 30,
X	0);
X    hdr_panel = (Panel)hdr_panel_sw->ts_data;
X
X    msg_num_item = panel_create_item(hdr_panel, PANEL_TEXT,
X	PANEL_ATTRIBUTE_LIST,		choice_args,
X	PANEL_ITEM_X,			4,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_STRING,		"Range:",
X	PANEL_MENU_CHOICE_STRINGS, 	"Help", 0,
X	PANEL_VALUE_DISPLAY_LENGTH, 	10,
X	PANEL_VALUE_STORED_LENGTH, 	80,
X	PANEL_LABEL_FONT, 		fonts[DEFAULT],
X	PANEL_NOTIFY_STRING, 		"\n\r",
X	PANEL_NOTIFY_PROC, 		msg_num_done,
X	0);
X
X    sub_hdr_item[0] = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			149,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,    		&mouse_left,
X	PANEL_CHOICE_STRINGS, 		"Help", 0,
X	PANEL_NOTIFY_PROC,    		read_mail,
X	0);
X    sub_hdr_item[1] = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			174,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_STRING,   		"Read ",
X	PANEL_MENU_TITLE_IMAGE, 	&mouse_left,
X	PANEL_CHOICE_STRINGS,		"Help", 0,
X	PANEL_NOTIFY_PROC,    		read_mail,
X	0);
X    sub_hdr_item[2] = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			223,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,    		&mouse_middle,
X	PANEL_CHOICE_STRINGS, 		"Help", 0,
X	PANEL_NOTIFY_PROC,    		delete_mail,
X	0);
X    sub_hdr_item[3] = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			248,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_STRING,   		"Delete ",
X	PANEL_MENU_TITLE_IMAGE, 	&mouse_middle,
X	PANEL_CHOICE_STRINGS, 		"Help", 0,
X	PANEL_NOTIFY_PROC,    		delete_mail,
X	0);
X    sub_hdr_item[4] = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			313,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,    		&mouse_right,
X	PANEL_CHOICE_STRINGS, 		"Help", 0,
X	PANEL_NOTIFY_PROC,    		read_mail,
X	0);
X    sub_hdr_item[5] = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			338,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_STRING,   		"Menu ",
X	PANEL_MENU_TITLE_IMAGE,	    	&mouse_right,
X	PANEL_CHOICE_STRINGS, 		"Help", 0,
X	PANEL_NOTIFY_PROC,    		read_mail,
X	0);
X
X    hdr_display = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			387,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,
X	    panel_button_image(hdr_panel, "Display", 7, fonts[DEFAULT]),
X	PANEL_MENU_TITLE_STRING, 	"Header Display Formats",
X	PANEL_CHOICE_STRINGS, 		"Show Deleted Messages",
X					"Don't Show Deleted Messages",
X					"Current Header in Bold Text",
X					"Current Header in Reverse Text",
X					"Help",
X					0,
X	PANEL_NOTIFY_PROC, 		display_hdrs,
X	0);
X
X    ignore_item = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, choice_args,
X	PANEL_ITEM_X,			464,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,
X	    panel_button_image(hdr_panel, "Headers", 7, fonts[DEFAULT]),
X	PANEL_MENU_TITLE_STRING, 	"Ignored Headers",
X	PANEL_CHOICE_STRINGS, 		"Current Settings",
X					"Add Values",
X					"Delete Values",
X					"Help",
X					0,
X	PANEL_NOTIFY_PROC, 		p_set_opts,
X	0);
X
X    next_scr = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			541,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,
X	    panel_button_image(hdr_panel, "Next", 4, fonts[DEFAULT]),
X	PANEL_MENU_TITLE_STRING, 	"Display Message Headers",
X	PANEL_CHOICE_STRINGS, 		"Show Next screenful",
X					"Show Previous screenful",
X					0,
X	PANEL_SHOW_ITEM, 		FALSE,
X	PANEL_NOTIFY_PROC,		do_hdr,
X	0);
X
X    prev_scr = panel_create_item(hdr_panel, PANEL_CHOICE,
X	PANEL_ATTRIBUTE_LIST, 		choice_args,
X	PANEL_ITEM_X,			594,
X	PANEL_ITEM_Y,			4,
X	PANEL_LABEL_IMAGE,
X	    panel_button_image(hdr_panel, "Prev", 4, fonts[DEFAULT]),
X	PANEL_MENU_TITLE_STRING, 	"Display Message Headers",
X	PANEL_CHOICE_STRINGS, 		"Show Previous screenful",
X					"Show Next screenful",
X					0,
X	PANEL_SHOW_ITEM, 		FALSE,
X	PANEL_NOTIFY_PROC, 		do_hdr,
X	0);
X}
END_OF_FILE
if test 4107 -ne `wc -c <'hdr_panel.c'`; then
    echo shar: \"'hdr_panel.c'\" unpacked with wrong size!
fi
# end of 'hdr_panel.c'
fi
if test -f 'hdr_procs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdr_procs.c'\"
else
echo shar: Extracting \"'hdr_procs.c'\" \(3944 characters\)
sed "s/^X//" >'hdr_procs.c' <<'END_OF_FILE'
X/* @(#)hdr_procs.c	(c) copyright	10/18/86 (Dan Heller) */
X
X/* hdr_procs.c  -- panel item procedures for the message hdrs */
X#include "mush.h"
X
X/* which message headers are to be displayed */
Xdo_hdr(foo, value, event)
XPanel_item foo;
Xint value;
Xstruct inputevent *event;
X{
X    register char *argv[3];
X    argv[2] = NULL;
X    argv[0] = "headers";
X
X    if (!msg_cnt) {
X	print("No Mail.");
X	return;
X    }
X    if (!value || event->ie_code == MS_LEFT)
X	argv[1] = (foo == next_scr)? "+": "-";
X    else
X	argv[1] = (foo == next_scr)? "-": "+";
X
X    panel_set(foo, PANEL_VALUE, 0, 0);
X    (void) do_hdrs(2, argv, NULL);
X}
X
X/* alters display of the message headers */
Xdisplay_hdrs(foo, value, event)
XPanel_item foo;
Xint value;
Xstruct inputevent *event;
X{
X    int show_deleted = !!do_set(set_options, "show_deleted");
X
X    if (event->ie_code != MS_LEFT) {
X	switch(value) {
X	    case 0 : case 1: {
X		char buf[25];
X		show_deleted = !value;
X		(void) cmd_line(sprintf(buf, "%sset show_deleted",
X			(value == 0)? "" : "un"), msg_list);
X	    }
X	    when 2 :
X		turnoff(glob_flags, REV_VIDEO);
X	    when 3 :
X		turnon(glob_flags, REV_VIDEO);
X	    when 4:
X		return help(hdr_panel_sw->ts_windowfd, "headers", tool_help);
X	}
X	(void) do_hdrs(0, DUBL_NULL, NULL);
X    }
X    print("%sShow Deleted headers, \"Current Message\" header in %s",
X			(show_deleted)? NO_STRING: "Don't ",
X			(ison(glob_flags, REV_VIDEO))? "reverse": "boldface");
X}
X
Xp_set_opts(item, value, event)
XPanel_item item;
Xint value;
Xstruct inputevent *event;
X{
X    static char   *p, *oldp;
X    static char   buf[8];
X
X    if (event->ie_code == MS_LEFT)
X	value = 0;
X    if (value && (value != 3 || value != 2)
X	      && panel_get(input_item, PANEL_SHOW_ITEM)) {
X	print("Need value for %s first!", oldp);
X	return;
X    } else if (!value && ison(glob_flags, IS_GETTING)) {
X	print("Finish editing letter first");
X	return;
X    } else if (item == option_item) {
X	if (!value) /* first menu item */
X	    view_options();
X	else if (value == 1)
X	    set_fkeys();
X	else
X	    (void) help(panel_sw->ts_windowfd, "opts", tool_help);
X	return;
X    } else if (item == ignore_item)
X	if (value == 3)
X	    return help(hdr_panel_sw->ts_windowfd, "ignore", tool_help);
X	else
X	    oldp = p = strcpy(buf, "ignore");
X    else if (item == alias_item)
X	if (value == 3)
X	    return help(panel_sw->ts_windowfd, "aliases", tool_help);
X	else
X	    oldp = p = strcpy(buf, "alias");
X    if (value) {
X	char tmp[30];
X	(void) sprintf(tmp, "%set %s:", (value == 1)? "S": "Uns", p);
X	panel_set(input_item,
X	    PANEL_LABEL_STRING, tmp,
X	    PANEL_MENU_CHOICE_STRINGS, "Abort", 0,
X	    PANEL_SHOW_ITEM, TRUE,
X	    0);
X	oldp = p;
X	return;
X    }
X    panel_set(item, PANEL_VALUE, 0, 0);
X    do_clear();
X    pw_text(msg_win, l_width(DEFAULT), 15, PIX_SRC, fonts[LARGE], p);
X    if (item != ignore_item)
X	pw_text(msg_win, 30*l_width(DEFAULT),15,PIX_SRC,fonts[LARGE],"Values");
X    (void) cmd_line(p, msg_list);
X}
X
Xmsg_num_done(item, event)
XPanel_item item;
Xstruct inputevent *event;
X{
X    char buf[82];
X    register char *p;
X    int n;
X
X    if (event->ie_code != '\n' && event->ie_code != '\r')
X	return help(hdr_panel_sw->ts_windowfd, "message range", tool_help);
X    (void) sprintf(buf, "headers %s", (p = (char *)panel_get_value(item)));
X    panel_set(item, PANEL_VALUE, NO_STRING, 0);
X    if (!(n = chk_msg(p)))
X	return;
X    current_msg = --n;
X    (void) cmd_line(buf, msg_list);
X    display_msg(n, (long)0);
X}
X
Xdo_sort(item, value, event)
XPanel_item item;
Xint value;
Xstruct inputevent *event;
X{
X    register char *argv[3];
X    argv[0] = "sort";
X    argv[2] = NULL;
X    if (event->ie_code == MS_LEFT)
X	argv[1] = do_set(set_options, "sort");
X    else switch(value) {
X	case 0: argv[1] = "d";
X	when 1: argv[1] = "a";
X	when 2: argv[1] = "s";
X	when 3: argv[1] = "S";
X	when 4: argv[1] = "R";
X	when 5: argv[1] = "-?";
X    }
X    (void) sort(2, argv, NULL);
X    if (value != 5)
X	(void) do_hdrs(0, DUBL_NULL, NULL);
X    panel_set(item, PANEL_VALUE, 0, 0);
X}
END_OF_FILE
if test 3944 -ne `wc -c <'hdr_procs.c'`; then
    echo shar: \"'hdr_procs.c'\" unpacked with wrong size!
fi
# end of 'hdr_procs.c'
fi
if test -f 'mail.icon.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail.icon.1'\"
else
echo shar: Extracting \"'mail.icon.1'\" \(1933 characters\)
sed "s/^X//" >'mail.icon.1' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8000,0x0000,0x0000,0x0001,
X	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
X	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
X	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x0000,0x0001,
X	0x8000,0x0000,0x0000,0x0001,0x8000,0x1FFF,0xFFFF,0xFE01,
X	0x8000,0xFE00,0x0000,0x0181,0x8007,0x01C0,0x0000,0x0061,
X	0x8018,0x0030,0x0000,0x0011,0x8020,0x7008,0x0000,0x0011,
X	0x80C1,0xFC06,0x0000,0x0009,0x8101,0xFC01,0x0000,0x0009,
X	0x8103,0xFE01,0x0000,0x0005,0x8203,0xFE00,0x8000,0x0005,
X	0x8403,0xFE00,0x4000,0x0005,0x8401,0xFC00,0x4000,0x0005,
X	0x8801,0xFC00,0x2000,0x0005,0x8800,0x7000,0x2000,0x0005,
X	0x8800,0x0000,0x3000,0x0005,0x9000,0x0000,0x1000,0x0005,
X	0x9000,0x0000,0x1000,0x0005,0x93FF,0xFFFF,0x9000,0x0025,
X	0xA200,0x0000,0x9000,0x00E5,0xA200,0x0000,0x9000,0x03A5,
X	0xA200,0x0000,0x9000,0x0625,0xA3FF,0xFFFF,0x9000,0x1C25,
X	0xA000,0x0000,0x1000,0x3425,0xA000,0x0000,0x1000,0xC425,
X	0xA000,0x0000,0x1003,0x8425,0xA000,0x0000,0x1006,0x0425,
X	0xA000,0x0000,0x101C,0x0425,0xA000,0x0000,0x11F0,0x0425,
X	0xA000,0x0000,0x13E0,0x0445,0xA000,0x0000,0x13E0,0x0585,
X	0xA000,0x0000,0x13E0,0x0605,0xA000,0x0000,0x11C0,0x0405,
X	0xA000,0x0000,0x1000,0x000D,0xA000,0x0000,0x1000,0x0011,
X	0xA000,0x0000,0x1000,0x0021,0xA000,0x0000,0x1000,0x00C1,
X	0xA000,0x0000,0x1000,0x0101,0xA000,0x0000,0x1000,0x0601,
X	0xA000,0x0000,0x1000,0x0801,0xA000,0x0000,0x1000,0x3801,
X	0xA000,0x0000,0x1000,0x4801,0xA000,0x0000,0x1000,0x8801,
X	0xA000,0x0000,0x1003,0x0801,0xA000,0x0000,0x1004,0x0801,
X	0xA000,0x0000,0x101C,0x0801,0xA000,0x0000,0x1024,0x0801,
X	0xA000,0x0000,0x1044,0x0801,0xA000,0x0000,0x1184,0x0801,
X	0xA000,0x0000,0x1204,0x0801,0xA000,0x0000,0x1404,0x0801,
X	0xBFFF,0xFFFF,0xF804,0x0801,0x8000,0x0000,0x0004,0x0801,
X	0x8000,0x0000,0x0004,0x0801,0x8000,0x0000,0x0004,0x0801,
X	0x8000,0x0000,0x0004,0x0801,0xFFFF,0xFFFF,0xFFFF,0xFFFF
END_OF_FILE
if test 1933 -ne `wc -c <'mail.icon.1'`; then
    echo shar: \"'mail.icon.1'\" unpacked with wrong size!
fi
# end of 'mail.icon.1'
fi
if test -f 'mail.icon.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail.icon.2'\"
else
echo shar: Extracting \"'mail.icon.2'\" \(1933 characters\)
sed "s/^X//" >'mail.icon.2' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8000,0x0000,0x0000,0x0001,
X	0x8000,0x0000,0x0000,0x0001,0x8000,0x0000,0x00E0,0x0001,
X	0x8000,0x0000,0x00DE,0x0001,0x8000,0x0000,0x00C1,0xE001,
X	0x8000,0x0000,0x00C0,0x1801,0x8000,0x0000,0x00C0,0x0801,
X	0x8000,0x0000,0x00C0,0x0801,0x8000,0x1FFF,0xFFC0,0x0E01,
X	0x8000,0xFE00,0x00C0,0x0981,0x8007,0x01C0,0x00C0,0x0861,
X	0x8018,0x0030,0x00C0,0x0811,0x8020,0x7008,0x00C0,0x0811,
X	0x80C1,0xFC06,0x00C0,0x1809,0x8101,0xBC01,0x00C0,0x6009,
X	0x8103,0x1E01,0x00C1,0x8005,0x8202,0x0E00,0x80C6,0x0005,
X	0x8404,0x0400,0x40D8,0x0005,0x8408,0x0200,0x40E0,0x0005,
X	0x8810,0x0100,0x20C0,0x0005,0x8820,0x6080,0x20C0,0x0005,
X	0x8840,0x4040,0x30C0,0x0005,0x9081,0x3020,0x10C0,0x0005,
X	0x9041,0x9C10,0x10C0,0x0005,0x93E0,0x8A0F,0x90C0,0x0005,
X	0xA210,0x6404,0x90C0,0x0005,0xA208,0x3002,0x90C0,0x0005,
X	0xA204,0x1401,0x90C0,0x0005,0xA3FF,0xFFFF,0x90C0,0x0005,
X	0xA000,0x0000,0x10C0,0x0005,0xA000,0x0000,0x10C0,0x0005,
X	0xA000,0x0000,0x10C0,0x0005,0xA000,0x0000,0x10C0,0x0005,
X	0xA000,0x0000,0x10C0,0x0005,0xA000,0x0000,0x11C0,0x0005,
X	0xA000,0x0000,0x13E0,0x0005,0xA000,0x0000,0x13E0,0x0005,
X	0xA000,0x0000,0x13E0,0x0005,0xA000,0x0000,0x11C0,0x0005,
X	0xA000,0x0000,0x1000,0x000D,0xA000,0x0000,0x1000,0x0011,
X	0xA000,0x0000,0x1000,0x0021,0xA000,0x0000,0x1000,0x00C1,
X	0xA000,0x0000,0x1000,0x0101,0xA000,0x0000,0x1000,0x0601,
X	0xA000,0x0000,0x1000,0x0801,0xA000,0x0000,0x1000,0x3001,
X	0xA000,0x0000,0x1000,0x4001,0xA000,0x0000,0x1000,0x8001,
X	0xA000,0x0000,0x1003,0x8001,0xA000,0x0000,0x1004,0x8001,
X	0xA000,0x0000,0x1018,0x8001,0xA000,0x0000,0x1020,0x8001,
X	0xA000,0x0000,0x1060,0x8001,0xA000,0x0000,0x1180,0x8001,
X	0xA000,0x0000,0x1280,0x8001,0xA000,0x0000,0x1480,0x8001,
X	0xBFFF,0xFFFF,0xFC80,0x8001,0x8000,0x0000,0x0080,0x8001,
X	0x8000,0x0000,0x0080,0x8001,0x8000,0x0000,0x0080,0x8001,
X	0x8000,0x0000,0x0080,0x8001,0xFFFF,0xFFFF,0xFFFF,0xFFFF
END_OF_FILE
if test 1933 -ne `wc -c <'mail.icon.2'`; then
    echo shar: \"'mail.icon.2'\" unpacked with wrong size!
fi
# end of 'mail.icon.2'
fi
if test -f 'makefile.bsd' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.bsd'\"
else
echo shar: Extracting \"'makefile.bsd'\" \(863 characters\)
sed "s/^X//" >'makefile.bsd' <<'END_OF_FILE'
X# makefile.bsd	(c) copyright 1986	(Dan Heller)
X#
XHDRS= mush.h config.h-dist strings.h bindings.h
XSRCS= main.c init.c misc.c mail.c hdrs.c execute.c commands.c print.c \
X      signals.c aliases.c setopts.c msgs.c pick.c sort.c expr.c \
X      folders.c dates.c loop.c help.c viewopts.c curses.c curs_io.c bind.c
XOBJS= main.o init.o misc.o mail.o hdrs.o execute.o commands.o print.o \
X      signals.o aliases.o setopts.o msgs.o pick.o sort.o expr.o \
X      folders.o dates.o loop.o help.o viewopts.o curses.o curs_io.o bind.o
XHELP_FILES= README cmd_help mush.1
X
XCFLAGS= -O -DCURSES -DBSD
XLDFLAGS= -s
XLINTFLAGS= -bxah -Dlint -DCURSES -DBSD
XLIBES= -lcurses -ltermlib
X
Xmush: $(OBJS)
X	@echo loading...
X	@cc $(LDFLAGS) $(OBJS) $(LIBES) -o mush
X
Xtar:
X	@tar fcv MUSH $(HDRS) $(SRCS) makefile.bsd $(HELP_FILES)
X
Xlint:
X	lint $(LINTFLAGS) $(SRCS)
X
Xclean:
X	rm -f *.o core mush
END_OF_FILE
if test 863 -ne `wc -c <'makefile.bsd'`; then
    echo shar: \"'makefile.bsd'\" unpacked with wrong size!
fi
# end of 'makefile.bsd'
fi
if test -f 'makefile.sun' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.sun'\"
else
echo shar: Extracting \"'makefile.sun'\" \(1292 characters\)
sed "s/^X//" >'makefile.sun' <<'END_OF_FILE'
X# makefile.sun	(c) copyright 1986	(Dan Heller)
X#
XHDRS= mush.h config.h-dist strings.h bindings.h
X
XSRCS= main.c init.c misc.c mail.c hdrs.c execute.c commands.c rite.c \
X      select.c doproc.c print.c signals.c aliases.c setopts.c msgs.c \
X      hdr_procs.c tool.c hdr_panel.c main_panel.c help.c viewopts.c sort.c \
X      pick.c fkeys.c expr.c folders.c dates.c loop.c edit_menu.c \
X      curses.c curs_io.c bind.c
X
XOBJS= main.o init.o misc.o mail.o hdrs.o execute.o commands.o rite.o \
X      select.o doproc.o print.o signals.o aliases.o setopts.o msgs.o \
X      hdr_procs.o tool.o hdr_panel.o main_panel.o help.o viewopts.o sort.o \
X      pick.o fkeys.o expr.o folders.o dates.o loop.o edit_menu.o \
X      curses.o curs_io.o bind.o
X
XIMAGES= mail.icon.1 mail.icon.2 check.pr cycle.pr envelope.pr glasses.pr \
X	write.pr up.arrow.pr dn.arrow.pr coffee.cup.pr
X
XHELP_FILES= README cmd_help tool_help mush.1
X
XMAKES= makefile.sun makefile.bsd makefile.sys.v
X
XCFLAGS= -O -DSUNTOOL -DCURSES -DBSD
XLDFLAGS= -s
XLIBES= -lcurses -ltermlib -lsuntool -lsunwindow -lpixrect
XLINTFLAGS= -bxah -Dlint
X
Xmush: $(OBJS)
X	@echo loading...
X	@cc $(LDFLAGS) $(OBJS) $(LIBES) -o mush
X
Xtar:
X	@tar fcv MUSH $(HDRS) $(SRCS) $(IMAGES) $(HELP_FILES) $(MAKES)
X
Xlint:
X	make -f makefile.bsd lint
X
Xclean:
X	rm -f *.o core mush
END_OF_FILE
if test 1292 -ne `wc -c <'makefile.sun'`; then
    echo shar: \"'makefile.sun'\" unpacked with wrong size!
fi
# end of 'makefile.sun'
fi
if test -f 'makefile.sys.v' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.sys.v'\"
else
echo shar: Extracting \"'makefile.sys.v'\" \(1162 characters\)
sed "s/^X//" >'makefile.sys.v' <<'END_OF_FILE'
XHDRS= mush.h config.h-dist strings.h bindings.h
XSRCS1= main.c init.c misc.c execute.c
XSRCS2= signals.c aliases.c msgs.c pick.c viewopts.c
XSRCS3= sort.c expr.c folders.c dates.c help.c
XSRCS4= loop.c bind.c
XSRCS5= commands.c setopts.c hdrs.c
XSRCS6= mail.c print.c
XSRCS7= curses.c curs_io.c
XOBJS= main.o init.o misc.o mail.o hdrs.o execute.o commands.o print.o \
X      signals.o aliases.o setopts.o msgs.o pick.o sort.o expr.o \
X      folders.o dates.o loop.o help.o viewopts.o bind.o curses.o curs_io.o
XDOCS= README cmd_help mush.1
X
XCFLAGS= -DSYSV -Mle -DCURSES
XLDFLAGS= -X -Mle -lx -F 3000 -lcurses -ltermlib
X
Xmush: $(OBJS)
X	@echo loading...
X	@cc $(LDFLAGS) $(OBJS) -o mush
X
Xmisc.o:	misc.c
X	cc $(CFLAGS) -LARGE -c misc.c
X
Xbind.o:	bind.c
X	cc $(CFLAGS) -LARGE -c bind.c
X
Xshar:
X	shar makefile.sys.v makefile.bsd ${DOCS} ${HDRS} > hdr.shr
X	shar ${SRCS1} > src1.shr
X	shar ${SRCS2} > src2.shr
X	shar ${SRCS3} > src3.shr
X	shar ${SRCS4} > src4.shr
X	shar ${SRCS5} > src5.shr
X	shar ${SRCS6} > src6.shr
X	shar ${SRCS7} > src7.shr
X
Xtar:
X	tar fcv MUSH makefile.sys.v ${HDRS} ${DOCS} ${SRCS1} ${SRCS2} ${SRCS3} \
X	${SRCS4} ${SRCS5} ${SRCS6} ${SRCS7}
X
Xclean:
X	rm -f *.o core mush
END_OF_FILE
if test 1162 -ne `wc -c <'makefile.sys.v'`; then
    echo shar: \"'makefile.sys.v'\" unpacked with wrong size!
fi
# end of 'makefile.sys.v'
fi
if test -f 'print.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'print.c'\"
else
echo shar: Extracting \"'print.c'\" \(4092 characters\)
sed "s/^X//" >'print.c' <<'END_OF_FILE'
X/* @(#)print.c	2.4	(c) copyright 10/15/86 (Dan Heller) */
X
X#include "mush.h"
X
X/*ARGSUSED*/
X/*VARARGS1*/
Xvoid
Xerror(fmt, arg1, arg2, arg3, arg4)
Xregister char *fmt;
Xchar *arg1, *arg2, *arg3, *arg4;
X{
X    print(fmt, arg1, arg2, arg3, arg4);
X    print_more(": %s\n", sys_errlist[errno]);
X}
X
X#if defined(SUNTOOL) || defined(CURSES)
X/*
X * print just like printf -- to a window, to curses, or to stdout.  Use vprintf
X * if available.  msgbuf is the buffer used to print into if necessary.
X * If you're running SUN3.2 or higher, the typecast (unsigned char *)msgbuf
X * (where indicated) otherwise, msgbuf is not typecast at all.
X * Also note same casting in wprint().
X */
X/*VARARGS1*/
Xvoid
Xprint(fmt, args)
Xregister char *fmt;
Xchar *args;
X{
X    static char msgbuf[BUFSIZ];
X#ifndef VPRINTF
X    FILE foo;
X#endif VPRINTF
X#ifdef SUNTOOL
X    static int x;
X#endif SUNTOOL
X    char *p; /* same type as struct file _ptr,_buf in stdio.h */
X
X#ifdef CURSES
X    if (iscurses) {
X	if (isoff(glob_flags, CONT_PRNT))
X	    move(LINES-1, 0), refresh();
X	turnoff(glob_flags, CONT_PRNT);
X    } else
X#endif CURSES
X	if (istool < 2) {
X#ifdef VPRINTF
X	    vprintf(fmt, &args), fflush(stdout);
X#else
X	    _doprnt(fmt, &args, stdout), fflush(stdout);
X#endif VPRINTF
X	    return;
X	}
X#ifdef VPRINTF
X    if (fmt)
X	vsprintf(msgbuf, fmt, &args); /* NULL in fmt reprints last msg */
X#else VPRINTF
X    foo._cnt = BUFSIZ;
X    foo._base = foo._ptr = msgbuf; /* may have to be cast(unsigned char *) */
X    foo._flag = _IOWRT+_IOSTRG;
X    if (fmt) {   /* passing NULL (not "") reprints last message */
X	(void) _doprnt(fmt, &args, &foo);
X	*foo._ptr = '\0'; /* plant terminating null character */
X    }
X#endif VPIRNTF
X    p = msgbuf;
X    if (iscurses || istool)
X	while (p = index(p, '\n'))
X	    *p = ' ';
X#ifdef CURSES
X    if (iscurses) {
X	addstr(msgbuf), clrtoeol(), refresh();
X	return;
X    }
X#endif CURSES
X#ifdef SUNTOOL
X    if (isoff(glob_flags, CONT_PRNT))
X	x = 5;
X    turnoff(glob_flags, CONT_PRNT);
X    pw_text(print_win, x,   l_height(LARGE), PIX_SRC, fonts[LARGE], msgbuf);
X    pw_text(print_win, x+1, l_height(LARGE), PIX_SRC|PIX_DST,
X		       fonts[LARGE], msgbuf);
X    x += strlen(msgbuf) * l_width(LARGE);
X    Clrtoeol(print_win, x, l_height(LARGE), LARGE);
X#endif SUNTOOL
X}
X#endif SUNTOOL || CURSES
X
X#ifdef SUNTOOL
X/*VARARGS*/
Xvoid
Xwprint(fmt, args)
Xchar *fmt, *args;
X{
X#ifndef VPRINTF
X    FILE foo;
X#endif VPRINTF
X    char msgbuf[BUFSIZ]; /* we're not getting huge strings */
X
X    if (istool < 2) {
X#ifdef VPRINTF
X	vprintf(fmt, &args);
X#else VPRINTF
X	_doprnt(fmt, &args, stdout);
X#endif VPRINTF
X	fflush(stdout);
X	return;
X    }
X    if (!fmt)
X	return;
X#ifdef VPRINTF
X    vsprintf(msgbuf, fmt, &args); /* NULL in fmt reprints last msg */
X#else VPRINTF
X    foo._cnt = BUFSIZ;
X    foo._base = foo._ptr = msgbuf; /* may have to typecast (unsigned char *) */
X    foo._flag = _IOWRT+_IOSTRG;
X    _doprnt(fmt, &args, &foo); /* format like printf into msgbuf via foo */
X    *foo._ptr = '\0'; /* plant terminating null character */
X#endif VPRINTF
X    Addstr(msgbuf);  /* addstr() will scroll if necessary */
X}
X
X/*
X * scroll the msg_win "lines"
X * if `lines' is negative (backwards scroll) msg_pix can't be NULL
X */
Xvoid
Xscroll_win(lines)
Xregister int lines;
X{
X    register int y = lines * l_height(curfont);
X    if (txt.y + y < msg_rect.r_height)
X	y = 0;  /* temporary */
X    txt.x = 5;
X
X    if (msg_pix) {
X	if (txt.y + y >= msg_pix->pr_size.y - 5)
X	    y = msg_pix->pr_size.y - txt.y;
X	still_more += y; /* let scrolling know where we are */
X	txt.y += y;
X	pw_rop(msg_win, 0, 5,
X	       msg_rect.r_width, crt * l_height(curfont),
X	       PIX_SRC, msg_pix, 0, txt.y - msg_rect.r_height + 3);
X	tool_more(NULL);
X	return;
X    }
X    /* y must be positive (forward scrolling) so we're scrolling typed
X     * text or something like that (~p, ~?, etc...)
X     */
X    pw_copy(msg_win, 0, 0,
X	msg_rect.r_width, msg_rect.r_height - y,
X	PIX_SRC, msg_win, 0, y);
X    pw_writebackground(msg_win, 0, msg_rect.r_height - y,
X	msg_rect.r_width, y, PIX_CLR);
X    txt.y -= y;
X}
X#endif SUNTOOL
X
X#ifdef CURSES
Xclr_bot_line()
X{
X    print("");
X}
X#endif CURSES
END_OF_FILE
if test 4092 -ne `wc -c <'print.c'`; then
    echo shar: \"'print.c'\" unpacked with wrong size!
fi
# end of 'print.c'
fi
if test -f 'strings.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'strings.h'\"
else
echo shar: Extracting \"'strings.h'\" \(473 characters\)
sed "s/^X//" >'strings.h' <<'END_OF_FILE'
X/* @(#)strings.h	(c) copyright 9/3/86 (Dan Heller) */
X
X/* External function definitions for routines described in string(3).  */
Xchar	*strcat(), *strncat(), *strcpy(), *strncpy();
Xint	strcmp(), strncmp(), strlen();
X
X#ifdef SYSV
X#define sprintf Sprintf
X#define	index	strchr
X#define	rindex	strrchr
X#endif /* SYSV */
X
Xchar 
X    *sprintf(),		/* Sprintf for sysv -- see end of misc.c */
X    *any(), 		/* return first char in str2 that exists in str1 */
X    *index(), *rindex();
END_OF_FILE
if test 473 -ne `wc -c <'strings.h'`; then
    echo shar: \"'strings.h'\" unpacked with wrong size!
fi
# end of 'strings.h'
fi
if test -f 'tool.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tool.c'\"
else
echo shar: Extracting \"'tool.c'\" \(4280 characters\)
sed "s/^X//" >'tool.c' <<'END_OF_FILE'
X/* @(#)tool.c	(c) copyright	10/15/86 (Dan Heller) */
X
X/* tool.c --make the mailtool windows, panels, etc... */
X#include "mush.h"
X
Xmake_tool(argc, argv)
Xchar **argv;
X{
X    struct stat rootbuf, tmpbuf;
X    struct inputmask im;
X    register unsigned i;
X    char **args = DUBL_NULL, **choice_args, **button_args, *p;
X    char buf1[WIN_NAMESIZE], buf2[WIN_NAMESIZE];
X
X    getfonts();
X    mail_icon.ic_font = fonts[DEFAULT];
X
X    if (p = do_set(set_options, "screen_win"))
X	screen = atoi(p);
X    else
X	screen = 6;
X
X    time_out = TIME_OUT;
X    /* where to place text on mail icon -- how many messages there are */
X    rect_construct(&mail_icon.ic_textrect,
X	l_width(DEFAULT), 58-l_height(DEFAULT),
X	3*l_width(DEFAULT), l_height(DEFAULT));
X
X    tool_parse_all(&argc, argv, &args, prog_name);
X
X    if (!(tool = tool_make(
X	WIN_ICON, 		&mail_icon,
X	WIN_HEIGHT, 		700,
X	WIN_WIDTH, 		650,
X	WIN_BOUNDARY_MGR, 	1,
X	WIN_ATTR_LIST, 		args,
X	NULL)))
X	perror(prog_name), cleanup(0);
X    tool_free_attribute_list(args);
X
X    choice_args = panel_make_list(
X	PANEL_MENU_TITLE_FONT, fonts[LARGE],
X	PANEL_DISPLAY_LEVEL, PANEL_NONE,
X	PANEL_SHOW_MENU, TRUE,
X	PANEL_SHOW_MENU_MARK, FALSE,
X	0);
X
X    button_args = panel_make_list(
X	PANEL_FEEDBACK, PANEL_INVERTED,
X	PANEL_SHOW_MENU, FALSE,
X	0);
X
X    make_hdr_panel(choice_args, button_args);
X
X    if (!(hdr_sw = gfxsw_createtoolsubwindow(tool, "hdr_sw",
X	TOOL_SWEXTENDTOEDGE, 10+ screen*l_height(DEFAULT), (char **)0)))
X	perror("hdr_sw"), cleanup(0);
X    gfxsw_getretained((struct gfxsubwindow *)hdr_sw->ts_data);
X    hdr_win = ((struct gfxsubwindow *)(hdr_sw->ts_data))->gfx_pixwin;
X
X    input_imnull(&im);
X    win_setinputcodebit(&im, LOC_STILL);
X    win_setinputcodebit(&im, LOC_MOVE);
X    win_setinputcodebit(&im, LOC_WINENTER);
X    for (i = VKEY_FIRSTFUNC; i <= VKEY_LASTFUNC; i++)
X	win_setinputcodebit(&im, i);
X    win_setinputmask(hdr_sw->ts_windowfd, &im, &im,
X				   win_fdtonumber(hdr_panel_sw->ts_windowfd)); 
X    hdr_sw->ts_io.tio_selected = hdr_io;
X    hdr_sw->ts_io.tio_handlesigwinch = hdrwin_handlesigwinch;
X
X    make_main_panel(choice_args, button_args);
X    xfree(choice_args), xfree(button_args);
X
X    if (!(print_sw = gfxsw_createtoolsubwindow(tool, "print_sw",
X	TOOL_SWEXTENDTOEDGE, l_height(LARGE) + 10, (char **)0)))
X	perror("print_sw"), cleanup(0);
X    print_win = ((struct gfxsubwindow *)(print_sw->ts_data))->gfx_pixwin;
X    print_sw->ts_io.tio_handlesigwinch = print_sigwinch;
X
X    /* text subwindow */
X    if (!(msg_sw = gfxsw_createtoolsubwindow(tool, "msg_sw",
X	TOOL_SWEXTENDTOEDGE, TOOL_SWEXTENDTOEDGE, (char **)0)))
X	perror("msg_sw"), cleanup(0);
X    gfxsw_getretained((struct gfxsubwindow *)msg_sw->ts_data);
X    msg_win = ((struct gfxsubwindow *)(msg_sw->ts_data))->gfx_pixwin;
X
X    /* everything we want the text window to pay attention to */
X    input_imnull(&im);
X    im.im_flags = IM_ASCII;
X    im.im_flags &= ~IM_ANSI;
X    for (i = VKEY_FIRSTFUNC; i <= VKEY_LASTFUNC; i++)
X	win_setinputcodebit(&im, i);
X    win_setinputmask(msg_sw->ts_windowfd, &im, &im, WIN_NULLLINK);
X    msg_sw->ts_io.tio_selected = msg_io;
X    msg_sw->ts_io.tio_handlesigwinch = msgwin_handlesigwinch;
X
X    /* tty subwindow */
X    if (!(tty_sw = ttytlsw_createtoolsubwindow(tool, "tty_sw",
X	TOOL_SWEXTENDTOEDGE, 0, (char **)0)))
X	perror("tty_sw"), cleanup(0);
X    ttysw_handlesigwinch(tty_sw);
X    win_setcursor(tty_sw->ts_windowfd, &write_cursor);
X
X    (void) sprintf(blank, "%128c", ' ');
X    (void) signal(SIGWINCH, sigwinchcatcher);
X    (void) signal(SIGTERM, sigtermcatcher);
X    (void) signal(SIGCHLD, sigchldcatcher);
X    pw_writebackground(hdr_win, 0,0, hdr_rect.r_width, hdr_rect.r_height,
X		       PIX_CLR);
X    if (ioctl(0, TIOCGETC, &tchars))
X	perror("gtty failed"), cleanup(0);
X    win_numbertoname (0, buf1);
X    if ((rootfd = open(buf1, 0)) == -1)
X	error("can't open %s", buf1), cleanup(0);
X    if (fstat(rootfd, &rootbuf))
X	error("can't stat %s", buf1), cleanup(0);
X    for (parentfd = 3; parentfd < rootfd; parentfd++)
X	if (fstat(parentfd, &tmpbuf))
X	    error("Can't stat fd-%d", parentfd);
X	else if (tmpbuf.st_ino == rootbuf.st_ino) {
X	    (void) close(rootfd);
X	    rootfd = parentfd;
X	    break;
X	}
X    istool = 2;
X    (void) do_version();
X    lock_cursors();
X    tool_install(tool);
X    tool_display(tool);
X    do_clear();
X}
END_OF_FILE
if test 4280 -ne `wc -c <'tool.c'`; then
    echo shar: \"'tool.c'\" unpacked with wrong size!
fi
# end of 'tool.c'
fi
if test -f 'up.arrow.pr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'up.arrow.pr'\"
else
echo shar: Extracting \"'up.arrow.pr'\" \(243 characters\)
sed "s/^X//" >'up.arrow.pr' <<'END_OF_FILE'
X/* "@(#)up.arrow.pr	2.2	9/3/86 (Dan Heller)"; */
X
X/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0xFFFF,0x8001,0xA439,0xA425,0xA439,0x9821,0x8181,0x83C1,
X	0x87E1,0x8FF1,0x9FF9,0xBFFD,0xBFFD,0xBFFD,0x8001,0xFFFF
END_OF_FILE
if test 243 -ne `wc -c <'up.arrow.pr'`; then
    echo shar: \"'up.arrow.pr'\" unpacked with wrong size!
fi
# end of 'up.arrow.pr'
fi
if test -f 'write.pr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'write.pr'\"
else
echo shar: Extracting \"'write.pr'\" \(244 characters\)
sed "s/^X//" >'write.pr' <<'END_OF_FILE'
X/* "@(#)write.cursor	2.2	9/3/86 (Dan Heller)"; */
X
X/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0x0018,0x002C,0x0056,0x00A4,0x0148,0x0290,0x0520,0x0A40,
X	0x1080,0x2100,0x4200,0xE400,0xE800,0xF000,0xE000,0x0000
END_OF_FILE
if test 244 -ne `wc -c <'write.pr'`; then
    echo shar: \"'write.pr'\" unpacked with wrong size!
fi
# end of 'write.pr'
fi
echo shar: End of archive 1 \(of 12\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
