Subject:  v11i043:  Inline code expander for C, Patch1
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: omepd!mcg
Posting-number: Volume 11, Issue 43
Archive-name: inline/Patch1

[  This is not a shar; you can feed this right into patch.  --r$  ]

System: inline
Patch #: 1
Priority: HIGH
Subject: expression rewriting sometimes generates bogus code
From: mcg@omepd.intel.com

Description:
	Under certain circumstances, typically if() statements lacking
	else clauses but with other following code, either syntactically
	or semantically incorrect code was generated by rewrite().

Fix:	From rn, say "| patch -d DIR", where DIR is your patch source
	directory.  Outside of rn, say "cd DIR; patch <thisarticle".
	If you don't have the patch program, apply the following by hand,
	or get patch.

	If patch indicates that patchlevel is the wrong version, you may need
	to apply one or more previous patches, or the patch may already
	have been applied.  See the patchlevel.h file to find out what has or
	has not been applied.  In any event, don't continue with the patch.


Index: patchlevel.h
Prereq: 0
3c3
< #define PATCHLEVEL 0
---
> #define PATCHLEVEL 1

Index: rewrite.c
Prereq: 1.3
*** rewrite.c.old	Thu Jul 16 10:54:21 1987
--- rewrite.c	Thu Jul 16 10:54:21 1987
***************
*** 1,17 ****
  /*
   * inline code expander - rewrite a procedure into an expression if possible
   *
   * (c) 1986 - copyright 1986, s. mcgeady, all rights reserved
   */
  
! /* $Header: rewrite.c,v 1.3 87/05/12 10:53:05 mcg Rel $ */
  
  #include "inline.h"
  #include "tokens.h"
  
  extern struct token *dostmt();		/* see expand.c */
  extern struct token *doexpr();		/* see expand.c */
  
  
  /*
   * This module takes arbitrary sequences of C statements (assumed to be
--- 1,17 ----
  /*
   * inline code expander - rewrite a procedure into an expression if possible
   *
   * (c) 1986 - copyright 1986, s. mcgeady, all rights reserved
   */
  
! /* $Header: rewrite.c,v 1.4 87/07/16 10:51:50 mcg Rel $ */
  
  #include "inline.h"
  #include "tokens.h"
  
  extern struct token *dostmt();		/* see expand.c */
  extern struct token *doexpr();		/* see expand.c */
  
  
  /*
   * This module takes arbitrary sequences of C statements (assumed to be
***************
*** 131,179 ****
  
  			block.tl_head = skipws(block.tl_tail->t_next);
  			block.tl_tail = dostmt(block.tl_head,0);
  
  			if ((ntok = rewrite(node,&block,0)) < 0) {
  				return(-1);
  			}
  			/* if no tokens added - i.e. empty block */
  			if (ntok == 0) {
  				addtok(expr,newtok(mem,T_NUM,"0"));
  			}
  
  			addtok(expr,newtok(mem,T_COLON,NIL));
  			addtok(expr,newtok(mem,T_WS," "));
  
  			tx = skipws(block.tl_tail->t_next);
! 			if (tx && tx != tl->tl_tail) {
! 				if (tx->t_tok != T_ELSE) {
! 					/* no else - treat rest of block like else */
! 					block.tl_head = tx;
! 					tx = block.tl_tail = tl->tl_tail;
! 					if ((ntok = rewrite(node,&block,0)) < 0) {
! 						return(-1);
! 					}
! 				} else {
! 					block.tl_head = skipws(tx->t_next);
! 					tx = block.tl_tail = dostmt(block.tl_head,0);
! 					if ((ntok = rewrite(node,&block,0)) < 0) {
! 						return(-1);
! 					}
  				}
  			} else {
- 				ntok = 0;
- 			}
- 			/* if no tokens added - i.e. empty block */
- 			if (ntok == 0) {
  				addtok(expr,newtok(mem,T_NUM,"0"));
  			}
- 			ntok = 1;
  			nonempty++;
  			/*FALLTHROUGH*/
  
  		case T_SEMIC:
  			if (ntok == 0) {
  				break;
  			}
  			/* if there was a preceding expression, insert a comma */
  			if (estart && estart->t_tok == T_RPAREN) {
  				instok(estart,tt = newtok(mem,T_COMMA,NIL));
--- 131,168 ----
  
  			block.tl_head = skipws(block.tl_tail->t_next);
  			block.tl_tail = dostmt(block.tl_head,0);
  
  			if ((ntok = rewrite(node,&block,0)) < 0) {
  				return(-1);
  			}
  			/* if no tokens added - i.e. empty block */
  			if (ntok == 0) {
  				addtok(expr,newtok(mem,T_NUM,"0"));
+ 				ntok++;
  			}
  
  			addtok(expr,newtok(mem,T_COLON,NIL));
  			addtok(expr,newtok(mem,T_WS," "));
  
  			tx = skipws(block.tl_tail->t_next);
! 			if (tx && tx != tl->tl_tail && tx->t_tok == T_ELSE) {
! 				block.tl_head = skipws(tx->t_next);
! 				tx = block.tl_tail = dostmt(block.tl_head,0);
! 				if ((ntok = rewrite(node,&block,0)) < 0) {
! 					return(-1);
  				}
  			} else {
  				addtok(expr,newtok(mem,T_NUM,"0"));
+ 				ntok++;
+ 				tx = block.tl_tail->t_next;
  			}
  			nonempty++;
  			/*FALLTHROUGH*/
  
  		case T_SEMIC:
  			if (ntok == 0) {
  				break;
  			}
  			/* if there was a preceding expression, insert a comma */
  			if (estart && estart->t_tok == T_RPAREN) {
  				instok(estart,tt = newtok(mem,T_COMMA,NIL));


-------------------------------------------------------------------------

