Subject:  v11i045:  Jove upgrade kit, Part01/04
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: Jonathan Payne  <jpayne@cs.rochester.edu>
Posting-number: Volume 11, Issue 45
Archive-name: jove.pch/Part01

Jove is a text editor that resembles emacs; it runs on Unix and MS-DOS.
It's smaller than GNU, but bigger than micro-emacs.  The following set of
patches upgrade version 4.6.1.4 to 4.7; the older version is what was
distributed on the 4.3 tape, and published previously in this newsgroup.
			--r$

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 4)."
# Contents:  jove.pch.1
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'jove.pch.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jove.pch.1'\"
else
echo shar: Extracting \"'jove.pch.1'\" \(51694 characters\)
sed "s/^X//" >'jove.pch.1' <<'END_OF_FILE'
Xdiff -c ojove/Makefile jove/Makefile
X*** ojove/Makefile	Thu Jul 16 09:14:01 1987
X--- jove/Makefile	Fri Jun 19 16:13:05 1987
X***************
X*** 19,44 ****
X  
X  DESTDIR =
X  TMPDIR = /tmp
X! LIBDIR = /u/jpayne/jovelib
X! BINDIR = /u/jpayne/bin
X! MANDIR = /u/jpayne/manl
X  MANEXT = l
X  SHELL = /bin/csh
X  
X  # These should all just be right if the above ones are.
X  JOVE = $(DESTDIR)$(BINDIR)/jove
X- RECOVER = $(DESTDIR)$(LIBDIR)/recover
X  TEACHJOVE = $(DESTDIR)$(BINDIR)/teachjove
X  JOVERC = $(DESTDIR)$(LIBDIR)/.joverc
X  CMDS.DOC = $(DESTDIR)$(LIBDIR)/cmds.doc
X  TEACH-JOVE = $(DESTDIR)$(LIBDIR)/teach-jove
X- PORTSRV = $(DESTDIR)$(LIBDIR)/portsrv
X  JOVEM = $(DESTDIR)$(MANDIR)/jove.$(MANEXT)
X- RECOVERM = $(DESTDIR)$(MANDIR)/recover.$(MANEXT)
X  TEACHJOVEM = $(DESTDIR)$(MANDIR)/teachjove.$(MANEXT)
X  
X  # Select the right libraries for your system.
X! #	2.9BSD:	LIBS = -ltermcap -ljobs
X  #	v7:	LIBS = -ltermcap
X  #	4.1BSD:	LIBS = -ltermcap -ljobs
X  #	4.2BSD:	LIBS = -ltermcap
X--- 19,43 ----
X  
X  DESTDIR =
X  TMPDIR = /tmp
X! LIBDIR = /nfs/socrates/usr/jpayne/jovelib
X! BINDIR = /nfs/socrates/usr/jpayne/bin
X! MANDIR = /nfs/socrates/usr/jpayne/manl
X  MANEXT = l
X  SHELL = /bin/csh
X  
X  # These should all just be right if the above ones are.
X  JOVE = $(DESTDIR)$(BINDIR)/jove
X  TEACHJOVE = $(DESTDIR)$(BINDIR)/teachjove
X+ RECOVER = $(DESTDIR)$(LIBDIR)/recover
X+ PORTSRV = $(DESTDIR)$(LIBDIR)/portsrv
X  JOVERC = $(DESTDIR)$(LIBDIR)/.joverc
X  CMDS.DOC = $(DESTDIR)$(LIBDIR)/cmds.doc
X  TEACH-JOVE = $(DESTDIR)$(LIBDIR)/teach-jove
X  JOVEM = $(DESTDIR)$(MANDIR)/jove.$(MANEXT)
X  TEACHJOVEM = $(DESTDIR)$(MANDIR)/teachjove.$(MANEXT)
X  
X  # Select the right libraries for your system.
X! #	2.10BSD:LIBS = -ltermcap
X  #	v7:	LIBS = -ltermcap
X  #	4.1BSD:	LIBS = -ltermcap -ljobs
X  #	4.2BSD:	LIBS = -ltermcap
X***************
X*** 49,71 ****
X  
X  # If you are not VMUNIX (vax running Berkeley Version 4), you must specify
X  # the -i flags (split I/D space) and maybe the -x option (for adb to work).
X! #	2.9BSD:	LDFLAGS = -x -i
X! #	v7:	LDFLAGS = -x -i
X  #	4.1BSD:	LDFLAGS =
X  #	4.2BSD:	LDFLAGS =
X  #	4.3BSD:	LDFLAGS =
X  #	SysV Rel. 2: LDFLAGS = -Ml
X  
X! LDFLAGS =
X  
X! CFLAGS = -O
X  
X! OBJECTS = keymaps.o funcdefs.o abbrev.o ask.o buf.o c.o case.o ctype.o \
X! 	delete.o disp.o extend.o fp.o fmt.o insert.o io.o iproc.o jove.o macros.o \
X! 	malloc.o marks.o misc.o move.o paragraph.o proc.o re.o re1.o rec.o \
X! 	scandir.o screen.o table.o term.o tune.o util.o vars.o version.o wind.o
X  
X! JOVESRC = funcdefs.c abbrev.c ask.c buf.c c.c case.c ctype.c \
X  	delete.c disp.c extend.c fp.c fmt.c insert.c io.c iproc.c \
X  	jove.c macros.c malloc.c marks.c misc.c move.c paragraph.c \
X  	proc.c re.c re1.c rec.c scandir.c screen.c table.c term.c util.c \
X--- 48,82 ----
X  
X  # If you are not VMUNIX (vax running Berkeley Version 4), you must specify
X  # the -i flags (split I/D space) and maybe the -x option (for adb to work).
X! #	2.10BSD:LDFLAGS =
X! #	v7:	LDFLAGS =
X  #	4.1BSD:	LDFLAGS =
X  #	4.2BSD:	LDFLAGS =
X  #	4.3BSD:	LDFLAGS =
X  #	SysV Rel. 2: LDFLAGS = -Ml
X+ #
X+ # SEPFLAG should be:
X+ #	not on a PDP-11:		SEPFLAG =
X+ #	PDP-11 with separate I&D:	SEPFLAG = -i
X+ #	PDP-11 without separate I&D:	SEPFLAG = -n
X  
X! LDFLAGS = -g
X! SEPFLAG =
X  
X! CFLAGS = -g
X  
X! BASESEG = funcdefs.o keymaps.o argcount.o ask.o buf.o ctype.o delete.o \
X! 	  disp.o fmt.o insert.o io.o jove.o malloc.o marks.o misc.o re.o \
X! 	  screen.o table.o tune.o util.o vars.o version.o
X! OVLAY1 = abbrev.o rec.o paragraph.o
X! OVLAY2 = c.o wind.o fp.o move.o
X! OVLAY3 = extend.o macros.o
X! OVLAY4 = iproc.o re1.o
X! OVLAY5 = proc.o scandir.o term.o case.o
X  
X! OBJECTS = $(BASESEG) $(OVLAY1) $(OVLAY2) $(OVLAY3) $(OVLAY4) $(OVLAY5)
X! 
X! JOVESRC = funcdefs.c abbrev.c argcount.c ask.c buf.c c.c case.c ctype.c \
X  	delete.c disp.c extend.c fp.c fmt.c insert.c io.c iproc.c \
X  	jove.c macros.c malloc.c marks.c misc.c move.c paragraph.c \
X  	proc.c re.c re1.c rec.c scandir.c screen.c table.c term.c util.c \
X***************
X*** 76,83 ****
X  HEADERS = ctype.h io.h jove.h re.h rec.h table.h temp.h termcap.h tune.h
X  
X  DOCS =	doc/cmds.doc.nr doc/example.rc doc/jove.1 doc/jove.2 doc/jove.3 \
X! 	doc/jove.4 doc/jove.nr doc/recover.nr doc/system.rc doc/teach-jove \
X! 	doc/teachjove.nr doc/README
X  
X  BACKUPS = $(HEADERS) $(JOVESRC) iproc-pipes.c iproc-ptys.c \
X  	teachjove.c recover.c setmaps.c portsrv.c tune.template \
X--- 87,94 ----
X  HEADERS = ctype.h io.h jove.h re.h rec.h table.h temp.h termcap.h tune.h
X  
X  DOCS =	doc/cmds.doc.nr doc/example.rc doc/jove.1 doc/jove.2 doc/jove.3 \
X! 	doc/jove.4 doc/jove.5 doc/jove.nr doc/system.rc \
X! 	doc/teach-jove doc/teachjove.nr doc/README
X  
X  BACKUPS = $(HEADERS) $(JOVESRC) iproc-pipes.c iproc-ptys.c \
X  	teachjove.c recover.c setmaps.c portsrv.c tune.template \
X***************
X*** 87,93 ****
X  all:	xjove recover teachjove portsrv
X  
X  xjove:	$(OBJECTS)
X! 	$(CC) $(LDFLAGS) -o xjove $(OBJECTS) version.o $(LIBS)
X  	@-size xjove
X  	@-date
X  
X--- 98,104 ----
X  all:	xjove recover teachjove portsrv
X  
X  xjove:	$(OBJECTS)
X! 	$(CC) $(LDFLAGS) -o xjove $(OBJECTS) $(LIBS);
X  	@-size xjove
X  	@-date
X  
X***************
X*** 131,138 ****
X  $(TEACH-JOVE): doc/teach-jove
X  	install -c -m 644 doc/teach-jove $(TEACH-JOVE)
X  
X! doc/cmds.doc:	doc/cmds.doc.nr doc/jove.4
X! 	nroff doc/cmds.doc.nr doc/jove.4 > doc/cmds.doc
X  
X  $(CMDS.DOC): doc/cmds.doc
X  	install -c -m 644 doc/cmds.doc $(CMDS.DOC)
X--- 142,149 ----
X  $(TEACH-JOVE): doc/teach-jove
X  	install -c -m 644 doc/teach-jove $(TEACH-JOVE)
X  
X! doc/cmds.doc:	doc/cmds.doc.nr doc/jove.4 doc/jove.5
X! 	nroff doc/cmds.doc.nr doc/jove.4 doc/jove.5 > doc/cmds.doc
X  
X  $(CMDS.DOC): doc/cmds.doc
X  	install -c -m 644 doc/cmds.doc $(CMDS.DOC)
X***************
X*** 158,169 ****
X  	     -e 's;SHELL;$(SHELL);' doc/jove.nr > /tmp/jove.nr
X  	install -m 644 /tmp/jove.nr $(JOVEM)
X  
X- $(RECOVERM): doc/recover.nr
X- 	@sed -e 's;TMPDIR;$(TMPDIR);' \
X- 	     -e 's;LIBDIR;$(LIBDIR);' \
X- 	     -e 's;SHELL;$(SHELL);' doc/recover.nr > /tmp/recover.nr
X- 	install -m 644 /tmp/recover.nr $(RECOVERM)
X- 
X  $(TEACHJOVEM): doc/teachjove.nr
X  	@sed -e 's;TMPDIR;$(TMPDIR);' \
X  	     -e 's;LIBDIR;$(LIBDIR);' \
X--- 169,174 ----
X***************
X*** 178,184 ****
X  	@echo Done
X  
X  tags:
X! 	ctags -w $(JOVESRC) $(HEADERS)
X  
X  ciall:
X  	ci $(BACKUPS)
X--- 183,189 ----
X  	@echo Done
X  
X  tags:
X! 	ctags -w $(JOVESRC) $(HEADERS) iproc-ptys.c
X  
X  ciall:
X  	ci $(BACKUPS)
X***************
X*** 189,195 ****
X  jove.shar:
X  	shar $(BACKUPS) > jove.shar
X  
X! backup:
X  	tar cf backup $(BACKUPS)
X  
X  tape-backup:
X--- 194,200 ----
X  jove.shar:
X  	shar $(BACKUPS) > jove.shar
X  
X! backup: $(BACKUPS)
X  	tar cf backup $(BACKUPS)
X  
X  tape-backup:
Xdiff -c ojove/Ovmakefile jove/Ovmakefile
X*** ojove/Ovmakefile	Thu Jul 16 09:14:02 1987
X--- jove/Ovmakefile	Fri Jun 12 11:23:45 1987
X***************
X*** 61,71 ****
X  
X  COFLAGS = -rworking -q
X  
X! BASESEG = funcdefs.o keymaps.o ask.o buf.o ctype.o delete.o disp.o fmt.o fp.o \
X! 	  insert.o io.o jove.o malloc.o macros.o marks.o misc.o move.o re.o \
X! 	  screen.o table.o tune.o util.o vars.o version.o
X! OVLAY1 = abbrev.o rec.o paragraph.o
X! OVLAY2 = c.o wind.o
X  OVLAY3 = extend.o
X  OVLAY4 = iproc.o re1.o
X  OVLAY5 = proc.o scandir.o term.o case.o
X--- 61,71 ----
X  
X  COFLAGS = -rworking -q
X  
X! BASESEG = funcdefs.o keymaps.o argcount.o ask.o buf.o ctype.o delete.o disp.o fmt.o fp.o \
X! 	  insert.o io.o jove.o malloc.o marks.o misc.o move.o re.o \
X! 	  screen.o table.o tune.o util.o version.o
X! OVLAY1 = abbrev.o rec.o paragraph.o macros.o
X! OVLAY2 = c.o wind.o vars.o
X  OVLAY3 = extend.o
X  OVLAY4 = iproc.o re1.o
X  OVLAY5 = proc.o scandir.o term.o case.o
X***************
X*** 72,78 ****
X  
X  OBJECTS = $(BASESEG) $(OVLAY1) $(OVLAY2) $(OVLAY3) $(OVLAY4) $(OVLAY5)
X  
X! C-FILES = funcdefs.c abbrev.c ask.c buf.c c.c case.c ctype.c delete.c disp.c \
X  	extend.c fmt.c fp.c insert.c io.c iproc.c iproc-pipes.c iproc-ptys.c \
X  	jove.c macros.c malloc.c marks.c misc.c move.c paragraph.c proc.c \
X  	re.c re1.c rec.c scandir.c screen.c table.c term.c util.c vars.c version.c \
X--- 72,78 ----
X  
X  OBJECTS = $(BASESEG) $(OVLAY1) $(OVLAY2) $(OVLAY3) $(OVLAY4) $(OVLAY5)
X  
X! C-FILES = funcdefs.c abbrev.c argcount.c ask.c buf.c c.c case.c ctype.c delete.c disp.c \
X  	extend.c fmt.c fp.c insert.c io.c iproc.c iproc-pipes.c iproc-ptys.c \
X  	jove.c macros.c malloc.c marks.c misc.c move.c paragraph.c proc.c \
X  	re.c re1.c rec.c scandir.c screen.c table.c term.c util.c vars.c version.c \
XCommon subdirectories: ojove/RCS and jove/RCS
Xdiff -c ojove/README jove/README
X*** ojove/README	Thu Jul 16 09:14:03 1987
X--- jove/README	Fri Feb  6 11:32:32 1987
X***************
X*** 146,152 ****
X  reads an initialization file in the user's home directory, and "example.rc"
X  is mine.
X  
X! The files "jove.[1234]" in DOC are the official JOVE manual.  I got
X  permission from Richard Stallman to use his manual for the original EMACS,
X  modifying it where necessary for JOVE.  Lots of work was done by Brian
X  Harvey on this manual.
X--- 146,152 ----
X  reads an initialization file in the user's home directory, and "example.rc"
X  is mine.
X  
X! The files "jove.[12345]" in DOC are the official JOVE manual.  I got
X  permission from Richard Stallman to use his manual for the original EMACS,
X  modifying it where necessary for JOVE.  Lots of work was done by Brian
X  Harvey on this manual.
Xdiff -c ojove/abbrev.c jove/abbrev.c
X*** ojove/abbrev.c	Thu Jul 16 09:14:04 1987
X--- jove/abbrev.c	Fri Jun 12 10:50:08 1987
X***************
X*** 102,110 ****
X  	struct abbrev	*ap;
X  
X  	DOTsave(&point);
X- 	exp = 1;
X      WITH_TABLE(curbuf->b_major)
X! 	BackWord();
X  	while (curchar < point.p_char && ismword(c = linebuf[curchar])) {
X  		if (AutoCaseAbbrev) {
X  			if (isupper(c)) {
X--- 102,109 ----
X  	struct abbrev	*ap;
X  
X  	DOTsave(&point);
X      WITH_TABLE(curbuf->b_major)
X! 	b_word(1);
X  	while (curchar < point.p_char && ismword(c = linebuf[curchar])) {
X  		if (AutoCaseAbbrev) {
X  			if (isupper(c)) {
X***************
X*** 112,118 ****
X  				c = tolower(c);
X  			}
X  		}
X- 
X  		*wp++ = c;
X  		curchar++;
X  	}
X--- 111,116 ----
X***************
X*** 124,141 ****
X  		SetDot(&point);
X  		return;
X  	}
X! 	DoTimes(DelPChar(), (wp - wordbuf));
X  
X  	for (cp = ap->a_phrase; c = *cp; ) {
X  		if (AutoCaseAbbrev) {
X! 			Insert(islower(c) && UC_count &&
X! 			       (cp == ap->a_phrase || (UC_count > 1 && (*(cp - 1) == ' '))) ?
X! 				toupper(c) : c);
X! 		}
X! 		else {
X! 			Insert(c);
X! 		}
X! 		cp++;
X  	}
X  
X  	if (ap->a_cmdhook != 0)
X--- 122,137 ----
X  		SetDot(&point);
X  		return;
X  	}
X! 	del_char(BACKWARD, (wp - wordbuf));
X  
X  	for (cp = ap->a_phrase; c = *cp; ) {
X  		if (AutoCaseAbbrev) {
X! 			insert_c(islower(c) && UC_count &&
X! 			       (cp == ap->a_phrase || (UC_count > 1 && (cp[-1] == ' '))) ?
X! 				toupper(c) : c, 1);
X! 		} else
X! 			insert_c(c, 1);
X! 		cp += 1;
X  	}
X  
X  	if (ap->a_cmdhook != 0)
XOnly in jove: argcount.c
Xdiff -c ojove/ask.c jove/ask.c
X*** ojove/ask.c	Thu Jul 16 09:14:06 1987
X--- jove/ask.c	Fri Jul 10 09:25:49 1987
X***************
X*** 15,20 ****
X--- 15,22 ----
X  #	include <sys/stat.h>
X  #endif
X  
X+ int	DoEVexpand = NO;	/* should we expand evironment variables? */
X+ 
X  int	Asking = NO;
X  char	Minibuf[LBSIZE];
X  private Line	*CurAskPtr = 0;	/* points at some line in mini-buffer */
X***************
X*** 57,63 ****
X  	SetBuf(saveb);
X  }
X  
X! static char *
X  real_ask(delim, d_proc, def, prompt)
X  char	*delim,
X  	*def,
X--- 59,106 ----
X  	SetBuf(saveb);
X  }
X  
X! /* look for any substrings of the form $foo in linebuf, and expand
X!    them according to their value in the environment (if possible) -
X!    this munges all over curchar and linebuf without giving it a second
X!    thought (I must be getting lazy in my old age) */
X! private
X! EVexpand()
X! {
X! 	register int	c;
X! 	register char	*lp = linebuf,
X! 			*ep;
X! 	char	varname[128],
X! 		*vp,
X! 		*lp_start;
X! 	Mark	*m = MakeMark(curline, curchar, M_FLOATER);
X! 
X! 	while (c = *lp++) {
X! 		if (c != '$')
X! 			continue;
X! 		lp_start = lp - 1;	/* the $ */
X! 		vp = varname;
X! 		while (c = *lp++) {
X! 			if (!isword(c))
X! 				break;
X! 			*vp++ = c;
X! 		}
X! 		*vp = '\0';
X! 		/* if we find an env. variable with the right
X! 		   name, we insert it in linebuf, and then delete
X! 		   the variable name that we're replacing - and
X!  		   then we continue in case there are others ... */
X! 		if (ep = getenv(varname)) {
X! 			curchar = lp_start - linebuf;
X! 			ins_str(ep, NO);
X! 			del_char(FORWARD, strlen(varname) + 1);
X! 			lp = linebuf + curchar;
X! 		}
X! 	}
X! 	ToMark(m);
X! 	DelMark(m);
X! }
X! 
X! private char *
X  real_ask(delim, d_proc, def, prompt)
X  char	*delim,
X  	*def,
X***************
X*** 72,79 ****
X  	int	abort = 0,
X  		no_typed = 0;
X  	data_obj	*push_cmd = LastCmd;
X! 	int	o_exp = exp,
X! 		o_exp_p = exp_p;
X  
X  	if (InAsk)
X  		complain((char *) 0);
X--- 115,122 ----
X  	int	abort = 0,
X  		no_typed = 0;
X  	data_obj	*push_cmd = LastCmd;
X! 	int	o_a_v = arg_value(),
X! 		o_i_an_a = is_an_arg();
X  
X  	if (InAsk)
X  		complain((char *) 0);
X***************
X*** 95,102 ****
X  		}
X  
X  	for (;;) {
X! 		exp = 1;
X! 		exp_p = NO;
X  		last_cmd = this_cmd;
X  		init_strokes();
X  cont:		s_mess("%s%s", prompt, linebuf);
X--- 138,144 ----
X  		}
X  
X  	for (;;) {
X! 		clr_arg_value();
X  		last_cmd = this_cmd;
X  		init_strokes();
X  cont:		s_mess("%s%s", prompt, linebuf);
X***************
X*** 103,120 ****
X  		Asking = curchar + prompt_len;
X  		c = getch();
X  		if ((c == EOF) || index(delim, c)) {
X  			if (d_proc == 0 || (*d_proc)(c) == 0)
X  				goto cleanup;
X  		} else switch (c) {
X! 		case CTL(G):
X  			message("[Aborted]");
X  			abort++;
X  			goto cleanup;
X  
X! 		case CTL(N):
X! 		case CTL(P):
X  			if (CurAskPtr != 0) {
X! 				int	n = (c == CTL(P) ? -exp : exp);
X  
X  				CurAskPtr = next_line(CurAskPtr, n);
X  				if (CurAskPtr == curbuf->b_first && CurAskPtr->l_next != 0)
X--- 145,164 ----
X  		Asking = curchar + prompt_len;
X  		c = getch();
X  		if ((c == EOF) || index(delim, c)) {
X+ 			if (DoEVexpand)
X+ 				EVexpand();
X  			if (d_proc == 0 || (*d_proc)(c) == 0)
X  				goto cleanup;
X  		} else switch (c) {
X! 		case CTL('G'):
X  			message("[Aborted]");
X  			abort++;
X  			goto cleanup;
X  
X! 		case CTL('N'):
X! 		case CTL('P'):
X  			if (CurAskPtr != 0) {
X! 				int	n = (c == CTL('P') ? -arg_value() : arg_value());
X  
X  				CurAskPtr = next_line(CurAskPtr, n);
X  				if (CurAskPtr == curbuf->b_first && CurAskPtr->l_next != 0)
X***************
X*** 127,133 ****
X  			}
X  			break;
X  
X! 		case CTL(R):
X  			if (def)
X  				ins_str(def, NO);
X  			else
X--- 171,177 ----
X  			}
X  			break;
X  
X! 		case CTL('R'):
X  			if (def)
X  				ins_str(def, NO);
X  			else
X***************
X*** 151,158 ****
X  	pop_env(savejmp);
X  
X  	LastCmd = push_cmd;
X! 	exp_p = o_exp_p;
X! 	exp = o_exp;
X  	no_typed = (linebuf[0] == '\0');
X  	strcpy(Minibuf, linebuf);
X  	SetBuf(saveb);
X--- 195,202 ----
X  	pop_env(savejmp);
X  
X  	LastCmd = push_cmd;
X! 	set_arg_value(o_a_v);
X! 	set_is_an_arg(o_i_an_a);
X  	no_typed = (linebuf[0] == '\0');
X  	strcpy(Minibuf, linebuf);
X  	SetBuf(saveb);
X***************
X*** 212,218 ****
X  	return real_ask(delim, d_proc, def, prompt);
X  }
X  
X! /* VARARGS2 */
X  
X  yes_or_no_p(fmt, va_alist)
X  char	*fmt;
X--- 256,262 ----
X  	return real_ask(delim, d_proc, def, prompt);
X  }
X  
X! /* VARARGS1 */
X  
X  yes_or_no_p(fmt, va_alist)
X  char	*fmt;
X***************
X*** 230,236 ****
X  		Asking = strlen(prompt);	/* so redisplay works */
X  		c = getch();
X  		Asking = NO;
X! 		switch (Upper(c)) {
X  		case 'Y':
X  			return YES;
X  
X--- 274,280 ----
X  		Asking = strlen(prompt);	/* so redisplay works */
X  		c = getch();
X  		Asking = NO;
X! 		switch (CharUpcase(c)) {
X  		case 'Y':
X  			return YES;
X  
X***************
X*** 237,243 ****
X  		case 'N':
X  			return NO;
X  
X! 		case CTL(G):
X  			complain("[Aborted]");
X  
X  		default:
X--- 281,287 ----
X  		case 'N':
X  			return NO;
X  
X! 		case CTL('G'):
X  			complain("[Aborted]");
X  
X  		default:
X***************
X*** 343,353 ****
X  		    (linebuf[curchar - 1] != '/') &&
X  		    (isdir(linebuf)));
X  	if (the_same && !is_ntdir) {
X! 		add_mess(n == 1 ? " [Unique]" : " [Ambiguous]");
X  		SitFor(7);
X  	}
X  	if (is_ntdir)
X! 		Insert('/');
X  }
X  
X  extern int	alphacomp();
X--- 387,397 ----
X  		    (linebuf[curchar - 1] != '/') &&
X  		    (isdir(linebuf)));
X  	if (the_same && !is_ntdir) {
X! 		add_mess((n == 1) ? " [Unique]" : " [Ambiguous]");
X  		SitFor(7);
X  	}
X  	if (is_ntdir)
X! 		insert_c('/', 1);
X  }
X  
X  extern int	alphacomp();
X***************
X*** 438,444 ****
X  {
X  	char	*ans,
X  		prompt[128],
X! 		*pretty_name = pr_name(def);
X  
X  	if (prmt)
X  		sprintf(prompt, prmt);
X--- 482,488 ----
X  {
X  	char	*ans,
X  		prompt[128],
X! 		*pretty_name = pr_name(def, YES);
X  
X  	if (prmt)
X  		sprintf(prompt, prmt);
Xdiff -c ojove/buf.c jove/buf.c
X*** ojove/buf.c	Thu Jul 16 09:14:07 1987
X--- jove/buf.c	Tue Jun 23 13:50:25 1987
X***************
X*** 26,33 ****
X  
X  TogMinor(bit)
X  {
X! 	if (exp_p) {
X! 		if (exp == 0)
X  			curbuf->b_minor &= ~bit;
X  		else
X  			curbuf->b_minor |= bit;
X--- 26,33 ----
X  
X  TogMinor(bit)
X  {
X! 	if (is_an_arg()) {
X! 		if (arg_value() == 0)
X  			curbuf->b_minor &= ~bit;
X  		else
X  			curbuf->b_minor |= bit;
X***************
X*** 147,153 ****
X  	offset = complete(bnames, prompt, RET_STATE);
X  	if (offset == EOF)
X  		complain((char *) 0);
X! 	if (offset == ORIGINAL)
X  		bname = Minibuf;
X  	else if (offset == NULLSTRING) {
X  		if (def)
X--- 147,153 ----
X  	offset = complete(bnames, prompt, RET_STATE);
X  	if (offset == EOF)
X  		complain((char *) 0);
X! 	if (offset == ORIGINAL || offset == AMBIGUOUS)
X  		bname = Minibuf;
X  	else if (offset == NULLSTRING) {
X  		if (def)
X***************
X*** 171,177 ****
X  	SetBuf(do_select(curwind, bname));
X  }
X  
X! static
X  defb_wind(b)
X  register Buffer *b;
X  {
X--- 171,177 ----
X  	SetBuf(do_select(curwind, bname));
X  }
X  
X! private
X  defb_wind(b)
X  register Buffer *b;
X  {
X***************
X*** 186,202 ****
X  
X  	do {
X  		if (w->w_bufp == b) {
X! 			if (one_windp())
X  				(void) do_select(w, alt);
X  			else {
X! 				register Window	*save = w->w_next;
X  
X  				del_wind(w);
X  				w = save->w_prev;
X  			}
X! 		}				
X  		w = w->w_next;
X! 	} while (w != fwind);
X  }
X  
X  Buffer *
X--- 186,202 ----
X  
X  	do {
X  		if (w->w_bufp == b) {
X! 			if (one_windp() || alt != Mainbuf)
X  				(void) do_select(w, alt);
X  			else {
X! 				Window	*save = w->w_next;
X  
X  				del_wind(w);
X  				w = save->w_prev;
X  			}
X! 		}
X  		w = w->w_next;
X! 	} while (w != fwind || w->w_bufp == b);
X  }
X  
X  Buffer *
X***************
X*** 275,281 ****
X  			continue;
X  		if (IsModified(b)) {
X  			y_or_n = ask("No", "%s modified; should I save it? ", b->b_name);
X! 			if (Upper(*y_or_n) == 'Y') {
X  				oldb = curbuf;
X  				SetBuf(b);
X  				SaveFile();
X--- 275,281 ----
X  			continue;
X  		if (IsModified(b)) {
X  			y_or_n = ask("No", "%s modified; should I save it? ", b->b_name);
X! 			if (CharUpcase(*y_or_n) == 'Y') {
X  				oldb = curbuf;
X  				SetBuf(b);
X  				SaveFile();
X***************
X*** 499,505 ****
X  {
X  	struct stat	stbuf;
X  
X! 	if (b->b_fname == 0 || stat(b->b_fname, &stbuf) == -1) {
X  		b->b_ino = 0;
X  		b->b_mtime = 0;
X  	} else {
X--- 499,505 ----
X  {
X  	struct stat	stbuf;
X  
X! 	if (b->b_fname == 0 || stat(pr_name(b->b_fname, NO), &stbuf) == -1) {
X  		b->b_ino = 0;
X  		b->b_mtime = 0;
X  	} else {
X***************
X*** 524,537 ****
X  		bufname(b);
X  		set_ino(b);
X  		b->b_ntbf = 1;
X- 		if (force) {
X- 			Buffer	*oldb = curbuf;
X- 
X- 			SetBuf(b);	/* this'll read the file */
X- 			SetBuf(oldb);
X- 		}
X  	}
X  
X  	if (w)
X  		tiewind(w, b);
X  	return b;
X--- 524,536 ----
X  		bufname(b);
X  		set_ino(b);
X  		b->b_ntbf = 1;
X  	}
X+ 	if (force) {
X+ 		Buffer	*oldb = curbuf;
X  
X+ 		SetBuf(b);	/* this'll read the file */
X+ 		SetBuf(oldb);
X+ 	}
X  	if (w)
X  		tiewind(w, b);
X  	return b;
X***************
X*** 549,563 ****
X  SetBuf(newbuf)
X  register Buffer	*newbuf;
X  {
X! 	register Buffer	*oldb = curbuf;
X  
X  	if (newbuf == curbuf || newbuf == 0)
X  		return;
X  
X  	lsave();
X  	curbuf = newbuf;
X! 	curline = newbuf->b_dot;
X! 	curchar = newbuf->b_char;
X  	getDOT();
X  	/* Do the read now ... */
X  	if (curbuf->b_ntbf)
X--- 548,570 ----
X  SetBuf(newbuf)
X  register Buffer	*newbuf;
X  {
X! 	register Buffer	*oldb = curbuf,
X! 			*b;
X  
X  	if (newbuf == curbuf || newbuf == 0)
X  		return;
X  
X+ 	/* check to see that we're selecting a valid buffer */
X+ 	for (b = world; b != 0; b = b->b_next)
X+ 		if (b == newbuf)
X+ 			break;
X+ 	if (b == 0)
X+ 		complain("Internal error: (%x) is not a valid buffer pointer!", newbuf);
X+ 
X  	lsave();
X  	curbuf = newbuf;
X! /*	curline = newbuf->b_dot;
X! 	curchar = newbuf->b_char;	STUPID!! */
X  	getDOT();
X  	/* Do the read now ... */
X  	if (curbuf->b_ntbf)
Xdiff -c ojove/c.c jove/c.c
X*** ojove/c.c	Thu Jul 16 09:14:09 1987
X--- jove/c.c	Wed Jun 24 12:43:21 1987
X***************
X*** 167,180 ****
X  	register char	c,
X  			syntax = (dir == FORWARD) ? _Op : _Cl;
X  
X- 	exp = 1;
X  	if (dir == BACKWARD)
X! 		BackChar();
X  	c = linebuf[curchar];
X  	for (;;) {
X  		if (!skip_words && ismword(c)) {
X  		    WITH_TABLE(curbuf->b_major)
X! 			(dir == FORWARD) ? ForWord() : BackWord();
X  		    END_TABLE();
X  		    break;
X  		} else if (has_syntax(c, syntax)) {
X--- 167,179 ----
X  	register char	c,
X  			syntax = (dir == FORWARD) ? _Op : _Cl;
X  
X  	if (dir == BACKWARD)
X! 		b_char(1);
X  	c = linebuf[curchar];
X  	for (;;) {
X  		if (!skip_words && ismword(c)) {
X  		    WITH_TABLE(curbuf->b_major)
X! 			(dir == FORWARD) ? f_word(1) : b_word(1);
X  		    END_TABLE();
X  		    break;
X  		} else if (has_syntax(c, syntax)) {
X***************
X*** 181,187 ****
X  			FindMatch(dir);
X  			break;
X  		}
X! 		DoTimes(ForChar(), dir);
X  		if (eobp() || bobp())
X  			return;
X  		c = linebuf[curchar];
X--- 180,186 ----
X  			FindMatch(dir);
X  			break;
X  		}
X! 		f_char(dir);
X  		if (eobp() || bobp())
X  			return;
X  		c = linebuf[curchar];
X***************
X*** 190,199 ****
X  
X  FSexpr()
X  {
X! 	register int	num = exp;
X  
X! 	if (exp < 0) {
X! 		exp = -exp;
X  		BSexpr();
X  	}
X  	while (--num >= 0)
X--- 189,198 ----
X  
X  FSexpr()
X  {
X! 	register int	num = arg_value();
X  
X! 	if (num < 0) {
X! 		set_arg_value(-num);
X  		BSexpr();
X  	}
X  	while (--num >= 0)
X***************
X*** 202,211 ****
X  
X  FList()
X  {
X! 	register int	num = exp;
X  
X! 	if (exp < 0) {
X! 		exp = -exp;
X  		BList();
X  	}
X  	while (--num >= 0)
X--- 201,210 ----
X  
X  FList()
X  {
X! 	register int	num = arg_value();
X  
X! 	if (num < 0) {
X! 		set_arg_value(-num);
X  		BList();
X  	}
X  	while (--num >= 0)
X***************
X*** 214,223 ****
X  
X  BSexpr()
X  {
X! 	register int	num = exp;
X  
X! 	if (exp < 0) {
X! 		exp = -exp;
X  		FSexpr();
X  	}
X  	while (--num >= 0)
X--- 213,222 ----
X  
X  BSexpr()
X  {
X! 	register int	num = arg_value();
X  
X! 	if (num < 0) {
X! 		negate_arg_value();
X  		FSexpr();
X  	}
X  	while (--num >= 0)
X***************
X*** 226,235 ****
X  
X  BList()
X  {
X! 	register int	num = exp;
X  
X! 	if (exp < 0) {
X! 		exp = -exp;
X  		FList();
X  	}
X  	while (--num >= 0)
X--- 225,234 ----
X  
X  BList()
X  {
X! 	register int	num = arg_value();
X  
X! 	if (num < 0) {
X! 		negate_arg_value();
X  		FList();
X  	}
X  	while (--num >= 0)
X***************
X*** 275,284 ****
X  	    (backslashed(linebuf, curchar)))
X  		complain((char *) 0);
X  	if (dir == FORWARD)
X! 		ForChar();
X  	bp = m_paren(c, dir, YES, NO);
X  	if (dir == FORWARD)
X! 		BackChar();
X  	if (bp != 0)
X  		SetDot(bp);
X  	mp_error();	/* if there is an error the user wants to
X--- 274,283 ----
X  	    (backslashed(linebuf, curchar)))
X  		complain((char *) 0);
X  	if (dir == FORWARD)
X! 		f_char(1);
X  	bp = m_paren(c, dir, YES, NO);
X  	if (dir == FORWARD)
X! 		b_char(1);
X  	if (bp != 0)
X  		SetDot(bp);
X  	mp_error();	/* if there is an error the user wants to
X***************
X*** 482,488 ****
X  		SetDot(match_c);
X  	}
X  	SetDot(&open_c_pt);
X! 	open_c_mark = MakeMark(curline, curchar, FLOATER);
X  	indent_pos = calc_pos(linebuf, curchar);
X  	/* search for a close comment; delete it if it exits */
X  	SetDot(&close_c_pt);
X--- 481,487 ----
X  		SetDot(match_c);
X  	}
X  	SetDot(&open_c_pt);
X! 	open_c_mark = MakeMark(curline, curchar, M_FLOATER);
X  	indent_pos = calc_pos(linebuf, curchar);
X  	/* search for a close comment; delete it if it exits */
X  	SetDot(&close_c_pt);
X***************
X*** 489,497 ****
X  	if (close_at_dot == 0) {
X  		slen = strlen(close_pat);
X  		while (slen--)
X! 			DelPChar();
X  	}
X! 	entry_mark = MakeMark(curline, curchar, FLOATER);
X  	ToMark(open_c_mark);
X  	/* always separate the comment body from anything preceeding it */
X  	LineInsert(1);
X--- 488,496 ----
X  	if (close_at_dot == 0) {
X  		slen = strlen(close_pat);
X  		while (slen--)
X! 			del_char(BACKWARD, 1);
X  	}
X! 	entry_mark = MakeMark(curline, curchar, M_FLOATER);
X  	ToMark(open_c_mark);
X  	/* always separate the comment body from anything preceeding it */
X  	LineInsert(1);
X***************
X*** 502,511 ****
X  			if (!eolp())
X  				LineInsert(1);
X  			else
X! 				line_move(FORWARD, NO);
X  		} else if (*cp == ' ' || *cp == '\t') {
X  			if (linebuf[curchar] != *cp)
X! 				Insert(*cp);
X  		} else
X  			/* Since we matched the open comment string on this
X  			   line, we don't need to worry about crossing line
X--- 501,510 ----
X  			if (!eolp())
X  				LineInsert(1);
X  			else
X! 				line_move(FORWARD, 1, NO);
X  		} else if (*cp == ' ' || *cp == '\t') {
X  			if (linebuf[curchar] != *cp)
X! 				insert_c(*cp, 1);
X  		} else
X  			/* Since we matched the open comment string on this
X  			   line, we don't need to worry about crossing line
X***************
X*** 512,518 ****
X  			   boundaries. */
X  			curchar++;
X  	}
X! 	savedot = MakeMark(curline, curchar, FLOATER);
X  
X  	/* We need to strip the line header pattern of leading white space
X  	   since we need to match the line after all of its leading
X--- 511,517 ----
X  			   boundaries. */
X  			curchar++;
X  	}
X! 	savedot = MakeMark(curline, curchar, M_FLOATER);
X  
X  	/* We need to strip the line header pattern of leading white space
X  	   since we need to match the line after all of its leading
X***************
X*** 529,556 ****
X  		Bol();
X  		DelWtSpace();
X  		if (header_len && !strncmp(linebuf, cp, header_len))
X! 			DoTimes(DelNChar(), header_len);
X  		if (trailer_len) {
X  			Eol();
X  			if ((curchar > trailer_len) &&
X  			    (!strncmp(&linebuf[curchar - trailer_len],
X  				      l_trailer, trailer_len)))
X! 				DoTimes(DelPChar(), trailer_len);
X  		}
X  		if (curline->l_next != 0)
X! 			line_move(FORWARD, NO);
X  		else
X  			break;
X  	} while (curline != entry_mark->m_line->l_next);
X  
X! 	DoSetMark(savedot->m_line, savedot->m_char);
X  	ToMark(entry_mark);
X  	saveRMargin = RMargin;
X  	RMargin = saveRMargin - strlen(l_header) -
X  		  strlen(l_trailer) - indent_pos + 2;
X! 	/* do not use the left margin */
X! 	exp_p = NO;
X! 	do_rfill();
X  	RMargin = saveRMargin;
X  	/* get back to the start of the comment */
X  	PopMark(); 
X--- 528,553 ----
X  		Bol();
X  		DelWtSpace();
X  		if (header_len && !strncmp(linebuf, cp, header_len))
X! 			del_char(FORWARD, header_len);
X  		if (trailer_len) {
X  			Eol();
X  			if ((curchar > trailer_len) &&
X  			    (!strncmp(&linebuf[curchar - trailer_len],
X  				      l_trailer, trailer_len)))
X! 				del_char(BACKWARD, trailer_len);
X  		}
X  		if (curline->l_next != 0)
X! 			line_move(FORWARD, 1, NO);
X  		else
X  			break;
X  	} while (curline != entry_mark->m_line->l_next);
X  
X! 	do_set_mark(savedot->m_line, savedot->m_char);
X  	ToMark(entry_mark);
X  	saveRMargin = RMargin;
X  	RMargin = saveRMargin - strlen(l_header) -
X  		  strlen(l_trailer) - indent_pos + 2;
X! 	do_rfill(NO);
X  	RMargin = saveRMargin;
X  	/* get back to the start of the comment */
X  	PopMark(); 
X***************
X*** 567,579 ****
X  		else
X  			ins_str(l_trailer, NO);
X  		if (curline->l_next != 0)
X! 			line_move(FORWARD, NO);
X  		else 
X  			break;
X  	} while (curline != entry_mark->m_line->l_next);
X  	/* handle the close comment symbol */
X  	if (curline == entry_mark->m_line->l_next) {
X! 		line_move(BACKWARD, NO);
X  		Eol();
X  	}
X  	DelWtSpace();
X--- 564,576 ----
X  		else
X  			ins_str(l_trailer, NO);
X  		if (curline->l_next != 0)
X! 			line_move(FORWARD, 1, NO);
X  		else 
X  			break;
X  	} while (curline != entry_mark->m_line->l_next);
X  	/* handle the close comment symbol */
X  	if (curline == entry_mark->m_line->l_next) {
X! 		line_move(BACKWARD, 1, NO);
X  		Eol();
X  	}
X  	DelWtSpace();
X***************
X*** 588,599 ****
X  			LineInsert(1);
X  			n_indent(indent_pos);
X  		} else
X! 			Insert(*cp);
X  	}
X  	ToMark(open_c_mark);
X  	Eol();
X! 	exp_p = NO;
X! 	DelNChar();
X  }
X  
X  #endif CMT_FMT
X--- 585,595 ----
X  			LineInsert(1);
X  			n_indent(indent_pos);
X  		} else
X! 			insert_c(*cp, 1);
X  	}
X  	ToMark(open_c_mark);
X  	Eol();
X! 	del_char(FORWARD, 1);
X  }
X  
X  #endif CMT_FMT
Xdiff -c ojove/case.c jove/case.c
X*** ojove/case.c	Thu Jul 16 09:14:09 1987
X--- jove/case.c	Fri Jun 12 10:45:46 1987
X***************
X*** 16,31 ****
X  
X  	DOTsave(&b);
X  
X! 	if (exp < 0) {
X  		restore++;
X! 		exp = -exp;
X! 		num = exp;
X! 		BackChar();	/* Cap previous EXP chars */
X! 	} else
X! 		num = exp;
X  		
X- 	exp = 1;	/* So all the commands are done once */
X- 
X  	while (num--) {
X  		if (upper(&linebuf[curchar])) {
X  			modify();
X--- 16,28 ----
X  
X  	DOTsave(&b);
X  
X! 	num = arg_value();
X! 	if (num < 0) {
X  		restore++;
X! 		num = -num;
X! 		b_char(num);	/* Cap previous EXP chars */
X! 	}
X  		
X  	while (num--) {
X  		if (upper(&linebuf[curchar])) {
X  			modify();
X***************
X*** 35,42 ****
X  			if (curline->l_next == 0)
X  				break;
X  			SetLine(curline->l_next);
X! 		}
X! 		else
X  			curchar++;
X  	}
X  	if (restore)
X--- 32,38 ----
X  			if (curline->l_next == 0)
X  				break;
X  			SetLine(curline->l_next);
X! 		} else
X  			curchar++;
X  	}
X  	if (restore)
X***************
X*** 51,65 ****
X  
X  	DOTsave(&b);
X  
X! 	if (exp < 0) {
X  		restore++;
X! 		exp = -exp;
X! 		num = exp;
X! 		BackWord();	/* Cap previous EXP words */
X! 	} else
X! 		num = exp;
X! 		
X! 	exp = 1;	/* So all the commands are done once */
X  
X  	while (num--) {
X  		to_word(1);	/* Go to the beginning of the next word. */
X--- 47,58 ----
X  
X  	DOTsave(&b);
X  
X! 	num = arg_value();
X! 	if (num < 0) {
X  		restore++;
X! 		num = -num;
X! 		b_word(num);		/* Cap previous EXP words */
X! 	}
X  
X  	while (num--) {
X  		to_word(1);	/* Go to the beginning of the next word. */
X***************
X*** 87,97 ****
X  	Bufpos	before;
X  
X  	DOTsave(&before);
X! 	ForWord();	/* This'll go backward if negative argument. */
X  	case_reg(before.p_line, before.p_char, curline, curchar, up);
X  }
X  
X! static
X  upper(c)
X  register char	*c;
X  {
X--- 80,90 ----
X  	Bufpos	before;
X  
X  	DOTsave(&before);
X! 	ForWord();	/* this'll go backward if negative argument */
X  	case_reg(before.p_line, before.p_char, curline, curchar, up);
X  }
X  
X! private
X  upper(c)
X  register char	*c;
X  {
X***************
X*** 121,127 ****
X  	(void) fixorder(&line1, &char1, &line2, &char2);
X  	DotTo(line1, char1);
X  
X- 	exp = 1;
X  	for (;;) {
X  		if (curline == line2 && curchar == char2)
X  			break;
X--- 114,119 ----
X***************
X*** 130,136 ****
X  				makedirty(curline);
X  				modify();
X  			}
X! 		ForChar();
X  	}
X  }
X  
X--- 122,128 ----
X  				makedirty(curline);
X  				modify();
X  			}
X! 		f_char(1);
X  	}
X  }
X  
Xdiff -c ojove/ctype.c jove/ctype.c
X*** ojove/ctype.c	Thu Jul 16 09:14:11 1987
X--- jove/ctype.c	Wed Feb  4 11:37:21 1987
X***************
X*** 89,91 ****
X--- 89,111 ----
X  {
X  	return ((CharTable[curbuf->b_major])[c]&(_W));
X  }
X+ 
X+ char CaseEquiv[] = {
X+ 	'\000',	'\001',	'\002',	'\003',	'\004',	'\005',	'\006',	'\007',
X+ 	'\010',	'\011',	'\012',	'\013',	'\014',	'\015',	'\016',	'\017',
X+ 	'\020',	'\021',	'\022',	'\023',	'\024',	'\025',	'\026',	'\027',
X+ 	'\030',	'\031',	'\032',	'\033',	'\034',	'\035',	'\036',	'\037',
X+ 	'\040',	'!',	'"',	'#',	'$',	'%',	'&',	'\'',
X+ 	'(',	')',	'*',	'+',	',',	'-',	'.',	'/',
X+ 	'0',	'1',	'2',	'3',	'4',	'5',	'6',	'7',
X+ 	'8',	'9',	':',	';',	'<',	'=',	'>',	'?',
X+ 	'@',	'A',	'B',	'C',	'D',	'E',	'F',	'G',
X+ 	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
X+ 	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
X+ 	'X',	'Y',	'Z',	'[',	'\\',	']',	'^',	'_',
X+ 	'`',	'A',	'B',	'C',	'D',	'E',	'F',	'G',
X+ 	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
X+ 	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
X+ 	'X',	'Y',	'Z',	'{',	'|',	'}',	'~',	'\177'
X+ };
X+ 
Xdiff -c ojove/delete.c jove/delete.c
X*** ojove/delete.c	Thu Jul 16 09:14:13 1987
X--- jove/delete.c	Wed Jun 24 12:43:21 1987
X***************
X*** 99,105 ****
X  
X  DelNChar()
X  {
X! 	del_char(1);
X  }
X  
X  /* Delete character backward */
X--- 99,105 ----
X  
X  DelNChar()
X  {
X! 	del_char(FORWARD, arg_value());
X  }
X  
X  /* Delete character backward */
X***************
X*** 107,134 ****
X  DelPChar()
X  {
X  	if (MinorMode(OverWrite)) {
X! 		int	count = min(exp, curchar);
X  
X! 		DoTimes(BackChar(), count);
X! 		LastKeyStruck = ' ';	/* can you say gross? */
X! 		DoTimes(SelfInsert(), count);
X! 		DoTimes(BackChar(), count);
X  	} else		
X! 		del_char(0);
X  }
X  
X! /* Delete some characters.  If deleting `forward' then call for_char
X     to the final position otherwise call back_char.  Then delete the
X     region between the two with patchup(). */
X  
X! del_char(forward)
X  {
X  	Bufpos	before,
X  		after;
X! 	int	killp = (exp_p && abs(exp) > 1);
X  
X  	DOTsave(&before);
X! 	(forward) ? ForChar() : BackChar();
X  	if (before.p_line == curline && before.p_char == curchar)
X  		complain((char *) 0);
X  	if (killp)
X--- 107,138 ----
X  DelPChar()
X  {
X  	if (MinorMode(OverWrite)) {
X! 		int	count = min(arg_value(), curchar);
X  
X! 		b_char(count);
X! 
X! 		/* overwrite with spaces */
X! 		set_arg_value(count);
X! 		LastKeyStruck = ' ';
X! 		SelfInsert();
X! 
X! 		b_char(count);
X  	} else		
X! 		del_char(BACKWARD, arg_value());
X  }
X  
X! /* Delete some characters.  If deleting forward then call for_char
X     to the final position otherwise call back_char.  Then delete the
X     region between the two with patchup(). */
X  
X! del_char(dir, num)
X  {
X  	Bufpos	before,
X  		after;
X! 	int	killp = (abs(num) > 1);
X  
X  	DOTsave(&before);
X! 	(dir == FORWARD) ? f_char(num) : b_char(num);
X  	if (before.p_line == curline && before.p_char == curchar)
X  		complain((char *) 0);
X  	if (killp)
X***************
X*** 249,258 ****
X  	register Mark	*dot;
X  	int	all;
X  
X- 	exp = 1;
X  	if (!blnkp(&linebuf[curchar]))
X  		return;
X! 	dot = MakeMark(curline, curchar, FLOATER);
X  	all = !blnkp(linebuf);
X  	while (blnkp(linebuf) && curline->l_prev)
X  		SetLine(curline->l_prev);
X--- 253,261 ----
X  	register Mark	*dot;
X  	int	all;
X  
X  	if (!blnkp(&linebuf[curchar]))
X  		return;
X! 	dot = MakeMark(curline, curchar, M_FLOATER);
X  	all = !blnkp(linebuf);
X  	while (blnkp(linebuf) && curline->l_prev)
X  		SetLine(curline->l_prev);
X***************
X*** 259,271 ****
X  	all |= (firstp(curline));
X  	Eol();
X  	DelWtSpace();
X! 	line_move(FORWARD, NO);
X  	while (blnkp(linebuf) && !eobp()) {
X  		DelWtSpace();
X! 		DelNChar();
X  	}
X  	if (!all && !eobp())
X! 		OpenLine();
X  	ToMark(dot);
X  	DelMark(dot);
X  }
X--- 262,274 ----
X  	all |= (firstp(curline));
X  	Eol();
X  	DelWtSpace();
X! 	line_move(FORWARD, 1, NO);
X  	while (blnkp(linebuf) && !eobp()) {
X  		DelWtSpace();
X! 		del_char(FORWARD, 1);
X  	}
X  	if (!all && !eobp())
X! 		open_lines(1);
X  	ToMark(dot);
X  	DelMark(dot);
X  }
Xdiff -c ojove/disp.c jove/disp.c
X*** ojove/disp.c	Thu Jul 16 09:14:15 1987
X--- jove/disp.c	Fri Jul 10 09:25:49 1987
X***************
X*** 108,118 ****
X  		if (VisBell && VB)
X  			putstr(VB);
X  		else
X! #ifdef SYSV	/* release 2, at least */
X! 			putpad("$<20>\007", 1) ;
X! #else
X! 			putpad("20\007", 1);
X! #endif SYSV
X  	}
X  	flusho();
X  }
X--- 108,114 ----
X  		if (VisBell && VB)
X  			putstr(VB);
X  		else
X! 			putpad(BL, 1);
X  	}
X  	flusho();
X  }
X***************
X*** 787,793 ****
X  		ign_some = 0;
X  	char	line[132],
X  		*fmt = ModeFmt,
X- 		tmp[16],
X  		fillc,
X  		c;
X  	register Buffer	*thisbuf = w->w_bufp;
X--- 783,788 ----
X***************
X*** 889,902 ****
X  				mode_app("[No file]");
X  			else {
X  				if (c == 'f')
X! 					mode_app(pr_name(thisbuf->b_fname));
X  				else
X  					mode_app(basename(thisbuf->b_fname));
X  			}
X  			break;
X  
X- 
X  		case 'n':
X  			for (bp = world, n = 1; bp != 0; bp = bp->b_next, n++)
X  				if (bp == thisbuf)
X  					break;
X--- 884,899 ----
X  				mode_app("[No file]");
X  			else {
X  				if (c == 'f')
X! 					mode_app(pr_name(thisbuf->b_fname, YES));
X  				else
X  					mode_app(basename(thisbuf->b_fname));
X  			}
X  			break;
X  
X  		case 'n':
X+ 		    {
X+ 			char	tmp[16];
X+ 
X  			for (bp = world, n = 1; bp != 0; bp = bp->b_next, n++)
X  				if (bp == thisbuf)
X  					break;
X***************
X*** 904,909 ****
X--- 901,907 ----
X  			sprintf(tmp, "%d", n);
X  			mode_app(tmp);
X  			break;
X+ 		    }
X  
X  		case 'm':
X  			if (IsModified(w->w_bufp))
X***************
X*** 933,940 ****
X  			       (int) theavg,
X  			       (int)((theavg - (int) theavg) * 100));
X  		    	mode_app(minibuf);
X  		    }
X- 		    break;
X  #endif
X  
X  		case 'C':	/* check mail here */
X--- 931,938 ----
X  			       (int) theavg,
X  			       (int)((theavg - (int) theavg) * 100));
X  		    	mode_app(minibuf);
X+ 			break;
X  		    }
X  #endif
X  
X  		case 'C':	/* check mail here */
X***************
X*** 944,950 ****
X  
X  #ifdef CHDIR
X  		case 'd':	/* print working directory */
X! 			mode_app(pr_name(pwd()));
X  			break;
X  #endif
X  			
X--- 942,948 ----
X  
X  #ifdef CHDIR
X  		case 'd':	/* print working directory */
X! 			mode_app(pr_name(pwd(), YES));
X  			break;
X  #endif
X  			
X***************
X*** 958,963 ****
X--- 956,975 ----
X  
X  		    	goto outahere;		/* %e means we're done! */
X  		    }
X+ 
X+ #ifdef IPROCS
X+ 		case 'p':
X+ 		    if (thisbuf->b_type != B_PROCESS) {
X+ 			char	tmp[40];
X+ 
X+ 			sprintf(tmp, "(%s)", (thisbuf->b_process == 0) ?
X+ 					     "No process" :
X+ 					     pstate(thisbuf->b_process));
X+ 			mode_app(tmp);
X+ 			break;
X+ 		    }
X+ #endif
X+ 
X  		}
X  	}
X  
X***************
X*** 980,987 ****
X  
X  RedrawDisplay()
X  {
X! 	Line	*newtop = prev_line((curwind->w_line = curline), exp_p ?
X! 				exp : HALF(curwind));
X  
X  	if (newtop == curwind->w_top)
X  		v_clear(FLine(curwind), FLine(curwind) + SIZE(curwind));
X--- 992,999 ----
X  
X  RedrawDisplay()
X  {
X! 	Line	*newtop = prev_line((curwind->w_line = curline), is_an_arg() ?
X! 				arg_value() : HALF(curwind));
X  
X  	if (newtop == curwind->w_top)
X  		v_clear(FLine(curwind), FLine(curwind) + SIZE(curwind));
X***************
X*** 1016,1027 ****
X  
X  	if (Asking)
X  		return;
X! 	if (exp < 0) {
X! 		exp = -exp;
X  		PrevPage();
X  		return;
X  	}
X! 	if (exp_p == YES)
X  		UpScroll();
X  	else {
X  		if (in_window(curwind, curwind->w_bufp->b_last) != -1) {
X--- 1028,1039 ----
X  
X  	if (Asking)
X  		return;
X! 	if (arg_value() < 0) {
X! 		negate_arg_value();
X  		PrevPage();
X  		return;
X  	}
X! 	if (arg_type() == YES)
X  		UpScroll();
X  	else {
X  		if (in_window(curwind, curwind->w_bufp->b_last) != -1) {
X***************
X*** 1041,1052 ****
X  
X  	if (Asking)
X  		return;
X! 	if (exp < 0) {
X! 		exp = -exp;
X  		NextPage();
X  		return;
X  	}
X! 	if (exp_p == YES)
X  		DownScroll();
X  	else {
X  		newline = prev_line(curwind->w_top, max(1, SIZE(curwind) - 1));
X--- 1053,1064 ----
X  
X  	if (Asking)
X  		return;
X! 	if (arg_value() < 0) {
X! 		negate_arg_value();
X  		NextPage();
X  		return;
X  	}
X! 	if (arg_type() == YES)
X  		DownScroll();
X  	else {
X  		newline = prev_line(curwind->w_top, max(1, SIZE(curwind) - 1));
X***************
X*** 1058,1064 ****
X  
X  UpScroll()
X  {
X! 	SetTop(curwind, next_line(curwind->w_top, exp));
X  	if ((curwind->w_bufp == curbuf) &&
X  	    (in_window(curwind, curline) == -1))
X  		SetLine(curwind->w_top);
X--- 1070,1076 ----
X  
X  UpScroll()
X  {
X! 	SetTop(curwind, next_line(curwind->w_top, arg_value()));
X  	if ((curwind->w_bufp == curbuf) &&
X  	    (in_window(curwind, curline) == -1))
X  		SetLine(curwind->w_top);
X***************
X*** 1066,1072 ****
X  
X  DownScroll()
X  {
X! 	SetTop(curwind, prev_line(curwind->w_top, exp));
X  	if ((curwind->w_bufp == curbuf) &&
X  	    (in_window(curwind, curline) == -1))
X  		SetLine(curwind->w_top);
X--- 1078,1084 ----
X  
X  DownScroll()
X  {
X! 	SetTop(curwind, prev_line(curwind->w_top, arg_value()));
X  	if ((curwind->w_bufp == curbuf) &&
X  	    (in_window(curwind, curline) == -1))
X  		SetLine(curwind->w_top);
X***************
X*** 1101,1108 ****
X  	if (Asking)
X  		return;
X  	SetLine(next_line(curwind->w_top, SIZE(curwind) - 1 -
X! 			min(SIZE(curwind) - 1, exp - 1)));
X! 	if (exp_p == NO)
X  		Eol();
X  }
X  
X--- 1113,1120 ----
X  	if (Asking)
X  		return;
X  	SetLine(next_line(curwind->w_top, SIZE(curwind) - 1 -
X! 			min(SIZE(curwind) - 1, arg_value() - 1)));
X! 	if (!is_an_arg())
X  		Eol();
X  }
X  
X***************
X*** 1112,1118 ****
X  {
X  	if (Asking)
X  		return;
X! 	SetLine(next_line(curwind->w_top, min(SIZE(curwind) - 1, exp - 1)));
X  }
X  
X  private int	LineNo,
X--- 1124,1130 ----
X  {
X  	if (Asking)
X  		return;
X! 	SetLine(next_line(curwind->w_top, min(SIZE(curwind) - 1, arg_value() - 1)));
X  }
X  
X  private int	LineNo,
X***************
X*** 1158,1164 ****
X  		f_mess("--more--");
X  		if ((c = getchar()) != ' ') {
X  			TOabort++;
X! 			if (c != CTL(G) && c != RUBOUT)
X  				Ungetc(c);
X  			return;
X  		}
X--- 1170,1176 ----
X  		f_mess("--more--");
X  		if ((c = getchar()) != ' ') {
X  			TOabort++;
X! 			if (c != CTL('G') && c != RUBOUT)
X  				Ungetc(c);
X  			return;
X  		}
XCommon subdirectories: ojove/doc and jove/doc
Xdiff -c ojove/extend.c jove/extend.c
X*** ojove/extend.c	Thu Jul 16 09:14:18 1987
X--- jove/extend.c	Tue Jun 23 13:50:18 1987
X***************
X*** 78,86 ****
X  {
X  	register int	i;
X  
X! 	exp_p = YES;
X! 	exp = 1;	/* So minor modes don't toggle.  We always want
X! 			   them on. */
X  	if (new == 0)
X  		return;
X  	for (i = 0; i < ExecIndex; i++)
X--- 78,84 ----
X  {
X  	register int	i;
X  
X! 	set_arg_value(1);
X  	if (new == 0)
X  		return;
X  	for (i = 0; i < ExecIndex; i++)
X***************
X*** 165,171 ****
X  		} else if (c == '^') {
X  			if ((c = getch()) == '?')
X  				c = RUBOUT;
X! 			else if (isalpha(c) || index("[\\]^_", c))
X  				c = c - '@';
X  			else
X  				complain("[Unknown control character]");
X--- 163,169 ----
X  		} else if (c == '^') {
X  			if ((c = getch()) == '?')
X  				c = RUBOUT;
X! 			else if (isalpha(c) || index("@[\\]^_", c))
X  				c = c - '@';
X  			else
X  				complain("[Unknown control character]");
X***************
X*** 320,326 ****
X  			sprintf(keydescbuf, "%s %p", pref, c1);
X  		else
X  			sprintf(keydescbuf, "%s [%p-%p]", pref, c1, c2);
X! 		if (prefp = IsPrefix(map[c1]))
X  			DescMap(prefp, keydescbuf);
X  		else
X  			Typeout("%-14s%s", keydescbuf, map[c1]->Name);
X--- 318,324 ----
X  			sprintf(keydescbuf, "%s %p", pref, c1);
X  		else
X  			sprintf(keydescbuf, "%s [%p-%p]", pref, c1, c2);
X! 		if ((prefp = IsPrefix(map[c1])) && (prefp != map))
X  			DescMap(prefp, keydescbuf);
X  		else
X  			Typeout("%-14s%s", keydescbuf, map[c1]->Name);
X***************
X*** 377,383 ****
X  				break;
X  			}
X  		}
X! 		if (prefp = IsPrefix(map[c1])) {
X  			sprintf(prefbuf, "%p", c1);
X  			fb_aux(cp, prefp, prefbuf, bufp);
X  		}
X--- 375,381 ----
X  				break;
X  			}
X  		}
X! 		if ((prefp = IsPrefix(map[c1])) && (prefp != map))  {
X  			sprintf(prefbuf, "%p", c1);
X  			fb_aux(cp, prefp, prefbuf, bufp);
X  		}
X***************
X*** 640,654 ****
X  			comp_value = NULLSTRING;
X  			return 0;
X  		}
X! 		if (comp_flags & RET_STATE) switch (command) {
X! 			case UNIQUE:
X! 			case ORIGINAL:
X! 			case NULLSTRING:
X! 				comp_value = command;
X! 				return 0;
X! 
X! 			default:
X! 				break;
X  		}
X  		if (InJoverc)
X  			complain("[\"%s\" unknown]", linebuf);
X--- 638,646 ----
X  			comp_value = NULLSTRING;
X  			return 0;
X  		}
X! 		if (comp_flags & RET_STATE) {
X! 			comp_value = command;
X! 			return 0;
X  		}
X  		if (InJoverc)
X  			complain("[\"%s\" unknown]", linebuf);
X***************
X*** 800,812 ****
X  		nchars += length(lp) + (lp->l_next != 0); /* include the NL */
X  	}
X  
X! 	s_mess("[\"%s\" line %d of %d, char %D of %D (%d%%)]",
X! 			filename(curbuf),
X! 			dotline,
X! 			i,
X! 			dotchar,
X! 			nchars,
X! 			(int) (((long) dotchar * 100) / nchars));
X  }
X  
X  #define IF_UNBOUND	-1
X--- 792,802 ----
X  		nchars += length(lp) + (lp->l_next != 0); /* include the NL */
X  	}
X  
X! 	s_mess("[\"%s\" line %d/%d, char %D/%D (%d%%), cursor = %d/%d]",
X! 	       filename(curbuf), dotline, i, dotchar, nchars,
X! 	       (nchars == 0) ? 100 : (int) (((long) dotchar * 100) / nchars),
X! 	       calc_pos(linebuf, curchar),
X! 	       calc_pos(linebuf, strlen(linebuf)));
X  }
X  
X  #define IF_UNBOUND	-1
X***************
X*** 884,890 ****
X  		Buffer	*savebuf = curbuf;
X  
X  		SetBuf(do_select((Window *) 0, "RC errors"));
X! 		ins_str(sprint("%s:%d:%s\t%s\n", pr_name(file), lnum, lbuf, mesgbuf), NO);
X  		unmodify();
X  		SetBuf(savebuf);
X  		Asking = 0;
X--- 874,880 ----
X  		Buffer	*savebuf = curbuf;
X  
X  		SetBuf(do_select((Window *) 0, "RC errors"));
X! 		ins_str(sprint("%s:%d:%s\t%s\n", pr_name(file, YES), lnum, lbuf, mesgbuf), NO);
X  		unmodify();
X  		SetBuf(savebuf);
X  		Asking = 0;
Xdiff -c ojove/fmt.c jove/fmt.c
X*** ojove/fmt.c	Thu Jul 16 09:14:21 1987
X--- jove/fmt.c	Fri May 29 12:49:31 1987
X***************
X*** 33,42 ****
X  	putc('\0', sp);
X  }
X  
X! static char	padc = ' ';
X! static File	*curiop = 0;
X! 
X! static
X  PPchar(c, str)
X  int	c;
X  char	*str;
X--- 33,39 ----
X  	putc('\0', sp);
X  }
X  
X! private
X  PPchar(c, str)
X  int	c;
X  char	*str;
X***************
X*** 53,98 ****
X  		sprintf(cp, "%c", c);
X  }
X  
X! static
X! putld(leftadj, width, d, base)
X  long	d;
X  {
X  	int	length = 1;
X  	long	tmpd = d;
X  
X  	while (tmpd = (tmpd / base))
X  		length++;
X  	if (d < 0)
X  		length++;
X! 	if (!leftadj)
X! 		pad(padc, width - length);
X  	if (d < 0) {
X! 		putc('-', curiop);
X  		d = -d;
X  	}
X  	outld(d, base);
X! 	if (leftadj)
X! 		pad(padc, width - length);
X  }
X  
X! static
X  outld(d, base)
X  long	d;
X  {
X! 	long	n;
X  
X  	if (n = (d / base))
X  		outld(n, base);
X! 	putc((int) ('0' + (int) (d % base)), curiop);
X  }
X  
X! static
X! puts(leftadj, width, str)
X  char	*str;
X  {
X  	int	length;
X! 	register char	*cp,
X! 			c;
X  
X  	if (str == 0)
X  #if pyr
X--- 50,106 ----
X  		sprintf(cp, "%c", c);
X  }
X  
X! private struct fmt_state {
X! 	int	precision,
X! 		width,
X! 		leftadj;
X! 	char	padc;
X! 	File	*iop;
X! } current_fmt;
X! 
X! private
X! putld(d, base)
X  long	d;
X  {
X  	int	length = 1;
X  	long	tmpd = d;
X  
X+ 	if (current_fmt.width == 0 && current_fmt.precision) {
X+ 		current_fmt.width = current_fmt.precision;
X+ 		current_fmt.padc = '0';
X+ 	}
X  	while (tmpd = (tmpd / base))
X  		length++;
X  	if (d < 0)
X  		length++;
X! 	if (!current_fmt.leftadj)
X! 		pad(current_fmt.padc, current_fmt.width - length);
X  	if (d < 0) {
X! 		putc('-', current_fmt.iop);
X  		d = -d;
X  	}
X  	outld(d, base);
X! 	if (current_fmt.leftadj)
X! 		pad(current_fmt.padc, current_fmt.width - length);
X  }
X  
X! private
X  outld(d, base)
X  long	d;
X  {
X! 	register long	n;
X  
X  	if (n = (d / base))
X  		outld(n, base);
X! 	putc((int) ('0' + (int) (d % base)), current_fmt.iop);
X  }
X  
X! private
X! puts(str)
X  char	*str;
X  {
X  	int	length;
X! 	register char	*cp;
X  
X  	if (str == 0)
X  #if pyr
X***************
X*** 101,125 ****
X  		str = "(null)";
X  #endif
X  	length = strlen(str);
X  	cp = str;
X! 	if (!leftadj)
X! 		pad(' ', width - length);
X! 	while (c = *cp++)
X! 		putc(c, curiop);
X! 	if (leftadj)
X! 		pad(' ', width - length);
X  }
X  
X! static
X  pad(c, amount)
X  register int	c,
X  		amount;
X  {
X  	while (--amount >= 0)
X! 		putc(c, curiop);
X  }
X  
X! static
X  doformat(sp, fmt, ap)
X  register File	*sp;
X  register char	*fmt;
X--- 109,137 ----
X  		str = "(null)";
X  #endif
X  	length = strlen(str);
X+ 	if (current_fmt.precision == 0 || length < current_fmt.precision)
X+ 		current_fmt.precision = length;
X+ 	else
X+ 		length = current_fmt.precision;
X  	cp = str;
X! 	if (!current_fmt.leftadj)
X! 		pad(' ', current_fmt.width - length);
X! 	while (--current_fmt.precision >= 0)
X! 		putc(*cp++, current_fmt.iop);
X! 	if (current_fmt.leftadj)
X! 		pad(' ', current_fmt.width - length);
X  }
X  
X! private
X  pad(c, amount)
X  register int	c,
X  		amount;
X  {
X  	while (--amount >= 0)
X! 		putc(c, current_fmt.iop);
X  }
X  
X! private
X  doformat(sp, fmt, ap)
X  register File	*sp;
X  register char	*fmt;
X***************
X*** 126,171 ****
X  va_list	ap;
X  {
X  	register char	c;
X! 	int	leftadj,
X! 		width;
X! 	File	*pushiop = curiop;
X  
X! 	curiop = sp;
X  
X  	while (c = *fmt++) {
X  		if (c != '%') {
X! 			putc(c, sp);
X  			continue;
X  		}
X  
X! 		padc = ' ';
X! 		leftadj = width = 0;
X  		c = *fmt++;
X  		if (c == '-') {
X! 			leftadj++;
X  			c = *fmt++;
X  		}
X  		if (c == '0') {
X! 			padc = '0';
X  			c = *fmt++;
X  		}
X  		while (c >= '0' && c <= '9') {
X! 			width = width * 10 + (c - '0');
X  			c = *fmt++;
X  		}
X  		if (c == '*') {
X! 			width = va_arg(ap, int);
X  			c = *fmt++;
X  		}
X  	reswitch:
X  		/* At this point, fmt points at one past the format letter. */
X  		switch (c) {
X  		case '%':
X! 			putc('%', curiop);
X  			break;
X  	
X  		case 'D':
X! 			putld(leftadj, width, va_arg(ap, long), 10);
X  			break;
X  	
X  		case 'b':
X--- 138,193 ----
X  va_list	ap;
X  {
X  	register char	c;
X! 	struct fmt_state	prev_fmt;
X  
X! 	prev_fmt = current_fmt;
X! 	current_fmt.iop = sp;
X  
X  	while (c = *fmt++) {
X  		if (c != '%') {
X! 			putc(c, current_fmt.iop);
X  			continue;
X  		}
X  
X! 		current_fmt.padc = ' ';
X! 		current_fmt.precision = current_fmt.leftadj = current_fmt.width = 0;
X  		c = *fmt++;
X  		if (c == '-') {
X! 			current_fmt.leftadj = YES;
X  			c = *fmt++;
X  		}
X  		if (c == '0') {
X! 			current_fmt.padc = '0';
X  			c = *fmt++;
X  		}
X  		while (c >= '0' && c <= '9') {
X! 			current_fmt.width = current_fmt.width * 10 + (c - '0');
X  			c = *fmt++;
X  		}
X  		if (c == '*') {
X! 			current_fmt.width = va_arg(ap, int);
X  			c = *fmt++;
X  		}
X+ 		if (c == '.') {
X+ 			c = *fmt++;
X+ 			while (c >= '0' && c <= '9') {
X+ 				current_fmt.precision = current_fmt.precision * 10 + (c - '0');
X+ 				c = *fmt++;
X+ 			}
X+ 			if (c == '*') {
X+ 				current_fmt.precision = va_arg(ap, int);
X+ 				c = *fmt++;
X+ 			}
X+ 		}
X  	reswitch:
X  		/* At this point, fmt points at one past the format letter. */
X  		switch (c) {
X  		case '%':
X! 			putc('%', current_fmt.iop);
X  			break;
X  	
X  		case 'D':
X! 			putld(va_arg(ap, long), 10);
X  			break;
X  	
X  		case 'b':
X***************
X*** 172,204 ****
X  		    {
X  			Buffer	*b = va_arg(ap, Buffer *);
X  
X! 			puts(leftadj, width, b->b_name);
X  			break;
X  		    }
X  
X  		case 'c':
X! 			putc(va_arg(ap, int), curiop);
X  			break;
X  	
X  		case 'd':
X! 			putld(leftadj, width, (long) va_arg(ap, int), 10);
X  			break;
X  	
X  		case 'f':	/* current command name gets inserted here! */
X! 			puts(leftadj, width, LastCmd->Name);
X  			break;
X  
X  		case 'l':
X! 			c = Upper(*++fmt);
X  			goto reswitch;
X  	
X  		case 'n':
X  			if (va_arg(ap, int) != 1)
X! 				puts(leftadj, width, "s");
X  			break;
X  
X  		case 'o':
X! 			putld(leftadj, width, (long) va_arg(ap, int), 8);
X  			break;
X  	
X  		case 'p':
X--- 194,226 ----
X  		    {
X  			Buffer	*b = va_arg(ap, Buffer *);
X  
X! 			puts(b->b_name);
X  			break;
X  		    }
X  
X  		case 'c':
X! 			putc(va_arg(ap, int), current_fmt.iop);
X  			break;
X  	
X  		case 'd':
X! 			putld((long) va_arg(ap, int), 10);
X  			break;
X  	
X  		case 'f':	/* current command name gets inserted here! */
X! 			puts(LastCmd->Name);
X  			break;
X  
X  		case 'l':
X! 			c = CharUpcase(*++fmt);
X  			goto reswitch;
X  	
X  		case 'n':
X  			if (va_arg(ap, int) != 1)
X! 				puts("s");
X  			break;
X  
X  		case 'o':
X! 			putld((long) va_arg(ap, int), 8);
X  			break;
X  	
X  		case 'p':
X***************
X*** 206,217 ****
X  		    	char	cbuf[20];
X  
X  		    	PPchar(va_arg(ap, int), cbuf);
X! 		    	puts(leftadj, width, cbuf);
X  		    	break;
X  		    }
X  
X  		case 's':
X! 			puts(leftadj, width, va_arg(ap, char *));
X  			break;
X  		
X  		default:
X--- 228,239 ----
X  		    	char	cbuf[20];
X  
X  		    	PPchar(va_arg(ap, int), cbuf);
X! 		    	puts(cbuf);
X  		    	break;
X  		    }
X  
X  		case 's':
X! 			puts(va_arg(ap, char *));
X  			break;
X  		
X  		default:
X***************
X*** 218,224 ****
X  			complain("Unknown format directive: \"%%%c\"", c);
X  		}
X  	}
X! 	curiop = pushiop;
X  }
X  
X  /* VARARGS1 */
X--- 240,246 ----
X  			complain("Unknown format directive: \"%%%c\"", c);
X  		}
X  	}
X! 	current_fmt = prev_fmt;
X  }
X  
X  /* VARARGS1 */
END_OF_FILE
if test 51694 -ne `wc -c <'jove.pch.1'`; then
    echo shar: \"'jove.pch.1'\" unpacked with wrong size!
fi
# end of 'jove.pch.1'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
