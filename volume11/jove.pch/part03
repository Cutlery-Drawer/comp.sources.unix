Subject:  v11i047:  Jove upgrade kit, Part03/04
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: Jonathan Payne  <jpayne@cs.rochester.edu>
Posting-number: Volume 11, Issue 47
Archive-name: jove.pch/Part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 4)."
# Contents:  jove.pch.3
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'jove.pch.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jove.pch.3'\"
else
echo shar: Extracting \"'jove.pch.3'\" \(50121 characters\)
sed "s/^X//" >'jove.pch.3' <<'END_OF_FILE'
Xdiff -c ojove/jove.h jove/jove.h
X*** ojove/jove.h	Thu Jul 16 09:14:38 1987
X--- jove/jove.h	Fri Jul 10 09:25:51 1987
X***************
X*** 57,71 ****
X  #define FORWARD		1
X  #define BACKWARD	-1
X  
X! #define CTL(c)		('c' & 037)
X! #define META(c)		('c' | 0200)
X  #define RUBOUT		'\177'
X! #define LF		CTL(J)
X! #define CR		CTL(M)
X! #define BS		CTL(H)
X  #define ESC		'\033'
X  
X- #define DoTimes(f, n)	exp_p = YES, exp = n, f
X  #define HALF(wp)	((wp->w_height - 1) / 2)
X  #define IsModified(b)	(b->b_modified)
X  #define SIZE(wp)	(wp->w_height - 1)
X--- 57,70 ----
X  #define FORWARD		1
X  #define BACKWARD	-1
X  
X! #define CTL(c)		(c & 037)
X! #define META(c)		(c | 0200)
X  #define RUBOUT		'\177'
X! #define LF		CTL('J')
X! #define CR		CTL('M')
X! #define BS		CTL('H')
X  #define ESC		'\033'
X  
X  #define HALF(wp)	((wp->w_height - 1) / 2)
X  #define IsModified(b)	(b->b_modified)
X  #define SIZE(wp)	(wp->w_height - 1)
X***************
X*** 81,86 ****
X--- 80,86 ----
X  #define lastp(line)	(line == curbuf->b_last)
X  #define makedirty(line)	line->l_dline |= DIRTY
X  #define one_windp()	(fwind->w_next == fwind)
X+ #define CharUpcase(c)	(CaseEquiv[c])
X  
X  extern int	OkayAbort,	/* okay to abort redisplay */
X  		BufSize;
X***************
X*** 121,126 ****
X--- 121,127 ----
X  #define SetMajor(x)	((curbuf->b_major = x), UpdModLine++)
X  
X  extern char	CharTable[NMAJORS][128];
X+ extern char	CaseEquiv[128];
X  
X  /* setjmp/longjmp args for DoKeys() mainjmp */
X  #define FIRSTCALL	0
X***************
X*** 192,213 ****
X  	Process	*p_next;
X  #ifdef PIPEPROCS
X  	int	p_toproc,	/* read p_fromproc and write p_toproc */
X! 		p_portpid,	/* Pid of child (the portsrv) */
X! 		p_pid;		/* Pid of real child i.e. not portsrv */
X  #else
X! 	int	p_fd,		/* File descriptor of ptyp? opened r/w */
X  		p_pid;		/* pid of child (the shell) */
X  #endif
X! 	Buffer	*p_buffer;	/* Add output to end of this buffer */
X  	char	*p_name;	/* ... */
X  	char	p_state,	/* State */
X  		p_howdied,	/* Killed? or Exited? */
X! 		p_reason,	/* If signaled, p_reason is the signal; else
X  				   it is the the exit code */
X! 		p_eof;		/* Received EOF, so can be free'd up */
X! 	Mark	*p_mark;	/* Where output left us. */
X  	data_obj
X! 		*p_cmd;		/* Command to call when process dies */
X  };
X  #endif IPROCS
X  
X--- 193,213 ----
X  	Process	*p_next;
X  #ifdef PIPEPROCS
X  	int	p_toproc,	/* read p_fromproc and write p_toproc */
X! 		p_portpid,	/* pid of child (the portsrv) */
X! 		p_pid;		/* pid of real child i.e. not portsrv */
X  #else
X! 	int	p_fd,		/* file descriptor of pty? opened r/w */
X  		p_pid;		/* pid of child (the shell) */
X  #endif
X! 	Buffer	*p_buffer;	/* add output to end of this buffer */
X  	char	*p_name;	/* ... */
X  	char	p_state,	/* State */
X  		p_howdied,	/* Killed? or Exited? */
X! 		p_reason;	/* If signaled, p_reason is the signal; else
X  				   it is the the exit code */
X! 	Mark	*p_mark;	/* where output left us */
X  	data_obj
X! 		*p_cmd;		/* command to call when process dies */
X  };
X  #endif IPROCS
X  
X***************
X*** 242,249 ****
X  	Line	*m_line;
X  	int	m_char;
X  	Mark	*m_next;	/* list of marks */
X! #define FLOATER	1
X! 	char	m_floater;	/* FLOATERing mark? */
X  };
X  
X  struct buffer {
X--- 242,251 ----
X  	Line	*m_line;
X  	int	m_char;
X  	Mark	*m_next;	/* list of marks */
X! #define M_FIXED		00
X! #define M_FLOATER	01
X! #define M_BIG_DELETE	02
X! 	char	m_flags;	/* FLOATERing mark? */
X  };
X  
X  struct buffer {
X***************
X*** 380,387 ****
X  	ScrollStep,		/* how should we scroll */
X  	WtOnMk,			/* write files on compile-it command */
X  	EndWNewline,		/* end files with a blank line */
X! 	MarkThresh,		/* moves greater than MarkThresh
X! 				   will SetMark */
X  	PDelay,			/* paren flash delay in tenths of a second */
X  	CIndIncrmt,		/* how much each indentation level pushes
X  				   over in C mode */
X--- 382,388 ----
X  	ScrollStep,		/* how should we scroll */
X  	WtOnMk,			/* write files on compile-it command */
X  	EndWNewline,		/* end files with a blank line */
X! 	MarkThresh,		/* moves greater than MarkThresh will SetMark */
X  	PDelay,			/* paren flash delay in tenths of a second */
X  	CIndIncrmt,		/* how much each indentation level pushes
X  				   over in C mode */
X***************
X*** 408,413 ****
X--- 409,415 ----
X  	SExitChar,		/* type this to stop i-search */
X  #endif
X  	IntChar,		/* ttysets this to generate QUIT */
X+ 	DoEVexpand,		/* treat $foo as environment variable */
X  	EWSize;			/* size to make the error window */
X  
X  extern char
X***************
X*** 427,435 ****
X  	Shell[128];		/* shell to use */
X  
X  extern int
X- 	exp,		/* argument count */
X- 	exp_p,		/* argument count is supplied */
X- 
X  	TOabort,	/* flag set by Typeout() */
X  	io,		/* file descriptor for reading and writing files */
X  	errormsg,	/* last message was an error message
X--- 429,434 ----
X***************
X*** 539,544 ****
X--- 538,546 ----
X  	*tgoto(),
X  	*pr_name(),
X  	*sprint(),
X+ #ifdef IPROCS
X+ 	*pstate(),
X+ #endif
X  	*StrIndex();
X  
X  extern Bufpos
Xdiff -c ojove/keymaps.txt jove/keymaps.txt
X*** ojove/keymaps.txt	Thu Jul 16 09:14:39 1987
X--- jove/keymaps.txt	Thu Jun 11 15:43:50 1987
X***************
X*** 34,40 ****
X  	"search-reverse",		/* ^R */
X  	"search-forward",		/* ^S */
X  	"transpose-characters",		/* ^T */
X! 	"quadruple-numeric-argument",	/* ^U */
X  	"next-page",			/* ^V */
X  	"kill-region",			/* ^W */
X  	"prefix-2",			/* ^X */
X--- 34,40 ----
X  	"search-reverse",		/* ^R */
X  	"search-forward",		/* ^S */
X  	"transpose-characters",		/* ^T */
X! 	"gather-numeric-argument",	/* ^U */
X  	"next-page",			/* ^V */
X  	"kill-region",			/* ^W */
X  	"prefix-2",			/* ^X */
Xdiff -c ojove/macros.c jove/macros.c
X*** ojove/macros.c	Thu Jul 16 09:14:41 1987
X--- jove/macros.c	Fri Jun 19 16:01:00 1987
X***************
X*** 8,14 ****
X  #include "jove.h"
X  
X  struct macro	*macros = 0;		/* Macros */
X- data_obj	*LastCmd;
X  
X  private
X  add_mac(new)
X--- 8,13 ----
X***************
X*** 84,90 ****
X  		complain("[Too many macros at once!]");
X  	macstack[stackp] = mac;
X  	mac->m_offset = 0;
X! 	mac->m_ntimes = exp;
X  	mac->m_flags |= EXECUTE;
X  }
X  
X--- 83,89 ----
X  		complain("[Too many macros at once!]");
X  	macstack[stackp] = mac;
X  	mac->m_offset = 0;
X! 	mac->m_ntimes = arg_value();
X  	mac->m_flags |= EXECUTE;
X  }
X  
X***************
X*** 362,368 ****
X  		if (!InJoverc) {
X  			TOstart("Warning", TRUE);
X  			Typeout("Warning: your macros file is in the old format.");
X! 			Typeout("Do you want me to convert \"%s\" to the new", pr_name(file));
X  			Typeout("format?");
X  			f_mess(msg);
X  			TOstop();
X--- 361,367 ----
X  		if (!InJoverc) {
X  			TOstart("Warning", TRUE);
X  			Typeout("Warning: your macros file is in the old format.");
X! 			Typeout("Do you want me to convert \"%s\" to the new", pr_name(file, YES));
X  			Typeout("format?");
X  			f_mess(msg);
X  			TOstop();
Xdiff -c ojove/marks.c jove/marks.c
X*** ojove/marks.c	Thu Jul 16 09:14:42 1987
X--- jove/marks.c	Wed Jun 24 13:22:48 1987
X***************
X*** 17,23 ****
X  
X  	MarkSet(newmark, line, column);
X  	newmark->m_next = curbuf->b_marks;
X! 	newmark->m_floater = type;
X  	curbuf->b_marks = newmark;
X  	return newmark;
X  }
X--- 17,23 ----
X  
X  	MarkSet(newmark, line, column);
X  	newmark->m_next = curbuf->b_marks;
X! 	newmark->m_flags = type;
X  	curbuf->b_marks = newmark;
X  	return newmark;
X  }
X***************
X*** 70,76 ****
X  				pmark = NMARKS - 1;
X  		} while (curbuf->b_markring[pmark] != 0);
X  
X! 		curbuf->b_markring[pmark] = MakeMark(curline, curchar, MarksShouldFloat);
X  		ToMark(curmark);
X  		DelMark(curmark);
X  		curmark = 0;
X--- 70,76 ----
X  				pmark = NMARKS - 1;
X  		} while (curbuf->b_markring[pmark] != 0);
X  
X! 		curbuf->b_markring[pmark] = MakeMark(curline, curchar, MarksShouldFloat ? M_FLOATER : M_FIXED);
X  		ToMark(curmark);
X  		DelMark(curmark);
X  		curmark = 0;
X***************
X*** 85,102 ****
X  
X  SetMark()
X  {
X! 	if (exp_p)
X  		PopMark();
X  	else
X! 		DoSetMark(curline, curchar);
X  }
X  
X! DoSetMark(l, c)
X  Line	*l;
X  {
X  	curbuf->b_themark = (curbuf->b_themark + 1) % NMARKS;
X  	if (curmark == 0)
X! 		curmark = MakeMark(l, c, MarksShouldFloat);
X  	else
X  		MarkSet(curmark, l, c);
X  	s_mess("[Point pushed]");
X--- 85,107 ----
X  
X  SetMark()
X  {
X! 	if (is_an_arg())
X  		PopMark();
X  	else
X! 		set_mark();
X  }
X  
X! set_mark()
X! {
X! 	do_set_mark(curline, curchar);
X! }
X! 
X! do_set_mark(l, c)
X  Line	*l;
X  {
X  	curbuf->b_themark = (curbuf->b_themark + 1) % NMARKS;
X  	if (curmark == 0)
X! 		curmark = MakeMark(l, c, MarksShouldFloat ? M_FLOATER : M_FIXED);
X  	else
X  		MarkSet(curmark, l, c);
X  	s_mess("[Point pushed]");
X***************
X*** 151,167 ****
X  	if (curbuf->b_marks == 0)
X  		return;
X  	while (lp != line2->l_next) {
X! 		for (m = curbuf->b_marks; m != 0; m = m->m_next) {
X! /*			if (!m->m_floater)
X! 				continue; */
X  			if (m->m_line == lp)
X  				m->m_char |= (1 << 15);
X- 		}
X  		lp = lp->l_next;
X  	}
X  	for (m = curbuf->b_marks; m; m = m->m_next) {
X- /*		if (!m->m_floater)
X- 			continue; */
X  		if ((m->m_char & (1 << 15)) == 0)
X  			continue;	/* Not effected */
X  		m->m_char &= ~(1 << 15);
X--- 156,167 ----
X  	if (curbuf->b_marks == 0)
X  		return;
X  	while (lp != line2->l_next) {
X! 		for (m = curbuf->b_marks; m != 0; m = m->m_next)
X  			if (m->m_line == lp)
X  				m->m_char |= (1 << 15);
X  		lp = lp->l_next;
X  	}
X  	for (m = curbuf->b_marks; m; m = m->m_next) {
X  		if ((m->m_char & (1 << 15)) == 0)
X  			continue;	/* Not effected */
X  		m->m_char &= ~(1 << 15);
X***************
X*** 178,187 ****
X--- 178,189 ----
X  				m->m_char = char1 + (m->m_char - char2);
X  			else
X  				m->m_char = char1;
X+ 			m->m_flags |= M_BIG_DELETE;
X  			m->m_line = line1;
X  		} else {
X  			m->m_char = char1;
X  			m->m_line = line1;
X+ 			m->m_flags |= M_BIG_DELETE;
X  		}
X  	}
X  }
X***************
X*** 196,202 ****
X  	register Mark	*m;
X  
X  	for (m = curbuf->b_marks; m != 0; m = m->m_next) {
X! 		if (!m->m_floater)
X  			continue;
X  		if (m->m_line == line1) {
X  			if (m->m_char > char1) {
X--- 198,204 ----
X  	register Mark	*m;
X  
X  	for (m = curbuf->b_marks; m != 0; m = m->m_next) {
X! 		if ((m->m_flags & M_FLOATER) == 0)
X  			continue;
X  		if (m->m_line == line1) {
X  			if (m->m_char > char1) {
Xdiff -c ojove/misc.c jove/misc.c
X*** ojove/misc.c	Thu Jul 16 09:14:43 1987
X--- jove/misc.c	Fri Jul 10 09:25:50 1987
X***************
X*** 12,161 ****
X  #include "termcap.h"
X  #endif
X  
X- Digit()
X- {
X- 	GetExp(LastKeyStruck);
X- }
X- 
X- Digit0()
X- {
X- 	GetExp('0');
X- }
X- 
X- Digit1()
X- {
X- 	GetExp('1');
X- }
X- 
X- Digit2()
X- {
X- 	GetExp('2');
X- }
X- 
X- Digit3()
X- {
X- 	GetExp('3');
X- }
X- 
X- Digit4()
X- {
X- 	GetExp('4');
X- }
X- 
X- Digit5()
X- {
X- 	GetExp('5');
X- }
X- 
X- Digit6()
X- {
X- 	GetExp('6');
X- }
X- 
X- Digit7()
X- {
X- 	GetExp('7');
X- }
X- 
X- Digit8()
X- {
X- 	GetExp('8');
X- }
X- 
X- Digit9()
X- {
X- 	GetExp('9');
X- }
X- 
X  prCTIME()
X  {
X  	s_mess(": %f %s", get_time((time_t *) 0, (char *) 0, 0, -1));
X  }
X  
X- extern int	alarmed;
X- 
X- FourTime()
X- {
X- 	int	oldc = LastKeyStruck,
X- 		newc;
X- 	int	nexp;
X- 
X- 	alarmed = 0;
X- 	exp_p = YES;
X- 	this_cmd = ARG_CMD;
X- 	do {
X- 		if ((nexp = exp * 4) != 0)
X- 			exp = nexp;
X- 		if (!alarmed)
X- 			newc = waitchar();
X- 		else
X- 			newc = getch();
X- 		if (alarmed)
X- 			message(key_strokes);
X- 	} while (newc == oldc);
X- 	Ungetc(newc);
X- }
X- 
X- int	exp_p,
X- 	exp;
X- 
X- GetExp(c)
X- {
X- 	int	sign = 0;
X- 	static int	digited;
X- 
X- 	if (!isdigit(c) && c != '-')
X- 		complain((char *) 0);
X- 	if (exp_p == NO) {	/* if we just got here */
X- 		exp = 0;	/* start over */
X- 		digited = NO;
X- 	} else if (exp_p == YES_NODIGIT) {
X- 		sign = (exp < 0) ? -1 : 1;
X- 		exp = 0;
X- 	}
X- 
X- 	if (!sign)
X- 		sign = (exp < 0) ? -1 : 1;
X- 	if (sign == -1)
X- 		exp = -exp;
X- 	if (c == '-') {
X- 		sign = -sign;
X- 		goto goread;
X- 	}
X- 	for (;;) {
X- 		if (alarmed)
X- 			message(key_strokes);
X- 		if (isdigit(c)) {
X- 			exp = (exp * 10) + (c - '0');
X- 			digited++;
X- 		} else {
X- 			if (digited)
X- 				exp_p = YES;
X- 			else {
X- 				exp = 1;
X- 				if (exp_p == NO)
X- 					exp_p = YES_NODIGIT;
X- 			}
X- 			exp *= sign;
X- 			this_cmd = ARG_CMD;
X- 			Ungetc(c);
X- 			return;
X- 		}
X- goread:		if (!alarmed)
X- 			c = waitchar();
X- 		else {
X- 			add_mess(NullStr);
X- 			c = getch();
X- 		}
X- 	}
X- }
X- 
X  ChrToOct()
X  {
X! 	int	c;
X  
X! 	c = waitchar();
X! 	if (alarmed)
X  		message(key_strokes);
X  	ins_str(sprint("\\%03o", c), NO);
X  }
X--- 12,29 ----
X  #include "termcap.h"
X  #endif
X  
X  prCTIME()
X  {
X  	s_mess(": %f %s", get_time((time_t *) 0, (char *) 0, 0, -1));
X  }
X  
X  ChrToOct()
X  {
X! 	int	c,
X! 		slow;
X  
X! 	c = waitchar(&slow);
X! 	if (slow)
X  		message(key_strokes);
X  	ins_str(sprint("\\%03o", c), NO);
X  }
X***************
X*** 197,209 ****
X  
X  	if (curchar == 0 || (eolp() && curchar == 1))
X  		complain((char *) 0);	/* BEEP */
X- 	exp = 1;
X  	if (eolp())
X! 		BackChar();
X  	before = linebuf[curchar - 1];
X! 	DelPChar();
X! 	ForChar();
X! 	Insert(before);
X  }
X  
X  /* Switch current line with previous one */
X--- 65,76 ----
X  
X  	if (curchar == 0 || (eolp() && curchar == 1))
X  		complain((char *) 0);	/* BEEP */
X  	if (eolp())
X! 		b_char(1);
X  	before = linebuf[curchar - 1];
X! 	del_char(BACKWARD, 1);
X! 	f_char(1);
X! 	insert_c(before, 1);
X  }
X  
X  /* Switch current line with previous one */
X***************
X*** 214,220 ****
X  
X  	if (firstp(curline))
X  		return;
X- 	exp = 1;
X  	lsave();
X  	old_prev = curline->l_prev->l_dline;
X  	curline->l_prev->l_dline = curline->l_dline;
X--- 81,86 ----
X***************
X*** 221,227 ****
X  	curline->l_dline = old_prev;
X  	getDOT();
X  	if (!lastp(curline))
X! 		line_move(FORWARD, NO);
X  	modify();
X  }
X  
X--- 87,93 ----
X  	curline->l_dline = old_prev;
X  	getDOT();
X  	if (!lastp(curline))
X! 		line_move(FORWARD, 1, NO);
X  	modify();
X  }
X  
X***************
X*** 239,252 ****
X  {
X  	Line	*line2;
X  	int	char2;
X  
X! 	if (exp_p) {
X! 		if (exp == 0) {	/* Kill to beginning of line */
X  			line2 = curline;
X  			char2 = 0;
X  		} else {
X! 			line2 = next_line(curline, exp);
X! 			if ((LineDist(curline, line2) < exp) || (line2 == curline))
X  				char2 = length(line2);
X  			else
X  				char2 = 0;
X--- 105,119 ----
X  {
X  	Line	*line2;
X  	int	char2;
X+ 	int	num = arg_value();
X  
X! 	if (is_an_arg()) {
X! 		if (num == 0) {	/* Kill to beginning of line */
X  			line2 = curline;
X  			char2 = 0;
X  		} else {
X! 			line2 = next_line(curline, num);
X! 			if ((LineDist(curline, line2) < num) || (line2 == curline))
X  				char2 = length(line2);
X  			else
X  				char2 = 0;
X***************
X*** 264,274 ****
X  	reg_kill(line2, char2, 0);
X  }
X  
X! /* Kill to beginning of sentence */
X  
X  KillBos()
X  {
X! 	exp = -exp;
X  	KillEos();
X  }
X  
X--- 131,141 ----
X  	reg_kill(line2, char2, 0);
X  }
X  
X! /* kill to beginning of sentence */
X  
X  KillBos()
X  {
X! 	negate_arg_value();
X  	KillEos();
X  }
X  
X***************
X*** 316,330 ****
X  {
X  	register data_obj	*cp;
X  	register int	c;
X  
X! 	c = waitchar();
X! 	if (c == CTL(G)) {
X  		message("[Aborted]");
X  		rbell();
X  		return;
X  	}
X  
X! 	if (alarmed)
X  		message(key_strokes);
X  
X  	cp = map[c];
X--- 183,198 ----
X  {
X  	register data_obj	*cp;
X  	register int	c;
X+ 	int	slow;
X  
X! 	c = waitchar(&slow);
X! 	if (c == CTL('G')) {
X  		message("[Aborted]");
X  		rbell();
X  		return;
X  	}
X  
X! 	if (slow)
X  		message(key_strokes);
X  
X  	cp = map[c];
X***************
X*** 348,354 ****
X  	line = killbuf[killptr];
X  	lp = lastline(line);
X  	dot = DoYank(line, 0, lp, length(lp), curline, curchar, curbuf);
X! 	SetMark();
X  	SetDot(dot);
X  }
X  
X--- 216,222 ----
X  	line = killbuf[killptr];
X  	lp = lastline(line);
X  	dot = DoYank(line, 0, lp, length(lp), curline, curchar, curbuf);
X! 	set_mark();
X  	SetDot(dot);
X  }
X  
X***************
X*** 357,363 ****
X  	if (!ModBufs(NO))
X  		message("[No buffers need saving]");
X  	else
X! 		put_bufs(exp_p);
X  }
X  
X  put_bufs(askp)
X--- 225,231 ----
X  	if (!ModBufs(NO))
X  		message("[No buffers need saving]");
X  	else
X! 		put_bufs(is_an_arg());
X  }
X  
X  put_bufs(askp)
X***************
X*** 403,418 ****
X  	Line	*newline;
X  
X  #ifndef ANSICODES
X! 	if (exp_p == NO)
X  		return;
X  #else
X! 	if (exp_p == NO || exp <= 0) {
X  		if (SP)
X  			putpad(SP, 1);	/* Ask for cursor position */
X  		return;
X  	}
X  #endif
X! 	newline = next_line(curbuf->b_first, exp - 1);
X  	PushPntp(newline);
X  	SetLine(newline);
X  }
X--- 271,286 ----
X  	Line	*newline;
X  
X  #ifndef ANSICODES
X! 	if (!is_an_arg())
X  		return;
X  #else
X! 	if (!is_an_arg() || arg_value() <= 0) {
X  		if (SP)
X  			putpad(SP, 1);	/* Ask for cursor position */
X  		return;
X  	}
X  #endif
X! 	newline = next_line(curbuf->b_first, arg_value() - 1);
X  	PushPntp(newline);
X  	SetLine(newline);
X  }
X***************
X*** 440,452 ****
X  	static char *unsupported = "[Unsupported ANSI code received]";
X  
X  	while (isdigit(c = getch()))
X! 		num1 = (num1*10) + (c - '0');
X  
X  	switch (c) {
X  	case ';':
X  		num2 = 0;
X  		while (isdigit(c = getch()))
X! 			num2 = (num2*10) + (c - '0');
X  		switch (c) {
X  		case 'R':
X  			MoveToCursor(--num1, --num2);
X--- 308,320 ----
X  	static char *unsupported = "[Unsupported ANSI code received]";
X  
X  	while (isdigit(c = getch()))
X! 		num1 = (num1 * 10) + (c - '0');
X  
X  	switch (c) {
X  	case ';':
X  		num2 = 0;
X  		while (isdigit(c = getch()))
X! 			num2 = (num2 * 10) + (c - '0');
X  		switch (c) {
X  		case 'R':
X  			MoveToCursor(--num1, --num2);
X***************
X*** 459,468 ****
X  		}
X  		break;
X  	case 'A':
X! 		line_move(BACKWARD, YES);
X  		break;
X  	case 'B':
X! 		line_move(FORWARD, YES);
X  		break;
X  	case 'C':
X  		ForChar();
X--- 327,336 ----
X  		}
X  		break;
X  	case 'A':
X! 		PrevLine();
X  		break;
X  	case 'B':
X! 		NextLine();
X  		break;
X  	case 'C':
X  		ForChar();
X***************
X*** 479,484 ****
X--- 347,369 ----
X  			break;
X  		}
X  		/* FALL THROUGH */
X+ 
X+ 	case 'P':
X+ 		PrevPage();
X+ 		break;
X+ 
X+ 	case 'Q':
X+ 		NextPage();
X+ 		break;
X+ 
X+ 	case 'R':
X+ 		UpScroll();
X+ 		break;
X+ 
X+ 	case 'S':
X+ 		DownScroll();
X+ 		break;
X+ 
X  	default:
X  		complain(unsupported);
X  	}
Xdiff -c ojove/move.c jove/move.c
X*** ojove/move.c	Thu Jul 16 09:14:44 1987
X--- jove/move.c	Fri Jun 12 11:53:33 1987
X***************
X*** 10,26 ****
X  
X  static int	line_pos;
X  
X! ForChar()
X  {
X- 	register int	num = exp;
X  
X! 	if (exp < 0) {
X! 		exp = -exp;
X! 		BackChar();
X  		return;
X  	}
X! 	exp = 1;
X! 	while (--num >= 0) {
X  		if (eolp()) {			/* Go to the next Line */
X  			if (curline->l_next == 0)
X  				break;
X--- 10,24 ----
X  
X  static int	line_pos;
X  
X! f_char(n)
X! register int	n;
X  {
X  
X! 	if (n < 0) {
X! 		b_char(-n);
X  		return;
X  	}
X! 	while (--n >= 0) {
X  		if (eolp()) {			/* Go to the next Line */
X  			if (curline->l_next == 0)
X  				break;
X***************
X*** 30,46 ****
X  	}
X  }
X  
X! BackChar()
X  {
X- 	register int	num = exp;
X  
X! 	if (exp < 0) {
X! 		exp = -exp;
X! 		ForChar();
X  		return;
X  	}
X! 	exp = 1;
X! 	while (--num >= 0) {
X  		if (bolp()) {
X  			if (curline->l_prev == 0)
X  				break;
X--- 28,42 ----
X  	}
X  }
X  
X! b_char(n)
X! register int	n;
X  {
X  
X! 	if (n < 0) {
X! 		f_char(-n);
X  		return;
X  	}
X! 	while (--n >= 0) {
X  		if (bolp()) {
X  			if (curline->l_prev == 0)
X  				break;
X***************
X*** 51,61 ****
X  	}
X  }
X  
X  NextLine()
X  {
X  	if ((curline == curbuf->b_last) && eolp())
X  		complain(NullStr);
X! 	line_move(FORWARD, YES);
X  }
X  
X  PrevLine()
X--- 47,67 ----
X  	}
X  }
X  
X+ ForChar()
X+ {
X+ 	f_char(arg_value());
X+ }
X+ 
X+ BackChar()
X+ {
X+ 	b_char(arg_value());
X+ }
X+ 
X  NextLine()
X  {
X  	if ((curline == curbuf->b_last) && eolp())
X  		complain(NullStr);
X! 	line_move(FORWARD, arg_value(), YES);
X  }
X  
X  PrevLine()
X***************
X*** 62,68 ****
X  {
X  	if ((curline == curbuf->b_first) && bolp())
X  		complain(NullStr);
X! 	line_move(BACKWARD, YES);
X  }
X  
X  /* moves to a different line in DIR; LINE_CMD says whether this is
X--- 68,74 ----
X  {
X  	if ((curline == curbuf->b_first) && bolp())
X  		complain(NullStr);
X! 	line_move(BACKWARD, arg_value(), YES);
X  }
X  
X  /* moves to a different line in DIR; LINE_CMD says whether this is
X***************
X*** 69,80 ****
X     being called from NextLine() or PrevLine(), in which case it tries
X     to line up the column with the column of the current line */
X  
X! line_move(dir, line_cmd)
X  {
X  	Line	*(*proc)() = (dir == FORWARD) ? next_line : prev_line;
X  	Line	*line;
X  
X! 	line = (*proc)(curline, exp);
X  	if (line == curline) {
X  		(dir == FORWARD) ? Eol() : Bol();
X  		return;
X--- 75,86 ----
X     being called from NextLine() or PrevLine(), in which case it tries
X     to line up the column with the column of the current line */
X  
X! line_move(dir, n, line_cmd)
X  {
X  	Line	*(*proc)() = (dir == FORWARD) ? next_line : prev_line;
X  	Line	*line;
X  
X! 	line = (*proc)(curline, n);
X  	if (line == curline) {
X  		(dir == FORWARD) ? Eol() : Bol();
X  		return;
X***************
X*** 142,147 ****
X--- 148,154 ----
X     with all the kludgery involved with paragraphs, and moving backwards
X     is particularly yucky. */
X  
X+ private
X  to_sent(dir)
X  {
X  	Bufpos	*new,
X***************
X*** 152,158 ****
X  
X  	new = dosearch("^[ \t]*$\\|[?.!]", dir, 1);
X  	if (new == 0) {
X! 		(dir < 0) ? ToFirst() : ToLast();
X  		return;
X  	}
X  	SetDot(new);
X--- 159,165 ----
X  
X  	new = dosearch("^[ \t]*$\\|[?.!]", dir, 1);
X  	if (new == 0) {
X! 		(dir == BACKWARD) ? ToFirst() : ToLast();
X  		return;
X  	}
X  	SetDot(new);
X***************
X*** 168,174 ****
X  	}
X  	if (blnkp(linebuf)) {
X  		Bol();
X! 		BackChar();
X  		if (old.p_line == curline && old.p_char >= curchar) {
X  			to_word(1);	/* Oh brother this is painful */
X  			to_sent(1);
X--- 175,181 ----
X  	}
X  	if (blnkp(linebuf)) {
X  		Bol();
X! 		b_char(1);
X  		if (old.p_line == curline && old.p_char >= curchar) {
X  			to_word(1);	/* Oh brother this is painful */
X  			to_sent(1);
X***************
X*** 186,201 ****
X  
X  Bos()
X  {
X! 	int	num = exp;
X  
X! 	if (exp < 0) {
X! 		exp = -exp;
X  		Eos();
X  		return;
X  	}
X  
X- 	exp = 1;
X- 
X  	while (--num >= 0) {
X  		to_sent(-1);
X  		if (bobp())
X--- 193,206 ----
X  
X  Bos()
X  {
X! 	register int	num = arg_value();
X  
X! 	if (num < 0) {
X! 		negate_arg_value();
X  		Eos();
X  		return;
X  	}
X  
X  	while (--num >= 0) {
X  		to_sent(-1);
X  		if (bobp())
X***************
X*** 205,220 ****
X  
X  Eos()
X  {
X! 	int	num = exp;
X  
X! 	if (exp < 0) {
X! 		exp = -exp;
X  		Bos();
X  		return;
X  	}
X  
X- 	exp = 1;
X- 
X  	while (--num >= 0) {
X  		to_sent(1);
X  		if (eobp())
X--- 210,223 ----
X  
X  Eos()
X  {
X! 	register int	num = arg_value();
X  
X! 	if (num < 0) {
X! 		negate_arg_value();
X  		Bos();
X  		return;
X  	}
X  
X  	while (--num >= 0) {
X  		to_sent(1);
X  		if (eobp())
X***************
X*** 222,240 ****
X  	}
X  }
X  
X! ForWord()
X  {
X  	register char	c;
X- 	register int	num = exp;
X  
X! 	if (exp < 0) {
X! 		exp = -exp;
X! 		BackWord();
X  		return;
X  	}
X- 	exp = 1;
X  	while (--num >= 0) {
X! 		to_word(1);
X  		while ((c = linebuf[curchar]) != 0 && isword(c))
X  			curchar++;
X  		if (eobp())
X--- 225,241 ----
X  	}
X  }
X  
X! f_word(num)
X! register int	num;
X  {
X  	register char	c;
X  
X! 	if (num < 0) {
X! 		b_word(-num);
X  		return;
X  	}
X  	while (--num >= 0) {
X! 		to_word(FORWARD);
X  		while ((c = linebuf[curchar]) != 0 && isword(c))
X  			curchar++;
X  		if (eobp())
X***************
X*** 243,261 ****
X  	this_cmd = 0;	/* Semi kludge to stop some unfavorable behavior */
X  }
X  
X! BackWord()
X  {
X- 	register int	num = exp;
X  	register char	c;
X  
X! 	if (exp < 0) {
X! 		exp = -exp;
X! 		ForWord();
X  		return;
X  	}
X- 	exp = 1;
X  	while (--num >= 0) {
X! 		to_word(-1);
X  		while (!bolp() && (c = linebuf[curchar - 1], isword(c)))
X  			--curchar;
X  		if (bobp())
X--- 244,260 ----
X  	this_cmd = 0;	/* Semi kludge to stop some unfavorable behavior */
X  }
X  
X! b_word(num)
X! register int	num;
X  {
X  	register char	c;
X  
X! 	if (num < 0) {
X! 		f_word(-num);
X  		return;
X  	}
X  	while (--num >= 0) {
X! 		to_word(BACKWARD);
X  		while (!bolp() && (c = linebuf[curchar - 1], isword(c)))
X  			--curchar;
X  		if (bobp())
X***************
X*** 263,265 ****
X--- 262,275 ----
X  	}
X  	this_cmd = 0;
X  }
X+ 
X+ ForWord()
X+ {
X+ 	f_word(arg_value());
X+ }
X+ 
X+ BackWord()
X+ {
X+ 	b_word(arg_value());
X+ }
X+ 
Xdiff -c ojove/paragraph.c jove/paragraph.c
X*** ojove/paragraph.c	Thu Jul 16 09:14:45 1987
X--- jove/paragraph.c	Wed Jun 24 12:43:24 1987
X***************
X*** 204,210 ****
X  	int	this_indent;
X  	Bufpos	orig;		/* remember where we were when we started */
X  
X- 	exp = 1;
X  	DOTsave(&orig);
X  strt:
X  	this = curline;
X--- 204,209 ----
X***************
X*** 218,224 ****
X  				if (firstp(curline))
X  					complain((char *) 0);
X  				else
X! 					line_move(BACKWARD, NO);
X  			goto strt;
X  		} else {
X  			while (i_blank(curline))
X--- 217,223 ----
X  				if (firstp(curline))
X  					complain((char *) 0);
X  				else
X! 					line_move(BACKWARD, 1, NO);
X  			goto strt;
X  		} else {
X  			while (i_blank(curline))
X***************
X*** 225,231 ****
X  				if (lastp(curline))
X  					complain((char *) 0);
X  				else
X! 					line_move(FORWARD, NO);
X  			head = curline;
X  			next = curline->l_next;
X  			if (!i_bsblank(next))
X--- 224,230 ----
X  				if (lastp(curline))
X  					complain((char *) 0);
X  				else
X! 					line_move(FORWARD, 1, NO);
X  			head = curline;
X  			next = curline->l_next;
X  			if (!i_bsblank(next))
X***************
X*** 302,308 ****
X  
X  Justify()
X  {
X! 	use_lmargin = (exp_p != NO);
X  	find_para(BACKWARD);
X  	DoJustify(para_head, 0, para_tail, length(para_tail), NO,
X  		  use_lmargin ? LMargin : body_indent);
X--- 301,307 ----
X  
X  Justify()
X  {
X! 	use_lmargin = is_an_arg();
X  	find_para(BACKWARD);
X  	DoJustify(para_head, 0, para_tail, length(para_tail), NO,
X  		  use_lmargin ? LMargin : body_indent);
X***************
X*** 339,345 ****
X  	Line	*rl1,
X  		*rl2;
X  
X! 	use_lmargin = (exp_p != NO);
X  	(void) fixorder(&l1, &c1, &l2, &c2);
X  	do {
X  		DotTo(l1, c1);
X--- 338,344 ----
X  	Line	*rl1,
X  		*rl2;
X  
X! 	use_lmargin = is_an_arg();
X  	(void) fixorder(&l1, &c1, &l2, &c2);
X  	do {
X  		DotTo(l1, c1);
X***************
X*** 346,352 ****
X  		find_para(FORWARD);
X  		rl1 = max_line(l1, para_head);
X  		rl2 = min_line(l2, para_tail);
X! 		tailmark = MakeMark(para_tail, 0, FLOATER);
X  		DoJustify(rl1, (rl1 == l1) ? c1 : 0, rl2,
X  			  (rl2 == l2) ? c2 : length(rl2),
X  			  NO, use_lmargin ? LMargin : body_indent);
X--- 345,351 ----
X  		find_para(FORWARD);
X  		rl1 = max_line(l1, para_head);
X  		rl2 = min_line(l2, para_tail);
X! 		tailmark = MakeMark(para_tail, 0, M_FLOATER);
X  		DoJustify(rl1, (rl1 == l1) ? c1 : 0, rl2,
X  			  (rl2 == l2) ? c2 : length(rl2),
X  			  NO, use_lmargin ? LMargin : body_indent);
X***************
X*** 356,362 ****
X  	} while (l1 != 0 && l2 != rl2);
X  }
X  
X! do_rfill()
X  {
X  	Mark	*mp = CurMark();
X  	Line	*l1 = curline,
X--- 355,361 ----
X  	} while (l1 != 0 && l2 != rl2);
X  }
X  
X! do_rfill(ulm)
X  {
X  	Mark	*mp = CurMark();
X  	Line	*l1 = curline,
X***************
X*** 364,370 ****
X  	int	c1 = curchar,
X  		c2 = mp->m_char;
X  
X! 	use_lmargin = (exp_p != NO);
X  	(void) fixorder(&l1, &c1, &l2, &c2);
X  	DoJustify(l1, c1, l2, c2, NO, use_lmargin ? LMargin : 0);
X  }
X--- 363,369 ----
X  	int	c1 = curchar,
X  		c2 = mp->m_char;
X  
X! 	use_lmargin = ulm;
X  	(void) fixorder(&l1, &c1, &l2, &c2);
X  	DoJustify(l1, c1, l2, c2, NO, use_lmargin ? LMargin : 0);
X  }
X***************
X*** 403,411 ****
X  		nspace = 0;
X  
X  	if (diff > nspace)
X! 		DoTimes(DelPChar(), (diff - nspace));
X  	else if (diff < nspace)
X! 		DoTimes(Insert(' '), (nspace - diff));
X  }
X  
X  DoJustify(l1, c1, l2, c2, scrunch, indent)
X--- 402,410 ----
X  		nspace = 0;
X  
X  	if (diff > nspace)
X! 		del_char(BACKWARD, (diff - nspace));
X  	else if (diff < nspace)
X! 		insert_c(' ', (nspace - diff));
X  }
X  
X  DoJustify(l1, c1, l2, c2, scrunch, indent)
X***************
X*** 414,423 ****
X  {
X  	int	okay_char = -1;
X  	char	*cp;
X! 	Mark	*savedot = MakeMark(curline, curchar, FLOATER),
X  		*endmark;
X  
X- 	exp = 1;
X  	(void) fixorder(&l1, &c1, &l2, &c2);	/* l1/c1 will be before l2/c2 */
X  	DotTo(l1, c1);
X  	if (get_indent(l1) >= c1) {
X--- 413,421 ----
X  {
X  	int	okay_char = -1;
X  	char	*cp;
X! 	Mark	*savedot = MakeMark(curline, curchar, M_FLOATER),
X  		*endmark;
X  
X  	(void) fixorder(&l1, &c1, &l2, &c2);	/* l1/c1 will be before l2/c2 */
X  	DotTo(l1, c1);
X  	if (get_indent(l1) >= c1) {
X***************
X*** 427,474 ****
X  		}
X  		ToIndent();
X  	}
X! 	endmark = MakeMark(l2, c2, FLOATER);
X  
X  	for (;;) {
X! 		cp = StrIndex(1, linebuf, curchar, ' ');
X! 		if (cp == 0)
X! 			Eol();
X! 		else
X! 			curchar = (cp - linebuf);
X! 		if (curline == endmark->m_line && curchar >= endmark->m_char)
X! 			goto outahere;
X! 		if (eolp()) {
X! 			ins_str("  ", NO);
X! 			DelNChar();	/* delete line separator */
X! 			curchar -= 2;	/* back over the spaces */
X! 		}
X! 		/* at this point we are ALWAYS sitting right after
X! 		   a word - that is, just before some spaces or the
X! 		   end of the line */
X! 		if (calc_pos(linebuf, curchar) <= RMargin) {
X  			okay_char = curchar;
X  			do_space();
X- 			continue;
X  		}
X- 
X- 		/* if we get here, we have done all we can for
X- 		   this line - now we split the line, or just move
X- 		   to the next one */
X  		if (okay_char > 0)
X  			curchar = okay_char;			
X  		if (curline == endmark->m_line && curchar >= endmark->m_char)
X  			goto outahere;
X! 		/* can't fit in small margin, so we do the best we can */
X  		if (eolp()) {
X! 			line_move(FORWARD, NO);
X  			n_indent(indent);
X  		} else {
X- 			/* insert a line break - line WAS too long */
X  			DelWtSpace();
X  			LineInsert(1);
X  			if (scrunch && TwoBlank()) {
X  				Eol();
X! 				DelNChar();
X  			}
X  			n_indent(indent);
X  		}
X--- 425,464 ----
X  		}
X  		ToIndent();
X  	}
X! 	endmark = MakeMark(l2, c2, M_FLOATER);
X  
X  	for (;;) {
X! 		while (calc_pos(linebuf, curchar) < RMargin) {
X! 			if (curline == endmark->m_line && curchar >= endmark->m_char)
X! 				goto outahere;
X  			okay_char = curchar;
X+ 			if (eolp()) {
X+ 				del_char(FORWARD, 1);	/* Delete line separator. */
X+ 				ins_str("  ", NO);
X+ 			} else {
X+ 				cp = StrIndex(1, linebuf, curchar + 1, ' ');
X+ 				if (cp == 0)
X+ 					Eol();
X+ 				else
X+ 					curchar = (cp - linebuf);
X+ 			}
X  			do_space();
X  		}
X  		if (okay_char > 0)
X  			curchar = okay_char;			
X  		if (curline == endmark->m_line && curchar >= endmark->m_char)
X  			goto outahere;
X! 
X! 		/* Can't fit in small margin, so we do the best we can. */
X  		if (eolp()) {
X! 			line_move(FORWARD, 1, NO);
X  			n_indent(indent);
X  		} else {
X  			DelWtSpace();
X  			LineInsert(1);
X  			if (scrunch && TwoBlank()) {
X  				Eol();
X! 				del_char(FORWARD, 1);
X  			}
X  			n_indent(indent);
X  		}
X***************
X*** 486,492 ****
X  
X  DoPara(dir)
X  {
X! 	register int	num = exp,
X  			first_time = TRUE;	
X  
X  	while (--num >= 0) {
X--- 476,482 ----
X  
X  DoPara(dir)
X  {
X! 	register int	num = arg_value(),
X  			first_time = TRUE;	
X  
X  	while (--num >= 0) {
X***************
X*** 495,501 ****
X  		    ((!first_time) || ((para_head == curline) && bolp()))) {
X  		    	if (bobp())
X  		    		complain((char *) 0);
X! 			BackChar();
X  			first_time = !first_time;
X  			goto tryagain;
X  		}
X--- 485,491 ----
X  		    ((!first_time) || ((para_head == curline) && bolp()))) {
X  		    	if (bobp())
X  		    		complain((char *) 0);
X! 			b_char(1);
X  			first_time = !first_time;
X  			goto tryagain;
X  		}
X***************
X*** 502,508 ****
X  		SetLine((dir == BACKWARD) ? para_head : para_tail);
X  		if (dir == BACKWARD && !firstp(curline) &&
X  		    i_blank(curline->l_prev))
X! 			line_move(BACKWARD, NO);
X  		else if (dir == FORWARD) {
X  			if (lastp(curline)) {
X  				Eol();
X--- 492,498 ----
X  		SetLine((dir == BACKWARD) ? para_head : para_tail);
X  		if (dir == BACKWARD && !firstp(curline) &&
X  		    i_blank(curline->l_prev))
X! 			line_move(BACKWARD, 1, NO);
X  		else if (dir == FORWARD) {
X  			if (lastp(curline)) {
X  				Eol();
X***************
X*** 509,515 ****
X  				break;
X  			}
X  			/* otherwise */
X! 			line_move(FORWARD, NO);
X  		}
X  	}
X  }
X--- 499,505 ----
X  				break;
X  			}
X  			/* otherwise */
X! 			line_move(FORWARD, 1, NO);
X  		}
X  	}
X  }
Xdiff -c ojove/proc.c jove/proc.c
X*** ojove/proc.c	Thu Jul 16 09:14:48 1987
X--- jove/proc.c	Thu Jun 25 09:45:20 1987
X***************
X*** 124,130 ****
X  	}
X  	if (cur_error != 0)
X  		ShowErr();
X- 	exp = 1;
X  }
X  
X  /* Free up all the errors */
X--- 124,129 ----
X***************
X*** 145,153 ****
X  		noerrs[] = "No errors!";
X  
X  private
X! toerror(forward)
X  {
X- 	register int	i;
X  	register struct error	*e = cur_error;
X  
X  	if (e == 0)
X--- 144,151 ----
X  		noerrs[] = "No errors!";
X  
X  private
X! toerror(forward, num)
X  {
X  	register struct error	*e = cur_error;
X  
X  	if (e == 0)
X***************
X*** 156,162 ****
X  	    (!forward && (e->er_prev == 0)))
X  		complain(errbounds, forward ? "last" : "first");
X  
X! 	for (i = 0; i < exp; i++) {
X  		if ((e = forward ? e->er_next : e->er_prev) == 0)
X  			break;
X  		cur_error = e;
X--- 154,160 ----
X  	    (!forward && (e->er_prev == 0)))
X  		complain(errbounds, forward ? "last" : "first");
X  
X! 	while (--num >= 0) {
X  		if ((e = forward ? e->er_next : e->er_prev) == 0)
X  			break;
X  		cur_error = e;
X***************
X*** 187,194 ****
X  ToError(forward)
X  {
X  	do {
X! 		toerror(forward);
X! 		exp = 1;
X  	} while (!okay_error());
X  	ShowErr();
X  }
X--- 185,191 ----
X  ToError(forward)
X  {
X  	do {
X! 		toerror(forward, arg_value());
X  	} while (!okay_error());
X  	ShowErr();
X  }
X***************
X*** 293,303 ****
X  	   default command and let the person decide. */
X  
X  	compilation = (sindex("make", make_cmd) || sindex("cc", make_cmd));
X! 	if (exp_p || !compilation) {
X  		if (!compilation) {
X  			rbell();
X! 			Inputp = make_cmd;	/* insert the default for the
X! 						   user */
X  		}
X  		null_ncpy(make_cmd, ask(make_cmd, "Compilation command: "),
X  				sizeof (make_cmd) - 1);
X--- 290,299 ----
X  	   default command and let the person decide. */
X  
X  	compilation = (sindex("make", make_cmd) || sindex("cc", make_cmd));
X! 	if (is_an_arg() || !compilation) {
X  		if (!compilation) {
X  			rbell();
X! 			Inputp = make_cmd;	/* insert the default for the user */
X  		}
X  		null_ncpy(make_cmd, ask(make_cmd, "Compilation command: "),
X  				sizeof (make_cmd) - 1);
X***************
X*** 367,373 ****
X  					  curline, curchar);
X  		}
X  		SetBuf(wordsb);
X! 		line_move(FORWARD, NO);
X  	}
X  	add_mess("Done.");
X  	SetBuf(buftospel);
X--- 363,369 ----
X  					  curline, curchar);
X  		}
X  		SetBuf(wordsb);
X! 		line_move(FORWARD, 1, NO);
X  	}
X  	add_mess("Done.");
X  	SetBuf(buftospel);
X***************
X*** 378,387 ****
X  
X  ShToBuf()
X  {
X! 	char	bufname[100];
X  
X  	strcpy(bufname, ask((char *) 0, "Buffer: "));
X! 	DoShell(bufname, ask(ShcomBuf, "Command: "));
X  }
X  
X  ShellCom()
X--- 374,385 ----
X  
X  ShToBuf()
X  {
X! 	char	bufname[128],
X! 		cmd[128];
X  
X  	strcpy(bufname, ask((char *) 0, "Buffer: "));
X! 	strcpy(cmd, ask(ShcomBuf, "Command: "));
X! 	DoShell(bufname, cmd);
X  }
X  
X  ShellCom()
X***************
X*** 402,409 ****
X  	Window	*savewp = curwind;
X  	int	status;
X  
X! 	exp = 1;
X! 	status = UnixToBuf(bufname, YES, 0, !exp_p, Shell,
X  			   ShFlags, command, (char *) 0);
X  	com_finish(status, command);
X  	SetWind(savewp);
X--- 400,406 ----
X  	Window	*savewp = curwind;
X  	int	status;
X  
X! 	status = UnixToBuf(bufname, YES, 0, !is_an_arg(), Shell,
X  			   ShFlags, command, (char *) 0);
X  	com_finish(status, command);
X  	SetWind(savewp);
X***************
X*** 465,471 ****
X     to fix everything up after we're done.  (Usually there's nothing to
X     fix up.) */
X  
X! /* VARARGS5 */
X  
X  UnixToBuf(bufname, disp, wsize, clobber, va_alist)
X  char	*bufname;
X--- 462,468 ----
X     to fix everything up after we're done.  (Usually there's nothing to
X     fix up.) */
X  
X! /* VARARGS4 */
X  
X  UnixToBuf(bufname, disp, wsize, clobber, va_alist)
X  char	*bufname;
X***************
X*** 517,523 ****
X  #else
X  	old_int = signal(SIGINT, SIG_IGN),
X  #endif
X- 	exp = 1;
X  	dopipe(p);
X  	pid = fork();
X  	if (pid == -1) {
X--- 514,519 ----
X***************
X*** 621,633 ****
X  {
X  	Mark	*m = CurMark();
X  	char	*tname = mktemp("/tmp/jfilterXXXXXX"),
X! 		combuf[130];
X  	Window	*save_wind = curwind;
X! 	int	status;
X  	File	*fp;
X  
X-     CATCH
X  	fp = open_file(tname, iobuff, F_WRITE, COMPLAIN, QUIET);
X  	putreg(fp, m->m_line, m->m_char, curline, curchar, YES);
X  	DelReg();
X  	sprintf(combuf, "%s < %s", cmd, tname);
X--- 617,630 ----
X  {
X  	Mark	*m = CurMark();
X  	char	*tname = mktemp("/tmp/jfilterXXXXXX"),
X! 		combuf[128];
X  	Window	*save_wind = curwind;
X! 	int	status,
X! 		error = NO;
X  	File	*fp;
X  
X  	fp = open_file(tname, iobuff, F_WRITE, COMPLAIN, QUIET);
X+     CATCH
X  	putreg(fp, m->m_line, m->m_char, curline, curchar, YES);
X  	DelReg();
X  	sprintf(combuf, "%s < %s", cmd, tname);
X***************
X*** 634,646 ****
X  	status = UnixToBuf(outbuf->b_name, NO, 0, outbuf->b_type == B_SCRATCH,
X  			   Shell, ShFlags, combuf, (char *) 0);
X      ONERROR
X! 	;	/* Do nothing ... but fall through and delete the tmp
X! 		   file. */
X      ENDCATCH
X  	f_close(fp);
X  	(void) unlink(tname);
X  	SetWind(save_wind);
X! 	com_finish(status, combuf);
X  }
X  
X  isprocbuf(bufname)
X--- 631,643 ----
X  	status = UnixToBuf(outbuf->b_name, NO, 0, outbuf->b_type == B_SCRATCH,
X  			   Shell, ShFlags, combuf, (char *) 0);
X      ONERROR
X! 	error = YES;
X      ENDCATCH
X  	f_close(fp);
X  	(void) unlink(tname);
X  	SetWind(save_wind);
X! 	if (error == NO)
X! 		com_finish(status, combuf);
X  }
X  
X  isprocbuf(bufname)
XOnly in ojove: rcs.output
Xdiff -c ojove/re.c jove/re.c
X*** ojove/re.c	Thu Jul 16 09:14:53 1987
X--- jove/re.c	Wed Jun 24 12:43:25 1987
X***************
X*** 26,50 ****
X  	WrapScan = 0,
X  	UseRE = 0;
X  
X- private char	CaseEquiv[] = {
X- 	'\000',	'\001',	'\002',	'\003',	'\004',	'\005',	'\006',	'\007',
X- 	'\010',	'\011',	'\012',	'\013',	'\014',	'\015',	'\016',	'\017',
X- 	'\020',	'\021',	'\022',	'\023',	'\024',	'\025',	'\026',	'\027',
X- 	'\030',	'\031',	'\032',	'\033',	'\034',	'\035',	'\036',	'\037',
X- 	'\040',	'!',	'"',	'#',	'$',	'%',	'&',	'\'',
X- 	'(',	')',	'*',	'+',	',',	'-',	'.',	'/',
X- 	'0',	'1',	'2',	'3',	'4',	'5',	'6',	'7',
X- 	'8',	'9',	':',	';',	'<',	'=',	'>',	'?',
X- 	'@',	'A',	'B',	'C',	'D',	'E',	'F',	'G',
X- 	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
X- 	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
X- 	'X',	'Y',	'Z',	'[',	'\\',	']',	'^',	'_',
X- 	'`',	'A',	'B',	'C',	'D',	'E',	'F',	'G',
X- 	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
X- 	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
X- 	'X',	'Y',	'Z',	'{',	'|',	'}',	'~',	'\177'
X- };
X- 
X  #define cind_cmp(a, b)	(CaseEquiv[a] == CaseEquiv[b])
X  
X  private int	REpeekc;
X--- 26,31 ----
X***************
X*** 738,747 ****
X  
X  	if (!delp) while (c = *repp++) {
X  		if (c == '\\') {
X! 			if ((c = *repp++) == '\0') {
X  				*tp++ = '\\';
X  	  			goto endchk;
X! 			} else if ((c = *repp++) >= '1' && c <= nparens + '1') {
X  				tp = insert(tp, endp, c - '1');
X  				continue;
X  			}
X--- 719,729 ----
X  
X  	if (!delp) while (c = *repp++) {
X  		if (c == '\\') {
X! 			c = *repp++;
X! 			if (c == '\0') {
X  				*tp++ = '\\';
X  	  			goto endchk;
X! 			} else if (c >= '1' && c <= nparens + '1') {
X  				tp = insert(tp, endp, c - '1');
X  				continue;
X  			}
X***************
X*** 786,792 ****
X  		repbuf[sizeof rep_str],
X  		*altbuf[NALTS];
X  	int	npars;
X! 	Mark	*m = MakeMark(curline, REbom, FLOATER);
X  
X  	message("Type C-X C-C to continue with query replace.");
X  
X--- 768,774 ----
X  		repbuf[sizeof rep_str],
X  		*altbuf[NALTS];
X  	int	npars;
X! 	Mark	*m = MakeMark(curline, REbom, M_FLOATER);
X  
X  	message("Type C-X C-C to continue with query replace.");
X  
X***************
X*** 801,807 ****
X  	byte_copy(sbuf, searchstr, sizeof searchstr);
X  	byte_copy(repbuf, rep_str, sizeof rep_str);
X  	byte_copy((char *) altbuf, (char *) alternates, sizeof alternates);
X! 	if (!exp_p)
X  		ToMark(m);
X  	DelMark(m);
X  }
X--- 783,789 ----
X  	byte_copy(sbuf, searchstr, sizeof searchstr);
X  	byte_copy(repbuf, rep_str, sizeof rep_str);
X  	byte_copy((char *) altbuf, (char *) alternates, sizeof alternates);
X! 	if (!is_an_arg())
X  		ToMark(m);
X  	DelMark(m);
X  }
Xdiff -c ojove/re1.c jove/re1.c
X*** ojove/re1.c	Thu Jul 16 09:14:58 1987
X--- jove/re1.c	Fri Jul 10 09:25:51 1987
X***************
X*** 8,15 ****
X  #include "jove.h"
X  #include "io.h"
X  #include "re.h"
X  
X! static
X  substitute(query, l1, char1, l2, char2)
X  Line	*l1,
X  	*l2;
X--- 8,17 ----
X  #include "jove.h"
X  #include "io.h"
X  #include "re.h"
X+ #include <sys/types.h>
X+ #include <sys/stat.h>
X  
X! private
X  substitute(query, l1, char1, l2, char2)
X  Line	*l1,
X  	*l2;
X***************
X*** 35,41 ****
X  			if (query) {
X  				message("Replace (Type '?' for help)? ");
X  reswitch:			redisplay();
X! 				switch (Upper(getchar())) {
X  				case '.':
X  					stop++;
X  					/* Fall into ... */
X--- 37,43 ----
X  			if (query) {
X  				message("Replace (Type '?' for help)? ");
X  reswitch:			redisplay();
X! 				switch (CharUpcase(getchar())) {
X  				case '.':
X  					stop++;
X  					/* Fall into ... */
X***************
X*** 51,57 ****
X  						goto nxtline;
X  					continue;
X  
X! 				case CTL(W):
X  					re_dosub(linebuf, YES);
X  					numdone++;
X  					offset = curchar = REbom;
X--- 53,59 ----
X  						goto nxtline;
X  					continue;
X  
X! 				case CTL('W'):
X  					re_dosub(linebuf, YES);
X  					numdone++;
X  					offset = curchar = REbom;
X***************
X*** 58,64 ****
X  					makedirty(curline);
X  					/* Fall into ... */
X  
X! 				case CTL(R):
X  				case 'R':
X  					RErecur();
X  					offset = curchar;
X--- 60,66 ----
X  					makedirty(curline);
X  					/* Fall into ... */
X  
X! 				case CTL('R'):
X  				case 'R':
X  					RErecur();
X  					offset = curchar;
X***************
X*** 65,71 ****
X  					lp = curline;
X  					continue;
X  
X! 				case CTL(U):
X  				case 'U':
X  					if (UNDO_lp == 0)
X  						continue;
X--- 67,73 ----
X  					lp = curline;
X  					continue;
X  
X! 				case CTL('U'):
X  				case 'U':
X  					if (UNDO_lp == 0)
X  						continue;
X***************
X*** 85,91 ****
X  				case 'Q':
X  					goto done;
X  
X! 				case CTL(L):
X  					RedrawDisplay();
X  					goto reswitch;
X  
X--- 87,93 ----
X  				case 'Q':
X  					goto done;
X  
X! 				case CTL('L'):
X  					RedrawDisplay();
X  					goto reswitch;
X  
X***************
X*** 110,116 ****
X  nxtline:			break;
X  		}
X  	}
X! 	SetMark();
X  done:	s_mess("%d substitution%n.", numdone, numdone);
X  }
X  
X--- 112,118 ----
X  nxtline:			break;
X  		}
X  	}
X! 	set_mark();
X  done:	s_mess("%d substitution%n.", numdone, numdone);
X  }
X  
X***************
X*** 117,126 ****
X  /* Prompt for search and replacement strings and do the substitution.  The
X     point is restored when we're done. */
X  
X! static
X  replace(query, inreg)
X  {
X! 	Mark	*save = MakeMark(curline, curchar, FLOATER),
X  		*m;
X  	char	*rep_ptr;
X  	Line	*l1 = curline,
X--- 119,128 ----
X  /* Prompt for search and replacement strings and do the substitution.  The
X     point is restored when we're done. */
X  
X! private
X  replace(query, inreg)
X  {
X! 	Mark	*save = MakeMark(curline, curchar, M_FLOATER),
X  		*m;
X  	char	*rep_ptr;
X  	Line	*l1 = curline,
X***************
X*** 166,174 ****
X  	replace(0, NO);
X  }
X  
X! /* C tags package. */
X  
X! static
X  lookup(searchbuf, filebuf, tag, file)
X  char	*searchbuf,
X  	*filebuf,
X--- 168,180 ----
X  	replace(0, NO);
X  }
X  
X! /* Lookup a tag in tag file FILE.  FILE is assumed to be sorted
X!    alphabetically.  The FASTTAGS code, which is implemented with
X!    a binary search, depends on this assumption.  If it's not true
X!    it is possible to comment out the fast tag code (which is clearly
X!    labeled) and everything else will just work. */
X  
X! private
X  lookup(searchbuf, filebuf, tag, file)
X  char	*searchbuf,
X  	*filebuf,
X***************
X*** 176,205 ****
X  	*file;
X  {
X  	register int	taglen = strlen(tag);
X! 	char	line[128],
X! 		pattern[100];
X! 	File	*fp;
X  
X  	fp = open_file(file, iobuff, F_READ, !COMPLAIN, QUIET);
X  	if (fp == NIL)
X  		return 0;
X! 	sprintf(pattern, "^%s[^\t]*\t\\([^\t]*\\)\t[?/]\\(.*\\)[?/]$", tag);
X  	while (f_gets(fp, line, sizeof line) != EOF) {
X! 		if (line[0] != *tag || strncmp(tag, line, taglen) != 0)
X  			continue;
X! 		if (!LookingAt(pattern, line, 0)) {
X  			complain("I thought I saw it!");
X  			break;
X  		} else {
X  			putmatch(2, searchbuf, 100);
X! 			putmatch(1, filebuf, 100);
X! 			close_file(fp);
X! 			return 1;
X  		}
X  	}
X! 	f_close(fp);
X! 	s_mess("Can't find tag \"%s\".", tag);
X! 	return 0;
X  }
X  
X  char	TagFile[128] = "./tags";
X--- 182,267 ----
X  	*file;
X  {
X  	register int	taglen = strlen(tag);
X! 	char	line[BUFSIZ],
X! 		pattern[128];
X! 	register File	*fp;
X! 	struct stat	stbuf;
X! 	int	fast = YES,
X! 		success = NO;
X! 	register off_t	lower, upper;
X  
X+ 	sprintf(pattern, "^%s[^\t]*\t*\\([^\t]*\\)\t*[?/]\\([^?/]*\\)[?/]", tag);
X  	fp = open_file(file, iobuff, F_READ, !COMPLAIN, QUIET);
X  	if (fp == NIL)
X  		return 0;
X! 
X! 	/* ********BEGIN FAST TAG CODE******** */
X! 
X! 	if (stat(file, &stbuf) < 0)
X! 		fast = NO;
X! 	else {
X! 		lower = 0;
X! 		upper = stbuf.st_size;
X! 		if (upper - lower < BUFSIZ)
X! 			fast = NO;
X! 	}
X! 	if (fast == YES) for (;;) {
X! 		off_t	mid;
X! 		int	whichway;
X! 
X! 		if (upper - lower < BUFSIZ) {
X! 			f_seek(fp, lower);
X! 			break;			/* stop this nonsense */
X! 		}
X! 		mid = (lower + upper) / 2;
X! 		f_seek(fp, mid);
X! 		f_toNL(fp);
X! 		if (f_gets(fp, line, sizeof line) == EOF)
X! 			break;
X! 		whichway = strncmp(line, tag, taglen);
X! 		if (whichway < 0) {
X! 			lower = mid;
X! 			continue;
X! 		} else if (whichway > 0) {
X! 			upper = mid;
X! 			continue;
X! 		} else {
X! 			if (strcmp(tag, line) == 0)	/* exact match */
X! 				goto found;
X! 			goto look_harder;
X! 		}
X! 	}
X! 	f_toNL(fp);
X! 	/* END FAST TAG CODE */
X! 
X  	while (f_gets(fp, line, sizeof line) != EOF) {
X! 		int	cmp;
X! 
X! look_harder:	if (line[0] > *tag)
X! 			break;
X! 		else if ((cmp = strncmp(line, tag, taglen)) > 0)
X! 			break;
X! 		else if (cmp < 0)
X  			continue;
X! 		/* if we get here, we've found the match */
X! found:		if (!LookingAt(pattern, line, 0)) {
X  			complain("I thought I saw it!");
X  			break;
X  		} else {
X+ 			putmatch(1, filebuf, FILESIZE);
X  			putmatch(2, searchbuf, 100);
X! 			success = YES;
X! 			if (strcmp(tag, line) == 0)	/* exact match */
X! 				break;
X! 			continue;
X  		}
X  	}
X! 	close_file(fp);
X! 		
X! 	if (success == NO)
X! 		s_mess("Can't find tag \"%s\".", tag);
X! 
X! 	return success;
X  }
X  
X  char	TagFile[128] = "./tags";
X***************
X*** 223,235 ****
X  		tagfname = TagFile;
X  	if (lookup(sstr, filebuf, tag, tagfname) == 0)
X  		return;
X! 	SetMark();
X  	b = do_find(curwind, filebuf, 0);
X  	if (curbuf != b)
X  		SetABuf(curbuf);
X  	SetBuf(b);
X  	if ((bp = dosearch(sstr, BACKWARD, 0)) == 0 &&
X! 	    (WrapScan || ((bp = dosearch(sstr, FORWARD, 0)) == 0)))
X  		message("Well, I found the file, but the tag is missing.");
X  	else
X  		SetDot(bp);
X--- 285,297 ----
X  		tagfname = TagFile;
X  	if (lookup(sstr, filebuf, tag, tagfname) == 0)
X  		return;
X! 	set_mark();
X  	b = do_find(curwind, filebuf, 0);
X  	if (curbuf != b)
X  		SetABuf(curbuf);
X  	SetBuf(b);
X  	if ((bp = dosearch(sstr, BACKWARD, 0)) == 0 &&
X! 	    ((bp = dosearch(sstr, FORWARD, 0)) == 0))
X  		message("Well, I found the file, but the tag is missing.");
X  	else
X  		SetDot(bp);
X***************
X*** 237,243 ****
X  
X  FindTag()
X  {
X! 	int	localp = !exp_p;
X  	char	tag[128];
X  
X  	strcpy(tag, ask((char *) 0, ProcFmt));
X--- 299,305 ----
X  
X  FindTag()
X  {
X! 	int	localp = !is_an_arg();
X  	char	tag[128];
X  
X  	strcpy(tag, ask((char *) 0, ProcFmt));
X***************
X*** 260,266 ****
X  		c2++;
X  
X  	null_ncpy(tagname, linebuf + c1, c2 - c1);
X! 	find_tag(tagname, !exp_p);
X  }
X  
X  /* I-search returns a code saying what to do:
X--- 322,328 ----
X  		c2++;
X  
X  	null_ncpy(tagname, linebuf + c1, c2 - c1);
X! 	find_tag(tagname, !is_an_arg());
X  }
X  
X  /* I-search returns a code saying what to do:
X***************
X*** 282,288 ****
X  		*incp = 0;
X  int	SExitChar = CR;
X  
X! #define cmp_char(a, b)	((a) == (b) || (CaseIgnore && (Upper(a) == Upper(b))))
X  
X  static Bufpos *
X  doisearch(dir, c, failing)
X--- 344,350 ----
X  		*incp = 0;
X  int	SExitChar = CR;
X  
X! #define cmp_char(a, b)	((a) == (b) || (CaseIgnore && (CharUpcase(a) == CharUpcase(b))))
X  
X  static Bufpos *
X  doisearch(dir, c, failing)
X***************
X*** 294,300 ****
X  	Bufpos	*bp;
X  	extern int	okay_wrap;
X  
X! 	if (c == CTL(S) || c == CTL(R))
X  		goto dosrch;
X  
X  	if (failing)
X--- 356,362 ----
X  	Bufpos	*bp;
X  	extern int	okay_wrap;
X  
X! 	if (c == CTL('S') || c == CTL('R'))
X  		goto dosrch;
X  
X  	if (failing)
X***************
X*** 338,344 ****
X  		SetDot(&save_env);
X  	else {
X  		if (LineDist(curline, save_env.p_line) >= MarkThresh)
X! 			DoSetMark(save_env.p_line, save_env.p_char);
X  	}
X  	setsearch(ISbuf);
X  }
X--- 400,406 ----
X  		SetDot(&save_env);
X  	else {
X  		if (LineDist(curline, save_env.p_line) >= MarkThresh)
X! 			do_set_mark(save_env.p_line, save_env.p_char);
X  	}
X  	setsearch(ISbuf);
X  }
X***************
X*** 385,391 ****
X  		case BS:
X  			return DELETE;
X  
X! 		case CTL(G):
X  			/* If we're failing, we backup until we're no longer
X  			   failing or we've reached the beginning; else, we
X  			   just about the search and go back to the start. */
X--- 447,453 ----
X  		case BS:
X  			return DELETE;
X  
X! 		case CTL('G'):
X  			/* If we're failing, we backup until we're no longer
X  			   failing or we've reached the beginning; else, we
X  			   just about the search and go back to the start. */
X***************
X*** 393,402 ****
X  				return BACKUP;
X  			return TOSTART;
X  
X! 		case CTL(\\):
X! 			c = CTL(S);
X! 		case CTL(S):
X! 		case CTL(R):
X  			/* If this is the first time through and we have a
X  			   search string left over from last time, use that
X  			   one now. */
X--- 455,464 ----
X  				return BACKUP;
X  			return TOSTART;
X  
X! 		case CTL('\\'):
X! 			c = CTL('S');
X! 		case CTL('S'):
X! 		case CTL('R'):
X  			/* If this is the first time through and we have a
X  			   search string left over from last time, use that
X  			   one now. */
X***************
X*** 404,410 ****
X  				strcpy(ISbuf, getsearch());
X  				incp = &ISbuf[strlen(ISbuf)];
X  			}
X! 			ndir = (c == CTL(S)) ? FORWARD : BACKWARD;
X  			/* If we're failing and we're not changing our
X  			   direction, don't recur since there's no way
X  			   the search can work. */
X--- 466,472 ----
X  				strcpy(ISbuf, getsearch());
X  				incp = &ISbuf[strlen(ISbuf)];
X  			}
X! 			ndir = (c == CTL('S')) ? FORWARD : BACKWARD;
X  			/* If we're failing and we're not changing our
X  			   direction, don't recur since there's no way
X  			   the search can work. */
X***************
X*** 423,430 ****
X  			add_mess("\\");
X  			/* Fall into ... */
X  
X! 		case CTL(Q):
X! 		case CTL(^):
X  			add_mess("");
X  			c = getch() | 0400;
X  			/* Fall into ... */
X--- 485,492 ----
X  			add_mess("\\");
X  			/* Fall into ... */
X  
X! 		case CTL('Q'):
X! 		case CTL('^'):
X  			add_mess("");
X  			c = getch() | 0400;
X  			/* Fall into ... */
END_OF_FILE
if test 50121 -ne `wc -c <'jove.pch.3'`; then
    echo shar: \"'jove.pch.3'\" unpacked with wrong size!
fi
# end of 'jove.pch.3'
fi
echo shar: End of archive 3 \(of 4\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
