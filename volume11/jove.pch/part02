Subject:  v11i046:  Jove upgrade kit, Part02/04
Newsgroups: comp.sources.unix
Sender: sources
Approved: rs@uunet.UU.NET

Submitted-by: Jonathan Payne  <jpayne@cs.rochester.edu>
Posting-number: Volume 11, Issue 46
Archive-name: jove.pch/Part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 4)."
# Contents:  jove.pch.2
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'jove.pch.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jove.pch.2'\"
else
echo shar: Extracting \"'jove.pch.2'\" \(43705 characters\)
sed "s/^X//" >'jove.pch.2' <<'END_OF_FILE'
Xdiff -c ojove/fp.c jove/fp.c
X*** ojove/fp.c	Thu Jul 16 09:14:23 1987
X--- jove/fp.c	Fri Jun 12 10:30:44 1987
X***************
X*** 7,12 ****
X--- 7,13 ----
X  
X  #include "jove.h"
X  #include "io.h"
X+ #include "ctype.h"
X  #include "termcap.h"
X  #include <sys/stat.h>
X  #include <sys/file.h>
X***************
X*** 14,22 ****
X  
X  #define MAXFILES	20	/* good enough for my purposes */
X  
X! static File	_openfiles[MAXFILES] = {0};
X  
X! static File *
X  f_alloc(name, flags, fd, buffer, buf_size)
X  char	*name,
X  	*buffer;
X--- 15,23 ----
X  
X  #define MAXFILES	20	/* good enough for my purposes */
X  
X! private File	_openfiles[MAXFILES] = {0};
X  
X! private File *
X  f_alloc(name, flags, fd, buffer, buf_size)
X  char	*name,
X  	*buffer;
X***************
X*** 106,111 ****
X--- 107,114 ----
X  		return EOF;
X  	fp->f_ptr = fp->f_base;
X  	fp->f_cnt = read(fp->f_fd, fp->f_base, fp->f_bufsize);
X+ 	while (fp->f_cnt == -1 && errno == EINTR)
X+ 		fp->f_cnt = read(fp->f_fd, fp->f_base, fp->f_bufsize);
X  	if (fp->f_cnt == -1) {
X  		printf("[Read error %d]", errno);
X  		fp->f_flags |= F_ERR;
X***************
X*** 147,152 ****
X--- 150,166 ----
X  	_flush(EOF, fp);
X  }
X  
X+ f_seek(fp, offset)
X+ register File	*fp;
X+ off_t	offset;
X+ {
X+ 	if (fp->f_flags & F_WRITE)
X+ 		flush(fp);
X+ 	fp->f_cnt = 0;		/* next read will filbuf(), next write
X+ 				   will flush() with no bad effects */
X+ 	lseek(fp->f_fd, (long) offset, L_SET);
X+ }
X+ 
X  _flush(c, fp)
X  register File	*fp;
X  {
X***************
X*** 182,188 ****
X  		return EOF;
X  	while (((c = getc(fp)) != EOF) && (c != '\n')) {
X  		if (c == NULL)
X! 			continue;	/* sorry we don't read nulls */
X  		if (cp >= endp) {
X  			add_mess(" [Line too long]");
X  			rbell();
X--- 196,202 ----
X  		return EOF;
X  	while (((c = getc(fp)) != EOF) && (c != '\n')) {
X  		if (c == NULL)
X! 			break;		/* sorry we don't read nulls */
X  		if (cp >= endp) {
X  			add_mess(" [Line too long]");
X  			rbell();
X***************
X*** 201,215 ****
X  	return NIL;	/* this means okay */
X  }
X  
X  /* Deals with output to the terminal, setting up the amount of characters
X     to be buffered depending on the output baud rate.  Why it's in a 
X     separate file I don't know ... */
X  
X! static char	one_buf;
X  
X  int	BufSize = 1;
X  
X! static File	_stdout = {1, 1, 1, F_WRITE, &one_buf, &one_buf};
X  File	*stdout = &_stdout;
X  
X  /* put a string with padding */
X--- 215,264 ----
X  	return NIL;	/* this means okay */
X  }
X  
X+ /* skip to beginning of next line, i.e., next read returns first
X+    character of new line */
X+ f_toNL(fp)
X+ register File	*fp;
X+ {
X+ 	register int	c;
X+ 
X+ 	if (fp->f_flags & F_EOF)
X+ 		return;
X+ 	while (((c = getc(fp)) != EOF) && (c != '\n'))
X+ 		;
X+ 	if (c == EOF)
X+ 		fp->f_flags |= F_EOF;
X+ }
X+ 
X+ f_readn(fp, addr, n)
X+ register File	*fp;
X+ register char	*addr;
X+ register int	n;
X+ {
X+ 	while (--n >= 0)
X+ 		*addr++ = getc(fp);
X+ }
X+ 
X+ f_getint(fp)
X+ File	*fp;
X+ {
X+ 	int	n = 0,
X+ 		c;
X+ 
X+ 	while (isdigit(c = getc(fp)))
X+ 		n = (n * 10) + c;
X+ 	return n;
X+ }
X+ 
X  /* Deals with output to the terminal, setting up the amount of characters
X     to be buffered depending on the output baud rate.  Why it's in a 
X     separate file I don't know ... */
X  
X! private char	one_buf;
X  
X  int	BufSize = 1;
X  
X! private File	_stdout = {1, 1, 1, F_WRITE, &one_buf, &one_buf};
X  File	*stdout = &_stdout;
X  
X  /* put a string with padding */
Xdiff -c ojove/funcdefs.c jove/funcdefs.c
X*** ojove/funcdefs.c	Thu Jul 16 09:14:24 1987
X--- jove/funcdefs.c	Fri Jun 12 12:25:57 1987
X***************
X*** 6,11 ****
X--- 6,12 ----
X   ************************************************************************/
X  
X  #include "jove.h"
X+ #include "ctype.h"
X  
X  #ifndef TXT_TO_C
X  extern int
X***************
X*** 97,103 ****
X  	ForChar(),
X  	FSexpr(),
X  	ForWord(),
X! 	FourTime(),
X  	GoLine(),
X  	GrowWindow(),
X  	IncFSearch(),
X--- 98,104 ----
X  	ForChar(),
X  	FSexpr(),
X  	ForWord(),
X! 	TimesFour(),
X  	GoLine(),
X  	GrowWindow(),
X  	IncFSearch(),
X***************
X*** 167,172 ****
X--- 168,174 ----
X  	SpelBuffer(),
X  #endif
X  	SplitWind(),
X+ 	GotoWind(),
X  	Remember(),
X  	Forget(),
X  	StrLength(),
X***************
X*** 354,363 ****
X--- 356,367 ----
X  	FUNCTION, "forward-sentence", WIRED_CMD(Eos),
X  	FUNCTION, "forward-word", WIRED_CMD(ForWord),
X  	DefMajor(FUNDAMENTAL), "fundamental-mode", 0,
X+ 	FUNCTION, "gather-numeric-argument", WIRED_CMD(TimesFour),
X  #ifdef LISP
X  	FUNCTION, "grind-s-expr", WIRED_CMD(GSexpr),
X  #endif
X  	FUNCTION, "goto-line", WIRED_CMD(GoLine),
X+ 	FUNCTION, "goto-window-with-buffer", WIRED_CMD(GotoWind),
X  	FUNCTION, "grow-window", WIRED_CMD(GrowWindow),
X  	FUNCTION, "handle-tab", WIRED_CMD(Tab),
X  	FUNCTION, "i-search-forward", WIRED_CMD(IncFSearch),
X***************
X*** 432,438 ****
X  	FUNCTION, "pushd", WIRED_CMD(Pushd),
X  	FUNCTION, "pwd", WIRED_CMD(prCWD),
X  #endif
X- 	FUNCTION, "quadruple-numeric-argument", WIRED_CMD(FourTime),
X  	FUNCTION, "query-replace-string", WIRED_CMD(QRepSearch),
X  #ifdef IPROCS
X  	FUNCTION, "quit-process", WIRED_CMD(ProcQuit),
X--- 436,441 ----
X***************
X*** 520,530 ****
X  		struct cmd	*which;
X  		int	cmdlen,
X  			found = 0;
X! 		static struct cmd	*cmdhash[1 + 26];
X  		static int	beenhere = NO;
X  
X  /* special case for prefix commands--only upper case ones */
X! #define hash(c)	((c == 'P') ? 0 : 1 + (c - 'a'))
X  
X  		/* initialize the hash table */
X  		if (beenhere == NO) {
X--- 523,533 ----
X  		struct cmd	*which;
X  		int	cmdlen,
X  			found = 0;
X! 		static struct cmd	*cmdhash[26];
X  		static int	beenhere = NO;
X  
X  /* special case for prefix commands--only upper case ones */
X! #define hash(c)	(c - 'a')
X  
X  		/* initialize the hash table */
X  		if (beenhere == NO) {
X***************
X*** 539,546 ****
X  		}
X  
X  		/* gather the cmd name */
X! 		while (((c = getch()) != EOF) && !index(" \t\r\n", c))
X  			*cp++ = c;
X  		if (c == EOF)
X  			return 0;
X  		*cp = '\0';
X--- 542,552 ----
X  		}
X  
X  		/* gather the cmd name */
X! 		while (((c = getch()) != EOF) && !index(" \t\r\n", c)) {
X! 			if (isupper(c))
X! 				c = tolower(c);
X  			*cp++ = c;
X+ 		}
X  		if (c == EOF)
X  			return 0;
X  		*cp = '\0';
X***************
X*** 549,555 ****
X  			return 0;
X  
X  		/* look it up (in the reduced search space) */
X! 		for (cmd = cmdhash[hash(cmdbuf[0])]; cmd->Name[0] == cmdbuf[0]; cmd++) {
X  			if (strncmp(cmd->Name, cmdbuf, cmdlen) == 0) {
X  				if (strcmp(cmd->Name, cmdbuf) == 0)
X  					return (data_obj *) cmd;
X--- 555,562 ----
X  			return 0;
X  
X  		/* look it up (in the reduced search space) */
X! 		if (islower(cmdbuf[0]))
X! 		    for (cmd = cmdhash[hash(cmdbuf[0])]; cmd != 0 && cmd->Name[0] == cmdbuf[0]; cmd++) {
X  			if (strncmp(cmd->Name, cmdbuf, cmdlen) == 0) {
X  				if (strcmp(cmd->Name, cmdbuf) == 0)
X  					return (data_obj *) cmd;
X***************
X*** 556,562 ****
X  				found++;
X  				which = cmd;
X  			}
X! 		}
X  		if (found > 1)
X  			complain("[\"%s\" ambiguous]", cmdbuf);
X  		else if (found == 0)
X--- 563,569 ----
X  				found++;
X  				which = cmd;
X  			}
X! 		    }
X  		if (found > 1)
X  			complain("[\"%s\" ambiguous]", cmdbuf);
X  		else if (found == 0)
X***************
X*** 565,581 ****
X  			return (data_obj *) which;
X  	} else {
X  		static char	*strings[(sizeof commands) / sizeof (commands[0])];
X! 		static int	beenhere = 0;
X  		register int	com;
X  
X! 		if (beenhere == 0) {
X  			register char	**strs = strings;
X! 			register struct cmd	*c = commands;
X  
X! 			beenhere = 1;
X! 			for (; c->Name; c++)
X  				*strs++ = c->Name;
X  			*strs = 0;
X  		}
X  
X  		if ((com = complete(strings, prompt, CASEIND)) < 0)
X--- 572,588 ----
X  			return (data_obj *) which;
X  	} else {
X  		static char	*strings[(sizeof commands) / sizeof (commands[0])];
X! 		static int	beenhere = NO;
X  		register int	com;
X  
X! 		if (beenhere == NO) {
X  			register char	**strs = strings;
X! 			register struct cmd	*c;
X  
X! 			for (c = commands; c->Name != 0; c++)
X  				*strs++ = c->Name;
X  			*strs = 0;
X+ 			beenhere = YES;
X  		}
X  
X  		if ((com = complete(strings, prompt, CASEIND)) < 0)
Xdiff -c ojove/insert.c jove/insert.c
X*** ojove/insert.c	Thu Jul 16 09:14:25 1987
X--- jove/insert.c	Fri Jul 10 09:25:50 1987
X***************
X*** 96,108 ****
X  		incrmt = (tabstop - (dotcol % tabstop));
X  		if (dotcol + incrmt > goal)
X  			break;
X! 		Insert('\t');
X  		dotcol += incrmt;
X  	}
X  	if (dotcol != goal)
X! 		DoTimes(Insert(' '), (goal - dotcol));
X! 	exp_p = NO;
X! 	exp = 1;
X  }
X  
X  SelfInsert()
X--- 96,106 ----
X  		incrmt = (tabstop - (dotcol % tabstop));
X  		if (dotcol + incrmt > goal)
X  			break;
X! 		insert_c('\t', 1);
X  		dotcol += incrmt;
X  	}
X  	if (dotcol != goal)
X! 		insert_c(' ', (goal - dotcol));
X  }
X  
X  SelfInsert()
X***************
X*** 116,132 ****
X  		register int	num,
X  				i;
X  
X! 		for (i = 0, num = exp, exp = 1; i < num; i++) {
X  			int	pos = calc_pos(linebuf, curchar);
X  
X  			if (!eolp()) {
X  				if (linebuf[curchar] == '\t') {
X  					if ((pos + 1) == ((pos + tabstop) - (pos % tabstop)))
X! 						DelNChar();
X  				} else
X! 					DelNChar();
X  			}
X! 			Insert(LastKeyStruck);
X  		}
X  	} else
X  		Insert(LastKeyStruck);
X--- 114,130 ----
X  		register int	num,
X  				i;
X  
X! 		for (i = 0, num = arg_value(); i < num; i++) {
X  			int	pos = calc_pos(linebuf, curchar);
X  
X  			if (!eolp()) {
X  				if (linebuf[curchar] == '\t') {
X  					if ((pos + 1) == ((pos + tabstop) - (pos % tabstop)))
X! 						del_char(FORWARD, 1);
X  				} else
X! 					del_char(FORWARD, 1);
X  			}
X! 			insert_c(LastKeyStruck, 1);
X  		}
X  	} else
X  		Insert(LastKeyStruck);
X***************
X*** 139,151 ****
X  
X  Insert(c)
X  {
X! 	if (exp <= 0)
X  		return;
X  	modify();
X  	makedirty(curline);
X! 	ins_c(c, linebuf, curchar, exp, LBSIZE);
X! 	IFixMarks(curline, curchar, curline, curchar + exp);
X! 	curchar += exp;
X  }	
X  
X  /* Tab in to the right place for C mode */
X--- 137,155 ----
X  
X  Insert(c)
X  {
X! 	insert_c(c, arg_value());
X! }
X! 
X! /* insert character C N times at point */
X! insert_c(c, n)
X! {
X! 	if (n <= 0)
X  		return;
X  	modify();
X  	makedirty(curline);
X! 	ins_c(c, linebuf, curchar, n, LBSIZE);
X! 	IFixMarks(curline, curchar, curline, curchar + n);
X! 	curchar += n;
X  }	
X  
X  /* Tab in to the right place for C mode */
X***************
X*** 159,165 ****
X  
X  		ToIndent();
X  		if (dotchar > curchar)
X! 			m = MakeMark(curline, dotchar, FLOATER);
X  		(void) lisp_indent();
X  		if (m) {
X  			ToMark(m);
X--- 163,169 ----
X  
X  		ToIndent();
X  		if (dotchar > curchar)
X! 			m = MakeMark(curline, dotchar, M_FLOATER);
X  		(void) lisp_indent();
X  		if (m) {
X  			ToMark(m);
X***************
X*** 177,191 ****
X  
X  QuotChar()
X  {
X! 	int	c;
X! 	extern int	alarmed;	/* If waitfor had to wait. */
X  
X! 	c = waitchar();
X! 	if (alarmed)
X  		message(key_strokes);
X! 	if (c == CTL(J))
X! 		LineInsert(exp);
X! 	else if (c != CTL(@))
X  		Insert(c);
X  }
X  
X--- 181,195 ----
X  
X  QuotChar()
X  {
X! 	int	c,
X! 		slow;
X  
X! 	c = waitchar(&slow);
X! 	if (slow)
X  		message(key_strokes);
X! 	if (c == CTL('J'))
X! 		LineInsert(arg_value());
X! 	else if (c != CTL('@'))
X  		Insert(c);
X  }
X  
X***************
X*** 215,224 ****
X  #endif
X  	SelfInsert();
X  	if (MinorMode(ShowMatch) && !charp() && !in_macro()) {
X! 		BackChar();	/* Back onto the ')' */
X  		if ((int) bp == -1)
X  			bp = m_paren(c, BACKWARD, NO, YES);
X! 		ForChar();
X  		if (bp != 0) {
X  			nx = in_window(curwind, bp->p_line);
X  			if (nx != -1) {		/* is visible */
X--- 219,228 ----
X  #endif
X  	SelfInsert();
X  	if (MinorMode(ShowMatch) && !charp() && !in_macro()) {
X! 		b_char(1);	/* Back onto the ')' */
X  		if ((int) bp == -1)
X  			bp = m_paren(c, BACKWARD, NO, YES);
X! 		f_char(1);
X  		if (bp != 0) {
X  			nx = in_window(curwind, bp->p_line);
X  			if (nx != -1) {		/* is visible */
X***************
X*** 264,279 ****
X  #ifdef LISP
X  	if (MajorMode(LISPMODE))
X  		DelWtSpace();
X  #endif
X! 	else if (blnkp(linebuf))
X  		DelWtSpace();
X  		
X  	/* If there is more than 2 blank lines in a row then don't make
X  	   a newline, just move down one. */
X! 	if (exp == 1 && eolp() && TwoBlank())
X  		SetLine(curline->l_next);
X  	else
X! 		LineInsert(exp);
X  
X  	if (indentp)
X  #ifdef LISP
X--- 268,284 ----
X  #ifdef LISP
X  	if (MajorMode(LISPMODE))
X  		DelWtSpace();
X+ 	else
X  #endif
X! 	    if (blnkp(linebuf))
X  		DelWtSpace();
X  		
X  	/* If there is more than 2 blank lines in a row then don't make
X  	   a newline, just move down one. */
X! 	if (arg_value() == 1 && eolp() && TwoBlank())
X  		SetLine(curline->l_next);
X  	else
X! 		LineInsert(arg_value());
X  
X  	if (indentp)
X  #ifdef LISP
X***************
X*** 292,298 ****
X  	int	llen;
X  
X  	if (*str == 0)
X! 		return;	/* ain't nothing to insert! */
X  	DOTsave(&save);
X  	llen = strlen(linebuf);
X  	while (c = *str++) {
X--- 297,303 ----
X  	int	llen;
X  
X  	if (*str == 0)
X! 		return;		/* ain't nothing to insert! */
X  	DOTsave(&save);
X  	llen = strlen(linebuf);
X  	while (c = *str++) {
X***************
X*** 314,328 ****
X  	makedirty(curline);
X  }
X  
X! OpenLine()
X  {
X  	Bufpos	dot;
X  
X  	DOTsave(&dot);
X! 	LineInsert(exp);	/* Open the lines... */
X  	SetDot(&dot);
X  }
X  
X  /* Take the region FLINE/FCHAR to TLINE/TCHAR and insert it at
X     ATLINE/ATCHAR in WHATBUF. */
X  
X--- 319,338 ----
X  	makedirty(curline);
X  }
X  
X! open_lines(n)
X  {
X  	Bufpos	dot;
X  
X  	DOTsave(&dot);
X! 	LineInsert(n);	/* Open the lines... */
X  	SetDot(&dot);
X  }
X  
X+ OpenLine()
X+ {
X+ 	open_lines(arg_value());
X+ }
X+ 
X  /* Take the region FLINE/FCHAR to TLINE/TCHAR and insert it at
X     ATLINE/ATCHAR in WHATBUF. */
X  
X***************
X*** 392,398 ****
X  
X  	/* Now must find a recently killed region. */
X  
X! 	if (exp < 0)
X  		dir = 1;
X  
X  	killptr += dir;
X--- 402,408 ----
X  
X  	/* Now must find a recently killed region. */
X  
X! 	if (arg_value() < 0)
X  		dir = 1;
X  
X  	killptr += dir;
X***************
X*** 468,474 ****
X  	}
X  }
X  
X! static
X  newchunk()
X  {
X  	register Line	*newline;
X--- 478,484 ----
X  	}
X  }
X  
X! private
X  newchunk()
X  {
X  	register Line	*newline;
X***************
X*** 520,526 ****
X  /* Remove the free lines, in chunk c, from the free list because they are
X     no longer free. */
X  
X! static
X  remfreelines(c)
X  register struct chunk	*c;
X  {
X--- 530,536 ----
X  /* Remove the free lines, in chunk c, from the free list because they are
X     no longer free. */
X  
X! private
X  remfreelines(c)
X  register struct chunk	*c;
X  {
X***************
X*** 584,595 ****
X  	DOTsave(&dot);
X  	FSexpr();
X  	DOTsave(&end);
X- 	exp = 1;
X  	SetDot(&dot);
X  	for (;;) {
X  		if (curline == end.p_line)
X  			break;
X! 		line_move(FORWARD, NO);
X  		if (!blnkp(linebuf))
X  			(void) lisp_indent();
X  	}
X--- 594,604 ----
X  	DOTsave(&dot);
X  	FSexpr();
X  	DOTsave(&end);
X  	SetDot(&dot);
X  	for (;;) {
X  		if (curline == end.p_line)
X  			break;
X! 		line_move(FORWARD, 1, NO);
X  		if (!blnkp(linebuf))
X  			(void) lisp_indent();
X  	}
X***************
X*** 656,662 ****
X  
X  	DOTsave(&savedot);
X  	SetDot(bp);
X! 	DoTimes(ForChar(), 1);
X  	if (linebuf[curchar] != '(') {
X  		register Word	*wp;
X  
X--- 665,671 ----
X  
X  	DOTsave(&savedot);
X  	SetDot(bp);
X! 	f_char(1);
X  	if (linebuf[curchar] != '(') {
X  		register Word	*wp;
X  
X***************
X*** 669,675 ****
X  			int	c_char = curchar;
X  
X  			WITH_TABLE(curbuf->b_major)
X! 				ForWord();
X  			END_TABLE();
X  			if (LookingAt("[ \t]*;\\|[ \t]*$", linebuf, curchar))
X  				curchar = c_char;
X--- 678,684 ----
X  			int	c_char = curchar;
X  
X  			WITH_TABLE(curbuf->b_major)
X! 				f_word(1);
X  			END_TABLE();
X  			if (LookingAt("[ \t]*;\\|[ \t]*$", linebuf, curchar))
X  				curchar = c_char;
Xdiff -c ojove/io.c jove/io.c
X*** ojove/io.c	Thu Jul 16 09:14:28 1987
X--- jove/io.c	Fri Jun 19 16:00:59 1987
X***************
X*** 107,115 ****
X  	}
X  	DOTsave(&save);
X  	dofread(fp);
X! 	SetDot(&save);
X! 	if (is_insert && io_chars > 0)
X  		modify();
X  	getDOT();
X  	close_file(fp);
X  }
X--- 107,117 ----
X  	}
X  	DOTsave(&save);
X  	dofread(fp);
X! 	if (is_insert && io_chars > 0) {
X  		modify();
X+ 		set_mark();
X+ 	}
X+ 	SetDot(&save);
X  	getDOT();
X  	close_file(fp);
X  }
X***************
X*** 121,127 ****
X  	int	xeof = 0;
X  	Line	*savel = curline;
X  	int	savec = curchar;
X! 	disk_line	f_getputl() ;
X  
X  	strcpy(end, linebuf + curchar);
X  	xeof = f_gets(fp, linebuf + curchar, LBSIZE - curchar);
X--- 123,129 ----
X  	int	xeof = 0;
X  	Line	*savel = curline;
X  	int	savec = curchar;
X! 	extern disk_line	f_getputl();
X  
X  	strcpy(end, linebuf + curchar);
X  	xeof = f_gets(fp, linebuf + curchar, LBSIZE - curchar);
X***************
X*** 157,169 ****
X  #ifndef CHDIR
X  
X  char *
X! pr_name(fname)
X  char	*fname;
X  {
X  	if (fname == 0)
X  		return 0;
X  
X! 	if (strncmp(fname, HomeDir, HomeLen) == 0) {
X  		static char	name_buf[100];
X  
X  		sprintf(name_buf, "~%s", fname + HomeLen);
X--- 159,171 ----
X  #ifndef CHDIR
X  
X  char *
X! pr_name(fname, okay_home)
X  char	*fname;
X  {
X  	if (fname == 0)
X  		return 0;
X  
X! 	if (okay_home == YES && strncmp(fname, HomeDir, HomeLen) == 0) {
X  		static char	name_buf[100];
X  
X  		sprintf(name_buf, "~%s", fname + HomeLen);
X***************
X*** 188,194 ****
X  }
X  
X  char *
X! pr_name(fname)
X  char	*fname;
X  {
X  	int	n;
X--- 190,196 ----
X  }
X  
X  char *
X! pr_name(fname, okay_home)
X  char	*fname;
X  {
X  	int	n;
X***************
X*** 201,207 ****
X  	    (fname[n] == '/'))
X  		return fname + n + 1;
X  
X! 	if (strcmp(HomeDir, "/") != 0 && strncmp(fname, HomeDir, HomeLen) == 0) {
X  		static char	name_buf[100];
X  
X  		sprintf(name_buf, "~%s", fname + HomeLen);
X--- 203,209 ----
X  	    (fname[n] == '/'))
X  		return fname + n + 1;
X  
X! 	if (okay_home == YES && strcmp(HomeDir, "/") != 0 && strncmp(fname, HomeDir, HomeLen) == 0) {
X  		static char	name_buf[100];
X  
X  		sprintf(name_buf, "~%s", fname + HomeLen);
X***************
X*** 256,268 ****
X  
X  getCWD()
X  {
X! 	char	*cwd = getenv("CWD");
X  #ifdef JOB_CONTROL
X  	extern char	*getwd();
X  	char	pathname[FILESIZE];
X  #endif
X  
X  	if (cwd == 0)
X  #ifdef JOB_CONTROL
X  		cwd = getwd(pathname);
X  #else
X--- 258,273 ----
X  
X  getCWD()
X  {
X! 	char	*cwd;
X  #ifdef JOB_CONTROL
X  	extern char	*getwd();
X  	char	pathname[FILESIZE];
X  #endif
X  
X+ 	cwd = getenv("CWD");
X  	if (cwd == 0)
X+ 		cwd = getenv("PWD");
X+ 	if (cwd == 0)
X  #ifdef JOB_CONTROL
X  		cwd = getwd(pathname);
X  #else
X***************
X*** 278,284 ****
X  
X  	s_mess(": %f ");
X  	for (i = DirSP; i >= 0; i--)
X! 		add_mess("%s ", pr_name(DirStack[i]));
X  }
X  
X  prCWD()
X--- 283,289 ----
X  
X  	s_mess(": %f ");
X  	for (i = DirSP; i >= 0; i--)
X! 		add_mess("%s ", pr_name(DirStack[i], YES));
X  }
X  
X  prCWD()
X***************
X*** 339,344 ****
X--- 344,350 ----
X  	return offset;
X  }
X  
X+ private
X  dfollow(file, into)
X  char	*file,
X  	*into;
X***************
X*** 377,382 ****
X--- 383,389 ----
X  
X  #endif CHDIR
X  
X+ private
X  get_hdir(user, buf)
X  register char	*user,
X  		*buf;
X***************
X*** 453,464 ****
X  
X  WrtReg()
X  {
X! 	DoWriteReg(0);
X  }
X  
X  AppReg()
X  {
X! 	DoWriteReg(1);
X  }
X  
X  int	CreatMode = DFLT_MODE;
X--- 460,471 ----
X  
X  WrtReg()
X  {
X! 	DoWriteReg(NO);
X  }
X  
X  AppReg()
X  {
X! 	DoWriteReg(YES);
X  }
X  
X  int	CreatMode = DFLT_MODE;
X***************
X*** 474,480 ****
X  	fname = ask_file((char *) 0, (char *) 0, fnamebuf);
X  
X  #ifdef BACKUPFILES
X! 	if (!app) {
X  		filemunge(fname);
X  
X  		if (BkupOnWrite)
X--- 481,487 ----
X  	fname = ask_file((char *) 0, (char *) 0, fnamebuf);
X  
X  #ifdef BACKUPFILES
X! 	if (app == NO) {
X  		filemunge(fname);
X  
X  		if (BkupOnWrite)
X***************
X*** 511,522 ****
X  
X  	chk_mtime(curbuf, fname, "write");
X  	filemunge(fname);
X! 	curbuf->b_type = B_FILE;  	/* In case it wasn't before. */
X  	setfname(curbuf, fname);
X  	file_write(fname, 0);
X  	unmodify();
X  }
X  
X  File *
X  open_file(fname, buf, how, ifbad, loudness)
X  register char	*fname;
X--- 518,545 ----
X  
X  	chk_mtime(curbuf, fname, "write");
X  	filemunge(fname);
X! 	curbuf->b_type = B_FILE;  	/* in case it wasn't before */
X  	setfname(curbuf, fname);
X  	file_write(fname, 0);
X  	unmodify();
X  }
X  
X+ /* Open file FNAME supplying the buffer IO routine with buffer BUF.
X+    HOW is F_READ, F_WRITE or F_APPEND.  IFBAD == COMPLAIN means that
X+    if we fail at opening the file, call complain.  LOUDNESS says
X+    whether or not to print the "reading ..." message on the message
X+    line.
X+ 
X+    NOTE:  This opens the pr_name(fname, NO) of fname.  That is, FNAME
X+ 	  is usually an entire pathname, which can be slow when the
X+ 	  pathname is long and there are lots of symbolic links along
X+ 	  the way (which has become very common in my experience).  So,
X+ 	  this speeds up opens file names in the local directory.  It
X+ 	  will not speed up things like "../scm/foo.scm" simple because
X+ 	  by the time we get here that's already been expanded to an
X+ 	  absolute pathname.  But this is a start.
X+    */
X+ 
X  File *
X  open_file(fname, buf, how, ifbad, loudness)
X  register char	*fname;
X***************
X*** 529,535 ****
X  	io_lines = 0;
X  	tellall = loudness;
X  
X! 	fp = f_open(fname, how, buf, LBSIZE);
X  	if (fp == NIL) {
X                  message(IOerr((how == F_READ) ? "open" : "create", fname));
X  		if (ifbad == COMPLAIN)
X--- 552,558 ----
X  	io_lines = 0;
X  	tellall = loudness;
X  
X! 	fp = f_open(pr_name(fname, NO), how, buf, LBSIZE);
X  	if (fp == NIL) {
X                  message(IOerr((how == F_READ) ? "open" : "create", fname));
X  		if (ifbad == COMPLAIN)
X***************
X*** 537,547 ****
X  	} else {
X  		int	readonly = FALSE;
X  
X! 		if (access(fname, W_OK) == -1 && errno != ENOENT)
X  			readonly = TRUE;
X  							 
X  		if (loudness != QUIET)
X! 			f_mess("\"%s\"%s", pr_name(fname),
X  				   readonly ? " [Read only]" : NullStr);
X  	}
X  	return fp;
X--- 560,570 ----
X  	} else {
X  		int	readonly = FALSE;
X  
X! 		if (access(pr_name(fname, NO), W_OK) == -1 && errno != ENOENT)
X  			readonly = TRUE;
X  							 
X  		if (loudness != QUIET)
X! 			f_mess("\"%s\"%s", pr_name(fname, YES),
X  				   readonly ? " [Read only]" : NullStr);
X  	}
X  	return fp;
X***************
X*** 552,559 ****
X     doing.
X  
X     I hate to use another stat(), but to use confirm we gotta
X!    do this before we open the file. */
X  
X  chk_mtime(thisbuf, fname, how)
X  Buffer	*thisbuf;
X  char	*fname,
X--- 575,586 ----
X     doing.
X  
X     I hate to use another stat(), but to use confirm we gotta
X!    do this before we open the file.
X  
X+    NOTE: This stats FNAME after converting it to a path-relative
X+ 	 name.  I can't see why this would cause a problem ...
X+    */
X+ 
X  chk_mtime(thisbuf, fname, how)
X  Buffer	*thisbuf;
X  char	*fname,
X***************
X*** 566,577 ****
X  	if ((thisbuf->b_mtime != 0) &&		/* if we care ... */
X  	    (b = file_exists(fname)) &&		/* we already have this file */
X  	    (b == thisbuf) &&			/* and it's the current buffer */
X! 	    (stat(fname, &stbuf) != -1) &&	/* and we can stat it */
X  	    (stbuf.st_mtime != b->b_mtime)) {	/* and there's trouble. */
X  	    	rbell();
X  		redisplay();	/* Ring that bell! */
X  	    	TOstart("Warning", TRUE);
X! 	    	Typeout("\"%s\" now saved on disk is not what you last", pr_name(fname));
X  		Typeout("visited or saved.  Probably someone else is editing");
X  		Typeout("your file at the same time.");
X  	    	if (how) {
X--- 593,604 ----
X  	if ((thisbuf->b_mtime != 0) &&		/* if we care ... */
X  	    (b = file_exists(fname)) &&		/* we already have this file */
X  	    (b == thisbuf) &&			/* and it's the current buffer */
X! 	    (stat(pr_name(fname, NO), &stbuf) != -1) &&	/* and we can stat it */
X  	    (stbuf.st_mtime != b->b_mtime)) {	/* and there's trouble. */
X  	    	rbell();
X  		redisplay();	/* Ring that bell! */
X  	    	TOstart("Warning", TRUE);
X! 	    	Typeout("\"%s\" now saved on disk is not what you last", pr_name(fname, YES));
X  		Typeout("visited or saved.  Probably someone else is editing");
X  		Typeout("your file at the same time.");
X  	    	if (how) {
X***************
X*** 626,632 ****
X  		for (;;) {
X  			rbell();
X  			y_or_n = ask(NullStr, "Shall I make your changes to \"%s\" permanent? ", curbuf->b_name);
X! 			c = Upper(*y_or_n);
X  			if (c == 'Y' || c == 'N')
X  				break;
X  		}			
X--- 653,659 ----
X  		for (;;) {
X  			rbell();
X  			y_or_n = ask(NullStr, "Shall I make your changes to \"%s\" permanent? ", curbuf->b_name);
X! 			c = CharUpcase(*y_or_n);
X  			if (c == 'Y' || c == 'N')
X  				break;
X  		}			
X***************
X*** 658,664 ****
X  
X  private int	nleft,	/* number of good characters left in current block */
X  		tmpfd = -1;
X! private disk_line	DFree = 1;
X  			/* pointer to end of tmp file */
X  private char	*tfname;
X  
X--- 685,691 ----
X  
X  private int	nleft,	/* number of good characters left in current block */
X  		tmpfd = -1;
X! disk_line	DFree = 1;
X  			/* pointer to end of tmp file */
X  private char	*tfname;
X  
X***************
X*** 682,691 ****
X  	(void) unlink(tfname);
X  }
X  
X! /* Get a line at `tl' in the tmp file into `buf' which should be LBSIZE
X!    long. */
X  
X! int	Jr_Len;		/* Length of Just Read Line. */
X  private char	*getblock();
X  
X  getline(addr, buf)
X--- 709,718 ----
X  	(void) unlink(tfname);
X  }
X  
X! /* get a line at `tl' in the tmp file into `buf' which should be LBSIZE
X!    long */
X  
X! int	Jr_Len;		/* length of Just Read Line */
X  private char	*getblock();
X  
X  getline(addr, buf)
Xdiff -c ojove/iproc-pipes.c jove/iproc-pipes.c
X*** ojove/iproc-pipes.c	Thu Jul 16 09:14:30 1987
X--- jove/iproc-pipes.c	Thu Jun 25 10:02:30 1987
X***************
X*** 13,20 ****
X  #include <signal.h>
X  #include <sgtty.h>
X  
X- typedef struct process	Process;
X- 
X  #define DEAD	1	/* Dead but haven't informed user yet */
X  #define STOPPED	2	/* Job stopped */
X  #define RUNNING	3	/* Just running */
X--- 13,18 ----
X***************
X*** 25,30 ****
X--- 23,29 ----
X  #define KILLED	2
X  
X  #define isdead(p)	(p == 0 || proc_state(p) == DEAD || p->p_toproc == -1)
X+ #define makedead(p)	(proc_state(p) = DEAD)
X  
X  #define proc_buf(p)	(p->p_buffer->b_name)
X  #define proc_cmd(p)	(p->p_name)
X***************
X*** 36,42 ****
X  	ProcOutput,
X  	NumProcs = 0;
X  
X! static char *
X  pstate(p)
X  Process	*p;
X  {
X--- 35,41 ----
X  	ProcOutput,
X  	NumProcs = 0;
X  
X! char *
X  pstate(p)
X  Process	*p;
X  {
X***************
X*** 54,65 ****
X  		if (p->p_howdied == EXITED) {
X  			if (p->p_reason == 0)
X  				return "Done";
X! 			return sprint("[Exit %d]", p->p_reason);
X  		}
X! 		return sprint("[Killed %d]", p->p_reason);
X  
X  	default:
X! 		return "Unknown state.";
X  	}
X  }
X  
X--- 53,64 ----
X  		if (p->p_howdied == EXITED) {
X  			if (p->p_reason == 0)
X  				return "Done";
X! 			return sprint("Exit %d", p->p_reason);
X  		}
X! 		return sprint("Killed %d", p->p_reason);
X  
X  	default:
X! 		return "Unknown state";
X  	}
X  }
X  
X***************
X*** 98,104 ****
X  			finish(1);
X  		read_proc(header.pid, header.nbytes);
X  	}
X- 	redisplay();
X  	here = 0;
X  	sigrelse(SIGCHLD);
X  }
X--- 97,102 ----
X***************
X*** 126,132 ****
X  	}
X  
X  	if (nbytes == EOF) {		/* Okay to clean up this process */
X! 		p->p_eof = 1;
X  		NumProcs--;	/* As far as getch() in main is concerned */
X  		return;
X  	}
X--- 124,130 ----
X  	}
X  
X  	if (nbytes == EOF) {		/* Okay to clean up this process */
X! 		proc_close(p);
X  		NumProcs--;	/* As far as getch() in main is concerned */
X  		return;
X  	}
X***************
X*** 155,166 ****
X  	proc_kill(curbuf->b_process, SIGQUIT);
X  }
X  
X! static
X  proc_close(p)
X  Process	*p;
X  {
X  	(void) close(p->p_toproc);
X! 	p->p_toproc = -1;	/* Writes will fail. */
X  }
X  
X  do_rtp(mp)
X--- 153,164 ----
X  	proc_kill(curbuf->b_process, SIGQUIT);
X  }
X  
X! private
X  proc_close(p)
X  Process	*p;
X  {
X  	(void) close(p->p_toproc);
X! 	p->p_toproc = -1;	/* writes will fail */
X  }
X  
X  do_rtp(mp)
X***************
X*** 228,234 ****
X  		(void) dup2(ProcOutput, 1);
X  		(void) dup2(ProcOutput, 2);
X  		pclose(toproc);
X! 		execv(Portsrv, args);
X  		printf("Execl failed.\n");
X  		_exit(1);
X  	}
X--- 226,232 ----
X  		(void) dup2(ProcOutput, 1);
X  		(void) dup2(ProcOutput, 2);
X  		pclose(toproc);
X! 		execv(Portsrv, argv);
X  		printf("Execl failed.\n");
X  		_exit(1);
X  	}
X***************
X*** 260,270 ****
X  	/* Pop_wind() after everything is set up; important!
X  	   Bindings won't work right unless newbuf->b_process is already
X  	   set up BEFORE NEWBUF is first SetBuf()'d. */
X! 	newp->p_mark = MakeMark(curline, curchar, FLOATER);
X  
X  	newp->p_toproc = toproc[1];
X  	newp->p_reason = 0;
X- 	newp->p_eof = 0;
X  	NumProcs++;
X  	(void) close(toproc[0]);
X  	sigrelse(SIGCHLD);
X--- 258,267 ----
X  	/* Pop_wind() after everything is set up; important!
X  	   Bindings won't work right unless newbuf->b_process is already
X  	   set up BEFORE NEWBUF is first SetBuf()'d. */
X! 	newp->p_mark = MakeMark(curline, curchar, M_FLOATER);
X  
X  	newp->p_toproc = toproc[1];
X  	newp->p_reason = 0;
X  	NumProcs++;
X  	(void) close(toproc[0]);
X  	sigrelse(SIGCHLD);
Xdiff -c ojove/iproc-ptys.c jove/iproc-ptys.c
X*** ojove/iproc-ptys.c	Thu Jul 16 09:14:31 1987
X--- jove/iproc-ptys.c	Thu Jun 25 10:01:44 1987
X***************
X*** 12,17 ****
X--- 12,18 ----
X  #endif
X  #include <signal.h>
X  #include <sgtty.h>
X+ #include <errno.h>
X  
X  #define DEAD	1	/* Dead but haven't informed user yet */
X  #define STOPPED	2	/* Job stopped */
X***************
X*** 23,28 ****
X--- 24,30 ----
X  #define KILLED	2
X  
X  #define isdead(p)	(p == 0 || proc_state(p) == DEAD || p->p_fd == -1)
X+ #define makedead(p)	(proc_state(p) = DEAD)
X  
X  #define proc_buf(p)	(p->p_buffer->b_name)
X  #define proc_cmd(p)	(p->p_name)
X***************
X*** 45,51 ****
X  	extern struct ltchars ls1;
X  #endif
X  
X! static char *
X  pstate(p)
X  Process	*p;
X  {
X--- 47,53 ----
X  	extern struct ltchars ls1;
X  #endif
X  
X! char *
X  pstate(p)
X  Process	*p;
X  {
X***************
X*** 60,71 ****
X  		if (p->p_howdied == EXITED) {
X  			if (p->p_reason == 0)
X  				return "Done";
X! 			return sprint("exit(%d)", p->p_reason);
X  		}
X! 		return sprint("Killed(%d)", p->p_reason);
X  
X  	default:
X! 		return "Unknown state.";
X  	}
X  }
X  
X--- 62,73 ----
X  		if (p->p_howdied == EXITED) {
X  			if (p->p_reason == 0)
X  				return "Done";
X! 			return sprint("Exit %d", p->p_reason);
X  		}
X! 		return sprint("Killed %d", p->p_reason);
X  
X  	default:
X! 		return "Unknown state";
X  	}
X  }
X  
X***************
X*** 98,111 ****
X  	}
X  
X  	n = read(fd, ibuf, sizeof(ibuf) - 1);
X! 	if (n == 0) {
X! 		proc_close(p);
X! 		NumProcs--;
X  		return;
X  	}
X  	ibuf[n] = '\0';
X  	proc_rec(p, ibuf);
X- 	redisplay();
X  }
X  
X  ProcKill()
X--- 100,123 ----
X  	}
X  
X  	n = read(fd, ibuf, sizeof(ibuf) - 1);
X! 	/* NOTE: This read somethings returns -1 when it's the first time
X! 	   we're reading the socket.  Errno was set to I/O error or something
X! 	   bizarre like that.  So, I'm choosing to ignore this.  I ignored
X! 	   it before, and what happened was random text was being inserted
X! 	   at the beginning of the buffer because the ibuf[n] = '\0' wasn't
X!  	   working right (ibuf[-1] = '\0'). */
X! 	if (n == -1 && errno == EIO)
X  		return;
X+ 	if (n <= 0) {
X+ 		if (n == 0) {
X+ 			makedead(p);
X+ 			return;
X+ 		}
X+ 		sprintf(ibuf, "\n[pty read error: %d]\n", errno);
X+ 		n = strlen(ibuf);
X  	}
X  	ibuf[n] = '\0';
X  	proc_rec(p, ibuf);
X  }
X  
X  ProcKill()
X***************
X*** 171,183 ****
X  	(void) write(p->p_fd, &c, 1);
X  }
X  
X! static
X  proc_close(p)
X  Process *p;
X  {
X  	(void) close(p->p_fd);
X  	global_fd &= ~(1 << p->p_fd);
X- 	p->p_eof++;
X  }
X  
X  do_rtp(mp)
X--- 183,194 ----
X  	(void) write(p->p_fd, &c, 1);
X  }
X  
X! private
X  proc_close(p)
X  Process *p;
X  {
X  	(void) close(p->p_fd);
X  	global_fd &= ~(1 << p->p_fd);
X  }
X  
X  do_rtp(mp)
X***************
X*** 216,222 ****
X  	va_list	ap;
X  	char	*argv[32],
X  		*cp;
X! 	Window *owind	= curwind;
X  	int	pid;
X  	Process	*newp;
X  	Buffer 	*newbuf;
X--- 227,233 ----
X  	va_list	ap;
X  	char	*argv[32],
X  		*cp;
X! 	Window *owind = curwind;
X  	int	pid;
X  	Process	*newp;
X  	Buffer 	*newbuf;
X***************
X*** 348,354 ****
X  
X  	newp->p_fd = ttyfd;
X  	newp->p_pid = pid;
X- 	newp->p_eof = 0;
X  
X  	newbuf = do_select((Window *) 0, bufname);
X  	newbuf->b_type = B_PROCESS;
X--- 359,364 ----
X***************
X*** 371,377 ****
X  	newp->p_name = copystr(cmdbuf);
X  	newp->p_state = RUNNING;
X  	newp->p_reason = 0;
X! 	newp->p_mark = MakeMark(curline, curchar, FLOATER);
X  
X  	newp->p_next = procs;
X  	procs = newp;
X--- 381,387 ----
X  	newp->p_name = copystr(cmdbuf);
X  	newp->p_state = RUNNING;
X  	newp->p_reason = 0;
X! 	newp->p_mark = MakeMark(curline, curchar, M_FLOATER);
X  
X  	newp->p_next = procs;
X  	procs = newp;
Xdiff -c ojove/iproc.c jove/iproc.c
X*** ojove/iproc.c	Thu Jul 16 09:14:32 1987
X--- jove/iproc.c	Wed Jun 24 12:52:13 1987
X***************
X*** 30,36 ****
X  		if (!isdead(p)) {
X  			if (killem == -1) {
X  				yorn = ask("y", "Should I kill your i-processes? ");
X! 				killem = (Upper(*yorn) == 'Y');
X  			}
X  			if (killem)
X  				proc_kill(p, SIGKILL);
X--- 30,36 ----
X  		if (!isdead(p)) {
X  			if (killem == -1) {
X  				yorn = ask("y", "Should I kill your i-processes? ");
X! 				killem = (CharUpcase(*yorn) == 'Y');
X  			}
X  			if (killem)
X  				proc_kill(p, SIGKILL);
X***************
X*** 50,56 ****
X  /* Process receive: receives the characters in buf, and appends them to
X     the buffer associated with p. */
X  
X! static
X  proc_rec(p, buf)
X  register Process	*p;
X  char	*buf;
X--- 50,56 ----
X  /* Process receive: receives the characters in buf, and appends them to
X     the buffer associated with p. */
X  
X! private
X  proc_rec(p, buf)
X  register Process	*p;
X  char	*buf;
X***************
X*** 68,88 ****
X  	if (w != 0)
X  		do_disp = (in_window(w, p->p_mark->m_line) != -1);
X  	SetBuf(p->p_buffer);
X! 	savepoint = MakeMark(curline, curchar, FLOATER);
X! 	ToMark(p->p_mark);	/* Where output last stopped. */
X  	if (savepoint->m_line == curline && savepoint->m_char == curchar)
X  		sameplace++;
X  
X  	ins_str(buf, YES);
X  	if (do_disp) {
X  		w->w_line = curline;
X  		w->w_char = curchar;
X  		redisplay();
X  	}
X- 	MarkSet(p->p_mark, curline, curchar);
X- 	if (!sameplace)
X- 		ToMark(savepoint);	/* Back to where we were. */
X- 	DelMark(savepoint);
X  	SetBuf(saveb);
X  }
X  
X--- 68,91 ----
X  	if (w != 0)
X  		do_disp = (in_window(w, p->p_mark->m_line) != -1);
X  	SetBuf(p->p_buffer);
X! 	savepoint = MakeMark(curline, curchar, M_FLOATER);
X! 	ToMark(p->p_mark);		/* where output last stopped */
X  	if (savepoint->m_line == curline && savepoint->m_char == curchar)
X  		sameplace++;
X  
X  	ins_str(buf, YES);
X+ 	MarkSet(p->p_mark, curline, curchar);
X+ 	if (!sameplace)
X+ 		ToMark(savepoint);	/* back to where we were */
X+ 	DelMark(savepoint);
X+ 	/* redisplay now, instead of right after the ins_str, so that
X+ 	   we don't get a bouncing effect if point is not the same as
X+ 	   the process output position */
X  	if (do_disp) {
X  		w->w_line = curline;
X  		w->w_char = curchar;
X  		redisplay();
X  	}
X  	SetBuf(saveb);
X  }
X  
X***************
X*** 95,105 ****
X  		s_mess("Cannot kill %s!", proc_buf(p));
X  }
X  
X! /* Deal with a process' death.  proc_rec turns on the FREEUP bit when it
X!    it gets the "EOF" from portsrv.  FREEUP'd processes get unlinked from
X!    the list, and the proc stucture and proc_buf(p) get free'd up, here. */
X  
X- private
X  DealWDeath()
X  {
X  	register Process	*p,
X--- 98,107 ----
X  		s_mess("Cannot kill %s!", proc_buf(p));
X  }
X  
X! /* Deal with a process' death.  Go through all processes and find
X!    the ones which have gotten EOF.  Delete them from the list and
X!    free up the memory, and insert a status string. */
X  
X  DealWDeath()
X  {
X  	register Process	*p,
X***************
X*** 108,114 ****
X  	
X  	for (p = procs; p != 0; p = next) {
X  		next = p->p_next;
X! 		if (!p->p_eof) {
X  			prev = p;
X  			continue;
X  		}
X--- 110,116 ----
X  	
X  	for (p = procs; p != 0; p = next) {
X  		next = p->p_next;
X! 		if (p->p_state != DEAD) {
X  			prev = p;
X  			continue;
X  		}
X***************
X*** 130,135 ****
X--- 132,138 ----
X  	char	*fmt = "%-15s  %-15s  %-8s %s",
X  		pidstr[10];
X  
X+ 	DealWDeath();
X  	if (procs == 0) {
X  		message("[No subprocesses]");
X  		return;
X***************
X*** 142,148 ****
X  		sprintf(pidstr, "%d", p->p_pid);
X  		Typeout(fmt, proc_buf(p), pstate(p), pidstr, p->p_name);
X  	}
X- 	DealWDeath();
X  	TOstop();
X  }
X  
X--- 145,150 ----
X***************
X*** 160,168 ****
X--- 162,193 ----
X  SendData(newlinep)
X  {
X  	register Process	*p = curbuf->b_process;
X+ 	register char	*lp,
X+ 			*gp;	/* JF fix for better prompt handling */
X  
X  	if (isdead(p))
X  		return;
X+ 	/* If the process mark was involved in a big deletion, because
X+ 	   the user hit ^W or something, then let's do some magic with
X+ 	   the process mark.  Problem is that if the user yanks back the
X+ 	   text he deleted, the mark stays at the beginning of the region,
X+ 	   and so the next time SendData() is called the entire region
X+ 	   will be sent.  That's not good.  So, to deal with that we reset
X+ 	   the mark to the last line, after skipping over the prompt, etc. */
X+ 	if (p->p_mark->m_flags & M_BIG_DELETE) {
X+ 		Bufpos	bp;
X+ 
X+ 		p->p_mark->m_flags &= ~M_BIG_DELETE;
X+ 
X+ 		DOTsave(&bp);
X+ 		ToLast();
X+ 		Bol();
X+ 		while (LookingAt(proc_prompt, linebuf, curchar))
X+ 			SetDot(dosearch(proc_prompt, 1, 1));
X+ 		MarkSet(p->p_mark, curline, curchar);
X+ 		SetDot(&bp);
X+ 	}
X+ 
X  	if (lastp(curline)) {
X  		Eol();
X  		if (newlinep)
X***************
X*** 174,181 ****
X  		while (LookingAt(proc_prompt, linebuf, curchar))
X  			SetDot(dosearch(proc_prompt, 1, 1));
X  		strcpy(genbuf, linebuf + curchar);
X! 		ToLast();
X! 		ins_str(genbuf, NO);
X  	}
X  }
X  
X--- 199,210 ----
X  		while (LookingAt(proc_prompt, linebuf, curchar))
X  			SetDot(dosearch(proc_prompt, 1, 1));
X  		strcpy(genbuf, linebuf + curchar);
X! 		Eof();
X! 		gp = genbuf;
X! 		lp = linebuf;
X! 		while (*lp == *gp && *lp != '\0')
X! 			lp++, gp++;
X! 		ins_str(gp, NO);
X  	}
X  }
X  
X***************
X*** 222,233 ****
X  register int	pid;
X  union wait	w;
X  {
X- 	char	str[128];
X  	register Process	*child;
X  
X  	if ((child = proc_pid(pid)) == 0)
X  		return;
X  
X  	if (WIFSTOPPED(w))
X  		child->p_state = STOPPED;
X  	else {
X--- 251,262 ----
X  register int	pid;
X  union wait	w;
X  {
X  	register Process	*child;
X  
X  	if ((child = proc_pid(pid)) == 0)
X  		return;
X  
X+ 	UpdModLine = YES;		/* we're changing state ... */
X  	if (WIFSTOPPED(w))
X  		child->p_state = STOPPED;
X  	else {
X***************
X*** 238,249 ****
X  			child->p_reason = w.w_termsig;
X  			child->p_howdied = KILLED;
X  		}
X! 		proc_close(child);
X  	}
X- 	sprintf(str, "[Process %s: %s]\n",
X- 		proc_cmd(child),
X- 		pstate(child));
X- 	proc_rec(child, str);
X  }
X  
X  /* Push/pod process bindings.  I openly acknowledge that this is a
X--- 267,286 ----
X  			child->p_reason = w.w_termsig;
X  			child->p_howdied = KILLED;
X  		}
X! 		{
X! 			Buffer	*save = curbuf;
X! 			char	mesg[128];
X! 
X! 			/* insert status message now */
X! 			sprintf(mesg, "[Process %s: %s]\n",
X! 				proc_cmd(child),
X! 				pstate(child));
X! 			SetBuf(child->p_buffer);
X! 			ins_str(mesg, NO);
X! 			SetBuf(save);
X! 			redisplay();
X! 		}
X  	}
X  }
X  
X  /* Push/pod process bindings.  I openly acknowledge that this is a
Xdiff -c ojove/jove.c jove/jove.c
X*** ojove/jove.c	Thu Jul 16 09:14:35 1987
X--- jove/jove.c	Fri Jul 10 09:25:50 1987
X***************
X*** 20,27 ****
X  #include <sgtty.h>
X  #else
X  #include <termio.h>
X- #endif SYSV
X  #include <fcntl.h>
X  
X  #ifdef TIOCSLTC
X  struct ltchars	ls1,
X--- 20,27 ----
X  #include <sgtty.h>
X  #else
X  #include <termio.h>
X  #include <fcntl.h>
X+ #endif SYSV
X  
X  #ifdef TIOCSLTC
X  struct ltchars	ls1,
X***************
X*** 62,71 ****
X  	int	CoreDump = (code != 0 && code != SIGHUP),
X  		DelTmps = 1;		/* Usually we delete them. */
X  
X- #ifdef LSRHS
X- 	if (CoreDump)
X- 		setdump(1);
X- #endif
X  	if (code == SIGINT) {
X  		char	c;
X  
X--- 62,67 ----
X***************
X*** 106,114 ****
X  	if (CoreDump)
X  		abort();
X  #ifdef PROFILING
X! 	exit(exp_p);
X  #else
X! 	_exit(exp_p);
X  #endif
X  }
X  
X--- 102,110 ----
X  	if (CoreDump)
X  		abort();
X  #ifdef PROFILING
X! 	exit(0);
X  #else
X! 	_exit(0);
X  #endif
X  }
X  
X***************
X*** 137,143 ****
X      }
X      if (fcntl(fd, F_SETFL, on ? blockf : nonblockf) == -1)
X  	finish(SIGHUP);
X-     return;
X  }
X  #endif SYSV
X  
X--- 133,138 ----
X***************
X*** 399,405 ****
X  }
X  
X  int	OKXonXoff = 0,		/* ^S and ^Q initially DON'T work */
X! 	IntChar = CTL(]);
X  
X  ttsize()
X  {
X--- 394,400 ----
X  }
X  
X  int	OKXonXoff = 0,		/* ^S and ^Q initially DON'T work */
X! 	IntChar = CTL(']');
X  
X  ttsize()
X  {
X***************
X*** 500,505 ****
X--- 495,502 ----
X  	TABS = !((sg1.c_oflag & TAB3) == TAB3);
X  	ospeed = sg1.c_cflag & CBAUD;
X  
X+ 	if (OKXonXoff)
X+ 		sg2.c_iflag &= ~(IXON | IXOFF);
X  	sg2.c_iflag &= ~(INLCR|ICRNL|IGNCR);
X  	sg2.c_lflag &= ~(ISIG|ICANON|ECHO);
X  	sg2.c_oflag &= ~(OCRNL|ONLCR);
X***************
X*** 584,591 ****
X  
X  	if (cp == 0) {
X  		rbell();
X! 		exp = 1;
X! 		exp_p = errormsg = NO;
X  		message(NullStr);
X  	} else
X  		ExecCmd(cp);
X--- 581,588 ----
X  
X  	if (cp == 0) {
X  		rbell();
X! 		clr_arg_value();
X! 		errormsg = NO;
X  		message(NullStr);
X  	} else
X  		ExecCmd(cp);
X***************
X*** 662,668 ****
X  
X  dorecover()
X  {
X! 	execl(Recover, "jove_recover", "-d", TmpFilePath, (char *)0);
X  	printf("%s: execl failed!\n", Recover);
X  	flusho();
X  	_exit(-1);
X--- 659,665 ----
X  
X  dorecover()
X  {
X! 	execl(Recover, "jove_recover", "-d", TmpFilePath, (char *) 0);
X  	printf("%s: execl failed!\n", Recover);
X  	flusho();
X  	_exit(-1);
X***************
X*** 721,727 ****
X  			case 't':
X  				++argv;
X  				--argc;
X- 				exp_p = YES;
X  				find_tag(argv[1], YES);
X  				break;
X  
X--- 718,723 ----
X***************
X*** 812,818 ****
X  	Mark	*m;
X  
X  	sprintf(bname, "%s", curbuf->b_name);
X! 	m = MakeMark(curline, curchar, FLOATER);
X  
X  	RecDepth++;
X  	UpdModLine++;
X--- 808,814 ----
X  	Mark	*m;
X  
X  	sprintf(bname, "%s", curbuf->b_name);
X! 	m = MakeMark(curline, curchar, M_FLOATER);
X  
X  	RecDepth++;
X  	UpdModLine++;
X***************
X*** 820,826 ****
X  	UpdModLine++;
X  	RecDepth--;
X  	SetBuf(do_select(curwind, bname));
X! 	if (exp_p == NO)
X  		ToMark(m);
X  	DelMark(m);
X  }
X--- 816,822 ----
X  	UpdModLine++;
X  	RecDepth--;
X  	SetBuf(do_select(curwind, bname));
X! 	if (!is_an_arg())
X  		ToMark(m);
X  	DelMark(m);
X  }
X***************
X*** 846,858 ****
X  		if (RecDepth == 0) {
X  			if (ModMacs()) {
X  				rbell();
X! 				if (Upper(*ask("No",
X  "Some MACROS haven't been saved; leave anyway? ")) != 'Y')
X  					break;
X  			}
X  			if (ModBufs(0)) {
X  				rbell();
X! 				if (Upper(*ask("No",
X  "Some buffers haven't been saved; leave anyway? ")) != 'Y')
X  					break;
X  			}
X--- 842,854 ----
X  		if (RecDepth == 0) {
X  			if (ModMacs()) {
X  				rbell();
X! 				if (CharUpcase(*ask("No",
X  "Some MACROS haven't been saved; leave anyway? ")) != 'Y')
X  					break;
X  			}
X  			if (ModBufs(0)) {
X  				rbell();
X! 				if (CharUpcase(*ask("No",
X  "Some buffers haven't been saved; leave anyway? ")) != 'Y')
X  					break;
X  			}
X***************
X*** 880,887 ****
X  
X  	for (;;) {
X  		if (this_cmd != ARG_CMD) {
X! 			exp = 1;
X! 			exp_p = NO;
X  			last_cmd = this_cmd;
X  			init_strokes();
X  		}
X--- 876,882 ----
X  
X  	for (;;) {
X  		if (this_cmd != ARG_CMD) {
X! 			clr_arg_value();
X  			last_cmd = this_cmd;
X  			init_strokes();
X  		}
X***************
X*** 1051,1061 ****
X  	}
X  	if (scanvec(argv, "-r"))
X  		dorecover();
X  
X- 	(void) time(&time0);
X  	ttinit();	/* initialize terminal (after ~/.joverc) */
X  	settout(ttbuf);	/* not until we know baudrate */
X- 	ResetTerm();
X  
X  	(void) signal(SIGHUP, finish);
X  	(void) signal(SIGINT, finish);
X--- 1046,1056 ----
X  	}
X  	if (scanvec(argv, "-r"))
X  		dorecover();
X+ 	if (scanvec(argv, "-rc"))
X+ 		FullRecover();
X  
X  	ttinit();	/* initialize terminal (after ~/.joverc) */
X  	settout(ttbuf);	/* not until we know baudrate */
X  
X  	(void) signal(SIGHUP, finish);
X  	(void) signal(SIGINT, finish);
X***************
X*** 1071,1078 ****
X  
X  	/* set things up to update the modeline every UpdFreq seconds */
X  	(void) signal(SIGALRM, updmode);
X! 	(void) alarm((unsigned) UpdFreq);
X  
X  	cl_scr(1);
X  	flusho();
X  	RedrawDisplay();	/* start the redisplay process. */
X--- 1066,1075 ----
X  
X  	/* set things up to update the modeline every UpdFreq seconds */
X  	(void) signal(SIGALRM, updmode);
X! 	(void) time(&time0);
X! 	(void) alarm((unsigned) (60 - (time0 % 60)));
X  
X+ 	ResetTerm();
X  	cl_scr(1);
X  	flusho();
X  	RedrawDisplay();	/* start the redisplay process. */
END_OF_FILE
if test 43705 -ne `wc -c <'jove.pch.2'`; then
    echo shar: \"'jove.pch.2'\" unpacked with wrong size!
fi
# end of 'jove.pch.2'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
