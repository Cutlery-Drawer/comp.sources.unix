This is a new archive version of TRN at patchlevel 3.
The original posting took up Volume23, issues 60 to 73, with
various problems.  These files replace those issues.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Pnews.SH getdate.y help.c rn.c
# Wrapped by rsalz@litchi.bbn.com on Fri Aug 23 16:38:59 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 14)."'
if test -f 'Pnews.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Pnews.SH'\"
else
  echo shar: Extracting \"'Pnews.SH'\" \(18036 characters\)
  sed "s/^X//" >'Pnews.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting Pnews (with variable substitutions)"
X$spitshell >Pnews <<!GROK!THIS!
X$startsh
X# $Header: Pnews.SH,v 4.3.3.3 91/01/16 03:27:15 davison Trn $
X#
X# $Log:	Pnews.SH,v $
X# Revision 4.3.3.3  91/01/16  03:27:15  davison
X# Integrated rn patches 48-54.
X# 
X# Revision 4.3.3.2  90/08/20  16:24:09  davison
X# Use mbox.saver for AUTHORCOPY.  Fixed sitename handling.
X# 
X# Revision 4.3.3.1  90/07/24  22:01:25  davison
X# Initial Trn Release
X# 
X# Revision 4.3.2.14  91/01/05  15:18:19  sob
X# Changed the header purge code to use sed instead of grep.
X# 
X# Revision 4.3.2.13  90/12/30  03:47:57  sob
X# Changed "hidden" to "hiddennet" to be like nntp and bnews.
X# Made it possible to cancel articles if hiddennet is defined.
X# 
X# Revision 4.3.2.12  90/12/30  03:27:44  sob
X# Corrected a spelling problem.
X# 
X# Revision 4.3.2.11  90/12/04  02:47:54  sob
X# Added a fix to remove blank lines in the header before posting.
X# 
X# Revision 4.3.2.10  90/11/22  13:45:40  sob
X# Added support for making news posting appear to come from the domain
X# itself instead of individual hosts withing a domain.
X# 
X# Revision 4.3.2.9  90/11/06  00:54:52  sob
X# Added ./ to be beginning of config.sh
X# 
X# Revision 4.3.2.8  90/11/06  00:08:11  sob
X# Fixed bug in sed syntax for usg password file format per bug report by
X# prc@erbe.se
X# 
X# Revision 4.3.2.7  90/05/04  23:14:45  sob
X# Expires: line removed from Pnews.header.
X# 
X# Revision 4.3.2.6  90/04/21  16:53:43  sob
X# Corrected a typo pointed out by Bill Aten.
X# 
X# Revision 4.3.2.5  89/12/17  01:53:48  sob
X# Changed from using ypcat to using ypmatch
X# 
X# Revision 4.3.2.4  89/12/09  01:48:30  sob
X# Reply-To: field removed. This makes all the headers created by rn
X# look roughly the same.
X# 
X# Revision 4.3.2.3  89/11/26  22:20:04  sob
X# Added support for some of the top level names that are not part of
X# the mainstream.
X# 
X# Revision 4.3.2.2  89/11/06  00:25:39  sob
X# Some minor changes to make the help messages more accurate
X# 
X# Revision 4.3.2.1  89/11/06  00:21:30  sob
X# Added RRN support from NNTP 1.5
X# 
X# Revision 4.3.1.4  86/09/05  15:21:10  lwall
X# Changes for new top-level newsgroup names.
X# 
X# Revision 4.3.1.3  85/08/01  14:24:06  lwall
X# Added AUTHORCOPY.  Temp file is no longer in /tmp.  'e editor' added.
X# 
X# Revision 4.3.1.2  85/05/17  10:36:46  lwall
X# Removed some extra backslashes.
X# 
X# Revision 4.3.1.1  85/05/10  11:30:21  lwall
X# Branch for patches.
X# 
X# Revision 4.3  85/05/01  12:20:33  lwall
X# Baseline for release with 4.3bsd.
X# 
X#
X# syntax: Pnews -h headerfile			or
X#	  Pnews -h headerfile oldarticle	or
X#         Pnews newsgroup title			or just
X#         Pnews
X
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
X# System dependencies
X
Xmailer="${mailer-/bin/mail}"
X# if you change this to something that does signatures, take out signature code
X
Xcase $portable in
Xdefine)
X# your site name
Xcase "$hostcmd" in
X'') sitename="$sitename" ;;
X*)  sitename=\`$hostcmd\` ;;
Xesac
Xcase \$sitename in
X	*.*)
X		;;
X	*)
X		sitename=\${sitename}.$domain
X		;;
Xesac
X# where recordings, distributions and moderators are kept
Xlib=\`$filexp $lib\`
X# where important rn things are kept
Xrnlib=\`$filexp $rnlib\`
X;;
Xundef)
X# your site name
Xsitename="$sitename"
X# where recordings, distributions and moderators are kept
Xlib="$lib"
X# where important rn things are kept
Xrnlib="$rnlib"
X;;
Xesac
X
Xcase $hiddennet in
Xdefine)	sitename="$domain"
X	;;
X*)
X	;;
Xesac
X
X# your organization name
Xorgname="$orgname"
X# what pager you use--if you have kernal paging use cat
Xpager="\${PAGER-$pager}"
X# how you derive full names, bsd, usg, or other
Xnametype="$nametype"
X# default editor
Xdefeditor="$defeditor"
X# how not to echo with newline
Xn="$n"
Xc="$c"
X
X# You should also look at the distribution warnings below marked !DIST!
X# to make sure any distribution regions you are a member of are included.
X# The following are some prototypical distribution groups.  If you do not
X# use them all set the unused ones to a non-null string such as 'none'.
Xloc="$locpref"
Xorg="$orgpref"
Xcity="$citypref"
Xstate="$statepref"
Xcntry="$cntrypref"
Xcont="$contpref"
X
Xtest=${test-test}
Xsed=${sed-sed}
Xecho=${echo-echo}
Xcat=${cat-cat}
Xegrep=${egrep-egrep}
Xgrep=${grep-grep}
Xrm=${rm-rm}
Xtr=${tr-tr}
Xinews=${inews-inews}
Xnidump=${nidump}
Xypmatch=${ypmatch}
X
X!GROK!THIS!
X$spitshell >>Pnews <<'!NO!SUBS!'
Xdotdir=${DOTDIR-${HOME-$LOGDIR}}
Xtmpart=$dotdir/.article
X
Xif $test -f $dotdir/.pnewsexpert; then
X    expertise=expert
Xelse
X    $cat <<'EOM'
XI see you've never used this version of Pnews before.  I will give you extra
Xhelp this first time through, but then you must remember what you learned.
XIf you don't understand any question, type h and a CR (carriage return) for
Xhelp.
X
XIf you've never posted an article to the net before, it is HIGHLY recommended
Xthat you read the netiquette document found in news.announce.newusers so
Xthat you'll know to avoid the commonest blunders.  To do that, interrupt
XPnews, and get to the top-level prompt of rn.  Type "g news.announce.newusers"
Xand you are on your way.
X
XEOM
X    expertise=beginner
Xfi
X
Xcase $cntry in
X  can) stpr=Province ;;
X  *)   stpr=State ;;
Xesac
X
Xheaderfile=""
Xcase $# in
X0) ;;
X*)  case $1 in
X    -h)
X	headerfile="$2"
X	shift
X	shift
X	case $# in
X	0)
X	    oldart=""
X	    ;;
X	*)
X	    oldart="$1"
X	    shift
X	    ;;
X	esac
X	;;
X    esac
X    ;;
Xesac
X
Xcase $headerfile in
X'')
X    . $rnlib/Pnews.header
X    ;;
X*)
X    $cat < $headerfile  > $tmpart
X    ;;
Xesac
X    rescue="sleep 1; $cat $tmpart >>${HOME-$LOGDIR}/dead.article ; $echo Article appended to ${HOME-$LOGDIR}/dead.article ; exit"
X    trap "$rescue" 1
X    trap "$rescue" 2
X
X$echo ""
X
X# extract the newsgroups list and distribution
Xhdr_newsgroups=`$sed -n -e '/^Newsgroups:/{' -e 's///' -e 's/,/ /g' -e p -e q -e '}' $tmpart`
Xhdr_distribution=`$sed -n -e '/^Distribution:/{' -e 's///' -e p -e q -e '}' $tmpart`
X
X# check for "poster" magic cookie
Xflag=0
Xfor ng in $hdr_newsgroups ; do
X    case "$ng" in
X	poster)	flag=1 ;;
X	*)	;;
X    esac
Xdone
Xcase $flag in
X1)
X    $echo " "
X    $echo "The original author has requested that messages be sent back via"
X    $echo "mail rather than posting to news.  Do you want to jump out of this"
X    $echo $n "and mail your reply instead? [yn] $c"
X    read ans
X    case $ans in
X	n*) ;;
X	*)  exit ;;
X    esac
X    $echo " "
X    $echo "OK, but you will have to edit the 'Newsgroups:' line in the message."
X    ;;
Xesac
X  
X# play recorded message
Xif $test -s ${lib}/recording ; then
X     for ng in $hdr_newsgroups ; do
X	_rec1=${lib}/`$sed -n "/^$ng/s/^.*	//p" ${lib}/recording`
X	_tmp=`$echo $ng |$sed "s/\..*//"`
X	_rec2=${lib}/`$cat -s ${lib}/recording|$grep ${_tmp}.all|$sed "s/^.*	//"`
X	if $test -f ${_rec1} ; then
X	    $cat -s ${_rec1}
X	fi
X	if $test -f ${_rec2} ; then
X	    $cat -s ${_rec2}
X	fi
X    done
Xfi
X
X# determine the distribution of this message
Xset X $hdr_distribution
Xshift
Xif $test $# -gt 0 ; then
X    dist=$1.whatever
Xelse
X    set X $hdr_newsgroups
X    shift
X    if $test $# -gt 0 ; then
X	dist=$1.whatever
X    else
X	dist=misc.whatever
X    fi
Xfi
Xcase $dist in
X*.*)
X    ;;
X*)
X    dist=$dist.whatever
X    ;;
Xesac
X
X# tell them what we think they are doing... !DIST!
Xcase $dist in
Xworld.*|comp.*|news.*|sci.*|rec.*|misc.*|soc.*|talk.*|alt.*)
X    $cat <<'EOM'
XThis program posts news to thousands of machines throughout the entire
Xcivilized world.  Your message will cost the net hundreds if not thousands of
Xdollars to send everywhere.  Please be sure you know what you are doing.
X
XEOM
X    ;;
Xvmsnet.*)
X    $echo 'This program posts news to many machines.'
X    ;;
Xbit.*)
X    $echo 'This program posts news to many machines on BITNET.'
X    ;;
Xddn.*)
X    $echo 'This program posts news to many machines throughout the internet.'
X    ;;
X$cont.*)
X    $echo 'This program posts news to many machines throughout the continent.'
X    ;;
X$cntry.*)
X    $echo 'This program posts news to many machines throughout the country.'
X    ;;
X$state.*)
X    $echo 'This program posts news to many machines throughout the state.'
X    ;;
X$city.*)
X    $echo 'This program posts news to many machines throughout the city.'
X    ;;
X$org.*)
X    $echo 'This program posts news to machines throughout the organization.'
X    ;;
X$loc.*)
X    $echo 'This program posts news to machines throughout the local organization.'
X    ;;
X*.*)
X    $echo 'This program may post news to many machines.'
X    ;;
Xto.*)
X    $echo 'This program may post news to a particular machine.'
X    ;;
X*)
X    $echo 'This program posts news to everyone on the machine.'
X    ;;
Xesac
Xans=""
Xwhile $test "$ans" = "" ; do
X    $echo $n "Are you absolutely sure that you want to do this? [ny] $c"
X    read ans
X    case $ans in
X    y*) ;;
X    f*) ;;
X    h*) $cat <<'EOH'
X
XType n or CR to exit, y to post.
X
XEOH
X	ans="" ;;
X    *) exit ;;
X    esac
Xdone
X
Xfile=h
Xwhile $test "$file" = h ; do
X    $echo ""
X    $echo $n "Prepared file to include [none]: $c"
X    read file
X    case $file in
X    h)
X	$cat <<'EOH'
X
XIf you have already produced the body of your article, type the filename
Xfor it here.  If you just want to proceed directly to the editor, type a
XRETURN.  In any event, you will be allowed to edit as many times as you
Xwant before you send off the article.
XEOH
X	;;
X    '')
X	$echo "" >> $tmpart
X	state=edit
X	;;
X    *)
X	$cat $file >>$tmpart
X	state=ask
X	;;
X    esac
Xdone
X
X$echo ""
X
Xwhile true ; do
X    case $state in
X    edit)
X	case $expertise in
X	beginner)
X	    $cat </dev/null >$dotdir/.pnewsexpert
X	    $cat <<'EOMessage'
XA temporary file has been created for you to edit.  Be sure to leave at
Xleast one blank line between the header and the body of your message.
X(And until a certain bug is fixed all over the net, don't start the body of
Xyour message with any indentation, or it may get eaten.)
X
XWithin the header may be fields that you don't understand.  If you don't
Xunderstand a field (or even if you do), you can simply leave it blank, and
Xit will go away when the article is posted.
X
XType return to get the default editor, or type the name of your favorite
Xeditor.
X
XEOMessage
X	    ;;
X	esac
X	case "${VISUAL-${EDITOR-}}" in
X	'')
X	    tmp=h
X	    ;;
X	*)
X	    tmp=''
X	    ;;
X	esac
X	while $test "$tmp" = h ; do
X	    $echo $n "Editor [${VISUAL-${EDITOR-$defeditor}}]: $c"
X	    read tmp
X	    case $tmp in
X	    h)
X		$cat <<'EOH'
X
XType a return to get the default editor, or type the name of the editor you
Xprefer.  The default editor depends on the VISUAL and EDITOR environment
Xvariables.
X
XEOH
X		;;
X	    '')
X		;;
X	    *)
X		VISUAL=$tmp
X		export VISUAL
X		;;
X	    esac
X	done
X	trap : 2
X	${VISUAL-${EDITOR-$defeditor}} $tmpart $oldart
X	trap "$rescue" 2
X	state=ask
X	;;
X	
X    ask)
X	$echo ""
X	$echo $n "Send, abort, edit, or list? $c"
X	read ans
X	
X	case "$ans" in
X	a*)
X	    state=rescue
X	    ;;
X	e*)
X	    set $ans
X	    case $# in
X	    2)  VISUAL="$2" ;;
X	    esac
X	    state=edit
X	    ;;
X	l*)
X	    $pager $tmpart
X	    state=ask
X	    ;;
X	s*)
X	    state=send
X	    ;;
X	h*)
X	    $cat <<'EOH'
X
XType s to send the article, a to abort and append the article to dead.article,
Xe to edit the article again, or l to list the article.
X
XTo invoke an alternate editor, type 'e editor'.
XEOH
X	esac
X	;;
X    
X    send)
X	set X `$sed < $tmpart -n -e '/^Newsgroups: /{' -e p -e q -e '}'`
X	shift
X	case $# in
X	2)
X	    state=cleanup
X	    if $test -f $lib/moderators; then
X		tryinews=no
X		shift
X		case "$1" in
X		*,*) set `$echo $1 | tr ',' ' '`;;
X		esac
X		for newsgroup in $*; do
X# the following screwy sed should prevent Eunice from hanging on no match
X		    moderator=`$sed <$lib/moderators \
X		    -e "/^$newsgroup[ 	]/!s/.*//" \
X		    -e "s/^$newsgroup[ 	]//"`
X		    case ${moderator}X in
X		    X)  tryinews=yes
X			;;
X		    *)
X			$echo Mailing to moderator $moderator
X			case "$sign" in
X			n*) ;;
X			*)
X			    if $test -f $dotdir/.signature; then
X				echo $n "Append .signature file? [y] $c"
X				read ans
X				case $ans in
X				''|y*)
X				    echo "-- " >> $tmpart
X				    cat $dotdir/.signature >> $tmpart
X				    ;;
X				esac
X			    fi
X			    sign=no
X			    ;;
X			esac
X			case "$mailer" in
X			*recmail)
X			    $echo To: $moderator | $cat - $tmpart | $mailer
X			    ;;
X			*)
X			    $mailer $moderator < $tmpart
X			    ;;
X			esac
X			case $? in
X			0) ;;
X			*)
X			    $echo Unable to mail to moderator $moderator
X			    state=rescue
X			    ;;
X			esac
X			;;
X		    esac
X		done
X	    else
X		tryinews=yes
X	    fi
X	    case "$tryinews" in
X	    yes)
X		if $sed '1,/^[	 ]*$/{/^[A-Z][-A-Za-z0-9]*:[	 ]*$/d;}' $tmpart |
X			$inews -h ; then
X		    : null
X		else
X		    state=rescue
X		fi
X		;;
X	    esac
X	    ;;
X	*)
X	    $echo ""
X	    $echo "Malformed Newsgroups line."
X	    $echo ""
X	    sleep 1
X	    state=edit
X	    ;;
X	esac
X	;;
X    rescue)
X	if $test -s $tmpart; then
X		$cat $tmpart >> ${HOME-$LOGDIR}/dead.article
X		$echo "Article appended to ${HOME-$LOGDIR}/dead.article"
X		$echo "A copy may be temporarily found in $tmpart"
X	else
X		$echo "Null article discarded."
X	fi
X	exit
X	;;
X    cleanup)
X	case "${AUTHORCOPY-none}" in
X	none)
X	    ;;
X	*)
X	    set X ${USER-${LOGNAME-`who am i`}} unknown
X	    shift
X	    $rnlib/mbox.saver $tmpart "." "." 0 0 Pnews $AUTHORCOPY "From $1 `date`"
X	    if $test $? -eq 0 ; then
X		$echo "Article appended to $AUTHORCOPY"
X	    else
X		$echo "Cannot append to $AUTHORCOPY"
X	    fi
X	    ;;
X	esac
X	exit
X	;;
X    esac
Xdone
X!NO!SUBS!
X$eunicefix Pnews
Xchmod 755 Pnews
X$spitshell >Pnews.header <<'!NO!SUBS!'
Xcase $# in
X0)
X    ng=h
X    while $test "$ng" = h ; do
X	$echo ""
X	$echo $n "Newsgroup(s): $c"
X	read ng
X	case $ng in
X	h)
X	    $cat <<'EOH'
X
XType the name of one or more newsgroups to which you wish to post an article.
XIf you want to post to multiple newsgroups, it is better to do them all at
Xonce than to post to each newsgroup individually, which defeats the news
Xreading programs' strategies of eliminating duplicates.
X
XSeparate multiple newsgroup names with commas.
XEOH
X	    ;;
X	esac
X    done
X    ;;
X*)
X    ng=$1
X    shift
X    ;;
Xesac
Xcase $ng in
X*\ *)
X    ng=`$echo "$ng" | $sed 's/[, ] */,/g'`
X    ;;
Xesac
Xcase $ng in
Xbit.*|pubnet.*|bionet.*|vmsnet.*|comp.*|news.*|sci.*|rec.*|misc.*|soc.*|talk.*|alt.*)
X    defdist=world
X    dist=h
X    ;;
Xddn.*)
X    defdist=inet
X    dist=h
X    ;;
Xto.*)
X    defdist=''
X    dist=''
X    ;;
X*.*)
X    defdist=`expr "X$ng" : 'X\([a-z0-9]*\)'`
X    dist=h
X    ;;
X*)
X    defdist=''
X    dist=''
X    ;;
Xesac
X
Xwhile $test "$dist" = h ; do
X    if $test -f $lib/distributions; then
X	$echo " "
X	$echo "Your local distribution prefixes are:"
X	$cat $lib/distributions
X	$echo " "
X    else
X	$egrep -v '[	 ]none$' <<EOM
X
XYour local distribution prefixes are:
X    Local organization:	$loc
X    Organization:	$org
X    City:		$city
X    $stpr:  		$state
X    Country:		$cntry
X    Continent:		$cont
X    Everywhere:		world
X
XEOM
X    fi
X    $echo $n "Distribution ($defdist): $c"
X    read dist
X    case $dist in
X    '') dist=$defdist ;;
X    esac
X    case $dist in
X    h)
X	$cat <<'EOH'
X
XThe Distribution line may be used to limit the distribution of an article
Xto some subset of the systems that would receive the article based only on
Xthe Newsgroups line.  For example, if you want to sell your car in talk.auto,
Xand you live in New Jersey, you might want to put "nj" on the Distribution
Xline to avoid advertising in California, which has enough problems of its own.
XThe actual area designators to use depend on where you are, of course.
XEOH
X	;;
X    ''|$loc*|$org*|$city*|$state*|$cntry*|$cont*|$defdist)
X	;;
X    world*|comp*|news*|sci*|rec*|misc*|soc*|talk*|alt*)
X	dist=''
X	;;
X    *)  
X	if $test -f $lib/distributions && \
X	  $egrep "^$dist[ 	]" $lib/distributions >$tmpart && \
X	  $test -s $tmpart; then
X	    : null
X	else
X	    $echo "Unrecognized distribution prefix--type h for help, CR to use anyway."
X	    defdist=$dist
X	    dist=h
X	fi
X	;;
X    esac
Xdone
X
Xfollow=""
X
Xcase $# in
X0)
X    title=h
X    while $test "$title" = h ; do
X	$echo ""
X	$echo $n "Title/Subject: $c"
X	read title
X	case $title in
X	h)
X	    $cat <<'EOH'
X
XType the title for your article.  Please make it as informative as possible
X(within reason) so that people who aren't interested won't have to read the
Xarticle to find out they aren't interested.  This includes marking movie
Xspoilers as (spoiler), and rotated jokes as (rot 13).
XEOH
X	;;
X	esac
X    done
X    ;;
X*)
X    title="$*"
X    ;;
Xesac
X
X# now build a file with a header for them to edit
X
Xset X ${USER-${LOGNAME-`who am i`}}
Xshift
Xlogname=$1
Xcase $logname in
X*!*) logname=`expr "$logname" : '!\(.*\)$'` ;;
Xesac
Xcase ${NAME-$nametype} in
Xbsd)
X	if $test "$ypmatch" != ""; then
X		fullname=`$ypmatch $logname passwd 2>/dev/null | $sed "s/^[^:]*:[^:]*:[^:]*:[^:]*:\([^,:;]*\).*"'$'"/\1/"`
X	elif $test "$nidump" != ""; then
X		fullname=`$nidump passwd / | $sed -e "/^$logname:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:\([^,:;]*\).*"'$'"/\1/" -e "q" -e "}" -e "d"`
X	fi
X     if $test "$fullname" = ""; then
X		fullname=`$sed </etc/passwd -e "/^$logname:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:\([^,:;]*\).*"'$'"/\1/" -e "q" -e "}" -e "d"`
X	fi
X    case $fullname in
X    *'&'*) : GACK
X	lname=`$echo $logname | $tr 'a-z' 'A-Z'`
X	lname=`$echo $lname $logname | $sed 's/^\(.\)[^ ]* ./\1/'`
X	fullname=`$echo "$fullname" | $sed "s/&/${lname}/"`
X	;;
X    esac
X    ;;
Xusg)
X	if $test "$ypmatch" != ""; then
X		fullname=`$ypmatch $logname passwd 2>/dev/null | $sed -e "s/^[^:]*:[^:]*:[^:]*:[^:]*:\([^(:]*\).*"'$'"/\1/" -e "s/^.*-//" -e "q"`
X	fi
X     if $test "$fullname" = ""; then
X    fullname=`$sed </etc/passwd -e "/^$logname:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:\([^(:]*\).*"'$'"/\1/" -e "s/^.*-//" -e "q" -e "}" -e "d"`
X	fi
X    ;;
X*)
X    fullname=${NAME-`$cat $dotdir/.fullname`}
X    ;;
Xesac
X
Xorgname=${ORGANIZATION-$orgname}
Xcase $orgname in
X/*) orgname=`$cat $orgname` ;;
Xesac
X
X$sed -e '/^Reply-To: $/d' > $tmpart <<EOHeader
XNewsgroups: $ng
XSubject: $title
XSummary: 
XReply-To: $REPLYTO
XFollowup-To: $follow
XDistribution: $dist
XOrganization: $orgname
XKeywords: 
X
XEOHeader
X
X!NO!SUBS!
Xcase "$isrrn" in
Xdefine) sed < Pnews.header -e '/^#NORMAL/d' > Pnews.h.new ;;
X*)  sed < Pnews.header -e '/^#NORMAL/s/^#NORMAL//' > Pnews.h.new ;;
Xesac
Xmv Pnews.h.new Pnews.header
X$eunicefix Pnews.header
END_OF_FILE
  if test 18036 -ne `wc -c <'Pnews.SH'`; then
    echo shar: \"'Pnews.SH'\" unpacked with wrong size!
  fi
  chmod +x 'Pnews.SH'
  # end of 'Pnews.SH'
fi
if test -f 'getdate.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getdate.y'\"
else
  echo shar: Extracting \"'getdate.y'\" \(12373 characters\)
  sed "s/^X//" >'getdate.y' <<'END_OF_FILE'
X%token ID MONTH DAY MERIDIAN NUMBER UNIT MUNIT SUNIT ZONE DAYZONE AGO
X%{
X	/* 	Steven M. Bellovin (unc!smb)			*/
X	/*	Dept. of Computer Science			*/
X	/*	University of North Carolina at Chapel Hill	*/
X	/*	@(#)getdate.y	2.13	9/16/86 */
X
X#include <sys/types.h>
X#include <ctype.h>
X#include <time.h>
X
X#define	NULL	0
X
X#define daysec (24L*60L*60L)
X
X	static int timeflag, zoneflag, dateflag, dayflag, relflag;
X	static time_t relsec, relmonth;
X	static int hh, mm, ss, merid, daylight;
X	static int dayord, dayreq;
X	static int month, day, year;
X	static int ourzone;
X
X#define AM 1
X#define PM 2
X#define DAYLIGHT 1
X#define STANDARD 2
X#define MAYBE    3
X%}
X
X%%
Xtimedate: 		/* empty */
X	| timedate item;
X
Xitem:	tspec =
X		{timeflag++;}
X	| zone =
X		{zoneflag++;}
X	| dtspec =
X		{dateflag++;}
X	| dyspec =
X		{dayflag++;}
X	| rspec =
X		{relflag++;}
X	| nspec;
X
Xnspec:	NUMBER =
X		{if (timeflag && dateflag && !relflag) year = $1;
X		else {timeflag++;hh = $1/100;mm = $1%100;ss = 0;merid = 24;}};
X
Xtspec:	NUMBER MERIDIAN =
X		{hh = $1; mm = 0; ss = 0; merid = $2;}
X	| NUMBER ':' NUMBER =
X		{hh = $1; mm = $3; merid = 24;}
X	| NUMBER ':' NUMBER MERIDIAN =
X		{hh = $1; mm = $3; merid = $4;}
X	| NUMBER ':' NUMBER NUMBER =
X		{hh = $1; mm = $3; merid = 24;
X		daylight = STANDARD; ourzone = -($4%100 + 60*$4/100);}
X	| NUMBER ':' NUMBER ':' NUMBER =
X		{hh = $1; mm = $3; ss = $5; merid = 24;}
X	| NUMBER ':' NUMBER ':' NUMBER MERIDIAN =
X		{hh = $1; mm = $3; ss = $5; merid = $6;}
X	| NUMBER ':' NUMBER ':' NUMBER NUMBER =
X		{hh = $1; mm = $3; ss = $5; merid = 24;
X		daylight = STANDARD; ourzone = -($6%100 + 60*$6/100);};
X
Xzone:	ZONE =
X		{ourzone = $1; daylight = STANDARD;}
X	| DAYZONE =
X		{ourzone = $1; daylight = DAYLIGHT;};
X
Xdyspec:	DAY =
X		{dayord = 1; dayreq = $1;}
X	| DAY ',' =
X		{dayord = 1; dayreq = $1;}
X	| NUMBER DAY =
X		{dayord = $1; dayreq = $2;};
X
Xdtspec:	NUMBER '/' NUMBER =
X		{month = $1; day = $3;}
X	| NUMBER '/' NUMBER '/' NUMBER =
X		{month = $1; day = $3; year = $5;}
X	| MONTH NUMBER =
X		{month = $1; day = $2;}
X	| MONTH NUMBER ',' NUMBER =
X		{month = $1; day = $2; year = $4;}
X	| NUMBER MONTH =
X		{month = $2; day = $1;}
X	| NUMBER MONTH NUMBER =
X		{month = $2; day = $1; year = $3;};
X
X
Xrspec:	NUMBER UNIT =
X		{relsec +=  60L * $1 * $2;}
X	| NUMBER MUNIT =
X		{relmonth += $1 * $2;}
X	| NUMBER SUNIT =
X		{relsec += $1;}
X	| UNIT =
X		{relsec +=  60L * $1;}
X	| MUNIT =
X		{relmonth += $1;}
X	| SUNIT =
X		{relsec++;}
X	| rspec AGO =
X		{relsec = -relsec; relmonth = -relmonth;};
X%%
X
Xstatic int mdays[12] =
X	{31, 0, 31,  30, 31, 30,  31, 31, 30,  31, 30, 31};
X#define epoch 1970
X
Xextern struct tm *localtime();
Xtime_t dateconv(mm, dd, yy, h, m, s, mer, zone, dayflag)
Xint mm, dd, yy, h, m, s, mer, zone, dayflag;
X{
X	time_t tod, jdate;
X	register int i;
X	time_t timeconv();
X
X	if (yy < 0) yy = -yy;
X	if (yy < 100) yy += 1900;
X	mdays[1] = 28 + (yy%4 == 0 && (yy%100 != 0 || yy%400 == 0));
X	if (yy < epoch || yy > 1999 || mm < 1 || mm > 12 ||
X		dd < 1 || dd > mdays[--mm]) return (-1);
X	jdate = dd-1;
X        for (i=0; i<mm; i++) jdate += mdays[i];
X	for (i = epoch; i < yy; i++) jdate += 365 + (i%4 == 0);
X	jdate *= daysec;
X	jdate += zone * 60L;
X	if ((tod = timeconv(h, m, s, mer)) < 0) return (-1);
X	jdate += tod;
X	if (dayflag==DAYLIGHT || (dayflag==MAYBE&&localtime(&jdate)->tm_isdst))
X		jdate += -1*60*60;
X	return (jdate);
X}
X
Xtime_t dayconv(ord, day, now) int ord, day; time_t now;
X{
X	register struct tm *loctime;
X	time_t tod;
X	time_t daylcorr();
X
X	tod = now;
X	loctime = localtime(&tod);
X	tod += daysec * ((day - loctime->tm_wday + 7) % 7);
X	tod += 7*daysec*(ord<=0?ord:ord-1);
X	return daylcorr(tod, now);
X}
X
Xtime_t timeconv(hh, mm, ss, mer) register int hh, mm, ss, mer;
X{
X	if (mm < 0 || mm > 59 || ss < 0 || ss > 59) return (-1);
X	switch (mer) {
X		case AM: if (hh < 1 || hh > 12) return(-1);
X			 return (60L * ((hh%12)*60L + mm)+ss);
X		case PM: if (hh < 1 || hh > 12) return(-1);
X			 return (60L * ((hh%12 +12)*60L + mm)+ss);
X		case 24: if (hh < 0 || hh > 23) return (-1);
X			 return (60L * (hh*60L + mm)+ss);
X		default: return (-1);
X	}
X}
Xtime_t monthadd(sdate, relmonth) time_t sdate, relmonth;
X{
X	struct tm *ltime;
X	time_t dateconv();
X	time_t daylcorr();
X	int mm, yy;
X
X	if (relmonth == 0) return 0;
X	ltime = localtime(&sdate);
X	mm = 12*ltime->tm_year + ltime->tm_mon + relmonth;
X	yy = mm/12;
X	mm = mm%12 + 1;
X	return daylcorr(dateconv(mm, ltime->tm_mday, yy, ltime->tm_hour,
X		ltime->tm_min, ltime->tm_sec, 24, ourzone, MAYBE), sdate);
X}
X
Xtime_t daylcorr(future, now) time_t future, now;
X{
X	int fdayl, nowdayl;
X
X	nowdayl = (localtime(&now)->tm_hour+1) % 24;
X	fdayl = (localtime(&future)->tm_hour+1) % 24;
X	return (future-now) + 60L*60L*(nowdayl-fdayl);
X}
X
Xstatic char *lptr;
X
Xyylex()
X{
X	extern int yylval;
X	int sign;
X	register char c;
X	register char *p;
X	char idbuf[20];
X	int pcnt;
X
X	for (;;) {
X		while (isspace(*lptr)) lptr++;
X
X		if (isdigit(c = *lptr) || c == '-' || c == '+') {
X			if (c== '-' || c == '+') {
X				if (c=='-') sign = -1;
X				else sign = 1;
X				if (!isdigit(*++lptr)) {
X					/* yylval = sign; return (NUMBER); */
X					return yylex();	/* skip the '-' sign */
X				}
X			} else sign = 1;
X			yylval = 0;
X			while (isdigit(c = *lptr++)) yylval = 10*yylval + c - '0';
X			yylval *= sign;
X			lptr--;
X			return (NUMBER);
X
X		} else if (isalpha(c)) {
X			p = idbuf;
X			while (isalpha(c = *lptr++) || c=='.')
X				if (p < &idbuf[sizeof(idbuf)-1])
X					*p++ = c;
X			*p = '\0';
X			lptr--;
X			return (lookup(idbuf));
X		}
X
X		else if (c == '(') {
X			pcnt = 0;
X			do {
X				c = *lptr++;
X				if (c == '\0') return(c);
X				else if (c == '(') pcnt++;
X				else if (c == ')') pcnt--;
X			} while (pcnt > 0);
X		}
X
X		else return (*lptr++);
X	}
X}
X
Xstruct table {
X	char *name;
X	int type, value;
X};
X
Xstruct table mdtab[] = {
X	{"January", MONTH, 1},
X	{"February", MONTH, 2},
X	{"March", MONTH, 3},
X	{"April", MONTH, 4},
X	{"May", MONTH, 5},
X	{"June", MONTH, 6},
X	{"July", MONTH, 7},
X	{"August", MONTH, 8},
X	{"September", MONTH, 9},
X	{"Sept", MONTH, 9},
X	{"October", MONTH, 10},
X	{"November", MONTH, 11},
X	{"December", MONTH, 12},
X
X	{"Sunday", DAY, 0},
X	{"Monday", DAY, 1},
X	{"Tuesday", DAY, 2},
X	{"Tues", DAY, 2},
X	{"Wednesday", DAY, 3},
X	{"Wednes", DAY, 3},
X	{"Thursday", DAY, 4},
X	{"Thur", DAY, 4},
X	{"Thurs", DAY, 4},
X	{"Friday", DAY, 5},
X	{"Saturday", DAY, 6},
X	{0, 0, 0}};
X
X#define HRS *60
X#define HALFHR 30
Xstruct table mztab[] = {
X	{"a.m.", MERIDIAN, AM},
X	{"am", MERIDIAN, AM},
X	{"p.m.", MERIDIAN, PM},
X	{"pm", MERIDIAN, PM},
X	{"nst", ZONE, 3 HRS + HALFHR},		/* Newfoundland */
X	{"n.s.t.", ZONE, 3 HRS + HALFHR},
X	{"ast", ZONE, 4 HRS},		/* Atlantic */
X	{"a.s.t.", ZONE, 4 HRS},
X	{"adt", DAYZONE, 4 HRS},
X	{"a.d.t.", DAYZONE, 4 HRS},
X	{"est", ZONE, 5 HRS},		/* Eastern */
X	{"e.s.t.", ZONE, 5 HRS},
X	{"edt", DAYZONE, 5 HRS},
X	{"e.d.t.", DAYZONE, 5 HRS},
X	{"cst", ZONE, 6 HRS},		/* Central */
X	{"c.s.t.", ZONE, 6 HRS},
X	{"cdt", DAYZONE, 6 HRS},
X	{"c.d.t.", DAYZONE, 6 HRS},
X	{"mst", ZONE, 7 HRS},		/* Mountain */
X	{"m.s.t.", ZONE, 7 HRS},
X	{"mdt", DAYZONE, 7 HRS},
X	{"m.d.t.", DAYZONE, 7 HRS},
X	{"pst", ZONE, 8 HRS},		/* Pacific */
X	{"p.s.t.", ZONE, 8 HRS},
X	{"pdt", DAYZONE, 8 HRS},
X	{"p.d.t.", DAYZONE, 8 HRS},
X	{"yst", ZONE, 9 HRS},		/* Yukon */
X	{"y.s.t.", ZONE, 9 HRS},
X	{"ydt", DAYZONE, 9 HRS},
X	{"y.d.t.", DAYZONE, 9 HRS},
X	{"hst", ZONE, 10 HRS},		/* Hawaii */
X	{"h.s.t.", ZONE, 10 HRS},
X	{"hdt", DAYZONE, 10 HRS},
X	{"h.d.t.", DAYZONE, 10 HRS},
X
X	{"gmt", ZONE, 0 HRS},
X	{"g.m.t.", ZONE, 0 HRS},
X	{"bst", DAYZONE, 0 HRS},		/* British Summer Time */
X	{"b.s.t.", DAYZONE, 0 HRS},
X	{"eet", ZONE, 0 HRS},		/* European Eastern Time */
X	{"e.e.t.", ZONE, 0 HRS},
X	{"eest", DAYZONE, 0 HRS},	/* European Eastern Summer Time */
X	{"e.e.s.t.", DAYZONE, 0 HRS},
X	{"met", ZONE, -1 HRS},		/* Middle European Time */
X	{"m.e.t.", ZONE, -1 HRS},
X	{"mest", DAYZONE, -1 HRS},	/* Middle European Summer Time */
X	{"m.e.s.t.", DAYZONE, -1 HRS},
X	{"wet", ZONE, -2 HRS },		/* Western European Time */
X	{"w.e.t.", ZONE, -2 HRS },
X	{"west", DAYZONE, -2 HRS},	/* Western European Summer Time */
X	{"w.e.s.t.", DAYZONE, -2 HRS},
X
X	{"jst", ZONE, -9 HRS},		/* Japan Standard Time */
X	{"j.s.t.", ZONE, -9 HRS},	/* Japan Standard Time */
X					/* No daylight savings time */
X
X	{"aest", ZONE, -10 HRS},	/* Australian Eastern Time */
X	{"a.e.s.t.", ZONE, -10 HRS},
X	{"aesst", DAYZONE, -10 HRS},	/* Australian Eastern Summer Time */
X	{"a.e.s.s.t.", DAYZONE, -10 HRS},
X	{"acst", ZONE, -(9 HRS + HALFHR)},	/* Australian Central Time */
X	{"a.c.s.t.", ZONE, -(9 HRS + HALFHR)},
X	{"acsst", DAYZONE, -(9 HRS + HALFHR)},	/* Australian Central Summer */
X	{"a.c.s.s.t.", DAYZONE, -(9 HRS + HALFHR)},
X	{"awst", ZONE, -8 HRS},		/* Australian Western Time */
X	{"a.w.s.t.", ZONE, -8 HRS},	/* (no daylight time there, I'm told */
X	{0, 0, 0}};
X
Xstruct table unittb[] = {
X	{"year", MUNIT, 12},
X	{"month", MUNIT, 1},
X	{"fortnight", UNIT, 14*24*60},
X	{"week", UNIT, 7*24*60},
X	{"day", UNIT, 1*24*60},
X	{"hour", UNIT, 60},
X	{"minute", UNIT, 1},
X	{"min", UNIT, 1},
X	{"second", SUNIT, 1},
X	{"sec", SUNIT, 1},
X	{0, 0, 0}};
X
Xstruct table othertb[] = {
X	{"tomorrow", UNIT, 1*24*60},
X	{"yesterday", UNIT, -1*24*60},
X	{"today", UNIT, 0},
X	{"now", UNIT, 0},
X	{"last", NUMBER, -1},
X	{"this", UNIT, 0},
X	{"next", NUMBER, 2},
X	{"first", NUMBER, 1},
X	/* {"second", NUMBER, 2}, */
X	{"third", NUMBER, 3},
X	{"fourth", NUMBER, 4},
X	{"fifth", NUMBER, 5},
X	{"sixth", NUMBER, 6},
X	{"seventh", NUMBER, 7},
X	{"eigth", NUMBER, 8},
X	{"ninth", NUMBER, 9},
X	{"tenth", NUMBER, 10},
X	{"eleventh", NUMBER, 11},
X	{"twelfth", NUMBER, 12},
X	{"ago", AGO, 1},
X	{0, 0, 0}};
X
Xstruct table milzone[] = {
X	{"a", ZONE, 1 HRS},
X	{"b", ZONE, 2 HRS},
X	{"c", ZONE, 3 HRS},
X	{"d", ZONE, 4 HRS},
X	{"e", ZONE, 5 HRS},
X	{"f", ZONE, 6 HRS},
X	{"g", ZONE, 7 HRS},
X	{"h", ZONE, 8 HRS},
X	{"i", ZONE, 9 HRS},
X	{"k", ZONE, 10 HRS},
X	{"l", ZONE, 11 HRS},
X	{"m", ZONE, 12 HRS},
X	{"n", ZONE, -1 HRS},
X	{"o", ZONE, -2 HRS},
X	{"p", ZONE, -3 HRS},
X	{"q", ZONE, -4 HRS},
X	{"r", ZONE, -5 HRS},
X	{"s", ZONE, -6 HRS},
X	{"t", ZONE, -7 HRS},
X	{"u", ZONE, -8 HRS},
X	{"v", ZONE, -9 HRS},
X	{"w", ZONE, -10 HRS},
X	{"x", ZONE, -11 HRS},
X	{"y", ZONE, -12 HRS},
X	{"z", ZONE, 0 HRS},
X	{0, 0, 0}};
X
Xlookup(id) char *id;
X{
X#define gotit (yylval=i->value,  i->type)
X#define getid for(j=idvar, k=id; *j++ = *k++; )
X
X	char idvar[20];
X	register char *j, *k;
X	register struct table *i;
X	int abbrev;
X
X	getid;
X	if (strlen(idvar) == 3) abbrev = 1;
X	else if (strlen(idvar) == 4 && idvar[3] == '.') {
X		abbrev = 1;
X		idvar[3] = '\0';
X	}
X	else abbrev = 0;
X
X	if (islower(*idvar)) *idvar = toupper(*idvar);
X
X	for (i = mdtab; i->name; i++) {
X		k = idvar;
X		for (j = i->name; *j++ == *k++;) {
X			if (abbrev && j==i->name+3) return gotit;
X			if (j[-1] == 0) return gotit;
X		}
X	}
X
X	getid;
X	for (i = mztab; i->name; i++)
X		if (strcmp(i->name, idvar) == 0) return gotit;
X
X	for (j = idvar; *j; j++)
X		if (isupper(*j)) *j = tolower(*j);
X	for (i=mztab; i->name; i++)
X		if (strcmp(i->name, idvar) == 0) return gotit;
X
X	getid;
X	for (i=unittb; i->name; i++)
X		if (strcmp(i->name, idvar) == 0) return gotit;
X
X	if (idvar[strlen(idvar)-1] == 's')
X		idvar[strlen(idvar)-1] = '\0';
X	for (i=unittb; i->name; i++)
X		if (strcmp(i->name, idvar) == 0) return gotit;
X
X	getid;
X	for (i = othertb; i->name; i++)
X		if (strcmp(i->name, idvar) == 0) return gotit;
X
X	getid;
X	if (strlen(idvar) == 1 && isalpha(*idvar)) {
X		if (isupper(*idvar)) *idvar = tolower(*idvar);
X		for (i = milzone; i->name; i++)
X			if (strcmp(i->name, idvar) == 0) return gotit;
X	}
X
X	return(ID);
X}
X
Xtime_t getdate(p, now, zone) char *p; time_t now; long zone;
X{
X#define mcheck(f)	if (f>1) err++
X	time_t monthadd();
X	int err;
X	struct tm *lt;
X	time_t sdate, tod;
X
X	lptr = p;
X	if (now <= 0)
X		(void) time(&now);
X	lt = localtime(&now);
X	year = lt->tm_year;
X	month = lt->tm_mon+1;
X	day = lt->tm_mday;
X	relsec = 0; relmonth = 0;
X	timeflag=zoneflag=dateflag=dayflag=relflag=0;
X	daylight = MAYBE;
X	hh = mm = ss = 0;
X	merid = 24;
X	ourzone = zone;
X
X	if (err = yyparse()) return (-1);
X
X	mcheck(timeflag);
X	mcheck(zoneflag);
X	mcheck(dateflag);
X	mcheck(dayflag);
X
X	if (err) return (-1);
X	if (dateflag || timeflag || dayflag) {
X		sdate = dateconv(month,day,year,hh,mm,ss,merid,ourzone,daylight);
X		if (sdate < 0) return -1;
X	}
X	else {
X		sdate = now;
X		if (relflag == 0)
X			sdate -= (lt->tm_sec + lt->tm_min*60 +
X				lt->tm_hour*(60L*60L));
X	}
X
X	sdate += relsec;
X	sdate += monthadd(sdate, relmonth);
X
X	if (dayflag && !dateflag) {
X		tod = dayconv(dayord, dayreq, sdate);
X		sdate += tod;
X	}
X
X	return sdate;
X}
X
Xyyerror(s) char *s;
X{}
END_OF_FILE
  if test 12373 -ne `wc -c <'getdate.y'`; then
    echo shar: \"'getdate.y'\" unpacked with wrong size!
  fi
  # end of 'getdate.y'
fi
if test -f 'help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.c'\"
else
  echo shar: Extracting \"'help.c'\" \(15622 characters\)
  sed "s/^X//" >'help.c' <<'END_OF_FILE'
X/* $Header: help.c,v 4.3.3.1 90/07/24 21:52:37 davison Trn $
X *
X * $Log:	help.c,v $
X * Revision 4.3.3.1  90/07/24  21:52:37  davison
X * Initial Trn Release
X * 
X * Revision 4.3.1.2  85/09/10  11:05:39  lwall
X * Improved %m in in_char().
X * 
X * Revision 4.3.1.1  85/05/10  11:33:10  lwall
X * Branch for patches.
X * 
X * Revision 4.3  85/05/01  11:38:59  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "rn.h"
X#include "term.h"
X#include "INTERN.h"
X#include "help.h"
X
Xvoid
Xhelp_init()
X{
X    ;
X}
X
Xint
Xhelp_page()
X{
X    int cmd;
X
X#ifdef PAGERHELP
X    doshell(sh,filexp(PAGERHELP));
X#else
X    page_init();
X    if ((cmd = print_lines("\
XPaging commands:\n\
X",STANDOUT)) ||
X    (cmd = print_lines("\n\
XSP	Display the next page.\n\
Xx	Display the next page decrypted (rot13).\n\
Xd	Display half a page more.\n\
XCR	Display one more line.\n\
X^R,v,^X	Restart the current article (v=verbose header, ^X=rot13).\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xb	Back up one page.\n\
X^L,X	Refresh the screen (X=rot13).\n\
X",NOMARKING)) ||
X#ifdef USETHREADS
X    (cmd = print_lines("\
Xt	Display the entire article tree and all its subjects.\n\
X",NOMARKING)) ||
X#endif
X    (cmd = print_lines("\
Xg pat	Go to (search forward within article for) pattern.\n\
XG	Search again for current pattern within article.\n\
X^G	Search for next line beginning with \"Subject:\".\n\
XTAB	Search for next line beginning with a different character.\n\
Xq	Quit the pager, go to end of article.  Leave article read or unread.\n\
Xj	Junk this article (mark it read).  Goes to end of article.\n\
X\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XThe following commands skip the rest of the current article, then behave\n\
Xjust as if typed to the 'What next?' prompt at the end of the article:\n\
X",STANDOUT)) ||
X    (cmd = print_lines("\n\
Xn	Scan forward for next unread article.\n\
XN	Go to next article.\n\
X^N	Scan forward for next unread article with same title.\n\
Xp,P,^P	Same as n,N,^N, only going backwards.\n\
X-	Go to previously displayed article.\n\
X",NOMARKING)) ||
X#ifdef USETHREADS
X    (cmd = print_lines("\
X<,>	Browse the previous/next selected thread.  If no threads are selected,\n\
X	all threads that had unread news upon entry to the group are considered\n\
X	selected for browsing.  Entering an empty group browses all threads.\n\
X[,],{,} Go to parent/child/root/leaf in thread.\n\
X\n\
X",NOMARKING)) ||
X#endif
X    (cmd = print_lines("\
XThe following commands also take you to the end of the article.\n\
XType h at end of article for a description of these commands:\n\
X",STANDOUT)) ||
X#ifdef USETHREADS
X    (cmd = print_lines("\
X	# $ & / = ? c C f F k K ^K J , m M number e r R ^R s S u U v w W Y ^ |\n\
X\n\
X(To return to the middle of the article after one of these commands, type ^L.)\n\
X",NOMARKING)) )
X#else
X    (cmd = print_lines("\
X	# $ & / = ? c C f F k K ^K m M number e r R ^R s S u v w W Y ^ |\n\
X\n\
X(To return to the middle of the article after one of these commands, type ^L.)\n\
X",NOMARKING)) )
X#endif
X	return cmd;
X#endif
X    return 0;
X}
X
Xint
Xhelp_art()
X{
X    int cmd;
X#ifdef ARTHELP
X    doshell(sh,filexp(ARTHELP));
X#else
X    page_init();
X    if ((cmd = print_lines("\
XArticle Selection commands:\n\
X",STANDOUT)) ||
X#ifdef USETHREADS
X    (cmd = print_lines("\n\
Xn,SP	Find next unread article (follows discussion-tree in threaded groups).\n\
X",NOMARKING)) ||
X#else
X    (cmd = print_lines("\n\
Xn,SP	Scan forward for next unread article.\n\
X",NOMARKING)) ||
X#endif
X    (cmd = print_lines("\
XN	Go to next article.\n\
X^N	Scan forward for next unread article with same subject.\n\
Xp,P,^P	Same as n,N,^N, only going backwards.\n\
X-	Go to previously displayed article.\n\
X",NOMARKING)) ||
X#ifdef USETHREADS
X    (cmd = print_lines("\
X<,>	Browse the previous/next selected thread.  If no threads are selected,\n\
X	all threads that had unread news upon entry to the group are considered\n\
X	selected for browsing.  Entering an empty group browses all threads.\n\
X[,]	Go to article's parent/child.\n\
X{,}	Go to tree's root/leaf.\n\
Xt	Display the entire article tree and all its subjects.\n\
X",NOMARKING)) ||
X#endif
X    (cmd = print_lines("\
Xnumber	Go to specified article.\n\
Xrange{,range}:command{:command}\n\
X	Apply one or more commands to one or more ranges of articles.\n\
X	Ranges are of the form: number | number-number.  You may use . for\n\
X	the current article, and $ for the last article.\n\
X",NOMARKING)) ||
X#ifdef USETHREADS
X    (cmd = print_lines("\
X 	Valid commands are: e, j, m, M, s, S, t, T, |, +, and -.\n\
X:cmd	Perform a command on all the selected articles.\n\
X",NOMARKING)) ||
X#else
X    (cmd = print_lines("\
X 	Valid commands are: e, j, m, M, s, S, and |.\n\
X",NOMARKING)) ||
X#endif
X    (cmd = print_lines("\
X/pattern/modifiers\n\
X	Scan forward for article containing pattern in the subject line.\n\
X	(Use ?pat? to scan backwards; append h to scan headers, a to scan\n\
X	entire articles, r to scan read articles, c to make case sensitive.)\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X/pattern/modifiers:command{:command}\n\
X	Apply one or more commands to the set of articles matching pattern.\n\
X	Use a K modifier to save entire command to the KILL file for this\n\
X	newsgroup.  Commands m and M, if first, imply an r modifier.\n\
X 	Valid commands are the same as for the range command.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xf,F	Submit a followup article (F = include this article).\n\
Xr,R	Reply through net mail (R = include this article).\n\
Xe dir{|command}\n\
X	Extract to directory using /bin/sh, uudecode, or specified command.\n\
Xs ...	Save to file or pipe via sh.\n\
XS ...	Save via preferred shell.\n\
Xw,W	Like s and S but save without the header.\n\
X| ...	Same as s|...\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XC	Cancel this article, if yours.\n\
X^R,v	Restart article (v=verbose).\n\
X^X	Restart article, rot13 mode.\n\
Xc	Catch up (mark all articles as read).\n\
Xb	Back up one page.\n\
X^L	Refresh the screen.  You can get back to the pager with this.\n\
XX	Refresh screen in rot13 mode.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X^	Go to first unread article.  Disables subject search mode.\n\
X$	Go to end of newsgroup.  Disables subject search mode.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("#       Print last article number.\n\
X&	Print current values of command-line switches.\n\
X&switch {switch}\n\
X	Set or unset more switches.\n\
X&&	Print current macro definitions.\n\
X&&def	Define a new macro.\n\
Xj	Junk this article (mark it read).  Stays at end of article.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xm	Mark article as still unread.\n\
XM	Mark article as still unread upon exiting newsgroup or Y command.\n\
XY	Yank back articles marked temporarily read via M.\n\
Xk	Kill current subject (mark articles as read).\n\
X",NOMARKING)) ||
X#ifdef USETHREADS
X    (cmd = print_lines("\
X,	Mark current article and its replies as read.\n\
XJ	Junk entire thread (mark all subjects as read in this thread).\n\
XT	Trash current thread (like 'J'), and save command in KILL file.\n\
X",NOMARKING)) ||
X#endif
X    (cmd = print_lines("\
XK	Mark current subject as read, and save command in KILL file.\n\
X^K	Edit local KILL file (the one for this newsgroup).\n\
X=	List subjects of unread articles.\n\
X",NOMARKING)) ||
X#ifdef USETHREADS
X    (cmd = print_lines("\
X+	Enter thread selection mode.\n\
XU	Unread some news -- prompts for thread, subthread, all, or select.\n\
X",NOMARKING)) ||
X#endif
X    (cmd = print_lines("\
Xu	Unsubscribe from this newsgroup.\n\
Xq	Quit this newsgroup for now.\n\
XQ	Quit newsgroup, staying at current newsgroup.\n\
X",NOMARKING)) )
X	return cmd;
X#endif
X    return 0;
X}
X
Xint
Xhelp_ng()
X{
X    int cmd;
X#ifdef NGHELP
X    doshell(sh,filexp(NGHELP));
X#else
X    page_init();
X    if (cmd = print_lines("\
XNewsgroup Selection commands:\n\
X",STANDOUT) )
X	return cmd;
X    if (ng != nextrcline) {
X	if ((cmd = print_lines("\
X\n\
Xy,SP	Do this newsgroup now.\n\
X.cmd	Do this newsgroup, executing cmd as first command.\n\
X",NOMARKING)) ||
X#ifdef USETHREADS
X    (cmd = print_lines("\
X+	Enter this newsgroup through the thread selector (like typing .+<CR>).\n\
X",NOMARKING)) ||
X#endif
X    (cmd = print_lines("\
X=	Start this newsgroup, but list subjects before reading articles.\n\
X",NOMARKING)) ||
X#ifdef USETHREADS
X    (cmd = print_lines("\
XU	Enter this newsgroup by way of the \"Set unread?\" prompt.\n\
X",NOMARKING)) ||
X#endif
X    (cmd = print_lines("\
Xu	Unsubscribe from this newsgroup.\n\
X",NOMARKING)) )
X	    return cmd;
X    }
X    if ((cmd = print_lines("\
Xc	Catch up (mark this newsgroup all read).\n\
X\n\
Xn	Go to the next newsgroup with unread news.\n\
XN	Go to the next newsgroup.\n\
Xp	Go to the previous newsgroup with unread news.\n\
XP	Go to the previous newsgroup.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X-	Go to the previously displayed newsgroup.\n\
X1	Go to the first newsgroup.\n\
X^	Go to the first newsgroup with unread news.\n\
X$	Go to the last newsgroup.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xg name	Go to the named newsgroup.  Subscribe to new newsgroups this way too.\n\
X/pat	Search forward for newsgroup matching pattern.\n\
X?pat	Search backward for newsgroup matching pattern.\n\
X	(Use * and ? style patterns.  Append r to include read newsgroups.)\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xl pat	List unsubscribed newsgroups containing pattern.\n\
Xm name	Move named newsgroup elsewhere (no name moves current newsgroup).\n\
Xo pat	Only display newsgroups matching pattern.  Omit pat to unrestrict.\n\
Xa pat	Like o, but also scans for unsubscribed newsgroups matching pattern.\n\
XL	List current .newsrc.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X&	Print current command-line switch settings.\n\
X&switch {switch}\n\
X	Set (or unset) more command-line switches.\n\
X&&	Print current macro definitions.\n\
X&&def	Define a new macro.\n\
X!cmd	Shell escape.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xq	Quit trn.\n\
Xx	Quit, restoring .newsrc to its state at startup of trn.\n\
X^K	Edit the global KILL file.  Use commands like /pattern/j to suppress\n\
X	pattern in every newsgroup.\n\
Xv	Print version.\n\
X",NOMARKING)) )
X	return cmd;
X#endif
X#ifdef PUSHBACK
X    if (cmd = get_anything())
X	return cmd;
X    show_macros();
X#endif
X    return 0;
X}
X
X#ifdef ESCSUBS
Xint
Xhelp_subs()
X{
X    int cmd;
X#ifdef SUBSHELP
X    doshell(sh,filexp(SUBSHELP));
X#else
X    page_init();
X    if ((cmd = print_lines("\
XValid substitutions are:\n\
X",STANDOUT)) ||
X    (cmd = print_lines("\
X\n\
Xa	Current article number\n\
XA	Full name of current article (%P/%c/%a)\n\
Xb	Destination of last save command, often a mailbox\n\
XB	Bytes to ignore at beginning of last saved article\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xc	Current newsgroup, directory form\n\
XC	Current newsgroup, dot form\n\
Xd	Full name of newsgroup directory (%P/%c)\n\
XD	Distribution line from current article\n\
Xe	The last command executed to extract data from an article\n\
XE	The number of extra (unselected) articles, not counting the current\n\
X	one if it is unselected\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xf	Who the current article is from\n\
XF	Newsgroups to followup to (from Newsgroups and Followup-To)\n\
Xh	(This help message)\n\
XH	Host name (yours)\n\
Xi	Message-I.D. line from current article, with <>\n\
XI	Reference indicator mark (see -F switch)\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xl	News administrator's login name, if any\n\
XL	Login name (yours)\n\
X",NOMARKING)) ||
X#ifdef USETHREADS
X    (cmd = print_lines("\
Xm	Current mode, first letter of (init,newsgroup,thread,article,pager,\n\
X		unread,Add,Catchup,Delete-bogus,Mailbox,Resubscribe)\n\
X",NOMARKING)) ||
X#else
X    (cmd = print_lines("\
Xm	Current mode, first letter of (init, newsgroup, article, pager,\n\
X		Add, Catchup, Delete bogus, Mailbox, Resubscribe)\n\
X",NOMARKING)) ||
X#endif
X    (cmd = print_lines("\
XM	Number of article marked with M\n\
Xn	Newsgroups from current article\n\
XN	Full name (yours)\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xo	Organization (yours)\n\
XO	Original working directory (where you ran trn from)\n\
Xp	Your private news directory (from -d)\n\
XP	Public news spool directory\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xr	Last reference (parent article id)\n\
XR	References list for followup article\n\
Xs	Subject, with all Re's and (nf)'s stripped off\n\
XS	Subject, with one Re stripped off\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xt	New To line derived from From and Reply-To (Internet format)\n\
XT	New To line derived from Path\n\
Xu	Number of unread articles\n\
XU	Number of unread articles not counting the current article (when\n\
X	threads are selected, the count only reflects selected articles)\n\
Xx	News library directory\n\
XX	Trn library directory\n\
Xz	Length of current article in bytes\n\
XZ	Number of selected threads\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X~	Your home directory\n\
X.	Directory containing . files\n\
X#	A counter in multiple-article commands\n\
X$	Current process number\n\
X/	Last search string\n\
XESC	Run preceding command through % interpretation\n\
X",NOMARKING)) )
X	return cmd;
X#endif
X    return 0;
X}
X#endif
X
X#ifdef USETHREADS
Xint
Xhelp_select()
X{
X    int cmd;
X
X    page_init();
X    if ((cmd = print_lines("\
XThread selection commands:\n\
X",STANDOUT)) ||
X    (cmd = print_lines("\n\
Xa-z,0-9	Select/deselect the discussion thread by its letter or number.  By\n\
X	default the letters h, k, m, n, p, q and y are omitted.\n\
XSP	Perform the default command (usually > or Z).\n\
XCR	Start reading.  Selects the current thread if none are selected.\n\
XZ,TAB	Start reading.  If no articles are selected, read everything.\n\
Xy, '.'	Toggle the current thread's selection.\n\
Xk, ','	Mark the current thread as killed.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xm, \\	Unmark the current thread.\n\
X-	Set a range, as in 2 - 5.  Repeats the last marking action.\n\
X@	Toggle all visible thread selections.\n\
Xn, ]	Move down to the next thread.\n\
Xp, [	Move up to the previous thread.\n\
X<, >	Go to previous/next page.\n\
X^, $	Go to first/last page.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XX	Mark all unselected articles as read and start reading.\n\
XD	Mark unselected articles on the current page as read.  Start\n\
X	reading if articles were selected, else go to next page.\n\
XJ	Junk all selected articles (mark them as read).\n\
X^K	Edit local KILL file (the one for this newsgroup).\n\
X:cmd	Perform a command on all the selected articles.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X/pattern/modifiers\n\
X	Scan all articles for a subject containing pattern.\n\
X	(Append h to scan headers, a to scan entire articles, c to make case\n\
X	sensitive, r to scan read articles (assumed when you are selecting\n\
X	read articles to set unread.)\n\
X/pattern/modifiers:command{:command}\n\
X	Apply one or more commands to the set of articles matching pattern.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X	Use a K modifier to save entire command to the KILL file for this\n\
X	newsgroup.  Commands m and M, if first, imply an r modifier.\n\
X 	Valid commands are: e, j, m, M, s, S, T, !, and the thread selection\n\
X	commands: + and -.\n\
XN	Leave this group as-is and go on to the next.\n\
XU	Switch between selecting read/unread articles.\n\
XL	Switch the current display mode between a terse mode without\n\
X	authors and a short and long mode with authors.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X&	View or set command line switches.\n\
X&&	View or set macro definitions.\n\
X!cmd	Escape to a subshell.\n\
Xq	Quit selection mode.\n\
XQ	Quit group and return to news group selection prompt for this group.\n\
X",NOMARKING)) )
X	return cmd;
X    return 0;
X}
X#endif
END_OF_FILE
  if test 15622 -ne `wc -c <'help.c'`; then
    echo shar: \"'help.c'\" unpacked with wrong size!
  fi
  # end of 'help.c'
fi
if test -f 'rn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rn.c'\"
else
  echo shar: Extracting \"'rn.c'\" \(14789 characters\)
  sed "s/^X//" >'rn.c' <<'END_OF_FILE'
X/*  rn -- new readnews program
X *
X *  Original Author: lwall@sdcrdcf.UUCP (Larry Wall)
X *  Organization: System Development Corporation, Santa Monica
X *
X *  begun:   01/14/83
X *	1.0: 04/08/83
X *      2.0: 09/01/83
X *      RRN/RN: 11/01/89
X*/
X
Xstatic char rnid[] = "@(#)$Header: rn.c,v 4.3.3.4 91/06/26 02:25:34 davison Trn $";
Xstatic char patchlevel[] = "Trn v1.0.3 based on Rn patchlevel 54";
X
X/* $Log:	rn.c,v $
X * Revision 4.3.3.4  91/06/26  02:25:34  davison
X * Misc. fixes for minor problems.
X * 
X * Revision 4.3.3.3  91/01/16  03:28:42  davison
X * Integrated rn patches 48-54.  Fixed in_char and verify interaction.
X * 
X * Revision 4.3.3.2  90/08/20  16:48:19  davison
X * Changed unthreaded group's default action, version #, email address.
X * 
X * Revision 4.3.3.1  90/07/21  20:31:38  davison
X * Initial Trn Release
X * 
X * Revision 4.3.2.11  91/01/04  22:58:24  sob
X * Checkpoint for patch 54
X * 
X * Revision 4.3.2.10  90/12/30  22:58:24  sob
X * Checkpoint for patch 53
X * 
X * Revision 4.3.2.9  90/12/13  22:58:24  sob
X * Checkpoint for patch 52
X * 
X * Revision 4.3.2.8  90/12/10  01:35:43  sob
X * Checkpoint for patch 51
X * 
X * Revision 4.3.2.7  90/11/23  20:30:43  sob
X * Checkpoint for patch 50
X * 
X * Revision 4.3.2.6  90/11/22  13:55:23  sob
X * Checkpoint for patch #49
X * 
X * Revision 4.3.2.5  90/11/06  01:19:43  sob
X * Checkpoint for patch 48
X * 
X * Revision 4.3.2.4  90/04/03  23:11:33  sob
X * Added more information to the version command.
X * 
X * Revision 4.3.2.3  90/03/22  23:05:23  sob
X * Fixes provided by Wayne Davison <drivax!davison>
X * 
X * Revision 4.3.2.2  89/11/28  01:51:25  sob
X * Removed redundant #include directive.
X * 
X * Revision 4.3.2.1  89/11/08  02:27:38  sob
X * Release of RN 4.3 with RRN that can be compiled from the same
X * sources as either version of the program.
X * 
X * Revision 4.3.1.4  85/09/10  11:05:13  lwall
X * Improved %m in in_char().
X * 
X * Revision 4.3.1.3  85/05/16  16:47:10  lwall
X * Catchup confirmation didn't grok -t.
X * 
X * Revision 4.3.1.2  85/05/13  09:34:53  lwall
X * Fixed default after do_newsgroup() returns from Q command.
X * 
X * Revision 4.3.1.1  85/05/10  11:38:08  lwall
X * Branch for patches.
X * 
X * Revision 4.3  85/05/01  11:47:56  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "INTERN.h"
X#include "common.h"
X#include "rn.h"
X#include "EXTERN.h"
X#include "rcstuff.h"
X#include "term.h"
X#include "final.h"
X#include "ngdata.h"
X#include "util.h"
X#include "only.h"
X#include "ngsrch.h"
X#include "help.h"
X#include "last.h"
X#include "init.h"
X#include "intrp.h"
X#include "rcln.h"
X#include "sw.h"
X#include "addng.h"
X#include "ng.h"
X
Xvoid
Xrn_init()
X{
X    ;
X}
X
Xvoid
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X    bool foundany;
X    register char *s;
X    bool oh_for_the_good_old_days = FALSE;
X
X#if defined(USETHREADS) && !THREAD_INIT
X    /* Default to threaded operation if our name starts with a 't' */
X    if ((s = rindex(argv[0],'/')) == Nullch)
X	s = argv[0];
X    else
X	s++;
X    if (*s == 't')
X	use_threads = TRUE;
X#endif
X    foundany = initialize(argc,argv);
X
X    if (maxngtodo)
X	starthere = 0;
X    else if (!foundany) {		/* nothing to do? */
X#ifdef VERBOSE
X	if (verbose)
X	    fputs("\
XNo unread news in subscribed-to newsgroups.  To subscribe to a new\n\
Xnewsgroup use the g<newsgroup> command.\n\
X",stdout) FLUSH;
X#endif
X	starthere = nextrcline;
X    }
X
X    /* loop through all unread news */
X
X    {
X	char promptbuf[80];
X	bool special = FALSE;		/* temporarily allow newsgroup */
X					/*   with no unread news? */
X	bool retry;			/* cycle back to top of list? */
X	NG_NUM recent_ng = 0;
X	
X	current_ng = 0;
X	do {
X	    retry = FALSE;
X	    if (findlast) {
X		findlast = FALSE;
X		starthere = 0;
X		if (*lastngname) {
X		    if ((ng = find_ng(lastngname)) == nextrcline)
X			ng = 0;
X		    else {
X			set_ngname(lastngname);
X		    	set_toread(ng);
X			if (toread[ng] <= TR_NONE)
X			    ng = 0;
X		    }
X		}
X	    }
X	    else {
X		ng = starthere;
X		starthere = 0;
X	    }
X	    while (ng <= nextrcline) {	/* for each newsgroup */
X		mode = 'n';
X		if (ng >= nextrcline) {	/* after the last newsgroup? */
X		    ng = nextrcline;	/* force it to 1 after */
X#ifdef ONLY
X		    if (maxngtodo) {
X			if (retry)
X#ifdef VERBOSE
X			    IF(verbose)
X				printf("\nRestriction %s%s still in effect.\n",
X				    ngtodo[0],
X				    maxngtodo > 1 ? ", etc." : nullstr) FLUSH;
X			    ELSE
X#endif
X#ifdef TERSE
X				fputs("\n(\"Only\" mode.)\n",stdout) FLUSH;
X#endif
X			else {
X#ifdef VERBOSE
X			    IF(verbose)
X				fputs("\nNo articles under restriction.",
X				  stdout) FLUSH;
X			    ELSE
X#endif
X#ifdef TERSE
X				fputs("\nNo \"only\" articles.",stdout) FLUSH;
X#endif
X			    end_only();	/* release the restriction */
X			    retry = TRUE;
X			}
X		    }
X#endif
X		    dfltcmd = (retry ? "npq" : "qnp");
X#ifdef VERBOSE
X		    IF(verbose)
X			sprintf(promptbuf,
X			    "\n******** End of newsgroups--what next? [%s] ",
X			    dfltcmd);
X		    ELSE
X#endif
X#ifdef TERSE
X			sprintf(promptbuf,
X			    "\n**** End--next? [%s] ", dfltcmd);
X#endif
X		}
X		else {
X		    bool shoe_fits;	/* newsgroup matches restriction? */
X
X		    if (toread[ng] >= TR_NONE) {	/* recalc toread? */
X			set_ngname(rcline[ng]);
X			if (shoe_fits = (special || inlist(ngname)))
X			    set_toread(ng);
X			if (paranoid) {
X			    recent_ng = current_ng;
X			    current_ng = ng;
X			    cleanup_rc();
X					/* this may move newsgroups around */
X			    ng = current_ng;
X			    set_ngname(rcline[ng]);
X			}
X		    }
X		    if (toread[ng] < (maxngtodo||special ? TR_NONE : TR_ONE) || !shoe_fits) {
X					/* unwanted newsgroup? */
X			ng++;		/* then skip it */
X			continue;
X		    }
X    reprompt_newsgroup:
X#ifdef USETHREADS
X		    dfltcmd = (ThreadedGroup && select_on
X			&& (ART_NUM)toread[ng] >= select_on ? "+ynq" : "ynq");
X#else
X		    dfltcmd = "ynq";
X#endif
X#ifdef VERBOSE
X		    IF(verbose)
X			sprintf(promptbuf,
X			    "\n******** %3ld unread article%s in %s--read now? [%s] ",
X			    (long)toread[ng], (toread[ng]==TR_ONE ? nullstr : "s"),
X			    ngname, dfltcmd);	/* format prompt string */
X		    ELSE
X#endif
X#ifdef TERSE
X			sprintf(promptbuf,
X			    "\n**** %3ld in %s--read? [%s] ",
X			    (long)toread[ng],
X			    ngname,dfltcmd);	/* format prompt string */
X#endif
X		}
X		special = FALSE;	/* go back to normal mode */
X		if (ng != current_ng) {
X		    recent_ng = current_ng;
X					/* remember previous newsgroup */
X		    current_ng = ng;	/* remember current newsgroup */
X		}
X    reask_newsgroup:
X		unflush_output();	/* disable any ^O in effect */
X		fputs(promptbuf,stdout) FLUSH;/* print prompt */
X		fflush(stdout);
X    reinp_newsgroup:
X		eat_typeahead();
X		getcmd(buf);
X		if (errno || *buf == '\f') {
X		    putchar('\n') FLUSH; /* if return from stop signal */
X		    goto reask_newsgroup;	/* give them a prompt again */
X		}
X		setdef(buf,dfltcmd);
X#ifdef VERIFY
X		printcmd();
X#endif
X		switch (*buf) {
X		case 'p':		/* find previous unread newsgroup */
X		    do {
X			if (ng <= 0)
X			    break;
X			ng--;
X			if (toread[ng] == TR_NONE)
X			    set_toread(ng);
X		    } while (toread[ng] <= TR_NONE);
X		    break;
X		case 'P':		/* goto previous newsgroup */
X		    do {
X			if (ng <= 0)
X			    break;
X			ng--;
X		    } while (toread[ng] < TR_NONE);
X		    special = TRUE;	/* don't skip it if toread==0 */
X		    break;
X		case '-':
X		    ng = recent_ng;	/* recall previous newsgroup */
X		    special = TRUE;	/* don't skip it if toread==0 */
X		    break;
X		case 'q': case 'Q': case 'x':	/* quit? */
X		    oh_for_the_good_old_days = (*buf == 'x');
X		    putchar('\n') FLUSH;
X		    ng = nextrcline+1;	/* satisfy */
X		    retry = FALSE;	/*   loop conditions */
X		    break;
X		case '^':
X		    putchar('\n') FLUSH;
X		    ng = 0;
X		    break;
X		case 'n':		/* find next unread newsgroup */
X		    if (ng == nextrcline) {
X			putchar('\n') FLUSH;
X			retry = TRUE;
X		    }
X		    else if (toread[ng] > TR_NONE)
X			retry = TRUE;
X		    ng++;
X		    break;
X		case 'N':		/* goto next newsgroup */
X		    ng++;
X		    special = TRUE;	/* and don't skip it if toread==0 */
X		    break;
X		case '1':		/* goto 1st newsgroup */
X		    ng = 0;
X		    special = TRUE;	/* and don't skip it if toread==0 */
X		    break;
X		case '$':
X		    ng = nextrcline;	/* goto last newsgroup */
X		    retry = TRUE;
X		    break;
X		case 'L':
X		    list_newsgroups();
X		    goto reask_newsgroup;
X		case '/': case '?':	/* scan for newsgroup pattern */
X#ifdef NGSEARCH
X		    switch (ng_search(buf,TRUE)) {
X		    case NGS_ABORT:
X			goto reinp_newsgroup;
X		    case NGS_INTR:
X#ifdef VERBOSE
X			IF(verbose)
X			    fputs("\n(Interrupted)\n",stdout) FLUSH;
X			ELSE
X#endif
X#ifdef TERSE
X			    fputs("\n(Intr)\n",stdout) FLUSH;
X#endif
X			ng = current_ng;
X			goto reask_newsgroup;
X		    case NGS_FOUND:
X			special = TRUE;	/* don't skip it if toread==0 */
X			break;
X		    case NGS_NOTFOUND:
X#ifdef VERBOSE
X			IF(verbose)
X			    fputs("\n\nNot found--use g to add newsgroups\n",
X				stdout) FLUSH;
X			ELSE
X#endif
X#ifdef TERSE
X			    fputs("\n\nNot found\n",stdout) FLUSH;
X#endif
X			goto reask_newsgroup;
X		    }
X#else
X		    notincl("/");
X#endif
X		    break;
X		case 'm':
X#ifndef RELOCATE
X		    notincl("m");
X		    break;
X#endif		    
X		case 'g':	/* goto named newsgroup */
X		    if (!finish_command(FALSE))
X					/* if they didn't finish command */
X			goto reinp_newsgroup;	/* go try something else */
X		    for (s = buf+1; *s == ' '; s++);
X					/* skip leading spaces */
X		    if (!*s)
X			strcpy(s,ngname);
X#ifdef RELOCATE
X		    if (!get_ng(s,*buf=='m'))	/* try to find newsgroup */
X#else
X		    if (!get_ng(s,FALSE))	/* try to find newsgroup */
X#endif
X			ng = current_ng;/* if not found, go nowhere */
X		    special = TRUE;	/* don't skip it if toread==0 */
X		    break;
X#ifdef DEBUGGING
X		case 'D':
X		    printf("\nTries: %d Hits: %d\n",
X			softtries,softtries-softmisses) FLUSH;
X		    goto reask_newsgroup;
X#endif
X		case '!':		/* shell escape */
X		    if (escapade())	 /* do command */
X			goto reinp_newsgroup;
X					/* if rubbed out, re input */
X		    goto reask_newsgroup;
X		case Ctl('k'):		/* edit global KILL file */
X		    edit_kfile();
X		    goto reask_newsgroup;
X		case 'c':		/* catch up */
X#ifdef CATCHUP
Xreask_catchup:
X#ifdef VERBOSE
X		IF(verbose)
X		    in_char("\nDo you really want to mark everything as read? [yn] ", 'C');
X		ELSE
X#endif
X#ifdef TERSE
X		    in_char("\nReally? [ynh] ", 'C');
X#endif
X		    setdef(buf,"y");
X#ifdef VERIFY
X		    printcmd();
X#endif
X		    putchar('\n') FLUSH;
X		    if (*buf == 'h') {
X#ifdef VERBOSE
X		    printf("Type y or SP to mark all articles as read.\n");
X		    printf("Type n to leave articles marked as they are.\n");
X#else
X		    printf("y or SP to mark all read.\n");
X		    printf("n to forget it.\n");
X#endif
X			goto reask_catchup;
X		    }
X		    else if (*buf!=' ' && *buf!='y' && *buf!='n' && *buf!='q') {
X			printf(hforhelp);
X			settle_down();
X			goto reask_catchup;
X		    } else if ( (*buf == ' ' || *buf == 'y') && ng<nextrcline )
X			catch_up(ng);
X		    else
X			retry = TRUE;
X		    ng++;
X#else
X		    notincl("c");
X#endif
X		    break;
X		case 'u':		/* unsubscribe */
X		    if (ng < nextrcline && toread[ng] >= TR_NONE) {
X					/* unsubscribable? */
X			printf(unsubto,rcline[ng]) FLUSH;
X			rcchar[ng] = NEGCHAR;
X					/* unsubscribe to (from?) it */
X			toread[ng] = TR_UNSUB;
X					/* and make line invisible */
X			ng++;		/* do an automatic 'n' */
X		    }
X		    break;
X		case 'h': {		/* help */
X		    int cmd;
X
X		    if ((cmd = help_ng()) > 0)
X			pushchar(cmd);
X		    goto reask_newsgroup;
X		}
X		case 'a':
X#ifndef FINDNEWNG
X		    notincl("a");
X		    goto reask_newsgroup;
X#else
X		    /* FALL THROUGH */
X#endif
X		case 'o':
X#ifdef ONLY
X		{
X#ifdef FINDNEWNG
X		    bool doscan = (*buf == 'a');
X#endif
X
X		    if (!finish_command(TRUE)) /* get rest of command */
X			goto reinp_newsgroup;	/* if rubbed out, try something else */
X		    end_only();
X		    if (buf[1]) {
X			bool minusd = instr(buf+1,"-d") != Nullch;
X
X			sw_list(buf+1);
X			if (minusd)
X			    cwd_check();
X			putchar('\n') FLUSH;
X#ifdef FINDNEWNG
X			if (doscan && maxngtodo)
X			    scanactive();
X#endif
X		    }
X		    ng = 0;		/* simulate ^ */
X		    retry = FALSE;
X		    break;
X		}
X#else
X		    notincl("o");
X		    goto reask_newsgroup;
X#endif
X		case '&':
X		    if (switcheroo()) /* get rest of command */
X			goto reinp_newsgroup;	/* if rubbed out, try something else */
X		    goto reask_newsgroup;
X		case 'l': {		/* list other newsgroups */
X		    if (!finish_command(TRUE)) /* get rest of command */
X			goto reinp_newsgroup;	/* if rubbed out, try something else */
X		    for (s = buf+1; *s == ' '; s++);
X		    			/* skip leading spaces */
X		    sprintf(cmd_buf,"%s '%s'",filexp(NEWSGROUPS),s);
X		    resetty();
X		    if (doshell(sh,cmd_buf))
X#ifdef VERBOSE
X			IF(verbose)
X			    fputs("    (Error from newsgroups program)\n",
X				stdout) FLUSH;
X			ELSE
X#endif
X#ifdef TERSE
X			    fputs("(Error)\n",stdout) FLUSH;
X#endif
X		    noecho();
X		    crmode();
X		    goto reask_newsgroup;
X		}
X#ifdef USETHREADS
X		case 'U': case '+':
X#endif
X		case '.': case '=':
X		case 'y': case 'Y': /* do normal thing */
X		    if (ng >= nextrcline) {
X			fputs("\nNot on a newsgroup.",stdout) FLUSH;
X			goto reask_newsgroup;
X		    }
X#ifdef USETHREADS
X		    else if (*buf == '+' || *buf == 'U' || *buf == '=') {
X			buf[1] = '\0';
X			s = savestr(buf);
X		    }
X#else
X		    if (*buf == '=')
X			s = savestr("=");
X#endif
X		    else if (*buf == '.') {	/* start command? */
X			if (!finish_command(FALSE)) /* get rest of command */
X			    goto reinp_newsgroup;
X			s = savestr(buf+1);
X					/* do_newsgroup will free it */
X		    }
X		    else
X			s = Nullch;
X		    if (toread[ng])
X			retry = TRUE;
X		    switch (do_newsgroup(s)) {
X		    case NG_ERROR:
X		    case NG_NORM:
X			ng++;
X			break;
X		    case NG_ASK:
X			goto reprompt_newsgroup;
X		    case NG_MINUS:
X			ng = recent_ng;	/* recall previous newsgroup */
X			special = TRUE;	/* don't skip it if toread==0 */
X			break;
X		    }
X		    break;
X#ifdef STRICTCR
X		case '\n':
X		    fputs(badcr,stdout) FLUSH;
X		    goto reask_newsgroup;
X#endif
X		case 'v':
X		    printf("\n%s",rnid);
X		    printf("\n%s",patchlevel);
X		    printf("\nSend bugs to davison@borland.com\n") FLUSH;
X		    goto reask_newsgroup;
X		default:
X		    printf("\n%s",hforhelp) FLUSH;
X		    settle_down();
X		    goto reask_newsgroup;
X		}
X	    }
X	} while (retry);
X    }
X
X    /* now write .newsrc back out */
X
X    write_rc();
X
X    if (oh_for_the_good_old_days)
X	get_old_rc();
X
X    finalize(0);			/* and exit */
X}
X
X/* set current newsgroup */
X
Xvoid
Xset_ngname(what)
Xchar *what;
X{
X    int len = strlen(what)+1;
X
X    growstr(&ngname,&ngnlen,len);
X    strcpy(ngname,what);
X    growstr(&ngdir,&ngdlen,len);
X    strcpy(ngdir,getngdir(ngname));
X}
X
Xstatic char *myngdir;
Xstatic int ngdirlen = 0;
X
Xchar *
Xgetngdir(ngnam)
Xchar *ngnam;
X{
X    register char *s;
X
X    growstr(&myngdir,&ngdirlen,strlen(ngnam)+1);
X    strcpy(myngdir,ngnam);
X    for (s = myngdir; *s; s++)
X	if (*s == '.')
X	    *s = '/';
X    return myngdir;
X}
END_OF_FILE
  if test 14789 -ne `wc -c <'rn.c'`; then
    echo shar: \"'rn.c'\" unpacked with wrong size!
  fi
  # end of 'rn.c'
fi
echo shar: End of archive 9 \(of 14\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
