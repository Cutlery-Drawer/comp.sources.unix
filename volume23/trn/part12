This is a new archive version of TRN at patchlevel 3.
The original posting took up Volume23, issues 60 to 73, with
various problems.  These files replace those issues.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  MANIFEST HACKERSGUIDE Makefile.SH Rnmail.SH artsrch.c
#   final.c kfile.c rthreads.c uudecode.c
# Wrapped by rsalz@litchi.bbn.com on Fri Aug 23 16:39:02 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 12 (of 14)."'
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
  echo shar: Extracting \"'MANIFEST'\" \(5281 characters\)
  sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
XAfter unpacking, you should have the following files:
X
XFilename	Description
X--------	-----------
XConfigure       A shell script that installs everything system dependent.
XEXTERN.h        When included, makes other includes not belong to me.
XHACKERSGUIDE    A brief guide to the contorted innards of trn.
XINIT            Sample system-wide switch file.
XINTERN.h        When included, makes other includes belong to me.
XMANIFEST        This list of files.
XMakefile.SH     The makefile.
XNEW             List of new features with trn v1.0.
XPnews.1         Manual page for Pnews.
XPnews.SH        A news posting shell script that knows about -h.
XREADME          Installation instructions and other tidbits.
XRnmail.1        Manual page for Rnmail.
XRnmail.SH       A mailer that knows about -h.
XWishlist        What the next version wants in it.
Xaddng.c         Routines for scanning the active file for new newsgroups.
Xaddng.h         Public info regarding addng.c.
Xart.c           Routines to display an article.
Xart.h           Public info regarding art.c.
Xartio.c         Reserved for the article abstract type, someday.
Xartio.h         Public info regarding artio.c.
Xartsrch.c       Routines for searching among articles.
Xartsrch.h       Public info regarding artsrch.c.
Xartstate.h      Info on the current state of the article.
Xbackpage.c      Routines for paging backwards in articles.
Xbackpage.h      Public info regarding backpage.c.
Xbits.c          Bitmap management functions.
Xbits.h          Public info regarding bits.c.
Xcheat.c         Routines to do lookahead of several types.
Xcheat.h         Public info regarding cheat.c.
Xcommon.h        Global info.
Xfinal.c         Finalization (exit) routines.
Xfinal.h         Public info regarding final.c.
Xgetactive.c     Program used by shell scripts to the active file (trrn only).
Xgetdate.y       A yacc script for date parsing.
Xhead.c          Header parsing routines.
Xhead.h          Public info regarding head.c.
Xhelp.c          Help routines.
Xhelp.h          Public info regarding help.c.
Xinit.c          Initialization (startup) routines.
Xinit.h          Public info regarding init.c.
Xintrp.c         Filename expansion and % interpretation routines.
Xintrp.h         Public info regarding intrp.c.
Xkfile.c         KILL file routines.
Xkfile.h         Public info regarding kfile.c.
Xlast.c          Routines for handling the .rnlast file.
Xlast.h          Public info regarding last.c.
Xmakedepend.SH   Shell script to generate make dependencies.
Xmakedir.SH      Shell script to make nested subdirectories.
Xmbox.saver.SH   Shell script to save an article to a mailbox.
Xmt-lint.h       A kludge file included when lint'ing.
Xmt-process.c    Mthreads' article processing routines.
Xmt-read.c       Mthreads' data-file reading routines.
Xmt-write.c      Mthreads' data-file writing routines.
Xmt.check.SH     A sample mt.log checker/trimmer.
Xmthreads.1      The man page for mthreads.
Xmthreads.c      The main workloop for the mthreads database manager.
Xmthreads.h      The include file for accessing the 'mt' structures.
Xndir.c          4.2 directory routine emulation.
Xndir.h          Public info regarding ndir.c.
Xnewsetup.1      Manual page for newsetup.
Xnewsetup.SH     Shell script to create a .newsrc file.
Xnewsgroups.1    Manual page for newsgroups.
Xnewsgroups.SH   Shell script to list unsubscribed newsgroups.
Xnewsnews.SH     A motd-like file that trn may print at startup.
Xng.c            Routines to display a newsgroup.
Xng.h            Public info regarding ng.c.
Xngdata.c        General data fetching routines for a newsgroup.
Xngdata.h        Public info regarding ngdata.c.
Xngsrch.c        Routines to search among newsgroups.
Xngsrch.h        Public info regarding ngsrch.c.
Xngstuff.c       Support routines for ng.c.
Xngstuff.h       Public info regarding ng.c.
Xnorm.saver.SH   Shell script to save an article to a normal file.
Xonly.c          Routines to perform newsgroup restriction.
Xonly.h          Public info regarding only.c.
Xpatchlevel      Indicates current patch level.
Xrcln.c          Routines to mung a .newsrc line.
Xrcln.h          Public info regarding rcln.c.
Xrcstuff.c       Routines to mung the .newsrc file.
Xrcstuff.h       Public info regarding rcstuff.c.
Xrespond.c       Various routines for doing things with articles.
Xrespond.h       Public info regarding respond.c.
Xrn.c            Main program.
Xrn.h            Public info regarding rn.c.
Xrt-rn.c         Misc. threaded routines.
Xrt-select.c     The thread selector.
Xrthreads.c      Routines that read the thread data files in reader format.
Xrthreads.h      The include file for accessing the 'rt' structures.
Xsearch.c        Regular expression processing ala emacs.
Xsearch.h        Public info regarding search.c.
Xsw.c            Switch processing routines.
Xsw.h            Public info regarding switch.c.
Xterm.c          Terminal interface routines.
Xterm.h          Public info regarding term.c.
Xthreads.c       Routines common to both thread makers and readers.
Xthreads.h       The include file for common thread structures.
Xtrn.1           Manual pages for trn -- PLEASE READ.
Xutil.c          Utility routines.
Xutil.h          Public info regarding util.c.
Xuudecode.c      The uudecoder routines.
Xuudecode.h      The uudecoder's include file.
END_OF_FILE
  if test 5281 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
  fi
  # end of 'MANIFEST'
fi
if test -f 'HACKERSGUIDE' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HACKERSGUIDE'\"
else
  echo shar: Extracting \"'HACKERSGUIDE'\" \(4518 characters\)
  sed "s/^X//" >'HACKERSGUIDE' <<'END_OF_FILE'
XHacking Notes
X
XIf you aren't interested in mucking with the innards of rn, don't read this.
X
XIn the interests of both space and time optimization, things are done inside
Xrn that don't always conform to the highest ideals of programming.  To the
Xextent I felt it was practical, I've tried to conform to good programming
Xpractice, but you must realize that my goal was to make a better mousetrap,
Xso certain conscious tradeoffs were made in the design of rn right from the
Xstart.  In particular, if you want to hack on rn (and I wouldn't blame you,
Xit's fun), beware of the following:
X  
X  * buf and cmd_buf are reused all over the place.  11-squishing is a good
X    term for it.  No, I'm on a Vax now, but I've been there.
X
X  * The article header is parsed on the fly, while it is being displayed.
X    In fact, practically everything is done on the fly within the article
X    display loop, and there are plenty of state variables.  The header
X    is never explicitly stored in memory; rather, pointers are kept into
X    the file.  The information required to backup pages is not stored in
X    memory, except for 1 buffer's worth.  The information required to do
X    the delayed mark as unread (M) is not stored in memory either.
X
X  * Lots of contortions are gone through to avoid using static memory, or
X    allocating unnecessary memory, or losing track of allocated memory,
X    while at the same time allowing .newsrc lines and header lines to be
X    ANY length up to the amount of memory you have.  Rn spends a great deal
X    of effort being lazy.  Do not use a static buffer when you can use
X    growstr().
X
X  * Lots of contortions are gone through to try to do things when people
X    aren't waiting, or have only been waiting a very short time.  Guessing
X    the next article to be opened and opening it, searching ahead for the
X    next article with the same subject, delaying the look up of the number
X    of articles in a newsgroup, writing the rest of the page while the
X    reader is examining the header, cacheing up subjects while the user
X    is reading, checkpointing the .newsrc only while the reader is in the
X    middle of an interesting article, are some of the strategies employed.
X  
X  * There are plenty of goto's.  Most of them involve going back to reprompt,
X    to reask for input, or to just plain do the unstructured things people
X    want to do when they are glaring at a terminal.  If they bother you
X    too much, just think of rn as a big state machine.  If they don't bother
X    you at all, I don't want you hacking on rn.
X
X  * Put all includes at the front of the file, before the first function,
X    or makedepend will not work right.  I could relax this, but makedepend
X    would take about 5 times longer to run.
X
XIn general then, feel free to hack on rn.  Just don't broadcast untested
Xpatches to the net.  Remember that there are people with limited address
Xspaces and limited cpu cycles.  If you add a wonderful new feature and
Xwant to publish a patch, put #ifdef's around it so that people who don't
Xwant it or can't afford it can work around it.  THIS MEANS YOU.  We don't
Xneed 57 varieties of mutually incompatible and incomprehensible rn floating
Xabout the net.  Consider telling me about your patch so that I can consider
Xincluding it in the standard version.  A COMPLETE PATCH TAKES INTO ACCOUNT
XSYSTEM DEPENDENCIES AS DETERMINED BY THE CONFIGURE SCRIPT.
X
X* Don't use ints where rn uses typedefs, in particular, for article numbers.
X* Don't use %d anywhere that someone might need a %ld.  (Just because YOU
X    typedefed it as an int doesn't mean someone else won't need a long.)
X* Don't use %D, that's archaic.
X* Put FLUSHes after printf()s, fputs()es and putchar('\n')s for our poor
X    brethern and sistern without line buffering.
X* Declare the type of every function.  Use void, even if your C compiler
X    doesn't.
X* Follow the style that rn already uses!  This is my pet peeve.  Well, one of
X    them, anyway.  I follow other people's strange styles when modifying
X    their programs, so I'd be much obliged if you did likewise.
X* Use lint.
X* Use RCS.  Start a new branch, like 4.3.[2-9].  (I will use 4.3.1 myself.)
X* Be structured wherever it doesn't interfere with practicality.
X* Long live paranoid programming.  The rest of the program is out to get you.
X    The world is out to destroy the program, not to mention the .newsrc.
X    And then there's always bitrot...
X* Stop reading this lugubrious trash and start thinking for yourself.
X* Thank you and good night.
END_OF_FILE
  if test 4518 -ne `wc -c <'HACKERSGUIDE'`; then
    echo shar: \"'HACKERSGUIDE'\" unpacked with wrong size!
  fi
  # end of 'HACKERSGUIDE'
fi
if test -f 'Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.SH'\"
else
  echo shar: Extracting \"'Makefile.SH'\" \(6240 characters\)
  sed "s/^X//" >'Makefile.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting Makefile (with variable substitutions)"
Xcat >Makefile <<!GROK!THIS!
X# $Header: makefile.SH,v 4.3.3.2 91/01/16 02:48:10 davison Trn $
X#
X# $Log:	makefile.SH,v $
X# Revision 4.3.3.2  91/01/16  02:48:10  davison
X# Integrated rn patches 48-54.
X# 
X# Revision 4.3.3.1  90/07/28  18:14:56  davison
X# Initial Trn Release
X# 
X# Revision 4.3.2.11  90/11/22  13:57:53  sob
X# Added support for additional CFLAGS and better cleanup.
X# 
X# Revision 4.3.2.10  90/05/04  00:44:51  sob
X# Added socketlib to list of libs.
X# 
X# Revision 4.3.2.9  90/04/23  00:27:12  sob
X# Added better support for XENIX
X# 
X# Revision 4.3.2.8  89/12/20  23:20:14  sob
X# Added "hp-ux" to the list of files created by Configure.
X# 
X# Revision 4.3.2.7  89/12/09  01:49:48  sob
X# make clean cleans up better.
X# 
X# Revision 4.3.2.6  89/12/08  22:43:45  sob
X# Added suggestions by weening@gang-of-four.stanford.edu and 
X# jik@pit-manager.mit.edu. rrn manual page is now created when
X# doing an installation. getactive will only be made when rrn is being
X# created.
X# 
X# Revision 4.3.2.5  89/11/08  04:47:38  sob
X# Added VOIDSIG handling for SunOS 4.X
X# 
X# Revision 4.3.2.4  89/11/08  03:16:29  sob
X# Added server.h to list of things created by Configure
X# 
X# Revision 4.3.2.3  89/11/08  01:05:52  sob
X# Updated to work with RRN or RN
X# 
X# Revision 4.3.2.2  89/11/06  00:03:19  sob
X# Added RRN support originally distributed with NNTP 1.5
X# 
X# Revision 4.3.2.1  89/11/05  23:55:09  sob
X# RRN support branch
X#
X# Revision 4.3.1.2  85/05/13  17:21:18  lwall
X# System V make needs space before line-continuing backslash.
X# 
X# Revision 4.3.1.1  85/05/10  11:30:15  lwall
X# Branch for patches.
X# 
X# Revision 4.3  85/05/01  11:33:26  lwall
X# Baseline for release with 4.3bsd.
X# 
X
XCC = $cc
Xrnbin = $rnbin
Xrnlib = $rnlib
Xmansrc = $mansrc
Xmanext = $manext
X#NNTPNNTPDIR = $NNTPSRC
X#NNTPNNTPINC = $rrninclude
XCFLAGS = $iandd $addcflags -O $include
XLDFLAGS = $iandd
XNDIRC = $ndirc
XNDIRO = $ndiro
X
Xlibs = $ndirlib $termlib $jobslib $socketlib
Xmlibs = $jobslib
X!GROK!THIS!
Xcat >>Makefile <<'!NO!SUBS!'
X#NNTPnntp=getactive
Xpublic = trn newsetup newsgroups Pnews Rnmail
Xprivate = norm.saver mbox.saver makedir\
X	filexp Pnews.header mthreads mt.check $(nntp)
Xmanpages = trn.1 Pnews.1 Rnmail.1 newsetup.1 newsgroups.1 mthreads.1
Xutil = Makefile makedepend newsnews
X
X
Xh1 = addng.h art.h artio.h artsrch.h backpage.h bits.h cheat.h common.h
Xh2 = final.h head.h help.h init.h intrp.h kfile.h last.h ndir.h ng.h
Xh3 = ngdata.h ngsrch.h ngstuff.h only.h rcln.h rcstuff.h
Xh4 = respond.h rn.h search.h sw.h term.h util.h uudecode.h
X#NNTPh5 = server.h
X
Xh = $(h1) $(h2) $(h3) $(h4) $(h5)
X
Xc1 = addng.c art.c artio.c artsrch.c backpage.c bits.c cheat.c
Xc2 = final.c head.c help.c init.c intrp.c kfile.c last.c $(NDIRC) ng.c
Xc3 = ngdata.c ngsrch.c ngstuff.c only.c rcln.c rcstuff.c respond.c rn.c
Xc4 = rthreads.c rt-rn.c rt-select.c search.c sw.c term.c threads.c util.c
Xc5 = uudecode.c
X#NNTPc6 = $(NNTPDIR)/common/clientlib.c
X
Xc = $(c1) $(c2) $(c3) $(c4) $(c5) $(c6)
Xmtc = mthreads.c mt-read.c mt-process.c mt-write.c threads.c $(c6)
X
Xobj1 = addng.o art.o artio.o artsrch.o backpage.o bits.o cheat.o
Xobj2 = final.o head.o help.o init.o intrp.o kfile.o last.o $(NDIRO) ng.o
Xobj3 = ngdata.o ngsrch.o ngstuff.o only.o rcln.o rcstuff.o respond.o rn.o
Xobj4 = rthreads.o rt-rn.o rt-select.o search.o sw.o term.o threads.o util.o
Xobj5 = uudecode.o
X#NNTPobj6 =  $(NNTPDIR)/common/clientlib.o
X
Xobj = $(obj1) $(obj2) $(obj3) $(obj4) $(obj5) $(obj6)
Xmtobj = mthreads.o mt-read.o mt-process.o mt-write.o threads.o getdate.o $(obj6)
X
Xlintflags = -phbvxac
X
Xadd1 = Makefile.old Pnews Rnmail
Xadd2 = bsd config.h config.sh eunice filexp
Xadd3 = loc makedepend makedir mbox.saver newsetup
Xadd4 = newsgroups newsnews norm.saver
Xadd5 = pdp11 usg v7 ultrix sun hp-ux sgi xenix server.h
Xadd6 = all pyr grimble .falseactive Pnews.header s5uniq
X
Xaddedbyconf = $(add1) $(add2) $(add3) $(add4) $(add5) $(add6)
X
X# grrr
XSHELL = /bin/sh
X
X.c.o:
X	$(CC) -c $(CFLAGS) $*.c
X
Xall: $(public) $(private) $(util)
X	touch all
X
Xtrn: $(obj)
X	$(CC) $(LDFLAGS) $(obj) $(libs) -o trn
X
Xmthreads: $(mtobj)
X	$(CC) $(LDFLAGS) $(mtobj) $(mlibs) -o mthreads
X
X#NNTPgetactive: getactive.o $(NNTPDIR)/common/clientlib.o
X#NNTP	$(CC) $(LDFLAGS) getactive.o $(NNTPDIR)/common/clientlib.o -o getactive $(libs)
X
X# Eek! This is gross.
X$(NNTPDIR)/common/clientlib.o:
X	$(CC) -c $(CFLAGS) $(NNTPINC) $(NNTPDIR)/common/clientlib.c
X	mv clientlib.o $(NNTPDIR)/common/clientlib.o
X
X# if a .h file depends on another .h file...
X$(h):
X	touch $@
X
Xinstall: $(public) $(private) $(manpages)
X# won't work with csh
X	export PATH || exit 1
X	- mv $(rnbin)/trn $(rnbin)/trn.old
X#NNTP	- ln -s trn $(rnbin)/trrn
X	- if test `pwd` != $(rnbin); then cp $(public) $(rnbin); fi
X	cd $(rnbin); chmod 755 $(public); strip trn
X	chmod 755 makedir
X	- ./makedir `./filexp $(rnlib)`
X	- mv $(rnlib)/mthreads $(rnlib)/mthreads.old
X	- if test `pwd` != `./filexp $(rnlib)`; then cp INIT $(private) `./filexp $(rnlib)`; fi
X	- if test ! -f `./filexp $(rnlib)/newsnews`; then cp newsnews `./filexp $(rnlib)`; fi
X	cd `./filexp $(rnlib)`; chmod 755 $(private); chmod 644 INIT newsnews; strip mthreads
X	- if test `pwd` != $(mansrc); then \
Xfor page in $(manpages); do \
Xcp $$page $(mansrc)/`basename $$page .1`.$(manext); \
Xdone; \
X#NNTPecho ".so man$(manext)/trn.$(manext)" > $(mansrc)/trrn.$(manext) ; \
Xfi
X
Xclean:
X	rm -f *.o
X
Xrealclean:
X	rm -f trn mthreads *.o core $(addedbyconf) 
X#NNTP	rm -f $(NNTPDIR)/common/clientlib.o getactive
X
X# The following lint has practically everything turned on.  Unfortunately,
X# you have to wade through a lot of mumbo jumbo that can't be suppressed.
X# If the source file has a /*NOSTRICT*/ somewhere, ignore the lint message
X# for that spot.
X
Xlint: lint_trn lint_mt
X
Xlint_trn:
X	lint $(lintflags) $(defs) $(c) > trn.fuzz
X
Xlint_mt:
X	lint $(lintflags) $(mtc) > mt.fuzz
X
Xdepend:
X	./makedepend
X
X# AUTOMATICALLY GENERATED MAKE DEPENDENCIES--PUT NOTHING BELOW THIS LINE
X$(obj):
X	@ echo "You haven't done a "'"make depend" yet!'; exit 1
X!NO!SUBS!
Xcase "$isrrn" in
Xdefine)  sed < Makefile -e '/^#NNTP/s/^#NNTP//' > Makefile.new ;;
X*) sed < Makefile -e '/^#NNTP/d' > Makefile.new ;;
Xesac
Xmv Makefile.new Makefile
X$eunicefix Makefile
END_OF_FILE
  if test 6240 -ne `wc -c <'Makefile.SH'`; then
    echo shar: \"'Makefile.SH'\" unpacked with wrong size!
  fi
  chmod +x 'Makefile.SH'
  # end of 'Makefile.SH'
fi
if test -f 'Rnmail.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Rnmail.SH'\"
else
  echo shar: Extracting \"'Rnmail.SH'\" \(6853 characters\)
  sed "s/^X//" >'Rnmail.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting Rnmail (with variable substitutions)"
X$spitshell >Rnmail <<!GROK!THIS!
X$startsh
X# $Header: Rnmail.SH,v 4.3.3.3 91/01/16 03:28:46 davison Trn $
X# 
X# $Log:	Rnmail.SH,v $
X# Revision 4.3.3.3  91/01/16  03:28:46  davison
X# Integrated rn patches 48-54.
X# 
X# Revision 4.3.3.2  90/08/20  16:22:29  davison
X# Use mbox.saver for MAILRECORD.  Fixed sitename handling.
X# 
X# Revision 4.3.3.1  90/07/24  22:02:49  davison
X# Initial Trn Release
X# 
X# Revision 4.3.2.3  90/12/30  03:48:04  sob
X# Changed "hidden" to "hiddennet" to be like nntp and bnews.
X# Made it possible to cancel articles if hiddennet is defined.
X# 
X# Revision 4.3.2.2  90/11/22  14:00:21  sob
X# Support added for hiding all hosts within a domain such that mail appears
X# to come for user@domainname only.
X# 
X# Revision 4.3.2.1  89/11/06  00:30:54  sob
X# Added RRN support from NNTP 1.5
X# 
X# Revision 4.3.1.4  85/08/01  14:23:05  lwall
X# Added MAILRECORD.  Temp file is no longer in /tmp.  'e editor' added.
X# 
X# Revision 4.3.1.3  85/05/20  16:25:17  lwall
X# Shouldn't ask editor if EDITOR or VISUAL defined.
X# 
X# Revision 4.3.1.2  85/05/17  10:36:19  lwall
X# Added "-- " before .signature.
X# 
X# Revision 4.3.1.1  85/05/10  11:30:38  lwall
X# Branch for patches.
X# 
X# Revision 4.3  85/05/01  11:34:18  lwall
X# Baseline for release with 4.3bsd.
X# 
X#
X# syntax: Rnmail -h headerfile [oldart]		or
X#         Rnmail destination-list 		or just
X#         Rnmail
X
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
X# System dependencies
X
Xmailer="${mailer-/bin/mail}"
X# if you change this to something that does signatures, take out signature code
X
X# your site name
Xcase $portable in
Xdefine)
X	case "$hostcmd" in
X	'') sitename="$sitename" ;;
X	*)  sitename=\`$hostcmd\` ;;
X	esac
X	case \$sitename in
X		*.*)
X			;;
X		*)
X			sitename=\${sitename}.$domain
X			;;
X	esac
X	;;
Xundef) sitename="$sitename" ;;
Xesac
X
Xcase $hiddennet in
Xdefine)	sitename="$domain"
X	;;
X*)
X	;;
Xesac
X
X# your organization name
Xorgname="$orgname"
X# what pager you use--if you have kernal paging use cat
Xpager="\${PAGER-$pager}"
X# how you derive full names, bsd, usg, or other
Xnametype="$nametype"
X# default editor
Xdefeditor="$defeditor"
X# where the non-publics are
Xrnlib=$rnlib
X# how not to do a newline with echo
Xn="$n"
Xc="$c"
X
Xtest=${test-test}
Xsed=${sed-sed}
Xecho=${echo-echo}
Xcat=${cat-cat}
Xgrep=${grep-grep}
Xrm=${rm-rm}
X
X!GROK!THIS!
X$spitshell >>Rnmail <<'!NO!SUBS!'
Xdotdir=${DOTDIR-${HOME-$LOGDIR}}
Xtmpart=$dotdir/.letter
X
Xheaderfile=""
Xcase $# in
X0) ;;
X*)  case $1 in
X    -h)
X	headerfile="$2"
X	case $# in
X	3) oldart=$3 ;;
X	esac
X	;;
X    esac
X    ;;
Xesac
X
Xcase $headerfile in
X'')
X    case $# in
X    0)
X	to=h
X	while $test "$to" = h ; do
X	    $echo ""
X	    $echo $n "To: $c"
X	    read to
X	    case $to in
X	    h)
X		$cat <<'EOH'
X
XType the net address of those people that you wish the message sent to.
XAdditional recipients may be added on the Cc: line when you edit.
X
XSeparate multiple addresses with spaces.
X
XEOH
X		;;
X	    esac
X	done
X	;;
X    *)
X	to="$*"
X	;;
X    esac
X    to=`$echo "$to" | $sed 's/  */ /g'`
X
X    title=h
X    while $test "$title" = h ; do
X	$echo ""
X	$echo $n "Title/Subject: $c"
X	read title
X	case $title in
X	h)
X	    $cat <<'EOH'
X
XType the title for your message.  
XEOH
X	    ;;
X	esac
X    done
X
X# now build a file with a header for them to edit
X    
X    orgname=${ORGANIZATION-$orgname}
X    case $orgname in
X    /*) orgname=`$cat $orgname` ;;
X    esac
X
X    $sed -e '/^Reply-To: $/d' > $tmpart <<EOHeader
XTo: $to
XSubject: $title
XOrganization: $orgname
XReply-To: $REPLYTO
XCc:
XBcc:
X
XEOHeader
X
X    ;;
X*)
X    $cat < $headerfile  > $tmpart
X    ;;
Xesac
X
X
Xfile=h
Xwhile $test "$file" = h ; do
X    $echo ""
X    $echo $n "Prepared file to include [none]: $c"
X    read file
X    case $file in
X    h)
X	$cat <<'EOH'
X
XIf you have already produced the body of your message, type the filename
Xfor it here.  If you just want to proceed directly to the editor, type a
XRETURN.  In any event, you will be allowed to edit as many times as you
Xwant before you send off the message.
XEOH
X	;;
X    '')
X	$echo "" >> $tmpart
X	state=edit
X	;;
X    *)
X	$cat $file >>$tmpart
X	state=ask
X	;;
X    esac
Xdone
X
X$echo ""
X
Xwhile true ; do
X    case $state in
X    edit)
X	rescue="sleep 1; $cat $tmpart >>${HOME-$LOGDIR}/dead.letter ; $echo Message appended to ${HOME-$LOGDIR}/dead.letter ; exit"
X	trap "$rescue" 1
X	trap : 2
X	case "${VISUAL-${EDITOR-}}" in
X	'')
X	    tmp=h
X	    ;;
X	*)
X	    tmp=''
X	    ;;
X	esac
X	while $test "$tmp" = h ; do
X	    $echo $n "Editor [${VISUAL-${EDITOR-$defeditor}}]: $c"
X	    read tmp
X	    case $tmp in
X	    h)
X		$cat <<'EOH'
X
XType a return to get the default editor, or type the name of the editor you
Xprefer.  The default editor depends on the VISUAL and EDITOR environment
Xvariables.
X
XEOH
X		;;
X	    '')
X		;;
X	    *)
X		VISUAL=$tmp
X		export VISUAL
X		;;
X	    esac
X	done
X	${VISUAL-${EDITOR-$defeditor}} $tmpart $oldart
X	trap "$rescue" 2
X	state=ask
X	;;
X	
X    ask)
X	$echo ""
X	$echo $n "Send, abort, edit, or list? $c"
X	read ans
X	
X	case $ans in
X	a*)
X	    state=rescue
X	    ;;
X	e*)
X	    set $ans
X	    case $# in
X	    2)  VISUAL="$2" ;;
X	    esac
X	    state=edit
X	    ;;
X	l*)
X	    $pager $tmpart
X	    state=ask
X	    ;;
X	s*)
X	    state=send
X	    ;;
X	h*)
X	    $cat <<'EOH'
X
XType s to send the message, a to abort and append the message to dead.letter,
Xe to edit the message again, or l to list the message.
X
XTo invoke an alternate editor, type 'e editor'.
XEOH
X	esac
X	;;
X    
X    send)
X	if $test -f $dotdir/.signature; then
X	    $echo $n "Append .signature file? [y] $c"
X	    read ans
X	    case $ans in
X	    ''|y*)
X		$echo "-- " >> $tmpart
X		cat $dotdir/.signature >> $tmpart
X		;;
X	    esac
X	fi
X	case $mailer in
X	*sendmail)
X	    $mailer -t <$tmpart
X	    ;;
X# but recmail does not know about Bcc, alas
X	*recmail)
X	    $mailer <$tmpart
X	    ;;
X	*)
X	    set X `$sed <$tmpart -n -e '/^To:/{' -e 's/To: *//p' -e q -e '}'`
X	    shift
X	    set X "$@" `$sed <$tmpart -n -e '/^Cc:/{' -e 's/Cc: *//p' -e q -e '}'`
X	    shift
X	    set X "$@" `$sed <$tmpart -n -e '/^Bcc:/{' -e 's/Bcc: *//p' -e q -e '}'`
X	    shift
X	    $grep -v "^Bcc:"  <$tmpart | $mailer "$@"
X	    ;;
X	esac
X	case $? in
X	0)
X	    state=cleanup
X	    ;;
X	*)
X	    state=rescue
X	    ;;
X	esac
X	;;
X    rescue)
X	$cat $tmpart >> ${HOME-$LOGDIR}/dead.letter
X	$echo "Message appended to ${HOME-$LOGDIR}/dead.letter"
X	$echo "A copy may be temporarily found in $tmpart"
X	exit
X	;;
X    cleanup)
X	case "${MAILRECORD-none}" in
X	none)
X	    ;;
X	*)
X	    set X ${USER-${LOGNAME-`who am i`}} unknown
X	    shift
X	    $rnlib/mbox.saver $tmpart "." "." 0 0 Pnews $MAILRECORD "From $1 `date`"
X	    if $test $? -eq 0 ; then
X		$echo "Message appended to $MAILRECORD"
X	    else
X		$echo "Cannot append to $MAILRECORD"
X	    fi
X	    ;;
X	esac
X	exit
X	;;
X    esac
Xdone
X!NO!SUBS!
X$eunicefix Rnmail
Xchmod 755 Rnmail
END_OF_FILE
  if test 6853 -ne `wc -c <'Rnmail.SH'`; then
    echo shar: \"'Rnmail.SH'\" unpacked with wrong size!
  fi
  chmod +x 'Rnmail.SH'
  # end of 'Rnmail.SH'
fi
if test -f 'artsrch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'artsrch.c'\"
else
  echo shar: Extracting \"'artsrch.c'\" \(8042 characters\)
  sed "s/^X//" >'artsrch.c' <<'END_OF_FILE'
X/* $Header: artsrch.c,v 4.3.3.1 90/07/21 20:13:13 davison Trn $
X *
X * $Log:	artsrch.c,v $
X * Revision 4.3.3.1  90/07/21  20:13:13  davison
X * Initial Trn Release
X * 
X * Revision 4.3.2.4  89/11/27  01:30:00  sob
X * Altered NNTP code per ideas suggested by Bela Lubkin
X * <filbo@gorn.santa-cruz.ca.us>
X * 
X * Revision 4.3.2.3  89/11/26  22:54:37  sob
X * Added new patches to make rrn faster.
X * 
X * Revision 4.3.2.2  89/11/26  22:20:57  sob
X * Added better NNTP support.
X * 
X * Revision 4.3.2.1  89/11/26  22:13:10  sob
X * Added support for NNTP
X * 
X * Revision 4.3  85/05/01  11:35:47  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "search.h"
X#include "term.h"
X#include "util.h"
X#include "intrp.h"
X#include "bits.h"
X#include "kfile.h"
X#include "head.h"
X#include "final.h"
X#include "cheat.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X#include "ng.h"
X#include "artio.h"
X#ifdef USETHREADS
X#include "rthreads.h"
X#include "ngdata.h"
X#endif
X#include "INTERN.h"
X#include "artsrch.h"
X
Xvoid
Xartsrch_init()
X{
X#ifdef ARTSEARCH
X#ifdef ZEROGLOB
X    init_compex(&sub_compex);
X    init_compex(&art_compex);
X#endif
X#endif
X}
X
X/* search for an article containing some pattern */
X
X#ifdef ARTSEARCH
Xint
Xart_search(patbuf,patbufsiz,get_cmd)
Xchar *patbuf;				/* if patbuf != buf, get_cmd must */
Xint patbufsiz;
Xint get_cmd;				/*   be set to FALSE!!! */
X{
X    char *pattern;			/* unparsed pattern */
X    register char cmdchr = *patbuf;	/* what kind of search? */
X    register char *s;
X    bool backward = cmdchr == '?' || cmdchr == Ctl('p');
X					/* direction of search */
X    COMPEX *compex;			/* which compiled expression */
X    char *cmdlst = Nullch;		/* list of commands to do */
X    int normal_return = SRCH_NOTFOUND;	/* assume no commands */
X    bool saltaway = FALSE;		/* store in KILL file? */
X    char howmuch;			/* search just the subjects */
X    bool doread;			/* search read articles? */
X    bool foldcase = TRUE;		/* fold upper and lower case? */
X
X    int_count = 0;
X    if (cmdchr == '/' || cmdchr == '?') {	/* normal search? */
X	if (get_cmd && buf == patbuf)
X	    if (!finish_command(FALSE))	/* get rest of command */
X		return SRCH_ABORT;
X	compex = &art_compex;
X	if (patbuf[1]) {
X	    howmuch = 0;
X	    doread = FALSE;
X	}
X	else {
X	    howmuch = art_howmuch;
X	    doread = art_doread;
X	}
X	s = cpytill(buf,patbuf+1,cmdchr);/* ok to cpy buf+1 to buf */
X	pattern = buf;
X	if (*pattern) {
X	    if (*lastpat)
X		free(lastpat);
X	    lastpat = savestr(pattern);
X	}
X	if (*s) {			/* modifiers or commands? */
X	    for (s++; *s && index("Kharc",*s); s++) {
X		if (*s == 'h')		/* scan header */
X		    howmuch = 1;
X		else if (*s == 'a')	/* scan article */
X		    howmuch = 2;
X		else if (*s == 'r')	/* scan read articles */
X		    doread = TRUE;
X		else if (*s == 'K')	/* put into KILL file */
X		    saltaway = TRUE;
X		else if (*s == 'c')	/* make search case sensitive */
X		    foldcase = FALSE;
X	    }
X	}
X	while (isspace(*s) || *s == ':')
X	    s++;
X	if (*s) {
X	    if (*s == 'm' || *s == 'M')
X		doread = TRUE;
X	    if (*s == 'k')		/* grandfather clause */
X		*s = 'j';
X	    cmdlst = savestr(s);
X	    normal_return = SRCH_DONE;
X	}
X	art_howmuch = howmuch;
X	art_doread = doread;
X	if (srchahead)
X	    srchahead = -1;
X    }
X    else {
X	register char *h;
X
X	howmuch = 0;			/* just search subjects */
X	doread = (cmdchr == Ctl('p'));
X	if (cmdchr == Ctl('n'))
X	    normal_return = SRCH_SUBJDONE;
X	compex = &sub_compex;
X	pattern = patbuf+1;
X	strcpy(pattern,": *");
X	h = pattern + strlen(pattern);
X	interp(h,patbufsiz - (h-patbuf),"%s");	/* fetch current subject */
X	if (cmdchr == 'K') {
X	    saltaway = TRUE;
X	    cmdchr = 'k';
X	}
X	if (cmdchr == 'k') {
X	    normal_return = SRCH_DONE;
X	    cmdlst = savestr("j");
X	    mark_as_read();		/* this article has this subject */
X	    if (!*h) {
X#ifdef VERBOSE
X		IF(verbose)
X		    fputs("\nCannot delete null subject.\n",stdout) FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    fputs("\nNull subject.\n",stdout) FLUSH;
X#endif
X		return SRCH_ABORT;
X	    }
X#ifdef VERBOSE
X	    else if (verbose)
X		printf("\nMarking subject \"%s\" as read.\n",h) FLUSH;
X#endif
X	}
X	else if (!srchahead)
X	    srchahead = -1;
X	h[24] = '\0';		/* compensate for notesfiles */
X	while (*h) {
X	    if (index("/\\[.^*$'\"",*h) != Nullch)
X		*h++ = '.';
X	    else
X		h++;
X	}
X#ifdef DEBUGGING
X	if (debug) {
X	    printf("\npattern = %s\n",pattern) FLUSH;
X	}
X#endif
X    }
X    if ((s = compile(compex,pattern,TRUE,foldcase)) != Nullch) {
X					/* compile regular expression */
X	printf("\n%s\n",s) FLUSH;
X	return SRCH_ABORT;
X    }
X#ifdef KILLFILES
X    if (saltaway) {
X	char saltbuf[LBUFLEN];
X
X	s = saltbuf;
X	sprintf(s,"/%s/",pattern);
X	s += strlen(s);
X	if (doread)
X	    *s++ = 'r';
X	if (howmuch==1)
X	    *s++ = 'h';
X	else if (howmuch==2)
X	    *s++ = 'a';
X	*s++ = ':';
X	if (!cmdlst)
X	    cmdlst = savestr("j");
X	safecpy(s,cmdlst,LBUFLEN-(s-saltbuf));
X	kf_append(saltbuf);
X    }
X#endif
X    if (cmdlst && index(cmdlst,'='))
X	normal_return = SRCH_ERROR;	/* listing subjects is an error? */
X    if (get_cmd) {
X	fputs("\nSearching...\n",stdout) FLUSH;
X					/* give them something to read */
X    }
X#ifdef USETHREADS
X    if (mode == 't') {
X	if (!cmdlst)
X	    cmdlst = savestr("+");	/* thread selector's default command */
X	if (unread_selector)
X	    doread = TRUE;
X	normal_return = SRCH_DONE;
X    }
X#endif
X    if (backward) {
X	if (cmdlst && art <= lastart)
X	    art++;			/* include current article */
X	if (doread)
X	    check_first(absfirst);
X    }
X    else {
X	if (art > lastart) {
X	    art = (doread ? absfirst : firstart);
X	    check_first(art--);
X	}
X	else if (cmdlst && art >= absfirst)
X	    art--;			/* include current article */
X    }
X    if (srchahead > 0) {
X	if (!backward)
X	    art = srchahead - 1;
X	srchahead = -1;
X    }
X    assert(!cmdlst || *cmdlst);
X    perform_cnt = 0;
X    for (;;) {
X	if (backward ?
X		(--art < absfirst || (!doread && art < firstart)) :
X		(++art > lastart)
X	  ) {			/* out of articles? */
X	    if (cmdlst)
X		free(cmdlst);
X	    return normal_return;
X	}
X	if (int_count) {
X	    int_count = 0;
X	    if (cmdlst)
X		free(cmdlst);
X	    return SRCH_INTR;
X	}
X	/*NOSTRICT*/
X	if (doread || !was_read(art)) {
X	    if (wanted(compex,art,howmuch)) {
X				    /* does the shoe fit? */
X		if (cmdlst) {
X		    if (perform(cmdlst,TRUE)) {
X			if (cmdlst)
X			    free(cmdlst);
X			return SRCH_INTR;
X		    }
X		}
X		else {
X		    if (cmdlst)
X			free(cmdlst);
X		    return SRCH_FOUND;
X		}
X	    }
X	    else if (!cmdlst && ! (art%50)) {
X		printf("...%ld",(long)art);
X		fflush(stdout);
X	    }
X	}
X    }
X}
X
X/* determine if article fits pattern */
X/* returns TRUE if it exists and fits pattern, FALSE otherwise */
X
Xbool
Xwanted(compex, artnum, scope)
XCOMPEX *compex;
XART_NUM artnum;
Xchar scope;
X{
X    if (!scope) {
X	char subj_buf[266];
X	
X#ifdef USETHREADS
X	if (ThreadedGroup)
X	    find_article(art);
X	if (p_art) {
X	    if (mode != 't')
X		strcpy(subj_buf, "Subject: ");
X	    else
X		*subj_buf = '\0';
X	    if (p_art->subject != -1)
X		strcat(subj_buf,subject_ptrs[p_art->subject]);
X	}
X	else
X#endif
X	{
X	    strcpy(subj_buf, "Subject: ");
X	    strncpy(subj_buf+9,fetchsubj(artnum,FALSE,FALSE),256);
X	}
X#ifdef DEBUGGING
X	if (debug & DEB_SEARCH_AHEAD)
X	    printf("%s\n",subj_buf) FLUSH;
X#endif
X	return execute(compex,subj_buf) != Nullch;
X    }
X#ifdef CACHESUBJ
X    else
X	fetchsubj(artnum,FALSE,FALSE);/* might as well get subject handy */
X#endif
X    
X#ifdef SERVER
X    if (scope == 1){
X	if (nntpopen(artnum,GET_HEADER) == Nullfp) /* we only need the header */
X	    return FALSE;
X    }
X    else
X#endif
X    if (artopen(artnum) == Nullfp)	/* ensure that article is open */
X
X	return FALSE;			/* if not, return NO MATCH */
X    scope--;
X    while (fgets(buf,LBUFLEN,artfp) != Nullch) {
X					/* for each line of article */
X	if (!scope && index(buf,':') == Nullch && *buf != ' ' && *buf != '\t')
X					/* if headers only and out of header */
X	    return FALSE;		/* say no go */
X	if (execute(compex,buf) != Nullch) {
X					/* does pattern matcher match? */
X	    return TRUE;		/* say Eureka */
X	}
X    }
X    return FALSE;			/* out of article, so no match */
X}
X#endif
X
END_OF_FILE
  if test 8042 -ne `wc -c <'artsrch.c'`; then
    echo shar: \"'artsrch.c'\" unpacked with wrong size!
  fi
  # end of 'artsrch.c'
fi
if test -f 'final.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'final.c'\"
else
  echo shar: Extracting \"'final.c'\" \(5537 characters\)
  sed "s/^X//" >'final.c' <<'END_OF_FILE'
X/* $Header: final.c,v 4.3.3.2 91/01/16 02:38:15 davison Trn $
X *
X * $Log:	final.c,v $
X * Revision 4.3.3.2  91/01/16  02:38:15  davison
X * Integrated rn patches 48-54.
X * 
X * Revision 4.3.3.1  90/06/20  22:36:57  davison
X * Initial Trn Release
X * 
X * Revision 4.3.2.9  90/11/22  16:08:34  sob
X * Added changes to accomodate pick C preprocessors.
X * 
X * Revision 4.3.2.8  90/04/14  19:37:14  sob
X * Added better support for the NeXT.
X * 
X * Revision 4.3.2.7  90/03/17  21:33:49  sob
X * cleaned up a bit
X * 
X * Revision 4.3.2.6  90/03/17  16:48:25  sob
X * Added changes to insure that rrn cleans up its temporary files when
X * exiting.
X * 
X * Revision 4.3.2.5  89/11/28  01:51:28  sob
X * Now handles SIGWINCH correctly.
X * 
X * Revision 4.3.2.4  89/11/27  01:30:24  sob
X * Altered NNTP code per ideas suggested by Bela Lubkin
X * <filbo@gorn.santa-cruz.ca.us>
X * 
X * Revision 4.3.2.3  89/11/08  02:25:07  sob
X * Integrated modifications from other RRN patches colleceted from USENET
X * 
X * Revision 4.3.2.2  89/11/07  23:26:31  sob
X * Added some fixes that relate to SIGSTP
X * 
X * Revision 4.3.2.1  89/11/06  00:16:08  sob
X * Added RRN support from NNTP 1.5
X *
X * Revision 4.3  85/05/01  11:38:08  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "term.h"
X#include "ng.h"
X#include "init.h"
X#include "bits.h"
X#include "last.h"
X#include "rcstuff.h"
X#include "ngdata.h"
X#include "artio.h"
X#include "INTERN.h"
X#include "final.h"
X
Xvoid
Xfinal_init()
X{
X#ifdef SIGTSTP
X    sigset(SIGTSTP, stop_catcher);	/* job control signals */
X    sigset(SIGTTOU, stop_catcher);	/* job control signals */
X    sigset(SIGTTIN, stop_catcher);	/* job control signals */
X#endif
X
X    sigset(SIGINT, int_catcher);	/* always catch interrupts */
X#ifdef SIGHUP
X    sigset(SIGHUP, sig_catcher);	/* and hangups */
X#endif
X#ifndef lint
X#ifdef SIGEMT
X    sigignore(SIGEMT);
X#endif
X#endif /* lint */
X
X    sigset(SIGILL, sig_catcher);
X#ifdef SIGTRAP
X    sigset(SIGTRAP, sig_catcher);
X#endif
X    sigset(SIGFPE, sig_catcher);
X#ifdef SIGBUS
X    sigset(SIGBUS, sig_catcher);
X#endif
X    sigset(SIGSEGV, sig_catcher);
X#ifdef SIGSYS
X    sigset(SIGSYS, sig_catcher);
X#endif
X    sigset(SIGTERM, sig_catcher);
X#ifdef SIGXCPU
X    sigset(SIGXCPU, sig_catcher);
X#endif
X#ifdef SIGXFSZ
X    sigset(SIGXFSZ, sig_catcher);
X#endif
X#ifdef SIGWINCH
X    sigset(SIGWINCH, winch_catcher);
X#endif
X}
X
Xvoid					/* very much void */
Xfinalize(status)
Xint status;
X{
X#ifdef SERVER
X    char artname[32];
X#endif /* SERVER */
X
X    if (bizarre)
X	resetty();
X    if (lockname && *lockname)
X 	UNLINK(lockname);
X#ifdef SERVER
X    if (*active_name)
X	UNLINK(active_name);
X    if (openart) {
X 	char artname[32];
X 	sprintf(artname, "/tmp/rrn%ld.%d", (long)openart, getpid());
X 	UNLINK(artname);
X    }
X    close_server();
X#endif /* SERVER */
X    if (status < 0) {
X	chdir("/usr/tmp");
X	sigset(SIGILL,SIG_DFL);
X	abort();
X    }
X    exit(status);
X}
X
X/* come here on interrupt */
X
XSIGRET
Xint_catcher()
X{
X    sigset(SIGINT,int_catcher);
X#ifdef DEBUGGING
X    if (debug)
X	write(2,"int_catcher\n",12);
X#endif
X    if (!waiting) {
X	if (int_count) {		/* was there already an interrupt? */
X	    write(2,"\nBye-bye.\n",10);
X	    sig_catcher(0);		/* emulate the other signals */
X	}
X	int_count++;
X    }
X}
X
X/* come here on signal other than interrupt, stop, or cont */
X
XSIGRET
Xsig_catcher(signo)
X{
X#ifdef VERBOSE
X    static char *signame[] = {
X	"",
X	"HUP",
X	"INT",
X	"QUIT",
X	"ILL",
X	"TRAP",
X	"IOT",
X	"EMT",
X	"FPE",
X	"KILL",
X	"BUS",
X	"SEGV",
X	"SYS",
X	"PIPE",
X	"ALRM",
X	"TERM",
X	"???"
X#ifdef SIGTSTP
X	,"STOP",
X	"TSTP",
X	"CONT",
X	"CHLD",
X	"TTIN",
X	"TTOU",
X	"TINT",
X	"XCPU",
X	"XFSZ"
X#ifdef SIGPROF
X	,"VTALARM",
X	"PROF"
X#endif
X#endif
X	};
X#endif
X
X#ifdef DEBUGGING
X    if (debug) {
X	printf("\nSIG%s--.newsrc not restored in debug\n",signame[signo]);
X	finalize(-1);
X    }
X#endif
X    if (panic)
X	abort();
X    (void) sigset(SIGILL,SIG_DFL);
X    panic = TRUE;			/* disable terminal I/O */
X    if (doing_ng) {			/* need we reconstitute rc line? */
X	yankback();
X	restore_ng();			/* then do so (hope this works) */
X    }
X    doing_ng = FALSE;
X    if (rc_changed)			/* need we write .newsrc out? */
X	write_rc();			/* then do so */
X    rc_changed = FALSE;
X#ifdef SIGHUP
X    if (signo != SIGHUP)
X#endif
X#ifdef VERBOSE
X	IF(verbose)
X	    printf("\nCaught %s%s--.newsrc restored\n",
X		signo ? "a SIG" : "an internal error", signame[signo]);
X	ELSE
X#endif
X#ifdef TERSE
X	    printf("\nSignal %d--bye bye\n",signo);
X#endif
X    switch (signo) {
X#ifdef SIGBUS
X    case SIGBUS:
X#endif
X    case SIGILL:
X    case SIGSEGV:
X	finalize(-signo);
X    }
X    finalize(1);				/* and blow up */
X}
X
X#ifdef SIGTSTP
X/* come here on stop signal */
X
XSIGRET
Xstop_catcher(signo)
Xint signo;
X{
X    if (!waiting) {
X	checkpoint_rc();		/* good chance of crash while stopped */
X	if (clear_on_stop) {
X	    clear();
X	    putchar('\n') FLUSH;
X	}
X	resetty();			/* this is the point of all this */
X#ifdef DEBUGGING
X	if (debug)
X	    write(2,"stop_catcher\n",13);
X#endif
X	sigset(signo,SIG_DFL);	/* enable stop */
X#ifdef SIGBLOCK
X	sigsetmask(sigblock(0) & ~(1 << (signo-1)));
X#endif
X	kill(0,signo);		/* and do the stop */
X    	savetty();
X#ifdef MAILCALL
X    	mailcount = 0;			/* force recheck */
X#endif
X    	if (!panic) {
X	    if (!waiting) {
X	    	noecho();			/* set no echo */
X	    	crmode();			/* set cbreak mode */
X	    	forceme("\f");		/* cause a refresh */
X					/* (defined only if TIOCSTI defined) */
X		errno = 0;			/* needed for getcmd */
X	    }
X    	}
X    }
X    sigset(signo,stop_catcher);	/* unenable the stop */
X}
X#endif
END_OF_FILE
  if test 5537 -ne `wc -c <'final.c'`; then
    echo shar: \"'final.c'\" unpacked with wrong size!
  fi
  # end of 'final.c'
fi
if test -f 'kfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kfile.c'\"
else
  echo shar: Extracting \"'kfile.c'\" \(7358 characters\)
  sed "s/^X//" >'kfile.c' <<'END_OF_FILE'
X/* $Header: kfile.c,v 4.3.3.2 91/01/16 02:46:28 davison Trn $
X *
X * $Log:	kfile.c,v $
X * Revision 4.3.3.2  91/01/16  02:46:28  davison
X * Integrated rn patches 48-54.
X * 
X * Revision 4.3.3.1  90/06/20  22:38:06  davison
X * Initial Trn Release
X * 
X * Revision 4.3.2.2  90/11/22  16:09:54  sob
X * Added changes to accomodate picky C preprocessors
X * 
X * Revision 4.3.2.1  90/03/22  23:04:41  sob
X * Fixes provided by Wayne Davison <drivax!davison>
X * 
X * Revision 4.3.1.3  85/05/29  09:11:52  lwall
X * Suppressed some killing messages on -t.
X * 
X * Revision 4.3.1.2  85/05/10  14:21:29  lwall
X * Prevented THRU from setting art < absfirst.
X * 
X * Revision 4.3.1.1  85/05/10  11:34:33  lwall
X * Branch for patches.
X * 
X * Revision 4.3  85/05/01  11:41:53  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "term.h"
X#include "util.h"
X#include "artsrch.h"
X#include "ng.h"
X#include "bits.h"
X#include "intrp.h"
X#include "ngstuff.h"
X#include "rcstuff.h"
X#include "rn.h"
X#ifdef USETHREADS
X#include "rthreads.h"
X#endif
X#include "INTERN.h"
X#include "kfile.h"
X
Xstatic bool exitcmds = FALSE;
X
Xvoid
Xkfile_init()
X{
X    ;
X}
X
X#ifndef KILLFILES
Xint
Xedit_kfile()
X{
X    notincl("^K");
X    return -1;
X}
X
X#else /* KILLFILES */
X
Xchar killglobal[] = KILLGLOBAL;
Xchar killlocal[] = KILLLOCAL;
X
Xvoid
Xmention(str)
Xchar *str;
X{
X#ifdef VERBOSE
X    IF(verbose) {
X#ifdef NOFIREWORKS
X	no_sofire();
X#endif
X	standout();
X	fputs(str,stdout);
X	un_standout();
X	putchar('\n');
X    }
X    ELSE
X#endif
X#ifdef TERSE
X	putchar('.');
X#endif
X    fflush(stdout);
X}
X
Xbool kill_mentioned;
X
Xint
Xdo_kfile(kfp,entering)
XFILE *kfp;
Xint entering;
X{
X#ifdef USETHREADS
X    int i;
X    ART_NUM kill_thread;
X#endif
X
X    art = lastart+1;
X    fseek(kfp,0L,0);			/* rewind file */
X    while (fgets(buf,LBUFLEN,kfp) != Nullch) {
X	buf[strlen(buf)-1] = '\0';
X	if (strnEQ(buf,"THRU",4)) {
X	    ART_NUM tmpart;
X
X	    tmpart = atol(buf+4)+1;
X	    if (tmpart < absfirst)
X		tmpart = absfirst;
X	    check_first(tmpart);
X	    firstart = tmpart;
X	    continue;
X	}
X	if (*buf == 'X') {		/* exit command? */
X	    if (entering) {
X		exitcmds = TRUE;
X		continue;
X	    }
X	    strcpy(buf,buf+1);
X	}
X	else {
X	    if (!entering)
X		continue;
X	}
X	if (*buf == '&') {
X	    mention(buf);
X	    switcheroo();
X	}
X	else if (*buf == '/' && firstart <= lastart) {
X	    mention(buf);
X	    kill_mentioned = TRUE;
X	    switch (art_search(buf, (sizeof buf), FALSE)) {
X	    case SRCH_ABORT:
X		continue;
X	    case SRCH_INTR:
X#ifdef VERBOSE
X		IF(verbose)
X		    printf("\n(Interrupted at article %ld)\n",(long)art)
X		      FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    printf("\n(Intr at %ld)\n",(long)art) FLUSH;
X#endif
X		return -1;
X	    case SRCH_DONE:
X		break;
X	    case SRCH_SUBJDONE:
X		fputs("\tsubject not found (???)\n",stdout) FLUSH;
X		break;
X	    case SRCH_NOTFOUND:
X		fputs("\tnot found\n",stdout) FLUSH;
X		break;
X	    case SRCH_FOUND:
X		fputs("\tfound\n",stdout) FLUSH;
X	    }
X	}
X#ifdef USETHREADS
X	else if (*buf == 'T' && firstart <= lastart && p_roots) {
X	    /* kill a thread by its root id number */
X	    kill_thread = atol(buf+1);
X	    for (i = 0; i < total.root; i++) {
X		if (p_roots[i].root_num == kill_thread) {
X		    if (count_one_root(i) != 0) {
X			mention(buf);
X			kill_mentioned = TRUE;
X			printf("%ldx%d ",(long)kill_thread,
X					 root_article_cnts[i]);
X			p_art = p_articles + p_roots[i].articles;
X			art = p_art->num;
X			follow_thread('k');
X		    }
X		    break;
X		}
X	    }
X	}
X#endif
X    }
X
X    return 0;
X}
X
Xvoid
Xkill_unwanted(starting,message,entering)
XART_NUM starting;
Xchar *message;
Xint entering;
X{
X    bool intr = FALSE;			/* did we get an interrupt? */
X    ART_NUM oldfirst;
X    bool anytokill = (toread[ng] > 0);
X
X    if (localkfp || globkfp) {
X	if (!entering && !exitcmds)
X	    return;
X	exitcmds = FALSE;
X	oldfirst = firstart;
X	firstart = starting;
X	clear();
X#ifdef VERBOSE
X# ifdef TERSE
X	if (message && (verbose || entering))
X# else
X	if (message)
X# endif
X#else
X	if (message && entering)
X#endif
X	    fputs(message,stdout) FLUSH;
X
X	kill_mentioned = FALSE;
X	if (localkfp)
X	    intr = do_kfile(localkfp,entering);
X	if (globkfp && !intr)
X	    intr = do_kfile(globkfp,entering);
X	if (entering && localkfp && !intr)
X	    setthru(lastart);
X	putchar('\n') FLUSH;
X	if (entering && kill_mentioned)
X#ifdef VERBOSE
X	    IF(verbose)
X		get_anything();
X	    ELSE
X#endif
X#ifdef TERSE
X		pad(just_a_sec);
X#endif
X	if (anytokill)			/* if there was anything to kill */
X	    forcelast = FALSE;		/* allow for having killed it all */
X	firstart = oldfirst;
X    }
X}
X
Xvoid
Xsetthru(thru)
XART_NUM thru;
X{
X    FILE *newkfp;
X    bool no_kills = 0;
X#ifdef USETHREADS
X    int i;
X    ART_NUM kill_thread;
X#endif
X
X    fseek(localkfp,0L,0);		/* rewind current file */
X    if (fgets(buf,LBUFLEN,localkfp) != Nullch
X     && (strnNE(buf,"THRU",4) || fgets(buf,LBUFLEN,localkfp) != Nullch))
X	fseek(localkfp,0L,0);
X    else
X	no_kills = 1;
X    strcpy(buf,filexp(getval("KILLLOCAL",killlocal)));
X    UNLINK(buf);			/* to prevent file reuse */
X    if (no_kills)
X	open_kfile(KF_LOCAL);		/* close file and reset open flag */
X    else if (newkfp = fopen(buf,"w")) {
X	fprintf(newkfp,"THRU %ld\n",(long)thru);
X	while (fgets(buf,LBUFLEN,localkfp) != Nullch) {
X	    if (strnEQ(buf,"THRU",4))
X		continue;
X#ifdef USETHREADS
X	    /* Leave out any outdated thread kills */
X	    if (*buf == 'T' && p_roots) {
X		kill_thread = atol(buf+1);
X		for (i = 0; i < total.root; i++) {
X		    if (p_roots[i].root_num == kill_thread) {
X			break;
X		    }
X		}
X		if (i == total.root)
X		    continue;
X	    }
X#endif
X	    fputs(buf,newkfp);
X	}
X	fclose(newkfp);
X	open_kfile(KF_LOCAL);		/* and reopen local file */
X    }
X    else
X	printf(cantcreate,buf) FLUSH;
X}
X
X/* edit KILL file for newsgroup */
X
Xint
Xedit_kfile()
X{
X    int r = -1;
X
X    if (in_ng)
X	strcpy(buf,filexp(getval("KILLLOCAL",killlocal)));
X    else
X	strcpy(buf,filexp(getval("KILLGLOBAL",killglobal)));
X    if ((r = makedir(buf,MD_FILE)) >= 0) {
X	sprintf(cmd_buf,"%s %s",
X	    filexp(getval("VISUAL",getval("EDITOR",defeditor))),buf);
X	printf("\nEditing %s KILL file:\n%s\n",
X	    (in_ng?"local":"global"),cmd_buf) FLUSH;
X	resetty();			/* make sure tty is friendly */
X	r = doshell(sh,cmd_buf);/* invoke the shell */
X	noecho();			/* and make terminal */
X	crmode();			/*   unfriendly again */
X	open_kfile(in_ng);
X    }
X    else
X	printf("Can't make %s\n",buf) FLUSH;
X    return r;
X}
X
Xvoid
Xopen_kfile(local)
Xint local;
X{
X    char *kname = filexp(local ?
X	getval("KILLLOCAL",killlocal) :
X	getval("KILLGLOBAL",killglobal)
X	);
X    
X    stat(kname,&filestat);
X    if (!filestat.st_size)		/* nothing in the file? */
X	UNLINK(kname);			/* delete the file */
X    if (local) {
X	if (localkfp)
X	    fclose(localkfp);
X	localkfp = fopen(kname,"r");
X    }
X    else {
X	if (globkfp)
X	    fclose(globkfp);
X	globkfp = fopen(kname,"r");
X    }
X}
X
Xvoid
Xkf_append(cmd)
Xchar *cmd;
X{
X    strcpy(cmd_buf,filexp(getval("KILLLOCAL",killlocal)));
X    if (makedir(cmd_buf,MD_FILE) >= 0) {
X#ifdef VERBOSE
X	IF(verbose)
X	    printf("\nDepositing command in %s...",cmd_buf);
X	ELSE
X#endif
X#ifdef TERSE
X	    printf("\n--> %s...",cmd_buf);
X#endif
X	fflush(stdout);
X	sleep(2);
X	if ((tmpfp = fopen(cmd_buf,"a")) != Nullfp) {
X	    fseek(tmpfp,0L,2);		/* get to EOF for sure */
X	    fprintf(tmpfp,"%s\n",cmd);
X	    fclose(tmpfp);
X	    fputs("done\n",stdout) FLUSH;
X	}
X	else
X	    printf(cantopen,cmd_buf) FLUSH;
X    }
X}
X#endif /* KILLFILES */
END_OF_FILE
  if test 7358 -ne `wc -c <'kfile.c'`; then
    echo shar: \"'kfile.c'\" unpacked with wrong size!
  fi
  # end of 'kfile.c'
fi
if test -f 'rthreads.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rthreads.c'\"
else
  echo shar: Extracting \"'rthreads.c'\" \(7151 characters\)
  sed "s/^X//" >'rthreads.c' <<'END_OF_FILE'
X/* $Header: rthreads.c,v 4.3.3.3 91/01/16 03:28:53 davison Trn $
X**
X** $Log:	rthreads.c,v $
X** Revision 4.3.3.3  91/01/16  03:28:53  davison
X** Changed Free to safefree.  Tweaked fopen for possible binary open mode.
X** 
X** Revision 4.3.3.2  90/08/20  16:58:14  davison
X** Added message for missing/bad db.init file.
X** 
X** Revision 4.3.3.1  90/06/20  23:00:28  davison
X** Initial Trn Release
X** 
X*/
X
X#include "EXTERN.h"
X#include "common.h"
X#include "intrp.h"
X
X#ifdef USETHREADS
X#include "INTERN.h"
X#include "rthreads.h"
X
Xstatic FILE *fp_in;
X
Xstatic char *strings = Nullch;
X
Xstatic int read_item();
Xstatic void wp_bmap(), lp_bmap();
Xstatic void safefree();
X
X/* Initialize our thread code by determining the byte-order of the thread
X** files and our own current byte-order.  If they differ, set flags to let
X** the read code know what we'll need to translate.
X*/
Xvoid
Xthread_init()
X{
X    char *filename;
X    int i;
X
X    word_same = long_same = TRUE;
X    filename = filexp( "%X/db.init" );
X    if( (fp_in = fopen( filename, FOPEN_RB )) != Nullfp ) {
X	if( fread( &mt_bmap, 1, sizeof (BMAP), fp_in ) >= sizeof (BMAP)-1 ) {
X	    if( mt_bmap.version != DB_VERSION ) {
X		printf( "\nThread database is the wrong version -- ignoring it.\n" ) FLUSH;
X		use_threads = FALSE;
X	    }
X	    mybytemap( &my_bmap );
X	    for( i = 0; i < sizeof (LONG); i++ ) {
X		if( i < sizeof (WORD) ) {
X		    if( my_bmap.w[i] != mt_bmap.w[i] ) {
X			word_same = FALSE;
X		    }
X		}
X		if( my_bmap.l[i] != mt_bmap.l[i] ) {
X		    long_same = FALSE;
X		}
X	    }
X	} else {
X	    goto no_db_init;
X	}
X	fclose( fp_in );
X    } else {
X      no_db_init:
X	printf( "\ndb.init read failed -- assuming no byte-order translations.\n\n" ) FLUSH;
X    }
X}
X
X/* Open a thread file for the sole purpose of using it in a newsreader-
X** style application.  Everything is read into arrays in chunks and some
X** useful massaging of the data is performed to make the newsreader's life
X** easier.  Be sure to call unuse_data() before calling this a second time.
X*/
Xint
Xuse_data( threadname )
Xchar *threadname;
X{
X    register int i, j, k;
X    register char *ptr;
X
X    if( (fp_in = fopen( threadname, FOPEN_RB )) == Nullfp ) {
X	if (errno != ENOENT) {
X	    printf( "\n\nOpen failed for thread data -- continuing unthreaded.\n" );
X	}
X	bzero( &total, sizeof (TOTAL) );
X	return 0;
X    }
X    if( fread( &total, 1, sizeof (TOTAL), fp_in ) < sizeof (TOTAL) ) {
X	printf( "\n\nRead failed for thread data -- continuing unthreaded.\n" );
X	fclose( fp_in );
X	bzero( &total, sizeof (TOTAL) );
X	return 0;
X    }
X    lp_bmap( &total.first, 4 );
X    wp_bmap( &total.root, 5 );
X
X    if( !read_item( &author_cnts, (MEM_SIZE)total.author * sizeof (WORD) )
X     || !read_item( &strings, (MEM_SIZE)total.string1 ) 
X     || !read_item( &subject_cnts, (MEM_SIZE)total.subject * sizeof (WORD) )
X     || !read_item( &p_roots, (MEM_SIZE)total.root * sizeof (PACKED_ROOT) )
X     || !read_item( &p_articles, (MEM_SIZE)total.article * sizeof (PACKED_ARTICLE) ) ) {
X	printf( "\n\nRead failed for thread data -- continuing unthreaded.\n" );
X	fclose( fp_in );
X	unuse_data( 0 );
X	return 0;
X    }
X    fclose( fp_in );
X
X    if( !word_same || !long_same ) {
X	wp_bmap( author_cnts, total.author );
X	wp_bmap( subject_cnts, total.subject );
X	for( i = 0; i < total.root; i++ ) {
X	    lp_bmap( &p_roots[i].root_num, 1 );
X	    wp_bmap( &p_roots[i].articles, 3 );
X	}
X	for( i = 0; i < total.article; i++ ) {
X	    lp_bmap( &p_articles[i].num, 2 );
X	    wp_bmap( &p_articles[i].subject, 8 );
X	}
X    }
X
X#ifndef lint
X    author_ptrs = (char **)safemalloc( total.author * sizeof (char **) );
X    subject_ptrs = (char **)safemalloc( total.subject * sizeof (char **) );
X    root_subjects = (WORD *)safemalloc( total.root * sizeof (WORD) );
X    root_article_cnts = (WORD *)safemalloc( total.root * sizeof (WORD) );
X#endif
X    selected_roots = safemalloc( total.root * sizeof (char) );
X
X    bzero( root_article_cnts, total.root * sizeof (WORD) );
X    bzero( selected_roots, total.root * sizeof (char) );
X
X    for( i = 0, ptr = strings; i < total.author; i++ ) {
X	author_ptrs[i] = ptr;
X	ptr += strlen( ptr ) + 1;
X    }
X
X    for( i = 0, j = 0; i < total.root; i++ ) {
X	root_subjects[i] = j;
X	k = p_roots[i].subject_cnt;
X	while( k-- ) {
X	    root_article_cnts[i] += subject_cnts[j];
X	    subject_ptrs[j++] = ptr;
X	    ptr += strlen( ptr ) + 1;
X	}
X	if( saved_selections ) {
X	    for( k = 0; k < selected_root_cnt; k++ ) {
X		if( p_roots[i].root_num == saved_selections[k] ) {
X		    selected_roots[i] = 1;
X		}
X	    }
X	}
X    }
X    count_roots( !saved_selections );
X    safefree( &saved_selections );
X    select_page = 0;
X    return 1;
X}
X
X/* A short-hand for reading a chunk of the file into a malloced array.
X*/
Xstatic int
Xread_item( dest, len )
Xchar **dest;
XMEM_SIZE len;
X{
X    int ret;
X
X    *dest = safemalloc( len );
X    ret = fread( *dest, 1, (int)len, fp_in );
X    if( ret != len ) {
X	free( *dest );
X	*dest = Nullch;
X	return 0;
X    }
X    return 1;
X}
X
X/* Free some memory if it hasn't already been freed.
X*/
Xstatic void
Xsafefree( pp )
Xchar **pp;
X{
X    if( *pp ) {
X	free( *pp );
X	*pp = Nullch;
X    }
X}
X
X/* Discard the thread data that we received through the use_data() call.
X** If "save_selections" is non-zero, we'll try to remember which roots
X** are currently selected long enough for the use_data() call to re-use
X** them.  Only do this when you are going to re-open the same data file
X** immediately with use_data() (presumably because the data has been
X** updated while we were using it).
X*/
Xvoid
Xunuse_data( save_selections )
Xbool save_selections;
X{
X    int i, j;
X
X    if( save_selections ) {
X#ifndef lint
X	saved_selections
X	  = (ART_NUM *)safemalloc( selected_root_cnt * sizeof (ART_NUM) );
X#endif
X	for( i = 0, j = 0; i < total.root; i++ ) {
X	    if( selected_roots[i] && root_article_cnts[i] ) {
X		saved_selections[j++] = p_roots[i].root_num;
X	    }
X	}
X    } else {
X	selected_root_cnt = selected_count = 0;
X    }
X    safefree( &p_roots );
X    safefree( &root_subjects );
X    safefree( &author_cnts );
X    safefree( &subject_cnts );
X    safefree( &author_ptrs );
X    safefree( &subject_ptrs );
X    safefree( &root_article_cnts );
X    safefree( &selected_roots );
X    safefree( &p_articles );
X    safefree( &strings );
X
X    p_art = curr_p_art = Nullart;
X    init_tree();		/* free any tree lines */
X
X    bzero( &total, sizeof (TOTAL) );
X}
X
X/* Transform each WORD's byte-ordering in a buffer of the designated length.
X*/
Xstatic void
Xwp_bmap( buf, len )
XWORD *buf;
Xint len;
X{
X    union {
X	BYTE b[sizeof (WORD)];
X	WORD w;
X    } in, out;
X    register int i;
X
X    if( word_same ) {
X	return;
X    }
X    while( len-- ) {
X	in.w = *buf;
X	for( i = 0; i < sizeof (WORD); i++ ) {
X	    out.b[my_bmap.w[i]] = in.b[mt_bmap.w[i]];
X	}
X	*buf++ = out.w;
X    }
X}
X
X/* Transform each LONG's byte-ordering in a buffer of the designated length.
X*/
Xstatic void
Xlp_bmap( buf, len )
XLONG *buf;
Xint len;
X{
X    union {
X	BYTE b[sizeof (LONG)];
X	LONG l;
X    } in, out;
X    register int i;
X
X    if( long_same ) {
X	return;
X    }
X    while( len-- ) {
X	in.l = *buf;
X	for( i = 0; i < sizeof (LONG); i++ ) {
X	    out.b[my_bmap.l[i]] = in.b[mt_bmap.l[i]];
X	}
X	*buf++ = out.l;
X    }
X}
X
X#endif /* USETHREADS */
END_OF_FILE
  if test 7151 -ne `wc -c <'rthreads.c'`; then
    echo shar: \"'rthreads.c'\" unpacked with wrong size!
  fi
  # end of 'rthreads.c'
fi
if test -f 'uudecode.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'uudecode.c'\"
else
  echo shar: Extracting \"'uudecode.c'\" \(8069 characters\)
  sed "s/^X//" >'uudecode.c' <<'END_OF_FILE'
X/* $Header: uudecode.c,v 4.3.3.2 91/01/16 03:41:52 davison Trn $
X**
X** $Log:	uudecode.c,v $
X** Revision 4.3.3.2  91/01/16  03:41:52  davison
X** Tweaked fopen for possible binary open mode.
X** 
X** Revision 4.3.3.1  90/06/20  22:48:21  davison
X** Initial Trn Release
X** 
X** Decode one or more uuencoded articles back to binary form.
X**
X** Trn version created by Wayne Davison.
X** Adapted from the nn version by Kim Storm.
X** From the Berkeley original, modified by MSD, RDR, JPHD & WLS.
X*/
X
X#include "EXTERN.h"
X#include "common.h"
X#include "INTERN.h"
X#include "uudecode.h"
X
X#if 000
Xexport char *decode_header_file = "Decode.Headers";
X#endif
X
X#define MAXCHAR 256
X#define NORMLEN 60	/* allows for 80 encoded chars per line */
X
X#define SEQMAX 'z'
X#define SEQMIN 'a'
X
Xstatic char seqc;
Xstatic int first, secnd, check, numl;
X
Xstatic char *target;
Xstatic char dest[MAXFILENAME];
Xstatic char blank;
Xstatic int chtbl[MAXCHAR], cdlen[NORMLEN + 3];
Xstatic int state;
Xstatic bool Xflag;
X
X#define	NO_ADVANCE		0x10
X
X#define	FIND_BEGIN		0x01
X#define	FIND_BEGIN_AFTER_ERROR	0x02
X#define	DECODE_TEXT		0x03
X#define	SKIP_TRAILING	       (0x04 | NO_ADVANCE)
X#define	SKIP_LEADING		0x05
X#define	FOUND_END	       (0x06 | NO_ADVANCE)
X#define DECODE_ERROR	       (0x07 | NO_ADVANCE)
X#define OTHER_ERROR	       (0x08 | NO_ADVANCE)
X#define NEW_BEGIN	       (0x09 | NO_ADVANCE)
X
Xuud_start(dir)
Xchar *dir;
X{
X    target = dir;
X    uu_out = Nullfp;
X    Xflag = FALSE;
X    seqc = SEQMAX;
X    check = 1;
X    first = 1;
X    secnd = 0;
X    state = FIND_BEGIN;
X}
X
Xuud_end()
X{
X    if (uu_out != Nullfp) {
X	fclose(uu_out);
X	uu_out = Nullfp;
X	printf("\n%s INCOMPLETE -- removed\n", dest);
X	unlink(dest);
X    }
X}
X
X
Xuudecode(in)
XFILE *in;
X{
X    int mode, onedone, lens;
X    char buff[LBUFLEN];
X
X    numl = onedone = 0;
X
X    if (state == FIND_BEGIN)
X	inittbls();
X
X    /*
X     * search for header or translation table line.
X     */
X
X    while ((state & NO_ADVANCE) || fgets(buff, sizeof buff, in) != Nullch) {
X	numl++;
X
X	switch (state) {
X	 case NEW_BEGIN:
X	    if (uu_out != Nullfp) {
X		printf("INCOMPLETE FILE: %s -- removed\n", dest);
X		sleep(2);
X		fclose(uu_out);
X		uu_out = Nullfp;
X		Xflag = FALSE;
X		unlink(dest);
X	    }
X	    /* fall thru */
X
X	 case FIND_BEGIN:
X	 case FIND_BEGIN_AFTER_ERROR:
X	    if (strnEQ(buff, "table ", 6)) {
X		gettable(in);
X		continue;
X	    }
X
X	    if (strnEQ(buff, "begin ", 6)
X	     || strnEQ(buff, "Xbegin ", 7)) {
X		lens = strlen(buff)-1;
X		if (buff[lens] == '\n')
X		    buff[lens] = '\0';
X
X		if(sscanf(buff+6,"%o%s", &mode, uu_fname) != 2)
X		    continue;
X
X		Xflag = (*buff == 'X');
X
X		if (target != Nullch)
X		    sprintf(dest, "%s/%s", target, uu_fname);
X		else
X		    strcpy(dest, uu_fname);
X
X		if ((uu_out = fopen(dest, FOPEN_WB)) == Nullfp) {
X		    printf("Cannot create file: %s\n", dest);
X		    goto err;
X		}
X		chmod(dest, mode);
X
X#if 000
X		if (decode_header_file)
X		    store_header(ah, in, target, decode_header_file);
X#endif
X
X		printf("Decoding: %s\n", uu_fname);
X		state = DECODE_TEXT;
X	    }
X	    continue;
X
X	 case SKIP_LEADING:
X	    state = decode_line(buff);
X	    continue;
X
X	 case DECODE_TEXT:
X	    state = decode_line(buff);
X	    onedone = 1;
X	    continue;
X
X	 case FOUND_END:
X	    fclose(uu_out);
X	    uu_out = Nullfp;
X	    Xflag = FALSE;
X	    state = FIND_BEGIN;
X	    printf("Done.\n");
X	    continue;
X
X	 case SKIP_TRAILING:
X	    printf("(Continued)\n");
X	    state = SKIP_LEADING;
X	    return 0;
X
X	 case DECODE_ERROR:
X	    state = SKIP_TRAILING;
X	    continue;
X
X	 case OTHER_ERROR:
X	    fclose(uu_out);
X	    uu_out = Nullfp;
X	    Xflag = FALSE;
X	    state = FIND_BEGIN_AFTER_ERROR;
X	    goto err;
X	}
X    }
X
X    if (onedone) {
X	if (state == DECODE_TEXT)
X	    state = SKIP_LEADING;
X	return 0;
X    }
X
X    if (state == FIND_BEGIN_AFTER_ERROR)
X	return -1;
X    printf("Couldn't find anything to decode.\n");
X
X err:
X    sleep(2);
X    return -1;
X}
X
X/*
X * decode one line, write on uu_out file
X */
X
Xstatic decode_line(buff)
Xchar *buff;
X{
X    char outl[LBUFLEN];
X    register char *bp, *ut;
X    register int *trtbl = chtbl;
X    register int n;
X    register int blen;		/* binary length (from decoded file) */
X    register int rlen;		/* calculated input line length */
X    register int len;		/* actual input line length */
X
X    if (Xflag) {
X	if (*buff == 'X')
X	    buff++;
X	else
X	    *buff = 'x';	/* force a mis-parse of a non-x'ed line */
X    }
X    len = strlen(buff);
X    if (--len < 0)
X	return state;
X
X    buff[len] = '\0';
X
X    /*
X     * Get the binary line length.
X     */
X    if ((blen = trtbl[buff[0]]) < 0) {
X	if (state == SKIP_LEADING) {
X	    if (strnEQ(buff, "begin ", 6))
X		return NEW_BEGIN;
X
X	    return SKIP_LEADING;
X	}
X	/*
X	 * end of uuencoded file ?
X	 */
X	if (strnEQ(buff, "end", 3))
X	    return FOUND_END;
X
X	/*
X	 * end of current file ? : get next one.
X	 */
X	if (strnEQ(buff, "include", 7)) {
X	    printf("Cannot handle 'include' lines -- unpack with uud\n");
X	    return OTHER_ERROR;
X	}
X
X	/*
X	 * trailing garbage
X	 */
X	return SKIP_TRAILING;
X    }
X
X    rlen = cdlen[blen];
X    if (state == SKIP_LEADING && len != rlen && len != rlen+1)
X	return SKIP_LEADING;
X
X    /*
X     * Is it the empty line before the end line ?
X     */
X    if (blen == 0)
X	return state;
X
X    if (len > rlen + 5)
X	return SKIP_TRAILING;
X
X    /*
X     * Pad with blanks.
X     */
X    for (bp = buff + len, n = rlen - len; --n >= 0; )
X	*bp++ = blank;
X
X    /*
X     * Verify
X     */
X    for (n = rlen, bp = buff; --n >= 0; bp++)
X	if (trtbl[*bp] < 0) {
X	    if (state == SKIP_LEADING)
X		return SKIP_LEADING;
X	    return DECODE_ERROR;
X	}
X
X    /*
X     * Check for uuencodes that append a 'z' to each line....
X     */
X    if (check)
X	if (secnd) {
X	    secnd = 0;
X	    if (buff[rlen] == SEQMAX)
X		check = 0;
X	} else if (first) {
X	    first = 0;
X	    secnd = 1;
X	    if (buff[rlen] != SEQMAX)
X		check = 0;
X	}
X
X    /*
X     * There we check.
X     */
X    if (check) {
X	if (buff[rlen] != seqc) {
X	    if (state == SKIP_LEADING)
X		return SKIP_LEADING;
X	    return DECODE_ERROR;
X	}
X
X	if (--seqc < SEQMIN)
X	    seqc = SEQMAX;
X    }
X
X    /*
X     * output a group of 3 bytes (4 input characters).
X     * the input chars are pointed to by p, they are to
X     * be output to file f. blen is used to tell us not to
X     * output all of them at the end of the file.
X     */
X    ut = outl;
X    n = blen;
X    bp = &buff[1];
X    while (--n >= 0) {
X	*(ut++) = trtbl[*bp] << 2 | trtbl[bp[1]] >> 4;
X	if (n > 0) {
X	    *(ut++) = (trtbl[bp[1]] << 4) | (trtbl[bp[2]] >> 2);
X	    n--;
X	}
X	if (n > 0) {
X	    *(ut++) = trtbl[bp[2]] << 6 | trtbl[bp[3]];
X	    n--;
X	}
X	bp += 4;
X    }
X    if (fwrite(outl, 1, blen, uu_out) <= 0) {
X	printf("Error on writing decoded file\n");
X	return OTHER_ERROR;
X    }
X
X    return DECODE_TEXT;
X}
X
X
X
X/*
X * Install the table in memory for later use.
X */
Xstatic inittbls()
X{
X    register int i, j;
X
X    /*
X     * Set up the default translation table.
X     */
X    for (i = 0; i < ' '; i++)
X	chtbl[i] = -1;
X    for (i = ' ', j = 0; i < ' ' + 64; i++, j++)
X	chtbl[i] = j;
X    for (i = ' ' + 64; i < MAXCHAR; i++)
X	chtbl[i] = -1;
X    chtbl['`'] = chtbl[' '];	/* common mutation */
X    chtbl['~'] = chtbl['^'];	/* another common mutation */
X    blank = ' ';
X    /*
X     * set up the line length table, to avoid computing lotsa * and / ...
X     */
X    cdlen[0] = 1;
X    for (i = 1, j = 5; i <= NORMLEN; i += 3, j += 4)
X	cdlen[i] = (cdlen[i + 1] = (cdlen[i + 2] = j));
X}
X
Xstatic gettable(in)
XFILE *in;
X{
X    char buff[LBUFLEN];
X    register int c, n = 0;
X    register char *cpt;
X
X    for (c = 0; c <= MAXCHAR; c++)
X	chtbl[c] = -1;
X
X    for (;;) {
X	if (fgets(buff, sizeof buff, in) == Nullch) {
X	    printf("EOF while in translation table.\n");
X	    return -1;
X	}
X	numl++;
X	if (strnEQ(buff, "begin", 5)) {
X	    printf("Incomplete translation table.\n");
X	    return -1;
X	}
X	cpt = buff + strlen(buff) - 1;
X	*cpt = ' ';
X	while (*cpt == ' ') {
X	    *cpt = 0;
X	    cpt--;
X	}
X	cpt = buff;
X	while (c = *cpt) {
X	    if (chtbl[c] != -1) {
X		printf("Duplicate char in translation table.\n");
X		return -1;
X	    }
X	    if (n == 0)
X		blank = c;
X	    chtbl[c] = n++;
X	    if (n >= 64)
X		return 0;
X	    cpt++;
X	}
X    }
X}
X
END_OF_FILE
  if test 8069 -ne `wc -c <'uudecode.c'`; then
    echo shar: \"'uudecode.c'\" unpacked with wrong size!
  fi
  # end of 'uudecode.c'
fi
echo shar: End of archive 12 \(of 14\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
