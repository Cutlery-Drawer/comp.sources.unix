This is a new archive version of TRN at patchlevel 3.
The original posting took up Volume23, issues 60 to 73, with
various problems.  These files replace those issues.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  mt-write.c rcstuff.c term.c
# Wrapped by rsalz@litchi.bbn.com on Fri Aug 23 16:38:56 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 7 (of 14)."'
if test -f 'mt-write.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mt-write.c'\"
else
  echo shar: Extracting \"'mt-write.c'\" \(9495 characters\)
  sed "s/^X//" >'mt-write.c' <<'END_OF_FILE'
X/* $Header: mt-write.c,v 4.3.3.2 91/01/16 02:49:17 davison Trn $
X**
X** $Log:	mt-write.c,v $
X** Revision 4.3.3.2  91/01/16  02:49:17  davison
X** Tweaked fopen for possible binary open mode.
X** 
X** Revision 4.3.3.1  90/07/24  23:51:18  davison
X** Initial Trn Release
X** 
X*/
X
X#include "EXTERN.h"
X#include "common.h"
X#include "mthreads.h"
X
Xstatic FILE *fp_out;
Xstatic int seq;
Xstatic int article_seq;
X
Xstatic int failure;
X
Xvoid write_subjects(), write_authors(), write_roots(), write_ids();
Xvoid write_articles(), write_thread(), write_item();
Xvoid enumerate_articles(), enumerate_thread();
Xvoid free_leftovers();
X
X/* Write out all the data in a packed format that is easy for our newsreader
X** to use.  We free things as we go, when we don't need them any longer.  If
X** we encounter any write errors, the write_item routine sets a failure flag
X** to halt our writing of the file, but we keep on plugging away to free
X** everything up.
X*/
Xint
Xwrite_data( filename )
Xchar *filename;
X{
X    if( filename == Nullch ) {
X	failure = 2;	/* A NULL filename indicates just free the data */
X    } else if( !ensure_path( filename ) ) {
X	log_error( "Unable to create path: `%s'.\n", filename );
X	failure = 2;
X    } else if( (fp_out = fopen( filename, FOPEN_WB )) == Nullfp ) {
X	log_error( "Unable to create file: `%s'.\n", filename );
X	failure = 2;
X    } else {
X	failure = 0;
X    }
X    write_item( &total, sizeof (TOTAL) );
X
X    enumerate_articles();
X
X    write_authors();
X    write_subjects();
X    write_roots();
X    write_articles();
X    write_ids();
X    free_leftovers();
X
X    if( failure != 2 ) {
X	fclose( fp_out );
X    }
X    if( failure == 1 ) {
X	log_error( "Write failed!  Removing `%s'.\n", filename );
X	unlink( filename );
X    }
X    return !failure;
X}
X
X/* Recursively descend the article tree, enumerating the articles as we go.
X** This way we can output the article sequence numbers into the data file.
X*/
Xvoid
Xenumerate_articles()
X{
X    register ROOT *root;
X
X    seq = article_seq = 0;
X
X    for( root = root_root; root; root = root->link ) {
X	root->seq = seq++;
X	if( !root->articles ) {
X	    log_error( "** No articles on this root??\n" );
X	    continue;
X	}
X	enumerate_thread( root->articles );
X    }
X    if( seq != total.root ) {
X	log_error( "** Wrote %d roots instead of %d **\n", seq, total.root );
X    }
X    if( article_seq != total.article ) {
X	log_error( "** Wrote %d articles instead of %d **\n", article_seq, total.article );
X    }
X}
X
X/* Recursive routine for above-mentioned enumeration. */
Xvoid
Xenumerate_thread( article )
XARTICLE *article;
X{
X    while( article ) {
X	article->seq = article_seq++;
X	if( article->children ) {
X	    enumerate_thread( article->children );
X	}
X	article = article->siblings;
X    }
X}
X
X#define write_and_free( str_ptr )	/* Comment for makedepend to	 \
X					** ignore the backslash above */ \
X{\
X    register int len = strlen( str_ptr ) + 1;\
X    write_item( str_ptr, len );\
X    free( str_ptr );\
X    string_offset += len;\
X}
X
XMEM_SIZE string_offset;
X
X/* Write out the author information:  first the use-counts, then the
X** name strings all packed together.
X*/
Xvoid
Xwrite_authors()
X{
X    register AUTHOR *author;
X
X    seq = 0;
X    for( author = author_root; author; author = author->link ) {
X	write_item( &author->count, sizeof (WORD) );
X	author->seq = seq++;
X    }
X    if( seq != total.author ) {
X	log_error( "** Wrote %d authors instead of %d **\n",
X		seq, total.author );
X    }
X
X    string_offset = 0;
X
X    for( author = author_root; author; author = author->link ) {
X	write_and_free( author->name );
X    }
X}
X
X/* Write out the subject information: first the packed string data, then
X** the use-counts.  The order is important -- it is the order required
X** by the roots for their subject structures.
X*/
Xvoid
Xwrite_subjects()
X{
X    register ROOT *root;
X    register SUBJECT *subject;
X
X    for( root = root_root; root; root = root->link ) {
X	for( subject = root->subjects; subject; subject = subject->link ) {
X	    write_and_free( subject->str );
X	}
X    }
X    if( string_offset != total.string1 ) {
X	log_error( "** Author/subject strings were %ld bytes instead of %ld **\n",
X		string_offset, total.string1 );
X    }
X
X    seq = 0;
X    for( root = root_root; root; root = root->link ) {
X	for( subject = root->subjects; subject; subject = subject->link ) {
X	    write_item( &subject->count, sizeof (WORD) );
X	    subject->seq = seq++;
X	}
X    }
X    if( seq != total.subject ) {
X	log_error( "** Wrote %d subjects instead of %d **\n",
X		seq, total.subject );
X    }
X}
X
X/* Write the roots in a packed format.  Interpret the pointers into
X** sequence numbers as we go.
X*/
Xvoid
Xwrite_roots()
X{
X    register ROOT *root;
X
X    for( root = root_root; root; root = root->link ) {
X	p_root.articles = root->articles->seq;
X	p_root.root_num = root->root_num;
X	p_root.thread_cnt = root->thread_cnt;
X	p_root.subject_cnt = root->subject_cnt;
X	write_item( &p_root, sizeof (PACKED_ROOT) );
X    }
X}
X
X#define rel_article( article, rseq )	((article)? (article)->seq - (rseq) : 0)
X#define valid_seq( ptr )		((ptr)? (ptr)->seq : -1)
X
X/* Write all the articles in the same order that we sequenced them. */
Xvoid
Xwrite_articles()
X{
X    register ROOT *root;
X
X    for( root = root_root; root; root = root->link ) {
X	write_thread( root->articles );
X    }
X}
X
X/* Recursive routine to write the article in thread order.  We depend on
X** the fact that our first child is the very next article written (if we
X** have children).
X*/
Xvoid
Xwrite_thread( article )
Xregister ARTICLE *article;
X{
X    while( article ) {
X	p_article.num = article->num;
X	p_article.date = article->date;
X	p_article.subject = valid_seq( article->subject );
X	p_article.author = valid_seq( article->author );
X	p_article.flags = (article->flags & ~NEW_ARTICLE);
X	p_article.child_cnt = article->child_cnt;
X	p_article.parent = rel_article( article->parent, article->seq );
X	p_article.siblings = rel_article( article->siblings, article->seq );
X	p_article.root = article->root->seq;
X	write_item( &p_article, sizeof (PACKED_ARTICLE) );
X	if( article->children ) {
X	    write_thread( article->children );
X	}
X	article = article->siblings;
X    }
X}
X
XWORD minus_one = -1;
X
X/* Write the message-id strings:  each domain name (not including the
X** ".unknown." domain) followed by all of its associated unique ids.
X** Then output the article sequence numbers they belong to.  This stuff
X** is last because the newsreader doesn't need to read it.
X*/
Xvoid
Xwrite_ids()
X{
X    register DOMAIN *domain;
X    register ARTICLE *id;
X    register DOMAIN *next_domain;
X    register ARTICLE *next_id;
X
X    string_offset = 0;
X
X    for( domain = &unk_domain; domain; domain = domain->link ) {
X	if( domain != &unk_domain ) {
X	    write_and_free( domain->name );
X	    if( !domain->ids ) {
X		log_error( "** Empty domain name!! **\n" );
X	    }
X	}
X	for( id = domain->ids; id; id = id->id_link ) {
X	    write_and_free( id->id );
X	}
X    }
X    if( string_offset != total.string2 ) {
X	log_error( "** Message-id strings were %ld bytes (%ld) **\n",
X		string_offset, total.string2 );
X    }
X    for( domain = &unk_domain; domain; domain = next_domain ) {
X	next_domain = domain->link;
X	for( id = domain->ids; id; id = next_id ) {
X	    next_id = id->id_link;
X	    write_item( &id->seq, sizeof (WORD) );
X	    free( id );
X	}
X	write_item( &minus_one, sizeof (WORD) );
X	if( domain != &unk_domain ) {
X	    free( domain );
X	}
X    }
X    unk_domain.ids = Nullart;
X    unk_domain.link = Null(DOMAIN*);
X}
X
X/* Free everything that's left to free.
X*/
Xvoid
Xfree_leftovers()
X{
X    register ROOT *root, *next_root;
X    register SUBJECT *subj, *next_subj;
X    register AUTHOR *author, *next_author;
X
X    for( root = root_root; root; root = next_root ) {
X	next_root = root->link;
X	for( subj = root->subjects; subj; subj = next_subj ) {
X	    next_subj = subj->link;
X	    free( subj );
X	}
X	free( root );
X    }
X    for( author = author_root; author; author = next_author ) {
X	next_author = author->link;
X	free( author );
X    }
X    root_root = Null(ROOT*);
X    author_root = Null(AUTHOR*);
X}
X
X/* This routine will check to be sure that the required path exists for
X** the data file, and if not it will attempt to create it.
X*/
Xint
Xensure_path( filename )
Xregister char *filename;
X{
X    int status, pid, w;
X    char tmpbuf[1024];
X#ifdef MAKEDIR
X    register char *cp, *last;
X    register char *tbptr = tmpbuf+5;
X
X    if( !(last = rindex( filename, '/' )) ) {	/* find filename portion */
X	return 1;				/* no path, we're fine */
X    }
X    *last = '\0';				/* truncate path at filename */
X    strcpy( tmpbuf, "mkdir" );
X
X    for( cp = last;; ) {
X	if( stat( filename, &filestat ) >= 0 && (filestat.st_mode & S_IFDIR) ) {
X	    *cp = '/';
X	    break;
X	}
X	if( !(cp = rindex( filename, '/' )) ) {/* find something that exists */
X	    break;
X	}
X	*cp = '\0';
X    }
X    
X    for( cp = filename; cp <= last; cp++ ) {
X	if( !*cp ) {
X	    sprintf( tbptr, " %s", filename );
X	    tbptr += strlen( tbptr );		/* set up for mkdir call */
X	    *cp = '/';
X	}
X    }
X    if( tbptr == tmpbuf+5 ) {
X	return 1;
X    }
X#else
X    sprintf(tmpbuf,"%s %s %d", filexp(DIRMAKER), filename, 1);
X#endif
X
X    if ((pid = vfork()) == 0) {
X	execl(SH, SH, "-c", tmpbuf, Nullch);
X	_exit(127);
X    }
X    while ((w = wait(&status)) != pid && w != -1)
X	;
X    if (w == -1)
X	status = -1;
X    return !status;
X}
X
X/* A simple routine to output some data only if we haven't failed any
X** previous writes.
X*/
Xvoid
Xwrite_item( buff, len )
Xchar *buff;
Xint len;
X{
X    if( !failure ) {
X	if( fwrite( buff, 1, len, fp_out ) < len ) {
X	    failure = 1;
X	}
X    }
X}
END_OF_FILE
  if test 9495 -ne `wc -c <'mt-write.c'`; then
    echo shar: \"'mt-write.c'\" unpacked with wrong size!
  fi
  # end of 'mt-write.c'
fi
if test -f 'rcstuff.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rcstuff.c'\"
else
  echo shar: Extracting \"'rcstuff.c'\" \(25009 characters\)
  sed "s/^X//" >'rcstuff.c' <<'END_OF_FILE'
X/* $Header: rcstuff.c,v 4.3.3.3 91/01/16 03:28:34 davison Trn $
X *
X * $Log:	rcstuff.c,v $
X * Revision 4.3.3.3  91/01/16  03:28:34  davison
X * Integrated rn patches 48-54.  Fixed in_char and verify interaction.
X * 
X * Revision 4.3.3.2  90/08/20  16:47:44  davison
X * Removed ngmax array.
X * 
X * Revision 4.3.3.1  90/06/20  22:39:28  davison
X * Initial Trn Release
X * 
X * Revision 4.3.2.12  90/12/12  03:05:15  sob
X * Adds "N" command to compliment the "Y" command when prompted for adding
X * new newsgroups.
X * 
X * Revision 4.3.2.11  90/11/22  17:49:57  sob
X * Fixed "Y" for regular rn users (non-NNTP).
X * 
X * Revision 4.3.2.10  90/11/22  13:53:26  sob
X * Made changes to keep more preprocessors happy.
X * 
X * Revision 4.3.2.9  90/11/06  01:04:39  sob
X * Updated help messages to include new Y command when adding new newsgroups.
X * 
X * Revision 4.3.2.8  90/10/30  23:26:43  sob
X * Changes to restore .newsrc when exiting rn and diskspace runs out while
X * updating .newsrc.
X * 
X * Revision 4.3.2.7  90/10/30  22:47:49  sob
X * A bit of cleanup.
X * 
X * Revision 4.3.2.6  90/09/04  23:36:32  sob
X * Changed "add" to "subscribe" to actually reflect what is being done.
X * 
X * Revision 4.3.2.5  90/05/04  00:44:07  sob
X * Fixes to add_newsgroup() from lar@usl.edu.
X * 
X * Revision 4.3.2.4  90/04/23  00:25:45  sob
X * Changed atoi to atol.
X * 
X * Revision 4.3.2.3  89/12/20  23:25:04  sob
X * Changed the maximum lenght of a newsgroup name from 20 to 40 characters.
X * 
X * Revision 4.3.2.2  89/11/26  18:22:26  sob
X * Added changes to addnewgroup() to cause rn to ask once and only once
X * to add a new group to .newsrc. 
X * Fix provided by Fletcher Mattox <fletcher@cs.utexas.edu>
X * 
X * Revision 4.3.2.1  89/11/06  00:58:29  sob
X * Added RRN support from NNTP 1.5
X * 
X * Revision 4.3.1.5  86/07/24  14:09:10  lwall
X * Removed check for spool directory existence in get_ng.
X * 
X * Revision 4.3.1.4  85/09/10  11:04:44  lwall
X * Improved %m in in_char().
X * 
X * Revision 4.3.1.3  85/05/29  09:13:25  lwall
X * %d that should be %ld.
X * 
X * Revision 4.3.1.2  85/05/17  11:40:08  lwall
X * Sped up "rn -c" by not mallocing unnecessarily.
X * 
X * Revision 4.3.1.1  85/05/10  11:37:18  lwall
X * Branch for patches.
X * 
X * Revision 4.3  85/05/01  11:45:56  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "ngdata.h"
X#include "term.h"
X#include "final.h"
X#include "rn.h"
X#include "intrp.h"
X#include "only.h"
X#include "rcln.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X#include "INTERN.h"
X#include "rcstuff.h"
X
Xchar *rcname INIT(Nullch);		/* path name of .newsrc file */
Xchar *rctname INIT(Nullch);		/* path name of temp .newsrc file */
Xchar *rcbname INIT(Nullch);		/* path name of backup .newsrc file */
Xchar *softname INIT(Nullch);		/* path name of .rnsoft file */
XFILE *rcfp INIT(Nullfp);			/* .newsrc file pointer */
X
X#ifdef HASHNG
X    short hashtbl[HASHSIZ];
X#endif
X
Xbool
Xrcstuff_init()
X{
X    register NG_NUM newng;
X    register char *s;
X    register int i;
X    register bool foundany = FALSE;
X    char *some_buf;
X    long length;
X#ifdef SERVER
X    char *cp;
X#endif /* SERVER */
X
X#ifdef HASHNG
X    for (i=0; i<HASHSIZ; i++)
X	hashtbl[i] = -1;
X#endif
X
X    /* make filenames */
X
X#ifdef SERVER
X
X    if (cp = getenv("NEWSRC"))
X	rcname = savestr(filexp(cp));
X    else
X	rcname = savestr(filexp(RCNAME));
X
X#else /* not SERVER */
X
X    rcname = savestr(filexp(RCNAME));
X
X#endif /* SERVER */
X
X    rctname = savestr(filexp(RCTNAME));
X    rcbname = savestr(filexp(RCBNAME));
X    softname = savestr(filexp(SOFTNAME));
X    
X    /* make sure the .newsrc file exists */
X
X    newsrc_check();
X
X    /* open .rnsoft file containing soft ptrs to active file */
X
X    tmpfp = fopen(softname,"r");
X    if (tmpfp == Nullfp)
X	writesoft = TRUE;
X
X    /* read in the .newsrc file */
X
X    for (nextrcline = 0;
X	(some_buf = get_a_line(buf,LBUFLEN,rcfp)) != Nullch;
X	nextrcline++) {
X					/* for each line in .newsrc */
X	char tmpbuf[10];
X
X	newng = nextrcline;		/* get it into a register */
X	length = len_last_line_got;	/* side effect of get_a_line */
X	if (length <= 1) {		/* only a newline??? */
X	    nextrcline--;		/* compensate for loop increment */
X	    continue;
X	}
X	if (newng >= MAXRCLINE) {	/* check for overflow */
X	    fputs("Too many lines in .newsrc\n",stdout) FLUSH;
X	    finalize(1);
X	}
X	if (tmpfp != Nullfp && fgets(tmpbuf,10,tmpfp) != Nullch)
X	    softptr[newng] = atol(tmpbuf);
X	else
X	    softptr[newng] = 0;
X	some_buf[--length] = '\0';	/* wipe out newline */
X	if (checkflag)			/* no extra mallocs for -c */
X	    rcline[newng] = some_buf;
X	else if (some_buf == buf) {
X	    rcline[newng] = savestr(some_buf);
X					/* make a semipermanent copy */
X	}
X	else {
X	    /*NOSTRICT*/
X#ifndef lint
X	    some_buf = saferealloc(some_buf,(MEM_SIZE)(length+1));
X#endif /* lint */
X	    rcline[newng] = some_buf;
X	}
X#ifdef NOTDEF
X	if (strnEQ(some_buf,"to.",3)) {	/* is this a non-newsgroup? */
X	    nextrcline--;		/* destroy this line */
X	    continue;
X	}
X#endif
X	if (*some_buf == ' ' ||
X	  *some_buf == '\t' ||
X	  strnEQ(some_buf,"options",7)) {		/* non-useful line? */
X	    toread[newng] = TR_JUNK;
X	    rcchar[newng] = ' ';
X	    rcnums[newng] = 0;
X	    continue;
X	}
X	for (s = rcline[newng]; *s && *s != ':' && *s != NEGCHAR; s++) ;
X	if (!*s && !checkflag) {
X#ifndef lint
X	    rcline[newng] = saferealloc(rcline[newng],(MEM_SIZE)length+2);
X#endif /* lint */
X	    s = rcline[newng] + length;
X	    *s = ':';
X	    *(s+1) = '\0';
X	}
X	rcchar[newng] = *s;		/* salt away the : or ! */
X	rcnums[newng] = (char)(s - rcline[newng]); 
X	rcnums[newng]++;		/* remember where it was */
X	*s = '\0';			/* null terminate newsgroup name */
X#ifdef HASHNG
X	if (!checkflag)
X	    sethash(newng);
X#endif
X	if (rcchar[newng] == NEGCHAR) {
X	    toread[newng] = TR_UNSUB;
X	    continue;
X	}
X
X	/* now find out how much there is to read */
X
X	if (!inlist(buf) || (suppress_cn && foundany && !paranoid))
X	    toread[newng] = TR_NONE;	/* no need to calculate now */
X	else
X	    set_toread(newng);
X#ifdef VERBOSE
X	if (!checkflag && softmisses == 1) {
X	    softmisses++;		/* lie a little */
X	    fputs("(Revising soft pointers--be patient.)\n",stdout) FLUSH;
X	}
X#endif
X	if (toread[newng] > TR_NONE) {	/* anything unread? */
X	    if (!foundany) {
X		starthere = newng;
X		foundany = TRUE;	/* remember that fact*/
X	    }
X	    if (suppress_cn) {		/* if no listing desired */
X		if (checkflag) {	/* if that is all they wanted */
X		    finalize(1);	/* then bomb out */
X		}
X	    }
X	    else {
X#ifdef VERBOSE
X		IF(verbose)
X		    printf("Unread news in %-40s %5ld article%s\n",
X			rcline[newng],(long)toread[newng],
X			toread[newng]==TR_ONE ? nullstr : "s") FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    printf("%s: %ld article%s\n",
X			rcline[newng],(long)toread[newng],
X			toread[newng]==TR_ONE ? nullstr : "s") FLUSH;
X#endif
X		if (int_count) {
X		    countdown = 1;
X		    int_count = 0;
X		}
X		if (countdown) {
X		    if (! --countdown) {
X			fputs("etc.\n",stdout) FLUSH;
X			if (checkflag)
X			    finalize(1);
X			suppress_cn = TRUE;
X		    }
X		}
X	    }
X	}
X    }
X    fclose(rcfp);			/* close .newsrc */
X    if (tmpfp != Nullfp)
X	fclose(tmpfp);			/* close .rnsoft */
X    if (checkflag) {			/* were we just checking? */
X	finalize(foundany);		/* tell them what we found */
X    }
X    if (paranoid)
X	cleanup_rc();
X
X#ifdef DEBUGGING
X    if (debug & DEB_HASH) {
X	page_init();
X	for (i=0; i<HASHSIZ; i++) {
X	    sprintf(buf,"%d	%d",i,hashtbl[i]);
X	    print_lines(buf,NOMARKING);
X	}
X    }
X#endif
X
X    return foundany;
X}
X
X/* try to find or add an explicitly specified newsgroup */
X/* returns TRUE if found or added, FALSE if not. */
X/* assumes that we are chdir'ed to SPOOL */
X
X#define ADDNEW_SUB 1
X#define ADDNEW_UNSUB 2
X
Xstatic int addnewbydefault = 0;
X
Xbool
Xget_ng(what,do_reloc)
Xchar *what;
Xbool do_reloc;
X{
X    char *ntoforget;
X    char promptbuf[128];
X#ifdef SERVER
X    char ser_line[256];
X#endif /* SERVER */
X
X#ifdef VERBOSE
X    IF(verbose)
X	ntoforget = "Type n to forget about this newsgroup.\n";
X    ELSE
X#endif
X#ifdef TERSE
X	ntoforget = "n to forget it.\n";
X#endif
X    if (index(what,'/')) {
X	dingaling();
X	printf("\nBad newsgroup name.\n") FLUSH;
X	return FALSE;
X    }
X    set_ngname(what);
X    ng = find_ng(ngname);
X    if (ng == nextrcline) {		/* not in .newsrc? */
X
X#ifdef SERVER
X	sprintf(ser_line, "GROUP %s", ngname);
X	put_server(ser_line);
X	if (get_server(ser_line, sizeof(ser_line)) < 0) {
X	    fprintf(stderr, "rrn: Unexpected close of server socket.\n");
X	    finalize(1);
X	}
X	if (*ser_line != CHAR_OK) {
X	    if (atoi(ser_line) != ERR_NOGROUP) {
X		fprintf(stderr, "Server response to GROUP %s:\n%s\n",
X		    ngname, ser_line);
X	    }
X#else /* not SERVER */
X
X	if ((softptr[ng] = findact(buf,ngname,strlen(ngname),0L)) < 0 ) {
X
X#endif /* SERVER */
X
X	    dingaling();
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("\nNewsgroup %s does not exist!\n",ngname) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		printf("\nNo %s!\n",ngname) FLUSH;
X#endif
X	    sleep(2);
X	    return FALSE;
X	}
X	if (addnewbydefault) {
X		printf("(Adding %s to end of your .newsrc %ssubscribed)\n",
X		       ngname, (addnewbydefault == ADDNEW_SUB) ? "" : "un");
X		if (addnewbydefault == ADDNEW_SUB)
X		     ng = add_newsgroup(ngname, ':');
X		else
X		     ng = add_newsgroup(ngname, '!');
X	        do_reloc = FALSE;
X	} else {
X#ifdef VERBOSE
X	IF(verbose)
X	    sprintf(promptbuf,"\nNewsgroup %s not in .newsrc--subscribe? [ynYN] ",ngname);
X	ELSE
X#endif
X#ifdef TERSE
X	    sprintf(promptbuf,"\nSubscribe %s? [ynY] ",ngname);
X#endif
Xreask_add:
X	in_char(promptbuf,'A');
X	setdef(buf,"y");
X#ifdef VERIFY
X	printcmd();
X#endif
X	putchar('\n') FLUSH;
X	if (*buf == 'h') {
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("Type y or SP to add %s to your .newsrc.\nType Y to add all new groups to the end of your .newsrc.\nType N to add all new groups to the end of your .newsrc unsubscribed.\n", ngname)
X		  FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		fputs("y or SP to add, Y to add all new groups, N to add all new groups unsubscribed\n",stdout) FLUSH;
X#endif
X	    fputs(ntoforget,stdout) FLUSH;
X	    goto reask_add;
X	}
X	else if (*buf == 'n' || *buf == 'q') {
X	    ng = add_newsgroup(ngname, '!');
X	    return FALSE;
X	}
X	else if (*buf == 'y') {
X	    ng = add_newsgroup(ngname, ':');
X	    do_reloc = FALSE;
X	}
X	else if (*buf == 'Y') {
X	    fputs(
X    "(I'll add all new newsgroups (subscribed) to the end of your .newsrc.)\n",
X		  stdout);
X	    addnewbydefault = ADDNEW_SUB;
X	    printf("(Adding %s to end of your .newsrc subscribed)\n", ngname);
X	    ng = add_newsgroup(ngname, ':');
X	    do_reloc = FALSE;
X	}
X	else if (*buf == 'N') {
X	    fputs(
X  "(I'll add all new newsgroups (unsubscribed) to the end of your .newsrc.)\n",
X		  stdout);
X	    addnewbydefault = ADDNEW_UNSUB;
X	    printf("(Adding %s to end of your .newsrc unsubscribed)\n", ngname);
X	    ng = add_newsgroup(ngname, '!');
X	    do_reloc = FALSE;
X	}
X	else {
X	    fputs(hforhelp,stdout) FLUSH;
X	    settle_down();
X	    goto reask_add;
X	}
X      }
X    }
X    else if (rcchar[ng] == NEGCHAR) {	/* unsubscribed? */
X#ifdef VERBOSE
X	IF(verbose)
X	    sprintf(promptbuf,
X"\nNewsgroup %s is currently unsubscribed to--resubscribe? [yn] ",ngname)
X  FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    sprintf(promptbuf,"\n%s unsubscribed--resubscribe? [yn] ",ngname)
X	      FLUSH;
X#endif
Xreask_unsub:
X	in_char(promptbuf,'R');
X	setdef(buf,"y");
X#ifdef VERIFY
X	printcmd();
X#endif
X	putchar('\n') FLUSH;
X	if (*buf == 'h') {
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("Type y or SP to resubscribe to %s.\n", ngname) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		fputs("y or SP to resubscribe.\n",stdout) FLUSH;
X#endif
X	    fputs(ntoforget,stdout) FLUSH;
X	    goto reask_unsub;
X	}
X	else if (*buf == 'n' || *buf == 'q') {
X	    return FALSE;
X	}
X	else if (*buf == 'y') {
X	    rcchar[ng] = ':';
X	}
X	else {
X	    fputs(hforhelp,stdout) FLUSH;
X	    settle_down();
X	    goto reask_unsub;
X	}
X    }
X
X    /* now calculate how many unread articles in newsgroup */
X
X    set_toread(ng);
X#ifdef RELOCATE
X    if (do_reloc)
X	ng = relocate_newsgroup(ng,-1);
X#endif
X    return toread[ng] >= TR_NONE;
X}
X
X/* add a newsgroup to the .newsrc file (eventually) */
X
XNG_NUM
Xadd_newsgroup(ngn, c)
Xchar *ngn, c;
X{
X    register NG_NUM newng = nextrcline++;
X					/* increment max rcline index */
X    
X    rcnums[newng] = strlen(ngn) + 1;
X    rcline[newng] = safemalloc((MEM_SIZE)(rcnums[newng] + 1));
X    strcpy(rcline[newng],ngn);		/* and copy over the name */
X    *(rcline[newng] + rcnums[newng]) = '\0';
X    rcchar[newng] = c;			/* subscribe or unsubscribe */
X    toread[newng] = TR_NONE;	/* just for prettiness */
X#ifdef HASHNG
X    sethash(newng);			/* so we can find it again */
X#endif
X#ifdef RELOCATE
X    return c=='!' ? newng : relocate_newsgroup(newng,-1);
X#else
X    return newng;
X#endif
X}
X
X#ifdef RELOCATE
XNG_NUM
Xrelocate_newsgroup(ngx,newng)
XNG_NUM ngx;
XNG_NUM newng;
X{
X    char *dflt = (ngx!=current_ng ? "$^.L" : "$^L");
X    char *tmprcline;
X    ART_UNREAD tmptoread;
X    char tmprcchar;
X    char tmprcnums;
X    ACT_POS tmpsoftptr;
X    register NG_NUM i;
X#if defined(DEBUGGING) && !defined(USETHREADS)
X    ART_NUM tmpngmax;
X#endif
X#ifdef CACHEFIRST
X    ART_NUM tmpabs1st;
X#endif
X    
X    starthere = 0;                      /* Disable this optimization */
X    writesoft = TRUE;			/* Update soft pointer file */
X    if (ngx < nextrcline-1) {
X#ifdef HASHNG
X	for (i=0; i<HASHSIZ; i++) {
X	    if (hashtbl[i] > ngx)
X		--hashtbl[i];
X	    else if (hashtbl[i] == ngx)
X		hashtbl[i] = nextrcline-1;
X	}
X#endif
X	tmprcline = rcline[ngx];
X	tmptoread = toread[ngx];
X	tmprcchar = rcchar[ngx];
X	tmprcnums = rcnums[ngx];
X	tmpsoftptr = softptr[ngx];
X#if defined(DEBUGGING) && !defined(USETHREADS)
X	tmpngmax = ngmax[ngx];
X#endif
X#ifdef CACHEFIRST
X	tmpabs1st = abs1st[ngx];
X#endif
X	for (i=ngx+1; i<nextrcline; i++) {
X	    rcline[i-1] = rcline[i];
X	    toread[i-1] = toread[i];
X	    rcchar[i-1] = rcchar[i];
X	    rcnums[i-1] = rcnums[i];
X	    softptr[i-1] = softptr[i];
X#if defined(DEBUGGING) && !defined(USETHREADS)
X	    ngmax[i-1] = ngmax[i];
X#endif
X#ifdef CACHEFIRST
X	    abs1st[i-1] = abs1st[i];
X#endif
X	}
X	rcline[nextrcline-1] = tmprcline;
X	toread[nextrcline-1] = tmptoread;
X	rcchar[nextrcline-1] = tmprcchar;
X	rcnums[nextrcline-1] = tmprcnums;
X	softptr[nextrcline-1] = tmpsoftptr;
X#if defined(DEBUGGING) && !defined(USETHREADS)
X	ngmax[nextrcline-1] = tmpngmax;
X#endif
X#ifdef CACHEFIRST
X	abs1st[nextrcline-1] = tmpabs1st;
X#endif
X    }
X    if (current_ng > ngx)
X	current_ng--;
X    if (newng < 0) {
X      reask_reloc:
X	unflush_output();		/* disable any ^O in effect */
X	if (addnewbydefault) {
X	    buf[0] = '$';
X	    buf[1] = '\0';
X	} else {
X#ifdef VERBOSE
X	IF(verbose)
X	    printf("\nPut newsgroup where? [%s] ", dflt);
X	ELSE
X#endif
X#ifdef TERSE
X	    printf("\nPut where? [%s] ", dflt);
X#endif
X	fflush(stdout);
X      reinp_reloc:
X	eat_typeahead();
X	getcmd(buf);
X	}
X	if (errno || *buf == '\f') {
X			    /* if return from stop signal */
X	    goto reask_reloc;	/* give them a prompt again */
X	}
X	setdef(buf,dflt);
X#ifdef VERIFY
X	printcmd();
X#endif
X	if (*buf == 'h') {
X#ifdef VERBOSE
X	    IF(verbose) {
X		printf("\n\n\
XType ^ to put the newsgroup first (position 0).\n\
XType $ to put the newsgroup last (position %d).\n", nextrcline-1);
X		printf("\
XType . to put it before the current newsgroup (position %d).\n", current_ng);
X		printf("\
XType -newsgroup name to put it before that newsgroup.\n\
XType +newsgroup name to put it after that newsgroup.\n\
XType a number between 0 and %d to put it at that position.\n", nextrcline-1);
X		printf("\
XType L for a listing of newsgroups and their positions.\n") FLUSH;
X	    }
X	    ELSE
X#endif
X#ifdef TERSE
X	    {
X		printf("\n\n\
X^ to put newsgroup first (pos 0).\n\
X$ to put last (pos %d).\n", nextrcline-1);
X		printf("\
X. to put before current newsgroup (pos %d).\n", current_ng);
X		printf("\
X-newsgroup to put before newsgroup.\n\
X+newsgroup to put after.\n\
Xnumber in 0-%d to put at that pos.\n", nextrcline-1);
X		printf("\
XL for list of .newsrc.\n") FLUSH;
X	    }
X#endif
X	    goto reask_reloc;
X	}
X	else if (*buf == 'L') {
X	    putchar('\n') FLUSH;
X	    list_newsgroups();
X	    goto reask_reloc;
X	}
X	else if (isdigit(*buf)) {
X	    if (!finish_command(TRUE))	/* get rest of command */
X		goto reinp_reloc;
X	    newng = atol(buf);
X	    if (newng < 0)
X		newng = 0;
X	    if (newng >= nextrcline)
X		return nextrcline-1;
X	}
X	else if (*buf == '^') {
X	    putchar('\n') FLUSH;
X	    newng = 0;
X	}
X	else if (*buf == '$') {
X	    if (! addnewbydefault) putchar('\n') FLUSH;
X	    return nextrcline-1;
X	}
X	else if (*buf == '.') {
X	    putchar('\n') FLUSH;
X	    newng = current_ng;
X	}
X	else if (*buf == '-' || *buf == '+') {
X	    if (!finish_command(TRUE))	/* get rest of command */
X		goto reinp_reloc;
X	    newng = find_ng(buf+1);
X	    if (newng == nextrcline) {
X		fputs("Not found.",stdout) FLUSH;
X		goto reask_reloc;
X	    }
X	    if (*buf == '+')
X		newng++;
X	}
X	else {
X	    printf("\n%s",hforhelp) FLUSH;
X	    settle_down();
X	    goto reask_reloc;
X	}
X    }
X    if (newng < nextrcline-1) {
X#ifdef HASHNG
X	for (i=0; i<HASHSIZ; i++) {
X	    if (hashtbl[i] == nextrcline-1)
X		hashtbl[i] = newng;
X	    else if (hashtbl[i] >= newng)
X		++hashtbl[i];
X	}
X#endif
X	tmprcline = rcline[nextrcline-1];
X	tmptoread = toread[nextrcline-1];
X	tmprcchar = rcchar[nextrcline-1];
X	tmprcnums = rcnums[nextrcline-1];
X	tmpsoftptr = softptr[nextrcline-1];
X#if defined(DEBUGGING) && !defined(USETHREADS)
X	tmpngmax = ngmax[nextrcline-1];
X#endif
X#ifdef CACHEFIRST
X	tmpabs1st = abs1st[nextrcline-1];
X#endif
X	for (i=nextrcline-2; i>=newng; i--) {
X	    rcline[i+1] = rcline[i];
X	    toread[i+1] = toread[i];
X	    rcchar[i+1] = rcchar[i];
X	    rcnums[i+1] = rcnums[i];
X	    softptr[i+1] = softptr[i];
X#if defined(DEBUGGING) && !defined(USETHREADS)
X	    ngmax[i+1] = ngmax[i];
X#endif
X#ifdef CACHEFIRST
X	    abs1st[i+1] = abs1st[i];
X#endif
X	}
X	rcline[newng] = tmprcline;
X	toread[newng] = tmptoread;
X	rcchar[newng] = tmprcchar;
X	rcnums[newng] = tmprcnums;
X	softptr[newng] = tmpsoftptr;
X#if defined(DEBUGGING) && !defined(USETHREADS)
X	ngmax[newng] = tmpngmax;
X#endif
X#ifdef CACHEFIRST
X	abs1st[newng] = tmpabs1st;
X#endif
X    }
X    if (current_ng >= newng)
X	current_ng++;
X    return newng;
X}
X#endif
X
X/* List out the newsrc with annotations */
X
Xvoid
Xlist_newsgroups()
X{
X    register NG_NUM i;
X    char tmpbuf[2048];
X    static char *status[] = {"(READ)","(UNSUB)","(BOGUS)","(JUNK)"};
X    int cmd;
X
X    page_init();
X    print_lines("\
X  #  Status  Newsgroup\n\
X",STANDOUT);
X    for (i=0; i<nextrcline && !int_count; i++) {
X	if (toread[i] >= 0)
X	    set_toread(i);
X	*(rcline[i] + rcnums[i] - 1) = rcchar[i];
X	if (toread[i] > 0)
X	    sprintf(tmpbuf,"%3d %6ld   ",i,(long)toread[i]);
X	else
X	    sprintf(tmpbuf,"%3d %7s  ",i,status[-toread[i]]);
X	safecpy(tmpbuf+13,rcline[i],2034);
X	*(rcline[i] + rcnums[i] - 1) = '\0';
X	if (cmd = print_lines(tmpbuf,NOMARKING)) {
X	    if (cmd > 0)
X		pushchar(cmd);
X	    break;
X	}
X    }
X    int_count = 0;
X}
X
X/* find a newsgroup in .newsrc */
X
XNG_NUM
Xfind_ng(ngnam)
Xchar *ngnam;
X{
X    register NG_NUM ngnum;
X#ifdef HASHNG
X    register int hashix = hash(ngnam);
X    register int incr = 1;
X
X    while ((ngnum = hashtbl[hashix]) >= 0) {
X	if (strEQ(rcline[ngnum], ngnam) && toread[ngnum] >= TR_UNSUB)
X	    return ngnum;
X	hashix = (hashix + incr) % HASHSIZ;
X	incr += 2;			/* offsets from original are in n*2 */
X    }
X    return nextrcline;			/* = notfound */
X
X#else /* just do linear search */
X
X    for (ngnum = 0; ngnum < nextrcline; ngnum++) {
X	if (strEQ(rcline[ngnum],ngnam))
X	    break;
X    }
X    return ngnum;
X#endif
X}
X
Xvoid
Xcleanup_rc()
X{
X    register NG_NUM ngx;
X    register NG_NUM bogosity = 0;
X
X#ifdef VERBOSE
X    IF(verbose)
X	fputs("Checking out your .newsrc--hang on a second...\n",stdout)
X	  FLUSH;
X    ELSE
X#endif
X#ifdef TERSE
X	fputs("Checking .newsrc--hang on...\n",stdout) FLUSH;
X#endif
X    for (ngx = 0; ngx < nextrcline; ngx++) {
X	if (toread[ngx] >= TR_UNSUB) {
X	    set_toread(ngx);		/* this may reset newsgroup */
X					/* or declare it bogus */
X	}
X	if (toread[ngx] == TR_BOGUS)
X	    bogosity++;
X    }
X    for (ngx = nextrcline-1; ngx >= 0 && toread[ngx] == TR_BOGUS; ngx--)
X	bogosity--;			/* discount already moved ones */
X    if (nextrcline > 5 && bogosity > nextrcline / 2) {
X	fputs(
X"It looks like the active file is messed up.  Contact your news administrator,\n\
X",stdout);
X	fputs(
X"leave the \"bogus\" groups alone, and they may come back to normal.  Maybe.\n\
X",stdout) FLUSH;
X    }
X#ifdef RELOCATE
X    else if (bogosity) {
X#ifdef VERBOSE
X	IF(verbose)
X	    fputs("Moving bogus newsgroups to the end of your .newsrc.\n",
X		stdout) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    fputs("Moving boguses to the end.\n",stdout) FLUSH;
X#endif
X	for (; ngx >= 0; ngx--) {
X	    if (toread[ngx] == TR_BOGUS)
X		relocate_newsgroup(ngx,nextrcline-1);
X	}
X#ifdef DELBOGUS
Xreask_bogus:
X	in_char("Delete bogus newsgroups? [ny] ", 'D');
X	setdef(buf,"n");
X#ifdef VERIFY
X	printcmd();
X#endif
X	putchar('\n') FLUSH;
X	if (*buf == 'h') {
X#ifdef VERBOSE
X	    IF(verbose)
X		fputs("\
XType y to delete bogus newsgroups.\n\
XType n or SP to leave them at the end in case they return.\n\
X",stdout) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		fputs("y to delete, n to keep\n",stdout) FLUSH;
X#endif
X	    goto reask_bogus;
X	}
X	else if (*buf == 'n' || *buf == 'q')
X	    ;
X	else if (*buf == 'y') {
X	    while (toread[nextrcline-1] == TR_BOGUS && nextrcline > 0)
X		--nextrcline;		/* real tough, huh? */
X	}
X	else {
X	    fputs(hforhelp,stdout) FLUSH;
X	    settle_down();
X	    goto reask_bogus;
X	}
X#endif
X    }
X#else
X#ifdef VERBOSE
X    IF(verbose)
X	fputs("You should edit bogus newsgroups out of your .newsrc.\n",
X	    stdout) FLUSH;
X    ELSE
X#endif
X#ifdef TERSE
X	fputs("Edit boguses from .newsrc.\n",stdout) FLUSH;
X#endif
X#endif
X    paranoid = FALSE;
X}
X
X#ifdef HASHNG
X/* make an entry in the hash table for the current newsgroup */
X
Xvoid
Xsethash(thisng)
XNG_NUM thisng;
X{
X    register int hashix = hash(rcline[thisng]);
X    register int incr = 1;
X#ifdef DEBUGGING
X    static int hashhits = 0, hashtries = 0;
X#endif
X
X#ifdef DEBUGGING
X    hashtries++;
X#endif
X    while (hashtbl[hashix] >= 0) {
X#ifdef DEBUGGING
X	hashhits++;
X	if (debug & DEB_HASH) {
X	    printf("  Hash hits: %d / %d\n",hashhits, hashtries) FLUSH;
X	}
X	hashtries++;
X#endif
X	hashix = (hashix + incr) % HASHSIZ;
X	incr += 2;			/* offsets from original are in n*2 */
X    }
X    hashtbl[hashix] = thisng;
X}
X
Xshort prime[] = {1,2,-3,-5,7,11,-13,-17,19,23,-29,-31,37,41,-43,-47,53,57,-59,
X    -61,67,71,-73,-79,83,89,-97,-101,1,1,1,1,1,1,1,1,1,1,1,1};
X
Xint
Xhash(ngnam)
Xregister char *ngnam;
X{
X    register int i = 0;
X    register int ch;
X    register int sum = 0;
X#ifdef DEBUGGING
X    char *ngn = ngnam;
X#endif
X
X    while (ch = *ngnam++) {
X	sum += (ch + i) * prime[i];   /* gives ~ 10% hits at 25% full */
X	i++;
X    }
X#ifdef DEBUGGING
X    if (debug & DEB_HASH)
X	printf("hash(%s) => %d => %d\n",ngn, sum, (sum<0?-sum:sum)%HASHSIZ)
X	  FLUSH;
X#endif
X    if (sum < 0)
X	sum = -sum;
X    return sum % HASHSIZ;
X}
X
X#endif
X
Xvoid
Xnewsrc_check()
X{
X    rcfp = fopen(rcname,"r");		/* open it */
X    if (rcfp == Nullfp) {			/* not there? */
X#ifdef VERBOSE
X	IF(verbose)
X	    fputs("\nTrying to set up a .newsrc file--running newsetup...\n\n\
X",stdout) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    fputs("Setting up .newsrc...\n",stdout) FLUSH;
X#endif
X	if (doshell(sh,filexp(NEWSETUP)) ||
X	    (rcfp = fopen(rcname,"r")) == Nullfp) {
X#ifdef VERBOSE
X	    IF(verbose)
X		fputs("\nCan't create a .newsrc--you must do it yourself.\n\
X",stdout) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		fputs("(Fatal)\n",stdout) FLUSH;
X#endif
X	    finalize(1);
X	}
X    }
X    else {
X	UNLINK(rcbname);		/* unlink backup file name */
X	link(rcname,rcbname);		/* and backup current name */
X    }
X}
X
X/* write out the (presumably) revised .newsrc */
X
Xvoid
Xwrite_rc()
X{
X    register NG_NUM tmpng;
X    register char *delim;
X
X    rcfp = fopen(rctname, "w");		/* open .newsrc */
X    if (rcfp == Nullfp) {
X	printf("Can't recreate .newsrc\n") FLUSH;
X	finalize(1);
X    }
X
X    /* write out each line*/
X
X    for (tmpng = 0; tmpng < nextrcline; tmpng++) {
X	if (rcnums[tmpng]) {
X	    delim = rcline[tmpng] + rcnums[tmpng] - 1;
X	    *delim = rcchar[tmpng];
X	}
X	else
X	    delim = Nullch;
X#ifdef DEBUGGING
X	if (debug & DEB_NEWSRC_LINE)
X	    printf("%s\n",rcline[tmpng]) FLUSH;
X#endif
X	if (fprintf(rcfp,"%s\n",rcline[tmpng]) < 0){
X			printf("Can't recreate .newsrc\n") FLUSH;
X			fclose(rcfp);			/* close .newsrc */
X			UNLINK(rctname);
X			finalize(1);
X    		}
X
X			;
X	if (delim)
X	    *delim = '\0';		/* might still need this line */
X    }
X
X    fclose(rcfp);			/* close .newsrc */
X    UNLINK(rcname);
X    link(rctname,rcname);
X    UNLINK(rctname);
X
X    if (writesoft) {
X	tmpfp = fopen(filexp(softname), "w");	/* open .rnsoft */
X	if (tmpfp == Nullfp) {
X	    printf(cantcreate,filexp(softname)) FLUSH;
X	    return;
X	}
X	for (tmpng = 0; tmpng < nextrcline; tmpng++) {
X	    fprintf(tmpfp,"%ld\n",(long)softptr[tmpng]);
X	}
X	fclose(tmpfp);
X    }
X}
X
Xvoid
Xget_old_rc()
X{
X    UNLINK(rctname);
X#ifdef RENAME
X    rename(rcname,rctname);
X    rename(rcbname,rcname);
X#else
X    link(rcname,rctname);
X    UNLINK(rcname);
X    link(rcbname,rcname);
X    UNLINK(rcbname);
X#endif
X}
END_OF_FILE
  if test 25009 -ne `wc -c <'rcstuff.c'`; then
    echo shar: \"'rcstuff.c'\" unpacked with wrong size!
  fi
  # end of 'rcstuff.c'
fi
if test -f 'term.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'term.c'\"
else
  echo shar: Extracting \"'term.c'\" \(25986 characters\)
  sed "s/^X//" >'term.c' <<'END_OF_FILE'
X/* $Header: term.c,v 4.3.3.2 91/01/16 03:38:36 davison Trn $
X *
X * $Log:	term.c,v $
X * Revision 4.3.3.2  91/01/16  03:38:36  davison
X * Integrated rn patches 48-54.  Revised 8-bit character support.
X * 
X * Revision 4.3.3.1  90/07/28  18:09:09  davison
X * Initial Trn Release
X * 
X * Revision 4.3.2.13  90/12/12  03:03:28  sob
X * Lost a closing paren in circfill()
X * 
X * Revision 4.3.2.12  90/12/10  01:33:54  sob
X * First attempts to make rn "8 bit clean"
X * 
X * Revision 4.3.2.11  90/11/22  13:34:06  sob
X * Added a change to circfill to make it work with POSIX-compliant OSes.
X * 
X * Revision 4.3.2.10  90/11/05  23:41:29  sob
X * Now it's gone.
X * 
X * Revision 4.3.2.9  90/11/05  23:30:07  sob
X * moved the winsize struct in anticipation of removing it.
X * 
X * Revision 4.3.2.8  90/10/01  01:43:59  sob
X * Fixed syntax error pointed out by stealth@m-net.ann-arbor.mi.us.
X * 
X * Revision 4.3.2.7  90/04/21  16:54:29  sob
X * Installed patches provided by SCO for SCO Xenix
X * 
X * Revision 4.3.2.6  90/04/13  23:48:17  sob
X * Modifications provided by Gene Hackney for 3b2.
X * 
X * Revision 4.3.2.5  90/04/06  20:35:08  sob
X * Added fixes for SCO Xenix sent by ronald@robobar.co.uk.
X * 
X * Revision 4.3.2.4  90/03/22  23:05:38  sob
X * Fixes provided by Wayne Davison <drivax!davison>
X * 
X * Revision 4.3.2.3  89/11/28  01:51:58  sob
X * Now handles SIGWINCH correctly.
X * 
X * Revision 4.3.2.2  89/11/27  01:31:34  sob
X * Altered NNTP code per ideas suggested by Bela Lubkin
X * <filbo@gorn.santa-cruz.ca.us>
X * 
X * Revision 4.3.2.1  89/11/06  01:02:12  sob
X * Added RRN support from NNTP 1.5
X * 
X * Revision 4.3.1.3  85/09/10  11:05:23  lwall
X * Improved %m in in_char().
X * 
X * Revision 4.3.1.2  85/05/16  16:45:35  lwall
X * Forced \r to \n on input.
X * Fix for terminfo braindamage regarding bc emulation.
X * 
X * Revision 4.3.1.1  85/05/10  11:41:03  lwall
X * Branch for patches.
X * 
X * Revision 4.3  85/05/01  11:51:10  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "final.h"
X#include "help.h"
X#include "cheat.h"
X#include "intrp.h"
X#include "INTERN.h"
X#include "term.h"
X
Xchar ERASECH;		/* rubout character */
Xchar KILLCH;		/* line delete character */
Xchar tcarea[TCSIZE];	/* area for "compiled" termcap strings */
X
X#ifdef USETHREADS
Xint upcost;
X#endif
X
X/* guarantee capability pointer != Nullch */
X/* (I believe terminfo will ignore the &tmpaddr argument.) */
X
X#define Tgetstr(key) ((tmpstr = tgetstr(key,&tmpaddr)) ? tmpstr : nullstr)
X
X#ifdef PUSHBACK
Xstruct keymap {
X    char km_type[128];
X    union km_union {
X	struct keymap *km_km;
X	char *km_str;
X    } km_ptr[128];
X};
X
X#define KM_NOTHIN 0
X#define KM_STRING 1
X#define KM_KEYMAP 2
X#define KM_BOGUS 3
X
X#define KM_TMASK 3
X#define KM_GSHIFT 4
X#define KM_GMASK 7
X
Xtypedef struct keymap KEYMAP;
X
XKEYMAP *topmap INIT(Null(KEYMAP*));
X
Xvoid mac_init();
XKEYMAP *newkeymap();
Xvoid show_keymap();
Xvoid pushstring();
X#endif
X
Xvoid line_col_calcs();
X
X/* terminal initialization */
X
Xvoid
Xterm_init()
X{
X    savetty();				/* remember current tty state */
X
X#ifdef TERMIO
X    ospeed = _tty.c_cflag & CBAUD;	/* for tputs() */
X    ERASECH = _tty.c_cc[VERASE];	/* for finish_command() */
X    KILLCH = _tty.c_cc[VKILL];		/* for finish_command() */
X#else
X    ospeed = _tty.sg_ospeed;		/* for tputs() */
X    ERASECH = _tty.sg_erase;		/* for finish_command() */
X    KILLCH = _tty.sg_kill;		/* for finish_command() */
X#endif
X
X    /* The following could be a table but I can't be sure that there isn't */
X    /* some degree of sparsity out there in the world. */
X
X    switch (ospeed) {			/* 1 second of padding */
X#ifdef BEXTA
X        case BEXTA:  just_a_sec = 1920; break;
X#else
X#ifdef B19200
X        case B19200: just_a_sec = 1920; break;
X#endif
X#endif
X        case B9600:  just_a_sec =  960; break;
X        case B4800:  just_a_sec =  480; break;
X        case B2400:  just_a_sec =  240; break;
X        case B1800:  just_a_sec =  180; break;
X        case B1200:  just_a_sec =  120; break;
X        case B600:   just_a_sec =   60; break;
X	case B300:   just_a_sec =   30; break;
X	/* do I really have to type the rest of this??? */
X        case B200:   just_a_sec =   20; break;
X        case B150:   just_a_sec =   15; break;
X        case B134:   just_a_sec =   13; break;
X        case B110:   just_a_sec =   11; break;
X        case B75:    just_a_sec =    8; break;
X        case B50:    just_a_sec =    5; break;
X        default:     just_a_sec =  960; break;
X					/* if we are running detached I */
X    }					/*  don't want to know about it! */
X}
X
X/* set terminal characteristics */
X
Xvoid
Xterm_set(tcbuf)
Xchar *tcbuf;		/* temp area for "uncompiled" termcap entry */
X{
X    char *tmpaddr;			/* must not be register */
X    register char *tmpstr;
X    char *tgetstr();
X    char *s;
X    int status;
X#ifdef TIOCGWINSZ
X    struct winsize winsize;
X#endif
X
X#ifdef PENDING
X#if ! defined (FIONREAD) && ! defined (RDCHK)
X    /* do no delay reads on something that always gets closed on exit */
X
X    devtty = open("/dev/tty",0);
X    if (devtty < 0) {
X	printf(cantopen,"/dev/tty") FLUSH;
X	finalize(1);
X    }
X    fcntl(devtty,F_SETFL,O_NDELAY);
X#endif
X#endif
X    
X    /* get all that good termcap stuff */
X
X#ifdef HAVETERMLIB
X    status = tgetent(tcbuf,getenv("TERM"));	/* get termcap entry */
X    if (status < 1) {
X#ifdef VERBOSE
X	printf("No termcap %s found.\n", status ? "file" : "entry") FLUSH;
X#else
X	fputs("Termcap botch\n",stdout) FLUSH;
X#endif
X	finalize(1);
X    }
X    tmpaddr = tcarea;			/* set up strange tgetstr pointer */
X    s = Tgetstr("pc");			/* get pad character */
X    PC = *s;				/* get it where tputs wants it */
X    if (!tgetflag("bs")) {		/* is backspace not used? */
X	BC = Tgetstr("bc");		/* find out what is */
X	if (BC == nullstr) 		/* terminfo grok's 'bs' but not 'bc' */
X	    BC = Tgetstr("le");
X    } else
X	BC = "\b";			/* make a backspace handy */
X    UP = Tgetstr("up");			/* move up a line */
X    if (!*UP)				/* no UP string? */
X	marking = 0;			/* disable any marking */
X    if (muck_up_clear)			/* this is for weird HPs */
X	CL = "\n\n\n\n";
X    else
X	CL = Tgetstr("cl");		/* get clear string */
X    CE = Tgetstr("ce");			/* clear to end of line string */
X#if defined(CLEAREOL) || defined(USETHREADS)
X    HO = Tgetstr("ho");			/* home cursor if no CM */
X    CM = Tgetstr("cm");			/* cursor motion */
X    if (*CM || *HO)
X	can_home = TRUE;
X#endif
X#ifdef CLEAREOL
X    CD = Tgetstr("cd");			/* clear to end of display */
X    if (!*CE || !*CD || !can_home)	/* can we CE, CD, and home? */
X	can_home_clear = FALSE;		/*  no, so disable use of clear eol */
X    if (!*CE) CE = CD;
X#endif /* CLEAREOL */
X#ifdef USETHREADS
X    upcost = strlen(UP);
X#endif
X    SO = Tgetstr("so");			/* begin standout */
X    SE = Tgetstr("se");			/* end standout */
X    if ((SG = tgetnum("sg"))<0)
X	SG = 0;				/* blanks left by SG, SE */
X    US = Tgetstr("us");			/* start underline */
X    UE = Tgetstr("ue");			/* end underline */
X    if ((UG = tgetnum("ug"))<0)
X	UG = 0;				/* blanks left by US, UE */
X    if (*US)
X	UC = nullstr;			/* UC must not be NULL */
X    else
X	UC = Tgetstr("uc");		/* underline a character */
X    if (!*US && !*UC) {			/* no underline mode? */
X	US = SO;			/* substitute standout mode */
X	UE = SE;
X	UG = SG;
X    }
X    LINES = tgetnum("li");		/* lines per page */
X    COLS = tgetnum("co");		/* columns on page */
X
X#ifdef TIOCGWINSZ
X    { struct winsize ws;
X	if (ioctl(0, TIOCGWINSZ, &ws) >= 0 && ws.ws_row > 0 && ws.ws_col > 0) {
X	    LINES = ws.ws_row;
X	    COLS = ws.ws_col;
X	}
X    }
X#endif
X	
X    AM = tgetflag("am");		/* terminal wraps automatically? */
X    XN = tgetflag("xn");		/* then eats next newline? */
X    VB = Tgetstr("vb");
X    if (!*VB)
X	VB = "\007";
X    CR = Tgetstr("cr");
X    if (!*CR) {
X	if (tgetflag("nc") && *UP) {
X	    CR = safemalloc((MEM_SIZE)strlen(UP)+2);
X	    sprintf(CR,"%s\r",UP);
X	}
X	else
X	    CR = "\r";
X    }
X#ifdef TIOCGWINSZ
X	if (ioctl(1, TIOCGWINSZ, &winsize)>=0) {
X		if (winsize.ws_row>0) LINES=winsize.ws_row;
X		if (winsize.ws_col>0) COLS=winsize.ws_col;
X	}
X#endif
X#else
X    ??????				/* Roll your own... */
X#endif
X    line_col_calcs();
X    noecho();				/* turn off echo */
X    crmode();				/* enter cbreak mode */
X
X#ifdef PUSHBACK
X    mac_init(tcbuf);
X#endif
X}
X
X#ifdef PUSHBACK
Xvoid
Xmac_init(tcbuf)
Xchar *tcbuf;
X{
X    char tmpbuf[1024];
X
X    tmpfp = fopen(filexp(getval("RNMACRO",RNMACRO)),"r");
X    if (tmpfp != Nullfp) {
X	while (fgets(tcbuf,1024,tmpfp) != Nullch) {
X	    mac_line(tcbuf,tmpbuf,(sizeof tmpbuf));
X	}
X	fclose(tmpfp);
X    }
X}
X
Xvoid
Xmac_line(line,tmpbuf,tbsize)
Xchar *line;
Xchar *tmpbuf;
Xint tbsize;
X{
X    register char *s, *m;
X    register KEYMAP *curmap;
X    register int ch;
X    register int garbage = 0;
X    static char override[] = "\nkeymap overrides string\n";
X
X    if (topmap == Null(KEYMAP*))
X	topmap = newkeymap();
X    if (*line == '#' || *line == '\n')
X	return;
X    if (line[ch = strlen(line)-1] == '\n')
X	line[ch] = '\0';
X    m = dointerp(tmpbuf,tbsize,line," \t");
X    if (!*m)
X	return;
X    while (*m == ' ' || *m == '\t') m++;
X    for (s=tmpbuf,curmap=topmap; *s; s++) {
X	ch = *s & 0177;
X	if (s[1] == '+' && isdigit(s[2])) {
X	    s += 2;
X	    garbage = (*s & KM_GMASK) << KM_GSHIFT;
X	}
X	else
X	    garbage = 0;
X	if (s[1]) {
X	    if ((curmap->km_type[ch] & KM_TMASK) == KM_STRING) {
X		fputs(override,stdout) FLUSH;
X		free(curmap->km_ptr[ch].km_str);
X		curmap->km_ptr[ch].km_str = Nullch;
X	    }
X	    curmap->km_type[ch] = KM_KEYMAP + garbage;
X	    if (curmap->km_ptr[ch].km_km == Null(KEYMAP*))
X		curmap->km_ptr[ch].km_km = newkeymap();
X	    curmap = curmap->km_ptr[ch].km_km;
X	}
X	else {
X	    if ((curmap->km_type[ch] & KM_TMASK) == KM_KEYMAP)
X		fputs(override,stdout) FLUSH;
X	    else {
X		curmap->km_type[ch] = KM_STRING + garbage;
X		curmap->km_ptr[ch].km_str = savestr(m);
X	    }
X	}
X    }
X}
X
XKEYMAP*
Xnewkeymap()
X{
X    register int i;
X    register KEYMAP *map;
X
X#ifndef lint
X    map = (KEYMAP*)safemalloc(sizeof(KEYMAP));
X#else
X    map = Null(KEYMAP*);
X#endif /* lint */
X    for (i=127; i>=0; --i) {
X	map->km_ptr[i].km_km = Null(KEYMAP*);
X	map->km_type[i] = KM_NOTHIN;
X    }
X    return map;
X}
X
Xvoid
Xshow_macros()
X{
X    char prebuf[64];
X
X    if (topmap != Null(KEYMAP*)) {
X	print_lines("Macros:\n",STANDOUT);
X	*prebuf = '\0';
X	show_keymap(topmap,prebuf);
X    }
X    else {
X	print_lines("No macros defined.\n", NOMARKING);
X    }
X}
X
Xvoid
Xshow_keymap(curmap,prefix)
Xregister KEYMAP *curmap;
Xchar *prefix;
X{
X    register int i;
X    register char *next = prefix + strlen(prefix);
X    register int kt;
X
X    for (i=0; i<128; i++) {
X	if (kt = curmap->km_type[i]) {
X	    if (i < ' ')
X		sprintf(next,"^%c",i+64);
X	    else if (i == ' ')
X		strcpy(next,"\\040");
X	    else if (i == 127)
X		strcpy(next,"^?");
X	    else
X		sprintf(next,"%c",i);
X	    if ((kt >> KM_GSHIFT) & KM_GMASK) {
X		sprintf(cmd_buf,"+%d", (kt >> KM_GSHIFT) & KM_GMASK);
X		strcat(next,cmd_buf);
X	    }
X	    switch (kt & KM_TMASK) {
X	    case KM_NOTHIN:
X		sprintf(cmd_buf,"%s	%c\n",prefix,i);
X		print_lines(cmd_buf,NOMARKING);
X		break;
X	    case KM_KEYMAP:
X		show_keymap(curmap->km_ptr[(char)i].km_km, prefix);
X		break;
X	    case KM_STRING:
X		sprintf(cmd_buf,"%s	%s\n",prefix,curmap->km_ptr[i].km_str);
X		print_lines(cmd_buf,NOMARKING);
X		break;
X	    case KM_BOGUS:
X		sprintf(cmd_buf,"%s	BOGUS\n",prefix);
X		print_lines(cmd_buf,STANDOUT);
X		break;
X	    }
X	}
X    }
X}
X
X#endif
X
X/* routine to pass to tputs */
X
Xchar
Xputchr(ch)
Xregister char ch;
X{
X    putchar(ch);
X#ifdef lint
X    ch = Null(char);
X    ch = ch;
X#endif
X    return((char) 0);
X}
X
X/* input the 2nd and succeeding characters of a multi-character command */
X/* returns TRUE if command finished, FALSE if they rubbed out first character */
X
Xbool
Xfinish_command(donewline)
Xint donewline;
X{
X    register char *s;
X    register bool quoteone = FALSE;
X
X    s = buf;
X    if (s[1] != FINISHCMD)		/* someone faking up a command? */
X	return TRUE;
X    do {
X      top:
X	if (*(unsigned char *)s < ' ') {
X	    putchar('^');
X	    putchar(*s | 64);
X	}
X	else if (*s == '\177') {
X	    putchar('^');
X	    putchar('?');
X	}
X	else
X	    putchar(*s);		/* echo previous character */
X	s++;
Xre_read:
X	fflush(stdout);
X	getcmd(s);
X	if (quoteone) {
X	    quoteone = FALSE;
X	    continue;
X	}
X	if (errno || *s == Ctl('l')) {
X	    *s = Ctl('r');		/* force rewrite on CONT */
X	}
X	if (*s == '\033') {		/* substitution desired? */
X#ifdef ESCSUBS
X	    char tmpbuf[4], *cpybuf;
X
X	    tmpbuf[0] = '%';
X	    read_tty(&tmpbuf[1],1);
X#ifdef RAWONLY
X	    tmpbuf[1] &= 0177;
X#endif
X	    tmpbuf[2] = '\0';
X	    if (tmpbuf[1] == 'h') {
X		(void) help_subs();
X		*s = '\0';
X		reprint();
X		goto re_read;
X	    }
X	    else if (tmpbuf[1] == '\033') {
X		*s = '\0';
X		cpybuf = savestr(buf);
X		interp(buf, (sizeof buf), cpybuf);
X		free(cpybuf);
X		s = buf + strlen(buf);
X		reprint();
X		goto re_read;
X	    }
X	    else {
X		interp(s,(sizeof buf) - (s-buf),tmpbuf);
X		fputs(s,stdout);
X		s += strlen(s);
X	    }
X	    goto re_read;
X#else
X	    notincl("^[");
X	    *s = '\0';
X	    reprint();
X	    goto re_read;
X#endif
X	}
X	else if (*s == ERASECH) {	/* they want to rubout a char? */
X	    rubout();
X	    s--;			/* discount the char rubbed out */
X	    if (*(unsigned char *)s < ' ' || *s == '\177')
X		rubout();
X	    if (s == buf) {		/* entire string gone? */
X		fflush(stdout);		/* return to single char command mode */
X		return FALSE;
X	    }
X	    else
X		goto re_read;
X	}
X	else if (*s == KILLCH) {	/* wipe out the whole line? */
X	    while (s-- != buf) {	/* emulate that many ERASEs */
X		rubout();
X		if (*(unsigned char *)s < ' ' || *s == '\177')
X		    rubout();
X	    }
X	    fflush(stdout);
X	    return FALSE;		/* return to single char mode */
X	}
X#ifdef WORDERASE
X	else if (*s == Ctl('w')) {	/* wipe out one word? */
X	    *s-- = ' ';
X	    while (!isspace(*s) || isspace(s[1])) {
X		rubout();
X		if (s-- == buf) {
X		    fflush(stdout);
X		    return FALSE;	/* return to single char mode */
X		}
X		if (*(unsigned char *)s < ' ' || *s == '\177')
X		    rubout();
X	    }
X	    s++;
X	    goto re_read;
X	}
X#endif
X	else if (*s == Ctl('r')) {
X	    *s = '\0';
X	    reprint();
X	    goto re_read;
X	}
X	else if (*s == Ctl('v')) {
X	    putchar('^');
X	    backspace();
X	    fflush(stdout);
X	    getcmd(s);
X	    goto top;
X	}
X	else if (*s == '\\') {
X	    quoteone = TRUE;
X	}
X    } while (*s != '\n');		/* till a newline (not echoed) */
X    *s = '\0';				/* terminate the string nicely */
X    if (donewline)
X	putchar('\n') FLUSH;
X    return TRUE;			/* say we succeeded */
X}
X
X/* discard any characters typed ahead */
X
Xvoid
Xeat_typeahead()
X{
X#ifdef PUSHBACK
X    if (!typeahead && nextin==nextout)	/* cancel only keyboard stuff */
X#else
X    if (!typeahead)
X#endif
X    {
X#ifdef PENDING
X	while (input_pending())
X	    read_tty(buf,sizeof(buf));
X#else /* this is probably v7 */
X	ioctl(_tty_ch,TIOCSETP,&_tty);
X#endif
X    }
X}
X
Xvoid
Xsettle_down()
X{
X    dingaling();
X    fflush(stdout);
X    sleep(1);
X#ifdef PUSHBACK
X    nextout = nextin;			/* empty circlebuf */
X#endif
X    eat_typeahead();
X}
X
X#ifdef PUSHBACK
X/* read a character from the terminal, with multi-character pushback */
X
Xint
Xread_tty(addr,size)
Xchar *addr;
Xint size;
X{
X    if (nextout != nextin) {
X	*addr = circlebuf[nextout++];
X	nextout %= PUSHSIZE;
X	return 1;
X    }
X    else {
X	size = read(0,addr,size);
X#ifdef RAWONLY
X	*addr &= 0177;
X#endif
X	return size;
X    }
X}
X
X#ifdef PENDING
X#if ! defined (FIONREAD) && ! defined (RDCHK)
Xint
Xcircfill()
X{
X    register int Howmany;
X
X    errno = 0;
X    Howmany = read(devtty,circlebuf+nextin,1);
X
X    if (Howmany < 0 && (errno == EAGAIN || errno == EINTR))
X	Howmany = 0;
X    if (Howmany) {
X	nextin += Howmany;
X	nextin %= PUSHSIZE;
X    }
X    return Howmany;
X}
X#endif /* PENDING */
X#endif /* FIONREAD */
X
Xvoid
Xpushchar(c)
Xchar c;
X{
X    nextout--;
X    if (nextout < 0)
X	nextout = PUSHSIZE - 1;
X    if (nextout == nextin) {
X	fputs("\npushback buffer overflow\n",stdout) FLUSH;
X	sig_catcher(0);
X    }
X    circlebuf[nextout] = c;
X}
X
X#else /* PUSHBACK */
X#ifndef read_tty
X/* read a character from the terminal, with hacks for O_NDELAY reads */
X
Xint
Xread_tty(addr,size)
Xchar *addr;
Xint size;
X{
X    if (is_input) {
X	*addr = pending_ch;
X	is_input = FALSE;
X	return 1;
X    }
X    else {
X	size = read(0,addr,size);
X#ifdef RAWONLY
X	*addr &= 0177;
X#endif
X	return size;
X    }
X}
X#endif /* read_tty */
X#endif /* PUSHBACK */
X
X/* print an underlined string, one way or another */
X
Xvoid
Xunderprint(s)
Xregister char *s;
X{
X    assert(UC);
X    if (*UC) {		/* char by char underline? */
X	while (*s) {
X	    if (*(unsigned char *)s < ' ') {
X		putchar('^');
X		backspace();/* back up over it */
X		underchar();/* and do the underline */
X		putchar(*s+64);
X		backspace();/* back up over it */
X		underchar();/* and do the underline */
X	    }
X	    else {
X		putchar(*s);
X		backspace();/* back up over it */
X		underchar();/* and do the underline */
X	    }
X	    s++;
X	}
X    }
X    else {		/* start and stop underline */
X	underline();	/* start underlining */
X	while (*s) {
X	    if (*(unsigned char *)s < ' ') {
X		putchar('^');
X		putchar(*s+64);
X	    }
X	    else
X		putchar(*s);
X	    s++;
X	}
X	un_underline();	/* stop underlining */
X    }
X}
X
X/* keep screen from flashing strangely on magic cookie terminals */
X
X#ifdef NOFIREWORKS
Xvoid
Xno_sofire()
X{
X    if (*UP && *SE) {		/* should we disable fireworks? */
X	putchar('\n');
X	un_standout();
X	up_line();
X	carriage_return();
X    }
X}
X
Xvoid
Xno_ulfire()
X{
X    if (*UP && *US) {		/* should we disable fireworks? */
X	putchar('\n');
X	un_underline();
X	up_line();
X	carriage_return();
X    }
X}
X#endif
X
X/* get a character into a buffer */
X
Xvoid
Xgetcmd(whatbuf)
Xregister char *whatbuf;
X{
X#ifdef PUSHBACK
X    register KEYMAP *curmap;
X    register int i;
X    bool no_macros; 
X    int times = 0;			/* loop detector */
X    char scrchar;
X
Xtryagain:
X    curmap = topmap;
X    no_macros = (whatbuf != buf && nextin == nextout); 
X#endif
X    for (;;) {
X	int_count = 0;
X	errno = 0;
X	if (read_tty(whatbuf,1) < 0){
X	    if (!errno)
X	        errno = EINTR;
X	    if (errno == EINTR)
X		return;
X	    perror(readerr);
X	    sig_catcher(0);
X	}
X#ifdef PUSHBACK
X	if (*whatbuf & 0200 || no_macros) {
X	    *whatbuf &= 0177;
X	    goto got_canonical;
X	}
X	if (curmap == Null(KEYMAP*))
X	    goto got_canonical;
X	for (i = (curmap->km_type[*whatbuf] >> KM_GSHIFT) & KM_GMASK; i; --i){
X	    read_tty(&scrchar,1);
X	}
X	switch (curmap->km_type[*whatbuf] & KM_TMASK) {
X	case KM_NOTHIN:			/* no entry? */
X	    if (curmap == topmap)	/* unmapped canonical */
X		goto got_canonical;
X	    settle_down();
X	    goto tryagain;
X	case KM_KEYMAP:			/* another keymap? */
X	    curmap = curmap->km_ptr[*whatbuf].km_km;
X	    assert(curmap != Null(KEYMAP*));
X	    break;
X	case KM_STRING:			/* a string? */
X	    pushstring(curmap->km_ptr[*whatbuf].km_str);
X	    if (++times > 20) {		/* loop? */
X		fputs("\nmacro loop?\n",stdout);
X		settle_down();
X	    }
X	    no_macros = FALSE;
X	    goto tryagain;
X	}
X#else
X#ifdef RAWONLY
X	*whatbuf &= 0177;
X#endif
X	break;
X#endif
X    }
X
Xgot_canonical:
X#ifndef TERMIO
X    if (*whatbuf == '\r')
X	*whatbuf = '\n';
X#endif
X    if (whatbuf == buf)
X	whatbuf[1] = FINISHCMD;		/* tell finish_command to work */
X}
X
X#ifdef PUSHBACK
Xvoid
Xpushstring(str)
Xchar *str;
X{
X    register int i;
X    char tmpbuf[PUSHSIZE];
X    register char *s = tmpbuf;
X
X    assert(str != Nullch);
X    interp(s,PUSHSIZE,str);
X    for (i = strlen(s)-1; i >= 0; --i) {
X	s[i] ^= 0200; 
X	pushchar(s[i]);
X    }
X}
X#endif
X
Xint
Xget_anything()
X{
X    char tmpbuf[2];
X
Xreask_anything:
X    unflush_output();			/* disable any ^O in effect */
X    standout();
X#ifdef VERBOSE
X    IF(verbose)
X	fputs("[Type space to continue] ",stdout);
X    ELSE
X#endif
X#ifdef TERSE
X	fputs("[MORE] ",stdout);
X#endif
X    un_standout();
X    fflush(stdout);
X    eat_typeahead();
X    if (int_count) {
X	return -1;
X    }
X    collect_subjects();			/* loads subject cache until */
X					/* input is pending */
X    getcmd(tmpbuf);
X    if (errno || *tmpbuf == '\f') {
X	putchar('\n') FLUSH;		/* if return from stop signal */
X	goto reask_anything;		/* give them a prompt again */
X    }
X    if (*tmpbuf == 'h') {
X#ifdef VERBOSE
X	IF(verbose)
X	    fputs("\nType q to quit or space to continue.\n",stdout) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    fputs("\nq to quit, space to continue.\n",stdout) FLUSH;
X#endif
X	goto reask_anything;
X    }
X    else if (*tmpbuf != ' ' && *tmpbuf != '\n') {
X	carriage_return();
X	erase_eol();	/* erase the prompt */
X	carriage_return();
X	return *tmpbuf == 'q' ? -1 : *tmpbuf;
X    }
X    if (*tmpbuf == '\n') {
X	page_line = LINES - 1;
X	carriage_return();
X	erase_eol();
X	carriage_return();
X    }
X    else {
X	page_line = 1;
X	if (erase_screen)		/* -e? */
X	    clear();			/* clear screen */
X	else {
X	    carriage_return();
X	    erase_eol();		/* erase the prompt */
X	    carriage_return();
X	}
X    }
X    return 0;
X}
X
X#ifdef USETHREADS
Xint
Xpause_getcmd()
X{
X    unflush_output();			/* disable any ^O in effect */
X    standout();
X#ifdef VERBOSE
X    IF(verbose)
X	fputs("[Type space or a command] ",stdout);
X    ELSE
X#endif
X#ifdef TERSE
X	fputs("[CMD] ",stdout);
X#endif
X    un_standout();
X    fflush(stdout);
X    eat_typeahead();
X    if (int_count) {
X	return -1;
X    }
X    getcmd(buf);
X    if (errno || *buf == '\f') {
X	return 0;			/* if return from stop signal */
X    }
X    else if (*buf != ' ') {
X	carriage_return();
X	erase_eol();	/* erase the prompt */
X	carriage_return();
X	return *buf;
X    }
X    return 0;
X}
X#endif
X
Xvoid
Xin_char(prompt, newmode)
Xchar *prompt;
Xchar newmode;
X{
X    char oldmode = mode;
X
Xreask_in_char:
X    unflush_output();			/* disable any ^O in effect */
X    fputs(prompt,stdout);
X    fflush(stdout);
X    eat_typeahead();
X    mode = newmode;
X    getcmd(buf);
X    if (errno || *buf == '\f') {
X	putchar('\n') FLUSH;		/* if return from stop signal */
X	goto reask_in_char;		/* give them a prompt again */
X    }
X    mode = oldmode;
X}
X
Xint
Xprint_lines(what_to_print,hilite)
Xchar *what_to_print;
Xint hilite;
X{
X    register char *s;
X    register int i;
X
X    if (page_line < 0)			/* they do not want to see this? */
X	return -1;
X    for (s=what_to_print; *s; ) {
X	if (page_line >= LINES || int_count) {
X	    if (i = -1, int_count || (i = get_anything())) {
X		page_line = -1;		/* disable further print_lines */
X		return i;
X	    }
X	}
X	page_line++;
X	if (hilite == STANDOUT) {
X#ifdef NOFIREWORKS
X	    if (erase_screen)
X		no_sofire();
X#endif
X	    standout();
X	}
X	else if (hilite == UNDERLINE) {
X#ifdef NOFIREWORKS
X	    if (erase_screen)
X		no_ulfire();
X#endif
X	    underline();
X	}
X	for (i=0; i<COLS; i++) {
X	    if (!*s)
X		break;
X	    if (*(unsigned char *)s >= ' ')
X		putchar(*s);
X	    else if (*s == '\t') {
X		putchar(*s);
X		i = ((i+8) & ~7) - 1; 
X	    }
X	    else if (*s == '\n') {
X		i = 32000;
X	    }
X	    else {
X		i++;
X		putchar('^');
X		putchar(*s + 64);
X	    }
X	    s++;
X	}
X	if (i) {
X	    if (hilite == STANDOUT)
X		un_standout();
X	    else if (hilite == UNDERLINE)
X		un_underline();
X	    if (AM && i == COLS)
X		fflush(stdout);
X	    else
X		putchar('\n') FLUSH;
X	}
X    }
X    return 0;
X}
X
Xvoid
Xpage_init()
X{
X    page_line = 1;
X    if (erase_screen)
X	clear();
X    else
X	putchar('\n') FLUSH;
X}
X
Xvoid
Xpad(num)
Xint num;
X{
X    register int i;
X
X    for (i = num; i; --i)
X	putchar(PC);
X    fflush(stdout);
X}
X
X/* echo the command just typed */
X
X#ifdef VERIFY
Xvoid
Xprintcmd()
X{
X    if (verify && buf[1] == FINISHCMD) {
X	if (*(unsigned char *)buf < ' ') {
X	    putchar('^');
X	    putchar(*buf | 64);
X	    backspace();
X	    backspace();
X	}
X	else {
X	    putchar(*buf);
X	    backspace();
X	}
X	fflush(stdout);
X    }
X}
X#endif
X
Xvoid
Xrubout()
X{
X    backspace();			/* do the old backspace, */
X    putchar(' ');			/*   space, */
X    backspace();			/*     backspace trick */
X}
X
Xvoid
Xreprint()
X{
X    register char *s;
X
X    fputs("^R\n",stdout) FLUSH;
X    for (s = buf; *s; s++) {
X	if (*(unsigned char *)s < ' ') {
X	    putchar('^');
X	    putchar(*s | 64);
X	}
X	else
X	    putchar(*s);
X    }
X}
X
X#if defined(CLEAREOL) || defined(USETHREADS)
Xvoid
Xhome_cursor()
X{
X    char *tgoto();
X
X    if (!*HO) {			/* no home sequence? */
X	if (!*CM) {		/* no cursor motion either? */
X	    fputs ("\n\n\n", stdout);
X	    return;		/* forget it. */
X	}
X	tputs (tgoto (CM, 0, 0), 1, putchr);	/* go to home via CM */
X	return;
X    }
X    else {			/* we have home sequence */
X	tputs (HO, 1, putchr);	/* home via HO */
X    }
X}
X#endif
X
X#ifdef USETHREADS
Xvoid
Xgoto_line(from,to)	/* assumes caller is already at beginning of line */
Xint from,to;
X{
X    char *tgoto(), *str;
X    int cmcost;
X
X    if (from == to) {
X	return;
X    }
X    if (*CM && !muck_up_clear) {
X	cmcost = strlen(str = tgoto(CM,0,to));
X    } else {
X	cmcost = 9999;
X    }
X    if (to > from) {
X      go_down:
X	if (to - from <= cmcost) {
X	    while(from++ < to) {
X		putchar('\n');
X	    }
X	    return;
X	}
X    } else if(*UP) {
X	if ((from - to) * upcost <= cmcost) {
X	    while(from-- > to) {
X		tputs(UP,1,putchr);
X	    }
X	    return;
X	}
X    } else if (cmcost == 9999) {
X	home_cursor();
X	from = 0;
X	goto go_down;
X    }
X    tputs(str,1,putchr);
X}
X#endif
X
X
Xvoid
Xline_col_calcs()
X{
X     if (LINES > 0) {			/* is this a crt? */
X	  if ((!initlines) || (!initlines_specified))
X	       /* no -i or unreasonable value for initlines */
X	       if (ospeed >= B9600) 	/* whole page at >= 9600 baud */
X		    initlines = LINES;
X	       else if (ospeed >= B4800)/* 16 lines at 4800 */
X		    initlines = 16;
X	       else			/* otherwise just header */
X		    initlines = 8;
X     }
X     else {				/* not a crt */
X	  LINES = 30000;		/* so don't page */
X	  CL = "\n\n";			/* put a couple of lines between */
X	  if ((!initlines) || (!initlines_specified))
X	       /* make initlines reasonable */
X	       initlines = 8;
X     }
X     if (COLS <= 0)
X	  COLS = 80;
X}
X
X
X#ifdef SIGWINCH
Xint
Xwinch_catcher()
X{
X     /* Come here if window size change signal received */
X#ifdef TIOCGWINSZ
X     struct winsize ws;
X
X     if (ioctl(0, TIOCGWINSZ, &ws) >= 0 && ws.ws_row > 0 && ws.ws_col > 0) {
X          LINES = ws.ws_row;
X          COLS = ws.ws_col;
X          line_col_calcs();
X     }
X#else
X     ???????
X     /* Well, if SIGWINCH is defined, but TIOCGWINSZ isn't, there's    */
X     /* almost certainly something wrong.  Figure it out for yourself, */
X     /* because I don't know now to deal :-)                           */
X#endif
X}
X#endif
END_OF_FILE
  if test 25986 -ne `wc -c <'term.c'`; then
    echo shar: \"'term.c'\" unpacked with wrong size!
  fi
  # end of 'term.c'
fi
echo shar: End of archive 7 \(of 14\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
