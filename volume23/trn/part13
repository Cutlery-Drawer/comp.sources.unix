This is a new archive version of TRN at patchlevel 3.
The original posting took up Volume23, issues 60 to 73, with
various problems.  These files replace those issues.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  NEW Pnews.1 Rnmail.1 addng.c artio.c backpage.c
#   getactive.c makedepend.SH mbox.saver.SH mthreads.h ndir.c ndir.h
#   newsetup.1 newsetup.SH newsgroups.1 newsgroups.SH ngsrch.c only.c
#   rthreads.h threads.c threads.h
# Wrapped by rsalz@litchi.bbn.com on Fri Aug 23 16:39:03 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 13 (of 14)."'
if test -f 'NEW' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'NEW'\"
else
  echo shar: Extracting \"'NEW'\" \(2877 characters\)
  sed "s/^X//" >'NEW' <<'END_OF_FILE'
X		    NEW FEATURES OF TRN 1.0 vs RN 4.3
X
XNew commands (article level)
X	t		display a map of the thread's article tree.
X	[, ], {, }	move around in the article tree
X	J		junk an entire thread of disucussion regardless of
X			subject changes.
X	T		put the entire thread of discussion in the KILL file
X			(as opposed to the current subject).
X	<, >		move between threads of discussion
X	U		mark some articles as unread again (choose from
X			the current thread, subthread, selected threads, or
X			all articles).
X	e		extract a shar or uuencoded file.
X	:		execute a command on all the selected threads/articles
X
XNew commands (newsgroup level)
X	+		enter a newsgroup through the thread selector.
X	U		enter a newsgroup through the "set unread" prompt.
X
XNew commands (thread selector)
X	[...lots...]	use the thread selector to quickly browse the subjects
X			and/or authors of articles and select only the ones
X			that you want to read.  You can read each one as
X			soon as you select it, or select them all at once.
X			Use the 'h' command to see a command summary, or read
X			the man page for more details.
X
XNew header display:	we display a subset of the thread's article tree in
X			each header.
X
XNew display ordering:	the articles appear in their reply order.
X
XNew switches (default may be on, use +x/+X to turn them off)
X	-x		turn on threaded extensions.
X	-X		use thread selector to enter a group.
X
XNew magic (use +H to turn them off)
X	-Hfrom		displays only the commented portion of the user name.
X	-Hdate		displays the date in local time.
X
XNew environment variables
X	EXSAVER		shell command that starts an extraction.
X	SELECTCHARS	the character set to use to select threads
X			(default:  abcdefgijlorstuvwxz1234567890).
X	UNSHAR		the unshar program to use (default /bin/sh).
X	REPLYTO		the value to use for the "Reply-To:" header, if
X			needed.
X
XNew mode
X	%m=t		when in the thread selector
X
XNew % interpolations
X	%#		keeps an incremental count during a multi-file save,
X			extract, etc.  ":s part.%#"
X	%e		the last command executed to extract an article.
X	%E		The number of extra (unselected) articles, not
X			counting the current article (if selected).
X	%U		same as before (number of unread articles, not counting
X			the current one) but if selections are on, only counts
X			selected articles.
X	%Z		The number of selected threads.
X
XMacros and Keymaps
X	When defining macros, make sure you don't define something that
X	will conflict with the selection characters in the thread selector.
X	An easy way is to exclude the thread selector with a mode test:
X
X		f	%(%m=t?f:|mail smith\n)
X
X	Also, if you want to use one of the selection characters as a
X	command in the thread selector, be sure to exclude it from the
X	list of selection characters in SELECTCHARS (you can define this
X	with -ESELECTCHARS=abc123 in your .rninit file).
X
XMiscellaneous
X	...and much, much more! (including various bug fixes!)
END_OF_FILE
  if test 2877 -ne `wc -c <'NEW'`; then
    echo shar: \"'NEW'\" unpacked with wrong size!
  fi
  # end of 'NEW'
fi
if test -f 'Pnews.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Pnews.1'\"
else
  echo shar: Extracting \"'Pnews.1'\" \(3130 characters\)
  sed "s/^X//" >'Pnews.1' <<'END_OF_FILE'
X''' $Header: Pnews.1,v 4.3.3.1 90/07/21 19:57:23 davison Trn $
X''' 
X''' $Log:	Pnews.1,v $
X''' Revision 4.3.3.1  90/07/21  19:57:23  davison
X''' Initial Trn Release
X''' 
X''' Revision 4.3.1.2  85/08/01  14:22:48  lwall
X''' Added AUTHORCOPY.
X''' 
X''' Revision 4.3.1.1  85/05/10  11:30:30  lwall
X''' Branch for patches.
X''' 
X''' Revision 4.3  85/05/01  11:33:50  lwall
X''' Baseline for release with 4.3bsd.
X''' 
X.de Sh
X.br
X.ne 5
X.PP
X\fB\\$1\fR
X.PP
X..
X.de Sp
X.if t .sp .5v
X.if n .sp
X..
X'''
X'''     Set up \*(-- to give an unbreakable dash;
X'''     string Tr holds user defined translation string.
X'''     Bell System Logo is used as a dummy character.
X'''
X.ie n \{\
X.tr \(bs-\*(Tr
X.ds -- \(bs-
X.if (\n(.H=4u)&(1m=24u) .ds -- \(bs\h'-12u'\(bs\h'-12u'-\" diablo 10 pitch
X.if (\n(.H=4u)&(1m=20u) .ds -- \(bs\h'-12u'\(bs\h'-8u'-\" diablo 12 pitch
X.ds L" ""
X.ds R" ""
X.ds L' '
X.ds R' '
X'br\}
X.el\{\
X.ds -- \(em\|
X.tr \*(Tr
X.ds L" ``
X.ds R" ''
X.ds L' `
X.ds R' '
X'br\}
X.TH PNEWS 1 LOCAL
X.SH NAME
XPnews - a program for posting news articles
X.SH SYNOPSIS
X.B Pnews newsgroup title
X.br
X  or
X.br
X.B Pnews -h headerfile [oldarticle]
X.br
X  or
X.br
X.B Pnews
X.SH DESCRIPTION
XPnews is a friendly interface for posting news articles.
XIt will ask several questions, then allow you to enter your article,
Xand then post it using the inews(1) program.
XIf you type h and a carriage return at any point,
X.I Pnews
Xwill tell you what it wants to know.
X.PP
XThe -h form is used when invoked from
X.IR rn .
XIf your editor can edit multiple files, and you want the article to which
Xyou are replying to show up as an alternate file, define the environment
Xvariable NEWSPOSTER as \*(L"Pnews -h %h %A\*(R".
XYou can also modify the the NEWSHEADER environment variable to change the
Xheader file that
X.I rn
Xpasses to Pnews.
X.SH ENVIRONMENT
X.IP AUTHORCOPY 8
XIf defined, contains the name of a file to which the finished article will
Xbe appended.
X.Sp
XDefault: article not saved
X.IP DOTDIR 8
XWhere to find your dot files, if they aren't in your home directory.
XThis is primarily for accounts which are shared by more than one person.
X.Sp
XDefault: $HOME
X.IP EDITOR 8
XThe editor you want to use, if VISUAL is undefined.
X.Sp
XDefault: whatever your news administrator installed, usually vi.
X.IP HOME 8
XYour home directory.
X.Sp
XDefault: $LOGDIR
X.IP LOGDIR 8
XYour home directory if HOME is undefined.
X.IP LOGNAME 8
XYour login name, if USER is undefined.
X.Sp
XDefault: value of \*(L"whoami\*(R".
X.IP NAME 8
XYour full name.
X.Sp
XDefault: name from /etc/passwd, or ~/.fullname.
X.IP ORGANIZATION 8
XEither the name of your organization, or the name of a file containing the
Xname of your organization.
X.Sp
XDefault: whatever your news administrator chose.
X.IP REPLYTO 8
XThe contents of a \*(L"Reply-To:\*(R" header line to insert into your message.
X.Sp
XDefault: header line not inserted.
X.IP USER 8
XYour login name.
X.Sp
XDefault: $LOGNAME
X.IP VISUAL 8
XThe editor you want to use.
X.Sp
XDefault: $EDITOR
X.SH FILES
X$DOTDIR/.article
X.br
X~/dead.article
X.SH SEE ALSO
Xrn(1), Rnmail(1), inews(1)
X.SH DIAGNOSTICS
X.SH BUGS
XNot the speediest program in the world, but maybe that's a blessing to the
Xnet.
END_OF_FILE
  if test 3130 -ne `wc -c <'Pnews.1'`; then
    echo shar: \"'Pnews.1'\" unpacked with wrong size!
  fi
  # end of 'Pnews.1'
fi
if test -f 'Rnmail.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Rnmail.1'\"
else
  echo shar: Extracting \"'Rnmail.1'\" \(3038 characters\)
  sed "s/^X//" >'Rnmail.1' <<'END_OF_FILE'
X''' $Header: Rnmail.1,v 4.3.3.1 90/07/21 19:57:27 davison Trn $
X''' 
X''' $Log:	Rnmail.1,v $
X''' Revision 4.3.3.1  90/07/21  19:57:27  davison
X''' Initial Trn Release
X''' 
X''' Revision 4.3.1.2  85/08/01  14:22:08  lwall
X''' Added MAILRECORD, DOTDIR.
X''' 
X''' Revision 4.3.1.1  85/05/10  11:30:44  lwall
X''' Branch for patches.
X''' 
X''' Revision 4.3  85/05/01  11:34:28  lwall
X''' Baseline for release with 4.3bsd.
X''' 
X.de Sh
X.br
X.ne 5
X.PP
X\fB\\$1\fR
X.PP
X..
X.de Sp
X.if t .sp .5v
X.if n .sp
X..
X'''
X'''     Set up \*(-- to give an unbreakable dash;
X'''     string Tr holds user defined translation string.
X'''     Bell System Logo is used as a dummy character.
X'''
X.ie n \{\
X.tr \(bs-\*(Tr
X.ds -- \(bs-
X.if (\n(.H=4u)&(1m=24u) .ds -- \(bs\h'-12u'\(bs\h'-12u'-\" diablo 10 pitch
X.if (\n(.H=4u)&(1m=20u) .ds -- \(bs\h'-12u'\(bs\h'-8u'-\" diablo 12 pitch
X.ds L" ""
X.ds R" ""
X.ds L' '
X.ds R' '
X'br\}
X.el\{\
X.ds -- \(em\|
X.tr \*(Tr
X.ds L" ``
X.ds R" ''
X.ds L' `
X.ds R' '
X'br\}
X.TH RNMAIL 1 LOCAL
X.SH NAME
XRnmail - a program for replying via mail
X.SH SYNOPSIS
X.B Rnmail destination_list
X.br
X  or
X.br
X.B Rnmail -h headerfile [oldarticle]
X.br
X  or
X.br
X.B Rnmail
X.SH DESCRIPTION
XRnmail is a friendly interface for mailing replies to news articles.
XIt will ask several questions, then allow you to enter your letter,
Xand then mail it off.
XIf you type h and a carriage return at any point,
X.I Rnmail
Xwill tell you what it wants to know.
X.PP
XThe -h form is used when invoked from
X.IR rn .
XIf your editor can edit multiple files, and you want the article to which
Xyou are replying to show up as an alternate file, define the environment
Xvariable MAILPOSTER as \*(L"Rnmail -h %h %A\*(R".
XYou can also modify the the MAILHEADER environment variable to change the
Xheader file that
X.I rn
Xpasses to Rnmail.
X.SH ENVIRONMENT
X.IP DOTDIR 8
XIf defined, specifies a place other than your home directory where 'dot' files
Xmay be stored.
XThis is primarily for accounts which are shared by more than one person.
X.Sp
XDefault: $HOME
X.IP EDITOR 8
XThe editor you want to use, if VISUAL is undefined.
X.Sp
XDefault: whatever your news administrator installed, usually vi.
X.IP HOME 8
XYour home directory.
X.Sp
XDefault: $LOGDIR
X.IP LOGDIR 8
XYour home directory if HOME is undefined.
X.IP LOGNAME 8
XYour login name, if USER is undefined.
X.Sp
XDefault: value of \*(L"whoami\*(R".
X.IP MAILRECORD 8
XIf defined, contains the name of a file to which the finished message will
Xbe appended.
X.Sp
XDefault: message not saved
X.IP ORGANIZATION 8
XEither the name of your organization, or the name of a file containing the
Xname of your organization.
X.Sp
XDefault: whatever your news administrator chose.
X.IP REPLYTO 8
XThe contents of a \*(L"Reply-To:\*(R" header line to insert into your message.
X.Sp
XDefault: header line not inserted.
X.IP USER 8
XYour login name.
X.Sp
XDefault: $LOGNAME
X.IP VISUAL 8
XThe editor you want to use.
X.Sp
XDefault: $EDITOR
X.SH FILES
X$DOTDIR/.letter
X.br
X~/dead.letter
X.SH SEE ALSO
Xrn(1), Pnews(1), mail(1)
X.SH DIAGNOSTICS
X.SH BUGS
XUses /bin/mail in the absence of sendmail.
END_OF_FILE
  if test 3038 -ne `wc -c <'Rnmail.1'`; then
    echo shar: \"'Rnmail.1'\" unpacked with wrong size!
  fi
  # end of 'Rnmail.1'
fi
if test -f 'addng.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'addng.c'\"
else
  echo shar: Extracting \"'addng.c'\" \(4695 characters\)
  sed "s/^X//" >'addng.c' <<'END_OF_FILE'
X/* $Header: addng.c,v 4.3.3.3 91/01/16 02:20:43 davison Trn $
X *
X * $Log:	addng.c,v $
X * Revision 4.3.3.3  91/01/16  02:20:43  davison
X * Integrated rn patches 48-54.
X * 
X * Revision 4.3.3.2  90/08/20  16:27:06  davison
X * Allow breaking out of ng adding.  Don't add 'X'ed groups.
X * 
X * Revision 4.3.3.1  90/06/20  22:35:43  davison
X * Initial Trn Release
X * 
X * Revision 4.3.2.6  90/11/22  16:06:35  sob
X * Changes to make pickly C preprocessors happier.
X * 
X * Revision 4.3.2.5  90/09/04  23:29:51  sob
X * Added fix for bithof() from bug report by kwthomas@nsslsun.gcn.uoknor.edu
X * 
X * Revision 4.3.2.4  90/03/17  17:11:36  sob
X * Added support for CNEWS active file flags.
X * 
X * Revision 4.3.2.3  89/11/08  02:33:28  sob
X * Added include for server.h
X * 
X * Revision 4.3.2.2  89/11/08  01:23:49  sob
X * Added GROUP check when SERVER defined.
X * 
X * Revision 4.3.2.1  89/11/06  00:34:11  sob
X * Added RRN support from NNTP 1.5
X * 
X * Revision 4.3.1.2  85/05/29  09:06:24  lwall
X * New newsgroups without spool directories incorrectly classified as "ancient".
X * 
X * Revision 4.3.1.1  85/05/10  11:30:50  lwall
X * Branch for patches.
X * 
X * Revision 4.3  85/05/01  11:34:41  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "rn.h"
X#include "ngdata.h"
X#include "last.h"
X#include "util.h"
X#include "intrp.h"
X#include "only.h"
X#include "rcstuff.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X#include "final.h"
X#include "INTERN.h"
X#include "addng.h"
X
Xvoid
Xaddng_init()
X{
X    ;
X}
X
X#ifdef FINDNEWNG
X/* generate a list of new newsgroups from active file */
X
Xbool
Xnewlist(munged,checkinlist)
Xbool munged;				/* are we scanning the whole file? */
Xbool checkinlist;
X{
X    char *tmpname;
X    register char *s, *status;
X    long birthof();
X
X    tmpname = savestr(filexp(RNEWNAME));
X    tmpfp = fopen(tmpname,"w");
X    if (tmpfp == Nullfp) {
X	printf(cantcreate,tmpname) FLUSH;
X	return FALSE;
X    }
X    while (fgets(buf,LBUFLEN,actfp) != Nullch) {
X	/* Check if they want to break out of the new newsgroups search */
X	if (int_count) {
X	    int_count = 0;
X	    fclose(tmpfp);
X	    UNLINK(tmpname);
X	    free(tmpname);
X	    return FALSE;
X	}
X	if (s = index(buf,' ')) {
X	    status=s;
X	    while (isdigit(*status) || isspace(*status)) status++;
X	    *s++ = '\0';
X#ifdef USETHREADS
X	    if (strnEQ(buf,"to.",3) || *status == 'x' || *status == 'X'
X				    || *status == '=')
X#else
X	    if (strnEQ(buf,"to.",3) || *status == 'x' || *status == '=')
X#endif
X	        /* since = groups are refiling to another group, just
X		   ignore their existence */
X		continue;
X	    if (find_ng(buf) == nextrcline &&
X		    (checkinlist ?
X			(inlist(buf)) :
X			(birthof(buf,(ART_NUM)atol(s)) > lasttime)
X		    )
X		) {
X					/* if not in .newsrc and younger */
X					/* than the last time we checked */
X		fprintf(tmpfp,"%s\n",buf);
X					/* then remember said newsgroup */
X	    }
X#ifdef FASTNEW
X	    else {			/* not really a new group */
X		if (!munged) {		/* did we assume not munged? */
X		    fclose(tmpfp);	/* then go back, knowing that */
X		    UNLINK(tmpname);
X		    free(tmpname);
X		    return TRUE;	/* active file was indeed munged */
X		}
X	    }
X#endif
X	}
X#ifdef DEBUGGING
X	else
X	    printf("Bad active record: %s\n",buf) FLUSH;
X#endif
X    }
X
X    /* we have successfully generated the list */
X
X    fclose(tmpfp);
X    tmpfp = fopen(tmpname,"r");
X    UNLINK(tmpname);			/* be nice to the world */
X    if (tmpfp == Nullfp) {
X	printf(cantopen,tmpname) FLUSH;
X	return FALSE;
X    }
X    while (fgets(buf,LBUFLEN,tmpfp) != Nullch) {
X	buf[strlen(buf)-1] = '\0';
X	get_ng(buf,TRUE);		/* add newsgroup, maybe */
X    }
X    fclose(tmpfp);			/* be nice to ourselves */
X    free(tmpname);
X    return FALSE;			/* do not call us again */
X}
X
X/* return creation time of newsgroup */
X
Xlong
Xbirthof(ngnam,ngsize)
Xchar *ngnam;
XART_NUM ngsize;
X{
X    char tst[128];
X    long time();
X 
X#ifdef SERVER
X    int x,tot,min,max;
X    sprintf(tst,"GROUP %s",ngnam);
X    put_server(tst);
X    (void) get_server(tst, sizeof(tst));
X    if (*tst != CHAR_OK) return(0); /* not a real group */
X    (void) sscanf(tst,"%d%d%d%d",&x,&tot,&min,&max);
X    if (tot > 0) return(time(Null(long *)));
X    else return(0);
X#else /* not SERVER */
X
X    sprintf(tst, ngsize ? "%s/%s/1" : "%s/%s" ,spool,getngdir(ngnam));
X    if (stat(tst,&filestat) < 0)
X	return (ngsize ? 0L : time(Null(long *)));
X	/* not there, assume something good */
X    else
X	return filestat.st_mtime;
X
X#endif
X}
X
Xbool
Xscanactive()
X{
X    NG_NUM oldnext = nextrcline;	/* remember # lines in newsrc */
X
X    fseek(actfp,0L,0);
X    newlist(TRUE,TRUE);
X    if (nextrcline != oldnext) {	/* did we add any new groups? */
X	return TRUE;
X    }
X    return FALSE;
X}
X
X#endif
X
END_OF_FILE
  if test 4695 -ne `wc -c <'addng.c'`; then
    echo shar: \"'addng.c'\" unpacked with wrong size!
  fi
  # end of 'addng.c'
fi
if test -f 'artio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'artio.c'\"
else
  echo shar: Extracting \"'artio.c'\" \(4969 characters\)
  sed "s/^X//" >'artio.c' <<'END_OF_FILE'
X/* $Header: artio.c,v 4.3.3.3 91/01/16 02:20:48 davison Trn $
X *
X * $Log:	artio.c,v $
X * Revision 4.3.3.3  91/01/16  02:20:48  davison
X * Integrated rn patches 48-54.
X * 
X * Revision 4.3.3.2  90/08/20  16:25:50  davison
X * Fixed bug in artopen ==> nntpopen interaction.
X * 
X * Revision 4.3.3.1  90/07/21  20:11:03  davison
X * Initial Trn Release
X * 
X * Revision 4.3.2.6  90/11/22  16:06:57  sob
X * Changes to make pickly C preprocessors happier.
X * 
X * Revision 4.3.2.5  90/03/22  23:04:04  sob
X * Fixes provided by Wayne Davison <drivax!davison>
X * 
X * Revision 4.3.2.4  89/11/27  01:29:57  sob
X * Altered NNTP code per ideas suggested by Bela Lubkin
X * <filbo@gorn.santa-cruz.ca.us>
X * 
X * Revision 4.3.2.3  89/11/26  22:55:31  sob
X * Add nntpopen() and nntpclose() routines to cut down on size of rrn
X * 
X * Revision 4.3.2.2  89/11/08  01:17:12  sob
X * Added changes to insure that this will compile for RN or RRN with no
X * changes to the source code.
X * 
X * Revision 4.3.2.1  89/11/06  00:07:25  sob
X * Added RRN support from NNTP 1.5
X * 
X * Revision 4.3  85/05/01  11:35:39  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X#include "INTERN.h"
X#include "artio.h"
X
Xvoid
Xartio_init()
X{
X    ;
X}
X
X/* open an article, unless it's already open */
X
XFILE *
Xartopen(artnum)
XART_NUM artnum;
X{
X#ifdef SERVER
X    return nntpopen(artnum,GET_ARTICLE);
X#else
X    char artname[32];			/* filename of current article */
X
X    if (artnum < 1)
X	return Nullfp;
X    if (openart == artnum) {		/* this article is already open? */
X	fseek(artfp,0L,0);		/* just get to the beginning */
X	return artfp;			/* and say we succeeded */
X    }
X    if (artfp != Nullfp) {		/* it was somebody else? */
X	fclose(artfp);			/* put them out of their misery */
X	openart = 0;			/* and remember them no more */
X    }
X    sprintf(artname,"%ld",(long)artnum);
X					/* produce the name of the article */
X    if (artfp = fopen(artname,"r"))	/* if we can open it */
X	openart = artnum;		/* remember what we did here */
X#ifdef LINKART
X    {
X	char tmpbuf[256];
X	char *s;
X
X	if (fstat(fileno(artfp),&filestat))
X	    return artfp;
X	if (filestat.st_size < (sizeof tmpbuf)) {
X	    fgets(tmpbuf,(sizeof tmpbuf),artfp);
X	    if (*tmpbuf == '/') {	/* is a "link" to another article */
X		fclose(artfp);
X		if (s=index(tmpbuf,'\n'))
X		    *s = '\0';
X		if (!(artfp = fopen(tmpbuf,"r")))
X		    openart = 0;
X		else {
X		    if (*linkartname)
X			free(linkartname);
X		    linkartname = savestr(tmpbuf);
X		}
X	    }
X	    else
X		fseek(artfp,0L,0);		/* get back to the beginning */
X	}
X    }
X#endif
X    return artfp;			/* and return either fp or NULL */
X#endif /* SERVER */
X}
X
X#ifdef SERVER
Xstatic long our_pid=0;
X
XFILE *
Xnntpopen(artnum,function)
XART_NUM artnum;
XART_PART function;
X{
X    char ser_line[256];
X    char artname[32];			/* filename of current article */
X    if (our_pid == 0)
X	our_pid = getpid();
X    if (artnum < 1)
X	return Nullfp;
X    if ((openart == artnum) && (openpart >= function))
X    {					/* this article is already open? */
X	fseek(artfp,0L,0);		/* just get to the beginning */
X	return artfp;			/* and say we succeeded */
X    }
X    if (artfp != Nullfp) {		/* it was somebody else? */
X	fclose(artfp);			/* put them out of their misery */
X	nntpclose();
X	openart = 0;			/* and remember them no more */
X    }
X    sprintf(artname,"/tmp/rrn%ld.%ld", (long) artnum, our_pid);
X    artfp = fopen(artname, "w+");	/* create the temporary article */
X    if (artfp == Nullfp) {
X	UNLINK(artname);
X	return Nullfp;
X    }
X    switch (function){
X	    case GET_STATUS:
X		function = GET_HEADER;	/* fall through */
X	    case GET_HEADER:
X		sprintf(ser_line, "HEAD %ld", (long)artnum);
X		break;
X	    case GET_ARTICLE:
X		sprintf(ser_line, "ARTICLE %ld", (long)artnum);
X		break;
X    }	    
X    put_server(ser_line);		/* ask the server for the article */
X    if (get_server(ser_line, sizeof(ser_line)) < 0) {
X	fprintf(stderr, "rrn: Unexpected close of server socket.\n");
X	finalize(1);
X    }
X    if (*ser_line != CHAR_OK) {		/* and get it's reaction */
X	fclose(artfp);
X	artfp = Nullfp;
X	UNLINK(artname);
X 	errno = ENOENT;		/* Simulate file-not-found */
X        return Nullfp;
X    }
X
X    for (;;) {
X        if (get_server(ser_line, sizeof(ser_line)) < 0) {
X	    fprintf(stderr, "rrn: Unexpected close of server socket.\n");
X	    finalize(1);
X	}
X	if (ser_line[0] == '.' && ser_line[1] == '\0')
X		break;
X	fputs((ser_line[0] == '.' ? ser_line + 1 : ser_line), artfp);
X	putc('\n', artfp);
X    }
X    openpart = function;
X    if (function == GET_HEADER)
X	 putc('\n', artfp); /* req'd blank line after header */
X    fseek(artfp, 0L, 0);		/* Then get back to the start */
X    openart = artnum;
X    return artfp;			/* and return either fp or NULL */
X}
X
Xvoid
Xnntpclose()
X{
X    char artname[32];			/* filename of current article */
X    if (our_pid == 0)
X	our_pid = getpid();
X    sprintf(artname, "/tmp/rrn%ld.%ld", (long) openart, our_pid);
X    UNLINK(artname);
X}
X#endif
END_OF_FILE
  if test 4969 -ne `wc -c <'artio.c'`; then
    echo shar: \"'artio.c'\" unpacked with wrong size!
  fi
  # end of 'artio.c'
fi
if test -f 'backpage.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'backpage.c'\"
else
  echo shar: Extracting \"'backpage.c'\" \(2353 characters\)
  sed "s/^X//" >'backpage.c' <<'END_OF_FILE'
X/* $Header: backpage.c,v 4.3.3.2 91/01/16 02:29:46 davison Trn $
X *
X * $Log:	backpage.c,v $
X * Revision 4.3.3.2  91/01/16  02:29:46  davison
X * Integrated rn patches 48-54.
X * 
X * Revision 4.3.3.1  90/06/20  22:36:17  davison
X * Initial Trn Release
X * 
X * Revision 4.3.2.1  90/11/22  16:08:00  sob
X * Made changes to accomodate picky C precompilers
X * 
X * Revision 4.3  85/05/01  11:36:03  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "intrp.h"
X#include "final.h"
X#include "INTERN.h"
X#include "backpage.h"
X
XART_LINE maxindx = -1;
Xlong lseek();
X
Xvoid
Xbackpage_init()
X{
X    char *varyname;
X    
X    varyname = filexp(VARYNAME);
X    close(creat(varyname,0600));
X    varyfd = open(varyname,2);
X    UNLINK(varyname);
X    if (varyfd < 0) {
X	printf(cantopen,varyname) FLUSH;
X	sig_catcher(0);
X    }
X    
X}
X
X/* virtual array read */
X
XART_POS
Xvrdary(indx)
XART_LINE indx;
X{
X    int subindx;
X    long offset;
X
X#ifdef DEBUGGING
X    if (indx > maxindx) {
X	printf("vrdary(%ld) > %ld\n",(long)indx, (long)maxindx) FLUSH;
X	return 0;
X    }
X#endif
X    if (indx < 0)
X	return 0;
X    subindx = indx % VARYSIZE;
X    offset = (indx - subindx) * sizeof(varybuf[0]);
X    if (offset != oldoffset) {
X	if (oldoffset >= 0) {
X#ifndef lint
X	    (void)lseek(varyfd,oldoffset,0);
X	    write(varyfd, (char *)varybuf,sizeof(varybuf));
X#endif /* lint */
X	}
X#ifndef lint
X	(void)lseek(varyfd,offset,0);
X	read(varyfd,(char *)varybuf,sizeof(varybuf));
X#endif /* lint */
X	oldoffset = offset;
X    }
X    return varybuf[subindx];
X}
X
X/* write to virtual array */
X
Xvoid
Xvwtary(indx,newvalue)
XART_LINE indx;
XART_POS newvalue;
X{
X    int subindx;
X    long offset;
X
X#ifdef DEBUGGING
X    if (indx < 0)
X	printf("vwtary(%ld)\n",(long)indx) FLUSH;
X    if (!indx)
X	maxindx = 0;
X    if (indx > maxindx) {
X	if (indx != maxindx + 1)
X	    printf("indx skipped %d-%d\n",maxindx+1,indx-1) FLUSH;
X	maxindx = indx;
X    }
X#endif
X    subindx = indx % VARYSIZE;
X    offset = (indx - subindx) * sizeof(varybuf[0]);
X    if (offset != oldoffset) {
X	if (oldoffset >= 0) {
X#ifndef lint
X	    (void)lseek(varyfd,oldoffset,0);
X	    write(varyfd,(char *)varybuf,sizeof(varybuf));
X#endif /* lint */
X	}
X#ifndef lint
X	(void)lseek(varyfd,offset,0);
X	read(varyfd,(char *)varybuf,sizeof(varybuf));
X#endif /* lint */
X	oldoffset = offset;
X    }
X    varybuf[subindx] = newvalue;
X}
X
END_OF_FILE
  if test 2353 -ne `wc -c <'backpage.c'`; then
    echo shar: \"'backpage.c'\" unpacked with wrong size!
  fi
  # end of 'backpage.c'
fi
if test -f 'getactive.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getactive.c'\"
else
  echo shar: Extracting \"'getactive.c'\" \(1826 characters\)
  sed "s/^X//" >'getactive.c' <<'END_OF_FILE'
X/* $Header: getactive.c,v 1.2 89/11/28 01:50:22 sob Locked $
X *
X * $Log:	getactive.c,v $
X * Revision 1.2  89/11/28  01:50:22  sob
X * Changed so that it won't give makedepend problems with SERVER is not defined.
X * 
X * Revision 1.1  89/11/06  00:50:14  sob
X * Initial revision
X * 
X *
X */
X#include <stdio.h>
X#include "config.h"
X#include "EXTERN.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X
Xmain(argc, argv)
X	int		argc;
X	char	 	*argv[];
X{
X	char		ser_line[256];
X	int		response;
X	register char	*server;
X	register FILE	*actfp;
X
X	if (argc != 2) {
X		fprintf(stderr, "Usage: getactive filename\n");
X		exit(1);
X	}
X
X	server = getserverbyfile(SERVER_FILE);
X	if (server == NULL) {
X		fprintf(stderr, "Couldn't get name of news server from %s\n",
X			SERVER_FILE);
X		fprintf(stderr,
X	  "Either fix this file, or put NNTPSERVER in your environment.\n");
X		exit(1);
X	}
X
X	response = server_init(server);
X	if (response < 0) {
X		fprintf(stderr,
X			"getactive: Can't get active file from server %s.\n",
X				server);
X		exit(1);
X	}
X
X	if (handle_server_response(response, server) < 0)
X		exit(1);
X
X	put_server("LIST");	/* tell server we want the active file */
X	(void) get_server(ser_line, sizeof(ser_line));
X	if (*ser_line != CHAR_OK) {		/* and then see if that's ok */
X		fprintf(stderr,
X			"getactive: Can't get active file from server.\n");
X		fprintf(stderr, "Server said: %s\n", ser_line);
X		exit(1);
X	}
X
X	actfp = fopen(argv[1], "w");		/* and get ready */
X	if (actfp == NULL) {
X		close_server();
X		perror(argv[1]);
X		exit(1);
X	}
X
X	while (get_server(ser_line, sizeof(ser_line)) >= 0) {  /* while */
X		if (ser_line[0] == '.')		/* there's another line */
X			break;			/* get it and write it to */
X		if (actfp != NULL) {		/* the temporary active file */
X			fputs(ser_line, actfp);
X			putc('\n', actfp);
X		}
X	}
X
X	(void) fclose(actfp);
X	close_server();
X}
END_OF_FILE
  if test 1826 -ne `wc -c <'getactive.c'`; then
    echo shar: \"'getactive.c'\" unpacked with wrong size!
  fi
  # end of 'getactive.c'
fi
if test -f 'makedepend.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makedepend.SH'\"
else
  echo shar: Extracting \"'makedepend.SH'\" \(2653 characters\)
  sed "s/^X//" >'makedepend.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting makedepend (with variable substitutions)"
X$spitshell >makedepend <<!GROK!THIS!
X$startsh
X# $Header: makedepend.SH,v 4.3.3.2 91/01/16 02:48:09 davison Trn $
X#
X# $Log:	makedepend.SH,v $
X# Revision 4.3.3.2  91/01/16  02:48:09  davison
X# Integrated rn patches 48-54.
X# 
X# Revision 4.3.3.1  90/06/20  22:38:14  davison
X# Initial Trn Release
X# 
X# Revision 4.3.2.3  90/10/30  22:46:14  sob
X# Made minor changes to the send command to work better on Apollos.
X# 
X# Revision 4.3.2.2  90/04/21  14:24:58  sob
X# Added a fix to deal with XENIX cc -E output.
X# 
X# Revision 4.3.2.1  89/12/17  02:52:46  sob
X# Will only read config.sh from local directory.
X# 
X# Revision 4.3.1.2  85/05/13  15:53:42  lwall
X# Made cpp look in /usr/local/include too.
X# 
X# Revision 4.3.1.1  85/05/10  11:35:10  lwall
X# Branch for patches.
X# 
X# Revision 4.3  85/05/01  11:42:26  lwall
X# Baseline for release with 4.3bsd.
X# 
X
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
X$cat /dev/null >.deptmp
X$echo "(Note: this is going to take a while.)"
X$rm -f X*.c
Xfor file in *.c; do
X    filebase=\`basename \$file .c\`
X    $echo "Finding dependencies for \$filebase.o."
X    $sed -n <\$file >X\$file \\
X	-e "/^\${filebase}_init(/q" \\
X	-e '/^#/{' \\
X	-e 's|/\*.*$||' \\
X	-e p \\
X	-e '}'
X    $cpp -I/usr/local/include X\$file | $sed  \\
X	-e '/^# *line/s/line//' \
X	-e '/^# *[0-9]/!d' \\
X	-e 's/^.*"\(.*\)".*\$/'\$filebase'.o: \1/' \\
X	-e 's|: \./|: |' \\
X	-e 's|: X|: |' | \\
X	$uniq | $sort | $uniq >> .deptmp
Xdone
X
Xfor file in *.SH; do
X    $echo \`basename \$file .SH\`: \$file config.sh \; /bin/sh \$file >> .deptmp
Xdone
X
X$sed <Makefile >Makefile.new -e '1,/^# AUTOMATICALLY/!d'
X
Xif $test -s .deptmp; then
X    echo "Updating Makefile..."
X    echo "# If this runs make out of memory, delete /usr/include lines." >>Makefile.new
X    $sed -e 's/\\\$/\$\$/g' .deptmp >>Makefile.new
Xelse
X    $echo "You don't seem to have a proper C preprocessor.  Using grep instead."
X    $egrep '^#include ' *.c *.h >.deptmp
X    echo "Updating Makefile..."
X    <.deptmp $sed -n 's|c:#include "\(.*\)".*\$\$|o: \1|p' >> Makefile.new
X    <.deptmp $sed -n 's|c:#include <\(.*\)>.*\$\$|o: /usr/include/\1|p' >> Makefile.new
X    <.deptmp $sed -n 's|h:#include "\(.*\)".*\$\$|h: \1|p' >> Makefile.new
X    <.deptmp $sed -n 's|h:#include <\(.*\)>.*\$\$|h: /usr/include/\1|p' >> Makefile.new
Xfi
X$mv Makefile Makefile.old
X$mv Makefile.new Makefile
X$echo "# WARNING: Put nothing here or make depend will gobble it up!" >> Makefile
Xrm .deptmp X*.c
X
X!GROK!THIS!
X$eunicefix makedepend
Xchmod 755 makedepend
END_OF_FILE
  if test 2653 -ne `wc -c <'makedepend.SH'`; then
    echo shar: \"'makedepend.SH'\" unpacked with wrong size!
  fi
  chmod +x 'makedepend.SH'
  # end of 'makedepend.SH'
fi
if test -f 'mbox.saver.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mbox.saver.SH'\"
else
  echo shar: Extracting \"'mbox.saver.SH'\" \(1806 characters\)
  sed "s/^X//" >'mbox.saver.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting mbox.saver (with variable substitutions)"
X$spitshell >mbox.saver <<!GROK!THIS!
X$startsh
X# $Header: mbox.saver.SH,v 4.3.3.1 90/08/20 16:30:28 davison Trn $
X# 
X# $Log:	mbox.saver.SH,v $
X# Revision 4.3.3.1  90/08/20  16:30:28  davison
X# Added support for MMDF format mailboxes.
X# 
X# Revision 4.3.2.3  90/11/22  14:28:27  sob
X# Changed . config.sh to . ./config.sh
X# 
X# Revision 4.3.2.2  90/03/17  20:44:54  sob
X# Modify Article header to place the colon after Article.
X# 
X# Revision 4.3.2.1  89/11/28  00:05:47  sob
X# Branch for RN/RRN combo patches
X# 
X# Revision 4.3.1.2  85/05/20  15:55:37  lwall
X# Turned $5 into \$5.
X# 
X# Revision 4.3.1.1  85/05/10  11:35:30  lwall
X# Branch for patches.
X# 
X# Revision 4.3  85/05/01  11:42:51  lwall
X# Baseline for release with 4.3bsd.
X# 
X# 
X#	Arguments:
X#	1 Full name of article (%A)
X#	2 Public news spool directory (%P)
X#	3 Directory of current newsgroup (%c)
X#	4 Article number (%a)
X#	5 Where in article to start (%B)
X#	6 Newsgroup name (%C)
X#	7 Save destination (%b)
X#	8 First line of message, normally From...
X#
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
X!GROK!THIS!
Xcase $mboxchar in
X"$CTRLA")
X    $spitshell >>mbox.saver <<!GROK!THIS!
X( $echo "$CTRLA$CTRLA$CTRLA$CTRLA"
X  if $test "\$5" = 0 -a ! "\$4" = 0 ; then
X    $echo "Article: \$4 of \$6"
X  fi
X  $tail +\$5c \$1
X  $echo ""
X  $echo ""
X  $echo "$CTRLA$CTRLA$CTRLA$CTRLA" ) >> \$7
X!GROK!THIS!
X    ;;
X*)
X    $spitshell >>mbox.saver <<!GROK!THIS!
X( $echo "\$8"
X  if $test "\$5" = 0 -a ! "\$4" = 0 ; then
X    $echo "Article: \$4 of \$6"
X  fi
X  $tail +\$5c \$1 | $sed "s/^From />From /"
X  $echo ""
X  $echo "" ) >> \$7
X!GROK!THIS!
X    ;;
Xesac
X$eunicefix mbox.saver
Xchmod 755 mbox.saver
END_OF_FILE
  if test 1806 -ne `wc -c <'mbox.saver.SH'`; then
    echo shar: \"'mbox.saver.SH'\" unpacked with wrong size!
  fi
  chmod +x 'mbox.saver.SH'
  # end of 'mbox.saver.SH'
fi
if test -f 'mthreads.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mthreads.h'\"
else
  echo shar: Extracting \"'mthreads.h'\" \(1581 characters\)
  sed "s/^X//" >'mthreads.h' <<'END_OF_FILE'
X/* $Header: mthreads.h,v 4.3.3.3 91/01/16 03:16:33 davison Trn $
X**
X** $Log:	mthreads.h,v $
X** Revision 4.3.3.3  91/01/16  03:16:33  davison
X** Added optional prototyping.
X** 
X** Revision 4.3.3.2  90/08/20  16:44:29  davison
X** New entries for new command-line interface.
X** 
X** Revision 4.3.3.1  90/06/20  22:55:27  davison
X** Initial Trn Release
X** 
X*/
X
X#ifdef lint
X#include "mt-lint.h"
X#endif
X#include "threads.h"
X
XEXT TOTAL total;
X
XEXT int processed_groups;
XEXT int added_articles, added_count;
XEXT int expired_articles, expired_count;
XEXT bool extra_expire INIT(FALSE);
XEXT int caught_interrupt INIT(0);
X
XEXT char *strings INIT(0);
XEXT WORD *subject_cnts INIT(0);
XEXT WORD *author_cnts INIT(0);
XEXT WORD *ids INIT(0);
X
XEXT SUBJECT **subject_array;
XEXT ROOT **root_array;
XEXT AUTHOR **author_array;
XEXT ARTICLE **article_array;
X
XEXT PACKED_ROOT p_root;
XEXT PACKED_ARTICLE p_article;
X
XEXT ROOT *root_root;
XEXT AUTHOR *author_root;
X
X#ifndef DOINIT
XEXT DOMAIN unk_domain;
X#else
XDOMAIN unk_domain = {
X    ".unknown.", NULL, NULL
X};
X#endif
X
Xint ngmatch ANSI((char *,char *));
Xint onepatmatch ANSI((char *,char *));
X
Xvoid log_entry();
Xvoid log_error();
X
Xvoid mybytemap ANSI((BMAP *));
Xint read_data ANSI((void));
Xint write_data ANSI((char *));
Xvoid dont_read_data ANSI((int));
X
Xvoid process_articles ANSI((ART_NUM,ART_NUM));
X
Xchar *thread_name ANSI((char *));
Xchar *file_exp ANSI((char *));
Xchar *savestr ANSI((char *));
X
X#ifndef lint
Xchar *safemalloc ANSI((MEM_SIZE));
Xvoid free();
Xvoid safefree();
X#endif
X
Xtime_t getdate ANSI((char *,time_t,long));
X
X#define Nullart Null(ARTICLE*)
END_OF_FILE
  if test 1581 -ne `wc -c <'mthreads.h'`; then
    echo shar: \"'mthreads.h'\" unpacked with wrong size!
  fi
  # end of 'mthreads.h'
fi
if test -f 'ndir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ndir.c'\"
else
  echo shar: Extracting \"'ndir.c'\" \(2539 characters\)
  sed "s/^X//" >'ndir.c' <<'END_OF_FILE'
X/* $Header: ndir.c,v 4.3.3.2 91/01/16 03:18:03 davison Trn $
X *
X * $Log:	ndir.c,v $
X * Revision 4.3.3.2  91/01/16  03:18:03  davison
X * Integrated rn patches 48-54.
X * 
X * Revision 4.3.3.1  90/06/20  22:38:20  davison
X * Initial Trn Release
X * 
X * Revision 4.3.1.6  90/11/22  16:08:50  sob
X * Added changes to accomodate pick C preprocessors.
X * 
X * Revision 4.3.1.5  90/03/22  23:04:47  sob
X * Fixes provided by Wayne Davison <drivax!davison>
X * 
X * Revision 4.3.1.3  85/05/23  11:19:24  lwall
X * Oops, shouldn't have included sys/types.h again.
X * 
X * Revision 4.3.1.2  85/05/15  14:46:00  lwall
X * Changed short to ino_t, which may be ushort on some systems.
X * 
X * Revision 4.3.1.1  85/05/10  11:35:34  lwall
X * Branch for patches.
X * 
X * Revision 4.3  85/05/01  11:42:55  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "INTERN.h"
X#include "ndir.h"
X
X#ifdef USENDIR
X/*
X * support for Berkeley directory reading routine on a V7 file system
X */
X
X/*
X * open a directory.
X */
XDIR *
Xopendir(name)
Xchar *name;
X{
X	register DIR *dirp;
X	register int fd;
X	char *malloc();
X
X	if ((fd = open(name, 0)) == -1)
X		return NULL;
X	if ((dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
X		close (fd);
X		return NULL;
X	}
X	dirp->dd_fd = fd;
X	dirp->dd_loc = 0;
X	return dirp;
X}
X
X/*
X * read an old style directory entry and present it as a new one
X */
X#ifndef pyr
X#define	ODIRSIZ	14
X
Xstruct	olddirect {
X	ino_t	od_ino;
X	char	od_name[ODIRSIZ];
X};
X#else	an Pyramid in the ATT universe
X#define	ODIRSIZ	248
X
Xstruct	olddirect {
X	long	od_ino;
X	short	od_fill1, od_fill2;
X	char	od_name[ODIRSIZ];
X};
X#endif
X
X/*
X * get next entry in a directory.
X */
Xstruct direct *
Xreaddir(dirp)
Xregister DIR *dirp;
X{
X	register struct olddirect *dp;
X	static struct direct dir;
X
X	for (;;) {
X		if (dirp->dd_loc == 0) {
X			dirp->dd_size = read(dirp->dd_fd, dirp->dd_buf,
X			    DIRBLKSIZ);
X			if (dirp->dd_size <= 0)
X				return NULL;
X		}
X		if (dirp->dd_loc >= dirp->dd_size) {
X			dirp->dd_loc = 0;
X			continue;
X		}
X		dp = (struct olddirect *)(dirp->dd_buf + dirp->dd_loc);
X		dirp->dd_loc += sizeof(struct olddirect);
X		if (dp->od_ino == 0)
X			continue;
X		dir.d_ino = dp->od_ino;
X		strncpy(dir.d_name, dp->od_name, ODIRSIZ);
X		dir.d_name[ODIRSIZ] = '\0'; /* insure null termination */
X		dir.d_namlen = strlen(dir.d_name);
X		dir.d_reclen = DIRSIZ(&dir);
X		return (&dir);
X	}
X}
X
X/*
X * close a directory.
X */
Xvoid
Xclosedir(dirp)
Xregister DIR *dirp;
X{
X	close(dirp->dd_fd);
X	dirp->dd_fd = -1;
X	dirp->dd_loc = 0;
X	free(dirp);
X}
X
X#endif /* USENDIR */
END_OF_FILE
  if test 2539 -ne `wc -c <'ndir.c'`; then
    echo shar: \"'ndir.c'\" unpacked with wrong size!
  fi
  # end of 'ndir.c'
fi
if test -f 'ndir.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ndir.h'\"
else
  echo shar: Extracting \"'ndir.h'\" \(1640 characters\)
  sed "s/^X//" >'ndir.h' <<'END_OF_FILE'
X/* $Header: ndir.h,v 4.3.3.1 91/01/16 03:18:04 davison Trn $
X *
X * $Log:	ndir.h,v $
X * Revision 4.3.3.1  91/01/16  03:18:04  davison
X * Added optional prototyping.
X * 
X * Revision 4.3.2.1  90/04/17  15:28:13  sob
X * Altered to include correct directory include file.
X * 
X * Revision 4.3  85/05/01  11:43:00  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#ifdef LIBNDIR
X#   include <ndir.h>
X#else
X#   ifndef USENDIR
X#	include DIRINC
X#   else
X
X#ifndef DEV_BSIZE
X#define	DEV_BSIZE	512
X#endif
X#define DIRBLKSIZ	DEV_BSIZE
X#define	MAXNAMLEN	255
X
Xstruct	direct {
X	long	d_ino;			/* inode number of entry */
X	short	d_reclen;		/* length of this record */
X	short	d_namlen;		/* length of string in d_name */
X	char	d_name[MAXNAMLEN + 1];	/* name must be no longer than this */
X};
X
X/*
X * The DIRSIZ macro gives the minimum record length which will hold
X * the directory entry.  This requires the amount of space in struct direct
X * without the d_name field, plus enough space for the name with a terminating
X * null byte (dp->d_namlen+1), rounded up to a 4 byte boundary.
X */
X#undef DIRSIZ
X#define DIRSIZ(dp) \
X    ((sizeof (struct direct) - (MAXNAMLEN+1)) + (((dp)->d_namlen+1 + 3) &~ 3))
X
X/*
X * Definitions for library routines operating on directories.
X */
Xtypedef struct _dirdesc {
X	int	dd_fd;
X	long	dd_loc;
X	long	dd_size;
X	char	dd_buf[DIRBLKSIZ];
X} DIR;
X#ifndef NULL
X#define NULL 0
X#endif
Xextern	DIR *opendir ANSI((char *));
Xextern	struct direct *readdir ANSI((DIR *));
Xextern	long telldir ANSI((DIR *));
Xextern	void seekdir ANSI((DIR *));
X#define rewinddir(dirp)	seekdir((dirp), (long)0)
Xextern	void closedir ANSI((DIR *));
X
X#   endif
X#endif
END_OF_FILE
  if test 1640 -ne `wc -c <'ndir.h'`; then
    echo shar: \"'ndir.h'\" unpacked with wrong size!
  fi
  # end of 'ndir.h'
fi
if test -f 'newsetup.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsetup.1'\"
else
  echo shar: Extracting \"'newsetup.1'\" \(1599 characters\)
  sed "s/^X//" >'newsetup.1' <<'END_OF_FILE'
X''' $Header: newsetup.1,v 4.3 85/05/01 11:43:22 lwall Exp $
X''' 
X''' $Log:	newsetup.1,v $
X''' Revision 4.3  85/05/01  11:43:22  lwall
X''' Baseline for release with 4.3bsd.
X''' 
X''' 
X.de Sh
X.br
X.ne 5
X.PP
X\fB\\$1\fR
X.PP
X..
X.de Sp
X.if t .sp .5v
X.if n .sp
X..
X'''
X'''     Set up \*(-- to give an unbreakable dash;
X'''     string Tr holds user defined translation string.
X'''     Bell System Logo is used as a dummy character.
X'''
X.ie n \{\
X.tr \(bs-\*(Tr
X.ds -- \(bs-
X.if (\n(.H=4u)&(1m=24u) .ds -- \(bs\h'-12u'\(bs\h'-12u'-\" diablo 10 pitch
X.if (\n(.H=4u)&(1m=20u) .ds -- \(bs\h'-12u'\(bs\h'-8u'-\" diablo 12 pitch
X.ds L" ""
X.ds R" ""
X.ds L' '
X.ds R' '
X'br\}
X.el\{\
X.ds -- \(em\|
X.tr \*(Tr
X.ds L" ``
X.ds R" ''
X.ds L' `
X.ds R' '
X'br\}
X.TH NEWSETUP 1 LOCAL
X.SH NAME
Xnewsetup - a program to set up a .newsrc file
X.SH SYNOPSIS
X.B newsetup
X.SH DESCRIPTION
XThe
X.I newsetup
Xprogram creates a new .newsrc file containing all of the currently active
Xnewsgroups.
XIt tries to put them in a reasonable order, i.e. local newsgroups earlier,
Xbut you'll probably want to change the ordering anyway (if you use
X.IR rn )
Xin order to put interesting newsgroups first.
XIf you already have a .newsrc, it will be backed up with the name
X\*(L".oldnewsrc\*(R".
X.SH ENVIRONMENT
X.IP DOTDIR 8
XWhere to put your .newsrc, if not in your home directory.
X.Sp
XDefault: $HOME
X.IP HOME 8
XYour home directory.
X.Sp
XDefault: $LOGDIR
X.IP LOGDIR 8
XYour home directory if HOME is undefined.
X.SH FILES
X/usr/lib/news/active or a reasonable facsimile
X.br
X${DOTDIR-{$HOME-$LOGDIR}}/.newsrc
X.SH SEE ALSO
Xrn(1), newsrc(5)
X.SH DIAGNOSTICS
X.SH BUGS
END_OF_FILE
  if test 1599 -ne `wc -c <'newsetup.1'`; then
    echo shar: \"'newsetup.1'\" unpacked with wrong size!
  fi
  # end of 'newsetup.1'
fi
if test -f 'newsetup.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsetup.SH'\"
else
  echo shar: Extracting \"'newsetup.SH'\" \(3690 characters\)
  sed "s/^X//" >'newsetup.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting newsetup (with variable substitutions)"
X$spitshell >newsetup <<!GROK!THIS!
X$startsh
X
X# $Header: newsetup.SH,v 4.3.3.1 91/01/16 03:18:11 davison Trn $
X# 
X# $Log:	newsetup.SH,v $
X# Revision 4.3.3.1  91/01/16  03:18:11  davison
X# Integrated rn patches 48-54.
X# 
X# Revision 4.3.2.8  90/11/22  13:26:55  sob
X# Purged unneeded code.
X# 
X# Revision 4.3.2.7  90/03/17  20:34:48  sob
X# Remove the /tmp/n.* files created when generating the .newsrc.
X# 
X# Revision 4.3.2.6  90/03/17  17:26:42  sob
X# Some versions of sed only take 9 wfiles.
X# 
X# Revision 4.3.2.5  89/11/28  01:15:32  sob
X# Fixed a bug that caused the active file to be removed on non-NNTP-based
X# systems.
X# 
X# Revision 4.3.2.4  89/11/28  00:31:20  sob
X# Changed news.announce.newuser to news.announce.newusers.
X# 
X# Revision 4.3.2.3  89/11/08  01:13:15  sob
X# Finished modifications to make work with RN and RRN
X#
X# Revision 4.3.2.2  89/11/07  23:25:50  sob
X#
X# Added support such that RN and RRN can be made from the same sources.
X# 
X# Revision 4.3.1.2  86/09/05  15:41:04  lwall
X# Changes for newsgroup renaming.
X# 
X# Revision 4.3.1.1  85/05/10  11:35:43  lwall
X# Branch for patches.
X# 
X# Revision 4.3  85/05/01  11:43:05  lwall
X# Baseline for release with 4.3bsd.
X# 
X
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
X: syntax: newsetup
X
X: System dependencies
X: You will want to change the definitions below to reflect the distribution
X: areas around you.  If you have more areas than this you will need to modify
X: the sed below.
X
Xlocorg="$locpref"
Xorganization="$orgpref"
Xcity="$citypref"
Xstate="$statepref"
Xcntry="$cntrypref"
Xcont="$contpref"
X#NORMALactive="${active-/usr/lib/news/active}"
X#NNTPactive="/tmp/active.\$\$"
X
Xdotdir="\${DOTDIR-\${HOME-\$LOGDIR}}"
X$rm -f \$dotdir/.oldnewsrc
X$echo "Creating .newsrc in \$dotdir to be used by news programs."
X#NNTPrnlib=$rnlib
X#NNTPcase \$rnlib in
X#NNTP~*) rnlib=\`$filexp \$rnlib\` ;;
X#NNTPesac
X#NNTP\$rnlib/getactive \$active
X#NORMALcase \$active in
X#NORMAL~*) active=\`$filexp \$active\` ;;
X#NORMALesac
X
Xif $test -s \$dotdir/.newsrc ; then
X    $echo "Saving your current .newsrc as .oldnewsrc..."
X    $mv -f \$dotdir/.newsrc \$dotdir/.oldnewsrc
Xfi
X
X: newsrc order determined here
X
X$sed <\$active '
X	/^to\./d
X	/ [^mny][^ ]*$/d
X	s/ .*//
X	s/^/ /
X	s/^ '\$locorg'\./01&/
X	s/^ '\$organization'\./02&/
X	s/^ '\$city'\./03&/
X	s/^ '\$state'\./04&/
X	s/^ '\$cntry'\./05&/
X	s/^ '\$cont'\./06&/
X	s/^ news\./07&/
X	s/^ comp\./08&/
X	s/^ sci\./09&/
X	s/^ rec\./10&/
X	s/^ soc\./11&/
X	s/^ talk\./13&/
X	s/^ control\$/14&/
X	s/^ junk\$/14&/
X	s/^ test\$/14&/
X	/\.test\$/s/^[0-9]*/14/
X	s/^ .*\./12&/
X	s/^ /00&/
X' |
X$sort -u |
X$sed '
X	/^14 /!s/\$/:/
X	/^14 /s/\$/!/
X	s/^[0-9][0-9] //
X' >\$dotdir/.newsrc
X
X#NNTP$rm -f \$active
X$rm -f /tmp/n.misc\$\$ /tmp/n.sci\$\$ /tmp/n.soc\$\$ /tmp/n.news\$\$ /tmp/n.comp\$\$
X$rm -f /tmp/n.\$cont\$\$ /tmp/n.\$city\$\$ /tmp/n.\$cntry\$\$ /tmp/n.\$state\$\$
X$rm -f /tmp/n.to\$\$ /tmp/n.\$organization\$\$ /tmp/n.\$locorg\$\$ /tmp/n.test\$\$
X$rm -f /tmp/n.tmp\$\$ /tmp/n.local\$\$ /tmp/n.rec\$\$
X
X$cat <<'EOH'
XDone.
X
XIf you have never used the news system before, you may find the articles
Xin news.announce.newusers to be helpful.  There is also a manual entry for rn.
X
XTo get rid of newsgroups you aren't interested in, use the 'u' command.
XType h for help at any time while running rn.
XEOH
X!GROK!THIS!
Xcase "$isrrn" in
Xdefine)  sed < newsetup -e '/^#NNTP/s/^#NNTP//' -e '/^#NORMAL/d' > newsetup.new ;;
X*) sed < newsetup -e '/^#NNTP/d' -e '/^#NORMAL/s/^#NORMAL//' > newsetup.new ;;
Xesac
Xmv newsetup.new newsetup
X$eunicefix newsetup
Xchmod 755 newsetup
END_OF_FILE
  if test 3690 -ne `wc -c <'newsetup.SH'`; then
    echo shar: \"'newsetup.SH'\" unpacked with wrong size!
  fi
  chmod +x 'newsetup.SH'
  # end of 'newsetup.SH'
fi
if test -f 'newsgroups.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsgroups.1'\"
else
  echo shar: Extracting \"'newsgroups.1'\" \(1706 characters\)
  sed "s/^X//" >'newsgroups.1' <<'END_OF_FILE'
X''' $Header: newsgroups.1,v 4.3 85/05/01 11:43:32 lwall Exp $
X''' 
X''' $Log:	newsgroups.1,v $
X''' Revision 4.3  85/05/01  11:43:32  lwall
X''' Baseline for release with 4.3bsd.
X''' 
X''' 
X.de Sh
X.br
X.ne 5
X.PP
X\fB\\$1\fR
X.PP
X..
X.de Sp
X.if t .sp .5v
X.if n .sp
X..
X'''
X'''     Set up \*(-- to give an unbreakable dash;
X'''     string Tr holds user defined translation string.
X'''     Bell System Logo is used as a dummy character.
X'''
X.ie n \{\
X.tr \(bs-\*(Tr
X.ds -- \(bs-
X.if (\n(.H=4u)&(1m=24u) .ds -- \(bs\h'-12u'\(bs\h'-12u'-\" diablo 10 pitch
X.if (\n(.H=4u)&(1m=20u) .ds -- \(bs\h'-12u'\(bs\h'-8u'-\" diablo 12 pitch
X.ds L" ""
X.ds R" ""
X.ds L' '
X.ds R' '
X'br\}
X.el\{\
X.ds -- \(em\|
X.tr \*(Tr
X.ds L" ``
X.ds R" ''
X.ds L' `
X.ds R' '
X'br\}
X.TH NEWSGROUPS 1 LOCAL
X.SH NAME
Xnewsgroups - a program to list unsubscribed newsgroups.
X.SH SYNOPSIS
X.B newsgroups pattern flag
X.SH DESCRIPTION
XThe
X.I newsgroups
Xprogram compares your .newsrc file with the file of active newsgroups,
Xand prints a list of unsubscribed newsgroups matching pattern.
XIf the second argument \*(L"flag\*(R" is present, only newsgroups not
Xfound in your .newsrc are listed, and the display is not paged.
XIf the second argument is missing, the display is paged, and an additional
Xlist of unsubscribed newsgroups occurring in your .newsrc is printed.
X.SH ENVIRONMENT
X.IP DOTDIR 8
XWhere to find your .newsrc, if not in your home directory.
X.Sp
XDefault: $HOME
X.IP HOME 8
XYour home directory.
X.Sp
XDefault: $LOGDIR
X.IP LOGDIR 8
XYour home directory if HOME is undefined.
X.SH FILES
X/usr/lib/news/active or a reasonable facsimile
X.br
X${DOTDIR-{$HOME-$LOGDIR}}/.newsrc
X.SH SEE ALSO
Xrn(1), newsrc(5)
X.SH DIAGNOSTICS
X.SH BUGS
XThe flag argument is a kludge.
END_OF_FILE
  if test 1706 -ne `wc -c <'newsgroups.1'`; then
    echo shar: \"'newsgroups.1'\" unpacked with wrong size!
  fi
  # end of 'newsgroups.1'
fi
if test -f 'newsgroups.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsgroups.SH'\"
else
  echo shar: Extracting \"'newsgroups.SH'\" \(2796 characters\)
  sed "s/^X//" >'newsgroups.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting newsgroups (with variable substitutions)"
X$spitshell >newsgroups <<!GROK!THIS!
X$startsh
X# $Header: newsgroups.SH,v 4.3.3.1 91/01/16 03:18:14 davison Trn $
X# 
X# $Log:	newsgroups.SH,v $
X# Revision 4.3.3.1  91/01/16  03:18:14  davison
X# Integrated rn patches 48-54.
X# 
X# Revision 4.3.2.7  90/04/23  19:30:41  sob
X# Extra space removed to make second part of newsgroups work.
X# Sigh.
X# 
X# Revision 4.3.2.6  90/04/06  20:35:37  sob
X# Added fixes for SCO Xenix sent by ronald@robobar.co.uk.
X# 
X# Revision 4.3.2.5  90/03/17  17:27:00  sob
X# System V sed and BSD sed don't work quite alike. This change uses a
X# syntax that is common between them.
X# 
X# Revision 4.3.2.4  89/11/08  01:13:35  sob
X# Finished modifications to make work with RN and RRN
X# 
X# Revision 4.3.2.3  89/11/07  22:58:04  sob
X# Added final changes to allow rn and rrn to be built from same sources.
X# 
X# Revision 4.3.2.2  89/11/07  22:52:22  sob
X# Added prelimiary support to allow both rrn and rn to be built from same
X# sources.
X# 
X# Revision 4.3.2.1  89/11/06  01:04:39  sob
X# Added RRN support from NNTP 1.5
X# 
X# Revision 4.3  85/05/01  11:43:27  lwall
X# Baseline for release with 4.3bsd.
X# 
X
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
X: syntax: newsgroups [pattern] [pipeflag]
X
X: System Dependencies
X
X: You might want to change pager to a "make column" program if you have one.
X: On the other hand, if your kernel does paging, cat would probably do.
Xpager="${pager-/usr/ucb/more}"
X#NORMALactive="${active-/usr/lib/news/active}"
X
X#NORMALcase \$active in
X#NORMAL~*) active=\`$filexp \$active\` ;;
X#NORMALesac
X
X#NNTPactive="/tmp/active.\$\$"
X
X: End of system dependencies, hopefully
X
X#NNTP$rnlib/getactive \$active
X
Xif $test \$# -ge 2 ; then
X    pager=$cat
Xelse
X    $echo "Completely unsubscribed newsgroups:"
Xfi
X
Xdotdir=\${DOTDIR-\${HOME-\$LOGDIR}}
X
X: Throwing .newsrc into the pot twice is a lovely hack to prevent
X: bogus newsgroups from showing up as unsubscribed.
X
X$cat \$dotdir/.newsrc \$dotdir/.newsrc \$active | \\
X$sed -n	-e '/^options/d' \\
X	-e '/^[	 ]/d' \\
X	-e '/^control/d' \\
X	-e '/^to\./d' \\
X	-e 's/^\([^ !:]*\)[ !:].*\$/\1/' \\
X	-e "/.*\$1/p" | \\
X$sort | $uniq -u | \$pager
Xif $test \$# -ge 2 ; then
X    exit
Xfi
X$echo $n "[Type return to continue] $c"
Xread tmp
X$echo ""
X$echo "Unsubscribed but mentioned in .newsrc:"
X$sed -n < \$dotdir/.newsrc \\
X	-e "/\$1.*!/"'s/^\([^!]*\)!.*\$/\1/p' | \\
X$sort | \$pager
X!GROK!THIS!
Xcase "$isrrn" in
Xdefine)  sed < newsgroups -e '/^#NNTP/s/^#NNTP//' -e '/^#NORMAL/d' > newsgroups.new ;;
X*) sed < newsgroups -e '/^#NNTP/d' -e '/^#NORMAL/s/^#NORMAL//' > newsgroups.new ;;
Xesac
Xmv newsgroups.new newsgroups
X$eunicefix newsgroups
Xchmod 755 newsgroups
END_OF_FILE
  if test 2796 -ne `wc -c <'newsgroups.SH'`; then
    echo shar: \"'newsgroups.SH'\" unpacked with wrong size!
  fi
  chmod +x 'newsgroups.SH'
  # end of 'newsgroups.SH'
fi
if test -f 'ngsrch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ngsrch.c'\"
else
  echo shar: Extracting \"'ngsrch.c'\" \(2770 characters\)
  sed "s/^X//" >'ngsrch.c' <<'END_OF_FILE'
X/* $Header: ngsrch.c,v 4.3 85/05/01 11:44:51 lwall Exp $
X *
X * $Log:	ngsrch.c,v $
X * Revision 4.3  85/05/01  11:44:51  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "rcstuff.h"
X#include "final.h"
X#include "search.h"
X#include "rn.h"
X#include "util.h"
X#include "term.h"
X#include "rcln.h"
X#include "INTERN.h"
X#include "ngsrch.h"
X
X#ifdef NGSORONLY
X    COMPEX ngcompex;
X#endif
X
Xvoid
Xngsrch_init()
X{
X#ifdef ZEROGLOB
X    init_compex(&ngcompex);
X#endif	/* ZEROGLOB */
X    ;
X}
X
X#ifdef NGSEARCH
Xint
Xng_search(patbuf,get_cmd)
Xchar *patbuf;				/* if patbuf != buf, get_cmd must */
Xint get_cmd;				/*   be set to FALSE!!! */
X{
X    char *pattern;			/* unparsed pattern */
X    register char cmdchr = *patbuf;	/* what kind of search? */
X    register char *s;
X    bool backward = cmdchr == '?';	/* direction of search */
X
X    int_count = 0;
X    if (get_cmd && buf == patbuf)
X	if (!finish_command(FALSE))		/* get rest of command */
X	    return NGS_ABORT;
X    for (pattern = patbuf+1; *pattern == ' '; pattern++) ;
X    if (*pattern) {
X	ng_doread = FALSE;
X    }
X    s = rindex(pattern,cmdchr);
X    if (s != Nullch && *(s-1) != '\\') {
X	*s++ = '\0';
X	if (index(s,'r') != Nullch)
X	    ng_doread = TRUE;
X    }
X    if ((s = ng_comp(&ngcompex,pattern,TRUE,TRUE)) != Nullch) {
X					/* compile regular expression */
X	printf("\n%s\n",s) FLUSH;
X	return NGS_ABORT;
X    }
X    fputs("\nSearching...",stdout) FLUSH;	/* give them something to read */
X    fflush(stdout);
X    for (;;) {
X	if (int_count) {
X	    int_count = 0;
X	    return NGS_INTR;
X	}
X	if (backward) {
X	    if (ng > 0)
X		--ng;
X	    else
X		ng = nextrcline;
X	}
X	else {
X	    if (ng >= nextrcline)
X		ng = 0;
X	    else
X		++ng;
X	}
X	if (ng == current_ng)
X	    return NGS_NOTFOUND;
X	if (ng == nextrcline || toread[ng] < TR_NONE || !ng_wanted())
X	    continue;
X	if (toread[ng] == TR_NONE)
X	    set_toread(ng);
X	
X	if (toread[ng] > TR_NONE)
X	    return NGS_FOUND;
X	else if (toread[ng] == TR_NONE)
X	    if (ng_doread)
X		return NGS_FOUND;
X	    else
X		printf("\n[0 unread in %s--skipping]",rcline[ng]) FLUSH;
X    }
X}
X
Xbool
Xng_wanted()
X{
X    return execute(&ngcompex,rcline[ng]) != Nullch;
X}
X#endif
X
X#ifdef NGSORONLY
Xchar *
Xng_comp(compex,pattern,RE,fold)
XCOMPEX *compex;
Xchar *pattern;
Xbool RE;
Xbool fold;
X{
X    char ng_pattern[128];
X    register char *s = pattern, *d = ng_pattern;
X
X    if (!*s)
X	return Nullch;			/* reuse old pattern */
X    for (; *s; s++) {
X	if (*s == '.') {
X	    *d++ = '\\';
X	    *d++ = *s;
X	}
X	else if (*s == '?') {
X	    *d++ = '.';
X	}
X	else if (*s == '*') {
X	    *d++ = '.';
X	    *d++ = *s;
X	}
X	else if (strnEQ(s,"all",3)) {
X	    *d++ = '.';
X	    *d++ = '*';
X	    s += 2;
X	}
X	else
X	    *d++ = *s;
X    }
X    *d = '\0';
X    return compile(compex,ng_pattern,RE,fold);
X}
X#endif
X
END_OF_FILE
  if test 2770 -ne `wc -c <'ngsrch.c'`; then
    echo shar: \"'ngsrch.c'\" unpacked with wrong size!
  fi
  # end of 'ngsrch.c'
fi
if test -f 'only.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'only.c'\"
else
  echo shar: Extracting \"'only.c'\" \(2551 characters\)
  sed "s/^X//" >'only.c' <<'END_OF_FILE'
X/* $Header: only.c,v 4.3.3.2 91/01/16 03:26:16 davison Trn $
X *
X * $Log:	only.c,v $
X * Revision 4.3.3.2  91/01/16  03:26:16  davison
X * Integrated rn patches 48-54.
X * 
X * Revision 4.3.3.1  90/06/20  22:39:13  davison
X * Initial Trn Release
X * 
X * Revision 4.3.2.1  90/11/22  16:11:20  sob
X * Added changes to accomodate pickly C preprocessors.
X * 
X * Revision 4.3  85/05/01  11:45:21  lwall
X * Baseline for release with 4.3bsd.
X * 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "search.h"
X#include "util.h"
X#include "final.h"
X#include "ngsrch.h"
X#include "INTERN.h"
X#include "only.h"
X
Xvoid
Xonly_init()
X{
X    ;
X}
X
Xvoid
Xsetngtodo(pat)
Xchar *pat;
X{
X    char *s;
X
X#ifdef ONLY
X    if (!*pat)
X	return;
X    if (maxngtodo < NGMAX) {
X	ngtodo[maxngtodo] = savestr(pat);
X#ifdef SPEEDOVERMEM
X#ifndef lint
X	compextodo[maxngtodo] = (COMPEX*)safemalloc(sizeof(COMPEX));
X#endif /* lint */
X	init_compex(compextodo[maxngtodo]);
X	compile(compextodo[maxngtodo],pat,TRUE,TRUE);
X	if ((s = ng_comp(compextodo[maxngtodo],pat,TRUE,TRUE)) != Nullch) {
X					    /* compile regular expression */
X	    printf("\n%s\n",s) FLUSH;
X	    finalize(1);
X	}
X#endif
X	maxngtodo++;
X    }
X#else
X    notincl("o");
X#endif
X}
X
X/* if command line list is non-null, is this newsgroup wanted? */
X
Xbool
Xinlist(ngnam)
Xchar *ngnam;
X{
X#ifdef ONLY
X    register int i;
X#ifdef SPEEDOVERMEM
X
X    if (maxngtodo == 0)
X	return TRUE;
X    for (i=0; i<maxngtodo; i++) {
X	if (execute(compextodo[i],ngnam))
X	    return TRUE;
X    }
X    return FALSE;
X#else
X    COMPEX ilcompex;
X    char *s;
X
X    if (maxngtodo == 0)
X	return TRUE;
X    init_compex(&ilcompex);
X    for (i=0; i<maxngtodo; i++) {
X	if ((s = ng_comp(&ilcompex,ngtodo[i],TRUE,TRUE)) != Nullch) {
X					    /* compile regular expression */
X	    printf("\n%s\n",s) FLUSH;
X	    finalize(1);
X	}
X	
X	if (execute(&ilcompex,ngnam) != Nullch) {
X	    free_compex(&ilcompex);
X	    return TRUE;
X	}
X    }
X    free_compex(&ilcompex);
X    return FALSE;
X#endif
X#else
X    return TRUE;
X#endif
X}
X
X#ifdef ONLY
Xvoid
Xend_only()
X{
X    if (maxngtodo) {			/* did they specify newsgroup(s) */
X	int whicharg;
X
X#ifdef VERBOSE
X	IF(verbose)
X	    printf("\nRestriction %s%s removed.\n",ngtodo[0],
X		maxngtodo > 1 ? ", etc." : nullstr) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    fputs("\nExiting \"only\".\n",stdout) FLUSH;
X#endif
X	for (whicharg = 0; whicharg < maxngtodo; whicharg++) {
X	    free(ngtodo[whicharg]);
X#ifdef SPEEDOVERMEM
X	    free_compex(compextodo[whicharg]);
X#ifndef lint
X	    free((char*)compextodo[whicharg]);
X#endif /* lint */
X#endif
X	}
X	maxngtodo = 0;
X    }
X}
X#endif
END_OF_FILE
  if test 2551 -ne `wc -c <'only.c'`; then
    echo shar: \"'only.c'\" unpacked with wrong size!
  fi
  # end of 'only.c'
fi
if test -f 'rthreads.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rthreads.h'\"
else
  echo shar: Extracting \"'rthreads.h'\" \(1674 characters\)
  sed "s/^X//" >'rthreads.h' <<'END_OF_FILE'
X/* $Header: rthreads.h,v 4.3.3.2 91/01/16 03:28:54 davison Trn $
X**
X** $Log:	rthreads.h,v $
X** Revision 4.3.3.2  91/01/16  03:28:54  davison
X** Added optional prototyping.
X** 
X** Revision 4.3.3.1  90/06/20  22:56:01  davison
X** Initial Trn Release
X** 
X*/
X
X#include "threads.h"
X
XEXT TOTAL total;
X
XEXT PACKED_ROOT *p_roots INIT(0);
XEXT WORD *root_subjects INIT(0);
XEXT WORD *author_cnts INIT(0);
XEXT WORD *subject_cnts INIT(0);
XEXT char **author_ptrs INIT(0);
XEXT char **subject_ptrs INIT(0);
XEXT PACKED_ARTICLE *p_articles INIT(0);
XEXT WORD *root_article_cnts INIT(0);
XEXT char *selected_roots INIT(0);
XEXT ART_NUM *saved_selections INIT(0);
XEXT bool unread_selector INIT(0);
X
XEXT PACKED_ARTICLE *p_art INIT(0);
XEXT PACKED_ARTICLE *curr_p_art INIT(0);
XEXT PACKED_ARTICLE *recent_p_art INIT(0);
X
XEXT int selected_root_cnt INIT(0);
XEXT ART_NUM selected_count INIT(0);
XEXT int unthreaded INIT(0);
XEXT int select_page;
XEXT bool scan_all_roots;
X
XEXT bool word_same, long_same;
XEXT BMAP my_bmap, mt_bmap;
X
Xvoid thread_init ANSI((void));
Xvoid mybytemap ANSI((BMAP *));
Xchar *thread_name ANSI((char *));
Xchar *safemalloc ANSI((MEM_SIZE));
Xint use_data ANSI((char *));
Xvoid unuse_data ANSI((bool));
Xvoid find_article ANSI((ART_NUM));
Xvoid init_tree ANSI((void));
Xvoid entire_tree ANSI((void));
Xint tree_puts ANSI((char *,ART_LINE,int));
Xint finish_tree ANSI((ART_LINE));
Xvoid first_art ANSI((void));
Xvoid follow_thread ANSI((char));
Xvoid next_root ANSI((void));
Xvoid prev_root ANSI((void));
Xchar select_thread ANSI((char));
Xint count_roots ANSI((bool));
Xint count_one_root ANSI((int));
XPACKED_ARTICLE *upper_limit ANSI((PACKED_ARTICLE *,bool));
X
X#define Nullart Null(PACKED_ARTICLE*)
END_OF_FILE
  if test 1674 -ne `wc -c <'rthreads.h'`; then
    echo shar: \"'rthreads.h'\" unpacked with wrong size!
  fi
  # end of 'rthreads.h'
fi
if test -f 'threads.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'threads.c'\"
else
  echo shar: Extracting \"'threads.c'\" \(2230 characters\)
  sed "s/^X//" >'threads.c' <<'END_OF_FILE'
X/* $Header: threads.c,v 4.3.3.2 90/08/20 16:49:38 davison Trn $
X**
X** $Log:	threads.c,v $
X** Revision 4.3.3.2  90/08/20  16:49:38  davison
X** Enlarged path buffers to be more consistent.
X** 
X** Revision 4.3.3.1  90/07/21  20:33:23  davison
X** Initial Trn Release
X** 
X*/
X
X#include "EXTERN.h"
X#include "common.h"
X#include "threads.h"
X
X#ifdef USETHREADS
X
X/* Change a newsgroup name into the name of the thread data file.  We
X** subsitute any '.'s in the group name into '/'s (unless LONG_THREAD_NAMES
X** is defined), prepend the path, and append the '/.thread' (or '.th') on to
X** the end.
X*/
Xchar *
Xthread_name( group )
Xchar *group;
X{
X    register char *ptr;
X    static char name_buff[512];
X#ifndef LONG_THREAD_NAMES
X    char group_buff[512];
X
X    strcpy( group_buff, group);
X    ptr = group = group_buff;
X    while( (ptr = index( ptr, '.' )) ) {
X	*ptr = '/';
X    }
X#endif
X#ifdef SUFFIX
X    sprintf( name_buff, "%s/%s%s", THREAD_DIR, group, SUFFIX );
X#else
X    sprintf( name_buff, "%s/%s", THREAD_DIR, group );
X#endif
X
X    return name_buff;
X}
X
X/* Determine this machine's byte map for WORDs and LONGs.  A byte map is an
X** array of BYTEs (sizeof (WORD) or sizeof (LONG) of them) with the 0th BYTE
X** being the byte number of the high-order byte in my <type>, and so forth.
X*/
Xvoid
Xmybytemap( map )
XBMAP *map;
X{
X    union {
X	BYTE b[sizeof (LONG)];
X	WORD w;
X	LONG l;
X    } u;
X    register BYTE *mp;
X    register int i, j;
X
X    mp = &map->w[sizeof (WORD)];
X    u.w = 1;
X    for( i = sizeof (WORD); i > 0; i-- ) {
X	for( j = 0; j < sizeof (WORD); j++ ) {
X	    if( u.b[j] != 0 ) {
X		break;
X	    }
X	}
X	if( j == sizeof (WORD) ) {
X	    goto bad_news;
X	}
X	*--mp = j;
X	while( u.b[j] != 0 && u.w ) {
X	    u.w <<= 1;
X	}
X    }
X
X    mp = &map->l[sizeof (LONG)];
X    u.l = 1;
X    for( i = sizeof (LONG); i > 0; i-- ) {
X	for( j = 0; j < sizeof (LONG); j++ ) {
X	    if( u.b[j] != 0 ) {
X		break;
X	    }
X	}
X	if( j == sizeof (LONG) ) {
X	  bad_news:
X	    /* trouble -- set both to *something* consistent */
X	    for( j = 0; j < sizeof (WORD); j++ ) {
X		map->w[j] = j;
X	    }
X	    for( j = 0; j < sizeof (LONG); j++ ) {
X		map->l[j] = j;
X	    }
X	    return;
X	}
X	*--mp = j;
X	while( u.b[j] != 0 && u.l ) {
X	    u.l <<= 1;
X	}
X    }
X}
X
X#endif /* USETHREADS */
END_OF_FILE
  if test 2230 -ne `wc -c <'threads.c'`; then
    echo shar: \"'threads.c'\" unpacked with wrong size!
  fi
  # end of 'threads.c'
fi
if test -f 'threads.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'threads.h'\"
else
  echo shar: Extracting \"'threads.h'\" \(1989 characters\)
  sed "s/^X//" >'threads.h' <<'END_OF_FILE'
X/* $Header: threads.h,v 4.3.3.2 90/08/20 16:50:09 davison Trn $
X**
X** $Log:	threads.h,v $
X** Revision 4.3.3.2  90/08/20  16:50:09  davison
X** Padded odd-boundaried arrays.  Upgraded database version #.
X** 
X** Revision 4.3.3.1  90/06/20  22:56:18  davison
X** Initial Trn Release
X** 
X*/
X
X#define DB_VERSION	2
X
Xtypedef char		BYTE;
Xtypedef short		WORD;
Xtypedef long		LONG;
X
X#define ROOT_ARTICLE	0x0001		/* article flag definitions */
X#define NEW_ARTICLE	0x0002		/* to avoid stat'ing new articles */
X
Xtypedef struct Article {
X    ART_NUM num;
X    char *id;
X    struct Domain *domain;
X    struct Subject *subject;
X    struct Author *author;
X    struct Article *parent, *children, *siblings;
X    struct Root *root;
X    struct Article *id_link;
X    time_t date;
X    WORD child_cnt;
X    WORD flags;
X    WORD seq;
X} ARTICLE;
X
Xtypedef struct Domain {
X    char *name;
X    ARTICLE *ids;
X    struct Domain *link;
X} DOMAIN;
X
Xtypedef struct Author {
X    struct Author *link;		/* this link MUST be first */
X    char *name;
X    WORD seq;
X    WORD count;
X} AUTHOR;
X
Xtypedef struct Subject {
X    struct Subject *link;
X    char *str;
X    WORD seq;
X    WORD count;
X} SUBJECT;
X
Xtypedef struct Root {
X    struct Root *link;			/* this link MUST be first */
X    ARTICLE *articles;
X    SUBJECT *subjects;
X    ART_NUM root_num;
X    WORD thread_cnt;
X    WORD subject_cnt;
X    WORD seq;
X} ROOT;
X
Xtypedef struct {
X    LONG root_num;
X    WORD articles;
X    WORD thread_cnt;
X    WORD subject_cnt;
X    WORD pad_hack;
X} PACKED_ROOT;
X
Xtypedef struct {
X    LONG num;
X    LONG date;
X    WORD subject, author;
X    WORD flags;
X    WORD child_cnt;
X    WORD parent, children, siblings;
X    WORD root;
X} PACKED_ARTICLE;
X
Xtypedef struct Total {
X    LONG first, last;
X    LONG string1;
X    LONG string2;
X    WORD root;
X    WORD article;
X    WORD subject;
X    WORD author;
X    WORD domain;
X    WORD pad_hack;
X} TOTAL;
X
Xtypedef struct {
X    BYTE l[sizeof (LONG)];
X    BYTE w[sizeof (WORD)];
X    BYTE version;
X    BYTE pad_hack;
X} BMAP;
END_OF_FILE
  if test 1989 -ne `wc -c <'threads.h'`; then
    echo shar: \"'threads.h'\" unpacked with wrong size!
  fi
  # end of 'threads.h'
fi
echo shar: End of archive 13 \(of 14\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
