Subject:  v23i041:  Flex, a fast lex replacement, Part05/10
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: ec57c692 265e2299 7f1a36e3 d2f59402

Submitted-by: Vern Paxson <vern@cs.cornell.edu>
Posting-number: Volume 23, Issue 41
Archive-name: flex2.3/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  flexdef.h main.c
# Wrapped by rsalz@litchi.bbn.com on Wed Oct 10 13:24:01 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 10)."'
if test -f 'flexdef.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flexdef.h'\"
else
  echo shar: Extracting \"'flexdef.h'\" \(29063 characters\)
  sed "s/^X//" >'flexdef.h' <<'END_OF_FILE'
X/* flexdef - definitions file for flex */
X
X/*-
X * Copyright (c) 1990 The Regents of the University of California.
X * All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Vern Paxson.
X * 
X * The United States Government has rights in this work pursuant
X * to contract no. DE-AC03-76SF00098 between the United States
X * Department of Energy and the University of California.
X *
X * Redistribution and use in source and binary forms are permitted provided
X * that: (1) source distributions retain this entire copyright notice and
X * comment, and (2) distributions including binaries display the following
X * acknowledgement:  ``This product includes software developed by the
X * University of California, Berkeley and its contributors'' in the
X * documentation or other materials provided with the distribution and in
X * all advertising materials mentioning features or use of this software.
X * Neither the name of the University nor the names of its contributors may
X * be used to endorse or promote products derived from this software without
X * specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X/* @(#) $Header: /usr/fsys/odin/a/vern/flex/RCS/flexdef.h,v 2.10 90/08/03 14:09:52 vern Exp $ (LBL) */
X
X#ifndef FILE
X#include <stdio.h>
X#endif
X
X/* always be prepared to generate an 8-bit scanner */
X#define FLEX_8_BIT_CHARS
X
X#ifdef FLEX_8_BIT_CHARS
X#define CSIZE 256
X#define Char unsigned char
X#else
X#define Char char
X#define CSIZE 128
X#endif
X
X/* size of input alphabet - should be size of ASCII set */
X#ifndef DEFAULT_CSIZE
X#define DEFAULT_CSIZE 128
X#endif
X
X#ifndef PROTO
X#ifdef __STDC__
X#define PROTO(proto) proto
X#else
X#define PROTO(proto) ()
X#endif
X#endif
X
X
X#ifdef USG
X#define SYS_V
X#endif
X
X#ifdef SYS_V
X#include <string.h>
X#else
X
X#include <strings.h>
X#ifdef lint
Xchar *sprintf(); /* keep lint happy */
X#endif
X#ifdef SCO_UNIX
Xvoid *memset();
X#else
Xchar *memset();
X#endif
X#endif
X
X#ifdef AMIGA
X#define bzero(s, n) setmem((char *)(s), n, '\0')
X#ifndef abs
X#define abs(x) ((x) < 0 ? -(x) : (x))
X#endif
X#else
X#define bzero(s, n) (void) memset((char *)(s), '\0', n)
X#endif
X
X#ifdef VMS
X#define unlink delete
X#define SHORT_FILE_NAMES
X#endif
X
X#ifdef __STDC__
X
X#ifdef __GNUC__
X#include <stddef.h>
Xvoid *malloc( size_t );
Xvoid free( void* );
X#else
X#include <stdlib.h>
X#endif
X
X#else	/* ! __STDC__ */
Xchar *malloc(), *realloc();
X#endif
X
X
X/* maximum line length we'll have to deal with */
X#define MAXLINE BUFSIZ
X
X/* maximum size of file name */
X#define FILENAMESIZE 1024
X
X#ifndef min
X#define min(x,y) ((x) < (y) ? (x) : (y))
X#endif
X#ifndef max
X#define max(x,y) ((x) > (y) ? (x) : (y))
X#endif
X
X#ifdef MS_DOS
X#ifndef abs
X#define abs(x) ((x) < 0 ? -(x) : (x))
X#endif
X#define SHORT_FILE_NAMES
X#endif
X
X#define true 1
X#define false 0
X
X
X#ifndef DEFAULT_SKELETON_FILE
X#define DEFAULT_SKELETON_FILE "flex.skel"
X#endif
X
X/* special chk[] values marking the slots taking by end-of-buffer and action
X * numbers
X */
X#define EOB_POSITION -1
X#define ACTION_POSITION -2
X
X/* number of data items per line for -f output */
X#define NUMDATAITEMS 10
X
X/* number of lines of data in -f output before inserting a blank line for
X * readability.
X */
X#define NUMDATALINES 10
X
X/* transition_struct_out() definitions */
X#define TRANS_STRUCT_PRINT_LENGTH 15
X
X/* returns true if an nfa state has an epsilon out-transition slot
X * that can be used.  This definition is currently not used.
X */
X#define FREE_EPSILON(state) \
X	(transchar[state] == SYM_EPSILON && \
X	 trans2[state] == NO_TRANSITION && \
X	 finalst[state] != state)
X
X/* returns true if an nfa state has an epsilon out-transition character
X * and both slots are free
X */
X#define SUPER_FREE_EPSILON(state) \
X	(transchar[state] == SYM_EPSILON && \
X	 trans1[state] == NO_TRANSITION) \
X
X/* maximum number of NFA states that can comprise a DFA state.  It's real
X * big because if there's a lot of rules, the initial state will have a
X * huge epsilon closure.
X */
X#define INITIAL_MAX_DFA_SIZE 750
X#define MAX_DFA_SIZE_INCREMENT 750
X
X
X/* a note on the following masks.  They are used to mark accepting numbers
X * as being special.  As such, they implicitly limit the number of accepting
X * numbers (i.e., rules) because if there are too many rules the rule numbers
X * will overload the mask bits.  Fortunately, this limit is \large/ (0x2000 ==
X * 8192) so unlikely to actually cause any problems.  A check is made in
X * new_rule() to ensure that this limit is not reached.
X */
X
X/* mask to mark a trailing context accepting number */
X#define YY_TRAILING_MASK 0x2000
X
X/* mask to mark the accepting number of the "head" of a trailing context rule */
X#define YY_TRAILING_HEAD_MASK 0x4000
X
X/* maximum number of rules, as outlined in the above note */
X#define MAX_RULE (YY_TRAILING_MASK - 1)
X
X
X/* NIL must be 0.  If not, its special meaning when making equivalence classes
X * (it marks the representative of a given e.c.) will be unidentifiable
X */
X#define NIL 0
X
X#define JAM -1	/* to mark a missing DFA transition */
X#define NO_TRANSITION NIL
X#define UNIQUE -1	/* marks a symbol as an e.c. representative */
X#define INFINITY -1	/* for x{5,} constructions */
X
X#define INITIAL_MAX_CCLS 100	/* max number of unique character classes */
X#define MAX_CCLS_INCREMENT 100
X
X/* size of table holding members of character classes */
X#define INITIAL_MAX_CCL_TBL_SIZE 500
X#define MAX_CCL_TBL_SIZE_INCREMENT 250
X
X#define INITIAL_MAX_RULES 100	/* default maximum number of rules */
X#define MAX_RULES_INCREMENT 100
X
X#define INITIAL_MNS 2000	/* default maximum number of nfa states */
X#define MNS_INCREMENT 1000	/* amount to bump above by if it's not enough */
X
X#define INITIAL_MAX_DFAS 1000	/* default maximum number of dfa states */
X#define MAX_DFAS_INCREMENT 1000
X
X#define JAMSTATE -32766	/* marks a reference to the state that always jams */
X
X/* enough so that if it's subtracted from an NFA state number, the result
X * is guaranteed to be negative
X */
X#define MARKER_DIFFERENCE 32000
X#define MAXIMUM_MNS 31999
X
X/* maximum number of nxt/chk pairs for non-templates */
X#define INITIAL_MAX_XPAIRS 2000
X#define MAX_XPAIRS_INCREMENT 2000
X
X/* maximum number of nxt/chk pairs needed for templates */
X#define INITIAL_MAX_TEMPLATE_XPAIRS 2500
X#define MAX_TEMPLATE_XPAIRS_INCREMENT 2500
X
X#define SYM_EPSILON (CSIZE + 1)	/* to mark transitions on the symbol epsilon */
X
X#define INITIAL_MAX_SCS 40	/* maximum number of start conditions */
X#define MAX_SCS_INCREMENT 40	/* amount to bump by if it's not enough */
X
X#define ONE_STACK_SIZE 500	/* stack of states with only one out-transition */
X#define SAME_TRANS -1	/* transition is the same as "default" entry for state */
X
X/* the following percentages are used to tune table compression:
X
X * the percentage the number of out-transitions a state must be of the
X * number of equivalence classes in order to be considered for table
X * compaction by using protos
X */
X#define PROTO_SIZE_PERCENTAGE 15
X
X/* the percentage the number of homogeneous out-transitions of a state
X * must be of the number of total out-transitions of the state in order
X * that the state's transition table is first compared with a potential 
X * template of the most common out-transition instead of with the first
X * proto in the proto queue
X */
X#define CHECK_COM_PERCENTAGE 50
X
X/* the percentage the number of differences between a state's transition
X * table and the proto it was first compared with must be of the total
X * number of out-transitions of the state in order to keep the first
X * proto as a good match and not search any further
X */
X#define FIRST_MATCH_DIFF_PERCENTAGE 10
X
X/* the percentage the number of differences between a state's transition
X * table and the most similar proto must be of the state's total number
X * of out-transitions to use the proto as an acceptable close match
X */
X#define ACCEPTABLE_DIFF_PERCENTAGE 50
X
X/* the percentage the number of homogeneous out-transitions of a state
X * must be of the number of total out-transitions of the state in order
X * to consider making a template from the state
X */
X#define TEMPLATE_SAME_PERCENTAGE 60
X
X/* the percentage the number of differences between a state's transition
X * table and the most similar proto must be of the state's total number
X * of out-transitions to create a new proto from the state
X */
X#define NEW_PROTO_DIFF_PERCENTAGE 20
X
X/* the percentage the total number of out-transitions of a state must be
X * of the number of equivalence classes in order to consider trying to
X * fit the transition table into "holes" inside the nxt/chk table.
X */
X#define INTERIOR_FIT_PERCENTAGE 15
X
X/* size of region set aside to cache the complete transition table of
X * protos on the proto queue to enable quick comparisons
X */
X#define PROT_SAVE_SIZE 2000
X
X#define MSP 50	/* maximum number of saved protos (protos on the proto queue) */
X
X/* maximum number of out-transitions a state can have that we'll rummage
X * around through the interior of the internal fast table looking for a
X * spot for it
X */
X#define MAX_XTIONS_FULL_INTERIOR_FIT 4
X
X/* maximum number of rules which will be reported as being associated
X * with a DFA state
X */
X#define MAX_ASSOC_RULES 100
X
X/* number that, if used to subscript an array, has a good chance of producing
X * an error; should be small enough to fit into a short
X */
X#define BAD_SUBSCRIPT -32767
X
X/* absolute value of largest number that can be stored in a short, with a
X * bit of slop thrown in for general paranoia.
X */
X#define MAX_SHORT 32766
X
X
X/* Declarations for global variables. */
X
X/* variables for symbol tables:
X * sctbl - start-condition symbol table
X * ndtbl - name-definition symbol table
X * ccltab - character class text symbol table
X */
X
Xstruct hash_entry
X    {
X    struct hash_entry *prev, *next;
X    char *name;
X    char *str_val;
X    int int_val;
X    } ;
X
Xtypedef struct hash_entry *hash_table[];
X
X#define NAME_TABLE_HASH_SIZE 101
X#define START_COND_HASH_SIZE 101
X#define CCL_HASH_SIZE 101
X
Xextern struct hash_entry *ndtbl[NAME_TABLE_HASH_SIZE]; 
Xextern struct hash_entry *sctbl[START_COND_HASH_SIZE];
Xextern struct hash_entry *ccltab[CCL_HASH_SIZE];
X
X
X/* variables for flags:
X * printstats - if true (-v), dump statistics
X * syntaxerror - true if a syntax error has been found
X * eofseen - true if we've seen an eof in the input file
X * ddebug - if true (-d), make a "debug" scanner
X * trace - if true (-T), trace processing
X * spprdflt - if true (-s), suppress the default rule
X * interactive - if true (-I), generate an interactive scanner
X * caseins - if true (-i), generate a case-insensitive scanner
X * useecs - if true (-Ce flag), use equivalence classes
X * fulltbl - if true (-Cf flag), don't compress the DFA state table
X * usemecs - if true (-Cm flag), use meta-equivalence classes
X * fullspd - if true (-F flag), use Jacobson method of table representation
X * gen_line_dirs - if true (i.e., no -L flag), generate #line directives
X * performance_report - if true (i.e., -p flag), generate a report relating
X *   to scanner performance
X * backtrack_report - if true (i.e., -b flag), generate "lex.backtrack" file
X *   listing backtracking states
X * csize - size of character set for the scanner we're generating;
X *   128 for 7-bit chars and 256 for 8-bit
X * yymore_used - if true, yymore() is used in input rules
X * reject - if true, generate backtracking tables for REJECT macro
X * real_reject - if true, scanner really uses REJECT (as opposed to just
X *   having "reject" set for variable trailing context)
X * continued_action - true if this rule's action is to "fall through" to
X *   the next rule's action (i.e., the '|' action)
X * yymore_really_used - has a REALLY_xxx value indicating whether a
X *   %used or %notused was used with yymore()
X * reject_really_used - same for REJECT
X */
X
Xextern int printstats, syntaxerror, eofseen, ddebug, trace, spprdflt;
Xextern int interactive, caseins, useecs, fulltbl, usemecs;
Xextern int fullspd, gen_line_dirs, performance_report, backtrack_report, csize;
Xextern int yymore_used, reject, real_reject, continued_action;
X
X#define REALLY_NOT_DETERMINED 0
X#define REALLY_USED 1
X#define REALLY_NOT_USED 2
Xextern int yymore_really_used, reject_really_used;
X
X
X/* variables used in the flex input routines:
X * datapos - characters on current output line
X * dataline - number of contiguous lines of data in current data
X *    statement.  Used to generate readable -f output
X * linenum - current input line number
X * skelfile - the skeleton file
X * yyin - input file
X * temp_action_file - temporary file to hold actions
X * backtrack_file - file to summarize backtracking states to
X * infilename - name of input file
X * action_file_name - name of the temporary file
X * input_files - array holding names of input files
X * num_input_files - size of input_files array
X * program_name - name with which program was invoked 
X */
X
Xextern int datapos, dataline, linenum;
Xextern FILE *skelfile, *yyin, *temp_action_file, *backtrack_file;
Xextern char *infilename;
Xextern char *action_file_name;
Xextern char **input_files;
Xextern int num_input_files;
Xextern char *program_name;
X
X
X/* variables for stack of states having only one out-transition:
X * onestate - state number
X * onesym - transition symbol
X * onenext - target state
X * onedef - default base entry
X * onesp - stack pointer
X */
X
Xextern int onestate[ONE_STACK_SIZE], onesym[ONE_STACK_SIZE];
Xextern int onenext[ONE_STACK_SIZE], onedef[ONE_STACK_SIZE], onesp;
X
X
X/* variables for nfa machine data:
X * current_mns - current maximum on number of NFA states
X * num_rules - number of the last accepting state; also is number of
X *             rules created so far
X * current_max_rules - current maximum number of rules
X * lastnfa - last nfa state number created
X * firstst - physically the first state of a fragment
X * lastst - last physical state of fragment
X * finalst - last logical state of fragment
X * transchar - transition character
X * trans1 - transition state
X * trans2 - 2nd transition state for epsilons
X * accptnum - accepting number
X * assoc_rule - rule associated with this NFA state (or 0 if none)
X * state_type - a STATE_xxx type identifying whether the state is part
X *              of a normal rule, the leading state in a trailing context
X *              rule (i.e., the state which marks the transition from
X *              recognizing the text-to-be-matched to the beginning of
X *              the trailing context), or a subsequent state in a trailing
X *              context rule
X * rule_type - a RULE_xxx type identifying whether this a a ho-hum
X *             normal rule or one which has variable head & trailing
X *             context
X * rule_linenum - line number associated with rule
X */
X
Xextern int current_mns, num_rules, current_max_rules, lastnfa;
Xextern int *firstst, *lastst, *finalst, *transchar, *trans1, *trans2;
Xextern int *accptnum, *assoc_rule, *state_type, *rule_type, *rule_linenum;
X
X/* different types of states; values are useful as masks, as well, for
X * routines like check_trailing_context()
X */
X#define STATE_NORMAL 0x1
X#define STATE_TRAILING_CONTEXT 0x2
X
X/* global holding current type of state we're making */
X
Xextern int current_state_type;
X
X/* different types of rules */
X#define RULE_NORMAL 0
X#define RULE_VARIABLE 1
X
X/* true if the input rules include a rule with both variable-length head
X * and trailing context, false otherwise
X */
Xextern int variable_trailing_context_rules;
X
X
X/* variables for protos:
X * numtemps - number of templates created
X * numprots - number of protos created
X * protprev - backlink to a more-recently used proto
X * protnext - forward link to a less-recently used proto
X * prottbl - base/def table entry for proto
X * protcomst - common state of proto
X * firstprot - number of the most recently used proto
X * lastprot - number of the least recently used proto
X * protsave contains the entire state array for protos
X */
X
Xextern int numtemps, numprots, protprev[MSP], protnext[MSP], prottbl[MSP];
Xextern int protcomst[MSP], firstprot, lastprot, protsave[PROT_SAVE_SIZE];
X
X
X/* variables for managing equivalence classes:
X * numecs - number of equivalence classes
X * nextecm - forward link of Equivalence Class members
X * ecgroup - class number or backward link of EC members
X * nummecs - number of meta-equivalence classes (used to compress
X *   templates)
X * tecfwd - forward link of meta-equivalence classes members
X * tecbck - backward link of MEC's
X * xlation - maps character codes to their translations, or nil if no %t table
X * num_xlations - number of different xlation values
X */
X
X/* reserve enough room in the equivalence class arrays so that we
X * can use the CSIZE'th element to hold equivalence class information
X * for the NUL character.  Later we'll move this information into
X * the 0th element.
X */
Xextern int numecs, nextecm[CSIZE + 1], ecgroup[CSIZE + 1], nummecs;
X
X/* meta-equivalence classes are indexed starting at 1, so it's possible
X * that they will require positions from 1 .. CSIZE, i.e., CSIZE + 1
X * slots total (since the arrays are 0-based).  nextecm[] and ecgroup[]
X * don't require the extra position since they're indexed from 1 .. CSIZE - 1.
X */
Xextern int tecfwd[CSIZE + 1], tecbck[CSIZE + 1];
X
Xextern int *xlation;
Xextern int num_xlations;
X
X
X/* variables for start conditions:
X * lastsc - last start condition created
X * current_max_scs - current limit on number of start conditions
X * scset - set of rules active in start condition
X * scbol - set of rules active only at the beginning of line in a s.c.
X * scxclu - true if start condition is exclusive
X * sceof - true if start condition has EOF rule
X * scname - start condition name
X * actvsc - stack of active start conditions for the current rule
X */
X
Xextern int lastsc, current_max_scs, *scset, *scbol, *scxclu, *sceof, *actvsc;
Xextern char **scname;
X
X
X/* variables for dfa machine data:
X * current_max_dfa_size - current maximum number of NFA states in DFA
X * current_max_xpairs - current maximum number of non-template xtion pairs
X * current_max_template_xpairs - current maximum number of template pairs
X * current_max_dfas - current maximum number DFA states
X * lastdfa - last dfa state number created
X * nxt - state to enter upon reading character
X * chk - check value to see if "nxt" applies
X * tnxt - internal nxt table for templates
X * base - offset into "nxt" for given state
X * def - where to go if "chk" disallows "nxt" entry
X * nultrans - NUL transition for each state
X * NUL_ec - equivalence class of the NUL character
X * tblend - last "nxt/chk" table entry being used
X * firstfree - first empty entry in "nxt/chk" table
X * dss - nfa state set for each dfa
X * dfasiz - size of nfa state set for each dfa
X * dfaacc - accepting set for each dfa state (or accepting number, if
X *    -r is not given)
X * accsiz - size of accepting set for each dfa state
X * dhash - dfa state hash value
X * numas - number of DFA accepting states created; note that this
X *    is not necessarily the same value as num_rules, which is the analogous
X *    value for the NFA
X * numsnpairs - number of state/nextstate transition pairs
X * jambase - position in base/def where the default jam table starts
X * jamstate - state number corresponding to "jam" state
X * end_of_buffer_state - end-of-buffer dfa state number
X */
X
Xextern int current_max_dfa_size, current_max_xpairs;
Xextern int current_max_template_xpairs, current_max_dfas;
Xextern int lastdfa, lasttemp, *nxt, *chk, *tnxt;
Xextern int *base, *def, *nultrans, NUL_ec, tblend, firstfree, **dss, *dfasiz;
Xextern union dfaacc_union
X    {
X    int *dfaacc_set;
X    int dfaacc_state;
X    } *dfaacc;
Xextern int *accsiz, *dhash, numas;
Xextern int numsnpairs, jambase, jamstate;
Xextern int end_of_buffer_state;
X
X/* variables for ccl information:
X * lastccl - ccl index of the last created ccl
X * current_maxccls - current limit on the maximum number of unique ccl's
X * cclmap - maps a ccl index to its set pointer
X * ccllen - gives the length of a ccl
X * cclng - true for a given ccl if the ccl is negated
X * cclreuse - counts how many times a ccl is re-used
X * current_max_ccl_tbl_size - current limit on number of characters needed
X *	to represent the unique ccl's
X * ccltbl - holds the characters in each ccl - indexed by cclmap
X */
X
Xextern int lastccl, current_maxccls, *cclmap, *ccllen, *cclng, cclreuse;
Xextern int current_max_ccl_tbl_size;
Xextern Char *ccltbl;
X
X
X/* variables for miscellaneous information:
X * starttime - real-time when we started
X * endtime - real-time when we ended
X * nmstr - last NAME scanned by the scanner
X * sectnum - section number currently being parsed
X * nummt - number of empty nxt/chk table entries
X * hshcol - number of hash collisions detected by snstods
X * dfaeql - number of times a newly created dfa was equal to an old one
X * numeps - number of epsilon NFA states created
X * eps2 - number of epsilon states which have 2 out-transitions
X * num_reallocs - number of times it was necessary to realloc() a group
X *		  of arrays
X * tmpuses - number of DFA states that chain to templates
X * totnst - total number of NFA states used to make DFA states
X * peakpairs - peak number of transition pairs we had to store internally
X * numuniq - number of unique transitions
X * numdup - number of duplicate transitions
X * hshsave - number of hash collisions saved by checking number of states
X * num_backtracking - number of DFA states requiring back-tracking
X * bol_needed - whether scanner needs beginning-of-line recognition
X */
X
Xextern char *starttime, *endtime, nmstr[MAXLINE];
Xextern int sectnum, nummt, hshcol, dfaeql, numeps, eps2, num_reallocs;
Xextern int tmpuses, totnst, peakpairs, numuniq, numdup, hshsave;
Xextern int num_backtracking, bol_needed;
X
Xvoid *allocate_array(), *reallocate_array();
X
X#define allocate_integer_array(size) \
X	(int *) allocate_array( size, sizeof( int ) )
X
X#define reallocate_integer_array(array,size) \
X	(int *) reallocate_array( (void *) array, size, sizeof( int ) )
X
X#define allocate_int_ptr_array(size) \
X	(int **) allocate_array( size, sizeof( int * ) )
X
X#define allocate_char_ptr_array(size) \
X	(char **) allocate_array( size, sizeof( char * ) )
X
X#define allocate_dfaacc_union(size) \
X	(union dfaacc_union *) \
X		allocate_array( size, sizeof( union dfaacc_union ) )
X
X#define reallocate_int_ptr_array(array,size) \
X	(int **) reallocate_array( (void *) array, size, sizeof( int * ) )
X
X#define reallocate_char_ptr_array(array,size) \
X	(char **) reallocate_array( (void *) array, size, sizeof( char * ) )
X
X#define reallocate_dfaacc_union(array, size) \
X	(union dfaacc_union *) \
X	reallocate_array( (void *) array, size, sizeof( union dfaacc_union ) )
X
X#define allocate_character_array(size) \
X	(Char *) allocate_array( size, sizeof( Char ) )
X
X#define reallocate_character_array(array,size) \
X	(Char *) reallocate_array( (void *) array, size, sizeof( Char ) )
X
X
X/* used to communicate between scanner and parser.  The type should really
X * be YYSTYPE, but we can't easily get our hands on it.
X */
Xextern int yylval;
X
X
X/* external functions that are cross-referenced among the flex source files */
X
X
X/* from file ccl.c */
X
Xextern void ccladd PROTO((int, int));	/* Add a single character to a ccl */
Xextern int cclinit PROTO(());	/* make an empty ccl */
Xextern void cclnegate PROTO((int));	/* negate a ccl */
X
X/* list the members of a set of characters in CCL form */
Xextern void list_character_set PROTO((FILE*, int[]));
X
X
X/* from file dfa.c */
X
X/* increase the maximum number of dfas */
Xextern void increase_max_dfas PROTO(());
X
Xextern void ntod PROTO(());	/* convert a ndfa to a dfa */
X
X
X/* from file ecs.c */
X
X/* convert character classes to set of equivalence classes */
Xextern void ccl2ecl PROTO(());
X
X/* associate equivalence class numbers with class members */
Xextern int cre8ecs PROTO((int[], int[], int));
X
X/* associate equivalence class numbers using %t table */
Xextern int ecs_from_xlation PROTO((int[]));
X
X/* update equivalence classes based on character class transitions */
Xextern void mkeccl PROTO((Char[], int, int[], int[], int, int));
X
X/* create equivalence class for single character */
Xextern void mkechar PROTO((int, int[], int[]));
X
X
X/* from file gen.c */
X
Xextern void make_tables PROTO(());	/* generate transition tables */
X
X
X/* from file main.c */
X
Xextern void flexend PROTO((int));
X
X
X/* from file misc.c */
X
X/* write out the actions from the temporary file to lex.yy.c */
Xextern void action_out PROTO(());
X
X/* true if a string is all lower case */
Xextern int all_lower PROTO((register Char *));
X
X/* true if a string is all upper case */
Xextern int all_upper PROTO((register Char *));
X
X/* bubble sort an integer array */
Xextern void bubble PROTO((int [], int));
X
X/* shell sort a character array */
Xextern void cshell PROTO((Char [], int, int));
X
Xextern void dataend PROTO(());	/* finish up a block of data declarations */
X
X/* report an error message and terminate */
Xextern void flexerror PROTO((char[]));
X
X/* report a fatal error message and terminate */
Xextern void flexfatal PROTO((char[]));
X
X/* report an error message formatted with one integer argument */
Xextern void lerrif PROTO((char[], int));
X
X/* report an error message formatted with one string argument */
Xextern void lerrsf PROTO((char[], char[]));
X
X/* spit out a "# line" statement */
Xextern void line_directive_out PROTO((FILE*));
X
X/* generate a data statment for a two-dimensional array */
Xextern void mk2data PROTO((int));
X
Xextern void mkdata PROTO((int));	/* generate a data statement */
X
X/* return the integer represented by a string of digits */
Xextern int myctoi PROTO((Char []));
X
X/* write out one section of the skeleton file */
Xextern void skelout PROTO(());
X
X/* output a yy_trans_info structure */
Xextern void transition_struct_out PROTO((int, int));
X
X
X/* from file nfa.c */
X
X/* add an accepting state to a machine */
Xextern void add_accept PROTO((int, int));
X
X/* make a given number of copies of a singleton machine */
Xextern int copysingl PROTO((int, int));
X
X/* debugging routine to write out an nfa */
Xextern void dumpnfa PROTO((int));
X
X/* finish up the processing for a rule */
Xextern void finish_rule PROTO((int, int, int, int));
X
X/* connect two machines together */
Xextern int link_machines PROTO((int, int));
X
X/* mark each "beginning" state in a machine as being a "normal" (i.e.,
X * not trailing context associated) state
X */
Xextern void mark_beginning_as_normal PROTO((register int));
X
X/* make a machine that branches to two machines */
Xextern int mkbranch PROTO((int, int));
X
Xextern int mkclos PROTO((int));	/* convert a machine into a closure */
Xextern int mkopt PROTO((int));	/* make a machine optional */
X
X/* make a machine that matches either one of two machines */
Xextern int mkor PROTO((int, int));
X
X/* convert a machine into a positive closure */
Xextern int mkposcl PROTO((int));
X
Xextern int mkrep PROTO((int, int, int));	/* make a replicated machine */
X
X/* create a state with a transition on a given symbol */
Xextern int mkstate PROTO((int));
X
Xextern void new_rule PROTO(());	/* initialize for a new rule */
X
X
X/* from file parse.y */
X
X/* write out a message formatted with one string, pinpointing its location */
Xextern void format_pinpoint_message PROTO((char[], char[]));
X
X/* write out a message, pinpointing its location */
Xextern void pinpoint_message PROTO((char[]));
X
Xextern void synerr PROTO((char []));	/* report a syntax error */
Xextern int yyparse PROTO(());	/* the YACC parser */
X
X
X/* from file scan.l */
X
Xextern int flexscan PROTO(());	/* the Flex-generated scanner for flex */
X
X/* open the given file (if NULL, stdin) for scanning */
Xextern void set_input_file PROTO((char*));
X
Xextern int yywrap PROTO(());	/* wrapup a file in the lexical analyzer */
X
X
X/* from file sym.c */
X
X/* save the text of a character class */
Xextern void cclinstal PROTO ((Char [], int));
X
X/* lookup the number associated with character class */
Xextern int ccllookup PROTO((Char []));
X
Xextern void ndinstal PROTO((char[], Char[]));	/* install a name definition */
Xextern void scinstal PROTO((char[], int));	/* make a start condition */
X
X/* lookup the number associated with a start condition */
Xextern int sclookup PROTO((char[]));
X
X
X/* from file tblcmp.c */
X
X/* build table entries for dfa state */
Xextern void bldtbl PROTO((int[], int, int, int, int));
X
Xextern void cmptmps PROTO(());	/* compress template table entries */
Xextern void inittbl PROTO(());	/* initialize transition tables */
Xextern void mkdeftbl PROTO(());	/* make the default, "jam" table entries */
X
X/* create table entries for a state (or state fragment) which has
X * only one out-transition */
Xextern void mk1tbl PROTO((int, int, int, int));
X
X/* place a state into full speed transition table */
Xextern void place_state PROTO((int*, int, int));
X
X/* save states with only one out-transition to be processed later */
Xextern void stack1 PROTO((int, int, int, int));
X
X
X/* from file yylex.c */
X
Xextern int yylex PROTO(());
X
X
X/* The Unix kernel calls used here */
X
Xextern int read PROTO((int, char*, int));
Xextern int unlink PROTO((char*));
Xextern int write PROTO((int, char*, int));
END_OF_FILE
  if test 29063 -ne `wc -c <'flexdef.h'`; then
    echo shar: \"'flexdef.h'\" unpacked with wrong size!
  fi
  # end of 'flexdef.h'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
  echo shar: Extracting \"'main.c'\" \(19459 characters\)
  sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/* flex - tool to generate fast lexical analyzers */
X
X/*-
X * Copyright (c) 1990 The Regents of the University of California.
X * All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Vern Paxson.
X * 
X * The United States Government has rights in this work pursuant
X * to contract no. DE-AC03-76SF00098 between the United States
X * Department of Energy and the University of California.
X *
X * Redistribution and use in source and binary forms are permitted provided
X * that: (1) source distributions retain this entire copyright notice and
X * comment, and (2) distributions including binaries display the following
X * acknowledgement:  ``This product includes software developed by the
X * University of California, Berkeley and its contributors'' in the
X * documentation or other materials provided with the distribution and in
X * all advertising materials mentioning features or use of this software.
X * Neither the name of the University nor the names of its contributors may
X * be used to endorse or promote products derived from this software without
X * specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
Xchar copyright[] =
X"@(#) Copyright (c) 1990 The Regents of the University of California.\n\
X All rights reserved.\n";
X#endif /* not lint */
X
X#ifndef lint
Xstatic char rcsid[] =
X    "@(#) $Header: /usr/fsys/odin/a/vern/flex/RCS/main.c,v 2.9 90/06/27 23:48:24 vern Exp $ (LBL)";
X#endif
X
X
X#include "flexdef.h"
X
Xstatic char flex_version[] = "2.3";
X
X
X/* declare functions that have forward references */
X
Xvoid flexinit PROTO((int, char**));
Xvoid readin PROTO(());
Xvoid set_up_initial_allocations PROTO(());
X
X
X/* these globals are all defined and commented in flexdef.h */
Xint printstats, syntaxerror, eofseen, ddebug, trace, spprdflt;
Xint interactive, caseins, useecs, fulltbl, usemecs;
Xint fullspd, gen_line_dirs, performance_report, backtrack_report, csize;
Xint yymore_used, reject, real_reject, continued_action;
Xint yymore_really_used, reject_really_used;
Xint datapos, dataline, linenum;
XFILE *skelfile = NULL;
Xchar *infilename = NULL;
Xint onestate[ONE_STACK_SIZE], onesym[ONE_STACK_SIZE];
Xint onenext[ONE_STACK_SIZE], onedef[ONE_STACK_SIZE], onesp;
Xint current_mns, num_rules, current_max_rules, lastnfa;
Xint *firstst, *lastst, *finalst, *transchar, *trans1, *trans2;
Xint *accptnum, *assoc_rule, *state_type, *rule_type, *rule_linenum;
Xint current_state_type;
Xint variable_trailing_context_rules;
Xint numtemps, numprots, protprev[MSP], protnext[MSP], prottbl[MSP];
Xint protcomst[MSP], firstprot, lastprot, protsave[PROT_SAVE_SIZE];
Xint numecs, nextecm[CSIZE + 1], ecgroup[CSIZE + 1], nummecs, tecfwd[CSIZE + 1];
Xint tecbck[CSIZE + 1];
Xint *xlation = (int *) 0;
Xint num_xlations;
Xint lastsc, current_max_scs, *scset, *scbol, *scxclu, *sceof, *actvsc;
Xchar **scname;
Xint current_max_dfa_size, current_max_xpairs;
Xint current_max_template_xpairs, current_max_dfas;
Xint lastdfa, *nxt, *chk, *tnxt;
Xint *base, *def, *nultrans, NUL_ec, tblend, firstfree, **dss, *dfasiz;
Xunion dfaacc_union *dfaacc;
Xint *accsiz, *dhash, numas;
Xint numsnpairs, jambase, jamstate;
Xint lastccl, current_maxccls, *cclmap, *ccllen, *cclng, cclreuse;
Xint current_max_ccl_tbl_size;
XChar *ccltbl;
Xchar *starttime, *endtime, nmstr[MAXLINE];
Xint sectnum, nummt, hshcol, dfaeql, numeps, eps2, num_reallocs;
Xint tmpuses, totnst, peakpairs, numuniq, numdup, hshsave;
Xint num_backtracking, bol_needed;
XFILE *temp_action_file;
XFILE *backtrack_file;
Xint end_of_buffer_state;
Xchar *action_file_name = NULL;
Xchar **input_files;
Xint num_input_files;
Xchar *program_name;
X
X#ifndef SHORT_FILE_NAMES
Xstatic char *outfile = "lex.yy.c";
X#else
Xstatic char *outfile = "lexyy.c";
X#endif
Xstatic int outfile_created = 0;
Xstatic int use_stdout;
Xstatic char *skelname = NULL;
X
X
Xint main( argc, argv )
Xint argc;
Xchar **argv;
X
X    {
X    flexinit( argc, argv );
X
X    readin();
X
X    if ( syntaxerror )
X	flexend( 1 );
X
X    if ( yymore_really_used == REALLY_USED )
X	yymore_used = true;
X    else if ( yymore_really_used == REALLY_NOT_USED )
X	yymore_used = false;
X
X    if ( reject_really_used == REALLY_USED )
X	reject = true;
X    else if ( reject_really_used == REALLY_NOT_USED )
X	reject = false;
X
X    if ( performance_report )
X	{
X	if ( interactive )
X	    fprintf( stderr,
X		     "-I (interactive) entails a minor performance penalty\n" );
X
X	if ( yymore_used )
X	    fprintf( stderr, "yymore() entails a minor performance penalty\n" );
X
X	if ( reject )
X	    fprintf( stderr, "REJECT entails a large performance penalty\n" );
X
X	if ( variable_trailing_context_rules )
X	    fprintf( stderr,
X"Variable trailing context rules entail a large performance penalty\n" );
X	}
X
X    if ( reject )
X	real_reject = true;
X
X    if ( variable_trailing_context_rules )
X	reject = true;
X
X    if ( (fulltbl || fullspd) && reject )
X	{
X	if ( real_reject )
X	    flexerror( "REJECT cannot be used with -f or -F" );
X	else
X	    flexerror(
X	"variable trailing context rules cannot be used with -f or -F" );
X	}
X
X    ntod();
X
X    /* generate the C state transition tables from the DFA */
X    make_tables();
X
X    /* note, flexend does not return.  It exits with its argument as status. */
X
X    flexend( 0 );
X
X    /*NOTREACHED*/
X    }
X
X
X/* flexend - terminate flex
X *
X * synopsis
X *    int status;
X *    flexend( status );
X *
X *    status is exit status.
X *
X * note
X *    This routine does not return.
X */
X
Xvoid flexend( status )
Xint status;
X
X    {
X    int tblsiz;
X    char *flex_gettime();
X
X    if ( skelfile != NULL )
X	{
X	if ( ferror( skelfile ) )
X	    flexfatal( "error occurred when writing skeleton file" );
X
X	else if ( fclose( skelfile ) )
X	    flexfatal( "error occurred when closing skeleton file" );
X	}
X
X    if ( temp_action_file )
X	{
X	if ( ferror( temp_action_file ) )
X	    flexfatal( "error occurred when writing temporary action file" );
X
X	else if ( fclose( temp_action_file ) )
X	    flexfatal( "error occurred when closing temporary action file" );
X
X	else if ( unlink( action_file_name ) )
X	    flexfatal( "error occurred when deleting temporary action file" );
X	}
X
X    if ( status != 0 && outfile_created )
X	{
X	if ( ferror( stdout ) )
X	    flexfatal( "error occurred when writing output file" );
X
X	else if ( fclose( stdout ) )
X	    flexfatal( "error occurred when closing output file" );
X
X	else if ( unlink( outfile ) )
X	    flexfatal( "error occurred when deleting output file" );
X	}
X
X    if ( backtrack_report && backtrack_file )
X	{
X	if ( num_backtracking == 0 )
X	    fprintf( backtrack_file, "No backtracking.\n" );
X	else if ( fullspd || fulltbl )
X	    fprintf( backtrack_file,
X		     "%d backtracking (non-accepting) states.\n",
X		     num_backtracking );
X	else
X	    fprintf( backtrack_file, "Compressed tables always backtrack.\n" );
X
X	if ( ferror( backtrack_file ) )
X	    flexfatal( "error occurred when writing backtracking file" );
X
X	else if ( fclose( backtrack_file ) )
X	    flexfatal( "error occurred when closing backtracking file" );
X	}
X
X    if ( printstats )
X	{
X	endtime = flex_gettime();
X
X	fprintf( stderr, "%s version %s usage statistics:\n", program_name,
X		 flex_version );
X	fprintf( stderr, "  started at %s, finished at %s\n",
X		 starttime, endtime );
X
X	fprintf( stderr, "  scanner options: -" );
X
X	if ( backtrack_report )
X	    putc( 'b', stderr );
X	if ( ddebug )
X	    putc( 'd', stderr );
X	if ( interactive )
X	    putc( 'I', stderr );
X	if ( caseins )
X	    putc( 'i', stderr );
X	if ( ! gen_line_dirs )
X	    putc( 'L', stderr );
X	if ( performance_report )
X	    putc( 'p', stderr );
X	if ( spprdflt )
X	    putc( 's', stderr );
X	if ( use_stdout )
X	    putc( 't', stderr );
X	if ( trace )
X	    putc( 'T', stderr );
X	if ( printstats )
X	    putc( 'v', stderr );	/* always true! */
X	if ( csize == 256 )
X	    putc( '8', stderr );
X
X	fprintf( stderr, " -C" );
X
X	if ( fulltbl )
X	    putc( 'f', stderr );
X	if ( fullspd )
X	    putc( 'F', stderr );
X	if ( useecs )
X	    putc( 'e', stderr );
X	if ( usemecs )
X	    putc( 'm', stderr );
X
X	if ( strcmp( skelname, DEFAULT_SKELETON_FILE ) )
X	    fprintf( stderr, " -S%s", skelname );
X
X	putc( '\n', stderr );
X
X	fprintf( stderr, "  %d/%d NFA states\n", lastnfa, current_mns );
X	fprintf( stderr, "  %d/%d DFA states (%d words)\n", lastdfa,
X		 current_max_dfas, totnst );
X	fprintf( stderr,
X		 "  %d rules\n", num_rules - 1 /* - 1 for def. rule */ );
X
X	if ( num_backtracking == 0 )
X	    fprintf( stderr, "  No backtracking\n" );
X	else if ( fullspd || fulltbl )
X	    fprintf( stderr, "  %d backtracking (non-accepting) states\n",
X		     num_backtracking );
X	else
X	    fprintf( stderr, "  compressed tables always backtrack\n" );
X
X	if ( bol_needed )
X	    fprintf( stderr, "  Beginning-of-line patterns used\n" );
X
X	fprintf( stderr, "  %d/%d start conditions\n", lastsc,
X		 current_max_scs );
X	fprintf( stderr, "  %d epsilon states, %d double epsilon states\n",
X		 numeps, eps2 );
X
X	if ( lastccl == 0 )
X	    fprintf( stderr, "  no character classes\n" );
X	else
X	    fprintf( stderr,
X	"  %d/%d character classes needed %d/%d words of storage, %d reused\n",
X		     lastccl, current_maxccls,
X		     cclmap[lastccl] + ccllen[lastccl],
X		     current_max_ccl_tbl_size, cclreuse );
X
X	fprintf( stderr, "  %d state/nextstate pairs created\n", numsnpairs );
X	fprintf( stderr, "  %d/%d unique/duplicate transitions\n",
X		 numuniq, numdup );
X
X	if ( fulltbl )
X	    {
X	    tblsiz = lastdfa * numecs;
X	    fprintf( stderr, "  %d table entries\n", tblsiz );
X	    }
X
X	else
X	    {
X	    tblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;
X
X	    fprintf( stderr, "  %d/%d base-def entries created\n",
X		     lastdfa + numtemps, current_max_dfas );
X	    fprintf( stderr, "  %d/%d (peak %d) nxt-chk entries created\n",
X		     tblend, current_max_xpairs, peakpairs );
X	    fprintf( stderr,
X		     "  %d/%d (peak %d) template nxt-chk entries created\n",
X		     numtemps * nummecs, current_max_template_xpairs,
X		     numtemps * numecs );
X	    fprintf( stderr, "  %d empty table entries\n", nummt );
X	    fprintf( stderr, "  %d protos created\n", numprots );
X	    fprintf( stderr, "  %d templates created, %d uses\n",
X		     numtemps, tmpuses );
X	    }
X
X	if ( useecs )
X	    {
X	    tblsiz = tblsiz + csize;
X	    fprintf( stderr, "  %d/%d equivalence classes created\n",
X		     numecs, csize );
X	    }
X
X	if ( usemecs )
X	    {
X	    tblsiz = tblsiz + numecs;
X	    fprintf( stderr, "  %d/%d meta-equivalence classes created\n",
X		     nummecs, csize );
X	    }
X
X	fprintf( stderr, "  %d (%d saved) hash collisions, %d DFAs equal\n",
X		 hshcol, hshsave, dfaeql );
X	fprintf( stderr, "  %d sets of reallocations needed\n", num_reallocs );
X	fprintf( stderr, "  %d total table entries needed\n", tblsiz );
X	}
X
X#ifndef VMS
X    exit( status );
X#else
X    exit( status + 1 );
X#endif
X    }
X
X
X/* flexinit - initialize flex
X *
X * synopsis
X *    int argc;
X *    char **argv;
X *    flexinit( argc, argv );
X */
X
Xvoid flexinit( argc, argv )
Xint argc;
Xchar **argv;
X
X    {
X    int i, sawcmpflag;
X    char *arg, *flex_gettime(), *mktemp();
X
X    printstats = syntaxerror = trace = spprdflt = interactive = caseins = false;
X    backtrack_report = performance_report = ddebug = fulltbl = fullspd = false;
X    yymore_used = continued_action = reject = false;
X    yymore_really_used = reject_really_used = false;
X    gen_line_dirs = usemecs = useecs = true;
X
X    sawcmpflag = false;
X    use_stdout = false;
X
X    csize = DEFAULT_CSIZE;
X
X    program_name = argv[0];
X
X    /* read flags */
X    for ( --argc, ++argv; argc ; --argc, ++argv )
X	{
X	if ( argv[0][0] != '-' || argv[0][1] == '\0' )
X	    break;
X
X	arg = argv[0];
X
X	for ( i = 1; arg[i] != '\0'; ++i )
X	    switch ( arg[i] )
X		{
X		case 'b':
X		    backtrack_report = true;
X		    break;
X
X		case 'c':
X		    fprintf( stderr,
X	"%s: Assuming use of deprecated -c flag is really intended to be -C\n",
X			     program_name );
X
X		    /* fall through */
X
X		case 'C':
X		    if ( i != 1 )
X			flexerror( "-C flag must be given separately" );
X
X		    if ( ! sawcmpflag )
X			{
X			useecs = false;
X			usemecs = false;
X			fulltbl = false;
X			sawcmpflag = true;
X			}
X
X		    for ( ++i; arg[i] != '\0'; ++i )
X			switch ( arg[i] )
X			    {
X			    case 'e':
X				useecs = true;
X				break;
X
X			    case 'F':
X				fullspd = true;
X				break;
X
X			    case 'f':
X				fulltbl = true;
X				break;
X
X			    case 'm':
X				usemecs = true;
X				break;
X
X			    default:
X				lerrif( "unknown -C option '%c'",
X					(int) arg[i] );
X				break;
X			    }
X
X		    goto get_next_arg;
X
X		case 'd':
X		    ddebug = true;
X		    break;
X
X		case 'f':
X		    useecs = usemecs = false;
X		    fulltbl = true;
X		    break;
X
X		case 'F':
X		    useecs = usemecs = false;
X		    fullspd = true;
X		    break;
X
X		case 'I':
X		    interactive = true;
X		    break;
X
X		case 'i':
X		    caseins = true;
X		    break;
X
X		case 'L':
X		    gen_line_dirs = false;
X		    break;
X
X		case 'n':
X		    /* stupid do-nothing deprecated option */
X		    break;
X
X		case 'p':
X		    performance_report = true;
X		    break;
X
X		case 'S':
X		    if ( i != 1 )
X			flexerror( "-S flag must be given separately" );
X
X		    skelname = arg + i + 1;
X		    goto get_next_arg;
X
X		case 's':
X		    spprdflt = true;
X		    break;
X
X		case 't':
X		    use_stdout = true;
X		    break;
X
X		case 'T':
X		    trace = true;
X		    break;
X
X		case 'v':
X		    printstats = true;
X		    break;
X
X		case '8':
X		    csize = CSIZE;
X		    break;
X
X		default:
X		    lerrif( "unknown flag '%c'", (int) arg[i] );
X		    break;
X		}
X
Xget_next_arg: /* used by -C and -S flags in lieu of a "continue 2" control */
X	;
X	}
X
X    if ( (fulltbl || fullspd) && usemecs )
X	flexerror( "full table and -Cm don't make sense together" );
X
X    if ( (fulltbl || fullspd) && interactive )
X	flexerror( "full table and -I are (currently) incompatible" );
X
X    if ( fulltbl && fullspd )
X	flexerror( "full table and -F are mutually exclusive" );
X
X    if ( ! skelname )
X	{
X	static char skeleton_name_storage[400];
X
X	skelname = skeleton_name_storage;
X	(void) strcpy( skelname, DEFAULT_SKELETON_FILE );
X	}
X
X    if ( ! use_stdout )
X	{
X	FILE *prev_stdout = freopen( outfile, "w", stdout );
X
X	if ( prev_stdout == NULL )
X	    lerrsf( "could not create %s", outfile );
X
X	outfile_created = 1;
X	}
X
X    num_input_files = argc;
X    input_files = argv;
X    set_input_file( num_input_files > 0 ? input_files[0] : NULL );
X
X    if ( backtrack_report )
X	{
X#ifndef SHORT_FILE_NAMES
X	backtrack_file = fopen( "lex.backtrack", "w" );
X#else
X	backtrack_file = fopen( "lex.bck", "w" );
X#endif
X
X	if ( backtrack_file == NULL )
X	    flexerror( "could not create lex.backtrack" );
X	}
X
X    else
X	backtrack_file = NULL;
X
X
X    lastccl = 0;
X    lastsc = 0;
X
X    /* initialize the statistics */
X    starttime = flex_gettime();
X
X    if ( (skelfile = fopen( skelname, "r" )) == NULL )
X	lerrsf( "can't open skeleton file %s", skelname );
X
X#ifdef SYS_V
X    action_file_name = tmpnam( NULL );
X#endif
X
X    if ( action_file_name == NULL )
X	{
X	static char temp_action_file_name[32];
X
X#ifndef SHORT_FILE_NAMES
X	(void) strcpy( temp_action_file_name, "/tmp/flexXXXXXX" );
X#else
X	(void) strcpy( temp_action_file_name, "flexXXXXXX.tmp" );
X#endif
X	(void) mktemp( temp_action_file_name );
X
X	action_file_name = temp_action_file_name;
X	}
X
X    if ( (temp_action_file = fopen( action_file_name, "w" )) == NULL )
X	lerrsf( "can't open temporary action file %s", action_file_name );
X
X    lastdfa = lastnfa = num_rules = numas = numsnpairs = tmpuses = 0;
X    numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
X    numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
X    num_backtracking = onesp = numprots = 0;
X    variable_trailing_context_rules = bol_needed = false;
X
X    linenum = sectnum = 1;
X    firstprot = NIL;
X
X    /* used in mkprot() so that the first proto goes in slot 1
X     * of the proto queue
X     */
X    lastprot = 1;
X
X    if ( useecs )
X	{ /* set up doubly-linked equivalence classes */
X	/* We loop all the way up to csize, since ecgroup[csize] is the
X	 * position used for NUL characters
X	 */
X	ecgroup[1] = NIL;
X
X	for ( i = 2; i <= csize; ++i )
X	    {
X	    ecgroup[i] = i - 1;
X	    nextecm[i - 1] = i;
X	    }
X
X	nextecm[csize] = NIL;
X	}
X
X    else
X	{ /* put everything in its own equivalence class */
X	for ( i = 1; i <= csize; ++i )
X	    {
X	    ecgroup[i] = i;
X	    nextecm[i] = BAD_SUBSCRIPT;	/* to catch errors */
X	    }
X	}
X
X    set_up_initial_allocations();
X    }
X
X
X/* readin - read in the rules section of the input file(s)
X *
X * synopsis
X *    readin();
X */
X
Xvoid readin()
X
X    {
X    skelout();
X
X    if ( ddebug )
X	puts( "#define FLEX_DEBUG" );
X
X    if ( csize == 256 )
X	puts( "#define YY_CHAR unsigned char" );
X    else
X	puts( "#define YY_CHAR char" );
X
X    line_directive_out( stdout );
X
X    if ( yyparse() )
X	{
X	pinpoint_message( "fatal parse error" );
X	flexend( 1 );
X	}
X
X    if ( xlation )
X	{
X	numecs = ecs_from_xlation( ecgroup );
X	useecs = true;
X	}
X
X    else if ( useecs )
X	numecs = cre8ecs( nextecm, ecgroup, csize );
X
X    else
X	numecs = csize;
X
X    /* now map the equivalence class for NUL to its expected place */
X    ecgroup[0] = ecgroup[csize];
X    NUL_ec = abs( ecgroup[0] );
X
X    if ( useecs )
X	ccl2ecl();
X    }
X
X
X
X/* set_up_initial_allocations - allocate memory for internal tables */
X
Xvoid set_up_initial_allocations()
X
X    {
X    current_mns = INITIAL_MNS;
X    firstst = allocate_integer_array( current_mns );
X    lastst = allocate_integer_array( current_mns );
X    finalst = allocate_integer_array( current_mns );
X    transchar = allocate_integer_array( current_mns );
X    trans1 = allocate_integer_array( current_mns );
X    trans2 = allocate_integer_array( current_mns );
X    accptnum = allocate_integer_array( current_mns );
X    assoc_rule = allocate_integer_array( current_mns );
X    state_type = allocate_integer_array( current_mns );
X
X    current_max_rules = INITIAL_MAX_RULES;
X    rule_type = allocate_integer_array( current_max_rules );
X    rule_linenum = allocate_integer_array( current_max_rules );
X
X    current_max_scs = INITIAL_MAX_SCS;
X    scset = allocate_integer_array( current_max_scs );
X    scbol = allocate_integer_array( current_max_scs );
X    scxclu = allocate_integer_array( current_max_scs );
X    sceof = allocate_integer_array( current_max_scs );
X    scname = allocate_char_ptr_array( current_max_scs );
X    actvsc = allocate_integer_array( current_max_scs );
X
X    current_maxccls = INITIAL_MAX_CCLS;
X    cclmap = allocate_integer_array( current_maxccls );
X    ccllen = allocate_integer_array( current_maxccls );
X    cclng = allocate_integer_array( current_maxccls );
X
X    current_max_ccl_tbl_size = INITIAL_MAX_CCL_TBL_SIZE;
X    ccltbl = allocate_character_array( current_max_ccl_tbl_size );
X
X    current_max_dfa_size = INITIAL_MAX_DFA_SIZE;
X
X    current_max_xpairs = INITIAL_MAX_XPAIRS;
X    nxt = allocate_integer_array( current_max_xpairs );
X    chk = allocate_integer_array( current_max_xpairs );
X
X    current_max_template_xpairs = INITIAL_MAX_TEMPLATE_XPAIRS;
X    tnxt = allocate_integer_array( current_max_template_xpairs );
X
X    current_max_dfas = INITIAL_MAX_DFAS;
X    base = allocate_integer_array( current_max_dfas );
X    def = allocate_integer_array( current_max_dfas );
X    dfasiz = allocate_integer_array( current_max_dfas );
X    accsiz = allocate_integer_array( current_max_dfas );
X    dhash = allocate_integer_array( current_max_dfas );
X    dss = allocate_int_ptr_array( current_max_dfas );
X    dfaacc = allocate_dfaacc_union( current_max_dfas );
X
X    nultrans = (int *) 0;
X    }
END_OF_FILE
  if test 19459 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
  fi
  # end of 'main.c'
fi
echo shar: End of archive 5 \(of 10\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
