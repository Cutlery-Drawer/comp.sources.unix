Subject:  v23i037:  Flex, a fast lex replacement, Part01/10
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 6558ddc9 f629c61f f6e5e61e 440e54c7

Submitted-by: Vern Paxson <vern@cs.cornell.edu>
Posting-number: Volume 23, Issue 37
Archive-name: flex2.3/part01

This is flex release 2.3, at patchlevel 6.

Flex is a replacement for lex.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  PACKNOTES README MANIFEST MISC MISC/README gen.c libmain.c
#   scan.l
# Wrapped by rsalz@litchi.bbn.com on Wed Oct 10 13:23:58 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 10)."'
if test -f 'PACKNOTES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PACKNOTES'\"
else
  echo shar: Extracting \"'PACKNOTES'\" \(179 characters\)
  sed "s/^X//" >'PACKNOTES' <<'END_OF_FILE'
X# "flexdoc.1" was split into 2 parts; to create it, do
X	cat flexdoc.1.0[1-9] >flexdoc.1
X# "initscan.c" was split into 2 parts; to create it, do
X	cat initscan.c.0[1-9] >initscan.c
END_OF_FILE
  if test 179 -ne `wc -c <'PACKNOTES'`; then
    echo shar: \"'PACKNOTES'\" unpacked with wrong size!
  fi
  # end of 'PACKNOTES'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(1599 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
X// $Header: /usr/fsys/odin/a/vern/flex/RCS/README,v 2.8 90/05/26 17:31:27 vern Exp $
X
XThis is release 2.3 of flex - a full release.
X
XThe flex distribution consists of the following files:
X
X	README		This message
X
X	Makefile
X	flexdef.h
X	parse.y
X	scan.l
X	ccl.c
X	dfa.c
X	ecs.c		flex sources
X	gen.c
X	main.c
X	misc.c
X	nfa.c
X	sym.c
X	tblcmp.c
X	yylex.c
X
X	libmain.c	flex library (-lfl) source
X
X	initscan.c	pre-flex'd version of scan.l
X
X	flex.skel	skeleton for generated scanners
X
X	flexdoc.1	full user documentation
X	flex.1		reference documentation
X
X	Changes		Differences between this release and the previous one
X
X	COPYING		flex's copyright
X
X	MISC/		a directory containing miscellaneous porting-related
X			notes (for Atari, MS-DOS, Turbo-C, and VMS)
X
X
XDecide where you want to keep flex.skel (suggestion:  /usr/local/lib),
Xbut don't move it there yet.  Edit "Makefile" and change the definition
Xof SKELETON_FILE to reflect the full pathname of flex.skel.
X
XRead the "Porting considerations" note in the Makefile and make
Xthe necessary changes.
X
XTo make flex for the first time, use:
X
X    make first_flex
X
Xwhich uses the pre-generated copy of the flex scanner (the scanner
Xitself is written using flex).
X
XAssuming it builds successfully, you can test it using
X
X    make test
X
XThe "diff" should not show any differences.
X
XIf you're feeling adventurous, issue "make bigtest" and be prepared
Xto wait a while.
X
XInstall flex using:
X
X	make install
X
X
XPlease send problems and feedback to:
X
X	vern@cs.cornell.edu
X	decvax!cornell!vern
X
X	Vern Paxson
X	CS Department
X	4126 Upson Hall
X	Cornell University
X	Ithaca, NY 14853-7501
END_OF_FILE
  if test 1599 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
  echo shar: Extracting \"'MANIFEST'\" \(1117 characters\)
  sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X----------------------------------------------------------
XPACKNOTES                  1	Warnings about long lines, etc
XREADME                     1	
XMANIFEST                   1	
XCOPYING                    2	
XChanges                    9	
XMISC                       1	
XMISC/Atari.patches         4	
XMISC/MSDOS.notes           9	
XMISC/Makefile.VMS         10	
XMISC/README                1	
XMISC/Turbo-C.notes         9	
XMakefile                  10	
Xccl.c                     10	
Xdfa.c                      6	
Xecs.c                      9	
Xflex.1                     4	
Xflex.skel                  6	
Xflexdef.h                  5	
Xflexdoc.1.01               2	(part 1)
Xflexdoc.1.02               8	(part 2)
Xgen.c                      1	
Xinitscan.c.01              3	(part 1)
Xinitscan.c.02              7	(part 2)
Xlibmain.c                  1	
Xmain.c                     5	
Xmisc.c                     8	
Xnfa.c                      8	
Xparse.y                    9	
Xscan.l                     1	
Xsym.c                      7	
Xtblcmp.c                   7	
Xyylex.c                    6	
END_OF_FILE
  if test 1117 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
  fi
  # end of 'MANIFEST'
fi
if test ! -d 'MISC' ; then
    echo shar: Creating directory \"'MISC'\"
    mkdir 'MISC'
fi
if test -f 'MISC/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MISC/README'\"
else
  echo shar: Extracting \"'MISC/README'\" \(520 characters\)
  sed "s/^X//" >'MISC/README' <<'END_OF_FILE'
XMiscellaneous flex stuff.  In here you'll find:
X
X  - a VMS makefile for flex
X
X  - out-of-date patches for flex on the Atari and for Minix,
X    from Ronald Lamprecht (V61%DHDURZ1.BITNET@CUNYVM.CUNY.EDU,
X    ...!unido!DHDURZ1.bitnet!V61, V61@DHDURZ1 (Bitnet));
X
X  - somewhat out-of-date notes on porting flex to MS-DOS, from
X    Jeffrey R. Jones (jjones@angate.att.com);
X
X  - notes on porting flex to Turbo-C, from Frank Whaley (few@quad1.quad.com,
X    uunet!ccicpg!quad1!few).
X
XUpdated versions of these will be welcome!
END_OF_FILE
  if test 520 -ne `wc -c <'MISC/README'`; then
    echo shar: \"'MISC/README'\" unpacked with wrong size!
  fi
  # end of 'MISC/README'
fi
if test -f 'gen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gen.c'\"
else
  echo shar: Extracting \"'gen.c'\" \(31594 characters\)
  sed "s/^X//" >'gen.c' <<'END_OF_FILE'
X/* gen - actual generation (writing) of flex scanners */
X
X/*-
X * Copyright (c) 1990 The Regents of the University of California.
X * All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Vern Paxson.
X * 
X * The United States Government has rights in this work pursuant
X * to contract no. DE-AC03-76SF00098 between the United States
X * Department of Energy and the University of California.
X *
X * Redistribution and use in source and binary forms are permitted provided
X * that: (1) source distributions retain this entire copyright notice and
X * comment, and (2) distributions including binaries display the following
X * acknowledgement:  ``This product includes software developed by the
X * University of California, Berkeley and its contributors'' in the
X * documentation or other materials provided with the distribution and in
X * all advertising materials mentioning features or use of this software.
X * Neither the name of the University nor the names of its contributors may
X * be used to endorse or promote products derived from this software without
X * specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
Xstatic char rcsid[] =
X    "@(#) $Header: /usr/helios/u0/vern/flex/RCS/gen.c,v 2.10 90/08/29 12:11:13 vern Exp $ (LBL)";
X#endif
X
X#include "flexdef.h"
X
X
X/* declare functions that have forward references */
X
Xvoid gen_next_state PROTO((int));
Xvoid genecs PROTO(());
Xvoid indent_put2s PROTO((char [], char []));
Xvoid indent_puts PROTO((char []));
X
X
Xstatic int indent_level = 0; /* each level is 4 spaces */
X
X#define indent_up() (++indent_level)
X#define indent_down() (--indent_level)
X#define set_indent(indent_val) indent_level = indent_val
X
X/* *everything* is done in terms of arrays starting at 1, so provide
X * a null entry for the zero element of all C arrays
X */
Xstatic char C_short_decl[] = "static const short int %s[%d] =\n    {   0,\n";
Xstatic char C_long_decl[] = "static const long int %s[%d] =\n    {   0,\n";
Xstatic char C_state_decl[] =
X	"static const yy_state_type %s[%d] =\n    {   0,\n";
X
X
X/* indent to the current level */
X
Xvoid do_indent()
X
X    {
X    register int i = indent_level * 4;
X
X    while ( i >= 8 )
X	{
X	putchar( '\t' );
X	i -= 8;
X	}
X    
X    while ( i > 0 )
X	{
X	putchar( ' ' );
X	--i;
X	}
X    }
X
X
X/* generate the code to keep backtracking information */
X
Xvoid gen_backtracking()
X
X    {
X    if ( reject || num_backtracking == 0 )
X	return;
X
X    if ( fullspd )
X	indent_puts( "if ( yy_current_state[-1].yy_nxt )" );
X    else
X	indent_puts( "if ( yy_accept[yy_current_state] )" );
X
X    indent_up();
X    indent_puts( "{" );
X    indent_puts( "yy_last_accepting_state = yy_current_state;" );
X    indent_puts( "yy_last_accepting_cpos = yy_cp;" );
X    indent_puts( "}" );
X    indent_down();
X    }
X
X
X/* generate the code to perform the backtrack */
X
Xvoid gen_bt_action()
X
X    {
X    if ( reject || num_backtracking == 0 )
X	return;
X
X    set_indent( 3 );
X
X    indent_puts( "case 0: /* must backtrack */" );
X    indent_puts( "/* undo the effects of YY_DO_BEFORE_ACTION */" );
X    indent_puts( "*yy_cp = yy_hold_char;" );
X
X    if ( fullspd || fulltbl )
X	indent_puts( "yy_cp = yy_last_accepting_cpos + 1;" );
X    else
X	/* backtracking info for compressed tables is taken \after/
X	 * yy_cp has been incremented for the next state
X	 */
X	indent_puts( "yy_cp = yy_last_accepting_cpos;" );
X
X    indent_puts( "yy_current_state = yy_last_accepting_state;" );
X    indent_puts( "goto yy_find_action;" );
X    putchar( '\n' );
X
X    set_indent( 0 );
X    }
X
X
X/* genctbl - generates full speed compressed transition table
X *
X * synopsis
X *     genctbl();
X */
X
Xvoid genctbl()
X
X    {
X    register int i;
X    int end_of_buffer_action = num_rules + 1;
X
X    /* table of verify for transition and offset to next state */
X    printf( "static const struct yy_trans_info yy_transition[%d] =\n",
X	    tblend + numecs + 1 );
X    printf( "    {\n" );
X    
X    /* We want the transition to be represented as the offset to the
X     * next state, not the actual state number, which is what it currently is.
X     * The offset is base[nxt[i]] - base[chk[i]].  That's just the
X     * difference between the starting points of the two involved states
X     * (to - from).
X     *
X     * first, though, we need to find some way to put in our end-of-buffer
X     * flags and states.  We do this by making a state with absolutely no
X     * transitions.  We put it at the end of the table.
X     */
X    /* at this point, we're guaranteed that there's enough room in nxt[]
X     * and chk[] to hold tblend + numecs entries.  We need just two slots.
X     * One for the action and one for the end-of-buffer transition.  We
X     * now *assume* that we're guaranteed the only character we'll try to
X     * index this nxt/chk pair with is EOB, i.e., 0, so we don't have to
X     * make sure there's room for jam entries for other characters.
X     */
X
X    base[lastdfa + 1] = tblend + 2;
X    nxt[tblend + 1] = end_of_buffer_action;
X    chk[tblend + 1] = numecs + 1;
X    chk[tblend + 2] = 1; /* anything but EOB */
X    nxt[tblend + 2] = 0; /* so that "make test" won't show arb. differences */
X
X    /* make sure every state has a end-of-buffer transition and an action # */
X    for ( i = 0; i <= lastdfa; ++i )
X	{
X	register int anum = dfaacc[i].dfaacc_state;
X
X	chk[base[i]] = EOB_POSITION;
X	chk[base[i] - 1] = ACTION_POSITION;
X	nxt[base[i] - 1] = anum;	/* action number */
X	}
X
X    for ( i = 0; i <= tblend; ++i )
X	{
X	if ( chk[i] == EOB_POSITION )
X	    transition_struct_out( 0, base[lastdfa + 1] - i );
X
X	else if ( chk[i] == ACTION_POSITION )
X	    transition_struct_out( 0, nxt[i] );
X
X	else if ( chk[i] > numecs || chk[i] == 0 )
X	    transition_struct_out( 0, 0 );		/* unused slot */
X
X	else	/* verify, transition */
X	    transition_struct_out( chk[i], base[nxt[i]] - (i - chk[i]) );
X	}
X
X
X    /* here's the final, end-of-buffer state */
X    transition_struct_out( chk[tblend + 1], nxt[tblend + 1] );
X    transition_struct_out( chk[tblend + 2], nxt[tblend + 2] );
X
X    printf( "    };\n" );
X    printf( "\n" );
X
X    /* table of pointers to start states */
X    printf( "static const struct yy_trans_info *yy_start_state_list[%d] =\n",
X	    lastsc * 2 + 1 );
X    printf( "    {\n" );
X
X    for ( i = 0; i <= lastsc * 2; ++i )
X	printf( "    &yy_transition[%d],\n", base[i] );
X
X    dataend();
X
X    if ( useecs )
X	genecs();
X    }
X
X
X/* generate equivalence-class tables */
X
Xvoid genecs()
X
X    {
X    register int i, j;
X    static char C_char_decl[] = "static const %s %s[%d] =\n    {   0,\n";
X    int numrows;
X    Char clower();
X
X    if ( numecs < csize )
X	printf( C_char_decl, "YY_CHAR", "yy_ec", csize );
X    else
X	printf( C_char_decl, "short", "yy_ec", csize );
X
X    for ( i = 1; i < csize; ++i )
X	{
X	if ( caseins && (i >= 'A') && (i <= 'Z') )
X	    ecgroup[i] = ecgroup[clower( i )];
X
X	ecgroup[i] = abs( ecgroup[i] );
X	mkdata( ecgroup[i] );
X	}
X
X    dataend();
X
X    if ( trace )
X	{
X	char *readable_form();
X
X	fputs( "\n\nEquivalence Classes:\n\n", stderr );
X
X	numrows = csize / 8;
X
X	for ( j = 0; j < numrows; ++j )
X	    {
X	    for ( i = j; i < csize; i = i + numrows )
X		{
X		fprintf( stderr, "%4s = %-2d", readable_form( i ), ecgroup[i] );
X
X		putc( ' ', stderr );
X		}
X
X	    putc( '\n', stderr );
X	    }
X	}
X    }
X
X
X/* generate the code to find the action number */
X
Xvoid gen_find_action()
X
X    {
X    if ( fullspd )
X	indent_puts( "yy_act = yy_current_state[-1].yy_nxt;" );
X
X    else if ( fulltbl )
X	indent_puts( "yy_act = yy_accept[yy_current_state];" );
X
X    else if ( reject )
X	{
X	indent_puts( "yy_current_state = *--yy_state_ptr;" );
X	indent_puts( "yy_lp = yy_accept[yy_current_state];" );
X
X	puts( "find_rule: /* we branch to this label when backtracking */" );
X
X	indent_puts( "for ( ; ; ) /* until we find what rule we matched */" );
X
X	indent_up();
X
X	indent_puts( "{" );
X
X	indent_puts( "if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )" );
X	indent_up();
X	indent_puts( "{" );
X	indent_puts( "yy_act = yy_acclist[yy_lp];" );
X
X	if ( variable_trailing_context_rules )
X	    {
X	    indent_puts( "if ( yy_act & YY_TRAILING_HEAD_MASK ||" );
X	    indent_puts( "     yy_looking_for_trail_begin )" );
X	    indent_up();
X	    indent_puts( "{" );
X
X	    indent_puts( "if ( yy_act == yy_looking_for_trail_begin )" );
X	    indent_up();
X	    indent_puts( "{" );
X	    indent_puts( "yy_looking_for_trail_begin = 0;" );
X	    indent_puts( "yy_act &= ~YY_TRAILING_HEAD_MASK;" );
X	    indent_puts( "break;" );
X	    indent_puts( "}" );
X	    indent_down();
X
X	    indent_puts( "}" );
X	    indent_down();
X
X	    indent_puts( "else if ( yy_act & YY_TRAILING_MASK )" );
X	    indent_up();
X	    indent_puts( "{" );
X	    indent_puts(
X		"yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;" );
X	    indent_puts(
X		"yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;" );
X
X	    if ( real_reject )
X		{
X		/* remember matched text in case we back up due to REJECT */
X		indent_puts( "yy_full_match = yy_cp;" );
X		indent_puts( "yy_full_state = yy_state_ptr;" );
X		indent_puts( "yy_full_lp = yy_lp;" );
X		}
X
X	    indent_puts( "}" );
X	    indent_down();
X
X	    indent_puts( "else" );
X	    indent_up();
X	    indent_puts( "{" );
X	    indent_puts( "yy_full_match = yy_cp;" );
X	    indent_puts( "yy_full_state = yy_state_ptr;" );
X	    indent_puts( "yy_full_lp = yy_lp;" );
X	    indent_puts( "break;" );
X	    indent_puts( "}" );
X	    indent_down();
X
X	    indent_puts( "++yy_lp;" );
X	    indent_puts( "goto find_rule;" );
X	    }
X
X	else
X	    {
X	    /* remember matched text in case we back up due to trailing context
X	     * plus REJECT
X	     */
X	    indent_up();
X	    indent_puts( "{" );
X	    indent_puts( "yy_full_match = yy_cp;" );
X	    indent_puts( "break;" );
X	    indent_puts( "}" );
X	    indent_down();
X	    }
X
X	indent_puts( "}" );
X	indent_down();
X
X	indent_puts( "--yy_cp;" );
X
X	/* we could consolidate the following two lines with those at
X	 * the beginning, but at the cost of complaints that we're
X	 * branching inside a loop
X	 */
X	indent_puts( "yy_current_state = *--yy_state_ptr;" );
X	indent_puts( "yy_lp = yy_accept[yy_current_state];" );
X
X	indent_puts( "}" );
X
X	indent_down();
X	}
X
X    else
X	/* compressed */
X	indent_puts( "yy_act = yy_accept[yy_current_state];" );
X    }
X
X
X/* genftbl - generates full transition table
X *
X * synopsis
X *     genftbl();
X */
X
Xvoid genftbl()
X
X    {
X    register int i;
X    int end_of_buffer_action = num_rules + 1;
X
X    printf( C_short_decl, "yy_accept", lastdfa + 1 );
X
X
X    dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
X
X    for ( i = 1; i <= lastdfa; ++i )
X	{
X	register int anum = dfaacc[i].dfaacc_state;
X
X	mkdata( anum );
X
X	if ( trace && anum )
X	    fprintf( stderr, "state # %d accepts: [%d]\n", i, anum );
X	}
X
X    dataend();
X
X    if ( useecs )
X	genecs();
X
X    /* don't have to dump the actual full table entries - they were created
X     * on-the-fly
X     */
X    }
X
X
X/* generate the code to find the next compressed-table state */
X
Xvoid gen_next_compressed_state( char_map )
Xchar *char_map;
X
X    {
X    indent_put2s( "register YY_CHAR yy_c = %s;", char_map );
X
X    /* save the backtracking info \before/ computing the next state
X     * because we always compute one more state than needed - we
X     * always proceed until we reach a jam state
X     */
X    gen_backtracking();
X
X    indent_puts(
X    "while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )" );
X    indent_up();
X    indent_puts( "{" );
X    indent_puts( "yy_current_state = yy_def[yy_current_state];" );
X
X    if ( usemecs )
X	{
X	/* we've arrange it so that templates are never chained
X	 * to one another.  This means we can afford make a
X	 * very simple test to see if we need to convert to
X	 * yy_c's meta-equivalence class without worrying
X	 * about erroneously looking up the meta-equivalence
X	 * class twice
X	 */
X	do_indent();
X	/* lastdfa + 2 is the beginning of the templates */
X	printf( "if ( yy_current_state >= %d )\n", lastdfa + 2 );
X
X	indent_up();
X	indent_puts( "yy_c = yy_meta[yy_c];" );
X	indent_down();
X	}
X
X    indent_puts( "}" );
X    indent_down();
X
X    indent_puts(
X	"yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];" );
X    }
X
X
X/* generate the code to find the next match */
X
Xvoid gen_next_match()
X
X    {
X    /* NOTE - changes in here should be reflected in gen_next_state() and
X     * gen_NUL_trans()
X     */
X    char *char_map = useecs ? "yy_ec[*yy_cp]" : "*yy_cp";
X    char *char_map_2 = useecs ? "yy_ec[*++yy_cp]" : "*++yy_cp";
X    
X    if ( fulltbl )
X	{
X	indent_put2s(
X	    "while ( (yy_current_state = yy_nxt[yy_current_state][%s]) > 0 )",
X		char_map );
X
X	indent_up();
X
X	if ( num_backtracking > 0 )
X	    {
X	    indent_puts( "{" );
X	    gen_backtracking();
X	    putchar( '\n' );
X	    }
X
X	indent_puts( "++yy_cp;" );
X
X	if ( num_backtracking > 0 )
X	    indent_puts( "}" );
X
X	indent_down();
X
X	putchar( '\n' );
X	indent_puts( "yy_current_state = -yy_current_state;" );
X	}
X
X    else if ( fullspd )
X	{
X	indent_puts( "{" );
X	indent_puts( "register const struct yy_trans_info *yy_trans_info;\n" );
X	indent_puts( "register YY_CHAR yy_c;\n" );
X	indent_put2s( "for ( yy_c = %s;", char_map );
X	indent_puts(
X	"      (yy_trans_info = &yy_current_state[yy_c])->yy_verify == yy_c;" );
X	indent_put2s( "      yy_c = %s )", char_map_2 );
X
X	indent_up();
X
X	if ( num_backtracking > 0 )
X	    indent_puts( "{" );
X
X	indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
X
X	if ( num_backtracking > 0 )
X	    {
X	    putchar( '\n' );
X	    gen_backtracking();
X	    indent_puts( "}" );
X	    }
X
X	indent_down();
X	indent_puts( "}" );
X	}
X
X    else
X	{ /* compressed */
X	indent_puts( "do" );
X
X	indent_up();
X	indent_puts( "{" );
X
X	gen_next_state( false );
X
X	indent_puts( "++yy_cp;" );
X
X	indent_puts( "}" );
X	indent_down();
X
X	do_indent();
X
X	if ( interactive )
X	    printf( "while ( yy_base[yy_current_state] != %d );\n", jambase );
X	else
X	    printf( "while ( yy_current_state != %d );\n", jamstate );
X
X	if ( ! reject && ! interactive )
X	    {
X	    /* do the guaranteed-needed backtrack to figure out the match */
X	    indent_puts( "yy_cp = yy_last_accepting_cpos;" );
X	    indent_puts( "yy_current_state = yy_last_accepting_state;" );
X	    }
X	}
X    }
X
X
X/* generate the code to find the next state */
X
Xvoid gen_next_state( worry_about_NULs )
Xint worry_about_NULs;
X
X    { /* NOTE - changes in here should be reflected in get_next_match() */
X    char char_map[256];
X
X    if ( worry_about_NULs && ! nultrans )
X	{
X	if ( useecs )
X	    (void) sprintf( char_map, "(*yy_cp ? yy_ec[*yy_cp] : %d)", NUL_ec );
X	else
X	    (void) sprintf( char_map, "(*yy_cp ? *yy_cp : %d)", NUL_ec );
X	}
X
X    else
X	(void) strcpy( char_map, useecs ? "yy_ec[*yy_cp]" : "*yy_cp" );
X
X    if ( worry_about_NULs && nultrans )
X	{
X	if ( ! fulltbl && ! fullspd )
X	    /* compressed tables backtrack *before* they match */
X	    gen_backtracking();
X
X	indent_puts( "if ( *yy_cp )" );
X	indent_up();
X	indent_puts( "{" );
X	}
X   
X    if ( fulltbl )
X	indent_put2s( "yy_current_state = yy_nxt[yy_current_state][%s];", 
X		char_map );
X    
X    else if ( fullspd )
X	indent_put2s( "yy_current_state += yy_current_state[%s].yy_nxt;",
X		    char_map );
X
X    else
X	gen_next_compressed_state( char_map );
X
X    if ( worry_about_NULs && nultrans )
X	{
X	indent_puts( "}" );
X	indent_down();
X	indent_puts( "else" );
X	indent_up();
X	indent_puts( "yy_current_state = yy_NUL_trans[yy_current_state];" );
X	indent_down();
X	}
X    
X    if ( fullspd || fulltbl )
X	gen_backtracking();
X
X    if ( reject )
X	indent_puts( "*yy_state_ptr++ = yy_current_state;" );
X    }
X
X
X/* generate the code to make a NUL transition */
X
Xvoid gen_NUL_trans()
X
X    { /* NOTE - changes in here should be reflected in get_next_match() */
X    int need_backtracking = (num_backtracking > 0 && ! reject);
X
X    if ( need_backtracking )
X	/* we'll need yy_cp lying around for the gen_backtracking() */
X	indent_puts( "register YY_CHAR *yy_cp = yy_c_buf_p;" );
X
X    putchar( '\n' );
X
X    if ( nultrans )
X	{
X	indent_puts( "yy_current_state = yy_NUL_trans[yy_current_state];" );
X	indent_puts( "yy_is_jam = (yy_current_state == 0);" );
X	}
X
X    else if ( fulltbl )
X	{
X	do_indent();
X	printf( "yy_current_state = yy_nxt[yy_current_state][%d];\n",
X		NUL_ec );
X	indent_puts( "yy_is_jam = (yy_current_state <= 0);" );
X	}
X
X    else if ( fullspd )
X	{
X	do_indent();
X	printf( "register int yy_c = %d;\n", NUL_ec );
X
X	indent_puts(
X	    "register const struct yy_trans_info *yy_trans_info;\n" );
X	indent_puts( "yy_trans_info = &yy_current_state[yy_c];" );
X	indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
X
X	indent_puts( "yy_is_jam = (yy_trans_info->yy_verify != yy_c);" );
X	}
X
X    else
X	{
X	char NUL_ec_str[20];
X
X	(void) sprintf( NUL_ec_str, "%d", NUL_ec );
X	gen_next_compressed_state( NUL_ec_str );
X
X	if ( reject )
X	    indent_puts( "*yy_state_ptr++ = yy_current_state;" );
X
X	do_indent();
X
X	if ( interactive )
X	    printf( "yy_is_jam = (yy_base[yy_current_state] == %d);\n",
X		    jambase );
X	else
X	    printf( "yy_is_jam = (yy_current_state == %d);\n", jamstate );
X	}
X
X    /* if we've entered an accepting state, backtrack; note that
X     * compressed tables have *already* done such backtracking, so
X     * we needn't bother with it again
X     */
X    if ( need_backtracking && (fullspd || fulltbl) )
X	{
X	putchar( '\n' );
X	indent_puts( "if ( ! yy_is_jam )" );
X	indent_up();
X	indent_puts( "{" );
X	gen_backtracking();
X	indent_puts( "}" );
X	indent_down();
X	}
X    }
X
X
X/* generate the code to find the start state */
X
Xvoid gen_start_state()
X
X    {
X    if ( fullspd )
X	indent_put2s( "yy_current_state = yy_start_state_list[yy_start%s];",
X		bol_needed ? " + (yy_bp[-1] == '\\n' ? 1 : 0)" : "" );
X
X    else
X	{
X	indent_puts( "yy_current_state = yy_start;" );
X
X	if ( bol_needed )
X	    {
X	    indent_puts( "if ( yy_bp[-1] == '\\n' )" );
X	    indent_up();
X	    indent_puts( "++yy_current_state;" );
X	    indent_down();
X	    }
X
X	if ( reject )
X	    {
X	    /* set up for storing up states */
X	    indent_puts( "yy_state_ptr = yy_state_buf;" );
X	    indent_puts( "*yy_state_ptr++ = yy_current_state;" );
X	    }
X	}
X    }
X
X
X/* gentabs - generate data statements for the transition tables
X *
X * synopsis
X *    gentabs();
X */
X
Xvoid gentabs()
X
X    {
X    int i, j, k, *accset, nacc, *acc_array, total_states;
X    int end_of_buffer_action = num_rules + 1;
X
X    /* *everything* is done in terms of arrays starting at 1, so provide
X     * a null entry for the zero element of all C arrays
X     */
X    static char C_char_decl[] =
X	"static const YY_CHAR %s[%d] =\n    {   0,\n";
X
X    acc_array = allocate_integer_array( current_max_dfas );
X    nummt = 0;
X
X    /* the compressed table format jams by entering the "jam state",
X     * losing information about the previous state in the process.
X     * In order to recover the previous state, we effectively need
X     * to keep backtracking information.
X     */
X    ++num_backtracking;
X
X    if ( reject )
X	{
X	/* write out accepting list and pointer list
X	 *
X	 * first we generate the "yy_acclist" array.  In the process, we compute
X	 * the indices that will go into the "yy_accept" array, and save the
X	 * indices in the dfaacc array
X	 */
X	int EOB_accepting_list[2];
X
X	/* set up accepting structures for the End Of Buffer state */
X	EOB_accepting_list[0] = 0;
X	EOB_accepting_list[1] = end_of_buffer_action;
X	accsiz[end_of_buffer_state] = 1;
X	dfaacc[end_of_buffer_state].dfaacc_set = EOB_accepting_list;
X
X	printf( C_short_decl, "yy_acclist", max( numas, 1 ) + 1 );
X
X	j = 1;	/* index into "yy_acclist" array */
X
X	for ( i = 1; i <= lastdfa; ++i )
X	    {
X	    acc_array[i] = j;
X
X	    if ( accsiz[i] != 0 )
X		{
X		accset = dfaacc[i].dfaacc_set;
X		nacc = accsiz[i];
X
X		if ( trace )
X		    fprintf( stderr, "state # %d accepts: ", i );
X
X		for ( k = 1; k <= nacc; ++k )
X		    {
X		    int accnum = accset[k];
X
X		    ++j;
X
X		    if ( variable_trailing_context_rules &&
X			 ! (accnum & YY_TRAILING_HEAD_MASK) &&
X			 accnum > 0 &&
X			 rule_type[accnum] == RULE_VARIABLE )
X			{
X			/* special hack to flag accepting number as part
X			 * of trailing context rule
X			 */
X			accnum |= YY_TRAILING_MASK;
X			}
X
X		    mkdata( accnum );
X
X		    if ( trace )
X			{
X			fprintf( stderr, "[%d]", accset[k] );
X
X			if ( k < nacc )
X			    fputs( ", ", stderr );
X			else
X			    putc( '\n', stderr );
X			}
X		    }
X		}
X	    }
X
X	/* add accepting number for the "jam" state */
X	acc_array[i] = j;
X
X	dataend();
X	}
X
X    else
X	{
X	dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
X
X	for ( i = 1; i <= lastdfa; ++i )
X	    acc_array[i] = dfaacc[i].dfaacc_state;
X
X	/* add accepting number for jam state */
X	acc_array[i] = 0;
X	}
X
X    /* spit out "yy_accept" array.  If we're doing "reject", it'll be pointers
X     * into the "yy_acclist" array.  Otherwise it's actual accepting numbers.
X     * In either case, we just dump the numbers.
X     */
X
X    /* "lastdfa + 2" is the size of "yy_accept"; includes room for C arrays
X     * beginning at 0 and for "jam" state
X     */
X    k = lastdfa + 2;
X
X    if ( reject )
X	/* we put a "cap" on the table associating lists of accepting
X	 * numbers with state numbers.  This is needed because we tell
X	 * where the end of an accepting list is by looking at where
X	 * the list for the next state starts.
X	 */
X	++k;
X
X    printf( C_short_decl, "yy_accept", k );
X
X    for ( i = 1; i <= lastdfa; ++i )
X	{
X	mkdata( acc_array[i] );
X
X	if ( ! reject && trace && acc_array[i] )
X	    fprintf( stderr, "state # %d accepts: [%d]\n", i, acc_array[i] );
X	}
X
X    /* add entry for "jam" state */
X    mkdata( acc_array[i] );
X
X    if ( reject )
X	/* add "cap" for the list */
X	mkdata( acc_array[i] );
X
X    dataend();
X
X    if ( useecs )
X	genecs();
X
X    if ( usemecs )
X	{
X	/* write out meta-equivalence classes (used to index templates with) */
X
X	if ( trace )
X	    fputs( "\n\nMeta-Equivalence Classes:\n", stderr );
X
X	printf( C_char_decl, "yy_meta", numecs + 1 );
X
X	for ( i = 1; i <= numecs; ++i )
X	    {
X	    if ( trace )
X		fprintf( stderr, "%d = %d\n", i, abs( tecbck[i] ) );
X
X	    mkdata( abs( tecbck[i] ) );
X	    }
X
X	dataend();
X	}
X
X    total_states = lastdfa + numtemps;
X
X    printf( tblend > MAX_SHORT ? C_long_decl : C_short_decl,
X	    "yy_base", total_states + 1 );
X
X    for ( i = 1; i <= lastdfa; ++i )
X	{
X	register int d = def[i];
X
X	if ( base[i] == JAMSTATE )
X	    base[i] = jambase;
X
X	if ( d == JAMSTATE )
X	    def[i] = jamstate;
X
X	else if ( d < 0 )
X	    {
X	    /* template reference */
X	    ++tmpuses;
X	    def[i] = lastdfa - d + 1;
X	    }
X
X	mkdata( base[i] );
X	}
X
X    /* generate jam state's base index */
X    mkdata( base[i] );
X
X    for ( ++i /* skip jam state */; i <= total_states; ++i )
X	{
X	mkdata( base[i] );
X	def[i] = jamstate;
X	}
X
X    dataend();
X
X    printf( tblend > MAX_SHORT ? C_long_decl : C_short_decl,
X	    "yy_def", total_states + 1 );
X
X    for ( i = 1; i <= total_states; ++i )
X	mkdata( def[i] );
X
X    dataend();
X
X    printf( lastdfa > MAX_SHORT ? C_long_decl : C_short_decl,
X	    "yy_nxt", tblend + 1 );
X
X    for ( i = 1; i <= tblend; ++i )
X	{
X	if ( nxt[i] == 0 || chk[i] == 0 )
X	    nxt[i] = jamstate;	/* new state is the JAM state */
X
X	mkdata( nxt[i] );
X	}
X
X    dataend();
X
X    printf( lastdfa > MAX_SHORT ? C_long_decl : C_short_decl,
X	    "yy_chk", tblend + 1 );
X
X    for ( i = 1; i <= tblend; ++i )
X	{
X	if ( chk[i] == 0 )
X	    ++nummt;
X
X	mkdata( chk[i] );
X	}
X
X    dataend();
X    }
X
X
X/* write out a formatted string (with a secondary string argument) at the
X * current indentation level, adding a final newline
X */
X
Xvoid indent_put2s( fmt, arg )
Xchar fmt[], arg[];
X
X    {
X    do_indent();
X    printf( fmt, arg );
X    putchar( '\n' );
X    }
X
X
X/* write out a string at the current indentation level, adding a final
X * newline
X */
X
Xvoid indent_puts( str )
Xchar str[];
X
X    {
X    do_indent();
X    puts( str );
X    }
X
X
X/* make_tables - generate transition tables
X *
X * synopsis
X *     make_tables();
X *
X * Generates transition tables and finishes generating output file
X */
X
Xvoid make_tables()
X
X    {
X    register int i;
X    int did_eof_rule = false;
X
X    skelout();
X
X    /* first, take care of YY_DO_BEFORE_ACTION depending on yymore being used */
X    set_indent( 2 );
X
X    if ( yymore_used )
X	{
X	indent_puts( "yytext -= yy_more_len; \\" );
X	indent_puts( "yyleng = yy_cp - yytext; \\" );
X	}
X
X    else
X	indent_puts( "yyleng = yy_cp - yy_bp; \\" );
X
X    set_indent( 0 );
X    
X    skelout();
X
X
X    printf( "#define YY_END_OF_BUFFER %d\n", num_rules + 1 );
X
X    if ( fullspd )
X	{ /* need to define the transet type as a size large
X	   * enough to hold the biggest offset
X	   */
X	int total_table_size = tblend + numecs + 1;
X	char *trans_offset_type =
X	    total_table_size > MAX_SHORT ? "long" : "short";
X
X	set_indent( 0 );
X	indent_puts( "struct yy_trans_info" );
X	indent_up();
X        indent_puts( "{" );
X        indent_puts( "short yy_verify;" );
X
X        /* in cases where its sister yy_verify *is* a "yes, there is a
X	 * transition", yy_nxt is the offset (in records) to the next state.
X	 * In most cases where there is no transition, the value of yy_nxt
X	 * is irrelevant.  If yy_nxt is the -1th  record of a state, though,
X	 * then yy_nxt is the action number for that state
X         */
X
X        indent_put2s( "%s yy_nxt;", trans_offset_type );
X        indent_puts( "};" );
X	indent_down();
X
X	indent_puts( "typedef const struct yy_trans_info *yy_state_type;" );
X	}
X    
X    else
X	indent_puts( "typedef int yy_state_type;" );
X
X    if ( fullspd )
X	genctbl();
X
X    else if ( fulltbl )
X	genftbl();
X
X    else
X	gentabs();
X
X    if ( num_backtracking > 0 )
X	{
X	indent_puts( "static yy_state_type yy_last_accepting_state;" );
X	indent_puts( "static YY_CHAR *yy_last_accepting_cpos;\n" );
X	}
X
X    if ( nultrans )
X	{
X	printf( C_state_decl, "yy_NUL_trans", lastdfa + 1 );
X
X	for ( i = 1; i <= lastdfa; ++i )
X	    {
X	    if ( fullspd )
X		{
X		if ( nultrans )
X		    printf( "    &yy_transition[%d],\n", base[i] );
X		else
X		    printf( "    0,\n" );
X		}
X	    
X	    else
X		mkdata( nultrans[i] );
X	    }
X
X	dataend();
X	}
X
X    if ( ddebug )
X	{ /* spit out table mapping rules to line numbers */
X	indent_puts( "extern int yy_flex_debug;" );
X	indent_puts( "int yy_flex_debug = 1;\n" );
X
X	printf( C_short_decl, "yy_rule_linenum", num_rules );
X	for ( i = 1; i < num_rules; ++i )
X	    mkdata( rule_linenum[i] );
X	dataend();
X	}
X
X    if ( reject )
X	{
X	/* declare state buffer variables */
X	puts(
X	"static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;" );
X	puts( "static YY_CHAR *yy_full_match;" );
X	puts( "static int yy_lp;" );
X
X	if ( variable_trailing_context_rules )
X	    {
X	    puts( "static int yy_looking_for_trail_begin = 0;" );
X	    puts( "static int yy_full_lp;" );
X	    puts( "static int *yy_full_state;" );
X	    printf( "#define YY_TRAILING_MASK 0x%x\n", YY_TRAILING_MASK );
X	    printf( "#define YY_TRAILING_HEAD_MASK 0x%x\n",
X		    YY_TRAILING_HEAD_MASK );
X	    }
X
X	puts( "#define REJECT \\" );
X        puts( "{ \\" );
X        puts(
X	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \\" );
X        puts(
X	    "yy_cp = yy_full_match; /* restore poss. backed-over text */ \\" );
X
X	if ( variable_trailing_context_rules )
X	    {
X	    puts( "yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \\" );
X	    puts(
X		"yy_state_ptr = yy_full_state; /* restore orig. state */ \\" );
X	    puts(
X	    "yy_current_state = *yy_state_ptr; /* restore curr. state */ \\" );
X	    }
X
X        puts( "++yy_lp; \\" );
X        puts( "goto find_rule; \\" );
X        puts( "}" );
X	}
X    
X    else
X	{
X	puts( "/* the intent behind this definition is that it'll catch" );
X	puts( " * any uses of REJECT which flex missed" );
X	puts( " */" );
X	puts( "#define REJECT reject_used_but_not_detected" );
X	}
X    
X    if ( yymore_used )
X	{
X	indent_puts( "static int yy_more_flag = 0;" );
X	indent_puts( "static int yy_doing_yy_more = 0;" );
X	indent_puts( "static int yy_more_len = 0;" );
X	indent_puts(
X	    "#define yymore() { yy_more_flag = 1; }" );
X	indent_puts(
X	    "#define YY_MORE_ADJ (yy_doing_yy_more ? yy_more_len : 0)" );
X	}
X
X    else
X	{
X	indent_puts( "#define yymore() yymore_used_but_not_detected" );
X	indent_puts( "#define YY_MORE_ADJ 0" );
X	}
X
X    skelout();
X
X    if ( ferror( temp_action_file ) )
X	flexfatal( "error occurred when writing temporary action file" );
X
X    else if ( fclose( temp_action_file ) )
X	flexfatal( "error occurred when closing temporary action file" );
X
X    temp_action_file = fopen( action_file_name, "r" );
X
X    if ( temp_action_file == NULL )
X	flexfatal( "could not re-open temporary action file" );
X
X    /* copy prolog from action_file to output file */
X    action_out();
X
X    skelout();
X
X    set_indent( 2 );
X
X    if ( yymore_used )
X	{
X	indent_puts( "yy_more_len = 0;" );
X	indent_puts( "yy_doing_yy_more = yy_more_flag;" );
X	indent_puts( "if ( yy_doing_yy_more )" );
X	indent_up();
X	indent_puts( "{" );
X	indent_puts( "yy_more_len = yyleng;" );
X	indent_puts( "yy_more_flag = 0;" );
X	indent_puts( "}" );
X	indent_down();
X	}
X
X    skelout();
X
X    gen_start_state();
X
X    /* note, don't use any indentation */
X    puts( "yy_match:" );
X    gen_next_match();
X
X    skelout();
X    set_indent( 2 );
X    gen_find_action();
X
X    skelout();
X    if ( ddebug )
X	{
X	indent_puts( "if ( yy_flex_debug )" );
X	indent_up();
X
X	indent_puts( "{" );
X	indent_puts( "if ( yy_act == 0 )" );
X	indent_up();
X	indent_puts( "fprintf( stderr, \"--scanner backtracking\\n\" );" );
X	indent_down();
X
X	do_indent();
X	printf( "else if ( yy_act < %d )\n", num_rules );
X	indent_up();
X	indent_puts(
X	"fprintf( stderr, \"--accepting rule at line %d (\\\"%s\\\")\\n\"," );
X	indent_puts( "         yy_rule_linenum[yy_act], yytext );" );
X	indent_down();
X
X	do_indent();
X	printf( "else if ( yy_act == %d )\n", num_rules );
X	indent_up();
X	indent_puts(
X	"fprintf( stderr, \"--accepting default rule (\\\"%s\\\")\\n\"," );
X	indent_puts( "         yytext );" );
X	indent_down();
X
X	do_indent();
X	printf( "else if ( yy_act == %d )\n", num_rules + 1 );
X	indent_up();
X	indent_puts( "fprintf( stderr, \"--(end of buffer or a NUL)\\n\" );" );
X	indent_down();
X
X	do_indent();
X	printf( "else\n" );
X	indent_up();
X	indent_puts( "fprintf( stderr, \"--EOF\\n\" );" );
X	indent_down();
X
X	indent_puts( "}" );
X	indent_down();
X	}
X
X    /* copy actions from action_file to output file */
X    skelout();
X    indent_up();
X    gen_bt_action();
X    action_out();
X
X    /* generate cases for any missing EOF rules */
X    for ( i = 1; i <= lastsc; ++i )
X	if ( ! sceof[i] )
X	    {
X	    do_indent();
X	    printf( "case YY_STATE_EOF(%s):\n", scname[i] );
X	    did_eof_rule = true;
X	    }
X    
X    if ( did_eof_rule )
X	{
X	indent_up();
X	indent_puts( "yyterminate();" );
X	indent_down();
X	}
X
X
X    /* generate code for handling NUL's, if needed */
X
X    /* first, deal with backtracking and setting up yy_cp if the scanner
X     * finds that it should JAM on the NUL
X     */
X    skelout();
X    set_indent( 7 );
X
X    if ( fullspd || fulltbl )
X	indent_puts( "yy_cp = yy_c_buf_p;" );
X    
X    else
X	{ /* compressed table */
X	if ( ! reject && ! interactive )
X	    {
X	    /* do the guaranteed-needed backtrack to figure out the match */
X	    indent_puts( "yy_cp = yy_last_accepting_cpos;" );
X	    indent_puts( "yy_current_state = yy_last_accepting_state;" );
X	    }
X	}
X
X
X    /* generate code for yy_get_previous_state() */
X    set_indent( 1 );
X    skelout();
X
X    if ( bol_needed )
X	indent_puts( "register YY_CHAR *yy_bp = yytext;\n" );
X
X    gen_start_state();
X
X    set_indent( 2 );
X    skelout();
X    gen_next_state( true );
X
X    set_indent( 1 );
X    skelout();
X    gen_NUL_trans();
X
X    skelout();
X
X    /* copy remainder of input to output */
X
X    line_directive_out( stdout );
X    (void) flexscan(); /* copy remainder of input to output */
X    }
END_OF_FILE
  if test 31594 -ne `wc -c <'gen.c'`; then
    echo shar: \"'gen.c'\" unpacked with wrong size!
  fi
  # end of 'gen.c'
fi
if test -f 'libmain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libmain.c'\"
else
  echo shar: Extracting \"'libmain.c'\" \(256 characters\)
  sed "s/^X//" >'libmain.c' <<'END_OF_FILE'
X/* libmain - flex run-time support library "main" function */
X
X/* $Header: /usr/fsys/odin/a/vern/flex/RCS/libmain.c,v 1.2 90/05/26 16:50:08 vern Exp $ */
X
Xextern int yylex();
X
Xint main( argc, argv )
Xint argc;
Xchar *argv[];
X
X    {
X    return yylex();
X    }
END_OF_FILE
  if test 256 -ne `wc -c <'libmain.c'`; then
    echo shar: \"'libmain.c'\" unpacked with wrong size!
  fi
  # end of 'libmain.c'
fi
if test -f 'scan.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scan.l'\"
else
  echo shar: Extracting \"'scan.l'\" \(12439 characters\)
  sed "s/^X//" >'scan.l' <<'END_OF_FILE'
X
X/* scan.l - scanner for flex input */
X
X%{
X/*-
X * Copyright (c) 1990 The Regents of the University of California.
X * All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Vern Paxson.
X * 
X * The United States Government has rights in this work pursuant
X * to contract no. DE-AC03-76SF00098 between the United States
X * Department of Energy and the University of California.
X *
X * Redistribution and use in source and binary forms are permitted provided
X * that: (1) source distributions retain this entire copyright notice and
X * comment, and (2) distributions including binaries display the following
X * acknowledgement:  ``This product includes software developed by the
X * University of California, Berkeley and its contributors'' in the
X * documentation or other materials provided with the distribution and in
X * all advertising materials mentioning features or use of this software.
X * Neither the name of the University nor the names of its contributors may
X * be used to endorse or promote products derived from this software without
X * specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
Xstatic char rcsid[] =
X    "@(#) $Header: /usr/fsys/odin/a/vern/flex/RCS/scan.l,v 2.9 90/06/27 23:48:34 vern Exp $ (LBL)";
X#endif
X
X#undef yywrap
X
X#include "flexdef.h"
X#include "parse.h"
X
X#define ACTION_ECHO fprintf( temp_action_file, "%s", yytext )
X#define MARK_END_OF_PROLOG fprintf( temp_action_file, "%%%% end of prolog\n" );
X
X#undef YY_DECL
X#define YY_DECL \
X	int flexscan()
X
X#define RETURNCHAR \
X	yylval = yytext[0]; \
X	return ( CHAR );
X
X#define RETURNNAME \
X	(void) strcpy( nmstr, (char *) yytext ); \
X	return ( NAME );
X
X#define PUT_BACK_STRING(str, start) \
X	for ( i = strlen( (char *) (str) ) - 1; i >= start; --i ) \
X	    unput((str)[i])
X
X#define CHECK_REJECT(str) \
X	if ( all_upper( str ) ) \
X	    reject = true;
X
X#define CHECK_YYMORE(str) \
X	if ( all_lower( str ) ) \
X	    yymore_used = true;
X%}
X
X%x SECT2 SECT2PROLOG SECT3 CODEBLOCK PICKUPDEF SC CARETISBOL NUM QUOTE
X%x FIRSTCCL CCL ACTION RECOVER BRACEERROR C_COMMENT ACTION_COMMENT
X%x ACTION_STRING PERCENT_BRACE_ACTION USED_LIST CODEBLOCK_2 XLATION
X
XWS		[ \t\f]+
XOPTWS		[ \t\f]*
XNOT_WS		[^ \t\f\n]
X
XNAME		[a-z_][a-z_0-9-]*
XNOT_NAME	[^a-z_\n]+
X
XSCNAME		{NAME}
X
XESCSEQ		\\([^\n]|[0-9]{1,3}|x[0-9a-f]{1,2})
X
X%%
X    static int bracelevel, didadef;
X    int i, indented_code, checking_used, new_xlation;
X    int doing_codeblock = false;
X    Char nmdef[MAXLINE], myesc();
X
X^{WS}			indented_code = true; BEGIN(CODEBLOCK);
X^#.*\n			++linenum; /* treat as a comment */
X^"/*"			ECHO; BEGIN(C_COMMENT);
X^"%s"{NAME}?		return ( SCDECL );
X^"%x"{NAME}?		return ( XSCDECL );
X^"%{".*\n		{
X			++linenum;
X			line_directive_out( stdout );
X			indented_code = false;
X			BEGIN(CODEBLOCK);
X			}
X
X{WS}			return ( WHITESPACE );
X
X^"%%".*			{
X			sectnum = 2;
X			line_directive_out( stdout );
X			BEGIN(SECT2PROLOG);
X			return ( SECTEND );
X			}
X
X^"%used"		{
X	pinpoint_message( "warning - %%used/%%unused have been deprecated" );
X			checking_used = REALLY_USED; BEGIN(USED_LIST);
X			}
X^"%unused"		{
X			checking_used = REALLY_NOT_USED; BEGIN(USED_LIST);
X	pinpoint_message( "warning - %%used/%%unused have been deprecated" );
X			checking_used = REALLY_NOT_USED; BEGIN(USED_LIST);
X			}
X
X
X^"%"[aeknopt]" ".*\n	{
X#ifdef NOTDEF
X			fprintf( stderr,
X			     "old-style lex command at line %d ignored:\n\t%s",
X				 linenum, yytext );
X#endif
X			++linenum;
X			}
X
X^"%"[cr]{OPTWS}		/* ignore old lex directive */
X
X%t{OPTWS}\n		{
X			++linenum;
X			xlation =
X			    (int *) malloc( sizeof( int ) * (unsigned) csize );
X
X			if ( ! xlation )
X			    flexfatal(
X				"dynamic memory failure building %t table" );
X
X			for ( i = 0; i < csize; ++i )
X			    xlation[i] = 0;
X
X			num_xlations = 0;
X
X			BEGIN(XLATION);
X			}
X
X^"%"[^sxanpekotcru{}]{OPTWS}	synerr( "unrecognized '%' directive" );
X
X^{NAME}			{
X			(void) strcpy( nmstr, (char *) yytext );
X			didadef = false;
X			BEGIN(PICKUPDEF);
X			}
X
X{SCNAME}		RETURNNAME;
X^{OPTWS}\n		++linenum; /* allows blank lines in section 1 */
X{OPTWS}\n		++linenum; return ( '\n' );
X.			synerr( "illegal character" ); BEGIN(RECOVER);
X
X
X<C_COMMENT>"*/"		ECHO; BEGIN(INITIAL);
X<C_COMMENT>"*/".*\n	++linenum; ECHO; BEGIN(INITIAL);
X<C_COMMENT>[^*\n]+	ECHO;
X<C_COMMENT>"*"		ECHO;
X<C_COMMENT>\n		++linenum; ECHO;
X
X
X<CODEBLOCK>^"%}".*\n	++linenum; BEGIN(INITIAL);
X<CODEBLOCK>"reject"	ECHO; CHECK_REJECT(yytext);
X<CODEBLOCK>"yymore"	ECHO; CHECK_YYMORE(yytext);
X<CODEBLOCK>{NAME}|{NOT_NAME}|.	ECHO;
X<CODEBLOCK>\n		{
X			++linenum;
X			ECHO;
X			if ( indented_code )
X			    BEGIN(INITIAL);
X			}
X
X
X<PICKUPDEF>{WS}		/* separates name and definition */
X
X<PICKUPDEF>{NOT_WS}.*	{
X			(void) strcpy( (char *) nmdef, (char *) yytext );
X
X			for ( i = strlen( (char *) nmdef ) - 1;
X			      i >= 0 &&
X			      nmdef[i] == ' ' || nmdef[i] == '\t';
X			      --i )
X			    ;
X
X			nmdef[i + 1] = '\0';
X
X                        ndinstal( nmstr, nmdef );
X			didadef = true;
X			}
X
X<PICKUPDEF>\n		{
X			if ( ! didadef )
X			    synerr( "incomplete name definition" );
X			BEGIN(INITIAL);
X			++linenum;
X			}
X
X<RECOVER>.*\n		++linenum; BEGIN(INITIAL); RETURNNAME;
X
X
X<USED_LIST>\n		++linenum; BEGIN(INITIAL);
X<USED_LIST>{WS}
X<USED_LIST>"reject"	{
X			if ( all_upper( yytext ) )
X			    reject_really_used = checking_used;
X			else
X			    synerr( "unrecognized %used/%unused construct" );
X			}
X<USED_LIST>"yymore"	{
X			if ( all_lower( yytext ) )
X			    yymore_really_used = checking_used;
X			else
X			    synerr( "unrecognized %used/%unused construct" );
X			}
X<USED_LIST>{NOT_WS}+	synerr( "unrecognized %used/%unused construct" );
X
X
X<XLATION>"%t"{OPTWS}\n	++linenum; BEGIN(INITIAL);
X<XLATION>^{OPTWS}[0-9]+	++num_xlations; new_xlation = true;
X<XLATION>^.		synerr( "bad row in translation table" );
X<XLATION>{WS}		/* ignore whitespace */
X
X<XLATION>{ESCSEQ}	{
X			xlation[myesc( yytext )] =
X				(new_xlation ? num_xlations : -num_xlations);
X			new_xlation = false;
X			}
X<XLATION>.		{
X			xlation[yytext[0]] =
X				(new_xlation ? num_xlations : -num_xlations);
X			new_xlation = false;
X			}
X
X<XLATION>\n		++linenum;
X
X
X<SECT2PROLOG>.*\n/{NOT_WS}	{
X			++linenum;
X			ACTION_ECHO;
X			MARK_END_OF_PROLOG;
X			BEGIN(SECT2);
X			}
X
X<SECT2PROLOG>.*\n	++linenum; ACTION_ECHO;
X
X<SECT2PROLOG><<EOF>>	MARK_END_OF_PROLOG; yyterminate();
X
X<SECT2>^{OPTWS}\n	++linenum; /* allow blank lines in section 2 */
X
X<SECT2>^({WS}|"%{")	{
X			indented_code = (yytext[0] != '%');
X			doing_codeblock = true;
X			bracelevel = 1;
X
X			if ( indented_code )
X			    ACTION_ECHO;
X
X			BEGIN(CODEBLOCK_2);
X			}
X
X<SECT2>"<"		BEGIN(SC); return ( '<' );
X<SECT2>^"^"		return ( '^' );
X<SECT2>\"		BEGIN(QUOTE); return ( '"' );
X<SECT2>"{"/[0-9]		BEGIN(NUM); return ( '{' );
X<SECT2>"{"[^0-9\n][^}\n]*	BEGIN(BRACEERROR);
X<SECT2>"$"/[ \t\n]	return ( '$' );
X
X<SECT2>{WS}"%{"		{
X			bracelevel = 1;
X			BEGIN(PERCENT_BRACE_ACTION);
X			return ( '\n' );
X			}
X<SECT2>{WS}"|".*\n	continued_action = true; ++linenum; return ( '\n' );
X
X<SECT2>{WS}		{
X			/* this rule is separate from the one below because
X			 * otherwise we get variable trailing context, so
X			 * we can't build the scanner using -{f,F}
X			 */
X			bracelevel = 0;
X			continued_action = false;
X			BEGIN(ACTION);
X			return ( '\n' );
X			}
X
X<SECT2>{OPTWS}/\n	{
X			bracelevel = 0;
X			continued_action = false;
X			BEGIN(ACTION);
X			return ( '\n' );
X			}
X
X<SECT2>^{OPTWS}\n	++linenum; return ( '\n' );
X
X<SECT2>"<<EOF>>"	return ( EOF_OP );
X
X<SECT2>^"%%".*		{
X			sectnum = 3;
X			BEGIN(SECT3);
X			return ( EOF ); /* to stop the parser */
X			}
X
X<SECT2>"["([^\\\]\n]|{ESCSEQ})+"]"	{
X			int cclval;
X
X			(void) strcpy( nmstr, (char *) yytext );
X
X			/* check to see if we've already encountered this ccl */
X			if ( (cclval = ccllookup( (Char *) nmstr )) )
X			    {
X			    yylval = cclval;
X			    ++cclreuse;
X			    return ( PREVCCL );
X			    }
X			else
X			    {
X			    /* we fudge a bit.  We know that this ccl will
X			     * soon be numbered as lastccl + 1 by cclinit
X			     */
X			    cclinstal( (Char *) nmstr, lastccl + 1 );
X
X			    /* push back everything but the leading bracket
X			     * so the ccl can be rescanned
X			     */
X			    PUT_BACK_STRING((Char *) nmstr, 1);
X
X			    BEGIN(FIRSTCCL);
X			    return ( '[' );
X			    }
X			}
X
X<SECT2>"{"{NAME}"}"	{
X			register Char *nmdefptr;
X			Char *ndlookup();
X
X			(void) strcpy( nmstr, (char *) yytext );
X			nmstr[yyleng - 1] = '\0';  /* chop trailing brace */
X
X			/* lookup from "nmstr + 1" to chop leading brace */
X			if ( ! (nmdefptr = ndlookup( nmstr + 1 )) )
X			    synerr( "undefined {name}" );
X
X			else
X			    { /* push back name surrounded by ()'s */
X			    unput(')');
X			    PUT_BACK_STRING(nmdefptr, 0);
X			    unput('(');
X			    }
X			}
X
X<SECT2>[/|*+?.()]	return ( yytext[0] );
X<SECT2>.		RETURNCHAR;
X<SECT2>\n		++linenum; return ( '\n' );
X
X
X<SC>","			return ( ',' );
X<SC>">"			BEGIN(SECT2); return ( '>' );
X<SC>">"/"^"		BEGIN(CARETISBOL); return ( '>' );
X<SC>{SCNAME}		RETURNNAME;
X<SC>.			synerr( "bad start condition name" );
X
X<CARETISBOL>"^"		BEGIN(SECT2); return ( '^' );
X
X
X<QUOTE>[^"\n]		RETURNCHAR;
X<QUOTE>\"		BEGIN(SECT2); return ( '"' );
X
X<QUOTE>\n		{
X			synerr( "missing quote" );
X			BEGIN(SECT2);
X			++linenum;
X			return ( '"' );
X			}
X
X
X<FIRSTCCL>"^"/[^-\n]	BEGIN(CCL); return ( '^' );
X<FIRSTCCL>"^"/-		return ( '^' );
X<FIRSTCCL>-		BEGIN(CCL); yylval = '-'; return ( CHAR );
X<FIRSTCCL>.		BEGIN(CCL); RETURNCHAR;
X
X<CCL>-/[^\]\n]		return ( '-' );
X<CCL>[^\]\n]		RETURNCHAR;
X<CCL>"]"		BEGIN(SECT2); return ( ']' );
X
X
X<NUM>[0-9]+		{
X			yylval = myctoi( yytext );
X			return ( NUMBER );
X			}
X
X<NUM>","			return ( ',' );
X<NUM>"}"			BEGIN(SECT2); return ( '}' );
X
X<NUM>.			{
X			synerr( "bad character inside {}'s" );
X			BEGIN(SECT2);
X			return ( '}' );
X			}
X
X<NUM>\n			{
X			synerr( "missing }" );
X			BEGIN(SECT2);
X			++linenum;
X			return ( '}' );
X			}
X
X
X<BRACEERROR>"}"		synerr( "bad name in {}'s" ); BEGIN(SECT2);
X<BRACEERROR>\n		synerr( "missing }" ); ++linenum; BEGIN(SECT2);
X
X
X<PERCENT_BRACE_ACTION,CODEBLOCK_2>{OPTWS}"%}".*		bracelevel = 0;
X<PERCENT_BRACE_ACTION,CODEBLOCK_2,ACTION>"reject"	{
X			ACTION_ECHO;
X			CHECK_REJECT(yytext);
X			}
X<PERCENT_BRACE_ACTION,CODEBLOCK_2,ACTION>"yymore"	{
X			ACTION_ECHO;
X			CHECK_YYMORE(yytext);
X			}
X<PERCENT_BRACE_ACTION,CODEBLOCK_2>{NAME}|{NOT_NAME}|.	ACTION_ECHO;
X<PERCENT_BRACE_ACTION,CODEBLOCK_2>\n			{
X			++linenum;
X			ACTION_ECHO;
X			if ( bracelevel == 0 ||
X			     (doing_codeblock && indented_code) )
X			    {
X			    if ( ! doing_codeblock )
X				fputs( "\tYY_BREAK\n", temp_action_file );
X			    
X			    doing_codeblock = false;
X			    BEGIN(SECT2);
X			    }
X			}
X
X
X	/* Reject and YYmore() are checked for above, in PERCENT_BRACE_ACTION */
X<ACTION>"{"		ACTION_ECHO; ++bracelevel;
X<ACTION>"}"		ACTION_ECHO; --bracelevel;
X<ACTION>[^a-z_{}"'/\n]+	ACTION_ECHO;
X<ACTION>{NAME}		ACTION_ECHO;
X<ACTION>"/*"		ACTION_ECHO; BEGIN(ACTION_COMMENT);
X<ACTION>"'"([^'\\\n]|\\.)*"'"	ACTION_ECHO; /* character constant */
X<ACTION>\"		ACTION_ECHO; BEGIN(ACTION_STRING);
X<ACTION>\n		{
X			++linenum;
X			ACTION_ECHO;
X			if ( bracelevel == 0 )
X			    {
X			    fputs( "\tYY_BREAK\n", temp_action_file );
X			    BEGIN(SECT2);
X			    }
X			}
X<ACTION>.		ACTION_ECHO;
X
X<ACTION_COMMENT>"*/"	ACTION_ECHO; BEGIN(ACTION);
X<ACTION_COMMENT>[^*\n]+	ACTION_ECHO;
X<ACTION_COMMENT>"*"	ACTION_ECHO;
X<ACTION_COMMENT>\n	++linenum; ACTION_ECHO;
X<ACTION_COMMENT>.	ACTION_ECHO;
X
X<ACTION_STRING>[^"\\\n]+	ACTION_ECHO;
X<ACTION_STRING>\\.	ACTION_ECHO;
X<ACTION_STRING>\n	++linenum; ACTION_ECHO;
X<ACTION_STRING>\"	ACTION_ECHO; BEGIN(ACTION);
X<ACTION_STRING>.	ACTION_ECHO;
X
X<ACTION,ACTION_COMMENT,ACTION_STRING><<EOF>>	{
X			synerr( "EOF encountered inside an action" );
X			yyterminate();
X			}
X
X
X<SECT2,QUOTE,CCL>{ESCSEQ}	{
X			yylval = myesc( yytext );
X			return ( CHAR );
X			}
X
X<FIRSTCCL>{ESCSEQ}	{
X			yylval = myesc( yytext );
X			BEGIN(CCL);
X			return ( CHAR );
X			}
X
X
X<SECT3>.*(\n?)		ECHO;
X%%
X
X
Xint yywrap()
X
X    {
X    if ( --num_input_files > 0 )
X	{
X	set_input_file( *++input_files );
X	return ( 0 );
X	}
X
X    else
X	return ( 1 );
X    }
X
X
X/* set_input_file - open the given file (if NULL, stdin) for scanning */
X
Xvoid set_input_file( file )
Xchar *file;
X
X    {
X    if ( file )
X	{
X	infilename = file;
X	yyin = fopen( infilename, "r" );
X
X	if ( yyin == NULL )
X	    lerrsf( "can't open %s", file );
X	}
X
X    else
X	{
X	yyin = stdin;
X	infilename = "<stdin>";
X	}
X    }
END_OF_FILE
  if test 12439 -ne `wc -c <'scan.l'`; then
    echo shar: \"'scan.l'\" unpacked with wrong size!
  fi
  # end of 'scan.l'
fi
echo shar: End of archive 1 \(of 10\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
