Subject:  v23i043:  Flex, a fast lex replacement, Part07/10
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 65a64ac9 c1ae906c 71a7080a eae9537b

Submitted-by: Vern Paxson <vern@cs.cornell.edu>
Posting-number: Volume 23, Issue 43
Archive-name: flex2.3/part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  initscan.c.02 sym.c tblcmp.c
# Wrapped by rsalz@litchi.bbn.com on Wed Oct 10 13:24:03 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 7 (of 10)."'
if test -f 'initscan.c.02' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'initscan.c.02'\"
else
  echo shar: Extracting \"'initscan.c.02'\" \(18105 characters\)
  sed "s/^X//" >'initscan.c.02' <<'END_OF_FILE'
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp = yy_bp + 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 367 "scan.l"
XBEGIN(CARETISBOL); return ( '>' );
X	YY_BREAK
Xcase 72:
X# line 368 "scan.l"
XRETURNNAME;
X	YY_BREAK
Xcase 73:
X# line 369 "scan.l"
Xsynerr( "bad start condition name" );
X	YY_BREAK
Xcase 74:
X# line 371 "scan.l"
XBEGIN(SECT2); return ( '^' );
X	YY_BREAK
Xcase 75:
X# line 374 "scan.l"
XRETURNCHAR;
X	YY_BREAK
Xcase 76:
X# line 375 "scan.l"
XBEGIN(SECT2); return ( '"' );
X	YY_BREAK
Xcase 77:
X# line 377 "scan.l"
X{
X			synerr( "missing quote" );
X			BEGIN(SECT2);
X			++linenum;
X			return ( '"' );
X			}
X	YY_BREAK
Xcase 78:
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp = yy_bp + 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 385 "scan.l"
XBEGIN(CCL); return ( '^' );
X	YY_BREAK
Xcase 79:
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp = yy_bp + 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 386 "scan.l"
Xreturn ( '^' );
X	YY_BREAK
Xcase 80:
X# line 387 "scan.l"
XBEGIN(CCL); yylval = '-'; return ( CHAR );
X	YY_BREAK
Xcase 81:
X# line 388 "scan.l"
XBEGIN(CCL); RETURNCHAR;
X	YY_BREAK
Xcase 82:
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp = yy_bp + 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 390 "scan.l"
Xreturn ( '-' );
X	YY_BREAK
Xcase 83:
X# line 391 "scan.l"
XRETURNCHAR;
X	YY_BREAK
Xcase 84:
X# line 392 "scan.l"
XBEGIN(SECT2); return ( ']' );
X	YY_BREAK
Xcase 85:
X# line 395 "scan.l"
X{
X			yylval = myctoi( yytext );
X			return ( NUMBER );
X			}
X	YY_BREAK
Xcase 86:
X# line 400 "scan.l"
Xreturn ( ',' );
X	YY_BREAK
Xcase 87:
X# line 401 "scan.l"
XBEGIN(SECT2); return ( '}' );
X	YY_BREAK
Xcase 88:
X# line 403 "scan.l"
X{
X			synerr( "bad character inside {}'s" );
X			BEGIN(SECT2);
X			return ( '}' );
X			}
X	YY_BREAK
Xcase 89:
X# line 409 "scan.l"
X{
X			synerr( "missing }" );
X			BEGIN(SECT2);
X			++linenum;
X			return ( '}' );
X			}
X	YY_BREAK
Xcase 90:
X# line 417 "scan.l"
Xsynerr( "bad name in {}'s" ); BEGIN(SECT2);
X	YY_BREAK
Xcase 91:
X# line 418 "scan.l"
Xsynerr( "missing }" ); ++linenum; BEGIN(SECT2);
X	YY_BREAK
Xcase 92:
X# line 421 "scan.l"
Xbracelevel = 0;
X	YY_BREAK
Xcase 93:
X# line 422 "scan.l"
X{
X			ACTION_ECHO;
X			CHECK_REJECT(yytext);
X			}
X	YY_BREAK
Xcase 94:
X# line 426 "scan.l"
X{
X			ACTION_ECHO;
X			CHECK_YYMORE(yytext);
X			}
X	YY_BREAK
Xcase 95:
X# line 430 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 96:
X# line 431 "scan.l"
X{
X			++linenum;
X			ACTION_ECHO;
X			if ( bracelevel == 0 ||
X			     (doing_codeblock && indented_code) )
X			    {
X			    if ( ! doing_codeblock )
X				fputs( "\tYY_BREAK\n", temp_action_file );
X			    
X			    doing_codeblock = false;
X			    BEGIN(SECT2);
X			    }
X			}
X	YY_BREAK
X	/* Reject and YYmore() are checked for above, in PERCENT_BRACE_ACTION */
Xcase 97:
X# line 447 "scan.l"
XACTION_ECHO; ++bracelevel;
X	YY_BREAK
Xcase 98:
X# line 448 "scan.l"
XACTION_ECHO; --bracelevel;
X	YY_BREAK
Xcase 99:
X# line 449 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 100:
X# line 450 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 101:
X# line 451 "scan.l"
XACTION_ECHO; BEGIN(ACTION_COMMENT);
X	YY_BREAK
Xcase 102:
X# line 452 "scan.l"
XACTION_ECHO; /* character constant */
X	YY_BREAK
Xcase 103:
X# line 453 "scan.l"
XACTION_ECHO; BEGIN(ACTION_STRING);
X	YY_BREAK
Xcase 104:
X# line 454 "scan.l"
X{
X			++linenum;
X			ACTION_ECHO;
X			if ( bracelevel == 0 )
X			    {
X			    fputs( "\tYY_BREAK\n", temp_action_file );
X			    BEGIN(SECT2);
X			    }
X			}
X	YY_BREAK
Xcase 105:
X# line 463 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 106:
X# line 465 "scan.l"
XACTION_ECHO; BEGIN(ACTION);
X	YY_BREAK
Xcase 107:
X# line 466 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 108:
X# line 467 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 109:
X# line 468 "scan.l"
X++linenum; ACTION_ECHO;
X	YY_BREAK
Xcase 110:
X# line 469 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 111:
X# line 471 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 112:
X# line 472 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase 113:
X# line 473 "scan.l"
X++linenum; ACTION_ECHO;
X	YY_BREAK
Xcase 114:
X# line 474 "scan.l"
XACTION_ECHO; BEGIN(ACTION);
X	YY_BREAK
Xcase 115:
X# line 475 "scan.l"
XACTION_ECHO;
X	YY_BREAK
Xcase YY_STATE_EOF(ACTION):
Xcase YY_STATE_EOF(ACTION_COMMENT):
Xcase YY_STATE_EOF(ACTION_STRING):
X# line 477 "scan.l"
X{
X			synerr( "EOF encountered inside an action" );
X			yyterminate();
X			}
X	YY_BREAK
Xcase 117:
X# line 483 "scan.l"
X{
X			yylval = myesc( yytext );
X			return ( CHAR );
X			}
X	YY_BREAK
Xcase 118:
X# line 488 "scan.l"
X{
X			yylval = myesc( yytext );
X			BEGIN(CCL);
X			return ( CHAR );
X			}
X	YY_BREAK
Xcase 119:
X# line 495 "scan.l"
XECHO;
X	YY_BREAK
Xcase 120:
X# line 496 "scan.l"
XYY_FATAL_ERROR( "flex scanner jammed" );
X	YY_BREAK
Xcase YY_STATE_EOF(INITIAL):
Xcase YY_STATE_EOF(SECT2):
Xcase YY_STATE_EOF(SECT3):
Xcase YY_STATE_EOF(CODEBLOCK):
Xcase YY_STATE_EOF(PICKUPDEF):
Xcase YY_STATE_EOF(SC):
Xcase YY_STATE_EOF(CARETISBOL):
Xcase YY_STATE_EOF(NUM):
Xcase YY_STATE_EOF(QUOTE):
Xcase YY_STATE_EOF(FIRSTCCL):
Xcase YY_STATE_EOF(CCL):
Xcase YY_STATE_EOF(RECOVER):
Xcase YY_STATE_EOF(BRACEERROR):
Xcase YY_STATE_EOF(C_COMMENT):
Xcase YY_STATE_EOF(PERCENT_BRACE_ACTION):
Xcase YY_STATE_EOF(USED_LIST):
Xcase YY_STATE_EOF(CODEBLOCK_2):
Xcase YY_STATE_EOF(XLATION):
X    yyterminate();
X
X	    case YY_END_OF_BUFFER:
X		{
X		/* amount of text matched not including the EOB char */
X		int yy_amount_of_matched_text = yy_cp - yytext - 1;
X
X		/* undo the effects of YY_DO_BEFORE_ACTION */
X		*yy_cp = yy_hold_char;
X
X		/* note that here we test for yy_c_buf_p "<=" to the position
X		 * of the first EOB in the buffer, since yy_c_buf_p will
X		 * already have been incremented past the NUL character
X		 * (since all states make transitions on EOB to the end-
X		 * of-buffer state).  Contrast this with the test in yyinput().
X		 */
X		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X		    /* this was really a NUL */
X		    {
X		    yy_state_type yy_next_state;
X
X		    yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X		    yy_current_state = yy_get_previous_state();
X
X		    /* okay, we're now positioned to make the
X		     * NUL transition.  We couldn't have
X		     * yy_get_previous_state() go ahead and do it
X		     * for us because it doesn't know how to deal
X		     * with the possibility of jamming (and we
X		     * don't want to build jamming into it because
X		     * then it will run more slowly)
X		     */
X
X		    yy_next_state = yy_try_NUL_trans( yy_current_state );
X
X		    yy_bp = yytext + YY_MORE_ADJ;
X
X		    if ( yy_next_state )
X			{
X			/* consume the NUL */
X			yy_cp = ++yy_c_buf_p;
X			yy_current_state = yy_next_state;
X			goto yy_match;
X			}
X
X		    else
X			{
X			    yy_cp = yy_last_accepting_cpos;
X			    yy_current_state = yy_last_accepting_state;
X			goto yy_find_action;
X			}
X		    }
X
X		else switch ( yy_get_next_buffer() )
X		    {
X		    case EOB_ACT_END_OF_FILE:
X			{
X			yy_did_buffer_switch_on_eof = 0;
X
X			if ( yywrap() )
X			    {
X			    /* note: because we've taken care in
X			     * yy_get_next_buffer() to have set up yytext,
X			     * we can now set up yy_c_buf_p so that if some
X			     * total hoser (like flex itself) wants
X			     * to call the scanner after we return the
X			     * YY_NULL, it'll still work - another YY_NULL
X			     * will get returned.
X			     */
X			    yy_c_buf_p = yytext + YY_MORE_ADJ;
X
X			    yy_act = YY_STATE_EOF((yy_start - 1) / 2);
X			    goto do_action;
X			    }
X
X			else
X			    {
X			    if ( ! yy_did_buffer_switch_on_eof )
X				YY_NEW_FILE;
X			    }
X			}
X			break;
X
X		    case EOB_ACT_CONTINUE_SCAN:
X			yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_match;
X
X		    case EOB_ACT_LAST_MATCH:
X			yy_c_buf_p =
X			    &yy_current_buffer->yy_ch_buf[yy_n_chars];
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_find_action;
X		    }
X		break;
X		}
X
X	    default:
X#ifdef FLEX_DEBUG
X		printf( "action # %d\n", yy_act );
X#endif
X		YY_FATAL_ERROR(
X			"fatal flex scanner internal error--no action found" );
X	    }
X	}
X    }
X
X
X/* yy_get_next_buffer - try to read in a new buffer
X *
X * synopsis
X *     int yy_get_next_buffer();
X *     
X * returns a code representing an action
X *     EOB_ACT_LAST_MATCH - 
X *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
X *     EOB_ACT_END_OF_FILE - end of file
X */
X
Xstatic int yy_get_next_buffer()
X
X    {
X    register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
X    register YY_CHAR *source = yytext - 1; /* copy prev. char, too */
X    register int number_to_move, i;
X    int ret_val;
X
X    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
X	YY_FATAL_ERROR(
X		"fatal flex scanner internal error--end of buffer missed" );
X
X    /* try to read more data */
X
X    /* first move last chars to start of buffer */
X    number_to_move = yy_c_buf_p - yytext;
X
X    for ( i = 0; i < number_to_move; ++i )
X	*(dest++) = *(source++);
X
X    if ( yy_current_buffer->yy_eof_status != EOF_NOT_SEEN )
X	/* don't do the read, it's not guaranteed to return an EOF,
X	 * just force an EOF
X	 */
X	yy_n_chars = 0;
X
X    else
X	{
X	int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;
X
X	if ( num_to_read > YY_READ_BUF_SIZE )
X	    num_to_read = YY_READ_BUF_SIZE;
X
X	else if ( num_to_read <= 0 )
X	    YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );
X
X	/* read in more data */
X	YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
X		  yy_n_chars, num_to_read );
X	}
X
X    if ( yy_n_chars == 0 )
X	{
X	if ( number_to_move == 1 )
X	    {
X	    ret_val = EOB_ACT_END_OF_FILE;
X	    yy_current_buffer->yy_eof_status = EOF_DONE;
X	    }
X
X	else
X	    {
X	    ret_val = EOB_ACT_LAST_MATCH;
X	    yy_current_buffer->yy_eof_status = EOF_PENDING;
X	    }
X	}
X
X    else
X	ret_val = EOB_ACT_CONTINUE_SCAN;
X
X    yy_n_chars += number_to_move;
X    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X
X    /* yytext begins at the second character in yy_ch_buf; the first
X     * character is the one which preceded it before reading in the latest
X     * buffer; it needs to be kept around in case it's a newline, so
X     * yy_get_previous_state() will have with '^' rules active
X     */
X
X    yytext = &yy_current_buffer->yy_ch_buf[1];
X
X    return ( ret_val );
X    }
X
X
X/* yy_get_previous_state - get the state just before the EOB char was reached
X *
X * synopsis
X *     yy_state_type yy_get_previous_state();
X */
X
Xstatic yy_state_type yy_get_previous_state()
X
X    {
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp;
X
X    register YY_CHAR *yy_bp = yytext;
X
X    yy_current_state = yy_start;
X    if ( yy_bp[-1] == '\n' )
X	++yy_current_state;
X
X    for ( yy_cp = yytext + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
X	{
X	register YY_CHAR yy_c = (*yy_cp ? yy_ec[*yy_cp] : 1);
X	if ( yy_accept[yy_current_state] )
X	    {
X	    yy_last_accepting_state = yy_current_state;
X	    yy_last_accepting_cpos = yy_cp;
X	    }
X	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	    {
X	    yy_current_state = yy_def[yy_current_state];
X	    if ( yy_current_state >= 341 )
X		yy_c = yy_meta[yy_c];
X	    }
X	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	}
X
X    return ( yy_current_state );
X    }
X
X
X/* yy_try_NUL_trans - try to make a transition on the NUL character
X *
X * synopsis
X *     next_state = yy_try_NUL_trans( current_state );
X */
X
X#ifdef YY_USE_PROTOS
Xstatic yy_state_type yy_try_NUL_trans( register yy_state_type yy_current_state )
X#else
Xstatic yy_state_type yy_try_NUL_trans( yy_current_state )
Xregister yy_state_type yy_current_state;
X#endif
X
X    {
X    register int yy_is_jam;
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X
X    register YY_CHAR yy_c = 1;
X    if ( yy_accept[yy_current_state] )
X	{
X	yy_last_accepting_state = yy_current_state;
X	yy_last_accepting_cpos = yy_cp;
X	}
X    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	{
X	yy_current_state = yy_def[yy_current_state];
X	if ( yy_current_state >= 341 )
X	    yy_c = yy_meta[yy_c];
X	}
X    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X    yy_is_jam = (yy_current_state == 340);
X
X    return ( yy_is_jam ? 0 : yy_current_state );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xstatic void yyunput( YY_CHAR c, register YY_CHAR *yy_bp )
X#else
Xstatic void yyunput( c, yy_bp )
XYY_CHAR c;
Xregister YY_CHAR *yy_bp;
X#endif
X
X    {
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X
X    /* undo effects of setting up yytext */
X    *yy_cp = yy_hold_char;
X
X    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	{ /* need to shift things up to make room */
X	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
X	register YY_CHAR *dest =
X	    &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
X	register YY_CHAR *source =
X	    &yy_current_buffer->yy_ch_buf[number_to_move];
X
X	while ( source > yy_current_buffer->yy_ch_buf )
X	    *--dest = *--source;
X
X	yy_cp += dest - source;
X	yy_bp += dest - source;
X	yy_n_chars = yy_current_buffer->yy_buf_size;
X
X	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
X	}
X
X    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
X	yy_cp[-2] = '\n';
X
X    *--yy_cp = c;
X
X    /* note: the formal parameter *must* be called "yy_bp" for this
X     *       macro to now work correctly
X     */
X    YY_DO_BEFORE_ACTION; /* set up yytext again */
X    }
X
X
X#ifdef __cplusplus
Xstatic int yyinput()
X#else
Xstatic int input()
X#endif
X
X    {
X    int c;
X    YY_CHAR *yy_cp = yy_c_buf_p;
X
X    *yy_cp = yy_hold_char;
X
X    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
X	{
X	/* yy_c_buf_p now points to the character we want to return.
X	 * If this occurs *before* the EOB characters, then it's a
X	 * valid NUL; if not, then we've hit the end of the buffer.
X	 */
X	if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X	    /* this was really a NUL */
X	    *yy_c_buf_p = '\0';
X
X	else
X	    { /* need more input */
X	    yytext = yy_c_buf_p;
X	    ++yy_c_buf_p;
X
X	    switch ( yy_get_next_buffer() )
X		{
X		case EOB_ACT_END_OF_FILE:
X		    {
X		    if ( yywrap() )
X			{
X			yy_c_buf_p = yytext + YY_MORE_ADJ;
X			return ( EOF );
X			}
X
X		    YY_NEW_FILE;
X
X#ifdef __cplusplus
X		    return ( yyinput() );
X#else
X		    return ( input() );
X#endif
X		    }
X		    break;
X
X		case EOB_ACT_CONTINUE_SCAN:
X		    yy_c_buf_p = yytext + YY_MORE_ADJ;
X		    break;
X
X		case EOB_ACT_LAST_MATCH:
X#ifdef __cplusplus
X		    YY_FATAL_ERROR( "unexpected last match in yyinput()" );
X#else
X		    YY_FATAL_ERROR( "unexpected last match in input()" );
X#endif
X		}
X	    }
X	}
X
X    c = *yy_c_buf_p;
X    yy_hold_char = *++yy_c_buf_p;
X
X    return ( c );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yyrestart( FILE *input_file )
X#else
Xvoid yyrestart( input_file )
XFILE *input_file;
X#endif
X
X    {
X    yy_init_buffer( yy_current_buffer, input_file );
X    yy_load_buffer_state();
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
X#else
Xvoid yy_switch_to_buffer( new_buffer )
XYY_BUFFER_STATE new_buffer;
X#endif
X
X    {
X    if ( yy_current_buffer == new_buffer )
X	return;
X
X    if ( yy_current_buffer )
X	{
X	/* flush out information for old buffer */
X	*yy_c_buf_p = yy_hold_char;
X	yy_current_buffer->yy_buf_pos = yy_c_buf_p;
X	yy_current_buffer->yy_n_chars = yy_n_chars;
X	}
X
X    yy_current_buffer = new_buffer;
X    yy_load_buffer_state();
X
X    /* we don't actually know whether we did this switch during
X     * EOF (yywrap()) processing, but the only time this flag
X     * is looked at is after yywrap() is called, so it's safe
X     * to go ahead and always set it.
X     */
X    yy_did_buffer_switch_on_eof = 1;
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_load_buffer_state( void )
X#else
Xvoid yy_load_buffer_state()
X#endif
X
X    {
X    yy_n_chars = yy_current_buffer->yy_n_chars;
X    yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
X    yyin = yy_current_buffer->yy_input_file;
X    yy_hold_char = *yy_c_buf_p;
X    }
X
X
X#ifdef YY_USE_PROTOS
XYY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
X#else
XYY_BUFFER_STATE yy_create_buffer( file, size )
XFILE *file;
Xint size;
X#endif
X
X    {
X    YY_BUFFER_STATE b;
X
X    b = (YY_BUFFER_STATE) malloc( sizeof( struct yy_buffer_state ) );
X
X    if ( ! b )
X	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
X
X    b->yy_buf_size = size;
X
X    /* yy_ch_buf has to be 2 characters longer than the size given because
X     * we need to put in 2 end-of-buffer characters.
X     */
X    b->yy_ch_buf = (YY_CHAR *) malloc( (unsigned) (b->yy_buf_size + 2) );
X
X    if ( ! b->yy_ch_buf )
X	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
X
X    yy_init_buffer( b, file );
X
X    return ( b );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_delete_buffer( YY_BUFFER_STATE b )
X#else
Xvoid yy_delete_buffer( b )
XYY_BUFFER_STATE b;
X#endif
X
X    {
X    if ( b == yy_current_buffer )
X	yy_current_buffer = (YY_BUFFER_STATE) 0;
X
X    free( (char *) b->yy_ch_buf );
X    free( (char *) b );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
X#else
Xvoid yy_init_buffer( b, file )
XYY_BUFFER_STATE b;
XFILE *file;
X#endif
X
X    {
X    b->yy_input_file = file;
X
X    /* we put in the '\n' and start reading from [1] so that an
X     * initial match-at-newline will be true.
X     */
X
X    b->yy_ch_buf[0] = '\n';
X    b->yy_n_chars = 1;
X
X    /* we always need two end-of-buffer characters.  The first causes
X     * a transition to the end-of-buffer state.  The second causes
X     * a jam in that state.
X     */
X    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
X    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;
X
X    b->yy_buf_pos = &b->yy_ch_buf[1];
X
X    b->yy_eof_status = EOF_NOT_SEEN;
X    }
X# line 496 "scan.l"
X
X
X
Xint yywrap()
X
X    {
X    if ( --num_input_files > 0 )
X	{
X	set_input_file( *++input_files );
X	return ( 0 );
X	}
X
X    else
X	return ( 1 );
X    }
X
X
X/* set_input_file - open the given file (if NULL, stdin) for scanning */
X
Xvoid set_input_file( file )
Xchar *file;
X
X    {
X    if ( file )
X	{
X	infilename = file;
X	yyin = fopen( infilename, "r" );
X
X	if ( yyin == NULL )
X	    lerrsf( "can't open %s", file );
X	}
X
X    else
X	{
X	yyin = stdin;
X	infilename = "<stdin>";
X	}
X    }
END_OF_FILE
  if test 18105 -ne `wc -c <'initscan.c.02'`; then
    echo shar: \"'initscan.c.02'\" unpacked with wrong size!
  fi
  # end of 'initscan.c.02'
fi
if test -f 'sym.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sym.c'\"
else
  echo shar: Extracting \"'sym.c'\" \(7527 characters\)
  sed "s/^X//" >'sym.c' <<'END_OF_FILE'
X/* sym - symbol table routines */
X
X/*-
X * Copyright (c) 1990 The Regents of the University of California.
X * All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Vern Paxson.
X * 
X * The United States Government has rights in this work pursuant
X * to contract no. DE-AC03-76SF00098 between the United States
X * Department of Energy and the University of California.
X *
X * Redistribution and use in source and binary forms are permitted provided
X * that: (1) source distributions retain this entire copyright notice and
X * comment, and (2) distributions including binaries display the following
X * acknowledgement:  ``This product includes software developed by the
X * University of California, Berkeley and its contributors'' in the
X * documentation or other materials provided with the distribution and in
X * all advertising materials mentioning features or use of this software.
X * Neither the name of the University nor the names of its contributors may
X * be used to endorse or promote products derived from this software without
X * specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
Xstatic char rcsid[] =
X    "@(#) $Header: /usr/fsys/odin/a/vern/flex/RCS/sym.c,v 2.4 90/06/27 23:48:36 vern Exp $ (LBL)";
X#endif
X
X#include "flexdef.h"
X
X
X/* declare functions that have forward references */
X
Xint hashfunct PROTO((register char[], int));
X
X
Xstruct hash_entry *ndtbl[NAME_TABLE_HASH_SIZE];
Xstruct hash_entry *sctbl[START_COND_HASH_SIZE];
Xstruct hash_entry *ccltab[CCL_HASH_SIZE];
X
Xstruct hash_entry *findsym();
X
X
X/* addsym - add symbol and definitions to symbol table
X *
X * synopsis
X *    char sym[], *str_def;
X *    int int_def;
X *    hash_table table;
X *    int table_size;
X *    0 / -1 = addsym( sym, def, int_def, table, table_size );
X *
X * -1 is returned if the symbol already exists, and the change not made.
X */
X
Xint addsym( sym, str_def, int_def, table, table_size )
Xregister char sym[];
Xchar *str_def;
Xint int_def;
Xhash_table table;
Xint table_size;
X
X    {
X    int hash_val = hashfunct( sym, table_size );
X    register struct hash_entry *sym_entry = table[hash_val];
X    register struct hash_entry *new_entry;
X    register struct hash_entry *successor;
X
X    while ( sym_entry )
X	{
X	if ( ! strcmp( sym, sym_entry->name ) )
X	    { /* entry already exists */
X	    return ( -1 );
X	    }
X	
X	sym_entry = sym_entry->next;
X	}
X
X    /* create new entry */
X    new_entry = (struct hash_entry *) malloc( sizeof( struct hash_entry ) );
X
X    if ( new_entry == NULL )
X	flexfatal( "symbol table memory allocation failed" );
X
X    if ( (successor = table[hash_val]) )
X	{
X	new_entry->next = successor;
X	successor->prev = new_entry;
X	}
X    else
X	new_entry->next = NULL;
X
X    new_entry->prev = NULL;
X    new_entry->name = sym;
X    new_entry->str_val = str_def;
X    new_entry->int_val = int_def;
X
X    table[hash_val] = new_entry;
X
X    return ( 0 );
X    }
X
X
X/* cclinstal - save the text of a character class
X *
X * synopsis
X *    Char ccltxt[];
X *    int cclnum;
X *    cclinstal( ccltxt, cclnum );
X */
X
Xvoid cclinstal( ccltxt, cclnum )
XChar ccltxt[];
Xint cclnum;
X
X    {
X    /* we don't bother checking the return status because we are not called
X     * unless the symbol is new
X     */
X    Char *copy_unsigned_string();
X
X    (void) addsym( (char *) copy_unsigned_string( ccltxt ), (char *) 0, cclnum,
X		   ccltab, CCL_HASH_SIZE );
X    }
X
X
X/* ccllookup - lookup the number associated with character class text
X *
X * synopsis
X *    Char ccltxt[];
X *    int ccllookup, cclval;
X *    cclval/0 = ccllookup( ccltxt );
X */
X
Xint ccllookup( ccltxt )
XChar ccltxt[];
X
X    {
X    return ( findsym( (char *) ccltxt, ccltab, CCL_HASH_SIZE )->int_val );
X    }
X
X
X/* findsym - find symbol in symbol table
X *
X * synopsis
X *    char sym[];
X *    hash_table table;
X *    int table_size;
X *    struct hash_entry *sym_entry, *findsym();
X *    sym_entry = findsym( sym, table, table_size );
X */
X
Xstruct hash_entry *findsym( sym, table, table_size )
Xregister char sym[];
Xhash_table table;
Xint table_size;
X
X    {
X    register struct hash_entry *sym_entry = table[hashfunct( sym, table_size )];
X    static struct hash_entry empty_entry =
X	{
X	(struct hash_entry *) 0, (struct hash_entry *) 0, NULL, NULL, 0,
X	} ;
X
X    while ( sym_entry )
X	{
X	if ( ! strcmp( sym, sym_entry->name ) )
X	    return ( sym_entry );
X	sym_entry = sym_entry->next;
X	}
X
X    return ( &empty_entry );
X    }
X
X    
X/* hashfunct - compute the hash value for "str" and hash size "hash_size"
X *
X * synopsis
X *    char str[];
X *    int hash_size, hash_val;
X *    hash_val = hashfunct( str, hash_size );
X */
X
Xint hashfunct( str, hash_size )
Xregister char str[];
Xint hash_size;
X
X    {
X    register int hashval;
X    register int locstr;
X
X    hashval = 0;
X    locstr = 0;
X
X    while ( str[locstr] )
X	hashval = ((hashval << 1) + str[locstr++]) % hash_size;
X
X    return ( hashval );
X    }
X
X
X/* ndinstal - install a name definition
X *
X * synopsis
X *    char nd[];
X *    Char def[];
X *    ndinstal( nd, def );
X */
X
Xvoid ndinstal( nd, def )
Xchar nd[];
XChar def[];
X
X    {
X    char *copy_string();
X    Char *copy_unsigned_string();
X
X    if ( addsym( copy_string( nd ), (char *) copy_unsigned_string( def ), 0,
X		 ndtbl, NAME_TABLE_HASH_SIZE ) )
X	synerr( "name defined twice" );
X    }
X
X
X/* ndlookup - lookup a name definition
X *
X * synopsis
X *    char nd[], *def;
X *    char *ndlookup();
X *    def/NULL = ndlookup( nd );
X */
X
XChar *ndlookup( nd )
Xchar nd[];
X
X    {
X    return ( (Char *) findsym( nd, ndtbl, NAME_TABLE_HASH_SIZE )->str_val );
X    }
X
X
X/* scinstal - make a start condition
X *
X * synopsis
X *    char str[];
X *    int xcluflg;
X *    scinstal( str, xcluflg );
X *
X * NOTE
X *    the start condition is Exclusive if xcluflg is true
X */
X
Xvoid scinstal( str, xcluflg )
Xchar str[];
Xint xcluflg;
X
X    {
X    char *copy_string();
X
X    /* bit of a hack.  We know how the default start-condition is
X     * declared, and don't put out a define for it, because it
X     * would come out as "#define 0 1"
X     */
X    /* actually, this is no longer the case.  The default start-condition
X     * is now called "INITIAL".  But we keep the following for the sake
X     * of future robustness.
X     */
X
X    if ( strcmp( str, "0" ) )
X	printf( "#define %s %d\n", str, lastsc );
X
X    if ( ++lastsc >= current_max_scs )
X	{
X	current_max_scs += MAX_SCS_INCREMENT;
X
X	++num_reallocs;
X
X	scset = reallocate_integer_array( scset, current_max_scs );
X	scbol = reallocate_integer_array( scbol, current_max_scs );
X	scxclu = reallocate_integer_array( scxclu, current_max_scs );
X	sceof = reallocate_integer_array( sceof, current_max_scs );
X	scname = reallocate_char_ptr_array( scname, current_max_scs );
X	actvsc = reallocate_integer_array( actvsc, current_max_scs );
X	}
X
X    scname[lastsc] = copy_string( str );
X
X    if ( addsym( scname[lastsc], (char *) 0, lastsc,
X		 sctbl, START_COND_HASH_SIZE ) )
X	format_pinpoint_message( "start condition %s declared twice", str );
X
X    scset[lastsc] = mkstate( SYM_EPSILON );
X    scbol[lastsc] = mkstate( SYM_EPSILON );
X    scxclu[lastsc] = xcluflg;
X    sceof[lastsc] = false;
X    }
X
X
X/* sclookup - lookup the number associated with a start condition
X *
X * synopsis
X *    char str[], scnum;
X *    int sclookup;
X *    scnum/0 = sclookup( str );
X */
X
Xint sclookup( str )
Xchar str[];
X
X    {
X    return ( findsym( str, sctbl, START_COND_HASH_SIZE )->int_val );
X    }
END_OF_FILE
  if test 7527 -ne `wc -c <'sym.c'`; then
    echo shar: \"'sym.c'\" unpacked with wrong size!
  fi
  # end of 'sym.c'
fi
if test -f 'tblcmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tblcmp.c'\"
else
  echo shar: Extracting \"'tblcmp.c'\" \(25169 characters\)
  sed "s/^X//" >'tblcmp.c' <<'END_OF_FILE'
X/* tblcmp - table compression routines */
X
X/*-
X * Copyright (c) 1990 The Regents of the University of California.
X * All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Vern Paxson.
X * 
X * The United States Government has rights in this work pursuant
X * to contract no. DE-AC03-76SF00098 between the United States
X * Department of Energy and the University of California.
X *
X * Redistribution and use in source and binary forms are permitted provided
X * that: (1) source distributions retain this entire copyright notice and
X * comment, and (2) distributions including binaries display the following
X * acknowledgement:  ``This product includes software developed by the
X * University of California, Berkeley and its contributors'' in the
X * documentation or other materials provided with the distribution and in
X * all advertising materials mentioning features or use of this software.
X * Neither the name of the University nor the names of its contributors may
X * be used to endorse or promote products derived from this software without
X * specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
Xstatic char rcsid[] =
X    "@(#) $Header: /usr/fsys/odin/a/vern/flex/RCS/tblcmp.c,v 2.5 90/06/27 23:48:38 vern Exp $ (LBL)";
X#endif
X
X#include "flexdef.h"
X
X
X/* declarations for functions that have forward references */
X
Xvoid mkentry PROTO((register int*, int, int, int, int));
Xvoid mkprot PROTO((int[], int, int));
Xvoid mktemplate PROTO((int[], int, int));
Xvoid mv2front PROTO((int));
Xint tbldiff PROTO((int[], int, int[]));
X
X
X/* bldtbl - build table entries for dfa state
X *
X * synopsis
X *   int state[numecs], statenum, totaltrans, comstate, comfreq;
X *   bldtbl( state, statenum, totaltrans, comstate, comfreq );
X *
X * State is the statenum'th dfa state.  It is indexed by equivalence class and
X * gives the number of the state to enter for a given equivalence class.
X * totaltrans is the total number of transitions out of the state.  Comstate
X * is that state which is the destination of the most transitions out of State.
X * Comfreq is how many transitions there are out of State to Comstate.
X *
X * A note on terminology:
X *    "protos" are transition tables which have a high probability of
X * either being redundant (a state processed later will have an identical
X * transition table) or nearly redundant (a state processed later will have
X * many of the same out-transitions).  A "most recently used" queue of
X * protos is kept around with the hope that most states will find a proto
X * which is similar enough to be usable, and therefore compacting the
X * output tables.
X *    "templates" are a special type of proto.  If a transition table is
X * homogeneous or nearly homogeneous (all transitions go to the same
X * destination) then the odds are good that future states will also go
X * to the same destination state on basically the same character set.
X * These homogeneous states are so common when dealing with large rule
X * sets that they merit special attention.  If the transition table were
X * simply made into a proto, then (typically) each subsequent, similar
X * state will differ from the proto for two out-transitions.  One of these
X * out-transitions will be that character on which the proto does not go
X * to the common destination, and one will be that character on which the
X * state does not go to the common destination.  Templates, on the other
X * hand, go to the common state on EVERY transition character, and therefore
X * cost only one difference.
X */
X
Xvoid bldtbl( state, statenum, totaltrans, comstate, comfreq )
Xint state[], statenum, totaltrans, comstate, comfreq;
X
X    {
X    int extptr, extrct[2][CSIZE + 1];
X    int mindiff, minprot, i, d;
X    int checkcom;
X
X    /* If extptr is 0 then the first array of extrct holds the result of the
X     * "best difference" to date, which is those transitions which occur in
X     * "state" but not in the proto which, to date, has the fewest differences
X     * between itself and "state".  If extptr is 1 then the second array of
X     * extrct hold the best difference.  The two arrays are toggled
X     * between so that the best difference to date can be kept around and
X     * also a difference just created by checking against a candidate "best"
X     * proto.
X     */
X
X    extptr = 0;
X
X    /* if the state has too few out-transitions, don't bother trying to
X     * compact its tables
X     */
X
X    if ( (totaltrans * 100) < (numecs * PROTO_SIZE_PERCENTAGE) )
X	mkentry( state, numecs, statenum, JAMSTATE, totaltrans );
X
X    else
X	{
X	/* checkcom is true if we should only check "state" against
X	 * protos which have the same "comstate" value
X	 */
X
X	checkcom = comfreq * 100 > totaltrans * CHECK_COM_PERCENTAGE;
X
X	minprot = firstprot;
X	mindiff = totaltrans;
X
X	if ( checkcom )
X	    {
X	    /* find first proto which has the same "comstate" */
X	    for ( i = firstprot; i != NIL; i = protnext[i] )
X		if ( protcomst[i] == comstate )
X		    {
X		    minprot = i;
X		    mindiff = tbldiff( state, minprot, extrct[extptr] );
X		    break;
X		    }
X	    }
X
X	else
X	    {
X	    /* since we've decided that the most common destination out
X	     * of "state" does not occur with a high enough frequency,
X	     * we set the "comstate" to zero, assuring that if this state
X	     * is entered into the proto list, it will not be considered
X	     * a template.
X	     */
X	    comstate = 0;
X
X	    if ( firstprot != NIL )
X		{
X		minprot = firstprot;
X		mindiff = tbldiff( state, minprot, extrct[extptr] );
X		}
X	    }
X
X	/* we now have the first interesting proto in "minprot".  If
X	 * it matches within the tolerances set for the first proto,
X	 * we don't want to bother scanning the rest of the proto list
X	 * to see if we have any other reasonable matches.
X	 */
X
X	if ( mindiff * 100 > totaltrans * FIRST_MATCH_DIFF_PERCENTAGE )
X	    { /* not a good enough match.  Scan the rest of the protos */
X	    for ( i = minprot; i != NIL; i = protnext[i] )
X		{
X		d = tbldiff( state, i, extrct[1 - extptr] );
X		if ( d < mindiff )
X		    {
X		    extptr = 1 - extptr;
X		    mindiff = d;
X		    minprot = i;
X		    }
X		}
X	    }
X
X	/* check if the proto we've decided on as our best bet is close
X	 * enough to the state we want to match to be usable
X	 */
X
X	if ( mindiff * 100 > totaltrans * ACCEPTABLE_DIFF_PERCENTAGE )
X	    {
X	    /* no good.  If the state is homogeneous enough, we make a
X	     * template out of it.  Otherwise, we make a proto.
X	     */
X
X	    if ( comfreq * 100 >= totaltrans * TEMPLATE_SAME_PERCENTAGE )
X		mktemplate( state, statenum, comstate );
X
X	    else
X		{
X		mkprot( state, statenum, comstate );
X		mkentry( state, numecs, statenum, JAMSTATE, totaltrans );
X		}
X	    }
X
X	else
X	    { /* use the proto */
X	    mkentry( extrct[extptr], numecs, statenum,
X		     prottbl[minprot], mindiff );
X
X	    /* if this state was sufficiently different from the proto
X	     * we built it from, make it, too, a proto
X	     */
X
X	    if ( mindiff * 100 >= totaltrans * NEW_PROTO_DIFF_PERCENTAGE )
X		mkprot( state, statenum, comstate );
X
X	    /* since mkprot added a new proto to the proto queue, it's possible
X	     * that "minprot" is no longer on the proto queue (if it happened
X	     * to have been the last entry, it would have been bumped off).
X	     * If it's not there, then the new proto took its physical place
X	     * (though logically the new proto is at the beginning of the
X	     * queue), so in that case the following call will do nothing.
X	     */
X
X	    mv2front( minprot );
X	    }
X	}
X    }
X
X
X/* cmptmps - compress template table entries
X *
X * synopsis
X *    cmptmps();
X *
X *  template tables are compressed by using the 'template equivalence
X *  classes', which are collections of transition character equivalence
X *  classes which always appear together in templates - really meta-equivalence
X *  classes.  until this point, the tables for templates have been stored
X *  up at the top end of the nxt array; they will now be compressed and have
X *  table entries made for them.
X */
X
Xvoid cmptmps()
X
X    {
X    int tmpstorage[CSIZE + 1];
X    register int *tmp = tmpstorage, i, j;
X    int totaltrans, trans;
X
X    peakpairs = numtemps * numecs + tblend;
X
X    if ( usemecs )
X	{
X	/* create equivalence classes base on data gathered on template
X	 * transitions
X	 */
X
X	nummecs = cre8ecs( tecfwd, tecbck, numecs );
X	}
X    
X    else
X	nummecs = numecs;
X
X    if ( lastdfa + numtemps + 1 >= current_max_dfas )
X	increase_max_dfas();
X
X    /* loop through each template */
X
X    for ( i = 1; i <= numtemps; ++i )
X	{
X	totaltrans = 0;	/* number of non-jam transitions out of this template */
X
X	for ( j = 1; j <= numecs; ++j )
X	    {
X	    trans = tnxt[numecs * i + j];
X
X	    if ( usemecs )
X		{
X		/* the absolute value of tecbck is the meta-equivalence class
X		 * of a given equivalence class, as set up by cre8ecs
X		 */
X		if ( tecbck[j] > 0 )
X		    {
X		    tmp[tecbck[j]] = trans;
X
X		    if ( trans > 0 )
X			++totaltrans;
X		    }
X		}
X
X	    else
X		{
X		tmp[j] = trans;
X
X		if ( trans > 0 )
X		    ++totaltrans;
X		}
X	    }
X
X	/* it is assumed (in a rather subtle way) in the skeleton that
X	 * if we're using meta-equivalence classes, the def[] entry for
X	 * all templates is the jam template, i.e., templates never default
X	 * to other non-jam table entries (e.g., another template)
X	 */
X
X	/* leave room for the jam-state after the last real state */
X	mkentry( tmp, nummecs, lastdfa + i + 1, JAMSTATE, totaltrans );
X	}
X    }
X
X
X
X/* expand_nxt_chk - expand the next check arrays */
X
Xvoid expand_nxt_chk()
X
X    {
X    register int old_max = current_max_xpairs;
X
X    current_max_xpairs += MAX_XPAIRS_INCREMENT;
X
X    ++num_reallocs;
X
X    nxt = reallocate_integer_array( nxt, current_max_xpairs );
X    chk = reallocate_integer_array( chk, current_max_xpairs );
X
X    bzero( (char *) (chk + old_max),
X	   MAX_XPAIRS_INCREMENT * sizeof( int ) / sizeof( char ) );
X    }
X
X
X/* find_table_space - finds a space in the table for a state to be placed
X *
X * synopsis
X *     int *state, numtrans, block_start;
X *     int find_table_space();
X *
X *     block_start = find_table_space( state, numtrans );
X *
X * State is the state to be added to the full speed transition table.
X * Numtrans is the number of out-transitions for the state.
X *
X * find_table_space() returns the position of the start of the first block (in
X * chk) able to accommodate the state
X *
X * In determining if a state will or will not fit, find_table_space() must take
X * into account the fact that an end-of-buffer state will be added at [0],
X * and an action number will be added in [-1].
X */
X
Xint find_table_space( state, numtrans )
Xint *state, numtrans;
X    
X    {
X    /* firstfree is the position of the first possible occurrence of two
X     * consecutive unused records in the chk and nxt arrays
X     */
X    register int i;
X    register int *state_ptr, *chk_ptr;
X    register int *ptr_to_last_entry_in_state;
X
X    /* if there are too many out-transitions, put the state at the end of
X     * nxt and chk
X     */
X    if ( numtrans > MAX_XTIONS_FULL_INTERIOR_FIT )
X	{
X	/* if table is empty, return the first available spot in chk/nxt,
X	 * which should be 1
X	 */
X	if ( tblend < 2 )
X	    return ( 1 );
X
X	i = tblend - numecs;	/* start searching for table space near the
X				 * end of chk/nxt arrays
X				 */
X	}
X
X    else
X	i = firstfree;		/* start searching for table space from the
X				 * beginning (skipping only the elements
X				 * which will definitely not hold the new
X				 * state)
X				 */
X
X    while ( 1 )		/* loops until a space is found */
X	{
X	if ( i + numecs > current_max_xpairs )
X	    expand_nxt_chk();
X
X	/* loops until space for end-of-buffer and action number are found */
X	while ( 1 )
X	    {
X	    if ( chk[i - 1] == 0 )	/* check for action number space */
X		{
X		if ( chk[i] == 0 )	/* check for end-of-buffer space */
X		    break;
X
X		else
X		    i += 2;	/* since i != 0, there is no use checking to
X				 * see if (++i) - 1 == 0, because that's the
X				 * same as i == 0, so we skip a space
X				 */
X		}
X
X	    else
X		++i;
X
X	    if ( i + numecs > current_max_xpairs )
X		expand_nxt_chk();
X	    }
X
X	/* if we started search from the beginning, store the new firstfree for
X	 * the next call of find_table_space()
X	 */
X	if ( numtrans <= MAX_XTIONS_FULL_INTERIOR_FIT )
X	    firstfree = i + 1;
X
X	/* check to see if all elements in chk (and therefore nxt) that are
X	 * needed for the new state have not yet been taken
X	 */
X
X	state_ptr = &state[1];
X	ptr_to_last_entry_in_state = &chk[i + numecs + 1];
X
X	for ( chk_ptr = &chk[i + 1]; chk_ptr != ptr_to_last_entry_in_state;
X	      ++chk_ptr )
X	    if ( *(state_ptr++) != 0 && *chk_ptr != 0 )
X		break;
X
X	if ( chk_ptr == ptr_to_last_entry_in_state )
X	    return ( i );
X
X	else
X	    ++i;
X	}
X    }
X
X
X/* inittbl - initialize transition tables
X *
X * synopsis
X *   inittbl();
X *
X * Initializes "firstfree" to be one beyond the end of the table.  Initializes
X * all "chk" entries to be zero.  Note that templates are built in their
X * own tbase/tdef tables.  They are shifted down to be contiguous
X * with the non-template entries during table generation.
X */
Xvoid inittbl()
X
X    {
X    register int i;
X
X    bzero( (char *) chk, current_max_xpairs * sizeof( int ) / sizeof( char ) );
X
X    tblend = 0;
X    firstfree = tblend + 1;
X    numtemps = 0;
X
X    if ( usemecs )
X	{
X	/* set up doubly-linked meta-equivalence classes
X	 * these are sets of equivalence classes which all have identical
X	 * transitions out of TEMPLATES
X	 */
X
X	tecbck[1] = NIL;
X
X	for ( i = 2; i <= numecs; ++i )
X	    {
X	    tecbck[i] = i - 1;
X	    tecfwd[i - 1] = i;
X	    }
X
X	tecfwd[numecs] = NIL;
X	}
X    }
X
X
X/* mkdeftbl - make the default, "jam" table entries
X *
X * synopsis
X *   mkdeftbl();
X */
X
Xvoid mkdeftbl()
X
X    {
X    int i;
X
X    jamstate = lastdfa + 1;
X
X    ++tblend; /* room for transition on end-of-buffer character */
X
X    if ( tblend + numecs > current_max_xpairs )
X	expand_nxt_chk();
X
X    /* add in default end-of-buffer transition */
X    nxt[tblend] = end_of_buffer_state;
X    chk[tblend] = jamstate;
X
X    for ( i = 1; i <= numecs; ++i )
X	{
X	nxt[tblend + i] = 0;
X	chk[tblend + i] = jamstate;
X	}
X
X    jambase = tblend;
X
X    base[jamstate] = jambase;
X    def[jamstate] = 0;
X
X    tblend += numecs;
X    ++numtemps;
X    }
X
X
X/* mkentry - create base/def and nxt/chk entries for transition array
X *
X * synopsis
X *   int state[numchars + 1], numchars, statenum, deflink, totaltrans;
X *   mkentry( state, numchars, statenum, deflink, totaltrans );
X *
X * "state" is a transition array "numchars" characters in size, "statenum"
X * is the offset to be used into the base/def tables, and "deflink" is the
X * entry to put in the "def" table entry.  If "deflink" is equal to
X * "JAMSTATE", then no attempt will be made to fit zero entries of "state"
X * (i.e., jam entries) into the table.  It is assumed that by linking to
X * "JAMSTATE" they will be taken care of.  In any case, entries in "state"
X * marking transitions to "SAME_TRANS" are treated as though they will be
X * taken care of by whereever "deflink" points.  "totaltrans" is the total
X * number of transitions out of the state.  If it is below a certain threshold,
X * the tables are searched for an interior spot that will accommodate the
X * state array.
X */
X
Xvoid mkentry( state, numchars, statenum, deflink, totaltrans )
Xregister int *state;
Xint numchars, statenum, deflink, totaltrans;
X
X    {
X    register int minec, maxec, i, baseaddr;
X    int tblbase, tbllast;
X
X    if ( totaltrans == 0 )
X	{ /* there are no out-transitions */
X	if ( deflink == JAMSTATE )
X	    base[statenum] = JAMSTATE;
X	else
X	    base[statenum] = 0;
X
X	def[statenum] = deflink;
X	return;
X	}
X
X    for ( minec = 1; minec <= numchars; ++minec )
X	{
X	if ( state[minec] != SAME_TRANS )
X	    if ( state[minec] != 0 || deflink != JAMSTATE )
X		break;
X	}
X
X    if ( totaltrans == 1 )
X	{
X	/* there's only one out-transition.  Save it for later to fill
X	 * in holes in the tables.
X	 */
X	stack1( statenum, minec, state[minec], deflink );
X	return;
X	}
X
X    for ( maxec = numchars; maxec > 0; --maxec )
X	{
X	if ( state[maxec] != SAME_TRANS )
X	    if ( state[maxec] != 0 || deflink != JAMSTATE )
X		break;
X	}
X
X    /* Whether we try to fit the state table in the middle of the table
X     * entries we have already generated, or if we just take the state
X     * table at the end of the nxt/chk tables, we must make sure that we
X     * have a valid base address (i.e., non-negative).  Note that not only are
X     * negative base addresses dangerous at run-time (because indexing the
X     * next array with one and a low-valued character might generate an
X     * array-out-of-bounds error message), but at compile-time negative
X     * base addresses denote TEMPLATES.
X     */
X
X    /* find the first transition of state that we need to worry about. */
X    if ( totaltrans * 100 <= numchars * INTERIOR_FIT_PERCENTAGE )
X	{ /* attempt to squeeze it into the middle of the tabls */
X	baseaddr = firstfree;
X
X	while ( baseaddr < minec )
X	    {
X	    /* using baseaddr would result in a negative base address below
X	     * find the next free slot
X	     */
X	    for ( ++baseaddr; chk[baseaddr] != 0; ++baseaddr )
X		;
X	    }
X
X	if ( baseaddr + maxec - minec >= current_max_xpairs )
X	    expand_nxt_chk();
X
X	for ( i = minec; i <= maxec; ++i )
X	    if ( state[i] != SAME_TRANS )
X		if ( state[i] != 0 || deflink != JAMSTATE )
X		    if ( chk[baseaddr + i - minec] != 0 )
X			{ /* baseaddr unsuitable - find another */
X			for ( ++baseaddr;
X			      baseaddr < current_max_xpairs &&
X			      chk[baseaddr] != 0;
X			      ++baseaddr )
X			    ;
X
X			if ( baseaddr + maxec - minec >= current_max_xpairs )
X			    expand_nxt_chk();
X
X			/* reset the loop counter so we'll start all
X			 * over again next time it's incremented
X			 */
X
X			i = minec - 1;
X			}
X	}
X
X    else
X	{
X	/* ensure that the base address we eventually generate is
X	 * non-negative
X	 */
X	baseaddr = max( tblend + 1, minec );
X	}
X
X    tblbase = baseaddr - minec;
X    tbllast = tblbase + maxec;
X
X    if ( tbllast >= current_max_xpairs )
X	expand_nxt_chk();
X
X    base[statenum] = tblbase;
X    def[statenum] = deflink;
X
X    for ( i = minec; i <= maxec; ++i )
X	if ( state[i] != SAME_TRANS )
X	    if ( state[i] != 0 || deflink != JAMSTATE )
X		{
X		nxt[tblbase + i] = state[i];
X		chk[tblbase + i] = statenum;
X		}
X
X    if ( baseaddr == firstfree )
X	/* find next free slot in tables */
X	for ( ++firstfree; chk[firstfree] != 0; ++firstfree )
X	    ;
X
X    tblend = max( tblend, tbllast );
X    }
X
X
X/* mk1tbl - create table entries for a state (or state fragment) which
X *            has only one out-transition
X *
X * synopsis
X *   int state, sym, onenxt, onedef;
X *   mk1tbl( state, sym, onenxt, onedef );
X */
X
Xvoid mk1tbl( state, sym, onenxt, onedef )
Xint state, sym, onenxt, onedef;
X
X    {
X    if ( firstfree < sym )
X	firstfree = sym;
X
X    while ( chk[firstfree] != 0 )
X	if ( ++firstfree >= current_max_xpairs )
X	    expand_nxt_chk();
X
X    base[state] = firstfree - sym;
X    def[state] = onedef;
X    chk[firstfree] = state;
X    nxt[firstfree] = onenxt;
X
X    if ( firstfree > tblend )
X	{
X	tblend = firstfree++;
X
X	if ( firstfree >= current_max_xpairs )
X	    expand_nxt_chk();
X	}
X    }
X
X
X/* mkprot - create new proto entry
X *
X * synopsis
X *   int state[], statenum, comstate;
X *   mkprot( state, statenum, comstate );
X */
X
Xvoid mkprot( state, statenum, comstate )
Xint state[], statenum, comstate;
X
X    {
X    int i, slot, tblbase;
X
X    if ( ++numprots >= MSP || numecs * numprots >= PROT_SAVE_SIZE )
X	{
X	/* gotta make room for the new proto by dropping last entry in
X	 * the queue
X	 */
X	slot = lastprot;
X	lastprot = protprev[lastprot];
X	protnext[lastprot] = NIL;
X	}
X
X    else
X	slot = numprots;
X
X    protnext[slot] = firstprot;
X
X    if ( firstprot != NIL )
X	protprev[firstprot] = slot;
X
X    firstprot = slot;
X    prottbl[slot] = statenum;
X    protcomst[slot] = comstate;
X
X    /* copy state into save area so it can be compared with rapidly */
X    tblbase = numecs * (slot - 1);
X
X    for ( i = 1; i <= numecs; ++i )
X	protsave[tblbase + i] = state[i];
X    }
X
X
X/* mktemplate - create a template entry based on a state, and connect the state
X *              to it
X *
X * synopsis
X *   int state[], statenum, comstate, totaltrans;
X *   mktemplate( state, statenum, comstate, totaltrans );
X */
X
Xvoid mktemplate( state, statenum, comstate )
Xint state[], statenum, comstate;
X
X    {
X    int i, numdiff, tmpbase, tmp[CSIZE + 1];
X    Char transset[CSIZE + 1];
X    int tsptr;
X
X    ++numtemps;
X
X    tsptr = 0;
X
X    /* calculate where we will temporarily store the transition table
X     * of the template in the tnxt[] array.  The final transition table
X     * gets created by cmptmps()
X     */
X
X    tmpbase = numtemps * numecs;
X
X    if ( tmpbase + numecs >= current_max_template_xpairs )
X	{
X	current_max_template_xpairs += MAX_TEMPLATE_XPAIRS_INCREMENT;
X
X	++num_reallocs;
X
X	tnxt = reallocate_integer_array( tnxt, current_max_template_xpairs );
X	}
X
X    for ( i = 1; i <= numecs; ++i )
X	if ( state[i] == 0 )
X	    tnxt[tmpbase + i] = 0;
X	else
X	    {
X	    transset[tsptr++] = i;
X	    tnxt[tmpbase + i] = comstate;
X	    }
X
X    if ( usemecs )
X	mkeccl( transset, tsptr, tecfwd, tecbck, numecs, 0 );
X
X    mkprot( tnxt + tmpbase, -numtemps, comstate );
X
X    /* we rely on the fact that mkprot adds things to the beginning
X     * of the proto queue
X     */
X
X    numdiff = tbldiff( state, firstprot, tmp );
X    mkentry( tmp, numecs, statenum, -numtemps, numdiff );
X    }
X
X
X/* mv2front - move proto queue element to front of queue
X *
X * synopsis
X *   int qelm;
X *   mv2front( qelm );
X */
X
Xvoid mv2front( qelm )
Xint qelm;
X
X    {
X    if ( firstprot != qelm )
X	{
X	if ( qelm == lastprot )
X	    lastprot = protprev[lastprot];
X
X	protnext[protprev[qelm]] = protnext[qelm];
X
X	if ( protnext[qelm] != NIL )
X	    protprev[protnext[qelm]] = protprev[qelm];
X
X	protprev[qelm] = NIL;
X	protnext[qelm] = firstprot;
X	protprev[firstprot] = qelm;
X	firstprot = qelm;
X	}
X    }
X
X
X/* place_state - place a state into full speed transition table
X *
X * synopsis
X *     int *state, statenum, transnum;
X *     place_state( state, statenum, transnum );
X *
X * State is the statenum'th state.  It is indexed by equivalence class and
X * gives the number of the state to enter for a given equivalence class.
X * Transnum is the number of out-transitions for the state.
X */
X
Xvoid place_state( state, statenum, transnum )
Xint *state, statenum, transnum;
X
X    {
X    register int i;
X    register int *state_ptr;
X    int position = find_table_space( state, transnum );
X
X    /* base is the table of start positions */
X    base[statenum] = position;
X
X    /* put in action number marker; this non-zero number makes sure that
X     * find_table_space() knows that this position in chk/nxt is taken
X     * and should not be used for another accepting number in another state
X     */
X    chk[position - 1] = 1;
X
X    /* put in end-of-buffer marker; this is for the same purposes as above */
X    chk[position] = 1;
X
X    /* place the state into chk and nxt */
X    state_ptr = &state[1];
X
X    for ( i = 1; i <= numecs; ++i, ++state_ptr )
X	if ( *state_ptr != 0 )
X	    {
X	    chk[position + i] = i;
X	    nxt[position + i] = *state_ptr;
X	    }
X
X    if ( position + numecs > tblend )
X	tblend = position + numecs;
X    }
X
X
X/* stack1 - save states with only one out-transition to be processed later
X *
X * synopsis
X *   int statenum, sym, nextstate, deflink;
X *   stack1( statenum, sym, nextstate, deflink );
X *
X * if there's room for another state one the "one-transition" stack, the
X * state is pushed onto it, to be processed later by mk1tbl.  If there's
X * no room, we process the sucker right now.
X */
X
Xvoid stack1( statenum, sym, nextstate, deflink )
Xint statenum, sym, nextstate, deflink;
X
X    {
X    if ( onesp >= ONE_STACK_SIZE - 1 )
X	mk1tbl( statenum, sym, nextstate, deflink );
X
X    else
X	{
X	++onesp;
X	onestate[onesp] = statenum;
X	onesym[onesp] = sym;
X	onenext[onesp] = nextstate;
X	onedef[onesp] = deflink;
X	}
X    }
X
X
X/* tbldiff - compute differences between two state tables
X *
X * synopsis
X *   int state[], pr, ext[];
X *   int tbldiff, numdifferences;
X *   numdifferences = tbldiff( state, pr, ext )
X *
X * "state" is the state array which is to be extracted from the pr'th
X * proto.  "pr" is both the number of the proto we are extracting from
X * and an index into the save area where we can find the proto's complete
X * state table.  Each entry in "state" which differs from the corresponding
X * entry of "pr" will appear in "ext".
X * Entries which are the same in both "state" and "pr" will be marked
X * as transitions to "SAME_TRANS" in "ext".  The total number of differences
X * between "state" and "pr" is returned as function value.  Note that this
X * number is "numecs" minus the number of "SAME_TRANS" entries in "ext".
X */
X
Xint tbldiff( state, pr, ext )
Xint state[], pr, ext[];
X
X    {
X    register int i, *sp = state, *ep = ext, *protp;
X    register int numdiff = 0;
X
X    protp = &protsave[numecs * (pr - 1)];
X
X    for ( i = numecs; i > 0; --i )
X	{
X	if ( *++protp == *++sp )
X	    *++ep = SAME_TRANS;
X	else
X	    {
X	    *++ep = *sp;
X	    ++numdiff;
X	    }
X	}
X
X    return ( numdiff );
X    }
END_OF_FILE
  if test 25169 -ne `wc -c <'tblcmp.c'`; then
    echo shar: \"'tblcmp.c'\" unpacked with wrong size!
  fi
  # end of 'tblcmp.c'
fi
echo shar: End of archive 7 \(of 10\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
