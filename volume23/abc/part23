Subject:  v23i102:  ABC interactive programming environment, Part23/25
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: bcd4a878 1c5622f5 e9ef9a9a d92317e9

Submitted-by: Steven Pemberton <steven@cwi.nl>
Posting-number: Volume 23, Issue 102
Archive-name: abc/part23

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  abc/README abc/README2 abc/b/b1file.c abc/b/getopt.c
#   abc/bed/e1save.c abc/bio/i4grp.c abc/boot/Makefile.bsd
#   abc/boot/README abc/btr/DEP abc/doc/ABCproject abc/ehdrs/getc.h
#   abc/ehdrs/supr.h abc/ex/generate/follower.cts
#   abc/ex/try/follower.cts abc/ihdrs/i0err.h abc/ihdrs/i3sou.h
#   abc/keys/Makefile abc/keys/keydef.h abc/tc/README abc/tc/tc3.c
#   abc/uhdrs/feat.h abc/uhdrs/os.h.gen abc/unix/DEP abc/unix/u1dir.c
#   abc/unix/u1time.c
# Wrapped by rsalz@litchi.bbn.com on Mon Dec 17 13:28:25 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 23 (of 25)."'
if test -f 'abc/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/README'\"
else
  echo shar: Extracting \"'abc/README'\" \(2086 characters\)
  sed "s/^X//" >'abc/README' <<'END_OF_FILE'
XCopyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988.
X
XHOW TO INSTALL ABC:
X
XYou will need 2.5 megabytes in total to compile and load the ABC system.
XTo start type:
X
X        ./Setup
X
Xwhich will ask you some questions to set the ABC system up on your
Xinstallation.  You can call "Setup" any number of times without spoiling
Xfiles.  So run it once to see what questions you will be asked.  If you
Xdon't know the answer to some question, you can run it again.
X
X        make makefiles
X        make depend
X
Xwill construct simple makefiles and makefiles with dependencies,
Xrespectively, in the relevant subdirectories.
X
X        make all
X
Xwill compile and load the ABC system, producing the "abc" command file and
Xthe binaries and datafiles it needs locally in this directory.  You can
Xtest the ABC interpreter with:
X
X        make examples
X
XThis runs some examples in ./ex. It does not test the ABC editor, however;
Xthat can only be done interactively with
X
X        make try_editor
X
XConsult the sheet "HOW TO TRY THE ABC EDITOR" (also in ./README2).
X
XIf all is well and you want to make ABC public
X
X        make install
X
Xwill do some editing to get the right pathnames in, and install the "abc"
Xshell command file, the "abc.1" manual file, and the auxiliary files in the
Xdirectories you indicated during setup.  Finally
X
X        make clean
X
Xwill clean all intermediate object files from the source directories, and
X
X        make clobber
X
Xwill clean the automatically created makefiles from the subdirectories.
X
XIf you have made ABC public, all necessary files have been copied to the
Xpublic places, and you can get rid of the entire ABC file system hierarchy
Xyou extracted from the tape, if you want.
X
XIf there are any problems, don't panic. See ./Problems for advice.  Also
Xedit the example Bug Report form in ./doc to communicate the problem to us.
XWe can then send out diffs for fixed problems in the future.
X
XAbove all, we would be very grateful to receive any comments you have about
Xthe setup procedure, or the ABC system in general, on how to make it easier
Xto use.
X
XGood luck!
END_OF_FILE
  if test 2086 -ne `wc -c <'abc/README'`; then
    echo shar: \"'abc/README'\" unpacked with wrong size!
  fi
  # end of 'abc/README'
fi
if test -f 'abc/README2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/README2'\"
else
  echo shar: Extracting \"'abc/README2'\" \(1775 characters\)
  sed "s/^X//" >'abc/README2' <<'END_OF_FILE'
XCopyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988.
X
XHOW TO TRY THE ABC EDITOR:
X
XThe directory ./ex/try is here to try the ABC editor interactively.
X
XAfter a successful "make all" or "make examples" say:
X
X        make try_editor
X
Xto enter the ABC system.  (If you are cross-compiling, copy ./ex
Xrecursively to the target machine and say:
X
X        cd ex
X        TryEditor
X
Xyou should make sure that the "abc" command in your PATH.)
X
XAfter the ABC system has started up it will prompt for a command with
X
X        >>> ?
X
XSlowly type `s', then `t', (no capitals needed) and you should see the ABC
Xeditor suggest the SELECT and START commands, respectively.  Now
Xpress [TAB] to accept this last suggestion, and [RETURN] to enter the
XSTART command to the ABC interpreter.  This command will prompt you for
Xinput, with
X
X        ?
X
XJust enter a few lines of text, (which will be echoed), ending with an
Xempty one (press [RETURN] immediately).  A short "poem" should be generated
Xby the ABC interpreter.
X
XIf you are already familiar with the ABC language, you might try to edit
Xthe START how-to by answering
X
X        >>> ?
X
Xwith
X
X        :START
X
XFor example, try to remove the SET RANDOM command, to get random
Xresults on the same input.  Or make the unit delay the echoing of the text,
Xentered by the user, until after the reading of the empty line.  For
Xtesting purposes you should at least try the arrow keys to move the focus
Xaround.
X
XYou can undo any change by pressing [BACKSPACE].
XYou can get help with ? or [ESC]-?.
XYou can leave the ABC editor with [ESC]-[ESC].
XYou can leave "abc" by typing QUIT.
X
XFor more information, see the manual page "abc(1)" and "The ABC
Xprogrammer's Handbook".
X
XSee the B Newsletter, issue 2, for a description of the "generate" program.
END_OF_FILE
  if test 1775 -ne `wc -c <'abc/README2'`; then
    echo shar: \"'abc/README2'\" unpacked with wrong size!
  fi
  # end of 'abc/README2'
fi
if test -f 'abc/b/b1file.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/b/b1file.c'\"
else
  echo shar: Extracting \"'abc/b/b1file.c'\" \(1866 characters\)
  sed "s/^X//" >'abc/b/b1file.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X#include "b.h"
X#include "bfil.h"
X#include "bmem.h"
X
XVisible string messfile= (string) NULL;	/* error messages */
XVisible string keysfile= (string) NULL;	/* key definitions */
XVisible string helpfile= (string) NULL;	/* manual as help */
X
XVisible string permfile= PERMFILE;	/* saves links file name vs. abc name */
XVisible string suggfile= SUGGFILE;	/* saves user suggestions */
XVisible string posfile= POSFILE;	/* saves focus positions */
XVisible string typesfile= TYPESFILE;	/* saves typecode's */
X
XVisible string buffile= BUFFILE;	/* saves copybuffer */
X
XVisible string wsgroupfile= WSGROUPFILE; 
X				/* saves links workspace name vs. abc name */
XVisible string curwsfile= CURWSFILE;	/* saves last workspace */
X
XVisible string tempfile= TEMPFILE;	/* temporary file */
XVisible string temp1file= TEMP1FILE;	/* another temporary file */
X
XVisible string editor;			/* another editor (via command line) */
X
XVisible char *bwsdefault; /* full path name of the default group directory */
XVisible char *startdir; /* full path name of the startup directory */
X
XVisible char *makepath(path1, path2) char *path1, *path2; {
X	if (path1 == NULL || *path1 == '\0')
X		return savepath(path2);
X	else if (path2 == NULL || *path2 == '\0')
X		return savepath(path1);
X	else {
X		char *path, *ppath;
X		int len;
X	
X		len= strlen(path1) + 1 + strlen(path2);
X		path= (char *) getmem((unsigned) (len+1));
X		strcpy(path, path1);
X		ppath= path + strlen(path);
X		if (ppath[-1] == DELIM && *path2 == DELIM)
X			--ppath;
X		else if (ppath[-1] != DELIM && *path2 != DELIM)
X			*ppath++= DELIM;
X		strcpy(ppath, path2);
X		return path;
X	}
X}
X
XVisible char *savepath(path) char *path; {
X	if (path != NULL)
X		return savestr(path);
X	return (char *) NULL;
X}
X
XVisible Procedure freepath(path) char *path; {
X	if (path != NULL)
X		freestr(path);
X}
END_OF_FILE
  if test 1866 -ne `wc -c <'abc/b/b1file.c'`; then
    echo shar: \"'abc/b/b1file.c'\" unpacked with wrong size!
  fi
  # end of 'abc/b/b1file.c'
fi
if test -f 'abc/b/getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/b/getopt.c'\"
else
  echo shar: Extracting \"'abc/b/getopt.c'\" \(1313 characters\)
  sed "s/^X//" >'abc/b/getopt.c' <<'END_OF_FILE'
X/* This file is slightly adapted from a public domain version. */
X/* We need os.h for the index-strchr controversy. */
X
X#include "os.h"
X
X/*LINTLIBRARY*/
X#define NULL	0
X#define EOF	(-1)
X#define ERR(s, c)	if(opterr){\
X	extern int write();\
X	char errbuf[2];\
X	errbuf[0] = c; errbuf[1] = '\n';\
X	VOID write(2, argv[0], (int)strlen(argv[0]));\
X	VOID write(2, s, (int)strlen(s));\
X	VOID write(2, errbuf, 2);}
X
Xint	opterr = 1;
Xint	optind = 1;
Xint	optopt;
Xchar	*optarg;
X
Xint
Xgetopt(argc, argv, opts)
Xint	argc;
Xchar	**argv, *opts;
X{
X	static int sp = 1;
X	register int c;
X	register char *cp;
X
X	if(sp == 1)
X		if(optind >= argc ||
X		   argv[optind][0] != '-' || argv[optind][1] == '\0')
X			return(EOF);
X		else if(strcmp(argv[optind], "--") == NULL) {
X			optind++;
X			return(EOF);
X		}
X	optopt = c = argv[optind][sp];
X	if(c == ':' || (cp=strchr(opts, c)) == NULL) {
X		ERR(": illegal option -- ", c);
X		if(argv[optind][++sp] == '\0') {
X			optind++;
X			sp = 1;
X		}
X		return('?');
X	}
X	if(*++cp == ':') {
X		if(argv[optind][sp+1] != '\0')
X			optarg = &argv[optind++][sp+1];
X		else if(++optind >= argc) {
X			ERR(": option requires an argument -- ", c);
X			sp = 1;
X			return('?');
X		} else
X			optarg = argv[optind++];
X		sp = 1;
X	} else {
X		if(argv[optind][++sp] == '\0') {
X			sp = 1;
X			optind++;
X		}
X		optarg = NULL;
X	}
X	return(c);
X}
END_OF_FILE
  if test 1313 -ne `wc -c <'abc/b/getopt.c'`; then
    echo shar: \"'abc/b/getopt.c'\" unpacked with wrong size!
  fi
  # end of 'abc/b/getopt.c'
fi
if test -f 'abc/bed/e1save.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bed/e1save.c'\"
else
  echo shar: Extracting \"'abc/bed/e1save.c'\" \(2113 characters\)
  sed "s/^X//" >'abc/bed/e1save.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/*
X * B editor -- Save Parse tree on file.
X */
X
X#include "b.h"
X#include "b0lan.h"
X#include "bedi.h"
X#include "etex.h"
X#include "bmem.h"
X#include "bobj.h"
X#include "node.h"
X#include "gram.h"
X
XHidden int spaces = 0; /* Saved-up spaces; emitted when non-blank found */
X
X/*
X * Write the representation of a node.	If it has children,
X * they are written by recursive calls.
X */
X
XHidden Procedure savewalk(n, level, bp, fp) node n; int level;
X		bufadm *bp; FILE *fp; {
X	string *rp;
X	string cp;
X	int nch;
X	int i;
X	char c;
X
X	if (Is_etext(n)) {
X		for (; spaces > 0; --spaces)
X			bufpush(bp, ' ');
X		bufcpy(bp, e_strval((value) n));
X		return;
X	}
X	nch = nchildren(n);
X	rp = noderepr(n);
X	for (i = 0; i <= nch; ++i) {
X		if (i)
X			savewalk(child(n, i), level, bp, fp);
X		cp = rp[i];
X		if (!cp) continue;
X		for (; c = *cp; ++cp) {
X			switch (c) {
X
X			case '\n':
X#if '\n' != '\r' /* This condition is TRUE in MPW C! */
X			case '\r':
X#endif
X				bufpush(bp, '\n');
X				if (fp) {
X					bufpush(bp, '\0');
X					fputs(bp->buf, fp);
X					bufreinit(bp);
X				}
X				if (c == '\n')
X					for (i = level; i > 0; --i)
X						bufcpy(bp, Indent);
X				spaces = 0;
X				break;
X
X			case '\b':
X				--level;
X				break;
X
X			case '\t':
X				++level;
X				break;
X
X			case ' ':
X				++spaces;
X				break;
X
X			default:
X				for (; spaces > 0; --spaces)
X					bufpush(bp, ' ');
X				bufpush(bp, c);
X				break;
X			}
X		}
X	}
X}
X
XVisible bool save(p, filename) path p; string filename; {
X	bufadm b, *bp;
X	FILE *fp = fopen(filename, "w");
X	
X	if (!fp) return No;
X	bp= &b;
X	bufinit(bp);
X	sendsave(p, bp, fp);
X	bufpush(bp, '\0');
X	fputs(bp->buf, fp);
X	buffree(bp);
X	return fclose(fp) != EOF;
X}
X
X
XHidden Procedure sendsave(p, bp, fp) path p; bufadm *bp; FILE *fp; {
X	p = pathcopy(p);
X	top(&p);
X	spaces = 0;
X	savewalk(tree(p), 0, bp, fp);
X	bufpush(bp, '\n');
X	pathrelease(p);
X}
X
X/*
X * Interface to top level.
X */
X
XVisible char *send(p) path p; {
X	char *res;
X	bufadm b, *bp;
X	
X	bp= &b;
X	bufinit(bp);
X	sendsave(p, bp, (FILE *)NULL);
X	bufpush(bp, '\0');
X	res= savestr(bp->buf);
X	buffree(bp);
X	return res;
X}
X
END_OF_FILE
  if test 2113 -ne `wc -c <'abc/bed/e1save.c'`; then
    echo shar: \"'abc/bed/e1save.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bed/e1save.c'
fi
if test -f 'abc/bio/i4grp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bio/i4grp.c'\"
else
  echo shar: Extracting \"'abc/bio/i4grp.c'\" \(2117 characters\)
  sed "s/^X//" >'abc/bio/i4grp.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X#include "b.h"
X#include "bfil.h"
X#include "bobj.h"
X#include "i3bws.h"	
X#include "i3sou.h"
X#include "i4bio.h"
X
X/* code to recover the index of a group of workspaces */
X
XVisible bool gr_recovered= No;
X
XHidden bool rec_ok= Yes;
X
XHidden value newgroup;
X
XVisible Procedure rec_wsgroup() {
X	value lis, dname;
X	value k, len, m;
X
X	gr_recovered= No;
X	rec_ok= Yes;
X	
X	newgroup= mk_elt();
X	
X	lis= get_names(bwsdir, abcworkspace);
X	k= one; len= size(lis);
X	while (numcomp(k, len) <= 0) {
X		dname= item(lis, k);
X		rec_dirname(dname);
X		release(dname);
X		k= sum(m= k, one);
X		release(m);
X	}
X	release(k); release(len);
X	release(lis);
X
X	rec_curlast();
X	
X	release(ws_group);
X	ws_group= newgroup;
X	groupchanges= Yes;
X	
X	gr_recovered= Yes;
X}
X
XHidden Procedure rec_dirname(dname) value dname; {
X	value name;
X	intlet k, len;
X	
X	/* try to find a name via the old index table */
X	name= Vnil;
X	len= Valid(ws_group) ? length(ws_group) : 0;
X	for (k= 0; k<len; ++k) {
X		if (compare(*assoc(ws_group, k), dname) == 0) {
X			name= copy(*key(ws_group, k));
X			if (is_wsname(name))
X				break;
X			release(name); name= Vnil;
X		}
X	}
X	if (!Valid(name)) { /* make a new name */
X		char *base= sstrval(dname);
X		name= mkabcname(base);
X		fstrval(base);
X	}
X	if (!is_abcname(name)) {
X		grperrV(G_DNAME, dname);
X		release(name);
X		return;
X	}
X	mk_groupentry(name, dname);
X	release(name);
X}
X
XHidden bool is_wsname(name) value name; {
X	if (!is_abcname(name))
X		return No;
X	if (compare(name, curwskey) == 0 || compare(name, lastwskey) == 0)
X		return No;
X	return Yes;
X}
X
XHidden Procedure mk_groupentry(name, dname) value name, dname; {
X	if (in_keys(name, newgroup)) {
X		grperrV(G_EXIST, dname);
X		return;
X	}
X	replace(dname, &newgroup, name);
X}
X
XHidden Procedure rec_curlast() {
X	value *aa;
X	if (!Valid(ws_group))
X		return;
X	if (in_env(ws_group, curwskey, &aa))
X		replace(*aa, &newgroup, curwskey);
X	if (in_env(ws_group, lastwskey, &aa))
X		replace(*aa, &newgroup, lastwskey);
X}
X
XHidden Procedure grperrV(m, v) int m; value v; {
X	if (rec_ok) {
X		bioerr(G_ERROR);
X		rec_ok= No;
X	}
X	bioerrV(m, v);
X}
END_OF_FILE
  if test 2117 -ne `wc -c <'abc/bio/i4grp.c'`; then
    echo shar: \"'abc/bio/i4grp.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bio/i4grp.c'
fi
if test -f 'abc/boot/Makefile.bsd' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/boot/Makefile.bsd'\"
else
  echo shar: Extracting \"'abc/boot/Makefile.bsd'\" \(1989 characters\)
  sed "s/^X//" >'abc/boot/Makefile.bsd' <<'END_OF_FILE'
X#
X# BSD Makefile for booting grammar tables with mktable from grammar file.
X#
X
X# --- Where to install the stuff ---
X
XCFILE=../bed/e1tabl.c
XHFILE=../ehdrs/tabl.h
X
X# --- What is the C preprocessor called ---
X#
X# ../scripts/mkdep has the right CPP if Setup succeeded and your UNIX ain't BSD
X
XCPP=	/bin/cc -E
X
X# --- Flags to the C compiler ---
X
XBINCL=	-I../bhdrs -I../ehdrs -I../uhdrs
XDEFS=	-DNDEBUG -DBSD
XCFLAGS= -O $(DEFS) $(BINCL)
XLDFLAGS=-s
XLIBS=	
XGDEFS=
X
X# --- Stuff for lint ---
X
XLINT=		lint
XLINTFLAGS=	-abh
XLBINCL=		$(BINCL)
X
X# --- Relevant files ---
X
XOBJS=	main.o alloc.o read.o fill.o comp.o dump.o code.o
X
XSRCS=	main.c alloc.c read.c fill.c comp.c dump.c ../bed/e1code.c
X
XHDRS=	../bhdrs/b.h main.h ../ehdrs/code.h lang.h
X
X# --- Main entries of the makefile ---
X
Xall: tabl.c.out tabl.h.out
X
Xtabl.c.out tabl.h.out: grammar mktable
X	mktable -g grammar -h tabl.h -t tabl.c.out -i tabl.h.out
X
Xgrammar: grammar.abc lang.h
X	$(CPP) $(GDEFS) grammar.abc 2>/dev/null | sed -e "/^$$/d" -e "/^#/d" >grammar
X
Xmktable: $(OBJS)
X	$(CC) $(LDFLAGS) $(OBJS) $(LIBS) -o mktable
X
Xinstall: $(CFILE) $(HFILE)
X
X$(CFILE): tabl.c.out
X	cp tabl.c.out $(CFILE)
X
X$(HFILE): tabl.h.out
X	cp tabl.h.out $(HFILE)
X
Xclean:
X	rm -f *.o mktable grammar tabl.c.out tabl.h.out tabl.c tabl.h
X
Xclobber: clean
X	rm -f lint tags
X
Xcode.o: ../bed/e1code.c
X	$(CC) -c $(CFLAGS) ../bed/e1code.c -o code.o
X
X# --- Utilities for the programmer ---
X
Xmflags:
X	echo MFLAGS=\"$(MFLAGS)\", MAKEFLAGS=\"$(MAKEFLAGS)\"
X
X# If your UNIX isn't BSD4.2 or higher, use:
X# MKDEP=../scripts/mkdep
XMKDEP=$(CC) -M
X
XMakefile: ALWAYS
X	rm -f Makefile
X	(echo "# EDIT MY ANCESTOR Makefile.bsd"; \
X	 echo "# AND SAY 'make -f Makefile.bsd Makefile'"; \
X	 cat Makefile.bsd; \
X	 $(MKDEP) $(DEFS) $(BINCL) $(SRCS); \
X	) >Makefile
X
Xlint:	$(SRCS) $(HDRS)
X	$(LINT) $(LINTFLAGS) $(DEFS) $(LBINCL) $(SRCS) >lint
X
Xtags:	$(HDRS) $(SRCS)
X	rm -f tags
X	ctags $(HDRS) $(SRCS)
X
Xtest:	all
X	cp tabl.h.out tabl.h
X	cp tabl.c.out tabl.c
X	cc -c $(CFLAGS) tabl.c
X
XALWAYS:	#dummy
X
X###
END_OF_FILE
  if test 1989 -ne `wc -c <'abc/boot/Makefile.bsd'`; then
    echo shar: \"'abc/boot/Makefile.bsd'\" unpacked with wrong size!
  fi
  # end of 'abc/boot/Makefile.bsd'
fi
if test -f 'abc/boot/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/boot/README'\"
else
  echo shar: Extracting \"'abc/boot/README'\" \(1407 characters\)
  sed "s/^X//" >'abc/boot/README' <<'END_OF_FILE'
XThe purpose of this directory is to generate the grammar tables for
Xthe ABC editor in ../bed/e1tabl.c and ../ehdrs/tabl.h from a more or
Xless readable description in ./grammar.abc (also using ./lang.h).
X
XThe ABC system is set up such that you can do without this directory.
X
XHowever, if you want to make a version of ABC with KEYWORDS in another
Xlanguage, you only need to change ./lang.h and say 'make install' here.
X(You might have to change the name of the C preprocessor in the Makefile.)
XThis will install new versions of ../bed/e1tabl.c and ../ehdrs/tabl.h,
Xincorporating the new grammar info.
XYou should also change ../bhdrs/b0lan.h and bint2/i2dis.c 
Xfor the ABC interpreter.
XThen you can 'cd ..' and remake the ABC system.
X
XLikewise if for whatever reason you only change the grammar file,
Xit is sufficient to say 'make install' here, and remake in '..'.
X
XThe ABC grammar is in the file grammar.abc.
XThe format of this file is decribed in its heading.
X
XThe rest of the files here (together with some files from elsewhere in
Xthe ABC system) are sources for the program 'mktable' that generates the
Xinclude- and data-file.
XIf you change anything in them you might have to recreate the
Xdependencies in the Makefile with 'make -f Makefile.bsd Makefile'.
XSee ../Makefile.unix, ../scripts/mkdep and ../Problems if your system cannot
Xcope with the BSD-ism 'cc -M' for generating dependency info for make.
END_OF_FILE
  if test 1407 -ne `wc -c <'abc/boot/README'`; then
    echo shar: \"'abc/boot/README'\" unpacked with wrong size!
  fi
  # end of 'abc/boot/README'
fi
if test -f 'abc/btr/DEP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/btr/DEP'\"
else
  echo shar: Extracting \"'abc/btr/DEP'\" \(1392 characters\)
  sed "s/^X//" >'abc/btr/DEP' <<'END_OF_FILE'
Xe1etex.o: e1etex.c
Xe1etex.o: ../bhdrs/b.h
Xe1etex.o: ../uhdrs/osconf.h
Xe1etex.o: ../uhdrs/os.h
Xe1etex.o: ../uhdrs/conf.h
Xe1etex.o: ../uhdrs/config.h
Xe1etex.o: ../bhdrs/bedi.h
Xe1etex.o: ../bhdrs/bobj.h
Xe1etex.o: ./etex.h
Xe1etex.o: ../bhdrs/bmem.h
Xi1btr.o: i1btr.c
Xi1btr.o: ../bhdrs/b.h
Xi1btr.o: ../uhdrs/osconf.h
Xi1btr.o: ../uhdrs/os.h
Xi1btr.o: ../uhdrs/conf.h
Xi1btr.o: ../uhdrs/config.h
Xi1btr.o: ../bhdrs/bmem.h
Xi1btr.o: ./i1btr.h
Xi1btr.o: ./i1tlt.h
Xi1lta.o: i1lta.c
Xi1lta.o: ../bhdrs/b.h
Xi1lta.o: ../uhdrs/osconf.h
Xi1lta.o: ../uhdrs/os.h
Xi1lta.o: ../uhdrs/conf.h
Xi1lta.o: ../uhdrs/config.h
Xi1lta.o: ../bhdrs/bobj.h
Xi1lta.o: ./i1btr.h
Xi1lta.o: ../ihdrs/i3scr.h
Xi1lta.o: ./i1tlt.h
Xi1obj.o: i1obj.c
Xi1obj.o: ../bhdrs/b.h
Xi1obj.o: ../uhdrs/osconf.h
Xi1obj.o: ../uhdrs/os.h
Xi1obj.o: ../uhdrs/conf.h
Xi1obj.o: ../uhdrs/config.h
Xi1obj.o: ../bhdrs/bmem.h
Xi1obj.o: ../bhdrs/bobj.h
Xi1obj.o: ./i1btr.h
Xi1obj.o: ./i1tlt.h
Xi1obj.o: ../ihdrs/i3typ.h
Xi1tex.o: i1tex.c
Xi1tex.o: ../bhdrs/b.h
Xi1tex.o: ../uhdrs/osconf.h
Xi1tex.o: ../uhdrs/os.h
Xi1tex.o: ../uhdrs/conf.h
Xi1tex.o: ../uhdrs/config.h
Xi1tex.o: ../bhdrs/bmem.h
Xi1tex.o: ../bhdrs/bobj.h
Xi1tex.o: ./i1btr.h
Xi1tex.o: ./i1tlt.h
Xi1tlt.o: i1tlt.c
Xi1tlt.o: ../bhdrs/b.h
Xi1tlt.o: ../uhdrs/osconf.h
Xi1tlt.o: ../uhdrs/os.h
Xi1tlt.o: ../uhdrs/conf.h
Xi1tlt.o: ../uhdrs/config.h
Xi1tlt.o: ../uhdrs/feat.h
Xi1tlt.o: ../bhdrs/bobj.h
Xi1tlt.o: ./i1btr.h
Xi1tlt.o: ./i1tlt.h
END_OF_FILE
  if test 1392 -ne `wc -c <'abc/btr/DEP'`; then
    echo shar: \"'abc/btr/DEP'\" unpacked with wrong size!
  fi
  # end of 'abc/btr/DEP'
fi
if test -f 'abc/doc/ABCproject' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/doc/ABCproject'\"
else
  echo shar: Extracting \"'abc/doc/ABCproject'\" \(1681 characters\)
  sed "s/^X//" >'abc/doc/ABCproject' <<'END_OF_FILE'
X# Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988.
X
X================================================================
X=         The ABC programming language and environment.        =
X================================================================
X
XAuthors:	Frank van Dijk
X		Leo Geurts
X		Timo Krijnen
X		Lambert Meertens
X		Steven Pemberton
X		Guido van Rossum
X
X		Centrum voor Wiskunde en Informatica / AA
X		POB 4079
X		1900 AB  Amsterdam
X		The Netherlands
X
XNet address:	abc@cwi.nl   (mcvax!abc.uucp for older mailers)
X
XDescription:
X
XABC is a programming language and environment for personal computing
Xdesigned and implemented at the CWI.
XWe have tried to combine attractive features in existing systems
Xwith some ideas of our own.
X
XSome features of the ABC programming language are:
X * a powerful collection of only five different data types
X   that may easily be combined;
X * strong typing, yet without declarations;
X * no limitations, apart from sheer exhaustion of memory;
X * refinements to support top-down programming;
X * nesting by indentation.
X
XSome features of the ABC environment are:
X * no need for files; how-to's (procedures and functions) and global
X   variables remain after logging out;
X * one consistent face is shown to the user at all times,
X   whether she executes commands, edits how-to's, or enters input to
X   a program;
X * generalized undo mechanism.
X
XFor full details see:
X
X	Leo Geurts, Lambert Meertens, Steven Pemberton,
X	The ABC Programmer's Handbook,
X	Prentice-Hall, Englewood Cliffs, New Jersey, 1989,
X	ISBN 0-13-000027-2.
X
XAvailable free from CWI is THE ABC NEWSLETTER.
XJust send a note to one of the above addresses for your subscription.
END_OF_FILE
  if test 1681 -ne `wc -c <'abc/doc/ABCproject'`; then
    echo shar: \"'abc/doc/ABCproject'\" unpacked with wrong size!
  fi
  # end of 'abc/doc/ABCproject'
fi
if test -f 'abc/ehdrs/getc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ehdrs/getc.h'\"
else
  echo shar: Extracting \"'abc/ehdrs/getc.h'\" \(507 characters\)
  sed "s/^X//" >'abc/ehdrs/getc.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
Xextern Procedure initkeys();
X
Xtypedef struct tabent {
X	int code;
X	string name;
X	string def;
X	string rep;
X} tabent;
X
Xextern struct tabent deftab[];
Xextern int ndefs; 		/* number of entries in deftab */
X
X#ifdef KEYS
X
X#define MAXDEFS 200
X#define MAXNEWDEFS 100
Xextern int ddefs; 		/* idem, before processing of keydefsfile */
X
X#else
X
X#define MAXDEFS 100
Xextern Procedure initgetc();
Xextern Procedure endgetc();
Xextern int inchar();
X
X#endif
END_OF_FILE
  if test 507 -ne `wc -c <'abc/ehdrs/getc.h'`; then
    echo shar: \"'abc/ehdrs/getc.h'\" unpacked with wrong size!
  fi
  # end of 'abc/ehdrs/getc.h'
fi
if test -f 'abc/ehdrs/supr.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ehdrs/supr.h'\"
else
  echo shar: Extracting \"'abc/ehdrs/supr.h'\" \(2335 characters\)
  sed "s/^X//" >'abc/ehdrs/supr.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/*
X * B editor -- Superstructure for fine focusing.
X */
X
X/*
X * Interpretation of s1, s2, s3 of focus (where n == tree(ep->focus)):
X *
X * s:	1	2	3	4	5	6	7	8	9
X *	fixed	varia	fixed	varia	fixed	varia	fixed	varia	fixed
X *
X * the fixed fields are the r_repr[i] fields of grammar rule table[symbol(n)],
X * with i == s/2 (and i is odd), thus:
X *
X *	repr[0]		repr[1]		repr[2]		repr[3]		repr[4]
X *
X * the variable fields are the children of the node, with i == s/2 and s even:
X *
X *		child(n,1)	child(n,2)	child(n,3)	child(n,4)
X *
X * (and child(n,i) == n->n_child[i-1]:-)
X *
X * Interpretation of mode of focus:
X *
X * WHOLE: whole node is the focus;
X * SUBSET: s1/2, s2/2 are first and last child number under focus;
X *          odd means fixed text, even means child node;
X * SUBRANGE: focus is part of fixed text or child; in C terms:
X *          s1 odd: repr[s1/2][s2..s3];
X *          s1 even: e_strval(child(n, s1/2))[s2..s3];
X * VHOLE: s1/2 is fixed text number; volatile hole before char s2;
X *          if s1 is even, ditto for child which must be "text".
X * ATEND: a volatile hole just after the entire node.
X * ATBEGIN: ditto just before it.
X * SUBLIST: s3 indicates how many times downrite() bring us
X *          beyond the focus (i.e., the focus is the subtree below
X *          ep->focus EXCLUDING the subtree reached after s3 times
X *          downrite().  Note s3 > 0.
X * FHOLE: Like VHOLE but in Fixed text.
X *
X * It is assumed that if the focus is a substring of fixed text
X * (SUBRANGE, VHOLE), it does not begin or end with lay-out of spaces.
X */
X
X#define WHOLE	'W'
X#define SUBSET	'S'
X#define SUBRANGE	'R'
X#define VHOLE	'V'
X#define ATEND	'E'
X#define ATBEGIN	'B'
X#define SUBLIST	'L'
X#define FHOLE	'F'
X
Xtypedef struct {
X	path focus;
X	char mode;
X	char /*bool*/ copyflag;
X	char /*bool*/ spflag;
X	char /*bool*/ changed;
X	short /*0..2*MAXCHILD+1*/ s1;
X	short s2;
X	short s3;
X	short highest;
X	value copybuffer; /* Actually, a queue */
X	value oldmacro; /* A text */
X	value newmacro; /* A text, too */
X	int generation;
X} environ;
X
X#ifdef STRUCTASS
X#define Emove(e1, e2) ((e2) = (e1))
X#else /* !STRUCTASS */
X#define Emove(e1, e2) emove(&(e1), &(e2))
X#endif /* !STRUCTASS */
X#define Ecopy(e1, e2) ecopy(&(e1), &(e2))
X#define Erelease(e) erelease(&(e))
X
Xbool ishole();
END_OF_FILE
  if test 2335 -ne `wc -c <'abc/ehdrs/supr.h'`; then
    echo shar: \"'abc/ehdrs/supr.h'\" unpacked with wrong size!
  fi
  # end of 'abc/ehdrs/supr.h'
fi
if test -f 'abc/ex/generate/follower.cts' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ex/generate/follower.cts'\"
else
  echo shar: Extracting \"'abc/ex/generate/follower.cts'\" \(1197 characters\)
  sed "s/^X//" >'abc/ex/generate/follower.cts' <<'END_OF_FILE'
X{[" ","M"]:{"a"};[" ","a"]:{" "; "s"};[" ","e"]:{"v"};[" ","f"]:{"l"};[" ","g"]:{"o"};[" ","h"]:{"a"};[" ","l"]:{"a"; "a"; "i"};[" ","s"]:{"n"; "u"};[" ","t"]:{"h"; "o"};[" ","w"]:{"a"; "a"; "e"; "h"};["A","n"]:{"d"};["I","t"]:{"s"};["M","a"]:{"r"; "r"};["T","h"]:{"a"};["a"," "]:{"l"};["a","d"]:{" "};["a","m"]:{"b"; "b"};["a","r"]:{"y"; "y"};["a","s"]:{" "; " "; " "};["a","t"]:{" "; " "};["b"," "]:{"w"};["c","e"]:{" "};["d"," "]:{"a"; "e"};["e"," "]:{"a"; "l"; "t"; "t"; "w"};["e","c"]:{"e"};["e","e"]:{"c"};["e","n"]:{"t"};["e","r"]:{"e"; "y"};["e","v"]:{"e"};["f","l"]:{"e"};["g","o"]:{"."};["h","a"]:{"d"; "t"; "t"};["h","e"]:{"r"};["h","i"]:{"t"};["i","t"]:{"e"; "t"};["l","a"]:{"m"; "m"};["l","e"]:{" "; "e"};["l","i"]:{"t"};["m","b"]:{" "; ","};["n","d"]:{" "};["n","o"]:{"w"};["n","t"]:{","};["o"," "]:{"g"};["o","w"]:{","};["r","e"]:{" "; " "};["r","y"]:{" "; " "; "w"};["s"," "]:{"f"; "s"; "s"; "w"};["s","n"]:{"o"};["s","u"]:{"r"};["t"," "]:{"M"; "l"};["t","e"]:{" "};["t","!
Xh"]:{"a"};["t","l"]:{"e"};["t","o"
X
X
X
X
X]:{" "};["t","s"]:{" "};["t","t"]:{"l"};["u","r"]:{"e"};["v","e"]:{"r"};["w","a"]:{"s"; "s"};["w","e"]:{"n"};["w","h"]:{"e"; "i"};["y"," "]:{"h"; "w"};["y","w"]:{"h"}}
END_OF_FILE
  if test 1197 -ne `wc -c <'abc/ex/generate/follower.cts'`; then
    echo shar: \"'abc/ex/generate/follower.cts'\" unpacked with wrong size!
  fi
  # end of 'abc/ex/generate/follower.cts'
fi
if test -f 'abc/ex/try/follower.cts' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ex/try/follower.cts'\"
else
  echo shar: Extracting \"'abc/ex/try/follower.cts'\" \(1407 characters\)
  sed "s/^X//" >'abc/ex/try/follower.cts' <<'END_OF_FILE'
X{[" ","b"]:{"a"; "e"; "e"};[" ","c"]:{"o"};[" ","d"]:{"e"; "u"};[" ","e"]:{"e"; "e"; "r"};[" ","g"]:{"a"};[" ","h"]:{"e"};[" ","l"]:{"a"; "a"};[" ","m"]:{"a"};[" ","t"]:{"o"};[" ","w"]:{"e"; "i"};[" ","z"]:{"e"; "i"};["a","a"]:{"m"; "n"; "r"; "r"};["a","b"]:{"c"};["a","g"]:{" "};["a","l"]:{" "};["a","m"]:{"."};["a","n"]:{" "; "g"; "g"; "g"};["a","r"]:{" "; "v"};["b","a"]:{"n"};["b","c"]:{" "};["b","e"]:{"e"; "e"};["c"," "]:{"m"};["c","h"]:{" "};["c","o"]:{"n"};["d","a"]:{"a"};["d","e"]:{" "};["d","u"]:{"u"};["e"," "]:{"b"; "c"; "l"};["e","e"]:{"n"; "n"; "r"; "t"; "t"};["e","n"]:{" "; " "; "."};["e","r"]:{" "; " "; "s"};["e","s"]:{" "};["e","t"]:{" "; "j"; "j"};["e","z"]:{"e"};["g"," "]:{"e"};["g","a"]:{"a"};["g","z"]:{"a"};["h"," "]:{"e"};["h","e"]:{"t"};["i","e"]:{"s"};["i","j"]:{" "; "n"};["j"," "]:{"t"};["j","e"]:{" "; " "};["j","n"]:{" "};["l"," "]:{"d"};["l","a"]:{"n"; "n"};["m","a"]:{"a"; "g"};["n"," "]:{"b"; "b"; "w"; "z"};["n","g"]:{"."; "."; "z"};["n","v"]:{"e"};["!
Xo","c"]:{"h"};["o","n"]:{"v"};["o"
X
X
X
X
X,"o"]:{"r"; "r"};["o","r"]:{" "; "a"};["r"," "]:{"h"; "l"; "w"; "z"};["r","a"]:{"l"};["r","s"]:{"i"};["r","t"]:{" "};["r","v"]:{"o"};["s"," "]:{"g"};["s","i"]:{"e"};["t"," "]:{"d"; "e"};["t","j"]:{"e"; "e"};["t","o"]:{"c"};["u","r"]:{"t"};["u","u"]:{"r"};["v","e"]:{"r"};["v","o"]:{"o"; "o"};["w","e"]:{"z"};["w","i"]:{"j"};["z","a"]:{"a"};["z","e"]:{"e"; "n"};["z","i"]:{"j"}}
END_OF_FILE
  if test 1407 -ne `wc -c <'abc/ex/try/follower.cts'`; then
    echo shar: \"'abc/ex/try/follower.cts'\" unpacked with wrong size!
  fi
  # end of 'abc/ex/try/follower.cts'
fi
if test -f 'abc/ihdrs/i0err.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ihdrs/i0err.h'\"
else
  echo shar: Extracting \"'abc/ihdrs/i0err.h'\" \(1676 characters\)
  sed "s/^X//" >'abc/ihdrs/i0err.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/* i1fun.c, i1nua.c, i1nur.c */
X
X#define ZERO_DIVIDE	MESS(1800, "in i/j, j is zero")
X#define NEG_POWER	MESS(1801, "in 0**y or y root 0, y is negative")
X#define NEG_EVEN	MESS(1802, "in x**(p/q) or (q/p) root x, x is negative and q is even")
X#define NEG_EXACT	MESS(1803, "in x**y or y root x, x is negative and y is not exact")
X
X/* i2exp.c, i2fix.c, i2tes.c */
X
X#define PRIO		MESS(1804, "ambiguous expression; please use ( and ) to resolve")
X#define NO_EXPR		MESS(1805, "no expression where expected")
X#define NO_TEST		MESS(1806, "no test where expected")
X#define UPTO_EXPR 	MESS(1807, "something unexpected in expression")
X#define UPTO_TEST 	MESS(1808, "something unexpected in test")
X#define NO_TRIM_TARG	MESS(1809, "misformed address")
X
X/* i2gen.c, i2fix.c */
X
X#define NO_INIT_OR_DEF	MESS(1810, "%s hasn't been initialised or (properly) defined")
X#define NO_DEFINITION	MESS(1811, "%s hasn't been (properly) defined")
X
X/* i3in2.c */
X
X#define NO_VALUE	MESS(1812, "%s has not yet received a value")
X
X/* i2gen.c, i3int.c */
X
X#define YIELD_NO_RETURN	MESS(1813, "function returns no value")
X#define TEST_NO_REPORT	MESS(1814, "predicate reports no outcome")
X
X/* i2gen.c, i2ana.c */
X
X#define REF_NO_TARGET	MESS(1815, "a refinement may not be used as an address")
X#define BAD_WHILE	MESS(1816, "bad node in while")
X#define BAD_TESTSUITE	MESS(1817, "bad node in testsuite")
X
X/* i2cmd.c, i2uni.c */
X#define WRONG_INDENT	MESS(1818, "indentation not used consistently")
X#define SMALL_INDENT	MESS(1819, "indentation must be at least 2")
X
X/* i3loc.c, i3sta.c */
X
X#define SEL_NO_TABLE	MESS(1820, "selection on non-table")
END_OF_FILE
  if test 1676 -ne `wc -c <'abc/ihdrs/i0err.h'`; then
    echo shar: \"'abc/ihdrs/i0err.h'\" unpacked with wrong size!
  fi
  # end of 'abc/ihdrs/i0err.h'
fi
if test -f 'abc/ihdrs/i3sou.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ihdrs/i3sou.h'\"
else
  echo shar: Extracting \"'abc/ihdrs/i3sou.h'\" \(1597 characters\)
  sed "s/^X//" >'abc/ihdrs/i3sou.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1987. */
X
X#define p_exists(pname, aa)	(in_env(b_perm, pname, aa))
X#define def_perm(pname, f)	(e_replace(f, &b_perm, pname), permchanges= Yes)
X#define free_perm(pname)	(e_delete(&b_perm, pname), permchanges= Yes)
X
X#define u_exists(pname, aa)	(in_env(b_units, pname, aa))
X#define def_unit(pname, u)	(e_replace(u, &b_units, pname))
X#define free_unit(pname)	(e_delete(&b_units, pname))
X
Xextern value b_perm;
Xextern bool permchanges;
Xextern value b_units;
Xextern value last_unit;
Xextern value last_target;
X
X#define Permname(pname) (behead(pname, MkSmallInt(2)))
X#define Permtype(pname) (strval(pname)[0])
X	/* possible types:
X	 *	1-8 [Cmd ... Tar]	(order used in mac/m1print.c!)
X	 *	: [last_unit]
X	 *	= [last_target]
X	 */
X
X#define Cmd '1'
X#define Zfd '2'
X#define Mfd '3'
X#define Dfd '4'
X#define Zpd '5'
X#define Mpd '6'
X#define Dpd '7'
X#define Tar '8'
X#define OldHow '+'	/* old how-to type (used in bio) */
X#define OldTar '-'	/* old target type (used in bio) */
X#define Wsp '.'		/* workspace type */
X
X#define	Cmd_ext ".cmd"
X#define Zfd_ext ".zfd"
X#define Mfd_ext ".mfd"
X#define Dfd_ext ".dfd"
X#define Zpd_ext ".zpd"
X#define Mpd_ext ".mpd"
X#define Dpd_ext ".dpd"
X#define Cts_ext ".cts"
X#define Wsp_ext ""
X
Xvalue permkey();
Xvalue get_pname();
Xvalue getval();
X
Xvalue new_fname();		/* devise a filename for a unit or target */
Xvalue mkabcname();		/* vice versa for recovering target name */
X#define CONVP_SIGN '_'		/* to map point */
X#define CONVDQ_SIGN '@'		/* to map double quote */
X
Xbool is_udfpr();		/* REPORT is user defined func or predic */
END_OF_FILE
  if test 1597 -ne `wc -c <'abc/ihdrs/i3sou.h'`; then
    echo shar: \"'abc/ihdrs/i3sou.h'\" unpacked with wrong size!
  fi
  # end of 'abc/ihdrs/i3sou.h'
fi
if test -f 'abc/keys/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/keys/Makefile'\"
else
  echo shar: Extracting \"'abc/keys/Makefile'\" \(2193 characters\)
  sed "s/^X//" >'abc/keys/Makefile' <<'END_OF_FILE'
X#
X# Makefile for ../abckeys.
X#
X# This is intended to be used through ../Makefile, where several
X# generic macro's are filled in.
X# The following macro's are more specific and should be changed here
X# in case you have to make very drastic changes.
X
X# --- Include flags to the C compiler ---
X
XKINCL=	-I../bhdrs -I../ehdrs -I../uhdrs
X
X# --- Include flags for lint ---
X
XLKINCL=		$(KINCL)
X
X# --- Relevant files ---
X
XOBJS=	keydef.o keyhlp.o \
X	e1getc.o \
X	b1file.o b1memo.o b1mess.o getopt.o b1outp.o \
X	u1file.o u1keys.o u1trm.o u1dir.o
X
XSRCS=	keydef.c keyhlp.c \
X	../bed/e1getc.c \
X	../b/b1file.c ../b/b1memo.c ../b/b1mess.c ../b/getopt.c ../b/b1outp.c \
X	../unix/u1file.c ../unix/u1keys.c ../unix/u1trm.c ../unix/u1dir.c
X
XHDRS=	keydef.h \
X	../bhdrs/b.h ../bhdrs/bfil.h ../bhdrs/bmem.h \
X	../bhdrs/bobj.h ../bhdrs/getopt.h \
X	../ehdrs/getc.h ../ehdrs/keys.h ../ehdrs/trm.h \
X	../uhdrs/osgen.h ../uhdrs/feat.h ../uhdrs/defs.h
X
X# --- Main entries of the makefile ---
X
Xall:	../abckeys
X
X../abckeys: $(OBJS)
X	$(CC) $(LDFLAGS) $(OBJS) $(LIBS) -o ../abckeys
X
Xkeydef.o: keydef.c
X	$(CC) -c $(CFLAGS) -DKEYS $(KINCL) keydef.c
X
Xkeyhlp.o: keyhlp.c
X	$(CC) -c $(CFLAGS) -DKEYS $(KINCL) keyhlp.c
X
Xe1getc.o: ../bed/e1getc.c
X	$(CC) -c $(CFLAGS) -DKEYS $(KINCL) ../bed/e1getc.c
X
Xgetopt.o: ../b/getopt.c
X	$(CC) -c $(CFLAGS) -DKEYS $(KINCL) ../b/getopt.c
X
Xb1file.o: ../b/b1file.c
X	$(CC) -c $(CFLAGS) -DKEYS $(KINCL) ../b/b1file.c
X
Xb1memo.o: ../b/b1memo.c
X	$(CC) -c $(CFLAGS) -DKEYS $(KINCL) ../b/b1memo.c
X
Xb1mess.o: ../b/b1mess.c
X	$(CC) -c $(CFLAGS) -DKEYS $(KINCL) ../b/b1mess.c
X
Xb1outp.o: ../b/b1outp.c
X	$(CC) -c $(CFLAGS) -DKEYS $(KINCL) ../b/b1outp.c
X
Xu1file.o: ../unix/u1file.c
X	$(CC) -c $(CFLAGS) -DKEYS $(KINCL) ../unix/u1file.c
X
Xu1keys.o: ../unix/u1keys.c
X	$(CC) -c $(CFLAGS) -DKEYS $(KINCL) ../unix/u1keys.c
X
Xu1trm.o: ../unix/u1trm.c
X	$(CC) -c $(CFLAGS) -DKEYS $(KINCL) ../unix/u1trm.c
X
Xu1dir.o: ../unix/u1dir.c
X	$(CC) -c $(CFLAGS) -DKEYS $(KINCL) ../unix/u1dir.c
X
X# --- Utilities for the programmer ---
X
Xdepend:
X	@$(MKDEP) $(DEFS) $(KINCL) $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(DEFS) -DKEYS $(LKINCL) $(SRCS)
X
XALWAYS:	#dummy
X
X###
X# Dependency information is taken from ./Dep or ./DEP; see ../Makefile.
X###
END_OF_FILE
  if test 2193 -ne `wc -c <'abc/keys/Makefile'`; then
    echo shar: \"'abc/keys/Makefile'\" unpacked with wrong size!
  fi
  # end of 'abc/keys/Makefile'
fi
if test -f 'abc/keys/keydef.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/keys/keydef.h'\"
else
  echo shar: Extracting \"'abc/keys/keydef.h'\" \(1324 characters\)
  sed "s/^X//" >'abc/keys/keydef.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1989. */
X
Xstring reprchar();
X
X/****************************************************************************/
X
X#define ABC_RELEASE "ABC Release %s."
X#define COPYRIGHT "Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1989."
X#define HEADING "This program allows you to redefine the key bindings for the ABC editor operations, producing a key definitions file."
X
X/****************************************************************************/
X
X#define E_INTERRUPT	"*** Your interrupt character is undefined."
X
X#ifdef CANSUSPEND
X
X#define E_SPCHAR	"*** You cannot include your interrupt or suspend character."
X
X#else
X
X#define E_SPCHAR	"*** You cannot include your interrupt character."
X
X#endif /* CANSUSPEND */
X
X#define E_ILLEGAL	"*** You are not allowed to start a definition with '%c' since that would make that character unavailable."
X
X#define E_TOO_MANY 	"*** Sorry, can't remember more key definitions"
X
X#define E_UNLAWFUL	"*** It may not contain an unprintable character"
X
X#define E_IN_USE	"*** That representation is in use for %s."
X
X#define E_UNKNOWN	"*** unknown operation name"
X
X#define E_NOTALLOWED	"*** you are not allowed to change \"%s\""
X
X#define E_KEYFILE	"*** Can't open key definitions file %s for writing; writing to standard output instead."
END_OF_FILE
  if test 1324 -ne `wc -c <'abc/keys/keydef.h'`; then
    echo shar: \"'abc/keys/keydef.h'\" unpacked with wrong size!
  fi
  # end of 'abc/keys/keydef.h'
fi
if test -f 'abc/tc/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/tc/README'\"
else
  echo shar: Extracting \"'abc/tc/README'\" \(1294 characters\)
  sed "s/^X//" >'abc/tc/README' <<'END_OF_FILE'
Xtermcap - terminal capabilities, library and database.
X
XThe routines provided by the library 'libtermcap.a' extract and use
Xcapabilities from the terminal database 'termcap'.
X
XIt is included in the Mark 2 distribution of ABC because the ABC editor
Xuses it, it is in the public domain, and there are UNIXes without it.
XIf '../Setup' finds the termcap in your system it uses that one.
X
XIf you don't have termcap available on your system the best thing to do
Xis to install it and run ../Setup again.
X
X	make DEST=/usr/lib ETC=/etc install
X
Xwill install the library and database at their usual places.  If these
Xare different on your system you will probably have to change pathnames
Xin the sources too. The files tc?.c test out the library routines.
XDon't forget to copy the manual pages from termcap.3X and termcap.5
Xto your systems manual.
X
XFor more information consult those manual pages.
X
XFor any program to work with termcap, the user should set the $TERM and
X$TERMCAP environment variables in her profile. You can also install
Xabc and abckeys as shell scripts, calling the executable binaries after
Xsetting these, e.g. for abc:
X	
X	: set TERMCAP environment variable
X	: ${TERMCAP=$ABC_LIB/termcap}
X	export TERMCAP
X	exec /usr/new/lib/abc/abc.exe
X
Xif the latter is the name you gave the binary.
END_OF_FILE
  if test 1294 -ne `wc -c <'abc/tc/README'`; then
    echo shar: \"'abc/tc/README'\" unpacked with wrong size!
  fi
  # end of 'abc/tc/README'
fi
if test -f 'abc/tc/tc3.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/tc/tc3.c'\"
else
  echo shar: Extracting \"'abc/tc/tc3.c'\" \(1303 characters\)
  sed "s/^X//" >'abc/tc/tc3.c' <<'END_OF_FILE'
X/*
X * tc3 [term]
X * Dummy program to test out termlib.
X * Input two numbers and it prints out the tgoto string generated.
X */
X#include <stdio.h>
Xchar buf[1024];
Xchar *getenv(), *tgetstr();
Xchar *rdchar();
Xchar *tgoto();
Xchar *CM;
Xchar cmbuff[30];
Xchar *x;
Xchar *UP;
Xchar *tgout;
X
Xmain(argc, argv) char **argv; {
X	char *p;
X	int rc;
X	int row, col;
X
X	if (argc < 2)
X		p = getenv("TERM");
X	else
X		p = argv[1];
X	rc = tgetent(buf,p);
X	x = cmbuff;
X	UP = tgetstr("up", &x);
X	printf("UP = %x = ", UP); pr(UP); printf("\n");
X	if (UP && *UP==0)
X		UP = 0;
X	CM = tgetstr("cm", &x);
X	printf("CM = "); pr(CM); printf("\n");
X	for (;;) {
X		if (scanf("%d %d", &row, &col) < 2)
X			exit(0);
X		tgout = tgoto(CM, row, col);
X		pr(tgout);
X		printf("\n");
X	}
X}
X
Xpr(p)
Xregister char *p;
X{
X	for (; *p; p++)
X		printf("%s", rdchar(*p));
X}
X
X/*
X * rdchar: returns a readable representation of an ASCII char, using ^ notation.
X */
X#include <ctype.h>
Xchar *rdchar(c)
Xchar c;
X{
X	static char ret[4];
X	register char *p;
X
X	/*
X	 * Due to a bug in isprint, this prints spaces as ^`, but this is OK
X	 * because we want something to show up on the screen.
X	 */
X	ret[0] = ((c&0377) > 0177) ? '\'' : ' ';
X	c &= 0177;
X	ret[1] = isprint(c) ? ' ' : '^';
X	ret[2] = isprint(c) ?  c  : c^0100;
X	ret[3] = 0;
X	for (p=ret; *p==' '; p++)
X		;
X	return (p);
X}
END_OF_FILE
  if test 1303 -ne `wc -c <'abc/tc/tc3.c'`; then
    echo shar: \"'abc/tc/tc3.c'\" unpacked with wrong size!
  fi
  # end of 'abc/tc/tc3.c'
fi
if test -f 'abc/uhdrs/feat.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/uhdrs/feat.h'\"
else
  echo shar: Extracting \"'abc/uhdrs/feat.h'\" \(1433 characters\)
  sed "s/^X//" >'abc/uhdrs/feat.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X/*
X * -- #define features, to make it easy to turn them off.
X */
X
X#define SAVEBUF		/* Save Copy Buffer on file between edit sessions */
X#define USERSUGG	/* Give suggestions for user-defined commands */
X#define SAVEPOS		/* Save focus position between edit sessions */
X#define RECORDING	/* [record] and [playback] commands */
X#define SCROLLBAR	/* Show scroll bar if unit > screen */
X#define SHOWBUF		/* Shows contents of copy buffer if locked */
X#define HELPFUL		/* Print help blurb on ESC-? or ? */
X#define GOTOCURSOR	/* enable [goto] operation */
X
X#ifdef SMALLSYS
X/*
X * The #define SMALLSYS squeezes out some lesser important debugging
X * code. Moreover you can #undef here some of the above mentioned features.
X * They are roughly sorted on amount of code saved, greatest
X * saving first.
X */
X
X#undef SAVEBUF
X#undef USERSUGG
X#undef SAVEPOS
X#undef RECORDING
X#undef SCROLLBAR
X#undef SHOWBUF
X#undef HELPFUL
X#undef GOTOCURSOR
X
X#endif /* SMALLSYS */
X
X#define CANSUSPEND	/* Can suspend abc? */
X#define STRUCTASS	/* C compiler knows structure assignment */
X
X#define	EXT_RANGE	/* extend range of approximate arithmetic */
X#define	TYPE_CHECK	/* do static type checking */
X#undef	CLEAR_MEM	/* remove internal adm. before editing a howto */
X#undef	SAVE_PERM	/* write perm env after each edit */
X
X#define TTY_ERRFILE	/* redirect error output from interpreter to /dev/tty */
END_OF_FILE
  if test 1433 -ne `wc -c <'abc/uhdrs/feat.h'`; then
    echo shar: \"'abc/uhdrs/feat.h'\" unpacked with wrong size!
  fi
  # end of 'abc/uhdrs/feat.h'
fi
if test -f 'abc/uhdrs/os.h.gen' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/uhdrs/os.h.gen'\"
else
  echo shar: Extracting \"'abc/uhdrs/os.h.gen'\" \(2433 characters\)
  sed "s/^X//" >'abc/uhdrs/os.h.gen' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X/* Operating system dependent ABC configuration */
X
X#include <math.h>	/* mathematical library, see math(3) */
X#include <ctype.h>	/* character classifications, see ctype(3) */
X#include <strings.h>	/* string operations, like strlen(), see string(3) */
X#include <sys/types.h>	/* basic system types, see stat(2) */
X#include <sys/stat.h>	/* file status, see stat(2) */
X#include <sys/file.h>	/* for access(2) modes, like R_OK; only used below */
X
X#define VOID (void)	/* VOID is used in casts only, for quieter lint */
X			/* make it empty if your compiler doesn't have void */
X
X#define SIGNAL		/* can #include <signal.h> (v7 or any BSD compatible) */
X#define SIGTYPE int	/* type returned by signal handler function */
X
X#define SETJMP		/* can #include <setjmp.h> */
X
X#define Interrupted() interrupted
X
X#define DELIM '/'
X#define SIZE_PATH 1024
X
X#define SEPARATOR '/'
X#define CURDIR "."
X#define PARENTDIR ".."
X
X#define Issep(c) ((c) == SEPARATOR)
X#define Isanysep(c) Issep(c)
X#define Isabspath(path) Issep(*(path))
X
X#define F_readable(f)	(access(f, R_OK) == 0)
X#define F_writable(f)	(access(f, W_OK) == 0)
X#define F_exists(f)	(access(f, F_OK) == 0)
X#define D_exists(f)	(access(f, F_OK) == 0)
X
X#define DIRMODE 0777
X#define Mkdir(path)	(mkdir(path, DIRMODE))
X
X#define KEYSPREFIX "abckeys_" /* only set for unix */
X
X#ifdef KEYS
X
X#define NEWFILE		"abc.key"
X	/* default name for new keydefinitions file */
X
X#define Eok(c) ((c) == '\r')
X	/* return character of user key sequence */
X
X#undef KNOWN_KEYBOARD
X	/* do we know the keyboard codes ? */
X
X#undef NULL_EXTENDED
X	/* keyboard extended codes start with a null char */
X
X#endif /* KEYS */
X
X/***************** code only for unix systems ***************************/
X
X#define strchr index    /* use index for strchr */
X#define strrchr rindex  /* and rindex for strrchr */
X
X#undef  TERMIO		/* is this a termio system */
X
X#define HAS_FTIME	/* ftime() and <sys/timeb.h> available */
X#define HAS_PERROR	/* can use sys_errlist and sys_nerr (from perror(3)) */
X#define HAS_MKDIR	/* mkdir() and rmdir() available */
X#define HAS_GETWD	/* getwd() available */
X#define HAS_RENAME	/* rename() available */
X#define HAS_SELECT	/* 4.2 BSD select() system call available */
X#define HAS_READDIR	/* Berkeley style directory reading routines */
X			/* opendir(), readdir() and closedir(); */
X			/* see directory(3), or ../unix/u1dir.c and ./dir.h */
END_OF_FILE
  if test 2433 -ne `wc -c <'abc/uhdrs/os.h.gen'`; then
    echo shar: \"'abc/uhdrs/os.h.gen'\" unpacked with wrong size!
  fi
  # end of 'abc/uhdrs/os.h.gen'
fi
if test -f 'abc/unix/DEP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/unix/DEP'\"
else
  echo shar: Extracting \"'abc/unix/DEP'\" \(1764 characters\)
  sed "s/^X//" >'abc/unix/DEP' <<'END_OF_FILE'
Xu1dir.o: u1dir.c
Xu1dir.o: ../bhdrs/b.h
Xu1dir.o: ../uhdrs/osconf.h
Xu1dir.o: ../uhdrs/os.h
Xu1dir.o: ../uhdrs/conf.h
Xu1dir.o: ../uhdrs/config.h
Xu1edit.o: u1edit.c
Xu1edit.o: ../bhdrs/b.h
Xu1edit.o: ../uhdrs/osconf.h
Xu1edit.o: ../uhdrs/os.h
Xu1edit.o: ../uhdrs/conf.h
Xu1edit.o: ../uhdrs/config.h
Xu1edit.o: ../bhdrs/bfil.h
Xu1file.o: u1file.c
Xu1file.o: ../bhdrs/b.h
Xu1file.o: ../uhdrs/osconf.h
Xu1file.o: ../uhdrs/os.h
Xu1file.o: ../uhdrs/conf.h
Xu1file.o: ../uhdrs/config.h
Xu1file.o: ../bhdrs/bmem.h
Xu1file.o: ../uhdrs/dest.h
Xu1file.o: ../bhdrs/bfil.h
Xu1keys.o: u1keys.c
Xu1keys.o: ../bhdrs/b.h
Xu1keys.o: ../uhdrs/osconf.h
Xu1keys.o: ../uhdrs/os.h
Xu1keys.o: ../uhdrs/conf.h
Xu1keys.o: ../uhdrs/config.h
Xu1keys.o: ../uhdrs/feat.h
Xu1keys.o: ../bhdrs/bmem.h
Xu1keys.o: ../ehdrs/getc.h
Xu1keys.o: ../ehdrs/keys.h
Xu1keys.o: ../uhdrs/args.h
Xu1main.o: u1main.c
Xu1main.o: ../bhdrs/b.h
Xu1main.o: ../uhdrs/osconf.h
Xu1main.o: ../uhdrs/os.h
Xu1main.o: ../uhdrs/conf.h
Xu1main.o: ../uhdrs/config.h
Xu1main.o: ../bhdrs/bmem.h
Xu1main.o: ../bhdrs/bfil.h
Xu1main.o: ../bhdrs/getopt.h
Xu1main.o: ../ihdrs/i3bws.h
Xu1os.o: u1os.c
Xu1os.o: ../bhdrs/b.h
Xu1os.o: ../uhdrs/osconf.h
Xu1os.o: ../uhdrs/os.h
Xu1os.o: ../uhdrs/conf.h
Xu1os.o: ../uhdrs/config.h
Xu1os.o: ../uhdrs/feat.h
Xu1sig.o: u1sig.c
Xu1sig.o: ../bhdrs/b.h
Xu1sig.o: ../uhdrs/osconf.h
Xu1sig.o: ../uhdrs/os.h
Xu1sig.o: ../uhdrs/conf.h
Xu1sig.o: ../uhdrs/config.h
Xu1sig.o: ../uhdrs/feat.h
Xu1time.o: u1time.c
Xu1time.o: ../bhdrs/b.h
Xu1time.o: ../uhdrs/osconf.h
Xu1time.o: ../uhdrs/os.h
Xu1time.o: ../uhdrs/conf.h
Xu1time.o: ../uhdrs/config.h
Xu1time.o: ../bhdrs/bobj.h
Xu1time.o: ../ihdrs/i1num.h
Xu1trm.o: u1trm.c
Xu1trm.o: ../bhdrs/b.h
Xu1trm.o: ../uhdrs/osconf.h
Xu1trm.o: ../uhdrs/os.h
Xu1trm.o: ../uhdrs/conf.h
Xu1trm.o: ../uhdrs/config.h
Xu1trm.o: ../ehdrs/trm.h
END_OF_FILE
  if test 1764 -ne `wc -c <'abc/unix/DEP'`; then
    echo shar: \"'abc/unix/DEP'\" unpacked with wrong size!
  fi
  # end of 'abc/unix/DEP'
fi
if test -f 'abc/unix/u1dir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/unix/u1dir.c'\"
else
  echo shar: Extracting \"'abc/unix/u1dir.c'\" \(2268 characters\)
  sed "s/^X//" >'abc/unix/u1dir.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X/* This is slightly edited from a public domain version */
X
X#include "b.h"
X
X#ifndef HAS_MKDIR
X
X/* mkdir - Make a directory */
X
XVisible int mkdir(dir, mode) char *dir; int mode; {
X	char buf[1024];
X
X	sprintf(buf, "(mkdir %s && chmod %o %s) >/dev/null 2>/dev/null",
X			dir, mode, dir);
X	return(system(buf));
X}
X
X/* rmdir - remove directory */
X
XVisible Procedure rmdir(dir) char *dir; {
X	char buf[1024];
X
X	sprintf(buf, "rmdir %s >/dev/null 2>/dev/null", dir);
X	return(system(buf));
X}
X
X#endif /* !HAS_MKDIR */
X
X#ifndef HAS_READDIR
X
X#include "dir.h"
X
X/*
X * support for Berkeley directory reading routines
X * on a VERSION7 or ATT file system
X */
X
X/* open a directory */
X
XVisible DIR *opendir(name) char *name; {
X	register DIR *dirp;
X	register int fd;
X	char *malloc();
X
X	if ((fd = open(name, 0)) == -1)
X		return NULL;
X	if ((dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
X		close (fd);
X		return NULL;
X	}
X	dirp->dd_fd = fd;
X	dirp->dd_loc = 0;
X	return dirp;
X}
X
X/* read an old style directory entry and present it as a new one */
X#ifndef pyr
X#define	ODIRSIZ	14
X
Xstruct	olddirect {
X	ino_t	od_ino;
X	char	od_name[ODIRSIZ];
X};
X#else	/* a Pyramid in the ATT universe */
X#define	ODIRSIZ	248
X
Xstruct	olddirect {
X	long	od_ino;
X	short	od_fill1, od_fill2;
X	char	od_name[ODIRSIZ];
X};
X#endif
X
X/* get next entry in a directory */
X
XVisible struct direct *readdir(dirp) register DIR *dirp; {
X	register struct olddirect *dp;
X	static struct direct dir;
X
X	for (;;) {
X		if (dirp->dd_loc == 0) {
X			dirp->dd_size = read(dirp->dd_fd, dirp->dd_buf,
X			    DIRBLKSIZ);
X			if (dirp->dd_size <= 0)
X				return NULL;
X		}
X		if (dirp->dd_loc >= dirp->dd_size) {
X			dirp->dd_loc = 0;
X			continue;
X		}
X		dp = (struct olddirect *)(dirp->dd_buf + dirp->dd_loc);
X		dirp->dd_loc += sizeof(struct olddirect);
X		if (dp->od_ino == 0)
X			continue;
X		dir.d_ino = dp->od_ino;
X		strncpy(dir.d_name, dp->od_name, ODIRSIZ);
X		dir.d_name[ODIRSIZ] = '\0'; /* insure null termination */
X		dir.d_namlen = strlen(dir.d_name);
X		dir.d_reclen = DIRSIZ(&dir);
X		return (&dir);
X	}
X}
X
X/* close a directory */
X
XVisible Procedure closedir(dirp) register DIR *dirp; {
X	close(dirp->dd_fd);
X	dirp->dd_fd = -1;
X	dirp->dd_loc = 0;
X	free(dirp);
X}
X
X#endif /* !HAS_READDIR */
END_OF_FILE
  if test 2268 -ne `wc -c <'abc/unix/u1dir.c'`; then
    echo shar: \"'abc/unix/u1dir.c'\" unpacked with wrong size!
  fi
  # end of 'abc/unix/u1dir.c'
fi
if test -f 'abc/unix/u1time.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/unix/u1time.c'\"
else
  echo shar: Extracting \"'abc/unix/u1time.c'\" \(1237 characters\)
  sed "s/^X//" >'abc/unix/u1time.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1989. */
X
X#include "b.h"
X#include "bobj.h"
X#include "i1num.h"
X
X#include <time.h>
X
X#ifdef HAS_FTIME	/* Berkeley */
X
X#include <sys/timeb.h>
X
XVisible value nowisthetime() {
X	struct tm *lt;
X	struct timeb tt;
X	value now;
X	value millisecs;
X	value thousand;
X	
X	ftime(&tt);
X	lt= localtime((long*) &tt.time);
X	
X	now= mk_compound(6);
X
X	*Field(now, 0)= mk_integer(lt->tm_year + 1900);
X	*Field(now, 1)= mk_integer(lt->tm_mon + 1);
X	*Field(now, 2)= mk_integer(lt->tm_mday);
X	*Field(now, 3)= mk_integer(lt->tm_hour);
X	*Field(now, 4)= mk_integer(lt->tm_min);
X	millisecs= mk_integer((int) (lt->tm_sec * 1000 + tt.millitm));
X	thousand= mk_integer(1000);
X	*Field(now, 5)= mk_exact(millisecs, thousand, 3);
X	release(millisecs); release(thousand);
X	return now;
X}
X
X#else
X
XVisible value nowisthetime() {
X	long ttt;
X	struct tm *lt;
X	value now;
X	
X	ttt= time((long*)0);
X	lt= localtime(&ttt);
X	
X	now= mk_compound(6);
X
X	*Field(now, 0)= mk_integer(lt->tm_year + 1900);
X	*Field(now, 1)= mk_integer(lt->tm_mon + 1);
X	*Field(now, 2)= mk_integer(lt->tm_mday);
X	*Field(now, 3)= mk_integer(lt->tm_hour);
X	*Field(now, 4)= mk_integer(lt->tm_min);
X	*Field(now, 5)= mk_integer(lt->tm_sec);
X	
X	return now;
X}
X
X#endif
END_OF_FILE
  if test 1237 -ne `wc -c <'abc/unix/u1time.c'`; then
    echo shar: \"'abc/unix/u1time.c'\" unpacked with wrong size!
  fi
  # end of 'abc/unix/u1time.c'
fi
echo shar: End of archive 23 \(of 25\).
cp /dev/null ark23isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0 # Just in case...
