Subject:  v23i101:  ABC interactive programming environment, Part22/25
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 533435ee 634a895b 374c7342 db43f9b7

Submitted-by: Steven Pemberton <steven@cwi.nl>
Posting-number: Volume 23, Issue 101
Archive-name: abc/part22

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  abc/b/b1memo.c abc/b/b1mess.c abc/bhdrs/b.h
#   abc/bhdrs/b0lan.h abc/bint1/i1nut.c abc/bint2/DEP
#   abc/bint3/i3com.c abc/bint3/i3imm.c abc/bint3/i3in2.c
#   abc/bint3/i3ini.c abc/boot/main.h abc/ehdrs/keys.h
#   abc/ehdrs/node.h abc/keys/DEP abc/stc/i2stc.h abc/tc/tputs.c
# Wrapped by rsalz@litchi.bbn.com on Mon Dec 17 13:28:23 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 22 (of 25)."'
if test -f 'abc/b/b1memo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/b/b1memo.c'\"
else
  echo shar: Extracting \"'abc/b/b1memo.c'\" \(2602 characters\)
  sed "s/^X//" >'abc/b/b1memo.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/* general memory handling */
X
X#include "b.h"
X#include "bmem.h"
X
Xchar *malloc();
Xchar *realloc();
X
XVisible ptr getmem(syze) unsigned syze; {
X	ptr p= (ptr) malloc(syze);
X	if (p == Nil) memexh();
X#ifdef MEMTRACE
X	writetrace(F_ALLOC, p, syze);
X#endif
X	return p;
X}
X
XVisible Procedure regetmem(v, syze) ptr *v; unsigned syze; {
X	ptr p= (ptr) realloc(*v, syze);
X	if (p == Nil) memexh();
X#ifdef MEMTRACE
X	writetrace(F_FREE, *v, 0);
X	writetrace(F_ALLOC, p, syze);
X#endif
X	*v= p;
X}
X
XVisible Procedure freemem(p) ptr p; {
X#ifdef MEMTRACE
X	writetrace(F_FREE, p, 0);
X#endif
X	free((char *)p);
X}
X
XVisible ptr savestr(s) char *s; {
X	ptr p= (ptr) getmem((unsigned) strlen(s) + 1);
X	strcpy(p, s);
X	return p;
X}
X
X#ifdef MEMTRACE
X
X/*
X * to fix memory that surely won't be free'd
X */
XVisible Procedure fixmem(p) ptr p; {
X	writetrace(F_FREE, p, 0);
X}
X
Xextern FILE *memfp;	/* set in ??main.c */
X
Xwritetrace(flag, p, size) int flag; ptr *p; unsigned size; {
X	address *frameptr;
X	
X	if (memfp == NULL)
X		return;
X	fwrite(&flag, sizeof(int), 1, memfp);
X	fwrite(&p, sizeof(ptr), 1, memfp);
X	fwrite(&size, sizeof(unsigned), 1, memfp);
X	
X	frameptr= (unsigned*) &flag - 1; 
X	frameptr= (unsigned*) *frameptr;	/* skip getmem or freemem */
X	do {
X		/* dump PC */
X		fwrite((char*)(frameptr-2), sizeof(address), 1, memfp);
X		/* follow FP */
X		frameptr= (unsigned*) *frameptr;
X	} while (*frameptr);
X	fwrite((char*)frameptr, sizeof(address), 1, memfp);
X}
X
X#endif /*MEMTRACE*/
X
X/************************************************************************/
X
X#define BUFINCR 100
X
XVisible Procedure bufinit(bp) bufadm *bp; {
X	bp->buf= (char *) getmem((unsigned) BUFINCR);
X	bp->ptr= bp->buf;
X	bp->end= bp->buf + BUFINCR;
X	*(bp->ptr)= '\0';
X}
X
XVisible Procedure buffree(bp) bufadm *bp; {
X	freemem((ptr) bp->buf);
X}
X
XVisible Procedure bufreinit(bp) bufadm *bp; {
X	buffree(bp);
X	bufinit(bp);
X}
X
XVisible Procedure bufgrow(bp) bufadm *bp; {
X	int n_ptr= bp->ptr - bp->buf;
X	int syze= (bp->end - bp->buf) + BUFINCR;
X	
X	regetmem((ptr *) &(bp->buf), (unsigned) syze);
X	bp->ptr= bp->buf + n_ptr;
X	bp->end= bp->buf + syze;
X}
X
XVisible Procedure bufpush(bp, c) bufadm *bp; char c; {
X	if (bp->ptr >= bp->end)
X		bufgrow(bp);
X	*(bp->ptr)++= c;
X}
X
XVisible Procedure bufcpy(bp, s) bufadm *bp; char *s; {
X	int len= strlen(s);
X
X	while (bp->ptr + len >= bp->end)
X		bufgrow(bp);
X	strcpy(bp->ptr, s);
X	bp->ptr+= len;
X}
X
XVisible Procedure bufncpy(bp, s, len) bufadm *bp; char *s; int len; {
X	while (bp->ptr + len >= bp->end)
X		bufgrow(bp);
X	strncpy(bp->ptr, s, len);
X	bp->ptr+= len;
X	*(bp->ptr)= '\0';
X}
END_OF_FILE
  if test 2602 -ne `wc -c <'abc/b/b1memo.c'`; then
    echo shar: \"'abc/b/b1memo.c'\" unpacked with wrong size!
  fi
  # end of 'abc/b/b1memo.c'
fi
if test -f 'abc/b/b1mess.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/b/b1mess.c'\"
else
  echo shar: Extracting \"'abc/b/b1mess.c'\" \(3072 characters\)
  sed "s/^X//" >'abc/b/b1mess.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/* B error message handling */
X
X/* All error messages are collected in a file, both to save data space
X   and to ease translation to other languages.	The English version
X   of the database can be recreated from the program sources by scanning
X   for the pattern "MESS".  This is a macro whose first argument is
X   the message number and whose second number is the message string;
X   this macro expands to only the message number which is passed to
X   the error routines.	The error routines then dig the message from
X   the error message file, or just print the number if the file can't be
X   opened.  There is also a way to pass a message that is determined
X   at runtime.
X*/
X
X#include "b.h"
X#include "bfil.h"
X#include "bmem.h"
X#include "bobj.h"
X
X/* While we are reading the Messages file, we build an index.
X   probe[k] contains the first message number found in block k.
X   blocks are BUFSIZ in size. */
X
X#define FILESIZE 22454 /* Approximated current size of Messages file */
X#define MAXPROBE (10 + FILESIZE/BUFSIZ) /* Allow some growth */
X
XHidden short probe[MAXPROBE];
XHidden int nprobes= 1;
X
X#define NOT_OPENED ((FILE*)(-1))
X#define NO_MESSFILE "*** Cannot find or read messages file; using numbers\n"
XHidden FILE *messfp= NOT_OPENED;
X
Xchar *messbuf; /* used for messages with arguments */
XHidden char buf[MESSBUFSIZE];
X
XVisible string getmess(nr) int nr;  {
X	int last, c; char *cp= NULL;
X	bool new; int block; long ftell();
X	static int last_nr= 0;
X
X	if (nr <= 0) 
X		return nr == -1 ? "%s" : nr == -2 ? "%s%s" : "";
X	if (messfp == NOT_OPENED) {
X		if (messfile)
X			messfp= fopen(messfile, "r");
X		else
X			messfp= NULL;
X		if (messfp == NULL) {
X			fflush(stdout);
X			putstr(errfile, NO_MESSFILE);
X			fflush(errfile);
X		}
X	}
X	if (nr == last_nr) {
X		cp= strchr(buf, '\t');
X		if (cp != NULL)
X		    return cp+1;
X	}
X	if (messfp) {
X		for (block= nprobes-1; block > 0; --block) {
X			if (probe[block] <= nr)
X				break;
X		}
X		new= block == nprobes-1;
X		fseek(messfp, (long)block*BUFSIZ, 0);
X		last= 0;
X		while (last < nr) {
X			if (new) block= ftell(messfp) / BUFSIZ;
X			cp= buf;
X			while ((c= getc(messfp)) != EOF && c != '\n') {
X				if (cp >= buf + MESSBUFSIZE - 2) break;
X				if (c != '\\')
X					*cp= c;
X				else {
X					c= getc(messfp);
X					if (c == EOF || c == '\n') break;
X					switch (c) {
X					case 'n': *cp= '\n'; break;
X					case 'r': *cp= '\r'; break;
X					case 't': *cp= '\t'; break;
X					case 'b': *cp= '\b'; break;
X					default: *cp++= '\\'; *cp= c; break;
X					}
X				}
X				cp++;
X			}
X			*cp= '\0';
X			if (c == EOF) break;
X			last= atoi(buf);
X			if (last <= 0)
X				continue;
X			if (new && block >= nprobes && nprobes < MAXPROBE) {
X				probe[block]= last;
X				nprobes= block+1;
X			}
X		}
X		if (last == nr) {
X			cp= strchr(buf, '\t');
X			if (cp != NULL) {
X				last_nr= nr;
X				return cp+1;
X			}
X		}
X	}
X	sprintf(buf, " (message %d) ", nr);
X	last_nr= 0;
X	return buf;
X}
X
XVisible Procedure initmess() {
X	messbuf= (char*) getmem(MESSBUFSIZE);
X}
X
XVisible Procedure endmess() {
X	freemem((ptr) messbuf);
X}
END_OF_FILE
  if test 3072 -ne `wc -c <'abc/b/b1mess.c'`; then
    echo shar: \"'abc/b/b1mess.c'\" unpacked with wrong size!
  fi
  # end of 'abc/b/b1mess.c'
fi
if test -f 'abc/bhdrs/b.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bhdrs/b.h'\"
else
  echo shar: Extracting \"'abc/bhdrs/b.h'\" \(3346 characters\)
  sed "s/^X//" >'abc/bhdrs/b.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/* b.h: general */
X
X#include "osconf.h"
X#include "os.h"
X#include "conf.h"
X#include "config.h"
X
X#define Forward
X#define Visible
X#define Hidden static
X#define Procedure
X
X/* The following are not intended as pseudo-encapsulation, */
X/* but to emphasize intention. */
X
Xtypedef int bool;
Xtypedef char *string; /* Strings are always terminated with a char '\0'. */
X
X#define Yes ((bool) 1)
X#define No  ((bool) 0)
X
Xtypedef short intlet;
X
X/************************************************************************/
X/*                                                                      */
X/* Values                                                               */
X/*                                                                      */
X/* There are different modules for values, however all agree that       */
X/* the first field of a value is its type, and the second its reference */
X/* count. All other fields depend on the module.                        */
X/*                                                                      */
X/************************************************************************/
X
X/*
X * "SMALL INTEGERS":
X *
X * When a "value" pointer has its low bit set, it is not a pointer.
X * By casting to int and shifting one bit to the right, it is converted
X * to its "int" value.  This can save a lot of heap space used for
X * small integers.
X * Sorry, you have to change this on machines with word rather than byte
X * addressing (maybe you can use the sign bit as tag).
X */
X
X#define IsSmallInt(v) (((int)(v)) & 1)
X#define SmallIntVal(v) (((int)(v) & ~1) / 2)
X#define MkSmallInt(i) ((value)((i)*2 | 1))
X	/* (Can't use << and >> because their effect on negative numbers
X		is not defined.) */
X
Xtypedef struct value {HEADER; string *cts;} *value;
X
X#define Hdrsize (sizeof(struct value)-sizeof(string))
X
X#define Type(v) (IsSmallInt(v) ? Num : (v)->type)
X#define Length(v) ((v)->len)
X#define Refcnt(v) ((v)->refcnt)
X#define Unique(v) ((v)->refcnt==1)
X
X#define Dummy NULL
X#define Dumval ((value) Dummy)
X#define Vnil ((value) NULL)
X#define Pnil ((value *) NULL)
X
X#define Valid(v) ((v) != Vnil)
X
X#define Ats(v) ((value *)&((v)->cts))
X#define Str(v) ((string)&((v)->cts))
X
X/* Types: */
X
X#define Num '0'
X#define Tex '"'
X#define Com ','
X#define Lis 'L'
X#define Ran 'R'		/* doesn't belong here !!! */
X#define Tab 'M'
X#define ELT '}'
X
X#define Is_text(v) (Type(v) == Tex)
X#define Is_number(v) (Type(v) == Num)
X#define Is_compound(v) (Type(v) == Com)
X#define Is_list(v) (Type(v) == Lis || Type(v) == ELT || Type(v) == Ran)
X#define Is_range(v) (Type(v) == Ran)
X#define Is_table(v) (Type(v) == Tab || Type(v) == ELT)
X#define Is_tlt(v) (Type(v)==Tex||Type(v)==Lis||Type(v)==Ran||Type(v)==Tab||Type(v)==ELT)
X#define Is_ELT(v) (Type(v) == ELT)
X
X/****************************************************************************/
X
Xvalue copy();
Xextern bool still_ok;
Xextern bool mess_ok;
Xextern bool interactive;
Xextern bool rd_interactive;
Xextern bool interrupted;
Xextern bool can_interrupt;
Xextern bool testing;
Xextern bool terminated;
X
X#define MESS(nr, text) nr
X#define GMESS(nr, text) getmess(nr)
Xstring getmess();
Xextern char *messbuf;
X#define MESSBUFSIZE 300
X
Xextern FILE *errfile;		/* should be in screen handling module */
X				/* but edi and int ... */
X#define DEBUGFILE stderr
END_OF_FILE
  if test 3346 -ne `wc -c <'abc/bhdrs/b.h'`; then
    echo shar: \"'abc/bhdrs/b.h'\" unpacked with wrong size!
  fi
  # end of 'abc/bhdrs/b.h'
fi
if test -f 'abc/bhdrs/b0lan.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bhdrs/b0lan.h'\"
else
  echo shar: Extracting \"'abc/bhdrs/b0lan.h'\" \(2596 characters\)
  sed "s/^X//" >'abc/bhdrs/b0lan.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/*  Keywords
X *  Predefined functions and predicates
X *  See for the displayer strings the file bint2/i2dis.c
X */
X
X#define Indent "   "	/* Output for each indentation level */
X#define INDENTSIZE 3	/* Number of spaces in same */
X
X/* *********************** KEYWORDS ******************************************* */
X
X/* R_HOW_TO for bed/e1sugg.c; should conform with boot/lang.h */
X#ifdef FRENCH
X#define R_HOW_TO	"COMMENT "
X#define S_HOW_TO	"COMMENT ?: "
X#else
X#define R_HOW_TO	"HOW TO "
X#define S_HOW_TO	"HOW TO ?: "
X#endif
X
X#define K_HOW	 	"HOW"
X#define K_TO_how	"TO"
X#define K_PUT		"PUT"
X#define K_IN_put	"IN"
X#define K_INSERT	"INSERT"
X#define K_IN_insert	"IN"
X#define K_REMOVE	"REMOVE"
X#define K_FROM_remove	"FROM"
X#define K_SETRANDOM	"SET RANDOM"
X#define K_DELETE	"DELETE"
X#define K_CHECK 	"CHECK"
X#define K_SHARE 	"SHARE"
X#define K_PASS		"PASS"
X#define K_WRITE 	"WRITE"
X#define K_READ		"READ"
X#define K_EG		"EG"
X#define K_RAW		"RAW"
X#define K_IF		"IF"
X#define K_WHILE 	"WHILE"
X#define K_FOR		"FOR"
X#define K_IN_for	"IN"
X#define K_SELECT	"SELECT"
X#define K_ELSE		"ELSE"
X#define K_QUIT		"QUIT"
X#define K_RETURN	"RETURN"
X#define K_REPORT	"REPORT"
X#define K_SUCCEED	"SUCCEED"
X#define K_FAIL		"FAIL"
X#define K_AND		"AND"
X#define K_OR		"OR"
X#define K_NOT		"NOT"
X#define K_SOME		"SOME"
X#define K_EACH		"EACH"
X#define K_NO		"NO"
X#define K_IN_quant	"IN"
X#define K_HAS		"HAS"
X
X#ifdef GFX /* Graphics extension */
X#define K_LINEFROM	"LINE FROM"
X#define K_TO_line	"TO"
X#define K_SPACEFROM	"SPACE FROM"
X#define K_TO_space	"TO"
X#define K_CLEARSCREEN	"CLEAR SCREEN"
X#endif
X
X/* *********************** predefined FUNCTIONS ******************************* */
X
X#define F_pi		"pi"
X#define F_e		"e"
X#define F_now		"now"
X#define F_abs		"abs"
X#define F_sign		"sign"
X#define F_floor 	"floor"
X#define F_ceiling	"ceiling"
X#define F_round 	"round"
X#define F_mod		"mod"
X#define F_root		"root"
X#define F_random	"random"
X#define F_exactly	"exactly"
X#define F_sin		"sin"
X#define F_cos		"cos"
X#define F_tan		"tan"
X#define F_arctan	"arctan"
X#define F_angle		"angle"
X#define F_radius	"radius"
X#define F_exp		"exp"
X#define F_log		"log"
X#define F_stripped	"stripped"
X#define F_split		"split"
X#define F_upper		"upper"
X#define F_lower		"lower"
X#define F_keys		"keys"
X#ifdef B_COMPAT
X#define F_thof		"th'of"
X#endif
X#define F_item		"item"
X#define F_min		"min"
X#define F_max		"max"
X#define F_choice	"choice"
X
X/* *********************** predefined PREDICATES ****************************** */
X
X#define P_exact		"exact"
X#define P_in		"in"
X#define P_notin 	"not.in"
X
END_OF_FILE
  if test 2596 -ne `wc -c <'abc/bhdrs/b0lan.h'`; then
    echo shar: \"'abc/bhdrs/b0lan.h'\" unpacked with wrong size!
  fi
  # end of 'abc/bhdrs/b0lan.h'
fi
if test -f 'abc/bint1/i1nut.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bint1/i1nut.c'\"
else
  echo shar: Extracting \"'abc/bint1/i1nut.c'\" \(3197 characters\)
  sed "s/^X//" >'abc/bint1/i1nut.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X#include "b.h"
X#include "bobj.h" /* for relation */
X#include "i1num.h"
X
X/*
X * This file contains routines to speed up some time consuming operations
X * when dealing with big numbers, such as:
X * . exactly() via prod2n()
X * . convnum() and round2() via prod10n()
X */
X
X/* To shut off lint and other warnings: */
X#undef Copy
X#define Copy(x) ((integer)copy((value)(x)))
X
X/*
X * prod2n() returns (v= p/q) * (2**n),
X * simplification rationals is done by sieving the 2 factors out of
X * q if n>0 or p if n<0
X */
X
XVisible value prod2n(v, n, simplify) value v, n; bool simplify; {
X	relation n1 = numcomp(n, zero);
X	integer p, q;
X	integer t1, t2;
X	value k;
X
X	if (n1 >= 0) {
X		p = Integral(v) ? Copy(v) : Copy(Numerator((rational) v));
X		q = Integral(v) ? int_1   : Copy(Denominator((rational) v));
X		n = copy(n);
X	}
X	else {
X		p = Integral(v) ? int_1   : Copy(Denominator((rational) v));
X		q = Integral(v) ? Copy(v) : Copy(Numerator((rational) v));
X		n = negated(n);
X	}
X	
X	if (simplify) {
X		while (n != zero && Even(Lsd(q)) && !Interrupted()) {
X			q = int_half(q);
X			n = diff(k = n, one);
X			release(k);
X		}
X	}
X	
X	if (n != zero) {
X		t1 = (integer) power((value) int_2, n);
X		p = int_prod(t2 = p, t1);
X		Release(t1); Release(t2);
X	}
X	release(n);
X	
X	if (n1 >= 0 && q == int_1)
X		return (value) p;
X	else if (n1 < 0 && p == int_1)
X		return (value) q;
X	else {
X		rational r = mk_rat(n1>=0 ? p : q, n1>=0 ? q : p, 0, No);
X		Release(p); Release(q);
X		return (value) r;
X	}
X}
X
X/* v is shifted n "digits" to the left */
X
XHidden integer int10shift(v, n) integer v; intlet n; {
X	struct integer vv;
X	integer w;
X	int i;
X	
X	if (n == 0)
X		return Copy(v);
X	FreezeSmallInt(v, vv);
X	w = (integer) grab_num(Length(v) + n);
X	for (i = 0; i<Length(v); ++i)
X		Digit(w, i+n) = Digit(v, i);
X	return int_canon(w);
X}
X
X/* returns u * 10**|n| */
X
XHidden integer int10mul(u, n) integer u; int n; {
X	integer v, w;
X
X	if (n<0) n = -n;
X	v = int10shift(u, n / tenlogBASE);
X	w = (integer) tento(n % tenlogBASE);
X	u = int_prod(v, w);
X	Release(v); Release(w);
X	return u;
X}
X
X/* prod10n(v,n) returns (v= p/q) * 10**n;
X * to prevent a time consuming multiplication of two possible big
X * numbers, the relevant operand (p if n>0 and q else) is first shifted
X * |n|/tenlogBASE "digits"
X */
X
XVisible value prod10n(v, n, simplify) value v; int n; bool simplify; {
X	integer p, q, t;
X
X	v = Approximate(v) ? exactly(v) : copy(v);
X
X	if (Integral(v)) {
X		p = Copy(v);
X		q = int_1;
X	}
X	else {
X		p = Copy(Numerator((rational) v));
X		q = Copy(Denominator((rational) v));
X	}
X	if (n > 0) {
X		p = int10mul(t = p, n);
X		Release(t);
X	}
X	else if (n < 0) {
X		q = int10mul(t = q, -n);
X		Release(t);
X	}
X	release(v);
X
X	if (q == int_1)
X		return (value) p;
X	else {
X		rational r = mk_rat(p, q, 0, simplify);
X		Release(p); Release(q);
X		return (value) r;
X	}
X}
X
X/* returns u+0.5 not simplified */
X
XVisible rational ratsumhalf(u) rational u; {
X	integer p, q;
X	rational s;
X
X	p = int_prod(Numerator(u), int_2);
X	p = int_sum(q = p, Denominator(u)); Release(q);
X	q = int_prod(Denominator(u), int_2);
X
X	s = mk_rat(p, q, 0, No);
X		/* roundsize not used, so 0 is sufficient */
X	Release(p); Release(q);
X	return s;
X}
END_OF_FILE
  if test 3197 -ne `wc -c <'abc/bint1/i1nut.c'`; then
    echo shar: \"'abc/bint1/i1nut.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bint1/i1nut.c'
fi
if test -f 'abc/bint2/DEP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bint2/DEP'\"
else
  echo shar: Extracting \"'abc/bint2/DEP'\" \(3282 characters\)
  sed "s/^X//" >'abc/bint2/DEP' <<'END_OF_FILE'
Xi2ana.o: i2ana.c
Xi2ana.o: ../bhdrs/b.h
Xi2ana.o: ../uhdrs/osconf.h
Xi2ana.o: ../uhdrs/os.h
Xi2ana.o: ../uhdrs/conf.h
Xi2ana.o: ../uhdrs/config.h
Xi2ana.o: ../bhdrs/bint.h
Xi2ana.o: ../bhdrs/bobj.h
Xi2ana.o: ../ihdrs/i0err.h
Xi2ana.o: ../ihdrs/i2nod.h
Xi2ana.o: ../ihdrs/i2gen.h
Xi2ana.o: ../ihdrs/i3env.h
Xi2ana.o: ../ihdrs/i3sou.h
Xi2cmd.o: i2cmd.c
Xi2cmd.o: ../bhdrs/b.h
Xi2cmd.o: ../uhdrs/osconf.h
Xi2cmd.o: ../uhdrs/os.h
Xi2cmd.o: ../uhdrs/conf.h
Xi2cmd.o: ../uhdrs/config.h
Xi2cmd.o: ../bhdrs/bint.h
Xi2cmd.o: ../uhdrs/feat.h
Xi2cmd.o: ../bhdrs/bobj.h
Xi2cmd.o: ../ihdrs/i0err.h
Xi2cmd.o: ../bhdrs/b0lan.h
Xi2cmd.o: ../ihdrs/i2par.h
Xi2cmd.o: ../ihdrs/i2nod.h
Xi2cmd.o: ../ihdrs/i3env.h
Xi2dis.o: i2dis.c
Xi2dis.o: ../bhdrs/b.h
Xi2dis.o: ../uhdrs/osconf.h
Xi2dis.o: ../uhdrs/os.h
Xi2dis.o: ../uhdrs/conf.h
Xi2dis.o: ../uhdrs/config.h
Xi2dis.o: ../bhdrs/bint.h
Xi2dis.o: ../bhdrs/bobj.h
Xi2dis.o: ../bhdrs/b0lan.h
Xi2dis.o: ../ihdrs/i2par.h
Xi2dis.o: ../ihdrs/i2nod.h
Xi2exp.o: i2exp.c
Xi2exp.o: ../bhdrs/b.h
Xi2exp.o: ../uhdrs/osconf.h
Xi2exp.o: ../uhdrs/os.h
Xi2exp.o: ../uhdrs/conf.h
Xi2exp.o: ../uhdrs/config.h
Xi2exp.o: ../bhdrs/bint.h
Xi2exp.o: ../bhdrs/bmem.h
Xi2exp.o: ../bhdrs/bobj.h
Xi2exp.o: ../ihdrs/i0err.h
Xi2exp.o: ../ihdrs/i2par.h
Xi2exp.o: ../ihdrs/i2nod.h
Xi2exp.o: ../ihdrs/i2gen.h
Xi2exp.o: ../ihdrs/i2exp.h
Xi2fix.o: i2fix.c
Xi2fix.o: ../bhdrs/b.h
Xi2fix.o: ../uhdrs/osconf.h
Xi2fix.o: ../uhdrs/os.h
Xi2fix.o: ../uhdrs/conf.h
Xi2fix.o: ../uhdrs/config.h
Xi2fix.o: ../bhdrs/bint.h
Xi2fix.o: ../bhdrs/bobj.h
Xi2fix.o: ../ihdrs/i0err.h
Xi2fix.o: ../ihdrs/i2exp.h
Xi2fix.o: ../ihdrs/i2nod.h
Xi2fix.o: ../ihdrs/i2gen.h
Xi2fix.o: ../ihdrs/i2par.h
Xi2fix.o: ../ihdrs/i3env.h
Xi2gen.o: i2gen.c
Xi2gen.o: ../bhdrs/b.h
Xi2gen.o: ../uhdrs/osconf.h
Xi2gen.o: ../uhdrs/os.h
Xi2gen.o: ../uhdrs/conf.h
Xi2gen.o: ../uhdrs/config.h
Xi2gen.o: ../bhdrs/bint.h
Xi2gen.o: ../uhdrs/feat.h
Xi2gen.o: ../bhdrs/bobj.h
Xi2gen.o: ../ihdrs/i0err.h
Xi2gen.o: ../ihdrs/i2nod.h
Xi2gen.o: ../ihdrs/i2gen.h
Xi2gen.o: ../ihdrs/i2par.h
Xi2gen.o: ../ihdrs/i3env.h
Xi2gen.o: ../ihdrs/i3int.h
Xi2gen.o: ../ihdrs/i3sou.h
Xi2syn.o: i2syn.c
Xi2syn.o: ../bhdrs/b.h
Xi2syn.o: ../uhdrs/osconf.h
Xi2syn.o: ../uhdrs/os.h
Xi2syn.o: ../uhdrs/conf.h
Xi2syn.o: ../uhdrs/config.h
Xi2syn.o: ../bhdrs/bint.h
Xi2syn.o: ../uhdrs/feat.h
Xi2syn.o: ../bhdrs/bmem.h
Xi2syn.o: ../bhdrs/bobj.h
Xi2syn.o: ../bhdrs/b0lan.h
Xi2syn.o: ../ihdrs/i2par.h
Xi2syn.o: ../ihdrs/i3scr.h
Xi2syn.o: ../ihdrs/i3env.h
Xi2tar.o: i2tar.c
Xi2tar.o: ../bhdrs/b.h
Xi2tar.o: ../uhdrs/osconf.h
Xi2tar.o: ../uhdrs/os.h
Xi2tar.o: ../uhdrs/conf.h
Xi2tar.o: ../uhdrs/config.h
Xi2tar.o: ../bhdrs/bint.h
Xi2tar.o: ../bhdrs/bobj.h
Xi2tar.o: ../ihdrs/i2par.h
Xi2tar.o: ../ihdrs/i2nod.h
Xi2tes.o: i2tes.c
Xi2tes.o: ../bhdrs/b.h
Xi2tes.o: ../uhdrs/osconf.h
Xi2tes.o: ../uhdrs/os.h
Xi2tes.o: ../uhdrs/conf.h
Xi2tes.o: ../uhdrs/config.h
Xi2tes.o: ../bhdrs/bint.h
Xi2tes.o: ../bhdrs/bobj.h
Xi2tes.o: ../ihdrs/i0err.h
Xi2tes.o: ../bhdrs/b0lan.h
Xi2tes.o: ../ihdrs/i2par.h
Xi2tes.o: ../ihdrs/i2nod.h
Xi2uni.o: i2uni.c
Xi2uni.o: ../bhdrs/b.h
Xi2uni.o: ../uhdrs/osconf.h
Xi2uni.o: ../uhdrs/os.h
Xi2uni.o: ../uhdrs/conf.h
Xi2uni.o: ../uhdrs/config.h
Xi2uni.o: ../bhdrs/bint.h
Xi2uni.o: ../uhdrs/feat.h
Xi2uni.o: ../bhdrs/bobj.h
Xi2uni.o: ../ihdrs/i0err.h
Xi2uni.o: ../bhdrs/b0lan.h
Xi2uni.o: ../ihdrs/i2par.h
Xi2uni.o: ../ihdrs/i2nod.h
Xi2uni.o: ../ihdrs/i3env.h
Xi2uni.o: ../ihdrs/i3sou.h
END_OF_FILE
  if test 3282 -ne `wc -c <'abc/bint2/DEP'`; then
    echo shar: \"'abc/bint2/DEP'\" unpacked with wrong size!
  fi
  # end of 'abc/bint2/DEP'
fi
if test -f 'abc/bint3/i3com.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bint3/i3com.c'\"
else
  echo shar: Extracting \"'abc/bint3/i3com.c'\" \(2542 characters\)
  sed "s/^X//" >'abc/bint3/i3com.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X#include "b.h"
X#include "bmem.h"
X#include "bobj.h"
X#include "bfil.h"
X#include "bcom.h"
X#include "i3scr.h"
X
X/****************************************************************************/
X
X/* Edit a file.  Parameters are the file name (as ABC value), a line
X   number where the focus should appear (may be 0 if not applicable; may
X   be ignored by some editors), and the kind of file: 't' for targets,
X   'u' for units.
X   Returns a bool: Yes if the file has been modified.
X*/
X
XVisible bool f_edit(fname, errline, kind, creating) value fname; intlet errline;
X		literal kind; bool creating; {
X	struct stat statbuf;
X	time_t modtime= 0;
X	string filename= sstrval(fname);
X	bool edited= Yes;
X
X	if (stat(filename, &statbuf) == 0)
X		modtime= statbuf.st_mtime;
X#ifdef unix
X	if (editor) /* another editor */
X		ed_file(filename, errline);
X	else
X#endif
X		abced_file(filename, errline, kind, creating);
X#ifdef macintosh
X	sync();
X#endif
X#ifndef macintosh
X	/* stat() doesn't work properly on the mac */
X	edited= !(stat(filename, &statbuf) == 0 && modtime == statbuf.st_mtime);
X#endif
X	fstrval(filename);
X	still_ok= Yes; /* ignore interrupts that occurred */
X	return edited;
X}
X
X/****************************************************************************/
X
XVisible bool cmdline(kind, bp, indent) literal kind; bufadm *bp; int indent; {
X	static char *edfirst= NULL;
X	static char *edbuf;
X	char *ed_line();
X	char *edlast;
X
X	for (;;) {
X		if (edfirst == NULL) {
X			if (kind == R_cmd && outeractive) {
X				oline();
X				at_nwl= No;
X			}
X			edbuf= ed_line(kind, indent);
X			if (edbuf == NULL) { /* editor interrupted */
X				still_ok= No;
X				return No;
X			}
X			edfirst= edbuf;
X		}
X		if (*edfirst == '\0') { /* at the end of edbuf */
X			edfirst= NULL;
X			freemem((ptr) edbuf);
X			if (kind != R_cmd)
X				continue;
X			bufcpy(bp, "\n");
X			return No;
X		}
X		edlast= strchr(edfirst, '\n');
X		if (edlast == NULL)
X			syserr(MESS(4500, "in cmdline()"));
X		bufncpy(bp, edfirst, edlast - edfirst + 1);
X		edfirst= ++edlast;
X#ifdef MEMTRACE
X		if (strcmp(edbuf, "QUIT\n") == 0)
X			freemem(edbuf);
X#endif
X		return Yes;
X	}
X}
X
X/* delete file from positions file */
X
XVisible Procedure idelpos(fname) value fname; {
X	string file= sstrval(fname);
X	delpos(file);
X	fstrval(file);
X}	
X
X/* move position in positions file */
X
XVisible Procedure imovpos(ofname, nfname) value ofname, nfname; {
X	string o_file= sstrval(ofname);
X	string n_file= sstrval(nfname);
X	movpos(o_file, n_file);
X	fstrval(o_file);
X	fstrval(n_file);
X}
END_OF_FILE
  if test 2542 -ne `wc -c <'abc/bint3/i3com.c'`; then
    echo shar: \"'abc/bint3/i3com.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bint3/i3com.c'
fi
if test -f 'abc/bint3/i3imm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bint3/i3imm.c'\"
else
  echo shar: Extracting \"'abc/bint3/i3imm.c'\" \(3018 characters\)
  sed "s/^X//" >'abc/bint3/i3imm.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X#include "b.h"
X#include "bint.h"
X#include "feat.h"
X#include "bobj.h"
X#include "b0lan.h"
X#include "i2par.h"
X#include "i3env.h"
X#include "i3scr.h"
X#ifdef MENUS
X#include "abcmenus.h"
X#endif
X
X/* ******************************************************************** */
X/*		immediate command					*/
X/* ******************************************************************** */
X
X#define TERM_COMMAND	MESS(3300, "terminating commands only allowed in how-to's and refinements")
X#define SHARE_COMMAND	MESS(3301, "share-command only allowed in a how-to")
X#define NO_COMMAND	MESS(3302, "I don't recognise this as a command")
X
XHidden Procedure imm_command() {
X	parsetree codeseq= NilTree;
X	parsetree c= NilTree, d= NilTree; 
X	int level;
X	char *kw;
X	txptr tx0;
X	
X	cntxt= In_command; still_ok= Yes; interrupted= No;
X	can_interrupt= Yes;
X	terminated= No;
X	resexp= Voi; lino= 0;
X#ifdef MENUS
X	adjust_menus(Prompt_menus);
X#endif
X	level= ilev();
X#ifdef MENUS
X	if (terminated) return;
X#endif
X	if (!still_ok) return;
X	if (level > 0)
X		parerr(MESS(3303, "outer indentation not zero"));
X	else if (findceol(), Ceol(tx));
X	else if (Char(tx) ==C_COLON || Char(tx) == C_EQUAL ||
X			Char(tx) == C_GREATER || Char(tx) == '!') {
X		if (interactive) special();
X		else parerr(MESS(3304, "special commands only interactively"));
X	}
X	else if (tx0= tx, is_cmdname(ceol, &kw)) {
X		if (how_keyword(kw)) {
X			tx= tx0;
X#ifdef MENUS
X			adjust_menus(Editor_menus);
X#endif
X			create_unit();
X		}
X		else if (quit_keyword(kw))
X			terminated= Yes;
X		else if (term_com(kw, &c)) {
X			release(c);
X			parerr(TERM_COMMAND);
X		}
X		else if (share_keyword(kw))
X			parerr(SHARE_COMMAND);
X		else if (control_command(kw, &c) ||
X				 simple_command(kw, &c, &d)) {
X			/* control_command MUST come before simple above */
X#ifdef MENUS
X			adjust_menus(Interpreter_menus);
X#endif
X			if (still_ok) fix_nodes(&c, &codeseq);
X			curline= c; curlino= one;
X			execthread(codeseq);
X			release(c); release(d);
X		}
X		else parerr(NO_COMMAND);
X	}
X	else parerr(NO_COMMAND);
X}
X
XVisible Procedure process() {
X	re_screen();
X	re_env();
X	f_lino= 0;
X	terminated= No;
X	while (!Eof && !terminated) {
X		imm_command();
X		if (!interactive && !still_ok) bye(1);
X	}
X}
X
XHidden Procedure special() {
X	switch(Char(tx++)) {
X		case ':':       skipsp(&tx);
X				if (Char(tx) == C_COLON) {
X#ifdef MENUS
X					adjust_menus(Interpreter_menus);
X#endif
X					lst_uhds();
X				}
X				else {
X#ifdef MENUS
X					adjust_menus(Editor_menus);
X#endif
X					edit_unit();
X				}
X				break;
X		case '=':       skipsp(&tx);
X				if (Char(tx) == C_EQUAL) {
X#ifdef MENUS
X					adjust_menus(Interpreter_menus);
X#endif
X					lst_ttgs();
X				}
X				else {
X#ifdef MENUS
X					adjust_menus(Editor_menus);
X#endif
X					edit_target();
X				}
X				break;
X		case '>':       skipsp(&tx);
X#ifdef MENUS
X				adjust_menus(Interpreter_menus);
X#endif
X				if (Char(tx) == C_GREATER) {
X					lst_wss();
X				}
X				else {
X					goto_ws();
X				}
X				break;
X		default:	syserr(MESS(3305, "special"));
X	}
X}
X
END_OF_FILE
  if test 3018 -ne `wc -c <'abc/bint3/i3imm.c'`; then
    echo shar: \"'abc/bint3/i3imm.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bint3/i3imm.c'
fi
if test -f 'abc/bint3/i3in2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bint3/i3in2.c'\"
else
  echo shar: Extracting \"'abc/bint3/i3in2.c'\" \(2625 characters\)
  sed "s/^X//" >'abc/bint3/i3in2.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/* B interpreter -- independent subroutines */
X
X#include "b.h"
X#include "bint.h"
X#include "bobj.h"
X#include "i0err.h"
X#include "i3env.h"
X#include "i3in2.h"
X#include "i3sou.h"
X
X/* Newlines for WRITE /// */
X
XVisible Procedure nl(n) value n; {
X	value l= size(n); int c= intval(l); release(l);
X	while (c--) newline();
X}
X
X
X/* Evaluating basic targets */
X
XVisible value v_local(name, number) value name, number; {
X	value *aa= envassoc(curnv->tab, number);
X	if (aa != Pnil && *aa != Vnil) {
X		if (Is_indirect(*aa)) {
X			value v= Indirect(*aa)->val;
X			if (v == Vnil) interrV(NO_VALUE, name);
X			return copy(v);
X		}
X		else return copy(*aa);
X	}
X	interrV(NO_VALUE, name);
X	return Vnil;
X}
X
XVisible value v_global(name) value name; {
X	value *aa= envassoc(prmnv->tab, name);
X	if (aa != Pnil && *aa != Vnil) {
X		if (Is_indirect(*aa)) {
X			load_global(*aa, name, Yes);
X			return copy(Indirect(*aa)->val);
X		}
X		else return copy(*aa);
X	}
X	interrV(NO_VALUE, name);
X	return Vnil;
X}
X
XVisible Procedure load_global(v, name, err) value v, name; bool err; {
X	indirect *w= Indirect(v);
X	if (w->val == Vnil) {
X		value *aa, pname= permkey(name, Tar);
X		if (p_exists(pname, &aa)) {
X			release(errtname); errtname= copy(name);
X			w->val= getval(*aa, In_tarval);
X		}
X		else if (err)
X			interrV(NO_VALUE, name);
X		release(pname);
X	}
X}
X
X/* Rangers */
X
X/* An IN-ranger is represented on the stack as a compound of three fields:
X   the last index used, the value of the expression after IN, and its length.
X   (The latter is redundant, but saves save many calls of 'size()'.)
X   When first called, there is, of course, no compound on the stack, but only
X   the value of the expression.  As the expression should always be a text,
X   list or table, this is recognizable as a special case, and then the
X   compound is created.
X   Return value is Yes if a new element was available and assigned, No if not.
X*/
X
XVisible bool in_ranger(l, pv) loc l; value *pv; {
X	value v= *pv, ind, tlt, len, i1, val; bool res;
X	if (!Is_compound(v) || Nfields(v) != 3) { /* First time */
X		tlt= v;
X		if (!Is_tlt(tlt)) {
X			interr(MESS(3400, "in ... i IN e, e is not a text, list or table"));
X			return No;
X		}
X		if (empty(tlt)) return No;
X		*pv= v= mk_compound(3);
X		*Field(v, 0)= ind= one;
X		*Field(v, 1)= tlt;
X		*Field(v, 2)= len= size(tlt);
X		bind(l);
X	}
X	else {
X		ind= *Field(v, 0); tlt= *Field(v, 1); len= *Field(v, 2);
X		res= numcomp(ind, len) < 0;
X		if (!res) { unbind(l); return No; }
X		*Field(v, 0)= ind= sum(i1= ind, one); release(i1);
X	}
X	put(val= item(tlt, ind), l); release(val);
X	return Yes;
X}
END_OF_FILE
  if test 2625 -ne `wc -c <'abc/bint3/i3in2.c'`; then
    echo shar: \"'abc/bint3/i3in2.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bint3/i3in2.c'
fi
if test -f 'abc/bint3/i3ini.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bint3/i3ini.c'\"
else
  echo shar: Extracting \"'abc/bint3/i3ini.c'\" \(3270 characters\)
  sed "s/^X//" >'abc/bint3/i3ini.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X#include "b.h"
X#include "bint.h"
X#include "feat.h"
X#include "bobj.h"
X#include "bfil.h"
X#include "i3env.h"
X#include "i3scr.h"
X#include "release.h"
X
XHidden Procedure print_heading() {
X	if (!f_interactive(stdin))
X		return;
X	putSstr(stderr,
X	"ABC Release %s.\n", RELEASE);
X	putstr(stderr,
X	"Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1989.\n");
X}
X
XVisible Procedure initcall(argc, argv) int argc; char **argv; {
X	bool filearg= No;
X	
X	/* check call: */
X	while (argc > 0) {
X		if (argv[0][0] == '-' && argv[0][1] == '\0');
X		else if (!F_readable(argv[0])) {
X			putSstr(errfile, "can't open input file %s\n", argv[0]);
X			immexit(-1);
X		}
X		else filearg= Yes;
X		++argv; --argc;
X	}
X	/* initial setting flag interactive: */
X	interactive= !filearg && f_interactive(stdin);
X}
X
XVisible Procedure run_abc(argc, argv) int argc; char **argv; {
X	bool filearg= argc > 0;
X	
X	i_lino= 0;
X	while (argc >= 0) {
X		if (argc == 0 || (argv[0][0] == '-' && argv[0][1] == '\0')) {
X			if (argc == 0 && filearg) break;
X			release(iname);
X			iname = Vnil;
X			ifile = stdin;
X			process();
X		}
X		else {
X			filearg= Yes;
X			release(iname);
X			iname = mk_text(argv[0]);
X			if (Isabspath(argv[0]))
X				ifile= fopen(argv[0], "r");
X			else {
X				char *path= makepath(startdir, argv[0]);
X				ifile= fopen(path, "r");
X				freepath(path);
X			}
X			if (ifile != NULL) {
X				process();
X				fclose(ifile);
X			}
X			else {
X				putSstr(errfile, "can't open input file %s\n", argv[0]);
X				immexit(-1);
X			}
X		}
X		++argv; --argc;
X	}
X}
X
XVisible Procedure set_vars() {
X	initmess();	/* set messbuf */
X	initfmt();	/* set fmtbuf */
X	initfile();	/* locate files (messages, keydefs, copybuffer, etc) */
X	init_scr();	/* set outeractive and rd_interactive */
X	initerr();	/* set errfile (!) */
X}
X
XVisible bool in_init= Yes;
X
Xextern bool use_bed;
X
XVisible Procedure init(prompt_help) bool prompt_help; {
X#ifdef SIGNAL
X	initsig();	/* catch signals */
X#endif /* SIGNAL */
X	if (use_bed) {
X		init_erro();	/* buffers for error messages from editor */
X		initkeys();	/* read key definitions from termcap and file */
X		initterm();	/* start trm module */
X		initgram();	/* edi's grammar tables */
X		initclasses();	/* suggestions for builtins */
X		initbed();	/* top-ep's admin; read copybuffer */
X	}
X	
X	initnum();
X	initsyn();
X#ifdef TYPE_CHECK
X	initpol();
X#endif
X	initprmnv();
X	/* start first output here,
X	 * since trm module may start alternative screen ... */
X	print_heading();
X	if (interactive && prompt_help)
X		putmess(errfile, MESS(1700, "Type '?' for help.\n"));
X	/* ... and initbws() prints ">current_ws_name" */
X	initbws();
X
X	in_init= No;
X}
X
XVisible Procedure endall() {
X	/* real tasks: */
X	endbws();
X	if (use_bed) {
X		endbed();	/* save editor parsetree and copybuffer */
X		endterm();	/* reset terminal */
X	}
X
X#ifdef MEMTRACE
X	/* the following only free memory: */
X	endstrval();	/* hack to free strval static store */
X	endnoderepr();	/* hack to free noderepr static store */
X
X#ifdef TYPE_CHECK
X	endpol();
X#endif
X	endsta();
X	endsyn();
X	endnum();
X#ifdef USERSUGG
X	endclasses();
X#endif
X	end_erro();
X	end_scr();
X	endfile();
X	endmess();
X#endif /* MEMTRACE */
X}
X
XVisible Procedure crashend() {
X	if (cntxt != In_wsgroup && cntxt != In_prmnv)
X		endbws();
X}
END_OF_FILE
  if test 3270 -ne `wc -c <'abc/bint3/i3ini.c'`; then
    echo shar: \"'abc/bint3/i3ini.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bint3/i3ini.c'
fi
if test -f 'abc/boot/main.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/boot/main.h'\"
else
  echo shar: Extracting \"'abc/boot/main.h'\" \(3090 characters\)
  sed "s/^X//" >'abc/boot/main.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
Xtypedef short item;	/* used for indexing xxxdef[] arrays;
X			 * each grammatical item will be represented
X			 * by its index in the applicable table.
X			 */
Xtypedef item *itemptr;
X
X/* to indicate end of classinfo arrays: */
X#define Nilitem ((item) -1)
X#define Isnilitem(i) (((item) (i)) == ((item) -1))
X/* (We can't use zero, because an item can indicate  the zero's entry
X * of a xxxdef[] array.
X */
X 
Xstruct classinfo {	/* the itemptr's here indicate 0-terminated array's */
X	string c_name;
X		/* only lower-case */
X	itemptr c_syms;
X		/* list of possible Symbols or LEXICALS */
X	itemptr c_insert;
X		/* list of pairs (char, class) for insertion */
X	itemptr c_append;
X		/* ditto for append to child already there */
X	itemptr c_join;
X		/* ditto for join of child with new node */
X};
X
X#define MAXCHILD 4	/* should actually be computed from input-grammar */
X			/* but this makes live easier ... */
Xstruct syminfo {
X	string s_name;
X		/* first char upper-case, rest lower */
X	string s_repr[MAXCHILD+1];
X		/* fixed-text parts */
X		/* entries are [0..nch] inclusive */
X	item s_class[MAXCHILD];
X		/* index of child into classdef[] */
X};
X
Xstruct lexinfo {
X	string l_name;	/* representing NAME, only Capitals */
X	string l_start; /* char's that may start this lexical */
X	string l_cont;	/* char's that may continue this lexical;
X			 * only used in abc-editor, not in mktable.
X			 */
X	int l_body;	/* index of enveloping class in classdef[] */
X	int l_sym;	/* index in symdef[], for use in class-definition */
X	int l_class;	/* index in classdef[], for use in Symbol-definition */
X};
X
Xstruct nameinfo {
X	string n_name;
X	item n_index;	/* into classdef[] | symdef[] | lexdef[] */
X	char n_type;	/* Class or Sym or Lex */
X};
X
X#define Class ('C')
X#define Sym ('S')
X#define Lex ('L')
X#define Errtype ('E')
X
X/* MAX's to allocate space; can be overwritten with commandline options */
X#define MAXSYM 127
X#define MAXCLASS 100
X#define MAXLEX 20
X#define MAXNAME 300
X
X#define NAMELEN 100	/* maximum significant part of name */
X#define STRINGLEN 256	/* maximum string length */
X#define SYMLEN 200	/* maximum number of alternative symbols in
X			 * any class definition */
X
Xextern struct classinfo *classdef;
Xextern struct syminfo *symdef;
Xextern struct lexinfo *lexdef;
Xextern struct nameinfo *namelist;
X
Xextern int maxclass;
Xextern int maxsym;
Xextern int maxlex;
Xextern int maxname;
X
Xextern int nclass;
Xextern int nsym;
Xextern int nlex;
Xextern int nname;
X
Xextern int nsuggstnbody;
Xextern int lsuggestion;
Xextern int nsuggestion;
X
Xextern int nsugghowbody;
Xextern int lsugghowname;
Xextern int nsugghowname;
X
Xextern int noptional;
Xextern int nhole;
Xextern int nlexical;
X
X#define GRAMMAR "grammar"
X#define TABLES "tabl.c.out"
X#define INCLUDE "tabl.h.out"
X#define HFILE "tabl.h"
X
Xextern string progname;
Xextern FILE *gfp;
Xextern char *gfile;
Xextern FILE *tfp;
Xextern char *tfile;
Xextern FILE *ifp;
Xextern char *ifile;
Xextern char *hfile;
X
Xchar *getmem();
Xstring savestr();
Xitemptr savearray();
X
X#define Assert(cond) ((cond) || asserr(__FILE__, __LINE__))
END_OF_FILE
  if test 3090 -ne `wc -c <'abc/boot/main.h'`; then
    echo shar: \"'abc/boot/main.h'\" unpacked with wrong size!
  fi
  # end of 'abc/boot/main.h'
fi
if test -f 'abc/ehdrs/keys.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ehdrs/keys.h'\"
else
  echo shar: Extracting \"'abc/ehdrs/keys.h'\" \(2943 characters\)
  sed "s/^X//" >'abc/ehdrs/keys.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/*
X * B editor -- Command key definitions as returned by inchar() in getc.c.
X * Old kludges removed.
X * The values must differ from the ones returned by inchar:
X *	32..126 (for printable chars == ABC alphabet)
X *	EOF (for end of file)
X *	0377 (for ignore, rings a bell?).
X *
X * New kludge: the order is used for mapping menuchoices 
X * to editoroperations (saves static data on the Mac:-);
X * the "holes" are caused by deviding lines in the menus
X * and later used for operations not on any menu.
X * So, look at mhdrs/abcmenus.h and mac/m1menus.c if you change this.
X */
X
X#define IGNORE 0377
X
X/* Focus menu: */
X#define 	FOCUS 0 /* one less than WIDEN */
X#define WIDEN		1
X#define EXTEND		2
X#define FIRST		3
X#define LAST		4
X#define PREVIOUS	5
X#define NEXT		6
X
X#define UPLINE		8
X#define DOWNLINE	9
X
X#define UPARROW		11
X#define DOWNARROW	12
X#define LEFTARROW	13
X#define RITEARROW	14
X
X/* not on a menu (mouseclick) */
X#define GOTO		7
X
X/* Edit menu: */
X#define		EDIT 14 /* one less than UNDO */
X#define UNDO		15
X#define REDO		16
X#define CUT			17
X#define COPY		18
X#define PASTE		19
X#define DELETE		20
X
X/* Special menu: */
X#define 	SPECIAL 20	/* one less than ACCEPT */
X#define ACCEPT		21
X#define NEWLINE		22
X
X#define RECORD		24
X#define PLAYBACK	25
X
X#define EXIT		27
X
X/* Pause menu: */
X#define CANCEL		26
X
X/* not on menus: */
X
X#define SUSPEND		28
X
X#define REDRAW		10
X#define LOOK		REDRAW
X
X#define HELP		23
X
X#ifdef KEYS
X#define DELBIND		29
X#endif
X
X/* string-valued codes; must be < 0 */
X
X#define TERMINIT 	-1
X#define TERMDONE	-2
X
X
X/* the next one is only used in printing the helpblurb
X   and should differ from all others above.
X */
X#define NOTHING		0
X
X/* the same for menus handled by do_menu_choice(),
X * instead of passed to editdocument().
X */
X#define HANDLED		0
X
X
X/* the strings belonging to the codes above: */
X
X#define S_IGNORE	"[ignore]"
X
X#define S_WIDEN		"[widen]"
X#define S_EXTEND	"[extend]"
X#define S_FIRST		"[first]"
X#define S_LAST		"[last]"
X#define S_PREVIOUS	"[previous]"
X#define S_NEXT		"[next]"
X#define S_UPLINE	"[upline]"
X#define S_DOWNLINE	"[downline]"
X#define S_UPARROW	"[up]"
X#define S_DOWNARROW	"[down]"
X#define S_LEFTARROW	"[left]"
X#define S_RITEARROW	"[right]"
X#define S_GOTO		"[goto]"
X#define S_ACCEPT	"[accept]"
X#define S_NEWLINE	"[newline]"
X#define S_RETURN	"[return]"
X#define S_UNDO		"[undo]"
X#define S_REDO		"[redo]"
X#define S_COPY		"[copy]"
X#define S_DELETE	"[delete]"
X#define S_RECORD	"[record]"
X#define S_PLAYBACK	"[playback]"
X#define S_REDRAW	"[redraw]"
X#define S_LOOK		"[look]"
X#define S_HELP		"[help]"
X#define S_EXIT		"[exit]"
X#define S_INTERRUPT	"[interrupt]"
X#define S_CANCEL	"[cancel]"
X#define S_SUSPEND	"[suspend]"
X#define S_PASTE		"[paste]"
X#define S_CUT		"[cut]"
X
X/* These two are not key defs but string-valued options: */
X
X#define S_DELBIND	S_IGNORE
X
X#define S_TERMINIT	"[term-init]"
X#define S_TERMDONE	"[term-done]"
X
X#define S_NOTHING	""
END_OF_FILE
  if test 2943 -ne `wc -c <'abc/ehdrs/keys.h'`; then
    echo shar: \"'abc/ehdrs/keys.h'\" unpacked with wrong size!
  fi
  # end of 'abc/ehdrs/keys.h'
fi
if test -f 'abc/ehdrs/node.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ehdrs/node.h'\"
else
  echo shar: Extracting \"'abc/ehdrs/node.h'\" \(2785 characters\)
  sed "s/^X//" >'abc/ehdrs/node.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/*
X * B editor -- Parse tree and Focus stack.
X */
X
X/*
X * Assertion macro.
X *
X * This one differs from the one in #include <assert.h> in that it
X * is usable as an expression operand, e.g. up(ep) || Assert(No).
X * The function asserr() must unconditionally terminate the program.
X * If the accumulated __FILE__ data wastes too much of your data
X * space, omit them and change the code in asserr() that uses them.
X * You better trust your code then, because unless compiled with "-g"
X * it's difficult to dig the line number information from the core dump.
X *
X * There is also a variant called Abort() which is equivalent to Assert(No).
X */
X
X#ifdef NDEBUG
X#define Abort() abort() /* Always fail */
X#define Assert(cond) 0 /* Dummy expression */
X#else /* NDEBUG */
X#define Abort() asserr(__FILE__, __LINE__)
X#define Assert(cond) ((cond) || Abort())
X#endif /* NDEBUG */
X
Xnode newnode();
X
X#ifndef NDEBUG
X#define symbol(n) (Assert(Is_Node(n)), (n)->n_symbol)
X#define nchildren(n) (Assert(Is_Node(n)), Length(n))
X#define marks(n) (Assert(Is_Node(n)), (n)->n_marks)
X#define child(n, i) \
X	(Assert(Is_Node(n) && (i)>0 && (i)<=Length(n)), (n)->n_child[(i)-1])
X#define lastchild(n) \
X	(Assert(Is_Node(n) && Length(n)>0), (n)->n_child[Length(n)-1])
X#define firstchild(n) \
X	(Assert(Is_Node(n) && Length(n)>0), (n)->n_child[0])
X#else /* NDEBUG */
X#define symbol(n) ((n)->n_symbol)
X#define nchildren(n) (Length(n))
X#define marks(n) ((n)->n_marks)
X#define child(n, i) ((n)->n_child[(i)-1])
X#define lastchild(n) ((n)->n_child[Length(n)-1])
X#define firstchild(n) ((n)->n_child[0])
X#endif /* NDEBUG */
X
Xint nodewidth();
X#define marked(p, x) (marks(tree(p))&(x))
X
Xpath newpath();
X
X#define parent(p) ((p)->p_parent)
X#define tree(p) ((p)->p_tree)
X#define ichild(p) ((p)->p_ichild)
X
X#define Ycoord(p) ((p)->p_ycoord)
X#define Xcoord(p) ((p)->p_xcoord)
X#define Level(p) ((p)->p_level)
X
X/* Procedure markpath(); */
X/* Procedure unmkpath(); */
X/* Procedure treereplace(); */
Xbool up();
Xbool downi();
X
X#define down(n) downi(n, 1)
X
Xbool downrite();
Xbool left();
Xbool rite();
X/* Procedure top(); */
Xbool nextnode();
X/* Procedure firstleaf(); */
Xbool nextleaf();
Xbool prevnode();
X/* Procedure lastleaf(); */
Xbool prevleaf();
Xbool nextmarked();
Xbool prevmarked();
X
X/*
X * The following are routines for lint, but macros for CC.
X * This way lint can detect wrong arguments passed.
X */
X
X#ifdef lint
X
Xnode nodecopy();
Xnoderelease();
Xnodeuniql();
X
Xpath pathcopy();
Xpathrelease();
Xpathuniql();
X
X#else
X
X#define nodecopy(n) ((node)copy(n))
X#define noderelease(n) release(n)
X#define nodeuniql(pn) uniql(pn)
X
X#define pathcopy(p) ((path)copy(p))
X#define pathrelease(p) release(p)
X#define pathuniql(pp) uniql(pp)
X
X#endif
X
Xnode grab_node();
Xpath grab_path();
X
END_OF_FILE
  if test 2785 -ne `wc -c <'abc/ehdrs/node.h'`; then
    echo shar: \"'abc/ehdrs/node.h'\" unpacked with wrong size!
  fi
  # end of 'abc/ehdrs/node.h'
fi
if test -f 'abc/keys/DEP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/keys/DEP'\"
else
  echo shar: Extracting \"'abc/keys/DEP'\" \(2626 characters\)
  sed "s/^X//" >'abc/keys/DEP' <<'END_OF_FILE'
Xkeydef.o: keydef.c
Xkeydef.o: ../bhdrs/b.h
Xkeydef.o: ../uhdrs/osconf.h
Xkeydef.o: ../uhdrs/os.h
Xkeydef.o: ../uhdrs/conf.h
Xkeydef.o: ../uhdrs/config.h
Xkeydef.o: ../bhdrs/bfil.h
Xkeydef.o: ../bhdrs/bmem.h
Xkeydef.o: ../uhdrs/feat.h
Xkeydef.o: ../ehdrs/keys.h
Xkeydef.o: ../ehdrs/getc.h
Xkeydef.o: ../ehdrs/trm.h
Xkeydef.o: ../bhdrs/release.h
Xkeydef.o: ./keydef.h
Xkeyhlp.o: keyhlp.c
Xkeyhlp.o: ../bhdrs/b.h
Xkeyhlp.o: ../uhdrs/osconf.h
Xkeyhlp.o: ../uhdrs/os.h
Xkeyhlp.o: ../uhdrs/conf.h
Xkeyhlp.o: ../uhdrs/config.h
Xkeyhlp.o: ../uhdrs/feat.h
Xkeyhlp.o: ../bhdrs/bmem.h
Xkeyhlp.o: ../ehdrs/keys.h
Xkeyhlp.o: ../ehdrs/getc.h
Xe1getc.o: ../bed/e1getc.c
Xe1getc.o: ../bhdrs/b.h
Xe1getc.o: ../uhdrs/osconf.h
Xe1getc.o: ../uhdrs/os.h
Xe1getc.o: ../uhdrs/conf.h
Xe1getc.o: ../uhdrs/config.h
Xe1getc.o: ../uhdrs/feat.h
Xe1getc.o: ../bhdrs/bmem.h
Xe1getc.o: ../bhdrs/bobj.h
Xe1getc.o: ../bhdrs/bfil.h
Xe1getc.o: ../ehdrs/keys.h
Xe1getc.o: ../ehdrs/getc.h
Xe1getc.o: ../uhdrs/args.h
Xb1file.o: ../b/b1file.c
Xb1file.o: ../bhdrs/b.h
Xb1file.o: ../uhdrs/osconf.h
Xb1file.o: ../uhdrs/os.h
Xb1file.o: ../uhdrs/conf.h
Xb1file.o: ../uhdrs/config.h
Xb1file.o: ../bhdrs/bfil.h
Xb1file.o: ../bhdrs/bmem.h
Xb1memo.o: ../b/b1memo.c
Xb1memo.o: ../bhdrs/b.h
Xb1memo.o: ../uhdrs/osconf.h
Xb1memo.o: ../uhdrs/os.h
Xb1memo.o: ../uhdrs/conf.h
Xb1memo.o: ../uhdrs/config.h
Xb1memo.o: ../bhdrs/bmem.h
Xb1mess.o: ../b/b1mess.c
Xb1mess.o: ../bhdrs/b.h
Xb1mess.o: ../uhdrs/osconf.h
Xb1mess.o: ../uhdrs/os.h
Xb1mess.o: ../uhdrs/conf.h
Xb1mess.o: ../uhdrs/config.h
Xb1mess.o: ../bhdrs/bfil.h
Xb1mess.o: ../bhdrs/bmem.h
Xb1mess.o: ../bhdrs/bobj.h
Xgetopt.o: ../b/getopt.c
Xgetopt.o: ../uhdrs/os.h
Xb1outp.o: ../b/b1outp.c
Xb1outp.o: ../bhdrs/b.h
Xb1outp.o: ../uhdrs/osconf.h
Xb1outp.o: ../uhdrs/os.h
Xb1outp.o: ../uhdrs/conf.h
Xb1outp.o: ../uhdrs/config.h
Xb1outp.o: ../bhdrs/bmem.h
Xu1file.o: ../unix/u1file.c
Xu1file.o: ../bhdrs/b.h
Xu1file.o: ../uhdrs/osconf.h
Xu1file.o: ../uhdrs/os.h
Xu1file.o: ../uhdrs/conf.h
Xu1file.o: ../uhdrs/config.h
Xu1file.o: ../bhdrs/bmem.h
Xu1file.o: ../uhdrs/dest.h
Xu1file.o: ../bhdrs/bfil.h
Xu1keys.o: ../unix/u1keys.c
Xu1keys.o: ../bhdrs/b.h
Xu1keys.o: ../uhdrs/osconf.h
Xu1keys.o: ../uhdrs/os.h
Xu1keys.o: ../uhdrs/conf.h
Xu1keys.o: ../uhdrs/config.h
Xu1keys.o: ../uhdrs/feat.h
Xu1keys.o: ../bhdrs/bmem.h
Xu1keys.o: ../ehdrs/getc.h
Xu1keys.o: ../ehdrs/keys.h
Xu1keys.o: ../uhdrs/args.h
Xu1trm.o: ../unix/u1trm.c
Xu1trm.o: ../bhdrs/b.h
Xu1trm.o: ../uhdrs/osconf.h
Xu1trm.o: ../uhdrs/os.h
Xu1trm.o: ../uhdrs/conf.h
Xu1trm.o: ../uhdrs/config.h
Xu1trm.o: ../ehdrs/trm.h
Xu1dir.o: ../unix/u1dir.c
Xu1dir.o: ../bhdrs/b.h
Xu1dir.o: ../uhdrs/osconf.h
Xu1dir.o: ../uhdrs/os.h
Xu1dir.o: ../uhdrs/conf.h
Xu1dir.o: ../uhdrs/config.h
END_OF_FILE
  if test 2626 -ne `wc -c <'abc/keys/DEP'`; then
    echo shar: \"'abc/keys/DEP'\" unpacked with wrong size!
  fi
  # end of 'abc/keys/DEP'
fi
if test -f 'abc/stc/i2stc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/stc/i2stc.h'\"
else
  echo shar: Extracting \"'abc/stc/i2stc.h'\" \(2818 characters\)
  sed "s/^X//" >'abc/stc/i2stc.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/*************************************************************************/
X
X/* polytype representation */
X
Xtypedef value typekind;
Xtypedef value polytype;
X
X/* accessing, NOT giving new values */
X
Xtypekind kind(); 	/* polytype u */
Xintlet nsubtypes(); 	/* polytype u */
Xpolytype subtype(); 	/* polytype u, intlet i */
Xpolytype asctype(); 	/* polytype u */
Xpolytype keytype(); 	/* polytype u */
Xvalue ident(); 		/* polytype u */
X
X/* MaKe Types, where subtypes are "eaten" */
X
Xpolytype mkt_polytype(); /* typekind k; intlet nsub */
X				/* visible only in bunif.c */
X/* Procedure putsubtype(); */	/* polytype sub, *pcomp; intlet isub */
X				/* to be used after mkt_polytype or
X				 * mkt_compound */
X
Xpolytype mkt_number();
Xpolytype mkt_text();
Xpolytype mkt_tn();
Xpolytype mkt_error();
Xpolytype mkt_list(); 	/* polytype s */
Xpolytype mkt_table();	/* polytype k, a */
Xpolytype mkt_lt(); 	/* polytype s */
Xpolytype mkt_tlt(); 	/* polytype s */
Xpolytype mkt_compound();	/* intlet nsub */
Xpolytype mkt_var(); 	/* value id */
Xpolytype mkt_newvar();
Xpolytype mkt_ext();
X
Xpolytype p_copy(); 	/* polytype u */
X/* Procedure p_release(); */		/* polytype u */
X
X/* predicates */
X
Xbool are_same_types(); 	/* polytype u, v */
Xbool have_same_structure();/* polytype u, v */
X
Xbool t_is_number();	/* typekind k */
Xbool t_is_text();	/* typekind k */
Xbool t_is_tn();		/* typekind k */
Xbool t_is_error();	/* typekind k */
Xbool t_is_list(); 	/* typekind k */
Xbool t_is_table();	/* typekind k */
Xbool t_is_lt(); 	/* typekind k */
Xbool t_is_tlt();	/* typekind k */
Xbool t_is_compound();	/* typekind k */
Xbool t_is_var();	/* typekind k */
Xbool t_is_ext();	/* typekind k */
Xbool has_number(); 	/* typekind k */
Xbool has_text(); 	/* typekind k */
Xbool has_lt();	 	/* typekind k */
X
X/* typetable */
X
X/* Procedure repl_type_of(); */ /* polytype u, tu */
Xbool table_has_type_of();	/* polytype u */
Xpolytype bottomtype(); 		/* polytype u */
Xpolytype bottomvar(); 		/* polytype u */
X
X/* Procedure usetypetable(); */		/* value t */
X/* Procedure deltypetable(); */
X
X/* init */
X
X/* Procedure initpol(); */ 	/* */
X
X/*************************************************************************/
X
X/* unification of polytypes */
X
X/* Procedure unify(); */ 	/* polytype a, b, &u; bool &bad */
X
Xbool contains(); 	/* polytype u, a */
Xbool equal_vars(); 	/* polytype s, a */
X
X/*************************************************************************/
X
X/* type unification errors */
X
X/* Procedure start_vars(); */ 		/* */
X/* Procedure add_var(); */		/* polytype tvar */
X/* Procedure end_vars(); */		/* */
X
X/* Procedure setreprtable(); */ 	/* */
X/* Procedure delreprtable(); */		/* */
X
X/* Procedure badtyperr(); */		/* polytype a, b */
X/* Procedure cyctyperr(); */		/* polytype a */
X
Xvalue conc();
END_OF_FILE
  if test 2818 -ne `wc -c <'abc/stc/i2stc.h'`; then
    echo shar: \"'abc/stc/i2stc.h'\" unpacked with wrong size!
  fi
  # end of 'abc/stc/i2stc.h'
fi
if test -f 'abc/tc/tputs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/tc/tputs.c'\"
else
  echo shar: Extracting \"'abc/tc/tputs.c'\" \(1724 characters\)
  sed "s/^X//" >'abc/tc/tputs.c' <<'END_OF_FILE'
X#include <sgtty.h>
X#include <ctype.h>
X
X/*
X * The following array gives the number of tens of milliseconds per
X * character for each speed as returned by gtty.  Thus since 300
X * baud returns a 7, there are 33.3 milliseconds per char at 300 baud.
X */
Xstatic
Xshort	tmspc10[] = {
X	0, 2000, 1333, 909, 743, 666, 500, 333, 166, 83, 55, 41, 20, 10, 5
X};
X
Xshort	ospeed;
Xchar	PC;
X
X/*
X * Put the character string cp out, with padding.
X * The number of affected lines is affcnt, and the routine
X * used to output one character is outc.
X */
Xtputs(cp, affcnt, outc)
X	register char *cp;
X	int affcnt;
X	int (*outc)();
X{
X	register int i = 0;
X	register int mspc10;
X
X	if (cp == 0)
X		return;
X
X	/*
X	 * Convert the number representing the delay.
X	 */
X	if (isdigit(*cp)) {
X		do
X			i = i * 10 + *cp++ - '0';
X		while (isdigit(*cp));
X	}
X	i *= 10;
X	if (*cp == '.') {
X		cp++;
X		if (isdigit(*cp))
X			i += *cp - '0';
X		/*
X		 * Only one digit to the right of the decimal point.
X		 */
X		while (isdigit(*cp))
X			cp++;
X	}
X
X	/*
X	 * If the delay is followed by a `*', then
X	 * multiply by the affected lines count.
X	 */
X	if (*cp == '*')
X		cp++, i *= affcnt;
X
X	/*
X	 * The guts of the string.
X	 */
X	while (*cp)
X		(*outc)(*cp++);
X
X	/*
X	 * If no delay needed, or output speed is
X	 * not comprehensible, then don't try to delay.
X	 */
X	if (i == 0)
X		return;
X	if (ospeed <= 0 || ospeed >= (sizeof tmspc10 / sizeof tmspc10[0]))
X		return;
X
X	/*
X	 * Round up by a half a character frame,
X	 * and then do the delay.
X	 * Too bad there are no user program accessible programmed delays.
X	 * Transmitting pad characters slows many
X	 * terminals down and also loads the system.
X	 */
X	mspc10 = tmspc10[ospeed];
X	i += mspc10 / 2;
X	for (i /= mspc10; i > 0; i--)
X		(*outc)(PC);
X}
END_OF_FILE
  if test 1724 -ne `wc -c <'abc/tc/tputs.c'`; then
    echo shar: \"'abc/tc/tputs.c'\" unpacked with wrong size!
  fi
  # end of 'abc/tc/tputs.c'
fi
echo shar: End of archive 22 \(of 25\).
cp /dev/null ark22isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0 # Just in case...
