Subject:  v23i103:  ABC interactive programming environment, Part24/25
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: ce62bbeb 78159c2f d7f7a852 2f417837

Submitted-by: Steven Pemberton <steven@cwi.nl>
Posting-number: Volume 23, Issue 103
Archive-name: abc/part24

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  abc/b/DEP abc/bed/e1code.c abc/bed/e1lexi.c
#   abc/bhdrs/bedi.h abc/bhdrs/bfil.h abc/bint2/i2tar.c
#   abc/bio/i4bio.c abc/bio/i4bio.h abc/bio/i4out.c abc/boot/lang.h
#   abc/btr/e1etex.c abc/ch_all abc/ch_install abc/ch_messages
#   abc/doc/BugReport abc/doc/Structure abc/ehdrs/cell.h
#   abc/ehdrs/erro.h abc/ehdrs/trm.h abc/ex/README abc/ex/TryEditor
#   abc/ex/generate.out abc/ihdrs/i2exp.h abc/ihdrs/i3env.h
#   abc/ihdrs/i3int.h abc/scripts/Change abc/scripts/Collect
#   abc/stc/DEP abc/tc/Makefile abc/tc/tc2.c abc/uhdrs/conf.h
#   abc/uhdrs/dir.h abc/ukeys/abckeys_2621 abc/ukeys/abckeys_5620
#   abc/ukeys/abckeys_5620-2 abc/ukeys/abckeys_5620-e
#   abc/ukeys/abckeys_adm31 abc/unix/u1edit.c abc/unix/u1os.c
# Wrapped by rsalz@litchi.bbn.com on Mon Dec 17 13:28:28 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 24 (of 25)."'
if test -f 'abc/b/DEP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/b/DEP'\"
else
  echo shar: Extracting \"'abc/b/DEP'\" \(1069 characters\)
  sed "s/^X//" >'abc/b/DEP' <<'END_OF_FILE'
Xb1file.o: b1file.c
Xb1file.o: ../bhdrs/b.h
Xb1file.o: ../uhdrs/osconf.h
Xb1file.o: ../uhdrs/os.h
Xb1file.o: ../uhdrs/conf.h
Xb1file.o: ../uhdrs/config.h
Xb1file.o: ../bhdrs/bfil.h
Xb1file.o: ../bhdrs/bmem.h
Xb1grab.o: b1grab.c
Xb1grab.o: ../bhdrs/b.h
Xb1grab.o: ../uhdrs/osconf.h
Xb1grab.o: ../uhdrs/os.h
Xb1grab.o: ../uhdrs/conf.h
Xb1grab.o: ../uhdrs/config.h
Xb1grab.o: ../bhdrs/bint.h
Xb1grab.o: ../bhdrs/bedi.h
Xb1grab.o: ../bhdrs/bmem.h
Xb1grab.o: ../bhdrs/bobj.h
Xb1memo.o: b1memo.c
Xb1memo.o: ../bhdrs/b.h
Xb1memo.o: ../uhdrs/osconf.h
Xb1memo.o: ../uhdrs/os.h
Xb1memo.o: ../uhdrs/conf.h
Xb1memo.o: ../uhdrs/config.h
Xb1memo.o: ../bhdrs/bmem.h
Xb1mess.o: b1mess.c
Xb1mess.o: ../bhdrs/b.h
Xb1mess.o: ../uhdrs/osconf.h
Xb1mess.o: ../uhdrs/os.h
Xb1mess.o: ../uhdrs/conf.h
Xb1mess.o: ../uhdrs/config.h
Xb1mess.o: ../bhdrs/bfil.h
Xb1mess.o: ../bhdrs/bmem.h
Xb1mess.o: ../bhdrs/bobj.h
Xb1outp.o: b1outp.c
Xb1outp.o: ../bhdrs/b.h
Xb1outp.o: ../uhdrs/osconf.h
Xb1outp.o: ../uhdrs/os.h
Xb1outp.o: ../uhdrs/conf.h
Xb1outp.o: ../uhdrs/config.h
Xb1outp.o: ../bhdrs/bmem.h
Xgetopt.o: getopt.c
Xgetopt.o: ../uhdrs/os.h
END_OF_FILE
  if test 1069 -ne `wc -c <'abc/b/DEP'`; then
    echo shar: \"'abc/b/DEP'\" unpacked with wrong size!
  fi
  # end of 'abc/b/DEP'
fi
if test -f 'abc/bed/e1code.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bed/e1code.c'\"
else
  echo shar: Extracting \"'abc/bed/e1code.c'\" \(833 characters\)
  sed "s/^X//" >'abc/bed/e1code.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X/*
X * Compaction scheme for characters to save space in grammar tables
X * by combining characters with similar properties (digits, l.c. letters).
X */
X
X#include "b.h"
X#include "code.h"
X
XVisible char code_array[RANGE];
XVisible char invcode_array[RANGE];
XVisible int lastcode= 0;
X
XVisible Procedure initcodes() {
X	int c;
X
X	code_array['\n'] = ++lastcode;
X	invcode_array[lastcode] = '\n';
X	for (c = ' '; c <= '0'; ++c) {
X		code_array[c] = ++lastcode;
X		invcode_array[lastcode] = c;
X	}
X	for (; c <= '9'; ++c)
X		code_array[c] = lastcode;
X	for (; c <= 'a'; ++c) {
X		code_array[c] = ++lastcode;
X		invcode_array[lastcode] = c;
X	}
X	for (; c <= 'z'; ++c)
X		code_array[c] = lastcode;
X	for (; c < RANGE; ++c) {
X		code_array[c] = ++lastcode;
X		invcode_array[lastcode] = c;
X	}
X}
END_OF_FILE
  if test 833 -ne `wc -c <'abc/bed/e1code.c'`; then
    echo shar: \"'abc/bed/e1code.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bed/e1code.c'
fi
if test -f 'abc/bed/e1lexi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bed/e1lexi.c'\"
else
  echo shar: Extracting \"'abc/bed/e1lexi.c'\" \(1145 characters\)
  sed "s/^X//" >'abc/bed/e1lexi.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/*
X * B editor -- Lexical elements (identifiers, keywords, numbers etc.)
X */
X
X#include "b.h"
X#include "bedi.h"
X#include "bobj.h"
X#include "node.h"
X#include "tabl.h"
X
X/*
X * Table defining lexical elements is generated by 'mktable' in e1tabl.c.
X *
X * ********** Indexed by (symbol-LEXICAL).
X */
X
X
X/*
X * Test whether character `c' may start a lexical element with
X * symbolic name `lex'.
X */
X
XVisible bool maystart(c, ilex) char c; int ilex; {
X	string cp;
X
X	ilex-= LEXICAL;
X	Assert(0 <= ilex && ilex < NLEX);
X	if (!isascii(c) || c != ' ' && !isprint(c))
X		return No;
X	cp= lextab[ilex].l_start;
X	if (*cp == '^')
X		return (strchr(cp+1, c) == NULL);
X	return (strchr(cp, c) != NULL);
X}
X
X
X/*
X * Test whether character `c' may continue a lexical element with
X * symbolic name `ilex'.
X */
X
XVisible bool maycontinue(c, ilex) char c; int ilex; {
X	string cp;
X
X	ilex-= LEXICAL;
X	Assert(0 <= ilex && ilex < NLEX);
X	if (!isascii(c) || c != ' ' && !isprint(c))
X		return No;
X	cp= lextab[ilex].l_continue;
X	if (*cp == '^')
X		return (strchr(cp+1, c) == NULL);
X	return (strchr(cp, c) != NULL);
X}
END_OF_FILE
  if test 1145 -ne `wc -c <'abc/bed/e1lexi.c'`; then
    echo shar: \"'abc/bed/e1lexi.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bed/e1lexi.c'
fi
if test -f 'abc/bhdrs/bedi.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bhdrs/bedi.h'\"
else
  echo shar: Extracting \"'abc/bhdrs/bedi.h'\" \(1100 characters\)
  sed "s/^X//" >'abc/bhdrs/bedi.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X#define CMDPROMPT ">>> " /* Prompt user for immediate command */
X
X/* Types */
X
X#define Nod 'N'
X#define Pat 'P'
X#define Etex 'E'
X	/* text values in the kernel of the editor are stored
X	 * according to the lineair model.
X	 */
X
X#define Is_Node(n) (Type(n) == Nod)
X#define Is_Pat(p) (Type(p) == Pat)
X#define Is_etext(v) (Type(v) == Etex)
X
Xtypedef struct node *node;
Xtypedef struct path *path;
Xtypedef int markbits;
X
Xstruct node {
X	HEADER;
X	markbits	n_marks;
X	intlet	n_width;
X	intlet	n_symbol;
X	node	n_child[1];
X};
X
X#define Nnil ((node) Vnil)
X
X#define NodOffset (sizeof(int) + 2*sizeof(intlet))
X
Xstruct path {
X	HEADER;
X	path	p_parent;
X	node	p_tree;
X	intlet	p_ichild;
X	intlet	p_ycoord;
X	intlet	p_xcoord;
X	intlet	p_level;
X	markbits	p_addmarks;
X	markbits	p_delmarks;
X};
X
X#define NilPath ((path) Vnil)
X
X
Xextern int doctype;	/* type of document edited by editdocument() */
X#define D_perm 0	/* a how-to definition or permanent location */
X#define D_input 1	/* input for READ or question */
X#define D_immcmd 2	/* editing immediate command */
END_OF_FILE
  if test 1100 -ne `wc -c <'abc/bhdrs/bedi.h'`; then
    echo shar: \"'abc/bhdrs/bedi.h'\" unpacked with wrong size!
  fi
  # end of 'abc/bhdrs/bedi.h'
fi
if test -f 'abc/bhdrs/bfil.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bhdrs/bfil.h'\"
else
  echo shar: Extracting \"'abc/bhdrs/bfil.h'\" \(1010 characters\)
  sed "s/^X//" >'abc/bhdrs/bfil.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X/* MESSFILE and HELPFILE in ../?hdrs/dest.h. */
X
X#define KEYSFILE	"abc.key"
X
X#define PERMFILE	"perm.abc"
X#define SUGGFILE	"suggest.abc"
X#define POSFILE		"position.abc"
X#define TYPESFILE	"types.abc"
X
X#define BUFFILE		"copybuf.abc"
X
X#define WSGROUPFILE	"wsgroup.abc"
X#define CURWSFILE	"curws.abc"
X
X#define TEMPFILE	"temp.abc"
X#define TEMP1FILE	"temp1.abc"
X
X#ifndef BWSNAME
X#define BWSNAME		"abc"
X#endif
X
Xextern string messfile;
Xextern string keysfile;
Xextern string helpfile;
X
Xextern string permfile;
Xextern string suggfile;
Xextern string posfile;
Xextern string typesfile;
Xextern string buffile;
X
Xextern string wsgroupfile;
Xextern string curwsfile;
X
Xextern string tempfile;
Xextern string temp1file;
X
Xextern string editor;
X
Xextern char *makepath();
Xextern char *savepath();
X/* extern Procedure freepath(); */
X
Xextern char *startdir;
Xextern char *bwsdefault;
Xextern char *curdir();
X
Xchar *f_getline();		/* return line from file including \n */
END_OF_FILE
  if test 1010 -ne `wc -c <'abc/bhdrs/bfil.h'`; then
    echo shar: \"'abc/bhdrs/bfil.h'\" unpacked with wrong size!
  fi
  # end of 'abc/bhdrs/bfil.h'
fi
if test -f 'abc/bint2/i2tar.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bint2/i2tar.c'\"
else
  echo shar: Extracting \"'abc/bint2/i2tar.c'\" \(701 characters\)
  sed "s/^X//" >'abc/bint2/i2tar.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X#include "b.h"
X#include "bint.h"
X#include "bobj.h"
X#include "i2par.h"
X#include "i2nod.h"
X
XForward parsetree singtarg();
X
XVisible parsetree targ(q) txptr q; {
X	return collateral(q, singtarg);
X}
X
XHidden parsetree singtarg(q) txptr q; {
X	parsetree v; value t;
X	skipsp(&tx);
X	if (nothing(q, MESS(2500, "nothing where address expected"))) 
X		return NilTree;
X	if (open_sign) v= compound(q, targ);
X	else if (is_tag(&t)) v= node2(TAG, t);
X	else {
X		parerr(MESS(2501, "no address where expected"));
X		tx= q;
X		return NilTree;
X	}
X	selection(q, &v);
X	trim_target(q, &v);
X	upto1(q, MESS(2502, "something unexpected in address"));
X	return v;
X}
END_OF_FILE
  if test 701 -ne `wc -c <'abc/bint2/i2tar.c'`; then
    echo shar: \"'abc/bint2/i2tar.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bint2/i2tar.c'
fi
if test -f 'abc/bio/i4bio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bio/i4bio.c'\"
else
  echo shar: Extracting \"'abc/bio/i4bio.c'\" \(745 characters\)
  sed "s/^X//" >'abc/bio/i4bio.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X#include "b.h"
X#include "bint.h"
X#include "bmem.h"
X#include "bobj.h"
X#include "i2par.h"
X#include "i3scr.h"
X#include "i3sou.h"
X#include "i4bio.h"
X
XVisible Procedure abcio(option, name_arg) char option, *name_arg; {
X	sv_ifile= ifile= stdin;
X	
X	switch (option) {
X		case 'i':
X			abcinput(name_arg);
X			break;
X		case 'o':
X			abcoutput(name_arg);
X			break;
X		case 'l':
X			abclist(stdout);
X			break;
X		case 'r':
X			if (!ws_recovered)
X				rec_workspace();
X			break;
X		case 'R':
X			if (!gr_recovered)
X				rec_wsgroup();
X			break;
X	}
X}
X
XVisible Procedure bioerr(m) int m; {
X	putmess(errfile, m);
X}
X
XVisible Procedure bioerrV(m, v) int m; value v; {
X	putSmess(errfile, m, strval(v));
X}
END_OF_FILE
  if test 745 -ne `wc -c <'abc/bio/i4bio.c'`; then
    echo shar: \"'abc/bio/i4bio.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bio/i4bio.c'
fi
if test -f 'abc/bio/i4bio.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bio/i4bio.h'\"
else
  echo shar: Extracting \"'abc/bio/i4bio.h'\" \(1189 characters\)
  sed "s/^X//" >'abc/bio/i4bio.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
Xvalue get_names();
Xbool abcfile();
Xbool abcworkspace();
Xbool unitfile();
Xbool targetfile();
Xchar *base_fname();
Xbool typeclash();
X
Xextern bool ws_recovered;
Xextern bool gr_recovered;
X
X#define IO_NAME		MESS(4600, "*** %s isn't the name of a location\n")
X#define O_INIT		MESS(4601, "*** %s hasn't been initialised\n")
X#define O_TABLE		MESS(4602, "*** %s isn't a table\n")
X#define R_ERROR		MESS(4603, "*** Errors while recovering workspace:\n")
X#define R_TNAME		MESS(4604, "*** %s: cannot derive a location name\n")
X#define R_FREAD		MESS(4605, "*** %s: cannot read this file\n")
X#define R_UNAME		MESS(4606, "*** %s: cannot derive a how-to name\n")
X#define R_RENAME	MESS(4607, "*** %s: cannot rename this file\n")
X#define R_EXIST		MESS(4608, "*** %s: the ABC name for this file is already in use\n")
X#define R_FWRITE	MESS(4609, "*** %s: cannot create this file\n")
X#define G_ERROR		MESS(4610, "*** Errors while recovering the workspace index\n")
X#define G_DNAME		MESS(4611, "*** %s: cannot derive an ABC name for this workspace\n")
X#define G_EXIST		MESS(4612, "*** %s: the ABC name for this workspace is already in use\n")
END_OF_FILE
  if test 1189 -ne `wc -c <'abc/bio/i4bio.h'`; then
    echo shar: \"'abc/bio/i4bio.h'\" unpacked with wrong size!
  fi
  # end of 'abc/bio/i4bio.h'
fi
if test -f 'abc/bio/i4out.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bio/i4out.c'\"
else
  echo shar: Extracting \"'abc/bio/i4out.c'\" \(953 characters\)
  sed "s/^X//" >'abc/bio/i4out.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X#include "b.h"
X#include "bint.h"
X#include "bmem.h"
X#include "bobj.h"
X#include "i3env.h"
X#include "i3scr.h"
X#include "i3sou.h"
X#include "i4bio.h"
X
X/* write_table_of_texts */
X
XVisible Procedure abcoutput(name_arg) char *name_arg; {
X	value name, pname;
X	value *aa;
X	value v;
X	intlet k, len;
X	
X	name= mk_text(name_arg);
X	if (!is_abcname(name)) {
X		bioerrV(IO_NAME, name);
X		release(name);
X		return;
X	}
X	pname= permkey(name, Tar);
X	if (!p_exists(pname, &aa)) {
X		bioerrV(O_INIT, name);
X		release(name);
X		release(pname);
X		return;
X	}
X	release(pname);
X	v= getval(*aa, In_tarval);
X	if (!still_ok) {
X		release(name);
X		release(v);
X		return;
X	}
X	if (!Is_table(v)) {
X		bioerrV(O_TABLE, name);
X		release(name);
X		release(v);
X		return;
X	}
X	at_nwl= Yes;
X	len= length(v);
X	for (k= 0; k<len && !Interrupted(); ++k) {
X		wri(*assoc(v, k), No, Yes, No);
X		newline();
X	}
X	release(name);
X	release(v);
X}
END_OF_FILE
  if test 953 -ne `wc -c <'abc/bio/i4out.c'`; then
    echo shar: \"'abc/bio/i4out.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bio/i4out.c'
fi
if test -f 'abc/boot/lang.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/boot/lang.h'\"
else
  echo shar: Extracting \"'abc/boot/lang.h'\" \(1192 characters\)
  sed "s/^X//" >'abc/boot/lang.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1987. */
X
X/* If you change this file, don't forget ../bhdrs/b0lan.h and bint2/i2dis.c */
X
X#define R_HOW_TO	"HOW TO "
X#define R_PASS		"PASS"
X#define R_PUT		"PUT "
X#define R_IN_put	" IN "
X#define R_INSERT	"INSERT "
X#define R_IN_insert	" IN "
X#define R_REMOVE	"REMOVE "
X#define R_FROM_remove	" FROM "
X#define R_SET_RANDOM	"SET RANDOM "
X#define R_DELETE	"DELETE "
X#define R_CHECK 	"CHECK "
X#define R_SHARE 	"SHARE "
X#define R_WRITE 	"WRITE "
X#define R_READ		"READ "
X#define R_EG		" EG "
X#define R_RAW		" RAW"
X#define R_IF		"IF "
X#define R_WHILE 	"WHILE "
X#define R_FOR		"FOR "
X#define R_IN_for	" IN "
X#define R_SELECT	"SELECT: "
X#define R_ELSE		"ELSE"
X#define R_QUIT		"QUIT"
X#define R_RETURN	"RETURN "
X#define R_REPORT	"REPORT "
X#define R_SUCCEED	"SUCCEED"
X#define R_FAIL		"FAIL"
X#define R_AND		"AND "
X#define R_OR		"OR "
X#define R_NOT		"NOT "
X#define R_SOME		"SOME "
X#define R_EACH		"EACH "
X#define R_NO		"NO "
X#define R_IN_quant	" IN "
X#define R_PARSING	" PARSING "
X#define R_HAS		" HAS "
X
X#ifdef GFX
X#define R_SPACE 	"SPACE "
X#define R_TO_space	" TO "
X#define R_LINE		"LINE "
X#define R_TO_line	" TO "
X#define R_CLEAR 	"CLEAR"
X#endif
END_OF_FILE
  if test 1192 -ne `wc -c <'abc/boot/lang.h'`; then
    echo shar: \"'abc/boot/lang.h'\" unpacked with wrong size!
  fi
  # end of 'abc/boot/lang.h'
fi
if test -f 'abc/btr/e1etex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/btr/e1etex.c'\"
else
  echo shar: Extracting \"'abc/btr/e1etex.c'\" \(1152 characters\)
  sed "s/^X//" >'abc/btr/e1etex.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X#include "b.h"
X#include "bedi.h"
X#include "bobj.h"
X#include "etex.h"
X#include "bmem.h"
X
XVisible int e_length(v) value v; {
X	return Length(v);
X}
X
XVisible value mk_etext(m) string m; {
X	value v; intlet len= strlen(m);
X	v= grab(Etex, len);
X	strcpy(Str(v), m);
X	return v;
X}
X
XVisible char e_ncharval(n, v) int n; value v; {
X	return *(Str(v)+n-1);
X}
X
XVisible string e_strval(v) value v; {
X	return Str(v);
X}
X
X
XVisible string e_sstrval(v) value v; {
X	return (string) savestr(Str(v));
X}
X
XVisible Procedure e_fstrval(s) string s; {
X	freestr(s);
X}
X
X
XVisible value e_icurtail(v, k) value v; int k; {
X	value w= grab(Etex, k);
X	strncpy(Str(w), Str(v), k);
X	*(Str(w) + k)= '\0';
X	return w;
X}
X
X
XVisible value e_ibehead(v, k) value v; int k; {
X	value w= grab(Etex, Length(v) - (k - 1));
X	strcpy(Str(w), Str(v) + k - 1);
X	return w;
X}
X
X
X
XVisible value e_concat(s, t) value s, t; {
X	value v= grab(Etex, Length(s) + Length(t));
X	strcpy(Str(v), Str(s));
X	strcpy(Str(v) + Length(s), Str(t));
X	return v;
X}
X
XVisible Procedure e_concto(s, t) value *s, t; {
X	value v= *s;
X	*s= e_concat(*s, t);
X	release(v);
X}
END_OF_FILE
  if test 1152 -ne `wc -c <'abc/btr/e1etex.c'`; then
    echo shar: \"'abc/btr/e1etex.c'\" unpacked with wrong size!
  fi
  # end of 'abc/btr/e1etex.c'
fi
if test -f 'abc/ch_all' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ch_all'\"
else
  echo shar: Extracting \"'abc/ch_all'\" \(753 characters\)
  sed "s/^X//" >'abc/ch_all' <<'END_OF_FILE'
X: 'Check if make all went allright.'
X
Xmsg="$1"
Xhlp="$2"
Xdestroot="$3"
X
Xerrors="no"
X
Xecho " "
X
Xfor f in abc abckeys
Xdo
X	if test ! -s $f
X	then
X		echo "*** Failed to make $f"
X		errors="yes"
X	fi
Xdone
X
Xcase $msg in
Xabc.mse)
X	if test ! -s abc.mse
X	then
X		echo "*** Failed to make messages file abc.mse"
X		errors="yes"
X	fi;;
Xesac
X
Xcase $hlp in
Xabc.hlp)
X	if test ! -s abc.hlp
X	then
X		echo "*** Failed to make help file abc.hlp"
X		errors="yes"
X	fi;;
Xesac
X
Xcase $errors in
Xyes)
X	exit 1
X	;;
Xno)
X	case $destroot in
X	'')	echo "The 'abc' command should now work."
X		echo "You can test the ABC interpreter with 'make examples'."
X		;;
X	*)	echo "That 'make all' went well."
X		echo "Say 'make install' to install the ABC system in $destroot."
X		;;
X	esac
X	exit 0
X	;;
Xesac
END_OF_FILE
  if test 753 -ne `wc -c <'abc/ch_all'`; then
    echo shar: \"'abc/ch_all'\" unpacked with wrong size!
  fi
  chmod +x 'abc/ch_all'
  # end of 'abc/ch_all'
fi
if test -f 'abc/ch_install' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ch_install'\"
else
  echo shar: Extracting \"'abc/ch_install'\" \(1009 characters\)
  sed "s/^X//" >'abc/ch_install' <<'END_OF_FILE'
X: 'Check if make install went allright.'
X
Xmsg="$1"
Xhlp="$2"
Xabcdir="$3"
Xlibdir="$4"
Xmandir="$5"
Xdestroot="$6"
X
Xerrors="no"
X
Xecho " "
X
Xfor f in abc abckeys
Xdo
X	if test ! -s $destroot$abcdir/$f
X	then
X		echo "*** Failed to install '$f' in $destroot$abcdir"
X		errors="yes"
X	fi
Xdone
Xfor f in $msg $hlp
Xdo
X	if test ! -s $destroot$libdir/$f
X	then
X		echo "*** Failed to install '$f' in $destroot$libdir"
X		errors="yes"
X	fi
Xdone
X
Xif test ! -s $destroot$mandir/abc.1
Xthen
X	echo "*** Failed to install 'abc.1' manual in $destroot$mandir"
X	errors="yes"
Xfi
X
Xcase $errors in
Xyes)
X	exit 1
X	;;
Xno)
X	echo "The ABC system is installed."
X	case $destroot in
X	'')	echo "You can clean up with 'make clean'.";;
X	*)	echo "You can copy from $destroot to the target machine."
X		echo "To test ABC there also copy ./ex there,"
X		echo "and use ./ex/DoExamples and ./ex/TryEditor"
X		echo "to test the interpreter and the editor, respectively."
X		echo "If all is well, you can clean up here with 'make clean'."
X		;;
X	esac
X	exit 0
X	;;	
Xesac
END_OF_FILE
  if test 1009 -ne `wc -c <'abc/ch_install'`; then
    echo shar: \"'abc/ch_install'\" unpacked with wrong size!
  fi
  chmod +x 'abc/ch_install'
  # end of 'abc/ch_install'
fi
if test -f 'abc/ch_messages' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ch_messages'\"
else
  echo shar: Extracting \"'abc/ch_messages'\" \(722 characters\)
  sed "s/^X//" >'abc/ch_messages' <<'END_OF_FILE'
X: Check whether makefile is properly edited
X
Xcase $1 in
Xabc.msg)
X	echo "First redefine MESSAGES=abc.mse in the Makefile." >&2
X	echo "Otherwise 'make all' would still use the distributed abc.msg." >&2
X	exit 1;;
Xabc.mse)
X	echo "Collecting error messages from source files to abc.mse." >&2
X	echo "After completion use 'make all' to incorporate them into abc." >&2
X	exit 0;;
X*)
X	if test -s "$1"
X	then
X		echo "Use 'make all' to incorporate your own messages file $1 into abc." >&2
X	else
X		echo "I see no messages file '$1' here." >&2
X		echo "You must create it yourself." >&2
X	fi
X	echo " " >&2
X	echo "Or redefine MESSAGES=abc.mse in the makefile" >&2
X	echo "if you want a new messages file from the source." >&2
X	exit 1;;
Xesac
END_OF_FILE
  if test 722 -ne `wc -c <'abc/ch_messages'`; then
    echo shar: \"'abc/ch_messages'\" unpacked with wrong size!
  fi
  chmod +x 'abc/ch_messages'
  # end of 'abc/ch_messages'
fi
if test -f 'abc/doc/BugReport' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/doc/BugReport'\"
else
  echo shar: Extracting \"'abc/doc/BugReport'\" \(720 characters\)
  sed "s/^X//" >'abc/doc/BugReport' <<'END_OF_FILE'
XBug Report
X
XFROM
X
XName:
X
XFirm/Institute:
X
XAddress:
X
X
X
XTelephone:
X
XInternet network address:
X
XMachine Type:      O Vax       O Sun         O PDP        O other: .......
X
XOperating System:  O 4.3 BSD   O Version 7   O System V   O other: .......
X
X==========================================================================
XABC Release 1.02.01.
X==========================================================================
X
XFAULTY PROGRAM:
X
XDESCRIPTION OF FAULT:
X
X
X
X
X
X
X
X
X
XREPEAT BY:
X
X
X
X
X
X
X
X
X==========================================================================
X
XSend to
X
X	ABC Group
X	CWI / AA
X	POB 4079
X	1009 AB  Amsterdam
X	The Netherlands
X
Xor by electronic mail to
X
X	abc@cwi.nl
X	
XFor older mailers use:
X	
X	mcvax!abc.uucp
X
END_OF_FILE
  if test 720 -ne `wc -c <'abc/doc/BugReport'`; then
    echo shar: \"'abc/doc/BugReport'\" unpacked with wrong size!
  fi
  # end of 'abc/doc/BugReport'
fi
if test -f 'abc/doc/Structure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/doc/Structure'\"
else
  echo shar: Extracting \"'abc/doc/Structure'\" \(1254 characters\)
  sed "s/^X//" >'abc/doc/Structure' <<'END_OF_FILE'
X# Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988.
X
X===========================================================================
X=  The Directory Structure of Release 1.00 of the Implementation of ABC.  =
X===========================================================================
X
X=
X= editor-interpreter directories:
X=
X
Xb	low level support (memory grabbing, option handling, etc)
X
Xbhdrs	interface include files for same
X
Xbed	editor source files
X
Xehdrs	editor include files
X
Xbint1	interpreter module for compound and number values
X
Xbtr	module for text, list and table values, using B trees
X
Xlin	module for text, list and table values, using linear structures
X
Xbint2	interpreter parser
X
Xstc	static type check
X
Xbint3	interpreter runtime system
X
Xihdrs	interpreter include files
X
Xbio	support for -[iolrR] options (interface with operating system)
X
Xuhdrs	unix specific header files
X
Xunix	unix specific source files
X
X=
X= other directories:
X=
X
Xkeys	source for utility abckeys (abc -k)
X
Xukeys	default keys definition files for some terminals
X
Xscripts	shell scripts for installation
X
Xboot	booting editor source files with grammar info
X
Xex	example B workspaces
X
Xdoc	documentation
X
Xtc	public domain sources for the termcap library needed by the editor
END_OF_FILE
  if test 1254 -ne `wc -c <'abc/doc/Structure'`; then
    echo shar: \"'abc/doc/Structure'\" unpacked with wrong size!
  fi
  # end of 'abc/doc/Structure'
fi
if test -f 'abc/ehdrs/cell.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ehdrs/cell.h'\"
else
  echo shar: Extracting \"'abc/ehdrs/cell.h'\" \(893 characters\)
  sed "s/^X//" >'abc/ehdrs/cell.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/*
X * B editor -- Definitions for linked lists of screen lines, baptized `cells'.
X * (This is NOT an abstract data type!)
X */
X
Xstruct cell {
X	struct cell *c_link;
X	node c_data;
X	short c_onscreen;
X	short c_oldindent;
X	short c_newindent;
X	short c_length;
X	char c_oldvhole;
X	char c_newvhole; /* Yes if this line contains a `vhole' */
X	char c_oldfocus;
X	char c_newfocus; /* Yes if this line contains underlining */
X};
X
Xtypedef struct cell cell;
X
X#define Cnil ((cell*) NULL)
X
X#define Nowhere (-9999)
X
X#define SpaceRound(x) ((indent + (x) + llength - 1) / llength)
X#define Space(p) \
X	SpaceRound((p)->c_length + (p)->c_newindent + (p)->c_newvhole)
X#define Oldspace(p) \
X	SpaceRound((p)->c_length + (p)->c_oldindent + (p)->c_oldvhole)
X
Xcell *replist();
Xcell *build();
X
Xextern int llength;
Xextern int winheight;
Xextern int indent;
END_OF_FILE
  if test 893 -ne `wc -c <'abc/ehdrs/cell.h'`; then
    echo shar: \"'abc/ehdrs/cell.h'\" unpacked with wrong size!
  fi
  # end of 'abc/ehdrs/cell.h'
fi
if test -f 'abc/ehdrs/erro.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ehdrs/erro.h'\"
else
  echo shar: Extracting \"'abc/ehdrs/erro.h'\" \(970 characters\)
  sed "s/^X//" >'abc/ehdrs/erro.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/*
X * B editor -- User (error) messages collected together.
X */
X
X#define COPY_EMPTY	MESS(6000, "Empty copy buffer")
X#define READ_BAD	MESS(6001, "Trouble with your how-to, see last line. Hit [interrupt] if you don't want this")
X#define EDIT_TABS	MESS(6002, "Spaces and tabs mixed for indentation; check your program layout")
X#define EXIT_HOLES	MESS(6003, "There are still holes left.  Please fill or delete these first.")
X#define GOTO_BAD	MESS(6004, "I cannot [goto] that position")
X#define GOTO_OUT	MESS(6005, "Sorry, I could not [goto] that position")
X#define GOTO_REC	MESS(6006, "You can't use [goto] in recording mode")
X#define INS_BAD		MESS(6007, "Cannot insert '%c'")
X#define PLB_NOK		MESS(6008, "No keystrokes recorded")
X#define REC_OK		MESS(6009, "Keystrokes recorded, use [play] to play back")
X#define REDO_OLD	MESS(6010, "This redo brought you to an older version.  Use [undo] to cancel")
X	
END_OF_FILE
  if test 970 -ne `wc -c <'abc/ehdrs/erro.h'`; then
    echo shar: \"'abc/ehdrs/erro.h'\" unpacked with wrong size!
  fi
  # end of 'abc/ehdrs/erro.h'
fi
if test -f 'abc/ehdrs/trm.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ehdrs/trm.h'\"
else
  echo shar: Extracting \"'abc/ehdrs/trm.h'\" \(938 characters\)
  sed "s/^X//" >'abc/ehdrs/trm.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/*
X * Terminal capabilities.  These correspond to bits set by trmstart in its
X * parameter flags parameter.
X */
X
X#define HAS_STANDOUT	1	/* Terminal has inverse video or underline */
X#define CAN_SCROLL	2	/* Terminal can insert/delete lines */
X#define CAN_OPTIMISE	4	/* Terminal can insert/delete characters */
X#define CAN_SENSE	8	/* Terminal can send cursor position */
X
X/*
X * Error codes returned by trmstart.
X */
X
X#define TE_OK		0	/* No errors */
X#define TE_TWICE	1	/* Trmstart called again */
X#define TE_NOTERM	2	/* $TERM not set or empty */
X#define TE_BADTERM	3	/* $TERM not found in termcap database */
X#define TE_DUMB		4	/* Terminal too dumb */
X#define TE_NOTTY	5	/* Stdin not a tty or cannot open "/etc/tty" */
X#define TE_NOMEM	6	/* Can't get enough memory */
X#define TE_BADSCREEN	7	/* Bad $SCREEN */
X#define TE_OTHER	8	/* This and higher are reserved errors */
END_OF_FILE
  if test 938 -ne `wc -c <'abc/ehdrs/trm.h'`; then
    echo shar: \"'abc/ehdrs/trm.h'\" unpacked with wrong size!
  fi
  # end of 'abc/ehdrs/trm.h'
fi
if test -f 'abc/ex/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ex/README'\"
else
  echo shar: Extracting \"'abc/ex/README'\" \(793 characters\)
  sed "s/^X//" >'abc/ex/README' <<'END_OF_FILE'
XThe subdirectories here represent ABC workspaces, with example ABC how-to's.
X
XWith DoExamples, the ABC interpreter in .. is tested (via the shell
Xcommand '../abc') on the following four examples:
X
X	generate	generates new sentences based on those supplied
X			by the user;
X	hanoi		the towers of hanoi;
X	pi		calculates the value of pi, using the unbounded
X			arithmetic of ABC;
X	xref		a cross reference generator.
X
XFor more information on these programs, see the B Newsletter, Issue 2.
X
XThe ABC editor can only be tested by calling ../abc interactively, as
Xis done by TryEditor.
XFor this the 'try' workspace has been created from the 'generate' example,
Xso you can always regenerate it with:
X
X        cd  ./generate
X        cp  *  ../try
X
XThe file ../README2 tells you how to try the ABC editor.
END_OF_FILE
  if test 793 -ne `wc -c <'abc/ex/README'`; then
    echo shar: \"'abc/ex/README'\" unpacked with wrong size!
  fi
  # end of 'abc/ex/README'
fi
if test -f 'abc/ex/TryEditor' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ex/TryEditor'\"
else
  echo shar: Extracting \"'abc/ex/TryEditor'\" \(973 characters\)
  sed "s/^X//" >'abc/ex/TryEditor' <<'END_OF_FILE'
X: 'test ABC editor'
X
Xcase $1 in
Xlocal)	abc=../abc;;
X*)	abc=abc;;
Xesac
X
Xcat <<EOF
XYou're about to try the ABC editor.
X
XFirst wait for the prompt '>>> ?' to appear.
XThen press 's' to get 'S?ELECT:'.
XNext press 't' to see 'ST?ART'.
XNow press the [TAB]-key to accept this suggestion.
XFinally press the [RETURN]-key to start execution.
X
XABC will prompt with '?' for some lines of text, until you type an empty line.
XAfter some time it will then generate a small poem from your twisted text.
X
XYou can undo any change by pressing [BACKSPACE].
XYou can get help with ? or [ESC]-?.
XYou can leave the ABC editor with [ESC]-[ESC].
XYou can leave 'abc' by typing QUIT.
X
XSee 'HOW TO TRY THE ABC EDITOR' in README2 for more information.
X
XLoading ABC ...
X
XEOF
X
X$abc -W `pwd` -w try
X
Xecho " "
Xecho "If you are satisfied about the ABC editor"
Xcase $1 in
Xlocal)	echo "you can make ABC public with 'make install'.";;
X*)	echo "you can clean on the compilation machine with 'make clean'.";;
Xesac
END_OF_FILE
  if test 973 -ne `wc -c <'abc/ex/TryEditor'`; then
    echo shar: \"'abc/ex/TryEditor'\" unpacked with wrong size!
  fi
  chmod +x 'abc/ex/TryEditor'
  # end of 'abc/ex/TryEditor'
fi
if test -f 'abc/ex/generate.out' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ex/generate.out'\"
else
  echo shar: Extracting \"'abc/ex/generate.out'\" \(441 characters\)
  sed "s/^X//" >'abc/ex/generate.out' <<'END_OF_FILE'
XMary had a little lamb,
XIts fleece was white as snow,
XAnd everywhere that Mary went,
XThat lamb was sure to go.
X
XIts whittle as whittle that lamb,
XMarywhittleece to go.
XIts sure as snow,
XThat Mary wherywhery was went,
X
XThat Mary hat Marywhere to go.
XIts was sure that lamb was fle lamb,
XIts snow,
XIts sure lite to go.
X
XAnd a lite went,
XAnd evere a lite to go.
XAnd evere where thad every was was where to go.
XMary where thad a lamb was went,
X
END_OF_FILE
  if test 441 -ne `wc -c <'abc/ex/generate.out'`; then
    echo shar: \"'abc/ex/generate.out'\" unpacked with wrong size!
  fi
  # end of 'abc/ex/generate.out'
fi
if test -f 'abc/ihdrs/i2exp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ihdrs/i2exp.h'\"
else
  echo shar: Extracting \"'abc/ihdrs/i2exp.h'\" \(1136 characters\)
  sed "s/^X//" >'abc/ihdrs/i2exp.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/* General definitions for parsing expressions */
X
X#ifdef macintosh
X/* Avoid conflict with extra reserved word: */
X#define comp b_comp
X#endif
X
Xtypedef struct {							
X	parsetree *stack;
X	parsetree *sp;
X	parsetree *top;
X	int nextend;
X	char level;		/* PARSER or FIXER */
X	char /* bool */ prop;	/* Yes while fixing left expr dya pred */
X	intlet nfield;		/* fieldnr unparsed node during fixing */
X} expadm;
X
X#define Stack(adm)	(adm->stack)
X#define Sp(adm)		(adm->sp)
X#define Top(adm)	(adm->top)
X#define Nextend(adm)	(adm->nextend)
X#define Level(adm)	(adm->level)
X#define Prop(adm)	(adm->prop)
X#define Nfld(adm)	(adm->nfield)
X
X#define N_EXP_STACK	15
X#define N_LTA_STACK	100
X
X#define Pop(adm)	*--Sp(adm)
X
X#define PARSER 'p'
X#define FIXER  'f'
X
X#define Bottom "$"
X
X#define Dya_opr(v) (Valid(v) && Is_compound(v))
X
X/************************************************************************/
X
Xstruct prio {
X	string fun;
X	char adic;
X	int L, H;
X};
X
X#define P_mon '1'
X#define P_dya '2'
X
X#define dprio(i) pprio(i, P_dya)
X#define mprio(i) pprio(i, P_mon)
X
Xstruct prio * pprio();
X
X
END_OF_FILE
  if test 1136 -ne `wc -c <'abc/ihdrs/i2exp.h'`; then
    echo shar: \"'abc/ihdrs/i2exp.h'\" unpacked with wrong size!
  fi
  # end of 'abc/ihdrs/i2exp.h'
fi
if test -f 'abc/ihdrs/i3env.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ihdrs/i3env.h'\"
else
  echo shar: Extracting \"'abc/ihdrs/i3env.h'\" \(872 characters\)
  sed "s/^X//" >'abc/ihdrs/i3env.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/* environments and context */
X
Xtypedef struct {
X	value uname;
X	env curnv;
X	value r_names, *bndtgs;
X	literal cntxt, resexp;
X	parsetree cur_line;
X	value cur_lino;
X} context;
X
X#define Enil ((env) NULL)
X
X/* contexts: */
X#define In_command 'c'
X#define In_read '?'
X#define In_unit 'u'
X#define In_edval 'e'
X#define In_tarval 't'
X#define In_prmnv 'p'
X#define In_wsgroup 'w'
X
X/* results */
X#define Ret 'V'
X#define Rep '+'
X#define Voi ' '
X
Xvalue* envassoc();
X
Xextern env curnv; extern value *bndtgs;
Xextern literal cntxt, resexp; extern value uname;
Xextern value errtname;
Xextern intlet lino;
Xextern intlet f_lino;
Xextern intlet i_lino;
X
Xextern context read_context;
X
Xextern envtab prmnvtab;
Xextern envchain prmnvchain;
Xextern env prmnv;
X
Xextern intlet errlino;
Xextern parsetree curline;
Xextern value curlino;
X
END_OF_FILE
  if test 872 -ne `wc -c <'abc/ihdrs/i3env.h'`; then
    echo shar: \"'abc/ihdrs/i3env.h'\" unpacked with wrong size!
  fi
  # end of 'abc/ihdrs/i3env.h'
fi
if test -f 'abc/ihdrs/i3int.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ihdrs/i3int.h'\"
else
  echo shar: Extracting \"'abc/ihdrs/i3int.h'\" \(698 characters\)
  sed "s/^X//" >'abc/ihdrs/i3int.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/* Interpreter */
X
Xvalue pop();
X/* Procedure push(); */
X
X#define Stop ((parsetree)zero) /* Legal stop */
X#define Halt NilTree /* Illegal stop (loose end of code) */
X
Xextern int call_level;
X
X#define _Thread(t) *Branch(t, Nbranches(t)) /* Next instruction */
X#define _Thread2(t) *Branch(t, Nbranches(t)+1) /* Alternate next instr. or flag */
X
X#ifdef MSDOS
X#ifdef M_I86LM
X
X#define Thread(t) (*_thread(t))
X#define Thread2(t) (*_thread2(t))
Xparsetree *_thread();
Xparsetree *_thread2();
X
X#endif /* M_I86LM */
X#endif /* MSDOS */
X
X#ifndef Thread
X#define Thread(t) _Thread(t)
X#endif
X#ifndef Thread2
X#define Thread2(t) _Thread2(t)
X#endif
END_OF_FILE
  if test 698 -ne `wc -c <'abc/ihdrs/i3int.h'`; then
    echo shar: \"'abc/ihdrs/i3int.h'\" unpacked with wrong size!
  fi
  # end of 'abc/ihdrs/i3int.h'
fi
if test -f 'abc/scripts/Change' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/scripts/Change'\"
else
  echo shar: Extracting \"'abc/scripts/Change'\" \(1083 characters\)
  sed "s/^X//" >'abc/scripts/Change' <<'END_OF_FILE'
X: 'Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. '
X
X: 'Change error messages in limited number of files'
X
X: 'This should be called locally in the directory of the concerning files!'
X
Xcase $1 in
X''|-*)	echo "Usage: $0 [start [step]] file ..." 1>&2; exit 1;;
X[0-9]*) start=$1; shift;
X	case $1 in
X	[0-9]*) step=$1; shift;;
X	*) step=100;;
X	esac;;
X*)	start=100; step=100;;
Xesac
X
Xfor file
Xdo
X	if test -f $file.orig
X	then
X		echo $file.orig already exists, $file skipped
X	else
X		mv $file $file.orig || exit
X		echo $file $start
X		sed 's/MESS([0-9]*/MESS($/' $file.orig |
X		awk "BEGIN {messnum=$start}"'
X			/MESS\(/ {n=split($0, field, "$");
X			 for (i=1; i<= n; i++) {
X			  if (i==2) {printf "%d", messnum; ++messnum}
X			  if (i>2) printf "$"
X			  printf "%s", field[i]
X			 }
X			 printf "\n"
X			}
X			!/MESS\(/ {print}' >$file
X		if test -s $file
X		then
X			if cmp -s $file.orig $file
X			then
X				mv $file.orig $file
X				echo $file unchanged
X			else
X				start=`expr $start + $step`
X			fi
X		else
X			mv $file.orig $file
X			echo $file clobbered, old version put back
X		fi
X	fi
Xdone
END_OF_FILE
  if test 1083 -ne `wc -c <'abc/scripts/Change'`; then
    echo shar: \"'abc/scripts/Change'\" unpacked with wrong size!
  fi
  chmod +x 'abc/scripts/Change'
  # end of 'abc/scripts/Change'
fi
if test -f 'abc/scripts/Collect' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/scripts/Collect'\"
else
  echo shar: Extracting \"'abc/scripts/Collect'\" \(1178 characters\)
  sed "s/^X//" >'abc/scripts/Collect' <<'END_OF_FILE'
X: sh or ksh script
X
X# Collect error messages from source files.
X#
X# Messages must have the form MESS(number, "string") and be contained
X# on one line.  They are output in the form
X# 	number [star] tab string
X# where [star] is a * after the number, present for system errors.
X# System errors are those lines that also contain the text "syserr" or
X# "SMESS"; the message number is repeated in the message text.
X# There are some more conventions for error messages, in particular
X# \n is replaced by a newline character, and %s may be replaced by
X# a parameter (e.g., ("you haven't yold me HOW TO %s").
X#
X# This script is called from the Makefile.  Its arguments are the files
X# from which messages must be collected.  The list of messages, sorted
X# by number, appears on the output.
X#
X# Since this script is somewhat naive, the output should be inspected
X# carefully (you might do a 'diff abc.msg abc.mse').
X# There is a companion script, Change, which assigns new numbers to
X# messages.
X
Xgrep 'MESS([0-9]' $* |
Xsed '/syserr/s/.*MESS(\([0-9]*\), *"\(.*\)").*/\1*	\2 (\1)/
X	/SMESS/s/.*MESS(\([0-9]*\), *"\(.*\)").*/\1*	\2 (\1)/
X	s/.*MESS(\([0-9]*\), *"\(.*\)").*/\1	\2/' |
Xsort -n
END_OF_FILE
  if test 1178 -ne `wc -c <'abc/scripts/Collect'`; then
    echo shar: \"'abc/scripts/Collect'\" unpacked with wrong size!
  fi
  chmod +x 'abc/scripts/Collect'
  # end of 'abc/scripts/Collect'
fi
if test -f 'abc/stc/DEP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/stc/DEP'\"
else
  echo shar: Extracting \"'abc/stc/DEP'\" \(971 characters\)
  sed "s/^X//" >'abc/stc/DEP' <<'END_OF_FILE'
Xi2tca.o: i2tca.c
Xi2tca.o: ../bhdrs/b.h
Xi2tca.o: ../uhdrs/osconf.h
Xi2tca.o: ../uhdrs/os.h
Xi2tca.o: ../uhdrs/conf.h
Xi2tca.o: ../uhdrs/config.h
Xi2tca.o: ../bhdrs/bmem.h
Xi2tca.o: ../bhdrs/bfil.h
Xi2tca.o: ../bhdrs/bint.h
Xi2tca.o: ../bhdrs/bobj.h
Xi2tca.o: ../bhdrs/b0lan.h
Xi2tca.o: ../ihdrs/i2nod.h
Xi2tca.o: ../ihdrs/i2par.h
Xi2tca.o: ./i2stc.h
Xi2tca.o: ../ihdrs/i3env.h
Xi2tca.o: ../ihdrs/i3sou.h
Xi2tce.o: i2tce.c
Xi2tce.o: ../bhdrs/b.h
Xi2tce.o: ../uhdrs/osconf.h
Xi2tce.o: ../uhdrs/os.h
Xi2tce.o: ../uhdrs/conf.h
Xi2tce.o: ../uhdrs/config.h
Xi2tce.o: ../bhdrs/bobj.h
Xi2tce.o: ./i2stc.h
Xi2tce.o: ../ihdrs/i2nod.h
Xi2tcp.o: i2tcp.c
Xi2tcp.o: ../bhdrs/b.h
Xi2tcp.o: ../uhdrs/osconf.h
Xi2tcp.o: ../uhdrs/os.h
Xi2tcp.o: ../uhdrs/conf.h
Xi2tcp.o: ../uhdrs/config.h
Xi2tcp.o: ../bhdrs/bobj.h
Xi2tcp.o: ./i2stc.h
Xi2tcu.o: i2tcu.c
Xi2tcu.o: ../bhdrs/b.h
Xi2tcu.o: ../uhdrs/osconf.h
Xi2tcu.o: ../uhdrs/os.h
Xi2tcu.o: ../uhdrs/conf.h
Xi2tcu.o: ../uhdrs/config.h
Xi2tcu.o: ../bhdrs/bobj.h
Xi2tcu.o: ./i2stc.h
END_OF_FILE
  if test 971 -ne `wc -c <'abc/stc/DEP'`; then
    echo shar: \"'abc/stc/DEP'\" unpacked with wrong size!
  fi
  # end of 'abc/stc/DEP'
fi
if test -f 'abc/tc/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/tc/Makefile'\"
else
  echo shar: Extracting \"'abc/tc/Makefile'\" \(882 characters\)
  sed "s/^X//" >'abc/tc/Makefile' <<'END_OF_FILE'
XCFLAGS	      = -O -DCM_N -DCM_GT -DCM_B -DCM_D
X
XDEST	      = ..
X
XETC	      = ..
X
XHDRS	      =
X
XLIBRARY	      = libtermcap.a
X
XMAKEFILE      = Makefile
X
XOBJS	      = termcap.o tgoto.o tputs.o
X
XPRINT	      = print
X
XSRCS	      = tc1.c tc2.c tc3.c \
X		termcap.c tgoto.c tputs.c
X
Xall:		$(LIBRARY)
X
X$(LIBRARY):	$(OBJS)
X		ar cru $(LIBRARY) $(OBJS)
X		ranlib $(LIBRARY)
X
Xclean:;		@rm -f $(OBJS) $(LIBRARY) tc1 tc2 tc3 tc1.o tc2.o tc3.o
X
Xindex:;		@ctags -wx $(HDRS) $(SRCS)
X
Xinstall:	library termcap
X
Xtermcap:
X		cp termcap $(ETC)
X
Xlibrary:        $(LIBRARY)
X		cp $(LIBRARY) $(DEST)
X
Xdatabase:
X		cp termcap $(ETC)
X
Xprint:;		@$(PRINT) $(HDRS) $(SRCS)
X
Xtags:           $(HDRS) $(SRCS); @ctags $(HDRS) $(SRCS)
X
Xtc1:		tc1.o $(LIBRARY)
X		cc $(CFLAGS) tc1.o $(LIBRARY) -o tc1
Xtc2:		tc1.o $(LIBRARY)
X		cc $(CFLAGS) tc1.o $(LIBRARY) -o tc2
Xtc3:		tc1.o $(LIBRARY)
X		cc $(CFLAGS) tc1.o $(LIBRARY) -o tc3
END_OF_FILE
  if test 882 -ne `wc -c <'abc/tc/Makefile'`; then
    echo shar: \"'abc/tc/Makefile'\" unpacked with wrong size!
  fi
  # end of 'abc/tc/Makefile'
fi
if test -f 'abc/tc/tc2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/tc/tc2.c'\"
else
  echo shar: Extracting \"'abc/tc/tc2.c'\" \(814 characters\)
  sed "s/^X//" >'abc/tc/tc2.c' <<'END_OF_FILE'
X/*
X * tc2 [term]
X * Dummy program to test out termlib.
X * Commands are "tcc\n" where t is type (s for string, f for flag,
X * or n for number) and cc is the name of the capability.
X */
X#include <stdio.h>
Xchar buf[1024];
Xchar *getenv(), *tgetstr();
X
Xmain(argc, argv) char **argv; {
X	char *p, *q;
X	int rc;
X	char b[3], c;
X	char area[200];
X
X	if (argc < 2)
X		p = getenv("TERM");
X	else
X		p = argv[1];
X	rc = tgetent(buf,p);
X	for (;;) {
X		c = getchar();
X		if (c < 0)
X			exit(0);
X		b[0] = getchar();
X		if (b[0] < ' ')
X			exit(0);
X		b[1] = getchar();
X		b[2] = 0;
X		getchar();
X		switch(c) {
X			case 'f':
X				printf("%s: %d\n",b,tgetflag(b));
X				break;
X			case 'n':
X				printf("%s: %d\n",b,tgetnum(b));
X				break;
X			case 's':
X				q = area;
X				printf("%s: %s\n",b,tgetstr(b,&q));
X				break;
X			default:
X				exit(0);
X		}
X	}
X}
END_OF_FILE
  if test 814 -ne `wc -c <'abc/tc/tc2.c'`; then
    echo shar: \"'abc/tc/tc2.c'\" unpacked with wrong size!
  fi
  # end of 'abc/tc/tc2.c'
fi
if test -f 'abc/uhdrs/conf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/uhdrs/conf.h'\"
else
  echo shar: Extracting \"'abc/uhdrs/conf.h'\" \(867 characters\)
  sed "s/^X//" >'abc/uhdrs/conf.h' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/* Most machine-dependent changes are done automatically by mkconfig,	*/
X/* the results of which can be found in config.h.			*/
X/* You only need to change this file conf.h under rare circumstances.	*/
X
X/* Miscellaneous definitions*/
Xtypedef int expint;		/*The 2nd argument of frexp points to this */
X				/*(see manual page frexp(3)).              */
X				/*On some 68K systems must be short (foo!) */
X
X#define Maxtrig 1e16		/*Max x for sin(x), cos(x), tan(x)         */
X				/*(Can anybody find a way to compute this  */
X				/*automatically?)                          */
X
X#define MaxSmallInt (BASE-1) /* This must be so! */
X#define MinSmallInt (-BASE) /* This must be so!!! */
X
X#define SEED getpid()		/*Any suitable random int (eg date or time) */
X				/*to start the random number generator with */
END_OF_FILE
  if test 867 -ne `wc -c <'abc/uhdrs/conf.h'`; then
    echo shar: \"'abc/uhdrs/conf.h'\" unpacked with wrong size!
  fi
  # end of 'abc/uhdrs/conf.h'
fi
if test -f 'abc/uhdrs/dir.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/uhdrs/dir.h'\"
else
  echo shar: Extracting \"'abc/uhdrs/dir.h'\" \(1070 characters\)
  sed "s/^X//" >'abc/uhdrs/dir.h' <<'END_OF_FILE'
X/* slightly edited for ABC from public domain source */
X
X#ifndef DEV_BSIZE
X#define	DEV_BSIZE	512
X#endif
X#define DIRBLKSIZ	DEV_BSIZE
X#define	MAXNAMLEN	255
X
Xstruct	direct {
X	long	d_ino;			/* inode number of entry */
X	short	d_reclen;		/* length of this record */
X	short	d_namlen;		/* length of string in d_name */
X	char	d_name[MAXNAMLEN + 1];	/* name must be no longer than this */
X};
X
X/*
X * The DIRSIZ macro gives the minimum record length which will hold
X * the directory entry.  This requires the amount of space in struct direct
X * without the d_name field, plus enough space for the name with a terminating
X * null byte (dp->d_namlen+1), rounded up to a 4 byte boundary.
X */
X#undef DIRSIZ
X#define DIRSIZ(dp) \
X    ((sizeof (struct direct) - (MAXNAMLEN+1)) + (((dp)->d_namlen+1 + 3) &~ 3))
X
X/*
X * Definitions for library routines operating on directories.
X */
Xtypedef struct _dirdesc {
X	int	dd_fd;
X	long	dd_loc;
X	long	dd_size;
X	char	dd_buf[DIRBLKSIZ];
X} DIR;
X#ifndef NULL
X#define NULL 0
X#endif
Xextern	DIR *opendir();
Xextern	struct direct *readdir();
Xextern	closedir();
END_OF_FILE
  if test 1070 -ne `wc -c <'abc/uhdrs/dir.h'`; then
    echo shar: \"'abc/uhdrs/dir.h'\" unpacked with wrong size!
  fi
  # end of 'abc/uhdrs/dir.h'
fi
if test -f 'abc/ukeys/abckeys_2621' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ukeys/abckeys_2621'\"
else
  echo shar: Extracting \"'abc/ukeys/abckeys_2621'\" \(668 characters\)
  sed "s/^X//" >'abc/ukeys/abckeys_2621' <<'END_OF_FILE'
X# HP2621 terminal
X# display screen labels f1-f8 upon startup, config-edit after exit:
X[term-init]       = "\033&jB" = ""
X[term-done]       = "\033&jA" = ""
X# use first four standard:
X[widen]    = "\033p\015" = "f1"
X[extend]   = "\033q\015" = "f2"
X[first]    = "\033r\015" = "f3"
X[last]     = "\033s\015" = "f4"
X# because arrow keys are drawn on the keyboards keys:
X[up]       = "\033t\015" = "f5"
X[left]     = "\033u\015" = "f6"
X[right]    = "\033v\015" = "f7"
X[down]     = "\033w\015" = "f8"
X# which makes rebind for following four necessary:
X[previous] = "\033[" = "ESC-["
X[next]     = "\033]" = "ESC-]"
X[upline]   = "\033k" = "ESC-k"
X[downline] = "\033j" = "ESC-j"
END_OF_FILE
  if test 668 -ne `wc -c <'abc/ukeys/abckeys_2621'`; then
    echo shar: \"'abc/ukeys/abckeys_2621'\" unpacked with wrong size!
  fi
  # end of 'abc/ukeys/abckeys_2621'
fi
if test -f 'abc/ukeys/abckeys_5620' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ukeys/abckeys_5620'\"
else
  echo shar: Extracting \"'abc/ukeys/abckeys_5620'\" \(696 characters\)
  sed "s/^X//" >'abc/ukeys/abckeys_5620' <<'END_OF_FILE'
X# Key bindings for the BLIT (TERM=5620).
X# Warning: this resets your function keys!
X
X# Initialize the function keys.
X
X[term-init]="[5620 PF keys]\r\n\e[1;2q\ew\e[2;2q\ee\e[3;2q\ef\e[4;2q\el\e[5;2q\ep\e[6;2q\en\e[7;2q\eu\e[8;2q\ed" = ""
X
X# Function key bindings are as in b(1) manual.
X# (Should reorder because of 3-2-3 lay-out?)
X
X[widen]		= "\ew" = "f1"
X[extend]	= "\ee" = "f2"
X[first]		= "\ef" = "f3"
X[last]		= "\el" = "f4"
X[previous] 	= "\ep" = "f5"
X[next]	 	= "\en" = "f6"
X[upline]	= "\eu" = "f7"
X[downline]	= "\ed" = "f8"
X
X# Find some use for HOME and HOME DOWN keys.
X
X[upline]	= "\e[H" = "Arrow-Home"
X[downline]	= "\e[70;1H" = "Arrow-Home-Down"
X
X# Ignore CLEAR key.
X
X[ignore]	= "\e[2J" = ""
END_OF_FILE
  if test 696 -ne `wc -c <'abc/ukeys/abckeys_5620'`; then
    echo shar: \"'abc/ukeys/abckeys_5620'\" unpacked with wrong size!
  fi
  # end of 'abc/ukeys/abckeys_5620'
fi
if test -f 'abc/ukeys/abckeys_5620-2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ukeys/abckeys_5620-2'\"
else
  echo shar: Extracting \"'abc/ukeys/abckeys_5620-2'\" \(707 characters\)
  sed "s/^X//" >'abc/ukeys/abckeys_5620-2' <<'END_OF_FILE'
X# Key bindings for the 5620-2 (5620 with new ROMs), my personal preferences.
X# (Guido)
X
X# Initialize the function keys.
X
X[term-init]="[Changing PF keys!]\r\n\e[1;2q\eW\e[2;2q\eF\e[3;2q\eL\e[4;2q\eb\e[5;2q\ef\e[6;2q\es\e[7;2q\er\e[8;2q\ep" = ""
X
X# 5 function key bindings are the same as for BE, F6-F8 are different.
X
X[widen]		= "\eW" = "f1"
X[first]		= "\eF" = "f2"
X[last]		= "\eL" = "f3"
X
X[previous]	= "\eb" = "f4"
X[next]		= "\ef" = "f5"
X
X[copy]		= "\es" = "f6"
X[redo]		= "\er" = "f7"
X[extend]	= "\ep" = "f8"
X
X# Find some use for CLEAR, HOME and HOME DOWN keys.
X
X[upline]	= "\e[H"	= "HOME"
X[downline]	= "\e[70;1H"	= "HOME-DOWN"
X[look]		= "\e[2J"	= "CLEAR"
X
X# Bind DEL to [delete]
X
X[delete]	= "\177"	= "DEL"
END_OF_FILE
  if test 707 -ne `wc -c <'abc/ukeys/abckeys_5620-2'`; then
    echo shar: \"'abc/ukeys/abckeys_5620-2'\" unpacked with wrong size!
  fi
  # end of 'abc/ukeys/abckeys_5620-2'
fi
if test -f 'abc/ukeys/abckeys_5620-e' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ukeys/abckeys_5620-e'\"
else
  echo shar: Extracting \"'abc/ukeys/abckeys_5620-e'\" \(799 characters\)
  sed "s/^X//" >'abc/ukeys/abckeys_5620-e' <<'END_OF_FILE'
X# Key bindings for the BLIT when using Steven's 'btty' driver.
X# Function keys are compatible with BE, not with the 'standard B' function
X# key numbering, which looks odd with the 3-2-3 arrangement of the DMD's function keys.
X# Warning: this resets your function keys!
X
X# Initialize the function keys.
X
X[term-init]="[5620-e PF keys]\r\n\e[1;3q\ep\r\e[2;3q\eq\r\e[3;3q\er\r\e[4;3q\eu\r\e[5;3q\ev\r\e[6;1q\3\e[7;1q\25\e[8;3q\es\r" = ""
X
X[widen]		= "\ep\r" = "f1"
X[first]		= "\eq\r" = "f2"
X[last]		= "\er\r" = "f3"
X
X[previous]	= "\eu\r" = "f4"
X[next]		= "\ev\r" = "f5"
X
X[upline]	= "\et\r" = "f7"
X[downline]	= "\ew\r" = "f8"
X
X# Find some use for HOME, HOME DOWN, DEL and CLEAR keys.
X
X[upline]	= "\e[H"	= "HOME"
X[downline]	= "\e[70;1H"	= "HOME-DOWN"
X[delete]	= "\177"	= "DEL"
X[look]		= "\e[2J"	= "CLEAR"
END_OF_FILE
  if test 799 -ne `wc -c <'abc/ukeys/abckeys_5620-e'`; then
    echo shar: \"'abc/ukeys/abckeys_5620-e'\" unpacked with wrong size!
  fi
  # end of 'abc/ukeys/abckeys_5620-e'
fi
if test -f 'abc/ukeys/abckeys_adm31' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/ukeys/abckeys_adm31'\"
else
  echo shar: Extracting \"'abc/ukeys/abckeys_adm31'\" \(781 characters\)
  sed "s/^X//" >'abc/ukeys/abckeys_adm31' <<'END_OF_FILE'
X[widen]        = "\027" = "Cmnd-W"
X[extend]       = "\005" = "Cmnd-E"
X[first]        = "\006" = "Cmnd-F"
X[last]         = "\014" = "Cmnd-L"
X[previous]     = "\020" = "Cmnd-P"
X[next]         = "\016" = "Cmnd-N"
X[upline]       = "\025" = "Cmnd-U"
X[downline]     = "\004" = "Cmnd-D"
X[up]           = "\017" = "Cmnd-Uparrow"
X[down]         = "\035" = "Cmnd-Downarrow"
X[left]         = "\013" = "Cmnd-Leftarrow"
X[right]        = "\012" = "Cmnd-Rightarrow"
X[redo]         = "\001" = "Cmnd-A"
X[copy]         = "\026" = "Cmnd-V"
X[copy]         = "\031" = "Cmnd-Y"
X[copy]         = "\002" = "Cmnd-B"
X[delete]       = "\030" = "Cmnd-X"
X[record]       = "\022" = "Cmnd-R"
X[playback]     = "\024" = "Cmnd-T"
X[look]         = "\033l" = "ESC-l"
X[term-init]    = "" = ""
X[term-done]    = "" = ""
END_OF_FILE
  if test 781 -ne `wc -c <'abc/ukeys/abckeys_adm31'`; then
    echo shar: \"'abc/ukeys/abckeys_adm31'\" unpacked with wrong size!
  fi
  # end of 'abc/ukeys/abckeys_adm31'
fi
if test -f 'abc/unix/u1edit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/unix/u1edit.c'\"
else
  echo shar: Extracting \"'abc/unix/u1edit.c'\" \(698 characters\)
  sed "s/^X//" >'abc/unix/u1edit.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X/* edit via another editor */
X
X#include "b.h"
X#include "bfil.h"
X
X#define COML 200
XHidden char com_line[COML];
X#define At_eos(s) ((s)+= strlen(s))
X
XVisible Procedure ed_file(fname, line) string fname; intlet line; {
X	string cl= com_line;
X	strcpy(cl, editor);
X	if (*(cl+strlen(cl)-1) == '+') {
X		if (line != 0) sprintf(At_eos(cl), "%d", line);
X		else *(cl+strlen(cl)-1)= ' ';
X	}
X	app_fname(At_eos(cl), fname);
X	system(com_line);
X}
X
XHidden Procedure app_fname(ceos, fname) string ceos; string fname; {
X	intlet k, len= strlen(fname);
X	*ceos++= ' ';
X	for (k= 0; k<len; ++k) {
X		*ceos++= '\\';
X		*ceos++= *fname++;
X	}
X	*ceos= '\0';
X}
END_OF_FILE
  if test 698 -ne `wc -c <'abc/unix/u1edit.c'`; then
    echo shar: \"'abc/unix/u1edit.c'\" unpacked with wrong size!
  fi
  # end of 'abc/unix/u1edit.c'
fi
if test -f 'abc/unix/u1os.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/unix/u1os.c'\"
else
  echo shar: Extracting \"'abc/unix/u1os.c'\" \(976 characters\)
  sed "s/^X//" >'abc/unix/u1os.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X#include "b.h"
X#include "feat.h"
X
X#ifndef NDEBUG
X
X/* Assertion error */
X
XVisible Procedure asserr(file, line) string file; int line; {
X
X	putSDstr(errfile, "Assertion failed: file %s, line %d\n", file, line);
X	trmend(); /* quick hack to reset ttymodes */
X	bye(-1);
X}
X
X#endif /* !NDEBUG */
X
X#ifndef HAS_GETWD
X
X/* getwd - get working directory */
X
XVisible char *getwd(buf) char *buf; {
X	FILE *fp;
X
X	*buf = 0;
X	if ((fp=popen("pwd", "r")) == 0 ) {
X		strcpy(buf, "cannot execute pwd");
X		return(0);
X	}
X	if (fgets(buf, 1024, fp) )
X		buf[strlen(buf)-1] = 0;
X	pclose(fp);
X	if (*buf == '/')
X		return buf;
X	else
X		return (char*) NULL;
X}
X
X#endif /* !HAS_GETWD */
X
X#ifndef HAS_RENAME
X
X/* rename - rename a file */
X
XVisible Procedure rename(from, to) char *from, *to; {
X	int i;
X
X	if( (i=link(from, to)) < 0 ) return(i);
X	if( (i=unlink(from)) < 0 ) {
X		unlink(to);
X		return(i);
X	}
X	return(0);
X}
X
X#endif /* !HAS_RENAME */
END_OF_FILE
  if test 976 -ne `wc -c <'abc/unix/u1os.c'`; then
    echo shar: \"'abc/unix/u1os.c'\" unpacked with wrong size!
  fi
  # end of 'abc/unix/u1os.c'
fi
echo shar: End of archive 24 \(of 25\).
cp /dev/null ark24isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0 # Just in case...
