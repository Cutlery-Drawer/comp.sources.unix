Subject:  v23i084:  ABC interactive programming environment, Part05/25
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: 224c79f8 954feef4 fe09aa85 4d07f6a4

Submitted-by: Steven Pemberton <steven@cwi.nl>
Posting-number: Volume 23, Issue 84
Archive-name: abc/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  abc/bio/DEP abc/btr/i1lta.c abc/tc/termcap.5
# Wrapped by rsalz@litchi.bbn.com on Mon Dec 17 13:27:54 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 25)."'
if test -f 'abc/bio/DEP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bio/DEP'\"
else
  echo shar: Extracting \"'abc/bio/DEP'\" \(1990 characters\)
  sed "s/^X//" >'abc/bio/DEP' <<'END_OF_FILE'
Xi4bio.o: i4bio.c
Xi4bio.o: ../bhdrs/b.h
Xi4bio.o: ../uhdrs/osconf.h
Xi4bio.o: ../uhdrs/os.h
Xi4bio.o: ../uhdrs/conf.h
Xi4bio.o: ../uhdrs/config.h
Xi4bio.o: ../bhdrs/bint.h
Xi4bio.o: ../bhdrs/bmem.h
Xi4bio.o: ../bhdrs/bobj.h
Xi4bio.o: ../ihdrs/i2par.h
Xi4bio.o: ../ihdrs/i3scr.h
Xi4bio.o: ../ihdrs/i3sou.h
Xi4bio.o: ./i4bio.h
Xi4fil.o: i4fil.c
Xi4fil.o: ../bhdrs/b.h
Xi4fil.o: ../uhdrs/osconf.h
Xi4fil.o: ../uhdrs/os.h
Xi4fil.o: ../uhdrs/conf.h
Xi4fil.o: ../uhdrs/config.h
Xi4fil.o: ../bhdrs/bfil.h
Xi4fil.o: ../bhdrs/bmem.h
Xi4fil.o: ../bhdrs/bobj.h
Xi4fil.o: ../ihdrs/i3sou.h
Xi4grp.o: i4grp.c
Xi4grp.o: ../bhdrs/b.h
Xi4grp.o: ../uhdrs/osconf.h
Xi4grp.o: ../uhdrs/os.h
Xi4grp.o: ../uhdrs/conf.h
Xi4grp.o: ../uhdrs/config.h
Xi4grp.o: ../bhdrs/bfil.h
Xi4grp.o: ../bhdrs/bobj.h
Xi4grp.o: ../ihdrs/i3bws.h
Xi4grp.o: ../ihdrs/i3sou.h
Xi4grp.o: ./i4bio.h
Xi4inp.o: i4inp.c
Xi4inp.o: ../bhdrs/b.h
Xi4inp.o: ../uhdrs/osconf.h
Xi4inp.o: ../uhdrs/os.h
Xi4inp.o: ../uhdrs/conf.h
Xi4inp.o: ../uhdrs/config.h
Xi4inp.o: ../bhdrs/bmem.h
Xi4inp.o: ../bhdrs/bobj.h
Xi4inp.o: ./i4bio.h
Xi4lis.o: i4lis.c
Xi4lis.o: ../bhdrs/b.h
Xi4lis.o: ../uhdrs/osconf.h
Xi4lis.o: ../uhdrs/os.h
Xi4lis.o: ../uhdrs/conf.h
Xi4lis.o: ../uhdrs/config.h
Xi4lis.o: ../bhdrs/bmem.h
Xi4lis.o: ../bhdrs/bobj.h
Xi4lis.o: ../bhdrs/bfil.h
Xi4lis.o: ../ihdrs/i3sou.h
Xi4lis.o: ./i4bio.h
Xi4out.o: i4out.c
Xi4out.o: ../bhdrs/b.h
Xi4out.o: ../uhdrs/osconf.h
Xi4out.o: ../uhdrs/os.h
Xi4out.o: ../uhdrs/conf.h
Xi4out.o: ../uhdrs/config.h
Xi4out.o: ../bhdrs/bint.h
Xi4out.o: ../bhdrs/bmem.h
Xi4out.o: ../bhdrs/bobj.h
Xi4out.o: ../ihdrs/i3env.h
Xi4out.o: ../ihdrs/i3scr.h
Xi4out.o: ../ihdrs/i3sou.h
Xi4out.o: ./i4bio.h
Xi4rec.o: i4rec.c
Xi4rec.o: ../bhdrs/b.h
Xi4rec.o: ../uhdrs/osconf.h
Xi4rec.o: ../uhdrs/os.h
Xi4rec.o: ../uhdrs/conf.h
Xi4rec.o: ../uhdrs/config.h
Xi4rec.o: ../uhdrs/feat.h
Xi4rec.o: ../bhdrs/bint.h
Xi4rec.o: ../bhdrs/bfil.h
Xi4rec.o: ../bhdrs/bmem.h
Xi4rec.o: ../bhdrs/bobj.h
Xi4rec.o: ../ihdrs/i2nod.h
Xi4rec.o: ../ihdrs/i2par.h
Xi4rec.o: ../ihdrs/i3scr.h
Xi4rec.o: ../ihdrs/i3sou.h
Xi4rec.o: ./i4bio.h
END_OF_FILE
  if test 1990 -ne `wc -c <'abc/bio/DEP'`; then
    echo shar: \"'abc/bio/DEP'\" unpacked with wrong size!
  fi
  # end of 'abc/bio/DEP'
fi
if test -f 'abc/btr/i1lta.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/btr/i1lta.c'\"
else
  echo shar: Extracting \"'abc/btr/i1lta.c'\" \(24025 characters\)
  sed "s/^X//" >'abc/btr/i1lta.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/* Access and update lists and tables */
X
X#include "b.h"
X#include "bobj.h"
X#include "i1btr.h"
X#include "i3scr.h" /* For at_nwl */
X#include "i1tlt.h"
X
X#define REMOVE_ENTRY	MESS(100, "removing non-existent list entry")
X
X#define REMOVE_RAN	MESS(101, "cannot remove from large range")
X#define INSERT_RAN	MESS(102, "cannot insert in large range")
X
X#define KEYS_TAB	MESS(103, "in keys t, t is not a table")
X
X#define SEL_TAB		MESS(104, "in t[k], t is not a table")
X#define SEL_KEY		MESS(105, "in t[k], k is not a key of t")
X
X#ifndef DEBUG
X#define check(v, where) /*nothing*/
X#endif
X
X#define IsInner(p) (Flag(p) == Inner)
X#define IsBottom(p) (Flag(p) == Bottom)
X
X#define _Pxitm(p, l, iw) (IsInner(p) ? Piitm(p, l, iw) : Pbitm(p, l, iw))
X
XHidden itemptr Pxitm(p, l, iw) btreeptr p; intlet l, iw; {
X	return _Pxitm(p, l, iw);
X}
X
X#define Inil ((itemptr)0)
X
X#define Incr(p, n) ((p) += (n))
X
XVisible width itemwidth[4]= {Cw, Lw, Tw, Kw};
X
X/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
Xtypedef struct {
X	btreeptr s_ptr;
X	int s_lim;
X} finger[Maxheight], *fingertip;
X
X#define Snil ((fingertip)0)
X
X#define Push(s, p, l) ((s)->s_ptr= (p), ((s)->s_lim= (l)), (s)++)
X#define Top(s, p, l) ((p)= ((s)-1)->s_ptr, (l)= ((s)-1)->s_lim)
X#define Drop(s) (--(s))
X#define Pop(s, p, l) (--(s), (p)= (s)->s_ptr, (l)= (s)->s_lim)
X	/* Pop(s, p, l) is equivalent to Top(s, p, l); Drop(s) */
X
X/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
XVisible fingertip unzip(p, at, s) btreeptr p; int at; fingertip s; {
X	int syz; intlet l;
X	if (p == Bnil) return s;
X	for (;;) {
X		if (at <= 0) l= 0;
X		else if (at >= Size(p)) l= Lim(p);
X		else if (IsInner(p)) {
X			l= 0;
X			while (at > (syz= Size(Ptr(p, l)))) {
X				++l;
X				at -= syz+1;
X			}
X		}
X		else if (at >= Lim(p)) l= Lim(p) - 1; /* for Irange/Crange */
X		else l= at; /* Assume Bottom */
X		Push(s, p, l);
X		if (!IsInner(p)) break;
X		p= Ptr(p, l);
X	}
X	return s;
X}
X
XVisible Procedure cpynptrs(to, from, n) btreeptr *to, *from; int n; {
X	while (--n >= 0) {
X		*to= copybtree(*from);
X		Incr(to, 1);
X		Incr(from, 1);
X	}
X}
X
XVisible int movnptrs(to, from, n) btreeptr *to, *from; int n; {
X	int syz= 0; /* Collects sum of sizes */
X	while (--n >= 0) {
X		*to= *from;
X		syz += Size(*from);
X		Incr(to, 1);
X		Incr(from, 1);
X	}
X	return syz;
X}
X
X/* The following two routines may prove machine-dependent when moving
X   N pointers is not equivalent to moving N*sizeof(pointer) characters.
X   Also, the latter may be slower. */
X
XVisible Procedure movnitms(to, from, n, iw) itemptr to, from; intlet n, iw; {
X	register char *t= (char *)to, *f= (char *)from;
X	n *= iw;
X	while (--n >= 0) *t++ = *f++;
X}
X
XHidden Procedure shift(p, l, iw) btreeptr p; intlet l, iw; {
X	/* Move items and pointers from l upwards one to the right */
X	btreeptr *to, *from;
X	intlet n= (Lim(p)-l) * iw; bool inner= IsInner(p);
X	char *f= (char *) Pxitm(p, Lim(p), iw);
X	char *t= f+iw;
X	while (--n >= 0) *--t = *--f;
X	if (inner) {
X		from= &Ptr(p, Lim(p));
X		to= from;
X		Incr(to, 1);
X		n= Lim(p)-l;
X		while (--n >= 0) {
X			*to= *from;
X			Incr(to, -1);
X			Incr(from, -1);
X		}
X	}
X}
X
XVisible Procedure cpynitms(to, from, n, it) itemptr to, from; intlet n, it; {
X	intlet i, iw= Itemwidth(it);
X	movnitms(to, from, n, iw);
X	switch (it) {
X	case Lt:
X	case Kt:
X	case Tt:
X		for (i= 0; i < n; ++i) {
X			copy(Keyval(to));
X			if (it == Tt) copy(Ascval(to));
X			else if (it == Kt) Ascval(to)= Vnil;
X			to= (itemptr) ((char*)to + iw);
X		}
X	}
X}
X
X/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
X/* Uflow uses a character array to hold the items.  This may be wrong. */
X
XVisible Procedure uflow(n, l, cbuf, pbuf, it)
X intlet n, l; char cbuf[]; btreeptr pbuf[]; intlet it; {
X	char ncbuf[3*Maxbottom*sizeof(btritem)], *cp= ncbuf;
X	btreeptr npbuf[3*Maxinner], *pp= npbuf, q;
X	intlet iw= Itemwidth(it); bool inner= IsInner(pbuf[0]);
X	intlet i, j, k, nn, l1= l>0 ? l-1 : l, l2= l<n ? l+1 : l;
X	for (i= l1; i <= l2; ++i) {
X		q= pbuf[i]; j= Lim(q);
X		cpynitms((itemptr)cp, Pxitm(q, 0, iw), j, it);
X		cp += j*iw;
X		if (inner) {
X			cpynptrs(pp, &Ptr(q, 0), j+1);
X			Incr(pp, j+1);
X		}
X		if (i < l2) {
X			movnitms((itemptr)cp, (itemptr)(cbuf+i*iw), 1, iw);
X			cp += iw;
X		}
X		relbtree(q, it);
X	}
X	nn= (cp-ncbuf)/iw;
X	k= inner ? Maxinner : Maxbottom;
X	if (nn <= k) k= 1;
X	else if (nn <= 2*k) k= 2;
X	else k= 3;
X	/* (k <= l2-l1+1) */
X	cp= ncbuf; pp= npbuf;
X	for (i= 0; i < k; ++i) {
X		if (i > 0) {
X			movnitms((itemptr)(cbuf+(l1+i-1)*iw), (itemptr)cp, 1, iw);
X			cp += iw;
X			--nn;
X		}
X		pbuf[l1+i]= q= grabbtreenode(inner ? Inner : Bottom, it);
X		Lim(q)= Size(q)= j= nn/(k-i); nn -= j;
X		movnitms(Pxitm(q, 0, iw), (itemptr)cp, j, iw);
X		cp += j*iw;
X		if (inner) {
X			Size(q) += movnptrs(&Ptr(q, 0), pp, j+1);
X			Incr(pp, j+1);
X		}
X	}
X	if (k < l2-l1+1) {
X		movnitms((itemptr)(cbuf+(l1+k-1)*iw), (itemptr)(cbuf+l2*iw), n-l2, iw);
X		VOID movnptrs(pbuf+l1+k, pbuf+l2+1, n-l2);
X		n -= l2-l1+1 - k;
X	}
X	return n;
X}
X
X/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
X/* Low level access routines */
X
X/* Meaning of 'flags' parameter to searchkey: */
X#define NORMAL 0
X#define UNIQUE 1 /* uniquify visited nodes */
X#define DYAMAX 2 /* special for dyadic max (= previous element) */
X#define DYAMIN 4 /* special for dyadic min (= next element) */
X
XHidden bool searchkey(v, pw, flags, ft)
X value v, *pw; int flags; fingertip *ft; {
X	btreeptr p, *pp;
X	intlet l, mid, h, it= Itemtype(*pw), iw= Itemwidth(it);
X	bool inner; relation r;
X	pp= &Root(*pw);
X	if (flags&UNIQUE) {
X		killranges(pw);
X		uniql(pw);
X		pp= &Root(*pw);
X	}
X	if (*pp == Bnil) return No;
X	for (;;) {
X		if (flags&UNIQUE) uniqlbtreenode(pp, it);
X		p= *pp;
X		inner= IsInner(p);
X		l= 0; h= Lim(p);
X		r= 1; /* For the (illegal?) case that there are no items */
X		while (l < h) { /* Binary search in {l..h-1} */
X			mid= (l+h)/2;
X			r= compare(v, Keyval(Pxitm(p, mid, iw)));
X			if (!comp_ok) return No;
X			if (r == 0) { /* Found it */
X				if (flags&(DYAMIN|DYAMAX)) {
X					/* Pretend not found */
X					if (flags&DYAMIN) r= 1;
X					else r= -1;
X				}
X				else { /* Normal case, report success */
X					l= mid;
X					break;
X				}
X			}
X			if (r < 0) h= mid; /* Continue in {l..mid-1} */
X			else if (r > 0) l= mid+1; /* Cont. in {mid+1..h-i} */
X		}
X		Push(*ft, p, l);
X		if (r == 0) return Yes;
X		if (!inner) {
X			switch (Flag(p)) {
X			case Irange: return h > 0 && l < Lim(p) && integral(v);
X			case Crange: return h > 0 && l < Lim(p) && character(v);
X			default: case Bottom: return No;
X			}
X		}
X		pp= &Ptr(p, l);
X	}
X}
X
XHidden Procedure killranges(pv) value *pv; {
X	btreeptr p= Root(*pv);
X	if (p == Bnil) return;
X	switch (Flag(p)) {
X	case Crange: killCrange(p, pv); break;
X	case Irange: killIrange(p, pv); break;
X	}
X}
X
XHidden Procedure killCrange(p, pv) btreeptr p; value *pv; {
X	value w; intlet lwbchar= Lwbchar(p), upbchar= Upbchar(p);
X	release(*pv);
X	*pv= mk_elt();
X	do {
X		w= mkchar(lwbchar);
X		insert(w, pv);
X		release(w);
X	} while (++lwbchar <= upbchar);
X}
X
XHidden Procedure killIrange(p, pv) btreeptr p; value *pv; {
X	value w, lwb, upb;
X	
X	lwb= copy(Lwbval(p)), upb= copy(Upbval(p));
X	release(*pv);
X	*pv= mk_elt();
X	do {
X		insert(lwb, pv);
X		if (compare(lwb, upb) >= 0) break;
X		w= lwb;
X		lwb= sum(lwb, one);
X		release(w);
X	} while (still_ok);
X	release(lwb);
X	release(upb);
X}
X
X/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
XHidden btreeptr rem(f, ft, it) fingertip f, ft; intlet it; {
X	btreeptr p, q, *pp; itemptr ip; intlet l, iw= Itemwidth(it);
X	bool inner, underflow;
X	Pop(ft, p, l);
X	inner= IsInner(p);
X	if (!inner) ip= Pbitm(p, l, iw);
X	else {
X		ip= Piitm(p, l, iw);
X		do {
X			Push(ft, p, l);
X			uniqlbtreenode(pp= &Ptr(p, l), it);
X			p= *pp;
X			l= Lim(p);
X		} while (IsInner(p));
X		inner= No;
X		l -= 2; /* So the movnitms below works fine */
X	}
X	release(Keyval(ip));
X	if (it == Tt || it == Kt) release(Ascval(ip));
X	--Lim(p);
X	movnitms(ip, Pbitm(p, l+1, iw), Lim(p)-l, iw);
X	for (;;) {
X		underflow= Lim(p) < (inner ? Mininner : Minbottom);
X		--Size(p);
X		if (ft == f) break;
X		Pop(ft, p, l);
X		if (underflow)
X			Lim(p)= uflow(Lim(p), l, (string)Piitm(p, 0, iw), &Ptr(p, 0), it);
X		inner= Yes;
X	}
X	if (Lim(p) == 0) { /* Reduce tree level */
X		q= p;
X		p= inner ? copybtree(Ptr(p, 0)) : Bnil;
X		relbtree(q, it);
X	}
X	return p;
X}
X
XHidden btreeptr ins(ip, f, ft, it) itemptr ip; fingertip f, ft; intlet it; {
X	btritem new, old; btreeptr p, q= Bnil, pq, oldq, *pp;
X	intlet l, iw= Itemwidth(it), nn, np, nq; bool inner, overflow;
X	if (ft == f) {
X		/* unify with rest? */
X		p= grabbtreenode(Bottom, it);
X		movnitms(Pbitm(p, 0, iw), ip, 1, iw);
X		Lim(p)= Size(p)= 1;
X		return p;
X	}
X	Pop(ft, p, l);
X	while (IsInner(p)) {
X		Push(ft, p, l);
X		uniqlbtreenode(pp= &Ptr(p, l), it);
X		p= *pp;
X		l= Lim(p);
X	}
X	overflow= Yes; inner= No;
X	for (;;) {
X		pq= p;
X		if (overflow) {
X			oldq= q;
X			movnitms(&old, ip, 1, iw);
X			ip= &new;
X			overflow= Lim(p) == (inner ? Maxinner : Maxbottom);
X			if (overflow) {
X				nn= Lim(p); np= nn/2; nq= nn-np-1;
X				q= grabbtreenode(inner ? Inner : Bottom, it);
X				Size(q)= Lim(q)= nq;
X				movnitms(&new, Pxitm(p, np, iw), 1, iw);
X				movnitms(Pxitm(q, 0, iw), Pxitm(p, np+1, iw), nq, iw);
X				if (inner) 
X					Size(q) += movnptrs(&Ptr(q, 0), &Ptr(p, np+1), nq+1);
X				Lim(p)= np;
X				Size(p) -= Size(q)+1;
X				if (l > np) {
X					l -= np+1;
X					pq= q;
X				}
X			}
X			shift(pq, l, iw);
X			movnitms(Pxitm(pq, l, iw), &old, 1, iw);
X			++Lim(pq);
X			if (inner) {
X				Size(p) -= Size(oldq);
X				Size(pq) += movnptrs(&Ptr(pq, l+1), &oldq, 1);
X			}
X		}
X		++Size(pq);
X		if (ft == f) break;
X		Pop(ft, p, l);
X		inner= Yes;
X	}
X	if (overflow)
X		p= mknewroot(p, ip, q, it);
X	return p;
X}
X
X/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
X/* Tables */
X
XVisible Procedure replace(a, pt, k) value a, *pt, k; {
X	btritem new; finger f; fingertip ft= f; btreeptr p; value *pp;
X	intlet it, iw, l;
X	check(*pt, " (replace in)");
X	if (Is_ELT(*pt)) { (*pt)->type= Tab; Itemtype(*pt)= Tt; }
X	it= Itemtype(*pt);
X	if (searchkey(k, pt, UNIQUE, &ft)) {
X		iw= Itemwidth(it);
X		Pop(ft, p, l);
X		pp= &Ascval(Pxitm(p, l, iw));
X		release(*pp);
X		*pp= copy(a);
X	}
X	else {
X		if (!comp_ok) return;
X		Keyval(&new)= copy(k); Ascval(&new)= copy(a);
X		Root(*pt)= ins(&new, f, ft, it);
X	}
X	check(*pt, " (replace out)");
X}
X
XVisible /*bool*/ delete(pt, k) value *pt, k; {
X	finger f; fingertip ft= f; intlet it= Itemtype(*pt);
X	check(*pt, " (delete in)");
X	if (!searchkey(k, pt, UNIQUE, &ft)) return No;
X	Root(*pt)= rem(f, ft, it);
X	check(*pt, " (delete out)");
X	return Yes;
X}
X
X/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
X/* Lists */
X
XHidden bool is_large_range(v) value v; {
X	value s; bool l;
X	s= size(v);
X	l= large(s);
X	release(s);
X	return l;
X}
X
XVisible Procedure insert(v, pl) value v, *pl; {
X	btritem new; finger f; fingertip ft= f; intlet it= Itemtype(*pl);
X	check(*pl, " (insert in)");
X	if (is_large_range(*pl)) {
X		interr(INSERT_RAN);
X		return;
X	}
X	if (Is_ELT(*pl)) (*pl)->type= Lis;
X	VOID searchkey(v, pl, UNIQUE, &ft);
X	if (!comp_ok) return;
X	Keyval(&new)= copy(v); Ascval(&new)= Vnil;
X	Root(*pl)= ins(&new, f, ft, it);
X	check(*pl, " (insert out)");
X}
X
XVisible Procedure remove(v, pl) value v, *pl; {
X	if (is_large_range(*pl)) {
X		interr(REMOVE_RAN);
X		return;
X	}
X	if (!delete(pl, v) && still_ok)
X		interr(REMOVE_ENTRY);
X}
X
X/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
X/* Miscellaneous accesses */
X
XHidden itemptr findkey(key, pv, flags) value key, *pv; int flags; {
X	finger f; fingertip ft= f; btreeptr p;
X	intlet it= Itemtype(*pv), iw= Itemwidth(it), l;
X	if (!searchkey(key, pv, flags, &ft)) return Inil;
X	Pop(ft, p, l);
X	return Pxitm(p, l, iw);
X}
X
XVisible value associate(t, k) value t, k; { /* t[k] */
X	itemptr ip;
X	if (!Is_table(t)) {
X		interr(SEL_TAB);
X		return Vnil;
X	}
X	ip= findkey(k, &t, NORMAL);
X	if (!ip) {
X		if (still_ok) /* Could be type error; then shut up! */
X			interr(SEL_KEY);
X		return Vnil;
X	}
X	return copy(Ascval(ip));
X}
X
XVisible value* adrassoc(t, k) value t, k; { /* &t[k] */
X	itemptr ip= findkey(k, &t, NORMAL);
X	if (!ip) return Pnil;
X	return &Ascval(ip);
X}
X
XVisible bool uniq_assoc(t, k) value t, k; { /* uniql(&t[k]) */
X	itemptr ip= findkey(k, &t, UNIQUE);
X	if (ip == Inil) return No;
X	uniql(&Ascval(ip));
X	return Yes;
X}
X
XVisible bool in_keys(k, t) value k, t; { /* k in keys t */
X	return findkey(k, &t, NORMAL) != Inil;
X}
X
XVisible value keys(t) value t; { /* keys t */
X	value v;
X	if (!Is_table(t)) {
X		interr(KEYS_TAB);
X		return Vnil;
X	}
X	v= grab(Lis, Kt);
X	Root(v)= copybtree(Root(t));
X	return v;
X}
X
X/* WARNING!  The following routine is not reentrant, since (for range lists)
X   it may return a pointer to static storage. */
X
XHidden itemptr getkth(k, v) int k; value v; {
X	finger f; fingertip ft; btreeptr p;
X	intlet it= Itemtype(v), iw= Itemwidth(it), l;
X	static btritem baked; value vk;
X	if (Root(v) == Bnil) return Inil;
X	ft= unzip(Root(v), k, f);
X	do {
X		if (ft == f) return Inil;
X		Pop(ft, p, l);
X	} while (l >= Lim(p));
X	switch (Flag(p)) {
X		default:
X		case Inner:
X		case Bottom:
X			return Pxitm(p, l, iw);
X		case Irange:
X			release(Keyval(&baked));
X			Keyval(&baked)= sum(Lwbval(p), vk= mk_integer(k));
X			release(vk);
X			return &baked;
X		case Crange:
X			release(Keyval(&baked));
X			Keyval(&baked)= mkchar(Lwbchar(p) + k);
X			return &baked;
X	}
X}
X
XVisible value* key(v, k) value v; intlet k; { /* &(++k th'of keys v) */
X	itemptr ip= getkth(k, v);
X	return ip ? &Keyval(ip) : Pnil;
X}
X
XVisible value* assoc(v, k) value v; intlet k; { /* &v[++k th'of keys v] */
X	itemptr ip= getkth(k, v);
X	return ip ? &Ascval(ip) : Pnil;
X}
X
XVisible value thof(k, v) int k; value v; { /* k th'of v */
X	itemptr ip= getkth(k-1, v);
X	if (!ip) return Vnil;
X	switch (Type(v)) {
X	case Tex: return mkchar(Charval(ip));
X	case Lis: return copy(Keyval(ip));
X	case Tab: return copy(Ascval(ip));
X	default: return Vnil;
X	}
X}
X
X/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
X/* Compare B-trees.  Should use fingers, but to keep things simple
X   (especially in the presence of range type nodes), doesn't.  This
X   makes its behaviour O(N log N), where it could be O(N), alas. */
X
X/* WARNING!  getkth may return a pointer to static storage (when retrieving
X   elements from a range list).  Therefore after the second call to getkth,
X   the return value of the first may be invalid, but only for lists.
X   So we extract the 'Key' values immediately after the call to getkth. */
X
XVisible relation comp_tlt(u, v) value u, v; {
X	itemptr up, vp; int k, ulen, vlen, len; relation r= 0;
X	bool tex= Is_text(u), tab= Is_table(u);
X	value key_u;
X	len= ulen= Tltsize(u); vlen= Tltsize(v);
X	if (vlen < len) len= vlen;
X	for (k= 0; k < len; ++k) {
X		up= getkth(k, u);
X		if (!tex) key_u= copy(Keyval(up));
X		vp= getkth(k, v);
X		if (tex) r= Charval(up) - Charval(vp);
X		else {
X			r= compare(key_u, Keyval(vp));
X			release(key_u);
X			if (tab && r == 0)
X				r= compare(Ascval(up), Ascval(vp));
X		}
X		if (r != 0) break;
X	}
X	if (r == 0) r= ulen - vlen;
X	return r;
X}
X
X/* Compare texts.  When both texts are bottom nodes, compare with
X   strncmp(), to speed up the most common use (look-up by the
X   system of tags in a symbol table).  Otherwise, call comp_tlt(). */
X
XVisible relation comp_text(u, v) value u, v; {
X	btreeptr p, q; int len; relation r;
X	if (!Is_text(u) || !Is_text(v)) 
X		syserr(MESS(106, "comp_text"));
X	p= Root(u), q= Root(v);
X	if (p EQ Bnil) return (q EQ Bnil) ? 0 : -1;
X	if (q EQ Bnil) return 1;
X	if (Flag(p) EQ Bottom && Flag(q) EQ Bottom) {
X		len= Lim(p);
X		if (Lim(q) < len) len= Lim(q);
X		r= strncmp(&Bchar(p, 0), &Bchar(q, 0), len);
X		if (r NE 0) return r;
X		return Lim(p) - Lim(q);
X	}
X	return comp_tlt(u, v);
X}
X
X/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
X/* Range type nodes */
X
XVisible bool is_rangelist(v) value v; {
X	return (bool) (Root(v) != Bnil
X		       && 
X		       (Flag(Root(v)) == Irange || Flag(Root(v)) == Crange)
X		      );
X}
X
XHidden value mk_numrange(lwb, upb) value lwb, upb; {
X	value lis;
X	btreeptr proot;
X
X	lis= grab(Lis, Lt);
X	if (numcomp(lwb, upb) > 0)
X		Root(lis)= Bnil;
X	else {
X		Root(lis)= proot= grabbtreenode(Irange, Lt);
X		Lwbval(proot)= copy(lwb);
X		Upbval(proot)= copy(upb);
X		set_size_and_lim(proot);
X	}
X	return(lis);
X}
X
XHidden value i_range(lo, hi) value lo, hi; {
X	value x, res= Vnil;
X
X	x= diff(lo, hi);
X	if (compare(x, one) >= 0)
X		res= mk_elt();
X	else
X		res= mk_numrange(lo, hi);
X	release(x);
X
X	return res;
X}
X
XHidden value mk_charrange(lwb, upb) value lwb, upb; {
X	value lis;
X	btreeptr proot;
X	intlet rsyz;
X
X	lis= grab(Lis, Lt);
X	rsyz= Bchar(Root(upb), 0) - Bchar(Root(lwb), 0) + 1;
X	if (rsyz <= 0)
X		Root(lis)= Bnil;
X	else {
X		Root(lis)= proot= grabbtreenode(Crange, Lt);
X		Size(proot)= rsyz;
X		Lim(proot)= rsyz > 1 ? 2 : 1;
X		Lwbval(proot)= copy(lwb);
X		Upbval(proot)= copy(upb);
X	}
X	return lis;
X}
X
X
XHidden value c_range(lo, hi) value lo, hi; {
X	char a, z;
X
X	a= charval(lo); z= charval(hi);
X	if (z <= a-1) return mk_elt();
X	else return mk_charrange(lo, hi);
X}
X
XVisible value mk_range(v1, v2) value v1, v2; {
X	if (Is_text(v1)) return c_range(v1, v2);
X	else		 return i_range(v1, v2);
X}
X
X
X/* set size and lim for integer range node */
X 
XHidden Procedure set_size_and_lim(pnode) btreeptr pnode; {
X	value smin, s;
X	smin= diff(Upbval(pnode), Lwbval(pnode));
X	s= sum(smin, one);
X	if (large(s)) {
X		Size(pnode)= Bigsize;
X		Lim(pnode)= 2;
X	}
X	else {
X		Size(pnode)= intval(s);
X		Lim(pnode)= Size(pnode) > 1 ? 2 : 1;
X	}
X	release(s); release(smin);
X}
X
X/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
X/* Dyadic min, max, size of lists */
X
XVisible value l2min(e, v) value e, v; { /* e min v */
X	finger f; fingertip ft= f; btreeptr p;
X	intlet it= Itemtype(v), iw= Itemwidth(it), l;
X	VOID searchkey(e, &v, DYAMIN, &ft);
X	for (;;) {
X		if (ft == f) return Vnil;
X		Top(ft, p, l);
X		if (l < Lim(p)) {
X			switch (Flag(p)) {
X			case Inner:
X				return copy(Keyval(Piitm(p, l, iw)));
X			case Bottom:
X				return copy(Keyval(Pbitm(p, l, iw)));
X			case Irange:
X				if (l == 0) return copy(Lwbval(p));
X				if (integral(e)) return sum(e, one);
X				return ceilf(e);
X			case Crange:
X				if (l == 0) return copy(Lwbval(p));
X				return mkchar(Bchar(Root(e), 0) + 1);
X			}
X		}
X		Drop(ft);
X	}
X}
X
XVisible value l2max(e, v) value e, v; { /* e max v */
X	finger f; fingertip ft= f; btreeptr p;
X	intlet it= Itemtype(v), iw= Itemwidth(it), l;
X	VOID searchkey(e, &v, DYAMAX, &ft);
X	for (;;) {
X		if (ft == f) return Vnil;
X		Top(ft, p, l);
X		--l;
X		if (l >= 0) {
X			switch (Flag(p)) {
X			case Inner:
X				return copy(Keyval(Piitm(p, l, iw)));
X			case Bottom:
X				return copy(Keyval(Pbitm(p, l, iw)));
X			case Irange:
X				if (l == 1) return copy(Upbval(p));
X				if (integral(e)) return diff(e, one);
X				return floorf(e);
X			case Crange:
X				if (l == 1) return copy(Upbval(p));
X				return mkchar(Bchar(Root(e), 0) - 1);
X			}
X		}
X		Drop(ft);
X	}
X}
X
XVisible int l2size(e, v) value e, v; { /* e#v */
X	finger f; fingertip ft= f; btreeptr p;
X	int count= 0; intlet it= Itemtype(v), iw= Itemwidth(it), l, r;
X	VOID searchkey(e, &v, DYAMIN, &ft);
X	for (;;) {
X		if (ft == f) return count;
X		Pop(ft, p, l);
X		while (--l >= 0) {
X			r= compare(Keyval(Pxitm(p, l, iw)), e);
X			if (r != 0) {
X				switch (Flag(p)) {
X				case Irange: /* See footnote */
X					if (l==0 && count==0 && integral(e))
X						++count;
X					break;
X				case Crange: /* See footnote */
X					if (l==0 && count==0 && !character(e))
X						++count;
X					break;
X				}
X				return count;
X			}
X			++count;
X			while (IsInner(p)) {
X				Push(ft, p, l);
X				p= Ptr(p, l);
X				l= Lim(p);
X			}
X		}
X	}
X}
X
X/* Clarification of what happens for x#{a..b}:
X * Consider these five cases: x<a; x=a; a<x<b; x=b; b<x.
X * Only the case a<x<b need be treated specially.  How do we find which
X * case we're in?
X * Searchkey gives us the following values for l on the stack, respectively:
X * 0; 1; 1; 2; 2.  After --l, this becomes -1; 0; 0; 1; 1.
X * In cases x=a or x=b, the compare returns 0, and we go another time
X * through the loop.  So when the compare returns r!=0, the value of l
X * is, respectively: -1; -1; 0; 0; 1.  The -1 cases in fact don't even
X * get at the compare, and the correct count is returned automatically.
X * So we need to do extra work only if l==0, except if x==b.
X * The latter condition is cared for by count==0 (if x==b, count is
X * surely >= 1; if a<x<b, count is surely 0).  This works even when
X * range nodes may be mixed with other node types in one tree.
X */
X
X/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
X
X#ifdef DEBUG
X/* Debug code */
X
XHidden char fmtstr[20];
X
XHidden Procedure check(v, whence) value v; string whence; {
X	if (!still_ok) return;
X	switch (Type(v)) {
X	case ELT:
X		return;
X	case Lis:
X	case Tab:
X		break;
X	default:
X		debug("value not a list or table", whence);
X		return;
X	}
X	if (Root(v) != Bnil)
X		VOID cktree(Inil, Root(v), Inil, Itemtype(v), whence);
X	if (!still_ok && !Interrupted()) {
X		dumptree(Root(v), 0, Itemtype(v));
X		putnewline(stdout);
X		fflush(stdout);
X	}
X}
X
XHidden int cktree(left, p, right, it, whence)
X itemptr left; btreeptr p; itemptr right; intlet it; string whence; {
X	/* returns size of checked subtree */
X	intlet i, iw= Itemwidth(it); int sz= 0;
X	if (!still_ok) return 0;
X	if (p == Bnil) {
X		debug("unexpected nil subtree", whence);
X		return 0;
X	}
X	switch (Flag(p)) {
X	case Inner:
X		for (i= 0; i < Lim(p); ++i) {
X			sz += 1 +
X			  cktree(left, Ptr(p, i), Piitm(p, i, iw), it, whence);
X			if (!still_ok) return;
X			left= Piitm(p, i, iw);
X		}
X		sz += cktree(left, Ptr(p, i), right, it, whence);
X		if (still_ok && sz != Size(p))
X			debug("size mismatch", whence);
X		break;
X	case Bottom:
X		for (i= 0; i < Lim(p); ++i) {
X			if (left != Inil && compare(Keyval(left),
X					Keyval(Pbitm(p, i, iw))) > 0) {
X				debug("bottom items out of order", whence);
X				break;
X			}
X			left= Pbitm(p, i, iw);
X			sz++;
X		}
X		if (still_ok && right != Inil
X			&& compare(Keyval(left), Keyval(right)) > 0)
X				debug("bottom items out of order", whence);
X		return sz;
X	case Irange:
X		if (left != Inil && compare(Keyval(left), Lwbval(p)) > 0
X			|| right != Inil
X				&& compare(Upbval(p), Keyval(right)) > 0)
X			debug("irange items out of order", whence);
X		sz= Size(p);
X	default:
X		debug("bad node type", whence);
X	}
X	return sz;
X}
X
X#ifdef NOT_USED
XVisible Procedure e_dumptree(v) value v; {
X	check(v, "");
X	if (still_ok) {
X		if (!at_nwl) putnewline(stdout);
X		dumptree(Root(v), 0, Itemtype(v));
X		putnewline(stdout);
X		fflush(stdout);
X		at_nwl= Yes;
X	}
X}
X#endif
X
XHidden Procedure dumptree(p, indent, it) btreeptr p; intlet indent, it; {
X	intlet i, iw= Itemwidth(it);
X	int n;
X	if (Interrupted()) return;
X	for (n= 0; n<3*indent; n++)
X		putchr(stdout, ' ');
X	if (p == Bnil) { putstr(stdout, "<nil>"); return; }
X	switch (Flag(p)) {
X	case Inner:
X		putstr(stdout, "(\n");
X		for (i= 0; !Interrupted() && i <= Lim(p); ++i) {
X			if (i > 0) {
X				for (n= 0; n<3*indent; n++)
X					putchr(stdout, ' ');
X				dumpval(Keyval(Piitm(p, i-1, iw)));
X				putnewline(stdout);
X			}
X			dumptree(Ptr(p, i), indent+1, it);
X			putnewline(stdout);
X		}
X		for (n= 0; n<3*indent; n++)
X			putchr(stdout, ' ');
X		putchr(stdout, ')');
X		break;
X	case Bottom:
X		putchr(stdout, '[');
X		for (i= 0; i < Lim(p); ++i) {
X			if (i > 0) putchr(stdout, ' ');
X			dumpval(Keyval(Pbitm(p, i, iw)));
X		}
X		putchr(stdout, ']');
X		break;
X	case Irange:
X		putchr(stdout, '{');
X		dumpval(Lwbval(p));
X		putstr(stdout, " .. ");
X		dumpval(Upbval(p));
X		putchr(stdout, '}');
X		break;
X	default:
X		sprintf(fmtstr, "?type='%c'?", Flag(p));
X		putstr(stdout, fmtstr);
X		break;
X	}
X}
X
XHidden Procedure dumpval(v) value v; {
X	if (Interrupted()) return;
X	if (v == Vnil) putstr(stdout, "(nil)");
X	else switch(Type(v)) {
X	case Num: case Tex: case Lis: case Tab: case ELT: case Com:
X		wri(v, No, No, No);
X		break;
X	default:
X		sprintf(fmtstr, "0x%lx", (long)v);
X		putstr(stdout, fmtstr);
X	}
X}
X
XHidden Procedure debug(s1, s2) string s1, s2; {
X	value v1= mk_text(s1);
X	value v2= mk_text(s2);
X	value v= concat(v1, v2);
X	interrV(-1, v);
X	release(v1); release(v2);
X	release(v);
X}
X
X#endif /* DEBUG */
X
END_OF_FILE
  if test 24025 -ne `wc -c <'abc/btr/i1lta.c'`; then
    echo shar: \"'abc/btr/i1lta.c'\" unpacked with wrong size!
  fi
  # end of 'abc/btr/i1lta.c'
fi
if test -f 'abc/tc/termcap.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/tc/termcap.5'\"
else
  echo shar: Extracting \"'abc/tc/termcap.5'\" \(25213 characters\)
  sed "s/^X//" >'abc/tc/termcap.5' <<'END_OF_FILE'
X.tr ||
X.TH TERMCAP 5 "10 May 1980"
X.UC
X.SH NAME
Xtermcap \- terminal capability data base
X.SH SYNOPSIS
X/etc/termcap
X.SH DESCRIPTION
X.I Termcap
Xis a data base describing terminals,
Xused,
X.IR e.g. ,
Xby
X.IR vi (1)
Xand
X.IR curses (3X).
XTerminals are described in
X.I termcap
Xby giving a set of capabilities which they have, and by describing
Xhow operations are performed.
XPadding requirements and initialization sequences
Xare included in
X.I termcap.
X.PP
XEntries in
X.I termcap
Xconsist of a number of `:' separated fields.
XThe first entry for each terminal gives the names which are known for the
Xterminal, separated by `|' characters.  The first name is always 2 characters
Xlong and is used by older version 6 systems which store the terminal type
Xin a 16 bit word in a systemwide data base.
XThe second name given is the most common abbreviation for the terminal, and the
Xlast name given should be a long name fully identifying the terminal.
XThe second name should contain no blanks; the last name may well contain
Xblanks for readability.
X.SH CAPABILITIES
X.nf
X(P) indicates padding may be specified
X(P*) indicates that padding may be based on no. lines affected
X
X.ta \w'k0-k9  'u +\w'Type  'u +\w'Pad?  'u
X\fBName	Type	Pad?	Description\fR
Xae	str	(P)	End alternate character set
Xal	str	(P*)	Add new blank line
Xam	bool		Terminal has automatic margins
Xas	str	(P)	Start alternate character set
Xbc	str		Backspace if not \fB^H\fR
Xbs	bool		Terminal can backspace with \fB^H\fR
Xbt	str	(P)	Back tab
Xbw	bool		Backspace wraps from column 0 to last column
XCC	str		Command character in prototype if terminal settable
Xcd	str	(P*)	Clear to end of display
Xce	str	(P)	Clear to end of line
Xch	str	(P)	Like cm but horizontal motion only, line stays same
Xcl	str	(P*)	Clear screen
Xcm	str	(P)	Cursor motion
Xco	num		Number of columns in a line
Xcr	str	(P*)	Carriage return, (default \fB^M\fR)
Xcs	str	(P)	Change scrolling region (vt100), like cm
Xcv	str	(P)	Like ch but vertical only.
Xda	bool		Display may be retained above
XdB	num		Number of millisec of bs delay needed
Xdb	bool		Display may be retained below
XdC	num		Number of millisec of cr delay needed
Xdc	str	(P*)	Delete character
XdF	num		Number of millisec of ff delay needed
Xdl	str	(P*)	Delete line
Xdm	str		Delete mode (enter)
XdN	num		Number of millisec of nl delay needed
Xdo	str		Down one line
XdT	num		Number of millisec of tab delay needed
Xed	str		End delete mode
Xei	str		End insert mode; give \*(lq:ei=:\*(rq if \fBic\fR
Xeo	str		Can erase overstrikes with a blank
Xff	str	(P*)	Hardcopy terminal page eject (default \fB^L\fR)
Xhc	bool		Hardcopy terminal
Xhd	str		Half-line down (forward 1/2 linefeed)
Xho	str		Home cursor (if no \fBcm\fR)
Xhu	str		Half-line up (reverse 1/2 linefeed)
Xhz	str		Hazeltine; can't print ~'s
Xic	str	(P)	Insert character
Xif	str		Name of file containing \fBis\fR
Xim	bool		Insert mode (enter); give \*(lq:im=:\*(rq if \fBic\fR
Xin	bool		Insert mode distinguishes nulls on display
Xip	str	(P*)	Insert pad after character inserted
Xis	str		Terminal initialization string
Xk0-k9	str		Sent by \*(lqother\*(rq function keys 0-9
Xkb	str		Sent by backspace key
Xkd	str		Sent by terminal down arrow key
Xke	str		Out of \*(lqkeypad transmit\*(rq mode
Xkh	str		Sent by home key
Xkl	str		Sent by terminal left arrow key
Xkn	num		Number of \*(lqother\*(rq keys
Xko	str		Termcap entries for other non-function keys
Xkr	str		Sent by terminal right arrow key
Xks	str		Put terminal in \*(lqkeypad transmit\*(rq mode
Xku	str		Sent by terminal up arrow key
Xl0-l9	str		Labels on \*(lqother\*(rq function keys
Xli	num		Number of lines on screen or page
Xll	str		Last line, first column (if no \fBcm\fR)
Xma	str		Arrow key map, used by vi version 2 only
Xmi	bool		Safe to move while in insert mode
Xml	str		Memory lock on above cursor.
Xms	bool		Safe to move while in standout and underline mode
Xmu	str		Memory unlock (turn off memory lock).
Xnc	bool		No correctly working carriage return (DM2500,H2000)
Xnd	str		Non-destructive space (cursor right)
Xnl	str	(P*)	Newline character (default \fB\en\fR)
Xns	bool		Terminal is a \s-2CRT\s+2 but doesn't scroll.
Xos	bool		Terminal overstrikes
Xpc	str		Pad character (rather than null)
Xpt	bool		Has hardware tabs (may need to be set with \fBis\fR)
Xse	str		End stand out mode
Xsf	str	(P)	Scroll forwards
Xsg	num		Number of blank chars left by so or se
Xso	str		Begin stand out mode
Xsr	str	(P)	Scroll reverse (backwards)
Xta	str	(P)	Tab (other than \fB^I\fR or with padding)
Xtc	str		Entry of similar terminal - must be last
Xte	str		String to end programs that use \fBcm\fP
Xti	str		String to begin programs that use \fBcm\fR
Xuc	str		Underscore one char and move past it
Xue	str		End underscore mode
Xug	num		Number of blank chars left by us or ue
Xul	bool		Terminal underlines even though it doesn't overstrike
Xup	str		Upline (cursor up)
Xus	str		Start underscore mode
Xvb	str		Visible bell (may not move cursor)
Xve	str		Sequence to end open/visual mode
Xvs	str		Sequence to start open/visual mode
Xxb	bool		Beehive (f1=escape, f2=ctrl C)
Xxn	bool		A newline is ignored after a wrap (Concept)
Xxr	bool		Return acts like \fBce\fP \er \en (Delta Data)
Xxs	bool		Standout not erased by writing over it (HP 264?)
Xxt	bool		Tabs are destructive, magic so char (Teleray 1061)
X.fi
X.PP
X.B A Sample Entry
X.PP
XThe following entry, which describes the Concept\-100, is among the more
Xcomplex entries in the
X.I termcap
Xfile as of this writing.
X(This particular concept entry is outdated,
Xand is used as an example only.)
X.PP
X.nf
Xc1\||\|c100\||\|concept100:is=\eEU\eEf\eE7\eE5\eE8\eEl\eENH\eEK\eE\e200\eEo&\e200:\e
X        :al=3*\eE^R:am:bs:cd=16*\eE^C:ce=16\eE^S:cl=2*^L:cm=\eEa%+ %+ :co#80:\e
X        :dc=16\eE^A:dl=3*\eE^B:ei=\eE\e200:eo:im=\eE^P:in:ip=16*:li#24:mi:nd=\eE=:\e
X        :se=\eEd\eEe:so=\eED\eEE:ta=8\et:ul:up=\eE;:vb=\eEk\eEK:xn:
X.fi
X.PP
XEntries may continue onto multiple lines by giving a \e as the last
Xcharacter of a line, and that empty fields
Xmay be included for readability (here between the last field on a line
Xand the first field on the next).
XCapabilities in
X.I termcap
Xare of three types:
XBoolean capabilities which indicate that the terminal has
Xsome particular feature, numeric capabilities giving the size of the terminal
Xor the size of particular delays, and string
Xcapabilities, which give a sequence which can be used to perform particular
Xterminal operations.
X.PP
X.B Types of Capabilities
X.PP
XAll capabilities have two letter codes.  For instance, the fact that
Xthe Concept has \*(lqautomatic margins\*(rq (i.e. an automatic return and linefeed
Xwhen the end of a line is reached) is indicated by the capability \fBam\fR.
XHence the description of the Concept includes \fBam\fR.
XNumeric capabilities are followed by the character `#' and then the value.
XThus \fBco\fR which indicates the number of columns the terminal has
Xgives the value `80' for the Concept.
X.PP
XFinally, string valued capabilities, such as \fBce\fR (clear to end of line
Xsequence) are given by the two character code, an `=', and then a string
Xending at the next following `:'.  A delay in milliseconds may appear after
Xthe `=' in such a capability, and padding characters are supplied by the
Xeditor after the remainder of the string is sent to provide this delay.
XThe delay can be either a integer, e.g. `20', or an integer followed by
Xan `*', i.e. `3*'.  A `*' indicates that the padding required is proportional
Xto the number of lines affected by the operation, and the amount given is
Xthe per-affected-unit padding required.
XWhen a `*' is specified, it is sometimes useful to give a delay of the form
X`3.5' specify a delay per unit to tenths of milliseconds.
X.PP
XA number of escape sequences are provided in the string valued capabilities
Xfor easy encoding of characters there.  A \fB\eE\fR maps to an \s-2ESCAPE\s0
Xcharacter, \fB^x\fR maps to a control-x for any appropriate x, and the sequences
X\fB\en \er \et \eb \ef\fR give a newline, return, tab, backspace and formfeed.
XFinally, characters may be given as three octal digits after a \fB\e\fR,
Xand the characters \fB^\fR and \fB\e\fR may be given as \fB\e^\fR and \fB\e\e\fR.
XIf it is necessary to place a \fB:\fR in a capability it must be escaped in
Xoctal as \fB\e072\fR.
XIf it is necessary to place a null character in a string capability it
Xmust be encoded as \fB\e200\fR.  The routines which deal with
X.I termcap
Xuse C strings, and strip the high bits of the output very late so that
Xa \fB\e200\fR comes out as a \fB\e000\fR would.
X.br
X.ne 5
X.PP
X.B Preparing Descriptions
X.PP
XWe now outline how to prepare descriptions of terminals.
XThe most effective way to prepare a terminal description is by imitating
Xthe description of a similar terminal in
X.I termcap
Xand to build up a description gradually, using partial descriptions
Xwith
X.I ex
Xto check that they are correct.
XBe aware that a very unusual terminal may expose deficiencies in
Xthe ability of the
X.I termcap
Xfile to describe it
Xor bugs in
X.I ex.
XTo easily test a new terminal description you can set the environment variable
XTERMCAP to a pathname of a file containing the description you are working
Xon and the editor will look there rather than in
X.I /etc/termcap.
XTERMCAP can also be set to the termcap entry itself
Xto avoid reading the file when starting up the editor.
X(This only works on version 7 systems.)
X.PP
X.B Basic capabilities
X.PP
XThe number of columns on each line for the terminal is given by the
X\fBco\fR numeric capability.  If the terminal is a \s-2CRT\s0, then the
Xnumber of lines on the screen is given by the \fBli\fR capability.
XIf the terminal wraps around to the beginning of the next line when
Xit reaches the right margin, then it should have the \fBam\fR capability.
XIf the terminal can clear its screen, then this is given by the
X\fBcl\fR string capability.  If the terminal can backspace, then it
Xshould have the \fBbs\fR capability, unless a backspace is accomplished
Xby a character other than \fB^H\fR (ugh) in which case you should give
Xthis character as the \fBbc\fR string capability.  If it overstrikes
X(rather than clearing a position when a character is struck over)
Xthen it should have the \fBos\fR capability.
X.PP
XA very important point here is that the local cursor motions encoded
Xin
X.I termcap
Xare undefined at the left and top edges of a \s-2CRT\s0 terminal.
XThe editor will never attempt to backspace around the left edge, nor
Xwill it attempt to go up locally off the top.  The editor assumes that
Xfeeding off the bottom of the screen will cause the screen to scroll up,
Xand the \fBam\fR capability tells whether the cursor sticks at the right
Xedge of the screen.  If the terminal has switch selectable automatic margins,
Xthe
X.I termcap
Xfile usually assumes that this is on, i.e. \fBam\fR.
X.PP
XThese capabilities suffice to describe hardcopy and \*(lqglass-tty\*(rq terminals.
XThus the model 33 teletype is described as
X.PP
X.DT
X	t3\||\|33\||\|tty33:co#72:os
X.PP
Xwhile the Lear Siegler \s-2ADM\-3\s0 is described as
X.PP
X.DT
X	cl\||\|adm3|3|lsi adm3:am:bs:cl=^Z:li#24:co#80
X.PP
X.B Cursor addressing
X.PP
XCursor addressing in the terminal is described by a
X\fBcm\fR string capability, with 
X.IR printf (3S)
Xlike escapes \fB%x\fR in it.
XThese substitute to encodings of the current line or column position,
Xwhile other characters are passed through unchanged.
XIf the \fBcm\fR string is thought of as being a function, then its
Xarguments are the line and then the column to which motion is desired,
Xand the \fB%\fR encodings have the following meanings:
X.PP
X.DT
X.nf
X	%d	as in \fIprintf\fR, 0 origin
X	%2	like %2d
X	%3	like %3d
X	%.	like %c
X	%+x	adds \fIx\fR to value, then %.
X	%>xy	if value > x adds y, no output.
X	%r	reverses order of line and column, no output
X	%i	increments line/column (for 1 origin)
X	%%	gives a single %
X	%n	exclusive or row and column with 0140 (DM2500)
X	%B	BCD (16*(x/10)) + (x%10), no output.
X	%D	Reverse coding (x-2*(x%16)), no output. (Delta Data).
X.fi
X.PP
XConsider the HP2645, which, to get to row 3 and column 12, needs
Xto be sent \eE&a12c03Y padded for 6 milliseconds.  Note that the order
Xof the rows and columns is inverted here, and that the row and column
Xare printed as two digits.  Thus its \fBcm\fR capability is \*(lqcm=6\eE&%r%2c%2Y\*(rq.
XThe Microterm \s-2ACT-IV\s0 needs the current row and column sent
Xpreceded by a \fB^T\fR, with the row and column simply encoded in binary,
X\*(lqcm=^T%.%.\*(rq.  Terminals which use \*(lq%.\*(rq need to be able to
Xbackspace the cursor (\fBbs\fR or \fBbc\fR),
Xand to move the cursor up one line on the screen (\fBup\fR introduced below).
XThis is necessary because it is not always safe to transmit \fB\et\fR, \fB\en\fR
X\fB^D\fR and \fB\er\fR, as the system may change or discard them.
X.PP
XA final example is the \s-2LSI ADM\s0-3a, which uses row and column
Xoffset by a blank character, thus \*(lqcm=\eE=%+ %+ \*(rq.
X.PP
X.B Cursor motions
X.PP
XIf the terminal can move the cursor one position to the right, leaving
Xthe character at the current position unchanged, then this sequence should
Xbe given as \fBnd\fR (non-destructive space).  If it can move the cursor
Xup a line
Xon the screen in the same column, this should be given as \fBup\fR.
XIf the terminal has no cursor addressing capability, but can home the cursor
X(to very upper left corner of screen) then this can be given as
X\fBho\fR; similarly a fast way of getting to the lower left hand corner
Xcan be given as \fBll\fR; this may involve going up with \fBup\fR
Xfrom the home position,
Xbut the editor will never do this itself (unless \fBll\fR does) because it
Xmakes no assumption about the effect of moving up from the home position.
X.PP
X.B Area clears
X.PP
XIf the terminal can clear from the current position to the end of the
Xline, leaving the cursor where it is, this should be given as \fBce\fR.
XIf the terminal can clear from the current position to the end of the
Xdisplay, then this should be given as \fBcd\fR.
XThe editor only uses
X\fBcd\fR from the first column of a line.
X.PP
X.B Insert/delete line
X.PP
XIf the terminal can open a new blank line before the line where the cursor
Xis, this should be given as \fBal\fR; this is done only from the first
Xposition of a line.  The cursor must then appear on the newly blank line.
XIf the terminal can delete the line which the cursor is on, then this
Xshould be given as \fBdl\fR; this is done only from the first position on
Xthe line to be deleted.
XIf the terminal can scroll the screen backwards, then this can be given as
X\fBsb\fR, but just \fBal\fR suffices.
XIf the terminal can retain display memory above then the
X\fBda\fR capability should be given; if display memory can be retained
Xbelow then \fBdb\fR should be given.  These let the editor understand
Xthat deleting a line on the screen may bring non-blank lines up from below
Xor that scrolling back with \fBsb\fR may bring down non-blank lines.
X.PP
X.B Insert/delete character
X.PP
XThere are two basic kinds of intelligent terminals with respect to
Xinsert/delete character which can be described using
X.I termcap.
XThe most common insert/delete character operations affect only the characters
Xon the current line and shift characters off the end of the line rigidly.
XOther terminals, such as the Concept 100 and the Perkin Elmer Owl, make
Xa distinction between typed and untyped blanks on the screen, shifting
Xupon an insert or delete only to an untyped blank on the screen which is
Xeither eliminated, or expanded to two untyped blanks.  You can find out
Xwhich kind of terminal you have by clearing the screen and then typing
Xtext separated by cursor motions.  Type \*(lqabc\ \ \ \ def\*(rq using local
Xcursor motions (not spaces) between the \*(lqabc\*(rq and the \*(lqdef\*(rq.
XThen position the cursor before the \*(lqabc\*(rq and put the terminal in insert
Xmode.  If typing characters causes the rest of the line to shift
Xrigidly and characters to fall off the end, then your terminal does
Xnot distinguish between blanks and untyped positions.  If the \*(lqabc\*(rq
Xshifts over to the \*(lqdef\*(rq which then move together around the end of the
Xcurrent line and onto the next as you insert, you have the second type of
Xterminal, and should give the capability \fBin\fR, which stands for
X\*(lqinsert null\*(rq.  If your terminal does something different and unusual
Xthen you may have to modify the editor to get it to use the insert
Xmode your terminal defines.  We have seen no terminals which have an insert
Xmode not not falling into one of these two classes.
X.PP
XThe editor can handle both terminals which have an insert mode, and terminals
Xwhich send a simple sequence to open a blank position on the current line.
XGive as \fBim\fR the sequence to get into insert mode, or give it an
Xempty value if your terminal uses a sequence to insert a blank position.
XGive as \fBei\fR the sequence to leave insert mode (give this, with
Xan empty value also if you gave \fBim\fR so).
XNow give as \fBic\fR any sequence needed to be sent just before sending
Xthe character to be inserted.  Most terminals with a true insert mode
Xwill not give \fBic\fR, terminals which send a sequence to open a screen
Xposition should give it here.  (Insert mode is preferable to the sequence
Xto open a position on the screen if your terminal has both.)
XIf post insert padding is needed, give this as a number of milliseconds
Xin \fBip\fR (a string option).  Any other sequence which may need to be
Xsent after an insert of a single character may also be given in \fBip\fR.
X.PP
XIt is occasionally necessary to move around while in insert mode
Xto delete characters on the same line (e.g. if there is a tab after
Xthe insertion position).  If your terminal allows motion while in
Xinsert mode you can give the capability \fBmi\fR to speed up inserting
Xin this case.  Omitting \fBmi\fR will affect only speed.   Some terminals
X(notably Datamedia's) must not have \fBmi\fR because of the way their
Xinsert mode works.
X.PP
XFinally, you can specify delete mode by giving \fBdm\fR and \fBed\fR
Xto enter and exit delete mode, and \fBdc\fR to delete a single character
Xwhile in delete mode.
X.PP
X.B "Highlighting, underlining, and visible bells"
X.PP
XIf your terminal has sequences to enter and exit standout mode these
Xcan be given as \fBso\fR and \fBse\fR respectively.
XIf there are several flavors of standout mode
X(such as inverse video, blinking, or underlining \-
Xhalf bright is not usually an acceptable \*(lqstandout\*(rq mode
Xunless the terminal is in inverse video mode constantly)
Xthe preferred mode is inverse video by itself.
XIf the code to change into or out of standout
Xmode leaves one or even two blank spaces on the screen,
Xas the TVI 912 and Teleray 1061 do,
Xthen \fBug\fR should be given to tell how many spaces are left.
X.PP
XCodes to begin underlining and end underlining can be given as \fBus\fR
Xand \fBue\fR respectively.
XIf the terminal has a code to underline the current character and move
Xthe cursor one space to the right, 
Xsuch as the Microterm Mime,
Xthis can be given as \fBuc\fR.
X(If the underline code does not move the cursor to the right,
Xgive the code followed by a nondestructive space.)
X.PP
XMany terminals, such as the HP 2621, automatically leave standout
Xmode when they move to a new line or the cursor is addressed.
XPrograms using standout mode should exit standout mode before
Xmoving the cursor or sending a newline.
X.PP
XIf the terminal has
Xa way of flashing the screen to indicate an error quietly (a bell replacement)
Xthen this can be given as \fBvb\fR; it must not move the cursor.
XIf the terminal should be placed in a different mode during
Xopen and visual modes of
X.I ex,
Xthis can be given as
X\fBvs\fR and \fBve\fR, sent at the start and end of these modes
Xrespectively.  These can be used to change, e.g., from a underline
Xto a block cursor and back.
X.PP
XIf the terminal needs to be in a special mode when running
Xa program that addresses the cursor,
Xthe codes to enter and exit this mode can be given as \fBti\fR and \fBte\fR.
XThis arises, for example, from terminals like the Concept with more than
Xone page of memory.
XIf the terminal has only memory relative cursor addressing and not screen
Xrelative cursor addressing, a one screen-sized window must be fixed into
Xthe terminal for cursor addressing to work properly.
X.PP
XIf your terminal correctly generates underlined characters
X(with no special codes needed)
Xeven though it does not overstrike,
Xthen you should give the capability \fBul\fR.
XIf overstrikes are erasable with a blank,
Xthen this should be indicated by giving \fBeo\fR.
X.PP
X.B Keypad
X.PP
XIf the terminal has a keypad that transmits codes when the keys are pressed,
Xthis information can be given. Note that it is not possible to handle
Xterminals where the keypad only works in local (this applies, for example,
Xto the unshifted HP 2621 keys).
XIf the keypad can be set to transmit or not transmit,
Xgive these codes as \fBks\fR and \fBke\fR.
XOtherwise the keypad is assumed to always transmit.
XThe codes sent by the left arrow, right arrow, up arrow, down arrow,
Xand home keys can be given as \fBkl, kr, ku, kd, \fRand\fB kh\fR respectively.
XIf there are function keys such as f0, f1, ..., f9, the codes they send
Xcan be given as \fBk0, k1, ..., k9\fR.
XIf these keys have labels other than the default f0 through f9, the labels
Xcan be given as \fBl0, l1, ..., l9\fR.
XIf there are other keys that transmit the same code as the terminal expects
Xfor the corresponding function, such as clear screen, the \fItermcap\fP
X2 letter codes can be given in the \fBko\fR capability,
Xfor example, \*(lq:ko=cl,ll,sf,sb:\*(rq, which says that the terminal has
Xclear, home down, scroll down, and scroll up keys that transmit
Xthe same thing as the cl, ll, sf, and sb entries.
X.PP
XThe
X.B ma
Xentry is also used to indicate arrow keys on terminals which have
Xsingle character arrow keys.  It is obsolete but still in use in
Xversion 2 of vi, which must be run on some minicomputers due to
Xmemory limitations.
XThis field is redundant with
X.BR "kl, kr, ku, kd, " and " kh" .
XIt consists of groups of two characters.
XIn each group, the first character is what an arrow key sends, the
Xsecond character is the corresponding vi command.
XThese commands are
X.B h
Xfor
X.BR kl ,
X.B j
Xfor
X.BR kd ,
X.B k
Xfor
X.BR ku ,
X.B l
Xfor
X.BR kr ,
Xand
X.B H
Xfor
X.BR kh .
XFor example, the mime would be
X.B ":ma=^Kj^Zk^Xl:"
Xindicating arrow keys left (^H), down (^K), up (^Z), and right (^X).
X(There is no home key on the mime.)
X.PP
X.B Miscellaneous
X.PP
XIf the terminal requires other than a null (zero) character as a pad,
Xthen this can be given as \fBpc\fR.
X.PP
XIf tabs on the terminal require padding, or if the terminal uses a
Xcharacter other than \fB^I\fR to tab, then this can be given as \fBta\fR.
X.PP
XHazeltine terminals, which don't allow `~' characters to be printed should
Xindicate \fBhz\fR.
XDatamedia terminals, which echo carriage-return linefeed for carriage return
Xand then ignore a following linefeed should indicate \fBnc\fR.
XEarly Concept terminals, which ignore a linefeed immediately after an \fBam\fR
Xwrap, should indicate \fBxn\fR.
XIf an erase-eol is required to get rid of standout
X(instead of merely writing on top of it),
X\fBxs\fP should be given.
XTeleray terminals, where tabs turn all characters moved over to blanks,
Xshould indicate \fBxt\fR.
XOther specific terminal problems may be corrected by adding more
Xcapabilities of the form \fBx\fIx\fR.
X.PP
XOther capabilities
Xinclude \fBis\fR, an initialization string for the terminal,
Xand \fBif\fR, the name of a file containing long initialization strings.
XThese strings are expected to properly clear and then set the tabs
Xon the terminal, if the terminal has settable tabs.
XIf both are given, \fBis\fR will be printed before \fBif\fR.
XThis is useful where \fBif\fR is
X.I /usr/lib/tabset/std
Xbut \fBis\fR
Xclears the tabs first.
X.PP
X.B Similar Terminals
X.PP
XIf there are two very similar terminals,
Xone can be defined as being just like the other with certain exceptions.
XThe string capability \fBtc\fR can be given
Xwith the name of the similar terminal.
XThis capability must be \fIlast\fP and the combined length of the two entries
Xmust not exceed 1024. Since
X.I termlib
Xroutines search the entry from left to right, and since the tc capability is
Xreplaced by the corresponding entry, the capabilities given at the left
Xoverride the ones in the similar terminal.
XA capability can be canceled with \fBxx@\fR where xx is the capability.
XFor example, the entry
X.PP
X	hn\||\|2621nl:ks@:ke@:tc=2621:
X.PP
Xdefines a 2621nl that does not have the \fBks\fR or \fBke\fR capabilities,
Xand hence does not turn on the function key labels when in visual mode.
XThis is useful for different modes for a terminal, or for different
Xuser preferences.
X.SH FILES
X.DT
X/etc/termcap	file containing terminal descriptions
X.SH SEE ALSO
Xex(1), curses(3X), termcap(3X), tset(1), vi(1), ul(1), more(1)
X.SH AUTHOR
XWilliam Joy
X.br
XMark Horton added underlining and keypad support
X.SH BUGS
X.I Ex
Xallows only 256 characters for string capabilities, and the routines
Xin 
X.IR termcap (3X)
Xdo not check for overflow of this buffer.
XThe total length of a single entry (excluding only escaped newlines)
Xmay not exceed 1024.
X.PP
XThe
X.BR ma ,
X.BR vs ,
Xand
X.B ve
Xentries are specific to the
X.I vi
Xprogram.
X.PP
XNot all programs support all entries.
XThere are entries that are not supported by any program.
END_OF_FILE
  if test 25213 -ne `wc -c <'abc/tc/termcap.5'`; then
    echo shar: \"'abc/tc/termcap.5'\" unpacked with wrong size!
  fi
  # end of 'abc/tc/termcap.5'
fi
echo shar: End of archive 5 \(of 25\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0 # Just in case...
