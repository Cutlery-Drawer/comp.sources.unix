Subject:  v23i085:  ABC interactive programming environment, Part06/25
Newsgroups: comp.sources.unix
Approved: rsalz@uunet.UU.NET
X-Checksum-Snefru: b7706352 a11485aa 68c9e722 ad6bf350

Submitted-by: Steven Pemberton <steven@cwi.nl>
Posting-number: Volume 23, Issue 85
Archive-name: abc/part06

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  abc/bed/e1que2.c abc/boot/dump.c abc/tc/termcap
# Wrapped by rsalz@litchi.bbn.com on Mon Dec 17 13:27:55 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 6 (of 25)."'
if test -f 'abc/bed/e1que2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/bed/e1que2.c'\"
else
  echo shar: Extracting \"'abc/bed/e1que2.c'\" \(23165 characters\)
  sed "s/^X//" >'abc/bed/e1que2.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1986. */
X
X/*
X * B editor -- Manipulate queues of nodes, higher levels.
X */
X
X#include "b.h"
X#include "bedi.h"
X#include "etex.h"
X#include "feat.h"
X#include "bobj.h"
X#include "node.h"
X#include "supr.h"
X#include "queu.h"
X#include "gram.h"
X#include "tabl.h"
X#include "code.h"
X
Xextern bool lefttorite;
X	/* Set by edit() to signal we parse purely left-to-right */
X
X/*
X * Insert a queue of nodes at the focus
X * (which had better be some kind of a hole).
X * The nodes may also be a text, in which case the individual characters
X * are inserted.
X * Extensive changes to the parse tree may occur, and the node may be
X * broken up in its constituent parts (texts and other nodes) which
X * are then inserted individually.
X */
X
XVisible bool
Xins_queue(ep, pq, pq2)
X	register environ *ep;
X	register queue *pq;
X	register queue *pq2;
X{
X	register bool ok = Yes;
X	register node n;
X	register queue oldq2;
X	environ saveenv;
X	int oldindentation = focindent(ep);
X	int indentation = oldindentation;
X	string str;
X
X	leftvhole(ep);
X	while (ok && !emptyqueue(*pq)) {
X		n = queuebehead(pq);
X		if (Is_etext(n)) {
X			str= e_sstrval((value) n);
X			ok = ins_string(ep, str, pq2, 0);
X			e_fstrval(str);
X			
X			switch (e_ncharval(e_length((value) n), (value) n)) {
X				/* Last char */
X			case '\t':
X				++indentation;
X				break;
X			case '\b':
X				--indentation;
X				break;
X			case '\n':
X				while (focindent(ep) > indentation) {
X					if (!ins_newline(ep))
X						break;
X				}
X				break;
X			}
X		}
X		else {
X			Ecopy(*ep, saveenv);
X			oldq2 = qcopy(*pq2);
X			if (!ins_node(&saveenv, n, pq2)) {
X				Erelease(saveenv);
X				qrelease(*pq2);
X				*pq2 = oldq2;
X				if (symbol(n) == Hole)
X					ok = ins_string(ep, "?", pq2, 0);
X				else
X					splitnode(n, pq);
X			}
X			else {
X				Erelease(*ep);
X				Emove(saveenv, *ep);
X				qrelease(oldq2);
X			}
X		}
X		noderelease(n);
X	}
X#ifndef NDEBUG
X	if (!ok)
X		qshow(*pq, "ins_queue");
X#endif
X	qrelease(*pq);
X	for (indentation = focindent(ep);
X		indentation > oldindentation; --indentation)
X		stringtoqueue("\b", pq2); /* Pass on indentation to outer level */
X	return ok;
X}
X
X
X/*
X * Subroutine to insert a queue to the right of the focus
X * without affecting the focus position.
X */
X
XVisible bool
Xapp_queue(ep, pq)
X	environ *ep;
X	queue *pq;
X{
X	int where;
X	static int markbit = 1; /* To properly handle recursive calls */
X
X	if (emptyqueue(*pq))
X		return Yes;
X	where = focoffset(ep);
X	markbit <<= 1;
X	markpath(&ep->focus, markbit);
X	if (!ins_queue(ep, pq, pq)) {
X		markbit >>= 1;
X		return No;
X	}
X	if (!firstmarked(&ep->focus, markbit)) Abort();
X	unmkpath(&ep->focus, markbit);
X	markbit >>= 1;
X	ep->spflag = No;
X	fixfocus(ep, where);
X	return Yes;
X}
X
X
X/*
X * Advance to next thing after current position.
X */
X
XVisible bool
Xmove_on(ep)
X	register environ *ep;
X{
X	register node n;
X	register string *rp;
X	register int sym;
X	register int ich = ichild(ep->focus);
X
X	if (!up(&ep->focus))
X		return No;
X	higher(ep);
X	n = tree(ep->focus);
X	rp = noderepr(n);
X	if (Fw_positive(rp[ich])) {
X		ep->mode = FHOLE;
X		ep->s1 = 2*ich + 1;
X		ep->s2 = 0;
X		if (ep->spflag) {
X			ep->spflag = No;
X			if (rp[ich][0] == ' ') {
X				++ep->s2;
X				if (fwidth(rp[ich]) > 1)
X					return Yes;
X			}
X			else
X				return Yes;
X		}
X		else
X			return Yes;
X	}
X	if (ich < nchildren(n)) {
X		s_downi(ep, ich+1);
X		sym = symbol(tree(ep->focus));
X		if (sym == Hole || sym == Optional)
X			ep->mode = WHOLE;
X		else
X			ep->mode = ATBEGIN;
X		return Yes;
X	}
X	ep->mode = ATEND;
X	return Yes;
X}
X
X
X/*
X * Like move_on but moves through fixed texts, skipping only spaces
X * and empty strings.
X * <<<<< This code is a dinosaur and should be revised. >>>>>
X */
X
XVisible bool
Xfix_move(ep)
X	register environ *ep;
X{
X	register int ich;
X	register int i;
X	register string *rp;
X	register string cp;
X
X	Assert(ep->mode == FHOLE);
X
X	ich = ep->s1/2;
X	rp = noderepr(tree(ep->focus));
X	cp = rp[ich];
X	if (cp) {
X		i = ep->s2;
X		Assert(i <= Fwidth(cp));
X		if (cp[i] == ' ') {
X			do {
X				++i;
X			} while (cp[i] == ' ');
X		}
X		if (cp[i] == '\b' || cp[i] == '\t') {
X			++i;
X			Assert(!cp[i]);
X		}
X		else if (cp[i]) {
X			if (i == ep->s2)
X				return No;
X			ep->s2 = i;
X			return Yes;
X		}
X	}
X
X	if (ich >= nchildren(tree(ep->focus)))
X		ep->mode = ATEND;
X	else {
X		s_downi(ep, ich+1);
X		if (symbol(tree(ep->focus)) == Hole
X			|| symbol(tree(ep->focus)) == Optional)
X			ep->mode = WHOLE;
X		else
X			ep->mode = ATBEGIN;
X	}
X	return Yes;
X}
X
X
X/*
X * Insert a node in the parse tree.
X */
X
XHidden bool
Xins_node(ep, n, pq)
X	register environ *ep;
X	register node n;
X	register queue *pq;
X{
X	register int sym;
X	register node nn;
X	register markbits x;
X	string *rp;
X	node fc;
X
X	if (symbol(n) == Optional)
X		return Yes;
X
X	for (;;) {
X		switch (ep->mode) {
X
X		case FHOLE:
X			if (ep->s2 < lenitem(ep) || !fix_move(ep))
X				return No;
X			continue;
X
X		case VHOLE:
X			if (ep->s2 == lenitem(ep)
X			    && symbol(tree(ep->focus)) == Name
X			    && (symbol(n) == Text1_display
X			        || symbol(n) == Text2_display))
X			{
X				/* enable insertion of name before */
X				/* text display with conversion */
X				ep->mode= ATEND;
X				continue;
X			}
X			if (ep->s2 < lenitem(ep) || !move_on(ep))
X				return No;
X			continue;
X
X		case ATBEGIN:
X			sym = symbol(tree(ep->focus));
X			if (sym == Optional || sym == Hole) {
X				ep->mode = WHOLE;
X				continue;
X			}
X			x = marks(tree(ep->focus));
X			if (joinnodes(&ep->focus, n, tree(ep->focus), No)) {
X				if (x) {
X					s_downi(ep, 2);
X					markpath(&ep->focus, x);
X					s_up(ep);
X				}
X				s_down(ep);
X				ep->mode = ATEND;
X				leftvhole(ep);
X				return Yes;
X			}
X			nn = tree(ep->focus);
X			rp = noderepr(nn);
X			if (nchildren(nn) >= 1 && Fw_zero(rp[0])) {
X				fc= firstchild(nn);
X				sym = (Is_etext(fc) ? (-1) : symbol(fc));
X				if (sym == Hole || sym == Optional) {
X					s_down(ep);
X					if (fitnode(&ep->focus, n)) {
X						ep->mode = ATEND;
X						leftvhole(ep);
X						return Yes;
X					}
X					s_up(ep);
X				}
X			}
X			nn = nodecopy(nn);
X			if (!fitnode(&ep->focus, n)) {
X				addtoqueue(pq, nn);
X				noderelease(nn);
X				delfocus(&ep->focus);
X				ep->mode = WHOLE;
X				continue;
X			}
X			if (downrite(&ep->focus)) {
X				if (!Is_etext(tree(ep->focus))) {
X					sym = symbol(tree(ep->focus));
X					if (sym == Hole || sym == Optional) {
X						if (fitnode(&ep->focus, nn)) {
X							noderelease(nn);
X							nn = Nnil;
X						}
X					}
X				}
X				else
X					VOID up(&ep->focus);
X			}
X			if (nn) {
X				addtoqueue(pq, nn);
X				noderelease(nn);
X			}
X			ep->mode = ATEND;
X			leftvhole(ep);
X			return Yes;
X
X		case WHOLE:
X			sym = symbol(tree(ep->focus));
X			Assert(sym == Optional || sym == Hole);
X			do {
X				higher(ep); /* Only for second time around */
X				if (fitnode(&ep->focus, n)) {
X					ep->mode = ATEND;
X					leftvhole(ep);
X					return Yes;
X				}
X			} while (resttoqueue(&ep->focus, pq));
X			ep->mode = ATEND;
X			/* Fall through */
X		case ATEND:
X			do {
X				higher(ep); /* Only for second time around */
X				if (joinnodes(&ep->focus, tree(ep->focus), n, ep->spflag)) {
X					ep->spflag = No;
X					leftvhole(ep);
X					return Yes;
X				}
X			} while (resttoqueue(&ep->focus, pq)
X				|| move_on(ep) && ep->mode == ATEND);
X			return No;
X
X		default:
X			return No;
X
X		}
X	}
X}
X
X/* Hacked refinements for ins_string below, mainly to fix problems
X * with suggestions and suggestion-rests for commands; timo
X */
X
XHidden bool softening_builtin(inch, sym) char inch; int sym; {
X	/* refinement for ins_string to enable softening of
X	 * builtin commands, e.g REMOVE ? FROM ? -> REMOVE M?
X	 */
X	return (bool) (isupper(inch) && Put <= sym && sym < Check);
X}
X
XHidden bool fits_kwchar(n, i, ch) node n; int i; int ch; {
X	/* REPORT i'th char of Keyword(n) == ch */
X	string s;
X	int si;
X	
X	Assert(symbol(n) == Keyword && i >= 0);
X	s= e_strval((value) firstchild(n));
X	if (strlen(s) < i)
X		return No;
X	/* else: */
X	si= s[i];
X	return (bool) si == ch;
X}
X
XHidden bool fits_nextkwstart(n, ch) node n; int ch; {
X	register int sym= symbol(n);
X	
X	if (sym == Keyword)
X		return fits_kwchar(n, 0, ch);
X	else if (sym == Kw_plus)
X		return fits_nextkwstart(child(n, 1), ch);
X	/* else: */
X	return No; /* can't accept Hole '?' as fit of Capital ch */
X}
X
X/* Return whether rest of user-defined-command stems from suggestion.
X * There is a problem with tailing Keywords, since we don't know whether
X * they stem from suggestion;
X * if they do, the user can accept them explicitly,
X * or by blind-typing, which has been handled by now;
X * if they don't, we should not kill them now!
X */
X
XHidden bool is_varsuggrest(n, exphole_seen) node n; bool exphole_seen; {
X	register int sym= symbol(n);
X	register node n2;
X	register int sym2;
X	
X	if (sym == Kw_plus) {
X		n2= child(n, 2);
X		sym2= symbol(n2);
X		if (sym2 == Hole)
X			return Yes;
X		else if (sym2 == Kw_plus || sym2 == Exp_plus || sym2 == Keyword)
X			return (is_varsuggrest(n2, exphole_seen));
X		/* else: FAIL */
X	}
X	else if (sym == Exp_plus) {
X		if (symbol(child(n, 1)) != Hole)
X			return No;
X		/* else: */
X		n2= child(n, 2);
X		sym2= symbol(n2);
X		if (sym2 == Hole)
X			/* Hole is safety-net; cannot happen? */
X			return Yes;
X		else if (sym2 == Kw_plus || sym2 == Exp_plus || sym2 == Keyword)
X			return is_varsuggrest(n2, Yes);
X	}
X	else if (sym == Keyword && exphole_seen)
X		return Yes;
X	/* else: */
X	return No;
X}
X
X/* Focus at end of expr in Exp_plus, or after space in Kw_plus;
X * acknowledge **pstr (== Capital) iff it fits start of Keyword
X * following focus;
X * else, if rest resembles suggestion-rest, kill that.
X */
XHidden bool ack_or_kill_varsuggrest(ep, pstr) environ *ep; string *pstr; {
X	node nn= tree(ep->focus);
X	
X	if (fits_nextkwstart(child(nn, 2), (int)**pstr)) {
X		/* accept start_char in Keyword */
X		s_downi(ep, 2);
X		Assert(symbol(tree(ep->focus)) != Exp_plus);
X		if (symbol(tree(ep->focus)) == Kw_plus)
X			s_downi(ep, 1);
X		Assert(symbol(tree(ep->focus)) == Keyword);
X		ep->s1= 2;
X		ep->s2= 1;
X		ep->mode= VHOLE;
X		ep->spflag= No;
X		++*pstr;
X		return Yes;
X	}
X	else if (is_varsuggrest(child(nn, 2), No)) {
X		/* kill non-matching suggestion-rest */
X		s_downi(ep, 2);
X		treereplace(&ep->focus, gram(Hole));
X		ep->mode= WHOLE;
X		ep->spflag= No;
X		return Yes;
X	}
X	return No;
X}
X
X/*
X * Another hack to turn {a.?} (where a. is seen as a name)
X * upon receit of a second "." into {a.?}, where a is the name
X * and . is seen as an operator (to enable '?' after ')
X */
X
XHidden bool range_hack(ep) register environ *ep; {
X	path pa;
X	int sympa;
X	string str;
X	node n1;
X	node n2;
X	node nn;
X	int s2= ep->s2;
X	bool r= No;
X	
X	if (s2 <= 1) return No;
X	
X	pa= parent(ep->focus);
X	sympa= pa ? symbol(tree(pa)) : Rootsymbol;
X
X	if (sympa == List_or_table_display || sympa == List_filler_series) {
X		str= e_sstrval((value) firstchild(tree(ep->focus)));
X		if (s2 == strlen(str) && str[s2-1] == '.') {
X			str[s2-1]= '\0';
X			n1= gram(Name);
X			setchild(&n1, 1, (node) mk_etext(str));
X			n2= gram(Operator);
X			setchild(&n2, 1, (node) mk_etext("."));
X			nn= gram(Blocked);
X			setchild(&nn, 1, n1);
X			setchild(&nn, 2, n2);
X			treereplace(&ep->focus, nn);
X			s_downi(ep, 2);
X			ep->mode= ATEND;
X			r= Yes;
X		}
X		e_fstrval(str);
X	}
X	return r;
X}
X
X/*
X * Insert a string in the parse tree.
X *
X * justgoon is Yes if the last key seen was a lower case
X * letter that was inserted as such.  In this case, some
X * code can be skipped, in particular in ins2.c (which
X * amounts to a so called horrible hack).
X */
X
XVisible bool justgoon = No;
X
X#define NEXT_CH (++str, alt_c = 0)
X
XVisible bool
Xins_string(ep, str, pq, alt_c)
X	register environ *ep;
X	/*auto*/ string str;
X	register queue *pq;
X	int alt_c;
X{
X	register node nn;
X	auto value v;
X	char buf[1024];
X	register string repr;
X	string oldstr;
X	register int sym;
X	register int len;
X	bool inter_active = alt_c != 0;
X	path pa;
X
X	if (alt_c < 0)
X		alt_c = 0;
X	while (*str) {
X		switch (*str) {
X
X		case '\n':
X			if (!ins_newline(ep))
X				return No;
X			/* Fall through */
X		case '\t':
X		case '\b':
X			NEXT_CH;
X			continue;
X
X		}
X		switch (ep->mode) {
X
X		case ATBEGIN:
X			nn = tree(ep->focus);
X			if (Is_etext(nn)) {
X				ep->s1 = 2*ichild(ep->focus);
X				ep->s2 = 0;
X				ep->mode = VHOLE;
X				s_up(ep);
X				continue;
X			}
X			sym = symbol(nn);
X			if (sym != Optional && sym != Hole) {
X				if (fwidth(noderepr(nn)[0]) == 0) {
X					if (down(&ep->focus))
X						break;
X				}
X				addtoqueue(pq, nn);
X				delfocus(&ep->focus);
X			}
X			ep->mode = WHOLE;
X			/* Fall through */
X		case WHOLE:
X			nn = tree(ep->focus);
X			sym = symbol(nn);
X			Assert(sym == Hole || sym == Optional);
X			while ((len = fitstring(&ep->focus, str, alt_c)) == 0) {
X				if (sym == Optional) {
X					if (!move_on(ep)) {
X						if (*str == ' ')
X							NEXT_CH;
X						else
X							return No;
X					}
X					break;
X				}
X				if (!inter_active && *str == '?') {
X					NEXT_CH;
X					ep->mode = ATEND;
X					break;
X				}
X				if (resttoqueue(&ep->focus, pq))
X					higher(ep);
X				else if (spacefix(ep))
X					break;
X				else if (*str == ' ') {
X					NEXT_CH;
X					break;
X				}
X				else if (inter_active)
X					return No;
X				else {
X					ep->mode = ATEND;
X					break;
X				}
X			}
X			if (len > 0) {
X				str += len;
X				alt_c = 0;
X				fixfocus(ep, len);
X			}
X			break;
X
X		case ATEND:
X			if ((pa=parent(ep->focus)) &&
X			    symbol(tree(pa)) == Exp_plus &&
X			    ichild(ep->focus) == 1 &&
X			    isupper(*str))
X			{	/* at end of expr in Exp_plus */
X				s_up(ep);
X				if (ack_or_kill_varsuggrest(ep, &str))
X					break;
X				/* else: undo up */
X				s_downi(ep, 1);
X			}
X			if (add_string(ep, &str)) {
X				alt_c = 0;
X				break;
X			}
X			
X			len = joinstring(&ep->focus, str, ep->spflag,
X				alt_c ? alt_c : inter_active ? -1 : 0, Yes);
X			if (len > 0) {
X				s_downi(ep, 2);
X				ep->spflag = No;
X				fixfocus(ep, len);
X			}
X			else {
X				if (resttoqueue(&ep->focus, pq)) {
X					higher(ep);
X					break;
X				}
X				if (move_on(ep))
X					break;
X				if (*str == ' ') {
X					NEXT_CH;
X					break;
X				}
X				return No;
X			}
X			str += len;
X			alt_c = 0;
X			break;
X
X		case FHOLE:
X			nn = tree(ep->focus);
X			sym = symbol(nn);
X			if (sym == Edit_unit && ep->s1 == 1 && ep->s2 == 1
X			    && symbol(child(nn, 1)) == Sugghowname)
X			{
X				s_downi(ep, 1);
X				ep->mode= VHOLE;
X				ep->s1= 2; ep->s2= 0;
X				break;
X			}
X			if (sym == Formal_kw_plus 
X			    && ep->s1 == 3 && ep->s2 == 1 && alt_c)
X			{
X				/* force Formal_naming_plus */
X				alt_c= 0;
X				/* and go_on */
X			}
X			if ((sym == Kw_plus || sym == Exp_plus)
X			    && ep->s1 == 3 && ep->s2 == 1) {
X				/* after space before Keyword */
X				if (isupper(*str)) {
X					if (ack_or_kill_varsuggrest(ep, &str))
X						break;
X				}
X				else if (sym == Exp_plus) {
X					/* this wasn't handled properly */
X					/* e.g. ADD a >?<TO ?, 
X					 *	insert +,
X					 *	ADD a>?< + TO ? */
X					s_downi(ep, 1);
X					ep->mode= ATEND;
X					ep->spflag= Yes;
X					break;
X				}
X				else if (sym == Kw_plus && alt_c)
X				        	/* force Exp_plus */
X				        	alt_c = 0;
X				        	/* and go on: */
X			}
X			repr = noderepr(nn)[ep->s1/2];
X			if (ep->s2 >= fwidth(repr)
X			    &&
X			    (ep->s2 <= 0 || !isalpha(repr[0]) ||
X			     ((ep->spflag || repr[ep->s2-1] == ' ')
X			      && !softening_builtin(*str, symbol(nn))
X			   )))
X			{	/* At end */
X				if (ep->s1/2 < nchildren(nn)) {
X					s_downi(ep, ep->s1/2 + 1);
X					ep->mode = ATBEGIN; /* Of next child */
X				}
X				else
X					ep->mode = ATEND;
X				break;
X			}
X			if ((*str == ':' || *str == ' ') && *str == repr[ep->s2]) {
X				/*****
X				 * Quick hack for insertion of test-suites and refinements:
X				 *****/
X				++ep->s2;
X				NEXT_CH;
X				continue;
X			}
X			if (!lefttorite)
X				nosuggtoqueue(ep, pq);
X			oldstr = str;
X			if (resuggest(ep, &str, alt_c) || soften(ep, &str, alt_c)) {
X				if (str > oldstr)
X					alt_c = 0;
X				continue;
X			}
X			if (fix_move(ep))
X				continue;
X			return No;
X
X		case VHOLE:
X			Assert(!(ep->s1&1));
X			nn = tree(ep->focus);
X			sym = symbol(nn);
X#ifdef USERSUGG
X			if (sym == Suggestion) {
X				if (*str == '?')
X					return No;
X				if (newsugg(ep, &str, alt_c))
X					alt_c = 0;
X				else {
X					killsugg(ep, &str);
X				}
X				continue;
X			}
X			else if (sym == Sugghowname) {
X				if (*str == '?')
X					return No;
X				if (!newhowsugg(ep, &str, alt_c))
X					return No;
X				/* else */
X				continue;
X			}
X#endif /* USERSUGG */
X			if (sym == Keyword && 
X			    (fits_kwchar(nn, ep->s2, (int)*str)
X			     ||
X			     (ep->s2 > 0 && alt_c > 0 &&
X			      fits_kwchar(nn, ep->s2, alt_c)
X			   )))
X			{
X				/* accept next char in Keyword */
X				/* required for blind typist rule; timo */
X				/* also enables lowercase within KW */
X				ep->s2++;
X				NEXT_CH;
X				break;
X			}
X			if (sym == Name && *str == '.' && range_hack(ep)) {
X				break;
X			}
X			s_downi(ep, ep->s1/2);
X			v = copy((value) tree(ep->focus));
X			len = 0;
X			if (!ep->spflag) {
X				for (; len < sizeof buf - 1 && str[len]
X						&& mayinsert(nn, ep->s1/2, !!(ep->s2 + len),
X							str[len]);
X					++len) {
X					buf[len] = str[len];
X				}
X				justgoon = len > 0 && islower(str[len-1]);
X				if (len <= 0 && alt_c
X					&& mayinsert(nn, ep->s1/2, !!(ep->s2 + len), alt_c)) {
X					buf[0] = alt_c;
X					len = 1;
X				}
X			}
X			if (len > 0) { /* Effectuate change */
X				str += len;
X				alt_c = 0;
X				Assert(Is_etext(v));
X				buf[len] = 0;
X				putintrim(&v, ep->s2, e_length(v) - ep->s2, buf);
X				treereplace(&ep->focus, (node) v);
X				s_up(ep);
X				ep->spflag = No;
X				ep->s2 += len;
X			}
X			else { /* Nothing inserted */
X				if (ep->s2 == 0) { /* Whole string rejected */
X					addtoqueue(pq, (node)v);
X					release(v);
X					s_up(ep);
X					delfocus(&ep->focus);
X					ep->mode = WHOLE;
X					break;
X				}
X				if (ep->s2 < e_length(v)) {
X					value w;
X/*					addstringtoqueue(pq, e_strval(v) + ep->s2); */
X					w= e_ibehead(v, ep->s2 + 1);
X					addtoqueue(pq, (node) w);
X					release(w);
X					/* putintrim(&v, ep->s2, 0, ""); */
X					v= e_icurtail(w= v, ep->s2);
X					release(w);
X					treereplace(&ep->focus, (node) v);
X				}
X				else
X					release(v);
X				if (!move_on(ep)) Abort(); /* ==> up, cancelling s_downi! */
X			}
X			break;
X
X		default:
X			Abort();
X
X		} /* end switch (ep->mode) */
X	} /* end while (*str) */
X
X	return Yes;
X}
X
X
X/*
X * See if two nodes can be joined in a hole.
X * 'Spflag' indicates whether a space must be present between the nodes
X * (required or forbidden).
X * Either of n1, n2 may actually be the current contents of the hole.
X */
X
XHidden bool
Xjoinnodes(pp, n1, n2, spflag)
X	path *pp;
X	node n1;
X	node n2;
X	bool spflag;
X{
X	path pa = parent(*pp);
X	int sympa = pa ? symbol(tree(pa)) : Rootsymbol;
X	struct table *tp = &table[sympa];
X	struct classinfo *ci = tp->r_class[ichild(*pp) - 1];
X	classptr cp = ci->c_join;
X	int sym1 = symbol(n1);
X	int sym2 = symbol(n2);
X	int symcp;
X	int symfound = -1;
X
X	if (!cp)
X		return No;
X	for (; *cp; cp += 2) {
X		if (cp[0] != spflag + 1)
X			continue;
X		symcp = cp[1];
X		tp = &table[symcp];
X		if (isinclass(sym1, tp->r_class[0])
X			&& isinclass(sym2, tp->r_class[1])) {
X			symfound = symcp;
X			break;
X		}
X	}
X
X	if (symfound < 0)
X		return No;
X	n1 = nodecopy(n1);
X	n2 = nodecopy(n2); /* 'Cause one of them may overlap tree(*pp) */
X	treereplace(pp, table[symfound].r_node);
X	if (!down(pp)) Abort();
X	treereplace(pp, n1);
X	if (!rite(pp)) Abort();
X	treereplace(pp, n2);
X	if (!up(pp)) Abort();
X	return Yes;
X}
X
X
X/*
X * Try to join a node (implicit as tree(*pp)) with some text.
X * That is, try to replace the node by one with it as first child,
X * (some of) the text as second child, and nothing or a space in between.
X *
X * 'Spflag' indicates whether a space is desirable between the nodes
X * (but if No it is only used as advice).
X *
X * Returns the number of characters consumed from str.
X */
X
XVisible int
Xjoinstring(pp, str, spflag, alt_c, mayindent)
X	path *pp;
X	register string str;
X	register bool spflag;
X	int alt_c;
X	bool mayindent;
X{
X	register struct table *tp;
X	path pa = parent(*pp);
X	node n1;
X	struct classinfo *ci;
X	register classptr cp;
X	int sympa = pa ? symbol(tree(pa)) : Rootsymbol;
X	register int sym1;
X	register int symcp;
X	int symfound;
X	int len;
X	char buf[2];
X	bool inter_active = alt_c != 0;
X
X	if (alt_c < 0)
X		alt_c = 0;
X	ci = table[sympa].r_class[ichild(*pp) - 1];
X	Assert(ci);
X	cp = ci->c_join;
X	if (!cp)
X		return 0;
X
X	n1 = tree(*pp);
X	sym1 = symbol(n1);
X	symfound = -1;
X	for (; *cp; cp += 2) {
X		if (cp[0] < spflag + 1)
X			continue;
X		symcp = cp[1];
X		tp = &table[symcp];
X		if (!mayindent && tp->r_repr[1] && strchr(tp->r_repr[1], '\t'))
X			continue;
X		if (isinclass(sym1, tp->r_class[0])
X			&& ((canfitchar(str[0], tp->r_class[1]))
X				|| str[0] == '?' && !inter_active)) {
X			if (cp[0] == spflag + 1) {
X				symfound = symcp;
X				break;
X			}
X			if (symfound < 0)
X				symfound = symcp;
X		}
X	}
X
X	if (symfound < 0) { /* 1-level recursion */
X		if (!alt_c)
X			return 0;
X		buf[0] = alt_c;
X		buf[1] = 0;
X		return joinstring(pp, buf, spflag, 0, mayindent);
X	}
X	n1 = nodecopy(n1); /* 'Cause it overlaps tree(*pp) */
X	treereplace(pp, table[symfound].r_node);
X	if (!down(pp)) Abort();
X	treereplace(pp, n1);
X	if (!rite(pp)) Abort();
X	len = fitstring(pp, str, 0);
X	if (len == 0 && str[0] == '?')
X		len = 1;
X	Assert(len > 0); /* Disagreement between canfitchar and fitstring */
X	if (!up(pp)) Abort();
X	return len;
X}
X
X
X/*
X * Similar to joinstring, but now the string must match the delimiter
X * rather than being acceptable as second child.
X * (Interface has changed to resemble resuggest/soften.)
X */
X
XHidden bool
Xadd_string(ep, pstr, alt_c)
X	environ *ep;
X	string *pstr;
X{
X	register struct table *tp;
X	path pa = parent(ep->focus);
X	node n1;
X	struct classinfo *ci;
X	register classptr cp;
X	int sympa = pa ? symbol(tree(pa)) : Rootsymbol;
X	register int sym1;
X	register int symcp;
X	register int c;
X
X	ci = table[sympa].r_class[ichild(ep->focus) - 1];
X	Assert(ci);
X	cp = ci->c_append;
X	if (!cp)
X		return No;
X	n1 = tree(ep->focus);
X	sym1 = symbol(n1);
X	c = **pstr;
X	for (; *cp; cp += 2) {
X		if ((*cp&0177) != c)
X			continue;
X		symcp = cp[1];
X		tp = &table[symcp];
X		if (isinclass(sym1, tp->r_class[0]))
X			break;
X	}
X	if (!*cp)
X		return No;
X	++*pstr;
X	if (c == ' ') {
X		ep->spflag = Yes;
X		return Yes;
X	}
X	n1 = nodecopy(n1); /* 'Cause it overlaps tree(ep->focus) */
X	treereplace(&ep->focus, table[symcp].r_node);
X	s_down(ep);
X	treereplace(&ep->focus, n1);
X	s_up(ep);
X	ep->mode = FHOLE;
X	ep->s1 = 3;
X	ep->s2 = (*cp&0200) ? 2 : 1;
X	ep->spflag = No;
X	return Yes;
X}
X
X
X/*
X * See whether a character may start a new node in a hole with given class.
X */
X
XHidden bool
Xcanfitchar(c, ci)
X	int c;
X	struct classinfo *ci;
X{
X	register classptr cp;
X	register int code = Code(c);
X
X	Assert(ci);
X	cp = ci->c_insert;
X	Assert(cp);
X	for (; *cp; cp += 2) {
X		if (cp[0] == code)
X			return Yes;
X	}
X	return No;
X}
X
X
X#ifndef NDEBUG
X/*
X * Debug routine to print a queue.
X */
X
XVisible Procedure
Xqshow(q, where)
X	queue q;
X	string where;
X{
X	node n;
X	char buf[256];
X	string cp;
X	string sp;
X
X	sprintf(buf, "%s:", where);
X	cp = buf + strlen(buf);
X	for (;q; q = q->q_link) {
X		n = q->q_data;
X		*cp++ = ' ';
X		if (Is_etext(n)) {
X			*cp++ = '"';
X			for (sp = e_strval((value) n); *sp; ++sp) {
X				if (isprint(*sp) || *sp == ' ') {
X					*cp++ = *sp;
X					if (*sp == '"')
X						*cp++ = *sp;
X				}
X				else {
X					sprintf(cp, "\\%03o", *sp&0377);
X					cp += 4;
X				}
X			}
X			*cp++ = '"';
X		}
X		else {
X			strncpy(cp, table[symbol(n)].r_name, 80);
X			cp += strlen(cp);
X		}
X		if (cp >= buf+80) {
X			strcpy(buf+76, "...");
X			break;
X		}
X	}
X	*cp = 0;
X	debug(buf);
X}
X#endif /* NDEBUG */
END_OF_FILE
  if test 23165 -ne `wc -c <'abc/bed/e1que2.c'`; then
    echo shar: \"'abc/bed/e1que2.c'\" unpacked with wrong size!
  fi
  # end of 'abc/bed/e1que2.c'
fi
if test -f 'abc/boot/dump.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/boot/dump.c'\"
else
  echo shar: Extracting \"'abc/boot/dump.c'\" \(5863 characters\)
  sed "s/^X//" >'abc/boot/dump.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */
X
X/*
X * Dump info in files for ABC editor.
X */
X
X#include "b.h"
X#include "main.h"
X
X#define Copyright \
X "/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1988. */\n\n"
X#define Warning \
X "/* WARNING: this file is constructed by 'mktable'. */\n"
X#define Change \
X "/* If you want to change the grammar, see ../boot/README. */\n\n"
X
XVisible Procedure dump_files() {
X	
X	dump_tables();
X	
X	dump_include();
X}
X	
XHidden Procedure dump_tables() {
X	
X	dump_title(tfp, "Data file with grammar tables");
X	fprintf(tfp, "#include \"b.h\"\n");
X	fprintf(tfp, "#include \"bedi.h\"\n");
X	fprintf(tfp, "#include \"%s\"\n\n", hfile);
X	dump_classdef();
X	dump_symdef();
X	dump_lexdef();
X}
X
XHidden Procedure dump_title(xfp, title) FILE *xfp; string title; {
X	fprintf(xfp, Copyright);
X	fprintf(xfp, "/* %s. */\n\n", title);
X	fprintf(xfp, Warning);
X	fprintf(xfp, Change);
X}
X
XHidden Procedure dump_classdef() {
X	struct classinfo *pclass;
X	int iclass;
X	
X	for (iclass= 0; iclass < nclass; iclass++) {
X		pclass= &classdef[iclass];
X		dump_array(pclass->c_syms, 's', iclass);
X		dump_array(pclass->c_insert, 'i', iclass);
X		dump_array(pclass->c_append, 'a', iclass);
X		dump_array(pclass->c_join, 'j', iclass);
X	}
X	fprintf(tfp, "\nstruct classinfo cl[%d] = {\n", nclass);
X	for (iclass= 0; iclass < nclass; iclass++) {
X		pclass= &classdef[iclass];
X		fprintf(tfp, "   {");
X		dump_adr(pclass->c_syms, 's', iclass);
X		fprintf(tfp, ", ");
X		dump_adr(pclass->c_insert, 'i', iclass);
X		fprintf(tfp, ", ");
X		dump_adr(pclass->c_append, 'a', iclass);
X		fprintf(tfp, ", ");
X		dump_adr(pclass->c_join, 'j', iclass);
X		if (iclass < nclass-1)
X			fprintf(tfp, "},");
X		else
X			fprintf(tfp, "}");
X		fprintf(tfp, "	/* %s */\n", pclass->c_name);
X	}
X	fprintf(tfp, "};\n\n");
X}	
X
XHidden Procedure dump_array(parray, ch, icl) itemptr parray; char ch; int icl; {
X	int w;	/* guess line width */
X	int a;
X	
X	if (parray == NULL)
X		return;
X	fprintf(tfp, "classelem %c%d[]= {", ch, icl);
X	w= 18;
X	while (!Isnilitem(*parray)) {
X		if (w >= 70) {
X			fprintf(tfp, "\n\t");
X			w= 8;
X		}
X		a= (int)*parray;
X		fprintf(tfp, "%d,", a);
X		w+= (a>99 ? 4: a>9 ? 3: 2);
X		parray++;
X	}
X	fprintf(tfp, "0};\n");
X}
X
XHidden Procedure dump_adr(parray, ch, icl) itemptr parray; char ch; int icl; {
X	
X	if (parray == NULL)
X		fprintf(tfp, "0");
X	else
X		fprintf(tfp, "%c%d", ch, icl);
X}
X
XHidden Procedure dump_symdef() {
X	int isym;
X
X	fprintf(tfp, "static struct table abc_grammar[%d] = {\n", nsym);
X	for (isym= 0; isym < nsym; ++isym)
X		dumpsymbol(isym);
X	fprintf(tfp, "};\n\n");
X	
X	fprintf(tfp, "struct table *table= abc_grammar;\n");
X}
X	
XHidden Procedure dumpsymbol(isym) int isym; {
X	struct syminfo *psym;
X	int ich;
X	
X	fprintf(tfp, "   /* %-3d */ {", isym);
X	psym= &symdef[isym];
X	dumpstring(psym->s_name);
X	fprintf(tfp, ", {");
X	for (ich= 0; ich <= MAXCHILD; ++ich) {
X		dumpstring(psym->s_repr[ich]);
X		if (ich == MAXCHILD)
X			break;
X		fprintf(tfp, ",");
X	}
X	fprintf(tfp, "}, {");
X	for (ich= 0; ich < MAXCHILD; ++ich) {
X		dump_cl(psym->s_class[ich]);
X		if (ich == MAXCHILD-1)
X			break;
X		fprintf(tfp, ",");
X	}
X	fprintf(tfp, "}, 0}%s\n",  (isym==nsym-1 ? "" : ","));
X}
X
XHidden Procedure dumpstring(s) string s; {
X	char c;
X	
X	if (s == NULL) {
X		fprintf(tfp, "0");
X		return;
X	}
X	fputc('"', tfp);
X	for (; (c= *s) != '\0'; ++s) {
X		if (c == '\b')
X			fprintf(tfp, "\\b");
X		else if (c == '\t')
X			fprintf(tfp, "\\t");
X		else if (c == '\n')
X			fprintf(tfp, "\\n");
X		else if (c == '\\' || c == '"')
X			fprintf(tfp, "\\%c", c);
X		else
X			fputc(c, tfp);
X	}
X	fprintf(tfp, "\"");
X}
X
XHidden Procedure dump_cl(ind) item ind; {
X	if (ind >= 0)
X		fprintf(tfp, "&cl[%d]", ind);
X	else
X		fprintf(tfp, "0");
X}
X
XHidden Procedure dump_lexdef() {
X	int ilex;
X
X	fprintf(tfp, "\nstatic struct lexinfo abc_lexicals[%d] = {\n", nlex);
X	for (ilex= 0; ilex < nlex; ++ilex)
X		dumplex(&lexdef[ilex], (ilex==nlex-1 ? "" : ","));
X	fprintf(tfp, "};\n\n");
X	
X	fprintf(tfp, "struct lexinfo *lextab= abc_lexicals;\n");
X}
X
XHidden Procedure dumplex(plex, sep) struct lexinfo *plex; string sep; {
X	
X	fprintf(tfp, "   {");
X	dumpstring(plex->l_start);
X	fprintf(tfp, ", ");
X	dumpstring(plex->l_cont);
X	fprintf(tfp, "}%s	/* %s */\n", sep, plex->l_name);
X}
X	
XHidden Procedure dump_include() {
X	
X	dump_title(ifp, "Header file with grammar table structure");
X	if (nsym+nlex < 128)
X		fprintf(ifp, "typedef char classelem;\n");
X	else
X		fprintf(ifp, "typedef short classelem;\n");
X	
X	fprintf(ifp, "typedef classelem *classptr;\n\n");
X	
X	fprintf(ifp, "struct classinfo {\n");
X	fprintf(ifp, "   classptr c_class;\n");
X	fprintf(ifp, "   classptr c_insert;\n");
X	fprintf(ifp, "   classptr c_append;\n");
X	fprintf(ifp, "   classptr c_join;\n");
X	fprintf(ifp, "};\n\n");
X	
X	fprintf(ifp, "#define MAXCHILD %d\n\n", MAXCHILD);
X	
X	fprintf(ifp, "struct table {\n");
X	fprintf(ifp, "   string r_name;\n");
X	fprintf(ifp, "   string r_repr[MAXCHILD+1];\n");
X	fprintf(ifp, "   struct classinfo *r_class[MAXCHILD];\n");
X	fprintf(ifp, "   node r_node;\n");
X	fprintf(ifp, "};\n\n");
X	
X	fprintf(ifp, "extern struct table *table;\n");
X	fprintf(ifp, "#define TABLEN %d\n", nsym);
X	
X	fprintf(ifp, "struct lexinfo {\n");
X	fprintf(ifp, "   string l_start;\n");
X	fprintf(ifp, "   string l_continue;\n");
X	fprintf(ifp, "};\n\n");
X	
X	fprintf(ifp, "extern struct lexinfo *lextab;\n");
X	
X	dump_isymdef();
X	
X	dump_ilexdef();
X}
X
XHidden Procedure dump_isymdef() {
X	int isym;
X	
X	fprintf(ifp, "\n/* Symbols indexing grammar table */\n\n");
X	for (isym= 0; isym < nsym; isym++) {
X		fprintf(ifp, "#define %s %d\n", symdef[isym].s_name, isym);
X	}
X}
X
XHidden Procedure dump_ilexdef() {
X	int ilex;
X	
X	fprintf(ifp, "\n/* LEXICAL symbols */\n");
X	fprintf(ifp, "\n#define LEXICAL %d\n\n", nlexical);
X	for (ilex= 0; ilex < nlex; ilex++) {
X		fprintf(ifp, "#define %s %d\n", 
X			lexdef[ilex].l_name, nlexical+ilex);
X	}
X	fprintf(ifp, "\n#define NLEX %d\n", nlex);
X}
END_OF_FILE
  if test 5863 -ne `wc -c <'abc/boot/dump.c'`; then
    echo shar: \"'abc/boot/dump.c'\" unpacked with wrong size!
  fi
  # end of 'abc/boot/dump.c'
fi
if test -f 'abc/tc/termcap' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abc/tc/termcap'\"
else
  echo shar: Extracting \"'abc/tc/termcap'\" \(22050 characters\)
  sed "s/^X//" >'abc/tc/termcap' <<'END_OF_FILE'
X# This file has been shortened considerably for the ABC distribution
X# and derives from a very old public-domain version. It should only be seen
X# as an example.
X# Ask yous boss to pay for a decent unix:-).
X#
X# This file describes capabilities of various terminals, as needed by
X# software such as screen editors.  It does not attempt to describe
X# printing terminals very well, nor graphics terminals.  Someday.
X# See termcap(5) in the Unix Programmers Manual for documentation.
X#
X# Conventions: First entry is two chars, first char is manufacturer,
X# second char is canonical name for model or mode.
X# Third entry is the one the editor will print with "set" command.
X# Last entry is verbose description.
X# Others are mnemonic synonyms for the terminal.
X#
X# Terminal naming conventions:
X# Terminal names look like <manufacturer> <model> - <modes/options>
X# Certain abbreviations (e.g. c100 for concept100) are also allowed
X# for upward compatibility.  The part to the left of the dash, if a
X# dash is present, describes the particular hardware of the terminal.
X# The part to the right can be used for flags indicating special ROM's,
X# extra memory, particular terminal modes, or user preferences.
X# All names are always in lower case, for consistency in typing.
X#
X# The following are conventionally used flags:
X#	rv	Terminal in reverse video mode (black on white)
X#	2p	Has two pages of memory.  Likewise 4p, 8p, etc.
X#	w	Wide - in 132 column mode.
X#	pp	Has a printer port which is used.
X#	na	No arrow keys - termcap ignores arrow keys which are
X#		actually there on the terminal, so the user can use
X#		the arrow keys locally.
X#  
X# There are some cases where the same name is used for two different
X# terminals, e.g. "teleray" or "2621" or "vt100".  In these cases,
X# if a site has one of these, they should choose a local default and
X# bring that terminal to the front in the reorder script.  This works
X# because tgetent picks the first match in /etc/termcap.
X# The list of names intentionally duplicated is:
X# 2621, c108, dtc, hp2621, teleray, tvi, vt100.
X#
X# If you absolutely MUST check for a specific terminal (this is discouraged)
X# check for the 2nd entry (the canonical form) since all other codes are
X# subject to change.  The two letter codes are there for version 6 and are
X# EXTREMELY subject to change, or even to go away if version 6 becomes for
X# all practical purposes obsolete.  We would much rather put in special
X# capabilities to describe your terminal rather than having you key on the
X# name.
X#
X#  Special manufacturer codes:
X#	A: hardcopy daisy wheel terminals
X#	M: Misc. (with only a few terminals)
X#  	q: Homemade
X#  	s: special (dialup, etc.)
X#  
X# Comments in this file begin with # - they cannot appear in the middle
X# of a termcap entry.  Individual entries are commented out by
X# placing a period between the colon and the capability name.
X#
X#  This file is to be installed with an editor script (reorder)
X#  that moves the most common terminals to the front of the file.
X#  If the source is not available, it can be constructed by sorting
X#  the above entries by the 2 char initial code.
X#
X# ...
X#
X# CIT 80  - vt 100 emulator, the termcap has been modified to remove
X#           the delay times and do an auto tab set rather than the indirect 
X#           file used in vt100.
XMT|cit80|cit 80|Citoh 80:\
X	:co#80:li#24:am:cl=\E[;H\EJ:bs:cm=\E[%i%2;%2H:nd=\E[C:up=\E[A:\
X	:ce=\EK:cd=\EJ:is=\E>:ks=\E[?1h\E=:ke=\E[?1l\E>:\
X	:ku=\EOA:kd=\EOB:kr=\EOC:kl=\EOD:
X# AlternateCIT 101 - vt 100 emulator, the termcap has been modified to remove
X#           the delay times and do an auto tab set rather than the indirect 
X#           file used in vt100.
X#	    Uses 23 lines so can run citsys (like h19sys).
XMU|citc|Citoh fast vt100:\
X	:co#80:li#23:am:cl=\E[;H\E[2J:bs:cm=\E[%i%2;%2H:nd=\E[C:up=\E[A:\
X	:ce=\E[K:cd=\E[J:so=\E[7m:se=\E[m:us=\E[4m:ue=\E[m:\
X	:is=\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h\E[3g\E[>5g:\
X	:ks=\E[?1h\E=:ke=\E[?1l\E>:ku=\EOA:kd=\EOB:kr=\EOC:kl=\EOD:\
X        :vb=\E[?5h\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\E[?5l:\
X	:dc=\E[P:al=\E[L:im=:ei=:dl=\E[M:ic=\E[@:
X# Note several versions of blit.  I don't know exactly what is what
X# so please send me any corrections to this -- mrh
X# From research!ikeya!rob Tue Aug 31 23:41 EDT 1982
XMY|blit|jerq|blit-pb|blit running teletype rom:\
X	:cr=^M:do=^J:nl=^J:bl=^G:ta=^I:\
X	:IC=\Ef%+ :DC=\Ee%+ :AL=\EF%+ :DL=\EE%+ :\
X	:mi:dl=\EE!:ic=\Ef!:dc=\Ee!:al=\EF!:\
X	:ce=\EK:cl=^L:cm=\EY%r%+ %+ :co#87:li#72:nd=\EC:\
X	:up=\EA:ku=\EA:kd=\EB:kr=\EC:kl=\ED:kb=^H:am:ul:pt:eo:
XMZ|cbblit|columbus enhanced tty blit:\
X	:vb=\E^G:so=\EU!:se=\EV!:us=\EU":ue=\EV":cd=\EJ:\
X	:im=\EQ:ei=\ER:ic@:co#88:sf=\EG:tc=blit:
XMa|oblit|ojerq|first version of blit rom:\
X	:cr=^M:do=^J:nl=^J:bl=^G:\
X	:AL=\Ef%+ :DL=\Ee%+ :mi:dl=\EE:ei=\ER:im=\EQ:dc=\EO:da:db:\
X	:al=\EF:cd=\EJ:ce=\EK:cl=^L:cm=\EY%r%+ %+ :co#88:li#72:nd=\EC:\
X	:up=\EA:vb=\E^G:am:ul:pt:eo:
XMb|daleblit|daleterm|blit running Dale DeJager's ROM:\
X	:ku=\EA:kd=\EB:kr=\EC:kl=\ED:so=\EU!:se=\EV!:us=\EU":ue=\EV":\
X	:da@:db@:tc=oblit:
XMc|datapoint|dp3|dp3360|datapoint 3360:\
X	:cr=^M:do=^J:nl=^J:bl=^G:\
X	:am:le=^H:bs:cd=^_:ce=^^:cl=^]^_:co#82:ho=^]:li#25:nd=^x:up=^z:
X#
X# d: DEC (DIGITAL EQUIPMENT CORPORATION)
X#
X# Note that xn glitch in vt100 is not quite the same as concept, since
X# the cursor is left in a different position while in the weird state
X# (concept at beginning of next line, vt100 at end of this line) so
X# all versions of vi before 3.7 don't handle xn right on vt100.
X# I assume you have smooth scroll off or are at a slow enough baud
X# rate that it doesn't matter (1200? or less).  Also this assumes
X# that you set auto-nl to "on", if you set it off use vt100-nam below.
X#
X# Since there are two things here called vt100, the installer can make
X# a local decision to make either one standard "vt100" by including
X# it in the list of terminals in reorder, since the first vt100 in
X# /etc/termcap is the one that it will find.  The choice is between
X# nam (no automatic margins) and am (automatic margins), as determined
X# by the wrapline switch (group 3 #2).  I presonally recommend turning
X# on the bit and using vt100-am, since having stuff hammer on the right
X# margin is sort of hard to read.  However, the xn glitch does not occur
X# if you turn the bit off.
X#
X# I am unsure about the padding requirements listed here.  I have heard
X# a claim that the vt100 needs no padding.  It's possible that it needs
X# padding only if the xon/xoff switch is off.  For UNIX, this switch
X# should probably be on.
X#
X# The vt100 uses rs and rf rather than is/ct/st because the tab settings
X# are in non-volatile memory and don't need to be reset upon login.
X# You can type "reset" to get them set.
Xdp|vt100-np|vt100 with no padding (for psl games):\
X	:cl=\E[H\E[2J:sr=\EM:cm=\E[%i%d;%dH:nd=\E[C:up=\E[A:\
X	:ce=\E[K:cd=\E[J:so=\E[7m:se=\E[m:us=\E[4m:ue=\E[m:\
X	:md=\E[1m:mr=\E[7m:mb=\E[5m:me=\E[m:tc=vt100:
Xd0|vt100|vt100-am|dec vt100:\
X	:cr=^M:do=^J:nl=^J:bl=^G:co#80:li#24:cl=50\E[;H\E[2J:\
X	:le=^H:bs:am:cm=5\E[%i%d;%dH:nd=2\E[C:up=2\E[A:\
X	:ce=3\E[K:cd=50\E[J:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:\
X	:md=2\E[1m:mr=2\E[7m:mb=2\E[5m:me=2\E[m:is=\E[1;24r\E[24;1H:\
X	:rf=/usr/lib/tabset/vt100:\
X	:rs=\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h:ks=\E[?1h\E=:ke=\E[?1l\E>:\
X	:ku=\EOA:kd=\EOB:kr=\EOC:kl=\EOD:kb=^H:\
X	:ho=\E[H:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:ta=^I:pt:sr=5\EM:vt#3:xn:\
X	:sc=\E7:rc=\E8:cs=\E[%i%d;%dr:
Xd1|vt100-nam|vt100 w/no am:\
X	:am@:xn@:tc=vt100-am:
Xd2|gt42|dec gt42:\
X	:cr=^M:do=^J:bl=^G:\
X	:le=^H:bs:co#72:ns:li#40:os:
Xd3|vt132|vt132:\
X	:al=99\E[L:dl=99\E[M:ip=7:dc=7\E[P:ei=\E[4l:im=\E[4h:xn:dN#30:tc=vt100:
Xd4|gt40|dec gt40:\
X	:cr=^M:do=^J:bl=^G:\
X	:le=^H:bs:co#72:ns:li#30:os:
Xd5|vt50|dec vt50:\
X	:cr=^M:do=^J:nl=^J:bl=^G:\
X	:le=^H:bs:cd=\EJ:ce=\EK:cl=\EH\EJ:co#80:li#12:nd=\EC:ta=^I:pt:up=\EA:
Xd6|vt125|vt125-am|DEC vt125:\
X	:xn:cr=^M:do=^J:nl=^J:bl=^G:co#80:li#24:cl=50\E[H\E[2J:\
X	:le=^H:am:bs:cm=5\E[%i%d;%dH:nd=2\E[C:up=2\E[A:ce=3\E[K:cd=50\E[J:\
X	:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:md=2\E[1m:mr=2\E[7m:mb=2\E[5m:\
X	:me=2\E[m:is=\E[1;24r\E[24;1H\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h:\
X	:ks=\E[?1h\E=:ke=\E[?1l\E>:if=/usr/lib/tabset/vt100:ku=\EOA:kd=\EOB:\
X	:kr=\EOC:kl=\EOD:kb=^H:ho=\E[H:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:ta=^I:\
X	:pt:sr=5\EM:vt#3:sc=\E7:rc=\E8:cs=\E[%i%d;%dr:
X# DEC gigi color graphic terminal , same as vt52
Xd7|gigi|dec gigi terminal:\
X	:co#80:is=200\E>\E[?4l\E[?5l\E[?7h\E[?8h:\
X	:li#24:cl=100\E[;H\E[2J:bs:cm=50\E[%i%2;%2H:nd=200\E[C:up=100\E[A:\
X	:ce=120\E[K:cd=100\E[J:so=20\E[7m:se=20\E[m:us=20\E[4m:ue=20\E[m:\
X	:ks=200\E[?1h\E=:ke=200\E[?1l\E>:\
X	:ku=\EOA:kd=\EOB:kr=\EOC:kl=\EOD:\
X	:kh=\E[H:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:pt:sr=200\EM:\
X	:dC=50:dF=200:dN=50:dT=50:
XdI|dw1|decwriter I:\
X	:cr=^M:do=^J:nl=^J:bl=^G:\
X	:le=^H:bs:co#72:hc:os:
X# From tut@Topaz.CC Thu May 12 14:49:02 1983
X# From tut@topaz.CC Thu Sep 24 22:10:46 1981
Xdf|dw4|decwriter IV:\
X	:cr=^M:do=^J:nl=^J:bl=^G:le=^H:bs:co#132:hc:os:am:\
X	:ta=^I:pt:is=\Ec:k0=\EOP:k1=\EOQ:k2=\EOR:k3=\EOS:kb=^H:
Xdh|vt50h|dec vt50h:\
X	:cr=^M:do=^J:nl=^J:bl=^G:\
X	:le=^H:bs:cd=\EJ:ce=\EK:cl=\EH\EJ:cm=\EY%+ %+ :co#80:li#12:nd=\EC:\
X	:ta=^I:pt:sr=\EI:up=\EA:
Xdi|vt100-s|vt100 with status line at top:\
X	:li#23:i2=\E[2;24r\E[24;1H:\
X	:cm@:ho=\E[H^J:cl=50\E[;H^J\E[2J:\
X	:hs:es:ts=\E7\E[1;%dH\E[1K:fs=\E8:tc=vt100-am:
Xdj|vt100-s-bot|vt100 with status line at bottom:\
X	:li#23:i2=\E[1;23r\E[23;1H:\
X	:hs:es:ts=\E7\E[24;%dH\E[1K:fs=\E8:tc=vt100-am:
Xds|vt100-nav|dec vt100 132 cols 14 lines (w/o advanced video option):\
X	:li#14:tc=vt100-w:
Xdt|vt100-w|dec vt100 132 cols (w/advanced video):\
X	:co#132:li#24:rs=\E>\E[?3h\E[?4l\E[?5l\E[?8h:tc=vt100-am:
Xdv|vt100-w-nam|dec vt100 132 cols (w/advanced video), no am:\
X	:co#132:li#24:rs=\E>\E[?3h\E[?4l\E[?5l\E[?8h:vt@:tc=vt100-nam:
Xdw|vt52|dec vt52:\
X	:cr=^M:do=^J:nl=^J:bl=^G:\
X	:le=^H:bs:cd=\EJ:ce=\EK:cl=\EH\EJ:cm=\EY%+ %+ :co#80:li#24:nd=\EC:\
X	:ta=^I:pt:sr=\EI:up=\EA:ku=\EA:kd=\EB:kr=\EC:kl=\ED:kb=^H:
Xdx|dw2|decwriter II:\
X	:cr=^M:do=^J:nl=^J:bl=^G:\
X	:kb=^h:le=^H:bs:co#132:hc:os:
X# # --------------------------------
X#
X# h: HEWLETT PACKARD
X#
X# Note: no "ho" on HP's since that homes to top of memory, not screen.
X# Due to severe 2621 braindamage, the only way to get the arrow keys to
X# transmit anything at all is to turn on the function key labels
X# (f1-f8) with ks, and even then the poor user has to hold down shift!
X# The default 2621 turns off the labels except when it has to to enable
X# the function keys.  If your installation prefers labels on all the time,
X# or off all the time (at the "expense" of the function keys) move the
X# 2621-nl or 2621-wl labels to the front using reorder.
X# Note: there are newer ROM's for 2621's that allow you to set strap A
X# so the regular arrow keys xmit \EA, etc, as with the 2645.  However,
X# even with this strap set, the terminal stops xmitting if you reset it,
X# until you unset and reset the strap!  Since there is no way to set/unset
X# the strap with an escape sequence, we don't use it in the default.
X# If you like, you can use 2621-ba (braindamaged arrow keys).
Xh1|2621-ba|2621 w/new rom, strap A set:\
X	:ks@:ke@:ku=\EA:kd=\EB:kl=\ED:kr=\EC:kh=\Eh:tc=hp2621:
X# 2621 with function labels.  Most of the time they are off,
X# but inside vi, the function key labels appear.  You have to
X# hold down shift to get them to xmit.
X# 2621k45: untested
X# 2622: unsure if this is quite it, have only heard about the terminal.
Xh3|2621k45|hp2621k45|k45|2622|hp2622|hp 2621 with 45 keyboard:\
X	:kb=^H:ku=\EA:kd=\EB:kl=\ED:kr=\EC:kh=\Eh:ks=\E&s1A:ke=\E&s0A:tc=2621:
X# This entry does not use any of the fancy windowing stuff of the 2621.
X# Indeed, termcap does not yet handle such stuff.  We are looking at it.
Xh6|hp2626|hp2626a|hp2626p|2626|2626a|2626p|hp 2626:\
X	:dc=2\EP:ip=2:se=\E&d@:so=\E&dB:cd=500\EJ:\
X	:mr=\E&dB:us=\E&dD:mb=\E&dA:mk=\E&dS:me=\E&d@:ue=\E&d@:\
X	:kh=\Eh:ku=\EA:kl=\ED:kr=\EC:kd=\EB:ks=\E&s1A:ke=\E&s0A:\
X	:sf=\ES:ta=2^I:xs:tc=2621:
X# cD is a pain - but it only screws up at 9600 baud.
X# You should use this terminal at 4800 baud or less.
Xh8|hp2648|hp2648a|2648a|2648|HP 2648a graphics terminal:\
X	:cl=50\EH\EJ:cm=20\E&a%r%dc%dY:dc=7\EP:ip=5:tc=2645:
X# This terminal should be used at 4800 baud or less.
Xh9|hp2645-np|2645 w/no padding:cm=\E&a%r%dc%dY:tc=hp2645:
X# 2640a doesn't have the Y cursor addressing feature, and C is memory relative
X# instead of screen relative, as we need.
X# 2621 using all 48 lines of memory, only 24 visible at any time.  Untested.
Xhl|2621-48|48 line 2621:\
X	:li#48:ho=\EH:cm=\E&a%r%dc%dR:tc=2621:
X# 2621 with no labels ever.  Also prevents vi delays on escape.
X# Needed for UCB ARPAVAX console, since lsi-11 expands tabs (wrong).
Xht|hp2621-nt|2621nt|2621-nt|hp2621nt|hp 2621 w/no tabs:\
X	:pt@:tc=hp2621:
X# 2621 with labels on all the time - normal outside vi, function inside vi.
X# # --------------------------------
X#
X# l: LEAR SIEGLER (ADM)
X#
X# If the adm31 gives you trouble with standout mode, check the DIP switch
X# in position 6, bank @c11, 25% from back end of pc.  Should be OFF.
X# If there is no such switch, you have an old adm31 and must use oadm31
Xl1|adm31|31|lsi adm31:\
X	:is=\Eu\E0:cr=^M:do=^J:nl=^J:bl=^G:\
X	:al=\EE:am:le=^H:bs:ce=\ET:cm=\E=%+ %+ :cl=\E*:cd=\EY:\
X	:co#80:dc=\EW:dl=\ER:ei=\Er:ho=^^:im=\Eq:\
X	:k0=^A0\r:k1=^A1\r:k2=^A2\r:k3=^A3\r:k4=^A4\r:\
X	:k5=^A5\r:k6=^A6\r:k7=^A7\r:k8=^A8\r:k9=^A9\r:kd=^J:kl=^H:kr=^L:ku=^K:\
X	:li#24:ma=j^Jk^P^K^Pl ^R^L^L :mi:nd=^L:\
X	:se=\EG0:so=\EG1:up=^K:us=\EG1:ue=\EG0:
Xl2|adm2|lsi adm2:\
X	:cr=^M:do=^J:nl=^J:bl=^G:al=\EE:am:le=^H:bs:cd=\EY:ce=\ET:cl=\E;:\
X	:cm=\E=%+ %+ :co#80:dc=\EW:dl=\ER:\
X	:ei=:ho=^^:ic=\EQ:im=:kd=^J:kh=^^:kl=^H:kr=^L:ku=^K:li#24:nd=^L:up=^K:
Xl3|adm3|3|lsi adm3:\
X	:cr=^M:do=^J:nl=^J:bl=^G:\
X	:am:le=^H:bs:cl=^Z:li#24:ma=^K^P:co#80:
Xl4|adm42|42|lsi adm42:\
X	:vs=\EC\E3 \E3(:\
X	:cr=^M:do=^J:nl=^J:bl=^G:\
X	:al=270\EE:am:le=^H:bs:cd=\EY:ce=\ET:cl=\E;:cm=\E=%+ %+ :co#80:\
X	:dc=\EW:dl=\ER:ei=\Er:im=\Eq:ip=6*:li#24:\
X	:bt=\EI:nd=^L:se=\EG0:so=\EG4:ta=\t:up=^k:\
X	:ma=^K^P:pc=\177:
Xl5|adm5|5|lsi adm5:\
X	:cr=^M:do=^J:nl=^J:bl=^G:\
X	:cd=\EY:ce=\ET:do=^J:kb=^H:kh=^^:\
X	:ma=^Hh^Jj^Kk^Ll^^H:se=\EG:sg#1:so=\EG:tc=adm3aplus:
Xl7|adm20|lear siegler adm20:\
X	:am:li#24:co#80:bs:cl=^Z:cm=\E=%i%r%+^_%+^_:nd=^L:up=^K:ho=^^:ce=\ET:\
X	:cd=\EY:al=\EE:dl=\ER:im=:ei=:ic=\EQ:dm=:ed=:dc=\EW:so=\E):se=\E(:\
X	:bt=\EI:pt:kn#7:k1=^A:k2=^B:k3=^W:k4=^D:k5=^E:k6:^X:k7=^Z:
Xla|adm3a|3a|lsi adm3a:\
X	:am:cr=^M:do=^J:nl=^J:bl=^G:\
X	:le=^H:bs:cm=\E=%+ %+ :cl=1^Z:co#80:ho=^^:li#24:ma=^K^P:nd=^L:up=^K:
Xlb|adm3a+|3a+|adm3aplus:\
X	:kl=^H:kd=^J:ku=^K:kr=^L:tc=adm3a:
Xlc|adm22|22|lsi adm22:\
X	:is=\E%\014\014\014\016\003\000\003\002\003\002\000\000\000\000\000\000\000\000\000\000\000:\
X	:al=\EE:am:bs:bt=\EI:cd=\Ey:ce=\Et:cl=\E+:cm=\000\E=%+ %+ :co#80:\
X	:cr=^M:dc=\EW:dl=\ER:do=^J:em=:ho=^^:ic=\EQ:im=:\
X	:k1=\001@\015:k2=\001A\015:k3=\001B\015:k4=\001C\015:\
X	:k5=\001D\015:k6=\001E\015:k7=\001F\015:kn#7:\
X	:ko=ho:\
X	:l1=F1:l2=F2:l3=F3:l4=F4:l5=F5:l6=F6:l7=F7:\
X	:kb=^H:kd=^J:kh=^^:kl=^H:kr=^L:ku=^K:li#24:\
X	:ma=j^Jk^P^K^Pl ^R^L^L :nd=^L:nl=^J:\
X	:se=\E(:so=\E):ta=\Ei:up=^K:
X# # --------------------------------
X#
X# v: TELEVIDEO
X#
X# There are some tvi's that require incredible amounts of padding and
X# some that don't.  I'm assuming 912 and 920 are the old slow ones,
X# and 912b, 912c, 920b, 920c are the new ones that don't need padding.
Xv1|tvi912|912|920|tvi920|old televideo:\
X	:ct=\E3:st=\E1:cr=^M:do=^J:nl=^J:bl=^G:\
X	:al=33*\EE:le=^H:ce=\ET:cm=\E=%+ %+ :cl=^Z:co#80:dc=\EW:dl=33*\ER:ei=:\
X	:kb=^h:ku=^K:kd=^J:kl=^H:kr=^L:k0=^A@\r:k1=^AA\r:k2=^AB\r:k3=^AC\r:\
X	:bs:am:k4=^AD\r:k5=^AE\r:k6=^AF\r:k7=^AG\r:k8=^AH\r:k9=^AI\r:\
X	:ho=^^:im=:ic=\EQ:li#24:nd=^L:ta=^I:pt:se=\Ek:so=\Ej:up=^K:us=\El:ue=\Em:\
X	:ma=^K^P^L :sg#1:ug#1:
X# the 912 has a <funct> key that's like shift: <funct>8 xmits "^A8\r".
X# The 920 has this plus real function keys that xmit different things.
X# Termcap makes you use the funct key on the 912 but the real keys on the 920.
Xv2|912b|912c|tvi912b|tvi912c|tvi|new televideo 912:\
X	:al=5*\EE:dl=5*\ER:tc=tvi912:
Xv3|920b|920c|tvi920b|tvi920c|new televideo 920:\
X	:k0=^A@\r:k1=^AA\r:k2=^AB\r:k3=^AC\r:k4=^AD\r:k5=^AE\r:\
X	:k6=^AF\r:k7=^AG\r:k8=^AH\r:k9=^AI\r:tc=tvi912b:
X# set to page 1 when entering ex (\E-17 )
X# reset to page 0 when exiting ex (\E-07 )
Xv4|tvi912-2p|tvi920-2p|912-2p|920-2p|tvi-2p|televideo w/2 pages:\
X	:ti=\E-17 :te=\E-07 :tc=tvi912:\
Xv5|tvi950-ap|tvi 950 w/alt pages:\
X	:is=\E\\1:ti=\E-06 :te=\E-16 :tc=tvi950:
Xv6|tvi950-b|bare tvi950 no is:\
X	:is@:tc=tvi950:
Xv7|tvi950-ns|tvi950 w/no standout:\
X	:so@:se@:us@:ue@:tc=tvi950:
Xv8|tvi925|925|televideo model 925:\
X	:hs:xn:am:bs:co#80:li#24:cm=\E=%+ %+ :cl=^Z:cd=\EY:ce=\ET:is=\El\E":\
X	:al=\EE:dl=\ER:im=:ei=:ic=\EQ:dc=\EW:if=/usr/lib/tabset/stdcrt:\
X	:ho=^^:nd=^L:bt=\EI:pt:so=\EG4:se=\EG0:sg#1:us=\EG8:ue=\EG0:ug#1:\
X	:up=^K:do=^V:kb=^H:ku=^K:kd=^V:kl=^H:kr=^L:kh=^^:ma=^V^J^L :\
X	:k1=^A@\r:k2=^AA\r:k3=^AB\r:k4=^AC\r:k5=^AD\r:k6=^AE\r:k7=^AF\r:\
X	:k8=^AG\r:k9=^AH\r:k0=^AI\r:ko=ic,dc,al,dl,cl,ce,cd,bt:\
X	:ts=\Ef:fs=\Eg:
X# entry by Tim Curry 5/21/82 Univ. of Central Fla. duke!ucf-cs!tim
Xv9|925a|tvi925a|TeleVideo Model 925:\
X        :al=\EE:am:bs:bt=\EI:bw:cd=\EY:ce=\ET:cl=^Z:cm=\E=%+ %+ :co#80:dc=\EW:\
X        :dl=\ER:do=^V:ei=:ic=\EQ:if=/usr/lib/tabset/std:im=:kb=^H:kd=^V:\
X        :kh=^^:kl=^H:kn#12:kr=^L:ku=^K:li#24:nd=^L:pt:se=\EG0:sg=#1:so=\EG4:\
X        :ue=\EG0:ug#1:ul:up=^K:us=\EG8:is=\El\
X        :vb=\Eb\200\200\200\200\200\200\200\200\200\200\200\200\200\200\Ed:\
X        :ve=\E.4:vs=\E.2:
X# The following tvi descriptions from B:pjphar and virus!mike
X# is for all 950's.  It sets the following attributes:
X# full duplex (\EDF)		write protect off (\E()
X# conversation mode (\EC)	graphics mode off (\E%)
X# white on black (\Ed)		auto page flip off (\Ew)
X# turn off status line (\Eg)	clear status line (\Ef\r)
X# normal video (\E0)		monitor mode off (\EX or \Eu)
X# edit mode (\Er)		load blank char to space (\Ee\040)
X# line edit mode (\EO)		enable buffer control (^O)
X# protect mode off (\E\047)	duplex edit keys (\El)
X# program unshifted send key to send line all (\E016)
X# program shifted send key to send line unprotected (\E004)
X# set the following to nulls:
X#	field delimiter (\Ex0\200\200)
X#	line delimiter (\Ex1\200\200)
X#	start-protected field delimiter (\Ex2\200\200)
X#	end-protected field delimiter (\Ex3\200\200)
X# set end of text delimiter to carriage return/null (\Ex4\r\200)
X#
Xva|tvi950|950|televideo950:\
X	:ct=\E3:st=\E1:cr=^M:do=^J:nl=^J:bl=^G:\
X	:is=\EDF\EC\Ed\EG0\Eg\Er\EO\E\047\E(\E%\Ew\EX\Ee ^O\
X	\El\E016\E004\Ex0\200\200\Ex1\200\200\Ex2\200\200\
X	\Ex3\200\200\Ex4\r\200\Ef\r:\
X	:al=\EE:am:le=^H:bs:bt=\EI:cd=\Ey:ce=\Et:cl=\E*:cm=\E=%+ %+ :\
X	:co#80:dc=\EW:dl=\ER:do=^V:ei=\Er:ho=^^:im=\Eq:k0=^A0\r:\
X	:k1=^A@\r:k2=^AA\r:k3=^AB\r:k4=^AC\r:k5=^AD\r:k6=^AE\r:\
X	:k7=^AF\r:k8=^AG\r:k9=^AH\r:kb=^H:kd=^V:kh=^^:kl=^H:\
X	:ko=ic\054dc\054al\054dl\054cl\054bt\054ce\054cd:kr=^L:\
X	:ku=^K:li#24:ma=^Vj^Kk^Hh^Ll^^H:mi:ms:nd=^L:ta=^I:pt:se=\EG0:\
X	:sg#1:so=\EG4:sr=\Ej:ue=\EG0:ug#1:up=^K:us=\EG8:\
X	:vb=\Eb\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\Ed:\
X	:xn:hs:ts=\Eg\Ef:fs=\r:ds=\Eg\Ef\r:
X#
X# is for 950 with two pages adds the following:
X#	set 48 line page (\E\\2)
X#	place cursor at page 0, line 24, column 1 (\E-07 )
X#	set local (no send) edit keys (\Ek)
X#
X# two page 950 adds the following:
X#	when entering ex, set 24 line page (\E\\1)
X#	when exiting ex, reset 48 line page (\E\\2)
X#			 place cursor at 0,24,1 (\E-07 )
X#	set duplex (send) edit keys (\El) when entering vi
X#	set local (no send) edit keys (\Ek) when exiting vi
X#
Xvb|tvi950-2p|950-2p|televideo950 w/2 pages:\
X	:is=\EDF\EC\Ed\EG0\Eg\Er\EO\E\047\E(\E%\Ew\EX\Ee ^O\
X	\Ek\E016\E004\Ex0\200\200\Ex1\200\200\Ex2\200\200\
X	\Ex3\200\200\Ex4\r\200\E\\2\E-07 \
X	:te=\E\\2\E-07 :ti=\E\\1\E-07 :ks=\El:ke=\Ek:tc=tvi950:
X#
X# is for 950 with four pages adds the following:
X#	set 96 line page (\E\\3)
X#	place cursor at page 0, line 24, column 1 (\E-07 )
X#
X# four page 950 adds the following:
X#	when entering ex, set 24 line page (\E\\1)
X#	when exiting ex, reset 96 line page (\E\\3)
X#			 place cursor at 0,24,1 (\E-07 )
X#
Xvc|tvi950-4p|950-4p|televideo950 w/4 pages:\
X	:is=\EDF\EC\Ed\EG0\Eg\Er\EO\E\047\E(\E%\Ew\EX\Ee ^O\
X	\Ek\E016\E004\Ex0\200\200\Ex1\200\200\Ex2\200\200\
X	\Ex3\200\200\Ex4\r\200\E\\3\E-07 \
X	:te=\E\\3\E-07 :ti=\E\\1\E-07 :ks=\El:ke=\Ek:tc=tvi950:
X#
X# is for reverse video 950 changes the following:
X#	set reverse video (\Ed)
X#
X# set vb accordingly (\Ed ...nulls... \Eb)
X#
Xvd|tvi950-rv|950-rv|televideo950 rev video:\
X	:is=\EDF\EC\Eb\EG0\Eg\Er\EO\E\047\E(\E%\Ew\EX\Ee ^O\
X	\El\E016\E004\Ex0\200\200\Ex1\200\200\Ex2\200\200\
X	\Ex3\200\200\Ex4\r\200:\
X	:vb=\Ed\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\Eb:\
X	:tc=tvi950:
X#
X# uses the appropriate entries from 950-2p and 950-rv
X#
Xve|tvi950-rv-2p|950-rv-2p|televideo950 rev video w/2 pages:\
X	:is=\EDF\EC\Eb\EG0\Eg\Er\EO\E\047\E(\E%\Ew\EX\Ee ^O\
X	\Ek\E016\E004\Ex0\200\200\Ex1\200\200\Ex2\200\200\
X	\Ex3\200\200\Ex4\r\200\E\\2\E-07 :\
X	:vb=\Ed\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\Eb:\
X	:te=\E\\2\E-07 :ti=\E\\1\E-07 :ks=\El:ke=\Ek:tc=tvi950:
X#
X# uses the appropriate entries from 950-4p and 950-rv
X#
Xvf|tvi950-rv-4p|950-rv-4p|televideo950 rev video w/4 pages:\
X	:is=\EDF\EC\Eb\EG0\Er\EO\E\047\E(\E%\Ew\EX\Ee ^O\
X	\Ek\E016\E004\Ex0\200\200\Ex1\200\200\Ex2\200\200\
X	\Ex3\200\200\Ex4\r\200\E\\3\E-07 :\
X	:vb=\Ed\200\200\200\200\200\200\200\200\200\200\200\200\200\200\200\Eb:\
X	:te=\E\\3\E-07 :ti=\E\\1\E-07 :ks=\El:ke=\Ek:tc=tvi950:
Xve|tvi924|924|televideo model 924:\
X	:am:bs:xn:co#80:li#24:cm=\E=%+ %+ :cl=\E*0:cd=\Ey:ce=\Et:is=\Ek0\E"^O:\
X	:al=\EE:dl=\ER:im=:ei=:ic=\EQ:dc=\EW:if=/usr/lib/tabset/stdcrt:ho=^^:\
X	:nd=^L:bt=\EI:pt:so=\EG4:se=\EG0:us=\EG8:ue=\EG0:up=^K:do=^V:kb=^H:\
X	:ku=^K:kd=^V:kl=^H:kr=^L:kh=^^:ma=^Vj^Kk^Ll^^H^R^L:k1=^A@\r:k2=^AA\r:\
X	:k3=^AB\r:k4=^AC\r:k5=^AD\r:k6=^AE\r:k7=^AF\r:k8=^AG\r:k9=^AH\r:\
X	:k0=^AI\r:ko=ic,dc,al,dl,cl,ce,cd,bt:sr=\Ej:\
X	:hs:fs=^Y\Es1:ts=\Ef:ds=\Es0\Ef^Y:
END_OF_FILE
  if test 22050 -ne `wc -c <'abc/tc/termcap'`; then
    echo shar: \"'abc/tc/termcap'\" unpacked with wrong size!
  fi
  # end of 'abc/tc/termcap'
fi
echo shar: End of archive 6 \(of 25\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0 # Just in case...
