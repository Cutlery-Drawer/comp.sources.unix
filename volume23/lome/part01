Path: j.cc.purdue.edu!mentor.cc.purdue.edu!noose.ecn.purdue.edu!samsung!zaphod.mps.ohio-state.edu!wuarchive!uunet!papaya.bbn.com!rsalz
From: rsalz@bbn.com (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v23i051:  Line oriented macro processor, Part01/09
Message-ID: <3025@litchi.bbn.com>
Date: 29 Nov 90 17:40:45 GMT
Organization: BBN Systems and Technologies, Cambridge MA
Lines: 1928
Approved: rsalz@uunet.UU.NET

Submitted-by: Darren New <new@ee.udel.edu>
Posting-number: Volume 23, Issue 51
Archive-name: lome/part01

This set of sources contains three general purpose line-oriented macro
processors. They currently run on the Commodore Amiga and under
SunOS4.x.  They will probably port with little or no effort to most
machines.

LOME (Line Oriented Macro Expander) is a relatively sophiticated macro
expander. It is designed to be compiled by Comp1 or interpreted by
Interp, and as such is very portable. The syntax and semantics are
described herein.

A second version of LOME, for those with PPL, is available. This
version is written in C but otherwise behaves like the version in SCM.
This version is also somewhat more flexible internally, allowing
expansion of the macro list during execution and so forth.

A LOME program consists of two files. The first file is the macro
definition file. This file defines the translation between lines in
the source file(s) and lines in the output file(s). The source file
contains text which is matched against the macros, with each matching
line being replaced by the body of the macro with certain parameters
begin replaced. Each so-expanded line is then matched again against
the macros until no more matches can be performed, at which point the
lines are output to the output file. Text in the bodies of the macros
can redirect input from and output to various files, allowing multiple
source or output files.

The LOME macro definition file (MDF) consists of a sequence of
arbitrary non-blank lines serving as comments, a single blank line, a
parameter line, and then a sequence of macro definitions. Each macro
definition consists of a header line to be matched against a source
line, followed by a set of lines known as the macro body. Each macro
definition (including the final one) is terminated by a line starting
with two BEOL characters (see below). The overall sequence of macro
definitions is termated by an end-of-file condition. Each macro header
line may be preceeded by any number of empty lines (not even
containing a HEOL). Each macro body contains mixtures of literal text
and specially-flagged escape sequences. The escape sequences can be
classified into one of three groups: parameter operations, which
affect individual parameters matched in the macro header; file
operations, which manipulate files; and control operations, which do
things which would be difficult to specify as macro-expansion
operations.

To install the Portable Programmer's Library, please see the bottom of
the PPL.doc file. Thank you.          -- Darren New

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 9)."
# Contents:  LOME LOME/Comp1.doc LOME/DESCRIPTION LOME/FixMake.Amiga
#   LOME/FixMake.Unix LOME/Interp.c LOME/Interp.h LOME/LOME.inp
#   LOME/LOME2.out LOME/LOME4.c LOME/LOME9.out LOME/MIOtest.inp
#   LOME/MIOtest1.inp LOME/MIOtest2.out LOME/MIOtest3.out
#   LOME/MIOtest8.out LOME/README LOME/Rubin.inp LOME/SCMTestD.out
#   MANIFEST PPL PPL/AExitAmiga.c PPL/AExitUnix.c PPL/BExitAmiga.c
#   PPL/BExitUnix.c PPL/Debug.Amiga PPL/Debug.Unix PPL/FExitAmiga.c
#   PPL/FExitUnix.c PPL/Fault.doc PPL/Fault.h PPL/FaultAmiga.h
#   PPL/FaultUnix.h PPL/FixMake.Amiga PPL/FixMake.Unix
#   PPL/MakeHead.Amiga PPL/MakeHead.Unix PPL/MakeTail PPL/README
#   PPL/ShiftLeft.c PPL/TestHost.c PPL/ld.Amiga PPL/ld.Unix TFS
#   TFS/FixMake.Amiga TFS/FixMake.Unix TFS/MakeTail TFS/README
#   TFS/TestTFS.c TFS/TestTFS1.out
# Wrapped by new@estelle.ee.udel.edu on Tue Aug 14 16:09:53 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'LOME' ; then
    echo shar: Creating directory \"'LOME'\"
    mkdir 'LOME'
fi
if test -f 'LOME/Comp1.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/Comp1.doc'\"
else
echo shar: Extracting \"'LOME/Comp1.doc'\" \(1778 characters\)
sed "s/^X//" >'LOME/Comp1.doc' <<'END_OF_FILE'
X
XComp1 will read a set of macro definitions from stream one and a
Xprogram to be expanded from stream two. It will write the expansion of
Xthe program on stream three and any erroneous lines to both to stream
Xthree and stream four.
X
XBoth streams one and two are read until a blank line is encountered.
XThen a single line is read from stream one containing the characters
Xthat will be considered special. The single line should contain these
Xfive characters in this order: the character to be used as zero, the
Xcharacter to be used as the parameter flag in macro headers, the
Xcharacter to be used as the end-of-line character in macro headers,
Xthe character to be used as the parameter flag in macro bodies, and
Xthe character to be used as the end-of-line character in macro bodies.
X
XThe parameter flags in the macro headers match one character each. The
Xcharacters matched are stored when matched. The character may be
Xinserted into the macro body by putting into the body the body
Xparameter flag followed by the parameter number (1-9) followed by the
Xconversion number (0, 1, or 2). Conversion zero causes the character
Xto be inserted, while conversion one causes the decimal equivalent of
Xthe character to be inserted without leading zeros and conversion two
Xcauses the decimal equivalent of the character to be inserted with
Xleading zeros to fill three characters.
X
XErrors are indicated by writing the program line to both streams three
Xand four, preceeded by a digit representing the error number. Error
Xzero is issued when the line is not matched. Error one is issued when
Xthe parameter number is out of range. Error two is issued when the
Xcharacter after a parameter zero request is not a digit. Error three
Xis issued when the conversion number is not zero, one, or two.
X
X
X
END_OF_FILE
if test 1778 -ne `wc -c <'LOME/Comp1.doc'`; then
    echo shar: \"'LOME/Comp1.doc'\" unpacked with wrong size!
fi
# end of 'LOME/Comp1.doc'
fi
if test -f 'LOME/DESCRIPTION' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/DESCRIPTION'\"
else
echo shar: Extracting \"'LOME/DESCRIPTION'\" \(1638 characters\)
sed "s/^X//" >'LOME/DESCRIPTION' <<'END_OF_FILE'
XThis set of sources contains three general purpose macro processors.
X
XThe first program is LOME, the Line Oriented Macro Assembler. This
Xis based on ideas from the Stage2 processor described in
X
X	author = "William M. Waite",
X	title = "Implementing Software for Non-Numeric Applications",
X	publisher = "Prentice-Hall, Inc.",
X	year = 1973,
X	comment = "isbn = 0-13-45898-5, lib of cong num 72-1768"
X
XHowever, it has been expanded to handle simpler loop construction
Xand more flexible mathematical expression.  Full documentation is
Xprovided in LOME.doc and LOME.cat.
X
XThe second program is Comp1, the lowest level compiler. It is a very
Xsimple macro expander and is roughly equivalent to Waite's program
Xcalled SIMCMP. Also supplied are a set of macros for Comp1 to
Xtranslate SCM (Simple Character Manipulator language) into C.
XSCM is equivalent to Waite's FLUB language.
X
XThe third and final (for now) program is Interp. This program
Xinterprets files of SCM macros without the need to compile them into
Xany other language. This is often faster than Comp1ing into another
Xlanguage and then compiling the result, especially during testing.
X
XThis set of sources contains three programs in the C programming language.
XIt requires PPL (the Portable Programmer's Library) and the TFS (Text File
XSubsystem) to be *easily* portable, although it could be ported to
Xmost any machine with a C compiler without too much trouble. Note that
Xit does not rely on any kind of character-set information and should
Xwork on EBCDIC machines and in Europe with non-USA keymaps; however,
Xeach of these might need minor changes to mapping routines in
XMacroIO.c.
X
X
END_OF_FILE
if test 1638 -ne `wc -c <'LOME/DESCRIPTION'`; then
    echo shar: \"'LOME/DESCRIPTION'\" unpacked with wrong size!
fi
# end of 'LOME/DESCRIPTION'
fi
if test -f 'LOME/FixMake.Amiga' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/FixMake.Amiga'\"
else
echo shar: Extracting \"'LOME/FixMake.Amiga'\" \(115 characters\)
sed "s/^X//" >'LOME/FixMake.Amiga' <<'END_OF_FILE'
Xjoin PPLDIR:PPL/MakeHead.Amiga MakeTail as Makefile.Amiga
Xjoin PPLDIR:PPL/MakeHead.Unix MakeTail as Makefile.Unix
X
END_OF_FILE
if test 115 -ne `wc -c <'LOME/FixMake.Amiga'`; then
    echo shar: \"'LOME/FixMake.Amiga'\" unpacked with wrong size!
fi
# end of 'LOME/FixMake.Amiga'
fi
if test -f 'LOME/FixMake.Unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/FixMake.Unix'\"
else
echo shar: Extracting \"'LOME/FixMake.Unix'\" \(111 characters\)
sed "s/^X//" >'LOME/FixMake.Unix' <<'END_OF_FILE'
Xcat $PPLDIR/PPL/MakeHead.Amiga MakeTail >Makefile.Amiga
Xcat $PPLDIR/PPL/MakeHead.Unix MakeTail >Makefile.Unix
X
END_OF_FILE
if test 111 -ne `wc -c <'LOME/FixMake.Unix'`; then
    echo shar: \"'LOME/FixMake.Unix'\" unpacked with wrong size!
fi
# end of 'LOME/FixMake.Unix'
fi
if test -f 'LOME/Interp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/Interp.c'\"
else
echo shar: Extracting \"'LOME/Interp.c'\" \(548 characters\)
sed "s/^X//" >'LOME/Interp.c' <<'END_OF_FILE'
X/*
X * Interp.c
X * SCM Interpreter data file
X * Copyright 1988 Darren New.
X * All rights reserved.
X */
X
X#include "Interp.h"
X
Xshort param[11];     /* parsed parameters */
X
Xshort startLine;     /* where to start executing */
X
Xunsigned short f['Z'];          /* values of FLG registers */
Xunsigned short v['Z'];          /* values of VAL registers */
X	 short p['Z'];          /* values of PTR registers */
Xshort subr['Z'];                /* line of BEGIN SUBROUTINE */
Xshort labl[100];		/* line of LABEL */
X
Xlong mem[MAXMEM];		/* memory locations */
X
X
END_OF_FILE
if test 548 -ne `wc -c <'LOME/Interp.c'`; then
    echo shar: \"'LOME/Interp.c'\" unpacked with wrong size!
fi
# end of 'LOME/Interp.c'
fi
if test -f 'LOME/Interp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/Interp.h'\"
else
echo shar: Extracting \"'LOME/Interp.h'\" \(1131 characters\)
sed "s/^X//" >'LOME/Interp.h' <<'END_OF_FILE'
X/*
X * Interp.h
X * SCM Interpreter header file
X * Copyright 1988 Darren New.
X * All rights reserved.
X */
X
X
Xextern short zero, HeadParm, HeadEOL;
X
Xextern short param[11];     /* parsed parameters */
X
Xextern short startLine;     /* where to start executing */
X
Xtypedef int func(int);
Xtypedef func * funcpnt;
X
X#define MAXSRC 5000 /* max number of lines in source file */
X#define MAXMEM 5000 /* max number of memory locations */
X
Xextern unsigned short f['Z'];           /* values of FLG registers */
Xextern unsigned short v['Z'];           /* values of VAL registers */
Xextern		short p['Z'];           /* values of PTR registers */
Xextern short subr['Z'];                 /* subroutine starting lines */
Xextern short labl[100]; 		/* labels */
X
Xextern long mem[MAXMEM];		/* memory locations */
X
X/* defined in Ifuncs?.c */
X
Xextern func Ebp, Ibp, Eep, Iep, Ebmr, Ibmr, Eemr, Iemr;
Xextern func Ebs, Ibs, Ees, Ies, El, Il, Ecd, Icd, End, Ind;
Xextern func Es, Ec, Egm, Epm, Ef, Epv, Evp, Eva, Evs, Epa;
Xextern func Eps, Ept, Epd, Empb, Et, Etife, Etifn, Etive, Etivn;
Xextern func Etipe, Etipn, Etipl, Er, Egb, Epb, Evi, Eov, Edebug, Emt;
X
X
X
X
END_OF_FILE
if test 1131 -ne `wc -c <'LOME/Interp.h'`; then
    echo shar: \"'LOME/Interp.h'\" unpacked with wrong size!
fi
# end of 'LOME/Interp.h'
fi
if test -f 'LOME/LOME.inp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/LOME.inp'\"
else
echo shar: Extracting \"'LOME/LOME.inp'\" \(492 characters\)
sed "s/^X//" >'LOME/LOME.inp' <<'END_OF_FILE'
XThis line should come out unchanged.
XTest1.
XTest2.				Test some parameter substitution ops
XTest3.				Test some control ops.
XTest4.				Test input skips
XXX - If this appears, input skips not skipping.
XXX - If this appears, input skips not skipping.
XIf this does not appear, input skips skipping too much.
XTest5.				Decimal Loop constructs
XTest6.				String Loop constructs
XTest7a. 			Test some file ops
XTest7b. 			Test some more file ops
XTestMath.			Test mathematical conversions
XEnd of Tests!.
END_OF_FILE
if test 492 -ne `wc -c <'LOME/LOME.inp'`; then
    echo shar: \"'LOME/LOME.inp'\" unpacked with wrong size!
fi
# end of 'LOME/LOME.inp'
fi
if test -f 'LOME/LOME2.out' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/LOME2.out'\"
else
echo shar: Extracting \"'LOME/LOME2.out'\" \(196 characters\)
sed "s/^X//" >'LOME/LOME2.out' <<'END_OF_FILE'
XFish Fish Fish
XThis line should go onto stream 4 and then be copied to output.
XThis should also go to stream 4 and be copied to output also.
XOnce more this goes to stream 4 and back.
XEND OF INPUT
END_OF_FILE
if test 196 -ne `wc -c <'LOME/LOME2.out'`; then
    echo shar: \"'LOME/LOME2.out'\" unpacked with wrong size!
fi
# end of 'LOME/LOME2.out'
fi
if test -f 'LOME/LOME4.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/LOME4.c'\"
else
echo shar: Extracting \"'LOME/LOME4.c'\" \(1790 characters\)
sed "s/^X//" >'LOME/LOME4.c' <<'END_OF_FILE'
X/*
X * LOME4.c
X * Line Oriented Macro Expander - ExpandLine()
X * Copyright 1989 Darren New
X *
X */
X
X#include "LOME.h"
X
X/* This will build an output line and push it on the stack */
X
Xvoid ExpandLine()
X{
X    bool done;
X
X    assert(0 < tstacksize);
X    assert(0 <= Sretoffs && Sretoffs < macrosize);
X
X    conslinesize = 0;
X    done = FALSE;
X
X    while (! done && ! quitting && skipping == 0 && 0 <= Sretoffs) {
X	switch (macroflag[Sretoffs]) {
X	    case 0: {	/* normal character to insert */
X		consline[conslinesize++] = macrochar[Sretoffs++];
X		break;
X		}
X	    case 1: {	/* substitution */
X		assert(macroflag[Sretoffs+1] == 1);
X		consline[conslinesize] = 0;
X		if (macrochar[Sretoffs] == params[O_CTRLOP]) {
X		    Sretoffs += 1;
X		    DoCtrlOp(macrochar[Sretoffs++] - params[O_ZERO]);
X		    }
X		else if (macrochar[Sretoffs] == params[O_FILEOP]) {
X		    Sretoffs += 1;
X		    DoFileOp(macrochar[Sretoffs++] - params[O_ZERO]);
X		    }
X		else {
X		    int p;
X		    p = macrochar[Sretoffs++] - params[O_ZERO];
X		    assert(0 <= p && p <= 9);
X		    DoSubsOp(p, macrochar[Sretoffs++] - params[O_ZERO]);
X		    }
X		break;
X		}
X	    case 2: {	/* BEOL */
X		consline[conslinesize] = 0;
X		Sretoffs += 1;
X		if (0 < conslinesize || params[O_ZERO] != params[O_FBLANK]) {
X		    tstacksize += 1;
X		    assert(Sinp == NULL && Sp0 == NULL && Sp1 == NULL);
X		    assert(Sp2 == NULL && Sp3 == NULL && Sp4 == NULL);
X		    assert(Sp5 == NULL && Sp6 == NULL && Sp7 == NULL);
X		    assert(Sp8 == NULL && Sp9 == NULL);
X		    Sinp = PLStrDup(consline);
X		    Sretoffs = -1;
X		    done = TRUE;
X		    }
X		break;
X		}
X	    case 3: {	/* end of macro body */
X		consline[conslinesize = 0] = 0;
X		PopTStack();
X		done = TRUE;
X		break;
X		}
X	    default : { /* mistake in program! */
X		bomb("Bad MacroFlag byte!");
X		}
X	    }
X	}
X    }
X
X
END_OF_FILE
if test 1790 -ne `wc -c <'LOME/LOME4.c'`; then
    echo shar: \"'LOME/LOME4.c'\" unpacked with wrong size!
fi
# end of 'LOME/LOME4.c'
fi
if test -f 'LOME/LOME9.out' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/LOME9.out'\"
else
echo shar: Extracting \"'LOME/LOME9.out'\" \(35 characters\)
sed "s/^X//" >'LOME/LOME9.out' <<'END_OF_FILE'
XThis should go only to t:LOME9.out
END_OF_FILE
if test 35 -ne `wc -c <'LOME/LOME9.out'`; then
    echo shar: \"'LOME/LOME9.out'\" unpacked with wrong size!
fi
# end of 'LOME/LOME9.out'
fi
if test -f 'LOME/MIOtest.inp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/MIOtest.inp'\"
else
echo shar: Extracting \"'LOME/MIOtest.inp'\" \(509 characters\)
sed "s/^X//" >'LOME/MIOtest.inp' <<'END_OF_FILE'
X1)  This should appear on stream 2.
X2)  This too should appear on stream 2.
XX)  This should not appear at all.
X3)  If this is not followed by a totally blank line, buffer not clearing.
X4)  Lines 4 - 6 should appear twice.
X5)  If not, rewind may not be working.
X6)  This is the last duplicated line.
X7)  Line 8 should be next and contain all ten digits.
X9)  Line 9 is followed by a maximum-length line of zeros.
X10) The next line should contain only a single zero - test one item lines.
X11) Last line for now.
END_OF_FILE
if test 509 -ne `wc -c <'LOME/MIOtest.inp'`; then
    echo shar: \"'LOME/MIOtest.inp'\" unpacked with wrong size!
fi
# end of 'LOME/MIOtest.inp'
fi
if test -f 'LOME/MIOtest1.inp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/MIOtest1.inp'\"
else
echo shar: Extracting \"'LOME/MIOtest1.inp'\" \(590 characters\)
sed "s/^X//" >'LOME/MIOtest1.inp' <<'END_OF_FILE'
X1)  This should appear on stream 2.
X2)  This too should appear on stream 2.
XX)  This should not appear at all.
X3)  If this is not followed by a totally blank line, buffer not clearing.
X4)  Lines 4 - 6 should appear twice.
X5)  If not, rewind may not be working.
X6)  This is the last duplicated line.
X7)  Line 8 should be next and contain all ten digits.
X9)  Line 9 is followed by a maximum-length line of zeros.
X10) The next line should contain only a single zero - test one item lines.
X11) Last line on stream 2 for now.
X12) This should go to stream 3.
X13) This should go to stream 3 also.
END_OF_FILE
if test 590 -ne `wc -c <'LOME/MIOtest1.inp'`; then
    echo shar: \"'LOME/MIOtest1.inp'\" unpacked with wrong size!
fi
# end of 'LOME/MIOtest1.inp'
fi
if test -f 'LOME/MIOtest2.out' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/MIOtest2.out'\"
else
echo shar: Extracting \"'LOME/MIOtest2.out'\" \(867 characters\)
sed "s/^X//" >'LOME/MIOtest2.out' <<'END_OF_FILE'
X1)  This should appear on stream 2.
X2)  This too should appear on stream 2.
X3)  If this is not followed by a totally blank line, buffer not clearing.
X
X4)  Lines 4 - 6 should appear twice.
X5)  If not, rewind may not be working.
X6)  This is the last duplicated line.
X4)  Lines 4 - 6 should appear twice.
X5)  If not, rewind may not be working.
X6)  This is the last duplicated line.
X7)  Line 8 should be next and contain all ten digits.
X8) 0123456789
X9)  Line 9 is followed by a maximum-length line of zeros.
X000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
X10) The next line should contain only a single zero - test one item lines.
X0
X11) Last line on stream 2 for now.
END_OF_FILE
if test 867 -ne `wc -c <'LOME/MIOtest2.out'`; then
    echo shar: \"'LOME/MIOtest2.out'\" unpacked with wrong size!
fi
# end of 'LOME/MIOtest2.out'
fi
if test -f 'LOME/MIOtest3.out' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/MIOtest3.out'\"
else
echo shar: Extracting \"'LOME/MIOtest3.out'\" \(69 characters\)
sed "s/^X//" >'LOME/MIOtest3.out' <<'END_OF_FILE'
X12) This should go to stream 3.
X13) This should go to stream 3 also.
END_OF_FILE
if test 69 -ne `wc -c <'LOME/MIOtest3.out'`; then
    echo shar: \"'LOME/MIOtest3.out'\" unpacked with wrong size!
fi
# end of 'LOME/MIOtest3.out'
fi
if test -f 'LOME/MIOtest8.out' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/MIOtest8.out'\"
else
echo shar: Extracting \"'LOME/MIOtest8.out'\" \(37 characters\)
sed "s/^X//" >'LOME/MIOtest8.out' <<'END_OF_FILE'
X13) This should go to stream 3 also.
END_OF_FILE
if test 37 -ne `wc -c <'LOME/MIOtest8.out'`; then
    echo shar: \"'LOME/MIOtest8.out'\" unpacked with wrong size!
fi
# end of 'LOME/MIOtest8.out'
fi
if test -f 'LOME/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/README'\"
else
echo shar: Extracting \"'LOME/README'\" \(2156 characters\)
sed "s/^X//" >'LOME/README' <<'END_OF_FILE'
X
XThese programs and all derivative works are copyright 1990 by
XDarren New. All Rights Reserved.
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the names of the copyright holder or author not be
Xused in advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XBOTH THE AUTHOR AND THE COPYRIGHT HOLDER DISCLAIM ALL WARRANTIES WITH
XREGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
XMERCHANTABILITY AND FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDER OR THE
XAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
XDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
XAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
XOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X
XThe author can currently be reached in the USA by phone at
X(302) 451-8013, by electronic mail at "new@udel.edu", or by
Xphysical mail at 151 Thorn Lane #12, Newark, DE 19711.
X
XIf you find this program (or the included libraries) useful, a
Xdonation would be welcome. Questions, comments, improvements, and
Xports are also welcome and will be redistributed with thanks and
Xattribution.
X
X
X----------------------------------------------------------------------
X
X
XPlease note that neither the TFS nor the BFS (nor the UIS or VMS, for
Xthat matter) are actually complete yet. However, they do seem to be
Xsufficiently complete to get LOME, Comp1, and Interp working. I
Xrelease them only for the compilation of the files in the LOME
Xdistribution.
X
XExpect a new distribution of the lower-level routines along with new
Xprograms in the not-so-near future. One such program is a state-based
Xmacro expander with the capability of outputting binary (via bypassing
Xof MacroIO).
X
XTo install the Portable Programmer's Library, please see the bottom of
Xthe PPL.doc file. Thank you.          -- Darren New
X
X
X
END_OF_FILE
if test 2156 -ne `wc -c <'LOME/README'`; then
    echo shar: \"'LOME/README'\" unpacked with wrong size!
fi
# end of 'LOME/README'
fi
if test -f 'LOME/Rubin.inp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/Rubin.inp'\"
else
echo shar: Extracting \"'LOME/Rubin.inp'\" \(1184 characters\)
sed "s/^X//" >'LOME/Rubin.inp' <<'END_OF_FILE'
XFILE: Rubin&.inp
XThis is a test file for Rubin.mac.
XIt really doesn't do anything except test a few options.
XThis is by no means an exhaustive test.
X
XThis should come out unchanged
Xbecause it does not start with an asterisk.
X
XTest simple cases:
X* gamma = alpha + beta
X* gamma = alpha - beta
X* gamma = alpha * beta
X* gamma = alpha / beta
X
XTest simple cases with modifiers:
X* gamma = alpha +x beta
X* gamma = alpha -h beta
X* gamma = alpha *f beta
X* gamma = alpha /u beta
X
XTest negations
X* gamma = -alpha + beta
X
XTest absolute values
X* gamma = |alpha - beta
X* gamma = |alpha - |beta
X* gamma = alpha - |beta
X* gamma = -|alpha - |beta
X
XTest a w field
X* gamma = alpha + beta /\omega
X* gamma = alpha + beta /\~omega
X
XTry the type casts
X* gamma =(half) alpha + beta
X* gamma =(full) alpha + beta
X* gamma = (scalar)alpha + beta
X* gamma = alpha + (scalar)beta
X* gamma = (scalar)alpha + (scalar)beta
X* gamma =(half) (scalar)alpha + (scalar)beta
X
XTry x, y, and z
X* gamma'gift = alpha + beta
X* gamma = alpha'apple + beta
X* gamma = alpha + beta'book
X* gamma'gift = alpha'apple + beta'book
X
XTry a line with everything on it
X* gamma'gift =(half) -|(scalar)alpha'apple *big |(scalar)beta'book /\~omega
X
END_OF_FILE
if test 1184 -ne `wc -c <'LOME/Rubin.inp'`; then
    echo shar: \"'LOME/Rubin.inp'\" unpacked with wrong size!
fi
# end of 'LOME/Rubin.inp'
fi
if test -f 'LOME/SCMTestD.out' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/SCMTestD.out'\"
else
echo shar: Extracting \"'LOME/SCMTestD.out'\" \(531 characters\)
sed "s/^X//" >'LOME/SCMTestD.out' <<'END_OF_FILE'
X1. IF SCM MACROS ARE CORRECT, OUTPUT CONTAINS NO LINES STARTING WITH X
X2. Lines starting with X indicate errors in macros or I/O.
X3. First three lines rely on VAL B = 1 + 0, VAL W = 2 + 0, GET BUFF B, PUT BUFF W.
X4. If this works, CALL F seems to work.
X5. Next line contains "6. GOOD" - anything else is wrong
X6. GOOD
X7. Next line contains "8. 0 1 2 3 4 5 6 7 8 9" from VAL fields
X8. 0 1 2 3 4 5 6 7 8 9
X9. Next line contains "10. 0 1 2 3" from PTR fields
X10. 0 1 2 3
X99. This should be printed as the last line. - END OF TEST ONE
END_OF_FILE
if test 531 -ne `wc -c <'LOME/SCMTestD.out'`; then
    echo shar: \"'LOME/SCMTestD.out'\" unpacked with wrong size!
fi
# end of 'LOME/SCMTestD.out'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(3223 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X LOME                       1	The Line Oriented Macro Expanders
X LOME/Comp1.c               5	
X LOME/Comp1.doc             1	
X LOME/DESCRIPTION           1	This is the DESCRIPTION you want to read 1st
X LOME/FixMake.Amiga         1	
X LOME/FixMake.Unix          1	
X LOME/Ifuncs1.c             2	
X LOME/Ifuncs2.c             2	
X LOME/Ifuncs3.c             2	
X LOME/Ifuncs4.c             2	
X LOME/Interp.c              1	
X LOME/Interp.h              1	
X LOME/Iparse.c              3	
X LOME/LOME.c                2	
X LOME/LOME.doc              9	
X LOME/LOME.h                4	
X LOME/LOME.inp              1	
X LOME/LOME.mac              4	
X LOME/LOME.scm              6	
X LOME/LOME0.c               3	
X LOME/LOME1.c               3	
X LOME/LOME1.out             4	
X LOME/LOME2.c               2	
X LOME/LOME2.out             1	
X LOME/LOME3.c               3	
X LOME/LOME4.c               1	
X LOME/LOME5.c               4	
X LOME/LOME6.c               3	
X LOME/LOME7.c               2	
X LOME/LOME8.c               5	
X LOME/LOME9.out             1	
X LOME/MIOtest.c             3	
X LOME/MIOtest.inp           1	
X LOME/MIOtest1.inp          1	
X LOME/MIOtest2.out          1	
X LOME/MIOtest3.out          1	
X LOME/MIOtest8.out          1	
X LOME/MacroIO.c             2	
X LOME/MacroIO.doc           3	
X LOME/MacroIO.h             3	
X LOME/MakeTail              2	
X LOME/README                1	
X LOME/Rubin.inp             1	
X LOME/Rubin.mac             5	
X LOME/Rubin.out             2	
X LOME/SCM.doc               7	
X LOME/SCM.mac               3	
X LOME/SCMTestC.out          7	
X LOME/SCMTestD.inp          2	
X LOME/SCMTestD.out          1	
X LOME/SCMTestP.scm          6	
X LOME/SCMdebug.mac          4	
X MANIFEST                   1	This shipping list
X PPL                        1	The Programmer's Portable Library
X PPL/AExitAmiga.c           1	
X PPL/AExitUnix.c            1	
X PPL/BExitAmiga.c           1	
X PPL/BExitUnix.c            1	
X PPL/Debug.Amiga            1	
X PPL/Debug.Unix             1	
X PPL/FExitAmiga.c           1	
X PPL/FExitUnix.c            1	
X PPL/Fault.doc              1	
X PPL/Fault.h                1	
X PPL/FaultAmiga.c           2	
X PPL/FaultAmiga.h           1	
X PPL/FaultUnix.c            2	
X PPL/FaultUnix.h            1	
X PPL/FixMake.Amiga          1	
X PPL/FixMake.Unix           1	
X PPL/MakeHead.Amiga         1	
X PPL/MakeHead.Unix          1	
X PPL/MakeTail               1	
X PPL/PPL.doc                6	
X PPL/PPLAmiga.c             5	
X PPL/PPLAmiga.h             7	
X PPL/PPLUnix.c              4	
X PPL/PPLUnix.h              8	
X PPL/README                 1	
X PPL/ShiftLeft.c            1	
X PPL/TestHost.c             1	
X PPL/ld.Amiga               1	
X PPL/ld.Unix                1	
X TFS                        1	The Text File Subsystem
X TFS/FixMake.Amiga          1	
X TFS/FixMake.Unix           1	
X TFS/MakeTail               1	
X TFS/README                 1	
X TFS/TFS.doc                2	
X TFS/TFS.h                  4	
X TFS/TFSAmiga.c             5	
X TFS/TFSUnix.c              6	
X TFS/TestTFS.c              1	
X TFS/TestTFS.inp            2	
X TFS/TestTFS1.out           1	
X TFS/TestTFS2.out           2	
END_OF_FILE
if test 3223 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test ! -d 'PPL' ; then
    echo shar: Creating directory \"'PPL'\"
    mkdir 'PPL'
fi
if test -f 'PPL/AExitAmiga.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/AExitAmiga.c'\"
else
echo shar: Extracting \"'PPL/AExitAmiga.c'\" \(177 characters\)
sed "s/^X//" >'PPL/AExitAmiga.c' <<'END_OF_FILE'
X/*
X	AExit.c
X	This is the default AssertExit functions for AssertBomb.
X*/
X
X#include <proto/dos.h>
X
Xint AssertExit(void);
Xint AssertExit()
X{
X    Exit(200);
X    return 0;
X    }
X
X
X
END_OF_FILE
if test 177 -ne `wc -c <'PPL/AExitAmiga.c'`; then
    echo shar: \"'PPL/AExitAmiga.c'\" unpacked with wrong size!
fi
# end of 'PPL/AExitAmiga.c'
fi
if test -f 'PPL/AExitUnix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/AExitUnix.c'\"
else
echo shar: Extracting \"'PPL/AExitUnix.c'\" \(222 characters\)
sed "s/^X//" >'PPL/AExitUnix.c' <<'END_OF_FILE'
X/*
X	AExit$(MACHINE).c
X	This is the default AssertExit functions for AssertBomb.
X*/
X
X#include "PPL.h"
X
Xint AssertExit ARGS((void));
Xint AssertExit()
X{
X    extern void abort ARGS((void));
X    abort();
X    return 0;
X    }
X
X
X
END_OF_FILE
if test 222 -ne `wc -c <'PPL/AExitUnix.c'`; then
    echo shar: \"'PPL/AExitUnix.c'\" unpacked with wrong size!
fi
# end of 'PPL/AExitUnix.c'
fi
if test -f 'PPL/BExitAmiga.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/BExitAmiga.c'\"
else
echo shar: Extracting \"'PPL/BExitAmiga.c'\" \(171 characters\)
sed "s/^X//" >'PPL/BExitAmiga.c' <<'END_OF_FILE'
X/*
X	BExit.c
X	This is the default BombExit functions for AssertBomb.
X*/
X
X#include <proto/dos.h>
X
Xint BombExit(void);
Xint BombExit()
X{
X    Exit(200);
X    return 0;
X    }
X
X
X
END_OF_FILE
if test 171 -ne `wc -c <'PPL/BExitAmiga.c'`; then
    echo shar: \"'PPL/BExitAmiga.c'\" unpacked with wrong size!
fi
# end of 'PPL/BExitAmiga.c'
fi
if test -f 'PPL/BExitUnix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/BExitUnix.c'\"
else
echo shar: Extracting \"'PPL/BExitUnix.c'\" \(216 characters\)
sed "s/^X//" >'PPL/BExitUnix.c' <<'END_OF_FILE'
X/*
X	BExit$(MACHINE).c
X	This is the default BombExit functions for AssertBomb.
X*/
X
X#include "PPL.h"
X
Xint BombExit ARGS((void));
Xint BombExit()
X{
X    extern void abort ARGS((void));
X    abort();
X    return 0;
X    }
X
X
X
END_OF_FILE
if test 216 -ne `wc -c <'PPL/BExitUnix.c'`; then
    echo shar: \"'PPL/BExitUnix.c'\" unpacked with wrong size!
fi
# end of 'PPL/BExitUnix.c'
fi
if test -f 'PPL/Debug.Amiga' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/Debug.Amiga'\"
else
echo shar: Extracting \"'PPL/Debug.Amiga'\" \(71 characters\)
sed "s/^X//" >'PPL/Debug.Amiga' <<'END_OF_FILE'
X/* startup-sequence for codeprobe */
X/* set echo on */
Xset autoswap on
END_OF_FILE
if test 71 -ne `wc -c <'PPL/Debug.Amiga'`; then
    echo shar: \"'PPL/Debug.Amiga'\" unpacked with wrong size!
fi
# end of 'PPL/Debug.Amiga'
fi
if test -f 'PPL/Debug.Unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/Debug.Unix'\"
else
echo shar: Extracting \"'PPL/Debug.Unix'\" \(56 characters\)
sed "s/^X//" >'PPL/Debug.Unix' <<'END_OF_FILE'
Xdir ../PPL
Xdir ../TFS
Xdir ../BFS
Xdir ../VMS
Xdir ../LOME
END_OF_FILE
if test 56 -ne `wc -c <'PPL/Debug.Unix'`; then
    echo shar: \"'PPL/Debug.Unix'\" unpacked with wrong size!
fi
# end of 'PPL/Debug.Unix'
fi
if test -f 'PPL/FExitAmiga.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/FExitAmiga.c'\"
else
echo shar: Extracting \"'PPL/FExitAmiga.c'\" \(174 characters\)
sed "s/^X//" >'PPL/FExitAmiga.c' <<'END_OF_FILE'
X/*
X	FExit.c
X	This is the default FaultExit functions for AssertBomb.
X*/
X
X#include <proto/dos.h>
X
Xint FaultExit(void);
Xint FaultExit()
X{
X    Exit(200);
X    return 0;
X    }
X
X
X
END_OF_FILE
if test 174 -ne `wc -c <'PPL/FExitAmiga.c'`; then
    echo shar: \"'PPL/FExitAmiga.c'\" unpacked with wrong size!
fi
# end of 'PPL/FExitAmiga.c'
fi
if test -f 'PPL/FExitUnix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/FExitUnix.c'\"
else
echo shar: Extracting \"'PPL/FExitUnix.c'\" \(219 characters\)
sed "s/^X//" >'PPL/FExitUnix.c' <<'END_OF_FILE'
X/*
X	FExit$(MACHINE).c
X	This is the default FaultExit functions for AssertBomb.
X*/
X
X#include "PPL.h"
X
Xint FaultExit ARGS((void));
Xint FaultExit()
X{
X    extern void abort ARGS((void));
X    abort();
X    return 0;
X    }
X
X
X
END_OF_FILE
if test 219 -ne `wc -c <'PPL/FExitUnix.c'`; then
    echo shar: \"'PPL/FExitUnix.c'\" unpacked with wrong size!
fi
# end of 'PPL/FExitUnix.c'
fi
if test -f 'PPL/Fault.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/Fault.doc'\"
else
echo shar: Extracting \"'PPL/Fault.doc'\" \(1602 characters\)
sed "s/^X//" >'PPL/Fault.doc' <<'END_OF_FILE'
XFault Handler routines and documentation
XCopyright 1986, 1990 Darren New.
X
XA function and three macros are defined:
X	AssertBomb(char * s, char * f, int l, int i, int (*exitfunc)() );
X		Builds an alert with the string S as the first line,
X		F (for file name) followed by L (line number) as
X		the second line, possibly as modified by I being 1 or 2.
X		Also displays "left mouse to retry, right mouse to abort."
X		returns the result of DisplayAlert().
X		If I is 1, "Assert:" is prepended to S.
X		If I is 2, "Fault:" is prepended to S.
X		If I is 3, "Bomb:" is prepended to S.
X		If (I & 0x80) then pressing the right mouse will
X		call exitfunc with no parameters.
X		Otherwise, the result of DisplayAlert is returned.
X	fault(s)
X		calls AssertBomb(s,__FILE__,__LINE__,2, FaultExit);
X	bomb(s)
X		calls AssertBomb(s,__FILE__,__LINE__,0x83, BombExit);
X	assert(exp)
X		If EXP is false, calls AssertBomb with the text of
X		EXP as S, I as 1, and EXITFUNC as AssertExit.
X		Thus, this may return without visible effect.
X		You may have problems if you put quotes or '\0' in
X		the expression exp, as it winds up between quotes (at
X		least in Lattice it does).
X		If USE_ASSERT is 0, this is macroed out of the program.
X		If USE_ASSERT is 1, this stays in the program.
X		If USE_ASSERT is undefined when <Fault.h> is included,
X			USE_ASSERT will be 1 is DEBUG is defined or
X			USE_ASSERT will be 0 if DEBUG is undefined.
X
X    If the user does not include definitions for FaultExit, BombExit, and
X    AssertExit in the program, the ones from the library will be pulled
X    in, which do no cleanup and simply call Exit(200).
X
END_OF_FILE
if test 1602 -ne `wc -c <'PPL/Fault.doc'`; then
    echo shar: \"'PPL/Fault.doc'\" unpacked with wrong size!
fi
# end of 'PPL/Fault.doc'
fi
if test -f 'PPL/Fault.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/Fault.h'\"
else
echo shar: Extracting \"'PPL/Fault.h'\" \(1197 characters\)
sed "s/^X//" >'PPL/Fault.h' <<'END_OF_FILE'
X/*
X	FaultUnix.h
X	This will handle various faulting situations.
X	assert and fault and bomb are included here.
X
X	Copyright 1987 Darren New.
X
X*/
X
X#ifndef FAULT_H
X#define FAULT_H 1
X
X#ifndef USE_ASSERT
X#ifdef DEBUG
X#define USE_ASSERT 1
X#else
X#define USE_ASSERT 0
X#endif /* debug */
X#endif /* use_assert */
X
Xextern int FaultExit(void), BombExit(void), AssertExit(void);
Xextern int AssertBomb(char *,char *,int,int,int (*)(void));
Xextern int AssertBombDB(char *,char *,int,int,int (*)(void));
X
X#if USE_DBUGLIB==1
X
X#define fault(s) AssertBombDB(s,__FILE__,__LINE__,2,FaultExit)
X#define bomb(s) AssertBombDB(s,__FILE__,__LINE__,0x83,BombExit)
X
X#else
X
X#define fault(s) AssertBomb(s,__FILE__,__LINE__,2,FaultExit)
X#define bomb(s) AssertBomb(s,__FILE__,__LINE__,0x83,BombExit)
X
X#endif /* use_dbuglib */
X
X#if USE_ASSERT==1
X#if USE_DBUGLIB==1
X
X#define assert(exp) {if(!(exp)){\
XDEBUGF(1,"Assert failed:\"%s\",%s,%d" C #exp C __FILE__ C __LINE__);\
X(void)AssertBomb(#exp,__FILE__,__LINE__,0x81,AssertExit);}}
X
X#else
X
X#define assert(exp) {if(!(exp))(void)AssertBomb(#exp,__FILE__,__LINE__,0x81,AssertExit);}
X
X#endif /* use_dbuglib */
X
X#else
X
X#define assert(exp) {}
X
X#endif /* use_assert */
X
X#endif	/* FAULT_H */
X
END_OF_FILE
if test 1197 -ne `wc -c <'PPL/Fault.h'`; then
    echo shar: \"'PPL/Fault.h'\" unpacked with wrong size!
fi
# end of 'PPL/Fault.h'
fi
if test -f 'PPL/FaultAmiga.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/FaultAmiga.h'\"
else
echo shar: Extracting \"'PPL/FaultAmiga.h'\" \(1190 characters\)
sed "s/^X//" >'PPL/FaultAmiga.h' <<'END_OF_FILE'
X/*
X	FaultAmiga.h
X	This will handle various faulting situations.
X	assert and fault and bomb are included here.
X
X	Copyright 1987 Darren New.
X
X*/
X
X#ifndef FAULT_H
X#define FAULT_H 1
X
X#ifndef USE_ASSERT
X#ifdef DEBUG
X#define USE_ASSERT 1
X#else
X#define USE_ASSERT 0
X#endif /* debug */
X#endif /* use_assert */
X
Xextern int FaultExit(void), BombExit(void), AssertExit(void);
Xextern int AssertBomb(char *,char *,int,int,int (*)());
Xextern int AssertBombDB(char *,char *,int,int,int (*)());
X
X#if USE_DBUGLIB==1
X
X#define fault(s) AssertBombDB(s,__FILE__,__LINE__,2,FaultExit)
X#define bomb(s) AssertBombDB(s,__FILE__,__LINE__,0x83,BombExit)
X
X#else
X
X#define fault(s) AssertBomb(s,__FILE__,__LINE__,2,FaultExit)
X#define bomb(s) AssertBomb(s,__FILE__,__LINE__,0x83,BombExit)
X
X#endif /* use_dbuglib */
X
X#if USE_ASSERT==1
X#if USE_DBUGLIB==1
X
X#define assert(exp) {if(!(exp)){\
XDEBUGF(1,"Assert failed:\"%s\",%s,%d" C #exp C __FILE__ C __LINE__);\
X(void)AssertBomb(#exp,__FILE__,__LINE__,0x81,AssertExit);}}
X
X#else
X
X#define assert(exp) {if(!(exp))(void)AssertBomb(#exp,__FILE__,__LINE__,0x81,AssertExit);}
X
X#endif /* use_dbuglib */
X
X#else
X
X#define assert(exp) {}
X
X#endif /* use_assert */
X
X#endif	/* FAULT_H */
X
END_OF_FILE
if test 1190 -ne `wc -c <'PPL/FaultAmiga.h'`; then
    echo shar: \"'PPL/FaultAmiga.h'\" unpacked with wrong size!
fi
# end of 'PPL/FaultAmiga.h'
fi
if test -f 'PPL/FaultUnix.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/FaultUnix.h'\"
else
echo shar: Extracting \"'PPL/FaultUnix.h'\" \(1197 characters\)
sed "s/^X//" >'PPL/FaultUnix.h' <<'END_OF_FILE'
X/*
X	FaultUnix.h
X	This will handle various faulting situations.
X	assert and fault and bomb are included here.
X
X	Copyright 1987 Darren New.
X
X*/
X
X#ifndef FAULT_H
X#define FAULT_H 1
X
X#ifndef USE_ASSERT
X#ifdef DEBUG
X#define USE_ASSERT 1
X#else
X#define USE_ASSERT 0
X#endif /* debug */
X#endif /* use_assert */
X
Xextern int FaultExit(void), BombExit(void), AssertExit(void);
Xextern int AssertBomb(char *,char *,int,int,int (*)(void));
Xextern int AssertBombDB(char *,char *,int,int,int (*)(void));
X
X#if USE_DBUGLIB==1
X
X#define fault(s) AssertBombDB(s,__FILE__,__LINE__,2,FaultExit)
X#define bomb(s) AssertBombDB(s,__FILE__,__LINE__,0x83,BombExit)
X
X#else
X
X#define fault(s) AssertBomb(s,__FILE__,__LINE__,2,FaultExit)
X#define bomb(s) AssertBomb(s,__FILE__,__LINE__,0x83,BombExit)
X
X#endif /* use_dbuglib */
X
X#if USE_ASSERT==1
X#if USE_DBUGLIB==1
X
X#define assert(exp) {if(!(exp)){\
XDEBUGF(1,"Assert failed:\"%s\",%s,%d" C #exp C __FILE__ C __LINE__);\
X(void)AssertBomb(#exp,__FILE__,__LINE__,0x81,AssertExit);}}
X
X#else
X
X#define assert(exp) {if(!(exp))(void)AssertBomb(#exp,__FILE__,__LINE__,0x81,AssertExit);}
X
X#endif /* use_dbuglib */
X
X#else
X
X#define assert(exp) {}
X
X#endif /* use_assert */
X
X#endif	/* FAULT_H */
X
END_OF_FILE
if test 1197 -ne `wc -c <'PPL/FaultUnix.h'`; then
    echo shar: \"'PPL/FaultUnix.h'\" unpacked with wrong size!
fi
# end of 'PPL/FaultUnix.h'
fi
if test -f 'PPL/FixMake.Amiga' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/FixMake.Amiga'\"
else
echo shar: Extracting \"'PPL/FixMake.Amiga'\" \(93 characters\)
sed "s/^X//" >'PPL/FixMake.Amiga' <<'END_OF_FILE'
Xjoin MakeHead.Amiga MakeTail as Makefile.Amiga
Xjoin MakeHead.Unix MakeTail as Makefile.Unix
X
END_OF_FILE
if test 93 -ne `wc -c <'PPL/FixMake.Amiga'`; then
    echo shar: \"'PPL/FixMake.Amiga'\" unpacked with wrong size!
fi
# end of 'PPL/FixMake.Amiga'
fi
if test -f 'PPL/FixMake.Unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/FixMake.Unix'\"
else
echo shar: Extracting \"'PPL/FixMake.Unix'\" \(87 characters\)
sed "s/^X//" >'PPL/FixMake.Unix' <<'END_OF_FILE'
Xcat MakeHead.Amiga MakeTail >Makefile.Amiga
Xcat MakeHead.Unix MakeTail >Makefile.Unix
X
END_OF_FILE
if test 87 -ne `wc -c <'PPL/FixMake.Unix'`; then
    echo shar: \"'PPL/FixMake.Unix'\" unpacked with wrong size!
fi
# end of 'PPL/FixMake.Unix'
fi
if test -f 'PPL/MakeHead.Amiga' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/MakeHead.Amiga'\"
else
echo shar: Extracting \"'PPL/MakeHead.Amiga'\" \(1376 characters\)
sed "s/^X//" >'PPL/MakeHead.Amiga' <<'END_OF_FILE'
X#Makefile headers for Commodore Amiga with Lattice 5.04 C compiler
X
X    # These may change from user to user
XEXECDIR=sys:bin/	#executables will be found here (in path)
XPPLDIR=PPLDIR:		#root of the PPL tree (also should be assigned)
X
X    # These should be the same for all users
XMACHINE=Amiga			#host .h to use
XPPLHOST=$(PPLDIR)PPL            #where various host files are stored
XLIB=LIB:			#destination for libraries
XCH=CH:				#compiler headers, uncompressed
XINC=INCLUDE:			#possibly compressed compiler headers
XDATECMD=date			#command to print date on stdout
XCOMPACT=lcompact		#command to copy and compress headers
XCOPY=copy			#command to copy files
XDELETE=delete			#command to delete files
XDIFF=diff -q			#command to compare text files
XCC=LC				#command to run compiler
XLIBEXT=.lib			#extension of a library file
XPPLLIB=$(LIB)PPL$(LIBEXT)       #where the library file is stored
XLIBPRG=OML			#command to manipulate libs
XLIBAFLGS=$(PPLLIB) r            #flags to replace in PPLLIB
XLIBDFLGS=$(PPLLIB) d            #flags to delete in PPLLIB
XLIBIEXT=.c			#library item extension
XWILDCARD=\#?			#wildcard character
XTTY=*				#the TTY file name
XCFLAGS=-i$(INC) -cafkrsu -rr -q1w1e -d3     #LC5.04 flags -- debugging
XCFLAGS=-i$(INC) -cafkrsu -rr -q1w1e -v -O   #LC5.04 flags -- optimizing
XFIXPROT1=protect		#patch prot bits on scripts
XFIXPROT2=+res			#patch prot bits on scripts
X
X
END_OF_FILE
if test 1376 -ne `wc -c <'PPL/MakeHead.Amiga'`; then
    echo shar: \"'PPL/MakeHead.Amiga'\" unpacked with wrong size!
fi
# end of 'PPL/MakeHead.Amiga'
fi
if test -f 'PPL/MakeHead.Unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/MakeHead.Unix'\"
else
echo shar: Extracting \"'PPL/MakeHead.Unix'\" \(1454 characters\)
sed "s/^X//" >'PPL/MakeHead.Unix' <<'END_OF_FILE'
X#Makefile headers for SunOS4.x with GNU C compiler
X
X    # These may change from user to user
XEXECDIR=$(HOME)/bin/        #executables will be found here (in path)
XPPLDIR=$(HOME)/PPLstuff/    #this is the root of the PPL dir tree (should be set)
X
X    # These should be the same for all users
XMACHINE=Unix			#host .h to use
XPPLHOST=$(PPLDIR)PPL            #where various host files are stored
XLIB=$(PPLDIR)                   #destination for libraries
XCH=$(PPLDIR)CH/                 #compiler headers, uncompressed
XINC=$(PPLDIR)Headers/           #possibly compressed compiler headers
XDATECMD=date			#command to print date on stdout
XCOMPACT=cat			#command to copy and compress headers
XCOPY=cp 			#command to copy files
XDELETE=rm -f			#command to delete files
XDIFF=diff -c			#command to compare text files
XCC=gcc				#command to run compiler
XLIBEXT=.a			#extension of a library file
XPPLLIB=$(LIB)libPPL$(LIBEXT)    #where the library file is stored
XLIBPRG=/usr/5bin/ar		#command to manipulate libs
XLIBAFLGS=rvs $(PPLLIB)          #flags to replace in PPLLIB
XLIBDFLGS=dvs $(PPLLIB)          #flags to delete in PPLLIB
XLIBIEXT=.o			#library item extension
XWILDCARD=*			#wildcard character
XTTY=/dev/tty			#the TTY file name
XCFLAGS=-Wall -I$(INC) -c -g -Bstatic  #compiler flags for GCC -- debugging
XCFLAGS=-Wall -I$(INC) -c -O     #compiler flags for GCC -- optimizing
XFIXPROT1=chmod u+rx		#patch prot bits on scripts
XFIXPROT2=			#patch prot bits on scripts
X
X
END_OF_FILE
if test 1454 -ne `wc -c <'PPL/MakeHead.Unix'`; then
    echo shar: \"'PPL/MakeHead.Unix'\" unpacked with wrong size!
fi
# end of 'PPL/MakeHead.Unix'
fi
if test -f 'PPL/MakeTail' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/MakeTail'\"
else
echo shar: Extracting \"'PPL/MakeTail'\" \(2100 characters\)
sed "s/^X//" >'PPL/MakeTail' <<'END_OF_FILE'
X# Makefile for PPL HOST routines
X
X$(MACHINE) : $(EXECDIR)ld.$(MACHINE)
X$(MACHINE) : $(CH)PPL.h $(INC)PPL.h
X$(MACHINE) : $(CH)Fault.h $(INC)Fault.h Fault$(MACHINE).o
X$(MACHINE) : AExit$(MACHINE).o BExit$(MACHINE).o FExit$(MACHINE).o
X$(MACHINE) : PPL$(MACHINE).o
X	date >$(MACHINE)
X
X$(CH)PPL.h : PPL$(MACHINE).h
X	$(COPY) PPL$(MACHINE).h $(CH)PPL.h
X
X$(INC)PPL.h : $(CH)PPL.h $(INC)Fault.h
X	$(COMPACT) <$(CH)PPL.h >$(INC)PPL.h
X
X$(CH)Fault.h : Fault$(MACHINE).h
X	$(COPY) Fault$(MACHINE).h $(CH)Fault.h
X
X$(INC)Fault.h : $(CH)Fault.h
X	$(COMPACT) <$(CH)Fault.h >$(INC)Fault.h
X
XPPL$(MACHINE).o : PPL$(MACHINE).c PPL$(MACHINE).h $(INC)Fault.h
X	$(CC) $(CFLAGS) PPL$(MACHINE).c
X	$(LIBPRG) $(LIBAFLGS) PPL$(MACHINE).o
X
XFault$(MACHINE).o : Fault$(MACHINE).c
X	$(CC) $(CFLAGS) Fault$(MACHINE).c
X	$(LIBPRG) $(LIBAFLGS) Fault$(MACHINE).o
X
XAExit$(MACHINE).o : AExit$(MACHINE).c
X	$(CC) $(CFLAGS) AExit$(MACHINE).c
X	$(LIBPRG) $(LIBAFLGS) AExit$(MACHINE).o
X
XBExit$(MACHINE).o : BExit$(MACHINE).c
X	$(CC) $(CFLAGS) BExit$(MACHINE).c
X	$(LIBPRG) $(LIBAFLGS) BExit$(MACHINE).o
X
XFExit$(MACHINE).o : FExit$(MACHINE).c
X	$(CC) $(CFLAGS) FExit$(MACHINE).c
X	$(LIBPRG) $(LIBAFLGS) FExit$(MACHINE).o
X
X$(EXECDIR)ld.$(MACHINE) : ld.$(MACHINE)
X	$(FIXPROT1) ld.$(MACHINE) $(FIXPROT2)
X	$(COPY) ld.$(MACHINE) $(EXECDIR)ld.$(MACHINE)
X	$(FIXPROT1) $(EXECDIR)ld.$(MACHINE) $(FIXPROT2)
X
Xtags : Fault$(MACHINE).h Fault$(MACHINE).c
Xtags : AExit$(MACHINE).c BExit$(MACHINE).c FExit$(MACHINE).c
Xtags : PPL$(MACHINE).h PPL$(MACHINE).c
X	ctags Fault$(MACHINE).h Fault$(MACHINE).c
X	ctags -a AExit$(MACHINE).c BExit$(MACHINE).c FExit$(MACHINE).c
X	ctags -a PPL$(MACHINE).h PPL$(MACHINE).c
X
Xtest : $(MACHINE)
X	$(CC) $(CFLAGS) TestHost.c
X	ld.$(MACHINE) TestHost TestHost.o
X	TestHost
X
Xzap : clean
X	-$(DELETE) $(MACHINE)
X	-$(DELETE) tags
X	-$(DELETE) $(CH)PPL.h
X	-$(DELETE) $(INC)PPL.h
X	-$(DELETE) $(CH)Fault.h
X	-$(DELETE) $(INC)Fault.h
X	-$(DELETE) $(PPLLIB)
X	-$(DELETE) TestHost
X
Xclean :
X	-$(DELETE) $(WILDCARD).tmp
X	-$(DELETE) $(WILDCARD).o
X	-$(DELETE) $(WILDCARD).err
X	-$(DELETE) t:$(WILDCARD)
X	-$(DELETE) $(WILDCARD).lnk
X	-$(DELETE) core
X
X#end of Makefile
X
END_OF_FILE
if test 2100 -ne `wc -c <'PPL/MakeTail'`; then
    echo shar: \"'PPL/MakeTail'\" unpacked with wrong size!
fi
# end of 'PPL/MakeTail'
fi
if test -f 'PPL/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/README'\"
else
echo shar: Extracting \"'PPL/README'\" \(2040 characters\)
sed "s/^X//" >'PPL/README' <<'END_OF_FILE'
X
XThese programs and all derivative works are copyright 1990 by
XDarren New. All Rights Reserved.
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the names of the copyright holder or author not be
Xused in advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XBOTH THE AUTHOR AND THE COPYRIGHT HOLDER DISCLAIM ALL WARRANTIES WITH
XREGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
XMERCHANTABILITY AND FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDER OR THE
XAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
XDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
XAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
XOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X
XThe author can currently be reached in the USA by phone at
X(302) 451-8013, by electronic mail at "new@udel.edu", or by
Xphysical mail at 151 Thorn Lane #12, Newark, DE 19711.
X
XIf you find this program (or the included libraries) useful, a
Xdonation would be welcome. Questions, comments, improvements, and
Xports are also welcome and will be redistributed with thanks and
Xattribution.
X
X
X----------------------------------------------------------------------
X
X
XPlease note that neither the TFS nor the BFS (nor the UIS or VMS, for
Xthat matter) are actually complete yet. However, they do seem to be
Xsufficiently complete to get LOME, Comp1, and Interp working. I
Xrelease them only for the recompilation of the files in the LOME
Xdistribution.
X
XExpect a new distribution of the lower-level routines along with new
Xprograms in the not-so-near future.
X
XTo install the Portable Programmer's Library, please see the bottom of
Xthe PPL.doc file. Thank you.          -- Darren New
X
X
X
END_OF_FILE
if test 2040 -ne `wc -c <'PPL/README'`; then
    echo shar: \"'PPL/README'\" unpacked with wrong size!
fi
# end of 'PPL/README'
fi
if test -f 'PPL/ShiftLeft.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/ShiftLeft.c'\"
else
echo shar: Extracting \"'PPL/ShiftLeft.c'\" \(790 characters\)
sed "s/^X//" >'PPL/ShiftLeft.c' <<'END_OF_FILE'
X/*
X * ShiftLeft.c
X * This program reads stdin and writes stdout.
X * If it sees a line starting with a multiple of eight spaces,
X * it outputs the same line starting with half as many spaces.
X * This essentially changes tabs to four spaces.
X * Started: 24-Feb-88 DHN
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <ctype.h>
X
Xvoid main()
X{
X    extern int errno;
X    int ls;		    /* number of leading spaces */
X    char ib[500];	    /* input buffer */
X    int err;		    /* error while writing */
X
X    while (NULL != gets(ib)) {
X	for (ls = 0; isspace(ib[ls]); ls++)
X	    ;
X	if ((0 < ls) && ((ls % 8) == 0))
X	    err = puts(&ib[ls / 2]);
X	else
X	    err = puts(ib);
X	if (errno != 0) {
X	    fprintf(stderr, "Error=%d, errno=%d\n", err, errno);
X	    exit(99);
X	    }
X	}
X
X    exit(0);
X    }
X
X
END_OF_FILE
if test 790 -ne `wc -c <'PPL/ShiftLeft.c'`; then
    echo shar: \"'PPL/ShiftLeft.c'\" unpacked with wrong size!
fi
# end of 'PPL/ShiftLeft.c'
fi
if test -f 'PPL/TestHost.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/TestHost.c'\"
else
echo shar: Extracting \"'PPL/TestHost.c'\" \(809 characters\)
sed "s/^X//" >'PPL/TestHost.c' <<'END_OF_FILE'
X/* TestFault.c -- Test the Fault function */
X
X#include "PPL.h"
X
Xshort DoIt()
X{
X    short i;
X    char * s = "Fault returned ";
X    char * t;
X    char r[50];
X
X    do {
X	i = fault("Well, here I am!");
X	for (t = s; *t; t++)
X	    PLPutChar((short) *t);
X	PLPutChar((short) PLToDig(i));
X	PLPutChar((short) '\n');
X	PLDelay(10);
X	PLResetInput();
X	PLResetOutput();
X	} while (i == 1);
X
X    strcpy(r, "Z Message X");
X
X    r[0] = PLToDig(PLstatuslevel);
X    for (i = 0; i < 10; i++) {
X	r[10] = PLToDig(i);
X	PLStatus(i, r);
X	PLDelay(1);
X	}
X
X    PLstatuslevel = 9;
X    r[0] = '9';
X    for (i = 0; i < 10; i++) {
X	r[10] = PLToDig(i);
X	PLStatus(i, r);
X	PLDelay(1);
X	}
X
X    PLstatuslevel = 0;
X    r[0] = '0';
X    for (i = 0; i < 10; i++) {
X	r[10] = PLToDig(i);
X	PLStatus(i, r);
X	PLDelay(1);
X	}
X
X    return PLsev_normal;
X    }
X
END_OF_FILE
if test 809 -ne `wc -c <'PPL/TestHost.c'`; then
    echo shar: \"'PPL/TestHost.c'\" unpacked with wrong size!
fi
# end of 'PPL/TestHost.c'
fi
if test -f 'PPL/ld.Amiga' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/ld.Amiga'\"
else
echo shar: Extracting \"'PPL/ld.Amiga'\" \(635 characters\)
sed "s/^X//" >'PPL/ld.Amiga' <<'END_OF_FILE'
X.key out/a,f1/a,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15
X. This will link together all the indicated .o files.
X. The first argument must be the name of the executable (w/o extension)
X. It will also link in the PPL library.
X.bra {
X.ket }
X
X. First, build the .lnk file
X.   execute >{out}.lnk ld1.Amiga {f1} {f2} {f3} {f4} {f5} {f6} {f7} {f8} {f9} {f10} {f11} {f12} {f13} {f14} {f15}
Xjoin {f1} {f2} {f3} {f4} {f5} {f6} {f7} {f8} {f9} as t:obj1.lnk
Xjoin t:obj1.lnk {f10} {f11} {f12} {f13} {f14} {f15} as t:obj2.lnk
XBLINK to {out} from LIB:c.o+t:obj2.lnk LIB LIB:PPL.lib+LIB:lcr.lib+LIB:amiga.lib ADDSYM
Xdelete t:obj(1|2).lnk quiet
X
END_OF_FILE
if test 635 -ne `wc -c <'PPL/ld.Amiga'`; then
    echo shar: \"'PPL/ld.Amiga'\" unpacked with wrong size!
fi
# end of 'PPL/ld.Amiga'
fi
if test -f 'PPL/ld.Unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/ld.Unix'\"
else
echo shar: Extracting \"'PPL/ld.Unix'\" \(280 characters\)
sed "s/^X//" >'PPL/ld.Unix' <<'END_OF_FILE'
X#!/bin/csh
X# This will link together all the indicated .o files.
X# It will also link the PPL library in and will generate an
X# output file named after the first .o file on the line.
X#    -Bstatic for debugging
X
Xgcc -L$PPLDIR -g -o $* -lPPL -Bstatic
X#gcc -L$PPLDIR -O -o $* -lPPL
X
END_OF_FILE
if test 280 -ne `wc -c <'PPL/ld.Unix'`; then
    echo shar: \"'PPL/ld.Unix'\" unpacked with wrong size!
fi
# end of 'PPL/ld.Unix'
fi
if test ! -d 'TFS' ; then
    echo shar: Creating directory \"'TFS'\"
    mkdir 'TFS'
fi
if test -f 'TFS/FixMake.Amiga' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TFS/FixMake.Amiga'\"
else
echo shar: Extracting \"'TFS/FixMake.Amiga'\" \(115 characters\)
sed "s/^X//" >'TFS/FixMake.Amiga' <<'END_OF_FILE'
Xjoin PPLDIR:PPL/MakeHead.Amiga MakeTail as Makefile.Amiga
Xjoin PPLDIR:PPL/MakeHead.Unix MakeTail as Makefile.Unix
X
END_OF_FILE
if test 115 -ne `wc -c <'TFS/FixMake.Amiga'`; then
    echo shar: \"'TFS/FixMake.Amiga'\" unpacked with wrong size!
fi
# end of 'TFS/FixMake.Amiga'
fi
if test -f 'TFS/FixMake.Unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TFS/FixMake.Unix'\"
else
echo shar: Extracting \"'TFS/FixMake.Unix'\" \(111 characters\)
sed "s/^X//" >'TFS/FixMake.Unix' <<'END_OF_FILE'
Xcat $PPLDIR/PPL/MakeHead.Amiga MakeTail >Makefile.Amiga
Xcat $PPLDIR/PPL/MakeHead.Unix MakeTail >Makefile.Unix
X
END_OF_FILE
if test 111 -ne `wc -c <'TFS/FixMake.Unix'`; then
    echo shar: \"'TFS/FixMake.Unix'\" unpacked with wrong size!
fi
# end of 'TFS/FixMake.Unix'
fi
if test -f 'TFS/MakeTail' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TFS/MakeTail'\"
else
echo shar: Extracting \"'TFS/MakeTail'\" \(1109 characters\)
sed "s/^X//" >'TFS/MakeTail' <<'END_OF_FILE'
X# Makefile for PPL TFS routines
X
X$(MACHINE) : $(CH)TFS.h $(INC)TFS.h TFS$(MACHINE).o
X	date >$(MACHINE)
X
X$(CH)TFS.h : TFS.h
X	$(COPY) TFS.h $(CH)TFS.h
X
X$(INC)TFS.h : $(CH)TFS.h
X	$(COMPACT) <$(CH)TFS.h >$(INC)TFS.h
X
XTFS$(MACHINE).o : TFS$(MACHINE).c $(INC)TFS.h $(INC)PPL.h
X	$(CC) $(CFLAGS) TFS$(MACHINE).c
X	$(LIBPRG) $(LIBAFLGS) TFS$(MACHINE).o
X
Xtest : $(MACHINE) TestTFS TestTFS.inp
X	$(DELETE) t:$(WILDCARD)
X	$(COPY) TestTFS.inp t:file-a
X	$(COPY) TestTFS.inp t:file-c
X	TestTFS >t:TestTFS1.out
X	$(DIFF) t:TestTFS1.out TestTFS1.out
X	$(DIFF) t:file-b TestTFS2.out
X#	t:file-c should remain, t:file-a should be gone
X
XTestTFS : TestTFS.c $(PPLLIB)
X	$(CC) $(CFLAGS) TestTFS.c
X	ld.$(MACHINE) TestTFS TestTFS.o
X
Xtags : TFS.h TFS$(MACHINE).c
X	ctags TFS.h TFS$(MACHINE).c
X
Xzap : clean
X	-$(DELETE) $(MACHINE)
X	-$(DELETE) tags
X	-$(DELETE) $(CH)TFS.h
X	-$(DELETE) $(INC)TFS.h
X	-$(DELETE) TestTFS
X	-$(LIBPRG) $(LIBDFLGS) TFS$(MACHINE)$(LIBIEXT)
X
Xclean :
X	-$(DELETE) $(WILDCARD).tmp
X	-$(DELETE) $(WILDCARD).o
X	-$(DELETE) $(WILDCARD).lnk
X	-$(DELETE) t:$(WILDCARD)
X	-$(DELETE) $(WILDCARD).err
X	-$(DELETE) core
X
X#end of Makefile
X
END_OF_FILE
if test 1109 -ne `wc -c <'TFS/MakeTail'`; then
    echo shar: \"'TFS/MakeTail'\" unpacked with wrong size!
fi
# end of 'TFS/MakeTail'
fi
if test -f 'TFS/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TFS/README'\"
else
echo shar: Extracting \"'TFS/README'\" \(2040 characters\)
sed "s/^X//" >'TFS/README' <<'END_OF_FILE'
X
XThese programs and all derivative works are copyright 1990 by
XDarren New. All Rights Reserved.
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the names of the copyright holder or author not be
Xused in advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XBOTH THE AUTHOR AND THE COPYRIGHT HOLDER DISCLAIM ALL WARRANTIES WITH
XREGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
XMERCHANTABILITY AND FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDER OR THE
XAUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
XDAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
XAN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
XOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X
XThe author can currently be reached in the USA by phone at
X(302) 451-8013, by electronic mail at "new@udel.edu", or by
Xphysical mail at 151 Thorn Lane #12, Newark, DE 19711.
X
XIf you find this program (or the included libraries) useful, a
Xdonation would be welcome. Questions, comments, improvements, and
Xports are also welcome and will be redistributed with thanks and
Xattribution.
X
X
X----------------------------------------------------------------------
X
X
XPlease note that neither the TFS nor the BFS (nor the UIS or VMS, for
Xthat matter) are actually complete yet. However, they do seem to be
Xsufficiently complete to get LOME, Comp1, and Interp working. I
Xrelease them only for the recompilation of the files in the LOME
Xdistribution.
X
XExpect a new distribution of the lower-level routines along with new
Xprograms in the not-so-near future.
X
XTo install the Portable Programmer's Library, please see the bottom of
Xthe PPL.doc file. Thank you.          -- Darren New
X
X
X
END_OF_FILE
if test 2040 -ne `wc -c <'TFS/README'`; then
    echo shar: \"'TFS/README'\" unpacked with wrong size!
fi
# end of 'TFS/README'
fi
if test -f 'TFS/TestTFS.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TFS/TestTFS.c'\"
else
echo shar: Extracting \"'TFS/TestTFS.c'\" \(1831 characters\)
sed "s/^X//" >'TFS/TestTFS.c' <<'END_OF_FILE'
X/*
X * TestTFS.c
X * Copyright 1987 Darren New.
X * TEST VERSION!
X */
X
X#include "PPL.h"
X#include "TFS.h"
X
X#include <stdio.h>
X
X#if HIDPROTS
XHIDDEN void showerr(int,short,char);
X#endif
X
XHIDDEN void showerr ARGS3(int,progline,short,line,char,fch)
X{
X    if (PLerr != PLerr_none) {
X	/* fprintf(stderr,
X"LINE=%d, PLErr=%d, OSerr=%ld, errmess=%s, errline=%d, errfile=%s\n",
X		line, PLerr , OSerr , PLErrText() , PLerr_line , PLerr_file);
X	*/
X	printf("fileline=%d, progline=%d, fch=%c, PLErr=%d, errmess=%s\n",
X		line, progline, fch ? fch : '@', PLerr, PLErrText());
X	PLErrClr();
X	}
X    }
X
X
X
Xshort DoIt()
X{
X
X    TFSfile a, b, c, d, e;
X    TFSnote a1;
X    short l, m;
X    char buf[BIGLINE+1];
X    short line = 1;
X
X    TFSInit();
X
X    buf[BIGLINE] = '|';
X
X    a = TFSOpen("t:file-a", "RPD");
X    showerr(__LINE__,0,'a');
X
X    b = TFSOpen("t:file-b", "CTW");
X    showerr(__LINE__,0,'b');
X
X    c = TFSOpen("t:file-c", "LD");
X    showerr(__LINE__,0,'c');
X
X    d = TFSOpen("t:file-d", "LR");
X    showerr(__LINE__,0,'d');
X
X    e = TFSOpen("t:file-e", "LWCT");
X    showerr(__LINE__,0,'e');
X
X    loop {
X	long holderr;
X	a1 = TFSNote(a); showerr(__LINE__,line,'N');
X	l = TFSRead(a, buf); holderr = PLerr; showerr(__LINE__,line,buf[0]);
X	if (l < 0 && holderr != PLerr_overflow) break;
X	if (holderr != PLerr_overflow)
X	    assert(l <= 0 ? 0 == buf[0] : 0 == buf[l]);
X	assert(l <= 0 || !isspace(buf[l-1]));
X	m = TFSWrite(b, buf); showerr(__LINE__,line,buf[0]);
X	if (buf[BIGLINE] != '|') {
X	    if (fault("buf[BIGLINE] trashed!")) {
X		break;
X		}
X	    }
X	line++;
X	}
X    if (l != -1 || PLerr != PLerr_eod) showerr(__LINE__,line,buf[0]);
X
X    if (!TFSWrite(b, "3 Trailing spaces:   ")) {
X	showerr(__LINE__,0,' ');
X	}
X
X    if (!TFSClose(b)) {
X	showerr(__LINE__,0,'C');
X	}
X
X    if (!TFSDestroy(a)) {
X	showerr(__LINE__,0,'D');
X	}
X
X    return PLsev_normal;
X    }
X
END_OF_FILE
if test 1831 -ne `wc -c <'TFS/TestTFS.c'`; then
    echo shar: \"'TFS/TestTFS.c'\" unpacked with wrong size!
fi
# end of 'TFS/TestTFS.c'
fi
if test -f 'TFS/TestTFS1.out' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TFS/TestTFS1.out'\"
else
echo shar: Extracting \"'TFS/TestTFS1.out'\" \(408 characters\)
sed "s/^X//" >'TFS/TestTFS1.out' <<'END_OF_FILE'
Xfileline=0, progline=54, fch=d, PLErr=9, errmess=Item does not exist
Xfileline=22, progline=62, fch=d, PLErr=18, errmess=Overflow error
Xfileline=23, progline=62, fch=e, PLErr=18, errmess=Overflow error
Xfileline=24, progline=62, fch=f, PLErr=18, errmess=Overflow error
Xfileline=25, progline=62, fch=g, PLErr=18, errmess=Overflow error
Xfileline=28, progline=62, fch=@, PLErr=6, errmess=End of data during input
END_OF_FILE
if test 408 -ne `wc -c <'TFS/TestTFS1.out'`; then
    echo shar: \"'TFS/TestTFS1.out'\" unpacked with wrong size!
fi
# end of 'TFS/TestTFS1.out'
fi
echo shar: End of archive 1 \(of 9\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 9 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
--- Darren New --- Grad Student --- CIS --- Univ. of Delaware ---

exit 0 # Just in case...
-- 
Please send comp.sources.unix-related mail to rsalz@uunet.uu.net.
Use a domain-based address or give alternate paths, or you may lose out.
