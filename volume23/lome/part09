Path: j.cc.purdue.edu!mentor.cc.purdue.edu!purdue!bu.edu!rpi!julius.cs.uiuc.edu!wuarchive!uunet!papaya.bbn.com!rsalz
From: rsalz@bbn.com (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v23i059:  Line oriented macro processor, Part09/09
Message-ID: <3034@litchi.bbn.com>
Date: 29 Nov 90 17:45:19 GMT
Organization: BBN Systems and Technologies, Cambridge MA
Lines: 1541
Approved: rsalz@uunet.UU.NET

Submitted-by: Darren New <new@ee.udel.edu>
Posting-number: Volume 23, Issue 59
Archive-name: lome/part09

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 9)."
# Contents:  LOME/SCM.doc LOME/SCMTestC.out PPL/PPLAmiga.h
# Wrapped by new@estelle.ee.udel.edu on Tue Aug 14 16:10:02 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'LOME/SCM.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/SCM.doc'\"
else
echo shar: Extracting \"'LOME/SCM.doc'\" \(14260 characters\)
sed "s/^X//" >'LOME/SCM.doc' <<'END_OF_FILE'
X
XSCM (Simple Character Manipulator) is a language used to write a
Xsophiticated macro expander. It is designed to be compiled by Comp1,
Xand as such is very simple and not particularly easy to read or use,
Xbut is particularly easy to implement. The syntax and semantics are
Xdescribed herein.
X
XThe SCM language is based on a simple abstract machine. The memory of
Xthis machine is organized into "cells" which can hold a two-bit flag,
Xan eight-bit unsigned value, and a pointer to a cell (an address). The
Xmemory consists of 36 single-cell registers and a memory space of
Xnumbered cells (i.e., an array of cells). Each SCM program may have up
Xto 99 labels, numbered 01 through 99. Up to 26 subroutines may be
Xwritten and used. All operations except GET and PUT are performed on
Xregisters; only GET and PUT address the general memory. Neither the
Xregisters not the program code are in memory addressable by the GET
Xand PUT instructions. There are only limited capabilities for literals
Xavailable, but some of the registers are initialized to various
Xconstants which are probably unwise to overwrite.
X
XThe registers are names A, B, C, ..., Y, Z, 0, 1, ..., 8, 9. That is,
Xlegal register names include all upper case letters and all digits.
XEach cell consists of three fields: FLG is a two-bit flag field taking
Xthe values 0, 1, 2, or 3. VAL is an eight-bit field taking the values
X0 through 255. PTR is a signed field large enough to address the
Xlowest-numbered and highest-numbered cells in the memory array. It is
Xexpected that this field will be at least 16 bits long. The VAL field
Xmay be used to store either characters or string lengths. The PTR
Xfield may be used to store addresses of memory cells or general signed
Xintegers.
X
XThere are six general classes of instructions in the SCM language:
Xdeclaration statements, control statements, data movement statements,
Xarithmetic statements, branch statements, and I/O statements. These
Xstatements are described below. In the descriptions of the statements,
Xa single dollar sign represents the name of a register; a double
Xdollar sign represents a two-digit label. In the text explaining the
Xsemantics, R1 represents the first register parameter, R2 the second
Xregister parameter, L1 the first label parameter, L2 the second label
Xparameter, and so on.
X
XSince there are no literals, the interpreter (or macros) for SCM must
Xinitialize certain registers before executing the first user
Xstatement. The registers whose names are digits must be initialized as
Xindicated below:
X
XReg     VAL     FLG     PTR
X---     ---     ---     ---
X0       0       0       0
X1       1       1       1
X2       2       2       2
X3       3       3       3
X4       4               4
X5       5               5
X6       6               10
X7       7
X8       8               The lowest value legal for the PTR R2 field in
X                        the GET instruction.
X9       9               The lowest value not legal for the PTR R1
X                        field in the PUT instruction.
X
X
X
X
X                    Declaration statements:
X
XBEGIN PROGRAM.
XThis must be the first statement in any SCM program. No instruction
Xmay appear between the BEGIN PROGRAM and the first BEGIN MAIN ROUTINE
Xor BEGIN SUBROUTINE $.
X
XEND PROGRAM.
XThis must be the last instruction in any SCM program.
X
XBEGIN MAIN ROUTINE.
XThis immediately preceeds the first statement to be executed by the
Xprogram. It must appear in any program.
X
XEND MAIN ROUTINE.
XThis immediately preceeds END PROGRAM, and if execution reaches this
Xstatement the program is terminated successfully. It must appear in
Xevery program.
X
XBEGIN SUBROUTINE $.
XThis immediately preceeds the first instruction of subroutine R1. This
Xmay appear at most once for any given register. This must preceed the
Xcorresponding END SUBROUTINE R1 and must preceed BEGIN MAIN ROUTINE.
XAlso, this may not appear when more BEGIN SUBROUTINE statements than
XEND SUBROUTINE statements have appeared. I.e., subroutines do not
Xnest and must preceed the main program. Instructions executed between
Xa BEGIN SUBROUTINE R1 and an END SUBROUTINE R1 should not reference or
Xalter R1, which may be being used to hold the return address.
X
XEND SUBROUTINE $.
XThis immediately follows the last instruction to be executed as part
Xof subroutine R1. It must follow BEGIN SUBROUTINE R1 and must appear
Xif BEGIN SUBROUTINE R1 appears. When execution reaches this statement,
Xcontrol is transfered to the instruction following the most recently
Xexecuted CALL R1 instuction. This must preceed the BEGIN MAIN ROUTINE
Xinstruction. No instructions may appear between an END SUBROUTINE $
Xand the next BEGIN SUBROUTINE or BEGIN MAIN ROUTINE.
X
XLABEL $$.
XThis marks the destination of a branch instruction. At execution time,
Xit does nothing. L1 must not match L1 of any other LABEL $$
Xinstruction anywhere in the program.
X
XCHRDATA $$ $ $ $$.
XThis must only follow a BEGIN MAIN ROUTINE statement, a CHRDATA
Xstatement, or a NUMDATA statement. It sets the memory location at
Xposition (R1*10+R2) (where R1, R2 are digits) to have the FLG field of
XR3 (0,1,2,3) and the VAL field of R4 (any character) and the PTR field
Xof (R5*10+R6) (where R5, R6 are digits).
X
XNUMDATA $$ $ $$ $$.
XThis must only follow a BEGIN MAIN ROUTINE statement, a CHRDATA
Xstatement, or a NUMDATA statement. It sets the memory location at
Xposition (R1*10+R2) (where R1, R2 are digits) to have the FLG field of
XR3 (0,1,2,3) and the VAL field of (R4*10+R5) (where R4, R5 are digits)
Xand the PTR field of (R6*10+R7) (where R6, R7 are digits).
X
X
X
X
X                    Control statements:
X
XSTOP $.
XThis terminates execution of the program. It is intended that the
Xtermination be considered "abnormal" or as the result of an error. The
Xcontents of register R1 should be displayed to the user if possible.
X
XCALL $.
XThis causes execution to begin at the first instruction following the
Xstatement BEGIN SUBROUTINE R1. The contents of R1 may be destroyed by
Xthis instruction. Execution resumes at the instruction following CALL
XR1 when the END SUBROUTINE R1 is executed. It is illegal to execute
XCALL R1 between the time a CALL R1 is executed and an END SUBROUTINE
XR1 is executed; i.e., subroutines are not recursive.
X
X                    Data Movement statements:
X
XGET $ = MEM $.
XThis reads the fields from the memory array cell addressed by the PTR
Xfield of the R2 register and stores them in R1. Neither the memory
Xnor R2 are changed by this instruction; R1's old contents are lost.
XNote that the PTR field may be implemented as an actual memory
Xaddress, as an array subscript, or something else altogether.
XTherefore, generation of memory array pointers requires the use of the
XMOV PTR $ = $ instruction.
X
XPUT MEM $ = $.
XThis writes the fields from R2 into the memory array cell addressed by
Xthe PTR field of R1. Neither R1 nor R2 are changed by this
Xinstruction; the old contents of the memory cell are lost.
X
XFLG $ = $.
XThe FLG field of R1 is overwritten with the contents of the FLG field
Xof R2. R2 is not changed.
X
XPTR $ = VAL $.
XThe PTR field of R1 is overwritten with the contents of the VAL field
Xof R2. R2 is not changed. PTR will always become a number from 0 to
X255 as the result of this instruction.
X
XVAL $ = PTR $.
XThe VAL field of R1 is overwritten with the contents of the PTR field
Xof R2. R2 is not changed. VAL will always become a number from 0 to
X255 as the result of this instruction; if the PTR field is outside of
Xthis range, the contents of VAL R1 are undefined as the result of this
Xinstruction.
X
X                    Arithmetic statements:
X
XVAL $ = $ + $.
XThe VAL field of R1 is overwritten by the sum of the contents of the
XVAL fields of R2 and R3. If the result is outside of the range 0
Xthrough 255, the result in VAL R1 is undefined. The same register may
Xappear any number of times in the statement; i.e., VAL A = A + A is
Xlegal. No field is changed except VAL R1.
X
XVAL $ = $ - $.
XThe VAL field of R1 is overwritten by the difference of the contents
Xof the VAL fields of R2 and R3 (R2 - R3, not R3 - R2). If the result
Xis outside of the range 0 through 255, the result in VAL R1 is
Xundefined. The same register may appear any number of times in the
Xstatement; i.e., VAL A = A - A is legal. No field is changed except
XVAL R1.
X
XPTR $ = $ + $.
XThe PTR field of R1 is overwritten by the sum of the contents of the
XPTR fields of R2 and R3. If the result is outside of the range
Xstorable in PTR fields, the result in PTR R1 is undefined. The same
Xregister may appear any number of times in the statement; i.e., PTR A
X= A + A is legal. No field is changed except PTR R1.
X
XPTR $ = $ - $.
XThe PTR field of R1 is overwritten by the difference of
Xthe contents of the PTR fields of R2 and R3 (R2 - R3, not R3 - R2). If
Xthe result is outside of the range storable in PTR fields, the result
Xin PTR R1 is undefined. The same register may appear any number of
Xtimes in the statement; i.e., PTR A = A - A is legal. No field is
Xchanged except PTR R1.
X
XPTR $ = $ * $.
XThe PTR field of R1 is overwritten by the product of the contents of
Xthe PTR fields of R2 and R3. If the result is outside of the range
Xstorable in PTR fields, the result in PTR R1 is undefined. The same
Xregister may appear any number of times in the statement; i.e., PTR A
X= A * A is legal. No field is changed except PTR R1. The normal rules
Xfor multiplying negative numbers apply.
X
XPTR $ = $ / $.
XThe PTR field of R1 is overwritten by the quotient of the contents of
Xthe PTR fields of R2 and R3 (R2 / R3, not R3 / R2). If the result is
Xoutside of the range storable in PTR fields, the result in PTR R1 is
Xundefined. The same register may appear any number of times in the
Xstatement; i.e., PTR A = A / A is legal. No field is changed except
XPTR R1. If the division results in a remainder, the remainder is
Xdiscarded. The normal rules for dividing negative numbers apply.
X
XMOV PTR $ BY $.
XThe PTR field of R1 is assumed to hold the address of
Xa memory cell. PTR R1 is replaced by a pointer that is PTR R2 memory
Xcells beyond where PTR R1 pointed before this instruction. If PTR R2
Xis zero, no change is made; if PTR R2 is negative, PTR R1 is replaced
Xby a pointer that is PTR R2 memory cells before where PTR R1 pointed
Xbefore this instruction. Use of this instruction allows the
Ximplementation to use more than one addressable unit per memory cell;
Xnormall addition, subtraction, and so on may not yield valid memory
Xcell addresses.
X
X                    Branch statements:
X
XTO $$.
XThe next instruction to be executed will be the instruction following
XLABEL L1. The LABEL L1 statement must appear and must not be separated
Xfrom the TO L1 statement by a BEGIN MAIN ROUTINE or a BEGIN SUBROUTINE
X$ statement. This must always be followed by a LABEL $$, END
XSUBROUTINE $, or END MAIN PROGRAM statement.
X
XTO $$ IF FLG $ EQ $.
XIf the FLG field of R1 has the same contents as the FLG field of R2,
Xthis behaves identically to TO L1 (including the restrictions on
Xplacement of LABEL L1). Otherwise, this statement has no effect.
X
XTO $$ IF FLG $ NE $.
XIf the FLG field of R1 has different contents from the FLG field of
XR2, this behaves identically to TO L1 (including the restrictions on
Xplacement of LABEL L1). Otherwise, this statement has no effect.
X
XTO $$ IF VAL $ EQ $.
XIf the VAL field of R1 has the same contents as the VAL field of R2,
Xthis behaves identically to TO L1 (including the restrictions on
Xplacement of LABEL L1). Otherwise, this statement has no effect.
X
XTO $$ IF VAL $ NE $.
XIf the VAL field of R1 has different contents from the VAL field of
XR2, this behaves identically to TO L1 (including the restrictions on
Xplacement of LABEL L1). Otherwise, this statement has no effect.
X
XTO $$ IF PTR $ EQ $.
XIf the PTR field of R1 has the same contents as the PTR field of R2,
Xthis behaves identically to TO L1 (including the restrictions on
Xplacement of LABEL L1). Otherwise, this statement has no effect.
X
XTO $$ IF PTR $ NE $.
XIf the PTR field of R1 has different contents from the PTR field of
XR2, this behaves identically to TO L1 (including the restrictions on
Xplacement of LABEL L1). Otherwise, this statement has no effect.
X
XTO $$ IF PTR $ LT $.
XIf the contents of the PTR field of R1 is numerically less than the
Xcontents from the PTR field of R2, this behaves identically to TO L1
X(including the restrictions on placement of LABEL L1). Otherwise, this
Xstatement has no effect.
X
X                    I/O statements:
X
XREWIND $.
XThe VAL field must have a value from zero to nine. The indicated
Xstream is rewound. If no error occurred, the FLG field of R1 will be
Xset to zero; otherwise, it will be set to one. No other fields are
Xchanged. The line buffer is not affected.
X
XGET BUFF $.
XThe VAL field must have a value from zero to nine. The indicated
Xstream is read using MGetBuff. If no error occurred, the FLG field of
XR1 will be set to zero; if the end of the input stream is detected,
Xthe FLG field of R1 will be set to one; if some other error is
Xdetected, the FLG field will be set to two.
X
XPUT BUFF $.
XThe VAL field must have a value from zero to nine. The indicated
Xstream is written using MPutBuff. If no error occurred, the FLG field
Xof R1 will be set to zero; if the end of the input stream is detected,
Xthe FLG field of R1 will be set to one; if some other error is
Xdetected, the FLG field will be set to two.
X
XVAL $ = INPUT.
XThis uses MGetChar to retrieve the next input character from the line
Xbuffer. The inputted character is placed in the VAL field of R1; no
Xother field is changed. As usual, end-of-line is indicated by the
Xreturned value being zero.
X
XOUTPUT = VAL $.
XThis places the contents of the VAL field of R1 at the next location
Xin the line buffer using MPutChar. If the buffer has filled, the VAL
Xfield of R1 is set to zero; otherwise, no fields are changed.
X
XDEBUG.
XThe implementation of this varies, but its intent is to produce output
Xallowing a programmer in SCM to dump the registers and memory at
Xspecific places in the code for debugging purposes.
X
XMESSAGE $$$$ TO $. This clears the line buffer, places the error message
Xcontaining the string $$$$ into it, then puts it as if PUT BUFF R5 was
Xcalled. This is kind of kludgy, and will be removed if I figure out how.
XThe problem with removing it is not having constants for the characters
Xwhich should be outputted.
X
X
END_OF_FILE
if test 14260 -ne `wc -c <'LOME/SCM.doc'`; then
    echo shar: \"'LOME/SCM.doc'\" unpacked with wrong size!
fi
# end of 'LOME/SCM.doc'
fi
if test -f 'LOME/SCMTestC.out' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LOME/SCMTestC.out'\"
else
echo shar: Extracting \"'LOME/SCMTestC.out'\" \(13523 characters\)
sed "s/^X//" >'LOME/SCMTestC.out' <<'END_OF_FILE'
X/*
X * SCM Executable program.
X * Generated by SCM Macros.
X *
X */
X#include "PPL.h"
X#include "MacroIO.h"
X					    /* */
X/* Declare the memory cells */
X#define MEMSIZ 6000
Xlong MEM[MEMSIZ];
X					    /* */
X/* Declare the registers */
Xshort FA, FB, FC, FD, FE, FF, FG, FH, FI, FJ, FK, FL, FM;
Xshort FN, FO, FP, FQ, FR, FS, FT, FU, FV, FW, FX, FY, FZ;
Xshort F0, F1, F2, F3;
Xshort VA, VB, VC, VD, VE, VF, VG, VH, VI, VJ, VK, VL, VM;
Xshort VN, VO, VP, VQ, VR, VS, VT, VU, VV, VW, VX, VY, VZ;
Xshort V0, V1, V2, V3, V4, V5, V6, V7, V8, V9;
Xlong  PA, PB, PC, PD, PE, PF, PG, PH, PI, PJ, PK, PL, PM;
Xlong  PN, PO, PP, PQ, PR, PS, PT, PU, PV, PW, PX, PY, PZ;
Xlong  P0, P1, P2, P3, P4, P5, P6, P7, P8, P9;
X					    /* */
Xvoid Stop ARGS((short, short, long));
Xvoid Oops ARGS((char *));
X					    /* */
Xvoid Stop ARGS3(short,flg,short,val,long,ptr)
X{
X    PLStatus(1, "Stop!");
X    PLExit(PLsev_error);
X    }
X					    /* */
Xvoid Oops ARGS1(char*,s)
X{
X    PLStatus(1, "Oops:");
X    PLStatus(1, s);
X    PLExit(PLsev_error);
X    }
X					    /* */
X/* BEGIN PROGRAM. */
X					    /* */
X/* BEGIN SUBROUTINE F. */
Xvoid SubF(void);
Xvoid SubF()
X{
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X/* END SUBROUTINE F. */
X    return;
X    }
X/* BEGIN SUBROUTINE S. */
Xvoid SubS(void);
Xvoid SubS()
X{
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (F1 == F1) goto LABEL03;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL03:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (F1 == F2) goto LABEL05;
X    goto LABEL04;
X    LABEL05:
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL04:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (F1 != F1) goto LABEL06;
X    goto LABEL07;
X    LABEL06:
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL07:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (F1 != F2) goto LABEL08;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL08:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (V1 == V1) goto LABEL09;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL09:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (V1 == V2) goto LABEL10;
X    goto LABEL11;
X    LABEL10:
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL11:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (V1 != V1) goto LABEL12;
X    goto LABEL13;
X    LABEL12:
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL13:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (V1 != V2) goto LABEL14;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL14:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (P1 == P1) goto LABEL15;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL15:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (P1 == P2) goto LABEL16;
X    goto LABEL17;
X    LABEL16:
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL17:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (P1 != P1) goto LABEL18;
X    goto LABEL19;
X    LABEL18:
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL19:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (P1 != P2) goto LABEL20;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL20:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (P1 < P2) goto LABEL21;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL21:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (P2 < P1) goto LABEL22;
X    goto LABEL23;
X    LABEL22:
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL23:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (P1 < P1) goto LABEL24;
X    goto LABEL25;
X    LABEL24:
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL25:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    FA = F1;
X    if (FA == F1) goto LABEL26;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL26:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VA = (P3 & 0xFF);
X    if (VA == V3) goto LABEL27;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL27:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    PA = (V2 & 0xFF);
X    if (PA == P2) goto LABEL28;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL28:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    FA = F1;
X    VA = V2 + V0;
X    PA = (V3 & 0xFF);
X    if (FA == F1) goto LABEL29;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL29:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (VA == V2) goto LABEL30;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL30:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    FA = F1;
X    PA = P2 + P0;
X    VA = (P3 & 0xFF);
X    if (FA == F1) goto LABEL31;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL31:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (PA == P2) goto LABEL32;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL32:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    FA = F1;
X    PA = P3 + P0;
X    VA = V2 + V0;
X    FA = F0;
X    if (VA == V2) goto LABEL33;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL33:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (PA == P3) goto LABEL34;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL34:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    FE = F0;
X    PE = (V0 & 0xFF);
X    VE = V1 + V3;
X    if (VE == V4) goto LABEL35;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL35:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (PE == P0) goto LABEL36;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL36:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (FE == F0) goto LABEL37;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL37:
X/* END SUBROUTINE S. */
X    return;
X    }
X/* BEGIN SUBROUTINE Q. */
Xvoid SubQ(void);
Xvoid SubQ()
X{
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    FA = F0;
X    VA = V0 + V0;
X    PA = P1 + P2;
X    if (FA == F0) goto LABEL41;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL41:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (VA == V0) goto LABEL42;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL42:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (PA == P3) goto LABEL43;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL43:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VA = V0 + V0;
X    FA = F0;
X    PA = P1 - P3;
X    if (FA == F0) goto LABEL44;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL44:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (VA == V0) goto LABEL45;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL45:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    PA = PA + P3;
X    if (PA == P1) goto LABEL46;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL46:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    PA = P0 + P0;
X    FA = F0;
X    VA = V1 - V3;
X    if (FA == F0) goto LABEL47;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL47:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (PA == P0) goto LABEL48;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL48:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VA = VA + V3;
X    if (VA == V1) goto LABEL49;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL49:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VA = V0 + V0;
X    FA = F0;
X    PA = P3 * P3;
X    PD = (V9 & 0xFF);
X    if (PA == PD) goto LABEL50;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL50:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (VA == V0) goto LABEL51;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL51:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (FA == F0) goto LABEL52;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL52:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VC = V0 + V0;
X    FC = F0;
X    PA = (V6 & 0xFF);
X    PC = PA / P2;
X    if (PC == P3) goto LABEL53;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL53:
X/* END SUBROUTINE Q. */
X    return;
X    }
X/* BEGIN SUBROUTINE R. */
Xvoid SubR(void);
Xvoid SubR()
X{
X    SubQ();
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (VC == V0) goto LABEL54;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL54:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (VC == V0) goto LABEL55;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL55:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    PA = (V7 & 0xFF);
X    PC = PA / P2;
X    if (PC == P3) goto LABEL56;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL56:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    PA = (V7 & 0xFF);
X    PA = P0 - PA;
X    PC = PA / P2;
X    PC = P0 - PC;
X    if (PC == P3) goto LABEL57;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL57:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    PA = (V7 & 0xFF);
X    PD = P0 - P2;
X    PC = PA / PD;
X    PC = P0 - PC;
X    if (PC == P3) goto LABEL58;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL58:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    PA = (V7 & 0xFF);
X    PA = P0 - PA;
X    PD = P0 - P2;
X    PC = PA / PD;
X    if (PC == P3) goto LABEL59;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL59:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    PD = (V4 & 0xFF);
X    PA = P0 - P2;
X    PC = P2 * PA;
X    PC = P0 - PC;
X    if (PC == PD) goto LABEL60;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL60:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    PD = (V4 & 0xFF);
X    PA = P0 - P2;
X    PC = PA * P2;
X    PC = P0 - PC;
X    if (PC == PD) goto LABEL61;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL61:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    PD = (V4 & 0xFF);
X    PA = P0 - P2;
X    PC = PA * PA;
X    if (PC == PD) goto LABEL62;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL62:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VC = V0 - V6;
X    if (VC == V6) goto LABEL63;
X    goto LABEL64;
X    LABEL63:
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL64:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (VC != V6) goto LABEL65;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL65:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    PC = P0 - P3;
X    if (PC == P3) goto LABEL66;
X    goto LABEL67;
X    LABEL66:
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL67:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (PC != P3) goto LABEL68;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL68:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (PC < P3) goto LABEL69;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL69:
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (P3 < PC) goto LABEL70;
X    goto LABEL71;
X    LABEL70:
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL71:
X/* END SUBROUTINE R. */
X    return;
X    }
X/* BEGIN MAIN ROUTINE. */
Xshort DoIt()
X{
X    F0 = 0; F1 = 1; F2 = 2; F3 = 3;
X    V0 = 0; V1 = 1; V2 = 2; V3 = 3; V4 = 4;
X    V5 = 5; V6 = 6; V7 = 7; V8 = 8; V9 = 9;
X    P0 = 0; P1 = 1; P2 = 2; P3 = 3; P4 = 4;
X    P5 = 5; P6 = 10;
X    P8 = ((long) MEM);
X    P9 = ((long) MEM) + sizeof(long) * MEMSIZ;
X    MStartIO(PLargcnt, PLarglist);
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    SubF();
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    goto LABEL02;
X    LABEL01:
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL02:
X    SubS();
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VD = MGetChar();
X    VE = MGetChar();
X    VF = MGetChar();
X    VG = MGetChar();
X    VH = MGetChar();
X    VI = MGetChar();
X    VJ = MGetChar();
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (VJ == V0) goto LABEL38;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL38:
X    VD = MPutChar(VD);
X    VE = MPutChar(VE);
X    VF = MPutChar(VF);
X    VI = MPutChar(VI);
X    VH = MPutChar(VH);
X    VH = MPutChar(VH);
X    VG = MPutChar(VG);
X    VJ = MPutChar(VJ);
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VD = MGetChar();
X    VE = MGetChar();
X    VF = MGetChar();
X    VG = MGetChar();
X    VH = MGetChar();
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (VH == V0) goto LABEL39;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL39:
X    VD = MPutChar(VD);
X    VE = MPutChar(VE);
X    VF = MPutChar(VF);
X    VJ = VG + V0;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VJ = VG + V1;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VJ = VG + V2;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VJ = VG + V3;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VJ = VG + V4;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VJ = VG + V5;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VJ = VG + V6;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VJ = VG + V7;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VJ = VG + V8;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VJ = VG + V9;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VH = MPutChar(VH);
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VD = MGetChar();
X    VG = MGetChar();
X    VE = MGetChar();
X    VF = MGetChar();
X    VG = MGetChar();
X    VH = MGetChar();
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    if (VH == V0) goto LABEL40;
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    LABEL40:
X    VD = MPutChar(VD);
X    VG = MPutChar(VG);
X    VE = MPutChar(VE);
X    VF = MPutChar(VF);
X    VI = (P0 & 0xFF);
X    VJ = VG + VI;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VI = (P1 & 0xFF);
X    VJ = VG + VI;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VI = (P2 & 0xFF);
X    VJ = VG + VI;
X    VJ = MPutChar(VJ);
X    VF = MPutChar(VF);
X    VI = (P3 & 0xFF);
X    VJ = VG + VI;
X    VJ = MPutChar(VJ);
X    VH = MPutChar(VH);
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X    SubR();
X    VB = V1 + V0;
X    FB = MGetBuff(VB);
X    VW = V2 + V0;
X    FW = MPutBuff(VW);
X/* END MAIN ROUTINE. */
X    MStopIO();
X    return 0;
X    }
X/* END PROGRAM. */
X/* End of generated file */
END_OF_FILE
if test 13523 -ne `wc -c <'LOME/SCMTestC.out'`; then
    echo shar: \"'LOME/SCMTestC.out'\" unpacked with wrong size!
fi
# end of 'LOME/SCMTestC.out'
fi
if test -f 'PPL/PPLAmiga.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PPL/PPLAmiga.h'\"
else
echo shar: Extracting \"'PPL/PPLAmiga.h'\" \(16566 characters\)
sed "s/^X//" >'PPL/PPLAmiga.h' <<'END_OF_FILE'
X/*
X * PPLAmiga.h
X * Portable Programmer's Library General Host Parameters
X * Copyright 1988,1990 Darren New.  All Rights Reserved.
X * Amiga version
X *
X * Started 19-Feb-88 DHN
X * LastMod 05-jan-90 DHN
X *
X */
X
X#ifndef PPL_h
X#define PPL_h
X
X
X/*****************************************************************
X *
X * This file gets included into every PPL source file.
X * This one of the few include files that the host programmer
X * should be changing.
X *
X */
X
X/*****************************************************************
X *
X * Include whatever files you need here to supply
X *  strlen, strcpy, strncmp, strcmp, strchr
X *  toupper, tolower
X *  isalnum, isaplha, isdigit, isupper, islower, isspace
X *  fault, assert, bomb
X *
X *  Note that assert can be compiled out, fault can always return
X *  false, and bomb can call PLExit(PLsev_bomb).
X *
X */
X
X#include "exec/types.h"
X#include "libraries/dos.h"
X#include "stdlib.h"
X#include "string.h"
X#include "ctype.h"
X
X#undef TRUE
X#undef FALSE
X#undef BITSPERLONG
X#undef NULL
X
X#define USE_ASSERT 1
X
X#include "Fault.h"
X
X/*****************************************************************
X *
X * These parameters describe your C compiler:
X *
X */
X
X/* First, some raw, low-level information advantage of which should
X * probably never be taken.
X */
X#define BITSPERCHAR    8
X#define BITSPERSHORT  16
X#define BITSPERLONG   32
X#define BITSPERFLOAT  32
X#define BITSPERDOUBLE 64
X
X/* To account for character-set differences, this macro (or function)
X * must accept a digit and return an integer from 0 to 9.
X * The other macro goes the other direction.
X */
X#define PLToInt(a) (a - '0')
X#define PLToDig(a) (a + '0')
X
X/* Set this to the most efficient small integer value for your compiler.
X * You may include "register" and "unsigned" without ill effect.
X * Vars of this type are never passed as parameters and are usually
X * loop indicies or array subscripts.
X */
Xtypedef unsigned short inx;
X
X/* Set this to a "generic pointer" (either void * or char *).
X */
Xtypedef void * ptr;
X
X/* Set this to a "boolean". This is not used for arrays, so faster
X * over smaller is better. Do not make it "register".
X */
Xtypedef short bool;
X
X/* Set this to the proper value for your computer.
X */
X#ifndef NULL
X#define NULL ((ptr)0)
X#endif
X
X/* Set this to the size of the longest legal file name under the native
X * operating system calls.
X * Note that this MUST be declared as a LONG literal.
X */
X#define BIGFNAME 512L
X
X/* Set this to the largest piece of contiguous memory that can be
X * allocated and accessed. I.e., this is the sizeof the largest
X * character array that PLallocmem can return. E.g., IBM PC = 64K.
X * This limits PLfillmem, PLallocmem, and other functions that
X * access large chunks of contiguous memory.
X * Note that this MUST be declared as a LONG literal.
X */
X#define BIGMEM 65530L
X
X/* Set this to the largest piece of contiguous I/O request that
X * can be I/O'ed in one call. E.g., IBM PC = 31K.
X * Note that this MUST be declared as a LONG literal.
X */
X#define BIGIO 32760L
X
X/* Set this to the smaller of BIGMEM and BIGIO
X */
X#define BIGBUF BIGIO
X
X/* Set this to the longest line reasonably returnable by the
X * line-oriented I/O functions. I.e., this is the size of buffers
X * allocated for GetLine and so on. This needn't be bigger that about 250.
X */
X#define BIGLINE 250
X
X/* Set this to 1 if you have structure assignment.
X * Set this to 0 to use PLmemcpy.
X * (note that PPL never passes structures by value)
X */
X#define STRUCT_ASSIGN 1
X
X/* Set this to 1 if you have prototype arguments for external functions.
X * Set this to 0 to declare functions without prototype arguments.
X */
X#define PROTOTYPES 1
X
X/* Set this to 1 if you have ANSI-style function definition headings.
X * Set this to 0 if you have PCC-style	function definition headings.
X */
X#define ANSIHEADERS 1
X
X/* Set this to 1 if HIDDEN functions need prototype declarations.
X * Set this to 0 if you don't want them.
X */
X#define HIDPROTS 1
X
X/* Set this to 1 if you want to check arguments to library functions.
X * Set this to 0 once your programs are debugged.
X */
X#define CHKARGS 1
X
X
X
X
X/*****************************************************************
X *
X * These parameters are utility macros. Do not change them!
X *
X */
Xtypedef char * str;	/* '\0' terminated string */
X#define EOS '\0'
X
X#define loop while(1)   /* like other langs */
X
X#define HIDDEN static	/* hidden objects go away (can be changed to comment for stupid debuggers) */
X
X/* Use this macro to assign structures */
X#if STRUCT_ASSIGN
X#define SASGN(a, b) (a = b)
X#else
X#define SASGN(a, b) PLCopyMem(&a, &b, sizeof(a))
X#endif
X
X/* Use this macro to declare arguments on function declarations */
X#if PROTOTYPES
X#define ARGS(a) a
X#else
X#define ARGS(a) ()
X#endif
X
X/* Use this macro to define formals of function definitions */
X#if ANSIHEADERS
X#define ARGS0() ()
X#define ARGS1(a,b) (a b)
X#define ARGS2(a,b,c,d) (a b, c d)
X#define ARGS3(a,b,c,d,e,f) (a b, c d, e f)
X#define ARGS4(a,b,c,d,e,f,g,h) (a b, c d, e f, g h)
X#define ARGS5(a,b,c,d,e,f,g,h,i,j) (a b, c d, e f, g h, i j)
X#define ARGS6(a,b,c,d,e,f,g,h,i,j,k,l) (a b, c d, e f, g h, i j, k l)
X#define ARGS7(a,b,c,d,e,f,g,h,i,j,k,l,m,n) (a b, c d, e f, g h, i j, k l, m n)
X#define ARGS8(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) (a b, c d, e f, g h, i j, k l, m n, o p)
X#else
X#define ARGS0() ()
X#define ARGS1(a,b) (b)a b;
X#define ARGS2(a,b,c,d) (b,d)a b; c d;
X#define ARGS3(a,b,c,d,e,f) (b,d,f)a b;c d;e f;
X#define ARGS4(a,b,c,d,e,f,g,h) (b,d,f,h)a b;c d;e f;g h;
X#define ARGS5(a,b,c,d,e,f,g,h,i,j) (b,d,f,h,j)a b;c d;e f;g h;i j;
X#define ARGS6(a,b,c,d,e,f,g,h,i,j,k,l) (b,d,f,h,j,l)a b;c d;e f;g h;i j;k l;
X#define ARGS7(a,b,c,d,e,f,g,h,i,j,k,l,m,n) (b,d,f,h,j,l,n)a b;c d;e f;g h;i j;k l;m n;
X#define ARGS8(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) (b,d,f,h,j,l,n,p)a b;c d;e f;g h;i j;k l;m n;o p;
X#endif
X
X/* This allows constant paramters passed to a short formal to by typecast
X * easily. It is kind of like a trailing L on an integer. Use new ANSI
X * stuff instead.
X */
X#define S (short)
X
X#define TRUE ((bool) 1)
X#define FALSE ((bool) 0)
X
X
X/*****************************************************************
X *
X * These declare the startup and termination routines.
X * Do NOT change these!
X *
X */
X
X/* This is to be called by the main() of the host program.
X * It returns the exit severity.
X */
Xextern short DoIt ARGS((void));
X
X/* This is called by the application when an unrecoverable error
X * has occured. The severity is passed as the argument.
X * The host should clean up if possible.
X */
Xextern void PLExit ARGS((short severity));
X
X/* These are the severities:
X */
X#define PLsev_normal	0   /* no error - just exit normally */
X#define PLsev_badarg	1   /* command line arguments bad or wrong config */
X#define PLsev_error	2   /* some other kind of error */
X#define PLsev_userbreak 3   /* user requested unclean interrupt */
X#define PLsev_oores	4   /* out of required resource */
X#define PLsev_nfres	5   /* required resource not found at all */
X#define PLsev_badform	6   /* input or file in wrong format */
X#define PLsev_fault	7   /* user req to not recov from recov error */
X#define PLsev_bomb	8   /* program detected unrecov error */
X#define PLsev_assert	9   /* assertion failed */
X#define PLsev_crash	10  /* program (and probably machine) crashed */
X
X
X/*****************************************************************
X *
X * These declare the memory allocation / access primatives
X *
X */
X
X/* This allocates dynamic memory. The first argument is a LONG
X * specifying how much memory (in bytes) needs to be allocated.
X * The second is an INT containing various flags (two so far).
X * If (flags & PLalloc_die) this will bomb("Out of Memory")
X * if the allocation fails; otherwise it will return NULL if the
X * allocation fails.
X * You will fail the allocation or bomb("Memory request too large")
X * if more memory than BIGMEM is requested. This retains the length
X * for the PLfreemem function.
X * If (flags & PLalloc_zero) this will clear the allocated memory to
X * all binary zeros if the allocation succeeds; otherwise, the memory
X * will be uninitialized.
X */
X#define PLalloc_die  1	/* bomb if out of memory */
X#define PLalloc_zero 2	/* clear new mem to zeros */
Xptr PLAllocMem ARGS((long size, int flags));
X
X/* This frees dynamic memory. The argument is a previously-allocated
X * pointer to memory as returned by PLAllocMem(). The application is
X * responsible for deallocating all memory it allocates before returning
X * normally from DoIt(). If possible, the application should deallocate
X * all memory before calling PLExit. The host programmer may wish to
X * check that memory is freed exactly once.
X */
Xvoid PLFreeMem ARGS((ptr where));
X
X/* This allocates enough memory to hold the given string, then copies
X * the string into that memory. It passes PLalloc_die=true to the
X * PLallocmem call.
X */
Xstr PLStrDup ARGS((str s));
X
X/* This copies memory from src to dest for siz bytes. The host function
X * will handle copying in the correct direction if the areas overlap.
X * This should be as efficient as possible.
X */
Xvoid PLCopyMem ARGS((ptr to, ptr from, long siz));
X
X/* This assigns a constant byte to a region of memory.
X * Again, this should be as efficient as possible.
X */
Xvoid PLFillMem ARGS((ptr where, long siz, char chr));
X
X/* This looks for a specific character within a range of memory.
X * It returns NULL if not found, or a pointer to the matching character
X * if found.
X */
Xptr PLFindMem ARGS((ptr where, long siz, char chr));
X
X
X/*****************************************************************
X *
X * These declare the error routines
X *
X */
X
X/* This is the type of an error value
X */
Xtypedef short PLerr_enum;
X#define PLerr_none	0   /* no error occured */
X#define PLerr_opsysR	1   /* otherwise unknown error - retry */
X#define PLerr_opsysW	2   /* otherwise unknown error - wait then retry */
X#define PLerr_opsysU	3   /* otherwise unknown error - ask user to fix */
X#define PLerr_opsysF	4   /* otherwise unknown error - unrecoverable failure */
X#define PLerr_fault	5   /* program-detected error */
X#define PLerr_eod	6   /* end of data (during read) */
X#define PLerr_oores	7   /* out of some resource (during write/create) */
X#define PLerr_again	8   /* multiple errors occured without being cleared */
X#define PLerr_exist	9   /* access to non-existant item */
X#define PLerr_already	10  /* can't create because item already there */
X#define PLerr_permit	11  /* "owner" disallows that access to you */
X#define PLerr_unsup	12  /* unsuported in this instance */
X#define PLerr_busy	13  /* item exits but is busy */
X#define PLerr_param	14  /* argument to function cannot be parsed */
X#define PLerr_notyet	15  /* something not yet implemented */
X#define PLerr_never	16  /* something that cannot be implemented */
X#define PLerr_badarg	17  /* argument to function semantically invalid */
X#define PLerr_overflow	18  /* overflow error */
X#define PLerr_underflow 19  /* underflow error */
X#define PLerr_userbreak 20  /* user break or interrupted system call */
X#define PLerr_last	21  /* largest error number + 1 */
X
X/* The PL error number */
Xextern PLerr_enum PLerr;
X
X/* The OS error number (whatever you need, if anything) */
Xextern int OSerr;   /* may be changed by HostPgrmr */
X
X/* The file and line of the last error (mainly for debugging) */
Xextern str PLerr_file;
Xextern long PLerr_line;
X
X/* This sets the error number.
X */
X#ifdef DEBUG
X#define PLErrSet(e) ((PLerr_file=__FILE__),(PLerr_line=__LINE__),\
XPLerr=((PLerr!=PLerr_none)?PLerr_again:(e)))
X#else
X#define PLErrSet(e) (PLerr = ((PLerr != PLerr_none) ? PLerr_again : (e)))
X#endif
X
X/* This clears the error number.
X * (This may be a void function if your compiler doesn't like empty args)
X */
X#define PLErrClr() (OSerr=0,PLerr=PLerr_none)
X
X/* This returns a string, suitable for user viewing, describing the
X * most recent error as indicated by PLerr.
X * The string should be static.
X */
Xstr PLErrText ARGS((void));
X
X/* This returns a string, suitable for user viewing, describing the
X * most recent error in the HOST terminology. Used when PLopsys?
X * returned or for additional information.
X * The string should be static.
X */
Xstr PLOSErrText ARGS((void));
X
X/*****************************************************************
X *
X * These declare the status message routines
X *   (Note that delay and beep are included here only due to their
X *    typical usage.)
X *
X */
X
X/* This displays a status message for utilities. The display should
X * be suppressed if PLstatuslevel <= level. PLstatuslevel should be
X * initialized before calling DoIt(), and is intended to be
X * changable by the user. It should default to a value of 6 (giving
X * status messages in the range 0-6).
X * level == 5 should be used for normal status messages, including
X * initial copyright messages, final summaries, and so on;
X * level == 6 should be used for progress reports;
X * level == 7 should be used to echo parameters; level == 3 should be
X * use for warnings and level == 2 should be used for non-fatal errors.
X * Obviously, use level == 0 (which can't be disabled) for fatal errors.
X */
Xextern short PLstatuslevel;
Xvoid PLStatus ARGS((short level, str message));
X
X/* This function will delay for the indicated number of seconds in the
X * most efficient way possible. (Of course, on a single-tasking
X * machine, you may wait as inefficiently as you like.)
X */
Xextern void PLDelay ARGS((short secs));
X
X/* This function is used to draw the user's attention to the computer.
X * If passed a zero, it should make a quiet, pleasant beep or chime,
X * or simply flash the screen if possible. This option will be used
X * to indicate that a minor error (like an illegal keystroke) has
X * occured.
X * If passed a one, it should make an audible tone, loud enough to be
X * heard even if not listened for. This should be used to indicate that
X * a lengthy process (during which the user has started working on
X * back paperwork or something) has completed. It should never be used
X * to indicate that an error has occured.
X * If passed a two or greater, it should give a rude audible indicator
X * of problems. This will be used only when the user is about to do
X * something that it is quite unlikely he wants to do.
X */
Xextern void PLBeep ARGS((short how));
X
X
X/*****************************************************************
X *
X * These declare basic standard input/output functions
X *
X * Do not use these in sophisticated applications.
X * Do not use these in place of the PLstatus routine.
X */
X
X
X/* This should return an integer from 0 to 255, representing the ASCII
X * of the next character read from the "standard input" or -1 for EOF or
X * -2 for some other I/O error. Newline must be returned as '\n', and
X * space as ' ' and tab as '\t'. It is assumed that redirection might
X * occur on this stream -- see also PLresetinput().
X * This may be changed to a macro by the host programmer.
X */
Xshort PLGetChar ARGS((void));
X
X/* This should send the indicated character to the "standard output".
X * The output characters may include '\n' for newline. It is assumed
X * that redirection may occur on this stream -- see also PLresetoutput().
X * This may be changed to a macro by the host programmer.
X */
Xvoid PLPutChar ARGS((short ch));
X
X/* When this is called, further calls to PLgetchar() should take
X * their input from the user terminal.
X * This may be changed to a macro by the host programmer.
X */
Xvoid PLResetInput ARGS((void));
X
X/* When this is called, further calls to PLputchar() should send
X * their output to the user terminal.
X * This may be changed to a macro by the host programmer.
X */
Xvoid PLResetOutput ARGS((void));
X
X	/* For testing only! Do not call printf except while debugging! */
X	extern void printf(char *, ...);
X
X
X/*****************************************************************
X *
X * These declare command-line argument functions
X *
X */
X
X/* This gives the name of the executable file, if available.
X * Otherwise, this will be NULL.
X */
Xextern str PLcmdname;
X
X/* This gives the host-syntax filename for the executable file now running,
X * if available.
X * Otherwise, this will be NULL.
X */
Xextern str PLcmdfile;
X
X/* This tells how many command-line arguments there were, EXCLUDING
X * the command name.
X */
Xextern short PLargcnt;
X
X/* This is the array of command-line argument strings, EXCLUDING the
X * command name.
X */
Xextern str PLarglist[];
X
X/* These are the flags describing the command-line parameters.
X */
Xextern long PLargflags;
X#define PLaf_hostwc 1	/* use host wildcards instead of portable wc's */
X#define PLaf_hostex 2	/* host already has expanded wildcards */
X
X
X
X#endif /* PPL_h */
X
END_OF_FILE
if test 16566 -ne `wc -c <'PPL/PPLAmiga.h'`; then
    echo shar: \"'PPL/PPLAmiga.h'\" unpacked with wrong size!
fi
# end of 'PPL/PPLAmiga.h'
fi
echo shar: End of archive 7 \(of 9\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 9 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
--- Darren New --- Grad Student --- CIS --- Univ. of Delaware ---

exit 0 # Just in case...
-- 
Please send comp.sources.unix-related mail to rsalz@uunet.uu.net.
Use a domain-based address or give alternate paths, or you may lose out.
