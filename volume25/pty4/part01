Newsgroups: comp.sources.unix
From: brnstnd@nyu.edu (Dan Bernstein)
Subject: v25i127: Generalized interface to pseudo-tty devices, Part01/09
Message-ID: <1992Feb19.220452.29446@PA.dec.com>
Date: Wed, 19 Feb 92 22:04:52 GMT
Approved: vixie@pa.dec.com

Submitted-By: brnstnd@nyu.edu (Dan Bernstein)
Posting-Number: Volume 25, Issue 127
Archive-Name: pty4/part01

[ What can I say?  It slices, it dices, it washes dishes, it walks the dog.
  It "just works", meaning that if you follow the directions you'll get a
  working package without any pulling of hair or gnashing of teeth or other
  standard porting activities.  Here's BLURB, to convince you that it's worth
  unpacking and installing.					--vix ]

pty is meant as the sole interface between pseudo-terminals and the rest
of the system. Rich Salz said of pty 3.0: ``This is the Ginsu knife (it
slices, it dices, it never rusts) that Dan has been talking about in
comp.unix.wizards/internals for some time now. It is a mind-blower.''
But I just couldn't leave well enough alone, so here's pty 4.0, a vastly
improved rewrite of the entire package. A taste of what it has to offer:

* Improved security - pty 3.0 offered tty security ahead of its time---
several months afterwards, Sun released a ``critical'' security patch
with essentially the same security tests. Now pty 4.0 offers proven
security. Although you can install and use the package without
privileges, system administrators can install pty 4.0 so that it
_guarantees_ that nobody else has access to your tty. I'm offering a
cash reward for anyone who can subvert these guarantees.

* Session management - If you run your shell under pty, and the
connection is hung up, you can log in again and reconnect. The session
management model is extremely simple---it has just three primitives---
yet powerful enough to accomplish tricky tasks, such as recording the
output from a process after the process has started. A paper in the
package, ``An introduction to session management,'' leads even novice
users through competent use of session management commands.

* Automatic installation - pty 4.0 comes with a completely automated
configure/compile/install/verify-configuration setup. It will configure
itself properly for most popular systems without human input.

* Modularity - When I say that pty is meant as the sole interface to
pseudo-terminals, I mean it! pty doesn't get in the way of direct,
efficient pseudo-terminal I/O. So you can use it as a component of other
programs which add input line editing, virtual screen support, or other
fancy features. pty handles just one job, and handles it so cleanly that
you'll never have to duplicate pseudo-terminal code in another program.

* Free utilities - pty 4.0 comes with even more useful utilities than
pty 3.0. It includes ten improved clones of standard utilities, notably
a version of ``script'' which makes a proper utmp entry; and thirty new
tools ranging from administrative helpers to ``tscript'', which records
an interactive session _including the timing between characters_. Power
users will appreciate ``nobuf'', which uses pty to transparently turn
off stdio buffering in any program.

* Free libraries - The pty package comes with several of my favorite
libraries: env, fmt, getopt, radixsort, ralloc, scan, sigdfl, sigsched,
sod, timer, username. You can use all of these for your own programs.

* POSIX support - pty 4.0 works without trouble under popular POSIX/BSD
systems, including Ultrix 4.1 and SunOS 4.1.1. All the job control
features have been adapted to work with POSIX job control. pty should
also be included with BSD 4.4.

* Detailed documentation - Let your worries about incomplete program
documentation be over. The pty package includes more than five thousand
lines of documentation: forty quick-reference man pages; papers on
controlling ttys, job control, session management, and user log files;
extensive notes on pty internals and porting issues; and more.

Okay, enough hype. What's pty good for? Once upon a time nethack would,
if you were lucky, produce characters with both a ring of polymorph and
a ring of polymorph control. I wanted to run nethack inside a script
which would keep rerolling characters until it saw that combination.
(Playing by the rules was never my forte.) Unfortunately, nethack didn't
like having its input and output redirected. So I wrote the first
versions of pty. ``pty nethack'' worked just like ``nethack'' but could
be invoked in the middle of a pipe inside a script. As the years went
by, pty became somewhat more powerful and flexible, but its basic
function has always remained the same: to run programs, especially
``interactive'' programs, under a pseudo-tty. Despite this single-minded
attitude, pty has wormed its way into the solutions to dozens of
problems, ranging from buffer control to automating telnet scripts to
making rlogind secure. Pseudo-terminal code seems to spring up
everywhere; pty is your weapon to slash that code to a single line.
Enjoy!

	---Dan Bernstein, brnstnd@nyu.edu

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 9)."
# Contents:  BINARIES MANIFEST OBJECTS README UNSHAR.HDR argv0.1
#   argv0.c biff.c checkptys.8 config config/devmty.h config/devsty.h
#   config/fdsettrouble.h config/genericptr.h config/posix.h
#   config/ptybin.h config/ptydir.h config/ptyext.h config/ptygroup.h
#   config/ptylongname.h config/ptymodes.h config/ptyopts.h
#   config/sessconnfile.h config/sessfile.h config/sysv.h
#   config/ttyopts.h config/utmpfile.h config/wtmpfile.h ctrlv.c env.h
#   excloff.c exclon.1 exclon.c fmt.h getopt.h getoptquiet.h lock.1
#   mesg.1 mesg.c nobuf.sh ptycomm.h ptyerr.h ptyget.h ptylogs.h
#   ptymaster.h ptymisc.h ptysecure.h ptysigler.h ptyslave.h
#   ptytexts.h radixsort.h ralloc.h scan.h sclogrotate.sh scnowinit.sh
#   script.sh script.tidy.1 script.tidy.sh sess.sh sessconnlog.h
#   sesslist.1 sesslog.h sessmenu.1 sessname.1 sessnowinit.sh
#   sessrotate.sh sigdfl.h sigsched.h sod.h talkacros.7 timer.h
#   tiocsti.1 tiocsti.c tplay.1 tscript.sh tty.1 tty.c ttydetach.1
#   ttyprotect.sh username.h users.1 utmpinit.8 utmpinit.c waitfor.1
#   waitfor.c wall.1 whoami.1 whoami.c wtmprotate.8 wtmprotate.sh
# Wrapped by vixie@cognition.pa.dec.com on Wed Feb 19 13:35:00 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'BINARIES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BINARIES'\"
else
echo shar: Extracting \"'BINARIES'\" \(342 characters\)
sed "s/^X//" >'BINARIES' <<'END_OF_FILE'
CHECKCONF
INSTALL
argv0
biff
checkptys
condom
ctrlv
disconnect
exclon
excloff
lock
mesg
nobuf
pty
reconnect
sclogrotate
scnowinit
script
script.tidy
sess
sesskill
sesslist
sessmenu
sessname
sessnowinit
sessrotate
sesswhere
sesswho
tiocsti
tplay
trecord
tscript
tty
ttydetach
ttyprotect
users
utmpinit
waitfor
wall
who
whoami
write
wtmprotate
END_OF_FILE
if test 342 -ne `wc -c <'BINARIES'`; then
    echo shar: \"'BINARIES'\" unpacked with wrong size!
fi
# end of 'BINARIES'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(5490 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X BINARIES                   1	
X BLURB                      4	
X CALLS                      6	
X CHANGES                    3	
X CHECKCONF.c                3	
X COPYRIGHT                  2	
X CTTYS.draft1               6	
X FILES                      2	
X FORMLETTER                 2	
X IMPACT                     3	
X INSTALL.c                  4	
X JOBCTRL.draft3             9	
X MANIFEST                   1	
X Makefile                   6	
X NEW                        5	
X NOTES                      4	
X OBJECTS                    1	
X QUESTIONS                  5	
X README                     1	
X SECURITY                   4	
X SESS.draft2                7	
X SYSCONF                    4	
X TESTS                      4	
X ULOGS.draft1               5	
X UNSHAR.HDR                 1	
X WTF                        3	
X argv0.1                    1	
X argv0.c                    1	
X biff.1                     2	
X biff.c                     1	
X checkptys.8                1	
X checkptys.c                4	
X condom.1                   2	
X config                     1	
X config/devmty.h            1	
X config/devsty.h            1	
X config/fdsettrouble.h      1	
X config/genericptr.h        1	
X config/posix.h             1	
X config/ptybin.h            1	
X config/ptydir.h            1	
X config/ptyext.h            1	
X config/ptygroup.h          1	
X config/ptylongname.h       1	
X config/ptymodes.h          1	
X config/ptyopts.h           1	
X config/sessconnfile.h      1	
X config/sessfile.h          1	
X config/sysv.h              1	
X config/ttyopts.h           1	
X config/utmpfile.h          1	
X config/wtmpfile.h          1	
X ctrlv.c                    1	
X disconnect.1               2	
X disconnect.c               2	
X env.c                      4	
X env.h                      1	
X excloff.c                  1	
X exclon.1                   1	
X exclon.c                   1	
X fmt.c                      4	
X fmt.h                      1	
X getopt.c                   3	
X getopt.h                   1	
X getoptquiet.c              2	
X getoptquiet.h              1	
X lock.1                     1	
X lock.c                     2	
X mesg.1                     1	
X mesg.c                     1	
X nobuf.sh                   1	
X pty-basic.1                3	
X pty-opts.1                 6	
X pty.1                      5	
X ptycomm.c                  3	
X ptycomm.h                  1	
X ptyerr.c                   2	
X ptyerr.h                   1	
X ptyget.c                   3	
X ptyget.h                   1	
X ptylogs.c                  2	
X ptylogs.h                  1	
X ptymain.c                  7	
X ptymaster.c                8	
X ptymaster.h                1	
X ptymisc.c                  2	
X ptymisc.h                  1	
X ptysecure.c                5	
X ptysecure.h                1	
X ptysigler.c                5	
X ptysigler.h                1	
X ptyslave.c                 3	
X ptyslave.h                 1	
X ptytexts.c                 3	
X ptytexts.h                 1	
X ptytty.c                   6	
X ptytty.h                   2	
X radixsort.3                3	
X radixsort.c                8	
X radixsort.h                1	
X ralloc.c                   3	
X ralloc.h                   1	
X reconnect.1                2	
X reconnect.c                2	
X scan.c                     4	
X scan.h                     1	
X sclogrotate.sh             1	
X scnowinit.sh               1	
X script.1                   2	
X script.sh                  1	
X script.tidy.1              1	
X script.tidy.sh             1	
X sess.1                     2	
X sess.sh                    1	
X sessconnlog.c              2	
X sessconnlog.h              1	
X sesskill.1                 2	
X sesskill.c                 2	
X sesslist.1                 1	
X sesslist.c                 3	
X sesslog.c                  2	
X sesslog.h                  1	
X sessmenu.1                 1	
X sessmenu.c                 3	
X sessname.1                 1	
X sessname.c                 3	
X sessnowinit.sh             1	
X sessrotate.sh              1	
X sesswhere.1                2	
X sesswhere.c                2	
X sesswho.1                  2	
X sesswho.c                  2	
X sigdfl.3                   2	
X sigdfl.c                   3	
X sigdfl.h                   1	
X sigsched.3                 6	
X sigsched.c                 7	
X sigsched.h                 1	
X sod.h                      1	
X talkacros.7                1	
X timer.c                    5	
X timer.h                    1	
X tiocsti.1                  1	
X tiocsti.c                  1	
X tplay.1                    1	
X tplay.c                    2	
X trecord.1                  2	
X trecord.c                  2	
X tscript.1                  2	
X tscript.sh                 1	
X tty.1                      1	
X tty.c                      1	
X ttydetach.1                1	
X ttydetach.c                2	
X ttydfl.7                   2	
X ttyprotect.sh              1	
X username.c                 2	
X username.h                 1	
X users.1                    1	
X users.c                    2	
X utmpinit.8                 1	
X utmpinit.c                 1	
X waitfor.1                  1	
X waitfor.c                  1	
X wall.1                     1	
X wall.c                     2	
X who.1                      2	
X who.c                      3	
X whoami.1                   1	
X whoami.c                   1	
X write.1                    2	
X write.c                    3	
X wtmprotate.8               1	
X wtmprotate.sh              1	
END_OF_FILE
if test 5490 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'OBJECTS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'OBJECTS'\"
else
echo shar: Extracting \"'OBJECTS'\" \(515 characters\)
sed "s/^X//" >'OBJECTS' <<'END_OF_FILE'
argv0.o
biff.o
checkptys.o
ctrlv.o
disconnect.o
env.o
exclon.o
excloff.o
fmt.o
getopt.o
getoptquiet.o
lock.o
mesg.o
ptycomm.o
ptyerr.o
ptyget.o
ptylogs.o
ptymain.o
ptymaster.o
ptymisc.o
ptysecure.o
ptysigler.o
ptyslave.o
ptytexts.o
ptytty.o
radixsort.o
ralloc.o
reconnect.o
scan.o
sessconnlog.o
sesskill.o
sesslist.o
sesslog.o
sessmenu.o
sessname.o
sesswhere.o
sesswho.o
sigdfl.o
sigsched.o
timer.o
tiocsti.o
tplay.o
trecord.o
tty.o
ttydetach.o
username.o
users.o
utmpinit.o
waitfor.o
wall.o
who.o
whoami.o
write.o
END_OF_FILE
if test 515 -ne `wc -c <'OBJECTS'`; then
    echo shar: \"'OBJECTS'\" unpacked with wrong size!
fi
# end of 'OBJECTS'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(4710 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
pty version 4.0, February 9, 1992.
Copyright (c) 1992, Daniel J. Bernstein.
All rights reserved.
X
X0. Read WTF if you want to know what all these files are for.
X1. Run SYSCONF. Check the bottom of README for any notes relevant to
X   your system.
X2. Make and run CHECKCONF. Edit config/* if necessary. If you don't have
X   privileges, make sure to change config/ptybin.h, config/ptydir.h, and
X   config/sess*.h. If you make any changes to config/*.h, you may want
X   to make and run CHECKCONF again. (If you don't have privileges, you
X   may also want to change flagxonlysecure = 0 to flagxonlysecure = -1
X   in ptymain.c line 36; this will eliminate a warning message each time
X   you use pty.)
X3. Make.
X4. Make INSTALL. (This doesn't actually install pty; it only makes the
X   INSTALL program, which you run in step 7.)
X5. If you have privileges, and you don't have a tty group (group 4),
X   make one.
X6. If you have privileges, and you want to run pty as its own uid rather
X   than root, make a pty uid.
X7. As root, run INSTALL, or ``INSTALL root'' if pty should run as root.
X   If you don't have privileges, run INSTALL anyway, and don't worry
X   about the error messages. Tricks: yes skip | ./INSTALL to see all the
X   steps of installation without executing any; yes ok | ./INSTALL to do
X   complete installation without having to confirm each step.
X8. Change /dev/tty* to be owned by pty if (1) pty isn't running as root
X   but (2) you still want to take advantage of pty's security features.
X   (If you want, you can chown only some of the ttys---tty[t-z]*, say.
X   Then pty will stick to those. In this case you should probably edit
X   config/ptyext.h to match.) Also change /dev/pty* to be owner pty and
X   mode 0600 if you want to prevent denial of service attacks; keep in
X   mind that this will stop valid non-root programs from opening ttys,
X   and that it will not close the dozens of other denial of service
X   attacks on your machine. (You may want to chmod and chown only a few
X   of the ptys, to keep them free for pty just in case.)
X9. If you want, invoke wtmprotate, sessrotate, or sclogrotate from your
X   daily, weekly, or monthly cron scripts. (wtmprotate may already be
X   handled by your vendor's scripts.) Also invoke utmpinit, sessnowinit,
X   and scnowinit from /etc/rc.local. Don't worry about these if you
X   don't have privileges.
X10. Run checkptys. If you want, arrange to have checkptys run
X    periodically by cron.
X11. If you want to make sure that pty works, look through TESTS and see
X    whether your setup works the same way.
X12. Fill out FORMLETTER and send it to me.
X
Thanks to Scott Schwartz for his extensive comments; Paul Graham for
utmpinit and for bug reports; Eliot Moss for all his work with pty 3.0,
much of which inspired changes in pty 4.0; Maarten Litmaath for mtty;
Seth Robertson for all his help; Keith Waclena for some incisive
comments on pty 3.0's configuration scripts; Larry McVoy for admitting
he was wrong about POSIX; Kartik Subbarao and Icarus Sparry for testing;
and the cast of thousands for feature requests and suggestions. Thanks
also to Dave Curry for checking pty's security.
X
Probably the best documentation to start with is SESS.draft2. Then try
pty-basic.1, then pty.1, then pty-opts.1. pty can do a lot of stuff---
don't expect to absorb it all at once.
X
pty is known to work in at least one configuration on each of the
following machines:
X
X  Sun 4/280, SunOS 4.0.3
X    note that because of an OS bug (fixed in SunOS 4.1), pty -t will
X    fail from non-job-control shells (like sh) unless pty runs as root
X  Sun 4/490, SunOS 4.1.1
X    tested by KS
X  Sun 3/160, SunOS 4.1.1
X    thanks to Seth Robertson
X  Sun 3/50, SunOS 4.1.1
X  Sun SLC, SunOS 4.1.1
X    tested by IS
X  VAX 8600, BSD 4.3+NFS (Mt. Xinu)
X  DECStation 5400, Ultrix 4.1 (Rev. 52)
X    must add -YPOSIX -DPOSIX to CC in Makefile
X  DECStation 5820, Ultrix 4.1 (Rev. 200)
X    must add -YPOSIX -DPOSIX to CC in Makefile
X
Other notes for the future:
X
X  Convex UNIX 9.0
X    must add -pcc -DPASS8=0 -DEXTB=15 to CC in Makefile; fd passing has
X    a very weird bug, need to look at it in depth
X  BSD 4.4
X    seems to work with the new fd passing system, but the machine
X    crashes; various CSRG/BSD folks are trying to find the kernel bug
X  SVR4
X    three people working on the port
X  AIX
X    two people working on the port
X  IRIS (which?)
X    must add -D_BSD_COMPAT -DIRIS_UGH_PTYS to CC in Makefile; must add
X    -lbsd to PTYLIBS in Makefile; must define TTY_TERMIO in
X    config/ttyopts.h; must define SYSV in config/sysv.h
X
X``Bizarre uses for pty... My favorite is: pty -0 jive | pty fn. Fn is the
client for a networked chat system. The result is a killer. :-)'' ---Sean Casey
END_OF_FILE
if test 4710 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'UNSHAR.HDR' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'UNSHAR.HDR'\"
else
echo shar: Extracting \"'UNSHAR.HDR'\" \(0 characters\)
sed "s/^X//" >'UNSHAR.HDR' <<'END_OF_FILE'
END_OF_FILE
if test 0 -ne `wc -c <'UNSHAR.HDR'`; then
    echo shar: \"'UNSHAR.HDR'\" unpacked with wrong size!
fi
# end of 'UNSHAR.HDR'
fi
if test -f 'argv0.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'argv0.1'\"
else
echo shar: Extracting \"'argv0.1'\" \(605 characters\)
sed "s/^X//" >'argv0.1' <<'END_OF_FILE'
X.TH argv0 1
X.SH NAME
argv0 \- run a program with a specified zeroth argument
X.SH SYNOPSIS
X.B argv0
X.I realname
X.I program
X[
X.I arg ...
X]
X.SH DESCRIPTION
X.B argv0
runs
the program stored as
X.I realname
on disk,
with the given
arguments.
It sets the zeroth argument of
the program to
X.I program.
X.SH EXAMPLES
X.EX
argv0 /bin/csh -bin/csh
X.EE
X
Run the shell with a hyphen as its first name.
This is how
X.B login(1)
runs shells;
X.B csh
will think it is a login shell
and behave accordingly.
X
X.EX
argv0 sendmail mailq
X.EE
X
Run
X.B sendmail
with a zeroth argument of
X.B mailq.
X.SH "SEE ALSO"
execve(2),
execvp(3)
END_OF_FILE
if test 605 -ne `wc -c <'argv0.1'`; then
    echo shar: \"'argv0.1'\" unpacked with wrong size!
fi
# end of 'argv0.1'
fi
if test -f 'argv0.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'argv0.c'\"
else
echo shar: Extracting \"'argv0.c'\" \(241 characters\)
sed "s/^X//" >'argv0.c' <<'END_OF_FILE'
X#include <stdio.h>
X
main(argc,argv)
int argc;
char *argv[];
X{
X if (argc < 3)
X  {
X   fputs("Usage: argv0 realname program [ arg ... ]\n",stderr);
X   exit(1);
X  }
X execvp(argv[1],argv + 2);
X perror("argv0: fatal: cannot execute");
X exit(4);
X}
END_OF_FILE
if test 241 -ne `wc -c <'argv0.c'`; then
    echo shar: \"'argv0.c'\" unpacked with wrong size!
fi
# end of 'argv0.c'
fi
if test -f 'biff.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'biff.c'\"
else
echo shar: Extracting \"'biff.c'\" \(599 characters\)
sed "s/^X//" >'biff.c' <<'END_OF_FILE'
X/* Public domain. */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <stdio.h>
X
X#define BIFFBIT 0100
X
main(argc,argv)
int argc;
char *argv[];
X{
X struct stat st;
X
X if (fstat(0,&st) == -1)
X   exit(2); /* XXX */
X
X if (argc == 1)
X   if (st.st_mode & BIFFBIT)
X     printf("is y\n");
X   else
X     printf("is n\n");
X else
X   switch(argv[1][0])
X    {
X     case 'y':
X       fchmod(0,(int) (st.st_mode | BIFFBIT));
X       break;
X     case 'n':
X       fchmod(0,(int) (st.st_mode & ~BIFFBIT));
X       break;
X     default:
X       fprintf(stderr,"usage: biff [y] [n]\n");
X       exit(2);
X    }
X exit(0);
X}
END_OF_FILE
if test 599 -ne `wc -c <'biff.c'`; then
    echo shar: \"'biff.c'\" unpacked with wrong size!
fi
# end of 'biff.c'
fi
if test -f 'checkptys.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'checkptys.8'\"
else
echo shar: Extracting \"'checkptys.8'\" \(525 characters\)
sed "s/^X//" >'checkptys.8' <<'END_OF_FILE'
X.TH checkptys 8
X.SH NAME
checkptys \- check pseudo-terminal use and pty installation
X.SH SYNOPSIS
X.B checkptys
X.SH DESCRIPTION
X.B checkptys
produces a report on the entire pseudo-terminal system,
including users currently logged on,
the protection of special files such as
X/etc/utmp,
and the setup of the
X.B pty
package.
X
It is assumed that
X.B checkptys
will be run with the same effective uid as
X.B pty.
You may want to run it from the daily cron script.
X.SH BUGS
This man page is woefully incomplete.
X.SH "SEE ALSO"
pty(1)
END_OF_FILE
if test 525 -ne `wc -c <'checkptys.8'`; then
    echo shar: \"'checkptys.8'\" unpacked with wrong size!
fi
# end of 'checkptys.8'
fi
if test ! -d 'config' ; then
    echo shar: Creating directory \"'config'\"
    mkdir 'config'
fi
if test -f 'config/devmty.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/devmty.h'\"
else
echo shar: Extracting \"'config/devmty.h'\" \(148 characters\)
sed "s/^X//" >'config/devmty.h' <<'END_OF_FILE'
X#ifndef CONFIG_DEVMTY_H
X#define CONFIG_DEVMTY_H
X
X#define DEVMTY "/dev/pty"
X
X/* DEVMTY is the prefix for all master sides of pseudo-ttys. */
X
X#endif
END_OF_FILE
if test 148 -ne `wc -c <'config/devmty.h'`; then
    echo shar: \"'config/devmty.h'\" unpacked with wrong size!
fi
# end of 'config/devmty.h'
fi
if test -f 'config/devsty.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/devsty.h'\"
else
echo shar: Extracting \"'config/devsty.h'\" \(142 characters\)
sed "s/^X//" >'config/devsty.h' <<'END_OF_FILE'
X#ifndef CONFIG_DEVSTY_H
X#define CONFIG_DEVSTY_H
X
X#define DEVSTY "/dev/tty"
X
X/* DEVSTY is the prefix of slave sides of pseudo-ttys. */
X
X#endif
END_OF_FILE
if test 142 -ne `wc -c <'config/devsty.h'`; then
    echo shar: \"'config/devsty.h'\" unpacked with wrong size!
fi
# end of 'config/devsty.h'
fi
if test -f 'config/fdsettrouble.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/fdsettrouble.h'\"
else
echo shar: Extracting \"'config/fdsettrouble.h'\" \(180 characters\)
sed "s/^X//" >'config/fdsettrouble.h' <<'END_OF_FILE'
X#ifndef CONFIG_FD_SET_TROUBLE_H
X#define CONFIG_FD_SET_TROUBLE_H
X
X#undef LACKING_FD_ZERO
X#undef DESPERATE_FD_SET
X
X/* sysconf expects lines 4 and 5 */
X
X/* XXX: deprecated */
X
X#endif
END_OF_FILE
if test 180 -ne `wc -c <'config/fdsettrouble.h'`; then
    echo shar: \"'config/fdsettrouble.h'\" unpacked with wrong size!
fi
# end of 'config/fdsettrouble.h'
fi
if test -f 'config/genericptr.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/genericptr.h'\"
else
echo shar: Extracting \"'config/genericptr.h'\" \(292 characters\)
sed "s/^X//" >'config/genericptr.h' <<'END_OF_FILE'
X#ifndef CONFIG_GENERICPTR_H
X#define CONFIG_GENERICPTR_H
X
X#define GENERICPTR char *
X
X/* GENERICPTR is a pointer-to-memory type, for use with ioctl. */
X/* char * is safe with all C compilers. void * is safe only with ANSI */
X/* but may produce fewer warnings under an ANSI compiler. */
X
X#endif
END_OF_FILE
if test 292 -ne `wc -c <'config/genericptr.h'`; then
    echo shar: \"'config/genericptr.h'\" unpacked with wrong size!
fi
# end of 'config/genericptr.h'
fi
if test -f 'config/posix.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/posix.h'\"
else
echo shar: Extracting \"'config/posix.h'\" \(292 characters\)
sed "s/^X//" >'config/posix.h' <<'END_OF_FILE'
X#ifndef CONFIG_POSIX_H
X#define CONFIG_POSIX_H
X
X#undef POSIX_SILLINESS
X
X/* must have #undef POSIX_SILLINESS or #define POSIX_SILLINESS
X   on line 4 of this file */
X
X/* this was originally -DPOSIX rather than -DPOSIX_SILLINESS,
X   but that conflicts with Ultrix 4.0's POSIX handling */
X
X#endif
END_OF_FILE
if test 292 -ne `wc -c <'config/posix.h'`; then
    echo shar: \"'config/posix.h'\" unpacked with wrong size!
fi
# end of 'config/posix.h'
fi
if test -f 'config/ptybin.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/ptybin.h'\"
else
echo shar: Extracting \"'config/ptybin.h'\" \(92 characters\)
sed "s/^X//" >'config/ptybin.h' <<'END_OF_FILE'
X#ifndef CONFIG_PTYBIN_H
X#define CONFIG_PTYBIN_H
X
X#define PTYBIN "/usr/local/ptybin"
X
X#endif
END_OF_FILE
if test 92 -ne `wc -c <'config/ptybin.h'`; then
    echo shar: \"'config/ptybin.h'\" unpacked with wrong size!
fi
# end of 'config/ptybin.h'
fi
if test -f 'config/ptydir.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/ptydir.h'\"
else
echo shar: Extracting \"'config/ptydir.h'\" \(225 characters\)
sed "s/^X//" >'config/ptydir.h' <<'END_OF_FILE'
X#ifndef CONFIG_PTYDIR_H
X#define CONFIG_PTYDIR_H
X
X#define PTYDIR "/usr/local/etc/pty"
X
X/* PTYDIR is where pty will store its communications files. */
X/* It must be owned by the same uid that pty runs as, mode 0700. */
X
X#endif
END_OF_FILE
if test 225 -ne `wc -c <'config/ptydir.h'`; then
    echo shar: \"'config/ptydir.h'\" unpacked with wrong size!
fi
# end of 'config/ptydir.h'
fi
if test -f 'config/ptyext.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/ptyext.h'\"
else
echo shar: Extracting \"'config/ptyext.h'\" \(283 characters\)
sed "s/^X//" >'config/ptyext.h' <<'END_OF_FILE'
X#ifndef CONFIG_PTYEXT_H
X#define CONFIG_PTYEXT_H
X
X#define PTYEXT1 "pqrstuvwxyzabcdefghijklmno"
X#define PTYEXT2 "0123456789abcdef"
X
X/* Note that PTYEXT2[0] must indicate the leader of each bank. */
X
X/* Note also that the order here determines the order of the session logs. */
X
X#endif
END_OF_FILE
if test 283 -ne `wc -c <'config/ptyext.h'`; then
    echo shar: \"'config/ptyext.h'\" unpacked with wrong size!
fi
# end of 'config/ptyext.h'
fi
if test -f 'config/ptygroup.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/ptygroup.h'\"
else
echo shar: Extracting \"'config/ptygroup.h'\" \(80 characters\)
sed "s/^X//" >'config/ptygroup.h' <<'END_OF_FILE'
X#ifndef CONFIG_PTYGROUP_H
X#define CONFIG_PTYGROUP_H
X
X#define PTYGROUP 4
X
X#endif
END_OF_FILE
if test 80 -ne `wc -c <'config/ptygroup.h'`; then
    echo shar: \"'config/ptygroup.h'\" unpacked with wrong size!
fi
# end of 'config/ptygroup.h'
fi
if test -f 'config/ptylongname.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/ptylongname.h'\"
else
echo shar: Extracting \"'config/ptylongname.h'\" \(96 characters\)
sed "s/^X//" >'config/ptylongname.h' <<'END_OF_FILE'
X#ifndef CONFIG_PTY_LONGNAME_H
X#define CONFIG_PTY_LONGNAME_H
X
X#define PTYLONGNAMELEN 100
X
X#endif
END_OF_FILE
if test 96 -ne `wc -c <'config/ptylongname.h'`; then
    echo shar: \"'config/ptylongname.h'\" unpacked with wrong size!
fi
# end of 'config/ptylongname.h'
fi
if test -f 'config/ptymodes.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/ptymodes.h'\"
else
echo shar: Extracting \"'config/ptymodes.h'\" \(129 characters\)
sed "s/^X//" >'config/ptymodes.h' <<'END_OF_FILE'
X#ifndef CONFIG_PTYMODES_H
X#define CONFIG_PTYMODES_H
X
X#define PTYMODE_USED 0600
X#define PTYMODE_UNUSED 0666 /* whimper */
X
X#endif
END_OF_FILE
if test 129 -ne `wc -c <'config/ptymodes.h'`; then
    echo shar: \"'config/ptymodes.h'\" unpacked with wrong size!
fi
# end of 'config/ptymodes.h'
fi
if test -f 'config/ptyopts.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/ptyopts.h'\"
else
echo shar: Extracting \"'config/ptyopts.h'\" \(187 characters\)
sed "s/^X//" >'config/ptyopts.h' <<'END_OF_FILE'
X#ifndef CONFIG_PTYOPTS_H
X#define CONFIG_PTYOPTS_H
X
X#undef PTY_MUSTNOT_SESSION
X#undef PTY_MUSTNOT_UTMPHOST
X#undef PTY_MUSTNOT_UTMP
X#undef PTY_MUSTNOT_WTMP
X#undef PTY_MUSTNOT_CHOWN
X
X#endif
END_OF_FILE
if test 187 -ne `wc -c <'config/ptyopts.h'`; then
    echo shar: \"'config/ptyopts.h'\" unpacked with wrong size!
fi
# end of 'config/ptyopts.h'
fi
if test -f 'config/sessconnfile.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/sessconnfile.h'\"
else
echo shar: Extracting \"'config/sessconnfile.h'\" \(165 characters\)
sed "s/^X//" >'config/sessconnfile.h' <<'END_OF_FILE'
X#ifndef CONFIG_SESSCONNFILE_H
X#define CONFIG_SESSCONNFILE_H
X
X#define SESSCONNLOG_FILE "/usr/local/etc/sclog"
X#define SESSCONNNOW_FILE "/usr/local/etc/scnow"
X
X#endif
END_OF_FILE
if test 165 -ne `wc -c <'config/sessconnfile.h'`; then
    echo shar: \"'config/sessconnfile.h'\" unpacked with wrong size!
fi
# end of 'config/sessconnfile.h'
fi
if test -f 'config/sessfile.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/sessfile.h'\"
else
echo shar: Extracting \"'config/sessfile.h'\" \(153 characters\)
sed "s/^X//" >'config/sessfile.h' <<'END_OF_FILE'
X#ifndef CONFIG_SESSFILE_H
X#define CONFIG_SESSFILE_H
X
X#define SESSLOG_FILE "/usr/local/etc/sesslog"
X#define SESSNOW_FILE "/usr/local/etc/sessnow"
X
X#endif
END_OF_FILE
if test 153 -ne `wc -c <'config/sessfile.h'`; then
    echo shar: \"'config/sessfile.h'\" unpacked with wrong size!
fi
# end of 'config/sessfile.h'
fi
if test -f 'config/sysv.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/sysv.h'\"
else
echo shar: Extracting \"'config/sysv.h'\" \(65 characters\)
sed "s/^X//" >'config/sysv.h' <<'END_OF_FILE'
X#ifndef CONFIG_SYSV_H
X#define CONFIG_SYSV_H
X
X#undef SYSV
X
X#endif
END_OF_FILE
if test 65 -ne `wc -c <'config/sysv.h'`; then
    echo shar: \"'config/sysv.h'\" unpacked with wrong size!
fi
# end of 'config/sysv.h'
fi
if test -f 'config/ttyopts.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/ttyopts.h'\"
else
echo shar: Extracting \"'config/ttyopts.h'\" \(155 characters\)
sed "s/^X//" >'config/ttyopts.h' <<'END_OF_FILE'
X#ifndef CONFIG_TTYOPTS_H
X#define CONFIG_TTYOPTS_H
X
X#define TTY_WINDOWS
X#undef TTY_AUXCHARS
X#undef TTY_TERMIO
X
X/* TTY_WINDOWS must be on line 4. */
X
X#endif
END_OF_FILE
if test 155 -ne `wc -c <'config/ttyopts.h'`; then
    echo shar: \"'config/ttyopts.h'\" unpacked with wrong size!
fi
# end of 'config/ttyopts.h'
fi
if test -f 'config/utmpfile.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/utmpfile.h'\"
else
echo shar: Extracting \"'config/utmpfile.h'\" \(322 characters\)
sed "s/^X//" >'config/utmpfile.h' <<'END_OF_FILE'
X#ifndef CONFIG_UTMPFILE_H
X#define CONFIG_UTMPFILE_H
X
X/* XXX: we should #include <utmp.h> here, but it's usually not protected,
so we have to pass on to the user the burden of including it first. */
X
X#ifndef UTMP_FILE
X#ifdef _PATH_UTMP
X#define UTMP_FILE _PATH_UTMP
X#else
X#define UTMP_FILE "/etc/utmp"
X#endif
X#endif
X
X#endif
END_OF_FILE
if test 322 -ne `wc -c <'config/utmpfile.h'`; then
    echo shar: \"'config/utmpfile.h'\" unpacked with wrong size!
fi
# end of 'config/utmpfile.h'
fi
if test -f 'config/wtmpfile.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/wtmpfile.h'\"
else
echo shar: Extracting \"'config/wtmpfile.h'\" \(326 characters\)
sed "s/^X//" >'config/wtmpfile.h' <<'END_OF_FILE'
X#ifndef CONFIG_WTMPFILE_H
X#define CONFIG_WTMPFILE_H
X
X/* XXX: we should #include <utmp.h> here, but it's usually not protected,
so we have to pass on to the user the burden of including it first. */
X
X#ifndef WTMP_FILE
X#ifdef _PATH_WTMP
X#define WTMP_FILE _PATH_WTMP
X#else
X#define WTMP_FILE "/usr/adm/wtmp"
X#endif
X#endif
X
X#endif
END_OF_FILE
if test 326 -ne `wc -c <'config/wtmpfile.h'`; then
    echo shar: \"'config/wtmpfile.h'\" unpacked with wrong size!
fi
# end of 'config/wtmpfile.h'
fi
if test -f 'ctrlv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ctrlv.c'\"
else
echo shar: Extracting \"'ctrlv.c'\" \(370 characters\)
sed "s/^X//" >'ctrlv.c' <<'END_OF_FILE'
X#include "ptymisc.h"
X
static char buf[64];
static char outbuf[1000];
X
main()
X{
X int r;
X int i;
X
X while ((r = read(0,buf,sizeof(buf))) > 0)
X  {
X   for (i = 0;i < r;++i)
X    {
X     outbuf[2 * i] = 22;
X     outbuf[2 * i + 1] = buf[i];
X    }
X   outbuf[2 * r] = 4;
X   bwrite(1,outbuf,2 * r + 1);
X  }
X for (i = 0;i < 30;++i)
X   outbuf[i] = 4;
X bwrite(1,outbuf,i);
X exit(0);
X}
END_OF_FILE
if test 370 -ne `wc -c <'ctrlv.c'`; then
    echo shar: \"'ctrlv.c'\" unpacked with wrong size!
fi
# end of 'ctrlv.c'
fi
if test -f 'env.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'env.h'\"
else
echo shar: Extracting \"'env.h'\" \(202 characters\)
sed "s/^X//" >'env.h' <<'END_OF_FILE'
X#ifndef ENV_H
X#define ENV_H
X
extern int env_init();
extern int env_put();
extern int env_put2();
extern int env_unset();
extern char *env_get();
extern char *env_pick();
X
extern char **environ;
X
X#endif
END_OF_FILE
if test 202 -ne `wc -c <'env.h'`; then
    echo shar: \"'env.h'\" unpacked with wrong size!
fi
# end of 'env.h'
fi
if test -f 'excloff.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'excloff.c'\"
else
echo shar: Extracting \"'excloff.c'\" \(110 characters\)
sed "s/^X//" >'excloff.c' <<'END_OF_FILE'
X/* Public domain. */
X#include <sys/ioctl.h>
X
main()
X{
X (void) ioctl(1,(unsigned long) TIOCNXCL,(char *) 0);
X}
END_OF_FILE
if test 110 -ne `wc -c <'excloff.c'`; then
    echo shar: \"'excloff.c'\" unpacked with wrong size!
fi
# end of 'excloff.c'
fi
if test -f 'exclon.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'exclon.1'\"
else
echo shar: Extracting \"'exclon.1'\" \(729 characters\)
sed "s/^X//" >'exclon.1' <<'END_OF_FILE'
X.TH excl 1
X.SH NAME
exclon, excloff \- reserve tty for exclusive use
X.SH SYNOPSIS
X.B exclon
X.PP
X.B excloff
X.SH DESCRIPTION
The
X.B exclon
command reserves your terminal for exclusive use with
the TIOCEXCL ioctl.
This means that any attempt to open your terminal,
including through /dev/tty,
will fail.
X
X.B write
is affected by
X.B exclon,
but
X.B talk
is not.
This feature has made
X.B exclon
a popular tool for people who prefer
the
X.B talk
style of communication.
X
To unreserve your terminal, use
X.B excloff.
It is polite to do this at the end of a session,
though it is automatic when the terminal is closed.
X.SH AUTHOR
I hesitate to claim authorship for a one-statement program.
X.SH "SEE ALSO"
talk(1), stty(1), ioctl(2), tty(4)
END_OF_FILE
if test 729 -ne `wc -c <'exclon.1'`; then
    echo shar: \"'exclon.1'\" unpacked with wrong size!
fi
# end of 'exclon.1'
fi
if test -f 'exclon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'exclon.c'\"
else
echo shar: Extracting \"'exclon.c'\" \(110 characters\)
sed "s/^X//" >'exclon.c' <<'END_OF_FILE'
X/* Public domain. */
X#include <sys/ioctl.h>
X
main()
X{
X (void) ioctl(1,(unsigned long) TIOCEXCL,(char *) 0);
X}
END_OF_FILE
if test 110 -ne `wc -c <'exclon.c'`; then
    echo shar: \"'exclon.c'\" unpacked with wrong size!
fi
# end of 'exclon.c'
fi
if test -f 'fmt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fmt.h'\"
else
echo shar: Extracting \"'fmt.h'\" \(769 characters\)
sed "s/^X//" >'fmt.h' <<'END_OF_FILE'
X#ifndef FMT_H
X#define FMT_H
X
X#define FMT_ULONG 39 /* enough space to hold 2^128 - 1 in decimal */
X#define FMT_LEN ((char *) 0) /* convenient abbreviation */
X
extern unsigned int fmt_uint();
extern unsigned int fmt_xint();
extern unsigned int fmt_nbbint();
extern unsigned int fmt_ushort();
extern unsigned int fmt_xshort();
extern unsigned int fmt_nbbshort();
extern unsigned int fmt_ulong();
extern unsigned int fmt_xlong();
extern unsigned int fmt_nbblong();
X
extern unsigned int fmt_plusminus();
extern unsigned int fmt_minus();
extern unsigned int fmt_0x();
X
extern unsigned int fmt_strncpy();
extern unsigned int fmt_memcpy();
extern unsigned int fmt_vis();
extern unsigned int fmt_nvis();
extern unsigned int fmt_rvis();
extern unsigned int fmt_unrvis();
X
X#endif
END_OF_FILE
if test 769 -ne `wc -c <'fmt.h'`; then
    echo shar: \"'fmt.h'\" unpacked with wrong size!
fi
# end of 'fmt.h'
fi
if test -f 'getopt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt.h'\"
else
echo shar: Extracting \"'getopt.h'\" \(459 characters\)
sed "s/^X//" >'getopt.h' <<'END_OF_FILE'
X#ifndef GETOPT_H
X#define GETOPT_H
X
X#ifndef GETOPTORIGDEF
X#define getopt getoptmine
X#define optarg getoptarg
X#define optind getoptind
X#define opterr getopterr
X#define optpos getoptpos
X#define optproblem getoptproblem
X#define optprogname getoptprogname
X#define opteof getopteof
X#endif
X
extern int getopt();
extern char *optarg;
extern int optind;
extern int opterr;
extern int optpos;
extern int optproblem;
extern char *optprogname;
extern int opteof;
X
X#endif
END_OF_FILE
if test 459 -ne `wc -c <'getopt.h'`; then
    echo shar: \"'getopt.h'\" unpacked with wrong size!
fi
# end of 'getopt.h'
fi
if test -f 'getoptquiet.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getoptquiet.h'\"
else
echo shar: Extracting \"'getoptquiet.h'\" \(459 characters\)
sed "s/^X//" >'getoptquiet.h' <<'END_OF_FILE'
X#ifndef GETOPT_H
X#define GETOPT_H
X
X#ifndef GETOPTORIGDEF
X#define getopt getoptmine
X#define optarg getoptarg
X#define optind getoptind
X#define opterr getopterr
X#define optpos getoptpos
X#define optproblem getoptproblem
X#define optprogname getoptprogname
X#define opteof getopteof
X#endif
X
extern int getopt();
extern char *optarg;
extern int optind;
extern int opterr;
extern int optpos;
extern int optproblem;
extern char *optprogname;
extern int opteof;
X
X#endif
END_OF_FILE
if test 459 -ne `wc -c <'getoptquiet.h'`; then
    echo shar: \"'getoptquiet.h'\" unpacked with wrong size!
fi
# end of 'getoptquiet.h'
fi
if test -f 'lock.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lock.1'\"
else
echo shar: Extracting \"'lock.1'\" \(589 characters\)
sed "s/^X//" >'lock.1' <<'END_OF_FILE'
X.TH lock 1
X.SH NAME
lock \- reserve a terminal
X.SH SYNOPSIS
X.B lock
X.SH DESCRIPTION
X.B lock
requests a password from the user, reads it again for verification,
and then sits around doing nothing until the password is typed a third
time.
X.PP
This clone version of
X.B lock
corrects several of the original's failings, by being much simpler:
it doesn't accept
X.I hasta la vista;
it doesn't accept
the root password;
it doesn't time out;
and it does print a message for each bad password.
X.SH VERSION
lock version 2.0, 7/27/91.
X.SH AUTHOR
Placed into the public domain by Daniel J. Bernstein.
END_OF_FILE
if test 589 -ne `wc -c <'lock.1'`; then
    echo shar: \"'lock.1'\" unpacked with wrong size!
fi
# end of 'lock.1'
fi
if test -f 'mesg.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mesg.1'\"
else
echo shar: Extracting \"'mesg.1'\" \(805 characters\)
sed "s/^X//" >'mesg.1' <<'END_OF_FILE'
X.TH mesg 1
X.SH NAME
mesg \- permit or deny messages
X.SH SYNOPSIS
X.B mesg
X[
X.B n
X] [
X.B y
X]
X.SH DESCRIPTION
After
X.B mesg y,
other users can
use
X.B write(1)
or
X.B talk(1)
to send messages to your terminal.
X.B mesg n
turns this off.
X.B mesg
applies to your current terminal session;
typically you'd put a
X.B mesg y
into your
X.B \&.login,
X.B \&.cshrc,
or
X.B \&.profile.
X
X.B mesg
without an argument tells you your current
messaging status.
X
X.B mesg
requires its input to be your terminal session
X(or at least a session you own). All it really
does is handle the group-write bit on the terminal.
X
X.B mesg
only looks at the first letter of its first argument.
X.SH "EXIT VALUE"
Without an argument,
X.I mesg
exits with value 0 if messages are receivable,
X1 if not,
X2 upon error.
X.SH "SEE ALSO"
write(1), talk(1)
END_OF_FILE
if test 805 -ne `wc -c <'mesg.1'`; then
    echo shar: \"'mesg.1'\" unpacked with wrong size!
fi
# end of 'mesg.1'
fi
if test -f 'mesg.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mesg.c'\"
else
echo shar: Extracting \"'mesg.c'\" \(599 characters\)
sed "s/^X//" >'mesg.c' <<'END_OF_FILE'
X/* Public domain. */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <stdio.h>
X
X#define MESGBIT 0020
X
main(argc,argv)
int argc;
char *argv[];
X{
X struct stat st;
X
X if (fstat(0,&st) == -1)
X   exit(2); /* XXX */
X
X if (argc == 1)
X   if (st.st_mode & MESGBIT)
X     printf("is y\n");
X   else
X     printf("is n\n");
X else
X   switch(argv[1][0])
X    {
X     case 'y':
X       fchmod(0,(int) (st.st_mode | MESGBIT));
X       break;
X     case 'n':
X       fchmod(0,(int) (st.st_mode & ~MESGBIT));
X       break;
X     default:
X       fprintf(stderr,"usage: mesg [y] [n]\n");
X       exit(2);
X    }
X exit(0);
X}
END_OF_FILE
if test 599 -ne `wc -c <'mesg.c'`; then
    echo shar: \"'mesg.c'\" unpacked with wrong size!
fi
# end of 'mesg.c'
fi
if test -f 'nobuf.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nobuf.sh'\"
else
echo shar: Extracting \"'nobuf.sh'\" \(44 characters\)
sed "s/^X//" >'nobuf.sh' <<'END_OF_FILE'
X#!/bin/sh
ctrlv | pty -0dpCR8 -xf ${1+"$@"}
END_OF_FILE
if test 44 -ne `wc -c <'nobuf.sh'`; then
    echo shar: \"'nobuf.sh'\" unpacked with wrong size!
fi
# end of 'nobuf.sh'
fi
if test -f 'ptycomm.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptycomm.h'\"
else
echo shar: Extracting \"'ptycomm.h'\" \(198 characters\)
sed "s/^X//" >'ptycomm.h' <<'END_OF_FILE'
X#ifndef PTY_COMM_H
X#define PTY_COMM_H
X
extern int comm_unlink();
extern int comm_read();
extern int comm_accept();
extern int comm_write();
extern int comm_putfd();
extern int comm_getfd();
X
X#endif
END_OF_FILE
if test 198 -ne `wc -c <'ptycomm.h'`; then
    echo shar: \"'ptycomm.h'\" unpacked with wrong size!
fi
# end of 'ptycomm.h'
fi
if test -f 'ptyerr.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptyerr.h'\"
else
echo shar: Extracting \"'ptyerr.h'\" \(408 characters\)
sed "s/^X//" >'ptyerr.h' <<'END_OF_FILE'
X#ifndef PTY_ERR_H
X#define PTY_ERR_H
X
extern void die();
extern void warn();
extern void warn_disable();
extern void info();
X
X#define DIE_USAGE 1
X#define DIE_NOCTTY 2
X#define DIE_GETMODES 3
X#define DIE_SETMODES 4
X#define DIE_NOPTYS 5
X#define DIE_SETUP 6
X#define DIE_FORK 7
X#define DIE_PTYDIR 8
X#define DIE_NOMEM 9
X#define DIE_IMPOSSIBLE 10
X#define DIE_COMM 11
X#define DIE_ELSE 16
X#define DIE_EXIST 17
X
X#endif
END_OF_FILE
if test 408 -ne `wc -c <'ptyerr.h'`; then
    echo shar: \"'ptyerr.h'\" unpacked with wrong size!
fi
# end of 'ptyerr.h'
fi
if test -f 'ptyget.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptyget.h'\"
else
echo shar: Extracting \"'ptyget.h'\" \(99 characters\)
sed "s/^X//" >'ptyget.h' <<'END_OF_FILE'
X#ifndef PTY_GETPTY_H
X#define PTY_GETPTY_H
X
extern int getfreepty();
extern int ungetpty();
X
X#endif
END_OF_FILE
if test 99 -ne `wc -c <'ptyget.h'`; then
    echo shar: \"'ptyget.h'\" unpacked with wrong size!
fi
# end of 'ptyget.h'
fi
if test -f 'ptylogs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptylogs.h'\"
else
echo shar: Extracting \"'ptylogs.h'\" \(137 characters\)
sed "s/^X//" >'ptylogs.h' <<'END_OF_FILE'
X#ifndef PTY_LOGS_H
X#define PTY_LOGS_H
X
extern int utmp_on();
extern int utmp_off();
extern int wtmp_on();
extern int wtmp_off();
X
X#endif
END_OF_FILE
if test 137 -ne `wc -c <'ptylogs.h'`; then
    echo shar: \"'ptylogs.h'\" unpacked with wrong size!
fi
# end of 'ptylogs.h'
fi
if test -f 'ptymaster.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptymaster.h'\"
else
echo shar: Extracting \"'ptymaster.h'\" \(73 characters\)
sed "s/^X//" >'ptymaster.h' <<'END_OF_FILE'
X#ifndef PTY_MASTER_H
X#define PTY_MASTER_H
X
extern void master();
X
X#endif
END_OF_FILE
if test 73 -ne `wc -c <'ptymaster.h'`; then
    echo shar: \"'ptymaster.h'\" unpacked with wrong size!
fi
# end of 'ptymaster.h'
fi
if test -f 'ptymisc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptymisc.h'\"
else
echo shar: Extracting \"'ptymisc.h'\" \(271 characters\)
sed "s/^X//" >'ptymisc.h' <<'END_OF_FILE'
X#ifndef PTY_MISC_H
X#define PTY_MISC_H
X
extern long now();
extern int gaargh();
extern int forceopen();
extern int respeq();
extern int bread();
extern int bwrite();
extern int lflock();
extern int lfunlock();
extern int setnonblock();
extern int unsetnonblock();
X
X#endif
END_OF_FILE
if test 271 -ne `wc -c <'ptymisc.h'`; then
    echo shar: \"'ptymisc.h'\" unpacked with wrong size!
fi
# end of 'ptymisc.h'
fi
if test -f 'ptysecure.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptysecure.h'\"
else
echo shar: Extracting \"'ptysecure.h'\" \(101 characters\)
sed "s/^X//" >'ptysecure.h' <<'END_OF_FILE'
X#ifndef PTY_SECURE_H
X#define PTY_SECURE_H
X
extern int ptysecure();
extern int ptyunsecure();
X
X#endif
END_OF_FILE
if test 101 -ne `wc -c <'ptysecure.h'`; then
    echo shar: \"'ptysecure.h'\" unpacked with wrong size!
fi
# end of 'ptysecure.h'
fi
if test -f 'ptysigler.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptysigler.h'\"
else
echo shar: Extracting \"'ptysigler.h'\" \(73 characters\)
sed "s/^X//" >'ptysigler.h' <<'END_OF_FILE'
X#ifndef PTY_SIGLER_H
X#define PTY_SIGLER_H
X
extern void sigler();
X
X#endif
END_OF_FILE
if test 73 -ne `wc -c <'ptysigler.h'`; then
    echo shar: \"'ptysigler.h'\" unpacked with wrong size!
fi
# end of 'ptysigler.h'
fi
if test -f 'ptyslave.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptyslave.h'\"
else
echo shar: Extracting \"'ptyslave.h'\" \(70 characters\)
sed "s/^X//" >'ptyslave.h' <<'END_OF_FILE'
X#ifndef PTY_SLAVE_H
X#define PTY_SLAVE_H
X
extern void slave();
X
X#endif
END_OF_FILE
if test 70 -ne `wc -c <'ptyslave.h'`; then
    echo shar: \"'ptyslave.h'\" unpacked with wrong size!
fi
# end of 'ptyslave.h'
fi
if test -f 'ptytexts.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptytexts.h'\"
else
echo shar: Extracting \"'ptytexts.h'\" \(196 characters\)
sed "s/^X//" >'ptytexts.h' <<'END_OF_FILE'
X#ifndef PTY_TEXTS_H
X#define PTY_TEXTS_H
X
extern char *ptyauthor;
extern char *ptyversion;
extern char *ptycopyright;
extern char *ptywarranty;
extern char *ptyusage;
extern char *ptyhelp;
X
X#endif
END_OF_FILE
if test 196 -ne `wc -c <'ptytexts.h'`; then
    echo shar: \"'ptytexts.h'\" unpacked with wrong size!
fi
# end of 'ptytexts.h'
fi
if test -f 'radixsort.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'radixsort.h'\"
else
echo shar: Extracting \"'radixsort.h'\" \(174 characters\)
sed "s/^X//" >'radixsort.h' <<'END_OF_FILE'
X#ifndef RADIXSORT_H
X#define RADIXSORT_H
X
extern int radixsort3();
extern int radixsort4();
extern int radixsort5();
extern int radixsort7();
X
extern int radixsort();
X
X#endif
END_OF_FILE
if test 174 -ne `wc -c <'radixsort.h'`; then
    echo shar: \"'radixsort.h'\" unpacked with wrong size!
fi
# end of 'radixsort.h'
fi
if test -f 'ralloc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ralloc.h'\"
else
echo shar: Extracting \"'ralloc.h'\" \(257 characters\)
sed "s/^X//" >'ralloc.h' <<'END_OF_FILE'
X#ifndef RALLOC_H
X#define RALLOC_H
X
extern char *ralloc();
extern void rfree();
extern int rcount();
extern int rallocinstall();
extern void rallocneverfail();
X
X#define RFREE(x) rfree((char *) (x))
X#define RALLOC(t,x) ((t *) ralloc((x) * sizeof(t)))
X
X#endif
END_OF_FILE
if test 257 -ne `wc -c <'ralloc.h'`; then
    echo shar: \"'ralloc.h'\" unpacked with wrong size!
fi
# end of 'ralloc.h'
fi
if test -f 'scan.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scan.h'\"
else
echo shar: Extracting \"'scan.h'\" \(732 characters\)
sed "s/^X//" >'scan.h' <<'END_OF_FILE'
X#ifndef SCAN_H
X#define SCAN_H
X
extern unsigned int scan_uint();
extern unsigned int scan_xint();
extern unsigned int scan_nbbint();
extern unsigned int scan_ushort();
extern unsigned int scan_xshort();
extern unsigned int scan_nbbshort();
extern unsigned int scan_ulong();
extern unsigned int scan_xlong();
extern unsigned int scan_nbblong();
X
extern unsigned int scan_plusminus();
extern unsigned int scan_0x();
X
extern unsigned int scan_whitenskip();
extern unsigned int scan_nonwhitenskip();
extern unsigned int scan_charsetnskip();
extern unsigned int scan_noncharsetnskip();
X/* XXX: these aren't unique in the first 8 characters. i don't care. */
X
extern unsigned int scan_strncmp();
extern unsigned int scan_memcmp();
X
X#endif
END_OF_FILE
if test 732 -ne `wc -c <'scan.h'`; then
    echo shar: \"'scan.h'\" unpacked with wrong size!
fi
# end of 'scan.h'
fi
if test -f 'sclogrotate.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sclogrotate.sh'\"
else
echo shar: Extracting \"'sclogrotate.sh'\" \(634 characters\)
sed "s/^X//" >'sclogrotate.sh' <<'END_OF_FILE'
WARNING: Do not change this file without changing Makefile accordingly!
X#include "config/sessconnfile.h"
XX!/bin/sh
XX if you want to save SESSCONNLOG_FILE.7, do it now!
mv SESSCONNLOG_FILE.6 SESSCONNLOG_FILE.7
mv SESSCONNLOG_FILE.5 SESSCONNLOG_FILE.6
mv SESSCONNLOG_FILE.4 SESSCONNLOG_FILE.5
mv SESSCONNLOG_FILE.3 SESSCONNLOG_FILE.4
mv SESSCONNLOG_FILE.2 SESSCONNLOG_FILE.3
mv SESSCONNLOG_FILE.1 SESSCONNLOG_FILE.2
mv SESSCONNLOG_FILE.0 SESSCONNLOG_FILE.1
ln SESSCONNLOG_FILE SESSCONNLOG_FILE.0
cp SESSCONNLOG_FILE SESSCONNLOG_FILE.new; : > SESSCONNLOG_FILE.new
chmod 644 SESSCONNLOG_FILE.new; mv SESSCONNLOG_FILE.new SESSCONNLOG_FILE
END_OF_FILE
if test 634 -ne `wc -c <'sclogrotate.sh'`; then
    echo shar: \"'sclogrotate.sh'\" unpacked with wrong size!
fi
# end of 'sclogrotate.sh'
fi
if test -f 'scnowinit.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scnowinit.sh'\"
else
echo shar: Extracting \"'scnowinit.sh'\" \(164 characters\)
sed "s/^X//" >'scnowinit.sh' <<'END_OF_FILE'
WARNING: Do not change this file without changing Makefile accordingly!
X#include "config/sessconnfile.h"
XX!/bin/sh
X: > SESSCONNNOW_FILE; chmod 644 SESSCONNNOW_FILE
END_OF_FILE
if test 164 -ne `wc -c <'scnowinit.sh'`; then
    echo shar: \"'scnowinit.sh'\" unpacked with wrong size!
fi
# end of 'scnowinit.sh'
fi
if test -f 'script.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'script.sh'\"
else
echo shar: Extracting \"'script.sh'\" \(281 characters\)
sed "s/^X//" >'script.sh' <<'END_OF_FILE'
X#!/bin/sh
X# XXX: propagate stops!
X# Public domain.
case "$@" in
X"") set typescript ${1+"$@"} ;;
X"-a") set typescript ${1+"$@"} ;;
esac
echo "Script started, teeing $@"
X{ echo 'Script started on '`date`;
X  pty -s "${SHELL-/bin/sh}";
X  echo 'Script done on '`date`
X} | tee ${1+"$@"}
END_OF_FILE
if test 281 -ne `wc -c <'script.sh'`; then
    echo shar: \"'script.sh'\" unpacked with wrong size!
fi
# end of 'script.sh'
fi
if test -f 'script.tidy.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'script.tidy.1'\"
else
echo shar: Extracting \"'script.tidy.1'\" \(318 characters\)
sed "s/^X//" >'script.tidy.1' <<'END_OF_FILE'
X.TH script.tidy 1
X.SH NAME
script.tidy \- remove extra carriage returns and backspaces
X.SH SYNOPSIS
X.B script.tidy
X.SH DESCRIPTION
This filter
does a bit of postprocessing,
typically on a typescript produced by
X.B script.
It removes extra carriage returns
and wipes out backspaced characters.
X.SH "SEE ALSO"
script(1)
END_OF_FILE
if test 318 -ne `wc -c <'script.tidy.1'`; then
    echo shar: \"'script.tidy.1'\" unpacked with wrong size!
fi
# end of 'script.tidy.1'
fi
if test -f 'script.tidy.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'script.tidy.sh'\"
else
echo shar: Extracting \"'script.tidy.sh'\" \(62 characters\)
sed "s/^X//" >'script.tidy.sh' <<'END_OF_FILE'
X#!/bin/sh
X# Public domain.
exec sed 's/3$//
X:x
s/[^8]8//
t x'
END_OF_FILE
if test 62 -ne `wc -c <'script.tidy.sh'`; then
    echo shar: \"'script.tidy.sh'\" unpacked with wrong size!
fi
# end of 'script.tidy.sh'
fi
if test -f 'sess.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sess.sh'\"
else
echo shar: Extracting \"'sess.sh'\" \(44 characters\)
sed "s/^X//" >'sess.sh' <<'END_OF_FILE'
X#!/bin/sh
X# Public domain.
exec pty -s "$@"
END_OF_FILE
if test 44 -ne `wc -c <'sess.sh'`; then
    echo shar: \"'sess.sh'\" unpacked with wrong size!
fi
# end of 'sess.sh'
fi
if test -f 'sessconnlog.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sessconnlog.h'\"
else
echo shar: Extracting \"'sessconnlog.h'\" \(451 characters\)
sed "s/^X//" >'sessconnlog.h' <<'END_OF_FILE'
X#ifndef SESSCONNLOG_H
X#define SESSCONNLOG_H
X
X#define SESSCONNLOG_EXTLEN 4
X#define SESSCONNLOG_REMOTELEN 116 /* reasonable for the moment... */
X
struct sessconnlog
X {
X  char ext[SESSCONNLOG_EXTLEN];
X  long date;
X  int siglerpid; /* 0 for unused---currently inaccurate otherwise */
X  char remote[SESSCONNLOG_REMOTELEN]; /* always 0-terminated */
X }
X;
X
extern int sessconnlog();
extern void sessconnlog_fill();
extern void sessconnlog_disable();
X
X#endif
END_OF_FILE
if test 451 -ne `wc -c <'sessconnlog.h'`; then
    echo shar: \"'sessconnlog.h'\" unpacked with wrong size!
fi
# end of 'sessconnlog.h'
fi
if test -f 'sesslist.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sesslist.1'\"
else
echo shar: Extracting \"'sesslist.1'\" \(611 characters\)
sed "s/^X//" >'sesslist.1' <<'END_OF_FILE'
X.TH sesslist 1
X.SH NAME
sesslist \- list all pty sessions you own
X.SH SYNOPSIS
X.B sesslist
X[
X.B\-0
X]
X.SH DESCRIPTION
X.B sesslist
lists on its standard output
all
X.B pty
sessions owned by the current user id.
Given
X.B\-0,
X.B sesslist
will separate output lines by null instead of newline.
X
The output format is meant for human consumption
and is not completely defined.
It is not compatible with previous versions of
X.B sesslist
and may change in future versions.
X
This version of
X.B sesslist
includes non-sessions
started by
X.B pty.
X.SH DIAGNOSTICS
Self-explanatory.
X.SH "SEE ALSO"
pty(1),
sess(1),
sessname(1)
END_OF_FILE
if test 611 -ne `wc -c <'sesslist.1'`; then
    echo shar: \"'sesslist.1'\" unpacked with wrong size!
fi
# end of 'sesslist.1'
fi
if test -f 'sesslog.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sesslog.h'\"
else
echo shar: Extracting \"'sesslog.h'\" \(373 characters\)
sed "s/^X//" >'sesslog.h' <<'END_OF_FILE'
X#ifndef SESSLOG_H
X#define SESSLOG_H
X
X#define SESSLOG_EXTLEN 4
X#define SESSLOG_USERLEN 16 /* no harm in planning for the future */
X
struct sesslog
X {
X  char ext[SESSLOG_EXTLEN];
X  char username[SESSLOG_USERLEN];
X  int uid;
X  int masterpid; /* 0 if it's an ending */
X  long date;
X }
X;
X
extern int sesslog();
extern void sesslog_fill();
extern void sesslog_disable();
X
X#endif
END_OF_FILE
if test 373 -ne `wc -c <'sesslog.h'`; then
    echo shar: \"'sesslog.h'\" unpacked with wrong size!
fi
# end of 'sesslog.h'
fi
if test -f 'sessmenu.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sessmenu.1'\"
else
echo shar: Extracting \"'sessmenu.1'\" \(649 characters\)
sed "s/^X//" >'sessmenu.1' <<'END_OF_FILE'
X.TH sessmenu 1
X.SH NAME
sessmenu \- give a menu of disconnected sessions
X.SH SYNOPSIS
X.B sessmenu
X.I program
X[
X.I arg ...
X]
X.SH DESCRIPTION
Normally
X.B sessmenu
runs
X.I program
with the given arguments
under a
X.B pty
session.
However, if you have one or more disconnected sessions,
X.B sessmenu
lists them and shows what processes they have running.
To reconnect to one of the sessions, type its name.
Otherwise press return
and
X.B sessmenu
will start a new session as usual.
X
X.B sessmenu
expects to be run from a network connection,
on a tty in character mode,
or on some raw device.
It does all its own echoing.
X.SH "SEE ALSO"
sess(1),
sesslist(1)
END_OF_FILE
if test 649 -ne `wc -c <'sessmenu.1'`; then
    echo shar: \"'sessmenu.1'\" unpacked with wrong size!
fi
# end of 'sessmenu.1'
fi
if test -f 'sessname.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sessname.1'\"
else
echo shar: Extracting \"'sessname.1'\" \(720 characters\)
sed "s/^X//" >'sessname.1' <<'END_OF_FILE'
X.TH sessname 1
X.SH NAME
sessname \- provide a more descriptive name for the current pty session
X.SH SYNOPSIS
X.B sessname
X[
X.B\-s\fIext
X] [
X.I name
X]
X.SH DESCRIPTION
X.B sessname
adds
X.I name
to the information listed by
X.B sesslist
for the current
X.B pty
session.
X
X.I name
is in addition to the
base name of the session,
which is the last two characters of the
pseudo-terminal filename.
X
Without an argument,
X.B sessname
prints the name of the current session.
X
Normally
X.B sessname
uses the session specified by environment variable PTY.
Given
X.B\-s,
it will use session
X.I ext
instead.
X.SH DIAGNOSTICS
Self-explanatory.
X.SH RESTRICTIONS
X.I name
is limited to 100 characters.
X.SH "SEE ALSO"
pty(1),
sess(1),
sesslist(1)
END_OF_FILE
if test 720 -ne `wc -c <'sessname.1'`; then
    echo shar: \"'sessname.1'\" unpacked with wrong size!
fi
# end of 'sessname.1'
fi
if test -f 'sessnowinit.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sessnowinit.sh'\"
else
echo shar: Extracting \"'sessnowinit.sh'\" \(152 characters\)
sed "s/^X//" >'sessnowinit.sh' <<'END_OF_FILE'
WARNING: Do not change this file without changing Makefile accordingly!
X#include "config/sessfile.h"
XX!/bin/sh
X: > SESSNOW_FILE; chmod 644 SESSNOW_FILE
END_OF_FILE
if test 152 -ne `wc -c <'sessnowinit.sh'`; then
    echo shar: \"'sessnowinit.sh'\" unpacked with wrong size!
fi
# end of 'sessnowinit.sh'
fi
if test -f 'sessrotate.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sessrotate.sh'\"
else
echo shar: Extracting \"'sessrotate.sh'\" \(538 characters\)
sed "s/^X//" >'sessrotate.sh' <<'END_OF_FILE'
WARNING: Do not change this file without changing Makefile accordingly!
X#include "config/sessfile.h"
XX!/bin/sh
XX if you want to save SESSLOG_FILE.7, do it now!
mv SESSLOG_FILE.6 SESSLOG_FILE.7
mv SESSLOG_FILE.5 SESSLOG_FILE.6
mv SESSLOG_FILE.4 SESSLOG_FILE.5
mv SESSLOG_FILE.3 SESSLOG_FILE.4
mv SESSLOG_FILE.2 SESSLOG_FILE.3
mv SESSLOG_FILE.1 SESSLOG_FILE.2
mv SESSLOG_FILE.0 SESSLOG_FILE.1
ln SESSLOG_FILE SESSLOG_FILE.0
cp SESSLOG_FILE SESSLOG_FILE.new; : > SESSLOG_FILE.new
chmod 644 SESSLOG_FILE.new; mv SESSLOG_FILE.new SESSLOG_FILE
END_OF_FILE
if test 538 -ne `wc -c <'sessrotate.sh'`; then
    echo shar: \"'sessrotate.sh'\" unpacked with wrong size!
fi
# end of 'sessrotate.sh'
fi
if test -f 'sigdfl.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sigdfl.h'\"
else
echo shar: Extracting \"'sigdfl.h'\" \(234 characters\)
sed "s/^X//" >'sigdfl.h' <<'END_OF_FILE'
X#ifndef SIGDFL_H
X#define SIGDFL_H
X
extern int sigdfl();
X
extern int sigdfl_tstp();
extern int sigdfl_stop();
extern int sigdfl_ttin();
extern int sigdfl_ttou();
X
extern int sigdfl_abrt(); /* professional version of abort() */
X
X#endif
END_OF_FILE
if test 234 -ne `wc -c <'sigdfl.h'`; then
    echo shar: \"'sigdfl.h'\" unpacked with wrong size!
fi
# end of 'sigdfl.h'
fi
if test -f 'sigsched.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sigsched.h'\"
else
echo shar: Extracting \"'sigsched.h'\" \(732 characters\)
sed "s/^X//" >'sigsched.h' <<'END_OF_FILE'
X#ifndef SIGSCHED_H
X#define SIGSCHED_H
X
typedef struct
X {
X  int type;
X  union { int n; char *c; } u;
X }
ss_sig;
X
typedef struct
X {
X  int (*sched)();
X  int (*unsched)();
X  union { int n; char *c; } u;
X }
ss_extern;
X
typedef void ss_thread();
typedef int ss_id;
typedef char *ss_idptr;
X
extern ss_sig *ss_asap();
extern ss_sig *ss_signal();
extern ss_sig *ss_sigread();
extern ss_sig *ss_sigwrite();
extern ss_sig *ss_sigexcept();
X
extern int ss_addsig();
X
extern void ss_externsetsig();
X
extern int ss_schedvwait();
extern int ss_schedwait();
extern int ss_sched();
extern int ss_schedonce();
extern int ss_unschedv();
extern int ss_unsched();
X
extern void ss_forcewait();
extern void ss_unforcewait();
X
extern int ss_exec();
X
X#endif
END_OF_FILE
if test 732 -ne `wc -c <'sigsched.h'`; then
    echo shar: \"'sigsched.h'\" unpacked with wrong size!
fi
# end of 'sigsched.h'
fi
if test -f 'sod.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sod.h'\"
else
echo shar: Extracting \"'sod.h'\" \(508 characters\)
sed "s/^X//" >'sod.h' <<'END_OF_FILE'
X#ifndef SOD_H
X#define SOD_H
X
X/* a half-hearted attempt at a generic stack library */
X
X#define SODdecl(foostack,foo) \
typedef struct foostack { struct foostack *next; foo data; } *foostack
X  /* note that user must supply semicolon */
X
X#define SODnext(x) ((x)->next)
X#define SODdata(x) ((x)->data)
X#define SODalloc(t,x,ralloc) ((t) ((ralloc)(sizeof(*x))))
X#define SODpush(x,y) ((y)->next = (x),(x) = (y))
X#define SODpop(x,y) ((y) = (x),(x) = (x)->next)
X#define SODfree(u,rfree) ((rfree)((char *)(u)))
X
X#endif
END_OF_FILE
if test 508 -ne `wc -c <'sod.h'`; then
    echo shar: \"'sod.h'\" unpacked with wrong size!
fi
# end of 'sod.h'
fi
if test -f 'talkacros.7' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'talkacros.7'\"
else
echo shar: Extracting \"'talkacros.7'\" \(712 characters\)
sed "s/^X//" >'talkacros.7' <<'END_OF_FILE'
X.TH talkacros 7
X.SH NAME
talkacros \- some acronyms commonly used in screen conversation
X.SH DESCRIPTION
Many abbreviations are commonly used between people engaged in
low-delay typed conversations.
Here are a few of them:
X.TP 5
jam
Just a minute.
X.TP
X\:-)
Smiley-face.
X(Look at it sideways.)
This can mean anything
from a grin to a grimace,
depending on the context.
X.TP
X\:-(
XFrown.
X.TP
t
True (from LISP).
X.TP
ayt
Are you there?
X(An answer of no
means that the other person is
busy with something else.)
X.TP
ga
Go ahead.
X.TP
tyl
Talk to you later.
X.TP
oo
Over and out.
X.PP
X.SH BUGS
The author's biases have almost completely determined
the selection of acronyms for this list.
X.SH "SEE ALSO"
talk(1), write(1)
END_OF_FILE
if test 712 -ne `wc -c <'talkacros.7'`; then
    echo shar: \"'talkacros.7'\" unpacked with wrong size!
fi
# end of 'talkacros.7'
fi
if test -f 'timer.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'timer.h'\"
else
echo shar: Extracting \"'timer.h'\" \(521 characters\)
sed "s/^X//" >'timer.h' <<'END_OF_FILE'
X#ifndef TIMER_H
X#define TIMER_H
X
X#include "sigsched.h"
X
X#define TIMER_REAL ((timer_type) 0)
X#define TIMER_VIRTUAL ((timer_type) 1)
X#define TIMER_PROF ((timer_type) 2)
X#define TIMER_NUM ((timer_type) 3)
X
typedef int timer_type;
typedef struct { unsigned long sec; unsigned long usec; } timer_clock;
typedef struct { ss_sig sig; ss_extern x; timer_type t; timer_clock when; } timer_sig;
X
extern int timer_now();
extern void timer_sum();
extern int timer_diff();
extern void timer_setsig();
extern int timer_init();
X
X#endif
END_OF_FILE
if test 521 -ne `wc -c <'timer.h'`; then
    echo shar: \"'timer.h'\" unpacked with wrong size!
fi
# end of 'timer.h'
fi
if test -f 'tiocsti.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tiocsti.1'\"
else
echo shar: Extracting \"'tiocsti.1'\" \(250 characters\)
sed "s/^X//" >'tiocsti.1' <<'END_OF_FILE'
X.TH tiocsti 1
X.SH NAME
tiocsti \- simulate terminal input
X.SH SYNOPSIS
X.B tiocsti
X[
X.I arg
X] ...
X.SH DESCRIPTION
X.B tiocsti
X``types'' each of its arguments on the
current terminal, separated by spaces,
as if you had typed them.
X.SH "SEE ALSO"
tty(4)
END_OF_FILE
if test 250 -ne `wc -c <'tiocsti.1'`; then
    echo shar: \"'tiocsti.1'\" unpacked with wrong size!
fi
# end of 'tiocsti.1'
fi
if test -f 'tiocsti.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tiocsti.c'\"
else
echo shar: Extracting \"'tiocsti.c'\" \(322 characters\)
sed "s/^X//" >'tiocsti.c' <<'END_OF_FILE'
X/* Public domain. */
X#include <sys/ioctl.h>
X
main(argc,argv)
int argc;
char *argv[];
X{
X int j;
X char *s;
X
X if (ioctl(3,TIOCGPGRP,(char *) &j) == -1)
X   (void) dup2(0,3);
X
X for (j = 1;j < argc;j++)
X  {
X   for (s = argv[j];*s;s++)
X     (void) ioctl(3,TIOCSTI,s);
X   if (j < argc - 1)
X     (void) ioctl(3,TIOCSTI," ");
X  }
X}
END_OF_FILE
if test 322 -ne `wc -c <'tiocsti.c'`; then
    echo shar: \"'tiocsti.c'\" unpacked with wrong size!
fi
# end of 'tiocsti.c'
fi
if test -f 'tplay.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tplay.1'\"
else
echo shar: Extracting \"'tplay.1'\" \(399 characters\)
sed "s/^X//" >'tplay.1' <<'END_OF_FILE'
X.TH tplay 1
X.SH NAME
tplay \- play back a tape-recorded input
X.SH SYNTAX
X.B tplay
X.SH DESCRIPTION
X.B tplay
replays a
X.I tape
recorded by
X.B trecord.
It pauses to produce the same timing as the original input to
X.B trecord
X(down to the resolution of the system clock).
X.SH VERSION
tplay version 1.0, 7/27/91.
X.SH AUTHOR
Placed into the public domain by Daniel J. Bernstein.
X.SH "SEE ALSO"
trecord(1)
END_OF_FILE
if test 399 -ne `wc -c <'tplay.1'`; then
    echo shar: \"'tplay.1'\" unpacked with wrong size!
fi
# end of 'tplay.1'
fi
if test -f 'tscript.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tscript.sh'\"
else
echo shar: Extracting \"'tscript.sh'\" \(293 characters\)
sed "s/^X//" >'tscript.sh' <<'END_OF_FILE'
X#!/bin/sh
X# XXX: propagate stops!
X# Public domain.
case "$@" in
X"") set tapescript ${1+"$@"} ;;
X"-a") set tapescript ${1+"$@"} ;;
esac
echo "Tape started, teeing $@"
X{ echo 'Tape started on '`date`;
X  pty -s "${SHELL-/bin/sh}";
X  echo 'Tape done on '`date`
X} | trecord | tee ${1+"$@"} | tplay
END_OF_FILE
if test 293 -ne `wc -c <'tscript.sh'`; then
    echo shar: \"'tscript.sh'\" unpacked with wrong size!
fi
# end of 'tscript.sh'
fi
if test -f 'tty.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tty.1'\"
else
echo shar: Extracting \"'tty.1'\" \(311 characters\)
sed "s/^X//" >'tty.1' <<'END_OF_FILE'
X.TH tty 1
X.SH NAME
tty \- get terminal name
X.SH SYNOPSIS
X.B tty
X[
X.B\-s
X]
X.SH DESCRIPTION
X.B tty
prints the pathname of the user's terminal,
or
X``not a tty''
if its input is not a terminal.
X.B tty \-s
prints nothing.
X.SH "EXIT VALUE"
X0 if the input is a terminal,
X1 if it isn't (or if option processing fails).
END_OF_FILE
if test 311 -ne `wc -c <'tty.1'`; then
    echo shar: \"'tty.1'\" unpacked with wrong size!
fi
# end of 'tty.1'
fi
if test -f 'tty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tty.c'\"
else
echo shar: Extracting \"'tty.c'\" \(684 characters\)
sed "s/^X//" >'tty.c' <<'END_OF_FILE'
X/* tty.c: clone of tty program
Daniel J. Bernstein, brnstnd@nyu.edu.
Depends on getopt.h.
Requires ttyname().
X7/22/91: Baseline. tty 1.0, public domain.
No known patent problems.
X
Documentation in tty.1.
X*/
X
X#include "getopt.h"
X
extern char *ttyname(); /* XXX: should have library for this */
X
main(argc,argv)
int argc;
char *argv[];
X{
X char *s;
X int opt;
X int flagsilent;
X
X flagsilent = 0;
X while ((opt = getopt(argc,argv,"s")) != opteof)
X   switch(opt)
X    {
X     case 's':
X       flagsilent = 1;
X       break;
X     case '?':
X     default:
X       exit(1);
X    }
X
X s = ttyname(0);
X
X if (!flagsilent)
X   if (s)
X     (void) puts(s);
X   else
X     (void) puts("not a tty");
X exit(!s);
X}
END_OF_FILE
if test 684 -ne `wc -c <'tty.c'`; then
    echo shar: \"'tty.c'\" unpacked with wrong size!
fi
# end of 'tty.c'
fi
if test -f 'ttydetach.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ttydetach.1'\"
else
echo shar: Extracting \"'ttydetach.1'\" \(384 characters\)
sed "s/^X//" >'ttydetach.1' <<'END_OF_FILE'
X.TH ttydetach 1
X.SH NAME
ttydetach \- run program without a controlling tty
X.SH SYNOPSIS
X.B ttydetach
X.I program
X[
X.I arg  ...
X]
X.SH DESCRIPTION
X.B ttydetach
removes its association with the current tty,
removes any PTY variable from the environment,
and
runs
X.I program
with the given arguments.
It may close or arbitrarily mangle
open tty descriptors.
X.SH "SEE ALSO"
pty(1),
tty(4)
END_OF_FILE
if test 384 -ne `wc -c <'ttydetach.1'`; then
    echo shar: \"'ttydetach.1'\" unpacked with wrong size!
fi
# end of 'ttydetach.1'
fi
if test -f 'ttyprotect.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ttyprotect.sh'\"
else
echo shar: Extracting \"'ttyprotect.sh'\" \(44 characters\)
sed "s/^X//" >'ttyprotect.sh' <<'END_OF_FILE'
X#!/bin/sh
X# Public domain.
exec pty -0 "$@"
END_OF_FILE
if test 44 -ne `wc -c <'ttyprotect.sh'`; then
    echo shar: \"'ttyprotect.sh'\" unpacked with wrong size!
fi
# end of 'ttyprotect.sh'
fi
if test -f 'username.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'username.h'\"
else
echo shar: Extracting \"'username.h'\" \(101 characters\)
sed "s/^X//" >'username.h' <<'END_OF_FILE'
X#ifndef USERNAME_H
X#define USERNAME_H
X
extern int uid2username();
extern int username2uid();
X
X#endif
END_OF_FILE
if test 101 -ne `wc -c <'username.h'`; then
    echo shar: \"'username.h'\" unpacked with wrong size!
fi
# end of 'username.h'
fi
if test -f 'users.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'users.1'\"
else
echo shar: Extracting \"'users.1'\" \(554 characters\)
sed "s/^X//" >'users.1' <<'END_OF_FILE'
X.TH users 1
X.SH NAME
users \- show compact list of users who are logged on
X.SH SYNOPSIS
X.B users
X.SH DESCRIPTION
X.B users
lists the login names of the users currently on the system in a compact,
sorted,
one-line format.
X.SH COMPATIBILITY
Some versions of this program eliminate duplicates.
Some eliminate duplicates incorrectly.
This clone version prints each user exactly as many times
as /etc/utmp lists.
X.SH FILES
X/etc/utmp
X.SH VERSION
users version 2.0, 7/23/91.
X.SH AUTHOR
Placed into the public domain by Daniel J. Bernstein.
X.SH "SEE ALSO"
who(1)
END_OF_FILE
if test 554 -ne `wc -c <'users.1'`; then
    echo shar: \"'users.1'\" unpacked with wrong size!
fi
# end of 'users.1'
fi
if test -f 'utmpinit.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utmpinit.8'\"
else
echo shar: Extracting \"'utmpinit.8'\" \(353 characters\)
sed "s/^X//" >'utmpinit.8' <<'END_OF_FILE'
X.TH utmpinit 8
X.SH NAME
utmpinit \- clear /etc/utmp
X.SH SYNOPSIS
X.B utmpinit
X.SH DESCRIPTION
X.B utmpinit
fills in
X/etc/utmp
with properly initialized blank entries,
in the same order as specified by
X.B getttyent(3).
It should be run from
X.B rc.local
to initialize
X/etc/utmp
more professionally than
X.B init(8)
does.
X.SH "SEE ALSO"
getttyent(3),
init(8)
END_OF_FILE
if test 353 -ne `wc -c <'utmpinit.8'`; then
    echo shar: \"'utmpinit.8'\" unpacked with wrong size!
fi
# end of 'utmpinit.8'
fi
if test -f 'utmpinit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utmpinit.c'\"
else
echo shar: Extracting \"'utmpinit.c'\" \(621 characters\)
sed "s/^X//" >'utmpinit.c' <<'END_OF_FILE'
X/* derived from contribution from paul graham <pjg@acsu.buffalo.edu> */
X
X#include <sys/types.h>
X#include <sys/file.h>
X#include <ttyent.h>
X#include <utmp.h>
X#include "config/utmpfile.h"
X#include "ptymisc.h"
X
main()
X{
X struct ttyent *tt;
X int fd;
X static struct utmp ut;
X
X fd = open(UTMP_FILE,O_WRONLY | O_TRUNC | O_CREAT,0644);
X if (fd == -1)
X   exit(1); /*XXX*/
X
X ut.ut_host[0] = 0;
X ut.ut_name[0] = 0;
X ut.ut_time = now(); /* XXX: init uses 0 */
X
X write(fd,(char *) &ut,sizeof(ut));
X while (tt = getttyent())
X  {
X   strncpy(ut.ut_line,tt->ty_name,sizeof(ut.ut_line));
X   write(fd,(char *) &ut,sizeof(ut)); /*XXX*/
X  }
X}
END_OF_FILE
if test 621 -ne `wc -c <'utmpinit.c'`; then
    echo shar: \"'utmpinit.c'\" unpacked with wrong size!
fi
# end of 'utmpinit.c'
fi
if test -f 'waitfor.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'waitfor.1'\"
else
echo shar: Extracting \"'waitfor.1'\" \(544 characters\)
sed "s/^X//" >'waitfor.1' <<'END_OF_FILE'
X.TH waitfor 1
X.SH NAME
waitfor \- read input until it matches a fixed string
X.SH SYNOPSIS
X.B waitfor
X.I string
X.SH DESCRIPTION
X.B waitfor
reads characters from its input, one at a time,
until the end of the first occurrence of
X.I string.
It copies the characters to stderr.
It leaves the input file position
just after
X.I string.
X.SH "EXIT VALUE"
X.B waitfor
exits 0 if it finds
X.I string,
X1 if
X.I string
is not specified,
X2 if it is not able to allocate memory for an input buffer,
X3 upon an output error,
X4 upon an input error or end of file.
END_OF_FILE
if test 544 -ne `wc -c <'waitfor.1'`; then
    echo shar: \"'waitfor.1'\" unpacked with wrong size!
fi
# end of 'waitfor.1'
fi
if test -f 'waitfor.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'waitfor.c'\"
else
echo shar: Extracting \"'waitfor.c'\" \(612 characters\)
sed "s/^X//" >'waitfor.c' <<'END_OF_FILE'
extern char *malloc();
X
main(argc,argv)
int argc;
char *argv[];
X{
X int len;
X char *s;
X int pos;
X char ch;
X int f;
X int p;
X if (!argv[1])
X   exit(1);
X len = strlen(argv[1]);
X if (!len)
X   len = 1;
X if (!(s = malloc(len)))
X   exit(2);
X pos = 0;
X f = 0;
X while (read(0,&ch,1) == 1)
X  {
X   if (write(2,&ch,1) != 1)
X     exit(3);
X   if (ch)
X    {
X     s[pos] = ch;
X     ++pos;
X     if (pos == len)
X      {
X       f = 1;
X       pos = 0;
X      }
X     if (f && (ch == argv[1][len - 1]))
X      {
X       for (p = 1;s[(pos + p) % len] == argv[1][p];++p)
X	 ;
X       if (!argv[1][p])
X	 exit(0);
X      }
X    }
X  }
X exit(4);
X}
END_OF_FILE
if test 612 -ne `wc -c <'waitfor.c'`; then
    echo shar: \"'waitfor.c'\" unpacked with wrong size!
fi
# end of 'waitfor.c'
fi
if test -f 'wall.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wall.1'\"
else
echo shar: Extracting \"'wall.1'\" \(513 characters\)
sed "s/^X//" >'wall.1' <<'END_OF_FILE'
X.TH wall 1
X.SH NAME
wall \- write to all users
X.SH SYNOPSIS
X.B wall
X.SH DESCRIPTION
X.B wall
prompts for a message with
X``Broadcast Message,''
then reads its standard input until end-of-file.
It then sends this message
to all logged in users.
X
Naturally,
X.B mesg
protections apply.
X
X.B wall
will refuse to send a message containing any control
characters (other than the initial beep).
X.SH FILES
X/dev/tty*
X.br
X/etc/utmp
X.SH RESTRICTIONS
The message is limited to 10000 characters.
X.SH "SEE ALSO"
mesg(1),
write(1)
END_OF_FILE
if test 513 -ne `wc -c <'wall.1'`; then
    echo shar: \"'wall.1'\" unpacked with wrong size!
fi
# end of 'wall.1'
fi
if test -f 'whoami.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'whoami.1'\"
else
echo shar: Extracting \"'whoami.1'\" \(480 characters\)
sed "s/^X//" >'whoami.1' <<'END_OF_FILE'
X.TH whoami 1
X.SH NAME
whoami \- print effective username
X.SH SYNTAX
whoami
X.SH DESCRIPTION
X.B whoami
prints the username
corresponding to the effective userid,
or the numeric userid if no username is available.
X.SH COMPATIBILITY
X.B whoami
originated with BSD systems and typically is not available
under System V.
However, this is a straight clone.
X.SH VERSION
whoami version 1.0, 7/22/91.
X.SH AUTHOR
Placed into the public domain by Daniel J. Bernstein.
X.SH "SEE ALSO"
getuid(2)
END_OF_FILE
if test 480 -ne `wc -c <'whoami.1'`; then
    echo shar: \"'whoami.1'\" unpacked with wrong size!
fi
# end of 'whoami.1'
fi
if test -f 'whoami.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'whoami.c'\"
else
echo shar: Extracting \"'whoami.c'\" \(347 characters\)
sed "s/^X//" >'whoami.c' <<'END_OF_FILE'
X/* whoami.c: clone of whoami program
Daniel J. Bernstein, brnstnd@nyu.edu.
Depends on username.h.
Requires puts() and geteuid().
X7/22/91: Baseline. whoami 1.0, public domain.
No known patent problems.
X
Documentation in whoami.1.
X*/
X
X#include "username.h"
X
main()
X{
X char *username;
X uid2username(geteuid(),&username);
X puts(username);
X exit(0);
X}
END_OF_FILE
if test 347 -ne `wc -c <'whoami.c'`; then
    echo shar: \"'whoami.c'\" unpacked with wrong size!
fi
# end of 'whoami.c'
fi
if test -f 'wtmprotate.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wtmprotate.8'\"
else
echo shar: Extracting \"'wtmprotate.8'\" \(464 characters\)
sed "s/^X//" >'wtmprotate.8' <<'END_OF_FILE'
X.TH wtmprotate 8
X.SH NAME
wtmprotate \- rotate /usr/adm/wtmp logs
X.SH SYNOPSIS
X.B wtmprotate
X.SH DESCRIPTION
X.B wtmprotate
saves a copy of /usr/adm/wtmp in
X/usr/adm/wtmp.0, then clears
X/usr/adm/wtmp.
It saves the old wtmp.0 in wtmp.1,
the old wtmp.1 in wtmp.2, and so on
up to wtmp.7.
Any previous wtmp.7 is removed.
X
X.B wtmprotate
should be run from a weekly or monthly
X.B cron
script
to prevent
X/usr/adm/wtmp
from filling up the disk.
X.SH "SEE ALSO"
utmpinit(8)
END_OF_FILE
if test 464 -ne `wc -c <'wtmprotate.8'`; then
    echo shar: \"'wtmprotate.8'\" unpacked with wrong size!
fi
# end of 'wtmprotate.8'
fi
if test -f 'wtmprotate.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wtmprotate.sh'\"
else
echo shar: Extracting \"'wtmprotate.sh'\" \(487 characters\)
sed "s/^X//" >'wtmprotate.sh' <<'END_OF_FILE'
WARNING: Do not change this file without changing Makefile accordingly!
X#include <utmp.h>
X#include "config/wtmpfile.h"
XX!/bin/sh
XX if you want to save WTMP_FILE.7, do it now!
mv WTMP_FILE.6 WTMP_FILE.7
mv WTMP_FILE.5 WTMP_FILE.6
mv WTMP_FILE.4 WTMP_FILE.5
mv WTMP_FILE.3 WTMP_FILE.4
mv WTMP_FILE.2 WTMP_FILE.3
mv WTMP_FILE.1 WTMP_FILE.2
mv WTMP_FILE.0 WTMP_FILE.1
ln WTMP_FILE WTMP_FILE.0
cp WTMP_FILE WTMP_FILE.new; : > WTMP_FILE.new
chmod 644 WTMP_FILE.new; mv WTMP_FILE.new WTMP_FILE
END_OF_FILE
if test 487 -ne `wc -c <'wtmprotate.sh'`; then
    echo shar: \"'wtmprotate.sh'\" unpacked with wrong size!
fi
# end of 'wtmprotate.sh'
fi
echo shar: End of archive 1 \(of 9\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 9 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
