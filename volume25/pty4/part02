Newsgroups: comp.sources.unix
From: brnstnd@nyu.edu (Dan Bernstein)
Subject: v25i128: Generalized interface to pseudo-tty devices, Part02/09
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: brnstnd@nyu.edu (Dan Bernstein)
Posting-Number: Volume 25, Issue 128
Archive-Name: pty4/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 9)."
# Contents:  COPYRIGHT FILES FORMLETTER biff.1 condom.1 disconnect.1
#   disconnect.c getoptquiet.c lock.c ptyerr.c ptylogs.c ptymisc.c
#   ptytty.h reconnect.1 reconnect.c script.1 sess.1 sessconnlog.c
#   sesskill.1 sesskill.c sesslog.c sesswhere.1 sesswhere.c sesswho.1
#   sesswho.c sigdfl.3 tplay.c trecord.1 trecord.c tscript.1
#   ttydetach.c ttydfl.7 username.c users.c wall.c who.1 write.1
# Wrapped by vixie@cognition.pa.dec.com on Wed Feb 19 13:35:02 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'COPYRIGHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COPYRIGHT'\"
else
echo shar: Extracting \"'COPYRIGHT'\" \(2170 characters\)
sed "s/^X//" >'COPYRIGHT' <<'END_OF_FILE'
pty version 4.0, February 9, 1992.
Copyright (c) 1992, Daniel J. Bernstein.
All rights reserved.
X
I want this program to be distributed freely in original form.
X
Once you've received a legal copy of this program, you can use it.
XForever. Nobody can take that right away from you. You can make changes
and backup copies for your use (or, if you're an organization, for the
use of everyone in the organization). You can distribute patches (though
not patched versions). You'd have all these rights even if I didn't tell
you about them.
X
Copyright law gives an author the exclusive right to copy and distribute his
works. So that you don't have to worry about these legalities, I grant you the
right to make and distribute exact and complete copies of this program.
X
On the other hand, I don't want this program sold without my permission.
Unless I give you permission, you may not charge for copies. You may charge for
distribution---but only if you first warn the recipient that the code is free,
and tell him where you got it from.
X
I don't want this program distributed without my name on it. I also don't
want lots of different versions running around, so unless I give you permission
you can't send out a modified version. It's perfectly all right to send other
people a description of how to make your changes (i.e., a patch), because then
each recipient knows firsthand what patches he's installed, and I won't go
chasing ghosts. (An author has no right to control patches in any case.)
X
If you run an archive site: When you receive a patch supposedly from me, do you
apply it to the original package and repackage it? I encourage you to change
your policy, if for no other reason than to give recipients a fallback in case
of buggy patches. If you're really set on this, how about including the patches
as separate, unapplied PATCHnn files inside the package? That's fine by me.
X
If you have questions about this program or about this notice, or if you
would like additional rights beyond those granted above, or if you have
a patch that you don't mind sharing, please contact me on the Internet
at brnstnd@nyu.edu. Special arrangements are available for vendors.
END_OF_FILE
if test 2170 -ne `wc -c <'COPYRIGHT'`; then
    echo shar: \"'COPYRIGHT'\" unpacked with wrong size!
fi
# end of 'COPYRIGHT'
fi
if test -f 'FILES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FILES'\"
else
echo shar: Extracting \"'FILES'\" \(1824 characters\)
sed "s/^X//" >'FILES' <<'END_OF_FILE'
BLURB
README
XFORMLETTER
SYSCONF
WTF
CALLS
CHANGES
COPYRIGHT
XFILES
OBJECTS
BINARIES
Makefile
TESTS
NEW
NOTES
IMPACT
SECURITY
pty.1
pty-basic.1
pty-opts.1
sess.1
condom.1
QUESTIONS
SESS.draft2
ULOGS.draft1
JOBCTRL.draft3
CTTYS.draft1
CHECKCONF.c
INSTALL.c
argv0.1
argv0.c
biff.1
biff.c
config
checkptys.8
checkptys.c
ctrlv.c
disconnect.1
disconnect.c
env.c
env.h
exclon.1
exclon.c
excloff.c
fmt.c
fmt.h
getopt.c
getopt.h
getoptquiet.c
getoptquiet.h
lock.1
lock.c
mesg.1
mesg.c
nobuf.sh
ptycomm.c
ptycomm.h
ptyerr.c
ptyerr.h
ptyget.c
ptyget.h
ptylogs.c
ptylogs.h
ptymain.c
ptymaster.c
ptymaster.h
ptymisc.c
ptymisc.h
ptysecure.c
ptysecure.h
ptysigler.c
ptysigler.h
ptyslave.c
ptyslave.h
ptytexts.c
ptytexts.h
ptytty.c
ptytty.h
radixsort.3
radixsort.c
radixsort.h
ralloc.c
ralloc.h
reconnect.1
reconnect.c
scan.c
scan.h
sclogrotate.sh
scnowinit.sh
script.1
script.sh
script.tidy.1
script.tidy.sh
sess.sh
sessconnlog.c
sessconnlog.h
sesskill.1
sesskill.c
sesslist.1
sesslist.c
sesslog.c
sesslog.h
sessmenu.1
sessmenu.c
sessname.1
sessname.c
sessnowinit.sh
sessrotate.sh
sesswhere.1
sesswhere.c
sesswho.1
sesswho.c
sigdfl.3
sigdfl.c
sigdfl.h
sigsched.3
sigsched.c
sigsched.h
sod.h
talkacros.7
timer.c
timer.h
tiocsti.1
tiocsti.c
tplay.1
tplay.c
trecord.1
trecord.c
tscript.1
tscript.sh
tty.1
tty.c
ttydetach.1
ttydetach.c
ttydfl.7
ttyprotect.sh
username.c
username.h
users.1
users.c
utmpinit.8
utmpinit.c
waitfor.1
waitfor.c
wall.1
wall.c
who.1
who.c
whoami.1
whoami.c
write.1
write.c
wtmprotate.8
wtmprotate.sh
config/devmty.h
config/devsty.h
config/fdsettrouble.h
config/genericptr.h
config/posix.h
config/ptybin.h
config/ptydir.h
config/ptyext.h
config/ptygroup.h
config/ptylongname.h
config/ptymodes.h
config/ptyopts.h
config/sessconnfile.h
config/sessfile.h
config/sysv.h
config/ttyopts.h
config/utmpfile.h
config/wtmpfile.h
END_OF_FILE
if test 1824 -ne `wc -c <'FILES'`; then
    echo shar: \"'FILES'\" unpacked with wrong size!
fi
# end of 'FILES'
fi
if test -f 'FORMLETTER' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FORMLETTER'\"
else
echo shar: Extracting \"'FORMLETTER'\" \(826 characters\)
sed "s/^X//" >'FORMLETTER' <<'END_OF_FILE'
To: brnstnd@nyu.edu (Dan Bernstein)
XFrom: 
Date: 
Subject: pty 4.0 FORMLETTER
X
Package: pty 4.0, 2/9/92 release
Obtained from (e.g., uunet.uu.net): 
Obtained by (e.g., ftp): 
X
X1. Machine architecture (e.g., Sun 4/280): 
X2. Operating system (e.g., SunOS 4.1): 
X3. OS vendor (e.g., Sun): 
X4. Does pty work on your machine so far? 
X5. What's CC in your Makefile?
X   CC=
X
X6. If you had to manually edit config/*, what changes did you make?
X   (If you don't remember, here's an easy way out: make CHECKCONF;
X   run CHECKCONF; insert CHECKCONF's output below.)
X
X
X
X7. Describe any problems you've had with pty.
X
X
X
X8. What do you think of the compile/install procedure? SYSCONF,
X   config/*, CHECKCONF, INSTALL, checkptys? How could these be made
X   easier to use?
X
X
X
X9. Any further questions, comments, or suggestions?
X
X
X
Your name:
END_OF_FILE
if test 826 -ne `wc -c <'FORMLETTER'`; then
    echo shar: \"'FORMLETTER'\" unpacked with wrong size!
fi
# end of 'FORMLETTER'
fi
if test -f 'biff.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'biff.1'\"
else
echo shar: Extracting \"'biff.1'\" \(957 characters\)
sed "s/^X//" >'biff.1' <<'END_OF_FILE'
X.TH biff 1
X.SH NAME
biff \- be notified if mail arrives and who it is from
X.SH SYNOPSIS
X.B biff
X[
X.B n
X] [
X.B y
X]
X.SH DESCRIPTION
After
X.B biff y,
the system will display
the top of incoming mail on your screen,
as described in
X.B comsat(8).
X.B biff n
turns this off.
X.B biff
applies to your current terminal session;
typically you'd put a
X.B biff y
into your
X.I \&.login,
X.I \&.cshrc,
or
X.I \&.profile.
X
X.B biff
without an argument tells you your current
X``biffing'' status.
X
The mail notification enabled by
X.B biff
operates asynchronously.
XFor synchronous notification use the MAIL variable of
X.B sh (1)
or the mail
variable of
X.B csh (1).
X
X.B biff
requires its input to be your terminal session
X(or at least a session you own). All it really
does is handle the owner-execute bit on the terminal.
X
X.B biff
only looks at the first letter of its first argument.
X
X.B biff
was named after a dog at Berkeley.
X.SH "SEE ALSO"
csh(1),
sh(1),
mail(1),
comsat(8C)
END_OF_FILE
if test 957 -ne `wc -c <'biff.1'`; then
    echo shar: \"'biff.1'\" unpacked with wrong size!
fi
# end of 'biff.1'
fi
if test -f 'condom.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'condom.1'\"
else
echo shar: Extracting \"'condom.1'\" \(1755 characters\)
sed "s/^X//" >'condom.1' <<'END_OF_FILE'
X.TH condom 1
X.SH NAME
condom \- wrap a pseudo-terminal around a program
X.SH SYNOPSIS
X.B condom
X.I program
X.B [
X.I arg ...
X.B ]
X
X.B ttyprotect
X.I program
X.B [
X.I arg ...
X.B ]
X.SH DESCRIPTION
X.B condom,
which is really just
X.B pty -0,
runs a program under a pseudo-terminal
with as little interpretation as possible.
X.B ttyprotect
is an alternate name for
X.B condom.
The following are the most noticeable effects of
X.B condom:
X
X1. The
X.B stdio(3)
routines
will, by default,
line-buffer their output rather than
waiting for a big block of output
to accumulate.
X
X2.
X.B condom
always exits with exit code 0,
provided nothing unusual happens.
X
X3.
The original terminal
is always in line-by-line,
echo mode (or whatever mode it is
in originally).
X
X4.
XEnd-of-file
in the input does not result in an end-of-file for
X.I program.
X(This is an inherent and unfortunate restriction
of the current pseudo-terminal design.)
The
X.B nobuf(1)
wrapper does transmit end-of-file.
X
X5.
If
X.I program
refers to /dev/tty,
it will see the pseudo-terminal
X(i.e., its input and output)
rather than its original terminal.
X
X6.
Various signals
to
X.B condom
will be forwarded to
X.I program
as HUPs instead.
X
X.B condom
is most useful for making sure that
X.I program
does not affect the
tty in any strange way,
particularly during debugging.
It is also useful for its effect on buffering:
several
X.B condoms
may appear in a pipeline.
XFor instance,
X
X.EX
last | condom grep phoenix | more
X.EE
X
provides much faster turnaround than the same pipeline without
X.B condom,
as
the
X.B grep
no longer buffers its output.
X
XFor a more complete description of
X.B pty,
see the
X.B pty(1),
X.B pty-basic(1),
and
X.B pty-opts(1)
man pages.
X.SH "SEE ALSO"
pty(1),
pty-basic(1),
pty-opts(1),
setbuf(3),
pty(4)
END_OF_FILE
if test 1755 -ne `wc -c <'condom.1'`; then
    echo shar: \"'condom.1'\" unpacked with wrong size!
fi
# end of 'condom.1'
fi
if test -f 'disconnect.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'disconnect.1'\"
else
echo shar: Extracting \"'disconnect.1'\" \(1070 characters\)
sed "s/^X//" >'disconnect.1' <<'END_OF_FILE'
X.TH disconnect 1
X.SH NAME
disconnect \- disconnect current pty session
X.SH SYNOPSIS
X.B disconnect
X[
X.B\-s\fIext
X]
X.SH DESCRIPTION
X.B disconnect
disconnects the current
session,
as if the connection
had been hung up.
Later you can use
X.B reconnect
to get back to the session
exactly where you left off.
X
X.B disconnect
doesn't actually hang up the connection.
If you have previously specified a
X.B reconnect
for the connection,
it will take effect immediately.
X
You can switch rapidly from session
X.I xx
to disconnected session
X.I zz
by typing
X
X.EX
reconnect zz;disconnect
X.EE
X
Then
X.I xx
and
X.I zz
will be reversed,
and you can switch back and forth without trouble.
X
Normally
X.B disconnect
disconnects the session specified by environment variable PTY.
Given
X.B\-s\fIext,
it will instead disconnect session
X.I ext.
X
Note that, unlike the previous version of
X.B disconnect,
this version guarantees that
the session will be disconnected
before it exits,
unless it fails with an error message.
X.SH DIAGNOSTICS
Self-explanatory.
X.SH "SEE ALSO"
pty(1),
sess(1),
reconnect(1)
END_OF_FILE
if test 1070 -ne `wc -c <'disconnect.1'`; then
    echo shar: \"'disconnect.1'\" unpacked with wrong size!
fi
# end of 'disconnect.1'
fi
if test -f 'disconnect.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'disconnect.c'\"
else
echo shar: Extracting \"'disconnect.c'\" \(1593 characters\)
sed "s/^X//" >'disconnect.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "ptymisc.h"
X#include "ptycomm.h"
X#include "config/ptydir.h"
X#include "getopt.h"
X#include "env.h"
X
main(argc,argv)
int argc;
char *argv[];
X{
X int opt;
X int uid;
X char *ext;
X int fdcomm;
X char resp6[6];
X
X uid = getuid();
X ext = env_get("PTY");
X while ((opt = getopt(argc,argv,"s:")) != opteof)
X   switch(opt)
X    {
X     case 's':
X       ext = optarg;
X       break;
X     case '?':
X     default:
X       exit(1);
X    }
X argc -= optind;
X argv += optind;
X
X if (!ext)
X  {
X   fprintf(stderr,"%s: fatal: no -s specified, and PTY not set; are we under a session?\n",optprogname);
X   exit(2);
X  }
X
X if (chdir(PTYDIR) == -1)
X  {
X   fprintf(stderr,"%s: fatal: cannot change to session directory %s\n",optprogname,PTYDIR);
X   exit(2);
X  }
X
X fdcomm = comm_write(ext,uid);
X if (fdcomm == -1)
X  {
X   fprintf(stderr,"%s: fatal: cannot find session %s; if it exists, do you own it?\n",optprogname,ext);
X   exit(2);
X  }
X if (bwrite(fdcomm,"d",1) < 1)
X  {
X   close(fdcomm);
X   fprintf(stderr,"%s: weird: session %s refuses to listen\n",optprogname,ext);
X   exit(2);
X  }
X if (bread(fdcomm,resp6,6) < 6)
X  {
X   close(fdcomm);
X   fprintf(stderr,"%s: weird: session %s refuses to respond\n",optprogname,ext);
X   exit(2);
X  }
X close(fdcomm);
X
X if (respeq(resp6,"kinky!"))
X  {
X   fprintf(stderr,"%s: fatal: pty %s does not support disconnects\n",optprogname,ext);
X   exit(2);
X  }
X if (respeq(resp6,"no-op!"))
X  {
X   fprintf(stderr,"%s: warning: session %s already disconnected\n",optprogname,ext);
X   exit(2);
X  }
X
X if (!respeq(resp6,"yessir"))
X   ; /* unrecognized reply code */
X
X exit(0);
X}
END_OF_FILE
if test 1593 -ne `wc -c <'disconnect.c'`; then
    echo shar: \"'disconnect.c'\" unpacked with wrong size!
fi
# end of 'disconnect.c'
fi
if test -f 'getoptquiet.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getoptquiet.c'\"
else
echo shar: Extracting \"'getoptquiet.c'\" \(1642 characters\)
sed "s/^X//" >'getoptquiet.c' <<'END_OF_FILE'
X/* XXX: this file shouldn't exist */
X
X#include <stdio.h> /* for EOF and stderr---talk about immodularity! */
X#include "getoptquiet.h"
X
int optind = 1;
int optpos = 0;
int opterr = 1;
char *optarg = 0;
int optproblem = 0;
char *optprogname = 0;
int opteof = EOF;
X
int getopt(argc,argv,opts)
int argc;
char **argv;
char *opts;
X{
X int c;
X char *s;
X
X optarg = 0;
X if (!optprogname)
X  {
X   optprogname = *argv;
X   if (!optprogname) /* oh boy */
X     optprogname = ""; /*XXX*/
X   for (s = optprogname;*s;++s)
X     if (*s == '/')
X       optprogname = s + 1;
X  }
X if (!argv || (optind >= argc) || !argv[optind])
X   return opteof;
X while (optpos && !argv[optind][optpos])
X  {
X   /* we simply skip blank arguments... not any more */
X   ++optind;
X   optpos = 0;
X   if ((optind >= argc) || !argv[optind])
X     return opteof;
X  }
X if (!optpos)
X  {
X   if (argv[optind][0] != '-')
X     return opteof;
X   ++optpos;
X   c = argv[optind][1];
X   if ((c == '-') || (c == 0))
X    {
X     /* XXX: this behavior of "-" is stupid */
X     if (c)
X       ++optind;
X     optpos = 0;
X     return opteof;
X    }
X   /* otherwise c is reassigned below */
X  }
X c = argv[optind][optpos];
X ++optpos;
X s = opts;
X while (*s)
X  {
X   if (c == *s)
X    {
X     if (s[1] == ':')
X      {
X       optarg = argv[optind] + optpos;
X       ++optind;
X       optpos = 0;
X       if (!*optarg)
X        {
X         optarg = argv[optind];
X         if ((optind >= argc) || !optarg) /* argument past end */
X          {
X           optproblem = c;
X           return '?';
X          }
X	 ++optind;
X        }
X      }
X     return c;
X    }
X   ++s;
X   if (*s == ':')
X     ++s;
X  }
X optproblem = c;
X return '?';
X}
END_OF_FILE
if test 1642 -ne `wc -c <'getoptquiet.c'`; then
    echo shar: \"'getoptquiet.c'\" unpacked with wrong size!
fi
# end of 'getoptquiet.c'
fi
if test -f 'lock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lock.c'\"
else
echo shar: Extracting \"'lock.c'\" \(990 characters\)
sed "s/^X//" >'lock.c' <<'END_OF_FILE'
X/* lock.c: clone of lock program
Daniel J. Bernstein, brnstnd@nyu.edu.
No dependencies.
Requires curses and signal, i.e., UNIX.
X7/27/91: Baseline. lock 2.0, public domain.
No known patent problems.
X
Documentation in lock.1.
X
Derived from version of lock included with pty 3.0.
X*/
X
X#include <curses.h>
X#include <signal.h>
X
main()
X{
X char key[100];
X char key2[100];
X int i;
X
X for (i = 1;i < 32;++i) /*XXX*/
X   signal(i,SIG_IGN);
X savetty();
X crmode();
X noecho();
X printf("Key: "); fflush(stdout);
X if (fgets(key,sizeof(key) - 2,stdin))
X  {
X   printf("\nAgain: "); fflush(stdout);
X   if (fgets(key2,sizeof(key2) - 2,stdin))
X     if (!strcmp(key,key2))
X      {
X       printf("\n"); fflush(stdout);
X       while ((fgets(key2,sizeof(key2),stdin) == NULL) || strcmp(key,key2))
X	{
X	 printf("Bad password!\n");
X	 for (i = 0;i < 20;++i)
X	   putchar(7);
X	 fflush(stdout);
X	 sleep(1);
X	}
X      }
X     else printf("\n%c",7);
X   else printf("\n%c",7);
X  }
X else printf("\n%c",7);
X resetty();
X exit(0);
X}
END_OF_FILE
if test 990 -ne `wc -c <'lock.c'`; then
    echo shar: \"'lock.c'\" unpacked with wrong size!
fi
# end of 'lock.c'
fi
if test -f 'ptyerr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptyerr.c'\"
else
echo shar: Extracting \"'ptyerr.c'\" \(955 characters\)
sed "s/^X//" >'ptyerr.c' <<'END_OF_FILE'
X#include "getoptquiet.h"
X#include "fmt.h"
X#include "ptyerr.h"
X#include "ralloc.h"
X
void die(n)
int n;
X{
X _exit(n);
X}
X
static int flagwarning = 1;
X
void warn_disable()
X{
X flagwarning = 0;
X}
X
void warn(level,problem)
char *level;
char *problem;
X{
X char *buf;
X
X if (!flagwarning)
X   return;
X if (!optprogname)
X   optprogname = "pty";
X buf = ralloc(strlen(optprogname) + strlen(level) + strlen(problem) + 10);
X if (!buf)
X  {
X   write(2,optprogname,strlen(optprogname));
X   write(2,": ",2);
X   write(2,level,strlen(level));
X   write(2,": ",2);
X   write(2,problem,strlen(problem));
X   write(2,"\r\n",2);
X  }
X else
X  {
X   char *t; t = buf;
X   t += fmt_strncpy(t,optprogname,0);
X   t += fmt_strncpy(t,": ",0);
X   t += fmt_strncpy(t,level,0);
X   t += fmt_strncpy(t,": ",0);
X   t += fmt_strncpy(t,problem,0);
X   t += fmt_strncpy(t,"\r\n",0);
X   *t = 0;
X   write(2,buf,strlen(buf));
X   rfree(buf);
X  }
X}
X
void info(text)
char *text;
X{
X write(2,text,strlen(text));
X}
END_OF_FILE
if test 955 -ne `wc -c <'ptyerr.c'`; then
    echo shar: \"'ptyerr.c'\" unpacked with wrong size!
fi
# end of 'ptyerr.c'
fi
if test -f 'ptylogs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptylogs.c'\"
else
echo shar: Extracting \"'ptylogs.c'\" \(2208 characters\)
sed "s/^X//" >'ptylogs.c' <<'END_OF_FILE'
X#include <sys/types.h>
X#include <sys/file.h>
X#include <utmp.h>
X#include "fmt.h"
X#include "config/utmpfile.h"
X#include "config/wtmpfile.h"
X#include "config/sysv.h" /*XXX*/
X#include "ptymisc.h"
X#include "ptylogs.h"
extern int flagxutmp; /*XXX*/
extern int flagxwtmp; /*XXX*/
X
X/* utmp and wtmp make about as much sense as /etc/passwd: not much. */
X
int utmp_on(ext,name,host,date)
char *ext;
char *name;
char *host;
long date;
X{
X struct utmp ut;
X struct utmp xt;
X int fd;
X int i;
X char *t;
X
X if (!flagxutmp)
X   return 0;
X
X /* XXXX: This uses sequential allocation. See utmpinit. */
X
X t = ut.ut_line;
X t += fmt_strncpy(t,"tty",0);
X *t++ = ext[0];
X *t++ = ext[1];
X *t = 0;
X strncpy(ut.ut_name,name,sizeof(ut.ut_name));
X#ifndef SYSV
X strncpy(ut.ut_host,host,sizeof(ut.ut_host));
X#endif
X ut.ut_time = date;
X
X if ((fd = open(UTMP_FILE,O_RDWR)) == -1)
X   return -1;
X
X i = 0;
X while (bread(fd,(char *) &xt,sizeof(xt)) == sizeof(xt)) /* XXX: should buffer */
X  {
X   if (!strncmp(xt.ut_line,ut.ut_line,sizeof(ut.ut_line)))
X    {
X     if (lseek(fd,i * (long) sizeof(xt),L_SET) == -1)
X      {
X       close(fd);
X       return -1;
X      }
X     i = -1;
X     break;
X    }
X   ++i;
X  }
X if (i != -1)
X  {
X   /* We have to reopen to avoid a race with other end-of-utmp entries. */
X   close(fd);
X   if ((fd = open(UTMP_FILE,O_RDWR | O_APPEND)) == -1)
X     return -1;
X  }
X
X if (bwrite(fd,(char *) &ut,sizeof(ut)) < sizeof(ut))
X  {
X   close(fd);
X   return -1;
X  }
X close(fd);
X return 0;
X}
X
int utmp_off(ext,host,date)
char *ext;
char *host;
long date;
X{
X utmp_on(ext,"",host,date);
X}
X
int wtmp_on(ext,name,host,date)
char *ext;
char *name;
char *host;
long date;
X{
X struct utmp wt;
X int fd;
X char *t;
X
X if (!flagxwtmp)
X   return 0;
X
X t = wt.ut_line;
X t += fmt_strncpy(t,"tty",0);
X *t++ = ext[0];
X *t++ = ext[1];
X *t = 0;
X strncpy(wt.ut_name,name,sizeof(wt.ut_name));
X#ifndef SYSV
X strncpy(wt.ut_host,host,sizeof(wt.ut_host));
X#endif
X wt.ut_time = date;
X
X if ((fd = open(WTMP_FILE,O_WRONLY | O_APPEND)) == -1)
X   return -1;
X if (bwrite(fd,(char *) &wt,sizeof(wt)) < sizeof(wt))
X  {
X   close(fd);
X   return -1;
X  }
X close(fd);
X return 0;
X}
X
int wtmp_off(ext,host,date)
char *ext;
char *host;
long date;
X{
X wtmp_on(ext,"",host,date);
X}
END_OF_FILE
if test 2208 -ne `wc -c <'ptylogs.c'`; then
    echo shar: \"'ptylogs.c'\" unpacked with wrong size!
fi
# end of 'ptylogs.c'
fi
if test -f 'ptymisc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptymisc.c'\"
else
echo shar: Extracting \"'ptymisc.c'\" \(2045 characters\)
sed "s/^X//" >'ptymisc.c' <<'END_OF_FILE'
X#include <sys/types.h>
X#include <sys/file.h>
X#include <sys/time.h>
X#include <errno.h>
extern int errno;
X#include <fcntl.h>
X#include "ptymisc.h"
X#include "config/fdsettrouble.h"
X
X#ifdef DESPERATE_FD_SET
X#undef fd_set
X#define fd_set long
X#endif
X
extern long time();
long now()
X{
X return time((long *) 0);
X}
X
int gaargh(n) int n;
X{
X struct timeval t;
X
X t.tv_sec = 0;
X t.tv_usec = n;
X return select(0,(fd_set *) 0,(fd_set *) 0,(fd_set *) 0,&t);
X}
X
int setnonblock(fd)
int fd;
X{
X return fcntl(fd,F_SETFL,fcntl(fd,F_GETFL,0) | FNDELAY); /* XXX */
X}
X
int unsetnonblock(fd)
int fd;
X{
X return fcntl(fd,F_SETFL,fcntl(fd,F_GETFL,0) & ~FNDELAY); /*XXX*/
X}
X
int forceopen(fd)
int fd;
X{
X int fdnull;
X if (fcntl(fd,F_GETFL,0) != -1) /* it's open already */
X   return 0;
X fdnull = open("/dev/null",O_RDWR,0);
X if (fdnull == -1)
X   fdnull = open("/",O_RDONLY,0);
X if (fdnull == -1)
X   return -1;
X if (fdnull != fd)
X  {
X   if (dup2(fdnull,fd) == -1)
X    {
X     close(fdnull);
X     return -1;
X    }
X   close(fdnull);
X  }
X return 0;
X}
X
int respeq(resp,str)
char *resp;
char *str;
X{
X return scan_strncmp(resp,str,6) == 6;
X}
X
int bread(fd,buf,n)
int fd; char *buf; int n;
X{
X int r; int tot; tot = 0;
X while (n)
X  {
X   r = read(fd,buf,n);
X   if (r == 0) break;
X   if (r == -1)
X     if ((errno == EINTR) || (errno == EWOULDBLOCK)) continue;
X     else return -1; /* XXX: losing data! */
X   buf += r; tot += r; n -= r;
X  }
X return tot;
X}
X
int bwrite(fd,buf,n)
int fd; char *buf; int n;
X{
X int w; int tot; tot = 0;
X while (n)
X  {
X   w = write(fd,buf,n);
X   if (w == 0) break; /* XXX: can happen under System V [sigh] */
X   if (w == -1)
X     if ((errno == EINTR) || (errno == EWOULDBLOCK)) continue;
X     else return -1; /* XXX: losing data! */
X   buf += w; tot += w; n -= w;
X  }
X return tot;
X}
X
int lflock(fd)
int fd;
X{
X /* must depend only on write access */
X /* does not need to disappear automatically upon close() */
X /* but should disappear automatically upon crash of any sort */
X return flock(fd,LOCK_EX);
X}
X
int lfunlock(fd)
int fd;
X{
X return flock(fd,LOCK_UN);
X}
END_OF_FILE
if test 2045 -ne `wc -c <'ptymisc.c'`; then
    echo shar: \"'ptymisc.c'\" unpacked with wrong size!
fi
# end of 'ptymisc.c'
fi
if test -f 'ptytty.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptytty.h'\"
else
echo shar: Extracting \"'ptytty.h'\" \(915 characters\)
sed "s/^X//" >'ptytty.h' <<'END_OF_FILE'
X#ifndef PTY_TTY_H
X#define PTY_TTY_H
X
X#include "config/ttyopts.h"
X#include <sys/ioctl.h>
X#ifdef TTY_TERMIO
X#include <sys/termio.h>
X#endif
X
struct ttywin
X {
X#ifdef TTY_WINDOWS
X  struct winsize ws;
X#endif
X  int dummy;
X }
X;
X
struct ttymodes
X {
X#ifdef TTY_TERMIO
X  struct termio ti;
X#else
X  int di; long lb;
X  struct sgttyb sg; struct tchars tc; struct ltchars lt;
X#endif
X  struct ttywin wi;
X#ifdef TTY_AUXCHARS
X  struct auxchars au;
X#endif
X }
X;
X
extern int tty_getctrl();
extern int tty_dissoc();
extern int tty_spaceleft();
extern int tty_setexcl();
extern int tctpgrp();
X
extern int tty_getmodes();
extern int tty_setmodes();
extern int tty_modifymodes();
X
X/* The following don't do any ioctls; they just mangle internal ttymodes. */
X
extern void tty_copymodes();
extern void tty_win2modes();
extern void tty_modes2win();
extern void tty_zeromode();
extern void tty_mungemodes();
extern void tty_initmodes();
X
X#endif
END_OF_FILE
if test 915 -ne `wc -c <'ptytty.h'`; then
    echo shar: \"'ptytty.h'\" unpacked with wrong size!
fi
# end of 'ptytty.h'
fi
if test -f 'reconnect.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'reconnect.1'\"
else
echo shar: Extracting \"'reconnect.1'\" \(1353 characters\)
sed "s/^X//" >'reconnect.1' <<'END_OF_FILE'
X.TH reconnect 1
X.SH NAME
reconnect \- reconnect to a pty session
X.SH SYNOPSIS
X.B reconnect
X[
X.B\-s\fIext
X]
X.I sn
X.SH DESCRIPTION
X.B reconnect
X.I sn
means
X``When this session finishes or is disconnected,
reconnect to the session named
X.I sn.''
This lets you get back to a
session abandoned by
X.B disconnect
or by a previously hung up connection.
X
If you are not currently
under a
X.B pty
session,
or if you would like to reconnect
immediately without waiting for
the current session to finish,
you can use
X
X.EX
sess reconnect sn
X.EE
X
Only the latest
X.B reconnect
matters for a given connection.
If you leave out
X.I sn,
the connection will simply drop
when its association with the
current session is severed.
This is the normal behavior.
X
Normally
X.B reconnect
handles the session specified by environment variable PTY.
Option
X.B\-s\fIext
tells
X.B reconnect
to set up a reconnect for session
X.I ext
instead.
X
Note that, unlike the previous version of
X.B reconnect,
this version lets you specify a reconnect to a session
which does not currently exist.
If the current session exits or is disconnected
before the other session is created,
the reconnection will fail.
X
Note that a session's input and output are handled just
as efficiently after reconnect as before disconnect.
X.SH DIAGNOSTICS
Self-explanatory.
X.SH "SEE ALSO"
pty(1),
sess(1),
disconnect(1)
END_OF_FILE
if test 1353 -ne `wc -c <'reconnect.1'`; then
    echo shar: \"'reconnect.1'\" unpacked with wrong size!
fi
# end of 'reconnect.1'
fi
if test -f 'reconnect.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'reconnect.c'\"
else
echo shar: Extracting \"'reconnect.c'\" \(1812 characters\)
sed "s/^X//" >'reconnect.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "ptymisc.h"
X#include "ptycomm.h"
X#include "config/ptydir.h"
X#include "getopt.h"
X#include "env.h"
X
char noreco[2] = { 0, 0 };
X
main(argc,argv)
int argc;
char *argv[];
X{
X int opt;
X int uid;
X char *ext;
X char *reco;
X int fdcomm;
X char resp6[6];
X
X uid = getuid();
X ext = env_get("PTY");
X while ((opt = getopt(argc,argv,"s:")) != opteof)
X   switch(opt)
X    {
X     case 's':
X       ext = optarg;
X       break;
X     case '?':
X     default:
X       exit(1);
X    }
X argc -= optind;
X argv += optind;
X
X if (!ext)
X  {
X   fprintf(stderr,"%s: fatal: no -s specified, and PTY not set; are we under a session?\n",optprogname);
X   exit(2);
X  }
X
X reco = *argv;
X if (!reco)
X   reco = noreco;
X
X if (chdir(PTYDIR) == -1)
X  {
X   fprintf(stderr,"%s: fatal: cannot change to session directory %s\n",optprogname,PTYDIR);
X   exit(2);
X  }
X
X fdcomm = comm_write(ext,uid);
X if (fdcomm == -1)
X  {
X   fprintf(stderr,"%s: fatal: cannot find session %s; if it exists, do you own it?\n",optprogname,ext);
X   exit(2);
X  }
X if (bwrite(fdcomm,"s",1) < 1)
X  {
X   close(fdcomm);
X   fprintf(stderr,"%s: weird: session %s refuses to listen\n",optprogname,ext);
X   exit(2);
X  }
X if (bwrite(fdcomm,reco,2) < 2)
X  {
X   close(fdcomm);
X   fprintf(stderr,"%s: weird: session %s refuses to listen\n",optprogname,ext);
X   exit(2);
X  }
X if (bread(fdcomm,resp6,6) < 6)
X  {
X   close(fdcomm);
X   fprintf(stderr,"%s: weird: session %s refuses to respond\n",optprogname,ext);
X   exit(2);
X  }
X close(fdcomm);
X
X if (respeq(resp6,"nosglr"))
X  {
X   fprintf(stderr,"%s: fatal: session %s not connected\n",optprogname,ext);
X   exit(2);
X  }
X
X if (!respeq(resp6,"sglrok"))
X   ; /* unrecognized reply code */
X
X fprintf(stderr,"%s: will connect to session %c%c when session %c%c is done\n"
X   ,optprogname,reco[0],reco[1],ext[0],ext[1]);
X exit(0);
X}
END_OF_FILE
if test 1812 -ne `wc -c <'reconnect.c'`; then
    echo shar: \"'reconnect.c'\" unpacked with wrong size!
fi
# end of 'reconnect.c'
fi
if test -f 'script.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'script.1'\"
else
echo shar: Extracting \"'script.1'\" \(1108 characters\)
sed "s/^X//" >'script.1' <<'END_OF_FILE'
X.TH script 1
X.SH NAME
script \- make typescript of terminal session
X.SH SYNOPSIS
X.B script
X[
X.B \-a
X] [
X.I file
X]
X.SH DESCRIPTION
X.B script
makes a typescript of everything printed on your terminal.
The typescript is written to
X.I file,
or appended to
X.I file
if the
X.B \-a
option is given.
You can print it later with
X.B lpr.
If you don't give a filename,
the typescript is saved in the file
X.I typescript.
X
Actually,
this clone version of
X.B script
just passes its options through to
X.B tee,
so you can list multiple files if you want.
X
X.B script
runs whatever shell is in environment variable
X.I SHELL,
default /bin/sh.
This clone version uses
X.B pty
to allocate a pseudo-terminal,
so the session is listed in
X.I /etc/utmp,
and lots of things work right that
didn't work in the original.
XFor example:
X.B talk(1)
works;
X.B mail(1)
works;
you can stop and restart the shell,
with
X.B control-Z
in
X.I sh
or
X.B suspend
in
X.I csh;
and so on.
X
The script ends when the forked shell exits.
This clone version is more careful than the original to
let every last bit of output appear.
X.SH "SEE ALSO"
script.tidy(1)
END_OF_FILE
if test 1108 -ne `wc -c <'script.1'`; then
    echo shar: \"'script.1'\" unpacked with wrong size!
fi
# end of 'script.1'
fi
if test -f 'sess.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sess.1'\"
else
echo shar: Extracting \"'sess.1'\" \(1160 characters\)
sed "s/^X//" >'sess.1' <<'END_OF_FILE'
X.TH sess 1
X.SH NAME
sess \- run a program under a disconnectable pty session
X.SH SYNOPSIS
X.B sess
X.I program
X.B [
X.I arg ...
X.B ]
X.SH DESCRIPTION
X.B sess,
which is really just
X.B pty -s,
runs a program under a pseudo-terminal
session that can be easily disconnected and reconnected.
The session can even be reconnected into the middle of a pipe.
X
See
X.B pty(1),
X.B pty-basic(1),
and
X.B pty-opts(1)
for a description of
X.B pty
and its options.
X
X.B sess
enters the user into
X/etc/utmp by default;
this can be turned off with
X.B\-xU.
X
When
X.B sess
receives a HUP signal,
i.e., when the connection is manually hung up,
it disconnects
X.I program
from the outside world
and waits for a
X.B reconnect.
You can manually disconnect a session with
X.B disconnect.
X
Sessions are named by
their pseudo-terminal extension:
for example,
a session under /dev/ttyp5
has name p5.
You can use
X.B sessname
to give them more descriptive names,
printed by
X.B sesslist.
X
See
X``An introduction to session management''
for a more complete description of the
session manager interface.
X.SH "SEE ALSO"
pty(1),
condom(1),
disconnect(1),
reconnect(1),
sessname(1),
sesskill(1),
sesslist(1)
END_OF_FILE
if test 1160 -ne `wc -c <'sess.1'`; then
    echo shar: \"'sess.1'\" unpacked with wrong size!
fi
# end of 'sess.1'
fi
if test -f 'sessconnlog.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sessconnlog.c'\"
else
echo shar: Extracting \"'sessconnlog.c'\" \(1688 characters\)
sed "s/^X//" >'sessconnlog.c' <<'END_OF_FILE'
X#include <sys/types.h>
X#include <sys/file.h>
X#include "sessconnlog.h"
X#include "ptymisc.h"
X#include "config/sessconnfile.h"
X#include "config/ptyext.h"
X
static int flagsessconnlog = 1;
X
void sessconnlog_disable()
X{
X flagsessconnlog = 0;
X}
X
int sessconnlog(sl)
struct sessconnlog *sl;
X{
X int fdnow;
X int fd;
X int x;
X char *s;
X
X if (!flagsessconnlog)
X   return 0;
X for (x = 0,s = PTYEXT1;*s;++s,x += (sizeof(PTYEXT2) - 1))
X   if (*s == sl->ext[0])
X    {
X     for (s = PTYEXT2;*s;++s,++x)
X       if (*s == sl->ext[1])
X	{
X	 fdnow = open(SESSCONNNOW_FILE,O_WRONLY | O_CREAT,0644);
X	 if (fdnow == -1)
X	   return -1;
X         if (lseek(fdnow,x * (long) sizeof(*sl),L_SET) == -1)
X	  {
X	   close(fdnow);
X	   return -1;
X	  }
X	 if (write(fdnow,(char *) sl,sizeof(*sl)) < sizeof(*sl))
X	  {
X	   close(fdnow); /* XXX: but now sessconnnow is messed up! */
X	   return -1;
X	  }
X	 lflock(fdnow);
X	 fd = open(SESSCONNLOG_FILE,O_WRONLY | O_APPEND | O_CREAT,0644);
X	 if (fd == -1)
X	  {
X	   lfunlock(fdnow);
X	   close(fdnow);
X	   return -1; /* XXX: but now sessconnnow is messed up! */
X	  }
X	 if (write(fd,(char *) sl,sizeof(*sl)) < sizeof(*sl))
X	  {
X	   lfunlock(fdnow);
X	   close(fdnow);
X	   close(fd);
X	   return -1; /* XXX: but now both logs are messed up! */
X	  }
X	 close(fd);
X	 lfunlock(fdnow);
X	 close(fdnow);
X	 return 0;
X	}
X     return -1;
X    }
X return -1;
X}
X
void sessconnlog_fill(sl,ext,remote,siglerpid,date)
struct sessconnlog *sl;
char *ext;
char *remote;
int siglerpid;
long date;
X{
X sl->ext[0] = ext[0];
X sl->ext[1] = ext[1];
X sl->ext[2] = ext[2]; /* requires SESSCONNLOG_EXTLEN be at least 3 */
X strncpy(sl->remote,remote,SESSCONNLOG_REMOTELEN);
X sl->siglerpid = siglerpid;
X sl->date = date;
X}
END_OF_FILE
if test 1688 -ne `wc -c <'sessconnlog.c'`; then
    echo shar: \"'sessconnlog.c'\" unpacked with wrong size!
fi
# end of 'sessconnlog.c'
fi
if test -f 'sesskill.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sesskill.1'\"
else
echo shar: Extracting \"'sesskill.1'\" \(865 characters\)
sed "s/^X//" >'sesskill.1' <<'END_OF_FILE'
X.TH sesskill 1
X.SH NAME
sesskill \- kill current pty session
X.SH SYNOPSIS
X.B sesskill
X[
X.B\-ym
X] [
X.B\-s\fIext
X]
X.SH DESCRIPTION
X.B sesskill
kills the current session.
X.B pty
will exit immediately,
throwing away any final output,
and any process running under the
pseudo-tty will receive a HUP signal.
X
Normally
X.B sesskill
kills the session specified by environment variable PTY.
Given
X.B\-s\fIext,
it will instead kill session
X.I ext.
X
Note that, unlike the previous version of
X.B sesskill,
this version can be applied
to a connected session, a session
where the slave process is still running,
and even a non-session running under
X.B pty.
It is very destructive.
It will, in fact, not take effect unless you specify
X.B\-y.
It will not take effect for the current session unless
you specify
X.B\-m.
X.SH DIAGNOSTICS
Self-explanatory.
X.SH "SEE ALSO"
pty(1),
sess(1)
END_OF_FILE
if test 865 -ne `wc -c <'sesskill.1'`; then
    echo shar: \"'sesskill.1'\" unpacked with wrong size!
fi
# end of 'sesskill.1'
fi
if test -f 'sesskill.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sesskill.c'\"
else
echo shar: Extracting \"'sesskill.c'\" \(1733 characters\)
sed "s/^X//" >'sesskill.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "ptycomm.h"
X#include "config/ptydir.h"
X#include "getopt.h"
X#include "env.h"
X
main(argc,argv)
int argc;
char *argv[];
X{
X int opt;
X int uid;
X char *ext;
X int fdcomm;
X char resp6[6];
X int yes;
X int me;
X
X yes = 0;
X me = 0;
X
X uid = getuid();
X ext = env_get("PTY");
X while ((opt = getopt(argc,argv,"s:ym")) != opteof)
X   switch(opt)
X    {
X     case 'm':
X       me = 1;
X       break;
X     case 'y':
X       yes = 1;
X       break;
X     case 's':
X       ext = optarg;
X       break;
X     case '?':
X     default:
X       exit(1);
X    }
X argc -= optind;
X argv += optind;
X
X if (!ext)
X  {
X   fprintf(stderr,"%s: fatal: no -s specified, and PTY not set; are we under a session?\n",optprogname);
X   exit(2);
X  }
X if (!yes)
X  {
X   fprintf(stderr,"%s: fatal: -y not specified, so no action taken\n",optprogname);
X   exit(2);
X  }
X if (!me && env_get("PTY") && (!strcmp(ext,env_get("PTY"))))
X  {
X   fprintf(stderr,"%s: fatal: that session is us, and -m not specified, so no action taken\n",optprogname);
X   exit(2);
X  }
X
X if (chdir(PTYDIR) == -1)
X  {
X   fprintf(stderr,"%s: fatal: cannot change to session directory %s\n",optprogname,PTYDIR);
X   exit(2);
X  }
X
X fdcomm = comm_write(ext,uid);
X if (fdcomm == -1)
X  {
X   fprintf(stderr,"%s: fatal: cannot find session %s; if it exists, do you own it?\n",optprogname,ext);
X   exit(2);
X  }
X if (write(fdcomm,"k",1) < 1)
X  {
X   close(fdcomm);
X   fprintf(stderr,"%s: weird: session %s refuses to listen\n",optprogname,ext);
X   exit(2);
X  }
X if (read(fdcomm,resp6,6) < 6)
X  {
X   close(fdcomm);
X   fprintf(stderr,"%s: weird: session %s refuses to respond\n",optprogname,ext);
X   exit(2);
X  }
X close(fdcomm);
X
X if (!respeq(resp6,"<poof>"))
X   ; /* unrecognized reply code */
X
X exit(0);
X}
END_OF_FILE
if test 1733 -ne `wc -c <'sesskill.c'`; then
    echo shar: \"'sesskill.c'\" unpacked with wrong size!
fi
# end of 'sesskill.c'
fi
if test -f 'sesslog.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sesslog.c'\"
else
echo shar: Extracting \"'sesslog.c'\" \(1688 characters\)
sed "s/^X//" >'sesslog.c' <<'END_OF_FILE'
X#include <sys/types.h>
X#include <sys/file.h>
X#include "sesslog.h"
X#include "ptymisc.h"
X#include "config/sessfile.h"
X#include "config/ptyext.h"
X
static int flagsesslog = 1;
X
void sesslog_disable()
X{
X flagsesslog = 0;
X}
X
int sesslog(sl)
struct sesslog *sl;
X{
X int fdnow;
X int fd;
X int x;
X char *s;
X
X if (!flagsesslog)
X   return 0;
X for (x = 0,s = PTYEXT1;*s;++s,x += (sizeof(PTYEXT2) - 1))
X   if (*s == sl->ext[0])
X    {
X     for (s = PTYEXT2;*s;++s,++x)
X       if (*s == sl->ext[1])
X	{
X	 fdnow = open(SESSNOW_FILE,O_WRONLY | O_CREAT,0644);
X	 if (fdnow == -1)
X	   return -1;
X         if (lseek(fdnow,x * (long) sizeof(*sl),L_SET) == -1)
X	  {
X	   close(fdnow);
X	   return -1;
X	  }
X	 if (write(fdnow,(char *) sl,sizeof(*sl)) < sizeof(*sl))
X	  {
X	   close(fdnow); /* XXX: but now sessnow is messed up! */
X	   return -1;
X	  }
X	 lflock(fdnow); /* XXX: what if it fails? */
X	 fd = open(SESSLOG_FILE,O_WRONLY | O_APPEND | O_CREAT,0644);
X	 if (fd == -1)
X	  {
X	   lfunlock(fdnow);
X	   close(fdnow);
X	   return -1; /* XXX: but now sessnow is messed up! */
X	  }
X	 if (write(fd,(char *) sl,sizeof(*sl)) < sizeof(*sl))
X	  {
X	   lfunlock(fdnow);
X	   close(fdnow);
X	   close(fd);
X	   return -1; /* XXX: but now both logs are messed up! */
X	  }
X	 close(fd);
X	 lfunlock(fdnow);
X	 close(fdnow);
X	 return 0;
X	}
X     return -1;
X    }
X return -1;
X}
X
void sesslog_fill(sl,ext,username,uid,masterpid,date)
struct sesslog *sl;
char *ext;
char *username;
int uid;
int masterpid;
long date;
X{
X sl->ext[0] = ext[0];
X sl->ext[1] = ext[1];
X sl->ext[2] = ext[2]; /* requires SESSLOG_EXTLEN be at least 3 */
X strncpy(sl->username,username,SESSLOG_USERLEN);
X sl->uid = uid;
X sl->masterpid = masterpid;
X sl->date = date;
X}
END_OF_FILE
if test 1688 -ne `wc -c <'sesslog.c'`; then
    echo shar: \"'sesslog.c'\" unpacked with wrong size!
fi
# end of 'sesslog.c'
fi
if test -f 'sesswhere.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sesswhere.1'\"
else
echo shar: Extracting \"'sesswhere.1'\" \(1049 characters\)
sed "s/^X//" >'sesswhere.1' <<'END_OF_FILE'
X.TH sesswhere 1
X.SH NAME
sesswhere \- list connections to pty sessions on the system
X.SH SYNOPSIS
X.B sesswhere
X[
X.B\-rRlL
X] [
X.B\-f\fIfile
X]
X.SH DESCRIPTION
X.B sesswhere
lists all
X.B pty
sessions on the system,
one per line,
including the network addresses they are connected to.
X
Normally
X.B sesswhere
uses the current session-connection log,
typically /usr/adm/scnow.
Under the
X.B\-f\fIfile
option
it will use
X.I file
instead.
X
The
X.B\-r
option
tells
X.B sesswhere
to list the lines in reverse order.
This is most commonly used with
X.B\-f.
X.B\-R
is the default.
X
Given the
X.B\-l
option,
X.B sesswhere
also shows
terminal lines without active
X.B pty
sessions.
X.B\-L
is the default.
X
Note that, in the default configuration, the owner
of a
X.B pty
session can control the information reported
by
X.B sesswhere,
so the output should not be used for security analysis.
X.B sesswhere
will always
print control characters visibly.
X
The system administrator may disable or restrict use of
X.B sesswhere.
X.SH "SEE ALSO"
pty(1),
sess(1),
sesswho(1),
sesslist(1)
END_OF_FILE
if test 1049 -ne `wc -c <'sesswhere.1'`; then
    echo shar: \"'sesswhere.1'\" unpacked with wrong size!
fi
# end of 'sesswhere.1'
fi
if test -f 'sesswhere.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sesswhere.c'\"
else
echo shar: Extracting \"'sesswhere.c'\" \(1808 characters\)
sed "s/^X//" >'sesswhere.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "fmt.h"
X#include "getopt.h"
X#include "sessconnlog.h"
X#include "config/sessconnfile.h"
X
main(argc,argv)
int argc;
char *argv[];
X{
X FILE *fisf;
X struct sessconnlog sl;
X int opt;
X char *file;
X int flaglogouts;
X int flagreverse;
X int revnum;
X
X file = SESSCONNNOW_FILE;
X flaglogouts = 0;
X flagreverse = 0;
X
X while ((opt = getopt(argc,argv,"rRlLf:")) != opteof)
X   switch(opt)
X    {
X     case 'R':
X       flagreverse = 1;
X       break;
X     case 'r':
X       flagreverse = 1;
X       break;
X     case 'l':
X       flaglogouts = 1;
X       break;
X     case 'L':
X       flaglogouts = 0;
X       break;
X     case 'f':
X       file = optarg;
X       break;
X     case '?':
X     default:
X       exit(1);
X    }
X
X fisf = fopen(file,"r");
X if (!fisf)
X  {
X   perror("sesswhere: fatal: cannot open current session-connection file");
X   exit(2);
X  }
X if (flagreverse)
X  {
X   fseek(fisf,0,2);
X   revnum = ftell(fisf) / sizeof(sl);
X   fseek(fisf,sizeof(sl) * --revnum,0);
X  }
X
X while (fread(&sl,sizeof(sl),1,fisf) == 1)
X  {
X   static char outbuf[SESSCONNLOG_REMOTELEN + 100];
X   if (sl.ext[0] && (sl.siglerpid || flaglogouts))
X    {
X     char *t; t = outbuf;
X     *t++ = sl.ext[0]; *t++ = sl.ext[1];
X     t += fmt_strncpy(t,"  ",0);
X     t += fmt_strncpy(t,asctime(localtime(&sl.date)) + 4,12);
X     switch(sl.siglerpid)
X      {
X       case -1:
X	 t += fmt_strncpy(t,"  connect ",0);
X	 t += fmt_vis(t,sl.remote,strlen(sl.remote));
X	 break;
X       case 1:
X	 t += fmt_strncpy(t,"  disconnect",0);
X	 break;
X       case 0:
X	 t += fmt_strncpy(t,"  cleanup",0);
X	 break;
X      }
X     *t++ = '\n';
X     *t = 0;
X     fwrite(outbuf,1,t - outbuf,stdout);
X    }
X   if (flagreverse)
X    {
X     if (fseek(fisf,-2 * sizeof(sl),1) == -1) /*XXX*/
X       break;
X     --revnum; /*XXX: why do we care? */
X    }
X  }
X exit(0);
X}
END_OF_FILE
if test 1808 -ne `wc -c <'sesswhere.c'`; then
    echo shar: \"'sesswhere.c'\" unpacked with wrong size!
fi
# end of 'sesswhere.c'
fi
if test -f 'sesswho.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sesswho.1'\"
else
echo shar: Extracting \"'sesswho.1'\" \(798 characters\)
sed "s/^X//" >'sesswho.1' <<'END_OF_FILE'
X.TH sesswho 1
X.SH NAME
sesswho \- list all pty sessions on the system
X.SH SYNOPSIS
X.B sesswho
X[
X.B\-rRlL
X] [
X.B\-f\fIfile
X]
X.SH DESCRIPTION
X.B sesswho
lists all
X.B pty
sessions on the system,
one per line,
with owners and master process ids.
X
Normally
X.B sesswho
uses the current session log,
typically /usr/adm/sessnow.
Under the
X.B\-f\fIfile
option
it will use
X.I file
instead.
X
The
X.B\-r
option
tells
X.B sesswho
to list the lines in reverse order.
This is most commonly used with
X.B\-f.
X.B\-R
is the default.
X
Given the
X.B\-l
option,
X.B sesswho
also shows
terminal lines without active
X.B pty
sessions.
This shows when those sessions terminated.
X.B\-L
is the default.
X
The system administrator may disable or restrict use of
X.B sesswho.
X.SH "SEE ALSO"
pty(1),
sess(1),
sesswhere(1),
sesslist(1)
END_OF_FILE
if test 798 -ne `wc -c <'sesswho.1'`; then
    echo shar: \"'sesswho.1'\" unpacked with wrong size!
fi
# end of 'sesswho.1'
fi
if test -f 'sesswho.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sesswho.c'\"
else
echo shar: Extracting \"'sesswho.c'\" \(1539 characters\)
sed "s/^X//" >'sesswho.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "getopt.h"
X#include "sesslog.h"
X#include "config/sessfile.h" /* XXX: maybe sesslog should have an iterator? */
X
main(argc,argv)
int argc;
char *argv[];
X{
X FILE *fisf;
X struct sesslog sl;
X int opt;
X char *file;
X int flaglogouts;
X int flagreverse;
X int revnum;
X
X file = SESSNOW_FILE;
X flaglogouts = 0;
X flagreverse = 0;
X
X while ((opt = getopt(argc,argv,"rRlLf:")) != opteof)
X   switch(opt)
X    {
X     case 'R':
X       flagreverse = 1;
X       break;
X     case 'r':
X       flagreverse = 1;
X       break;
X     case 'l':
X       flaglogouts = 1;
X       break;
X     case 'L':
X       flaglogouts = 0;
X       break;
X     case 'f':
X       file = optarg;
X       break;
X     case '?':
X     default:
X       exit(1);
X    }
X
X fisf = fopen(file,"r");
X if (!fisf)
X  {
X   perror("sesswho: fatal: cannot open current session file");
X   exit(2);
X  }
X if (flagreverse)
X  {
X   fseek(fisf,0,2);
X   revnum = ftell(fisf) / sizeof(sl);
X   fseek(fisf,sizeof(sl) * --revnum,0);
X  }
X
X while (fread(&sl,sizeof(sl),1,fisf) == 1)
X  {
X   if (sl.ext[0] && (sl.masterpid || flaglogouts))
X     /* XXX: requires printf with %* */
X     printf(sl.masterpid ? "%c%c  %12.12s  %-*.*s  %d\n"
X			 : "%c%c  %12.12s  %-*.*s  exit\n"
X       ,sl.ext[0],sl.ext[1]
X       ,asctime(localtime(&sl.date)) + 4
X       ,SESSLOG_USERLEN
X       ,SESSLOG_USERLEN
X       ,sl.username
X       ,sl.masterpid
X      );
X   if (flagreverse)
X    {
X     if (fseek(fisf,-2 * sizeof(sl),1) == -1) /*XXX*/
X       break;
X     --revnum; /*XXX: why do we care? */
X    }
X  }
X exit(0);
X}
END_OF_FILE
if test 1539 -ne `wc -c <'sesswho.c'`; then
    echo shar: \"'sesswho.c'\" unpacked with wrong size!
fi
# end of 'sesswho.c'
fi
if test -f 'sigdfl.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sigdfl.3'\"
else
echo shar: Extracting \"'sigdfl.3'\" \(1706 characters\)
sed "s/^X//" >'sigdfl.3' <<'END_OF_FILE'
X.TH sigdfl 3
X.SH NAME
sigdfl \- invoke the default action for a signal
X.SH SYNTAX
X.B #include <sigdfl.h>
X
int \fBsigdfl(\fIsig\fB)\fR;
X
int \fBsigdfl_ttou()\fR;
X.br
int \fBsigdfl_tstp()\fR;
X.br
int \fBsigdfl_ttin()\fR;
X.br
int \fBsigdfl_stop()\fR;
X
int \fBsigdfl_abrt()\fR;
X
int \fIsig\fP;
X.SH DESCRIPTION
X.B sigdfl(\fIsig\fB)
has exactly the same effect as what happens 
if the process isn't blocking
X.I sig,
has SIG_DFL as the handler for
X.I sig,
and then receives
X.I sig.
In the case of stop signals
X(TSTP, TTIN, TTOU, STOP),
X.B sigdfl
will absorb one or more CONT
signals before returning.
X.B sigdfl
is safe against
multithreading.
X
X.B sigdfl
has several interesting uses inside signal handlers.
XFor instance, the handler for SEGV can clean up the tty
and then call
X.B sigdfl(\fRSIGSEGV\fB).
Unlike a simple
X.B abort(),
this doesn't hide the reason for the core dump from the user.
Similar comments apply to the stop signals.
Note that processes handling a stop signal should
take steps to ensure that they are back in the foreground
after
X.B sigdfl
returns.
X
X.B sigdfl
returns 0 normally, -1 with
errno
set in case of various impossible errors.
X
X.B sigdfl_tstp()
is the same as
X.B sigdfl(\fRSIGTSTP\fB).
On systems not supporting
SIGTSTP,
X.B sigdfl_tstp
returns -1 with errno ENOTTY.
Similar comments apply to
X.B sigdfl_stop(),
X.B sigdfl_ttin(),
and
X.B sigdfl_ttou().
X.B sigdfl_abrt()
is a professional version of
X.B abort();
it will dump core with the ABRT signal,
even if an ABRT handler is in place.
X
SIG_DFL
could, in principle, be implemented as
X.B sigdfl.
X.SH VERSION
sigdfl 1.0, July 18, 1991.
X.SH AUTHOR
Placed into the public domain by Daniel J. Bernstein.
X.SH "SEE ALSO"
signal(3),
abort(3)
END_OF_FILE
if test 1706 -ne `wc -c <'sigdfl.3'`; then
    echo shar: \"'sigdfl.3'\" unpacked with wrong size!
fi
# end of 'sigdfl.3'
fi
if test -f 'tplay.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tplay.c'\"
else
echo shar: Extracting \"'tplay.c'\" \(1590 characters\)
sed "s/^X//" >'tplay.c' <<'END_OF_FILE'
X/* tplay.c: play back a tape
Daniel J. Bernstein, brnstnd@nyu.edu.
Depends on sigsched.h, timer.h.
Requires read()/write(), i.e., UNIX.
X7/27/91: Baseline. tplay 1.0, public domain.
No known patent problems.
X
Documentation in tplay.1.
X
X*/
X
X#include "sigsched.h"
X#include "timer.h"
X
static char hdr[8];
static char buf[256];
static timer_clock latest;
static timer_sig tsig;
static int flageof = 0;
X
void doit(n)
int n; /* if nonzero, there's data waiting to be written */
X{
X int r;
X timer_clock now;
X timer_clock diff;
X int x;
X
X while (!flageof)
X  {
X   x = 1 + (unsigned int) (unsigned char) hdr[7];
X   if (n)
X    {
X     n = 0;
X     while (n < x)
X      {
X       r = write(1,buf + n,x - n);
X       if (r <= 0) ; /*XXX*/
X       n += r;
X      }
X    }
X   r = read(0,hdr,8); /* eighth byte is length of data */
X   if (r == -1)
X     ; /*XXX*/
X   if (r < 7)
X     ; /*XXX*/
X   if (r == 7)
X     flageof = 1;
X   else
X    {
X     x = 1 + (unsigned int) (unsigned char) hdr[7];
X     n = 0;
X     while (n < x)
X      {
X       r = read(0,buf + n,x - n);
X       if (r == -1) ; /*XXX*/
X       if (r == 0) ; /*XXX*/
X       n += r;
X      }
X    }
X   diff.usec = (hdr[2] * 256 + hdr[1]) * 256 + hdr[0];
X   diff.sec = ((hdr[6] * 256 + hdr[5]) * 256 + hdr[4]) * 256 + hdr[3];
X   if (diff.sec || diff.usec)
X    {
X     now = latest; /*XXX: structure copying */
X     timer_sum(&now,&diff,&latest);
X     timer_setsig(&tsig,TIMER_REAL,&latest);
X     ss_schedonce(&tsig.sig,doit,1);
X     break;
X    }
X  }
X}
X
main()
X{
X timer_now(TIMER_REAL,&latest);
X ss_schedonce(ss_asap(),doit,0);
X timer_init();
X ss_exec();
X exit(0);
X}
END_OF_FILE
if test 1590 -ne `wc -c <'tplay.c'`; then
    echo shar: \"'tplay.c'\" unpacked with wrong size!
fi
# end of 'tplay.c'
fi
if test -f 'trecord.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'trecord.1'\"
else
echo shar: Extracting \"'trecord.1'\" \(904 characters\)
sed "s/^X//" >'trecord.1' <<'END_OF_FILE'
X.TH trecord 1
X.SH NAME
trecord \- tape-record input
X.SH SYNTAX
X.B trecord
X.SH DESCRIPTION
X.B trecord
records its input, including timing information,
and sends the resulting
X.I tape
to its output.
The tape can be played with
X.B tplay.
X
A useful idiom is
X.PP
X.EX
trecord | tee tapefile | tplay
X.EE
X.PP
which copies its input to its output,
meanwhile tape-recording the input in
X.I tapefile.
X
The (machine-independent)
X.I tape
format is any number of
X7-byte records separated by variable-length records.
XEach 7-byte record consists of three bytes giving a microsecond
delay, low byte first, and four bytes giving a second delay, low
byte first. A variable-length record of length
X.I n + 2
has first byte
X.I n
and contains actual data
in the remaining
X.I n + 1
bytes.
X.SH VERSION
trecord version 1.0, 7/27/91.
X.SH AUTHOR
Placed into the public domain by Daniel J. Bernstein.
X.SH "SEE ALSO"
tplay(1),
tee(1)
END_OF_FILE
if test 904 -ne `wc -c <'trecord.1'`; then
    echo shar: \"'trecord.1'\" unpacked with wrong size!
fi
# end of 'trecord.1'
fi
if test -f 'trecord.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'trecord.c'\"
else
echo shar: Extracting \"'trecord.c'\" \(1106 characters\)
sed "s/^X//" >'trecord.c' <<'END_OF_FILE'
X/* trecord.c: tape-record the input
Daniel J. Bernstein, brnstnd@nyu.edu.
Depends on timer.h.
Requires read()/write(), i.e., UNIX.
X7/27/91: Baseline. trecord 1.0, public domain.
No known patent problems.
X
Documentation in trecord.1.
X*/
X
X#include "timer.h"
X
static char buf[8 + 256];
X
main()
X{
X timer_clock latest;
X timer_clock now;
X timer_clock diff;
X int r;
X int n;
X int w;
X
X if (timer_now(TIMER_REAL,&latest) == -1)
X   ; /*XXX*/
X do
X  {
X   r = read(0,buf + 8,sizeof(buf) - 8);
X   if (r == -1)
X     ; /*XXX*/
X   if (timer_now(TIMER_REAL,&now) == -1)
X     ; /*XXX*/
X   if (timer_diff(&now,&latest,&diff) < 0)
X     ; /* time warp! */
X   latest = now;
X   buf[0] = diff.usec & 255;
X   buf[1] = (diff.usec / 256) & 255;
X   buf[2] = (diff.usec / 65536) & 255;
X   buf[3] = diff.sec & 255;
X   buf[4] = (diff.sec / 256) & 255;
X   buf[5] = (diff.sec / 65536) & 255;
X   buf[6] = (diff.sec / 16777216) & 255;
X   buf[7] = r - 1;
X   r += 8;
X   if (r == 8)
X     r = 7;
X   n = 0;
X   while (n < r)
X    {
X     w = write(1,buf + n,r - n);
X     if (w < 0)
X       ; /*XXX*/
X     n += w;
X    }
X  }
X while (r != 7);
X exit(0);
X}
END_OF_FILE
if test 1106 -ne `wc -c <'trecord.c'`; then
    echo shar: \"'trecord.c'\" unpacked with wrong size!
fi
# end of 'trecord.c'
fi
if test -f 'tscript.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tscript.1'\"
else
echo shar: Extracting \"'tscript.1'\" \(829 characters\)
sed "s/^X//" >'tscript.1' <<'END_OF_FILE'
X.TH tscript 1
X.SH NAME
tscript \- make tape of terminal session
X.SH SYNOPSIS
X.B tscript
X[
X.B \-a
X] [
X.I file ...
X]
X.SH DESCRIPTION
X.B tscript
makes a tape of everything printed on your terminal.
The tape is written to the named
X.I file\fRs,
or appended to
X.I file
if the
X.B \-a
option is given.
If you don't give a filename,
the tape is saved in the file
X.I tapescript.
X
The difference between
X.B tscript
and
X.B script
is that
X.B tscript
records the time between characters.
While
X.B script
produces a human-readable record,
the output of
X.B tscript
must be played back with
X.B tplay.
X
X.B tscript
runs whatever shell is in environment variable
X.I SHELL, default /bin/sh.
The tape ends when the forked shell exits.
X
Note that
X.B tscript
requires both
X.B tplay
and
X.B trecord
to run.
X.SH "SEE ALSO"
script(1),
tplay(1),
trecord(1)
END_OF_FILE
if test 829 -ne `wc -c <'tscript.1'`; then
    echo shar: \"'tscript.1'\" unpacked with wrong size!
fi
# end of 'tscript.1'
fi
if test -f 'ttydetach.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ttydetach.c'\"
else
echo shar: Extracting \"'ttydetach.c'\" \(1126 characters\)
sed "s/^X//" >'ttydetach.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <sys/file.h>
X#include <sys/ioctl.h>
X#include <errno.h>
extern int errno;
X#include "env.h"
X#include "config/posix.h"
X
main(argc,argv)
int argc;
char *argv[];
X{
X int fd;
X int dummy;
X if (argc < 2)
X  {
X   fputs("Usage: ttydetach program [ arg ... ]\n",stderr);
X   exit(1);
X  }
X if (env_unset("PTY") == -1)
X  {
X   fputs("ttydetach: fatal: out of memory\n",stderr);
X   exit(2);
X  }
X fd = open("/dev/tty",O_RDWR);
X if (fd == -1)
X  {
X   if (errno == EBUSY) /* damn! */
X    {
X     if ((ioctl(0,TIOCNOTTY,0) == -1)
X       &&(ioctl(1,TIOCNOTTY,0) == -1)
X       &&(ioctl(2,TIOCNOTTY,0) == -1)
X       &&(ioctl(3,TIOCNOTTY,0) == -1)
X       )
X     fputs("ttydetach: warning: unable to detach from tty: exclusive-use set\n",stderr);
X       /* but it's not as if we didn't try... */
X    }
X  }
X else
X  {
X   if (ioctl(fd,TIOCNOTTY,0) == -1)
X     perror("ttydetach: warning: unable to detach from tty");
X   close(fd);
X  }
X if (ioctl(3,TIOCGPGRP,&dummy) == -1)
X   close(3);
X#ifdef POSIX_SILLINESS /* XXX: sigh... */
X setsid();
X#endif
X execvp(argv[1],argv + 1);
X perror("ttydetach: fatal: cannot execute");
X exit(4);
X}
END_OF_FILE
if test 1126 -ne `wc -c <'ttydetach.c'`; then
    echo shar: \"'ttydetach.c'\" unpacked with wrong size!
fi
# end of 'ttydetach.c'
fi
if test -f 'ttydfl.7' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ttydfl.7'\"
else
echo shar: Extracting \"'ttydfl.7'\" \(1331 characters\)
sed "s/^X//" >'ttydfl.7' <<'END_OF_FILE'
X.TH ttydfl 7
X.SH NAME
ttydfl \- tty default settings
X.SH DESCRIPTION
This manual page describes a standard set of
tty settings,
as respected by various programs including
X.B pty(1).
X
X.B ttydfl
is in the old tty discipline.
Its input and output speeds are EXTB.
X(Note that ttys connected directly to modems will typically have
lower speeds.)
X
XEven and odd parity characters are supported;
the high bit of an 8-bit character is stripped.
DEC ctrl-Q processing is enabled.
X
The erase character is delete (ASCII 127).
The kill (erase line) character is ctrl-U (21).
The interrupt character is ctrl-C (3).
The quit character is ctrl-backslash (28).
The start character is ctrl-Q (17).
The stop character is ctrl-S (19).
The end-of-file character is ctrl-D (4).
The alternate end-of-file character, if any, is undefined.
X
The suspend character is ctrl-Z (26).
The delayed suspend character is ctrl-Y (25).
X(Note that Suns do not handle delayed suspend processing.)
The reprint character is ctrl-R (18).
The flush character is ctrl-O (15).
The word-erase character is ctrl-W (23).
The literal-next character is ctrl-V (22).
X
On systems supporting auxiliary characters,
the use-status key is ctrl-T (20),
and the following status bits are set:
load1, load5, load15, rawcpu, uptime, pgrp, childs,
pcpu, state.
X.SH "SEE ALSO"
pty(1),
tty(4)
END_OF_FILE
if test 1331 -ne `wc -c <'ttydfl.7'`; then
    echo shar: \"'ttydfl.7'\" unpacked with wrong size!
fi
# end of 'ttydfl.7'
fi
if test -f 'username.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'username.c'\"
else
echo shar: Extracting \"'username.c'\" \(798 characters\)
sed "s/^X//" >'username.c' <<'END_OF_FILE'
X/* username.c, username.h: username-uid conversions
Daniel J. Bernstein, brnstnd@nyu.edu.
Depends on fmt.h, scan.h.
Requires getpwuid(), getpwnam().
X7/18/91: Rewritten to use fmt/scan. username 1.1, public domain.
X5/1/91: Baseline. username 1.0, public domain.
No known patent problems.
X
XXXX: cache
X
X*/
X
X#include <pwd.h>
X#include "username.h"
X#include "fmt.h"
X#include "scan.h"
X
int uid2username(uid,unp)
int uid;
char **unp;
X{
X struct passwd *pw;
X static char un[FMT_ULONG + 1];
X
X if (pw = getpwuid(uid))
X  {
X   *unp = pw->pw_name;
X   return 0;
X  }
X un[fmt_uint(un,uid)] = 0;
X *unp = un;
X return 1;
X}
X
int username2uid(un,uid)
char *un;
int *uid;
X{
X struct passwd *pw;
X
X if (!un[scan_uint(un,uid)])
X   return 1;
X pw = getpwnam(un);
X if (!pw)
X   return -1; /*XXX*/
X *uid = pw->pw_uid;
X return 0;
X}
END_OF_FILE
if test 798 -ne `wc -c <'username.c'`; then
    echo shar: \"'username.c'\" unpacked with wrong size!
fi
# end of 'username.c'
fi
if test -f 'users.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'users.c'\"
else
echo shar: Extracting \"'users.c'\" \(1370 characters\)
sed "s/^X//" >'users.c' <<'END_OF_FILE'
X/* users.c: clone of users program
Daniel J. Bernstein, brnstnd@nyu.edu.
Depends on radixsort.h, sod.h, ralloc.h.
Requires BSD: /etc/utmp, <utmp.h>.
X7/23/91: Baseline. users 2.0, public domain.
No known patent problems.
X
Documentation in users.1.
X*/
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <utmp.h>
X#include "config/utmpfile.h"
X#include "radixsort.h"
X#include "sod.h"
X#include "ralloc.h"
X
struct utmp ut;
SODdecl(namestack,struct { char name[sizeof(ut.ut_name) + 1]; } );
X
main()
X{
X register FILE *fi;
X namestack namehead;
X namestack name;
X int numnames;
X char **base;
X int i;
X
X numnames = 0;
X namehead = 0;
X if (!(fi = fopen(UTMP_FILE,"r")))
X   exit(1); /*XXX*/
X while (fread((char *) &ut,sizeof(ut),1,fi))
X   if (ut.ut_name[0])
X    {
X     name = SODalloc(namestack,name,ralloc);
X     if (!name)
X       exit(1); /*XXX*/
X     strncpy(SODdata(name).name,ut.ut_name,sizeof(ut.ut_name));
X     SODpush(namehead,name);
X     ++numnames;
X    }
X fclose(fi);
X
X base = RALLOC(char *,numnames);
X if (!base)
X   exit(1); /*XXX*/
X
X i = 0;
X for (name = namehead;name;name = SODnext(name))
X   base[i++] = SODdata(name).name;
X 
X if (radixsort7(base,numnames,0,(unsigned char *) 0,0,ralloc,rfree) == -1)
X   exit(1); /*XXX*/
X
X i = 0;
X for (;;)
X  {
X   if (i)
X     putchar(' ');
X   if (i == numnames)
X     break;
X   fputs(base[i],stdout);
X   ++i;
X  }
X putchar('\n');
X exit(0);
X}
END_OF_FILE
if test 1370 -ne `wc -c <'users.c'`; then
    echo shar: \"'users.c'\" unpacked with wrong size!
fi
# end of 'users.c'
fi
if test -f 'wall.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wall.c'\"
else
echo shar: Extracting \"'wall.c'\" \(1768 characters\)
sed "s/^X//" >'wall.c' <<'END_OF_FILE'
X/* Public domain. */
X
X#include <sys/types.h>
X#include <sys/file.h>
X#ifdef BSD
X#include <limits.h>
X#endif
X#include <stdio.h>
X#include <strings.h>
X#include <utmp.h>
X#include <pwd.h>
X#include <time.h>
X#include <ctype.h>
X#include "fmt.h"
X#include "config/utmpfile.h"
extern unsigned short getuid();
extern char *ttyname();
extern long time();
X
main()
X{ 
X register FILE *fi;
X struct utmp ut;
X char fntty[30];
X int fd;
X char buf[10000];
X char *username;
X struct passwd *pw;
X char hostname[64];
X char *ttyn;
X long t;
X struct tm *tm;
X int r;
X int pos;
X
X if (!(pw = getpwuid((int) getuid())))
X  {
X   fprintf(stderr,"write: who are you?\n");
X   exit(1);
X  }
X username = pw->pw_name;
X
X gethostname(hostname,sizeof(hostname));
X
X if (!(ttyn = ttyname(2)))
X  {
X   fprintf(stderr,"wall: Can't find your tty\n");
X   exit(1);
X  }
X
X t = time((long *) 0);
X tm = localtime(&t);
X
X sprintf(buf,"\nBroadcast message from %s@%s on %s at %d:%02d ...%c\n\n",
X		username,hostname,ttyn + 5,tm->tm_hour,tm->tm_min,7);
X pos = strlen(buf);
X  {
X   static char pre[] =
X"End your message with the EOF character. This is how it will show up:";
X   write(1,pre,strlen(pre));
X  }
X write(1,buf,pos);
X while ((pos < 10000) && ((r = read(0,buf + pos,10000 - pos)) > 0))
X   pos += r;
X if (fmt_nvis(FMT_LEN,buf,pos) != pos + 1) /* +1 for extra beep */
X  {
X   fprintf(stderr,"wall: sorry, that message has control characters\n");
X   exit(1);
X  }
X
X if (fi = fopen(UTMP_FILE,"r"))
X   while (fread((char *) &ut,sizeof(ut),1,fi))
X     if (ut.ut_name[0])
X      {
X       sprintf(fntty,"/dev/%.8s",ut.ut_line);
X       if ((fd = open(fntty,O_WRONLY)) == -1)
X         fprintf(stderr,"wall: cannot write to %.8s\n",ut.ut_line);
X       else
X        {
X	 write(fd,buf,pos);
X         close(fd);
X        }
X      }
X
X exit(0);
X}
END_OF_FILE
if test 1768 -ne `wc -c <'wall.c'`; then
    echo shar: \"'wall.c'\" unpacked with wrong size!
fi
# end of 'wall.c'
fi
if test -f 'who.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'who.1'\"
else
echo shar: Extracting \"'who.1'\" \(1353 characters\)
sed "s/^X//" >'who.1' <<'END_OF_FILE'
X.TH who 1
X.SH NAME
who \- show who is logged on
X.SH SYNOPSIS
X.B who
X[
X\fB\-lL\fI
X] [
X.I file
X] [
X.B "am I"
X]
X.SH DESCRIPTION
X.B who
lists the login name, terminal name, and login time
for each current user.
Normally
X.B who
uses
X.I /etc/utmp,
and omits
logged-out terminals.
If you give it a
X.I file,
such as
X/usr/adm/wtmp,
it will use that file instead,
and include logouts as lines with a blank username.
Other types of entries in
X/usr/adm/wtmp
are documented
in
utmp(5).
X.PP
Option
X.B\-L
restricts the display to lines which actually have someone logged on,
omitting any lines with a blank username, just as
X.B who
does normally with no arguments.
Option
X.B\-l
shows all lines, just as
X.B who
does normally with a
X.I file
argument.
X.PP
With two (or more) arguments,
as in
X.B who am I
X(and also 
X.B who are you),
X.B who
tells who you are logged in as,
including the local host name.
X.SH COMPATIBILITY
Standard
X.B who am i
does not give a meaningful error when its input is not a terminal;
this version does.
Standard
X.B who
does not have the
X.B\-l
option.
Different versions of
X.B who
vary in how they treat three or more arguments.
Other than that, this is an exact clone.
X.SH BUGS
None known.
X.SH VERSION
who version 2.0, 7/22/91.
X.SH AUTHOR
Placed into the public domain by Daniel J. Bernstein.
X.SH FILES
X/etc/utmp
X.SH "SEE ALSO"
getuid(2), utmp(5)
END_OF_FILE
if test 1353 -ne `wc -c <'who.1'`; then
    echo shar: \"'who.1'\" unpacked with wrong size!
fi
# end of 'who.1'
fi
if test -f 'write.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'write.1'\"
else
echo shar: Extracting \"'write.1'\" \(1827 characters\)
sed "s/^X//" >'write.1' <<'END_OF_FILE'
X.TH write 1
X.SH NAME
write \- write to another user
X.SH SYNOPSIS
X.B write
X.I user
X[
X.I ttyname
X]
X.SH DESCRIPTION
X.B write
copies lines from your terminal to that of
another user.
This clone version
starts and (if you don't kill the process)
ends your message with identifying lines.
It also
precedes each line with your username.
X
If you want to write to a user who is logged in more than once,
you can
choose a particular terminal with
X.I ttyname.
X(This misfeature is deprecated.)
Otherwise
X.B write
will choose a terminal for you.
X
The other user can use
X.B mesg
to allow or deny
X.B write
permission.
In many recent versions of
X.B write,
you cannot write to a user unless you are also allowing messages.
Unfortunately, this adds absolutely no security, because you can
turn messages right back off after starting
X.B write.
This clone version exhibits the right behavior:
it checks
X.B mesg
permission on the other end
before writing each line.
X
This version of
X.B write
does not
allow shell escapes.
X
There are many popular ways of using
X.B write
X(perhaps the most common being to
use
X.B talk
instead).
Typically each user ends each series of lines
with a distinctive signal, such as
X``ga'' (go ahead),
so that the other user can type without
worrying about messed-up output.
The number of abbreviations used in
screen conversation is immense.
See
X.B talkacros(7)
for further information.
X
This clone version of
X.B write
uses the standard input,
rather than the standard error,
to determine your tty.
X
X.B write
displays control characters in a printable form.
X.SH RESTRICTIONS
Lines longer than 500 characters
will be split in two.
X
X.B write
sleeps for a second after sending each line.
This restriction means that you can't
flood someone else's screen with a large text.
X.SH "SEE ALSO"
mesg(1),
who(1),
mail(1),
talkacros(7)
END_OF_FILE
if test 1827 -ne `wc -c <'write.1'`; then
    echo shar: \"'write.1'\" unpacked with wrong size!
fi
# end of 'write.1'
fi
echo shar: End of archive 2 \(of 9\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 9 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
