Newsgroups: comp.sources.unix
From: jnweiger@immd4.informatik.uni-erlangen.de (Juergen Weigert)
Subject: v25i047: Screen3 - multiple windows on an ASCII terminal, Part07/08
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: jnweiger@immd4.informatik.uni-erlangen.de (Juergen Weigert)
Posting-Number: Volume 25, Issue 47
Archive-Name: screen3/part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 8)."
# Contents:  ansi.c
# Wrapped by vixie@cognition.pa.dec.com on Thu Dec 19 17:36:06 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ansi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ansi.c'\"
else
echo shar: Extracting \"'ansi.c'\" \(68134 characters\)
sed "s/^X//" >'ansi.c' <<'END_OF_FILE'
X/* Copyright (c) 1991
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X * All rights reserved.  Not derived from licensed software.
X *
X * Permission is granted to freely use, copy, modify, and redistribute
X * this software, provided that no attempt is made to gain profit from it,
X * the authors are not construed to be liable for any results of using the
X * software, alterations are clearly marked as such, and this notice is
X * not modified.
X *
X * Noteworthy contributors to screen's design and implementation:
X *	Wayne Davison (davison@borland.com)
X *	Patrick Wolfe (pat@kai.com, kailand!pat)
X *	Bart Schaefer (schaefer@cse.ogi.edu)
X *	Nathan Glasser (nathan@brokaw.lcs.mit.edu)
X *	Larry W. Virden (lwv27%cas.BITNET@CUNYVM.CUNY.Edu)
X *	Howard Chu (hyc@hanauma.jpl.nasa.gov)
X *	Tim MacKenzie (tym@dibbler.cs.monash.edu.au)
X *	Markku Jarvinen (mta@{cc,cs,ee}.tut.fi)
X *	Marc Boucher (marc@CAM.ORG)
X *
X ****************************************************************
X */
X
X#ifndef lint
X  static char rcs_id[] = "$Id: ansi.c,v 1.88 91/10/11 11:27:40 jnweiger Exp $ FAU";
X#endif
X
X#include <stdio.h>
X#if defined(BSD) || defined(sequent) || defined(pyr)
X# include <strings.h>
X#else
X# include <string.h>
X#endif
X#include <sys/types.h>
X#include "config.h"
X#include "screen.h"
X#include "ansi.h"
X#include "extern.h"
X#include <fcntl.h>
X#ifndef sun /* we want to know about TIOCGWINSZ. jw. */
X# include <sys/ioctl.h>
X#endif
X
extern char *getenv(), *tgetstr(), *tgoto();
X#ifndef __STDC__
extern char *malloc();
X#endif
X
extern struct win *fore;
extern int ForeNum;
extern force_vt, assume_LP;
extern int BellDisplayed;
extern int MsgMinWait;
X
X#ifdef TIOCGWINSZ
extern struct winsize glwz;
X#endif
X
static int rows, cols;		/* window size of the curr window. */
int TermcapROWS, TermcapCOLS;	/* defaults that we learned from termcap */
int maxwidth, Z0width, Z1width;
int default_width, default_height;	/* width/height a new window will get */
X
int screenwidth, screenheight;	/* width/height of the fore window */
int screentop, screenbot;	/* scrollregion start/end */
int screenx, screeny;		/* cursor position */
char GlobalAttr, GlobalCharset;
int insert;			/* insert mode */
int keypad;
int flow;
X
int status;
static int status_lastx, status_lasty;
X
int flowctl, wrap = 1, default_monitor = 0; 
int visual_bell = 0, termcapHS, use_hardstatus = 1;
char *Termcap, *extra_incap, *extra_outcap;
static int Termcaplen;
char *blank, *null, *LastMsg;
char Term[MAXSTR+5];	/* +5: "TERM=" */
char screenterm[20] = "screen";
char *Z0, *Z1;
int ISO2022, HS;
time_t TimeDisplayed, time();
X
X/*
X * the termcap routines need this to work
X */
short ospeed;
char *BC;
char *UP;
X
static void AddCap __P((char *));
static void MakeString __P((char *, char *, int, char *));
static int Special __P((int));
static void DoESC __P((int, int ));
static void DoCSI __P((int, int ));
static void CPutStr __P((char *, int));
static void SetChar __P(());
static void StartString __P((enum string_t));
static void AddChar __P((int ));
static void PrintChar __P((int ));
static void PrintFlush __P((void));
static void KeypadMode __P((int));
static void FlowMode __P((int));
static void DesignateCharset __P((int, int ));
static void MapCharset __P((int));
static void SaveCursor __P((void));
static void RestoreCursor __P((void));
static void CountChars __P((int));
static int CalcCost __P((char *));
static int Rewrite __P((int, int, int, int));
static void BackSpace __P((void));
static void Return __P((void));
static void LineFeed __P((int));
static void ReverseLineFeed __P((void));
static void InsertAChar __P((int));
static void InsertChar __P((int));
static void DeleteChar __P((int));
static void DeleteLine __P((int));
static void InsertLine __P((int));
static void ScrollUpMap __P((int));
static void ScrollDownMap __P((int));
static void Scroll __P((char *, int, int, char *));
static void ForwardTab __P((void));
static void BackwardTab __P((void));
static void ClearScreen __P((void));
static void ClearFromBOS __P((void));
static void ClearToEOS __P((void));
static void ClearLine __P((void));
static void ClearToEOL __P((void));
static void ClearFromBOL __P((void));
static void ClearInLine __P((int, int, int, int ));
static void CursorRight __P(());
static void CursorUp __P(());
static void CursorDown __P(());
static void CursorLeft __P(());
static void ASetMode __P((int));
static void SelectRendition __P((void));
static void FillWithEs __P((void));
static void RedisplayLine __P((char *, char *, char *, int, int, int ));
static void FindAKA __P((void));
static void SetCurr __P((struct win *));
static void inpRedisplayLine __P((int, int, int, int));
static void process_inp_input __P((char **, int *));
static void AbortInp __P((void));
static void AKAfin __P((char *, int));
static void Colonfin __P((char *, int));
static void RAW_PUTCHAR __P((int));
static char *e_tgetstr __P((char *, char **));
static int e_tgetflag __P((char *));
static int e_tgetnum __P((char *));
X
X
static char *tbuf, *tentry, *termname;
static char *tp;
static char *TI, *TE, *BL, *VB, *CR, *NL, *CL, *IS;
char *WS;	/* used in ResizeScreen() */
char *CE;	/* used in help.c */
static char *CM, *US, *UE, *SO, *SE, *CD, *DO, *SR, *SF, *AL;
static char *CS, *DL, *DC, *IC, *IM, *EI, *ND, *KS, *KE;
static char *MB, *MD, *MH, *MR, *ME, *PO, *PF, *HO;
static char *TS, *FS, *DS, *VI, *VE, *VS;
static char *CDC, *CDL, *CAL, *CUP, *CDO, *CLE, *CRI, *CIC;
static char *attrtab[NATTR];
static AM, MS, COP;
int LP;
X/*
X * Do not confuse S0 (es-zero), E0 (e-zero) with SO (es-oh), PO (pe-oh),
X * Z0 (z-zero), DO (de-oh)... :-)
X */
static char *C0, *S0, *E0;
static char c0_tab[256];
X/*
X */
static screencap = 0;
char *OldImage, *OldAttr, *OldFont;
static struct win *curr;
static display = 1;
static StrCost;
static UPcost, DOcost, LEcost, NDcost, CRcost, IMcost, EIcost, NLcost;
static tcLineLen;
static StatLen;
static lp_missing = 0;
X
int in_ovl;
int ovl_blockfore;
void (*ovl_process)();
void (*ovl_RedisplayLine)();
int (*ovl_Rewrite)();
X
static char *KeyCaps[] =
X{
X  "k0", "k1", "k2", "k3", "k4", "k5", "k6", "k7", "k8", "k9",
X  "kb", "kd", "kh", "kl", "ko", "kr", "ku",
X  "K1", "K2", "K3", "K4", "K5",
X  "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7", "l8", "l9"
X};
X#define NKEYCAPS (sizeof(KeyCaps)/sizeof(*KeyCaps))
static char *KeyCapsArr[NKEYCAPS];
X
static char TermcapConst[] = "\\\n\
X\t:DO=\\E[%dB:LE=\\E[%dD:RI=\\E[%dC:UP=\\E[%dA:bs:bt=\\E[Z:\\\n\
X\t:cd=\\E[J:ce=\\E[K:cl=\\E[H\\E[J:cm=\\E[%i%d;%dH:ct=\\E[3g:\\\n\
X\t:do=^J:nd=\\E[C:pt:rc=\\E8:rs=\\Ec:sc=\\E7:st=\\EH:up=\\EM:\\\n\
X\t:le=^H:bl=^G:cr=^M:it#8:ho=\\E[H:nw=\\EE:ta=^I:is=\\E)0:xv:";
X
void
InitTermcap()
X{
X  register char *s;
X  int i;
X
X  screencap = 0;
X  if ((s = getenv("SCREENCAP")) != 0)
X    {
X      if ((Termcap = malloc((unsigned) strlen(s) + 10)) != 0)
X	{
X	  sprintf(Termcap, "TERMCAP=%s", s);
X	  screencap = 1;
X	}
X    }
X  else
X    Termcap = malloc((unsigned) 1024);
X  Termcaplen = 0;
X  tbuf = malloc((unsigned) 1024);
X  tentry = tp = malloc((unsigned) 1024);
X  if (!(Termcap && tbuf && tentry))
X    Msg_nomem;
X  bzero(tbuf, 1024);
X  if ((termname = getenv("TERM")) == 0)
X    Msg(0, "No TERM in environment.");
X  debug1("InitTermcap: looking for tgetent('%s');\n", termname);
X  if (tgetent(tbuf, termname) != 1)
X    Msg(0, "Cannot find termcap entry for %s.", termname);
X  debug1("got it:\n%s\n",tbuf);
X#ifdef DEBUG
X  if (extra_incap)
X    debug1("Extra incap: %s\n", extra_incap);
X  if (extra_outcap)
X    debug1("Extra outcap: %s\n", extra_outcap);
X#endif
X
X  TermcapCOLS = TermcapROWS = 0;
X  if (s = getenv("COLUMNS"))
X    TermcapCOLS = atoi(s);
X  if (TermcapCOLS <= 0)
X    TermcapCOLS = e_tgetnum("co");
X  if (TermcapCOLS <= 0)
X    TermcapCOLS = 80;
X  if (s = getenv("LINES"))
X    TermcapROWS = atoi(s);
X  if (TermcapROWS <= 0)
X    TermcapROWS = e_tgetnum("li");
X  if (TermcapROWS <= 0)
X    TermcapROWS = 24;
X
X  if (e_tgetflag("hc"))
X    Msg(0, "You can't run screen on a hardcopy terminal.");
X  if (e_tgetflag("os"))
X    Msg(0, "You can't run screen on a terminal that overstrikes.");
X  if (e_tgetflag("ns"))
X    Msg(0, "Terminal must support scrolling.");
X  if (!(CL = e_tgetstr("cl", &tp)))
X    Msg(0, "Clear screen capability required.");
X  if (!(CM = e_tgetstr("cm", &tp)))
X    Msg(0, "Addressable cursor capability required.");
X  switch (flowctl)
X    {
X    case 0:
X      flow = !e_tgetflag("NF");
X      flowctl = flow + 1;
X      break;
X    case 1:
X      flow = 0;
X      break;
X    case 2:
X    case 3:
X      flow = 1;
X      break;
X    }
X  AM = e_tgetflag("am");
X  LP = assume_LP || (!extra_incap && !strncmp(termname, "vt", 2))
X  		 || !AM || e_tgetflag("LP") || e_tgetflag("xv");
X  COP = e_tgetflag("OP");
X  HO = e_tgetstr("ho", &tp);
X  TI = e_tgetstr("ti", &tp);
X  TE = e_tgetstr("te", &tp);
X  if (!(BL = e_tgetstr("bl", &tp)))
X    BL = "\007";
X  VB = e_tgetstr("vb", &tp);
X  if (!(BC = e_tgetstr("bc", &tp)))
X    {
X      if (e_tgetflag("bs"))
X	BC = "\b";
X      else
X	BC = e_tgetstr("le", &tp);
X    }
X  if (!(CR = e_tgetstr("cr", &tp)))
X    CR = "\r";
X  if (!(NL = e_tgetstr("nl", &tp)))
X    NL = "\n";
X  IS = e_tgetstr("is", &tp);
X  MS = 1;
X  if (e_tgetnum("sg") <= 0 && e_tgetnum("ug") <= 0)
X    {
X      MS = e_tgetflag("ms");
X      attrtab[ATTR_DI] = MH = e_tgetstr("mh", &tp);	/* Dim */
X      attrtab[ATTR_US] = US = e_tgetstr("us", &tp);	/* Underline */
X      attrtab[ATTR_BD] = MD = e_tgetstr("md", &tp);	/* Bold */
X      attrtab[ATTR_RV] = MR = e_tgetstr("mr", &tp);	/* Reverse */
X      attrtab[ATTR_SO] = SO = e_tgetstr("so", &tp);	/* Standout */
X      attrtab[ATTR_BL] = MB = e_tgetstr("mb", &tp);	/* Blinking */
X      ME = e_tgetstr("me", &tp);
X      SE = e_tgetstr("se", &tp);
X      UE = e_tgetstr("ue", &tp);
X      /*
X       * Does ME also reverse the effect of SO and/or US?  This is not
X       * clearly specified by the termcap manual. Anyway, we should at
X       * least look whether ME and SE/UE are equal:
X       */
X      if (UE && ((SE && strcmp(SE, UE) == 0) || (ME && strcmp(ME, UE) == 0)))
X	UE = 0;
X      if (SE && (ME && strcmp(ME, SE) == 0))
X	SE = 0;
X
X      /* Set up missing entries */
X      s = 0;
X      for (i = NATTR-1; i >= 0; i--)
X	if (attrtab[i])
X	  s = attrtab[i];
X      for (i = 0; i < NATTR; i++)
X	{
X	  if (attrtab[i] == 0)
X	    attrtab[i] = s;
X	  else
X	    s = attrtab[i];
X	}
X    }
X  else
X    {
X      US = UE = SO = SE = MB = MD = MH = MR = ME = 0;
X      for (i = 0; i < NATTR; i++)
X	attrtab[i] = 0;
X    }
X  CE = e_tgetstr("ce", &tp);
X  CD = e_tgetstr("cd", &tp);
X  if (!(DO = e_tgetstr("do", &tp)))
X    DO = NL;
X  UP = e_tgetstr("up", &tp);
X  ND = e_tgetstr("nd", &tp);
X  SR = e_tgetstr("sr", &tp);
X  if (!(SF = e_tgetstr("sf", &tp)))
X    SF = NL;
X  AL = e_tgetstr("al", &tp);
X  DL = e_tgetstr("dl", &tp);
X  CS = e_tgetstr("cs", &tp);
X  DC = e_tgetstr("dc", &tp);
X  IC = e_tgetstr("ic", &tp);
X  CIC = e_tgetstr("IC", &tp);
X  CDC = e_tgetstr("DC", &tp);
X  CDL = e_tgetstr("DL", &tp);
X  CAL = e_tgetstr("AL", &tp);
X  CUP = e_tgetstr("UP", &tp);
X  CDO = e_tgetstr("DO", &tp);
X  CLE = e_tgetstr("LE", &tp);
X  CRI = e_tgetstr("RI", &tp);
X  IM = e_tgetstr("im", &tp);
X  EI = e_tgetstr("ei", &tp);
X  if (e_tgetflag("in"))
X    IC = IM = 0;
X  if (IC && IC[0] == '\0')
X    IC = 0;
X  if (CIC && CIC[0] == '\0')
X    CIC = 0;
X  if (IM && IM[0] == '\0')
X    IM = 0;
X  if (EI && EI[0] == '\0')
X    EI = 0;
X  if (EI == 0)
X    IM = 0;
X  if (IC && IM && strcmp(IC, IM) == 0)
X    IC = 0;
X  KS = e_tgetstr("ks", &tp);
X  KE = e_tgetstr("ke", &tp);
X  if (KE == 0)
X    KS = 0;
X  ISO2022 = e_tgetflag("G0");
X  if (ISO2022)
X    {
X      if ((S0 = e_tgetstr("S0", &tp)) == NULL)
X#ifdef TERMINFO
X	S0 = "\033(%p1%c";
X#else
X	S0 = "\033(%.";
X#endif
X      if ((E0 = e_tgetstr("E0", &tp)) == NULL)
X	E0 = "\033(B";
X      C0 = e_tgetstr("C0", &tp);
X    }
X  else if ((S0 = e_tgetstr("as", &tp)) != NULL
X        && (E0 = e_tgetstr("ae", &tp)) != NULL)
X    {
X      ISO2022 = 1;
X      C0 = e_tgetstr("ac", &tp);
X    }
X  else
X    {
X      S0 = E0 = "";
X      C0 = "g.h.i'j-k-l-m-n+o~p\"q-r-s_t+u+v+w+x|y<z>";
X    }
X  for (i = 0; i < 256; i++)
X    c0_tab[i] = i;
X  if (C0)
X    for (i = strlen(C0)&~1; i >= 0; i-=2)
X      c0_tab[C0[i]] = C0[i+1];
X  debug1("ISO2022 = %d\n", ISO2022);
X  /* WS changes the window size */
X  WS = e_tgetstr("WS", &tp);
X  VI = e_tgetstr("vi", &tp);
X  VE = e_tgetstr("ve", &tp);
X  VS = e_tgetstr("vs", &tp);
X  PO = e_tgetstr("po", &tp);
X  if (!(PF = e_tgetstr("pf", &tp)))
X    PO = 0;
X  debug2("terminal size is %d, %d (says TERMCAP)\n", TermcapCOLS, TermcapROWS);
X  /* Termcap fields Z0 & Z1 contain width-changing sequences. */
X  if ((Z0 = e_tgetstr("Z0", &tp)) != NULL
X      && (Z1 = e_tgetstr("Z1", &tp)) == NULL)
X    Z0 = NULL;
X
X  Z0width = 132;
X  Z1width = 80;
X
X  CheckScreenSize(0);
X  if ((HS = e_tgetflag("hs")) != 0)
X    {
X      debug("oy! we have a hardware status line, says termcap\n");
X      TS = e_tgetstr("ts", &tp);
X      FS = e_tgetstr("fs", &tp);
X      DS = e_tgetstr("ds", &tp);
X      if ((HS = e_tgetnum("ws")) <= 0)
X	HS = screenwidth;
X      if (!TS || !FS || !DS)
X	HS = 0;
X    }
X  termcapHS = HS;
X  if (!use_hardstatus)
X    HS = 0;
X
X  UPcost = CalcCost(UP);
X  DOcost = CalcCost(DO);
X  NLcost = CalcCost(NL);
X  LEcost = CalcCost(BC);
X  NDcost = CalcCost(ND);
X  CRcost = CalcCost(CR);
X  IMcost = CalcCost(IM);
X  EIcost = CalcCost(EI);
X  for (i = 0; i < NKEYCAPS; i++)
X    KeyCapsArr[i] = e_tgetstr(KeyCaps[i], &tp);
X  MakeTermcap(0);
X}
X
X/*
X * if the adaptflag is on, we keep the size of this display, else
X * we may try to restore our old window sizes.
X */
void
InitTerm(adapt)
int adapt;
X{
X  display = 1;
X  screentop = screenbot = -1;
X  PutStr(IS);
X  PutStr(TI);
X  if (IM && strcmp(IM, EI))
X    PutStr(EI);
X  insert = 0;
X  if (KS && strcmp(KS, KE))
X    PutStr(KE);
X  keypad = 0;
X  ResizeScreen((struct win *)0);
X  ChangeScrollRegion(0, screenheight-1);
X  PutStr(CL);
X  screenx = screeny = 0;
X  fflush(stdout);
X  debug1("we %swant to adapt all our windows to the display\n", 
X	 (adapt) ? "" : "don't ");
X  /* In case the size was changed by a init sequence */
X  CheckScreenSize((adapt) ? 2 : 0);
X}
X
void
XFinitTerm()
X{
X  display = 1;
X  flow = 1;
X  InsertMode(0);
X  KeypadMode(0);
X  ResizeScreen((struct win *)0);
X  ChangeScrollRegion(0, screenheight - 1);
X  SaveSetAttr(0, ASCII);
X  screenx = screeny = -1;
X  GotoPos(0, screenheight - 1);
X  PutStr(TE);
X  fflush(stdout);
X  if (Termcap) 
X    {
X      Free(Termcap);
X      debug("FinitTerm: old termcap freed\n");
X    }
X  if (tbuf) 
X    {
X      Free(tbuf);
X      debug("FinitTerm: old tbuf freed\n");
X    }
X  if (tentry) 
X    {
X      Free(tentry);
X      debug("FinitTerm: old tentry freed\n");
X    }
X}
X
static void AddCap(s)
char *s;
X{
X  register int n;
X
X  if (tcLineLen + (n = strlen(s)) > 55 && Termcaplen < 1024-4)
X    {
X      strcpy(Termcap + Termcaplen, "\\\n\t:");
X      Termcaplen += 4;
X      tcLineLen = 0;
X    }
X  if (Termcaplen + n < 1024)
X    {
X      strcpy(Termcap + Termcaplen, s);
X      Termcaplen += n;
X      tcLineLen += n;
X    }
X  else
X    Msg(0, "TERMCAP overflow - sorry.");
X}
X
char *MakeTermcap(aflag)
int aflag;
X{
X  char buf[1024];
X  register char *p, *cp, ch;
X  int i;
X
X  if (screencap)
X    {
X      sprintf(Term, "TERM=screen");
X      return Termcap;
X    }
X  if (screenterm == 0 || *screenterm == '\0')
X    {
X      debug("MakeTermcap sets screenterm=screen\n");
X      strcpy(screenterm, "screen");
X    }
X  for (;;)
X    {
X      sprintf(Term, "TERM=");
X      p = Term + 5;
X      if (!aflag && (unsigned)strlen(screenterm)+strlen(termname) < MAXSTR-1)
X	{
X	  sprintf(p, "%s.%s", screenterm, termname);
X	  if (tgetent(buf, p) == 1)
X	    break;
X	}
X      if (screenwidth >= 132)
X	{
X	  sprintf(p, "%s-w", screenterm);
X          if (tgetent(buf, p) == 1)
X	    break;
X	}
X      sprintf(p, "%s", screenterm);
X      if (tgetent(buf, p) == 1)
X	break;
X      sprintf(p, "vt100");
X      break;
X    }
X  tcLineLen = 100;	/* Force NL */
X  sprintf(Termcap,
X	  "TERMCAP=SC|%s|VT 100/ANSI X3.64 virtual terminal|", p);
X  Termcaplen = strlen(Termcap);
X  if (extra_outcap && *extra_outcap)
X    {
X      for (cp = extra_outcap; p = index(cp, ':'); cp = p)
X	{
X	  ch = *++p;
X	  *p = '\0';
X	  AddCap(cp);
X	  *p = ch;
X	}
X      tcLineLen = 100;	/* Force NL */
X    }
X  if (Termcaplen + (unsigned)strlen(TermcapConst) < 1024)
X    {
X      strcpy(Termcap + Termcaplen, TermcapConst);
X      Termcaplen += strlen(TermcapConst);
X    }
X  sprintf(buf, "li#%d:co#%d:", screenheight, screenwidth);
X  AddCap(buf);
X  if ((force_vt && !COP) || LP || !AM)
X    AddCap("LP:");
X  else
X    AddCap("am:");
X  if (VB)
X    AddCap("vb=\\E[?5h\\E[?5l:");
X  if (US)
X    {
X      AddCap("us=\\E[4m:");
X      AddCap("ue=\\E[24m:");
X    }
X  if (SO)
X    {
X      AddCap("so=\\E[3m:");
X      AddCap("se=\\E[23m:");
X    }
X  if (MB)
X    AddCap("mb=\\E[5m:");
X  if (MD)
X    AddCap("md=\\E[1m:");
X  if (MH)
X    AddCap("mh=\\E[2m:");
X  if (MR)
X    AddCap("mr=\\E[7m:");
X  if (MB || MD || MH || MR)
X    AddCap("me=\\E[m:ms:");
X  if ((CS && SR) || AL || CAL || aflag)
X    {
X      AddCap("sr=\\EM:");
X      AddCap("al=\\E[L:");
X      AddCap("AL=\\E[%dL:");
X    }
X  else if (SR)
X    AddCap("sr=\\EM:");
X  if (CS || DL || CDL || aflag)
X    {
X      AddCap("dl=\\E[M:");
X      AddCap("DL=\\E[%dM:");
X    }
X  if (CS)
X    AddCap("cs=\\E[%i%d;%dr:");
X  if (DC || CDC || aflag)
X    {
X      AddCap("dc=\\E[P:");
X      AddCap("DC=\\E[%dP:");
X    }
X  if (CIC || IC || IM || aflag)
X    {
X      AddCap("im=\\E[4h:");
X      AddCap("ei=\\E[4l:");
X      AddCap("mi:");
X      AddCap("ic=\\E[@:");
X      AddCap("IC=\\E[%d@:");
X    }
X  if (KS)
X    AddCap("ks=\\E=:");
X  if (KE)
X    AddCap("ke=\\E>:");
X  if (ISO2022)
X    AddCap("G0:");
X  if (PO)
X    {
X      AddCap("po=\\E[5i:");
X      AddCap("pf=\\E[4i:");
X    }
X  if (Z0)
X    {
X      AddCap("Z0=\\E[?3h:");
X      AddCap("Z1=\\E[?3l:");
X    }
X  if (WS)
X    AddCap("WS=\\E[8;%d;%dt:");
X  for (i = 0; i < NKEYCAPS; i++)
X    {
X      if (KeyCapsArr[i] == 0)
X	continue;
X      MakeString(KeyCaps[i], buf, sizeof(buf), KeyCapsArr[i]);
X      AddCap(buf);
X    }
X  return Termcap;
X}
X
static void MakeString(cap, buf, buflen, s)
char *cap, *buf;
int buflen;
char *s;
X{
X  register char *p, *pmax;
X  register unsigned int c;
X
X  p = buf;
X  pmax = p + buflen - (3+4+2);
X  *p++ = *cap++;
X  *p++ = *cap;
X  *p++ = '=';
X  while ((c = *s++) && p < pmax)
X    {
X      switch (c)
X	{
X	case '\033':
X	  *p++ = '\\';
X	  *p++ = 'E';
X	  break;
X	case ':':
X	  sprintf(p, "\\072");
X	  p += 4;
X	  break;
X	case '^':
X	case '\\':
X	  *p++ = '\\';
X	  *p++ = c;
X	  break;
X	default:
X	  if (c >= 200)
X	    {
X	      sprintf(p, "\\%03o", c & 0377);
X	      p += 4;
X	    }
X	  else if (c < ' ')
X	    {
X	      *p++ = '^';
X	      *p++ = c + '@';
X	    }
X	  else
X	    *p++ = c;
X	}
X    }
X  *p++ = ':';
X  *p = '\0';
X}
X
void
Activate()
X{
X  debug("Activate()\n");
X  if (display)
X    RemoveStatus();
X  display = fore->active = 1;
X  ResizeScreen(fore);
X  SetCurr(fore);
X  debug3("Fore (%d) has size %dx%d", ForeNum, curr->width, curr->height);
X  debug1("(%d)\n", curr->histheight);
X  ChangeScrollRegion(curr->top, curr->bot);
X  KeypadMode(curr->keypad);
X  FlowMode(curr->flow);
X  if (curr->monitor != MON_OFF)
X    curr->monitor = MON_ON;
X  curr->bell = BELL_OFF;
X  Redisplay();
X}
X
void
ResetScreen(p)
register struct win *p;
X{
X  register int i;
X
X  p->wrap = wrap;
X  p->origin = 0;
X  p->insert = 0;
X  p->vbwait = 0;
X  p->keypad = 0;
X  p->top = 0;
X  p->bot = p->height - 1;
X  p->saved = 0;
X  p->LocalAttr = 0;
X  p->x = p->y = 0;
X  p->state = LIT;
X  p->StringType = NONE;
X  p->ss = 0;
X  p->LocalCharset = G0;
X  bzero(p->tabs, p->width);
X  for (i = 8; i < p->width; i += 8)
X    p->tabs[i] = 1;
X  for (i = G0; i <= G3; i++)
X    p->charsets[i] = ASCII;
X}
X
void
WriteString(wp, buf, len)
struct win *wp;
register char *buf;
int len;
X{
X  register int c, intermediate = 0;
X
X  if (!len)
X    return;
X  if (wp->logfp != NULL)
X    if (fwrite(buf, len, 1, wp->logfp) < 1)
X      {
X	extern int errno;
X
X	Msg(errno, "Error writing logfile");
X	fclose(wp->logfp);
X	wp->logfp = NULL;
X      }
X  /*
X   * SetCurr() here may prevent output, as it may set display = 0
X   */
X  SetCurr(wp);
X  if (display)
X    {
X      if (!HS)
X	RemoveStatus();
X    }
X  else if (curr->monitor == MON_ON)
X    curr->monitor = MON_FOUND;
X
X  do
X    {
X      c = *buf++;
X      if (c == '\0' || c == '\177')
X	continue;
X    NextChar:
X      switch (curr->state)
X	{
X	case PRIN:
X	  switch (c)
X	    {
X	    case '\033':
X	      curr->state = PRINESC;
X	      break;
X	    default:
X	      PrintChar(c);
X	    }
X	  break;
X	case PRINESC:
X	  switch (c)
X	    {
X	    case '[':
X	      curr->state = PRINCSI;
X	      break;
X	    default:
X	      PrintChar('\033');
X	      PrintChar(c);
X	      curr->state = PRIN;
X	    }
X	  break;
X	case PRINCSI:
X	  switch (c)
X	    {
X	    case '4':
X	      curr->state = PRIN4;
X	      break;
X	    default:
X	      PrintChar('\033');
X	      PrintChar('[');
X	      PrintChar(c);
X	      curr->state = PRIN;
X	    }
X	  break;
X	case PRIN4:
X	  switch (c)
X	    {
X	    case 'i':
X	      curr->state = LIT;
X	      PrintFlush();
X	      break;
X	    default:
X	      PrintChar('\033');
X	      PrintChar('[');
X	      PrintChar('4');
X	      PrintChar(c);
X	      curr->state = PRIN;
X	    }
X	  break;
X	case STRESC:
X	  switch (c)
X	    {
X	    case '\\':
X	      curr->state = LIT;
X	      *(curr->stringp) = '\0';
X	      switch (curr->StringType)
X		{
X		case PM:
X		  if (!display)
X		    break;
X		  MakeStatus(curr->string);
X		  if (!HS && status && len > 1)
X		    {
X		      curr->outlen = len - 1;
X		      bcopy(buf, curr->outbuf, curr->outlen);
X		      return;
X		    }
X		  break;
X		case DCS:
X		  if (display)
X		    printf("%s", curr->string);
X		  break;
X		case AKA:
X		  if (curr->akapos == 0 && !*curr->string)
X		    break;
X		  strncpy(curr->cmd + curr->akapos, curr->string, 20);
X		  if (!*curr->string)
X		    curr->autoaka = curr->y + 1;
X		  break;
X		default:
X		  break;
X		}
X	      break;
X	    default:
X	      curr->state = ASTR;
X	      AddChar('\033');
X	      AddChar(c);
X	    }
X	  break;
X	case ASTR:
X	  switch (c)
X	    {
X	    case '\0':
X	      break;
X	    case '\033':
X	      curr->state = STRESC;
X	      break;
X	    default:
X	      AddChar(c);
X	    }
X	  break;
X	case ESC:
X	  switch (c)
X	    {
X	    case '[':
X	      curr->NumArgs = 0;
X	      intermediate = 0;
X	      bzero((char *) curr->args, MAXARGS * sizeof(int));
X	      curr->state = CSI;
X	      break;
X	    case ']':
X	      StartString(OSC);
X	      break;
X	    case '_':
X	      StartString(APC);
X	      break;
X	    case 'P':
X	      StartString(DCS);
X	      break;
X	    case '^':
X	      StartString(PM);
X	      break;
X	    case '"':
X	    case 'k':
X	      StartString(AKA);
X	      break;
X	    default:
X	      if (Special(c))
X		break;
X	      if (c >= ' ' && c <= '/')
X		intermediate = intermediate ? -1 : c;
X	      else if (c >= '0' && c <= '~')
X		{
X		  DoESC(c, intermediate);
X		  curr->state = LIT;
X		}
X	      else
X		{
X		  curr->state = LIT;
X		  goto NextChar;
X		}
X	    }
X	  break;
X	case CSI:
X	  switch (c)
X	    {
X	    case '0':
X	    case '1':
X	    case '2':
X	    case '3':
X	    case '4':
X	    case '5':
X	    case '6':
X	    case '7':
X	    case '8':
X	    case '9':
X	      if (curr->NumArgs < MAXARGS)
X		{
X		  curr->args[curr->NumArgs] =
X		    10 * curr->args[curr->NumArgs] + c - '0';
X		}
X	      break;
X	    case ';':
X	    case ':':
X	      curr->NumArgs++;
X	      break;
X	    default:
X	      if (Special(c))
X		break;
X	      if (c >= '@' && c <= '~')
X		{
X		  curr->NumArgs++;
X		  DoCSI(c, intermediate);
X		  if (curr->state != PRIN)
X		    curr->state = LIT;
X		}
X	      else if ((c >= ' ' && c <= '/') || (c >= '<' && c <= '?'))
X		intermediate = intermediate ? -1 : c;
X	      else
X		{
X		  curr->state = LIT;
X		  goto NextChar;
X		}
X	    }
X	  break;
X	case LIT:
X	default:
X	  if (!Special(c))
X	    {
X	      if (c == '\033')
X		{
X		  intermediate = 0;
X		  curr->state = ESC;
X		  if (display && lp_missing && (CIC || IC || IM))
X		    {
X		      RedisplayLine(blank, null, null, screenbot,
X				    cols - 2, cols - 1);
X		      GotoPos(curr->x, curr->y);
X		    }
X		  if (curr->autoaka < 0)
X		    curr->autoaka = 0;
X		}
X	      else if (c < ' ')
X		break;
X	      else
X		{
X		  NewRendition(curr->LocalAttr);
X		  NewCharset(curr->charsets[(curr->ss) ? curr->ss :
X					     curr->LocalCharset]);
X		  if (curr->x < cols - 1)
X		    {
X		      if (curr->insert)
X			InsertAChar(c);
X		      else
X			{
X			  if (display)
X			    PUTCHAR(c);
X			  SetChar(c);
X			}
X		      curr->x++;
X		    }
X		  else if (curr->x == cols - 1)
X		    {
X		      if (curr->wrap && (LP || !force_vt || COP))
X			{
X			  if (display)
X			    RAW_PUTCHAR(c);
X			  SetChar(c);
X			  if (AM && !LP)
X			    {
X			      curr->x = 0; /* terminal auto-wrapped */
X			      LineFeed(0);
X			    }
X			  else
X			    curr->x++;
X			}
X		      else
X			{
X			  if (display)
X			    {
X			      if (LP || curr->y != screenbot)
X				{
X				  RAW_PUTCHAR(c);
X				  GotoPos(curr->x, curr->y);
X				}
X			      else
X				CheckLP(c);
X			    }
X			  SetChar(c);
X			  if (curr->wrap)
X			    curr->x++;
X			}
X		    }
X		  else
X		    {
X		      LineFeed(2); /* cr+lf, handle LP */
X		      if (curr->insert)
X			InsertAChar(c);
X		      else
X			{
X			  if (display)
X			    PUTCHAR(c);
X			  SetChar(c);
X			}
X		      curr->x = 1;
X		    }
X		  if (curr->ss)
X		    {
X		      NewCharset(curr->charsets[curr->LocalCharset]);
X		      curr->ss = 0;
X		    }
X		}
X	    }
X	}
X    } while (--len);
X  curr->outlen = 0;
X  if (curr->state == PRIN)
X    PrintFlush();
X}
X
static int Special(c)
register int c;
X{
X  switch (c)
X    {
X    case '\b':
X      BackSpace();
X      return 1;
X    case '\r':
X      Return();
X      return 1;
X    case '\n':
X      if (curr->autoaka)
X	FindAKA();
X      LineFeed(1);
X      return 1;
X    case '\007':
X      if (!visual_bell)
X	PutStr(BL);
X      else
X	{
X	  if (!VB)
X	    curr->bell = BELL_VISUAL;
X	  else
X	    PutStr(VB);
X	}
X      if (!display)
X	curr->bell = BELL_ON;
X      return 1;
X    case '\t':
X      ForwardTab();
X      return 1;
X    case '\017':		/* SI */
X      MapCharset(G0);
X      return 1;
X    case '\016':		/* SO */
X      MapCharset(G1);
X      return 1;
X    }
X  return 0;
X}
X
static void DoESC(c, intermediate)
int c, intermediate;
X{
X  switch (intermediate)
X    {
X    case 0:
X      switch (c)
X	{
X	case 'E':
X	  LineFeed(2);
X	  break;
X	case 'D':
X	  LineFeed(1);
X	  break;
X	case 'M':
X	  ReverseLineFeed();
X	  break;
X	case 'H':
X	  curr->tabs[curr->x] = 1;
X	  break;
X	case 'Z':		/* jph: Identify as VT100 */
X	  Report(curr, "\033[?%d;%dc", 1, 2);
X	  break;
X	case '7':
X	  SaveCursor();
X	  break;
X	case '8':
X	  RestoreCursor();
X	  break;
X	case 'c':
X	  ClearScreen();
X	  ResetScreen(curr);
X	  NewRendition(0);
X	  NewCharset(ASCII);
X	  InsertMode(0);
X	  KeypadMode(0);
X	  ChangeScrollRegion(0, rows-1);
X	  break;
X	case '=':
X	  KeypadMode(1);
X	  curr->keypad = 1;
X	  if (curr->autoflow)
X	    FlowMode(curr->flow = 0);
X	  break;
X	case '>':
X	  KeypadMode(0);
X	  curr->keypad = 0;
X	  if (curr->autoflow)
X	    FlowMode(curr->flow = 1);
X	  break;
X	case 'n':		/* LS2 */
X	  MapCharset(G2);
X	  break;
X	case 'o':		/* LS3 */
X	  MapCharset(G3);
X	  break;
X	case 'N':		/* SS2 */
X	  if (curr->charsets[curr->LocalCharset] != curr->charsets[G2])
X	    curr->ss = G2;
X	  else
X	    curr->ss = 0;
X	  break;
X	case 'O':		/* SS3 */
X	  if (curr->charsets[curr->LocalCharset] != curr->charsets[G3])
X	    curr->ss = G3;
X	  else
X	    curr->ss = 0;
X	  break;
X	}
X      break;
X    case '#':
X      switch (c)
X	{
X	case '8':
X	  FillWithEs();
X	  break;
X	}
X      break;
X    case '(':
X      DesignateCharset(c, G0);
X      break;
X    case ')':
X      DesignateCharset(c, G1);
X      break;
X    case '*':
X      DesignateCharset(c, G2);
X      break;
X    case '+':
X      DesignateCharset(c, G3);
X      break;
X    }
X}
X
static void DoCSI(c, intermediate)
int c, intermediate;
X{
X  register int i, a1 = curr->args[0], a2 = curr->args[1];
X
X  if (curr->NumArgs > MAXARGS)
X    curr->NumArgs = MAXARGS;
X  switch (intermediate)
X    {
X    case 0:
X      switch (c)
X	{
X	case 'H':
X	case 'f':
X	  if (a1 < 1)
X	    a1 = 1;
X	  if (curr->origin)
X	    a1 += curr->top;
X	  if (a1 > rows)
X	    a1 = rows;
X	  if (a2 < 1)
X	    a2 = 1;
X	  if (a2 > cols)
X	    a2 = cols;
X	  GotoPos(--a2, --a1);
X	  curr->x = a2;
X	  curr->y = a1;
X	  if (curr->autoaka)
X	    curr->autoaka = a1 + 1;
X	  break;
X	case 'J':
X	  if (a1 < 0 || a1 > 2)
X	    a1 = 0;
X	  switch (a1)
X	    {
X	    case 0:
X	      ClearToEOS();
X	      break;
X	    case 1:
X	      ClearFromBOS();
X	      break;
X	    case 2:
X	      ClearScreen();
X	      GotoPos(curr->x, curr->y);
X	      break;
X	    }
X	  break;
X	case 'K':
X	  if (a1 < 0 || a1 > 2)
X	    a1 %= 3;
X	  switch (a1)
X	    {
X	    case 0:
X	      ClearToEOL();
X	      break;
X	    case 1:
X	      ClearFromBOL();
X	      break;
X	    case 2:
X	      ClearLine();
X	      break;
X	    }
X	  break;
X	case 'A':
X	  CursorUp(a1 ? a1 : 1);
X	  break;
X	case 'B':
X	  CursorDown(a1 ? a1 : 1);
X	  break;
X	case 'C':
X	  CursorRight(a1 ? a1 : 1);
X	  break;
X	case 'D':
X	  CursorLeft(a1 ? a1 : 1);
X	  break;
X	case 'm':
X	  SelectRendition();
X	  break;
X	case 'g':
X	  if (a1 == 0)
X	    curr->tabs[curr->x] = 0;
X	  else if (a1 == 3)
X	    bzero(curr->tabs, cols);
X	  break;
X	case 'r':
X	  if (!a1)
X	    a1 = 1;
X	  if (!a2)
X	    a2 = rows;
X	  if (a1 < 1 || a2 > rows || a1 >= a2)
X	    break;
X	  curr->top = a1 - 1;
X	  curr->bot = a2 - 1;
X	  ChangeScrollRegion(curr->top, curr->bot);
X	  if (curr->origin)
X	    {
X	      GotoPos(0, curr->top);
X	      curr->y = curr->top;
X	      curr->x = 0;
X	    }
X	  else
X	    {
X	      GotoPos(0, 0);
X	      curr->y = curr->x = 0;
X	    }
X	  break;
X	case 's':
X	  SaveCursor();
X	  break;
X	case 't':
X	  if (a1 != 8)
X	    break;
X	  a1 = curr->args[2];
X	  if (a1 < 1)
X	    a1 = curr->width;
X	  if (a2 < 1)
X	    a2 = curr->height;
X	  if (WS == NULL)
X	    {
X	      a2 = curr->height;
X	      if (Z0 == NULL || (a1 != Z0width && a1 != Z1width))
X	        a1 = curr->width;
X 	    }
X	  if (a1 == curr->width && a2 == curr->height)
X	    break;
X          ChangeWindowSize(curr, a1, a2);
X	  SetCurr(curr);
X	  if (display)
X	    Activate();
X	  break;
X	case 'u':
X	  RestoreCursor();
X	  break;
X	case 'I':
X	  if (!a1)
X	    a1 = 1;
X	  while (a1--)
X	    ForwardTab();
X	  break;
X	case 'Z':
X	  if (!a1)
X	    a1 = 1;
X	  while (a1--)
X	    BackwardTab();
X	  break;
X	case 'L':
X	  InsertLine(a1 ? a1 : 1);
X	  break;
X	case 'M':
X	  DeleteLine(a1 ? a1 : 1);
X	  break;
X	case 'P':
X	  DeleteChar(a1 ? a1 : 1);
X	  break;
X	case '@':
X	  InsertChar(a1 ? a1 : 1);
X	  break;
X	case 'h':
X	  ASetMode(1);
X	  break;
X	case 'l':
X	  ASetMode(0);
X	  break;
X	case 'i':
X	  if (PO && a1 == 5)
X	    {
X	      curr->stringp = curr->string;
X	      curr->state = PRIN;
X	    }
X	  break;
X	case 'n':
X	  if (a1 == 6)		/* Report cursor position */
X	    Report(curr, "\033[%d;%dR", curr->y + 1, curr->x + 1);
X	  break;
X	case 'c':		/* Identify as VT100 */
X	  Report(curr, "\033[?%d;%dc", 1, 2);
X	  break;
X	}
X      break;
X    case '?':
X      debug2("\\E[?%d%c\n",a1,c);
X      if (c != 'h' && c != 'l')
X	break;
X      i = (c == 'h');
X      switch (a1)
X	{
X	case 3:
X	  i = (i ? Z0width : Z1width);
X	  if ((Z0 || WS) && curr->width != i)
X	    {
X              ChangeWindowSize(curr, i, curr->height);
X	      SetCurr(curr);
X	      if (display)
X		Activate();
X	    }
X	  break;
X	case 5:
X	  if (i)
X	    curr->vbwait = 1;
X	  else
X	    {
X	      if (curr->vbwait)
X		PutStr(VB);
X	      curr->vbwait = 0;
X	    }
X	  break;
X	case 6:
X	  if ((curr->origin = i) != 0)
X	    {
X	      GotoPos(0, curr->top);
X	      curr->y = curr->top;
X	      curr->x = 0;
X	    }
X	  else
X	    {
X	      GotoPos(0, 0);
X	      curr->y = curr->x = 0;
X	    }
X	  break;
X	case 7:
X	  curr->wrap = i;
X	  break;
X	case 35:
X	  debug1("Cursor %svisible\n", i?"in":"");
X	  curr->cursor_invisible = i;
X	  break;
X	}
X      break;
X    }
X}
X
void
INSERTCHAR(c)
int c;
X{
X  if (!insert && (IC || CIC))
X    {
X      if (IC)
X        PutStr(IC);
X      else
X        CPutStr(CIC, 1);
X      RAW_PUTCHAR(c);
X      return;
X    }
X  InsertMode(1);
X  if (insert)
X    RAW_PUTCHAR(c);
X  else
X    RefreshLine(screeny, screenx, screenwidth-1);
X}
X
void
PUTCHAR(c)
int c;
X{
X  if (insert)
X    InsertMode(0);
X  RAW_PUTCHAR(c);
X}
X
X/*
X * RAW_PUTCHAR() is for all text that will be displayed.
X * NOTE, that charset Nr. 0 has a conversion table, but c1, c2, ... don't.
X */
X
static void
RAW_PUTCHAR(c)
int c;
X{
X  if (GlobalCharset == '0')
X    putchar(c0_tab[c]);
X  else
X    putchar(c);
X  if (screenx < screenwidth - 1)
X    screenx++;
X  else
X    {
X      screenx++;
X      if ((AM && !LP) || screenx > screenwidth)
X	{
X	  screenx -= screenwidth;
X	  if (screeny < screenheight-1 && screeny != screenbot)
X	    screeny++;
X	}
X    }
X}
X
void
PutChar(c)
int c;
X{
X  /* this PutChar for ESC-sequences only */
X  putchar(c);
X}
X
void
PutStr(s)
char *s;
X{
X  if (display && s)
X    tputs(s, 1, PutChar);
X}
X
static void CPutStr(s, c)
char *s;
int c;
X{
X  if (display && s)
X    tputs(tgoto(s, 0, c), 1, PutChar);
X}
X
static void SetChar(c)
register int c;
X{
X  register struct win *p = curr;
X
X  p->image[p->y][p->x] = c;
X  p->attr[p->y][p->x] = p->LocalAttr;
X  p->font[p->y][p->x] = p->charsets[p->ss ? p->ss : p->LocalCharset];
X}
X
static void StartString(type)
enum string_t type;
X{
X  curr->StringType = type;
X  curr->stringp = curr->string;
X  curr->state = ASTR;
X}
X
static void AddChar(c)
int c;
X{
X  if (curr->stringp >= curr->string + MAXSTR - 1)
X    curr->state = LIT;
X  else
X    *(curr->stringp)++ = c;
X}
X
static void PrintChar(c)
int c;
X{
X  if (curr->stringp >= curr->string + MAXSTR - 1)
X    PrintFlush();
X  *(curr->stringp)++ = c;
X}
X
static void PrintFlush()
X{
X  if (curr->stringp > curr->string)
X    {
X      tputs(PO, 1, PutChar);
X      (void) fflush(stdout);
X      (void) write(1, curr->string, curr->stringp - curr->string);
X      tputs(PF, 1, PutChar);
X      (void) fflush(stdout);
X      curr->stringp = curr->string;
X    }
X}
X
X/* Insert mode is a toggle on some terminals, so we need this hack:
X */
void
InsertMode(on)
int on;
X{
X  if (display && on != insert && IM)
X    {
X      insert = on;
X      if (insert)
X	PutStr(IM);
X      else
X	PutStr(EI);
X    }
X}
X
X/* ...and maybe keypad application mode is a toggle, too:
X */
static void KeypadMode(on)
int on;
X{
X  if (display && keypad != on && KS)
X    {
X      keypad = on;
X      if (keypad)
X	PutStr(KS);
X      else
X	PutStr(KE);
X    }
X}
X
static void FlowMode(on)
int on;
X{
X  if (display && flow != on)
X    {
X      flow = on;
X      SetFlow(on);
X    }
X}
X
void
ToggleFlow()
X{
X  flow = fore->flow = !fore->flow;
X  SetFlow(flow);
X}
X
static void DesignateCharset(c, n)
int c, n;
X{
X  curr->ss = 0;
X  if (c == 'B')
X    c = ASCII;
X  if (curr->charsets[n] != c)
X    {
X      curr->charsets[n] = c;
X      if (curr->LocalCharset == n)
X	NewCharset(c);
X    }
X}
X
static void MapCharset(n)
int n;
X{
X  curr->ss = 0;
X  if (curr->LocalCharset != n)
X    {
X      curr->LocalCharset = n;
X      NewCharset(curr->charsets[n]);
X    }
X}
X
void
NewCharset(new)
int new;
X{
X  if (!display || GlobalCharset == new)
X    return;
X  GlobalCharset = new;
X  if (new == ASCII)
X    PutStr(E0);
X  else
X    CPutStr(S0, new);
X}
X
static void SaveCursor()
X{
X  curr->saved = 1;
X  curr->Saved_x = curr->x;
X  curr->Saved_y = curr->y;
X  curr->SavedLocalAttr = curr->LocalAttr;
X  curr->SavedLocalCharset = curr->LocalCharset;
X  bcopy((char *) curr->charsets, (char *) curr->SavedCharsets,
X	4 * sizeof(int));
X}
X
static void RestoreCursor()
X{
X  if (curr->saved)
X    {
X      GotoPos(curr->Saved_x, curr->Saved_y);
X      curr->x = curr->Saved_x;
X      curr->y = curr->Saved_y;
X      curr->LocalAttr = curr->SavedLocalAttr;
X      NewRendition(curr->LocalAttr);
X      bcopy((char *) curr->SavedCharsets, (char *) curr->charsets,
X	    4 * sizeof(int));
X      curr->LocalCharset = curr->SavedLocalCharset;
X      NewCharset(curr->charsets[curr->LocalCharset]);
X    }
X}
X
X/*ARGSUSED*/
static void CountChars(c)
int c;
X{
X  StrCost++;
X}
X
static int CalcCost(s)
register char *s;
X{
X  if (s)
X    {
X      StrCost = 0;
X      tputs(s, 1, CountChars);
X      return StrCost;
X    }
X  else
X    return EXPENSIVE;
X}
X
void
GotoPos(x2, y2)
int x2, y2;
X{
X  register int dy, dx, x1, y1;
X  register int costx, costy;
X  register int m;
X  register char *s;
X  int CMcost;
X  enum move_t xm = M_NONE, ym = M_NONE;
X
X  if (!display)
X    return;
X
X  x1 = screenx;
X  y1 = screeny;
X
X  if (x1 == screenwidth)
X    if (LP && AM)
X      x1 = -1;		/* don't know how the terminal treats this */
X    else
X      x1--;
X  if (x2 == screenwidth)
X    x2--;
X  dx = x2 - x1;
X  dy = y2 - y1;
X  if (dy == 0 && dx == 0)
X    {
X      return;
X    }
X  if (!MS && GlobalAttr)	/* Save to move in SO mode ? */
X    NewRendition(0);
X  if (y1 < 0			/* don't know the y position */
X      || (y2 > screenbot && y1 <= screenbot)	/* have to cross border */
X      || (y2 < screentop && y1 >= screentop))	/* of scrollregion ?    */
X    {
X    DoCM:
X      if (HO && !x2 && !y2)
X        PutStr(HO);
X      else
X        PutStr(tgoto(CM, x2, y2));
X      screenx = x2;
X      screeny = y2;
X      return;
X    }
X  /* Calculate CMcost */
X  if (HO && !x2 && !y2)
X    s = HO;
X  else
X    s = tgoto(CM, x2, y2);
X  CMcost = CalcCost(s);
X
X  /* Calculate the cost to move the cursor to the right x position */
X  costx = EXPENSIVE;
X  if (x1 >= 0)	/* relativ x positioning only if we know where we are */
X    {
X      if (dx > 0)
X	{
X	  if (CRI && (dx > 1 || !ND))
X	    {
X	      costx = CalcCost(tgoto(CRI, 0, dx));
X	      xm = M_CRI;
X	    }
X	  if ((m = NDcost * dx) < costx)
X	    {
X	      costx = m;
X	      xm = M_RI;
X	    }
X	  /* Speedup: dx <= Rewrite() */
X	  if (dx < costx && (m = Rewrite(y1, x1, x2, 0)) < costx)
X	    {
X	      costx = m;
X	      xm = M_RW;
X	    }
X	}
X      else if (dx < 0)
X	{
X	  if (CLE && (dx < -1 || !BC))
X	    {
X	      costx = CalcCost(tgoto(CLE, 0, -dx));
X	      xm = M_CLE;
X	    }
X	  if ((m = -dx * LEcost) < costx)
X	    {
X	      costx = m;
X	      xm = M_LE;
X	    }
X	}
X      else
X	costx = 0;
X    }
X  /* Speedup: Rewrite() >= x2 */
X  if (x2 + CRcost < costx && (m = Rewrite(y1, 0, x2, 0) + CRcost) < costx)
X    {
X      costx = m;
X      xm = M_CR;
X    }
X
X  /* Check if it is already cheaper to do CM */
X  if (costx >= CMcost)
X    goto DoCM;
X
X  /* Calculate the cost to move the cursor to the right y position */
X  costy = EXPENSIVE;
X  if (dy > 0)
X    {
X      if (CDO && dy > 1)	/* DO & NL are always != 0 */
X	{
X	  costy = CalcCost(tgoto(CDO, 0, dy));
X	  ym = M_CDO;
X	}
X      if ((m = dy * ((x2 == 0) ? NLcost : DOcost)) < costy)
X	{
X	  costy = m;
X	  ym = M_DO;
X	}
X    }
X  else if (dy < 0)
X    {
X      if (CUP && (dy < -1 || !UP))
X	{
X	  costy = CalcCost(tgoto(CUP, 0, -dy));
X	  ym = M_CUP;
X	}
X      if ((m = -dy * UPcost) < costy)
X	{
X	  costy = m;
X	  ym = M_UP;
X	}
X    }
X  else
X    costy = 0;
X
X  /* Finally check if it is cheaper to do CM */
X  if (costx + costy >= CMcost)
X    goto DoCM;
X
X  switch (xm)
X    {
X    case M_LE:
X      while (dx++ < 0)
X	PutStr(BC);
X      break;
X    case M_CLE:
X      CPutStr(CLE, -dx);
X      break;
X    case M_RI:
X      while (dx-- > 0)
X	PutStr(ND);
X      break;
X    case M_CRI:
X      CPutStr(CRI, dx);
X      break;
X    case M_CR:
X      PutStr(CR);
X      screenx = 0;
X      x1 = 0;
X      /* FALLTHROUGH */
X    case M_RW:
X      if (x1 < x2)
X	Rewrite(y1, x1, x2, 1);
X      break;
X    default:
X      break;
X    }
X  switch (ym)
X    {
X    case M_UP:
X      while (dy++ < 0)
X	PutStr(UP);
X      break;
X    case M_CUP:
X      CPutStr(CUP, -dy);
X      break;
X    case M_DO:
X      s =  (x2 == 0) ? NL : DO;
X      while (dy-- > 0)
X	PutStr(s);
X      break;
X    case M_CDO:
X      CPutStr(CDO, dy);
X      break;
X    default:
X      break;
X    }
X  screenx = x2;
X  screeny = y2;
X}
X
static int
Rewrite(y, x1, x2, doit)
int y, x1, x2, doit;
X{
X  register int cost, dx;
X  register char *p, *f, *i;
X
X  if (x1 == x2)
X    return(0);
X  if (in_ovl)
X    {
X      if (ovl_Rewrite == 0)
X        return EXPENSIVE;
X      else
X        return ((*ovl_Rewrite)(y, x1, x2, doit));
X    }
X  dx = x2 - x1;
X  if (doit)
X    {
X      i = curr->image[y] + x1;
X      while (dx-- > 0)
X	PUTCHAR(*i++);
X      return(0);
X    }
X  p = curr->attr[y] + x1;
X  f = curr->font[y] + x1;
X
X  cost = dx = x2 - x1;
X  if (insert)
X    cost += EIcost + IMcost;
X  while(dx-- > 0)
X    {
X      if (*p++ != GlobalAttr || *f++ != GlobalCharset)
X	return EXPENSIVE;
X    }
X  return cost;
X}
X
static void BackSpace()
X{
X  if (curr->x > 0)
X    {
X      curr->x--;
X    }
X  else if (curr->wrap && curr->y > 0)
X    {
X      curr->x = cols - 1;
X      curr->y--;
X    }
X  if (display)
X    GotoPos(curr->x, curr->y);
X}
X
static void Return()
X{
X  if (curr->x > 0)
X    {
X      curr->x = 0;
X      if (display)
X        GotoPos(curr->x, curr->y);
X    }
X}
X
static void LineFeed(out_mode)
int out_mode;
X{
X  /* out_mode: 0=no-output lf, 1=lf, 2=cr+lf */
X  if (out_mode == 2)
X    curr->x = 0;
X  if (curr->y != curr->bot)		/* Don't scroll */
X    {
X      if (curr->y < rows-1)
X	curr->y++;
X      if (out_mode && display)
X	GotoPos(curr->x, curr->y);
X      return;
X    }
X  ScrollUpMap(1);
X  if (curr->autoaka > 1)
X    curr->autoaka--;
X  if (out_mode && display)
X    {
X      ScrollRegion(curr->top, curr->bot, 1);
X      GotoPos(curr->x, curr->y);
X    }
X}
X
static void ReverseLineFeed()
X{
X  if (curr->y == curr->top)
X    {
X      ScrollDownMap(1);
X      if (!display)
X	return;
X      ScrollRegion(curr->top, curr->bot, -1);
X      GotoPos(curr->x, curr->y);
X    }
X  else if (curr->y > 0)
X    CursorUp(1);
X}
X
static void InsertAChar(c)
int c;
X{
X  register int y = curr->y, x = curr->x;
X
X  if (x == cols)
X    x--;
X  bcopy(curr->image[y], OldImage, cols);
X  bcopy(curr->attr[y], OldAttr, cols);
X  bcopy(curr->font[y], OldFont, cols);
X  bcopy(curr->image[y] + x, curr->image[y] + x + 1, cols - x - 1);
X  bcopy(curr->attr[y] + x, curr->attr[y] + x + 1, cols - x - 1);
X  bcopy(curr->font[y] + x, curr->font[y] + x + 1, cols - x - 1);
X  SetChar(c);
X  if (!display)
X    return;
X  if (CIC || IC || IM)
X    {
X      InsertMode(curr->insert);
X      INSERTCHAR(c);
X      if (y == screenbot)
X	lp_missing = 0;
X    }
X  else
X    {
X      RedisplayLine(OldImage, OldAttr, OldFont, y, x, cols - 1);
X      GotoPos(++x, y);
X    }
X}
X
static void InsertChar(n)
int n;
X{
X  register int i, y = curr->y, x = curr->x;
X
X  if (n <= 0)
X    return;
X  /*
X   * The termcap manual states that only one of IM and IC is
X   * to be defined unless the terminal needs both sequences.
X   * We don't like this because we think that there may be cases
X   * where it is preferable to send IC instead of IM/EI.
X   * The hack is to ignore the IC sequence if we are already
X   * in insert mode, so that programs which follow the termcap
X   * guidelines still work. (I don't believe that there are
X   * terminals which need IC in the insert mode. Why switch to
X   * insert mode if you must send IC before every character ???)
X   */
X  if (curr->insert)
X    return;
X  if (x == cols)
X    --x;
X  bcopy(curr->image[y], OldImage, cols);
X  bcopy(curr->attr[y], OldAttr, cols);
X  bcopy(curr->font[y], OldFont, cols);
X  if (n > cols - x)
X    n = cols - x;
X  bcopy(curr->image[y] + x, curr->image[y] + x + n, cols - x - n);
X  bcopy(curr->attr[y] + x, curr->attr[y] + x + n, cols - x - n);
X  bcopy(curr->font[y] + x, curr->font[y] + x + n, cols - x - n);
X  ClearInLine(0, y, x, x + n - 1);
X  if (!display)
X    return;
X  if (IC || CIC || IM)
X    {
X      if (y == screenbot)
X	lp_missing = 0;
X      if (!insert)
X	{
X	  if (n == 1 && IC)
X	    {
X	      PutStr(IC);
X	      return;
X            }
X	  if (CIC)
X	    {
X	      CPutStr(CIC, n);
X	      return;
X            }
X	}
X      InsertMode(1);
X      for (i = n; i--; )
X	INSERTCHAR(' ');
X      GotoPos(x, y);
X    }
X  else
X    {
X      RedisplayLine(OldImage, OldAttr, OldFont, y, x, cols - 1);
X      GotoPos(x, y);
X    }
X}
X
static void DeleteChar(n)
int n;
X{
X  register int i, y = curr->y, x = curr->x;
X
X  if (x == cols)
X    --x;
X  bcopy(curr->image[y], OldImage, cols);
X  bcopy(curr->attr[y], OldAttr, cols);
X  bcopy(curr->font[y], OldFont, cols);
X  if (n > cols - x)
X    n = cols - x;
X  bcopy(curr->image[y] + x + n, curr->image[y] + x, cols - x - n);
X  bcopy(curr->attr[y] + x + n, curr->attr[y] + x, cols - x - n);
X  bcopy(curr->font[y] + x + n, curr->font[y] + x, cols - x - n);
X  ClearInLine(0, y, cols - n, cols - 1);
X  if (!display)
X    return;
X  if (CDC && !(n == 1 && DC))
X    {
X      CPutStr(CDC, n);
X      if (lp_missing && y == screenbot)
X	{
X	  FixLP(cols - 1 - n, y);
X          GotoPos(x, y);
X	}
X    }
X  else if (DC)
X    {
X      for (i = n; i; i--)
X	PutStr(DC);
X      if (lp_missing && y == screenbot)
X	{
X	  FixLP(cols - 1 - n, y);
X          GotoPos(x, y);
X	}
X    }
X  else
X    {
X      RedisplayLine(OldImage, OldAttr, OldFont, y, x, cols - 1);
X      GotoPos(x, y);
X    }
X}
X
static void DeleteLine(n)
int n;
X{
X  register int old = curr->top;
X  
X  if (curr->y < curr->top || curr->y > curr->bot)
X    return;
X  if (n > curr->bot - curr->y + 1)
X    n = curr->bot - curr->y + 1;
X  curr->top = curr->y;
X  ScrollUpMap(n);
X  curr->top = old;
X  if (!display)
X    return;
X  ScrollRegion(curr->y, curr->bot, n);
X  GotoPos(curr->x, curr->y);
X}
X
static void InsertLine(n)
int n;
X{
X  register int old = curr->top;
X
X  if (curr->y < curr->top || curr->y > curr->bot)
X    return;
X  if (n > curr->bot - curr->y + 1)
X    n = curr->bot - curr->y + 1;
X  curr->top = curr->y;
X  ScrollDownMap(n);
X  curr->top = old;
X  if (!display)
X    return;
X  ScrollRegion(curr->y, curr->bot, -n);
X  GotoPos(curr->x, curr->y);
X}
X
void
ScrollRegion(ys, ye, n)
int ys, ye, n;
X{
X  int i;
X  int up;
X  int oldtop, oldbot;
X  int alok, dlok, aldlfaster;
X  int missy = 0;
X
X  if (n == 0)
X    return;
X  if (ys == 0 && ye == screenheight-1 && 
X      (n >= screenheight || -n >= screenheight))
X    {
X      PutStr(CL);
X      screeny = screenx = 0;
X      lp_missing = 0;
X      return;
X    }
X
X  if (lp_missing)
X    {
X      if (screenbot>ye || screenbot<ys)
X	missy = screenbot;
X      else
X	{
X	  missy = screenbot - n;
X          if (missy>ye || missy<ys)
X	    lp_missing = 0;
X	}
X    }
X
X  up = 1;
X  if (n < 0)
X    {
X      up = 0;
X      n = -n;
X    }
X  if (n >= ye-ys+1)
X    n = ye-ys+1;
X
X  oldtop = screentop;
X  oldbot = screenbot;
X  if (screenbot != ye)
X    ChangeScrollRegion(ys, ye);
X  alok = (AL || CAL || (ye == screenbot &&  up));
X  dlok = (DL || CDL || (ye == screenbot && !up));
X  if (screentop != ys && !(alok && dlok))
X    ChangeScrollRegion(ys, ye);
X
X  if (lp_missing && 
X      (oldbot != screenbot ||
X       oldbot == screenbot && up && screentop == ys && screenbot == ye))
X    {
X      /* Can't use FixLP */
X      GotoPos(screenwidth-1, oldbot);
X      SaveSetAttr(curr->attr[missy][screenwidth-1], curr->font[missy][screenwidth-1]);
X      PUTCHAR(curr->image[missy][screenwidth-1]);
X      RestoreAttr();
X      lp_missing = 0;
X      if (oldbot == screenbot)		/* have scrolled */
X	{
X	  if (--n == 0)
X	    {
X	      ChangeScrollRegion(oldtop, oldbot);
X	      return;
X	    }
X	}
X    }
X
X  aldlfaster = (n > 1 && ye == screenbot && (up && CDL || !up && CAL));
X
X  if ((up || SR) && screentop == ys && screenbot == ye && !aldlfaster)
X    {
X      if (up)
X	{
X	  GotoPos(0, ye);
X	  while (n-- > 0)
X	    PutStr(NL); /* was SF, I think NL is faster */
X	}
X      else
X	{
X	  GotoPos(0, ys);
X	  while (n-- > 0)
X	    PutStr(SR);
X	}
X    }
X  else if (alok && dlok)
X    {
X      if (up || ye != screenbot)
X	{
X          GotoPos(0, up ? ys : ye+1-n);
X          if (CDL && !(n == 1 && DL))
X	    CPutStr(CDL, n);
X	  else
X	    for(i=n; i--; )
X	      PutStr(DL);
X	}
X      if (!up || ye != screenbot)
X	{
X          GotoPos(0, up ? ye+1-n : ys);
X          if (CAL && !(n == 1 && AL))
X	    CPutStr(CAL, n);
X	  else
X	    for(i=n; i--; )
X	      PutStr(AL);
X	}
X    }
X  else
X    {
X      Redisplay();
X      return;
X    }
X  if (lp_missing && missy != screenbot)
X    FixLP(screenwidth-1, missy);
X  ChangeScrollRegion(oldtop, oldbot);
X  if (lp_missing && missy != screenbot)
X    FixLP(screenwidth-1, missy);
X}
X
static void ScrollUpMap(n)
int n;
X{
X  char tmp[256 * sizeof(char *)];
X  register int ii, i, cnt1, cnt2;
X  register char **ppi, **ppa, **ppf;
X
X  i = curr->top + n;
X  cnt1 = n * sizeof(char *);
X  cnt2 = (curr->bot - i + 1) * sizeof(char *);
X  ppi = curr->image + i;
X  ppa = curr->attr + i;
X  ppf = curr->font + i;
X  for(ii = curr->top; ii < i; ii++)
X     AddLineToHist(curr, &curr->image[ii], &curr->attr[ii], &curr->font[ii]);
X  for (i = n; i; --i)
X    {
X      bclear(*--ppi, cols);
X      bzero(*--ppa, cols);
X      bzero(*--ppf, cols);
X    }
X  Scroll((char *) ppi, cnt1, cnt2, tmp);
X  Scroll((char *) ppa, cnt1, cnt2, tmp);
X  Scroll((char *) ppf, cnt1, cnt2, tmp);
X}
X
static void ScrollDownMap(n)
int n;
X{
X  char tmp[256 * sizeof(char *)];
X  register int i, cnt1, cnt2;
X  register char **ppi, **ppa, **ppf;
X
X  i = curr->top;
X  cnt1 = (curr->bot - i - n + 1) * sizeof(char *);
X  cnt2 = n * sizeof(char *);
X  Scroll((char *) (ppi = curr->image + i), cnt1, cnt2, tmp);
X  Scroll((char *) (ppa = curr->attr + i), cnt1, cnt2, tmp);
X  Scroll((char *) (ppf = curr->font + i), cnt1, cnt2, tmp);
X  for (i = n; i; --i)
X    {
X      bclear(*ppi++, cols);
X      bzero(*ppa++, cols);
X      bzero(*ppf++, cols);
X    }
X}
X
static void Scroll(cp, cnt1, cnt2, tmp)
char *cp, *tmp;
int cnt1, cnt2;
X{
X  if (!cnt1 || !cnt2)
X    return;
X  if (cnt1 <= cnt2)
X    {
X      bcopy(cp, tmp, cnt1);
X      bcopy(cp + cnt1, cp, cnt2);
X      bcopy(tmp, cp + cnt2, cnt1);
X    }
X  else
X    {
X      bcopy(cp + cnt1, tmp, cnt2);
X      bcopy(cp, cp + cnt2, cnt1);
X      bcopy(tmp, cp, cnt2);
X    }
X}
X
static void ForwardTab()
X{
X  register int x = curr->x;
X
X  if (x == cols)
X    {
X      LineFeed(2);
X      x = 0;
X    }
X  if (curr->tabs[x] && x < cols - 1)
X    x++;
X  while (x < cols - 1 && !curr->tabs[x])
X    x++;
X  GotoPos(x, curr->y);
X  curr->x = x;
X}
X
static void BackwardTab()
X{
X  register int x = curr->x;
X
X  if (curr->tabs[x] && x > 0)
X    x--;
X  while (x > 0 && !curr->tabs[x])
X    x--;
X  GotoPos(x, curr->y);
X  curr->x = x;
X}
X
static void ClearScreen()
X{
X  register int i;
X  register char **ppi = curr->image, **ppa = curr->attr, **ppf = curr->font;
X
X  for (i = 0; i < rows; ++i)
X    {
X      AddLineToHist(curr, ppi, ppa, ppf);
X      bclear(*ppi++, cols);
X      bzero(*ppa++, cols);
X      bzero(*ppf++, cols);
X    }
X  if (display)
X    {
X      PutStr(CL);
X      screenx = screeny = 0;
X      lp_missing = 0;
X    }
X}
X
static void ClearFromBOS()
X{
X  register int n, y = curr->y, x = curr->x;
X
X  for (n = 0; n < y; ++n)
X    ClearInLine(1, n, 0, cols - 1);
X  ClearInLine(1, y, 0, x);
X  GotoPos(x, y);
X  RestoreAttr();
X}
X
static void ClearToEOS()
X{
X  register int n, y = curr->y, x = curr->x;
X
X  if (!y && !x)
X    {
X      ClearScreen();
X      return;
X    }
X  if (display && CD)
X    {
X      PutStr(CD);
X      lp_missing = 0;
X    }
X  ClearInLine(!CD, y, x, cols - 1);
X  for (n = y + 1; n < rows; n++)
X    ClearInLine(!CD, n, 0, cols - 1);
X  GotoPos(x, y);
X  RestoreAttr();
X}
X
static void ClearLine()
X{
X  register int y = curr->y, x = curr->x;
X
X  ClearInLine(1, y, 0, cols - 1);
X  GotoPos(x, y);
X  RestoreAttr();
X}
X
static void ClearToEOL()
X{
X  register int y = curr->y, x = curr->x;
X
X  ClearInLine(1, y, x, cols - 1);
X  GotoPos(x, y);
X  RestoreAttr();
X}
X
static void ClearFromBOL()
X{
X  register int y = curr->y, x = curr->x;
X
X  ClearInLine(1, y, 0, x);
X  GotoPos(x, y);
X  RestoreAttr();
X}
X
static void ClearInLine(displ, y, x1, x2)
int displ, y, x1, x2;
X{
X  register int n;
X
X  if (x1 == cols)
X    x1--;
X  if (x2 == cols)
X    x2--;
X  if ((n = x2 - x1 + 1) != 0)
X    {
X      if (displ && display)
X	{
X	  if (x2 == cols - 1 && CE)
X	    {
X	      GotoPos(x1, y);
X	      PutStr(CE);
X	      if (y == screenbot)
X		lp_missing = 0;
X	    }
X	  else
X	    DisplayLine(curr->image[y], curr->attr[y], curr->font[y],
X			blank, null, null, y, x1, x2);
X	}
X      if (curr)
X	{
X          bclear(curr->image[y] + x1, n);
X          bzero(curr->attr[y] + x1, n);
X          bzero(curr->font[y] + x1, n);
X	}
X    }
X}
X
static void CursorRight(n)
register int n;
X{
X  register int x = curr->x;
X
X  if (x == cols)
X    {
X      LineFeed(2);
X      x = 0;
X    }
X  if ((curr->x += n) >= cols)
X    curr->x = cols - 1;
X  GotoPos(curr->x, curr->y);
X}
X
static void CursorUp(n)
register int n;
X{
X  if (curr->y < curr->top)		/* if above scrolling rgn, */
X    {
X      if ((curr->y -= n) < 0)		/* ignore it's limits      */
X         curr->y = 0;
X    }
X  else
X    if ((curr->y -= n) < curr->top)
X      curr->y = curr->top;
X  GotoPos(curr->x, curr->y);
X}
X
static void CursorDown(n)
register int n;
X{
X  if (curr->y > curr->bot)		/* if below scrolling rgn, */
X    {
X      if ((curr->y += n) > rows - 1)	/* ignore it's limits      */
X        curr->y = rows - 1;
X    }
X  else
X    if ((curr->y += n) > curr->bot)
X      curr->y = curr->bot;
X  GotoPos(curr->x, curr->y);
X}
X
static void CursorLeft(n)
register int n;
X{
X  if ((curr->x -= n) < 0)
X    curr->x = 0;
X  GotoPos(curr->x, curr->y);
X}
X
static void ASetMode(on)
int on;
X{
X  register int i;
X
X  for (i = 0; i < curr->NumArgs; ++i)
X    {
X      switch (curr->args[i])
X	{
X	case 4:
X	  curr->insert = on;
X	  InsertMode(on);
X	  break;
X	}
X    }
X}
X
static void SelectRendition()
X{
X  register int i = 0, a = curr->LocalAttr;
X
X  do
X    {
X      switch (curr->args[i])
X	{
X	case 0:
X	  a = 0;
X	  break;
X	case 1:
X	  a |= A_BD;
X	  break;
X	case 2:
X	  a |= A_DI;
X	  break;
X	case 3:
X	  a |= A_SO;
X	  break;
X	case 4:
X	  a |= A_US;
X	  break;
X	case 5:
X	  a |= A_BL;
X	  break;
X	case 7:
X	  a |= A_RV;
X	  break;
X	case 22:
X	  a &= ~(A_BD | A_SO | A_DI);
X	  break;
X	case 23:
X	  a &= ~A_SO;
X	  break;
X	case 24:
X	  a &= ~A_US;
X	  break;
X	case 25:
X	  a &= ~A_BL;
X	  break;
X	case 27:
X	  a &= ~A_RV;
X	  break;
X	}
X    } while (++i < curr->NumArgs);
X  NewRendition(curr->LocalAttr = a);
X}
X
void
NewRendition(new)
register int new;
X{
X  register int i, old = GlobalAttr;
X
X  if (!display || old == new)
X    return;
X  GlobalAttr = new;
X  for (i = 1; i <= A_MAX; i <<= 1)
X    {
X      if ((old & i) && !(new & i))
X	{
X	  PutStr(UE);
X	  PutStr(SE);
X	  PutStr(ME);
X	  if (new & A_DI)
X	    PutStr(attrtab[ATTR_DI]);
X	  if (new & A_US)
X	    PutStr(attrtab[ATTR_US]);
X	  if (new & A_BD)
X	    PutStr(attrtab[ATTR_BD]);
X	  if (new & A_RV)
X	    PutStr(attrtab[ATTR_RV]);
X	  if (new & A_SO)
X	    PutStr(attrtab[ATTR_SO]);
X	  if (new & A_BL)
X	    PutStr(attrtab[ATTR_BL]);
X	  return;
X	}
X    }
X  if ((new & A_DI) && !(old & A_DI))
X    PutStr(attrtab[ATTR_DI]);
X  if ((new & A_US) && !(old & A_US))
X    PutStr(attrtab[ATTR_US]);
X  if ((new & A_BD) && !(old & A_BD))
X    PutStr(attrtab[ATTR_BD]);
X  if ((new & A_RV) && !(old & A_RV))
X    PutStr(attrtab[ATTR_RV]);
X  if ((new & A_SO) && !(old & A_SO))
X    PutStr(attrtab[ATTR_SO]);
X  if ((new & A_BL) && !(old & A_BL))
X    PutStr(attrtab[ATTR_BL]);
X}
X
void
SaveSetAttr(newattr, newcharset)
int newattr, newcharset;
X{
X  NewRendition(newattr);
X  NewCharset(newcharset);
X}
X
void
RestoreAttr()
X{
X  NewRendition(curr->LocalAttr);
X  NewCharset(curr->charsets[curr->LocalCharset]);
X}
X
static void FillWithEs()
X{
X  register int i;
X  register char *p, *ep;
X
X  curr->y = curr->x = 0;
X  for (i = 0; i < rows; ++i)
X    {
X      bzero(curr->attr[i], cols);
X      bzero(curr->font[i], cols);
X      p = curr->image[i];
X      ep = p + cols;
X      while (p < ep)
X	*p++ = 'E';
X    }
X  if (display)
X    Redisplay();
X}
X
void Redisplay()
X{
X  register int i;
X
X  PutStr(CL);
X  screenx = screeny = 0;
X  lp_missing = 0;
X  for (i = 0; i < rows; ++i)
X    {
X      if (in_ovl)
X	(*ovl_RedisplayLine)(i, 0, cols - 1, 1);
X      else
X        DisplayLine(blank, null, null, curr->image[i], curr->attr[i],
X		    curr->font[i], i, 0, cols - 1);
X    }
X  if (!in_ovl)
X    {
X      GotoPos(curr->x, curr->y);
X      NewRendition(curr->LocalAttr);
X      NewCharset(curr->charsets[curr->LocalCharset]);
X    }
X}
X
void
DisplayLine(os, oa, of, s, as, fs, y, from, to)
int from, to, y;
register char *os, *oa, *of, *s, *as, *fs;
X{
X  register int x;
X  int last2flag = 0, delete_lp = 0;
X
X  if (!LP && y == screenbot && to == cols - 1)
X    if (lp_missing
X	|| s[to] != os[to] || as[to] != oa[to] || of[to] != fs[to])
X      {
X	if ((IC || IM) && (from < to || !in_ovl))
X	  {
X	    if ((to -= 2) < from - 1)
X	      from--;
X	    last2flag = 1;
X	    lp_missing = 0;
X	  }
X	else
X	  {
X	    to--;
X	    delete_lp = (CE || DC || CDC);
X	    lp_missing = (s[to] != ' ' || as[to] || fs[to]);
X	  }
X      }
X    else
X      to--;
X  for (x = from; x <= to; ++x)
X    {
X      if (s[x] == os[x] && as[x] == oa[x] && of[x] == fs[x])
X	continue;
X      GotoPos(x, y);
X      NewRendition(as[x]);
X      NewCharset(fs[x]);
X      PUTCHAR(s[x]);
X    }
X  if (last2flag)
X    {
X      GotoPos(x, y);
X      NewRendition(as[x + 1]);
X      NewCharset(fs[x + 1]);
X      PUTCHAR(s[x + 1]);
X      GotoPos(x, y);
X      NewRendition(as[x]);
X      NewCharset(fs[x]);
X      INSERTCHAR(s[x]);
X    }
X  else if (delete_lp)
X    {
X      if (DC)
X	PutStr(DC);
X      else if (CDC)
X	CPutStr(CDC, 1);
X      else if (CE)
X	PutStr(CE);
X    }
X}
X
void
RefreshLine(y, from, to)
int y, from, to;
X{
X  char *oi = null;
X
X  if (CE && to == screenwidth-1)
X    {
X      GotoPos(from, y);
X      PutStr(CE);
X      oi = blank;
X    }
X  if (in_ovl)
X    (*ovl_RedisplayLine)(y, from, to, (oi == blank));
X  else
X    DisplayLine(oi, null, null, curr->image[y], curr->attr[y],
X                curr->font[y], y, from, to);
X}
X
static void RedisplayLine(os, oa, of, y, from, to)
int from, to, y;
char *os, *oa, *of;
X{
X  DisplayLine(os, oa, of, curr->image[y], curr->attr[y],
X	      curr->font[y], y, from, to);
X  NewRendition(curr->LocalAttr);
X  NewCharset(curr->charsets[curr->LocalCharset]);
X}
X
void
XFixLP(x2, y2)
register int x2, y2;
X{
X  register struct win *p = curr;
X
X  GotoPos(x2, y2);
X  SaveSetAttr(p->attr[y2][x2], p->font[y2][x2]);
X  PUTCHAR(p->image[y2][x2]);
X  RestoreAttr();
X  lp_missing = 0;
X}
X
void
CheckLP(n_ch)
char n_ch;
X{
X  register int y = screenbot, x = cols - 1;
X  register char n_at, n_fo, o_ch, o_at, o_fo;
X
X  o_ch = curr->image[y][x];
X  o_at = curr->attr[y][x];
X  o_fo = curr->font[y][x];
X
X  n_at = curr->LocalAttr;
X  n_fo = curr->charsets[curr->LocalCharset];
X
X  lp_missing = 0;
X  if (n_ch == o_ch && n_at == o_at && n_fo == o_fo)
X    {
X      return;
X    }
X  if (n_ch != ' ' || n_at || n_fo)
X    lp_missing = 1;
X  if (o_ch != ' ' || o_at || o_fo)
X    {
X      if (DC)
X	PutStr(DC);
X      else if (CDC)
X	CPutStr(CDC, 1);
X      else if (CE)
X	PutStr(CE);
X      else
X	lp_missing = 1;
X    }
X}
X
static void FindAKA()
X{
X  register char *cp, *line, ch;
X  register struct win *wp = curr;
X  register int len = strlen(wp->cmd);
X  int y;
X
X  y = (wp->autoaka > 0 && wp->autoaka <= wp->height) ? wp->autoaka - 1 : wp->y;
X  cols = wp->width;
X try_line:
X  cp = line = wp->image[y];
X  if (wp->autoaka > 0 && (ch = *wp->cmd) != '\0')
X    {
X      for (;;)
X	{
X	  if ((cp = index(cp, ch)) != NULL
X	      && !strncmp(cp, wp->cmd, len))
X	    break;
X	  if (!cp || ++cp - line >= cols - len)
X	    {
X	      if (++y == wp->autoaka && y < rows)
X		goto try_line;
X	      return;
X	    }
X	}
X      cp += len;
X    }
X  for (len = cols - (cp - line); len && *cp == ' '; len--, cp++)
X    ;
X  if (len)
X    {
X      if (wp->autoaka > 0 && (*cp == '!' || *cp == '%' || *cp == '^'))
X	wp->autoaka = -1;
X      else
X	wp->autoaka = 0;
X      line = wp->cmd + wp->akapos;
X      while (len && *cp != ' ')
X	{
X	  if ((*line++ = *cp++) == '/')
X	    line = wp->cmd + wp->akapos;
X	  len--;
X	}
X      *line = '\0';
X    }
X  else
X    wp->autoaka = 0;
X}
X
X
X/* We dont use HS status line with Input.
X * If we would use it, then we should check e_tgetflag("es") if
X * we are allowed to use esc sequences there.
X * For now, we hope that Goto(,,STATLINE,0) brings us in the bottom
X * line. jw.
X */
X
static char inpbuf[101];
static int inplen;
static int inpmaxlen;
static char *inpstring;
static int inpstringlen;
static void (*inpfinfunc)();
X
void
Input(istr, len, finfunc)
char *istr;
int len;
void (*finfunc)();
X{
X  int maxlen;
X
X  inpstring = istr;
X  inpstringlen = strlen(istr);
X  if (len > 100)
X    len = 100;
X  maxlen = screenwidth - inpstringlen;
X  if (!LP && STATLINE == screenbot)
X    maxlen--;
X  if (len > maxlen)
X    len = maxlen;
X  if (len < 2)
X    {
X      Msg(0, "Width too small");
X      return;
X    }
X  inpmaxlen = len;
X  inpfinfunc = finfunc;
X  InitOverlayPage(process_inp_input, inpRedisplayLine, (int (*)())0, 1);
X  inplen = 0;
X  GotoPos(0, STATLINE);
X  if (CE)
X    PutStr(CE);
X  else
X    {
X      DisplayLine(curr->image[screeny], curr->attr[screeny],
X		  curr->font[screeny],
X		  blank, null, null, screeny, 0, cols - 1);
X    }
X  inpRedisplayLine(STATLINE, 0, inpstringlen - 1, 0);
X  GotoPos(inpstringlen, STATLINE);
X}
X
static void
process_inp_input(ppbuf, plen)
char **ppbuf;
int *plen;
X{
X  int len, x;
X  char *pbuf;
X  char ch;
X
X  if (ppbuf == 0)
X    {
X      AbortInp();
X      return;
X    }
X  x = inpstringlen+inplen;
X  len = *plen;
X  pbuf = *ppbuf;
X  while (len)
X    {
X      ch = *pbuf++;
X      len--;
X      if (ch >= ' ' && ch <= '~' && inplen < inpmaxlen)
X	{
X	  inpbuf[inplen++] = ch;
X  	  GotoPos(x, STATLINE);
X	  SaveSetAttr(A_SO, ASCII);
X	  PUTCHAR(ch);
X	  x++;
X	}
X      else if ((ch == '\b' || ch == 0177) && inplen > 0)
X	{
X	  inplen--;
X	  x--;
X  	  GotoPos(x, STATLINE);
X	  SaveSetAttr(0, ASCII);
X	  PUTCHAR(' ');
X  	  GotoPos(x, STATLINE);
X	}
X      else if (ch == '\004' || ch == '\003' || ch == '\000' || ch == '\n' || ch == '\r')
X	{
X          if (ch != '\n' && ch != '\r')
X	    inplen = 0;
X	  inpbuf[inplen] = 0;
X          AbortInp(); /* redisplays... */
X          (*inpfinfunc)(inpbuf, inplen);
X	  break;
X	}
X    }
X  *ppbuf = pbuf;
X  *plen = len;
X}
X
static void
AbortInp()
X{
X  in_ovl = 0;	/* So we can use RefreshLine() */
X  RefreshLine(STATLINE, 0, screenwidth-1);
X  ExitOverlayPage();
X}
X
static void
inpRedisplayLine(y, xs, xe, isblank)
int y, xs, xe, isblank;
X{
X  int q, r, s, l, v;
X
X  if (y != STATLINE)
X    return;
X  inpbuf[inplen] = 0;
X  GotoPos(xs,y);
X  q = xs;
X  v = xe - xs + 1;
X  s = 0;
X  r = inpstringlen;
X  if (v > 0 && q < r)
X    {
X      SaveSetAttr(A_SO, ASCII);
X      l = v;
X      if (l > r-q)
X	l = r-q;
X      printf("%-*.*s", l, l, inpstring + q - s);
X      q += l;
X      v -= l;
X    }
X  s = r;
X  r += inplen;
X  if (v > 0 && q < r)
X    {
X      SaveSetAttr(A_SO, ASCII);
X      l = v;
X      if (l > r-q)
X	l = r-q;
X      printf("%-*.*s", l, l, inpbuf + q - s);
X      q += l;
X      v -= l;
X    }
X  s = r;
X  r = screenwidth;
X  if (!isblank && v > 0 && q < r)
X    {
X      SaveSetAttr(0, ASCII);
X      l = v;
X      if (l > r-q)
X	l = r-q;
X      printf("%-*.*s", l, l, "");
X      q += l;
X    }
X  SetLastPos(q, y);
X}
X
static void
AKAfin(buf, len)
char *buf;
int len;
X{
X  if (len)
X    {
X      strcpy(curr->cmd + curr->akapos, buf);
X    }
X}
X
void
InputAKA()
X{
X  void Input(), AKAfin();
X
X  Input("Set window's a.k.a. to: ", 20, AKAfin);
X}
X
static void
Colonfin(buf, len)
char *buf;
int len;
X{
X  if (len)
X    RcLine(buf);
X}
X
void
InputColon()
X{
X  void Input(), Colonfin();
X
X  Input(":", 100, Colonfin);
X}
X
void
MakeBlankLine(p, n)
register char *p;
register int n;
X{
X  while (n--)
X    *p++ = ' ';
X}
X
void
MakeStatus(msg)
char *msg;
X{
X  register char *s, *t;
X  register int max, ti;
X
X  SetCurr(fore);
X  display = 1;
X  if (!(max = HS))
X    {
X      max = !LP ? cols - 1 : cols;
X    }
X  if (status)
X    {
X      if (!BellDisplayed)
X	{
X	  ti = time((time_t *) 0) - TimeDisplayed;
X	  if (ti < MsgMinWait)
X	    sleep(MsgMinWait - ti);
X	}
X      RemoveStatus();
X    }
X  for (s = t = msg; *s && t - msg < max; ++s)
X    if (*s == BELL)
X      PutStr(BL);
X    else if (*s >= ' ' && *s <= '~')
X      *t++ = *s;
X  *t = '\0';
X  if (t > msg)
X    {
X      strncpy(LastMsg, msg, maxwidth);
X      status = 1;
X      status_lastx = screenx;
X      status_lasty = screeny;
X      StatLen = t - msg;
X      if (!HS)
X	{
X	  GotoPos(0, STATLINE);
X          SaveSetAttr(A_SO, ASCII);
X	  InsertMode(0);
X	  printf("%s", msg);
X          screenx = -1;
X	}
X      else
X	{
X	  debug("HS:");
X          SaveSetAttr(A_SO, ASCII);
X	  InsertMode(0);
X	  CPutStr(TS, 0);
X	  printf("%s", msg);
X	  PutStr(FS);
X	}
X      (void) fflush(stdout);
X      (void) time(&TimeDisplayed);
X    }
X}
X
void
RemoveStatus()
X{
X  if (!status)
X    return;
X  status = 0;
X  BellDisplayed = 0;
X  SetCurr(fore);
X  display = 1;
X  if (!HS)
X    {
X      GotoPos(0, STATLINE);
X      if (in_ovl)
X	(*ovl_RedisplayLine)(STATLINE, 0, StatLen - 1, 0);
X      else
X	RedisplayLine(null, null, null, STATLINE, 0, StatLen - 1);
X      GotoPos(status_lastx, status_lasty);
X    }
X  else
X    {
X      PutStr(DS);
X    }
X}
X
void
ClearDisplay()
X{
X  PutStr(CL);
X  screeny = screenx = 0;
X  fflush(stdout);
X}
X
static void SetCurr(wp)
struct win *wp;
X{
X  curr = wp;
X  cols = curr->width;
X  rows = curr->height;
X  display = curr->active;
X}
X
void
InitOverlayPage(pro, red, rewrite, blockfore)
void (*pro)();
void (*red)();
int (*rewrite)();
int blockfore;
X{
X  RemoveStatus();
X  SetOvlCurr();
X  ChangeScrollRegion(0, screenheight - 1);
X  ovl_process = pro;
X  ovl_RedisplayLine = red;
X  ovl_Rewrite = rewrite;
X  ovl_blockfore = blockfore;
X  curr->active = 0;
X  in_ovl = 1;
X}
X
void
XExitOverlayPage()
X{
X  GotoPos(curr->x, curr->y);
X  RestoreAttr();
X  ChangeScrollRegion(curr->top, curr->bot);
X  curr->active = 1;
X  in_ovl = 0;
X}
X
void
SetOvlCurr()
X{
X  SetCurr(fore);
X  SaveSetAttr(0, ASCII);
X  InsertMode(0);
X  display = 1;
X}
X
void
SetLastPos(x,y)
int x,y;
X{
X  screenx = x;
X  screeny = y;
X}
X
void
WSresize(width, height)
int width, height;
X{
X  debug2("(display=%d:WSresize says:'%s'\n", display, tgoto(WS, width, height));
X  PutStr(tgoto(WS, width, height));
X}
X
void
ChangeScrollRegion(top, bot)
int top, bot;
X{
X  if (display == 0)
X    return;
X  if (CS == 0)
X    {
X      screentop = 0;
X      screenbot = screenheight - 1;
X      return;
X    }
X  if (top == screentop && bot == screenbot)
X    return;
X  debug2("ChangeScrollRegion: (%d - %d)\n", top, bot);
X  PutStr(tgoto(CS, bot, top));
X  screentop = top;
X  screenbot = bot;
X  screeny = screenx = -1;		/* Just in case... */
X}
X
X
void AddLineToHist(wp, pi, pa, pf)
struct win *wp;
char **pi, **pa, **pf;
X{
X  register char *q;
X
X  if (wp->histheight == 0)
X    return;
X  q = *pi; *pi = wp->ihist[wp->histidx]; wp->ihist[wp->histidx] = q;
X  q = *pa; *pa = wp->ahist[wp->histidx]; wp->ahist[wp->histidx] = q;
X  q = *pf; *pf = wp->fhist[wp->histidx]; wp->fhist[wp->histidx] = q;
X  if (++wp->histidx >= wp->histheight)
X    wp->histidx = 0;
X}
X
X
X/*
X *
X *  Termcap routines that use our extra_incap
X *
X */
X
X/* findcap:
X *   cap = capability we are looking for
X *   tepp = pointer to bufferpointer
X *   n = size of buffer (0 = infinity)
X */
X
char *
findcap(cap, tepp, n)
char *cap;
char **tepp;
int n;
X{
X  char *tep;
X  char c, *p, *cp;
X  int mode;	/* mode: 0=LIT  1=^  2=\x  3,4,5=\nnn */
X  int num = 0, capl;
X
X  if (!extra_incap)
X    return (0);
X  tep = *tepp;
X  capl = strlen(cap);
X  cp = 0;
X  mode = 0;
X  for (p = extra_incap; *p; )
X    {
X      if (strncmp(p, cap, capl) == 0)
X	{
X	  p+=capl;
X	  c = *p;
X	  if (c && c != ':' && c != '@')
X	    p++;
X	  if (c == 0 || c == '@' || c == '=' || c == ':' || c == '#')
X	    cp = tep;
X	}
X      while (c = *p)
X	{
X	  p++;
X	  if (mode == 0)
X	    {
X	      if (c == ':')
X	        break;
X	      if (c == '^')
X		mode = 1;
X	      if (c == '\\')
X		mode = 2;
X	    }
X	  else if (mode == 1)
X	    {
X	      c = c & 0x1f;
X	      mode = 0;
X	    }
X	  else if (mode == 2)
X	    {
X	      switch(c)
X		{
X		case '0':
X		case '1':
X		case '2':
X		case '3':
X		case '4':
X		case '5':
X		case '6':
X		case '7':
X		case '8':
X		case '9':
X		  mode = 3;
X		  num = 0;
X		  break;
X		case 'E':
X		  c = 27;
X		  break;
X		case 'n':
X		  c = '\n';
X		  break;
X		case 'r':
X		  c = '\r';
X		  break;
X		case 't':
X		  c = '\t';
X		  break;
X		case 'b':
X		  c = '\b';
X		  break;
X		case 'f':
X		  c = '\f';
X		  break;
X		}
X	      if (mode == 2)
X		mode = 0;
X	    }
X	  if (mode > 2)
X	    {
X	      num = num * 8 + (c - '0');
X	      if (mode++ == 5 || (*p < '0' || *p > '9'))
X		{
X		  c = num;
X		  mode = 0;
X		}
X	    }
X	  if (mode)
X	    continue;
X
X	  if (cp && n != 1)
X	    {
X	      *cp++ = c;
X	      n--;
X	    }
X	}
X      if (cp)
X	{
X	  *cp++ = 0;
X	  *tepp = cp;
X	  debug2("'%s' found in extra_incap -> %s\n", cap, tep);
X	  return(tep);
X	}
X    }
X  return(0);
X}
X
static char *
e_tgetstr(cap, tepp)
char *cap;
char **tepp;
X{
X  char *tep;
X  if (tep = findcap(cap, tepp, 0))
X    return((*tep == '@') ? 0 : tep);
X  return (tgetstr(cap, tepp));
X}
X
static int
e_tgetflag(cap)
char *cap;
X{
X  char buf[2], *bufp;
X  char *tep;
X  bufp = buf;
X  if (tep = findcap(cap, &bufp, 2))
X    return((*tep == '@') ? 0 : 1);
X  return (tgetflag(cap));
X}
X
static int
e_tgetnum(cap)
char *cap;
X{
X  char buf[20], *bufp;
X  char *tep, c;
X  int res, base = 10;
X
X  bufp = buf;
X  if (tep = findcap(cap, &bufp, 20))
X    {
X      c = *tep;
X      if (c == '@')
X	return(-1);
X      if (c == '0')
X	base = 8;
X      res = 0;
X      while ((c = *tep++) >= '0' && c <= '9')
X	res = res * base + (c - '0');
X      return(res);
X    }
X  return (tgetnum(cap));
X}
END_OF_FILE
if test 68134 -ne `wc -c <'ansi.c'`; then
    echo shar: \"'ansi.c'\" unpacked with wrong size!
fi
# end of 'ansi.c'
fi
echo shar: End of archive 7 \(of 8\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
