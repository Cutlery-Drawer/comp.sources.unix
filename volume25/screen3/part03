Newsgroups: comp.sources.unix
From: jnweiger@immd4.informatik.uni-erlangen.de (Juergen Weigert)
Subject: v25i043: Screen3 - multiple windows on an ASCII terminal, Part03/08
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: jnweiger@immd4.informatik.uni-erlangen.de (Juergen Weigert)
Posting-Number: Volume 25, Issue 43
Archive-Name: screen3/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 8)."
# Contents:  CHANGES COPYING config/config.gould_np1 help.c screen.h
#   window.c
# Wrapped by vixie@cognition.pa.dec.com on Thu Dec 19 17:36:05 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGES'\"
else
echo shar: Extracting \"'CHANGES'\" \(9292 characters\)
sed "s/^X//" >'CHANGES' <<'END_OF_FILE'
X3.1.1
X------
X
iScreen is now under the GNU copyleft license. See file COPYING.
X
command line option -A. $LINES, $COLUMNS improved.
X
C-A : vbell_wait <sec>
X
XXENIX support (Ronald Khoo)
X
SYSV has uname() instead of gethostname().
X
hpux has setresuid.
X
ClearScreen now saves image to scrollback buffer.
X
mips has setenv.
X
numerous bugfixes.
X
X3.1 finally released version.
X=============================
X
X3.0.99: last minute changes:
X----------------------------
X
MIPS support (J{rvinen Markku)
X
SVR4 support (Marc Boucher)
X
secopen() secfopen() calls replace stat/access/open.
C-a : echo improved.
X'register int'
X
Changes up to Screen 3.0 Patchlevel 7
X=====================================
X
Better terminfo support: Screen now checks if a termcap/info
entry which the name "screen.$TERM" does exist. Look in the
X"VIRTUAL TERMINAL" section of the manual for more details.
X
Many security improvements.
X
ScrollRegion() bug fixed which caused slow scrolling if AL
or DL was used.
X
Pyramid and Ultrix support added. (Tim and Larry)
X  
XENVIRONMENT support.
X  /local/etc/screenrc checks for $SYSSCREENRC
X  $HOME/.screenrc checks for $ISCREENRC and $SCREENRC
X  /local/screens checks for $ISCREENDIR and $SCREENDIR
X  .screenrc understands ${VAR} and $VAR .
X
screen 3.0 Patchlevel 6
X=======================
X
X.screenrc:
X  screen now only opens the windows you explicitly ask for. if you 
X  specify none, you still get one window, of course.
X
screen 3.0. Patchlevel 5
X========================
X
Ansi prototyping by Christos.
X
copy mode: CTRL-U / CTRL-D exchanged. code cleanup.
X
changes to screen 3.0 patchlevel 4
X==================================
X
markkeys "string"
X  allows to rebind the keys used in copy/history mode.
X  string is made up of pairs "<oldchar>=<newchar>" which are separated
X  by a colon. Oldchar and newchar are either single ascii characters, 
X  or the two character sequence ^x, where x is an ascii character, or
X  a 3 digit octal value prepended with '\'. the string "\040=.:^M=q"
X  rebinds '.' to set marks, and the return rey will abort copy mode.
X
set scrollback 100
X  resizes the scrollback history buffer to 100 lines. a default of 50
X  is installed. 
X
A Howard Chu like scrollback history is installed. Many vi-like keys
X  are added to the copy mode. The '?' key reports on cursor position.
X
screen 3.0 Patchlevel 3
X=======================
X
WriteString fixed, it did kill the display variable.
X
Yet another LP bugfix.
X
non vt100 semi-graphics character support.
X
waynes patch fixed
X
screen 3.0 Patchlevel 2
X=======================
X
wayne patches cursor motion outside scrollregions.
X
X.screenrc 
X  monitor on|off
X
changes in Screen 3.0 Patchlevel 1
X==================================
X
screen -wipe
X
X^A : set vbell_msg "Wuff Wuff"
X
Thousand enhancements: help resizible, copy'n'paste in main
X  socket loop, and no more '\0' hackin'. :WS=\E8;%d;%dt:
X
screen can now resize windows under sunview.
X
X^A : set crlf on|off
X  effects markroutine join.
X
screen learned about sized windows under X
X
screen -ls (-d) -q
X  quiet option. We count the number of detached (attached) sessions and set
X  a return value of 10+n. The -q option inhibits all startup
X  warnings/messages. i.e. screen -R -q may return with code 12 or higher
X  or start a new/old session.
X
pow_detach_msg "text string"
X  new command, allows messages, terminal reset, etc. on logout caused
X  by pow_detach.
X
X^A : learned a new keyword "set":
X  commands like "login on" , "vbell off", ... affect the default for
X  windows to be created. But commands like "set login off" affect
X  the actual setting of this window. and not the default.
X  such commands may be bound to keys. example: 
X  bind 'O' set login off
X  is valid in your .screenrc as well as typed at the ':' prompt.
X  a bonus is ":set all" which is synonym to ":help".
X  At the Colon prompt also KeyNames can be entered, alothough that makes
X  not always sense.
X
X^A x uses a builtin lockprg, if 
X  a) we don't find our lockprg, or
X  b) user supplies us with the environmet variable LOCKPRG set to "builtin"
X  the builtin locks until your login password is typed. on systems using
X  "shadow password files" you are prompted for a password.
X
markroutine can append joined.
X
screen removes the "controlling tty" from utmp while ptys are attached.
X
markroutine performs CR+NL when '\n' is pressed
X
screen may die quietly, when no TERMCAP entry for "screen" is
found, and screen is run under X-windows
X
X_SEQUENT_ marks sequent386_ptx
X
screen runs now under SunOS4.1.1 (we need setsid()!).
X
bug in SetForeWindow fixed.
X
rare markroutine bug fixed.
X
we dont open every file the attacher tells us.
X
we have now our wonderful "Wuff, Wuff" visual_bell
X
we have now the interprocess-communication-buffer. secure version.
X
X'^A =' removes the interprocess-communication-buffer.
X
markroutine as in 2.1
X
markroutine: 'a' toggles append mode,
X             '>' like ' ', but immediately WriteFile(DUMP_EXCHANGE) then.
X             'A' like ' ', but first switch to append mode.
X
X.screenrc understands "screen 2:faui09 rlogin faui09 -l jnweiger"
X                  and "password none"
X                  and "vbell [on|off]"
X
X'^A :' allows .screenrc commands "online".
X
screen now receives new $TERM from attacher, when it is reattached 
X
MakeClientSocket() fifo version does now test for access.
X
X.screenrc learns "hardstatus {on|off}"
X
termcap's VB is used for vbell if available.
X
Attach() code rewritten:
X	screen now lists socket directory, if it does not find a suitable socket
X	screen -d [host.tty] detaches a running screen. 
X
screen -[ls|list]
X	list all sockets that we find in our sockdir
X
when the socket has been removed, send a SIGCHLD to the poor SCREEN 
process and it will try to recover. then try a 'screen -r' again.
all the socket stuff lives now in an extra file.
X
Major changes in version 2.4:
X=============================
X
X*  Test version that presents the erlangen extensions from 2.0 in a 2.3
X   screen.
X
X*  window resize support
X
X*  screen locking C-a x
X
X*  support for SYSV
X
X*  password protection
X
X*  copy & paste across screens
X
X*  remote detach and power detach
X
Major changes in version 2.3:
X
X*  Terminal emulation has been significantly enhanced and bugfixed.
X
X*  We now fully update the last character on the screen for true auto-
X   margin terminals, though there may be some delay before the character
X   can be safely added to the screen.  If your terminal has character
X   insert it will be used to shorten the delay.
X
X*  Added the "termcap" .screenrc command to tweak your terminal's termcap
X   entry AND to customize the termcap generated for the virtual terminals.
X   See also the -L and -O command-line options, and the SCREENCAP environ-
X   ment variable.
X
X*  Fixed screen's character handling when detached or suspended to NOT block
X   the child processes in their windows -- output continues to be processed
X   in the background.
X
X*  Added a.k.a.s (window-name aliases) that allow you to customize the
X   window-information line, including being able to change the name on-
X   the-fly to reflect what's currently running in the window (see the
X   -k option, shellaka command, and ALSO KNOWN AS discussion in the doc).
X
X*  Added the ability to log the output of a window to a file (see the
X   "C-a H" (log) command).
X
X*  Flow-control can now be set for each window and switched interactively
X   (see the "flow" command, -f option, and FLOW CONTROL discussion).
X
X*  Individual windows can be included or excluded from mention in the
X   /etc/utmp file (see the "login" command and -l option).
X
X*  Added an activity monitor, which allows you to have a window watched for
X   the start of any output and alert you when it occurs (see the "C-a M"
X   (monitor) command).
X
X*  Enhanced the information in the window-information line to keep track of
X   windows that have: logging turned on '(L)'; beeped in the background '!';
X   became active while being monitored '@' (see the "C-a w" (windows) command).
X
X*  Added an on-line help display that lists all the commands and their
X   key bindings (see the "C-a ?" (help) command).
X
X*  Extended handling of the beep message (and also the new activity message)
X   to allow '~' to specify a literal beep (see the "beep" and "activity"
X   .screenrc commands).
X
X*  You can now set the default action on receipt of a hangup signal:  detach
X   or terminate (see the "autodetach" .screenrc command).
X
X*  Routing of characters to their virtual terminals has been enhanced to
X   not drop characters nor (in rare circumstances) hang up screen.
X
X*  The NFS compatibility has been enhanced.
X
Major changes in version 2.0a:
X
X*  Screen allows you to `detach' the "screen" session from the physical
X   terminal and resume it at a later point in time (possibly on a
X   different terminal or in a different login session).
X
X  To get an impression of this functionality do the following:
X
X     - call "screen" and create a couple of windows
X     - type Control-A Control-D (screen terminates; you are back
X       in the shell)
X     - call "screen -r" to resume the detached screen
X
X*  Screen supports multiple character sets and the ISO 2022 control
X   functions to designate and switch between character sets.
X   This allows you, for instance, to make use of the VT100 graphics
X   character set or national character sets.
END_OF_FILE
if test 9292 -ne `wc -c <'CHANGES'`; then
    echo shar: \"'CHANGES'\" unpacked with wrong size!
fi
# end of 'CHANGES'
fi
if test -f 'COPYING' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COPYING'\"
else
echo shar: Extracting \"'COPYING'\" \(9934 characters\)
sed "s/^X//" >'COPYING' <<'END_OF_FILE'
X		    GNU GENERAL PUBLIC LICENSE
X		     Version 1, February 1989
X
X Copyright (C) 1989 Free Software Foundation, Inc.
X                    675 Mass Ave, Cambridge, MA 02139, USA
X Everyone is permitted to copy and distribute verbatim copies
X of this license document, but changing it is not allowed.
X
X			    Preamble
X
X  The license agreements of most software companies try to keep users
at the mercy of those companies.  By contrast, our General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  The
General Public License applies to the Free Software Foundation's
software and to any other program whose authors commit to using it.
You can use it for your programs, too.
X
X  When we speak of free software, we are referring to freedom, not
price.  Specifically, the General Public License is designed to make
sure that you have the freedom to give away or sell copies of free
software, that you receive source code or can get it if you want it,
that you can change the software or use pieces of it in new free
programs; and that you know you can do these things.
X
X  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.
X
X  For example, if you distribute copies of a such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.
X
X  We protect your rights with two steps: (1) copyright the software, and
X(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.
X
X  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.
X
X  The precise terms and conditions for copying, distribution and
modification follow.
X
X		    GNU GENERAL PUBLIC LICENSE
X   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X
X  0. This License Agreement applies to any program or other work which
contains a notice placed by the copyright holder saying it may be
distributed under the terms of this General Public License.  The
X"Program", below, refers to any such program or work, and a "work based
on the Program" means either the Program or any work containing the
Program or a portion of it, either verbatim or with modifications.  Each
licensee is addressed as "you".
X
X  1. You may copy and distribute verbatim copies of the Program's source
code as you receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice and
disclaimer of warranty; keep intact all the notices that refer to this
General Public License and to the absence of any warranty; and give any
other recipients of the Program a copy of this General Public License
along with the Program.  You may charge a fee for the physical act of
transferring a copy.
X
X  2. You may modify your copy or copies of the Program or any portion of
it, and copy and distribute such modifications under the terms of Paragraph
X1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating that
X    you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish, that
X    in whole or in part contains the Program or any part thereof, either
X    with or without modifications, to be licensed at no charge to all
X    third parties under the terms of this General Public License (except
X    that you may choose to grant warranty protection to some or all
X    third parties, at your option).
X
X    c) If the modified program normally reads commands interactively when
X    run, you must cause it, when started running for such interactive use
X    in the simplest and most usual way, to print or display an
X    announcement including an appropriate copyright notice and a notice
X    that there is no warranty (or else, saying that you provide a
X    warranty) and that users may redistribute the program under these
X    conditions, and telling the user how to view a copy of this General
X    Public License.
X
X    d) You may charge a fee for the physical act of transferring a
X    copy, and you may at your option offer warranty protection in
X    exchange for a fee.
X
Mere aggregation of another independent work with the Program (or its
derivative) on a volume of a storage or distribution medium does not bring
the other work under the scope of these terms.
X
X  3. You may copy and distribute the Program (or a portion or derivative of
it, under Paragraph 2) in object code or executable form under the terms of
Paragraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal charge
X    for the cost of distribution) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
Source code for a work means the preferred form of the work for making
modifications to it.  For an executable file, complete source code means
all the source code for all modules it contains; but, as a special
exception, it need not include source code for modules which are standard
libraries that accompany the operating system on which the executable
file runs, or for standard header files or definitions files that
accompany that operating system.
X
X  4. You may not copy, modify, sublicense, distribute or transfer the
Program except as expressly provided under this General Public License.
Any attempt otherwise to copy, modify, sublicense, distribute or transfer
the Program is void, and will automatically terminate your rights to use
the Program under this License.  However, parties who have received
copies, or rights to use copies, from you under this General Public
License will not have their licenses terminated so long as such parties
remain in full compliance.
X
X  5. By copying, distributing or modifying the Program (or any work based
on the Program) you indicate your acceptance of this license to do so,
and all its terms and conditions.
X
X  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the original
licensor to copy, distribute or modify the Program subject to these
terms and conditions.  You may not impose any further restrictions on the
recipients' exercise of the rights granted herein.
X
X  7. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.
X
XEach version is given a distinguishing version number.  If the Program
specifies a version number of the license which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
the license, you may choose any version ever published by the Free Software
XFoundation.
X
X  8. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.
X
X			    NO WARRANTY
X
X  9. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
XFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.
X
X  10. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.
X
X		     END OF TERMS AND CONDITIONS
END_OF_FILE
if test 9934 -ne `wc -c <'COPYING'`; then
    echo shar: \"'COPYING'\" unpacked with wrong size!
fi
# end of 'COPYING'
fi
if test -f 'config/config.gould_np1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/config.gould_np1'\"
else
echo shar: Extracting \"'config/config.gould_np1'\" \(14876 characters\)
sed "s/^X//" >'config/config.gould_np1' <<'END_OF_FILE'
X/* Copyright (c) 1991
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * Noteworthy contributors to screen's design and implementation:
X *	Wayne Davison (davison@borland.com)
X *	Patrick Wolfe (pat@kai.com, kailand!pat)
X *	Bart Schaefer (schaefer@cse.ogi.edu)
X *	Nathan Glasser (nathan@brokaw.lcs.mit.edu)
X *	Larry W. Virden (lwv27%cas.BITNET@CUNYVM.CUNY.Edu)
X *	Howard Chu (hyc@hanauma.jpl.nasa.gov)
X *	Tim MacKenzie (tym@dibbler.cs.monash.edu.au)
X *	Markku Jarvinen (mta@{cc,cs,ee}.tut.fi)
X *	Marc Boucher (marc@CAM.ORG)
X *
X ****************************************************************
X * $Id: config.gould_np1,v 1.5 91/10/06 11:58:22 jnweiger Exp $ FAU
X */
X
X/*
X * config file by Chris Fletcher <ma8caf@uk.ac.bath.gdt>
X * The config file has been set up without the set uid and writing to
X * /etc/utmp options.
X ****************************************************************
X */
X
X/*
X *		Beginning of User Configuration Section
X *
X * First off, you should decide if you intend to install screen set-uid to
X * root.  This isn't necessary to use screen, but it allows the pseudo-ttys
X * to be set to their proper owner (for security purposes), /etc/utmp to be
X * updated, and /dev/kmem to be accessed to read the load average values.
X *
X * An alternative to installing screen set-uid root is to install it set-gid
X * utmp (with the file /etc/utmp installed to be group-utmp writable) or
X * set-gid kmem (with /dev/kmem set to be group-kmem readable) or some other
X * custom group to give you both.  The final alternative is to omit /etc/utmp
X * updating and the /dev/kmem reading (see the following defines) and simply
X * run screen as a regular program -- its major functions will be unaffected.
X */
X
X
X/*
X * Define POSIX if your system supports IEEE Std 1003.1-1988 (POSIX).
X */
X#undef POSIX
X
X/*
X * Define BSDJOBS if you have BSD-style job control (both process
X * groups and a tty that deals correctly with them).
X */
X#define BSDJOBS
X
X/*
X * Define TERMIO if you have struct termio instead of struct sgttyb.
X * This is usually the case for SVID systems, where BSD uses sgttyb.
X * POSIX systems should define this anyway, even though they use
X * struct termios.
X */
X#undef TERMIO
X
X/*
X * Define TERMINFO if your machine emulates the termcap routines
X * with the terminfo database.
X * Thus the .screenrc file is parsed for
X * the command 'terminfo' and not 'termcap'.
X */
X#undef TERMINFO
X
X/*
X * Define SYSV if your machine is SYSV complient (Sys V, HPUX, A/UX)
X */
X#undef SYSV
X
X/*
X * Define SIGVOID if your signal handlers return void.  On older
X * systems, signal returns int, but on newer ones, it returns void.
X */
X#undef SIGVOID 
X
X/*
X * Define DIRENT if your system has <dirent.h> instead of <sys/dir.h>
X */
X#undef DIRENT
X
X/*
X * If screen is going to be installed set-uid root, you MUST define SUIDROOT.
X */
X#undef SUIDROOT
X
X/*
X * If screen is installed with permissions to update /etc/utmp (such as if
X * it is installed set-uid root), define UTMPOK.  Set LOGINDEFAULT to one (1)
X * if you want entries added to /etc/utmp by default, else set it to zero (0).
X */
X#undef UTMPOK
X#define LOGINDEFAULT	0
X
X/*
X * If your system has getutent(), pututline(), etc. to write to the
X * utmp file, define GETUTENT.
X */
X#undef GETUTENT
X
X/*
X * Define UTHOST if the utmp file has a host field.
X */
X#define UTHOST
X
X/*
X * If UTMPOK is defined and your system (incorrectly) counts logins by
X * counting non-null entries in /etc/utmp (instead of counting non-null
X * entries with no hostname that are not on a pseudo tty), define USRLIMIT
X * to have screen put an upper-limit on the number of entries to write
X * into /etc/utmp.  This helps to keep you from exceeding a limited-user
X * license.
X */
X#undef USRLIMIT
X
X/*
X * If screen is NOT installed set-uid root, screen can provide tty security
X * by exclusively locking the ptys.  While this keeps other users from
X * opening your ptys, it also keeps your own subprocesses from being able
X * to open /dev/tty.  Define LOCKPTY to add this exclusive locking.
X */
X#undef LOCKPTY
X
X/*
X * If your system does not have the calls setreuid() and setregid(), define
X * NOREUID to force screen to use a forked process to safely create output
X * files without retaining any special privileges.  (Output logging will be
X * disabled, however.)
X */
X#undef NOREUID
X
X/*
X * If you want the "time" command to display the current load average
X * you must install screen with the needed privileges to read /dev/kmem
X * and have a load average format that screen understands.  We handle the
X * following formats:  3 doubles (BSD), 3 longs (sun), and 4 longs (alliant).
X */
X#define  LOADAV_3DOUBLES
X#undef LOADAV_3LONGS
X#undef  LOADAV_4LONGS
X
X/*
X * If your system has the new format /etc/ttys (like 4.3 BSD) and the
X * getttyent(3) library functions, define GETTTYENT.
X */
X#define GETTTYENT
X
X/*
X * If your version of NFS supports named sockets and you install screen
X * suid root, you may need to define NFS_HACK for screen to be able to
X * open the sockets.
X */
X#undef NFS_HACK
X
X/*
X * By default screen will create a directory named ".screen" in the user's
X * HOME directory to contain the named sockets.  If this causes you problems
X * (e.g. some user's HOME directories are NFS-mounted and don't support
X * named sockets) you can have screen create the socket directories in a
X * common subdirectory, such as /tmp or /usr/tmp.  It makes things a little
X * more secure if you choose a directory where the "sticky" bit is on, but
X * this isn't required.  Screen will name the subdirectories "S-$USER"
X * (e.g /tmp/S-davison).
X * Do not define TMPTEST unless it's for debugging purpose.
X * If you want to have your socket directory in "/tmp/screens" then
X * define LOCALSOCKDIR and change the definition of SOCKDIR below.
X */
X#undef LOCALSOCKDIR
X
X#ifdef LOCALSOCKDIR
X# ifndef TMPTEST
X#  define SOCKDIR "/local/screens"
X# else
X#  define SOCKDIR "/tmp/screens"
X# endif
X#endif
X
X/*
X * Define USEBCOPY if the bcopy() from your system's C library supports the
X * overlapping of source and destination blocks.  When undefined, screen
X * uses its own (probably slower) version of bcopy().
X */
X#define USEBCOPY
X
X/*
X * If you'd rather see the status line on the first line of your
X * terminal rather than the last, define TOPSTAT.
X */
X#undef TOPSTAT
X
X/*
X * If your system has vsprintf() and requires the use of the macros in
X * "varargs.h" to use functions with variable arguments,
X * define USEVARARGS.
X */
X#undef USEVARARGS
X
X/*
X * Define this if your system supports named pipes.
X */
X#undef NAMEDPIPE
X
X/*
X * here come the erlangen extensions to screen:
X * define LOCK if you want to use a lock program for a screenlock.
X * define PASSWORD for secure reattach of your screen.
X * define COPY_PASTE to use the famous hacker's treasure zoo.
X * define POW_DETACH to have a detach_and_logout key.
X * define REMOTE_DETACH (-d option) to move screen between terminals.
X * (jw)
X */
X#define LOCK
X#define PASSWORD
X#define COPY_PASTE
X#define REMOTE_DETACH
X#define POW_DETACH
X
X/*
X * As error messages are mostly meaningless to the user, we
X * try to throw out phrases that are somewhat more familiar
X * to ...well, at least familiar to us NetHack players.
X */
X#define NETHACK
X
X/*
X * and another sneaky feature: screen sources two startup files.
X * first a global file with a path specified here, second
X * your local $HOME/.screenrc
X * Don't define this, if you don't want it.
X */
X#undef ETCSCREENRC "/local/etc/screenrc"
X
X/*
X *	End of User Configuration Section
X */
X
X/*
X *		Beginning of User Configuration Section
X *
X * First off, you should decide if you intend to install screen set-uid to
X * root.  This isn't necessary to use screen, but it allows the pseudo-ttys
X * to be set to their proper owner (for security purposes), /etc/utmp to be
X * updated, and /dev/kmem to be accessed to read the load average values.
X *
X * An alternative to installing screen set-uid root is to install it set-gid
X * utmp (with the file /etc/utmp installed to be group-utmp writable) or
X * set-gid kmem (with /dev/kmem set to be group-kmem readable) or some other
X * custom group to give you both.  The final alternative is to omit /etc/utmp
X * updating and the /dev/kmem reading (see the following defines) and simply
X * run screen as a regular program -- its major functions will be unaffected.
X */
X
X
X/*
X * Define POSIX if your system supports IEEE Std 1003.1-1988 (POSIX).
X */
X#undef POSIX
X
X/*
X * Define BSDJOBS if you have BSD-style job control (both process
X * groups and a tty that deals correctly with them).
X */
X#define BSDJOBS
X
X/*
X * Define TERMIO if you have struct termio instead of struct sgttyb.
X * This is usually the case for SVID systems, where BSD uses sgttyb.
X * POSIX systems should define this anyway, even though they use
X * struct termios.
X */
X#undef TERMIO
X
X/*
X * Define TERMINFO if your machine emulates the termcap routines
X * with the terminfo database.
X * Thus the .screenrc file is parsed for
X * the command 'terminfo' and not 'termcap'.
X */
X#undef TERMINFO
X
X/*
X * Define SYSV if your machine is SYSV complient (Sys V, HPUX, A/UX)
X */
X#undef SYSV
X
X/*
X * Define SIGVOID if your signal handlers return void.  On older
X * systems, signal returns int, but on newer ones, it returns void.
X */
X#undef SIGVOID 
X
X/*
X * Define DIRENT if your system has <dirent.h> instead of <sys/dir.h>
X */
X#undef DIRENT
X
X/*
X * If screen is going to be installed set-uid root, you MUST define SUIDROOT.
X */
X#undef SUIDROOT
X
X/*
X * If screen is installed with permissions to update /etc/utmp (such as if
X * it is installed set-uid root), define UTMPOK.  Set LOGINDEFAULT to one (1)
X * if you want entries added to /etc/utmp by default, else set it to zero (0).
X */
X#undef UTMPOK
X#define LOGINDEFAULT	0
X
X/*
X * If your system has getutent(), pututline(), etc. to write to the
X * utmp file, define GETUTENT.
X */
X#undef GETUTENT
X
X/*
X * Define UTHOST if the utmp file has a host field.
X */
X#define UTHOST
X
X/*
X * If UTMPOK is defined and your system (incorrectly) counts logins by
X * counting non-null entries in /etc/utmp (instead of counting non-null
X * entries with no hostname that are not on a pseudo tty), define USRLIMIT
X * to have screen put an upper-limit on the number of entries to write
X * into /etc/utmp.  This helps to keep you from exceeding a limited-user
X * license.
X */
X#undef USRLIMIT
X
X/*
X * If screen is NOT installed set-uid root, screen can provide tty security
X * by exclusively locking the ptys.  While this keeps other users from
X * opening your ptys, it also keeps your own subprocesses from being able
X * to open /dev/tty.  Define LOCKPTY to add this exclusive locking.
X */
X#undef LOCKPTY
X
X/*
X * If your system does not have the calls setreuid() and setregid(), define
X * NOREUID to force screen to use a forked process to safely create output
X * files without retaining any special privileges.  (Output logging will be
X * disabled, however.)
X */
X#undef NOREUID
X
X/*
X * If you want the "time" command to display the current load average
X * you must install screen with the needed privileges to read /dev/kmem
X * and have a load average format that screen understands.  We handle the
X * following formats:  3 doubles (BSD), 3 longs (sun), and 4 longs (alliant).
X */
X#define  LOADAV_3DOUBLES
X#undef LOADAV_3LONGS
X#undef  LOADAV_4LONGS
X
X/*
X * If your system has the new format /etc/ttys (like 4.3 BSD) and the
X * getttyent(3) library functions, define GETTTYENT.
X */
X#define GETTTYENT
X
X/*
X * If your version of NFS supports named sockets and you install screen
X * suid root, you may need to define NFS_HACK for screen to be able to
X * open the sockets.
X */
X#undef NFS_HACK
X
X/*
X * By default screen will create a directory named ".screen" in the user's
X * HOME directory to contain the named sockets.  If this causes you problems
X * (e.g. some user's HOME directories are NFS-mounted and don't support
X * named sockets) you can have screen create the socket directories in a
X * common subdirectory, such as /tmp or /usr/tmp.  It makes things a little
X * more secure if you choose a directory where the "sticky" bit is on, but
X * this isn't required.  Screen will name the subdirectories "S-$USER"
X * (e.g /tmp/S-davison).
X * Do not define TMPTEST unless it's for debugging purpose.
X * If you want to have your socket directory in "/tmp/screens" then
X * define LOCALSOCKDIR and change the definition of SOCKDIR below.
X */
X#undef LOCALSOCKDIR
X
X#ifdef LOCALSOCKDIR
X# ifndef TMPTEST
X#  define SOCKDIR "/local/screens"
X# else
X#  define SOCKDIR "/tmp/screens"
X# endif
X#endif
X
X/*
X * Define USEBCOPY if the bcopy() from your system's C library supports the
X * overlapping of source and destination blocks.  When undefined, screen
X * uses its own (probably slower) version of bcopy().
X */
X#define USEBCOPY
X
X/*
X * If you'd rather see the status line on the first line of your
X * terminal rather than the last, define TOPSTAT.
X */
X#undef TOPSTAT
X
X/*
X * If your system has vsprintf() and requires the use of the macros in
X * "varargs.h" to use functions with variable arguments,
X * define USEVARARGS.
X */
X#undef USEVARARGS
X
X/*
X * Define this if your system supports named pipes.
X */
X#undef NAMEDPIPE
X
X/*
X * here come the erlangen extensions to screen:
X * define LOCK if you want to use a lock program for a screenlock.
X * define PASSWORD for secure reattach of your screen.
X * define COPY_PASTE to use the famous hacker's treasure zoo.
X * define POW_DETACH to have a detach_and_logout key.
X * define REMOTE_DETACH (-d option) to move screen between terminals.
X * (jw)
X */
X#define LOCK
X#define PASSWORD
X#define COPY_PASTE
X#define REMOTE_DETACH
X#define POW_DETACH
X
X/*
X * As error messages are mostly meaningless to the user, we
X * try to throw out phrases that are somewhat more familiar
X * to ...well, at least familiar to us NetHack players.
X */
X#define NETHACK
X
X/*
X * and another sneaky feature: screen sources two startup files.
X * first a global file with a path specified here, second
X * your local $HOME/.screenrc
X * Don't define this, if you don't want it.
X */
X#undef ETCSCREENRC "/local/etc/screenrc"
X
X/*
X *	End of User Configuration Section
X */
END_OF_FILE
if test 14876 -ne `wc -c <'config/config.gould_np1'`; then
    echo shar: \"'config/config.gould_np1'\" unpacked with wrong size!
fi
# end of 'config/config.gould_np1'
fi
if test -f 'help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.c'\"
else
echo shar: Extracting \"'help.c'\" \(12910 characters\)
sed "s/^X//" >'help.c' <<'END_OF_FILE'
X/* Copyright (c) 1991
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * Noteworthy contributors to screen's design and implementation:
X *	Wayne Davison (davison@borland.com)
X *	Patrick Wolfe (pat@kai.com, kailand!pat)
X *	Bart Schaefer (schaefer@cse.ogi.edu)
X *	Nathan Glasser (nathan@brokaw.lcs.mit.edu)
X *	Larry W. Virden (lwv27%cas.BITNET@CUNYVM.CUNY.Edu)
X *	Howard Chu (hyc@hanauma.jpl.nasa.gov)
X *	Tim MacKenzie (tym@dibbler.cs.monash.edu.au)
X *	Markku Jarvinen (mta@{cc,cs,ee}.tut.fi)
X *	Marc Boucher (marc@CAM.ORG)
X *
X ****************************************************************
X */
X
X#ifndef lint
X  static char rcs_id[] = "$Id: help.c,v 1.42 91/10/11 11:42:09 jnweiger Exp $ FAU";
X#endif
X
X#include "config.h"
X#include <stdio.h>
X#include <sys/types.h>
X#if defined(BSD) || defined(sequent) || defined(pyr)
X# include <strings.h>
X#else
X# include <string.h>
X#endif
X
X#include "screen.h"
X#include "ansi.h"
X#include "extern.h"
X#include "patchlevel.h"
X
int help_page = 0;
int command_search, command_bindings = 0;
extern char Esc, MetaEsc;
extern char *KeyNames[];
extern struct key ktab[];
extern int screenwidth, screenheight;
extern char *blank, *null, *CE;
extern struct win *fore;
X
static void centerline __P((char *));
static void HelpRedisplayLine __P((int, int, int, int));
static void process_help_input __P((char **, int *));
static void AbortHelp __P((void));
static void add_key_to_buf __P((char *, int));
X
void
exit_with_usage(myname)
char *myname;
X{
X  printf("Use: %s [-opts] [cmd [args]]\n", myname);
X  printf(" or: %s -r [host.tty]\n\nOptions:\n", myname);
X  printf("-a           Force all capabilities into each window's termcap\n");
X  printf("-A -[r|R]    Adapt all windows to the new display width & height\n");
X  printf("-c file      Read configuration file instead of .screenrc\n");
X#ifdef REMOTE_DETACH
X  printf("-d (-r)      Detach the elsewhere running screen (and reattach here)\n");
X  printf("-D (-r)      Detach and logout remote (and reattach here)\n");
X#endif
X  printf("-e xy        Change command characters\n");
X  printf("-f           Flow control on, -fn = off, -fa = auto\n");
X  printf("-h lines     Set the size of the scrollback history buffer\n");
X  printf("-i           Interrupt output sooner when flow control is on\n");
X  printf("-l           Login mode on (update /etc/utmp), -ln = off\n");
X  printf("-list        or -ls. Do nothing, just list our SockDir\n");
X  printf("-L           Terminal's last character can be safely updated\n");
X  printf("-O           Choose optimal output rather than exact vt100 emulation\n");
X  printf("-q           Quiet startup. Sets $status if unsuccessful.\n");
X  printf("-r           Reattach to a detached screen process\n");
X  printf("-R           Reattach if possible, otherwise start a new session\n");
X  printf("-s shell     Shell to execute rather than $SHELL\n");
X  printf("-T term      Use term as $TERM for windows, rather than \"screen\"\n");
X  printf("-t title     Set command's a.k.a. (window title)\n");
X  printf("-wipe        Do nothing, just clean up SockDir\n");
X  exit(1);
X}
X
X/* Esc-char is not consumed. All others are. Esc-char, space, and return end */
static void
process_help_input(ppbuf, plen)
char **ppbuf;
int *plen;
X{
X  int done = 0;
X
X  if (ppbuf == 0)
X    {
X      AbortHelp();
X      return;
X    }
X  while (!done && *plen > 0)
X    {
X      switch (**ppbuf)
X	{
X	case ' ':
X	  if (display_help() == 0)
X            break;
X	  /* FALLTHROUGH */
X	case '\r':
X	case '\n':
X	  done = 1;
X	  break;
X	default:
X	  if (**ppbuf == Esc)
X	    {
X	      done = 1;
X	      continue;
X	    }
X	  break;
X	}
X      ++*ppbuf;
X      --*plen;
X    }
X  if (done)
X    AbortHelp();
X}
X
static void
AbortHelp()
X{
X  help_page = 0;
X  ExitOverlayPage();
X  Activate();
X}
X
static int maxrow, grow, numcols, numrows, num_names;
static int numskip, numpages;
X
int
display_help()
X{
X  int col, crow, n, key = 0;
X  enum keytype typ = ktab[0].type;
X  char buf[256], Esc_buf[5], cbuf[256];
X
X  if (!help_page++)
X    {
X      if (screenwidth < 26 || screenheight < 6)
X        {
X	  Msg(0, "Window size too small for help page");
X	  help_page = 0;
X	  return -1;
X        }
X      InitOverlayPage(process_help_input, HelpRedisplayLine, 0, 0);
X
X      command_bindings = 0;
X      for (key = 0; key < 256; key++)
X        if ((typ = ktab[key].type) == KEY_CREATE
X	    || typ == KEY_SCREEN
X	    || typ == KEY_SET
X	    || (typ == KEY_AKA && ktab[key].args))
X	  command_bindings++;
X      debug1("help: command_bindings counted: %d\n",command_bindings);
X      for (n = 0; KeyNames[n] != NULL; n++)
X	; /* we dont know "sizeof * KeyNames" */
X      num_names = n - 1;
X      debug1("help: we find %d named keys (+1).\n", num_names);
X      command_search = 0;
X
X      numcols = screenwidth/26;
X      if (numcols == 0)
X        numcols = 1;
X      numrows = (num_names + numcols -1) / numcols;
X      debug1("Numrows: %d\n", numrows);
X      numskip = screenheight-5 - (2 + numrows);
X      while (numskip < 0)
X	numskip += screenheight-5;
X      numskip %= screenheight-5;
X      debug1("Numskip: %d\n", numskip);
X      if (numskip > screenheight/3 || numskip > command_bindings)
X	numskip = 1;
X      maxrow = 2 + numrows + numskip + command_bindings;
X      grow = 0;
X
X      numpages = (maxrow + screenheight-6) / (screenheight-5);
X    }
X
X  if (grow >= maxrow)
X    { 
X      return(-1);
X    }
X
X  /* Clear the help screen */
X  ClearDisplay();
X  
X  sprintf(cbuf,"Screen key bindings, page %d of %d.", help_page, numpages);
X  centerline(cbuf);
X  printf("\n");
X  crow = 2;
X
X  *Esc_buf = '\0';
X  add_key_to_buf(Esc_buf, Esc);
X  Esc_buf[strlen(Esc_buf) - 1] = '\0';
X
X  for (; crow < screenheight - 3; crow++)
X    {
X      if (grow < 1)
X        {
X   	  *buf = '\0';
X          add_key_to_buf(buf, MetaEsc);
X          buf[strlen(buf) - 1] = '\0';
X          sprintf(cbuf,"Command key:  %s   Literal %s:  %s", Esc_buf, Esc_buf, buf);
X          centerline(cbuf);
X	  grow++;
X        }
X      else if (grow >= 2 && grow-2 < numrows)
X	{
X	  for (col = 0; col < numcols && (n = numrows * col + (grow-2)) < num_names; col++)
X	    {
X	      debug1("help: searching key %d\n", n);
X	      buf[0] = '\0';
X	      for (key = 0; key < 128; key++)
X		if (ktab[key].type == (enum keytype) (n + 2)
X		    && ((enum keytype) (n + 2) != KEY_AKA || !ktab[key].args) )
X		  add_key_to_buf(buf, key);
X	      buf[14] = '\0';
X	      /*
X	       * Format is up to 10 chars of name, 1 spaces, 14 chars of key
X	       * bindings, and a space.
X	       */
X	      printf("%-10.10s %-14.14s ", KeyNames[n + 1], buf);
X	    }
X	  printf("\r\n");
X          grow++;
X        }
X      else if (grow-2-numrows >= numskip 
X               && grow-2-numrows-numskip < command_bindings)
X        {
X          char **pp, *cp;
X
X	  while (command_search < 128
X		 && (typ = ktab[command_search].type) != KEY_CREATE
X		 && typ != KEY_SCREEN
X		 && typ != KEY_SET
X		 && (typ != KEY_AKA || !ktab[command_search].args))
X	    command_search++;
X	  buf[0] = '\0';
X	  add_key_to_buf(buf, command_search);
X	  printf("%-4s", buf);
X	  col = 4;
X	  if (typ != KEY_CREATE)
X	    {
X	      col += strlen(KeyNames[(int)typ - 1]) + 1;
X	      printf("%s ", KeyNames[(int)typ - 1]);
X	    }
X	  pp = ktab[command_search++].args;
X	  while (pp && (cp = *pp) != NULL)
X	    {
X	      if (!*cp || (index(cp, ' ') != NULL))
X		{
X		  if (index(cp, '\'') != NULL)
X		    *buf = '"';
X		  else
X		    *buf = '\'';
X		  sprintf(buf + 1, "%s%c", cp, *buf);
X		  cp = buf;
X		}
X	      if ((col += (unsigned)strlen(cp) + 1) >= screenwidth)
X		{
X		  col = screenwidth - (col - (strlen(cp) + 1)) - 2;
X		  if (col >= 0)
X		    {
X		      n = cp[col];
X		      cp[col] = '\0';
X		      printf("%s$", *pp);
X		      cp[col] = (char) n;
X	  	    }
X	          break;
X	        }
X	      printf("%s%c", cp, (screenwidth - col != 1 || !pp[1]) ? ' ' : '$');
X	      pp++;
X	    }
X	  printf("\r\n");
X	  grow++;
X	}
X      else
X	{
X          putchar('\n');
X	  grow++;
X	}
X    }
X  printf("\n");
X  sprintf(cbuf,"[Press Space %s Return to end; %s to begin a command.]",
X	 grow < maxrow ? "for next page;" : "or", Esc_buf);
X  centerline(cbuf);
X  fflush(stdout);
X  SetLastPos(0, screenheight-1);
X  return(0);
X}
X
static void
add_key_to_buf(buf, key)
char *buf;
int key;
X{
X  debug1("help: key found: %c\n", key);
X  switch (key)
X    {
X    case ' ':
X      strcat(buf, "sp ");
X      break;
X    case 0x7f:
X      strcat(buf, "^? ");
X      break;
X    default:
X      if (key < ' ')
X	sprintf(buf + strlen(buf), "^%c ", (key | 0x40));
X      else
X	sprintf(buf + strlen(buf), "%c ", key);
X      break;
X    }
X}
X
static void
centerline(str)
char *str;
X{
X  int l;
X  l = (screenwidth - 1 + (unsigned)strlen(str)) / 2;
X  if (l > screenwidth - 1)
X    l = screenwidth - 1;
X  printf("%*.*s\r\n", l, l, str);
X}
X
static void
HelpRedisplayLine(y, xs, xe, isblank)
int y, xs, xe, isblank;
X{
X  if (isblank)
X    return;
X  if (CE)
X    {
X      GotoPos(xs, y);
X      PutStr(CE);
X      return;
X    }
X  DisplayLine(null, null, null, blank, null, null, y, xs, xe);
X}
X
X/*
X * here all the copyright stuff 
X */
X
X
static char version[40];
X
static char cpmsg[] = "\
X\n\
iScreen version %v\n\
X\n\
Copyright (c) 1991\n\
X    Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)\n\
X    Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)\n\
Copyright (c) 1987 Oliver Laumann\n\
X\n\
This program is free software; you can redistribute it and/or \
modify it under the terms of the GNU General Public License as published \
by the Free Software Foundation; either version 1, or (at your option) \
any later version.\n\
X\n\
This program is distributed in the hope that it will be useful, \
but WITHOUT ANY WARRANTY; without even the implied warranty of \
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \
GNU General Public License for more details.\n\
X\n\
You should have received a copy of the GNU General Public License \
along with this program (see the file COPYING); if not, write to the \
XFree Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n";
X
X
static void process_copyright_input __P((char **, int *));
static void AbortCopyright __P((void));
static void copypage __P((void));
X
static char *cps, *savedcps;
X
static void
process_copyright_input(ppbuf, plen)
char **ppbuf;
int *plen;
X{
X  int done = 0;
X
X  if (ppbuf == 0)
X    {
X      AbortCopyright();
X      return;
X    }
X  while (!done && *plen > 0)
X    {
X      switch (**ppbuf)
X	{
X	case ' ':
X          if (*cps)
X	    {
X	      copypage();
X	      break;
X	    }
X	  /* FALLTHROUGH */
X	case '\r':
X	case '\n':
X	  AbortCopyright();
X	  done = 1;
X	  break;
X	default:
X	  break;
X	}
X      ++*ppbuf;
X      --*plen;
X    }
X}
X
static void
AbortCopyright()
X{
X  ExitOverlayPage();
X  Activate();
X}
X
void
display_copyright()
X{
X  if (screenwidth < 10 || screenheight < 5)
X    {
X      Msg(0, "Window size too small for copyright page");
X      return;
X    }
X  InitOverlayPage(process_copyright_input, HelpRedisplayLine, 0, 0);
X  sprintf(version, "%d.%.2d.%.2d%s (%s) %s", REV, VERS, PATCHLEVEL, STATE, ORIGIN, DATE);
X  cps = cpmsg;
X  savedcps = 0;
X  copypage();
X}
X
X
static void
copypage()
X{
X  char *ws;
X  int x, y, l;
X  char cbuf[80];
X
X  ClearDisplay();
X  x = y = 0;
X  while(*cps)
X    {
X      ws = cps;
X      while (*cps == ' ')
X	cps++;
X      if (strncmp(cps, "%v", 2) == 0)
X	{
X	  savedcps = cps + 2;
X	  ws = cps = version;
X	}
X      while (*cps && *cps != ' ' && *cps != '\n')
X	cps++;
X      l = cps - ws;
X      cps = ws;
X      if (l > screenwidth - 1)
X	l = screenwidth - 1;
X      if (x && x + l >= screenwidth - 2)
X	{
X	  printf("\r\n");
X	  x = 0;
X	  if (++y > screenheight - 4)
X            break;
X	}
X      if (x)
X	{
X	  putchar(' ');
X	  x++;
X	}
X      printf("%*.*s", l, l, ws);
X      x += l;
X      cps += l;
X      if (*cps == 0 && savedcps)
X	{
X	  cps = savedcps;
X	  savedcps = 0;
X	}
X      if (*cps == '\n')
X	{
X	  printf("\r\n");
X	  x = 0;
X	  if (++y > screenheight - 4)
X            break;
X	}
X      if (*cps == ' ' || *cps == '\n')
X	cps++;
X    }
X  while (y++ < screenheight - 2)
X    printf("\r\n");
X  sprintf(cbuf,"[Press Space %s Return to end.]",
X	 *cps ? "for next page;" : "or");
X  centerline(cbuf);
X  fflush(stdout);
X  SetLastPos(0, screenheight-1);
X}
X  
END_OF_FILE
if test 12910 -ne `wc -c <'help.c'`; then
    echo shar: \"'help.c'\" unpacked with wrong size!
fi
# end of 'help.c'
fi
if test -f 'screen.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screen.h'\"
else
echo shar: Extracting \"'screen.h'\" \(10535 characters\)
sed "s/^X//" >'screen.h' <<'END_OF_FILE'
X/* Copyright (c) 1991
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * Noteworthy contributors to screen's design and implementation:
X *	Wayne Davison (davison@borland.com)
X *	Patrick Wolfe (pat@kai.com, kailand!pat)
X *	Bart Schaefer (schaefer@cse.ogi.edu)
X *	Nathan Glasser (nathan@brokaw.lcs.mit.edu)
X *	Larry W. Virden (lwv27%cas.BITNET@CUNYVM.CUNY.Edu)
X *	Howard Chu (hyc@hanauma.jpl.nasa.gov)
X *	Tim MacKenzie (tym@dibbler.cs.monash.edu.au)
X *	Markku Jarvinen (mta@{cc,cs,ee}.tut.fi)
X *	Marc Boucher (marc@CAM.ORG)
X *
X ****************************************************************
X * $Id: screen.h,v 1.49 91/10/11 10:24:11 jnweiger Exp $ FAU
X */
X
X/* screen.h now includes enough to satisfy its own references.
X * only config.h is still needed.
X */
X
X#include <stdio.h>
X#include <errno.h>
X#if defined(pyr)
extern int errno;
X#endif
X
X#ifdef sun
X# define getpgrp __getpgrp
X# define exit __exit
X#endif
X
X#ifdef POSIX
X#include <unistd.h>
X# if defined(__STDC__)
X#  include <stdlib.h>
X# endif
X#endif
X
X#ifdef sun
X# undef getpgrp
X# undef exit
X#endif
X
X#ifdef POSIX
X# include <termios.h>
X# ifdef hpux
X#  include <bsdtty.h>
X# endif
X#else
X# ifdef TERMIO
X#  include <termio.h>
X# else
X#  include <sgtty.h>
X# endif /* TERMIO */
X#endif /* POSIX */
X
X#ifdef SUIDROOT
X#  ifdef LOCKPTY
X#	 undef LOCKPTY
X#  endif
X#endif
X
X#ifndef UTMPOK
X#  ifdef USRLIMIT
X#	 undef USRLIMIT
X#  endif
X#endif
X
X#ifndef LOGINDEFAULT
X#  define LOGINDEFAULT 0
X#endif
X
X#if defined(LOADAV_3DOUBLES) || defined(LOADAV_3LONGS) || defined(LOADAV_4LONGS)
X#  define LOADAV
X#endif
X
X#ifndef FSCALE
X# ifdef MIPS
X#  define FSCALE 256            /* MIPS doesn't, and... */
X# else
X#  define FSCALE 1000.0 	/* Sequent doesn't define FSCALE...grrrr */
X# endif	
X#endif
X
X#ifndef F_OK
X#define F_OK 0
X#endif
X#ifndef X_OK
X#define X_OK 1
X#endif
X#ifndef W_OK
X#define W_OK 2
X#endif
X#ifndef R_OK
X#define R_OK 4
X#endif
X
X#ifndef MAXPATH
X# define MAXPATH 1024
X#endif
X
X#ifdef SIGVOID
X# if defined(ultrix)
X#  define sig_t void
X# else /* nice compilers: */
X   typedef void sig_t;
X# endif
X#else
X   typedef int sig_t;
X#endif
X
X#ifdef SVR4
X#define SIGPROTOARG   (int)
X#define SIGDEFARG     int sigsig
X#define SIGARG        0
X#else
X#define SIGPROTOARG   (void)
X#define SIGDEFARG
X#define SIGARG
X#endif
X
X#if (!defined(SYSV) && !defined(POSIX)) || defined(sysV68)
typedef int pid_t;
X#endif
X
X#if defined(M_XENIX)
typedef int pid_t;
typedef int gid_t;
typedef int uid_t;
X#endif
X
X#if defined(UTMPOK) && defined(_SEQUENT_)
X# define GETUTENT
X#endif
X
X#ifdef GETUTENT
X  typedef char *slot_t;
X#else
X  typedef int slot_t;
X#endif
X
X#if !defined(BSD) && !defined(sequent)
X# define index strchr
X# define rindex strrchr
X#endif
X
X#ifdef SYSV /* jw. */
X# define bzero(poi,len) memset(poi,0,len)
X# define killpg(pgrp,sig) kill( -(pgrp), sig)
X#endif
X
X/* here comes my own Free: jw. */
X#define Free(a) {if ((a) == 0) abort(); else free((void *)(a)); (a)=0;}
X
X#define Ctrl(c) ((c)&037)
X
X/* modes for markroutine 
X */
X#define PLAIN 0
X#define TRICKY 1
X
X/*typedef long off_t; */	/* Someone might need this */
X
enum state_t 
X{
X  LIT,				/* Literal input */
X  ESC,				/* Start of escape sequence */
X  ASTR,				/* Start of control string */
X  STRESC,			/* ESC seen in control string */
X  CSI,				/* Reading arguments in "CSI Pn ; Pn ; ... ; XXX" */
X  PRIN,				/* Printer mode */
X  PRINESC,			/* ESC seen in printer mode */
X  PRINCSI,			/* CSI seen in printer mode */
X  PRIN4			/* CSI 4 seen in printer mode */
X};
X
enum string_t 
X{
X  NONE,
X  DCS,				/* Device control string */
X  OSC,				/* Operating system command */
X  APC,				/* Application program command */
X  PM,				/* Privacy message */
X  AKA				/* a.k.a. for current screen */
X};
X
X#define MAXSTR		256
X#define MAXARGS 	64
X#define MSGWAIT 	5
X#define MSGMINWAIT 	1
X
X/* 
X * 4 <= IOSIZE <=1000
X * you may try to vary this value. Use low values if your (VMS) system
X * tends to choke when pasting. Use high values if you want to test
X * how many characters your pty's can buffer.
X */
X#define IOSIZE		80
X
X/*
X * if a nasty user really wants to try a history of 2000 lines on all 10
X * windows, he will allocate 5 MegaBytes of memory, which is quite enough.
X */
X#define MAXHISTHEIGHT 2000
X#define DEFAULTHISTHEIGHT 50
X
struct win 
X{
X  int wpid; /* process, that is connected to the other end of ptyfd */
X  int ptyfd; /* usually the master side of our pty pair */
X  int ttyflag; /* 1 if ptyfd is connected to a user specified tty. */
X  int aflag;
X  char outbuf[IOSIZE];
X  int outlen;
X  int autoaka, akapos;
X  char cmd[MAXSTR];
X  char tty[MAXSTR];
X  int args[MAXARGS];
X  int NumArgs;
X  slot_t slot;
X  char **image;
X  char **attr;
X  char **font;
X  int LocalCharset;
X  int charsets[4];
X  int ss;
X  int active;
X  int x, y;
X  char LocalAttr;
X  int saved;
X  int Saved_x, Saved_y;
X  char SavedLocalAttr;
X  int SavedLocalCharset;
X  int SavedCharsets[4];
X  int top, bot;
X  int wrap;
X  int origin;
X  int insert;
X  int keypad;
X  int width, height;	/* width AND height, as we have now resized wins. jw.*/
X  int histheight;       /* all histbases are malloced with width * histheight */
X  int histidx;          /* 0= < histidx < histheight; where we insert lines */
X  char **ihist; 	/* the history buffer  image */
X  char **ahist; 	/* attributes */
X  char **fhist; 	/* fonts */
X  enum state_t state;
X  enum string_t StringType;
X  char string[MAXSTR];
X  char *stringp;
X  char *tabs;
X  int vbwait;            
X  int bell;
X  int flow;
X  int autoflow;
X  int WinLink;
X  FILE *logfp;
X  int monitor;
X  int cursor_invisible;
X};
X
X#define D_DETACH	0
X#define D_STOP		1
X#define D_REMOTE	2
X#define D_POWER 	3
X#define D_REMOTE_POWER	4
X#define D_LOCK		5
X
X/*
X * Here are the messages the attacher sends to the backend
X */
X
X#define MSG_CREATE	0
X#define MSG_ERROR	1
X#define MSG_ATTACH	2
X#define MSG_CONT	3
X#define MSG_DETACH	4
X#define MSG_POW_DETACH	5
X#define MSG_WINCH	6
X#define MSG_HANGUP	7
X
struct msg
X{
X  int type;
X  union
X    {
X      struct
X	{
X	  int lflag;
X	  int aflag;
X	  int flowflag;
X	  int hheight;  /* size of scrollback buffer */
X	  int nargs;
X	  char line[MAXPATH];
X	  char dir[MAXPATH];
X	  char screenterm[20]; /* is screen really "screen" ? */
X	}
X      create;
X      struct
X	{
X	  int apid;
X	  int adaptflag; /* do we wish to adapt window size? */
X	  int lines, columns;
X	  char tty[MAXPATH];
X	  char password[20];
X	  char envterm[MAXPATH];
X	}
X      attach;
X      struct 
X	{
X	  char password[20];
X	  int dpid;
X	  char tty[MAXPATH];
X	}
X      detach;
X      char message[MAXPATH*2];
X    } m;
X};
X
X/*
X * And the signals the attacher receives from the backend
X */
X
X#define SIG_BYE		SIGHUP
X#define SIG_POWER_BYE	SIGUSR1
X#define SIG_LOCK	SIGUSR2
X#define SIG_STOP	SIGTSTP
X#define SIG_PW_OK	SIGUSR1
X#define SIG_PW_FAIL	SIG_BYE
X
X
struct mode
X{
X#ifdef TIOCSWINSZ
X  struct winsize ws;
X#endif
X#ifdef POSIX
X  struct termios tio;
X# ifdef hpux
X  struct ltchars m_ltchars;
X# endif
X#else
X# ifdef TERMIO
X  struct termio tio;
X# else
X  struct sgttyb m_ttyb;
X  struct tchars m_tchars;
X  struct ltchars m_ltchars;
X  int m_ldisc;
X  int m_lmode;
X# endif				/* TERMIO */
X#endif				/* POSIX */
X};
X
X#define BELL		7
X#define VBELLWAIT	1 /* No. of seconds a vbell will be displayed */
X
X#define BELL_OFF	0 /* No bell has occurred in the window */
X#define BELL_ON 	1 /* A bell has occurred, but user not yet notified */
X#define BELL_DONE	2 /* A bell has occured, user has been notified */
X#define BELL_VISUAL     3 /* A bell has occured in fore win, notify him visually */
X
X#define MON_OFF 	0 /* Monitoring is off in the window */
X#define MON_ON		1 /* No activity has occurred in the window */
X#define MON_FOUND	2 /* Activity has occured, but user not yet notified */
X#define MON_DONE	3 /* Activity has occured, user has been notified */
X
X#define DUMP_TERMCAP	0 /* WriteFile() options */
X#define DUMP_HARDCOPY	1
X#define DUMP_EXCHANGE	2
X
X#undef MAXWIN20
X
X#ifdef MAXWIN20
X#define MAXWIN	20
X#else
X#define MAXWIN	10
X#endif
X
X/* the key definitions are used in screen.c and help.c */
X/* keep this list synchronus with the names given in fileio.c */
enum keytype
X{
X  KEY_IGNORE, /* Keep these first 2 at the start */
X  KEY_SCREEN,
X  KEY_0,  KEY_1,  KEY_2,  KEY_3,  KEY_4,
X  KEY_5,  KEY_6,  KEY_7,  KEY_8,  KEY_9,
X#ifdef MAXWIN20
X  KEY_10, KEY_11, KEY_12, KEY_13, KEY_14,
X  KEY_15, KEY_16, KEY_17, KEY_18, KEY_19,
X#endif
X  KEY_AKA,
X  KEY_AUTOFLOW,
X  KEY_CLEAR,
X  KEY_COLON,
X  KEY_COPY,
X  KEY_DETACH,
X  KEY_FLOW,
X  KEY_HARDCOPY,
X  KEY_HELP,
X  KEY_HISTORY,
X  KEY_INFO,
X  KEY_KILL,
X  KEY_LASTMSG,
X  KEY_LICENSE,
X  KEY_LOCK,
X  KEY_LOGTOGGLE,
X  KEY_LOGIN,
X  KEY_MONITOR,
X  KEY_NEXT,
X  KEY_OTHER,
X  KEY_PASTE,
X  KEY_POW_DETACH,
X  KEY_PREV,
X  KEY_QUIT,
X  KEY_READ_BUFFER,
X  KEY_REDISPLAY,
X  KEY_REMOVE_BUFFERS,
X  KEY_RESET,
X  KEY_SET,
X  KEY_SHELL,
X  KEY_SUSPEND,
X  KEY_TERMCAP,
X  KEY_TIME,
X  KEY_VBELL,
X  KEY_VERSION,
X  KEY_WIDTH,
X  KEY_WINDOWS,
X  KEY_WRAP,
X  KEY_WRITE_BUFFER,
X  KEY_XOFF,
X  KEY_XON,
X  KEY_EXTEND,
X  KEY_X_WINDOWS,
X  KEY_BONUSWINDOW,
X  KEY_CREATE,
X};
X
struct key 
X{
X  enum keytype type;
X  char **args;
X};
X
X#ifdef NETHACK
X#	define Msg_nomem Msg(0, "You feel stupid.")
X#else
X#	define Msg_nomem Msg(0, "Out of memory.")
X#endif
X
X#ifdef DEBUG
X#	define debug(x) {fprintf(dfp,x);fflush(dfp);}
X#	define debug1(x,a) {fprintf(dfp,x,a);fflush(dfp);}
X#	define debug2(x,a,b) {fprintf(dfp,x,a,b);fflush(dfp);}
X#	define debug3(x,a,b,c) {fprintf(dfp,x,a,b,c);fflush(dfp);}
X	extern FILE *dfp;
X#else
X#	define debug(x) {}
X#	define debug1(x,a) {}
X#	define debug2(x,a,b) {}
X#	define debug3(x,a,b,c) {}
X#endif
X
X#if defined(__STDC__)
X# define __P(a) a
X#else
X# define __P(a) ()
X# define const
X#endif
X
X#ifdef hpux
X# define setreuid(ruid, euid) setresuid(ruid, euid, -1)
X# define setregid(rgid, egid) setresgid(rgid, egid, -1)
X#endif
X
X#if !defined(SYSV) || defined(sun) || defined(RENO) || defined(xelos)
X# define BSDWAIT
X#endif
END_OF_FILE
if test 10535 -ne `wc -c <'screen.h'`; then
    echo shar: \"'screen.h'\" unpacked with wrong size!
fi
# end of 'screen.h'
fi
if test -f 'window.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'window.c'\"
else
echo shar: Extracting \"'window.c'\" \(13890 characters\)
sed "s/^X//" >'window.c' <<'END_OF_FILE'
X/* Copyright (c) 1991
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * Noteworthy contributors to screen's design and implementation:
X *	Wayne Davison (davison@borland.com)
X *	Patrick Wolfe (pat@kai.com, kailand!pat)
X *	Bart Schaefer (schaefer@cse.ogi.edu)
X *	Nathan Glasser (nathan@brokaw.lcs.mit.edu)
X *	Larry W. Virden (lwv27%cas.BITNET@CUNYVM.CUNY.Edu)
X *	Howard Chu (hyc@hanauma.jpl.nasa.gov)
X *	Tim MacKenzie (tym@dibbler.cs.monash.edu.au)
X *	Markku Jarvinen (mta@{cc,cs,ee}.tut.fi)
X *	Marc Boucher (marc@CAM.ORG)
X *
X ****************************************************************
X */
X
X#ifndef lint
X  static char rcs_id[] = "$Id: window.c,v 1.22 91/10/08 15:11:00 mlschroe Exp $ FAU";
X#endif
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <signal.h>
X#ifndef sun
X#include <sys/ioctl.h>
X#endif
X
X#ifdef MIPS
extern int errno;
X#endif
X
X#include "config.h"
X#include "screen.h"
X#include "extern.h"
X
static void FreeScrollback __P((struct win *));
X
static int ResizeHistArray __P((struct win *, char ***, int, int, int));
static int ResizeScreenArray __P((struct win *, char ***, int, int, int));
static void FreeArray __P((char ***, int));
X
extern TermcapCOLS, TermcapROWS;
extern int maxwidth;
extern int default_width, default_height, screenwidth, screenheight;
extern char *blank, *null, *OldImage, *OldAttr;
extern char *OldFont, *LastMsg;
extern struct win *wtab[], *fore;
extern int WinList, ForeNum;
extern char *Z0, *Z1, *WS;
extern int Z0width, Z1width;
X
extern int Detached;
X
X#ifdef TIOCSWINSZ
X  struct winsize glwz;
X#endif
X
X/*
X * ChangeFlag:   0: try to modify no window
X *               1: modify fore (and try to modify no other)
X *               2: modify all windows
X *
X * Note: Activate() is only called if change_flag == 1
X *       i.e. on a WINCH event
X */
X
void
CheckScreenSize(change_flag)
int change_flag;
X{
X  int width, height, n;
X  struct win *p;
X
X  if (Detached)
X    {
X      debug("CheckScreenSize: Detached -> No check.\n");
X      return;
X    }
X#ifdef TIOCSWINSZ
X  if (ioctl(0, TIOCGWINSZ, &glwz) != 0)
X    {
X      debug1("CheckScreenSize: ioctl(0, TIOCGWINSZ) errno %d\n", errno);
X      width = TermcapCOLS;
X      height = TermcapROWS;
X    }
X  else
X    {
X      width = glwz.ws_col;
X      height = glwz.ws_row;
X      if (width == 0)
X        width = TermcapCOLS;
X      if (height == 0)
X        height = TermcapROWS;
X    }
X#else
X  width = TermcapCOLS;
X  height = TermcapROWS;
X#endif
X  
X  debug2("CheckScreenSize: screen is (%d,%d)\n", width, height);
X
X  if (change_flag == 2)
X    {
X      for (n = WinList; n != -1; n = p->WinLink)
X        {
X          p = wtab[n];
X          ChangeWindowSize(p, width, height);
X	}
X    }
X  if (screenwidth == width && screenheight == height)
X    {
X      debug("CheckScreenSize: No change -> return.\n");
X      return;
X    }
X  ChangeScreenSize(width, height, change_flag);
X  if (change_flag == 1 && WinList != -1)	/* was HasWindow */
X    Activate ();
X}
X
void
ChangeScreenSize(width, height, change_fore)
int width, height;
int change_fore;
X{
X  struct win *p;
X  int n, wwi;
X
X  if (screenwidth == width && screenheight == height)
X    {
X      debug("ChangeScreenSize: no change\n");
X      return;
X    }
X  debug3("ChangeScreenSize to (%d,%d) (change_fore: %d)\n",width, height, change_fore);
X  screenwidth = width;
X  screenheight = height;
X
X  if (WS)
X    {
X      default_width = TermcapCOLS;
X      default_height = TermcapROWS;
X    }
X  else
X    {
X      if (Z0 && (width == Z0width || width == Z1width) &&
X          (TermcapCOLS == Z0width || TermcapCOLS == Z1width))
X        default_width = TermcapCOLS;
X      else
X        default_width = width;
X      default_height = height;
X    }
X  debug2("Default size: (%d,%d)\n",default_width, default_height);
X  if (change_fore)
X    {
X      if (WinList != -1 && change_fore) /* was HasWindow */
X        {
X          debug("Trying to change fore.\n");
X          ChangeWindowSize(fore, width, height);
X        }
X    }
X  if (WS == NULL)
X    {
X      /* We have to adapt all windows */
X      for (n = WinList; n != -1; n = p->WinLink)
X        {
X          p = wtab[n];
X          debug1("Trying to change window %d.\n",n);
X          wwi = width;
X          if (Z0 && (width==Z0width || width==Z1width))
X	    {
X	      if (p->width > (Z0width + Z1width) / 2)
X		wwi = Z0width;
X	      else
X		wwi = Z1width;
X	    }
X          ChangeWindowSize(p, wwi, height);
X        }
X    }
X}
X
int
ChangeScrollback(p, histheight, histwidth)
struct win *p;
int histheight, histwidth;
X{
X  if (histheight > MAXHISTHEIGHT)
X    histheight = MAXHISTHEIGHT;
X  debug2("ChangeScrollback(..., %d, %d)\n", histheight, histwidth);
X  debug2("  was %d, %d\n", p->histheight, p->width);
X
X  if (histheight == 0)
X    {
X      FreeScrollback(p);
X      return 0;
X    }
X
X  if (ResizeHistArray(p, &p->ihist, histwidth, histheight, 1)
X      || ResizeHistArray(p, &p->ahist, histwidth, histheight, 0)
X      || ResizeHistArray(p, &p->fhist, histwidth, histheight, 0))
X    {
X      debug("   failed, removing all histbuf\n");
X      FreeScrollback(p);
X      Msg_nomem;
X      return (-1);
X    }
X  if (p->histheight != histheight)
X    p->histidx = 0;
X  p->histheight = histheight;
X
X  return(0);
X}
X
static void FreeScrollback(p)
struct win *p;
X{
X  FreeArray(&p->ihist, p->histheight);
X  FreeArray(&p->ahist, p->histheight);
X  FreeArray(&p->fhist, p->histheight);
X  p->histheight = 0;
X}
X
static int
ResizeHistArray(p, arr, wi, hi, fillblank)
struct win *p;
char ***arr;
int wi, hi, fillblank;
X{
X  char **narr, **np, **onp, **onpe;
X  int t, x, first;
X
X  if (p->width == wi && p->histheight == hi)
X    return(0);
X  if (p->histheight != hi)
X    {
X      if ((narr = (char **)calloc(sizeof(char *), hi)) == NULL)
X	{
X	  FreeArray(arr, p->histheight);
X	  return(-1);
X	}
X      np = narr;
X      onp = (*arr) + p->histidx;
X      onpe = (*arr) + p->histheight;
X      first = p->histheight - hi;
X      if (first<0)
X	 np-=first;
X      for(t=0; t<p->histheight; t++)
X	{
X          if (t-first >=0 && t-first < hi)
X	    *np++ = *onp;
X	  else
X	    Free(*onp);
X	  if (++onp == onpe)
X	    onp = *arr;
X	}
X      if (*arr)
X	Free(*arr);
X    }
X  else
X    narr = *arr;
X 
X  for (t=0, np=narr; t<hi; t++, np++)
X    {
X      x = p->width;
X      if (*np == 0)
X	{
X	  *np = (char *)malloc(wi);
X          x = 0;
X	}
X      else if (p->width != wi)
X	{
X	  *np = (char *)xrealloc(*np, wi);
X	}
X      if (*np == 0)
X	{
X	  FreeArray(&narr, hi);
X	  return(-1);
X	}
X      if (x<wi)
X	{
X	  if (fillblank)
X	    bclear(*np+x, wi-x);
X	  else
X	    bzero(*np+x, wi-x);
X	}
X    }
X  *arr = narr;
X  return(0);
X}
X      
X
static int
ResizeScreenArray(p, arr, wi, hi, fillblank)
struct win *p;
char ***arr;
int wi, hi, fillblank;
X{
X  int minr;
X  char **cp;
X
X  if (p->width == wi && p->height == hi)
X    return(0);
X
X  if (hi > p->height)
X    minr = p->height;
X  else
X    minr = hi;
X
X  if (p->height > hi)
X    {
X      for (cp = *arr; cp < *arr + (p->height - hi); cp++)
X	Free(*cp);
X      bcopy((char *)(*arr + (p->height - hi)), (char *)(*arr),
X	    hi * sizeof(char *));
X    }
X  if (*arr && p->width != wi)
X    for (cp = *arr; cp < *arr + minr; cp++)
X      {
X	if ((*cp = (char *)xrealloc(*cp, (unsigned) wi)) == 0)
X	  {
X	    FreeArray(arr, p->height);
X	    return(-1);
X	  }
X	if (wi > p->width)
X	  {
X	    if (fillblank)
X	      bclear(*cp + p->width, wi - p->width);
X	    else
X	      bzero(*cp + p->width, wi - p->width);
X	  }
X      }
X  if (*arr)
X    *arr = (char **) xrealloc((char *) *arr, (unsigned) hi * sizeof(char *));
X  else
X    *arr = (char **) malloc((unsigned) hi * sizeof(char *));
X  if (*arr == 0)
X    return(-1);
X  for (cp = *arr + p->height; cp < *arr + hi; cp++)
X    {
X      if ((*cp = malloc((unsigned) wi)) == 0)
X	{
X	  while (--cp >= *arr)
X	    Free(*cp);
X	  Free(*arr);
X          return(-1);
X	}
X      if (fillblank)
X	bclear(*cp, wi);
X      else
X	bzero(*cp, wi);
X    }
X  return(0);
X}
X
static void
XFreeArray(arr, hi)
char ***arr;
int hi;
X{
X  register char **p;
X  register int t;
X
X  if (*arr == 0)
X    return;
X  for (t = hi, p = *arr; t--; p++)
X    if (*p)
X      Free(*p);
X  Free(*arr);
X}
X
X
int
ChangeWindowSize(p, width, height)
struct win *p;
int width, height;
X{
X  int t, scr;
X  
X  if (width > maxwidth)
X    {
X      maxwidth = width;
X      debug1("New maxwidth: %d\n", maxwidth);
X      if (blank == 0)
X        blank = malloc((unsigned) maxwidth);
X      else
X        blank = xrealloc(blank, (unsigned) maxwidth);
X      if (null == 0)
X        null = malloc((unsigned) maxwidth);
X      else
X        null = xrealloc(null, (unsigned) maxwidth);
X      if (OldImage == 0)
X        OldImage = malloc((unsigned) maxwidth);
X      else
X        OldImage = xrealloc(OldImage, (unsigned) maxwidth);
X      if (OldAttr == 0)
X        OldAttr = malloc((unsigned) maxwidth);
X      else
X        OldAttr = xrealloc(OldAttr, (unsigned) maxwidth);
X      if (OldFont == 0)
X        OldFont = malloc((unsigned) maxwidth);
X      else
X        OldFont = xrealloc(OldFont, (unsigned) maxwidth);
X      if (LastMsg == 0)
X        {
X          LastMsg = malloc((unsigned) maxwidth + 1);
X          *LastMsg = 0;
X        }
X      else
X        LastMsg = xrealloc(LastMsg, (unsigned) maxwidth + 1);
X      LastMsg[maxwidth]=0;
X      if (!(blank && null && OldImage && OldAttr && OldFont && LastMsg))
X	{
nomem:	  for (t = WinList; t != -1 && wtab[t] != p; t = p->WinLink) 
X	    ;
X	  if (t >= 0)
X	    KillWindow(t);
X	  Msg(0, "Out of memory -> Window destroyed !!");
X	  return(-1);
X	}
X      MakeBlankLine(blank, maxwidth);
X      bzero(null, maxwidth);
X    }
X  
X  if (width == p->width && height == p->height)
X    {
X      debug("ChangeWindowSize: No change.\n");
X      return(0);
X    }
X
X  debug2("ChangeWindowSize from (%d,%d) to ", p->width, p->height);
X  debug2("(%d,%d)\n", width, height);
X
X  if (width == 0 && height == 0)
X    {
X      FreeArray(&p->image, p->height);
X      FreeArray(&p->attr, p->height);
X      FreeArray(&p->font, p->height);
X      if (p->tabs)
X	Free(p->tabs);
X      p->width = 0;
X      p->height = 0;
X      FreeScrollback(p);
X      return(0);
X    }
X
X  /* when window gets smaller, scr is the no. of lines we scroll up */
X  scr = p->height - height;
X  if (scr < 0)
X    scr = 0;
X  for (t = 0; t < scr; t++)
X    AddLineToHist(p, p->image+t, p->attr+t, p->font+t); 
X  if (ResizeScreenArray(p, &p->image, width, height, 1)
X      || ResizeScreenArray(p, &p->attr, width, height, 0)
X      || ResizeScreenArray(p, &p->font, width, height, 0))
X    {
X      goto nomem;
X    }
X  /* this won't change the height of the scrollback history buffer, but
X   * it will check the width of the lines.
X   */
X  ChangeScrollback(p, p->histheight, width);
X
X  if (p->tabs == 0)
X    {
X      /* tabs get width+1 because 0 <= x <= width */
X      if ((p->tabs = malloc((unsigned) width + 1)) == 0)
X        goto nomem;
X      t = 8;
X    }
X  else
X    {
X      if ((p->tabs = xrealloc(p->tabs, (unsigned) width + 1)) == 0)
X        goto nomem;
X      t = p->width;
X    }
X  for (t = (t + 7) & 8; t < width; t += 8)
X    p->tabs[t] = 1; 
X  p->height = height;
X  p->width = width;
X  if (p->x >= width)
X    p->x = width - 1;
X  if ((p->y -= scr) < 0)
X    p->y = 0;
X  if (p->Saved_x >= width)
X    p->Saved_x = width - 1;
X  if ((p->Saved_y -= scr) < 0)
X    p->Saved_y = 0;
X  if (p->autoaka > 0) 
X    if ((p->autoaka -= scr) < 1)
X      p->autoaka = 1;
X  p->top = 0;
X  p->bot = height - 1;
X#ifdef TIOCSWINSZ
X  if (p->ptyfd && p->wpid)
X    {
X      glwz.ws_col = width;
X      glwz.ws_row = height;
X      debug("Setting pty winsize.\n");
X      if (ioctl(p->ptyfd, TIOCSWINSZ, &glwz))
X	debug2("SetPtySize: errno %d (fd:%d)\n", errno, p->ptyfd);
X# if defined(STUPIDTIOCSWINSZ) && defined(SIGWINCH)
X#  ifdef POSIX
X      pgrp = tcgetpgrp(p->ptyfd);
X#  else
X      if (ioctl(p->ptyfd, TIOCGPGRP, &pgrp))
X	pgrp = 0;
X#  endif
X      if (pgrp)
X	{
X	  debug1("Sending SIGWINCH to pgrp %d.\n", pgrp);
X	  if (killpg(pgrp, SIGWINCH))
X	    debug1("killpg: errno %d\n", errno);
X	}
X      else
X	debug1("Could not get pgrp: errno %d\n", errno);
X# endif /* STUPIDTIOCSWINSZ */
X    }
X#endif
X  return(0);
X}
X
X
void
ResizeScreen(wi)
struct win *wi;
X{
X  int width, height;
X
X  if (wi)
X    {
X      width = wi->width;
X      height = wi->height;
X    }
X  else
X    {
X      width = default_width;
X      height = default_height;
X    }
X  if (screenwidth == width && screenheight == height)
X    {
X      debug("ResizeScreen: No change\n");
X      return;
X    }
X  debug2("ResizeScreen: to (%d,%d).\n", width, height);
X  if (WS)
X    {
X      debug("ResizeScreen: using WS\n");
X      WSresize(width, height);
X      ChangeScreenSize(width, height, 0);
X    }
X  else if (Z0 && (width == Z0width || width == Z1width))
X    {
X      debug("ResizeScreen: using Z0/Z1\n");
X      PutStr(width == Z0width ? Z0 : Z1);
X      ChangeScreenSize(width, screenheight, 0);
X    }
X  if (screenwidth != width || screenheight != height)
X    {
X      debug2("BUG: Cannot resize from (%d,%d)",screenwidth, screenheight);
X      debug2(" to (%d,%d) !!\n", width, height);
X      if (wi)
X	ChangeWindowSize(wi, screenwidth, screenheight);
X    }
X}
X
char *
xrealloc(mem, len)
char *mem;
int len;
X{
X  register char *nmem;
X
X  if (nmem = realloc(mem, len))
X    return(nmem);
X  free(mem);
X  return((char *)0);
X}
END_OF_FILE
if test 13890 -ne `wc -c <'window.c'`; then
    echo shar: \"'window.c'\" unpacked with wrong size!
fi
# end of 'window.c'
fi
echo shar: End of archive 3 \(of 8\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
