Newsgroups: comp.sources.unix
From: jnweiger@immd4.informatik.uni-erlangen.de (Juergen Weigert)
Subject: v25i046: Screen3 - multiple windows on an ASCII terminal, Part06/08
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: jnweiger@immd4.informatik.uni-erlangen.de (Juergen Weigert)
Posting-Number: Volume 25, Issue 46
Archive-Name: screen3/part06

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 8)."
# Contents:  screen.1
# Wrapped by vixie@cognition.pa.dec.com on Thu Dec 19 17:36:06 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'screen.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screen.1'\"
else
echo shar: Extracting \"'screen.1'\" \(61578 characters\)
sed "s/^X//" >'screen.1' <<'END_OF_FILE'
X.if n .ds Q \&"
X.if n .ds U \&"
X.if t .ds Q ``
X.if t .ds U ''
X.TH SCREEN 1 "28 August 1991"
X.UC 4
X.SH NAME
screen \- screen manager with VT100/ANSI terminal emulation
X.SH SYNOPSIS
X.B screen
X[
X.B -\fIoptions\fP
X] [
X.B \fIcmd\fP
X[
X.B \fIargs\fP
X] ]
X.br
X.B screen \-r
X[
X.BR \fIhost.tty\fP
X]
X.ta .5i 1.8i
X.SH DESCRIPTION
X.I Screen
is a full-screen window manager that
multiplexes a physical terminal between several processes (typically
interactive shells).
XEach virtual terminal provides the functions
of the DEC VT100 terminal and, in addition, several control functions
from the ANSI X3.64 (ISO 6429) and ISO 2022 standards
X(e.\|g. insert/delete line and support for multiple character sets).
There is a scrollback history buffer for each virtual terminal and a 
copy-and-paste mechanism that allows moving text regions between
windows.
X.PP
When
X.I screen
is called, it creates a single window with a shell in it (or the specified
command) and then gets out of your way so that you can use the program as you
normally would.
Then, at any time, you can create new (full-screen) windows with other programs
in them (including more shells), kill existing windows, view a list of the
current windows, turn output logging on and off, copy-and-paste text between
windows, view the scrollback history, switch between windows
in whatever manner you wish, etc.
When a program terminates,
X.I screen
kills the window that contained it.
If this window was in the foreground, the display switches to the previous
window; if none are left,
X.I screen
exits.
X.PP
XEverything you type is sent to the program running in the current window.
The only exception to this is the one keystroke that is used to initiate
a command to the window manager.
By default, each command begins with a control-a (abbreviated C-a from
now on), and is followed by one other keystroke.
The command character and all the key bindings can be fully customized
to be anything you like, though they are always two characters in length.
X.PP
The standard way to create a new window is to type \*QC-a c\*U.
This creates a new window running a shell and switches to that
window immediately, regardless of the state of the process running
in the current window.
Similarly, you can create a new window with a custom command in it by
first binding the command to a keystroke (in your .screenrc file) and
then using it just like the \*QC-a c\*U command.
In addition, new windows can be created by running a command like:
X.IP
screen emacs prog.c
X.PP
from a shell prompt within a previously created window.
This will not run another copy of 
X.IR screen ,
but will instead supply the
command name and its arguments to the window manager who will use it to
create the new window.
The above example would start the emacs editor (editing prog.c) and switch
to its window.
X.PP
If \*Q/etc/utmp\*U is writable by
X.IR screen ,
an appropriate record will be written to this file for each window, and
removed when the window is terminated.
This is useful for working with \*Qtalk\*U, \*Qscript\*U, \*Qshutdown\*U,
X\*Qrsend\*U, \*Qsccs\*U and other similar programs that use the utmp
file to determine who you are. As long as 
X.I screen
is active on your terminal,
the terminals own record is removed from the utmp file. See also \*QC-a L\*U.
X.SH GETTING STARTED
Before you begin to use
X.I screen
you'll need to make sure you have correctly selected your terminal type,
just as you would for any other termcap/terminfo program.
X(You can do this by using
X.IR tset
or
X.IR stty , 
for example.)
X.PP
If you're impatient and want to get started without doing a lot more reading,
you should remember this one command:  \*QC-a ?\*U.
Typing these two characters will display a list of the available
X.I screen
commands and their bindings. Each keystroke is discussed in
the section \*QCOMMAND KEYS\*U. The manual section \*QCUSTOMIZATION\*U 
deals with the contents of your .screenrc.
X.PP
If possible, choose a version of your terminal's termcap that has automatic
margins turned \fIoff\fP.
This will ensure an accurate and optimal update of the screen
in all circumstances.
The next best thing is an auto-margin terminal that allows the last position
on the screen to be updated without scrolling the screen (such as a vt100).
This also allows the entire screen to be updated.
Lastly, if all you've got is a \*Qtrue\*U auto-margin terminal
X.I screen
will be content to use it, but updating a character put into the last position
on the screen may not be possible until the screen scrolls or the character
is moved into a safe position in some other way.
This delay can be shortened by using a terminal with insert-character
capability.
X.PP
If your terminal is of the second type (firm-margined `am'), you will
want to let
X.I screen
know about this, since a normal termcap doesn't distinguish this type of
automatic margins from a \*Qtrue\*U `am' terminal.
You do this by specifying the `LP' capability in your termcap
X(see the \*Qtermcap\*U .screenrc command), or by using the
X.B \-L
command-line option.
X.I Screen
needs this information to correctly update the screen.
X.PP
If you are using a \*Qtrue\*U auto-margin terminal (no `LP') at low baud
rates, you may want to turn on a more optimal output mode by including the
flag `OP' in your termcap entry, or by specifying the
X.B \-O
command-line option.
The trade-off is that
X.I screen
will no-longer accurately emulate the vt100's line-end quirks (e.\|g. the
screen will scroll after putting \fIone\fP character in the last screen
position).
X.SH "COMMAND KEYS"
As mentioned, each
X.I screen
command consists of a
X\*QC-a\*U followed by one other character.
XFor your convenience, all commands that are bound to lower-case letters are
also bound to their control character counterparts (with the exception
of \*QC-a a\*U; see below), thus, \*QC-a c\*U as well as \*QC-a C-c\*U can
be used to create a window.
X.PP
The following keystroke commands are available:
X.IP "\fBC-a 0\fP  -  \fBC-a 9\fP   (select0 - select9)"
Switch to the window with the number 0 through 9.
When a new window is established, the first available number from the
range 0..9 is assigned to this window.
Thus, the first window can be activated by \*QC-a 0\*U (there can be no more
than 10 windows present at any one time).
X.IP "\fBC-a C-a\fP   (other)"
Switch to the window displayed previously.
Note that this function defaults to the command character typed twice,
unless overridden; for instance, if you use the option \*Q\fB\-e]x\fP\*U,
this function becomes \*Q]]\*U, not \*Q]C-a\*U.
X.IP "\fBC-a a\fP\0\0\0\0\0"
Send the command character (C-a) to the processes in the current window.
X.IP "\fBC-a A\fP   (aka)"
Allow the user to enter an a.\|k.\|a (also-known-as). for the current window.
X.IP "\fBC-a c\fP  or  \fBC-a C-c\fP   (shell)"
Create a new window with a shell and switch to that window.
X.IP "\fBC-a C\fP   (clear)"
Clear the screen.
X.IP "\fBC-a d\fP  or  \fBC-a C-d\fP   (detach)"
Detach
X.I screen
X(disconnect it from the terminal and put it into the background).
A detached
X.I screen
can be resumed by invoking
X.I screen
with the
X.B \-r
option. (See also section \*QCOMMAND-LINE OPTIONS\*U.)
X.IP "\fBC-a D D\fP   (pow_detach)"
Power detach. Mainly the same as above, but also sends a HANGUP signal to
the parent process of
X.IR screen .
CAUTION: This will result in a logout, when 
X.I screen
was started from your login shell.
X.IP "\fBC-a f\fP  or  \fBC-a C-f\fP   (flow)"
Toggle the current window's flow-control setting.
X.IP "\fBC-a C-g\fP   (vbell)"
Toggles 
X.I screen's visual bell mode. If your terminal does not support
a visual bell, a `vbell-message' is displayed in the status line. 
X.IP "\fBC-a h\fP  or  \fBC-a C-h\fP   (hardcopy)"
Write a hardcopy of the current window to the file \*Qhardcopy.\fIn\fP\*U
in the window's default directory, where \fIn\fP is the number
of the current window. 
X.IP "\fBC-a H\fP   (log)"
Begins/ends logging of the current window to the file \*Qscreenlog.\fIn\fP\*U
in the window's default directory, where \fIn\fP is the number
of the current window.
The session log is appended to the previous contents of the file
if it already exists. 
The current contents and the contents of the scrollback history are not
included in the session log.
X.IP "\fBC-a i\fP  or  \fBC-a C-i\fP   (info)"
Uses the message line to display some information about the current window:
the cursor position in the form \*Q(column,row)\*U starting with \*Q(1,1)\*U,
the terminal width and height plus the size of the scrollback buffer in lines, 
like in \*U(80,24)+50\*U, various flag settings (flow-control, insert mode,
origin
mode, wrap mode, application-keypad mode, output logging, and activity
monitoring (`+' indicates enabled, `-' not)),
the currently active character set (\fIG0\fP, \fIG1\fP, \fIG2\fP,
or \fIG3\fP), and in square brackets the the terminal character sets that are
currently designated as \fIG0\fP through \fIG3\fP.
XFor system information use \*QC-a t\*U.
X.IP "\fBC-a k\fP  or  \fBC-a C-k\fP   (kill)"
Kill the current window and switch to the previously displayed window.
Note:
X.I Emacs
users should keep this command in mind, when killing a line.
It is recommended not to use \*QC-a\*U as the
X.I screen
escape key or that kill is rebinded to \*QC-a K\*U.
X.IP "\fBC-a l\fP  or  \fBC-a C-l\fP   (redisplay)"
Redisplay the current window.
X.IP "\fBC-a L\fP   (login)"
Adds or removes the entry in /etc/utmp file for the current window.
This controls if the window is `logged in'. See also above.
Additionally to that toggle, it is convenient having a `log in' and a `log out'
key. E.\|g. `bind I set login on' and `bind O set login off' will map these
keys to be C-a I and C-a O.
X.IP "\fBC-a m\fP  or  \fBC-a C-m\fP   (lastmsg)"
Repeat the last message displayed in the message line.
Useful if you're typing when a message appears, because (unless your terminal
has a status line) the message goes away when you press a key.
X.IP "\fBC-a M\fP   (monitor)"
Toggles monitoring of the current window.
When monitoring is turned on and the affected window is switched into the
background, you will receive the activity notification message in the
status line at the first sign of output and the window will also be marked
with an `@' in the window-status display.
Monitoring is initially off for all windows.
X.IP "\fBC-a space\fP  or  \fBC-a n\fP  or  \fBC-a C-n\fP   (next)"
Switch to the next window.
This function can be used repeatedly to cycle through the list of windows.
X(Some terminals require you to release the control key before pressing space.)
X.IP "\fBC-a p\fP  or  \fBC-a C-p\fP   (prev)"
Switch to the previous window (the opposite of \fBC-a n\fP).
X.IP "\fBC-a q\fP  or  \fBC-a C-q\fP   (xon)"
Send a control-q to the program in the current window.
X.IP "\fBC-a r\fP  or  \fBC-a C-r\fP   (wrap)"
Toggle the current window's line-wrap setting (turn the current window's
automatic margins on and off).
X.IP "\fBC-a s\fP  or  \fBC-a C-s\fP   (xoff)"
Send a control-s to the program in the current window.
X.IP "\fBC-a t\fP  or  \fBC-a C-t\fP   (time)"
Uses the message line to display the time of day, the host name, and the load
averages over 1, 5, and 15 minutes (if this is available on your system).
XFor window specific information use \*QC-a i\*U.
X.IP "\fBC-a v\fP  or  \fBC-a C-v\fP   (version)"
Display the version and compilation date.
X.IP "\fBC-a w\fP  or  \fBC-a C-w\fP   (windows)"
Uses the message line to display a list of all the windows.
XEach window is listed by number with the name of process that has been
started in the window (or its a.\|k.\|a.);
the current window is marked with a `*';
the previous window is marked with a `-';
all the windows that are \*Qlogged in\*U are marked with a `$';
a background window that has received a bell is marked with a `!';
a background window that is being monitored and has had activity occur
is marked with an `@';
a window which has output logging turned on is marked with `(L)'.
X.IP "\fBC-a W\fP   (width)"
Toggle the window width between 80 and 132 columns. As this command became
a toggle, \*QC-a N\*U is no longer supported.
This requires a capable terminal and the termcap entries \*QZ0\*U and \*QZ1\*U.
See the \*Qtermcap\*U command in section \*QCUSTOMIZATION\*U 
for more information.
X.IP "\fBC-a x\fP  or  \fBC-a C-x\fP   (lock)"
Call a screenlock program (/local/bin/lck or /usr/bin/lock or a builtin, if no
other is available). Screen does not accept any command keys until this program
terminates. Meanwhile processes in the windows may continue, as the windows 
are in the `detached' state. The screenlock program may be changed through the
environment variable $LOCKPRG (which must be set in the shell from which 
X.I screen
is started) and is executed with the user's uid and gid.
X.IP "\fBC-a z\fP  or  \fBC-a C-z\fP   (suspend)"
Suspend
X.IR screen .
The windows are in the `detached' state, while 
X.IR screen
is suspended.
X.IP "\fBC-a Z\fP   (reset)"
Reset the virtual terminal to its \*Qpower-on\*U values.
X.IP "\fBC-a .\fP   (termcap)"
Write the termcap entry for the virtual terminal of the currently active
window to the file \*Q.termcap\*U in the user's \*Q$HOME/.screen\*U directory
X(or wherever 
X.I screen
stores it's sockets. See the \*QFILES\*U section below).
This termcap entry is identical to the value of the environment variable
X$TERMCAP that is set up by
X.I screen
for each window. For terminfo based systems you will need to run a converter
like 
X.IR captoinfo
and then compile the entry with 
X.IR tic .
X.IP "\fBC-a /\fP   (autoflow)"
Toggle the current window's autoflow setting between manual and auto.
Autoflow mode assumes that when a program turns on the application keypad
that you want flow-control temporarily turned off (though it is still
possible to toggle flow-control manually).
X.IP "\fBC-a ?\fP   (help)"
Displays a help screen showing you all the key bindings.
The first pages list all the internal commands followed by their bindings.
Subsequent pages will display the custom commands, one command per key.
Press space when you're done reading each page, or return to exit early.
All other characters are ignored, except for the command character, which will
exit the help display and begin a command.
X.IP "\fBC-a C-\e\fP   (quit)"
Kill all windows and terminate
X.IR screen .
Note that on vt100-style terminals the keys C-4 and C-\e are identical.
So be careful not to write C-a C-4 when selecting window no. 4.
Use the empty bind command (as in \*Qbind '^\'\*U) to remove a key binding.
X.IP "\fBC-a :\fP   (colon)"
Allows you to enter \*Q.screenrc\*U command lines as well as names of 
key-bound-functions. Useful for on-the-fly modification of key bindings, 
specific window creation and changing settings. Settings of the current window
can be changed by prepending the command (if appropriate) with the keyword
X\*Qset\*U.  If you consider this as the `Ex command mode' of 
X.IR screen ,
you may regard \*QC-a esc\*U as it's `Vi command mode'.
X.IP "\fBC-a [\fP  or  \fBC-a C-[\fP  or  \fBC-a esc\fP   (copy)"
XEnter copy/scrollback mode. This allows you to copy text from the current
window and it's history into the paste buffer. In this mode a vi-like
X`full screen editor' is active:
X.br
X.IR "Movement keys" :
X.br
X\fBh\fP, \fBj\fP, \fBk\fP, \fBl\fP move the cursor line by line or column by column.
X.br
X\fB0\fP, \fB^\fP and \fB$\fP move to the leftmost column, to the first or last
non-whitespace
character on the line.
X.br
X\fBH\fP, \fBM\fP and \fBL\fP move the cursor to the leftmost column
of the top, center or bottom line of the window. 
X.br
X\fB+\fP and \fB-\fP positions one line up and down.
X.br
X\fBG\fP moves to the specified absolute line (default: end of buffer).
X.br 
X\fB|\fP moves to the specified absolute column.
X.br
X\fBw\fP, \fBb\fP, \fBe\fP move the cursor word by word.
X.br 
X\fBC-u\fP and \fBC-d\fP scroll the display up/down by the specified amount of 
lines while preserving the cursor position. (Default: half screenfull). 
X.br
X\fBC-b\fP and \fBC-f\fP scroll the display up/down a full screen.
X.br
X\fBg\fP moves to the beginning of the buffer, whereas
X.br
X\fB%\fP jumps to the specified percentage.
X.br
X.IR Note :
XEmacs style movement keys can be customized by a .screenrc command. (E.\|g.
markkeys "h=^B:l=^F:$=^E") There is no simple method for a full emacs-style
keymap, as this involves multicharacter codes.
X.IR Marking :
X.br
The copy range is specified by setting two marks. The text between these marks 
will be highlighted. Press \fBspace\fP to set the first or second mark
respectively.
X.br
X\fBY\fP and \fBy\fP can be used to mark one whole line or to mark from 
start of line.
X.br
X\fBW\fP marks exactly one word. 
X.br 
X.IR "Repeat count" :
X.br
Any of these commands can be prefixed with a number (by pressing digits 
X\fB0\fP..\fB9\fP) which
is taken as a repeat count. Example: \*QC-a C-[ H 10 j 5 Y\*U will copy lines
X11 to 15 into the pastebuffer.
X.br
X.IR Specials :
X.br
There are however some keys that act differently here and in
X.IR vi .
X.I Vi
does not allow to yank rectangular blocks of text, but
X.I screen
does. Press 
X.br
X\fBc\fP or \fBC\fP to set the left or right margin respectively. If no repeat count is
given, both default to the current cursor position. Try this on a rather 
full text screen as an example: 'C-A [ S-M 20 l SPACE c 10 l 5 j S-C SPACE'.
X.br
X\fBJ\fP joins lines. It toggles between 
X3 modes: lines separated by a newline character (012), lines glued seamless,
lines separated by a single whitespace. Note that you can prepend the newline
character with a carriage return character, by issuing a \*Qset crlf on\*U.
X.br
X\fBv\fP is for all the
X.I vi 
users with \*Q:set numbers\*U - it toggles the left margin between column 9
and 1.
X.br
Press \fBa\fP before the final space key to toggle in append mode. Thus
the contents of the pastebuffer will not be overwritten, but appended to.
X.br
X\fBA\fP toggles in append mode and sets a (second) mark.
X.br
X\fB>\fP sets the (second) mark and writes the contents of the copybuffer to
the file /tmp/screen-exchange once copy-mode is finished. This example
demonstrates how to dump the whole scrollback buffer to file: 'C-A
X[ g SPACE G $ >'
X.br
X\fB?\fP gives information about the current line and column.
X.IP "\fBC-a ]\fP  or  \fBC-a C-]\fP   (paste)"
Paste. Write the contents of the paste buffer to the stdin queue of the
current window.
X.IP "\fBC-a {\fP   (history)"
Usually users work with a shell that allows easy access to previous commands.
XE.g. csh has the command \*Q!!\*U to repeat the last command executed. 
X.I Screen
allows you to have a primitive way of re-calling \*Qthe command that
started ...\*U: You just type the first letter of that command, then hit
X`C-a {' and
X.I screen
tries to find a previous line that matches with the `prompt character' 
to the left of the cursor. This line is pasted into this window's input queue.
Thus you have a crude command history (made up by the visible window and it's
scrollback buffer). 
X.IP "\fBC-a >\fP   (write_buffer)"
Writes the contents of the paste buffer to a public accessible screen-exchange
file. This is thought of as a primitive means of communication between
X.I screen
users on the same host. See also \*QC-a esc\*U.
X.IP "\fBC-a <\fP   (read_buffer)"
Reads the screen-exchange file into the pastebuffer. See also \*QC-a ]\*U.
X.IP "\fBC-a =\fP   (kill_buffer)"
Removes the exchange file used by \*QC-a <\*U and \*QC-a >\*U.
X.SH "COMMAND-LINE OPTIONS"
Screen has the following command-line options:
X.TP 5
X.B \-a
include \fIall\fP capabilities (with some minor exceptions) in each
window's termcap, even if
X.I screen
must redraw parts of the display in order to implement a function.
X.TP 5
X.B "\-c \fIfile\fP"
override the default configuration file from \*Q$HOME/.screenrc\*U
to \fIfile\fP.
X.TP 5
X.B "\-d\fP|\fB\-D \fP[\fIhost.tty\fP\]\fB"
does not start
X.IR screen ,
but detach the elsewhere running 
X.I screen
session. It has the same effect as typing \*QC-a d\*U from 
X.I screen's
controlling terminal. \fB-D\fP is the equivalent to the power detach key.
If no session can be detached, this option is ignored. 
The combination \*Qscreen -D -r\*U can be used to `transport' the elsewhere 
running session to this terminal and logout there. 
Note: It is a good idea to have the status of your sessions checked by means of
X\*Qscreen -list\*U.
X.TP 5
X.B "\-e \fIxy\fP"
specifies the command character to be \fIx\fP and the character generating a
literal command character to \fIy\fP (when typed after the command character).
The default is \*QC-a\*U and `a', which can be specified as \*Q-e^Aa\*U.
See the \*Qescape\*U .screenrc command for more details.
X.TP 5
X.B "\-f\fP, \fB\-fn\fP, and \fB\-fa"
turns flow-control on, off, or \*Qon with automatic switching\*U.
This can also be defined through the \*Qflow\*U .screenrc command.
X.TP 5
X.B "\-h \fInum\fP"
Specifies the history scrollback buffer to be \fInum\fP lines high.
X.TP 5
X.B \-i
will cause the interrupt key (usually C-c) to interrupt the display
immediately when flow-control is on.
See the \*Qflow\*U .screenrc command for details.
X.TP 5
X.B "\-l \fPand\fB -ln"
turns login mode on or off (for /etc/utmp updating).
This can also be defined through the \*Qlogin\*U .screenrc command.
X.TP 5
X.B "\-ls \fPand\fB -list"
does not start
X.IR screen ,
but prints a list of
X.I host.tty
pairs identifying your 
X.I screen
sessions.
Sessions marked `detached' can be resumed with \*Qscreen -r\*U. Those marked 
X`attached' are running and have a controlling terminal. Sessions marked as
X`dead' should be thoroughly checked and removed. Ask your system administrator
if you are not sure. Remove sessions with the \fB-wipe\fP option.
X.TP 5
X.B "\-t \fIname\fP"
sets the title (a.\|k.\|a.) for the default shell or specified program.
See also the \*Qshellaka\*U .screenrc command.
X.TP 5
X.B "\-wipe"
does the same as \*Qscreen -ls\*U, but removes destroyed sessions instead of 
marking them as `dead'.
X.TP 5
X.B \-L
tells 
X.I screen
your auto-margin terminal has a writable last-position on
the screen.
This can also be set in your .screenrc by specifying `LP' in a \*Qtermcap\*U
command.
X.TP 5
X.B \-O
selects a more optimal output mode for your terminal rather than true vt100
emulation (only affects auto-margin terminals without `LP').
This can also be set in your .screenrc by specifying `OP' in a \*Qtermcap\*U
command.
X.TP 5
X.B "\-r \fP[\fIhost.tty\fP]"
resumes a detached
X.I screen
session.
No other options (except \*Q-d -r\*U or \*Q-D -r\*U) may be specified, though
an optional
X.I host.tty
may be needed to distinguish between multiple detached
X.I screen
sessions.
X.TP 5
X.B \-R
attempts to resume the first detached 
X.I screen
session it finds.
If successful, all other command-line options are ignored.
If no detached session exists, starts a new session using the specified
options, just as if
X.B \-R
were not specified.
X.TP 5
X.B \-s
sets the default shell to the program specified, instead of the value
in the environment variable $SHELL (or \*Q/bin/sh\*U if not defined).
This can also be defined through the \*Qshell\*U .screenrc command.
X.SH CUSTOMIZATION
The \*Qsocket directory\*U defaults either to $HOME/.screen or preferably
to /local/screens. If
X.I screen
is installed setuid-root, then the administrator
should compile screen with an adequate (not NFS mounted) SOCKDIR. If
X.I screen
is not running setuid-root, the user can specify any mode 777 directory
in the environment variable $SCREENDIR.
X.PP
When
X.I screen
is invoked, it executes initialization commands from the files
X\*Q/local/etc/screenrc\*U and
X\*Q.screenrc\*U in the user's home directory. These are the \*Qprogrammer's
defaults\*U that can be overridden in the following ways: For the 
global screenrc file 
X.I screen
searches for the environment variable $SYSSCREENRC. The user specific
screenrc file is searchend in $ISCREENRC, then $SCREENRC, then $HOME/.iscreenrc
and finally defaults to $HOME/.screenrc. The command line option \fB-c\fP takes
precedence over the user specific screenrc file.
Commands in these files are used to set options, bind functions to
keys, and to automatically establish one or more extra windows at the
beginning of your
X.I screen
session.
Commands are listed one per line, with empty lines being ignored.
A command's arguments are separated by tabs or spaces, and may be
surrounded by single or double quotes.
A `#' turns the rest of the line into a comment, except in quotes.
Unintelligible lines are warned about and ignored.
Commands may contain references to environment variables. The 
syntax is the shell-like "$VAR " or "${VAR}". Note that this causes 
incompatibilities with previous 
X.I screen
versions, as now the '$'-sign has to be protected with '\' if no
variable substitution shall be performed.
X.PP
Customization can also be done 'on-line'. To enter the command mode type
X`C-a :'. Setting flags (like scrollback, login, etc.) on-line may not have
the desired effect, as e.\|g. the command "C-a : login on" will affect
only the settings for the creation of new windows (just like within .screenrc).
If you intend to change flags
of the current window, then prepend the command with the keyword "set". E.\|g.
X"C-a : set login on" will log this window in.
X.PP
The following initialization commands are available:
X.PP
X.ne 3
X.B "activity \fImessage\fP"
X.sp
When any activity occurs in a background window that is being monitored,
X.I screen
displays a notification in the message line.
The notification message can be re-defined by means of the \*Qactivity\*U
command.
XEach occurrence of `%' in \fImessage\fP is replaced by
the number of the window in which activity has occurred,
and each occurrence of `~' is replaced by the definition for bell
in your termcap (usually an audible bell).
The default message is
X.sp
X	'Activity in window %'
X.sp
Note that monitoring is off for all windows by default, but can be altered
by use of the \*Qmonitor\*U command (C-a M).
X.PP
X.ne 3
X.B "autodetach on\fP|\fBoff"
X.sp
Sets whether 
X.I screen
will automatically detach upon hangup, which
saves all your running programs until they are resumed with a
X.B "screen -r"
command.
When turned off, a hangup signal will terminate 
X.I screen
and all the processes it contains. Autodetach is on by default.
X.PP
X.ne 3
X.B "bell \fImessage\fP"
X.sp
When a bell character is sent to a background window,
X.I screen
displays a notification in the message line.
The notification message can be re-defined by means of the \*Qbell\*U
command.
XEach occurrence of `%' in \fImessage\fP is replaced by
the number of the window to which a bell has been sent,
and each occurrence of `~' is replaced by the definition for bell
in your termcap (usually an audible bell).
The default message is
X.sp
X	'Bell in window %'
X.sp
An empty message can be supplied to the \*Qbell\*U command to suppress
output of a message line (bell "").
X.PP
X.ne 3
X.B "bind \fP\fIkey\fP [\fIfunction\fP [\fIargs\fP]]"
X.sp
Bind a function to a key.
By default, each function provided by
X.I screen
is bound to one or more keys as indicated by the above table, e.\|g. the
function to create a new window is bound to \*QC-c\*U and \*Qc\*U.
The \*Qbind\*U command can be used to redefine the key bindings and to
define new bindings.
The \fIkey\fP argument is either a single character, a two-character sequence
of the form \*Q^x\*U (meaning \*QC-x\*U), a backslash followed by an octal
number (specifying the ASCII code of the character), or a backslash followed
by a second character, such as \*Q\e^\*U or \*Q\e\e\*U.
The argument can also be quoted, if you like.
If no further argument is given, any previously established binding
for this key is removed.
The \fIfunction\fP argument can be one of the following keywords:
X.PP
X.nf
X	select0	Switch to window #0
X	\0\0...
X	select9	Switch to window #9
X	aka	Change the current window's a.\|k.\|a.
X	autoflow	Toggle the current window's autoflow setting
X	clear	Clear the screen
X	colon	Enter one \*Q.screenrc\*U command on-the-fly.
X	copy	Select a piece of text.
X	detach	Detach \fIscreen\fP
X	flow	Toggle the current window's flow-control setting
X	hardcopy	Make hardcopy of current window
X	history	Use cut&paste to fetch a recently displayed line.
X	help	Display a list of the key bindings in effect
X	info	Display the current window's status information
X	kill	Kill the current window
X	lastmsg	Redisplay the last message line
X	lock	Run a screenlock program. 
X	log	Begin/end logging of the current window's output
X	login	Toggle the window's \*Qlogin\*U setting (/etc/utmp entry)
X	monitor	Toggle activity monitoring of the current window
X	next	Switch to the next window
X	other	Switch to the window displayed previously
X	paste	Paste in a selected piece of text.
X	pow_detach	Detach \fIscreen\fP and logout.
X	prev	Switch to the previous window
X	quit	Kill all windows and terminate
X	readbuffer	Take text from the exchange file.
X	redisplay	Redisplay current window
X	reset	Reset the window to its \*Qpower-on\*U settings
X	screen	Create a new window with the specified command
X	shell	Create a new window with a shell
X	suspend	Suspend \fIscreen\fP
X	termcap	Write screen's termcap entry to $HOME/.screencap
X	vbell	Toggle the window's \*Qvbell\*U setting.
X  	version	Display the version numbers and date last modified
X	width	Toggle the terminal width between 80 and 132 columns
X	windows	Display a list of all windows
X	wrap	Toggle the current window's line-wrap setting
X	writebuffer	Store the selected text in the exchange file.
X	xoff	Send a control-s to the current program
X	xon	Send a control-q to the current program
X.fi
X.PP
XFor purposes of backward compatibility, if your command does not match one
of the above keywords, it is assumed to be an external command, and is run
in a newly created window.
This is an abbreviation of the screen command,
but without the possibility of specifying any screen options.
Some examples:
X.PP
X.nf
X	bind ' ' windows
X	bind ^f screen telnet foobar
X	bind \e033 screen -ln -t root 9 su
X.fi
X.PP
would bind the space key to the function that displays a list
of windows (so that the function usually invoked by \*QC-a C-w\*U
would also be available as \*QC-a space\*U),
bind \*QC-f\*U to the function \*Qcreate a window with a TELNET
connection to foobar\*U, and bind \*Qescape\*U to the function
that creates an non-login window with a.\|k.\|a. \*Qroot\*U in slot #9, with
a super-user shell.
X.PP
X.ne 3
X.B "chdir \fP[\fIdirectory\fP]"
X.sp
Change the \fIcurrent directory\fP of
X.I screen
to the specified directory or, if called without an argument,
to your home directory (the value of the environment variable $HOME).
All windows that are created by means of the \*Qscreen\*U command
from within \*Q.screenrc\*U or by means of \*QC-a : screen ...\*U
or \*QC-a c\*U use this as their default directory.
Without a chdir command, this would be the directory from which
X.I screen
was invoked.
Hardcopy and log files are always written to the \fIwindow's\fP default
directory, \fInot\fP the current directory of the process running in the
window.
You can use this command multiple times in your .screenrc to start various
windows in different default directories, but the last chdir value will
affect all the windows you create interactively.
X.PP
X.ne 3
X.B "crlf on\fP|\fBoff"
X.sp
This affects the copying of text regions with the `C-a [' command. If it is set
to `on', lines will be separated by the two character sequence `CR' - `LF'. 
Otherwise only `LF' is used.
X.PP
X.ne 3
X.B "echo \fP[\fB-n\fP]\fB \fImessage\fP"
X.sp
The echo command may be used to annoy 
X.I screen
users with a 'message of the
day'. Typically installed in a global /usr/local/etc/screenrc. See also
X\*Qsleep\*U.
XEcho is also usefull for online checking of environment variables.
X.PP
X.ne 3
X.B "escape \fIxy\fP"
X.sp
Set the command character to \fIx\fP and the character generating a literal
command character to \fIy\fP (just like in the \-e option).
XEach argument is either a single character, a two-character sequence
of the form \*Q^x\*U (meaning \*QC-x\*U), a backslash followed by an octal
number (specifying the ASCII code of the character), or a backslash followed
by a second character, such as \*Q\e^\*U or \*Q\e\e\*U.
The default is \*Q^Aa\*U, but \*Q``\*U is recommended by one of the authors.
X.PP
X.ne 3
X.B "flow on\fP|\fBoff\fP|\fBauto \fP[\fBinterrupt\fP]\fB"
X.sp
Sets the default flow-control mode for new windows.
Specifying \*Qflow auto interrupt\*U is the same as the command-line options
X.B \-fa
and
X.BR \-i .
See the discussion on FLOW-CONTROL later on in this document for full details.
X.PP
X.ne 3
X.B "login on\fP|\fBoff"
X.sp
Sets the login flag which determines if new windows should have /etc/utmp
entries added for them.
The login state is also changeable on-the-fly by using the bindable version
of the \*Qlogin\*U command (C-a L) of by means of "C-a : set login on|off".
The default should be \*Qon\*U for a 
X.I screen
that runs under suid-root.
X.PP
X.ne 3
X.B "markkeys \fIstring\fP"
X.sp
This is a method of changing the keymap used for copy/history mode.
The string is made up of \fIoldchar\fP=\fInewchar\fP pairs which are
separated by `:'. Example: The string \*QB=^B:F=^F\*U will change the 
keys `C-b' and `C-f' from their (original emacs-style bindings) to the vi style
binding (scroll up/down full page), which is the default meaning of `B' and
X`F'.
X.PP
X.ne 3
X.B "mode \fImode\fP"
X.sp
The mode of each newly allocated pseudo-tty is set to \fImode\fP.
X\fIMode\fP is an octal number.
When no \*Qmode\*U command is given, mode 0622 is used.
X.PP
X.ne 3
X.B "nethack on\fP|\fBoff"
X.sp
Changes the kind of error messages used by
X.IR screen .
When you are familiar with the game \*Qnethack\*U, you may enjoy the
nethack-style messages which will often blurr the facts a little, but are
much funnier to read. Anyway, standard messages always tend to be unclear as
well.
X.br
This option is only 
available, if screen was compiled with the NETHACK flag defined. The
default setting is then determined by the presence of the environment 
variable $NETHACKOPTIONS.
X.PP
X.ne 3
X.B "password \fP[\fIcrypted_pw\fP]"
X.sp
Present a crypted password in your \*Q.screenrc\*U file and screen will ask
for it, whenever a detached session is tried to be resumed. This is useful,
if you have privileged programs running under
X.I screen
and you want to protect your session from reattach attempts by users that 
managed to have your uid. (I.e. any superuser.)
X.PP
X.ne 3
X.B "pow_detach_msg \fImessage\fP"
X.sp
The \fImessage\fP specified here is output whenever a `Power detach' was
performed. It may be used as a replacement for a logout message or to reset 
baud rate, etc.
X.PP
X.ne 3
X.B "screen \fP[\fI-opts\fP] [\fIn\fP] [\fIcmd\fP [\fIargs\fP]]"
X.sp
XEstablish a new window.
The flow-control options (\fB\-f\fP, \fB\-fn\fP and \fB\-fa\fP),
title (a.\|k.\|a.) option (\fB\-t\fP), login options (\fB-l\fP and \fB-ln\fP)
X, terminal type option (\fB-T <term>\fP) and scrollback option (\fB-h\fP <num>)
may be specified for each command.
If an optional number \fIn\fP in the range 0..9 is given, the window
number \fIn\fP is assigned to the newly created window (or, if this
number is already in-use, the next available number).
If a command is specified after \*Qscreen\*U, this command (with the given
arguments) is started in the window; otherwise, a shell is created.
Thus, if your \*Q.screenrc\*U contains the lines
X.sp
X.nf
X	# example for .screenrc:
X	screen 1
X	screen -fn -t foobar 2 telnet foobar
X.fi
X.sp
X.I screen
creates a shell window (in window #1), a window with a TELNET connection
to the machine foobar (with no flow-control using the a.\|k.\|a. \*Qfoobar\*U
in window #2), and finally, a second shell window
X(the default window) which gets a window number of zero.
When the initialization is completed,
X.I screen
switches to the last window specified in your .screenrc file or, if none, it
opens a default window #0 that would be displayed in this
case.
X.PP
X.ne 3
X.B "scrollback \fP\fInum\fP"
X.sp
Set the size of the scrollback buffer for new windows to \fInum\fP lines.
The default scrollback is 50 lines.
Use "C-a : set scrollback \fInum\fP" to change the scrollback size of the
current window and use "C-a i" to view the current setting. 
X.PP
X.ne 3
X.B "shell \fIcommand\fP"
X.sp
Set the command to be used to create a new shell.
This overrides the value of the environment variable $SHELL, or \*Q/bin/sh\*U
if undefined.
This is useful if you'd like to run a tty-enhancer which is expecting to
execute the program specified in $SHELL.
X.PP
X.ne 3
X.B "shellaka \fIa.\|k.\|a.\fP"
X.sp
Set the a.\|k.\|a. for all shells created during startup or by
the C-A C-c command.
XFor details about what a.\|k.\|a.\|'s are, see the discussion
entitled ALSO KNOWN AS.
X.PP
X.ne
X.B "sleep \fP\fInum\fP"
This command will pause the execution of a .screenrc file for \fInum\fP seconds.
It may be used to give users a chance to read the messages output by \*Qecho\*U.
X.PP
X.ne 3
X.B "term \fIterm\fP"
X.sp
In each window's environment
X.I screen
opens, it sets the $TERM variable to \*Qscreen\*U by default. 
But when no description for \*Qscreen\*U is installed in the local termcap
or terminfo data base, you can pretend that the terminal emulator is - say -
X\*Qvt100\*U. This won't do much harm, as 
X.I screen
is VT100/ANSI compatible.
The use of the \*Qterm\*U command is discouraged for non-default purpose.
That is, one may want to specify special $TERM settings (e.g. vt100) for the
next \*Qscreen rlogin othermacine\*U command. Use the command \*Qscreen -T vt100
rlogin othermachine\*U rather than setting (\*Qterm vt100\*U) and resetting
X(\*Qterm screen\*U) the default before and after the \*Qscreen\*U command.
X.PP
X.ne 3
X.B "termcap \fIterm\fP \fIterminal-tweaks\fP \fP[\fIwindow-tweaks\fP]"
X.br
X.B "terminfo \fIterm\fP \fIterminal-tweaks\fP \fP[\fIwindow-tweaks\fP]"
X.sp
Use this command to modify your terminal's termcap entry without going through
all the hassles involved in creating a custom termcap entry.
Plus, you can optionally customize the termcap generated for the windows.
If your system works with terminfo-database rather than with
termcap
X.I screen
will understand the `terminfo' command which has the same effects as
the `termcap' command. Thus users can write one .screenrc file that handles
both cases, although terminfo syntax is slightly different
from termcap syntax.
X.PP
The first argument specifies which terminal(s) should be affected by this
definition.
You can specify multiple terminal names by separating them with `|'s.
Use `*' to match all terminals and `vt*' to match all terminals that begin
with \*Qvt\*U.
X.PP
XEach \fItweak\fP argument contains one or more termcap defines (separated
by `:'s) to be inserted at the start of the appropriate termcap entry,
enhancing it or overriding existing values.
The first tweak modifies your terminal's termcap, and contains definitions
that your terminal uses to perform certain functions.
Specify a null string to leave this unchanged (e.\|g. '').
The second (optional) tweak modifies all the window termcaps, and should
contain definitions that screen understands (see the \*QVIRTUAL TERMINAL\*U
section).
X.PP
Some examples:
X.IP
termcap xterm*  LP:hs@
X.PP
Informs
X.I screen
that all terminals that begin with `xterm' have firm auto-margins that
allow the last position on the screen to be updated (LP), but they don't
really have a status line (no 'hs' -- append `@' to turn entries off).
Note that we assume `LP' for all terminal names that start with \*Qvt\*U,
but only if you don't specify a termcap command for that terminal.
X.sp
X.nf
X	termcap vt*  LP
X	termcap vt102|vt220  Z0=\eE[?3h:Z1=\eE[?3l
X.fi
X.sp
Specifies the firm-margined `LP' capability for all terminals that begin with
X`vt', and the second line will also add the escape-sequences to switch
into (Z0) and back out of (Z1) 132-character-per-line mode if this is
a vt102 or vt220.
X(You must specify Z0 and Z1 in your termcap to use the width-changing
commands.)
X.IP
termcap vt100  ""  l0=PF1:l1=PF2:l2=PF3:l3=PF4
X.PP
This leaves your vt100 termcap alone and adds the function key labels to
each window's termcap entry.
X.IP
termcap h19|z19  am@:im=\eE@:ei=\eEO  dc=\eE[P
X.PP
Takes a h19 or z19 termcap and turns off auto-margins (am@) and enables the
insert mode (im) and end-insert (ei) capabilities (the `@' in the `im'
string is after the `=', so it is part of the string).
Having the `im' and `ei' definitions put into your terminal's termcap will
cause screen to automatically advertise the character-insert capability in
each window's termcap.
XEach window will also get the delete-character capability (dc) added to its
termcap, which screen will translate into a line-update for the terminal
X(we're pretending it doesn't support character deletion).
X.PP
If you would like to fully specify each window's termcap entry, you should
instead set the $SCREENCAP variable prior to running
X.IR screen .
See the discussion on the \*QVIRTUAL TERMINAL\*U in this manual, and the termcap(5)
man page for more information on termcap definitions.
X.PP
X.ne 3
X.B "vbell on\fP|\fBoff"
X.sp
Sets the visual bell setting for new windows. If your terminal does not support
a visual bell a message is printed to the status line. The default 
message is \*QWuff, Wuff!!\*U.
X.PP
X.ne 3
X.B "vbell_msg \fImessage\fP"
X.sp
Sets the visual bell message. \fImessage\fP is printed to the status line if
the window receives a bell character (^G) and vbell is set to \*Qon\*U.
X.PP
X.ne 3
X.B "wrap on\fP|\fBoff"
X.sp
Sets the line-wrap setting for new windows.
When line-wrap is on, the second consecutive printable character output at
the last column of a line will wrap to the start of the following line.
As an added feature, backspace (^H) will also wrap through the left margin
to the previous line.
Line-wrap is on by default and can be toggled with the \*Qwrap\*U
command (\*QC-a r\*U) or by means of "C-a : set wrap on|off".
X.SH "THE MESSAGE LINE"
X.I Screen
displays informational messages and other diagnostics in a \fImessage line\fP
at the bottom of the screen.
If your terminal has a status line defined in its termcap, screen will use
this for displaying its messages, otherwise the last line of the screen will
be temporarily overwritten and output will be momentarily interrupted.
The message line is automatically removed after a few seconds delay, but it
can also be removed early (on terminals without a status line) by beginning
to type.
X.PP
The message line facility can be used by an application running in
the current window by means of the ANSI \fIPrivacy message\fP
control sequence.
XFor instance, from within the shell, try something like:
X.IP
echo '<esc>^Hello world<esc>\e\e'
X.PP
where '<esc>' is an \fIescape\fP, '^' is a literal up-arrow,
and '\e\e' turns into a single backslash.
X.SH "FLOW-CONTROL"
XEach window has a flow-control setting that determines how screen deals with
the XON and XOFF characters (and perhaps the interrupt character).
When flow-control is turned off, screen ignores the XON and XOFF characters,
which allows the user to send them to the current program by simply typing
them (useful for the \fIemacs\fP editor, for instance).
The trade-off is that it will take longer for output from a \*Qnormal\*U
program to pause in response to an XOFF.
With flow-control turned on, XON and XOFF characters are used to immediately
pause the output of the current window.
You can still send these characters to the current program, but you must use
the appropriate two-character screen commands (typically \*QC-a q\*U (xon)
and \*QC-a s\*U (xoff)).
The xon/xoff commands are also useful for typing C-s and C-q past a terminal
that intercepts these characters.
X.PP
XEach window has an initial flow-control value set with either the
X.B \-f
option or the \*Qflow\*U .screenrc command.
It can then be toggled on and off interactively with the \*Qflow\*U
bound-command (C-a f).
X.PP
There is also an automatic flow-switching mode that will enable/disable
flow-control on-the-fly based on the current setting of the application
keypad -- when it is enabled, flow-control is turned off and visa versa.
Of course, you can still manipulate flow-control manually when needed, and
toggle the auto-flow mode on and off with the \*Qautoflow\*U command (C-a /).
X.PP
If you're running with flow-control enabled and find that pressing the
interrupt key (usually C-c) does not interrupt the display until another
X6-8 lines have scrolled by, try running screen with the \*Qinterrupt\*U
option (add the \*Qinterrupt\*U flag to the \*Qflow\*U command in
your .screenrc, or use the
X.B \-i
command-line option).
This causes the output that
X.I screen
has accumulated from the interrupted program to be flushed.
One disadvantage is that the virtual terminal's memory contains the
non-flushed version of the output, which in rare cases can cause
minor inaccuracies in the output.
XFor example, if you switch screens and return, or update the screen
with \*QC-a l\*U you would see the version of the output you would
have gotten without \*Qinterrupt\*U being on.
Also, you might need to turn off flow-control (or use auto-flow mode to turn
it off automatically) when running a program that expects you to type the
interrupt character as input, as it is possible to interrupt
the output of the virtual terminal to your physical terminal when flow-control
is enabled.
If this happens, a simple refresh of the screen with \*QC-a l\*U will
restore it.
Give each mode a try, and use whichever mode you find more comfortable.
X.SH "ALSO KNOWN AS (A.\|K.\|A.\|s)"
You can customize each window's name in the window display (viewed with the
X\*Qwindows\*U command (C-a w)) by setting it with one of
the a.\|k.\|a. commands.
Normally the name displayed is the actual command name of the program
created in the window.
However, it is sometimes useful to distinguish various programs of the same
name or to change the name on-the-fly to reflect the current state of
the window.
X.PP
The default name for all shell windows can be set with the \*Qshellaka\*U
command in the .screenrc file, while all other windows are created with
a \*Qscreen\*U command and thus can have their name set with the
X.B \-t
option.
Interactively, there is the AKA-string escape-sequence
X(<esc>k\fIname\fP<esc>\e) and the \*Qaka\*U command (C-a A).
The former can be output from an application to control the window's name
under software control, and the latter will prompt for a name when typed.
You can also bind pre-defined names to keys with the \*Qaka\*U command
to set things quickly without prompting.
X.PP
XFinally,
X.I screen
has a shell-specific heuristic that is enabled by setting the window's name
to \*Q\fIsearch|name\fP\*U and arranging to have a null aka escape-sequence
output as a part of your prompt.
The \fIsearch\fP portion specifies an end-of-prompt search string, while
the \fIname\fP portion specifies the default shell name for the window.
If the \fIname\fP ends in a `:'
X.I screen
will add what it believes to be the current command running in the window
to the end of the window's shell name (e.\|g. \*Q\fIname:cmd\fP\*U).
Otherwise the current command name supersedes the shell name while it is
running.
X.PP
Here's how it works:  you must modify your shell prompt to output a null
aka escape-sequence (<esc>k<esc>\e) as a part of your prompt.
The last part of your prompt must be the same as the string you specified
for the \fIsearch\fP portion of the a.\|k.\|a.
Once this is set up,
X.I screen
will use the aka escape-sequence to clear the previous command name and
get ready for the next command.
Then, when a newline is received from the shell, a search is made for the
end of the prompt.
If found, it will grab the first word after the matched string and use it
as the command name.
If the command name begins with either '!', '%', or '^'
X.I screen
will use the first word on the following line (if found) in preference to
the just-found name.
This helps csh users get better command names when using job control or
history recall commands.
X.PP
Here's some .screenrc examples:
X.IP
screen -t top 2 nice top
X.PP
Adding this line to your .screenrc would start a niced version of the
X\*Qtop\*U command in window 2 name \*Qtop\*U rather than \*Qnice\*U.
X.sp
X.nf
X	shellaka '> |csh'
X	screen 1
X.fi
X.sp
This file would start two shells (one specified, one default) using
the given shellaka.
The a.\|k.\|a. specified is an auto-aka that would expect the prompt and
the typed command to look something like the following:
X.IP
X/usr/joe/src/dir> trn
X.PP
X(it looks after the '> ' for the command name).
The window status would show the name \*Qtrn\*U while the command was
running, and revert to \*Qcsh\*U upon completion.
X.IP
bind R screen -t '% |root:' su
X.PP
Having this command in your .screenrc would bind the key
sequence \*QC-a R\*U to the \*Qsu\*U command and give it an
auto-aka name of \*Qroot:\*U.
XFor this auto-aka to work, the screen could look something
like this:
X.sp
X.nf
X	% !em
X	emacs file.c
X.fi
X.sp
Here the user typed the csh history command \*Q!em\*U which ran the
previously entered \*Qemacs\*U command.
The window status would show \*Qroot:emacs\*U during the execution
of the command, and revert to simply \*Qroot:\*U at its completion.
X.PP
X.nf
X	bind o aka
X	bind E aka ""
X	bind u aka (unknown)
X.fi
X.sp
The first binding doesn't have any arguments, so it would prompt you
for an a.\|k.\|a. when you type \*QC-a o\*U.
The second binding would clear an auto-aka's current setting (C-a E).
The third binding would set the current window's a.\|k.\|a. to \*Q(unknown)\*U
X(C-a u).
X.PP
One thing to keep in mind when adding a null aka escape-sequence to
your prompt is that some shells (like the csh) count all the non-control
characters as part of the prompt's length.
If these invisible characters aren't a multiple of 8 then backspacing over
a tab will result in an incorrect display.
One way to get around this is to use a prompt like this:
X.IP
set prompt='^[[0000m^[k^[\e% '
X.PP
The escape-sequence \*Q<esc>[0000m\*U not only normalizes the character
attributes, but all the zeros round the length of the invisible characters
up to 8.
Bash users will probably want to echo the escape sequence in the
PROMPT_COMMAND:
X.IP
PROMPT_COMMAND='echo -n -e "\e033k\e033\e134"'
X.PP
X(I used \*Q\134\*U to output a `\e' because of a bug in v1.04).
X.SH "THE VIRTUAL TERMINAL"
Usually
X.I screen
tries to emulate as much of the VT100/ANSI standard
as possible. But if your terminal lacks certain capabilities
the emulation may not be complete. In these cases
X.I screen
has to tell the applications that some of the features
are missing. This is no problem on machines using termcap,
because
X.I screen
can use the $TERMCAP variable to
customize the standard screen termcap.
X.br
But if you do a
rlogin on another machine or your machine supports only
terminfo this method fails. Because of this
X.I screen
offers a way to deal with these cases. Here is how it works:
X.br
When 
X.I screen
tries to figure out a terminal name for itself,
it first looks
for an entry named \*Qscreen.<term>\*U, where <term> is
the contents of your $TERM variable.
If no such entry exists,
X.I screen
tries \*Qscreen\*U (or \*Qscreen-w\*U, if the terminal is wide
X(132 cols or more)).
If even this entry cannot be found, \*Qvt100\*U is used as a
substitute.
X.br
The idea is that if you have a terminal which doesn't
support an important feature (e.g. delete char or clear to EOS)
you can build a new termcap/terminfo entry for
X.I screen
X(named \*Qscreen.<dumbterm>\*U) in which this capability
has been disabled.  If this entry is installed on your
machines you are able to do
a rlogin and still keep the correct termcap/terminfo entry.
The terminal name is put in the $TERM variable
of all new windows.
X.I Screen
also sets the $TERMCAP variable reflecting the capabilities
of the virtual terminal emulated. Notice that, however, on machines
using the terminfo database this variable has no effect.
XFurthermore, the variable $WINDOW is set to the window number
of each window.
X.br
The actual set of capabilities supported by the virtual terminal
depends on the capabilities supported by the physical terminal.
If, for instance, the physical terminal does not support underscore mode,
X.I screen
does not put the `us' and `ue' capabilities into the window's $TERMCAP
variable, accordingly.
However, a minimum number of capabilities must be supported by a
terminal in order to run
X.IR screen ;
namely scrolling, clear screen, and direct cursor addressing
X(in addition,
X.I screen
does not run on hardcopy terminals or on terminals that over-strike).
X.PP
Also, you can customize the $TERMCAP value used by
X.I screen
by using the \*Qtermcap\*U .screenrc command, or
by defining the variable $SCREENCAP prior to startup.
When the latter defined, its value will be copied verbatim into each
window's $TERMCAP variable.
This can either be the full terminal definition, or a filename where the
terminal \*Qscreen\*U (and/or \*Qscreen-w\*U) is defined.
X.PP
Note that 
X.I screen
honors the \*Qterminfo\*U .screenrc command if the system uses the
terminfo database rather than termcap.
X.PP
When the boolean `G0' capability is present in the termcap entry
for the terminal on which
X.I screen
has been called, the terminal emulation of
X.I screen
supports multiple character sets.
This allows an application to make use of, for instance,
the VT100 graphics character set or national character sets.
The following control functions from ISO 2022 are supported:
X\fIlock shift G0\fP (\fISI\fP), \fIlock shift G1\fP (\fISO\fP),
X\fIlock shift G2\fP, \fIlock shift G3\fP, \fIsingle shift G2\fP,
and \fIsingle shift G3\fP.
When a virtual terminal is created or reset, the ASCII character
set is designated as \fIG0\fP through \fIG3\fP.
When the `G0' capability is present, screen evaluates the capabilities
X`S0', `E0', and `C0' if present. `S0' is the sequence the terminal uses
to enable and start the graphics character set rather than \fISI\fP. 
X`E0' is the corresponding replacement for \fISO\fP. `C0' gives a character
by character translation string that is used during semi-graphics mode. This 
string is built like the `acsc' terminfo capability.
X.PP
When the `po' and `pf' capabilities are present in the terminal's
termcap entry, applications running in a
X.I screen
window can send output to the printer port of the terminal.
This allows a user to have an application in one window
sending output to a printer connected to the terminal, while all
other windows are still active (the printer port is enabled
and disabled again for each chunk of output).
As a side-effect, programs running in different windows can
send output to the printer simultaneously.
Data sent to the printer is not displayed in the window.
X.PP
Some capabilities are only put into the $TERMCAP
variable of the virtual terminal if they can be efficiently
implemented by the physical terminal.
XFor instance, `dl' (delete line) is only put into the $TERMCAP
variable if the terminal supports either delete line itself or
scrolling regions. Note that this may provoke confusion, when 
the session is reattached on a different terminal, as the value
of $TERMCAP cannot be modified by parent processes.
X.PP
The following is a list of control sequences recognized by
X.IR screen .
X\*Q(V)\*U and \*Q(A)\*U indicate VT100-specific and ANSI- or
ISO-specific functions, respectively.
X.PP
X.nf
X.TP 20
X.B "ESC E"
X	Next Line
X.TP 20
X.B "ESC D"
X	Index
X.TP 20
X.B "ESC M"
X	Reverse Index
X.TP 20
X.B "ESC H"
X	Horizontal Tab Set
X.TP 20
X.B "ESC 7"
X(V)	Save Cursor and Attributes
X.TP 20
X.B "ESC 8"
X(V)	Restore Cursor and Attributes
X.TP 20
X.B "ESC [s"
X(A)	Save Cursor and Attributes
X.TP 20
X.B "ESC [u"
X(A)	Restore Cursor and Attributes
X.TP 20
X.B "ESC c"
X	Reset to Initial State
X.TP 20
X.B "ESC ="
X(V)	Application Keypad Mode
X.TP 20
X.B "ESC >"
X(V)	Numeric Keypad Mode
X.TP 20
X.B "ESC # 8"
X(V)	Fill Screen with E's
X.TP 20
X.B "ESC \e"
X(A)	String Terminator
X.TP 20
X.B "ESC ^"
X(A)	Privacy Message String (Message Line)
X.TP 20
X.B "ESC k"
X	A.\|k.\|a. Definition String
X.TP 20
X.B "ESC P"
X(A)	Device Control String
X	Outputs a string directly to the host
X	terminal without interpretation.
X.TP 20
X.B "ESC _"
X(A)	Application Program Command (not used)
X.TP 20
X.B "ESC ]"
X(A)	Operating System Command (not used)
X.TP 20
X.B "Control-N"
X(A)	Lock Shift G1 (SO)
X.TP 20
X.B "Control-O"
X(A)	Lock Shift G0 (SI)
X.TP 20
X.B "ESC n"
X(A)	Lock Shift G2
X.TP 20
X.B "ESC o"
X(A)	Lock Shift G3
X.TP 20
X.B "ESC N"
X(A)	Single Shift G2
X.TP 20
X.B "ESC O"
X(A)	Single Shift G3
X.TP 20
X.B "ESC ( \fPPcs"
X(A)	Designate character set as G0
X.TP 20
X.B "ESC ) \fPPcs"
X(A)	Designate character set as G1
X.TP 20
X.B "ESC * \fPPcs"
X(A)	Designate character set as G2
X.TP 20
X.B "ESC + \fPPcs"
X(A)	Designate character set as G3
X.TP 20
X.B "ESC [ \fPPn\fB ; \fPPn\fB H"
X	Direct Cursor Addressing
X.TP 20
X.B "ESC [ \fPPn\fB ; \fPPn\fB f"
X	Direct Cursor Addressing
X.TP 20
X.B "ESC [ \fPPn\fB J"
X	Erase in Display
X.TP 20
X\h'\w'ESC 'u'Pn = None or \fB0\fP
X	From Cursor to End of Screen
X.TP 20
X\h'\w'ESC Pn = 'u'\fB1\fP
X	From Beginning of Screen to Cursor
X.TP 20
X\h'\w'ESC Pn = 'u'\fB2\fP
X	Entire Screen
X.TP 20
X.B "ESC [ \fPPn\fB K"
X	Erase in Line
X.TP 20
X\h'\w'ESC 'u'Pn = None or \fB0\fP
X	From Cursor to End of Line
X.TP 20
X\h'\w'ESC Pn = 'u'\fB1\fP
X	From Beginning of Line to Cursor
X.TP 20
X\h'\w'ESC Pn = 'u'\fB2\fP
X	Entire Line
X.TP 20
X.B "ESC [ \fPPn\fB A"
X	Cursor Up
X.TP 20
X.B "ESC [ \fPPn\fB B"
X	Cursor Down
X.TP 20
X.B "ESC [ \fPPn\fB C"
X	Cursor Right
X.TP 20
X.B "ESC [ \fPPn\fB D"
X	Cursor Left
X.TP 20
X.B "ESC [ \fPPs\fB ;\fP...\fB; \fPPs\fB m"
X	Select Graphic Rendition
X.TP 20
X\h'\w'ESC 'u'Ps = None or \fB0\fP
X	Default Rendition
X.TP 20
X\h'\w'ESC Ps = 'u'\fB1\fP
X	Bold
X.TP 20
X\h'\w'ESC Ps = 'u'\fB2\fP
X(A)	Faint
X.TP 20
X\h'\w'ESC Ps = 'u'\fB3\fP
X(A)	\fIStandout\fP Mode (ANSI: Italicized)
X.TP 20
X\h'\w'ESC Ps = 'u'\fB4\fP
X	Underlined
X.TP 20
X\h'\w'ESC Ps = 'u'\fB5\fP
X	Blinking
X.TP 20
X\h'\w'ESC Ps = 'u'\fB7\fP
X	Negative Image
X.TP 20
X\h'\w'ESC Ps = 'u'\fB22\fP
X(A)	Normal Intensity
X.TP 20
X\h'\w'ESC Ps = 'u'\fB23\fP
X(A)	\fIStandout\fP Mode off (ANSI: Italicized off)
X.TP 20
X\h'\w'ESC Ps = 'u'\fB24\fP
X(A)	Not Underlined
X.TP 20
X\h'\w'ESC Ps = 'u'\fB25\fP
X(A)	Not Blinking
X.TP 20
X\h'\w'ESC Ps = 'u'\fB27\fP
X(A)	Positive Image
X.TP 20
X.B "ESC [ \fPPn\fB g"
X	Tab Clear
X.TP 20
X\h'\w'ESC 'u'Pn = None or \fB0\fP
X	Clear Tab at Current Position
X.TP 20
X\h'\w'ESC Ps = 'u'\fB3\fP
X	Clear All Tabs
X.TP 20
X.B "ESC [ \fPPn\fB ; \fPPn\fB r"
X(V)	Set Scrolling Region
X.TP 20
X.B "ESC [ \fPPn\fB I"
X(A)	Horizontal Tab
X.TP 20
X.B "ESC [ \fPPn\fB Z"
X(A)	Backward Tab
X.TP 20
X.B "ESC [ \fPPn\fB L"
X(A)	Insert Line
X.TP 20
X.B "ESC [ \fPPn\fB M"
X(A)	Delete Line
X.TP 20
X.B "ESC [ \fPPn\fB @"
X(A)	Insert Character
X.TP 20
X.B "ESC [ \fPPn\fB P"
X(A)	Delete Character
X.TP 20
X.B "ESC [ \fPPs\fB ;\fP...\fB; \fPPs\fB h"
X	Set Mode
X.TP 20
X.B "ESC [ \fPPs\fB ;\fP...\fB; \fPPs\fB l"
X	Reset Mode
X.TP 20
X\h'\w'ESC 'u'Ps = \fB4\fP
X(A)	Insert Mode
X.TP 20
X\h'\w'ESC Ps = 'u'\fB?3\fP
X(V)	Change Terminal Width
X.TP 20
X\h'\w'ESC Ps = 'u'\fB?5\fP
X(V)	Visible Bell (\fIOn\fP followed by \fIOff\fP)
X.TP 20
X\h'\w'ESC Ps = 'u'\fB?6\fP
X(V)	\fIOrigin\fP Mode
X.TP 20
X\h'\w'ESC Ps = 'u'\fB?7\fP
X(V)	\fIWrap\fP Mode
X.TP 20
X.B "ESC [ 5 i"
X(A)	Start relay to printer (ANSI Media Copy)
X.TP 20
X.B "ESC [ 4 i"
X(A)	Stop relay to printer (ANSI Media Copy)
X.fi
X.SH FILES
X.nf
X.ta 2i
X$SYSSCREENRC
X.br
X/local/etc/screenrc		  \fIscreen\fP initialization commands
X.br
X$ISCREENRC
X.br
X$SCREENRC
X.br
X$HOME/.iscreenrc
X.br
X$HOME/.screenrc	  Read in after /usr/local/etc/screenrc
X.br
X$ISCREENDIR/S-<login>
X.br
X$SCREENDIR/S-<login>
X.br
X/local/screens/S-<login>		  Socket directories (default)
X.br
X/usr/tmp/screens/S-<login>		  Alternate socket directories.
X.br
X<socket directory>/.termcap		  Written by the "termcap" output function
X.br
X/usr/tmp/screens/screen-exchange		  or
X.br
X/tmp/screen-exchange		  \fIscreen\fP `interprocess communication buffer'
X.br
hardcopy.[0-9]	  Screen images created by the hardcopy function
X.br
screenlog.[0-9]	  Output log files created by the log function
X.br
X/usr/lib/terminfo/?/*		   or
X.br
X/etc/termcap	  Terminal capability databases
X.br
X/etc/utmp	  Login records
X.br
X$LOCKPRG	  Program that locks a terminal.
X.fi
X.SH "SEE ALSO"
termcap(5), utmp(5), vi(1), captoinfo(1), tic(1)
X.SH AUTHORS
Originally created by Oliver Laumann, this latest version was
produced by Wayne Davison, Juergen Weigert and Michael Schroeder.
X.SH CONTRIBUTORS
Bart Schaefer,
Patrick Wolfe,
Nathan Glasser,
Larry Virden,
Howard Chu,
Toerless Eckert, 
Rudolf Koenig.
X.SH VERSION
This is version 3.0. It's roots are a merge of version custom version
X2.3PR7 by Wayne Davison
and several enhancements to Oliver Laumann's version 2.0. Note that all versions
numbered 2.x are copyright by Oliver Laumann. 
X
X.SH BUGS
X`dm' (delete mode), `xn', and `xs' are not handled
correctly (they are ignored).
X.PP
The \fIGR\fP set of ISO 2022 is not supported.
X.PP
There is no keyboard input translation to VT100 sequences.
X.PP
It is not possible to change the environment variable $TERMCAP when 
reattaching under a different terminal type.
X.PP
The support of terminfo based systems is very limited. Adding extra
capabilities to $TERMCAP may not have any effects.
X.PP
X.I Screen
does not make use of hardware tabs.
X.PP
X.I Screen
must be installed as set-uid with owner root in order to be able
to correctly change the owner of the tty device file for each
window.
Special permission may also be required to write the file \*Q/etc/utmp\*U.
X.PP
XEntries in \*Q/etc/utmp\*U are not removed when
X.I screen
is killed with SIGKILL.
This will cause some programs (like "w" or "rwho")
to advertise that a user is logged on who really isn't.
END_OF_FILE
if test 61578 -ne `wc -c <'screen.1'`; then
    echo shar: \"'screen.1'\" unpacked with wrong size!
fi
# end of 'screen.1'
fi
echo shar: End of archive 6 \(of 8\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
