Newsgroups: comp.sources.unix
From: fthood!egray@uxc.cso.uiuc.edu (Emmet P. Gray)
Subject: v25i098: mtools2 - tools to manipulate MSDOS filesystems, V2.0, Part02/03
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: fthood!egray@uxc.cso.uiuc.edu (Emmet P. Gray)
Posting-Number: Volume 25, Issue 98
Archive-Name: mtools2/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 3)."
# Contents:  mtools/Configure mtools/buf_write.c mtools/dir_read.c
#   mtools/dir_write.c mtools/mattrib.c mtools/mcd.c mtools/mcopy.c
#   mtools/mdel.c mtools/mformat.c mtools/mlabel.c mtools/mmd.c
#   mtools/mrd.c mtools/mren.c mtools/mtype.c
# Wrapped by lai@risotto on Sat Jan 11 12:03:34 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'mtools/Configure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Configure'\"
else
echo shar: Extracting \"'mtools/Configure'\" \(4629 characters\)
sed "s/^X//" >'mtools/Configure' <<'END_OF_FILE'
XHow to configure Mtools to your system...
X
X1) Things you'll need to know.
X
X	The full path to the devices you want to use.
X
X	The number of tracks, heads, and sectors supported by each device.
X
X		5.25" 160k = 40 tracks, 1 head, and 8 sectors
X		5.25" 180k = 40 tracks, 1 head, and 9 sectors
X		5.25" 320k = 40 tracks, 2 heads, and 8 sectors
X		5.25" 360k = 40 tracks, 2 heads, and 9 sectors
X		5.25" 1.2m = 80 tracks, 2 heads, and 15 sectors
X		3.5"  720k = 80 tracks, 2 heads, and 9 sectors
X		3.5" 1.44m = 80 tracks, 2 heads, and 18 sectors
X
X	If you choose to use a hard disk partition as one of your devices,
X	then you may have to change the read/write permissions on that
X	partition.
X
X2) The Makefile and msdos.h files
X
X	The following pre-processor variables are used in Mtools.  They
X	should be set with "-Dvariable" in CFLAGS in the Makefile.
X
X		BSD	for systems without System V style strings functions
X			and System V style utime().
X
X		ISC	default devices for ISC's Unix V.
X
X		UNIXPC	default devices for AT&T Unix PC 7300/3B1
X
X		SPARC	default devices for SunOS 4.1 on a SPARCstation
X
X	There is a variable in msdos.h called SIG_TYPE which should be
X	configured to the "base" return type of signal();
X
X3) The devices "database" in devices.c
X
X	WARNING:  The devices.c file, as distributed, has *NO* devices
X	defined.  You *MUST* select from one of the examples or edit the
X	devices database yourself.
X
X	struct device {
X		char drive;			/* the drive letter */
X		char *name;			/* full path to device */
X		long offset;			/* skip this many bytes */
X		int fat_bits;			/* FAT encoding scheme */
X		int mode;			/* any special open() flags */
X		int (*gioctl) ();		/* gioctl() if needed */
X		int tracks;			/* tracks */
X		int heads;			/* heads */
X		int sectors;			/* sectors */
X	};
X
X	drive	the drive letter (in uppercase) that you want to associate
X		to this device.
X
X	name	full path to the device.  Shell expansion is done on the
X		name so things like $HOME/vpix/C: will work.
X
X	offset	skip over a partition table.  Useful for msdos disk "images"
X		such as those VP/ix uses.
X
X	fat_bits The encoding scheme for the File Allocation Table.  Currently
X		supports only 12 and 16 bit FATs.
X
X	mode	any special open() mode flags (not normally used, except
X		in the AT&T Unixpc 7300/3b1).
X
X	gioctl	any special ioctl() calls required after opening the device
X		(not normally used, except in the AT&T Unixpc 7300/3b1).
X
X	tracks	the number of tracks supported by this device or zero if
X		this type of sanity checking is not required.  Do NOT use
X		this field for hard disks or disk "images".  Also used by
X		gioctl(), if present, as a default starting place.
X
X	heads	the number of heads supported by this device or zero if
X		this type of sanity checking is not required.
X
X	sectors	the number of sectors supported by this device or zero if
X		this type of sanity checking is not required.
X
X
X	If a device supports more than one disk capacity (1.2m and
X	360k), then you should place the most frequently used capacity
X	first.  You may get an error message from the device driver when
X	the disk capacity doesn't match the device, but these can be
X	safely ignored.
X
X4)  Examples devices
X
X	for Interactive 386ix 2.0.2 with:
X		1.2m 5.25" as a: (supports 1.2m, 360k, and 320k)
X		1.44m 3.5" as b: (supports 1.44m, 720k)
X		hard disk partition as c:
X		vpix disk image as d:
X		user's vpix disk image as e:
X
X		{'A', "/dev/rdsk/f0q15dt", 0L, 12, 0, (int (*)()) 0, 80, 2, 15},
X		{'A', "/dev/rdsk/f0d9dt", 0L, 12, 0, (int (*)()) 0, 40, 2, 9},
X		{'A', "/dev/rdsk/f0d8dt", 0L, 12, 0, (int (*)()) 0, 40, 2, 8},
X		{'B', "/dev/rdsk/f13ht", 0L, 12, 0, (int (*)()) 0, 80, 2, 18},
X		{'B', "/dev/rdsk/f13dt", 0L, 12, 0, (int (*)()) 0, 80, 2, 9},
X		{'C', "/dev/rdsk/0p1", 0L, 16, 0, (int (*)()) 0, 0, 0, 0},
X		{'D', "/usr/vpix/defaults/C:", 8704L, 12, 0, (int (*)()) 0, 0, 0, 0},
X		{'E', "$HOME/vpix/C:", 8704L, 12, 0, (int (*)()) 0, 0, 0, 0},
X		{'\0', (char *) NULL, 0L, 0, 0, (int (*)()) 0, 0, 0, 0}
X
X
X	for AT&T Unixpc 7300/3b1 with:
X		360k 5.25" as a: (supports 360k, and 320k, 180k, 160k)
X		DOS73 disk image as c:
X
X		{'A', "/dev/rfp020", 0L, 12, O_NDELAY, init_unixpc, 40, 2, 9},
X		{'C', "/usr/bin/DOS/dvd000", 0L, 12, 0, (int (*)()) 0, 0, 0, 0}
X		{'\0', (char *) NULL, 0L, 0, 0, (int (*)()) 0, 0, 0, 0}
X
X
X	for Sun SparcStation with:
X		1.44m 3.5" as a: (supports 1.44m and 720k)
X
X		{'A', "/dev/rfd0c", 0L, 12, 0, (int (*)()) 0, 80, 2, 18},
X		{'A', "/dev/rfd0c", 0L, 12, 0, (int (*)()) 0, 80, 2, 9},
X		{'\0', (char *) NULL, 0L, 0, 0, (int (*)()) 0, 0, 0, 0}
X
X		Note that the two devices are actually the same physical
X		device, and that only the number of sectors are
X		different.
END_OF_FILE
if test 4629 -ne `wc -c <'mtools/Configure'`; then
    echo shar: \"'mtools/Configure'\" unpacked with wrong size!
fi
# end of 'mtools/Configure'
fi
if test -f 'mtools/buf_write.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/buf_write.c'\"
else
echo shar: Extracting \"'mtools/buf_write.c'\" \(3057 characters\)
sed "s/^X//" >'mtools/buf_write.c' <<'END_OF_FILE'
X/*
X * Do full cylinder buffered writes to slow devices.  Uses a simple
X * buffered read/delayed write algorithm
X */
X
X#include <stdio.h>
X#include "msdos.h"
X
Xextern int fd, disk_size, disk_dirty, dir_start, dir_len;
Xextern int clus_size;
Xextern long disk_offset, disk_current;
Xextern unsigned char *disk_buf;
Xstatic int blank_cyl();
X
Xvoid
Xdisk_write(start, buf, len)
Xlong start;
Xunsigned char *buf;
Xint len;
X{
X	register long i;
X	int length;
X	unsigned char *buf_ptr, *disk_ptr;
X	char *memcpy();
X	void perror(), exit(), disk_flush();
X	long where, tail, lseek();
X
X					/* don't use cache? */
X	if (disk_size == 1) {
X		where = (start * MSECTOR_SIZE) + disk_offset;
X		if (lseek(fd, where, 0) < 0) {
X			perror("disk_write: lseek");
X			exit(1);
X		}
X					/* write it! */
X		if (write(fd, (char *) buf, (unsigned int) len) != len) {
X			perror("disk_write: write");
X			exit(1);
X		}
X		return;
X	}
X
X	tail = start + (len / MSECTOR_SIZE) - 1;
X	for (i = start; i <= tail; i++) {
X					/* a cache miss... */
X		if (i < disk_current || i >= disk_current + disk_size) {
X
X			if (disk_dirty)
X				disk_flush();
X
X			/*
X			 * If there is something on the new cylinder that
X			 * you want to keep, you'll have to read it first
X			 * before writing.
X			 */
X			if (blank_cyl(i))
X				disk_current = (i / disk_size) * disk_size;
X			else {
X				disk_current = (i / disk_size) * disk_size;
X				where = (disk_current * MSECTOR_SIZE) + disk_offset;
X				length = disk_size * MSECTOR_SIZE;
X
X					/* move to next location */
X				if (lseek(fd, where, 0) < 0) {
X					perror("disk_write: lseek");
X					exit(1);
X				}
X					/* read it! */
X				if (read(fd, (char *) disk_buf, (unsigned int) length) != length) {
X					perror("disk_write: read");
X					exit(1);
X				}
X			}
X		}
X					/* a cache hit ... */
X		buf_ptr = buf + ((i - start) * MSECTOR_SIZE);
X		disk_ptr = disk_buf + ((i - disk_current) * MSECTOR_SIZE);
X		memcpy((char *) disk_ptr, (char *) buf_ptr, MSECTOR_SIZE);
X		disk_dirty = 1;
X	}
X	return;
X}
X
X/*
X * Flush a dirty buffer to disk.  Resets disk_dirty to zero.
X * All errors are fatal.
X */
X
Xvoid
Xdisk_flush()
X{
X	int len;
X	long where, lseek();
X	void perror(), exit();
X
X	if (fd < 0 || disk_current < 0L || !disk_dirty)
X		return;
X
X	where = (disk_current * MSECTOR_SIZE) + disk_offset;
X	if (lseek(fd, where, 0) < 0) {
X		perror("disk_flush: lseek");
X		exit(1);
X	}
X					/* write it! */
X	len = disk_size * MSECTOR_SIZE;
X	if (write(fd, (char *) disk_buf, (unsigned int) len) != len) {
X		perror("disk_flush: write");
X		exit(1);
X	}
X	disk_dirty = 0;
X	return;
X}
X
X/*
X * Determine if the cylinder has some useful information on it.  Returns a 1
X * if it is blank.
X */
X
Xstatic int
Xblank_cyl(num)
Xlong num;
X{
X	register unsigned int i;
X	unsigned int start, end, fat_decode();
X	long sector;
X
X	sector = (num / disk_size) * disk_size;
X	if (!sector)
X		return(0);
X
X	start = ((sector - dir_start - dir_len) / clus_size) + 2;
X	end = ((sector + disk_size - dir_start - dir_len) / clus_size) + 2;
X
X	for (i = start; i < end; i++) {
X					/* if fat_decode returns non-zero */
X		if (fat_decode(i))
X			return(0);
X	}
X	return(1);
X}
END_OF_FILE
if test 3057 -ne `wc -c <'mtools/buf_write.c'`; then
    echo shar: \"'mtools/buf_write.c'\" unpacked with wrong size!
fi
# end of 'mtools/buf_write.c'
fi
if test -f 'mtools/dir_read.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/dir_read.c'\"
else
echo shar: Extracting \"'mtools/dir_read.c'\" \(3300 characters\)
sed "s/^X//" >'mtools/dir_read.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "msdos.h"
X
Xlong dir_chain[MAX_DIR_SECS];		/* chain of sectors in directory */
Xunsigned char *dir_buf;			/* the directory buffer */
Xint dir_dirty;				/* is the buffer dirty? */
X
Xextern int dir_len, dir_start, clus_size, dir_entries, fat_error;
Xextern unsigned int last_fat;
X
X/*
X * Read a directory entry, return a pointer a static structure.
X */
X
Xstruct directory *
Xdir_read(num)
Xint num;
X{
X	char *memcpy();
X	unsigned char *offset;
X	static struct directory dir;
X
X	offset = dir_buf + (num * MDIR_SIZE);
X	memcpy((char *) &dir, (char *) offset, MDIR_SIZE);
X	return(&dir);
X}
X
X/*
X * Fill in the global variable dir_chain[].  Argument is the starting
X * cluster number.  Returns -1 on error.
X */
X
Xint
Xfill_chain(num)
Xunsigned int num;
X{
X	register int i, length;
X	unsigned int next, fat_decode();
X	unsigned char *offset;
X	char *malloc();
X	void free(), perror(), exit(), disk_read(), dir_flush();
X
X	length = 0;
X	/* CONSTCOND */
X	while (1) {
X		dir_chain[length] = (long) (num - 2) * clus_size + dir_start + dir_len;
X		length++;
X					/* sectors, not clusters! */
X		for (i = 1; i < clus_size; i++) {
X			dir_chain[length] = dir_chain[length - 1] + 1L;
X			length++;
X		}
X
X		if (length >= MAX_DIR_SECS) {
X			fprintf(stderr, "fill_chain: directory too large\n");
X			return(-1);
X		}
X					/* get next cluster number */
X		next = fat_decode(num);
X		if (next == 1) {
X			fprintf(stderr, "fill_chain: FAT problem\n");
X			fat_error++;
X			return(-1);
X		}
X					/* end of cluster chain */
X		if (next >= last_fat)
X			break;
X		num = next;
X	}
X	if (dir_dirty)
X		dir_flush();
X					/* fill the dir_buf */
X	free((char *) dir_buf);
X	dir_buf = (unsigned char *) malloc((unsigned int) length * MSECTOR_SIZE);
X	if (dir_buf == NULL) {
X		perror("fill_chain: malloc");
X		exit(1);
X	}
X
X	for (i = 0; i < length; i++) {
X		offset = dir_buf + (i * MSECTOR_SIZE);
X		disk_read(dir_chain[i], offset, MSECTOR_SIZE);
X	}
X
X	dir_entries = length * 16;
X	return(0);
X}
X
X/*
X * Reset the global variable dir_chain[] to the root directory.
X */
X
Xvoid
Xreset_chain(code)
Xint code;
X{
X	register int i;
X	char *malloc();
X	void free(), disk_read(), dir_flush(), exit(), perror();
X
X	if (dir_dirty)
X		dir_flush();
X
X	for (i = 0; i < dir_len; i++)
X		dir_chain[i] = (long) dir_start + i;
X
X	if (code == OLD)
X		free((char *) dir_buf);
X
X	dir_buf = (unsigned char *) malloc((unsigned int) dir_len * MSECTOR_SIZE);
X	if (dir_buf == NULL) {
X		perror("reset_chain: malloc");
X		exit(1);
X	}
X	disk_read((long) dir_start, dir_buf, dir_len * MSECTOR_SIZE);
X
X	dir_entries = dir_len * 16;
X	return;
X}
X
X/*
X * Get rid of spaces in an MSDOS 'raw' name (one that has come from the
X * directory structure) so that it can be used for regular expression
X * matching with a unix filename.  Also used to 'unfix' a name that has
X * been altered by dos_name().  Returns a pointer a static buffer.
X */
X
Xchar *
Xunix_name(name, ext)
Xunsigned char *name, *ext;
X{
X	char *s, tname[9], text[4], *strcpy(), *strcat(), *strchr();
X	char *strncpy();
X	static char ans[13];
X
X	strncpy(tname, (char *) name, 8);
X	tname[8] = '\0';
X	if (s = strchr(tname, ' '))
X		*s = '\0';
X
X	strncpy(text, (char *) ext, 3);
X	text[3] = '\0';
X	if (s = strchr(text, ' '))
X		*s = '\0';
X
X	if (*text) {
X		strcpy(ans, tname);
X		strcat(ans, ".");
X		strcat(ans, text);
X	}
X	else
X		strcpy(ans, tname);
X	return(ans);
X}
END_OF_FILE
if test 3300 -ne `wc -c <'mtools/dir_read.c'`; then
    echo shar: \"'mtools/dir_read.c'\" unpacked with wrong size!
fi
# end of 'mtools/dir_read.c'
fi
if test -f 'mtools/dir_write.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/dir_write.c'\"
else
echo shar: Extracting \"'mtools/dir_write.c'\" \(4191 characters\)
sed "s/^X//" >'mtools/dir_write.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <time.h>
X#include <ctype.h>
X#include "msdos.h"
X
Xextern int fd, dir_dirty, clus_size, dir_entries;
Xextern long dir_chain[MAX_DIR_SECS];
Xextern unsigned char *dir_buf;
X
X/*
X * Write a directory entry.  A simple cache is used instead of something
X * more elaborate.
X */
X
Xvoid
Xdir_write(num, dir)
Xint num;
Xstruct directory *dir;
X{
X	unsigned char *offset;
X	char *memcpy();
X
X	offset = dir_buf + (num * MDIR_SIZE);
X	memcpy((char *) offset, (char *) dir, MDIR_SIZE);
X	dir_dirty = 1;
X	return;
X}
X
X/*
X * Write a partially filled directory buffer to disk.  Resets dir_dirty to
X * zero.
X */
X
Xvoid
Xdir_flush()
X{
X	int i, length;
X	unsigned char *offset;
X	void disk_write();
X
X	if (fd < 0 || !dir_dirty)
X		return;
X
X	length = dir_entries / 16;
X	for (i = 0; i < length; i++) {
X		offset = dir_buf + (i * MSECTOR_SIZE);
X		disk_write(dir_chain[i], offset, MSECTOR_SIZE);
X	}
X	dir_dirty = 0;
X	return;
X}
X
X/*
X * Convert a Unix filename to a legal MSDOS name.  Returns a pointer to
X * a static area.  Will truncate file and extension names, will
X * substitute the letter 'X' for any illegal character in the name.
X */
X
Xunsigned char *
Xdos_name(filename, verbose)
Xchar *filename;
Xint verbose;
X{
X	static char *dev[9] = {"CON", "AUX", "COM1", "COM2", "PRN", "LPT1",
X	"LPT2", "LPT3", "NUL"};
X	char *s, buf[MAX_PATH], *name, *ext, *strcpy(), *strpbrk(), *strrchr();
X	static unsigned char ans[13];
X	int dot, modified, len;
X	register int i;
X
X	strcpy(buf, filename);
X	name = buf;
X					/* skip drive letter */
X	if (buf[0] && buf[1] == ':')
X		name = &buf[2];
X					/* zap the leading path */
X	if (s = strrchr(name, '/'))
X		name = s + 1;
X	if (s = strrchr(name, '\\'))
X		name = s + 1;
X
X	ext = "";
X	dot = 0;
X	len = strlen(name);
X	for (i = 0; i < len; i++) {
X		s = name + len -i -1;
X		if (*s == '.' && !dot) {
X			dot = 1;
X			*s = '\0';
X			ext = s +1;
X		}
X		if (islower(*s))
X			*s = toupper(*s);
X	}
X	if (*name == '\0') {
X		name = "X";
X		if (verbose)
X			printf("\"%s\" Null name component, using \"%s.%s\"\n", filename, name, ext);
X	}
X	for (i = 0; i < 9; i++) {
X		if (!strcmp(name, dev[i])) {
X			*name = 'X';
X			if (verbose)
X				printf("\"%s\" Is a device name, using \"%s.%s\"\n", filename, name, ext);
X		}
X	}
X	if (strlen(name) > 8) {
X		*(name + 8) = '\0';
X		if (verbose)
X			printf("\"%s\" Name too long, using, \"%s.%s\"\n", filename, name, ext);
X	}
X	if (strlen(ext) > 3) {
X		*(ext + 3) = '\0';
X		if (verbose)
X			printf("\"%s\" Extension too long, using \"%s.%s\"\n", filename, name, ext);
X	}
X	modified = 0;
X	while (s = strpbrk(name, "^+=/[]:',?*\\<>|\". ")) {
X		modified++;
X		*s = 'X';
X	}
X	while (s = strpbrk(ext, "^+=/[]:',?*\\<>|\". ")) {
X		modified++;
X		*s = 'X';
X	}
X	if (modified && verbose)
X		printf("\"%s\" Contains illegal character(s), using \"%s.%s\"\n", filename, name, ext);
X
X	sprintf((char *) ans, "%-8.8s%-3.3s", name, ext);
X	return(ans);
X}
X
X/*
X * Make a directory entry.  Builds a directory entry based on the
X * name, attribute, starting cluster number, and size.  Returns a pointer
X * to a static directory structure.
X */
X
Xstruct directory *
Xmk_entry(filename, attr, fat, size, date)
Xunsigned char *filename;
Xunsigned char attr;
Xunsigned int fat;
Xlong size, date;
X{
X	int i;
X	char *strncpy();
X	static struct directory ndir;
X	struct tm *now, *localtime();
X	unsigned char hour, min_hi, min_low, sec;
X	unsigned char year, month_hi, month_low, day;
X
X	now = localtime(&date);
X	strncpy((char *) ndir.name, (char *) filename, 8);
X	strncpy((char *) ndir.ext, (char *) filename + 8, 3);
X	ndir.attr = attr;
X	for (i = 0; i < 10; i++)
X		ndir.reserved[i] = '\0';
X	hour = now->tm_hour << 3;
X	min_hi = now->tm_min >> 3;
X	min_low = now->tm_min << 5;
X	sec = now->tm_sec / 2;
X	ndir.time[1] = hour + min_hi;
X	ndir.time[0] = min_low + sec;
X	year = (now->tm_year - 80) << 1;
X	month_hi = (now->tm_mon + 1) >> 3;
X	month_low = (now->tm_mon + 1) << 5;
X	day = now->tm_mday;
X	ndir.date[1] = year + month_hi;
X	ndir.date[0] = month_low + day;
X	ndir.start[1] = fat / 0x100;
X	ndir.start[0] = fat % 0x100;
X	ndir.size[3] = size / 0x1000000L;
X	ndir.size[2] = (size % 0x1000000L) / 0x10000L;
X	ndir.size[1] = ((size % 0x1000000L) % 0x10000L) / 0x100;
X	ndir.size[0] = ((size % 0x1000000L) % 0x10000L) % 0x100;
X	return(&ndir);
X}
END_OF_FILE
if test 4191 -ne `wc -c <'mtools/dir_write.c'`; then
    echo shar: \"'mtools/dir_write.c'\" unpacked with wrong size!
fi
# end of 'mtools/dir_write.c'
fi
if test -f 'mtools/mattrib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/mattrib.c'\"
else
echo shar: Extracting \"'mtools/mattrib.c'\" \(3434 characters\)
sed "s/^X//" >'mtools/mattrib.c' <<'END_OF_FILE'
X/*
X * Change MSDOS file attribute flags
X *
X * Emmet P. Gray			US Army, HQ III Corps & Fort Hood
X * ...!uunet!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV
X * fthood!egray@uxc.cso.uiuc.edu	Directorate of Engineering & Housing
X * 					Environmental Management Office
X * 					Fort Hood, TX 76544-5057
X */
X
X#include <stdio.h>
X#include "msdos.h"
X#include "patchlevel.h"
X
Xint fd = -1;				/* the file descriptor for the device */
Xint dir_start;				/* starting sector for directory */
Xint dir_len;				/* length of directory (in sectors) */
Xint dir_entries;			/* number of directory entries */
Xint clus_size;				/* cluster size (in sectors) */
Xchar *mcwd;				/* the Current Working Directory */
Xint fat_error;				/* FAT error detected? */
X
X#define ADD	1
X#define REMOVE	(-1)
X#define LEAVE	0
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int entry, ismatch, oops, fargn, read_only, hidden, sys, archive;
X	int i, action;
X	char *filename, *newfile, *unix_name(), drive, get_drive();
X	char *get_path(), *pathname, *get_name(), *fix_mcwd(), last_drive;
X	void exit(), dir_write(), dir_flush(), disk_flush();
X	struct directory *dir, *dir_read();
X
X	oops = 0;
X	fargn = -1;
X	archive = LEAVE;
X	hidden = LEAVE;
X	read_only = LEAVE;
X	sys = LEAVE;
X					/* can't use getopt(3)... */
X	for (i = 1; i < argc; i++) {
X		switch (argv[i][0]) {
X			case '-':
X				action = REMOVE;
X				break;
X			case '+':
X				action = ADD;
X				break;
X			default:
X				fargn = i;
X				break;
X		}
X		if (fargn != -1)
X			break;
X
X		switch (argv[i][1]) {
X			case 'a':
X			case 'A':
X				archive = action;
X				break;
X			case 'h':
X			case 'H':
X				hidden = action;
X				break;
X			case 'r':
X			case 'R':
X				read_only = action;
X				break;
X			case 's':
X			case 'S':
X				sys = action;
X				break;
X			default:
X				oops++;
X				break;
X		}
X		if (oops)
X			break;
X	}
X	if (argc < 3 || argv[fargn][0] == '\0' || oops) {
X		fprintf(stderr, "Mtools version %s, dated %s\n", VERSION, DATE);
X		fprintf(stderr, "Usage: %s [-a|+a] [-h|+h] [-r|+r] [-s|+s] msdosfile [msdosfiles...]\n", argv[0]);
X		exit(1);
X	}
X	last_drive = 'x';
X	mcwd = fix_mcwd();
X
X	for (i = fargn; i < argc; i++) {
X		drive = get_drive(argv[i]);
X		if (last_drive != drive) {
X			if (init(drive, 2)) {
X				fprintf(stderr, "%s: Cannot initialize '%c:'\n", argv[0], drive);
X				continue;
X			}
X			last_drive = drive;
X		}
X		filename = get_name(argv[i]);
X		pathname = get_path(argv[i]);
X		if (subdir(drive, pathname))
X			continue;
X
X					/* see if exists and do it */
X		ismatch = 0;
X		for (entry = 0; entry < dir_entries; entry++) {
X			dir = dir_read(entry);
X					/* if empty */
X			if (dir->name[0] == 0x0)
X				break;
X					/* if erased */
X			if (dir->name[0] == 0xe5)
X				continue;
X					/* if dir or volume label */
X			if ((dir->attr & 0x10) || (dir->attr & 0x08))
X				continue;
X
X			newfile = unix_name(dir->name, dir->ext);
X
X					/* do it... */
X			if (match(newfile, filename)) {
X				if (archive == ADD)
X					dir->attr |= 0x20;
X				if (archive == REMOVE)
X					dir->attr &= ~0x20;
X				if (hidden == ADD)
X					dir->attr |= 0x02;
X				if (hidden == REMOVE)
X					dir->attr &= ~0x02;
X				if (read_only == ADD)
X					dir->attr |= 0x01;
X				if (read_only == REMOVE)
X					dir->attr &= ~0x01;
X				if (sys == ADD)
X					dir->attr |= 0x04;
X				if (sys == REMOVE)
X					dir->attr &= ~0x04;
X				dir_write(entry, dir);
X				ismatch++;
X			}
X		}
X		if (!ismatch)
X			fprintf(stderr, "%s: File \"%s\" not found\n", argv[0], filename);
X	}
X	dir_flush();
X	disk_flush();
X	close(fd);
X	exit(0);
X}
END_OF_FILE
if test 3434 -ne `wc -c <'mtools/mattrib.c'`; then
    echo shar: \"'mtools/mattrib.c'\" unpacked with wrong size!
fi
# end of 'mtools/mattrib.c'
fi
if test -f 'mtools/mcd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/mcd.c'\"
else
echo shar: Extracting \"'mtools/mcd.c'\" \(2639 characters\)
sed "s/^X//" >'mtools/mcd.c' <<'END_OF_FILE'
X/*
X * Change MSDOS directories
X *
X * Emmet P. Gray			US Army, HQ III Corps & Fort Hood
X * ...!uunet!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV
X * fthood!egray@uxc.cso.uiuc.edu	Directorate of Engineering & Housing
X * 					Environmental Management Office
X * 					Fort Hood, TX 76544-5057
X */
X
X#include <stdio.h>
X#include "msdos.h"
X#include "patchlevel.h"
X
Xint fd = -1;				/* the file descriptor for the device */
Xint dir_start;				/* starting sector for directory */
Xint dir_len;				/* length of directory (in sectors) */
Xint dir_entries;			/* number of directory entries */
Xint clus_size;				/* cluster size (in sectors) */
Xchar *mcwd;				/* the Current Working Directory */
Xint fat_error;				/* FAT error detected? */
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	FILE *fp;
X	char *fix_mcwd(), *strcpy(), newpath[MAX_PATH], *get_name();
X	char *get_path(), *pathname, *filename, drive, *strcat();
X	char get_drive(), *mcwd_path, *getenv(), *expand();
X	void exit();
X
X	if (argc > 2) {
X		fprintf(stderr, "Mtools version %s, dated %s\n", VERSION, DATE);
X		fprintf(stderr, "Usage: %s: msdosdirectory\n", argv[0]);
X		exit(1);
X	}
X					/* only report the mcwd */
X	mcwd = fix_mcwd();
X	if (argc == 1) {
X		printf("%s\n", mcwd);
X		exit(0);
X	}
X
X	drive = get_drive(argv[1]);
X	filename = get_name(argv[1]);
X	pathname = get_path(argv[1]);
X
X	if (init(drive, 0)) {
X		fprintf(stderr, "%s: Cannot initialize '%c:'\n", argv[0], drive);
X		exit(1);
X	}
X
X	/*
X	 * Move to "first guess" subdirectory, so that is_dir() can
X	 * search to see if filename is also a directory.
X	 */
X	if (subdir(drive, pathname)) {
X		fprintf(stderr, "%s: Directory not found\n", argv[0]);
X		exit(1);
X	}
X					/* is filename really a subdirectory? */
X	strcpy(newpath, pathname);
X	if (is_dir(filename)) {
X		if (newpath[strlen(newpath) -1] != '/')
X			strcat(newpath, "/");
X		strcat(newpath, filename);
X
X					/* move to real subdirectory */
X		if (subdir(drive, newpath)) {
X			fprintf(stderr, "%s: Directory not found\n", argv[0]);
X			exit(1);
X		}
X	}
X	else {
X		if (*filename != '\0') {
X			fprintf(stderr, "%s: Directory not found\n", argv[0]);
X			exit(1);
X		}
X	}
X					/* it checked out ok, so save it */
X	mcwd_path = getenv("MCWD");
X	if (mcwd_path == NULL || *mcwd_path == '\0')
X		mcwd_path = "$HOME/.mcwd";
X
X	if (!(fp = fopen(expand(mcwd_path), "w"))) {
X		fprintf(stderr, "%s: Can't open '%s' for write\n", argv[0], expand(mcwd_path));
X		exit(1);
X	}
X	fprintf(fp, "%c:%s\n", drive, newpath);
X	fclose(fp);
X	exit(0);
X}
X
X/*
X * stubs for read-only programs
X */
X
Xvoid
Xdisk_flush()
X{
X	extern int disk_dirty;
X
X	disk_dirty = 0;
X	return;
X}
X
Xvoid
Xdir_flush()
X{
X	extern int dir_dirty;
X
X	dir_dirty = 0;
X	return;
X}
END_OF_FILE
if test 2639 -ne `wc -c <'mtools/mcd.c'`; then
    echo shar: \"'mtools/mcd.c'\" unpacked with wrong size!
fi
# end of 'mtools/mcd.c'
fi
if test -f 'mtools/mcopy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/mcopy.c'\"
else
echo shar: Extracting \"'mtools/mcopy.c'\" \(4332 characters\)
sed "s/^X//" >'mtools/mcopy.c' <<'END_OF_FILE'
X/*
X * A front-end to the mread/mwrite commands.
X *
X * Emmet P. Gray			US Army, HQ III Corps & Fort Hood
X * ...!uunet!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV
X * fthood!egray@uxc.cso.uiuc.edu	Directorate of Engineering & Housing
X * 					Environmental Management Office
X * 					Fort Hood, TX 76544-5057
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "patchlevel.h"
X
X#define NONE	0
X#define MREAD	1
X#define MWRITE	2
X#define MKDIR
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	extern int optind;
X	extern char *optarg;
X	int i, oops, msdos_args, unix_args, destination;
X	char **nargv, **malloc();
X	void exit();
X					/* get command line options */
X	msdos_args = 0;
X	unix_args = 0;
X	oops = 0;
X	while ((i = getopt(argc, argv, "tnvm")) != EOF) {
X		switch (i) {
X			case 't':
X			case 'n':
X			case 'v':
X			case 'm':
X				break;
X			default:
X				oops = 1;
X				break;
X		}
X	}
X
X	if (oops || (argc - optind) < 2) {
X		fprintf(stderr, "Mtools version %s, dated %s\n", VERSION, DATE);
X		fprintf(stderr, "Usage: %s [-tnvm] sourcefile targetfile\n", argv[0]);
X		fprintf(stderr, "       %s [-tnvm] sourcefile [sourcefiles...] targetdirectory\n", argv[0]);
X		exit(1);
X	}
X					/* last file determines the direction */
X	if (argv[argc - 1][1] == ':')
X		destination = MWRITE;
X	else
X		destination = MREAD;
X
X					/* count the arguments */
X	for (i = optind; i < argc; i++) {
X		if (argv[i][1] == ':')
X			msdos_args++;
X		else
X			unix_args++;
X	}
X
X	if (destination == MREAD && unix_args > 1) {
X		fprintf(stderr, "%s: Duplicate destination files\n", argv[0]); 
X		exit(1);
X	}
X					/* chaining of mread and mwrite */
X	if (destination == MWRITE && msdos_args > 1)
X		chain(argc, argv);
X
X	/*
X	 * Copy the *argv[] array in case your Unix doesn't end the array
X	 * with a null when it passes it to main()
X	 */
X	nargv = (char **) malloc((unsigned int) (argc + 1) * sizeof(*argv));
X	nargv[0] = "mcopy";
X	for (i = 1; i < argc; i++)
X		nargv[i] = argv[i];
X	nargv[argc] = NULL;
X
X	if (destination == MWRITE)
X		execvp("mwrite", nargv);
X	else
X		execvp("mread", nargv);
X}
X
Xchain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	extern int optind;
X	int i, j, pid, status;
X	char *tmpdir, *mktemp(), **nargv, **malloc(), buf[256], *strcpy();
X	char *unixname(), *realloc();
X	void exit();
X
X	nargv = (char **) malloc((unsigned int) (argc + 4) * sizeof(*argv));
X	nargv[0] = "mread";
X	nargv[1] = "-n";
X					/* copy only the msdos arguments */
X	j = 2;
X	for (i = optind; i < argc -1; i++) {
X		if (argv[i][1] == ':')
X			nargv[j++] = argv[i];
X	}
X					/* create a temp directory */
X	tmpdir = mktemp("/tmp/mtoolsXXXXXX");
X	if (mkdir(tmpdir, 0777) < 0)
X		perror("mkdir");
X
X	nargv[j++] = tmpdir;
X	nargv[j] = NULL;
X
X	printf("reading...\n");
X	if (!(pid = fork()))
X		execvp("mread", nargv);
X
X	while (wait(&status) != pid)
X		;
X					/* reconstruct the argv[] */
X	nargv[0] = "sh";
X	nargv[1] = "-c";
X	nargv[2] = (char *) malloc(7);
X	strcpy(nargv[2], "mwrite");
X
X	j = 3;
X	for (i = 1; i < argc -1; i++) {
X		/*
X		 * Substitute the msdos arguments for their unix
X		 * counterparts that have already been copied to tmpdir.
X		 */
X		if (argv[i][1] == ':')
X			sprintf(buf, "%s/%s", tmpdir, unixname(argv[i]));
X		else
X			strcpy(buf, argv[i]);
X
X		nargv[2] = (char *) realloc(nargv[2], sizeof(nargv[2]) + sizeof(buf));
X		strcat(nargv[2], " ");
X		strcat(nargv[2], buf);
X	}
X					/* protect last arg from expansion */
X	sprintf(buf, "'%s'", argv[i]);
X	nargv[2] = (char *) realloc(nargv[2], sizeof(nargv[2]) + sizeof(buf));
X	strcat(nargv[2], " ");
X	strcat(nargv[2], buf);
X
X	nargv[3] = NULL;
X
X	printf("writing...\n");
X	if (!(pid = fork()))
X		execvp("sh", nargv);
X
X	while (wait(&status) != pid)
X		;
X					/* clobber the directory */
X	sprintf(buf, "rm -fr %s", tmpdir);
X	system(buf);
X	exit(0);
X}
X
Xchar *
Xunixname(filename)
Xchar *filename;
X{
X	char *s, *temp, *strcpy(), *strrchr(), buf[256];
X	static char ans[13];
X
X	strcpy(buf, filename);
X	temp = buf;
X					/* skip drive letter */
X	if (buf[0] && buf[1] == ':')
X		temp = &buf[2];
X					/* find the last separator */
X	if (s = strrchr(temp, '/'))
X		temp = s + 1;
X	if (s = strrchr(temp, '\\'))
X		temp = s + 1;
X					/* xlate to lower case */
X	for (s = temp; *s; ++s) {
X		if (isupper(*s))
X			*s = tolower(*s);
X	}
X
X	strcpy(ans, temp);
X	return(ans);
X}
X
X#ifdef MKDIR
Xmkdir(path, mode)
Xchar *path;
Xint mode;
X{
X	char buf[256];
X	sprintf(buf, "mkdir %s", path);
X	return(system(buf));
X}
X#endif /* MKDIR */
END_OF_FILE
if test 4332 -ne `wc -c <'mtools/mcopy.c'`; then
    echo shar: \"'mtools/mcopy.c'\" unpacked with wrong size!
fi
# end of 'mtools/mcopy.c'
fi
if test -f 'mtools/mdel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/mdel.c'\"
else
echo shar: Extracting \"'mtools/mdel.c'\" \(3601 characters\)
sed "s/^X//" >'mtools/mdel.c' <<'END_OF_FILE'
X/*
X * Delete an MSDOS file
X *
X * Emmet P. Gray			US Army, HQ III Corps & Fort Hood
X * ...!uunet!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV
X * fthood!egray@uxc.cso.uiuc.edu	Directorate of Engineering & Housing
X * 					Environmental Management Office
X * 					Fort Hood, TX 76544-5057
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include "msdos.h"
X#include "patchlevel.h"
X
Xint fd = -1;				/* the file descriptor for the device */
Xint dir_start;				/* starting sector for directory */
Xint dir_len;				/* length of directory (in sectors) */
Xint dir_entries;			/* number of directory entries */
Xint clus_size;				/* cluster size (in sectors) */
Xchar *mcwd;				/* the Current Working Directory */
Xint fat_error;				/* FAT error detected? */
X
Xstatic int got_signal();
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int i, ismatch, entry, nogo, verbose, fargn;
X	unsigned int start;
X	char *filename, *newfile, *get_name(), *unix_name(), *get_path();
X	char *pathname, ans[10], drive, get_drive(), last_drive, *fix_mcwd();
X	void exit(), fat_write(), dir_write(), dir_flush(), disk_flush();
X	struct directory *dir, *dir_read();
X					/* catch signals */
X	signal(SIGINT, (SIG_TYPE(*) ()) got_signal);
X	signal(SIGTERM, (SIG_TYPE(*) ()) got_signal);
X	signal(SIGQUIT, (SIG_TYPE(*) ()) got_signal);
X
X	if (argc > 1 && !strcmp(argv[1], "-v")) {
X		verbose = 1;
X		fargn = 2;
X	}
X	else {
X		verbose = 0;
X		fargn = 1;
X	}
X	if (argc < 2 || (argv[1][0] == '-' && !verbose)) {
X		fprintf(stderr, "Mtools version %s, dated %s\n", VERSION, DATE);
X		fprintf(stderr, "Usage: %s [-v] msdosfile [msdosfiles...]\n", argv[0]);
X		exit(1);
X	}
X	last_drive = 'x';
X	mcwd = fix_mcwd();
X
X	for (i = fargn; i < argc; i++) {
X		drive = get_drive(argv[i]);
X		if (drive != last_drive) {
X			if (last_drive != 'x') {
X				fat_write();
X				dir_flush();
X				disk_flush();
X			}
X
X			if (init(drive, 2)) {
X				fprintf(stderr, "%s: Cannot initialize '%c:'\n", argv[0], drive);
X				continue;
X			}
X			last_drive = drive;
X		}
X		filename = get_name(argv[i]);
X		pathname = get_path(argv[i]);
X		if (subdir(drive, pathname))
X			continue;
X
X		nogo = 0;
X		ismatch = 0;
X		for (entry = 0; entry < dir_entries; entry++) {
X			dir = dir_read(entry);
X					/* if empty */
X			if (dir->name[0] == 0x0)
X				break;
X					/* if erased */
X			if (dir->name[0] == 0xe5)
X				continue;
X					/* if dir or volume label */
X			if ((dir->attr & 0x10) || (dir->attr & 0x08))
X				continue;
X
X			newfile = unix_name(dir->name, dir->ext);
X					/* see it if matches the pattern */
X			if (match(newfile, filename)) {
X				if (verbose)
X					printf("Removing %s\n", newfile);
X				ismatch = 1;
X				if (dir->attr & 0x01) {
X					while (!nogo) {
X						printf("%s: \"%s\" is read only, erase anyway (y/n) ? ", argv[0], newfile);
X						gets(ans);
X						if (ans[0] == 'y' || ans[0] == 'Y')
X							break;
X						if (ans[0] == 'n' || ans[0] == 'N')
X							nogo = 1;
X					}
X					if (nogo)
X						continue;
X				}
X				start = dir->start[1] * 0x100 + dir->start[0];
X				if (fat_free(start))
X					break;
X				dir->name[0] = 0xe5;
X				dir_write(entry, dir);
X			}
X		}
X		if (fat_error)
X			break;
X
X		if (!ismatch)
X			fprintf(stderr, "%s: File \"%s\" not found\n", argv[0], filename);
X	}
X					/* write the FAT, flush the buffers */
X	fat_write();
X	dir_flush();
X	disk_flush();
X	close(fd);
X	exit(0);
X}
X
X/*
X * Do a graceful exit if the program is interrupted.  This will reduce
X * (but not eliminate) the risk of generating a corrupted disk on
X * a user abort.
X */
X
Xstatic int
Xgot_signal()
X{
X	void exit(), disk_flush(), fat_write(), dir_flush();
X
X	if (fd < 0)
X		exit(1);
X	fat_write();
X	dir_flush();
X	disk_flush();
X	close(fd);
X	exit(1);
X}
END_OF_FILE
if test 3601 -ne `wc -c <'mtools/mdel.c'`; then
    echo shar: \"'mtools/mdel.c'\" unpacked with wrong size!
fi
# end of 'mtools/mdel.c'
fi
if test -f 'mtools/mformat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/mformat.c'\"
else
echo shar: Extracting \"'mtools/mformat.c'\" \(6144 characters\)
sed "s/^X//" >'mtools/mformat.c' <<'END_OF_FILE'
X/*
X * Add an MSDOS filesystem to a low level formatted diskette.
X *
X * Emmet P. Gray			US Army, HQ III Corps & Fort Hood
X * ...!uunet!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV
X * fthood!egray@uxc.cso.uiuc.edu	Directorate of Engineering & Housing
X * 					Environmental Management Office
X * 					Fort Hood, TX 76544-5057
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "msdos.h"
X#include "patchlevel.h"
X
Xint fd, dir_dirty, dir_entries;
Xlong dir_chain[MAX_DIR_SECS];
Xunsigned char *dir_buf;
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	extern int optind;
X	extern char *optarg;
X	extern struct device devices[];
X	struct bootsector boot;
X	int i, c, oops, tracks, heads, sectors, fat_len, dir_len, clus_size;
X	int tot_sectors, num_clus, fat_guess;
X	long time(), now, lseek();
X	char drive, *name, *expand();
X	char *strncpy(), *memset(), *memcpy();
X	unsigned char media, label[12], buf[MSECTOR_SIZE];
X	struct device *dev;
X	struct directory *dir, *mk_entry();
X	void exit(), perror();
X
X	oops = 0;
X	tracks = 0;
X	heads = 0;
X	sectors = 0;
X	label[0] = '\0';
X					/* get command line options */
X	while ((c = getopt(argc, argv, "t:h:s:l:")) != EOF) {
X		switch (c) {
X			case 't':
X				tracks = atoi(optarg);
X				break;
X			case 'h':
X				heads = atoi(optarg);
X				break;
X			case 's':
X				sectors = atoi(optarg);
X				break;
X			case 'l':
X				sprintf((char *) label, "%-11.11s", optarg);
X				break;
X			default:
X				oops = 1;
X				break;
X		}
X	}
X
X	if (oops || (argc - optind) != 1) {
X		fprintf(stderr, "Mtools version %s, dated %s\n", VERSION, DATE);
X		fprintf(stderr, "Usage: %s [-t tracks] [-h heads] [-s sectors] [-l label] device\n", argv[0]);
X		exit(1);
X	}
X
X	drive = argv[argc -1][0];
X	if (islower(drive))
X		drive = toupper(drive);
X
X					/* check out the drive letter */
X	dev = devices;
X	while (dev->drive) {
X		if (dev->drive == drive)
X			break;
X		dev++;
X	}
X	if (!dev->drive) {
X		fprintf(stderr, "Drive '%c:' not supported\n", drive);
X		exit(1);
X	}
X	if (dev->tracks == 0) {
X		fprintf(stderr, "Non-removable media is not supported\n");
X		exit(1);
X	}
X					/* find the right one */
X	if (!dev->gioctl) {
X		while (dev->drive == drive) {
X			if ((!tracks || dev->tracks == tracks) && (!heads || dev->heads == heads) && (!sectors || dev->sectors == sectors))
X				break;
X			dev++;
X		}
X	}
X	if (dev->drive != drive) {
X		fprintf(stderr, "%s: Paramaters not supported\n", argv[0]);
X		exit(1);
X	}
X					/* open the device */
X	name = expand(dev->name);
X	if ((fd = open(name, 2 | dev->mode)) < 0) {
X		perror("init: open");
X		exit(1);
X	}
X					/* fill in the blanks */
X	if (!tracks)
X		tracks = dev->tracks;
X	if (!heads)
X		heads = dev->heads;
X	if (!sectors)
X		sectors = dev->sectors;
X
X					/* set parameters, if needed */
X	if (dev->gioctl) {
X		if ((*(dev->gioctl)) (fd, tracks, heads, sectors))
X			exit(1);
X	}
X					/* do a "test" read */
X	if (read(fd, (char *) buf, MSECTOR_SIZE) != MSECTOR_SIZE) {
X		fprintf(stderr, "%s: Error reading from '%s', wrong parameters?\n", argv[0], name);
X		exit(1);
X	}
X					/* get the parameters */
X	tot_sectors = tracks * heads * sectors;
X	switch (tot_sectors) {
X		case 320:		/* 40t * 1h * 8s = 160k */
X			media = 0xfe;
X			clus_size = 1;
X			dir_len = 4;
X			fat_len = 1;
X			break;
X		case 360:		/* 40t * 1h * 9s = 180k */
X			media = 0xfc;
X			clus_size = 1;
X			dir_len = 4;
X			fat_len = 2;
X			break;
X		case 640:		/* 40t * 2h * 8s = 320k */
X			media = 0xff;
X			clus_size = 2;
X			dir_len = 7;
X			fat_len = 1;
X			break;
X		case 720:		/* 40t * 2h * 9s = 360k */
X			media = 0xfd;
X			clus_size = 2;
X			dir_len = 7;
X			fat_len = 2;
X			break;
X		case 1440:		/* 80t * 2h * 9s = 720k */
X			media = 0xf9;
X			clus_size = 2;
X			dir_len = 7;
X			fat_len = 3;
X			break;
X		case 2400:		/* 80t * 2h * 15s = 1.2m */
X			media = 0xf9;
X			clus_size = 1;
X			dir_len = 14;
X			fat_len = 7;
X			break;
X		case 2880:		/* 80t * 2h * 18s = 1.44m */
X			media = 0xf0;
X			clus_size = 1;
X			dir_len = 14;
X			fat_len = 9;
X			break;
X		default:		/* a non-standard format */
X			media = 0xf0;
X			if (heads == 1)
X				clus_size = 1;
X			else
X				clus_size = (tot_sectors > 2000) ? 1 : 2;
X			if (heads == 1)
X				dir_len = 4;
X			else
X				dir_len = (tot_sectors > 2000) ? 14 : 7;
X			/*
X			 * Estimate the fat length, then figure it out.  The
X			 * 341 is the number of 12 bit fat entries in a sector.
X			 */
X			fat_guess = ((tot_sectors / clus_size) / 341.0) + 0.95;
X			num_clus = (tot_sectors -dir_len - (2 * fat_guess) -1) / clus_size;
X			fat_len = (num_clus / 341.0) + 1;
X			break;
X	}
X					/* the boot sector */
X	memset((char *) &boot, '\0', MSECTOR_SIZE);
X	boot.jump[0] = 0xeb;
X	boot.jump[1] = 0x44;
X	boot.jump[2] = 0x90;
X	strncpy((char *) boot.banner, "Mtools  ", 8);
X	boot.secsiz[0] = 512 % 0x100;
X	boot.secsiz[1] = 512 / 0x100;
X	boot.clsiz = (unsigned char) clus_size;
X	boot.nrsvsect[0] = 1;
X	boot.nrsvsect[1] = 0;
X	boot.nfat = 2;
X	boot.dirents[0] = (dir_len * 16) % 0x100;
X	boot.dirents[1] = (dir_len * 16) / 0x100;
X	boot.psect[0] = tot_sectors % 0x100;
X	boot.psect[1] = tot_sectors / 0x100;
X	boot.descr = media;
X	boot.fatlen[0] = fat_len % 0x100;
X	boot.fatlen[1] = fat_len / 0x100;
X	boot.nsect[0] = sectors % 0x100;
X	boot.nsect[1] = sectors / 0x100;
X	boot.nheads[0] = heads % 0x100;
X	boot.nheads[1] = heads / 0x100;
X
X					/* write the boot */
X	lseek(fd, 0L, 0);
X	write(fd, (char *) &boot, MSECTOR_SIZE);
X					/* first fat */
X	memset((char *) buf, '\0', MSECTOR_SIZE);
X	buf[0] = media;
X	buf[1] = 0xff;
X	buf[2] = 0xff;
X	write(fd, (char *) buf, MSECTOR_SIZE);
X	memset((char *) buf, '\0', MSECTOR_SIZE);
X	for (i = 1; i < fat_len; i++)
X		write(fd, (char *) buf, MSECTOR_SIZE);
X					/* second fat */
X	buf[0] = media;
X	buf[1] = 0xff;
X	buf[2] = 0xff;
X	write(fd, (char *) buf, MSECTOR_SIZE);
X	memset((char *) buf, '\0', MSECTOR_SIZE);
X	for (i = 1; i < fat_len; i++)
X		write(fd, (char *) buf, MSECTOR_SIZE);
X					/* the root directory */
X	if (label[0] != '\0') {
X		time(&now);
X		dir = mk_entry(label, 0x08, 0, 0L, now);
X		memcpy((char *) buf, (char *) dir, MDIR_SIZE);
X	}
X	write(fd, (char *) buf, MSECTOR_SIZE);
X	memset((char *) buf, '\0', MSECTOR_SIZE);
X	for (i = 1; i < dir_len; i++)
X		write(fd, (char *) buf, MSECTOR_SIZE);
X	close(fd);
X	exit(0);
X}
X
X/* hooks for the missing parts */
Xvoid disk_write() {}
END_OF_FILE
if test 6144 -ne `wc -c <'mtools/mformat.c'`; then
    echo shar: \"'mtools/mformat.c'\" unpacked with wrong size!
fi
# end of 'mtools/mformat.c'
fi
if test -f 'mtools/mlabel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/mlabel.c'\"
else
echo shar: Extracting \"'mtools/mlabel.c'\" \(3079 characters\)
sed "s/^X//" >'mtools/mlabel.c' <<'END_OF_FILE'
X/*
X * Make an MSDOS volume label
X *
X * Emmet P. Gray			US Army, HQ III Corps & Fort Hood
X * ...!uunet!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV
X * fthood!egray@uxc.cso.uiuc.edu	Directorate of Engineering & Housing
X * 					Environmental Management Office
X * 					Fort Hood, TX 76544-5057
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "msdos.h"
X#include "patchlevel.h"
X
Xint fd = -1;				/* the file descriptor for the device */
Xint dir_start;				/* starting sector for directory */
Xint dir_len;				/* length of directory (in sectors) */
Xint dir_entries;			/* number of directory entries */
Xint clus_size;				/* cluster size (in sectors) */
Xchar *mcwd;				/* the Current Working Directory */
Xint fat_error;				/* FAT error detected? */
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int entry, slot, fargn, verbose, oops;
X	char filename[30], *strncpy(), drive, ans[10], *strncat();
X	char *strcpy(), *fix_mcwd();
X	unsigned char fixed[12], vol[12];
X	void exit(), dir_write(), dir_flush(), disk_flush();
X	struct directory *dir, *dir_read(), *mk_entry();
X	long time(), now;
X
X	fargn = 1;
X	verbose = 0;
X	oops = 0;
X	if (argc > 1) {
X		if (!strcmp(argv[1], "-v")) {
X			fargn = 2;
X			verbose = 1;
X		}
X		if (argv[1][0] == '-' && !verbose)
X			oops++;
X	}
X	if (argc < 2 || argv[fargn][1] != ':' || oops) {
X		fprintf(stderr, "Mtools version %s, dated %s\n", VERSION, DATE);
X		fprintf(stderr, "Usage: %s [-v] drive:\n", argv[0]);
X		exit(1);
X	}
X	mcwd = fix_mcwd();
X
X	drive = argv[fargn][0];
X	if (islower(drive))
X		drive = toupper(drive);
X
X	if (init(drive, 2)) {
X		fprintf(stderr, "%s: Cannot initialize '%c:'\n", argv[0], drive);
X		exit(1);
X	}
X					/* see if a label exists and get slot */
X	slot = -1;
X	vol[0] = '\0';
X	for (entry = 0; entry < dir_entries; entry++) {
X		dir = dir_read(entry);
X					/* if empty */
X		if (dir->name[0] == 0x0) {
X			if (slot < 0)
X				slot = entry;
X			break;
X		}
X					/* if erased */
X		if (dir->name[0] == 0xe5) {
X			if (slot < 0)
X				slot = entry;
X			continue;
X		}
X					/* if not a volume label */
X		if (!(dir->attr & 0x08))
X			continue;
X
X		slot = entry;
X		strncpy((char *) vol, (char *) dir->name, 8);
X		vol[8] = '\0';
X		strncat((char *) vol, (char *) dir->ext, 3);
X		vol[11] = '\0';
X
X		printf("Volume in drive %c is \"%s\"\n", drive, vol);
X		break;
X	}
X	if (slot < 0) {
X		fprintf(stderr, "%s: No directory slots\n", argv[0]);
X		exit(1);
X	}
X	if (vol[0] == '\0')
X		printf("Volume in drive %c is unlabeled\n", drive);
X
X					/* ask for new label */
X	printf("Enter the new volume label (11 characters): ");
X	gets(filename);
X	if (filename[0] != '\0') {
X		sprintf((char *) fixed, "%-11.11s", filename);
X		if (strlen(filename) > 11 && verbose)
X			printf("New label is \"%s\"\n", fixed);
X	}
X	else {
X		if (vol[0] == '\0')
X			exit(0);
X
X		printf("Delete volume label (y/n): ");
X		gets(ans);
X		if (ans[0] == 'y' || ans[0] == 'Y') {
X			strcpy((char *) fixed, (char *) vol);
X			fixed[0] = 0xe5;
X		}
X		else
X			exit(0);
X	}
X					/* make directory entry */
X	time(&now);
X	dir = mk_entry(fixed, 0x08, 0, 0L, now);
X	dir_write(slot, dir);
X
X	dir_flush();
X	disk_flush();
X	close(fd);
X	exit(0);
X}
END_OF_FILE
if test 3079 -ne `wc -c <'mtools/mlabel.c'`; then
    echo shar: \"'mtools/mlabel.c'\" unpacked with wrong size!
fi
# end of 'mtools/mlabel.c'
fi
if test -f 'mtools/mmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/mmd.c'\"
else
echo shar: Extracting \"'mtools/mmd.c'\" \(5127 characters\)
sed "s/^X//" >'mtools/mmd.c' <<'END_OF_FILE'
X/*
X * Make an MSDOS subdirectory
X *
X * Emmet P. Gray			US Army, HQ III Corps & Fort Hood
X * ...!uunet!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV
X * fthood!egray@uxc.cso.uiuc.edu	Directorate of Engineering & Housing
X * 					Environmental Management Office
X * 					Fort Hood, TX 76544-5057
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include "msdos.h"
X#include "patchlevel.h"
X
Xint fd = -1;				/* the file descriptor for the device */
Xint dir_start;				/* starting sector for directory */
Xint dir_len;				/* length of directory (in sectors) */
Xint dir_entries;			/* number of directory entries */
Xint clus_size;				/* cluster size (in sectors) */
Xchar *mcwd;				/* the Current Working Directory */
Xint fat_error;				/* FAT error detected? */
X
Xstatic int got_signal();
Xstatic void empty_dir();
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int i, entry, slot, fargn, verbose, oops;
X	extern unsigned int end_fat;
X	unsigned int fat, dot, next_fat();
X	char filename[13], *newfile, drive, get_drive(), *get_path();
X	char *strcpy(), *fix_mcwd(), *pathname, *unix_name(), last_drive;
X	unsigned char *fixed, *dos_name();
X	void exit(), fat_write(), dir_write(), disk_flush(), dir_flush();
X	struct directory *dir, *dir_read(), *mk_entry();
X	long time(), now;
X					/* catch signals */
X	signal(SIGINT, (SIG_TYPE(*) ()) got_signal);
X	signal(SIGTERM, (SIG_TYPE(*) ()) got_signal);
X	signal(SIGQUIT, (SIG_TYPE(*) ()) got_signal);
X
X	fargn = 1;
X	verbose = 0;
X	oops = 0;
X	if (argc > 1) {
X		if (!strcmp(argv[1], "-v")) {
X			fargn = 2;
X			verbose = 1;
X		}
X		if (argv[1][0] == '-' && !verbose)
X			oops++;
X	}
X	if (argc == 1 || oops) {
X		fprintf(stderr, "Mtools version %s, dated %s\n", VERSION, DATE);
X		fprintf(stderr, "Usage: %s [-v] msdosdirectory [msdosdirectories...]\n", argv[0]);
X		exit(1);
X	}
X	last_drive = 'x';
X	mcwd = fix_mcwd();
X
X	for (i = fargn; i < argc; i++) {
X		drive = get_drive(argv[i]);
X		if (drive != last_drive) {
X			if (last_drive != 'x') {
X				fat_write();
X				dir_flush();
X				disk_flush();
X			}
X
X			if (init(drive, 2)) {
X				fprintf(stderr, "%s: Cannot initialize '%c:'\n", argv[0], drive);
X				continue;
X			}
X			last_drive = drive;
X		}
X					/* serves the get_name() function too */
X		fixed = dos_name(argv[i], verbose);
X
X		strcpy(filename, unix_name(fixed, fixed + 8));
X		pathname = get_path(argv[i]);
X
X		if (subdir(drive, pathname))
X			continue;
X					/* see if exists and get slot */
X		slot = -1;
X		dot = 0;
X		oops = 0;
X		for (entry = 0; entry < dir_entries; entry++) {
X			dir = dir_read(entry);
X
X					/* if empty */
X			if (dir->name[0] == 0x0) {
X				if (slot < 0)
X					slot = entry;
X				break;
X			}
X					/* if erased */
X			if (dir->name[0] == 0xe5) {
X				if (slot < 0)
X					slot = entry;
X				continue;
X			}
X					/* if not a directory */
X			if (!(dir->attr & 0x10))
X				continue;
X
X			newfile = unix_name(dir->name, dir->ext);
X					/* save the 'dot' directory info */
X			if (!strcmp(".", newfile))
X				dot = dir->start[1] * 0x100 + dir->start[0];
X
X			if (!strcmp(filename, newfile)) {
X				fprintf(stderr, "%s: Directory \"%s\" already exists\n", argv[0], filename);
X				oops++;
X				break;
X			}
X		}
X		if (oops)
X			continue;
X					/* no '.' entry means root directory */
X		if (dot == 0 && slot < 0) {
X			fprintf(stderr, "%s: No directory slots\n", argv[0]);
X			continue;
X		}
X					/* make the directory grow */
X		if (dot && slot < 0) {
X			if (dir_grow(dot)) {
X				fprintf(stderr, "%s: Disk full\n", argv[0]);
X				continue;
X			}
X					/* first slot in the new part */
X			slot = entry;
X		}
X					/* grab a starting cluster */
X		if ((fat = next_fat(0)) == 1) {
X			fprintf(stderr, "%s: Disk full\n", argv[0]);
X			continue;
X		}
X					/* make directory entry */
X		time(&now);
X		dir = mk_entry(fixed, 0x10, fat, 0L, now);
X		dir_write(slot, dir);
X					/* write the cluster */
X		empty_dir(fat, dot);
X		fat_encode(fat, end_fat);
X	}
X					/* write the FAT, flush the buffers */
X	fat_write();
X	dir_flush();
X	disk_flush();
X	close(fd);
X	exit(0);
X}
X
X/*
X * Write an empty directory 'template' to the cluster starting at 'dot'.
X */
X
Xstatic void
Xempty_dir(dot, dot_dot)
Xunsigned int dot, dot_dot;
X{
X	int buflen;
X	long start;
X	char buf[MAX_CLUSTER], *memcpy(), *memset();
X	struct directory *dir, *mk_entry();
X	void disk_write();
X	long time(), now;
X
X	start = (long) (dot - 2) * clus_size + dir_start + dir_len;
X
X	buflen = clus_size * MSECTOR_SIZE;
X	time(&now);
X					/* make the '.' and '..' entries */
X	dir = mk_entry((unsigned char *) ".          ", 0x10, dot, 0L, now);
X	memcpy(&buf[0], (char *) dir, MDIR_SIZE);
X	dir = mk_entry((unsigned char *) "..         ", 0x10, dot_dot, 0L, now);
X	memcpy(&buf[MDIR_SIZE], (char *) dir, MDIR_SIZE);
X
X					/* zero the remainder */
X	memset(&buf[2 * MDIR_SIZE], '\0', buflen - (2 * MDIR_SIZE));
X
X					/* write the cluster */
X	disk_write(start, (unsigned char *) buf, buflen);
X	return;
X}
X
X/*
X * Do a graceful exit if the program is interrupted.  This will reduce
X * (but not eliminate) the risk of generating a corrupted disk on
X * a user abort.
X */
X
Xstatic int
Xgot_signal()
X{
X	void exit(), disk_flush(), fat_write(), dir_flush();
X
X	if (fd < 0)
X		exit(1);
X	fat_write();
X	dir_flush();
X	disk_flush();
X	close(fd);
X	exit(1);
X}
END_OF_FILE
if test 5127 -ne `wc -c <'mtools/mmd.c'`; then
    echo shar: \"'mtools/mmd.c'\" unpacked with wrong size!
fi
# end of 'mtools/mmd.c'
fi
if test -f 'mtools/mrd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/mrd.c'\"
else
echo shar: Extracting \"'mtools/mrd.c'\" \(4300 characters\)
sed "s/^X//" >'mtools/mrd.c' <<'END_OF_FILE'
X/*
X * Delete an MSDOS subdirectory
X *
X * Emmet P. Gray			US Army, HQ III Corps & Fort Hood
X * ...!uunet!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV
X * fthood!egray@uxc.cso.uiuc.edu	Directorate of Engineering & Housing
X * 					Environmental Management Office
X * 					Fort Hood, TX 76544-5057
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include "msdos.h"
X#include "patchlevel.h"
X
Xint fd = -1;				/* the file descriptor for the device */
Xint dir_start;				/* starting sector for directory */
Xint dir_len;				/* length of directory (in sectors) */
Xint dir_entries;			/* number of directory entries */
Xint clus_size;				/* cluster size (in sectors) */
Xchar *mcwd;				/* the Current Working Directory */
Xint fat_error;				/* FAT error detected? */
X
Xstatic int got_signal(), is_empty();
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int i, ismatch, entry, oops, empty;
X	unsigned int start;
X	char *filename, *newfile, *get_name(), drive, *pathname, *get_path();
X	char *unix_name(), get_drive(), last_drive, *fix_mcwd();
X	void exit(), fat_write(), dir_write(), disk_flush(), dir_flush();
X	struct directory *dir, *dir_read();
X					/* catch signals */
X	signal(SIGINT, (SIG_TYPE(*) ()) got_signal);
X	signal(SIGTERM, (SIG_TYPE(*) ()) got_signal);
X	signal(SIGQUIT, (SIG_TYPE(*) ()) got_signal);
X
X	if (argc == 1) {
X		fprintf(stderr, "Mtools version %s, dated %s\n", VERSION, DATE);
X		fprintf(stderr, "Usage: %s mdsosdirectory [msdosdirectories...]\n", argv[0]);
X		exit(1);
X	}
X
X	last_drive = 'x';
X	mcwd = fix_mcwd();
X
X	for (i = 1; i < argc; i++) {
X		drive = get_drive(argv[i]);
X		if (drive != last_drive) {
X			if (last_drive != 'x') {
X				fat_write();
X				dir_flush();
X				disk_flush();
X			}
X
X			if (init(drive, 2)) {
X				fprintf(stderr, "%s: Cannot initialize '%c:'\n", argv[0], drive);
X				continue;
X			}
X			last_drive = drive;
X		}
X
X		filename = get_name(argv[i]);
X		pathname = get_path(argv[i]);
X		if (subdir(drive, pathname))
X			continue;
X
X		oops = 0;
X		ismatch = 0;
X		for (entry = 0; entry < dir_entries; entry++) {
X			dir = dir_read(entry);
X					/* if empty */
X			if (dir->name[0] == 0x0)
X				break;
X					/* if erased */
X			if (dir->name[0] == 0xe5)
X				continue;
X					/* if not dir */
X			if (!(dir->attr & 0x10))
X				continue;
X
X			newfile = unix_name(dir->name, dir->ext);
X			if (match(newfile, filename)) {
X				start = dir->start[1] * 0x100 + dir->start[0];
X				if ((empty = is_empty(start)) < 0)
X					break;
X				if (!empty) {
X					fprintf(stderr, "%s: Directory \"%s\" is not empty\n", argv[0], filename);
X					oops++;
X					break;
X				}
X				if (!start) {
X					fprintf(stderr, "%s: Can't remove root directory\n", argv[0]);
X					oops++;
X					break;
X				}
X				if (fat_free(start))
X					break;
X				dir->name[0] = 0xe5;
X				dir_write(entry, dir);
X				ismatch = 1;
X			}
X		}
X		if (fat_error)
X			break;
X
X		if (oops)
X			continue;
X
X		if (!ismatch)
X			fprintf(stderr, "%s: Directory \"%s\" not found\n", argv[0], filename);
X	}
X					/* write the FAT, flush the buffers */
X	fat_write();
X	dir_flush();
X	disk_flush();
X	close(fd);
X	exit(0);
X}
X
X/*
X * See if directory is empty.  Returns 1 if empty, 0 if not, and -1 on error.
X * Can't use subdir() and dir_read() as it would clobber the globals.
X */
X
Xstatic int
Xis_empty(fat)
Xunsigned int fat;
X{
X	register int i;
X	int next, buflen;
X	long sector;
X	extern unsigned int last_fat, fat_decode();
X	unsigned char tbuf[MAX_CLUSTER];
X	void disk_read();
X
X	/* CONSTCOND */
X	while (1) {
X		sector = (long) (fat - 2) * clus_size + dir_start + dir_len;
X		buflen = clus_size * MSECTOR_SIZE;
X		disk_read(sector, tbuf, buflen);
X
X					/* check first character of name */
X		for (i = 0; i < MSECTOR_SIZE; i += MDIR_SIZE) {
X			if (tbuf[i] == '.')
X				continue;
X			if (tbuf[i] != 0x0 && tbuf[i] != 0xe5)
X				return(0);
X		}
X					/* get next cluster number */
X		next = fat_decode(fat);
X		if (next == 1) {
X			fprintf(stderr, "is_empty: FAT problem\n");
X			return(-1);
X		}
X					/* end of cluster chain */
X		if (next >= last_fat)
X			break;
X		fat = next;
X	}
X	return(1);
X}
X
X/*
X * Do a graceful exit if the program is interrupted.  This will reduce
X * (but not eliminate) the risk of generating a corrupted disk on
X * a user abort.
X */
X
Xstatic int
Xgot_signal()
X{
X	void exit(), disk_flush(), fat_write(), dir_flush();
X
X	if (fd < 0)
X		exit(1);
X	fat_write();
X	dir_flush();
X	disk_flush();
X	close(fd);
X	exit(1);
X}
END_OF_FILE
if test 4300 -ne `wc -c <'mtools/mrd.c'`; then
    echo shar: \"'mtools/mrd.c'\" unpacked with wrong size!
fi
# end of 'mtools/mrd.c'
fi
if test -f 'mtools/mren.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/mren.c'\"
else
echo shar: Extracting \"'mtools/mren.c'\" \(3089 characters\)
sed "s/^X//" >'mtools/mren.c' <<'END_OF_FILE'
X/*
X * Rename an existing MSDOS file
X *
X * Emmet P. Gray			US Army, HQ III Corps & Fort Hood
X * ...!uunet!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV
X * fthood!egray@uxc.cso.uiuc.edu	Directorate of Engineering & Housing
X * 					Environmental Management Office
X * 					Fort Hood, TX 76544-5057
X */
X
X#include <stdio.h>
X#include "msdos.h"
X#include "patchlevel.h"
X
Xint fd = -1;				/* the file descriptor for the device */
Xint dir_start;				/* starting sector for directory */
Xint dir_len;				/* length of directory (in sectors) */
Xint dir_entries;			/* number of directory entries */
Xint clus_size;				/* cluster size (in sectors) */
Xchar *mcwd;				/* the Current Working Directory */
Xint fat_error;				/* FAT error detected? */
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int entry, ismatch, nogo, fargn, verbose;
X	char filename[13], *newfile, *strncpy(), *unix_name();
X	char new[13], ans[10], *temp, *strcpy(), drive, get_drive();
X	char *get_path(), *pathname, *get_name(), *fix_mcwd();
X	unsigned char *target, *dos_name();
X	void exit(), dir_write(), disk_flush(), dir_flush();
X	struct directory *dir, *dir_read();
X
X	fargn = 1;
X	verbose = 0;
X	if (argc > 1) {
X		if (!strcmp(argv[1], "-v")) {
X			fargn = 2;
X			verbose = 1;
X		}
X	}
X	if (argc != fargn + 2) {
X		fprintf(stderr, "Mtools version %s, dated %s\n", VERSION, DATE);
X		fprintf(stderr, "Usage: %s [-v] sourcefile targetfile\n", argv[0]);
X		exit(1);
X	}
X	mcwd = fix_mcwd();
X
X	drive = get_drive(argv[1]);
X	if (init(drive, 2)) {
X		fprintf(stderr, "%s: Cannot initialize '%c:'\n", argv[0], drive);
X		exit(1);
X	}
X	strcpy(filename, get_name(argv[fargn]));
X	pathname = get_path(argv[fargn]);
X	if (subdir(drive, pathname))
X		exit(1);
X
X	temp = get_name(argv[fargn + 1]);
X	target = dos_name(argv[fargn + 1], verbose);
X
X	strcpy(new, unix_name(target, target + 8));
X	nogo = 0;
X					/* the name supplied may be altered */
X	if (strcmp(temp, new) && verbose) {
X		while (!nogo) {
X			printf("Do you accept \"%s\" as the new filename (y/n) ? ", new);
X			gets(ans);
X			if (ans[0] == 'y' || ans[0] == 'Y')
X				break;
X			if (ans[0] == 'n' || ans[0] == 'N')
X				nogo = 1;
X		}
X	}
X	if (nogo)
X		exit(0);
X					/* see if exists and do it */
X	ismatch = 0;
X	for (entry = 0; entry < dir_entries; entry++) {
X		dir = dir_read(entry);
X					/* if empty */
X		if (dir->name[0] == 0x0)
X			break;
X					/* if erased */
X		if (dir->name[0] == 0xe5)
X			continue;
X					/* if volume label */
X		if ((dir->attr & 0x08))
X			continue;
X					/* you may rename a directory */
X		newfile = unix_name(dir->name, dir->ext);
X
X					/* if the new name already exists */
X		if (!strcmp(new, newfile)) {
X			fprintf(stderr, "%s: File \"%s\" already exists\n", argv[0], new);
X			exit(1);
X		}
X					/* if the old name exists */
X		if (match(newfile, filename)) {
X			ismatch = 1;
X			break;
X		}
X	}
X	if (!ismatch) {
X		fprintf(stderr, "%s: File \"%s\" not found\n", argv[0], filename);
X		exit(1);
X	}
X					/* so go ahead and do it */
X	strncpy((char *) dir->name, (char *) target, 8);
X	strncpy((char *) dir->ext, (char *) target + 8, 3);
X	dir_write(entry, dir);
X
X	dir_flush();
X	disk_flush();
X	close(fd);
X	exit(0);
X}
END_OF_FILE
if test 3089 -ne `wc -c <'mtools/mren.c'`; then
    echo shar: \"'mtools/mren.c'\" unpacked with wrong size!
fi
# end of 'mtools/mren.c'
fi
if test -f 'mtools/mtype.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/mtype.c'\"
else
echo shar: Extracting \"'mtools/mtype.c'\" \(2931 characters\)
sed "s/^X//" >'mtools/mtype.c' <<'END_OF_FILE'
X/*
X * Display contents of an MSDOS file
X *
X * Emmet P. Gray			US Army, HQ III Corps & Fort Hood
X * ...!uunet!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV
X * fthood!egray@uxc.cso.uiuc.edu	Directorate of Engineering & Housing
X * 					Environmental Management Office
X * 					Fort Hood, TX 76544-5057
X */
X
X#include <stdio.h>
X#include "msdos.h"
X#include "patchlevel.h"
X
Xint fd = -1;				/* the file descriptor for the device */
Xint dir_start;				/* starting sector for directory */
Xint dir_len;				/* length of directory (in sectors) */
Xint dir_entries;			/* number of directory entries */
Xint clus_size;				/* cluster size (in sectors) */
Xchar *mcwd;				/* the Current Working Directory */
Xint fat_error;				/* FAT error detected? */
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	extern int optind;
X	extern char *optarg;
X	int i, ismatch, entry, c, oops, textmode, stripmode;
X	unsigned int fat;
X	long size;
X	char *filename, *newfile, *get_name(), *unix_name(), *pathname;
X	char *get_path(), drive, get_drive(), last_drive, *fix_mcwd();
X	void exit();
X	struct directory *dir, *dir_read();
X
X					/* get command line options */
X	oops = 0;
X	stripmode = 0;
X	textmode = 0;
X	while ((c = getopt(argc, argv, "st")) != EOF) {
X		switch (c) {
X			case 's':
X				stripmode = 1;
X				break;
X			case 't':
X				textmode = 1;
X				break;
X			default:
X				oops = 1;
X				break;
X		}
X	}
X
X	if (oops || (argc - optind) < 1) {
X		fprintf(stderr, "Mtools version %s, dated %s\n", VERSION, DATE);
X		fprintf(stderr, "Usage: %s [-st] msdosfile [msdosfiles...]\n", argv[0]);
X		exit(1);
X	}
X	last_drive = 'x';
X	mcwd = fix_mcwd();
X
X	for (i = optind; i < argc; i++) {
X		drive = get_drive(argv[i]);
X		if (drive != last_drive) {
X			if (init(drive, 0)) {
X				fprintf(stderr, "%s: Cannot initialize '%c:'\n", argv[0], drive);
X				continue;
X			}
X			last_drive = drive;
X		}
X		filename = get_name(argv[i]);
X		pathname = get_path(argv[i]);
X		if (subdir(drive, pathname))
X			continue;
X
X		ismatch = 0;
X		for (entry = 0; entry < dir_entries; entry++) {
X			dir = dir_read(entry);
X					/* if empty */
X			if (dir->name[0] == 0x0)
X				break;
X					/* if erased */
X			if (dir->name[0] == 0xe5)
X				continue;
X					/* if dir or volume label */
X			if ((dir->attr & 0x10) || (dir->attr & 0x08))
X				continue;
X
X			newfile = unix_name(dir->name, dir->ext);
X
X					/* see it if matches the pattern */
X			if (match(newfile, filename)) {
X				fat = dir->start[1] * 0x100 + dir->start[0];
X				size = dir->size[3] * 0x1000000L + dir->size[2] * 0x10000L + dir->size[1] * 0x100 + dir->size[0];
X				if (file_read(stdout, fat, textmode, stripmode, size))
X					break;
X				ismatch = 1;
X			}
X		}
X		if (fat_error)
X			break;
X
X		if (!ismatch)
X			fprintf(stderr, "%s: File \"%s\" not found\n", argv[0], filename);
X	}
X	close(fd);
X	exit(0);
X}
X
X/*
X * stubs for read-only programs
X */
X
Xvoid
Xdisk_flush()
X{
X	extern int disk_dirty;
X
X	disk_dirty = 0;
X	return;
X}
X
Xvoid
Xdir_flush()
X{
X	extern int dir_dirty;
X
X	dir_dirty = 0;
X	return;
X}
END_OF_FILE
if test 2931 -ne `wc -c <'mtools/mtype.c'`; then
    echo shar: \"'mtools/mtype.c'\" unpacked with wrong size!
fi
# end of 'mtools/mtype.c'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
