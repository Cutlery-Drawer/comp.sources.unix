Newsgroups: comp.sources.unix
From: fthood!egray@uxc.cso.uiuc.edu (Emmet P. Gray)
Subject: v25i097: mtools2 - tools to manipulate MSDOS filesystems, V2.0, Part01/03
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: fthood!egray@uxc.cso.uiuc.edu (Emmet P. Gray)
Posting-Number: Volume 25, Issue 97
Archive-Name: mtools2/part01

                                MTOOLS
                              version 2.0

Mtools is a public domain collection of programs to allow Unix systems
to read, write, and manipulate files on an MSDOS filesystem (typically a
diskette).

The following MSDOS commands are emulated:

	ATTRIB, CD, COPY, DEL/ERASE, DIR, FORMAT, LABEL, MD/MKDIR,
	RD/RMDIR, COPY, REN/RENAME, TYPE, and COPY.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  mtools mtools/Mattrib.1 mtools/Mcd.1 mtools/Mcopy.1
#   mtools/Mdel.1 mtools/Mdir.1 mtools/Mformat.1 mtools/Mkmanifest.1
#   mtools/Mlabel.1 mtools/Mmd.1 mtools/Mrd.1 mtools/Mread.1
#   mtools/Mren.1 mtools/Mtools.1 mtools/Mtype.1 mtools/Mwrite.1
#   mtools/Readme mtools/Release.notes mtools/buf_read.c
#   mtools/devices.c mtools/dir_make.c mtools/expand.c
#   mtools/fat_free.c mtools/fat_read.c mtools/fat_write.c
#   mtools/file_read.c mtools/file_write.c mtools/is_dir.c
#   mtools/match.c mtools/mkmanifest.c mtools/msdos.h mtools/parse.c
#   mtools/patchlevel.h mtools/subdir.c
# Wrapped by lai@risotto on Sat Jan 11 12:03:34 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'mtools' ; then
    echo shar: Creating directory \"'mtools'\"
    mkdir 'mtools'
fi
if test -f 'mtools/Mattrib.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mattrib.1'\"
else
echo shar: Extracting \"'mtools/Mattrib.1'\" \(1208 characters\)
sed "s/^X//" >'mtools/Mattrib.1' <<'END_OF_FILE'
X.TH MATTRIB 1 local
X.SH NAME
Xmattrib \- change MSDOS file attribute flags
X.SH SYNOPSIS
X.B mattrib
X[
X.B -a|+a
X]
X[
X.B -h|+h
X]
X[
X.B -r|+r
X]
X[
X.B -s|+s
X] msdosfile [ msdosfiles... ]
X.SH DESCRIPTION
X.I Mattrib
Xwill add attribute flags to an MSDOS file (with the '+' operator) or
Xremove attribute flags (with the '-' operator).
X.PP
X.I Mattrib
Xwill allow the following command line options:
X.TP
X.B a
XArchive bit.  Used by some backup programs to indicate a new file.
X.TP
X.B r
XRead-only bit.  Used to indicate a read-only file.  Files with this bit
Xset cannot be erased by DEL.  However, 
X.I
Xmdel
Xis more cunning.
X.TP
X.B s
XSystem bit.  Used by MSDOS to indicate a operating system file.
X.TP
X.B h
XHidden bit.  Used to make files hidden from DIR.  However,
X.I
Xmdir
Xis more cunning.
X.PP
XMSDOS subdirectory names are supported with either the '/' or '\e\'
Xseparator.  The use of the '\e\' separator or wildcards will require the
Xnames to be enclosed in quotes to protect them from the shell.
X.PP
XThe
X.I mcd
Xcommand may be used to establish the device and the current working
Xdirectory (relative to MSDOS), otherwise the default is A:/.
X.SH SEE ALSO
Xmcd(1)
X.SH BUGS
XMost versions of ATTRIB don't allow this many options.
END_OF_FILE
if test 1208 -ne `wc -c <'mtools/Mattrib.1'`; then
    echo shar: \"'mtools/Mattrib.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mattrib.1'
fi
if test -f 'mtools/Mcd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mcd.1'\"
else
echo shar: Extracting \"'mtools/Mcd.1'\" \(893 characters\)
sed "s/^X//" >'mtools/Mcd.1' <<'END_OF_FILE'
X.TH MCD 1 local
X.SH NAME
Xmcd \- change MSDOS directory
X.SH SYNOPSIS
X.B mcd
X[ msdosdirectory ]
X.SH DESCRIPTION
XWithout arguments,
X.I mcd
Xwill report the current device and working directory.  Otherwise,
X.I mcd
Xchanges the current device and current working directory relative to an
XMSDOS filesystem.
X.PP
XThe environmental variable MCWD may be used to locate the file where the
Xdevice and current working directory information is stored.  The default
Xis '$HOME/.mcwd'.  Information in this file is ignored if the file is
Xmore than 6 hours old.
X.PP
XMSDOS subdirectory names are supported with either the '/' or '\e\'
Xseparator.  The use of the '\e\' separator or wildcards will require the
Xdirectory name to be enclosed in quotes to protect it from the shell.
X.SH SEE ALSO
Xmdir(1)
X.SH BUGS
XMSDOS doesn't use CD to change to another device.
X.PP
XIt may be wise to remove old .mcwd files at logout.
END_OF_FILE
if test 893 -ne `wc -c <'mtools/Mcd.1'`; then
    echo shar: \"'mtools/Mcd.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mcd.1'
fi
if test -f 'mtools/Mcopy.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mcopy.1'\"
else
echo shar: Extracting \"'mtools/Mcopy.1'\" \(1658 characters\)
sed "s/^X//" >'mtools/Mcopy.1' <<'END_OF_FILE'
X.TH MCOPY 1 local
X.SH NAME
Xmcopy \- copy MSDOS files to/from Unix
X.SH SYNOPSIS
X.B mcopy
X[
X.B -tnvm
X] sourcefile targetfile
X.PP
X.B mcopy
X[
X.B -tnvm
X] sourcefile [ sourcefiles... ] targetdirectory
X.SH DESCRIPTION
X.I Mcopy
Xcopies the specified file to the named file, or copies multiple files to
Xthe named directory.  The source and target can be either MSDOS or Unix
Xfiles.
X.PP
XThe use of a drive letter designation on the MSDOS files, 'a:' for
Xexample, determines the direction of the transfer.  A missing drive
Xdesignation implies a Unix file whose path starts in the current
Xdirectory
X.PP
X.I Mcopy
Xwill allow the following command line options:
X.TP
X.B t
XText file transfer.
X.I Mcopy
Xwill translate incoming carriage return/line feeds to line feeds.
X.TP
X.B n
XNo warning.
X.I Mcopy
Xwill not warn the user when overwriting an existing file.
X.TP
X.B v
XVerbose mode.
X.TP
X.B m
XPreserve the file modification time.
X.PP
XIf the target file already exists, and the
X.I -n
Xoption is not in effect,
X.I mcopy
Xasks whether or not to overwrite the file.
X.PP
XMSDOS subdirectory names are supported with either the '/' or '\e\'
Xseparator.  The use of the '\e\' separator or wildcards will require the
Xnames to be enclosed in quotes to protect them from the shell.
X.PP
XThe
X.I mcd
Xcommand may be used to establish the device and the current working
Xdirectory (relative to MSDOS), otherwise the default is A:/.
X.SH SEE ALSO
Xmcd(1), mread(1), mwrite(1)
X.SH BUGS
XUnlike MSDOS, the destination directory may
X.B not
Xbe omitted.
X.PP
XThe '+' operator (append) from MSDOS is not supported.
X.PP
XNo other
X.I Mtools
Xcommand
X.B requires
Xthe use of a drive letter designation on MSDOS files.
END_OF_FILE
if test 1658 -ne `wc -c <'mtools/Mcopy.1'`; then
    echo shar: \"'mtools/Mcopy.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mcopy.1'
fi
if test -f 'mtools/Mdel.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mdel.1'\"
else
echo shar: Extracting \"'mtools/Mdel.1'\" \(829 characters\)
sed "s/^X//" >'mtools/Mdel.1' <<'END_OF_FILE'
X.TH MDEL 1 local
X.SH NAME
Xmdel \- delete an MSDOS file
X.SH SYNOPSIS
X.B mdel
X[
X.B -v
X] msdosfile [ msdosfiles...  ]
X.SH DESCRIPTION
X.I Mdel
Xdeletes a file on an MSDOS filesystem.
X.PP
X.I Mdel
Xwill allow the following command line option:
X.TP
X.B v
XVerbose mode.  Echo the filenames as they are processed.
X.PP
X.I Mdel
Xwill ask for verification prior to removing a read\-only file.
X.PP
XMSDOS subdirectory names are supported with either the '/' or '\e\'
Xseparator.  The use of the '\e\' separator or wildcards will require the
Xnames to be enclosed in quotes to protect them from the shell.
X.PP
XThe
X.I mcd
Xcommand may be used to establish the device and the current working
Xdirectory (relative to MSDOS), otherwise the default is A:/.
X.SH SEE ALSO
Xmcd(1)
X.SH BUGS
XAllows multiple arguments, which does not follow the MSDOS convention.
END_OF_FILE
if test 829 -ne `wc -c <'mtools/Mdel.1'`; then
    echo shar: \"'mtools/Mdel.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mdel.1'
fi
if test -f 'mtools/Mdir.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mdir.1'\"
else
echo shar: Extracting \"'mtools/Mdir.1'\" \(967 characters\)
sed "s/^X//" >'mtools/Mdir.1' <<'END_OF_FILE'
X.TH MDIR 1 local
X.SH NAME
Xmdir \- display an MSDOS directory
X.SH SYNOPSIS
X.B mdir
X[
X.B -w
X] msdosdirectory
X.PP
X.B mdir
X[
X.B -w
X] msdosfile [ msdosfiles...  ] 
X.SH DESCRIPTION
X.I Mdir
Xdisplays the contents of an MSDOS directory.
X.PP
X.I Mdir
Xwill allow the following command line option:
X.TP
X.B w
XWide output.  This option will print the filenames across the page
Xwithout displaying the file size or creation date.
X.PP
XAn error occurs if a component of the path is not a directory.
X.PP
XMSDOS subdirectory names are supported with either the '/' or '\e\'
Xseparator.  The use of the '\e\' separator or wildcards will require the
Xnames to be enclosed in quotes to protect them from the shell.
X.PP
XThe
X.I mcd
Xcommand may be used to establish the device and the current working
Xdirectory (relative to MSDOS), otherwise the default is A:/.
X.SH SEE ALSO
Xmcd(1)
X.SH BUGS
XAllows multiple arguments, which does not follow the MSDOS convention.
X.PP
XThere is no /P (pause) option.
END_OF_FILE
if test 967 -ne `wc -c <'mtools/Mdir.1'`; then
    echo shar: \"'mtools/Mdir.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mdir.1'
fi
if test -f 'mtools/Mformat.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mformat.1'\"
else
echo shar: Extracting \"'mtools/Mformat.1'\" \(865 characters\)
sed "s/^X//" >'mtools/Mformat.1' <<'END_OF_FILE'
X.TH MFORMAT 1 local
X.SH NAME
Xmformat \- add an MSDOS filesystem to a low-level formatted diskette.
X.SH SYNOPSIS
X.B mformat
X[
X.B -t
Xtracks ] [
X.B -h
Xheads ] [
X.B -s
Xsectors ] [
X.B -l
Xvolume label ] drive:
X.SH DESCRIPTION
X.I Mformat
Xadds a minimal MSDOS filesystem (boot sector, FAT, and root directory) to
Xa diskette that has already been formatted by a Unix low-level format.
X.PP
XThe follow options are supported:
X.TP
X.B t
XThe number of tracks (not cylinders).
X.TP
X.B h
XThe number of heads (sides).
X.TP
X.B s
XThe number of sectors per track.
X.TP
X.B l
XAn optional volume label.
X.PP
XTo format a diskette at a density other than the default, you must supply
X(at least) those command line parameters that are different from the
Xdefault.
X.SH SEE ALSO
Xmlabel(1)
X.SH BUGS
XRequires a low-level format utility from Unix.
X.PP
XDoesn't detect (or record) bad block information.
END_OF_FILE
if test 865 -ne `wc -c <'mtools/Mformat.1'`; then
    echo shar: \"'mtools/Mformat.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mformat.1'
fi
if test -f 'mtools/Mkmanifest.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mkmanifest.1'\"
else
echo shar: Extracting \"'mtools/Mkmanifest.1'\" \(1570 characters\)
sed "s/^X//" >'mtools/Mkmanifest.1' <<'END_OF_FILE'
X.TH MKMANIFEST 1 local
X.SH NAME
Xmkmanifest \- create a shell script to restore Unix filenames
X.SH SYNOPSIS
X.B mkmanifest
X[ files ]
X.SH DESCRIPTION
X.I Mkmanifest
Xcreates a shell script that will aid in the restoration of Unix filenames
Xthat got clobbered by the MSDOS filename restrictions.  MSDOS filenames
Xare restricted to 8 character names, 3 character extensions, upper case
Xonly, no device names, and no illegal characters.
X.PP
XThe mkmanifest program is compatible with the methods used in
X.I pcomm, arc,
Xand
X.I mtools
Xto change perfectly good Unix filenames to fit the MSDOS restrictions.
X.SH EXAMPLE
XI want to copy the following Unix files to a MSDOS diskette (using the
X.I mcopy
Xcommand).
X.PP
X.in +0.5i
X.nf
Xvery_long_name
X2.many.dots
Xillegal:
Xgood.c
Xprn.dev
XCapital
X.fi
X.in
X.PP
X.I Mcopy
Xwill convert the names to:
X.PP
X.in +0.5i
X.nf
Xvery_lon
X2xmany.dot
Xillegalx
Xgood.c
Xxprn.dev
Xcapital
X.fi
X.in
X.PP
XThe command:
X.PP
Xmkmanifest very_long_name 2.many.dots illegal: good.c prn.dev Capital >
Xmanifest
X.PP
Xwould produce the following:
X.PP
X.in +0.5i
X.nf
Xmv very_lon very_long_name
Xmv 2xmany.dot 2.many.dots
Xmv illegalx illegal:
Xmv xprn.dev prn.dev
Xmv capital Capital
X.fi
X.in
X.PP
XNotice that "good.c" did not require any conversion, so it did not appear
Xin the output.
X.PP
XSuppose I've copied these files from the diskette to another Unix
Xsystem, and I now want the files back to their original names.  If the
Xfile "manifest" (the output captured above) was sent along with those
Xfiles, it could be used to convert the filenames.
X.SH SEE ALSO
Xarc(1), pcomm(1), mtools(1)
END_OF_FILE
if test 1570 -ne `wc -c <'mtools/Mkmanifest.1'`; then
    echo shar: \"'mtools/Mkmanifest.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mkmanifest.1'
fi
if test -f 'mtools/Mlabel.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mlabel.1'\"
else
echo shar: Extracting \"'mtools/Mlabel.1'\" \(649 characters\)
sed "s/^X//" >'mtools/Mlabel.1' <<'END_OF_FILE'
X.TH MLABEL 1 local
X.SH NAME
Xmlabel \- make an MSDOS volume label
X.SH SYNOPSIS
X.B mlabel
X[
X.B -v
X] drive:
X.SH DESCRIPTION
X.I Mlabel
Xdisplays the current volume label, if present, and prompts the user
Xfor a new volume label.  To delete an existing volume label, press
Xreturn at the prompt.
X.PP
X.I Mlabel
Xwill allow the following command line option:
X.TP
X.B v
XVerbose mode.  Display the new volume label if the label supplied is
Xinvalid.
X.PP
XReasonable care is taken to create a valid MSDOS volume label.  If an
Xinvalid label is specified,
X.I mlabel
Xwill change the label (and display the new label if the verbose mode is
Xset).
X.SH SEE ALSO
Xmformat(1)
END_OF_FILE
if test 649 -ne `wc -c <'mtools/Mlabel.1'`; then
    echo shar: \"'mtools/Mlabel.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mlabel.1'
fi
if test -f 'mtools/Mmd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mmd.1'\"
else
echo shar: Extracting \"'mtools/Mmd.1'\" \(1048 characters\)
sed "s/^X//" >'mtools/Mmd.1' <<'END_OF_FILE'
X.TH MMD 1 local
X.SH NAME
Xmmd \- make an MSDOS subdirectory
X.SH SYNOPSIS
X.B mmd
X[
X.B -v
X] msdosdirectory [ msdosdirectories... ]
X.SH DESCRIPTION
X.I Mmd
Xmakes a new directory on an MSDOS filesystem.
X.PP
X.I Mmd
Xwill allow the following command line option:
X.TP
X.B v
XVerbose mode.  Display the new directory name if the name supplied is
Xinvalid.
X.PP
XReasonable care is taken to create a valid MSDOS directory name.  If an
Xinvalid name is specified,
X.I mmd
Xwill change the name (and display the new name if the verbose mode is
Xset).
X.PP
XAn error occurs if the directory already exists.
X.PP
XMSDOS subdirectory names are supported with either the '/' or '\e\'
Xseparator.  The use of the '\e\' separator or wildcards will require the
Xdirectory name to be enclosed in quotes to protect it from the shell.
X.PP
XThe
X.I mcd
Xcommand may be used to establish the device and the current working
Xdirectory (relative to MSDOS), otherwise the default is A:/.
X.SH SEE ALSO
Xmcd(1), mrd(1)
X.SH BUGS
XAllows multiple arguments, which does not follow the MSDOS convention.
END_OF_FILE
if test 1048 -ne `wc -c <'mtools/Mmd.1'`; then
    echo shar: \"'mtools/Mmd.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mmd.1'
fi
if test -f 'mtools/Mrd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mrd.1'\"
else
echo shar: Extracting \"'mtools/Mrd.1'\" \(707 characters\)
sed "s/^X//" >'mtools/Mrd.1' <<'END_OF_FILE'
X.TH MRD 1 local
X.SH NAME
Xmrd \- remove an MSDOS subdirectory
X.SH SYNOPSIS
X.B mrd
Xmsdosdirectory [ msdosdirectories... ]
X.SH DESCRIPTION
X.I Mrd
Xremoves a directory from an MSDOS filesystem.
X.PP
XAn error occurs if the directory is not empty.
X.PP
XMSDOS subdirectory names are supported with either the '/' or '\e\'
Xseparator.  The use of the '\e\' separator or wildcards will require the
Xdirectory name to be enclosed in quotes to protect it from the shell.
X.PP
XThe
X.I mcd
Xcommand may be used to establish the device and the current working
Xdirectory (relative to MSDOS), otherwise the default is A:/.
X.SH SEE ALSO
Xmcd(1), mmd(1)
X.SH BUGS
XAllows multiple arguments, which does not follow the MSDOS convention.
END_OF_FILE
if test 707 -ne `wc -c <'mtools/Mrd.1'`; then
    echo shar: \"'mtools/Mrd.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mrd.1'
fi
if test -f 'mtools/Mread.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mread.1'\"
else
echo shar: Extracting \"'mtools/Mread.1'\" \(1293 characters\)
sed "s/^X//" >'mtools/Mread.1' <<'END_OF_FILE'
X.TH MREAD 1 local
X.SH NAME
Xmread \- low level read (copy) an MSDOS file to Unix
X.SH SYNOPSIS
X.B mread
X[
X.B -tnm
X] msdosfile unixfile
X.PP
X.B mread
X[
X.B -tnm
X] msdosfile [ msdosfiles... ] unixdirectory
X.SH DESCRIPTION
XIn the first form,
X.I mread
Xcopies the specified MSDOS file to the named Unix file.  The second form
Xof the command copies multiple MSDOS files to the named Unix directory.
X.PP
X.I Mread
Xwill allow the following command line options:
X.TP
X.B t
XText file transfer.
X.I Mread
Xwill translate incoming carriage return/line feeds to line feeds.
X.TP
X.B n
XNo warning.
X.I Mread
Xwill not warn the user when overwriting an existing file.
X.TP
X.B m
XPreserve the file modification times.
X.PP
XIf the target file already exists, and the
X.I -n
Xoption is not in effect,
X.I mread
Xasks whether or not to overwrite the file.
X.PP
XMSDOS subdirectory names are supported with either the '/' or '\e\'
Xseparator.  The use of the '\e\' separator or wildcards will require the
Xnames to be enclosed in quotes to protect them from the shell.
X.PP
XThe
X.I mcd
Xcommand may be used to establish the device and the current working
Xdirectory (relative to MSDOS), otherwise the default is A:/.
X.SH SEE ALSO
Xmcd(1), mcopy(1), mtype(1), mwrite(1)
X.SH BUGS
XUnlike MSDOS, the destination directory may
X.B not
Xbe omitted.
END_OF_FILE
if test 1293 -ne `wc -c <'mtools/Mread.1'`; then
    echo shar: \"'mtools/Mread.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mread.1'
fi
if test -f 'mtools/Mren.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mren.1'\"
else
echo shar: Extracting \"'mtools/Mren.1'\" \(1186 characters\)
sed "s/^X//" >'mtools/Mren.1' <<'END_OF_FILE'
X.TH MREN 1 local
X.SH NAME
Xmren \- rename an existing MSDOS file
X.SH SYNOPSIS
X.B mren
X[
X.B -v
X] sourcefile targetfile
X.SH DESCRIPTION
X.I Mren
Xrenames an existing file on an MSDOS filesystem.
X.PP
X.I Mren
Xwill allow the following command line option:
X.TP
X.B v
XVerbose mode.  Display the new filename if the name supplied is
Xinvalid.
X.PP
XReasonable care is taken to create a valid MSDOS filename.  If an invalid
XMSDOS target name is specified,
X.I mren
Xwill change the name (and prompt the user to accept or reject the new name
Xif the verbose mode is set).
X.PP
XThe path component of the target filename (if supplied) is ignored.  In
Xother words, you may not use
X.I mren
Xto move a file from one subdirectory to another.
X.PP 
X.I Mren
Xmay be used to rename directories.
X.PP
XMSDOS subdirectory names are supported with either the '/' or '\e\'
Xseparator.  The use of the '\e\' separator or wildcards will require the
Xnames to be enclosed in quotes to protect them from the shell.
X.PP
XThe
X.I mcd
Xcommand may be used to establish the device and the current working
Xdirectory (relative to MSDOS), otherwise the default is A:/.
X.SH SEE ALSO
Xmcd(1)
X.SH BUGS
XMSDOS can't use REN to rename directories.
END_OF_FILE
if test 1186 -ne `wc -c <'mtools/Mren.1'`; then
    echo shar: \"'mtools/Mren.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mren.1'
fi
if test -f 'mtools/Mtools.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mtools.1'\"
else
echo shar: Extracting \"'mtools/Mtools.1'\" \(2116 characters\)
sed "s/^X//" >'mtools/Mtools.1' <<'END_OF_FILE'
X.TH MTOOLS 1 local
X.SH NAME
XMtools \- a collection of tools for manipulating MSDOS files
X.SH SYNOPSIS
X.nf
X\fBmattrib\fR \- change MSDOS file attribute flags
X\fBmcd\fR \- change MSDOS directory
X\fBmcopy\fR \- copy MSDOS files to/from Unix
X\fBmdel\fR \- delete an MSDOS file
X\fBmdir\fR \- display an MSDOS directory
X\fBmformat\fR \- add an MSDOS filesystem to a low-level formatted diskette
X\fBmlabel\fR \- make an MSDOS volume label
X\fBmmd\fR \- make an MSDOS subdirectory
X\fBmrd\fR \- remove an MSDOS subdirectory
X\fBmread\fR \- low level read (copy) an MSDOS file to Unix
X\fBmren\fR \- rename an existing MSDOS file
X\fBmtype\fR \- display contents of an MSDOS file
X\fBmwrite\fR \- low level write (copy) a Unix file to MSDOS
X.fi
X.SH DESCRIPTION
XMtools is a public domain collection of programs to allow Unix systems
Xto read, write, and manipulate files on an MSDOS filesystem (typically a
Xdiskette).  Each program attempts to emulate the MSDOS equivalent
Xcommand as closely as practical.
X.PP
XMSDOS filenames are optionally composed of a drive letter followed by a
Xcolon, a subdirectory, and a filename.  Subdirectory names can use either
Xthe '/' or '\e\' separator.  The use of the '\e\' separator or wildcards
Xwill require the names to be enclosed in quotes to protect them from the
Xshell.
X.PP
XThe regular expression "pattern matching" routines follow the Unix-style
Xrules.  For example, '*' matches all MSDOS files in lieu of '*.*'.  The
Xarchive, hidden, read-only and system attribute bits are ignored during
Xpattern matching.
X.PP
XAll options use the '-' (minus) flag, not '/' as you'd expect in MSDOS.
X.PP
XThe
X.I mcd
Xcommand is used to establish the device and the current working
Xdirectory (relative to the MSDOS filesystem), otherwise the default is
Xassumed to be A:/.
X.SH SEE ALSO
Xmattrib(1), mcd(1), mdel(1), mformat(1), mrd(1), mren(1), mtype(1),
Xmcopy(1), mdir(1), mlabel(1), mmd(1), mread(1), mwrite(1)
X.SH BUGS
XAn unfortunate side effect of not guessing the proper device (when
Xmultiple disk capacities are supported) is an occasional error message
Xfrom the device driver.  These can be safely ignored.
END_OF_FILE
if test 2116 -ne `wc -c <'mtools/Mtools.1'`; then
    echo shar: \"'mtools/Mtools.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mtools.1'
fi
if test -f 'mtools/Mtype.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mtype.1'\"
else
echo shar: Extracting \"'mtools/Mtype.1'\" \(903 characters\)
sed "s/^X//" >'mtools/Mtype.1' <<'END_OF_FILE'
X.TH MTYPE 1 local
X.SH NAME
Xmtype \- display contents of an MSDOS file
X.SH SYNOPSIS
X.B mtype
X[
X.B -ts
X] msdosfile [ msdosfiles... ]
X.SH DESCRIPTION
X.I Mtype
Xdisplays the specified MSDOS file on the screen.
X.PP
X.I Mtype
Xwill allow the following command line options:
X.TP
X.B t
XText file viewing.
X.I Mtype
Xwill translate incoming carriage return/line feeds to line feeds.
X.TP
X.B s
XStrip high bit.
X.I Mtype
Xwill strip the high bit from the data.
X.PP
XMSDOS subdirectory names are supported with either the '/' or '\e\'
Xseparator.  The use of the '\e\' separator or wildcards will require the
Xnames to be enclosed in quotes to protect them from the shell.
X.PP
XThe
X.I mcd
Xcommand may be used to establish the device and the current working
Xdirectory (relative to MSDOS), otherwise the default is A:/.
X.SH SEE ALSO
Xmcd(1), mread(1)
X.SH BUGS
XAllows multiple arguments, which does not follow the MSDOS convention.
END_OF_FILE
if test 903 -ne `wc -c <'mtools/Mtype.1'`; then
    echo shar: \"'mtools/Mtype.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mtype.1'
fi
if test -f 'mtools/Mwrite.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Mwrite.1'\"
else
echo shar: Extracting \"'mtools/Mwrite.1'\" \(1570 characters\)
sed "s/^X//" >'mtools/Mwrite.1' <<'END_OF_FILE'
X.TH MWRITE 1 local
X.SH NAME
Xmwrite \- low level write (copy) a Unix file to MSDOS
X.SH SYNOPSIS
X.B mwrite
X[
X.B -tnvm
X] unixfile msdosfile
X.PP
X.B mwrite
X[
X.B -tnvm
X] unixfile [ unixfiles... ] msdosdirectory
X.SH DESCRIPTION
XIn the first form,
X.I mwrite
Xcopies the specified Unix file to the named MSDOS file.  The second form
Xof the command copies multiple Unix files to the named MSDOS directory.
X.PP
X.I Mwrite
Xwill allow the following command line options:
X.TP
X.B t
XText file transfer.
X.I Mwrite
Xwill translate incoming line feeds to carriage return/line feeds.
X.TP
X.B n
XNo warning.
X.I Mwrite
Xwill not warn the user when overwriting an existing file.
X.TP
X.B v
XVerbose mode.  Display the new filename if the Unix filename requires
Xconversion.
X.TP
X.B m
XPreserve the file modification times.
X.PP
XIf the target file already exists, and the
X.I -n
Xoption is not in effect,
X.I mwrite
Xasks whether or not to overwrite the file.
X.PP
XReasonable care is taken to create a valid MSDOS filename.  If an
Xinvalid name is specified,
X.I mwrite
Xwill change the name (and display the new name if the verbose mode is
Xset).
X.PP
XMSDOS subdirectory names are are supported with either the '/' or '\e\'
Xseparator.  The use of the '\e\' separator or wildcards will require the
Xnames to be enclosed in quotes to protect them from the shell.
X.PP
XThe
X.I mcd
Xcommand may be used to establish the device and the current working
Xdirectory (relative to MSDOS), otherwise the default is A:/.
X.SH SEE ALSO
Xmcd(1), mcopy(1), mread(1)
X.SH BUGS
XUnlike MSDOS, the destination directory may
X.B not
Xbe omitted.
END_OF_FILE
if test 1570 -ne `wc -c <'mtools/Mwrite.1'`; then
    echo shar: \"'mtools/Mwrite.1'\" unpacked with wrong size!
fi
# end of 'mtools/Mwrite.1'
fi
if test -f 'mtools/Readme' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Readme'\"
else
echo shar: Extracting \"'mtools/Readme'\" \(2533 characters\)
sed "s/^X//" >'mtools/Readme' <<'END_OF_FILE'
X				MTOOLS
X			      version 2.0
X
XMtools is a public domain collection of programs to allow Unix systems
Xto read, write, and manipulate files on an MSDOS filesystem (typically a
Xdiskette).
X
XThe following MSDOS commands are emulated:
X
XMtool 		MSDOS
Xname		equivalent	Description
X-----		----		-----------
Xmattrib		ATTRIB		change MSDOS file attribute flags
Xmcd		CD		change MSDOS directory
Xmcopy		COPY		copy MSDOS files to/from Unix
Xmdel		DEL/ERASE	delete an MSDOS file
Xmdir		DIR		display an MSDOS directory
Xmformat		FORMAT		add MSDOS filesystem to a low-level format
Xmlabel		LABEL		make an MSDOS volume label.
Xmmd		MD/MKDIR	make an MSDOS subdirectory
Xmrd		RD/RMDIR	remove an MSDOS subdirectory
Xmread		COPY		low level read (copy) an MSDOS file to Unix
Xmren		REN/RENAME	rename an existing MSDOS file
Xmtype		TYPE		display contents of an MSDOS file
Xmwrite		COPY		low level write (copy) a Unix file to MSDOS
X
XYou should be able to just close your eyes and pretend you're on an MSDOS
Xsystem.  Everything should work the same... except for the added 'm' at
Xthe beginning of each command.
X
XI really wanted to avoid the use of a 'text' mode and a 'data' mode when
Xtransferring files, but I couldn't find a better way.  It gets rather
Xconfusing and it's quite possible to mess up a file if you apply the
Xtext mode when it is not appropriate (ie:  to a COM or EXE file).
X
XThe pattern matching routine more closely resembles Unix than MSDOS.
XFor example, "*" matches all MSDOS files in lieu of "*.*".
X
XThe use of wildcards (or the '\' separator) will require the names to be
Xenclosed in quotes to protect them from the shell.  For example:
X
X	RIGHT:	mcopy "a:*.c" .
X
X	will copy all files on the A: disk with the extension .C to the
X	current Unix directory.
X
X	WRONG:	mcopy a:*.c .
X
X	will cause the shell to expand a:*.c in the current Unix directory
X	(which is probably not what you wanted) then copy that list of
X	files (if there were any) from A: to the current Unix directory.
X
X	RIGHT:	mcopy *.c a:
X
X	will copy all files with the extension .c in the current Unix
X	directory to the A: drive.  (This time you *want* the shell
X	the expand the *.c).
X
XThe manuals are very terse...  it's assumed that the reader is already
Xfamiliar with MSDOS.
X
XMcopy is really a front-end to the low level Mread and Mwrite commands.
X
XEmmet P. Gray				US Army, HQ III Corps & Fort Hood
X...!uunet!uiucuxc!fthood!egray		Attn: AFZF-DE-ENV
Xfthood!egray@uxc.cso.uiuc.edu		Directorate of Engineering & Housing
X					Environmental Management Office
X					Fort Hood, TX 76544-5057
END_OF_FILE
if test 2533 -ne `wc -c <'mtools/Readme'`; then
    echo shar: \"'mtools/Readme'\" unpacked with wrong size!
fi
# end of 'mtools/Readme'
fi
if test -f 'mtools/Release.notes' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/Release.notes'\"
else
echo shar: Extracting \"'mtools/Release.notes'\" \(1008 characters\)
sed "s/^X//" >'mtools/Release.notes' <<'END_OF_FILE'
XNew in the v2.0 release....
X
X	1) Support for multiple devices.  Mtools now supports:
X		multiple floppy disks (A:, B:, etc)
X		DOS partitions on a hard disk
X		DOS "images" such as those VP/ix uses.
X
X	2) Wildcards are supported anywhere in a pathname (not just
X	in the "filename" part as before)
X
X	3) Reads and writes to slow devices are now "cylinder buffered"
X	when appropriate.
X
X	4) Versions of CD, FORMAT, LABEL, and ATTRIB have been added.
X
X	5) A Mtools.1 manual page has beed added for an overview of Mtools.
X
X	6) The mkmanifest command has been added.  Although not an 'mtool'
X	command, it makes life easier when fixing up Unix filenames that
X	get clobbered by MSDOS file name restrictions.
X
X	7) The mkdfs program of the "fast-mtools" release for the Sun
X	SparcStation can be replaced with mformat.
X
X	8) The Configure file has been included to help those who must add
X	devices to the devices.c file.
X
X	Many thanks to Viktor Dukhovni (viktor@math.princeton.edu) for
X	many of the ideas in the new release.
END_OF_FILE
if test 1008 -ne `wc -c <'mtools/Release.notes'`; then
    echo shar: \"'mtools/Release.notes'\" unpacked with wrong size!
fi
# end of 'mtools/Release.notes'
fi
if test -f 'mtools/buf_read.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/buf_read.c'\"
else
echo shar: Extracting \"'mtools/buf_read.c'\" \(1759 characters\)
sed "s/^X//" >'mtools/buf_read.c' <<'END_OF_FILE'
X/*
X * Do full cylinder buffered reads from slow devices.  Uses a simple
X * buffered read/delayed write algorithm.
X */
X
X#include <stdio.h>
X#include "msdos.h"
X
Xunsigned char *disk_buf;		/* disk read/write buffer */
Xint disk_size;				/* size of read/write buffer */
Xlong disk_current;			/* first sector in buffer */
Xint disk_dirty;				/* is the buffer dirty? */
X
Xextern int fd;
Xextern long disk_offset;
X
Xvoid
Xdisk_read(start, buf, len)
Xlong start;
Xunsigned char *buf;
Xint len;
X{
X	register long i;
X	int length;
X	unsigned char *buf_ptr, *disk_ptr;
X	char *memcpy();
X	long where, tail, lseek();
X	void perror(), exit(), disk_flush();
X
X					/* don't use cache? */
X	if (disk_size == 1) {
X		where = (start * MSECTOR_SIZE) + disk_offset;
X		if (lseek(fd, where, 0) < 0) {
X			perror("disk_read: lseek");
X			exit(1);
X		}
X					/* read it! */
X		if (read(fd, (char *) buf, (unsigned int) len) != len) {
X			perror("disk_read: read");
X			exit(1);
X		}
X		return;
X	}
X
X	tail = start + (len / MSECTOR_SIZE) - 1;
X	for (i = start; i <= tail; i++) {
X					/* a "cache" miss */
X		if (i < disk_current || i >= disk_current + disk_size) {
X
X			if (disk_dirty)
X				disk_flush();
X
X			disk_current = (i / disk_size) * disk_size;
X			where = (disk_current * MSECTOR_SIZE) + disk_offset;
X			length = disk_size * MSECTOR_SIZE;
X
X					/* move to next location */
X			if (lseek(fd, where, 0) < 0) {
X				perror("disk_read: lseek");
X				exit(1);
X			}
X					/* read it! */
X			if (read(fd, (char *) disk_buf, (unsigned int) length) != length) {
X				perror("disk_read: read");
X				exit(1);
X			}
X		}
X					/* a cache hit... */
X		buf_ptr = buf + ((i - start) * MSECTOR_SIZE);
X		disk_ptr = disk_buf + ((i - disk_current) * MSECTOR_SIZE);
X		memcpy((char *) buf_ptr, (char *) disk_ptr, MSECTOR_SIZE);
X	}
X	return;
X}
END_OF_FILE
if test 1759 -ne `wc -c <'mtools/buf_read.c'`; then
    echo shar: \"'mtools/buf_read.c'\" unpacked with wrong size!
fi
# end of 'mtools/buf_read.c'
fi
if test -f 'mtools/devices.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/devices.c'\"
else
echo shar: Extracting \"'mtools/devices.c'\" \(2619 characters\)
sed "s/^X//" >'mtools/devices.c' <<'END_OF_FILE'
X/*
X * Device tables.  See the Configure file for a complete description.
X */
X
X#include <stdio.h>
X#include "msdos.h"
X
X#ifdef DELL
Xstruct device devices[] = {
X	{'A', "/dev/rdsk/f0d9dt", 0L, 12, 0, (int (*) ()) 0, 40, 2, 9},
X	{'A', "/dev/rdsk/f0q15dt", 0L, 12, 0, (int (*) ()) 0, 80, 2, 15},
X	{'A', "/dev/rdsk/f0d8dt", 0L, 12, 0, (int (*) ()) 0, 40, 2, 8},
X	{'B', "/dev/rdsk/f13ht", 0L, 12, 0, (int (*) ()) 0, 80, 2, 18},
X	{'B', "/dev/rdsk/f13dt", 0L, 12, 0, (int (*) ()) 0, 80, 2, 9},
X	{'C', "/dev/rdsk/dos", 0L, 16, 0, (int (*) ()) 0, 0, 0, 0},
X	{'\0', (char *) NULL, 0L, 0, 0, (int (*) ()) 0, 0, 0, 0}
X};
X#endif /* DELL */
X
X#ifdef ISC
Xstruct device devices[] = {
X	{'A', "/dev/rdsk/f0d9dt", 0L, 12, 0, (int (*) ()) 0, 40, 2, 9},
X	{'A', "/dev/rdsk/f0q15dt", 0L, 12, 0, (int (*) ()) 0, 80, 2, 15},
X	{'A', "/dev/rdsk/f0d8dt", 0L, 12, 0, (int (*) ()) 0, 40, 2, 8},
X	{'B', "/dev/rdsk/f13ht", 0L, 12, 0, (int (*) ()) 0, 80, 2, 18},
X	{'B', "/dev/rdsk/f13dt", 0L, 12, 0, (int (*) ()) 0, 80, 2, 9},
X	{'C', "/dev/rdsk/0p1", 0L, 16, 0, (int (*) ()) 0, 0, 0, 0},
X	{'D', "/usr/vpix/defaults/C:", 8704L, 12, 0, (int (*) ()) 0, 0, 0, 0},
X	{'E', "$HOME/vpix/C:", 8704L, 12, 0, (int (*) ()) 0, 0, 0, 0},
X	{'\0', (char *) NULL, 0L, 0, 0, (int (*) ()) 0, 0, 0, 0}
X};
X#endif /* ISC */
X
X#ifdef MASSCOMP
Xstruct device devices[] = {
X	{'A', "/dev/rflp", 0L, 12, 0, (int (*) ()) 0, 80, 2, 8},
X	{'\0', (char *) NULL, 0L, 0, 0, (int (*) ()) 0, 0, 0, 0}
X};
X#endif /* MASSCOMP */
X
X#ifdef SPARC
Xstruct device devices[] = {
X	{'A', "/dev/rfd0c", 0L, 12, 0, (int (*) ()) 0, 80, 2, 18},
X	{'A', "/dev/rfd0c", 0L, 12, 0, (int (*) ()) 0, 80, 2, 9},
X	{'\0', (char *) NULL, 0L, 0, 0, (int (*) ()) 0, 0, 0, 0}
X};
X#endif /* SPARC */
X
X#ifdef UNIXPC
X#include <sys/gdioctl.h>
X#include <fcntl.h>
X
Xint init_unixpc();
X
Xstruct device devices[] = {
X	{'A', "/dev/rfp020", 0L, 12, O_NDELAY, init_unixpc, 40, 2, 9},
X	{'C', "/usr/bin/DOS/dvd000", 0L, 12, 0, (int (*) ()) 0, 0, 0, 0},
X	{'\0', (char *) NULL, 0L, 0, 0, (int (*) ()) 0, 0, 0, 0}
X};
X
Xint
Xinit_unixpc(fd, ntracks, nheads, nsect)
Xint fd, ntracks, nheads, nsect;
X{
X	struct gdctl gdbuf;
X
X	if (ioctl(fd, GDGETA, &gdbuf) == -1) {
X		ioctl(fd, GDDISMNT, &gdbuf);
X		return(1);
X	}
X
X	gdbuf.params.cyls = ntracks * nheads;
X	gdbuf.params.heads = nheads;
X	gdbuf.params.psectrk = nsect;
X
X	gdbuf.params.pseccyl = gdbuf.params.psectrk * gdbuf.params.heads;
X	gdbuf.params.flags = 1;		/* disk type flag */
X	gdbuf.params.step = 0;		/* step rate for controller */
X	gdbuf.params.sectorsz = 512;	/* sector size */
X
X	if (ioctl(fd, GDSETA, &gdbuf) < 0) {
X		ioctl(fd, GDDISMNT, &gdbuf);
X		return(1);
X	}
X	return(0);
X}
X#endif /* UNIXPC */
END_OF_FILE
if test 2619 -ne `wc -c <'mtools/devices.c'`; then
    echo shar: \"'mtools/devices.c'\" unpacked with wrong size!
fi
# end of 'mtools/devices.c'
fi
if test -f 'mtools/dir_make.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/dir_make.c'\"
else
echo shar: Extracting \"'mtools/dir_make.c'\" \(2037 characters\)
sed "s/^X//" >'mtools/dir_make.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <time.h>
X#include "msdos.h"
X
Xextern int dir_start, dir_len, clus_size, dir_entries, fat_error, clus_size;
Xextern unsigned int num_clus, end_fat, last_fat;
Xextern long dir_chain[MAX_DIR_SECS];
Xextern unsigned char *dir_buf;
X
X/*
X * Make a subdirectory grow in length.  Only subdirectories (not root)
X * may grow.  Returns a 0 on success, 1 on failure (disk full), or -1
X * on error.
X */
X
Xint
Xdir_grow(fat)
Xunsigned int fat;
X{
X	int i, num, buflen, new;
X	long sector;
X	char *memset(), *realloc();
X	unsigned char *offset, tbuf[MAX_CLUSTER];
X	unsigned int next, last, next_fat(), fat_decode();
X	void perror(), exit(), disk_write(), disk_read();
X
X	last = next_fat(0);
X	if (last == 1)
X		return(1);
X
X	/* CONSTCOND */
X	while (1) {
X		next = fat_decode(fat);
X		if (next == 1) {
X			fprintf(stderr, "dir_grow: FAT problem\n");
X			fat_error++;
X			return(-1);
X		}
X					/* end of cluster chain */
X		if (next >= last_fat)
X			break;
X		fat = next;
X	}
X					/* mark the end of the chain */
X	fat_encode(fat, last);
X	fat_encode(last, end_fat);
X					/* zero the buffer */
X	buflen = clus_size * MSECTOR_SIZE;
X	memset((char *) tbuf, '\0', buflen);
X
X					/* write the cluster */
X	sector = (long) (last - 2) * clus_size + dir_start + dir_len;
X	disk_write(sector, tbuf, buflen);
X
X					/* fix up the globals.... */
X	num = dir_entries / 16;
X	dir_entries += clus_size * 16;
X	for (i = 0; i < clus_size; i++)
X		dir_chain[num + i] = sector + i;
X
X					/* fix up dir_buf.... */
X	new = num + clus_size;
X	dir_buf = (unsigned char *) realloc((char *) dir_buf, (unsigned int) new * MSECTOR_SIZE);
X	if (dir_buf == NULL) {
X		perror("dir_grow: malloc");
X		exit(1);
X	}
X	offset = dir_buf + (num * MSECTOR_SIZE);
X	disk_read(dir_chain[num], offset, clus_size * MSECTOR_SIZE);
X	return(0);
X}
X
X/*
X * Returns next free cluster or 1 if none are available.
X */
X
Xunsigned int
Xnext_fat(last)
Xunsigned int last;
X{
X	register unsigned int i;
X	unsigned int fat_decode();
X
X	for (i = last + 1; i < num_clus + 2; i++) {
X		if (!fat_decode(i))
X			return(i);
X	}
X	return(1);
X}
END_OF_FILE
if test 2037 -ne `wc -c <'mtools/dir_make.c'`; then
    echo shar: \"'mtools/dir_make.c'\" unpacked with wrong size!
fi
# end of 'mtools/dir_make.c'
fi
if test -f 'mtools/expand.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/expand.c'\"
else
echo shar: Extracting \"'mtools/expand.c'\" \(1738 characters\)
sed "s/^X//" >'mtools/expand.c' <<'END_OF_FILE'
X/*
X * Do filename expansion with the shell.  Returns a pointer to a
X * static area.
X */
X
X#define EXPAND_BUF	2048
X
X#include <stdio.h>
X
Xchar *
Xexpand(input)
Xchar *input;
X{
X	FILE *fp, *popen();
X	int last;
X	char buf[256], *strpbrk(), *strcpy();
X	static char ans[EXPAND_BUF];
X
X	if (input == NULL)
X		return(NULL);
X	if (*input == '\0')
X		return("");
X					/* any thing to expand? */
X	if (!strpbrk(input, "$*{}[]\\?~")) {
X		strcpy(ans, input);
X		return(ans);
X	}
X					/* popen an echo */
X	sprintf(buf, "echo %s", input);
X
X	fp = popen(buf, "r");
X	fgets(ans, EXPAND_BUF, fp);
X	pclose(fp);
X
X	if (!strlen(ans)) {
X		strcpy(ans, input);
X		return(ans);
X	}
X
X	/*
X	 * A horrible kludge...  if the last character is not a line feed,
X	 * then the csh has returned an error message.  Otherwise zap the
X	 * line feed.
X	 */
X	last = strlen(ans) - 1;
X	if (ans[last] != '\n') {
X		strcpy(ans, input);
X		return(ans);
X	}
X	else
X		ans[last] = '\0';
X
X	return(ans);
X}
X
X/*
X * Miscellaneous routines probably missing from Bezerkely
X */
X
X#ifdef BSD
X/*
X * Return ptr to first occurrence of any character from `brkset'
X * in the character string `string'; NULL if none exists.
X */
X
Xchar *
Xstrpbrk(string, brkset)
Xregister char *string, *brkset;
X{
X	register char *p;
X
X	if (!string || !brkset)
X		return(0);
X	do {
X		for (p = brkset; *p != '\0' && *p != *string; ++p)
X			;
X		if (*p != '\0')
X			return(string);
X	}
X	while (*string++);
X	return(0);
X}
X
X/*
X * Copies the character c, n times to string s
X */
X
Xchar *
Xmemset(s, c, n)
Xchar *s, c;
Xint n;
X{
X	char *s1 = s;
X
X	while (n > 0) {
X		--n;
X		*s++ = c;
X	}
X	return(s1);
X}
X
X/*
X * Copy contents of memory (with possible overlapping).
X */
X
Xchar *
Xmemcpy(s1, s2, n)
Xchar *s1, *s2;
Xint n;
X{
X	bcopy(s2, s1, n);
X	return(s1);
X}
X#endif /* BSD */
END_OF_FILE
if test 1738 -ne `wc -c <'mtools/expand.c'`; then
    echo shar: \"'mtools/expand.c'\" unpacked with wrong size!
fi
# end of 'mtools/expand.c'
fi
if test -f 'mtools/fat_free.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/fat_free.c'\"
else
echo shar: Extracting \"'mtools/fat_free.c'\" \(728 characters\)
sed "s/^X//" >'mtools/fat_free.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "msdos.h"
X
Xextern int fat_error;
Xextern unsigned int last_fat;
X
X/*
X * Remove a string of FAT entries (delete the file).  The argument is
X * the beginning of the string.  Does not consider the file length, so
X * if FAT is corrupted, watch out!
X */
X
Xint
Xfat_free(fat)
Xunsigned int fat;
X{
X	unsigned int next, fat_decode();
X					/* a zero length file? */
X	if (fat == 0)
X		return(0);
X
X	/* CONSTCOND */
X	while (1) {
X					/* get next cluster number */
X		next = fat_decode(fat);
X					/* mark current cluster as empty */
X		if (fat_encode(fat, 0) || next == 1) {
X			fprintf(stderr, "fat_free: FAT problem\n");
X			fat_error++;
X			return(-1);
X		}
X		if (next >= last_fat)
X			break;
X		fat = next;
X	}
X	return(0);
X}
END_OF_FILE
if test 728 -ne `wc -c <'mtools/fat_free.c'`; then
    echo shar: \"'mtools/fat_free.c'\" unpacked with wrong size!
fi
# end of 'mtools/fat_free.c'
fi
if test -f 'mtools/fat_read.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/fat_read.c'\"
else
echo shar: Extracting \"'mtools/fat_read.c'\" \(2500 characters\)
sed "s/^X//" >'mtools/fat_read.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "msdos.h"
X
Xint fat_len;				/* length of FAT table (in sectors) */
Xunsigned int end_fat;			/* the end-of-chain marker */
Xunsigned int last_fat;			/* the last in a chain marker */
Xunsigned char *fat_buf;			/* the File Allocation Table */
X
Xextern int fat_bits;
X
X/*
X * Get and decode a FAT (file allocation table) entry.  Returns the cluster
X * number on success or 1 on failure.
X */
X
Xunsigned int
Xfat_decode(num)
Xunsigned int num;
X{
X	unsigned int fat, fat_hi, fat_low, byte_1, byte_2;
X	int start;
X
X	if (fat_bits == 12) {
X		/*
X		 *	|    byte n     |   byte n+1    |   byte n+2    |
X		 *	|7|6|5|4|3|2|1|0|7|6|5|4|3|2|1|0|7|6|5|4|3|2|1|0|
X		 *	| | | | | | | | | | | | | | | | | | | | | | | | |
X		 *	| n+0.0 | n+0.5 | n+1.0 | n+1.5 | n+2.0 | n+2.5 |
X		 *	    \_____  \____   \______/________/_____   /
X		 *	      ____\______\________/   _____/  ____\_/
X		 *	     /     \      \          /       /     \
X		 *	| n+1.5 | n+0.0 | n+0.5 | n+2.0 | n+2.5 | n+1.0 |
X		 *	|      FAT entry k      |    FAT entry k+1      |
X		 */
X					/* which bytes contain the entry */
X		start = num * 3 / 2;
X		if (start <= 2 || start + 1 > (fat_len * MSECTOR_SIZE))
X			return(1);
X
X		byte_1 = *(fat_buf + start);
X		byte_2 = *(fat_buf + start + 1);
X					/* (odd) not on byte boundary */
X		if (num % 2) {
X			fat_hi = (byte_2 & 0xff) << 4;
X			fat_low = (byte_1 & 0xf0) >> 4;
X		}
X					/* (even) on byte boundary */
X		else {
X			fat_hi = (byte_2 & 0xf) << 8;
X			fat_low = byte_1 & 0xff;
X		}
X		fat = (fat_hi + fat_low) & 0xfff;
X	}
X	else {
X		/*
X		 *	|    byte n     |   byte n+1    |
X		 *	|7|6|5|4|3|2|1|0|7|6|5|4|3|2|1|0|
X		 *	| | | | | | | | | | | | | | | | |
X		 *	|         FAT entry k           |
X		 */
X					/* which bytes contain the entry */
X		start = num * 2;
X		if (start <= 3 || start + 1 > (fat_len * MSECTOR_SIZE))
X			return(1);
X
X		fat = (*(fat_buf + start + 1) * 0x100) + *(fat_buf + start);
X	}
X	return(fat);
X}
X
X/*
X * Read the entire FAT table into memory.
X */
X
Xvoid
Xfat_read(start)
Xint start;
X{
X	int buflen;
X	char *malloc();
X	void perror(), exit(), disk_read();
X					/* only the first copy of the FAT */
X	buflen = fat_len * MSECTOR_SIZE;
X	fat_buf = (unsigned char *) malloc((unsigned int) buflen);
X	if (fat_buf == NULL) {
X		perror("fat_read: malloc");
X		exit(1);
X	}
X					/* read the FAT sectors */
X	disk_read((long) start, fat_buf, buflen);
X
X					/* the encoding scheme */
X	if (fat_bits == 12) {
X		end_fat = 0xfff;
X		last_fat = 0xff8;
X	}
X	else {
X		end_fat = 0xffff;
X		last_fat = 0xfff8;
X	}
X	return;
X}
END_OF_FILE
if test 2500 -ne `wc -c <'mtools/fat_read.c'`; then
    echo shar: \"'mtools/fat_read.c'\" unpacked with wrong size!
fi
# end of 'mtools/fat_read.c'
fi
if test -f 'mtools/fat_write.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/fat_write.c'\"
else
echo shar: Extracting \"'mtools/fat_write.c'\" \(2442 characters\)
sed "s/^X//" >'mtools/fat_write.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "msdos.h"
X
Xextern int fd, dir_start, num_fat, fat_len, fat_error, fat_bits;
Xextern unsigned char *fat_buf;
X
X/*
X * Puts a code into the FAT table.  Is the opposite of fat_decode().  No
X * sanity checking is done on the code.  Returns a 1 on error.
X */
X
Xint
Xfat_encode(num, code)
Xunsigned int num;
Xunsigned int code;
X{
X	int start;
X
X	if (fat_bits == 12) {
X		/*
X		 *	|    byte n     |   byte n+1    |   byte n+2    |
X		 *	|7|6|5|4|3|2|1|0|7|6|5|4|3|2|1|0|7|6|5|4|3|2|1|0|
X		 *	| | | | | | | | | | | | | | | | | | | | | | | | |
X		 *	| n+0.0 | n+0.5 | n+1.0 | n+1.5 | n+2.0 | n+2.5 |
X		 *	    \_____  \____   \______/________/_____   /
X		 *	      ____\______\________/   _____/  ____\_/
X		 *	     /     \      \          /       /     \
X		 *	| n+1.5 | n+0.0 | n+0.5 | n+2.0 | n+2.5 | n+1.0 |
X		 *	|      FAT entry k      |    FAT entry k+1      |
X		 */
X					/* which bytes contain the entry */
X		start = num * 3 / 2;
X		if (start <= 2 || start + 1 > (fat_len * MSECTOR_SIZE))
X			return(1);
X					/* (odd) not on byte boundary */
X		if (num % 2) {
X			*(fat_buf + start) = (*(fat_buf + start) & 0x0f) + ((code << 4) & 0xf0);
X			*(fat_buf + start + 1) = (code >> 4) & 0xff;
X		}
X					/* (even) on byte boundary */
X		else {
X			*(fat_buf + start) = code & 0xff;
X			*(fat_buf + start + 1) = (*(fat_buf + start + 1) & 0xf0) + ((code >> 8) & 0x0f);
X		}
X	}
X	else {
X		/*
X		 *	|    byte n     |   byte n+1    |
X		 *	|7|6|5|4|3|2|1|0|7|6|5|4|3|2|1|0|
X		 *	| | | | | | | | | | | | | | | | |
X		 *	|         FAT entry k           |
X		 */
X					/* which bytes contain the entry */
X		start = num * 2;
X		if (start <= 3 || start + 1 > (fat_len * MSECTOR_SIZE))
X			return(1);
X
X		*(fat_buf + start + 1) =  code / 0x100;
X		*(fat_buf + start) =  code % 0x100;
X	}
X	return(0);
X}
X
X/*
X * Write the FAT table to the disk.  Up to now the FAT manipulation has
X * been done in memory.  All errors are fatal.  (Might not be too smart
X * to wait till the end of the program to write the table.  Oh well...)
X */
X
Xvoid
Xfat_write()
X{
X	int fat_start, buflen, dups;
X	void disk_write();
X
X	if (fd < 0)
X		return;
X
X	fat_start = dir_start - (fat_len * num_fat);
X	buflen = fat_len * MSECTOR_SIZE;
X
X	disk_write((long) fat_start, fat_buf, buflen);
X
X	/*
X	 * Only duplicate the FAT table if no errors were detected
X	 */
X	if (!fat_error) {
X		dups = num_fat - 1;
X		while (dups--) {
X			fat_start += fat_len;
X			disk_write((long) fat_start, fat_buf, buflen);
X		}
X	}
X	return;
X}
END_OF_FILE
if test 2442 -ne `wc -c <'mtools/fat_write.c'`; then
    echo shar: \"'mtools/fat_write.c'\" unpacked with wrong size!
fi
# end of 'mtools/fat_write.c'
fi
if test -f 'mtools/file_read.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/file_read.c'\"
else
echo shar: Extracting \"'mtools/file_read.c'\" \(1825 characters\)
sed "s/^X//" >'mtools/file_read.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "msdos.h"
X
Xextern int clus_size, dir_start, dir_len, fat_error;
Xextern unsigned int last_fat;
X
X/*
X * Read the clusters given the beginning FAT entry.  Returns 0 on success.
X */
X
Xint
Xfile_read(fp, fat, textmode, stripmode, size)
XFILE *fp;
Xunsigned int fat;
Xint textmode, stripmode;
Xlong size;
X{
X	register int i;
X	int in_len, out_len;
X	unsigned int fat_decode();
X	long current, start;
X	unsigned char in_buf[MAX_CLUSTER], out_buf[MAX_CLUSTER];
X	void disk_read(), perror();
X
X	current = 0L;
X	in_len = clus_size * MSECTOR_SIZE;
X					/* a zero length file? */
X	if (fat == 0)
X		return(0);
X
X	/* CONSTCOND */
X	while (1) {
X		start = (long) (fat - 2) * clus_size + dir_start + dir_len;
X		disk_read(start, in_buf, in_len);
X
X					/* do the translations */
X		if (textmode || stripmode) {
X			out_len = 0;
X			for (i = 0; i < in_len; i++) {
X				current++;
X				if (current > size)
X					break;
X				if (textmode && in_buf[i] == '\r')
X					continue;
X				if (textmode && current == size && in_buf[i] == 0x1a)
X					continue;
X				if (stripmode)
X					out_buf[out_len++] = in_buf[i] & 0x7f;
X				else
X					out_buf[out_len++] = in_buf[i];
X			}
X					/* write it */
X			if (fwrite((char *) out_buf, sizeof(*out_buf), out_len, fp) == 0) {
X				perror("file_write: fwrite");
X				return(-1);
X			}
X		}
X					/* much easier... */
X		else {
X			out_len = (size - current > in_len) ? in_len : size - current;
X			if (fwrite((char *) in_buf, sizeof(*in_buf), out_len, fp) == 0) {
X				perror("file_write: fwrite");
X				return(-1);
X			}
X
X			current += out_len;
X			if (current >= size)
X				break;
X		}
X
X					/* get next cluster number */
X		fat = fat_decode(fat);
X		if (fat == 1) {
X			fprintf(stderr, "file_read: FAT problem\n");
X			fat_error++;
X			return(-1);
X		}
X					/* end of cluster chain */
X		if (fat >= last_fat)
X			break;
X	}
X	return(0);
X}
END_OF_FILE
if test 1825 -ne `wc -c <'mtools/file_read.c'`; then
    echo shar: \"'mtools/file_read.c'\" unpacked with wrong size!
fi
# end of 'mtools/file_read.c'
fi
if test -f 'mtools/file_write.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/file_write.c'\"
else
echo shar: Extracting \"'mtools/file_write.c'\" \(2342 characters\)
sed "s/^X//" >'mtools/file_write.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "msdos.h"
X
Xextern int full, fat_error, clus_size, dir_start, dir_len;
Xextern unsigned end_fat;
X
Xstatic int need_nl, put_cluster();
X
X/*
X * Write out clusters with input from the given file pointer.   Returns the
X * size of the file (which may have changed) or -1 on error.
X */
X
Xlong
Xfile_write(fp, firstfat, filesize, textmode)
XFILE *fp;
Xunsigned int firstfat;
Xlong filesize;
Xint textmode;
X{
X	int i;
X	unsigned int fat, oldfat, next_fat();
X	long size;
X
X	oldfat = 0;
X	fat = firstfat;
X	need_nl = 0;
X	size = 0L;
X
X	/* CONSTCOND */
X	while (1) {
X		if ((i = put_cluster(fp, fat, &filesize, textmode)) < 0) {
X			if (oldfat) {
X				fat_encode(oldfat, end_fat);
X				if (fat_free(firstfat))
X					fat_error++;
X				full = 1;
X			}
X			return(-1);
X		}
X
X		size += i;
X		if (size >= filesize) {
X			fat_encode(fat, end_fat);
X			break;
X		}
X		oldfat = fat;
X					/* get next free cluster */
X		fat = next_fat(oldfat);
X		if (fat == 1) {
X			fat_encode(oldfat, end_fat);
X					/* delete it, if doesn't fit */
X			if (fat_free(firstfat))
X				fat_error++;
X			full = 1;
X			return(-1);
X		}
X		fat_encode(oldfat, fat);
X	}
X	return(size);
X}
X
X/*
X * Write to the cluster from the named Unix file descriptor.  Returns the
X * size of what was written, or -1 on error.
X */
X
Xstatic int
Xput_cluster(fp, num, filesize, textmode)
XFILE *fp;
Xunsigned int num;
Xlong *filesize;
Xint textmode;
X{
X	int i, buflen, c;
X	long start;
X	unsigned char tbuf[MAX_CLUSTER];
X	void disk_write(), perror();
X
X	start = (long) (num - 2) * clus_size + dir_start + dir_len;
X	buflen = clus_size * MSECTOR_SIZE;
X					/* '\n' to '\r\n' translation */
X	if (textmode) {
X		i = 0;
X		if (need_nl) {
X			tbuf[i++] = '\n';
X			need_nl = 0;
X		}
X		while (i < buflen) {
X			if ((c = fgetc(fp)) == EOF) {
X					/* put a file EOF marker */
X				tbuf[i++] = 0x1a;
X					/* make the file appear larger */
X				*filesize = *filesize + 1;
X				break;
X			}
X			if (c == '\n') {
X				tbuf[i++] = '\r';
X					/* make the file appear larger */
X				*filesize = *filesize + 1;
X					/* if at the end of the buffer */
X				if (i == buflen) {
X					need_nl++;
X					break;
X				}
X			}
X			tbuf[i++] = (unsigned char) c;
X		}
X	}
X					/* much easier.... */
X	else {
X		if ((i = fread((char *) tbuf, sizeof(*tbuf), buflen, fp)) <= 0) {
X			perror("putcluster: fread");
X			return(-1);
X		}
X	}
X
X	disk_write(start, tbuf, buflen);
X	return(i);
X}
END_OF_FILE
if test 2342 -ne `wc -c <'mtools/file_write.c'`; then
    echo shar: \"'mtools/file_write.c'\" unpacked with wrong size!
fi
# end of 'mtools/file_write.c'
fi
if test -f 'mtools/is_dir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/is_dir.c'\"
else
echo shar: Extracting \"'mtools/is_dir.c'\" \(907 characters\)
sed "s/^X//" >'mtools/is_dir.c' <<'END_OF_FILE'
X/*
X * Test to see if a filename is a directory.  Subdir() has to be called
X * on the directory above this one first...  Returns 1 if true.
X */
X
X#include <stdio.h>
X#include "msdos.h"
X
Xextern int dir_entries;
X
Xint
Xis_dir(path)
Xchar *path;
X{
X	register int entry;
X	char *newname, *unix_name();
X	struct directory *dir, *dir_read();
X					/* no path */
X	if (*path == '\0')
X		return(0);
X
X	for (entry = 0; entry < dir_entries; entry++) {
X		dir = dir_read(entry);
X					/* if empty */
X		if (dir->name[0] == 0x0)
X			break;
X					/* if erased */
X		if (dir->name[0] == 0xe5)
X			continue;
X					/* skip if not a directory */
X		if (!(dir->attr & 0x10))
X			continue;
X
X		newname = unix_name(dir->name, dir->ext);
X		if (match(newname, path))
X			return(1);
X	}
X
X	/*
X	 * If the file is "." or ".." but it fails to match, then you
X	 * must be at root
X	 */
X	if (!strcmp(path, ".") || !strcmp(path, ".."))
X		return(1);
X
X	return(0);
X}
END_OF_FILE
if test 907 -ne `wc -c <'mtools/is_dir.c'`; then
    echo shar: \"'mtools/is_dir.c'\" unpacked with wrong size!
fi
# end of 'mtools/is_dir.c'
fi
if test -f 'mtools/match.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/match.c'\"
else
echo shar: Extracting \"'mtools/match.c'\" \(1657 characters\)
sed "s/^X//" >'mtools/match.c' <<'END_OF_FILE'
X/*
X * Do shell-style pattern matching for '?', '\', '[..]', and '*' wildcards.
X * Returns 1 if match, 0 if not.
X */
X
X#include <stdio.h>
X
Xint
Xmatch(s, p)
Xchar *s, *p;
X{
X	int matched, reverse;
X	char first, last;
X
X	for (; *p != '\0'; s++, p++) {
X		switch (*p) {
X			case '?':	/* match any one character */
X				if (*s == '\0')
X					return(0);
X				break;
X			case '*':	/* match everything */
X				while (*p == '*')
X					p++;
X
X					/* if last char in pattern */
X				if (*p == '\0')
X					return(1);
X
X					/* search for next char in pattern */
X				matched = 0;
X				while (*s != '\0') {
X					if (*s == *p) {
X						matched = 1;
X						break;
X					}
X					s++;
X				}
X				if (!matched)
X					return(0);
X				break;
X			case '[':	 /* match range of characters */
X				first = '\0';
X				matched = 0;
X				reverse = 0;
X				while (*++p != ']') {
X					if (*p == '^') {
X						reverse = 1;
X						p++;
X					}
X					first = *p;
X					if (first == ']' || first == '\0')
X						return(0);
X
X					/* if 2nd char is '-' */
X					if (*(p + 1) == '-') {
X						p++;
X					/* set last to 3rd char ... */
X						last = *++p;
X						if (last == ']' || last == '\0')
X							return(0);
X					/* test the range of values */
X						if (*s >= first && *s <= last) {
X							matched = 1;
X							p++;
X							break;
X						}
X						return(0);
X					}
X					if (*s == *p)
X						matched = 1;
X				}
X				if (matched && reverse)
X					return(0);
X				if (!matched)
X					return(0);
X				break;
X			case '\\':	/* Literal match with next character */
X				p++;
X				/* fall thru */
X			default:
X				if (*s != *p)
X					return(0);
X				break;
X		}
X	}
X					/* string ended prematurely ? */
X	if (*s != '\0')
X		return(0);
X	else
X		return(1);
X}
END_OF_FILE
if test 1657 -ne `wc -c <'mtools/match.c'`; then
    echo shar: \"'mtools/match.c'\" unpacked with wrong size!
fi
# end of 'mtools/match.c'
fi
if test -f 'mtools/mkmanifest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/mkmanifest.c'\"
else
echo shar: Extracting \"'mtools/mkmanifest.c'\" \(2306 characters\)
sed "s/^X//" >'mtools/mkmanifest.c' <<'END_OF_FILE'
X/*
X * A program to create a manifest (shiping list) that is a shell script
X * to return a Unix file name to it's original state after it has been
X * clobbered by MSDOS's file name restrictions.
X *
X *	This code also used in arc, mtools, and pcomm
X */
X
X#ifdef BSD
X#define strrchr rindex
X#endif /* BSD */
X
X#include <stdio.h>
X#include <ctype.h>
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int i;
X	char *name, *new_name, *dos_name(), *strrchr();
X	void exit();
X
X	if (argc == 1) {
X		fprintf(stderr, "Usage: mkmanifest <list-of-files>\n");
X		exit(1);
X	}
X
X	for (i=1; i<argc; i++) {
X					/* zap the leading path */
X		if (name = strrchr(argv[i], '/'))
X			name++;
X		else
X			name = argv[i];
X					/* create new name */
X		new_name = dos_name(name);
X
X		if (strcmp(new_name, name))
X			printf("mv %s %s\n", new_name, name);
X	}
X	exit(0);
X}
X
Xchar *
Xdos_name(name)
Xchar *name;
X{
X	static char *dev[9] = {"con", "aux", "com1", "com2", "lpt1", "prn",
X	"lpt2", "lpt3", "nul"};
X	char *s, *temp, *ext, *strcpy(), *strpbrk(), *strcat();
X	char buf[15];
X	int i, dot;
X	static char ans[13];
X
X	strcpy(buf, name);
X	temp = buf;
X					/* separate the name from extention */
X	ext = "";
X	dot = 0;
X	for (i=strlen(buf)-1; i>=0; i--) {
X		if (buf[i] == '.' && !dot) {
X			dot = 1;
X			buf[i] = '\0';
X			ext = &buf[i+1];
X		}
X		if (isupper(buf[i]))
X			buf[i] = tolower(buf[i]);
X	}
X					/* if no name */
X	if (*temp == '\0')
X		temp = "x";
X					/* if name is a device */
X	for (i=0; i<9; i++) {
X		if (!strcmp(temp, dev[i])) 
X			*temp = 'x';
X	}
X					/* name too long? */
X	if (strlen(temp) > 8)
X		*(temp+8) = '\0';
X					/* extention too long? */
X	if (strlen(ext) > 3)
X		*(ext+3) = '\0';
X					/* illegal characters? */
X	while (s = strpbrk(temp, "^+=/[]:',?*\\<>|\". "))
X		*s = 'x';
X
X	while (s = strpbrk(ext, "^+=/[]:',?*\\<>|\". "))
X		*s = 'x';
X
X	strcpy(ans, temp);
X	if (*ext) {
X		strcat(ans, ".");
X		strcat(ans, ext);
X	}
X	return(ans);
X}
X
X#ifdef BSD
X/*
X * Return ptr to first occurrence of any character from `brkset'
X * in the character string `string'; NULL if none exists.
X */
X
Xchar *
Xstrpbrk(string, brkset)
Xregister char *string, *brkset;
X{
X	register char *p;
X
X	if (!string || !brkset)
X		return(0);
X	do {
X		for (p = brkset; *p != '\0' && *p != *string; ++p)
X			;
X		if (*p != '\0')
X			return(string);
X	}
X	while (*string++);
X	return(0);
X}
X#endif /* BSD */
END_OF_FILE
if test 2306 -ne `wc -c <'mtools/mkmanifest.c'`; then
    echo shar: \"'mtools/mkmanifest.c'\" unpacked with wrong size!
fi
# end of 'mtools/mkmanifest.c'
fi
if test -f 'mtools/msdos.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/msdos.h'\"
else
echo shar: Extracting \"'mtools/msdos.h'\" \(2049 characters\)
sed "s/^X//" >'mtools/msdos.h' <<'END_OF_FILE'
X/*
X * msdos common header file
X */
X
X#define MSECTOR_SIZE	512		/* MSDOS sector size in bytes */
X#define MDIR_SIZE	32		/* MSDOS directory size in bytes */
X#define MAX_CLUSTER	8192		/* largest cluster size */
X#define MAX_PATH	128		/* largest MSDOS path length */
X#define MAX_DIR_SECS	64		/* largest directory (in sectors) */
X
X#define NEW		1
X#define OLD		0
X
Xstruct directory {
X	unsigned char name[8];		/* file name */
X	unsigned char ext[3];		/* file extension */
X	unsigned char attr;		/* attribute byte */
X	unsigned char reserved[10];	/* ?? */
X	unsigned char time[2];		/* time stamp */
X	unsigned char date[2];		/* date stamp */
X	unsigned char start[2];		/* starting cluster number */
X	unsigned char size[4];		/* size of the file */
X};
X
Xstruct device {
X	char drive;			/* the drive letter */
X	char *name;			/* full path to device */
X	long offset;			/* skip this many bytes */
X	int fat_bits;			/* FAT encoding scheme */
X	int mode;			/* any special open() flags */
X	int (*gioctl) ();		/* gioctl() function if needed */
X	int tracks;			/* tracks */
X	int heads;			/* heads */
X	int sectors;			/* sectors */
X};
X
Xstruct bootsector {
X	unsigned char jump[3];		/* Jump to boot code */
X	unsigned char banner[8];	/* OEM name & version */
X	unsigned char secsiz[2];	/* Bytes per sector hopefully 512 */
X	unsigned char clsiz;		/* Cluster size in sectors */
X	unsigned char nrsvsect[2];	/* Number of reserved (boot) sectors */
X	unsigned char nfat;		/* Number of FAT tables hopefully 2 */
X	unsigned char dirents[2];	/* Number of directory slots */
X	unsigned char psect[2];		/* Total sectors on disk */
X	unsigned char descr;		/* Media descriptor=first byte of FAT */
X	unsigned char fatlen[2];	/* Sectors in FAT */
X	unsigned char nsect[2];		/* Sectors/track */
X	unsigned char nheads[2];	/* Heads */
X	unsigned char nhs[4];		/* number of hidden sectors */
X	unsigned char bigsect[4];	/* big total sectors */
X	unsigned char junk[476];	/* who cares? */
X};
X
Xtypedef void SIG_TYPE;
X/* typedef int SIG_TYPE; */
X
X#ifdef BSD
X#define strchr index
X#define strrchr rindex
X#endif /* BSD */
END_OF_FILE
if test 2049 -ne `wc -c <'mtools/msdos.h'`; then
    echo shar: \"'mtools/msdos.h'\" unpacked with wrong size!
fi
# end of 'mtools/msdos.h'
fi
if test -f 'mtools/parse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/parse.c'\"
else
echo shar: Extracting \"'mtools/parse.c'\" \(2194 characters\)
sed "s/^X//" >'mtools/parse.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <ctype.h>
X#include "msdos.h"
X
Xextern char *mcwd;
X
X/*
X * Get name component of filename.  Translates name to upper case.  Returns
X * pointer to static area.
X */
X
Xchar *
Xget_name(filename)
Xchar *filename;
X{
X	char *s, *temp, *strcpy(), *strrchr(), buf[MAX_PATH];
X	static char ans[13];
X
X	strcpy(buf, filename);
X	temp = buf;
X					/* skip drive letter */
X	if (buf[0] && buf[1] == ':')
X		temp = &buf[2];
X					/* find the last separator */
X	if (s = strrchr(temp, '/'))
X		temp = s + 1;
X	if (s = strrchr(temp, '\\'))
X		temp = s + 1;
X					/* xlate to upper case */
X	for (s = temp; *s; ++s) {
X		if (islower(*s))
X			*s = toupper(*s);
X	}
X
X	strcpy(ans, temp);
X	return(ans);
X}
X
X/*
X * Get the path component of the filename.  Translates to upper case.
X * Returns pointer to a static area.  Doesn't alter leading separator,
X * always strips trailing separator (unless it is the path itself).
X */
X
Xchar *
Xget_path(filename)
Xchar *filename;
X{
X	char *s, *end, *begin, *strcpy(), *strrchr(), buf[MAX_PATH];
X	char drive, *strcat();
X	static char ans[MAX_PATH];
X	int has_sep;
X
X	strcpy(buf, filename);
X	begin = buf;
X					/* skip drive letter */
X	drive = '\0';
X	if (buf[0] && buf[1] == ':') {
X		drive = (islower(buf[0])) ? toupper(buf[0]) : buf[0];
X		begin = &buf[2];
X	}
X					/* if absolute path */
X	if (*begin == '/' || *begin == '\\')
X		ans[0] = '\0';
X	else {
X		if (!drive || drive == *mcwd)
X			strcpy(ans, mcwd + 2);
X		else
X			strcpy(ans, "/");
X	}
X					/* find last separator */
X	has_sep = 0;
X	end = begin;
X	if (s = strrchr(end, '/')) {
X		has_sep++;
X		end = s;
X	}
X	if (s = strrchr(end, '\\')) {
X		has_sep++;
X		end = s;
X	}
X					/* zap the trailing separator */
X	*end = '\0';
X					/* translate to upper case */
X	for (s = begin; *s; ++s) {
X		if (islower(*s))
X			*s = toupper(*s);
X		if (*s == '\\')
X			*s = '/';
X	}
X					/* if separator alone, put it back */
X	if (!strlen(begin) && has_sep)
X		strcat(ans, "/");
X
X	strcat(ans, begin);
X	return(ans);
X}
X
X/*
X * get the drive letter designation
X */
X
Xchar
Xget_drive(filename)
Xchar *filename;
X{
X	if (*filename && *(filename + 1) == ':') {
X		if (islower(*filename))
X			return(toupper(*filename));
X		else
X			return(*filename);
X	}
X	else
X		return(*mcwd);
X}
END_OF_FILE
if test 2194 -ne `wc -c <'mtools/parse.c'`; then
    echo shar: \"'mtools/parse.c'\" unpacked with wrong size!
fi
# end of 'mtools/parse.c'
fi
if test -f 'mtools/patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/patchlevel.h'\"
else
echo shar: Extracting \"'mtools/patchlevel.h'\" \(385 characters\)
sed "s/^X//" >'mtools/patchlevel.h' <<'END_OF_FILE'
X#define VERSION	"2.0.5"
X#define DATE	"25 Aug 91"
X
X/*
X * Version 1.0		13 Oct 86
X * Version 1.1		11 Jan 87
X * Version 1.2		11 Jun 87
X * Version 1.3		15 Jun 88
X * Version 1.4		28 Sep 88
X * Version 1.5		 9 Oct 88
X * Version 1.6		 3 May 89
X * Version 2.0		 8 Sep 90
X *  patch #1		12 Oct 90
X *  patch #2		21 Nov 90
X *  patch #3		28 Nov 90
X *  patch #4		11 Apr 91
X *  patch #5		25 Aug 91
X */
END_OF_FILE
if test 385 -ne `wc -c <'mtools/patchlevel.h'`; then
    echo shar: \"'mtools/patchlevel.h'\" unpacked with wrong size!
fi
# end of 'mtools/patchlevel.h'
fi
if test -f 'mtools/subdir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mtools/subdir.c'\"
else
echo shar: Extracting \"'mtools/subdir.c'\" \(2167 characters\)
sed "s/^X//" >'mtools/subdir.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "msdos.h"
X
Xextern int dir_entries;
Xstatic int descend();
X
X/*
X * Descends the directory tree.  Returns 1 on error.  Attempts to optimize by
X * remembering the last path it parsed
X */
X
Xint
Xsubdir(drive, pathname)
Xchar drive;
Xchar *pathname;
X{
X	char *s, *tmp, tbuf[MAX_PATH], *path, *strcpy();
X	static char last_drive, lastpath[MAX_PATH];
X	int code;
X	void reset_chain();
X
X	strcpy(tbuf, pathname);
X					/* if paths are same, do nothing */
X	if (!strcmp(tbuf, lastpath) && last_drive == drive)
X		return(0);
X					/* start at root */
X	reset_chain(OLD);
X	strcpy(lastpath, tbuf);
X	last_drive = drive;
X					/* separate the parts */
X	tmp = &tbuf[1];
X	for (s = tmp; *s; ++s) {
X		if (*s == '/') {
X			path = tmp;
X			*s = '\0';
X			if (descend(path))
X				return(1);
X			tmp = s + 1;
X		}
X	}
X	code = descend(tmp);
X	return(code);
X}
X
X/*
X * Find the directory and load a new dir_chain[].  A null directory
X * is ok.  Returns a 1 on error.
X */
X
Xstatic int
Xdescend(path)
Xchar *path;
X{
X	int entry;
X	unsigned int start;
X	char *newname, *unix_name();
X	struct directory *dir, *dir_read();
X	void reset_chain();
X					/* nothing required */
X	if (*path == '\0')
X		return(0);
X
X	for (entry = 0; entry < dir_entries; entry++) {
X		dir = dir_read(entry);
X					/* if empty */
X		if (dir->name[0] == 0x0)
X			break;
X					/* if erased */
X		if (dir->name[0] == 0xe5)
X			continue;
X					/* skip if not a directory */
X		if (!(dir->attr & 0x10))
X			continue;
X
X		newname = unix_name(dir->name, dir->ext);
X
X		/*
X		 * Be careful not to match '.' and '..' with wildcards
X		 */
X		if (*newname == '.' && *path != '.')
X			continue;
X
X		if (match(newname, path)) {
X			start = dir->start[1] * 0x100 + dir->start[0];
X
X					/* if '..' points to root */
X			if (!start && !strcmp(path, "..")) {
X				reset_chain(OLD);
X				return(0);
X			}
X					/* fill in the directory chain */
X			if (fill_chain(start))
X				return(1);
X
X			return(0);
X		}
X	}
X
X	/*
X	 * If path is '.' or '..', but they weren't found, then you must be
X	 * at root.
X	 */
X	if (!strcmp(path, ".") || !strcmp(path, "..")) {
X		reset_chain(OLD);
X		return(0);
X	}
X	fprintf(stderr, "Path component \"%s\" is not a directory\n", path);
X	return(1);
X}
END_OF_FILE
if test 2167 -ne `wc -c <'mtools/subdir.c'`; then
    echo shar: \"'mtools/subdir.c'\" unpacked with wrong size!
fi
# end of 'mtools/subdir.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
