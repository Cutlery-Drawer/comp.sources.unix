Newsgroups: comp.sources.unix
From: ehrlich@margaux.inria.fr (Robert Ehrlich)
Subject: v25i072: ofiles2 - a portable version of ofiles (show list of open files)
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: ehrlich@margaux.inria.fr (Robert Ehrlich)
Posting-Number: Volume 25, Issue 72
Archive-Name: ofiles2

[ I grabbed the Makefile and man page from the last version of ofiles that
  was posted here; the man page needed some editing, which I did, so if there
  are bugs in the man page it's my fault.				--vix ]

This is a heavily reworked version of ofiles. Ofiles shows identifys the
opener of a file.  It was modified to be more portable and is known to work
on several architectures :

        - Suns 3 and 4 under SunOs from 3.0 to 4.1.1
        - Sony 1xxx 68k under newsOS 3.0 to 4.0
        - Sony 3xxx RISC under newsOS 3.5 to 4.0
        - Decstation 3100 under Ultrix 2.2 to 4.1
        - Pyramid OSX 5.0 (with vtophys.c from OSX sources)
        - Vax BSD4.3 and Ultrix
        - Sequent DYNIX 3.0

The author of the rework is Robert Ehrlich (ehrlich@margaux.inria.fr).

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  MANIFEST Makefile README ofiles.8l ofiles.c
# Wrapped by vixie@cognition.pa.dec.com on Fri Dec 20 14:31:10 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(251 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	
X Makefile                   1	
X README                     1	
X ofiles.8l                  1	
X ofiles.c                   1	
END_OF_FILE
if test 251 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(738 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X#	Makefile for ofiles
X#
X
PROG=	ofiles
BIN=	${DESTDIR}/usr/local/etc
X
I=/usr/include
S=/usr/include/sys
L=/usr/include/local
X
INCLUDE=
DEBUG=	-O
CDEFS=  
CFLAGS= ${DEBUG} ${CDEFS} ${INCLUDE}
X
HDR=	
ONEC=	ofiles.c
OTHER=	
SOURCE=	Makefile ${HDR} ${ONEC} ${OTHER}
X
all: ${PROG}
X
X# SunOS 4.0 needs -lkvm in the following rule
X
X${PROG}:
X	${CC} -o $@ ${CFLAGS} ${ONEC} 
X
clean: FRC
X	rm -f Makefile.bak ${PROG} *.o a.out core errs tags
X
install: all FRC
X	install -cs -m 2755 -g kmem ${PROG} ${BIN}
X
lint: ${HDR} ${ONEC} FRC
X	lint ${CDEFS} ${INCLUDE} ${ONEC}
X
print: source FRC
X	lpr -J'${PROG} source' ${SOURCE}
X
source: ${SOURCE}
X
spotless: clean
X	rcsclean ${SOURCE}
X
tags: ${HDR} ${ONEC}
X	ctags -t ${HDR} ${ONEC}
X
X${SOURCE}:
X	co -q $@
X
XFRC:
X
END_OF_FILE
if test 738 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1088 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
This is a heavily reworked version of ofiles. Ofiles shows identifys the
opener of a file.
It was modified to be more portable and is known to work on several
architectures :
X	- Suns 3 and 4 under SunOs from 3.0 to 4.1.1
X	- Sony 1xxx 68k under newsOS 3.0 to 4.0
X	- Sony 3xxx RISC under newsOS 3.5 to 4.0
X	- Decstation 3100 under Ultrix 2.2 to 4.1
X	- Pyramid OSX 5.0 (with vtophys.c from OSX sources)
X	- Vax BSD4.3 and Ultrix
X	- Sequent DYNIX 3.0
This is a heavily reworked version of ofiles. Ofiles shows identifies the
opener of a file.
It has proved to be very portable, and should work on many other
architectures if you mess a little bit with the #defines. The code base is
all there, but it needs configuration.
X
There is no makefile because it is so simple to compile. You just need to
provide the right libraries :
Sun:
X	cc ofiles.c -o ofiles -lkvm
Sony:
X	cc ofiles.c -o ofiles -lmld
It needs two things : a symbol extraction library and a kernel memory access
library. On most systems one or the other is already in the libc.
X
X
Send Bugs and comments to ehrlich@margaux.inria.fr.
END_OF_FILE
if test 1088 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'ofiles.8l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ofiles.8l'\"
else
echo shar: Extracting \"'ofiles.8l'\" \(5890 characters\)
sed "s/^X//" >'ofiles.8l' <<'END_OF_FILE'
X.TH OFILES 8L LOCAL
X.SH NAME
ofiles \- show owner of open file or network connection
X.SH SYNOPSIS
X.B ofiles
X[
X.B \-Dnpimfd
X] [
X.B \-k
X.I nlist
X.I core
X]
X.I names
X.SH DESCRIPTION
X.I Ofiles
displays the owner, process identification (PID), type, command and
the number of the inode associated with an open instance of a file
or a network connection.
X.PP
An open file may be a regular file, a file system or a directory;
it is specified by its path name.
When the path name refers to a file system,
X.I ofiles
will display the owners of all open instances of files in the system.
X.PP
An open network connection is specified by the kernel address of its
Protocol Control Block (PCB), as displayed by
X.IR netstat (8),
when its
X.B \-A
option is specified.
X.SH OPTIONS
X.I Ofiles
displays information about its usage if no options are specified.
X.TP \w'-kXnlistXcore'u+4
X.BI \-D
This option selects verbose, debugging output.
X.TP
X.BI \-k \ nlist\ core
This option may be used only on DYNIX hosts.
It sets optional name list and core file paths.
X.IP
X.I Nlist
is the path to the file from which
X.I ofiles
should obtain the addresses of kernel symbols,
instead of from
X.IR /dynix .
X.IP
X.I Core
is the path to the file from which
X.I ofiles
should obtain the value of kernel symbols,
instead of from
X.IR /dev/mem .
X.IP
This option is useful for debugging system crash dumps.
X.TP
X.B \-n
This option specifies that the
X.I name
arguments identify network connections by their hexadecimal, Protocol
Control Block (PCB) addresses.
PCB addresses can be obtained via the
X.B \-A
option of
X.IR netstat (1).
X.IP
This option makes it possible to determine the local processes that
are using network connections in the LISTEN through ESTABLISHED states.
X.TP
X.B \-p 
This option specifies that
X.I ofiles
should print process identifiers only \- e. g., so that the output may
be piped to
X.IR kill (1).
X.TP
X.B "\-m, \-f, \-d"
These options force the argument to be considered a
mount point, regular file, and device respectively.
X.TP
X.I names
These are path names of files, directories and file systems;
or, if the
X.B \-n
option has been specified, network connections, identified by their
hexadecimal Protocol Control Block (PCB) addresses.
X.SH OUTPUT
X.I Ofiles
displays for each
X.IR name :
X.TP \w'name/linkages'u+4
X.I name/linkages
for file paths, an interpretation of the type of name \- file, directory
or file system;
for network connections, the kernel address linkages, starting with the file
structure and proceeding through the socket structure and the Internet
Protocol Control Block (INPCB) structure to the PCB
X.TP
X.B USER
the login name of the user of the process that has
X.I name
open
X.TP
X.B PID
the identifier of the process that has
X.I name
open
X.TP
X.B TYPE
a file type explanation:
X.RS
X.TP \w'file'u+4
X.B cwd 
if
X.I name
is the current working directory of the process
X.TP
X.B file
if
X.I name
is being used as a regular file by the process, optionally followed by:
X.RS
X.TP
X.B /s
if the process has a shared lock on the file
X.TP
X.B /x
if the process has an exclusive lock on the file
X.RE
X.TP
X.B rdir
if 
X.I name
is the root directory of the process
X.TP
X.B sock
if
X.I name
is a socket
X.RE
X.TP
X.B FD
the file descriptor number, local to the process
X.TP
X.B CMD
the user command that opened
X.I name
X.TP
X.B INODE
the inode number of the file
X.SH EXAMPLES
This example shows the use of
X.I ofiles
to discover the owner of the open, regular file,
X.IR /usr/spool/lpd/lock .
X.PP
X.RS
X.nf
X% ofiles /usr/spool/lpd/lock
X.br
X/usr/spool/lpd/lock	
X.br
USER	PID	TYPE  	FD	CMD	INODE
X.br
root	110	file/x	 3	lpd	26683
X.fi
X.RE
X.PP
This example shows the use of
X.IR netstat (1),
X.IR grep (1)
and
X.I ofiles
to identify the local endpoint of the ``smtp'' network connection.
The first column of output from
X.I netstat
is the PCB address; it is used as the
X.I name
argument to
X.IR ofiles ,
along with the
X.B \-n
option.
X.PP
X.RS
X.nf
X% netstat -aA | grep smtp
X.br
X80f6770c	tcp	0	0	*.smtp	*.*	LISTEN
X.br
X% ofiles -n 80f6770c
X.br
file 80102b64 of socket 80f6758c of INPCB 80f6780c of PCB 80f6770c	
X.br
USER	PID	TYPE	FD	CMD
X.br
root	105	sock	 5	sendmail 
X.fi
X.RE
X.SH "THEORY OF OPERATION"
Stat each file or file system argument and scan the process table, looking
for a match in the associated user structure's file lists.  Follow each PCB
arg to the Internet Protocol Control Block (INPCB), thence to the socket;
then scan the file table to find the file structure address associated with
the socket; finally, scan the process table, looking for a nacth in the
associated user structure's file lists.  Now handles remote NFS files.
X.SH DIAGNOSTICS
XErrors are identified with messages on the standard error file.
X.PP
X.I Ofiles
returns a one (1) if any error was detected, including the failure to
locate any
X.IR names .
It returns a zero (0) if no errors were detected and if it was able to
display owner information about all the specified
X.IR names .
X.SH BUGS
X.I Ofiles
can't identify SunOS 4.0 stream files, so it doesn't follow their file
structure pointers correctly when reading their inodes.
That results in the display of erroneous inode numbers for stream files.
X.PP
The
X.B \-n
option limits its search to network connections in the LISTEN through
XESTABLISHED states.
X.PP
Since
X.I ofiles
reads kernel memory in its search for open files and network connections,
rapid changes in kernel memory may produce unsatisfactory results.
X.SH AUTHORS
C. Spencer is the original author.
Michael Ditto, Tom Dunigan, Alexander Dupuy, Gary Nebbett and Richard Tobin
contributed.
X.PP
Michael Spitzer, Ray Moody, and Vik Lall of the Purdue University Computing
Center converted the program to a variety of UNIX environments.
X.PP
Vic Abell of the Purdue University Computing Center added the
X.B \-n
option.
X.PP
The author of this reworked version is Robert Ehrlich
X<ehrlich@margaux.inria.fr>.
X.SH SEE ALSO
inode(5),
mount(1),
kill(1),
tcp(4).
END_OF_FILE
if test 5890 -ne `wc -c <'ofiles.8l'`; then
    echo shar: \"'ofiles.8l'\" unpacked with wrong size!
fi
# end of 'ofiles.8l'
fi
if test -f 'ofiles.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ofiles.c'\"
else
echo shar: Extracting \"'ofiles.c'\" \(34835 characters\)
sed "s/^X//" >'ofiles.c' <<'END_OF_FILE'
X/*	ofiles.c
X *
X *	ofiles [-D ] [-k nlist core] [-n] [-p] [-f|d|m] args
X *
X *	Show owner of open file or network connection.
X *
X *	Reports owner, process ID, access type, command and inode number.
X *
X *	-D		select verbose debugging output
X *
X *	-k nlist core	specifies alternative name list and core files
X *			(DYNIX only)
X *
X *	-n		interpret names as network connection, hexadecimal
X *			Protocol Control Block (PCB) addresses
X *
X *	-p  		gives brief (pids only) report
X *
X *	-i		print inode number (ommitted by default)
X *
X *	-m		force argument to be considered as a mount point
X *
X *	-f		force argument to be considered as a regular file
X *
X *	-d		force argument to be considered as a device
X *
X *	names		file names, file system names or network connection
X *			PCB addresses
X *
X *	Stat each file or file system argument and scan the process table,
X *	looking for a match in the associated user structure's file lists.
X *
X *	Follow each PCB arg to the Internet Protocol Control Block (INPCB),
X *	thence to the socket; then scan the file table to find the file
X *	structure address associated with the socket; finally, scan the
X *	process table, looking for a nacth in the associated user structure's
X *	file lists.
X *
X *	Now handles remote NFS files.
X */
X
X/*
X *	Authors:
X *
X *	The orignal author is:
X *
X *		C. Spencer
X *
X *	Contributors include:
X *
X *		Michael Ditto
X *		Tom Dunigan
X *		Alexander Dupuy
X *		Greg Nebbett
X *		Richard Tobin
X *
X *	From the Purdue University Computing Center:
X *
X *		Mike Spitzer 		converted to 4.3BSD, DYNIX 3.0.1[24]
X *		Ray Moody		SunOS 4.0 and ULTRIX 2.2
X *		Vik Lall
X *
X *		Vic Abell		added socket option and removed lint
X *	
X *	From INRIA Rocquencourt	(France)
X *		Robert Ehrlich		completely revisited in order to:
X *				- make it work on DECSTATIONs 3100, Pyramid
X *					OSX, Sony NewsOS 3.5 4.0 risc 68k
X *				- make it work on pre 4.0 SunOS (yes,
X *					my workstation runs 3.5 !)
X *				- find executable text files, mapped files
X *					under SunOS 4.0
X *				- make it work on remote NFS file-systems
X *				- simplify
X */
X
X#ifndef lint
static char rcsid[]="$Header: /usr/src/local/etc/ofiles/RCS/ofiles.c,v 1.8 89/03/21 12:29:30 abe Exp Locker: abe $";
X#endif /* lint */
X
X#include <sys/param.h>
X#include <sys/dir.h>
X#include <sys/signal.h>
X#if ! BSD || BSD < 43
X#include <sys/time.h>
X#endif
X#include <sys/user.h>
X
X#ifdef sun
X#if ! defined _user_h && ! defined _sys_user_h
X#define SunOS 3
X#else
X#define SunOS 4
X#ifdef _sys_user_h
X#define SunOSrel 1
X#else
define SunOSrel 0
X#endif /* _sys_user_h */
X#endif /* _user_h */
X#endif /* sun */
X
X#ifdef sequent
X#define DYNIX
X#endif
X
X#if defined DYNIX || defined sun || defined pyr || defined sony
X#define NFS
X#endif
X
X#ifdef DYNIX
X#define KERNEL
X#include <sys/file.h>
X#include <sys/vnode.h>
X#include <sys/inode.h>
X#undef KERNEL
X#else
X#define KERNEL
X#include <sys/file.h>
X#ifndef NFS
X#include <sys/inode.h>
X#include <sys/mount.h>
X#undef KERNEL
X#else
X#undef KERNEL
X#include <sys/vfs.h>
X#include <rpc/types.h>
X#include <sys/vnode.h>
X#include <ufs/inode.h>
X#include <nfs/nfs.h>
X#include <nfs/rnode.h>
X#include <ufs/mount.h>
X#endif
X#endif
X
X#include <sys/stat.h>
X#ifndef pyr
X#include <machine/pte.h>
X#else
X#include <sys/pte.h>
X#include <sys/immu.h>
X#endif pyr
X
X#if !defined(ultrix) && !defined(sun) && ! defined DYNIX && ! defined pyr
X#include <machine/machparam.h>
X#endif
X#include <sys/proc.h>
X#include <nlist.h>
X#ifndef O_NDELAY
X#include <sys/fcntl.h>
X#endif
X#include <pwd.h>
X#include <fstab.h>
X#include <sys/vmmac.h>
X#include <stdio.h>
X
X#ifdef NFS
struct snode {
X	struct snode *s_next;
X	struct vnode s_vnode;
X	struct vnode *s_realvp;
X	struct vnode *s_bdevvp;
X	u_short s_flag;
X	dev_t s_dev;
X};
X#endif NFS
X
X#if defined sun && SunOS >= 4
X#include <kvm.h>
kvm_t	*kd;
X#endif
X
X#ifdef _nfs_rnode_h		/* _nfs_rnode_h only defined on recent versions of NFS */
X#define r_nfsattr r_attr	/* the names of these fields changed vith new version of NFS */
X#define nfsfattr vattr
X#define na_nodeid va_nodeid
X#endif	/* NFS version */
X
X#ifdef ultrix
X#include <sys/gnode.h>
X#include <sys/gnode_common.h>
X#include <machine/param.h>
X#define i_number g_number
X#endif
X
X#include <sys/socket.h>
X#include <sys/socketvar.h>
X#include <net/route.h>
X#include <netinet/in.h>
X#include <netinet/in_pcb.h>
X#include <netinet/tcp.h>
X#include <netinet/tcp_fsm.h>
X#include <netinet/tcp_timer.h>
X#include <netinet/tcp_var.h>
X
X#define CDIR	01
X#define OFILE	02
X#define RDIR	04
X#define SHFILE	010
X#define EXFILE	020
X#define SOCKET  040
X
X#if (! defined sun || SunOS < 4) && ! defined DYNIX && ! defined pyr
X	/* no more text struct in these systems */
X#include <sys/text.h>
X#endif
X
X#ifdef pyr	/* maybe for all SYS V ? */
X#undef r_lock
X#include <sys/region.h>
X#endif
X	/* defines for unix BSD whitout NFS */
X#define x_ptr x_iptr
X#define node inode
X#define DTYPE_NODE DTYPE_INODE
X#define FSID struct fs *
X#define _fsid i_fs
X#define ISROOT(n) ((n)->i_number == ROOTINO)
X#define ISBDEV(n) (((n)->i_mode&IFMT) == IFBLK)
X#define ISDEV(n) (((n)->i_mode&IFMT) == IFBLK || ((n)->i_mode&IFMT) == IFCHR)
X#define TYPEWORD(n) ((n)->i_mode)
X#define TYPEBITS(m) ((m)&IFMT)
X#define NODETYPE_T unsigned short
X#define TREG IFREG
X#define TDIR IFDIR
X#define TCHR IFCHR
X#define TBLK IFBLK
X
X#ifdef ultrix
X	/* defines for ultrix, i.e. DEC gfs variant of NFS */
X#undef x_ptr
X#undef node
X
X#define x_ptr	x_gptr
X#define node gnode
X#undef FSID
X#define FSID struct mount *
X#define i_fs g_mp
X#undef ISROOT
X#define ISROOT(n) ((n)->g_number == ROOTINO || isroot(n))
X#define i_number g_number
X#define i_mode g_mode
X#define i_rdev g_rdev
X#undef TREG
X#undef TDIR
X#undef TCHR
X#undef TBLK
X#define TREG GFREG
X#define TDIR GFDIR
X#define TCHR GFCHR
X#define TBLK GFBLK
X#include <sys/mount.h>
X#define m_inodp m_gnodp
X#undef NFS	/* ultrix implememtetion of NFS doesn't fit with my defines */
X#if defined P_DYING	/* ultrix 4.1 */
X#define p_flag p_sched
X#endif			/* ultrix 4.1 */
X#endif ultrix
X
X#if defined sun || defined NFS
X	/* defines for unix systems with NFS a la SUN */
X#undef x_ptr
X#undef node
X#undef DTYPE_NODE
X
X#define x_ptr x_vptr
X#define node vnode
X#define DTYPE_NODE DTYPE_VNODE
X
X#undef FSID
X#undef _fsid
X#define FSID struct vfs *
X#define _fsid v_vfsp
X
X#undef ISROOT
X#undef ISBDEV
X#undef ISDEV
X#define ISROOT(n) ((n)->v_flag & VROOT)
X#define ISBDEV(n) (((n)->v_type) == VBLK)
X#define ISDEV(n) (((n)->v_type) == VBLK || ((n)->v_type) == VCHR)
X
X#undef TYPEWORD
X#undef TYPEBITS
X#undef NODETYPE_T
X#undef TREG
X#undef TDIR
X#undef TCHR
X#undef TBLK
X#define TYPEWORD(n) ((n)->v_type)
X#define TYPEBITS(m) m
X#define NODETYPE_T enum vtype
X#define TREG VREG
X#define TDIR VDIR
X#define TCHR VCHR
X#define TBLK VBLK
X
X#endif sun || NFS
X
X#define TYPE(n) (TYPEBITS(TYPEWORD(n)))
X
typedef FSID myfsid_t;
typedef NODETYPE_T nodetype_t;
X
X#define XFILE	0100
X#define MAPPED	0200
X#define MOUNTP	0400
X
X
X#define STR(s) "s"
X
X#if defined sun && SunOS >= 4 
X#include <vm/seg_vn.h>
X#include <vm/seg.h>
X#if SunOSrel > 0
X#include <vm/hat.h>
X#endif
X#include <vm/as.h>
X
X#endif SunOS >= 4
X
X/*
X * PEEK variants:
X *	KM: from /dev/kmem
X *	M:  from /dev/mem
X *	A:  2nd arg is an array, don't take its address, take its size
X *	P:  2nd arg is a pointer, don't take its address, take size of pointed data
X *	E:  return 0 on error instead of aborting
X */
X
X#define KMPEEK(fromwhere, intowhat) \
X	(void)peek(kmem, (ls_t)(fromwhere), (char *)(&intowhat), sizeof intowhat, "intowhat", __LINE__, 0)
X#define KMAPEEK(fromwhere, intowhat) \
X	(void)peek(kmem, (ls_t)(fromwhere), (char *)(intowhat), sizeof intowhat, "intowhat", __LINE__, 0)
X#define KMPPEEK(fromwhere, intowhat) \
X	(void)peek(kmem, (ls_t)(fromwhere), (char *)(intowhat), sizeof *intowhat, "intowhat", __LINE__, 0)
X#define MPPEEK(fromwhere, intowhat) \
X	(void)peek(mem, (ls_t)(fromwhere), (char *)(intowhat), sizeof *intowhat, "intowhat", __LINE__, 0)
X#define EKMAPEEK(fromwhere, intowhat) \
X	peek(kmem, (ls_t)(fromwhere), (char *)(intowhat), sizeof intowhat, "intowhat", __LINE__, 1)
X#define EMPPEEK(fromwhere, intowhat) \
X	peek(mem, (ls_t)(fromwhere), (char *)(intowhat), sizeof *intowhat, "intowhat", __LINE__, 1)
X
X#if !defined NFS && ! defined ROOTINO
X#ifdef ultrix
X#include <ufs/fs.h>
X#else
X#include <sys/fs.h>
X#endif
X#endif
X
char *namelist;
char *corefile;
int k_opt = 0;
X#ifdef pyr
int dflg = 0;
X#endif pyr
int n_opt = 0;
X
X#if defined	ultrix || ( defined sun && SunOS < 4)
X#define	ls_t	long
X#else
X#define ls_t	off_t
X#endif
X
X#ifdef	sun
char	*sprintf();
X#endif
X
ls_t lseek(), vtophys();
X
X#ifdef	ultrix
void exit(), nlist(), perror();
X#endif
X
int nproc;		/* number of entries in proc table 		*/
int mem;		/* fd for /dev/mem				*/
int kmem;
int swap;		/* fd for /dev/swap				*/
struct proc  *procbase, *procNPROC;
int ppid = -1;		/* previously display PID */
X
int pids_only = 0;	/* if non-zero, only output process ids	*/
int iflag = 0;		/* i-numbers wanted */
X
char *progname;
struct nlist nl[] = {
X#ifndef mips
X#define SYM(s) STR(_/**/s)
X#else
X#define SYM(s) STR(s)
X#endif
X#define	X_PROC		0
X	{ SYM(proc) },
X#define X_PROCNPROC 	1
X	{ SYM(procNPROC) },
X#define X_SYSMAP	2
X	{ SYM(Sysmap) },
X#define	SFIL		3
X	{  SYM(file)  },
X#define	SNFILE		4
X	{  SYM(nfile)  },
X#define X_U		5
X#if sun && SunOS >= 4 && SunOSrel >= 1
X	{ SYM(uunix) },
X#else
X	{ SYM(u) },
X#endif /* SunOS >= 4.1 */
X#if defined NFS
X#define X_ROOTVFS	6
X	{ SYM(rootvfs) },
X#else
X#define X_MOUNT		6
X	{ SYM(mount) },
X#endif
X#ifdef NFS
X#define X_UFSVNOPS	7
X	{ SYM(ufs_vnodeops) },
X#define X_NFSVNOPS	8
X	{ SYM(nfs_vnodeops) },
X#define X_SPECVNOPS	9
X	{ SYM(spec_vnodeops) },
X#endif NFS
X	{ "" }
X};
X
X#if sun && SunOS >= 4 && SunOSrel >= 1
X#define U_ADDR uunix
struct user *uunix;
struct file **ofilep;
struct file *ofile_arr[NOFILE];
int nofile;
X#undef NOFILE
X#define NOFILE nofile
X#define ofile(x) ofilep[x]
X#else
X#define U_ADDR ((struct user *)(nl[X_U].n_value))
X#endif
X
X#ifdef pyr
X#define DELTA_U	((char *)u -(char *)U_ADDR)
X#define ofile(x) (((struct file **)(((char *)(u->u_ofile))+DELTA_U))[x])
X#endif
X
X#ifdef	DYNIX
X#define ofile(x) u->u_lofile[x].of_file
X#undef NOFILE
X#define NOFILE u->u_nofile
X#endif
X
X#ifndef ofile
X	/* normal case, "standard " unix */
X#define ofile(x) u->u_ofile[x]
X#endif /* normal case */
X
int debug;
char *filename, *fsname;
struct node *argnodep, argnode;
dev_t argdev;
nodetype_t argtype;
X
onalarm() {}
X
X#ifdef ultrix
X
isroot(np)
struct node *np;
X{
X	struct node *mp;
X	KMPEEK(&(np->g_mp->m_gnodp), mp);
X	return (mp == argnodep);
X}
X#endif ultrix
X
X#if (defined ultrix || defined sony) && defined mips
uread(from, to)
unsigned int from, *to;
X{
X	struct pte *paddr;
X	struct proc *procp;
X#if 0
X	int pte;
X#else
X	struct pte pte;
X#endif
X	short pid, mypid;
X	mypid = getpid();
X	for (procp = procbase + 2; procp < procNPROC; ++procp) {
X		KMPEEK(&(procp->p_pid), pid);
X		if (pid == mypid) goto found;
X	}
X	error("My pid is not in proc table !\n");
found:
X	KMPEEK(&(procp->p_addr), paddr);
X	KMPEEK(&paddr[(from-UADDR)>>PGSHIFT], pte);
X#if 0
X	MPPEEK((pte&PG_PFNUM) | (from & PGOFSET), to);
X#else
X	MPPEEK((pte.pg_pfnum << PGSHIFT) | (from & PGOFSET), to);
X#endif
X}
X
X
X#endif 
X
ismountdev(s)
char *s;
X{
X	register struct fstab *fs;
X	
X	if ((fs = getfsspec(s)) != NULL) {
X		fsname = fs->fs_file;
X		return 1;
X	}
X	return 0;
X}
X
getmountdev(s)
char *s;
X{
X	register struct fstab *fs;
X
X	if ((fs = getfsfile(s)) != NULL)
X		filename = fs->fs_spec;
X}
X
struct proc p;
X
ino_t inum;
X#ifdef NFS
struct snode *vdata;
X#endif
X
int type;
X
main(argc, argv)
X	int 	argc;
X	char	*argv[];
X{
X
X	struct user *u, *getuser();
X	struct proc *procp;
X	register int filen, flags;
X	char *getsockfp(), *rindex();
X	struct file *fp;
X	int ax, err, findf, nmct;
X	char *ap;
X	int exitval = 0;
X	struct mount *mountp;
X
X#ifdef	lint
X/*
X * The following code satisfies lint for KERNEL symbols.
X * This program is lint-free under 4.3BSD, DYNIX 3.0.1[24], SunOS 4.0
X * and ULTRIX 2.2, using the lint libraries of the systems at the
X * Purdue University Computing Center.
X */
X#if	!defined(ultrix) && !defined(DYNIX) && !defined(sun)
X	long lintlong;
X#endif
X#ifdef	ultrix
X	struct nch *lintnch;
X	float lintfloat;
X#endif
X#if	!defined(DYNIX)
X	file = fileNFILE = NULL;
X	fp = file;
X	fp = fileNFILE;
X	nfile = 0;
X	filen = nfile;
X#endif
X#if	!defined(ultrix) && !defined(DYNIX) && !defined(sun)
X	inode = inodeNINODE = rootdir = NULL;
X	i = inode;
X	i = inodeNINODE;
X	i = rootdir;
X	ninode = 0;
X	nextinodeid = 0l;
X	lintlong = nextinodeid;
X	nextinodeid = lintlong;
X	filen = ninode;
X#endif
X#if defined sun && SunOS >= 4
X	tcp_ttl = 0;
X	filen  = tcp_ttl;
X#endif
X#ifdef	ultrix
X	nch = NULL;
X	lintnch = nch;
X	nch = lintnch;
X	nchsize = 0;
X	filen = nchsize;
X	tcp_alpha = tcp_beta = 0.0;
X	lintfloat = tcp_alpha;
X	lintfloat = tcp_beta;
X	tcp_alpha = lintfloat;
X#endif
X#endif	/* lint */
X
X	if ((progname = rindex(argv[0], '/')))
X		progname++;
X	else
X		progname = argv[0];
X
X	if (argc == 1) {
X
usage:
X
X#ifdef	DYNIX
X		(void) fprintf(stderr,
X			"usage: %s [-D ] [-k nlist core] [-n] [-p] [-d|-n|-p]  names\n",
X			progname);
X#else
X		(void) fprintf(stderr,
X			"usage: %s [-D ] [-n] [-p] [-d|-n|-p] names\n", progname);
X#endif
X		(void) fprintf(stderr, "\t-D    = select verbose debugging output\n");
X#ifdef	DYNIX
X		(void) fprintf(stderr,
X			"\t-k    = use specified nlist and core files\n");
X#endif
X		(void) fprintf(stderr,
X			"\t-n    = interpret names as network connection, hexadecimal,\n");
X		(void) fprintf(stderr,
X			"\t        Protocol Control Block (PCB) addresses, as supplied\n");
X		(void) fprintf(stderr,
X			"\t        by netstat's -A option\n");
X		(void) fprintf(stderr, "\t-p    = print only process IDs\n");
X		(void) fprintf(stderr,
X			"\tnames = file names or PCB addresses\n");
X		(void) fprintf(stderr, "\t-d\n\t-m\n\t-f      force name to be considered respectiveley\n");
X		(void) fprintf(stderr, "\t\t as a device, mount point or regular file\n");
X		exit(exitval);
X	}
X
X	/* check for switches */
X	for (err = 0, ax = 1; ax < argc; ax++) {
X		ap = argv[ax];
X		if (*ap++ != '-')
X			break;
X		while (*ap) {
X			type = 0;
X			switch (*ap++) {
X
X			case 'D':
X				debug = 1;
X				break;
X#if defined DYNIX || defined pyr
X			case 'k':
X				if ((ax + 2) >= argc) {
X					(void) fprintf(stderr,
X						"%s: no nlist/core after -k\n",
X						progname);
X					err++;
X				} else {
X					namelist = argv[++ax];
X					corefile = argv[++ax];
X					k_opt = 1;
X#ifdef pyr
X					if (ap[1] == 'd')
X						dflg = 1;
X#endif pyr
X					continue;
X				}
X				break;
X#endif DYNIX || pyr
X			case 'n':
X				n_opt++;
X				break;
X
X			case 'p':
X				pids_only = 1;
X				break;
X			case 'i':
X				iflag = 1;
X				break;
X
X			case 'm':
X			case 'f':
X			case 'd':
X				type = ap[-1];
X				break;
X			default:
X				(void) fprintf(stderr,
X					"%s: unknown switch - %c\n",
X					progname, *(ap - 1));
X				err++;
X			}
X		}
X	}
X	if (ax >= argc) {
X		(void) fprintf(stderr, "%s: no names specified\n", progname);
X		err++;
X	}
X	if (err) {
X		exitval = 1;
X		goto usage;
X	}
X
X#if defined sun && SunOS >= 4
X    	if ((kd = kvm_open (NULL, NULL, NULL, O_RDONLY)) == 0) {
X		(void) fprintf(stderr, "%s: can't access memory: ",
X			progname);
X        	perror ("");
X		exit(1);
X	}
X#endif
X	if ((mem = open("/dev/mem", 0)) < 0) {
X		(void) fprintf(stderr, "%s: /dev/mem: ", progname);
X		perror("");
X		exit(1);
X	}
X	if (k_opt) {
X		if ((kmem = open(corefile, 0)) < 0) {
X			(void) fprintf(stderr, "%s: %s: ",
X				progname, corefile);
X			perror("");
X			exit(1);
X		}
X		mem = kmem;
X#ifdef pyr
X		if (dflg)
X			setdump();
X#endif pyr
X	} else {
X		if ((kmem = open("/dev/kmem", 0)) < 0) {
X			(void) fprintf(stderr, "%s: /dev/kmem: ", progname);
X			perror("");
X			exit(1);
X		}
X	}
X#ifndef pyr
X	if (!k_opt) 
X		if ((swap = open("/dev/drum", 0)) < 0) {
X			(void) fprintf(stderr, "%s: /dev/drum: ", progname);
X			perror("");
X			exit(1);
X		}
X#endif pyr
X	getsyms();
X
X	for (err = 0, nmct = argc - ax; ax < argc; ax++) {
X		/* if -n, then arg is a PCB */
X		if (n_opt) {
X			if ((filename = getsockfp(argv[ax], &fp)) == NULL) {
X				err++;
X				continue;
X			}
X			fsname = "";
X		} else {
X			int argfd;
X			char buf[100];
X
X			filename = argv[ax];
X			fsname = filename;
retry:
X			signal(SIGALRM,onalarm);
X			alarm(1);
X			argfd = open(fsname, O_RDONLY|O_NDELAY);
X			alarm(0);
X			if (argfd == -1) {
X				extern int errno;
X				extern char *sys_errlist[];
X				struct stat bufstat;
X				if (stat(fsname, &bufstat) != -1)
X					switch (bufstat.st_mode & IFMT) {
X						case IFBLK:
X							argtype = TBLK;
X							break;
X						case IFCHR:
X							argtype = TCHR;
X							break;	
X						default:
X							goto bad;
X					}
X				else
X					goto bad;
X				argdev = bufstat.st_rdev;
X				type = 'd';
X				goto skip;
bad:
X				(void) sprintf(buf, "open failed for %s (%s)\n", fsname, sys_errlist[errno]);
X				error(buf);
X
X			}
X#if defined pyr || defined sun && SunOS >= 4 && SunOSrel >=1
X#define OFILEPTR
X			{
X			struct file **ofp;
X#if defined sun
X			KMPEEK(nl[X_U].n_value, uunix);
X#endif
X			KMPEEK(&(U_ADDR->u_ofile), ofp);
X			KMPEEK(ofp+argfd, fp);
X			}
X#endif OFILEPTR
X
X#if defined mips && (defined ultrix || defined sony)
X	/* ultrix & sony mips have no access via kmem to its own user struct ! */
X			uread(&((U_ADDR->u_ofile)[argfd]), &fp);
X#endif
X
X
X#if !defined OFILEPTR && !((defined ultrix || defined sony) && defined mips)
X	/* the "normal case " */
X			KMPEEK(U_ADDR->u_ofile+argfd, fp);
X#endif /* normal case */
X			KMPEEK(&(fp->f_data), argnodep);
X			KMPEEK(argnodep, argnode);
X			(void)close(argfd);
X			switch(type) {
X				case 0:
X					if (ISROOT(&argnode)) {
X						type = 'm';
X						getmountdev(filename);
X					} else if (ISDEV(&argnode))
X						if (ismountdev(fsname)) {
X							type = 'm';
X							goto retry;
X						} else {
X							type = 'd';
X							fsname = "";
X						}
X					else {
X						type = 'f';
X						fsname = "";
X					}
X					break;
X				case 'f':
X					switch(TYPE(&argnode)) {
X						case TREG:
X						case TDIR:
X						case TCHR:
X						case TBLK:
X							break;
X						default:
X							(void)sprintf(buf,
X								"invalid %s type for arg type '%c' arg %s\n",
X								STR(node),
X								type,
X								argv[ax]);
X							error(buf);
X					}
X					break;
X				case 'm':
X					if (!ISROOT(&argnode)) {
X						if (ismountdev(fsname))
X							goto retry;
X						(void)sprintf(buf,
X							"%s is not a root\n",
X							fsname);
X						error(buf);
X					}
X					if (fsname == filename)
X						getmountdev(filename);
X					break;
X				case 'd':
X					if(!ISDEV(&argnode)) {
X						(void)sprintf(buf,
X							"%s is not a device\n",
X							filename);
X						error(buf);
X					}
X					fsname = "";
X					break;
X			}
X			if (type == 'd')
X#ifdef NFS
X				KMPEEK(&(((struct snode *)(argnode.v_data))->s_dev), argdev);
X#else
X				argdev = argnode.i_rdev;
X#endif NFS
X				argtype = TYPE(&argnode);
X		}
X		if (iflag && type == 'f') {
X#ifdef NFS
X			struct node *i;
X
X			if (ISDEV(&argnode)) {
X				KMPEEK(&(((struct snode *)argnode.v_data)->s_realvp), i);
X				KMPEEK(&(i->v_data), vdata);
X			} else {
X				if ((int)argnode.v_op == nl[X_UFSVNOPS].n_value)
X					KMPEEK(&(((struct inode *)argnode.v_data)->i_number), inum);
X				else if ((int)argnode.v_op == nl[X_NFSVNOPS].n_value)
X					KMPEEK(&(((struct rnode *)argnode.v_data)->r_nfsattr.na_nodeid), inum);
X				else
X					inum = 0;
X			}
X#else
X			inum = argnode.i_number;
X#endif
X		}
skip:
X		if (! pids_only) {
X			(void) printf("%s\t%s", filename, fsname);
X			if (!n_opt) {
X				if (type == 'f')
X					if (TYPE(&argnode) == TDIR)
X						(void) printf(" (directory)");
X					else
X						(void) printf(" (regular file)");
X				else if (type == 'm')
X					(void) printf(" (mount point)");
X				else
X					(void) printf(" (device)");
X					
X			}
X			(void) printf("\n%-8.8s  %5s  %-6.6s  FD  %-14.14s",
X				"USER", "PID", "TYPE", "CMD");
X			if (!n_opt && iflag)
X				(void) printf("  INODE");
X			(void) printf("\n");
X		}
X		if (!n_opt) {
X			struct node *i;
X#if defined NFS
X			struct vfs *vfsp;
X			KMPEEK(nl[X_ROOTVFS].n_value, vfsp);
X			for (; vfsp; KMPEEK(&(vfsp->vfs_next), vfsp)) {
X				KMPEEK(&(vfsp->vfs_vnodecovered), i);
X				if(!i) continue;
X				if (check(i, type))
X					gotone(0,0,-1,MOUNTP,i);
X			}
X#else
X			mountp = (struct mount *)nl[X_MOUNT].n_value;
X			for (;;) {
X				KMPEEK(&(mountp->m_inodp), i);
X				if (!i) break;
X				if (check(i, type))
X					gotone(0,0,-1,MOUNTP,i);
X				++mountp;
X			}
X#endif NFS
X		}
X
X		for (procp = procbase, findf = 0; procp < procNPROC; ++procp) {
X			KMPEEK(procp, p);
X			flags = 0;
X			if (p.p_stat == 0 || p.p_stat == SZOMB) 
X				continue;
X#if defined sun && SunOS >= 4
X			u = kvm_getu(kd, &p);
X#if SunOSrel >= 1
X			getuofiles(u, p.p_segu);
X#endif
X#else
X			u = getuser(&p);
X#endif
X
X			if ( u == (struct user *)NULL)
X				continue;
X			if (debug)
X				(void) printf("pid %d uid %d cmd %s\n", p.p_pid,
X					p.p_uid, u->u_comm);
X			if (!n_opt) {
X				struct node *txtnode;
X
X				if (check(u->u_rdir, type)) {
X					gotone(u, &p, -1, RDIR, u->u_rdir);
X					findf++;
X				}
X				if (check(u->u_cdir, type)) {
X					gotone(u, &p, -1, CDIR, u->u_cdir);
X					findf++;
X				}
X		/* check text files */
X#if (! defined sun || SunOS < 4) && !defined pyr
X#ifndef DYNIX
X				if (p.p_textp) {
X					KMPEEK(&(p.p_textp->x_ptr), txtnode);
X					if (check(txtnode, type)) {
X						gotone(u, &p, -1, XFILE, txtnode);
X						findf++;
X					}
X				}
X#endif DYNIX
X#endif
X#ifdef pyr
X				{
X					struct pregion *prp = p.p_region;
X					struct region *rp;
X					struct node *lastv = 0;
X					int nreg;
X
X					for (nreg = 0; nreg <= p.p_nregion; ++nreg) {
X						KMPEEK(&(prp->p_reg), rp);
X						KMPEEK(&(rp->r_vptr), txtnode);
X						if (txtnode == lastv) continue;
X						if (check(txtnode, type)) {
X							gotone(u, &p, -1, XFILE, txtnode);
X							findf++;
X						}
X						lastv = txtnode;
X					}
X				}
X#endif pyr
X#if defined sun && SunOS >= 4
X		/* in SunOS >= 4 and DYNIX, text files are mapped files */
X				if (p.p_as) {
X					struct seg *segp, *segnext;
X					struct  segvn_data *svd;
X					struct vnode *lastv = 0;
X
X					KMPEEK(&(p.p_as->a_segs), segp);
X					if (!segp) goto noseg;
X					segnext = segp;
X					do {
X					    KMPEEK(&((struct  segvn_data *)(segnext->s_data)), svd);
X					    if (!svd) continue;
X					    KMPEEK(&(svd->vp), txtnode);
X					    if(txtnode == lastv) continue;
X#if defined sun
X					    if(((int)txtnode&0xff00000) != 0xff00000
X) continue;
X#endif sun
X					    if (check(txtnode, type)) {
X						    gotone(u, &p, -1, MAPPED, txtnode);
X						    findf++;
X						    lastv = txtnode;
X					    }
X					    
X					} while(KMPEEK(&((struct  segvn_data *)(segnext->s_next)), segnext),
X						segnext != segp);
X					noseg: ;
X				}
X#endif SunOS < 4
X			}
X			for (filen = 0; filen < NOFILE; filen++)
X			{
X				struct file f;
X
X				flags = 0;
X				if (n_opt) {
X					if (ofile(filen) != fp)
X						continue;
X				} else {
X					if (ofile(filen) == NULL)
X						continue;
X				}
X
X				KMPEEK(ofile(filen), f);
X
X				if (f.f_count > 0) {
X					if (n_opt && f.f_type == DTYPE_SOCKET) {
X						gotone(u, &p, filen, SOCKET, 0);
X						findf++;
X						continue;
X					}
X					if (f.f_type != DTYPE_NODE)
X						continue;
X
X					if (check((struct node *)f.f_data,
X						type)) {
X						flags |= OFILE;
X						if (f.f_flag & FEXLOCK) {
X							flags |= EXFILE;
X						}
X						if (f.f_flag & FSHLOCK) {
X							flags |= SHFILE;
X						}
X						gotone(u, &p, filen, flags, (struct node *)f.f_data);
X						findf++;
X					}
X				}
X			}
X		}
X		if (findf)
X			nmct--;
X		if (! pids_only) {
X	    		(void) printf("\n");
X			(void) fflush(stdout);
X		}
X	}
X	if (pids_only && ppid != -1) {
X		(void) printf("\n");
X		(void) fflush(stdout);
X	}
X	exitval = (err || nmct) ? 1 : 0;
X	exit(exitval);
X}
X
X
X/*
X * print the name of the user owning process "p" and the pid of that process
X */
gotone(u, p, fd, f, i)
X	struct user *u;
X	struct proc *p;
X	int fd;
X	int f;
X	struct node *i;
X{
X	char *ty, tybuf[8], *strcat(), *strcpy();
X	struct passwd *getpwuid();
X	register struct passwd *pw;
X
X	/* only print pids and return */
X	if (pids_only) {
X		if (!p) return;
X		if (ppid != p->p_pid) {
X			if (ppid != -1)
X				(void) printf(" ");
X			(void) printf("%d", p->p_pid);
X			(void) fflush(stdout);
X			ppid = p->p_pid;
X		}
X		return;
X	}
X	if (p) {
X		pw = getpwuid((int)p->p_uid);
X		if (pw)
X			(void) printf("%-8.8s  ", pw->pw_name );
X		else
X			(void) printf("%-8d  ", p->p_uid);
X		(void) printf("%5d  ", p->p_pid);
X		if (f & OFILE) {
X			(void) strcpy(tybuf, "file");
X			ty = tybuf;
X			if (f & SHFILE)
X				(void) strcat(ty, "/s");
X			else if (f & EXFILE)
X				(void) strcat(ty, "/x");
X		} else if (f & CDIR)
X			ty = "cwd";
X		else if (f & RDIR)
X			ty = "rdir";
X		else if (f & SOCKET)
X			ty = "sock";
X#if SunOS < 4
X		else if (f & XFILE)
X			ty = "text";
X#else /* SunOS >= 4 */
X		else if (f & MAPPED)
X			ty = "mapped";
X#endif /* SunOS */
X		else
X			ty = "";
X	} else {
X		printf("                 ");
X		if (f & MOUNTP)
X		ty = "mntpnt";
X	}
X	(void) printf("%-6.6s  ", ty);
X	if (fd >= 0)
X		(void) printf("%2d  ", fd);
X	else
X		(void) printf("    ");
X	(void) printf("%-14.14s", u?u->u_comm:"");
X	if (iflag && i) {
X		if (type != 'f') {
X#ifdef NFS
X			struct vnodeops *vopp;
X
X			if (type != 'd')
X				KMPEEK(&(i->v_data), vdata);
X			KMPEEK(&(i->v_op), vopp);
X			if ((int)vopp == nl[X_UFSVNOPS].n_value)
X				KMPEEK(&(((struct inode *)vdata)->i_number), inum);
X			else if ((int)vopp == nl[X_NFSVNOPS].n_value)
X				KMPEEK(&(((struct rnode *)vdata)->r_nfsattr.na_nodeid), inum);
X			else if ((int)vopp == nl[X_SPECVNOPS].n_value) {
X				KMPEEK(&(vdata)->s_realvp, i);
X				KMPEEK(&(i->v_data), vdata);
X				KMPEEK(&(((struct inode *)vdata)->i_number), inum);
X			} else
X				inum = 0;
X#else
X			KMPEEK(&(i->i_number), inum);
X#endif
X		}
X		printf("  %5d", inum);
X	}
X
X	(void) printf("\n");
X	return;
X}
X
X/*
X * is [igv]node "i"
X 	 - on the filesystem of argnode when type == 'm'
X	 - identical to argnode when type = 'f'
X	 - the same device as argnode when type == 'd'
X   ?
X   returns TRUE or FALSE 
X */
X 
X
check(i, type)
X	struct node *i;
X{
X	myfsid_t fsid;
X	dev_t dev;
X	nodetype_t tword;
X
X	if (type == 'f') return (i == argnodep);
X	if (i == (struct node *)NULL)
X		return 0;
X	if (type == 'm') {
X		KMPEEK(&(i->_fsid), fsid);
X		return (argnode._fsid == fsid);
X	}
X	KMPEEK(&TYPEWORD(i),tword);
X	if (TYPEBITS(tword) != argtype) return 0;
X#ifndef NFS
X	KMPEEK(&(i->i_rdev), dev);
X#else
X	KMPEEK(&(i->v_data), vdata);
X	KMPEEK(&(vdata->s_dev), dev);
X#endif
X	return (argdev == dev);
X}
X
X
X#if !defined(sun) || SunOS < 4
X/* 
X * get user page for proc "p" from core or swap
X * return pointer to user struct
X */
X#ifdef	DYNIX
struct user *
getuser(p)
X	struct proc *p;
X{
X	int btr;
X	ls_t sp;
X	static struct user *u = NULL;
X	char *valloc();
X
X	if (u == NULL) {
X		if ((u = (struct user *) valloc(ctob(UPAGES))) == NULL) {
X			(void) fprintf(stderr,
X				"%s: can't allocate space for user structure\n",				progname);
X			exit(1);
X		}
X	}
X	btr = ctob(UPAGES);
X	if ((p->p_flag & SLOAD) == 0) {
X		if (k_opt)
X			return (struct user *)NULL;
X		sp = (ls_t) dtob(p->p_swaddr);
X		if (lseek(swap, sp, 0) != sp) {
X			if (debug) {
X				(void) fprintf(stderr,
X					"%s: error seeking to swap for %d: ",
X					progname, p->p_pid);
X				perror("");
X			}
X			return (struct user *)NULL;
X		}
X		if (read(swap, (char*)u, btr) != btr) {
X			if (debug) {
X				(void) fprintf(stderr,
X				    "%s: error reading swap for %d: ",
X				    progname, p->p_pid);
X				perror("");
X			}
X			return (struct user *)NULL;
X		}
X		if (debug)
X			(void) printf("read swap\n");
X	} else {
X		KMPPEEK(p->p_uarea, u);
X	}
X	return u;
X}
X#endif
X
X#ifdef pyr
struct user *
getuser(p)
X	struct proc *p;
X{
X	static union uuser {
X		struct user u_user;
X		char u_bytes[UPAGES*NBPG];
X	} uuser;
X
X	if (readublk(p->p_pid, &uuser))
X		return 0;
X	else
X		return &uuser.u_user;
X}
X
X#endif pyr
X
X#if ! defined DYNIX && ! defined pyr
struct user *
getuser(p)
X	struct proc *p;
X{
X#define USERPAGES ((sizeof (struct user) + NBPG -1)/NBPG)
X	struct pte mypgtbl[USERPAGES];
X	int upage;
X	ls_t sp;
X	typedef struct { char bytes[NBPG] } page;
X	page *up;
X	static union uuser {
X		struct user u_user;
X		char u_bytes[USERPAGES*NBPG];
X	} uuser;
X#define User uuser.u_user
X
X	/* easy way */
X	if ((p->p_flag & SLOAD) == 0) {
X		if (k_opt)
X			return (struct user *)NULL;
X#if defined ultrix && defined P_DYING		/* ultrix 4.1 */
X		if (p->p_smap == 0)
X			return (struct user *)NULL;
X		{
X		struct dmap l_dmap;
X		int ublkno;
X		KMPEEK(p->p_smap, l_dmap);
X		KMPEEK(l_dmap.dm_ptdaddr, ublkno);
X		sp = (ls_t)dtob(ublkno);
X		}
X#else
X		sp = (ls_t)dtob(p->p_swaddr);
X#endif /* ultrix 4.1 */
X		if(!peek(swap,  sp, (char *)&User, sizeof(union uuser),
X			"swapped user page(s)", __LINE__, -1))
X			return (struct user *)NULL;
X		if (debug)
X			(void) printf("read swap\n");
X	} else { 	/* boo */
X		/* now get this user's page table */
X		if (! EKMAPEEK(p->p_addr, mypgtbl)) {
X			(void) fprintf(stderr,
X				"%s: can't get mypgtbl.\n", progname);
X			return (struct user *)NULL;
X		}
X		/* now collect various pages of u area */
X		for (upage = 0, up = (page *)&User; upage < USERPAGES; upage++) {
X		if(! EMPPEEK(ctob(mypgtbl[upage].pg_pfnum), up)) {
X				(void) fprintf(stderr,
X				    "%s: can't get page %d of user area.\n",
X				    progname, upage);
X				return(NULL);
X			}
X			++up;
X		}
X	}
X	return &User;
X}
X
X#endif /* ! DYNIX */
X#endif /* SunOS < 4 */
X
X
X/*
X * print mesg "s", don't exit if we are processing a core, 
X * so that corrupt entries don't prevent further uncorrupted
X * entries from showing up.
X */
error(s)
X	char *s;
X{
X	if (s && !k_opt)
X		(void) fprintf(stderr, "%s: %s", progname, s);
X	if (!k_opt)
X		exit(1);
X}
X
X/*
X * get some symbols form the kernel
X */
getsyms()
X{
X	register i;
X
X	if (k_opt) {
X#ifdef	ultrix
X		(void) nlist(namelist, nl);
X#else	/* not ultrix */
X		if (nlist(namelist, nl) == -1) {
X			(void) fprintf(stderr,
X				"%s: can't get name list from %s\n",
X				progname, namelist);
X			exit(1);
X		}
X#endif	/* ultrix */
X	} else {
X#ifdef	ultrix
X		(void) nlist("/vmunix", nl);
X#else	/* not ultrix */
X#ifdef	DYNIX
X		if (nlist("/dynix", nl) == -1)
X#else	/* not DYNIX */
X		if (nlist("/vmunix", nl) == -1)
X#endif	/* DYNIX */
X		{
X			(void) fprintf(stderr,
X				"%s: can't get name list from %s\n",
X#ifdef	DYNIX
X				progname, "/dynix");
X#else	/* not DYNIX */
X				progname, "/vmunix");
X#endif	/* DYNIX */
X			exit(1);
X		}
X#endif	/* ultrix */
X	}
X
X	for (i = 0; i < (sizeof(nl)/sizeof(nl[0]))-1; i++)
X		if (nl[i].n_value == 0) {
X			(void) fprintf(stderr, "%s: can't nlist symbol %s\n",
X				progname, nl[i].n_name);
X			exit(1);
X		}
X
X	KMPEEK(nl[X_PROC].n_value, procbase);
X	KMPEEK(nl[X_PROCNPROC].n_value, procNPROC);
X
X	return;
X}
X
X/*
X * When looking at kernel data space through /dev/mem or
X * with a core file, do virtual memory mapping.
X */
ls_t
vtophys(vaddr)
X#ifdef pyr
X	;
X#else
X	ls_t vaddr;
X{
X	u_int paddr;
X	
X#ifdef	i386
X	if (vaddr < 8192)
X		return vaddr;
X#endif
X	paddr = nl[X_SYSMAP].n_value;
X	peek(kmem, (ls_t)paddr, &paddr, sizeof paddr, "level 1 page table", __LINE__);
X	paddr = (int)((int *)paddr + (vaddr / NBPG));
X	peek(kmem, (ls_t)paddr, &paddr, sizeof paddr, "level 2 page table", __LINE__);
X	(void) read(kmem, (char *)&paddr, sizeof paddr);
X#ifndef	i386
X# define	PTBITS	0x1ff	/* 512 byte pages */
X#else
X# define	PTBITS	0xfff	/* 4096 byte pages */
X#endif
X
X	return ((ls_t)(paddr & ~PTBITS) | (vaddr & PTBITS));
X}
X#endif pyr	/* vtophys in a separate file for pyramid */
X
X/*
X * get file pointer for socket
X */
char *
getsockfp(cba, pfp)
X	char *cba;
X	struct file **pfp;
X{
X	register char *cp;
X	struct file *socktofile();
X	struct inpcb inpcb;
X	static char nmbuf[128];
X	struct socket sock;
X	struct tcpcb tcpcb;
X	long x;
X
X/*
X * Convert PCB address from ASCII to hex.
X */
X	for (cp = cba, x = 0l; *cp; cp++) {
X		x <<= 4;
X		if (*cp >= '0' && *cp <= '9')
X			x += *cp - '0';
X		else if (*cp >= 'a' && *cp <= 'f')
X			x += *cp - 'a' + 10;
X		else if (*cp >= 'A' && *cp <= 'F')
X			x += *cp - 'A' + 10;
X		else {
X			(void) fprintf(stderr,
X				"%s: non-hex address, %s\n", progname, cba);
X			return(NULL);
X		}
X	}
X/*
X * Read PCB and make sure it is in LISTEN or ESTABLISHED state.
X */
X	KMPEEK(x, tcpcb);
X	if (tcpcb.t_state < TCPS_LISTEN || tcpcb.t_state > TCPS_ESTABLISHED) {
X		(void) fprintf(stderr,
X			"%s: PCB %x not in LISTEN to ESTABLISHED state\n",
X			progname, x);
X		return(NULL);
X	}
X	if (tcpcb.t_inpcb == (struct inpcb *)0) {
X		(void) fprintf(stderr,
X			"%s: PCB %x has no INPCB\n",
X			progname, x);
X		return(NULL);
X	}
X/*
X * Read INPCB for PCB and make sure it points back to the PCB.
X */
X	KMPEEK(tcpcb.t_inpcb, inpcb);
X	if ((caddr_t)x != inpcb.inp_ppcb) {
X		(void) fprintf(stderr,
X			"%s: INPCB for PCB %x not linked to it\n",
X			progname, x);
X		return(NULL);
X	}
X/*
X * Read the socket and make sure it points back to the INPCB.
X */
X	KMPEEK(inpcb.inp_socket, sock);
X	if (sock.so_pcb != (caddr_t)tcpcb.t_inpcb) {
X		(void) fprintf(stderr,
X			"%s: socket not linked to INPCB for PCB %x\n",
X			progname, x);
X		return(NULL);
X	}
X/*
X * Find the file structure that is linked to the socket.
X */
X	if ((*pfp = socktofile((caddr_t)inpcb.inp_socket)) == NULL) {
X		(void) fprintf(stderr,
X			"%s: no file structure for socket of PCB %x\n",
X			progname, x);
X		return(NULL);
X	}
X/*
X * Construct a pseudo file name and return it.
X */
X	(void) sprintf(nmbuf,
X		"file %lx of socket %lx of INPCB %lx of PCB %lx",
X		(long)*pfp, (long)inpcb.inp_socket, (long)tcpcb.t_inpcb, x);
X	return(nmbuf);
X}
X
X/*
X * Convert a socket address to a file address.
X */
struct file *
socktofile(s)
X	caddr_t s;
X{
X	register struct file *afile;
X	char *calloc();
X	register struct file *fp;
X	static struct file *ftp;
X	static int nfile = -1;
X	static struct file *xfile = NULL;
X/*
X * Read the size of file table, allocate space
X * for it, and read the file table pointer (once).
X */
X	if (nfile < 0) {
X		KMPEEK(nl[SNFILE].n_value, nfile);
X		xfile = (struct file *) calloc((unsigned)nfile, sizeof (struct file));
X		KMPEEK(nl[SFIL].n_value, ftp);
X	}
X/*
X * Read the file table and search for an in-use
X * socket file with a matching data address.
X */
X	(void)peek(kmem, (ls_t)ftp, (char *)xfile, nfile * sizeof(struct file), "_file",
X			__LINE__, 0);
X	for (fp = xfile, afile = ftp; fp < &xfile[nfile]; fp++, afile++) {
X		if (fp->f_count && fp->f_type == DTYPE_SOCKET
X		&&  s == fp->f_data)
X			return(afile);
X	}
X	return(NULL);
X}
X
peek(file, fromwhere, intowhat, size, msg, line, errflg)
char *intowhat, *msg;
ls_t fromwhere;
X{
X	extern errno;
X	extern char *sys_errlist[];
X	int n;
X
X#if defined sun && SunOS >= 4
X	if (file == kmem) {
X		if ((n = kvm_read(kd,
X			     (unsigned long)(fromwhere), 
X			     (char *)(intowhat),
X			      size
X
X			    )) == -1
X		   ) goto bad;
X		return n;
X	}
X#endif
X	if (lseek(file, k_opt?vtophys(fromwhere):fromwhere, 0) == -1) goto bad;
X	if ((n = read(file, intowhat, size)) == -1) goto bad;
X	return n;
bad:
X	if (errflg > 0) return 0;
X	(void)fprintf (
X		stderr,
X		"%s: peek from 0x%x into 0x%x failed for %s at line %d (%s)\n",
X		progname,
X		fromwhere,
X		intowhat,
X		msg,
X		line,
X		sys_errlist[errno]
X	);
X	if (error == 0) exit(1);
X	return 0;
X}
X
X#if defined sun && SunOS >= 4 && SunOSrel >= 1
getuofiles(locu, segu)
register struct user *locu;
register struct seguser *segu;
X{
X	nofile = locu->u_lastfile + 1;
X	if (nofile <= 0) return;
X	ofilep = locu->u_ofile;
X	if (ofilep == segu->segu_u.u_ofile_arr)
X		ofilep = locu->u_ofile_arr;
X	else {
X		(void)peek(kmem, (ls_t)(ofilep), (char *)(ofile_arr), 
X		     nofile*sizeof (struct file *), "ofile_arr", __LINE__, 0);
X		ofilep = ofile_arr;
X	}
X}
X#endif
END_OF_FILE
if test 34835 -ne `wc -c <'ofiles.c'`; then
    echo shar: \"'ofiles.c'\" unpacked with wrong size!
fi
# end of 'ofiles.c'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
