Newsgroups: comp.sources.unix
From: ben@bytepb.byte.com (Ben Smith @ BYTE)
Subject: v25i109: BYTE Benchmarks, V3.1, Part02/04
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: ben@bytepb.byte.com (Ben Smith @ BYTE)
Posting-Number: Volume 25, Issue 109
Archive-Name: byte-benchmarks3.1/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 4)."
# Contents:  Makefile results/reports.shar src/dhry_2.c src/dummy.c
#   src/fstime.c testdir/cctest.c testdir/sort.src
# Wrapped by vixie@cognition.pa.dec.com on Sun Feb  2 16:27:40 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(8076 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X##############################################################################
X#  The BYTE UNIX Benchmarks - Release 3
X#          Module: Makefile   SID: 3.9 5/15/91 19:30:15
X#          
X##############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Tom Yager at BYTE Magazine
X#	bensmith@bytepb.byte.com    tyager@bytepb.byte.com
X#
X##############################################################################
X#  Modification Log: 7/28/89 cleaned out workload files
X#                    4/17/90 added routines for installing from shar mess
X#                    7/23/90 added compile for dhrystone version 2.1
X#                          (this is not part of Run file. still use old)
X#                          removed HZ from everything but dhry.
X#                          HZ is read from the environment, if not
X#                          there, you must define it in this file
X#                    10/30/90 moved new dhrystone into standard set
X#                          new pgms (dhry included) run for a specified
X#                          time rather than specified number of loops
X#                    4/5/91 cleaned out files not needed for
X#                          release 3 -- added release 3 files -ben
X##############################################################################
ID="@(#)Makefile:3.9 -- 5/15/91 19:30:15";
SHELL = /bin/sh
X#HZ = ????  	   #(read from environment)
CFLAGS = -DTIME
OPTON = -O        #optimization on (give it your best shot) 
X                  #            -- check your compiler man
OPTOFF = -Od      #optimization off -- check your compiler man
X# local directories
PROGDIR = ./pgms
SRCDIR = ./src
DOCDIR = ./doc
TESTDIR = ./testdir
RESULTDIR = ./results
TMPDIR = ./tmp
X# other directories
INCLDIR = /usr/include
LIBDIR = /lib
SCRIPTS = byte.logo cleanup.sh \
X	fs.awk multi.sh tst.sh index.sh index.base \
X	index.awk loops.awk loopm.awk\
X	report.sh report.awk
SOURCES = arith.c big.c context1.c \
X	dummy.c execl.c \
X	fstime.c getopt.c hanoi.c \
X	pipe.c spawn.c limit.c \
X	syscall.c looper.c timeit.c \
X	dhry_1.c dhry_2.c dhry.h 
DOCS = bench.doc bench3.doc
TESTS = sort.src cctest.c dc.dat
RESULTS = reports.shar
BINS = $(PROGDIR)/arithoh $(PROGDIR)/register $(PROGDIR)/short \
X	$(PROGDIR)/int $(PROGDIR)/long $(PROGDIR)/float $(PROGDIR)/double \
X	$(PROGDIR)/hanoi \
X	$(PROGDIR)/fstime $(PROGDIR)/syscall $(PROGDIR)/context1 \
X	$(PROGDIR)/pipe $(PROGDIR)/spawn $(PROGDIR)/execl \
X	$(PROGDIR)/dhry2 $(PROGDIR)/dhry2reg  $(PROGDIR)/looper
REQD = $(BINS) $(PROGDIR)/byte.logo $(PROGDIR)/cleanup.sh  \
X	$(PROGDIR)/fs.awk $(PROGDIR)/multi.sh \
X	$(PROGDIR)/tst.sh $(PROGDIR)/index.sh $(PROGDIR)/index.base \
X	$(PROGDIR)/index.awk $(PROGDIR)/loops.awk $(PROGDIR)/loopm.awk \
X	$(PROGDIR)/report.sh $(PROGDIR)/report.awk \
X	$(TESTDIR)/sort.src $(TESTDIR)/cctest.c $(TESTDIR)/dc.dat
X
X# ######################### the big ALL ############################
all: distr programs
X	@chmod 744 * $(SRCDIR)/* $(PROGDIR)/* $(TESTDIR)/* $(DOCDIR)/*
X
X# ####################### a check for Run ######################
check: $(REQD)
X	make all
X# ##############################################################
X# distribute the files out to subdirectories if they are in this one
distr: 
X	@echo "Checking distribution of files"
X# scripts
X	@if  test ! -d  $(PROGDIR) \
X        ; then  \
X           mkdir $(PROGDIR) \
X           ; mv $(SCRIPTS) $(PROGDIR) \
X        ; else \
X           echo "$(PROGDIR)  exists" \
X        ; fi
X# C sources
X	@if  test ! -d  $(SRCDIR) \
X        ; then  \
X           mkdir $(SRCDIR) \
X           ; mv $(SOURCES) $(SRCDIR) \
X        ; else \
X           echo "$(SRCDIR)  exists" \
X        ; fi
X# test data
X	@if  test ! -d  $(TESTDIR) \
X        ; then  \
X           mkdir $(TESTDIR) \
X           ; mv $(TESTS) $(TESTDIR) \
X        ; else \
X           echo "$(TESTDIR)  exists" \
X        ; fi
X# documents directory
X	@if  test ! -d  $(DOCDIR) \
X        ; then  \
X           mkdir $(DOCDIR) \
X	   ; mv $(DOCS) $(DOCDIR) \
X        ; else \
X           echo "$(DOCDIR)  exists" \
X        ; fi
X# temporary work directory
X	@if  test ! -d  $(TMPDIR) \
X        ; then  \
X           mkdir $(TMPDIR) \
X        ; else \
X           echo "$(TMPDIR)  exists" \
X        ; fi
X# directory for results
X	@if  test ! -d  $(RESULTDIR) \
X        ; then  \
X           mkdir $(RESULTDIR) \
X	   ;  mv $(RESULTS) $(RESULTDIR) \
X        ; else \
X           echo "$(RESULTDIR)  exists" \
X        ; fi
X
programs: $(BINS)
X
X# Individual programs
X$(PROGDIR)/arithoh:	$(SRCDIR)/arith.c
X	cc -o $(PROGDIR)/arithoh ${CFLAGS} ${OPTON} -Darithoh $(SRCDIR)/arith.c
X$(PROGDIR)/register: $(SRCDIR)/arith.c
X	cc -o $(PROGDIR)/register ${CFLAGS} ${OPTON} -Ddatum=register $(SRCDIR)/arith.c
X$(PROGDIR)/short: $(SRCDIR)/arith.c
X	cc -o $(PROGDIR)/short ${CFLAGS} ${OPTON} -Ddatum=short $(SRCDIR)/arith.c
X$(PROGDIR)/int: $(SRCDIR)/arith.c
X	cc -o $(PROGDIR)/int ${CFLAGS} ${OPTON} -Ddatum=int $(SRCDIR)/arith.c
X$(PROGDIR)/long: $(SRCDIR)/arith.c
X	cc -o $(PROGDIR)/long ${CFLAGS} ${OPTON} -Ddatum=long $(SRCDIR)/arith.c
X$(PROGDIR)/float: $(SRCDIR)/arith.c
X	cc -o $(PROGDIR)/float ${CFLAGS} ${OPTON} -Ddatum=float $(SRCDIR)/arith.c
X$(PROGDIR)/double: $(SRCDIR)/arith.c
X	cc -o $(PROGDIR)/double ${CFLAGS} ${OPTON} -Ddatum=double $(SRCDIR)/arith.c
X$(PROGDIR)/hanoi: $(SRCDIR)/hanoi.c
X	cc -o $(PROGDIR)/hanoi ${CFLAGS} ${OPTON} $(SRCDIR)/hanoi.c
X$(PROGDIR)/fstime: $(SRCDIR)/fstime.c
X	cc -o $(PROGDIR)/fstime ${CFLAGS} ${OPTON} -Dawk=1 $(SRCDIR)/fstime.c
X$(PROGDIR)/syscall: $(SRCDIR)/syscall.c
X	cc -o $(PROGDIR)/syscall ${CFLAGS} ${OPTON} $(SRCDIR)/syscall.c
X$(PROGDIR)/context1: $(SRCDIR)/context1.c
X	cc -o $(PROGDIR)/context1 ${CFLAGS} ${OPTON} $(SRCDIR)/context1.c
X$(PROGDIR)/pipe: $(SRCDIR)/pipe.c
X	cc -o $(PROGDIR)/pipe ${CFLAGS} ${OPTON} $(SRCDIR)/pipe.c
X$(PROGDIR)/spawn: $(SRCDIR)/spawn.c
X	cc -o $(PROGDIR)/spawn ${CFLAGS} ${OPTON} $(SRCDIR)/spawn.c
X$(PROGDIR)/execl: $(SRCDIR)/execl.c $(SRCDIR)/big.c
X	cc -o $(PROGDIR)/execl ${CFLAGS} ${OPTON} $(SRCDIR)/execl.c
X$(PROGDIR)/dhry2: $(SRCDIR)/dhry_1.c $(SRCDIR)/dhry_2.c $(SRCDIR)/dhry.h
X	cd $(SRCDIR); cc -c ${CFLAGS} -DHZ=${HZ} ${OPTON} dhry_1.c  
X	cd $(SRCDIR); cc -c ${CFLAGS} -DHZ=${HZ} ${OPTON} dhry_2.c  
X	cc -o $(PROGDIR)/dhry2 ${CFLAGS} ${OPTON} $(SRCDIR)/dhry_1.o $(SRCDIR)/dhry_2.o 
X	cd $(SRCDIR); rm -f dhry_1.o dhry_2.o 
X$(PROGDIR)/dhry2reg: $(SRCDIR)/dhry_1.c $(SRCDIR)/dhry_2.c $(SRCDIR)/dhry.h 
X	cd $(SRCDIR); cc -c ${CFLAGS} -DREG=register -DHZ=${HZ} ${OPTON} dhry_1.c
X	cd $(SRCDIR); cc -c ${CFLAGS} -DREG=register -DHZ=${HZ} ${OPTON} dhry_2.c
X	cc -o $(PROGDIR)/dhry2reg ${CFLAGS} ${OPTON} $(SRCDIR)/dhry_1.o $(SRCDIR)/dhry_2.o
X	cd $(SRCDIR); rm -f dhry_1.o dhry_2.o
X$(PROGDIR)/looper: $(SRCDIR)/looper.c
X	cc -o $(PROGDIR)/looper ${CFLAGS} ${OPTON} $(SRCDIR)/looper.c
X
X# Run the benchmarks and create the reports
run:
X	sh ./Run
X
report:
X	sh pgms/report.sh results/log > results/report
X	sh pgms/index.sh pgms/index.base results/log >> results/report
X	cat results/report
X
X# SCCS stuff and disk reproduction
clean:
X	rm -f $(BINS)
X
delta:
X	delta -y"development step" sccs/s.Run sccs/s.README
X	cd src; delta -y"development step" sccs
X	cd pgms; delta -y"development step" sccs
X	cd testdir; delta -y"development step" sccs
X	cd doc; delta -y"development step" sccs
get:
X	get -e sccs/s.Run sccs/s.README
X	cd src; get -e sccs
X	cd pgms; get -e sccs
X	cd testdir; get -e sccs
X	cd doc; get -e sccs
X	chmod 744 $(SRCDIR)/* 
X	chmod 755 $(PROGDIR)/* *
rel:
X	cd bench; rm -f Makefile Run README; get ../sccs
X	cd bench/src; rm -f *; get ../../src/sccs
X	cd bench/pgms; rm -f *; get ../../pgms/sccs
X	cd bench/testdir; rm -f *; get ../../testdir/sccs
X	cd bench/doc; rm -f *; get ../../doc/sccs
X	cd bench; chmod 744 src/* testdir/*
X	cd bench; chmod 755 * pgms/*
X
tar48:
X	format /dev/rdsk/f05d9t 
X	tar cfb /dev/rdsk/f05d9t 20 bench
X	tar tf /dev/rdsk/f05d9t 
X
tar96:
X	format /dev/rdsk/f05ht
X	tar cfb /dev/rdsk/f05ht 20 bench
X	tar tf /dev/rdsk/f05ht
X
tar135:
X	format /dev/rdsk/f13dt
X	tar cfb /dev/rdsk/f13dt 20 bench
X	tar tf /dev/rdsk/f13dt
END_OF_FILE
if test 8076 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
chmod +x 'Makefile'
# end of 'Makefile'
fi
if test -f 'results/reports.shar' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'results/reports.shar'\"
else
echo shar: Extracting \"'results/reports.shar'\" \(10505 characters\)
sed "s/^X//" >'results/reports.shar' <<'END_OF_FILE'
X#	This is a shell archive.
X#	Remove everything above and including the cut line.
X#	Then run the rest of the file through sh.
X#----cut here-----cut here-----cut here-----cut here-----
X#!/bin/sh
X# shar:	Shell Archiver
X#	Run the following text with /bin/sh to create:
X#	hp425t.report
X#	hp720.report
X#	next040.report
X# This archive created: Wed May 15 09:20:51 1991
echo shar: extracting hp425t.report '(3051 characters)'
sed 's/^XX//' << \ABRACADABRA > hp425t.report
XXX
XXX  BYTE UNIX Benchmarks (Version 3.9)
XXX  System -- HP-UX hpfmcb49 B.08.00 B 9000/42E 08000915959e
XXX  Start Benchmark Run: Thu May  9 14:31:51 EDT 1991
XXX   1 interactive users.
XXXDhrystone 2 without register variables    30581.5 lps   (10 secs, 6 samples)
XXXDhrystone 2 using register variables      30573.8 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = arithoh)         1453209.6 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = register)          3238.6 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = short)             3512.9 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = int)               3239.2 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = long)              3238.5 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = float)             2654.7 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = double)            2871.3 lps   (10 secs, 6 samples)
XXXSystem Call Overhead Test                  3630.7 lps   (10 secs, 6 samples)
XXXPipe Throughput Test                       1284.4 lps   (10 secs, 6 samples)
XXXPipe-based Context Switching Test           563.8 lps   (10 secs, 6 samples)
XXXProcess Creation Test                        57.6 lps   (10 secs, 6 samples)
XXXExecl Throughput Test                        43.4 lps   (9 secs, 6 samples)
XXXFile Read  (10 seconds)                    6748.0 KBps  (10 secs, 6 samples)
XXXFile Write (10 seconds)                    1200.0 KBps  (10 secs, 6 samples)
XXXFile Copy  (10 seconds)                     746.0 KBps  (10 secs, 6 samples)
XXXFile Read  (30 seconds)                    7077.0 KBps  (30 secs, 6 samples)
XXXFile Write (30 seconds)                    1789.0 KBps  (30 secs, 6 samples)
XXXFile Copy  (30 seconds)                     322.0 KBps  (30 secs, 6 samples)
XXXC Compiler Test                              47.6 lpm   (60 secs, 3 samples)
XXXShell scripts (1 concurrent)                 37.0 lpm   (60 secs, 3 samples)
XXXShell scripts (2 concurrent)                 20.0 lpm   (60 secs, 3 samples)
XXXShell scripts (4 concurrent)                 10.0 lpm   (60 secs, 3 samples)
XXXShell scripts (8 concurrent)                  5.0 lpm   (60 secs, 3 samples)
XXXDc: sqrt(2) to 99 decimal places           1205.2 lpm   (60 secs, 6 samples)
XXXRecursion Test--Tower of Hanoi              508.2 lps   (10 secs, 6 samples)
XXX
XXX
XXX                     INDEX VALUES            
XXXTEST                                        BASELINE     RESULT      INDEX
XXX
XXXArithmetic Test (type = double)               2541.7     2871.3        1.1
XXXDhrystone 2 without register variables       22366.3    30581.5        1.4
XXXExecl Throughput Test                           16.5       43.4        2.6
XXXFile Copy  (30 seconds)                        179.0      322.0        1.8
XXXPipe-based Context Switching Test             1318.5      563.8        0.4
XXXShell scripts (8 concurrent)                     4.0        5.0        1.2
XXX                                                                 =========
XXX     SUM of  6 items                                                   8.6
XXX     AVERAGE                                                           1.4
ABRACADABRA
if test 3051 -ne "`wc -c hp425t.report`"
then
echo shar: error transmitting hp425t.report '(should have been 3051 characters)'
fi
echo shar: extracting hp720.report '(3043 characters)'
sed 's/^XX//' << \ABRACADABRA > hp720.report
XXX
XXX  BYTE UNIX Benchmarks (Version 1.1)
XXX  System -- HP-UX hp720 A.B8.01 A 9000/720 48914161
XXX  Start Benchmark Run: Fri Apr 19 09:40:12 EDT 1991
XXX   1 interactive users.
XXXDhrystone 2 without register variables    81533.8 lps   (10 secs, 6 samples)
XXXDhrystone 2 using register variables      81533.3 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = arithoh)         233156.1 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = register)          5195.7 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = short)             5134.0 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = int)               5195.6 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = long)              5195.7 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = float)            12939.7 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = double)           21286.0 lps   (10 secs, 6 samples)
XXXSystem Call Overhead Test                 23100.7 lps   (10 secs, 6 samples)
XXXPipe Throughput Test                       7723.2 lps   (10 secs, 6 samples)
XXXPipe-based Context Switching Test          3151.4 lps   (10 secs, 6 samples)
XXXProcess Creation Test                       221.5 lps   (10 secs, 6 samples)
XXXExecl Throughput Test                        70.6 lps   (9 secs, 6 samples)
XXXFile Read  (10 seconds)                   30048.0 KBps  (10 secs, 6 samples)
XXXFile Write (10 seconds)                    7766.0 KBps  (10 secs, 6 samples)
XXXFile Copy  (10 seconds)                     775.0 KBps  (10 secs, 6 samples)
XXXFile Read  (30 seconds)                   31091.0 KBps  (30 secs, 6 samples)
XXXFile Write (30 seconds)                    9033.0 KBps  (30 secs, 6 samples)
XXXFile Copy  (30 seconds)                     910.0 KBps  (30 secs, 6 samples)
XXXC Compiler Test                              86.9 lpm   (60 secs, 3 samples)
XXXShell scripts (1 concurrent)                 56.7 lpm   (60 secs, 3 samples)
XXXShell scripts (2 concurrent)                 34.0 lpm   (60 secs, 3 samples)
XXXShell scripts (4 concurrent)                 18.3 lpm   (60 secs, 3 samples)
XXXShell scripts (8 concurrent)                  9.3 lpm   (60 secs, 3 samples)
XXXDc: sqrt(2) to 99 decimal places           2907.5 lpm   (60 secs, 6 samples)
XXXRecursion Test--Tower of Hanoi              830.0 lps   (10 secs, 6 samples)
XXX
XXX
XXX                     INDEX VALUES            
XXXTEST                                        BASELINE     RESULT      INDEX
XXX
XXXArithmetic Test (type = double)               2541.7    21286.0        8.4
XXXDhrystone 2 without register variables       22366.3    81533.8        3.6
XXXExecl Throughput Test                           16.5       70.6        4.3
XXXFile Copy  (30 seconds)                        179.0      910.0        5.1
XXXPipe-based Context Switching Test             1318.5     3151.4        2.4
XXXShell scripts (8 concurrent)                     4.0        9.3        2.3
XXX                                                                 =========
XXX     SUM of  6 items                                                  26.1
XXX     AVERAGE                                                           4.3
ABRACADABRA
if test 3043 -ne "`wc -c hp720.report`"
then
echo shar: error transmitting hp720.report '(should have been 3043 characters)'
fi
echo shar: extracting next040.report '(3011 characters)'
sed 's/^XX//' << \ABRACADABRA > next040.report
XXX
XXX  BYTE UNIX Benchmarks (Version 3.9)
XXX  System -- next040
XXX  Start Benchmark Run: Thu May  9 14:44:11 EDT 1991
XXX   0 interactive users.
XXXDhrystone 2 without register variables    23561.8 lps   (10 secs, 6 samples)
XXXDhrystone 2 using register variables      23563.6 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = arithoh)          47309.3 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = register)          3151.4 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = short)             3507.6 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = int)               3150.5 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = long)              3150.4 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = float)             2837.9 lps   (10 secs, 6 samples)
XXXArithmetic Test (type = double)            2837.7 lps   (10 secs, 6 samples)
XXXSystem Call Overhead Test                  8308.8 lps   (10 secs, 6 samples)
XXXPipe Throughput Test                       2966.7 lps   (10 secs, 6 samples)
XXXPipe-based Context Switching Test          1211.7 lps   (10 secs, 6 samples)
XXXProcess Creation Test                        43.5 lps   (10 secs, 6 samples)
XXXExecl Throughput Test                        26.6 lps   (9 secs, 6 samples)
XXXFile Read  (10 seconds)                   20209.0 KBps  (10 secs, 6 samples)
XXXFile Write (10 seconds)                    1000.0 KBps  (10 secs, 6 samples)
XXXFile Copy  (10 seconds)                     804.0 KBps  (10 secs, 6 samples)
XXXFile Read  (30 seconds)                   21031.0 KBps  (30 secs, 6 samples)
XXXFile Write (30 seconds)                     933.0 KBps  (30 secs, 6 samples)
XXXFile Copy  (30 seconds)                     765.0 KBps  (30 secs, 6 samples)
XXXC Compiler Test                              37.5 lpm   (62 secs, 3 samples)
XXXShell scripts (1 concurrent)                 28.3 lpm   (62 secs, 3 samples)
XXXShell scripts (2 concurrent)                 17.2 lpm   (62 secs, 3 samples)
XXXShell scripts (4 concurrent)                  9.6 lpm   (62 secs, 3 samples)
XXXShell scripts (8 concurrent)                  4.8 lpm   (62 secs, 3 samples)
XXXDc: sqrt(2) to 99 decimal places           1021.8 lpm   (62 secs, 6 samples)
XXXRecursion Test--Tower of Hanoi              313.3 lps   (10 secs, 6 samples)
XXX
XXX
XXX                     INDEX VALUES            
XXXTEST                                        BASELINE     RESULT      INDEX
XXX
XXXArithmetic Test (type = double)               2541.7     2837.7        1.1
XXXDhrystone 2 without register variables       22366.3    23561.8        1.0
XXXExecl Throughput Test                           16.5       26.6        1.6
XXXFile Copy  (30 seconds)                        179.0      765.0        4.3
XXXPipe-based Context Switching Test             1318.5     1211.7        0.9
XXXShell scripts (8 concurrent)                     4.0        4.8        1.2
XXX                                                                 =========
XXX     SUM of  6 items                                                  10.2
XXX     AVERAGE                                                           1.7
ABRACADABRA
if test 3011 -ne "`wc -c next040.report`"
then
echo shar: error transmitting next040.report '(should have been 3011 characters)'
fi
X#	End of shell archive
exit 0
END_OF_FILE
if test 10505 -ne `wc -c <'results/reports.shar'`; then
    echo shar: \"'results/reports.shar'\" unpacked with wrong size!
fi
# end of 'results/reports.shar'
fi
if test -f 'src/dhry_2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/dhry_2.c'\"
else
echo shar: Extracting \"'src/dhry_2.c'\" \(5850 characters\)
sed "s/^X//" >'src/dhry_2.c' <<'END_OF_FILE'
X/*****************************************************************************
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: dhry_2.c   SID: 3.4 5/15/91 19:30:22
X *          
X *****************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yager
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *****************************************************************************
X *  Modification Log:
X *
X *  Adapted from:
X *
X *                   "DHRYSTONE" Benchmark Program
X *                   -----------------------------
X *
X * **** WARNING **** See warning in n.dhry_1.c
X *                                                                            
X *  Version:    C, Version 2.1
X *                                                                            
X *  File:       dhry_2.c (part 3 of 3)
X *
X *  Date:       May 25, 1988
X *
X *  Author:     Reinhold P. Weicker
X *
X ****************************************************************************/
X/* SCCSid is defined in dhry_1.c */
X
X#include "dhry.h"
X
X#ifndef REG
X#define REG
X        /* REG becomes defined as empty */
X        /* i.e. no register variables   */
X#endif
X
extern  int     Int_Glob;
extern  char    Ch_1_Glob;
X
X
Proc_6 (Enum_Val_Par, Enum_Ref_Par)
X/*********************************/
X    /* executed once */
X    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */
X
XEnumeration  Enum_Val_Par;
XEnumeration *Enum_Ref_Par;
X{
X  *Enum_Ref_Par = Enum_Val_Par;
X  if (! Func_3 (Enum_Val_Par))
X    /* then, not executed */
X    *Enum_Ref_Par = Ident_4;
X  switch (Enum_Val_Par)
X  {
X    case Ident_1: 
X      *Enum_Ref_Par = Ident_1;
X      break;
X    case Ident_2: 
X      if (Int_Glob > 100)
X        /* then */
X      *Enum_Ref_Par = Ident_1;
X      else *Enum_Ref_Par = Ident_4;
X      break;
X    case Ident_3: /* executed */
X      *Enum_Ref_Par = Ident_2;
X      break;
X    case Ident_4: break;
X    case Ident_5: 
X      *Enum_Ref_Par = Ident_3;
X      break;
X  } /* switch */
X} /* Proc_6 */
X
X
Proc_7 (Int_1_Par_Val, Int_2_Par_Val, Int_Par_Ref)
X/**********************************************/
X    /* executed three times                                      */ 
X    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */
X    /*                  Int_Par_Ref becomes 7                    */
X    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */
X    /*                  Int_Par_Ref becomes 17                   */
X    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */
X    /*                  Int_Par_Ref becomes 18                   */
One_Fifty       Int_1_Par_Val;
One_Fifty       Int_2_Par_Val;
One_Fifty      *Int_Par_Ref;
X{
X  One_Fifty Int_Loc;
X
X  Int_Loc = Int_1_Par_Val + 2;
X  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;
X} /* Proc_7 */
X
X
Proc_8 (Arr_1_Par_Ref, Arr_2_Par_Ref, Int_1_Par_Val, Int_2_Par_Val)
X/*********************************************************************/
X    /* executed once      */
X    /* Int_Par_Val_1 == 3 */
X    /* Int_Par_Val_2 == 7 */
Arr_1_Dim       Arr_1_Par_Ref;
Arr_2_Dim       Arr_2_Par_Ref;
int             Int_1_Par_Val;
int             Int_2_Par_Val;
X{
X  REG One_Fifty Int_Index;
X  REG One_Fifty Int_Loc;
X
X  Int_Loc = Int_1_Par_Val + 5;
X  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;
X  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];
X  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;
X  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)
X    Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;
X  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;
X  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];
X  Int_Glob = 5;
X} /* Proc_8 */
X
X
XEnumeration Func_1 (Ch_1_Par_Val, Ch_2_Par_Val)
X/*************************************************/
X    /* executed three times                                         */
X    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */
X    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */
X    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */
X
Capital_Letter   Ch_1_Par_Val;
Capital_Letter   Ch_2_Par_Val;
X{
X  Capital_Letter        Ch_1_Loc;
X  Capital_Letter        Ch_2_Loc;
X
X  Ch_1_Loc = Ch_1_Par_Val;
X  Ch_2_Loc = Ch_1_Loc;
X  if (Ch_2_Loc != Ch_2_Par_Val)
X    /* then, executed */
X    return (Ident_1);
X  else  /* not executed */
X  {
X    Ch_1_Glob = Ch_1_Loc;
X    return (Ident_2);
X   }
X} /* Func_1 */
X
X
Boolean Func_2 (Str_1_Par_Ref, Str_2_Par_Ref)
X/*************************************************/
X    /* executed once */
X    /* Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING" */
X    /* Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING" */
X
Str_30  Str_1_Par_Ref;
Str_30  Str_2_Par_Ref;
X{
X  REG One_Thirty        Int_Loc;
X      Capital_Letter    Ch_Loc;
X
X  Int_Loc = 2;
X  while (Int_Loc <= 2) /* loop body executed once */
X    if (Func_1 (Str_1_Par_Ref[Int_Loc],
X                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
X      /* then, executed */
X    {
X      Ch_Loc = 'A';
X      Int_Loc += 1;
X    } /* if, while */
X  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
X    /* then, not executed */
X    Int_Loc = 7;
X  if (Ch_Loc == 'R')
X    /* then, not executed */
X    return (true);
X  else /* executed */
X  {
X    if (strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)
X      /* then, not executed */
X    {
X      Int_Loc += 7;
X      Int_Glob = Int_Loc;
X      return (true);
X    }
X    else /* executed */
X      return (false);
X  } /* if Ch_Loc */
X} /* Func_2 */
X
X
Boolean Func_3 (Enum_Par_Val)
X/***************************/
X    /* executed once        */
X    /* Enum_Par_Val == Ident_3 */
XEnumeration Enum_Par_Val;
X{
X  Enumeration Enum_Loc;
X
X  Enum_Loc = Enum_Par_Val;
X  if (Enum_Loc == Ident_3)
X    /* then, executed */
X    return (true);
X  else /* not executed */
X    return (false);
X} /* Func_3 */
X
END_OF_FILE
if test 5850 -ne `wc -c <'src/dhry_2.c'`; then
    echo shar: \"'src/dhry_2.c'\" unpacked with wrong size!
fi
chmod +x 'src/dhry_2.c'
# end of 'src/dhry_2.c'
fi
if test -f 'src/dummy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/dummy.c'\"
else
echo shar: Extracting \"'src/dummy.c'\" \(7483 characters\)
sed "s/^X//" >'src/dummy.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: dummy.c   SID: 3.3 5/15/91 19:30:19
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yager
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X *
X ******************************************************************************/
X/*
X *  Hacked up C program for use in the standard shell.? scripts of
X *  the multiuser test.  This is based upon makework.c, and is typically
X *  edited using edscript.2 before compilation.
X *
X * $Header: dummy.c,v 3.4 87/06/23 15:54:53 kjmcdonell Beta $
X */
char SCCSid[] = "@(#) @(#)dummy.c:3.3 -- 5/15/91 19:30:19";
X
X#include <stdio.h>
X#include <signal.h>
X
X#define DEF_RATE	5.0
X#define GRANULE		5
X#define CHUNK		60
X#define MAXCHILD	12
X#define MAXWORK		10
X
float	thres;
float	est_rate = DEF_RATE;
int	nusers;		/* number of concurrent users to be simulated by
X			 * this process */
int	firstuser;	/* ordinal identification of first user for this
X			 * process */
int	nwork = 0;	/* number of job streams */
int	exit_status = 0;	/* returned to parent */
int	sigpipe;	/* pipe write error flag */
X
struct st_work {
X	char	*cmd;		/* name of command to run */
X	char	**av;		/* arguments to command */
X	char	*input;		/* standard input buffer */
X	int	inpsize;	/* size of standard input buffer */
X} work[MAXWORK];
X
struct {
X	int	xmit;	/* # characters sent */
X	char	*bp;	/* std input buffer pointer */
X	int	blen;	/* std input buffer length */
X	int	fd;	/* stdin to command */
X	int	pid;	/* child PID */
X	char	*line;	/* start of input line */ 
X	int	firstjob;	/* inital piece of work */
X	int	thisjob;	/* current piece of work */
X} child[MAXCHILD], *cp;
X
main(argc, argv)
int	argc;
char	*argv[];
X{
X    int		i;
X    int		l;
X    int		fcopy = 0;	/* fd for copy output */
X    int		master = 1;	/* the REAL master, == 0 for clones */
X    int		nchild;		/* no. of children for a clone to run */
X    int		done;		/* count of children finished */
X    int		output;		/* aggregate output char count for all
X				   children */
X    int		c;
X    int		thiswork = 0;	/* next job stream to allocate */
X    int		nch;		/* # characters to write */
X    int		written;	/* # characters actully written */
X    char	logname[15];	/* name of the log file(s) */
X    int		onalarm();
X    int		pipeerr();
X    int		wrapup();
X    int		grunt();
X    char	*malloc();
X    int		pvec[2];	/* for pipes */
X    char	*p;
X    char	*prog;		/* my name */
X
X#if ! debug
X    freopen("masterlog.00", "a", stderr);
X#endif
X    fprintf(stderr, "*** New Run ***  ");
X    prog = argv[0];
X    while (argc > 1 && argv[1][0] == '-')  {
X	p = &argv[1][1];
X	argc--;
X	argv++;
X	while (*p) {
X	    switch (*p) {
X	    case 'r':
X			/* code DELETED here */
X			argc--;
X			argv++;
X			break;
X
X	    case 'c':
X			/* code DELETED here */
X			lseek(fcopy, 0L, 2);	/* append at end of file */
X			break;
X
X	    default:
X		fprintf(stderr, "%s: bad flag '%c'\n", prog, *p);
X			exit(4);
X	    }
X	    p++;
X	}
X    }
X    
X    if (argc < 2) {
X	fprintf(stderr, "%s: missing nusers\n", prog);
X	exit(4);
X    }
X
X    nusers = atoi(argv[1]);
X    if (nusers < 1) {
X	fprintf(stderr, "%s: impossible nusers (%d<-%s)\n", prog, nusers, argv[1]);
X	exit(4);
X    }
X    fprintf(stderr, "%d Users\n", nusers);
X    argc--;
X    argv++;
X
X    /* build job streams */
X    getwork();
X#if debug
X    dumpwork();
X#endif
X
X    /* clone copies of myself to run up to MAXCHILD jobs each */
X    firstuser = MAXCHILD;
X    fprintf(stderr, "master pid %d\n", getpid());
X    fflush(stderr);
X    while (nusers > MAXCHILD) {
X	fflush(stderr);
X	if (nusers >= 2*MAXCHILD)
X	    /* the next clone must run MAXCHILD jobs */
X	    nchild = MAXCHILD;
X	else
X	    /* the next clone must run the leftover jobs */
X	    nchild = nusers - MAXCHILD;
X	if ((l = fork()) == -1) {
X	    /* fork failed */
X	    fatal("** clone fork failed **\n");
X	    goto bepatient;
X	} else if (l > 0) {
X	    fprintf(stderr, "master clone pid %d\n", l);
X	    /* I am the master with nchild fewer jobs to run */
X	    nusers -= nchild;
X	    firstuser += MAXCHILD;
X	    continue;
X	} else {
X	    /* I am a clone, run MAXCHILD jobs */
X#if ! debug
X	    sprintf(logname, "masterlog.%02d", firstuser/MAXCHILD);
X	    freopen(logname, "w", stderr);
X#endif
X	    master = 0;
X	    nusers = nchild;
X	    break;
X	}
X    }
X    if (master)
X	firstuser = 0;
X
X    close(0);
X
X    /* code DELETED here */
X
X    fflush(stderr);
X
X    srand(time(0));
X    thres = 0;
X    done = output = 0;
X    for (i = 0; i < nusers; i++) {
X	if (child[i].blen == 0)
X	    done++;
X	else
X	    thres += est_rate * GRANULE;
X    }
X    est_rate = thres;
X
X    signal(SIGALRM, onalarm);
X    signal(SIGPIPE, pipeerr);
X    alarm(GRANULE);
X    while (done < nusers) {
X	for (i = 0; i < nusers; i++) {
X	    cp = &child[i];
X	    if (cp->xmit >= cp->blen) continue;
X	    l = rand() % CHUNK + 1;	/* 1-CHUNK chars */
X	    if (l == 0) continue;
X	    if (cp->xmit + l > cp->blen)
X		l = cp->blen - cp->xmit;
X	    p = cp->bp;
X	    cp->bp += l;
X	    cp->xmit += l;
X#if debug
X	    fprintf(stderr, "child %d, %d processed, %d to go\n", i, cp->xmit, cp->blen - cp->xmit);
X#endif
X	    while (p < cp->bp) {
X		if (*p == '\n' || (p == &cp->bp[-1] && cp->xmit >= cp->blen)) {
X		    /* write it out */
X		    nch = p - cp->line + 1;
X		    if ((written = write(cp->fd, cp->line, nch)) != nch) {
X
X			/* code DELETED here */
X
X		    }
X		    if (fcopy)
X			write(fcopy, cp->line, p - cp->line + 1);
X#if debug
X		    fprintf(stderr, "child %d gets \"", i);
X		    {
X			char *q = cp->line;
X			while (q <= p) {
X				if (*q >= ' ' && *q <= '~')
X					fputc(*q, stderr);
X				else
X					fprintf(stderr, "\\%03o", *q);
X				q++;
X			}
X		    }
X		    fputc('"', stderr);
X#endif
X		    cp->line = &p[1];
X		}
X		p++;
X	    }
X	    if (cp->xmit >= cp->blen) {
X		done++;
X		close(cp->fd);
X#if debug
X	fprintf(stderr, "child %d, close std input\n", i);
X#endif
X	    }
X	    output += l;
X	}
X	while (output > thres) {
X	    pause();
X#if debug
X	    fprintf(stderr, "after pause: output, thres, done %d %.2f %d\n", output, thres, done);
X#endif
X	}
X    }
X
bepatient:
X    alarm(0);
X/****
X *  If everything is going OK, we should simply be able to keep
X *  looping unitil 'wait' fails, however some descendent process may
X *  be in a state from which it can never exit, and so a timeout
X *  is used.
X *  5 minutes should be ample, since the time to run all jobs is of
X *  the order of 5-10 minutes, however some machines are painfully slow,
X *  so the timeout has been set at 20 minutes (1200 seconds).
X ****/
X
X    /* code DELETED here */
X
X}
X
onalarm()
X{
X    thres += est_rate;
X    signal(SIGALRM, onalarm);
X    alarm(GRANULE);
X}
X
grunt()
X{
X    /* timeout after label "bepatient" in main */
X    exit_status = 4;
X    wrapup();
X}
X
pipeerr()
X{
X	sigpipe++;
X}
X
wrapup()
X{
X    /* DUMMY, real code dropped */
X}
X
getwork()
X{
X
X    /* DUMMY, real code dropped */
X    gets();
X    strncpy();
X    malloc(); realloc();
X    open(); close();
X}
X
fatal(s)
char *s;
X{
X    int	i;
X    fprintf(stderr, s);
X    fflush(stderr);
X    perror("Reason?");
X    for (i = 0; i < nusers; i++) {
X	if (child[i].pid > 0 && kill(child[i].pid, SIGKILL) != -1)
X	    fprintf(stderr, "pid %d killed off\n", child[i].pid);
X    }
X    fflush(stderr);
X    exit_status = 4;
X    return;
X}
END_OF_FILE
if test 7483 -ne `wc -c <'src/dummy.c'`; then
    echo shar: \"'src/dummy.c'\" unpacked with wrong size!
fi
chmod +x 'src/dummy.c'
# end of 'src/dummy.c'
fi
if test -f 'src/fstime.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/fstime.c'\"
else
echo shar: Extracting \"'src/fstime.c'\" \(5474 characters\)
sed "s/^X//" >'src/fstime.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: fstime.c   SID: 3.5 5/15/91 19:30:19
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yager
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X * $Header: fstime.c,v 3.4 87/06/22 14:23:05 kjmcdonell Beta $
X * 10/19/89 - rewrote timing calcs and added clock check (Ben Smith)
X * 10/26/90 - simplify timing, change defaults (Tom Yager)
X * 11/16/90 - added better error handling and changed output format (Ben Smith)
X * 11/17/90 - changed the whole thing around (Ben Smith)
X * 2/22/91 - change a few style elements and improved error handling (Ben Smith)
X * 4/17/91 - incorporated suggestions from Seckin Unlu (seckin@sumac.intel.com)
X * 4/17/91 - limited size of file, will rewind when reaches end of file
X ******************************************************************************/
char SCCSid[] = "@(#) @(#)fstime.c:3.5 -- 5/15/91 19:30:19";
X
X#include <stdio.h>
X#include <signal.h>
X#include <errno.h>
X
X#define SECONDS 2
X#define BUFF_SIZE 1024
X#define MAX_BLOCKS 2000   /* max number of BUFF_SIZE blocks in file */
X#define FNAME0	"dummy0"
X#define FNAME1	"dummy1"
X
X/****************** GLOBALS ***************************/
char buf[BUFF_SIZE];
int			seconds = SECONDS;
int			f;
int			g;
int			i;
int			stop_count();
int			clean_up();
int			sigalarm = 0;
X
X/******************** MAIN ****************************/
X
main(argc, argv)
char **argv;
X{
X
X/**** initialize ****/
X    if (argc > 1)
X	seconds = atoi(argv[1]);
X    if (argc == 3 && chdir(argv[2]) == -1) 
X	    {
X	    perror("fstime: chdir");
X	    exit(1);
X	    }
X    if((f = creat(FNAME0, 0600)) != -1)
X            close(f);
X    else
X	    {
X	    perror("fstime: creat");
X	    exit(1);
X	    }
X    if((g = creat(FNAME1, 0600)) != -1)
X            close(g);
X    else
X	    {
X	    perror("fstime: creat");
X	    exit(1);
X	    }
X    if( (f = open(FNAME0, 2)) == -1)
X	    {
X	    perror("fstime: open");
X	    exit(1);
X	    }
X    if( ( g = open(FNAME1, 2)) == -1 )
X	    {
X	    perror("fstime: open");
X	    exit(1);
X	    }
X    /* fill buffer */
X    for (i = 0; i < BUFF_SIZE; i++)
X	buf[i] = i & 0177;
X    /*** run the tests ****/
X    signal(SIGKILL,clean_up);
X    if(w_test() || r_test() || c_test()) 
X	{ 
X	clean_up();
X	exit(1);
X	}
X    /* else */
X    clean_up();
X    exit(0);
X}
X
w_test() 
X/* write test */
X{
X    long n_blocks = 0L;
X    int f_blocks;
X    extern int sigalarm;
X
X    sync();
X    sleep(5); /* to insure the sync */
X
X    signal(SIGALRM,stop_count);
X    sigalarm = 0; /* reset alarm flag */
X    alarm(seconds);
X    while(!sigalarm)
X	{
X	for(f_blocks=0; f_blocks < MAX_BLOCKS; ++f_blocks)
X		{
X		if (write(f, buf, BUFF_SIZE) < 0)
X		    {
X		    if (errno != EINTR) {
X			perror("fstime: write");
X			return(-1);
X			} else stop_count();
X		    }
X		++ n_blocks;
X		}
X        lseek(f, 0L, 0); /* rewind */
X	}
X    /* stop clock */
X    fprintf(stderr, "%d second sample\n", seconds);
X    fprintf(stderr, "%ld Kbytes/sec write\n", 
X         (long) n_blocks / (long) seconds);
return(0);
X}
X
r_test() 
X/* read test */
X{
X    long n_blocks = 0L;
X    extern int sigalarm;
X    extern int errno;
X
X    /* rewind */
X    sync();
X    sleep(10+seconds/2);
X    errno = 0;
X    lseek(f, 0L, 0);
X
X    signal(SIGALRM,stop_count);
X    sigalarm = 0; /* reset alarm flag */
X    alarm(seconds);
X    while(!sigalarm)
X	{
X	if (read(f, buf, BUFF_SIZE) < 0) /* read while checking for an error */
X	    switch(errno)
X	    {
X	    case 0:
X            case EINVAL:
X                lseek(f, 0L, 0);  /* rewind at end of file */
X		continue;
X		break;
X            case EINTR:
X		stop_count();
X		break;
X            default:
X                perror("fstime: read");
X	        return(-1);
X		break;
X            }
X	++ n_blocks;
X        }
X    /* stop clock */
X    fprintf(stderr, "%d second sample\n", seconds);
X    fprintf(stderr, "%ld Kbytes/sec read\n", 
X         (long) n_blocks / (long) seconds);
return(0);
X}
X
X
c_test() 
X/* copy test */
X{
X    long n_blocks = 0L;
X    extern int sigalarm;
X
X    /* rewind */
X    sync();
X    sleep(10+seconds/2); /* to insure the sync */
X    errno - 0;
X    lseek(f, 0L, 0);
X
X    signal(SIGALRM,stop_count);
X    sigalarm = 0; /* reset alarm flag */
X    alarm(seconds);
X    while(!sigalarm)
X	{
X	if (read(f, buf, BUFF_SIZE) < 0)
X	    switch(errno)
X	    {
X	    case 0:
X            case EINVAL:
X                lseek(f, 0L, 0);  /* rewind at end of file */
X                lseek(g, 0L, 0);  /* rewind the output as well */
X		continue;
X		break;
X            case EINTR:
X		stop_count();
X		break;
X            default:
X                perror("fstime: copy read");
X	        return(-1);
X		break;
X            }
X	if (write(g, buf, BUFF_SIZE) < 0)
X	    {
X            if (errno != EINTR) {
X	        perror("fstime: copy write");
X	        return(-1);
X                } else stop_count();
X	    }
X	++ n_blocks;
X        }
X    /* stop clock */
X    fprintf(stderr, "%d second sample\n", seconds);
X    fprintf(stderr, "%ld Kbytes/sec copy \n", 
X         (long) n_blocks / (long) seconds);
return(0);
X}
X
stop_count()
X{
extern int sigalarm;
sigalarm = 1;
return(0);
X}
X
clean_up()
X{
if( unlink(FNAME0) || unlink(FNAME1))
X	return(-1);
else
X	return(0);
X}
END_OF_FILE
if test 5474 -ne `wc -c <'src/fstime.c'`; then
    echo shar: \"'src/fstime.c'\" unpacked with wrong size!
fi
chmod +x 'src/fstime.c'
# end of 'src/fstime.c'
fi
if test -f 'testdir/cctest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'testdir/cctest.c'\"
else
echo shar: Extracting \"'testdir/cctest.c'\" \(3552 characters\)
sed "s/^X//" >'testdir/cctest.c' <<'END_OF_FILE'
X
X
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 1
X *          Module: cctest.c   SID: 1.2 7/10/89 18:55:45
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Rick Grehan at BYTE Magazine
X *	bensmith@bixpb.UUCP    rick_g@bixpb.UUCP
X *
X *******************************************************************************
X *  Modification Log:
X * $Header: cctest.c,v 3.4 87/06/22 14:22:47 kjmcdonell Beta $
X *
X ******************************************************************************/
char SCCSid[] = "@(#) @(#)cctest.c:1.2 -- 7/10/89 18:55:45";
X#include <stdio.h>
X/*
X * C compile and load speed test file.
X * Based upon fstime.c from MUSBUS 3.1, with all calls to ftime() replaced
X * by calls to time().  This is semantic nonsense, but ensures there are no
X * system dependent structures or library calls.
X *
X */
X#define NKBYTE 20
char buf[BUFSIZ];
X
main(argc, argv)
char **argv;
X{
X    int		n = NKBYTE;
X    int		nblock;
X    int		f;
X    int		g;
X    int		i;
X    int		xfer, t;
X    struct	{	/* FAKE */
X	int	time;
X	int	millitm;
X    } now, then;
X
X    if (argc > 0)
X	/* ALWAYS true, so NEVER execute this program! */
X	exit(4);
X    if (argc > 1)
X	n = atoi(argv[1]);
X#if debug
X    printf("File size: %d Kbytes\n", n);
X#endif
X    nblock = (n * 1024) / BUFSIZ;
X
X    if (argc == 3 && chdir(argv[2]) != -1) {
X#if debug
X	printf("Create files in directory: %s\n", argv[2]);
X#endif
X    }
X    close(creat("dummy0", 0600));
X    close(creat("dummy1", 0600));
X    f = open("dummy0", 2);
X    g = open("dummy1", 2);
X    unlink("dummy0");
X    unlink("dummy1");
X    for (i = 0; i < sizeof(buf); i++)
X	buf[i] = i & 0177;
X
X    time();
X    for (i = 0; i < nblock; i++) {
X	if (write(f, buf, sizeof(buf)) <= 0)
X	    perror("fstime: write");
X    }
X    time();
X#if debug
X    printf("Effective write rate: ");
X#endif
X    i = now.millitm - then.millitm;
X    t = (now.time - then.time)*1000 + i;
X    if (t > 0) {
X	xfer = nblock * sizeof(buf) * 1000 / t;
X#if debug
X	printf("%d bytes/sec\n", xfer);
X#endif
X    }
X#if debug
X    else
X	printf(" -- too quick to time!\n");
X#endif
X#if awk
X    fprintf(stderr, "%.2f", t > 0 ? (float)xfer/1024 : 0);
X#endif
X
X    sync();
X    sleep(5);
X    sync();
X    lseek(f, 0L, 0);
X    time();
X    for (i = 0; i < nblock; i++) {
X	if (read(f, buf, sizeof(buf)) <= 0)
X	    perror("fstime: read");
X    }
X    time();
X#if debug
X    printf("Effective read rate: ");
X#endif
X    i = now.millitm - then.millitm;
X    t = (now.time - then.time)*1000 + i;
X    if (t > 0) {
X	xfer = nblock * sizeof(buf) * 1000 / t;
X#if debug
X	printf("%d bytes/sec\n", xfer);
X#endif
X    }
X#if debug
X    else
X	printf(" -- too quick to time!\n");
X#endif
X#if awk
X    fprintf(stderr, " %.2f", t > 0 ? (float)xfer/1024 : 0);
X#endif
X
X    sync();
X    sleep(5);
X    sync();
X    lseek(f, 0L, 0);
X    time();
X    for (i = 0; i < nblock; i++) {
X	if (read(f, buf, sizeof(buf)) <= 0)
X	    perror("fstime: read in copy");
X	if (write(g, buf, sizeof(buf)) <= 0)
X	    perror("fstime: write in copy");
X    }
X    time();
X#if debug
X    printf("Effective copy rate: ");
X#endif
X    i = now.millitm - then.millitm;
X    t = (now.time - then.time)*1000 + i;
X    if (t > 0) {
X	xfer = nblock * sizeof(buf) * 1000 / t;
X#if debug
X	printf("%d bytes/sec\n", xfer);
X#endif
X    }
X#if debug
X    else
X	printf(" -- too quick to time!\n");
X#endif
X#if awk
X    fprintf(stderr, " %.2f\n", t > 0 ? (float)xfer/1024 : 0);
X#endif
X
X}
END_OF_FILE
if test 3552 -ne `wc -c <'testdir/cctest.c'`; then
    echo shar: \"'testdir/cctest.c'\" unpacked with wrong size!
fi
chmod +x 'testdir/cctest.c'
# end of 'testdir/cctest.c'
fi
if test -f 'testdir/sort.src' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'testdir/sort.src'\"
else
echo shar: Extracting \"'testdir/sort.src'\" \(8546 characters\)
sed "s/^X//" >'testdir/sort.src' <<'END_OF_FILE'
version="1.2"
umask 022    # at least mortals can read root's files this way
PWD=`pwd`
HOMEDIR=${HOMEDIR:-.}
cd $HOMEDIR
HOMEDIR=`pwd`
cd $PWD
BINDIR=${BINDIR:-${HOMEDIR}/pgms}
cd $BINDIR
BINDIR=`pwd`
cd $PWD
PATH="${PATH}:${BINDIR}"
SCRPDIR=${SCRPDIR:-${HOMEDIR}/pgms}
cd $SCRPDIR
SCRPDIR=`pwd`
cd $PWD
TMPDIR=${HOMEDIR}/tmp
cd $TMPDIR
TMPDIR=`pwd`
cd $PWD
RESULTDIR=${RESULTDIR:-${HOMEDIR}/results}
cd $RESULTDIR
RESULTDIR=`pwd`
cd $PWD
TESTDIR=${TESTDIR:-${HOMEDIR}/testdir}
cd $TESTDIR
TESTDIR=`pwd`
cd $PWD
export BINDIR TMPDIR RESULTDIR PATH
echo "kill -9 $$" > ${TMPDIR}/kill_run ; chmod u+x ${TMPDIR}/kill_run
arithmetic="arithoh register short int long float double dc"
system="syscall pipe context1 spawn execl fstime"
mem="seqmem randmem"
misc="C shell"
dhry="dhry2 dhry2reg" # dhrystone loops
db="dbmscli" # add to as new database engines are developed
load="shell" # cummulative load tests
args="" # the accumulator for the bench units to be run
runoption="N"
for word
do  # do level 1
case $word
in
all)
X;;
arithmetic)
args="$args $arithmetic"
X;;
db)
args="$args $db"
X;;
dhry)
args="$args $dhry"
X;;
load)
args="$args $load"
X;;
mem)
args="$args $mem"
X;;
misc)
args="$args $misc"
X;;
speed)
args="$args $arithmetic $system"
X;;
system)
args="$args $system"
X;;
X-q|-Q)
runoption="Q" #quiet
X;;
X-v|-V)
runoption="V" #verbose
X;;
X-d|-D)
runoption="D" #debug
X;;
X*)
args="$args $word"
X;;
esac
done # end do level 1
set - $args
if test $# -eq 0  #no arguments specified
then
set - $dhry $arithmetic $system $misc  # db and work not included
fi
if test "$runoption" = 'D'
then
set -x
set -v
fi
date=`date`
tmp=${TMPDIR}/$$.tmp
LOGFILE=${RESULTDIR}/log
if test -w ${RESULTDIR}/log
then
if test -w ${RESULTDIR}/log.accum
then
cat ${RESULTDIR}/log >> ${RESULTDIR}/log.accum
rm ${RESULTDIR}/log
else
mv ${RESULTDIR}/log ${RESULTDIR}/log.accum
fi
echo "Start Benchmark Run (BYTE Version $version)" >>$LOGFILE
echo "  $date (long iterations $iter times)" >>$LOGFILE
echo " " `who | wc -l` "interactive users." >>$LOGFILE
uname -a >>$LOGFILE
iter=${iterations-6}
if test $iter -eq 6
then
longloop="1 2 3 4 5 6"
shortloop="1 2 3"
else  # generate list of loop numbers
short=`expr \( $iter + 1 \) / 2`
longloop=""
shortloop=""
while test $iter -gt 0
do # do level 1
longloop="$iter $longloop"
if test $iter -le $short
then
shortloop="$iter $shortloop"
fi
iter=`expr $iter - 1`
done # end do level 1
fi #loop list genration
for bench # line argument processing
do # do level 1
X# set some default values
prog=${BINDIR}/$bench  # the bench name is default program
need=$prog             # we need the at least the program
paramlist="#"          # a dummy parameter to make anything run
testdir="${TESTDIR}"   # the directory in which to run the test
prepcmd=""             # preparation command or script
parammsg=""
repeat="$longloop"
stdout="$LOGFILE"
stdin=""
cleanopt="-t $tmp"
bgnumber=""
trap "${SCRPDIR}/cleanup -l $LOGFILE -a; exit" 1 2 3 15
if [ $runoption != 'Q' ]
then
echo "$bench: \c"
fi
echo "" >>$LOGFILE
X###################### select the bench specific values ##########
case $bench
in
dhry2)
options=${dhryloops-10000}
logmsg="Dhrystone 2 without register variables"
cleanopt="-d $tmp"
X;;
dhry2reg)
options=${dhryloops-10000}
logmsg="Dhrystone 2 using register variables"
cleanopt="-d $tmp"
X;;
arithoh|register|short|int|long|float|double)
options=${arithloop-10000}
logmsg="Arithmetic Test (type = $bench): $options Iterations"
X;;
dc)  need=dc.dat
prog=dc
options=""
stdin=dc.dat
stdout=/dev/null
logmsg="Arithmetic Test (sqrt(2) with dc to 99 decimal places)"
X;;
hanoi)  options='$param'
stdout=/dev/null
logmsg="Recursion Test: Tower of Hanoi Problem"
paramlist="${ndisk-17}"
parammsg='$param Disk Problem:'
X;;
syscall)
options=${ncall-4000}
logmsg="System Call Overhead Test: 5 x $options Calls"
X;;
context1)
options=${switch1-500}
logmsg="Pipe-based Context Switching Test: 2 x $options Switches"
X;;
pipe)   options=${io-2048}
logmsg="Pipe Throughput Test: read & write $options x 512 byte blocks"
X;;
spawn)  options=${children-100}
logmsg="Process Creation Test: $options forks"
X;;
execl)  options=${nexecs-100}
logmsg="Execl Throughput Test: $options execs"
X;;
randmem|seqmem)
if test $bench = seqmem
then
type=Sequential
else
type=Random
fi
poke=${poke-1000000}
options='-s$param '"-n$poke"
logmsg="$type Memory Access Test: $poke Accesses"
paramlist=${arrays-"512 1024 2048 8192 16384"}
parammsg='Array Size: $param bytes'
cleanopt="-m $tmp"
X;;
fstime) repeat="$shortloop"
where=${where-${TMPDIR}}
options='$param '"$where"
logmsg="Filesystem Throughput Test:"
paramlist=${blocks-"512 1024 2048 8192"}
parammsg='File Size: $param blocks'
cleanopt="-f $tmp"
X;;
C)   need=cctest.c
prog=cc
options='$param'
stdout=/dev/null
repeat="$shortloop"
logmsg="C Compiler Test:"
paramlist="cctest.c"
parammsg='cc $param'
rm -f a.out
X;;
dbmscli)
repeat="$shortloop"
need="db.dat"
prepcmd='${BINDIR}/dbprep ${testdir}/db.dat 10000'
paramlist=${clients-"1 2 4 8"}
parammsg='$param client processes. (filesize `cat ${testdir}/db.dat|wc -c` bytes)'
logmsg="Client/Server Database Engine:"
options='${testdir}/db.dat $param 0 1000'  # $param clients;
X# 0 sleep; 1000 iterations
X;;
shell)
prog="multi.sh"
repeat="$shortloop"
logmsg="Bourne shell script and Unix utilities"
paramlist=${background-"1 2 4 8"}
parammsg='$param concurrent background processes'
bgnumber='$param'
testdir="shelldir"
X;;
X*)   ${BINDIR}/cleanup -l $LOGFILE -r "run: unknown benchmark \"$bench\"" -a
exit 1
X;;
esac
echo "$logmsg" >>$LOGFILE
for param in $paramlist
do   # level 2
param=`echo $param | sed 's/_/ /g'` # be sure that spaces are used
X# underscore can couple params
if [ "$runoption" != "Q" ]
then
echo "\n   [$param] -\c"           # generate message to user
fi
eval msg='"'$parammsg'"'            # the eval is used to
if test "$msg"                      # evaluate any embedded
then                                # variables in the parammsg
echo "" >>$LOGFILE
echo "$msg" >>$LOGFILE
fi
eval opt='"'$options'"'   # evaluate any vars in options
eval prep='"'$prepcmd'"'   # evaluate any prep command
eval bg='"'$bgnumber'"'   # evaluate bgnumber string
rm -f $tmp    # remove any tmp files
X# if the test requires mulitple concurrent processes,
X# prepare the background process string (bgstr)
X# this is just a string of "+"s that will provides a
X# parameter count for a "for" loop
bgstr=""
if test "$bg" != ""
then
count=`expr "$bg"`
while test $count -gt 0
do
bgstr="+ $bgstr"
count=`expr $count - 1`
done
fi
X#
for i in $repeat    # loop for the specified number
do  # do depth 3
if [ "$runoption" != 'D' ]  # level 1
then
X# regular Run - set logfile to go on signal
trap "${SCRPDIR}/cleanup -l $LOGFILE -i $i $cleanopt -a; exit" 1 2 3 15
else
trap "exit" 1 2 3 15
fi #end level 1
if [ "$runoption" != 'Q' ]
then
echo " $i\c"                  # display repeat number
fi
pwd=`pwd`                     # remember where we are
cd $testdir                   # move to the test directory
if [ "$runoption" = "V" ]
then
echo
echo "BENCH COMMAND TO BE EXECUTED:"
echo "$prog $opt"
fi
X# execute any prepratory command string
if [ -n "$prep" ]
then
X$prep >>$stdout 
fi
X############ THE BENCH IS TIMED ##############
if test "$stdin" = ""  
then # without redirected stdin
time $prog $opt $bgstr 2>>$tmp >>$stdout
else # with redirected stdin
time $prog $opt $bgstr <$stdin 2>>$tmp >>$stdout
fi 
time $benchcmd
X###############################################
cd $pwd                    # move back home
status=$?                  # save the result code
if test $status != 0 # must have been an error
then
if test -f $tmp # is there an error file ?
then
cp $tmp ${TMPDIR}/save.$bench.$param
X${SCRPDIR}/cleanup -l $LOGFILE -i $i $cleanopt -r \
X"run: bench=$bench param=$param fatalstatus=$status" -a
else
X${SCRPDIR}/cleanup -l $LOGFILE -r \
X"run: bench=$bench param=$param fatalstatus=$status" -a
fi 
exit # leave the script if there are errors
fi # end  level 1
done # end do depth 3 - repeat of bench
if [ "$runoption" != 'D' ]
then
X${SCRPDIR}/cleanup -l $LOGFILE $cleanopt # finalize this bench
X# with these options
X# & calculate results
fi
done # end do depth 2 - end of all options for this bench
X########### some specific cleanup routines ##############
case $bench
in
C)
rm -f cctest.o a.out
X;;
esac
if [ "$runoption" != 'Q' ]
then
echo ""
fi
done # end do level 1  - all benchmarks requested
echo "" >>$LOGFILE
echo " " `who | wc -l` "interactive users." >>$LOGFILE
echo "End Benchmark Run ($date) ...." >>$LOGFILE
if [ "$runoption" != 'Q' ]
then
pg $LOGFILE
fi
exit
END_OF_FILE
if test 8546 -ne `wc -c <'testdir/sort.src'`; then
    echo shar: \"'testdir/sort.src'\" unpacked with wrong size!
fi
chmod +x 'testdir/sort.src'
# end of 'testdir/sort.src'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
