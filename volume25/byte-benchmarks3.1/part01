Newsgroups: comp.sources.unix
From: ben@bytepb.byte.com (Ben Smith @ BYTE)
Subject: v25i108: BYTE Benchmarks, V3.1, Part01/04
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: ben@bytepb.byte.com (Ben Smith @ BYTE)
Posting-Number: Volume 25, Issue 108
Archive-Name: byte-benchmarks3.1/part01

[ This is a benchmark suite similar in spirit to SPEC, except that it's
  smaller and contains mostly things like "sieve" and "dhrystone".  If
  you are comparing different UN*X machines for performance, this gives
  fairly good numbers.  Note that the numbers aren't useful for anything
  except (perhaps, as in "maybe") for comparison against the same bench-
  mark suite run on some other system.                           --vix ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 4)."
# Contents:  MANIFEST README doc doc/bench3.doc pgms pgms/byte.logo
#   pgms/cleanup.sh pgms/fs.awk pgms/index.awk pgms/index.base
#   pgms/index.sh pgms/loopm.awk pgms/loops.awk pgms/multi.sh
#   pgms/report.awk pgms/report.sh pgms/tst.sh results src src/arith.c
#   src/context1.c src/execl.c src/getopt.c src/hanoi.c src/limit.c
#   src/looper.c src/pipe.c src/spawn.c src/syscall.c src/timeit.c
#   testdir testdir/dc.dat tmp
# Wrapped by vixie@cognition.pa.dec.com on Sun Feb  2 16:27:40 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1491 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	
X Makefile                   2	
X README                     1	
X Run                        3	
X doc                        1	
X doc/bench.doc              3	
X doc/bench3.doc             1	
X pgms                       1	
X pgms/byte.logo             1	
X pgms/cleanup.sh            1	
X pgms/fs.awk                1	
X pgms/index.awk             1	
X pgms/index.base            1	
X pgms/index.sh              1	
X pgms/loopm.awk             1	
X pgms/loops.awk             1	
X pgms/multi.sh              1	
X pgms/report.awk            1	
X pgms/report.sh             1	
X pgms/tst.sh                1	
X results                    1	
X results/reports.shar       2	
X src                        1	
X src/arith.c                1	
X src/big.c                  3	
X src/context1.c             1	
X src/dhry.h                 4	
X src/dhry_1.c               3	
X src/dhry_2.c               2	
X src/dummy.c                2	
X src/execl.c                1	
X src/fstime.c               2	
X src/getopt.c               1	
X src/hanoi.c                1	
X src/limit.c                1	
X src/looper.c               1	
X src/pipe.c                 1	
X src/spawn.c                1	
X src/syscall.c              1	
X src/timeit.c               1	
X testdir                    1	
X testdir/cctest.c           2	
X testdir/dc.dat             1	
X testdir/sort.src           2	
X tmp                        1	
END_OF_FILE
if test 1491 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(6548 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
Version 3.6 -- 5/15/91  19:30:16
X
X================================================================
To use the new BYTE Unix Benchmarks:
X
X   make 
X   Run
X
X================================================================
You may run individual benchmark programs and groups of programs.
There are also a few options.
X
X  Run [<bench> ...] [<group> ...] [-qvd]
X
X	-q	quiet		no output to standard out
X	-v	verbose		extra output to standard out
X	-d	debug		Run is displayed as it is run
X
X     GROUP	BENCHMARK	EXPLANATION		SOURCE
X     --------   -----------	--------------------	-------------
X     index                      only those need for 
X                                generating the BYTE
X                                index
X		double		double arithmetic	src/arith.c
X		dhry2		dhrystone 2 w/o regs	src/dhry_1.c
X							src/dhry_2.c
X							src/dhry.h
X		execl		execl call		src/execl.c
X							src/big.c
X		fstime		filesystem throughput	src/fstime.c
X		pipe		pipe throughput		src/pipe.c
X		shell   	load system with	pgms/multi.sh
X				  concurrent shell	pgms/tst.sh
X				  scripts		src/looper.c
X     arithmetic
X		arithoh		arithmetic overhead 	src/arith.c
X		register	register arithmetic	src/arith.c
X		short		short arithmetic	src/arith.c
X		int		int arithmetic		src/arith.c
X		long		long arithmetic		src/arith.c
X		float		float arithmetic	src/arith.c
X		double		double arithmetic	src/arith.c
X     system
X		syscall		system call overhead	src/syscall.c
X		pipe		pipe throughput		src/pipe.c
X		context1	pipe context switch	src/context1.c
X		spawn		process creation	src/spawn.c
X		execl		execl call		src/execl.c
X		fstime		filesystem throughput	src/fstime.c
X     misc
X		C		compile and link	/bin/cc
X							src/looper.c
X		dc		calculations with dc	testdir/dc.dat
X							src/looper.c
X		hanoi		recursion 		src/hanoi.c
X							src/looper.c
X     dhry
X		dhry2		dhrystone 2 w/o regs	src/dhry_1.c
X							src/dhry_2.c
X							src/dhry.h
X		dhry2reg	dhrystone 2 with regs	src/dhry_1.c
X							src/dhry_2.c
X							src/dhry.h
X		shell   	load system with	pgms/multi.sh
X				  concurrent shell	pgms/tst.sh
X				  scripts
X                        ** Most C programs also include src/timeit.c
X
X===================== RELEASE NOTES =====================================
X
X========================  May 91 ==========================
This is version 3. This set of programs should be able to determine if
your system is BSD or SysV. (It uses the output format of time (1)
to see. If you have any problems, contact me (by email,
preferably): ben@bytepb.byte.com
X
X---
X
The document doc/bench.doc describes the basic flow of the
benchmark system. The document doc/bench3.doc describes the major
changes in design of this version. As a user of the benchmarks,
you should understand some of the methods that have been
implemented to generate loop counts:
X
Tests that are compiled C code:
X  The function wake_me(second, func) is included (from the file
timeit.c). This function uses signal and alarm to set a countdown
for the time request by the benchmark administration script
X(Run). As soon as the clock is started, the test is run with a
counter keeping track of the number of loops that the test makes.
When alarm sends its signal, the loop counter value is sent to stderr
and the program terminates. Since the time resolution, signal
trapping and other factors don't insure that the test is for the
precise time that was requested, the test program is also run
from the time (1) command. The real time value returned from time
X(1) is what is used in calculating the number of loops per second
X(or minute, depending on the test).  As is obvious, there is some
overhead time that is not taken into account, therefore the
number of loops per second is not absolute. The overhead of the
test starting and stopping and the signal and alarm calls is
common to the overhead of real applications. If a program loads
quickly, the number of loops per second increases; a phenomenon
that favors systems that can load programs quickly. (Setting the
sticky bit of the test programs is not considered fair play.)
X
Test that use existing UNIX programs or shell scripts:
X  The concept is the same as that of compiled tests, except the
alarm and signal are contained in separate compiled program,
looper (source is looper.c). Looper uses an execvp to invoke the
test with its arguments. Here, the overhead includes the
invocation and execution of looper.
X
X--
X
The index numbers are generated from a baseline file that is in
pgms/index.base. You can put tests that you wish in this file.
All you need to do is take the results/log file from your
baseline machine, edit out the comment and blank lines, and sort
the result (vi/ex command: 1,$!sort). The sort in necessary
because the process of generating the index report uses join (1).
You can regenerate the reports by running "make report."
X
X--
X
X========================= Jan 90 =============================
Tom Yager has joined the effort here at BYTE; he is responsible
for many refinements in the UNIX benchmarks.
X
The memory access tests have been deleted from the benchmarks.
The file access tests have been reversed so that the test is run
for a fixed time. The amount of data transfered (written, read,
and copied) is the variable. !WARNING! This test can eat up a
large hunk of disk space.
X
The initial line of all shell scripts has been changed from the
SCO and XENIX form (:) to the more standard form "#! /bin/sh".
But different systems handle shell switching differently. Check
the documentation on your system and find out how you are
supposed to do it. Or, simpler yet, just run the benchmarks from
the Bourne shell. (You may need to set SHELL=/bin/sh as well.)
X
The options to Run have not been checked in a while. They may no
longer function. Next time, I'll get back on them. There needs to
be another option added (next time) that halts testing between
each test. !WARNING! Some systems have caches that are not getting flushed
before the next test or iteration is run. This can cause
erroneous values. 
X
X========================= Sept 89 =============================
The database (db) programs now have a tuneable message queue space.
queue space. The default set in the Run script is 1024 bytes.
Other major changes are in the format of the times. We now show
Arithmetic and Geometric mean and standard deviation for User
Time, System Time, and Real Time. Generally, in reporting, we
plan on using the Real Time values with the benchs run with one
active user (the bench user). Comments and arguments are requested.
X
contact: BIX bensmith or rick_g
END_OF_FILE
if test 6548 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
chmod +x 'README'
# end of 'README'
fi
if test ! -d 'doc' ; then
    echo shar: Creating directory \"'doc'\"
    mkdir 'doc'
fi
if test -f 'doc/bench3.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/bench3.doc'\"
else
echo shar: Extracting \"'doc/bench3.doc'\" \(2369 characters\)
sed "s/^X//" >'doc/bench3.doc' <<'END_OF_FILE'
The BYTE Unix benchmarks that we published in March, 1990, we
expected that they fill our needs for several years. It was only a
few months before we started to see that UNIX workstation performance
was going to make the benchmark design questionable. The design flaw
was that the benchmarks timed a fixed number of loops; if there were
to few loops, the times were too small to be reliable. Perhaps we
could have increased the number of loops and been safe for another
few years (months?). But with IBM's introduction of the RS/6000, it
became obvious that we needed to redesign our benchmarks.
X
Now the work on version 3 is complete. The new design increases in
precision on faster workstations because we turned everything
upside-down: we count loops for a fixed amount of time. There are
some additional benefits, the amount of time for running the suite is
relative predictable (about an hour). 
X
Since new benchmarks mean new baselines and indexes, we reevaluated
these elements as well. Though the Everex Step 386/33 is still a very
contemporary machine, the operating system that we were using for the
baseline (SCO Xenix 386 version 2.3.1). We were tempted to use the
new HP 9000 Series 700 as the baseline, but so few machines are in
that league that the index would be very strange. Instead, we have
taken the conservative approach: a popular machine.  The new baseline
machine is the Sun Microsystems [TOM, please fill in configuration],
the baseline for this month's roundup of SPARC clones.
X
We also changed which benchmark tests are used to generate the new
index: 
X * a double precision arithmetic performance test
X * Dhrystone 2 without register variables 
X * Spawning a process (!M!execl()!EM!)
X * File copy throughput in five seconds
X * Pipe-based context switching
X * The shell script with 8 concurrent scripts running
X
Instead of just summing the indexes of each of these tests to get the
overall index, we are using the average. This means that the baseline
value is 1 instead of six.
X
As always, the BYTE Unix benchmarks are freely available from BIX and
on the Usenet. Version 3 automatically configures to System V and BSD
Unix systems. It also includes scripts for generating the indexes.
Thanks to the many users who sent use reports and suggestions for
Version 2, BYTE and you have a much better set of tools for
benchmarking UNIX systems.
X
END_OF_FILE
if test 2369 -ne `wc -c <'doc/bench3.doc'`; then
    echo shar: \"'doc/bench3.doc'\" unpacked with wrong size!
fi
chmod +x 'doc/bench3.doc'
# end of 'doc/bench3.doc'
fi
if test ! -d 'pgms' ; then
    echo shar: Creating directory \"'pgms'\"
    mkdir 'pgms'
fi
if test -f 'pgms/byte.logo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgms/byte.logo'\"
else
echo shar: Extracting \"'pgms/byte.logo'\" \(1395 characters\)
sed "s/^X//" >'pgms/byte.logo' <<'END_OF_FILE'
X
X         ############   #####        ## ############### ###############
X         ############## #####        ## ############### ###############
X         #####       ## #####        ##      #####      #####         
X         #####       ## #####        ##      #####      #####         
X         #####       ## #####        ##      #####      #####         
X         ############   #####       ##       #####      ###############
X         #############   ######### ##        #####      ###############
X         #####       ##   ##########         #####      #####         
X         #####       ##      #####           #####      #####         
X         #####       ##      #####           #####      #####         
X         #####       ##      #####           #####      #####         
X         ##############      #####           #####      ###############
X         ############        #####           #####      ###############
X
X
X   #    #  #    #  #  #    #          #####   ######  #    #   ####   #    #
X   #    #  ##   #  #   #  #           #    #  #       ##   #  #    #  #    #
X   #    #  # #  #  #    ##            #####   #####   # #  #  #       ######
X   #    #  #  # #  #    ##            #    #  #       #  # #  #       #    #
X   #    #  #   ##  #   #  #           #    #  #       #   ##  #    #  #    #
X    ####   #    #  #  #    #          #####   ######  #    #   ####   #    #
X
END_OF_FILE
if test 1395 -ne `wc -c <'pgms/byte.logo'`; then
    echo shar: \"'pgms/byte.logo'\" unpacked with wrong size!
fi
chmod +x 'pgms/byte.logo'
# end of 'pgms/byte.logo'
fi
if test -f 'pgms/cleanup.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgms/cleanup.sh'\"
else
echo shar: Extracting \"'pgms/cleanup.sh'\" \(2621 characters\)
sed "s/^X//" >'pgms/cleanup.sh' <<'END_OF_FILE'
X#! /bin/sh
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 3
X#          Module: cleanup.sh   SID: 3.5 5/15/91 19:30:26
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	ben@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X###############################################################################
X#  Modification Log:
X#  added report for dhrystones 6/89 - ben
X#
X###############################################################################
ID="@(#)cleanup.sh:3.5 -- 5/15/91 19:30:26";
X#
X# $Header: cleanup,v 5.2 88/01/07 10:58:24 kenj Exp $
X#
X#  Cleanup when an iterative test terminates
X#
BINDIR=${BINDIR-./pgms}
log=${LOG-./results/log}
timeaccum=${TIMEACCUM-./results/times}
flavor="${FLAVOR-SysV}"
while ( test $# -ge 1 )
do
X    opt=$1
X    shift
X    case $opt
X      in
X
X    -a) : abort
X	echo '' >>$LOGFILE
X	echo '**************************' >>$LOGFILE
X	echo '* Benchmark Aborted .... *' >>$LOGFILE
X	echo '**************************' >>$LOGFILE
X	echo
X	echo 'Benchmark Aborted ....'    # notice displayed on screen
X	echo "" >>$LOGFILE
X	echo " " `who | wc -l` "interactive users." >>$LOGFILE
X	echo "" >>$LOGFILE
X	date=`date`
X	echo "End Benchmark Run ($date) ...." >>$LOGFILE
X	echo "End Benchmark Run ($date) ...."
X	;;
X
X
X    -f) : filesystem throughput
X	awk -f ${BINDIR}/fs.awk <$1 >>$LOGFILE
X	cat $1 >> $timeaccum 2>/dev/null
X	rm -f $1
X	shift
X	;;
X    
X    -d) : dhrystone evaluation
X	awk -f ${BINDIR}/dhry.awk <$1 >>$LOGFILE
X	cat $1 >> $timeaccum 2>/dev/null
X	rm -f $1
X	shift
X	;;
X    -l) : loops per second for a specified time evaluation
X	awk -f ${BINDIR}/loops.awk  <$1 >>$LOGFILE
X	cat $1 >> $timeaccum 2>/dev/null
X	rm -f $1
X	shift
X	;;
X    
X    
X    -m) : loops per minute for a specified time evaluation
X	awk -f ${BINDIR}/loopm.awk  <$1 >>$LOGFILE
X	cat $1 >> $timeaccum 2>/dev/null
X	rm -f $1
X	shift
X	;;
X    
X    -i) : report last iteration
X	echo "Terminated during iteration $1" >>$LOGFILE
X	shift
X	;;
X
X    -L) : logfile
X	LOGFILE=$1
X	shift
X	;;
X    
X    -r) : reason for failure
X	echo $1
X	echo $1 >>$LOGFILE
X	shift
X	;;
X
X    -m) : mem throughput tests
X	awk -f ${BINDIR}/mem.awk <$1 >>$LOGFILE
X	cat $1 >> $timeaccum 2>/dev/null
X	rm -f $1
X	shift
X	;;
X
X    -t) : timing with /bin/time
X	awk -f ${BINDIR}/time.awk <$1 >>$LOGFILE
X	cat $1 >> $timeaccum 2>/dev/null
X	rm -f $1
X	shift
X	;;
X
X
X    '') : 'skip it (residual effect of shifts)'
X	;;
X
X    *)
X	echo "cleanup: bad option ($opt)" >>$LOGFILE
esac
done
exit
END_OF_FILE
if test 2621 -ne `wc -c <'pgms/cleanup.sh'`; then
    echo shar: \"'pgms/cleanup.sh'\" unpacked with wrong size!
fi
chmod +x 'pgms/cleanup.sh'
# end of 'pgms/cleanup.sh'
fi
if test -f 'pgms/fs.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgms/fs.awk'\"
else
echo shar: Extracting \"'pgms/fs.awk'\" \(1992 characters\)
sed "s/^X//" >'pgms/fs.awk' <<'END_OF_FILE'
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 3
X#          Module: fs.awk   SID: 3.4 5/15/91 19:30:24
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Tom Yager at BYTE Magazine
X#	ben@bytepb.byte.com   tyager@bytepb.byte.com
X#
X###############################################################################
X#  Modification Log:
X#       added geometric mean 8/6/89 -ben
X#       modified for new version of fstime 11/15/89 -ben
X#       removed variance 10/23/90 -ben
X#
X###############################################################################
BEGIN   { w_product = 0.0000;
X	r_product = 0.0000;
X	c_product = 0.0000;
X	iter=0;
X	w_too_quick=0;
X	r_too_quick=0;
X	c_too_quick=0;
X	}
X/FLAVOR\|/ { split($0, junk,"|");
X	flavor=junk[2] ;
X		}
X/real/	{ iter++; ok++; next; }
X/user/	{ if (flavor == "SysV") {next;} }
X/sys/	{ if (flavor == "SysV") {next;} }
X/^$/	{ next; } 
X/^#/	{ next; } 
X/sample/ { sample = $1; next; }
X/fstime/ {
X         print "** Iteration ",iter," Failed: ",$0; 
X	 ok--;
X         fail=1;
X         } 
X/write/ { if (!fail) {
X	       w+=$1;
X	       w2+=$1*$1;
X	       w_product += log($1); 
X	       }
X        }
X/read/  { if (!fail) {
X	       r+=$1;
X	       r2+=$1*$1;
X	       r_product += log($1); 
X	       }
X        }
X/copy/  { if (!fail) {
X	       c+=$1;
X	       c2+=$1*$1;
X	       c_product += log($1);
X	       }
X	}
XEND {
X	if (ok > 0) {
X# TestName|Sample(seconds)|Unit(KiloBytes/sec)|ArithMean|GeoMean|DataPoints
X	    printf "File Read  (%d seconds)|%d|KBps|%.0f|%.0f|%d\n",sample,sample,r/ok,exp(r_product/ok),ok;
X	    printf "File Write (%d seconds)|%d|KBps|%.0f|%.0f|%d\n",sample,sample,w/ok,exp(w_product/ok),ok;
X	    printf "File Copy  (%d seconds)|%d|KBps|%.0f|%.0f|%d\n",sample,sample,c/ok,exp(c_product/ok),ok;
X	} else {
X	    print "File I/O|  no measured results|"
X	}
X    }
END_OF_FILE
if test 1992 -ne `wc -c <'pgms/fs.awk'`; then
    echo shar: \"'pgms/fs.awk'\" unpacked with wrong size!
fi
chmod +x 'pgms/fs.awk'
# end of 'pgms/fs.awk'
fi
if test -f 'pgms/index.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgms/index.awk'\"
else
echo shar: Extracting \"'pgms/index.awk'\" \(497 characters\)
sed "s/^X//" >'pgms/index.awk' <<'END_OF_FILE'
BEGIN	{ 
X	FS="|" ; 
X	sum=0.00; 
X	n=0;
X	printf("\n                     INDEX VALUES            \n");
X	printf("TEST%40sBASELINE     RESULT      INDEX\n\n","");
X
X	}
X
X	{ # process all lines - use geometric means
X	idex = $10/$5;
X	sum += idex;
X	++n;
X	printf("%-40s  %10.1f %10.1f %10.1f\n",$1,$5,$10,idex);
X	}
X
XEND	{
X	printf("              %30s                     =========\n","");
X	printf("     SUM of %2d items  %30s  %20.1f\n",n,"",sum);
X	printf("     AVERAGE          %30s  %20.1f\n","",sum/n);
X	}
END_OF_FILE
if test 497 -ne `wc -c <'pgms/index.awk'`; then
    echo shar: \"'pgms/index.awk'\" unpacked with wrong size!
fi
chmod +x 'pgms/index.awk'
# end of 'pgms/index.awk'
fi
if test -f 'pgms/index.base' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgms/index.base'\"
else
echo shar: Extracting \"'pgms/index.base'\" \(314 characters\)
sed "s/^X//" >'pgms/index.base' <<'END_OF_FILE'
Arithmetic Test (type = double)|10.0|lps|2541.7|2541.7|6
Dhrystone 2 without register variables|10.0|lps|22366.4|22366.3|6
XExecl Throughput Test|9.4|lps|16.5|16.5|6
XFile Copy  (30 seconds)|30|KBps|179|179|6
Pipe-based Context Switching Test|10.0|lps|1318.5|1318.5|6
Shell scripts (8 concurrent)|60.1|lpm|4.0|4.0|3
END_OF_FILE
if test 314 -ne `wc -c <'pgms/index.base'`; then
    echo shar: \"'pgms/index.base'\" unpacked with wrong size!
fi
chmod +x 'pgms/index.base'
# end of 'pgms/index.base'
fi
if test -f 'pgms/index.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgms/index.sh'\"
else
echo shar: Extracting \"'pgms/index.sh'\" \(1541 characters\)
sed "s/^X//" >'pgms/index.sh' <<'END_OF_FILE'
X##############################################################################
X#  The BYTE UNIX Benchmarks - Release 3
X#          Module: index.sh   SID: 3.5 5/15/91 19:30:24
X#          
X##############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Tom Yager at BYTE Magazine
X#	ben@bytepb.byte.com   tyager@byptepb.byte.com
X#
X##############################################################################
X# generate an index from test log
X# 
X#############################################################################
X#  Modification Log:
X#        created 4/1/91 - Ben Smith
X#
X##############################################################################
BINDIR=${BINDIR-pgms}
BASE=${BASE-pgms/index.base}
TARGET=${TARGET-results/log}
TEMP=/tmp/$$.dat
X#
X# BASELINE DATA
X#
if [ $# -lt 1 ]
then
X	echo "Data File for baseline: \c"
X	read BASE
else
X	BASE=$1
fi
X# check for existance
if [ ! -r ${BASE} ]
then
X	echo "Cannot open $BASE for reading"
X	exit 1
fi
X#
X# RESULTS TARGET
X#
if [ $# -lt 2 ]
then
X	echo "Source File for target machine results: \c"
X	read TARGET
else
X	TARGET=$2
fi
X# check for existance
if [ ! -r ${TARGET} ]
then
X	echo "Cannot open $TARGET for reading"
X	exit 1
fi
X#
X# make dat file for results
X sort $TARGET > ${TEMP}
X#
X# DESTINATION
X#
if [ $# -eq 3 ]
then
X	DEST=$3
X	join -t'|' ${BASE} ${TEMP} | awk -f ${BINDIR}/index.awk > ${DEST}
else
X	join -t'|' ${BASE} ${TEMP} | awk -f ${BINDIR}/index.awk
fi
X
X# cleanup
rm -f ${TEMP}
X
X
X
END_OF_FILE
if test 1541 -ne `wc -c <'pgms/index.sh'`; then
    echo shar: \"'pgms/index.sh'\" unpacked with wrong size!
fi
chmod +x 'pgms/index.sh'
# end of 'pgms/index.sh'
fi
if test -f 'pgms/loopm.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgms/loopm.awk'\"
else
echo shar: Extracting \"'pgms/loopm.awk'\" \(1800 characters\)
sed "s/^X//" >'pgms/loopm.awk' <<'END_OF_FILE'
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 1
X#          Module: loopm.awk   SID: 1.4 5/15/91 19:30:25
X#      LOOPS per minute
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Tom Yager at BYTE Magazine
X#	ben@bytepb.byte.com   tyager@bytepb.byte.com
X#
X###############################################################################
X#  Modification Log:
X#        created 2/12/91 -ben
X#
X###############################################################################
BEGIN { rsum = 0.000; r2sum = 0.000; r_product = 0.0000;
X	  iter = 0; Test=""; SubTest=""; secs = 0.00; secs_sum = 0.00;
X	  mins = 0.000; time_str=""; flavor="SysV";
X	}
X/TEST\|/ { split($0, junk,"|");
X	Test=junk[2]; 
X	}
X/FLAVOR\|/ { split($0, junk,"|");
X	flavor=junk[2] ; 
X	}
X/loops/ { loops=$1; 
X	iter ++;
X        }
X/real/	{ if (flavor == "SysV") {time_str = $2; }
X  	else { time_str = $1; }
X	# determine seconds from time_str
X	if ( time_str ~/\:/)
X	   {
X	   split(time_str,junk,":");
X	   secs = 60 * junk[1] + junk[2];
X	   }
X	else { secs = time_str; }
X	mins=secs/60.000; 
X	print mins;
X	if(loops) { rsum += loops/mins;
X		r2sum += (loops*loops)/(mins*mins);
X		r_product += (log(loops)-log(mins));
X		secs_sum += secs;
X		}
X	}  
X/user/	{ if (flavor == "SysV") { next;} } # don't use these times
X/sys/	{ if (flavor == "SysV") { next;} } # don't use these times
X#/^$/	{ next } 
XEND {
X	if (iter > 0) {  
X# TestName|Sample(seconds)|units|ArithMean|GeoMean|DataPoints
X	    printf("%s|%.1f|lpm|%.1f|%.1f|%d\n",Test,secs_sum/iter,rsum/iter,exp(r_product/iter),iter);
X	    }
X	else { 
X	    printf("%s|  no measured results|\n",Test); 
X	    }
X    }
END_OF_FILE
if test 1800 -ne `wc -c <'pgms/loopm.awk'`; then
    echo shar: \"'pgms/loopm.awk'\" unpacked with wrong size!
fi
chmod +x 'pgms/loopm.awk'
# end of 'pgms/loopm.awk'
fi
if test -f 'pgms/loops.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgms/loops.awk'\"
else
echo shar: Extracting \"'pgms/loops.awk'\" \(1716 characters\)
sed "s/^X//" >'pgms/loops.awk' <<'END_OF_FILE'
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 1
X#          Module: loops.awk   SID: 1.4 5/15/91 19:30:25
X#      LOOPS per second
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Tom Yager at BYTE Magazine
X#	ben@bytepb.byte.com   tyager@bytepb.byte.com
X#
X###############################################################################
X#  Modification Log:
X#        created 2/12/91 -ben
X#
X###############################################################################
BEGIN { rsum = 0.000; r2sum = 0.000; r_product = 0.0000;
X	  iter = 0; Test=""; SubTest=""; secs = 0.00; secs_sum = 0.00;
X	}
X/TEST\|/ { split($0, junk,"|");
X	Test=junk[2]; 
X	}
X/FLAVOR\|/ { split($0, junk,"|");
X	flavor=junk[2] ; 
X	}
X/loops/ { loops=$1; 
X	iter ++;
X        }
X/real/	{ if (flavor == "SysV") {time_str=$2; }
X	  else {time_str=$1; }
X	# determine seconds from time_str
X	if ( time_str ~/\:/)
X	   {
X	   split(time_str,junk,":");
X	   secs = 60 * junk[1] + junk[2];
X	   }
X	else { secs = time_str; }
X	if(loops) { rsum += loops/secs;
X		r2sum += (loops*loops)/(secs*secs);
X		r_product += (log(loops)-log(secs));
X		secs_sum += secs;
X		}
X	}  
X/user/	{ if (flavor == "SysV") { next;} } # don't use these times
X/sys/	{ if (flavor == "SysV") { next;} } # don't use these times
X#/^$/	{ next } 
XEND {
X	if (iter > 0) {  
X# TestName|Sample(seconds)|units|ArithMean|GeoMean|DataPoints
X	    printf("%s|%.1f|lps|%.1f|%.1f|%d\n",Test,secs_sum/iter,rsum/iter,exp(r_product/iter),iter)
X	    }
X	else { 
X	    printf("%s|  no measured results|\n",Test); 
X	    }
X    }
END_OF_FILE
if test 1716 -ne `wc -c <'pgms/loops.awk'`; then
    echo shar: \"'pgms/loops.awk'\" unpacked with wrong size!
fi
chmod +x 'pgms/loops.awk'
# end of 'pgms/loops.awk'
fi
if test -f 'pgms/multi.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgms/multi.sh'\"
else
echo shar: Extracting \"'pgms/multi.sh'\" \(704 characters\)
sed "s/^X//" >'pgms/multi.sh' <<'END_OF_FILE'
X#! /bin/sh
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 3
X#          Module: multi.sh   SID: 3.4 5/15/91 19:30:24
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	ben@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X###############################################################################
X#  Modification Log:
X#
X###############################################################################
ID="@(#)multi.sh:3.4 -- 5/15/91 19:30:24";
for i
do
X	/bin/sh $BINDIR/tst.sh &
done
wait
X
END_OF_FILE
if test 704 -ne `wc -c <'pgms/multi.sh'`; then
    echo shar: \"'pgms/multi.sh'\" unpacked with wrong size!
fi
chmod +x 'pgms/multi.sh'
# end of 'pgms/multi.sh'
fi
if test -f 'pgms/report.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgms/report.awk'\"
else
echo shar: Extracting \"'pgms/report.awk'\" \(969 characters\)
sed "s/^X//" >'pgms/report.awk' <<'END_OF_FILE'
X##############################################################################
X#  The BYTE UNIX Benchmarks - Release 1
X#          Module: report.awk   SID: 1.4 5/15/91 19:30:25
X#          
X##############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Tom Yager at BYTE Magazine
X#	ben@bytepb.byte.com   tyager@byptepb.byte.com
X#
X##############################################################################
X# generate an report from test log
X# 
X#############################################################################
X#  Modification Log:
X#        created 4/1/91 - Ben Smith
X#
X##############################################################################
BEGIN { FS="|" ; 
X	printf("\n");
X      }
NF==2		{ print $2; }
NF==3		{ printf("%-40.40s %s\n",$1,$2); }
NF==6		{ printf("%-40.40s %8.1f %-5s (%d secs, %d samples)\n",$1,$5,$3,$2,$6); }
XEND   { printf("\n"); }
END_OF_FILE
if test 969 -ne `wc -c <'pgms/report.awk'`; then
    echo shar: \"'pgms/report.awk'\" unpacked with wrong size!
fi
chmod +x 'pgms/report.awk'
# end of 'pgms/report.awk'
fi
if test -f 'pgms/report.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgms/report.sh'\"
else
echo shar: Extracting \"'pgms/report.sh'\" \(1071 characters\)
sed "s/^X//" >'pgms/report.sh' <<'END_OF_FILE'
X##############################################################################
X#  The BYTE UNIX Benchmarks - Release 1
X#          Module: report.sh   SID: 1.4 5/15/91 19:30:26
X#          
X##############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Tom Yager at BYTE Magazine
X#	ben@bytepb.byte.com   tyager@byptepb.byte.com
X#
X##############################################################################
X# generate an report from test log
X# 
X#############################################################################
X#  Modification Log:
X#        created 4/1/91 - Ben Smith
X#
X##############################################################################
BINDIR=${BINDIR-pgms}
TARGET=${TARGET-results/log}
X# RESULTS TARGET
X#
if [ $# -lt 1 ]
then
X	echo "Source File for target machine results: \c"
X	read TARGET
else
X	TARGET=$1
fi
X# check for existance
if [ ! -r ${TARGET} ]
then
X	echo "Cannot open $TARGET for reading"
X	exit 1
fi
awk -f ${BINDIR}/report.awk $TARGET
X
X
END_OF_FILE
if test 1071 -ne `wc -c <'pgms/report.sh'`; then
    echo shar: \"'pgms/report.sh'\" unpacked with wrong size!
fi
chmod +x 'pgms/report.sh'
# end of 'pgms/report.sh'
fi
if test -f 'pgms/tst.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgms/tst.sh'\"
else
echo shar: Extracting \"'pgms/tst.sh'\" \(785 characters\)
sed "s/^X//" >'pgms/tst.sh' <<'END_OF_FILE'
X#! /bin/sh
X###############################################################################
X#  The BYTE UNIX Benchmarks - Release 3
X#          Module: tst.sh   SID: 3.4 5/15/91 19:30:24
X#          
X###############################################################################
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	Ben Smith or Rick Grehan at BYTE Magazine
X#	ben@bytepb.UUCP    rick_g@bytepb.UUCP
X#
X###############################################################################
X#  Modification Log:
X#
X###############################################################################
ID="@(#)tst.sh:3.4 -- 5/15/91 19:30:24";
sort >sort.$$ <sort.src
od sort.$$ | sort -n +1 > od.$$
grep the sort.$$ | tee grep.$$ | wc > wc.$$
rm sort.$$ grep.$$ od.$$ wc.$$
END_OF_FILE
if test 785 -ne `wc -c <'pgms/tst.sh'`; then
    echo shar: \"'pgms/tst.sh'\" unpacked with wrong size!
fi
chmod +x 'pgms/tst.sh'
# end of 'pgms/tst.sh'
fi
if test ! -d 'results' ; then
    echo shar: Creating directory \"'results'\"
    mkdir 'results'
fi
if test ! -d 'src' ; then
    echo shar: Creating directory \"'src'\"
    mkdir 'src'
fi
if test -f 'src/arith.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/arith.c'\"
else
echo shar: Extracting \"'src/arith.c'\" \(2655 characters\)
sed "s/^X//" >'src/arith.c' <<'END_OF_FILE'
X
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: arith.c   SID: 3.3 5/15/91 19:30:19
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yager
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X *  May 12, 1989 - modified empty loops to avoid nullifying by optimizing
X *                 compilers
X *  August 28, 1990 - changed timing relationship--now returns total number
X *	                  of iterations (ty)
X *  November 9, 1990 - made changes suggested by Keith Cantrell
X *                        (digi!kcantrel) to defeat optimization
X *                        to non-existence
X *
X ******************************************************************************/
X
char SCCSid[] = "@(#) @(#)arith.c:3.3 -- 5/15/91 19:30:19";
X/*
X *  arithmetic test
X *
X */
X
X#include <stdio.h>
X#include "timeit.c"
X
unsigned long iter;
X
X/* this function is called when the alarm expires */
report()
X{
X	fprintf(stderr,"%ld loops\n", iter);
X	exit(0);
X}
X
main(argc, argv)
int	argc;
char	*argv[];
X{
X	int	duration;
X	int result = 0;
X
X	if (argc != 2) {
X		printf("Usage: %s duration\n", argv[0]);
X		exit(1);
X	}
X
X	duration = atoi(argv[1]);
X
X	/* set up alarm call */
X	iter = 0;	/* init iteration count */
X	wake_me(duration, report);
X
X	/* this loop will be interrupted by the alarm call */
X	while (1)
X	{
X        /* in switching to time-based (instead of iteration-based),
X           the following statement was added. It should not skew
X           the timings too much--there was an increment and test
X           in the "while" expression above. The only difference is 
X           that now we're incrementing a long instead of an int.  (ty) */
X	++iter;
X	/* the loop calls a function to insure that something is done 
X	   the results of the function are fed back in (just so they 
X	   they won't be thrown away. A loop with 
X	   unused assignments may get optimized out of existence */
X	result = dumb_stuff(result);
X	}
X}
X
X
X/************************** dumb_stuff *******************/
dumb_stuff(i)
int i;
X{
X#ifndef arithoh
X	datum	x, y, z;
X		z = 0;
X#endif
X		/*
X		 *     101
X		 * sum       i*i/(i*i-1)
X		 *     i=2
X		 */
X		/* notice that the i value is always reset by the loop */
X		for (i=2; i<=101; i++) 
X			{
X#ifndef arithoh
X			x = i;
X			y = x*x;
X			z += y/(y-1);
X			}
return(x+y+z);
X#else
X			}
return(0);
X#endif
X}
X
END_OF_FILE
if test 2655 -ne `wc -c <'src/arith.c'`; then
    echo shar: \"'src/arith.c'\" unpacked with wrong size!
fi
chmod +x 'src/arith.c'
# end of 'src/arith.c'
fi
if test -f 'src/context1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/context1.c'\"
else
echo shar: Extracting \"'src/context1.c'\" \(2637 characters\)
sed "s/^X//" >'src/context1.c' <<'END_OF_FILE'
X
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: context1.c   SID: 3.3 5/15/91 19:30:18
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yager
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: context1.c,v 3.4 87/06/22 14:22:59 kjmcdonell Beta $
X *  August 28, 1990 - changed timing routines--now returns total number of
X *                    iterations in specified time period
X *
X ******************************************************************************/
char SCCSid[] = "@(#) @(#)context1.c:3.3 -- 5/15/91 19:30:18";
X/*
X *  Context switching via synchronized unbuffered pipe i/o
X *
X */
X
X#include <stdio.h>
X#include "timeit.c"
X#include <errno.h>
X
unsigned long iter;
X
report()
X{
X	fprintf(stderr,"%ld loops\n", iter);
X	exit(0);
X}
X
main(argc, argv)
int	argc;
char	*argv[];
X{
X	int duration;
X	int	check;
X	int	p1[2], p2[2];
X
X	if (argc != 2) {
X		printf("Usage: context duration\n");
X		exit(1);
X	}
X
X	duration = atoi(argv[1]);
X	
X	/* set up alarm call */
X	iter = 0;
X	wake_me(duration, report);
X
X	if (pipe(p1) || pipe(p2)) {
X		perror("pipe create failed");
X		exit(1);
X	}
X
X	if (fork()) {	/* parent process */
X		/* master, write p1 & read p2 */
X		close(p1[0]); close(p2[1]);
X		while (1) {
X			if (write(p1[1], (char *)&iter, sizeof(iter)) != sizeof(iter)) {
X				if ((errno != 0) && (errno != EINTR))
X					perror("master write failed");
X				exit(1);
X			}
X			if (read(p2[0], (char *)&check, sizeof(check)) != sizeof(check)) {
X				if ((errno != 0) && (errno != EINTR))
X					perror("master read failed");
X				exit(1);
X			}
X			if (check != iter) {
X				printf("Master sync error: expect %d, got %d\n",
X					iter, check);
X				exit(2);
X			}
X			iter++;
X		}
X	}
X	else { /* child process */
X		unsigned long iter1;
X
X		iter1 = 0;
X		/* slave, read p1 & write p2 */
X		close(p1[1]); close(p2[0]);
X		while (1) {
X			if (read(p1[0], (char *)&check, sizeof(check)) != sizeof(check)) {
X				if ((errno != 0) && (errno != EINTR))
X					perror("slave read failed");
X				exit(1);
X			}
X			if (check != iter1) {
X				printf("Slave sync error: expect %d, got %d\n",
X					iter, check);
X				exit(2);
X			}
X			if (write(p2[1], (char *)&iter1, sizeof(iter1)) != sizeof(check)) {
X				if ((errno != 0) && (errno != EINTR))
X					perror("slave write failed");
X				exit(1);
X			}
X			iter1++;
X		}
X	}
X}
END_OF_FILE
if test 2637 -ne `wc -c <'src/context1.c'`; then
    echo shar: \"'src/context1.c'\" unpacked with wrong size!
fi
chmod +x 'src/context1.c'
# end of 'src/context1.c'
fi
if test -f 'src/execl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/execl.c'\"
else
echo shar: Extracting \"'src/execl.c'\" \(2379 characters\)
sed "s/^X//" >'src/execl.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: execl.c   SID: 3.3 5/15/91 19:30:19
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yager
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: execl.c,v 3.5 87/06/22 15:37:08 kjmcdonell Beta $
X *  August 28, 1990 - Modified timing routines
X *
X ******************************************************************************/
X/*
X *  Execing
X *
X */
char SCCSid[] = "@(#) @(#)execl.c:3.3 -- 5/15/91 19:30:19";
X
X#include <stdio.h>
X#include <sys/types.h>
X
char	bss[8*1024];	/* something worthwhile */
X
X#define main dummy
X			
X#include "big.c"        /* some real code */
X
X#undef main
X
X/* added by BYTE */
char *getenv();
X
X
main(argc, argv)	/* the real program */
int	argc;
char	*argv[];
X{
X        unsigned long iter = 0;
X	char *ptr; 
X	char *fullpath;
X	int 	duration;
X	char	count_str[6], start_str[12], path_str[81], *dur_str;
X	long	start_time, this_time;
X
X#ifdef DEBUG
X	int count;
X	for(count = 0; count < argc; ++ count)
X		printf("%s ",argv[count]);
X		printf("\n");
X#endif
X	if (argc < 2) 
X		{
X		printf("Usage: %s duration\n", argv[0]);
X		exit(1);
X		}
X
X
X	duration = atoi(argv[1]);
X	if (duration > 0) 
X		/* the first invocation */
X		{  
X		dur_str = argv[1];
X		if((ptr = getenv("BINDIR")) != NULL)
X			sprintf(path_str,"%s/execl",ptr);
X		fullpath=path_str;
X		time(&start_time);
X		}
X	else  /* one of those execl'd invocations */
X		{
X		/* real duration follow the phoney null duration */
X		duration = atoi(argv[2]);
X		dur_str = argv[2];
X		iter = (unsigned long)atoi(argv[3]); /* where are we now ? */
X		sscanf(argv[4], "%ld", &start_time);
X		fullpath = argv[0];
X		} 
X
X	sprintf(count_str, "%d", ++iter); /* increment the execl counter */
X	sprintf(start_str, "%ld", start_time);
X	time(&this_time);
X	if (this_time - start_time >= duration) { /* time has run out */
X		fprintf(stderr, "%ld loops\n", iter);
X		exit(0);
X		}
X	execl(fullpath, fullpath, "0", dur_str, count_str, start_str, 0);
X	printf("Exec failed at iteration %d\n", iter);
X	perror("Reason");
X	exit(1);
X}
END_OF_FILE
if test 2379 -ne `wc -c <'src/execl.c'`; then
    echo shar: \"'src/execl.c'\" unpacked with wrong size!
fi
chmod +x 'src/execl.c'
# end of 'src/execl.c'
fi
if test -f 'src/getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/getopt.c'\"
else
echo shar: Extracting \"'src/getopt.c'\" \(3147 characters\)
sed "s/^X//" >'src/getopt.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: getopt.c   SID: 3.3 5/15/91 19:30:18
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yager
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X *	@(#)getopt.c	2.5 (smail) 9/15/87
X * Here's something you've all been waiting for:  the AT&T public domain
X * source for getopt(3).  It is the code which was given out at the 1985
X * UNIFORUM conference in Dallas.  I obtained it by electronic mail
X * directly from AT&T.  The people there assure me that it is indeed
X * in the public domain.
X * 
X * There is no manual page.  That is because the one they gave out at
X * UNIFORUM was slightly different from the current System V Release 2
X * manual page.  The difference apparently involved a note about the
X * famous rules 5 and 6, recommending using white space between an option
X * and its first argument, and not grouping options that have arguments.
X * Getopt itself is currently lenient about both of these things White
X * space is allowed, but not mandatory, and the last option in a group can
X * have an argument.  That particular version of the man page evidently
X * has no official existence, and my source at AT&T did not send a copy.
X * The current SVR2 man page reflects the actual behavor of this getopt.
X * However, I am not about to post a copy of anything licensed by AT&T.
X *********************************************************************/
char SCCSid[] = "@(#) @(#)getopt.c:3.3 -- 5/15/91 19:30:18";
X
X/* This include is needed only to get "index" defined as "strchr" on Sys V. */
X#include "defs.h"
X
X/*LINTLIBRARY*/
X#define NULL	0
X#define EOF	(-1)
X#define ERR(s, c)	if(opterr){\
X	extern int write();\
X	char errbuf[2];\
X	errbuf[0] = c; errbuf[1] = '\n';\
X	(void) write(2, argv[0], (unsigned)strlen(argv[0]));\
X	(void) write(2, s, (unsigned)strlen(s));\
X	(void) write(2, errbuf, 2);}
X
extern char *index();
X
int	opterr = 1;
int	optind = 1;
int	optopt;
char	*optarg;
X
int
getopt(argc, argv, opts)
int	argc;
char	**argv, *opts;
X{
X	static int sp = 1;
X	register int c;
X	register char *cp;
X
X	if(sp == 1)
X		if(optind >= argc ||
X		   argv[optind][0] != '-' || argv[optind][1] == '\0')
X			return(EOF);
X		else if(strcmp(argv[optind], "--") == NULL) {
X			optind++;
X			return(EOF);
X		}
X	optopt = c = argv[optind][sp];
X	if(c == ':' || (cp=index(opts, c)) == NULL) {
X		ERR(": illegal option -- ", c);
X		if(argv[optind][++sp] == '\0') {
X			optind++;
X			sp = 1;
X		}
X		return('?');
X	}
X	if(*++cp == ':') {
X		if(argv[optind][sp+1] != '\0')
X			optarg = &argv[optind++][sp+1];
X		else if(++optind >= argc) {
X			ERR(": option requires an argument -- ", c);
X			sp = 1;
X			return('?');
X		} else
X			optarg = argv[optind++];
X		sp = 1;
X	} else {
X		if(argv[optind][++sp] == '\0') {
X			sp = 1;
X			optind++;
X		}
X		optarg = NULL;
X	}
X	return(c);
X}
END_OF_FILE
if test 3147 -ne `wc -c <'src/getopt.c'`; then
    echo shar: \"'src/getopt.c'\" unpacked with wrong size!
fi
chmod +x 'src/getopt.c'
# end of 'src/getopt.c'
fi
if test -f 'src/hanoi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/hanoi.c'\"
else
echo shar: Extracting \"'src/hanoi.c'\" \(1479 characters\)
sed "s/^X//" >'src/hanoi.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: hanoi.c   SID: 3.3 5/15/91 19:30:20
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yager
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: hanoi.c,v 3.5 87/08/06 08:11:14 kenj Exp $
X *  August 28, 1990 - Modified timing routines (ty)
X *
X ******************************************************************************/
char SCCSid[] = "@(#) @(#)hanoi.c:3.3 -- 5/15/91 19:30:20";
X
X#define other(i,j) (6-(i+j))
X
X#include <stdio.h>
X#include "timeit.c"
X
unsigned long iter = 0;
int num[4];
long cnt;
X
report()
X{
X	fprintf(stderr,"%ld loops\n", iter);
X	exit(0);
X}
X
X
main(argc,argv)
char **argv;
X{
X	int disk=10, /* default number of disks */
X         duration;
X
X	if (argc < 2) {
X		printf("Usage: %s duration [disks]\n", argv[0]);
X		exit(1);
X		}
X	duration = atoi(argv[1]);
X	if(argc > 2) disk = atoi(argv[2]);
X	num[1] = disk;
X
X	wake_me(duration, report);
X
X	while(1) {
X		mov(disk,1,3);
X		iter++;
X		}
X
X	exit(0);
X}
X
mov(n,f,t)
X{
X	int o;
X	if(n == 1) {
X		num[f]--;
X		num[t]++;
X		return;
X	}
X	o = other(f,t);
X	mov(n-1,f,o);
X	mov(1,f,t);
X	mov(n-1,o,t);
X	return;
X}
END_OF_FILE
if test 1479 -ne `wc -c <'src/hanoi.c'`; then
    echo shar: \"'src/hanoi.c'\" unpacked with wrong size!
fi
chmod +x 'src/hanoi.c'
# end of 'src/hanoi.c'
fi
if test -f 'src/limit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/limit.c'\"
else
echo shar: Extracting \"'src/limit.c'\" \(3291 characters\)
sed "s/^X//" >'src/limit.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: limit.c   SID: 3.3 5/15/91 19:30:20
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yager
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: limit.c,v 3.4 87/06/22 14:25:11 kjmcdonell Beta $
X *
X ******************************************************************************/
X/*
X *  Force a UNIX system to the per process and per user limits
X *
X */
char SCCSid[] = "@(#) @(#)limit.c:3.3 -- 5/15/91 19:30:20";
X
X#define	CLICK	1024
X#define	MAXCHN	100
X
X#include <signal.h>
X#include <setjmp.h>
X
int	parent;		/* parent's pid */
int	child;		/* child's pid */
int	pid[MAXCHN];
int	ncall;
int	level;
jmp_buf	env;
X
main(argc, argv)
int	argc;
char	*argv[];
X{
X	char	*top;
X	int	pad;
X	int	end;
X	int	i;
X	int	status;
X	float	f;
X	int	flag();
X	int	wakeup();
X	long	last;
X
X	/* open files (file descriptors) */
X	for (i = 3; open(".", 0) > 0; i++) ;
X	printf("Maximum open files per process: %d\n", i);
X	while (--i > 2)
X		close(i);
X
X	/* process address space */
X	top = (char *)sbrk(0);
X#if debug
X	printf("inital top of program: 0x%x\n", top);
X#endif
X	pad = (((int)top+CLICK-1)/CLICK)*CLICK - (int)top;
X	sbrk(pad);
X	for (i = 0; (char *)sbrk(CLICK) != (char *)-1; i++) ;
X#if debug
X	printf("final top of program: 0x%x\n", sbrk(0));
X#endif
X	brk(top);
X#if debug
X	printf("top of program restored to: 0x%x\n", sbrk(0));
X#endif
X	end = (((int)top+pad)/CLICK) + i;
X	f = ((float)end * CLICK) / 1024;
X	printf("Process address space limit: ");
X	if (f < 1024)
X		printf("%.2f Kbytes\n", f);
X	else {
X		f /= 1024;
X		printf("%.2f Mbytes\n", f);
X	}
X
X	/* process creations */
X	printf("Maximum number of child processes:");
X	i = 0;
X	while (1) {
X#if debug
X		printf("about to fork\n");
X#endif
X		if ((pid[i] = fork()) == -1) {
X#if debug
X			perror("fork failed");
X#endif
X			break;
X		} else if (pid[i] != 0) {
X#if debug
X			printf("child %d: pid=%d\n", i+1, pid[i]);
X#endif
X			i++;
X			if (i >= MAXCHN) {
X				printf(" more than");
X				break;
X			}
X		} else {
X#if debug
X			printf("child %d pausing\n", getpid());
X#endif
X			pause();
X#if debug
X			printf("child %d exiting\n", getpid());
X#endif
X			exit(1);
X		}
X	}
X	printf(" %d\n", i);
X	while (--i >= 0) {
X		kill(pid[i], SIGKILL);
X		wait(0);
X	}
X
X	ncall = level = 0;
X	parent = getpid();
X	signal(SIGTERM, flag);
X	if ((child = fork()) == 0) {
X		signal(SIGALRM, wakeup);
X		recurse();
X		exit(4);
X	}
X	while ((i = wait(&status)) == -1) {
X	}
X	printf("Estimated maximum stack size: %d Kbytes\n", level);
X	exit(0);
X}
X
recurse()
X{
X	int	temp[1024 / sizeof(int)];
X#if debug
X	printf("recursion @ level %d\n", ncall);
X#endif
X	temp[1024 / sizeof(int) - 1] = 1;
X	ncall++;
X	kill(parent, SIGTERM);
X	while (ncall > level) {
X		alarm(2);
X		pause();
X	}
X	if (ncall < 8000)
X		/* less than 8M bytes of temp storage! */
X		recurse();
X	else
X		/* give up! */
X		exit(0);
X}
X
flag()
X{
X	signal(SIGTERM, flag);
X	level++;
X	if (child != 0)
X		kill(child, SIGTERM);
X}
X
wakeup()
X{
X	signal(SIGALRM, wakeup);
X}
END_OF_FILE
if test 3291 -ne `wc -c <'src/limit.c'`; then
    echo shar: \"'src/limit.c'\" unpacked with wrong size!
fi
chmod +x 'src/limit.c'
# end of 'src/limit.c'
fi
if test -f 'src/looper.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/looper.c'\"
else
echo shar: Extracting \"'src/looper.c'\" \(1985 characters\)
sed "s/^X//" >'src/looper.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 1
X *          Module: looper.c   SID: 1.4 5/15/91 19:30:22
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith or Tom Yager at BYTE Magazine
X *	ben@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X *  
X *  February 25, 1991 -- created (Ben S.)
X *
X ******************************************************************************/
char SCCSid[] = "@(#) @(#)looper.c:1.4 -- 5/15/91 19:30:22";
X/*
X *  Shell Process creation
X *
X */
X
X#include <stdio.h>
X#include "timeit.c"
X
unsigned long iter;
char *cmd_argv[28];
int  cmd_argc;
X
report()
X{
X	fprintf(stderr,"%ld loops\n", iter);
X	exit(0);
X}
X
main(argc, argv, env)
int	argc;
char	*argv[];
char    *env[];
X{
int	slave, count, count1, duration;
int	status;
X
if (argc < 2) 
X	{
X	printf("Usage: %s duration command [args..]\n", argv[0]);
X	printf("  duration in seconds\n");
X	exit(1);
X	}
X
if((duration = atoi(argv[1])) < 1)
X	{
X	printf("Usage: %s duration command [arg..]\n", argv[0]);
X	printf("  duration in seconds\n");
X	exit(1);
X	}
X
X/* get command  */
cmd_argc=argc-2;
for( count=2;count < argc; ++count)
X	cmd_argv[count-2]=argv[count];
X#ifdef DEBUG
printf("<<%s>>",cmd_argv[0]);
for(count=1;count < cmd_argc; ++count)
X	printf(" <%s>", cmd_argv[count]);
putchar('\n');
exit(0);
X#endif
X
iter = 0;
wake_me(duration, report);
X
while (1) 
X	{
X	if ((slave = fork()) == 0) 
X		{ /* execute command */
X		execvp(cmd_argv[0],cmd_argv);
X		exit(0);
X		} 
X	else if (slave < 0) 
X		{
X		/* woops ... */
X		printf("Fork failed at iteration %d\n", iter);
X		perror("Reason");
X		exit(2);
X		} 
X	else
X		/* master */
X		wait(&status);
X	if (status != 0) 
X		{
X		printf("Bad wait status: 0x%x\n", status);
X		exit(2);
X		}
X	iter++;
X	}
X}
END_OF_FILE
if test 1985 -ne `wc -c <'src/looper.c'`; then
    echo shar: \"'src/looper.c'\" unpacked with wrong size!
fi
chmod +x 'src/looper.c'
# end of 'src/looper.c'
fi
if test -f 'src/pipe.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/pipe.c'\"
else
echo shar: Extracting \"'src/pipe.c'\" \(1610 characters\)
sed "s/^X//" >'src/pipe.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: pipe.c   SID: 3.3 5/15/91 19:30:20
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yager
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: pipe.c,v 3.5 87/06/22 14:32:36 kjmcdonell Beta $
X *  August 29, 1990 - modified timing routines (ty)
X *
X ******************************************************************************/
char SCCSid[] = "@(#) @(#)pipe.c:3.3 -- 5/15/91 19:30:20";
X/*
X *  pipe  -- test single process pipe throughput (no context switching)
X *
X */
X
X#include <stdio.h>
X#include <errno.h>
X#include "timeit.c"
X
unsigned long iter;
X
report()
X{
X	fprintf(stderr,"%ld loops\n", iter);
X	exit(0);
X}
X
main(argc, argv)
int	argc;
char	*argv[];
X{
X	char	buf[512];
X	int		pvec[2], duration;
X
X	if (argc != 2) {
X		printf("Usage: %s duration\n", argv[0]);
X		exit(1);
X		}
X
X	duration = atoi(argv[1]);
X
X	pipe(pvec);
X
X	wake_me(duration, report);
X	iter = 0;
X
X	while (1) {
X		if (write(pvec[1], buf, sizeof(buf)) != sizeof(buf)) {
X			if ((errno != EINTR) && (errno != 0))
X				printf("write failed, error %d\n", errno);
X			}
X		if (read(pvec[0], buf, sizeof(buf)) != sizeof(buf)) {
X			if ((errno != EINTR) && (errno != 0))
X				printf("read failed, error %d\n", errno);
X			}
X		iter++;
X	}
X}
END_OF_FILE
if test 1610 -ne `wc -c <'src/pipe.c'`; then
    echo shar: \"'src/pipe.c'\" unpacked with wrong size!
fi
chmod +x 'src/pipe.c'
# end of 'src/pipe.c'
fi
if test -f 'src/spawn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/spawn.c'\"
else
echo shar: Extracting \"'src/spawn.c'\" \(1702 characters\)
sed "s/^X//" >'src/spawn.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: spawn.c   SID: 3.3 5/15/91 19:30:20
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yagerat BYTE Magazine
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: spawn.c,v 3.4 87/06/22 14:32:48 kjmcdonell Beta $
X *  August 29, 1990 - Modified timing routines (ty)
X *
X ******************************************************************************/
char SCCSid[] = "@(#) @(#)spawn.c:3.3 -- 5/15/91 19:30:20";
X/*
X *  Process creation
X *
X */
X
X#include <stdio.h>
X#include "timeit.c"
X
unsigned long iter;
X
report()
X{
X	fprintf(stderr,"%ld loops\n", iter);
X	exit(0);
X}
X
main(argc, argv)
int	argc;
char	*argv[];
X{
X	int	slave, count, count1, duration;
X	int	status;
X
X	if (argc != 2) {
X		printf("Usage: %s duration \n", argv[0]);
X		exit(1);
X	}
X
X	duration = atoi(argv[1]);
X
X	iter = 0;
X	wake_me(duration, report);
X
X	while (1) {
X		if ((slave = fork()) == 0) {
X			/* slave .. boring */
X#if debug
X			printf("fork OK\n");
X#endif
X			/* kill it right away */
X			exit(0);
X		} else if (slave < 0) {
X			/* woops ... */
X			printf("Fork failed at iteration %d\n", iter);
X			perror("Reason");
X			exit(2);
X		} else
X			/* master */
X			wait(&status);
X		if (status != 0) {
X			printf("Bad wait status: 0x%x\n", status);
X			exit(2);
X		}
X		iter++;
X#if debug
X		printf("Child %d done.\n", slave);
X#endif
X		}
X}
END_OF_FILE
if test 1702 -ne `wc -c <'src/spawn.c'`; then
    echo shar: \"'src/spawn.c'\" unpacked with wrong size!
fi
chmod +x 'src/spawn.c'
# end of 'src/spawn.c'
fi
if test -f 'src/syscall.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/syscall.c'\"
else
echo shar: Extracting \"'src/syscall.c'\" \(1313 characters\)
sed "s/^X//" >'src/syscall.c' <<'END_OF_FILE'
X/*******************************************************************************
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: syscall.c   SID: 3.3 5/15/91 19:30:21
X *          
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yager at BYTE Magazine
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X *  $Header: syscall.c,v 3.4 87/06/22 14:32:54 kjmcdonell Beta $
X *  August 29, 1990 - Modified timing routines
X *
X ******************************************************************************/
X/*
X *  syscall  -- sit in a loop calling the system
X *
X */
char SCCSid[] = "@(#) @(#)syscall.c:3.3 -- 5/15/91 19:30:21";
X
X#include <stdio.h>
X#include "timeit.c"
X
unsigned long iter;
X
report()
X{
X	fprintf(stderr,"%ld loops\n", iter);
X	exit(0);
X}
X
main(argc, argv)
int	argc;
char	*argv[];
X{
X	int	duration;
X	int	i;
X
X	if (argc != 2) {
X		printf("Usage: %s duration\n", argv[0]);
X		exit(1);
X	}
X
X	duration = atoi(argv[1]);
X
X	iter = 0;
X	wake_me(duration, report);
X
X	while (1) {
X		close(dup(0));
X		getpid();
X		getuid();
X		umask(022);
X		iter++;
X	}
X}
END_OF_FILE
if test 1313 -ne `wc -c <'src/syscall.c'`; then
    echo shar: \"'src/syscall.c'\" unpacked with wrong size!
fi
chmod +x 'src/syscall.c'
# end of 'src/syscall.c'
fi
if test -f 'src/timeit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/timeit.c'\"
else
echo shar: Extracting \"'src/timeit.c'\" \(1145 characters\)
sed "s/^X//" >'src/timeit.c' <<'END_OF_FILE'
X/*******************************************************************************
X *          
X *  The BYTE UNIX Benchmarks - Release 3
X *          Module: timeit.c   SID: 3.3 5/15/91 19:30:21
X *******************************************************************************
X * Bug reports, patches, comments, suggestions should be sent to:
X *
X *	Ben Smith, Rick Grehan or Tom Yager
X *	ben@bytepb.byte.com   rick_g@bytepb.byte.com   tyager@bytepb.byte.com
X *
X *******************************************************************************
X *  Modification Log:
X *  May 12, 1989 - modified empty loops to avoid nullifying by optimizing
X *                 compilers
X *  August 28, 1990 - changed timing relationship--now returns total number
X *	                  of iterations (ty)
X *
X ******************************************************************************/
X
X/* this module is #included in other modules--no separate SCCS ID */
X
X/*
X *  Timing routine
X *
X */
X
X#include <signal.h>
X
wake_me(seconds, func)
int seconds;
void (*func)();
X{
X	/* set up the signal handler */
X	signal(SIGALRM, func);
X	/* get the clock running */
X	alarm(seconds);
X}
X
END_OF_FILE
if test 1145 -ne `wc -c <'src/timeit.c'`; then
    echo shar: \"'src/timeit.c'\" unpacked with wrong size!
fi
chmod +x 'src/timeit.c'
# end of 'src/timeit.c'
fi
if test ! -d 'testdir' ; then
    echo shar: Creating directory \"'testdir'\"
    mkdir 'testdir'
fi
if test -f 'testdir/dc.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'testdir/dc.dat'\"
else
echo shar: Extracting \"'testdir/dc.dat'\" \(142 characters\)
sed "s/^X//" >'testdir/dc.dat' <<'END_OF_FILE'
X99
k
X2
v
p
q
X[ calculate the sqrt(2) to 99 decimal places ... John Lions Test ]
X[ $Header: dc.dat,v 1.1 87/06/22 14:28:28 kjmcdonell Beta $ ]
END_OF_FILE
if test 142 -ne `wc -c <'testdir/dc.dat'`; then
    echo shar: \"'testdir/dc.dat'\" unpacked with wrong size!
fi
chmod +x 'testdir/dc.dat'
# end of 'testdir/dc.dat'
fi
if test ! -d 'tmp' ; then
    echo shar: Creating directory \"'tmp'\"
    mkdir 'tmp'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
