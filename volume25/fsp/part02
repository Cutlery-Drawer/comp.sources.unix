Subject: v25i025: A real-time, multithreaded Internet archive server, Part02/03
Newsgroups: comp.sources.unix
Approved: vixie@pa.dec.com

Submitted-By: wen-king@vlsi.cs.caltech.edu
Posting-Number: Volume 25, Issue 25
Archive-Name: fsp/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 3)."
# Contents:  Makefile bsd_src/glob.c bsd_src/print.c client_util.c
#   common_def.h server_host.c server_lib.c server_main.c udp_io.c
# Wrapped by vixie@cognition.pa.dec.com on Fri Dec 13 17:53:11 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(6894 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#############################################################################
X# You need to do a successful 'make' in the bsd_src directory first before
X# trying to run 'make' in this directory.  The bsd_src directory contains
X# several files derived from those found in the uunet.uu.net archive.
X# Run "make install" to install binaries.
X# Run "make installm" to install man pages.
X# Run "make de-install" to remove installed binaries and man pages.
X
X#############################################################################
X# This is where you want to install the binary
X#
BIN=/usr/local/bin
X
X#############################################################################
X# This is where you want to install the man pages
X#
MAN=/usr/local/man/man1
X
X#############################################################################
X# If you want to provide FSP service, this should be set to the working
X# directory of the FSP server.
X#
DEF_FSP_HOME=/usr/tmp
X
X#############################################################################
X# If you want to provide FSP service, this should be set to the UDP socket
X# port number the FSP server should use.
X#
DEF_FSP_PORT=21
X
X#############################################################################
X# This is where the version number string comes from:
X#
VERSION_STR="Original Caltech version 1.0, Dec 1991"
X
X#############################################################################
X# FSP uses BSD random/srandom functions.  If your system does not have
X# them, include them from the bsd_src directory.
X#
X#RANDOM=bsd_src/random.o
X
X#############################################################################
CFLAGS=-g
X
PROGS=	fspd flscmd fcdcmd fgetcmd frmcmd frmdircmd fprocmd \
X	fmkdir fput fver fcatcmd
X
IPROGS=	${BIN}/fspd ${BIN}/flscmd ${BIN}/fcdcmd \
X	${BIN}/fgetcmd ${BIN}/frmcmd ${BIN}/frmdircmd ${BIN}/fprocmd \
X	${BIN}/fmkdir ${BIN}/fput ${BIN}/fver ${BIN}/fcatcmd
X
IMANS=	${MAN}/fcatcmd.1 ${MAN}/fcat.1 ${MAN}/fcdcmd.1 ${MAN}/fcd.1 \
X	${MAN}/fgetcmd.1 ${MAN}/fget.1 ${MAN}/flscmd.1 ${MAN}/fls.1 \
X	${MAN}/fmkdir.1 ${MAN}/fprocmd.1 ${MAN}/fpro.1 ${MAN}/fput.1 \
X	${MAN}/frmcmd.1 ${MAN}/frm.1 ${MAN}/frmdircmd.1 ${MAN}/frmdir.1 \
X	${MAN}/fspd.1 ${MAN}/fver.1
X
all:
X	@ cd bsd_src; make
X	@ make all1
X
all1:	  ${PROGS}
install:  ${IPROGS}
installm: ${IMANS}
X
SERVER_OBJ= server_main.o server_lib.o server_host.o udp_io.o server_file.o
CLIENT_OBJ= client_lib.o udp_io.o client_util.o
GLOB_OBJ= bsd_src/glob.o
UTIL_LS_OBJ= bsd_src/cmp.o bsd_src/ls.o bsd_src/print.o bsd_src/util.o \
X		${GLOB_OBJ}
X
X#############################################################################
X
fspd: ${SERVER_OBJ} ${RANDOM}
X	cc ${CFLAGS} -o fspd ${SERVER_OBJ} ${RANDOM} ${LIB}
X
fgetcmd: fgetcmd.o ${CLIENT_OBJ} ${GLOB_OBJ}
X	cc ${CFLAGS} -o fgetcmd fgetcmd.o ${CLIENT_OBJ} ${GLOB_OBJ} ${LIB}
X
fcatcmd: fcatcmd.o ${CLIENT_OBJ} ${GLOB_OBJ}
X	cc ${CFLAGS} -o fcatcmd fcatcmd.o ${CLIENT_OBJ} ${GLOB_OBJ} ${LIB}
X
fput: fput.o ${CLIENT_OBJ}
X	cc ${CFLAGS} -o fput fput.o ${CLIENT_OBJ} ${LIB}
X
frmcmd: frmcmd.o ${CLIENT_OBJ} ${GLOB_OBJ}
X	cc ${CFLAGS} -o frmcmd frmcmd.o ${CLIENT_OBJ} ${GLOB_OBJ} ${LIB}
X
flscmd: flscmd.o ${CLIENT_OBJ} ${UTIL_LS_OBJ}
X	cc ${CFLAGS} -o flscmd flscmd.o ${CLIENT_OBJ} ${UTIL_LS_OBJ} ${LIB}
X
fcdcmd: fcdcmd.o ${CLIENT_OBJ} ${GLOB_OBJ}
X	cc ${CFLAGS} -o fcdcmd fcdcmd.o ${CLIENT_OBJ} ${GLOB_OBJ} ${LIB}
X
frmdircmd: frmdircmd.o ${CLIENT_OBJ} ${GLOB_OBJ}
X	cc ${CFLAGS} -o frmdircmd frmdircmd.o ${CLIENT_OBJ} ${GLOB_OBJ} ${LIB}
X
fprocmd: fprocmd.o ${CLIENT_OBJ} ${GLOB_OBJ}
X	cc ${CFLAGS} -o fprocmd fprocmd.o ${CLIENT_OBJ} ${GLOB_OBJ} ${LIB}
X
fmkdir: fmkdir.o ${CLIENT_OBJ}
X	cc ${CFLAGS} -o fmkdir fmkdir.o ${CLIENT_OBJ} ${LIB}
X
fver: fver.o ${CLIENT_OBJ}
X	cc ${CFLAGS} -o fver fver.o ${CLIENT_OBJ} ${LIB}
X
X#############################################################################
X
X${BIN}/fspd     : fspd      ; cp fspd      ${BIN}/fspd
X${BIN}/fgetcmd  : fgetcmd   ; cp fgetcmd   ${BIN}/fgetcmd
X${BIN}/fcatcmd  : fcatcmd   ; cp fcatcmd   ${BIN}/fcatcmd
X${BIN}/fput     : fput      ; cp fput      ${BIN}/fput
X${BIN}/frmcmd   : frmcmd    ; cp frmcmd    ${BIN}/frmcmd
X${BIN}/flscmd   : flscmd    ; cp flscmd    ${BIN}/flscmd
X${BIN}/fcdcmd   : fcdcmd    ; cp fcdcmd    ${BIN}/fcdcmd
X${BIN}/frmdircmd: frmdircmd ; cp frmdircmd ${BIN}/frmdircmd
X${BIN}/fprocmd  : fprocmd   ; cp fprocmd   ${BIN}/fprocmd
X${BIN}/fmkdir   : fmkdir    ; cp fmkdir    ${BIN}/fmkdir
X${BIN}/fver     : fver      ; cp fver      ${BIN}/fver
X
X#############################################################################
X
X${MAN}/fcat.1     : fcatcmd.1  ; cp fcatcmd.1   ${MAN}/fcat.1
X${MAN}/fcatcmd.1  : fcatcmd.1  ; cp fcatcmd.1   ${MAN}/fcatcmd.1
X${MAN}/fcd.1      : fcdcmd.1   ; cp fcdcmd.1    ${MAN}/fcd.1
X${MAN}/fcdcmd.1   : fcdcmd.1   ; cp fcdcmd.1    ${MAN}/fcdcmd.1
X${MAN}/fget.1     : fgetcmd.1  ; cp fgetcmd.1   ${MAN}/fget.1
X${MAN}/fgetcmd.1  : fgetcmd.1  ; cp fgetcmd.1   ${MAN}/fgetcmd.1
X${MAN}/fls.1      : flscmd.1   ; cp flscmd.1    ${MAN}/fls.1
X${MAN}/flscmd.1   : flscmd.1   ; cp flscmd.1    ${MAN}/flscmd.1
X${MAN}/fmkdir.1   : fmkdir.1   ; cp fmkdir.1    ${MAN}/fmkdir.1
X${MAN}/fpro.1     : fprocmd.1  ; cp fprocmd.1   ${MAN}/fpro.1
X${MAN}/fprocmd.1  : fprocmd.1  ; cp fprocmd.1   ${MAN}/fprocmd.1
X${MAN}/fput.1     : fput.1     ; cp fput.1      ${MAN}/fput.1
X${MAN}/frm.1      : frmcmd.1   ; cp frmcmd.1    ${MAN}/frm.1
X${MAN}/frmcmd.1   : frmcmd.1   ; cp frmcmd.1    ${MAN}/frmcmd.1
X${MAN}/frmdir.1   : frmdircmd.1; cp frmdircmd.1 ${MAN}/frmdir.1
X${MAN}/frmdircmd.1: frmdircmd.1; cp frmdircmd.1 ${MAN}/frmdircmd.1
X${MAN}/fspd.1     : fspd.1     ; cp fspd.1      ${MAN}/fspd.1
X${MAN}/fver.1     : fver.1     ; cp fver.1      ${MAN}/fver.1
X
X#############################################################################
X
server_main.o: server_main.c server_def.h common_def.h Makefile
X	cc ${CFLAGS} -DDEF_FSP_PORT=${DEF_FSP_PORT}	\
X		     -DDEF_FSP_HOME=\"${DEF_FSP_HOME}\"	\
X		     -DVERSION_STR=\"${VERSION_STR}\"	\
X		     -c server_main.c
X
client_lib.o: client_lib.c client_def.h common_def.h
client_util.o: client_util.c client_def.h common_def.h
fcatcmd.o: fcatcmd.c client_def.h common_def.h
fcdcmd.o: fcdcmd.c client_def.h common_def.h
fgetcmd.o: fgetcmd.c client_def.h common_def.h
flscmd.o: flscmd.c client_def.h common_def.h
fmkdir.o: fmkdir.c client_def.h common_def.h
fprocmd.o: fprocmd.c client_def.h common_def.h
fput.o: fput.c client_def.h common_def.h
frmcmd.o: frmcmd.c client_def.h common_def.h
fver.o: fver.c client_def.h common_def.h
frmdircmd.o: frmdircmd.c client_def.h common_def.h
server_host.o: server_host.c server_def.h common_def.h
server_file.o: server_file.c server_def.h common_def.h
server_lib.o: server_lib.c server_def.h common_def.h
server_main.o: server_main.c server_def.h common_def.h
udp_io.o: udp_io.c common_def.h
X
clean:
X	rm -f *.o ${PROGS}
X	@ cd bsd_src; make clean
X
de-install:
X	rm -f ${IPROGS} ${IMANS}
END_OF_FILE
if test 6894 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'bsd_src/glob.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bsd_src/glob.c'\"
else
echo shar: Extracting \"'bsd_src/glob.c'\" \(10080 characters\)
sed "s/^X//" >'bsd_src/glob.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1980 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
static char sccsid[] = "@(#)glob.c	5.4 (Berkeley) 6/29/88";
X#endif /* not lint */
X
X/*
X * C-shell glob for random programs.
X */
X
X#include "../client_def.h"
X#include "tweak.h"
X
X#define	QUOTE 0200
X#define	TRIM 0177
X#define	eq(a,b)		(strcmp(a, b)==0)
X#define	GAVSIZ		(NCARGS/6)
X#define	isdir(d)	((d.st_mode & S_IFMT) == S_IFDIR)
X
static	char **gargv;		/* Pointer to the (stack) arglist */
static	int gargc;		/* Number args in gargv */
static	int gnleft;
static	int gflag;
static	int tglob();
char	**glob();
char	*globerr;
char	*home;
struct	passwd *getpwnam();
extern	int errno;
static	char *strspl(), *strend();
char	*malloc(), *strcpy(), *strcat();
char	**copyblk();
X
static	int globcnt;
X
char	*globchars = "`{[*?";
X
static	char *gpath, *gpathp, *lastgpathp;
static	int globbed;
static	char *entp;
static	char **sortbas;
X
char **
glob(v)
X	register char *v;
X{
X	char agpath[BUFSIZ];
X	char *agargv[GAVSIZ];
X	char *vv[2];
X	vv[0] = v;
X	vv[1] = 0;
X	gflag = 0;
X	rscan(vv, tglob);
X	if (gflag == 0)
X		return (copyblk(vv));
X
X	globerr = 0;
X	gpath = agpath; gpathp = gpath; *gpathp = 0;
X	lastgpathp = &gpath[sizeof agpath - 2];
X	ginit(agargv); globcnt = 0;
X	collect(v);
X	if (globcnt == 0 && (gflag&1)) {
X		blkfree(gargv), gargv = 0;
X		return (0);
X	} else
X		return (gargv = copyblk(gargv));
X}
X
static
ginit(agargv)
X	char **agargv;
X{
X
X	agargv[0] = 0; gargv = agargv; sortbas = agargv; gargc = 0;
X	gnleft = NCARGS - 4;
X}
X
static
collect(as)
X	register char *as;
X{
X	if (eq(as, "{") || eq(as, "{}")) {
X		Gcat(as, "");
X		sort();
X	} else
X		acollect(as);
X}
X
static
acollect(as)
X	register char *as;
X{
X	register int ogargc = gargc;
X
X	gpathp = gpath; *gpathp = 0; globbed = 0;
X	expand(as);
X	if (gargc != ogargc)
X		sort();
X}
X
static
sort()
X{
X	register char **p1, **p2, *c;
X	char **Gvp = &gargv[gargc];
X
X	p1 = sortbas;
X	while (p1 < Gvp-1) {
X		p2 = p1;
X		while (++p2 < Gvp)
X			if (strcmp(*p1, *p2) > 0)
X				c = *p1, *p1 = *p2, *p2 = c;
X		p1++;
X	}
X	sortbas = Gvp;
X}
X
static
expand(as)
X	char *as;
X{
X	register char *cs;
X	register char *sgpathp, *oldcs;
X	struct stat stb;
X
X	sgpathp = gpathp;
X	cs = as;
X	if (*cs == '~' && gpathp == gpath) {
X		addpath('~');
X		for (cs++; letter(*cs) || digit(*cs) || *cs == '-';)
X			addpath(*cs++);
X		if (!*cs || *cs == '/') {
X			if (gpathp != gpath + 1) {
X				*gpathp = 0;
X				if (gethdir(gpath + 1))
X					globerr = "Unknown user name after ~";
X				(void) strcpy(gpath, gpath + 1);
X			} else
X				(void) strcpy(gpath, home);
X			gpathp = strend(gpath);
X		}
X	}
X	while (!any(*cs, globchars)) {
X		if (*cs == 0) {
X			if (!globbed)
X				Gcat(gpath, "");
X			else if (util_stat(gpath, &stb) >= 0) {
X				Gcat(gpath, "");
X				globcnt++;
X			}
X			goto endit;
X		}
X		addpath(*cs++);
X	}
X	oldcs = cs;
X	while (cs > as && *cs != '/')
X		cs--, gpathp--;
X	if (*cs == '/')
X		cs++, gpathp++;
X	*gpathp = 0;
X	if (*oldcs == '{') {
X		(void) execbrc(cs, ((char *)0));
X		return;
X	}
X	matchdir(cs);
endit:
X	gpathp = sgpathp;
X	*gpathp = 0;
X}
X
static
matchdir(pattern)
X	char *pattern;
X{
X	struct stat stb;
X	register struct rdirent *dp;
X	RDIR *dirp;
X
X	dirp = util_opendir(gpath);
X	if (dirp == NULL) {
X		if (globbed)
X			return;
X		goto patherr2;
X	}
X	if (util_stat(gpath, &stb) < 0)
X		goto patherr1;
X	if (!isdir(stb)) {
X		errno = ENOTDIR;
X		goto patherr1;
X	}
X	while ((dp = util_readdir(dirp)) != NULL) {
X		if (dp->d_ino == 0)
X			continue;
X		if (match(dp->d_name, pattern)) {
X			Gcat(gpath, dp->d_name);
X			globcnt++;
X		}
X	}
X	util_closedir(dirp);
X	return;
X
patherr1:
X	util_closedir(dirp);
patherr2:
X	globerr = "Bad directory components";
X}
X
static
execbrc(p, s)
X	char *p, *s;
X{
X	char restbuf[BUFSIZ + 2];
X	register char *pe, *pm, *pl;
X	int brclev = 0;
X	char *lm, savec, *sgpathp;
X
X	for (lm = restbuf; *p != '{'; *lm++ = *p++)
X		continue;
X	for (pe = ++p; *pe; pe++)
X	switch (*pe) {
X
X	case '{':
X		brclev++;
X		continue;
X
X	case '}':
X		if (brclev == 0)
X			goto pend;
X		brclev--;
X		continue;
X
X	case '[':
X		for (pe++; *pe && *pe != ']'; pe++)
X			continue;
X		continue;
X	}
pend:
X	brclev = 0;
X	for (pl = pm = p; pm <= pe; pm++)
X	switch (*pm & (QUOTE|TRIM)) {
X
X	case '{':
X		brclev++;
X		continue;
X
X	case '}':
X		if (brclev) {
X			brclev--;
X			continue;
X		}
X		goto doit;
X
X	case ','|QUOTE:
X	case ',':
X		if (brclev)
X			continue;
doit:
X		savec = *pm;
X		*pm = 0;
X		(void) strcpy(lm, pl);
X		(void) strcat(restbuf, pe + 1);
X		*pm = savec;
X		if (s == 0) {
X			sgpathp = gpathp;
X			expand(restbuf);
X			gpathp = sgpathp;
X			*gpathp = 0;
X		} else if (amatch(s, restbuf))
X			return (1);
X		sort();
X		pl = pm + 1;
X		if (brclev)
X			return (0);
X		continue;
X
X	case '[':
X		for (pm++; *pm && *pm != ']'; pm++)
X			continue;
X		if (!*pm)
X			pm--;
X		continue;
X	}
X	if (brclev)
X		goto doit;
X	return (0);
X}
X
static
match(s, p)
X	char *s, *p;
X{
X	register int c;
X	register char *sentp;
X	char sglobbed = globbed;
X
X	if (*s == '.' && *p != '.')
X		return (0);
X	sentp = entp;
X	entp = s;
X	c = amatch(s, p);
X	entp = sentp;
X	globbed = sglobbed;
X	return (c);
X}
X
static
amatch(s, p)
X	register char *s, *p;
X{
X	register int scc;
X	int ok, lc;
X	char *sgpathp;
X	struct stat stb;
X	int c, cc;
X
X	globbed = 1;
X	for (;;) {
X		scc = *s++ & TRIM;
X		switch (c = *p++) {
X
X		case '{':
X			return (execbrc(p - 1, s - 1));
X
X		case '[':
X			ok = 0;
X			lc = 077777;
X			while (cc = *p++) {
X				if (cc == ']') {
X					if (ok)
X						break;
X					return (0);
X				}
X				if (cc == '-') {
X					if (lc <= scc && scc <= *p++)
X						ok++;
X				} else
X					if (scc == (lc = cc))
X						ok++;
X			}
X			if (cc == 0)
X				if (ok)
X					p--;
X				else
X					return 0;
X			continue;
X
X		case '*':
X			if (!*p)
X				return (1);
X			if (*p == '/') {
X				p++;
X				goto slash;
X			}
X			s--;
X			do {
X				if (amatch(s, p))
X					return (1);
X			} while (*s++);
X			return (0);
X
X		case 0:
X			return (scc == 0);
X
X		default:
X			if (c != scc)
X				return (0);
X			continue;
X
X		case '?':
X			if (scc == 0)
X				return (0);
X			continue;
X
X		case '/':
X			if (scc)
X				return (0);
slash:
X			s = entp;
X			sgpathp = gpathp;
X			while (*s)
X				addpath(*s++);
X			addpath('/');
X			if (util_stat(gpath, &stb) == 0 && isdir(stb))
X				if (*p == 0) {
X					Gcat(gpath, "");
X					globcnt++;
X				} else
X					expand(p);
X			gpathp = sgpathp;
X			*gpathp = 0;
X			return (0);
X		}
X	}
X}
X
static
Gmatch(s, p)
X	register char *s, *p;
X{
X	register int scc;
X	int ok, lc;
X	int c, cc;
X
X	for (;;) {
X		scc = *s++ & TRIM;
X		switch (c = *p++) {
X
X		case '[':
X			ok = 0;
X			lc = 077777;
X			while (cc = *p++) {
X				if (cc == ']') {
X					if (ok)
X						break;
X					return (0);
X				}
X				if (cc == '-') {
X					if (lc <= scc && scc <= *p++)
X						ok++;
X				} else
X					if (scc == (lc = cc))
X						ok++;
X			}
X			if (cc == 0)
X				if (ok)
X					p--;
X				else
X					return 0;
X			continue;
X
X		case '*':
X			if (!*p)
X				return (1);
X			for (s--; *s; s++)
X				if (Gmatch(s, p))
X					return (1);
X			return (0);
X
X		case 0:
X			return (scc == 0);
X
X		default:
X			if ((c & TRIM) != scc)
X				return (0);
X			continue;
X
X		case '?':
X			if (scc == 0)
X				return (0);
X			continue;
X
X		}
X	}
X}
X
static
Gcat(s1, s2)
X	register char *s1, *s2;
X{
X	register int len = strlen(s1) + strlen(s2) + 1;
X
X	if (len >= gnleft || gargc >= GAVSIZ - 1)
X		globerr = "Arguments too long";
X	else {
X		gargc++;
X		gnleft -= len;
X		gargv[gargc] = 0;
X		gargv[gargc - 1] = strspl(s1, s2);
X	}
X}
X
static
addpath(c)
X	char c;
X{
X
X	if (gpathp >= lastgpathp)
X		globerr = "Pathname too long";
X	else {
X		*gpathp++ = c;
X		*gpathp = 0;
X	}
X}
X
static
rscan(t, f)
X	register char **t;
X	int (*f)();
X{
X	register char *p, c;
X
X	while (p = *t++) {
X		if (f == tglob)
X			if (*p == '~')
X				gflag |= 2;
X			else if (eq(p, "{") || eq(p, "{}"))
X				continue;
X		while (c = *p++)
X			(*f)(c);
X	}
X}
X/*
static
scan(t, f)
X	register char **t;
X	int (*f)();
X{
X	register char *p, c;
X
X	while (p = *t++)
X		while (c = *p)
X			*p++ = (*f)(c);
X} */
X
static
tglob(c)
X	register char c;
X{
X
X	if (any(c, globchars))
X		gflag |= c == '{' ? 2 : 1;
X	return (c);
X}
X/*
static
trim(c)
X	char c;
X{
X
X	return (c & TRIM);
X} */
X
X
letter(c)
X	register char c;
X{
X
X	return (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_');
X}
X
digit(c)
X	register char c;
X{
X
X	return (c >= '0' && c <= '9');
X}
X
any(c, s)
X	register int c;
X	register char *s;
X{
X
X	while (*s)
X		if (*s++ == c)
X			return(1);
X	return(0);
X}
blklen(av)
X	register char **av;
X{
X	register int i = 0;
X
X	while (*av++)
X		i++;
X	return (i);
X}
X
char **
blkcpy(oav, bv)
X	char **oav;
X	register char **bv;
X{
X	register char **av = oav;
X
X	while (*av++ = *bv++)
X		continue;
X	return (oav);
X}
X
blkfree(av0)
X	char **av0;
X{
X	register char **av = av0;
X
X	while (*av)
X		free(*av++);
X	free((char *)av0);
X}
X
static
char *
strspl(cp, dp)
X	register char *cp, *dp;
X{
X	register char *ep = malloc((unsigned)(strlen(cp) + strlen(dp) + 1));
X
X	if (ep == (char *)0)
X		{ perror("Out of memory 1"); exit(1); }
X	(void) strcpy(ep, cp);
X	(void) strcat(ep, dp);
X	return (ep);
X}
X
char **
copyblk(v)
X	register char **v;
X{
X	register char **nv = (char **)malloc((unsigned)((blklen(v) + 1) *
X						sizeof(char **)));
X	if (nv == (char **)0)
X		{ perror("Out of memory 2"); exit(2); }
X
X	return (blkcpy(nv, v));
X}
X
static
char *
strend(cp)
X	register char *cp;
X{
X
X	while (*cp)
X		cp++;
X	return (cp);
X}
X/*
X * Extract a home directory from the password file
X * The argument points to a buffer where the name of the
X * user whose home directory is sought is currently.
X * We write the home directory of the user back there.
X */
gethdir(home)
X	char *home;
X{
X}
END_OF_FILE
if test 10080 -ne `wc -c <'bsd_src/glob.c'`; then
    echo shar: \"'bsd_src/glob.c'\" unpacked with wrong size!
fi
# end of 'bsd_src/glob.c'
fi
if test -f 'bsd_src/print.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bsd_src/print.c'\"
else
echo shar: Extracting \"'bsd_src/print.c'\" \(4381 characters\)
sed "s/^X//" >'bsd_src/print.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989 The Regents of the University of California.
X * All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Michael Fischbein.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that: (1) source distributions retain this entire copyright
X * notice and comment, and (2) distributions including binaries display
X * the following acknowledgement:  ``This product includes software
X * developed by the University of California, Berkeley and its contributors''
X * in the documentation or other materials provided with the distribution
X * and in all advertising materials mentioning features or use of this
X * software. Neither the name of the University nor the names of its
X * contributors may be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
static char sccsid[] = "@(#)print.c	5.22 (Berkeley) 5/10/90";
X#endif /* not lint */
X
X#include <sys/types.h>
X#include <sys/param.h>
X#include <sys/stat.h>
X#include <stdio.h>
X#include <grp.h>
X#include <pwd.h>
X#include <utmp.h>
X#include "ls.h"
X#include "tweak.h"
X
X#define BLK(A) (((A)+1023)/1024)
X
printscol(stats, num)
X	register LS *stats;
X	register int num;
X{
X	for (; num--; ++stats) {
X		(void)printaname(stats);
X		(void)putchar('\n');
X	}
X}
X
printlong(stats, num)
X	LS *stats;
X	register int num;
X{
X	extern int errno;
X	char *modep;
X
X	if (f_total)
X		(void)printf("total %lu\n", stats[0].lstat.st_btotal);
X	for (; num--; ++stats) {
X		if (f_inode) (void)printf("%6lu ", stats->lstat.st_ino);
X		if (f_size ) (void)printf("%4ld ", BLK(stats->lstat.st_size));
X		modep = ((S_IFDIR & stats->lstat.st_mode)) ? "drwxrwxrwx"
X							: "-rw-rw-rw-" ;
X
X		(void)printf("%s %3u %-*s ",
X			modep, stats->lstat.st_nlink, 8, "nobody");
X		if (f_group)
X			(void)printf("%-*s ", 8, "nobody");
X		else
X			(void)printf("%8ld ", stats->lstat.st_size);
X		if (f_accesstime)
X			printtime(stats->lstat.st_atime);
X		else if (f_statustime)
X			printtime(stats->lstat.st_ctime);
X		else
X			printtime(stats->lstat.st_mtime);
X		(void)printf("%s", stats->name);
X		if (f_type)
X			(void)printtype(stats->lstat.st_mode);
X		(void)putchar('\n');
X	}
X}
X
X#define	TAB	8
X
printcol(stats, num)
X	LS *stats;
X	int num;
X{
X	extern int termwidth;
X	register int base, chcnt, cnt, col, colwidth;
X	int endcol, numcols, numrows, row;
X
X	colwidth = stats[0].lstat.st_maxlen;
X	if (f_inode)
X		colwidth += 6;
X	if (f_size)
X		colwidth += 5;
X	if (f_type)
X		colwidth += 1;
X
X	colwidth = (colwidth + TAB) & ~(TAB - 1);
X	if (termwidth < 2 * colwidth) {
X		printscol(stats, num);
X		return;
X	}
X
X	numcols = termwidth / colwidth;
X	numrows = num / numcols;
X	if (num % numcols)
X		++numrows;
X
X	if (f_size && f_total)
X		(void)printf("total %lu\n", stats[0].lstat.st_btotal);
X	for (row = 0; row < numrows; ++row) {
X		endcol = colwidth;
X		for (base = row, chcnt = col = 0; col < numcols; ++col) {
X			chcnt += printaname(stats + base);
X			if ((base += numrows) >= num)
X				break;
X			while ((cnt = (chcnt + TAB & ~(TAB - 1))) <= endcol) {
X				(void)putchar('\t');
X				chcnt = cnt;
X			}
X			endcol += colwidth;
X		}
X		putchar('\n');
X	}
X}
X
X/*
X * print [inode] [size] name
X * return # of characters printed, no trailing characters
X */
printaname(lp)
X	LS *lp;
X{
X	int chcnt;
X
X	chcnt = 0;
X
X	if (f_inode)
X	{
X	    printf("%5lu ", lp->lstat.st_ino);
X	    chcnt += 6;
X	}
X
X	if (f_size)
X	{
X	    printf("%4ld ", BLK(lp->lstat.st_size));
X	    chcnt += 5;
X	}
X
X	printf("%s", lp->name); chcnt += strlen(lp->name);
X
X	if (f_type)
X	{
X	    chcnt += printtype(lp->lstat.st_mode);
X	}
X
X	return(chcnt);
X}
X
printtime(ftime)
X	time_t ftime;
X{
X	int i;
X	char *longstring, *ctime();
X	time_t time();
X
X	longstring = ctime((long *)&ftime);
X	for (i = 4; i < 11; ++i)
X		(void)putchar(longstring[i]);
X
X#define	SIXMONTHS	((365 / 2) * 24 * 60 * 60)
X	if (ftime + SIXMONTHS > time((time_t *)NULL))
X		for (i = 11; i < 16; ++i)
X			(void)putchar(longstring[i]);
X	else {
X		(void)putchar(' ');
X		for (i = 20; i < 24; ++i)
X			(void)putchar(longstring[i]);
X	}
X	(void)putchar(' ');
X}
X
printtype(mode)
X	mode_t mode;
X{
X	switch(mode & S_IFMT) {
X	case S_IFDIR:
X		(void)putchar('/');
X		return(1);
X	}
X	return(0);
X}
END_OF_FILE
if test 4381 -ne `wc -c <'bsd_src/print.c'`; then
    echo shar: \"'bsd_src/print.c'\" unpacked with wrong size!
fi
# end of 'bsd_src/print.c'
fi
if test -f 'client_util.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'client_util.c'\"
else
echo shar: Extracting \"'client_util.c'\" \(9556 characters\)
sed "s/^X//" >'client_util.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "client_def.h"
X
extern char *realloc(), *malloc(), *getenv();
extern int errno;
X
static int env_dir_malloced = 0;
char *env_dir = "/";
char *env_myport;
char *env_host;
char *env_port;
X
char *util_abs_path(s2)
X    char *s2;
X{
X    char *path, *s, *d, *t;
X
X    if(!env_dir) env_dir = "";
X    if(!s2) s2 = "";
X
X    if(*s2 == '/')
X    {
X	path = malloc(strlen(s2)+2);
X	sprintf(path,"/%s",s2);
X    } else
X    {
X	path = malloc(strlen(env_dir)+strlen(s2)+3);
X	sprintf(path,"/%s/%s",env_dir,s2);
X    }
X
X    for(t = path; *t; )
X    {
X	if(t[0] == '/')
X	{
X	    while(t[1] == '/') for(d = t, s = t+1; *d++ = *s++; );
X	    if(t != path && t[1] == 0) { t[0] = 0; return(path); }
X	}
X	if(t[0] == '.' && t[1] == '.')
X	{
X	    if(t-1 == path && t[2] ==  0 ) { *t = 0; return(path); }
X	    if(t-1 == path && t[2] == '/')
X	    {
X		for(d = t, s = t + 3; *d++ = *s++; );
X		continue;
X	    }
X	    if(t[-1] == '/' && (t[2] == '/' || t[2] ==  0))
X	    {
X		s = t + 2;	/* point to either slash or nul */
X		t -= 2;		/* guaranteed that t >= path here */
X		while(t > path && t[0] != '/') t--;
X		if(t != path || *s == '/') { for(d = t; *d++ = *s++; ); }
X				      else { t[1] = 0; return(path);    }
X		continue;
X	    }
X	}
X	if(t[0] == '.')
X	{
X	    if(t-1 == path && t[1] ==  0 ) { *t = 0; return(path); }
X	    if(t-1 == path && t[1] == '/')
X	    {
X		for(d = t, s = t + 2; *d++ = *s++; );
X		continue;
X	    }
X	    if(t[-1] == '/' && (t[1] == '/' || t[1] ==  0))
X	    {
X		s = t + 1;	/* point to either slash or nul */
X		for(d = t-1; *d++ = *s++; ); 
X		t--;
X		continue;
X	    }
X	}
X	t++;
X    }
X    return(path);
X}
X
char *util_getwd(p)
X    char *p;
X{
X    if(p) strcpy(p,env_dir);
X    return(p);
X}
X
RDIRENT **get_dir_blk(path)
X    char *path;
X{
X    RDIRENT **dp;
X    char *p1, *p2;
X    unsigned long pos;
X    int cnt, k, rem;
X    UBUF *ub;
X    char *fpath;
X
X    fpath = util_abs_path(path);
X
X    for(pos = 0, cnt = 0; ; )
X    {
X	ub = client_interact(CC_GET_DIR,pos, strlen(fpath),fpath+1, 0,NULLP);
X
X	if(ub->cmd == CC_ERR)
X	{
X	    fprintf(stderr,"directory reading error: %s\n",ub->buf);
X	    free(fpath); return((RDIRENT **) 0);
X	}
X
X	for(p2 = ub->buf, rem = ub->len, k = 0; ; k++)
X	{
X	    if(rem < RDHSIZE) break;
X	    if(((RDIRENT *) p2)->type == RDTYPE_SKIP) break;
X	    if(((RDIRENT *) p2)->type == RDTYPE_END ) { k++; break; }
X	    p2 += RDHSIZE; rem -= (RDHSIZE+1);
X	    while(*p2++             ) {       rem--; }
X	    while((p2 - ub->buf) & 3) { p2++; rem--; }
X	}
X
X	p1 = malloc(p2-ub->buf);
X	if(cnt) dp = (RDIRENT **) realloc(dp,(cnt+k+1)*sizeof(RDIRENT *));
X	   else dp = (RDIRENT **)  malloc(   (cnt+k+1)*sizeof(RDIRENT *));
X
X	if(!p1 || !dp) { free(fpath);
X			  fputs("directory reading out of memory\n",stderr);
X			  return((RDIRENT **) 0); }
X
X	for(p2 = ub->buf, rem = ub->len; ; cnt++)
X	{
X	    if(rem < RDHSIZE) break;
X	    if(((RDIRENT *) p2)->type == RDTYPE_SKIP) break;
X	    if(((RDIRENT *) p2)->type == RDTYPE_END )
X						{ dp[cnt] = 0; return(dp); }
X	    dp[cnt] = (RDIRENT *) p1;
X	    ((RDIRENT *) p1)->time = ntohl(((RDIRENT *) p2)->time);
X	    ((RDIRENT *) p1)->size = ntohl(((RDIRENT *) p2)->size);
X	    ((RDIRENT *) p1)->type =       ((RDIRENT *) p2)->type ;
X
X	    p2 += RDHSIZE; p1 += RDHSIZE; rem -= (RDHSIZE+1);
X	    while(*p1++ = *p2++     ) {		    rem--; }
X	    while((p2 - ub->buf) & 3) { p2++; p1++; rem--; }
X	}
X
X	if(ub->len != UBUF_SPACE) { dp[cnt] = 0; return(dp); }
X	pos += ub->len;
X    }
X}
X
util_download(path,fp)
X    char *path;
X    FILE *fp;
X{   
X    unsigned long pos;
X    unsigned tmax, tcnt, wrote;
X    UBUF *ub;
X    char *fpath;
X 
X    fpath = util_abs_path(path);
X 
X    for(tmax = 1, tcnt = 0, pos = 0; ; )
X    {   
X        ub = client_interact(CC_GET_FILE,pos, strlen(fpath),fpath+1, 0,NULLP);
X
X	if(client_trace && (++tcnt >= tmax))
X	{
X	    if(tmax < 16) tmax <<= 1; else tcnt = 0;
X	    fprintf(stderr,"\r%luk  ",pos>>10);
X	    fflush(stderr);
X	}
X
X        if(ub->cmd == CC_ERR)
X        {    
X            fprintf(stderr,"downloading %s: %s\n",path,ub->buf);
X	    free(fpath); return(-1); 
X        }   
X 
X        wrote = fwrite(ub->buf,1,ub->len,fp);
X        pos  += wrote;
X 
X        if(ub->len < UBUF_SPACE || ub->len != wrote) break;
X    }
X
X    if(client_trace) { fprintf(stderr,"\r%luk : %s \n",pos>>10,path);
X		       fflush(stderr); }
X
X    free(fpath); return(0);
X}
X
util_upload(path,fp)
X    char *path;
X    FILE *fp;
X{   
X    unsigned long pos;
X    unsigned bytes, first, tmax, tcnt;
X    char *fpath, buf[UBUF_SPACE];
X    UBUF *ub;
X 
X    fpath = util_abs_path(path);
X 
X    for(tmax = 1, tcnt = 0, pos = 0, first = 1; ; first = 0)
X    {   
X	if((bytes = fread(buf,1,sizeof(buf),fp)) || first)
X	{
X	    ub = client_interact(CC_UP_LOAD,pos, bytes,buf, 0,NULLP);
X	    if(client_trace && (++tcnt >= tmax))
X	    {
X		if(tmax < 16) tmax <<= 1; else tcnt = 0;
X		fprintf(stderr,"\r%luk ",pos>>10);
X		fflush(stderr);
X	    }
X
X	} else
X	{
X	    ub = client_interact(CC_INSTALL,pos,strlen(fpath),fpath+1,0,NULLP);
X	}
X 
X        if(ub->cmd == CC_ERR)
X        {    
X            fprintf(stderr,"uploading %s: %s\n",path,ub->buf);
X	    free(fpath); return(1); 
X        }   
X 
X	if(!bytes && !first) break;
X        pos += bytes;
X    }
X
X    if(client_trace) { fprintf(stderr,"\r%luk : %s \n",pos>>10,path);
X		       fflush(stderr); }
X
X    free(fpath); return(0);
X}
X
util_get_env()
X{
X    if(!(env_host = getenv("FSP_HOST")))
X		{ fputs("Env var FSP_HOST not defined\n",stderr); exit(1); }
X    if(!(env_port = getenv("FSP_PORT")))
X		{ fputs("Env var FSP_PORT not defined\n",stderr); exit(1); }
X    if(!(env_dir  = getenv("FSP_DIR")))
X		{ fputs("Env var FSP_DIR not defined\n",stderr); exit(1); }
X    if(!(env_myport  = getenv("FSP_LOCALPORT")))
X	    { fputs("Env var FSP_LOCALPORT not defined\n",stderr); exit(1); }
X
X    client_trace  = !!getenv("FSP_TRACE");
X}
X
client_intr()
X{
X    switch(client_intr_state)
X    {
X	case 0: exit(2);
X	case 1: client_intr_state = 2; break;
X	case 2: exit(3);
X    }
X}
X
env_client()
X{
X    util_get_env();
X    init_client(env_host,atoi(env_port),atoi(env_myport));
X    signal(SIGINT,client_intr);
X}
X
X/*****************************************************************************/
X
static DDLIST *ddroot = 0;
X
RDIR *util_opendir(path)
X    char *path;
X{
X    char *fpath;
X    RDIRENT **dep;
X    DDLIST   *ddp;
X    RDIR   *rdirp;
X
X    fpath = util_abs_path(path);
X
X    for(ddp = ddroot; ddp; ddp = ddp->next) if(!strcmp(ddp->path,fpath)) break;
X
X    if(!ddp)
X    {
X	if(!(dep = get_dir_blk(fpath))) return((RDIR *) 0);
X	ddp = (DDLIST *) malloc(sizeof(DDLIST));
X	ddp->dep_root = dep;
X	ddp->path     = fpath;
X	ddp->ref_cnt  = 0;
X	ddp->next     = ddroot;
X	ddroot        = ddp;
X
X    } else free(fpath);
X
X    ddp->ref_cnt++;
X
X    rdirp = (RDIR *) malloc(sizeof(RDIR));
X    rdirp->ddp = ddp;
X    rdirp->dep = ddp->dep_root;
X    return(rdirp);
X}
X
util_closedir(rdirp)
X    RDIR *rdirp;
X{
X    rdirp->ddp->ref_cnt--;
X    free(rdirp);
X}
X
rdirent *util_readdir(rdirp)
X    RDIR *rdirp;
X{
X    static rdirent rde;
X    RDIRENT **dep;
X
X    dep = rdirp->dep;
X
X    if(!*dep) return((rdirent *) 0);
X
X    rde.d_fileno = 10;
X    rde.d_reclen = 10;
X    rde.d_namlen = strlen((*dep)->name);
X    rde.d_name   = (*dep)->name;
X    rdirp->dep   = dep+1;
X
X    return(&rde);
X}
X
util_split_path(path,p1,p2,p3)
X    char *path, **p1, **p2, **p3;
X{
X    char *s;
X    static char junk;
X
X    *p1 = "/";
X    if(*path == '/') { *p2 =  path; *p3 = path+1; }
X		else { *p2 = &junk; *p3 = path  ; }
X
X    for(s = *p3; *s; s++)
X    {
X	if(*s == '/')
X	{
X	    *p1 = path;
X	    *p2 = s;
X	    *p3 = s+1;
X	}
X    }
X
X    return(1);
X}
X
util_stat(path,sbuf)
X    char *path;
X    struct stat *sbuf;
X{
X    RDIR *drp;
X    RDIRENT **dep;
X    char *fpath, *ppath, *p1, *pfile;
X
X    fpath = util_abs_path(path);
X
X    if(!strcmp(fpath,env_dir))
X    {
X	ppath = fpath;
X	pfile = ".";
X
X    } else
X    {
X	util_split_path(fpath,&ppath,&p1,&pfile); *p1 = 0;
X    }
X
X    if(drp = util_opendir(ppath))
X    {
X	for(dep = drp->dep; *dep; dep++)
X	{
X	    if(!strcmp((*dep)->name,pfile))
X	    {
X		if((*dep)->type & RDTYPE_DIR) sbuf->st_mode = 0777 | S_IFDIR;
X					 else sbuf->st_mode = 0666 | S_IFREG;
X
X		if((*dep)->type & RDTYPE_DIR) sbuf->st_nlink  = 2;
X					 else sbuf->st_nlink  = 1;
X		sbuf->st_uid    = 0;
X		sbuf->st_gid    = 0;
X		sbuf->st_size   = (*dep)->size;
X		sbuf->st_atime  = (*dep)->time;
X		sbuf->st_mtime  = (*dep)->time;
X		sbuf->st_ctime  = (*dep)->time;
X		util_closedir(drp); free(fpath); return(0);
X	    }
X	}
X	util_closedir(drp);
X    }
X
X    free(fpath); errno = ENOENT; return(-1);
X}
X
util_cd(p)
X    char *p;
X{
X    char *fpath;
X    UBUF *ub;
X    DDLIST   *ddp;
X
X    fpath = util_abs_path(p);
X    for(ddp = ddroot; ddp; ddp = ddp->next) if(!strcmp(ddp->path,fpath)) break;
X
X    if(!ddp)
X    {
X	ub = client_interact(CC_GET_DIR,0L, strlen(fpath),fpath+1, 0,NULLP);
X
X	if(ub->cmd == CC_ERR)
X	{
X	    free(fpath);
X	    fprintf(stderr,"cd error: %s\n",ub->buf);
X	    errno = EACCES;
X	    return(-1);
X	}
X    }
X
X    if(env_dir_malloced) free(env_dir);
X    env_dir_malloced = 1;
X    env_dir = fpath;
X    return(0);
X}
END_OF_FILE
if test 9556 -ne `wc -c <'client_util.c'`; then
    echo shar: \"'client_util.c'\" unpacked with wrong size!
fi
# end of 'client_util.c'
fi
if test -f 'common_def.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common_def.h'\"
else
echo shar: Extracting \"'common_def.h'\" \(4903 characters\)
sed "s/^X//" >'common_def.h' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include <stdio.h>
X#include <sys/param.h>
X#include <sys/types.h>
X#include <dirent.h>
X#include <errno.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <sys/stat.h>
X#include <sys/time.h>
X#include <fcntl.h>
X#include <signal.h>
X
X/****************************************************************************
X*  UBUF is the structure of message exchanged between server and clients. 
X*
X*    The 'buf' part of the buffer is variable lenght up to max of 1024.
X*    The 'key' field is used by the server for sequence identification.
X*    The 'seq' field is used by the client for sequence identification.
X*
X*  Client's message to server contain a key value that is the same as the
X*  key value of the previous message received from the server.  Similarly,
X*  the server's message to client contains a seq value that is the same
X*  as the seq value of the previous message from the client. 
X*
X*  The buf field is logically partitioned into two parts by the len field.
X*  The len field indicate the size of the first part of the buffer starting
X*  at buf[0].  The rest of the buffer is the second field.  In some cases
X*  both fields can contain information.
X*
X****************************************************************************/
X
X#define UBUF_HSIZE 12                           /* 12 bytes for the header */
X#define UBUF_SPACE 1024			        /* maximum payload.        */
X
typedef struct UBUF {            char   cmd;  /* message code.             */
X                        unsigned char   sum;  /* message checksum.         */
X                        unsigned short  key;  /* message key.              */
X                        unsigned short  seq;  /* message sequence number.  */
X                        unsigned short  len;  /* number of bytes in buf 1. */
X                        unsigned long   pos;  /* location in the file.     */
X
X                        char   buf[UBUF_SPACE];
X                    } UBUF;
X
X/* definition of cmd */
X
X#define CC_VERSION	0x10	/* return server's version string.	*/
X#define CC_ERR          0x40    /* error response from server.          */
X#define CC_GET_DIR      0x41    /* get a directory listing.             */
X#define CC_GET_FILE     0x42    /* get a file.                          */
X#define CC_UP_LOAD      0x43    /* open a file for writing.             */
X#define CC_INSTALL      0x44    /* close a file opened for writing.     */
X#define CC_DEL_FILE     0x45    /* delete a file.                       */
X#define CC_DEL_DIR      0x46    /* delete a directory.                  */
X#define CC_GET_PRO      0x47    /* get directory protection.            */
X#define CC_SET_PRO      0x48    /* set directory protection.            */
X#define CC_MAKE_DIR     0x49    /* create a directory.                  */
X#define CC_BYE          0x4A    /* finish a session.                    */
X
X/****************************************************************************
X*  RDIRENT is the structure of a directory entry contained in a .FSP_CONTENT
X*  file.  Each entry contains a 4 bytes quantity 'time', a 4 bytes quentity
X*  'size', and 1 byte of 'type'.  Then followed by x number of bytes of
X*  'name'.  'name' is null terminated.  Then followed by enough number of
X*  padding to fill to an 4-byte boundary.  At this point, if the next entry
X*  to follow will spread across 1k boundary, then two possible things will
X*  happen.  1) if the header fits between this entry and the 1k boundary,
X*  a complete header will be filled in with a 'type' set to RDTYPE_SKIP.
X*  And then enough bytes to padd to 1k boundary.  2) if the header does
X*  not fit, then simply pad to the 1k boundary.  This will make sure that
X*  messages carrying directory information carry only complete directory
X*  entries and no fragmented entries.  The last entry is type RDTYPE_END.
X****************************************************************************/
X
X#define RDHSIZE (2*sizeof(unsigned long)+sizeof(unsigned char))
X
typedef struct RDIRENT { unsigned long  time;
X                         unsigned long  size;
X                         unsigned char  type;
X                         char        name[1]; } RDIRENT;
X
X#define RDTYPE_END      0x00
X#define RDTYPE_FILE     0x01
X#define RDTYPE_DIR      0x02
X#define RDTYPE_SKIP     0x2A
X
X#define NULLP ((char *) 0)
END_OF_FILE
if test 4903 -ne `wc -c <'common_def.h'`; then
    echo shar: \"'common_def.h'\" unpacked with wrong size!
fi
# end of 'common_def.h'
fi
if test -f 'server_host.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server_host.c'\"
else
echo shar: Extracting \"'server_host.c'\" \(4133 characters\)
sed "s/^X//" >'server_host.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "server_def.h"
X
X/****************************************************************************
X* This file contains routines to maintain client database.
X****************************************************************************/
X
extern char *realloc(), *malloc(), *ctime();
X
static HTAB     *htab;		/* client data base.			*/
static unsigned  hcnt;		/* number of clients.			*/
static unsigned  htot = 0;	/* available entries in the data base.	*/
static HTAB     hzero;
X
X#define HALLOC_SIZE 30
X
X/****************************************************************************
X* Returns an entry from the database corresponding to to the inet number.
X* A new entry is created is it is not found.
X* The database is a linear array of sorted structures.
X* Entries are searched using binary search on the array.
X****************************************************************************/
X
HTAB *find_host(inet_num)
X    unsigned long inet_num;
X{
X    unsigned	  l, h, m, i;
X    unsigned long inum;
X    HTAB	  *hs, *hd;
X
X    for(l = 0, h = hcnt-1; (m = (l + h) >> 1) != l; )	/* binary search */
X    {
X	inum = htab[m].inet_num;
X	if(inum > inet_num) h = m; else
X	if(inum < inet_num) l = m; else { htab[m].acc_cnt++; return(htab+m); }
X    }
X
X    if(htab[m].inet_num < inet_num) m++;  /* locate first entry that is > */
X
X    if((hcnt+1) > htot)			/* need more space */
X    {
X	htot += HALLOC_SIZE;		/* add HALLOC_SIZE entries at a time */
X
X	if(!(htab = (HTAB *) realloc(htab,sizeof(HTAB)*htot)))
X				    { perror("grow_htab realloc"); exit(1); }
X    }
X
X    for(i = hcnt-m, hs = htab+hcnt, hd=htab+hcnt+1; i--; *--hd = *--hs);
X
X    htab[m]=hzero;
X    htab[m].inet_num = inet_num;
X    htab[m].last_key = get_next_key()  ;
X    htab[m].next_key = get_next_key()+1;
X    hcnt++;
X    return(htab+m);
X}
X
X/****************************************************************************
X* Write out the client table in the .HTAB_DUMP file.
X****************************************************************************/
X
dump_htab()
X{
X    int i;
X    FILE *fp;
X    HTAB *hp;
X
X    if(!(fp = fopen(".HTAB_DUMP","w"))) return;
X
X    for(i = hcnt-2, hp = htab+1; i--; hp++)
X    {
X	fprintf(fp,"%d.%d.%d.%d\t%5d %c %s",
X			    ((unsigned char *)(&hp->inet_num))[0],
X			    ((unsigned char *)(&hp->inet_num))[1],
X			    ((unsigned char *)(&hp->inet_num))[2],
X			    ((unsigned char *)(&hp->inet_num))[3],
X			    hp->acc_cnt,
X			    (hp->inhibit) ? '*' : ((hp->active) ? '+' : ' '),
X			    ctime(&(hp->last_acc)));
X    }
X
X    fclose(fp);
X}
X
X/****************************************************************************
X* Client database initialization routine.  Reads in .ROGUE_HOSTS.
X****************************************************************************/
X
init_htab()		/* always have 2 entries -- 0, MAXINT */
X{
X    FILE *fp;
X    HTAB	*hp;
X    char  buf[1024];
X    unsigned int i1,i2,i3,i4;
X    unsigned long hnum;
X
X    if(!(htab = (HTAB *) malloc(sizeof(HTAB)*HALLOC_SIZE)))
X				{ perror("grow_htab malloc"); exit(1); }
X    htab[0] = hzero;
X    htab[1] = hzero;
X    htab[1].inet_num = ~0;
X    hcnt = 2;
X    htot = HALLOC_SIZE;
X
X    if(fp = fopen(".ROGUE_HOSTS","r"))
X    {
X	while(fgets(buf,sizeof(buf),fp))
X	{
X	    if(*buf < '0' || *buf > '9') continue;
X
X	    sscanf(buf,"%d.%d.%d.%d",&i1,&i2,&i3,&i4);
X	    ((unsigned char *) (&hnum))[0] = i1;
X	    ((unsigned char *) (&hnum))[1] = i2;
X	    ((unsigned char *) (&hnum))[2] = i3;
X	    ((unsigned char *) (&hnum))[3] = i4;
X	    hp = find_host(hnum);
X	    hp->inhibit = 1;
X	}
X	fclose(fp);
X    }
X}
END_OF_FILE
if test 4133 -ne `wc -c <'server_host.c'`; then
    echo shar: \"'server_host.c'\" unpacked with wrong size!
fi
# end of 'server_host.c'
fi
if test -f 'server_lib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server_lib.c'\"
else
echo shar: Extracting \"'server_lib.c'\" \(5990 characters\)
sed "s/^X//" >'server_lib.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "server_def.h"
X
extern int errno;
X
static int myport = 0;
static int myfd;
static int interrupted = 0;
X
server_interrupt()
X{
X    interrupted = 1;
X    signal(SIGALRM,server_interrupt);
X}
X
X/****************************************************************************
X*  This is the message filter.  It is called by main with a timeout value.
X*  If timeout is -1, it will never time out.  Otherwise, it waits for a
X*  message.  If timed out, it returns.  Otherwise it pass it through checks.
X*  Those message that passed get sent to the dispatch loop.
X****************************************************************************/
X
server_loop(timeout)
X    unsigned long timeout;
X{
X    unsigned long cur_time;
X    HTAB *hp;
X    UBUF rbuf;
X    struct sockaddr_in from;
X    unsigned u, sum, mask;
X    int retval, bytes, old;
X    unsigned char *s, *d, *t;
X
X    while(1)
X    {
X	mask = 1 << myfd;
X	if(interrupted) { dump_htab(); interrupted = 0; }
X	retval = _x_select(&mask, timeout);
X
X	if(retval == -1) { if(errno = EINTR) continue;
X			   perror("select"); exit(1); }
X
X	if(retval == 1)    /* an incoming message is waiting */
X	{
X	    bytes = sizeof(from);
X	    if((bytes = recvfrom(myfd,(char*)&rbuf,sizeof(rbuf),0,
X				    &from,&bytes)) < UBUF_HSIZE) continue;
X
X	    rbuf.len = ntohs(rbuf.len);
X	    if(rbuf.len+UBUF_HSIZE > bytes) continue;	/* truncated.  */
X
X	    if(!(hp = find_host(from.sin_addr.s_addr)))
X			{ fputs("find host failed\n",stderr); exit(0); }
X
X	    if(hp->inhibit) continue;
X
X	    old = 0;
X	    cur_time = time((time_t *) 0);
X
X	    if(hp->next_key != rbuf.key)
X	    {
X		if(hp->last_key == rbuf.key)
X		{
X		    if(hp->active && (cur_time < hp->last_acc + 3)) continue;
X		    old = 1;
X
X		} else
X		if(hp->active && (cur_time < hp->last_acc + 60)) continue;
X	    }
X
X	    hp->active   =        1;
X	    hp->last_acc = cur_time;
X
X	    s = (unsigned char *) &rbuf;
X	    d = s + bytes;
X	    u = rbuf.sum; rbuf.sum = 0;
X	    for(t = s, sum = bytes; t < d; sum += *t++);
X	    sum = (sum + (sum >> 8)) & 0xff;
X	    if(sum != u) continue;			/* wrong check sum */
X
X	    rbuf.pos = ntohl(rbuf.pos);
X	    server_get_packet(bytes,&rbuf,old,hp,&from);
X
X	} else return(0);				/* got a timeout */
X    }
X}
X
X/****************************************************************************
X* Routine to return a 16-bit key with random number in the first 8-bits and
X* zero in the second 8-bits.
X****************************************************************************/
X
get_next_key()
X{
X    unsigned long k;
X
X    k = random();
X    k = k ^ (k >> 8) ^ (k >> 16) ^ (k << 8);
X
X    return(k & 0xff00);
X}
X
X/****************************************************************************
X* Generic routine for sending reply back to clients.
X*        from: client address structure.
X*          ub: pointer to the message buffer.
X*  len1, len2: lengths of the two data regions in the message buffer.
X****************************************************************************/
X
server_reply(from,ub,len1,len2)
X    struct sockaddr_in *from;
X    UBUF *ub;
X    int   len1, len2;
X{
X    unsigned char *s, *t, *d;
X    unsigned sum;
X
X    if(dbug) fprintf(stderr,"snd (%c,%d,%d,%lu) ---> %d.%d.%d.%d\n",
X                ub->cmd, len1, len2, ub->pos,
X                ((unsigned char *)(&(from->sin_addr.s_addr)))[0],
X                ((unsigned char *)(&(from->sin_addr.s_addr)))[1],
X                ((unsigned char *)(&(from->sin_addr.s_addr)))[2],
X                ((unsigned char *)(&(from->sin_addr.s_addr)))[3]);
X
X    ub->len = htons(len1);
X    ub->pos = htonl(ub->pos);
X
X    ub->sum = 0;
X    s = (unsigned char *) ub;
X    d = s + (len1 + len2 + UBUF_HSIZE);
X    for(t = s, sum = 0; t < d; sum += *t++);
X    ub->sum = sum + (sum >> 8);
X
X    if(sendto(myfd,(char *)ub,(len1 + len2 + UBUF_HSIZE),0,
X			from,sizeof(struct sockaddr_in)) == -1)
X						{ perror("sendto"); exit(1); }
X}
X
X/****************************************************************************
X* Send an error string.
X****************************************************************************/
X
send_error(from,ub,msg)
X    struct sockaddr_in *from;
X    UBUF *ub;
X    char *msg;
X{
X    char *d;
X
X    for(d = ub->buf; *d++ = *msg++; );
X    ub->cmd = CC_ERR;
X
X    server_reply(from,ub,d-ub->buf,0);
X}
X
X/****************************************************************************
X* Send a block of data read from the file 'fp'.  Offset information is
X* contained in the input ub message buffer, which also doubles as the output
X* message buffer.
X****************************************************************************/
X
send_file(from,ub,fp)
X    struct sockaddr_in *from;
X    UBUF *ub;
X    FILE *fp;
X{
X    int bytes;
X
X    fseek(fp,ub->pos,0);
X    bytes = fread(ub->buf, 1, UBUF_SPACE, fp);
X    server_reply(from,ub,bytes,0);
X}
X
X/****************************************************************************
X* The tow UDP socket initialization routines.  One for running alone.
X* The other for running under inetd.
X****************************************************************************/
X
init_network(port)
X    int port;
X{
X    myport = port;
X
X    if((myfd = _x_udp(&myport)) == -1) { perror("socket open"); exit(1); }
X
X    if(dbug)
X    {
X	fprintf(stderr,"listening on port %d\n",myport);
X	fflush(stderr);
X    }
X
X    signal(SIGALRM,server_interrupt);
X}
X
init_inetd()
X{
X    myfd = dup(0);
X
X    signal(SIGALRM,server_interrupt);
X}
END_OF_FILE
if test 5990 -ne `wc -c <'server_lib.c'`; then
    echo shar: \"'server_lib.c'\" unpacked with wrong size!
fi
# end of 'server_lib.c'
fi
if test -f 'server_main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server_main.c'\"
else
echo shar: Extracting \"'server_main.c'\" \(5561 characters\)
sed "s/^X//" >'server_main.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "server_def.h"
X
X#define ERR(S) { send_error(from,ub,S); return; }
X
int inetd_mode =            0;
int dbug       =            0;
int   udp_port = DEF_FSP_PORT;
char *home_dir = DEF_FSP_HOME;
char *run_uid  =            0;
X
X/****************************************************************************
X*  This is the dispatch loop for message that has been accepted.
X*    bytes: size of the message received.
X*       ub: pointer to the message buffer.
X*      old: true if this message contains old sequence number (retransmit).
X*       hp: pointer to the entry for the client host who sent this message.
X*     from: pointer to the socket address structure of the client host.
X****************************************************************************/
X
server_get_packet(bytes,ub,old,hp,from)
X    int   bytes,old;
X    UBUF *ub;
X    HTAB *hp;
X    struct sockaddr_in *from;
X{
X    unsigned long inet_num;
X    unsigned l1, l2;
X    char *s1, *s2, *pe;
X    FILE *fp;
X
X    l1 = ub->len;
X    l2 = bytes - l1 - UBUF_HSIZE;
X    s1 = ub->buf;
X    s2 = ub->buf + l1;
X
X    if(dbug) fprintf(stderr,"rcv (%c,%d,%d,%lu) <--- %d.%d.%d.%d\n",
X		ub->cmd, l1, l2, ub->pos,
X		((unsigned char *)(&hp->inet_num))[0],
X		((unsigned char *)(&hp->inet_num))[1],
X		((unsigned char *)(&hp->inet_num))[2],
X		((unsigned char *)(&hp->inet_num))[3]);
X
X    if(!old) { hp->last_key = hp->next_key;
X	       hp->next_key = get_next_key() + ((hp->last_key+1) & 0x00ff); }
X
X    ub->key  = hp->next_key;
X    inet_num = hp->inet_num;
X
X    switch(ub->cmd)
X    {
X      case CC_VERSION : { ERR(VERSION_STR); }
X
X      case CC_BYE     : { if(!old) hp->active = 0;
X			  server_reply(from,ub,0,0);
X			  return; }
X			
X      case CC_GET_DIR : { if((pe = check_path(s1,l1)) ||
X			     (pe = server_get_dir(s1,&fp))) ERR(pe);
X			  send_file(from,ub,fp);
X			  fclose(fp);
X			  return; }
X
X      case CC_GET_FILE: { if((pe = check_path(s1,l1)) ||
X		             (pe = server_get_file(s1,&fp))) ERR(pe);
X			  send_file(from,ub,fp);
X			  fclose(fp);
X			  return; }
X
X      case CC_DEL_FILE: { if(!old)
X			    if((pe = check_path(s1,l1)) ||
X			       (pe = server_del_file(s1,inet_num))) ERR(pe);
X			  server_reply(from,ub,0,0);
X			  return; }
X
X      case CC_DEL_DIR : { if(!old)
X			    if((pe = check_path(s1,l1)) ||
X			       (pe = server_del_dir(s1,inet_num))) ERR(pe);
X			  server_reply(from,ub,0,0);
X			  return; }
X
X      case CC_UP_LOAD : { if(!old)
X			    if(pe = server_up_load(s1,l1,ub->pos,inet_num))
X								      ERR(pe);
X			  server_reply(from,ub,0,0);
X			  return; }
X
X      case CC_INSTALL : { if(!old)
X			    if((pe = check_path(s1,l1)) ||
X			       (pe = server_install(s1,inet_num))) ERR(pe);
X			  server_reply(from,ub,0,0);
X			  return; }
X
X      case CC_MAKE_DIR: { if(!old)
X			    if((pe = check_path(s1,l1)) ||
X			       (pe = server_make_dir(s1,inet_num))) ERR(pe);
X			  if(pe = server_get_pro(s1,inet_num)) ERR(pe);
X			  server_reply(from,ub,strlen(ub->buf)+1,0);
X			  return; }
X
X      case CC_GET_PRO : { if((pe = check_path(s1,l1)) ||
X			     (pe = server_get_pro(s1,inet_num))) ERR(pe);
X			  server_reply(from,ub,strlen(ub->buf)+1,0);
X			  return; }
X
X      case CC_SET_PRO : { if(!old)
X			    if((pe = check_path(s1,l1)) ||
X			       (pe = server_set_pro(s1,s2,inet_num))) ERR(pe);
X			  if(pe = server_get_pro(s1,inet_num)) ERR(pe);
X			  server_reply(from,ub,strlen(ub->buf)+1,0);
X			  return; }
X    }
X}
X
arg_err()
X{
X    fputs("arg: -h absolute_path    set home directory.\n",stderr);
X    fputs("     -p udp_port_number  set port number.\n",stderr);
X    fputs("     -u uid_number       assume this uid after startup.\n",stderr);
X    fputs("     -d                  turn on debug mode.\n",stderr);
X    exit(1);
X}
X
main(argc,argv)
X    int argc;
X    char **argv;
X{
X    int t;
X
X    inetd_mode = !strcmp(argv[0],"in.fspd");
X
X    if(inetd_mode)
X    {
X	init_inetd();
X	freopen("/dev/null","r",stdin);
X	freopen("/dev/null","w",stdout);
X	freopen("/dev/null","w",stderr);
X    }
X
X    for(t = 1; t < argc; t++)
X    {
X	if(argv[t][0] == '-') switch(argv[t][1])
X	{
X	    case 'd':	dbug++; break;
X
X	    case 'h':	if(argv[t][2]) home_dir = argv[t]+2; else
X			if(argv[t+1] ) home_dir = argv[++t]; else
X								arg_err();
X			break;
X
X	    case 'u':	if(argv[t][2]) run_uid = argv[t]+2; else
X			if(argv[t+1] ) run_uid = argv[++t]; else
X								arg_err();
X			break;
X
X	    case 'p':	if(argv[t][2]) udp_port = atoi(argv[t]+2); else
X			if(argv[t+1] ) udp_port = atoi(argv[++t]); else
X								arg_err();
X			break;
X
X	    default : arg_err();
X
X	} else arg_err();
X    }
X
X    if(!inetd_mode)
X    {
X	init_network(udp_port);
X	if(!dbug) { freopen("/dev/null","r",stdin);
X		    freopen("/dev/null","w",stdout);
X		    freopen("/dev/null","w",stderr); }
X    }
X
X    if(run_uid) if(setuid(atoi(run_uid)) != 0) exit(1);
X    init_home_dir();
X    init_htab();
X
X    srandom(getpid());
X
X    if(inetd_mode) {	      server_loop(120*1000L); }  /* 2 minutes */
X	      else { while(1) server_loop(      -1L); }
X
X    exit(0);
X}
END_OF_FILE
if test 5561 -ne `wc -c <'server_main.c'`; then
    echo shar: \"'server_main.c'\" unpacked with wrong size!
fi
# end of 'server_main.c'
fi
if test -f 'udp_io.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'udp_io.c'\"
else
echo shar: Extracting \"'udp_io.c'\" \(4013 characters\)
sed "s/^X//" >'udp_io.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "common_def.h"
X
static struct sockaddr_in INET_ZERO = { AF_INET };
X
extern int errno;
X#define DSIZE (sizeof(int)*8)
X#define SAVE(A) { int sav; sav = errno; A; errno = sav; }
X
X#ifndef EXOS_IPC
X
X#include <netdb.h>
X
extern long inet_addr();
X
X_x_udp(port)
X    int *port;
X{
X    int f, len, zz;
X    struct sockaddr_in me ;
X    struct sockaddr_in sin;
X
X    me = sin = INET_ZERO;
X
X    me.sin_port = htons((unsigned short) *port);
X    me.sin_family = AF_INET;
X 
X    if((f=socket(AF_INET,SOCK_DGRAM,0)) == -1) return(-1);
X 
X    if( setsockopt(f,SOL_SOCKET,SO_REUSEADDR,(int)&zz,sizeof(zz)) < 0 ||
X        bind(f,(struct sockaddr *) &me,(len = sizeof(me))) < 0 ||
X        getsockname(f,(char *)&sin,&len) < 0)
X                                { SAVE(((void) close(f))); return(-1); }
X    if(!*port) *port = ntohs((unsigned short) sin.sin_port); return(f);
X}      
X
X_x_adr(host,port,his)
X    struct sockaddr_in *his;
X    char *host;
X    int port;
X{
X    char myhost[128];
X    struct hostent *H;
X    int    i;
X    char *s, *d;
X 
X    *his = INET_ZERO;
X    if(!host) (void) gethostname(host = myhost,sizeof(myhost));
X 
X    if((his->sin_addr.s_addr = inet_addr(host)) != -1)
X    {   his->sin_family = AF_INET;
X    } else
X    if(H = gethostbyname(host))
X    {   for(s = (char *)H->h_addr, d = (char *)&his->sin_addr, i = H->h_length;
X						i--; *d++ = *s++);
X        his->sin_family = H->h_addrtype;
X    } else return(-1);
X    his->sin_port = htons((unsigned short) port);
X 
X    return(0);
X}
X
X_x_select(rf, tt)       /* tt is in unit of ms */
X    int *rf;
X    long tt;
X{
X    struct timeval timeout;
X 
X    if(tt != -1)
X    {
X        timeout.tv_sec  =  tt / 1000;
X        timeout.tv_usec = (tt % 1000)*1000;
X        return(select(DSIZE, rf, (int *) 0, (int *) 0, &timeout));
X    }
X       
X    return(select(DSIZE, rf, (int *) 0, (int *) 0, (struct timeval *) 0));
X}
X#endif  /* not EXOS_IPC */
X
X#ifdef EXOS_IPC
X
extern long rhost();
X
X_x_udp(port)
X    int *port;
X{
X    struct sockaddr_in sin; int f;
X
X    sin = INET_ZERO;
X    sin.sin_family = AF_INET;
X    sin.sin_port   = htons((unsigned short) *port);
X    if((f = socket(SOCK_DGRAM, (struct sockproto *) 0, &sin, SO_REUSEADDR))
X							== -1) return(-1);
X    sin = INET_ZERO;
X    if(socketaddr(f,&sin) == -1) { SAVE(((void) close(f))); return(-1); }
X    if(!*port) *port = ntohs((unsigned short) sin.sin_port); return(f);
X}
X
X_x_adr(host,port,his)
X    char *host;
X    int port;
X    struct sockaddr_in *his;
X{
X    char myhost[128];
X    int f;
X
X    *his = INET_ZERO;
X    if(!host) (void) gethostname(host = myhost,sizeof(myhost));
X
X    his->sin_family = AF_INET;
X    his->sin_port   = htons((unsigned short) port);
X
X    if((his->sin_addr.s_addr = rhost(&host)) == -1) return(-1);
X
X    return(0);
X}
X
X_x_select(readfds, tt)
X    int *readfds;
X    long tt;				/* Time to wait in miniseconds. */
X{
X    int  code;
X    long mask = *readfds;
X
X    if(tt & 0xc0000000) tt = 0x3fffffff;/* It does not like 0x7fffffff. */
X
X    code = select(DSIZE, &mask, (long *) 0, tt);
X
X    *readfds = mask;
X
X    return(code);
X}
X
recvfrom(s, msg, len, flags, from, fromlen)
X    char *msg;
X    int s, len, flags, *fromlen;
X    struct sockaddr_in *from;
X{
X    return(receive(s,from,msg,len));
X}
X
sendto(s, msg, len, flags, to, tolen)
X    char *msg;
X    int s, len, flags, tolen;
X    struct sockaddr_in *to;
X{
X     to->sin_family = AF_INET;
X     return(send(s,to,msg,len));
X}
X
X#endif /* EXOS_IPC */
END_OF_FILE
if test 4013 -ne `wc -c <'udp_io.c'`; then
    echo shar: \"'udp_io.c'\" unpacked with wrong size!
fi
# end of 'udp_io.c'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
