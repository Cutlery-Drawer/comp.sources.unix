Subject: v25i024: A real-time, multithreaded Internet archive server, Part01/03
Newsgroups: comp.sources.unix
Approved: vixie@pa.dec.com

Submitted-By: wen-king@vlsi.cs.caltech.edu
Posting-Number: Volume 25, Issue 24
Archive-Name: fsp/part01

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  MANIFEST README bsd_src bsd_src/Makefile bsd_src/cmp.c
#   bsd_src/ls.h bsd_src/tweak.h bsd_src/util.c client_def.h
#   client_lib.c fcatcmd.1 fcatcmd.c fcdcmd.1 fcdcmd.c fgetcmd.1
#   fgetcmd.c flscmd.1 flscmd.c fmkdir.1 fmkdir.c fprocmd.1 fprocmd.c
#   fput.1 fput.c frmcmd.1 frmcmd.c frmdircmd.1 frmdircmd.c fspd.1
#   fver.1 fver.c server_def.h setup
# Wrapped by vixie@cognition.pa.dec.com on Fri Dec 13 17:53:11 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1491 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	
X Makefile                   2	
X README                     1	
X bsd_src                    1	
X bsd_src/Makefile           1	
X bsd_src/cmp.c              1	
X bsd_src/glob.c             2	
X bsd_src/ls.c               3	
X bsd_src/ls.h               1	
X bsd_src/print.c            2	
X bsd_src/random.c           3	
X bsd_src/tweak.h            1	
X bsd_src/util.c             1	
X client_def.h               1	
X client_lib.c               1	
X client_util.c              2	
X common_def.h               2	
X fcatcmd.1                  1	
X fcatcmd.c                  1	
X fcdcmd.1                   1	
X fcdcmd.c                   1	
X fgetcmd.1                  1	
X fgetcmd.c                  1	
X flscmd.1                   1	
X flscmd.c                   1	
X fmkdir.1                   1	
X fmkdir.c                   1	
X fprocmd.1                  1	
X fprocmd.c                  1	
X fput.1                     1	
X fput.c                     1	
X frmcmd.1                   1	
X frmcmd.c                   1	
X frmdircmd.1                1	
X frmdircmd.c                1	
X fspd.1                     1	
X fver.1                     1	
X fver.c                     1	
X server_def.h               1	
X server_file.c              3	
X server_host.c              2	
X server_lib.c               2	
X server_main.c              2	
X setup                      1	
X udp_io.c                   2	
END_OF_FILE
if test 1491 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(13080 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X						Interested party please email
X						wen-king@vlsi.cs.caltech.edu
X    What is the purpose of FSP:
X
X	FSP is a set of programs that implements a public-access archive
X	similar to an anonymous-FTP archive.  It is not meant to be a
X	replacement for ftp; it is only meant to do what anonymous-ftp
X	does, but in a manner more acceptible to the provider of the
X	service and more friendly to the clients. 
X
X	Providing anonymous-FTP service can be costly --- each active
X	session consumes one process slot in the OS and one stream socket
X	entry in the network sub-system.  The servers can also run
X	concurrently, adding to the system load.  A popular archive site
X	can easily be overwhelmed as a result.  Some were forced to
X	shutdown or and some impose inconvienent access restrictions. 
X
X	Unlike FTP, FSP is connection-less and virtually state-less.  One
X	server handles requests from all clients machines.  Each active
X	client machine takes up 16-bytes in a dynamically extensible
X	table.  Since only one server runs at any time, the load added
X	to the server machine is less than one.
X
X	In exchange for allowing site operators to keep their sites open
X	and do away with cumbersome access restrictions, this is what the
X	clients accept with FSP: 
X
X	 1) Lower transfer rate.  The maximum rate is 1 kbyte per UDP
X	    message round-trip time between the client and the server.
X	
X	 2) Only one active transfer per client machine.  This is done
X	    to minimize the amount of data the server has to keep.
X
X	In addition to the potential for more abundant sites and more
X	accessible sites, this is what the clients gain with FSP:
X
X	 1) Robustness.  Since FSP is connectionless, flucturations in
X	    the network will not abort a FSP transaction.  Furthermore,
X	    the 16-bytes of data for each client can be regenerated at
X	    any point during any transaction.  Thus, if the server goes
X	    down at any point during a transaction, the transaction will
X	    resume when the server is restarted.  (like NFS) 
X
X	 2) Friendlier user interface.  FSP does not have its own command
X	    interpretor like FTP.  Since it is connectionless, there is
X	    no reason to carry much information from one command to the
X	    next, and the commands can all be made into individual unix
X	    programs.  For instance, there is one program you run to list
X	    the directory and another you run to download a file. 
X
X	 3) Client protection.  FSP oversees a directory structure similar
X	    to that of an anonymous-FTP.  However, a directory created
X	    via FSP transaction is owned by the client machine that issued
X	    the creation request.  The client can create and delete files
X	    and subdirectories in that directory.  In addition, the client
X	    can enable any of the two attributes for that directory: 
X
X		A) Give all other clients the permission to create files
X		   and subdirectries.
X
X		B) Give all other clients the permission to delete files
X		   and subdirectories.
X
X	    Note: A subdirectory can be deleted only if it is empty,
X		  the client owns the subdirectory, and the client has
X		  delete permission for the parent directory containing
X		  the subdirectory. 
X
X	 4) Server protection.  FSP server does not spawn sub-programs.
X	    It will accept only paths that are downward relative to its
X	    designated working directory.  On systems with symbolic links,
X	    the server will follow symbolic links, but it does not follow
X	    uplinks ("..").  Clients cannot create symbolic links and
X	    care should be taken so that other users on the server machine
X	    cannot create symbolic links in the server's work space. 
X
X	    It is also fairly difficult to formuate an attack to force a
X	    shutdown of a FSP site by actions of a rogue site.  About the
X	    only way to distrupt a FSP service is to flood the FSP site
X	    with network packets.  FSP server prevents itself from
X	    'counter-flooding' by filtering for legitimate requests using
X	    the following method:
X
X		A) Each request message contains a key.  For each client,
X		   server database contains the keys to be used for the
X		   next client request and for the previous client request.
X
X		B) If the next request does not contain a key that matches
X		   either of the two keys, it is accepted only if at least
X		   one minute has elapsed since the last time a request
X		   is accepted.  If the key does match the old key
X		   (retransmit) it is accepted if the elapse time is
X		   greater than 3 seconds.
X
X		C) Every request message accepted is acknowledged with
X		   one reply message.  The reply message contains a new
X		   key to used for the next request.  The new key is
X		   computed by the server with a pseudo-random number
X		   generator. 
X
X	    Flooding is a ballant violation of network etiquette because
X	    a site can be subjected to flooding attack whether it has FSP
X	    running or not, and flooding congests every link and gateway
X	    between the rogue client and the server.  As a further measure
X	    of protection, the server loads a table of rogue clients on
X	    startup.  The server will not respond to requests from any of
X	    those clients.
X
X    The software set:
X
X	common_def.h	This C header file contains definitions common to
X			both the server code and the client code.
X
X	client_def.h	This C header file contains definitions for the
X			client code.
X
X	server_def.h	This C header file contains definitions for the
X			server code.
X
X	udp_io.c	This file contains the lowest level routines that
X			deal with the unix inet sockets.  This file is
X			used by both the server code and the client code.
X
X	server_main.c	Main routine and dispatch loop for the server.
X	server_host.c	Routines for maintaining client database.
X	server_file.c	Routines for file i/o.
X	server_lib.c	Routines for inet socket i/o.
X
X	client_lib.c	Core routines of the client library.
X	client_util.c	Supplementry routines of the client library.
X
X	bsd_src/	Directory containing additional sources derived
X			from those in public archive on uunet.uu.net.  It
X			contains a BSD random/srandom routine, a modified
X			BSD globbing routine, a modified "ls" source.
X
X	fcdcmd.c	These compiles into individual client utilities.
X	fgetcmd.c	Those with a "cmd" in their name will do their
X	flscmd.c	own globbing on their argv base on directory
X	fprocmd.c	information obtained from the server.
X	frmcmd.c
X	frmdircmd.c
X	fcatcmd.c
X	fmkdir.c
X	fput.c
X	fver.c
X
X    Compilation:
X
X	FSP has been compiled and tested on a SS-2 running SunOs 4.1.1,
X	a HP-9000 running HP UNIX, a VAX-780 running 4.3-tahoe, and a 386
X	box running system-V UNIX with old Excelan ethernet interface. 
X
X	To compile the software, you must first successfully complete a
X	"make" in the bsd_src directory.  You may have to change a few
X	files.  In particular, you may have to edit "Makefile" and "tweak.h"
X	in bsd_src directory. 
X
X	When that is done, you can edit the Makefile on the top directory
X	and run "make" in the top directory.  You may have to read through
X	the rest of this document first before making changes to the Makefile.
X
X    Server Administration:
X
X	The only things you need for setting up a FSP server is a work
X	directory for the service and and the FSP server itself (fspd).
X	fspd can run independently or it can be run under inetd.  When
X	running independently, fspd waits for messages through a UDP
X	socket whoes port number is defined in the Makefile.  When running
X	under inetd, fspd is involked as in.fspd.  inetd will spawn fspd
X	when a message arrives for the FSP socket.  The fspd process will
X	take over and stick around to wait on additional messages.  After
X	it has become idle for 2 minutes, fspd will exit and return control
X	to inetd. 
X
X	Sample setup for inetd operation:
X
X	    In /etc/services file:
X
X		fsp             21/udp          fspd
X
X	    In /etc/inetd.conf file:
X
X		fsp dgram   udp wait ftp /usr/etc/fspd in.fspd
X
X	    In this sample, the same port number for ftp is used for the
X	    fsp socket.  There will not be a conflict because ftp uses
X	    stream protocol, and fsp uses UDP protocol.  The fspd program
X	    in this example is ran under user 'ftp'. 
X
X	In addition, fspd will accept these flags:
X
X	    -h absolute_path    Set fsp work directory.  Overrides the
X				compiled-in default.
X
X	    -p udp_port_number  Set UDP port number.  Overrides the
X				compiled-in default.
X
X	    -u uid_number       Assume this uid after startup.  If present,
X				fspd will attempt a setuid() to this uid
X				number.  It will exit if setuid() fails.
X
X	    -d                  Turn on debug mode.  The stdio files will
X				remain open in debugging mode.
X
X	When fspd starts, it chdir to its work directory where it looks
X	for (and reads in if found) a list of internet numbers in the
X	standard 4-part form: ddd.ddd.ddd.ddd in the file ".ROGUE_HOSTS".
X	This file is prepared by the FSP maintainer, and is used to
X	indicate that fspd should not respond to any requests from these
X	machines.   After that, it begins to service any requests it gets
X	on the UDP socket.
X
X	If a file .OWN.XXXXXXXX, where XXXXXXXX is an 8-digit hex number,
X	exists in a directory in fspd's work space, the directory is owned
X	by the machine whoes inet number is XXXXXXXX, where the number
X	is printed as a hexadecimal number.  If no such file exists, the
X	directory has no owner.
X
X	If the file .FSP_NO_DEL exists in a directory, only the owner is
X	allowed to remove items from that directory.
X
X	If the file .FSP_NO_ADD exists in a directory, only the owner is
X	allowed to add items into that directory.
X
X	Thus, you typically want to protect the top directory by creating
X	the .FSP_NO_DEL and .FSP_NO_ADD files, and leaving out the
X	.OWN.XXXXXXXX file in the top directory. 
X
X	Clients does not get to read the directory information directory.
X	fspd maintains a directory listing in the file .FSP_CONTENT in
X	each directory.  When a client requests information for a directory,
X	the .FSP_CONTENT file is created if it doesn't exist, and it is
X	rebuilt if it is out of date.  The information is accessed by
X	having the client read the directory listing file.  Care is taken
X	so that the client will not get corrupted entries when the directory
X	is changed while the listing is being read.
X
X	Files being uploaded are first written to a temporary file in the
X	work directory: .TMP.XXXXXXXX where XXXXXXXX is the inet number
X	of the client.  When upload is compelete, the file is moved into
X	the intended location. 
X
X	An 'alarm' interrupt will cause fspd to dump its current client
X	database into the file .HTAB_DUMP in the work directory.  This
X	can be useful for debugging and for catching rogue clients.
X
X    Client utilities:
X
X	All inter-command states are kept in these four shell environment
X	variables.
X
X	    FSP_PORT		Port number of the fspd you wish to contact.
X	    FSP_HOST		Host name or number of the fspd.
X	    FSP_LOCALPORT	Port number to use for talking to fspd.
X	    FSP_DIR		Your current working directory in the archive.
X
X	In addition, FSP_TRACE can be set if you want status reports be
X	printed while files are being transferred.
X
X	A typical setup looks like this:
X
X	    setenv FSP_PORT	 21
X	    setenv FSP_HOST	 131.215.131.97
X	    setenv FSP_LOCALPORT 4334
X	    setenv FSP_DIR	 /
X	    setenv FSP_TRACE
X
X	(All examples will be in csh.  However, it is assumed that similar
X	 things can be done with other shells)
X
X	The FSP_LOCALPORT should be the same for all users on the same
X	machine and trying to access to the same server.  It can be used
X	as a way to achieve mutual exclusion to ensure that only one
X	transaction takes place at any time.
X
X	For commands that do globbing using remote directory info, normal
X	shell globbing needs to be turned off.  In csh, it can be done
X	with a set of aliases: 
X
X	    alias fcd setenv FSP_DIR \`\(set noglob\; exec fcdcmd \!\*\)\`
X	    alias fls    \(set noglob\; exec flscmd    \!\*\)
X	    alias fget   \(set noglob\; exec fgetcmd   \!\*\)
X	    alias fcat   \(set noglob\; exec fcatcmd   \!\*\)
X	    alias frm    \(set noglob\; exec frmcmd    \!\*\)
X	    alias frmdir \(set noglob\; exec frmdircmd \!\*\)
X	    alias fpro   \(set noglob\; exec fprocmd   \!\*\)
X	
X	In addtion, this alias is useful:
X
X	    alias fpwd echo \$FSP_DIR on \$FSP_HOST port \$FSP_PORT
X
X	Commands:
X
X	    fver	display server's version number.
X	    fcd		change current remote directory, like cd.
X	    fls		list directory.  works like ls.
X	    fget	get the named files.
X	    fput	put the named files.
X	    fcat	get the named files and send them to stdout.
X	    fmkdir	make named directories.
X	    frm		delete named files.
X	    frmdir	delete named directories.
X
X	    fpro	no arg: display directory protection modes.
X			    +c: give others permission to create new items.
X			    -c: deny others permission to create new items.
X			    +d: give others permission to delete old items.
X			    -d: deny others permission to delete old items.
X
X    ***********************************************************************
X
X    This is a free software.  Be creative; make your own macros and tools
X    and let me know of any bugs and suggestions.
END_OF_FILE
if test 13080 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'bsd_src' ; then
    echo shar: Creating directory \"'bsd_src'\"
    mkdir 'bsd_src'
fi
if test -f 'bsd_src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bsd_src/Makefile'\"
else
echo shar: Extracting \"'bsd_src/Makefile'\" \(516 characters\)
sed "s/^X//" >'bsd_src/Makefile' <<'END_OF_FILE'
X# This subdirectory contains modified version of files obtained from the
X# uunet.uu.net archive.  You need to do 'make' in this directory first.
X# You may have to edit tweak.h to get things to them to properly on your
X# system.
X
CFLAGS=-g
X
all: cmp.o glob.o ls.o print.o util.o random.o
X
cmp.o: cmp.c ls.h tweak.h
glob.o: glob.c ../client_def.h ../common_def.h tweak.h
ls.o: ls.c ../client_def.h ../common_def.h ls.h tweak.h
print.o: print.c ls.h tweak.h
util.o: util.c tweak.h
random.o: random.c
X
clean:
X	rm -f *.o
END_OF_FILE
if test 516 -ne `wc -c <'bsd_src/Makefile'`; then
    echo shar: \"'bsd_src/Makefile'\" unpacked with wrong size!
fi
# end of 'bsd_src/Makefile'
fi
if test -f 'bsd_src/cmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bsd_src/cmp.c'\"
else
echo shar: Extracting \"'bsd_src/cmp.c'\" \(1886 characters\)
sed "s/^X//" >'bsd_src/cmp.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989 The Regents of the University of California.
X * All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Michael Fischbein.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that: (1) source distributions retain this entire copyright
X * notice and comment, and (2) distributions including binaries display
X * the following acknowledgement:  ``This product includes software
X * developed by the University of California, Berkeley and its contributors''
X * in the documentation or other materials provided with the distribution
X * and in all advertising materials mentioning features or use of this
X * software. Neither the name of the University nor the names of its
X * contributors may be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
static char sccsid[] = "@(#)cmp.c	5.2 (Berkeley) 4/8/90";
X#endif /* not lint */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include "ls.h"
X#include "tweak.h"
X
namecmp(a, b)
X	LS *a, *b;
X{
X	return(strcmp(a->name, b->name));
X}
X
revnamecmp(a, b)
X	LS *a, *b;
X{
X	return(strcmp(b->name, a->name));
X}
X
modcmp(a, b)
X	LS *a, *b;
X{
X	return(a->lstat.st_mtime < b->lstat.st_mtime);
X}
X
revmodcmp(a, b)
X	LS *a, *b;
X{
X	return(b->lstat.st_mtime < a->lstat.st_mtime);
X}
X
acccmp(a, b)
X	LS *a, *b;
X{
X	return(a->lstat.st_atime < b->lstat.st_atime);
X}
X
revacccmp(a, b)
X	LS *a, *b;
X{
X	return(b->lstat.st_atime < a->lstat.st_atime);
X}
X
statcmp(a, b)
X	LS *a, *b;
X{
X	return(a->lstat.st_ctime < b->lstat.st_ctime);
X}
X
revstatcmp(a, b)
X	LS *a, *b;
X{
X	return(b->lstat.st_ctime < a->lstat.st_ctime);
X}
END_OF_FILE
if test 1886 -ne `wc -c <'bsd_src/cmp.c'`; then
    echo shar: \"'bsd_src/cmp.c'\" unpacked with wrong size!
fi
# end of 'bsd_src/cmp.c'
fi
if test -f 'bsd_src/ls.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bsd_src/ls.h'\"
else
echo shar: Extracting \"'bsd_src/ls.h'\" \(2175 characters\)
sed "s/^X//" >'bsd_src/ls.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989 The Regents of the University of California.
X * All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Michael Fischbein.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that: (1) source distributions retain this entire copyright
X * notice and comment, and (2) distributions including binaries display
X * the following acknowledgement:  ``This product includes software
X * developed by the University of California, Berkeley and its contributors''
X * in the documentation or other materials provided with the distribution
X * and in all advertising materials mentioning features or use of this
X * software. Neither the name of the University nor the names of its
X * contributors may be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X *
X *	@(#)ls.h	5.10 (Berkeley) 4/8/90
X */
X
typedef struct _lsstruct {
X	char *name;			/* file name */
X	int len;			/* file name length */
X	struct stat lstat;		/* lstat(2) for file */
X} LS;
X
X/*
X * overload -- we probably have to save blocks and/or maxlen with the lstat
X * array, so tabdir() stuffs it into unused fields in the first stat structure.
X * If there's ever a type larger than u_long, fix this.  Any calls to qsort
X * must save and restore the values.
X */
X#define	st_btotal	st_dev
X#define	st_maxlen	st_rdev
X
extern int errno;
X
extern int f_accesstime;	/* use time of last access */
extern int f_group;		/* show group ownership of a file */
extern int f_inode;		/* print inode */
extern int f_kblocks;		/* print size in kilobytes */
extern int f_longform;		/* long listing format */
extern int f_singlecol;		/* use single column output */
extern int f_size;		/* list size in short listing */
extern int f_statustime;	/* use time of last mode change */
extern int f_total;		/* if precede with "total" line */
extern int f_type;		/* add type character for non-regular files */
END_OF_FILE
if test 2175 -ne `wc -c <'bsd_src/ls.h'`; then
    echo shar: \"'bsd_src/ls.h'\" unpacked with wrong size!
fi
# end of 'bsd_src/ls.h'
fi
if test -f 'bsd_src/tweak.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bsd_src/tweak.h'\"
else
echo shar: Extracting \"'bsd_src/tweak.h'\" \(681 characters\)
sed "s/^X//" >'bsd_src/tweak.h' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X/* #define d_ino d_fileno		/* */
X/* #define mode_t unsigned short	/* */
END_OF_FILE
if test 681 -ne `wc -c <'bsd_src/tweak.h'`; then
    echo shar: \"'bsd_src/tweak.h'\" unpacked with wrong size!
fi
# end of 'bsd_src/tweak.h'
fi
if test -f 'bsd_src/util.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bsd_src/util.c'\"
else
echo shar: Extracting \"'bsd_src/util.c'\" \(1739 characters\)
sed "s/^X//" >'bsd_src/util.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989 The Regents of the University of California.
X * All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Michael Fischbein.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that: (1) source distributions retain this entire copyright
X * notice and comment, and (2) distributions including binaries display
X * the following acknowledgement:  ``This product includes software
X * developed by the University of California, Berkeley and its contributors''
X * in the documentation or other materials provided with the distribution
X * and in all advertising materials mentioning features or use of this
X * software. Neither the name of the University nor the names of its
X * contributors may be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
static char sccsid[] = "@(#)util.c	5.7 (Berkeley) 4/8/90";
X#endif /* not lint */
X
X#include <sys/types.h>
X#include <stdio.h>
X#include <ctype.h>
X#include "tweak.h"
X
prcopy(src, dest, len)
X	register char *src, *dest;
X	register int len;
X{
X	register int ch;
X
X	while(len--) {
X		ch = *src++;
X		*dest++ = isprint(ch) ? ch : '?';
X	}
X}
X
char
X*emalloc(size)
X	unsigned int size;
X{
X	char *retval, *malloc();
X
X	if (!(retval = malloc(size)))
X		nomem();
X	return(retval);
X}
X
nomem()
X{
X	(void)fprintf(stderr, "ls: out of memory.\n");
X	ls_bad(1);
X}
X
usage()
X{
X	(void)fprintf(stderr, "usage: ls [-1ACFLRacdfgiklqrstu] [file ...]\n");
X	ls_bad(1);
X}
END_OF_FILE
if test 1739 -ne `wc -c <'bsd_src/util.c'`; then
    echo shar: \"'bsd_src/util.c'\" unpacked with wrong size!
fi
# end of 'bsd_src/util.c'
fi
if test -f 'client_def.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'client_def.h'\"
else
echo shar: Extracting \"'client_def.h'\" \(1460 characters\)
sed "s/^X//" >'client_def.h' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "common_def.h"
X
X/****************************************************************************
X* These structures are used to implement a opendir/readdir mechanism similar
X* to that of the normal opendir/reader mechanism in unix.
X****************************************************************************/
X
typedef struct DDLIST {	struct DDLIST *next;
X			char          *path;
X			RDIRENT  **dep_root;
X			int         ref_cnt; } DDLIST;
X
typedef struct RDIR { DDLIST   *ddp;
X		      RDIRENT **dep; } RDIR;
X
typedef struct rdirent { unsigned long  d_fileno;
X			 unsigned short d_reclen;
X			 unsigned short d_namlen;
X			 char          *d_name; } rdirent;
X
extern UBUF     *client_interact();
extern RDIRENT **get_dir_blk();
extern rdirent  *util_readdir();
extern RDIR     *util_opendir();
X
extern int client_trace;
extern int client_intr_state;
END_OF_FILE
if test 1460 -ne `wc -c <'client_def.h'`; then
    echo shar: \"'client_def.h'\" unpacked with wrong size!
fi
# end of 'client_def.h'
fi
if test -f 'client_lib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'client_lib.c'\"
else
echo shar: Extracting \"'client_lib.c'\" \(2942 characters\)
sed "s/^X//" >'client_lib.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "client_def.h"
X
extern int errno;
X
static int myfd;
static struct sockaddr_in server_addr;
static unsigned short myseq = 0;
static unsigned short key;
X
int client_trace      = 0;
int client_intr_state = 0;
X
UBUF *client_interact(cmd,pos,l1,p1,l2,p2)
X    unsigned cmd, l1, l2;
X    unsigned long pos;
X    unsigned char *p1, *p2;
X{
X    struct sockaddr_in from;
X    UBUF sbuf;
X    static UBUF rbuf;
X    unsigned char *s, *t, *d;
X    unsigned u, n, sum, mask, mlen;
X    int retval, bytes, retry;
X
X    sbuf.cmd = cmd;
X    sbuf.len = htons(l1);
X    sbuf.pos = htonl(pos);
X
X    client_intr_state = 1;
X
X    for(u = l1, d = (unsigned char *) sbuf.buf; u--; *d++ = *p1++);
X    for(u = l2				      ; u--; *d++ = *p2++);
X    mlen = d - (unsigned char *) &sbuf;
X
X    for(retry = 0; ; retry++)
X    {
X	sbuf.key = key;
X	sbuf.seq = myseq;
X	sbuf.sum = 0;
X
X	for(t = (unsigned char *) &sbuf, sum = n = mlen; n--; sum += *t++);
X	sbuf.sum = sum + (sum >> 8);
X	if(client_trace && retry) write(2,"R",1);
X
X	if(sendto(myfd,&sbuf,mlen,0,&server_addr,sizeof(server_addr)) == -1)
X						{ perror("sendto"); exit(1); }
X	mask = 1 << myfd;
X
X	while(1)
X	{
X	    retval = _x_select(&mask, 3000L);
X
X	    if((retval == -1) && (errno = EINTR)) continue;
X
X	    if(retval == 1)    /* an incoming message is waiting */
X	    {
X		bytes = sizeof(from);
X		if((bytes = recvfrom(myfd,(char*)&rbuf,sizeof(rbuf),0,
X					&from,&bytes)) < UBUF_HSIZE) continue;
X
X		s = (unsigned char *) &rbuf;
X		d = s + bytes;
X		u = rbuf.sum; rbuf.sum = 0;
X		for(t = s, sum = 0; t < d; sum += *t++);
X		sum = (sum + (sum >> 8)) & 0xff;
X		if(sum != u) continue;  /* wrong check sum */
X
X		rbuf.len = htons(rbuf.len);
X		rbuf.pos = htonl(rbuf.pos);
X
X		if(rbuf.seq 	      != myseq) continue;  /* wrong seq # */
X		if(rbuf.len+UBUF_HSIZE > bytes) continue;  /* truncated.  */
X
X		myseq++; key = rbuf.key;	/* update seq and keys.   */
X
X		if(client_intr_state == 2) { client_done(); exit(1); }
X
X		return(&rbuf);
X
X	    } else break;   /* go back to re-transmit buffer again */
X	}
X    }
X}
X
init_client(host,port,myport)
X    char *host;
X    int   port;
X    int myport;
X{
X    if((myfd = _x_udp(&myport)) == -1)
X		{ perror("socket open"); exit(1); }
X
X    if(_x_adr(host,port,&server_addr) == -1)
X		{ perror("server addr"); exit(1); } 
X}
X
client_done()
X{
X    (void) client_interact(CC_BYE,0L,0,NULLP,0,NULLP);
X}
END_OF_FILE
if test 2942 -ne `wc -c <'client_lib.c'`; then
    echo shar: \"'client_lib.c'\" unpacked with wrong size!
fi
# end of 'client_lib.c'
fi
if test -f 'fcatcmd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fcatcmd.1'\"
else
echo shar: Extracting \"'fcatcmd.1'\" \(1639 characters\)
sed "s/^X//" >'fcatcmd.1' <<'END_OF_FILE'
X.TH FCAT 1 "8 December 1991"
X.SH NAME
fcatcmd, fcat \- copy files in the FSP database to stdout
X.SH SYNOPSIS
X.B fcatcmd
X.I filename
X\&.\|.\|.
X.LP
X.B fcat
X.I filename
X\&.\|.\|.
X.SH DESCRIPTION
X.LP
XFor each file named in the argument list,
X.B fcatcmd
reads the file and writes the content of the file to its
X.B stdout.
X.LP
X.B fcatcmd
will perform
X.B csh
file name globbing based on file and directory information
obtained from the FSP database.
X.LP
Since user's command shells generally cannot do the proper globbing for
this program, it is recommended that user defines a shell alias or
fucntion to turns off command shell globbing before running this program.
X.B csh
example:
X.LP
X.nf
alias fcat \e(set noglob\e; exec fcatcmd \e!\e*\e)
X.fi
X.SH ENVIRONMENT
X.LP
The following variables associate this program with a FSP database:
X.TP
X.B FSP_HOST
The name or internet number of the machine with the FSP server.
X.TP
X.B FSP_PORT
The port number of the UDP socket used by the FSP server.
X.TP
X.B FSP_LOCALPORT
The port number of the UDP socket used by FSP client utilities.
You may pick any number not currently used for other purposes.
The main reason of defining this number is to ensure mutual
exclusion between client utilities accessing the same FSP database.
X.TP
X.B FSP_DIR
The current working directory of the client in the FSP database.
The root of the database is /.
X.TP
X.B FSP_TRACE
If this variable is set,
X.B fcatcmd
will display the number of kilo-byte blocks transfered as transfer
progresses.
X.SH "SEE ALSO"
X.PD
fcatcmd(1), fcdcmd(1), fgetcmd(1), flscmd(1), fmkdir(1),
fprocmd(1), fput(1), frmcmd(1), frmdircmd(1), fver(1), fspd(1)
END_OF_FILE
if test 1639 -ne `wc -c <'fcatcmd.1'`; then
    echo shar: \"'fcatcmd.1'\" unpacked with wrong size!
fi
# end of 'fcatcmd.1'
fi
if test -f 'fcatcmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fcatcmd.c'\"
else
echo shar: Extracting \"'fcatcmd.c'\" \(1140 characters\)
sed "s/^X//" >'fcatcmd.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "client_def.h"
X
extern char **glob();
dont_die(){}
X
main(argc,argv,envp)
X    int argc;
X    char **argv,**envp;
X{
X    char **av, *av2[2];
X
X    env_client();
X
X    signal(SIGPIPE,dont_die);
X
X    while(*++argv)
X    {
X	if(!(av = glob(*argv))) { av = av2; av2[0] = *argv; av2[1] = 0; }
X	while(*av) get_file(*av++);
X    }
X
X    client_done();
X
X    exit(0);
X}
X
get_file(path)
X    char *path;
X{
X    char *name, *t2;
X    FILE *fp;
X
X    for(name = t2 = path; *t2; t2++) if(*t2 == '/') name = t2 + 1;
X    util_download(path,stdout);
X}
END_OF_FILE
if test 1140 -ne `wc -c <'fcatcmd.c'`; then
    echo shar: \"'fcatcmd.c'\" unpacked with wrong size!
fi
# end of 'fcatcmd.c'
fi
if test -f 'fcdcmd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fcdcmd.1'\"
else
echo shar: Extracting \"'fcdcmd.1'\" \(2087 characters\)
sed "s/^X//" >'fcdcmd.1' <<'END_OF_FILE'
X.TH FCD 1 "8 December 1991"
X.SH NAME
fcdcmd, fcd \- change client's current working directory in the FSP database
X.SH SYNOPSIS
X.B fcdcmd
X.I path
X.LP
X.B fcd
X.I path
X.SH DESCRIPTION
X.LP
If no paths are given, / is used as the current working directory.  If
X.I path
begins with a /,
X.B fcdcmd
uses it as the current working directory.  Otherwise,
X.B fcdcmd
appends
X.I path
to the end of the current working directory.  In both cases,
X.B fcdcmd
simplifies the new path and writes it to the
X.I stdout.
In order for the effect of
X.B fcdcmd
to be felt in subsequent FSP transactions, user needs to save the
X.I stdout
output in the
X.I FSP_DIR
variable.  If the change is successful,
X.B fcdcmd
will display the protection setting of the new working directory.
X.LP
X.B fcdcmd
will perform
X.B csh
file name globbing based on file and directory information
obtained from the FSP database.
X.LP
Since user's command shells generally cannot do the proper globbing for
this program, it is recommended that user defines a shell alias or
fucntion to turns off command shell globbing before running this program.
X.B csh
example:
X.LP
X.nf
alias fcd setenv FSP_DIR \e`\e(set noglob\e; exec fcdcmd \e!\e*\e)\e`
X.fi
X.SH ENVIRONMENT
X.LP
The following variables associate this program with a FSP database:
X.TP
X.B FSP_HOST
The name or internet number of the machine with the FSP server.
X.TP
X.B FSP_PORT
The port number of the UDP socket used by the FSP server.
X.TP
X.B FSP_LOCALPORT
The port number of the UDP socket used by FSP client utilities.
You may pick any number not currently used for other purposes.
The main reason of defining this number is to ensure mutual
exclusion between client utilities accessing the same FSP database.
X.TP
X.B FSP_DIR
The current working directory of the client in the FSP database.
The root of the database is /.
X.SH "SEE ALSO"
X.PD
fcatcmd(1), fcdcmd(1), fgetcmd(1), flscmd(1), fmkdir(1),
fprocmd(1), fput(1), frmcmd(1), frmdircmd(1), fver(1), fspd(1)
X.br
X.ne 5
X.SH BUGS
X.LP
If more than one
X.B paths
are given, only the first one will be used.
The rest will be silently ignored.
END_OF_FILE
if test 2087 -ne `wc -c <'fcdcmd.1'`; then
    echo shar: \"'fcdcmd.1'\" unpacked with wrong size!
fi
# end of 'fcdcmd.1'
fi
if test -f 'fcdcmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fcdcmd.c'\"
else
echo shar: Extracting \"'fcdcmd.c'\" \(1359 characters\)
sed "s/^X//" >'fcdcmd.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "client_def.h"
X
extern char **glob();
extern char *env_dir;
extern char *util_abs_path();
X
main(argc,argv)
X    int argc;
X    char **argv;
X{
X    char *np;
X    char **av, *av2[2];
X
X    env_client();
X    if(argc == 1)
X    {
X	print_pro("/");
X	puts("/");
X    }
X    else
X    {
X        if(!(av = glob(argv[1]))) { av = av2; av2[0] = *argv; av2[1] = 0; }
X	np = util_abs_path(*av);
X	if(print_pro(np)) puts(np); else puts(env_dir);
X    }
X    client_done();
X    exit(0);
X}
X
print_pro(p)
X    char *p;
X{
X    UBUF *ub;
X
X    ub = client_interact(CC_GET_PRO,0L, strlen(p),p+1, 0,NULLP);
X
X    if(ub->cmd == CC_ERR)
X    {
X	fprintf(stderr,"ERR: %s\n",ub->buf);
X	return(0);
X
X    } else
X    {
X	fprintf(stderr,"directory mode: %s\n",ub->buf);
X	return(1);
X    }
X}
END_OF_FILE
if test 1359 -ne `wc -c <'fcdcmd.c'`; then
    echo shar: \"'fcdcmd.c'\" unpacked with wrong size!
fi
# end of 'fcdcmd.c'
fi
if test -f 'fgetcmd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fgetcmd.1'\"
else
echo shar: Extracting \"'fgetcmd.1'\" \(1649 characters\)
sed "s/^X//" >'fgetcmd.1' <<'END_OF_FILE'
X.TH FGET 1 "8 December 1991"
X.SH NAME
fgetcmd, fget \- download files from the FSP database
X.SH SYNOPSIS
X.B fgetcmd
X.I filename
X\&.\|.\|.
X.LP
X.B fget
X.I filename
X\&.\|.\|.
X.SH DESCRIPTION
X.LP
XFor each file named in the argument list,
X.B fgetcmd
copies the file to the client's current working directory in the
client machine.
X.B fgetcmd
will perform
X.B csh
file name globbing based on file and directory information
obtained from the FSP database.
X.LP
Since user's command shells generally cannot do the proper globbing for
this program, it is recommended that user defines a shell alias or
fucntion to turns off command shell globbing before running this program.
X.B csh
example:
X.LP
X.nf
alias fget \e(set noglob\e; exec fgetcmd \e!\e*\e)
X.fi
X.SH ENVIRONMENT
X.LP
The following variables associate this program with a FSP database:
X.TP
X.B FSP_HOST
The name or internet number of the machine with the FSP server.
X.TP
X.B FSP_PORT
The port number of the UDP socket used by the FSP server.
X.TP
X.B FSP_LOCALPORT
The port number of the UDP socket used by FSP client utilities.
You may pick any number not currently used for other purposes.
The main reason of defining this number is to ensure mutual
exclusion between client utilities accessing the same FSP database.
X.TP
X.B FSP_DIR
The current working directory of the client in the FSP database.
The root of the database is /.
X.TP
X.B FSP_TRACE
If this variable is set,   
X.B fgetcmd
will display the number of kilo-byte blocks transfered as transfer 
progresses. 
X.SH "SEE ALSO"
X.PD
fcatcmd(1), fcdcmd(1), fgetcmd(1), flscmd(1), fmkdir(1),
fprocmd(1), fput(1), frmcmd(1), frmdircmd(1), fver(1), fspd(1)
END_OF_FILE
if test 1649 -ne `wc -c <'fgetcmd.1'`; then
    echo shar: \"'fgetcmd.1'\" unpacked with wrong size!
fi
# end of 'fgetcmd.1'
fi
if test -f 'fgetcmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fgetcmd.c'\"
else
echo shar: Extracting \"'fgetcmd.c'\" \(1261 characters\)
sed "s/^X//" >'fgetcmd.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "client_def.h"
X
extern char **glob();
X
main(argc,argv,envp)
X    int argc;
X    char **argv,**envp;
X{
X    char **av, *av2[2];
X
X    env_client();
X
X    while(*++argv)
X    {
X	if(!(av = glob(*argv))) { av = av2; av2[0] = *argv; av2[1] = 0; }
X	while(*av) get_file(*av++);
X    }
X
X    client_done();
X
X    exit(0);
X}
X
get_file(path)
X    char *path;
X{
X    char *name, *t2;
X    FILE *fp;
X
X    for(name = t2 = path; *t2; t2++) if(*t2 == '/') name = t2 + 1;
X
X    if(fp = fopen(name,"w"))
X    {
X	if(util_download(path,fp) == -1) { fclose(fp); unlink(name); }
X				    else { fclose(fp);               }
X
X    } else fprintf(stderr,"Cannot write %s\n",name);
X}
END_OF_FILE
if test 1261 -ne `wc -c <'fgetcmd.c'`; then
    echo shar: \"'fgetcmd.c'\" unpacked with wrong size!
fi
# end of 'fgetcmd.c'
fi
if test -f 'flscmd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flscmd.1'\"
else
echo shar: Extracting \"'flscmd.1'\" \(1881 characters\)
sed "s/^X//" >'flscmd.1' <<'END_OF_FILE'
X.TH FLS 1 "8 December 1991"
X.SH NAME
flscmd, fls \- list the contents of a FSP database
X.SH SYNOPSIS
X.B flscmd
X[
X.B unix ls flags
X]
X.I filename
X\&.\|.\|.
X.LP
X.B fls
X[
X.B unix ls flags
X]
X.I filename
X\&.\|.\|.
X.SH DESCRIPTION
X.LP
X.B flscmd
lists the content of the FSP database.  All usual
flags and usages for the unix
X.B ls
command are accepted.
X.LP
X.B flscmd
will perform
X.B csh
file name globbing based on file and directory information
obtained from the FSP database.
X.LP
Since user's command shells generally cannot do the proper globbing for
this program, it is recommended that user defines a shell alias or
fucntion to turns off command shell globbing before running this program.
X.B csh
example:
X.LP
X.nf
alias fls \e(set noglob\e; exec flscmd \e!\e*\e)
X.fi
X.SH ENVIRONMENT
X.LP
The following variables associate this program with a FSP database:
X.TP
X.B FSP_HOST
The name or internet number of the machine with the FSP server.
X.TP
X.B FSP_PORT
The port number of the UDP socket used by the FSP server.
X.TP
X.B FSP_LOCALPORT
The port number of the UDP socket used by FSP client utilities.
You may pick any number not currently used for other purposes.
The main reason of defining this number is to ensure mutual
exclusion between client utilities accessing the same FSP database.
X.TP
X.B FSP_DIR
The current working directory of the client in the FSP database.
The root of the database is /.
X.SH "SEE ALSO"
X.PD
fcatcmd(1), fcdcmd(1), fgetcmd(1), flscmd(1), fmkdir(1),
fprocmd(1), fput(1), frmcmd(1), frmdircmd(1), fver(1), fspd(1)
X.br
X.ne 5
X.SH BUGS
X.LP
X.B flscmd
is based on 4.3
X.B ls
code.  It inherits any bugs found in 4.3
X.B ls.
In addition, only four pieces of information for each file and directory
are available through FSP:
X.B name,
X.B time,
X.B size,
and
X.B type.
All other information that
X.B flscmd
display are for compatibility purposes only
and are forged locally.
END_OF_FILE
if test 1881 -ne `wc -c <'flscmd.1'`; then
    echo shar: \"'flscmd.1'\" unpacked with wrong size!
fi
# end of 'flscmd.1'
fi
if test -f 'flscmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flscmd.c'\"
else
echo shar: Extracting \"'flscmd.c'\" \(880 characters\)
sed "s/^X//" >'flscmd.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "client_def.h"
X
main(argc,argv,envp)
X    int argc;
X    char **argv,**envp;
X{
X    unsigned long pos;
X    RDIRENT **dp;
X
X    env_client();
X
X    fls_main(argc,argv,envp);
X
X    client_done();
X
X    exit(0);
X}
X
ls_bad(n)
X    int n;
X{
X    client_done();
X    exit(n);
X}
END_OF_FILE
if test 880 -ne `wc -c <'flscmd.c'`; then
    echo shar: \"'flscmd.c'\" unpacked with wrong size!
fi
# end of 'flscmd.c'
fi
if test -f 'fmkdir.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fmkdir.1'\"
else
echo shar: Extracting \"'fmkdir.1'\" \(1293 characters\)
sed "s/^X//" >'fmkdir.1' <<'END_OF_FILE'
X.TH FMKDIR 1 "8 December 1991"
X.SH NAME
fmkdir \- create directories in the FSP database
X.SH SYNOPSIS
X.B fmkdir
X.I name
X\&.\|.\|.
X.SH DESCRIPTION
X.LP
XFor each
X.I name
appearing in the argument list,
X.B fmkdir
creates a directory in the client's current working directory
in the FSP database.  The new directories are owned by the
client machine, and permission for other machines to create or
delete items in these directories are initially turned off.
The client may alter the permission states with the
X.B fprocmd
command.
X.SH ENVIRONMENT
X.LP
The following variables associate this program with a FSP database:
X.TP
X.B FSP_HOST
The name or internet number of the machine with the FSP server.
X.TP
X.B FSP_PORT
The port number of the UDP socket used by the FSP server.
X.TP
X.B FSP_LOCALPORT
The port number of the UDP socket used by FSP client utilities.
You may pick any number not currently used for other purposes.
The main reason of defining this number is to ensure mutual
exclusion between client utilities accessing the same FSP database.
X.TP
X.B FSP_DIR
The current working directory of the client in the FSP database.
The root of the database is /.
X.SH "SEE ALSO"
X.PD
fcatcmd(1), fcdcmd(1), fgetcmd(1), flscmd(1), fmkdir(1),
fprocmd(1), fput(1), frmcmd(1), frmdircmd(1), fver(1), fspd(1)
END_OF_FILE
if test 1293 -ne `wc -c <'fmkdir.1'`; then
    echo shar: \"'fmkdir.1'\" unpacked with wrong size!
fi
# end of 'fmkdir.1'
fi
if test -f 'fmkdir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fmkdir.c'\"
else
echo shar: Extracting \"'fmkdir.c'\" \(1186 characters\)
sed "s/^X//" >'fmkdir.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "client_def.h"
X
extern char **glob(), *util_abs_path();
X
main(argc,argv,envp)
X    int argc;
X    char **argv,**envp;
X{
X    char **av, *av2[2];
X
X    env_client();
X    while(*++argv) make_dir(*argv);
X    client_done();
X
X    exit(0);
X}
X
make_dir(p)
X    char *p;
X{
X    char *op;
X    UBUF *ub;
X
X    op = util_abs_path(p);
X
X    ub = client_interact(CC_MAKE_DIR,0L, strlen(op),op+1, 0,NULLP);
X
X    if(ub->cmd == CC_ERR)
X    {
X	fprintf(stderr,"Can't create %s: %s\n",p,ub->buf);
X	free(op); return(-1);
X    }
X
X    printf("%s\t: %s\n",p,ub->buf);
X
X    free(op);
X    return(0);
X}
END_OF_FILE
if test 1186 -ne `wc -c <'fmkdir.c'`; then
    echo shar: \"'fmkdir.c'\" unpacked with wrong size!
fi
# end of 'fmkdir.c'
fi
if test -f 'fprocmd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fprocmd.1'\"
else
echo shar: Extracting \"'fprocmd.1'\" \(1977 characters\)
sed "s/^X//" >'fprocmd.1' <<'END_OF_FILE'
X.TH FPRO 1 "8 December 1991"
X.SH NAME
fprocmd, fpro \- get or set permissions for directories in the FSP database
X.SH SYNOPSIS
X.B fprocmd
X[
X.B +c|-c|+d|-d
X]
X.I directory
X\&.\|.\|.
X.LP
X.B fpro
X[
X.B +c|-c|+d|-d
X]
X.I directory
X\&.\|.\|.
X.SH DESCRIPTION
X.LP
If no flags are specified, for each file named in the argument list,
X.B fprocmd
displays the current permission settings for each directory named.
If a flag is present (only one may be specified each time),
X.B fprocmd
will perform the following operations
and display the resulting settings for each named directory:
X.TP
X.B +c
Give others permission to create new items.
X.TP
X.B -c
Deny others permission to create new items.
X.TP
X.B +d
Give others permission to delete old items.
X.TP
X.B -d
Deny others permission to delete old items.
X.LP
X.B fprocmd
will perform
X.B csh
file name globbing based on file and directory information
obtained from the FSP database.
X.LP
Since user's command shells generally cannot do the proper globbing for
this program, it is recommended that user defines a shell alias or
fucntion to turns off command shell globbing before running this program.
X.B csh
example:
X.LP
X.nf
alias fpro \e(set noglob\e; exec fprocmd \e!\e*\e)
X.fi
X.SH ENVIRONMENT
X.LP
The following variables associate this program with a FSP database:
X.TP
X.B FSP_HOST
The name or internet number of the machine with the FSP server.
X.TP
X.B FSP_PORT
The port number of the UDP socket used by the FSP server.
X.TP
X.B FSP_LOCALPORT
The port number of the UDP socket used by FSP client utilities.
You may pick any number not currently used for other purposes.
The main reason of defining this number is to ensure mutual
exclusion between client utilities accessing the same FSP database.
X.TP
X.B FSP_DIR
The current working directory of the client in the FSP database.
The root of the database is /.
X.SH "SEE ALSO"
X.PD
fcatcmd(1), fcdcmd(1), fgetcmd(1), flscmd(1), fmkdir(1),
fprocmd(1), fput(1), frmcmd(1), frmdircmd(1), fver(1), fspd(1)
END_OF_FILE
if test 1977 -ne `wc -c <'fprocmd.1'`; then
    echo shar: \"'fprocmd.1'\" unpacked with wrong size!
fi
# end of 'fprocmd.1'
fi
if test -f 'fprocmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fprocmd.c'\"
else
echo shar: Extracting \"'fprocmd.c'\" \(1706 characters\)
sed "s/^X//" >'fprocmd.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "client_def.h"
X
extern char **glob(), *util_abs_path();
X
main(argc,argv,envp)
X    int argc;
X    char **argv,**envp;
X{
X    char **av, *av2[2], *key;
X
X    env_client();
X
X    if(argv[1]	&& (argv[1][0] == '+' || argv[1][0] == '-')
X		&& (argv[1][1] == 'c' || argv[1][1] == 'd'))
X    {
X        key = *++argv;
X
X	while(*++argv)
X	{
X	    if(!(av = glob(*argv))) { av = av2; av2[0] = *argv; av2[1] = 0; }
X	    while(*av) set_pro(*av++,key);
X	}
X
X    } else
X    {
X	if(argv[1]) while(*++argv)
X	{
X	    if(!(av = glob(*argv))) { av = av2; av2[0] = *argv; av2[1] = 0; }
X	    while(*av) print_pro(*av++);
X
X	} else print_pro(".");
X    }
X
X    client_done();
X
X    exit(0);
X}
X
print_pro(p)
X    char *p;
X{
X    char *op;
X    UBUF *ub;
X
X    op = util_abs_path(p);
X
X    ub = client_interact(CC_GET_PRO,0L, strlen(op),op+1, 0,NULLP);
X
X    printf("%s\t: %s\n",p,ub->buf);
X
X    return(0);
X}
X
set_pro(p,key)
X    char *p, *key;
X{
X    char *op;
X    UBUF *ub;
X
X    op = util_abs_path(p);
X
X    ub = client_interact(CC_SET_PRO,0L, strlen(op),op+1, strlen(key)+1,key);
X
X    printf("%s\t: %s\n",p,ub->buf);
X
X    return(0);
X}
END_OF_FILE
if test 1706 -ne `wc -c <'fprocmd.c'`; then
    echo shar: \"'fprocmd.c'\" unpacked with wrong size!
fi
# end of 'fprocmd.c'
fi
if test -f 'fput.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fput.1'\"
else
echo shar: Extracting \"'fput.1'\" \(1197 characters\)
sed "s/^X//" >'fput.1' <<'END_OF_FILE'
X.TH FPUT 1 "8 December 1991"
X.SH NAME
fput \- upload files to the FSP database
X.SH SYNOPSIS
X.B fput
X.I filename
X\&.\|.\|.
X.SH DESCRIPTION
X.LP
XFor each file named in the argument list,
X.B fput
copies the file from the client's current working directory in the
client machine to the FSP database.
X.SH ENVIRONMENT
X.LP
The following variables associate this program with a FSP database:
X.TP
X.B FSP_HOST
The name or internet number of the machine with the FSP server.
X.TP
X.B FSP_PORT
The port number of the UDP socket used by the FSP server.
X.TP
X.B FSP_LOCALPORT
The port number of the UDP socket used by FSP client utilities.
You may pick any number not currently used for other purposes.
The main reason of defining this number is to ensure mutual
exclusion between client utilities accessing the same FSP database.
X.TP
X.B FSP_DIR
The current working directory of the client in the FSP database.
The root of the database is /.
X.TP
X.B FSP_TRACE
If this variable is set,   
X.B fput
will display the number of kilo-byte blocks transfered as transfer 
progresses. 
X.SH "SEE ALSO"
X.PD
fcatcmd(1), fcdcmd(1), fgetcmd(1), flscmd(1), fmkdir(1),
fprocmd(1), fput(1), frmcmd(1), frmdircmd(1), fver(1), fspd(1)
END_OF_FILE
if test 1197 -ne `wc -c <'fput.1'`; then
    echo shar: \"'fput.1'\" unpacked with wrong size!
fi
# end of 'fput.1'
fi
if test -f 'fput.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fput.c'\"
else
echo shar: Extracting \"'fput.c'\" \(1212 characters\)
sed "s/^X//" >'fput.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "client_def.h"
X
main(argc,argv,envp)
X    int argc;
X    char **argv,**envp;
X{
X    env_client();
X    while(*++argv) put_file(*argv);
X    client_done();
X
X    exit(0);
X}
X
put_file(path)
X    char *path;
X{
X    struct stat sb;
X    char *name, *t2;
X    FILE *fp;
X
X    if(stat(path,&sb) != 0) { perror(path); return; }
X    if(!(S_IFREG & sb.st_mode)) { fprintf(stderr,"%s: not a file\n",path);
X				return; }
X
X    for(name = t2 = path; *t2; t2++) if(*t2 == '/') name = t2 + 1;
X
X    if(fp = fopen(path,"r"))
X    {
X	util_upload(name,fp);
X	fclose(fp);
X
X    } else fprintf(stderr,"Cannot read %s\n",path);
X}
END_OF_FILE
if test 1212 -ne `wc -c <'fput.c'`; then
    echo shar: \"'fput.c'\" unpacked with wrong size!
fi
# end of 'fput.c'
fi
if test -f 'frmcmd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'frmcmd.1'\"
else
echo shar: Extracting \"'frmcmd.1'\" \(1425 characters\)
sed "s/^X//" >'frmcmd.1' <<'END_OF_FILE'
X.TH FRM 1 "8 December 1991"
X.SH NAME
frmcmd, frm \- remove files from the FSP database
X.SH SYNOPSIS
X.B frmcmd
X.I filename
X\&.\|.\|.
X.LP
X.B frm
X.I filename
X\&.\|.\|.
X.SH DESCRIPTION
X.LP
X.B frmcmd
deletes the named files from the FSP database.
X.B frmcmd
will perform
X.B csh
file name globbing based on file and directory information
obtained from the FSP database.
X.LP
Since user's command shells generally cannot do the proper globbing for
this program, it is recommended that user defines a shell alias or
fucntion to turns off command shell globbing before running this program.
X.B csh
example:
X.LP
X.nf
alias frm \e(set noglob\e; exec frmcmd \e!\e*\e)
X.fi
X.SH ENVIRONMENT
X.LP
The following variables associate this program with a FSP database:
X.TP
X.B FSP_HOST
The name or internet number of the machine with the FSP server.
X.TP
X.B FSP_PORT
The port number of the UDP socket used by the FSP server.
X.TP
X.B FSP_LOCALPORT
The port number of the UDP socket used by FSP client utilities.
You may pick any number not currently used for other purposes.
The main reason of defining this number is to ensure mutual
exclusion between client utilities accessing the same FSP database.
X.TP
X.B FSP_DIR
The current working directory of the client in the FSP database.
The root of the database is /.
X.SH "SEE ALSO"
X.PD
fcatcmd(1), fcdcmd(1), fgetcmd(1), flscmd(1), fmkdir(1),
fprocmd(1), fput(1), frmcmd(1), frmdircmd(1), fver(1), fspd(1)
END_OF_FILE
if test 1425 -ne `wc -c <'frmcmd.1'`; then
    echo shar: \"'frmcmd.1'\" unpacked with wrong size!
fi
# end of 'frmcmd.1'
fi
if test -f 'frmcmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'frmcmd.c'\"
else
echo shar: Extracting \"'frmcmd.c'\" \(1230 characters\)
sed "s/^X//" >'frmcmd.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "client_def.h"
X
extern char **glob(), *util_abs_path();
X
main(argc,argv,envp)
X    int argc;
X    char **argv,**envp;
X{
X    char **av, *av2[2];
X
X    env_client();
X
X    while(*++argv)
X    {
X	if(!(av = glob(*argv))) { av = av2; av2[0] = *argv; av2[1] = 0; }
X	while(*av) remove_it(*av++);
X    }
X
X    client_done();
X
X    exit(0);
X}
X
remove_it(p)
X    char *p;
X{
X    char *op;
X    UBUF *ub;
X
X    op = util_abs_path(p);
X
X    ub = client_interact(CC_DEL_FILE,0L, strlen(op),op+1, 0,NULLP);
X
X    if(ub->cmd == CC_ERR)
X    {
X	fprintf(stderr,"Can't remove %s: %s\n",p,ub->buf);
X	free(op); return(-1);
X    }
X
X    return(0);
X}
END_OF_FILE
if test 1230 -ne `wc -c <'frmcmd.c'`; then
    echo shar: \"'frmcmd.c'\" unpacked with wrong size!
fi
# end of 'frmcmd.c'
fi
if test -f 'frmdircmd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'frmdircmd.1'\"
else
echo shar: Extracting \"'frmdircmd.1'\" \(1466 characters\)
sed "s/^X//" >'frmdircmd.1' <<'END_OF_FILE'
X.TH FRMDIR 1 "8 December 1991"
X.SH NAME
frmdircmd, frmdir \- remove directories from the FSP database
X.SH SYNOPSIS
X.B frmdircmd
X.I directory
X\&.\|.\|.
X.LP
X.B frmdir
X.I directory
X\&.\|.\|.
X.SH DESCRIPTION
X.LP
X.B frmdircmd
deletes the named directories from the FSP database.
X.B frmdircmd
will perform
X.B csh
file name globbing based on file and directory information
obtained from the FSP database.
X.LP
Since user's command shells generally cannot do the proper globbing for
this program, it is recommended that user defines a shell alias or
fucntion to turns off command shell globbing before running this program.
X.B csh
example:
X.LP
X.nf
alias frmdir \e(set noglob\e; exec frmdircmd \e!\e*\e)
X.fi
X.SH ENVIRONMENT
X.LP
The following variables associate this program with a FSP database:
X.TP
X.B FSP_HOST
The name or internet number of the machine with the FSP server.
X.TP
X.B FSP_PORT
The port number of the UDP socket used by the FSP server.
X.TP
X.B FSP_LOCALPORT
The port number of the UDP socket used by FSP client utilities.
You may pick any number not currently used for other purposes.
The main reason of defining this number is to ensure mutual
exclusion between client utilities accessing the same FSP database.
X.TP
X.B FSP_DIR
The current working directory of the client in the FSP database.
The root of the database is /.
X.SH "SEE ALSO"
X.PD
fcatcmd(1), fcdcmd(1), fgetcmd(1), flscmd(1), fmkdir(1),
fprocmd(1), fput(1), frmcmd(1), frmdircmd(1), fver(1), fspd(1)
END_OF_FILE
if test 1466 -ne `wc -c <'frmdircmd.1'`; then
    echo shar: \"'frmdircmd.1'\" unpacked with wrong size!
fi
# end of 'frmdircmd.1'
fi
if test -f 'frmdircmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'frmdircmd.c'\"
else
echo shar: Extracting \"'frmdircmd.c'\" \(1229 characters\)
sed "s/^X//" >'frmdircmd.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "client_def.h"
X
extern char **glob(), *util_abs_path();
X
main(argc,argv,envp)
X    int argc;
X    char **argv,**envp;
X{
X    char **av, *av2[2];
X
X    env_client();
X
X    while(*++argv)
X    {
X	if(!(av = glob(*argv))) { av = av2; av2[0] = *argv; av2[1] = 0; }
X	while(*av) remove_it(*av++);
X    }
X
X    client_done();
X
X    exit(0);
X}
X
remove_it(p)
X    char *p;
X{
X    char *op;
X    UBUF *ub;
X
X    op = util_abs_path(p);
X
X    ub = client_interact(CC_DEL_DIR,0L, strlen(op),op+1, 0,NULLP);
X
X    if(ub->cmd == CC_ERR)
X    {
X	fprintf(stderr,"Can't remove %s: %s\n",p,ub->buf);
X	free(op); return(-1);
X    }
X
X    return(0);
X}
END_OF_FILE
if test 1229 -ne `wc -c <'frmdircmd.c'`; then
    echo shar: \"'frmdircmd.c'\" unpacked with wrong size!
fi
# end of 'frmdircmd.c'
fi
if test -f 'fspd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fspd.1'\"
else
echo shar: Extracting \"'fspd.1'\" \(1610 characters\)
sed "s/^X//" >'fspd.1' <<'END_OF_FILE'
X.TH FSPD 1 "8 December 1991"
X.SH NAME
fspd, in.fspd \- server for the FSP database
X.SH SYNOPSIS
X.B fspd
X[
X.B -h path
X.B |
X.B -p port
X.B |
X.B -u uid
X]
X.LP
X.B in.fspd
X.SH DESCRIPTION
X.B fspd
is the server for an anonymous-ftp style archive called FSP. The main
features of this service are: connection-less model, communication
robustness, server resource protection, inter-client protection, and user
friendly interface. Please read the INFO file bundled with the FSP source
for more information. 
X.LP
X.SH FILES
X.PD 0
X.TP 20
X.B .OWN.XXXXXXXX
Used to indicate the ownership of a directory.  If this file is
present in a directory, the directory is owned by the machine whose
inet number is XXXXXXXX when printed as an 8-digit hex number.
X
X.TP
X.B .FSP_NO_DEL
XExistence of this file in a directory prevents non-owner machines
from deleting items from this directory.
X
X.TP
X.B .FSP_NO_ADD
XExistence of this file in a directory prevents non-owner machines
from adding items to this directory.
X
X.TP
X.B .TMP.XXXXXXXX
Transient temporary file in the top FSP directory used for file
uploading.
X
X.TP
X.B .HTAB_DUMP
A file created in the top directory when
X.B fspd
receives an alarm signal.  It contains a listing of the active
clients in
X.B fspd's
client table.
X
X.TP
X.B .ROGUE_HOSTS
A file containing a list of inet numbers in the normal 4-part format.
X.B fspd
will not respond to messages from machines named in this file.
X
X.TP
X.B .FSP_CONTENT
XFile used to cache directory listing.
X
X.SH "SEE ALSO"
X.PD
fcatcmd(1), fcdcmd(1), fgetcmd(1), flscmd(1), fmkdir(1),
fprocmd(1), fput(1), frmcmd(1), frmdircmd(1), fver(1), fspd(1)
END_OF_FILE
if test 1610 -ne `wc -c <'fspd.1'`; then
    echo shar: \"'fspd.1'\" unpacked with wrong size!
fi
# end of 'fspd.1'
fi
if test -f 'fver.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fver.1'\"
else
echo shar: Extracting \"'fver.1'\" \(974 characters\)
sed "s/^X//" >'fver.1' <<'END_OF_FILE'
X.TH FVER 1 "8 December 1991"
X.SH NAME
fver \- displays the version number string of the FSP database
X.SH SYNOPSIS
X.B fver
X.SH DESCRIPTION
X.LP
X.B fver
displays the version number string of the FSP database.
X.SH ENVIRONMENT
X.LP
The following variables associate this program with a FSP database:
X.TP
X.B FSP_HOST
The name or internet number of the machine with the FSP server.
X.TP
X.B FSP_PORT
The port number of the UDP socket used by the FSP server.
X.TP
X.B FSP_LOCALPORT
The port number of the UDP socket used by FSP client utilities.
You may pick any number not currently used for other purposes.
The main reason of defining this number is to ensure mutual
exclusion between client utilities accessing the same FSP database.
X.TP
X.B FSP_DIR
The current working directory of the client in the FSP database.
The root of the database is /.
X.SH "SEE ALSO"
X.PD
fcatcmd(1), fcdcmd(1), fgetcmd(1), flscmd(1), fmkdir(1),
fprocmd(1), fput(1), frmcmd(1), frmdircmd(1), fver(1), fspd(1)
END_OF_FILE
if test 974 -ne `wc -c <'fver.1'`; then
    echo shar: \"'fver.1'\" unpacked with wrong size!
fi
# end of 'fver.1'
fi
if test -f 'fver.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fver.c'\"
else
echo shar: Extracting \"'fver.c'\" \(830 characters\)
sed "s/^X//" >'fver.c' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include <stdio.h>
X#include "client_def.h"
X
main()
X{
X    UBUF *ub;
X
X    env_client();
X    ub = client_interact(CC_VERSION,0L, 0,NULLP, 0,NULLP);
X    printf("FSP version: %s\n",ub->buf);
X    client_done();
X
X    exit(0);
X}
END_OF_FILE
if test 830 -ne `wc -c <'fver.c'`; then
    echo shar: \"'fver.c'\" unpacked with wrong size!
fi
# end of 'fver.c'
fi
if test -f 'server_def.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server_def.h'\"
else
echo shar: Extracting \"'server_def.h'\" \(1801 characters\)
sed "s/^X//" >'server_def.h' <<'END_OF_FILE'
X    /*********************************************************************\
X    *  Copyright (c) 1991 by Wen-King Su (wen-king@vlsi.cs.caltech.edu)   *
X    *                                                                     *
X    *  You may copy or modify this file in any manner you wish, provided  *
X    *  that this notice is always included, and that you hold the author  *
X    *  harmless for any loss or damage resulting from the installation or *
X    *  use of this software.                                              *
X    \*********************************************************************/
X
X#include "common_def.h"
X
X/****************************************************************************
X*  HTAB is structure for storing client information for one client machine.
X*  They makes it easy to reuse regular unix tool's source for new purposes.
X****************************************************************************/
X
typedef struct HTAB HTAB;
X
struct HTAB {	unsigned long	inet_num;	/* inet number of client     */
X		unsigned long   last_acc;	/* last sucessful access time*/
X		unsigned short	next_key;	/* next key client should use*/
X		unsigned short	last_key;	/* previous key client used  */
X		unsigned short   acc_cnt;	/* number of successful acc  */
X		unsigned short  active:1;   	/* session continuing.	     */
X		unsigned short inhibit:1; };	/* deny access permission.   */
X
extern init_htab();
extern HTAB *find_host();
extern char *check_path();
X
extern char *server_make_dir();
extern char *server_del_dir();
extern char *server_del_file();
extern char *server_get_dir();
extern char *server_get_file();
extern char *server_get_pro();
extern char *server_set_pro();
extern char *server_up_load();
extern char *server_install();
X
extern int dbug;
extern char *home_dir;
END_OF_FILE
if test 1801 -ne `wc -c <'server_def.h'`; then
    echo shar: \"'server_def.h'\" unpacked with wrong size!
fi
# end of 'server_def.h'
fi
if test -f 'setup' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'setup'\"
else
echo shar: Extracting \"'setup'\" \(626 characters\)
sed "s/^X//" >'setup' <<'END_OF_FILE'
X
X# Sample csh initialization file.
X
setenv FSP_PORT 21
setenv FSP_LOCALPORT 4334
setenv FSP_HOST 131.215.131.97
setenv FSP_DIR  /
setenv FSP_TRACE
X
alias fcd setenv FSP_DIR \`\(set noglob\; exec fcdcmd \!\*\)\`
alias fls    \(set noglob\; exec flscmd    \!\*\)
alias fget   \(set noglob\; exec fgetcmd   \!\*\)
alias fcat   \(set noglob\; exec fcatcmd   \!\*\)
alias fmore  \(set noglob\; exec fcatcmd   \!\* \| less \)
alias frm    \(set noglob\; exec frmcmd    \!\*\)
alias frmdir \(set noglob\; exec frmdircmd \!\*\)
alias fpro   \(set noglob\; exec fprocmd   \!\*\)
alias fpwd echo \$FSP_DIR on \$FSP_HOST port \$FSP_PORT
END_OF_FILE
if test 626 -ne `wc -c <'setup'`; then
    echo shar: \"'setup'\" unpacked with wrong size!
fi
# end of 'setup'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
