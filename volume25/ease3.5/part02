Subject:  v25i018:  Ease 3.5 - high-level sendmail.cf language, Part02/06
Newsgroups: comp.sources.unix
Approved: vixie@pa.dec.com

Submitted-by: Bruce G. Barnett <barnett@crdgw1.ge.com>
Posting-number: Volume 25, Issue 18
Archive-name: ease3.5/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 6)."
# Contents:  CONVERTING Makefile doc/cfc.man src/Makefile src/ease.sh
#   src/errors.c src/idman.c src/lexan.patch src/symtab.c test/test.mc
# Wrapped by vixie@cognition.pa.dec.com on Tue Dec 10 08:45:56 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'CONVERTING' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CONVERTING'\"
else
echo shar: Extracting \"'CONVERTING'\" \(5098 characters\)
sed "s/^X//" >'CONVERTING' <<'END_OF_FILE'
X=====================================================================
X	Converting a sendmail file into ease
X
X
Step 1.  Use cfc to convert the sendmail file into ease.
X	You may want to use "make convert" in the top Makefile
X
X	As a start, use the following arguments to cfc 
X
X	SunOS 4.0, /usr/lib/sendmail.subsidiary.cf
X		=> cfc -s -C V < /usr/lib/sendmail.subsidiary.cf>sendmail.ease
X
X	SunOS 4.0, /usr/lib/sendmail.main.cf
X
X		=> cfc -s < /usr/lib/sendmail.main.cf>sendmail.ease
X
X
X	Ultrix 3.0: 
X
X		=> cfc -d -C SDIZFN </etc/sendmail.cf >sendmail.ease
X
X	IDA sendmail
X
X		=> cfc -i
X
X	4.2 sendmail
X
X		=> cfc -c
X
X	4.3 sendmail
X
X		=> cdc -u
X
X	HP/UX
X		=> cfc -i -CGUS
X
X	A/UX
X		=> cfc -i -CUNI
X
X	CGI IRIS
X		=> cfc -i -C FKSVN  
X
X	smail
X
X		=> cfc -C DUET
X
Step 2.  Convert the ease file to cf: 
X
X	% et <sendmail.ease >sendmail.cf
X
X	Look at the errors and warnings.
X
X	Most of these errors can be eliminated by using the right
X	flags on cfc. Make sure that you specify all of the
X	classes (using the -C flag ) that you need, which generate
X	the matching field definitions for any_in_? fields.
X	Then repeat the cf-> ease translation with the necessary
X	-C XYZ flags.
X
X	The remaining errors are either warnings or mistakes
X	in the translation. 
X	Let's look at some examples:
X
X		line 1598: Warning: Ruleset not defined: RULESET_12
X
X	This says there is a line that has
X		RULESET_12 = ruleset 12;
X
X	Comment it out if you wish.
X
X
X	case 2)
X
X		line 1598: Warning: Macro not defined: Y
X	or
X		line 1598: Warning: Class not defined: Y
X
X	This is just a warning and is probably okay. There may be a rule that 
X	does different actions if the macro is set or not. Example:
X
X	if ( one_or_more )	/* add local domain */
X		next (concat ("$1<@",ifset (Y, "${Y}", "${m_sitename}"))>);
X
X	If this bothers you, rewrite to rule to not need the Y macro:
X
X	if ( one_or_more )	/* add local domain */
X		next ("$1<@${m_sitename}"))>);
X
X	Do not define them, even to define them to be nothing!
X	An empty string is still defined, and may break your sendmail rules.
X
X	case 3)
X
X		line 88 near ";": Warning: Appending to previously defined class T.
X	This is okay. Sendmail allows you to define a class over several lines.
X	combine them into one line if you wish.
X
X	case 4)
X
X	line 1485: Warning: Mailer not defined: ERROR
X
X	Ease treats upper and lower case letters as different.
X	Sendmail does not. Change the case to be consistent
X
X	case 5)
X
X	warning: Unknown option 'M' on line 387
X	
X	cfc found an unusual option. It tries to convert it into
X		an asm("...') string.
X
X
X	.....
X	So look at the warnings and errors, and repeat step 1 until you 
X	feel comfortable with the change.
X
X	If you can't get cfc/ease to accept the new syntax, use the
X	asm(" ") construct to work around it and report the bugs.
X
Step 3. Verify the ease output matches the original sendmail
X
X	You can use  "make test_conversion" it you wish
X
X	At this point, you should verify that the ease output is identical to
X	the original sendmail.cf file. Use the script cfdiff to
X	compare the original sendmail.cf file with the ease output file.
X
X	That is, if your original sendmail file is /etc/sendmail.cf,
X	and the new one is ./sendmail.cf, do a
X
X	 set path = ( $cwd/bin $path );rehash;cfdiff /etc/sendmail.cf ./sendmail.cf
X
X	You may see some differences. Examples:
X
X	< Odbackground
X	---
X	> Odb
X
X	Okay: ease outputs the full name instead of the abbreviation
X
X	< Muucp,	P=/usr/bin/uux, F=sDFhuU, S=13, R=23, M=100000,
X	< 	A=uux - $h!rmail ($u)
X	---
X	> Muucp, P=/usr/bin/uux, F=sDFhuU, S=13, R=23, M=100000, A=uux - $h!rmail ($u)
X
X	Okay: this is on two lines instead of one.
X
X	< CTuucp UUCP arpa ARPA bitnet BITNET csnet CSNET mailnet MAILNET decnet DECNET rscs RSCS
X	---
X	> CTuucp UUCP arpa ARPA bitnet BITNET csnet CSNET mailnet
X	> CTMAILNET decnet DECNET rscs RSCS
X	
X	OKAY: this is just a different number of lines.
X
X
X	Differences in the spaces in the rules)
X	The syntax of sendmail specifies that there are tabs between the 
X	left hand side and the right hand side, and a tab between the right 
X	hand side and the comments.
X
X	Any spaces in the middle of the rules are cosmetic. Ignore differences.
X
X	If there is any other difference, 
X	please send me a bug report, and see if you can make changes to your
X	ease input file to match the original file. You may need the asm("")
X	command.
X
X	If your diff program has the -w option, you can ignore spaces in the
X	cf files. Occasionally ease inserts some extra spaces. Or the
X	original sendmail file has extra spaces. (e.g. SunOS).
X	See the script cfdiff.
X
Step 4. Once you have the ease file in good form, put it under sccs
X	control, and put the version number (%W% in the V macro
X	definition, so the "Received-by" header line reflects the revision.)
X
You are now ready to debug your sendmail file.
See the file TESTING
X============================================================================
X
If you find these programs useful, or if you have suggestions or changes,
please drop me a line.
X
X	Bruce Barnett
X	General Electric
X	Corporate Research and Development
X	P. O. Box 8, 1 River Road
X	Schenectady, NY 12302
X
X	barnett@crdgw1.ge.com
END_OF_FILE
if test 5098 -ne `wc -c <'CONVERTING'`; then
    echo shar: \"'CONVERTING'\" unpacked with wrong size!
fi
# end of 'CONVERTING'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(3046 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#	$Header: /home/kreskin/u0/barnett/Src/Ease/ease/RCS/Makefile,v 3.4 1991/10/15 17:37:27 barnett Exp $
X#
X#	$Log: Makefile,v $
X# Revision 3.4  1991/10/15  17:37:27  barnett
X# Changed 'make shar'
X#
X# Revision 3.3  1991/09/09  16:41:11  barnett
X# added '-' to /bin/rm in "make all"
X#
X# Revision 3.2  1991/05/16  10:51:13  barnett
X# Fixed a few typos and added the MAKE variable
X#
X# Revision 1.2  1991/02/25  22:07:29  barnett
X# Added RCS header, amd specified value for MAKE variable
X#
X# Revision 1.1  1991/02/25  14:37:28  barnett
X# Initial revision - release to net
X#
X#
X# where do you want to place the binaries and scripts?
X# the programs are: et cfc cfdiff cfstrip
BINDIR=`pwd`/bin
X
X#where is your original sendmail file?
X#ORIGINAL=/etc/sendmail.cf
ORIGINAL=/usr/lib/sendmail.cf
X#ORIGINAL=/usr/lib/sendmail.main.cf
X#ORIGINAL=/usr/lib/sendmail.subsidiary.cf
X
X# What arguments to cfc do you want for cfc (see the file CONVERTING)
X# IDA
X#CONVERT_FLAGS=-i
X#SunOS Subsidiary
CONVERT_FLAGS=-s -CV
X
X#what extenstion do you want for the manual pages?
X#EXT=1
X#EXT=l
XEXT=n
SHELL=/bin/sh
MAKE=make
X
all:
X	cd cfc; ${MAKE} ${FLAGS}  $@
X	cd src; ${MAKE} ${FLAGS}  $@
X	cd utils; ${MAKE} ${FLAGS}  $@
X	touch all
X	
install:
X	test -d ${BINDIR} || mkdir ${BINDIR}
X#	cd cf; make $(MFLAGS) $@
X	BD=${BINDIR};cd cfc; ${MAKE} ${MFLAGS} BINDIR=$$BD $@
X	BD=${BINDIR};cd src; ${MAKE} ${MFLAGS} BINDIR=$$BD $@
X	BD=${BINDIR};cd utils; ${MAKE} ${MFLAGS} BINDIR=$$BD $@
X	cd doc; ${MAKE} ${MFLAGS} EXT=${EXT} $@
X
X
X
convert:	${ORIGINAL} all 
X		${BINDIR}/cfc ${CONVERT_FLAGS} < ${ORIGINAL} >sendmail.ease
X
test_conversion:	${ORIGINAL} sendmail.cf
X	PATH=${BINDIR}:$$PATH;export PATH;cfdiff ${ORIGINAL} sendmail.cf
X
clean:
X#	cd cf; make $(MFLAGS) $@
X	cd src; ${MAKE} ${MFLAGS} $@
X	cd cfc; ${MAKE} ${MFLAGS} $@
X	cd utils; ${MAKE} ${MFLAGS} $@
X	-/bin/rm all
X
X
debug:	all sendmail.ease
X	BD=${BINDIR};cd debug; ${MAKE} ${MFLAGS} BINDIR=$$BD $@
sendmail.ease:
X	@ echo where is the sendmail.ease file you want to debug?	
X
sendmail.cf: all sendmail.ease
X	${BINDIR}/et <sendmail.ease >sendmail.cf
X
hostname.ease: SCCS/s.hostname.ease
X	sccs get hostname.ease
X
hostname.cf:	hostname.ease
X	et -C <hostname.ease >hostname.cf
X
install_hostname: hostname.cf
X	@sccs check
X	/bin/mv ${ORIGINAL} ${ORIGINAL}.old
X	/bin/cp hostname.cf ${ORIGINAL}
X	build-new-aliases
X
mail: Part01 Part02 Part03 Part04 Part05 Part06
X	@ WHO=${WHO} && \
X	[ $${WHO:-missing} = missing ] && \
X	echo USAGE:  make mail WHO=address || \
X	(( mail -s "Ease 3.0: Part 1 of 6" $${WHO} <Part01) ;\
X	 ( mail -s "Ease 3.0: Part 2 of 6" $${WHO} <Part02) ;\
X	 ( mail -s "Ease 3.0: Part 3 of 6" $${WHO} <Part03) ;\
X	 ( mail -s "Ease 3.0: Part 4 of 6" $${WHO} <Part04) ;\
X	 ( mail -s "Ease 3.0: Part 5 of 6" $${WHO} <Part05) ;\
X	 ( mail -s "Ease 3.0: Part 6 of 6" $${WHO} <Part06; ))
X
depend lint print:
X	-for dir in *; do [ -f $$dir/[Mm]akefile ] && (cd $$dir; make $(MFLAGS) $@); done
X
shar:
X	dirname=`basename $$PWD`; cd ..; shar `find $$dirname -name RCS -prune -o -name GE -prune -o -type f -print|egrep -v '~|#' ` >/tmp/ease.shar
X
END_OF_FILE
if test 3046 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'doc/cfc.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/cfc.man'\"
else
echo shar: Extracting \"'doc/cfc.man'\" \(5783 characters\)
sed "s/^X//" >'doc/cfc.man' <<'END_OF_FILE'
X...
X... $Header: /tmp_mnt/home/kreskin/u0/barnett/Src/Ease/ease/doc/RCS/cfc.man,v 3.3 1991/09/09 16:36:05 barnett Exp $
X... 
X... $Log: cfc.man,v $
X... Revision 3.3  1991/09/09  16:36:05  barnett
X... minor bug fixes
X...
X... Revision 1.2  1990/04/04  15:42:51  jeff
X... Reformatted somewhat for readability.  Added some bugs
X... described by Bruce Barnett.
X...
X... Version 1.1  90/04/04  14:57:38  jeff
X... Initial version
X... 
X... Revision 2.0  88/06/15  15:17:36  arnold
X... Baseline release for net posting. ADR.
X... 
X... Revision 1.3  88/01/21  16:23:21  arnold
X... Some typo fixes.
X... 
X... Revision 1.2  87/04/08  10:21:47  arnold
X... Small bug fixes, compatibility option added, also warnings for
X... unrecognized flags and options. ADR.
X... 
X... Revision 1.1  87/02/16  15:25:32  arnold
X... Initial revision
X... 
X...
X.TH CFC local
X.SH NAME
cfc \- Sendmail cf file compiler
X.SH SYNOPSIS
X.B cfc
X[
X.B \-s
X] [
X.B \-i
X] [
X.B \-d
X] [
X.B \-c
X] [
X.B \-u
X] [
X.B \-C \fICLASSES\fP
X] <
X.I sendmail.cf-file
X>
X.I ease-source-file
X.SH DESCRIPTION
X.I Cfc
is a filter that reads a raw
X.IR sendmail (8)
configuration file on its standard input, and produces almost useable
X.IR ease (1)
source on its standard output.
X.P
It is designed as a conversion tool, to translate an existing
X.B sendmail.cf
file into
X.I ease
with the idea that all future work will be done in
X.IR ease .
X.P
X.I Cfc
passes all comments through to the output, and converts all predefined
X.I sendmail
macros, options, option values, and mailer flags into the names used by
X.IR ease .
X.P
It is suggested you use
X.I cfc
to convert a 
X.I sendmail.cf
file into 
X.I ease
format, and then convert the
X.I ease
file back into
X.I sendmail
format.
You may have to experiment with the right options and the right combinations
before
X.I ease
will generate an output file with no errors.
Then use the
X.I cfdiff
script to compare the original
X.I sendmail.cf
file to the output of
X.IR ease .
You should see some differences in formatting, as some 
X.I sendmail
lines can be on one or two lines, and some options have more than one form.
Once it is determined that these are the only difference, you should feel
very comfortable using 
X.I ease
as a high level langauge for 
X.I sendmail 
files.
If you are unable to make the two files identical, you may need to modify the 
X.I ease
input file so the output is correct.
If necessary, you can use the
X.IR asm ()
function in
X.I ease
to pass the characters, unchanged, to the output.
X.P
X.I Cfc
isn't perfect. 
You may wish to modify the 
X.I ease
file for cosmetic reasons:
X.IP
X.I Cfc
introduces tabs on its own, as well as often passing through tabs
from the
X.I sendmail
input.
It will also print a header for each different type of line, e.g. if the
input had seven
X.B O
X(option) lines, there will be seven option blocks.
These are usually succesive, and can therefore be merged.
X.IP
Move some comments.
The block close on rulesets often comes after the comments that
precede the next ruleset or mailer specification.
X
X.RE
X.P
In short,
X.I cfc
does over 99% of the tedious work of translating a
X.B sendmail.cf
into
X.I ease
format.
Suprisingly, the combination of
X.I cfc
and
X.I ease
can find bugs in a current
X.B sendmail.cf
file!
X.P
X.I Cfc
takes five options.
X.RS
X.TP
X.B \-c
Indicates that
X.I cfc
should run in 4.2BSD compatibility mode.
In this case, options and mailer flags which are new in the 4.3BSD
version of
X.I sendmail
will not be recognized.
X.TP
X.B \-u
X.I Cfc
will warn about the use of any undocumented options or mailer flags in
the 4.3BSD
X.IR sendmail .
The correct
X.I ease
output will still be produced.
X.TP
X.B \-s
X.I Cfc
will assume the input file is for Sun's sendmail.
It will produce a ruleset definition for rule number 30, which Sun uses
in their standard configuration file, and older implementations
complain about. It also adds some declarations that match Sun's
additions to sendmail, so errors won't occur.
X.TP
X.B \-d
X.I Cfc
will cause some definitions to be added that will convert the Ultrix
X.i sendmail.cf
file with fewer errors.
X.TP
X.B \-i
X.I Cfc
will add some declarations that the IDA version of 
X.I sendmail
likes to see.
X.TP
X.B \-C
X<LETTER><LETTER>...
X.I Cfc
will add an additional header of the form
X.I any_in_<LETTER>
and
X.I any_not_in_<LETTER>
where
X.I <LETTER>
is a single character that specifes a class used in the sendmail file,
but not defined.
This prevents 
X.I ease
from complaining about undefined classes.
X.RE
X.P
With the right compination of options and class definitions, it is
easy to convert a 
X.I sendmail
file into 
X.I ease ,
edit the file, and run 
X.I ease
on the file, and install the output.
X.\" .SH FILES
X.SH SEE ALSO
X.I "Sendmail Installation and Operation Guide"
by Eric Allman
X(SMM:7 in the 4.3 BSD UNIX System Manager's Manual),
X.I "Ease: A Configuration Language for Sendmail"
by James S. Schoner, amended by Jeff P. Stearns, Arnold D. Robbins, and Bruce G. Barnett.
X.IR sendmail (8),
X.IR ease (1).
X.SH DIAGNOSTICS
X``\c
X.IR Routine :
malformed input line
X.IR line :
fatal error''
for input it doesn't understand.
X.I Routine
is the name of the routine in
X.I cfc
which choked, and
X.I line
is the line number in the input.
X.SH BUGS
Only recognizes continuation lines (lines that begin with a \s-1TAB\s+1)
for header (H) and mailer (M) definitions.
X.P
Should read from files on the command line, instead of being a pure filter.
X.P
Should be a two pass program, and learn the classes which need
defining automatically. The
X.B \-C
option is really a kludge.
X.PP
In some cases, you can use the
X\fIasm(".......")\fP
command to work around problems.
X.SH AUTHOR
X.nf
Arnold Robbins
XEmory University Computing Center
arnold@emory.edu
X
Modifications by Bruce G. Barnett
General Electric, Corporate Research and Development
barnett@crdgw1.ge.com
X
X.fi
END_OF_FILE
if test 5783 -ne `wc -c <'doc/cfc.man'`; then
    echo shar: \"'doc/cfc.man'\" unpacked with wrong size!
fi
# end of 'doc/cfc.man'
fi
if test -f 'src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile'\"
else
echo shar: Extracting \"'src/Makefile'\" \(4585 characters\)
sed "s/^X//" >'src/Makefile' <<'END_OF_FILE'
X# Makefile for Ease Translator (et).
X#
X#	$Header: /tmp_mnt/home/kreskin/u0/barnett/Src/Ease/ease/src/RCS/Makefile,v 3.3 1991/09/09 16:33:23 barnett Exp $
X#
X#	$Log: Makefile,v $
X# Revision 3.3  1991/09/09  16:33:23  barnett
X# Minor bug fix release
X#
X# Revision 3.2  1991/05/16  10:45:25  barnett
X# Better support for System V machines
X# Support for machines with read only text segments
X#
X# Revision 3.1  1991/02/25  22:09:52  barnett
X# Fixed some portability problems
X#
X# Revision 2.1  1990/01/30  13:54:13  jeff
X# Updated for release 2.1 Aplha.
X#
X# Revision 2.0  88/06/15  14:47:35  root
X# Baseline release for net posting. ADR.
X# 
X#
X#	James S. Schoner, Purdue University Computing Center,
X#			  West Lafayette, Indiana  47907
X#
X#	Copyright (c) 1985 by Purdue Research Foundation
X#
X#	All rights reserved.
X#
X
INCLUDE =
X
X# where to install the binaries
BINDIR          =	../bin
X
OWNER = root
GROUP = staff
MODE = 755
X# Important Compile flags are defined here
X# DATA_RW - this is defined if your system allows string constants to 
X#           be modifiable. If you have one of the following systems, I am told
X#	    you should NOT define it: (Thanks to rainer@flyer.uni-duisburg.de)
X#	         - A sun 3/60 using gcc
X#		 - A esix SysV PC  with gcc
X#                - A HP9000/845 with cc
X#		 - Apollo/Domain with BSD4.3 environment
X#           The default is to define it, because this is what earlier versions 
X#           of Ease did.
X#
X# SYSV
X# 		If you have a system V machine, and have <string.h>
X#		instead of <strings.h>, then define this
X#
X#OFLAGS=-DSYSV 
OFLAGS=-DDATA_RW
X 
DEFS = ${OFLAGS}
LIBS = -ll
X# some people must remove the -O
CFLAGS = -O ${DEFS} ${INCLUDE}
CC = cc
X#CC = gcc
YACC = yacc 
X#YACC = bison -y
X
LP = lpr
LPFLAGS = -J"Ease Source"
X
X
X# System V install different from BSD install sigh...
X#INSTALL = install -c -m ${MODE} -o ${OWNER} -g ${GROUP}
INSTALL=cp
X
X# Special Debug flags
X# select this one to debug the grammar
X#DEFS =-DYYDEBUG
X# The following two lines are used with the SunOS malloc() debug package.
X#DEFS = -DMALLOC_DEBUG	#  Part of the SunOS malloc package
X#LIBS = /usr/lib/debug/malloc.o -ll
CFLAGS = -g  ${DEFS} ${INCLUDE}
X
X
HDR = symtab.h
SRC = main.c emitcf.c errors.c idman.c strops.c symtab.c fixstrings.c
LST = Makefile lexan.l parser.y ${HDR} ${SRC}
DEP = parser.c lexan.c ${SRC}
OBJ = parser.o lexan.o main.o emitcf.o errors.o idman.o strops.o symtab.o \
X	fixstrings.o
CFILES= $(SRC) $(DEP)
X
all: et
X
et: ${OBJ}
X	${CC} ${CFLAGS} -o et ${OBJ} ${LIBS}
X
clean: FRC
X	rm -f et *.o lexan.c parser.c y.output yacc.acts yacc.tmp \
X	      lexdefs.h y.tab.h errs Makefile.bak y.output y.tab.c y.tok.h
X
depend:
X	${CC} -M ${CFLAGS} ${CFILES} | \
X	sed -e ':loop' \
X	    -e 's/\.\.\/[^ /]*\/\.\./../' \
X	    -e 't loop' | \
X	awk ' { if ($$1 != prev) { print rec; rec = $$0; prev = $$1; } \
X		else { if (length(rec $$2) > 78) { print rec; rec = $$0; } \
X		       else rec = rec " " $$2 } } ; \
X	      END { print rec } ' > makedep
X	echo '/^# DO NOT DELETE THIS LINE/+1,$$d' >eddep
X	echo '$$r makedep' >>eddep
X	echo 'w' >>eddep
X	cp Makefile Makefile.bak
X	ex - Makefile < eddep
X	rm eddep makedep
X
install: et FRC
X	${INSTALL} et ${BINDIR}
X	${INSTALL} ease.sh ${BINDIR}/ease
X
X
lint:   ${DEP} symtab.h FRC
X	lint -hxn ${DEP}
X
print:  ${LST} FRC
X	@pr -f ${LST} | ${LP} ${LPFLAGS}
X
spotless: clean FRC
X	rcsclean ${LST}
X
y.tab.h parser.c: parser.y
X	@rm -f parser.c
X	${YACC} -v -d parser.y
X	sed 's/=yylex/=yyyylex/' < y.tab.c >parser.c
X
X# the following dummy rule is because of the results of 'make depend'
X# However, under SunOS Make - it complains. You may have to comment it out
X./lexdefs.h:	lexdefs.h
X
lexdefs.h:	y.tab.h
X	-(cmp -s y.tab.h lexdefs.h || cp y.tab.h lexdefs.h)
X
lexan.c: lexan.l
X
parser.o: y.tok.h
y.tok.h:	y.tab.h
X	grep '^#.*define' y.tab.h |\
X	sed 's/^# define \([^ ]*\) [^ ]*$$/	"\1",/' >y.tok.h
X
X${HDR} ${SRC} lexan.l parser.y:
X	co $@
X
XFRC:
X
X
X# DO NOT DELETE THIS LINE -- make depend uses it
X
main.o: main.c fixstrings.h 
emitcf.o: emitcf.c  symtab.h fixstrings.h
errors.o: errors.c fixstrings.h
idman.o: idman.c  symtab.h fixstrings.h
strops.o: strops.c fixstrings.h 
strops.o: symtab.h
symtab.o: symtab.c fixstrings.h 
symtab.o: symtab.h
fixstrings.o: fixstrings.c 
parser.o: parser.c fixstrings.h  symtab.h
lexan.o: lexan.c  fixstrings.h symtab.h lexdefs.h
main.o: main.c fixstrings.h 
emitcf.o: emitcf.c  symtab.h fixstrings.h
errors.o: errors.c fixstrings.h
idman.o: idman.c  symtab.h fixstrings.h
strops.o: strops.c fixstrings.h 
strops.o: symtab.h
symtab.o: symtab.c fixstrings.h 
symtab.o: symtab.h
fixstrings.o: fixstrings.c 
X
X
X
X
X
X
X
X
END_OF_FILE
if test 4585 -ne `wc -c <'src/Makefile'`; then
    echo shar: \"'src/Makefile'\" unpacked with wrong size!
fi
# end of 'src/Makefile'
fi
if test -f 'src/ease.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ease.sh'\"
else
echo shar: Extracting \"'src/ease.sh'\" \(3735 characters\)
sed "s/^X//" >'src/ease.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X#  ease - front end for the ease translator (et).
X#
X#  This sh script simplifies the task of calling "et" with the proper flags.
X#
X#  It also defines a VERSION macro, known to cpp when preprocessing the
X#  input to et.  This allows you to automatically embed the RCS version
X#  number of your config file into the generated sendmail.cf. 
X#
X#  For example, if your ease input file contains the RCS version string
X#	$Revision: 1.7 $
X#  and the lines
X#	define ("Received:",
X#	    "by ${m_oname} (${VERSION})"
X#	    ifset (m_shostname, " from ${m_shostname} ") "for ${m_ruser}"
X#  then your sendmail.cf will define the "Received:" header line so that
X#  it contains the RCS version number of the ease input file.  This version
X#  number will ultimately be stamped into the header of every message which
X#  flows though this sendmail, thus allowing you to see at a glance whether
X#  some problem was due to an out-of-date sendmail.cf.
X#
X#  At our site, the "Received:" header lines thus have the following form:
X#
X#	Received: by isis.tc.fluke.COM (version 2.46)
X#	    from argv.tc.fluke.COM for jeff
X#	    id AA10285; Wed, 21 Feb 90 17:28:43 PST
X#	Received: by argv.tc.fluke.COM (version 2.46)
X#	    for jeff@isis
X#	    id AA06739; Wed, 21 Feb 90 17:28:39 PST
X#
X#  This makes it a little easier to track down problems in networks comprising
X#  dozens or hundreds of machines.
X#
X# $Source: /home/kreskin/u0/barnett/Src/ease/src/RCS/ease.sh,v $
X# $Locker:  $
X#
X# $Revision: 1.7 $
X# Check-in $Date: 1991/05/16 10:45:25 $
X# $State: Exp $
X#
X# $Author: barnett $
X#
X# $Log: ease.sh,v $
X# Revision 1.7  1991/05/16  10:45:25  barnett
X# Better support for System V machines
X# Support for machines with read only text segments
X#
X# Revision 1.6  1990/05/07  11:15:04  jeff
X# Add support for the "-q" flag added to ease.
X#
X# Version 1.5  90/02/22  15:51:12  jeff
X# Improved the comments in preparation for netwide release.
X# 
X# Version 1.4  88/11/18  11:24:12  jeff
X# RCS mangled the previous change; try it again.  (It saw something that
X# looked like a keyword to it, so it expanded the token.  Yuck.)
X# 
X# Version 1.3  88/11/18  11:20:52  jeff
X# Change the VERSION macro from the date to the RCS revision of the
X# config.ease file.
X# 
X# Version 1.2  87/04/13  16:56:29  jeff
X# Change argument parsing to accomodate the new -C flag.
X# 
X# Version 1.1  87/04/08  12:20:58  jeff
X# Initial version
X# 
X#
X# @(#)FLUKE source file: $Header: /home/kreskin/u0/barnett/Src/ease/src/RCS/ease.sh,v 1.7 1991/05/16 10:45:25 barnett Exp $
X
PATH=.:/bin:/usr/bin:/usr/ucb:/usr/local/bin
export PATH
X
echo    "#"
echo    "#   Compiled via: $0 $*"
echo	"# From directory: `pwd`"
echo    "#           Date: `date`"
echo    "#"
echo    "# This file was produced by the \"ease\" translator."
echo    "# You probably shouldn't edit it, since changes will be lost"
echo	"# the next time that ease is run.  Instead, edit the source file"
echo	"# located in the directory named above."
echo    "#"
X
cppflags=
etflags='-q'
CPP='cc -E'
X
X
for i in ${1+"$@"} ;do
X    case "$1" in
X	'')	break;;
X	-C)	etflags="${etflags-} $1";;
X	-D*)	cppflags="$cppflags $1";;
X	*)	file="$1";;
X    esac
X    shift
done
X
X#
X#  Extract the RCS "Revision" string from the ease input file, and
X#  use it to define the VERSION symbol to cpp.
X#
X#  If you maintain your ease input file with SCCS, the appropriate change
X#  should be simple.
X#
Rev=`fgrep 'Revision:' $file | sed -e 's/^.*Revision:[	 ]*\([^	 ]*\).*/\1/'`
X
X# The sed commands delete empty comment lines and those preprocessor output
X# lines which indicate the linenumber and filename.
X$CPP -DVERSION=\"version\ $Rev\" $cppflags $file |
X    et $etflags |
X    sed -e '/^# *$/d' \
X	-e '/^#[ 	]*[0123456789][0123456789]*[ 	]*".*"[	 ]*$/d'
END_OF_FILE
if test 3735 -ne `wc -c <'src/ease.sh'`; then
    echo shar: \"'src/ease.sh'\" unpacked with wrong size!
fi
# end of 'src/ease.sh'
fi
if test -f 'src/errors.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/errors.c'\"
else
echo shar: Extracting \"'src/errors.c'\" \(5256 characters\)
sed "s/^X//" >'src/errors.c' <<'END_OF_FILE'
X#ifdef FLUKE
X# ifndef LINT
X    static char RCSid[] = "@(#)FLUKE  $Header: /tmp_mnt/home/kreskin/u0/barnett/Src/Ease/ease/src/RCS/errors.c,v 2.3 1991/09/09 16:33:23 barnett Exp $";
X# endif LINT
X#endif FLUKE
X
X/*
X *  	errors.c   -- Contains error initialization and reporting routines.
X *
X *  	author     -- James S. Schoner, Purdue University Computing Center,
X *				        West Lafayette, Indiana  47907
X *
X *  	date       -- July 9, 1985
X *
X *	Copyright (c) 1985 by Purdue Research Foundation
X *
X *	All rights reserved.
X *
X * $Log: errors.c,v $
X * Revision 2.3  1991/09/09  16:33:23  barnett
X * Minor bug fix release
X *
X * Revision 2.2  1991/05/16  10:45:25  barnett
X * Better support for System V machines
X * Support for machines with read only text segments
X *
X * Revision 2.1  1990/01/30  14:17:29  jeff
X * Bruce Barnett - extensions for SunOS/Ultrix.
X *
X * Revision 2.0  88/06/15  14:41:10  root
X * Baseline release for net posting. ADR.
X */
X
X#include <stdio.h>
X#include "fixstrings.h"
X#include <ctype.h>
extern int  ErrorCount;	 /* error count	               */
extern char FNbuf[];	 /* input file name   	       */
extern int  Lcount;	 /* line count	     	       */
XFILE *DIAGf = {stderr};  /* file for diagnostic output */
extern char yytext[];	/* current token */
extern int yyleng;	/* and it's length */
extern int	yylineno;	/* current input line number */
extern char *infile;		/* input file name */
static char *source;
X
X/*
X * yywhere() -- input position for yyparse()
X * from Schreiner and Friedman's book on compiler construction
X */
void
yywhere() 	/* position stamp */
X{
X    char	colon = 0;	/* flag */
X    if (source && *source && strcmp(source,"\"\"")) {
X	char	*cp = source;
X	int	len = strlen(source);
X	
X	if (*cp == '"')
X	  ++cp, len -= 2;
X	if (strlen(cp, "./", 2) == 0)
X	  cp += 2, len -= 2;
X	if (len > 0 )
X	  fprintf(DIAGf, "\"%.*s\"", len, cp);
X	colon = 1;
X    } 	else if (infile && strcmp(infile,"-")) {
X	  fprintf(DIAGf, "\"%s\"",infile);
X	  colon = 1;
X      }
X    if (yylineno > 0 ) {
X	if (colon)
X	  fputs(", ",DIAGf);
X	fprintf(DIAGf, "line %d",
X		yylineno - (*yytext == '\n' || ! *yytext));
X	colon = 1;
X/*	if ((yylineno - (*yytext == '\n' || ! *yytext)) != Lcount)
X	  fprintf(DIAGf, "?%d:?", Lcount); */
X    }
X    if (*yytext) {
X	register int i;
X	for (i=0;i<20;++i)
X	  if (!yytext[i] || yytext[i] == '\n')
X	    break;
X	if (i) {
X	    if (colon)
X	      putc(' ',DIAGf);
X	    fprintf(DIAGf, "near \"%.*s\"",i,yytext);
X	    colon = 1;
X	}
X    }
X    if (colon)
X      fputs(": ",DIAGf);
X    fflush(DIAGf);
X    fflush(stdout);
X    fflush(stderr); /* just to make sure */
X}
X
X
X/*
X *	yymark - keep track of source file and line number 
X */
X
void
yymark()	/* retreive from '# digit text' */
X{
X    if (source)
X      cfree(source); 
X    source = (char *) calloc(yyleng,sizeof(char));
X    if (source) {
X      sscanf(yytext, "# %d%s",&yylineno, source);
X/*      fprintf(stderr,"source = '%s' on %s",source,yytext); */
X      Lcount = yylineno;
X      if (strcmp(source,"\"\""))
X	strcpy(FNbuf,source);
X      else if ( infile && strcmp(infile,"-"))
X	sprintf(FNbuf,"\"%s\"",infile);
X/*      fprintf(stderr,"FNbuf = '%s', infile = '%s'\n",FNbuf,infile); */
X	       
X  }
X}
X
X
X
X/*
X *	yyerror () -- Prints source file name (FNbuf), line number (Lcount),
X *		      and error message (sbErr) for each invokation.
X *		      it also prints out a message where the error is.
X *
X */
void
yyerror (sbErr)
char *sbErr;
X{
X    extern int yynerrs;
X    ++ErrorCount;
X    yywhere();
X/*    fprintf(DIAGf, " %s\t[error %d]\n", sbErr, ErrorCount); */
X    fprintf(DIAGf, " %s\n", sbErr);
X/* yynerrs is the number of yacc errors, ErrorCount is larger */
X}
X
X
X
X/*
X *	ErrorReport () -- Prints source file name (FNbuf), line number (Lcount),
X *			  and error message (sbErr) for each invokation.
X *
X */
void
XErrorReport (sbErr)
char *sbErr;
X{
X/*	fprintf (DIAGf, "%s, line %d: %s", FNbuf, Lcount, sbErr);
X	ErrorCount++; */
X    yyerror(sbErr);
X}
X
X
X/*
X *	FatalError () -- Translator fatal error routine which prints 
X *			 error message (sbErr) and an argument (sbArg).
X *
X */
void
XFatalError (sbErr, sbArg)
char *sbErr,
X     *sbArg;
X{
X	fprintf (DIAGf, "%s, line %d: Fatal Error In Translator: %s %s\n", 
X		 FNbuf, Lcount, sbErr, sbArg); 
X	fflush(stderr);
X	exit (1);
X}
X
X
X/*
X *	PrintError () -- Prints source file name (FNbuf), line number
X *			 (cline), error message (sbErr), and argument
X *			 (sbArg) for each invokation.
X *
X */
void
PrintError (sbErr, sbArg)
char *sbErr;
char *sbArg;
X{
X    char	Ebuffer[1000];
X    sprintf(Ebuffer,sbErr,sbArg);
X    yyerror(Ebuffer);
X/*    fprintf (DIAGf, "%s, line %d: %s %s.\n", FNbuf, Lcount, sbErr, sbArg);
X	ErrorCount++; */
X}
X
X
X/*
X *	PrintWarning () -- Prints a warning message with source file
X *			   name (FNbuf), line number (Lcount), warning
X *			   (sbWarn), and a possible identifier (sbID).
X *
X */
void
PrintWarning (sbWarn, sbID)
char *sbWarn;
char *sbID;
X{
X/*	fprintf (DIAGf, "%s, line %d: Warning: ", FNbuf, Lcount); */
X        yywhere();
X	fprintf(DIAGf,"Warning: ");
X	if (sbID != NULL)
X		fprintf (DIAGf, sbWarn, sbID);
X	else
X		fprintf (DIAGf, sbWarn);
X}
X
X
X/*
X *	InitError () -- Initialize line count (Lcount) to one and error count
X *		        (ErrorCount) to zero.
X *
X */
void
InitError ()
X{
X	Lcount     = 1;
X	ErrorCount = 0;
X}
END_OF_FILE
if test 5256 -ne `wc -c <'src/errors.c'`; then
    echo shar: \"'src/errors.c'\" unpacked with wrong size!
fi
# end of 'src/errors.c'
fi
if test -f 'src/idman.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/idman.c'\"
else
echo shar: Extracting \"'src/idman.c'\" \(6904 characters\)
sed "s/^X//" >'src/idman.c' <<'END_OF_FILE'
X#ifdef FLUKE
X# ifndef LINT
X    static char RCSid[] = "@(#)FLUKE  $Header: /home/kreskin/u0/barnett/Src/Ease/ease/src/RCS/idman.c,v 3.2 1991/10/15 17:02:04 barnett Exp $";
X# endif LINT
X#endif FLUKE
X
X/*
X *  	idman.c	-- Contains routines for manipulating identifiers and their
X *		   symbolic associations.
X *
X *  	author	-- James S. Schoner, Purdue University Computing Center,
X *				     West Lafayette, Indiana  47907
X *
X *  	date	-- July 9, 1985
X *
X *	Copyright (c) 1985 by Purdue Research Foundation
X *
X *	All rights reserved.
X *
X * $Log: idman.c,v $
X * Revision 3.2  1991/10/15  17:02:04  barnett
X * Detect if (one_or_more) next ($2) error
X *
X * Revision 3.1  1991/02/25  22:09:52  barnett
X * Fixed some portability problems
X *
X * Revision 3.0  1991/02/22  18:50:27  barnett
X * Added support for HP/UX and IDA sendmail.
X *
X * Revision 2.1  1990/01/30  14:33:52  jeff
X * Bruce Barnett - changed UniqMac.
X *
X * Revision 2.0  88/06/15  14:42:14  root
X * Baseline release for net posting. ADR.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "symtab.h"
X#include "fixstrings.h"
X
extern struct he *LookupSymbol ();
extern void	  FatalError (),
X		  ErrorReport (),
X		  PrintWarning (),
X		  PrintError ();
extern char *	  malloc ();
extern short number_of_fields;	/* number of fields on a ruleset */
X
char	IDused[] = "                          "; /* 26 blanks */
X/*
X *	UniqMac () -- Assigns and returns a unique one-character macro
X *		      name (upper-case) for an Ease macro name.
X *
X *	Bruce Barnett:
X *	Special enhancement - if idval is a single character,
X *	and the corresponding letter has not been assigned,
X *	Make the idc character the same as the macro name 
X *
X *	This makes it nice to test cfc/ease completeness.
X *	Also makes reading the ease output easier.
X *
X */
char
UniqMac (phe)
struct he *phe;		/* symbol table entry for Ease macro */
X{
X    short i;
X
X    if ((strlen(phe->psb) == 1) && 
X	isupper(*(phe->psb)) &&
X	IDused[*(phe->psb) - 'A'] == ' ' ) {
X	IDused[*(phe->psb) - 'A'] = (phe->idval.idc) = *(phe->psb);
X    } else {
X	for (i=0;i<26 && IDused[i] != ' ';i++) 
X	  ;	/* find first unused letter */
X	if (i==26) FatalError ("Too many macro names (26 max)", (char *) NULL);
X	IDused[i] = 
X	  (phe->idval.idc) = 
X	    'A' + i;
X    }
X    return (phe->idval.idc);
X}
X
X
X/*
X *	BindID () -- Binds either a ruleset or precedence identifier (phe) to
X * 		     an integer (vid).  The id type distinction is passed in
X *		     the parameter idt.
X *
X */
void
BindID (phe, vid, idt)
register struct he *phe;	/* symbol table entry for an identifier    */
int vid;			/* value of the identifier		   */
unsigned idt;			/* identifier type (ruleset or precedence) */
X{
X	if (ISTYPED(phe->idtype)) {	/* should be undefined */
X		PrintWarning ("Redeclaration of %s.\n", phe->psb);
X		phe->idtype = ID_UNTYPED;
X	}
X	phe->idtype |= idt;		/* make defined	       */
X	if (ISRULESET(phe->idtype)) {
X		if (vid > VALRSNMAX) {
X			ErrorReport ("Ruleset number too large.\n");
X			return;
X		} else if (vid < 0) {
X			ErrorReport ("Ruleset number must be non-negative.\n");
X			return;
X		}
X		sprintf (phe->idval.rsn, "%d", vid);
X	} else 
X		phe->idval.prec = vid;
X}
X
X
X/*
X *	CheckRS () -- Checks validity of a ruleset identifier (phe) and 
X *		      returns the ruleset string to which the identifier
X *		      is bound.  If the ruleset identifier is invalid, the
X *		      null string is returned.
X *
X */
char *
CheckRS (phe)
struct he *phe;		/* symbol table entry for ruleset identifier */
X{
X	if (!ISRULESET(phe->idtype)) {
X		if (!ISTYPED(phe->idtype))
X			PrintError ("Ruleset identifier not bound to a number: %s", phe->psb);
X		else
X			PrintError ("Identifier not of ruleset type: %s", phe->psb);
X		return (NULL);
X	} else
X		return (phe->idval.rsn);
X}
X
X
X/*
X *	MakeMac () -- Declare a macro name (pmac) as a class and/or macro type 
X *		      (targtype) and return the unique cf character assigned 
X *		      to it.
X *
X */
char
MakeMac (pmac, targtype)
register struct he *pmac;	/* symbol table entry for macro identifier */
unsigned targtype;		/* target declaration type for the macro   */
X{
X	/*
X	 *	An Ease macro may be declared as both a singular macro and
X	 *	a class macro.
X	 *
X	 */
X	if (ISMACRO(pmac->idtype) || ISCLASS(pmac->idtype)) {
X		pmac->idtype |= targtype;
X		return (pmac->idval.idc);
X	}
X	if (ISTYPED(pmac->idtype)) {	/* not a macro or class id */
X		PrintError ("Redeclaring or using as macro or class: %s", pmac->psb);
X		return ('\0');
X	}
X	pmac->idtype |= targtype;	/* previously untyped; declare here */
X	return (UniqMac (pmac));
X}
X	
X
X/*
X *	GetField () -- Returns a field type string given a field 
X *		       identifier (fid).
X *
X */
char *
GetField (fid)
register struct he *fid;	/* field identifier */
X{
X	if (!ISFIELD(fid->idtype)) {
X		PrintError ("Field type not defined for %s", fid->psb);
X		return (NULL);
X	} else {
X	    number_of_fields++;
X	    return (fid->idval.fstring);
X	}
X}
X
X
X/*
X *	CheckMailer () -- Declares a mailer identifier (mid) as type mailer,
X *			  checking that the identifier was not previously 
X *			  declared a different type. 
X *
X */
char *
CheckMailer (mid)
register struct he *mid;
X{
X	if (ISTYPED (mid->idtype) && !ISMAILER (mid->idtype)) {
X		PrintError ("Redeclaration as mailer: %s", mid->psb);
X		return (NULL);
X	}
X	mid->idtype |= ID_MAILER;
X	return (mid->psb);
X}
X
X
X/*
X *	AssignType () -- Assigns to each field identifier in fidlist the
X *			 type (in string form) fidtype.  This is accomplished
X *			 by making each field identifier symbol table entry
X *			 "point" to the type found in fidtype.
X *
X */
void
AssignType (fidlist, fidtype)
register char *fidlist;		/* field identifier list, blank separated */
char *fidtype;			/* field identifier type string		  */
X{
X	register struct he *fid;	/* pointer to a field identifier  */
X	char *fres;			/* field type result string	  */
X	register char *srch;		/* fidlist search pointer	  */
X	char  sep;			/* fidlist separator character    */
X
X	fres = (char *) malloc (strlen (fidtype) + 1);
X	if (fres == NULL)
X		FatalError ("System out of string space in AssignType ()", (char *) NULL);
X	strcpy (fres, fidtype);		/* make clean copy of string type */
X
X	/*
X	 *	Search for all field identifiers and make the type assignment. 
X 	 *
X	 */
X	srch = fidlist;
X	while (*srch != '\0') {
X		while ((*++srch != ' ') && (*srch != '\0'))
X			/* null */ ;
X		if (*fidlist != '\0') {		        /* found a field id       */
X			sep = *srch;
X			*srch = '\0';
X			fid = LookupSymbol (fidlist);	/* get symbol table entry */
X			if (ISFIELD(fid->idtype)) {
X				if (strcmp (fid->idval.fstring, fres))
X					PrintWarning ("Redefinition of field type for %s.\n", fid->psb);
X			} else if (ISTYPED(fid->idtype)) {
X				PrintError ("Redeclaration of identifier as a field: %s", fid->psb);
X				return;
X			}
X			fid->idtype |= ID_FIELD;	/* type the identifier    */
X			fid->idval.fstring = fres;	/* type the field	  */
X			if ((*srch = sep) != '\0')
X				fidlist = ++srch;
X		}
X	}
X}
END_OF_FILE
if test 6904 -ne `wc -c <'src/idman.c'`; then
    echo shar: \"'src/idman.c'\" unpacked with wrong size!
fi
# end of 'src/idman.c'
fi
if test -f 'src/lexan.patch' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lexan.patch'\"
else
echo shar: Extracting \"'src/lexan.patch'\" \(5320 characters\)
sed "s/^X//" >'src/lexan.patch' <<'END_OF_FILE'
X*** /home/kreskin/u0/barnett/Src/ease/src/lexan.l	Wed Mar  1 15:43:53 1989
X--- lexan.l	Mon May  7 14:12:53 1990
X***************
X*** 59,78 ****
X  	static char linbuf[BUFSIZ], *pc = linbuf;
X  	char c;
X  
X- 
X- 
X- 
X- 
X  	/* initialize buffer: first call only */
X  	if (*pc == '\0' && pc == linbuf) {
X  		if (fgets(linbuf, BUFSIZ, yyin)==NULL)
X  			return EOF;
X!                 if (linbuf[0] == '#' )
X!                     fprintf(yyout, "%s", linbuf);  /* echo input as comment */
X!                 else
X!                     fprintf(yyout, "# %s", linbuf);  /* echo input as comment */
X! 
X  	}
X  	c = *pc++;
X  	if (c == '\n') {
X  		pc = linbuf;
X--- 68,82 ----
X  	static char linbuf[BUFSIZ], *pc = linbuf;
X  	char c;
X  
X  	/* initialize buffer: first call only */
X  	if (*pc == '\0' && pc == linbuf) {
X  		if (fgets(linbuf, BUFSIZ, yyin)==NULL)
X  			return EOF;
X! 		/* echo input as comment */
X! 		if (EchoInputAsComments) {
X! 		    fprintf(yyout, "%s%s", (linbuf[0] == '#' ? "" : "# "), linbuf);
X  		}
X+ 	}
X  	c = *pc++;
X  	if (c == '\n') {
X  		pc = linbuf;
X***************
X*** 79,90 ****
X  		if (fgets(linbuf, BUFSIZ, yyin) == NULL)
X  			*pc = EOF;
X  		else
X! 			/* echo input as comment except cpp comments */
X!                     if (linbuf[0] == '#' )
X!                         fprintf(yyout, "%s", linbuf);  /* echo input as comment */
X!                     else
X!                         fprintf(yyout, "# %s", linbuf);  /* echo input as comment */
X  	}
X  	return c;
X  }
X  
X--- 83,94 ----
X  		if (fgets(linbuf, BUFSIZ, yyin) == NULL)
X  			*pc = EOF;
X  		else
X! 			/* echo input as comment (except cpp comments) */
X! 			if (EchoInputAsComments) {
X! 			    fprintf(yyout, "%s%s",
X! 				(linbuf[0] == '#' ? "" : "# "), linbuf);
X  			}
X+ 	}
X  	return c;
X  }
X  
X***************
X*** 103,109 ****
X  	{ "Path",		MPATH },
X  	{ "Recipient",		MRECIPIENT },
X  	{ "Sender",		MSENDER },
X- 	{ "asm",		ASM },
X  	{ "bind",		BIND },
X  	{ "canon",		CANON },
X  	{ "class",		CLASS },
X--- 107,112 ----
X***************
X*** 112,121 ****
X  	{ "d_interactive",	DOPTI },
X  	{ "d_queue",		DOPTQ },
X  	{ "define",		DEFINE },
X- 	{ "eval",		EVAL },
X  	{ "f_addrw",		CCFLAG },
X  	{ "f_arpa",		AAFLAG },
X- 	{ "f_bsmtp",		BBFLAG },	/* IDA */
X  	{ "f_date",		DDFLAG },
X  	{ "f_dot",		XXFLAG },
X  	{ "f_escape",		EEFLAG },
X--- 115,122 ----
X***************
X*** 125,136 ****
X  	{ "f_full",		XFLAG },
X  	{ "f_llimit",		LLFLAG },
X  	{ "f_locm",		LFLAG },
X- 	{ "f_mail11",		HHFLAG },
X  	{ "f_mesg",		MMFLAG },
X  	{ "f_mult",		MFLAG },
X  	{ "f_noreset",		SSFLAG },
X  	{ "f_noufrom",		NFLAG },
X- 	{ "f_relativize",	VVFLAG },
X  	{ "f_retsmtp",		PFLAG },
X  	{ "f_return",		PPFLAG },
X  	{ "f_rfrom",		RFLAG },
X--- 126,135 ----
X***************
X*** 159,171 ****
X  	{ "match",		MATCH },
X  	{ "next",		NEXT },
X  	{ "o_alias",		AAOPT },
X- 	{ "o_aliasfile",	YYOPT },
X  	{ "o_bsub",		BBOPT },
X  	{ "o_checkpoint",	CCOPT },
X  	{ "o_delivery",		DOPT },
X  	{ "o_dmuid",		UOPT },
X  	{ "o_dnet",		NNOPT },
X- 	{ "o_envelope",		SLOPT },
X  	{ "o_ewait",		AOPT },
X  	{ "o_flog",		SSOPT },
X  	{ "o_fsmtp",		HHOPT },
X--- 158,168 ----
X***************
X*** 174,183 ****
X  	{ "o_hformat",		OOPT },
X  	{ "o_loadnc",		XXOPT },
X  	{ "o_loadq",		XOPT },
X- 	{ "o_maxempty",		BOPT },
X- 	{ "o_maxhops",		HOPT },
X  	{ "o_newproc",		YYOPT },
X- 	{ "o_nfs",		RROPT },	/* SunOS 4.0 */
X  	{ "o_pmaster",		PPOPT },
X  	{ "o_prifactor",	ZOPT },
X  	{ "o_qdir",		QQOPT },
X--- 171,177 ----
X***************
X*** 200,209 ****
X  	{ "o_wizpass",		WWOPT },
X  	{ "options",		OPTIONS },
X  	{ "precedence",		PRECEDENCE },
X- 	{ "quote",		QUOTE },
X  	{ "readclass",		READCLASS },
X  	{ "resolve",		RESOLVE },
X- 	{ "resolved",		RESOLVED },
X  	{ "retry",		RETRY },
X  	{ "return",		RETURN },
X  	{ "ruleset",		RULESET },
X--- 194,201 ----
X***************
X*** 210,218 ****
X  	{ "trusted",		TRUSTED },
X  	{ "user",		USER },
X  	{ "while",		IF },
X- 	{ "ypalias",		YPALIAS },
X- 	{ "ypmap",		YPMAP },
X- 	{ "yppasswd",		YPPASSWD },
X  };
X  %}
X  
X--- 202,207 ----
X***************
X*** 221,231 ****
X  
X  [ \t\f]+			; 	/* discard whitepsace  */
X  [\n]				Lcount++;
X! ^\#[ \t]*[0-9]+[ \t]*\".*\"[ \t]*.*[\n]	{
X! /*			        sscanf (yytext, "%*c%d%s", &Lcount, FNbuf); */
X! 	                        yymark();
X  			        }
X! [A-Za-z_][A-Za-z0-9_-]*		{
X  				register int l, h, m, r, c;
X  
X  				l = 0;
X--- 210,219 ----
X  
X  [ \t\f]+			; 	/* discard whitepsace  */
X  [\n]				Lcount++;
X! ^\#[ \t]*[0-9]+[ \t]*\".*\"[ \t]*[\n]	{
X! 			        sscanf (yytext, "%*c%d%s", &Lcount, FNbuf);
X  			        }
X! [A-Za-z][A-Za-z0-9_-]*		{
X  				register int l, h, m, r, c;
X  
X  				l = 0;
X***************
X*** 292,305 ****
X  						INch = input ();
X  				}
X  				}
X- "/"				return (SLASH);
X  [\\]?.				{
X  				if (RMatch) {	/* in rulesets, return literal character */
X  					yylval.ival = (yytext[0] == '\\') ? yytext[1] : yytext[0];
X  					return (SEPCHAR);
X- 
X  				} else {
X! 					PrintError ("Illegal delimiter character: (octal code) \\%03o", *yytext);
X  				}
X  				}
X  %%
X--- 280,292 ----
X  						INch = input ();
X  				}
X  				}
X  [\\]?.				{
X  				if (RMatch) {	/* in rulesets, return literal character */
X  					yylval.ival = (yytext[0] == '\\') ? yytext[1] : yytext[0];
X  					return (SEPCHAR);
X  				} else {
X! 					ErrorReport ("Illegal delimiter character");
X! 					printf (": (octal code) \\%03o\n", *yytext);
X  				}
X  				}
X  %%
END_OF_FILE
if test 5320 -ne `wc -c <'src/lexan.patch'`; then
    echo shar: \"'src/lexan.patch'\" unpacked with wrong size!
fi
# end of 'src/lexan.patch'
fi
if test -f 'src/symtab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/symtab.c'\"
else
echo shar: Extracting \"'src/symtab.c'\" \(6799 characters\)
sed "s/^X//" >'src/symtab.c' <<'END_OF_FILE'
X#ifdef FLUKE
X# ifndef LINT
X    static char RCSid[] = "@(#)FLUKE  $Header: /tmp_mnt/home/kreskin/u0/barnett/Src/Ease/ease/src/RCS/symtab.c,v 3.1 1991/09/09 16:33:23 barnett Exp $";
X# endif LINT
X#endif FLUKE
X
X/*
X *  	symtab.c   -- Contains Ease Translator symbol table routines.
X *
X *  	author     -- James S. Schoner, Purdue University Computing Center,
X *				        West Lafayette, Indiana  47907
X *
X *  	date       -- July 9, 1985
X *
X *	Copyright (c) 1985 by Purdue Research Foundation
X *
X *	All rights reserved.
X *
X * $Log: symtab.c,v $
X * Revision 3.1  1991/09/09  16:33:23  barnett
X * Minor bug fix release
X *
X * Revision 3.0  1991/02/22  18:50:27  barnett
X * Added support for HP/UX and IDA sendmail.
X *
X * Revision 2.1  1990/01/30  15:55:54  jeff
X * SunOS/Ultrix/Ida additions Jan 25 1988 Bruce Barnett
X *
X * Revision 2.0  88/06/15  14:43:04  root
X * Baseline release for net posting. ADR.
X */
X
X#include "fixstrings.h"
X#include <stdio.h>
X#include <ctype.h>
X#include "symtab.h"
X
X#define ERRORMAILER "error"		/* predefined error mailer name */
X#define ERRORMAILERUC "ERROR"		/* predefined ERROR mailer name */
X
extern void FatalError (),
X	    PrintWarning ();
X
struct he *LookupSymbol ();
X
struct Defmac {				/* predefined macro struct def  */
X	char *macname;
X	char  macrep;
X};
X
static struct he *SymTab[SST];		/* hash table base array        */
static struct Defmac MacDefs[] = {	/* predefined macros	        */
X			{"m_smtp",	'e'},
X			{"m_oname",	'j'},
X			{"m_uucpname",	'k'}, /* IDA */
X			{"m_ufrom",	'l'},
X			{"m_daemon",	'n'},
X			{"m_domain",	'm'},	/* SunOS */
X			{"m_addrops",	'o'},
X			{"m_defaddr",	'q'},
X			{"m_sitename",	'w'},
X			{"m_odate",	'a'},
X			{"m_adate",	'b'},
X			{"m_hops",	'c'},
X			{"m_udate",	'd'},
X			{"m_saddr",	'f'},
X			{"m_sreladdr",	'g'},
X			{"m_rhost",	'h'},
X			{"m_qid",	'i'},
X			{"m_pid",	'p'},
X			{"m_protocol",	'r'},
X			{"m_shostname", 's'},
X			{"m_ctime",	't'},
X			{"m_ruser",	'u'},
X			{"m_version",	'v'},
X			{"m_sname",	'x'},
X			{"m_stty",	'y'},
X			{"m_rhdir",	'z'},
X			{"sentinel",	'\0'}
X};
X
X/* FLUKE jps 28-apr-86 - Install some wired-in class names */
static struct Defmac ClassDefs[] = {	/* predefined classes */
X			{"c_myname",	'w'},
X			{"c_mydomain",	'm'},
X			{"class_sentinel",	'\0'}
X};
X
X/*
X *	DefScan () -- Scan symbol table to find macros, classes, mailers, 
X *		      and rulesets which have been referenced or declared, but
X *		      not defined.  A warning is printed for each such 
X *		      occurence.  This routine is usually called at the end
X *		      of a successful Ease translation.
X *
X */
void
DefScan ()
X{
X	register int stindex;		/* symbol table hash index   */
X	register struct he *hcsearch;	/* hash chain search pointer */
X
X	for (stindex = 0; stindex < SST; stindex++) {
X		if ((hcsearch = SymTab[stindex]) != NULL)
X			while (hcsearch != NULL) {
X				if ((ISMACRO(hcsearch->idtype) && 
X				     isupper(hcsearch->idval.idc)) &&
X				     !ISMACRO(hcsearch->idd))
X					PrintWarning ("Macro not defined: %s\n", hcsearch->psb);
X#ifdef notdef
X				if (ISCLASS(hcsearch->idtype) && !ISCLASS(hcsearch->idd))
X#else
X				/* FLUKE jps 28-apr-86 */
X				/* print warnings for UPPER CASE names only */
X				if (ISCLASS(hcsearch->idtype) &&
X				    isupper(hcsearch->idval.idc) &&
X				    !ISCLASS(hcsearch->idd))
X#endif
X					PrintWarning ("Class not defined: %s\n", hcsearch->psb);
X				if (ISMAILER(hcsearch->idtype) && !ISMAILER(hcsearch->idd) && (strcmp(hcsearch->psb,"LOCAL")))
X					PrintWarning ("Mailer not defined: %s\n", hcsearch->psb);
X				if (ISRULESET(hcsearch->idtype) && !ISRULESET(hcsearch->idd))
X					PrintWarning ("Ruleset not defined: %s\n", hcsearch->psb);
X				hcsearch = hcsearch->phe;
X			}
X	}
X}
X				     
X
X/*
X *	InitSymbolTable () -- Invoked by main () to initialize the symbol table.
X *
X */
void
InitSymbolTable ()
X{
X	int i;
X
X	for (i = 0; i < SST; i++)		/* initialize base array */
X		SymTab[i] = NULL;
X}
X
X
X/*
X *	PreLoad () -- Invoked by main () to preload special macro names 
X *		      and mailer declarations.
X *
X */
void
PreLoad ()
X{
X	struct Defmac *macptr;
X	struct he     *symptr;
X
X	/* preload special (lower-case) macros */
X	for (macptr = &MacDefs[0]; (*macptr).macrep != '\0'; macptr++) {
X		symptr = LookupSymbol ((*macptr).macname);
X		symptr->idtype |= ID_MACRO;
X		symptr->idval.idc = (*macptr).macrep;
X	}
X
X	/* preload special (lower-case) classes */
X	for (macptr = &ClassDefs[0]; (*macptr).macrep != '\0'; macptr++) {
X		symptr = LookupSymbol ((*macptr).macname);
X		symptr->idtype |= ID_CLASS;
X		symptr->idval.idc = (*macptr).macrep;
X	}
X
X	/* preload error mailer declaration */
X	symptr = LookupSymbol (ERRORMAILER);
X	symptr->idtype |= ID_MAILER;
X	symptr->idd |= ID_MAILER;
X
X	/* preload ERROR mailer declaration */
X	symptr = LookupSymbol (ERRORMAILERUC);
X	symptr->idtype |= ID_MAILER;
X	symptr->idd |= ID_MAILER;
X}
X	
X
X/*
X *	LookupSymbol () -- Returns a pointer to the hash entry already 
X *			   existing, or newly created, which corresponds 
X *			   to string sb.
X *
X */
struct he *
LookupSymbol (sb)
char sb[];			/* string buffer containing identifier */
X{
X	struct he *phe;		/* hash entry search pointer  */
X	int	  hc;		/* hash code of sb identifier */
X	extern char *malloc ();
X
X	phe = SymTab[hc = HashCode (sb)];
X	while (phe != NULL)			/* find hash entry for sb */
X		if (!strcmp (phe->psb, sb))
X			return (phe);
X		else
X			phe = phe->phe;
X	/* make new symbol table entry */
X	if ((phe = (struct he *) malloc (sizeof (struct he))) == NULL)
X		FatalError ("System out of space in LookupSymbol ()", (char *) NULL);
X	if ((phe->psb = (char *) malloc (strlen (sb) + 1)) == NULL)
X		FatalError ("System out of space in LookupSymbol ()", (char *) NULL);
X	strcpy (phe->psb, sb);
X	phe->idval.idc = '\0';
X	phe->idtype = ID_UNTYPED;
X	phe->idd = ID_UNTYPED;
X	phe->phe = SymTab[hc];
X	return (SymTab[hc] = phe);
X}
X
X
X/*
X *	RemoveSymbol () -- Removes the symbol table entry phe from the 
X *			   symbol table.
X *
X */
void
RemoveSymbol (phe)
struct he *phe;	   /* pointer to hash entry to be removed from symbol table */
X{
X	int hc;	   		/* hash code of entry phe       */
X	struct he *sphe;	/* search pointer for entry phe */
X
X	if (phe == NULL)
X		return;
X	else {			/* search and remove entry phe  */
X		sphe = SymTab[hc = HashCode (phe->psb)];
X		free (phe->psb);
X		if (sphe == phe)
X			SymTab[hc] = phe->phe;
X		else
X			while (sphe != NULL)
X				if (sphe->phe == phe) {
X					sphe->phe = phe->phe;
X					return;
X				} else
X					sphe = sphe->phe;
X	}
X}
X
X
X/*
X *	HashCode () -- Returns the hash code of the string in sb by adding 
X *		       the character values and applying mod by the hash 
X *		       table size.
X *
X */
int
HashCode (sb)
char sb[];
X{
X	int ccSum = 0;			/* sum of char values in string sb */
X	int i;
X
X	for (i = 0; sb[i]; i++)		/* add char codes for sb chars     */
X		ccSum += sb[i];
X	return (ccSum % SST);		/* return sum mod table size	   */
X}
END_OF_FILE
if test 6799 -ne `wc -c <'src/symtab.c'`; then
    echo shar: \"'src/symtab.c'\" unpacked with wrong size!
fi
# end of 'src/symtab.c'
fi
if test -f 'test/test.mc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/test.mc'\"
else
echo shar: Extracting \"'test/test.mc'\" \(4506 characters\)
sed "s/^X//" >'test/test.mc' <<'END_OF_FILE'
X/*
X * Sendmail configuration file for test rulesets
X *
X * Simon Kenyon November 20th, 1986
X */
X
bind
X	EnvelopeTo 		= ruleset  0;
X	From			= ruleset  1;
X	HeaderTo		= ruleset  2;
X	Canonicalize		= ruleset  3;
X	Externalize		= ruleset  4;
X
X	LocalHeaderFrom		= ruleset 10;
X	UucpHeaderFrom		= ruleset 11;
X
X	LocalHeaderTo		= ruleset 20;
X	UucpHeaderTo		= ruleset 21;
X
macro
X	Domain		= "my_domain";
X	Version		= "ruleset tester V1.0";
X
X	m_sitename	= "whatever";
X	m_oname		= "${m_sitename}.${Domain}";
X	m_daemon	= "MAILER-DAEMON";
X	/*m_ufrom		= "From ${m_sreladdr}  ${m_udate} remote from ${m_sitename}";*/
X	m_ufrom		= "From ${m_sreladdr}  ${m_udate}";
X	m_addrops	= ".:%@!^=/[]{}";
X	m_defaddr	= concat (
X				ifset (m_sname, "${m_sname}	<${m_sreladdr}>",
X						"${m_sreladdr}"),
X				""
X			  );
X	m_smtp		= "${m_oname} Sendmail ${m_version}/${Version} ready at ${m_adate}";
X
options
X	o_alias		= "/usr/lib/aliases";
X	o_delivery	= d_background;
X	o_dmuid		= "1";
X	o_flog		= "/usr/lib/sendmail.st";
X	o_fsmtp		= "/usr/lib/sendmail.hf";
X	o_gid		= "1";
X	o_hformat	= "";
X	o_qdir		= "/usr/spool/mqueue";
X	o_qtimeout	= "3d";
X	o_safe		= "";
X	o_slog		= "9";
X	o_timezone	= "WET";
X	o_tmode		= "0644";
X	o_tread		= "r2h";
X	o_wizpass	= "*";
X
precedence
X	first-class		=    0;
X	special-delivery	=  100;
X	junk			= -100;
X
trusted
X	{root, daemon, uucp, network};
X	{simon};
X
header
X	define ("a:", "The origination date in Arpanet format = ${m_odate}");
X	define ("b:", "The current date in Arpanet format = ${m_adate}");
X	define ("c:", "The hop count = ${m_hops}");
X	define ("d:", "The date in UNIX (ctime) format = ${m_udate}");
X	define ("e:", "The SMTP entry message = ${m_smtp}");
X	define ("f:", "The sender (from) address = ${m_saddr}");
X	define ("g:", "The sender address relative to the recipient = ${m_sreladdr}");
X	define ("h:", "The recipient host = ${m_rhost}");
X	define ("i:", "The queue id = ${m_qid}");
X	define ("j:", "The official domain name for this site = ${m_oname}");
X	define ("l:", "The format of the UNIX from line = ${m_ufrom}");
X	define ("n:", "The name of the daemon (for error messages) = ${m_daemon}");
X	define ("o:", "The set of operators in addresses = ${m_addrops}");
X	define ("p:", "Sendmail's pid = ${m_pid}");
X	define ("q:", "The default format of sender address = ${m_defaddr}");
X	define ("r:", "Protocol used = ${m_protocol}");
X	define ("s:", "Sender's host name = ${m_shostname}");
X	define ("t:", "A numeric representation of the current time = ${m_ctime}");
X	define ("u:", "The recipient user = ${m_ruser}");
X	define ("v:", "The version number of sendmail = ${m_version}");
X	define ("w:", "The hostname of this site = ${m_sitename}");
X	define ("x:", "The full name of the sender = ${m_sname}");
X	define ("y:", "The id of the sender's tty = ${m_stty}");
X	define ("z:", "The home directory of the recipient = ${m_rhdir}");
X
field
X	path		: match (1*);
X
ruleset Canonicalize {
X	if (path)
X		next ("{3}" $1);
X}
X
ruleset EnvelopeTo {
X	if (path @ path)
X		resolve (mailer (uucp),
X			 host ("{0_uucp}" $2),
X			 user ("{0_uucp}" $1));
X	if (path ! path)
X		resolve (mailer (uucp),
X			 host ("{0_uucp}" $1),
X			 user ("{0_uucp}" $2));
X	if (path)
X		resolve (mailer (local),
X			 user ("{0_local}" $1));
X}
X
ruleset From {
X	if (path)
X		return ("{1}" $1);
X}
X
ruleset HeaderTo {
X	if (path)
X		return ("{2}" $1);
X}
X
ruleset Externalize {
X	if (path)
X		return ("{4}" $1);
X}
X
ruleset LocalHeaderFrom {
X	if (path)
X		return ("{S_local}" $1);
X}
X
ruleset LocalHeaderTo {
X	if (path)
X		return ("{R_local}" $1);
X}
X
ruleset UucpHeaderFrom {
X	if (path)
X		return ("{S_uucp}" $1);
X}
X
ruleset UucpHeaderTo {
X	if (path)
X		return ("{R_uucp}" $1);
X}
X
mailer
X	local {
X		Path		= "/usr/src/local/EUnet/ease/test/args",
X		Flags		= {f_date,
X				   f_from,
X				   f_locm,
X				   f_mesg,
X				   f_mult,
X				   f_noufrom,
X				   f_rfrom,
X				   f_strip},
X		Sender		= LocalHeaderFrom,
X		Recipient 	= LocalHeaderTo,
X		Argv		= "args mail -d ${m_ruser}"
X	};
X	prog {
X		Path		= "/usr/src/local/EUnet/ease/test/args",
X		Flags		= {f_date,
X				   f_expensive,
X				   f_from,
X				   f_locm,
X				   f_mesg,
X				   f_noufrom,
X				   f_strip},
X		Sender		= LocalHeaderFrom,
X		Recipient 	= LocalHeaderTo,
X		Argv		= "args sh -c ${m_ruser}"
X	};
X	uucp {
X		Path		= "/usr/src/local/EUnet/ease/test/args",
X		Flags		= {f_date,
X				   f_from,
X				   f_mesg,
X				   f_strip,
X				   f_ufrom,
X				   f_upperh,
X				   f_upperu},
X		Sender		= UucpHeaderFrom,
X		Recipient 	= UucpHeaderTo,
X		Maxsize		= "65535",
X		Argv		= "args uumail -h -oc -gA -f${m_sreladdr} ${m_rhost}!${m_ruser}"
X	};
END_OF_FILE
if test 4506 -ne `wc -c <'test/test.mc'`; then
    echo shar: \"'test/test.mc'\" unpacked with wrong size!
fi
# end of 'test/test.mc'
fi
echo shar: End of archive 2 \(of 6\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
