Newsgroups: comp.sources.unix
From: madler@cco.caltech.edu (Mark Adler)
Subject: v25i142: zip - file compression/archive tool, Part01/07
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: madler@cco.caltech.edu (Mark Adler)
Posting-Number: Volume 25, Issue 142
Archive-Name: zip/part01

[ I removed all the ^M's from the various files that had them, and I
  renamed "readme" to "README" to match the c.s.unix convention.  The
  blurb below is from the man page.				--vix ]

NAME
     zip - package and compress (archive) files

DESCRIPTION
     Zip is a compression and file packaging utility for Unix,
     MSDOS, OS/2, and VMS.  It is analogous to a combination of
     tar and compress and is compatible with PKZIP (Phil Katz
     ZIP) for MSDOS systems.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 7)."
# Contents:  MANIFEST README contents crypt.h dir_os2.c dir_os2.h
#   doturboc.bat globals.c im_bits.c implode.h infozip.who makecrc.c
#   makefile makefile.bor makefile.msc makefile.os2 makefile.pwc
#   makevms.com revision.h ship.def tailor.h tempf.c tempf.h zip.def
#   zip.prj ziperr.h
# Wrapped by vixie@cognition.pa.dec.com on Sun Mar  1 18:57:37 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1429 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	
X README                     1	
X contents                   1	
X crypt.h                    1	
X dir_os2.c                  1	
X dir_os2.h                  1	
X doturboc.bat               1	
X fileio.c                   6	
X globals.c                  1	
X history                    5	
X im_bits.c                  1	
X im_ctree.c                 7	
X im_lm.asm                  2	
X im_lmat.c                  4	
X implode.c                  2	
X implode.h                  1	
X infozip.who                1	
X makecrc.c                  1	
X makefile                   1	
X makefile.bor               1	
X makefile.msc               1	
X makefile.os2               1	
X makefile.pwc               1	
X makevms.com                1	
X revision.h                 1	
X ship.c                     5	
X ship.def                   1	
X shrink.c                   2	
X tailor.h                   1	
X tempf.c                    1	
X tempf.h                    1	
X util.c                     2	
X zip.1                      3	
X zip.c                      4	
X zip.def                    1	
X zip.doc                    4	
X zip.h                      2	
X zip.prj                    1	
X ziperr.h                   1	
X zipfile.c                  3	
X zipnote.c                  2	
X zipsplit.c                 3	
X zipup.c                    2	
END_OF_FILE
if test 1429 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(929 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
Copyright (C) 1990,1991 Mark Adler, Richard B. Wales, and Jean-loup Gailly.
Permission is granted to any individual or institution to use, copy, or
redistribute this software so long as all of the original files are included
unmodified, that it is not sold for profit, and that this copyright notice
is retained.
X
LIKE ANYTHING ELSE THAT'S FREE, ZIP AND ITS ASSOCIATED UTILITIES ARE
PROVIDED AS IS AND COME WITH NO WARRANTY OF ANY KIND, EITHER EXPRESSED OR
IMPLIED. IN NO EVENT WILL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY DAMAGES
RESULTING FROM THE USE OF THIS SOFTWARE.
X
Please read the file zip.doc for information on how to compile, install, and
use zip, zipcloak (if this is not an export version), zipsplit, zipnote, and
ship.  The file "contents" is a complete list of the files you should have in
this distribution.  Also, if you are using MSDOS, you should read the note on
file formats at the end of the contents file.
END_OF_FILE
if test 929 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'contents' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'contents'\"
else
echo shar: Extracting \"'contents'\" \(3587 characters\)
sed "s/^X//" >'contents' <<'END_OF_FILE'
Copyright (C) 1990,1991 Mark Adler, Richard B. Wales, and Jean-loup Gailly.
Permission is granted to any individual or institution to use, copy, or
redistribute this software so long as all of the original files are included
unmodified, that it is not sold for profit, and that this copyright notice
is retained.
X
This file is a complete list of files mentioned in the above copyright.  Some
of the files in this list explicitly state in their text that they are public
domain or not copyrighted.  These files can be distributed separately and are
marked below with asterisks.
X
file            what it is
X----            ----------
contents        This file.
crypt.c         Code for encryption and decryption (not in export version).
crypt.h         Header used in implode modules to access encryption routines.
dir_os2.c       * Directory routines for OS/2.
dir_os2.h       * Definitions of functions in dir_os2.c.
doturboc.bat    Batch file for compiling under Turbo C 2.0.
fileio.c        System dependent routines (most of them anyway).
globals.c       Global variables.
history         List of changes in the versions leading up to this one.
im_bits.c       Output variable-length bit strings.
im_ctree.c      Encode source values using variable-length binary code trees.
im_lm.asm       An 80x86 assembler version of a routine in im_lmat.c.
im_lmat.c       Find redundant text in a sliding window.
implode.c       Implode compression method (calls other im* modules).
implode.h       Definitions of functions external to the im* modules.
infozip.who     List of contributors to the portable Zip project.
makecrc.c       * Generate the CRC table in util.c and shrink.c.
makefile        Unix make file.
makefile.bor    MSDOS Borland C++ make file.
makefile.exp    Export make file (leaves out encryption and zipcloak).
makefile.msc    MSDOS Microsoft C make file.
makefile.os2    OS/2 make file.
makefile.pwc    Power C make file.
makevms.com     VMS command file for compilation.
readme          Short file to point to zip.doc.
revision.h      Contains the program version number and revision date.
ship.c          * Encodes a binary stream into a mailable text stream.
ship.def        OS/2 def file for Ship.
shrink.c        Shrink compression method.
tailor.h        * Tailors the compilation to the system being compiled on.
tempf.c         Temporary memory/file interface.
tempf.h         Definitions of functions in tempf.c.
util.c          Miscellaneous utility routines.
zip.1           Source for the Zip man page (zip.doc).
zip.c           Main routine for Zip.
zip.def         OS/2 def file for Zip.
zip.doc         Documentation for Zip (zip.1 processed).
zip.h           Header for all Zip modules.
zip.prj         Project file for Borland (Turbo) C++.
zipcloak.c      Main routine for ZipCloak.
ziperr.h        Error messages in Zip.
zipfile.c       Zip file format handler.
zipnote.c       Main routine for ZipNote.
zipsplit.c      Main routine for ZipSplit.
zipup.c         Applies shrink and/or implode methods to compress an entry.
X
All of the files are in Unix (LF only) format execpt for the documentation
files, zip.prj, and doturboc.bat.  On MSDOS systems, you can use the -a
option of unzip to convert the source files to CRLF format.  This is only
necessary if you wish to edit the files--they will compile as is with
Microsoft C and Turbo/Borland C++ 1.0 or later.  However, you will have to
convert the files (using unzip -a) to the CRLF format to compile with the
older Turbo C 1.0 or 2.0.  You should be able to find unzip the same place
you found this.
END_OF_FILE
if test 3587 -ne `wc -c <'contents'`; then
    echo shar: \"'contents'\" unpacked with wrong size!
fi
# end of 'contents'
fi
if test -f 'crypt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'crypt.h'\"
else
echo shar: Extracting \"'crypt.h'\" \(1087 characters\)
sed "s/^X//" >'crypt.h' <<'END_OF_FILE'
X/*
X
X Copyright (C) 1990,1991 Mark Adler, Richard B. Wales, and Jean-loup Gailly.
X Permission is granted to any individual or institution to use, copy, or
X redistribute this software so long as all of the original files are included
X unmodified, that it is not sold for profit, and that this copyright notice
X is retained.
X
X*/
X
X/*
X *  crypt.h by Mark Adler.
X */
X
X/* Set up portability */
X#include "tailor.h"
X
X/* Define zfwrite() and zputc() functions */
X#ifdef EXPORT
X#  define zfwrite fwrite
X#  define zputc putc
X#else /* !EXPORT */
X   extern int zfwrite OF((voidp *, extent, extent, FILE *));
X   extern int zfputc OF((int, FILE *));
X   extern char *key;
X#  define zputc(b,f) (key!=NULL?zfputc(b,f):putc(b,f))
X#endif /* ?EXPORT */
X
X/* The implode routines now use the same temporary name generator */
char *tempname OF((int));
X
X/* I'm sneaking this in on Rich's code to make my compiler a bit happier */
X#ifdef NeXT
X   extern void free(voidp *);
X   extern voidp *qsort(voidp *, extent, extent, int (*)());
X   extern extent strlen(char *);
X   extern int unlink(char *);
X#endif /* NeXT */
END_OF_FILE
if test 1087 -ne `wc -c <'crypt.h'`; then
    echo shar: \"'crypt.h'\" unpacked with wrong size!
fi
# end of 'crypt.h'
fi
if test -f 'dir_os2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dir_os2.c'\"
else
echo shar: Extracting \"'dir_os2.c'\" \(5569 characters\)
sed "s/^X//" >'dir_os2.c' <<'END_OF_FILE'
X/*
X * @(#)dir.c 1.4 87/11/06 Public Domain.
X *
X *  A public domain implementation of BSD directory routines for
X *  MS-DOS.  Written by Michael Rendell ({uunet,utai}michael@garfield),
X *  August 1897
X *  Ported to OS/2 by Kai Uwe Rommel
X *  December 1989, February 1990
X *  Change for HPFS support, October 1990
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <malloc.h>
X#include <string.h>
X#include <ctype.h>
X
X#define INCL_NOPM
X#include <os2.h>
X
X#include "dir_os2.h"
X
X
int attributes = A_DIR | A_HIDDEN;
X
X
static char *getdirent(char *);
static void free_dircontents(struct _dircontents *);
X
static HDIR hdir;
static USHORT count;
static FILEFINDBUF find;
X
X
DIR *opendir(char *name)
X{
X  struct stat statb;
X  DIR *dirp;
X  char c;
X  char *s;
X  struct _dircontents *dp;
X  char nbuf[MAXPATHLEN + 1];
X  int len;
X
X  strcpy(nbuf, name);
X  len = strlen (nbuf);
X  s = nbuf + len;
X
X#if 1
X  if ( ((c = nbuf[strlen(nbuf) - 1]) == '\\' || c == '/') &&
X       (strlen(nbuf) > 1) )
X  {
X    nbuf[strlen(nbuf) - 1] = 0;
X
X    if ( nbuf[strlen(nbuf) - 1] == ':' )
X      strcat(nbuf, "\\.");
X  }
X  else
X    if ( nbuf[strlen(nbuf) - 1] == ':' )
X      strcat(nbuf, ".");
X#else
X  if ( len && ((c = nbuf[len-1]) == '\\' || c == '/' || c == ':') )
X  {
X    nbuf[len++] = '.';      /* s now points to '.' */
X    nbuf[len] = 0;
X  }
X#endif
X
X  if (stat(nbuf, &statb) < 0 || (statb.st_mode & S_IFMT) != S_IFDIR)
X    return NULL;
X
X  if ( (dirp = malloc(sizeof(DIR))) == NULL )
X    return NULL;
X
X#if 1
X  if ( nbuf[strlen(nbuf) - 1] == '.' )
X    strcpy(nbuf + strlen(nbuf) - 1, "*.*");
X  else
X    if ( ((c = nbuf[strlen(nbuf) - 1]) == '\\' || c == '/') &&
X         (strlen(nbuf) == 1) )
X      strcat(nbuf, "*.*");
X    else
X      strcat(nbuf, "\\*.*");
X#else
X  if ( *s == 0 )
X    *s++ = '\\';
X
X  strcpy (s, "*.*");
X#endif
X
X  dirp -> dd_loc = 0;
X  dirp -> dd_contents = dirp -> dd_cp = NULL;
X
X  if ((s = getdirent(nbuf)) == NULL)
X    return dirp;
X
X  do
X  {
X    if (((dp = malloc(sizeof(struct _dircontents))) == NULL) ||
X        ((dp -> _d_entry = malloc(strlen(s) + 1)) == NULL)      )
X    {
X      if (dp)
X        free(dp);
X      free_dircontents(dirp -> dd_contents);
X
X      return NULL;
X    }
X
X    if (dirp -> dd_contents)
X    {
X      dirp -> dd_cp -> _d_next = dp;
X      dirp -> dd_cp = dirp -> dd_cp -> _d_next;
X    }
X    else
X      dirp -> dd_contents = dirp -> dd_cp = dp;
X
X    strcpy(dp -> _d_entry, s);
X    dp -> _d_next = NULL;
X
X    dp -> _d_size = find.cbFile;
X    dp -> _d_mode = find.attrFile;
X    dp -> _d_time = *(unsigned *) &(find.ftimeLastWrite);
X    dp -> _d_date = *(unsigned *) &(find.fdateLastWrite);
X  }
X  while ((s = getdirent(NULL)) != NULL);
X
X  dirp -> dd_cp = dirp -> dd_contents;
X
X  return dirp;
X}
X
X
void closedir(DIR * dirp)
X{
X  free_dircontents(dirp -> dd_contents);
X  free(dirp);
X}
X
X
struct direct *readdir(DIR * dirp)
X{
X  static struct direct dp;
X
X  if (dirp -> dd_cp == NULL)
X    return NULL;
X
X  dp.d_namlen = dp.d_reclen =
X    strlen(strcpy(dp.d_name, dirp -> dd_cp -> _d_entry));
X
X  dp.d_ino = 0;
X
X  dp.d_size = dirp -> dd_cp -> _d_size;
X  dp.d_mode = dirp -> dd_cp -> _d_mode;
X  dp.d_time = dirp -> dd_cp -> _d_time;
X  dp.d_date = dirp -> dd_cp -> _d_date;
X
X  dirp -> dd_cp = dirp -> dd_cp -> _d_next;
X  dirp -> dd_loc++;
X
X  return &dp;
X}
X
X
void seekdir(DIR * dirp, long off)
X{
X  long i = off;
X  struct _dircontents *dp;
X
X  if (off >= 0)
X  {
X    for (dp = dirp -> dd_contents; --i >= 0 && dp; dp = dp -> _d_next);
X
X    dirp -> dd_loc = off - (i + 1);
X    dirp -> dd_cp = dp;
X  }
X}
X
X
long telldir(DIR * dirp)
X{
X  return dirp -> dd_loc;
X}
X
X
static void free_dircontents(struct _dircontents * dp)
X{
X  struct _dircontents *odp;
X
X  while (dp)
X  {
X    if (dp -> _d_entry)
X      free(dp -> _d_entry);
X
X    dp = (odp = dp) -> _d_next;
X    free(odp);
X  }
X}
X
X
static char *getdirent(char *dir)
X{
X  int done;
X
X  if (dir != NULL)
X  {                                    /* get first entry */
X    hdir = HDIR_CREATE;
X    count = 1;
X    done = DosFindFirst(dir, &hdir, attributes,
X                        &find, sizeof(find), &count, 0L);
X  }
X  else                                 /* get next entry */
X    done = DosFindNext(hdir, &find, sizeof(find), &count);
X
X  if (done == 0)
X    return find.achName;
X  else
X  {
X    DosFindClose(hdir);
X    return NULL;
X  }
X}
X
X
X/* ISFAT.C
X *
X * Autor:    Kai Uwe Rommel
X * Datum:    Sun 28-Oct-1990
X *
X * Compiler: MS C ab 6.00
X * System:   OS/2 ab 1.2
X */
X
X#define LABEL    "isfat.c"
X#define VERSION  "1.0"
X
X
X/* #include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <ctype.h>
X 
X#define INCL_NOPM
X#include <os2.h> */
X
X
int IsFileSystemFAT(char *dir)
X{
X  USHORT nDrive;
X  ULONG lMap;
X  BYTE bData[64], bName[3];
X  USHORT cbData;
X  static USHORT nLastDrive = -1, nResult;
X
X  if ( _osmode == DOS_MODE )
X    return TRUE;
X  else
X  {
X    /* We separate FAT and HPFS+other file systems here.
X       at the moment I consider other systems to be similar to HPFS,
X       i.e. support long file names and beeing case sensitive */
X
X    if ( isalpha(dir[0]) && (dir[1] == ':') )
X      nDrive = toupper(dir[0]) - '@';
X    else
X      DosQCurDisk(&nDrive, &lMap);
X
X    if ( nDrive == nLastDrive )
X      return nResult;
X
X    bName[0] = (char) (nDrive + '@');
X    bName[1] = ':';
X    bName[2] = 0;
X
X    nLastDrive = nDrive;
X    cbData = sizeof(bData);
X
X    if ( !DosQFSAttach(bName, 0U, 1U, bData, &cbData, 0L) )
X      nResult = !strcmp(bData + (*(USHORT *) (bData + 2) + 7), "FAT");
X    else
X      nResult = FALSE;
X
X    /* End of this ugly code */
X    return nResult;
X  }
X}
X
X
X
X/* End of ISFAT.C */
END_OF_FILE
if test 5569 -ne `wc -c <'dir_os2.c'`; then
    echo shar: \"'dir_os2.c'\" unpacked with wrong size!
fi
# end of 'dir_os2.c'
fi
if test -f 'dir_os2.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dir_os2.h'\"
else
echo shar: Extracting \"'dir_os2.h'\" \(1975 characters\)
sed "s/^X//" >'dir_os2.h' <<'END_OF_FILE'
X/*
X * @(#) dir.h 1.4 87/11/06   Public Domain.
X *
X *  A public domain implementation of BSD directory routines for
X *  MS-DOS.  Written by Michael Rendell ({uunet,utai}michael@garfield),
X *  August 1987
X *
X *  Enhanced and ported to OS/2 by Kai Uwe Rommel; added scandir() prototype
X *  December 1989, February 1990
X *  Change of MAXPATHLEN for HPFS, October 1990
X */
X
X
X#define MAXNAMLEN  256
X#define MAXPATHLEN 256
X
X#define A_RONLY    0x01
X#define A_HIDDEN   0x02
X#define A_SYSTEM   0x04
X#define A_LABEL    0x08
X#define A_DIR      0x10
X#define A_ARCHIVE  0x20
X
X
struct direct
X{
X  ino_t    d_ino;                   /* a bit of a farce */
X  int      d_reclen;                /* more farce */
X  int      d_namlen;                /* length of d_name */
X  char     d_name[MAXNAMLEN + 1];   /* null terminated */
X  /* nonstandard fields */
X  long     d_size;                  /* size in bytes */
X  unsigned d_mode;                  /* DOS or OS/2 file attributes */
X  unsigned d_time;
X  unsigned d_date;
X};
X
X/* The fields d_size and d_mode are extensions by me (Kai Uwe Rommel).
X * The find_first and find_next calls deliver this data without any extra cost.
X * If this data is needed, these fields save a lot of extra calls to stat() 
X * (each stat() again performs a find_first call !).
X */
X
struct _dircontents
X{
X  char *_d_entry;
X  long _d_size;
X  unsigned _d_mode, _d_time, _d_date;
X  struct _dircontents *_d_next;
X};
X
typedef struct _dirdesc
X{
X  int  dd_id;                   /* uniquely identify each open directory */
X  long dd_loc;                  /* where we are in directory entry is this */
X  struct _dircontents *dd_contents;   /* pointer to contents of dir */
X  struct _dircontents *dd_cp;         /* pointer to current position */
X}
DIR;
X
X
extern int attributes;
X
extern DIR *opendir(char *);
extern struct direct *readdir(DIR *);
extern void seekdir(DIR *, long);
extern long telldir(DIR *);
extern void closedir(DIR *);
X#define rewinddir(dirp) seekdir(dirp, 0L)
END_OF_FILE
if test 1975 -ne `wc -c <'dir_os2.h'`; then
    echo shar: \"'dir_os2.h'\" unpacked with wrong size!
fi
# end of 'dir_os2.h'
fi
if test -f 'doturboc.bat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doturboc.bat'\"
else
echo shar: Extracting \"'doturboc.bat'\" \(574 characters\)
sed "s/^X//" >'doturboc.bat' <<'END_OF_FILE'
X: This file is a complement to zip.prj for Turbo C 2.0 users.
X: Use it to assemble im_lm.asm then enter TC, change the compilation
X: model from small to compact if you wish (thus removing a limitation on
X: the number of files but getting slower code), and press F9...
X: Note: currently, im_lm.asm does not work in the compact model with Turbo C.
X: If you wish to use the compact model, #define NO_ASM in im_lmat.c and
X: remove im_lm.obj from zip.prj.
tasm -t -ml -DDYN_ALLOC im_lm;
X: Let's do ship while we're here
tcc -w -a -d -G -O -Z -ms -Ic:\tc\include -Lc:\tc\lib ship
END_OF_FILE
if test 574 -ne `wc -c <'doturboc.bat'`; then
    echo shar: \"'doturboc.bat'\" unpacked with wrong size!
fi
# end of 'doturboc.bat'
fi
if test -f 'globals.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'globals.c'\"
else
echo shar: Extracting \"'globals.c'\" \(2276 characters\)
sed "s/^X//" >'globals.c' <<'END_OF_FILE'
X/*
X
X Copyright (C) 1990,1991 Mark Adler, Richard B. Wales, and Jean-loup Gailly.
X Permission is granted to any individual or institution to use, copy, or
X redistribute this software so long as all of the original files are included
X unmodified, that it is not sold for profit, and that this copyright notice
X is retained.
X
X*/
X
X/*
X *  globals.c by Mark Adler.
X */
X
X#define GLOBALS         /* include definition of errors[] in zip.h */
X#include "zip.h"
X
X
X/* Handy place to build error messages */
char errbuf[FNMAX+81];
X
X/* Argument processing globals */
int recurse = 0;        /* 1=recurse into directories encountered */
int pathput = 1;        /* 1=store path with name */
int method = BEST;      /* one of BEST, SHRINK (only), or IMPLODE (only) */
int dosify = 0;         /* 1=make new entries look like MSDOS */
int verbose = 0;        /* 1=report oddities in zip file structure */
int level = 5;          /* 0=fastest compression, 9=best compression */
X#ifdef VMS
X   int vmsver = 0;      /* 1=append VMS version number to file names */
X#endif /* VMS */
int linkput = 0;        /* 1=store symbolic links as such */
int noisy = 1;          /* 0=quiet operation */
char *special = NULL;   /* List of special suffixes */
char *key = NULL;       /* Scramble password if scrambling */
char *tempath = NULL;   /* Path for temporary files */
X
X/* Zip file globals */
char *zipfile;          /* New or existing zip archive (zip file) */
ulg zipbeg;             /* Starting offset of zip structures */
ulg cenbeg;             /* Starting offset of central directory */
struct zlist far *zfiles = NULL;  /* Pointer to list of files in zip file */
extent zcount;          /* Number of files in zip file */
extent zcomlen;         /* Length of zip file comment */
char *zcomment;         /* Zip file comment (not zero-terminated) */
struct zlist far **zsort;       /* List of files sorted by name */
X
X/* Files to operate on that are not in zip file */
struct flist far *found = NULL; /* List of names found */
struct flist far * far *fnxt;   /* Where to put next name in found list */
extent fcount;          /* Count of files in list */
X
X/* Flags for cleaning up after compression routines */
int shract = 0;         /* Shrink active */
int impact = 0;         /* Implosion active */
END_OF_FILE
if test 2276 -ne `wc -c <'globals.c'`; then
    echo shar: \"'globals.c'\" unpacked with wrong size!
fi
# end of 'globals.c'
fi
if test -f 'im_bits.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'im_bits.c'\"
else
echo shar: Extracting \"'im_bits.c'\" \(4743 characters\)
sed "s/^X//" >'im_bits.c' <<'END_OF_FILE'
X/*
X
X Copyright (C) 1990,1991 Mark Adler, Richard B. Wales, and Jean-loup Gailly.
X Permission is granted to any individual or institution to use, copy, or
X redistribute this software so long as all of the original files are included
X unmodified, that it is not sold for profit, and that this copyright notice
X is retained.
X
X*/
X
X/*
X *  im_bits.c by Richard B. Wales & Jean-loup Gailly.
X *
X *  PURPOSE
X *
X *      Output variable-length bit strings.
X *
X *  DISCUSSION
X *
X *      The PKZIP "imploded" file format interprets compressed file data
X *      as a sequence of bits.  Multi-bit strings in the file may cross
X *      byte boundaries without restriction.
X *
X *      The first bit of each byte is the low-order bit.
X *
X *      The routines in this file allow a variable-length bit value to
X *      be output right-to-left (useful for literal values). For
X *      left-to-right output (useful for code strings from the tree routines),
X *      the bits must have been reversed first with bi_reverse().
X *
X *  INTERFACE
X *
X *      ImpErr bi_init (FILE *fp)
X *          Initialize the bit string routines and specify the output
X *          file to be written to in subsequent calls.
X *
X *      ImpErr bi_rlout (int value, int length)
X *          Write out a bit string, taking the source bits right to
X *          left.
X *
X *      int bi_reverse (int value, int length)
X *          Reverse the bits of a bit string, taking the source bits left to
X *          right and emitting them right to left.
X *
X *      ImpErr bi_windup (void)
X *          Write out any remaining bits in an incomplete byte.
X */
X
X
X#include "implode.h"
X
X
X/***********************************************************************
X *
X * Local data used by the "bit string" routines.
X */
X
X
X/* Current file stream pointer. */
local   FILE *  bi_fp;
X
local unsigned short bi_buf;
X/* Output buffer. bits are inserted starting at the bottom (least significant
X * bits).
X */
X
X#define Buf_size (8 * 2*sizeof(char))
X/* Number of bits used within bi_buf. (bi_buf might be implemented on
X * more than 16 bits on some systems.)
X */
X
local int bi_valid;                  /* number of valid bits in bi_buf */
X/* All bits above the last valid bit are always zero.
X */
X
X/* Output a 16 bit value to the bit stream, lower (oldest) byte first */
X#define PUTSHORT(w) \
X{  (void) zputc ((char)((w) & 0xff), bi_fp); \
X   (void) zputc ((char)((US_INT)(w) >> 8), bi_fp); \
X   if (ferror (bi_fp)) return IM_IOERR; \
X}
X
X/* Output an 8 bit value to the bit stream, bits right to left */
X#define PUTBYTE(w) \
X{  (void) zputc ((char)((w) & 0xff), bi_fp); \
X   if (ferror (bi_fp)) return IM_IOERR; \
X}
X
X/***********************************************************************
X *
X * Initialize the bit string routines.
X */
X
ImpErr
bi_init (fp)
X    FILE *fp;
X{   if (fp == NULL)
X    {   fprintf (stderr, "\nError in bi_init: null file pointer");
X        return IM_LOGICERR;
X    }
X    bi_fp   = fp;
X    bi_buf = 0;
X    bi_valid = 0;
X    return IM_OK;
X}
X
X
X/***********************************************************************
X *
X * Output bits from right to left.
X */
X
ImpErr
bi_rlout (value, length)
X    int value;
X    int length; /* must be <= 16 */
X{
X    /* Send value on length bits. If not enough room in bi_buf, use
X     * (valid) bits from bi_buf and (16 - bi_valid) bits from value, leaving
X     * (width - (16-bi_valid)) unused bits in value.
X     */
X    if (bi_valid > Buf_size - length) {
X        bi_buf |= (value << bi_valid);
X        PUTSHORT(bi_buf);
X        bi_buf = (unsigned short)value >> (Buf_size - bi_valid);
X        bi_valid += length - Buf_size;
X    } else {
X        bi_buf |= value << bi_valid;
X        bi_valid += length;
X    }
X#ifdef  IMPDEBUG
X    fprintf (stderr, " / ");
X    while (length-- > 0)
X    {
X        putc ((value & 1) ? '1' : '0', stderr);
X        value >>= 1;
X    }
X#endif  /* IMPDEBUG */
X    return IM_OK;
X}
X
X
X/***********************************************************************
X *
X * Reverse the bits of a bit string, taking the source bits left to
X * right (starting at 2^15) and emitting them right to left.
X */
X
int
bi_reverse (value, length)
X    int value;
X    int length;
X{
X    int result = 0;
X    unsigned short lbit = 0x8000;
X    unsigned short rbit = 1;
X    while (length-- > 0) {
X       if (value & lbit) result |= rbit;
X       lbit >>= 1, rbit <<= 1;
X    }
X    return result;
X}
X
X
X/***********************************************************************
X *
X * Flush any remaining bits.
X */
X
ImpErr
bi_windup ()
X{
X    if (bi_valid > 8) {
X        PUTSHORT(bi_buf);
X    } else if (bi_valid > 0) {
X        PUTBYTE(bi_buf);
X    }
X    bi_buf = 0;
X    bi_valid = 0;
X    return IM_OK;
X}
X
X
X/**********************************************************************/
END_OF_FILE
if test 4743 -ne `wc -c <'im_bits.c'`; then
    echo shar: \"'im_bits.c'\" unpacked with wrong size!
fi
# end of 'im_bits.c'
fi
if test -f 'implode.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'implode.h'\"
else
echo shar: Extracting \"'implode.h'\" \(4579 characters\)
sed "s/^X//" >'implode.h' <<'END_OF_FILE'
X/*
X
X Copyright (C) 1990,1991 Mark Adler, Richard B. Wales, and Jean-loup Gailly.
X Permission is granted to any individual or institution to use, copy, or
X redistribute this software so long as all of the original files are included
X unmodified, that it is not sold for profit, and that this copyright notice
X is retained.
X
X*/
X
X/*
X * implode.h by Richard B. Wales.
X */
X
X#include "crypt.h"
X#include "tempf.h"
X#include <errno.h>
X
X
X/***********************************************************************
X *
X * Type definitions.
X */
X
X
typedef long  L_INT;
typedef int   INT;
typedef short S_INT;
X
typedef unsigned long  UL_INT;
typedef unsigned int   U_INT;
typedef unsigned short US_INT;
X
typedef unsigned char  U_CHAR;
X
typedef unsigned long  CRC;
X
X#define VOID void
X
X#define local static            /* More meaningful outside functions */
X/* #define local */
X
X#define TRUE  1
X#define FALSE 0
X
X/* Error return codes. */
typedef
enum
X    {   IM_OK,                  /* all OK */
X        IM_EOF,                 /* end of file on input */
X        IM_IOERR,               /* I/O error */
X        IM_BADARG,              /* invalid procedure argument */
X        IM_NOMEM,               /* out of memory */
X        IM_LOGICERR,            /* logic error */
X        IM_NOCTBLS              /* no more code tables */
X    }
X    ImpErr;
X
X/* The different possible compression methods. */
typedef
enum
X    {   NO_LITERAL_TREE,        /* use only two trees */
X        LITERAL_TREE            /* use all three trees */
X    }
X    Method;
X
X/* File data structure. */
typedef
struct  fdata
X    {   L_INT    fd_len;        /* # of bytes in file */
X        L_INT    fd_clen;       /* compressed length */
X        tFILE    *fd_temp;      /* temporary file stream pointer */
X        U_INT    fd_bufsize;    /* size of sliding dictionary */
X        U_INT    fd_strsize;    /* max string match length */
X        U_INT    fd_nbits;      /* # distance bits to write literally */
X        Method   fd_method;     /* compression method */
X    }
X    FDATA;
X
X/* Data structure for string matches. */
typedef
struct  match
X    {   S_INT       ma_dist;    /* distance back into buffer */
X        union {
X           US_INT   ma_length;  /* length of matched string */
X           U_CHAR   ma_litc[2]; /* literal characters matched */
X        } l;
X        /* l is ma_litc if ma_dist <= 0. If ma_dist < 0, the length is
X         * 2 and the distance is -ma_dist.
X         */
X    }
X    MATCH;
X
X
X/***********************************************************************
X *
X * External variable declarations.
X */
X
extern FDATA fd;                /* file data */
X#ifndef MSDOS
extern int errno;               /* system error code */
X#endif  /* MSDOS */
X
extern MATCH *ma_buf;           /* match info buffer */
X#define MA_BUFSIZE 512
X/* MA_BUFSIZE must be such that
X *     256*sizeof(TRDATA) <= MA_BUFSIZE*sizeof(MATCH)
X * since the same buffer is used for both purposes at different times.
X */
X
X/***********************************************************************
X *
X * External procedure declarations.
X */
X
X
X#ifdef  MODERN
X#include <string.h>
X#else
voidp *malloc();
char  *strcpy();
char  *strcat();
X#endif  /* MODERN */
X
X
X/***********************************************************************
X *
X * Routines in "im_lmat.c" source file.
X */
X
X
ImpErr  lm_init
X        OF ((int pack_level));
X
ImpErr  lm_input
X        OF ((U_CHAR *block, U_INT count));
X
ImpErr  lm_windup
X        OF ((void));
X
X
X/***********************************************************************
X *
X * Routines in "im_ctree.c" source file.
X */
X
ImpErr ct_init
X        OF ((void));
X
ImpErr ct_tally
X        OF ((MATCH *ma));
X
ImpErr ct_mktrees
X        OF ((void));
X
ImpErr ct_wrtrees
X        OF ((FILE *outfp));
X
ImpErr ct_wrdata
X        OF ((FILE *outfp));
X
ImpErr ct_windup
X        OF ((void));
X
X
X/***********************************************************************
X *
X * Routines in "im_bits.c" source file.
X */
X
ImpErr bi_init
X        OF ((FILE *fp));
X
ImpErr bi_rlout
X        OF ((int value, int length));
X
int bi_reverse
X        OF ((int value, int length));
X
ImpErr bi_windup
X        OF ((void));
X
X
X/***********************************************************************
X *
X * Routines in "implode.c" source file.
X */
X
int imp_setup
X        OF ((long filesize, int pack_level));
X
int imp_p1
X        OF ((char *buf, int count));
X
int imp_size
X        OF ((long *size, char *opts));
X
int imp_p2
X        OF ((FILE *outfp));
X
int imp_clear
X        OF ((void));
X
X
X/**********************************************************************/
END_OF_FILE
if test 4579 -ne `wc -c <'implode.h'`; then
    echo shar: \"'implode.h'\" unpacked with wrong size!
fi
# end of 'implode.h'
fi
if test -f 'infozip.who' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'infozip.who'\"
else
echo shar: Extracting \"'infozip.who'\" \(4521 characters\)
sed "s/^X//" >'infozip.who' <<'END_OF_FILE'
These members of the INFO-ZIP group contributed to the development and
testing of portable Zip.  They are responsible for whatever works in Zip.
Whatever doesn't work is solely the fault of the authors of Zip (Mark Adler,
Rich Wales, and Jean-loup Gailly).
X
Mark Adler              madler@tybalt.caltech.edu       NeXT 2.x
Glenn J. Andrews        oper1%drcv06.decnet@drcvax.af.mil       VAX VMS
Tom Betz                marob!upaya!tbetz@phri.nyu.edu  SCO Xenix 2.3.1
James Birdsall          jwbirdsa@amc.com                AT&T 3B1
Wim Bonner              27313853@WSUVM1.CSC.WSU.EDU     HP 9000/840a HPUX
Paul Borman             prb@cray.com                    Cray-X/YMP,2 UNICOS 6-8
Leslie C. Brown         lbrown@BRL.MIL                  Pyramid MIS-4
Ralf Brown              ralf@b.gp.cs.cmu.edu            Pyramid MIS-4
Pietro Caselli          zaphod@petruz.sublink.org       Minix 1.5.10
Bill Davidsen           davidsen@crdos1.crd.ge.com      Xenix (on what?)
Daniel Deimert          daniel@hexagon.se               zeus3.21 Zilog S8000
James P. Dugal          jpd@usl.edu                     Pyramid 90X OSx4.1
X"Evil Ed"               esaffle@gmuvax2.gmu.edu         Ulrix-32 V3.1 (Rev. 9)
Greg Flint              afc@klaatu.cc.purdue.edu        ETA-10P* hybrid Sys V
Jeff Foy                jfoy@glia.biostr.washington.edu IRIX Sys V Rel 3.3.1
Kevin M. Fritz          kmfritz@apgea.army.mil          Turbo C++ 1.0
Jean-loup Gailly        jloup@chorus.fr                 MS-DOS Microsoft C 5.1
Scott D. Galloway       sgallowa@letterkenn-emh1.army.mil   Sperry 5000 SysV.3
David Gundlach          david@rolf.stat.uga.edu         Sun SS1+ SunOS 4.1
Peter Jones             jones@mips1.info.uqam.ca        MIPS UMIPS 4.0
Bruce Kahn              bkahn@archive.webo.dg.com       MS-DOS Microsoft C 5.1
Bob Kemp                Robert.V.Kemp@ATT.COM           AT&T 3B2 SysV 3.2v2
XEarl Kiech              KIECH@utkvx.utk.edu             VAX VMS V5.4-1A
David Kirschbaum        kirsch@usasoc.soc.mil           He got us all in this
X                                                        mess in the first place
Bo Kullmar              bk@kullmar.se                   DNIX 5.2, 5.3
Harry Langenbacher      harry@neuron6.Jpl.Nasa.Gov      Sun SS1+ SunOS 4.1
Michael D. Lawler       mdlawler@bsu-cs.bsu.edu         Mt.Xinu BSD 4.3 on VAX
David Lemson            lemson@ux1.cso.uiuc.edu         Sequent Dynix 3.0.17
Onno van der Linden     linden@fwi.uva.nl               SCO Unix 3.2.0
Warner Losh             imp@Solbourne.COM               packing algorithm help
John Lundin             lundin@urvax.urich.edu          VAX VMS
Cliff Manis             root@csoftec.csf.com            SCO 2.3.1 (386)
Bill Marsh              bmarsh@cod.nosc.mil             SGI Iris 4D35
Robert McBroom (?)      rm3@ornl.gov                    DECsystem 5810
William O'Shaughnessy   williamo@hpcupt1.cup.hp.com     HPUX
XEnrico Renato Palmerini palmer@vxscaq.cineca.it         UNISYS 7000 Sys 5 r2.3
Keith Petersen          w8sdz@simtel20.army.mil         Maintainer of Info-ZIP
X                                                        Pyramid UCB OSx4.4c
David A Rasmussen       dave@convex.csd.uwm.edu         Convex C220 with 9.0 OS
Michael Regoli          mr@cica.indiana.edu             Ultrix 3.1 VAX 8650     
X                                                        BSD 4.3 IBM RT/125
X                                                        BSD 4.3 MicroVAX 3500
X                                                        SunOS 4.0.3 Sun 4/330
Greg Roelofs            roelofs@amelia.nas.nasa.gov     BSD 4.3 VAX 11/780
X                                                        VMS 5.2 VAX 8600
X                                                        UTS 1.2.4 Amdahl 5800
X                                                        Ultrix 4.1 DEC 5810
X                                                        Unicos 5.1, 6.0.11 Cray
X                                                        MS-DOS Microsoft C 6.0
X                                                        Irix 3.3.2, SGI Iris 4D
Kai Uwe Rommel          rommel@informatik.tu-muenchen.de        OS/2
Dave Sisson             daves@vtcosy.cns.vt.edu         AIX 1.1.1 PS/2 & 3090
Ron Srodawa             srodawa@vela.acs.oakland.edu    SCO Xenix/386 2.3.3
Bertil Stenstr|m        stenis@heron.qz.se              HP-UX 7.0 HP9000/835
Arjan de Vet            devet@info.win.tue.nl           SunOS 4.1, MSC 5.1
Rich Wales              wales@cs.ucla.edu               SunOS 4.0.3 Sun-3/50
END_OF_FILE
if test 4521 -ne `wc -c <'infozip.who'`; then
    echo shar: \"'infozip.who'\" unpacked with wrong size!
fi
# end of 'infozip.who'
fi
if test -f 'makecrc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makecrc.c'\"
else
echo shar: Extracting \"'makecrc.c'\" \(2388 characters\)
sed "s/^X//" >'makecrc.c' <<'END_OF_FILE'
X/* Not copyrighted 1990 Mark Adler */
X
X#include <stdio.h>
X
main()
X/*
X  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
X  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
X
X  Polynomials over GF(2) are represented in binary, one bit per coefficient,
X  with the lowest powers in the most significant bit.  Then adding polynomials
X  is just exclusive-or, and multiplying a polynomial by x is a right shift by
X  one.  If we call the above polynomial p, and represent a byte as the
X  polynomial q, also with the lowest power in the most significant bit (so the
X  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
X  where a mod b means the remainder after dividing a by b.
X
X  This calculation is done using the shift-register method of multiplying and
X  taking the remainder.  The register is initialized to zero, and for each
X  incoming bit, x^32 is added mod p to the register if the bit is a one (where
X  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
X  x (which is shifting right by one and adding x^32 mod p if the bit shifted
X  out is a one).  We start with the highest power (least significant bit) of
X  q and repeat for all eight bits of q.
X
X  The table is simply the CRC of all possible eight bit values.  This is all
X  the information needed to generate CRC's on data a byte at a time for all
X  combinations of CRC register values and incoming bytes.  The table is
X  written to stdout as 256 long hexadecimal values in C language format.
X*/
X{
X  unsigned long c;      /* crc shift register */
X  unsigned long e;      /* polynomial exclusive-or pattern */
X  int i;                /* counter for all possible eight bit values */
X  int k;                /* byte being shifted into crc apparatus */
X
X  /* terms of polynomial defining this crc (except x^32): */
X  static int p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
X
X  /* Make exclusive-or pattern from polynomial */
X  e = 0;
X  for (i = 0; i < sizeof(p)/sizeof(int); i++)
X    e |= 1L << (31 - p[i]);
X
X  /* Compute and print table of CRC's, five per line */
X  printf("  0x00000000L");
X  for (i = 1; i < 256; i++)
X  {
X    c = 0;
X    for (k = i | 256; k != 1; k >>= 1)
X    {
X      c = c & 1 ? (c >> 1) ^ e : c >> 1;
X      if (k & 1)
X        c ^= e;
X    }
X    printf(i % 5 ? ", 0x%08lxL" : ",\n  0x%08lxL", c);
X  }
X  putchar('\n');
X  return 0;
X}
END_OF_FILE
if test 2388 -ne `wc -c <'makecrc.c'`; then
    echo shar: \"'makecrc.c'\" unpacked with wrong size!
fi
# end of 'makecrc.c'
fi
if test -f 'makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile'\"
else
echo shar: Extracting \"'makefile'\" \(4489 characters\)
sed "s/^X//" >'makefile' <<'END_OF_FILE'
X# Makefile for Zip, ZipNote, ZipSplit, and Ship.
X# Note: this makefile leaves out the encryption/decryption part of zip, and
X#  completely leaves out the zipcloak program.
X
X# what you can make ...
default:
X	@echo ''
X	@echo 'Make what?  You must say what system to make Zip for--e.g.'
X	@echo '"make bsd".  Choices: bsd, bsdold, sysv, sun, next, next10,'
X	@echo 'hpux, dnix, cray, 3b1, zilog, aux, convex, aix, and minix.'
X	@echo 'See the file zip.doc for more information.'
X	@echo ''
X
X# variables (to use the Gnu compiler, change cc to gcc in CC and BIND)
MAKE = make
CC = cc
BIND = cc
RENAME = mv
X
X# flags
X#   CFLAGS    flags for C compile
X#   LFLAGS1   flags after output file spec, before obj file list
X#   LFLAGS2   flags after obj file list (libraries, etc)
CFLAGS =
LFLAGS1 =
LFLAGS2 = -s
X
X# object file lists
OBJZ = zip.o zipfile.o zipup.o fileio.o util.o tempf.o shrink.o globals.o
OBJI = implode.o im_lmat.o im_ctree.o im_bits.o
OBJN = zipnote.o zipfile_.o zipup_.o fileio_.o globals.o
OBJS = zipsplit.o zipfile_.o zipup_.o fileio_.o globals.o
X
X# suffix rules
X.SUFFIXES:
X.SUFFIXES: _.o .o .c .doc .1
X.c_.o:
X	$(RENAME) $< $*_.c
X	$(CC) $(CFLAGS) -DUTIL -DEXPORT -c $*_.c
X	$(RENAME) $*_.c $<
X.c.o:
X	$(CC) $(CFLAGS) -DEXPORT -c $<
X.1.doc:
X	nroff -man $< | col -b > $@
X
X# rules for zip, zipnote, zipsplit, and zip.doc.
X$(OBJZ): zip.h ziperr.h tempf.h tailor.h
X$(OBJI): implode.h crypt.h ziperr.h tempf.h tailor.h
X$(OBJN): zip.h ziperr.h tailor.h
X$(OBJS): zip.h ziperr.h tailor.h
zip.o zipup.o zipnote.o zipsplit.o: revision.h
zips: zip zipnote zipsplit ship
zipsman: zip zipnote zipsplit ship zip.doc
zip: $(OBJZ) $(OBJI)
X	$(BIND) -o zip $(LFLAGS1) $(OBJZ) $(OBJI) $(LFLAGS2)
zipnote: $(OBJN)
X	$(BIND) -o zipnote $(LFLAGS1) $(OBJN) $(LFLAGS2)
zipsplit: $(OBJS)
X	$(BIND) -o zipsplit $(LFLAGS1) $(OBJS) $(LFLAGS2)
ship: ship.c
X	$(CC) $(CFLAGS) -o ship $(LFLAGS1) ship.c $(LFLAGS2)
X
X# These symbols, when #defined using -D have these effects on compilation:
X# ZMEM		- includes C language versions of memset(), memcpy(), and
X#		  memcmp() (util.c).
X# DIRENT	- use <sys/dirent.h> and getdents() instead of <sys/dir.h>
X#		  and opendir(), etc. (fileio.c).
X# NODIR		- used for 3B1, which has neither getdents() nor opendir().
X# NDIR		- use "ndir.h" instead of <sys/dir.h> (fileio.c).
X# UTIL		- select routines for utilities (note and split).
X# PROTO		- enable function prototypes.
X# RMDIR		- remove directories using a system("rmdir ...") call.
X# CONVEX	- for Convex make target.
X# AIX		- for AIX make target.
X# EXPORT	- leave out the encryption code.
X
X# BSD 4.3 (also Unisys 7000--AT&T System V with heavy BSD 4.2)
bsd:
X	$(MAKE) zips CFLAGS="-O"
X
X# BSD, but missing memset(), memcmp().
bsdold:
X	$(MAKE) zips CFLAGS="-O -DZMEM"
X
X# AT&T System V, Rel 3.  Also SCO, Xenix, OpenDeskTop, ETA-10P*, SGI.
sysv:
X	$(MAKE) zips CFLAGS="-O -DDIRENT"
X
X# DNIX 5.x: like System V but optimization is messed up.
dnix:
X	$(MAKE) zips CFLAGS="-DDIRENT"
X
X# Sun OS 4.x: BSD, but use getdents().
sun:
X	$(MAKE) zips CFLAGS="-O -DDIRENT"
X
X# NeXT 1.0: BSD, but use shared library.
next10:
X	$(MAKE) zips CFLAGS="-O" LFLAGS2="-s -lsys_s"
X
X# NeXT 2.0: BSD, but use MH_OBJECT format for smaller executables.
next:
X	$(MAKE) zips CFLAGS="-O" LFLAGS2="-s -object"
X
X# HPUX: System V, but use <ndir.h> and opendir(), etc.
hpux:
X	$(MAKE) zips CFLAGS="-O -DNDIR"
X
X# Cray Unicos 5.1.10 & 6.0.11, Standard C compiler 2.0
cray:
X	$(MAKE) zips CFLAGS="-O -DDIRENT" CC="scc"
X
X# AT&T 3B1: System V, but missing a few things.
X3b1:
X	$(MAKE) zips CFLAGS="-O -DNODIR -DRMDIR"
X
X# zilog zeus 3.21
zilog:
X	$(MAKE) zips CFLAGS="-O -DZMEM -DNDIR -DRMDIR" CC="scc -i"
X
X# SCO 386 cross compile for MS-DOS
X# Note: zip.exe should be lzexe'd on DOS to reduce its size
scodos:
X	$(MAKE) zips CFLAGS="-O -Ms -dos -DNO_ASM" LFLAGS1="-Ms -dos" \
X	 LFLAGS2=""
X	$(RENAME) zip zip.exe
X
X# A/UX:
aux:
X	$(MAKE) zips CFLAGS="-O -DTERMIO"
X
X# Convex C220, OS 9.0
convex:
X	$(MAKE) zips CFLAGS="-O2 -rl -DCONVEX"
X
X# AIX Version 3.1 for RISC System/6000 
aix:
X	$(MAKE) zips CC="c89" BIND="c89" \
X	   CFLAGS="-O -D_POSIX_SOURCE -D_ALL_SOURCE -D_BSD -DAIX"
X
X# MINIX 1.5.10 with Bruce Evans 386 patches and gcc/GNU make
minix:
X	$(MAKE) zips CFLAGS="-O -DDIRENT -DMINIX" CC=gcc BIND=gcc
X	chmem =262144 zip
X
X# clean up after making stuff and installing it
clean:
X	rm -f *.o
X	rm -f zip zipnote zipsplit ship
X
X# This one's for my own use during development.
it:
X	$(MAKE) zipsman CFLAGS="-O -Wall -DPROTO" LFLAGS2="-s -object"\
X	VPATH="${HOME}/Unix/bin"
X
X# end of Makefile
END_OF_FILE
if test 4489 -ne `wc -c <'makefile'`; then
    echo shar: \"'makefile'\" unpacked with wrong size!
fi
# end of 'makefile'
fi
if test -f 'makefile.bor' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.bor'\"
else
echo shar: Extracting \"'makefile.bor'\" \(3300 characters\)
sed "s/^X//" >'makefile.bor' <<'END_OF_FILE'
X# Makefile for Zip, ZipNote, ZipSplit, and Ship, for
X# Borland (Turbo) C++ 1.0 or 2.0.
X# Warning: this file is not suitable for Turbo C 2.0. Use zip.prj instead.
X
X# To use, do "make -fmakefile.bor"
X# If you do not have masm or tasm, or if you are using the compact model,
X# then add -DNO_ASM to CFLAGS and remove im_lm.obj from OBJI
X
X# Warning: the default used here is the small model, which produces
X# faster code, but imposes some limitation on the number of files
X# that zip can process. Compile with the compact model to remove these
X# limitations.
X
X# ------------- Turbo C++, Borland C++ -------------
MODEL=-ms
X#   Change to -mc for compact model
CFLAGS=-w -w-eff -w-def -w-sig -a -d -G -O -Z $(MODEL) -DEXPORT
UTILFLAGS=-DUTIL $(CFLAGS) -o
CC=bcc
LD=bcc
X#   replace bcc with tcc for Turbo C++ 1.0
LDFLAGS=$(MODEL)
AS=tasm
ASFLAGS=-ml -t -DDYN_ALLOC
X
X# ------------- Common declarations:
STRIP=rem
X#    If you don't have lzexe, get it. Then define:
X#STRIP=lzexe
X#    This makes a big difference in .exe size (and possibly load time)
X
X# variables
OBJZ = zip.obj zipfile.obj zipup.obj fileio.obj util.obj tempf.obj shrink.obj\
X globals.obj
OBJI = implode.obj im_lmat.obj im_ctree.obj im_bits.obj im_lm.obj
X# remove im_lm.obj in above line if you do not have masm
X
OBJN = zipnote.obj zipfile_.obj zipup_.obj fileio_.obj globals.obj
OBJS = zipsplit.obj zipfile_.obj zipup_.obj fileio_.obj globals.obj
X
zips:	zip.exe zipnote.exe zipsplit.exe ship.exe
X
zip.obj:	zip.h ziperr.h tailor.h revision.h zip.c
X	$(CC) -c $(CFLAGS) $*.c
X
zipfile.obj:	zip.h ziperr.h tailor.h zipfile.c
X	$(CC) -c $(CFLAGS) $*.c
X
zipup.obj:	zip.h ziperr.h tailor.h revision.h zipup.c
X	$(CC) -c $(CFLAGS) $*.c
X
fileio.obj:	zip.h ziperr.h tailor.h fileio.c
X	$(CC) -c $(CFLAGS) $*.c
X
util.obj:	zip.h ziperr.h tailor.h util.c
X	$(CC) -c $(CFLAGS) $*.c
X
tempf.obj:	tempf.h tailor.h tempf.c
X	$(CC) -c $(CFLAGS) $*.c
X
shrink.obj:	zip.h ziperr.h tempf.h tailor.h shrink.c
X	$(CC) -c $(CFLAGS) $*.c
X
globals.obj:	zip.h ziperr.h tailor.h globals.c
X	$(CC) -c $(CFLAGS) $*.c
X
zipnote.obj:	zip.h ziperr.h tailor.h revision.h zipnote.c
X	$(CC) -c $(CFLAGS) $*.c
X
zipsplit.obj:	zipsplit.c zip.h ziperr.h tailor.h revision.h
X	$(CC) -c $(CFLAGS) $*.c
X
implode.obj:	implode.h crypt.h ziperr.h tempf.h tailor.h implode.c
X	$(CC) -c $(CFLAGS) $*.c
X
im_lmat.obj:	implode.h crypt.h ziperr.h tempf.h tailor.h im_lmat.c
X	$(CC) -c $(CFLAGS) $*.c
X
im_lm.obj:	im_lm.asm
X	$(AS) $(ASFLAGS) im_lm;
X
im_ctree.obj:	implode.h crypt.h ziperr.h tempf.h tailor.h im_ctree.c
X	$(CC) -c $(CFLAGS) $*.c
X
im_bits.obj:	implode.h crypt.h ziperr.h tempf.h tailor.h im_bits.c
X	$(CC) -c $(CFLAGS) $*.c
X
zipfile_.obj:	zipfile.c zip.h
X	$(CC) -c $(UTILFLAGS)$* zipfile.c
X
zipup_.obj:	zipup.c zip.h
X	$(CC) -c $(UTILFLAGS)$* zipup.c
X
fileio_.obj:	fileio.c zip.h
X	$(CC) -c $(UTILFLAGS)$* fileio.c
X
X# we must cut the command line to fit in the MS/DOS 128 byte limit:
zip.exe: $(OBJZ) $(OBJI)
X	echo $(OBJZ) > zip.rsp
X	echo $(OBJI) >> zip.rsp
X	$(LD) $(LDFLAGS) @zip.rsp
X	del zip.rsp
X	$(STRIP) zip.exe
X
zipnote.exe: $(OBJN)
X	echo $(OBJN) > zipn.rsp
X	$(LD) $(LDFLAGS) @zipn.rsp
X	del zipn.rsp
X	$(STRIP) zipnote.exe
X
zipsplit.exe: $(OBJS)
X	echo $(OBJS) > zips.rsp
X	$(LD) $(LDFLAGS) @zips.rsp
X	del zips.rsp
X	$(STRIP) zipsplit.exe
X
ship.exe: ship.c
X	$(CC) $(CFLAGS) ship.c
X	$(STRIP) ship.exe
END_OF_FILE
if test 3300 -ne `wc -c <'makefile.bor'`; then
    echo shar: \"'makefile.bor'\" unpacked with wrong size!
fi
# end of 'makefile.bor'
fi
if test -f 'makefile.msc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.msc'\"
else
echo shar: Extracting \"'makefile.msc'\" \(3286 characters\)
sed "s/^X//" >'makefile.msc' <<'END_OF_FILE'
X# Makefile for Zip, ZipNote, ZipSplit, and Ship, for
X# Microsoft C 5.1 or 6.0.
X
X# To use, do "make makefile.msc"
X# If you do not have masm or tasm, then add -DNO_ASM to CFLAGS and remove
X# im_lm.obj from OBJI
X
X# Warning: the default used here is the small model, which produces
X# faster code, but imposes some limitation on the number of files
X# that zip can process. Compile with the compact model to remove these
X# limitations.
X
X# ------------- Microsoft C 5.1 or 6.0 -------------
MODEL=-AS
X#     Change to -AC for compact model
CFLAGS=-W3 -Ox -nologo $(MODEL)
SPECFLAGS=-W3 -Oaict -Gs -nologo $(MODEL) -DEXPORT
UTILFLAGS=-DUTIL $(CFLAGS) -Fo
CC=cl
LD=link
LDFLAGS=/e/st:0x1000
X#     If you use lzexe as recommended, remove /e from LDFLAGS
AS=masm
X#     For MSC 6.0, use: AS=ml 
ASFLAGS=-ml -t
X
X# ------------- Common declarations:
STRIP=rem
X#    If you don't have lzexe, get it. Then define:
X#STRIP=lzexe
X#    This makes a big difference in .exe size (and possibly load time)
X
X# variables
OBJZ = zip.obj zipfile.obj zipup.obj fileio.obj util.obj tempf.obj shrink.obj\
X globals.obj
OBJI = implode.obj im_lmat.obj im_ctree.obj im_bits.obj im_lm.obj
X# remove im_lm.obj in above line if you do not have masm
X
OBJN = zipnote.obj zipfile_.obj zipup_.obj fileio_.obj globals.obj
OBJS = zipsplit.obj zipfile_.obj zipup_.obj fileio_.obj globals.obj
X
zips:	zip.exe zipnote.exe zipsplit.exe ship.exe
X
zip.obj:	zip.h ziperr.h tailor.h revision.h zip.c
X	$(CC) -c $(CFLAGS) $*.c
X
zipfile.obj:	zip.h ziperr.h tailor.h zipfile.c
X	$(CC) -c $(SPECFLAGS) $*.c
X
zipup.obj:	zip.h ziperr.h tailor.h revision.h zipup.c
X	$(CC) -c $(CFLAGS) $*.c
X
fileio.obj:	zip.h ziperr.h tailor.h fileio.c
X	$(CC) -c $(CFLAGS) $*.c
X
util.obj:	zip.h ziperr.h tailor.h util.c
X	$(CC) -c $(CFLAGS) $*.c
X
tempf.obj:	tempf.h tailor.h tempf.c
X	$(CC) -c $(CFLAGS) $*.c
X
shrink.obj:	zip.h ziperr.h tempf.h tailor.h shrink.c
X	$(CC) -c $(CFLAGS) $*.c
X
globals.obj:	zip.h ziperr.h tailor.h globals.c
X	$(CC) -c $(CFLAGS) $*.c
X
zipnote.obj:	zip.h ziperr.h tailor.h revision.h zipnote.c
X	$(CC) -c $(CFLAGS) $*.c
X
X# MSC 5.1 dies on zipsplit with -Ox
zipsplit.obj:	zipsplit.c zip.h ziperr.h tailor.h revision.h
X	$(CC) -c $(SPECFLAGS) $*.c
X
implode.obj:	implode.h crypt.h ziperr.h tempf.h tailor.h implode.c
X	$(CC) -c $(CFLAGS) $*.c
X
im_lmat.obj:	implode.h crypt.h ziperr.h tempf.h tailor.h im_lmat.c
X	$(CC) -c $(CFLAGS) $*.c
X
im_lm.obj:	im_lm.asm
X	$(AS) $(ASFLAGS) im_lm;
X
im_ctree.obj:	implode.h crypt.h ziperr.h tempf.h tailor.h im_ctree.c
X	$(CC) -c $(CFLAGS) $*.c
X
im_bits.obj:	implode.h crypt.h ziperr.h tempf.h tailor.h im_bits.c
X	$(CC) -c $(CFLAGS) $*.c
X
zipfile_.obj:	zipfile.c zip.h
X	$(CC) -c $(UTILFLAGS)$@ zipfile.c
X
zipup_.obj:	zipup.c zip.h
X	$(CC) -c $(UTILFLAGS)$@ zipup.c
X
fileio_.obj:	fileio.c zip.h
X	$(CC) -c $(UTILFLAGS)$@ fileio.c
X
X# we must cut the command line to fit in the MS/DOS 128 byte limit:
zip.exe: $(OBJZ) $(OBJI)
X	echo $(OBJZ)+ > zip.rsp
X	echo $(OBJI); >> zip.rsp
X	$(LD) $(LDFLAGS) @zip.rsp
X	del zip.rsp
X	$(STRIP) zip.exe
X
zipnote.exe: $(OBJN)
X	echo $(OBJN); > zipn.rsp
X	$(LD) $(LDFLAGS) @zipn.rsp
X	del zipn.rsp
X	$(STRIP) zipnote.exe
X
zipsplit.exe: $(OBJS)
X	echo $(OBJS); > zips.rsp
X	$(LD) $(LDFLAGS) @zips.rsp
X	del zips.rsp
X	$(STRIP) zipsplit.exe
X
ship.exe: ship.c
X	$(CC) $(CFLAGS) ship.c
X	$(STRIP) ship.exe
END_OF_FILE
if test 3286 -ne `wc -c <'makefile.msc'`; then
    echo shar: \"'makefile.msc'\" unpacked with wrong size!
fi
# end of 'makefile.msc'
fi
if test -f 'makefile.os2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.os2'\"
else
echo shar: Extracting \"'makefile.os2'\" \(3393 characters\)
sed "s/^X//" >'makefile.os2' <<'END_OF_FILE'
X# Makefile for Zip, ZipNote, ZipSplit, and Ship
X# for Microsoft C 6.00 and MASM 6.00 under OS/2.
X
X# To use, enter "nmake -f makefile.os2".
X
X# The resulting programs can be used under OS/2 protected
X# and real mode as well as under MS-DOS!
X# A larger stack has to be used for OS/2 because system calls
X# use more stack than under DOS, 8k is recommended by Microsoft.
X
X# Note that __STDC__ has to be defined explicitly with C 6.00 when -Ze
X# is given, because Microsoft disables __STDC__ when their extensions
X# are enabled. This is different to the C 5.10 behaviour.
X
X# If you do not have masm, then add -DNO_ASM to CFLAGS and remove
X# im_lm.obj from OBJI
X
MODEL=-AC
X# change this to -AS to use the small model
DEFINES=-D__STDC__ -DOS2 -DEXPORT
X
X# Loop optimization -Ol with C 6.00A is sometimes not safe.
X# Use it only for time-critical modules.
X
CC=cl -nologo
CFLAGS=$(MODEL) -W1 -Zep1 -J -G2s -Ocegit $(DEFINES)
XXFLAGS=-Oxaz
LDFLAGS=$(MODEL) -Lp -F 2000
AS=ml -nologo
AFLAGS=-W2 -Zm -Cp $(DEFINES)
X
X# For protect-mode only programs use rem
STRIP=bind -nologo
X# STRIP=rem
X
X# variables
X# remove im_lm.obj in OBJI if you do not have masm
OBJZ = zip.obj zipfile.obj zipup.obj fileio.obj util.obj tempf.obj \
X       shrink.obj globals.obj dir_os2.obj
OBJI = implode.obj im_lmat.obj im_ctree.obj im_bits.obj im_lm.obj
X
OBJN = zipnote.obj zipfile_.obj zipup_.obj fileio_.obj globals.obj
OBJS = zipsplit.obj zipfile_.obj zipup_.obj fileio_.obj globals.obj
X
zips:	zip.exe zipnote.exe zipsplit.exe ship.exe
X
zip.obj:	zip.h ziperr.h tailor.h revision.h zip.c
X	$(CC) -c $(CFLAGS) $*.c
X
zipfile.obj:	zip.h ziperr.h tailor.h zipfile.c
X	$(CC) -c $(CFLAGS) $*.c
X
zipup.obj:	zip.h ziperr.h tailor.h revision.h zipup.c
X	$(CC) -c $(CFLAGS) $*.c
X
fileio.obj:	zip.h ziperr.h tailor.h fileio.c
X	$(CC) -c $(CFLAGS) $*.c
X
util.obj:	zip.h ziperr.h tailor.h util.c
X	$(CC) -c $(CFLAGS) $*.c
X
tempf.obj:	tempf.h tailor.h tempf.c
X	$(CC) -c $(CFLAGS) $*.c
X
shrink.obj:	zip.h ziperr.h tempf.h tailor.h shrink.c
X	$(CC) -c $(CFLAGS) $(XFLAGS) $*.c
X
globals.obj:	zip.h ziperr.h tailor.h globals.c
X	$(CC) -c $(CFLAGS) $*.c
X
dir_os2.obj: dir_os2.c dir_os2.h
X	$(CC) -c $(CFLAGS) dir_os2.c
X
zipnote.obj:	zip.h ziperr.h tailor.h revision.h zipnote.c
X	$(CC) -c $(CFLAGS) $*.c
X
zipsplit.obj: zipsplit.c zip.h ziperr.h tailor.h revision.h
X	$(CC) -c $(CFLAGS) $*.c
X
implode.obj:	implode.h crypt.h ziperr.h tempf.h tailor.h implode.c
X	$(CC) -c $(CFLAGS) $(XFLAGS) $*.c
X
im_lmat.obj:	implode.h crypt.h ziperr.h tempf.h tailor.h im_lmat.c
X	$(CC) -c $(CFLAGS) $(XFLAGS) $*.c
X
im_lm.obj:	im_lm.asm
X	$(AS) -c $(AFLAGS) $*.asm
X#	masm -ml -t -DOS2 im_lm.asm;   # use this for 5.10
X
im_ctree.obj:	implode.h crypt.h ziperr.h tempf.h tailor.h im_ctree.c
X	$(CC) -c $(CFLAGS) $(XFLAGS) $*.c
X
im_bits.obj:	implode.h crypt.h ziperr.h tempf.h tailor.h im_bits.c
X	$(CC) -c $(CFLAGS) $(XFLAGS) $*.c
X
zipfile_.obj: zipfile.c zip.h
X	$(CC) -c $(CFLAGS) -DUTIL -Fo$@ zipfile.c
X
zipup_.obj: zipup.c zip.h
X	$(CC) -c $(CFLAGS) -DUTIL -Fo$@ zipup.c
X
fileio_.obj: fileio.c zip.h
X	$(CC) -c $(CFLAGS) -DUTIL -Fo$@ fileio.c
X
zip.exe: $(OBJZ) $(OBJI) zip.def
X	$(CC) $(LDFLAGS) $** -o $@
X        $(STRIP) $@ -n DOSQFSATTACH
X
zipnote.exe: $(OBJN) zip.def
X	$(CC) $(LDFLAGS) $** -o $@
X        $(STRIP) $@
X
zipsplit.exe: $(OBJS) zip.def
X	$(CC) $(LDFLAGS) $** -o $@
X        $(STRIP) $@
X
ship.exe: ship.c ship.def
X	$(CC) $(CFLAGS) $(LDFLAGS) $** -o $@
X        $(STRIP) $@
END_OF_FILE
if test 3393 -ne `wc -c <'makefile.os2'`; then
    echo shar: \"'makefile.os2'\" unpacked with wrong size!
fi
# end of 'makefile.os2'
fi
if test -f 'makefile.pwc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.pwc'\"
else
echo shar: Extracting \"'makefile.pwc'\" \(3619 characters\)
sed "s/^X//" >'makefile.pwc' <<'END_OF_FILE'
X# Makefile for Zip, ZipNote, ZipSplit, and Ship, for Power C.
X
X# This version by Bob Hardy, 07-16-91
X
X# Make sure you have plenty of free diskspace before invoking make,
X# especially for "make zips".  If you run out of space, several lines
X# will lose dramatically, and the make will fail.  You may even have
X# to rename some source files.
X
CC=pc
LD=pcl
MODEL=m
X# (note from the editor: the "m" here for MODEL looks a little suspicious--
X#  it probably should be s or c, since the small or compact models are what
X#  should be used.)
CFLAGS=/f- /m$(MODEL) /dMSDOS /dNO_ASM /dEXPORT
LDFLAGS=/d 
STRIP=lzexe
X# If you don't have lzexe, get it. Then define:
X#    STRIP=lzexe
X# This makes a *big* difference in .exe size (hence load time)
X# If you want to make without it, comment out all the STRIP lines and the
X# "rm *.old" lines.  This will cost you in terms of disk usage, though.
X
X# variables
OBJZ1 = zip.mix zipfile.mix zipup.mix fileio.mix util.mix
OBJZ2 = shrink.mix globals.mix tempf.mix
OBJC2 = util.mix globals.mix
OBJI = implode.mix im_lmat.mix im_ctree.mix im_bits.mix
OBJN = zipnote.mix zipfile_.mix zipup_.mix fileio_.mix globals.mix
OBJS = zipsplit.mix zipfile_.mix zipup_.mix fileio_.mix globals.mix
X
zips:		zip.exe zipnote.exe zipsplit.exe ship.exe
X
zip.mix:	zip.h ziperr.h tailor.h revision.h zip.c
X	$(CC) $(CFLAGS) zip.c
X
zipfile.mix:	zip.h ziperr.h tailor.h zipfile.c
X	$(CC) $(CFLAGS) zipfile.c
X
zipup.mix:	zip.h ziperr.h tailor.h revision.h zipup.c
X	$(CC) $(CFLAGS) zipup.c
X
fileio.mix:	zip.h ziperr.h tailor.h fileio.c
X	$(CC) $(CFLAGS) fileio.c
X
util.mix:	zip.h ziperr.h tailor.h util.c
X	$(CC) $(CFLAGS) util.c
X
shrink.mix:	zip.h ziperr.h tailor.h shrink.c
X	$(CC) $(CFLAGS) shrink.c
X
globals.mix:	zip.h ziperr.h tailor.h globals.c
X	$(CC) $(CFLAGS) globals.c
X
zipnote.mix:	zip.h ziperr.h tailor.h revision.h zipnote.c
X	$(CC) $(CFLAGS) zipnote.c
X
zipsplit.mix: zipsplit.c zip.h ziperr.h tailor.h revision.h
X	$(CC) $(CFLAGS) zipsplit.c
X
implode.mix:	implode.h crypt.h ziperr.h tailor.h tempf.h implode.c
X	$(CC) $(CFLAGS) implode.c
X
tempf.mix:	tempf.h tailor.h tempf.c
X	$(CC) $(CFLAGS) tempf.c
X
im_lmat.mix:	implode.h crypt.h ziperr.h tailor.h im_lmat.c
X	$(CC) $(CFLAGS) im_lmat.c
X
im_ctree.mix:	implode.h crypt.h ziperr.h tailor.h tempf.h im_ctree.c
X	$(CC) $(CFLAGS) im_ctree.c
X
im_bits.mix:	implode.h crypt.h ziperr.h tailor.h im_bits.c
X	$(CC) $(CFLAGS) im_bits.c
X
zipfile_.mix: zipfile.c zip.h
X	+ren zipfile.c zipfile_.c
X	$(CC) /dUTIL $(CFLAGS) zipfile_.c
X	+ren zipfile_.c zipfile.c
X
zipup_.mix: zipup.c zip.h
X	+ren zipup.c zipup_.c
X	$(CC) /dUTIL $(CFLAGS) zipup_.c
X	+ren zipup_.c zipup.c
X
fileio_.mix: fileio.c zip.h
X	+ren fileio.c fileio_.c
X	$(CC) /dUTIL $(CFLAGS) fileio_.c
X	+ren fileio_.c fileio.c
X
X# we must cut the command line to fit in the MS/DOS 128 byte limit:
zip.exe: $(OBJZ1) $(OBJZ2) $(OBJI)
X	+echo L $(OBJZ1) > zip.rsp
X	+echo L $(OBJZ2) >> zip.rsp
X	+echo L $(OBJI) >> zip.rsp
X	+echo FA; >> zip.rsp
X	+echo b zip,,, >> zip.rsp
X	$(LD) $(LDFLAGS) @zip.rsp
X	rm zip.rsp
X	$(STRIP) zip.exe
X#	rm zip.old
X# Leave these "rm *.old" lines in if you have a shortage of diskspace.
X# Particularly if you intend to "make zips".
X
zipnote.exe: $(OBJN)
X	+echo L $(OBJN) > zipn.rsp
X	+echo FA; >> zipn.rsp
X	+echo b zipnote,,, >> zipn.rsp
X	$(LD) $(LDFLAGS) @zipn.rsp
X	rm zipn.rsp
X	$(STRIP) zipnote.exe
X#	rm zipnote.old
X
zipsplit.exe: $(OBJS)
X	+echo L $(OBJS) > zips.rsp
X	+echo FA; >> zips.rsp
X	+echo b zipsplit,,, >> zips.rsp
X	$(LD) $(LDFLAGS) @zips.rsp
X	rm zips.rsp
X	$(STRIP) zipsplit.exe
X#	rm zipsplit.old
X
ship.exe: ship.c
X	$(CC) $(CFLAGS) ship.c
X	$(LD) $(LDFLAGS) ship.mix
X	$(STRIP) ship.exe
X#	rm ship.old
END_OF_FILE
if test 3619 -ne `wc -c <'makefile.pwc'`; then
    echo shar: \"'makefile.pwc'\" unpacked with wrong size!
fi
# end of 'makefile.pwc'
fi
if test -f 'makevms.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makevms.com'\"
else
echo shar: Extracting \"'makevms.com'\" \(2470 characters\)
sed "s/^X//" >'makevms.com' <<'END_OF_FILE'
X$ !
X$ !     "Makefile" for VMS versions of Zip, ZipNote,
X$ !      ZipSplit, Ship and UnShip (stolen from Unzip)
X$ !
X$ set verify    ! like "echo on", eh?
X$ !
X$ !------------------------------- Zip section --------------------------------
X$ !
X$ cc /def=EXPORT zip,zipfile,zipup,fileio,util,tempf,shrink,globals,implode,im_lmat,im_ctree,im_bits
X$ link zip,zipfile,zipup,fileio,util,tempf,shrink,globals,implode,im_lmat,im_ctree,im_bits,sys$input:/opt
sys$share:vaxcrtl.exe/shareable
X$ !
X$ ! If you have problems with implode, compile with /define=noimplode
X$ ! and remove all the im* files from the above lines.
X$ !
X$ !-------------------------- Zip utilities section ---------------------------
X$ !
X$ ren zipfile.c zipfile_.c;*
X$ ren zipup.c zipup_.c;*
X$ ren fileio.c fileio_.c;*
X$ ren util.c util_.c;*
X$ cc /def=EXPORT zipnote, zipsplit
X$ cc /def=EXPORT /def=UTIL zipfile_, zipup_, fileio_, util_
X$ ren zipfile_.c zipfile.c;*
X$ ren zipup_.c zipup.c;*
X$ ren fileio_.c fileio.c;*
X$ ren util_.c util.c;*
X$ link zipnote, zipfile_, zipup_, fileio_, globals, sys$input:/opt
sys$share:vaxcrtl.exe/shareable
X$ link zipsplit, zipfile_, zipup_, fileio_, globals, sys$input:/opt
sys$share:vaxcrtl.exe/shareable
X$ !
X$ !--------------------------- Ship/UnShip section ----------------------------
X$ !
X$ cc ship
X$ link ship,sys$input:/opt
sys$share:vaxcrtl.exe/shareable
X$ !
X$ ! Create a hard link.  (To remove both files, delete the copy FIRST, then
X$ ! the original.  Otherwise, if original deleted first [copy says "no such
X$ ! file"], must use "set file/remove unship.exe;#" to get rid of the copy.
X$ ! Unlike in Unix, deleting the original ALWAYS destroys the data--but not
X$ ! the directory entry of the copy.)  Using a hard link saves disk space, by
X$ ! the way.  Note, however, that copying a hard link copies the data, not
X$ ! just the link.  Therefore, set up the link in the directory in which the
X$ ! executable is to reside, or else rename (move) the executables into the
X$ ! directory.
X$ !
X$ set file/enter=unship.exe ship.exe
X$ !
X$ !----------------------------- Symbols section ------------------------------
X$ !
X$ ! Set up symbols for the various executables.  Edit the example below,
X$ ! changing "pc" to "disk:[directory]" as appropriate, and uncomment
X$ ! (remove the exclamation marks).
X$ !
X$ ! zip		== "$pc:zip.exe"
X$ ! zipnote	== "$pc:zipnote.exe"
X$ ! zipsplit	== "$pc:zipsplit.exe"
X$ ! ship		== "$pc:ship.exe"
X$ ! unship	== "$pc:unship.exe"
X$ !
X$ set noverify
END_OF_FILE
if test 2470 -ne `wc -c <'makevms.com'`; then
    echo shar: \"'makevms.com'\" unpacked with wrong size!
fi
# end of 'makevms.com'
fi
if test -f 'revision.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'revision.h'\"
else
echo shar: Extracting \"'revision.h'\" \(1198 characters\)
sed "s/^X//" >'revision.h' <<'END_OF_FILE'
X/*
X
X Copyright (C) 1990,1991 Mark Adler, Richard B. Wales, and Jean-loup Gailly.
X Permission is granted to any individual or institution to use, copy, or
X redistribute this software so long as all of the original files are included
X unmodified, that it is not sold for profit, and that this copyright notice
X is retained.
X
X*/
X
X/*
X *  revision.h by Mark Adler.
X */
X
X#define REVISION 10
X#define REVDATE "29 September 1991"
X
X/* Copyright notice for binary executables--this notice only applies to
X * those (zip, zipcloak, zipsplit, and zipnote), not to this file
X * (revision.h).
X */
X
X#ifndef NOCPYRT
char *copyright[] = {
X"Copyright (C) 1990,1991 Mark Adler, Richard B. Wales, and Jean-loup Gailly.",
X"Permission is granted to any individual or institution to use, copy, or",
X"redistribute this executable so long as it is not modified and that it is",
X"not sold for profit."
X};
char *disclaimer[] = {
X"",
X"LIKE ANYTHING ELSE THAT'S FREE, ZIP AND ITS ASSOCIATED UTILITIES ARE",
X"PROVIDED AS IS AND COME WITH NO WARRANTY OF ANY KIND, EITHER EXPRESSED OR",
X"IMPLIED. IN NO EVENT WILL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY DAMAGES",
X"RESULTING FROM THE USE OF THIS SOFTWARE."
X};
X#endif /* !NOCPYRT */
END_OF_FILE
if test 1198 -ne `wc -c <'revision.h'`; then
    echo shar: \"'revision.h'\" unpacked with wrong size!
fi
# end of 'revision.h'
fi
if test -f 'ship.def' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ship.def'\"
else
echo shar: Extracting \"'ship.def'\" \(74 characters\)
sed "s/^X//" >'ship.def' <<'END_OF_FILE'
NAME WINDOWCOMPAT NEWFILES
DESCRIPTION 'encode/split/mail & decode files'
END_OF_FILE
if test 74 -ne `wc -c <'ship.def'`; then
    echo shar: \"'ship.def'\" unpacked with wrong size!
fi
# end of 'ship.def'
fi
if test -f 'tailor.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tailor.h'\"
else
echo shar: Extracting \"'tailor.h'\" \(3123 characters\)
sed "s/^X//" >'tailor.h' <<'END_OF_FILE'
X/* tailor.h -- Not copyrighted 1991 Mark Adler */
X
X/* const's are inconsistently used across ANSI libraries--kill for all
X   header files. */
X#define const
X
X
X/* Use prototypes and ANSI libraries if __STDC__ */
X#ifdef __STDC__
X#  ifndef PROTO
X#    define PROTO
X#  endif /* !PROTO */
X#  define MODERN
X#endif /* __STDC__ */
X
X
X/* Use prototypes and ANSI libraries if Silicon Graphics */
X#ifdef sgi
X#  ifndef PROTO
X#    define PROTO
X#  endif /* !PROTO */
X#  define MODERN
X#endif /* sgi */
X
X
X/* Define MSDOS for Turbo C as well as Microsoft C */
X#ifdef __POWERC                 /* For Power C too */
X#  define __TURBOC__
X#endif /* __POWERC */
X#ifdef __TURBOC__
X#  ifndef MSDOS
X#    define MSDOS
X#  endif /* !MSDOS */
X#endif /* __TURBOC__ */
X
X
X/* Use prototypes and ANSI libraries if Microsoft or Borland C */
X#ifdef MSDOS
X#  ifndef PROTO
X#    define PROTO
X#  endif /* !PROTO */
X#  define MODERN
X#endif /* MSDOS */
X
X
X/* Turn off prototypes if requested */
X#ifdef NOPROTO
X#  ifdef PROTO
X#    undef PROTO
X#  endif /* PROTO */
X#endif /* NOPROT */
X
X
X/* Used to remove arguments in function prototypes for non-ANSI C */
X#ifdef PROTO
X#  define OF(a) a
X#else /* !PROTO */
X#  define OF(a) ()
X#endif /* ?PROTO */
X
X
X/* Allow far and huge allocation for small model (Microsoft C or Turbo C) */
X#ifdef MSDOS
X#  ifdef __TURBOC__
X#    include <alloc.h>
X#  else /* !__TURBOC__ */
X#    include <malloc.h>
X#    define farmalloc _fmalloc
X#    define farfree   _ffree
X#  endif /* ?__TURBOC__ */
X#else /* !MSDOS */
X#  define huge
X#  define far
X#  define near
X#  define farmalloc malloc
X#  define farfree   free
X#endif /* ?MSDOS */
X
X
X/* Define MSVMS if either MSDOS or VMS defined */
X#ifdef MSDOS
X#  define MSVMS
X#else /* !MSDOS */
X#  ifdef VMS
X#    define MSVMS
X#  endif /* VMS */
X#endif /* ?MSDOS */
X
X
X/* Define void, voidp, and extent (size_t) */
X#include <stdio.h>
X#ifdef MODERN
X#  ifndef M_XENIX
X#    include <stddef.h>
X#  endif /* !M_XENIX */
X#  include <stdlib.h>
X   typedef size_t extent;
X   typedef void voidp;
X#else /* !MODERN */
X   typedef unsigned int extent;
X#  define void int
X   typedef char voidp;
X#endif /* ?MODERN */
X
X/* Get types and stat */
X#ifdef VMS
X#  include <types.h>
X#  include <stat.h>
X#else /* !VMS */
X#  include <sys/types.h>
X#  include <sys/stat.h>
X#endif /* ?VMS */
X
X
X/* Cheap fix for unlink on VMS */
X#ifdef VMS
X#  define unlink delete
X#endif /* VMS */
X
X
X/* For Pyramid */
X#ifdef pyr
X#  define strrchr rindex
X#  define ZMEM
X#endif /* pyr */
X
X
X/* File operations--use "b" for binary if allowed */
X#ifdef MODERN
X#  define FOPR "rb"
X#  define FOPM "r+b"
X#  define FOPW "w+b"
X#else /* !MODERN */
X#  define FOPR "r"
X#  define FOPM "r+"
X#  define FOPW "w+"
X#endif /* ?MODERN */
X
X
X/* Fine tuning */
X#ifndef MSDOS
X#   define BSZ 8192   /* Buffer size for files */
X#else /* !MSDOS */
X#   define BSZ 4096   /* Keep precious NEAR space */
X    /* BSZ can't be 8192 even for compact model because of 64K limitation
X     * in im_lmat.c. If you run out of memory when processing a large number
X     * files, use the compact model and reduce BSZ to 2048 here and in
X     * im_lm.asm.
X     */
X#endif /* ?MSDOS */
X
X/* end of tailor.h */
END_OF_FILE
if test 3123 -ne `wc -c <'tailor.h'`; then
    echo shar: \"'tailor.h'\" unpacked with wrong size!
fi
# end of 'tailor.h'
fi
if test -f 'tempf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tempf.c'\"
else
echo shar: Extracting \"'tempf.c'\" \(4437 characters\)
sed "s/^X//" >'tempf.c' <<'END_OF_FILE'
X/*
X
X Copyright (C) 1990,1991 Mark Adler, Richard B. Wales, and Jean-loup Gailly.
X Permission is granted to any individual or institution to use, copy, or
X redistribute this software so long as all of the original files are included
X unmodified, that it is not sold for profit, and that this copyright notice
X is retained.
X
X*/
X
X/*
X *  tempf.c by Mark Adler.
X */
X
X#include "tailor.h"
X#include "tempf.h"
X
extern char *tempname OF((int));
X
X#ifdef MODERN
X#  include <string.h>
X#else /* !MODERN */
X   voidp *malloc();
X#  ifndef ZMEM
X     char *memcpy();
X#  endif /* !ZMEM */
X#endif /* ?MODERN */
X#ifdef ZMEM
X   char *memcpy OF((char *, char *, unsigned int));
X#endif /* ZMEM */
int unlink OF((char *));
X
X
X/* Define a special memcpy for MSDOS small model */
X#if defined(MSDOS) && (defined(M_I86SM) || defined(__SMALL__))
X#  include <dos.h>
X#  define memcpy farmemcpy
X   void farmemcpy(char far *d, char far *s, unsigned n)
X   {
X      movedata(FP_SEG(s), FP_OFF(s), FP_SEG(d), FP_OFF(d), n);
X   }
X#endif
X
X
tFILE *topen(c)
int c;
X/* Create a new temporary file and return its descriptor.  Save the character
X   c to be used in the temporary file name, if needed. */
X{
X  tFILE *t;
X
X  if ((t = (tFILE *)malloc(sizeof(tFILE))) == NULL ||
X      (t->b = farmalloc(TMPSIZ)) == NULL)
X    return NULL;
X  t->p = t->m = 0;
X  t->c = c;
X  t->f = NULL;
X  return t;
X}
X
X
int tnew(t)
tFILE *t;               /* temporary file descriptor */
X/* Create a temporary file with a unique name */
X{
X  return (t->n = tempname(t->c)) == NULL ||
X         (t->f = fopen(t->n, FOPW)) == NULL;
X}
X
X
unsigned twrite(b, s, n, t)
char *b;                /* buffer to write from */
unsigned s;             /* size of items */
unsigned n;             /* number of items */
tFILE *t;               /* temporary file descriptor */
X/* Like fwrite()--will create a temporary file if needed. */
X{
X  unsigned j;           /* room in memory, items to write */
X  long k;               /* bytes to write */
X  long w;               /* bytes written to file */
X
X  /* write to memory portion */
X  j = TMPSIZ - t->p;
X  k = s * (long) n;
X  if (j && k)
X  {
X    j = (long)j > k ? (unsigned)k : j;
X    memcpy(t->b + t->p, (char far *)b, j);
X    t->p += j;
X    if (t->m < t->p)
X      t->m = t->p;
X    b += j;
X    k -= j;
X  }
X  if (k == 0)
X    return n;
X
X  /* create temporary file if needed */
X  if (t->f == NULL && tnew(t))
X    return 0;
X
X  /* write to temporary file */
X  j = (unsigned)(k / s);
X  if (j && fwrite(b, s, j, t->f) != j)
X    return 0;
X  b += w = s * (long)j;
X  k -= w;
X  if (k && fwrite(b, (unsigned)k, 1, t->f) != 1)
X    return 0;
X  return n;
X}
X
X
int tflush(t)
tFILE *t;               /* temporary file descriptor */
X/* Like fflush() */
X{
X  return t->f == NULL ? 0 : fflush(t->f);
X}
X
X
void trewind(t)
tFILE *t;               /* temporary file descriptor */
X/* Like rewind() */
X{
X  t->p = 0;
X  if (t->f != NULL)
X    rewind(t->f);
X}
X
X
unsigned tread(b, s, n, t)
char *b;                /* buffer to read into */
unsigned s;             /* size of items */
unsigned n;             /* number of items */
tFILE *t;               /* temporary file descriptor */
X/* Like fread() */
X{
X  unsigned j;           /* bytes in memory, items to read */
X  long k;               /* bytes requested */
X  long r;               /* bytes read from file */
X
X  /* read from memory */
X  j = t->m - t->p;
X  k = s * (long)n;
X  if (j && k)
X  {
X    j = (long)j > k ? (unsigned)k : j;
X    memcpy((char far *)b, t->b + t->p, j);
X    t->p += j;
X    b += j;
X    k -= j;
X  }
X
X  /* read from file if more requested */
X  if (k && t->f != NULL)
X  {
X    j = (unsigned)(k / s);
X    if (j)
X    {
X      r = s * (long)fread(b, s, j, t->f);
X      b += r;
X      k -= r;
X    }
X    if (k && k < s)
X      k -= fread(b, 1, (unsigned)k, t->f);
X  }
X
X  /* return complete items read */
X  return n - (unsigned)((k + s - 1) / s);
X}
X
X
int terror(t)
tFILE *t;               /* temporary file descriptor */
X/* Like ferror() */
X{
X  return t->f == NULL ? 0 : ferror(t->f);
X}
X
X
int teof(t)
tFILE *t;               /* temporary file descriptor */
X/* Like feof() */
X{
X  return t->f == NULL ? t->p == t->m : feof(t->f);
X}
X
X
int tclose(t)
tFILE *t;               /* temporary file descriptor */
X/* Like fclose()--frees the memory used by the descriptor and deletes
X   the temporary file, if any. */
X{
X  int r;
X
X  r = 0;
X  if (t->f != NULL)
X  {
X    r = fclose(t->f);
X    unlink(t->n);
X    free(t->n);
X  }
X  farfree(t->b);
X  free(t);
X  return r;
X}
END_OF_FILE
if test 4437 -ne `wc -c <'tempf.c'`; then
    echo shar: \"'tempf.c'\" unpacked with wrong size!
fi
# end of 'tempf.c'
fi
if test -f 'tempf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tempf.h'\"
else
echo shar: Extracting \"'tempf.h'\" \(2182 characters\)
sed "s/^X//" >'tempf.h' <<'END_OF_FILE'
X/*
X
X Copyright (C) 1990,1991 Mark Adler, Richard B. Wales, and Jean-loup Gailly.
X Permission is granted to any individual or institution to use, copy, or
X redistribute this software so long as all of the original files are included
X unmodified, that it is not sold for profit, and that this copyright notice
X is retained.
X
X*/
X
X/*
X *  tempf.h by Mark Adler.
X */
X
X/* These "t" functions behave like their "f" counterparts, except that
X   topen() takes one character to (possibly) be used in a temporary file
X   name, twrite() can create a temporary file, and tclose() will delete
X   the temporary file, if any.  tnew() is only defined for use in the
X   tputc() macro.  It should not be called explicitly.  These functions
X   use the type tFILE instead of FILE to point to a file descriptor. */
X
X#if !defined(OS2) && (defined(M_I86CM) || defined(__COMPACT__))
X#   define TMPSIZ  0x8000  /* memory portion of temporary files */
X    /* The MSDOS compact model is to be used only for processing a large
X     * number of files. In this case we try to reduce the memory requirements.
X     * You can reduce TMPSIZ to 16384 or 8192 if 32K is still too large,
X     * but the resulting code will be slower.
X     */
X#else
X#   define TMPSIZ  0xe000  /* memory portion of temporary files */
X#endif
X
typedef struct {
X  char far *b;          /* memory part of file */
X  unsigned p;           /* current read/write pointer for memory part */
X  unsigned m;           /* bytes in memory part */
X  int c;                /* character to use in spill file name */
X  FILE *f;              /* spill file pointer or NULL*/
X  char *n;              /* spill file name if f not NULL */
X} tFILE;
X
tFILE *topen OF((int));
int tnew OF((tFILE *));
unsigned twrite OF((char *, unsigned, unsigned, tFILE *));
int tflush OF((tFILE *));
void trewind OF((tFILE *));
unsigned tread OF((char *, unsigned, unsigned, tFILE *));
int terror OF((tFILE *));
int teof OF((tFILE *));
int tclose OF((tFILE *));
X
X#define tputcm(c,t) ((t)->b[(t)->p++]=(c),(t)->m<(t)->p?((t)->m=(t)->p):0,c)
X#define tputcf(c,t) ((t)->f==NULL?(tnew(t)?-1:putc(c,(t)->f)):putc(c,(t)->f))
X#define tputc(c,t) ((t)->p<TMPSIZ?(int)tputcm(c,t):tputcf(c,t))
END_OF_FILE
if test 2182 -ne `wc -c <'tempf.h'`; then
    echo shar: \"'tempf.h'\" unpacked with wrong size!
fi
# end of 'tempf.h'
fi
if test -f 'zip.def' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zip.def'\"
else
echo shar: Extracting \"'zip.def'\" \(86 characters\)
sed "s/^X//" >'zip.def' <<'END_OF_FILE'
NAME WINDOWCOMPAT NEWFILES
DESCRIPTION 'The world-famous zip utilities from Info-ZIP'
END_OF_FILE
if test 86 -ne `wc -c <'zip.def'`; then
    echo shar: \"'zip.def'\" unpacked with wrong size!
fi
# end of 'zip.def'
fi
if test -f 'zip.prj' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zip.prj'\"
else
echo shar: Extracting \"'zip.prj'\" \(620 characters\)
sed "s/^X//" >'zip.prj' <<'END_OF_FILE'
zip.c        (zip.h ziperr.h tailor.h revision.h)
zipfile.c    (zip.h ziperr.h tailor.h)
zipup.c      (zip.h ziperr.h tailor.h revision.h)
fileio.c     (zip.h ziperr.h tailor.h)
util.c       (zip.h ziperr.h tailor.h)
tempf.c      (tempf.h tailor.h)
shrink.c     (zip.h ziperr.h tempf.h tailor.h)
crypt.c      (zip.h ziperr.h tailor.h)
globals.c    (zip.h ziperr.h tailor.h)
implode.c    (implode.h crypt.h ziperr.h tempf.h tailor.h)
im_lmat.c    (implode.h crypt.h ziperr.h tempf.h tailor.h)
im_ctree.c   (implode.h crypt.h ziperr.h tempf.h tailor.h)
im_bits.c    (implode.h crypt.h ziperr.h tempf.h tailor.h)
im_lm.obj
END_OF_FILE
if test 620 -ne `wc -c <'zip.prj'`; then
    echo shar: \"'zip.prj'\" unpacked with wrong size!
fi
# end of 'zip.prj'
fi
if test -f 'ziperr.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ziperr.h'\"
else
echo shar: Extracting \"'ziperr.h'\" \(2561 characters\)
sed "s/^X//" >'ziperr.h' <<'END_OF_FILE'
X/*
X
X Copyright (C) 1990,1991 Mark Adler, Richard B. Wales, and Jean-loup Gailly.
X Permission is granted to any individual or institution to use, copy, or
X redistribute this software so long as all of the original files are included
X unmodified, that it is not sold for profit, and that this copyright notice
X is retained.
X
X*/
X
X/*
X *  ziperr.h by Mark Adler.
X */
X
X/* Error return values.  The values 0..4 and 12..18 follow the conventions
X   of PKZIP.   The values 4..10 are all assigned to "insufficient memory"
X   by PKZIP, so the codes 5..10 are used here for other purposes. */
X#define ZE_MISS         -1      /* used by procname(), zipbare() */
X#define ZE_OK           0       /* success */
X#define ZE_EOF          2       /* unexpected end of zip file */
X#define ZE_FORM         3       /* zip file structure error */
X#define ZE_MEM          4       /* out of memory */
X#define ZE_LOGIC        5       /* internal logic error (implode) */
X#define ZE_BIG          6       /* entry too large to split */
X#define ZE_NOTE         7       /* invalid comment format */
X#define ZE_ABORT        9       /* user interrupt or termination */
X#define ZE_TEMP         10      /* error using a temp file */
X#define ZE_READ         11      /* read or seek error */
X#define ZE_NONE         12      /* nothing to do */
X#define ZE_NAME         13      /* missing or empty zip file */
X#define ZE_WRITE        14      /* error writing to a file */
X#define ZE_CREAT        15      /* couldn't open to write */
X#define ZE_PARMS        16      /* bad command line */
X#define ZE_OPEN         18      /* could not open a specified file to read */
X/* Macro to determine whether to call perror() or not */
X#define PERR(e) (e==ZE_READ||e==ZE_WRITE||e==ZE_CREAT||e==ZE_TEMP||e==ZE_OPEN)
X
X#ifdef GLOBALS
X/* Error messages for the err() function in the zip programs */
char *errors[] = {
X/*  1 */  "",
X/*  2 */  "Unexpected end of zip file",
X/*  3 */  "Zip file structure invalid",
X/*  4 */  "Out of memory",
X/*  5 */  "Internal logic error",
X/*  6 */  "Entry too big to split",
X/*  7 */  "Invalid comment format",
X/*  8 */  "",
X/*  9 */  "Interrupted",
X/* 10 */  "Temporary file failure",
X/* 11 */  "Input file read failure",
X/* 12 */  "Nothing to do!",
X/* 13 */  "Missing or empty zip file",
X/* 14 */  "Output file write failure",
X/* 15 */  "Could not create output file",
X/* 16 */  "Invalid command arguments",
X/* 17 */  "",
X/* 18 */  "File not found or no read permission",
X};
X#else /* !GLOBALS */
extern char *errors[];          /* Error messages for err() */
X#endif /* ?GLOBALS */
END_OF_FILE
if test 2561 -ne `wc -c <'ziperr.h'`; then
    echo shar: \"'ziperr.h'\" unpacked with wrong size!
fi
# end of 'ziperr.h'
fi
echo shar: End of archive 1 \(of 7\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
