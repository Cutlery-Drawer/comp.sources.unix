Newsgroups: comp.sources.unix
From: phil@Shiva.COM (Phil Budne)
Subject: v25i167: finger - Phil's Finger Program, Part04/07
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: phil@Shiva.COM (Phil Budne)
Posting-Number: Volume 25, Issue 167
Archive-Name: finger/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 7)."
# Contents:  conf.c names.c output.c select.c switch.c whois.c
#   ymakefile
# Wrapped by budd@bu-it on Fri Jul  6 13:22:03 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f conf.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"conf.c\"
else
echo shar: Extracting \"conf.c\" \(8973 characters\)
sed "s/^X//" >conf.c <<'END_OF_conf.c'
X/*
X * conf.c -- read run time configuration file for finger
X *
X * Copyright (C) 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X/* TODO:
X * implement options and route
X * do ttylocs from here? (nah, hardle needs them)
X */
X
X/*
X * The idea for formatting phone numbers comes from
X * Michael Thompson <thompson@dalcs.UUCP> Dalhousie University,
X * Halifax, NS in comp.bugs.4bsd on Sept 25, 1987 
X * "BSD4.3 finger is Berkley dependent. +FIX" 
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: conf.c,v 3.0 90/07/06 13:10:27 budd Rel $";
X# endif /* lint not defined */
X
X# include <stdio.h>
X# include <strings.h>
X# include <ctype.h>
X# include <pwd.h>
X# include <grp.h>
X# include "person.h"
X# include "finger.h"
X# include "args.h"			/* sw_debug */
X
X# define CONF "finger.conf"
X# define NUMBER '#'
X# define COMMENT '!'
X
XLOCAL int initialized = FALSE;
XLOCAL char *confdirs[] = {
X# ifdef CONFDIRS
X    CONFDIRS,
X# endif /* CONFDIRS defined */
X    "/etc",
X    "/usr/local/etc",
X    "/usr/etc",
X    ".",				/* for debugging.. move to first? */
X    NULL
X};
X
X# define NBUILDINGS 10			/* UGH! */
XLOCAL struct building {
X    char code;
X    char *name;
X} buildings[NBUILDINGS];
XLOCAL int nbuildings = 0;
X
X# define NACCTS 32			/* UGH! */
XLOCAL struct acct {
X    unsigned short min, max;
X    char group, *name;
X} accts[NACCTS];
XLOCAL int naccts = 0;
X
X# define NPHONES 32			/* UGH! */
XLOCAL struct phone {
X    int splats;
X    char *pat;
X} phones[NPHONES];
XLOCAL int nphones = 0;
X
X# define NHIDDEN 32			/* UGH! */
Xchar *hidden[NHIDDEN];
XLOCAL int nhidden = 0;
X
X# define NPREFIX 32			/* UGH! */
Xchar *prefix[NPREFIX];
XLOCAL int nprefixes = 0;
X
XGLOBAL BOOL
Xread_conf() {
X    FILE *f;
X    char **dp;
X    char buf[ 512 ];
X    enum { START, ACCT, BUILDING, HIDDEN, OPT, PHONE, PREFIX, ROUTE } state;
X
X    if( initialized )
X	return( TRUE );
X    initialized = TRUE;
X
X    /* read env variable for path(s)? */
X
X    for( dp = confdirs, f = NULL; f == NULL && *dp != NULL; dp++ ) {
X	sprintf( buf, "%s/%s", *dp, CONF );
X	f = fopen( buf, "r" );
X    }
X    if( f == NULL )
X	return( FALSE );
X
X    if( sw_debug )
X	printf("%s:\n", buf );
X
X    state = START;
X    if( fgets( buf, sizeof( buf ), f ) == NULL ) {
X	fclose( f );
X	return( FALSE );
X    }
X
X    do {				/* ...while fgets */
X	char *cp;
X
X	switch( buf[0] ) {
X	case '%':
X	    /* use perfect hashing? */
X# define PAIR(a,b) (a)<<7|(b)
X	    switch( PAIR(buf[1],buf[2]) ) {
X	    case PAIR('a','c'):
X		state = ACCT;
X		break;
X	    case PAIR('b','u'):
X		state = BUILDING;
X		break;
X	    case PAIR('h','i'):
X		state = HIDDEN;
X		break;
X	    case PAIR('o','p'):
X		state = OPT;
X		break;
X	    case PAIR('p','h'):
X		state = PHONE;
X		break;
X	    case PAIR('p','r'):
X		state = PREFIX;
X		break;
X	    case PAIR('r','o'):
X		state = ROUTE;
X		break;
X	    default:
X		state = START;
X		break;
X	    }
X	    /* fall */
X	case COMMENT:
X	    /* # is used in phones */
X	    continue;
X	} /* switch on buf[0] */
X
X	cp = index( buf, '\n' );
X	if( cp != NULL )
X	    *cp = EOS;
X
X	switch( state ) {
X	case START:
X	    break;
X
X	case ACCT:
X	    if( naccts < NACCTS ) {
X		char temp[ 128 ], *tp;	/* FIXME */
X		BOOL lit, name, hyp;
X		int min, max, grp;
X		struct passwd *pw;
X		struct group *gr;
X
X		name = FALSE;		/* no letters */
X		lit = FALSE;		/* no litteral next */
X		tp = temp;		/* output buffer */
X		for( cp = buf; *cp; cp++ ) {
X		    if( *cp == '\\' ) {
X			lit = name = TRUE; /* quote next, interpret as name */
X			continue;
X		    }
X		    if( isspace(*cp) && !lit )
X			break;
X		    if( !isdigit(*cp) )
X			name = TRUE;
X		    *tp++ = *cp;
X		    lit = FALSE;
X		}
X		*tp = EOS;		/* tie off string */
X		if( tp == temp || *cp == EOS ) /* empty string, or EOS? */
X		    break;		/* must have two fields */
X
X		hyp = (*cp == '-');	/* unquoted hypen means a range */
X		if( !name )
X		    min = atoi( temp );
X		else if( (gr = getgrnam( temp )) != NULL )
X		    min = gr->gr_gid;
X		else if( (pw = getpwnam( temp )) != NULL )
X		    min = pw->pw_uid;
X		else
X		    break;
X
X		if( hyp ) {
X		    tp = temp;
X		    name = lit = FALSE;
X		    for( ; *cp ; cp++ ) {
X			if( *cp == '\\' ) {
X			    /* quote next, interpret as name */
X			    lit = name = TRUE;
X			    continue;
X			}
X			if( isspace(*cp) && !lit )
X			    break;
X			if( !isdigit(*cp) )
X			    name = TRUE;
X
X			*tp++ = *cp;
X			lit = FALSE;
X		    }
X		    if( tp == temp || *cp == EOS )
X			break;
X		    *tp = EOS;
X		    if( !name )
X			max = atoi( temp );
X		    else if( (gr = getgrnam( temp )) != NULL )
X			max = gr->gr_gid;
X		    else if( (pw = getpwnam( temp )) != NULL )
X			max = pw->pw_uid;
X		    else
X			break;
X		}
X		else
X		    max = min;
X
X		if( !skipwhite(&cp) )
X		    break;
X		grp = *cp++;
X		skipwhite(&cp);
X
X		accts[naccts].min = min;
X		accts[naccts].max = max;
X		accts[naccts].group = grp;
X		accts[naccts].name = savestr( cp );
X		naccts++;
X		if( sw_debug )
X		    printf("acct: %d-%d %c %s\n", min, max, grp, cp );
X	    }
X	    break;
X
X	case BUILDING:
X	    if( nbuildings < NBUILDINGS ) {
X		cp = buf+1;
X		if( skipwhite(&cp) ) {
X		    buildings[nbuildings].code = buf[0];
X		    buildings[nbuildings].name = savestr( cp );
X		    nbuildings++;
X		    if( sw_debug )
X			printf("bldg: %c %s\n", buf[0], cp );
X		}
X	    }
X	    break;
X
X	case OPT:
X	    /* options to set; ie; sw_berkeley, sw_its */
X	    break;
X
X	case PHONE:
X	    if( nphones < NPHONES ) {
X		int splats;
X
X		splats = 0;
X		for( cp = buf; *cp; cp++ )
X		    if( *cp == NUMBER )
X			splats++;
X		if( splats > 0 ) {
X		    phones[nphones].splats = splats;
X		    phones[nphones].pat = savestr( buf );
X		    nphones++;
X		    if( sw_debug )
X			printf("phone: %d %s\n", splats, buf );
X		}
X	    }
X	    break;
X
X	case HIDDEN:
X	    if( nhidden < NHIDDEN ) {
X		hidden[nhidden] = savestr( buf );
X		nhidden++;
X		if( sw_debug )
X		    printf("hidden: %s\n", buf );
X	    }
X	    break;
X
X	case PREFIX:
X	    if( nprefixes < NPREFIX ) {
X		prefix[nprefixes] = savestr( buf );
X		nprefixes++;
X		if( sw_debug )
X		    printf("prefix: %s\n", buf );
X	    }
X	    break;
X
X	case ROUTE:
X	    break;
X
X	} /* state switch */
X    } while( fgets( buf, sizeof( buf ), f ) != NULL );
X    if( sw_debug )
X	printf("\
Xconf: %d accts, %d buildings, %d hidden, %d phones, %d prefixes\n",
X	       naccts, nbuildings, nhidden, nphones, nprefixes );
X    return( TRUE );
X} /* read_conf */
X
X/*
X *	routines called from outside...
X */
X
XGLOBAL int ishidden( str )
X    char *str;
X{
X    register int i;
X
X    for( i = 0; i < nhidden; i++ )
X	if( strcmp( str, hidden[i] ) == 0 )
X	    return( TRUE );
X    return( FALSE );
X}
X
XGLOBAL char *conf_prefix( i )
X    int i;
X{
X    if( i > nprefixes )
X	return( NULL );
X    return( prefix[i] );
X}
X
XGLOBAL void acct_group( pp )
X    PERSON *pp;
X{
X    int i;
X    register struct acct *ap;
X
X    for( i = 0, ap = accts; i < naccts; i++, ap++ ) {
X	if( ap->min <= ap->max ) {
X	    if( pp->p_gid >= ap->min && pp->p_gid <= ap->max ) {
X		pp->p_group = ap->group;
X		return;
X	    }
X	}
X	else if( pp->p_gid >= ap->max && pp->p_gid <= ap->min ) {
X	    pp->p_group = ap->group;
X	    return;
X	}
X    }
X    if( pp->p_gid == pp->p_uid )
X	pp->p_group = '.';		/* use '=' ? */
X    else
X	pp->p_group = ' ';
X}
X
XGLOBAL char *acct_name( pp )
X    PERSON *pp;
X{
X    int i;
X    register struct acct *ap;
X
X    for( i = 0, ap = accts; i < naccts; i++, ap++ ) {
X	if( ap->min <= ap->max ) {
X	    if( pp->p_gid >= ap->min && pp->p_gid <= ap->max )
X		return( ap->name );
X	}
X	else if( pp->p_gid >= ap->max && pp->p_gid <= ap->min )
X	    return( ap->name );
X    }
X    return( NULL );
X}
X
XGLOBAL void catphone( dest, phone )
X    register char *dest, *phone;
X{
X    char *ph;
X    int digits, other, i;
X
X    ph = phone;
X    for( digits = other = 0; *phone != EOS; phone++ )
X	if( isdigit(*phone) )
X	    digits++;
X	else
X	    other++;
X
X    if( 
X# ifdef FORMAT_DIGITS_ONLY
X       other == 0 &&
X# endif /* FORMAT_DIGITS_ONLY defined */
X       digits > 0 ) {
X	while( *dest != EOS )
X	    dest++;
X
X	for( i = 0; i < nphones; i++ )
X	    if( phones[i].splats == digits ) {
X		register char *pat;
X
X		phone = ph;
X		for( pat = phones[i].pat; *pat != EOS; pat++ ) {
X		    if( *pat == NUMBER ) {
X			while( !isdigit(*phone) )
X			    phone++;
X			*dest++ = *phone++;
X		    }
X		    else
X			*dest++ = *pat;
X		}
X		*dest = EOS;
X		return;
X	    }
X    } /* other == 0 && digits > 0 */
X    strcat( dest, phone );
X}
X
X/* given an office string, return formatted in a static buffer */
X# define OFFSIZ 100
X
XGLOBAL char *office( s )
X    char *s;
X{
X    char offbuff[OFFSIZ];
X    int i, l;
X
X    l = strlen( s );
X    if( l > OFFSIZ - 10 )	/* close? */
X	return( s );		/* good-bye */
X
X    for( i = 0; i < nbuildings; i++ )
X	if( buildings[i].code == s[l-1] )
X	    break;
X
X    if( i >= nbuildings )
X	return( s );
X
X    strcpy(offbuff, s);
X    offbuff[l-1] = EOS;
X    strcat(offbuff, buildings[i].name );
X    return( offbuff );
X} /* office */
END_OF_conf.c
if test 8973 -ne `wc -c <conf.c`; then
    echo shar: \"conf.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f names.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"names.c\"
else
echo shar: Extracting \"names.c\" \(7736 characters\)
sed "s/^X//" >names.c <<'END_OF_names.c'
X/*
X * names.c -- lookup names via nlist
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: names.c,v 3.0 90/07/06 13:11:24 budd Rel $";
X# endif /* lint not defined */
X
X# include "finger.h"
X
X# ifdef DEBUGSW
X# define IFDEBUG( x ) if( sw_debug ) printf x
X# else  /* DEBUGSW not defined */
X# define IFDEBUG( x )
X# endif /* DEBUGSW not defined */
X
X# if Umax != 42				/* the rest of the file.... */
X
X# ifdef USG
X# include <fcntl.h>
X/* TODO: <sys/var.h> check info_proc vs. ((proc *)v.ve_proc) - v.v_proc */
X# else  /* USG not defined */
X# include <sys/file.h>
X# endif /* USG not defined */
X# include <sys/types.h>
X# include <sys/stat.h>
X# ifdef AUX
X# include <a.out.h>
X# else  /* AUX not defined */
X# include <nlist.h>
X# endif /* AUX not defined */
X# include <stdio.h>
X
X# include "args.h"
X# include "info.h"			/* after finger.h */
X# include "kmem.h"
X
Xlong symdate =
X# include "symdate.h"
X;
X
XGLOBAL struct info I;
X
Xextern FTYPE kmem;			/* from kmem.c */
X
Xextern char longversion[];		/* from version.c */
Xextern char *sys_errlist[];		/* from library */
Xextern int errno;			/* from library */
X
Xstruct nlist nl[] = {			/* nlist table */
X# ifdef UNDERSCORE_NLIST_NAMES
X# define SYM(s,sc,m) { s },
X# else  /* UNDERSCORE_NLIST_NAMES not defined */
X# define SYM(s,sc,m) { sc },
X# endif /* UNDERSCORE_NLIST_NAMES not defined */
X# include "syms.h"
X# undef SYM
X    ""
X};
X# define LNL ((sizeof(nl)/sizeof(struct nlist))-1)
X
Xunsigned long *nvptrs[] = {
X# define SYM(s,sc,m) CONC(&I.info_,m) ,	/* build table of pointers to values */
X# include "syms.h"
X# undef SYM
X};
X
XLOCAL int readnlist(kfile)		/* force read of nlist */
Xchar *kfile;
X{
X    register int i;
X    struct stat kernst;
X# ifdef HAVE_VERSION
X    char kmem_verstr[ VERSTRLEN+1 ];
X# endif /* HAVE_VERSION defined */
X
X    IFDEBUG(("getting namelist from %s\n", kfile ));
X
X    if( nlist(kfile, nl) < 0 ) {
X	fprintf(stderr, "%%Could not read %s namelist\n", kfile );
X	return( FALSE );
X    }
X
X    for( i = 0; i < LNL; i++ ) {
X	if(
X# ifndef COFF
X	  nl[i].n_type == N_UNDF &&
X# endif /* COFF not defined */
X	  nl[i].n_value == 0L ) {
X	    fprintf(stderr, "%%No namelist entry for %s\n", nl[i].n_name );
X	    return( FALSE );
X	} /* empty entry */
X	*nvptrs[i] = nl[i].n_value;
X    } /* for i */
X
X    if( stat( kfile, &kernst ) == 0 ) {
X	I.info_kerneldate = kernst.st_mtime;
X	I.info_kernelsize = kernst.st_size;
X	I.info_symdate = symdate;
X    } /* stat */
X
X    strncpy( I.info_fingerversion, longversion, sizeof( I.info_fingerversion));
X# ifdef HAVE_VERSION
X    bzero( I.info_verstr, sizeof( I.info_verstr ) );
X    bzero( kmem_verstr,  sizeof( kmem_verstr )  );
X
X    /* save _version from /vmunix in I.info_verstr */
X    if( read_vmunix( KERNEL_FILE, I.info_version,
X		    I.info_verstr, VERSTRLEN ) ) {
X	I.info_verstr[VERSTRLEN] = '\0';
X
X# ifdef DEBUGSW
X	if( sw_debug ) {
X	    printf("info_version %#x\n", I.info_version );
X	    printf("%s:\n", kfile );
X	    printf("%*s\n", -VERSTRLEN, I.info_verstr );
X	}
X# endif /* DEBUGSW defined */
X
X# ifdef PICKY
X	/*
X	 * be picky.... insist that running kernel
X	 * contain same string at same location
X	 */
X
X	if( KMEMREAD(I.info_version, kmem_verstr,  VERSTRLEN ) ) {
X	    kmem_verstr[VERSTRLEN] = '\0';
X
X# ifdef DEBUGSW
X	    if( sw_debug ) {
X		printf("kmem @ %#x:\n", I.info_version );
X		printf("%*s\n", -VERSTRLEN, kmem_verstr );
X	    }
X# endif /* DEBUGSW defined */
X
X	    /* if match, we win */
X	    if( strncmp( kmem_verstr, I.info_verstr, VERSTRLEN ) == 0 )
X		return( TRUE );
X	} /* kread ok */
X# endif /* PICKY defined */
X    } /* got version from /vmunix file */
X# ifdef PICKY
X    return( FALSE );
X# else  /* PICKY not defined */
X    return( TRUE );
X# endif /* PICKY not defined */
X# else  /* HAVE_VERSION not defined */
X    return( TRUE );
X# endif /* HAVE_VERSION not defined */
X} /* readnlist */
X
XLOCAL int writenfile( kfile )
Xchar *kfile;
X{
X    int nfile;
X
X    if( !readnlist( kfile ) )
X	return( FALSE );
X
X    if( sw_nosave )			/* write prohibited? */
X	return( TRUE );			/* be nice */
X
X    IFDEBUG(("writing %s\n", SAVED_NLIST ));
X    if( (nfile=open( SAVED_NLIST, O_TRUNC|O_CREAT|O_WRONLY,
X		    NLIST_MODE)) >= 0 ) {
X	write( nfile, &I, sizeof( I ) );
X# ifndef USG
X	fchown( nfile, geteuid(), getegid() );
X	fchmod( nfile, NLIST_MODE );
X# else  /* USG defined */
X	chown( SAVED_NLIST, geteuid(), getegid() );
X	chmod( SAVED_NLIST, NLIST_MODE );
X# endif /* USG defined */
X	close( nfile );
X    } /* open for write */
X    else
X	fprintf( stderr, "%%Could not write %s (%s)\n",
X		SAVED_NLIST, sys_errlist[ errno ] );
X    return( TRUE );
X} /* writenfile */
X
XGLOBAL int readnames() {	/* get nlist from save file or /vmunix */
X# ifdef SAVED_NLIST
X    int nfile, oknfile, oknlist;
X    struct stat savst, kernst;
X    char kmem_verstr[ VERSTRLEN+1 ];
X
X    oknfile = oknlist = FALSE;
X
X    /* check if SAVED_NLIST exists, is right size */
X    /* built from same copy of syms.h */
X    if( !sw_read ) {				/* not getting new save */
X	IFDEBUG(("%s: ", SAVED_NLIST ));
X	if( stat( SAVED_NLIST, &savst ) == 0 &&	/* got status of save file */
X	   savst.st_size == sizeof( I ) ) {	/* data file is right size */
X	    IFDEBUG(("size ok "));
X
X	    if( (nfile = open( SAVED_NLIST, O_RDONLY )) >= 0 ) { /* opened */
X		if( read( nfile, &I, sizeof( I ) ) == sizeof( I ) ) {
X		    IFDEBUG(("read ok "));
X		    if( I.info_symdate == symdate ) {/* same copy of syms.h? */
X			oknfile = TRUE;		/* doing fine */
X			IFDEBUG(("symdate ok "));
X		    } /* same copy of syms.h */
X# ifdef DEBUGSW
X		    else if( sw_debug )
X			printf("*symdate mismatch*");
X# endif /* DEBUGSW defined */
X
X		}
X		close( nfile );
X	    } /* open ok */
X	} /* stat + size ok */
X	IFDEBUG(("\n"));
X    } /* not sw_read */
X
X    if( sw_read || !oknfile )		/* if no good fall back on /vmunix */
X	return( writenfile( KERNEL_FILE ) );
X
X# ifdef AUTONLIST
X    /*
X     *	does version string in running kernel match that of
X     *  the kernel that was running when the nlist file was created?
X     */
X# ifdef HAVE_VERSION
X    if( I.info_version != 0L ) {		/* have addr for verstr */
X	bzero( kmem_verstr, sizeof( kmem_verstr ) );
X	if( KMEMREAD( I.info_version, kmem_verstr, VERSTRLEN ) ) {
X# ifdef DEBUGSW
X	    if( sw_debug ) {
X		printf("kmem @ %#x:\n", I.info_version );
X		printf("%*s\n", -VERSTRLEN, kmem_verstr );
X		printf("info_verstr:\n");
X		printf("%*s\n", -VERSTRLEN, I.info_verstr );
X	    } /* sw_debug */
X# endif /* DEBUGSW defined */
X	    if( strncmp( I.info_verstr, kmem_verstr, VERSTRLEN ) == 0  )
X		oknlist = TRUE;			/* matches!! */
X	} /* kread ok */
X    } /* version != 0 */
X    else
X# endif /* HAVE_VERSION defined */
X	if( stat( KERNEL_FILE, &kernst ) == 0 &&   /* get kernel date/size */
X	    savst.st_mtime > kernst.st_mtime &&	  /* more recent than kernel */
X	    I.info_kerneldate == kernst.st_mtime && /* same /vmunix */
X	    I.info_kernelsize == kernst.st_size ) {
X# ifdef DEBUGSW
X	if( sw_debug )
X	    printf("%s and %s kernel size and date match\n",
X		   SAVED_NLIST, KERNEL_FILE );
X# endif /* DEBUGSW defined */
X	oknlist = TRUE;
X    } /* stat ok... */
X    if( !oknlist )
X	return( writenfile( KERNEL_FILE ) );
X# else  /* AUTONLIST not defined */
X    if( !oknlist )
X	return( readnlist( KERNEL_FILE ) );
X# endif /* AUTONLIST not defined */
X    return( TRUE );
X# else  /* SAVED_NLIST not defined */
X    return( readnlist( KERNEL_FILE ) );
X# endif /* SAVED_NLIST not defined */
X} /* readnames */
X
X# endif /* Umax != 42 */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_names.c
if test 7736 -ne `wc -c <names.c`; then
    echo shar: \"names.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f output.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"output.c\"
else
echo shar: Extracting \"output.c\" \(7837 characters\)
sed "s/^X//" >output.c <<'END_OF_output.c'
X/*
X * output.c -- terminal & output for new finger
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: output.c,v 3.0 90/07/06 13:11:28 budd Rel $";
X# endif /* lint not defined */
X
X# include "finger.h"
X# include <sys/types.h>
X# include <sys/ioctl.h>
X# include <sys/stat.h>
X# include <stdio.h>
X# ifdef TTY_GROUP
X# include <grp.h>
X# endif /* TTY_GROUP defined */
X# include "output.h"
X# include "args.h"			/* sw_output (before luser.h) */
X# include "luser.h"
X
Xextern char *getenv();			/* from library */
Xextern int netfinger;			/* from args.c */
X
XLOCAL int term_width;			/* termcap width */
XLOCAL int output_col;			/* keep track of chars outchar'ed */
XLOCAL int done_output;			/* keep track for blank lines */
X
X# ifndef DEFWIDTH
X# define DEFWIDTH (MAXLINE-1)
X# endif /* DEFWIDTH not defined */
X
XGLOBAL void ptree( u, routine )
Xregister LUSER *u;
Xint (*routine)();
X{
X    if( u == NULL )
X        return;
X
X    if( u->u_left != NULL )
X        ptree( u->u_left, routine );
X
X    (*routine)(u);
X
X    if( u->u_right != NULL )
X        ptree( u->u_right, routine );
X} /* ptree */
X
XGLOBAL char *intstr(s, sex)		/* print an interval */
Xchar *s;				/* buffer to use (if needed) */
Xlong sex;
X{
X    long min, hours, days;
X
X    min = sex / 60;			/* get minutes */
X
X    s[0] = EOS;				/* zap buffer */
X    if( min <= 0 )			/* worth thinking about? */
X	return( s );
X
X    hours = min / 60;			/* get hours */
X    min = min % 60;			/* cast out hours */
X
X    days = hours / 24;			/* get number of days */
X    hours = hours % 24;			/* cast out days */
X
X    if( days > 0 ) {			/* over a day? */
X        if( days < 10 ) {		/* but still 1 digit? */
X	    if( hours < 1 )
X		sprintf(s, "%dday", days); /* don't print 0h */
X	    else if( hours < 10 )
X		sprintf(s, "%dd%dh", days, hours ); /* <days>d<hours>h */
X	    else
X		sprintf(s, "%dd%d", days, hours ); /* <days>d<hours> */
X	} /* < 10 days */
X	else {
X	    int weeks, d2;
X
X	    weeks = days / 7;
X	    d2 = days % 7;
X	    if( weeks < 10 ) {
X		if( d2 == 0 ) {
X		    if( hours < 10 )
X			sprintf(s, "%dw%dh", weeks, hours );
X		    else
X			sprintf(s, "%dwks", weeks );
X		}
X		else
X		    sprintf(s, "%dw%dd", weeks, d2 );
X	    } /* < 10 weeks */
X	    else if( weeks < 100 ) { 	/* (693 days!) */
X		if( d2 > 0 )
X		    sprintf(s, "%dw%d", weeks, d2 );
X		else
X		    sprintf(s, "%dwk", weeks );
X	    } /* lt 100 weeks */
X	    else if( days < 1000 )
X		sprintf(s, "%3dd", days); /* print three digits of day */
X	    else			/* print years?? .... nah... */
X		strcpy(s, "*:**");	/* P-U-N-T ! */
X	} /* > 9 days */
X    } /* days > 0 */
X    else {				/* days == 0 */
X	if( hours == 0 )		/* less than an hour? */
X	    sprintf(s, "%4d", min); 	/* just minutes */
X	else if( hours < 10 )		/* one digit of hours? */
X	    sprintf(s, "%1d:%02d", hours, min);	/* print h:mn */
X	else				/* hours >= 10 (must be <= 23) */
X	    sprintf(s, "%2d:%1d", hours, min / 10); /* print hh:m */
X    } /* days == 0 */
X    return( s );      
X} /* intstr */
X
X/*
X *	termstat - given a LUSER record, get stat(2) information for terminal
X *		   returns TRUE for success
X */
X
XGLOBAL void termstat( u )
XLUSER *u;
X{
X    char term[30];
X    struct stat stb;
X# ifdef Umax
X    LOCAL short rdpminor = -1;
X# endif /* Umax defined */
X
X# ifdef TTY_GROUP
X    LOCAL int ttygroup = -1;
X
X    if( ttygroup < 0 ) {
X	struct group *gr;
X	if( (gr = getgrnam("tty")) != NULL )
X	    ttygroup = gr->gr_gid;
X# ifdef TTY_GROUP_NUMBER
X	else
X	    ttygroup = TTY_GROUP_NUMBER;
X# endif /* TTY_GROUP_NUMBER defined */
X	endgrent();
X    } /* get ttygroup */
X# endif /* TTY_GROUP defined */
X
X    if( u == NULL )
X	return;
X
X# ifdef Umax
X    if( rdpminor == -1 ) {
X	if( stat( "/dev/rdpcontrol", &stb ) == 0 && 
X	   (stb.st_mode & S_IFMT) == S_IFCHR )
X	    rdpminor = minor( stb.st_rdev );
X	else
X	    rdpminor = -2;
X    }
X# endif /* Umax defined */
X
X    strcpy(term, "/dev/");
X    strcat(term, u->u_line);
X    if( stat(term, &stb) < 0 || (stb.st_mode & S_IFMT) != S_IFCHR ) {
X	u->u_flags |= U_BADTTY;		/* bad device!? */
X	return;
X    }
X
X    if( sw_output )
X	u->u_idle = time( 0 ) - stb.st_mtime; /* save (output) idle time */
X    else
X	u->u_idle = time( 0 ) - stb.st_atime; /* save idle time */
X
X    u->u_ttydev = stb.st_rdev;		/* save major/minor device numbers */
X# ifdef AIX3
X    if( S_ISMPX( stb.st_mode ) ) {
X	char *cp;
X
X	cp = rindex( u->u_line, '/' );
X	if( cp != NULL )
X	    u->u_ttydev += atoi( cp+1 );
X    }
X# endif /* AIX3 defined */
X
X# ifdef Umax
X    if( minor(stb.st_rdev) == rdpminor ) {
X	u->u_ttyaddr = stb.st_rdaddr; 	/* annex/rdp inet addr */
X	u->u_ttytype = stb.st_rdtype;	/* annex/rdp device type */
X	u->u_ttynum =  stb.st_rdnum;	/* annex/rdp line number */
X    }
X    else
X	u->u_ttyaddr = 0;		/* needed in Umax 4.3 (rel 4.0) */
X# endif /* Umax defined */
X
X    if( (stb.st_mode & 0100) != 0 )	/* owner execute? */
X	u->u_flags |= U_BIFF;		/* yes, biff y */
X
X    if( (stb.st_mode & 01) != 0 )	/* world execute? */
X	u->u_flags |= U_HUNGRY;		/* yes, is hungry! */
X
X# ifdef TTY_GROUP
X    if( (stb.st_mode & 0002) == 0 && 
X       (stb.st_gid != ttygroup || (stb.st_mode & 0020) == 0 ) )
X	u->u_flags |= U_NOWRITE;	/* no, msg n */
X# else  /* TTY_GROUP not defined */
X    if( (stb.st_mode & 0002) == 0 )	/* world write permission? */
X	u->u_flags |= U_NOWRITE;	/* no, msg n */
X# endif /* TTY_GROUP not defined */
X    
X    return;
X} /* termstat */
X
XGLOBAL char *gtname( s )
Xchar *s;
X{
X    /* .see TTY_PREFIX (in getent.c) */
X    if( *s == 't' && s[1] == 't' && s[2] == 'y' )
X	return( s+3 );
X# ifdef UmaxV
X    if( *s == 'r' && s[1] == 't' || *s == 'R' && s[1] == 'T' )
X	return( s+2 );
X# endif /* UmaxV defined */
X    return( s );
X} /* gtname */
X
X/*
X *	outline - output a line of text, obeying width of device
X */
X
XGLOBAL void outchar(c)
Xchar c;
X{
X    if( c == '\t' )
X	output_col = (output_col + 8) & ~7;
X    else if( c == '\n' ) {
X	output_col = 0;
X	if( netfinger )
X	    putc('\r', OUTPUT );
X    }
X    else
X	output_col++;
X    done_output = TRUE;
X    putc(c, OUTPUT);
X} /* outchar */
X
XGLOBAL void outline( line )
Xregister char *line;
X{
X    register int c;
X
X    while( output_col < term_width ) {
X	if( (c = *line++) == EOS )
X	    break;
X	else
X	    outchar(c);
X    } /* for col */
X
X    outchar('\n');
X} /* outline */
X
XGLOBAL void blankline() {
X    if( done_output )
X	outchar( '\n' );
X    done_output = FALSE;
X} /* blankline */
X
XGLOBAL void getterm() {
X# ifdef TIOCGWINSZ			/* 4.3 */
X    struct winsize ws;
X# endif /* TIOCGWINSZ defined */
X# ifdef TIOCGSIZE			/* SOS3 */
X    struct ttysize ts;
X# endif /* TIOCGSIZE defined */
X    char tbuf[1024];			/* termcap defn */
X    char *term;				/* terminal type */
X    int w;				/* width */
X
X    if( netfinger || !isatty(STD_OUTPUT) ) { /* stdout not a terminal? */
X	term_width = PLUS_INF;		/* no output truncation */
X	return;
X    }
X    term_width = DEFWIDTH;
X    w = -1;
X
X# ifdef TIOCGWINSZ			/* 4.3 ioctl */
X    if( ioctl( STD_OUTPUT, TIOCGWINSZ, &ws ) == 0 )
X	w = ws.ws_col;
X# endif /* TIOCGWINSZ defined */
X# ifdef TIOCGSIZE
X    if( w <= 0 && ioctl( STD_OUTPUT, TIOCGSIZE, &ts ) == 0 )
X	w = ts.ts_cols;
X# endif /* TIOCGSIZE defined */
X    if( (term = getenv("TERM")) != NULL && /* get terminal type */
X       tgetent(tbuf, term) == 1 ) {	/* get termcap entry into tbuf */
X	if( w <= 0 )
X	    w = tgetnum("co");		/* get cols */
X
X	if( tgetflag("am") )		/* auto wrap? */
X	    w--;			/* yes, narrow by 1 */
X    } /* got termcap entry */
X    else
X	w--;				/* assume the worst */
X
X    if( w > 0 )				/* get width? */
X	term_width = w;			/* set it */
X} /* getterm */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_output.c
if test 7837 -ne `wc -c <output.c`; then
    echo shar: \"output.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f select.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"select.c\"
else
echo shar: Extracting \"select.c\" \(7584 characters\)
sed "s/^X//" >select.c <<'END_OF_select.c'
X/*
X * select.c -- perform selection process for finger
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: select.c,v 3.0 90/07/06 13:11:41 budd Rel $";
X# endif /* lint not defined */
X
X# include <pwd.h>
X# include <stdio.h>
X# include <sys/types.h>
X# include <strings.h>
X# include "person.h"
X# include "args.h"			/* before luser.h */
X# include "luser.h"
X# include "finger.h"
X# include "inquire.h"
X
Xtypedef struct sel {
X    char *s_name;			/* name of selector (upper case) */
X					/* for match against lusers */
X    int s_matches;			/* number of users matched */
X    char *s_orig;			/* name in living color (orig case) */
X					/* for passwd file lookup */
X    struct switches s_sw;		/* per selector flags!! */
X    struct sel *s_next;			/* next in chain */
X} SEL;
X
Xextern PERSON *makeperson();		/* from getperson.c */
Xextern LTREE *linsert(), *ent_select();	/* from getent.c  */
Xextern LUSER *newluser();		/* from getent.c */
Xextern BOOL useinquire;			/* from args.c */
X
XLOCAL SEL *selhead;			/* chain of selectors */
XLOCAL SEL *seltail;			/* tail of selector chain */
X
XLOCAL LTREE *luser_tree;		/* tree of lusers from selectors */
X
XLOCAL LUSER *copy_not_found();		/* forward */
XLOCAL void insert_winner();		/* forward */
X
XGLOBAL void ini_select() {		/* initialize select.c statics */
X    selhead = seltail = NULL;
X    luser_tree = NULL;
X} /* ini_select */
X
XGLOBAL BOOL have_locals() {		/* find out if we have any SEL's */
X    return( selhead != NULL );
X} /* havelocal */
X
XGLOBAL void addlocal( name )		/* add a local finger selector */
Xchar *name;
X{
X    register SEL *new;
X
X    if( (new = (SEL *)malloc( sizeof( SEL ) )) == NULL ) {
X	fprintf(stderr, "malloc failed in sinsert\n");
X	exit( 1 );
X    } /* malloc failed */
X
X    new->s_orig = savestr( name );
X    new->s_name = name;
X    zup( name );
X    new->s_matches = 0;
X    new->s_sw = Sw;
X    new->s_next = NULL;
X
X    if( selhead == NULL )
X	selhead = seltail = new;
X    else {
X	seltail->s_next = new;
X	seltail = new;
X    }
X} /* addlocal */
X
XGLOBAL void select_go() {		/* here to finger local users */
X    struct passwd *pw;
X    LTREE *tree2;
X    int flag;
X    SEL *sp;
X
X    setpwent();
X    if( !useinquire ) {
X	while( (pw = getpwent()) != NULL ) {
X	    LOCAL SEL *match();
X	    SEL *winner;		/* the selector that matched */
X	    char person[ 100 ], *tp;
X
X	    if( selhead == NULL )
X		break;
X
X	    /* BUG: handle USG format gecos fields!! */
X	    /* copy gecos (WISH: only if comma)*/
X	    strcpy( person, pw->pw_gecos );
X	    if( (tp = index(person, ',')) != NULL ) /* find a comma? */
X		*tp = EOS;			/* yes, blast it. */
X
X	    /* find a selector that matches uname or personal name */
X	    winner = match( pw->pw_name, person );
X	    if( winner != NULL )
X		insert_winner( winner, pw->pw_name, pw );
X	} /* while */
X    } /* no inquire */
X# ifdef INQUIRE
X    else {				/* use inquire */
X	struct block *bp;
X
X	for( sp = selhead; sp != NULL; sp = sp->s_next ) {
X	    if( Read( sp->s_name, BPs ) != NULL )
X		insert_winner( sp, BPs[_UNAME], NULL, BPs );
X
X	    if( sp->s_sw.sw_match )
X		continue;
X
X	    /* Use FindPerson (inquire internal lastname lookup) */
X	    for(bp = FindPerson( sp->s_name ); bp != NULL; /* find all */
X		bp = NextPerson( sp->s_name, bp) ){ /* matching lastnames */
X		Expand( bp, BPs );
X		insert_winner( sp, BPs[_UNAME], NULL, BPs );
X	    } /* for matching persons */
X	} /* for each sel */
X    } /* useinquire */
X# endif /* INQUIRE defined */
X
X    /* one last try for unmatched selectors (or ones added by /follow!) */
X    for( sp = selhead; sp != NULL; sp = sp->s_next ) {
X	if( sp->s_matches == 0 ) {
X	    struct passwd *pw;
X
X	    pw = getpwnam( sp->s_orig );
X	    if( pw != NULL )
X		insert_winner( sp, pw->pw_name, pw, NULL );
X	} /* no matches */
X    } /* for */
X
X    endpwent();
X
X    tree2 = ent_select( luser_tree ); 	/* get tree of logged in people */
X    tree2 = copy_not_found( luser_tree, tree2 ); /* merge people not on */
X
X    flag = 0;
X    for( sp = selhead; sp != NULL; sp = sp->s_next )
X	if( sp->s_matches == 0 ) {
X	    if( flag == 0 )
X		fprintf(stderr, "%%No matches for ");
X	    else
X		fputs( ", ", stderr );
X	    fputs( sp->s_orig, stderr );
X	    flag++;
X	}
X    if( flag > 0 )
X	putc( '\n', stderr );
X
X    if( tree2 != NULL )			/* get anything? */
X	dofinger( tree2 );
X} /* select_go */
X
X/* PERHAPS LUSERS SHOULD BE IN A LIST (avoid recursion) */
X/* see newluser in getent.c?  WISH */
X
X/* returns merged tree of logged in users and prototypes never found (NLI) */
X
XLOCAL LUSER *copy_not_found( proto, out )
XLUSER *proto, *out;			/* not logged in, output tree */
X{
X    if( proto != NULL ) {
X	/* travese bottom up, so safe to remove elements */
X	out = copy_not_found( proto->u_left, out );
X	out = copy_not_found( proto->u_right, out );
X	
X	if( (proto->u_flags & U_FOUND) == 0 ) {	/* proto never found? */
X	    proto->u_left = proto->u_right = NULL; /* remove from tree */
X	    out = linsert( proto, out ); /* insert into output tree */
X	} /* if not found */
X    } /* have a prototype */
X    return( out );
X} /* copy_not_found */
X
XLOCAL SEL *match(uname, fullname)	/* return a sel that matches */
Xchar *uname, *fullname;
X{
X    char *tp;
X    int nfull;
X    register SEL *sp;
X    char temp[ 512 ], temp2[ 512 ], *fullp[ 128 ];
X
X    strupcpy(temp, uname );		/* make upper case copy of uname */
X
X    nfull = 0;
X    if( fullname != NULL ) {
X	strupcpy(temp2, fullname);	/* copy personal, upper case */
X	tp = temp2;			/* point to fullname */
X	for( ; ; ) {
X	    register char *bp;		/* pointer to start of token */
X
X	    if( !skipwhite( &tp ) )	/* skip leading white */
X		break;
X
X	    bp = tp;			/* save start of token */
X	    if( !skipblack( &tp ) && bp == tp )
X		break;
X
X	    *tp++ = EOS;		/* tie off token */
X	    fullp[ nfull++ ] = bp;
X	} /* forever */
X    } /* have fullname */
X
X    for( sp = selhead; sp != NULL; sp = sp->s_next ) {
X	register int i;
X
X	if( strcmp( temp, sp->s_name ) == 0 )
X	    return( sp );
X
X	if( sp->s_sw.sw_match		/* allow match on fullname? */
X	   || nfull == 0 )		/* have one?? */
X	    continue;
X
X	for( i = 0; i < nfull; i++ )
X	    if( strcmp( fullp[i], sp->s_name ) == 0 )
X		return( sp );
X    }
X    return( NULL );
X} /* match */
X
XLOCAL void insert_winner( winner, uname, pw, inq )
XSEL *winner;
Xchar *uname;
Xstruct passwd *pw;
Xstruct info *inq;			/* for INQUIRE */
X{
X    register LUSER *u;
X
X    /* find a matching selector? is it in luser_tree already? */
X    if( winner == NULL  ||  treefind( luser_tree, uname ) != NULL )
X	return;
X    winner->s_matches++;		/* count our conquests */
X
X    if( pw == NULL ) {
X	pw = getpwnam( uname );
X# ifdef DEBUG
X	if( pw == NULL )
X	    printf("no pw entry for %s\n", uname );
X# endif /* DEBUG defined */
X    }
X
X    /* found a new matching selector. create entry */
X
X    u = newluser();			/* create a user */
X    strcpy(u->u_user, uname);		/* set user name! */
X# ifdef INQUIRE
X    u->u_person = makeperson( u, pw, inq ); /* build person struct */
X# else  /* INQUIRE not defined */
X    u->u_person = makeperson( u, pw, NULL ); /* build person struct */
X# endif /* INQUIRE not defined */
X    u->u_flags |= U_NLI;		/* say not logged in */
X    u->u_sw = winner->s_sw;		/* inherit switched from SEL */
X    luser_tree = linsert(u, luser_tree);
X} /* insert_winner */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_select.c
if test 7584 -ne `wc -c <select.c`; then
    echo shar: \"select.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f switch.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"switch.c\"
else
echo shar: Extracting \"switch.c\" \(7158 characters\)
sed "s/^X//" >switch.c <<'END_OF_switch.c'
X/*
X * switch.c -- process switches (flags)	July 1987
X *
X * Copyright (C) 1987, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: switch.c,v 3.0 90/07/06 13:11:48 budd Rel $";
X# endif /* lint not defined */
X
X# include <stdio.h>
X# include <strings.h>
X# include <ctype.h>
X# include <signal.h>
X
X# ifndef sigmask
X# define sigmask(s) (1<<(s))
X# endif /* sigmask not defined */
X
X# include "args.h"
X# include "finger.h"
X
X# ifndef PAGER
X# define PAGER "more"
X# endif /* PAGER not defined */
X
X# ifndef BUGS_TO
X# define BUGS_TO "bug-finger@bu-it.bu.edu"
X# endif /* BUGS_TO not defined */
X
Xextern char *getenv();			/* libc */
Xextern char longversion[];		/* from version.c */
X
X# define SWITCH(s,u,a,h) LOCAL int a();
X# include "switch.h"			/* define forwards */
X# undef SWITCH
X
XLOCAL struct switchtab {
X    char *s_name;
X    int s_unique;
X    int (*s_ptr)();
X    char *s_help;
X} switches[] = {
X# define SWITCH(s,u,a,h) { s, u, a, h },
X# include "switch.h"			/* define table entries */
X# undef SWITCH
X    { NULL, NULL }
X};
X
X/*
X *	switch actions
X */
X
X# define SET2(what,name)	\
XLOCAL int CONC(set_,name) ( val ) char *val; \
X{ if( val != NULL )fprintf(stderr, "%%Switch %s takes no args\n", STR(name)); \
X  what = TRUE; return( TRUE ); }
X
X# define SETF(name) SET2(CONC(sw_,name),name)
X# define SETP(name) SET2(CONC(Sw.sw_,name),name)
X
XSETF(age);
XSETF(berkeley);
X# ifdef DEBUGSW
XSETF(debug);
X# endif /* DEBUGSW defined */
XSETF(follow);
XSETF(its);
XSETF(jobs);
XSETF(nosave);
XSETF(output);
XSETF(pid);
XSETF(read);
XSETF(state);
XSETF(whois);
X
X/* per person */
XSETP(location);
XSETP(mail);
XSETP(match);
XSETP(plan);
XSETP(noplan);
X
X# if 0
XLOCAL int set_fields( val )
Xchar *val;
X{
X    if( val == NULL ) {
X	sw_fields = ":";
X	return( TRUE );
X    }
X    sw_fields = val;
X    return( TRUE );
X} /* set fields */
X# endif /* 0 */
X
X# ifdef INQUIRE
XLOCAL int set_noinquire( val )
Xchar *val;
X{
X    extern BOOL useinquire;
X    useinquire = FALSE;
X    return( TRUE );
X} /* set noinquire */
X# endif /* INQUIRE defined */
X
XLOCAL int display_version( val )
Xchar *val;
X{
X    puts( longversion );
X# ifndef lint
X    puts( Copyright );
X# endif /* lint not defined */
X    exit( 0 );
X    return( TRUE );			/* supress complaints */
X}
X
XLOCAL FILE *openpager(pager, mode, pid)
X    char *pager, *mode;
X    int *pid;
X{
X    int pipefd[2], myend;
X    register c;
X
X    if( pipe(pipefd) < 0 ) {
X	perror( "pipe" );
X	return( NULL );
X    }
X
X    /* NOTE!! we depend on myend^1 being the other end */
X    /* and that the child will connect myend to fd myend */
X
X    if( *mode == 'r' )			/* parent reading? */
X	myend = 1;			/* child gets write/stdout */
X    else				/* parent writing. */
X	myend = 0;			/* child gets read/stdin */
X
X    switch( (*pid = fork()) ) {
X    case -1:
X	perror( "fork" );
X	close( pipefd[0] );		/* close reader */
X	close( pipefd[1] );		/* close writer */
X	return( NULL );
X
X    case 0:				/* child */
X	close( pipefd[myend^1] );	/* close other end */
X	if( pipefd[myend] != myend ) {	/* in place?? (unlikely) */
X	    dup2( pipefd[myend], myend ); /* Nope, move it */
X	    close( pipefd[ myend ] );
X	} /* not yet in place */
X	setuid( getuid() );		/* remove any setuidness!!! */
X	setgid( getgid() );
X	execlp( pager, pager, 0 );	/* forgo doing "sh -c cmd" */
X	perror( pager );
X	while( (c = getchar()) != EOF )	/* whoops!! Just copy bytes! */
X	    putchar( c );
X	exit( 0 );
X	/* NOTREACHED */
X
X    default:				/* parent */
X	myend ^= 1;			/* parent gets other end */
X	close( pipefd[myend^1] );	/* close childs end */
X	return( fdopen( pipefd[myend], mode ) ); /* use "rw"[myend] ?? */
X					/* check for failure!! */
X    } /* switch */
X    /* NOTREACHED */
X} /* openpager */
X
XLOCAL int closepager( f, pid )
X    FILE *f;
X    int pid;
X{
X    int pid2, w, smask;
X
X    fclose( f );
X# ifndef USG
X    smask = sigblock( sigmask(SIGHUP) | sigmask(SIGQUIT) | sigmask(SIGINT) );
X# else  /* USG defined */
X# ifdef SIGPOLL				/* SVR3 signaling */
X    sighold( SIGHUP );
X    sighold( SIGQUIT );
X    sighold( SIGINT );
X# endif /* SIGPOLL defined */
X# endif /* USG defined */
X
X    while( (pid2 = wait(&w)) != -1 && pid2 != pid )
X	printf("%d %d\n", pid, pid2);
X
X# ifndef USG
X    sigsetmask( smask );
X# else  /* USG defined */
X# ifdef SIGPOLL				/* SVR3 signaling features */
X    sigrelse( SIGHUP );
X    sigrelse( SIGQUIT );
X    sigrelse( SIGINT );
X# endif /* SIGPOLL defined */
X# endif /* USG defined */
X
X    if( pid2 == -1 )
X	return( -1 );			/* process not found? */
X    return( w );			/* return (whole) status */
X} /* closepager */
X
XLOCAL int display_help( val )
Xchar *val;
X{
X    static char help_format[] = "%-15s %s\n"; /* just one copy */
X    register struct switchtab *sp;
X    char *pager;
X    int pid;
X    FILE *p;
X
X    if( (pager = getenv("PAGER")) == NULL )
X	pager = PAGER;
X
X    if( !isatty(STD_INPUT) || (p = openpager( pager, "w", &pid )) == NULL ) {
X	pager = NULL;			/* oh well */
X	p = stdout;
X    } /* openpager failed */
X
X    fprintf( p, "finger/whois help:\n");
X    fprintf( p, "%s\n",  longversion );
X# ifndef lint
X    fprintf( p, "%s\n",  Copyright );
X# endif /* lint not defined */
X    fprintf( p, "\n\
Xfinger accepts the following as arguments:\n\
Xlocal usernames, local personal names, switches (/sw or -sw),\n\
Xterminal names (+tty0d +0d), self (.), or remote (@host, user@host)\n\
X\n");
X    fprintf( p, help_format, "switch", "action");
X    fprintf( p, help_format, "======", "======");
X    for( sp = switches; sp->s_help != NULL; sp++ )
X	fprintf( p, help_format, sp->s_name, sp->s_help );
X    fprintf( p, "\n");
X    fprintf( p, "for more information type 'man finger', bugs to %s\n",
X	    BUGS_TO );
X    fflush( p );
X    if( pager != NULL )			/* have pager process? */
X	closepager( p, pid );		/* be tidy */
X    exit( 0 );
X    return( TRUE );			/* keep gcc quiet */
X} /* display_help */
X
XGLOBAL void doswitch( cp )		/* see also args.h */
Xregister char *cp;
X{
X    register char *tp, *vp, *ttp;
X    register struct switchtab *sp;
X    register len;
X    int match;
X
X    for( ; cp != NULL ; cp = tp ) {
X	tp = index( cp, '/' );
X	if( tp != NULL )
X	    *tp++ = EOS;
X
X	if( (vp = index(cp,':')) != NULL )
X	    *vp++ = EOS;
X
X	len = strlen( cp );
X	if( len == 0 )
X	    continue;
X
X	for( ttp = cp; *ttp != EOS; ttp++ )
X	    if( isupper( *ttp ) )
X		*ttp = tolower( *ttp );
X
X	match = 0;
X	sp = switches;
X	while( sp->s_name != NULL ) {
X	    if( strncmp(cp, sp->s_name, len) == 0 ) {
X		match++;
X		if( len >= sp->s_unique ) {
X		    (void) (*(sp->s_ptr))( vp );
X		    match = 1;		/* force uniqueness */
X		    break;
X		}
X	    } /* if strncmp [i] */
X	    sp++;
X	} /* while */
X	if( match > 1 ) {
X	    fprintf(stderr, "?Ambiguous switch '%s'. Use /help for help\n",
X		    cp );
X	    exit( 1 );
X	}
X	else if( sp->s_name == NULL ) {
X	    fprintf(stderr, "?Unknown switch '%s'. Use /help for help\n", cp );
X	    exit( 1 );
X	}
X    } /* for ever */
X} /* doswitch */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_switch.c
if test 7158 -ne `wc -c <switch.c`; then
    echo shar: \"switch.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f whois.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"whois.c\"
else
echo shar: Extracting \"whois.c\" \(7273 characters\)
sed "s/^X//" >whois.c <<'END_OF_whois.c'
X/*
X * whois -- user info output for new finger
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: whois.c,v 3.0 90/07/06 13:12:18 budd Rel $";
X# endif /* lint not defined */
X
X# include "finger.h"
X# include <sys/types.h>
X# include <sys/stat.h>
X# include <sys/time.h>
X# include <strings.h>
X# include <stdio.h>
X# include <ctype.h>
X# if defined(AUX) || defined(AIX3)
X# include <time.h>			/* bus-ted */
X# endif /* defined(AUX) || defined(AIX3) */
X# include <pwd.h>
X# include <grp.h>
X# include "person.h"
X# include "args.h"			/* sw_its (before luser.h) */
X# include "luser.h"
X# include "output.h"
X
XEXTERN void outline();			/* from output.c */
XEXTERN char *acct_name();		/* from conf.c */
XEXTERN char *office();			/* from acct.c */
XEXTERN struct group *getgrent();	/* USG grp.h loses */
X
XFORWARD GLOBAL char *nicetime();
X
XLOCAL char line[MAXLINE];
X
XLOCAL void newline() {
X    if( line[0] != EOS ) {
X	outline( line );
X	line[0] = EOS;
X    } /* non-empty */
X} /* newline */
X
XLOCAL void checksemi() {
X    if( line[0] != EOS )
X	strcat(line, ";");
X} /* checksemi */
X
XGLOBAL void whois( u )
Xregister LUSER *u;
X{
X    char tbuf[ 100 ];
X    register PERSON *p;
X    struct group *gr;
X    char **members, *acctname;
X
X    line[0] = EOS;
X
X    p = u->u_person;		/* get person structure */
X    if( p != NULL ) {
X	if( p->p_nickname != NULL ) {
X	    strcat(line, "  (");
X	    strcat(line, p->p_nickname);
X	    strcat(line, ")");
X	} /* nickname */
X
X# ifdef notdef				/* shown below (in mcheck) */
X	if( p->p_maddr != NULL ) {
X	    strcat(line, "  [" );
X	    strcat(line, p->p_maddr );
X	    strcat(line, "]");
X	} /* mail address */
X# endif /* notdef defined */
X
X	acctname = acct_name( p );
X	if( p->p_project != NULL || p->p_supervisor != NULL ||
X	   acctname != NULL ) {
X# ifdef DONT_SAY_HACKING		/* some people confuse hackers */
X	    strcat(line, "  working ");	/* and crackers!! */
X# else  /* DONT_SAY_HACKING not defined */
X	    strcat(line, "  Hacking ");
X# endif /* DONT_SAY_HACKING not defined */
X	    if( p->p_project != NULL ) {
X# ifdef DONT_SAY_HACKING
X		strcat(line, " on ");
X# endif /* DONT_SAY_HACKING defined */
X		strcat(line, p->p_project);
X		strcat(line, " ");
X	    } /* project */
X	    if( p->p_supervisor != NULL || acctname != NULL ) {
X		strcat(line, "for ");
X		if( p->p_supervisor != NULL )
X		    strcat(line, p->p_supervisor);
X		else {
X		    strcat(line, acctname ); /* *TODO* do this in getperson? */
X		    acctname = NULL;	/* don't repeat this! */
X		}
X	    } /* super */
X	} /* project or super */
X
X	newline();
X
X	if( p->p_birthday != NULL ) {
X	    strcat(line, "  Birthday ");
X	    strcat(line, p->p_birthday);
X	} /* birthday */
X
X	if( p->p_waddr != NULL || p->p_wphone != NULL ) {
X	    checksemi();
X	    strcat(line, "  Work ");
X	    if( p->p_waddr != NULL ) {
X		strcat(line, p->p_waddr );
X		if( p->p_wphone != NULL ) {
X		    strcat(line, "; ");
X		    catphone(line, p->p_wphone );
X		} /* waddr and wphone */
X	    } /* one of waddr and wphone */
X	    else
X		catphone(line, p->p_wphone);
X	} /* work address or phone */
X
X	newline();
X
X	if( p->p_haddr != NULL || p->p_hphone != NULL ) {
X	    strcat(line, "  Home ");
X	    if( p->p_haddr != NULL ) {
X		strcat(line, p->p_haddr );
X		if( p->p_hphone != NULL ) {
X		    strcat(line, "; ");
X		    catphone(line, p->p_hphone );
X		} /* addr and phone */
X	    } /* one of addr and phone */
X	    else
X		catphone(line, p->p_hphone);
X	} /* home address or phone */
X
X	/**************** dull stuff ****************/
X	newline();
X	if( p->p_home != NULL ) {
X	    struct passwd *pw;
X	    char *acn;
X
X	    sprintf(tbuf, "  [%d,%d]", p->p_uid, p->p_gid );
X	    strcat(line, tbuf);
X
X	    strcat(line, "  <");
X	    strcat(line, p->p_home);
X	    strcat(line, ">");
X
X	    acn = NULL;
X	    if( (gr = getgrgid( p->p_gid )) != NULL )
X		acn = gr->gr_name;
X# ifndef NO_COMMON_NAMESPACE		/* uid's and gid's use same names @bu */
X	    else if( (pw = getpwuid( p->p_gid )) != NULL ) /* NOTE: gid! */
X		acn = pw->pw_name;
X# endif /* NO_COMMON_NAMESPACE not defined */
X	    else
X		acn = acctname;
X
X	    if( acn != NULL ) {
X		checksemi();
X		strcat(line, "  Group: ");
X		strcat(line, acn );
X	    }
X	    if( p->p_shell != NULL ) {
X		strcat(line, "  Shell: ");
X		strcat(line, p->p_shell);
X	    } /* unusual shell */
X	} /* has home (password entry) */
X
X	newline();
X    } /* has person struct */
X
X    setgrent();
X    tbuf[0] = EOS;
X    while( (gr = getgrent()) != NULL ) {
X	for( members = gr->gr_mem; *members != NULL; members++ ) {
X	    if( strcmp( u->u_user, *members ) == 0 ) {
X		strcat( tbuf, " " );	/* add a space */
X		strcat( tbuf, gr->gr_name ); /* add name */
X		break;
X	    } /* match */
X	} /* while members */
X    } /* while gr */
X    endgrent();
X
X    if( tbuf[0] != EOS ) {
X	strcpy(line, "  Groups:");
X	strcat(line, tbuf );
X	newline();
X    } /* found groups */
X
X} /* whois */
X
X# define PLANBUFLEN 200
XGLOBAL BOOL plan( u )
XLUSER *u;
X{
X    char buf[PLANBUFLEN];
X    struct stat st;
X    PERSON *p;
X    FILE *f;
X
X    if( (p = u->u_person) == NULL || p->p_home == NULL || p->p_home[0] == EOS )
X	return( FALSE );
X
X    strcpy(buf, p->p_home);
X    strcat(buf, "/.plan");
X
X    if( (f = fopen(buf, "r")) == NULL )
X        return( FALSE );
X
X    if( fstat( fileno(f), &st ) < 0 )
X	outline("  Plan:");
X    else {
X	sprintf( buf, "  Plan: (last modified %s)", nicetime( st.st_mtime ) );
X	outline( buf );
X    }
X
X    while( fgets(buf, PLANBUFLEN, f) != NULL ) {
X	register char *cp;
X	if( (cp = index(buf, '\n')) != NULL )
X	    *cp = EOS;
X# ifndef DONT_TAB_PLAN
X	outchar('\t');
X# endif /* DONT_TAB_PLAN not defined */
X	outline( buf );
X    } /* while */
X    fclose( f );
X    return( TRUE );
X} /* plan */
X
XLOCAL char *weekday[] = {
X    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
X};
X
XLOCAL char *month[] = {
X    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
X    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
X};
X
XGLOBAL char *nicetime( t )
Xtime_t t;
X{
X    struct tm *tm, *localtime();
X    static char buffer[100];
X    char *am;
X    int hour;
X
X    tm = localtime( &t );
X    if( sw_its ) {			/* format date/time like ITS */
X	sprintf( buffer, "%02d/%02d/%02d %02d:%02d:%02d",
X		tm->tm_mon+1, tm->tm_mday, tm->tm_year,
X		tm->tm_hour,  tm->tm_min, tm->tm_sec );
X	return( buffer );
X    } /* ITS */
X
X    hour = tm->tm_hour;
X    am = "AM";
X    if( hour == 0 )			/* fix midnight */
X	hour = 12;
X    else if( hour > 11 ) {		/* after 11AM */
X	am = "PM";			/* its after-noon */
X	if( hour > 12 )			/* but don't touch 12!! */
X	    hour -= 12;
X    } /* PM */
X
X    sprintf(buffer, "%s %d-%s-%d %d:%02d%s",
X	    weekday[tm->tm_wday], tm->tm_mday,
X	    month[tm->tm_mon], tm->tm_year,
X	    hour, tm->tm_min, am);
X
X    return( buffer );
X} /* nicetime */
X
XGLOBAL void remarks(u)
XLUSER *u;
X{
X    PERSON *p;
X    register char *cp;
X
X    p = u->u_person;
X    if( p != NULL && p->p_remarks != NULL ) {
X	cp = p->p_remarks;
X	while( *cp != EOS )
X	    outchar( *cp++ );
X    } /* have person and remarks */
X} /* remarks */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_whois.c
if test 7273 -ne `wc -c <whois.c`; then
    echo shar: \"whois.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ymakefile -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ymakefile\"
else
echo shar: Extracting \"ymakefile\" \(7929 characters\)
sed "s/^X//" >ymakefile <<'END_OF_ymakefile'
X/*
X * ymakefile -- cpp input file for real work makefile (xmakefile)
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X/*
X * $Id: ymakefile,v 3.1 90/07/06 13:21:28 budd Exp $
X */
X
X/* Needed under AIX_RT */
XSHELL=/bin/sh
X
X# include "local.h"
X
X/* Used for make depend */
X/* CCM=cc -M */
XCCM=./cc-M
X
XETAGS=etags
XDIST=/usr/public/users/budd/finger
X
X# ifdef C_COMPILER
XCC=C_COMPILER
X# else  /* C_COMPILER not defined */
X# ifdef ibm032
XCC=pcc
X# endif /* ibm032 defined */
X# endif /* C_COMPILER not defined */
X
X# ifdef C_FLAGS
XCC_FLAGS=C_FLAGS
X# else  /* C_FLAGS not defined */
XCC_FLAGS=-O
X# endif /* C_FLAGS not defined */
X
X# ifdef LD_FLAGS
X/* useful for -Bstatic on SunOS4 */
XLDFLAGS=LD_FLAGS
X# endif /* LD_FLAGS defined */
X
X# ifdef INQUIRE
XLINQUIRE=./hakinq/libinq.a
X# endif /* INQUIRE defined */
X
X# ifdef USG
XTERM=-lcurses
X# else  /* USG not defined */
XTERM=-ltermcap
X# endif /* USG not defined */
X
X# if SunOS >= 40
X# ifdef i386
XOSLIBS=-lkvm -lld
X# else  /* i386 not defined */
XOSLIBS=-lkvm
X# endif /* i386 not defined */
X# endif /* SunOS >= 40 */
X
X# ifdef sgi
X/* -lsun for yp -- per spike@world.std.com */
X# ifdef YELLOW_PAGES
XOSLIBS=-lbsd -lmld -lsun
X# else  /* YELLOW_PAGES not defined */
XOSLIBS=-lbsd -lmld
X# endif /* YELLOW_PAGES not defined */
XINCLUDES=-I/usr/include/bsd
X# endif /* sgi defined */
X
X# ifdef AIX3
XOSLIBS=-lcfg -lodm
X# endif /* AIX3 defined */
X
X# ifdef UmaxV
X/* recent versions have /bsd/usr/include... /bsd/bin/cc... etc */
XOSLIBS=-laux
XINCLUDES=-I./include
X# endif /* UmaxV defined */
X
X# ifdef SYSI86				/* Interactive 386/ix */
XOSLIBS=-linet
X# endif /* SYSI86 defined */
X
X# if Umax == 43
XOSLIBS=-lld
X# endif /* Umax == 43 */
X
X# ifdef LIB_RESOLVE
XRESOLVE=LIB_RESOLVE
X# endif /* LIB_RESOLVE defined */
X
X# ifdef INCLUDE_PATH
XINCLUDES=INCLUDE_PATH
X# endif /* INCLUDE_PATH defined */
X
X# ifdef USG
XOTHERS=uptime
X# endif /* USG defined */
X
X# ifdef NO_STRINGS_H
XOSINCLUDES=-I.
X# endif /* NO_STRINGS_H defined */
X
XCFLAGS=$(CC_FLAGS) $(OSINCLUDES) $(INCLUDES) 
X
X/****************************************************************
X */
XALL=	xf fingerd ttyloc ttyask $(OTHERS)
X
X/* for cleanup */
XALLBIN= $(ALL) symdate pversion newmanifest mywhoami
X
Xall:	$(ALL)
X
X.PRECIOUS: $(ALL)
X
X/****************************************************************
X * (internet) finger daemon
X */
X
X/* Add new files to MANIFEST!! */
XFINGERD_O=fingerd.o string.o upper.o
Xfingerd: $(FINGERD_O)
X	$(CC) $(CFLAGS) -o fingerd $(FINGERD_O) $(RESOLVE) $(OSLIBS) $(LDFLAGS)
X# ifdef IN_DOT_DAEMON
X	-rm -f in.fingerd
X	ln fingerd in.fingerd
X# endif /* IN_DOT_DAEMON defined */
X
X/****************************************************************
X * new finger!
X */
X/* Add new files to MANIFEST!! */
XNF_O=	args.o daemon.o doremote.o conf.o finger.o getcommand.o\
X	getent.o getperson.o getttyloc.o getut.o global.o inquire.o\
X	kmem.o lastlog.o locname.o mcheck.o names.o output.o readpr.o\
X	ttylocfile.o read_vmunix.o select.o skip.o string.o switch.o\
X	undomain.o upper.o ustruct.o whois.o whoj.o
X
XNF_C=	args.c daemon.c doremote.c conf.c finger.c getcommand.c\
X	getent.c getperson.c getttyloc.c getut.c global.c inquire.c\
X	kmem.c lastlog.c locname.c mcheck.c names.c output.c readpr.c\
X	ttylocfile.c read_vmunix.c select.c skip.c string.c switch.c\
X	undomain.c upper.c ustruct.c whois.c whoj.c
X
XNFLIBS=	$(TERM) $(RESOLVE) $(LINQUIRE) $(OSLIBS)
X
Xxf:	$(NF_O) pversion mywhoami
X	./make-version > version.c
X	$(CC) -c version.c
X	$(CC) $(CFLAGS) -o xf $(NF_O) version.o $(NFLIBS) $(LDFLAGS)
X
Xpversion: pversion.c History.h
X	$(CC) $(CFLAGS) -o pversion pversion.c
X
X/* whoami is a BSDism.  USG systems don't have it */
Xmywhoami: mywhoami.c
X	$(CC) $(CFLAGS) -o mywhoami mywhoami.c
X
X/* uptime replacement for USG systems */
X# ifdef USG
Xuptime:	uptime.c
X	$(CC) $(CFLAGS) -o uptime uptime.c
X# endif /* USG defined */
X
X# ifdef UmaxV
X/* newer releases have /bsd/usr/include */
X$(NF_O): ./include
X
X./include:
X	mkdir include include/sys
X	(cd include; \
X	 ln -s /usr/include/sys/arpa /usr/include/sys/netinet .; \
X	 ln -s /usr/include/sys/aux/syslog.h /usr/include/sys/aux/netdb.h .; \
X	 cd sys; ln -s /usr/include/sys/h/socket.h . )
X# endif /* UmaxV defined */
X
Xsymdate.h: symdate syms.h
X	./symdate syms.h > symdate.h
X
Xsymdate: symdate.c
X	$(CC) -o symdate symdate.c
X
X/****************
X * create call graph.  (-c and -W are BU local switches)
X */
Xxf.calls: $(NF_C)
X	calls -W 4 -c -e -f main $(NF_C) > xf.calls
X
XTAGS:	$(NF_C)
X	$(ETAGS) $(NF_C) 
X
X/****************************************************************
X * Interactive ttyloc asker (front end for ttyloc)
X */
X
XTTYASK= ttyask.o skip.o getttytype.o ttylocfile.o string.o upper.o
Xttyask:	$(TTYASK)
X	$(CC) $(CFLAGS) -o ttyask $(TTYASK) $(OSLIBS) $(LDFLAGS)
X
X/****************************************************************
X * ttyloc setting program
X */
X
XTTYLOC=	ttyloc.o locname.o
Xttyloc:	$(TTYLOC)
X	$(CC) $(CFLAGS) -o ttyloc $(TTYLOC) $(OSLIBS) $(LDFLAGS)
X
X/****************************************************************
X * lint picking
X */
X
X/* removed -p -- not in SunOS anymore!! */
Xlint:	llib-lf.ln
X	lint -h llib-lf.ln *.c > LINT 2>&1
X
Xllib-lf.ln:
X	lint -Cf $(DEFS) *.c > /dev/null 2>&1
X
X/****************************************************************
X * household chores
X */
XKIT=Finger-part
X/*
X * be tidy (keeps .o files)
X *
X * kill myecho, pversion, and symdate as they are compiled
X * and don't port across achitectures!
X */
X
Xclean:
X	-rm -f core *~ \#* *.out finger.tar *.bak LOG *.s $(KIT)* \
X		MANIFEST.* myecho pversion symdate mywhoami getgroup checkmode
X
Xrealclean: clean
X	-rm -f $(ALLBIN) *.o version.c local.h \
X		xmakefile Install in.fingerd
X
X/*
X * pack up using tar or makekit
X */
X
X/* If you add here, you MUST add to MANIFEST too!! */
XSAMPLE=SAMPLE-local.h
XSAMPLE2=SAMPLE-flags
XSAMPLE3=SAMPLE-conf
XSAMPLES=$(SAMPLE) $(SAMPLE2) SAMPLE-nttyloc $(SAMPLE3)
XTAR=	VERSION* COPYRIGHT COPYING Cover README\
X	finger.1 ttyloc.1 nttyloc.5 finger.conf.5 fingerd.8c\
X	Makefile ymakefile Install.cpp autoconfig make-version\
X	TODO WISHES COUNT ORIG FINDDEFS DIFFALL COMDEFALL defs.awk cc-M\
X	MODES $(SAMPLES) Distfile\
X	`ls *.[ch] | egrep -v '^(local\.h|version\.c|symdate\.h)'`
X
X$(SAMPLE): local.h
X	rm -f $(SAMPLE)
X	cp local.h $(SAMPLE)
X
X$(SAMPLE2):
X	-cp local-flags $(SAMPLE2) || touch $(SAMPLE2)
X
X$(SAMPLE3):
X	-cp finger.conf $(SAMPLE3) || touch $(SAMPLE3)
X
Xfinger.tar tar: $(SAMPLES) pversion mywhoami
X	-rm -f VERSION*
X# ifndef USG
X	echo "`date` by `./mywhoami` on `hostname`" > VERSION-`pversion`
X# endif /* USG not defined */
X	tar cf finger.tar $(TAR) hungry
X
Xfinger.tar.Z: finger.tar
X	compress -v < finger.tar > finger.tar.Z
X
Xsplit:	finger.tar.Z
X	uuencode finger.tar.Z < finger.tar.Z | split - finger.tar.Z.uu.
X
X/* utter crock to merge file list and MANIFEST! */
Xnewmanifest: newmanifest.c
X	$(CC) $(CFLAGS) -o newmanifest newmanifest.c
X
X/* note; hungry/?* to defeat cpp comment removal!! */
Xkit:	$(SAMPLES) pversion newmanifest
X	-rm -f VERSION* $(KIT)*
X	echo "version `pversion` packed `date` by `whoami` on `hostname`" > \
X		VERSION
X	cp MANIFEST MANIFEST.saved
X	./newmanifest $(TAR) hungry hungry/?* MANIFEST > nMANIFEST
X	mv nMANIFEST MANIFEST
X	makekit -n $(KIT) -s 64k -m
X	rm -f MANIFEST.BAK
X
Xdist:	kit split
X	rm -rf $(DIST)
X	mkdir $(DIST) $(DIST)/shar $(DIST)/split
X	cp README COPYING $(DIST)
X	mv finger.tar finger.tar.Z VERSION* $(DIST)
X	mv $(KIT)* $(DIST)/shar
X	mv finger.tar.Z.uu.?? $(DIST)/split
X
Xdepend:
X	sed '/^# DO NOT DELETE THIS LINE/q' xmakefile > xmakefile.tmp
X	$(CCM) $(CFLAGS) *.c |\
X		egrep -v '(local\.h|finger\.h|/usr/include|.c:$$|.c$$)' |\
X		sed 's@[ 	]*\./@ @' >> xmakefile.tmp
X	mv xmakefile.tmp xmakefile
X
X/* ugh.  cannot trust make depend the first time around */
Xnames.o: symdate.h
END_OF_ymakefile
if test 7929 -ne `wc -c <ymakefile`; then
    echo shar: \"ymakefile\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 4 \(of 7\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

