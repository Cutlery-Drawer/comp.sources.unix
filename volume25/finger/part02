Newsgroups: comp.sources.unix
From: phil@Shiva.COM (Phil Budne)
Subject: v25i165: finger - Phil's Finger Program, Part02/07
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: phil@Shiva.COM (Phil Budne)
Posting-Number: Volume 25, Issue 165
Archive-Name: finger/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 7)."
# Contents:  Makefile SAMPLE-local.h TODO args.h checkmode.c daemon.c
#   finger.conf.5 finger.h getttytype.c getut.c kmem.c lastlog.c
#   luser.h newmanifest.c nttyloc.5 string.c switch.h syms.h ttyloc.1
#   ttyloc.c uptime.c ustruct.h whoj.c
# Wrapped by budd@bu-it on Fri Jul  6 13:22:00 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Makefile -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile\"
else
echo shar: Extracting \"Makefile\" \(2551 characters\)
sed "s/^X//" >Makefile <<'END_OF_Makefile'
X# Copyright (C) 1987, 1990  Philip L. Budne
X#
X# This file is part of "Phil's Finger Program".
X#
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 1, or (at your option)
X# any later version.
X#
X
X# $Id: Makefile,v 3.0 90/07/06 13:10:14 budd Rel $
X
X# Needed under AIX/RT
XSHELL=/bin/sh
X#
XMAKEFILE_CPP=/lib/cpp -P
X#
X# If your cpp does not have -P (omit "# line")
X#MAKEFILE_CPP=/lib/cpp | grep -v ^#
X# If you are missing cpp?!
X#MAKEFILE_CPP=cc -E | grep -v ^#
X#
X# cat -s on BSD means omit adjacent blank lines.
X# on USG it means be quiet about missing files?!
XCRUSH_BLANKS=| sed 's/[ 	]*$$//' | cat -s
X
Xall:	DEPEND ALWAYS
X	make -f xmakefile all
X
Xquick:	ALWAYS
X	touch DEPEND
X	make -f xmakefile all
X
Xxf:	DEPEND ALWAYS
X	make -f xmakefile xf
X
Xttyloc:	DEPEND ALWAYS
X	make -f xmakefile ttyloc
X
Xttyask:	DEPEND ALWAYS
X	make -f xmakefile ttyask
X
Xfingerd: DEPEND ALWAYS
X	make -f xmakefile fingerd
X
Xtar finger.tar:	xmakefile ALWAYS
X	make -f xmakefile tar
X
Xkit shar: xmakefile ALWAYS
X	make -f xmakefile kit
X
Xdist:	xmakefile ALWAYS
X	make -f xmakefile dist
X
XTAGS:	xmakefile ALWAYS
X	make -f xmakefile TAGS
X
Xclean:	xmakefile ALWAYS
X	make -f xmakefile clean
X	rm -f CROCK DEPEND
X
Xrealclean: xmakefile ALWAYS
X	make -f xmakefile realclean
X	rm -f CROCK DEPEND
X
Xxmakefile: CROCK ymakefile local.h
X	@echo '# do not edit this file, created from ymakefile' > xmakefile
X	$(MAKEFILE_CPP) ymakefile $(CRUSH_BLANKS)		>> xmakefile
X	echo '# DO NOT DELETE THIS LINE -- make depend uses it' >> xmakefile
X
Xdepend DEPEND: xmakefile
X	make -f xmakefile depend
X	touch DEPEND
X
Xinstall: Install
X	@echo "Run the shell script ./Install if you dare"
X
XInstall: Install.cpp local.h
X	@echo '#!/bin/sh' > Install
X	@echo '# do not edit this file, created from Install.cpp' >> Install
X	$(MAKEFILE_CPP) Install.cpp $(CRUSH_BLANKS) >> Install
X	chmod +x Install
X
X# must be executed in sequence!
X# (.ORDER is honored by Encore make)
X.ORDER CROCK: mywhoami getgroup checkmode local.h
X	@touch CROCK
X
Xlocal.h:
X	./autoconfig > local.h.tmp && mv local.h.tmp local.h
X
Xmywhoami: mywhoami.c
X	$(CC) $(CFLAGS) -o mywhoami mywhoami.c
X
Xgetgroup: getgroup.c
X	$(CC) $(CFLAGS) -o getgroup getgroup.c
X
Xcheckmode: checkmode.c
X	$(CC) $(CFLAGS) -o checkmode checkmode.c
X
Xdefs:
X	grep '^#[ 	]*if' *.[ch] > defs
X	grep '^#[ 	]*define' *.[ch] > defs
X
Xdefs.out: defs
X	sh defs.sh > defs.out
X
X# always needs making
XALWAYS:
X
X# A monument to a hack of long ago and far away...
Xlove:
X	@echo 'not war?'
END_OF_Makefile
if test 2551 -ne `wc -c <Makefile`; then
    echo shar: \"Makefile\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f SAMPLE-local.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"SAMPLE-local.h\"
else
echo shar: Extracting \"SAMPLE-local.h\" \(2003 characters\)
sed "s/^X//" >SAMPLE-local.h <<'END_OF_SAMPLE-local.h'
X/*
X *	local.h for bu-it
X *	created on Thu May 17 21:58:00 EDT 1990 by budd using autoconfig
X */
X
X/* local-flags: *****************/
X/* local-flags for bu-it */
X
X/*
X# define INQUIRE
X*/
X
X# define C_COMPILER gcc
X# if 1
X# define C_FLAGS -g -O
X# else  /* not 1 */
X# define C_FLAGS -W -Wreturn-type -Wunused -Wswitch -Wshadow -Wpointer-arith -Wcast-qual -Wpointer-arith -Wcast-qual -Dlint -g
X# endif /* not 1 */
X
X# define DEBUGSW		/* include /debug switch */
X# define UNPREFIX_NODOMAIN 	/* unprefix hosts with no dots */
X/* end of local-flags ***********/
X
X# define SunOS 403
X
X# define IN_DOT_DAEMON	/* internet daemon names prefixed with in. */
X
X# define LASTLOG			/* BSD last login file */
X
X# define SWAP_DEVICE "/dev/drum"	/* swap device */
X
X# define UNDERSCORE_NLIST_NAMES
X
X# define STREAMS
X
X# define SHORT_TTYP
X
X
X# define TTY_GROUP_NUMBER 4
X
X# define TTY_GROUP "tty"
X
X/* for Install.cpp */
X# define KMEM_GROUP kmem
X
X/* getpwnam(3) is fast (yellow pages) */
X
X# define HAVE_YP_MATCH			/* have yp_match(3) */
X
X# define ALIASES "/etc/aliases"	/* sendmail aliases file */
X
X# define TTYENT				/* use getttyent(3) */
X
X# define INETD				/* use inetd for fingerd */
X
X# define VOIDSIG			/* signal() declared as void * */
X
X/* utmp has ut_host field */
X
X# define KERNEL_FILE "/vmunix"
X
X# define MAIL_SPOOL "/usr/spool/mail"
X
X# define SYSLOG				/* fingerd does syslog-ing */
X
X# define SAVED_NLIST "/etc/finger-saved-nlist" /* save nlist to this file */
X
X# define AUTONLIST			/* update nlist save file as needed */
X
X# define NLIST_MODE 0664		/* creation mode for nlist file */
X
X# define NETBERK			/* network finger implies /berk */
X					/* (I hate this) */
X
X# define NETFOLLOW			/* net finger implies /follow */
X
X/**************** REQUIRED!! (used by Install) ****************/
X
X# define TTYLOC_DIR "/usr/spool/ttyloc"
X
X# define TTYLOC_MODE 0644
X
X/* extra paths to try to exec finger */
X/* # define FINGERPATHS "/usr/local/local/bin/finger", "/bin/who" /*  */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_SAMPLE-local.h
if test 2003 -ne `wc -c <SAMPLE-local.h`; then
    echo shar: \"SAMPLE-local.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f TODO -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"TODO\"
else
echo shar: Extracting \"TODO\" \(2202 characters\)
sed "s/^X//" >TODO <<'END_OF_TODO'
XALSO: grep for TODO in source files
X==
XOUTPUT FORMAT:
X1.	/fields[:sep]
X
X#4. clean up /follow
X-	trace at tree building time? (insert locals)
X		store where?
X-	warn about loops in man page
X-	avoid local loops
X-	handle "", pipes, files
X
X5. lint + GLOBAL/LOCAL + void + extern int foo();
X
X6. update copyrights (date, and notice)
X
X#7. INSTALL:
X	do install via Makefile?
X	Install man pages
X
X8.	faster lookup when /match?
X
X9.	always try getpwbyname (even when using inquire)
X
X#10.	keep ttylocs and default ttylocs in a binary file? dbm?
X	see comments at top of getttyloc.c
X
XDOCUMENT:
X11.	readttylocfile(3)
X12.	getttytype(3)
X#13.	Document all defines.
X
X#14.	update autoconfig
X
X==
X
X#15.	-help print copyright? (or at least point to it)
X	help too long?? feed to more?
X
X16.	-help say that /foll/berk are set by remote fingers (conditionally
X	compile!!)
X
X#17.	A way to say "-v"@host to pass switches to 4n hosts
X
X#22.	Be able to continue without read_vmunix. (see PICKY in names.c)
X
X21.
X	non-compile oriented config (esp PREFIXes)
X		- office prefixes (sort by length (longest first?))
X		- host prefixes
X		- hosts to forward to other hosts (DECnet hosts...)
X		  (check MX records??)
X		- other stuff
X
X#24.	penalize for pause() or wait() ?? (done 3/10/88)
X
X27.	whoj with X11 hostname fails (. tickles unprefix)
X	use of undomain in that context is bogus.
X
X28.	print a message when a 4n finger shuts down without sending any data
X
X31.	show terminal input state? (or lack thereof)
X	display * for runnable?
X
X33.	do getpwuid( getpwnam( match )->pw_uid )
X	helps with dual names for same uid?? (but is slow!)
X
X#34.	Use comments on #else #endif (fuat)
X
X#35.	Blast ZUPing of hosts (stu)
X
X#36.	Do getNETbynumber on unknown hosts!! (fingerd, ttyloc)
X	ie; convert 10.0.0.9 to arpa.9?
X	128.197.20.40 to bu-net.20.40?
X
X37.	show swapped after progrname (if room).
X	what char to use?
X
X38.	More bits in p_flags under SunOS 4.0:
X	SULOCK SKEEP SPGLDR SFAVORD
X
X39.	figure out stream tty status?
X
X40.	Use sendmailbox (provide small one?)
X
X# Don't count these!!
X#5/9/88	32 + 17 = 49
X#5/17	23 + 15 = 38
X#6/9	21 + 19 = 40
X#6/27	22 + 10 = 32
X#7/5	16 + 10 = 27
X#10/26	16 + 11 = 29
X#6/15/89 9 + 19 = 28
X#6/28/89 9 + 15 = 24
X#7/6/90	17 + 11 = 38
END_OF_TODO
if test 2202 -ne `wc -c <TODO`; then
    echo shar: \"TODO\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f args.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"args.h\"
else
echo shar: Extracting \"args.h\" \(1956 characters\)
sed "s/^X//" >args.h <<'END_OF_args.h'
X/*
X * args.h -- flag/switch definitions
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# define ARGS_RCSID "$Id: args.h,v 3.0 90/07/06 13:10:20 budd Rel $"
X
X# ifndef EXTERN
X# define EXTERN extern
X# endif /* EXTERN not defined */
X
X/* global (not per-person) switches */
Xtypedef char sw_t;
X
XEXTERN sw_t sw_age;		/* age switch */
X				/* display on rather than idle */
XEXTERN sw_t sw_berkeley;	/* be like bzerkly finger */
X				/* (force -w -p with names) */
XEXTERN sw_t sw_debug;		/* enable debug output */
XEXTERN sw_t sw_follow;		/* let finger do the walking */
X				/* cudos to CTorek for the idea */
XEXTERN sw_t sw_its;		/* be more like ITS (default is Twenex; */
XEXTERN sw_t sw_jobs;		/* do whoj display */
XEXTERN sw_t sw_nosave;		/* prohibit write of nlist */
X				/* this is forced on by 'xf' */
XEXTERN sw_t sw_output;		/* display idle time based on last output */
XEXTERN sw_t sw_pid;		/* show current process pid */
XEXTERN sw_t sw_read;		/* force read of nlist, and save */
X				/* do this from your rc file */
X				/* if you don't use AUTONLIST */
XEXTERN sw_t sw_state;		/* show process state in place of idle */
XEXTERN sw_t sw_whois;		/* whois switch -- show long information */
X
XEXTERN char *sw_fields;		/* NYI: display output in AWKable form */
X
X/****************
X * flags processed per-user
X */
X
XEXTERN struct switches {
X    int sw_location	: 1;	/* ignore user location */
X    int sw_mail		: 1;	/* force mail check */
X    int sw_match	: 1;	/* match on usernames only */
X    int sw_noplan	: 1;	/* prhibit display of plan under /whois */
X    int sw_plan		: 1;	/* check for ~/.plan file */
X} Sw;
X
X/*
X * Local variables:
X * comment-column: 32
X * End:
X */
END_OF_args.h
if test 1956 -ne `wc -c <args.h`; then
    echo shar: \"args.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f checkmode.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"checkmode.c\"
else
echo shar: Extracting \"checkmode.c\" \(3214 characters\)
sed "s/^X//" >checkmode.c <<'END_OF_checkmode.c'
X/*
X * checkmode.c -- check file modes
X *
X * Copyright (C) 1990 Philip L. Budne
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: checkmode.c,v 3.0 90/07/06 13:10:25 budd Rel $";
Xstatic char Copyright[] = "Copyright (C) 1990 Philip L. Budne";
X# endif /* lint not defined */
X
X# include <sys/types.h>
X# include <sys/stat.h>
X# include <stdio.h>
X
X# define EOS '\0'
X
X# ifndef S_IRUSR			/* sigh */
X# define S_IRUSR 0000400		/* read permission, owner */
X# define S_IWUSR 0000200		/* write permission, owner */
X# define S_IXUSR 0000100		/* execute/search permission, owner */
X# define S_IRGRP 0000040		/* read permission, group */
X# define S_IWGRP 0000020		/* write permission, grougroup */
X# define S_IXGRP 0000010		/* execute/search permission, group */
X# define S_IROTH 0000004		/* read permission, other */
X# define S_IWOTH 0000002		/* write permission, other */
X# define S_IXOTH 0000001		/* execute/search permission, other */
X# endif /* S_IRUSR not defined */
X
X# define USER	(S_IRUSR|S_IWUSR|S_IXUSR|S_ISUID)
X# define GROUP	(S_IRGRP|S_IWGRP|S_IXGRP|S_ISGID)
X# define OTHER	(S_IROTH|S_IWOTH|S_IXOTH)
X
X# define READ	(S_IRUSR|S_IRGRP|S_IROTH)
X# define WRITE	(S_IWUSR|S_IWGRP|S_IWOTH)
X# define EXEC	(S_IXUSR|S_IXGRP|S_IXOTH)
X
X# define SET	(S_ISUID|S_ISGID)
X
X# define OCTAL(c) ((c) >= '0' && (c) <= '7')
X
Xint thing(), thing1();
Xvoid bad();
Xchar *cp;
X
Xvoid
Xusage() {
X    fprintf( stderr, "Usage checkmode file mode_mask [bits_set]\n" );
X    exit( 1 );
X}
X
Xint
Xmain( c, v )
X    int c;
X    char **v;
X{
X    int mask, bits;
X    char op;
X    struct stat st;
X
X    if( c < 2 || c > 4 )
X	usage();
X
X    mask = thing( v[2] );
X    if( c == 3 )
X	bits = mask;
X    else
X	bits = thing( v[3] );
X
X    if( *cp == '+' || *cp == '-' )
X	op = *cp++;
X    else
X	op = '+';
X
X    if( stat( v[1], &st ) < 0 ) {
X	perror( v[1] );
X	exit( 2 );
X    }
X
X    if( (st.st_mode & mask) == bits )
X	exit( 0 );
X    puts("nope");
X    exit( 1 );
X} /* main */
X
X# define PEEK (*cp)
X# define NEXT (*cp++)
X
Xint
Xthing( p )
X    char *p;
X{
X    int m;
X
X    cp = p;
X
X    m = thing1();
X    while( PEEK == '+' || PEEK == '-' ) {
X	if( NEXT == '+' )
X	    m |= thing1();		/* add bits */
X	else
X	    m &= ~thing1();		/* remove bits */
X    }
X    if( PEEK )
X	bad();
X    return( m );
X} /* thing */
X
Xint
Xthing1() {
X    int m;
X
X    if( OCTAL(PEEK) ) {
X	m = 0;
X	do
X	    m = (m<<3) | NEXT - '0';
X	while( OCTAL(PEEK) );
X	return( m );
X    }
X
X    switch( PEEK ) {
X    case 'u':
X	m = USER;
X	NEXT;
X	break;
X    case 'g':
X	m = GROUP;
X	NEXT;
X	break;
X    case 'o':
X	m = OTHER;
X	NEXT;
X	break;
X# ifdef S_ISVTX
X    case 't':
X	NEXT;
X	return( S_ISVTX );
X# endif /* S_ISVTX defined */
X    default:
X	m = USER|GROUP|OTHER;
X	break;
X    }
X
X    switch( PEEK ) {
X    case 'r':
X	m &= READ;
X	break;
X    case 'w':
X	m &= WRITE;
X	break;
X    case 'x':
X	m &= EXEC;
X	break;
X    case 's':
X	m &= SET;
X	break;
X    case EOS:
X	return( m );
X    default:
X	bad();
X    }
X    NEXT;
X    return( m );
X}
X
Xvoid
Xbad() {
X    fprintf( stderr, "Bad character in mode '%c'\n", PEEK );
X    usage();
X}
END_OF_checkmode.c
if test 3214 -ne `wc -c <checkmode.c`; then
    echo shar: \"checkmode.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f daemon.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"daemon.c\"
else
echo shar: Extracting \"daemon.c\" \(2979 characters\)
sed "s/^X//" >daemon.c <<'END_OF_daemon.c'
X/*
X * daemon.c -- Different things that can parent a shell -- January 1988
X *
X * Copyright (C) 1988, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: daemon.c,v 3.0 90/07/06 13:10:29 budd Rel $";
X# endif /* lint not defined */
X
X# include "finger.h"
X# include "daemon.h"
X
Xstruct daemon daemons [] = {
X    /* cmd		short		long */
X
X# ifdef sun
X# if SunOS >= 400
X    {"cmdtool",		"cmdtool",	"SunView (cmdtool)" },
X# endif /* SunOS >= 400 */
X    {"suntools",	"suntools",	"SunView (suntools)" },
X    {"vt100tool",	"vt100tool",	"SunView (vt100tool)" },
X    {"othertools",	"othertools",	"SunView (othertools)" },
X    {"dbxtool",		"dbxtool",	"SunView (dbxtool)" }, /* use ptys? */
X    {"dnalogind",	"DNA",		"DNA login" },	/* Sun DECnet? */
X    {"dnaserver",	"DNI",		"Sunlink/DNI" }, /* ditto? */
X    {"psterm",		"NeWs",		"NeWs Window" },
X# endif /* sun defined */
X
X# ifdef IN_DOT_DAEMON
X    {"in.rlogind",	"rlogin",	"Remote Login" },
X    {"in.telnetd",	"telnet",	"Telnet" },
X    {"in.supdupd",	"supdup",	"Supdup" },
X    {"in.rshd",		"rsh",		"Remote Shell" },
X# else  /* IN_DOT_DAEMON not defined */
X    {"rlogind",		"rlogin",	"Remote Login"},
X    {"telnetd",		"telnet",	"Telnet" },
X    {"supdupd",		"supdup",	"Supdup" },
X    {"rshd",		"rsh",		"Remote Shell" },
X# endif /* IN_DOT_DAEMON not defined */
X
X# ifdef ultrix
X    {"dlogin",		"dlogin",	"DECnet Login" },
X    {"dlogind",		"dlogin",	"DECnet Login" },
X    {"dtermd",		"dterm",	"DECnet Terminal" }, /* cterm? */
X    {"dnet_spawner",	"decnet",	"DECnet" },	/* SNH? */
X    {"telnet.gw",	"telnet",	"Telnet GW" },	/* SNH? */
X    {"dxterm",		"dxterm",	"X window" },
X# endif /* ultrix defined */
X
X# ifdef sgi
X    {"wsh",		"wsh",		"NeWs Window"},
X    {"grcond",		"grcond",	"Graphics Console"},
X# endif /* sgi defined */
X
X# if defined(AIX_RT) || defined(AIX_PS2) || defined(AIX3)
X    {"aixterm",		"aixterm",	"X Window" },	/* no host in utmp */
X# endif /* defined(AIX_RT) || defined(AIX_PS2) || defined(AIX3) */
X
X    {"xterm",		"xterm",	"X Window" },	/* no host in utmp */
X
X
X    {"inetd",		"inet",		"Internet" },	/* SNH */
X
X    /* **************** put under ifdefs? **************** */
X
X    /* 4.3 XNS */
X    {"GAP3d",		"GAP3",		"XNS GAP3" },
X    {"xnscourierd",	"XNS",		"XNS Courier" }, /* snh */
X
X    /* MIT Chaosnet */
X    {"TELNET",		"chtn",		"Chaos Telnet" },
X    {"SUPDUP",		"chsupdup",	"Chaos" },	/* ever get this? */
X    {"chserver",	"chaos",	"Chaosnet" },	/* snh */
X
X    /* Stanford PUP - Bill Nowicki and Jeff Mogul */
X    {"telser",		"pup",		"PUP" },
X
X# ifdef LOCAL_DAEMONS
X    LOCAL_DAEMONS,
X# endif /* LOCAL_DAEMONS defined */
X
X    {0, 0, 0}
X}; /* daemons[] */
X
X/*
X * Local variables:
X * comment-column: 56
X * End:
X */
END_OF_daemon.c
if test 2979 -ne `wc -c <daemon.c`; then
    echo shar: \"daemon.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f finger.conf.5 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"finger.conf.5\"
else
echo shar: Extracting \"finger.conf.5\" \(2561 characters\)
sed "s/^X//" >finger.conf.5 <<'END_OF_finger.conf.5'
X.\" -*-nroff-*-
X.\" $Id: finger.conf.5,v 3.0 90/07/06 13:10:39 budd Rel $
X.\" Copyright (c) 1990  Philip L. Budne
X.TH FINGER.CONF 5 "30 April 1990"
X.UC 4
X.SH NAME
Xfinger.conf \- runtime configuration information for finger
X.SH DESCRIPTION
XThe
X.I finger.conf
Xfile allows
X.IR finger (1)
Xto be configured in a site-dependant manner at runtime.
X.PP
XIf the first character on a line is a exclamation mark (!), the line
Xis ignored. The file is broken into sections initiated by a percent
Xsign and section name at the start of a line.
X.\" ----
X.\" set tab stops
X.ta \w'.DECNET\ \ 'u +\w'MCS'u 
X.\" translate & to dot
X.tr &.
X.\" Begin Example
X.de BE
X.PP
X\fC
X.nf
X..
X.\" End Example
X.de EE
X\fR
X.fi
X..
X.\" ====
X.SS ACCOUNTS
XInformation from the
X.I accounts
Xsection is used to display a group letter after the username in
X.I finger
Xoutput, and in
X.I whois
Xoutput to supply defaults for account and project.  The first column
Xis a group name or number. A range of groups can be specified using a
Xhyphen.  A backslash (\\) can be used to quote hyphens (or spaces!!)
Xin group names.
X.BE
X%accounts
Xstaff	+	Staff Wizards
Xnseg	N	Networking Systems
Xdsg	D	Distributed Systems
Xcsg	C	Central Systems
Xscv	V	Skeeve Group
Xitother	I	Disinformation Technology
Xusrsrv	U	User Disservices
Xguest	G	Guest
Xx\-y	X	The X-Y Group
X0-9999	?	The Great Unknown
X.EE
X.\" ----
X.SS BUILDINGS
XThe
X.I buildings
Xsection is used to expand GECOS office locations in a site independant
Xmanner for
X.I whois
Xoutput.
X.BE
X%buildings
XM	MCS
XA	ACC
XC	CS
XE	ERB
X.EE
X.\" ----
X.SS HIDDEN
XThe
X.I hidden
Xsection is used to discourage display of programs names that are
Xuninteresting.
X.BE
X%hidden
Xgamescontrol
X.EE
X.\" ----
X.SS PHONES
XThe
X.I buildings
Xsection is used to expand GECOS phone numbers in a site independant
Xmanner for
X.I whois
Xoutput. The first format in which the number of pound signs matches
Xthe number of digits in the phone number to be printed is used.
X.BE
X%phones
Xx3-####
Xx#-####
Xx####
X(617) ###-####
X(###) ###-####
X.EE
X.\" ----
X.SS PREFIXES
XThe
X.I prefixes
Xsection is used to remove hostname prefixes for shortened display
Xbefore ttyloc information.
X.BE
X%prefixes
XBUIT
XBU-
XBU
X.EE
X.\" ----
X.\" .SS ROUTES
X.\" The
X.\" .I routes
X.\" section is not yet implemented.
X.\" .PP
X.\" .BE 
X.\" %routes
X.\" &DECNET	@\fRdecnet_router_host\fP
X.\" .EE
X.\" ====
X.SH FILES
X.ta \w'/usr/local/etc/finger.conf\ \ 'u
X.nf
X/etc/finger.conf	First try
X/usr/local/etc/finger.conf	Second try
X/usr/etc/finger.conf	Third try
X&/finger.conf		Last try
X.fi
X.\" ====
X.SH "SEE ALSO"
Xfinger(1), nttyloc(5)
X.\" ====
X.SH AUTHOR
XPhilip L. Budne
END_OF_finger.conf.5
if test 2561 -ne `wc -c <finger.conf.5`; then
    echo shar: \"finger.conf.5\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f finger.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"finger.h\"
else
echo shar: Extracting \"finger.h\" \(1904 characters\)
sed "s/^X//" >finger.h <<'END_OF_finger.h'
X/*
X * finger.h - basic language defines for finger etc
X *
X * Copyright (C) 1988, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# define FINGER_RCSID "$Id: finger.h,v 3.0 90/07/06 13:10:41 budd Rel $"
X
X# ifndef _FINGER_H_
X# define _FINGER_H_
X
X# include "local.h"
X
X# define EOS '\0'
X
X# define LOCAL static
X# define GLOBAL
X# define FORWARD
X
X# define BOOL int
X# define FALSE 0
X# define TRUE 1
X
X# ifndef lint
XLOCAL char Copyright[] = "Copyright (C) 1986, 1990  Philip L. Budne";
X# endif /* lint not defined */
X
X/* param.h (on 4.3) has MAXHOSTNAMELEN *TODO* */
X# ifndef MAXHOSTLEN
X# define MAXHOSTLEN 64
X# endif /* MAXHOSTLEN not defined */
X
X# define BPW (sizeof(int)*8)
X# define MINUS_INF (1<<(BPW-1))
X# define PLUS_INF  (MINUS_INF-1)
X
Xextern char *savestr();			/* string.c */
Xextern char *malloc();			/* libc */
X
X# ifdef __STDC__			/* f****d up ANSI C (accomodate GCC) */
X
X# define CONC(a,b) a##b			/* concatenate 2 strings */
X# define CONC3(a,b,c) a##b##c		/* same for three */
X# define STR(a) #a			/* make arg into a quoted string */
X
X# define SIGNED signed
X
X# else  /* __STDC__ not defined */
X
X# define CONC(a,b) a/**/b
X# define CONC3(a,b,c) a/**/b/**/c
X# define STR(s) "s"
X
X# define SIGNED
X
X# endif /* __STDC__ not defined */
X
X# ifndef INIT_PID
X# define INIT_PID 1			/* Unix truism */
X# endif /* INIT_PID not defined */
X
X# ifdef UPCASE_HOSTS
X# define HZUP(s) zup(s)
X# else  /* UPCASE_HOSTS not defined */
X# define HZUP(s) s
X# endif /* UPCASE_HOSTS not defined */
X
X/* std io descriptors */
X# define STD_INPUT 0
X# define STD_OUTPUT 1
X
X# endif /* _FINGER_H_ not defined */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_finger.h
if test 1904 -ne `wc -c <finger.h`; then
    echo shar: \"finger.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f getttytype.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"getttytype.c\"
else
echo shar: Extracting \"getttytype.c\" \(1782 characters\)
sed "s/^X//" >getttytype.c <<'END_OF_getttytype.c'
X/*
X * getttytype.c -- get tty type for a line (July 1987)
X *
X * Copyright (C) 1987, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: getttytype.c,v 3.0 90/07/06 13:10:56 budd Rel $";
X# endif /* lint not defined */
X
X# include <stdio.h>
X# include "finger.h"
X
X# ifdef TTYENT
X
X# include <ttyent.h>
X
XGLOBAL char *getttytype( tty )
Xchar *tty;
X{
X    register struct ttyent *ty;
X    register char *type;
X
X    setttyent();
X    if( (ty = getttynam( tty )) == NULL )
X	type = NULL;
X    else
X	type = ty->ty_type;
X
X    endttyent();
X    return( type );
X} /* 4.3 getttytype */
X
X# else  /* TTYENT not defined */
X
X# include <strings.h>
X
XGLOBAL char *getttytype( tty )
Xchar *tty;
X{
X    FILE *f;
X    char line[ 512 ];
X    char *cp, *type;
X    register char *sp;
X
X    if( (f = fopen("/etc/ttytype", "r")) == NULL )
X	return( NULL );
X
X    type = NULL;			/* be realistic */
X    while( fgets( line, sizeof( line ), f ) != NULL ) {
X	cp = line;
X	if( !skipwhite( &cp ) )
X	    continue;
X
X	type = cp;
X	if( !skipblack( &cp ) )
X	    continue;
X	*cp++ = EOS;			/* tie off type */
X
X	if( !skipwhite( &cp ) )		/* eat white. */
X	    continue;
X
X	if( (sp = index(cp, '\n')) != NULL ) /* kill eol */
X	    *sp = EOS;
X
X	if( strcmp( cp, tty ) != 0 ) {	/* match tty name? */
X	    type = NULL;
X	    continue;			/* no, back to work */
X	}
X	break;
X    } /* while */
X    fclose( f );
X    return( type );
X} /* 4.2 getttytype */
X# endif /* TTYENT not defined */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_getttytype.c
if test 1782 -ne `wc -c <getttytype.c`; then
    echo shar: \"getttytype.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f getut.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"getut.c\"
else
echo shar: Extracting \"getut.c\" \(2006 characters\)
sed "s/^X//" >getut.c <<'END_OF_getut.c'
X/*
X * getut.c -- read utmp file
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: getut.c,v 3.0 90/07/06 13:10:58 budd Rel $";
X# endif /* lint not defined */
X
X# include "finger.h"
X# ifdef USG				/* UTMP_NEEDS_TIME_T? */
X# include <sys/types.h>			/* for time_t */
X# endif /* USG defined */
X# include <utmp.h>
X# include <stdio.h>
X
X# ifdef USER_PROCESS
X# include <errno.h>
X# endif /* USER_PROCESS defined */
X
X# define UTFILE "/etc/utmp"
X# define MAXNAME 100
X
XLOCAL char utfile[MAXNAME] = UTFILE;
XLOCAL FILE *f = NULL;
X
Xvoid setutent() {
X    if( f == NULL )
X	f = fopen( utfile, "r" );
X    else
X	rewind( f );
X} /* setutent */
X
Xvoid endutent() {
X    if( f != NULL )
X	fclose( f );
X} /* endutent */
X
Xvoid utmpname( file )
Xchar *file;
X{
X    endutent();
X    strcpy(utfile, file);
X} /* utmpname */
X
Xstruct utmp *getutent() {
X    static struct utmp ut;
X 
X    if( f == NULL ) {
X	setutent();
X	if( f == NULL )
X	    return( NULL );
X    }
X
X    while( fread(&ut, sizeof( ut ), 1, f) == 1 ) {
X# ifdef USER_PROCESS
X	if( ut.ut_type == USER_PROCESS
X	   && (kill( ut.ut_pid, 0 ) == 0 || errno == EPERM ) )
X# endif /* USER_PROCESS defined */
X	    return( &ut );
X    }
X    rewind( f );
X    return( NULL );
X} /* getutent */
X
X/*
X *	not implemented:
X *
X *	void pututline( struct utmp *u );
X *		(uses direct write(2))
X *	struct utmp *getutline( struct utmp *line )
X *		find entry with matching ut->line
X *	struct utmp *getutid( struct utmp *id )
X *		find entry with matching ut->type (!!)
X *		(RUN_LVL, BOOT_TIME, OLD_TIME, NEW_TIME)
X *		if one of (INIT_PROCESS, LOGIN_PROCESS, USER_PROCESS
X *		or DEAD_PROCESS) ut_id must mach also.
X */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_getut.c
if test 2006 -ne `wc -c <getut.c`; then
    echo shar: \"getut.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f kmem.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"kmem.c\"
else
echo shar: Extracting \"kmem.c\" \(3486 characters\)
sed "s/^X//" >kmem.c <<'END_OF_kmem.c'
X/*
X * kmem.c -- interact with /dev/kmem, /dev/mem etc.
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: kmem.c,v 3.0 90/07/06 13:11:09 budd Rel $";
X# endif /* lint not defined */
X
X# include "finger.h"
X# if Umax != 42
X# include <sys/types.h>
X# include "kmem.h"
X# include "args.h"			/* sw_debug */
X
X/* # define DEBUG			/**/
X
X# ifdef sun
X# include "info.h"			/* info_[r]consdev */
Xextern struct info I;			/* namelist values from names.c */
X
X# include <sys/stat.h>			/* to stat /dev/console */
XGLOBAL dev_t consdev;
XGLOBAL dev_t rconsdev;
XGLOBAL dev_t dev_console;
X# endif /* sun defined */
X
XGLOBAL FTYPE kmem;			/* fd for /dev/kmem */
X# if SunOS < 400
XGLOBAL FTYPE mem;			/* fd for /dev/mem */
X# ifdef SWAP_DEVICE
XGLOBAL FTYPE drum;			/* fd for /dev/drum */
X# endif /* SWAP_DEVICE defined */
X# else  /* not SunOS < 400 */
X# include <sys/file.h>			/* O_RDONLY */
X# include <stdio.h>			/* NULL */
X# endif /* not SunOS < 400 */
X
X
XGLOBAL int ini_kmem() {
X# ifdef sun
X    struct stat stb;
X# endif /* sun defined */
X
X# if SunOS >= 400
X    if( (kmem = kvm_open( NULL, NULL, NULL, O_RDONLY, "finger" )) == NULL ) {
X	perror("kvm_open");
X	return( FALSE );
X    }
X# else  /* not SunOS >= 400 */
X    if( ISBADFILE( (kmem = OPEN("/dev/kmem")) ) ) {
X	perror("/dev/kmem");
X 	kmem = BADFILE; 	
X	return( FALSE );
X    }
X
X    if( ISBADFILE( (mem = OPEN("/dev/mem")) ) ) {
X	perror("/dev/mem");
X	CLOSE(kmem);
X	kmem = BADFILE;
X	return( FALSE );
X    }
X
X# ifdef SWAP_DEVICE
X    if( ISBADFILE( (drum = OPEN( SWAP_DEVICE )) ) ) {
X	perror(SWAP_DEVICE);
X	CLOSE(kmem);
X	CLOSE(mem);
X 	kmem = BADFILE;
X 	return( FALSE );
X    }
X# endif /* SWAP_DEVICE defined */
X# endif /* not SunOS >= 400 */
X
X    if( !readnames() )			/* read in info struct */
X	return( FALSE );
X
X# ifdef sun
X    KMEMREAD(I.info_consdev,  &consdev,  sizeof(consdev));
X    KMEMREAD(I.info_rconsdev, &rconsdev, sizeof(rconsdev));
X    if( stat("/dev/console", &stb ) == 0 )
X	dev_console = stb.st_rdev;
X    else
X	dev_console = 0xffff;		/* makedev(255,255) */
X# ifdef DEBUGSW
X    if( sw_debug )
X	printf("consdev %#x rconsdev %#x /dev/console %#x\n",
X	       consdev, rconsdev, dev_console );
X# endif /* DEBUGSW defined */
X# endif /* sun defined */
X
X    return( TRUE );
X} /* ini_kmem */
X
X# if SunOS < 400			/* anything but SunOS 4.x */
XGLOBAL int kread(f, pos, buf, count)
XFTYPE f;
Xint count;
Xunsigned long pos;			/* caddr_t? */
Xchar *buf;
X{
X    int cc;
X# ifdef DEBUG
X    char *name;
X
X    if( f == mem )
X	name = " mem";
X    else if( f == kmem )
X	name = "kmem";
X    else if( f == drum )
X	name = "drum";
X    else
X	name = "??";
X# endif /* DEBUG defined */
X
X    if( SEEK(f, pos, 0) == -1 ) {
X        perror("seek");
X	cc = -1;
X    }
X    else 
X	cc = READ(f, buf, count);
X
X# if BUFIO
X    if( cc > 0 )
X	cc *= count;
X# endif /* BUFIO */
X
X# ifdef DEBUG
X    printf("kread: %s@%08x %d(%d) chars\n",
X	   name,
X	   pos,
X	   count,
X	   cc);
X# endif /* DEBUG defined */
X
X    if( cc == -1 ) {
X# ifdef DEBUG
X	perror("read");
X# endif /* DEBUG defined */
X	return( FALSE );
X    } /* bad return */
X    return( TRUE );
X} /* kread */
X# endif /* SunOS < 400 */
X
X# endif /* Umax != 42 */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_kmem.c
if test 3486 -ne `wc -c <kmem.c`; then
    echo shar: \"kmem.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f lastlog.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"lastlog.c\"
else
echo shar: Extracting \"lastlog.c\" \(1815 characters\)
sed "s/^X//" >lastlog.c <<'END_OF_lastlog.c'
X/*
X * lastlog.c - get time and location of last login
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: lastlog.c,v 3.0 90/07/06 13:11:14 budd Rel $";
X# endif /* lint not defined */
X
X# include "finger.h"
X# ifdef LASTLOG
X# include <sys/types.h>
X# include <ctype.h>
X# include <lastlog.h>
X
X# ifndef LLPATH
X# define LLPATH "/usr/adm/lastlog"
X# endif /* LLPATH not defined */
X
XLOCAL llfile = -1;
X
XGLOBAL void llopen() {
X    if( llfile < 0 )
X	llfile = open(LLPATH, 0);
X    else
X	lseek( llfile, 0L, 0 );
X} /* llopen */
X
XGLOBAL void llclose() {
X    if( llfile >= 0 )
X	close( llfile );
X} /* llclose */
X
XGLOBAL BOOL lltime( uid, location, time, host )
Xshort uid;
Xchar *location;
Xtime_t *time;
Xint *host;
X{
X    struct lastlog ll;
X
X    if( llfile < 0 )
X	return( FALSE );
X
X    lseek( llfile, uid * sizeof( ll ), 0 );
X    if( read(llfile, &ll, sizeof( ll ) ) != sizeof( ll ) )
X	return( FALSE );
X
X    *time = ll.ll_time;			/* return time of login */
X    if( ll.ll_host[0] != EOS ) {
X	*host = TRUE;
X	strzcpy(location, ll.ll_host,
X		sizeof( ll.ll_host ) );	/* copy fixed len */
X
X	if( isdigit(*location) )
X	    checkhost( location, sizeof( location ) ); /* hack octets */
X	undomain( location, 0 ); 	/* remove domains, but not prefixes */
X	HZUP( location );		/* upper caseify */
X    }
X    else {
X	*host = FALSE;
X	strzcpy(location, ll.ll_line, sizeof( ll.ll_line ) );
X    }
X    return( TRUE );
X} /* lltime */
X# endif /* LASTLOG defined */
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_lastlog.c
if test 1815 -ne `wc -c <lastlog.c`; then
    echo shar: \"lastlog.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f luser.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"luser.h\"
else
echo shar: Extracting \"luser.h\" \(1888 characters\)
sed "s/^X//" >luser.h <<'END_OF_luser.h'
X/*
X * luser.h -- per utmp entry information (December 1985)
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# define LUSER_RCSID "$Id: luser.h,v 3.0 90/07/06 13:11:17 budd Rel $"
X
X# define ULEN 9			/* user length */
X# define TLEN 9			/* tty (line) length */
X# define HLEN 40		/* host name length */
X
Xtypedef struct luser {		/* per-login/tty information */
X    /* use pointers for user, line, host? */
X    char u_user[ULEN];		/* user name */
X    char u_line[TLEN];		/* tty name */
X    char u_host[HLEN];		/* fn host (if any) */
X    time_t u_time;		/* login time */
X    time_t u_idle;		/* time of last terminal act. */
X    struct person *u_person;	/* personal information */
X    struct luser *u_left, *u_right; /* children for btree */
X    unsigned short u_flags;	/* flagies */
X    dev_t u_ttydev;		/* device number of tty */
X    struct pr *u_command, *u_daemonp; /* "current" process, daemon process */
X    struct daemon *u_daemon;	/* daemon if any */
X# ifdef Umax
X    long  u_ttyaddr;		/* inet addr of annex/rdp tty */
X    short u_ttytype;		/* device type of annex/rdp tty */
X    short u_ttynum;		/* device number of annex/rdp tty */
X# endif /* Umax defined */
X    struct switches u_sw;	/* per luser arg flags (from selector!) */
X} LUSER;
X
X# define LTREE LUSER
X
X/* in u_flags */
X# define U_NOWRITE 001		/* msg n */
X# define U_BIFF	   002		/* biff y */
X# define U_NLI     004		/* not logged in */
X# define U_FOUND   010		/* found logged in */
X# define U_HUNGRY  020		/* hungry y */
X# define U_BADTTY  040		/* could not stat tty */
X
X/*
X * Local variables:
X * comment-column: 32
X * End:
X */
END_OF_luser.h
if test 1888 -ne `wc -c <luser.h`; then
    echo shar: \"luser.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f newmanifest.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"newmanifest.c\"
else
echo shar: Extracting \"newmanifest.c\" \(3484 characters\)
sed "s/^X//" >newmanifest.c <<'END_OF_newmanifest.c'
X/*
X * newmanifest.c -- crock to merge MANIFEST descriptions with file list
X *
X * Copyright (C) 1989, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: newmanifest.c,v 3.0 90/07/06 13:11:25 budd Rel $";
X# endif /* lint not defined */
X
X# include <stdio.h>
X# include <ctype.h>
X# include <strings.h>			/* I'm sorry for you if you use USG! */
X
X# define MAXFILES 5000			/* seems like plenty */
X# define MAXSTR 100
X
Xstruct file {
X    char fname[ MAXSTR ];
X    int archive, found;
X    char descrip[ MAXSTR ];
X} files[ MAXFILES ];			/* should use a binary tree. */
Xint nfiles = 0;
X
X# define MANIFEST "MANIFEST"
X
Xchar *prog;
X
Xint
Xmain( argc, argv )
X    int argc;
X    char *argv[];
X{
X    FILE *m;
X    char line[ 1024 ];
X    int i;
X
X    prog = argv[0];
X    argc--;
X    argv++;
X
X    if( (m = fopen(MANIFEST, "r")) == NULL ) {
X	perror( MANIFEST );
X    }
X    else {
X	int skip = 2;
X
X	while( fgets( line, sizeof( line ), m ) != NULL )
X	    if( skip > 0 )
X		skip--;
X	    else {
X		char *cp, *dp;
X		if( (cp = index( line, '\n' )) != NULL )
X		    *cp = '\0';
X		else
X		    fprintf( stderr, "line truncated!!\n" );
X
X		cp = line;
X		if( isspace( *cp ) )
X		    cp++;
X		if( *cp == '\0' )
X		    continue;
X
X		dp = files[ nfiles ].fname;
X		while( *cp != '\0' && !isspace( *cp ) )
X		    *dp++ = *cp++;
X		if( dp == files[ nfiles ].fname )
X		    continue;
X
X		while( isspace( *cp ) )
X		    cp++;
X
X		files[ nfiles ].archive = atoi( cp ); /* who cares!! */
X		while( isdigit( *cp ) )	/* skip past archive number */
X		    cp++;
X
X		while( isspace( *cp ) )	/* skip any whitspace */
X		    cp++;
X
X		dp = files[ nfiles ].descrip;
X		while( *dp++ = *cp++ )	/* save any description */
X		    ;
X
X		files[nfiles].found = 0; /* not found yet */
X		nfiles++;
X	    } /* not skipping */
X    } /* while */
X
X    /* perhaps qsort files[] so we can binary search? */
X    /* perhaps store in a binary tree so we can insert easily? */
X    /* don't you wish you used C++?? Looks like line noise to me tho.... */
X    /* do we really care? how big is this kit anyway??? */
X
X    while( argc > 0 ) {
X	for( i = 0; i < nfiles; i++ )	/* awful linear search */
X	    if( strcmp( files[i].fname, argv[0]) == 0 ) {
X		files[i].found = 1;	/* now can see (was blind) */
X		break;
X	    }
X	if( i == nfiles ) {		/* not found in MANIFEST? */
X	    strcpy( files[i].fname, argv[0] ); /* add it to list */
X	    strcpy( files[i].descrip, "" ); /* sorry. */
X	    files[i].archive = 999;	/* very silly kit number */
X	    files[i].found = -1;	/* flag as just added */
X	    nfiles++;
X	    fprintf( stderr, "adding %s\n", argv[0] );
X	} /* not previously in list */
X	argc--;
X	argv++;
X    } /* while argc */
X
X    /* I'm so lazy, should fopen output file, not use stdout! */
X    puts("this was created by newmanifest.");
X    puts("   File Name		Archive #	Description");
X
X    /* less than perfect formatting. will be re-read by makekit soon */
X    for( i = 0; i < nfiles; i++ )
X	if( files[i].found != 0 )	/* found in argv[] */
X	    printf(" %-25s %d\t%s\n",
X		   files[ i ].fname,
X		   files[ i ].archive,
X		   files[ i ].descrip );
X	else				/* not found... */
X	    fprintf( stderr, "flushing %s\n", files[i].fname );
X    return( 0 );			/* Be ANSI */
X} /* main */
END_OF_newmanifest.c
if test 3484 -ne `wc -c <newmanifest.c`; then
    echo shar: \"newmanifest.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f nttyloc.5 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"nttyloc.5\"
else
echo shar: Extracting \"nttyloc.5\" \(2000 characters\)
sed "s/^X//" >nttyloc.5 <<'END_OF_nttyloc.5'
X.\" -*-nroff-*-
X.\" $Id: nttyloc.5,v 3.0 90/07/06 13:11:27 budd Rel $
X.\" Copyright (c) 1987, 1990  Philip L. Budne
X.TH NTTYLOC 5 "14 June 1988"
X.UC 4
X.SH NAME
Xnttyloc \- new finger ttyloc file format
X.SH DESCRIPTION
XThe
X.I nttyloc
Xfile describes the physical location and type of each terminal
Xline on the system.  This file is accessed via the
X.I readttyloc (3)
Xand
X.I findttyloc (3)
Xfunctions.
X.PP
XIf the first non whitespace character on a line is a poundsign (#),
Xthe line is ignored. The first field is the line type.  The keyword
X.I ttyloc
Xsignifies a hardwired line not suitable for mauling by an idle terminal
Xmauling daemon (none exist yet) while
X.I hardwire
Xsignifies one that is.
X.I dialup
Xmeans that the line is directly connected to a modem, data switch,
Xor other ephemeral terminal location.
X.I random
Xcan be used when the line is not connected.
X.PP
XThe second field is the ``short'' location, displayed by
X.IR finger (1)
Xwhen the user has created a file named ttyloc\fIhostname_tty\fR
Xin /usr/spool/ttyloc since login using the
X.IR ttyloc (1)
Xprogram.  The third field is the ``long'' location displayed when
Xthere is no current file in /usr/spool/ttyloc.
XBoth the short fields can be many words long (or empty) if quoted
Xwith single or double quote marks.
X
X.PP
XSome examples:
X.PP
X.ta \w'random\ \ 'u +\w'console\ \ 'u +\w'VA3451\ \ 'u +.7i
X.nf
X# bu-cs /etc/nttyloc
Xttyloc	console	CTY 	"BU-CS console"
Xdialup	tty00	VA3451	"IMP (VA3451)"
Xrandom	tty01	MUX	MUX
Xhard	tty02	Opr	"Operations Central (x2089)"
Xttyloc	tty03	3b5	"3b5 ersatz ethernet"
Xdialup	tty08	""	"Campus Terminal Network"
Xttyloc	ttya	qms	"Terminal port A (QMS 1200)"
X.fi
X.SH FILES
X.ta \w'/usr/spool/ttyloc\ \ 'u
X.nf
X/etc/nttyloc	system default ttylocs (line type, tty, short/long)
X/etc/ttyloc	system default ttylocs old format (tty, long)
X/etc/ttys	used under 4.3 for last ditch (ttytype/comment)
X/usr/spool/ttyloc	user set ttyloc files
X.fi
X.SH "SEE ALSO"
Xfinger(1), ttyask(1), readttylocfile(3)
X.SH AUTHOR
XPhilip L. Budne
END_OF_nttyloc.5
if test 2000 -ne `wc -c <nttyloc.5`; then
    echo shar: \"nttyloc.5\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f string.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"string.c\"
else
echo shar: Extracting \"string.c\" \(2753 characters\)
sed "s/^X//" >string.c <<'END_OF_string.c'
X/*
X * string.c -- common string routines for finger (December 1985)
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: string.c,v 3.0 90/07/06 13:11:46 budd Rel $";
X# endif /* lint not defined */
X
X# include <ctype.h>			/* for isxxx */
X# include <stdio.h>			/* for NULL */
X# include <strings.h>			/* for strcpy() */
X# include "finger.h"
X# include "upper.h"			/* uppercase[] */
X
XGLOBAL char *strip( s )
Xregister char *s;
X{
X    register char *cp;
X
X    for( cp = s; isprint( *cp ); cp++ )	/* skip printing chars */
X	;
X    *cp = EOS;				/* tie off after printables */
X
X    while( cp > s )			/* backup */
X	if( isspace( *(cp - 1) ) )	/* is previous a space? */
X	    cp--;			/* yes, keep going */
X	else
X	    break;
X    *cp = EOS;				/* tie off before spaces */
X
X    for( cp = s; isspace( *cp ); cp++ )	/* start at top */
X	;				/* skipping spaces */
X
X    return( cp );			/* return remainder */
X} /* strip */
X
XGLOBAL void cleanup( s )	/* strip off leading white, trailing crud */
Xregister char *s;		/* in place */
X{
X    register char *cp;
X
X    for( cp = s; isprint( *cp ); cp++ ) ; /* cut off any crud.. */
X    *cp = EOS;
X
X    for( cp = s; *cp != EOS && isspace( *cp ); cp++ ); /* trim leading white */
X
X    if( cp != s )		/* leading white? */
X	if( *cp == EOS )
X	    *s = EOS;		/* empty string!! */
X	else
X	    strcpy(s, cp);	/* copy backwards to remove leading white */
X} /* cleanup */
X
XGLOBAL char *zup( s )		/* blast in place to upper */
Xchar *s;
X{
X    register char *cp;
X    for( cp = s; *cp != NULL; cp++ )
X	    *cp = uppercase[ *cp & 0177 ];
X
X    return( s );
X} /* zup */
X
XGLOBAL char *strzcpy(dest, src, count)	/* non-nul terminated src, max length */
Xregister char *dest, *src;
Xregister int count;
X{
X    while( count-- > 0  &&  *src != EOS )
X	*dest++ = *src++;
X
X    *dest = EOS;
X    return( dest );
X} /* strzcpy */
X
X
XGLOBAL char *strupcpy(dest, src)	/* copy and uppercasify */
Xregister char *src, *dest;
X{
X    register int c;
X
X    do
X	*dest++ = uppercase[ (c = *src++ & 0177) ];
X    while( c != EOS );
X    return( dest );
X} /* strupcpy */
X
XGLOBAL char *savestr( s )
Xchar *s;
X{
X    char *d;
X
X    if( s == NULL )
X	return( NULL );			/* note: NOT "" (see alias copy loop) */
X					/* in args.c */
X
X    if( (d = malloc( strlen( s ) + 1 )) == NULL ) {
X	fprintf(stderr, "?Savestr failed for '%s'\n", s);
X	exit( 1 );
X    }
X    return( strcpy(d, s) );
X} /* savestr */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_string.c
if test 2753 -ne `wc -c <string.c`; then
    echo shar: \"string.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f switch.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"switch.h\"
else
echo shar: Extracting \"switch.h\" \(2349 characters\)
sed "s/^X//" >switch.h <<'END_OF_switch.h'
X/*
X * switch.h -- switch definitions for finger
X *
X * Copyright (C) 1987, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# define SWITCH_RCSID "$Id: switch.h,v 3.0 90/07/06 13:11:50 budd Rel $"
X
X/* string, unique length, action(routine in args.c), help */
XSWITCH("age",	    1,set_age,	"display job age rather than idle time")
XSWITCH("berkeley",  1,set_berkeley,"user names imply /plan/whois")
X# ifdef DEBUGSW
XSWITCH("debug",	    1,set_debug,"enable debug output")
X# endif /* DEBUGSW defined */
X# ifdef notdef
XSWITCH("fields",    2,set_fields,"output for awk /fields[:sep] sets FS")
X# endif /* notdef defined */
XSWITCH("follow",    2,set_follow,"let finger do the walking (follow .forward)")
XSWITCH("help",	    1,display_help,"display help (you are looking at it)")
XSWITCH("its",	    1,set_its,"format output more like MIT-ITS finger")
XSWITCH("location",  1,set_location,"ignore user set ttylocs")
XSWITCH("mail-check",3,set_mail,	"show information about mail file")
XSWITCH("match-user",1,set_match,"match on user name only")
X# ifdef INQUIRE
XSWITCH("noinquire", 1,set_noinquire,"prohibit using inquire database")
X# endif /* INQUIRE defined */
XSWITCH("noplan",    3,set_noplan,"prohibit plan display")
X# ifdef SAVED_NLIST
XSWITCH("nosave-nlist",3,set_nosave,"prohibit saving of /vmunix namelist file")
X# endif /* SAVED_NLIST defined */
XSWITCH("output-idle",1,set_output,"show time since last output to terminal")
XSWITCH("plan-check",1,set_plan,	"show plan files")
XSWITCH("pid",	    2,set_pid,	"show process id")
X# ifdef SAVED_NLIST
XSWITCH("read-nlist",1,set_read, "force reading of /vmunix namelist file")
X# endif /* SAVED_NLIST defined */
XSWITCH("short",	    1,set_jobs,	"short form (same as /jobs)")
XSWITCH("state",	    1,set_state,"display process state in place of idle time")
XSWITCH("user-match",1,set_match,"alias for /match-user")
XSWITCH("whois",	    1,set_whois,"display personal info (whois command)")
XSWITCH("whoj",	    4,set_jobs, "alias for /short")
XSWITCH("version",   1,display_version, "display version")
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_switch.h
if test 2349 -ne `wc -c <switch.h`; then
    echo shar: \"switch.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f syms.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"syms.h\"
else
echo shar: Extracting \"syms.h\" \(2245 characters\)
sed "s/^X//" >syms.h <<'END_OF_syms.h'
X/*
X * syms.h -- names to lookup via nlist
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# define SYMS_RCSID "$Id: syms.h,v 3.0 90/07/06 13:11:53 budd Rel $"
X
X# ifndef _FINGER_H_
X# include "finger.h"
X# endif /* _FINGER_H_ not defined */
X
X# ifndef _SYMS_H_
X# define _SYMS_H_
X# ifdef sgi
X# define HAVE_KERNEL_MAGIC
X# endif /* sgi defined */
X# ifndef USG
X# define HAVE_VERSION
X# endif /* USG not defined */
X# endif /* _SYMS_H_ not defined */
X
X/*
X *	First argument is string for nlist.
X *	Second argument is string for nlist on COFF systems
X *	Third is member name for Info struct
X */
X
X    SYM("_proc","proc",proc)		/* process table (or pointer) */
X# if SunOS < 410
X    SYM("_u","u",u)			/* u struct (for pause sleep addr) */
X# else  /* not SunOS < 410 */
X    SYM("_kernelmap","u",u)			/* u struct (for pause sleep addr) */
X# endif /* not SunOS < 410 */
X
X# ifdef USG
X    SYM("_v","v",v)			/* sys/var.h var struct */
X# ifdef STREAMS
X    SYM("_pollwait","pollwait",pollwait) /* poll(2) sleep address */
X# endif /* STREAMS defined */
X# else  /* USG not defined */
X    SYM("_nproc","nproc",nproc)		/* size of process table */
X    SYM("_version","version",version)	/* version/build id string */
X    SYM("_selwait","selwait",selwait)	/* select(2) sleep address */
X# endif /* USG not defined */
X
X# ifdef sun
X    SYM("_consdev","consdev",consdev)	/* console device */
X    SYM("_rconsdev","rconsdev",rconsdev) /* redirected console? */
X# endif /* sun defined */
X
X# ifdef sgi
X    SYM("_end","end",end)		/* label at end of bss */
X    SYM("_kernel_magic","kernel_magic",kernel_magic) /* value of _end */
X# endif /* sgi defined */
X
X# ifdef NEED_USRPT
X    SYM("_usrpt","usrpt",usrpt)
X    SYM("_Usrptmap","Usrptmap",Usrptmap)
X# endif /* NEED_USRPT defined */
X
X# ifdef ibm032				/* RT/AOS4.3 */
X    SYM("_procSIZE","procSIZE",procSIZE)
X    SYM("_userSIZE","userSIZE",userSIZE)
X# endif /* ibm032 defined */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_syms.h
if test 2245 -ne `wc -c <syms.h`; then
    echo shar: \"syms.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ttyloc.1 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ttyloc.1\"
else
echo shar: Extracting \"ttyloc.1\" \(3045 characters\)
sed "s/^X//" >ttyloc.1 <<'END_OF_ttyloc.1'
X.\" -*-nroff-*-
X.\" $Id: ttyloc.1,v 3.0 90/07/06 13:12:00 budd Rel $
X.\" Copyright (c) 1987, 1990  Philip L. Budne
X.TH TTYLOC 1 "14 June 1988"
X.UC 4
X.SH NAME
Xttyloc, ttyfrob, ttyask, ttyplace, ttycycle, ttyrandom \- set user console location for finger
X.SH SYNOPSIS
X.B ttyloc
X[
X.I text
X]
X
X.B ttyfrob
X.I terminal
X[
X.I text
X]
X
X.B ttyask
X[
X.B -c
X] [
X.B -p
X] [
X.B -r
X] [
X.B -f
X.I file
X] [
X.B -t
X.I time
X] [
X-h
X]
X
X.B ttyplace
X[
X.B -a
X] [
X.B -c
X] [
X.B -r
X] [
X.B -f
X.I file
X]
X.I place
X
X.B ttycycle
X[
X.B -a
X] [
X.B -p
X] [
X.B -r
X] [
X.B -f
X.I file
X] [
X.B -t
X.I time
X]
X
X.B ttycycle
X[
X.B -a
X] [
X.B -p
X] [
X.B -r
X] [
X.B -f
X.I file
X] [
X.B -t
X.I time
X]
X
X.B ttyrandom
X[
X.B -a
X] [
X.B -c
X] [
X.B -p
X] [
X.B -f
X.I file
X] [
X.B -t
X.I time
X]
X
X.SH DESCRIPTION
X.I Ttyloc
Xsets the
X.I finger
Xterminal location string for the current terminal login.
XIf the user does not run
X.I ttyloc
Xa default location is displayed. Running
X.I ttyloc
Xwith no arguments clears the user set location string.
X
X.I Ttyfrob
Xsets the location string for the specified terminal.
XThe user must own the device or be the super user.
X
X.I Ttyask
Xis a front end for ttyloc, useful in your
X.I .login
Xor
X.I .profile
Xfile it reads the
Xfile
X.I ~/.ttyplaces
Xof the following format:
X
X.ta 1i
X.nf
Xoffice	Office: MCS 107 x9069
Xhome	Brookline, Ma
Xconsole	Console
Xprint	CS Printer Room
Xmachine	CS Machine Room
Xother	LOST IN SPACE
X.fi
X.ta
X.br
X
XThe user is prompted for each entry
X.B --home--
Xuntil an afirmative response (space, Y, y) is given.  Negative
Xreponses are rubout (delete key), N and n, no return is needed Q or q
Xto quit. Question mark gives help.
X
XIf the
X.B -h
Xflag is used and the terminal is determined to have a hardwired
Xlocation the user is not prompted.  The
X.B -f
Xflag forces
X.I ttyask
Xto read an alternate
X.I ttyplaces
Xfile.
X
XThe
X.B -t
X.I time
Xoption causes
X.I ttyask
Xto timeout if a location is not selected in
X.I time
Xseconds.
X
X.I Ttyplace
Xis an alias for
X.I ttyask -a
Xthat accepts a string argument that is searched for in the
X.I ttyplaces
Xfile.
X
X.I Ttyrandom
Xis an alias of
X.I ttyask -r
Xthat randomly selects a ttyloc from the ttyplaces file.
XWith the
X.B -t
X.I time
Xoption it will pick a new ttyloc every
X.I time
Xseconds.
X
X.I Ttycycle
Xis an alias of
X.I ttyask -c
Xthat sequences through the location in the ttyplaces file.  The
Xdefault cycle time is 60 seconds, and can be set with the
X.B -t
X.I time
Xoption.
X
XAll of
X.I ttyask, ttyplace, ttycycle,
Xand
X.I ttyrandom
Xaccept the flags
X.TP
X.B -a
Xforce into
X.I ttyask
Xmode
X.TP
X.B -p
Xforce into
X.I ttyplace
Xmode
X.TP
X.B -r
Xforce into
X.I ttyrandom
Xmode
X.TP
X.B -c
Xforce into
X.I ttycycle
Xmode
X
X.SH FILES
X.ta 2i
X.nf
X/usr/spool/ttyloc	user set ttyloc files
X~/.ttyplaces	locations for ttyask/ttyplace/ttyrandom
X/etc/nttyloc	new format default locations
X/etc/ttyloc	for per-line system default ttylocs (old form)
X/etc/ttytype	(4.2 only) used to determine hardwire-ness (or lack thereof)
X/etc/ttys	(4.3 only) used for ttytype (hardwire) and fallback location
X.fi
X.ta
X.SH SEE ALSO
X.IR finger (1),
X.IR nttyloc (5)
X.SH AUTHOR
XPhilip L. Budne, Boston University
END_OF_ttyloc.1
if test 3045 -ne `wc -c <ttyloc.1`; then
    echo shar: \"ttyloc.1\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ttyloc.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ttyloc.c\"
else
echo shar: Extracting \"ttyloc.c\" \(4467 characters\)
sed "s/^X//" >ttyloc.c <<'END_OF_ttyloc.c'
X/*
X * ttyloc.c -- Set Terminal Location (December 1985)
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: ttyloc.c,v 3.0 90/07/06 13:12:02 budd Rel $";
X# endif /* lint not defined */
X
X# include <sys/types.h>
X# include <sys/stat.h>
X# include <strings.h>
X# include <errno.h>
X# include <ctype.h>
X# include <stdio.h>
X# include "finger.h"
X
Xextern int errno;
X
X# define LCLEN 100			/* location length */
X# define FNLEN 100			/* file name length */
Xchar *argv0;
X
XGLOBAL char localhost[ MAXHOSTLEN+1 ];
X
Xextern char *ttyname();			/* from library */
Xextern char *locname();			/* from locname.c! */
XFORWARD LOCAL char *gettname();
XFORWARD LOCAL void getlocation(), fatal(), checkown(), pfatal(), checkdevice();
X
XGLOBAL int main( argc, argv )
X    int argc;
X    char *argv[];
X{
X    int len;				/* length of ttyloc string */
X    FILE *f;
X    BOOL frobbing;			/* true if ttyfrob */
X    char *tname;
X    char locstr[LCLEN], *tfname;
X
X    gethostname( localhost, MAXHOSTLEN );
X
X    argv0 = "ttyloc?";
X    frobbing = FALSE;
X
X    if( argc > 0 ) {
X	argv0 = rindex( argv[0], '/' );
X	if( argv0 == NULL )
X	    argv0 = argv[0];
X	else
X	    argv0++;
X
X	if( strcmp(argv0, "ttyfrob") == 0 )
X	    frobbing = TRUE;
X
X	argc--;
X	argv++;
X    }
X
X    if( frobbing ) {
X	if( argc > 0 ) {
X	    tname = argv[0];
X	    argc--;
X	    argv++;
X	    checkdevice( tname );
X	} /* more args */
X	else
X	    fatal("must have tty name");
X    } /* frobbing */
X    else {
X	char *dev;
X# if 0					/* returns /dev/tty! */
X	dev = ctermid( NULL );
X	if( dev == NULL )
X# endif /* 0 */
X	    dev = ttyname( 0 );
X	if( dev == NULL )
X	    fatal("could not find tty!");
X	checkown( dev );
X	tname = gettname( dev );
X    }
X    getlocation(locstr, argc, argv);
X
X    tfname = locname( tname );		/* get spool file name */
X
X    len = strlen(locstr);
X    if( len == 0 ) {
X	if( unlink( tfname ) < 0 && errno != ENOENT )
X	    pfatal("could not unlink %s", tfname );
X	exit( 0 );
X    }
X
X    f = fopen( tfname, "w" );
X    if( f == NULL )
X	pfatal("could not open %s");
X
X    fputs( locstr, f );			/* check return? */
X
X# ifdef USG
X    chmod( tfname, TTYLOC_MODE );
X# else  /* USG not defined */
X    fchmod(fileno(f), TTYLOC_MODE);
X# endif /* USG not defined */
X    fclose( f );			/* check for err? */
X    return( 0 );			/* ANSI! */
X} /* main */
X
XLOCAL void checkdevice( s )
X    char *s;
X{
X    char devname[20];
X
X    strcpy(devname, "/dev/");
X    strcat(devname, s);
X    checkown( devname );
X} /* checkdevice */
X
XLOCAL char *gettname( device )
X    char *device;
X{
X    device = rindex(device, '/');
X    if( device != NULL )
X	device++;			/* skip over last slash */
X    return( device );
X} /* getttname */
X
XLOCAL void getlocation(locstr, count, vec)
Xchar *locstr;
Xint count;
Xchar *vec[];
X{
X    register char *cp, *sp;
X
X    cp = locstr;
X    *cp = EOS;
X
X    while( count > 0 ) {
X	sp = vec[0];
X	if( cp != locstr )
X	    *cp++ = ' ';
X
X	while( *sp != EOS ) {
X	    if( isprint( *sp ) )
X		*cp++ = *sp;
X	    else
X		fprintf( stderr, "%%%s: ignoring non printing character 0%o\n",
X			argv0, *sp & 0xff );
X	    sp++;
X	}
X	count--;
X	vec++;
X    }
X    if( cp != locstr )
X	*cp++ = '\n';
X    *cp = EOS;
X} /* getlocation */
X
XLOCAL void fatal( s, x )
Xchar *s;
Xint x;
X{
X    char line[ 1024 ];
X    sprintf( line, s, x );
X    fprintf(stderr, "?%s: %s\n", argv0, line );
X    exit( 1 );
X} /* fatal */
X
XLOCAL void pfatal( s, x )
Xchar *s;
Xint x;
X{
X    extern int errno, sys_nerr;
X    extern char *sys_errlist[];
X    char line[ 1024 ];
X
X    sprintf( line, s, x );
X    if( errno > 0 && errno < sys_nerr )
X	fprintf(stderr, "?%s: %s; %s\n", argv0, line, sys_errlist[ errno ] );
X    else
X	fprintf(stderr, "?%s: %s; error %d\n", argv0, line, errno );
X    exit( 1 );
X} /* pfatal */
X
XLOCAL void checkown( name )
X    char *name;
X{
X    struct stat stb;
X    int uid;
X
X    if( stat( name, &stb ) < 0 ) {
X	pfatal("could not stat %s", name );
X	exit( 1 );
X    } /* stat ok */
X    if( (stb.st_mode & S_IFMT) != S_IFCHR )
X	fatal("%s is not a character device!");
X    uid = getuid();			/* get invoker's uid */
X    if( uid != 0 && stb.st_uid != uid )
X	fatal( "not owner of %s", name );
X} /* checkown */
X
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_ttyloc.c
if test 4467 -ne `wc -c <ttyloc.c`; then
    echo shar: \"ttyloc.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f uptime.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"uptime.c\"
else
echo shar: Extracting \"uptime.c\" \(1934 characters\)
sed "s/^X//" >uptime.c <<'END_OF_uptime.c'
X/*
X * uptime.c -- /usr/ucb/uptime replacement for USG systems
X *
X * Copyright (C) 1989, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: uptime.c,v 3.0 90/07/06 13:12:10 budd Rel $";
X# endif /* lint not defined */
X
X# include <stdio.h>
X# include <sys/types.h>
X# include <time.h>
X# include <utmp.h>
X
Xmain() {
X    struct utmp *ut;
X    time_t boot, now;
X    struct tm *tm;
X    int users, hour, min, day, items;
X    char am;
X
X    users = boot = 0;
X    setutent();
X    while( (ut = getutent()) )
X	switch( ut->ut_type ) {
X	case BOOT_TIME:
X	    boot = ut->ut_time;
X	    break;
X	case USER_PROCESS:
X	    users++;
X	    break;
X	}
X
X    time( &now );
X    tm = localtime( &now );
X
X    hour = tm->tm_hour;
X    am = 'a';
X    if( hour == 0 )			/* fix midnight */
X	hour = 12;
X    else if( hour > 11 ) {		/* after 11AM */
X	am = 'p';			/* its after-noon */
X	if( hour > 12 )			/* but don't touch 12!! */
X	    hour -= 12;
X    } /* pm */
X    printf("%2d:%02d%cm  ", hour, tm->tm_min, am );
X
X    items = 0;
X    if( boot != 0 ) {
X	int min, day;
X	boot = now - boot;		/* get time since boot */
X	boot /= 60;			/* get minutes */
X
X	min = boot % 60;
X	boot /= 60;			/* toss mins */
X
X	hour = boot % 24;		/* get hours */
X	boot /= 24;
X
X	day = boot % 7;
X	boot /= 7;
X
X	printf("up ");
X
X# define PUTF(what,n)\
X	{ if( items++ > 0 ) { putchar(','); putchar(' '); } \
X	printf("%d %s", n, what); if( n != 1 ) putchar('s'); }
X
X	if( boot > 0 )
X	    PUTF("week", boot );
X
X	if( day > 0 )
X	    PUTF("day", day );
X
X	if( hour > 0 )
X	    PUTF("hour", hour );
X
X	if( min > 0 )
X	    PUTF("minute", min );
X    } /* have boot */
X
X    PUTF("user", users );
X    putchar('\n');
X}
END_OF_uptime.c
if test 1934 -ne `wc -c <uptime.c`; then
    echo shar: \"uptime.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ustruct.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ustruct.h\"
else
echo shar: Extracting \"ustruct.h\" \(2568 characters\)
sed "s/^X//" >ustruct.h <<'END_OF_ustruct.h'
X/*
X * ustruct.h -- system includes for user struct
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# define USTRUCT_RCSID "$Id: ustruct.h,v 3.0 90/07/06 13:12:14 budd Rel $"
X
X# ifdef accel
X# define INCLUDE_HEADERS
X# endif /* accel defined */
X
X# include <sys/param.h>			/* everyone!! */
X
X# ifdef USG
X
X# include <sys/types.h>
X# include <sys/time.h>			/* for proc.h */
X# include <sys/signal.h>		/* for MAXSIG */
X
X# ifdef sgi
X# include <sys/syssgi.h>
X# endif /* sgi defined */
X
X# ifdef SYSI86
X# include <sys/sysi86.h>
X# endif /* SYSI86 defined */
X
X# ifndef AIX_RT				/* PC/RT AIX uses VRM segments */
X
X# ifdef AIX3
X
X# include <procinfo.h>
X
X# else  /* AIX3 not defined */
X
X# ifdef AUX				/* SVR2 */
X
X# include <sys/mmu.h>
X# include <sys/page.h>
X# include <sys/seg.h>			/* for proc.h */
X# include <sys/region.h>		/* for proc.h */
X
X# else  /* AUX not defined */
X
X# ifndef AIX_PS2
X
X/* SVR3: UmaxV, 386/ix */
X
X# ifdef DIR_H
X# include <sys/dir.h>			/* for dirent u_dent */
X# else  /* DIR_H not defined */
X# include <sys/fs/s5dir.h>		/* for dirent u_dent */
X# endif /* DIR_H not defined */
X
X# ifndef SYSI86
X/* for UmaxV, sgi */
X# include <sys/sbd.h>			/* for proc.h (p_ubptbl[])*/
X# endif /* SYSI86 not defined */
X
X# include <sys/immu.h>			/* for region.h */
X# include <sys/region.h>		/* for preg_t p_region */
X
X# endif /* AIX_PS2 not defined */
X# endif /* AUX not defined */
X
X# endif /* AIX3 not defined */
X
X# endif /* AIX_RT not defined */
X
X# else  /* USG not defined */
X
X/* BSD systems here */
X
X# if defined(bsd4_3) || defined(ultrix)	/* ifdef NI_DENT?? */
X# include <sys/dir.h>			/* for direct ni_dent in namei.h */
X# endif /* defined(bsd4_3) || defined(ultrix) */
X
X# if SunOS < 400
X# include <sys/vm.h>
X# ifndef accel
X# include <machine/pte.h>
X# endif /* accel not defined */
X# endif /* SunOS < 400 */
X
X# if SunOS >= 410
X# include <sys/session.h>
X# endif /* SunOS >= 410 */
X
X# endif /* USG not defined */
X
X/* everyone!! */
X# include <sys/user.h>
X# include <sys/proc.h>			/* for p_pid */
X# undef u				/* sgi defines macro */
X
X# ifndef SHORT_TTYP			/* SVR2, BSD, SOS3.x */
X# ifdef TTY_REQUIRES_IOCTL		/* 4.3, Ultrix */
X# include <sys/ioctl.h>
X# endif /* TTY_REQUIRES_IOCTL defined */
X# include <sys/tty.h>			/* for t_pgrp, t_{raw,out}q */
X# endif /* SHORT_TTYP not defined */
END_OF_ustruct.h
if test 2568 -ne `wc -c <ustruct.h`; then
    echo shar: \"ustruct.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f whoj.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"whoj.c\"
else
echo shar: Extracting \"whoj.c\" \(2769 characters\)
sed "s/^X//" >whoj.c <<'END_OF_whoj.c'
X/*
X * whoj.c -- whoj style output for finger
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: whoj.c,v 3.0 90/07/06 13:12:21 budd Rel $";
X# endif /* lint not defined */
X
X# include <sys/types.h>
X# include <stdio.h>
X# include "output.h"
X# include "args.h"			/* for luser.h */
X# include "luser.h"
X# include "finger.h"
X# include "pr.h"
X
Xextern LUSER *maketree();		/* from getent.c */
Xextern struct pr *getcommand();		/* from getcommand.c */
Xextern char *gtname();			/* from XXX */
Xextern void ptree();			/* from XXX */
X
Xstatic int whoj_termw;			/* whoj terminal name width */
Xstatic int whoj_userw;			/* whoj user name width */
Xstatic time_t now;			/* current time */
X
XLOCAL void whojwidth();			/* forward */
XLOCAL void whojuser();			/* forward */
X
XGLOBAL void dowhoj() {
X    LUSER *t;
X
X    time( &now );			/* get current time */
X    t = maketree();			/* build tree of utmp entries */
X    whoj_termw = whoj_userw = -1;
X    ptree( t, whojwidth );		/* figure widths */
X    ptree( t, whojuser );		/* print tree */
X} /* whoj */
X
XLOCAL int max(a, b)
Xint a, b;
X{
X    if( a > b )
X	return( a );
X    else
X        return( b );
X} /* max */
X
XLOCAL void whojwidth( u )
XLUSER *u;
X{
X    char *tn;
X    int tnl;
X
X    if( u->u_host[0] == EOS ) {		/* no host? */
X	tn = gtname( u->u_line );	/* remove tty from line name */
X	tnl = strlen( tn );
X	if( tn != u->u_line )		/* it did? */
X	    tnl++;			/* yes, add back a 't' */
X    }
X    else {
X	undomain( u->u_host, TRUE ); 	/* remove domains and prefixes */
X        tnl = strlen( u->u_host );
X    }
X
X    whoj_termw = max( tnl, whoj_termw );
X    whoj_userw = max( strlen( u->u_user ), whoj_userw );
X} /* whojwidth */
X
XLOCAL void whojuser( u )
XLUSER *u;
X{
X    struct pr *pr;
X    char line[MAXLINE],			/* output line */
X    	*tn,				/* return from gtname */
X    	tname[20],			/* terminal name to output */
X        *cmd;				/* command to output */
X
X    line[0] = EOS;
X    if( u->u_host[0] == EOS ) {
X	tn = gtname( u->u_line );
X	if( tn != u->u_line ) {
X	    tname[0] = 't';
X	    strcpy(&tname[1], tn);
X	    tn = tname;
X	}
X    }
X    else
X        tn = u->u_host;
X
X    termstat( u );			/* needed for getcommand */
X    pr = getcommand( u );
X    if( pr != NULL )
X	cmd = pr->pr_cmd;
X    else
X	cmd = "?";
X
X    sprintf(line,
X	    "%*s  %*s  %s",
X	    -whoj_termw,
X	    tn,
X	    -whoj_userw,
X	    u->u_user,
X	    cmd
X	    );
X    outline(line);
X} /* whojuser */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_whoj.c
if test 2769 -ne `wc -c <whoj.c`; then
    echo shar: \"whoj.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 2 \(of 7\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

