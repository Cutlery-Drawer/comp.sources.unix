Newsgroups: comp.sources.unix
From: phil@Shiva.COM (Phil Budne)
Subject: v25i166: finger - Phil's Finger Program, Part03/07
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: phil@Shiva.COM (Phil Budne)
Posting-Number: Volume 25, Issue 166
Archive-Name: finger/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 7)."
# Contents:  Install.cpp MANIFEST comdef.c doremote.c finger.1 getent.c
#   mcheck.c read_vmunix.c ttylocfile.c undomain.c
# Wrapped by budd@bu-it on Fri Jul  6 13:22:01 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Install.cpp -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Install.cpp\"
else
echo shar: Extracting \"Install.cpp\" \(4755 characters\)
sed "s/^X//" >Install.cpp <<'END_OF_Install.cpp'
X/*
X * Copyright (C) 1988, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X */
X
X/*
X * $Id: Install.cpp,v 3.0 90/07/06 13:09:49 budd Rel $
X */
X
X# include "local.h"
X
X# ifdef USG
XCHOWN=/bin/chown
X# else  /* USG not defined */
XCHOWN=/etc/chown
X# endif /* USG not defined */
X
X/* ttyloc program runs setuid */
XTTYLOCOWN=daemon
X
X/*fingerd must have this path built in (see FINGERPATHS in fingerd.c/local.h)*/
XDEST=/usr/local/bin
X
X/* you might change this to '1' if you don't have/use manl (local) */
XMANSEC='l'
X/* base for man files */
XMAND=/usr/man
X
X/* saved nlist file (finger needs to be in kmem group under 4.3) */
X# ifdef KMEM_GROUP
XNLISTGRP=KMEM_GROUP
X# else  /* KMEM_GROUP not defined */
XNLISTGRP=daemon
X# endif /* KMEM_GROUP not defined */
X
X# ifdef SAVED_NLIST
XNFILE=SAVED_NLIST
X# else  /* SAVED_NLIST not defined */
XNFILE=/etc/finger-saved-nlist
X# endif /* SAVED_NLIST not defined */
X
X# ifdef NLIST_MODE
XNFILEMODE=NLIST_MODE
X# else  /* NLIST_MODE not defined */
XNFILEMODE=664
X# endif /* NLIST_MODE not defined */
X
X# ifdef sun
XFINGERDDEST=/usr/etc/in.fingerd
XFINGERDSOURCE=in.fingerd
X# if SunOS < 400
XINETDCONF=/etc/servers
X# else  /* not SunOS < 400 */
XINETDCONF=/etc/inetd.conf
X# endif /* not SunOS < 400 */
X# else  /* sun not defined */
X# ifdef sgi
XFINGERDDEST=/usr/etc/fingerd
XFINGERDSOURCE=fingerd
XINETDCONF=/usr/etc/inetd.conf
X# else  /* sgi not defined */
XFINGERDDEST=/etc/fingerd
XFINGERDSOURCE=fingerd
X# ifdef INETD
XINETDCONF=/etc/inetd.conf
X# endif /* INETD defined */
X# endif /* sgi not defined */
X# endif /* sun not defined */
X
X# ifdef sgi
X/* what about other USG systems? */
XUCBDIR=/usr/bsd
X# else  /* sgi not defined */
XUCBDIR=/usr/ucb
X# endif /* sgi not defined */
X
Xecho binary dir is $DEST finger setgid $NLISTGRP
Xecho manual pages to $MAND section $MANSEC
Xecho saved namelist is $NFILE group $NLISTGRP mode $NFILEMODE
Xecho ttyloc dir is TTYLOC_DIR owner $TTYLOCOWN files mode TTYLOC_MODE
Xecho $FINGERDSOURCE to $FINGERDDEST
Xecho ''
Xecho "Type RETURN to continue"
Xread FOOBAR
X
X/* flush groty versions */
Xif [ -r $UCBDIR/finger ]; then
X	echo moving $UCBDIR/finger to $UCBDIR/ofinger
X	mv $UCBDIR/finger $UCBDIR/ofinger
Xfi
Xif [ -r $UCBDIR/f ]; then
X	echo moving $UCBDIR/f to $UCBDIR/of
X	mv $UCBDIR/f $UCBDIR/of
Xfi
Xif [ -r $UCBDIR/whois ]; then
X	echo moving $UCBDIR/whois to $UCBDIR/nicname
X	mv $UCBDIR/whois $UCBDIR/nicname
Xfi
X
Xecho ''
Xecho installing $DEST/finger setgid $NLISTGRP
Xcp xf $DEST/finger
X# ifndef NOSTRIP
Xstrip $DEST/finger
X# endif /* NOSTRIP not defined */
Xchgrp $NLISTGRP $DEST/finger
Xchmod 2711 $DEST/finger
Xls -lg $DEST/finger
X
Xfor x in whois whoj f; do
X	if [ ! -r $DEST/$x ]; then
X		echo linking $DEST/$x to $DEST/finger
X		(cd $DEST; ln -s finger $x)
X	fi
X	ls -l $DEST/$x
Xdone
X
Xecho ''
Xif [ ! -r $NFILE ]; then
X	echo creating empty $NFILE
X	touch $NFILE
Xfi
Xchgrp $NLISTGRP $NFILE
Xchmod $NFILEMODE $NFILE
Xls -lg $NFILE
X
Xecho ''
Xecho installing $FINGERDSOURCE as $FINGERDDEST
Xcp $FINGERDSOURCE $FINGERDDEST
X# ifndef NOSTRIP
Xstrip $FINGERDDEST
X# endif /* NOSTRIP not defined */
X# ifdef INETD
Xecho "Checking $INETDCONF"
Xif grep finger $INETDCONF; then
X	true;
Xelse
X	echo "Perhaps you should to edit $INETDCONF"
Xfi
X# else  /* INETD not defined */
Xecho "Checking /etc/rc files"
Xif grep /etc/fingerd /etc/rc*; then
X	true;
Xelse
X	echo "You might want to start fingerd from /etc/rc.local"
Xfi
X# endif /* INETD not defined */
X
Xecho ''
Xecho installing $DEST/ttyloc setuid $TTYLOCOWN
Xcp ttyloc $DEST
X# ifndef NOSTRIP
Xstrip $DEST/ttyloc
X# endif /* NOSTRIP not defined */
X$CHOWN $TTYLOCOWN $DEST/ttyloc
Xchmod 4711 $DEST/ttyloc
Xls -lg $DEST/ttyloc
X
Xecho ''
Xecho installing $DEST/ttyask
Xcp ttyask $DEST
X# ifndef NOSTRIP
Xstrip $DEST/ttyask
X# endif /* NOSTRIP not defined */
X(
X    cd $DEST
X    ls -lg ttyask
X    for x in ttyplace ttyroom ttyrandom ttycycle; do
X	rm -f $x
X	echo linking $x to ttyask
X	ln -s ttyask $x
X	ls -l $x
X    done
X)
X
X# ifdef TTYLOC_DIR
Xecho ''
Xif [ ! -d TTYLOC_DIR ]; then
X	echo creating TTYLOC_DIR
X	mkdir TTYLOC_DIR
Xfi
X$CHOWN $TTYLOCOWN TTYLOC_DIR
Xls -lgd TTYLOC_DIR
X# else  /* TTYLOC_DIR not defined */
Xecho 'TTYLOC_DIR not defined in local.h!!' 1>&2
X# endif /* TTYLOC_DIR not defined */
X
X# ifdef USG
Xecho ''
Xecho installing man uptime in $UCBDIR/uptime
Xcp uptime $UDBDIR/uptime
X# endif /* USG defined */
X
Xecho ''
Xecho installing man pages
Xcp finger.1	$MAND/man$MANSEC/finger.$MANSEC
Xcp ttyloc.1	$MAND/man$MANSEC/ttyloc.$MANSEC
Xcp nttyloc.5	$MAND/man5
Xcp finger.conf.5 $MAND/man5
Xcp fingerd.8c	$MAND/man8
X
Xecho ''
Xecho 'taking it out for a spin!'
X$DEST/finger
END_OF_Install.cpp
if test 4755 -ne `wc -c <Install.cpp`; then
    echo shar: \"Install.cpp\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f MANIFEST -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"MANIFEST\"
else
echo shar: Extracting \"MANIFEST\" \(6086 characters\)
sed "s/^X//" >MANIFEST <<'END_OF_MANIFEST'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X COMDEFALL                 1	Run all files thru comdef
X COPYING                   6	Copying conditions (GNU General Public Licence)
X COPYRIGHT                 1	Copyright as it appears in C files
X COUNT                     1	Shell script to count TODO and WISHES
X Cover                     1	Cover letter
X DIFFALL                   1	Run diff for all .orig files (see ORIG)
X Distfile                  1	Distfile for local testing
X FINDDEFS                  1	Shell script to local defined symbols
X History.h                 7	Revision history, version number
X Install.cpp               3	Cpp input for installation shell script
X MANIFEST                  3	This file
X MODES                     1	Emacs Local modes for bottom of new files
X Makefile                  2	Master Makefile
X ORIG                      1	Shell script to save files before edit
X README                    1	Documentation
X SAMPLE-conf               1	Sample finger.conf file
X SAMPLE-flags              1	Sample local-flags file
X SAMPLE-local.h            2	Sample local.h file
X SAMPLE-nttyloc            1	Sample /etc/nttyloc file
X TODO                      2	Things that "should" be done
X VERSION                   1	Version of this KIT
X WISHES                    1	Things that "could" be done
X args.c                    5	Argument processor. main is here.
X args.h                    2	Argument definitions
X autoconfig                5	Creates local.h from thin air
X cc-M                      1	Cheap substitute for cc's without -M flag
X checkmode.c               2	Check file modes for autoconfig
X comdef.c                  3	Automagic utility to comment #else and #endifs
X conf.c                    4	Read finger.conf file
X daemon.c                  2	list of interesting daemon parent names/titles
X daemon.h                  1	struct daemon for daemon.c
X defs.awk                  1	Awk program for FINDDEFS
X doremote.c                3	Connect to remote fingerds with TCP
X finger.1                  3	Finger Man page
X finger.c                  6	Output formatting. main is in args.c
X finger.conf.5             2	Manual page for finger.conf file
X finger.h                  2	General definitions for all programs
X fingerd.8c                1	Manual page for finger daemon
X fingerd.c                 6	Finger daemon (for inetd or stand alone use)
X getcommand.c              6	Much terrible wizardry here
X getent.c                  3	Scan utmp entries to create LUSERs
X getgroup.c                1	Report file GID for autoconfig script
X getperson.c               5	Create PERSONal information structs
X getttyloc.c               7	Cons up console location
X getttytype.c              2	Get ttytype (/etc/ttytype or via getttyent())
X getut.c                   2	Logic to read /etc/utmp file
X global.c                  1	Global variables
X hungry                    1	Directory for hungry stuff
X hungry/README             1	hungry README
X hungry/hungry.1c          1	hungry man page
X hungry/hungry.c           1	hungry program
X hungry/hungry.h           1	hungry defns
X hungry/rwho-changes       1	changes for rwho
X hungry/rwho.1c-changes    1	changes for rwho man page
X hungry/rwhod-changes      1	changes for rwhod
X inet_netof.c              1	
X inet_ntoa.c               1	
X info.h                    1	Structure of saved namelist file
X inquire.c                 1	Logic to read inquire database(s) for person.c
X inquire.h                 1	More inquire help.
X kmem.c                    2	Routines to open and read mem, kmem, swap
X kmem.h                    1	Defns for kmem.c usage.
X lastlog.c                 2	Read /usr/adm/lastloc (ACK)
X locname.c                 1	Cons up name for ttyloc files (for set/read)
X luser.h                   2	Basic LUSER check
X make-version              1	Create version.c using pversion
X mcheck.c                  3	Check for (new) mail
X myecho.c                  1	Avoid escape expansion by S5 echo commands
X mywhoami.c                1	whoami command for autoconfig
X names.c                   4	Read /vmunix and much more!!
X newmanifest.c             2	Crock to merge MANIFEST and arg list
X nttyloc.5                 2	Man file for nttyloc file
X output.c                  4	Output related routines
X output.h                  1	Output file defn and max line length
X person.h                  1	Per Person information
X pr.h                      1	Per Process information
X pversion.c                1	Print version number using History.h
X read_vmunix.c             3	Just plain awful stuff here.
X readpr.c                  5	Read process table from kernel (ACK!)
X remote.h                  1	Structs for collecting remote objects to finger
X select.c                  4	The envelope please
X skip.c                    1	skip (non)spaces
X string.c                  2	Common string routines
X strings.h                 1	strings.h helper for USG systems
X switch.c                  4	Switch (option) processing
X switch.h                  2	Switch (option) definitions
X symdate.c                 1	Used to create symdate.h from syms.h
X syms.h                    2	Symbols to read from kernel
X tsel.h                    1	Pick a terminal, any terminal
X ttyask.c                  5	Front end for ttyloc
X ttyloc.1                  2	Man page for ttyloc
X ttyloc.c                  2	Set user terminal location
X ttylocfile.c              3	read (n)ttyloc file
X ttylocfile.h              1	defns for ttylocfile.c
X undomain.c                3	Strip domains and prefixes from hosts
X upper.c                   1	Uppercasification table
X upper.h                   1	Uppercasification table extern
X uptime.c                  2	/usr/ucb/uptime for USG systems
X ustruct.c                 5	Awful system dependant code
X ustruct.h                 2	Common defines for users of u/proc structs
X waitstate.h               1	Translations of kernel sleeps
X whois.c                   4	Output formatting big time
X whoj.c                    2	Quickie output formatting
X ymakefile                 4	Real makefile.
END_OF_MANIFEST
if test 6086 -ne `wc -c <MANIFEST`; then
    echo shar: \"MANIFEST\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f comdef.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"comdef.c\"
else
echo shar: Extracting \"comdef.c\" \(5921 characters\)
sed "s/^X//" >comdef.c <<'END_OF_comdef.c'
X/*
X * comdef.c -- comment defines automagicly
X *	esp for nasty ANSI conforming CPPs!
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: comdef.c,v 3.0 90/07/06 13:10:26 budd Rel $";
X# endif /* lint not defined */
X
X# include <stdio.h>
X# include <ctype.h>
X
X/* Should all be runtime options: */
X# define USEDEF				/* check for if(n)def for comments */
X/*# define DEBUG			/* output debug info */
X
X/*
X * the following 4 (PRESERVE_xxx) output "#[s\t]thing" as input if
X * defined.  Otherwise if INDENTATION is defined they will be indented
X * according to depth.  If INDENT_OTHER is defined even includes and
X * defines will be indented (otherwise indented to MIN_INDENT).  if
X * IDENTATION is not defined all output will be indented to
X * MIN_INDENT.
X */
X
X/*# define PRESERVE_BAD			/* preserve indentation on failures */
X/*# define PRESERVE_IF			/* preserve indentation on ifs */
X/*# define PRESERVE_ENDIF		/* preserve indentation on endifs */
X/*# define PRESERVE_OTHER		/* preserve indentation on define... */
X/*# define INDENTATION			/* indent by depth (but not define..)*/
X/*# define INDENT_OTHER			/* indent define/include.. by depth */
X
X# ifndef MIN_INDENT
X# define MIN_INDENT 1
X# endif /* MIN_INDENT not defined */
X
X# define REL(i) ((i)+MIN_INDENT)
X
X# define EOS '\0'
X
X# define MAX 100			/* plenty!! */
Xchar stack[MAX][ 256 ];
Xint flags[MAX];
Xint sp = -1;
X
X# define FL_NOT 01			/* inverse of "condition" */
X# define FL_ELS 02			/* seen else */
X# define FL_DEF 04			/* was ifdef or ifndef */
X
Xmain() {
X    char line[ 1024 ], saved[ 1024 ];
X    register char *cp, *xp, *yp;
X    int ln;
X
X    ln = -1;
X    while( gets( line ) ) {
X	cp = line;
X	ln++;
X
X	while( *cp && isspace( *cp ) )
X	    cp++;
X
X	if( *cp != '#' ) {
X	    puts( line );
X	    continue;
X	}
X	cp++;
X
X	while( *cp && isspace( *cp ) )
X	    cp++;
X
X	xp = cp;
X	while( isalpha( *cp ) )
X	    cp++;
X
X	strcpy( saved, line );		/* sigh */
X	if( *cp != EOS ) {
X	    if( !isspace( *cp ) ) {
X		fprintf( stderr, "%d: bad line: %s\n", ln, line );
X		puts( line );
X		continue;
X	    }
X	    *cp++ = EOS;
X	    while( isspace( *cp ) )
X		cp++;
X	}
X
X# ifdef DEBUG
X	fprintf( stderr, " <<< %s >>>\n", xp );
X# endif /* DEBUG defined */
X	if( strncmp( xp, "if", 2 ) == 0 || strcmp( xp, "elif" ) == 0 ) {
X	    if( strcmp( xp, "elif" ) != 0 )
X		sp++;
X# ifdef PRESERVE_IF
X	    puts( saved );
X# else  /* PRESERVE_IF not defined */
X	    putit( REL(sp), xp );
X	    putchar(' ');
X	    puts( cp );
X# endif /* PRESERVE_IF not defined */
X
X	    if( sp == MAX )
X		fprintf( stderr, "%d: Beyond MAX", ln );
X	    else {
X		yp = cp;
X		while( *cp != EOS )
X		    if( *cp == '/' && cp[1] == '*' ) {
X			while( isspace( cp[-1] ) && cp >= yp )
X			    cp--;
X			*cp = EOS;
X			break;
X		    }
X		    else
X			cp++;
X# ifdef DEBUG
X		fprintf( stderr, "saving: %s\n", yp );
X# endif /* DEBUG defined */
X		strcpy( stack[sp], yp );
X		flags[sp] = 0;
X
X		/* check for !exp ???!! */
X		if( strcmp( xp, "ifndef" ) == 0 ) {
X		    flags[sp] |= FL_NOT;
X# ifdef USEDEF
X		    flags[sp] |= FL_DEF;
X# endif /* USEDEF defined */
X		}
X# ifdef USEDEF
X		else if( strcmp( xp, "ifdef" ) == 0 )
X		    flags[sp] |= FL_DEF;
X# endif /* USEDEF defined */
X	    }
X	}
X	else if( strcmp( xp, "else" ) == 0 ) {
X	    if( sp < 0 ) {
X		fprintf( stderr, "%d: else not under if\n", ln );
X# ifdef PRESERVE_BAD
X		puts( saved );
X# else  /* PRESERVE_BAD not defined */
X		putit( REL(sp), "else" );
X		putchar('\n');
X# endif /* PRESERVE_BAD not defined */
X	    }
X	    else {
X		flags[sp] ^= FL_NOT;	/* invert not-ness */
X		if( flags[sp] & FL_ELS )
X		    fprintf( stderr, "double else for %s at line %d????\n",
X			    stack[ sp ], ln );
X# ifdef PRESERVE_BAD
X		fputs( line, stdout );
X# else  /* PRESERVE_BAD not defined */
X		putit( REL(sp), "else" );
X# endif /* PRESERVE_BAD not defined */
X		/* extra space to match indent on endif */
X		putchar( ' ' );
X		comment(sp);
X	    }
X	}
X	else if( strcmp( xp, "endif" ) == 0 ) {
X	    if( sp >= MAX || sp < 0 ) {
X		if( sp < 0 )
X		    fprintf( stderr, "%d: Too many endifs\n", ln );
X# ifdef PRESERVE_BAD
X		puts( saved );
X# else  /* PRESERVE_BAD not defined */
X		putit( REL(sp), "endif");
X		putchar('\n');
X# endif /* PRESERVE_BAD not defined */
X	    } /* bad sp */
X	    else {
X# ifdef PRESERVE_ENDIF
X		fputs( line, stdout );
X# else  /* PRESERVE_ENDIF not defined */
X		putit( REL(sp), "endif" );
X# endif /* PRESERVE_ENDIF not defined */
X		comment(sp+1);		/* decr in wrong place for indenting */
X	    } /* ok sp */
X	    sp--;
X	} /* found endif */
X	else {				/* found something else */
X# ifdef PRESERVE_OTHER
X	    puts( saved );		/* define, include, or something... */
X# else  /* PRESERVE_OTHER not defined */
X# ifdef INDENT_OTHER
X	    putit( REL(sp+1), xp );
X# else  /* INDENT_OTHER not defined */
X	    putit( MIN_INDENT, xp );
X# endif /* INDENT_OTHER not defined */
X	    putchar(' ');
X	    puts( cp );
X# endif /* PRESERVE_OTHER not defined */
X	} /* define, include ... */
X    } /* while */
X} /* main */
X
Xputit( off, s )
X    register off;
X    char *s;
X{
X# ifdef DEBUG
X    fprintf( stderr, "level %d off %d putit: %s\n", sp, off, s );
X# endif /* DEBUG defined */
X
X    putchar('#');
X
X# ifdef INDENTATION
X    if( off < MIN_INDENT )
X# endif /* INDENTATION defined */
X	off = MIN_INDENT;
X
X    while( off-- > 0 )
X	putchar(' ');
X
X    fputs( s, stdout );
X}
X
Xcomment() {				/* comment elses and endif */
X    fputs(" /* ", stdout );
X    if( (flags[sp] & FL_DEF) == 0 && (flags[sp] & FL_NOT) )
X	fputs("not ", stdout );
X
X    fputs( stack[sp], stdout );
X    if( flags[sp] & FL_DEF )
X	if( flags[sp] & FL_NOT )
X	    fputs(" not defined", stdout );
X	else
X	    fputs(" defined", stdout );
X    puts( " */" );
X} /* comment */
END_OF_comdef.c
if test 5921 -ne `wc -c <comdef.c`; then
    echo shar: \"comdef.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f doremote.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"doremote.c\"
else
echo shar: Extracting \"doremote.c\" \(5687 characters\)
sed "s/^X//" >doremote.c <<'END_OF_doremote.c'
X/*
X * doremote.c -- contact remote hosts for finger
X *
X * Copyright (c) 1986, 1990  Barry Z. Shein and Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X */
X
X/*
X *	Barry Shein, Boston University
X *		routine to attach to remote finger server
X *		addition to finger.c
X *
X *	Adapted to new finger; Phil Budne, Boston University
X *
X *	Conforms (as much as I can tell) to RFC742
X *	[which is a pretty liberal document]
X *
X *	Note: Not all finger daemons support multiple requests.
X *	According to my reading of the RFC this is allowed, the
X *	correct format (which we use here) is name,name,name\r\n
X */
X
X
X# ifndef lint
Xstatic char *rcsid = "$Id: doremote.c,v 3.0 90/07/06 13:10:32 budd Rel $";
X# endif /* lint not defined */
X
X# include <sys/types.h>
X# include <netinet/in.h>
X# include <sys/socket.h>
X# include <strings.h>
X# include <netdb.h>
X# include <ctype.h>
X# include <stdio.h>
X
X# include "remote.h"
X# include "args.h"
X# include "finger.h"
X
X# define SERVICE "finger"
X# define PROTOCOL "tcp"
X
Xextern char *inet_ntoa();		/* from library */
X
XFORWARD LOCAL void prhost();
X
X# ifndef DEF_PORT
X# ifdef IPPORT_FINGER
X# define DEF_PORT IPPORT_FINGER 
X# else  /* IPPORT_FINGER not defined */
X# define DEF_PORT 79
X# endif /* IPPORT_FINGER not defined */
X# endif /* DEF_PORT not defined */
X
XLOCAL short port;
XGLOBAL void
Xdoremote( hosts )
XRHOST *hosts;
X{
X    register char *cp;
X    struct servent *sp;
X    struct hostent *hp;
X    RUSER *rup;
X
X    if( hosts == NULL )
X	return;
X
X    if((sp = getservbyname(SERVICE,PROTOCOL)) == NULL)
X	port = htons( DEF_PORT );
X    else
X	port = sp->s_port;
X
X    /* loop for all host names */
X    for( ; hosts != NULL ; hosts = hosts->rh_next ) {
X
X	cp = hosts->rh_name;			/* get host 'name' */
X	rup = hosts->rh_user;			/* get pointer to user chain */
X
X	/* handle internet numeric format */
X	if( isdigit( *cp ) ) {
X	    struct in_addr haddr;
X	    char temp[ 128 ];
X
X	    haddr.s_addr = inet_addr( cp ); /* get address */
X
X	    /* try to get name for address */
X	    if((hp = gethostbyaddr(&haddr, sizeof(haddr), AF_INET)) == NULL ) {
X		if( net_host( temp, haddr ) )	/* failed, try network name */
X		    prhost( temp );
X		else				/* total lossage */
X		    prhost( inet_ntoa( haddr ) ); /* reformat!! */
X						/* ie; 10.4 -> 10.0.0.4 */
X		tryaddr( &haddr, rup );		/* try just given addr */
X		continue;			/* next host */
X	    }
X# ifdef JUST_ADDR_GIVEN
X	    prhost( hp->h_name );		/* official name */
X	    tryaddr( &haddr, rup );
X	    continue;				/* next host */
X# endif /* JUST_ADDR_GIVEN defined */
X	} /* given number */
X	else if( (hp = gethostbyname(cp)) == NULL ) {
X	    /* try other networks here?! */
X
X# ifdef HAVE_H_ERRNO
X	    extern int h_errno, h_nerr;
X	    extern char *h_errlist[];
X
X	    if( h_errno > 0 && h_errno <= h_nerr )
X		fprintf(stderr,"%%%s: %s\n", h_errlist[h_errno], cp );
X	    else
X# endif /* HAVE_H_ERRNO defined */
X		fprintf(stderr,"%%Unknown host: %s\n", cp );
X	    continue;				/* next host */
X	} /* hostbyname failed */
X
X	prhost( hp->h_name );		/* show official name */
X# ifdef h_addr
X	if( hp->h_addr_list != NULL ) {
X	    struct in_addr **lp;
X
X	    for( lp = (struct in_addr **)hp->h_addr_list; *lp != NULL; lp++ ) {
X		/* Trying... used to be here */
X		if( tryaddr( *lp, rup ) )
X		    break;
X	    } /* for each address */
X	} /* have address list */
X	else
X	    fprintf(stderr,"%%No addresses?\n"); /* should get h_errno set! */
X# else  /* h_addr not defined */
X	tryaddr( hp->h_addr, rup );
X# endif /* h_addr not defined */
X    } /* for each host */
X} /* doremote*/
X
Xint
Xtryaddr( addr, rup )
X    struct in_addr *addr;
X    register RUSER *rup;
X{
X    char buf[BUFSIZ+1], *cp;
X    struct sockaddr_in sin;		/* so much for protcol independance */
X    FILE *f;
X    int s;
X
X    if( (s = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
X	perror("socket");
X	return( FALSE );
X    } /* socket failed */
X
X    bzero( (char *) &sin, sizeof( sin ) );
X    bcopy( (char *) addr, (char *) &sin.sin_addr, sizeof( sin.sin_addr ) );
X    sin.sin_family = AF_INET;
X    sin.sin_port = port;
X
X# ifndef DONT_SAY_TRYING
X    /* show all non-local addrs? */
X    /* only show if multi-homed */
X    /* only show address on error w/ multi-homed host? */
X    printf("Trying %s...\n", inet_ntoa(*addr) );
X# endif /* DONT_SAY_TRYING not defined */
X
X    if( connect( s, (char *) &sin, sizeof( sin ) ) < 0 ) {
X	perror("connect");
X	close(s);
X	return( FALSE );
X    }
X
X    /*
X     *	Build into one buffer for the host
X     *	terminate with CR-LF
X     */
X
X    buf[0] = EOS;
X    if( sw_whois )
X	strcat(buf," /w ");
X
X    while( rup != NULL ) {
X	strcat(buf,rup->ru_name) ;
X	if( (rup = rup->ru_next) != NULL )
X	    strcat(buf,",");
X    } /* while rup */
X
X    strcat(buf,"\r\n") ;
X    /*
X     *	Send request
X     */
X    if( write(s, buf, strlen( buf ) ) < 0 ) {
X	perror("write");
X	close(s);
X	return( FALSE );
X    }
X
X    /*
X     *	Read and display result
X     */
X    f = fdopen(s, "r");
X    while( fgets(buf, BUFSIZ, f) != NULL ) {
X	/* blast \r as well? */
X	if( (cp = index( buf, '\n' )) != NULL )	/* strip newlines */
X	    *cp = EOS;
X	outline( buf );				/* output as much as will fit */
X    } /* while */
X    fclose( f );
X    return( TRUE );
X} /* doremote */
X
XLOCAL void
Xprhost( name )
Xchar *name;
X{
X    char buf[255];
X
X    blankline();
X    sprintf(buf, "[%s]", name); 	/* format string */
X    outline( HZUP(buf) );		/* output it (upper cased) */
X    fflush( stdout );
X} /* prhost */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_doremote.c
if test 5687 -ne `wc -c <doremote.c`; then
    echo shar: \"doremote.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f finger.1 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"finger.1\"
else
echo shar: Extracting \"finger.1\" \(6690 characters\)
sed "s/^X//" >finger.1 <<'END_OF_finger.1'
X.\" -*-nroff-*-
X.\" $Id: finger.1,v 3.0 90/07/06 13:10:33 budd Rel $
X.\" Copyright (c) 1987, 1990  Philip L. Budne
X.TH FINGER local "31 January 1990"
X.UC 4
X.SH NAME
Xf, finger, whois, whoj \- who are you, and what are you doing on my system
X.SH SYNOPSIS
X.B finger
X[
X.I /switch -switch +tty . user name @host name@host
X]
X
X.B whois
X[
X.I /switch -switch +tty . user name @host name@host
X]
X
X.B whoj
X
X.SH DESCRIPTION
X.I Finger
Xoutput contains the following information: Username, full name,
Xprogram, idle time, biff/hunger state, tty name, write
Xpermission, and terminal location.  If program (current process)
Xis running
X.IR setuid (2)
Xas the super user, a plus (+) will be appended to the program.  If it
Xis
X.IR setuid (2)
Xto some other user an exclamation mark (!) will be appended.  Biff on
Xis signified by a period before the tty name, hunger by a comma, both
Xby a semi-colon.  No write permission (mesg n) is flagged by an
Xasterisk after the tty name.  If a user who is not logged in is
Xspecified the time and line (or host) of last login are displayed,
Xalong with the user's plan and mail file status.
X.PP
X.I Whois
Xis an alias for
X.I finger -whois.
XThis format is multi-line, and includes all the information described
Xabove as well as the user's user id, group id, home directory, login
Xshell and groups, any plan which the person has placed in the file
X.I \&.plan
Xin their home directory, and the project on which they are working
Xfrom the file
X.I \&.project
Xalso in the home directory. If the local system has an
X.I inquire
Xdatabase more information will be displayed.
X.PP
X.I Whoj
Xis an alias for
X.I finger -whoj
Xthat displays only the terminal (or host name), user name, and program.
X.PP
XThe arguments accepted by
X.I finger
Xcan be one of: a user name, a personal name (first or last) from the
Xpassword file or inquire database, a switch (starting with - or /), a
Xterminal specification (+tty0d and +0d both mean the user on
X/dev/tty0d, +tty0 matches /dev/tty0*), a period (specifies the user on
Xthe stdin terminal) or a remote specification user@host. If no user is
Xspecified
X.I (finger @host)
Xthen everyone is displayed.  You can also use
X.I finger user@host@host
Xto accomplish a primitive routing.  The only option passed to remote
Xsystems is
X.B /w
Xas per RFC782.  However a backslash (two are needed to get past the
Xshell) can be used to prevent local interpretation of a flag
X.I "finger \e\e-w"
Xfingers the user
X.IR -w !
Xand
X.I "finger \e\e-v@bu-it.bu.edu"
Xfinds what version of finger bu-it.bu.edu is running.
X.PP
X.I Finger
Xand
X.I whois
Xoptions include:
X.PP
X.TP 15
X.B /age
XReplace idle time with user connect time.
X.TP 15
X.B /berkeley
Ximitate BSD
X.I finger
X(usernames imply
X.BR /whois/plan )
X.TP 15
X.B /follow
Xfollow
X.I \.forward
Xfiles onto other hosts (let
X.I finger
Xdo the walking!!)
X.TP 15
X.B /help
Xdisplay short help message.
X.TP 15
X.B /its
Xoutput date and time more like the MIT ITS NAME program.  Changes
X-What- header to Jobnam.
X.TP 15
X.B /location
XIgnore user set ttyloc.
X.TP 15
X.B /mail-check
XTalk about age of mail file (by default mail information is only
Xprinted for logged out users), and mail forwarding.
X.TP 15
X.B /noinquire
XDo not consult the inquire database (if present).
X.TP 15
X.B /noplan
XDo not display .plan files ever (by default .plan files are shown for
Xusers matched by name but not logged in).
X.TP 15
X.B /nosave-nlist
XProhibit rewriting
X.I /etc/finger-saved-nlist.
XIf
X.I finger
Xis invoked as
X.I xf
Xthis is on by default.
X.TP 15
X.B /output-idle
XShow idle time since last output to terminal.
X.TP 15
X.B /plan-check
XForce printing of plan files for all users displayed (by default plans
Xare only printed for logged out users matched by name).
X.TP 15
X.B /pid
XDisplay pid of "current" process.
X.TP 15
X.B /read-nlist
XForce read of
X.I /vmunix
Xnamelist.
X.TP 15
X.B /short
XGive
X.I whoj
X(extra short format) output. Also
X.B /whoj.
X.TP 15
X.B /user-match
XMatch arguments only on user name. Also
X.B /match-user.
X.TP 15
X.B /version
XDisplay version and build information.
X.TP 15
X.B /whois
XGive
X.I whois
X(personal information) output. Implies
X.B /mail.
X.PP
XSome options are
X.I per-user
Xif they appear
X.B directly
Xafter a user (with no intervening spaces). For example;
X.br
X.I "finger tower/match budne"
Xshows only user
X.I tower
Xbut shows all users with last name budne.  The following options are
Xper-user:
X.BR location ,
X.BR mail ,
X.BR match ,
X.BR noplan ,
X.BR plan .
X
X.PP
XIt is possible to set up psuedo-users which are programs run instead
Xof the normal
X.I finger.
XThese have the string "RC" (exactly) in their GECOS field. Finger
Xchanges to their 'home' directory and expects there to be a program
Xwith the same name as the user. For example:
X
X.ce 1
Xuusnap:(*none*):1000:1000:RC:/usr/bin: 
X
X.PP
XWill cause
X.I finger lpq
Xto display the line printer queue rather than the normal
X.I finger
Xlisting.  This is particularly useful for remote machines (eg.
X.IR "finger uusnap@bu.edu" )
XBefore running the program
X.I finger
Xwill
X.IR setuid (2)
Xand
X.IR setgid (2)
Xto the psuedo-user's uid and group.
X.PP
X.SH FILES
X.ta 1.8i
X.nf
X/etc/utmp	who file
X/etc/passwd	for user names, offices
X/etc/nttyloc	for per-line system default ttylocs (new format)
X/etc/ttyloc	for per-line system default ttylocs (old format)
X/etc/ttys	Used under BSD 4.3 as last ditch for location
X/etc/ttytab	Used under SunOS 4 as last ditch for location
X/usr/adm/lastlog	last login times
X/usr/spool/mail	user mail files
X/usr/spool/ttyloc	user set ttyloc files
X~user/.forward	user mail address
X~user/.project	user projects
X~user/.plan	user plans
X.fi
X.ta
X.SH "SEE ALSO"
X.IR w (1),
X.IR who (1),
X.IR mesg (1),
X.IR hungry (1),
X.IR ttyloc (1),
X.IR nttyloc (5),
X.IR passwd (5),
X.IR utmp (5),
X.IR fingerd (8c)
X.SH AUTHOR
XPhilip L. Budne
X.SH BUGS
XShould show last
X.RB log out
Xtime, but there is no easy way to obtain it.
X.PP
XThis is even more of a pain in an NFS cluster, since each server and
Xclient maintain their own lastlog file.  What should be done is to
Xmodify
X.IR init (8), rlogind (8c),
Xand
X.IR telnetd (8c)
Xto write into a common (NFS) file containing login, logout, and host.
XAnother tact would be to have
X.IR login (1)
Xfork your shell, wait for exit and then write logout time.  Perhaps
Xlast logout should be added to the
X.I inquire
Xdatabase.
X.PP
XWhile
X.I finger
Xendeavors to show the correct program (it does better than
X.IR w (1)
Xby looking at process groups) it can fail.  Users of
X.IR sh (1)
Xmay have the most recent (highest numbered pid) fork displayed (ie;
X.IR more (1)
Xwill show up instead of the program which forked it.)
X.PP
XUnder Encore UMAX this will happen to csh users too if they user set
X.I mesg n
X(must be open the terminal for write in order to determine the
Xterminal process group number).
END_OF_finger.1
if test 6690 -ne `wc -c <finger.1`; then
    echo shar: \"finger.1\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f getent.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"getent.c\"
else
echo shar: Extracting \"getent.c\" \(4976 characters\)
sed "s/^X//" >getent.c <<'END_OF_getent.c'
X/*
X * getent.c -- build local user tree for finger
X * It all started here.. (November 1985)
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: getent.c,v 3.0 90/07/06 13:10:48 budd Rel $";
X# endif /* lint not defined */
X
X# include <sys/types.h>
X# include <utmp.h>
X# include <stdio.h>
X# include <ctype.h>
X# include "person.h"
X# include "args.h"			/* for luser.h */
X# include "luser.h"
X# include "tsel.h"
X# include "finger.h"
X
Xextern struct utmp *getutent();		/* from utmp.c */
Xextern endutent();			/* from utmp.c */
Xextern LUSER *treefind();		/* from getperson.c */
X
XFORWARD GLOBAL LUSER *linsert();
XFORWARD LOCAL  LUSER *mkluser();
X
XLOCAL TSEL *first_tsel, *last_tsel;
X
X# define LINESIZE sizeof( ((struct utmp *)0)->ut_line )	/* size of ut_line */
X
X/* .see gtname() in output.c */
X# define TTY_PREFIX "tty"
X# define TTY_PREFIX_SIZE (sizeof(TTY_PREFIX)-1)
X
X
XGLOBAL void init_tsel() {
X    first_tsel = last_tsel = NULL;
X}
X
XGLOBAL void addtty( s )
X    char *s;
X{
X    register TSEL *ts;
X    register l, l2;
X    if( (ts = (TSEL *) malloc( sizeof( TSEL ) )) == NULL ) {
X	perror("could not allocate tty selector");
X	exit( 1 );
X    }
X
X    l = l2 = strlen( s );
X    if( l > LINESIZE ) {
X	l = LINESIZE;
X	if( l > LINESIZE - TTY_PREFIX_SIZE )
X	    l2 = l - TTY_PREFIX_SIZE;
X    }
X
X    ts->ts_name = s;
X    ts->ts_len = l;
X    ts->ts_len2 = l2;
X    ts->ts_next = NULL;
X    if( first_tsel == NULL )
X	first_tsel = last_tsel = ts;
X    else {
X	last_tsel->ts_next = ts;
X	last_tsel = ts;
X    }
X}
X
XGLOBAL LTREE *maketree() {		/* create tree of users */
X    register struct utmp *ut;
X    LTREE *tree;
X    LUSER *new;
X
X    tree = NULL;
X
X    while( (ut = getutent()) != NULL ) {
X
X	if( ut->ut_name[0] == EOS )	/* entry has name? */
X 	    continue;			/* no, get next */
X
X	if( first_tsel != NULL ) {
X	    register TSEL *t;
X	    int ok;
X
X	    ok = FALSE;
X	    for( t = first_tsel; t != NULL; t = t->ts_next ) {
X		if( strncmp( ut->ut_line, t->ts_name, t->ts_len ) == 0 ||
X		   (strncmp( ut->ut_line, TTY_PREFIX, TTY_PREFIX_SIZE ) == 0 &&
X		    strncmp( &ut->ut_line[TTY_PREFIX_SIZE],
X			    t->ts_name, t->ts_len2 ) == 0) ){
X		    ok = TRUE;
X		    break;
X		} /* if strncmp */
X	    } /* for */
X	    if( !ok )
X		continue;
X	} /* first_tsel */
X
X	new = mkluser(ut);
X	tree = linsert(new, tree);
X    }
X    endutent();
X    return( tree );
X} /* maketree */
X
XGLOBAL LTREE *linsert(new, tree) 	/* insert new user into tree */
Xregister LUSER *new;
Xregister LTREE *tree;
X{
X    if( tree == NULL )			/* empty tree. return new entry */
X        return( new );
X
X    if( strcmp(new->u_user, tree->u_user) < 0 ) /* less than root? */
X	 tree->u_left = (LUSER *)linsert(new, tree->u_left); /* put on left */
X    else
X         tree->u_right = (LUSER *)linsert(new, tree->u_right);/* put on right */
X					/* dupes are added to right */
X					/* (.see pwtree) because we assume */
X					/* that the utmp file is in tty name */
X					/* order */
X
X    return( tree );			/* return the tree */
X}
X
XGLOBAL LUSER *newluser() {		/* create empty luser struct */
X    register LUSER *new;
X
X    if( (new = (LUSER *)malloc( sizeof( LUSER ) )) == NULL ) {
X	fprintf(stderr, "malloc failed in newluser\n");
X	exit( 1 );
X    }
X    new->u_person = NULL;
X    new->u_left = new->u_right = NULL;
X    new->u_flags = 0;
X    new->u_sw = Sw;			/* get per-person switches */
X    return( new );
X} /* newluser */
X
XLOCAL LUSER *mkluser( ut )		/* create a luser from utmp */
Xregister struct utmp *ut;
X{
X    register LUSER *new;
X
X    new = newluser();
X
X    strzcpy(new->u_user, ut->ut_name, sizeof(ut->ut_name) );
X    strzcpy(new->u_line, ut->ut_line, sizeof(ut->ut_line) );
X# ifndef UTMP_NO_HOST
X    strzcpy(new->u_host, ut->ut_host, sizeof(ut->ut_host) );
X# endif /* UTMP_NO_HOST not defined */
X    new->u_time = ut->ut_time;
X
X    return( new );
X} /* mkluser */
X
X/*
X * here with tree of usernames from command line
X * return new tree of logged in users
X */
X
XGLOBAL LTREE *ent_select( proto )
XLUSER *proto;
X{
X    register struct utmp *ut;
X    char name[ sizeof( ut->ut_name ) + 1 ];
X    LUSER *new, *found;
X    LTREE *t2;
X
X    t2 = NULL;
X
X    while( (ut = getutent()) != NULL ) {
X	if( ut->ut_name[0] == EOS )	/* entry has name? */
X	    continue;			/* no, get next */
X
X	strzcpy( name, ut->ut_name, sizeof( ut->ut_name ) );
X	if( (found = treefind( proto, name )) != NULL ) {
X	    register PERSON *p;
X
X	    found->u_flags |= U_FOUND;
X	    new = mkluser(ut);
X	    p = new->u_person = found->u_person;
X	    if( p != NULL )
X		p->p_count++;
X	    t2 = linsert(new, t2);
X	} /* found template */
X    } /* while utmp */
X    endutent();
X
X    return( t2 );
X} /* ent_select */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_getent.c
if test 4976 -ne `wc -c <getent.c`; then
    echo shar: \"getent.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mcheck.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mcheck.c\"
else
echo shar: Extracting \"mcheck.c\" \(4934 characters\)
sed "s/^X//" >mcheck.c <<'END_OF_mcheck.c'
X/*
X * mcheck.c -- check for mail
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: mcheck.c,v 3.0 90/07/06 13:11:19 budd Rel $";
X# endif /* lint not defined */
X
X# include <sys/types.h>
X# include <sys/stat.h>
X# include <strings.h>
X# include <errno.h>
X# include <stdio.h>
X# include <ctype.h>
X# include "person.h"
X# include "args.h"			/* before luser.h */
X# include "luser.h"
X# include "finger.h"
X
Xextern void add4n();			/* from args.c */
X
X/*
X *	it is possible to detect aliasing by invoking sendmail -bv
X *	<user>. This checks .forward files too!!  but is of little use
X *	when the current host is a workstation or other mail moron
X *	that hands off all work to a server.
X *
X *	"ypmatch <user> aliases" DOES work, but no functions 
X *	are provided to access the mail.alias yp map.  TODO
X */
X
X# define LEN 1024
XGLOBAL void mcheck( u )
XLUSER *u;
X{
X# ifdef MAIL_SPOOL
X    BOOL nomailbox;
X    char fname[LEN];
X    struct stat stb;
X    extern int errno;
X    extern char *sys_errlist[];
X
X# ifdef AIX_PS2
X    if( u->u_person == NULL )
X	return;
X    strcpy(fname, u->u_person->p_home );
X    strcat(fname, "/.newmail");
X# else  /* AIX_PS2 not defined */
X    strcpy(fname, MAIL_SPOOL );
X    strcat(fname, "/");
X    strcat(fname, u->u_user );
X# endif /* AIX_PS2 not defined */
X
X    nomailbox = FALSE;
X    if( stat(fname, &stb) != 0 ) {
X	switch( errno ) {
X        case ENOENT:
X	    nomailbox = TRUE;
X	    break;
X
X	case EPERM:
X	    outline("  [Mail file protected]");
X	    break;
X
X	default:
X	    sprintf(fname, "  [Funny mail file error (%s)]",
X		    sys_errlist[errno] );
X	    outline( fname );
X	} /* switch */
X    } /* stat failed */
X    else {				/* stat ok */
X	if( stb.st_size > 0  &&  stb.st_mtime >= stb.st_atime ) {
X	    sprintf(fname, "  %s has new mail as of %s",
X		    u->u_user, nicetime( stb.st_mtime ) );
X
X	    if( stb.st_atime != stb.st_ctime ) { /* read since created */
X		outline( fname );	/* output previous line */
X		sprintf(fname, "  last read %s", nicetime( stb.st_atime ) );
X	    }
X	}
X	else				/* empty or access after modify */
X	    sprintf(fname, "  %s has no new mail, last read %s",
X		    u->u_user, nicetime( stb.st_atime ) );
X	outline( fname );
X    } /* stat ok */
X
X    if( u->u_person != NULL && u->u_person->p_maddr != NULL ) {
X	sprintf(fname, "  [%s is forwarded to %s]",
X		(nomailbox ? "Mail" : "New mail"),
X		u->u_person->p_maddr );
X	outline( fname );
X    }
X    else if( nomailbox )
X	outline("  [No mail file]");
X# endif /* MAIL_SPOOL defined */
X} /* mcheck */
X
X/**** THIS IS GROSS ****/
X
XGLOBAL void maddr( p, uname )		/* get mailing address */
X    PERSON *p;
X    char *uname;			/* for possible alias hackery */
X{
X    register char *dp, *xp, *ap;
X    char fname[ LEN ], obuf[ LEN*3 ], *sp;
X    int room;
X    FILE *f;
X
X    /* try yp_match( domain, "mail.alias", name, namelen, valp, vallenp ) */
X
X    strcpy( fname, p->p_home );
X    strcat( fname, "/.forward" );
X    f = fopen( fname, "r" );
X    if( f == NULL )
X	return;
X
X    dp = obuf;				/* set dest ptr */
X    room = sizeof( obuf );
X    while( fgets( fname, sizeof( fname ), f ) != NULL ) {
X	sp = fname;			/* set src ptr */
X
X	for( ; ; ) {
X	    if( !skipwhite( &sp ) )	/* eat whitespace */
X		break;			/* nothing left? */
X
X	    /* check for " / | \ */
X	    if( room > 0 &&dp != obuf ) { /* not the first? */
X		*dp++ = ',';
X		room--;
X	    }
X
X	    xp = sp;			/* save start of addr */
X	    while( *sp != EOS && !isspace( *sp ) && *sp != ',' )
X		if( --room > 0 )
X		    *dp++ = *sp++;	/* copy while not white */
X
X	    if( *sp != EOS )		/* if not end of source */
X		*sp++ = EOS;		/* tie off (blast/skip punct) */
X
X	    if( sw_follow ) {
X		if( (ap = rindex( xp, '@' )) != NULL ) /* have a host? */
X		    *ap++ = EOS;	/* tie off host */
X
X		if( *xp == '\\' )	/* backslash quoted username? */
X		    xp++;		/* skip bs */
X
X		if( *xp != '|' && *xp != '/' ) { /* not pipe or file */
X		    char *pp;		/* percent ptr */
X
X		    /* perhaps blast only the rightmost %? */
X		    pp = xp;		/* blast all %'s in user into @'s */
X		    while( (pp = index(pp, '%')) != NULL )
X			*pp++ = '@';
X
X		    if( ap != NULL && !islocalhost(ap) )
X			add4n(savestr(xp), savestr(ap) ); /* user, host */
X		    else if( strcmp( xp, uname ) != 0 ) { /* not me? */
X			struct switches SavedSw;
X			SavedSw = Sw;
X			Sw.sw_match = TRUE;
X			addlocal( savestr(xp) );
X			Sw = SavedSw;
X		    }
X		} /* not pipe or file */
X	    } /* sw_follow */
X	} /* for ever */
X    } /* read ok */
X    *dp = EOS;				/* tie off */
X
X    p->p_maddr = savestr( obuf );	/* fill in person's mailing address */
X
X    close( f );
X} /* maddr */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_mcheck.c
if test 4934 -ne `wc -c <mcheck.c`; then
    echo shar: \"mcheck.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f read_vmunix.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"read_vmunix.c\"
else
echo shar: Extracting \"read_vmunix.c\" \(5605 characters\)
sed "s/^X//" >read_vmunix.c <<'END_OF_read_vmunix.c'
X/*
X * read_vmunix.c -- read data from an a.out file (for kernel _version)
X *	This is just awful!!
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: read_vmunix.c,v 3.0 90/07/06 13:11:37 budd Rel $";
X# endif /* lint not defined */
X
X# include "finger.h"
X# if Umax != 42 && !defined(USG)
X
X# include "args.h"
X# ifndef COFF				/* good old a.out */
X
X# include <a.out.h>
X
X/*
X *	N_SEGSIZ is only needed if the kernel is not an OMAGIC file.
X */
X
X# ifdef sun
X
X# define LMASK 0xfff			/* crock, seems to work tho */
X					/* for Sun2,3,4 */
X/*# define LOADADDR 0xff004000		/* sun4 */
X/*# define LOADADDR 0x0f004000		/* sun3 */
X/*# define LOADADDR     0x4000		/* sun2 */
X# endif /* sun defined */
X
X# ifdef accel
X# define LMASK 0xffff
X# define INCLUDE_HEADERS
X# endif /* accel defined */
X
X# ifndef N_SEGSIZ			/* a sun-ism */
X# include <sys/param.h>			/* get CLBYTES */
X# define N_SEGSIZ(a) (CLBYTES)		/* simulate sun macro */
X# endif /* N_SEGSIZ not defined */
X
X# ifdef vax
X# define LOADADDR 0x80000000		/* kernel load address */
X# endif /* vax defined */
X
X# ifdef ibm032				/* RT under AOS/ACIS 4.3 */
X# define LOADADDR 0xe0000000		/* kernel load address */
X# endif /* ibm032 defined */
X
X# ifdef sony_news			/* only tested for News-800 */
X# define LOADADDR 0x80001000		/* crocked by 4k? */
X# endif /* sony_news defined */
X
X# ifdef sequent				/* only tested for S3 */
X# define LOADADDR 0
X# endif /* sequent defined */
X
XGLOBAL BOOL
Xread_vmunix( file, off, str, len )
Xchar *file;				/* file name */
Xlong off;				/* virtual address */
Xchar *str;				/* dest buffer */
Xint len;				/* chars to read */
X{
X    int f;
X    long pos, base, data, koffset;
X    struct exec ex;
X
X    if( off == 0L )			/* bogus offset */
X	return( FALSE );		/* lose quickly */
X
X    if( (f = open( file, 0 )) < 0 )	/* open /vmunix */
X	return( FALSE );		/* you lose */
X
X    if( read( f, &ex, sizeof( ex ) ) != sizeof( ex ) ) { /* read header */
X	close( f );			/* short read */
X	return( FALSE );		/* quit */
X    }
X
X    base = N_TXTOFF( ex );		/* get start of meaningfullness */
X
X# ifdef LOADADDR
X    koffset = LOADADDR;			/* offset into image */
X# else  /* LOADADDR not defined */
X# ifdef LMASK
X    koffset = ex.a_entry & ~LMASK;
X# else  /* LMASK not defined */
X# include <ERROR: must have one of LOADADDR and LMASK>
X# endif /* LMASK not defined */
X# endif /* LOADADDR not defined */
X
X    off -= koffset;			/* remove kernel offset */
X    if( ex.a_magic == OMAGIC
X# ifdef NMAGIC				/* sequent lacks NMAGIC! */
X       || (off < ex.a_text && ex.a_magic == NMAGIC)
X# endif /* NMAGIC defined */
X# ifdef SMAGIC				/* sequent standalone */
X	|| ex.a_magic == SMAGIC
X# endif /* SMAGIC defined */
X	) /* OMAGIC or NMAGIC text */
X	data = 0;			/* no data offset */
X# ifdef NMAGIC
X    else if( ex.a_magic == NMAGIC ) {	/* NMAGIC data loaded on seg boundry */
X	int segs;			/* segment size */
X	segs = N_SEGSIZ(ex) - 1;	/* round to "segment" after text*/
X	data = (ex.a_text + segs - 1) & ~segs;
X	data -= ex.a_text;		/* just get needed offset */
X    }
X# endif /* NMAGIC defined */
X# ifdef SOME_DAY_OVER_THE_RAINBOW
X    else if( ex.a_magic == ZMAGIC ) {	/* never seen a ZMAGIC kernel!! */
X	base = N_SEGSIZ(ex);		/* text starts on page boundry */
X	if( off >= ex.a_text ) {
X	    /* something like for NMAGIC above... */
X	}
X    } /* ZMAGIC */
X# endif /* SOME_DAY_OVER_THE_RAINBOW defined */
X    else {
X# ifdef DEBUGSW
X 	if( sw_debug )
X	    printf("Unknown %s magic %#x %#o\n", KERNEL_FILE,
X		ex.a_magic, ex.a_magic );
X# endif /* DEBUGSW defined */
X	return( FALSE );		/* (bad magic falls here too) */
X    }
X
X    pos = off + base - data;
X# ifdef DEBUGSW
X    if( sw_debug )
X	printf("read_vmunix: pos %#x off %#x base %#x data %#x\n",
X	       pos, off, base, data );
X# endif /* DEBUGSW defined */
X
X    if( lseek( f, pos, 0 ) == pos &&	/* seek to position */
X       read( f, str, len ) == len ) {	/* and read bytes */
X	close( f );			/* ok!! */
X	return( TRUE );			/* return good status */
X    } /* lseek and read OK */
X    close( f );
X    return( FALSE );
X} /* read_vmunix */
X
X# else  /* COFF defined */
X
X/*
X *	BSD systems using COFF end up here
X *	ie; DECstation3100 and Sun 386i
X *
X *	*TODO* needs work!
X */
X
X# include <stdio.h>
X# include <filehdr.h>
X# include <syms.h>			/* works for DS3100. 386i?? */
X# include <ldfcn.h>
X
X# ifndef ISCOFF
X/* UGH! This happens only on Umax 4.3 */
X# define ISCOFF(m) ((m) >= 0500 && (m) <= 0577)
X# endif /* ISCOFF not defined */
X
XGLOBAL BOOL
Xread_vmunix( file, off, str, len )	/* Hacking cough... */
X    char *file;				/* file name */
X    long off;				/* virtual address */
X    char *str;				/* dest buffer */
X    int len;				/* chars to read */
X{
X    LDFILE *ld;
X
X# ifdef DEBUGSW
X	if( sw_debug )
X	    printf("read_vmunix('%s', %x, ... , %d)\n", file, off, len );
X# endif /* DEBUGSW defined */
X
X    if( (ld = ldopen(file, NULL)) == NULL )
X	return( FALSE );
X
X    for( ; ; ) {			/* bogus loop */
X	if( !ISCOFF( HEADER(ld).f_magic ) )
X	    break;
X
X# ifdef DEBUGSW
X	if( sw_debug )
X	    puts("got here");
X# endif /* DEBUGSW defined */
X
X	/* more good stuff here! */
X
X	break;				/* break bogus loop! */
X    } /* bogus for loop */
X    ldclose( ld );
X    return( FALSE );
X} /* read_vmunix */
X# endif /* COFF defined */
X
X# endif /* Umax != 42 && !defined(USG) */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_read_vmunix.c
if test 5605 -ne `wc -c <read_vmunix.c`; then
    echo shar: \"read_vmunix.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ttylocfile.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ttylocfile.c\"
else
echo shar: Extracting \"ttylocfile.c\" \(6076 characters\)
sed "s/^X//" >ttylocfile.c <<'END_OF_ttylocfile.c'
X/*
X * ttylocfile.c -- read /etc/ttyloc and /etc/nttyloc (December 1985)
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: ttylocfile.c,v 3.0 90/07/06 13:12:03 budd Rel $";
X# endif /* lint not defined */
X
X# include "finger.h"
X# include <sys/types.h>
X# include <stdio.h>
X# ifdef TTYENT
X# include <ttyent.h>
X# endif /* TTYENT defined */
X
X# include "ttylocfile.h"
X
X# define BUFSIZE 512
X
XLOCAL TTYLOC ttyloc[MAXTTY];
XLOCAL int nttyloc;
X
XLOCAL int ttyloc_compare( a, b )	/* comparison for qsorting ttyloc[] */
X    register struct ttyloc *a, *b;
X{
X    return strcmp( a->t_name, b->t_name );
X} /* ttyloc_compare */
X
XGLOBAL int readnewttylocfile() {
X    FILE *fp;
X    char buf[BUFSIZE];
X    char *cp;
X    register char *sp;
X    register int c, q, l;
X    register struct ttyloc *tp;
X
X    nttyloc = 0;
X    if( (fp = fopen(NLOCFILE,"r")) == NULL )
X	return( 0 );			/* found none */
X
X    tp = ttyloc;			/* point to start of array */
X    while( nttyloc < MAXTTY && fgets(buf, BUFSIZE, fp) != NULL ) {
X	cp = buf;
X
X	tp->t_name = NULL;
X	tp->t_short = NULL;
X	tp->t_locn = NULL;
X	tp->t_type = LT_UNKNOWN;
X
X	l = strlen(cp);			/* smash nl into eos */
X	if( l > 0 && (buf[l-1] == '\n') )
X	    buf[l-1] = EOS;
X
X	if( !skipwhite( &cp ) )
X	    continue;
X
X	if( *cp == '#' )		/* comment line? */
X	    continue;			/*  yes, skip it */
X
X	sp = cp;			/* get start of line type */
X	if( !skipblack( &cp ) )
X	    continue;
X	*cp++ = EOS;
X
X	l = strlen( sp );
X	if( strncmp( sp, "hardwire", l ) == 0 )
X	    tp->t_type = LT_HARD;
X	else if( strncmp( sp, "ttyloc", l ) == 0 )
X	    tp->t_type = LT_TTYLOC;
X	else if( strncmp( sp, "dialup", l ) == 0 )
X	    tp->t_type = LT_DIALUP;
X	else if( strncmp( sp, "random", l ) == 0 )
X	    tp->t_type = LT_UNKNOWN;
X	else
X	    continue;			/* you lose */
X
X	if( !skipwhite( &cp ) )
X	    continue;
X	tp->t_name = cp;		/* save start of terminal name */
X	if( !skipblack( &cp ) )
X	    continue;
X	*cp++ = EOS;
X
X	/* pick up short location */
X	if( *cp == '"' || *cp == '\'' ) {
X	    q = *cp++;
X	    sp = cp;
X	    while( (c = *cp) != EOS && c != q )
X		cp++;
X	    if( c == EOS )
X		continue;
X	}
X	else {
X	    sp = cp;
X	    if( !skipblack( &cp ) )
X		continue;
X	}
X	*cp++ = EOS;
X
X	tp->t_short = sp;
X
X	if( !skipwhite( &cp ) )
X	    continue;
X
X	/* pick up long location */
X	if( *cp == '"' || *cp == '\'' ) {
X	    q = *cp++;
X	    sp = cp;
X	    while( (c = *cp) != EOS && c != q )
X		cp++;
X	    *cp++ = EOS;
X	}
X	else
X	    sp = cp;
X
X	if( strlen( sp ) == 0 )		/* no long location? */
X	    continue;			/* get lost */
X
X	tp->t_locn  = savestr( sp );
X	tp->t_name  = savestr( tp->t_name );
X	if( *tp->t_short != EOS )
X	    tp->t_short = savestr( tp->t_short );
X	else
X	    tp->t_short = NULL;
X
X	tp++;
X	nttyloc++;
X    } /* while fgets.. */
X    fclose(fp);
X    qsort( ttyloc, nttyloc, sizeof( ttyloc[0] ), ttyloc_compare );
X    return( nttyloc );
X} /* readnewttylocfile */
X
XGLOBAL int readttylocfile() {
X    FILE *fp;
X    char buf[BUFSIZE];
X    char *cp;
X    register int i;
X    register char *sp;
X    register struct ttyloc *tp;
X
X    nttyloc = 0;
X    if( (fp = fopen(LOCFILE,"r")) == NULL )
X	return( 0 );			/* found none */
X
X    tp = ttyloc;			/* point to start of array */
X    while( nttyloc < MAXTTY && fgets(buf, BUFSIZE, fp) != NULL ) {
X	cp = buf;
X
X	i = strlen(cp);			/* smash nl into eos */
X	if( i > 0 && (buf[i-1] == '\n') )
X	    buf[i-1] = EOS;
X
X	if( !skipwhite( &cp ) )
X	    continue;
X
X	if( *cp == '#' )		/* comment line? */
X	    continue;			/*  yes, skip it */
X
X	sp = cp;
X	if( !skipblack( &cp ))
X	    continue;
X
X	*cp++ = EOS;
X
X	tp->t_short = NULL;
X	tp->t_locn = NULL;
X	tp->t_type = LT_UNKNOWN;
X
X       if( strlen( cp ) > 0 ) {
X	    tp->t_locn = savestr( cp );
X	    tp->t_name = savestr( sp );
X	    tp++;
X	    nttyloc++;
X	}
X    } /* while fgets.. */
X    fclose(fp);
X    qsort( ttyloc, nttyloc, sizeof( ttyloc[0] ), ttyloc_compare );
X    return( nttyloc );
X} /* readttylocfile */
X
X# ifdef TTYENT
XGLOBAL int readttyents() {		/* 4.3/Ultrix ttys file */
X    register struct ttyent *ty;
X    register struct ttyloc *tp;
X
X    nttyloc = 0;
X    tp = ttyloc;
X    setttyent();
X    while( nttyloc < MAXTTY && (ty = getttyent()) != NULL ) {
X# ifndef USE_ALL_TTYENTS
X	if( (ty->ty_status & TTY_ON) == 0 )
X	    continue;
X# endif /* USE_ALL_TTYENTS not defined */
X
X	tp->t_name = savestr( ty->ty_name ); /* save line name */
X
X# ifdef DONT_USE_TTYENT_TYPE_AS_SHORT
X	tp->t_short = NULL;
X# else  /* DONT_USE_TTYENT_TYPE_AS_SHORT not defined */
X	tp->t_short = savestr( ty->ty_type );
X# endif /* DONT_USE_TTYENT_TYPE_AS_SHORT not defined */
X
X	tp->t_locn = NULL;		/* assume the worst */
X	if( ty->ty_comment != NULL ) {
X	    char *cp;
X
X	    cp = ty->ty_comment;
X	    if( *cp == '#' )		/* strip leading pound sign */
X		cp++;			/* (needed under uglix) */
X
X	    while( *cp == ' ' || *cp == '\t' ) /* strip leading white */
X		cp++;
X
X	    if( *cp != EOS )		/* anything left? */
X		tp->t_locn = savestr( cp ); /* yes, save as location */
X	} /* have comment */
X	tp->t_type = LT_UNKNOWN;
X	tp++;
X	nttyloc++;
X    } /* while */
X    endttyent();
X    qsort( ttyloc, nttyloc, sizeof( ttyloc[0] ), ttyloc_compare );
X    return( nttyloc );
X} /* readttyents */
X# endif /* TTYENT defined */
X
XGLOBAL TTYLOC *findttyloc( tty )	/* find entry in ttyloc file */
Xchar *tty;
X{
X    register int min, max, ptr;
X    register TTYLOC *tp;
X
X    min = 0;
X    max = nttyloc - 1;
X    while( min <= max ) {
X	int v;
X	ptr = (max + min + 1) >> 1;
X	tp = &ttyloc[ ptr ];
X	v = strcmp( tty, tp->t_name );
X# ifdef DEBUG
X	fprintf(stderr, "%d %d %d: %s,%s,%d\n",
X		min, ptr, max, tty, tp->t_name, v);
X# endif /* DEBUG defined */
X	if( v == 0 )
X	    return( tp );
X	else if( v > 0 )
X	    min = ptr + 1;
X	else
X	    max = ptr - 1;
X    } /* while */
X    return( NULL );
X} /* findttyloc */
X
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_ttylocfile.c
if test 6076 -ne `wc -c <ttylocfile.c`; then
    echo shar: \"ttylocfile.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f undomain.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"undomain.c\"
else
echo shar: Extracting \"undomain.c\" \(5512 characters\)
sed "s/^X//" >undomain.c <<'END_OF_undomain.c'
X/*
X * undomain.c -- massage host names
X *
X * Copyright (C) 1986, 1990  Philip L. Budne
X *
X * This file is part of "Phil's Finger Program".
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X */
X
X# ifndef lint
Xstatic char *rcsid = "$Id: undomain.c,v 3.0 90/07/06 13:12:06 budd Rel $";
X# endif /* lint not defined */
X
X# include <stdio.h>			/* for NULL */
X# include <strings.h>			/* for (r)index */
X# include <ctype.h>			/* for isdigit() */
X# include <sys/types.h>			/* for socket.h */
X# include <sys/socket.h>		/* for AF_INET */
X# include <netdb.h>			/* for {host,net}ent structs */
X# include <arpa/inet.h>			/* for inet_.... */
X# include <netinet/in.h>		/* for in_addr */
X# include "finger.h"
X# include "upper.h"
X
X# if 1
X# define SCMP(a,b) casecmp(a,b)
X# define CCMP(a,b) TOUP(a) == TOUP(b)
X# define TOUP(c) uppercase[c&0177]
X# else  /* not 1 */
X# define SCMP(a,b) (strcmp(a,b) == 0)
X# define CCMP(a,b) a == b
X# endif /* not 1 */
X
Xextern char localhost[];		/* from args.c */
Xextern char OFFICIALhostname[];		/* from args.c */
X
Xextern char *conf_prefix();		/* from conf.c */
X
XLOCAL char *prefixes[] = {		/* read from init file? */
X					/* Sorted by length?? */
X# ifdef PREFIXES
X    PREFIXES ,
X# endif /* PREFIXES defined */
X    NULL
X    };
X
XLOCAL BOOL tryprefix( hp, pp )
X    register char *pp, *hp;
X{
X    char *h;
X# ifdef DEBUG
X    printf("tryprefix(%s,%s)\n", hp, pp );
X# endif /* DEBUG defined */
X    h = hp;				/* save host buffer pointer */
X    while( CCMP(*hp,*pp) && *pp != EOS ) {
X	hp++;
X	pp++;
X    } /* while prefix matches */
X    if( *hp == EOS )			/* saw end of host first? */
X	return( FALSE );		/* ENTIRE hostname is a prefix?? */
X					/* try next (shorter?) prefix */
X
X    if( *pp == EOS )			/* saw end of prefix */
X	strcpy( h, hp );		/* slide back (backwards overlap?) */
X
X    return( TRUE );
X} /* tryprefix */
X
XLOCAL void unprefix( h )
Xchar *h;
X{
X    char **ppp, *pp;
X    int i;
X
X    for( ppp = prefixes; *ppp != NULL; ppp++ )
X	if( tryprefix( h, *ppp ) )
X	    return;
X
X    for( i = 0; (pp = conf_prefix(i)) != NULL; i++ )
X	if( tryprefix( h, pp ) )
X	    return;
X} /* unprefix */
X
XGLOBAL void undomain( h, rem_prefix )
Xchar *h;
Xint rem_prefix;
X{
X    int tries;
X    register char *p1, *p2;
X    char *op1;
X
X    HZUP( h );
X    p1 = rindex(h, '.');		/* find last dot in name */
X    if( p1 != NULL ) {			/* hack for well known domains */
X	if( SCMP( p1, ".ARPA" ) ) {
X	    *p1 = EOS;			/* zap it */
X	    return;
X	} /* special case for .ARPA */
X    } /* got last dot */
X    else {				/* no dots at all */
X# ifdef UNPREFIX_NODOMAIN
X	if( rem_prefix )
X	    unprefix( h );
X# endif /* UNPREFIX_NODOMAIN defined */
X	return;
X    } /* no dots at all */
X
X    tries = 0;
X    p1 = index(h, '.');			/* find first dot in new name */
X    if( p1 == NULL )
X	return;
X    p1++;
X    op1 = p1;
X
X# if 0
X    p2 = index( OFFICIALhostname, '.' ); /* find first dot in local name */
X    if( p2 == NULL )
X	return;
X    p2++;
X# else  /* not 0 */
X    p2 = OFFICIALhostname;		/* host may be a subdomain of ours */
X# endif /* not 0 */
X
X    for( ; ; ) {			/* loop1 */
X	for( ; ; ) {			/* loop2 */
X	    tries++;
X	    if( SCMP( p1, p2 ) ) {	/* both suffixes match? */
X		p1[-1] = EOS;		/* yes remove common suffix */
X		if( rem_prefix && tries == 1 ) {
X		    unprefix( h );
X		    return;
X		} /* removing prefixes and full domain matches */
X	    } /* suffixes match */
X
X	    p1 = index( p1, '.' );	/* find next dot in target string */
X	    if( p1 == NULL )		/* no more? */
X		break;			/* loop2 */
X	    p1++;
X	} /* loop2 */
X
X	p2 = index( p2, '.' );		/* step to next higher local domain */
X	if( p2 == NULL )
X	    break;			/* loop1 */
X	p2++;
X	p1 = op1;			/* go back to first target domain */
X    } /* loop1 */
X} /* undomain */
X
XBOOL casecmp( a, b )
X    register char *a, *b;
X{
X    while( TOUP(*a) == TOUP(*b++) )
X	if( *a == EOS )
X	    return( TRUE );
X	else
X	    a++;
X    return( FALSE );
X} /* casecmp */
X
XGLOBAL int checkhost( host, len )
X    char *host;
X    int len;
X{
X    int o1, o2, o3, o4;
X
X    /* exactly four octets? */
X    if( isdigit( host[0] ) &&
X       sscanf( host, "%d.%d.%d.%d", &o1, &o2, &o3, &o4 ) == 4 ) {
X	char temp[ 256 ];		/* large */
X	struct in_addr in;
X	struct hostent *hp;
X
X	/* make into an address */
X	in.s_addr = (o1 << 24) | (o2 << 16) | (o3 << 8) | o4;
X
X	/* assume login was dumb. try to reverse address */
X	if( (hp = gethostbyaddr( &in, sizeof( in ), AF_INET )) != NULL ) {
X	    strzcpy( host, hp->h_name, len );
X	    return( TRUE );
X	}
X	else if( net_host( temp, in ) ) {
X	    strzcpy( host, temp, len );
X	    return( TRUE );
X	} /* getnetbyaddr */
X    } /* 4 dotted octets */
X    return( FALSE );
X} /* checkhost */
X
XGLOBAL int
Xnet_host( buf, in )
X    char *buf;
X    struct in_addr in;
X{
X    char octet[ 5 ];
X    struct netent *np;
X    long lna;
X
X    if( (np = getnetbyaddr( inet_netof( in ), AF_INET )) != NULL ) {
X	strcpy( buf, np->n_name );
X
X	lna = inet_lnaof( in );		/* get "local net address" */
X	if( lna & 0xff0000 ) {		/* 2nd octet set */
X	    sprintf( octet, ".%d", (lna >> 16) & 0xff );
X	    strcat( buf, octet );
X	}
X	if( lna & 0xffff00 ) {	/* 2nd or 3rd */
X	    sprintf( octet, ".%d", (lna >> 8) & 0xff );
X	    strcat( buf, octet );
X	}
X	sprintf( octet, ".%d", lna & 0xff ); /* Class A B and C */
X	strcat( buf, octet );
X	return( TRUE );
X    }
X    return( FALSE );
X}
X/*
X * Local variables:
X * comment-column: 40
X * End:
X */
END_OF_undomain.c
if test 5512 -ne `wc -c <undomain.c`; then
    echo shar: \"undomain.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 3 \(of 7\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

