Newsgroups: comp.sources.unix
From: ram@eiffel.com (Raphael Manfredi)
Subject: v25i050: kit - the ultimate mailing kit, Part02/04
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: ram@eiffel.com (Raphael Manfredi)
Posting-Number: Volume 25, Issue 50
Archive-Name: kit/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 4)."
# Contents:  UNSHAR.HDR config.h.SH des/main.c kit/kit.SH
#   kit/mailkit.SH kit/unkit.SH man/kit.SH
# Wrapped by vixie@cognition.pa.dec.com on Thu Dec 19 21:18:29 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'UNSHAR.HDR' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'UNSHAR.HDR'\"
else
echo shar: Extracting \"'UNSHAR.HDR'\" \(4302 characters\)
sed "s/^X//" >'UNSHAR.HDR' <<'END_OF_FILE'
Return-Path: ram@eiffel.com
Received: by cognition.pa.dec.com; id AA07451; Mon, 25 Nov 91 12:57:25 -0800
Received: by inet-gw-1.pa.dec.com; id AA23335; Mon, 25 Nov 91 12:57:21 -0800
Received: from uunet.uu.net (via LOCALHOST.UU.NET) by relay2.UU.NET with SMTP 
X	(5.61/UUNET-internet-primary) id AA04155; Mon, 25 Nov 91 15:57:11 -0500
Received: from eiffel.UUCP by uunet.uu.net with UUCP/RMAIL
X	(queueing-rmail) id 155650.21663; Mon, 25 Nov 1991 15:56:50 EST
Received: by eiffel.eiffel.com (4.0/SMI-4.0)
X	id AA09846; Mon, 25 Nov 91 12:40:15 PST
Date: Mon, 25 Nov 91 12:40:15 PST
XFrom: ram@eiffel.com (Raphael)
Message-Id: <9111252040.AA09846@eiffel.eiffel.com>
To: vixie
Subject: kit 2.0 package (Part 1/3)
XX-Mailer: MAILAGENT [version 2.8 PL11]
X
Here is the answer to your request:
X
X	maildist vixie@Pa.dec.com kit 2.0
X
X
This is a shar file. It will be simpler to unshar it if you own the Rich Salz's
cshar package. If you do not have it, send me the following mail:
X
X	Subject: Command
X	@PACK shar
X	@SH maildist vixie@Pa.dec.com cshar 3.0
X
and you will get cshar as shell archives.
X
Detailed intructions can be obtained by:
X
X	Subject: Command
X	@SH mailhelp vixie@Pa.dec.com
X
Unshar: Save this mail into a file, e.g. "foo1" and wait until
X	you have received the 3 parts. Then, do "unshar -n foo*". If you
X	do not own "unshar", edit the 3 files and remove the mail header
X	by hand before feeding into sh.
X
X-- maildist speaking for ram
X
X
Return-Path: ram@eiffel.com
Received: by cognition.pa.dec.com; id AA07900; Mon, 25 Nov 91 13:08:01 -0800
Received: by inet-gw-1.pa.dec.com; id AA24318; Mon, 25 Nov 91 13:07:57 -0800
Received: from uunet.uu.net (via LOCALHOST.UU.NET) by relay1.UU.NET with SMTP 
X	(5.61/UUNET-internet-primary) id AA25668; Mon, 25 Nov 91 16:07:38 -0500
Received: from eiffel.UUCP by uunet.uu.net with UUCP/RMAIL
X	(queueing-rmail) id 160633.24288; Mon, 25 Nov 1991 16:06:33 EST
Received: by eiffel.eiffel.com (4.0/SMI-4.0)
X	id AA09847; Mon, 25 Nov 91 12:40:18 PST
Date: Mon, 25 Nov 91 12:40:18 PST
XFrom: ram@eiffel.com (Raphael)
Message-Id: <9111252040.AA09847@eiffel.eiffel.com>
To: vixie
Subject: kit 2.0 package (Part 2/3)
XX-Mailer: MAILAGENT [version 2.8 PL11]
X
Here is the answer to your request:
X
X	maildist vixie@Pa.dec.com kit 2.0
X
X
This is a shar file. It will be simpler to unshar it if you own the Rich Salz's
cshar package. If you do not have it, send me the following mail:
X
X	Subject: Command
X	@PACK shar
X	@SH maildist vixie@Pa.dec.com cshar 3.0
X
and you will get cshar as shell archives.
X
Detailed intructions can be obtained by:
X
X	Subject: Command
X	@SH mailhelp vixie@Pa.dec.com
X
Unshar: Save this mail into a file, e.g. "foo2" and wait until
X	you have received the 3 parts. Then, do "unshar -n foo*". If you
X	do not own "unshar", edit the 3 files and remove the mail header
X	by hand before feeding into sh.
X
X-- maildist speaking for ram
X
X
Return-Path: ram@eiffel.com
Received: by cognition.pa.dec.com; id AA07407; Mon, 25 Nov 91 12:53:37 -0800
Received: by inet-gw-1.pa.dec.com; id AA22997; Mon, 25 Nov 91 12:53:34 -0800
Received: from uunet.uu.net (via LOCALHOST.UU.NET) by relay2.UU.NET with SMTP 
X	(5.61/UUNET-internet-primary) id AA03531; Mon, 25 Nov 91 15:53:35 -0500
Received: from eiffel.UUCP by uunet.uu.net with UUCP/RMAIL
X	(queueing-rmail) id 155157.20607; Mon, 25 Nov 1991 15:51:57 EST
Received: by eiffel.eiffel.com (4.0/SMI-4.0)
X	id AA09848; Mon, 25 Nov 91 12:40:20 PST
Date: Mon, 25 Nov 91 12:40:20 PST
XFrom: ram@eiffel.com (Raphael)
Message-Id: <9111252040.AA09848@eiffel.eiffel.com>
To: vixie
Subject: kit 2.0 package (Part 3/3)
XX-Mailer: MAILAGENT [version 2.8 PL11]
X
Here is the answer to your request:
X
X	maildist vixie@Pa.dec.com kit 2.0
X
X
This is a shar file. It will be simpler to unshar it if you own the Rich Salz's
cshar package. If you do not have it, send me the following mail:
X
X	Subject: Command
X	@PACK shar
X	@SH maildist vixie@Pa.dec.com cshar 3.0
X
and you will get cshar as shell archives.
X
Detailed intructions can be obtained by:
X
X	Subject: Command
X	@SH mailhelp vixie@Pa.dec.com
X
Unshar: Save this mail into a file, e.g. "foo3" and wait until
X	you have received the 3 parts. Then, do "unshar -n foo*". If you
X	do not own "unshar", edit the 3 files and remove the mail header
X	by hand before feeding into sh.
X
X-- maildist speaking for ram
X
X
END_OF_FILE
if test 4302 -ne `wc -c <'UNSHAR.HDR'`; then
    echo shar: \"'UNSHAR.HDR'\" unpacked with wrong size!
fi
# end of 'UNSHAR.HDR'
fi
if test -f 'config.h.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h.SH'\"
else
echo shar: Extracting \"'config.h.SH'\" \(4258 characters\)
sed "s/^X//" >'config.h.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X	if test ! -f config.sh; then
X		ln ../config.sh . || \
X		ln ../../config.sh . || \
X		ln ../../../config.sh . || \
X		(echo "Can't find config.sh."; exit 1)
X	fi 2>/dev/null
X	. ./config.sh
X	;;
esac
echo "Extracting config.h (with variable substitutions)"
sed <<!GROK!THIS! >config.h -e 's!^#undef!/\*#define!'
X/*
X * This file was produced by running the config.h.SH script, which
X * gets its values from config.sh, which is generally produced by
X * running Configure.
X *
X * Feel free to modify any of this as the need arises.  Note, however,
X * that running config.h.SH again will wipe out any changes you've made.
X * For a more permanent change edit config.sh and rerun config.h.SH.
X *
X * \$Id: config.h.SH,v 2.0.1.5 91/11/25 15:48:49 ram Exp $
X */
X
X#ifndef _config_h_
X#define _config_h_
X
X/* BYTEORDER
X *	This symbol hold the hexadecimal constant defined in byteorder,
X *	i.e. 0x1234 or 0x4321, etc...
X */
X#define BYTEORDER 0x$byteorder	/* large digits for MSB */
X
X/* GETOPT:
X *	This symbol, if defined, indicates that the getopt() routine exists.
X */
X#$d_getopt	GETOPT		/**/
X
X/* index:
X *	This preprocessor symbol is defined, along with rindex, if the system
X *	uses the strchr and strrchr routines instead.
X */
X#$d_index	index strchr	/**/
X
X/* MEMCPY:
X *	This symbol, if defined, indicates that the memcpy routine is available
X *	to copy blocks of memory. You should always use bcopy() instead of
X *	memcpy() because bcopy is remaped to memcpy if necessary. This means
X *	that a memcpy() routine must be provided in case MEMCPY is not defined
X *	and no bcopy() is found.
X */
X#$d_memcpy	MEMCPY		/**/
X
X/* MEMSET:
X *	This symbol, if defined, indicates that the memset routine is available
X *	to set blocks of memory. You should always use bzero() instead of
X *	memset() because bzero is remaped to memset if necessary. This means
X *	that a memset() routine must be provided in case MEMSET is not defined
X *	and no bzero() is found.
X */
X#$d_memset	MEMSET		/**/
X
X/* SIGNAL_T:
X *	This symbol's value is either "void" or "int", corresponding to the
X *	appropriate return type of a signal handler.  Thus, you can declare
X *	a signal handler using "SIGNAL_T (*handler())()", and define the
X *	handler using "SIGNAL_T handler(sig)".
X */
X#define SIGNAL_T $signal_t	/* Kept for backward compatibility */
X
X/* I_SYSIOCTL:
X *	This symbol, if defined, indicates that <sys/ioctl.h> exists and should
X *	be included. Otherwise, include <sgtty.h> or <termio.h>.
X */
X#$i_sysioctl	I_SYSIOCTL		/**/
X
X/* I_TERMIO:
X *	This symbol, if defined, indicates that the program should include
X *	<termio.h> rather than <sgtty.h>.  There are also differences in
X *	the ioctl() calls that depend on the value of this symbol.
X */
X/* I_TERMIOS:
X *	This symbol, if defined, indicates that the program should include
X *	the POSIX termios.h rather than sgtty.h or termio.h.
X *	There are also differences in the ioctl() calls that depend on the
X *	value of this symbol.
X */
X/* I_SGTTY:
X *	This symbol, if defined, indicates that the program should include
X *	<sgtty.h> rather than <termio.h>.  There are also differences in
X *	the ioctl() calls that depend on the value of this symbol.
X */
X#$i_termio	I_TERMIO		/**/
X#$i_termios	I_TERMIOS		/**/
X#$i_sgtty	I_SGTTY		/**/
X
X/* VOIDFLAGS
X *	This symbol indicates how much support of the void type is given by this
X *	compiler.  What various bits mean:
X *
X *	    1 = supports declaration of void
X *	    2 = supports arrays of pointers to functions returning void
X *	    4 = supports comparisons between pointers to void functions and
X *		    addresses of void functions
X *	    8 = suports declaration of generic void pointers
X *
X *	The package designer should define VOIDUSED to indicate the requirements
X *	of the package.  This can be done either by #defining VOIDUSED before
X *	including config.h, or by defining defvoidused in Myinit.U.  If the
X *	latter approach is taken, only those flags will be tested.  If the
X *	level of void support necessary is not present, defines void to int.
X */
X#ifndef VOIDUSED
X#define VOIDUSED $defvoidused
X#endif
X#define VOIDFLAGS $voidflags
X#if (VOIDFLAGS & VOIDUSED) != VOIDUSED
X#$define void int		/* is void to be avoided? */
X#$define M_VOID			/* Xenix strikes again */
X#endif
X
X#endif
X!GROK!THIS!
END_OF_FILE
if test 4258 -ne `wc -c <'config.h.SH'`; then
    echo shar: \"'config.h.SH'\" unpacked with wrong size!
fi
chmod +x 'config.h.SH'
# end of 'config.h.SH'
fi
if test -f 'des/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des/main.c'\"
else
echo shar: Extracting \"'des/main.c'\" \(4088 characters\)
sed "s/^X//" >'des/main.c' <<'END_OF_FILE'
X/* Encrypt/decrypt command compatible with Sun's "des" command */
X/*
X * $Id: main.c,v 2.0.1.1 91/04/01 15:40:10 ram Exp $
X *
X * $Log:	main.c,v $
X * Revision 2.0.1.1  91/04/01  15:40:10  ram
X * patch1: created
X * 
X */
X
X#include <stdio.h>
X
char iv[8];	/* Initial vector for CBC mode */
int block;
X
main(argc,argv)
int argc;
char *argv[];
X{
X	int c,cnt,encrypt,decrypt,hexflag;
X	register int i;
X	char key[8],tkey1[20],tkey2[20],*akey,*getpass();
X	extern char *optarg;
X
X	hexflag = block = encrypt = decrypt = 0;
X	akey = NULL;
X	while((c = getopt(argc,argv,"hedk:b")) != EOF){
X		switch(c){
X		case 'h':
X			hexflag++;
X			break;
X		case 'e':
X			encrypt++;
X			break;
X		case 'd':
X			decrypt++;
X			break;
X		case 'k':
X			akey = optarg;
X			break;
X		case 'b':
X			block++;
X			break;
X		}
X	}
X	if(encrypt == 0 && decrypt == 0){
X		fprintf(stderr,"Usage: des -e|-d [-h] [-k key]\n");
X		exit(2);
X	}
X	if(akey == NULL){
X		/* No key on command line, prompt for it */
X		memset(tkey1,0,sizeof(tkey1));
X		memset(tkey2,0,sizeof(tkey2));
X		for(;;){
X			akey = getpass("Enter key: ");
X			strncpy(tkey1,akey,sizeof(tkey1));
X			akey = getpass("Enter key again: ");
X			strncpy(tkey2,akey,sizeof(tkey2));
X			if(strncmp(tkey1,tkey2,sizeof(tkey1)) != 0){
X				fprintf(stderr,"Key mistyped, try again\n");
X			} else
X				break;
X		}
X		akey = tkey1;
X	}
X	if(hexflag){
X		for(i=0;i<16;i++){
X			if(htoa(akey[i]) == -1){
X				fprintf(stderr,"Non-hex character in key\n");
X				exit(1);
X			}
X		}
X		gethex(key,akey,8);
X	} else {
X		strncpy(key,akey,8);
X		/* Set up key, determine parity bit */
X		for(cnt = 0; cnt < 8; cnt++){
X			c = 0;
X			for(i=0;i<7;i++)
X				if(key[cnt] & (1 << i))
X					c++;
X			if((c & 1) == 0)
X				key[cnt] |= 0x80;
X			else
X				key[cnt] &= ~0x80;
X		}
X	}
X	/* Blot out original key */
X	i = strlen(akey);
X	i = (i < 8) ? i : 8;
X	memset(akey,0,i);
X
X	desinit(0);
X	setkey(key);
X
X	/* Initialize IV to all zeros */
X	memset(iv,0,8);
X
X	if(encrypt){
X		doencrypt();
X	} else {
X		dodecrypt();
X	}
X}
X/* Encrypt standard input to standard output */
doencrypt()
X{
X	char work[8],*cp,*cp1;
X	int cnt,i;
X
X	for(;;){
X		if((cnt = fread(work,1,8,stdin)) != 8){
X			/* Put residual byte count in the last block.
X			 * Note that garbage is left in the other bytes,
X			 * if any; this is a feature, not a bug, since it'll
X			 * be stripped out at decrypt time.
X			 */
X			work[7] = cnt;
X		}
X		if(!block){
X			/* CBC mode; chain in last cipher word */
X			cp = work;
X			cp1 = iv;
X			for(i=8; i!=0; i--)
X				*cp++ ^= *cp1++;
X		}
X		endes(work);	/* Encrypt block */
X		if(!block){	/* Save outgoing ciphertext for chain */
X			memcpy(iv,work,8);
X		}
X		fwrite(work,1,8,stdout);
X		if(cnt != 8)
X			break;
X	}
X}
dodecrypt()
X{
X	char work[8],nwork[8],ivtmp[8],*cp,*cp1;
X	int cnt,i;
X
X
X	cnt = fread(work,1,8,stdin);	/* Prime the pump */
X	for(;;){
X		if(!block){	/* Save incoming ciphertext for chain */
X			memcpy(ivtmp,work,8);
X		}
X		dedes(work);
X		if(!block){	/* Unchain block, save ciphertext for next */
X			cp = work;
X			cp1 = iv;
X			for(i=8; i!=0; i--){
X				*cp++ ^= *cp1++;
X			}
X			memcpy(iv,ivtmp,8);
X		}
X		/* Save buffer pending next read */
X		memcpy(nwork,work,8);
X		/* Try to read next block */
X		cnt = fread(work,1,8,stdin);
X		if(cnt != 8){	/* Can "only" be 0 if not 8 */
X			/* Prev block was last one, write appropriate number
X			 * of bytes
X			 */
X			cnt = nwork[7];
X			if(cnt < 0 || cnt > 7){
X				fprintf(stderr,"Corrupted file or wrong key\n");
X			} else if(cnt != 0)
X				fwrite(nwork,1,cnt,stdout);
X			exit(0);
X		} else {
X			/* Now okay to write previous buffer */
X			fwrite(nwork,1,8,stdout);
X		}
X
X	}
X}
X/* Convert hex/ascii nybble to binary */
int
htoa(c)
char c;
X{
X	if(c >= '0' && c <= '9')
X		return c - '0';
X	if(c >= 'a' && c <= 'f')
X		return 10 + c - 'a';
X	if(c >= 'A' && c <= 'F')
X		return 10 + c - 'A';
X	return -1;
X}
X/* Convert bytes from hex/ascii to binary */
gethex(result,cp,cnt)
register char *result;
register char *cp;
register int cnt;
X{
X	while(cnt-- != 0){
X		*result = htoa(*cp++) << 4;
X		*result++ |= htoa(*cp++);
X	}
X}
X#ifdef	DEBUG
put8(cp)
register char *cp;
X{
X	int i;
X
X	for(i=0;i<8;i++){
X		fprintf(stderr,"%02x ",*cp++ & 0xff);
X	}
X}
X#endif
X
END_OF_FILE
if test 4088 -ne `wc -c <'des/main.c'`; then
    echo shar: \"'des/main.c'\" unpacked with wrong size!
fi
# end of 'des/main.c'
fi
if test -f 'kit/kit.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kit/kit.SH'\"
else
echo shar: Extracting \"'kit/kit.SH'\" \(8103 characters\)
sed "s/^X//" >'kit/kit.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X	if test ! -f config.sh; then
X		ln ../config.sh . || \
X		ln ../../config.sh . || \
X		ln ../../../config.sh . || \
X		(echo "Can't find config.sh."; exit 1)
X	fi 2>/dev/null
X	. config.sh
X	;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting kit/kit (with variable substitutions)"
X$spitshell >kit <<!GROK!THIS!
X$startsh
X# @(#) converts to ascii && packages a whole directory
X# @(#) (c) E. Mogenet April, 1990
X# @(#) (c) R. Manfredi, 1990 1991
X
X# Which patch-level is it ?
pl='$PATCHLEVEL'
version='$VERSION'
libdir='$privlib'
X!GROK!THIS!
X$spitshell >>kit <<'!NO!SUBS!'
X
X# $Id: kit.SH,v 2.0.1.6 91/12/08 14:55:06 ram Exp $
X#
X# $Log:	kit.SH,v $
X# Revision 2.0.1.6  91/12/08  14:55:06  ram
X# patch10: forgot to protect evaluation of variable in a test
X# 
X# Revision 2.0.1.5  91/11/25  15:50:59  ram
X# patch9: added option -M which asks for minikit inclusion
X# patch9: the subject given to mailkit was wrong unless -s was used
X# 
X# Revision 2.0.1.4  91/11/25  12:08:20  ram
X# patch8: stamping of kit parts is now done by kit instead of mailkit
X# patch8: new option -l to give recipient file list
X# patch8: removed comments describing usage and done some clean-up
X# 
X# Revision 2.0.1.3  91/07/30  17:24:20  ram
X# patch6: config.sh now carries the symbols defined in patchlevel.h
X# 
X# Revision 2.0.1.2  91/05/27  14:25:21  ram
X# patch5: added options -d and -n
X# patch5: usage is no longer printed by a function
X# patch5: redirection with piping in eval may yield i/o error
X# patch5: version number is no longer hardwired
X# 
X# Revision 2.0.1.1  91/04/01  15:48:26  ram
X# patch1: new options -x, -k and -X for encryption facilities
X# patch1: naming convention for files has been revised
X# patch1: kit now traps interrupts for a graceful exit
X# 
X# Revision 2.0  91/02/19  15:49:53  ram
X# Baseline for first official release.
X# 
X
coding=btoa					# Program used for coding
mode="zag"					# Mode is the 'A' part of the name
code="ba"					# Code is the 'B' part of the name
mailkit=mailkit				# Mailing program to use with kit
invoke=no					# Do we have to invoke mailkit ?
tmpfile=/tmp/Kds$$			# Temporary file
tmpdir="."					# Temporary directory used
partname="Kit"				# Default part name used
minikit=''					# Do not include minikit
mininame=''					# File where minikit's name is stored
instruct=''					# Instrucutions for minikit usage
X
X# Mailkit options
mailopt=""
subject=""
X
X# DES options
key=""
desopt=""
X
X# Old Bourne shells do not have functions
usage='
echo "Usage: kit [-BEFHMVXefhpx] [-d dir] [-k key] [-m address] [-n basename]";
echo " "" "" "" "" "" "" [-l file] [-s name] dirs | files";
echo " "" -B : use btoa encoding (default).";
echo " "" -E : edit instructions for part #0 (passed to mailkit).";
echo " "" -F : feed instructions from stdin to part #0 (passed to mailkit).";
echo " "" -H : use hex-encoding.";
echo " "" -M : include minikit in the distribution.";
echo " "" -V : print version and patch-level.";
echo " "" -X : use Electronic Code Block DES encryption.";
echo " "" -d : put temporary files in the specified directory.";
echo " "" -e : edit instructions to add in each part (passed to mailkit).";
echo " "" -f : feed instructions from stdin in each part (passed to mailkit).";
echo " "" -h : to print this help message.";
echo " "" -k : sets the key used for data encryption.";
echo " "" -m : invoke mailkit to mail the parts.";
echo " "" "" "" "" "" "" There may be as many -m as necessary.";
echo " "" -l : file holding the recipient list (passed to mailkit).";
echo " "" -n : set the basename of the generated parts (default is $partname).";
echo " "" -p : preserve files sent (given to mailkit).";
echo " "" -s : set kit name (given to mailkit).";
echo " "" -x : use Cipher Block Chaining DES encryption (default).";
exit 1
X'
X
for i in $*
do
X	case $i in 
X	-M) shift
X		if test -f minikit; then
X			if test -f MINIKIT; then
X				minikit="mkit$$"
X			else
X				minikit='MINIKIT'
X			fi
X		else
X			minikit='minikit'
X		fi
X		;;
X	-H) shift
X		coding=hexencode
X		code="hex"
X		;;
X	-B) shift
X		coding=btoa
X		code="ba"
X		;;
X	-E|-e|-F|-f|-p) mailopt="$mailopt $1"
X		shift
X		;;
X	-X) desopt="-b"
X		mode="zec"
X		shift
X		;;
X	-d) tmpdir="$2"
X		shift
X		shift
X		;;
X	-x) desopt=""
X		mode="zcb"
X		shift
X		;;
X	-k) key=" -k $2"
X		case "$mode" in
X		zag) mode="zcb";;
X		esac
X		shift
X		shift
X		;;
X	-m) address="$address $2"
X		invoke=yes
X		shift
X		shift
X		;;
X	-l) mailopt="$mailopt -l $2"
X		invoke=yes
X		shift
X		shift
X		;;
X	-n) partname="$2"
X		shift
X		shift
X		;;
X	-s) subject="$2"
X		shift
X		shift
X		;;
X	-V) echo "kit $version PL$pl"
X		exit 0
X		;;
X	-h) eval $usage
X		;;
X	-*) echo "unkown option $1"
X		eval $usage
X	esac
done
X
X# At this stage, $1 should hold the name of a file or a directory
if test "x$1" = x
then
X	eval $usage
fi
X
rm -f $tmpdir/$partname??			# Make sure no parts already exist
X
X# If DES is to be performed, do it before ASCII coding
case "$mode" in
zag);;
X*) desopt="$desopt -e"$key
X	coding="des $desopt | "$coding;;
esac
X
X# We have two encoding methods for binary datas:
X# - hexencode: brute force (mogenix)
X# - btoa: binary to ascii (ram)
X#
X# As we want to make kit-unkit encoding-independant, the following
X# naming convention occurs for files split: names are A.B.* where:
X#
X#   - A is zag for uncrypted files
X#   - A is zcb for DES encrypted files with CBC mode
X#   - A is zec for DES encrypted files with ECB mode
X# 
X#   - B is hex for hex-encoded file
X#   - B is ba for ASCII-encoded files
X
split_file=$mode.$code.		# Name used for spliting
X
X# In case we are interrupted
trap "rm -f $tmpfile; cd $tmpdir; rm -f $partname?? ${split_file}* \
X	$minikit $partname??.$$; echo >&2 'Aborted.'; exit 1" 1 2 3 15
X
X# We have to use a tmp file to avoid des prompting while tar is running
tar cvf - $@ | compress -v > $tmpfile
X
cd $tmpdir
X
X# If minikit is to be used, copy the script from the library directory
if test "$minikit"; then
X	if test -r "$libdir/minikit"; then
X		cp $libdir/minikit $minikit
X		chmod +x $minikit
X		# Name of the minikit program is passed along to unkit, so that the
X		# script may be removed when unkit is ran...
X		echo "$minikit" > zzz.minikit
X		mininame=zzz.minikit
X		# Prepare instructions for later
X		instruct=">>
X>> In case you do not have unkit, you may proceeed as follows:
X>> - First run all the parts through unshar or sh. This will extract
X>>   some temporary files, and among them a script called '$minikit'.
X>> - Run the '$minikit' program, and the kit will be extracted for you.
X>>   If the extraction is successful, all the temporary files previously
X>>   extracted will be removed, including $minikit.
X
X"
X	else
X		echo >&2 "$0: cannot find minikit in $libdir"
X		kill -15 $$
X	fi
fi
X
echo "Coding with $coding"
X# Beware: 'eval $coding < $tmpfile' is not portable
cat $tmpfile | eval $coding |
split -600 - $split_file &&
makekit -k100 -n $partname ${split_file}* $minikit $mininame &&
rm ${split_file}* $minikit $mininame $tmpfile
X
case "$subject" in
X'') subject=$1
esac
X
X# Stamp the files, stating they are kit files and not shell archives
set X $partname??
shift
nfiles=$#
for file in $partname??
do
X	# Extract part number
X	part=`expr $file : '[^0-9]*\(.*\)'`
X	# Remove leading zero(s)
X	part_num=`expr $part + 0`
X	# Write kit header stamp message
X	echo "Stamping kit $part_num..."
X	genstamp=">> Generated by kit $version PL$pl on `date`"
X	if test $nfiles -gt 1; then
X		cat >$file.$$ <<EOH
X>> This is a kit file (part #$part_num out of $nfiles). To unkit, save this message
X>> into a file, e.g. foo$part, and wait until you have the $nfiles files.
X>> Then, do "unkit foo*". To see what will be extracted, you may wish to
X>> do "unkit -l foo*" before.
X>>
X$genstamp
X$instruct
XEOH
X	else
X		cat >$file.$$ <<EOH
X>> This is a kit file. To unkit, save this message into a file, e.g. foo.
X>> Then, do "unkit foo". To see what will be extracted, you may wish to
X>> do "unkit -l foo" before.
X>>
X$genstamp
X$instruct
XEOH
X	fi
X	cat $file >>$file.$$
X	mv $file.$$ $file
done
X
X# If -m option used, invoke mailkit
if test $invoke = yes; then
X	$mailkit -n $partname $mailopt "$subject" $address
fi
X!NO!SUBS!
chmod 755 kit
X$eunicefix kit
END_OF_FILE
if test 8103 -ne `wc -c <'kit/kit.SH'`; then
    echo shar: \"'kit/kit.SH'\" unpacked with wrong size!
fi
chmod +x 'kit/kit.SH'
# end of 'kit/kit.SH'
fi
if test -f 'kit/mailkit.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kit/mailkit.SH'\"
else
echo shar: Extracting \"'kit/mailkit.SH'\" \(6605 characters\)
sed "s/^X//" >'kit/mailkit.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X	if test ! -f config.sh; then
X		ln ../config.sh . || \
X		ln ../../config.sh . || \
X		ln ../../../config.sh . || \
X		(echo "Can't find config.sh."; exit 1)
X	fi 2>/dev/null
X	. config.sh
X	;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting kit/mailkit (with variable substitutions)"
X$spitshell >mailkit <<!GROK!THIS!
X# @(#) Mailer for kit files
X# @(#) (c) R. Manfredi, 1990 1991
X
X# $Id: mailkit.SH,v 2.0.1.4 91/12/08 14:55:22 ram Exp $
X#
X# $Log:	mailkit.SH,v $
X# Revision 2.0.1.4  91/12/08  14:55:22  ram
X# patch10: forgot to protect evaluation of variable in a test
X# 
X# Revision 2.0.1.3  91/11/25  12:09:23  ram
X# patch8: stamping of kit parts is now done directly in kit
X# patch8: added option -l to allow taking recipients from a file
X# 
X# Revision 2.0.1.2  91/07/30  17:26:26  ram
X# patch6: config.sh now carries the symbols defined in patchlevel.h
X# patch6: the subject line in mails now appears first for USG /bin/mail
X# 
X# Revision 2.0.1.1  91/05/27  14:28:37  ram
X# patch5: added option -n
X# patch5: usage is no longer printed by a function
X# patch5: version number is no longer hardwired
X# patch5: set -- was not supported everywhere; use set X and shift
X# 
X# Revision 2.0  91/02/19  15:49:57  ram
X# Baseline for first official release.
X# 
X
X# Define the mailer program
mailer="$mailer"
X
X# Define the default editor
editor=$defeditor
X
X# Which patch-level is it ?
pl='$PATCHLEVEL'
version='$VERSION'
X!GROK!THIS!
X$spitshell >>mailkit <<'!NO!SUBS!'
X
X# Flag used for -e/f and -E/F options
edit=no
added=no
feed=no
preserve=no
recipients=''
X
X# Default part's name
partname="Kit"
X
X# Old Bourne shells do not have functions
usage='
echo "Usage: mailkit [-EFVefhp] [-n base] [-l file] prog_name [address_list]";
echo " "" -E : edit a message that will be sent as part #0";
echo " "" -F : feed message from stdin and sent it as part #0";
echo " "" -V : print version and patch-level";
echo " "" -e : edit a message that will be added to every part";
echo " "" -f : feed message from stdin to every part";
echo " "" -h : to print this help message.";
echo " "" -l : get recipients from a file (address_list is ignored).";
echo " "" -n : set the basename of parts to be sent (default is $partname).";
echo " "" -p : preserve files sent.";
exit 1;
X'
X
X# Argument parsing
for i in $*
do
X	case $i in
X	-V) echo "mailkit $version PL$pl"
X		exit 0
X		;;
X	-E) edit=yes
X		added=no
X		shift
X		;;
X	-e) edit=yes
X		added=yes
X		shift
X		;;
X	-h) eval $usage
X		;;
X	-p) preserve=yes
X		shift
X		;;
X	-l) recipients="$2"
X		shift
X		shift
X		;;
X	-n) partname="$2"
X		shift
X		shift
X		;;
X	-f)	feed=yes
X		added=yes
X		shift
X		;;
X	-F)	feed=yes
X		added=no
X		shift
X		;;
X	-*) echo "unknown option $1"
X		eval $usage
X		;;
X	esac
done
X
if test "x$1" = x; then
X	echo >&2 "$0: missing program name"
X	eval $usage
fi
X
X# Save arguments before using set
this_prog=$0
prog_name=$1
shift
address=$@
saved_address=$@
X
X# When a recipient file is provided, ignore the remaining of the command line
if test "$recipients"; then
X	if test -r "$recipients"; then
X		# The format of the file is simple: a list of addresses, one per
X		# line. Shell-style comments are allowed and multiple addresses on a
X		# single line may be separated with spaces or commas.
X		set X `<$recipients sed -n -e '/^[^#]/ {'	\
X			-e 's/#.*//'	\
X			-e 's/,/ /g'	\
X			-e 's/\n/ /'	\
X			-e 'p'			\
X			-e '}'` $saved_address
X		shift
X		address=$@
X	else
X		echo >&2 "$this_prog: can't open $recipients"
X		exit 1
X	fi
fi
X
if test "x$address" = x; then
X	echo >&2 "$this_prog: missing recipient list"
X	eval $usage
fi
X
X# In case of editing, compute a temporary file name
message=/tmp/MKt$$
X# Temporary files used for building top message
tmpmsg=/tmp/Nkt$$
topmsg=/tmp/Tkt$$
X
X# Set a trap in case we die abruptly
trap 'rm -f $message $tmpmsg $topmsg;
test $preserve = no && rm -f $partname??;
echo "Mailing aborted."
exit 1' 1 2 3 15
X
X# Count how many files there are
set X $partname??
shift
nfiles=$#
X
if test $edit = yes
then
X	# If editing was asked for, prepare the help message
X	cat >$message <<EOM
Please, enter your message here for the "$prog_name" kit.
Do not worry about this text, the 4 lines at the top will be removed.
XEOM
X	if test $added = yes
X	then
X		cat >>$message <<'EOM'
The message will be added at the top of each part.
XEOM
X	else
X		cat >>$message <<'EOM'
The message will be sent as part #0 and other parts will mention that.
XEOM
X	fi
X	cat >>$message <<'EOM'
X------------------------------------------------------------------------
XEOM
X	# Call the editor
X	$editor $message
X
X	# Now remove the 4 lines at the top
X	# Do not use tail +5, as this may not exist on every system
X	cp $message $tmpmsg
X	awk '{ nl += 1 }; nl > 4 { print }' <$tmpmsg >$message
X	rm -f $tmpmsg
X
X	# If message is empty, discard it.
X	if test ! -s $message
X	then
X		rm -f $message
X		edit=no
X	fi
elif test $feed = yes; then
X	edit=yes			# No differences from now on
X	cat > $message		# Feed from stdin
fi
X
X# Print recipient list
echo "Mailing \"$prog_name\" to the following recipient list:"
echo $address | tr ' ' '\012' | sed -e 's/^/	/'
X
for i in $partname??
do
X	# Extracts the part number (will it work on all systems ?)
X	# Note that this does not rely on the leader part of the name.
X	part=`expr $i : '[^0-9]*\(.*\)'`
X
X	# Remove leading zero(s).
X	# Is there a simpler way to do this ?
X	part_num=`expr ${part:-1} + 0`
X
X	# Protect against unexisting/unreadable files matching "$partname*"
X	if  test -f $i -a -r $i
X	then
X		echo Mailing $i \($prog_name\)
X		# System V /bin/mail does not recognize header correctly, unless the
X		# first line is a subject. Oh well...
X		cat > $topmsg <<EOH
Subject: $prog_name - kit #$part_num / $nfiles
To: $address
X
XEOH
X		# Has edit been requested ?
X		if test $edit = yes
X		then
X			if test $added = yes
X			then
X				# Add message to each part
X				cat $message >> $topmsg
X				# add a blank line
X				echo " " >> $topmsg
X			else
X				# Signals that there is a part #0
X				cat >> $topmsg <<EOM
X[ There is an instruction mail which is labeled: $prog_name - kit #0 / $nfiles ]
X
XEOM
X			fi
X		fi
X		cat $i >> $topmsg
X		$mailer $address < $topmsg
X		rm -f $topmsg
X	else
X		echo $this_prog: could not open $i >&2
X	fi
done
X
X# Is there a part #0 to send ?
if test $edit = yes -a $added = no
then
X	cat > $topmsg <<EOM
Subject: $prog_name - kit #0 / $nfiles
To: $address
X
X[ This is an instruction message for the $prog_name kit ]
X
XEOM
X	cat >>$topmsg <$message
X	echo Mailing instructions \($prog_name\)
X	$mailer $address < $topmsg
X	rm -f $topmsg
fi
X
X# Clean up
rm -f $message
test $preserve = no && rm -f $partname??
X!NO!SUBS!
chmod 755 mailkit
X$eunicefix mailkit
END_OF_FILE
if test 6605 -ne `wc -c <'kit/mailkit.SH'`; then
    echo shar: \"'kit/mailkit.SH'\" unpacked with wrong size!
fi
chmod +x 'kit/mailkit.SH'
# end of 'kit/mailkit.SH'
fi
if test -f 'kit/unkit.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kit/unkit.SH'\"
else
echo shar: Extracting \"'kit/unkit.SH'\" \(4063 characters\)
sed "s/^X//" >'kit/unkit.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X	if test ! -f config.sh; then
X		ln ../config.sh . || \
X		ln ../../config.sh . || \
X		ln ../../../config.sh . || \
X		(echo "Can't find config.sh."; exit 1)
X	fi 2>/dev/null
X	. config.sh
X	;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting kit/unkit (with variable substitutions)"
X$spitshell >unkit <<!GROK!THIS!
X$startsh
X# @(#) unkit, reversal of kit
X# @(#) (c) E. Mogenet April 1990
X# @(#) (c) R. Manfredi, 1990 1991
X
X# $Id: unkit.SH,v 2.0.1.7 91/12/08 14:56:49 ram Exp $
X#
X# $Log:	unkit.SH,v $
X# Revision 2.0.1.7  91/12/08  14:56:49  ram
X# patch10: added space in the credit for Emmanuel Mogenet
X# 
X# Revision 2.0.1.6  91/11/25  15:52:14  ram
X# patch9: added a trap to clean-up things in case of interruption
X# patch9: now knows about minikit and zzz.minikit file
X# 
X# Revision 2.0.1.5  91/11/25  12:09:54  ram
X# patch8: random clean-up for consistency with other scripts
X# 
X# Revision 2.0.1.4  91/07/30  17:31:49  ram
X# patch6: config.sh now carries the symbols defined in patchlevel.h
X# patch6: not all the tar support -o option for ownership overwrite
X# patch6: the -v option for zcat did not make much sense
X# patch6: (last two reported by Richard Bielak <richieb@bony.com>)
X# 
X# Revision 2.0.1.3  91/05/27  14:29:22  ram
X# patch5: usage is no longer printed by a function
X# patch5: version number is no longer hardwired
X# 
X# Revision 2.0.1.2  91/04/30  13:34:11  ram
X# patch3: unkit now carries a built-in unshar
X# 
X# Revision 2.0.1.1  91/04/01  15:51:53  ram
X# patch1: unkit updated to deal with new naming conventions
X# patch1: for some reason, log messages from 1.0 had been kept
X# 
X# Revision 2.0  91/02/19  15:50:03  ram
X# Baseline for first official release.
X# 
X
X# Which patch-level is it ?
pl='$PATCHLEVEL'
version='$VERSION'
X
X!GROK!THIS!
X
case "$d_taropt_o" in
X"$define") opt='xvof';;
X*) opt='xvf';;
esac
echo "tar_opt='$opt'" >> unkit
X
X$spitshell >>unkit <<'!NO!SUBS!'
decoding=hexdecode			# Default decoding program
preserve=yes				# Preserve input files by default
X
X# In case we are interrupted, remove all the temporary files
trap 'test -f zzz.minikit && rm -f `cat zzz.minikit` zzz.minikit; \
X	rm -f z??.[hb][ea]*.??;  echo >&2 "Aborted."; exit 1' 1 2 3 15
X
X# Old Bourne shells do not have functions
usage='
echo "Usage: unkit [-hlprV] [file1 ... filen]";
echo " "" -h : give this help message.";
echo " "" -l : list the contents of a the kit files.";
echo " "" -p : preserve input files (default).";
echo " "" -r : remove input files if unshar succeeds.";
echo " "" -V : print current version and patch-level.";
exit 1
X'
X
X# Option parsing
for i in $*
do
X	case $i in
X	-p) preserve=yes
X		shift;;
X	-r) if test $tar_opt = xvof
X		then
X			preserve=no
X		fi
X		shift;;
X	-V) echo "unkit $version PL$pl"
X		exit 0;;
X	-h) eval $usage;;
X	-l) tar_opt=tvf
X		preserve=yes
X		shift;;
X	-*) echo "Unknown option $i"
X		eval $usage;;
X	esac
done
X
X# Test for unshar -- we have our own built-in unshar, but the
X# unshar that comes with cshar is smarter in case of errors and
X# much more reliable.
X
X# Use a sub-shell to avoid messages like "sh: unshar not found".
X# The "$a" variable is the parameter set by 'eval' (or empty if none).
if (unshar -n /dev/null) >/dev/null 2>&1
then
X	unshar_cmd='unshar -n $a'
else
X	# Our built-in unshar may not give a meaningful exit status
X	unshar_cmd='sed -n -e "/^#![ 	]*\/bin\/sh/,\$p" $a | /bin/sh'
fi
X
X# If no file name is given, process the standard input
if test $# -eq 0
then
X	eval $unshar_cmd
else
X	for i
X	do
X		# The command expects "$a" to be the parameter
X		eval "a=$i; $unshar_cmd"	&&
X		(test $preserve = no && rm $i)
X	done
fi
X
X# Now check for file names to find how to decode
if test -f z[ace][gbc].ba.aa
then
X	decoding=atob
fi
if test -f zcb.*.aa
then
X	decoding=$decoding" | des -d"
elif test -f zec.*.aa
then
X	decoding=$decoding" | des -d -b"
fi
X
echo "Decoding with $decoding"
X
cat `ls z??.[hb][ea]*.??` |
eval $decoding		|
zcat				|
tar $tar_opt -
X
test -f zzz.minikit && rm -f `cat zzz.minikit` zzz.minikit
rm -f z??.[hb][ea]*.??
X!NO!SUBS!
chmod 755 unkit
X$eunicefix unkit
END_OF_FILE
if test 4063 -ne `wc -c <'kit/unkit.SH'`; then
    echo shar: \"'kit/unkit.SH'\" unpacked with wrong size!
fi
chmod +x 'kit/unkit.SH'
# end of 'kit/unkit.SH'
fi
if test -f 'man/kit.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/kit.SH'\"
else
echo shar: Extracting \"'man/kit.SH'\" \(9636 characters\)
sed "s/^X//" >'man/kit.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X    fi 2>/dev/null
X    . config.sh
X    ;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting man/kit.$manext (with variable substitutions)"
X$rm -f kit.$manext
X$spitshell >kit.$manext <<!GROK!THIS!
X.TH KIT $manext ram
X''' @(#) Manual page for mailing kit -- (c) ram July 1990
X'''
X''' $Id: kit.SH,v 2.0.1.5 91/11/25 15:53:01 ram Exp $
X'''
X''' $Log:	kit.SH,v $
X''' Revision 2.0.1.5  91/11/25  15:53:01  ram
X''' patch9: added kit's -M option to include minikit
X''' patch9: documents the tar -o possible problem
X''' 
X''' Revision 2.0.1.4  91/11/25  12:10:23  ram
X''' patch8: documents new -l option for kit and mailkit
X''' 
X''' Revision 2.0.1.3  91/05/27  14:32:48  ram
X''' patch5: search for config.sh is now silent
X''' patch5: documented new options -d and -n for kit
X''' patch5: new option -n for mailkit
X''' patch5: the 'kit .' bug has now a workaround thanks to -d
X''' patch5: new example to show usage of -d and -n
X''' 
X''' Revision 2.0.1.2  91/04/30  13:38:47  ram
X''' patch3: fixed some English mistakes/misspellings
X''' patch3: unshar is no longer needed to unkit (built-in)
X''' patch3: the NOTE section has been revised
X''' 
X''' Revision 2.0.1.1  91/04/01  15:52:58  ram
X''' patch1: documented the new kit options -x, -k and -X
X''' patch1: new naming conventions for split files are described
X''' 
X''' Revision 2.0  91/02/19  15:50:28  ram
X''' Baseline for first official release.
X''' 
X'''
X.SH NAME
kit, mailkit, unkit \- the ultimate mailing tools
X.SH SYNOPSIS
X\fBkit\fR [ \fB\-EFHMBVXefhpx\fR ] [ \fB\-k\fI key\fR]
X[ \fB\-d\fI dir\fR ] [ \fB\-m\fI address\fR ] [ \fB\-n\fI basename\fR ]
X[ \fB\-l\fI file\fR ] [ \fB\-s\fI name\fR ] \fIdirectories\fR | \fIfiles\fR
X.br
X\fBmailkit\fR [ \fB\-EFVefhp\fR ] [ \fB\-l\fI file\fR ]
X[ \fB\-n\fI partname\fR ] \fItitle\fR [ \fIaddress(es)\fR ]
X.br
X\fBunkit\fR [ \fB\-hlprV\fR ] [ \fIfiles\fR ]
X.SH DESCRIPTION
X\fIKit\fR is the ultimate mailing tool. It enables you to mail
data without any consideration of possible escape sequences or
control characters.
Given a file name or a directory, it builds a single file using
X\fItar\fR(1) and \fIcompress\fR(1). Then this file is hex-encoded
X(option \fB\-H\fR) or ASCII-encoded with \fIbtoa\fR(1)
X(option \fB\-B\fR, which is used by default) before being shell-archived
by \fImakekit\fR(1).
X\fIKit\fR produces files that match "Kit*" regular expression.
This default base name can be changed thanks to \fB\-n\fR option.
On invocation, it removes all previously existing "Kit*" files.
With \fB\-m\fR option, it is possible to give one mail address, and
X\fIkit\fR will invoke \fImailkit\fR to send the archive. There may be
as many \fB\-m\fR options as needed (to send the same archive to more
than a single person).
If there are a lot of recipients, you may want to store them in a file
and use the \fB\-l\fR option to tell \fIkit\fR where the recipient file
is located.
X.PP
The \fB\-E\fR, \fB\-F\fR, \fB\-e\fR, \fB\-f\fR and \fB\-p\fR options are
passed on to \fImailkit\fR, so
if no \fB\-m\fR option is used, they will be ignored. When sending
files with \fB\-m\fR, the subject of the message holds the name of
the first file given in the command line (supposed to be the name
of the kit). It is possible to overwrite this default by using the
X\fB\-s\fR option.
X.PP
If you want to send sensible data, it is possible to encrypt them using
a public-domain implementation of Data Encryption Standard (DES).
The \fB\-x\fR option will use the Cipher Block Chaining mode (default),
while \fB\-X\fR requests the Electronic Code Book mode. If you do not
specify the encryption key with \fB\-k\fR, \fIdes\fR(1) will prompt you
for one. If you use the \fB\-k\fR option, \fB\-x\fR is assumed.
X.PP
It may happen that there are no write permissions in the directory
where the root directory to be kitted lies. The \fB-d\fR option enables
you to specify another directory, where all the temporary files will be
stored. If you use something like \fI/tmp\fR, you must be careful to use
X\fB\-n\fR to change the base name used (in case someone else is doing
the same thing, otherwise files may get mangled).
X.PP
When you send a kit to someone which may not have \fIkit\fR, the \fB\-M\fR
option may be used to include a \fIminikit\fR script, which is a minimal
set of commands to unkit an unencrypted ASCII-encoded kit. The overhead is
small (around 4K) and some instructions are provided in the header of every
kit part. The minikit is usually called \fIminikit\fR, but should you
already have a file with that name in your distribution, it will be renamed
X\fIMINIKIT\fR. If by chance (!) you named one of your files MINIKIT, then
a unique name of the form \fImkitXXXXX\fR will be generated (XXXXX stands
for the PID of the \fIkit\fR process).
X.PP
X\fIMailkit\fR takes "Kit*" files and sends them to a list of addresses.
The \fB\-n\fR option can be used to change that base name, if necessary.
XEach message sent corresponds to one part and has its \`Subject:'
field set to the number of this part with the \fItitle\fR given, and you
also have the total number of parts, so that missing parts can easily
be located.
X.PP
The options \fB\-E\fR and \fB\-e\fR from \fImailkit\fR enable you to give
the recipient some instructions. They both call an editor. At the
top of the file edited, there is a little message, which
will (of course) be stripped from the text you enter, so do not
remove it or your own message will be cut instead. With \fB\-E\fR,
the message will be sent in an extra part (#0), while with \fB\-e\fR
it will be included in each part. Empty messages will be ignored.
X.PP
When \fImailkit\fR is given a \fB\-l\fR option, it takes the file name
as a file whith recipients addresses in it and adds the optional addresses that
may be given on the command line. Addresses in the recipient file are
separated with spaces, commas or new lines. Shell-style comments starting with
a pound sign (#) are allowed.
X.PP
Options \fB\-F\fR and \fB\-f\fR are very similar, but take their
input from stdin (standard input) instead of calling an editor.
Option \fB\-p\fR asks \fImailkit\fR for preserving mailed files. They
are removed by default.
X.PP
X\fIUnkit\fR is used to restore the original files. The argument is
a list of archive files (or mail files, as \fIunshar\fR(1), which
is called by \fIunkit\fR, can deal with mail headers).
Input files are not removed unless option \fB\-r\fR is given. By default,
option \fB\-p\fR is used to preserve the input file(s).
If no file name is given to \fIunkit\fR, the standard input is processed.
This is useful to process messages directly from a mail user agent.
X.PP
If you want to know what \fIunkit\fR will create without actually
doing it, use the \fB\-l\fR option. With this option, \fB\-r\fR is
ignored.
X.PP
XFor all of these commands, option \fB\-V\fR prints the version
number with the current patch level and exits, while \fB\-h\fR gives
a little help message with the syntax and the meaning of the options.
X.SH FILES
X.PD 0
X.TP 20
Kit*
files generated by \fIkit\fR
X.TP
X{zag,zcb,zec}.hex.*
temporary files used by \fIkit\fR and \fIunkit\fR for datas which
are hex-encoded.
X.TP
X{zag,zcb,zec}.ba.*
temporary files used by \fIkit\fR and \fIunkit\fR for datas which
are ASCII-encoded.
X.TP
zag*
non encrypted files.
X.TP
zcb*
data encrypted using CBC mode.
X.TP
zec
data encrypted using ECB mode.
X.TP
zzz.minikit
file holding the name of the provided minikit script.
X.TP
X$privlib/minikit
the script which may be used to unkit a distribution when the kit
package is not available.
X.PD
X.SH NOTE
X.PP
In order to use kit, you need to install \fBcshar\fR in your
PATH (programs needed are \fIshar\fR, \fImakekit\fR).
Moreover, \fIhexdecode\fR, \fIhexencode\fR, \fIatob\fR and \fIbtoa\fR
must be installed and \fIcompress\fR must be available.
If any of these is missing, this mailing kit is useless.
X.PP
X.I Unkit
has its own \fIunshar\fR built-in, but it will not be used if
X\fIunshar\fR is installed, because it is really simple-minded and
not smart at all in case of errors. However, this is useful if
you do not have \fBcshar\fR, but still want to use \fIunkit\fR.
X.SH EXAMPLES
X.PP
To mail \fIram@educ.emse.fr\fR a directory called XLOCK and all what it may
hold, do:
X.sp
X.in +5
X.B kit XLOCK
X.br
X.B mailkit XLOCK ram@educ.emse.fr
X.in -5
X.sp
X\fIKit\fR will produce files Kit*, and mailkit will send them.
Or, to do it all in one:
X.sp
X.in +5
X.B kit \-m ram@educ.emse.fr XLOCK
X.in -5
X.sp
If you have no write permissions in the current directory, you can
specify an alternate directory for temporary files:
X.sp
X.in +5
X\fBkit \-m ram@eiffel.com \-d /tmp \-n mykit XLOCK\fR
X.in -5
X.sp
To unkit, save the mail messages in files called, e.g. xlock.01 (for
part 01), xlock.02 (for part 02) and so on.
Then do:
X.sp
X.in +5
X.B unkit xlock*
X.in -5
X.sp
XEven if it succeeds, files xlock* will not be removed.
X.SH BUGS
Try "kit .": it is harmless (well, I hope !), and you will quickly
understand the problem. The solution is to use the \fB\-d\fR option.
X.PP
If you use the
X.B \-r
option in
X.I unkit
and one or more kit parts are missing, all the files will be lost.
So use it with care...
X.PP
Some systems cannot extract tar archives with overwriting of ownership
informations (usually this is done with tar option -o).
X.SH "SEE ALSO"
atob($manext), btoa($manext), cshar(1), makekit(1).
X.SH AUTHOR
Raphael Manfredi <ram@eiffel.com>.
X
X\fIKit\fR was developed at the Ecole des Mines, Saint-Etienne,
XFrance.
X!GROK!THIS!
chmod 444 kit.$manext
END_OF_FILE
if test 9636 -ne `wc -c <'man/kit.SH'`; then
    echo shar: \"'man/kit.SH'\" unpacked with wrong size!
fi
# end of 'man/kit.SH'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
