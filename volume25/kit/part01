Newsgroups: comp.sources.unix
From: ram@eiffel.com (Raphael Manfredi)
Subject: v25i049: kit - the ultimate mailing kit, Part01/04
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: ram@eiffel.com (Raphael Manfredi)
Posting-Number: Volume 25, Issue 49
Archive-Name: kit/part01

[ this is a wrapper for cshar2 that lets you mail arbitrary collections of
  possibly-binary files to someone.  it contains a stripped-down copy of the
  DES implementation from comp.sources.unix Volume 7.			--vix ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 4)."
# Contents:  MANIFEST Makefile.SH README btoa btoa/Makefile.SH
#   btoa/atob.c btoa/btoa.c btoa/hexdecode.c btoa/hexencode.c des
#   des/Makefile.SH des/README des/des.1 des/des.3 des/descert.c
#   des/getopt.c des/getpass.c des/misc.c des/testdata install.SH kit
#   kit/Makefile.SH kit/minikit man man/Makefile.SH man/atob.SH
#   man/btoa.SH man/mailkit.SH man/unkit.SH patchlevel.h
# Wrapped by vixie@cognition.pa.dec.com on Thu Dec 19 21:18:28 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1770 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
README                     Read it
MANIFEST                   This shipping list
Configure                  Portability tool
Makefile.SH                Main makefile
btoa/Makefile.SH           Makefile for btoa and al.
btoa/atob.c                For ascii to binary decoding
btoa/btoa.c                For binary to ascii encoding
btoa/hexdecode.c           Hex-decoding
btoa/hexencode.c           Hex-encoding
config.h.SH                Produces config.h
des/Makefile.SH            Makefile for des
des/README                 Informations on des
des/des.1                  Manual page for des(1)
des/des.3                  Description of the des functions
des/des.c                  Software DES functions from Phil Karn
des/descert.c              Cerifies the des(1) command
des/getopt.c               Public domain implementaion of getopt()
des/getpass.c              Reads a key from the terminal
des/main.c                 Main file for des
des/misc.c                 Implementations of memset() and memcpy()
des/testdata               A set of tests to certify the des
install.SH                 BSD-like installation script
kit/Makefile.SH            Makefile for scripts
kit/kit.SH                 The main script-shell
kit/mailkit.SH             Mails parts generated by "kit"
kit/minikit                The minikit script for kit extraction
kit/unkit.SH               Reversal of "kit"
man/Makefile.SH            Makefile for manual pages
man/atob.SH                Manual page for "atob"
man/btoa.SH                Manual page for atob/btoa
man/kit.SH                 The manual page for "kit"
man/mailkit.SH             The manual page for "mailkit"
man/unkit.SH               The manual page for "unkit"
patchlevel.h               Current patch level value
END_OF_FILE
if test 1770 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.SH'\"
else
echo shar: Extracting \"'Makefile.SH'\" \(1456 characters\)
sed "s/^X//" >'Makefile.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X	if test ! -f config.sh; then
X		ln ../config.sh . || \
X		ln ../../config.sh . || \
X		ln ../../../config.sh . || \
X		(echo "Can't find config.sh."; exit 1)
X	fi 2>/dev/null
X	. config.sh
X	;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting Makefile (with variable substitutions)"
X$spitshell >Makefile <<!GROK!THIS!
X#
X#	Makefile for kit
X#
X
X# $Id: Makefile.SH,v 2.0.1.4 91/12/08 14:53:40 ram Exp $
X#
X# $Log:	Makefile.SH,v $
X# Revision 2.0.1.4  91/12/08  14:53:40  ram
X# patch10: make clobber was not removing cppstdin
X# 
X# Revision 2.0.1.3  91/11/25  12:03:02  ram
X# patch8: this file was stamped with a wrong package name
X# 
X# Revision 2.0.1.2  91/05/27  14:14:19  ram
X# patch5: some dumb make failed on previous makefile
X# 
X# Revision 2.0.1.1  91/04/01  15:34:43  ram
X# patch1: added des target
X# 
X# Revision 2.0  91/02/19  15:48:41  ram
X# Baseline for first official release.
X# 
X
SHELL = /bin/sh
X
SUBDIRS = btoa kit man des
RM = $rm
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
X
X#
X#	Building rules
X#
X
all install clean realclean: makefiles
X	-@for dir in $(SUBDIRS); do \
X		(cd $$dir && make $@) \
X	done
X
makefiles:
X	-@for dir in $(SUBDIRS); do \
X		(cd $$dir && if test ! -f Makefile; then \
X			sh Makefile.SH; fi) \
X	done
X
clobber: makefiles
X	-@for dir in $(SUBDIRS); do \
X		(cd $$dir && make $@) \
X	done
X	$(RM) -f config.h config.sh Makefile install cppstdin
X!NO!SUBS!
chmod 755 Makefile
X$eunicefix Makefile
END_OF_FILE
if test 1456 -ne `wc -c <'Makefile.SH'`; then
    echo shar: \"'Makefile.SH'\" unpacked with wrong size!
fi
chmod +x 'Makefile.SH'
# end of 'Makefile.SH'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(2822 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X                             kit 2.0
X
X             Copyright (c) 1990 1991, Raphael Manfredi
X
You may copy this kit in whole or in part as long as you don't try to
make money off it, or pretend you wrote it.
X------------------------------------------------------------------------
The ultimate mailing kit -- Assumes you own cshar (written by Rich Salz)
X
Please read all the directions below before you proceed any further, and
then follow them carefully.
X
After you have unpacked your kit, you should have all the files listed
in MANIFEST.
X
If you only wish to use unkit, then CSHAR is not necessary, though
strongly recommended.
X
In order to use kit, you need to install CSHAR in your PATH (programs
needed are shar, makekit and unshar). Compress must be available. If you
miss one of those, send me a mail: ram@eiffel.com (Raphael Manfredi).
X
Moreover, hexdecode, hexencode, atob and btoa must be installed. The
public-domain implementation of des, which is provided with kit, must
also be in your PATH if you want to use the encryption facilities.
X
X
INSTALLATION
X
X1) Run Configure. This will figure out various things about your
system. After it has been completed, it will produce config.h and
config.sh.
X
You might have to trim # comments from the front of Configure if your
shell doesn't handle them, but any other comments will be taken care of.
X
X2) Run make.
X
X3) If make succeeded, you may wish to do make install. Be sure your
rights are correct (if you install manual pages, you may need
super-user privileges).
X
X4) Read the manual entries before running.
X
X5) IMPORTANT! Communicate any problem and suggested patches to
me, ram@eiffel.com (Raphael Manfredi), so we can keep this
distribution in sync. If you have a problem, there will be someone
who might have had it or will have it too.
X
If possible, send me patches such that the patch program will
apply them. Context diffs are the best, then normal diffs. Do not
send ed scripts: I have probably changed my copy since the version
you got.
X
X6) After everything is installed, you can do "make clobber". This will
clean up everything and let you re-distribute this kit, without
carrying useless files. You should keep this distribution intact, so
that future patches will be applicable.
X
X7) I have an automatic patch sender. Send me a mail of the following
form:
X
X	Subject: Command
X	@SH mailhelp PATH
X
and you will get instructions about how to use it. PATH stands for
YOUR e-mail address, either in INTERNET form or in bang notation.
X
X
CREDITS
X
Kit relies on two public-domain softwares:
X
X	- cshar, written by Rich Salz.
X	- des, written by Phil Karn, which is provided with kit.
X
To maintain and configure kit, I use the dist 2.0 package written
by Larry Wall with some significant changes. If you wish to get a
copy of it, feel free to ask me.
X
X	-- Raphael
END_OF_FILE
if test 2822 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'btoa' ; then
    echo shar: Creating directory \"'btoa'\"
    mkdir 'btoa'
fi
if test -f 'btoa/Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'btoa/Makefile.SH'\"
else
echo shar: Extracting \"'btoa/Makefile.SH'\" \(1270 characters\)
sed "s/^X//" >'btoa/Makefile.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X    fi 2>/dev/null
X    . config.sh
X    ;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting btoa/Makefile (with variable substitutions)"
X$spitshell >Makefile <<!GROK!THIS!
X#
X# Makefile for kit (sub-directory btoa)
X#
X
X# $Id: Makefile.SH,v 2.0.1.1 91/05/27 14:14:41 ram Exp $
X#
X# $Log:	Makefile.SH,v $
X# Revision 2.0.1.1  91/05/27  14:14:41  ram
X# patch5: some dumb make failed on previous makefile
X# 
X# Revision 2.0  91/02/19  15:49:16  ram
X# Baseline for first official release.
X# 
X
SHELL = /bin/sh
X
CC = $cc
CFLAGS = $ccflags $optimize
RM = $rm
bin = $bin
X
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
BIN = btoa atob hexencode hexdecode
X
all: $(BIN)
X
btoa: btoa.c
X	$(CC) $(CFLAGS) -o $@ $@.c
X
atob: atob.c
X	$(CC) $(CFLAGS) -o $@ $@.c
X
hexencode: hexencode.c
X	$(CC) $(CFLAGS) -o $@ $@.c
X
hexdecode: hexdecode.c
X	$(CC) $(CFLAGS) -o $@ $@.c
X
install: $(BIN)
X	-for file in $(BIN); do \
X		../install -s -m 755 $$file $(bin); \
X	done
X
clean:
X	$(RM) -f *.o $(BIN)
X
realclean clobber: clean
X	$(RM) -f core Makefile config.sh
X!NO!SUBS!
chmod 644 Makefile
X$eunicefix Makefile
END_OF_FILE
if test 1270 -ne `wc -c <'btoa/Makefile.SH'`; then
    echo shar: \"'btoa/Makefile.SH'\" unpacked with wrong size!
fi
chmod +x 'btoa/Makefile.SH'
# end of 'btoa/Makefile.SH'
fi
if test -f 'btoa/atob.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'btoa/atob.c'\"
else
echo shar: Extracting \"'btoa/atob.c'\" \(3277 characters\)
sed "s/^X//" >'btoa/atob.c' <<'END_OF_FILE'
X/*
X
X   ##     #####   ####   #####            ####
X  #  #      #    #    #  #    #          #    #
X #    #     #    #    #  #####           #
X ######     #    #    #  #    #   ###    #
X #    #     #    #    #  #    #   ###    #    #
X #    #     #     ####   #####    ###     ####
X
X	stream filter to change printable ascii from "btoa" back into
X	8 bit bytes if bad chars, or Csums do not match: exit(1)
X	[and NO output]
X
X	Paul Rutter Joe Orost
X
X	Raphael Manfredi (ram) modified this file, in order to produce
X	meaningfull error messages (otherwise, fatal() was called, even
X	when a temporary file could not be created...); added error()
X*/
X
X/*
X * $Id: atob.c,v 2.0 91/02/19 15:49:21 ram Exp $
X *
X * $Log:	atob.c,v $
X * Revision 2.0  91/02/19  15:49:21  ram
X * Baseline for first official release.
X * 
X */
X
X#include <stdio.h>
X
X#define reg register
X
X#define streq(s0, s1)  strcmp(s0, s1) == 0
X
X#define times85(x)	((((((x<<2)+x)<<2)+x)<<2)+x)
X
long int Ceor = 0;
long int Csum = 0;
long int Crot = 0;
long int word = 0;
long int bcount = 0;
X
fatal() {
X  fprintf(stderr, "bad format or Csum to atob\n");
X  exit(1);
X}
X
error(s)
char *s;	/* the error message */
X{
X  fprintf(stderr, "%s\n", s);
X  exit(1);
X}
X
X#define DE(c) ((c) - '!')
X
decode(c) reg c;
X{
X  if (c == 'z') {
X    if (bcount != 0) {
X      fatal();
X    } 
X    else {
X      byteout(0);
X      byteout(0);
X      byteout(0);
X      byteout(0);
X    }
X  } 
X  else if ((c >= '!') && (c < ('!' + 85))) {
X    if (bcount == 0) {
X      word = DE(c);
X      ++bcount;
X    } 
X    else if (bcount < 4) {
X      word = times85(word);
X      word += DE(c);
X      ++bcount;
X    } 
X    else {
X      word = times85(word) + DE(c);
X      byteout((int)((word >> 24) & 255));
X      byteout((int)((word >> 16) & 255));
X      byteout((int)((word >> 8) & 255));
X      byteout((int)(word & 255));
X      word = 0;
X      bcount = 0;
X    }
X  } 
X  else {
X    fatal();
X  }
X}
X
XFILE *tmp_file;
X
byteout(c) reg c;
X{
X  Ceor ^= c;
X  Csum += c;
X  Csum += 1;
X  if ((Crot & 0x80000000)) {
X    Crot <<= 1;
X    Crot += 1;
X  } 
X  else {
X    Crot <<= 1;
X  }
X  Crot += c;
X  putc(c, tmp_file);
X}
X
main(argc, argv) char **argv;
X{
X  reg c;
X  reg long int i;
X  char tmp_name[100];
X  char buf[100];
X  long int n1, n2, oeor, osum, orot;
X
X  if (argc != 1) {
X    fprintf(stderr,"bad args to %s\n", argv[0]);
X    exit(2);
X  }
X  sprintf(tmp_name, "/usr/tmp/atob.%x", getpid());
X  tmp_file = fopen(tmp_name, "w+");
X  if (tmp_file == NULL) {
X    error("can't create temporary file");
X  }
X  unlink(tmp_name); /* Make file disappear */
X  /*search for header line*/
X  for (;;) {
X    if (fgets(buf, sizeof buf, stdin) == NULL) {
X      error("could not read header line");
X    }
X    if (streq(buf, "xbtoa Begin\n")) {
X      break;
X    }
X  }
X
X  while ((c = getchar()) != EOF) {
X    if (c == '\n') {
X      continue;
X    } 
X    else if (c == 'x') {
X      break;
X    } 
X    else {
X      decode(c);
X    }
X  }
X  if (scanf("btoa End N %ld %lx E %lx S %lx R %lx\n", &n1, &n2, &oeor, &osum, &orot) != 5) {
X    error("could not read check sum");
X  }
X  if ((n1 != n2) || (oeor != Ceor) || (osum != Csum) || (orot != Crot)) {
X    fatal();
X  } 
X  else {
X    /*copy OK tmp file to stdout*/;
X    fseek(tmp_file, 0L, 0);
X    for (i = n1; --i >= 0;) {
X      putchar(getc(tmp_file));
X    }
X  }
X  exit(0);
X}
END_OF_FILE
if test 3277 -ne `wc -c <'btoa/atob.c'`; then
    echo shar: \"'btoa/atob.c'\" unpacked with wrong size!
fi
# end of 'btoa/atob.c'
fi
if test -f 'btoa/btoa.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'btoa/btoa.c'\"
else
echo shar: Extracting \"'btoa/btoa.c'\" \(2696 characters\)
sed "s/^X//" >'btoa/btoa.c' <<'END_OF_FILE'
X/*
X
X #####    #####   ####     ##             ####
X #    #     #    #    #   #  #           #    #
X #####      #    #    #  #    #          #
X #    #     #    #    #  ######   ###    #
X #    #     #    #    #  #    #   ###    #    #
X #####      #     ####   #    #   ###     ####
X
X	btoa: version 4.0
X	stream filter to change 8 bit bytes into printable ascii
X	computes the number of bytes, and three kinds of simple checksums
X	incoming bytes are collected into 32-bit words, then printed in
X	base 85 exp(85,5) > exp(2,32)
X	the ASCII characters used are between '!' and 'u'
X	'z' encodes 32-bit zero; 'x' is used to mark the end of encoded data.
X
X	Paul Rutter Joe Orost
X*/
X
X/*
X * $Id: btoa.c,v 2.0 91/02/19 15:49:25 ram Exp $
X *
X * $Log:	btoa.c,v $
X * Revision 2.0  91/02/19  15:49:25  ram
X * Baseline for first official release.
X * 
X */
X
X#include <stdio.h>
X
X#define reg register
X
X#define MAXPERLINE 78
X
long int Ceor = 0;
long int Csum = 0;
long int Crot = 0;
X
long int ccount = 0;
long int bcount = 0;
long int word;
X
X#define EN(c)	(int) ((c) + '!')
X
encode(c) reg c;
X{
X  Ceor ^= c;
X  Csum += c;
X  Csum += 1;
X  if ((Crot & 0x80000000)) {
X    Crot <<= 1;
X    Crot += 1;
X  } 
X  else {
X    Crot <<= 1;
X  }
X  Crot += c;
X
X  word <<= 8;
X  word |= c;
X  if (bcount == 3) {
X    wordout(word);
X    bcount = 0;
X  } 
X  else {
X    bcount += 1;
X  }
X}
X
wordout(word) reg long int word;
X{
X  if (word == 0) {
X    charout('z');
X  } 
X  else {
X    reg int tmp = 0;
X
X    if (word < 0)
X    { /* Because some don't support unsigned long */
X      tmp = 32;
X      word = word - (long)(85 * 85 * 85 * 85 * 32);
X    }
X    if (word < 0) {
X      tmp = 64;
X      word = word - (long)(85 * 85 * 85 * 85 * 32);
X    }
X    charout(EN((word / (long)(85 * 85 * 85 * 85)) + tmp));
X    word %= (long)(85 * 85 * 85 * 85);
X    charout(EN(word / (85 * 85 * 85)));
X    word %= (85 * 85 * 85);
X    charout(EN(word / (85 * 85)));
X    word %= (85 * 85);
X    charout(EN(word / 85));
X    word %= 85;
X    charout(EN(word));
X  }
X}
X
charout(c) {
X  putchar(c);
X  ccount += 1;
X  if (ccount == MAXPERLINE) {
X    putchar('\n');
X    ccount = 0;
X  }
X}
X
main(argc,argv)
char **argv;
X{
X  reg c;
X  reg long int n;
X
X  if (argc != 1) {
X    fprintf(stderr,"bad args to %s\n", argv[0]);
X    exit(2);
X  }
X  printf("xbtoa Begin\n");
X  n = 0;
X  while ((c = getchar()) != EOF) {
X    encode(c);
X    n += 1;
X  }
X  while (bcount != 0) {
X    encode(0);
X  }
X  /* n is written twice as crude cross check*/
X  if (ccount == 0) /* ccount == 0 means '\n' just written in charout() */
X    ; /* this avoids bug in BITNET, which changes blank line to spaces */
X  else
X    putchar('\n');
X  printf("xbtoa End N %ld %lx E %lx S %lx R %lx\n", n, n, Ceor, Csum, Crot);
X  exit(0);
X}
END_OF_FILE
if test 2696 -ne `wc -c <'btoa/btoa.c'`; then
    echo shar: \"'btoa/btoa.c'\" unpacked with wrong size!
fi
# end of 'btoa/btoa.c'
fi
if test -f 'btoa/hexdecode.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'btoa/hexdecode.c'\"
else
echo shar: Extracting \"'btoa/hexdecode.c'\" \(1276 characters\)
sed "s/^X//" >'btoa/hexdecode.c' <<'END_OF_FILE'
X
X/*
X
X #    #  ######  #    #  #####   ######   ####    ####   #####   ######
X #    #  #        #  #   #    #  #       #    #  #    #  #    #  #
X ######  #####     ##    #    #  #####   #       #    #  #    #  #####
X #    #  #         ##    #    #  #       #       #    #  #    #  #        ###
X #    #  #        #  #   #    #  #       #    #  #    #  #    #  #        ###
X #    #  ######  #    #  #####   ######   ####    ####   #####   ######   ###
X
X	Converts hex from stdin to stdout.
X
X	R. Manfredi and E. Mogenet, June 1990.
X*/
X
X/*
X * $Id: hexdecode.c,v 2.0 91/02/19 15:49:29 ram Exp $
X *
X * $Log:	hexdecode.c,v $
X * Revision 2.0  91/02/19  15:49:29  ram
X * Baseline for first official release.
X * 
X */
X
X#include <stdio.h>
X
static char	rcs_id[] = "@(#)hexdecode, convert hex from stdin to stdout";
X
X#define ishexa(x) (((x)>='0' && (x)<='9') || ((x)>='A' && (x)<='F'))
X#define tohexa(x) ( (x)>='A' ? (x)-'A'+0xA : (x)-'0' )
X
main(argc, argv)
int	argc;
char	**argv;
X{
X	int	c1, c2;
X
X	while (EOF != (c1 = getchar())) {
X		if (ishexa(c1)) {
X			c2 = getchar();
X			if (ishexa(c2))
X				putchar((tohexa(c1) << 4) | (tohexa(c2)));
X			else
X				goto corrupted;
X		} else if ( c1 != '\n' ) {
corrupted:
X			fprintf(stderr, "%s: file corrupted\n", argv[0]);
X			exit(1);
X		}
X	}
X	exit(0);
X}
X
X
END_OF_FILE
if test 1276 -ne `wc -c <'btoa/hexdecode.c'`; then
    echo shar: \"'btoa/hexdecode.c'\" unpacked with wrong size!
fi
# end of 'btoa/hexdecode.c'
fi
if test -f 'btoa/hexencode.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'btoa/hexencode.c'\"
else
echo shar: Extracting \"'btoa/hexencode.c'\" \(1066 characters\)
sed "s/^X//" >'btoa/hexencode.c' <<'END_OF_FILE'
X/*
X
X #    #  ######  #    #  ######  #    #   ####    ####   #####   ######
X #    #  #        #  #   #       ##   #  #    #  #    #  #    #  #
X ######  #####     ##    #####   # #  #  #       #    #  #    #  #####
X #    #  #         ##    #       #  # #  #       #    #  #    #  #        ###
X #    #  #        #  #   #       #   ##  #    #  #    #  #    #  #        ###
X #    #  ######  #    #  ######  #    #   ####    ####   #####   ######   ###
X
X	stdout = hexa(stdin)
X
X	R. Manfredi and E. Mogenet
X*/
X
X/*
X * $Id: hexencode.c,v 2.0 91/02/19 15:49:33 ram Exp $
X *
X * $Log:	hexencode.c,v $
X * Revision 2.0  91/02/19  15:49:33  ram
X * Baseline for first official release.
X * 
X */
X
X#include <stdio.h>
X
static char	rcs_id[] = "@(#)hexencode, stdout = hexa(stdin)";
X
X#define QUARTET 0xF
static char	hexa[] = "0123456789ABCDEF";
X
main()
X{
X	int	c;
X	int	jump;
X
X
X	jump = 0;
X	while (EOF != (c = getchar())) {
X		putchar(hexa[(c>>4) & QUARTET]);
X		putchar(hexa[c & QUARTET]);
X		jump += 2;
X		if ( jump > 75 ) {
X			putchar('\n');
X			jump = 0;
X		}
X	}
X	putchar('\n');
X	exit(0);
X}
X
X
END_OF_FILE
if test 1066 -ne `wc -c <'btoa/hexencode.c'`; then
    echo shar: \"'btoa/hexencode.c'\" unpacked with wrong size!
fi
# end of 'btoa/hexencode.c'
fi
if test ! -d 'des' ; then
    echo shar: Creating directory \"'des'\"
    mkdir 'des'
fi
if test -f 'des/Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des/Makefile.SH'\"
else
echo shar: Extracting \"'des/Makefile.SH'\" \(1473 characters\)
sed "s/^X//" >'des/Makefile.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X	if test ! -f config.sh; then
X		ln ../config.sh . || \
X		ln ../../config.sh . || \
X		ln ../../../config.sh . || \
X		(echo "Can't find config.sh."; exit 1)
X	fi 2>/dev/null
X	. config.sh
X	;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting des/Makefile (with variable substitutions)"
X$spitshell >Makefile <<!GROK!THIS!
X#
X# Makefile for kit (sub-directory des)
X#
X
X# $Id: Makefile.SH,v 2.0.1.3 91/11/25 12:03:16 ram Exp $
X#
X# $Log:	Makefile.SH,v $
X# Revision 2.0.1.3  91/11/25  12:03:16  ram
X# patch8: this file was stamped with a wrong package name
X# 
X# Revision 2.0.1.2  91/05/27  14:15:38  ram
X# patch5: some dumb make failed on previous makefile
X# 
X# Revision 2.0.1.1  91/04/01  15:38:51  ram
X# patch1: created
X# 
X
SHELL = /bin/sh
X
ALL = certify des
CC = $cc
CFLAGS = $ccflags $optimize
MAKE = make
RM = $rm
bin = $bin
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
X
all: $(ALL)
X
des: main.o des.o getpass.o misc.o getopt.o
X	$(CC) $(CFLAGS) -o des main.o des.o getpass.o misc.o getopt.o
X
descert: descert.o des.o
X	$(CC) $(CFLAGS) -o descert descert.o des.o
X
certify: testdata
X	$(MAKE) $(MFLAGS) descert
X	if ./descert < testdata; then touch certify; $(RM) descert descert.o; fi
X
install: des
X	../install -s -m 755 des $(bin)
X	@echo "	Warning: manual pages for des not installed."
X
clean:
X	rm -f *.o des descert
X
realclean clobber: clean
X	$(RM) -f certify core Makefile config.sh
X!NO!SUBS!
chmod 755 Makefile
X$eunicefix Makefile
END_OF_FILE
if test 1473 -ne `wc -c <'des/Makefile.SH'`; then
    echo shar: \"'des/Makefile.SH'\" unpacked with wrong size!
fi
# end of 'des/Makefile.SH'
fi
if test -f 'des/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des/README'\"
else
echo shar: Extracting \"'des/README'\" \(1687 characters\)
sed "s/^X//" >'des/README' <<'END_OF_FILE'
Here is an excerpt from the original public-domain DES package, written
by Phil Karn and cleaned up by Bdale Garbee. I removed all the unneeded
stuff for kit, and I added some defines in the code, so that it can
be meta-configured. I also rewrote the Makefile.
X
I left the two man pages des.1 and des.3, but the main Makefile won't
install them, because they may conflict with already existing manual
pages. However, des itself is installed, because kit needs it for
its encryption facilities.
X
Raphael Manfredi <ram@eiffel.com>
X
X- - - - -
X
Phil asked me to clean this up slightly and package it for distribution.
I've got it running on my Symmetric 4.2bsd system, Phil reports it runs fine
on a variety of systems at Bellcore.  Note that getopt is required but not
provided, as there is already a getopt package in the mod.sources archives.
X
Bdale Garbee, N3EUA  870401	
winfree!bdale aka bdale%winfree.uucp@flash.bellcore.com
X
X- - - - -
X
This package contains a DES subroutine library based on the original public
domain code by James Gillogly, but made faster and more flexible. Commands
using this library have been added for testing and for encrypting and
decrypting files (compatible with the DES command under Sun UNIX), among
other things.
X
Run make. That will compile everything and run test data (from the NBS
certification suite) through it.  It runs as-is under UNIX. It will run
under MS-DOS with a few minor changes: make sure you define LITTLE_ENDIAN
when compiling des.c, and change the name of the console in getpass.c.  If
you have the byte order flag set wrong, you will get ENCRYPT FAIL messages
when the descert test is run.
X
Phil Karn, KA9Q
karn@flash.bellcore.com
END_OF_FILE
if test 1687 -ne `wc -c <'des/README'`; then
    echo shar: \"'des/README'\" unpacked with wrong size!
fi
# end of 'des/README'
fi
if test -f 'des/des.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des/des.1'\"
else
echo shar: Extracting \"'des/des.1'\" \(3926 characters\)
sed "s/^X//" >'des/des.1' <<'END_OF_FILE'
X.TH DES 1  "30 March 1991"
X'''
X''' $Id: des.1,v 2.0.1.1 91/04/01 15:39:16 ram Exp $
X'''
X''' $Log:	des.1,v $
X''' Revision 2.0.1.1  91/04/01  15:39:16  ram
X''' patch1: created
X''' 
X'''
X.SH NAME
des - DES file encryption
X.SH SYNOPSIS
X.PP
X.B des -e|-d [-h] [-k key] [-b]
X.SH DESCRIPTION
X.B Des
is a filter that encrypts or decrypts standard input to standard output
with the Data Encryption Standard (DES).
XEither -e (encrypt) or -d (decrypt) must be specified. If the key is not
given on the command line with the -k option the command will prompt for it
twice, suppressing echo and comparing the two responses to guard against
mistyping.
X.PP
The
X.B des
command is provided to promote secure exchange of data in a standard
fashion.
X.PP
The -h flag controls how the key string is to be interpreted. Without
the -h flag, the key is an ASCII string. Since DES ignores the low
order bit of each key byte, the high order bit is set for odd parity,
thus retaining the information contained in the low order bit. If the
X-h flag is set, the key string is interpreted as 16 hex/ASCII
characters; the low order bit of each byte is again ignored as per the
DES algorithm. This allows the use of any arbitrary 56-bit key,
including bytes representing control characters that could not be typed
if the -h option were not used.
X.PP
By default, DES Cipher Block Chaining (CBC) mode is used, with an initial
vector (IV) of all zeros; if the -b option is specified, Electronic Code
Book (ECB, eight bytes at a time) mode is used instead.
X.PP
The CBC mode treats an entire file as a unit of encryption, that is,
if insertions or deletions are made to the encrypted file then
decryption will not succeed.
CBC mode also ensures  that regularities in clear data do not appear
in the encrypted data.
X.PP
XECB mode treats each 8 bytes as units of encryptions, so if parts
of the encrypted file are modified then other parts may still be
decrypted. Identical values of clear text encrypt to identical values of
cipher text.
X.PP
If the key is an argument to the
X.B des
command, it is potentially visible to users executing
X.BR ps (1)
or a derivative.
To minimize this possibility,
X.B des
takes care to destroy the key argument immediately upon entry.
X.PP
The following sections give information required to implement compatible
facilities in other environments.
X.LP
Since the CBC and ECB modes of DES require units of 8 bytes to be
encrypted, files being encrypted by the
X.B des
command have 1 to 8 bytes appended to them to cause them to be a
multiple of 8 bytes. The last byte, when decrypted, gives the number
of bytes (0 to 7) which are to be saved of the last 8 bytes. The other
bytes of those appended to the input are randomized before encryption.
If, when decrypting, the last byte is not in the range of 0 to 7 then
either the encrypted file has been corrupted or an incorrect key was
provided for decryption and an error message is printed.
X.LP
The DES
algorithm requires an 8 byte key whose low order bits are assumed to be
odd-parity bits. The ASCII key supplied by the user is zero padded to
X8 bytes and the high order bits are set to be odd-parity bits. The
DES algorithm then ignores the low bit of each ASCII
character, but that bit's information has been preserved in the high
bit due to the parity.
X.LP
The CBC mode of operation always uses an initial value of all zeros for
the initialization vector, so the first 8 bytes of a file are
encrypted the same whether in CBC or ECB mode.
X.PP
XExcept for the -h option, this command is compatible with the
X.B des
command on the Sun Microsystems workstation.
X.SH BUGS
X.LP
It would be better to use a real 56-bit key rather than an
ASCII-based 56-bit pattern.  Knowing that the key was derived from
ASCII radically reduces the time necessary for a brute-force
crytographic attack.
X.SH AUTHOR
Phil Karn, KA9Q.
X.br
Manual page updated by Raphael Manfredi, from the SUN-OS
X.BR des (1)
manual page.
END_OF_FILE
if test 3926 -ne `wc -c <'des/des.1'`; then
    echo shar: \"'des/des.1'\" unpacked with wrong size!
fi
# end of 'des/des.1'
fi
if test -f 'des/des.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des/des.3'\"
else
echo shar: Extracting \"'des/des.3'\" \(2112 characters\)
sed "s/^X//" >'des/des.3' <<'END_OF_FILE'
X.TH DES 3  "24 March 1987"
X'''
X''' $Id: des.3,v 2.0.1.1 91/04/01 15:39:26 ram Exp $
X'''
X''' $Log:	des.3,v $
X''' Revision 2.0.1.1  91/04/01  15:39:26  ram
X''' patch1: created
X''' 
X'''
X.SH NAME
desinit, setkey, endes, dedes, desdone - DES encryption
X.SH SYNOPSIS
X.PP
X.B desinit(mode)
X.B int mode;
X.PP
X.B setkey(key)
X.B char *key;
X.PP
X.B endes(block)
X.B char *block;
X.PP
X.B dedes(block)
X.B char *block;
X.PP
X.B desdone()
X.SH DESCRIPTION
These routines implement both standard and modified forms of the NBS Data
XEncryption Standard (DES). The user must first call
X.B desinit
with one of three operating modes:
X.PP
X0 - Standard, vanilla DES.
X.PP
X1 - DES with the initial and final permutations removed.
As these permutations do not strengthen the algorithm,
they are widely regarded as having no purpose other than to slow
down software implementations.
Removing them speeds it up but of course the algorithm is no longer standard
and it will not be compatible with hardware DES chips.
X.PP
X2 - DES with the initial and final permutations removed, and with independent
X48-bit subkeys for each of the 16 rounds. Needless to say this is even
less standard than mode 1, but if properly used (randomize ALL key bytes --
no padding!) it should strengthen the algorithm.
X.PP
After calling
X.B desinit
the user next calls
X.B setkey.
In modes 0 and 1, 8 key bytes are expected, with the low order bit of
each key byte ignored (parity is not checked). This gives a 56-bit key.
In mode 2, 128 key bytes are expected; the high order 2 bits of each byte are
ignored, giving a 768 bit key.
In this mode, the first 8 bytes will be used in the first round, the
second 8 bytes in the second round, and so on.
X.PP
Once the key is set, the user may perform in-place encryption and decryption
of 8-byte blocks of data with calls to
X.B endes
and
X.B dedes.
X.PP
To free up memory dynamically allocated by
X.B desinit
the user may call
X.B desdone.
If further encryption or decryption is to be done,
X.B desinit
and
X.B setkey
must be called again.
X.SH AUTHOR
Phil Karn, KA9Q, building heavily on the earlier public domain code
by Jim Gillogly.
X
X
END_OF_FILE
if test 2112 -ne `wc -c <'des/des.3'`; then
    echo shar: \"'des/des.3'\" unpacked with wrong size!
fi
# end of 'des/des.3'
fi
if test -f 'des/descert.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des/descert.c'\"
else
echo shar: Extracting \"'des/descert.c'\" \(1356 characters\)
sed "s/^X//" >'des/descert.c' <<'END_OF_FILE'
X/*
X * $Id: descert.c,v 2.0.1.1 91/04/01 15:39:44 ram Exp $
X *
X * $Log:	descert.c,v $
X * Revision 2.0.1.1  91/04/01  15:39:44  ram
X * patch1: created
X * 
X */
X
X#include <stdio.h>
int nfail = 0;
main()
X{
X	char key[8],plain[8],cipher[8],answer[8];
X	int i;
X	int test;
X	int fail;
X
X	desinit(0);
X
X	for(test=0;!feof(stdin);test++){
X
X		get8(key);
X		printf(" K: "); put8(key);
X		setkey(key);
X
X		get8(plain);
X		printf(" P: "); put8(plain);
X
X		get8(answer);
X		printf(" C: "); put8(answer);
X
X		for(i=0;i<8;i++)
X			cipher[i] = plain[i];
X		endes(cipher);
X
X		for(i=0;i<8;i++)
X			if(cipher[i] != answer[i])
X				break;
X		fail = 0;
X		if(i != 8){
X			printf(" Encrypt FAIL");
X			fail++;
X		}
X		dedes(cipher);
X		for(i=0;i<8;i++)
X			if(cipher[i] != plain[i])
X				break;
X		if(i != 8){
X			printf(" Decrypt FAIL");
X			fail++;
X		}
X		if(fail == 0)
X			printf(" OK");
X		else
X			nfail++;
X		printf("\n");
X	}
X
X	stats();
X	/* NOTREACHED */
X}
X
stats()
X{
X	printf("\n    -- ");
X	if (nfail == 0)
X		printf("All tests succesful");
X	else if (nfail == 1)
X		printf("FAILED 1 test");
X	else
X		printf("FAILED %d tests", nfail);
X	printf(".\n\n");
X	(void) exit((nfail == 0)? 0 : 1);
X	/* NOTREACHED */
X}
X
get8(cp)
char *cp;
X{
X	int i,t;
X
X	for(i=0;i<8;i++){
X		scanf("%2x",&t);
X		if(feof(stdin))
X			stats();
X		*cp++ = t;
X	}
X}
put8(cp)
char *cp;
X{
X	int i;
X
X	for(i=0;i<8;i++){
X		printf("%02x",*cp++ & 0xff);
X	}
X}
END_OF_FILE
if test 1356 -ne `wc -c <'des/descert.c'`; then
    echo shar: \"'des/descert.c'\" unpacked with wrong size!
fi
# end of 'des/descert.c'
fi
if test -f 'des/getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des/getopt.c'\"
else
echo shar: Extracting \"'des/getopt.c'\" \(1639 characters\)
sed "s/^X//" >'des/getopt.c' <<'END_OF_FILE'
X/* got this off net.sources */
X/*
X * $Id: getopt.c,v 2.0.1.1 91/04/01 15:39:52 ram Exp $
X *
X * $Log:	getopt.c,v $
X * Revision 2.0.1.1  91/04/01  15:39:52  ram
X * patch1: created
X * 
X */
X
X#include "../config.h"
X#ifndef GETOPT
X#include <stdio.h>
X
X/*
X * get option letter from argument vector
X */
int	opterr = 1,		/* useless, never set or used */
X	optind = 1,		/* index into parent argv vector */
X	optopt;			/* character checked for validity */
char	*optarg;		/* argument associated with option */
X
X#define BADCH	(int)'?'
X#define EMSG	""
X#define tell(s)	fputs(*nargv,stderr);fputs(s,stderr); \
X		fputc(optopt,stderr);fputc('\n',stderr);return(BADCH);
X
getopt(nargc,nargv,ostr)
int	nargc;
char	**nargv,
X	*ostr;
X{
X	static char	*place = EMSG;	/* option letter processing */
X	register char	*oli;		/* option letter list index */
X	char	*index();
X
X	if(!*place) {			/* update scanning pointer */
X		if(optind >= nargc || *(place = nargv[optind]) != '-' || !*++place) return(EOF);
X		if (*place == '-') {	/* found "--" */
X			++optind;
X			return(EOF);
X		}
X	}				/* option letter okay? */
X	if ((optopt = (int)*place++) == (int)':' || !(oli = index(ostr,optopt))) {
X		if(!*place) ++optind;
X		tell(": illegal option -- ");
X	}
X	if (*++oli != ':') {		/* don't need argument */
X		optarg = NULL;
X		if (!*place) ++optind;
X	}
X	else {				/* need an argument */
X		if (*place) optarg = place;	/* no white space */
X		else if (nargc <= ++optind) {	/* no arg */
X			place = EMSG;
X			tell(": option requires an argument -- ");
X		}
X	 	else optarg = nargv[optind];	/* white space */
X		place = EMSG;
X		++optind;
X	}
X	return(optopt);			/* dump back option letter */
X}
X#endif
X
END_OF_FILE
if test 1639 -ne `wc -c <'des/getopt.c'`; then
    echo shar: \"'des/getopt.c'\" unpacked with wrong size!
fi
# end of 'des/getopt.c'
fi
if test -f 'des/getpass.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des/getpass.c'\"
else
echo shar: Extracting \"'des/getpass.c'\" \(2184 characters\)
sed "s/^X//" >'des/getpass.c' <<'END_OF_FILE'
X/*
X * $Id: getpass.c,v 2.0.1.2 91/04/30 13:33:30 ram Exp $
X *
X * $Log:	getpass.c,v $
X * Revision 2.0.1.2  91/04/30  13:33:30  ram
X * patch3: now relies on the new metaconfig symbol SIGNAL_T
X * 
X * Revision 2.0.1.1  91/04/01  15:40:01  ram
X * patch1: created
X * 
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include "../config.h"
X
X/* These defines should be correctly set up by Configure */
X#ifdef I_TERMIOS
X#include <termios.h>
X#endif
X#ifdef I_TERMIO
X#include <termio.h>
X#endif
X#ifdef I_SGTTY
X#include <sgtty.h>
X#endif
X#ifdef I_SYSIOCTL
X#include <sys/ioctl.h>
X#endif
X
X#define	TTY	"/dev/tty"	/* Change to "con" for MS-DOS */
X
X/* Issue prompt and read reply with echo turned off */
char *
getpass(prompt)
char *prompt;
X{
X	register char *cp;
X	int c;
X	FILE *tty;
X	static char pbuf[128];
X
X#ifdef I_SGTTY
X	struct sgttyb ttyb,ttysav;
X#else
X#ifdef I_TERMIOS
X	struct termios ttyb, ttysav;
X#else
X	struct termio ttyb, ttysav;
X#endif
X#endif
X
X	extern SIGNAL_T (*signal())();
X	SIGNAL_T (*sig)();
X
X	if ((tty = fdopen(open(TTY, 2), "r")) == NULL)
X		tty = stdin;
X	else
X		setbuf(tty, (char *)NULL);
X	sig = signal(SIGINT, SIG_IGN);
X
X#ifdef I_SGTTY
X	ioctl(fileno(tty), TIOCGETP, &ttyb);
X	ioctl(fileno(tty), TIOCGETP, &ttysav);
X	ttyb.sg_flags |= RAW;
X	ttyb.sg_flags &= ~ECHO;
X	ioctl(fileno(tty), TIOCSETP, &ttyb);
X#else
X#ifdef I_TERMIOS
X	tcgetattr(fileno(tty), &ttyb);
X	tcgetattr(fileno(tty), &ttysav);
X#else
X	ioctl(fileno(tty), TCGETA, &ttyb);
X	ioctl(fileno(tty), TCGETA, &ttysav);
X#endif
X#ifdef CBREAK
X	ttyb.c_lflag |= CBREAK;
X#endif
X#ifdef RAW
X	ttyb.c_lflag |= RAW;
X#endif
X	ttyb.c_lflag &= ~ECHO;
X#ifdef I_TERMIOS
X	tcsetattr(fileno(tty), TCSANOW, &ttyb);
X#else
X	ioctl(fileno(tty), TCSETA, &ttyb);
X#endif
X#endif
X
X	fprintf(stderr, "%s", prompt);
X	fflush(stderr);
X	cp = pbuf;
X	for (;;) {
X		c = getc(tty);
X		if(c == '\r' || c == '\n' || c == EOF)
X			break;
X		if (cp < &pbuf[127])
X			*cp++ = c;
X	}
X	*cp = '\0';
X	fprintf(stderr,"\r\n");
X	fflush(stderr);
X
X#ifdef I_SGTTY
X	ioctl(fileno(tty), TIOCSETP, &ttysav);
X#else
X#ifdef I_TERMIOS
X	tcsetattr(fileno(tty), TCSANOW, &ttysav);
X#else
X	ioctl(fileno(tty), TCSETA, &ttysav);
X#endif
X#endif
X
X	signal(SIGINT, sig);
X	if (tty != stdin)
X		fclose(tty);
X	return(pbuf);
X}
END_OF_FILE
if test 2184 -ne `wc -c <'des/getpass.c'`; then
    echo shar: \"'des/getpass.c'\" unpacked with wrong size!
fi
# end of 'des/getpass.c'
fi
if test -f 'des/misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des/misc.c'\"
else
echo shar: Extracting \"'des/misc.c'\" \(526 characters\)
sed "s/^X//" >'des/misc.c' <<'END_OF_FILE'
X/*
X * $Id: misc.c,v 2.0.1.1 91/04/01 15:40:18 ram Exp $
X *
X * $Log:	misc.c,v $
X * Revision 2.0.1.1  91/04/01  15:40:18  ram
X * patch1: created
X * 
X */
X
X#include "../config.h"
X#ifndef MEMSET
X/* Set block of memory to constant */
memset(blk,val,size)
register char *blk;
register char val;
register unsigned size;
X{
X	while(size-- != 0)
X		*blk++ = val;
X}
X#endif
X
X#ifndef MEMCPY
X/* Copy block of memory */
memcpy(dest,src,size)
register char *dest,*src;
register unsigned size;
X{
X	while(size-- != 0)
X		*dest++ = *src++;
X}
X#endif
X
END_OF_FILE
if test 526 -ne `wc -c <'des/misc.c'`; then
    echo shar: \"'des/misc.c'\" unpacked with wrong size!
fi
# end of 'des/misc.c'
fi
if test -f 'des/testdata' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des/testdata'\"
else
echo shar: Extracting \"'des/testdata'\" \(1734 characters\)
sed "s/^X//" >'des/testdata' <<'END_OF_FILE'
X0000000000000000 0000000000000000 8CA64DE9C1B123A7
XFFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF 7359B2163E4EDC58
X3000000000000000 1000000000000001 958E6E627A05557B
X1111111111111111 1111111111111111 F40379AB9E0EC533
X0123456789ABCDEF 1111111111111111 17668DFC7292532D
X1111111111111111 0123456789ABCDEF 8A5AE1F81AB8F2DD
X0000000000000000 0000000000000000 8CA64DE9C1B123A7
XFEDCBA9876543210 0123456789ABCDEF ED39D950FA74BCC4
X7CA110454A1A6E57 01A1D6D039776742 690F5B0D9A26939B
X0131D9619DC1376E 5CD54CA83DEF57DA 7A389D10354BD271
X07A1133E4A0B2686 0248D43806F67172 868EBB51CAB4599A
X3849674C2602319E 51454B582DDF440A 7178876E01F19B2A
X04B915BA43FEB5B6 42FD443059577FA2 AF37FB421F8C4095
X0113B970FD34F2CE 059B5E0851CF143A 86A560F10EC6D85B
X0170F175468FB5E6 0756D8E0774761D2 0CD3DA020021DC09
X43297FAD38E373FE 762514B829BF486A EA676B2CB7DB2B7A
X07A7137045DA2A16 3BDD119049372802 DFD64A815CAF1A0F
X04689104C2FD3B2F 26955F6835AF609A 5C513C9C4886C088
X37D06BB516CB7546 164D5E404F275232 0A2AEEAE3FF4AB77
X1F08260D1AC2465E 6B056E18759F5CCA EF1BF03E5DFA575A
X584023641ABA6176 004BD6EF09176062 88BF0DB6D70DEE56
X025816164629B007 480D39006EE762F2 A1F9915541020B56
X49793EBC79B3258F 437540C8698F3CFA 6FBF1CAFCFFD0556
X4FB05E1515AB73A7 072D43A077075292 2F22E49BAB7CA1AC
X49E95D6D4CA229BF 02FE55778117F12A 5A6B612CC26CCE4A
X018310DC409B26D6 1D9D5C5018F728C2 5F4C038ED12B2E41
X1C587F1C13924FEF 305532286D6F295A 63FAC0D034D9F793
X0101010101010101 0123456789ABCDEF 617B3A0CE8F07100
X1F1F1F1F0E0E0E0E 0123456789ABCDEF DB958605F8C8C606
XE0FEE0FEF1FEF1FE 0123456789ABCDEF EDBFD1C66C29CCC7
X0000000000000000 FFFFFFFFFFFFFFFF 355550B2150E2451
XFFFFFFFFFFFFFFFF 0000000000000000 CAAAAF4DEAF1DBAE
X0123456789ABCDEF 0000000000000000 D5D44FF720683D0D
XFEDCBA9876543210 FFFFFFFFFFFFFFFF 2A2BB008DF97C2F2
END_OF_FILE
if test 1734 -ne `wc -c <'des/testdata'`; then
    echo shar: \"'des/testdata'\" unpacked with wrong size!
fi
# end of 'des/testdata'
fi
if test -f 'install.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'install.SH'\"
else
echo shar: Extracting \"'install.SH'\" \(3781 characters\)
sed "s/^X//" >'install.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X	if test ! -f config.sh; then
X		ln ../config.sh . || \
X		ln ../../config.sh . || \
X		ln ../../../config.sh . || \
X		(echo "Can't find config.sh."; exit 1)
X	fi 2>/dev/null
X	. config.sh
X	;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting install (with variable substitutions)"
X$spitshell >install <<!GROK!THIS!
X$startsh
X# @(#) Installing script accepting bsd-style arguments
X# Derived from a script found in the X11R4 distribution.
X
X# $Id: install.SH,v 2.0.1.2 91/07/30 17:20:35 ram Exp $
X#
X# $Log:	install.SH,v $
X# Revision 2.0.1.2  91/07/30  17:20:35  ram
X# patch6: new install.SH script
X# 
X# Revision 2.0.1.1  91/05/27  14:20:35  ram
X# patch5: mkdir_p is now eval'ed instead of being a function
X# patch5: explicitely exit with a zero status when all is done
X# 
X# Revision 2.0  91/02/19  15:49:42  ram
X# Baseline for first official release.
X# 
X
chown='$chown'
chmod='$chmod'
chgrp='$chgrp'
rm='$rm'
mv='$mv'
test='$test'
sed='$sed'
X!GROK!THIS!
X$spitshell >>install <<'!NO!SUBS!'
X
mode=""
dst=""
src=""
dostrip=""
newdir=""
uid=""
gid=""
X
X# simulates mkdir -p
mkdir_p='
name=$1;
create='';
while $test $name; do
X	if $test ! -d "$name"; then
X		create="$name $create";
X		name=`echo $name | $sed -e "s|^[^/]*$||"`;
X		name=`echo $name | $sed -e "s|\(.*\)/.*|\1|"`;
X	else
X		name='';
X	fi;
done;
for file in $create; do
X	mkdir $file && $test $verbose &&
X	echo "install: created directory $file" >&2;
done
X'
X
verbose=''
X
while $test x$1 != x
do
X	case $1 in 
X	-c) shift
X		continue
X		;;
X	-m) mode="$2 "
X		shift
X		shift
X		continue
X		;;
X	-o) uid="$2 "
X		shift
X		shift
X		continue
X		;;
X	-g) gid="$2 "
X		shift
X		shift
X		continue
X		;;
X	-s) dostrip="strip"
X		shift
X		continue
X		;;
X	-d) newdir="$newdir$2 "
X		shift
X		shift
X		continue
X		;;
X	-v) verbose='true'
X		shift
X		;;
X	*) if $test x$src = x
X		then
X			src=$1
X		else
X			dst=$1
X		fi
X		shift
X		continue
X		;;
X	esac
done
X
X# if -d option is used, we have to create the path given
if $test ! x$newdir = x
then
X	for i in $newdir
X	do
X		set x $i
X		shift
X		eval $mkdir_p
X	done
X	exit 0		# -d is the only action
fi
X
if $test x$src = x
then
X	echo "install: no input file specified" >&2
X	exit 1
fi
X
if $test x$dst = x
then
X	echo "install: no destination specified" >&2
X	exit 1
fi
X
srcbase=`basename $src`
dstbase=`basename $dst`
X
X# If the destination is a directory, the target name is srcbase...
if $test -d $dst; then
X	dstbase=$srcbase
else
X	dst="`echo $dst | sed 's,^\(.*\)/.*$,\1,'`"
X	if $test ! -d $dst; then
X		dstbase=$dst
X		dst="."
X	fi
fi
X
X# If the src has a directory, extract the dir name...
if $test "$src" != "$srcbase" -a "$src" != "./$srcbase"; then
X	src="`echo $src | sed 's,^\(.*\)/.*$,\1,'`"
else
X	src="."
fi
X
X# dst is the destination directory and dstbase the base name.
X# srcbase is the base name of source and src the source dir.
X
srcpth=`(cd $src; pwd)`/$srcbase
destpth=`(cd $dst; pwd)`/$dstbase
if $test x$srcpth = x$destpth; then
X	$test $verbose && \
X	echo "install: destination and source are identical"
X	exit 0
fi
X
X# Do the install
X(
X	cd $src
X
X	if $test -f $dst/$dstbase; then
X		$rm -f $dst/$dstbase && $test $verbose &&
X		echo "install: $dst/$dstbase removed"
X	fi
X	if $test -f $dst/$dstbase; then
X		$mv $dst/$dstbase $dst/OLD$dstbase && $test $verbose &&
X		echo "install: $dst/$dstbase renamed as OLD$dstbase"
X	fi
X
X	cp $srcbase $dst/$dstbase && $test $verbose &&
X	echo "install: $srcbase installed as $dst/$dstbase"
X
X	if $test ! x$dostrip = x; then
X		strip $dst/$dstbase 2>/dev/null && $test $verbose &&
X		echo "install: stripped $dst/$dstbase"
X	fi
X
X	if $test ! x$uid = x; then
X		$chown $uid $dst/$dstbase
X	fi
X	if $test ! x$gid = x; then
X		$chgrp $gid $dst/$dstbase
X	fi
X	if $test ! x$mode = x
X	then
X		$chmod $mode $dst/$dstbase
X	fi
X)
X
exit 0
X!NO!SUBS!
chmod 755 install
X$eunicefix install
END_OF_FILE
if test 3781 -ne `wc -c <'install.SH'`; then
    echo shar: \"'install.SH'\" unpacked with wrong size!
fi
chmod +x 'install.SH'
# end of 'install.SH'
fi
if test ! -d 'kit' ; then
    echo shar: Creating directory \"'kit'\"
    mkdir 'kit'
fi
if test -f 'kit/Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kit/Makefile.SH'\"
else
echo shar: Extracting \"'kit/Makefile.SH'\" \(1430 characters\)
sed "s/^X//" >'kit/Makefile.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X	if test ! -f config.sh; then
X		ln ../config.sh . || \
X		ln ../../config.sh . || \
X		ln ../../../config.sh . || \
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. config.sh
X	;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting kit/Makefile (with variable substitutions)"
X$spitshell >Makefile <<!GROK!THIS!
X#
X# Makefile for kit (sub-directory kit)
X#
X
X# $Id: Makefile.SH,v 2.0.1.3 91/11/25 15:49:18 ram Exp $
X#
X# $Log:	Makefile.SH,v $
X# Revision 2.0.1.3  91/11/25  15:49:18  ram
X# patch9: now installs minikit in the private kit library
X# 
X# Revision 2.0.1.2  91/11/25  12:03:28  ram
X# patch8: this file was stamped with a wrong package name
X# 
X# Revision 2.0.1.1  91/05/27  14:21:28  ram
X# patch5: some dumb make failed on previous makefile
X# 
X# Revision 2.0  91/02/19  15:49:49  ram
X# Baseline for first official release.
X# 
X
SHELL = /bin/sh
X
RM = $rm
binsh = $scriptdir
libdir = $privlib
X
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
scripts = kit mailkit unkit
scriptsh = kit.SH mailkit.SH unkit.SH
added = Makefile config.sh
X
all: $(scripts)
X
kit: kit.SH
X	sh $@.SH
X
mailkit: mailkit.SH
X	sh $@.SH
X
unkit: unkit.SH
X	sh $@.SH
X
install: $(scripts)
X	-for file in $(scripts); do \
X		../install -m 755 $$file $(binsh); \
X	done
X	../install -m 644 minikit $(libdir)
X
clean:
X	$(RM) -f $(scripts)
X
realclean clobber: clean
X	$(RM) -f $(added)
X!NO!SUBS!
chmod 755 Makefile
X$eunicefix Makefile
END_OF_FILE
if test 1430 -ne `wc -c <'kit/Makefile.SH'`; then
    echo shar: \"'kit/Makefile.SH'\" unpacked with wrong size!
fi
chmod +x 'kit/Makefile.SH'
# end of 'kit/Makefile.SH'
fi
if test -f 'kit/minikit' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kit/minikit'\"
else
echo shar: Extracting \"'kit/minikit'\" \(3119 characters\)
sed "s/^X//" >'kit/minikit' <<'END_OF_FILE'
X#! /bin/sh
export PATH || exec sh $0
trap "rm -f mini_unkit mini_code.c core mini_code; exit 1" 1 2 3 15
echo "Extracting mini kit..."
cat >mini_code.c <<'EOP'
X#include <stdio.h>
X#define reg register
X#define streq(s0, s1)  strcmp(s0, s1) == 0
X#define times85(x)	((((((x<<2)+x)<<2)+x)<<2)+x)
X#define DE(c) ((c) - '!')
long int Ceor = 0;
long int Csum = 0;
long int Crot = 0;
long int word = 0;
long int bcount = 0;
fatal() {
X  fprintf(stderr, "bad format or Csum to atob\n");
X  exit(1);
X}
error(s) char *s;
X{
X  fprintf(stderr, "%s\n", s);
X  exit(1);
X}
decode(c) reg c;
X{
X  if (c == 'z') {
X    if (bcount != 0) {
X      fatal();
X    } 
X    else {
X      byteout(0); byteout(0); byteout(0); byteout(0);
X    }
X  } 
X  else if ((c >= '!') && (c < ('!' + 85))) {
X    if (bcount == 0) {
X      word = DE(c);
X      ++bcount;
X    } 
X    else if (bcount < 4) {
X      word = times85(word);
X      word += DE(c);
X      ++bcount;
X    } 
X    else {
X      word = times85(word) + DE(c);
X      byteout((int)((word >> 24) & 255));
X      byteout((int)((word >> 16) & 255));
X      byteout((int)((word >> 8) & 255));
X      byteout((int)(word & 255));
X      word = 0;
X      bcount = 0;
X    }
X  } 
X  else {
X    fatal();
X  }
X}
XFILE *tmp_file;
byteout(c) reg c;
X{
X  Ceor ^= c;
X  Csum += c;
X  Csum += 1;
X  if ((Crot & 0x80000000)) {
X    Crot <<= 1;
X    Crot += 1;
X  } 
X  else {
X    Crot <<= 1;
X  }
X  Crot += c;
X  putc(c, tmp_file);
X}
main(argc, argv) char **argv;
X{
X  reg c;
X  reg long int i;
X  char tmp_name[100];
X  char buf[100];
X  long int n1, n2, oeor, osum, orot;
X
X  if (argc != 1) {
X    fprintf(stderr,"bad args to %s\n", argv[0]);
X    exit(2);
X  }
X  sprintf(tmp_name, "/usr/tmp/atob.%x", getpid());
X  tmp_file = fopen(tmp_name, "w+");
X  if (tmp_file == NULL) {
X    error("can't create temporary file");
X  }
X  unlink(tmp_name);
X  for (;;) {
X    if (fgets(buf, sizeof buf, stdin) == NULL) {
X      error("could not read header line");
X    }
X    if (streq(buf, "xbtoa Begin\n")) {
X      break;
X    }
X  }
X
X  while ((c = getchar()) != EOF) {
X    if (c == '\n') {
X      continue;
X    } 
X    else if (c == 'x') {
X      break;
X    } 
X    else {
X      decode(c);
X    }
X  }
X  if (scanf("btoa End N %ld %lx E %lx S %lx R %lx\n", &n1, &n2, &oeor, &osum, &orot) != 5) {
X    error("could not read check sum");
X  }
X  if ((n1 != n2) || (oeor != Ceor) || (osum != Csum) || (orot != Crot)) {
X    fatal();
X  } 
X  else {
X    fseek(tmp_file, 0L, 0);
X    for (i = n1; --i >= 0;) {
X      putchar(getc(tmp_file));
X    }
X  }
X  exit(0);
X}
XEOP
cat >mini_unkit <<'EOP'
if tar -cf - /dev/null 2>/dev/null | tar -xof - >/dev/null 2>&1; then
X	tar_opt='xvof'
else
X	tar_opt='xvf'
fi
if test -f zag.ba.aa; then
X	cat `ls zag.ba.??` | ./mini_code | zcat | tar $tar_opt - || exit 1
else
X	echo >&2 "Sorry, I can only deal with plain ascii-encoded kits"
X	exit 1
fi
test -f zzz.minikit && rm -f `cat zzz.minikit` zzz.minikit
rm -f z??.[hb][ea]*.??
XEOP
echo "Compiling mini kit..."
if cc -o mini_code mini_code.c >/dev/null 2>&1; then
X	echo "Running mini kit..."
X	sh mini_unkit
else
X	echo "Error in C compilation--aborting."
fi
rm -f core mini_code mini_code.c mini_unkit
echo "Done."
END_OF_FILE
if test 3119 -ne `wc -c <'kit/minikit'`; then
    echo shar: \"'kit/minikit'\" unpacked with wrong size!
fi
# end of 'kit/minikit'
fi
if test ! -d 'man' ; then
    echo shar: Creating directory \"'man'\"
    mkdir 'man'
fi
if test -f 'man/Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/Makefile.SH'\"
else
echo shar: Extracting \"'man/Makefile.SH'\" \(1278 characters\)
sed "s/^X//" >'man/Makefile.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X	if test ! -f config.sh; then
X		ln ../config.sh . || \
X		ln ../../config.sh . || \
X		ln ../../../config.sh . || \
X		(echo "Can't find config.sh."; exit 1)
X	fi 2>/dev/null
X	. config.sh
X	;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting man/Makefile (with variable substitutions)"
X$spitshell >Makefile <<!GROK!THIS!
X#
X# Makefile for kit (sub-directory man)
X#
X
X# $Id: Makefile.SH,v 2.0.1.2 91/05/27 14:30:53 ram Exp $
X#
X# $Log:	Makefile.SH,v $
X# Revision 2.0.1.2  91/05/27  14:30:53  ram
X# patch5: search for config.sh is now silent
X# 
X# Revision 2.0.1.1  91/04/30  13:35:12  ram
X# patch3: installation of manual pages made optional
X# 
X# Revision 2.0  91/02/19  15:50:12  ram
X# Baseline for first official release.
X# 
X
SHELL = /bin/sh
X
RM = $rm
man = $mansrc
X
X.SUFFIXES: .$manext .SH
X
X.SH.$manext:
X	sh $<
X
L = $manext
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
manpage = atob.$(L) btoa.$(L) kit.$(L) mailkit.$(L) unkit.$(L)
added = Makefile config.sh
X
X.SH:
X	sh $<
X
all: $(manpage)
X
install: all
X	-if test "$(man)"; then \
X		for file in $(manpage); do \
X			../install -m 444 $$file $(man); \
X		done; \
X	fi
X
clean:
X	$(RM) -f $(manpage)
X
realclean clobber: clean
X	$(RM) -f $(added)
X!NO!SUBS!
chmod 755 Makefile
X$eunicefix Makefile
END_OF_FILE
if test 1278 -ne `wc -c <'man/Makefile.SH'`; then
    echo shar: \"'man/Makefile.SH'\" unpacked with wrong size!
fi
chmod +x 'man/Makefile.SH'
# end of 'man/Makefile.SH'
fi
if test -f 'man/atob.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/atob.SH'\"
else
echo shar: Extracting \"'man/atob.SH'\" \(450 characters\)
sed "s/^X//" >'man/atob.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X	if test ! -f config.sh; then
X		ln ../config.sh . || \
X		ln ../../config.sh . || \
X		ln ../../../config.sh . || \
X		(echo "Can't find config.sh."; exit 1)
X	fi 2>/dev/null
X	. config.sh
X	;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting man/atob.$manext (with variable substitutions)"
X$rm -f atob.$manext
X$spitshell >atob.$manext <<!GROK!THIS!
X.so $mansrc/btoa.$manext
X!GROK!THIS!
chmod 444 atob.$manext
END_OF_FILE
if test 450 -ne `wc -c <'man/atob.SH'`; then
    echo shar: \"'man/atob.SH'\" unpacked with wrong size!
fi
# end of 'man/atob.SH'
fi
if test -f 'man/btoa.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/btoa.SH'\"
else
echo shar: Extracting \"'man/btoa.SH'\" \(1769 characters\)
sed "s/^X//" >'man/btoa.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X    fi 2>/dev/null
X    . config.sh
X    ;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting man/btoa.$manext (with variable substitutions)"
X$rm -f btoa.$manext
X$spitshell >btoa.$manext <<!GROK!THIS!
X.TH BTOA $manext local
X''' @(#) Manual page for atob/btoa -- (c) ram August 1990
X'''
X''' $Id: btoa.SH,v 2.0.1.1 91/05/27 14:31:27 ram Exp $
X'''
X''' $Log:	btoa.SH,v $
X''' Revision 2.0.1.1  91/05/27  14:31:27  ram
X''' patch5: search for config.sh is now silent
X''' 
X''' Revision 2.0  91/02/19  15:50:22  ram
X''' Baseline for first official release.
X''' 
X'''
X.SH NAME
btoa, atob \- encode/decode binary to printable ASCII
X.SH SYNOPSIS
X.B btoa
X.br
X.B atob
X.SH DESCRIPTION
X.I Btoa
is a filter that reads anything from the standard input, and encodes it into
printable ASCII on the standard output.  It also attaches a header and checksum
information used by the reverse filter 
X.I atob 
to find the start of the data and to check integrity.
X.PP
X.I Atob
reads an encoded file, strips off any leading and
trailing lines added by mailers, and recreates a copy of the original file
on the standard output.
X.I Atob 
gives NO output (and exits with an error message) if its input is garbage or 
the checksums do not check.
X.PP
X.SH FEATURES
X.I Btoa
uses a compact base-85 encoding so that
X4 bytes are encoded into 5 characters (file is expanded by 25%).
As a special case, 32-bit zero is encoded as one character.  This encoding
produces less output than
X.IR uuencode "(1)."
X.SH AUTHOR
Paul Rutter
X.SH "SEE ALSO"
kit($manext), mail(1), uuencode(1)
X!GROK!THIS!
chmod 444 btoa.$manext
END_OF_FILE
if test 1769 -ne `wc -c <'man/btoa.SH'`; then
    echo shar: \"'man/btoa.SH'\" unpacked with wrong size!
fi
# end of 'man/btoa.SH'
fi
if test -f 'man/mailkit.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/mailkit.SH'\"
else
echo shar: Extracting \"'man/mailkit.SH'\" \(461 characters\)
sed "s/^X//" >'man/mailkit.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X	if test ! -f config.sh; then
X		ln ../config.sh . || \
X		ln ../../config.sh . || \
X		ln ../../../config.sh . || \
X		(echo "Can't find config.sh."; exit 1)
X	fi 2>/dev/null
X	. config.sh
X	;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting man/mailkit.$manext (with variable substitutions)"
X$rm -f mailkit.$manext
X$spitshell >mailkit.$manext <<!GROK!THIS!
X.so $mansrc/kit.$manext
X!GROK!THIS!
chmod 444 mailkit.$manext
END_OF_FILE
if test 461 -ne `wc -c <'man/mailkit.SH'`; then
    echo shar: \"'man/mailkit.SH'\" unpacked with wrong size!
fi
# end of 'man/mailkit.SH'
fi
if test -f 'man/unkit.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/unkit.SH'\"
else
echo shar: Extracting \"'man/unkit.SH'\" \(453 characters\)
sed "s/^X//" >'man/unkit.SH' <<'END_OF_FILE'
case $CONFIG in
X'')
X	if test ! -f config.sh; then
X		ln ../config.sh . || \
X		ln ../../config.sh . || \
X		ln ../../../config.sh . || \
X		(echo "Can't find config.sh."; exit 1)
X	fi 2>/dev/null
X	. config.sh
X	;;
esac
case "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
esac
echo "Extracting man/unkit.$manext (with variable substitutions)"
X$rm -f unkit.$manext
X$spitshell >unkit.$manext <<!GROK!THIS!
X.so $mansrc/kit.$manext
X!GROK!THIS!
chmod 444 unkit.$manext
END_OF_FILE
if test 453 -ne `wc -c <'man/unkit.SH'`; then
    echo shar: \"'man/unkit.SH'\" unpacked with wrong size!
fi
# end of 'man/unkit.SH'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(42 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X#define VERSION 2.0
X#define PATCHLEVEL 10
END_OF_FILE
if test 42 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
