Newsgroups: comp.sources.unix
From: ram@eiffel.com (Raphael Manfredi)
Subject: v25i101: kit - the ultimate mailing kit, Patch11
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: ram@eiffel.com (Raphael Manfredi)
Posting-Number: Volume 25, Issue 101
Archive-Name: kit/pch11

[The latest patch for kit version 2.0 is #12.
	ram@eiffel.com (Raphael Manfredi)
]

System: kit version 2.0
Patch #: 11
Priority: LOW
Subject: updated Configure
Subject: added subdirectories badtar and shar
Subject: updated README
Subject: updated config.h.SH
Subject: now depends on the 'hasdes' configuration variable
Subject: added declarations for static functions
Subject: reported by Monty Solomon <roscom!monty@bu.edu>
Subject: now uses makeshar when cshar is not installed
Subject: the leading 'startsh' configuration variable was missing
Subject: reported by Michael Fischer <fischer-michael@cs.yale.edu>
Subject: now knows about badtar
Subject: added -b option to force use of badtar
Subject: the .so directive was made relative to make man happy
Subject: documents badtar and cshar-emulating scripts
Subject: added badtar and shar directories
Date: Sat Jan 11 19:25:26 PST 1992
From: Raphael Manfredi <ram@eiffel.com>

Description:

	The DES Makefile now depends on the 'hasdes' configuration
	variable, which means des will not be built if a valid DES
	implementation is found on the machine.

	Added declarations for static functions in des/des.c.
	(reported by Monty Solomon <roscom!monty@bu.edu>)

	The main improvement... Kit is now a *standalone* package and
	cshar is no longer needed to use kit, thanks to the scripts held
	in the shar directory.

	The leading 'startsh' configuration variable was missing in file
	kit/mailkit.SH.
	(reported by Michael Fischer <fischer-michael@cs.yale.edu>)

	The release now contains the 'badtar' program which may be used
	by kit to fix tar bugs and NFS idiosyncrasies.

	Added -b option to unkit to force use of badtar.

	The .so directive in man paged was made relative to make man happy.
	(reported by Michael Fischer <fischer-michael@cs.yale.edu>)


Fix:	From rn, say "| patch -p -N -d DIR", where DIR is your kit source
	directory.  Outside of rn, say "cd DIR; patch -p -N <thisarticle".
	If you don't have the patch program, apply the following by hand,
	or get patch (version 2.0, latest patchlevel).

	After patching:
		*** DO NOTHING--INSTALL ALL PATCHES UP THROUGH #12 FIRST ***

	If patch indicates that patchlevel is the wrong version, you may need
	to apply one or more previous patches, or the patch may already
	have been applied.  See the patchlevel.h file to find out what has or
	has not been applied.  In any event, don't continue with the patch.

	If you are missing previous patches they can be obtained from me:

		Raphael Manfredi <ram@eiffel.com>

	If you send a mail message of the following form it will greatly speed
	processing:

		Subject: Command
		@SH mailpatch PATH kit 2.0 LIST
			   ^ note the c

	where PATH is a return path FROM ME TO YOU either in Internet notation,
	or in bang notation from some well-known host, and LIST is the number
	of one or more patches you need, separated by spaces, commas, and/or
	hyphens.  Saying 35- says everything from 35 to the end.

	To get some more detailed instructions, send me the following mail:

		Subject: Command
		@SH mailhelp PATH


Index: patchlevel.h
Prereq: 10
2c2
< #define PATCHLEVEL 10
---
> #define PATCHLEVEL 11

Index: badtar/badtar.c
*** badtar/badtar.c.old	Sat Jan 11 19:24:23 1992
--- badtar/badtar.c	Sat Jan 11 19:24:24 1992
***************
*** 0 ****
--- 1,385 ----
+ /*
+  * I got that from net.sources and extended it -- RAM
+  *
+  * $Id: badtar.c,v 2.0.1.1 92/01/11 19:12:45 ram Exp $
+  *
+  * $Log:	badtar.c,v $
+  * Revision 2.0.1.1  92/01/11  19:12:45  ram
+  * patch11: created
+  * 
+  */
+ 
+ /* read tar tapes with bad blocks MWS */
+ #include "../config.h"
+ #include "../patchlevel.h"
+ #include <stdio.h>
+ #include <sys/types.h>
+ #include <sys/file.h>					/* Should be metaconfigured ? */
+ #ifdef I_FCNTL							/* Added by ram for O_RDONLY */
+ #include <fcntl.h>
+ #else
+ #include <sys/fcntl.h>
+ #endif
+ #define TBLOCK		512					/* Size of a tape block */
+ #define NAMSIZ		100					/* Maximum size for filename */
+ #define BLOCKF		20					/* Blocking factor */
+ #define TAPEBLOCK 	(BLOCKF * TBLOCK)	/* Blocksize */
+ 
+ int verbose = 0;					/* Verbose output control */
+ int silent = 0;						/* Silent output control */
+ char *default_tape = TAPEDEV;		/* Default device tape file */
+ 
+ /* Logging printf */
+ #define lprintf		if (!silent) fprintf
+ 
+ /* see tar (4 or 5) in the manual */
+ union hblock {
+      char dummy[TBLOCK];
+      struct header {
+           char name[NAMSIZ];
+           char mode[8];
+           char uid[8];
+           char gid[8];
+           char size[12];
+           char mtime[12];
+           char chksum[8];
+           char linkflag;
+           char linkname[NAMSIZ];
+      } dbuf;
+ };
+ char pad[TBLOCK];
+ 
+ /* Print usage */
+ usage()
+ {
+ 	fprintf(stderr,
+ "Usage: badtar [-hiorsvV] [-l logfile] [-f tape drive] [-u uid] [-g gid]\n");
+ 	fprintf(stderr, "  -V : print version number.\n");
+ 	fprintf(stderr, "  -f : tape drive device or file (default is %s).\n",
+ 		default_tape);
+ 	fprintf(stderr, "  -g : set GID on extracted files (0 for current user).\n");
+ 	fprintf(stderr, "  -h : print this help message.\n");
+ 	fprintf(stderr, "  -i : ignore end of tape blocks.\n");
+ 	fprintf(stderr, "  -l : define log file (default is stderr).\n");
+ 	fprintf(stderr, "  -o : set ownership of files to current user.\n");
+ 	fprintf(stderr, "  -r : make relative paths by removing leading '/'.\n");
+ 	fprintf(stderr, "  -s : silent mode, no logging is done.\n");
+ 	fprintf(stderr, "  -u : set UID on extracted files (0 for current user).\n");
+ 	fprintf(stderr, "  -v : verbose mode, print headers found.\n");
+ }
+ 
+ /* Print version number */
+ version()
+ {
+ 	fprintf(stderr, "badtar %.1f PL%d\n", VERSION, PATCHLEVEL);
+ 	fprintf(stderr, "(version modified by Raphael Manfredi, as part of kit)\n");
+ }
+ 
+ /* check the check sum for the header block */
+ check_sum(c)
+ union hblock *c;
+ {
+ 	int i,j;
+ 	char *cp;
+ 	cp = c->dummy;
+ 	i = 0;
+ 	for (j = 0; j < TBLOCK; j++)
+ 		i += *cp++;
+ 	/* When calculating the checksum, the "chksum" field is
+ 	 * treated as if it were all blanks.
+ 	 */
+ 	for (j = 0; j < 8; j++)
+ 		i -= c->dbuf.chksum[j];	/* Remove chksum values */
+ 	for (j = 0; j < 8; j++)
+ 		i += ' ';				/* Treat as blank */
+ 	return(i);
+ }
+ 
+ char buf[TAPEBLOCK];
+ char xbuf[TAPEBLOCK];
+ int bpos = TAPEBLOCK - TBLOCK, eot = 0, bad = 0, fd1;
+ FILE *logf;
+ 
+ extern int errno;
+ 
+ /* get the next TBLOCK chars from the tape */
+ char *get_next()
+ {
+ 	int res;
+ 	int nbytes;
+ 	if (bpos >= TAPEBLOCK - TBLOCK) {	/* Reached end of buf array */
+ 		bcopy(xbuf, buf, TAPEBLOCK);	/* Reset buf to xbuf ('x' chars) */
+ 		res = read(fd1, buf, TAPEBLOCK);	/* Read a new chunck */
+ 		if (res == 0) {
+ 			eot = 1;					/* End of tape */
+ 			lprintf(logf, "*** End of tape?\n");
+ 		} else if (res < TAPEBLOCK) {
+ 			if (res == -1) {
+ 				lprintf(logf, "*** Bad block on tape!!\n");
+ 				bad = 1; 
+ 			} else {
+ 				/* We read only a partial block (maybe we are
+ 				 * reading data through a pipe ?). Anyway, loop
+ 				 * until TAPEBLOCK bytes have been read or an
+ 				 * error occurred.
+ 				 */
+ 				for (
+ 					nbytes = res;
+ 					nbytes < TAPEBLOCK && res != -1;
+ 					nbytes += res
+ 				) {
+ 					res = read(fd1, buf + nbytes, TAPEBLOCK - nbytes);
+ 					if (res == -1) {
+ 						lprintf(logf, "*** Bad block on tape!!\n");
+ 						bad = 1;
+ 						break;
+ 					} else if (res == 0) {
+ 						eot = 1;
+ 						lprintf(logf, "*** End of tape?\n");
+ 						break;
+ 					}
+ 				}
+ 			}
+ 		} else if (bad) {
+ 			lprintf(logf, "*** End of bad block(s) on tape\n");
+ 			bad = 0;
+ 		}
+ 		bpos = 0;
+ 	} else
+ 		bpos += TBLOCK;
+ 
+ 	fflush(logf);			/* Let they know what we're doing */
+ 	return &buf[bpos];
+ }
+ 
+ main(argc, argv)
+ char **argv;
+ {
+ 	int i, size, chksum, fblocks, eot_block;
+ 	int user = -1;				/* UID to be forced */
+ 	int group = -1;				/* GID to be forced */
+ 	union hblock *hp;			/* To decipher headers */
+ 	char tape[NAMSIZ];			/* Name of tape device */
+ 	char ignore = 0;			/* Do not ignore EOT */
+ 	char relative = 0;			/* Do not remove leading '/' */
+ 	int nblock = 0;				/* Number of blocks written */
+ 	strcpy(tape, default_tape);	/* Default device file */
+ 	logf = stderr;				/* Default logging on stderr */
+ 	i = 1;
+ 	
+ 	/* get arguments */
+ 	while (argc > i && argv[i][0] == '-') {
+ 		switch (argv[i][1]) {
+ 			case 'f' : 
+ 				if (argc > i + 1) {
+ 					strcpy(tape,argv[++i]);
+ 					}
+ 				else {
+ 					fprintf(stderr, "No tape drive name given\n");
+ 					exit(10);
+ 				}
+ 				break;
+ 			case 'l':
+ 				if (argc > i + 1) {
+ 					if ((logf = fopen(argv[++i], "w")) == NULL) {
+ 						perror("Can't open log file\n");
+ 						exit(11);
+ 					}
+ 				}
+ 				else {
+ 					fprintf(stderr, "No log file name given\n");
+ 					exit(12);
+ 				}
+ 				break;
+ 			case 'i':		/* Ignore end of tape condition */
+ 				ignore = 1;
+ 				break;
+ 			case 'r':		/* Force relative paths */
+ 				relative = 1;
+ 				break;
+ 			case 'o':		/* Forces ownership */
+ 				user = (int) getuid();
+ 				group = (int) getgid();
+ 				break;
+ 			case 'u':		/* Force UID on extraction */
+ 				if (argc > i + 1) {
+ 					sscanf(argv[++i], "%d", &user);
+ 					if (user == 0)
+ 						user = (int) getuid();	/* Can't give to root */
+ 				} else {
+ 					fprintf(stderr, "No user ID given\n");
+ 					exit(1);
+ 				}
+ 				break;
+ 			case 'g':		/* Force GID on extraction */
+ 				if (argc > i + 1) {
+ 					sscanf(argv[++i], "%d", &group);
+ 					if (group == 0)
+ 						group = (int) getgid();	/* Can't give to root */
+ 				} else {
+ 					fprintf(stderr, "No group ID given\n");
+ 					exit(1);
+ 				}
+ 				break;
+ 			case 'v':		/* Verbose logging */
+ 				verbose = 1;
+ 				silent = 0;
+ 				break;
+ 			case 's':		/* No logging */
+ 				silent = 1;
+ 				verbose = 0;
+ 				break;
+ 			case 'h':		/* Print help message */
+ 				usage();
+ 				exit(0);
+ 			case 'V':		/* Print version number */
+ 				version();
+ 				exit(0);
+ 			default: 
+ 				usage();
+ 				exit(13);
+ 		}
+ 		i++;
+ 	}
+ 	
+ 	/* first char cannot be a 0 */
+ 	pad[0]  = 'x';
+ 	
+ 	/* don't quite know what the tape driver will return, so fill buffer
+ 	   with non zero rubbish
+ 	 */
+ 	for (i = 0; i < TAPEBLOCK; i++) xbuf[i] = 'x';
+ 	
+ 	/* open the tape drive ('-' stands for stdin) */
+ 	if (0 == strcmp(tape, "-"))
+ 		fd1 = 0;		/* Standard input */
+ 	else if ((fd1 = open(tape, O_RDONLY,0)) < 0) {
+ 		perror("can't open tape");
+ 		exit(1);
+ 	}
+ 	while (1) {
+ 		fflush(logf);			/* So that they know where we are */
+ 		hp = (union hblock *) get_next();
+ 		/* tar tests the first char to see if it is an end of tape (eot) block
+ 		 * or not. Can't see why it doesn't use tape marks. Maybe they weren't
+ 		 * invented when it was written?
+ 	 	 */
+ 	 	/* get a tar block */
+ 		
+ 		if (hp->dbuf.name[0] == '\0' && !bad && !fblocks) {
+ 			/* skip possible eot block (there are two of them) */
+ 			lprintf(logf, "*** End of tape block\n");
+ 			eot_block++;
+ 			if (eot_block < 2)
+ 				continue;
+ 			eot = 1;
+ 		}
+ 		/* note if the last block read is bad there may be rubish
+ 		 * (old info from the last write at the end of it) this may cause
+ 		 * some of the last files which are extracted to be partially
+ 		 * overwritten. There is very little one can do about this
+ 		 * (except pray)
+ 		 */
+ 		
+ 		/* end of tape ?? */
+ 		if (eot) {
+ 			if (fblocks) {
+ 				lprintf(logf,"*** Last file Truncated. File padded!!\n");
+ 				while (fblocks-- > 0)
+ 					nblock++, write(1, pad, TBLOCK);
+ 			}
+ 			if (!ignore) {
+ 				/* write two blank (eot) blocks */
+ 				pad[0] = '\0';
+ 				nblock++, write(1, pad, TBLOCK);
+ 				nblock++, write(1, pad, TBLOCK);
+ 				i = BLOCKF - nblock % BLOCKF;	/* Pad if necessary */
+ 				if (i < BLOCKF) {
+ 					lprintf(logf, "*** Padding %d block%s\n", i, i>1 ? "s":"");
+ 					for (; i > 0; i--)
+ 						write(1, pad, TBLOCK);
+ 				}
+ 				lprintf(logf,"*** End of tar\n");
+ 				exit(0);		/* OK */
+ 			} else {
+ 				lprintf(logf,"*** Ignoring end of tar\n");
+ 				fblocks = 0;		/* You never know */
+ 				eot = 0;			/* I said: ignore EOT !! */
+ 				eot_block = 0;
+ 				continue;
+ 			}
+ 		}
+ 		
+ 		/* We need two consecutive EOT blocks for eot
+ 		 * condition to occur
+ 		 */
+ 		eot_block = 0;
+ 		
+ 		/* decode header informations */
+ 		sscanf(hp->dbuf.size, "%lo", &size);
+ 		sscanf(hp->dbuf.chksum, "%o", &chksum);
+ 
+ 		if (fblocks > 0 && !bad) { /* all ok in the middle of a file */
+ 			nblock++, write(1, hp, TBLOCK);
+ 			fblocks--;
+ 			/* header inside file ? */
+ 			if (check_sum(hp) == chksum && hp->dbuf.name[0] != '\0')
+ 				lprintf(logf, "*** Warning: Header found inside file!!\n");
+ 			continue;
+ 		}
+ 		
+ 		/* have we got a header ?? */
+ 		if (check_sum(hp) == chksum && hp->dbuf.name[0] != '\0') {
+ 
+ 			if (verbose) {
+ 				/* Write some informations about the header we've got */
+ 				fprintf(logf, "*** Header found.\n");
+ 				fprintf(logf, "***   Name: %s\n", hp->dbuf.name);
+ 				fprintf(logf, "***   Size: %d\n", size);
+ 				fprintf(logf, "***   Mode: %s\n", hp->dbuf.mode);
+ 				fprintf(logf, "***   Link flag: %c\n", hp->dbuf.linkflag);
+ 			}
+ 
+ 			/* we have a header */
+ 			if (fblocks > 0) {
+ 				lprintf(logf, "*** Truncated!! File padded!!\n");
+ 				while (fblocks-- > 0)
+ 					nblock++, write(1, pad, TBLOCK);
+ 			}
+ 
+ 			/* If membership has to be overwritten, do it now */
+ 			if (user != -1 || group != -1) {
+ 				if (user != -1)
+ 					sprintf(hp->dbuf.uid, "%o", user);
+ 				if (group != -1)
+ 					sprintf(hp->dbuf.gid, "%o", group);
+ 				sprintf(hp->dbuf.chksum, "%o", check_sum(hp));
+ 			}
+ 
+ 			/* Remove the leading '/' to get non absolute path */
+ 			if (relative && hp->dbuf.name[0] == '/') {
+ 				sprintf(hp->dbuf.name, "%s", hp->dbuf.name + 1);
+ 				sprintf(hp->dbuf.chksum, "%o", check_sum(hp));
+ 			}
+ 
+ 			/* Compute number of blocks used by the file */
+ 			fblocks = (size%TBLOCK) ? size/TBLOCK + 1 : size/TBLOCK;
+ 			lprintf(logf,"%s (%d bytes)\n", hp->dbuf.name, size);
+ 			nblock++, write(1, hp, TBLOCK);		/* Write the header */
+ 			continue;
+ 		}
+ 		
+ 		/* not a header */
+ 		if (fblocks <= 0) {
+ 			/* throw it away! */
+ 			lprintf(logf, "*** Deleted block!!\n");
+ 			fblocks = 0;	/* It can't be < 0, but you know... */
+ 			continue;
+ 		}
+ 
+ 		lprintf(logf, "***  Writing possibly bad block!!\n");
+ 		fblocks--;
+ 		nblock++, write(1, hp, TBLOCK);
+ 	}
+ }
+ 

Index: Configure
Prereq: 2.0.1.4
*** Configure.old	Sat Jan 11 19:23:59 1992
--- Configure	Sat Jan 11 19:24:01 1992
***************
*** 16,24 ****
  # Write to ram@eiffel.com (Raphael Manfredi) and I will send you the
  # latest revision of the dist package, which includes metaconfig.)
  
! # $Id: Configure,v 2.0.1.4 91/11/25 15:48:25 ram Exp $
  #
! # Generated on Mon Nov 25 15:43:33 PST 1991 [metaconfig 2.8 PL11]
  
  cat >/tmp/c1$$ <<EOF
  
--- 16,24 ----
  # Write to ram@eiffel.com (Raphael Manfredi) and I will send you the
  # latest revision of the dist package, which includes metaconfig.)
  
! # $Id: Configure,v 2.0.1.5 92/01/11 19:08:09 ram Exp $
  #
! # Generated on Sat Jan 11 19:03:07 PST 1992 [metaconfig 2.8 PL13]
  
  cat >/tmp/c1$$ <<EOF
  
***************
*** 150,163 ****
--- 150,166 ----
  contains=''
  cppstdin=''
  cppminus=''
+ d_bcopy=''
  d_getopt=''
  d_index=''
  d_memcpy=''
  d_memset=''
+ d_perror=''
  d_portable=''
  d_voidsig=''
  signal_t=''
  defeditor=''
+ i_fcntl=''
  i_string=''
  strings=''
  i_sysioctl=''
***************
*** 191,197 ****
--- 194,204 ----
  mips_type=''
  voidflags=''
  defvoidused=''
+ needbtar=''
+ wantbtar=''
  d_taropt_o=''
+ hasdes=''
+ tapedev=''
  large=''
  d_whoami=''
  i_sysselct=''
***************
*** 661,666 ****
--- 668,674 ----
  		cp ../config.sh .
  		n="$tmp"
  		c="$ans"
+ 		hint=previous
  		;;
  	esac
  fi
***************
*** 1200,1205 ****
--- 1208,1215 ----
  		nm_opt=''
  	elif $test -d /usr/ccs/lib; then
  		nm_opt='-p'
+ 	elif $test -f /dgux; then
+ 		nm_opt='-p'
  	else
  		nm_opt=''
  	fi;;
***************
*** 1437,1442 ****
--- 1447,1464 ----
  else echo "$1() not found.";
  	eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu"; fi'
  
+ : see if bcopy exists
+ case "$d_bcopy" in
+ $define) d_bcopy="$undef";;
+ $undef) d_bcopy="$define";;
+ esac
+ set bcopy d_bcopy
+ eval $inlibc
+ case "$d_bcopy" in
+ $define) d_bcopy="$undef";;
+ *) d_bcopy="$define";;
+ esac
+ 
  : see if getopt exists
  set getopt d_getopt
  eval $inlibc
***************
*** 1522,1527 ****
--- 1544,1571 ----
  set memset d_memset
  eval $inlibc
  
+ : see if perror exists
+ echo " "
+ if $contains '^perror$' libc.list >/dev/null 2>&1; then
+     echo 'perror() found.'
+     d_perror="$undef"
+ else
+     echo "perror() not found -- Won't be able to give precise error messages."
+     d_perror="$define"
+ fi
+ 
+ : see if this is an fcntl system
+ echo " "
+ if $test -r $usrinc/fcntl.h ; then
+     val="$define"
+     echo "<fcntl.h> found."
+ else
+     val="$undef"
+     echo "No <fcntl.h> found, but that's ok."
+ fi
+ set i_fcntl
+ eval $setvar
+ 
  : see how we invoke the C preprocessor
  echo " "
  echo "Now, how can we feed standard input to your C preprocessor..."
***************
*** 1758,1763 ****
--- 1802,1828 ----
  eval $setvar
  $rm -f $$.tmp
  
+ : locate the default tape device
+ echo " "
+ case "$tapedev" in
+ '') if set x /dev/rst*; shift; $test -c "$1"; then
+ 		dflt="$1";
+ 	elif set x /dev/rmt*; shift; $test -c "$1"; then
+ 		dflt="$1";
+ 	elif set x /dev/rmt/m*; shift; $test -c "$1"; then
+ 		dflt="$1";
+ 	elif set x /dev/rmt/?; shift; $test -c "$1"; then
+ 		dflt="$1";
+ 	else
+ 		dflt="/dev/rmt8";
+ 	fi
+ 	;;
+ *) dflt="$tapedev";;
+ esac
+ rp='Where is your tape device located?'
+ . myread
+ tapedev="$ans"
+ 
  : check for void type
  echo " "
  $cat <<EOM
***************
*** 1879,1884 ****
--- 1944,1977 ----
      fi
  done
  
+ : decide how portable to be
+ case "$d_portable" in
+ "$define") dflt=y;;
+ *)	dflt=n;;
+ esac
+ $cat <<'EOH'
+  
+ I can set things up so that your shell scripts and binaries are more portable,
+ at what may be a noticable cost in performance.  In particular, if you
+ ask to be portable, the following happens:
+ 
+      1) Shell scripts will rely on the PATH variable rather than using
+ 	the paths derived above.
+      2) ~username interpretations will be done at run time rather than
+ 	by Configure.
+ 
+ EOH
+ rp="Do you expect to run these scripts and binaries on multiple machines?"
+ . myread
+ case "$ans" in
+     y*) d_portable="$define"
+ 	for file in $loclist; do
+ 	    eval $file=$file
+ 	done
+ 	;;
+     *)  d_portable="$undef" ;;
+ esac
+ 
  : see if we need -o option for tar
  echo " "
  case "$d_taropt_o" in
***************
*** 1930,1935 ****
--- 2023,2084 ----
  	fi
  done
  
+ : see if des is there and compatible
+ echo " "
+ case "$hasdes" in
+ '') hasdes=false
+ 	xxx=`loc des x $pth`
+ 	case "$xxx" in
+ 	/*) echo "I see you already have a DES in $xxx."
+ 		echo "Let's make sure it is compatible with mine..."
+ 		$cat > dedes.c <<EOP
+ #include <stdio.h>
+ main()
+ {
+ 	char s[10];
+ 	int c;
+ 
+ 	while (gets(s)) {
+ 		sscanf(s, "%d", &c);
+ 		putchar(c);
+ 	}
+ }
+ EOP
+ 		if $cc -o dedes dedes.c >/dev/null 2>&1; then
+ 			echo "This is a DES try" > des.1
+ 			$tr ' ' '\012' >des.data <<EOD
+ 237 195 33 239 62 135 8 90 191 42 108 230 24 121 207 173 18 98
+ 224 166 63 115 153 79
+ EOD
+ 			./dedes >des.input <des.data
+ 			$xxx -d -k foo <des.input > des.2 2>&1
+ 			if cmp -s des.1 des.2 >/dev/null 2>&1; then
+ 				echo "Yes, it is! We won't need mine then."
+ 				hasdes=true
+ 			else
+ 				echo "No, it isn't!! But that's ok, I'll use my own version."
+ 				hasdes=false
+ 			fi
+ 		else
+ 			echo "(I can't seem to compile the test program--Using your DES)"
+ 			hasdes=true
+ 		fi
+ 		;;
+ 	*) echo "I don't see any DES implementation out there. I'll use mine."
+ 		;;
+ 	esac
+ 	;;
+ *) case "$hasdes" in
+ 	true) echo "I already know that your DES is compatible with mine.";;
+ 	*) $cat <<EOM
+ As before, I'm going to use the DES implementation provided with $package.
+ EOM
+ 	;;
+ 	esac
+ 	;;
+ esac
+ $rm -f dedes.c dedes des.data des.input des.1 des.2
+ 
  : determine the name of a reasonable mailer
  case "$mailer" in
  '')
***************
*** 2024,2055 ****
  *) manext=1;;
  esac
  
! : decide how portable to be
! case "$d_portable" in
! "$define") dflt=y;;
! *)	dflt=n;;
  esac
! $cat <<'EOH'
!  
! I can set things up so that your shell scripts and binaries are more portable,
! at what may be a noticable cost in performance.  In particular, if you
! ask to be portable, the following happens:
  
!      1) Shell scripts will rely on the PATH variable rather than using
! 	the paths derived above.
!      2) ~username interpretations will be done at run time rather than
! 	by Configure.
  
! EOH
! rp="Do you expect to run these scripts and binaries on multiple machines?"
! . myread
! case "$ans" in
!     y*) d_portable="$define"
! 	for file in $loclist; do
! 	    eval $file=$file
! 	done
  	;;
-     *)  d_portable="$undef" ;;
  esac
  
  : determine where private executables go
--- 2173,2232 ----
  *) manext=1;;
  esac
  
! : see if we need badtar
! echo " "
! case "$needbtar" in
! '') xxx=''
! 	case "$d_taropt_o" in
! 	"$define") xxx='o';;
! 	esac
! 	echo "Checking to see how well 'tar x${xxx}f' sets ownership..."
! 	(cd /bin; $tar cf - rm) | eval "$tar x${xxx}f -"
! 	needbtar='true'
! 	if test -f rm; then
! 		(cd /bin; ls -l rm) > rm.orig
! 		ls -l rm > rm.now
! 		if cmp rm.orig rm.now >/dev/null 2>&1; then
! 		echo "Your tar does not seem to overwrite ownership -- I'll use badtar."
! 		else
! 			echo "Your tar works fine."
! 			needbtar='false'
! 		fi
! 	else
! 		echo "(My test failed -- Using badtar, just in case.)"
! 	fi
! 	;;
! *) case "$needbtar" in
! 	true) echo "I'll pipe badtar's output to tar, so that things run smoothly."
! 		;;
! 	*) echo "I'll trust your tar to overwrite file ownership."
! 		;;
! 	esac
! 	;;
  esac
! $rm -f rm rm.orig rm.now
  
! : does the user want badtar ?
! wantbtar='true'
! case "$needbtar" in
! true) ;;
! *) $cat <<EOM
! 
! $package comes with badtar, a program which repairs damaged tar files. You
! do not need it to run $package, but you may want to compile and install it
! anyway. Badtar has its output piped to tar and does some kind of filterting,
! like padding files (assuming some blocks on the tape could not be read),
! stripping down absolute paths to relative ones by removing the leading '/',
! or simply overwriting the ownership of the files. It comes with a manual page.
  
! EOM
! 	dflt='y'
! 	rp='Would you like to have badtar installed?'
! 	. myread
! 	case "$and" in
! 	n*|N*) wantbtar='false';;
! 	esac
  	;;
  esac
  
  : determine where private executables go
***************
*** 2219,2232 ****
--- 2396,2412 ----
  contains='$contains'
  cppstdin='$cppstdin'
  cppminus='$cppminus'
+ d_bcopy='$d_bcopy'
  d_getopt='$d_getopt'
  d_index='$d_index'
  d_memcpy='$d_memcpy'
  d_memset='$d_memset'
+ d_perror='$d_perror'
  d_portable='$d_portable'
  d_voidsig='$d_voidsig'
  signal_t='$signal_t'
  defeditor='$defeditor'
+ i_fcntl='$i_fcntl'
  i_string='$i_string'
  strings='$strings'
  i_sysioctl='$i_sysioctl'
***************
*** 2260,2266 ****
--- 2440,2450 ----
  mips_type='$mips_type'
  voidflags='$voidflags'
  defvoidused='$defvoidused'
+ needbtar='$needbtar'
+ wantbtar='$wantbtar'
  d_taropt_o='$d_taropt_o'
+ hasdes='$hasdes'
+ tapedev='$tapedev'
  EOT
  
  : add special variables

Index: kit/kit.SH
Prereq: 2.0.1.6
*** kit/kit.SH.old	Sat Jan 11 19:24:40 1992
--- kit/kit.SH	Sat Jan 11 19:24:41 1992
***************
*** 26,34 ****
  !GROK!THIS!
  $spitshell >>kit <<'!NO!SUBS!'
  
! # $Id: kit.SH,v 2.0.1.6 91/12/08 14:55:06 ram Exp $
  #
  # $Log:	kit.SH,v $
  # Revision 2.0.1.6  91/12/08  14:55:06  ram
  # patch10: forgot to protect evaluation of variable in a test
  # 
--- 26,37 ----
  !GROK!THIS!
  $spitshell >>kit <<'!NO!SUBS!'
  
! # $Id: kit.SH,v 2.0.1.7 92/01/11 19:17:20 ram Exp $
  #
  # $Log:	kit.SH,v $
+ # Revision 2.0.1.7  92/01/11  19:17:20  ram
+ # patch11: now uses makeshar when cshar is not installed
+ # 
  # Revision 2.0.1.6  91/12/08  14:55:06  ram
  # patch10: forgot to protect evaluation of variable in a test
  # 
***************
*** 174,179 ****
--- 177,185 ----
  		;;
  	-*) echo "unkown option $1"
  		eval $usage
+ 		;;
+ 	*) break
+ 		;;
  	esac
  done
  
***************
*** 242,252 ****
  	fi
  fi
  
  echo "Coding with $coding"
  # Beware: 'eval $coding < $tmpfile' is not portable
  cat $tmpfile | eval $coding |
  split -600 - $split_file &&
! makekit -k100 -n $partname ${split_file}* $minikit $mininame &&
  rm ${split_file}* $minikit $mininame $tmpfile
  
  case "$subject" in
--- 248,265 ----
  	fi
  fi
  
+ # Check whether we can use cshar or not
+ if (makekit -v) >/dev/null 2>&1; then
+ 	makekit="makekit -k100 -n $partname ${split_file}* $minikit $mininame"
+ else
+ 	makekit="$libdir/makeshar -n $partname ${split_file}* $minikit $mininame"
+ fi
+ 
  echo "Coding with $coding"
  # Beware: 'eval $coding < $tmpfile' is not portable
  cat $tmpfile | eval $coding |
  split -600 - $split_file &&
! eval $makekit &&
  rm ${split_file}* $minikit $mininame $tmpfile
  
  case "$subject" in

Index: man/kit.SH
Prereq: 2.0.1.5
*** man/kit.SH.old	Sat Jan 11 19:24:57 1992
--- man/kit.SH	Sat Jan 11 19:24:59 1992
***************
*** 18,26 ****
  .TH KIT $manext ram
  ''' @(#) Manual page for mailing kit -- (c) ram July 1990
  '''
! ''' $Id: kit.SH,v 2.0.1.5 91/11/25 15:53:01 ram Exp $
  '''
  ''' $Log:	kit.SH,v $
  ''' Revision 2.0.1.5  91/11/25  15:53:01  ram
  ''' patch9: added kit's -M option to include minikit
  ''' patch9: documents the tar -o possible problem
--- 18,30 ----
  .TH KIT $manext ram
  ''' @(#) Manual page for mailing kit -- (c) ram July 1990
  '''
! ''' $Id: kit.SH,v 2.0.1.6 92/01/11 19:22:08 ram Exp $
  '''
  ''' $Log:	kit.SH,v $
+ ''' Revision 2.0.1.6  92/01/11  19:22:08  ram
+ ''' patch11: the .so directive was made relative to make man happy
+ ''' patch11: documents badtar and cshar-emulating scripts
+ ''' 
  ''' Revision 2.0.1.5  91/11/25  15:53:01  ram
  ''' patch9: added kit's -M option to include minikit
  ''' patch9: documents the tar -o possible problem
***************
*** 58,64 ****
  \fBmailkit\fR [ \fB\-EFVefhp\fR ] [ \fB\-l\fI file\fR ]
  [ \fB\-n\fI partname\fR ] \fItitle\fR [ \fIaddress(es)\fR ]
  .br
! \fBunkit\fR [ \fB\-hlprV\fR ] [ \fIfiles\fR ]
  .SH DESCRIPTION
  \fIKit\fR is the ultimate mailing tool. It enables you to mail
  data without any consideration of possible escape sequences or
--- 62,68 ----
  \fBmailkit\fR [ \fB\-EFVefhp\fR ] [ \fB\-l\fI file\fR ]
  [ \fB\-n\fI partname\fR ] \fItitle\fR [ \fIaddress(es)\fR ]
  .br
! \fBunkit\fR [ \fB\-bhlprV\fR ] [ \fIfiles\fR ]
  .SH DESCRIPTION
  \fIKit\fR is the ultimate mailing tool. It enables you to mail
  data without any consideration of possible escape sequences or
***************
*** 66,73 ****
  Given a file name or a directory, it builds a single file using
  \fItar\fR(1) and \fIcompress\fR(1). Then this file is hex-encoded
  (option \fB\-H\fR) or ASCII-encoded with \fIbtoa\fR(1)
! (option \fB\-B\fR, which is used by default) before being shell-archived
! by \fImakekit\fR(1).
  \fIKit\fR produces files that match "Kit*" regular expression.
  This default base name can be changed thanks to \fB\-n\fR option.
  On invocation, it removes all previously existing "Kit*" files.
--- 70,76 ----
  Given a file name or a directory, it builds a single file using
  \fItar\fR(1) and \fIcompress\fR(1). Then this file is hex-encoded
  (option \fB\-H\fR) or ASCII-encoded with \fIbtoa\fR(1)
! (option \fB\-B\fR, which is used by default) before being shell-archived.
  \fIKit\fR produces files that match "Kit*" regular expression.
  This default base name can be changed thanks to \fB\-n\fR option.
  On invocation, it removes all previously existing "Kit*" files.
***************
*** 126,131 ****
--- 129,139 ----
  the message will be sent in an extra part (#0), while with \fB\-e\fR
  it will be included in each part. Empty messages will be ignored.
  .PP
+ Options \fB\-F\fR and \fB\-f\fR are very similar, but take their
+ input from stdin (standard input) instead of calling an editor.
+ Option \fB\-p\fR asks \fImailkit\fR for preserving mailed files. They
+ are removed by default.
+ .PP
  When \fImailkit\fR is given a \fB\-l\fR option, it takes the file name
  as a file whith recipients addresses in it and adds the optional addresses that
  may be given on the command line. Addresses in the recipient file are
***************
*** 132,142 ****
  separated with spaces, commas or new lines. Shell-style comments starting with
  a pound sign (#) are allowed.
  .PP
- Options \fB\-F\fR and \fB\-f\fR are very similar, but take their
- input from stdin (standard input) instead of calling an editor.
- Option \fB\-p\fR asks \fImailkit\fR for preserving mailed files. They
- are removed by default.
- .PP
  \fIUnkit\fR is used to restore the original files. The argument is
  a list of archive files (or mail files, as \fIunshar\fR(1), which
  is called by \fIunkit\fR, can deal with mail headers).
--- 140,145 ----
***************
*** 145,150 ****
--- 148,160 ----
  If no file name is given to \fIunkit\fR, the standard input is processed.
  This is useful to process messages directly from a mail user agent.
  .PP
+ Sometimes, \fItar\fR does not work well accross NFS and will fail restoring
+ ownership on files, even with the \-\fBo\fR option. If you chose to install
+ \fIbadtar\fR at configuration time, you may use \-\fBb\fR to instruct
+ \fIunkit\fR using \fIbadtar\fR as a filter before running \fItar\fR. This is
+ the default action on some systems (the \-\fBh\fR option will tell you
+ what was determined at configuration time).
+ .PP
  If you want to know what \fIunkit\fR will create without actually
  doing it, use the \fB\-l\fR option. With this option, \fB\-r\fR is
  ignored.
***************
*** 181,192 ****
  $privlib/minikit
  the script which may be used to unkit a distribution when the kit
  package is not available.
  .PD
  .SH NOTE
  .PP
! In order to use kit, you need to install \fBcshar\fR in your
! PATH (programs needed are \fIshar\fR, \fImakekit\fR).
! Moreover, \fIhexdecode\fR, \fIhexencode\fR, \fIatob\fR and \fIbtoa\fR
  must be installed and \fIcompress\fR must be available.
  If any of these is missing, this mailing kit is useless.
  .PP
--- 191,214 ----
  $privlib/minikit
  the script which may be used to unkit a distribution when the kit
  package is not available.
+ .TP
+ $privlib/makeshar
+ the script which emulates \fIcshar\fR's \fImakekit\fR program.
+ .TP
+ $privlib/rshar
+ a simple shell archive maker.
  .PD
  .SH NOTE
  .PP
! Kit may now be used as a standalone package, i.e. without the help of
! the \fIcshar\fR distribution.
! This was not true before version 2.0 PL10. Two simple shell scripts
! now emulate \fIcshar\fR's behaviour. Those scripts are held in the
! private library directory because they are not intended to be used
! directly by any user.
! .PP
! In order to use kit, \fIhexdecode\fR, \fIhexencode\fR,
! \fIatob\fR and \fIbtoa\fR
  must be installed and \fIcompress\fR must be available.
  If any of these is missing, this mailing kit is useless.
  .PP
***************
*** 247,253 ****
  .SH AUTHOR
  Raphael Manfredi <ram@eiffel.com>.
  
! \fIKit\fR was developed at the Ecole des Mines, Saint-Etienne,
! France.
  !GROK!THIS!
  chmod 444 kit.$manext
--- 269,276 ----
  .SH AUTHOR
  Raphael Manfredi <ram@eiffel.com>.
  
! \fIKit\fR was first developed at the Ecole des Mines, Saint-Etienne,
! France. Many improvements were added at Interactive Software
! Engineering Inc., Santa-Barbara CA, USA.
  !GROK!THIS!
  chmod 444 kit.$manext

Index: README
*** README.old	Sat Jan 11 19:24:11 1992
--- README	Sat Jan 11 19:24:12 1992
***************
*** 1,11 ****
                               kit 2.0
  
!              Copyright (c) 1990 1991, Raphael Manfredi
  
  You may copy this kit in whole or in part as long as you don't try to
  make money off it, or pretend you wrote it.
  ------------------------------------------------------------------------
! The ultimate mailing kit -- Assumes you own cshar (written by Rich Salz)
  
  Please read all the directions below before you proceed any further, and
  then follow them carefully.
--- 1,11 ----
                               kit 2.0
  
!            Copyright (c) 1990 1991 1992, Raphael Manfredi
  
  You may copy this kit in whole or in part as long as you don't try to
  make money off it, or pretend you wrote it.
  ------------------------------------------------------------------------
!                       The ultimate mailing kit
  
  Please read all the directions below before you proceed any further, and
  then follow them carefully.
***************
*** 13,24 ****
  After you have unpacked your kit, you should have all the files listed
  in MANIFEST.
  
! If you only wish to use unkit, then CSHAR is not necessary, though
! strongly recommended.
  
! In order to use kit, you need to install CSHAR in your PATH (programs
! needed are shar, makekit and unshar). Compress must be available. If you
! miss one of those, send me a mail: ram@eiffel.com (Raphael Manfredi).
  
  Moreover, hexdecode, hexencode, atob and btoa must be installed. The
  public-domain implementation of des, which is provided with kit, must
--- 13,25 ----
  After you have unpacked your kit, you should have all the files listed
  in MANIFEST.
  
! Kit used to rely on Rich Salz's cshar package but is now self-contained.
! However, if you have the opportunity to get cshar, I would recommend its
! installation. Kit will automatically use the tools from cshar when they
! are available.
  
! In order to use kit, you must have an implementation of compress. If you
! miss it, send me a mail: ram@eiffel.com (Raphael Manfredi).
  
  Moreover, hexdecode, hexencode, atob and btoa must be installed. The
  public-domain implementation of des, which is provided with kit, must
***************
*** 69,81 ****
  
  CREDITS
  
! Kit relies on two public-domain softwares:
  
! 	- cshar, written by Rich Salz.
  	- des, written by Phil Karn, which is provided with kit.
  
- To maintain and configure kit, I use the dist 2.0 package written
- by Larry Wall with some significant changes. If you wish to get a
- copy of it, feel free to ask me.
  
! 	-- Raphael
--- 70,93 ----
  
  CREDITS
  
! Kit relies on four public-domain softwares:
  
! 	- cshar, written by Rich Salz (kit will use it if possible).
  	- des, written by Phil Karn, which is provided with kit.
+ 	- btoa (as a stripped down implementation).
+ 	- badtar, written by Mike Williams, with a few enhancements.
  
  
! ACKNOWLEDGMENTS
! 
! I would like to thank:
! 	Gary Casterline <casterln@are.berkeley.edu>
! 	Michael Fischer <fischer-michael@cs.yale.edu>
! 	Monty Solomon <monty@bu.edu>
! for their bug reports and comments.
! 
! The criticism of Tim Kuehn <timk@wynnds.xenitec.on.ca> was also much
! appreciated.
! 
! 
! 	Raphael Manfredi <ram@eiffel.com>

Index: badtar/README
*** badtar/README.old	Sat Jan 11 19:24:17 1992
--- badtar/README	Sat Jan 11 19:24:18 1992
***************
*** 0 ****
--- 1,26 ----
+ The following program can be used to extract files from a tar tape which
+ contains read errors. It is used as a filter whose output should be piped
+ into tar thus:
+ 
+ 	badtar -f /dev/rmt16 -l log_file | tar xf -
+ 
+ This program is not perfect. It cannot read what cannot be read, but it
+ will continue over read errors, pad files to suitable lengths when blocks
+ are missing, ignore files whose header tar blocks are mangled etc...
+ 
+ The log file (-l flag) gives a list of all files found, indicates which of 
+ them were padded, shows where blocks were deleted (ie files were lost)
+ and where bad blocks occured on the tape. You can get a good idea from this
+ list where files will have been mangled or lost. All error messages begin with
+ *** which makes life easier to find errors in a long list.
+ 
+ Badtar was written by Mike Williams and appeared in net.sources in 1986.
+ I have worked on the code one day I could not read my backup tape... The
+ ownership overwriting has been written specially for kit. Badtar may be
+ used apart from kit, of course, as a standalone tool.
+ 
+ If you have suggestions on how to improve badtar, I would be pleased to
+ hear about it. However, I'd like to keep it small, being part of kit
+ delivery.
+ 
+ 	Raphael Manfredi <ram@eiffel.com>

Index: shar/README
*** shar/README.old	Sat Jan 11 19:25:11 1992
--- shar/README	Sat Jan 11 19:25:11 1992
***************
*** 0 ****
--- 1,18 ----
+ This directory contains a set of shell scripts which are to be used
+ by kit when cshar is not available. Those scripts are not intended
+ to be executed directly by the user, hence no manual page is provided
+ and the scripts are installed in the private library directory.
+ 
+ There should be no difference from the user's point of view when kit
+ uses those scripts instead of the cshar package. The aim was to make
+ kit a self-contained package. When possible however, cshar should be
+ installed. Kit will automatically use cshar whenever it can.
+ 
+ In the design of the shell archive produced by rshar, I freely borrowed
+ the style used by Rich Salz in his cshar package. In the makeshar script,
+ the algorithm used to assign each file a part number comes directly from
+ the makedist perl script found in Larry Wall's dist 2.0.
+ 
+ The scripts are so small they are installed in the public kit library
+ even if cshar is installed. It might be useful if the kit scripts are
+ shared accross different machines and some do miss cshar.

Index: Makefile.SH
Prereq: 2.0.1.4
*** Makefile.SH.old	Sat Jan 11 19:24:08 1992
--- Makefile.SH	Sat Jan 11 19:24:08 1992
***************
*** 18,26 ****
  #	Makefile for kit
  #
  
! # $Id: Makefile.SH,v 2.0.1.4 91/12/08 14:53:40 ram Exp $
  #
  # $Log:	Makefile.SH,v $
  # Revision 2.0.1.4  91/12/08  14:53:40  ram
  # patch10: make clobber was not removing cppstdin
  # 
--- 18,29 ----
  #	Makefile for kit
  #
  
! # $Id: Makefile.SH,v 2.0.1.5 92/01/11 19:08:43 ram Exp $
  #
  # $Log:	Makefile.SH,v $
+ # Revision 2.0.1.5  92/01/11  19:08:43  ram
+ # patch11: added subdirectories badtar and shar
+ # 
  # Revision 2.0.1.4  91/12/08  14:53:40  ram
  # patch10: make clobber was not removing cppstdin
  # 
***************
*** 39,45 ****
  
  SHELL = /bin/sh
  
! SUBDIRS = btoa kit man des
  RM = $rm
  !GROK!THIS!
  $spitshell >>Makefile <<'!NO!SUBS!'
--- 42,48 ----
  
  SHELL = /bin/sh
  
! SUBDIRS = badtar btoa kit shar man des
  RM = $rm
  !GROK!THIS!
  $spitshell >>Makefile <<'!NO!SUBS!'

Index: badtar/Makefile.SH
*** badtar/Makefile.SH.old	Sat Jan 11 19:24:14 1992
--- badtar/Makefile.SH	Sat Jan 11 19:24:15 1992
***************
*** 0 ****
--- 1,72 ----
+ case $CONFIG in
+ '')
+ 	if test ! -f config.sh; then
+ 		ln ../config.sh . || \
+ 		ln ../../config.sh . || \
+ 		ln ../../../config.sh . || \
+ 		(echo "Can't find config.sh."; exit 1)
+ 	fi 2>/dev/null
+ 	. config.sh
+ 	;;
+ esac
+ case "$0" in
+ */*) cd `expr X$0 : 'X\(.*\)/'` ;;
+ esac
+ echo "Extracting badtar/Makefile (with variable substitutions)"
+ $spitshell >Makefile <<!GROK!THIS!
+ #
+ # Makefile for kit (sub-directory badtar)
+ #
+ 
+ # $Id: Makefile.SH,v 2.0.1.1 92/01/11 19:11:57 ram Exp $
+ #
+ # $Log:	Makefile.SH,v $
+ # Revision 2.0.1.1  92/01/11  19:11:57  ram
+ # patch11: created
+ # 
+ 
+ SHELL = /bin/sh
+ 
+ CC = $cc
+ CFLAGS = $ccflags $optimize
+ RM = $rm
+ bin = $bin
+ man = $mansrc
+ manpage = badtar.$manext
+ !GROK!THIS!
+ case "$wantbtar" in
+ true)
+ $spitshell >>Makefile <<'!NO!SUBS!'
+ 
+ all: badtar $(manpage)
+ 
+ badtar: badtar.o
+ 	$(CC) $(CFLAGS) -o badtar badtar.o
+ 
+ $(manpage): badtar.SH
+ 	/bin/sh badtar.SH
+ 
+ install: badtar $(manpage)
+ 	../install -s -m 755 badtar $(bin)
+ 	../install -m 444 $(manpage) $(man)
+ 
+ clean:
+ 	rm -f *.o badtar $(manpage)
+ 
+ !NO!SUBS!
+ 	;;
+ *)
+ $spitshell >>Makefile <<'!NO!SUBS!'
+ 
+ all install clean:
+ 
+ !NO!SUBS!
+ 	;;
+ esac
+ $spitshell >>Makefile <<'!NO!SUBS!'
+ realclean clobber: clean
+ 	$(RM) -f core Makefile config.sh
+ 
+ !NO!SUBS!
+ chmod 755 Makefile
+ $eunicefix Makefile

Index: des/Makefile.SH
Prereq: 2.0.1.3
*** des/Makefile.SH.old	Sat Jan 11 19:24:32 1992
--- des/Makefile.SH	Sat Jan 11 19:24:32 1992
***************
*** 18,26 ****
  # Makefile for kit (sub-directory des)
  #
  
! # $Id: Makefile.SH,v 2.0.1.3 91/11/25 12:03:16 ram Exp $
  #
  # $Log:	Makefile.SH,v $
  # Revision 2.0.1.3  91/11/25  12:03:16  ram
  # patch8: this file was stamped with a wrong package name
  # 
--- 18,29 ----
  # Makefile for kit (sub-directory des)
  #
  
! # $Id: Makefile.SH,v 2.0.1.4 92/01/11 19:13:59 ram Exp $
  #
  # $Log:	Makefile.SH,v $
+ # Revision 2.0.1.4  92/01/11  19:13:59  ram
+ # patch11: now depends on the 'hasdes' configuration variable
+ # 
  # Revision 2.0.1.3  91/11/25  12:03:16  ram
  # patch8: this file was stamped with a wrong package name
  # 
***************
*** 40,45 ****
--- 43,50 ----
  RM = $rm
  bin = $bin
  !GROK!THIS!
+ case "$hasdes" in
+ false)
  $spitshell >>Makefile <<'!NO!SUBS!'
  
  all: $(ALL)
***************
*** 61,68 ****
--- 66,85 ----
  clean:
  	rm -f *.o des descert
  
+ !NO!SUBS!
+ 	;;
+ *)
+ $spitshell >>Makefile <<'!NO!SUBS!'
+ 
+ all install clean:
+ 
+ !NO!SUBS!
+ 	;;
+ esac
+ $spitshell >>Makefile <<'!NO!SUBS!'
  realclean clobber: clean
  	$(RM) -f certify core Makefile config.sh
+ 
  !NO!SUBS!
  chmod 755 Makefile
  $eunicefix Makefile

Index: shar/Makefile.SH
*** shar/Makefile.SH.old	Sat Jan 11 19:25:08 1992
--- shar/Makefile.SH	Sat Jan 11 19:25:08 1992
***************
*** 0 ****
--- 1,59 ----
+ case $CONFIG in
+ '')
+ 	if test ! -f config.sh; then
+ 		ln ../config.sh . || \
+ 		ln ../../config.sh . || \
+ 		ln ../../../config.sh . || \
+ 		(echo "Can't find config.sh."; exit 1)
+ 	fi
+ 	. config.sh
+ 	;;
+ esac
+ case "$0" in
+ */*) cd `expr X$0 : 'X\(.*\)/'` ;;
+ esac
+ echo "Extracting shar/Makefile (with variable substitutions)"
+ $spitshell >Makefile <<!GROK!THIS!
+ #
+ # Makefile for kit (sub-directory shar)
+ #
+ 
+ # $Id: Makefile.SH,v 2.0.1.1 92/01/11 19:22:47 ram Exp $
+ #
+ # $Log:	Makefile.SH,v $
+ # Revision 2.0.1.1  92/01/11  19:22:47  ram
+ # patch11: created
+ # 
+ 
+ SHELL = /bin/sh
+ 
+ RM = $rm
+ libdir = $privlib
+ 
+ !GROK!THIS!
+ $spitshell >>Makefile <<'!NO!SUBS!'
+ scripts = makeshar rshar
+ scriptsh = makeshar.SH rshar.SH
+ added = Makefile config.sh
+ 
+ all: $(scripts)
+ 
+ makeshar: makeshar.SH
+ 	sh $@.SH
+ 
+ rshar: rshar.SH
+ 	sh $@.SH
+ 
+ install: $(scripts)
+ 	-for file in $(scripts); do \
+ 		../install -m 555 $$file $(libdir); \
+ 	done
+ 
+ clean:
+ 	$(RM) -f $(scripts)
+ 
+ realclean clobber: clean
+ 	$(RM) -f $(added)
+ !NO!SUBS!
+ chmod 755 Makefile
+ $eunicefix Makefile

Index: MANIFEST
*** MANIFEST.old	Sat Jan 11 19:25:20 1992
--- MANIFEST	Sat Jan 11 19:25:21 1992
***************
*** 2,7 ****
--- 2,11 ----
  MANIFEST                   This shipping list
  Configure                  Portability tool
  Makefile.SH                Main makefile
+ badtar/Makefile.SH         Makefile for badtar
+ badtar/README              Informations on badtar
+ badtar/badtar.SH           Manual page for badtar
+ badtar/badtar.c            A program to repair damaged tar files
  btoa/Makefile.SH           Makefile for btoa and al.
  btoa/atob.c                For ascii to binary decoding
  btoa/btoa.c                For binary to ascii encoding
***************
*** 32,34 ****
--- 36,42 ----
  man/mailkit.SH             The manual page for "mailkit"
  man/unkit.SH               The manual page for "unkit"
  patchlevel.h               Current patch level value
+ shar/Makefile.SH           Makefile for shar
+ shar/README                Purpose of the shar scripts
+ shar/makeshar.SH           Builds a set of shar files
+ shar/rshar.SH              A simple shar program

*** End of Patch 11 ***
