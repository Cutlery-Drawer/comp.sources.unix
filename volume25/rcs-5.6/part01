Newsgroups: comp.sources.unix
From: hammer@cs.purdue.edu (Adam Hammer)
Subject: v25i077: rcs-5.6 - Revision Control System, V5.6, Part01/11
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: hammer@cs.purdue.edu (Adam Hammer)
Posting-Number: Volume 25, Issue 77
Archive-Name: rcs-5.6/part01

[ I split the rcs.ps (postscript version of the manual) into two parts.
  You will need to reassemble them with cat(1) before printing them. --vix ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 11)."
# Contents:  MANIFEST Makefile README man man/Makefile man/ident.1
#   man/merge.1 man/rcsclean.1 man/rcsdiff.1 man/rcsfile.5
#   man/rcsfreeze.1 man/rcsmerge.1 man/rlog.1 rcs_func.ms src
#   src/Makefile src/ident.c src/merge.c src/merger.c src/rcsclean.c
#   src/rcsfreeze.sh src/rcskeys.c src/rcsmap.c
# Wrapped by vixie@cognition.pa.dec.com on Fri Dec 20 16:23:39 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1770 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X COPYING                    3	
X MANIFEST                   1	
X Makefile                   1	
X README                     1	
X man                        1	
X man/Makefile               1	
X man/ci.1                   3	
X man/co.1                   3	
X man/ident.1                1	
X man/merge.1                1	
X man/rcs.1                  2	
X man/rcsclean.1             1	
X man/rcsdiff.1              1	
X man/rcsfile.5              1	
X man/rcsfreeze.1            1	
X man/rcsintro.1             2	
X man/rcsmerge.1             1	
X man/rlog.1                 1	
X rcs.ms                     9	
X rcs.ps.part1              11	
X rcs.ps.part2              10	
X rcs_func.ms                1	
X src                        1	
X src/COPYING                4	
X src/Makefile               1	
X src/README                 2	
X src/ci.c                   7	
X src/co.c                   5	
X src/conf.heg               3	
X src/conf.sh                7	
X src/ident.c                1	
X src/maketime.c             2	
X src/merge.c                1	
X src/merger.c               1	
X src/partime.c              4	
X src/rcs.c                  8	
X src/rcsbase.h              5	
X src/rcsclean.c             1	
X src/rcsdiff.c              2	
X src/rcsedit.c              8	
X src/rcsfcmp.c              2	
X src/rcsfnms.c              6	
X src/rcsfreeze.sh           1	
X src/rcsgen.c               3	
X src/rcskeep.c              2	
X src/rcskeys.c              1	
X src/rcslex.c               6	
X src/rcsmap.c               1	
X src/rcsmerge.c             2	
X src/rcsrev.c               5	
X src/rcssyn.c               4	
X src/rcstest                2	
X src/rcsutil.c              4	
X src/rlog.c                 6	
END_OF_FILE
if test 1770 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(300 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
SUBDIR=	src man
DESTDIR=
X
all: ${SUBDIR}
X
X${SUBDIR}: FRC
X	cd $@; make ${MFLAGS} DESTDIR=${DESTDIR}
X
install:
X	for i in ${SUBDIR}; do \
X		(cd $$i; make ${MFLAGS} DESTDIR=${DESTDIR} install); \
X	done
X
clean:
X	for i in ${SUBDIR}; do \
X		(cd $$i; make ${MFLAGS} DESTDIR=${DESTDIR} clean); \
X	done
X
XFRC:
X
END_OF_FILE
if test 300 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(17679 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
This directory contains complete sources for RCS version 5.6.
X
RCS, the Revision Control System, manages multiple revisions of files.
RCS can store, retrieve, log, identify, and merge revisions.
It is useful for files that are revised frequently,
e.g. programs, documentation, graphics, and papers.
X
X/* Copyright (C) 1982, 1988, 1989 Walter Tichy
X   Copyright 1990, 1991 by Paul Eggert
X   Distributed under license by the Free Software Foundation, Inc.
X
This file is part of RCS.
X
RCS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
X
RCS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
X
You should have received a copy of the GNU General Public License
along with RCS; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
Report problems and direct all questions to:
X
X    rcs-bugs@cs.purdue.edu
X
X*/
X
X$Id: README,v 5.16 1991/11/03 01:09:19 eggert Exp $
X
X
Installation notes:
X
X  RCS requires a diff that supports the -n option.
X  Get GNU diff (version 1.15 or later) if your diff lacks -n.
X
X  RCS works best with a diff that supports -a and -L,
X  and a diff3 that supports -E and -m.
X  GNU diff supports these options.
X
X  Sources for RCS are in the src directory.
X  Read the directions in src/README to build RCS on your system.
X
X  Manual entries reside in man.
X
X  Troff source for the paper `RCS--A System for Version Control', which
X  appeared in _Software--Practice & Experience_, is in rcs.ms.
X
X  If you don't have troff, you can get GNU groff to format the documentation.
X
X
RCS compatibility notes:
X
X  RCS version 5 reads RCS files written by any RCS version released since 1982.
X  It also writes RCS files that these older versions of RCS can read,
X  unless you use one of the following new features:
X
X	checkin times after 1999/12/31 23:59:59 GMT
X	checking in non-text files
X	non-Ascii symbolic names
X	rcs -bX, where X is nonempty
X	rcs -kX, where X is not `kv'
X	RCS files that exceed hardcoded limits in older RCS versions
X
X  A working file written by RCS 5.5 or later contains four-digit years in its
X  keyword strings.  If you check out a working file with RCS 5.5 or later,
X  an older RCS version's `ci -k' may insist on two-digit years.
X  Fix this with `co -V4', or by editing the working file.
X
X
XFeatures new to RCS version 5.6 include:
X
X  Security holes have been plugged; setgid use is no longer supported.
X
X  co can retrieve old revisions much more efficiently.
X  To generate the Nth youngest revision on the trunk,
X  the old method used up to N passes through copies of the working file;
X  the new method uses a piece table to generate the working file in one pass.
X
X  When ci finds no changes in the working file,
X  it automatically reverts to the previous revision unless -f is given.
X
X  RCS follows symbolic links to RCS files instead of breaking them,
X  and warns when it breaks hard links to RCS files.
X
X  `$' stands for the revision number taken from working file keyword strings.
X  E.g. if F contains an Id keyword string,
X  `rcsdiff -r$ F' compares F to its checked-in revision, and
X  `rcs -nL:$ F' gives the symbolic name L to F's revision.
X
X  co and ci's new -M option sets the modification time
X  of the working file to be that of the revision.
X  Without -M, ci now tries to avoid changing the working file's
X  modification time if its contents are unchanged.
X
X  rcs's new -m option changes the log message of an old revision.
X
X  RCS is portable to hosts that do not permit `,' in filenames.
X  (`,' is not part of the Posix portable filename character set.)
X  A new -x option specifies extensions other than `,v' for RCS files.
X  The Unix default is `-x,v/', so that the working file `w' corresponds
X  to the first file in the list `RCS/w,v', `w,v', `RCS/w' that works.
X  The non-Unix default is `-x', so that only `RCS/w' is tried.
X  Eventually, the Unix default should change to `-x/,v'
X  to encourage interoperability among all Posix hosts.
X
X  A new RCSINIT environment variable specifies defaults for options like -x.
X
X  The separator for revision ranges has been changed from `-' to `:', because
X  the range `A-B' is ambiguous if `A', `B' and `A-B' are all symbolic names.
X  E.g. the old `rlog -r1.5-1.7' is now `rlog -r1.5:1.7'; ditto for `rcs -o'.
X  For a while RCS will still support (but warn about) the old `-' separator.
X
X  RCS manipulates its lock files using a method that is more reliable under NFS.
X
X  Experimental support for MS-DOS and OS/2 is available as part of a separate
X  software distribution.
X
X
XFeatures new to RCS version 5 include:
X
X  RCS can check in arbitrary files, not just text files, if diff -a works.
X  RCS can merge lines containing just a single `.' if diff3 -m works.
X  GNU diff supports the -a and -m options.
X
X  RCS can now be used as a setuid program.
X  See ci(1) for how users can employ setuid copies of ci, co, and rcsclean.
X  Setuid privileges yield extra security if the effective user owns RCS files
X  and directories, and if only the effective user can write RCS directories.
X  RCS uses the real user for all accesses other than writing RCS directories.
X  As described in ci(1), there are three levels of setuid support.
X
X    1.  Setuid works fully if the seteuid() system call lets any
X    process switch back and forth between real and effective users,
X    as specified in Posix 1003.1a Draft 5.
X
X    2.  On hosts with saved setuids (a Posix 1003.1-1990 option) and without
X    a modern seteuid(), setuid works unless the real or effective user is root.
X
X    3.  On hosts that lack both modern seteuid() and saved setuids,
X    setuid does not work, and RCS uses the effective user for all accesses;
X    formerly it was inconsistent.
X
X  New options to co, rcsdiff, and rcsmerge give more flexibility to keyword
X  substitution.
X
X    -kkv substitutes the default `$Keyword: value $' for keyword strings.
X    However, a locker's name is inserted only as a file is being locked,
X    i.e. by `ci -l' and `co -l'.  This is normally the default.
X
X    -kkvl acts like -kkv, except that a locker's name is always inserted
X    if the given revision is currently locked.  This was the default in
X    version 4.  It is now the default only with when using rcsdiff to
X    compare a revision to a working file whose mode is that of a file
X    checked out for changes.
X
X    -kk substitutes just `$Keyword$', which helps to ignore keyword values
X    when comparing revisions.
X
X    -ko retrieves the old revision's keyword string, thus bypassing keyword
X    substitution.
X
X    -kv retrieves just `value'.  This can ease the use of keyword values, but
X    it is dangerous because it causes RCS to lose track of where the keywords
X    are, so for safety the owner write permission of the working file is
X    turned off when -kv is used; to edit the file later, check it out again
X    without -kv.
X
X  rcs -ko sets the default keyword substitution to be in the style of co -ko,
X  and similarly for the other -k options.  This can be useful with binary file
X  formats that cannot tolerate changing the lengths of keyword strings.
X  However it also renders a RCS file readable only by RCS version 5 or later.
X  Use rcs -kkv to restore the usual default substitution.
X
X  RCS can now be used by development groups that span timezone boundaries.
X  All times are now displayed in GMT, and GMT is the default timezone.
X  To use local time with co -d, append ` LT' to the time.
X  When interchanging RCS files with sites running older versions of RCS,
X  time stamp discrepancies may prevent checkins; to work around this,
X  use `ci -d' with a time slightly in the future.
X
X  Dates are now displayed using four-digit years, not two-digit years.
X  Years given in -d options must now have four digits.
X  This change is required for RCS to continue to work after 1999/12/31.
X  The form of dates in version 5 RCS files will not change until 2000/01/01,
X  so in the meantime RCS files can still be interchanged with sites
X  running older versions of RCS.  To make room for the longer dates,
X  rlog now outputs `lines: +A -D' instead of `lines added/del: A/D'.
X
X  To help prevent diff programs that are broken or have run out of memory
X  from trashing an RCS file, ci now checks diff output more carefully.
X
X  ci -k now handles the Log keyword, so that checking in a file
X  with -k does not normally alter the file's contents.
X
X  RCS no longer outputs white space at the ends of lines
X  unless the original working file had it.
X  For consistency with other keywords,
X  a space, not a tab, is now output after `$Log:'.
X  Rlog now puts lockers and symbolic names on separate lines in the output
X  to avoid generating lines that are too long.
X  A similar fix has been made to lists in the RCS files themselves.
X
X  RCS no longer outputs the string `Locker: ' when expanding Header or Id
X  keywords.  This saves space and reverts back to version 3 behavior.
X
X  The default branch is not put into the RCS file unless it is nonempty.
X  Therefore, files generated by RCS version 5 can be read by RCS version 3
X  unless they use the default branch feature introduced in version 4.
X  This fixes a compatibility problem introduced by version 4.
X
X  RCS can now emulate older versions of RCS; see `co -V'.
X  This may be useful to overcome compatibility problems
X  due to the above changes.
X
X  Programs like Emacs can now interact with RCS commands via a pipe:
X  the new -I option causes ci, co, and rcs to run interactively,
X  even if standard input is not a terminal.
X  These commands now accept multiple inputs from stdin separated by `.' lines.
X
X  ci now silently ignores the -t option if the RCS file already exists.
X  This simplifies some shell scripts and improves security in setuid sites.
X
X  Descriptive text may be given directly in an argument of the form -t-string.
X
X  The character set for symbolic names has been upgraded
X  from Ascii to ISO 8859.
X
X  rcsdiff now passes through all options used by GNU diff;
X  this is a longer list than 4.3BSD diff.
X
X  merge's new -L option gives tags for merge's overlap report lines.
X  This ability used to be present in a different, undocumented form;
X  the new form is chosen for compatibility with GNU diff3's -L option.
X
X  rcsmerge and merge now have a -q option, just like their siblings do.
X
X  RCS now attempts to ignore parts of an RCS file that look like they come
X  from a future version of RCS.
X
X  When properly configured, RCS now strictly conforms with Posix 1003.1-1990.
X  RCS can still be compiled in non-Posix traditional Unix environments,
X  and can use common BSD and USG extensions to Posix.
X  RCS is a conforming Standard C program, and also compiles under traditional C.
X
X  Arbitrary limits on internal table sizes have been removed.
X  The only limit now is the amount of memory available via malloc().
X
X  File temporaries, lock files, signals, and system call return codes
X  are now handled more cleanly, portably, and quickly.
X  Some race conditions have been removed.
X
X  A new compile-time option RCSPREFIX lets administrators avoid absolute path
X  names for subsidiary programs, trading speed for flexibility.
X
X  The configuration procedure is now more automatic.
X
X  Snooping has been removed.
X
X
Version 4 was the first version distributed by FSF.
Beside bug fixes, features new to RCS version 4 include:
X
X  The notion of default branch has been added; see rcs -b.
X
X
Version 3 was included in the 4.3BSD distribution.
X
X
XFurther projects:
X
X  Add format options for finer control over the output of ident and rlog.
X
X  Be able to redo the most recent checkin with minor changes.
X
X  Add a `-' option to take the list of pathnames from standard input.
X  Perhaps the pathnames should be null-terminated, not newline-terminated,
X  so that pathnames that contain newlines are handled properly.
X
X  Add general options so that rcsdiff and rcsmerge can pass arbitrary options
X  to its subsidiary co and diff processes.  E.g.
X
X	-.OPTION to pass OPTION to the subsidiary `co'
X	-/OPTION to pass OPTION to the subsidiary `diff' (for rcsdiff only)
X
X  For example:
X
X	rcsdiff -.-d"1991/02/09 18:09" -.-sRel -/+unified -/-C -/5 -/-d foo.c
X
X  invokes `co -d"1991/02/09 18:09" -sRel ...' and `diff +unified -C 5 -d ...'.
X  To pass an option to just one subsidiary `co', put the -. option
X  after the corresponding -r option.  For example:
X
X	rcsmerge -r1.4 -.-ko -r1.8 -.-kkv foo.c
X
X  passes `-ko' to the first subsidiary `co', and `-kkv' to the second one.
X
X
X  Permit multiple option-pathname pairs, e.g. co -r1.4 a -r1.5 b.
X
X  Add ways to specify the earliest revision, the most recent revision,
X  the earliest or latest revision on a particular branch, and
X  the parent or child of some other revision.
X
X  If a user has multiple locks, perhaps ci should fall back on ci -k's
X  method to figure out which revision to use.
X
X  Symbolic names need not refer to existing branches and revisions.
X  rcs(1)'s BUGS section says this is a bug.  Is it?  If so, it should be fixed.
X
X  Write an rcsck program that repairs corrupted RCS files,
X  much as fsck repairs corrupted file systems.
X
X  Clean up the source code with a consistent indenting style.
X
X  Update the date parser to use the more modern getdate.y by Bellovin,
X  Salz, and Berets, or the even more modern getdate by Moraes.  None of
X  these getdate implementations are as robust as RCS's old warhorse in
X  avoiding problems like arithmetic overflow, so they'll have to be
X  fixed first.
X
X  Break up the code into a library so that it's easier to write new programs
X  that manipulate RCS files, and so that useless code is removed from the
X  existing programs.  For example, the rcs command contains unnecessary
X  keyword substitution baggage, and the merge command can be greatly pruned.
X
X  Make it easier to use your favorite text editor to edit log messages,
X  etc. instead of having to type them in irretrievably at the terminal.
X
The following projects require a change to RCS file format,
and thus must wait until at least RCS version 6.
X
X  Be able to store RCS files in compressed format.
X  Don't bother to use a .Z extension that would exceed file name length limits;
X  just look at the magic number.
X
X  Add locker commentary, e.g. `co -l -m"checkout to fix merge bug" foo'
X  to tell others why you checked out `foo'.
X  Also record the time when the revision was locked,
X  and perhaps the working pathname (if applicable).
X
X  Let the user mark an RCS revision as deleted; checking out such a revision
X  would result in no working file.  Similarly, using `co -d' with a date either
X  before the initial revision or after the file was marked deleted should
X  remove the working file.  For extra credit, extend the notion of `deleted' to
X  include `renamed'.  RCS should support arbitrary combinations of renaming and
X  deletion, e.g. renaming A to B and B to A, checking in new revisions to both
X  files, and then renaming them back.
X
X  Use a better scheme for locking revisions; the current scheme requires
X  changing the RCS file just to lock or unlock a revision.
X  The new scheme should coexist as well as possible with older versions of RCS,
X  and should avoid the rare NFS bugs mentioned in rcsedit.c.
X
X  Add rcs options for changing keyword names, e.g. XConsortium instead of Id.
X
X  Add frozen branches a la SCCS.  In general, be able to emulate all of
X  SCCS, so that an SCCS-to-RCS program can be practical.
X
X  Add support for distributed RCS, where widely separated
X  users cannot easily access each others' RCS files,
X  and must periodically distribute and reconcile new revisions.
X
X  Be able to create empty branches.
X
X  Improve RCS's method for storing binary files.
X  Although it is more efficient than SCCS's,
X  the diff algorithm is still line oriented,
X  and often generates long output for minor changes to an executable file.
X
X  Add a new `-kb' expansion for binary files on non-Posix hosts
X  that distinguish between text and binary I/O.
X  The current `text_work_stdio' compile-time switch is too inflexible.
X  This fix either requires nonstandard primitives like DOS's setmode(),
X  or requires that `-kb' be specified on initial checkin and never changed.
X  From the user's point of view, it would be best if
X  RCS detected and handled binary files without human intervention,
X  switching expansion methods as needed from revision to revision.
X
X  Extend the grammar of RCS files so that keywords need not be in a fixed order.
X
X  Internationalize messages; unfortunately, there's no common standard yet.
X  This requires a change in RCS file format because of the
X  `empty log message' and `checked in with -k' hacks inside RCS files.
X
X
Credits:
X
X  RCS was designed and built by Walter F. Tichy of Purdue University.
X  RCS version 3 was released in 1983.
X
X  Adam Hammer, Thomas Narten, and Dan Trinkle of Purdue supported RCS through
X  version 4.3, released in 1990.  Guy Harris of Sun contributed many porting
X  fixes.  Paul Eggert of System Development Corporation contributed bug fixes
X  and tuneups.  Jay Lepreau contributed 4.3BSD support.
X
X  Paul Eggert of Twin Sun wrote the changes for RCS version 5, released in 1991.
X  Rich Braun of Kronos and Andy Glew of Intel contributed ideas for new options.
X  Bill Hahn of Stratus contributed ideas for setuid support.
X  Ideas for piece tables came from Joe Berkovitz of Stratus and Walter F. Tichy.
X  Matt Cross of Stratus contributed test case ideas.
X  Adam Hammer of Purdue QAed.
END_OF_FILE
if test 17679 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'man' ; then
    echo shar: Creating directory \"'man'\"
    mkdir 'man'
fi
if test -f 'man/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/Makefile'\"
else
echo shar: Extracting \"'man/Makefile'\" \(603 characters\)
sed "s/^X//" >'man/Makefile' <<'END_OF_FILE'
X# Make RCS man pages.
X
X#	$Id: Makefile,v 5.2 1991/08/19 03:13:55 eggert Exp $
X
MANDIR = /usr/man
X
install = install -c -m 444
X
all clean ::
X
install ::
X	${install} ci.1 ${DESTDIR}${MANDIR}/man1
X	${install} co.1 ${DESTDIR}${MANDIR}/man1
X	${install} ident.1 ${DESTDIR}${MANDIR}/man1
X	${install} merge.1 ${DESTDIR}${MANDIR}/man1
X	${install} rcs.1 ${DESTDIR}${MANDIR}/man1
X	${install} rcsdiff.1 ${DESTDIR}${MANDIR}/man1
X	${install} rcsintro.1 ${DESTDIR}${MANDIR}/man1
X	${install} rcsmerge.1 ${DESTDIR}${MANDIR}/man1
X	${install} rlog.1 ${DESTDIR}${MANDIR}/man1
X	${install} rcsfile.5 ${DESTDIR}${MANDIR}/man5
END_OF_FILE
if test 603 -ne `wc -c <'man/Makefile'`; then
    echo shar: \"'man/Makefile'\" unpacked with wrong size!
fi
# end of 'man/Makefile'
fi
if test -f 'man/ident.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/ident.1'\"
else
echo shar: Extracting \"'man/ident.1'\" \(1414 characters\)
sed "s/^X//" >'man/ident.1' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X.ds iD \\$3 \\$4 \\$5 \\$6 \\$7
X..
X.Id $Id: ident.1,v 5.0 1990/08/22 09:09:36 eggert Exp $
X.ds r \s-1RCS\s0
X.if n .ds - \%--
X.if t .ds - \(em
X.TH IDENT 1 \*(Dt GNU
X.SH NAME
ident \- identify files
X.SH SYNOPSIS
X.B ident
X[
X.B \-q
X] [
X.I file
X\&.\|.\|. ]
X.SH DESCRIPTION
X.B ident
searches for all occurrences of the pattern
X.BI $ keyword : .\|.\|. $
in the named files or, if no file name appears, the standard input.
X.PP
These patterns are normally inserted automatically by the \*r command
X.BR co (1),
but can also be inserted manually.
The option
X.B \-q
suppresses
the warning given if there are no patterns in a file.
X.PP
X.B ident
works on text files as well as object files and dumps.
XFor example, if the C program in
X.B f.c
contains
X.IP
X\f3char rcsid[] = \&"$\&Id: f.c,v \*(iD $\&";\fP
X.LP
and
X.B f.c
is compiled into
X.BR f.o ,
then the command
X.IP
X.B "ident  f.c  f.o"
X.LP
will output
X.nf
X.IP
X.ft 3
f.c:
X    $\&Id: f.c,v \*(iD $
f.o:
X    $\&Id: f.c,v \*(iD $
X.ft
X.fi
X.SH IDENTIFICATION
Author: Walter F. Tichy.
X.br
Revision Number: \*(Rv; Release Date: \*(Dt.
X.br
Copyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
Copyright \(co 1990 by Paul Eggert.
X.SH "SEE ALSO"
ci(1), co(1), rcs(1), rcsdiff(1), rcsintro(1), rcsmerge(1), rlog(1),
rcsfile(5)
X.br
Walter F. Tichy,
X\*r\*-A System for Version Control,
X.I "Software\*-Practice & Experience"
X.BR 15 ,
X7 (July 1985), 637-654.
END_OF_FILE
if test 1414 -ne `wc -c <'man/ident.1'`; then
    echo shar: \"'man/ident.1'\" unpacked with wrong size!
fi
# end of 'man/ident.1'
fi
if test -f 'man/merge.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/merge.1'\"
else
echo shar: Extracting \"'man/merge.1'\" \(1787 characters\)
sed "s/^X//" >'man/merge.1' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: merge.1,v 5.3 1991/02/28 19:18:45 eggert Exp $
X.TH MERGE 1 \*(Dt GNU
X.SH NAME
merge \- three-way file merge
X.SH SYNOPSIS
X.B merge
X[
X.B \-L
X.I label1
X[
X.B \-L
X.I label3
X] ] [
X.B \-p
X] [
X.B \-q
X]
X.I "file1 file2 file3"
X.SH DESCRIPTION
X.B merge
incorporates all changes that lead from
X.I file2
to
X.I file3
into
X.IR file1 .
The result goes to standard output if
X.B \-p
is present, into
X.I file1
otherwise.
X.B merge
is useful for combining separate changes to an original.  Suppose
X.I file2
is the original, and both
X.I file1
and
X.I file3
are modifications of
X.IR file2 .
Then
X.B merge
combines both changes.
X.PP
An overlap occurs if both
X.I file1
and
X.I file3
have changes in a common segment of lines.
On a few older hosts where
X.B diff3
does not support the
X.B \-E
option,
X.B merge
does not detect overlaps, and merely supplies the changed lines from
X.I file3.
On most hosts, if overlaps occur,
X.B merge
outputs a message (unless the
X.B \-q
option is given),
and includes both alternatives
in the result.  The alternatives are delimited as follows:
X.LP
X.RS
X.nf
X.BI <<<<<<< " file1"
X.I "lines in file1"
X.B "======="
X.I "lines in file3"
X.BI >>>>>>> " file3"
X.RE
X.fi
X.LP
If there are overlaps, the user should edit the result and delete one of the
alternatives.
If the
X.BI \-L "\ label1"
and
X.BI \-L "\ label3"
options are given, the labels are output in place of the names
X.I file1
and
X.I file3
in overlap reports.
X.SH DIAGNOSTICS
XExit status is 0 for no overlaps, 1 for some overlaps, 2 for trouble.
X.SH IDENTIFICATION
Author: Walter F. Tichy.
X.br
Revision Number: \*(Rv; Release Date: \*(Dt.
X.br
Copyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
Copyright \(co 1990, 1991 by Paul Eggert.
X.SH SEE ALSO
diff3(1), diff(1), rcsmerge(1), co(1).
END_OF_FILE
if test 1787 -ne `wc -c <'man/merge.1'`; then
    echo shar: \"'man/merge.1'\" unpacked with wrong size!
fi
# end of 'man/merge.1'
fi
if test -f 'man/rcsclean.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/rcsclean.1'\"
else
echo shar: Extracting \"'man/rcsclean.1'\" \(3703 characters\)
sed "s/^X//" >'man/rcsclean.1' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: rcsclean.1,v 1.8 1991/11/03 01:09:19 eggert Exp $
X.ds r \&\s-1RCS\s0
X.if n .ds - \%--
X.if t .ds - \(em
X.TH RCSCLEAN 1 \*(Dt GNU
X.SH NAME
rcsclean \- clean up working files
X.SH SYNOPSIS
X.B rcsclean
X.RI [ options "] [ " file " .\|.\|. ]"
X.SH DESCRIPTION
X.B rcsclean
removes working files that were checked out and never modified.
XFor each
X.I file
given,
X.B rcsclean
compares the working file and a revision in the corresponding
X\*r file.  If it finds a difference, it does nothing.
Otherwise, it first unlocks the revision if the
X.B \-u
option is given,
and then removes the working file
unless the working file is writable and the revision is locked.
It logs its actions by outputting the corresponding
X.B "rcs \-u"
and
X.B "rm \-f"
commands on the standard output.
X.PP
If no
X.I file
is given, all working files in the current directory are cleaned.
Pathnames matching an \*r suffix denote \*r files;
all others denote working files.
Names are paired as explained in
X.BR ci (1).
X.PP
The number of the revision to which the working file is compared
may be attached to any of the options
X.BR \-n ,
X.BR \-q ,
X.BR \-r ,
or
X.BR \-u .
If no revision number is specified, then if the
X.B \-u
option is given and the caller has one revision locked,
X.B rcsclean
uses that revision; otherwise
X.B rcsclean
uses the latest revision on the default branch, normally the root.
X.PP
X.B rcsclean
is useful for
X.B clean
targets in Makefiles.
See also
X.BR rcsdiff (1),
which prints out the differences,
and
X.BR ci (1),
which
normally asks whether to check in a file
if it was not changed.
X.SH OPTIONS
X.TP
X.BI \-k subst
Use
X.I subst
style keyword substitution when retrieving the revision for comparison.
See
X.BR co (1)
for details.
X.TP
X.BR \-n [\f2rev\fP]
Do not actually remove any files or unlock any revisions.
Using this option will tell you what
X.B rcsclean
would do without actually doing it.
X.TP
X.BR \-q [\f2rev\fP]
Do not log the actions taken on standard output.
X.TP
X.BR \-r [\f2rev\fP]
This option has no effect other than specifying the revision for comparison.
X.TP
X.BR \-u [\f2rev\fP]
Unlock the revision if it is locked and no difference is found.
X.TP
X.BI \-V n
XEmulate \*r version
X.IR n .
See
X.BR co (1)
for details.
X.TP
X.BI \-x "suffixes"
Use
X.I suffixes
to characterize \*r files.
See
X.BR ci (1)
for details.
X.SH EXAMPLES
X.LP
X.RS
X.ft 3
rcsclean  *.c  *.h
X.ft
X.RE
X.LP
removes all working files ending in
X.B .c
or
X.B .h
that were not changed
since their checkout.
X.LP
X.RS
X.ft 3
rcsclean
X.ft
X.RE
X.LP
removes all working files in the current directory
that were not changed since their checkout.
X.SH FILES
X.B rcsclean
accesses files much as
X.BR ci (1)
does.
X.SH ENVIRONMENT
X.TP
X.B \s-1RCSINIT\s0
options prepended to the argument list, separated by spaces.
A backslash escapes spaces within an option.
The
X.B \s-1RCSINIT\s0
options are prepended to the argument lists of most \*r commands.
Useful
X.B \s-1RCSINIT\s0
options include
X.BR \-q ,
X.BR \-V ,
and
X.BR \-x .
X.SH DIAGNOSTICS
The exit status is zero if and only if all operations were successful.
Missing working files and \*r files are silently ignored.
X.SH IDENTIFICATION
Author: Walter F. Tichy.
X.br
Revision Number: \*(Rv; Release Date: \*(Dt.
X.br
Copyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
Copyright \(co 1990, 1991 by Paul Eggert.
X.SH "SEE ALSO"
ci(1), co(1), ident(1), rcs(1), rcsdiff(1), rcsintro(1), rcsmerge(1), rlog(1),
rcsfile(5)
X.br
Walter F. Tichy,
X\*r\*-A System for Version Control,
X.I "Software\*-Practice & Experience"
X.BR 15 ,
X7 (July 1985), 637-654.
X.SH BUGS
At least one
X.I file
must be given in older Unix versions that
do not provide the needed directory scanning operations.
X.br
END_OF_FILE
if test 3703 -ne `wc -c <'man/rcsclean.1'`; then
    echo shar: \"'man/rcsclean.1'\" unpacked with wrong size!
fi
# end of 'man/rcsclean.1'
fi
if test -f 'man/rcsdiff.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/rcsdiff.1'\"
else
echo shar: Extracting \"'man/rcsdiff.1'\" \(2809 characters\)
sed "s/^X//" >'man/rcsdiff.1' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: rcsdiff.1,v 5.3 1991/04/21 12:00:46 eggert Exp $
X.ds r \&\s-1RCS\s0
X.if n .ds - \%--
X.if t .ds - \(em
X.TH RCSDIFF 1 \*(Dt GNU
X.SH NAME
rcsdiff \- compare RCS revisions
X.SH SYNOPSIS
X.B rcsdiff
X[
X.BI \-k subst
X] [
X.B \-q
X] [
X.BI \-r rev1
X[
X.BI \-r rev2
X] ] [
X.BI \-V n
X] [
X.BI \-x suffixes
X] [
X.I "diff options"
X]
X.I "file .\|.\|."
X.SH DESCRIPTION
X.B rcsdiff
runs
X.BR diff (1)
to compare two revisions of each \*r file given.
X.PP
Pathnames matching an \*r suffix denote \*r files;
all others denote working files.
Names are paired as explained in
X.BR ci (1).
X.PP
The option
X.B \-q
suppresses diagnostic output.
Zero, one, or two revisions may be specified with
X.BR \-r .
The option
X.BI \-k subst
affects keyword substitution when extracting
revisions, as described in
X.BR co (1);
for example,
X.B "\-kk\ \-r1.1\ \-r1.2"
ignores differences in keyword values when comparing revisions
X.B 1.1
and
X.BR 1.2 .
To avoid excess output from locker name substitution,
X.B \-kkvl
is assumed if (1) at most one revision option is given,
X(2) no
X.B \-k
option is given, (3)
X.B \-kkv
is the default keyword substitution, and
X(4) the working file's mode would be produced by
X.BR "co\ \-l".
See
X.BR co (1)
for details
about
X.B \-V
and
X.BR \-x .
Otherwise, all options of
X.BR diff (1)
that apply to regular files are accepted, with the same meaning as for
X.BR diff .
X.PP
If both
X.I rev1
and
X.I rev2
are omitted,
X.B rcsdiff
compares the latest revision on the
default branch (by default the trunk)
with the contents of the corresponding working file.  This is useful
for determining what you changed since the last checkin.
X.PP
If
X.I rev1
is given, but
X.I rev2
is omitted,
X.B rcsdiff
compares revision
X.I rev1
of the \*r file with
the contents of the corresponding working file.
X.PP
If both
X.I rev1
and
X.I rev2
are given,
X.B rcsdiff
compares revisions
X.I rev1
and
X.I rev2
of the \*r file.
X.PP
Both
X.I rev1
and
X.I rev2
may be given numerically or symbolically.
X.SH EXAMPLE
The command
X.LP
X.B "        rcsdiff  f.c"
X.LP
compares the latest revision on the default branch of the \*r file
to the contents of the working file
X.BR f.c .
X.SH ENVIRONMENT
X.TP
X.B \s-1RCSINIT\s0
options prepended to the argument list, separated by spaces.
See
X.BR ci (1)
for details.
X.SH DIAGNOSTICS
XExit status is 0 for no differences during any comparison,
X1 for some differences, 2 for trouble.
X.SH IDENTIFICATION
Author: Walter F. Tichy.
X.br
Revision Number: \*(Rv; Release Date: \*(Dt.
X.br
Copyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
Copyright \(co 1990, 1991 by Paul Eggert.
X.SH "SEE ALSO"
ci(1), co(1), diff(1), ident(1), rcs(1), rcsintro(1), rcsmerge(1), rlog(1)
X.br
Walter F. Tichy,
X\*r\*-A System for Version Control,
X.I "Software\*-Practice & Experience"
X.BR 15 ,
X7 (July 1985), 637-654.
X.br
END_OF_FILE
if test 2809 -ne `wc -c <'man/rcsdiff.1'`; then
    echo shar: \"'man/rcsdiff.1'\" unpacked with wrong size!
fi
# end of 'man/rcsdiff.1'
fi
if test -f 'man/rcsfile.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/rcsfile.5'\"
else
echo shar: Extracting \"'man/rcsfile.5'\" \(6267 characters\)
sed "s/^X//" >'man/rcsfile.5' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: rcsfile.5,v 5.1 1991/08/19 03:13:55 eggert Exp $
X.ds r \s-1RCS\s0
X.if n .ds - \%--
X.if t .ds - \(em
X.TH RCSFILE 5 \*(Dt GNU
X.SH NAME
rcsfile \- format of RCS file
X.SH DESCRIPTION
An \*r file's
contents are described by the grammar
below.
X.PP
The text is free format: space, backspace, tab, newline, vertical
tab, form feed, and carriage return (collectively,
X.IR "white space")
have no significance except in strings.
However, an \*r file must end in a newline character.
X.PP
Strings are enclosed by
X.BR @ .
If a string contains a
X.BR @ ,
it must be doubled;
otherwise, strings may contain arbitrary binary data.
X.PP
The meta syntax uses the following conventions: `|' (bar) separates
alternatives; `{' and `}' enclose optional phrases; `{' and `}*' enclose
phrases that may be repeated zero or more times;
X`{' and '}+' enclose phrases that must appear at least once and may be
repeated;
Terminal symbols are in
X.BR boldface ;
nonterminal symbols are in
X.IR italics .
X.LP
X.nr x \w'\f3branches\fP'
X.nr y \w'{ \f3comment\fP'
X.if \nx<\ny .nr x \ny
X.nr y \w'\f3{ branch\fP'
X.if \nx<\ny .nr x \ny
X.ta \w'\f2deltatext\fP  'u +\w'::=  'u +\nxu+\w'  'u
X.fc ~
X.nf
X\f2rcstext\fP	::=	\f2admin\fP {\f2delta\fP}* \f2desc\fP {\f2deltatext\fP}*
X.LP
X\f2admin\fP	::=	\f3head\fP	{\f2num\fP}\f3;\fP
X		{ \f3branch\fP	{\f2num\fP}\f3;\fP }
X		\f3access\fP	{\f2id\fP}*\f3;\fP
X		\f3symbols\fP	{\f2id\fP \f3:\fP \f2num\fP}*\f3;\fP
X		\f3locks\fP	{\f2id\fP \f3:\fP \f2num\fP}*\f3;\fP  {\f3strict  ;\fP}
X		{ \f3comment\fP	{\f2string\fP}\f3;\fP }
X		{ \f3expand\fP	{\f2string\fP}\f3;\fP }
X		{ \f2newphrase\fP }*
X.LP
X\f2delta\fP	::=	\f2num\fP
X		\f3date\fP	\f2num\fP\f3;\fP
X		\f3author\fP	\f2id\fP\f3;\fP
X		\f3state\fP	{\f2id\fP}\f3;\fP
X		\f3branches\fP	{\f2num\fP}*\f3;\fP
X		\f3next\fP	{\f2num\fP}\f3;\fP
X		{ \f2newphrase\fP }*
X.LP
X\f2desc\fP	::=	\f3desc\fP	\f2string\fP
X.LP
X\f2deltatext\fP	::=	\f2num\fP
X		\f3log\fP	\f2string\fP
X		{ \f2newphrase\fP }*
X		\f3text\fP	\f2string\fP
X.LP
X\f2num\fP	::=	{\f2digit\fP{\f3.\fP}}+
X.LP
X\f2digit\fP	::=	\f30\fP | \f31\fP | .\|.\|. | \f39\fP
X.LP
X\f2id\fP	::=	\f2letter\fP{\f2idchar\fP}*
X.LP
X\f2letter\fP	::=	any letter
X.LP
X\f2idchar\fP	::=	any visible graphic character except \f2special\fP
X.LP
X\f2special\fP	::=	\f3$\fP | \f3,\fP | \f3.\fP | \f3:\fP | \f3;\fP | \f3@\fP
X.LP
X\f2string\fP	::=	\f3@\fP{any character, with \f3@\fP doubled}*\f3@\fP
X.LP
X\f2newphrase\fP	::=	\f2id\fP \f2word\fP* \f3;\fP
X.LP
X\f2word\fP	::=	\f2id\fP | \f2num\fP | \f2string\fP | \f3:\fP
X.fi
X.PP
Identifiers are case sensitive.  Keywords are in lower case only.
The sets of keywords and identifiers may overlap.
In most environments RCS uses the ISO 8859/1 encoding:
letters are octal codes 101\-132, 141\-172, 300\-326, 330\-366 and 370-377,
visible graphic characters are codes 041\-176 and 240\-377,
and white space characters are codes 010\-015 and 040.
X.PP
The
X.I newphrase
productions in the grammar are reserved for future extensions
to the format of \*r files.
No
X.I newphrase
will begin with any keyword already in use.
X.PP
The
X.I delta
nodes form a tree.  All nodes whose numbers
consist of a single pair
X(e.g., 2.3, 2.1, 1.3, etc.)
are on the trunk, and are linked through the
X.B next
field in order of decreasing numbers.
The
X.B head
field in the
X.I admin
node points to the head of that sequence (i.e., contains
the highest pair).
The
X.B branch
node in the admin node indicates the default
branch (or revision) for most \*r operations.
If empty, the default
branch is the highest branch on the trunk.
X.PP
All
X.I delta
nodes whose numbers consist of
X.RI 2 n
fields
X.RI ( n \(\fP=2)
X(e.g., 3.1.1.1, 2.1.2.2, etc.)
are linked as follows.
All nodes whose first
X.RI 2 n \-1
number fields are identical are linked through the
X.B next
field in order of increasing numbers.
XFor each such sequence,
the
X.I delta
node whose number is identical to the first
X.RI 2 n \-2
number fields of the deltas on that sequence is called the branchpoint.
The
X.B branches
field of a node contains a list of the
numbers of the first nodes of all sequences for which it is a branchpoint.
This list is ordered in increasing numbers.
X.LP
X.nf
X.vs 12
X.ne 38
XExample:
X.if t .in +0.5i
X.cs 1 20
X.eo
X
X                           Head
X                             |
X                             |
X                             v                        / \
X                         ---------                   /   \
X   / \          / \      |       |      / \         /     \
X  /   \        /   \     |  2.1  |     /   \       /       \
X /     \      /     \    |       |    /     \     /         \
X/1.2.1.3\    /1.3.1.1\   |       |   /1.2.2.2\   /1.2.2.1.1.1\
X---------    ---------   ---------   ---------   -------------
X    ^            ^           |           ^             ^
X    |            |           |           |             |
X    |            |           v           |             |
X   / \           |       ---------      / \            |
X  /   \          |       \  1.3  /     /   \           |
X /     \         ---------\     /     /     \-----------
X/1.2.1.1\                  \   /     /1.2.2.1\
X---------                   \ /      ---------
X    ^                        |           ^
X    |                        |           |
X    |                        v           |
X    |                    ---------       |
X    |                    \  1.2  /       |
X    ----------------------\     /---------
X                           \   /
X                            \ /
X                             |
X                             |
X                             v
X                         ---------
X                         \  1.1  /
X                          \     /
X                           \   /
X                            \ /
X
X.ec
X.if t .in
X.cs 1
X.ce
XFig. 1: A revision tree
X.vs
X.fi
X.PP
X.SH IDENTIFICATION
X.de VL
X\\$2
X..
Author: Walter F. Tichy,
Purdue University, West Lafayette, IN, 47907.
X.br
Revision Number: \*(Rv; Release Date: \*(Dt.
X.br
Copyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
Copyright \(co 1990, 1991 by Paul Eggert.
X.SH SEE ALSO
ci(1), co(1), ident(1), rcs(1), rcsdiff(1), rcsmerge(1), rlog(1),
X.br
Walter F. Tichy,
X\*r\*-A System for Version Control,
X.I "Software\*-Practice & Experience"
X.BR 15 ,
X7 (July 1985), 637-654.
END_OF_FILE
if test 6267 -ne `wc -c <'man/rcsfile.5'`; then
    echo shar: \"'man/rcsfile.5'\" unpacked with wrong size!
fi
# end of 'man/rcsfile.5'
fi
if test -f 'man/rcsfreeze.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/rcsfreeze.1'\"
else
echo shar: Extracting \"'man/rcsfreeze.1'\" \(1723 characters\)
sed "s/^X//" >'man/rcsfreeze.1' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: rcsfreeze.1,v 4.4 1990/11/13 15:43:42 hammer Exp $
X.ds r \s-1RCS\s0
X.TH RCSFREEZE 1 \*(Dt GNU
X.SH NAME
rcsfreeze \- freeze a configuration of sources checked in under RCS
X.SH SYNOPSIS
X.B rcsfreeze
X.RI [ "name" ]
X.SH DESCRIPTION
X.B rcsfreeze
assigns a symbolic revision
number to a set of \*r files that form a valid configuration.
X.PP
The idea is to run
X.B rcsfreeze
each time a new version is checked
in.  A unique symbolic name (\c
X.BI C_ number,
where
X.I number
is increased each time
X.B rcsfreeze
is run) is then assigned to the most
recent revision of each \*r file of the main trunk.
X.PP
An optional
X.I name
argument to
X.B rcsfreeze
gives a symbolic name to the configuration.
The unique identifier is still generated
and is listed in the log file but it will not appear as
part of the symbolic revision name in the actual \*r files.
X.PP
A log message is requested from the user for future reference.
X.PP
The shell script works only on all \*r files at one time.
All changed files must be checked in already.
Run
X.IR rcsclean (1)
first and see whether any sources remain in the current directory.
X.SH FILES
X.TP
X.B RCS/.rcsfreeze.ver
version number
X.TP
X.B RCS/.rcsfreeze.log
log messages, most recent first
X.SH AUTHOR
Stephan v. Bechtolsheim
X.SH "SEE ALSO"
co(1), rcs(1), rcsclean(1), rlog(1)
X.SH BUGS
X.B rcsfreeze
does not check whether any sources are checked out and modified.
X.PP
Although both source file names and RCS file names are accepted,
they are not paired as usual with RCS commands.
X.PP
XError checking is rudimentary.
X.PP
X.B rcsfreeze
is just an optional example shell script, and should not be taken too seriously.
See \s-1CVS\s0 for a more complete solution.
END_OF_FILE
if test 1723 -ne `wc -c <'man/rcsfreeze.1'`; then
    echo shar: \"'man/rcsfreeze.1'\" unpacked with wrong size!
fi
# end of 'man/rcsfreeze.1'
fi
if test -f 'man/rcsmerge.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/rcsmerge.1'\"
else
echo shar: Extracting \"'man/rcsmerge.1'\" \(3305 characters\)
sed "s/^X//" >'man/rcsmerge.1' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: rcsmerge.1,v 5.3 1991/08/19 03:13:55 eggert Exp $
X.ds r \&\s-1RCS\s0
X.if n .ds - \%--
X.if t .ds - \(em
X.TH RCSMERGE 1 \*(Dt GNU
X.SH NAME
rcsmerge \- merge RCS revisions
X.SH SYNOPSIS
X.B rcsmerge
X.RI [ options ] " file"
X.SH DESCRIPTION
X.B rcsmerge
incorporates the changes between two revisions
of an \*r file into the corresponding working file.
X.PP
Pathnames matching an \*r suffix denote \*r files;
all others denote working files.
Names are paired as explained in
X.BR ci (1).
X.PP
At least one revision must be specified with one of the options
described below, usually
X.BR \-r .
At most two revisions may be specified.
If only one revision is specified, the latest
revision on the default branch (normally the highest branch on the trunk)
is assumed for the second revision.
Revisions may be specified numerically or symbolically.
X.PP
X.B rcsmerge
prints a warning if there are overlaps, and delimits
the overlapping regions as explained in
X.BR merge (1).
The command is useful for incorporating changes into a checked-out revision.
X.SH OPTIONS
X.TP
X.BI \-k subst
Use
X.I subst
style keyword substitution.
See
X.BR co (1)
for details.
XFor example,
X.B "\-kk\ \-r1.1\ \-r1.2"
ignores differences in keyword values when merging the changes from
X.B 1.1
to
X.BR 1.2 .
X.TP
X.BR \-p [\f2rev\fP]
Send the result to standard output instead of overwriting the working file.
X.TP
X.BR \-q [\f2rev\fP]
Run quietly; do not print diagnostics.
X.TP
X.BR \-r [\f2rev\fP]
Merge with respect to revision
X.IR rev .
Here an empty
X.I rev
stands for the latest revision on the default branch, normally the head.
X.TP
X.BI \-V n
XEmulate \*r version
X.IR n .
See
X.BR co (1)
for details.
X.TP
X.BI \-x "suffixes"
Use
X.I suffixes
to characterize \*r files.
See
X.BR ci (1)
for details.
X.SH EXAMPLES
Suppose you have released revision 2.8 of
X.BR f.c .
Assume
furthermore that after you complete an unreleased revision 3.4, you receive
updates to release 2.8 from someone else.
To combine the updates to 2.8 and your changes between 2.8 and 3.4,
put the updates to 2.8 into file f.c and execute
X.LP
X.B "    rcsmerge  \-p  \-r2.8  \-r3.4  f.c  >f.merged.c"
X.PP
Then examine
X.BR f.merged.c .
Alternatively, if you want to save the updates to 2.8 in the \*r file,
check them in as revision 2.8.1.1 and execute
X.BR "co \-j":
X.LP
X.B "    ci  \-r2.8.1.1  f.c"
X.br
X.B "    co  \-r3.4  \-j2.8:2.8.1.1  f.c"
X.PP
As another example, the following command undoes the changes
between revision 2.4 and 2.8 in your currently checked out revision
in
X.BR f.c .
X.LP
X.B "    rcsmerge  \-r2.8  \-r2.4  f.c"
X.PP
Note the order of the arguments, and that
X.B f.c
will be
overwritten.
X.SH ENVIRONMENT
X.TP
X.B \s-1RCSINIT\s0
options prepended to the argument list, separated by spaces.
See
X.BR ci (1)
for details.
X.SH DIAGNOSTICS
XExit status is 0 for no overlaps, 1 for some overlaps, 2 for trouble.
X.SH IDENTIFICATION
Author: Walter F. Tichy.
X.br
Revision Number: \*(Rv; Release Date: \*(Dt.
X.br
Copyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
Copyright \(co 1990, 1991 by Paul Eggert.
X.SH "SEE ALSO"
ci(1), co(1), ident(1), merge(1), rcs(1), rcsdiff(1), rcsintro(1), rlog(1),
rcsfile(5)
X.br
Walter F. Tichy,
X\*r\*-A System for Version Control,
X.I "Software\*-Practice & Experience"
X.BR 15 ,
X7 (July 1985), 637-654.
X.br
END_OF_FILE
if test 3305 -ne `wc -c <'man/rcsmerge.1'`; then
    echo shar: \"'man/rcsmerge.1'\" unpacked with wrong size!
fi
# end of 'man/rcsmerge.1'
fi
if test -f 'man/rlog.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/rlog.1'\"
else
echo shar: Extracting \"'man/rlog.1'\" \(5697 characters\)
sed "s/^X//" >'man/rlog.1' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: rlog.1,v 5.3 1991/08/22 06:50:48 eggert Exp $
X.ds g \&\s-1UTC\s0
X.ds r \&\s-1RCS\s0
X.if n .ds - \%--
X.if t .ds - \(em
X.TH RLOG 1 \*(Dt GNU
X.SH NAME
rlog \- print log messages and other information about RCS files
X.SH SYNOPSIS
X.B rlog
X.RI [ " options " ] " file " .\|.\|.
X.SH DESCRIPTION
X.B rlog
prints information about \*r files.
X.PP
Pathnames matching an \*r suffix denote \*r files;
all others denote working files.
Names are paired as explained in
X.BR ci (1).
X.PP
X.B rlog
prints the following information for each
X\*r file: \*r pathname, working pathname, head (i.e., the number
of the latest revision on the trunk), default branch, access list, locks,
symbolic names, suffix, total number of revisions,
number of revisions selected for printing, and
descriptive text.  This is followed by entries for the selected revisions in
reverse chronological order for each branch.  For each revision,
X.B rlog
prints revision number, author, date/time, state, number of
lines added/deleted (with respect to the previous revision),
locker of the revision (if any), and log message.
All times are displayed in Coordinated Universal Time (\*g).
Without options,
X.B rlog
prints complete information.
The options below restrict this output.
X.nr n \w'\f3\-V\fP\f2n\fP '+1n-1/1n
X.TP \nn
X.B \-L
Ignore \*r files that have no locks set.
This is convenient in combination with
X.BR \-h ,
X.BR \-l ,
and
X.BR \-R .
X.TP
X.B \-R
Print only the name of the \*r file.
This is convenient for translating a
working pathname into an \*r pathname.
X.TP
X.B \-h
Print only the \*r pathname, working pathname, head,
default branch, access list, locks,
symbolic names, and suffix.
X.TP
X.B \-t
Print the same as
X.BR \-h ,
plus the descriptive text.
X.TP
X.B \-b
Print information about the revisions on the default branch, normally
the highest branch on the trunk.
X.TP
X.BI \-d "dates"
Print information about revisions with a checkin date/time in the ranges given by
the semicolon-separated list of
X.IR dates .
A range of the form
X.IB d1 < d2
or
X.IB d2 > d1
selects the revisions that were deposited between
X.I d1
and
X.I d2
inclusive.
A range of the form
X.BI < d
or
X.IB d >
selects
all revisions dated
X.I d
or earlier.
A range of the form
X.IB d <
or
X.BI > d
selects
all revisions dated
X.I d
or later.
A range of the form
X.I d
selects the single, latest revision dated
X.I d
or earlier.
The date/time strings
X.IR d ,
X.IR d1 ,
and
X.I d2
are in the free format explained in
X.BR co (1).
Quoting is normally necessary, especially for
X.B <
and
X.BR > .
Note that the separator is
a semicolon.
X.TP
X.BR \-l [\f2lockers\fP]
Print information about locked revisions only.
In addition, if the comma-separated list
X.I lockers
of login names is given,
ignore all locks other than those held by the
X.IR lockers .
XFor example,
X.B "rlog\ \-L\ \-R\ \-lwft\ RCS/*"
prints the name of \*r files locked by the user
X.BR wft .
X.TP
X.BR \-r [\f2revisions\fP]
prints information about revisions given in the comma-separated list
X.I revisions
of revisions and ranges.
A range
X.IB rev1 : rev2
means revisions
X.I rev1
to
X.I rev2
on the same branch,
X.BI : rev
means revisions from the beginning of the branch up to and including
X.IR rev ,
and
X.IB rev :
means revisions starting with
X.I rev
to the end of the branch containing
X.IR rev .
An argument that is a branch means all
revisions on that branch.
A range of branches means all revisions
on the branches in that range.
A branch followed by a
X.B .\&
means the latest revision in that branch.
A bare
X.B \-r
with no
X.I revisions
means the latest revision on the default branch, normally the trunk.
X.TP
X.BI \-s states
prints information about revisions whose state attributes match one of the
states given in the comma-separated list
X.IR states .
X.TP
X.BR \-w [\f2logins\fP]
prints information about revisions checked in by users with
login names appearing in the comma-separated list
X.IR logins .
If
X.I logins
is omitted, the user's login is assumed.
X.TP
X.BI \-V n
XEmulate \*r version
X.I n
when generating logs.
See
X.BR co (1)
for more.
X.TP
X.BI \-x "suffixes"
Use
X.I suffixes
to characterize \*r files.
See
X.BR ci (1)
for details.
X.PP
X.B rlog
prints the intersection of the revisions selected with
the options
X.BR \-d ,
X.BR \-l ,
X.BR \-s ,
and
X.BR \-w ,
intersected
with the union of the revisions selected by
X.B \-b
and
X.BR \-r .
X.SH EXAMPLES
X.LP
X.nf
X.B "    rlog  \-L  \-R  RCS/*"
X.B "    rlog  \-L  \-h  RCS/*"
X.B "    rlog  \-L  \-l  RCS/*"
X.B "    rlog  RCS/*"
X.fi
X.LP
The first command prints the names of all \*r files in the subdirectory
X.B RCS
that have locks.  The second command prints the headers of those files,
and the third prints the headers plus the log messages of the locked revisions.
The last command prints complete information.
X.SH ENVIRONMENT
X.TP
X.B \s-1RCSINIT\s0
options prepended to the argument list, separated by spaces.
See
X.BR ci (1)
for details.
X.SH DIAGNOSTICS
The exit status is zero if and only if all operations were successful.
X.SH IDENTIFICATION
Author: Walter F. Tichy.
X.br
Revision Number: \*(Rv; Release Date: \*(Dt.
X.br
Copyright \(co 1982, 1988, 1989 by Walter F. Tichy.
X.br
Copyright \(co 1990, 1991 by Paul Eggert.
X.SH "SEE ALSO"
ci(1), co(1), ident(1), rcs(1), rcsdiff(1), rcsintro(1), rcsmerge(1),
rcsfile(5)
X.br
Walter F. Tichy,
X\*r\*-A System for Version Control,
X.I "Software\*-Practice & Experience"
X.BR 15 ,
X7 (July 1985), 637-654.
X.SH BUGS
The separator for revision ranges in the
X.B \-r
option used to be
X.B \-
instead of
X.BR : ,
but this leads to confusion when symbolic names contain
X.BR \- .
XFor backwards compatibility
X.B "rlog \-r"
still supports the old
X.B \-
separator, but it warns about this obsolete use.
X.br
END_OF_FILE
if test 5697 -ne `wc -c <'man/rlog.1'`; then
    echo shar: \"'man/rlog.1'\" unpacked with wrong size!
fi
# end of 'man/rlog.1'
fi
if test -f 'rcs_func.ms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rcs_func.ms'\"
else
echo shar: Extracting \"'rcs_func.ms'\" \(3683 characters\)
sed "s/^X//" >'rcs_func.ms' <<'END_OF_FILE'
X.SH
XFunctions of RCS (Revision Control System)
X.PP
RCS manages software libraries. It greatly increases programmer productivity
by providing the following functions.
X.IP 1.
RCS stores and retrieves multiple revisions of program and other text.
Thus, one can maintain one or more releases while developing the next
release, with a minimum of space overhead. Changes no longer destroy the
original -- previous revisions remain accessible.
X.RS
X.IP a.
Maintains each module as a tree of revisions.
X.IP b.
Project libraries can
be organized centrally, decentralized, or any way you like.
X.IP c.
RCS works for any type of text: programs, documentation, memos, papers,
graphics, VLSI layouts, form letters, etc.
X.RE
X.IP 2.
RCS maintains a complete history of changes.
Thus, one can find out what happened to a module easily
and quickly, without having to compare source listings or
having to track down colleagues.
X.RS
X.IP a.
RCS performs automatic record keeping.
X.IP b.
RCS logs all changes automatically.
X.IP c.
RCS guarantees project continuity.
X.RE
X.IP 3.
RCS manages multiple lines of development.
X.IP 4.
RCS can merge multiple lines of development.
Thus, when several parallel lines of development must be consolidated
into one line, the merging of changes is automatic.
X.IP 5.
RCS flags coding conflicts.
If two or more lines of development modify the same section of code,
RCS can alert programmers about overlapping changes.
X.IP 6.
RCS resolves access conflicts.
When two or more programmers wish to modify the same revision,
RCS alerts the programmers and makes sure that one modification won't wipe
out the other one.
X.IP 7.
RCS provides high-level retrieval functions.
Revisions can be retrieved according to ranges of revision numbers,
symbolic names, dates, authors, and states.
X.IP 8.
RCS provides release and configuration control.
Revisions can be marked as released, stable, experimental, etc.
Configurations of modules can be described simply and directly.
X.IP 9.
RCS performs automatic identification of modules with name, revision
number, creation time, author, etc.
Thus, it is always possible to determine which revisions of which
modules make up a given configuration.
X.IP 10.
Provides high-level management visibility.
Thus, it is easy to track the status of a software project.
X.RS
X.IP a.
RCS provides a complete change history.
X.IP b.
RCS records who did what when to which revision of which module.
X.RE
X.IP 11.
RCS is fully compatible with existing software development tools.
RCS is unobtrusive -- its interface to the file system is such that
all your existing software tools can be used as before.
X.IP 12.
RCS' basic user interface is extremely simple. The novice need to learn
only two commands. Its more sophisticated features have been
tuned towards advanced software development environments and the
experienced software professional.
X.IP 13.
RCS simplifies software distribution if customers
maintain sources with RCS also. This technique assures proper
identification of versions and configurations, and tracking of customer
modifications. Customer modifications can be merged into distributed
versions locally or by the development group.
X.IP 14.
RCS needs little extra space for the revisions (only the differences).
If intermediate revisions are deleted, the corresponding
differences are compressed into the shortest possible form.
X.IP 15.
RCS is implemented with reverse deltas. This means that
the latest revision, which is the one that is accessed most often,
is stored intact. All others are regenerated from the latest one
by applying reverse deltas (backward differences). This
results in fast access time for the revision needed most often.
END_OF_FILE
if test 3683 -ne `wc -c <'rcs_func.ms'`; then
    echo shar: \"'rcs_func.ms'\" unpacked with wrong size!
fi
# end of 'rcs_func.ms'
fi
if test ! -d 'src' ; then
    echo shar: Creating directory \"'src'\"
    mkdir 'src'
fi
if test -f 'src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile'\"
else
echo shar: Extracting \"'src/Makefile'\" \(6792 characters\)
sed "s/^X//" >'src/Makefile' <<'END_OF_FILE'
X# $Id: Makefile,v 5.16 1991/10/07 17:32:46 eggert Exp $
X# Copyright (C) 1982, 1988, 1989 Walter Tichy
X# Copyright 1990, 1991 by Paul Eggert
X#   Distributed under license by the Free Software Foundation, Inc.
X#
X# This file is part of RCS.
X#
X# RCS is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X#
X# RCS is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X#
X# You should have received a copy of the GNU General Public License
X# along with RCS; see the file COPYING.  If not, write to
X# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# Report problems and direct all questions to:
X#
X#    rcs-bugs@cs.purdue.edu
X#
X
X# default target
default :: all
X
X# See README for more information on the configuration section.
X# ----- start of configuration section -----
X
X#(Unix
X
X CC = cc
X#CC = bsdcc -qlanglvl=ansi# AIX
X#CC = cc -g# debug
X#CC = gcc -g# GCC
X
X CC_D =
X
X CC_O = -O
X#CC_O =# debug
X#CC_O = -O -R# BSD compilers that do not support `const'
X#CC_O = -O -fdelayed-branch -finline-functions -fomit-frame-pointer -fstrength-reduce# GCC options for brave souls
X
X CC_W =
X#CC_W = -Wall -Wcast-qual -Wpointer-arith -Wshadow -Wwrite-strings# GCC
X
X CFLAGS = $(CC_D) $(CC_O) $(CC_W)
X
X COMPAT2 = 0
X#COMPAT2 = 1
X
X DIFF = $(DIFFPREFIX)diff
X#DIFF = $(DIFFPREFIX)rdiff# short for ``RCS diff'' on some hosts
X
X DIFFPREFIX = /usr/local/gnu/# GNU diff -- must be version 1.15 or later
X#DIFFPREFIX = /bin/# traditional diff
X#DIFFPREFIX = /usr/bin/# traditional diff (alternate name)
X
X DIFF_FLAGS = -an# GNU diff
X#DIFF_FLAGS = -n# traditional diff
X
X DIFF_L = 1# GNU diff
X#DIFF_L = 0# traditional diff
X
X DIFF_SUCCESS = 0
X#DIFF_SUCCESS = EXIT_SUCCESS
X DIFF_FAILURE = 1
X#DIFF_FAILURE = EXIT_FAILURE
X DIFF_TROUBLE = 2
X#DIFF_TROUBLE = (EXIT_FAILURE*2)
X
X DIFF3 = $(DIFF)3# GNU diff3
X#DIFF3 = /usr/lib/diff3# traditional diff3
X#DIFF3 = /usr/5lib/diff3prog# other aliases for traditional diff3
X#DIFF3 = /usr/lib/diff3prog
X#DIFF3 = /usr/lib/rdiff3
X
X DIFF3_BIN = 1# GNU diff
X#DIFF3_BIN = 0# traditional diff
X
X ED = /bin/ed
X
X EXECUTABLE_GROUP = staff# BSD unix installation
X EXECUTABLE_PERMISSIONS = -g $(EXECUTABLE_GROUP) -m 775# BSD unix installation
X INSTALL = install -c $(EXECUTABLE_PERMISSIONS)# BSD unix installation
X#INSTALL = cp# traditional Unix installation
X
X LDFLAGS =
X
X LDLIBS =
X
X LINK = $(CC) $(LDFLAGS)
X
X LINT = lint -abchx# traditional and BSD lint
X#LINT = lint# System V lint
X
X MAKE = make
X
X OTHER_OBJECT =
X
X RCSDIR = /usr/local/bin
X#RCSDIR = /bin
X#RCSDIR = /usr/bin
X
X RCSPREFIX = $(RCSDIR)/
X#RCSPREFIX =
X
X REMOVE = rm -f
X
X SENDMAIL = "/bin/mail"
X#SENDMAIL = "/etc/delivermail", "-w"
X#SENDMAIL = "/usr/bin/mail"
X#SENDMAIL = "/usr/lib/sendmail"
X#SENDMAIL = "mail"
X#SENDMAIL =# for impoverished hosts that lack electronic mail
X
X TESTPREFIX =
X
X o = .o
X#o = .s# Minix/PC with ACK cc
X
X x =
X
X#)
X# On non-Unix hosts you must manually create and edit conf.h from conf.heg.
X
X# ----- end of configuration section -----
X# You shouldn't have to change anything past this point.
X
X
X# Avoid brain damage in some versions of 'make'.
SHELL = /bin/sh
X
X# all commands
RCSCOMMANDS = ci$x co$x ident$x merge$x rcs$x rcsdiff$x rcsmerge$x rlog$x
X
all :: $(RCSCOMMANDS)
X
install :: all
X	$(INSTALL) ci$x $(DESTDIR)$(RCSDIR)
X	$(INSTALL) co$x $(DESTDIR)$(RCSDIR)
X	$(INSTALL) ident$x $(DESTDIR)$(RCSDIR)
X	$(INSTALL) merge$x $(DESTDIR)$(RCSDIR)
X	$(INSTALL) rcs$x $(DESTDIR)$(RCSDIR)
X	$(INSTALL) rcsdiff$x $(DESTDIR)$(RCSDIR)
X	$(INSTALL) rcsmerge$x $(DESTDIR)$(RCSDIR)
X	$(INSTALL) rlog$x $(DESTDIR)$(RCSDIR)
X
X# Install RCS and (if applicable) GNU diff before running these tests.
X# To test RCS before installing it, see README.
RCSTEST = PATH=$(RCSDIR):$(DIFFPREFIX).:$$PATH sh $(TESTPREFIX)rcstest
installtest ::
X	$(RCSTEST)
installdebug ::
X	$(RCSTEST) -v
X
clean ::
X	$(REMOVE) a.* *$o conf.h conf.error $(RCSCOMMANDS) rcsclean$x
X
X#(Unix
conf.h : conf.sh Makefile
X	$(REMOVE) a.*
X	CC='$(CC)' CFLAGS='$(CFLAGS)' \
X	COMPAT2='$(COMPAT2)' \
X	DIFF3='$(DIFF3)' DIFF3_BIN='$(DIFF3_BIN)' \
X	DIFF='$(DIFF)' DIFF_FLAGS='$(DIFF_FLAGS)' DIFF_L='$(DIFF_L)' \
X	DIFF_SUCCESS='$(DIFF_SUCCESS)' DIFF_FAILURE='$(DIFF_FAILURE)' DIFF_TROUBLE='$(DIFF_TROUBLE)' \
X	ED='$(ED)' \
X	LDFLAGS='$(LDFLAGS)' LDLIBS='$(LDLIBS)' \
X	RCSPREFIX='$(RCSPREFIX)' \
X	SENDMAIL='$(SENDMAIL)' \
X	sh -x conf.sh >a.h 2>conf.error
X	mv a.h $@
X	$(REMOVE) a.*
X#)
X
ci = ci$o rcslex$o rcssyn$o rcsgen$o rcsedit$o rcskeys$o rcsmap$o \
X	rcsrev$o rcsutil$o rcsfnms$o partime$o maketime$o rcskeep$o \
X	rcsfcmp$o $(OTHER_OBJECT)
ci$x : $(ci)
X	$(LINK) $(ci) $(LDLIBS) -o $@
X
co = co$o rcslex$o rcssyn$o rcsgen$o rcsedit$o rcskeys$o rcsmap$o \
X	rcsrev$o rcsutil$o rcsfnms$o partime$o maketime$o rcskeep$o $(OTHER_OBJECT)
co$x : $(co)
X	$(LINK) $(co) $(LDLIBS) -o $@
X
ident = ident$o rcsmap$o $(OTHER_OBJECT)
ident$x : $(ident)
X	$(LINK) $(ident) $(LDLIBS) -o $@
X
merge = merge$o merger$o rcsfnms$o rcslex$o \
X	rcsmap$o rcsrev$o rcssyn$o rcsutil$o \
X	rcskeep$o rcskeys$o $(OTHER_OBJECT)
merge$x : $(merge)
X	$(LINK) $(merge) $(LDLIBS) -o $@
X
rlog = rlog$o rcslex$o rcsmap$o rcssyn$o rcsrev$o rcsutil$o partime$o \
X	maketime$o rcsfnms$o rcskeep$o rcskeys$o $(OTHER_OBJECT)
rlog$x : $(rlog)
X	$(LINK) $(rlog) $(LDLIBS) -o $@
X
rcs = rcs$o rcslex$o rcssyn$o rcsrev$o rcsutil$o rcsgen$o rcsedit$o rcskeys$o \
X	rcsmap$o rcsfnms$o rcskeep$o $(OTHER_OBJECT)
rcs$x : $(rcs)
X	$(LINK) $(rcs) $(LDLIBS) -o $@
X
rcsclean = rcsclean$o rcsedit$o rcsfcmp$o rcsfnms$o rcsgen$o rcskeys$o \
X	rcslex$o rcsmap$o rcsrev$o rcssyn$o rcsutil$o rcskeep$o $(OTHER_OBJECT)
rcsclean$x : $(rcsclean)
X	$(LINK) $(rcsclean) $(LDLIBS) -o $@
X
rcsdiff = rcsdiff$o rcsutil$o rcsfnms$o rcsmap$o rcsrev$o rcssyn$o rcslex$o \
X	maketime$o partime$o rcskeep$o rcskeys$o $(OTHER_OBJECT)
rcsdiff$x : $(rcsdiff)
X	$(LINK) $(rcsdiff) $(LDLIBS) -o $@
X
rcsmerge = rcsmerge$o merger$o rcsutil$o rcsfnms$o rcsmap$o rcsrev$o rcssyn$o \
X	rcslex$o rcskeep$o rcskeys$o $(OTHER_OBJECT)
rcsmerge$x : $(rcsmerge)
X	$(LINK) $(rcsmerge) $(LDLIBS) -o $@
X
SOURCE=	ci.c co.c ident.c maketime.c merge.c merger.c partime.c rcs.c \
X	rcsclean.c rcsdiff.c rcsedit.c rcsfcmp.c rcsfnms.c rcsgen.c \
X	rcskeep.c rcskeys.c rcslex.c rcsmap.c rcsmerge.c rcsrev.c rcssyn.c \
X	rcsutil.c rlog.c
OBJECT=	ci$o co$o ident$o maketime$o merge$o merger$o partime$o rcs$o \
X	rcsclean$o rcsdiff$o rcsedit$o rcsfcmp$o rcsfnms$o rcsgen$o \
X	rcskeep$o rcskeys$o rcslex$o rcsmap$o rcsmerge$o rcsrev$o rcssyn$o \
X	rcsutil$o rlog$o
X
lint :: conf.h
X	$(LINT) $(CC_D) -Dlint=1 $(SOURCE)
X
conf_h = conf.h
X$(OBJECT) : $(conf_h) rcsbase.h
END_OF_FILE
if test 6792 -ne `wc -c <'src/Makefile'`; then
    echo shar: \"'src/Makefile'\" unpacked with wrong size!
fi
# end of 'src/Makefile'
fi
if test -f 'src/ident.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ident.c'\"
else
echo shar: Extracting \"'src/ident.c'\" \(5571 characters\)
sed "s/^X//" >'src/ident.c' <<'END_OF_FILE'
X/* Copyright (C) 1982, 1988, 1989 Walter Tichy
X   Copyright 1990, 1991 by Paul Eggert
X   Distributed under license by the Free Software Foundation, Inc.
X
This file is part of RCS.
X
RCS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
X
RCS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
X
You should have received a copy of the GNU General Public License
along with RCS; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
Report problems and direct all questions to:
X
X    rcs-bugs@cs.purdue.edu
X
X*/
X
X/*
X *                     RCS identification operation
X */
X
X/* $Log: ident.c,v $
X * Revision 5.3  1991/09/10  22:15:46  eggert
X * Open files with FOPEN_R, not FOPEN_R_WORK,
X * because they might be executables, not working files.
X *
X * Revision 5.2  1991/08/19  03:13:55  eggert
X * Report read errors immediately.
X *
X * Revision 5.1  1991/02/25  07:12:37  eggert
X * Don't report empty keywords.  Check for I/O errors.
X *
X * Revision 5.0  1990/08/22  08:12:37  eggert
X * Don't limit output to known keywords.
X * Remove arbitrary limits and lint.  Ansify and Posixate.
X *
X * Revision 4.5  89/05/01  15:11:54  narten
X * changed copyright header to reflect current distribution rules
X * 
X * Revision 4.4  87/10/23  17:09:57  narten
X * added exit(0) so exit return code would be non random
X * 
X * Revision 4.3  87/10/18  10:23:55  narten
X * Updating version numbers. Changes relative to 1.1 are actually relative
X * to 4.1
X * 
X * Revision 1.3  87/07/09  09:20:52  trinkle
X * Added check to make sure there is at least one arg before comparing argv[1]
X * with "-q".  This necessary on machines that don't allow dereferncing null
X * pointers (i.e. Suns).
X * 
X * Revision 1.2  87/03/27  14:21:47  jenkins
X * Port to suns
X * 
X * Revision 4.1  83/05/10  16:31:02  wft
X * Added option -q and input from reading stdin.
X * Marker matching is now done with trymatch() (independent of keywords).
X * 
X * Revision 3.4  83/02/18  17:37:49  wft
X * removed printing of new line after last file.
X *
X * Revision 3.3  82/12/04  12:48:55  wft
X * Added LOCKER.
X *
X * Revision 3.2  82/11/28  18:24:17  wft
X * removed Suffix; added ungetc to avoid skipping over trailing KDELIM.
X *
X * Revision 3.1  82/10/13  15:58:51  wft
X * fixed type of variables receiving from getc() (char-->int).
X*/
X
X#include  "rcsbase.h"
X
static int match P((FILE*));
static void scanfile P((FILE*,char const*,int));
X
mainProg(identId, "ident", "$Id: ident.c,v 5.3 1991/09/10 22:15:46 eggert Exp $")
X/*  Ident searches the named files for all occurrences
X *  of the pattern $keyword:...$, where the keywords are
X *  Author, Date, Header, Id, Log, RCSfile, Revision, Source, and State.
X */
X
X{
X   FILE *fp;
X   int quiet;
X   int status = EXIT_SUCCESS;
X
X   if ((quiet  =  argc > 1 && strcmp("-q",argv[1])==0)) {
X        argc--; argv++;
X   }
X
X   if (argc<2)
X	scanfile(stdin, (char*)0, quiet);
X
X   while ( --argc > 0 ) {
X      if (!(fp = fopen(*++argv, FOPEN_R))) {
X	 VOID fprintf(stderr,  "%s error: can't open %s\n", cmdid, *argv);
X	 status = EXIT_FAILURE;
X      } else {
X	 scanfile(fp, *argv, quiet);
X	 if (argc>1) VOID putchar('\n');
X      }
X   }
X   if (ferror(stdout) || fclose(stdout)!=0) {
X      VOID fprintf(stderr,  "%s error: write error\n", cmdid);
X      status = EXIT_FAILURE;
X   }
X   exitmain(status);
X}
X
X#if lint
X	exiting void identExit() { _exit(EXIT_FAILURE); }
X#endif
X
X
X	static void
scanfile(file, name, quiet)
X	register FILE *file;
X	char const *name;
X	int quiet;
X/* Function: scan an open file with descriptor file for keywords.
X * Return false if there's a read error.
X */
X{
X   register int c;
X
X   if (name)
X      VOID printf("%s:\n", name);
X   else
X      name = "input";
X   c = 0;
X   for (;;) {
X      if (c < 0) {
X	 if (feof(file))
X	    break;
X	 if (ferror(file))
X	    goto read_error;
X      }
X      if (c == KDELIM) {
X	 if ((c = match(file)))
X	    continue;
X	 quiet = true;
X      }
X      c = getc(file);
X   }
X   if (!quiet)
X      VOID fprintf(stderr, "%s warning: no id keywords in %s\n", cmdid, name);
X   if (fclose(file) == 0)
X      return;
X
X read_error:
X   VOID fprintf(stderr, "%s error: %s: read error\n", cmdid, name);
X   exit(EXIT_FAILURE);
X}
X
X
X
X	static int
match(fp)   /* group substring between two KDELIM's; then do pattern match */
X   register FILE *fp;
X{
X   char line[BUFSIZ];
X   register int c;
X   register char * tp;
X
X   tp = line;
X   while ((c = getc(fp)) != VDELIM) {
X      if (c < 0)
X	 return c;
X      switch (ctab[c]) {
X	 case LETTER: case Letter:
X	    *tp++ = c;
X	    if (tp < line+sizeof(line)-4)
X	       break;
X	    /* fall into */
X	 default:
X	    return c ? c : '\n'/* anything but 0 or KDELIM or EOF */;
X      }
X   }
X   if (tp == line)
X      return c;
X   *tp++ = c;
X   if ((c = getc(fp)) != ' ')
X      return c ? c : '\n';
X   *tp++ = c;
X   while( (c = getc(fp)) != KDELIM ) {
X      if (c < 0  &&  feof(fp) | ferror(fp))
X	    return c;
X      switch (ctab[c]) {
X	 default:
X	    *tp++ = c;
X	    if (tp < line+sizeof(line)-2)
X	       break;
X	    /* fall into */
X	 case NEWLN: case UNKN:
X	    return c ? c : '\n';
X      }
X   }
X   if (tp[-1] != ' ')
X      return c;
X   *tp++ = c;     /*append trailing KDELIM*/
X   *tp   = '\0';
X   VOID fprintf(stdout, "     %c%s\n", KDELIM, line);
X   return 0;
X}
END_OF_FILE
if test 5571 -ne `wc -c <'src/ident.c'`; then
    echo shar: \"'src/ident.c'\" unpacked with wrong size!
fi
# end of 'src/ident.c'
fi
if test -f 'src/merge.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/merge.c'\"
else
echo shar: Extracting \"'src/merge.c'\" \(2143 characters\)
sed "s/^X//" >'src/merge.c' <<'END_OF_FILE'
X/* merge - three-way file merge */
X
X/* Copyright 1991 by Paul Eggert
X   Distributed under license by the Free Software Foundation, Inc.
X
This file is part of RCS.
X
RCS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
X
RCS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
X
You should have received a copy of the GNU General Public License
along with RCS; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
Report problems and direct all questions to:
X
X    rcs-bugs@cs.purdue.edu
X
X*/
X
X#include "rcsbase.h"
X
X
static char const usage[] =
X "\nmerge: usage: merge [-p] [-q] [-L label1 [-L label3]] file1 file2 file3\n";
X
X	static exiting void
badoption(a)
X	char const *a;
X{
X	faterror("unknown option: %s%s", a-2, usage);
X}
X
X
mainProg(mergeId, "merge", "$Id: merge.c,v 1.2 1991/08/19 03:13:55 eggert Exp $")
X{
X	register char const *a;
X	char const *label[2], *arg[3];
X	int labels, tostdout;
X
X	labels = 0;
X	tostdout = false;
X
X	while ((a = *++argv)  &&  *a++ == '-') {
X		switch (*a++) {
X			case 'p': tostdout = true; break;
X			case 'q': quietflag = true; break;
X			case 'L':
X				if (1<labels)
X					faterror("too many -L options");
X				if (!(label[labels++] = *++argv))
X					faterror("-L needs following argument");
X				--argc;
X				break;
X			default:
X				badoption(a);
X		}
X		if (*a)
X			badoption(a);
X		--argc;
X	}
X
X	if (argc != 4)
X		faterror("%s arguments%s",
X			argc<4 ? "not enough" : "too many",  usage
X		);
X
X	/* This copy keeps us `const'-clean.  */
X	arg[0] = argv[0];
X	arg[1] = argv[1];
X	arg[2] = argv[2];
X
X	switch (labels) {
X		case 0: label[0] = arg[0]; /* fall into */
X		case 1: label[1] = arg[2];
X	}
X
X	exitmain(merge(tostdout, label, arg));
X}
X
X
X#if lint
X#	define exiterr mergeExit
X#endif
X	exiting void
exiterr()
X{
X	tempunlink();
X	_exit(DIFF_TROUBLE);
X}
END_OF_FILE
if test 2143 -ne `wc -c <'src/merge.c'`; then
    echo shar: \"'src/merge.c'\" unpacked with wrong size!
fi
# end of 'src/merge.c'
fi
if test -f 'src/merger.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/merger.c'\"
else
echo shar: Extracting \"'src/merger.c'\" \(3036 characters\)
sed "s/^X//" >'src/merger.c' <<'END_OF_FILE'
X/* merger - three-way file merge internals */
X
X/* Copyright 1991 by Paul Eggert
X   Distributed under license by the Free Software Foundation, Inc.
X
This file is part of RCS.
X
RCS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
X
RCS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
X
You should have received a copy of the GNU General Public License
along with RCS; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
Report problems and direct all questions to:
X
X    rcs-bugs@cs.purdue.edu
X
X*/
X
X#include "rcsbase.h"
X
libId(mergerId, "$Id: merger.c,v 1.3 1991/08/20 23:05:00 eggert Exp $")
X
X	static char const *
normalize_arg(s, b)
X	char const *s;
X	char **b;
X/*
X * If S looks like an option, prepend ./ to it.  Yield the result.
X * Set *B to the address of any storage that was allocated..
X */
X{
X	char *t;
X	switch (*s) {
X		case '-': case '+':
X			*b = t = testalloc(strlen(s) + 3);
X			VOID sprintf(t, ".%c%s", SLASH, s);
X			return t;
X		default:
X			*b = 0;
X			return s;
X	}
X}
X
X	int
merge(tostdout, label, argv)
X	int tostdout;
X	char const *const label[2];
X	char const *const argv[3];
X/*
X * Do `merge [-p] -L l0 -L l1 a0 a1 a2',
X * where TOSTDOUT specifies whether -p is present,
X * LABEL gives l0 and l1, and ARGV gives a0, a1, and a2.
X * Yield DIFF_SUCCESS or DIFF_FAILURE.
X */
X{
X	register int i;
X	FILE *f;
X	RILE *rt;
X	char const *a[3], *t;
X	char *b[3];
X	int s;
X#if !DIFF3_BIN
X	char const *d[2];
X#endif
X
X	for (i=3; 0<=--i; )
X		a[i] = normalize_arg(argv[i], &b[i]);
X
X#if DIFF3_BIN
X	t = 0;
X	if (!tostdout)
X		t = maketemp(0);
X	s = run(
X		(char*)0, t,
X		DIFF3, "-am", "-L", label[0], "-L", label[1],
X		a[0], a[1], a[2], (char*)0
X	);
X	switch (s) {
X		case DIFF_SUCCESS:
X			break;
X		case DIFF_FAILURE:
X			if (!quietflag)
X				warn("overlaps during merge");
X			break;
X		default:
X			exiterr();
X	}
X	if (t) {
X		if (!(f = fopen(argv[0], FOPEN_W)))
X			efaterror(argv[0]);
X		if (!(rt = Iopen(t, FOPEN_R, (struct stat*)0)))
X			efaterror(t);
X		fastcopy(rt, f);
X		Ifclose(rt);
X		Ofclose(f);
X	}
X#else
X	for (i=0; i<2; i++)
X		switch (run(
X			(char*)0, d[i]=maketemp(i),
X			DIFF, a[i], a[2], (char*)0
X		)) {
X			case DIFF_FAILURE: case DIFF_SUCCESS: break;
X			default: exiterr();
X		}
X	t = maketemp(2);
X	s = run(
X		(char*)0, t,
X		DIFF3, "-E", d[0], d[1], a[0], a[1], a[2],
X		label[0], label[1], (char*)0
X	);
X	if (s != DIFF_SUCCESS) {
X		s = DIFF_FAILURE;
X		if (!quietflag)
X			warn("overlaps or other problems during merge");
X	}
X	if (!(f = fopen(t, "a")))
X		efaterror(t);
X	aputs(tostdout ? "1,$p\n" : "w\n",  f);
X	Ofclose(f);
X	if (run(t, (char*)0, ED, "-", a[0], (char*)0))
X		exiterr();
X#endif
X
X	tempunlink();
X	for (i=3; 0<=--i; )
X		if (b[i])
X			tfree(b[i]);
X	return s;
X}
END_OF_FILE
if test 3036 -ne `wc -c <'src/merger.c'`; then
    echo shar: \"'src/merger.c'\" unpacked with wrong size!
fi
# end of 'src/merger.c'
fi
if test -f 'src/rcsclean.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/rcsclean.c'\"
else
echo shar: Extracting \"'src/rcsclean.c'\" \(6396 characters\)
sed "s/^X//" >'src/rcsclean.c' <<'END_OF_FILE'
X/* rcsclean - clean up working files */
X
X/* Copyright 1991 by Paul Eggert
X   Distributed under license by the Free Software Foundation, Inc.
X
This file is part of RCS.
X
RCS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
X
RCS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
X
You should have received a copy of the GNU General Public License
along with RCS; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
Report problems and direct all questions to:
X
X	rcs-bugs@cs.purdue.edu
X
X*/
X
X#include "rcsbase.h"
X
X#if has_dirent
X	static int get_directory P((char const*,char***));
X#endif
X
static int unlock P((struct hshentry *));
static void cleanup P((void));
X
static RILE *workptr;
static int exitstatus;
X
mainProg(rcscleanId, "rcsclean", "$Id: rcsclean.c,v 5.1 1991/11/03 01:11:44 eggert Exp $")
X{
X	static char const usage[] =
X		"\nrcsclean: usage: rcsclean [-ksubst] [-{nqru}[rev]] [-Vn] [-xsuffixes] [file ...]";
X
X	static struct buf revision;
X
X	char *a, **newargv;
X	char const *rev, *p;
X	int changelock, expmode, perform, unlocked, unlockflag, waslocked;
X	struct hshentries *deltas;
X	struct hshentry *delta;
X	struct stat workstat;
X
X	setrid();
X
X	expmode = -1;
X	rev = nil;
X	suffixes = X_DEFAULT;
X	perform = true;
X	unlockflag = false;
X
X	argc = getRCSINIT(argc, argv, &newargv);
X	argv = newargv;
X	for (;;) {
X		if (--argc <= 0) {
X#			if has_dirent
X				argc = get_directory(".", &newargv);
X				argv = newargv;
X				break;
X#			else
X				faterror("no file names specified");
X#			endif
X		}
X		a = *++argv;
X		if (*a++ != '-')
X			break;
X		switch (*a++) {
X			case 'k':
X				if (0 <= expmode)
X					redefined('k');
X				if ((expmode = str2expmode(a))  <  0)
X					goto unknown;
X				break;
X
X			case 'n':
X				perform = false;
X				goto handle_revision;
X
X			case 'q':
X				quietflag = true;
X				/* fall into */
X			case 'r':
X			handle_revision:
X				if (*a) {
X					if (rev)
X						warn("redefinition of revision number");
X					rev = a;
X				}
X				break;
X
X			case 'u':
X				unlockflag = true;
X				goto handle_revision;
X
X			case 'V':
X				setRCSversion(*argv);
X				break;
X
X			case 'x':
X				suffixes = a;
X				break;
X
X			default:
X			unknown:
X				faterror("unknown option: %s%s", *argv, usage);
X		}
X	}
X
X	do {
X		ffree();
X
X		if (!(
X			0 < pairfilenames(
X				argc, argv,
X				unlockflag&perform ? rcswriteopen : rcsreadopen,
X				true, true
X			) &&
X			(workptr = Iopen(workfilename,FOPEN_R_WORK,&workstat))
X		))
X			continue;
X
X		gettree();
X
X		p = 0;
X		if (rev) {
X			if (!fexpandsym(rev, &revision, workptr))
X				continue;
X			p = revision.string;
X		} else if (Head)
X			switch (unlockflag ? findlock(false,&delta) : 0) {
X				default:
X					continue;
X				case 0:
X					p = Dbranch ? Dbranch : "";
X					break;
X				case 1:
X					p = delta->num;
X					break;
X			}
X		delta = 0;
X		deltas = 0;  /* Keep lint happy.  */
X		if (p  &&  !(delta = genrevs(p,(char*)0,(char*)0,(char*)0,&deltas)))
X			continue;
X
X		waslocked = delta && delta->lockedby;
X		locker_expansion = unlock(delta);
X		unlocked = locker_expansion & unlockflag;
X		changelock = unlocked & perform;
X		if (unlocked<waslocked  &&  workstat.st_mode&(S_IWUSR|S_IWGRP|S_IWOTH))
X			continue;
X
X		if (!dorewrite(unlockflag, changelock))
X			continue;
X
X		if (0 <= expmode)
X			Expand = expmode;
X		else if (
X			waslocked  &&
X			Expand == KEYVAL_EXPAND  &&
X			WORKMODE(RCSstat.st_mode,true) == workstat.st_mode
X		)
X			Expand = KEYVALLOCK_EXPAND;
X
X		getdesc(false);
X
X		if (
X		    !delta ? workstat.st_size!=0 :
X			0 < rcsfcmp(
X			    workptr, &workstat,
X			    buildrevision(deltas, delta, (FILE*)0, false),
X			    delta
X			)
X		)
X			continue;
X
X		if (quietflag < unlocked)
X			aprintf(stdout, "rcs -u%s %s\n", delta->num, RCSfilename);
X
X		if_advise_access(changelock  &&  deltas->first != delta,
X			finptr, MADV_SEQUENTIAL
X		);
X		if (!donerewrite(changelock))
X			continue;
X
X		if (!quietflag)
X			aprintf(stdout, "rm -f %s\n", workfilename);
X		Izclose(&workptr);
X		if (perform  &&  un_link(workfilename) != 0)
X			eerror(workfilename);
X
X	} while (cleanup(),  ++argv,  0 < --argc);
X
X	tempunlink();
X	if (!quietflag)
X		Ofclose(stdout);
X	exitmain(exitstatus);
X}
X
X	static void
cleanup()
X{
X	if (nerror) exitstatus = EXIT_FAILURE;
X	Izclose(&finptr);
X	Izclose(&workptr);
X	Ozclose(&fcopy);
X	Ozclose(&frewrite);
X	dirtempunlink();
X}
X
X#if lint
X#       define exiterr rcscleanExit
X#endif
X	exiting void
exiterr()
X{
X	dirtempunlink();
X	tempunlink();
X	_exit(EXIT_FAILURE);
X}
X
X	static int
unlock(delta)
X	struct hshentry *delta;
X{
X	register struct lock **al, *l;
X
X	if (delta && delta->lockedby && strcmp(getcaller(),delta->lockedby)==0)
X		for (al = &Locks;  (l = *al);  al = &l->nextlock)
X			if (l->delta == delta) {
X				*al = l->nextlock;
X				delta->lockedby = 0;
X				return true;
X			}
X	return false;
X}
X
X#if has_dirent
X	static int
get_directory(dirname, aargv)
X	char const *dirname;
X	char ***aargv;
X/*
X * Put a vector of all DIRNAME's directory entries names into *AARGV.
X * Ignore names of RCS files.
X * Yield the number of entries found.  Terminate the vector with 0.
X * Allocate the storage for the vector and entry names.
X * Do not sort the names.  Do not include '.' and '..'.
X */
X{
X	int i, entries = 0, entries_max = 64;
X	size_t chars = 0, chars_max = 1024;
X	size_t *offset = tnalloc(size_t, entries_max);
X	char *a = tnalloc(char, chars_max), **p;
X	DIR *d;
X	struct dirent *e;
X
X	if (!(d = opendir(dirname)))
X		efaterror(dirname);
X	while ((errno = 0,  e = readdir(d))) {
X		char const *en = e->d_name;
X		size_t s = strlen(en) + 1;
X		if (en[0]=='.'   &&   (!en[1]  ||  en[1]=='.' && !en[2]))
X			continue;
X		if (rcssuffix(en))
X			continue;
X		while (chars_max < s + chars)
X			a = trealloc(char, a, chars_max<<=1);
X		if (entries == entries_max)
X			offset = trealloc(size_t, offset, entries_max<<=1);
X		offset[entries++] = chars;
X		VOID strcpy(a+chars, en);
X		chars += s;
X	}
X	if (errno  ||  closedir(d) != 0)
X		efaterror(dirname);
X	if (chars)
X		a = trealloc(char, a, chars);
X	else
X		tfree(a);
X	*aargv = p = tnalloc(char*, entries+1);
X	for (i=0; i<entries; i++)
X		*p++ = a + offset[i];
X	*p = 0;
X	tfree(offset);
X	return entries;
X}
X#endif
END_OF_FILE
if test 6396 -ne `wc -c <'src/rcsclean.c'`; then
    echo shar: \"'src/rcsclean.c'\" unpacked with wrong size!
fi
# end of 'src/rcsclean.c'
fi
if test -f 'src/rcsfreeze.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/rcsfreeze.sh'\"
else
echo shar: Extracting \"'src/rcsfreeze.sh'\" \(3267 characters\)
sed "s/^X//" >'src/rcsfreeze.sh' <<'END_OF_FILE'
X#! /bin/sh
X
X# rcsfreeze - assign a symbolic revision number to a configuration of RCS files
X
X#	$Id: rcsfreeze.sh,v 4.4 1991/04/21 11:58:24 eggert Exp $
X
X#       The idea is to run rcsfreeze each time a new version is checked
X#       in. A unique symbolic revision number (C_[number], where number
X#       is increased each time rcsfreeze is run) is then assigned to the most
X#       recent revision of each RCS file of the main trunk.
X#
X#       If the command is invoked with an argument, then this
X#       argument is used as the symbolic name to freeze a configuration.
X#       The unique identifier is still generated
X#       and is listed in the log file but it will not appear as
X#       part of the symbolic revision name in the actual RCS file.
X#
X#       A log message is requested from the user which is saved for future
X#       references.
X#
X#       The shell script works only on all RCS files at one time.
X#       It is important that all changed files are checked in (there are
X#       no precautions against any error in this respect).
X#       file names:
X#       {RCS/}.rcsfreeze.ver	version number
X#       {RCS/}.rscfreeze.log	log messages, most recent first
X
PATH=/usr/local/bin:/bin:/usr/bin:/usr/ucb:$PATH
export PATH
X
DATE=`date` || exit
X# Check whether we have an RCS subdirectory, so we can have the right
X# prefix for our paths.
if [ -d RCS ]
then RCSDIR=RCS/
else RCSDIR=
fi
X
X# Version number stuff, log message file
VERSIONFILE=${RCSDIR}.rcsfreeze.ver
LOGFILE=${RCSDIR}.rcsfreeze.log
X# Initialize, rcsfreeze never run before in the current directory
X[ -r $VERSIONFILE ] || { echo 0 >$VERSIONFILE && >>$LOGFILE; } || exit
X
X# Get Version number, increase it, write back to file.
VERSIONNUMBER=`cat $VERSIONFILE` &&
VERSIONNUMBER=`expr $VERSIONNUMBER + 1` &&
echo $VERSIONNUMBER >$VERSIONFILE || exit
X
X# Symbolic Revision Number
SYMREV=C_$VERSIONNUMBER
X# Allow the user to give a meaningful symbolic name to the revision.
SYMREVNAME=${1-$SYMREV}
echo >&2 "rcsfreeze: symbolic revision number computed: \"${SYMREV}\"
rcsfreeze: symbolic revision number used:     \"${SYMREVNAME}\"
rcsfreeze: the two differ only when rcsfreeze invoked with argument
rcsfreeze: give log message, summarizing changes (end with EOF or single '.')" \
X	|| exit
X
X# Stamp the logfile. Because we order the logfile the most recent
X# first we will have to save everything right now in a temporary file.
TMPLOG=/tmp/rcsfrz$$
trap 'rm -f $TMPLOG; exit 1' 1 2 13 15
X# Now ask for a log message, continously add to the log file
X(
X	echo "Version: $SYMREVNAME($SYMREV), Date: $DATE
X-----------" || exit
X	while read MESS
X	do
X		case $MESS in
X		.) break
X		esac
X		echo "	$MESS" || exit
X	done
X	echo "-----------
X" &&
X	cat $LOGFILE
X) >$TMPLOG &&
X
X# combine old and new logfiles
cp $TMPLOG $LOGFILE &&
rm -f $TMPLOG || exit
trap 1 2 13 15
X
X# Now the real work begins by assigning a symbolic revision number
X# to each rcs file. Take the most recent version of the main trunk.
X
status=
X
for FILE in ${RCSDIR}*
do
X#   get the revision number of the most recent revision
X    HEAD=`rlog -h $FILE` &&
X	REV=`echo "$HEAD" | sed -n 's/^head:[ 	]*//p'` &&
X#   assign symbolic name to it.
X    echo >&2 "rcsfreeze: $REV $FILE" &&
X    rcs -q -n$SYMREVNAME:$REV $FILE || status=$?
done
X
exit $status
END_OF_FILE
if test 3267 -ne `wc -c <'src/rcsfreeze.sh'`; then
    echo shar: \"'src/rcsfreeze.sh'\" unpacked with wrong size!
fi
# end of 'src/rcsfreeze.sh'
fi
if test -f 'src/rcskeys.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/rcskeys.c'\"
else
echo shar: Extracting \"'src/rcskeys.c'\" \(2683 characters\)
sed "s/^X//" >'src/rcskeys.c' <<'END_OF_FILE'
X/*
X *                     RCS keyword table and match operation
X */
X
X/* Copyright (C) 1982, 1988, 1989 Walter Tichy
X   Copyright 1990, 1991 by Paul Eggert
X   Distributed under license by the Free Software Foundation, Inc.
X
This file is part of RCS.
X
RCS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
X
RCS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
X
You should have received a copy of the GNU General Public License
along with RCS; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
Report problems and direct all questions to:
X
X    rcs-bugs@cs.purdue.edu
X
X*/
X
X
X
X/* $Log: rcskeys.c,v $
X * Revision 5.2  1991/08/19  03:13:55  eggert
X * Say `T const' instead of `const T'; it's less confusing for pointer types.
X * (This change was made in other source files too.)
X *
X * Revision 5.1  1991/04/21  11:58:25  eggert
X * Don't put , just before } in initializer.
X *
X * Revision 5.0  1990/08/22  08:12:54  eggert
X * Add -k.  Ansify and Posixate.
X *
X * Revision 4.3  89/05/01  15:13:02  narten
X * changed copyright header to reflect current distribution rules
X * 
X * Revision 4.2  87/10/18  10:36:33  narten
X * Updating version numbers. Changes relative to 1.1 actuallyt
X * relative to 4.1
X * 
X * Revision 1.2  87/09/24  14:00:10  narten
X * Sources now pass through lint (if you ignore printf/sprintf/fprintf 
X * warnings)
X * 
X * Revision 4.1  83/05/04  10:06:53  wft
X * Initial revision.
X * 
X */
X
X
X#include "rcsbase.h"
X
libId(keysId, "$Id: rcskeys.c,v 5.2 1991/08/19 03:13:55 eggert Exp $")
X
X
char const *const Keyword[] = {
X    /* This must be in the same order as rcsbase.h's enum markers type. */
X	nil,
X	AUTHOR, DATE, HEADER, IDH,
X	LOCKER, LOG, RCSFILE, REVISION, SOURCE, STATE
X};
X
X
X
X	enum markers
trymatch(string)
X	char const *string;
X/* function: Checks whether string starts with a keyword followed
X * by a KDELIM or a VDELIM.
X * If successful, returns the appropriate marker, otherwise Nomatch.
X */
X{
X        register int j;
X	register char const *p, *s;
X	for (j = sizeof(Keyword)/sizeof(*Keyword);  (--j);  ) {
X		/* try next keyword */
X		p = Keyword[j];
X		s = string;
X		while (*p++ == *s++) {
X			if (!*p)
X			    switch (*s) {
X				case KDELIM:
X				case VDELIM:
X				    return (enum markers)j;
X				default:
X				    return Nomatch;
X			    }
X		}
X        }
X        return(Nomatch);
X}
X
END_OF_FILE
if test 2683 -ne `wc -c <'src/rcskeys.c'`; then
    echo shar: \"'src/rcskeys.c'\" unpacked with wrong size!
fi
# end of 'src/rcskeys.c'
fi
if test -f 'src/rcsmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/rcsmap.c'\"
else
echo shar: Extracting \"'src/rcsmap.c'\" \(3048 characters\)
sed "s/^X//" >'src/rcsmap.c' <<'END_OF_FILE'
X/* RCS map of character types */
X
X/* Copyright (C) 1982, 1988, 1989 Walter Tichy
X   Copyright 1990, 1991 by Paul Eggert
X   Distributed under license by the Free Software Foundation, Inc.
X
This file is part of RCS.
X
RCS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
X
RCS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
X
You should have received a copy of the GNU General Public License
along with RCS; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
Report problems and direct all questions to:
X
X    rcs-bugs@cs.purdue.edu
X
X*/
X
X#include "rcsbase.h"
X
libId(mapId, "$Id: rcsmap.c,v 5.2 1991/08/19 03:13:55 eggert Exp $")
X
X/* map of character types */
X/* ISO 8859/1 (Latin-1) */
enum tokens const ctab[] = {
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	SPACE,	SPACE,	NEWLN,	SPACE,	SPACE,	SPACE,	UNKN,	UNKN,
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	SPACE,	IDCHAR,	IDCHAR,	IDCHAR,	DELIM,	IDCHAR,	IDCHAR,	IDCHAR,
X	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	DELIM,	IDCHAR,	PERIOD,	IDCHAR,
X	DIGIT,	DIGIT,	DIGIT,	DIGIT,	DIGIT,	DIGIT,	DIGIT,	DIGIT,
X	DIGIT,	DIGIT,	COLON,	SEMI,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,
X	SBEGIN,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
X	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
X	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
X	LETTER,	LETTER,	LETTER,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,
X	IDCHAR,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,
X	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,
X	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,
X	Letter,	Letter,	Letter,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	UNKN,
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
X	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,
X	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,
X	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,
X	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,	IDCHAR,
X	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
X	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
X	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	IDCHAR,
X	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	Letter,
X	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,
X	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,
X	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	IDCHAR,
X	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter,	Letter
X};
END_OF_FILE
if test 3048 -ne `wc -c <'src/rcsmap.c'`; then
    echo shar: \"'src/rcsmap.c'\" unpacked with wrong size!
fi
# end of 'src/rcsmap.c'
fi
echo shar: End of archive 1 \(of 11\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
