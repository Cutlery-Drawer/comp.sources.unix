Subject:  v25i006:  trn 2.0 - threaded newsreader based on rn 4.4, Part03/13
Newsgroups: comp.sources.unix
Approved: vixie@pa.dec.com

Submitted-by: davison@borland.com (Wayne Davison)
Posting-number: Volume 25, Issue 6
Archive-name: trn/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 13)."
# Contents:  Makefile.SH Rnmail.SH addng.c artsrch.c config.h.SH
#   final.c head.c init.c kfile.c ngdata.c tmpthread.c
# Wrapped by vixie@cognition.pa.dec.com on Tue Dec  3 16:34:51 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.SH'\"
else
echo shar: Extracting \"'Makefile.SH'\" \(6864 characters\)
sed "s/^X//" >'Makefile.SH' <<'END_OF_FILE'
case $CONFIG in
X    '') . ./config.sh ;;
esac
echo "Extracting Makefile (with variable substitutions)"
X$cat >Makefile <<!GROK!THIS!
X# $Id: Makefile.SH,v 4.4.2.1 1991/12/01 18:05:42 sob PATCH_2 sob $
X#
X# This software is Copyright 1991 by Stan Barber. 
X#
X# Permission is hereby granted to copy, reproduce, redistribute or otherwise
X# use this software as long as: there is no monetary profit gained
X# specifically from the use or reproduction of this software, it is not
X# sold, rented, traded or otherwise marketed, and this copyright notice is
X# included prominently in any copy made. 
X#
X# The author make no claims as to the fitness or correctness of this software
X# for any use whatsoever, and it is provided as is. Any use of this software
X# is at the user's own risk. 
X#
X# $Log: Makefile.SH,v $
X# Revision 4.4.2.1  1991/12/01  18:05:42  sob
X# Changed clientlib to be built in the rn tree instead of the nntp tree.
X#
X# Revision 4.4.1.1  1991/09/25  19:38:08  sob
X# Changed some install directives
X#
X# Revision 4.4  1991/09/09  20:18:23  sob
X# release 4.4
X#
X#
X# 
X
CC = $cc
rnbin = $rnbin
rnlib = $rnlib
mansrc = $mansrc
manext = $manext
X#NNTPNNTPDIR = $NNTPSRC
X#NNTPNNTPINC = $rrninclude
CFLAGS = $cflags
LDFLAGS = $posix$iandd
NDIRC = $ndirc
NDIRO = $ndiro
X
libs = $ndirlib $termlib $jobslib $xnxlib $socketlib -lm $sharedclib
mlibs = $ndirlib $jobslib $xnxlib $socketlib $sharedclib
X!GROK!THIS!
X$cat >>Makefile <<'!NO!SUBS!'
X#NNTPnntp=getactive
X#MTmthreading=mthreads mt.check
public = trn tmpthread newsetup newsgroups Pnews Rnmail
private = norm.saver mbox.saver makedir\
X	filexp Pnews.header $(mthreading) $(nntp)
manpages = trn.1 Pnews.1 Rnmail.1 newsetup.1 newsgroups.1
util = Makefile makedepend newsnews
X
X
h1 = addng.h art.h artio.h artsrch.h autosub.h backpage.h bits.h cheat.h 
h2 = common.h decode.h final.h head.h help.h init.h intrp.h kfile.h last.h
h3 = ng.h ngdata.h ngsrch.h ngstuff.h only.h rcln.h rcstuff.h
h4 = respond.h rn.h search.h sw.h term.h util.h
X
h = $(h1) $(h2) $(h3) $(h4)
X
c1 = addng.c art.c artio.c artsrch.c autosub.c backpage.c bits.c cheat.c
c2 = decode.c final.c head.c help.c init.c intrp.c kfile.c last.c $(NDIRC)
c3 = ng.c ngdata.c ngsrch.c ngstuff.c only.c rcln.c rcstuff.c respond.c rn.c
c4 = rthreads.c rt-rn.c rt-select.c search.c sw.c term.c threads.c util.c
c5 = unship.c uudecode.c
X#NNTPc6 = server.c $(NNTPDIR)/common/clientlib.c
X
c = $(c1) $(c2) $(c3) $(c4) $(c5) $(c6)
X
mtc1 = mthreads.c mt-read.c mt-process.c mt-write.c mt-misc.c threads.c $(NDIRC)
X#NNMTmtc2 = $(c6)
mtc = $(mtc1) $(mtc2)
X
tmc = tmpthread.c tm-read.c tm-process.c tm-write.c mt-misc.c threads.c $(mtc2)
X
obj1 = addng.o art.o artio.o artsrch.o autosub.o backpage.o bits.o cheat.o
obj2 = decode.o final.o head.o help.o init.o intrp.o kfile.o last.o $(NDIRO)
obj3 = ng.o ngdata.o ngsrch.o ngstuff.o only.o rcln.o rcstuff.o respond.o rn.o
obj4 = rthreads.o rt-rn.o rt-select.o search.o sw.o term.o threads.o util.o
obj5 = unship.o uudecode.o
X#NNTPobj6 = server.o clientlib.o
X
obj = $(obj1) $(obj2) $(obj3) $(obj4) $(obj5) $(obj6)
X
mto1 = mthreads.o mt-read.o mt-process.o mt-write.o mt-misc.o
mto2 = threads.o getdate.o $(NDIRO)
X#NNMTmto3 = $(obj6)
mtobj = $(mto1) $(mto2) $(mto3)
X
tmo1 = tmpthread.o tm-read.o tm-process.o tm-write.o mt-misc.o
tmo2 = threads.o getdate.o
tmobj = $(tmo1) $(tmo2) $(obj6)
X
lintflags = -phbvxac
X
add1 = Makefile.old Pnews Rnmail mt.check
add2 = bsd config.h config.sh eunice filexp 
add3 = loc makedepend makedir mbox.saver ndir.h newsetup
add4 = newsgroups newsnews norm.saver
add5 = pdp11 usg v7 ultrix sun hp-ux sgi xenix next server.h mips uts
add6 = all pyr grimble .falseactive Pnews.header s5uniq sigtest stardent
X
addedbyconf = $(add1) $(add2) $(add3) $(add4) $(add5) $(add6)
X
X# grrr
SHELL = /bin/sh
X
X
X.c.o:
X	$(CC) -c $(CFLAGS) $*.c
X
all: $(public) $(private) $(util)
X	touch all
X
trn: $(obj)
X	$(CC) $(LDFLAGS) $(obj) $(libs) -o trn
X
mthreads: $(mtobj)
X	$(CC) $(LDFLAGS) $(mtobj) $(mlibs) -o mthreads
X
tmpthread: $(tmobj)
X	$(CC) $(LDFLAGS) $(tmobj) $(mlibs) -o tmpthread
X
mtgroups: mtgroups.o mt-misc.o
X	$(CC) $(LDFLAGS) mtgroups.o mt-misc.o -lcurses $(libs) -o mtgroups
X
X#NNTPgetactive: getactive.o server.o clientlib.o
X#NNTP	$(CC) $(LDFLAGS) getactive.o server.o clientlib.o -o getactive $(libs)
X
X#NNTPclientlib.o:
X#NNTP	$(CC) -c $(CFLAGS) $(NNTPINC) $(NNTPDIR)/common/clientlib.c
X
X# if a .h file depends on another .h file...
X$(h):
X	touch $@
X
install: $(public) $(private) $(manpages)
X# won't work with csh
X	export PATH || exit 1
X	- mv $(rnbin)/trn $(rnbin)/trn.old
X#NNTP	- ln -s trn $(rnbin)/trrn
X	- if test `pwd` != $(rnbin); then cp $(public) $(rnbin); fi
X	- if test `pwd` != $(rnbin); then cd $(rnbin); chmod 755 $(public); strip trn tmpthread ; fi
X	- ./makedir `./filexp $(rnlib)`
X#MT	- cd `./filexp $(rnlib)`; mv mthreads mthreads.old
X	- if test `pwd` != `./filexp $(rnlib)`; then cp INIT $(private) `./filexp $(rnlib)`; fi
X#NNTP	- if test `pwd` != `./filexp $(rnlib)`; then strip `./filexp $(rnlib)`/getactive ; fi
X	- if test ! -f `./filexp $(rnlib)/newsnews`; then cp newsnews `./filexp $(rnlib)`; fi
X	cd `./filexp $(rnlib)`; chmod 755 $(private); chmod 644 INIT newsnews
X#MT	- if test `pwd` != `./filexp $(rnlib)`; then strip `./filexp $(rnlib)`/mthreads ; fi
X	- if test `pwd` != $(mansrc); then \
for page in $(manpages); do \
cp $$page $(mansrc)/`basename $$page .1`.$(manext); \
done; \
X#NNTPecho ".so man$(manext)/trn.$(manext)" > $(mansrc)/trrn.$(manext) ; \
fi
X
clean:
X	rm -f *.o
X
realclean:
X	rm -f trn mthreads tmpthread *.o core $(addedbyconf) 
X#NNTP	rm -f clientlib.o getactive
X
X# The following lint has practically everything turned on.  Unfortunately,
X# you have to wade through a lot of mumbo jumbo that can't be suppressed.
X# If the source file has a /*NOSTRICT*/ somewhere, ignore the lint message
X# for that spot.
X
lint: lint_trn lint_mt lint_tm
X
lint_trn:
X	lint $(lintflags) $(defs) $(c) > trn.fuzz
X
lint_mt:
X	lint $(lintflags) $(mtc) > mt.fuzz
X
lint_tm:
X	lint $(lintflags) $(tmc) > tt.fuzz
X
sabertrn: $(c)
X	#load $(c) $(libs)
X
depend: config.h Makefile
X	./makedepend
X
X# AUTOMATICALLY GENERATED MAKE DEPENDENCIES--PUT NOTHING BELOW THIS LINE
config.h: config.h.SH config.sh ; sh config.h.SH
Makefile: Makefile.SH config.sh ; sh Makefile.SH
X$(obj):
X	@ echo "You haven't done a "'"make depend" yet!'; exit 1
X!NO!SUBS!
case "$isrrn" in
define) if $test "$serverspool " != " " ; then
X		sed < Makefile -e '/^#NNTP/s/^#NNTP//
X				   /^#MT/s/^#MT//
X				   /^#NNMT/d' > Makefile.new
X	else if $test "$xthread " != "define " ; then
X		sed < Makefile -e '/^#NNTP/s/^#NNTP//
X				   /^#MT/s/^#MT//
X				   /^#NNMT/s/^#NNMT//' > Makefile.new
X	else
X		sed < Makefile -e '/^#NNTP/s/^#NNTP//
X				   /^#MT/d
X				   /^#NNMT/s/^#NNMT//' > Makefile.new
X	fi ; fi
X	;;
X*)	sed < Makefile -e '/^#NNTP/d
X			   /^#MT/s/^#MT//
X			   /^#NNMT/d' > Makefile.new
X	;;
esac
mv Makefile.new Makefile
X$eunicefix Makefile
END_OF_FILE
if test 6864 -ne `wc -c <'Makefile.SH'`; then
    echo shar: \"'Makefile.SH'\" unpacked with wrong size!
fi
# end of 'Makefile.SH'
fi
if test -f 'Rnmail.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Rnmail.SH'\"
else
echo shar: Extracting \"'Rnmail.SH'\" \(6458 characters\)
sed "s/^X//" >'Rnmail.SH' <<'END_OF_FILE'
case $CONFIG in
X    '') . ./config.sh ;;
esac
echo "Extracting Rnmail (with variable substitutions)"
X$spitshell >Rnmail <<!GROK!THIS!
X$startsh
X# $Id: Rnmail.SH,v 4.4 1991/09/09 20:18:23 sob Exp sob $
X# 
X# $Log: Rnmail.SH,v $
X# Revision 4.4  1991/09/09  20:18:23  sob
X# release 4.4
X#
X#
X# 
X# This software is Copyright 1991 by Stan Barber. 
X#
X# Permission is hereby granted to copy, reproduce, redistribute or otherwise
X# use this software as long as: there is no monetary profit gained
X# specifically from the use or reproduction of this software, it is not
X# sold, rented, traded or otherwise marketed, and this copyright notice is
X# included prominently in any copy made. 
X#
X# The author make no claims as to the fitness or correctness of this software
X# for any use whatsoever, and it is provided as is. Any use of this software
X# is at the user's own risk. 
X#
X#
X# syntax: Rnmail -h headerfile [oldart]		or
X#         Rnmail destination-list 		or just
X#         Rnmail
X
export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
X# System dependencies
X
mailer="${mailer-/bin/mail}"
X# if you change this to something that does signatures, take out signature code
X
X# your site name
case $portable in
define)
X	case "$hostcmd" in
X	'') sitename="$sitename" ;;
X	*)  sitename=\`$hostcmd\` ;;
X	esac
X	case \$sitename in
X		*.*)
X			;;
X		*)
X			sitename=\${sitename}.$domain
X			;;
X	esac
X	;;
undef) sitename="$sitename" ;;
esac
X
X# your organization name
orgname="$orgname"
X# what pager you use--if you have kernal paging use cat
pager="\${PAGER-$pager}"
X# how you derive full names, bsd, usg, or other
nametype="$nametype"
X# default editor
defeditor="$defeditor"
X# where the non-publics are
rnlib=$rnlib
X# how not to do a newline with echo
n="$n"
c="$c"
X
test=${test-test}
sed=${sed-sed}
echo=${echo-echo}
cat=${cat-cat}
grep=${grep-grep}
rm=${rm-rm}
X
X!GROK!THIS!
case "$ignoreorg" in
define) $spitshell >>Rnmail <<'!NO!SUBS!'
orgname=${NEWSORG-$orgname}
X!NO!SUBS!
X	;;
X*)	$spitshell >>Rnmail <<'!NO!SUBS!'
orgname=${NEWSORG-${ORGANIZATION-$orgname}}
X!NO!SUBS!
X	;;
esac
X$spitshell >>Rnmail <<'!NO!SUBS!'
dotdir=${DOTDIR-${HOME-$LOGDIR}}
tmpart=$dotdir/.letter
X
headerfile=""
case $# in
X0) ;;
X*)  case $1 in
X    -h)
X	headerfile="$2"
X	case $# in
X	3) oldart=$3 ;;
X	esac
X	;;
X    esac
X    ;;
esac
X
case $headerfile in
X'')
X    case $# in
X    0)
X	to=h
X	while $test "$to" = h ; do
X	    $echo ""
X	    $echo $n "To: $c"
X	    read to
X	    case $to in
X	    h)
X		$cat <<'EOH'
X
Type the net address of those people that you wish the message sent to.
Additional recipients may be added on the Cc: line when you edit.
X
Separate multiple addresses with spaces.
X
XEOH
X		;;
X	    esac
X	done
X	;;
X    *)
X	to="$*"
X	;;
X    esac
X    to=`$echo "$to" | $sed 's/  */ /g'`
X
X    title=h
X    while $test "$title" = h ; do
X	$echo ""
X	$echo $n "Title/Subject: $c"
X	read title
X	case $title in
X	h)
X	    $cat <<'EOH'
X
Type the title for your message.  
XEOH
X	    ;;
X	esac
X    done
X
X# now build a file with a header for them to edit
X    
X    case $orgname in
X    /*) orgname=`$cat $orgname` ;;
X    esac
X
X    $sed -e '/^Reply-To: $/d' > $tmpart <<EOHeader
To: $to
Subject: $title
Organization: $orgname
Reply-To: $REPLYTO
Cc:
Bcc:
X
XEOHeader
X
X    ;;
X*)
X    $cat < $headerfile  > $tmpart
X    ;;
esac
X
X
file=h
while $test "$file" = h ; do
X    $echo ""
X    $echo $n "Prepared file to include [none]: $c"
X    read file
X    case $file in
X    h)
X	$cat <<'EOH'
X
If you have already produced the body of your message, type the filename
for it here.  If you just want to proceed directly to the editor, type a
RETURN.  In any event, you will be allowed to edit as many times as you
want before you send off the message.
XEOH
X	;;
X    '')
X	$echo "" >> $tmpart
X	state=edit
X	;;
X    *)
X	$cat $file >>$tmpart
X	state=ask
X	;;
X    esac
done
X
X$echo ""
X
while true ; do
X    case $state in
X    edit)
X	rescue="sleep 1; $cat $tmpart >>${HOME-$LOGDIR}/dead.letter ; $echo Message appended to ${HOME-$LOGDIR}/dead.letter ; exit"
X	trap "$rescue" 1
X	trap : 2
X	case "${VISUAL-${EDITOR-}}" in
X	'')
X	    tmp=h
X	    ;;
X	*)
X	    tmp=''
X	    ;;
X	esac
X	while $test "$tmp" = h ; do
X	    $echo $n "Editor [${VISUAL-${EDITOR-$defeditor}}]: $c"
X	    read tmp
X	    case $tmp in
X	    h)
X		$cat <<'EOH'
X
Type a return to get the default editor, or type the name of the editor you
prefer.  The default editor depends on the VISUAL and EDITOR environment
variables.
X
XEOH
X		;;
X	    '')
X		;;
X	    *)
X		VISUAL=$tmp
X		export VISUAL
X		;;
X	    esac
X	done
X	${VISUAL-${EDITOR-$defeditor}} $tmpart $oldart
X	trap "$rescue" 2
X	state=ask
X	;;
X	
X    ask)
X	$echo ""
X	$echo $n "Send, abort, edit, or list? $c"
X	read ans
X	
X	case $ans in
X	a*)
X	    state=rescue
X	    ;;
X	e*)
X	    set $ans
X	    case $# in
X	    2)  VISUAL="$2" ;;
X	    esac
X	    state=edit
X	    ;;
X	l*)
X	    $pager $tmpart
X	    state=ask
X	    ;;
X	s*)
X	    state=send
X	    ;;
X	h*)
X	    $cat <<'EOH'
X
Type s to send the message, a to abort and append the message to dead.letter,
e to edit the message again, or l to list the message.
X
To invoke an alternate editor, type 'e editor'.
XEOH
X	esac
X	;;
X    
X    send)
X	if $test -f $dotdir/.signature; then
X	    $echo $n "Append .signature file? [y] $c"
X	    read ans
X	    case $ans in
X	    ''|y*)
X		$echo "-- " >> $tmpart
X		cat $dotdir/.signature >> $tmpart
X		;;
X	    esac
X	fi
X	case $mailer in
X	*sendmail)
X	    $mailer -t <$tmpart
X	    ;;
X# but recmail does not know about Bcc, alas
X	*recmail)
X	    $mailer <$tmpart
X	    ;;
X	*)
X	    set X `$sed <$tmpart -n -e '/^To:/{' -e 's/To: *//p' -e q -e '}'`
X	    shift
X	    set X "$@" `$sed <$tmpart -n -e '/^Cc:/{' -e 's/Cc: *//p' -e q -e '}'`
X	    shift
X	    set X "$@" `$sed <$tmpart -n -e '/^Bcc:/{' -e 's/Bcc: *//p' -e q -e '}'`
X	    shift
X	    $grep -v "^Bcc:"  <$tmpart | $mailer "$@"
X	    ;;
X	esac
X	case $? in
X	0)
X	    state=cleanup
X	    ;;
X	*)
X	    state=rescue
X	    ;;
X	esac
X	;;
X    rescue)
X	$cat $tmpart >> ${HOME-$LOGDIR}/dead.letter
X	$echo "Message appended to ${HOME-$LOGDIR}/dead.letter"
X	$echo "A copy may be temporarily found in $tmpart"
X	exit
X	;;
X    cleanup)
X	case "${MAILRECORD-none}" in
X	none)
X	    ;;
X	*)
X	    set X ${USER-${LOGNAME-`who am i`}} unknown
X	    shift
X	    $rnlib/mbox.saver $tmpart "." "." 0 0 Pnews $MAILRECORD "From $1 `date`"
X	    if $test $? -eq 0 ; then
X		$echo "Message appended to $MAILRECORD"
X	    else
X		$echo "Cannot append to $MAILRECORD"
X	    fi
X	    ;;
X	esac
X	exit
X	;;
X    esac
done
X!NO!SUBS!
X$eunicefix Rnmail
chmod 755 Rnmail
END_OF_FILE
if test 6458 -ne `wc -c <'Rnmail.SH'`; then
    echo shar: \"'Rnmail.SH'\" unpacked with wrong size!
fi
# end of 'Rnmail.SH'
fi
if test -f 'addng.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'addng.c'\"
else
echo shar: Extracting \"'addng.c'\" \(8453 characters\)
sed "s/^X//" >'addng.c' <<'END_OF_FILE'
X/* $Id: addng.c,v 4.4.2.1 1991/12/01 18:05:42 sob PATCH_2 sob $
X *
X * $Log: addng.c,v $
X * Revision 4.4.2.1  1991/12/01  18:05:42  sob
X * Patchlevel 2 changes
X *
X * Revision 4.4  1991/09/09  20:18:23  sob
X * release 4.4
X *
X *
X * 
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "rn.h"
X#include "ngdata.h"
X#include "last.h"
X#include "util.h"
X#include "intrp.h"
X#include "only.h"
X#include "rcstuff.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X#include "final.h"
X#include "INTERN.h"
X#include "addng.h"
X
X#ifdef TZSET
X#include <time.h>
X#else
X#include <sys/time.h>
X#include <sys/timeb.h>
X#endif
X
void
addng_init()
X{
X    ;
X}
X
X#ifdef FINDNEWNG
X/* generate a list of new newsgroups from active file */
X
bool
newlist(munged,checkinlist)
bool_int munged;			/* are we scanning the whole file? */
bool_int checkinlist;
X{
X    char *tmpname;
X    register char *s, *status;
X    register NG_NUM ngnum;
X#ifndef ACTIVE_TIMES
X    long birthof();
X#endif
X
X    tmpname = filexp(RNEWNAME);
X    tmpfp = fopen(tmpname,"w+");
X    if (tmpfp == Nullfp) {
X	printf(cantcreate,tmpname) FLUSH;
X	return FALSE;
X    }
X    UNLINK(tmpname);			/* be nice to the world */
X
X    while (fgets(buf,LBUFLEN,actfp) != Nullch) {
X	/* Check if they want to break out of the new newsgroups search */
X	if (int_count) {
X	    int_count = 0;
X	    fclose(tmpfp);
X	    return FALSE;
X	}
X	if (s = index(buf,' ')) {
X	    status=s;
X	    while (isdigit(*status) || isspace(*status)) status++;
X	    *s++ = '\0';
X	    if (strnEQ(buf,"to.",3) || *status == 'x' || *status == '=')
X	        /* since = groups are refiling to another group, just
X		   ignore their existence */
X		continue;
X#ifdef ACTIVE_TIMES
X	    if (inlist(buf) && ((ngnum = find_ng(buf)) == nextrcline
X				|| toread[ngnum] == TR_UNSUB)
X#else
X	    if (checkinlist ?
X		(inlist(buf) && ((ngnum = find_ng(buf)) == nextrcline
X				 || toread[ngnum] == TR_UNSUB))
X	      : (find_ng(buf) == nextrcline
X		 && birthof(buf,(ART_NUM)atol(s)) > lasttime)
X#endif
X	    ) {
X					/* if not in .newsrc and younger */
X					/* than the last time we checked */
X		fprintf(tmpfp,"%s\n",buf);
X					/* then remember said newsgroup */
X	    }
X#ifdef FASTNEW
X	    else {			/* not really a new group */
X		if (!munged) {		/* did we assume not munged? */
X		    fclose(tmpfp);	/* then go back, knowing that */
X		    return TRUE;	/* active file was indeed munged */
X		}
X	    }
X#endif
X	}
X#ifdef DEBUGGING
X	else
X	    printf("Bad active record: %s\n",buf) FLUSH;
X#endif
X    }
X
X    /* we have successfully generated the list */
X
X    fseek(tmpfp,0L,0);			/* rewind back to the beginning */
X    while (fgets(buf,LBUFLEN,tmpfp) != Nullch) {
X	buf[strlen(buf)-1] = '\0';
X	get_ng(buf,TRUE);		/* add newsgroup, maybe */
X    }
X    fclose(tmpfp);			/* be nice to ourselves */
X    return FALSE;			/* do not call us again */
X}
X
X#ifdef ACTIVE_TIMES
X#ifdef SERVER
X
bool
find_new_groups()
X{
X    char *tmpname;
X    register char *s;
X    struct tm *ts;
X    long now;
X    NG_NUM oldnext = nextrcline;	/* remember # lines in newsrc */
X
X    tmpname = filexp(RNEWNAME);
X    tmpfp = fopen(tmpname,"w+");
X    if (tmpfp == Nullfp) {
X	printf(cantcreate,tmpname) FLUSH;
X	return FALSE;
X    }
X    UNLINK(tmpname);			/* be nice to the world */
X
X    time(&now);
X    ts = gmtime(&lastnewtime);
X    sprintf(ser_line, "NEWGROUPS %02d%02d%02d %02d%02d%02d GMT",
X	ts->tm_year % 100, ts->tm_mon+1, ts->tm_mday,
X	ts->tm_hour, ts->tm_min, ts->tm_sec);
X#ifdef DEBUGGING
X    if (debug & DEB_NNTP)
X	printf(">%s\n", ser_line) FLUSH;
X#endif
X    put_server(ser_line);
X    nntp_get(ser_line, sizeof(ser_line));
X#ifdef DEBUGGING
X    if (debug & DEB_NNTP)
X	printf("<%s\n", ser_line) FLUSH;
X#endif
X    if (*ser_line != CHAR_OK) {		/* and then see if that's ok */
X  error_exit:
X	fclose(tmpfp);
X	printf("Can't get new groups from server:\n%s\n", ser_line);
X	return FALSE;
X    }
X
X    while (1) {
X	if (nntp_get(ser_line, sizeof(ser_line)) < 0)
X	    goto error_exit;
X#ifdef DEBUGGING
X	if (debug & DEB_NNTP)
X	    printf("<%s\n", ser_line) FLUSH;
X#endif
X	if (ser_line[0] == '.')
X	    break;
X	if ((s = index(ser_line, ' ')) != Nullch)
X	    *s = '\0';
X	fprintf(tmpfp,"%s\n",ser_line);
X    }
X
X    /* we have successfully generated the list */
X
X    if (ftell(tmpfp)) {
X	fputs("\nFinding new newsgroups:\n",stdout) FLUSH;
X
X	fseek(tmpfp,0L,0);		/* rewind back to the beginning */
X	while (fgets(buf,LBUFLEN,tmpfp) != Nullch) {
X	    buf[strlen(buf)-1] = '\0';
X	    get_ng(buf,FALSE);		/* add newsgroup, maybe */
X	}
X	lastnewtime = now;		/* remember when we found new groups */
X    }					/* (ends up back in .rnlast) */
X    fclose(tmpfp);			/* be nice to ourselves */
X
X    return oldnext != nextrcline;
X}
X#else /* not SERVER */
X
bool
find_new_groups()
X{
X    register char *s;
X    long lastone;
X    NG_NUM oldnext = nextrcline;	/* remember # lines in newsrc */
X
X    fstat(fileno(actfp),&filestat);	/* find active file size */
X    lastactsiz = filestat.st_size;	/* just to save it in .rnlast */
X
X    stat(ACTIVE_TIMES,&filestat);	/* did active.times file grow? */
X    if (filestat.st_size == lastnewsize)
X	return FALSE;
X    lastnewsize = filestat.st_size;
X
X    fputs("\nChecking for new newsgroups...\n",stdout) FLUSH;
X
X    s = filexp(ACTIVE_TIMES);
X    tmpfp = fopen(s,"r");
X    if (tmpfp == Nullfp) {
X	printf(cantopen,s) FLUSH;
X	return FALSE;
X    }
X    lastone = time(Null(time_t*)) - 24L * 60 * 60 - 1;
X    while (fgets(buf,LBUFLEN,tmpfp) != Nullch) {
X	if ((s = index(buf, ' ')) != Nullch)
X	    if ((lastone = atol(s+1)) >= lastnewtime) {
X		char tmpbuf[80];
X		*s = '\0';
X		if (findact(tmpbuf, buf, s - buf, 0L) >= 0)
X		    get_ng(buf,FALSE);	/* add newsgroup, maybe */
X	    }
X    }
X    fclose(tmpfp);
X    lastnewtime = lastone+1;		/* remember time of last new group */
X					/* (ends up back in .rnlast) */
X    return oldnext != nextrcline;
X}
X#endif /* SERVER */
X#else /* not ACTIVE_TIMES */
X
bool
find_new_groups()
X{
X    long oldactsiz = lastactsiz;
X    NG_NUM oldnext = nextrcline;	/* remember # lines in newsrc */
X
X    fstat(fileno(actfp),&filestat);	/* did active file grow? */
X
X    if (filestat.st_size == lastactsiz)
X	return FALSE;
X    lastactsiz = filestat.st_size;	/* remember new size */
X
X#ifdef VERBOSE
X    IF(verbose)
X	fputs("\nChecking active file for new newsgroups...\n",stdout) FLUSH;
X    ELSE
X#endif
X#ifdef TERSE
X	fputs("\nNew newsgroups:\n",stdout) FLUSH;
X#endif
X
X#ifdef FASTNEW				/* bad soft ptrs -> edited active */
X    if (!writesoft && oldactsiz) {	/* maybe just do tail of file? */
X	fseek(actfp,oldactsiz-NL_SIZE,0);
X	fgets(buf,LBUFLEN,actfp);
X	if (*buf == '\n' && !newlist(FALSE,FALSE))
X	    goto bugout;
X    }
X#endif
X    fseek(actfp,0L,0);		/* rewind active file */
X    newlist(TRUE,FALSE);		/* sure hope they use hashing... */
bugout:
X    return oldnext != nextrcline;
X}
X
X/* return creation time of newsgroup */
X
long
birthof(ngnam,ngsize)
char *ngnam;
ART_NUM ngsize;
X{
X    char tst[128];
X    long time();
X 
X#ifdef SERVER		/* ngsize not used */
X    int x,tot,min,max;
X    sprintf(tst,"GROUP %s",ngnam);
X#ifdef DEBUGGING
X    if (debug & DEB_NNTP)
X	printf(">%s\n", tst) FLUSH;
X#endif
X    put_server(tst);
X    (void) nntp_get(tst, sizeof(tst));
X#ifdef DEBUGGING
X    if (debug & DEB_NNTP)
X	printf("<%s\n", tst) FLUSH;
X#endif
X    if (*tst != CHAR_OK) return(0); /* not a real group */
X    (void) sscanf(tst,"%d%d%d%d",&x,&tot,&min,&max);
X    if (tot > 0) return(time(Null(long *)));
X    else return(0);
X#else /* not SERVER */
X
X    sprintf(tst, ngsize ? "%s/%s/1" : "%s/%s" ,spool,getngdir(ngnam));
X    if (stat(tst,&filestat) < 0)
X	return (ngsize ? 0L : time(Null(long *)));
X	/* not there, assume something good */
X    else
X	return filestat.st_mtime;
X
X#endif
X}
X#endif /* ACTIVE_TIMES */
X
bool
scanactive()
X{
X    NG_NUM oldnext = nextrcline;	/* remember # lines in newsrc */
X
X    fseek(actfp,0L,0);
X    newlist(TRUE,TRUE);
X    if (nextrcline != oldnext) {	/* did we add any new groups? */
X	return TRUE;
X    }
X    return FALSE;
X}
X
X#endif
X
END_OF_FILE
if test 8453 -ne `wc -c <'addng.c'`; then
    echo shar: \"'addng.c'\" unpacked with wrong size!
fi
# end of 'addng.c'
fi
if test -f 'artsrch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'artsrch.c'\"
else
echo shar: Extracting \"'artsrch.c'\" \(8260 characters\)
sed "s/^X//" >'artsrch.c' <<'END_OF_FILE'
X/* $Id: artsrch.c,v 4.4.2.1 1991/12/01 18:05:42 sob PATCH_2 sob $
X *
X * $Log: artsrch.c,v $
X * Revision 4.4.2.1  1991/12/01  18:05:42  sob
X * Patchlevel 2 changes
X *
X * Revision 4.4  1991/09/09  20:18:23  sob
X * release 4.4
X *
X *
X * 
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "search.h"
X#include "term.h"
X#include "util.h"
X#include "intrp.h"
X#include "bits.h"
X#include "kfile.h"
X#include "head.h"
X#include "final.h"
X#include "cheat.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X#include "ng.h"
X#include "artio.h"
X#ifdef USETHREADS
X#include "threads.h"
X#include "rthreads.h"
X#include "ngdata.h"
X#endif
X#include "INTERN.h"
X#include "artsrch.h"
X
void
artsrch_init()
X{
X#ifdef ARTSEARCH
X#ifdef ZEROGLOB
X    init_compex(&sub_compex);
X    init_compex(&art_compex);
X#endif
X#endif
X}
X
X/* search for an article containing some pattern */
X
X#ifdef ARTSEARCH
int
art_search(patbuf,patbufsiz,get_cmd)
char *patbuf;				/* if patbuf != buf, get_cmd must */
int patbufsiz;
int get_cmd;				/*   be set to FALSE!!! */
X{
X    char *pattern;			/* unparsed pattern */
X    register char cmdchr = *patbuf;	/* what kind of search? */
X    register char *s;
X    bool backward = cmdchr == '?' || cmdchr == Ctl('p');
X					/* direction of search */
X    COMPEX *compex;			/* which compiled expression */
X    char *cmdlst = Nullch;		/* list of commands to do */
X    int normal_return = SRCH_NOTFOUND;	/* assume no commands */
X    bool saltaway = FALSE;		/* store in KILL file? */
X    char howmuch;			/* search just the subjects */
X    bool doread;			/* search read articles? */
X    bool foldcase = TRUE;		/* fold upper and lower case? */
X
X    int_count = 0;
X    if (cmdchr == '/' || cmdchr == '?') {	/* normal search? */
X	if (get_cmd && buf == patbuf)
X	    if (!finish_command(FALSE))	/* get rest of command */
X		return SRCH_ABORT;
X	compex = &art_compex;
X	if (patbuf[1]) {
X	    howmuch = 0;
X	    doread = FALSE;
X	}
X	else {
X	    howmuch = art_howmuch;
X	    doread = art_doread;
X	}
X	s = cpytill(buf,patbuf+1,cmdchr);/* ok to cpy buf+1 to buf */
X	pattern = buf;
X	if (*pattern) {
X	    if (*lastpat)
X		free(lastpat);
X	    lastpat = savestr(pattern);
X	}
X	if (*s) {			/* modifiers or commands? */
X	    for (s++; *s && index("Kharc",*s); s++) {
X		if (*s == 'h')		/* scan header */
X		    howmuch = 1;
X		else if (*s == 'a')	/* scan article */
X		    howmuch = 2;
X		else if (*s == 'r')	/* scan read articles */
X		    doread = TRUE;
X		else if (*s == 'K')	/* put into KILL file */
X		    saltaway = TRUE;
X		else if (*s == 'c')	/* make search case sensitive */
X		    foldcase = FALSE;
X	    }
X	}
X	while (isspace(*s) || *s == ':')
X	    s++;
X	if (*s) {
X	    if (*s == 'm' || *s == 'M')
X		doread = TRUE;
X	    if (*s == 'k')		/* grandfather clause */
X		*s = 'j';
X	    cmdlst = savestr(s);
X	    normal_return = SRCH_DONE;
X	}
X	art_howmuch = howmuch;
X	art_doread = doread;
X	if (srchahead)
X	    srchahead = -1;
X    }
X    else {
X	register char *h;
X
X	howmuch = 0;			/* just search subjects */
X	doread = (cmdchr == Ctl('p'));
X	if (cmdchr == Ctl('n'))
X	    normal_return = SRCH_SUBJDONE;
X	compex = &sub_compex;
X	pattern = patbuf+1;
X	strcpy(pattern,": *");
X	h = pattern + strlen(pattern);
X	interp(h,patbufsiz - (h-patbuf),"%\\s");  /* fetch current subject */
X	if (cmdchr == 'K') {
X	    saltaway = TRUE;
X	    cmdchr = 'k';
X	}
X	if (cmdchr == 'k') {
X	    normal_return = SRCH_DONE;
X	    cmdlst = savestr("j");
X	    mark_as_read();		/* this article has this subject */
X	    if (!*h) {
X#ifdef VERBOSE
X		IF(verbose)
X		    fputs("\nCannot delete null subject.\n",stdout) FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    fputs("\nNull subject.\n",stdout) FLUSH;
X#endif
X		return SRCH_ABORT;
X	    }
X#ifdef VERBOSE
X	    else if (verbose)
X		printf("\nMarking subject \"%s\" as read.\n",h) FLUSH;
X#endif
X	}
X	else if (!srchahead)
X	    srchahead = -1;
X	{			/* compensate for notesfiles */
X	    register int i;
X	    for (i = 24; *h && i--; h++)
X		if (*h == '\\')
X		    h++;
X	    *h = '\0';
X	}
X#ifdef DEBUGGING
X	if (debug) {
X	    printf("\npattern = %s\n",pattern) FLUSH;
X	}
X#endif
X    }
X    if ((s = compile(compex,pattern,TRUE,foldcase)) != Nullch) {
X					/* compile regular expression */
X	printf("\n%s\n",s) FLUSH;
X	return SRCH_ABORT;
X    }
X#ifdef KILLFILES
X    if (saltaway) {
X	char saltbuf[LBUFLEN];
X
X	s = saltbuf;
X	sprintf(s,"/%s/",pattern);
X	s += strlen(s);
X	if (doread)
X	    *s++ = 'r';
X	if (howmuch==1)
X	    *s++ = 'h';
X	else if (howmuch==2)
X	    *s++ = 'a';
X	*s++ = ':';
X	if (!cmdlst)
X	    cmdlst = savestr("j");
X	safecpy(s,cmdlst,LBUFLEN-(s-saltbuf));
X	kf_append(saltbuf);
X    }
X#endif
X    if (cmdlst && index(cmdlst,'='))
X	normal_return = SRCH_ERROR;	/* listing subjects is an error? */
X    if (get_cmd) {
X	fputs("\nSearching...\n",stdout) FLUSH;
X					/* give them something to read */
X    }
X#ifdef USETHREADS
X    if (mode == 't') {
X	if (!cmdlst)
X	    cmdlst = savestr("+");	/* thread selector's default command */
X	if (unread_selector)
X	    doread = TRUE;
X	normal_return = SRCH_DONE;
X    }
X#endif
X    if (backward) {
X	if (cmdlst && art <= lastart)
X	    art++;			/* include current article */
X	if (doread)
X	    check_first(absfirst);
X    }
X    else {
X	if (art > lastart) {
X	    art = (doread ? absfirst : firstart);
X	    check_first(art--);
X	}
X	else if (cmdlst && art >= absfirst)
X	    art--;			/* include current article */
X    }
X    if (srchahead > 0) {
X	if (!backward)
X	    art = srchahead - 1;
X	srchahead = -1;
X    }
X    assert(!cmdlst || *cmdlst);
X    perform_cnt = 0;
X    for (;;) {
X	if (backward ?
X		(--art < absfirst || (!doread && art < firstart)) :
X		(++art > lastart)
X	  ) {			/* out of articles? */
X	    if (cmdlst)
X		free(cmdlst);
X	    return normal_return;
X	}
X	if (int_count) {
X	    int_count = 0;
X	    if (cmdlst)
X		free(cmdlst);
X	    return SRCH_INTR;
X	}
X	/*NOSTRICT*/
X	if (doread || !was_read(art)) {
X	    if (wanted(compex,art,howmuch)) {
X				    /* does the shoe fit? */
X		if (cmdlst) {
X		    if (perform(cmdlst,TRUE)) {
X			if (cmdlst)
X			    free(cmdlst);
X			return SRCH_INTR;
X		    }
X		}
X		else {
X		    if (cmdlst)
X			free(cmdlst);
X		    return SRCH_FOUND;
X		}
X	    }
X	    else if (!cmdlst && ! (art%50)) {
X		printf("...%ld",(long)art);
X		fflush(stdout);
X	    }
X	}
X    }
X}
X
X/* determine if article fits pattern */
X/* returns TRUE if it exists and fits pattern, FALSE otherwise */
X
bool
wanted(compex, artnum, scope)
COMPEX *compex;
ART_NUM artnum;
char_int scope;
X{
X    if (!scope) {
X	char subj_buf[266];
X	
X#ifdef USETHREADS
X	if (ThreadedGroup)
X	    find_article(art);
X	if (p_art) {
X	    if (mode != 't')
X		strcpy(subj_buf, "Subject: ");
X	    else
X		*subj_buf = '\0';
X	    if (p_art->subject != -1)
X		strcat(subj_buf,subject_ptrs[p_art->subject]);
X	}
X	else
X#endif
X	{
X	    strcpy(subj_buf, "Subject: ");
X	    strncpy(subj_buf+9,fetchsubj(artnum,FALSE,FALSE),256);
X	}
X#ifdef DEBUGGING
X	if (debug & DEB_SEARCH_AHEAD)
X	    printf("%s\n",subj_buf) FLUSH;
X#endif
X	return execute(compex,subj_buf) != Nullch;
X    }
X#ifdef CACHESUBJ
X    else
X	fetchsubj(artnum,FALSE,FALSE);/* might as well get subject handy */
X#endif
X    
X#ifdef SERVER
X    if (scope == 1){
X	if (nntpopen(artnum,GET_HEADER) == Nullfp) /* we only need the header */
X	    return FALSE;
X    }
X    else
X#endif
X    if (artopen(artnum) == Nullfp)	/* ensure that article is open */
X
X	return FALSE;			/* if not, return NO MATCH */
X    scope--;
X    while (fgets(buf,LBUFLEN,artfp) != Nullch) {
X					/* for each line of article */
X	if (!scope && index(buf,':') == Nullch && *buf != ' ' && *buf != '\t')
X					/* if headers only and out of header */
X	    return FALSE;		/* say no go */
X	if (execute(compex,buf) != Nullch) {
X					/* does pattern matcher match? */
X	    return TRUE;		/* say Eureka */
X	}
X    }
X    return FALSE;			/* out of article, so no match */
X}
X#endif
X
END_OF_FILE
if test 8260 -ne `wc -c <'artsrch.c'`; then
    echo shar: \"'artsrch.c'\" unpacked with wrong size!
fi
# end of 'artsrch.c'
fi
if test -f 'config.h.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h.SH'\"
else
echo shar: Extracting \"'config.h.SH'\" \(6846 characters\)
sed "s/^X//" >'config.h.SH' <<'END_OF_FILE'
X: create config.h file
case $CONFIG in
X    '') . ./config.sh ;;
esac
echo "Extracting config.h (with variable substitutions)"
case "$threaddir" in
X'.')	threaddir='/usr/spool/threads'
X	tdir='undef';;
X*)	tdir='define';;
esac
case "$serverspool" in
X'') sspool='undef';;
X*)  sspool='define';;
esac
case "$activetimes" in
X'none')	acttimes='undef';;
X*)	acttimes='define';;
esac
case "$syslog" in
LOG_*)	syslog2='define';;
X*)	syslog2='undef';;
esac
case "$hostfile" in
X'')	usehostfile='undef';;
X*)	usehostfile='define';;
esac
X
X$sed 's,^#undef,/*#undef,' >config.h <<EOT
X/* config.h
X * This file was produced by running the config.h.SH script, which
X * gets its values from config.sh, which is generally produced by
X * running Configure.
X *
X * Feel free to modify any of this as the need arises.  Note, however,
X * that running config.h.SH again will wipe out any changes you've made.
X * For a more permanent change edit config.sh and rerun config.h.SH.
X * $Id: config.h.SH,v 4.4.2.1 1991/12/01 18:05:42 sob PATCH_2 sob $
X *
X * $Log: config.h.SH,v $
X * Revision 4.4.2.1  1991/12/01  18:05:42  sob
X * Fixed problems with CTRLA flag.
X *
X * Revision 4.4  1991/09/09  20:18:23  sob
X * release 4.4
X *
X *
X * 
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X/* name of the site.  May be overridden by HOSTFILE, gethostname, uname, etc. */
X#define SITENAME "$sitename"
X#$usehostfile HOSTFILE "$hostfile"	/* defined if we read the hostname from a file */
X
X/* domain name for the site */
X#define OURDOMAIN "$domain"
X
X/* name of the organization, may be a file name */
X#define ORGNAME "$orgname"
X
X/* ignore the ORGANIZATION environment variable */
X#$ignoreorg IGNOREORG		/**/
X
X/* login name of news administrator, if any. */
X#$isadmin NEWSADMIN "$newsadmin"	/**/
X
X/* news library, may use only ~ and %l expansion */
X#define LIB "$lib"
X
X/* rn private library, may use ~ expansion, %x and %l */
X#define RNLIB "$rnlib"
X
X/* mthreads private files */
X#define MTLIB "$mtlib"
X
X/* location of the news spool directory, may use ~ expansion, %x and %l */
X#define SPOOL "$spool"
X
X/* the server's spool directory if generating an NNTP trn & a local mthreads */
X#$sspool SERVERSPOOL "$serverspool"	/* forces local mthreads */
X
X/* put thread files in each spool directory, unless THREAD_DIR is defined */
X#$tdir THREAD_DIR "$threaddir"	/* base directory */
X
X/* save in subdirectories unless LONG_THREAD_NAMES & THREAD_DIR are defined */
X#undef LONG_THREAD_NAMES		/* not for short-name systems */
X
X/* I doubt you'd want to undefine this, but someone may */
X#define USETMPTHREAD			/* use tmpthread to update threads */
X
X/* location of the active file, may use ~ expansion, %x and %l */
X#define ACTIVE "$active"
X
X/* define where the active.times file is kept if we're using it */
X#$acttimes ACTIVE_TIMES "$activetimes"	/* including name */
X
X/* location of spooled mail */
X#define MAILFILE "$maildir"
X
X/* default shell--ok to be a slow shell like csh */
X#define PREFSHELL "$pref"
X
X/* default editor */
X#define DEFEDITOR "$defeditor"
X
X/* root uid */
X#define ROOTID $rootid
X
X/* what is the first character of a mailbox? */
X#define MBOXCHAR '$mboxchar'
X
X/* how to cancel an article */
X#define CANCEL "$inews -h <%h"
X
X/* distribution groups */
X#define LOCDIST   "$locpref"
X#define ORGDIST   "$orgpref"
X#define CITYDIST  "$citypref"
X#define STATEDIST "$statepref"
X#define CNTRYDIST "$cntrypref"
X#define CONTDIST  "$contpref"
X
X#define THREAD_INIT $threaddef
X#define SELECT_INIT $selectdef
X
X#$strchr index  strchr		/* cultural */
X#$strchr rindex strrchr		/*  differences? */
X#$memcpy bcopy(s,d,n) memcpy((char*)d,(char*)s,(int)n)	/* Different */
X#$memcpy bzero(d,n)   memset((char*)d,0,(int)n)		/*  flavors. */
X#$rename RENAME		/* is rename() a system call? */
X#$ftruncate FTRUNCATE	/* is ftruncate() available? */
X#$usleep USLEEP		/* do we have usleep? */
X#$uselect USELECT 	/* should we use select to emulate usleep? */
X#$strftime STRFTIME	/* is strftime() available? */
X#$chsize CHSIZE		/* is chsize() available? */
X#$tzset TZSET		/* modern timezone functions? */
X#$novoid void int	/* is void to be avoided? */
X#$novfork vfork fork	/* is vfork too virtual? */
X#$sunos4 SUNOS4		/* running SunOS 4.X? */
X#$eunice EUNICE		/* no linking? */
X#$eunice VMS		/* not currently used, here just in case */
X#$getcwd GETCWD		/* do we have getcwd()? */
X#$getwd GETWD		/* do we have getwd()? */
X#$setvbuf SETVBUF 	/* do we have setvbuf()? */
X#$setbuffer SETBUFFER	/* do we have setbuffer()? */
X#$usendir USENDIR 	/* include ndir.c? */
X#$libndir LIBNDIR 	/* include /usr/include/ndir.h? */
X#define DIRTYPE $dirtype
X#ifndef USENDIR
X#define DIRINC $dirinc
X#endif
X#$mininact MININACT	/* include 2.10.2 optimization? */
X#$portable PORTABLE	/* do we do extra lookups to start up? */
X#$passnam PASSNAMES	/* do names come from the passwd file? */
X			/*  (undef to take name from ~/.fullname) */
X#$berknam BERKNAMES	/* if so, are they Berkeley format? */
X			/* (that is, ":name,stuff:") */
X#$usgnam USGNAMES	/* or are they USG format? */
X			/* (that is, ":stuff-name(stuff):") */
X#$whoami WHOAMI		/* should we include whoami.h? */
X#$rdchk RDCHK		/* do we have rdchk()? */
X#$termio TERMIO		/* is this a termio system? */
X#$termios TERMIOS 	/* is this a termios system? */
X#$fcntl FCNTL		/* should we include fcntl.h? */
X#$ioctl IOCTL		/* are ioctl args all defined in one place? */
X#$ptem PTEM		/* has the ptem.h include file ? */
X#$normsig NORMSIG 	/* use signal rather than sigset? */
X#$sigblock SIGBLOCK	/* use sigblock and sigsetmask */
X#$sighold HAVESIGHOLD	/* use sighold and sigrelse */
X#define SIGRET $sigret	/* what does signal() return? */
X#$havetlib HAVETERMLIB	/* do we have termlib-style routines? */
X#$getuidgid GETUIDGID	/* allow setuid (if possible) */
X#$getpwent GETPWENT	/* should we include getpwent? */
X#$internet INTERNET	/* does our mailer do INTERNET addressing? */
X#$gethostname GETHOSTNAME	/* do we have a gethostname function? */
X#$douname DOUNAME 	/* do we have a uname function? */
X#$phostname PHOSTNAME "$hostcmd"	/* how to get host name with popen */
X#$norelay NORELAY 	/* 2.10.3 doesn't have Relay-Version line */
X#$isrrn SERVER		/* rrn server code */
X#$isrrn SERVER_FILE "$serverfile"	/* news server file */
X#$syslog2 USESYSLOG $syslog	/* use syslog for mthreads' log messages */
X#$xthread XTHREAD 	/* get thread files via NNTP */
XEOT
END_OF_FILE
if test 6846 -ne `wc -c <'config.h.SH'`; then
    echo shar: \"'config.h.SH'\" unpacked with wrong size!
fi
# end of 'config.h.SH'
fi
if test -f 'final.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'final.c'\"
else
echo shar: Extracting \"'final.c'\" \(5349 characters\)
sed "s/^X//" >'final.c' <<'END_OF_FILE'
X/* $Id: final.c,v 4.4.2.1 1991/12/01 18:05:42 sob PATCH_2 sob $
X *
X * $Log: final.c,v $
X * Revision 4.4.2.1  1991/12/01  18:05:42  sob
X * Patchlevel 2 changes
X *
X * Revision 4.4  1991/09/09  20:18:23  sob
X * release 4.4
X *
X *
X * 
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "term.h"
X#include "ng.h"
X#include "init.h"
X#include "bits.h"
X#include "last.h"
X#include "rcstuff.h"
X#include "ngdata.h"
X#include "artio.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X#include "INTERN.h"
X#include "final.h"
X
void
final_init()
X{
X#ifdef SIGTSTP
X    sigset(SIGTSTP, stop_catcher);	/* job control signals */
X    sigset(SIGTTOU, stop_catcher);	/* job control signals */
X    sigset(SIGTTIN, stop_catcher);	/* job control signals */
X#endif
X
X    sigset(SIGINT, int_catcher);	/* always catch interrupts */
X#ifdef SIGHUP
X    sigset(SIGHUP, sig_catcher);	/* and hangups */
X#endif
X    sigset(SIGILL, sig_catcher);
X#ifdef SIGTRAP
X    sigset(SIGTRAP, sig_catcher);
X#endif
X    sigset(SIGFPE, sig_catcher);
X#ifdef SIGBUS
X    sigset(SIGBUS, sig_catcher);
X#endif
X    sigset(SIGSEGV, sig_catcher);
X#ifdef SIGSYS
X    sigset(SIGSYS, sig_catcher);
X#endif
X    sigset(SIGTERM, sig_catcher);
X#ifdef SIGXCPU
X    sigset(SIGXCPU, sig_catcher);
X#endif
X#ifdef SIGXFSZ
X    sigset(SIGXFSZ, sig_catcher);
X#endif
X#ifdef SIGWINCH
X    sigset(SIGWINCH, winch_catcher);
X#endif
X
X#ifndef lint
X#ifdef SIGEMT
X    sigignore(SIGEMT);
X#endif
X#endif /* lint */
X}
X
void					/* very much void */
finalize(status)
int status;
X{
X    termlib_reset();
X    if (bizarre)
X	resetty();
X    if (lockname && *lockname)
X 	UNLINK(lockname);
X#ifdef USETHREADS
X    if (tmpthread_group)
X	UNLINK(tmpthread_file);
X#endif
X#ifdef SERVER
X    if (*active_name)
X	UNLINK(active_name);
X    if (openart) {
X 	char artname[MAXFILENAME];
X	char intrpwork[MAXFILENAME];
X	interp(intrpwork,MAXFILENAME,"%P");
X 	sprintf(artname, "%s/rrn%ld.%d", intrpwork, (long)openart, getpid());
X 	UNLINK(artname);
X    }
X    close_server();
X#endif /* SERVER */
X    if (status < 0) {
X	chdir("/usr/tmp");
X	sigset(SIGILL,SIG_DFL);
X	abort();
X    }
X    exit(status);
X}
X
X/* come here on interrupt */
X
SIGRET
int_catcher()
X{
X    sigset(SIGINT,int_catcher);
X#ifdef DEBUGGING
X    if (debug)
X	write(2,"int_catcher\n",12);
X#endif
X    if (!waiting) {
X	if (int_count) {		/* was there already an interrupt? */
X	    write(2,"\nBye-bye.\n",10);
X	    sig_catcher(0);		/* emulate the other signals */
X	}
X	int_count++;
X    }
X}
X
X/* come here on signal other than interrupt, stop, or cont */
X
SIGRET
sig_catcher(signo)
int signo;
X{
X#ifdef VERBOSE
X    static char *signame[] = {
X	"",
X	"HUP",
X	"INT",
X	"QUIT",
X	"ILL",
X	"TRAP",
X	"IOT",
X	"EMT",
X	"FPE",
X	"KILL",
X	"BUS",
X	"SEGV",
X	"SYS",
X	"PIPE",
X	"ALRM",
X	"TERM",
X	"???"
X#ifdef SIGTSTP
X	,"STOP",
X	"TSTP",
X	"CONT",
X	"CHLD",
X	"TTIN",
X	"TTOU",
X	"TINT",
X	"XCPU",
X	"XFSZ"
X#ifdef SIGPROF
X	,"VTALARM",
X	"PROF"
X#endif
X#endif
X	};
X#endif
X
X#ifdef DEBUGGING
X    if (debug) {
X	printf("\nSIG%s--.newsrc not restored in debug\n",signame[signo]);
X	finalize(-1);
X    }
X#endif
X    if (panic)
X	abort();
X    (void) sigset(SIGILL,SIG_DFL);
X    panic = TRUE;			/* disable terminal I/O */
X    if (doing_ng) {			/* need we reconstitute rc line? */
X#ifdef DELAYMARK
X	yankback();
X#endif
X	restore_ng();			/* then do so (hope this works) */
X    }
X    doing_ng = FALSE;
X    if (rc_changed)			/* need we write .newsrc out? */
X	write_rc();			/* then do so */
X    rc_changed = FALSE;
X#ifdef SIGHUP
X    if (signo != SIGHUP)
X#endif
X#ifdef VERBOSE
X	IF(verbose)
X	    printf("\nCaught %s%s--.newsrc restored\n",
X		signo ? "a SIG" : "an internal error", signame[signo]);
X	ELSE
X#endif
X#ifdef TERSE
X	    printf("\nSignal %d--bye bye\n",signo);
X#endif
X    switch (signo) {
X#ifdef SIGBUS
X    case SIGBUS:
X#endif
X    case SIGILL:
X    case SIGSEGV:
X	finalize(-signo);
X    }
X    finalize(1);				/* and blow up */
X}
X
X#ifdef SIGTSTP
X/* come here on stop signal */
X
SIGRET
stop_catcher(signo)
int signo;
X{
X    if (!waiting) {
X	checkpoint_rc();	/* good chance of crash while stopped */
X	if (clear_on_stop) {
X	    clear();
X	    putchar('\n') FLUSH;
X	}
X	termlib_reset();
X	resetty();		/* this is the point of all this */
X#ifdef DEBUGGING
X	if (debug)
X	    write(2,"stop_catcher\n",13);
X#endif
X	sigset(signo,SIG_DFL);	/* enable stop */
X#ifdef SIGBLOCK
X	sigsetmask(sigblock(0) & ~(1 << (signo-1)));
X#endif
X	kill(0,signo);		/* and do the stop */
X    	savetty();
X#ifdef MAILCALL
X    	mailcount = 0;			/* force recheck */
X#endif
X    	if (!panic) {
X	    if (!waiting) {
X		termlib_init();
X	    	noecho();			/* set no echo */
X	    	crmode();			/* set cbreak mode */
X	    	forceme("\f");		/* cause a refresh */
X					/* (defined only if TIOCSTI defined) */
X		errno = 0;			/* needed for getcmd */
X	    }
X    	}
X    }
X    sigset(signo,stop_catcher);	/* unenable the stop */
X}
X#endif
END_OF_FILE
if test 5349 -ne `wc -c <'final.c'`; then
    echo shar: \"'final.c'\" unpacked with wrong size!
fi
# end of 'final.c'
fi
if test -f 'head.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'head.c'\"
else
echo shar: Extracting \"'head.c'\" \(8920 characters\)
sed "s/^X//" >'head.c' <<'END_OF_FILE'
X/* $Id: head.c,v 4.4 1991/09/09 20:18:23 sob Exp sob $
X *
X * $Log: head.c,v $
X * Revision 4.4  1991/09/09  20:18:23  sob
X * release 4.4
X *
X *
X * 
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "artio.h"
X#include "bits.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X#include "util.h"
X#include "INTERN.h"
X#include "head.h"
X
bool first_one;		/* is this the 1st occurance of this header line? */
X
static char htypeix[26] =
X    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
X
void
head_init()
X{
X    register int i;
X
X    for (i=HEAD_FIRST+1; i<HEAD_LAST; i++)
X	htypeix[*htype[i].ht_name - 'a'] = i;
X}
X
X#ifdef DEBUGGING
void
dumpheader(where)
char *where;
X{
X    register int i;
X
X    printf("header: %d %s", parsed_art, where);
X
X    for (i=0; i<HEAD_LAST; i++) {
X	printf("%15s %4d %4d %03o\n",htype[i].ht_name,
X	    htype[i].ht_minpos,
X	    htype[i].ht_maxpos,
X	    htype[i].ht_flags) FLUSH;
X    }
X}
X#endif
X
int
set_line_type(bufptr,colon)
char *bufptr;
register char *colon;
X{
X    char lc[LONGKEY+3];
X    register char *t, *f;
X    register int i, len;
X
X    if (colon-bufptr > LONGKEY+2)
X	return SOME_LINE;
X
X    for (t=lc,f=bufptr; f<colon; f++, t++) {
X	if (isspace(*f))
X	/* guard against space before : */
X	    break;
X	*t = isupper(*f) ? tolower(*f) : *f;
X    }
X    *t = '\0';
X    f = lc;				/* get lc into register */
X    len = t - f;
X
X    /* now scan the headtype table, backwards so we don't have to supply an
X     * extra terminating value, using first letter as index, and length as
X     * optimization to avoid calling subroutine strEQ unnecessarily.  Hauls.
X     */
X    
X    if (islower(*f)) {
X	for (i = htypeix[*f - 'a']; *htype[i].ht_name == *f; --i) {
X	    if (len == htype[i].ht_length && strEQ(f, htype[i].ht_name)) {
X		return i;
X	    }
X	}
X    }
X    return SOME_LINE;
X}
X
void
start_header(artnum)
ART_NUM artnum;
X{
X    register int i;
X
X#ifdef DEBUGGING
X    if (debug & 4)
X	dumpheader("start_header\n");
X#endif
X    for (i=0; i<HEAD_LAST; i++) {
X	htype[i].ht_minpos = -1;
X	htype[i].ht_maxpos = 0;
X    }
X    in_header = SOME_LINE;
X    first_one = FALSE;
X#ifdef ASYNC_PARSE
X    parsed_art = artnum;
X#endif
X}
X
bool
parseline(art_buf,newhide,oldhide)
char *art_buf;
int newhide, oldhide;
X{
X    if (*art_buf == ' ' || *art_buf == '\t')
X					/* header continuation line? */
X	return oldhide;
X    else {				/* maybe another header line */
X	char *s;
X
X	if (first_one) {		/* did we just pass 1st occurance? */
X	    first_one = FALSE;
X	    htype[in_header].ht_maxpos = artpos;
X					/* remember where line left off */
X	}
X	s = index(art_buf,':');
X	if (s == Nullch) {
X			    /* is it the end of the header? */
X	    htype[PAST_HEADER].ht_minpos =
X		(*art_buf == '\n') ? ftell(artfp) : artpos;
X			    /* remember where body starts */
X	    in_header = PAST_HEADER;
X	}
X	else {	/* it is a new header line */
X	    in_header = set_line_type(art_buf,s);
X	    first_one = (htype[in_header].ht_minpos < 0);
X	    if (first_one)
X		htype[in_header].ht_minpos = artpos;
X#ifdef DEBUGGING
X	    if (debug & 4)
X		dumpheader(art_buf);
X#endif
X	    if (htype[in_header].ht_flags & HT_HIDE)
X		return newhide;
X	}
X    }
X    return FALSE;			/* don't hide this line */
X}
X
X#ifdef ASYNC_PARSE
int
parse_maybe(artnum)
ART_NUM artnum;
X{
X    char tmpbuf[LBUFLEN];
X
X    if (parsed_art == artnum)
X	return 0;
X    /* no maybe about it now */
X#ifdef SERVER
X    if (nntpopen(artnum,GET_HEADER) == Nullfp) {
X#else
X    if (artopen(artnum) == Nullfp) {
X#endif
X	return -1;
X    }
X    start_header(artnum);
X    while (in_header) {
X	artpos = ftell(artfp);
X	if (fgets(tmpbuf,LBUFLEN,artfp) == Nullch)
X	    break;
X	parseline(tmpbuf,FALSE,FALSE);
X    }
X    in_header = PAST_HEADER;
X    return 0;
X}
X#endif
X
X/* get the subject line for an article */
X
char *
fetchsubj(artnum,current_subject,copy)
ART_NUM artnum;				/* article to get subject from */
bool_int current_subject;		/* is it in a parsed header? */
bool_int copy;				/* do you want it savestr()ed? */
X{
X    char *s = Nullch, *t;
X#ifdef SERVER
X    static int xhdr = 1;		/* Can we use xhdr command? */
X    int eoo;				/* End of server output */
X#endif /* SERVER */
X
X#ifdef CACHESUBJ
X    if (!subj_list) {
X	register ART_NUM i;
X	
X
X#ifndef lint
X	subj_list =
X	  (char**)safemalloc((MEM_SIZE)((OFFSET(lastart)+2)*sizeof(char *)));
X#endif /* lint */
X	for (i=0; i<=OFFSET(lastart); i++)
X	    subj_list[i] = Nullch;
X    }
X    if (!artnum || artnum > lastart)
X	s = nullstr;
X    else
X	s = subj_list[OFFSET(artnum)];
X#endif
X    if (s == Nullch) {
X	if (current_subject) {
X	    s = fetchlines(artnum,SUBJ_LINE);
X#ifdef CACHESUBJ
X	    subj_list[OFFSET(artnum)] = s;
X#endif
X	}
X	else {
X	    s = safemalloc((MEM_SIZE)LBUFLEN);
X	    *s = '\0';
X#ifdef SERVER
X	    if (xhdr) {
X	    	sprintf(ser_line, "XHDR subject %ld", artnum);
X	    	put_server(ser_line);
X#ifdef DEBUGGING
X		if (debug & DEB_NNTP)
X		    printf(">%s\n", ser_line) FLUSH;
X#endif
X		if (nntp_get(ser_line, sizeof (ser_line)) >= 0) {
X#ifdef DEBUGGING
X			if (debug & DEB_NNTP)
X			    printf("<%s\n", ser_line) FLUSH;
X#endif
X			if (ser_line[0] == CHAR_FATAL) {
X				fprintf(stderr,"\nrrn: %s\n",ser_line);
X				finalize(1);
X/*			    xhdr = 0; */
X			} else {
X			    while (nntp_get(ser_line, sizeof (ser_line)) >= 0) {
X#ifdef DEBUGGING
X				if (debug & DEB_NNTP)
X				    printf("<%s\n", ser_line) FLUSH;
X#endif
X				if (ser_line[0] == '.')
X				    break;
X				else {
X				    t = index(ser_line, ' ');
X				    if (t++) {
X					strcpy(s, t);
X					if (t = index(s, '\r'))
X						*t = '\0';
X				    }
X				}
X			    }
X			}
X		} else {
X		    fprintf(stderr,
X			"\nrrn: Unexpected close of server socket.\n");
X		    finalize(1);
X		}
X	    }
X
X	    if (!xhdr) {
X		sprintf(ser_line, "HEAD %ld", artnum);
X		put_server(ser_line);
X#ifdef DEBUGGING
X		if (debug & DEB_NNTP)
X		    printf(">%s\n", ser_line) FLUSH;
X#endif
X		eoo = 0;
X		if (nntp_get(ser_line, sizeof (ser_line)) >= 0 && 
X			ser_line[0] == CHAR_OK) {
X		    do {
X			if (nntp_get(s, LBUFLEN) < 0 || (*s == '.')) {
X			strcpy(s, "Title: \n");
X			eoo = 1;
X		        }
X		    } while (strnNE(s,"Title:",6) && strnNE(s,"Subject:",8));
X
X		    if (!eoo)
X			while (nntp_get(ser_line, sizeof (ser_line)) >= 0 &&
X				ser_line[0] != '.');
X		    t = index(s,':')+1;
X		    while (*t == ' ') t++;
X		    strcpy(s, t);
X	        }
X	    }
X#else /* not SERVER */
X	    if (artopen(artnum) != Nullfp) {
X		do {
X		    if (fgets(s,LBUFLEN,artfp) == Nullch)
X			strcpy(s, "Title: \n");
X		} while (strnNE(s,"Title:",6) && strnNE(s,"Subject:",8));
X
X		s[strlen(s)-1] = '\0';
X		t = index(s,':')+1;
X		while (*t == ' ') t++;
X		strcpy(s, t);
X	    }
X#endif
X	    s = saferealloc(s, (MEM_SIZE)strlen(s)+1);
X#ifdef CACHESUBJ
X	    subj_list[OFFSET(artnum)] = s;
X#endif 
X	}
X    }
X#ifdef CACHESUBJ
X    if (copy) {
X	t = savestr(s);
X	return t;
X    }
X    else
X	return s;
X#else
X    if (copy)
X	return s;
X    else {
X	safecpy(cmd_buf,s,CBUFLEN);	/* hope this is okay--we're */
X	free(s);
X	return cmd_buf;			/* really scraping for space here */
X    }
X#endif
X}
X
X/* get header lines from an article */
X
char *
fetchlines(artnum,which_line)
ART_NUM artnum;				/* article to get line from */
int which_line;				/* type of line desired */
X{
X    char *newbuf, *t, tmp_buf[LBUFLEN];
X    register ART_POS curpos;
X    int size;
X    register ART_POS firstpos;
X    register ART_POS lastpos;
X    
X#ifdef ASYNC_PARSE
X    if (parse_maybe(artnum))
X	artnum = 0;
X#endif
X    firstpos = htype[which_line].ht_minpos;
X    lastpos = htype[which_line].ht_maxpos;
X#ifdef SERVER
X    if (!artnum || firstpos < 0 || nntpopen(artnum,GET_HEADER) == Nullfp) {
X#else
X    if (!artnum || firstpos < 0 || artopen(artnum) == Nullfp) {
X#endif
X	newbuf = safemalloc((unsigned int)1);
X	*newbuf = '\0';
X	return newbuf;
X    }
X#ifndef lint
X    size = lastpos - firstpos + 1;
X#else
X    size = Null(int);
X#endif /* lint */
X#ifdef DEBUGGING
X    if (debug && (size < 1 || size > 1000)) {
X	printf("Firstpos = %ld, lastpos = %ld\n",(long)firstpos,(long)lastpos);
X	gets(tmp_buf);
X    }
X#endif
X    newbuf = safemalloc((unsigned int)size);
X    *newbuf = '\0';
X    fseek(artfp,firstpos,0);
X    for (curpos = firstpos; curpos < lastpos; curpos = ftell(artfp)) {
X	if (fgets(tmp_buf,LBUFLEN,artfp) == Nullch)
X	    break;
X	if (*tmp_buf == ' ' || *tmp_buf == '\t')
X	    t = tmp_buf;
X	else {
X	    t = index(tmp_buf,':');
X	    if (t == Nullch)
X		break;
X	    t++;
X	}
X	while (*t == ' ' || *t == '\t') t++;
X	safecat(newbuf,t,size);
X    }
X    return newbuf;
X}
X
END_OF_FILE
if test 8920 -ne `wc -c <'head.c'`; then
    echo shar: \"'head.c'\" unpacked with wrong size!
fi
# end of 'head.c'
fi
if test -f 'init.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'init.c'\"
else
echo shar: Extracting \"'init.c'\" \(6682 characters\)
sed "s/^X//" >'init.c' <<'END_OF_FILE'
X/* $Id: init.c,v 4.4 1991/09/09 20:18:23 sob Exp sob $
X *
X * $Log: init.c,v $
X * Revision 4.4  1991/09/09  20:18:23  sob
X * release 4.4
X *
X *
X * 
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "final.h"
X#include "term.h"
X#include "last.h"
X#include "rn.h"
X#include "rcstuff.h"
X#include "ngdata.h"
X#include "only.h"
X#include "intrp.h"
X#include "addng.h"
X#include "sw.h"
X#include "art.h"
X#include "artsrch.h"
X#include "artio.h"
X#include "backpage.h"
X#include "bits.h"
X#include "cheat.h"
X#include "head.h"
X#include "help.h"
X#include "kfile.h"
X#include "ngsrch.h"
X#include "ngstuff.h"
X#include "rcln.h"
X#include "respond.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X#ifdef USETHREADS
X#include "threads.h"
X#include "rthreads.h"
X#endif
X#include "ng.h"
X#include "decode.h"
X#include "INTERN.h"
X#include "init.h"
X
bool
initialize(argc,argv)
int argc;
char *argv[];
X{
X    char *tcbuf;
X    register bool foundany = FALSE;
X    long time();
X#ifdef SERVER
X    char *server;
X    int response;
X#endif
X#ifdef NOLINEBUF
X    static char std_out_buf[BUFSIZ];	/* must be static or malloced */
X
X    setbuf(stdout, std_out_buf);
X#endif
X
X    tcbuf = safemalloc(1024);		/* make temp buffer for termcap and */
X					/* other initialization stuff */
X    
X    /* init terminal */
X    
X    term_init();			/* must precede sw_init() so that */
X					/* ospeed is set for baud-rate */
X					/* switches.  Actually terminal */
X					/* mode setting is in term_set() */
X
X    /* we have to know rnlib to look up global switches in %X/INIT */
X
X    lib = savestr(filexp(LIB));
X    rnlib = savestr(filexp(RNLIB));
X
X    /* decode switches */
X
X    sw_init(argc,argv,&tcbuf);          /* must not do % interps! */
X					/* (but may mung environment) */
X
X    /* init signals, status flags */
X
X    final_init();
X    
X    /* start up file expansion and the % interpreter */
X
X    intrp_init(tcbuf);
X    
X    /* now make sure we have a current working directory */
X
X    if (!checkflag)
X	cwd_check();
X    
X    /* now that we know where to save things, cd to news directory */
X
X    if (chdir(spool)) {
X	printf(nocd,spool) FLUSH;
X	finalize(1);
X    }
X
X    /* if we aren't just checking, turn off echo */
X
X    if (!checkflag)
X	term_set(tcbuf);
X
X    /* get info on last rn run, if any */
X
X    if (!checkflag)
X	last_init(tcbuf);
X
X    free(tcbuf);			/* recover 1024 bytes */
X
X    /* make sure we are the sole possessors of .newsrc */
X
X    if (!checkflag)
X	lock_check();
X
X    /* check for news news */
X
X    if (!checkflag)
X	newsnews_check();
X
X#ifdef SERVER
X
X    /* open connection to server if appropriate */
X
X    if ((server = get_server_name(1)) == NULL)
X	finalize(1);
X
X    response = server_init(server);
X    if (response < 0) {
X	fprintf(stderr,
X	    "Couldn't connect to %s news server, try again later.\n",
X		server);
X	finalize(1);
X    }
X
X    if (handle_server_response(response, server) < 0)
X	finalize(1);
X
X#endif
X
X    /* open active file, etc. */
X
X    ngdata_init();
X
X    /* now read in the .newsrc file */
X
X    foundany = rcstuff_init();
X
X    /* it looks like we will actually read something, so init everything */
X
X    addng_init();
X    art_init();
X    artio_init();
X    artsrch_init();
X    backpage_init();
X    bits_init();
X    cheat_init();
X    head_init();
X    help_init();
X    kfile_init();
X    ng_init();
X    ngsrch_init();
X    ngstuff_init();
X    only_init();
X    rcln_init();
X    respond_init();
X    rn_init();
X    search_init();
X    decode_init();
X#ifdef USETHREADS
X    thread_init();
X#endif
X    util_init();
X
X#ifdef FINDNEWNG
X	/*
X	 * Skip this check if the -q flag was given.
X	 */
X    if (!quickstart) {
X	if (find_new_groups()) {	/* did we add any new groups? */
X	    foundany = TRUE;		/* let main() know */
X	    starthere = 0;		/* start ng scan from the top */
X	}
X    }
X#endif
X    time(&lasttime);			/* remember when we inited-- */
X					/* ends up back in .rnlast */
X    writelast();			/* in fact, put it there now */
X
X#ifdef FINDNEWNG
X# ifdef ONLY
X    if (maxngtodo)			/* patterns on command line? */
X	foundany |= scanactive();
X# endif
X#endif
X
X    return foundany;
X}
X
X/* make sure there is no rn out there already */
X
void
lock_check()
X{
X    lockname = savestr(filexp(LOCKNAME));
X    if (!checkflag) {
X	tmpfp = fopen(lockname,"r");
X	if (tmpfp != Nullfp) {
X	    int processnum;
X    
X	    fgets(buf,LBUFLEN,tmpfp);
X	    fclose(tmpfp);
X	    processnum = atoi(buf);
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("You seem to have left a trn running, process %d.\n",
X		    processnum) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		printf("Trn left running, #%d.\n", processnum) FLUSH;
X#endif
X	    if (kill(processnum, SIGEMT)) {
X				    /* does process not exist? */
X				    /* (rn ignores SIGEMT) */
X		sleep(2);
X#ifdef VERBOSE
X		IF(verbose)
X		    fputs("\n\
That process does not seem to exist anymore.  The count of read articles\n\
may be incorrect in the last newsgroup accessed by that other (defunct)\n\
process.\n\n",stdout) FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    fputs("\nProcess crashed.\n",stdout) FLUSH;
X#endif
X		if (*lastngname) {
X#ifdef VERBOSE
X		    IF(verbose)
X			printf("(The last newsgroup accessed was %s.)\n\n",
X			lastngname) FLUSH;
X		    ELSE
X#endif
X#ifdef TERSE
X			printf("(In %s.)\n\n",lastngname) FLUSH;
X#endif
X		}
X		get_anything();
X		putchar('\n') FLUSH;
X	    }
X	    else {
X#ifdef VERBOSE
X		IF(verbose)
X		    fputs("\n\
You may not have two copies of [t]rn running simultaneously.  Goodbye.\n\
X",stdout) FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    fputs("\nCan't start another.\n",stdout) FLUSH;
X#endif
X               if (bizarre)
X                 resetty();
X		exit(0);
X	    }
X	}
X	tmpfp = fopen(lockname,"w");
X	if (tmpfp == Nullfp) {
X	    printf(cantcreate,lockname) FLUSH;
X	    sig_catcher(0);
X	}
X	fprintf(tmpfp,"%d\n",getpid());
X	fclose(tmpfp);
X    }
X}
X
void
newsnews_check()
X{
X    char *newsnewsname = filexp(NEWSNEWSNAME);
X
X    if ((tmpfp = fopen(newsnewsname,"r")) != Nullfp) {
X	fstat(fileno(tmpfp),&filestat);
X	if (filestat.st_mtime > lasttime) {
X	    while (fgets(buf,sizeof(buf),tmpfp) != Nullch)
X		fputs(buf,stdout) FLUSH;
X	    get_anything();
X	    putchar('\n') FLUSH;
X	}
X	fclose(tmpfp);
X    }
X}
END_OF_FILE
if test 6682 -ne `wc -c <'init.c'`; then
    echo shar: \"'init.c'\" unpacked with wrong size!
fi
# end of 'init.c'
fi
if test -f 'kfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kfile.c'\"
else
echo shar: Extracting \"'kfile.c'\" \(7380 characters\)
sed "s/^X//" >'kfile.c' <<'END_OF_FILE'
X/* $Id: kfile.c,v 4.4 1991/09/09 20:18:23 sob Exp sob $
X *
X * $Log: kfile.c,v $
X * Revision 4.4  1991/09/09  20:18:23  sob
X * release 4.4
X *
X *
X * 
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "term.h"
X#include "util.h"
X#include "artsrch.h"
X#include "ng.h"
X#include "bits.h"
X#include "intrp.h"
X#include "ngstuff.h"
X#include "rcstuff.h"
X#include "rn.h"
X#ifdef USETHREADS
X#include "threads.h"
X#include "rthreads.h"
X#endif
X#include "INTERN.h"
X#include "kfile.h"
X
static bool exitcmds = FALSE;
X
void
kfile_init()
X{
X    ;
X}
X
X#ifndef KILLFILES
int
edit_kfile()
X{
X    notincl("^K");
X    return -1;
X}
X
X#else /* KILLFILES */
X
char killglobal[] = KILLGLOBAL;
char killlocal[] = KILLLOCAL;
X
void
mention(str)
char *str;
X{
X#ifdef VERBOSE
X    IF(verbose) {
X#ifdef NOFIREWORKS
X	no_sofire();
X#endif
X	standout();
X	fputs(str,stdout);
X	un_standout();
X	putchar('\n');
X    }
X    ELSE
X#endif
X#ifdef TERSE
X	putchar('.');
X#endif
X    fflush(stdout);
X}
X
bool kill_mentioned;
X
int
do_kfile(kfp,entering)
XFILE *kfp;
int entering;
X{
X#ifdef USETHREADS
X    int i;
X    ART_NUM kill_thread;
X#endif
X
X    art = lastart+1;
X    fseek(kfp,0L,0);			/* rewind file */
X    while (fgets(buf,LBUFLEN,kfp) != Nullch) {
X	buf[strlen(buf)-1] = '\0';
X	if (strnEQ(buf,"THRU",4)) {
X	    ART_NUM tmpart;
X
X	    tmpart = atol(buf+4)+1;
X	    if (tmpart < absfirst)
X		tmpart = absfirst;
X	    check_first(tmpart);
X	    firstart = tmpart;
X	    continue;
X	}
X	if (*buf == 'X') {		/* exit command? */
X	    if (entering) {
X		exitcmds = TRUE;
X		continue;
X	    }
X	    strcpy(buf,buf+1);
X	}
X	else {
X	    if (!entering)
X		continue;
X	}
X	if (*buf == '&') {
X	    mention(buf);
X	    switcheroo();
X	}
X	else if (*buf == '/' && firstart <= lastart) {
X	    mention(buf);
X	    kill_mentioned = TRUE;
X	    switch (art_search(buf, (sizeof buf), FALSE)) {
X	    case SRCH_ABORT:
X		continue;
X	    case SRCH_INTR:
X#ifdef VERBOSE
X		IF(verbose)
X		    printf("\n(Interrupted at article %ld)\n",(long)art)
X		      FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    printf("\n(Intr at %ld)\n",(long)art) FLUSH;
X#endif
X		return -1;
X	    case SRCH_DONE:
X		break;
X	    case SRCH_SUBJDONE:
X		fputs("\tsubject not found (???)\n",stdout) FLUSH;
X		break;
X	    case SRCH_NOTFOUND:
X		fputs("\tnot found\n",stdout) FLUSH;
X		break;
X	    case SRCH_FOUND:
X		fputs("\tfound\n",stdout) FLUSH;
X	    }
X	}
X#ifdef USETHREADS
X	else if (*buf == 'T' && firstart <= lastart && p_roots) {
X	    /* kill a thread by its root id number */
X	    kill_thread = atol(buf+1);
X	    for (i = 0; i < total.root; i++) {
X		if (p_roots[i].root_num == kill_thread) {
X		    if (count_one_root(i) != 0) {
X			mention(buf);
X			kill_mentioned = TRUE;
X			printf("%ldx%d ",(long)kill_thread,
X					 root_article_cnts[i]);
X#ifdef VERBOSE
X			IF(verbose)
X			    putchar('\n') FLUSH;
X#endif
X			p_art = p_articles + p_roots[i].articles;
X			art = p_art->num;
X			follow_thread('J');
X		    }
X		    break;
X		}
X	    }
X	}
X#endif
X    }
X
X    return 0;
X}
X
void
kill_unwanted(starting,message,entering)
ART_NUM starting;
char *message;
int entering;
X{
X    bool intr = FALSE;			/* did we get an interrupt? */
X    ART_NUM oldfirst;
X    bool anytokill = (toread[ng] > 0);
X
X    if (localkfp || globkfp) {
X	if (!entering && !exitcmds)
X	    return;
X	exitcmds = FALSE;
X	oldfirst = firstart;
X	firstart = starting;
X	clear();
X#ifdef VERBOSE
X# ifdef TERSE
X	if (message && (verbose || entering))
X# else
X	if (message)
X# endif
X#else
X	if (message && entering)
X#endif
X	    fputs(message,stdout) FLUSH;
X
X	kill_mentioned = FALSE;
X	if (localkfp)
X	    intr = do_kfile(localkfp,entering);
X	if (globkfp && !intr)
X	    intr = do_kfile(globkfp,entering);
X	if (entering && localkfp && !intr)
X	    setthru(lastart);
X	putchar('\n') FLUSH;
X	if (entering && kill_mentioned)
X#ifdef VERBOSE
X	    IF(verbose)
X		get_anything();
X	    ELSE
X#endif
X#ifdef TERSE
X		pad(just_a_sec);
X#endif
X	if (anytokill)			/* if there was anything to kill */
X	    forcelast = FALSE;		/* allow for having killed it all */
X	firstart = oldfirst;
X    }
X}
X
void
setthru(thru)
ART_NUM thru;
X{
X    FILE *newkfp;
X    bool no_kills = 0;
X#ifdef USETHREADS
X    int i;
X    ART_NUM kill_thread;
X#endif
X
X    fseek(localkfp,0L,0);		/* rewind current file */
X    if (fgets(buf,LBUFLEN,localkfp) != Nullch
X     && (strnNE(buf,"THRU",4) || fgets(buf,LBUFLEN,localkfp) != Nullch))
X	fseek(localkfp,0L,0);
X    else
X	no_kills = 1;
X    strcpy(buf,filexp(getval("KILLLOCAL",killlocal)));
X    UNLINK(buf);			/* to prevent file reuse */
X    if (no_kills)
X	open_kfile(KF_LOCAL);		/* close file and reset open flag */
X    else if (newkfp = fopen(buf,"w")) {
X	fprintf(newkfp,"THRU %ld\n",(long)thru);
X	while (fgets(buf,LBUFLEN,localkfp) != Nullch) {
X	    if (strnEQ(buf,"THRU",4))
X		continue;
X#ifdef USETHREADS
X	    /* Leave out any outdated thread kills */
X	    if (*buf == 'T' && p_roots) {
X		kill_thread = atol(buf+1);
X		for (i = 0; i < total.root; i++) {
X		    if (p_roots[i].root_num == kill_thread) {
X			break;
X		    }
X		}
X		if (i == total.root)
X		    continue;
X	    }
X#endif
X	    fputs(buf,newkfp);
X	}
X	fclose(newkfp);
X	open_kfile(KF_LOCAL);		/* and reopen local file */
X    }
X    else
X	printf(cantcreate,buf) FLUSH;
X}
X
X/* edit KILL file for newsgroup */
X
int
edit_kfile()
X{
X    int r = -1;
X
X    if (in_ng)
X	strcpy(buf,filexp(getval("KILLLOCAL",killlocal)));
X    else
X	strcpy(buf,filexp(getval("KILLGLOBAL",killglobal)));
X    if ((r = makedir(buf,MD_FILE)) >= 0) {
X	sprintf(cmd_buf,"%s %s",
X	    filexp(getval("VISUAL",getval("EDITOR",defeditor))),buf);
X	printf("\nEditing %s KILL file:\n%s\n",
X	    (in_ng?"local":"global"),cmd_buf) FLUSH;
X	resetty();			/* make sure tty is friendly */
X	r = doshell(sh,cmd_buf);/* invoke the shell */
X	noecho();			/* and make terminal */
X	crmode();			/*   unfriendly again */
X	open_kfile(in_ng);
X    }
X    else
X	printf("Can't make %s\n",buf) FLUSH;
X    return r;
X}
X
void
open_kfile(local)
int local;
X{
X    char *kname = filexp(local ?
X	getval("KILLLOCAL",killlocal) :
X	getval("KILLGLOBAL",killglobal)
X	);
X    
X    stat(kname,&filestat);
X    if (!filestat.st_size)		/* nothing in the file? */
X	UNLINK(kname);			/* delete the file */
X    if (local) {
X	if (localkfp)
X	    fclose(localkfp);
X	localkfp = fopen(kname,"r");
X    }
X    else {
X	if (globkfp)
X	    fclose(globkfp);
X	globkfp = fopen(kname,"r");
X    }
X}
X
void
kf_append(cmd)
char *cmd;
X{
X    strcpy(cmd_buf,filexp(getval("KILLLOCAL",killlocal)));
X    if (makedir(cmd_buf,MD_FILE) >= 0) {
X#ifdef VERBOSE
X	IF(verbose)
X	    printf("\nDepositing command in %s...",cmd_buf);
X	ELSE
X#endif
X#ifdef TERSE
X	    printf("\n--> %s...",cmd_buf);
X#endif
X	fflush(stdout);
X	sleep(2);
X	if ((tmpfp = fopen(cmd_buf,"a")) != Nullfp) {
X	    fseek(tmpfp,0L,2);		/* get to EOF for sure */
X	    fprintf(tmpfp,"%s\n",cmd);
X	    fclose(tmpfp);
X	    fputs("done\n",stdout) FLUSH;
X	}
X	else
X	    printf(cantopen,cmd_buf) FLUSH;
X    }
X}
X#endif /* KILLFILES */
END_OF_FILE
if test 7380 -ne `wc -c <'kfile.c'`; then
    echo shar: \"'kfile.c'\" unpacked with wrong size!
fi
# end of 'kfile.c'
fi
if test -f 'ngdata.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ngdata.c'\"
else
echo shar: Extracting \"'ngdata.c'\" \(8738 characters\)
sed "s/^X//" >'ngdata.c' <<'END_OF_FILE'
X/* $Id: ngdata.c,v 4.4.2.1 1991/12/01 18:05:42 sob PATCH_2 sob $
X *
X * $Log: ngdata.c,v $
X * Revision 4.4.2.1  1991/12/01  18:05:42  sob
X * Patchlevel 2 changes
X *
X * Revision 4.4.1.1  1991/09/25  19:38:08  sob
X * Some adaptions for CNEWS
X *
X * Revision 4.4  1991/09/09  20:23:31  sob
X * release 4.4
X *
X *
X * 
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "ndir.h"
X#include "rcstuff.h"
X#include "rn.h"
X#include "intrp.h"
X#include "final.h"
X#include "rcln.h"
X#include "util.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X#include "INTERN.h"
X#include "ngdata.h"
X
void
ngdata_init()
X{
X    char *cp;
X
X    /* open the active file */
X
X#ifdef SERVER
X    put_server("LIST");		/* tell server we want the active file */
X    nntp_get(ser_line, sizeof(ser_line));
X    if (*ser_line != CHAR_OK) {		/* and then see if that's ok */
X	fprintf(stdout, "Can't get active file from server: \n%s\n", ser_line);
X	finalize(1);
X    }
X
X    cp = filexp("%P/rrnact.%$");	/* make a temporary name */
X    strcpy(active_name, cp);
X    actfp = fopen(active_name, "w+");	/* and get ready */
X    if (actfp == Nullfp) {
X	printf(cantopen,active_name) FLUSH;
X	finalize(1);
X    }
X
X    activeitems = 0;
X    while (1) {
X	if (nntp_get(ser_line, sizeof(ser_line)) < 0) {
X	    printf("Can't get active file from server:\ntransfer failed after %d entries\n", activeitems);
X	    finalize(1);
X	}
X	if (ser_line[0] == '.')		/* while there's another line */
X		break;			/* get it and write it to */
X	activeitems++;
X	fputs(ser_line, actfp);
X	putc('\n', actfp);
X    }
X
X    if (ferror(actfp)) {
X	printf("Error writing to active file %s.\n", active_name) FLUSH;
X	finalize(1);
X    }
X#else /* not SERVER */
X
X    cp = filexp(ACTIVE);
X    actfp = fopen(cp,"r");
X    if (actfp == Nullfp) {
X	printf(cantopen,cp) FLUSH;
X	finalize(1);
X    }
X    activeitems = 0;
X    /* count entries */
X    while(fgets(buf,LBUFLEN,actfp) != NULL)
X	activeitems++;
X#endif
X    if (fseek(actfp,0L,0) == -1) {	/* just get to the beginning */
X	printf("Error seeking in active file.\n") FLUSH;
X	finalize(1);
X    }
X
X    return;
X}
X
X/* find the maximum article number of a newsgroup */
X
ART_NUM
getngsize(num)
register NG_NUM num;
X{
X    register int len;
X    register char *nam;
X    char tmpbuf[80];
X    ART_POS oldsoft;
X
X    nam = rcline[num];
X    len = rcnums[num] - 1;
X    softtries++;
X#ifdef DEBUGGING
X    if (debug & DEB_SOFT_POINTERS)
X	printf("Softptr = %ld\n",(long)softptr[num]) FLUSH;
X#endif
X    oldsoft = softptr[num];
X    if ((softptr[num] = findact(tmpbuf, nam, len, (long)oldsoft)) >= 0) {
X	if (softptr[num] != oldsoft) {
X	    softmisses++;
X	    writesoft = TRUE;
X	}
X    }
X    else {
X	softptr[num] = 0;
X#ifdef USETHREADS
X	if (RCCHAR(rcchar[num]) == ':')
X#else
X	if (rcchar[num] == ':')		/* unsubscribe quietly */
X#endif
X	    rcchar[num] = NEGCHAR;
X	return TR_BOGUS;		/* well, not so quietly, actually */
X    }
X	
X#ifdef DEBUGGING
X    if (debug & DEB_SOFT_POINTERS) {
X	printf("Should be %ld\n",(long)softptr[num]) FLUSH;
X    }
X#endif
X    {
X	register char *s;
X	ART_NUM tmp;
X
X	for (s=tmpbuf+len+1; isdigit(*s); s++) ;
X	if (tmp = atol(s))
X#ifdef MININACT
X#ifdef CACHEFIRST
X	    abs1st[num] = tmp;
X#else
X	    abs1st = tmp;
X#endif
X#endif
X	if (!in_ng) {
X	    for (s++; isdigit(*s); s++) ;
X	    while (isspace(*s)) s++;
X	    switch (*s) {
X	    case 'n': moderated = getval("NOPOSTRING"," (no posting)"); break;
X	    case 'm': moderated = getval("MODSTRING", " (moderated)"); break;
X	    /* This shouldn't even occur.  What are we doing in a non-existent
X	       group?  Disallow it. */
X	    case 'x': return TR_BOGUS;
X	    /* what should be done about refiled groups?  rn shouldn't even
X	       be in them (ie, if sci.aquaria is refiled to rec.aquaria, then
X	       get the news there) */
X	    case '=': return TR_BOGUS;
X	    default: moderated = nullstr;
X	    }
X	}
X    }
X#ifdef USETHREADS
X    {
X	ART_NUM last;
X
X	last = atol(tmpbuf+len+1);
X	return last >= ngmax[num] ? last : ngmax[num];
X    }
X#else
X    return atol(tmpbuf+len+1);
X#endif
X}
X
ACT_POS
findact(outbuf,nam,len,suggestion)
char *outbuf;
char *nam;
int len;
long suggestion;
X{
X    ACT_POS retval;
X
X    fseek(actfp,100000L,1);	/* hopefully this forces a reread */
X    if (suggestion == 0L || fseek(actfp,suggestion,0) < 0 ||
X      fgets(outbuf,80,actfp) == Nullch ||
X      outbuf[len] != ' ' ||
X      strnNE(outbuf,nam,len)) {
X#ifdef DEBUGGING
X	if (debug & DEB_SOFT_POINTERS)
X	    printf("Missed, looking for %s in %sLen = %d\n",nam,outbuf,len)
X	      FLUSH;
X#endif
X	fseek(actfp,0L,0);
X#ifndef lint
X	retval = (ACT_POS)ftell(actfp);
X#else
X	retval = Null(ACT_POS);
X#endif /* lint */
X	while (fgets(outbuf,80,actfp) != Nullch) {
X	    if (outbuf[len] == ' ' && strnEQ(outbuf,nam,len))
X		return retval;
X#ifndef lint
X	    retval = (ACT_POS) ftell(actfp);
X#endif /* lint */
X	    if (ferror(actfp)) {
X		perror("error on active file"); /* something is wrong */
X		sig_catcher(0);
X	    }
X	}
X	if(ferror(actfp)) {
X	    perror("error on active file");
X	    sig_catcher(0);
X	}
X	return (ACT_POS) -1;
X    }
X    else
X#ifndef lint
X	return (ACT_POS) suggestion;
X#else
X	return retval;
X#endif /* lint */
X    /*NOTREACHED*/
X}
X
X/* determine the absolutely first existing article number */
X#ifdef SERVER
ART_NUM
getabsfirst(ngnum,ngsize)
register NG_NUM ngnum;
ART_NUM ngsize;
X{
X    ART_NUM a1st;
X
X#ifdef CACHEFIRST
X    if (a1st = abs1st[ngnum])
X	return a1st;
X#endif
X#ifdef MININACT
X    getngsize(ngnum);
X# ifdef CACHEFIRST
X    return abs1st[ngnum];
X# else
X    return abs1st;
X# endif
X#else
X    getngsize(ngnum); /* set moderated as side effect */
X    sprintf(ser_line,"GROUP %s",rcline[ngnum]);
X    put_server(ser_line);
X    if (nntp_get(ser_line, sizeof(ser_line)) < 0) {
X	fprintf(stderr, "\nrrn: Unexpected close of server socket.\n");
X	finalize(1);
X    }
X    if (*ser_line == CHAR_FATAL){
X	fprintf(stderr,"\nrrn: %s\n",ser_line);
X	finalize(1);
X    }
X    if (*ser_line != CHAR_OK) {		/* and then see if that's ok */
X	a1st = ngsize+1;		/* nothing there */
X    }
X    (void) sscanf(ser_line,"%*d%*d%d",&a1st);
X# ifdef CACHEFIRST
X    abs1st[ngnum] = a1st;
X# endif
X    return a1st;
X#endif
X}
X/* we already know the lowest article number with NNTP */
ART_NUM
getngmin(dirname,floor)
char *dirname;
ART_NUM floor;
X{
X    return(floor);		/* dirname not used */
X}
X
X#else /*SERVER*/
X
ART_NUM
getabsfirst(ngnum,ngsize)
register NG_NUM ngnum;
ART_NUM ngsize;
X{
X    register ART_NUM a1st;
X#ifndef MININACT
X    char dirname[MAXFILENAME];
X#endif
X
X#ifdef CACHEFIRST
X    if (a1st = abs1st[ngnum])
X	return a1st;
X#endif
X#ifdef MININACT
X    getngsize(ngnum);
X# ifdef CACHEFIRST
X    return abs1st[ngnum];
X# else
X    return abs1st;
X# endif
X#else /* not MININACT */
X    getngsize(ngnum); /* set moderate as side effect */
X    sprintf(dirname,"%s/%s",spool,getngdir(rcline[ngnum]));
X    a1st = getngmin(dirname,0L);
X    if (!a1st)				/* nothing there at all? */
X	a1st = ngsize+1;		/* aim them at end of newsgroup */
X# ifdef CACHEFIRST
X    abs1st[ngnum] = a1st;
X# endif
X    return a1st;
X#endif /* MININACT */
X}
X
X/* scan a directory for minimum article number greater than floor */
X
ART_NUM
getngmin(dirname,floor)
char *dirname;
ART_NUM floor;
X{
X    register DIR *dirp;
X    register struct DIRTYPE *dp;
X    register ART_NUM min = 1000000;
X    register ART_NUM maybe;
X    register char *p;
X#ifdef notdef
X    char tmpbuf[128];
X#endif
X    
X    dirp = opendir(dirname);
X    if (!dirp)
X	return 0;
X    while ((dp = readdir(dirp)) != Null(struct DIRTYPE *)) {
X	if ((maybe = atol(dp->d_name)) < min && maybe > floor) {
X	    for (p = dp->d_name; *p; p++)
X		if (!isdigit(*p))
X		    goto nope;
X#ifdef notdef
X	   /* 
X	    * If newsgroup names ever go entirely numeric, then
X	    * this code will have to be reinserted.
X	    * For the time being, we assume that if a numeric name is
X	    * found, it must be an article (and not a directory).
X	    * This will avoid two stat(2) calls for those running
X	    * rn.
X	    */
X	    if (*dirname == '.' && !dirname[1])
X		stat(dp->d_name, &filestat);
X	    else {
X		sprintf(tmpbuf,"%s/%s",dirname,dp->d_name);
X		stat(tmpbuf, &filestat);
X	    }
X	    if (! (filestat.st_mode & S_IFDIR))
X#endif
X		min = maybe;
X	}
X      nope:
X	;
X    }
X    closedir(dirp);
X    return min==1000000 ? 0 : min;
X}
X#endif
END_OF_FILE
if test 8738 -ne `wc -c <'ngdata.c'`; then
    echo shar: \"'ngdata.c'\" unpacked with wrong size!
fi
# end of 'ngdata.c'
fi
if test -f 'tmpthread.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tmpthread.c'\"
else
echo shar: Extracting \"'tmpthread.c'\" \(6070 characters\)
sed "s/^X//" >'tmpthread.c' <<'END_OF_FILE'
X/* $Id: tmpthread.c,v 4.4.3.1 1991/11/22 04:12:21 davison Trn $
X**
X** $Log: tmpthread.c,v $
X** Revision 4.4.3.1  1991/11/22  04:12:21  davison
X** Trn Release 2.0
X** 
X*/
X
X/* tmpthread.c -- for creating a temporary discussion-thread file
X**
X** Usage:  tmpthread [opts] news.group last# first# addmax# /tmp/filename
X*/
X
X#include "EXTERN.h"
X#include "common.h"
X#include "threads.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X#include "INTERN.h"
X#define TMPTHREAD
X#include "mthreads.h"
X
X#ifdef TZSET
X#include <time.h>
X#else
X#include <sys/time.h>
X#include <sys/timeb.h>
X#endif
X
struct stat filestat;
X
char buf[LBUFLEN+1];
char *filename, *group, *tmpname;
X
int first, last, max, start;
int log_verbosity = 0, debug = 0, slow_down = 0;
int ignore_database = 0, read_from_tmp = 0;
X
char nullstr[1] = "";
X
X#ifdef XTHREAD
int size;
X#else
XFILE *fp;
X#endif
X
X#ifdef TZSET
time_t tnow;
X#else
struct timeb ftnow;
X#endif
X
X#ifdef SERVER
char *server;
X#endif
X
SIGRET int_handler();
X
int
main(argc, argv)
int  argc;
char *argv[];
X{
X    char *cp;
X
X    while (--argc) {
X	if (**++argv == '-') {
X	    while (*++*argv) {
X		switch (**argv) {
X		case 'D':
X		    debug++;
X		    break;
X		case 'i':
X		    ignore_database++;
X		    break;
X		case 's':
X		    if (*++*argv <= '9' && **argv >= '0') {
X			slow_down = atoi(*argv);
X			while (*++*argv <= '9' && **argv >= '0') {
X			    ;
X			}
X		    } else {
X			slow_down = 1L * 1000 * 1000;
X		    }
X		    --*argv;
X		    break;
X		case 't':	/* Use tmpfile w/no byte-order changes */
X		    read_from_tmp = 1;
X		    break;
X		case 'T':	/* Use tmpfile w/possible byte-order changes */
X		    read_from_tmp = 2;
X		    break;
X		case 'v':
X		    log_verbosity++;
X		    break;
X		default:
X		    fprintf(stderr, "Unknown option: '%c'\n", **argv);
X		    exit(1);
X		}
X	    }
X	} else {
X	    break;
X	}
X    }
X
X    if (argc < 5) {
X      give_usage:
X	fprintf(stderr,
X"Usage:  tmpthread [opts] news.group last# first# addmax# /tmp/filename\n");
X	exit(1);
X    }
X
X    group = argv[0];
X    last = atoi(argv[1]);
X    first = atoi(argv[2]);
X    max = atoi(argv[3]);
X    tmpname = argv[4];
X
X    if (first < 0 || last < first - 1 || max <= 0) {
X	goto give_usage;
X    }
X
X    /* Initialize umask(), file_exp(), etc. */
X    mt_init();
X
X#ifdef SIGHUP
X    if (sigset(SIGHUP, SIG_IGN) != SIG_IGN) {
X	sigset(SIGHUP, int_handler);
X    }
X#endif
X    if (sigset(SIGINT, SIG_IGN) != SIG_IGN) {
X	sigset(SIGINT, int_handler);
X    }
X#ifdef SIGQUIT
X    if (sigset(SIGQUIT, SIG_IGN) != SIG_IGN) {
X	sigset(SIGQUIT, int_handler);
X    }
X#endif
X    sigset(SIGTERM, int_handler);
X#ifdef SIGBUS
X    sigset(SIGBUS, int_handler);
X#endif
X    sigset(SIGSEGV, int_handler);
X#ifdef SIGTTIN
X    sigset(SIGTTIN, SIG_IGN);
X    sigset(SIGTTOU, SIG_IGN);
X#endif
X
X#ifdef lint
X    int_handler(SIGINT);
X#endif
X
X#ifdef SERVER
X    if ((server = get_server_name(0)) == NULL) {
X	log_entry("couldn't find name of news server.\n");
X	exit(1);
X    }
X    switch (server_init(server)) {
X    case OK_NOPOST:
X    case OK_CANPOST:
X	break;
X    case ERR_ACCESS:
X	log_entry("Server %s rejected connection.\n", server);
X	exit(1);
X    default:
X	log_entry("Couldn't connect with server %s.\n", server);
X	exit(1);
X    }
X#endif
X
X    /* See if this machine needs byte-order translation for the database */
X    word_same = long_same = TRUE;
X    if (read_from_tmp != 1) {
X#ifdef XTHREAD
X	put_server("XTHREAD DBINIT");
X	rawcheck_server(buf, sizeof buf);
X	size = rawget_server((char*)&mt_bmap, sizeof (BMAP));
X	if (size < sizeof (BMAP) - 1) {
X#else
X	if ((fp = fopen(file_exp(DBINIT), FOPEN_RB)) == Nullfp
X	 || fread((char*)&mt_bmap, 1, sizeof (BMAP), fp) < sizeof (BMAP)-1) {
X#endif
X	    log_entry("db.init read failed -- assuming no byte-order translations.\n\n");
X	    mybytemap(&mt_bmap);
X	} else {
X	    int i;
X
X	    if (mt_bmap.version != DB_VERSION) {
X		log_entry("Thread database is not the right version -- ignoring it.\n");
X		ignore_database = 1;
X	    }
X	    mybytemap(&my_bmap);
X	    for (i = 0; i < sizeof (LONG); i++) {
X		if (i < sizeof (WORD)) {
X		    if (my_bmap.w[i] != mt_bmap.w[i]) {
X			word_same = FALSE;
X		    }
X		}
X		if (my_bmap.l[i] != mt_bmap.l[i]) {
X		    long_same = FALSE;
X		}
X	    }
X	}
X#ifdef XTHREAD
X	while (rawget_server(buf, sizeof buf)) {
X	    ;		/* trash any extraneous bytes */
X	}
X#else
X	if (fp != Nullfp) {
X	    fclose(fp);
X	}
X#endif
X    }
X
X    /* What time is it? */
X#ifdef TZSET
X    (void) time(&tnow);
X    (void) tzset();
X#else
X    (void) ftime(&ftnow);
X#endif
X
X#ifdef SERVER
X    sprintf(buf, "GROUP %s", group);
X    put_server(buf);
X    if (get_server(buf, sizeof buf) < 0 || *buf != CHAR_OK) {
X	log_entry("NNTP failure on group `%s'.\n", group);
X#else
X    strcpy(cp = buf, group);
X    while ((cp = index(cp, '.'))) {
X	*cp = '/';
X    }
X    filename = file_exp(buf);		/* relative to spool dir */
X    if (chdir(filename) < 0) {
X	if (errno != ENOENT) {
X	    log_entry("Unable to chdir to `%s'.\n", filename);
X	}
X#endif
X	exit(1);
X    } else {
X	if (read_from_tmp) {
X	    filename = tmpname;
X	} else {
X#ifdef XTHREAD
X	    ignore_database = TRUE;
X#else
X	    filename = thread_name(group);
X#endif
X	}
X	if (ignore_database || !init_data(filename) || !read_data()) {
X	    (void) init_data(Nullch);
X	    total.last = first - 1;
X	    total.first = first;
X	}
X	start = total.last + 1;
X	if (start < last - max + 1) {
X	    start = last - max + 1;
X	}
X	process_articles(first, last);
X	putchar('\n') FLUSH;
X	if (!write_data(tmpname)) {
X	    exit(1);
X	}
X    }
X    return 0;
X}
X
SIGRET
int_handler(sig)
int sig;
X{
X    /* Simply bug out with an error flag. */
X    printf("interrupt %d!\n", sig) FLUSH;
X    exit(1);
X}
X
void
wrap_it_up(ret)
int ret;
X{
X    exit(ret);
X}
X
X/* Generate a "log entry" for the interactive user.
X*/
X/*VARARGS1*/
void
log_entry(fmt, arg1, arg2)
char *fmt;
long arg1;
long arg2;
X{
X    printf("tmpthread: ");
X    printf(fmt, arg1, arg2);
X    fflush(stdout);
X}
X
X/* Generate a "log entry", with newsgroup name for the interactive user.
X*/
X/*VARARGS1*/
void
log_error(fmt, arg1, arg2, arg3)
char *fmt;
long arg1;
long arg2;
long arg3;
X{
X    log_entry("%s: ", group);
X    printf(fmt, arg1, arg2, arg3);
X    fflush(stdout);
X}
END_OF_FILE
if test 6070 -ne `wc -c <'tmpthread.c'`; then
    echo shar: \"'tmpthread.c'\" unpacked with wrong size!
fi
# end of 'tmpthread.c'
fi
echo shar: End of archive 3 \(of 13\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 13 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
