Subject:  v25i012:  trn 2.0 - threaded newsreader based on rn 4.4, Part09/13
Newsgroups: comp.sources.unix
Approved: vixie@pa.dec.com

Submitted-by: davison@borland.com (Wayne Davison)
Posting-number: Volume 25, Issue 12
Archive-name: trn/part09

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 13)."
# Contents:  intrp.c rcstuff.c
# Wrapped by vixie@cognition.pa.dec.com on Tue Dec  3 16:34:55 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'intrp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'intrp.c'\"
else
echo shar: Extracting \"'intrp.c'\" \(27010 characters\)
sed "s/^X//" >'intrp.c' <<'END_OF_FILE'
X/* $Id: intrp.c,v 4.4.2.1 1991/12/01 18:05:42 sob PATCH_2 sob $
X *
X * $Log: intrp.c,v $
X * Revision 4.4.2.1  1991/12/01  18:05:42  sob
X * Patchlevel 2 changes
X *
X * Revision 4.4  1991/09/09  20:18:23  sob
X * release 4.4
X *
X *
X * 
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "search.h"
X#include "head.h"
X#include "rn.h"
X#include "artsrch.h"
X#include "ng.h"
X#include "respond.h"
X#include "rcstuff.h"
X#include "bits.h"
X#include "artio.h"
X#include "term.h"
X#include "final.h"
X#ifdef USETHREADS
X#include "threads.h"
X#include "rthreads.h"
X#endif
X#include "INTERN.h"
X#include "intrp.h"
X
static char * regexp_specials = "^$.*[\\/?";
X
char orgname[] = ORGNAME;
X
X/* name of this site */
X#ifdef GETHOSTNAME
X    char *hostname;
X#   undef SITENAME
X#   define SITENAME hostname
X#else /* !GETHOSTNAME */
X#   ifdef DOUNAME
X#	include <sys/utsname.h>
X	struct utsname utsn;
X#	undef SITENAME
X#	define SITENAME utsn.nodename
X#   else /* !DOUNAME */
X#	ifdef PHOSTNAME
X	    char *hostname;
X#	    undef SITENAME
X#	    define SITENAME hostname
X#	else /* !PHOSTNAME */
X#	    ifdef WHOAMI
X#		undef SITENAME
X#		define SITENAME sysname
X#	    endif /* WHOAMI */
X#	endif /* PHOSTNAME */
X#   endif /* DOUNAME */
X#endif /* GETHOSTNAME */
X
X#ifdef TILDENAME
static char *tildename = Nullch;
static char *tildedir = Nullch;
X#endif
X
char *realname INIT(Nullch);	/* real name of sender from /etc/passwd */
X
X#ifdef CONDSUB
char *skipinterp ANSI((char *,char *));
X#endif
X
static void abort_interp ANSI((void));
X
void
intrp_init(tcbuf)
char *tcbuf;
X{
X    char *getlogin();
X
X    spool = savestr(filexp(SPOOL));	/* usually /usr/spool/news */
X#ifdef USETHREADS
X    mtlib = savestr(filexp(MTLIB));
X    threaddir = savestr(filexp(THREAD_DIR));
X#endif
X    
X    /* get environmental stuff */
X
X#ifdef NEWSADMIN
X    {
X#ifdef GETPWENT
X	struct passwd *getpwnam();
X	struct passwd *pwd = getpwnam(NEWSADMIN);
X
X	if (pwd != NULL)
X	    newsuid = pwd->pw_uid;
X#else
X#ifdef TILDENAME
X	char tildenews[2+sizeof NEWSADMIN];
X	strcpy(tildenews, "~");
X	strcat(tildenews, NEWSADMIN);
X	(void) filexp(tildenews);
X#else
X	#error "At least one of GETPWENT or TILDENAME needed to get NEWSADMIN"
X#endif  /* TILDENAME */
X#endif	/* GETPWENT */
X    }
X#endif	/* NEWSADMIN */
X    /* get home directory */
X
X    homedir = getenv("HOME");
X    if (homedir == Nullch)
X	homedir = getenv("LOGDIR");
X
X    dotdir = getval("DOTDIR",homedir);
X
X    /* get login name */
X
X    logname = getenv("USER");
X    if (logname == Nullch)
X	logname = getenv("LOGNAME");
X#ifdef GETLOGIN
X    if (logname == Nullch)
X	logname = savestr(getlogin());
X#endif
X
X#ifdef NEWSADMIN
X    /* if this is the news admin than load his UID into newsuid */
X
X    if ( strEQ(logname,NEWSADMIN) )
X	newsuid = getuid();
X#endif
X
X    if (checkflag)			/* that getwd below takes ~1/3 sec. */
X	return;				/* and we do not need it for -c */
X    getwd(tcbuf);			/* find working directory name */
X    origdir = savestr(tcbuf);		/* and remember it */
X
X    /* get the real name of the person (%N) */
X    /* Must be done after logname is read in because BERKNAMES uses that */
X
X    strcpy(tcbuf,getrealname((long)getuid()));
X    realname = savestr(tcbuf);
X
X    /* name of header file (%h) */
X
X    headname = savestr(filexp(HEADNAME));
X
X    /* name of this site (%H) */
X
X#ifdef HOSTFILE
X    if ((tmpfp = fopen(HOSTFILE,"r")) == NULL) {
X	hostname = "unknown";
X	printf("Warning: Couldn't open %s to determine hostname!\n", HOSTFILE); 
X    } else {
X	fgets(buf, sizeof(buf), tmpfp);
X	buf[strlen(buf)-1] = 0;
X	hostname = savestr(buf);
X	fclose(tmpfp);
X    }
X#else
X#ifdef GETHOSTNAME
X    gethostname(buf,sizeof buf);
X    hostname = savestr(buf);
X#else
X#ifdef DOUNAME
X    /* get sysname */
X    uname(&utsn);
X#else
X#ifdef PHOSTNAME
X    {
X	FILE *popen();
X	FILE *pipefp = popen(PHOSTNAME,"r");
X	
X	if (pipefp == Nullfp) {
X	    printf("Can't find hostname\n");
X	    sig_catcher(0);
X	}
X	fgets(buf,sizeof buf,pipefp);
X	buf[strlen(buf)-1] = '\0';	/* wipe out newline */
X	hostname = savestr(buf);
X	pclose(pipefp);
X    }
X#endif	/* PHOSTNAME */
X#endif	/* DOUNAME */
X#endif	/* GETHOSTNAME */
X#endif	/* HOSTFILE */
X    if (index(SITENAME,'.') == NULL) {
X	sprintf(buf, "%s.%s", SITENAME, OURDOMAIN);
X	sitename = savestr(buf);
X    } else
X	sitename = savestr(SITENAME);
X}
X
X/* expand filename via %, ~, and $ interpretation */
X/* returns pointer to static area */
X/* Note that there is a 1-deep cache of ~name interpretation */
X
char *
filexp(s)
register char *s;
X{
X    static char filename[CBUFLEN];
X    char scrbuf[CBUFLEN];
X    register char *d;
X
X#ifdef DEBUGGING
X    if (debug & DEB_FILEXP)
X	printf("< %s\n",s) FLUSH;
X#endif
X    interp(filename, (sizeof filename), s);	
X					/* interpret any % escapes */
X#ifdef DEBUGGING
X    if (debug & DEB_FILEXP)
X	printf("%% %s\n",filename) FLUSH;
X#endif
X    s = filename;
X    if (*s == '~') {	/* does destination start with ~? */
X	if (!*(++s) || *s == '/') {
X	    sprintf(scrbuf,"%s%s",homedir,s);
X				/* swap $HOME for it */
X#ifdef DEBUGGING
X    if (debug & DEB_FILEXP)
X	printf("~ %s\n",scrbuf) FLUSH;
X#endif
X	    strcpy(filename,scrbuf);
X	}
X	else {
X#ifdef TILDENAME
X	    for (d=scrbuf; isalnum(*s); s++,d++)
X		*d = *s;
X	    *d = '\0';
X	    if (tildedir && strEQ(tildename,scrbuf)) {
X		strcpy(scrbuf,tildedir);
X		strcat(scrbuf, s);
X		strcpy(filename, scrbuf);
X#ifdef DEBUGGING
X		if (debug & DEB_FILEXP)
X		    printf("r %s %s\n",tildename,tildedir) FLUSH;
X#endif
X	    }
X	    else {
X		if (tildename) {
X		    free(tildename);
X		    free(tildedir);
X		}
X		tildedir = Nullch;
X		tildename = savestr(scrbuf);
X#ifdef GETPWENT		/* getpwnam() is not the paragon of efficiency */
X		{
X#ifdef notdef
X		    struct passwd *getpwnam ANSI((char*));
X#endif
X		    struct passwd *pwd = getpwnam(tildename);
X		    if ( pwd == NULL){
X			printf("%s is an unknown user. Using default.\n",tildename) FLUSH;
X			return(Nullch);
X		    }
X		    sprintf(scrbuf,"%s%s",pwd->pw_dir,s);
X		    tildedir = savestr(pwd->pw_dir);
X		    strcpy(filename,scrbuf);
X		    endpwent();
X		}
X#else			/* this will run faster, and is less D space */
X		{	/* just be sure LOGDIRFIELD is correct */
X		    FILE *pfp = fopen("/etc/passwd","r");
X		    char tmpbuf[512];
X		    int i;
X		    
X		    if (pfp == Nullfp) {
X			printf(cantopen,"passwd") FLUSH;
X			sig_catcher(0);
X		    }
X		    while (fgets(tmpbuf,512,pfp) != Nullch) {
X			d = cpytill(scrbuf,tmpbuf,':');
X#ifdef DEBUGGING
X			if (debug & DEB_FILEXP)
X			    printf("p %s\n",tmpbuf) FLUSH;
X#endif
X			if (strEQ(scrbuf,tildename)) {
X			    for (i=LOGDIRFIELD-2; i; i--) {
X				if (d)
X				    d = index(d+1,':');
X			    }
X			    if (d) {
X				cpytill(scrbuf,d+1,':');
X				tildedir = savestr(scrbuf);
X				strcat(scrbuf,s);
X				strcpy(filename,scrbuf);
X			    }
X			    break;
X			}
X		    }
X		    fclose(pfp);
X		}
X#endif
X	    }
X#else /* !TILDENAME */
X#ifdef VERBOSE
X	    IF(verbose)
X		fputs("~loginname not implemented.\n",stdout) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		fputs("~login not impl.\n",stdout) FLUSH;
X#endif
X#endif
X	}
X    }
X    else if (*s == '$') {	/* starts with some env variable? */
X	d = scrbuf;
X	*d++ = '%';
X	if (s[1] == '{')
X	    strcpy(d,s+2);
X	else {
X	    *d++ = '{';
X	    for (s++; isalnum(*s); s++) *d++ = *s;
X				/* skip over token */
X	    *d++ = '}';
X	    strcpy(d,s);
X	}
X#ifdef DEBUGGING
X	if (debug & DEB_FILEXP)
X	    printf("$ %s\n",scrbuf) FLUSH;
X#endif
X	interp(filename, (sizeof filename), scrbuf);
X					/* this might do some extra '%'s but */
X					/* that is how the Mercedes Benz */
X    }
X#ifdef DEBUGGING
X    if (debug & DEB_FILEXP)
X	printf("> %s\n",filename) FLUSH;
X#endif
X    return filename;
X}
X
X#ifdef CONDSUB
X/* skip interpolations */
X
char *
skipinterp(pattern,stoppers)
register char *pattern;
char *stoppers;
X{
X
X    while (*pattern && (!stoppers || !index(stoppers,*pattern))) {
X#ifdef DEBUGGING
X	if (debug & 8)
X	    printf("skipinterp till %s at %s\n",stoppers?stoppers:"",pattern);
X#endif
X	if (*pattern == '%' && pattern[1]) {
X	    switch (*++pattern) {
X	    case '{':
X		for (pattern++; *pattern && *pattern != '}'; pattern++)
X		    if (*pattern == '\\')
X			pattern++;
X		break;
X	    case '[':
X		for (pattern++; *pattern && *pattern != ']'; pattern++)
X		    if (*pattern == '\\')
X			pattern++;
X		break;
X#ifdef CONDSUB
X	    case '(': {
X		pattern = skipinterp(pattern+1,"!=");
X		if (!*pattern)
X		    goto getout;
X		for (pattern++; *pattern && *pattern != '?'; pattern++)
X		    if (*pattern == '\\')
X			pattern++;
X		if (!*pattern)
X		    goto getout;
X		pattern = skipinterp(pattern+1,":)");
X		if (*pattern == ':')
X		    pattern = skipinterp(pattern+1,")");
X		break;
X	    }
X#endif
X#ifdef BACKTICK
X	    case '`': {
X		pattern = skipinterp(pattern+1,"`");
X		break;
X	    }
X#endif
X#ifdef PROMPTTTY
X	    case '"':
X		pattern = skipinterp(pattern+1,"\"");
X		break;
X#endif
X	    default:
X		break;
X	    }
X	    pattern++;
X	}
X	else {
X	    if (*pattern == '^' && pattern[1])
X		pattern += 2;
X	    else if (*pattern == '\\' && pattern[1])
X		pattern += 2;
X	    else
X		pattern++;
X	}
X    }
getout:
X    return pattern;			/* where we left off */
X}
X#endif
X
X/* interpret interpolations */
X
char *
dointerp(dest,destsize,pattern,stoppers)
register char *dest;
register int destsize;
register char *pattern;
char *stoppers;
X{
X    char *subj_buf = Nullch;
X    char *ngs_buf = Nullch;
X    char *refs_buf = Nullch;
X    char *artid_buf = Nullch;
X    char *reply_buf = Nullch;
X    char *from_buf = Nullch;
X    char *path_buf = Nullch;
X    char *follow_buf = Nullch;
X    char *dist_buf = Nullch;
X    char *line_buf = Nullch;
X    register char *s, *h;
X    register int i;
X    char scrbuf[512];
X    bool upper = FALSE;
X    bool lastcomp = FALSE;
X    bool re_quote = FALSE;
X    int metabit = 0;
X
X    while (*pattern && (!stoppers || !index(stoppers,*pattern))) {
X#ifdef DEBUGGING
X	if (debug & 8)
X	    printf("dointerp till %s at %s\n",stoppers?stoppers:"",pattern);
X#endif
X	if (*pattern == '%' && pattern[1]) {
X	    upper = FALSE;
X	    lastcomp = FALSE;
X	    re_quote = FALSE;
X	    for (s=Nullch; !s; ) {
X		switch (*++pattern) {
X		case '^':
X		    upper = TRUE;
X		    break;
X		case '_':
X		    lastcomp = TRUE;
X		    break;
X		case '\\':
X		    re_quote = TRUE;
X		    break;
X		case '/':
X#ifdef ARTSRCH
X		    s = scrbuf;
X		    if (!index("/?g",pattern[-2]))
X			*s++ = '/';
X		    strcpy(s,lastpat);
X		    s += strlen(s);
X		    if (pattern[-2] != 'g') {
X			if (index("/?",pattern[-2]))
X			    *s++ = pattern[-2];
X			else
X			    *s++ = '/';
X			if (art_howmuch == 1)
X			    *s++ = 'h';
X			else if (art_howmuch == 2)
X			    *s++ = 'a';
X			if (art_doread)
X			    *s++ = 'r';
X		    }
X		    *s = '\0';
X		    s = scrbuf;
X#else
X		    s = nullstr;
X#endif
X		    break;
X		case '{':
X		    pattern = cpytill(scrbuf,pattern+1,'}');
X		    if (s = index(scrbuf,'-'))
X			*s++ = '\0';
X		    else
X			s = nullstr;
X		    s = getval(scrbuf,s);
X		    break;
X		case '[':
X		    pattern = cpytill(scrbuf,pattern+1,']');
X		    i = set_line_type(scrbuf,scrbuf+strlen(scrbuf));
X		    if (line_buf)
X			free(line_buf);
X		    s = line_buf = fetchlines(art,i);
X		    break;
X#ifdef CONDSUB
X		case '(': {
X		    COMPEX *oldbra_compex = bra_compex;
X		    COMPEX cond_compex;
X		    char rch;
X		    bool matched;
X		    
X		    init_compex(&cond_compex);
X		    pattern = dointerp(dest,destsize,pattern+1,"!=");
X		    rch = *pattern;
X		    if (rch == '!')
X			pattern++;
X		    if (*pattern != '=')
X			goto getout;
X		    pattern = cpytill(scrbuf,pattern+1,'?');
X		    if (!*pattern)
X			goto getout;
X		    if (s = compile(&cond_compex,scrbuf,TRUE,TRUE)) {
X			printf("%s: %s\n",scrbuf,s) FLUSH;
X			pattern += strlen(pattern);
X			goto getout;
X		    }
X		    matched = (execute(&cond_compex,dest) != Nullch);
X		    if (cond_compex.nbra)	/* were there brackets? */
X			bra_compex = &cond_compex;
X		    if (matched==(rch == '=')) {
X			pattern = dointerp(dest,destsize,pattern+1,":)");
X			if (*pattern == ':')
X			    pattern = skipinterp(pattern+1,")");
X		    }
X		    else {
X			pattern = skipinterp(pattern+1,":)");
X			if (*pattern == ':')
X			    pattern++;
X			pattern = dointerp(dest,destsize,pattern,")");
X		    }
X		    s = dest;
X		    bra_compex = oldbra_compex;
X		    free_compex(&cond_compex);
X		    break;
X		}
X#endif
X#ifdef BACKTICK
X		case '`': {
X		    FILE *pipefp, *popen();
X
X		    pattern = dointerp(scrbuf,(sizeof scrbuf),pattern+1,"`");
X		    pipefp = popen(scrbuf,"r");
X		    if (pipefp != Nullfp) {
X			int len;
X
X			len = fread(scrbuf,sizeof(char),(sizeof scrbuf)-1,
X			    pipefp);
X			scrbuf[len] = '\0';
X			pclose(pipefp);
X		    }
X		    else {
X			printf("\nCan't run %s\n",scrbuf);
X			*scrbuf = '\0';
X		    }
X		    for (s=scrbuf; *s; s++) {
X			if (*s == '\n') {
X			    if (s[1])
X				*s = ' ';
X			    else
X				*s = '\0';
X			}
X		    }
X		    s = scrbuf;
X		    break;
X		}
X#endif
X#ifdef PROMPTTTY
X		case '"':
X		    pattern = dointerp(scrbuf,(sizeof scrbuf),pattern+1,"\"");
X		    fputs(scrbuf,stdout) FLUSH;
X		    resetty();
X		    gets(scrbuf);
X		    noecho();
X		    crmode();
X		    s = scrbuf;
X		    break;
X#endif
X		case '~':
X		    s = homedir;
X		    break;
X		case '.':
X		    s = dotdir;
X		    break;
X		case '$':
X		    s = scrbuf;
X		    sprintf(s,"%d",getpid());
X		    break;
X		case '#':
X		    s = scrbuf;
X		    sprintf(s,"%d",perform_cnt);
X		    break;
X		case '0': case '1': case '2': case '3': case '4':
X		case '5': case '6': case '7': case '8': case '9':
X#ifdef CONDSUB
X		    s = getbracket(bra_compex,*pattern - '0');
X#else
X		    s = nullstr;
X#endif
X		    break;
X		case 'a':
X		    s = scrbuf;
X		    sprintf(s,"%ld",(long)art);
X		    break;
X		case 'A':
X#ifdef LINKART
X		    s = linkartname;	/* so Eunice people get right file */
X#else
X		    s = scrbuf;
X#ifdef SERVER
X		    sprintf(s,"%s/rrn%ld.%d",spool,(long)art,getpid());
X#else
X		    sprintf(s,"%s/%s/%ld",spool,ngdir,(long)art);
X#endif
X#endif
X		    break;
X		case 'b':
X		    s = savedest;
X		    break;
X		case 'B':
X		    s = scrbuf;
X		    sprintf(s,"%ld",(long)savefrom);
X		    break;
X		case 'c':
X		    s = ngdir;
X		    break;
X		case 'C':
X		    s = ngname;
X		    break;
X		case 'd':
X		    s = scrbuf;
X		    sprintf(s,"%s/%s",spool,ngdir);
X		    break;
X		case 'D':
X		    s = dist_buf = fetchlines(art,DIST_LINE);
X		    break;
X		case 'e':
X		    s = (extractprog ? extractprog : "-");
X		    break;
X		case 'E':
X		    s = extractdest;
X		    break;
X		case 'f':			/* from line */
X#ifdef ASYNC_PARSE
X		    parse_maybe(art);
X#endif
X		    if (htype[REPLY_LINE].ht_minpos >= 0) {
X						/* was there a reply line? */
X			if (!(s=reply_buf))
X			    s = reply_buf = fetchlines(art,REPLY_LINE);
X		    }
X		    else if (!(s = from_buf))
X			s = from_buf = fetchlines(art,FROM_LINE);
X		    break;
X		case 'F':
X#ifdef ASYNC_PARSE
X		    parse_maybe(art);
X#endif
X		    if (htype[FOLLOW_LINE].ht_minpos >= 0)
X					/* is there a Followup-To line? */
X			s = follow_buf = fetchlines(art,FOLLOW_LINE);
X		    else 
X			s = ngs_buf = fetchlines(art,NGS_LINE);
X		    break;
X		case 'h':			/* header file name */
X		    s = headname;
X		    break;
X		case 'H':			/* host name */
X		    s = sitename;
X		    break;
X		case 'i':
X		    if (!(s=artid_buf))
X			s = artid_buf = fetchlines(art,MESSID_LINE);
X		    if (*s && *s != '<') {
X			sprintf(scrbuf,"<%s>",artid_buf);
X			s = scrbuf;
X		    }
X		    break;
X		case 'I':			/* ref article indicator */
X		    s = scrbuf;
X		    sprintf(scrbuf,"'%s'",indstr);
X		    break;
X		case 'l':			/* rn library */
X#ifdef NEWSADMIN
X		    s = newsadmin;
X#else
X		    s = "???";
X#endif
X		    break;
X		case 'L':			/* login id */
X		    s = logname;
X		    break;
X		case 'm':		/* current mode */
X		    s = scrbuf;
X		    *s = mode;
X		    s[1] = '\0';
X		    break;
X		case 'M':
X#ifdef DELAYMARK
X		    sprintf(scrbuf,"%ld",(long)dmcount);
X		    s = scrbuf;
X#else
X		    s = nullstr;
X#endif
X		    break;
X		case 'n':			/* newsgroups */
X		    s = ngs_buf = fetchlines(art,NGS_LINE);
X		    break;
X		case 'N':			/* full name */
X		    s = getval("NAME",realname);
X		    break;
X		case 'o':			/* organization */
X#ifdef IGNOREORG
X		    s = getval("NEWSORG",orgname); 
X#else
X		    s = getenv("NEWSORG");
X		    if (s == Nullch) 
X			s = getval("ORGANIZATION",orgname); 
X#endif
X#ifdef ORGFILE
X		    if (*s == '/') {
X			FILE *ofp = fopen(s,"r");
X
X			if (ofp) {
X			    fgets(scrbuf,sizeof scrbuf,ofp);
X			    fclose(ofp);
X			    s = scrbuf+strlen(scrbuf)-1;
X			    if (*s == '\n')
X				*s = '\0';
X			    s = scrbuf;
X			}
X		    }
X#endif
X		    break;
X		case 'O':
X		    s = origdir;
X		    break;
X		case 'p':
X		    s = cwd;
X		    break;
X		case 'P':
X		    s = spool;
X		    break;
X		case 'r':
X#ifdef ASYNC_PARSE
X		    parse_maybe(art);
X#endif
X		    if (htype[REFS_LINE].ht_minpos >= 0) {
X			refs_buf = fetchlines(art,REFS_LINE);
X			refscpy(scrbuf,(sizeof scrbuf),refs_buf);
X		    }
X		    else
X			*scrbuf = '\0';
X		    s = rindex(scrbuf,'<');
X		    break;
X		case 'R':
X#ifdef ASYNC_PARSE
X		    parse_maybe(art);
X#endif
X		    if (htype[REFS_LINE].ht_minpos >= 0) {
X			refs_buf = fetchlines(art,REFS_LINE);
X			refscpy(scrbuf,(sizeof scrbuf),refs_buf);
X			/* no more than 3 prior references allowed,
X			** including the one concatenated below */
X			if ((s = rindex(scrbuf,'<')) > scrbuf) {
X			    *s = '\0';
X			    h = rindex(scrbuf,'<');
X			    *s = '<';
X			    if (h > scrbuf)
X				strcpy(scrbuf,h);
X			}
X		    }
X		    else
X			*scrbuf = '\0';
X		    if (!artid_buf)
X			artid_buf = fetchlines(art,MESSID_LINE);
X		    if (artid_buf[0] == '<')
X			safecat(scrbuf,artid_buf,sizeof(scrbuf));
X		    else if (artid_buf[0]) {
X			char tmpbuf[64];
X    
X			sprintf(tmpbuf,"<%s>",artid_buf);
X			safecat(scrbuf,tmpbuf,sizeof(scrbuf));
X		    }
X		    s = scrbuf;
X		    break;
X		case 's':
X		    if (!(s=subj_buf))
X			s = subj_buf = fetchsubj(art,TRUE,TRUE);
X						/* get subject handy */
X		    while ((*s=='R'||*s=='r')&&(s[1]=='E'||s[1]=='e')&&s[2]==':') {
X						/* skip extra Re: */
X			s += 3;
X			if (*s == ' ')
X			    s++;
X		    }
X		    if (h = instr(s,"- (nf", TRUE))
X			*h = '\0';
X		    break;
X		case 'S':
X		    if (!(s=subj_buf))
X			s = subj_buf = fetchsubj(art,TRUE,TRUE);
X						/* get subject handy */
X		    if ((*s=='R'||*s=='r')&&(s[1]=='E'||s[1]=='e')&&s[2]==':') {
X						/* skip extra Re: */
X			s += 3;
X			if (*s == ' ')
X			    s++;
X		    }
X		    break;
X		case 't':
X		case 'T':
X#ifdef ASYNC_PARSE
X		    parse_maybe(art);
X#endif
X		    if (htype[REPLY_LINE].ht_minpos >= 0) {
X					/* was there a reply line? */
X			if (!(s=reply_buf))
X			    s = reply_buf = fetchlines(art,REPLY_LINE);
X		    }
X		    else if (!(s = from_buf))
X			s = from_buf = fetchlines(art,FROM_LINE);
X		    if (*pattern == 'T') {
X			if (htype[PATH_LINE].ht_minpos >= 0) {
X					/* should we substitute path? */
X			    s = path_buf = fetchlines(art,PATH_LINE);
X			}
X			i = strlen(sitename);
X			if (strnEQ(sitename,s,i) && s[i] == '!')
X			    s += i + 1;
X		    }
X		    if ((h=index(s,'(')) != Nullch)
X						/* strip garbage from end */
X			*(h-1) = '\0';
X		    else if ((h=index(s,'<')) != Nullch) {
X						/* or perhaps from beginning */
X			s = h+1;
X			if ((h=index(s,'>')) != Nullch)
X			    *h = '\0';
X		    }
X		    break;
X		case 'u':
X		    sprintf(scrbuf,"%ld",(long)toread[ng]);
X		    s = scrbuf;
X		    break;
X		case 'U': {
X		    int unseen;
X
X		    unseen = (art <= lastart) && !was_read(art);
X#ifdef USETHREADS
X		    if (selected_root_cnt) {
X			int selected;
X
X			selected = curr_p_art
X				&& (selected_roots[curr_p_art->root] & 1);
X			sprintf(scrbuf,"%ld",
X				(long)selected_count - (selected && unseen));
X		    }
X		    else
X			sprintf(scrbuf,"%ld",(long)toread[ng]-unthreaded
X						-unseen);
X#else
X		    sprintf(scrbuf,"%ld",(long)toread[ng]-unseen);
X#endif
X		    s = scrbuf;
X		    break;
X		}
X#ifdef USETHREADS
X		case 'v': {
X		    int selected, unseen;
X
X		    selected = curr_p_art
X				&& (selected_roots[curr_p_art->root] & 1);
X		    unseen = (art <= lastart) && !was_read(art);
X		    sprintf(scrbuf,"%ld",(long)toread[ng] - selected_count
X					 - unthreaded - (!selected && unseen));
X		    s = scrbuf;
X		    break;
X		}
X		case 'w':
X		    s = mtlib;
X		    break;
X		case 'W':
X		    s = threaddir;
X		    break;
X#endif
X		case 'x':			/* news library */
X		    s = lib;
X		    break;
X		case 'X':			/* rn library */
X		    s = rnlib;
X		    break;
X		case 'z':
X#ifdef LINKART
X		    s = linkartname;	/* so Eunice people get right file */
X#else
X		    s = scrbuf;
X		    sprintf(s,"%ld",(long)art);
X#endif
X		    if (stat(s,&filestat) < 0)
X			filestat.st_size = 0L;
X		    sprintf(scrbuf,"%5ld",(long)filestat.st_size);
X		    s = scrbuf;
X		    break;
X#ifdef USETHREADS
X		case 'Z':
X		    sprintf(scrbuf,"%ld",(long)selected_count);
X		    s = scrbuf;
X		    break;
X#endif
X		default:
X		    if (--destsize <= 0)
X			abort_interp();
X		    *dest++ = *pattern | metabit;
X		    s = nullstr;
X		    break;
X		}
X	    }
X	    if (!s)
X		s = nullstr;
X	    pattern++;
X	    if (upper || lastcomp) {
X		char *t;
X
X		if (s != scrbuf) {
X		    safecpy(scrbuf,s,(sizeof scrbuf));
X		    s = scrbuf;
X		}
X		if (upper || !(t=rindex(s,'/')))
X		    t = s;
X		while (*t && !isalpha(*t))
X		    t++;
X		if (islower(*t))
X		    *t = toupper(*t);
X	    }
X	    /* Do we have room left? */
X	    i = strlen(s);
X	    if (destsize <= i)
X		abort_interp();
X	    destsize -= i;	/* adjust the size now. */
X
X	    /* A maze of twisty little conditions, all alike... */
X	    if (metabit) {
X		/* set meta bit while copying. */
X		i = metabit;		/* maybe get into register */
X		if (s == dest) {
X		    while (*dest)
X			*dest++ |= i;
X		} else {
X		    while (*s)
X			*dest++ = *s++ | i;
X		}
X	    } else if (re_quote) {
X		/* put a backslash before regexp specials while copying. */
X		if (s == dest) {
X		    /* copy out so we can copy in. */
X		    safecpy(scrbuf, s, sizeof scrbuf);
X		    s = scrbuf;
X		    if (i > sizeof scrbuf)	/* we truncated, ack! */
X			destsize += i - sizeof scrbuf;
X		}
X		while (*s) {
X		    if (index(regexp_specials, *s)) {
X			if (--destsize <= 0)
X			    abort_interp();
X			*dest++ = '\\';
X		    }
X		    *dest++ = *s++;
X		}
X	    } else {
X		/* straight copy. */
X		if (s == dest) {
X		    dest += i;
X		} else {
X		    while (*s)
X			*dest++ = *s++;
X		}
X	    }
X	}
X	else {
X	    if (--destsize <= 0)
X		abort_interp();
X	    if (*pattern == '^' && pattern[1]) {
X		++pattern;			/* skip uparrow */
X		i = *pattern;		/* get char into a register */
X		if (i == '?')
X		    *dest++ = '\177' | metabit;
X		else if (i == '(') {
X		    metabit = 0200;
X		    destsize++;
X		}
X		else if (i == ')') {
X		    metabit = 0;
X		    destsize++;
X		}
X		else
X		    *dest++ = i & 037 | metabit;
X		pattern++;
X	    }
X	    else if (*pattern == '\\' && pattern[1]) {
X		++pattern;			/* skip backslash */
X		i = *pattern;		/* get char into a register */
X    
X		/* this used to be a switch but the if may save space */
X		
X		if (i >= '0' && i <= '7') {
X		    i = 1;
X		    while (i < 01000 && *pattern >= '0' && *pattern <= '7') {
X			i <<= 3;
X			i += *pattern++ - '0';
X		    }
X		    *dest++ = i & 0377 | metabit;
X		    --pattern;
X		}
X		else if (i == 'b')
X		    *dest++ = '\b' | metabit;
X		else if (i == 'f')
X		    *dest++ = '\f' | metabit;
X		else if (i == 'n')
X		    *dest++ = '\n' | metabit;
X		else if (i == 'r')
X		    *dest++ = '\r' | metabit;
X		else if (i == 't')
X		    *dest++ = '\t' | metabit;
X		else
X		    *dest++ = i | metabit;
X		pattern++;
X	    }
X	    else
X		*dest++ = *pattern++ | metabit;
X	}
X    }
X    *dest = '\0';
getout:
X    if (subj_buf != Nullch)	/* return any checked out storage */
X	free(subj_buf);
X    if (ngs_buf != Nullch)
X	free(ngs_buf);
X    if (refs_buf != Nullch)
X	free(refs_buf);
X    if (artid_buf != Nullch)
X	free(artid_buf);
X    if (reply_buf != Nullch)
X	free(reply_buf);
X    if (from_buf != Nullch)
X	free(from_buf);
X    if (path_buf != Nullch)
X	free(path_buf);
X    if (follow_buf != Nullch)
X	free(follow_buf);
X    if (dist_buf != Nullch)
X	free(dist_buf);
X    if (line_buf != Nullch)
X	free(line_buf);
X    return pattern;			/* where we left off */
X}
X
void
interp(dest,destsize,pattern)
char *dest;
int destsize;
char *pattern;
X{
X    dointerp(dest,destsize,pattern,Nullch);
X#ifdef DEBUGGING
X    if (debug & DEB_FILEXP)
X	fputs(dest,stdout);
X#endif
X}
X
X/* copy a references line, normalizing as we go */
X
void
refscpy(dest,destsize,src)
register char *dest, *src;
register int destsize;
X{
X    register char *dot, *at, *beg;
X    char tmpbuf[64];
X    
X    while (*src) {
X	if (*src != '<') {
X	    if (--destsize <= 0)
X		break;
X	    *dest++ = '<';
X	    at = dot = Nullch;
X	    beg = src;
X	    while (*src && *src != ' ' && *src != ',') {
X		if (*src == '.')
X		    dot = src;
X		else if (*src == '@')
X		    at = src;
X		if (--destsize <= 0)
X		    break;
X		*dest++ = *src++;
X	    }
X	    if (destsize <= 0)
X		break;
X	    if (dot && !at) {
X		int len;
X
X		*dest = *dot++ = '\0';
X		sprintf(tmpbuf,"%s@%s.UUCP",dot,beg);
X		len = strlen(tmpbuf);
X		if (destsize > len) {
X		    strcpy(dest,tmpbuf);
X		    dest = dest + len;
X		    destsize -= len;
X		}
X	    }
X	    if (--destsize <= 0)
X		break;
X	    *dest++ = '>';
X	}
X	else {
X	    while (*src && --destsize > 0 && (*dest++ = *src++) != '>') ;
X	    if (destsize <= 0)
X		break;
X	}
X	while (*src == ' ' || *src == ',') src++;
X	if (*src && --destsize > 0)
X	    *dest++ = ' ';
X    }
X    *dest = '\0';
X} 
X
X/* get the person's real name from /etc/passwd */
X/* (string is overwritten, so it must be copied) */
X
char *
getrealname(uid)
long uid;
X{
X    char *s, *c;
X
X#ifdef PASSNAMES
X#ifdef GETPWENT
X#ifdef notdef
X    struct passwd *getpwuid ANSI((uid_t));
X#endif
X    struct passwd *pwd = getpwuid(uid);
X    
X    s = pwd->pw_gecos;
X#else
X    char tmpbuf[512];
X    int i;
X
X    getpw(uid, tmpbuf);
X    for (s=tmpbuf, i=GCOSFIELD-1; i; i--) {
X	if (s)
X	    s = index(s,':')+1;
X    }
X    if (!s)
X	return nullstr;
X    cpytill(tmpbuf,s,':');
X    s = tmpbuf;
X#endif
X#ifdef BERKNAMES
X#ifdef BERKJUNK
X    while (*s && !isalnum(*s) && *s != '&') s++;
X#endif
X    if ((c = index(s, ',')) != Nullch)
X	*c = '\0';
X    if ((c = index(s, ';')) != Nullch)
X	*c = '\0';
X    s = cpytill(buf,s,'&');
X    if (*s == '&') {			/* whoever thought this one up was */
X	c = buf + strlen(buf);		/* in the middle of the night */
X	strcat(c,logname);		/* before the morning after */
X	strcat(c,s+1);
X	if (islower(*c))
X	    *c = toupper(*c);		/* gack and double gack */
X    }
X#else
X    if ((c = index(s, '(')) != Nullch)
X	*c = '\0';
X    if ((c = index(s, '-')) != Nullch)
X	s = c;
X    strcpy(buf,tmpbuf);
X#endif
X#ifdef GETPWENT
X    endpwent();
X#endif
X    return buf;				/* return something static */
X#else
X    if ((tmpfp=fopen(filexp(FULLNAMEFILE),"r")) != Nullfp) {
X	fgets(buf,sizeof buf,tmpfp);
X	fclose(tmpfp);
X	buf[strlen(buf)-1] = '\0';
X	return buf;
X    }
X    return "PUT YOUR NAME HERE";
X#endif
X}
X
static void
abort_interp()
X{
X    fputs("\n% interp buffer overflow!\n",stdout) FLUSH;
X    sig_catcher(0);
X}
X
X
END_OF_FILE
if test 27010 -ne `wc -c <'intrp.c'`; then
    echo shar: \"'intrp.c'\" unpacked with wrong size!
fi
# end of 'intrp.c'
fi
if test -f 'rcstuff.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rcstuff.c'\"
else
echo shar: Extracting \"'rcstuff.c'\" \(27693 characters\)
sed "s/^X//" >'rcstuff.c' <<'END_OF_FILE'
X/* $Id: rcstuff.c,v 4.4.2.1 1991/12/01 18:05:42 sob PATCH_2 sob $
X *
X * $Log: rcstuff.c,v $
X * Revision 4.4.2.1  1991/12/01  18:05:42  sob
X * Patchlevel 2 changes
X *
X * Revision 4.4  1991/09/09  20:27:37  sob
X * release 4.4
X *
X *
X * 
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "ngdata.h"
X#include "term.h"
X#include "final.h"
X#include "rn.h"
X#include "intrp.h"
X#include "only.h"
X#include "rcln.h"
X#ifdef SERVER
X#include "server.h"
X#endif
X#include "autosub.h"
X#include "INTERN.h"
X#include "rcstuff.h"
X
char *rcname INIT(Nullch);		/* path name of .newsrc file */
char *rctname INIT(Nullch);		/* path name of temp .newsrc file */
char *rcbname INIT(Nullch);		/* path name of backup .newsrc file */
char *softname INIT(Nullch);		/* path name of .rnsoft file */
XFILE *rcfp INIT(Nullfp);		/* .newsrc file pointer */
X
static void grow_rc_arrays ANSI((int));
static void parse_rcline ANSI((NG_NUM));
X
X#ifdef HASHNG
X    static int hashsiz;
X    static short *hashtbl = NULL;
X#endif
X
bool
rcstuff_init()
X{
X    register NG_NUM newng;
X    register int i;
X    register bool foundany = FALSE;
X    char *some_buf;
X    long length;
X#ifdef SERVER
X    char *cp;
X#endif /* SERVER */
X    bool found = FALSE;
X
X    /* make filenames */
X
X#ifdef SERVER
X
X    if (cp = getenv("NEWSRC"))
X	rcname = savestr(filexp(cp));
X    else
X	rcname = savestr(filexp(RCNAME));
X
X#else /* not SERVER */
X
X    rcname = savestr(filexp(RCNAME));
X
X#endif /* SERVER */
X
X    rctname = savestr(filexp(RCTNAME));
X    rcbname = savestr(filexp(RCBNAME));
X    softname = savestr(filexp(SOFTNAME));
X    
X    /* make sure the .newsrc file exists */
X
X    newsrc_check();
X
X    /* open .rnsoft file containing soft ptrs to active file */
X
X    tmpfp = fopen(softname,"r");
X    if (tmpfp == Nullfp)
X	writesoft = TRUE;
X
X    /* allocate memory for rc file globals */
X    grow_rc_arrays(1500);
X
X    /* read in the .newsrc file */
X
X    for (nextrcline = 0;
X	(some_buf = get_a_line(buf,LBUFLEN,rcfp)) != Nullch;
X	nextrcline++) {
X					/* for each line in .newsrc */
X	char tmpbuf[10];
X
X	newng = nextrcline;		/* get it into a register */
X	length = len_last_line_got;	/* side effect of get_a_line */
X	if (length <= 1) {		/* only a newline??? */
X	    nextrcline--;		/* compensate for loop increment */
X	    continue;
X	}
X	if (newng >= maxrcline)		/* check for overflow */
X	    grow_rc_arrays(maxrcline + 500);
X	if (tmpfp != Nullfp && fgets(tmpbuf,10,tmpfp) != Nullch)
X	    softptr[newng] = atol(tmpbuf);
X	else
X	    softptr[newng] = 0;
X	some_buf[--length] = '\0';	/* wipe out newline */
X	if (checkflag)			/* no extra mallocs for -c */
X	    rcline[newng] = some_buf;
X	else if (some_buf == buf) {
X	    rcline[newng] = savestr(some_buf);
X					/* make a semipermanent copy */
X	}
X	else {
X	    /*NOSTRICT*/
X#ifndef lint
X	    some_buf = saferealloc(some_buf,(MEM_SIZE)(length+1));
X#endif /* lint */
X	    rcline[newng] = some_buf;
X	}
X#ifdef NOTDEF
X	if (strnEQ(some_buf,"to.",3)) {	/* is this a non-newsgroup? */
X	    nextrcline--;		/* destroy this line */
X	    continue;
X	}
X#endif
X	if (*some_buf == ' ' ||
X	  *some_buf == '\t' ||
X	  strnEQ(some_buf,"options",7)) {		/* non-useful line? */
X	    toread[newng] = TR_JUNK;
X	    rcchar[newng] = ' ';
X	    rcnums[newng] = 0;
X	    continue;
X	}
X	parse_rcline(newng);
X	if (rcchar[newng] == NEGCHAR) {
X	    toread[newng] = TR_UNSUB;
X	    continue;
X	}
X
X	/* now find out how much there is to read */
X
X	if (!inlist(buf) || (suppress_cn && foundany && !paranoid))
X	    toread[newng] = TR_NONE;	/* no need to calculate now */
X	else
X	    set_toread(newng);
X#ifdef VERBOSE
X	if (!checkflag && softmisses == 1) {
X	    softmisses++;		/* lie a little */
X	    fputs("(Revising soft pointers--be patient.)\n",stdout) FLUSH;
X	}
X#endif
X	if (toread[newng] > TR_NONE) {	/* anything unread? */
X	    if (!foundany) {
X		starthere = newng;
X		foundany = TRUE;	/* remember that fact*/
X	    }
X	    if (suppress_cn) {		/* if no listing desired */
X		if (checkflag) {	/* if that is all they wanted */
X		    finalize(1);	/* then bomb out */
X		}
X	    }
X	    else {
X#ifdef VERBOSE
X		IF(verbose)
X		    printf("Unread news in %-40s %5ld article%s\n",
X			rcline[newng],(long)toread[newng],
X			toread[newng]==TR_ONE ? nullstr : "s") FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    printf("%s: %ld article%s\n",
X			rcline[newng],(long)toread[newng],
X			toread[newng]==TR_ONE ? nullstr : "s") FLUSH;
X#endif
X		if (int_count) {
X		    countdown = 1;
X		    int_count = 0;
X		}
X		if (countdown) {
X		    if (! --countdown) {
X			fputs("etc.\n",stdout) FLUSH;
X			if (checkflag)
X			    finalize(1);
X			suppress_cn = TRUE;
X		    }
X		}
X	    }
X	}
X    }
X    fclose(rcfp);			/* close .newsrc */
X    if (tmpfp != Nullfp)
X	fclose(tmpfp);			/* close .rnsoft */
X    if (checkflag) {			/* were we just checking? */
X	finalize(foundany);		/* tell them what we found */
X    }
X    if (paranoid)
X	cleanup_rc();
X
X#ifdef HASHNG
X
X    /* find a good hash size given num of newsgroups */
X
X    hashsiz = maxrcline * 1.15;
X    if ((hashsiz & 1) == 0)	/* must be odd */
X	hashsiz++;
X
X    if (hashsiz <= activeitems)
X	hashsiz = activeitems * 1.15;
X    /* find one that's prime */
X    while (! found) {
X	for (i=3; ; i+=2) {
X	    if ( (float)(hashsiz)/i == hashsiz/i )
X		break;
X	    if ( i > hashsiz/i ) {
X		found = TRUE;
X		break;
X	    }
X	}
X	if (! found)
X	    hashsiz += 2;
X    }
X
X    hashtbl = (short *) safemalloc( hashsiz * sizeof(short) );
X
X    for (i=0; i<hashsiz; i++)
X	hashtbl[i] = -1;
X
X    if (!checkflag)
X	for (i=0; i<nextrcline; i++)
X	    sethash(i);
X#endif
X
X#ifdef DEBUGGING
X    if (debug & DEB_HASH) {
X	page_init();
X	for (i=0; i<hashsiz; i++) {
X	    sprintf(buf,"%d	%d",i,hashtbl[i]);
X	    print_lines(buf,NOMARKING);
X	}
X    }
X#endif
X
X    return foundany;
X}
X
static void
parse_rcline(ngnum)
NG_NUM ngnum;
X{
X#ifdef M_XENIX
X    char *s;			/* bypass a compiler bug (ugh!) */
X#else
X    register char *s;
X#endif
X
X    for (s = rcline[ngnum]; *s && *s != ':' && *s != NEGCHAR; s++) ;
X    if (!*s && !checkflag) {
X#ifndef lint
X	rcline[ngnum] = saferealloc(rcline[ngnum],
X				(MEM_SIZE)(s - rcline[ngnum]) + 3);
X#endif /* lint */
X	strcpy(s, ": ");
X    }
X#ifdef USETHREADS
X    if (*s == ':' && s[1] && s[2] == '0') {
X	rcchar[ngnum] = '0';
X	s[2] = '1';
X    } else
X#endif
X	rcchar[ngnum] = *s;	/* salt away the : or ! */
X    rcnums[ngnum] = (char)(s - rcline[ngnum]) + 1;
X				/* remember where the numbers are */
X    *s = '\0';			/* null terminate newsgroup name */
X}
X
void
abandon_ng(ngnum)
NG_NUM ngnum;
X{
X    char *some_buf = Nullch;
X
X    /* open .oldnewsrc and try to find the prior value for the group. */
X    if ((rcfp = fopen(rcbname, "r")) != Nullfp) {
X	int length = rcnums[ngnum] - 1;
X
X	while ((some_buf = get_a_line(buf,LBUFLEN,rcfp)) != Nullch) {
X	    if (len_last_line_got <= 0)
X		continue;
X	    some_buf[len_last_line_got-1] = '\0';	/* wipe out newline */
X	    if ((some_buf[length] == ':' || some_buf[length] == NEGCHAR)
X	     && strnEQ(rcline[ngnum], some_buf, length)) {
X		break;
X	    }
X	    if (some_buf != buf)
X		free(some_buf);
X	}
X	fclose(rcfp);
X    } else if (errno != ENOENT) {
X	printf("Unable to open %s.\n", rcbname) FLUSH;
X	return;
X    }
X    if (some_buf == Nullch) {
X	some_buf = rcline[ngnum] + rcnums[ngnum];
X	if (*some_buf == ' ')
X	    some_buf++;
X	*some_buf = '\0';
X#ifdef CACHEFIRST
X	abs1st[ngnum] = 0;	/* force group to be re-calculated */
X#endif
X    }
X    else {
X	free(rcline[ngnum]);
X	if (some_buf == buf) {
X	    rcline[ngnum] = savestr(some_buf);
X	}
X	else {
X	    /*NOSTRICT*/
X#ifndef lint
X	    some_buf = saferealloc(some_buf, (MEM_SIZE)(len_last_line_got));
X#endif /* lint */
X	    rcline[ngnum] = some_buf;
X	}
X    }
X    parse_rcline(ngnum);
X    if (rcchar[ngnum] == NEGCHAR)
X	rcchar[ngnum] = ':';
X    set_toread(ngnum);
X}
X
X/* try to find or add an explicitly specified newsgroup */
X/* returns TRUE if found or added, FALSE if not. */
X/* assumes that we are chdir'ed to SPOOL */
X
X#define ADDNEW_SUB ':'
X#define ADDNEW_UNSUB '!'
X
static int addnewbydefault = 0;
X
bool
get_ng(what,do_reloc)
char *what;
bool_int do_reloc;
X{
X    char *ntoforget;
X    char promptbuf[128];
X    int autosub;
X
X#ifdef VERBOSE
X    IF(verbose)
X	ntoforget = "Type n to forget about this newsgroup.\n";
X    ELSE
X#endif
X#ifdef TERSE
X	ntoforget = "n to forget it.\n";
X#endif
X    if (index(what,'/')) {
X	dingaling();
X	printf("\nBad newsgroup name.\n") FLUSH;
X	return FALSE;
X    }
X    set_ngname(what);
X    ng = find_ng(ngname);
X    if (ng == nextrcline) {		/* not in .newsrc? */
X
X#ifdef SERVER
X	sprintf(ser_line, "GROUP %s", ngname);
X	put_server(ser_line);
X	if (nntp_get(ser_line, sizeof(ser_line)) < 0) {
X	    fprintf(stderr, "\nrrn: Unexpected close of server socket.\n");
X	    finalize(1);
X	}
X	if (*ser_line != CHAR_OK) {
X	    if (atoi(ser_line) != ERR_NOGROUP) {
X		fprintf(stderr, "\nServer response to GROUP %s:\n%s\n",
X		    ngname, ser_line);
X		finalize(1);
X	    }
X#else /* not SERVER */
X
X	if (ng >= maxrcline)		/* check for overflow */
X	    grow_rc_arrays(maxrcline + 25);
X
X	if ((softptr[ng] = findact(buf,ngname,strlen(ngname),0L)) < 0 ) {
X
X#endif /* SERVER */
X
X	    dingaling();
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("\nNewsgroup %s does not exist!\n",ngname) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		printf("\nNo %s!\n",ngname) FLUSH;
X#endif
X	    sleep(2);
X	    return FALSE;
X	}
X	autosub = auto_subscribe(ngname);
X	if (!autosub) autosub = addnewbydefault;
X	if (autosub) {
X		printf("(Adding %s to end of your .newsrc %ssubscribed)\n",
X		       ngname, (autosub == ADDNEW_SUB) ? "" : "un");
X		ng = add_newsgroup(ngname, autosub);
X	        do_reloc = FALSE;
X	} else {
X#ifdef VERBOSE
X	IF(verbose)
X	    sprintf(promptbuf,"\nNewsgroup %s not in .newsrc--subscribe? [ynYN] ",ngname);
X	ELSE
X#endif
X#ifdef TERSE
X	    sprintf(promptbuf,"\nSubscribe %s? [ynYN] ",ngname);
X#endif
reask_add:
X	in_char(promptbuf,'A');
X	setdef(buf,"y");
X#ifdef VERIFY
X	printcmd();
X#endif
X	putchar('\n') FLUSH;
X	if (*buf == 'h') {
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("Type y or SP to add %s to your .newsrc.\nType Y to add all new groups to the end of your .newsrc.\nType N to add all new groups to the end of your .newsrc unsubscribed.\n", ngname)
X		  FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		fputs("y or SP to add, Y to add all new groups, N to add all new groups unsubscribed\n",stdout) FLUSH;
X#endif
X	    fputs(ntoforget,stdout) FLUSH;
X	    goto reask_add;
X	}
X	else if (*buf == 'n' || *buf == 'q') {
X	    ng = add_newsgroup(ngname, '!');
X	    return FALSE;
X	}
X	else if (*buf == 'y') {
X	    ng = add_newsgroup(ngname, ':');
X	    do_reloc = TRUE;
X	}
X	else if (*buf == 'Y') {
X	    fputs(
X    "(I'll add all new newsgroups (subscribed) to the end of your .newsrc.)\n",
X		  stdout);
X	    addnewbydefault = ADDNEW_SUB;
X	    printf("(Adding %s to end of your .newsrc subscribed)\n", ngname);
X	    ng = add_newsgroup(ngname, ':');
X	    do_reloc = FALSE;
X	}
X	else if (*buf == 'N') {
X	    fputs(
X  "(I'll add all new newsgroups (unsubscribed) to the end of your .newsrc.)\n",
X		  stdout);
X	    addnewbydefault = ADDNEW_UNSUB;
X	    printf("(Adding %s to end of your .newsrc unsubscribed)\n", ngname);
X	    ng = add_newsgroup(ngname, '!');
X	    do_reloc = FALSE;
X	}
X	else {
X	    fputs(hforhelp,stdout) FLUSH;
X	    settle_down();
X	    goto reask_add;
X	}
X      }
X    }
X    else if (mode == 'i')		/* adding new groups during init? */
X	return FALSE;
X    else if (rcchar[ng] == NEGCHAR) {	/* unsubscribed? */
X#ifdef VERBOSE
X	IF(verbose)
X	    sprintf(promptbuf,
X"\nNewsgroup %s is currently unsubscribed to--resubscribe? [yn] ",ngname)
X  FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    sprintf(promptbuf,"\n%s unsubscribed--resubscribe? [yn] ",ngname)
X	      FLUSH;
X#endif
reask_unsub:
X	in_char(promptbuf,'R');
X	setdef(buf,"y");
X#ifdef VERIFY
X	printcmd();
X#endif
X	putchar('\n') FLUSH;
X	if (*buf == 'h') {
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("Type y or SP to resubscribe to %s.\n", ngname) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		fputs("y or SP to resubscribe.\n",stdout) FLUSH;
X#endif
X	    fputs(ntoforget,stdout) FLUSH;
X	    goto reask_unsub;
X	}
X	else if (*buf == 'n' || *buf == 'q') {
X	    return FALSE;
X	}
X	else if (*buf == 'y') {
X#ifdef USETHREADS
X	    register char *cp = rcline[ng] + rcnums[ng];
X	    rcchar[ng] = (*cp && cp[1] == '0' ? '0' : ':');
X#else
X	    rcchar[ng] = ':';
X#endif
X	    do_reloc = FALSE;
X	}
X	else {
X	    fputs(hforhelp,stdout) FLUSH;
X	    settle_down();
X	    goto reask_unsub;
X	}
X    }
X
X    /* now calculate how many unread articles in newsgroup */
X
X    set_toread(ng);
X#ifdef RELOCATE
X    if (do_reloc)
X	ng = relocate_newsgroup(ng,-1);
X#endif
X    return toread[ng] >= TR_NONE;
X}
X
X/* add a newsgroup to the .newsrc file (eventually) */
X
NG_NUM
add_newsgroup(ngn, c)
char *ngn;
char_int c;
X{
X    register NG_NUM newng = nextrcline++;
X					/* increment max rcline index */
X
X    if (newng >= maxrcline)		/* check for overflow */
X	grow_rc_arrays(maxrcline + 25);
X
X    rcnums[newng] = strlen(ngn) + 1;
X    rcline[newng] = safemalloc((MEM_SIZE)(rcnums[newng] + 2));
X    strcpy(rcline[newng],ngn);		/* and copy over the name */
X    strcpy(rcline[newng]+rcnums[newng], " ");
X    rcchar[newng] = c;			/* subscribe or unsubscribe */
X    toread[newng] = TR_NONE;	/* just for prettiness */
X#ifdef HASHNG
X    sethash(newng);			/* so we can find it again */
X#endif
X    return newng;
X}
X
X#ifdef RELOCATE
NG_NUM
relocate_newsgroup(ngx,newng)
NG_NUM ngx;
NG_NUM newng;
X{
X    char *dflt = (ngx!=current_ng ? "$^.L" : "$^L");
X    char *tmprcline;
X    ART_UNREAD tmptoread;
X    char tmprcchar;
X    char tmprcnums;
X    ACT_POS tmpsoftptr;
X    register NG_NUM i;
X#if defined(DEBUGGING) || defined(USETHREADS)
X    ART_NUM tmpngmax;
X#endif
X#ifdef CACHEFIRST
X    ART_NUM tmpabs1st;
X#endif
X    
X    starthere = 0;                      /* Disable this optimization */
X    writesoft = TRUE;			/* Update soft pointer file */
X    if (ngx < nextrcline-1) {
X#ifdef HASHNG
X	for (i=0; i<hashsiz; i++) {
X	    if (hashtbl[i] > ngx)
X		--hashtbl[i];
X	    else if (hashtbl[i] == ngx)
X		hashtbl[i] = nextrcline-1;
X	}
X#endif
X	tmprcline = rcline[ngx];
X	tmptoread = toread[ngx];
X	tmprcchar = rcchar[ngx];
X	tmprcnums = rcnums[ngx];
X	tmpsoftptr = softptr[ngx];
X#if defined(DEBUGGING) || defined(USETHREADS)
X	tmpngmax = ngmax[ngx];
X#endif
X#ifdef CACHEFIRST
X	tmpabs1st = abs1st[ngx];
X#endif
X	for (i=ngx+1; i<nextrcline; i++) {
X	    rcline[i-1] = rcline[i];
X	    toread[i-1] = toread[i];
X	    rcchar[i-1] = rcchar[i];
X	    rcnums[i-1] = rcnums[i];
X	    softptr[i-1] = softptr[i];
X#if defined(DEBUGGING) || defined(USETHREADS)
X	    ngmax[i-1] = ngmax[i];
X#endif
X#ifdef CACHEFIRST
X	    abs1st[i-1] = abs1st[i];
X#endif
X	}
X	rcline[nextrcline-1] = tmprcline;
X	toread[nextrcline-1] = tmptoread;
X	rcchar[nextrcline-1] = tmprcchar;
X	rcnums[nextrcline-1] = tmprcnums;
X	softptr[nextrcline-1] = tmpsoftptr;
X#if defined(DEBUGGING) || defined(USETHREADS)
X	ngmax[nextrcline-1] = tmpngmax;
X#endif
X#ifdef CACHEFIRST
X	abs1st[nextrcline-1] = tmpabs1st;
X#endif
X    }
X    if (current_ng > ngx)
X	current_ng--;
X    if (newng < 0) {
X      reask_reloc:
X	unflush_output();		/* disable any ^O in effect */
X#ifdef VERBOSE
X	IF(verbose)
X	    printf("\nPut newsgroup where? [%s] ", dflt);
X	ELSE
X#endif
X#ifdef TERSE
X	    printf("\nPut where? [%s] ", dflt);
X#endif
X	fflush(stdout);
X      reinp_reloc:
X	eat_typeahead();
X	getcmd(buf);
X	if (errno || *buf == '\f') {
X			    /* if return from stop signal */
X	    goto reask_reloc;	/* give them a prompt again */
X	}
X	setdef(buf,dflt);
X#ifdef VERIFY
X	printcmd();
X#endif
X	if (*buf == 'h') {
X#ifdef VERBOSE
X	    IF(verbose) {
X		printf("\n\n\
Type ^ to put the newsgroup first (position 0).\n\
Type $ to put the newsgroup last (position %d).\n", nextrcline-1);
X		printf("\
Type . to put it before the current newsgroup (position %d).\n", current_ng);
X		printf("\
Type -newsgroup name to put it before that newsgroup.\n\
Type +newsgroup name to put it after that newsgroup.\n\
Type a number between 0 and %d to put it at that position.\n", nextrcline-1);
X		printf("\
Type L for a listing of newsgroups and their positions.\n") FLUSH;
X	    }
X	    ELSE
X#endif
X#ifdef TERSE
X	    {
X		printf("\n\n\
X^ to put newsgroup first (pos 0).\n\
X$ to put last (pos %d).\n", nextrcline-1);
X		printf("\
X. to put before current newsgroup (pos %d).\n", current_ng);
X		printf("\
X-newsgroup to put before newsgroup.\n\
X+newsgroup to put after.\n\
number in 0-%d to put at that pos.\n", nextrcline-1);
X		printf("\
L for list of .newsrc.\n") FLUSH;
X	    }
X#endif
X	    goto reask_reloc;
X	}
X	else if (*buf == 'L') {
X	    putchar('\n') FLUSH;
X	    list_newsgroups();
X	    goto reask_reloc;
X	}
X	else if (isdigit(*buf)) {
X	    if (!finish_command(TRUE))	/* get rest of command */
X		goto reinp_reloc;
X	    newng = atol(buf);
X	    if (newng < 0)
X		newng = 0;
X	    if (newng >= nextrcline)
X		return nextrcline-1;
X	}
X	else if (*buf == '^') {
X	    putchar('\n') FLUSH;
X	    newng = 0;
X	}
X	else if (*buf == '$') {
X	    newng = nextrcline-1;
X	}
X	else if (*buf == '.') {
X	    putchar('\n') FLUSH;
X	    newng = current_ng;
X	}
X	else if (*buf == '-' || *buf == '+') {
X	    if (!finish_command(TRUE))	/* get rest of command */
X		goto reinp_reloc;
X	    newng = find_ng(buf+1);
X	    if (newng == nextrcline) {
X		fputs("Not found.",stdout) FLUSH;
X		goto reask_reloc;
X	    }
X	    if (*buf == '+')
X		newng++;
X	}
X	else {
X	    printf("\n%s",hforhelp) FLUSH;
X	    settle_down();
X	    goto reask_reloc;
X	}
X    }
X    if (newng < nextrcline-1) {
X#ifdef HASHNG
X	for (i=0; i<hashsiz; i++) {
X	    if (hashtbl[i] == nextrcline-1)
X		hashtbl[i] = newng;
X	    else if (hashtbl[i] >= newng)
X		++hashtbl[i];
X	}
X#endif
X	tmprcline = rcline[nextrcline-1];
X	tmptoread = toread[nextrcline-1];
X	tmprcchar = rcchar[nextrcline-1];
X	tmprcnums = rcnums[nextrcline-1];
X	tmpsoftptr = softptr[nextrcline-1];
X#if defined(DEBUGGING) || defined(USETHREADS)
X	tmpngmax = ngmax[nextrcline-1];
X#endif
X#ifdef CACHEFIRST
X	tmpabs1st = abs1st[nextrcline-1];
X#endif
X	for (i=nextrcline-2; i>=newng; i--) {
X	    rcline[i+1] = rcline[i];
X	    toread[i+1] = toread[i];
X	    rcchar[i+1] = rcchar[i];
X	    rcnums[i+1] = rcnums[i];
X	    softptr[i+1] = softptr[i];
X#if defined(DEBUGGING) || defined(USETHREADS)
X	    ngmax[i+1] = ngmax[i];
X#endif
X#ifdef CACHEFIRST
X	    abs1st[i+1] = abs1st[i];
X#endif
X	}
X	rcline[newng] = tmprcline;
X	toread[newng] = tmptoread;
X	rcchar[newng] = tmprcchar;
X	rcnums[newng] = tmprcnums;
X	softptr[newng] = tmpsoftptr;
X#if defined(DEBUGGING) || defined(USETHREADS)
X	ngmax[newng] = tmpngmax;
X#endif
X#ifdef CACHEFIRST
X	abs1st[newng] = tmpabs1st;
X#endif
X    }
X    if (current_ng >= newng)
X	current_ng++;
X    return newng;
X}
X#endif
X
X/* List out the newsrc with annotations */
X
void
list_newsgroups()
X{
X    register NG_NUM i;
X    char tmpbuf[2048];
X    static char *status[] = {"(READ)","(UNSUB)","(BOGUS)","(JUNK)"};
X    int cmd;
X
X    page_init();
X    print_lines("\
X  #  Status  Newsgroup\n\
X",STANDOUT);
X    for (i=0; i<nextrcline && !int_count; i++) {
X	if (toread[i] >= 0)
X	    set_toread(i);
X#ifdef USETHREADS
X	*(rcline[i] + rcnums[i] - 1) = RCCHAR(rcchar[i]);
X#else
X	*(rcline[i] + rcnums[i] - 1) = rcchar[i];
X#endif
X	if (toread[i] > 0)
X	    sprintf(tmpbuf,"%3d %6ld   ",i,(long)toread[i]);
X	else
X	    sprintf(tmpbuf,"%3d %7s  ",i,status[-toread[i]]);
X	safecpy(tmpbuf+13,rcline[i],2034);
X	*(rcline[i] + rcnums[i] - 1) = '\0';
X	if (cmd = print_lines(tmpbuf,NOMARKING)) {
X	    if (cmd > 0)
X		pushchar(cmd);
X	    break;
X	}
X    }
X    int_count = 0;
X}
X
X/* find a newsgroup in .newsrc */
X
NG_NUM
find_ng(ngnam)
char *ngnam;
X{
X    register NG_NUM ngnum;
X#ifdef HASHNG
X    register int hashix = hash(ngnam);
X    register int incr = 1;
X
X    while ((ngnum = hashtbl[hashix]) >= 0) {
X	if (strEQ(rcline[ngnum], ngnam) && toread[ngnum] >= TR_UNSUB)
X	    return ngnum;
X	hashix = (hashix + incr) % hashsiz;
X	incr += 2;			/* offsets from original are in n*2 */
X    }
X    return nextrcline;			/* = notfound */
X
X#else /* just do linear search */
X
X    for (ngnum = 0; ngnum < nextrcline; ngnum++) {
X	if (strEQ(rcline[ngnum],ngnam))
X	    break;
X    }
X    return ngnum;
X#endif
X}
X
void
cleanup_rc()
X{
X    register NG_NUM ngx;
X    register NG_NUM bogosity = 0;
X
X#ifdef VERBOSE
X    IF(verbose)
X	fputs("Checking out your .newsrc--hang on a second...\n",stdout)
X	  FLUSH;
X    ELSE
X#endif
X#ifdef TERSE
X	fputs("Checking .newsrc--hang on...\n",stdout) FLUSH;
X#endif
X    for (ngx = 0; ngx < nextrcline; ngx++) {
X	if (toread[ngx] >= TR_UNSUB) {
X	    set_toread(ngx);		/* this may reset newsgroup */
X					/* or declare it bogus */
X	}
X	if (toread[ngx] == TR_BOGUS)
X	    bogosity++;
X    }
X    for (ngx = nextrcline-1; ngx >= 0 && toread[ngx] == TR_BOGUS; ngx--)
X	bogosity--;			/* discount already moved ones */
X    if (nextrcline > 5 && bogosity > nextrcline / 2) {
X	fputs(
X"It looks like the active file is messed up.  Contact your news administrator,\n\
X",stdout);
X	fputs(
X"leave the \"bogus\" groups alone, and they may come back to normal.  Maybe.\n\
X",stdout) FLUSH;
X    }
X#ifdef RELOCATE
X    else if (bogosity) {
X#ifdef VERBOSE
X	IF(verbose)
X	    fputs("Moving bogus newsgroups to the end of your .newsrc.\n",
X		stdout) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    fputs("Moving boguses to the end.\n",stdout) FLUSH;
X#endif
X	for (; ngx >= 0; ngx--) {
X	    if (toread[ngx] == TR_BOGUS)
X		relocate_newsgroup(ngx,nextrcline-1);
X	}
X#ifdef DELBOGUS
reask_bogus:
X	in_char("Delete bogus newsgroups? [ny] ", 'D');
X	setdef(buf,"n");
X#ifdef VERIFY
X	printcmd();
X#endif
X	putchar('\n') FLUSH;
X	if (*buf == 'h') {
X#ifdef VERBOSE
X	    IF(verbose)
X		fputs("\
Type y to delete bogus newsgroups.\n\
Type n or SP to leave them at the end in case they return.\n\
X",stdout) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		fputs("y to delete, n to keep\n",stdout) FLUSH;
X#endif
X	    goto reask_bogus;
X	}
X	else if (*buf == 'n' || *buf == 'q')
X	    ;
X	else if (*buf == 'y') {
X	    while (toread[nextrcline-1] == TR_BOGUS && nextrcline > 0)
X		--nextrcline;		/* real tough, huh? */
X	}
X	else {
X	    fputs(hforhelp,stdout) FLUSH;
X	    settle_down();
X	    goto reask_bogus;
X	}
X#endif
X    }
X#else
X#ifdef VERBOSE
X    IF(verbose)
X	fputs("You should edit bogus newsgroups out of your .newsrc.\n",
X	    stdout) FLUSH;
X    ELSE
X#endif
X#ifdef TERSE
X	fputs("Edit boguses from .newsrc.\n",stdout) FLUSH;
X#endif
X#endif
X    paranoid = FALSE;
X}
X
X#ifdef HASHNG
X/* make an entry in the hash table for the current newsgroup */
X
void
sethash(thisng)
NG_NUM thisng;
X{
X    register int hashix = hash(rcline[thisng]);
X    register int incr = 1;
X#ifdef DEBUGGING
X    static int hashhits = 0, hashtries = 0;
X#endif
X
X#ifdef DEBUGGING
X    hashtries++;
X#endif
X    while (hashtbl[hashix] >= 0) {
X#ifdef DEBUGGING
X	hashhits++;
X	if (debug & DEB_HASH) {
X	    printf("  Hash hits: %d / %d\n",hashhits, hashtries) FLUSH;
X	}
X	hashtries++;
X#endif
X	hashix = (hashix + incr) % hashsiz;
X	incr += 2;			/* offsets from original are in n*2 */
X    }
X    hashtbl[hashix] = thisng;
X}
X
short prime[] = {1,2,-3,-5,7,11,-13,-17,19,23,-29,-31,37,41,-43,-47,53,57,-59,
X    -61,67,71,-73,-79,83,89,-97,-101,1,1,1,1,1,1,1,1,1,1,1,1};
X
int
hash(ngnam)
register char *ngnam;
X{
X    register int i = 0;
X    register int ch;
X    register int sum = 0;
X#ifdef DEBUGGING
X    char *ngn = ngnam;
X#endif
X
X    while (ch = *ngnam++) {
X	sum += (ch + i) * prime[i];   /* gives ~ 10% hits at 25% full */
X	i++;
X    }
X#ifdef DEBUGGING
X    if (debug & DEB_HASH)
X	printf("hash(%s) => %d => %d\n",ngn, sum, (sum<0?-sum:sum)%hashsiz)
X	  FLUSH;
X#endif
X    if (sum < 0)
X	sum = -sum;
X    return (sum % hashsiz);
X}
X
X#endif
X
void
newsrc_check()
X{
X    rcfp = fopen(rcname,"r");		/* open it */
X    if (rcfp == Nullfp) {			/* not there? */
X#ifdef VERBOSE
X	IF(verbose)
X	    fputs("\nTrying to set up a .newsrc file--running newsetup...\n\n\
X",stdout) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    fputs("Setting up .newsrc...\n",stdout) FLUSH;
X#endif
X	if (doshell(sh,filexp(NEWSETUP)) ||
X	    (rcfp = fopen(rcname,"r")) == Nullfp) {
X#ifdef VERBOSE
X	    IF(verbose)
X		fputs("\nCan't create a .newsrc--you must do it yourself.\n\
X",stdout) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		fputs("(Fatal)\n",stdout) FLUSH;
X#endif
X	    finalize(1);
X	}
X    }
X    else {
X	UNLINK(rcbname);		/* unlink backup file name */
X	link(rcname,rcbname);		/* and backup current name */
X    }
X}
X
X/* write out the (presumably) revised .newsrc */
X
void
write_rc()
X{
X    register NG_NUM tmpng;
X    register char *delim;
X
X    rcfp = fopen(rctname, "w");		/* open .newnewsrc */
X    if (rcfp == Nullfp) {
X	printf(cantrecreate,".newsrc") FLUSH;
X	finalize(1);
X    }
X    if (stat(rcname,&filestat)>=0) {	/* preserve permissions */
X	chmod(rctname,filestat.st_mode&0666);
X	chown(rctname,filestat.st_uid,filestat.st_gid);	/* if possible */
X    }
X
X    /* write out each line*/
X
X    for (tmpng = 0; tmpng < nextrcline; tmpng++) {
X	if (rcnums[tmpng]) {
X	    delim = rcline[tmpng] + rcnums[tmpng] - 1;
X#ifdef USETHREADS
X	    *delim = RCCHAR(rcchar[tmpng]);
X	    if (rcchar[tmpng] == '0' && delim[2] == '1')
X		delim[2] = '0';
X#else
X	    *delim = rcchar[tmpng];
X#endif
X	}
X	else
X	    delim = Nullch;
X#ifdef DEBUGGING
X	if (debug & DEB_NEWSRC_LINE)
X	    printf("%s\n",rcline[tmpng]) FLUSH;
X#endif
X	if (fprintf(rcfp,"%s\n",rcline[tmpng]) < 0) {
X	write_error:
X	    printf(cantrecreate,".newsrc") FLUSH;
X	    fclose(rcfp);		/* close .newnewsrc */
X	    UNLINK(rctname);
X	    finalize(1);
X	}
X	if (delim) {
X	    *delim = '\0';		/* might still need this line */
X#ifdef USETHREADS
X	    if (rcchar[tmpng] == '0' && delim[2] == '0')
X		delim[2] = '1';
X#endif
X	}
X    }
X    fflush(rcfp);
X    if (ferror(rcfp))
X	goto write_error;
X
X    fclose(rcfp);			/* close .newnewsrc */
X    UNLINK(rcname);
X#ifdef RENAME
X    rename(rctname,rcname);
X#else
X    link(rctname,rcname);
X    UNLINK(rctname);
X#endif
X
X    if (writesoft) {
X	tmpfp = fopen(filexp(softname), "w");	/* open .rnsoft */
X	if (tmpfp == Nullfp) {
X	    printf(cantcreate,filexp(softname)) FLUSH;
X	    return;
X	}
X	for (tmpng = 0; tmpng < nextrcline; tmpng++) {
X	    fprintf(tmpfp,"%ld\n",(long)softptr[tmpng]);
X	}
X	fclose(tmpfp);
X    }
X}
X
void
get_old_rc()
X{
X    UNLINK(rctname);
X#ifdef RENAME
X    rename(rcname,rctname);
X    rename(rcbname,rcname);
X#else
X    link(rcname,rctname);
X    UNLINK(rcname);
X    link(rcbname,rcname);
X    UNLINK(rcbname);
X#endif
X}
X
static char *
grow(ptr, elem, size)
char *ptr;
int elem;
int size;
X{
X    if (ptr != NULL)
X	return saferealloc(ptr, (MEM_SIZE)elem * size);
X    else
X	return safemalloc((MEM_SIZE)elem * size);
X}
X
static void
grow_rc_arrays(newsize)
int newsize;
X{
X#if defined(CACHEFIRST) || defined(USETHREADS)
X    register int i;
X#endif
X
X#ifdef CACHEFIRST
X    abs1st = (ART_NUM *) grow((char*)abs1st, newsize, sizeof(ART_NUM));
X#endif
X#if defined(DEBUGGING) || defined(USETHREADS)
X    ngmax = (ART_NUM *) grow((char*)ngmax, newsize, sizeof(ART_NUM));
X#endif
X    rcline = (char **) grow((char*)rcline, newsize, sizeof(char*));
X    toread = (ART_UNREAD *) grow((char*)toread, newsize, sizeof(ART_UNREAD));
X    rcchar = (char *) grow(rcchar, newsize, sizeof(char));
X    rcnums = (char *) grow(rcnums, newsize, sizeof(char));
X    softptr = (ACT_POS *) grow((char*)softptr, newsize, sizeof(ACT_POS));
X
X#if defined(CACHEFIRST) || defined(USETHREADS)
X    for (i=maxrcline; i < newsize; i++) {
X# ifdef CACHEFIRST
X	abs1st[i] = 0;
X# endif
X# ifdef USETHREADS
X	ngmax[i] = 0;
X# endif
X    }
X#endif /* CACHEFIRST || USETHREADS */
X    maxrcline = newsize;
X    return;
X}
END_OF_FILE
if test 27693 -ne `wc -c <'rcstuff.c'`; then
    echo shar: \"'rcstuff.c'\" unpacked with wrong size!
fi
# end of 'rcstuff.c'
fi
echo shar: End of archive 9 \(of 13\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 13 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
