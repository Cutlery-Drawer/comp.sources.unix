Newsgroups: comp.sources.unix
From: bruce@beta.cs.su.oz.au (Bruce Janson)
Subject: v25i157: trash - simulate process execution in MIPS RISC/os 4.52, Part03/08
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: bruce@beta.cs.su.oz.au (Bruce Janson)
Posting-Number: Volume 25, Issue 157
Archive-Name: trash/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 8)."
# Contents:  DIFFS i_c.c i_s.c main.c
# Wrapped by bruce@basser on Tue Mar  3 23:25:22 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'DIFFS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'DIFFS'\"
else
echo shar: Extracting \"'DIFFS'\" \(14311 characters\)
sed "s/^X//" >'DIFFS' <<'END_OF_FILE'
XMon Jun 24 ??:??:?? EST 1991
Xsysv.c:		sys_recvfrom(): was copying out junk into *fromlenp
X
XTue Jun 25 07:21:56 EST 1991
Xbsd43.c:	*(): replaced some quiet_proc* with mget/mput
X
XWed Jun 26 16:21:11 EST 1991
Xbsd43.c:	*(): replaced some quiet_proc* with mget/mput
X
XSat Jun 29 01:52:57 EST 1991
Xgo.c:		go(): print out pc with "unrecognised instrn" message
X
XSat Jun 29 01:53:45 EST 1991
Xoptab.c:	added some i_c*() instructions
Xi_c.c:			"
X
XSat Jun 29 23:49:21 EST 1991
Xi_syscall.c:	result spec. for syscalls that return 2 results
Xbsd43.c:		"
Xsysv.c:			"
Xmakefile:	incorporated *.u support
X
XTue Jul  2 13:06:27 EST 1991
Xmakefile:	tidied up .u/utrash strand
Xtrash.1:	added H desc.
X
XTue Jul  2 13:07:17 EST 1991
Xmakefile:	replaced cc with /bin/cc
X
XTue Jul  2 23:41:31 EST 1991
Xi_syscall.c:	'u' = unsigned long type
Xbsd43.c:		"
Xsysv.c:			"
X
XWed Jul  3 23:07:19 EST 1991
Xi_syscall.c:	replaced explicit syscall table lookup with function call
Xbsd43.c:	defined function for above and removed global variables
Xsysv.c:			"
Xposix.c:		"
X
XThu Jul  4 00:50:19 EST 1991
Xsysv.c:		added some basser-specific syscall support (LIMITS, SHARE)
Xmuck:		created: basser use only -- the right #defines don't exist
X
XFri Jul  5 22:32:37 EST 1991
Xi_syscall.c:	(suggestion: greg@cxsyd.cx.oz.au) rationalised I/O
X		data escapes
X
XSat Jul  6 01:25:23 EST 1991
Xi_syscall.c:	(suggestion: greg@cxsyd.cx.oz.au) changed time
X		representation
Xbsd43.c:		"
Xsysv.c:			"
X
XTue Jul 16 03:47:35 EST 1991
X<various>:	added vcouldnot()
X
XSat Jul 20 02:14:18 EST 1991
Xi_d.c:		added "divide by 0" checks
X
XWed Aug  7 17:21:35 EST 1991
Xsysv.c:		made sysv signal() work for SIG_IGN and SIG_DFL
X
XWed Aug  7 17:22:31 EST 1991
Xsysv.c:		added support for fcntl(.., F_SETLK, ..)
X
XThu Aug  8 11:50:29 EST 1991
Xmain.c:		added version_string and "-v"
X
XFri Aug  9 02:36:45 EST 1991
Xmain.c:		fixed bug in canonical argument format ("-sh" was
X		being interpreted as further arguments by getopt()
X		rather than as argv[0])
X
XFri Aug  9 02:38:42 EST 1991
Xmain.c:		added support for "#!" executable interpreter scripts
Xsysv.c:			"
Xbsd43.c:		"
Xprocess.c:		"
Xload.c:			"
X
XSat Aug 17 13:26:21 EST 1991
Xprocess.h:	typo in Procmgettextword(): changed "unsigned char"
X			to "unsigned char *"
X
XSun Aug 18 03:42:07 EST 1991
Xmakefile:	added dependencies for .u support
X
XSun Aug 18 03:42:38 EST 1991
Xprocess.h:	improved calculation of taddr in Procmgettextword()
X
XMon Aug 19 22:38:26 EST 1991
Xflag.h:		isolated common flag print code
Xbsd43.c:		"
Xsysv.c:			"
X
XMon Aug 19 22:38:36 EST 1991
Xbsd43.c:	made bsd43 sigvec() work for SIG_IGN and SIG_DFL, plus
X			other minor sig fixes
X
XFri Aug 30 21:05:27 EST 1991
Xmain.c:		sent out first of Version 1
X
XWed Sep  4 19:35:11 EST 1991
Xsysv.c:		added (incomplete) defn of sigreturn()
X
XThu Sep  5 16:51:10 EST 1991
Xsysv.c:		added (undocumented) SETOWN to sys_fcntl()
X
XMon Sep  9 01:59:48 EST 1991
Xsysv.c:		completed (sysv) signal support
X
XMon Sep  9 02:00:43 EST 1991
Xsysv.c:		enabled alarm() syscall
X
XMon Sep  9 19:58:42 EST 1991
Xsysv.c:		removed "bsd.h"
Xmakefile:	removed "bsd.h"
X
XMon Sep  9 20:58:22 EST 1991
Xi_syscall.c:	formats for wait3 args
Xsysv.c:		formats for wait3 args
X
XTue Sep 10 00:02:08 EST 1991
Xi_syscall.c:	format for times args
X
XTue Sep 10 19:54:11 EST 1991
Xsysv.c:		fixed bug in sigreturn -- don't overwrite registers on return
X
XSat Sep 14 01:29:27 EST 1991
Xmyldopen.c:	(bug: greg@cxsyd.cx.oz.au) fixed EBADF bug in myldopen()
X
XTue Sep 24 20:28:44 EST 1991
Xsysv.c:		delayed sigrelse() call until just before next instrn
Xgo.c:		delayed sigrelse() call until just before next instrn
X
XFri Oct 11 15:37:50 EST 1991
Xprocess.c:	(bug: roy@cs.su.oz.au) vcouldnot() error messages during startup
Xsyms.c:		(bug: roy@cs.su.oz.au) vcouldnot() error messages during startup
X
XMon Oct 14 20:02:46 EST 1991
Xsysv.c:		sysv_utssys() ustat() support
X
XSat Oct 26 21:04:42 EST 1991
Xbsd43.c:	(bug: kmk@cc.tut.fi) sys_statfs() was using wrong args
X
XSat Oct 26 21:26:24 EST 1991
Xmain.c:		sent out first of Version 2
X
XWed Oct 30 02:49:04 EST 1991
Xbsd43.c:	added support for bsd43_sysmips(.., HWCONF, ..)
Xbsd43.c:	tidied up code for bsd43_sysmips(.., GETRUSAGE, ..)
X
XWed Oct 30 03:11:00 EST 1991
Xbsd43.c:	added support for bsd43_ioctl(.., FLIOC_SENSE_DRIVE, ..)
X
XSat Nov  9 05:05:17 EST 1991
Xload.c:		replaced procmput() with a quiet_procmput() -- odd...
X
XWed Nov 13 17:07:11 EST 1991
Xmain.c:		added support for C flag
Xprocess.h:	added support for C flag
Xprocess.c:	added support for C flag
Xtrash.1:	added support for C flag
X
XWed Nov 13 17:59:46 EST 1991
Xsysv.c:		rearrangements for interconnected sys_ioctl
Xbsd43.c:	rearrangements for interconnected sys_ioctl
Xsgttyb.c:	rearrangements for interconnected sys_ioctl
X
XThu Nov 14 16:50:00 EST 1991
Xsysv.c:		added support for sysv_ioctl(.., oFIO[N]CLEX, ..)
X
XSat Nov 16 01:28:44 EST 1991
Xi_syscall.c:	ensure -P behaviour after encountering unimplemented
X		syscall feature
X
XSat Nov 16 19:15:14 EST 1991
Xsysv.c:		added support for MTIOCGET
X
XSat Nov 16 21:08:09 EST 1991
Xsysv.c:		added support for MTIOCTOP
X
XSat Nov 16 21:08:09 EST 1991
Xbsd43.c:	added support for bsd43_sysmips(BSD43_MIPS_WAIT3, ..)
X
XSun Dec  8 14:17:14 EST 1991
Xi_syscall.c:	print correct field of sockaddr_in in say_addr()
X
XSun Dec  8 16:11:13 EST 1991
Xmain.c:		extend Aflag to show execve() env vector
Xi_syscall.c:	extend Aflag to show execve() env vector
Xsysv.c:		extend Aflag to show execve() env vector
Xbsd43.c:	extend Aflag to show execve() env vector
Xtrash.1:	extend Aflag to show execve() env vector
X
XSun Dec  8 16:16:58 EST 1991
Xmakefile:	increased -Olimit from 571 to 600
X
XTue Dec 31 15:38:12 EST 1991
Xprocess.h:	added support for NMAGIC (both types) and OMAGIC files
Xprocess.c:	added support for NMAGIC (both types) and OMAGIC files
X
XTue Dec 31 17:36:48 EST 1991
Xmakefile:	added comment about use of CHMOD
X
XThu Jan  2 10:20:53 EST 1992
Xsysv.c:		fixed inherited fd bug
Xbsd43.c:	fixed inherited fd bug
Xmain.c:		fixed inherited fd bug
Xprocess.c:	fixed inherited fd bug
Xsyms.c:		fixed inherited fd bug
Xmakefile:	fixed inherited fd bug
Xload.c:		fixed inherited fd bug
Xfd.c:		fixed inherited fd bug
Xtrash.1:	fixed inherited fd bug
X
XMon Jan  6 11:50:54 EST 1992
Xprocess.c:	fflush log file in procclose()
X
XMon Jan  6 11:53:37 EST 1992
Xfd.c:		fd_invalid() now sets EBADF
X
XMon Jan  6 11:54:43 EST 1992
Xmakefile:	added entries for generic.[chou]
Xgeneric.c:	created
Xgeneric.h:	created
Xsysv.c:		replaced syscalls with generics
Xbsd43.c:	replaced syscalls with generics
Xi_syscall.c:	now explicitly passes syscallno to syscall
X
XMon Jan  6 12:04:21 EST 1992
Xsysv.c:		added support for /proc fcntl()'s
X
XMon Jan  6 23:52:57 EST 1992
Xsysv.c:		added support for ioctl(TCSETA[FW]) arg printing
X
XTue Jan  7 18:59:49 EST 1992
Xsysv.c:		added support for fcntl(PFCSTOP)
X
XTue Jan  7 19:05:08 EST 1992
Xi_syscall.c:	added support for /proc fcntl() cmd printing
X
XTue Jan  7 20:01:50 EST 1992
Xi_syscall.c:	rationalised post-syscall return_errno code slightly
X
XTue Jan  7 21:12:53 EST 1992
Xprocess.c:	proc_mget() and proc_mput() now do nothing when length == 0
X
XTue Jan  7 21:46:33 EST 1992
Xsysv.c:		added support for fcntl(PFCGETPR)
Xi_syscall.c:	added support for fcntl(PFCGETPR)
X
XThu Jan  9 23:49:55 EST 1992
Xsysv.c:		made sys_ofcntl() more like sys_fcntl()
X
XFri Jan 10 00:47:03 EST 1992
Xsysv.c:		sysv_SIGNAL() now prints truncated form unless Aflag
X
XMon Jan 13 18:47:12 EST 1992
Xsysv.c:		setpgrp() has 1 argument, not 0
X
XMon Jan 13 23:55:26 EST 1992
Xgeneric.c:	added PIXIE test in exit
X
XSat Jan 18 14:33:31 EST 1992
Xi_syscall.c:	extend Aflag to show execve() arg vector
Xtrash.1:	extend Aflag to show execve() arg vector
X
XThu Jan 23 00:48:57 EST 1992
Xcouldnot.c:	flush outfp before _exit()
Xvcouldnot.c:	flush outfp before _exit()
X
XThu Jan 23 01:38:41 EST 1992
Xmakefile:	-O3 rather than -O4: seemed to run faster...
X
XThu Jan 23 01:39:17 EST 1992
Xgeneric.c:	if defined(PIXIE) then exit() else _exit()
X
XThu Jan 23 01:39:54 EST 1992
Xentry.h:	created: hashed table of binary trees of decoded instrn pages
Xdiblock.c:	created: hashed table of binary trees of decoded instrn pages
Xdiblock.h:	created: hashed table of binary trees of decoded instrn pages
Xtalloc.h:	created: hashed table of binary trees of decoded instrn pages
X
XThu Jan 23 01:40:04 EST 1992
Xregister.h:	changed to threaded decoded instruction scheme
Xvcouldnot.c:	changed to threaded decoded instruction scheme
Xgeneric.c:	changed to threaded decoded instruction scheme
Xhistory.c:	changed to threaded decoded instruction scheme
Xload.c:		changed to threaded decoded instruction scheme
Xoptab.c:	changed to threaded decoded instruction scheme
Xi_o.c:		changed to threaded decoded instruction scheme
Xi_x.c:		changed to threaded decoded instruction scheme
Xi_n.c:		changed to threaded decoded instruction scheme
Xinstruction.h:	changed to threaded decoded instruction scheme
Xi_u.c:		changed to threaded decoded instruction scheme
Xi_syscall.c:	changed to threaded decoded instruction scheme
Xi_d.c:		changed to threaded decoded instruction scheme
Xi_m.c:		changed to threaded decoded instruction scheme
Xi_s.c:		changed to threaded decoded instruction scheme
Xi_a.c:		changed to threaded decoded instruction scheme
Xi_b.c:		changed to threaded decoded instruction scheme
Xsysv.c:		changed to threaded decoded instruction scheme
Xi_j.c:		changed to threaded decoded instruction scheme
Xbsd43.c:	changed to threaded decoded instruction scheme
Xi_l.c:		changed to threaded decoded instruction scheme
Xprocess.h:	changed to threaded decoded instruction scheme
Xgo.c:		changed to threaded decoded instruction scheme
Xi_c.c:		changed to threaded decoded instruction scheme
Xprocess.c:	changed to threaded decoded instruction scheme
Xmakefile:	changed to threaded decoded instruction scheme
X
XThu Jan 23 10:15:42 EST 1992
Xsysv.c:		added support for sysfs()
X
XFri Jan 24 21:03:24 EST 1992
Xgeneric.c:	replaced most calls to mgetstring() with mgets()
Xi_syscall.c:	replaced most calls to mgetstring() with mgets()
Xbsd43.c:	replaced most calls to mgetstring() with mgets()
Xsysv.c:		replaced most calls to mgetstring() with mgets()
X
XSun Jan 26 22:43:26 EST 1992
Xmain.c:		Version 3
X
XTue Jan 28 00:22:52 EST 1992
Xgetprbyno.c:	changed to getprbyno.c from getprotobynumber.c (>12 chars)
Xmakefile:	changed to getprbyno.c from getprotobynumber.c (>12 chars)
X
XTue Jan 28 00:27:31 EST 1992
Xinstrn.h:	changed to instrn.h from instruction.h (>12 chars)
Xmakefile:	changed to instrn.h from instruction.h (>12 chars)
X*.c:		changed to instrn.h from instruction.h (>12 chars)
X
XWed Jan 29 18:38:08 EST 1992
Xprocess.c:	reject processes that call shared libraries
X
XWed Jan 29 18:38:57 EST 1992
Xvcouldnot.c:	checked dipc before indirecting through it
X
XWed Feb  5 22:57:16 EST 1992
XREADME:		added ack to Robert Bedichek
X
XFri Feb  7 20:56:59 EST 1992
Xsysv.c:		(bug: roy@cs.su.oz.au) added support for poll()
X
XMon Feb 10 13:19:17 EST 1992
Xinstrn.h:	dipc now an argument and handlers now return dinstrn *
Xoptab.c:	dipc now an argument and handlers now return dinstrn *
Xdiblock.h:	dipc now an argument and handlers now return dinstrn *
Xdiblock.c:	dipc now an argument and handlers now return dinstrn *
Xgo.c:		dipc now an argument and handlers now return dinstrn *
Xbsd43.c:	dipc now an argument and handlers now return dinstrn *
Xgeneric.c:	dipc now an argument and handlers now return dinstrn *
Xhistory.c:	dipc now an argument and handlers now return dinstrn *
Xload.c:		dipc now an argument and handlers now return dinstrn *
Xprocess.c:	dipc now an argument and handlers now return dinstrn *
Xsysv.c:		dipc now an argument and handlers now return dinstrn *
Xvcouldnot.c:	dipc now an argument and handlers now return dinstrn *
Xprocess.h:	dipc now an argument and handlers now return dinstrn *
Xi_*.c:		dipc now an argument and handlers now return dinstrn *
X
XMon Feb 10 13:28:26 EST 1992
Xmain.c:		vcouldnot() -> couldnot()
X
XMon Feb 10 22:45:50 EST 1992
Xfd.c:		removed extern decls of *couldnot()
Xprocess.c:	removed extern decls of *couldnot()
X
XMon Feb 10 22:45:55 EST 1992
Xmain.c:		Version 4
X
XMon Feb 10 22:46:03 EST 1992
Xi_j.c:		tidied up a little
X
XMon Feb 10 22:46:03 EST 1992
Xprocess.h:	moved quiet_procmget_word() into i_l.c
Xi_l.c:		moved quiet_procmget_word() into i_l.c
Xprocess.h:	moved quiet_procmput_word() into i_s.c
Xi_s.c:		moved quiet_procmput_word() into i_s.c
X
XMon Feb 10 22:46:03 EST 1992
Xi_l.c:		added new handlers
Xi_s.c:		added new handlers
X
XTue Feb 11 01:30:00 EST 1992
Xi_a.c:		added explicit calls to "c_" routines from "i_" routines
Xi_b.c:		added explicit calls to "c_" routines from "i_" routines
Xi_d.c:		added explicit calls to "c_" routines from "i_" routines
Xi_j.c:		added explicit calls to "c_" routines from "i_" routines
Xi_l.c:		added explicit calls to "c_" routines from "i_" routines
Xi_m.c:		added explicit calls to "c_" routines from "i_" routines
Xi_s.c:		added explicit calls to "c_" routines from "i_" routines
X
XTue Feb 11 05:00:00 EST 1992
Xi_l.c:		parameterised quiet_procm??t_word() to work with char, short and long
X
XFri Feb 14 00:45:42 EST 1992
Xmakefile:	added PFLAG
X
XSat Feb 15 01:38:59 EST 1992
Xprocess.h:	replaced calls to mget() with calls to "in-place" dmget()
Xprocess.c:	replaced calls to mget() with calls to "in-place" dmget()
Xbsd43.c:	replaced calls to mget() with calls to "in-place" dmget()
Xgeneric.c:	replaced calls to mget() with calls to "in-place" dmget()
Xi_syscall.c:	replaced calls to mget() with calls to "in-place" dmget()
Xsysv.c:		replaced calls to mget() with calls to "in-place" dmget()
X
XSat Feb 15 19:06:41 EST 1992
Xprocess.c:	added "wcache": load/store memory access cache
Xwcache.c:	added "wcache": load/store memory access cache
Xwcache.h:	added "wcache": load/store memory access cache
Xmakefile:	added "wcache": load/store memory access cache
Xi_l.c:		added "wcache": load/store memory access cache
Xi_s.c:		added "wcache": load/store memory access cache
X
XMon Feb 17 20:40:18 EST 1992
Xi_l.c:		tidied up quiet_procmget_word()
Xi_s.c:		tidied up quiet_procmput_word()
X
XMon Feb 17 20:41:35 EST 1992
Xprocess.h:	rearranged some statements -- seemed to generate faster code
X
XFri Feb 28 20:34:00 EST 1992
Xsysv.c:		bug: sysv_print_sigcontext() now returns an int as declared
X
XFri Feb 28 22:05:10 EST 1992
Xi_a.c:		speedup: added c_addi()
Xi_s.c:		speedup: added c_slt()
X
XSat Feb 29 21:49:31 EST 1992
Xgo.c:		changed "emergency" tracing code slightly in interpret()
Xi_s.c:		bug: fixed in c_slt()
X
XTue Mar  3 23:00:52 EST 1992
Xmain.c:		Version 5
END_OF_FILE
if test 14311 -ne `wc -c <'DIFFS'`; then
    echo shar: \"'DIFFS'\" unpacked with wrong size!
fi
# end of 'DIFFS'
fi
if test -f 'i_c.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'i_c.c'\"
else
echo shar: Extracting \"'i_c.c'\" \(8817 characters\)
sed "s/^X//" >'i_c.c' <<'END_OF_FILE'
X#include	"register.h"
X#include	"symtab.h"
X#include	"diblock.h"
X#include	"instrn.h"
X#include	"process.h"
X
Xdinstrn	*
Xi_ceq(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint		fmt;
Xint		ft;
Xint		fs;
Xint		fd;
X{
X	float		singles;
X	float		singlet;
X	double		doubles;
X	double		doublet;
X	int		result;
X	unsigned long	cs;
X
X	/*
X	 * equal
X	 */
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singles);
X
X		procsget(CP1G(ft), *(unsigned long *)&singlet);
X
X		result = (singles == singlet);
X
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doubles + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doubles);
X
X		procsget(CP1G(ft), *((unsigned long *)&doublet + 1));
X
X		procsget(CP1G(ft) + 1, *(unsigned long *)&doublet);
X
X		result = (doubles == doublet);
X
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	procsget(CP1CS, cs);
X
X	Set_Cond(cs, result);
X
X	procsput(CP1CS, cs);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_cfc1(dipc, rt, fs)
Xdinstrn	*dipc;
Xint		rt;
Xint		fs;
X{
X	unsigned long	s;
X
X	procsget(CP1C(fs), s);
X
X	procsput(rt, s);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_cle(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint		fmt;
Xint		ft;
Xint		fs;
Xint		fd;
X{
X	float		singles;
X	float		singlet;
X	double		doubles;
X	double		doublet;
X	int		result;
X	unsigned long	cs;
X
X	/*
X	 * less than || equal
X	 *
X	 * TODO: exception if unordered
X	 */
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singles);
X
X		procsget(CP1G(ft), *(unsigned long *)&singlet);
X
X		result = (singles <= singlet);
X
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doubles + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doubles);
X
X		procsget(CP1G(ft), *((unsigned long *)&doublet + 1));
X
X		procsget(CP1G(ft) + 1, *(unsigned long *)&doublet);
X
X		result = (doubles <= doublet);
X
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	procsget(CP1CS, cs);
X
X	Set_Cond(cs, result);
X
X	procsput(CP1CS, cs);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_clt(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint		fmt;
Xint		ft;
Xint		fs;
Xint		fd;
X{
X	float		singles;
X	float		singlet;
X	double		doubles;
X	double		doublet;
X	int		result;
X	unsigned long	cs;
X
X	/*
X	 * less than
X	 *
X	 * TODO: exception if unordered
X	 */
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singles);
X
X		procsget(CP1G(ft), *(unsigned long *)&singlet);
X
X		result = (singles < singlet);
X
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doubles + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doubles);
X
X		procsget(CP1G(ft), *((unsigned long *)&doublet + 1));
X
X		procsget(CP1G(ft) + 1, *(unsigned long *)&doublet);
X
X		result = (doubles < doublet);
X
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	procsget(CP1CS, cs);
X
X	Set_Cond(cs, result);
X
X	procsput(CP1CS, cs);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_cole(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint		fmt;
Xint		ft;
Xint		fs;
Xint		fd;
X{
X	float		singles;
X	float		singlet;
X	double		doubles;
X	double		doublet;
X	int		result;
X	unsigned long	cs;
X
X	/*
X	 * ordered && (less than || equal)
X	 * (see p.7-6)
X	 *
X	 * TODO: ordered
X	 */
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singles);
X
X		procsget(CP1G(ft), *(unsigned long *)&singlet);
X
X		result = (singles <= singlet);
X
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doubles + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doubles);
X
X		procsget(CP1G(ft), *((unsigned long *)&doublet + 1));
X
X		procsget(CP1G(ft) + 1, *(unsigned long *)&doublet);
X
X		result = (doubles <= doublet);
X
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	procsget(CP1CS, cs);
X
X	Set_Cond(cs, result);
X
X	procsput(CP1CS, cs);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_colt(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint		fmt;
Xint		ft;
Xint		fs;
Xint		fd;
X{
X	float		singles;
X	float		singlet;
X	double		doubles;
X	double		doublet;
X	int		result;
X	unsigned long	cs;
X
X	/*
X	 * ordered && less than
X	 * (see p.7-6)
X	 *
X	 * TODO: ordered
X	 */
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singles);
X
X		procsget(CP1G(ft), *(unsigned long *)&singlet);
X
X		result = (singles < singlet);
X
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doubles + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doubles);
X
X		procsget(CP1G(ft), *((unsigned long *)&doublet + 1));
X
X		procsget(CP1G(ft) + 1, *(unsigned long *)&doublet);
X
X		result = (doubles < doublet);
X
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	procsget(CP1CS, cs);
X
X	Set_Cond(cs, result);
X
X	procsput(CP1CS, cs);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_ctc1(dipc, rt, fs)
Xdinstrn	*dipc;
Xint		rt;
Xint		fs;
X{
X	unsigned long	t;
X
X	procsget(rt, t);
X
X	procsput(CP1C(fs), t);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_cule(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint		fmt;
Xint		ft;
Xint		fs;
Xint		fd;
X{
X	float		singles;
X	float		singlet;
X	double		doubles;
X	double		doublet;
X	int		result;
X	unsigned long	cs;
X
X	/*
X	 * less than || equal
X	 *
X	 * TODO: unordered
X	 */
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singles);
X
X		procsget(CP1G(ft), *(unsigned long *)&singlet);
X
X		result = (singles <= singlet);
X
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doubles + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doubles);
X
X		procsget(CP1G(ft), *((unsigned long *)&doublet + 1));
X
X		procsget(CP1G(ft) + 1, *(unsigned long *)&doublet);
X
X		result = (doubles <= doublet);
X
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	procsget(CP1CS, cs);
X
X	Set_Cond(cs, result);
X
X	procsput(CP1CS, cs);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_cult(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint		fmt;
Xint		ft;
Xint		fs;
Xint		fd;
X{
X	float		singles;
X	float		singlet;
X	double		doubles;
X	double		doublet;
X	int		result;
X	unsigned long	cs;
X
X	/*
X	 * unordered || less than
X	 * (see p.7-6)
X	 *
X	 * TODO: unordered
X	 */
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singles);
X
X		procsget(CP1G(ft), *(unsigned long *)&singlet);
X
X		result = (singles < singlet);
X
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doubles + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doubles);
X
X		procsget(CP1G(ft), *((unsigned long *)&doublet + 1));
X
X		procsget(CP1G(ft) + 1, *(unsigned long *)&doublet);
X
X		result = (doubles < doublet);
X
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	procsget(CP1CS, cs);
X
X	Set_Cond(cs, result);
X
X	procsput(CP1CS, cs);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_cvtd(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint		fmt;
Xint		ft;
Xint		fs;
Xint		fd;
X{
X	float	singlef;
X	double	doublef;
X	long	fixedf;
X
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singlef);
X
X		doublef = singlef;
X		break;
X
X	case FMT_FIXED:
X		procsget(CP1G(fs), fixedf);
X
X		doublef = fixedf;
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	/*
X	 * Note apparent reversal of words within
X	 * doubles here -- no idea why.
X	 */
X
X	procsput(CP1G(fd), *((unsigned long *)&doublef + 1));
X
X	procsput(CP1G(fd) + 1, *(unsigned long *)&doublef);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_cvts(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint		fmt;
Xint		ft;
Xint		fs;
Xint		fd;
X{
X	float	singlef;
X	double	doublef;
X	long	fixedf;
X
X	switch (fmt)
X	{
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doublef + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doublef);
X
X		singlef = doublef;
X		break;
X
X	case FMT_FIXED:
X		procsget(CP1G(fs), fixedf);
X
X		singlef = fixedf;
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	procsput(CP1G(fd), *(unsigned long *)&singlef);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_cvtw(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint		fmt;
Xint		ft;
Xint		fs;
Xint		fd;
X{
X	float	singlef;
X	double	doublef;
X	long	fixedf;
X
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singlef);
X
X		fixedf = singlef;
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doublef + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doublef);
X
X		fixedf = doublef;
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	procsput(CP1G(fd), fixedf);
X
X	return dipc;
X}
END_OF_FILE
if test 8817 -ne `wc -c <'i_c.c'`; then
    echo shar: \"'i_c.c'\" unpacked with wrong size!
fi
# end of 'i_c.c'
fi
if test -f 'i_s.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'i_s.c'\"
else
echo shar: Extracting \"'i_s.c'\" \(11592 characters\)
sed "s/^X//" >'i_s.c' <<'END_OF_FILE'
X#include	"register.h"
X#include	"symtab.h"
X#include	"diblock.h"
X#include	"instrn.h"
X#include	"process.h"
X#include	"wcache.h"
X
X/*
X * TODO -- big-endian v. little-endian.
X */
X
X#define	quiet_procmput_word(dipc,offset,w,n,S) \
X{ \
X	int		i; \
X	unsigned long	*wp; \
X \
X	if ((i = offset - P.p_data_region_min) >= 0) \
X	{ \
X		if (n == sizeof(int)) \
X		{ \
X			if (offset <= P.p_data_region_wlimit) \
X			{ \
X				wp = (unsigned long *)&P.p_data_region[i]; \
X				*wp = w; \
X				S; \
X				return dipc; \
X			} \
X		} \
X		else if (n == sizeof(short)) \
X		{ \
X			if (offset <= P.p_data_region_limit + 1 - n) \
X			{ \
X				*(unsigned short *)&P.p_data_region[i] = w; \
X				return dipc; \
X			} \
X		} \
X		else \
X		{ \
X			if (offset <= P.p_data_region_limit) \
X			{ \
X				*(unsigned char *)&P.p_data_region[i] = w; \
X				return dipc; \
X			} \
X		} \
X \
X		if (offset <= STACK_WMAX) \
X		{ \
X			if ((i = offset - P.p_stack_region_min) < 0) \
X			{ \
X				(void)proc_grow_stack(dipc, offset); \
X \
X				i = offset - P.p_stack_region_min; \
X			} \
X \
X			if (n == sizeof(int)) \
X			{ \
X				wp = (unsigned long *)&P.p_stack_region[i]; \
X				*wp = w; \
X				S; \
X			} \
X			else if (n == sizeof(short)) \
X				*(unsigned short *)&P.p_stack_region[i] = w; \
X			else \
X				*(unsigned char *)&P.p_stack_region[i] = w; \
X \
X			return dipc; \
X		} \
X	} \
X \
X	(void)quiet_procmput(dipc, offset, (unsigned char *)&w, n); \
X	return dipc; \
X}
X
Xstatic
Xdinstrn	*
Xc_sb(dipc)
Xdinstrn	*dipc;
X{
X	unsigned long	addr;
X	unsigned char	c;
X
X	addr = *dipc->di_1 + (long)dipc->di_2;
X	c = *dipc->di_0;
X
X	quiet_procmput_word(dipc, addr, c, sizeof(c), ;);
X}
X
Xdinstrn	*
Xi_sb(dipc, base, rt, offset)
Xdinstrn	*dipc;
Xint	base;
Xint	rt;
Xshort	offset;
X{
X	unsigned long	b;
X	unsigned long	t;
X	unsigned char	c;
X
X	if (compile_ok)
X	{
X		dipc->di_handler = c_sb;
X		dipc->di_0 = &P.p_state[rt];
X		dipc->di_1 = &P.p_state[base];
X		dipc->di_2 = (unsigned long *)(long)offset;
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(base, b);
X
X	procsget(rt, t);
X
X	c = t;
X
X	(void)procmput(dipc, b + (long)offset, (char *)&c, sizeof(c));
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_sh(dipc)
Xdinstrn	*dipc;
X{
X	unsigned long	addr;
X	unsigned short	h;
X
X	addr = *dipc->di_1 + (long)dipc->di_2;
X	h = *dipc->di_0;
X
X	check_halfword_align(dipc, addr);
X
X	quiet_procmput_word(dipc, addr, h, sizeof(h), ;);
X}
X
Xdinstrn	*
Xi_sh(dipc, base, rt, offset)
Xdinstrn	*dipc;
Xint	base;
Xint	rt;
Xshort	offset;
X{
X	unsigned long	b;
X	unsigned long	addr;
X	unsigned long	t;
X	unsigned short	h;
X
X	if (compile_ok)
X	{
X		dipc->di_handler = c_sh;
X		dipc->di_0 = &P.p_state[rt];
X		dipc->di_1 = &P.p_state[base];
X		dipc->di_2 = (unsigned long *)(long)offset;
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(base, b);
X
X	addr = b + offset;
X
X	check_halfword_align(dipc, addr);
X
X	procsget(rt, t);
X
X	h = t;
X
X	(void)procmput(dipc, addr, (char *)&h, sizeof(h));
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_sll(dipc)
Xdinstrn	*dipc;
X{
X	*dipc->di_0 = *dipc->di_1 << (int)dipc->di_2;
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_sll(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	t;
X
X	if (compile_ok)
X	{
X		if (rd == R_0)
X			dipc->di_handler = c_noop;
X		else
X		{
X			dipc->di_handler = c_sll;
X			dipc->di_0 = &P.p_state[rd];
X			dipc->di_1 = &P.p_state[rt];
X			dipc->di_2 = (unsigned long *)shamt;
X		}
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(rt, t);
X
X	procsput(rd, t << shamt);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_sllv(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	t;
X	unsigned long	s;
X
X	procsget(rt, t);
X
X	procsget(rs, s);
X
X	procsput(rd, t << (s & 0x1F));
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_slt(dipc)
Xdinstrn	*dipc;
X{
X	*dipc->di_0 = ((long)*dipc->di_1 < (long)*dipc->di_2) ? 1 : 0;
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_slt(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	long	s;
X	long	t;
X
X	if (compile_ok)
X	{
X		if (rd == R_0)
X			dipc->di_handler = c_noop;
X		else
X		{
X			dipc->di_handler = c_slt;
X			dipc->di_0 = &P.p_state[rd];
X			dipc->di_1 = &P.p_state[rs];
X			dipc->di_2 = &P.p_state[rt];
X		}
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(rs, *(unsigned long *)&s);
X
X	procsget(rt, *(unsigned long *)&t);
X
X	procsput(rd, (s < t) ? 1 : 0);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_slti(dipc, rs, rt, immediate)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xshort	immediate;
X{
X	long	s;
X
X	procsget(rs, *(unsigned long *)&s);
X
X	procsput(rt, (s < (long)immediate) ? 1 : 0);
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_sltiu(dipc)
Xdinstrn	*dipc;
X{
X	*dipc->di_0 = (*dipc->di_1 < (unsigned long)dipc->di_2) ? 1 : 0;
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_sltiu(dipc, rs, rt, immediate)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xshort	immediate;
X{
X	unsigned long	s;
X	long		i;
X	unsigned long	ui;
X
X	i = immediate;
X	ui = i;
X
X	if (compile_ok)
X	{
X		if (rt == R_0)
X			dipc->di_handler = c_noop;
X		else
X		{
X			dipc->di_handler = c_sltiu;
X			dipc->di_0 = &P.p_state[rt];
X			dipc->di_1 = &P.p_state[rs];
X			dipc->di_2 = (unsigned long *)ui;
X		}
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(rs, s);
X
X	procsput(rt, (s < ui) ? 1 : 0);
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_sltu(dipc)
Xdinstrn	*dipc;
X{
X	*dipc->di_0 = (*dipc->di_1 < *dipc->di_2) ? 1 : 0;
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_sltu(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	s;
X	unsigned long	t;
X
X	if (compile_ok)
X	{
X		if (rd == R_0)
X			dipc->di_handler = c_noop;
X		else
X		{
X			dipc->di_handler = c_sltu;
X			dipc->di_0 = &P.p_state[rd];
X			dipc->di_1 = &P.p_state[rs];
X			dipc->di_2 = &P.p_state[rt];
X		}
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(rs, s);
X
X	procsget(rt, t);
X
X	procsput(rd, (s < t) ? 1 : 0);
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_sra(dipc)
Xdinstrn	*dipc;
X{
X	*dipc->di_0 = (unsigned long)(((long)*dipc->di_2) >> (int)dipc->di_1);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_sra(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	long	t;
X
X	if (compile_ok)
X	{
X		if (rd == R_0)
X			dipc->di_handler = c_noop;
X		else
X		{
X			dipc->di_handler = c_sra;
X			dipc->di_0 = &P.p_state[rd];
X			dipc->di_1 = (unsigned long *)shamt;
X			dipc->di_2 = &P.p_state[rt];
X		}
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(rt, *(unsigned long *)&t);
X
X	procsput(rd, t >> shamt);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_srav(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	long		t;
X	unsigned long	s;
X
X	procsget(rt, *(unsigned long *)&t);
X
X	procsget(rs, s);
X
X	procsput(rd, t >> (s & 0x1F));
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_srl(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	t;
X
X	procsget(rt, t);
X
X	procsput(rd, t >> shamt);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_srlv(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	t;
X	unsigned long	s;
X
X	procsget(rt, t);
X
X	procsget(rs, s);
X
X	procsput(rd, t >> (s & 0x1F));
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_sub(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	s;
X	unsigned long	t;
X
X	procsget(rs, s);
X
X	procsget(rt, t);
X
X	/*
X	 * TODO -- overflow exception.
X	 */
X	procsput(rd, s - t);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_subfmt(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint	fmt;
Xint	ft;
Xint	fs;
Xint	fd;
X{
X	float		singles;
X	float		singlet;
X	float		singled;
X	double		doubles;
X	double		doublet;
X	double		doubled;
X	unsigned long	l[2];
X
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singles);
X
X		procsget(CP1G(ft), *(unsigned long *)&singlet);
X
X		singled = singles - singlet;
X
X		procsput(CP1G(fd), *(unsigned long *)&singled);
X
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doubles + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doubles);
X
X		procsget(CP1G(ft), *((unsigned long *)&doublet + 1));
X
X		procsget(CP1G(ft) + 1, *(unsigned long *)&doublet);
X
X		doubled = doubles - doublet;
X
X		procsput(CP1G(fd), *((unsigned long *)&doubled + 1));
X
X		procsput(CP1G(fd) + 1, *(unsigned long *)&doubled);
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_subu(dipc)
Xdinstrn	*dipc;
X{
X	*dipc->di_0 = *dipc->di_1 - *dipc->di_2;
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_subu(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	s;
X	unsigned long	t;
X
X	if (compile_ok)
X	{
X		if (rd == R_0)
X			dipc->di_handler = c_noop;
X		else
X		{
X			dipc->di_handler = c_subu;
X			dipc->di_0 = &P.p_state[rd];
X			dipc->di_1 = &P.p_state[rs];
X			dipc->di_2 = &P.p_state[rt];
X		}
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(rs, s);
X
X	procsget(rt, t);
X
X	procsput(rd, s - t);
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_sw0(dipc)
Xdinstrn	*dipc;
X{
X	unsigned long	addr;
X	unsigned long	l;
X	cent		*cap;
X
X	addr = *dipc->di_1;
X	l = *dipc->di_0;
X
X	if ((cap = &wcache[addr % CACHEZ])->c_addr == addr)
X	{
X		*cap->c_ptr = l;
X		return dipc;
X	}
X
X	check_word_align(dipc, addr);
X
X	quiet_procmput_word(dipc, addr, l, sizeof(l), cap->c_ptr = wp; cap->c_addr = addr);
X}
X
Xstatic
Xdinstrn	*
Xc_sw4(dipc)
Xdinstrn	*dipc;
X{
X	unsigned long	addr;
X	unsigned long	l;
X	cent		*cap;
X
X	addr = *dipc->di_1 + 4;
X	l = *dipc->di_0;
X
X	if ((cap = &wcache[addr % CACHEZ])->c_addr == addr)
X	{
X		*cap->c_ptr = l;
X		return dipc;
X	}
X
X	check_word_align(dipc, addr);
X
X	quiet_procmput_word(dipc, addr, l, sizeof(l), cap->c_ptr = wp; cap->c_addr = addr);
X}
X
Xstatic
Xdinstrn	*
Xc_sw(dipc)
Xdinstrn	*dipc;
X{
X	unsigned long	addr;
X	unsigned long	l;
X	cent		*cap;
X
X	addr = *dipc->di_1 + (long)dipc->di_2;
X	l = *dipc->di_0;
X
X	if ((cap = &wcache[addr % CACHEZ])->c_addr == addr)
X	{
X		*cap->c_ptr = l;
X		return dipc;
X	}
X
X	check_word_align(dipc, addr);
X
X	quiet_procmput_word(dipc, addr, l, sizeof(l), cap->c_ptr = wp; cap->c_addr = addr);
X}
X
Xdinstrn	*
Xi_sw(dipc, base, rt, offset)
Xdinstrn	*dipc;
Xint	base;
Xint	rt;
Xshort	offset;
X{
X	unsigned long	b;
X	unsigned long	addr;
X	unsigned long	t;
X
X	if (compile_ok)
X	{
X		switch (offset)
X		{
X		case 0:
X			dipc->di_handler = c_sw0;
X			break;
X
X		case 4:
X			dipc->di_handler = c_sw4;
X			break;
X
X		default:
X			dipc->di_handler = c_sw;
X			break;
X		}
X		dipc->di_0 = &P.p_state[rt];
X		dipc->di_1 = &P.p_state[base];
X		dipc->di_2 = (unsigned long *)(long)offset;
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(base, b);
X
X	addr = b + (long)offset;
X
X	check_word_align(dipc, addr);
X
X	procsget(rt, t);
X
X	(void)procmput(dipc, addr, (char *)&t, sizeof(t));
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_swc1(dipc, base, rt, offset)
Xdinstrn	*dipc;
Xint	base;
Xint	rt;
Xshort	offset;
X{
X	unsigned long	b;
X	unsigned long	addr;
X	unsigned long	t;
X
X	procsget(base, b);
X
X	addr = b + (long)offset;
X
X	check_word_align(dipc, addr);
X
X	procsget(CP1G(rt), t);
X
X	(void)procmput(dipc, addr, (char *)&t, sizeof(t));
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_swl(dipc, base, rt, offset)
Xdinstrn	*dipc;
Xint	base;
Xint	rt;
Xshort	offset;
X{
X	unsigned long	b;
X	unsigned long	addr;
X	unsigned long	t;
X	int		length;
X
X	procsget(base, b);
X
X	addr = b + (long)offset;
X
X	procsget(rt, t);
X
X	length = sizeof(t) - (addr - (addr & ~0x3));
X
X	(void)procmput(dipc, addr, (char *)&t, length);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_swr(dipc, base, rt, offset)
Xdinstrn	*dipc;
Xint	base;
Xint	rt;
Xshort	offset;
X{
X	unsigned long	b;
X	unsigned long	addr;
X	unsigned long	t;
X	int		length;
X
X	procsget(base, b);
X
X	addr = b + (long)offset;
X
X	procsget(rt, t);
X
X	length = (addr - (addr & ~0x3)) + 1;
X
X	(void)procmput(dipc, addr & ~0x3, ((char *)&t) + (sizeof(t) - length), length);
X
X	return dipc;
X}
END_OF_FILE
if test 11592 -ne `wc -c <'i_s.c'`; then
    echo shar: \"'i_s.c'\" unpacked with wrong size!
fi
# end of 'i_s.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(9515 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X#include	<stdio.h>
X
X/*
X * Simulate the execution of a process
X * on a MIPS R[CS]3330 under RISC/os 4.52.
X */
X
X#define	DEFAULT_OUTNAME	"<stderr>"
X#define	DEFAULT_OUTFP	stderr
X
X#define	toggle(f)	(f) = 1 - (f)
X
Xextern int		fd_init();
Xextern int		hist_init();
Xextern void		histo_dump();
Xextern void		hist_dump();
Xextern char		*strdup();
Xextern int		getopt();
Xextern void		usage();
Xextern int		load();
Xextern int		go();
Xextern char		*execvpath();
Xextern int		setobuf();
X
Xextern int		optind;
Xextern char		*optarg;
X
Xchar			**gargv;
Xchar			**genvp;
Xchar			*usage_args	= " [-ABCFHILMNPRSTVW] [-a argc] [-d fd] [-f executable ] [-h history_length] [-o outfile] [-v] [command ..]";
Xchar			*getopt_args	=    "ABCFHILMNPRSTVWa:d:f:h:o:v";
Xint			Aflag;		/* show read/write/execve args	*/
Xint			Bflag;		/* print page no.s		*/
Xint			Cflag;		/* C-like trace format		*/
Xint			Fflag;		/* follow across execvp		*/
Xint			Hflag;		/* emit an execution histogram	*/
Xint			Iflag;		/* show instructions		*/
Xint			Lflag	= 1;	/* line buffer output		*/
Xint			Mflag;		/* show memory accesses		*/
Xint			Nflag;		/* show instrn counts		*/
Xint			Pflag;		/* show syscalls before		*/
Xint			Rflag;		/* show register accesses	*/
Xint			Sflag	= 1;	/* show syscalls after		*/
Xint			Tflag;		/* show system time		*/
Xint			Vflag;		/* be verbose			*/
Xint			Wflag	= 1;	/* truncate outfile b4 writing	*/
XFILE			*outfp	= DEFAULT_OUTFP;
Xchar			*adotout;	/* explicit executable		*/
Xint			nargc	= -1;	/* # of argv's before env's	*/
X
Xunsigned long		instruction_count;
Xunsigned long		instruction_count_since_last_syscall;
X
Xstatic char		*version_string	= "Version 5";
Xstatic int		output_file_has_been_specified;
Xstatic char		*default_argv[]	=
X{
X	"a.out",
X	(char *)0
X};
X
Xmain(argc, argv, envp)
Xint	argc;
Xchar	*argv[];
Xchar	*envp[];
X{
X	int	c;
X	char	*newoutfile;
X	int	newoutfd;
X	FILE	*newoutfp;
X	char	**app;
X	char	**epp;
X
X	gargv = &argv[0];
X	genvp = &envp[0];
X
X	newoutfile = (char *)0;
X	newoutfd = -1;
X
X	while ((c = getopt(argc, argv, getopt_args)) != -1)
X	{
X		switch (c)
X		{
X		case 'A':
X			toggle(Aflag);
X			break;
X
X		case 'B':
X			toggle(Bflag);
X			break;
X
X		case 'C':
X			toggle(Cflag);
X			break;
X
X		case 'F':
X			toggle(Fflag);
X			break;
X
X		case 'H':
X			toggle(Hflag);
X			break;
X
X		case 'I':
X			toggle(Iflag);
X			break;
X
X		case 'L':
X			toggle(Lflag);
X			break;
X
X		case 'M':
X			toggle(Mflag);
X			break;
X
X		case 'N':
X			toggle(Nflag);
X			break;
X
X		case 'P':
X			toggle(Pflag);
X			break;
X
X		case 'R':
X			toggle(Rflag);
X			break;
X
X		case 'S':
X			toggle(Sflag);
X			break;
X
X		case 'T':
X			toggle(Tflag);
X			break;
X
X		case 'V':
X			toggle(Vflag);
X			break;
X
X		case 'W':
X			toggle(Wflag);
X			break;
X
X		case 'a':
X			nargc = atoi(optarg);
X			break;
X
X		case 'd':
X			newoutfd = atoi(optarg);
X			break;
X
X		case 'f':
X			adotout = optarg;
X			break;
X
X		case 'h':
X			if (hist_init(atoi(optarg)) == -1)
X				exit(1);
X			break;
X
X		case 'o':
X			newoutfile = optarg;
X			output_file_has_been_specified = 1;
X			break;
X
X		case 'v':
X			printf("%s\n", version_string);
X			exit(0);
X			break;
X
X		case '?':
X		default:
X			usage();
X			exit(1);
X		}
X	}
X
X	/*
X	 * Trailing arguments?
X	 */
X	if (optind >= argc)
X	{
X		/*
X		 * No -- use the default.
X		 */
X		app = &default_argv[0];
X		epp = &envp[0];
X	}
X	else
X	{
X		/*
X		 * Yes -- use them.
X		 */
X		app = &argv[optind];
X		if (nargc == -1)
X			epp = &envp[0];
X		else
X		{
X			/*
X			 * Overwrite the dummy argument
X			 * to use it as an argument vector terminator.
X			 * The environment will be got from
X			 * the rest.
X			 */
X			argv[optind + nargc] = (char *)0;
X			epp = &argv[optind + nargc + 1];
X		}
X	}
X
X	if (adotout == (char *)0)
X	{
X		/*
X		 * Find the executable.
X		 */
X		if ((adotout = execvpath(*app)) == (char *)0)
X		{
X			couldnot("find executable \"%s\"", *app);
X			exit(1);
X		}
X	}
X
X	if (fd_init(newoutfd) == -1)
X		exit(1);
X
X	if (output_file_has_been_specified)
X	{
X		if (Wflag)
X		{
X			if ((newoutfp = fopen(newoutfile, "w")) == (FILE *)0)
X			{
X				couldnot("fopen(\"%s\", \"w\")", newoutfile);
X				exit(1);
X			}
X			(void)fclose(newoutfp);
X		}
X
X		if ((newoutfp = fopen(newoutfile, "a")) == (FILE *)0)
X		{
X			couldnot("fopen(\"%s\", \"a\")", newoutfile);
X			exit(1);
X		}
X	}
X	else
X	{
X		if (newoutfd == -1)
X		{
X			if ((newoutfd = dup(1)) == -1)
X			{
X				couldnot("dup(1)");
X				exit(1);
X			}
X		}
X
X		if ((newoutfp = fdopen(newoutfd, "a")) == (FILE *)0)
X		{
X			couldnot("fdopen(%d, \"a\")", newoutfd);
X			exit(1);
X		}
X	}
X
X	outfp = newoutfp;
X
X	if (setobuf() == -1)
X		exit(1);
X
X	if (load(adotout, app, epp) == -1)
X		exit(1);
X
X	if (go() == -1)
X	{
X		histo_dump();
X		hist_dump();
X		exit(1);
X	}
X
X	histo_dump();
X	hist_dump();
X
X	exit(0);
X}
X
Xint
Xsetobuf()
X{
X	if (Lflag)
X	{
X		static char	obuf[4096];
X
X		if (setvbuf(outfp, &obuf[0], _IOLBF, sizeof(obuf)) != 0)
X		{
X			couldnot("set line buffering on output file");
X			return -1;
X		}
X	}
X
X	return 0;
X}
X
Xstatic
Xchar	*
Xitoa(i)
Xint	i;
X{
X	static char	result[16];
X
X	(void)sprintf(&result[0], "%d", i);
X
X	return &result[0];
X}
X
X#define	duplicate(f,cp,l)	{ if (f) *cp++ = l; }
X#define	negate(f,cp,l)		duplicate(!(f), (cp), (l))
X
X/*
X * We are given a (filename,argument,environment) vector that
X * looks like this:
X *
X *	filename,
X *	arg[0], arg[1], ..., arg[N-1]
X *	env[0], env[1], ..., env[M-1]
X *
X * while our arguments are gargv[0], ..., gargv[A-1].
X * and our environment is genv[0], ..., genv[G-1].
X *
X * We make the (filename,argument,environment) vector look
X * like this:
X *
X *	execvpath(gargv[0])
X *	execvpath(gargv[0]), -d, fd, -myflags, -f, filename, -a, N, --, argv[0], argv[1], ..., argv[N-1], E, env[0], env[1], ..., env[E-1]
X *	genv[0], genv[1], ..., genv[G-1]
X *
X * and we leave our environment as is.
X *
X * e.g.
X *
X *	/bin/sh
X *	-sh
X *	PATH=...
X *
X * might become
X *
X *	/usr/local/bin/trash
X *	/usr/local/bin/trash -d 18 -ABFT -f /bin/sh -a 1 -- -sh 23 PATH=...
X *	HOME=...
X */
Xint
Xaugment_execve_args(fp, appp, eppp)
Xchar	**fp;
Xchar	***appp;
Xchar	***eppp;
X{
X	char	flagsbuf[128];
X	int	argc;
X	char	**argp;
X	int	envc;
X	char	**envp;
X	int	newargc;
X	char	*result_filename;
X	char	**result_argp;
X	char	**result_envp;
X	int	argi;
X	int	i;
X	char	*cp;
X
X	/*
X	 * The new filename.
X	 */
X	if ((result_filename = strdup(execvpath(gargv[0]))) == (char *)0)
X	{
X		vcouldnot("allocate enough memory for pre-execve filename");
X		return -1;
X	}
X
X	/*
X	 * The new arg vector.
X	 */
X	for (argp = *appp, argc = 0; argp[argc] != (char *)0; argc++)
X		;
X
X	for (envp = *eppp, envc = 0; envp[envc] != (char *)0; envc++)
X		;
X
X	newargc = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + argc + 1 + envc + 1;
X
X	if ((result_argp = (char **)malloc(newargc * sizeof(char *))) == (char **)0)
X	{
X		vcouldnot("allocate enough memory for %d pre-execve arguments", newargc);
X		return -1;
X	}
X
X	argi = 0;
X	if ((result_argp[argi++] = strdup(result_filename)) == (char *)0)
X	{
X		vcouldnot("allocate enough memory for pre-execve argv[0]");
X		return -1;
X	}
X
X{
X	if ((result_argp[argi++] = strdup("-d")) == (char *)0)
X	{
X		vcouldnot("allocate enough memory for pre-execve -d");
X		return -1;
X	}
X	if ((result_argp[argi++] = strdup(itoa(fileno(outfp)))) == (char *)0)
X	{
X		vcouldnot("allocate enough memory for pre-execve fd");
X		return -1;
X	}
X}
X
X	/*
X	 * Calculate the new flags.
X	 */
X	cp = &flagsbuf[0];
X	*cp++ = '-';
X
X	duplicate(Aflag, cp, 'A');
X	duplicate(Bflag, cp, 'B');
X	duplicate(Cflag, cp, 'C');
X	duplicate(Fflag, cp, 'F');
X	duplicate(Iflag, cp, 'I');
X	negate(Lflag, cp, 'L');
X	duplicate(Mflag, cp, 'M');
X	duplicate(Nflag, cp, 'N');
X	duplicate(Pflag, cp, 'P');
X	duplicate(Rflag, cp, 'R');
X	negate(Sflag, cp, 'S');
X	duplicate(Tflag, cp, 'T');
X	duplicate(Vflag, cp, 'V');
X
X	*cp++ = 'W';
X	*cp = '\0';
X
X	if ((result_argp[argi++] = strdup(&flagsbuf[0])) == (char *)0)
X	{
X		vcouldnot("allocate enough memory for pre-execve flagsbuf");
X		return -1;
X	}
X
X	if ((result_argp[argi++] = strdup("-f")) == (char *)0)
X	{
X		vcouldnot("allocate enough memory for pre-execve -f");
X		return -1;
X	}
X	result_argp[argi++] = *fp;
X
X	if ((result_argp[argi++] = strdup("-a")) == (char *)0)
X	{
X		vcouldnot("allocate enough memory for pre-execve -a");
X		return -1;
X	}
X	if ((result_argp[argi++] = strdup(itoa(argc))) == (char *)0)
X	{
X		vcouldnot("allocate enough memory for pre-execve argc");
X		return -1;
X	}
X	if ((result_argp[argi++] = strdup("--")) == (char *)0)
X	{
X		vcouldnot("allocate enough memory for pre-execve --");
X		return -1;
X	}
X	for (i = 0; i < argc; i++)
X		result_argp[argi++] = argp[i];
X	if ((result_argp[argi++] = strdup(itoa(envc))) == (char *)0)
X	{
X		vcouldnot("allocate enough memory for pre-execve envc");
X		return -1;
X	}
X	for (i = 0; i < envc; i++)
X		result_argp[argi++] = envp[i];
X	result_argp[argi] = (char *)0;
X
X	/*
X	 * The new env vector.
X	 */
X	for (envc = 0; genvp[envc] != (char *)0; envc++)
X		;
X
X	if ((result_envp = (char **)malloc((envc + 1) * sizeof(char *))) == (char **)0)
X	{
X		vcouldnot("allocate enough memory for %d pre-execve environment strings", envc + 1);
X		return -1;
X	}
X
X	for (i = 0; i < envc; i++)
X	{
X		if ((result_envp[i] = strdup(genvp[i])) == (char *)0)
X		{
X			vcouldnot("allocate enough memory for pre-execve env string");
X			return -1;
X		}
X	}
X	result_envp[i] = (char *)0;
X
X	/*
X	 * Assign the results.
X	 */
X	*fp = result_filename;
X	*appp = result_argp;
X	*eppp = result_envp;
X
X	/*
X	 * Free up the left-overs.
X	 */
X	(void)free(argp);
X	(void)free(envp);
X
X	if (Vflag)
X	{
X		char	**cp;
X
X		fprintf(outfp, "execve'(filename=\"%s\",argv={", *fp);
X		for (cp = *appp; *cp != (char *)0; cp++)
X			fprintf(outfp, "\"%s\",", *cp);
X		fprintf(outfp, "},envp={");
X		for (cp = *eppp; *cp != (char *)0; cp++)
X			fprintf(outfp, "\"%s\",", *cp);
X		fprintf(outfp, "}\n");
X	}
X
X	return 0;
X}
END_OF_FILE
if test 9515 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
echo shar: End of archive 3 \(of 8\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
