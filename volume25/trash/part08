Newsgroups: comp.sources.unix
From: bruce@beta.cs.su.oz.au (Bruce Janson)
Subject: v25i162: trash - simulate process execution in MIPS RISC/os 4.52, Part08/08
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: bruce@beta.cs.su.oz.au (Bruce Janson)
Posting-Number: Volume 25, Issue 162
Archive-Name: trash/part08

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 8)."
# Contents:  sysv.c
# Wrapped by bruce@basser on Tue Mar  3 23:25:24 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'sysv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sysv.c'\"
else
echo shar: Extracting \"'sysv.c'\" \(58975 characters\)
sed "s/^X//" >'sysv.c' <<'END_OF_FILE'
X#include		<sys/param.h>
X#include		<sys/types.h>
X#include		<sys/statfs.h>
X#include		<sys/stat.h>
X#include		<sys/times.h>
X#include		<sys/dirent.h>
X#include		<sys/swap.h>
X#include		<sys/utsname.h>
X#include		<sys/termio.h>
X#include		<sys/stermio.h>
X#include		<sys/stropts.h>
X#include		<sys/flio.h>
X#include		<sys/mtio.h>
X#include		<sys/fs/prfcntl.h>
X#include		<sys/ptrace.h>
X#include		<sys/immu.h>
X#include		<sys/sbd.h>
X#include		<sys/region.h>
X#undef	PC
X#if	defined(LIMITS)
X#include		<sys/lnode.h>
X#define	LIMITSoffset	(320 + SYSVoffset)
X#endif	/* defined(LIMITS) */
X#if	defined(SHARE)
X#include		<sys/share.h>
X#define	SHAREoffset	(323 + SYSVoffset)
X#endif	/* defined(SHARE) */
X#include		<sys/proc.h>
X#include		<sys/fstyp.h>
X#include		<sys/fsid.h>
X#define	INKERNEL	1
X#include		<signal.h>
X#undef	INKERNEL
X#include		<poll.h>
X#include		<errno.h>
X#include		<fcntl.h>
X#include		<ustat.h>
X#include		<sys.s>
X#if	!defined(SYS_setlim)
X#define	SYS_setlim	(0 + LIMITSoffset)
X#define	SYS_getlim	(1 + LIMITSoffset)
X#define	SYS_limonoff	(2 + LIMITSoffset)
X#endif	/* !defined(SYS_setlim) */
X#if	!defined(SYS_sharecosts)
X#define	SYS_sharecosts	(0 + SHAREoffset)
X#define	SYS_gettab	(1 + SHAREoffset)
X#endif	/* !defined(SYS_sharecosts) */
X#include		<stdio.h>
X#include		<unistd.h>
X#include		<bsd/sys/types.h>
X#include		<bsd/sys/socket.h>
X#include		<bsd/sys/uio.h>
X#include		<bsd/sys/wait.h>
X#include		<bsd/sys/time.h>
X#include		<bsd/sys/resource.h>
X#include		"register.h"
X#include		"symtab.h"
X#include		"diblock.h"
X#include		"instrn.h"
X#include		"process.h"
X#include		"sysentry.h"
X#include		"nels.h"
X#include		"res.h"
X#include		"flag.h"
X#include		"generic.h"
X
Xextern time_t		time();
X
Xextern int		fd_lookup();
Xextern int		fd_open();
Xextern void		fd_dopen();
Xextern int		fd_close();
Xextern int		fd_invalid();
Xextern int		fd_nfiles();
Xextern int		fd_sort();
Xextern void		histo_dump();
Xextern void		hist_dump();
Xextern char		*malloc();
Xextern char		*strdup();
Xextern int		bufset();
Xextern int		mstrlen();
Xextern int		mgetstring();
Xextern int		mgets();
Xextern char		**mgetvp();
Xextern int		magic_ok();
Xextern int		interpreter_ok();
Xextern int		is_a_shared_library();
Xextern int		augment_execve_args();
Xextern void		vis_quoted_truncated_buffer();
Xextern void		say_time();
Xextern char		*signal_name();
Xextern int		printval();
Xextern int		bsd43_sys_ioctl();
Xextern int		sgttybsize();
X
Xextern FILE		*outfp;
Xextern int		errno;
X
Xextern int		Aflag;
Xextern int		Fflag;
Xextern int		Pflag;
Xextern int		Sflag;
X
Xextern unsigned long	arg[];
X
Xextern int		return_errno;	/* errno goes here. */
Xextern long		return_value0;	/* Result 1 value goes here. */
Xextern long		return_value1;	/* Result 2 value goes here. */
X
Xextern sysentry		*current_sysentp;
Xextern char		*sys_call_buf;	/* Scratch buf. */
X
Xstatic int		sysv_print_received_signal();
X
Xstatic
Xint
Xsys_execve(syscallno)
Xint	syscallno;
X{
X	char	*filename;
X	char	**argp;
X	char	**envp;
X	int	need_close_on_exec;
X
X	if (mgetstring(arg[0]) == -1)
X		return -1;
X
X	if ((filename = strdup(sys_call_buf)) == (char *)0)
X	{
X		vcouldnot("execve(): ran out of memory");
X		return -1;
X	}
X
X	if ((argp = mgetvp(arg[1])) == (char **)0)
X		return -1;
X
X	if ((envp = mgetvp(arg[2])) == (char **)0)
X		return -1;
X
X	if (fd_sort() == -1)
X		return -1;
X
X	if (Fflag)
X	{
X		int	mok;
X
X		if
X		(
X			access(filename, X_OK) != 0
X			||
X			(mok = magic_ok(filename)) == 0
X			||
X			(mok == 2 && interpreter_ok(filename) == 0)
X			||
X			is_a_shared_library(filename)
X		)
X		{
X			return_value0 = -1;
X			return_errno = errno;
X
X			if (mfreevp(envp) == -1)
X				return -1;
X
X			if (mfreevp(argp) == -1)
X				return -1;
X
X			(void)free(filename);
X
X			return 0;
X		}
X
X		if (augment_execve_args(&filename, &argp, &envp) == -1)
X		{
X			(void)mfreevp(envp);
X			(void)mfreevp(argp);
X			(void)free(filename);
X		}
X
X		need_close_on_exec = 0;
X	}
X	else
X	{
X		histo_dump();
X		hist_dump();
X
X		if (fcntl(fileno(outfp), F_SETFD, 1) == -1)
X		{
X			vcouldnot("fcntl(%d, F_SETFD, 1)", fileno(outfp));
X			return -1;
X		}
X
X		need_close_on_exec = 1;
X	}
X
X	Rstart;
X	return_value0 = syscall(syscallno, filename, argp, envp);
X	return_errno = errno;
X	Rstop;
X
X	if (need_close_on_exec)
X	{
X		if (fcntl(fileno(outfp), F_SETFD, 0) == -1)
X		{
X			vcouldnot("fcntl(%d, F_SETFD, 0)", fileno(outfp));
X			return -1;
X		}
X	}
X
X	if (mfreevp(envp) == -1)
X		return -1;
X
X	if (mfreevp(argp) == -1)
X		return -1;
X
X	(void)free(filename);
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_fcntl(syscallno)
Xint	syscallno;
X{
X	int	size;
X	void	*fargp;
X
X	switch ((int)arg[1])
X	{
X	case F_DUPFD:
X		Rstart;
X		return_value0 = dup(fd_lookup((int)arg[0]));
X		return_errno = errno;
X		Rstop;
X
X		if (return_value0 != -1)
X		{
X			int	newfd;
X			int	nfiles;
X
X			for (nfiles = fd_nfiles(), newfd = (int)arg[2]; newfd < nfiles && fd_lookup(newfd) != -1; newfd++)
X				;
X
X			if (newfd >= nfiles)
X			{
X				(void)close(return_value0);
X				errno = EMFILE;
X				return 0;
X			}
X
X			fd_dopen(return_value0, newfd);
X
X			return_value0 = newfd;
X		}
X		return 0;
X
X	case F_GETFD:
X	case F_SETFD:
X	case F_GETFL:
X	case F_SETFL:
X	case F_SETOWN:
X	case PFCSEXEC:
X	case PFCREXEC:
X	case PFCRUN:
X	case PFCSSTEP:
X	case PFCCSIG:
X		size = -1;
X		break;
X
X	case PFCWSTOP:
X	case PFCGMASK:
X	case PFCSMASK:
X	case PFCSTOP:
X		size = sizeof(unsigned long);
X		break;
X
X	case PFCGETPR:
X		size = sizeof(proc_t);
X		break;
X
X	case PFCGETUSEG:
X		size = sizeof(struct pfcseg);
X		break;
X
X	case PFCGETREGS:
X		size = sizeof(unsigned long) * NPTRC_REGS;
X		break;
X
X	case F_SETLK:
X	case F_SETLKW:
X		size = sizeof(struct flock);
X		break;
X
X	default:
X		return -2;
X	}
X
X	if (size != -1)
X	{
X		if (bufset(size) == -1)
X			return -1;
X
X		if (mget(arg[2], sys_call_buf, size, &fargp) == -1)
X			return -1;
X	}
X
X	Rstart;
X	return_value0 = syscall(syscallno, fd_lookup((int)arg[0]), (int)arg[1], (size == -1) ? (int)arg[2] : (int)fargp);
X	return_errno = errno;
X	Rstop;
X
X	if (size != -1)
X	{
X		if (mput(arg[2], fargp, size, return_value0) == -1)
X			return -1;
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_fstat(syscallno)
Xint	syscallno;
X{
X	return generic_fstat(syscallno, sizeof(struct stat));
X}
X
Xstatic
Xint
Xsys_fstatfs(syscallno)
Xint	syscallno;
X{
X	int		len;
X	struct statfs	*bufp;
X
X	len = arg[2];
X
X	if (dmget(arg[1], len, &bufp) == -1)
X		return -1;
X
X	Rstart;
X	return_value0 = syscall(syscallno, fd_lookup((int)arg[0]), bufp, len, (int)arg[3]);
X	return_errno = errno;
X	Rstop;
X
X	if (dmput(arg[1], bufp, len, return_value0) == -1)
X		return -1;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_getgid(syscallno)
Xint	syscallno;
X{
X	Rstart;
X	return_value0 = getgid();
X	return_value1 = getegid();
X	return_errno = errno;
X	Rstop;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_getgroups(syscallno)
Xint	syscallno;
X{
X	return generic_getgroups(syscallno, NGROUPS);
X}
X
Xstatic
Xint
Xsys_getitimer(syscallno)
Xint	syscallno;
X{
X	return generic_getitimer(syscallno, sizeof(struct itimerval));
X}
X
X#if	defined(LIMITS)
Xstatic
Xint
Xsys_getlim(syscallno)
Xint	syscallno;
X{
X	int	function;
X	lnode	*address;
X	int	size;
X	int	realsize;
X
X	function = arg[0];
X	size = arg[2];
X
X	switch (function)
X	{
X	case L_GETUID:
X		realsize = sizeof(lnode);
X		break;
X
X	default:
X		realsize = size;
X		break;
X	}
X
X	if (dmget(arg[1], realsize, &address) == -1)
X		return -1;
X
X	Rstart;
X	return_value0 = syscall(syscallno, function, address, size);
X	return_errno = errno;
X	Rstop;
X
X	if (dmput(arg[1], address, realsize, return_value0) == -1)
X		return -1;
X
X	return 0;
X}
X#endif	/* defined(LIMITS) */
X
Xstatic
Xint
Xsys_getrlimit(syscallno)
Xint	syscallno;
X{
X	return generic_getrlimit(syscallno, sizeof(struct rlimit));
X}
X
Xstatic
Xint
Xsys_getrusage(syscallno)
Xint	syscallno;
X{
X	return generic_getrusage(syscallno, sizeof(struct rusage));
X}
X
Xstatic
Xint
Xsys_gettimeofday(syscallno)
Xint	syscallno;
X{
X	struct timeval	tv;
X	struct timezone	tz;
X
X	return generic_gettimeofday(syscallno, &tv, sizeof(tv), &tz, sizeof(tz));
X}
X
Xstatic
Xint
Xsys_getuid(syscallno)
Xint	syscallno;
X{
X	Rstart;
X	return_value0 = getuid();
X	return_value1 = geteuid();
X	return_errno = errno;
X	Rstop;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_ioctl(syscallno)
Xint	syscallno;
X{
X	int	length;
X	int	need_copy_in;
X	int	need_copy_out;
X	int	arg2_is_arg;
X
X	arg2_is_arg = 0;
X
X	if ((arg[1] & (unsigned long)(IOC_INOUT | IOC_VOID)) == 0)
X	{
X		/*
X		 * Old style.
X		 */
X
X		length = 0;
X		need_copy_in = 0;
X		need_copy_out = 0;
X
X		switch ((int)arg[1])
X		{
X		case FIONREAD:
X			length = sizeof(int);
X			need_copy_out = 1;
X			break;
X
X		case FLIOC_SENSE_DRIVE:
X			break;
X
X		case I_POP:
X			break;
X
X		case I_PUSH:
X			length = mstrlen(arg[2]) + 1;
X			need_copy_in = 1;
X			break;
X
X		case I_SRDOPT:
X			length = sizeof(arg[2]);
X			arg2_is_arg = 1;
X			break;
X
X		case STGET:
X			length = sizeof(struct stio);
X			need_copy_out = 1;
X			break;
X
X		case oTCGETA:
X		case TCGETA:
X			length = sizeof(struct termio);
X			need_copy_out = 1;
X			break;
X
X		case oTIOCGETP:
X			length = sgttybsize();
X			need_copy_out = 1;
X			break;
X
X		case oTIOCSETP:
X			length = sgttybsize();
X			need_copy_in = 1;
X			break;
X
X		case oTCSETA:
X		case TCSETA:
X		case oTCSETAF:
X		case TCSETAF:
X		case oTCSETAW:
X		case TCSETAW:
X			length = sizeof(struct termio);
X			need_copy_in = 1;
X			break;
X
X		case TCFLSH:
X		case TCSBRK:
X		case TCXONC:
X			length = sizeof(arg[2]);
X			arg2_is_arg = 1;
X			break;
X
X		case oFIOCLEX:
X		case oFIONCLEX:
X			break;
X
X		case oTIOCEXCL:
X		case TIOCEXCL:
X			break;
X
X		case TIOCGPGRP:
X			length = sizeof(int);
X			need_copy_out = 1;
X			break;
X
X		case TIOCGWINSZ:
X			length = sizeof(struct winsize);
X			need_copy_out = 1;
X			break;
X
X		case MTIOCGET:
X			/*
X		case oTIOCHPCL:
X			 * Somebody has stuffed up here...
X			 * The MTIOCGET returns a struct,
X			 * the oTIOCHPCL doesn't but
X			 * they've got the same ioctl encoding.
X			 * So we try to guess based on the
X			 * pointer arg...
X			 */
X			if (arg[2] != (unsigned long)0)
X			{
X				length = sizeof(struct mtget);
X				need_copy_out = 1;
X			}
X			break;
X
X		case MTIOCTOP:
X			length = sizeof(struct mtop);
X			need_copy_in = 1;
X			break;
X
X		case oTIOCNOTTY:
X		case TIOCNOTTY:
X			break;
X
X		case oTIOCNXCL:
X		case TIOCNXCL:
X			break;
X
X		case TIOCOUTQ:
X			length = sizeof(int);
X			need_copy_out = 1;
X			break;
X
X		case TIOCSPGRP:
X			length = sizeof(int);
X			need_copy_in = 1;
X			break;
X
X		case oTIOCSTI:
X		case TIOCSTI:
X			length = sizeof(char);
X			need_copy_in = 1;
X			break;
X
X		case TIOCSWINSZ:
X			length = sizeof(struct winsize);
X			need_copy_in = 1;
X			break;
X
X		case LDSETT:
X			length = sizeof(struct termcb);
X			need_copy_in = 1;
X			break;
X
X		default:
X			return -2;
X		}
X	}
X	else
X	{
X		/*
X		 * New style.
X		 */
X
X		need_copy_in = arg[1] & (unsigned long)IOC_IN;
X		need_copy_out = arg[1] & (unsigned long)IOC_OUT;
X		length = (arg[1] >> (unsigned long)16) & (unsigned long)IOCPARM_MASK;
X	}
X
X	if (length > 0)
X	{
X		if (bufset((unsigned int)length) == -1)
X			return -1;
X
X		if (need_copy_in)
X		{
X			if (quiet_procmget(GLOBALdipc, (unsigned long)arg[2], sys_call_buf, length) == -1)
X				return -1;
X		}
X	}
X
X	/*
X	 * TODO: But what about fd's hidden in ioctl() args?
X	 *       strioctl() calls, for example.
X	 */
X	Rstart;
X	return_value0 = syscall(syscallno, fd_lookup((int)arg[0]), (int)arg[1], arg2_is_arg ? (int)arg[2] : (int)sys_call_buf);
X	return_errno = errno;
X	Rstop;
X
X	if
X	(
X		need_copy_out
X		&&
X		return_value0 != -1
X		&&
X		quiet_procmput(GLOBALdipc, (unsigned long)arg[2], sys_call_buf, length) == -1
X	)
X		return -1;
X
X	return 0;
X}
X
X/*
X * Global entry point so that the bsd43 ioctl()
X * can call the sysv ioctl() when it finds that
X * it is really being called with sysv arguments
X * .. yes, this is fairly gross.
X */
Xint
Xsysv_sys_ioctl()
X{
X	static int	ive_been_called_before;
X	int		result;
X
X	if (ive_been_called_before)
X		result = -2;
X	else
X	{
X		ive_been_called_before = 1;
X		result = sys_ioctl(SYS_ioctl);
X	}
X
X	ive_been_called_before = 0;
X
X	return result;
X}
X
Xstatic
Xint
Xsys_lstat(syscallno)
Xint	syscallno;
X{
X	struct stat	statb;
X
X	return generic_lstat(syscallno, &statb, sizeof(statb));
X}
X
Xstatic
Xint
Xsys_ofcntl(syscallno)
Xint	syscallno;
X{
X	switch ((int)arg[1])
X	{
X	case F_GETFL:
X	case F_SETFL:
X		Rstart;
X		return_value0 = syscall(syscallno, fd_lookup((int)arg[0]), (int)arg[1], (int)arg[2]);
X		return_errno = errno;
X		Rstop;
X		break;
X
X	default:
X		return sys_fcntl(SYS_fcntl);
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_pipe(syscallno)
Xint	syscallno;
X{
X	int	fds[2];
X
X	Rstart;
X	return_value0 = pipe(&fds[0]);
X	return_errno = errno;
X	Rstop;
X
X	if (return_value0 != -1)
X	{
X		return_value0 = fd_open(fds[0]);
X		return_value1 = fd_open(fds[1]);
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_poll(syscallno)
Xint	syscallno;
X{
X	unsigned long	nfds;
X	int		timeout;
X	int		size;
X	struct pollfd	*fds;
X	int		fd;
X	int		*saved_fds;
X
X	nfds = arg[1];
X	timeout = arg[2];
X
X	size = nfds * sizeof(fds[0]);
X
X	if (bufset(size) == -1)
X		return -1;
X
X	if (mget(arg[0], sys_call_buf, size, &fds) == -1)
X		return -1;
X
X	if (fds != (struct pollfd *)0)
X	{
X		if ((saved_fds = (int *)malloc(nfds * sizeof(int))) == (int *)0)
X		{
X			vcouldnot("allocate space for %d poll fds", nfds);
X			return -1;
X		}
X
X		for (fd = 0; fd < nfds; fd++)
X		{
X			saved_fds[fd] = fds[fd].fd;
X			fds[fd].fd = fd_lookup(fds[fd].fd);
X		}
X	}
X
X	Rstart;
X	return_value0 = syscall(syscallno, fds, nfds, timeout);
X	return_errno = errno;
X	Rstop;
X
X	if (fds != (struct pollfd *)0)
X	{
X		for (fd = 0; fd < nfds; fd++)
X			fds[fd].fd = saved_fds[fd];
X
X		(void)free(saved_fds);
X	}
X
X	if (mput(arg[0], fds, size, return_value0) == -1)
X		return -1;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_recvfrom(syscallno)
Xint	syscallno;
X{
X	struct sockaddr	from;
X
X	return generic_recvfrom(syscallno, &from);
X}
X
Xstatic
Xint
Xsys_recvmsg(syscallno)
Xint	syscallno;
X{
X	struct msghdr	local_msghdr;
X	struct msghdr	saved_local_msghdr;
X	struct iovec	*saved_msg_iov;
X
X	if (quiet_procmget(GLOBALdipc, (unsigned long)arg[1], &local_msghdr, sizeof(local_msghdr)) == -1)
X		return -1;
X
X	saved_local_msghdr = local_msghdr;
X
X	/*
X	 * Copy in the optional address.
X	 */
X	if (local_msghdr.msg_name != (caddr_t)0)
X	{
X		caddr_t	name;
X
X		if ((name = (caddr_t)malloc(local_msghdr.msg_namelen)) == (caddr_t)0)
X		{
X			vcouldnot("allocate buffer for msg_name of length %d bytes", local_msghdr.msg_namelen);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)local_msghdr.msg_name, name, (unsigned int)local_msghdr.msg_namelen) == -1)
X			return -1;
X
X		local_msghdr.msg_name = name;
X	}
X
X	/*
X	 * Copy in the scatter/gather array.
X	 */
X	if (local_msghdr.msg_iov != (struct iovec *)0)
X	{
X		struct iovec	*v;
X		int		i;
X
X		if ((v = (struct iovec *)malloc(local_msghdr.msg_iovlen * sizeof(*v))) == (struct iovec *)0)
X		{
X			vcouldnot("allocate buffer for scatter/gather vector of %d elements", local_msghdr.msg_iovlen);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)local_msghdr.msg_iov, v, (unsigned int)local_msghdr.msg_iovlen * sizeof(*v)) == -1)
X			return -1;
X
X		local_msghdr.msg_iov = v;
X
X		/*
X		 * Save a copy of the array.
X		 */
X		if ((saved_msg_iov = (struct iovec *)malloc(local_msghdr.msg_iovlen * sizeof(*v))) == (struct iovec *)0)
X		{
X			vcouldnot("allocate buffer for saved scatter/gather vector of %d elements", local_msghdr.msg_iovlen);
X			return -1;
X		}
X
X		(void)memcpy(saved_msg_iov, v, local_msghdr.msg_iovlen * sizeof(*v));
X
X		/*
X		 * Copy in each entry of the array.
X		 */
X		for (i = 0; i < local_msghdr.msg_iovlen; i++)
X		{
X			struct iovec	*liovp;
X
X			liovp = &(local_msghdr.msg_iov[i]);
X
X			if (liovp->iov_base != (caddr_t)0)
X			{
X				caddr_t	b;
X
X				if ((b = (caddr_t)malloc(liovp->iov_len)) == (caddr_t)0)
X				{
X					vcouldnot("allocate buffer for member of scatter/gather vector of %d bytes", liovp->iov_len);
X					return -1;
X				}
X
X				if (quiet_procmget(GLOBALdipc, (unsigned long)liovp->iov_base, b, (unsigned int)liovp->iov_len) == -1)
X					return -1;
X
X				liovp->iov_base = b;
X			}
X		}
X	}
X
X	/*
X	 * Copy in the optional(?) access rights.
X	 */
X	if (local_msghdr.msg_accrights != (caddr_t)0)
X	{
X		caddr_t	a;
X
X		if ((a = (caddr_t)malloc(local_msghdr.msg_accrightslen)) == (caddr_t)0)
X		{
X			vcouldnot("allocate buffer for access rights of length %d bytes", local_msghdr.msg_accrightslen);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)local_msghdr.msg_accrights, a, (unsigned int)local_msghdr.msg_accrightslen) == -1)
X			return -1;
X
X		local_msghdr.msg_accrights = a;
X	}
X
X	Rstart;
X	return_value0 = syscall(syscallno, fd_lookup((int)arg[0]), &local_msghdr, (int)arg[2]);
X	return_errno = errno;
X	Rstop;
X
X	/*
X	 * Copy out fields to the user, free()'ing as we go.
X	 */
X
X	/*
X	 * Copy out the access rights.
X	 */
X	if (saved_local_msghdr.msg_accrights != (caddr_t)0)
X	{
X		if (quiet_procmput(GLOBALdipc, (unsigned long)saved_local_msghdr.msg_accrights, local_msghdr.msg_accrights, (unsigned int)local_msghdr.msg_accrightslen) == -1)
X			return -1;
X
X		(void)free((char *)local_msghdr.msg_accrights);
X	}
X
X	/*
X	 * Copy out the scatter/gather array.
X	 */
X	if (saved_local_msghdr.msg_iov != (struct iovec *)0)
X	{
X		int	i;
X
X		/*
X		 * Copy out each entry of the array.
X		 */
X		for (i = 0; i < local_msghdr.msg_iovlen; i++)
X		{
X			struct iovec	*liovp;
X
X			liovp = &(local_msghdr.msg_iov[i]);
X
X			if (saved_msg_iov[i].iov_base != (caddr_t)0)
X			{
X				if (quiet_procmput(GLOBALdipc, (unsigned long)saved_msg_iov[i].iov_base, liovp->iov_base, (unsigned int)liovp->iov_len) == -1)
X					return -1;
X				
X				(void)free(liovp->iov_base);
X			}
X		}
X
X		(void)free(saved_msg_iov);
X
X		/*
X		 * Copy out the reconstructed array itself?
X		 */
X
X		(void)free(local_msghdr.msg_iov);
X	}
X
X	/*
X	 * Copy out the received name and its length?
X	 */
X
X	(void)free(local_msghdr.msg_name);
X
X	return 0;
X}
X
X#define	select_dget(a,d,pp,m,nm)	\
X{ \
X	if (a == 0) \
X		pp = (struct fd_set *)0; \
X	else \
X	{ \
X		struct fd_set	tfds; \
X		int		fd; \
X \
X		if (quiet_procmget(GLOBALdipc, (unsigned long)a, &tfds, howmany(m, NFDBITS) * sizeof(fd_mask)) == -1) \
X			return -1; \
X \
X		FD_ZERO(&d); \
X \
X		for (fd = 0; fd < m; fd++) \
X		{ \
X			int	nfd; \
X \
X			if \
X			( \
X				FD_ISSET(fd, &tfds) \
X				&& \
X				(nfd = fd_lookup(fd)) != -1 \
X			) \
X			{ \
X				FD_SET(nfd, &d); \
X				if (nfd >= nm) \
X					nm = nfd + 1; \
X			} \
X		} \
X \
X		pp = &d; \
X	} \
X}
X
X#define	select_tget(a,d,p,t)	\
X{ \
X	if (a == 0) \
X		p = (t *)0; \
X	else \
X	{ \
X		if (quiet_procmget(GLOBALdipc, (unsigned long)a, &d, sizeof(d)) == -1) \
X			return -1; \
X \
X		p = &d; \
X	} \
X}
X
X#define	select_dput(a,pp,nn)	\
X{ \
X	if (a != 0) \
X	{ \
X		struct fd_set	tfds; \
X		int		fd; \
X \
X		FD_ZERO(&tfds); \
X \
X		for (fd = 0; fd < nn; fd++) \
X		{ \
X			int	nfd; \
X \
X			if \
X			( \
X				(nfd = fd_lookup(fd)) != -1 \
X				&& \
X				FD_ISSET(nfd, pp) \
X			) \
X				FD_SET(fd, &tfds); \
X		} \
X \
X		if (quiet_procmput(GLOBALdipc, (unsigned long)a, &tfds, howmany(nn, NFDBITS) * sizeof(fd_mask)) == -1) \
X			return -1; \
X	} \
X}
X
Xstatic
Xint
Xsys_select(syscallno)
Xint	syscallno;
X{
X	struct fd_set	rfds;
X	struct fd_set	*rfdsp;
X	struct fd_set	wfds;
X	struct fd_set	*wfdsp;
X	struct fd_set	efds;
X	struct fd_set	*efdsp;
X	struct timeval	timeout;
X	struct timeval	*timeoutp;
X	int		nfds;
X	int		newnfds;
X
X	nfds = (int)arg[0];
X	if (nfds > fd_nfiles())
X		nfds = fd_nfiles();
X	newnfds = 0;
X
X	select_dget(arg[1], rfds, rfdsp, nfds, newnfds);
X	select_dget(arg[2], wfds, wfdsp, nfds, newnfds);
X	select_dget(arg[3], efds, efdsp, nfds, newnfds);
X	select_tget(arg[4], timeout, timeoutp, struct timeval);
X
X	Rstart;
X	return_value0 = syscall(syscallno, newnfds, rfdsp, wfdsp, efdsp, timeoutp);
X	return_errno = errno;
X	Rstop;
X
X	if (return_value0 != -1)
X	{
X		select_dput(arg[3], efdsp, nfds);
X		select_dput(arg[2], wfdsp, nfds);
X		select_dput(arg[1], rfdsp, nfds);
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_sendmsg(syscallno)
Xint	syscallno;
X{
X	struct msghdr	local_msghdr;
X
X	if (quiet_procmget(GLOBALdipc, (unsigned long)arg[1], &local_msghdr, sizeof(local_msghdr)) == -1)
X		return -1;
X
X#if	0
Xfprintf(outfp, "local_msghdr.msg_name = 0x%x\n", local_msghdr.msg_name);
Xfprintf(outfp, "local_msghdr.msg_namelen = %d\n", local_msghdr.msg_namelen);
X#endif	/* 0 */
X
X	/*
X	 * Copy in the optional address.
X	 */
X	if (local_msghdr.msg_name != (caddr_t)0)
X	{
X		caddr_t	name;
X
X		if ((name = (caddr_t)malloc(local_msghdr.msg_namelen)) == (caddr_t)0)
X		{
X			vcouldnot("allocate buffer for msg_name of length %d bytes", local_msghdr.msg_namelen);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)local_msghdr.msg_name, name, (unsigned int)local_msghdr.msg_namelen) == -1)
X			return -1;
X
X		local_msghdr.msg_name = name;
X
X#if	0
X{
X	int	i;
X
X	fprintf(outfp, "msg_name =");
X	for (i = 0; i < local_msghdr.msg_namelen; i++)
X		fprintf(outfp, "%02x", local_msghdr.msg_name[i] & 0xFF);
X	fprintf(outfp, "\n");
X}
X#endif	/* 0 */
X	}
X
X#if	0
Xfprintf(outfp, "local_msghdr.msg_iov = 0x%x\n", local_msghdr.msg_iov);
Xfprintf(outfp, "local_msghdr.msg_iovlen = %d\n", local_msghdr.msg_iovlen);
X#endif	/* 0 */
X
X	/*
X	 * Copy in the scatter/gather array.
X	 */
X	if (local_msghdr.msg_iov != (struct iovec *)0)
X	{
X		struct iovec	*v;
X		int		i;
X
X		if ((v = (struct iovec *)malloc(local_msghdr.msg_iovlen * sizeof(*v))) == (struct iovec *)0)
X		{
X			vcouldnot("allocate buffer for scatter/gather vector of %d elements", local_msghdr.msg_iovlen);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)local_msghdr.msg_iov, v, (unsigned int)local_msghdr.msg_iovlen * sizeof(*v)) == -1)
X			return -1;
X
X		local_msghdr.msg_iov = v;
X
X		/*
X		 * Copy in each entry in the array.
X		 */
X		for (i = 0; i < local_msghdr.msg_iovlen; i++)
X		{
X			struct iovec	*liovp;
X
X			liovp = &(local_msghdr.msg_iov[i]);
X
X#if	0
Xfprintf(outfp, "local_msghdr.msg_iov[%d].iov_base = 0x%x\n", i, liovp->iov_base);
Xfprintf(outfp, "local_msghdr.msg_iov[%d].iov_len = %d\n", i, liovp->iov_len);
X#endif	/* 0 */
X
X			if (liovp->iov_base != (caddr_t)0)
X			{
X				caddr_t	b;
X
X				if ((b = (caddr_t)malloc(liovp->iov_len)) == (caddr_t)0)
X				{
X					vcouldnot("allocate buffer for member of scatter/gather vector of %d bytes", liovp->iov_len);
X					return -1;
X				}
X
X				if (quiet_procmget(GLOBALdipc, (unsigned long)liovp->iov_base, b, (unsigned int)liovp->iov_len) == -1)
X					return -1;
X
X				liovp->iov_base = b;
X			}
X		}
X	}
X
X#if	0
Xfprintf(outfp, "local_msghdr.msg_accrights = %d\n", local_msghdr.msg_accrights);
Xfprintf(outfp, "local_msghdr.msg_accrightslen = %d\n", local_msghdr.msg_accrightslen);
X#endif	/* 0 */
X
X	/*
X	 * Copy in the optional(?) access rights.
X	 */
X	if (local_msghdr.msg_accrights != (caddr_t)0)
X	{
X		caddr_t	a;
X
X		if ((a = (caddr_t)malloc(local_msghdr.msg_accrightslen)) == (caddr_t)0)
X		{
X			vcouldnot("allocate buffer for access rights of length %d bytes", local_msghdr.msg_accrightslen);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)local_msghdr.msg_accrights, a, (unsigned int)local_msghdr.msg_accrightslen) == -1)
X			return -1;
X
X		local_msghdr.msg_accrights = a;
X	}
X
X	Rstart;
X	return_value0 = syscall(syscallno, fd_lookup((int)arg[0]), &local_msghdr, (int)arg[2]);
X	return_errno = errno;
X	Rstop;
X
X	/*
X	 * Should we copy out any of these fields to the user?
X	 * Assuming "no" until demonstrated otherwise.
X	 */
X	
X	/*
X	 * Free up all the temporary space...
X	 */
X
X	if (local_msghdr.msg_accrights != (caddr_t)0)
X		(void)free((char *)local_msghdr.msg_accrights);
X
X	if (local_msghdr.msg_iov != (struct iovec *)0)
X	{
X		int	i;
X
X		for (i = 0; i < local_msghdr.msg_iovlen; i++)
X		{
X			struct iovec	*liovp;
X
X			liovp = &local_msghdr.msg_iov[i];
X
X			if (liovp->iov_base != (caddr_t)0)
X				(void)free((char *)liovp->iov_base);
X		}
X
X		(void)free((char *)local_msghdr.msg_iov);
X	}
X
X	if (local_msghdr.msg_name != (caddr_t)0)
X		(void)free((char *)local_msghdr.msg_name);
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_sendto(syscallno)
Xint	syscallno;
X{
X	struct sockaddr	to;
X
X	return generic_sendto(syscallno, &to);
X}
X
Xstatic
Xint
Xsys_setitimer(syscallno)
Xint	syscallno;
X{
X	struct itimerval	it;
X	struct itimerval	oit;
X
X	return generic_setitimer(syscallno, &it, sizeof(it), &oit, sizeof(oit));
X}
X
Xstatic
Xint
Xsys_setpgrp(syscallno)
Xint	syscallno;
X{
X	Rstart;
X	return_value0 = syscall(syscallno, arg[0]);
X	return_errno = errno;
X	Rstop;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_setrlimit(syscallno)
Xint	syscallno;
X{
X	return generic_setrlimit(syscallno, sizeof(struct rlimit));
X}
X
X#if	defined(SHARE)
Xstatic
Xint
Xsys_sharecosts(syscallno)
Xint	syscallno;
X{
X	int			function;
X	struct sh_consts	*address;
X	int			size;
X
X	function = arg[0];
X	size = arg[2];
X
X	if (dmget(arg[1], size, &address) == -1)
X		return -1;
X
X	Rstart;
X	return_value0 = syscall(syscallno, function, address, size);
X	return_errno = errno;
X	Rstop;
X
X	if (dmput(arg[1], address, size, return_value0) == -1)
X		return -1;
X
X	return 0;
X}
X#endif	/* defined(SHARE) */
X
X#if	0
X#define	SIG_DEBUG	1
X#endif	/* 0 */
X
X#define	SH_DFL		0
X#define	SH_HOLD		1
X
Xtypedef struct siginfo	siginfo;
Xstruct siginfo
X{
X	unsigned long		sig_handler;
X	int			sig_handler_type;
X	unsigned long		sig_tramp;
X	int			sig_code;
X	struct sigcontext	sig_context;
X	int			sig_pending;
X};
X
Xstatic siginfo		sinfo[NSIG];
X
Xint			sigs_pending;
X
Xstatic
Xvoid
Xour_handler(sig, code, scp)
Xint			sig;
Xint			code;
Xstruct sigcontext	*scp;
X{
X	sinfo[sig].sig_pending++;
X	sigs_pending++;
X
X	sinfo[sig].sig_code = code;
X	sinfo[sig].sig_context = *scp;
X
X#if	defined(SIG_DEBUG)
X	if (sysv_print_received_signal(U_SYSV, "sysv_debug", sinfo[sig].sig_tramp, sinfo[sig].sig_handler, sig, sinfo[sig].sig_code, scp) == -1)
X		return -1;
X#endif	/* defined(SIG_DEBUG) */
X
X	/*
X	 * All of our handlers are of the "sigset()" kind.
X	 * Normally this would mean that:
X	 *	1. during the execution of the handler, any
X	 *	   further arrivals of the same signal are held.
X	 *	2. on return from the handler, the same handler
X	 *	   is restored and any held signal is delivered.
X	 * We want to keep the first property but we want to
X	 * modify the second property so that, instead of
X	 * restoring the signal handler and re-enabling signals
X	 * immediately, we continue to hold signals
X	 * and only release them and restore the handler at
X	 * a later time (i.e. when we actually simulate signal delivery).
X	 * This assignment to "scp->is_sigset" accomplishes this.
X	 */
X	scp->is_sigset = 0;
X}
X
Xdinstrn	*
Xdeliver_signal(dipc)
Xdinstrn	*dipc;
X{
X	int			i;
X	struct sigcontext	*sscp;
X	int			regmask;
X	int			regbit;
X	int			regi;
X
X	for (i = 0; i < nels(sinfo); i++)
X	{
X		if (sinfo[i].sig_pending > 0)
X		{
X			/*
X			 * Massage saved sigcontext.
X			 */
X			sinfo[i].sig_context.sc_pc = dipc->di_addr;
X
X			regmask = 0xFFFFFFFF;	
X			sinfo[i].sig_context.sc_regmask = regmask;	
X
X			sinfo[i].sig_context.sc_regs[0] = 0;
X			for
X			(
X				regi = 1, regbit = 1 << 1;
X				regi < nels(sinfo[i].sig_context.sc_regs);
X				regi++, regbit <<= 1
X			)
X			{
X				if (regmask & regbit)
X				{
X					int	saved_give_warnings;
X
X					if (PG(regi) == R_K0 || PG(regi) == R_K1)
X					{
X						saved_give_warnings = give_warnings;
X						give_warnings = 0;
X					}
X
X					if (quiet_procsget(PG(regi), &sinfo[i].sig_context.sc_regs[regi]) == -1)
X						return dipc;
X
X					if (PG(regi) == R_K0 || PG(regi) == R_K1)
X						give_warnings = saved_give_warnings;
X				}
X			}
X
X			if (quiet_procsget(R_HI, &sinfo[i].sig_context.sc_mdhi) == -1)
X				return dipc;
X
X			if (quiet_procsget(R_LO, &sinfo[i].sig_context.sc_mdlo) == -1)
X				return dipc;
X#if	0
X			/*
X			 * TODO: floating point? exceptions?
X			 */
X			{
X				int *srp, *frp;
X				uint *urp;
X
X				scp->sc_ownedfp = u.u_pcb.pcb_ownedfp;
X
X				if ((regmask & 1) && u.u_pcb.pcb_ownedfp)
X				{
X					checkfp (u.u_procp, 0);	/* dump fp to pcb */
X					for
X					(
X						srp = &scp->sc_fpregs[0], frp = u.u_pcb.pcb_fpregs;
X						frp < &u.u_pcb.pcb_fpregs[32];
X						srp++, frp++
X					)
X						*srp = *frp;
X					scp->sc_fpc_csr = u.u_pcb.pcb_fpc_csr;
X					scp->sc_fpc_eir = u.u_pcb.pcb_fpc_eir;
X					u.u_pcb.pcb_fpc_csr &= ~FPCSR_EXCEPTIONS;
X				}
X
X				scp->sc_cause = USER_REG(EF_CAUSE);
X				scp->sc_badvaddr = USER_REG(EF_BADVADDR);
X			}
X#endif	/* 0 */
X
X			/*
X			 * Store massaged sigcontext on stack.
X			 */
X			if (quiet_procsget(R_SP, &sscp) == -1)
X				return dipc;
X
X			/*
X			 * Make room.
X			 */
X			sscp--;
X
X			/*
X			 * Ensure quad word aligned.
X			 */
X			sscp = (struct sigcontext *)(((unsigned long)sscp) & ~0xF);
X
X			if (quiet_procmput(GLOBALdipc, (unsigned long)sscp, &sinfo[i].sig_context, sizeof(sinfo[i].sig_context)) == -1)
X				return dipc;
X
X			if (Pflag || Sflag)
X			{
X				if (sysv_print_received_signal(U_SYSV, "sysv", sinfo[i].sig_tramp, sinfo[i].sig_handler, i, sinfo[i].sig_code, sscp) == -1)
X					return dipc;
X			}
X
X			/*
X			 * Set up arguments and SP for sig_tramp() call.
X			 */
X			if (quiet_procsput(R_A0, i) == -1)
X				return dipc;
X
X			if (quiet_procsput(R_A1, sinfo[i].sig_code) == -1)
X				return dipc;
X
X			if (quiet_procsput(R_A2, sscp) == -1)
X				return dipc;
X
X			if (quiet_procsput(R_SP, sscp) == -1)
X				return dipc;
X
X			if (quiet_procsput(R_A3, sinfo[i].sig_handler) == -1)
X				return dipc;
X
X			/*
X			 * Set up PC for sig_tramp() call.
X			 */
X			if ((dipc = addr_to_decoded_instrnp(dipc, sinfo[i].sig_tramp)) == (dinstrn *)0)
X				return dipc;
X
X			dipc--;
X
X			sigs_pending--;
X			sinfo[i].sig_pending--;
X
X			if (sinfo[i].sig_handler_type == SH_DFL)
X				(void)sigset(i, SIG_DFL);
X
X			break;
X		}
X	}
X
X	return dipc;
X}
X
Xstatic
Xint
Xsys_signal(syscallno)
Xint	syscallno;
X{
X	int	signo;
X	int	sigbits;
X
X	signo = arg[0] & SIGNO_MASK;
X	sigbits = arg[0] & ~SIGNO_MASK;
X
X	switch ((int)arg[1])
X	{
X	case SIG_IGN:
X	case SIG_DFL:
X	case SIG_HOLD:
X		return_value0 = (long)sigset(signo, arg[1]);
X		if
X		(
X			return_value0 != (long)SIG_ERR
X			&&
X			return_value0 != (long)SIG_DFL
X			&&
X			return_value0 != (long)SIG_IGN
X			&&
X			return_value0 != (long)SIG_HOLD
X		)
X			return_value0 = sinfo[signo].sig_handler;
X
X		if (return_value0 != (long)SIG_ERR)
X			sinfo[signo].sig_handler = arg[1];
X		break;
X
X	default:
X		switch (sigbits)
X		{
X		case SIGHOLD:
X			return_value0 = (long)sighold(signo);
X			break;
X
X		case SIGRELSE:
X			return_value0 = (long)sigrelse(signo);
X			break;
X
X		case SIGIGNORE:
X			return_value0 = (long)sigignore(signo);
X			break;
X
X		case SIGPAUSE:
X			return_value0 = (long)sigpause(signo);
X			break;
X
X		case SIGDEFER:
X			return_value0 = (long)sigset(signo, our_handler);
X			if
X			(
X				return_value0 != (long)SIG_ERR
X				&&
X				return_value0 != (long)SIG_DFL
X				&&
X				return_value0 != (long)SIG_IGN
X				&&
X				return_value0 != (long)SIG_HOLD
X			)
X				return_value0 = sinfo[signo].sig_handler;
X
X			if (return_value0 != (long)SIG_ERR)
X			{
X				sinfo[signo].sig_handler = arg[1];
X				sinfo[signo].sig_handler_type = SH_HOLD;
X				sinfo[signo].sig_tramp = arg[2];
X			}
X			break;
X
X		default:
X			return_value0 = (long)sigset(signo, our_handler);
X			if
X			(
X				return_value0 != (long)SIG_ERR
X				&&
X				return_value0 != (long)SIG_DFL
X				&&
X				return_value0 != (long)SIG_IGN
X				&&
X				return_value0 != (long)SIG_HOLD
X			)
X				return_value0 = sinfo[signo].sig_handler;
X
X			if (return_value0 != (long)SIG_ERR)
X			{
X				sinfo[signo].sig_handler = arg[1];
X				sinfo[signo].sig_handler_type = SH_DFL;
X				sinfo[signo].sig_tramp = arg[2];
X			}
X			break;
X		}
X		break;
X	}
X
X	return_errno = errno;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_sigreturn(syscallno)
Xint	syscallno;
X{
X	struct sigcontext	sc;
X	struct sigcontext	*scp;
X	int			regmask;
X	int			regi;
X	int			regbit;
X
X	if (mget(arg[0], &sc, sizeof(sc), &scp) == -1)
X		return -1;
X
X	if (scp == (struct sigcontext *)0)
X	{
X		return_value0 = -1;
X		return_errno = EFAULT;
X		return 0;
X	}
X
X#if	0
X	/*
X	 * TODO: floating point? exceptions?
X	 */
X	{
X		int *srp, *frp;
X		uint *urp;
X
X		scp->sc_ownedfp = u.u_pcb.pcb_ownedfp;
X
X		if ((regmask & 1) && u.u_pcb.pcb_ownedfp)
X		{
X			checkfp (u.u_procp, 0);	/* dump fp to pcb */
X			for
X			(
X				srp = &scp->sc_fpregs[0], frp = u.u_pcb.pcb_fpregs;
X				frp < &u.u_pcb.pcb_fpregs[32];
X				srp++, frp++
X			)
X				*srp = *frp;
X			scp->sc_fpc_csr = u.u_pcb.pcb_fpc_csr;
X			scp->sc_fpc_eir = u.u_pcb.pcb_fpc_eir;
X			u.u_pcb.pcb_fpc_csr &= ~FPCSR_EXCEPTIONS;
X		}
X
X		scp->sc_cause = USER_REG(EF_CAUSE);
X		scp->sc_badvaddr = USER_REG(EF_BADVADDR);
X	}
X#endif	/* 0 */
X
X	if (quiet_procsput(R_HI, scp->sc_mdhi) == -1)
X		return -1;
X
X	if (quiet_procsput(R_LO, scp->sc_mdlo) == -1)
X		return -1;
X
X	regmask = scp->sc_regmask;
X
X	for
X	(
X		regi = 1, regbit = 1 << 1;
X		regi < nels(scp->sc_regs);
X		regi++, regbit <<= 1
X	)
X	{
X		if (regmask & regbit)
X		{
X			int	saved_give_warnings;
X
X			if (PG(regi) == R_K0 || PG(regi) == R_K1)
X			{
X				saved_give_warnings = give_warnings;
X				give_warnings = 0;
X			}
X
X			if (quiet_procsput(PG(regi), scp->sc_regs[regi]) == -1)
X				return -1;
X
X			if (PG(regi) == R_K0 || PG(regi) == R_K1)
X				give_warnings = saved_give_warnings;
X		}
X	}
X
X	/*
X	 * Set up PC for return.
X	 */
X	if ((GLOBALdipc = addr_to_decoded_instrnp(GLOBALdipc, scp->sc_pc)) == (dinstrn *)0)
X		return -1;
X
X	GLOBALdipc--;
X
X	if (scp->is_sigset != 0)
X		(void)sigrelse(scp->is_sigset & SIGNO_MASK);
X
X	/*
X	 * Set up tidy but unused return values.
X	 */
X	return_value0 = 0;
X	return_errno = 0;
X
X	return -3;
X}
X
Xstatic
Xint
Xsys_stat(syscallno)
Xint	syscallno;
X{
X	struct stat	statb;
X
X	return generic_stat(syscallno, &statb, sizeof(statb));
X}
X
Xstatic
Xint
Xsys_statfs(syscallno)
Xint	syscallno;
X{
X	char		*cp;
X	int		len;
X	struct statfs	buf;
X	struct statfs	*bufp;
X
X	if (mgets(arg[0], &cp) == -1)
X		return -1;
X
X	len = arg[2];
X
X	if (mget(arg[1], &buf, len, &bufp) == -1)
X		return -1;
X
X	Rstart;
X	return_value0 = syscall(syscallno, cp, bufp, len, (int)arg[3]);
X	return_errno = errno;
X	Rstop;
X
X	if (mput(arg[1], bufp, len, return_value0) == -1)
X		return -1;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_sysfs(syscallno)
Xint	syscallno;
X{
X	char	*cp;
X	char	buf[FSTYPSZ];
X
X	switch (arg[0])
X	{
X	case GETFSIND:
X		if (mgets(arg[1], &cp) == -1)
X			return -1;
X
X		Rstart;
X		return_value0 = syscall(syscallno, arg[0], cp);
X		return_errno = errno;
X		Rstop;
X
X		break;
X
X	case GETFSTYP:
X		Rstart;
X		return_value0 = syscall(syscallno, arg[0], arg[1], &buf[0]);
X		return_errno = errno;
X		Rstop;
X
X		if (mput(arg[2], &buf[0], sizeof(buf), return_value0) == -1)
X			return -1;
X		break;
X
X	case GETNFSTYP:
X		Rstart;
X		return_value0 = syscall(syscallno, arg[0]);
X		return_errno = errno;
X		Rstop;
X		break;
X
X	default:
X		return -2;
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_times(syscallno)
Xint	syscallno;
X{
X	return generic_times(syscallno, sizeof(struct tms));
X}
X
Xstatic
Xint
Xsys_utime(syscallno)
Xint	syscallno;
X{
X	time_t	t[2];
X
X	return generic_utime(syscallno, &t[0], sizeof(t));
X}
X
Xstatic
Xint
Xsys_utssys(syscallno)
Xint	syscallno;
X{
X	struct utsname	*utsnp;
X	struct ustat	*ubp;
X
X	switch (arg[2])
X	{
X	case 0:	/* uname */
X		if (dmget(arg[0], sizeof(*utsnp), &utsnp) == -1)
X			return -1;
X
X		Rstart;
X		return_value0 = syscall(syscallno, utsnp, 0, arg[2]);
X		return_errno = errno;
X		Rstop;
X
X		if (dmput(arg[0], utsnp, sizeof(*utsnp), return_value0) == -1)
X			return -1;
X		break;
X
X	case 2:	/* ustat */
X		if (dmget(arg[0], sizeof(*ubp), &ubp) == -1)
X			return -1;
X
X		Rstart;
X		return_value0 = syscall(syscallno, ubp, arg[1], arg[2]);
X		return_errno = errno;
X		Rstop;
X
X		if (dmput(arg[0], ubp, sizeof(*ubp), return_value0) == -1)
X			return -1;
X		break;
X
X	default:
X		return -2;
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_wait3(syscallno)
Xint	syscallno;
X{
X	union wait	s;
X	struct rusage	r;
X
X	return generic_wait3(syscallno, &s, sizeof(s), &r, sizeof(r));
X}
X
Xstatic sysentry	sysv_systab[]	=
X{
X	{ "syscall",	1,	"d",	'd',	(int (*)())0,	},
X	{ "_exit",	1,	"d",	'e',	generic_exit,	},
X	{ "fork",	0,	"",	'Y',	generic_fork,	},
X	{ "read",	3,	"dRd",	'd',	generic_read,	},
X	{ "write",	3,	"dWd",	'd',	generic_write,	},
X	{ "open",	3,	"FOm",	'd',	generic_open,	},
X	{ "close",	1,	"d",	'd',	generic_close,	},
X	{ "Owait",	0,	"",	'\0',	(int (*)())0,	},
X	{ "creat",	2,	"Fm",	'd',	generic_creat,	},
X	{ "link",	2,	"FF",	'd',	generic_link,	},
X
X	{ "unlink",	1,	"F",	'd',	generic_unlink,	},
X	{ "Oexecv",	0,	"",	'\0',	(int (*)())0,	},
X	{ "chdir",	1,	"F",	'd',	generic_chdir,	},
X	{ "time",	1,	"v",	't',	generic_time,	},
X	{ "mknod",	3,	"Fmx",	'd',	generic_mknod,	},
X	{ "chmod",	2,	"Fm",	'd',	generic_chmod,	},
X	{ "chown",	3,	"Fdd",	'd',	generic_chown,	},
X	{ "brk",	1,	"I",	'd',	generic_brk,	},
X	{ "stat",	2,	"FS",	'd',	sys_stat,	},
X	{ "lseek",	3,	"duw",	'u',	generic_lseek,	},
X
X	{ "getpid",	0,	"",	'd',	generic_getpid,	},
X	{ "mount",	0,	"",	'\0',	(int (*)())0,	},
X	{ "umount",	0,	"",	'\0',	(int (*)())0,	},
X	{ "setuid",	1,	"d",	'd',	generic_setuid,	},
X	{ "getuid",	0,	"",	'Y',	sys_getuid,	},
X	{ "stime",	1,	"v",	'd',	generic_stime,	},
X	{ "ptrace",	4,	"ddxd",	'd',	generic_ptrace,	},
X	{ "alarm",	1,	"d",	'd',	generic_alarm,	},
X	{ "fstat",	2,	"dS",	'd',	sys_fstat,	},
X	{ "pause",	0,	"",	'd',	generic_pause,	},
X
X	{ "utime",	2,	"FQ",	'd',	sys_utime,	},
X	{ "Ostty",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Ogtty",	0,	"",	'\0',	(int (*)())0,	},
X	{ "access",	2,	"FP",	'd',	generic_access,	},
X	{ "nice",	1,	"d",	'd',	generic_nice,	},
X	{ "statfs",	4,	"FXdd",	'd',	sys_statfs,	},
X	{ "sync",	0,	"",	'd',	generic_sync,	},
X	{ "kill",	2,	"dK",	'd',	generic_kill,	},
X	{ "fstatfs",	4,	"dXdd",	'd',	sys_fstatfs,	},
X	{ "setpgrp",	1,	"d",	'd',	sys_setpgrp,	},
X
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "dup",	1,	"d",	'd',	generic_dup,	},
X	{ "pipe",	0,	"",	'Y',	sys_pipe,	},
X	{ "times",	1,	"k",	'd',	sys_times,	},
X	{ "profil",	4,	"Iddd",	'd',	generic_profil,	},
X	{ "plock",	1,	"d",	'd',	generic_plock,	},
X	{ "setgid",	1,	"d",	'd',	generic_setgid,	},
X	{ "getgid",	0,	"",	'Y',	sys_getgid,	},
X	{ "signal",	3,	"KJI",	'J',	sys_signal,	},
X	{ "msgsys",	0,	"",	'\0',	(int (*)())0,	},
X
X	{ "sysmips",	0,	"",	'\0',	(int (*)())0,	},
X	{ "acct",	1,	"F",	'd',	generic_acct,	},
X	{ "shmsys",	0,	"",	'\0',	(int (*)())0,	},
X	{ "semsys",	0,	"",	'\0',	(int (*)())0,	},
X	{ "ioctl",	3,	"dCA",	'd',	sys_ioctl,	},
X	{ "uadmin",	3,	"ddd",	'd',	generic_uadmin,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "utssys",	3,	"pdd",	'd',	sys_utssys,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "execve",	3,	"FlE",	'e',	sys_execve,	},
X
X	{ "umask",	1,	"x",	'x',	generic_umask,	},
X	{ "chroot",	1,	"F",	'd',	generic_chroot,	},
X	{ "ofcntl",	3,	"dxd",	'd',	sys_ofcntl,	},
X	{ "ulimit",	2,	"dd",	'd',	generic_ulimit,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X
X	{ "advfs",	0,	"",	'\0',	(int (*)())0,	},
X	{ "unadvfs",	0,	"",	'\0',	(int (*)())0,	},
X	{ "rmount",	0,	"",	'\0',	(int (*)())0,	},
X	{ "rumount",	0,	"",	'\0',	(int (*)())0,	},
X	{ "rfstart",	0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "rdebug",	0,	"",	'\0',	(int (*)())0,	},
X	{ "rfstop",	0,	"",	'\0',	(int (*)())0,	},
X	{ "rfsys",	0,	"",	'\0',	(int (*)())0,	},
X	{ "rmdir",	1,	"F",	'd',	generic_rmdir,	},
X
X	{ "mkdir",	2,	"Fm",	'd',	generic_mkdir,	},
X	{ "getdents",	3,	"dRd",	'd',	generic_getdents,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "sysfs",	3,	"dxp",	'd',	sys_sysfs,	},
X	{ "getmsg",	0,	"",	'\0',	(int (*)())0,	},
X	{ "putmsg",	0,	"",	'\0',	(int (*)())0,	},
X	{ "poll",	3,	"pdd",	'd',	sys_poll,	},
X	{ "sigreturn",	1,	"y",	'd',	sys_sigreturn,	},
X	{ "accept",	3,	"dLU",	'd',	generic_accept,	},
X
X	{ "bind",	3,	"dLd",	'd',	generic_bind,	},
X	{ "connect",	3,	"dLd",	'd',	generic_connect,	},
X	{ "gethostid",	0,	"",	'u',	generic_gethostid,	},
X	{ "getpeername", 3,	"dLU",	'd',	generic_getpeername, },
X	{ "getsockname", 3,	"dLU",	'd',	generic_getsockname, },
X	{ "getsockopt", 5,	"dddxU", 'd',	generic_getsockopt,	},
X	{ "listen",	2,	"dd",	'd',	generic_listen,	},
X	{ "recv",	4,	"dRdN",	'd',	generic_recv,	},
X	{ "recvfrom",	6,	"dRdNLU", 'd',	sys_recvfrom,	},
X	{ "recvmsg",	3,	"dpN",	'd',	sys_recvmsg,	},
X
X	{ "select",	5,	"dDDDT", 'd',	sys_select,	},
X	{ "send",	4,	"dWdN",	'd',	generic_send,	},
X	{ "sendmsg",	3,	"dpN",	'd',	sys_sendmsg,	},
X	{ "sendto",	6,	"dWdNLd", 'd',	sys_sendto,	},
X	{ "sethostid",	1,	"u",	'd',	generic_sethostid,	},
X	{ "setsockopt", 5,	"dddpd", 'd',	generic_setsockopt,	},
X	{ "shutdown",	2,	"dd",	'd',	generic_shutdown,	},
X	{ "socket",	3,	"abc",	'd',	generic_socket,	},
X	{ "gethostname", 2,	"xd",	'd',	generic_gethostname, },
X	{ "sethostname", 0,	"",	'\0',	(int (*)())0,	},
X
X	{ "getdomainname", 2,	"xd",	'd',	generic_getdomainname,	},
X	{ "setdomainname", 2,	"xd",	'd',	generic_setdomainname, },
X	{ "truncate",	2,	"Fu",	'd',	generic_truncate,	},
X	{ "ftruncate",	2,	"du",	'd',	generic_ftruncate,	},
X	{ "rename",	2,	"FF",	'd',	generic_rename,	},
X	{ "symlink",	2,	"FF",	'd',	generic_symlink,	},
X	{ "readlink",	3,	"FRd",	'd',	generic_readlink,	},
X	{ "lstat",	2,	"FS",	'd',	sys_lstat,	},
X	{ "nfsmount",	0,	"",	'\0',	(int (*)())0,	},
X	{ "nfssvc",	0,	"",	'd',	generic_nfssvc,	},
X
X	{ "getfh",	0,	"",	'\0',	(int (*)())0,	},
X	{ "async_daemon", 0,	"",	'd',	generic_async_daemon, },
X	{ "old_exportfs", 0,	"",	'\0',	(int (*)())0,	},
X	{ "mmap",	0,	"",	'\0',	(int (*)())0,	},
X	{ "munmap",	0,	"",	'\0',	(int (*)())0,	},
X	{ "getitimer",	2,	"dV",	'd',	sys_getitimer,	},
X	{ "setitimer",	3,	"dVV",	'd',	sys_setitimer,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X
X	{ "cacheflush", 3,	"Idd",	'd',	generic_cacheflush,	},
X	{ "cachectl",	3,	"Idd",	'd',	generic_cachectl,	},
X	{ "fchown",	3,	"ddd",	'd',	generic_fchown,	},
X	{ "fchmod",	2,	"dm",	'd',	generic_fchmod,	},
X	{ "wait3",	3,	"hij",	'd',	sys_wait3,	},
X	{ "mmap",	0,	"",	'\0',	(int (*)())0,	},
X	{ "munmap",	0,	"",	'\0',	(int (*)())0,	},
X	{ "madvise",	0,	"",	'\0',	(int (*)())0,	},
X	{ "getpagesize",0,	"",	'd',	generic_getpagesize, },
X	{ "setreuid",	2,	"dd",	'd',	generic_setreuid,	},
X
X	{ "setregid",	2,	"dd",	'd',	generic_setregid,	},
X	{ "setpgid",	2,	"dd",	'd',	generic_setpgid,	},
X	{ "getgroups",	2,	"dG",	'd',	sys_getgroups,	},
X	{ "setgroups",	2,	"dg",	'd',	generic_setgroups,	},
X	{ "gettimeofday", 2,	"TZ",	'd',	sys_gettimeofday, },
X	{ "getrusage",	2,	"dx",	'd',	sys_getrusage,	},
X	{ "getrlimit",	2,	"dx",	'd',	sys_getrlimit,	},
X	{ "setrlimit",	2,	"dx",	'd',	sys_setrlimit,	},
X	{ "exportfs",	0,	"",	'\0',	(int (*)())0,	},
X	{ "fcntl",	3,	"dBH",	'd',	sys_fcntl,	},
X#if	0
XAnd then, a long way on at 260, 261 and 262 there are:
X	{ "netboot",	0,	"",	'\0',	(int (*)())0,	},
X	{ "netunboot",	0,	"",	'\0',	(int (*)())0,	},
X	{ "rdump",	0,	"",	'\0',	(int (*)())0,	},
Xbut they aren't used.
X#endif	/* 0 */
X};
X
X#if	defined(LIMITS)
Xstatic sysentry	limits_sysv_systab[]	=
X{
X	{ "setlim",	2,	"",	'\0',	(int (*)())0,	}, /* 320 */
X	{ "getlim",	3,	"dxd",	'd',	sys_getlim,	}, /* 321 */
X	{ "limonoff",	1,	"",	'\0',	(int (*)())0,	}, /* 322 */
X};
X#endif	/* defined(LIMITS) */
X
X#if	defined(SHARE)
Xstatic sysentry	share_sysv_systab[]	=
X{
X	{ "sharecosts",	3,	"dxd",	'd',	sys_sharecosts,	}, /* 323 */
X	{ "gettab",	4,	"",	'\0',	(int (*)())0,	}, /* 324 */
X};
X#endif	/* defined(SHARE) */
X
Xsysentry	*
Xsysv_systab_entry(n)
Xint	n;
X{
X	int	nn;
X
X	if (n >= 0 && n < nels(sysv_systab))
X		return &sysv_systab[n];
X
X#if	defined(LIMITS)
X	nn = n - (LIMITSoffset - SYSVoffset);
X
X	if (nn >= 0 && nn < nels(limits_sysv_systab))
X		return &limits_sysv_systab[nn];
X#endif	/* defined(LIMITS) */
X
X#if	defined(SHARE)
X	nn = n - (SHAREoffset - SYSVoffset);
X
X	if (nn >= 0 && nn < nels(share_sysv_systab))
X		return &share_sysv_systab[nn];
X#endif	/* defined(SHARE) */
X
X	return (sysentry *)0;
X}
X
Xint
Xsysv_print_open_flags(arg)
Xunsigned long	arg;
X{
X	need_leading_pipe = 0;
X
X	if ((arg & (O_WRONLY | O_RDWR)) == 0)
X	{
X		say_flag(O_RDONLY, "O_RDONLY", arg);
X	}
X	else
X	{
X		say_flag(O_WRONLY, "O_WRONLY", arg);
X		say_flag(O_RDWR, "O_RDWR", arg);
X	}
X
X	say_flag(O_APPEND, "O_APPEND", arg);
X	say_flag(O_CREAT, "O_CREAT", arg);
X	say_flag(O_EXCL, "O_EXCL", arg);
X	say_flag(O_NDELAY, "O_NDELAY", arg);
X	say_flag(O_SYNC, "O_SYNC", arg);
X	say_flag(O_TRUNC, "O_TRUNC", arg);
X
X	say_residual(arg);
X
X	return 0;
X}
X
Xint
Xsysv_print_stat(arg)
Xlong	arg;
X{
X	struct stat	statbuf;
X
X	if (quiet_procmget(GLOBALdipc, (unsigned long)arg, (char *)&statbuf, sizeof(statbuf)) == -1)
X		return -1;
X
X	fprintf(outfp, "{" /* } */ );
X	fprintf(outfp, "st_dev=0x%x,", statbuf.st_dev);
X	fprintf(outfp, " st_ino=%d,", statbuf.st_ino);
X	fprintf(outfp, " st_mode=0x%x,", statbuf.st_mode);
X	fprintf(outfp, " st_nlink=%d,", statbuf.st_nlink);
X	fprintf(outfp, " st_uid=%d,", statbuf.st_uid);
X	fprintf(outfp, " st_gid=%d,", statbuf.st_gid);
X	fprintf(outfp, " st_rdev=0x%x,", statbuf.st_rdev);
X	fprintf(outfp, " st_size=%d,", statbuf.st_size);
X	fprintf(outfp, " st_atime=");
X	say_time(outfp, statbuf.st_atime);
X	fprintf(outfp, ",");
X	fprintf(outfp, " st_mtime=");
X	say_time(outfp, statbuf.st_mtime);
X	fprintf(outfp, ",");
X	fprintf(outfp, " st_ctime=");
X	say_time(outfp, statbuf.st_ctime);
X	fprintf(outfp, ",");
X	fprintf(outfp, /* { */ "}");
X
X	return 0;
X}
X
Xint
Xsysv_print_ioctl_cmd(cmd)
Xunsigned long	cmd;
X{
X	char	*cname;
X
X	switch (cmd)
X	{
X	case FIONREAD:
X		cname = "FIONREAD";
X		break;
X
X	case I_POP:
X		cname = "I_POP";
X		break;
X
X	case I_PUSH:
X		cname = "I_PUSH";
X		break;
X
X	case I_SRDOPT:
X		cname = "I_SRDOPT";
X		break;
X
X	case STGET:
X		cname = "STGET";
X		break;
X
X	case oTCGETA:
X		cname = "oTCGETA";
X		break;
X
X	case TCGETA:
X		cname = "TCGETA";
X		break;
X
X	case oTCSETA:
X		cname = "oTCSETA";
X		break;
X
X	case TCSETA:
X		cname = "TCSETA";
X		break;
X
X	case oTCSETAF:
X		cname = "oTCSETAF";
X		break;
X
X	case TCSETAF:
X		cname = "TCSETAF";
X		break;
X
X	case oTCSETAW:
X		cname = "oTCSETAW";
X		break;
X
X	case TCSETAW:
X		cname = "TCSETAW";
X		break;
X
X	case TCFLSH:
X		cname = "TCFLSH";
X		break;
X
X	case TCSBRK:
X		cname = "TCSBRK";
X		break;
X
X	case TCXONC:
X		cname = "TCXONC";
X		break;
X
X	case oTIOCEXCL:
X		cname = "oTIOCEXCL";
X		break;
X
X	case TIOCEXCL:
X		cname = "TIOCEXCL";
X		break;
X
X	case TIOCGPGRP:
X		cname = "TIOCGPGRP";
X		break;
X
X	case TIOCGWINSZ:
X		cname = "TIOCGWINSZ";
X		break;
X
X	case oTIOCHPCL:
X		cname = "oTIOCHPCL";
X		break;
X
X	case oTIOCNOTTY:
X		cname = "oTIOCNOTTY";
X		break;
X
X	case TIOCNOTTY:
X		cname = "TIOCNOTTY";
X		break;
X
X	case oTIOCNXCL:
X		cname = "oTIOCNXCL";
X		break;
X
X	case TIOCNXCL:
X		cname = "TIOCNXCL";
X		break;
X
X	case TIOCOUTQ:
X		cname = "TIOCOUTQ";
X		break;
X
X	case TIOCSPGRP:
X		cname = "TIOCSPGRP";
X		break;
X
X	case oTIOCSTI:
X		cname = "oTIOCSTI";
X		break;
X
X	case TIOCSTI:
X		cname = "TIOCSTI";
X		break;
X
X	case TIOCSWINSZ:
X		cname = "TIOCSWINSZ";
X		break;
X
X	case LDSETT:
X		cname = "LDSETT";
X		break;
X
X	default:
X		cname = (char *)0;
X		break;
X	}
X
X	if (cname == (char *)0)
X		fprintf(outfp, "0x%x", cmd);
X	else
X		fprintf(outfp, "%s", cname);
X
X	return 0;
X}
X
Xstatic
Xint
Xsay_termcb(arg)
Xunsigned long	arg;
X{
X	struct termcb	tio;
X
X	if (quiet_procmget(GLOBALdipc, arg, &tio, sizeof(tio)) == -1)
X		return -1;
X
X	fprintf(outfp, "{");
X
X	/*
X	 * term flags.
X	 */
X
X	fprintf(outfp, "st_flgs=");
X
X	need_leading_pipe = 0;
X
X	say_notflag(TM_NONE, "TM_NONE", tio.st_flgs);
X	say_flag(TM_SNL, "TM_SNL", tio.st_flgs);
X	say_flag(TM_ANL, "TM_ANL", tio.st_flgs);
X	say_flag(TM_LCF, "TM_LCF", tio.st_flgs);
X	say_flag(TM_CECHO, "TM_CECHO", tio.st_flgs);
X	say_flag(TM_CINVIS, "TM_CINVIS", tio.st_flgs);
X	say_flag(TM_SET, "TM_SET", tio.st_flgs);
X
X	say_residual(tio.st_flgs);
X
X	/*
X	 * term type.
X	 */
X
X	fprintf(outfp, ", st_termt=");
X
X	switch (tio.st_termt)
X	{
X	case TERM_NONE:
X		fprintf(outfp, "TERM_NONE");
X		break;
X
X	case TERM_TEC:
X		fprintf(outfp, "TERM_TEC");
X		break;
X
X	case TERM_V61:
X		fprintf(outfp, "TERM_V61");
X		break;
X
X	case TERM_V10:
X		fprintf(outfp, "TERM_V10");
X		break;
X
X	case TERM_TEX:
X		fprintf(outfp, "TERM_TEX");
X		break;
X
X	case TERM_D40:
X		fprintf(outfp, "TERM_D40");
X		break;
X
X	case TERM_H45:
X		fprintf(outfp, "TERM_H45");
X		break;
X
X	case TERM_D42:
X		fprintf(outfp, "TERM_D42");
X		break;
X
X	default:
X		fprintf(outfp, "0x%x", tio.st_termt);
X		break;
X	}
X
X	/*
X	 * gtty only - current row.
X	 */
X	fprintf(outfp, ", st_crow=%d", tio.st_crow);
X
X	/*
X	 * gtty only - current col.
X	 */
X	fprintf(outfp, ", st_ccol=%d", tio.st_ccol);
X
X	/*
X	 * variable row.
X	 */
X	fprintf(outfp, ", st_vrow=%d", tio.st_vrow);
X
X	/*
X	 * last row.
X	 */
X	fprintf(outfp, ", st_lrow=%d", tio.st_lrow);
X
X	fprintf(outfp, "}");
X
X	return 0;
X}
X
Xstatic
Xint
Xsay_termiob(arg)
Xunsigned long	arg;
X{
X	struct termio	tio;
X
X	if (quiet_procmget(GLOBALdipc, arg, &tio, sizeof(tio)) == -1)
X		return -1;
X
X	fprintf(outfp, "{");
X
X	/*
X	 * Input modes.
X	 */
X
X	fprintf(outfp, "c_iflag=");
X
X	need_leading_pipe = 0;
X
X	say_flag(IGNBRK, "IGNBRK", tio.c_iflag);
X	say_flag(BRKINT, "BRKINT", tio.c_iflag);
X	say_flag(IGNPAR, "IGNPAR", tio.c_iflag);
X	say_flag(PARMRK, "PARMRK", tio.c_iflag);
X	say_flag(INPCK, "INPCK", tio.c_iflag);
X	say_flag(ISTRIP, "ISTRIP", tio.c_iflag);
X	say_flag(INLCR, "INLCR", tio.c_iflag);
X	say_flag(IGNCR, "IGNCR", tio.c_iflag);
X	say_flag(ICRNL, "ICRNL", tio.c_iflag);
X	say_flag(IUCLC, "IUCLC", tio.c_iflag);
X	say_flag(IXON, "IXON", tio.c_iflag);
X	say_flag(IXANY, "IXANY", tio.c_iflag);
X	say_flag(IXOFF, "IXOFF", tio.c_iflag);
X
X	say_residual(tio.c_iflag);
X
X	/*
X	 * Output modes.
X	 */
X
X	fprintf(outfp, ", c_oflag=");
X
X	need_leading_pipe = 0;
X
X	say_flag(OPOST, "OPOST", tio.c_oflag);
X	say_flag(OLCUC, "OLCUC", tio.c_oflag);
X	say_flag(ONLCR, "ONLCR", tio.c_oflag);
X	say_flag(OCRNL, "OCRNL", tio.c_oflag);
X	say_flag(ONOCR, "ONOCR", tio.c_oflag);
X	say_flag(ONLRET, "ONLRET", tio.c_oflag);
X	say_flag(OFILL, "OFILL", tio.c_oflag);
X	say_flag(OFDEL, "OFDEL", tio.c_oflag);
X
X	say_notflag(NLDLY, "NL0", tio.c_oflag);
X	say_flag(NL1, "NL1", tio.c_oflag);
X
X	say_notflag(CRDLY, "CR0", tio.c_oflag);
X	say_flag(CR3, "CR3", tio.c_oflag);
X	say_flag(CR2, "CR2", tio.c_oflag);
X	say_flag(CR1, "CR1", tio.c_oflag);
X
X	say_notflag(TABDLY, "TAB0", tio.c_oflag);
X	say_flag(TAB3, "TAB3", tio.c_oflag);
X	say_flag(TAB2, "TAB2", tio.c_oflag);
X	say_flag(TAB1, "TAB1", tio.c_oflag);
X
X	say_notflag(BSDLY, "BS0", tio.c_oflag);
X	say_flag(BS1, "BS1", tio.c_oflag);
X
X	say_notflag(VTDLY, "VT0", tio.c_oflag);
X	say_flag(VT1, "VT1", tio.c_oflag);
X
X	say_notflag(FFDLY, "FF0", tio.c_oflag);
X	say_flag(FF1, "FF1", tio.c_oflag);
X
X	say_residual(tio.c_oflag);
X
X	/*
X	 * Hardware control modes.
X	 */
X
X	fprintf(outfp, ", c_cflag=");
X
X	switch (tio.c_cflag & CBAUD)
X	{
X	case B0:
X		fprintf(outfp, "B0");
X		break;
X
X	case B50:
X		fprintf(outfp, "B50");
X		break;
X
X	case B75:
X		fprintf(outfp, "B75");
X		break;
X
X	case B110:
X		fprintf(outfp, "B110");
X		break;
X
X	case B134:
X		fprintf(outfp, "B134");
X		break;
X
X	case B150:
X		fprintf(outfp, "B150");
X		break;
X
X	case B200:
X		fprintf(outfp, "B200");
X		break;
X
X	case B300:
X		fprintf(outfp, "B300");
X		break;
X
X	case B600:
X		fprintf(outfp, "B600");
X		break;
X
X	case B1200:
X		fprintf(outfp, "B1200");
X		break;
X
X	case B1800:
X		fprintf(outfp, "B1800");
X		break;
X
X	case B2400:
X		fprintf(outfp, "B2400");
X		break;
X
X	case B4800:
X		fprintf(outfp, "B4800");
X		break;
X
X	case B9600:
X		fprintf(outfp, "B9600");
X		break;
X
X	case B19200:
X		fprintf(outfp, "B19200");
X		break;
X
X	case B38400:
X		fprintf(outfp, "B38400");
X		break;
X	}
X
X	tio.c_cflag &= ~CBAUD;
X
X	need_leading_pipe = 1;
X
X	say_notflag(CSIZE, "CS5", tio.c_cflag);
X	say_flag(CS8, "CS8", tio.c_cflag);
X	say_flag(CS7, "CS7", tio.c_cflag);
X	say_flag(CS6, "CS6", tio.c_cflag);
X
X	say_flag(CSTOPB, "CSTOPB", tio.c_cflag);
X	say_flag(CREAD, "CREAD", tio.c_cflag);
X	say_flag(PARENB, "PARENB", tio.c_cflag);
X	say_flag(PARODD, "PARODD", tio.c_cflag);
X	say_flag(HUPCL, "HUPCL", tio.c_cflag);
X	say_flag(CLOCAL, "CLOCAL", tio.c_cflag);
X	say_flag(CNEW_RTSCTS, "CNEW_RTSCTS", tio.c_cflag);
X	say_flag(LOBLK, "LOBLK", tio.c_cflag);
X	say_flag(CNEW_MDMBUF, "CNEW_MDMBUF", tio.c_cflag);
X
X	say_residual(tio.c_cflag);
X
X	/*
X	 * Local flags.
X	 */
X
X	fprintf(outfp, ", c_lflag=");
X
X	need_leading_pipe = 0;
X
X	say_flag(ISIG, "ISIG", tio.c_lflag);
X	say_flag(ICANON, "ICANON", tio.c_lflag);
X	say_flag(XCASE, "XCASE", tio.c_lflag);
X	say_flag(ECHO, "ECHO", tio.c_lflag);
X	say_flag(ECHOE, "ECHOE", tio.c_lflag);
X	say_flag(ECHOK, "ECHOK", tio.c_lflag);
X	say_flag(ECHONL, "ECHONL", tio.c_lflag);
X	say_flag(NOFLSH, "NOFLSH", tio.c_lflag);
X	say_flag(TOSTOP, "TOSTOP", tio.c_lflag);
X	say_flag(LNEW_CTLECH, "LNEW_CTLECH", tio.c_lflag);
X	say_flag(LNEW_PRTERA, "LNEW_PRTERA", tio.c_lflag);
X	say_flag(LNEW_CRTBS, "LNEW_CRTBS", tio.c_lflag);
X	say_flag(LNEW_PENDIN, "LNEW_PENDIN", tio.c_lflag);
X	say_flag(LNEW_FLUSHO, "LNEW_FLUSHO", tio.c_lflag);
X
X	say_residual(tio.c_lflag);
X
X	/*
X	 * Line discipline.
X	 */
X
X	fprintf(outfp, ", c_line=%d", tio.c_line);
X
X	/*
X	 * Control chars.
X	 */
X
X	fprintf(outfp, ", c_cc=[");
X	fprintf(outfp, "VINTR=0x%02x,", tio.c_cc[VINTR]);
X	fprintf(outfp, "VQUIT=0x%02x,", tio.c_cc[VQUIT]);
X	fprintf(outfp, "VERASE=0x%02x,", tio.c_cc[VERASE]);
X	fprintf(outfp, "VKILL=0x%02x,", tio.c_cc[VKILL]);
X	fprintf(outfp, "VEOF=0x%02x,", tio.c_cc[VEOF]);
X	fprintf(outfp, "VEOL=0x%02x,", tio.c_cc[VEOL]);
X	fprintf(outfp, "VEOL2=0x%02x,", tio.c_cc[VEOL2]);
X	fprintf(outfp, "VSWTCH=0x%02x,", tio.c_cc[VSWTCH]);
X	fprintf(outfp, "V_START=0x%02x,", tio.c_cc[V_START]);
X	fprintf(outfp, "V_STOP=0x%02x,", tio.c_cc[V_STOP]);
X	fprintf(outfp, "V_SUSP=0x%02x,", tio.c_cc[V_SUSP]);
X	fprintf(outfp, "V_DSUSP=0x%02x,", tio.c_cc[V_DSUSP]);
X	fprintf(outfp, "V_RPRNT=0x%02x,", tio.c_cc[V_RPRNT]);
X	fprintf(outfp, "V_FLUSH=0x%02x,", tio.c_cc[V_FLUSH]);
X	fprintf(outfp, "V_WERAS=0x%02x,", tio.c_cc[V_WERAS]);
X	fprintf(outfp, "V_LNEXT=0x%02x,", tio.c_cc[V_LNEXT]);
X	fprintf(outfp, "V_STATUS=0x%02x,", tio.c_cc[V_STATUS]);
X	fprintf(outfp, "V_SAVED_EOF=0x%02x,", tio.c_cc[V_SAVED_EOF]);
X	fprintf(outfp, "V_SAVED_EOL=0x%02x,", tio.c_cc[V_SAVED_EOL]);
X	fprintf(outfp, "19=0x%02x,", tio.c_cc[19]);
X	fprintf(outfp, "20=0x%02x,", tio.c_cc[20]);
X	fprintf(outfp, "21=0x%02x,", tio.c_cc[21]);
X	fprintf(outfp, "22=0x%02x,", tio.c_cc[22]);
X	fprintf(outfp, "]");
X
X	/*
X	 * (bsd43) saved flags.
X	 */
X
X	fprintf(outfp, ", c_saved_flags=0x%x", tio.c_saved_flags);
X
X	/*
X	 * Filler.
X	 */
X
X	fprintf(outfp, ", c_filler=0x%x", tio.c_filler);
X
X	fprintf(outfp, "}");
X
X	return 0;
X}
X
Xint
Xsysv_print_ioctl_arg(args)
Xunsigned long	*args;
X{
X	int	i;
X
X	switch (args[1])
X	{
X	case FIONREAD:
X		if (quiet_procmget(GLOBALdipc, (unsigned long)args[2], &i, sizeof(i)) == -1)
X			return -1;
X
X		fprintf(outfp, "{*(int *)0x%x=%d}", args[2], i);
X		break;
X
X	case TCGETA:
X	case TCSETA:
X	case TCSETAW:
X	case TCSETAF:
X		if (say_termiob(args[2]) == -1)
X			return -1;
X
X		break;
X
X	case LDSETT:
X		if (say_termcb(args[2]) == -1)
X			return -1;
X
X		break;
X
X	default:
X		fprintf(outfp, "0x%x", args[2]);
X		break;
X	}
X
X	return 0;
X}
X
Xint
Xsysv_print_fdset(nfds, arg)
Xint		nfds;
Xunsigned long	arg;
X{
X	if (arg == (unsigned long)0)
X		fprintf(outfp, "0x%x", arg);
X	else
X	{
X		struct fd_set	tfds;
X		int		fd;
X
X		if (quiet_procmget(GLOBALdipc, arg, &tfds, sizeof(tfds)) == -1)
X			return -1;
X
X		fprintf(outfp, "{");
X
X		for (fd = 0; fd < nfds; fd++)
X		{
X			if (FD_ISSET(fd, &tfds))
X				fprintf(outfp, "%d,", fd);
X		}
X
X		fprintf(outfp, "}");
X	}
X
X	return 0;
X}
X
Xint
Xsysv_print_whence(arg)
Xunsigned long	arg;
X{
X	switch (arg)
X	{
X	case SEEK_SET:
X		fprintf(outfp, "SEEK_SET");
X		break;
X
X	case SEEK_CUR:
X		fprintf(outfp, "SEEK_CUR");
X		break;
X
X	case SEEK_END:
X		fprintf(outfp, "SEEK_END");
X		break;
X
X	default:
X		fprintf(outfp, "0x%x", arg);
X		break;
X	}
X
X	return 0;
X}
X
Xint
Xsysv_print_statfs(arg)
Xunsigned long	arg;
X{
X	if (arg == (unsigned long)0)
X		fprintf(outfp, "0x%x", arg);
X	else
X	{
X		struct statfs	t;
X
X		if (quiet_procmget(GLOBALdipc, arg, &t, sizeof(t)) == -1)
X			return -1;
X
X		fprintf(outfp, "{");
X		fprintf(outfp, "fstyp=%d,", t.f_fstyp);
X		fprintf(outfp, "bsize=%d,", t.f_bsize);
X		fprintf(outfp, "frsize=%d,", t.f_frsize);
X		fprintf(outfp, "blocks=%d,", t.f_blocks);
X		fprintf(outfp, "bfree=%d,", t.f_bfree);
X		fprintf(outfp, "files=%d,", t.f_files);
X		fprintf(outfp, "ffree=%d,", t.f_ffree);
X		vis_quoted_truncated_buffer(outfp, sizeof(t.f_fname), &t.f_fname[0], sizeof(t.f_fname));
X		fprintf(outfp, ",");
X		vis_quoted_truncated_buffer(outfp, sizeof(t.f_fpack), &t.f_fpack[0], sizeof(t.f_fpack));
X		fprintf(outfp, "}");
X	}
X	return 0;
X}
X
Xint
Xsysv_print_wait3_union_wait(arg)
Xunsigned long	arg;
X{
X	union wait	w;
X	union wait	*wp;
X
X	if (mget(arg, &w, sizeof(w), &wp) == -1)
X		return -1;
X
X	if (wp == (union wait *)0)
X		fprintf(outfp, "0x%x", arg);
X	else
X	{
X		fprintf(outfp, "{" /* } */);
X
X		if (w.w_status == WSTOPPED)
X		{
X			fprintf(outfp, "w_stopval=WSTOPPED,");
X			fprintf(outfp, "w_stopsig=%s", signal_name(w.w_stopsig));
X		}
X		else
X		{
X			fprintf(outfp, "w_termsig=%s,", signal_name(w.w_termsig));
X			fprintf(outfp, "w_coredump=%d,", w.w_coredump);
X			fprintf(outfp, "w_retcode=%d", w.w_retcode);
X		}
X
X		fprintf(outfp, /* { */ "}");
X	}
X
X	return 0;
X}
X
Xint
Xsysv_print_wait3_options(arg)
Xunsigned long	arg;
X{
X	if (arg == (unsigned long)0)
X		fprintf(outfp, "0x%x", arg);
X	else
X	{
X		need_leading_pipe = 0;
X
X		say_flag(WNOHANG, "WNOHANG", arg);
X		say_flag(WUNTRACED, "WUNTRACED", arg);
X
X		say_residual(arg);
X	}
X
X	return 0;
X}
X
Xint
Xsysv_print_wait3_rusage(arg)
Xunsigned long	arg;
X{
X	fprintf(outfp, "0x%x", arg);
X
X	return 0;
X}
X
Xint
Xsysv_print_sigcontext(outfp, p)
XFILE		*outfp;
Xunsigned long	p;
X{
X	struct sigcontext	sc;
X	struct sigcontext	*scp;
X	int			i;
X
X	fprintf(outfp, "{" /* } */);
X
X	if (mget(p, &sc, sizeof(sc), &scp) == -1)
X		return -1;
X
X	if (Aflag)
X	{
X		if (scp != (struct sigcontext *)0)
X		{
X			fprintf(outfp, "regmask=0x%x,", scp->sc_regmask);
X			fprintf(outfp, "mask=0x%x,", scp->sc_mask);
X			fprintf(outfp, "pc=%s,", proc_text_address(scp->sc_pc));
X
X			for (i = 0; i < nels(scp->sc_regs); i++)
X				fprintf(outfp, "regs[%d]=0x%x,", i, scp->sc_regs[i]);
X
X			fprintf(outfp, "ownedfp=0x%x,", scp->sc_ownedfp);
X
X			for (i = 0; i < nels(scp->sc_fpregs); i++)
X				fprintf(outfp, "fpregs[%d]=0x%x,", i, scp->sc_fpregs[i]);
X
X			fprintf(outfp, "fpc_csr=0x%x,", scp->sc_fpc_csr);
X			fprintf(outfp, "fpc_eir=0x%x,", scp->sc_fpc_eir);
X			fprintf(outfp, "mdhi=%d,", scp->sc_mdhi);
X			fprintf(outfp, "mdlo=%d,", scp->sc_mdlo);
X			fprintf(outfp, "cause=0x%x,", scp->sc_cause);
X			fprintf(outfp, "badvaddr=0x%x,", scp->sc_badvaddr);
X			fprintf(outfp, "badpaddr=0x%x,", scp->sc_badpaddr);
X			fprintf(outfp, "sigset=%s,", signal_name(scp->is_sigset));
X		}
X	}
X	else
X		fprintf(outfp, "...");
X
X	fprintf(outfp, /* { */ "}");
X
X	return 0;
X}
X
Xstatic
Xint
Xsysv_print_received_signal(universe, universe_name, tramp, handler, sig, code, scp)
Xint			universe;
Xchar			*universe_name;
Xunsigned long		tramp;
Xunsigned long		handler;
Xint			sig;
Xint			code;
Xstruct sigcontext	*scp;
X{
X	fprintf(outfp, "%6d:", P.p_pid);
X
X	fprintf(outfp, "%s_SIGNAL(", universe_name);
X
X	if (printval(universe, tramp, 'I', (unsigned long *)0, (unsigned long)0, (unsigned long)0, DIRN_ENTRY) == -1)
X		return -1;
X
X	fprintf(outfp, ", ");
X
X	if (printval(universe, handler, 'I', (unsigned long *)0, (unsigned long)0, (unsigned long)0, DIRN_ENTRY) == -1)
X		return -1;
X
X	fprintf(outfp, ", ");
X
X	if (printval(universe, sig, 'K', (unsigned long *)0, (unsigned long)0, (unsigned long)0, DIRN_ENTRY) == -1)
X		return -1;
X
X	fprintf(outfp, ", ");
X
X	if (printval(universe, code, 'd', (unsigned long *)0, (unsigned long)0, (unsigned long)0, DIRN_ENTRY) == -1)
X		return -1;
X
X	fprintf(outfp, ", ");
X
X	if (printval(universe, scp, 'y', (unsigned long *)0, (unsigned long)0, (unsigned long)0, DIRN_ENTRY) == -1)
X		return -1;
X
X	fprintf(outfp, ")");
X
X	fprintf(outfp, "\n");
X
X	return 0;
X}
END_OF_FILE
if test 58975 -ne `wc -c <'sysv.c'`; then
    echo shar: \"'sysv.c'\" unpacked with wrong size!
fi
# end of 'sysv.c'
fi
echo shar: End of archive 8 \(of 8\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
