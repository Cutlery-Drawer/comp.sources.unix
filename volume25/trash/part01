Newsgroups: comp.sources.unix
From: bruce@beta.cs.su.oz.au (Bruce Janson)
Subject: v25i155: trash - simulate process execution in MIPS RISC/os 4.52, Part01/08
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: bruce@beta.cs.su.oz.au (Bruce Janson)
Posting-Number: Volume 25, Issue 155
Archive-Name: trash/part01

[ Here's one I can't test because I don't have a MIPS RISCOS computer.  But
  the code is clean and the example (see below) is enticing, so in the hope
  that folks will port it to various other computers, here it is.

	$ trash echo hello world
	 17636:sysv_ioctl(1, TCGETA, {c_iflag=BRKINT|IGNPAR|ISTRIP|ICRNL|IXON\
|IXANY, c_oflag=OPOST|ONLCR|NL0|CR0|TAB0|BS0|VT0|FF0, c_cflag=B9600|CS8|CREAD\
|HUPCL|CLOCAL, c_lflag=ISIG|ICANON|ECHO|ECHOE|ECHOK, c_line=0, c_cc=[VINTR=0x\
7f,VQUIT=0x1c,VERASE=0x08,VKILL=0x40,VEOF=0x04,VEOL=0x00,VEOL2=0x00,VSWTCH=0x\
00,V_START=0x11,V_STOP=0x13,V_SUSP=0xff,V_DSUSP=0xff,V_RPRNT=0x12,V_FLUSH=0x0\
f,V_WERAS=0x17,V_LNEXT=0x16,V_STATUS=0x00,V_SAVED_EOF=0x00,V_SAVED_EOL=0x00,1\
9=0x00,20=0x00,21=0x00,22=0x00,], c_saved_flags=0x0, c_filler=0x0}) = 0
	hello world
	 17636:sysv_write(1, "hello world\n", 12) = 12
	 17636:sysv_close(0) = 0
	 17636:sysv_close(1) = 0
	 17636:sysv_close(2) = 0
	 17636:sysv__exit(0)
	$ trash -S echo hello world
	hello world
	$ 

  --vix ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 8)."
# Contents:  README bzero.c couldnot.c diblock.c diblock.h diffem
#   dmult.s dmultu.s entry.h execvpath.c flag.h generic.h getopt.c
#   getprbyno.c histogram.c history.c i_d.c i_j.c i_m.c i_n.c i_o.c
#   i_u.c i_x.c install instrn.h myldopen.c myname.c nels.h posix.c
#   process.h register.h res.h resource.c say.c sgttyb.c syms.c
#   symtab.h sysentry.h sysmess.c talloc.h usage.c vcouldnot.c
#   warning.c wcache.c wcache.h
# Wrapped by bruce@basser on Tue Mar  3 23:25:18 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1618 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XTue Mar  3 22:55:57 EST 1992
X
XThis is trash (version 5).
X
Xtrash attempts to simulate the execution of a process run
Xunder a MIPS RISC/os 4.52 environment.
Xtrash has been tested and used only in that environment.
X
XIn its default mode, trash acts like truss (SysVR4) or
Xtrace (SunOS 4.1) and prints the arguments and results
Xof systems calls as they return.  However, both truss
Xand trace control the execution of another process whereas
Xtrash simulates it.
X
XUnder favourable conditions trash will simulate a process
Xat approximately 1/10th the speed at which that process would
Xnormally execute.  However, in general, the speed of simulation
Xdepends on the characteristics of the simulated process.
X
XTo build trash, unshar the package and type "make".
XThere is no "install" target -- you will have to install the
Xtarget ("trash") and the manual entry ("trash.1") explicitly.
X
XThis version of trash owes much to the techniques described in:
X
X    "Some Efficient Architecture Simulation Techniques"
X    Robert C. Bedichek, Department of Computer Science, FR-35
X    University of Washington, Seattle, Washington 98195
X    robertb@cs.washington.edu
X    pp.53-63, Proceedings of Winter 1990 USENIX,
X    Washington, D.C., January 22-26, 1990.
X
XThanks also to roy@cs.su.oz.au (Roy Giles), kmk@cc.tut.fi
X(Kai 'Kaizzu' Kein{nen), greg@cxsyd.cx.oz.au (Greg Kelty) and
Xsm@cerberus.bhpese.oz (Scott Merrilees) who reported bugs
Xand/or made helpful suggestions.
X
XBruce Janson					Email:	bruce@cs.su.oz.au
XBasser Department of Computer Science		Phone:	+61-2-692-3423
XUniversity of Sydney, N.S.W., 2006, AUSTRALIA	Fax:	+61-2-692-3838
END_OF_FILE
if test 1618 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'bzero.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bzero.c'\"
else
echo shar: Extracting \"'bzero.c'\" \(71 characters\)
sed "s/^X//" >'bzero.c' <<'END_OF_FILE'
Xint
Xbzero(cp, n)
Xchar	*cp;
Xint	n;
X{
X	while (n-- > 0)
X		*cp++ = 0x00;
X}
END_OF_FILE
if test 71 -ne `wc -c <'bzero.c'`; then
    echo shar: \"'bzero.c'\" unpacked with wrong size!
fi
# end of 'bzero.c'
fi
if test -f 'couldnot.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'couldnot.c'\"
else
echo shar: Extracting \"'couldnot.c'\" \(597 characters\)
sed "s/^X//" >'couldnot.c' <<'END_OF_FILE'
X#include	<varargs.h>
X#include	<stdio.h>
X
Xextern char	*myname();
Xextern void	format();
Xextern char	*sysmess();
X
Xextern int	errno;
Xextern FILE	*outfp;
X
Xstatic
Xint
Xcouldnot_putc(c)
Xint	c;
X{
X	putc(c, outfp);
X}
X
X/*
X * "couldnot(printf_like_format, printf_like_arg, ...);"
X */
Xvoid
Xcouldnot(va_alist)
Xva_dcl
X{
X	register char	*cp;
X	va_list		ap;
X
X	fprintf(outfp, "%s: could not ", myname());
X	va_start(ap);
X	format(couldnot_putc, &ap);
X	va_end(ap);
X	cp = sysmess();
X	if (cp != (char *)0 && *cp != '\0')
X	{
X		fprintf(outfp, ": %s", cp);
X		errno = 0;
X	}
X	fprintf(outfp, ".\n");
X	fflush(outfp);
X	_exit(1);
X}
END_OF_FILE
if test 597 -ne `wc -c <'couldnot.c'`; then
    echo shar: \"'couldnot.c'\" unpacked with wrong size!
fi
# end of 'couldnot.c'
fi
if test -f 'diblock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'diblock.c'\"
else
echo shar: Extracting \"'diblock.c'\" \(2256 characters\)
sed "s/^X//" >'diblock.c' <<'END_OF_FILE'
X#include	<stdio.h>
X#include	"entry.h"
X#include	"diblock.h"
X#include	"talloc.h"
X#include	"nels.h"
X
X#define	TABZ	127
X
X#define	abs(n)	(((n) < 0) ? -(n) : (n))
X
Xstatic entry	*hash_table[TABZ];
X
Xstatic
Xentry	*
Xmkent(dipc, key, data)
Xdinstrn		*dipc;
Xunsigned long	key;
Xunsigned long	data;
X{
X	entry	*p;
X
X	if ((p = talloc(entry)) == (entry *)0)
X	{
X		GLOBALdipc = dipc;
X		vcouldnot("allocate %d bytes for hash entry", sizeof(entry));
X		return (entry *)0;
X	}
X
X	p->ent_key = key;
X	p->ent_data = data;
X	p->ent_right = (entry *)0;
X	p->ent_left = (entry *)0;
X
X	return p;
X}
X
X/*
X * Given a key, return a pointer to the entry
X * in the table corresponding to that key - or
X * a pointer to the entry where it should be if
X * it is not there.
X */
Xstatic
Xentry	**
Xlookup(key)
Xunsigned long	key;
X{
X	entry	**pp;
X	int	flag;
X
X	pp = &hash_table[abs(key) % nels(hash_table)];
X
X	while
X	(
X		*pp != (entry *)0
X		&&
X		(flag = (key - (*pp)->ent_key)) != 0
X	)
X		pp = (flag > 0) ? &((*pp)->ent_right) : &((*pp)->ent_left);
X
X	return pp;
X}
X
X/*
X * Delete an entry with the given key.
X * If not there, return 0, else 1.
X */
Xstatic
Xint
Xdel(key)
Xunsigned long	key;
X{
X	entry	**p;
X	entry	*l;
X	entry	*r;
X
X	if (*(p = lookup(key)) == (entry *)0)
X		return 0;
X
X	l = (*p)->ent_left;
X	r = (*p)->ent_right;
X	(void)free(*p);
X
X	if (l == (entry *)0)
X	{
X		*p = r;
X		return 1;
X	}
X
X	if (r == (entry *)0)
X	{
X		*p = l;
X		return 1;
X	}
X
X	*p = l;
X	while (l->ent_right != (entry *)0)
X		l = l->ent_right;
X	l->ent_right = r;
X
X	return 1;
X}
X
Xdiblock	*
Xaddr_to_decoded_block(dipc, addr)
Xdinstrn		*dipc;
Xunsigned long	addr;
X{
X	static unsigned long	lastaddr;
X	static diblock		*lastdiblockp;
X	entry			**pp;
X	entry			*p;
X
X	addr /= SIMULATED_PAGE_SIZE;
X
X	if (addr == lastaddr)
X		return lastdiblockp;
X
X	lastaddr = addr;
X
X	if ((p = *(pp = lookup(addr))) == (entry *)0)
X	{
X		diblock	*diblockp;
X
X		if ((diblockp = talloc(diblock)) == (diblock *)0)
X		{
X			GLOBALdipc = dipc;
X			vcouldnot("allocate %d bytes for diblock", sizeof(diblock));
X			return (diblock *)0;
X		}
X
X		diblockp->dib_want_init = 1;
X		diblockp->dib_first_addr = addr * SIMULATED_PAGE_SIZE;
X
X		if ((p = mkent(dipc, addr, (unsigned long)diblockp)) == (entry *)0)
X			return (diblock *)0;
X
X		*pp = p;
X	}
X
X	lastdiblockp = (diblock *)p->ent_data;
X
X	return lastdiblockp;
X}
END_OF_FILE
if test 2256 -ne `wc -c <'diblock.c'`; then
    echo shar: \"'diblock.c'\" unpacked with wrong size!
fi
# end of 'diblock.c'
fi
if test -f 'diblock.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'diblock.h'\"
else
echo shar: Extracting \"'diblock.h'\" \(638 characters\)
sed "s/^X//" >'diblock.h' <<'END_OF_FILE'
X#define	SIMULATED_PAGE_SIZE	(4 * 1024)
X
Xtypedef struct dinstrn	dinstrn;
Xstruct dinstrn
X{
X	dinstrn		*(*di_handler)();
X	unsigned long	di_addr;
X	unsigned long	*di_0;
X	unsigned long	*di_1;
X	unsigned long	*di_2;
X	unsigned long	*di_3;
X};
X
Xtypedef struct diblock	diblock;
Xstruct diblock
X{
X	int		dib_want_init;
X	unsigned long	dib_first_addr;
X	dinstrn		dib_instrn[SIMULATED_PAGE_SIZE / sizeof(unsigned long)];
X};
X
Xextern diblock	*addr_to_decoded_block();
Xextern dinstrn	*addr_to_decoded_instrnp();
Xextern dinstrn	*c_noop();
Xextern dinstrn	*do_delayed_branch();
Xextern dinstrn	*deliver_signal();
X
Xextern int	compile_ok;
Xextern dinstrn	*GLOBALdipc;
END_OF_FILE
if test 638 -ne `wc -c <'diblock.h'`; then
    echo shar: \"'diblock.h'\" unpacked with wrong size!
fi
# end of 'diblock.h'
fi
if test -f 'diffem' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'diffem'\"
else
echo shar: Extracting \"'diffem'\" \(34 characters\)
sed "s/^X//" >'diffem' <<'END_OF_FILE'
Xdiff $1 ~s/usr/local/bin/trash/$1
END_OF_FILE
if test 34 -ne `wc -c <'diffem'`; then
    echo shar: \"'diffem'\" unpacked with wrong size!
fi
chmod +x 'diffem'
# end of 'diffem'
fi
if test -f 'dmult.s' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dmult.s'\"
else
echo shar: Extracting \"'dmult.s'\" \(412 characters\)
sed "s/^X//" >'dmult.s' <<'END_OF_FILE'
X/*
X *	int
X *	dmult(s, t, hip, lop)
X *	unsigned long	s;
X *	unsigned long	t;
X *	unsigned long	*hip;
X *	unsigned long	*lop;
X *	{
X *		*hip = high word of double "s * t";
X *		*lop = low word of double "s * t";
X *	
X *		return 0;
X *	}
X */
X	.text	
X	.align	2
X	.globl	dmult
X	.ent	dmult 2
Xdmult:
X	.option	O1
X	.frame	$sp, 0, $31
X	mult	$4, $5
X	mfhi	$14
X	mflo	$15
X	sw	$14, 0($6)
X	sw	$15, 0($7)
X	move	$2, $0
X	j	$31
X	.end	dmult
END_OF_FILE
if test 412 -ne `wc -c <'dmult.s'`; then
    echo shar: \"'dmult.s'\" unpacked with wrong size!
fi
# end of 'dmult.s'
fi
if test -f 'dmultu.s' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dmultu.s'\"
else
echo shar: Extracting \"'dmultu.s'\" \(436 characters\)
sed "s/^X//" >'dmultu.s' <<'END_OF_FILE'
X/*
X *	int
X *	dmultu(s, t, hip, lop)
X *	unsigned long	s;
X *	unsigned long	t;
X *	unsigned long	*hip;
X *	unsigned long	*lop;
X *	{
X *		*hip = high word of unsigned double "s * t";
X *		*lop = low word of unsigned double "s + t";
X *	
X *		return 0;
X *	}
X */
X	.text	
X	.align	2
X	.globl	dmultu
X	.ent	dmultu 2
Xdmultu:
X	.option	O1
X	.frame	$sp, 0, $31
X	multu	$4, $5
X	mfhi	$14
X	mflo	$15
X	sw	$14, 0($6)
X	sw	$15, 0($7)
X	move	$2, $0
X	j	$31
X	.end	dmultu
END_OF_FILE
if test 436 -ne `wc -c <'dmultu.s'`; then
    echo shar: \"'dmultu.s'\" unpacked with wrong size!
fi
# end of 'dmultu.s'
fi
if test -f 'entry.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'entry.h'\"
else
echo shar: Extracting \"'entry.h'\" \(134 characters\)
sed "s/^X//" >'entry.h' <<'END_OF_FILE'
Xtypedef struct entry	entry;
Xstruct entry
X{
X	unsigned long	ent_key;
X	unsigned long	ent_data;
X	entry		*ent_left;
X	entry		*ent_right;
X};
END_OF_FILE
if test 134 -ne `wc -c <'entry.h'`; then
    echo shar: \"'entry.h'\" unpacked with wrong size!
fi
# end of 'entry.h'
fi
if test -f 'execvpath.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'execvpath.c'\"
else
echo shar: Extracting \"'execvpath.c'\" \(790 characters\)
sed "s/^X//" >'execvpath.c' <<'END_OF_FILE'
X#include	<unistd.h>
X
Xextern char	*getenv();
Xextern char	*strchr();
X
Xstatic
Xchar	*
Xnext_attempted_path(prefix, last_component, result)
Xchar	*prefix;
Xchar	*last_component;
Xchar	*result;
X{
X	char	*s;
X
X	s = result;
X
X	while (*prefix != '\0' && *prefix != ':')
X		*s++ = *prefix++;
X
X	if (result != s)
X		*s++ = '/';
X
X	while (*last_component != '\0')
X		*s++ = *last_component++;
X
X	*s = '\0';
X
X	return (*prefix == '\0') ? (char *)0 : prefix + 1;
X}
X
Xchar	*
Xexecvpath(name)
Xchar	*name;
X{
X	static char	fname[256];
X	char		*cp;
X
X	if (name == (char *)0 || strchr(name, '/') != (char *)0)
X		return name;
X
X	if ((cp = getenv("PATH")) == (char *)0)
X		cp = "";
X
X	while ((cp = next_attempted_path(cp, name, &fname[0])) != (char *)0)
X	{
X		if (access(&fname[0], X_OK) == 0)
X			return &fname[0];
X	}
X
X	return name;
X}
END_OF_FILE
if test 790 -ne `wc -c <'execvpath.c'`; then
    echo shar: \"'execvpath.c'\" unpacked with wrong size!
fi
# end of 'execvpath.c'
fi
if test -f 'flag.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flag.h'\"
else
echo shar: Extracting \"'flag.h'\" \(531 characters\)
sed "s/^X//" >'flag.h' <<'END_OF_FILE'
X#define	say_flag(mask,string,arg) \
X{ \
X	if (((arg) & (mask)) == (mask)) \
X	{ \
X		fprintf(outfp, "%s%s", need_leading_pipe ? "|" : "", string); \
X		need_leading_pipe = 1; \
X		arg &= ~(mask); \
X	} \
X}
X
X#define	say_notflag(mask,string,arg) \
X{ \
X	if (((arg) & (mask)) == 0) \
X	{ \
X		fprintf(outfp, "%s%s", need_leading_pipe ? "|" : "", string); \
X		need_leading_pipe = 1; \
X	} \
X}
X
X#define	say_residual(arg) \
X{ \
X	if ((arg) != 0) \
X		fprintf(outfp, "%s0x%x", need_leading_pipe ? "|" : "", (arg)); \
X}
X
Xextern int	need_leading_pipe;
END_OF_FILE
if test 531 -ne `wc -c <'flag.h'`; then
    echo shar: \"'flag.h'\" unpacked with wrong size!
fi
# end of 'flag.h'
fi
if test -f 'generic.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'generic.h'\"
else
echo shar: Extracting \"'generic.h'\" \(3046 characters\)
sed "s/^X//" >'generic.h' <<'END_OF_FILE'
X/*
X4G!Gsed -n -e '/\(generic_.*\)(syscallno.*)$/s//extern int \1();/p' < generic.c
X */
Xextern int generic_accept();
Xextern int generic_access();
Xextern int generic_acct();
Xextern int generic_adjtime();
Xextern int generic_alarm();
Xextern int generic_async_daemon();
Xextern int generic_bind();
Xextern int generic_brk();
Xextern int generic_cachectl();
Xextern int generic_cacheflush();
Xextern int generic_chdir();
Xextern int generic_chmod();
Xextern int generic_chown();
Xextern int generic_chroot();
Xextern int generic_close();
Xextern int generic_connect();
Xextern int generic_creat();
Xextern int generic_dup();
Xextern int generic_exit();
Xextern int generic_fchmod();
Xextern int generic_fchown();
Xextern int generic_flock();
Xextern int generic_fork();
Xextern int generic_fstat();
Xextern int generic_fsync();
Xextern int generic_ftruncate();
Xextern int generic_getdents();
Xextern int generic_getdirentries();
Xextern int generic_getdomainname();
Xextern int generic_getdtablesize();
Xextern int generic_getgroups();
Xextern int generic_gethostid();
Xextern int generic_gethostname();
Xextern int generic_getitimer();
Xextern int generic_getpagesize();
Xextern int generic_getpeername();
Xextern int generic_getpid();
Xextern int generic_getpriority();
Xextern int generic_getrlimit();
Xextern int generic_getrusage();
Xextern int generic_gettimeofday();
Xextern int generic_getsockname();
Xextern int generic_getsockopt();
Xextern int generic_kill();
Xextern int generic_killpg();
Xextern int generic_link();
Xextern int generic_listen();
Xextern int generic_lseek();
Xextern int generic_lstat();
Xextern int generic_mkdir();
Xextern int generic_mknod();
Xextern int generic_nfssvc();
Xextern int generic_nice();
Xextern int generic_open();
Xextern int generic_pause();
Xextern int generic_plock();
Xextern int generic_profil();
Xextern int generic_ptrace();
Xextern int generic_read();
Xextern int generic_readlink();
Xextern int generic_recv();
Xextern int generic_recvfrom();
Xextern int generic_rename();
Xextern int generic_rmdir();
Xextern int generic_send();
Xextern int generic_sendto();
Xextern int generic_setdomainname();
Xextern int generic_setgid();
Xextern int generic_setgroups();
Xextern int generic_sethostid();
Xextern int generic_setitimer();
Xextern int generic_setpgid();
Xextern int generic_setpriority();
Xextern int generic_setregid();
Xextern int generic_setreuid();
Xextern int generic_setrlimit();
Xextern int generic_setsockopt();
Xextern int generic_settimeofday();
Xextern int generic_setuid();
Xextern int generic_shutdown();
Xextern int generic_socket();
Xextern int generic_socketpair();
Xextern int generic_stat();
Xextern int generic_stime();
Xextern int generic_symlink();
Xextern int generic_sync();
Xextern int generic_time();
Xextern int generic_times();
Xextern int generic_truncate();
Xextern int generic_uadmin();
Xextern int generic_ulimit();
Xextern int generic_umask();
Xextern int generic_unlink();
Xextern int generic_unmount();
Xextern int generic_utime();
Xextern int generic_utimes();
Xextern int generic_vhangup();
Xextern int generic_wait3();
Xextern int generic_write();
END_OF_FILE
if test 3046 -ne `wc -c <'generic.h'`; then
    echo shar: \"'generic.h'\" unpacked with wrong size!
fi
# end of 'generic.h'
fi
if test -f 'getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt.c'\"
else
echo shar: Extracting \"'getopt.c'\" \(937 characters\)
sed "s/^X//" >'getopt.c' <<'END_OF_FILE'
Xextern int	strcmp();
Xextern char	*strchr();
Xextern int	strlen();
X
Xint	optind	= 1;
Xint	optopt;
Xchar	*optarg;
X
Xint
Xgetopt(argc, argv, opts)
Xint	argc;
Xchar	**argv;
Xchar	*opts;
X{
X	static int	sp	= 1;
X	register int	c;
X	register char	*cp;
X
X	if (sp == 1)
X	{
X		if
X		(
X			optind >= argc
X			||
X			argv[optind][0] != '-'
X			||
X			argv[optind][1] == '\0'
X		)
X			return -1;
X
X		if (strcmp(argv[optind], "--") == 0)
X		{
X			optind++;
X			return -1;
X		}
X	}
X
X	c = argv[optind][sp];
X	optopt = c;
X
X	if (c == ':' || (cp = strchr(opts, c)) == (char *)0)
X	{
X		if (argv[optind][++sp] == '\0')
X		{
X			optind++;
X			sp = 1;
X		}
X		return '?';
X	}
X
X	if (*++cp == ':')
X	{
X		if (argv[optind][sp + 1] != '\0')
X			optarg = &argv[optind++][sp + 1];
X		else if (++optind >= argc)
X		{
X			sp = 1;
X			return '?';
X		}
X		else
X			optarg = argv[optind++];
X		sp = 1;
X	}
X	else
X	{
X		if (argv[optind][++sp] == '\0')
X		{
X			sp = 1;
X			optind++;
X		}
X		optarg = (char *)0;
X	}
X
X	return c;
X}
END_OF_FILE
if test 937 -ne `wc -c <'getopt.c'`; then
    echo shar: \"'getopt.c'\" unpacked with wrong size!
fi
# end of 'getopt.c'
fi
if test -f 'getprbyno.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getprbyno.c'\"
else
echo shar: Extracting \"'getprbyno.c'\" \(645 characters\)
sed "s/^X//" >'getprbyno.c' <<'END_OF_FILE'
X#include	<bsd/sys/types.h>
X#include	<bsd/netdb.h>
X
Xstruct protoent	*
Xgetprotobynumber(proto)
Xint	proto;
X{
X	static struct protoent	result;
X	char			*name;
X
X	switch (proto)
X	{
X	case 0:
X		name = "ip";
X		break;
X
X	case 1:
X		name = "icmp";
X		break;
X
X	case 3:
X		name = "ggp";
X		break;
X
X	case 6:
X		name = "tcp";
X		break;
X
X	case 8:
X		name = "egp";
X		break;
X
X	case 12:
X		name = "pup";
X		break;
X
X	case 17:
X		name = "udp";
X		break;
X
X	case 20:
X		name = "hmp";
X		break;
X
X	case 22:
X		name = "xns-idp";
X		break;
X
X	case 27:
X		name = "rdp";
X		break;
X
X	default:
X		return (struct protoent *)0;
X	}
X
X	result.p_name = name;
X	result.p_proto = proto;
X
X	return &result;
X}
END_OF_FILE
if test 645 -ne `wc -c <'getprbyno.c'`; then
    echo shar: \"'getprbyno.c'\" unpacked with wrong size!
fi
# end of 'getprbyno.c'
fi
if test -f 'histogram.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'histogram.c'\"
else
echo shar: Extracting \"'histogram.c'\" \(912 characters\)
sed "s/^X//" >'histogram.c' <<'END_OF_FILE'
X#include	<stdio.h>
X
X#define	PAGE_SIZE	4096
X
X#define	addr_to_i(a)	(((a) - histo_addr) / PAGE_SIZE)
X#define	i_to_addr(i)	(((i) * PAGE_SIZE) + histo_addr)
X
Xextern char		*calloc();
Xextern void		couldnot();
X
Xextern FILE		*outfp;
Xextern int		Hflag;
X
Xstatic int		*histo_buf;
Xstatic int		histo_length;
Xstatic unsigned long	histo_addr;
X
Xint
Xhisto_init(first, length)
Xunsigned long	first;
Xint		length;
X{
X	histo_length = (length + PAGE_SIZE - 1) / PAGE_SIZE;
X
X	if ((histo_buf = (int *)calloc(histo_length, sizeof(int))) == (int *)0)
X	{
X		couldnot("allocate memory for histogram buffer of %d entries", histo_length);
X		return -1;
X	}
X
X	histo_addr = first;
X
X	return 0;
X}
X
Xvoid
Xhisto_log(addr)
Xunsigned long	addr;
X{
X	histo_buf[addr_to_i(addr)]++;
X}
X
Xvoid
Xhisto_dump()
X{
X	int	i;
X	int	p;
X
X	p = getpid();
X
X	if (Hflag)
X	{
X		for (i = 0; i < histo_length; i++)
X			fprintf(outfp, "%d:\t%d\t%d\n", p, i_to_addr(i), histo_buf[i]);
X	}
X}
END_OF_FILE
if test 912 -ne `wc -c <'histogram.c'`; then
    echo shar: \"'histogram.c'\" unpacked with wrong size!
fi
# end of 'histogram.c'
fi
if test -f 'history.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'history.c'\"
else
echo shar: Extracting \"'history.c'\" \(981 characters\)
sed "s/^X//" >'history.c' <<'END_OF_FILE'
X#include	<stdio.h>
X#include	"register.h"
X#include	"symtab.h"
X#include	"diblock.h"
X#include	"instrn.h"
X#include	"process.h"
X
Xextern char		*calloc();
Xextern void		couldnot();
X
Xextern FILE		*outfp;
X
Xint			hist_length;
X
Xstatic unsigned long	*hist_buf;
Xstatic int		hist_i;
X
Xint
Xhist_init(n)
Xint	n;
X{
X	if (n < 0)
X	{
X		couldnot("initialise history buffer to %d entries", n);
X		return -1;
X	}
X
X	if ((hist_buf = (unsigned long *)calloc(n, sizeof(unsigned long))) == (unsigned long *)0)
X	{
X		couldnot("allocate memory for history buffer of %d entries", n);
X		return -1;
X	}
X
X	hist_length = n;
X
X	return 0;
X}
X
Xvoid
Xhist_log(addr)
Xunsigned long	addr;
X{
X	if (hist_length > 0)
X	{
X		hist_buf[hist_i++] = addr;
X
X		if (hist_i >= hist_length)
X			hist_i = 0;
X	}
X}
X
Xvoid
Xhist_dump()
X{
X	int	i;
X
X	if (hist_length > 0)
X		fprintf(outfp, "Backtrace:\n");
X
X	for (i = 0; i < hist_length; i++)
X	{
X		fprintf(outfp, "%s\n", proc_text_address(hist_buf[hist_i++]));
X
X		if (hist_i >= hist_length)
X			hist_i = 0;
X	}
X}
END_OF_FILE
if test 981 -ne `wc -c <'history.c'`; then
    echo shar: \"'history.c'\" unpacked with wrong size!
fi
# end of 'history.c'
fi
if test -f 'i_d.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'i_d.c'\"
else
echo shar: Extracting \"'i_d.c'\" \(2266 characters\)
sed "s/^X//" >'i_d.c' <<'END_OF_FILE'
X#include	"register.h"
X#include	"symtab.h"
X#include	"diblock.h"
X#include	"instrn.h"
X#include	"process.h"
X
Xstatic
Xvoid
Xnotdiv0(dipc)
Xdinstrn	*dipc;
X{
X	GLOBALdipc = dipc;
X	vcouldnot("divide by 0");
X}
X
Xstatic
Xdinstrn	*
Xc_div(dipc)
Xdinstrn	*dipc;
X{
X	long	s;
X	long	t;
X
X	s = (long)*dipc->di_0;
X	t = (long)*dipc->di_1;
X
X	if (t == 0)
X		notdiv0(dipc);
X	else
X	{
X		P.p_state[R_LO] = s / t;
X		P.p_state[R_HI] = s % t;
X	}
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_div(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	long	s;
X	long	t;
X
X	if (compile_ok)
X	{
X		dipc->di_handler = c_div;
X		dipc->di_0 = &P.p_state[rs];
X		dipc->di_1 = &P.p_state[rt];
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(rs, s);
X
X	procsget(rt, t);
X
X	if (t == (long)0)
X		notdiv0(dipc);
X	else
X	{
X		procsput(R_LO, s / t);
X		procsput(R_HI, s % t);
X	}
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_divfmt(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint	fmt;
Xint	ft;
Xint	fs;
Xint	fd;
X{
X	float	singles;
X	float	singlet;
X	float	singled;
X	double	doubles;
X	double	doublet;
X	double	doubled;
X
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singles);
X
X		procsget(CP1G(ft), *(unsigned long *)&singlet);
X
X		if (singlet == (float)0)
X			notdiv0(dipc);
X		else
X		{
X			singled = singles / singlet;
X
X			procsput(CP1G(fd), *(unsigned long *)&singled);
X		}
X
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doubles + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doubles);
X
X		procsget(CP1G(ft), *((unsigned long *)&doublet + 1));
X
X		procsget(CP1G(ft) + 1, *(unsigned long *)&doublet);
X
X		if (doublet == (double)0)
X			notdiv0(dipc);
X		else
X		{
X			doubled = doubles / doublet;
X
X			procsput(CP1G(fd), *((unsigned long *)&doubled + 1));
X
X			procsput(CP1G(fd) + 1, *(unsigned long *)&doubled);
X		}
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_divu(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	s;
X	unsigned long	t;
X
X	procsget(rs, s);
X
X	procsget(rt, t);
X
X	if (t == (unsigned long)0)
X		notdiv0(dipc);
X	else
X	{
X		procsput(R_LO, s / t);
X		procsput(R_HI, s % t);
X	}
X
X	return dipc;
X}
END_OF_FILE
if test 2266 -ne `wc -c <'i_d.c'`; then
    echo shar: \"'i_d.c'\" unpacked with wrong size!
fi
# end of 'i_d.c'
fi
if test -f 'i_j.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'i_j.c'\"
else
echo shar: Extracting \"'i_j.c'\" \(1916 characters\)
sed "s/^X//" >'i_j.c' <<'END_OF_FILE'
X#include	"register.h"
X#include	"symtab.h"
X#include	"diblock.h"
X#include	"instrn.h"
X#include	"process.h"
X
Xdinstrn	*
Xi_j(dipc, target)
Xdinstrn		*dipc;
Xunsigned long	target;
X{
X	dipc = do_delayed_branch(dipc, (dipc->di_addr & 0xF0000000) | (target << 2));
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_jal(dipc)
Xdinstrn	*dipc;
X{
X	P.p_state[R_RA] = (unsigned long)dipc->di_0;
X	do_known_delayed_branch;
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_jal_up(dipc)
Xdinstrn	*dipc;
X{
X	P.p_state[R_RA] = (unsigned long)dipc->di_0;
X	do_known_delayed_upbranch;
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_jal(dipc, target)
Xdinstrn		*dipc;
Xunsigned long	target;
X{
X	unsigned long	ra;
X	unsigned long	addr;
X
X	ra = dipc->di_addr + 2 * sizeof(unsigned long);
X	addr = (dipc->di_addr & 0xF0000000) | (target << 2);
X
X	if (compile_ok)
X	{
X		dipc->di_handler = (addr > dipc->di_addr) ? c_jal : c_jal_up;
X		dipc->di_0 = (unsigned long *)ra;
X		(void)compile_known_delayed_branch(dipc, addr);
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	/*
X	 * Save the link address in the link register.
X	 */
X	procsput(R_RA, ra);
X
X	dipc = do_delayed_branch(dipc, addr);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_jalr(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	ra;
X	unsigned long	s;
X
X	ra = dipc->di_addr + 2 * sizeof(unsigned long);
X
X	procsget(rs, s);
X
X	/*
X	 * Save the link address in the link register.
X	 */
X	procsput(rd, ra);
X
X	dipc = do_delayed_branch(dipc, s);
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_jr(dipc)
Xdinstrn	*dipc;
X{
X	do_unknown_delayed_branch;
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_jr(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	s;
X
X	if (compile_ok)
X	{
X		dipc->di_handler = c_jr;
X		dipc->di_0 = &P.p_state[rs];
X		(void)compile_unknown_delayed_branch(dipc);
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(rs, s);
X
X	dipc = do_delayed_branch(dipc, s);
X
X	return dipc;
X}
END_OF_FILE
if test 1916 -ne `wc -c <'i_j.c'`; then
    echo shar: \"'i_j.c'\" unpacked with wrong size!
fi
# end of 'i_j.c'
fi
if test -f 'i_m.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'i_m.c'\"
else
echo shar: Extracting \"'i_m.c'\" \(4303 characters\)
sed "s/^X//" >'i_m.c' <<'END_OF_FILE'
X#include	"register.h"
X#include	"symtab.h"
X#include	"diblock.h"
X#include	"instrn.h"
X#include	"process.h"
X
Xdinstrn	*
Xi_mfc1(dipc, rt, fs)
Xdinstrn	*dipc;
Xint	rt;
Xint	fs;
X{
X	unsigned long	t;
X
X	procsget(CP1G(fs), t);
X
X	procsput(rt, t);
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_mfhi(dipc)
Xdinstrn	*dipc;
X{
X	*dipc->di_0 = P.p_state[R_HI];
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_mfhi(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	d;
X
X	if (compile_ok)
X	{
X		if (rd == R_0)
X			dipc->di_handler = c_noop;
X		else
X		{
X			dipc->di_handler = c_mfhi;
X			dipc->di_0 = &P.p_state[rd];
X		}
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(R_HI, d);
X
X	procsput(rd, d);
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_mflo(dipc)
Xdinstrn	*dipc;
X{
X	*dipc->di_0 = P.p_state[R_LO];
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_mflo(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	d;
X
X	if (compile_ok)
X	{
X		if (rd == R_0)
X			dipc->di_handler = c_noop;
X		else
X		{
X			dipc->di_handler = c_mflo;
X			dipc->di_0 = &P.p_state[rd];
X		}
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(R_LO, d);
X
X	procsput(rd, d);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_movfmt(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint	fmt;
Xint	ft;
Xint	fs;
Xint	fd;
X{
X	float	singles;
X	double	doubles;
X
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singles);
X
X		procsput(CP1G(fd), *(unsigned long *)&singles);
X
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doubles + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doubles);
X
X		procsput(CP1G(fd), *((unsigned long *)&doubles + 1));
X
X		procsput(CP1G(fd) + 1, *(unsigned long *)&doubles);
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_mtc1(dipc, rt, fs)
Xdinstrn	*dipc;
Xint	rt;
Xint	fs;
X{
X	unsigned long	t;
X
X	procsget(rt, t);
X
X	procsput(CP1G(fs), t);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_mthi(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	v;
X
X	procsget(rs, v);
X
X	procsput(R_HI, v);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_mtlo(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	v;
X
X	procsget(rs, v);
X
X	procsput(R_LO, v);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_mulfmt(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint	fmt;
Xint	ft;
Xint	fs;
Xint	fd;
X{
X	float	singles;
X	float	singlet;
X	float	singled;
X	double	doubles;
X	double	doublet;
X	double	doubled;
X
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singles);
X
X		procsget(CP1G(ft), *(unsigned long *)&singlet);
X
X		singled = singles * singlet;
X
X		procsput(CP1G(fd), *(unsigned long *)&singled);
X
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doubles + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doubles);
X
X		procsget(CP1G(ft), *((unsigned long *)&doublet + 1));
X
X		procsget(CP1G(ft) + 1, *(unsigned long *)&doublet);
X
X		doubled = doubles * doublet;
X
X		procsput(CP1G(fd), *((unsigned long *)&doubled + 1));
X
X		procsput(CP1G(fd) + 1, *(unsigned long *)&doubled);
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_mult(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	s;
X	unsigned long	t;
X	unsigned long	hi;
X	unsigned long	lo;
X
X	procsget(rs, s);
X
X	procsget(rt, t);
X
X	if (dmult(s, t, &hi, &lo) != -1)
X	{
X		procsput(R_HI, hi);
X		procsput(R_LO, lo);
X	}
X
X	return dipc;
X}
X
Xstatic
Xdinstrn	*
Xc_multu(dipc)
Xdinstrn	*dipc;
X{
X	(void)dmultu(*dipc->di_0, *dipc->di_1, &P.p_state[R_HI], &P.p_state[R_LO]);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_multu(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint	rs;
Xint	rt;
Xint	rd;
Xint	shamt;
Xint	funct;
X{
X	unsigned long	s;
X	unsigned long	t;
X	unsigned long	hi;
X	unsigned long	lo;
X
X	if (compile_ok)
X	{
X		dipc->di_handler = c_multu;
X		dipc->di_0 = &P.p_state[rs];
X		dipc->di_1 = &P.p_state[rt];
X
X		return (*dipc->di_handler)(dipc);
X	}
X
X	procsget(rs, s);
X
X	procsget(rt, t);
X
X	if (dmultu(s, t, &hi, &lo) != -1)
X	{
X		procsput(R_HI, hi);
X		procsput(R_LO, lo);
X	}
X
X	return dipc;
X}
END_OF_FILE
if test 4303 -ne `wc -c <'i_m.c'`; then
    echo shar: \"'i_m.c'\" unpacked with wrong size!
fi
# end of 'i_m.c'
fi
if test -f 'i_n.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'i_n.c'\"
else
echo shar: Extracting \"'i_n.c'\" \(1153 characters\)
sed "s/^X//" >'i_n.c' <<'END_OF_FILE'
X#include	"register.h"
X#include	"symtab.h"
X#include	"diblock.h"
X#include	"instrn.h"
X#include	"process.h"
X
Xdinstrn	*
Xi_negfmt(dipc, fmt, ft, fs, fd)
Xdinstrn	*dipc;
Xint		fmt;
Xint		ft;
Xint		fs;
Xint		fd;
X{
X	float	singles;
X	float	singled;
X	double	doubles;
X	double	doubled;
X
X	switch (fmt)
X	{
X	case FMT_SINGLE:
X		procsget(CP1G(fs), *(unsigned long *)&singles);
X
X		singled = -singles;
X
X		procsput(CP1G(fd), *(unsigned long *)&singled);
X
X		break;
X
X	case FMT_DOUBLE:
X		/*
X		 * Note apparent reversal of words within
X		 * doubles here -- no idea why.
X		 */
X		procsget(CP1G(fs), *((unsigned long *)&doubles + 1));
X
X		procsget(CP1G(fs) + 1, *(unsigned long *)&doubles);
X
X		doubled = -doubles;
X
X		procsput(CP1G(fd), *((unsigned long *)&doubled + 1));
X
X		procsput(CP1G(fd) + 1, *(unsigned long *)&doubled);
X		break;
X
X	default:
X		unrecognised(dipc);
X		break;
X	}
X
X	return dipc;
X}
X
Xdinstrn	*
Xc_noop(dipc)
Xdinstrn	*dipc;
X{
X	return dipc;
X}
X
Xdinstrn	*
Xi_nor(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint		rs;
Xint		rt;
Xint		rd;
Xint		shamt;
Xint		funct;
X{
X	unsigned long	s;
X	unsigned long	t;
X
X	procsget(rs, s);
X
X	procsget(rt, t);
X
X	procsput(rd, ~(s | t));
X
X	return dipc;
X}
END_OF_FILE
if test 1153 -ne `wc -c <'i_n.c'`; then
    echo shar: \"'i_n.c'\" unpacked with wrong size!
fi
# end of 'i_n.c'
fi
if test -f 'i_o.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'i_o.c'\"
else
echo shar: Extracting \"'i_o.c'\" \(540 characters\)
sed "s/^X//" >'i_o.c' <<'END_OF_FILE'
X#include	"register.h"
X#include	"symtab.h"
X#include	"diblock.h"
X#include	"instrn.h"
X#include	"process.h"
X
Xdinstrn	*
Xi_or(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint		rs;
Xint		rt;
Xint		rd;
Xint		shamt;
Xint		funct;
X{
X	unsigned long	s;
X	unsigned long	t;
X
X	procsget(rs, s);
X
X	procsget(rt, t);
X
X	procsput(rd, s | t);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_ori(dipc, rs, rt, immediate)
Xdinstrn	*dipc;
Xint		rs;
Xint		rt;
Xshort		immediate;
X{
X	unsigned long	s;
X
X	procsget(rs, s);
X
X	procsput(rt, s | ((unsigned long)immediate & 0xFFFF));
X
X	return dipc;
X}
END_OF_FILE
if test 540 -ne `wc -c <'i_o.c'`; then
    echo shar: \"'i_o.c'\" unpacked with wrong size!
fi
# end of 'i_o.c'
fi
if test -f 'i_u.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'i_u.c'\"
else
echo shar: Extracting \"'i_u.c'\" \(121 characters\)
sed "s/^X//" >'i_u.c' <<'END_OF_FILE'
X#include	"diblock.h"
X#include	"instrn.h"
X
Xdinstrn	*
Xi_undef(dipc)
Xdinstrn	*dipc;
X{
X	unrecognised(dipc);
X
X	return dipc;
X}
END_OF_FILE
if test 121 -ne `wc -c <'i_u.c'`; then
    echo shar: \"'i_u.c'\" unpacked with wrong size!
fi
# end of 'i_u.c'
fi
if test -f 'i_x.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'i_x.c'\"
else
echo shar: Extracting \"'i_x.c'\" \(542 characters\)
sed "s/^X//" >'i_x.c' <<'END_OF_FILE'
X#include	"register.h"
X#include	"symtab.h"
X#include	"diblock.h"
X#include	"instrn.h"
X#include	"process.h"
X
Xdinstrn	*
Xi_xor(dipc, rs, rt, rd, shamt, funct)
Xdinstrn	*dipc;
Xint		rs;
Xint		rt;
Xint		rd;
Xint		shamt;
Xint		funct;
X{
X	unsigned long	s;
X	unsigned long	t;
X
X	procsget(rs, s);
X
X	procsget(rt, t);
X
X	procsput(rd, s ^ t);
X
X	return dipc;
X}
X
Xdinstrn	*
Xi_xori(dipc, rs, rt, immediate)
Xdinstrn	*dipc;
Xint		rs;
Xint		rt;
Xshort		immediate;
X{
X	unsigned long	s;
X
X	procsget(rs, s);
X
X	procsput(rt, s ^ ((unsigned long)immediate & 0xFFFF));
X
X	return dipc;
X}
END_OF_FILE
if test 542 -ne `wc -c <'i_x.c'`; then
    echo shar: \"'i_x.c'\" unpacked with wrong size!
fi
# end of 'i_x.c'
fi
if test -f 'install' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'install'\"
else
echo shar: Extracting \"'install'\" \(486 characters\)
sed "s/^X//" >'install' <<'END_OF_FILE'
XDEFAULTHOSTS="`ls /n/.mips`"
X
Xcase $# in
X0)
X	HOSTS="$DEFAULTHOSTS"
X	;;
X
X*)
X	HOSTS="$*"
X	;;
Xesac
X
Xfor h in $HOSTS
Xdo
X	echo $h
X	(
X		DIR=/n/$h/usr/local/bin
X		TARGET=$DIR/trash
X		OLDTARGET=$DIR/OLDtrash$$
X
X		mv $TARGET $OLDTARGET
X		ls trash | cpio -pdm $DIR
X		chmod 755 $TARGET
X		/bsd43/bin/chown bin.bin $TARGET
X		rm -f $DIR/OLDtrash*
X	)
X	(
X		DIR=/n/$h/usr/local/man/man1
X		TARGET=$DIR/trash.1
X
X		ls trash.1 | cpio -pdm $DIR
X		chmod 664 $TARGET
X		/bsd43/bin/chown man.bin $TARGET
X	)
Xdone
END_OF_FILE
if test 486 -ne `wc -c <'install'`; then
    echo shar: \"'install'\" unpacked with wrong size!
fi
chmod +x 'install'
# end of 'install'
fi
if test -f 'instrn.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'instrn.h'\"
else
echo shar: Extracting \"'instrn.h'\" \(1607 characters\)
sed "s/^X//" >'instrn.h' <<'END_OF_FILE'
X/*
X * See optab.c.
X */
X#define	OP(a,b,c,d)	{a,b,c,d}
X
X/*
X * An entry in the table of instructions
X * each of which describes the known
X * info. about the instruction's arguments
X * - see optab.c.
X */
Xtypedef struct instrn	instrn;
Xstruct instrn
X{
X	char	*i_name;	/* Printable name.			*/
X	int	i_format;	/* Instruction format -- see p.A-3.	*/
X#define	IF_U	0		/*			undefined	*/
X#define	IF_I	1		/*			immediate	*/
X#define	IF_J	2		/*			jump		*/
X#define	IF_R	3		/*			register	*/
X				/* See p.B-2 and foll.			*/
X#define	IF_I1	4		/*			immediate(cop1)	*/
X#define	IF_M1	5		/*			move (cop1)	*/
X#define	IF_C1	6		/*			control (cop1)	*/
X#define	IF_R1	7		/*			register (cop1)	*/
X	dinstrn	*(*i_handler)(); /* Routine that performs the instn's fn.*/
X	char	*i_pageno;	/* The "mips RISC ARCHITECTURE" book.	*/
X};
X
X/*
X * Floating point register formats.
X */
X#define	FMT_SINGLE		0
X#define	FMT_DOUBLE		1
X#define	FMT_FIXED		4
X
X/*
X * Extract subfields from an instruction.
X */
X#define	i_to_op(i)		(((i) >> 26) & 0x3F)
X#define	i_to_rs(i)		(((i) >> 21) & 0x1F)
X#define	i_to_rt(i)		(((i) >> 16) & 0x1F)
X#define	i_to_immediate(i)	(((i) >> 0) & 0xFFFF)
X#define	i_to_target(i)		(((i) >> 0) & 0x3FFFFFF)
X#define	i_to_rd(i)		(((i) >> 11) & 0x1F)
X#define	i_to_shamt(i)		(((i) >> 6) & 0x1F)
X#define	i_to_funct(i)		(((i) >> 0) & 0x3F)
X#define	is_cop1_group1(i)	((((i) >> 25) & 0x1) == 0)
X#define	i_to_cop1_group1(i)	((((i) >> 16) & 0x1) | (((i) >> 21) & (0x7 << 1)))
X#define	i_to_cop1_group2(i)	i_to_funct(i)
X#define	i_to_fmt(i)		(i_to_rs(i) & 0xF)
X#define	i_to_ft(i)		i_to_rt(i)
X#define	i_to_fs(i)		i_to_rd(i)
X#define	i_to_fd(i)		i_to_shamt(i)
END_OF_FILE
if test 1607 -ne `wc -c <'instrn.h'`; then
    echo shar: \"'instrn.h'\" unpacked with wrong size!
fi
# end of 'instrn.h'
fi
if test -f 'myldopen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'myldopen.c'\"
else
echo shar: Extracting \"'myldopen.c'\" \(2038 characters\)
sed "s/^X//" >'myldopen.c' <<'END_OF_FILE'
X#include	<sys/param.h>
X#include	<sys/types.h>
X#include	<errno.h>
X#include	<fcntl.h>
X#include	<stdio.h>
X#include	<filehdr.h>
X#include	<scnhdr.h>
X#include	<syms.h>
X#include	<ldfcn.h>
X#include	<aouthdr.h>
X
Xextern void	couldnot();
X
Xextern int	errno;
X
X/*
X * Front-end for ldopen()
X * that writes different
X * error messages.
X */
XLDFILE	*
Xmy_ldopen(adotout, ldfp)
Xchar	*adotout;
XLDFILE	*ldfp;
X{
X	int	new_fd;
X	int	need_cleanup;
X	LDFILE	*resultfp;
X	int	saved_errno;
X
X	need_cleanup = 1;
X
X	if ((new_fd = dup(2)) == -1)
X	{
X		if (errno == EBADF)
X		{
X			errno = 0;
X			need_cleanup = 0;
X		}
X		else
X		{
X			couldnot("dup fd 2 before ldopen(\"%s\", ..)", adotout);
X			return (LDFILE *)0;
X		}
X	}
X
X	if (need_cleanup)
X	{
X		int	devnull_fd;
X
X		if ((devnull_fd = open("/dev/null", O_WRONLY)) == -1)
X		{
X			couldnot("open /dev/null before ldopen(\"%s\", ..)", adotout);
X			(void)close(new_fd);
X			return (LDFILE *)0;
X		}
X
X		if (dup2(devnull_fd, 2) != 2)
X		{
X			saved_errno = errno;
X			(void)dup2(new_fd, 2);
X			errno = saved_errno;
X			couldnot("dup2 /dev/null fd before ldopen(\"%s\", ..)", adotout);
X			(void)close(devnull_fd);
X			(void)close(new_fd);
X			return (LDFILE *)0;
X		}
X
X		if (close(devnull_fd) == -1)
X		{
X			saved_errno = errno;
X			(void)dup2(new_fd, 2);
X			errno = saved_errno;
X			couldnot("close /dev/null fd before ldopen(\"%s\", ..)", adotout);
X			(void)close(new_fd);
X			return (LDFILE *)0;
X		}
X	}
X
X	if ((resultfp = ldopen(adotout, ldfp)) == (LDFILE *)0)
X	{
X		if (need_cleanup)
X		{
X			saved_errno = errno;
X			(void)dup2(new_fd, 2);
X			errno = saved_errno;
X		}
X		couldnot("ldopen \"%s\"", adotout);
X		if (need_cleanup)
X			(void)close(new_fd);
X		return (LDFILE *)0;
X	}
X
X	if (need_cleanup)
X	{
X		if (dup2(new_fd, 2) != 2)
X		{
X			couldnot("dup2 to restore fd 2 after ldopen(\"%s\", ..)", adotout);
X			(void)ldclose(resultfp);
X			(void)close(new_fd);
X			return (LDFILE *)0;
X		}
X
X		if (close(new_fd) == -1)
X		{
X			couldnot("close new_fd after ldopen(\"%s\", ..)", adotout);
X			(void)ldclose(resultfp);
X			return (LDFILE *)0;
X		}
X	}
X
X	return resultfp;
X}
END_OF_FILE
if test 2038 -ne `wc -c <'myldopen.c'`; then
    echo shar: \"'myldopen.c'\" unpacked with wrong size!
fi
# end of 'myldopen.c'
fi
if test -f 'myname.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'myname.c'\"
else
echo shar: Extracting \"'myname.c'\" \(374 characters\)
sed "s/^X//" >'myname.c' <<'END_OF_FILE'
Xchar	*
Xmyname()
X{
X	static char	*s_myname;
X
X	if (s_myname == (char *)0)
X	{
X		extern char	*strrchr();
X		extern char	**gargv;
X
X		if (gargv == (char **)0)
X		{
X			/*
X			 * Klutz - you forgot to initialise gargv in main().
X			 */
X			s_myname = "?";
X		}
X		else if ((s_myname = strrchr(*gargv, '/')) == (char *)0)
X			s_myname = *gargv;
X		else
X			s_myname++;
X	}
X
X	return s_myname;
X}
END_OF_FILE
if test 374 -ne `wc -c <'myname.c'`; then
    echo shar: \"'myname.c'\" unpacked with wrong size!
fi
# end of 'myname.c'
fi
if test -f 'nels.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nels.h'\"
else
echo shar: Extracting \"'nels.h'\" \(43 characters\)
sed "s/^X//" >'nels.h' <<'END_OF_FILE'
X#define	nels(a)	(sizeof(a) / sizeof(a[0]))
END_OF_FILE
if test 43 -ne `wc -c <'nels.h'`; then
    echo shar: \"'nels.h'\" unpacked with wrong size!
fi
# end of 'nels.h'
fi
if test -f 'posix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'posix.c'\"
else
echo shar: Extracting \"'posix.c'\" \(1302 characters\)
sed "s/^X//" >'posix.c' <<'END_OF_FILE'
X#include	<stdio.h>
X#include	"sysentry.h"
X#include	"nels.h"
X
Xextern FILE	*outfp;
X
Xstatic sysentry	posix_systab[]	=
X{
X	{ "syscall",	0,	"",	'\0',	(int (*)())0,	},
X};
X
Xsysentry	*
Xposix_systab_entry(n)
Xint	n;
X{
X	if (n >= 0 && n < nels(posix_systab))
X		return &posix_systab[n];
X
X	return (sysentry *)0;
X}
X
Xint
Xposix_print_open_flags(arg)
Xlong	arg;
X{
X	vcouldnot("print posix open flags 0x%x", arg);
X	return -1;
X}
X
Xint
Xposix_print_stat(arg)
Xlong	arg;
X{
X	vcouldnot("print posix stat structure at address 0x%x", arg);
X	return -1;
X}
X
Xint
Xposix_print_ioctl_cmd(cmd)
Xunsigned long	cmd;
X{
X	char	*cname;
X
X	switch (cmd)
X	{
X	default:
X		cname = (char *)0;
X		break;
X	}
X
X	if (cname == (char *)0)
X		fprintf(outfp, "0x%x", cmd);
X	else
X		fprintf(outfp, "%s", cname);
X
X	return 0;
X}
X
Xint
Xposix_print_ioctl_arg(args)
Xunsigned long	*args;
X{
X	switch (args[1])
X	{
X	default:
X		fprintf(outfp, "0x%x", args[2]);
X		break;
X	}
X
X	return 0;
X}
X
Xint
Xposix_print_fdset(nfds, arg)
Xint		nfds;
Xunsigned long	arg;
X{
X	fprintf(outfp, "0x%x", arg);
X
X	return 0;
X}
X
Xint
Xposix_print_whence(arg)
Xunsigned long	arg;
X{
X	fprintf(outfp, "0x%x", arg);
X
X	return 0;
X}
X
Xint
Xposix_print_statfs(arg)
Xunsigned long	arg;
X{
X	fprintf(outfp, "0x%x", arg);
X
X	return 0;
X}
X
Xvoid
Xposix_print_sigcontext(outfp, p)
XFILE		*outfp;
Xunsigned long	p;
X{
X	fprintf(outfp, "0x%x");
X}
END_OF_FILE
if test 1302 -ne `wc -c <'posix.c'`; then
    echo shar: \"'posix.c'\" unpacked with wrong size!
fi
# end of 'posix.c'
fi
if test -f 'process.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'process.h'\"
else
echo shar: Extracting \"'process.h'\" \(3667 characters\)
sed "s/^X//" >'process.h' <<'END_OF_FILE'
X#define	DEFAULT_TEXT_MIN	((unsigned long)0x00400000)
X#define	DEFAULT_DATA_MIN	((unsigned long)0x10000000)
X
X#define	STACK_MAX		((unsigned long)0x7FFFFFFF)
X#define	STACK_WMAX		(STACK_MAX + 1 - sizeof(unsigned long))
X
X/*
X * Arbitrary...
X */
X#define	STACK_MIN		((STACK_MAX + 1) / 2)
X#define	DATA_MAX		(STACK_MIN - 1)
X
Xtypedef struct process		process;
Xstruct process
X{
X	char			*p_adotout;
X	unsigned long		p_entry_point;
X	int			p_pid;
X	unsigned long		p_state[R_MAX];
X	symtab			p_symtab;
X
X	/*
X	 * Text space.
X	 *
X	 * p_text_region_limit =
X	 *	p->p_text_region_min + p_text_region_size - 1;
X	 */
X	unsigned char		*p_text_region;
X	unsigned long		p_text_region_min;
X	unsigned long		p_text_region_limit;
X	unsigned long		p_text_region_wlimit;
X	int			p_text_region_is_readonly;
X
X	/*
X	 * Data space.
X	 *
X	 * p_data_region_limit =
X	 *	p_data_region_min + p_data_region_size - 1;
X	 * ((p_data_region_limit + sizeof(unsigned char)) is
X	 * also known as The Break.)
X	 *
X	 * p_writable_data >= p_data_region_min
X	 *	&&
X	 * p_writable_data <= DATA_MAX
X	 */
X	unsigned char		*p_data_region;
X	unsigned long		p_data_region_min;
X	unsigned long		p_data_region_limit;
X	unsigned long		p_data_region_wlimit;
X	unsigned long		p_writable_data;
X
X	/*
X	 * Stack space.
X	 *
X	 * p_stack_region_min =
X	 *	STACK_MAX + 1 - p_stack_region_size;
X	 */
X	unsigned char		*p_stack_region;
X	unsigned long		p_stack_region_min;
X};
X
X#define	check_word_align(dipc,i) \
X{ \
X	if ((i) & 0x3) \
X	{ \
X		GLOBALdipc = dipc; \
X		vcouldnot("access memory at non word-aligned address 0x%x", (i)); \
X	} \
X}
X
X#define	check_halfword_align(dipc,i) \
X{ \
X	if ((i) & 0x1) \
X	{ \
X		GLOBALdipc = dipc; \
X		vcouldnot("access memory at non halfword-aligned address 0x%x", (i)); \
X	} \
X}
X
X#define	do_known_delayed_branch \
X{ \
X	dinstrn	*bdslot_dipc; \
X \
X	bdslot_dipc = (dinstrn *)dipc->di_2; \
X \
X	(void)(*bdslot_dipc->di_handler)(bdslot_dipc); \
X \
X	dipc = (dinstrn *)dipc->di_3; \
X}
X
X#define	do_unknown_delayed_branch \
X{ \
X	dinstrn	*bdslot_dipc; \
X \
X	bdslot_dipc = (dinstrn *)dipc->di_1; \
X \
X	(void)(*bdslot_dipc->di_handler)(bdslot_dipc); \
X \
X	if (sigs_pending > 0) \
X		dipc = deliver_signal(addr_to_decoded_instrnp(dipc, *dipc->di_0)); \
X	else \
X		dipc = addr_to_decoded_instrnp(dipc, *dipc->di_0) - 1; \
X}
X
X#define	do_known_delayed_upbranch \
X{ \
X	do_known_delayed_branch; \
X \
X	if (sigs_pending > 0) \
X		dipc = deliver_signal(dipc + 1); \
X}
X
X#define	procsput(regi,value) \
X{ \
X	if (Rflag) \
X		procsput_trace(regi, value); \
X \
X	switch (regi) \
X	{ \
X	case R_0: \
X		/* \
X		 * Register 0 is special. \
X		 */ \
X		break; \
X \
X	case R_K0: \
X	case R_K1: \
X		if (give_warnings) \
X			warning("write to kernel-reserved register %s", say_register(regi)); \
X		/* fall thru. */ \
X	default: \
X		P.p_state[regi] = value; \
X		break; \
X	} \
X}
X
X#define	procsget(regi,r) \
X{ \
X	switch (regi) \
X	{ \
X	case R_K0: \
X	case R_K1: \
X		if (give_warnings) \
X			procsget_warning(regi); \
X		/* fall thru. */ \
X	default: \
X		r = P.p_state[regi]; \
X		break; \
X	} \
X \
X	if (Rflag) \
X		procsget_trace(regi, r); \
X}
X
Xextern char			*malloc();
Xextern char			*calloc();
Xextern char			*realloc();
X
Xextern int			procopen();
Xextern void			procsget_trace();
Xextern void			procsput_trace();
Xextern void			procsget_warning();
Xextern void			procmget_trace();
Xextern int			quiet_procmget();
Xextern int			quiet_procmput();
Xextern int			quiet_procsget();
Xextern int			quiet_procsput();
Xextern int			quiet_procbreakget();
Xextern int			quiet_procbreakput();
Xextern char			*proc_text_address();
Xextern int			proc_grow_stack();
Xextern int			proc_mem_contiguous();
X
Xextern int			Mflag;
Xextern int			Rflag;
X
Xextern process			P;
Xextern int			give_warnings;
Xextern int			sigs_pending;
END_OF_FILE
if test 3667 -ne `wc -c <'process.h'`; then
    echo shar: \"'process.h'\" unpacked with wrong size!
fi
# end of 'process.h'
fi
if test -f 'register.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'register.h'\"
else
echo shar: Extracting \"'register.h'\" \(2197 characters\)
sed "s/^X//" >'register.h' <<'END_OF_FILE'
X/*
X * Register space size.
X */
X#define	NREGS		32
X
X/*
X * Main processor general registers.
X */
X#define	PGBASE		0
X#define	PG(r)		(PGBASE + r)
X
X/*
X * Main processor "control" registers.
X */
X#define	PCBASE		(PGBASE + NREGS)
X#define	PC(r)		(PCBASE + r)
X
X/*
X * Coprocessor 0 general registers.
X */
X#define	CP0GBASE	(PCBASE + NREGS)
X#define	CP0G(r)		(CP0GBASE + r)
X
X/*
X * Coprocessor 0 control registers.
X */
X#define	CP0CBASE	(CP0GBASE + NREGS)
X#define	CP0C(r)		(CP0CBASE + r)
X
X/*
X * Coprocessor 1 general registers.
X */
X#define	CP1GBASE	(CP0CBASE + NREGS)
X#define	CP1G(r)		(CP1GBASE + r)
X
X/*
X * Coprocessor 1 control registers.
X */
X#define	CP1CBASE	(CP1GBASE + NREGS)
X#define	CP1C(r)		(CP1CBASE + r)
X#define	CP1CS		(CP1C(31))	/* Control/Status Register */
X#define	Condition_Shift	23
X#define	Set_Cond(r,v)	r = ((v) ? (r | (1 << Condition_Shift)) : (r & ~(1 << Condition_Shift)))
X#define	Test_Cond(r)	(((r) >> Condition_Shift) & 0x1)
X
X/*
X * Coprocessor 2 general registers.
X */
X#define	CP2GBASE	(CP1CBASE + NREGS)
X#define	CP2G(r)		(CP2GBASE + r)
X
X/*
X * Coprocessor 2 control registers.
X */
X#define	CP2CBASE	(CP2GBASE + NREGS)
X#define	CP2C(r)		(CP2CBASE + r)
X
X/*
X * Coprocessor 3 general registers.
X */
X#define	CP3GBASE	(CP2CBASE + NREGS)
X#define	CP3G(r)		(CP3GBASE + r)
X
X/*
X * Coprocessor 3 control registers.
X */
X#define	CP3CBASE	(CP3GBASE + NREGS)
X#define	CP3C(r)		(CP3CBASE + r)
X
X/*
X * Must be greater than
X * the largest of the above..
X */
X#define	R_MAX		(CP3CBASE + NREGS)
X
X/*
X * Some aliases.
X */
X#define	R_0		PG(0)
X#define	R_AT		PG(1)
X#define	R_V0		PG(2)
X#define	R_V1		PG(3)
X#define	R_A0		PG(4)
X#define	R_A1		PG(5)
X#define	R_A2		PG(6)
X#define	R_A3		PG(7)
X#define	R_T0		PG(8)
X#define	R_T1		PG(9)
X#define	R_T2		PG(10)
X#define	R_T3		PG(11)
X#define	R_T4		PG(12)
X#define	R_T5		PG(13)
X#define	R_T6		PG(14)
X#define	R_T7		PG(15)
X#define	R_S0		PG(16)
X#define	R_S1		PG(17)
X#define	R_S2		PG(18)
X#define	R_S3		PG(19)
X#define	R_S4		PG(20)
X#define	R_S5		PG(21)
X#define	R_S6		PG(22)
X#define	R_S7		PG(23)
X#define	R_T8		PG(24)
X#define	R_T9		PG(25)
X#define	R_K0		PG(26)
X#define	R_K1		PG(27)
X#define	R_GP		PG(28)
X#define	R_SP		PG(29)
X#define	R_S8		PG(30)
X#define	R_RA		PG(31)
X
X#define	R_HI		PC(0)
X#define	R_LO		PC(1)
END_OF_FILE
if test 2197 -ne `wc -c <'register.h'`; then
    echo shar: \"'register.h'\" unpacked with wrong size!
fi
# end of 'register.h'
fi
if test -f 'res.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'res.h'\"
else
echo shar: Extracting \"'res.h'\" \(204 characters\)
sed "s/^X//" >'res.h' <<'END_OF_FILE'
Xextern int	res_sys_start();
Xextern int	res_sys_stop();
Xextern void	res_print();
X
Xextern int	Tflag;
X
X#define	Rstart	{ if (Tflag) (void)res_sys_start(); }
X#define	Rstop	{ if (Tflag) (void)res_sys_stop(); }
END_OF_FILE
if test 204 -ne `wc -c <'res.h'`; then
    echo shar: \"'res.h'\" unpacked with wrong size!
fi
# end of 'res.h'
fi
if test -f 'resource.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'resource.c'\"
else
echo shar: Extracting \"'resource.c'\" \(1734 characters\)
sed "s/^X//" >'resource.c' <<'END_OF_FILE'
X#include	<bsd43/sys/syscall.h>
X#include	<bsd43/sys/time.h>
X#include	<bsd43/sys/resource.h>
X#include	<stdio.h>
X#include	"res.h"
X
X#define	USE_GETTIMEOFDAY	1
X
Xextern FILE			*outfp;
X
X#if	USE_GETTIMEOFDAY
Xstatic struct bsd43_timeval	starttd;
Xstatic struct bsd43_timeval	stoptd;
X#else	/* USE_GETTIMEOFDAY */
Xstatic struct bsd43_rusage	start;
Xstatic struct bsd43_rusage	stop;
X#endif	/* USE_GETTIMEOFDAY */
X
Xint
Xres_sys_start()
X{
X#if	USE_GETTIMEOFDAY
X	if (syscall(BSD43_SYS_gettimeofday, &starttd, (struct bsd43_timezone *)0) == -1)
X	{
X		vcouldnot("gettimeofday(): start");
X		return -1;
X	}
X#else	/* USE_GETTIMEOFDAY */
X	if (syscall(BSD43_SYS_getrusage, BSD43_RUSAGE_SELF, &start) == -1)
X	{
X		vcouldnot("getrusage(): start");
X		return -1;
X	}
X#endif	/* USE_GETTIMEOFDAY */
X
X	return 0;
X}
X
Xint
Xres_sys_stop()
X{
X#if	USE_GETTIMEOFDAY
X	if (syscall(BSD43_SYS_gettimeofday, &stoptd, (struct bsd43_timezone *)0) == -1)
X	{
X		vcouldnot("gettimeofday(): stop");
X		return -1;
X	}
X#else	/* USE_GETTIMEOFDAY */
X	if (syscall(BSD43_SYS_getrusage, BSD43_RUSAGE_SELF, &stop) == -1)
X	{
X		vcouldnot("getrusage(): stop");
X		return -1;
X	}
X#endif	/* USE_GETTIMEOFDAY */
X
X	return 0;
X}
X
Xvoid
Xres_print()
X{
X	fprintf
X	(
X		outfp,
X		" <Ds=%dus>",
X#if	USE_GETTIMEOFDAY
X		(stoptd.tv_sec - starttd.tv_sec) * 1000000 +
X		(stoptd.tv_usec - starttd.tv_usec)
X#else	/* USE_GETTIMEOFDAY */
X		(stop.ru_stime.tv_sec - start.ru_stime.tv_sec) * 1000000 +
X		(stop.ru_stime.tv_usec - start.ru_stime.tv_usec)
X#endif	/* USE_GETTIMEOFDAY */
X	);
X
X#if	USE_GETTIMEOFDAY
X	stoptd.tv_sec = starttd.tv_sec;
X	stoptd.tv_usec = starttd.tv_usec;
X#else	/* USE_GETTIMEOFDAY */
X	stop.ru_stime.tv_sec = start.ru_stime.tv_sec;
X	stop.ru_stime.tv_usec = start.ru_stime.tv_usec;
X#endif	/* USE_GETTIMEOFDAY */
X}
END_OF_FILE
if test 1734 -ne `wc -c <'resource.c'`; then
    echo shar: \"'resource.c'\" unpacked with wrong size!
fi
# end of 'resource.c'
fi
if test -f 'say.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'say.c'\"
else
echo shar: Extracting \"'say.c'\" \(1913 characters\)
sed "s/^X//" >'say.c' <<'END_OF_FILE'
X#include	"register.h"
X
Xstatic char	*pg_string[]	=
X{
X	"zero",
X	"at",
X	"v0",
X	"v1",
X	"a0",
X	"a1",
X	"a2",
X	"a3",
X	"t0",
X	"t1",
X	"t2",
X	"t3",
X	"t4",
X	"t5",
X	"t6",
X	"t7",
X	"s0",
X	"s1",
X	"s2",
X	"s3",
X	"s4",
X	"s5",
X	"s6",
X	"s7",
X	"t8",
X	"t9",
X	"k0",
X	"k1",
X	"gp",
X	"sp",
X	"s8",
X	"ra",
X};
X
Xchar	*
Xsay_register(r)
Xint	r;
X{
X	static char	result[128];
X
X	if (r >= R_MAX)
X		sprintf(&result[0], "<unknown register: %d>", r);
X	else if (r >= CP3CBASE)
X		sprintf(&result[0], "CP3C(%d)", r - CP3CBASE);
X	else if (r >= CP3GBASE)
X		sprintf(&result[0], "CP3G(%d)", r - CP3GBASE);
X	else if (r >= CP2CBASE)
X		sprintf(&result[0], "CP2C(%d)", r - CP2CBASE);
X	else if (r >= CP2GBASE)
X		sprintf(&result[0], "CP2G(%d)", r - CP2GBASE);
X	else if (r >= CP1CBASE)
X	{
X		if (r == CP1C(31))
X			sprintf(&result[0], "CP1CS");
X		else
X			sprintf(&result[0], "CP1C(%d)", r - CP1CBASE);
X	}
X	else if (r >= CP1GBASE)
X		sprintf(&result[0], "CP1G(%d)", r - CP1GBASE);
X	else if (r >= CP0CBASE)
X		sprintf(&result[0], "CP0C(%d)", r - CP0CBASE);
X	else if (r >= CP0GBASE)
X		sprintf(&result[0], "CP0G(%d)", r - CP0GBASE);
X	else if (r >= PCBASE)
X	{
X		switch (r)
X		{
X		case PC(0):
X			sprintf(&result[0], "hi");
X			break;
X
X		case PC(1):
X			sprintf(&result[0], "lo");
X			break;
X
X		case PC(2):
X			sprintf(&result[0], "pc");
X			break;
X
X		case PC(3):
X			sprintf(&result[0], "delayedpc");
X			break;
X
X		case PC(4):
X			sprintf(&result[0], "delayedstatus");
X			break;
X
X		case PC(5):
X			sprintf(&result[0], "break");
X			break;
X
X		default:
X			sprintf(&result[0], "PC(%d)", r - PCBASE);
X			break;
X		}
X	}
X	else if (r >= PGBASE)
X		sprintf(&result[0], "%s", pg_string[r - PGBASE]);
X	else
X		sprintf(&result[0], "<unknown register: %d", r);
X
X	return &result[0];
X}
X
Xchar	*
Xsay_fc_register(r)
Xint	r;
X{
X	return say_register(r + CP1CBASE);
X}
X
Xchar	*
Xsay_fg_register(r)
Xint	r;
X{
X	return say_register(r + CP1GBASE);
X}
X
Xchar	*
Xsay_pg_register(r)
Xint	r;
X{
X	return say_register(r + PGBASE);
X}
END_OF_FILE
if test 1913 -ne `wc -c <'say.c'`; then
    echo shar: \"'say.c'\" unpacked with wrong size!
fi
# end of 'say.c'
fi
if test -f 'sgttyb.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sgttyb.c'\"
else
echo shar: Extracting \"'sgttyb.c'\" \(72 characters\)
sed "s/^X//" >'sgttyb.c' <<'END_OF_FILE'
X#include	<sgtty.h>
X
Xint
Xsgttybsize()
X{
X	return sizeof(struct sgttyb);
X}
END_OF_FILE
if test 72 -ne `wc -c <'sgttyb.c'`; then
    echo shar: \"'sgttyb.c'\" unpacked with wrong size!
fi
# end of 'sgttyb.c'
fi
if test -f 'syms.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'syms.c'\"
else
echo shar: Extracting \"'syms.c'\" \(3211 characters\)
sed "s/^X//" >'syms.c' <<'END_OF_FILE'
X#define	LANGUAGE_C	1
X#include		<sys/types.h>
X#include		<sys/stat.h>
X#include		<stdio.h>
X#include		<filehdr.h>
X#include		<syms.h>
X#include		<ldfcn.h>
X#include		"symtab.h"
X
Xextern char		*malloc();
Xextern char		*realloc();
Xextern char		*ldgetname();
X
Xstatic int		symcomp();
Xstatic syment		*findsym();
X
Xint
Xsymtab_open(ldptr, adotout, symtabp)
XLDFILE	*ldptr;
Xchar	*adotout;
Xsymtab	*symtabp;
X{
X	struct stat	statb;
X	FILHDR		filehdr;
X	int		symmax;
X	syment		*stbl;
X	syment		*sp;
X	syment		*nsp;
X	SYMR		sy;
X	HDRR		shdr;
X	int		i;
X	int		symcnt;
X
X	symtabp->st_symcnt = 0;
X	symtabp->st_tab = (syment *)0;
X
X	if (stat(adotout, &statb) == -1)
X	{
X		couldnot("stat \"%s\"", adotout);
X		return -1;
X	}
X
X	if (statb.st_size == 0)
X		return 0;
X
X	if (ldfhread(ldptr, &filehdr) != SUCCESS)
X	{
X		couldnot("read file header from file \"%s\"", adotout);
X		return -1;
X	}
X
X	if (PSYMTAB(ldptr) == (pCHDRR)0)
X		/*
X		 * No symbol table.
X		 */
X		return 0;
X
X	shdr = SYMHEADER(ldptr);
X	symmax = shdr.isymMax + shdr.iextMax;
X
X	if ((stbl = (syment *)malloc((unsigned)(symmax * sizeof(syment)))) == (syment *)0)
X	{
X		couldnot("allocate space for namelist of file \"%s\"", adotout);
X		return -1;
X	}
X
X	for (i = 0, symcnt = 0, sp = stbl; i < symmax; i++)
X	{
X		if (ldtbread(ldptr, i, &sy) == FAILURE)
X		{
X			couldnot("read indexed symbol tabel entry from file \"%s\"", adotout);
X			return -1;
X		}
X
X		if
X		(
X			sy.st != stGlobal
X			&&
X			sy.st != stStatic
X			&&
X			sy.st != stProc
X			&&
X			sy.st != stStaticProc
X		)
X			continue;
X
X		sp->n_value = sy.value;
X		sp->n_scnum = sy.sc;
X		sp->n_name = ldgetname(ldptr, &sy);
X		sp->n_proc = (struct procent *)0;
X
X		symcnt++;
X		sp++;
X	}
X
X	/*
X	 * Sort by address.
X	 */
X	qsort(stbl, symcnt, sizeof(*sp), symcomp);
X
X	/*
X	 * Remove duplicates.
X	 */
X	for (sp = nsp = stbl; sp < &stbl[symcnt]; sp++)
X	{
X		*nsp++ = *sp;
X		while (sp[1].n_value == sp[0].n_value)
X			sp++;
X	}
X
X	/*
X	 * Compact the table.
X	 */
X	symcnt = nsp - stbl;
X	if ((stbl = (syment *)realloc((char *)stbl, (unsigned int)(symcnt * sizeof(syment)))) == (syment *)0)
X	{
X		couldnot("reallocate symbol table space for file \"%s\"", adotout);
X		return -1;
X	}
X
X	/*
X	 * Pass back the results.
X	 */
X	symtabp->st_symcnt = symcnt;
X	symtabp->st_tab = stbl;
X
X	return 0;
X}
X
Xint
Xsymtab_close(symtabp)
Xsymtab	*symtabp;
X{
X	if (symtabp->st_tab != (syment *)0)
X	{
X		(void)free((char *)(symtabp->st_tab));
X		symtabp->st_tab = (syment *)0;
X	}
X
X	symtabp->st_symcnt = 0;
X
X	return 0;
X}
X
Xchar	*
Xsymtab_text_address(symtabp, address)
Xsymtab		*symtabp;
Xunsigned long	address;
X{
X	static char	buf[512];
X	syment		*sp;
X
X	if ((sp = findsym(symtabp, address)) == (syment *)0)
X		sprintf(&buf[0], "0x%06x", address);
X	else
X		sprintf(&buf[0], "%s+0x%02x", sp->n_name, address - sp->n_value);
X
X	return &buf[0];
X}
X
Xstatic
Xint
Xsymcomp(a, b)
Xsyment	*a;
Xsyment	*b;
X{
X	return a->n_value - b->n_value;
X}
X
Xstatic
Xsyment	*
Xfindsym(symtabp, addr)
Xsymtab		*symtabp;
Xunsigned long	addr;
X{
X	int	low;
X	int	high;
X	int	i;
X	syment	*tab;
X
X	if (symtabp == (symtab *)0 || (tab = symtabp->st_tab) == (syment *)0)
X		return (syment *)0;
X
X	low = 0;
X	high = symtabp->st_symcnt;
X
X	while (high - low > 1)
X	{
X		i = (low + high) / 2;
X
X		if (tab[i].n_value <= addr)
X			low = i;
X		else
X			high = i;
X	}
X
X	return &tab[low];
X}
END_OF_FILE
if test 3211 -ne `wc -c <'syms.c'`; then
    echo shar: \"'syms.c'\" unpacked with wrong size!
fi
# end of 'syms.c'
fi
if test -f 'symtab.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'symtab.h'\"
else
echo shar: Extracting \"'symtab.h'\" \(384 characters\)
sed "s/^X//" >'symtab.h' <<'END_OF_FILE'
Xtypedef struct procent	procent;
Xstruct procent
X{
X	long		isym;
X	long		iline;
X	long		regmask;
X	short		regoffset;
X	short		frameoffset;
X};
X
Xtypedef struct syment	syment;
Xstruct syment
X{
X	char		*n_name;
X	unsigned long	n_value;
X	int		n_scnum;
X	procent		*n_proc;
X};
X
Xtypedef struct symtab	symtab;
Xstruct symtab
X{
X	syment		*st_tab;	/* The entries.		*/
X	int		st_symcnt;	/* # of entries.	*/
X};
END_OF_FILE
if test 384 -ne `wc -c <'symtab.h'`; then
    echo shar: \"'symtab.h'\" unpacked with wrong size!
fi
# end of 'symtab.h'
fi
if test -f 'sysentry.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sysentry.h'\"
else
echo shar: Extracting \"'sysentry.h'\" \(478 characters\)
sed "s/^X//" >'sysentry.h' <<'END_OF_FILE'
X#define	U_SYSV		1
X#define	U_BSD43		2
X#define	U_POSIX		3
X
X#define	DIRN_ENTRY	0
X#define	DIRN_EXIT	1
X
X#define	NSYSARGS	6	/* All direct system calls	*/
X				/* have <= NSYSARGS args.	*/
X
X/*
X * Structure of our version of the system-entry table.
X */
Xtypedef struct sysentry	sysentry;
Xstruct sysentry
X{
X	char	*sy_name;	/* name			*/
X	char	sy_narg;	/* number of arguments	*/
X	char	*sy_desc;	/* argument formats	*/
X	char	sy_rdesc;	/* result format	*/
X	int	(*sy_call)();	/* handler		*/
X};
END_OF_FILE
if test 478 -ne `wc -c <'sysentry.h'`; then
    echo shar: \"'sysentry.h'\" unpacked with wrong size!
fi
# end of 'sysentry.h'
fi
if test -f 'sysmess.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sysmess.c'\"
else
echo shar: Extracting \"'sysmess.c'\" \(289 characters\)
sed "s/^X//" >'sysmess.c' <<'END_OF_FILE'
X/*
X * Return a pointer to the error
X * message indicated by errno.
X * or a zero length string if
X * errno is out of bounds.
X */
Xchar	*
Xsysmess()
X{
X	extern int	errno;
X	extern int	sys_nerr;
X	extern char	*sys_errlist[];
X
X	return (errno <= 0 || errno >= sys_nerr) ? "" : sys_errlist[errno];
X}
END_OF_FILE
if test 289 -ne `wc -c <'sysmess.c'`; then
    echo shar: \"'sysmess.c'\" unpacked with wrong size!
fi
# end of 'sysmess.c'
fi
if test -f 'talloc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'talloc.h'\"
else
echo shar: Extracting \"'talloc.h'\" \(44 characters\)
sed "s/^X//" >'talloc.h' <<'END_OF_FILE'
X#define	talloc(t)	(t *)calloc(1, sizeof(t))
END_OF_FILE
if test 44 -ne `wc -c <'talloc.h'`; then
    echo shar: \"'talloc.h'\" unpacked with wrong size!
fi
# end of 'talloc.h'
fi
if test -f 'usage.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'usage.c'\"
else
echo shar: Extracting \"'usage.c'\" \(154 characters\)
sed "s/^X//" >'usage.c' <<'END_OF_FILE'
X#include	<stdio.h>
X
Xextern char	*myname();
X
Xextern char	*usage_args;
X
Xvoid
Xusage()
X{
X	fprintf(stderr, "Usage: %s%s\n", myname(), usage_args);
X	exit(1);
X}
END_OF_FILE
if test 154 -ne `wc -c <'usage.c'`; then
    echo shar: \"'usage.c'\" unpacked with wrong size!
fi
# end of 'usage.c'
fi
if test -f 'vcouldnot.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vcouldnot.c'\"
else
echo shar: Extracting \"'vcouldnot.c'\" \(855 characters\)
sed "s/^X//" >'vcouldnot.c' <<'END_OF_FILE'
X#include	<varargs.h>
X#include	<stdio.h>
X#include	"register.h"
X#include	"symtab.h"
X#include	"diblock.h"
X#include	"instrn.h"
X#include	"process.h"
X
Xextern char		*myname();
Xextern void		format();
Xextern char		*sysmess();
Xextern char		*proc_text_address();
X
Xextern int		errno;
Xextern FILE		*outfp;
X
Xstatic
Xint
Xvcouldnot_putc(c)
Xint	c;
X{
X	putc(c, outfp);
X}
X
X/*
X * "vcouldnot(printf_like_format, printf_like_arg, ...);"
X */
Xvoid
Xvcouldnot(va_alist)
Xva_dcl
X{
X	char	*cp;
X	va_list	ap;
X
X	fprintf(outfp, "%s: could not ", myname());
X	va_start(ap);
X	format(vcouldnot_putc, &ap);
X	va_end(ap);
X	cp = sysmess();
X	if (cp != (char *)0 && *cp != '\0')
X	{
X		fprintf(outfp, ": %s", cp);
X		errno = 0;
X	}
X
X	fprintf(outfp, ": pc=%s", proc_text_address((GLOBALdipc == (dinstrn *)0) ? (unsigned long)0 : GLOBALdipc->di_addr));
X
X	fprintf(outfp, ".\n");
X	fflush(outfp);
X	_exit(1);
X}
END_OF_FILE
if test 855 -ne `wc -c <'vcouldnot.c'`; then
    echo shar: \"'vcouldnot.c'\" unpacked with wrong size!
fi
# end of 'vcouldnot.c'
fi
if test -f 'warning.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'warning.c'\"
else
echo shar: Extracting \"'warning.c'\" \(420 characters\)
sed "s/^X//" >'warning.c' <<'END_OF_FILE'
X#include	<varargs.h>
X#include	<stdio.h>
X
Xextern char	*myname();
Xextern void	format();
X
Xextern FILE	*outfp;
X
Xstatic
Xint
Xwarning_putc(c)
Xint	c;
X{
X	putc(c, outfp);
X}
X
X/*
X * "warning(printf_like_format, printf_like_arg, ...);"
X */
Xvoid
Xwarning(va_alist)
Xva_dcl
X{
X	register char	*cp;
X	va_list		ap;
X
X	fprintf(outfp, "%s: warning: ", myname());
X	va_start(ap);
X	format(warning_putc, &ap);
X	va_end(ap);
X	fprintf(outfp, ".\n");
X}
END_OF_FILE
if test 420 -ne `wc -c <'warning.c'`; then
    echo shar: \"'warning.c'\" unpacked with wrong size!
fi
# end of 'warning.c'
fi
if test -f 'wcache.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wcache.c'\"
else
echo shar: Extracting \"'wcache.c'\" \(214 characters\)
sed "s/^X//" >'wcache.c' <<'END_OF_FILE'
X#include	<stdio.h>
X#include	"wcache.h"
X#include	"nels.h"
X
Xcent	wcache[CACHEZ];
X
Xvoid
Xwcache_clear()
X{
X	int	i;
X
X/*
Xprintf("clear\n");
Xfflush(stdout);
X*/
X	for (i = 0; i < nels(wcache); i++)
X		wcache[i].c_addr = 0;
X}
END_OF_FILE
if test 214 -ne `wc -c <'wcache.c'`; then
    echo shar: \"'wcache.c'\" unpacked with wrong size!
fi
# end of 'wcache.c'
fi
if test -f 'wcache.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wcache.h'\"
else
echo shar: Extracting \"'wcache.h'\" \(139 characters\)
sed "s/^X//" >'wcache.h' <<'END_OF_FILE'
X#define	CACHEZ	4096
X
Xtypedef struct cent	cent;
Xstruct cent
X{
X	unsigned long	c_addr;
X	unsigned long	*c_ptr;
X};
X
Xextern cent	wcache[CACHEZ];
END_OF_FILE
if test 139 -ne `wc -c <'wcache.h'`; then
    echo shar: \"'wcache.h'\" unpacked with wrong size!
fi
# end of 'wcache.h'
fi
echo shar: End of archive 1 \(of 8\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
