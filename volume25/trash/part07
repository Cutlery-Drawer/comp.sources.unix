Newsgroups: comp.sources.unix
From: bruce@beta.cs.su.oz.au (Bruce Janson)
Subject: v25i161: trash - simulate process execution in MIPS RISC/os 4.52, Part07/08
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: bruce@beta.cs.su.oz.au (Bruce Janson)
Posting-Number: Volume 25, Issue 161
Archive-Name: trash/part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 8)."
# Contents:  bsd43.c
# Wrapped by bruce@basser on Tue Mar  3 23:25:24 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'bsd43.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bsd43.c'\"
else
echo shar: Extracting \"'bsd43.c'\" \(51326 characters\)
sed "s/^X//" >'bsd43.c' <<'END_OF_FILE'
X#include		<bsd43/sys/syscall.h>
X#include		<bsd43/sys/param.h>
X#include		<bsd43/sys/types.h>
X#include		<bsd43/sys/vfs.h>
X#include		<bsd43/sys/time.h>
X#include		<bsd43/sys/resource.h>
X#include		<bsd43/sys/ioctl.h>
X#include		<bsd43/sys/stat.h>
X#include		<bsd43/sys/file.h>
X#include		<bsd43/sys/socket.h>
X#include		<bsd43/sys/uio.h>
X#include		<bsd43/sys/wait.h>
X#include		<bsd43/sys/sysmips.h>
X#include		<bsd43/mips/hwconf.h>
X#define	NFSCLIENT
X#include		<bsd43/sys/mount.h>
X#undef	NFSCLIENT
X#include		<bsd43/rpc/types.h>
X#include		<bsd43/rpc/auth.h>
X#include		<bsd43/nfs/nfs.h>
X#include		<bsd43/netinet/in.h>
X#include		<bsd43/nfs/nfs_clnt.h>
X#include		<bsd43/nfs/export.h>
X#include		<bsd43/fcntl.h>
X#include		<bsd43/signal.h>
X#include		<fcntl.h>
X#include		<errno.h>
X#include		<stdio.h>
X#include		"register.h"
X#include		"symtab.h"
X#include		"diblock.h"
X#include		"instrn.h"
X#include		"process.h"
X#include		"sysentry.h"
X#include		"res.h"
X#include		"nels.h"
X#include		"flag.h"
X#include		"generic.h"
X
Xextern int		fd_lookup();
Xextern int		fd_open();
Xextern void		fd_dopen();
Xextern int		fd_close();
Xextern int		fd_sort();
Xextern void		histo_dump();
Xextern void		hist_dump();
Xextern char		*strdup();
Xextern int		bufset();
Xextern int		mstrlen();
Xextern int		mgetstring();
Xextern int		mgets();
Xextern char		**mgetvp();
Xextern int		mfreevp();
Xextern int		augment_execve_args();
Xextern int		mget();
Xextern int		mput();
Xextern void		say_time();
Xextern char		*proc_text_address();
Xextern char		*signal_set();
Xextern int		sysv_sys_ioctl();
X
Xextern FILE		*outfp;
Xextern int		errno;
X
Xextern int		Fflag;
X
Xextern unsigned long	arg[];
X
Xextern int		return_errno;	/* errno goes here. */
Xextern long		return_value0;	/* Result 1 value goes here. */
Xextern long		return_value1;	/* Result 2 value goes here. */
X
Xextern sysentry		*current_sysentp;
Xextern char		*sys_call_buf;	/* Scratch buf. */
X
Xstatic
Xint
Xsys_adjtime(syscallno)
Xint	syscallno;
X{
X	struct bsd43_timeval	tv;
X	struct bsd43_timeval	otv;
X
X	return generic_adjtime(syscallno, &tv, sizeof(tv), &otv, sizeof(otv));
X}
X
Xstatic
Xint
Xsys_dup2(syscallno)
Xint	syscallno;
X{
X	int	old_real_fd;
X
X	Rstart;
X	return_value0 = syscall(BSD43_SYS_dup, fd_lookup((int)arg[0]));
X	return_errno = errno;
X	Rstop;
X
X	if (return_value0 == -1)
X		return 0;
X
X	if ((old_real_fd = fd_lookup((int)arg[1])) != -1)
X	{
X		(void)close(old_real_fd);
X		(void)fd_close((int)arg[1]);
X	}
X
X	fd_dopen(return_value0, (int)arg[1]);
X
X	return_value0 = (int)arg[1];
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_execve(syscallno)
Xint	syscallno;
X{
X	char	*filename;
X	char	**argp;
X	char	**envp;
X	int	need_close_on_exec;
X
X	if (mgetstring(arg[0]) == -1)
X		return -1;
X
X	if ((filename = strdup(sys_call_buf)) == (char *)0)
X	{
X		vcouldnot("execve(): ran out of memory");
X		return -1;
X	}
X
X	if ((argp = mgetvp(arg[1])) == (char **)0)
X		return -1;
X
X	if ((envp = mgetvp(arg[2])) == (char **)0)
X		return -1;
X
X	if (fd_sort() == -1)
X		return -1;
X
X	if (Fflag)
X	{
X		int	mok;
X
X		if
X		(
X			syscall(BSD43_SYS_access, filename, BSD43_X_OK) != 0
X			||
X			(mok = magic_ok(filename)) == 0
X			||
X			(mok == 2 && interpreter_ok(filename) == 0)
X			||
X			is_a_shared_library(filename)
X		)
X		{
X			return_value0 = -1;
X			return_errno = errno;
X
X			if (mfreevp(envp) == -1)
X				return -1;
X
X			if (mfreevp(argp) == -1)
X				return -1;
X
X			(void)free(filename);
X
X			return 0;
X		}
X
X		if (augment_execve_args(&filename, &argp, &envp) == -1)
X		{
X			(void)mfreevp(envp);
X			(void)mfreevp(argp);
X			(void)free(filename);
X		}
X
X		need_close_on_exec = 0;
X	}
X	else
X	{
X		histo_dump();
X		hist_dump();
X
X		if (fcntl(fileno(outfp), F_SETFD, 1) == -1)
X		{
X			vcouldnot("fcntl(%d, F_SETFD, 1)", fileno(outfp));
X			return -1;
X		}
X
X		need_close_on_exec = 1;
X	}
X
X	Rstart;
X	return_value0 = syscall(syscallno, filename, argp, envp);
X	return_errno = errno;
X	Rstop;
X
X	if (need_close_on_exec)
X	{
X		if (fcntl(fileno(outfp), F_SETFD, 0) == -1)
X		{
X			vcouldnot("fcntl(%d, F_SETFD, 0)", fileno(outfp));
X			return -1;
X		}
X	}
X
X	if (mfreevp(envp) == -1)
X		return -1;
X
X	if (mfreevp(argp) == -1)
X		return -1;
X
X	(void)free(filename);
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_exportfs(syscallno)
Xint	syscallno;
X{
X	char		*dirnamep;
X	char		dirname[1024];
X	struct export	exent;
X	struct export	*exp;
X	int		first_length;
X	int		write_length;
X
X	if (mgets(arg[0], &dirnamep) == -1)
X		return -1;
X
X	if (dirnamep != (char *)0)
X	{
X		(void)strcpy(&dirname[0], dirnamep);
X		dirnamep = &dirname[0];
X	}
X
X	if (arg[1] == (unsigned long)0)
X		exp = (struct export *)0;
X	else
X	{
X		if (quiet_procmget(GLOBALdipc, (unsigned long)arg[1], &exent, sizeof(exent)) == -1)
X			return -1;
X
X		if (exent.ex_flags & EX_RDMOSTLY)
X		{
X			write_length = exent.ex_writeaddrs.naddrs * sizeof(struct bsd43_sockaddr);
X#if	0
Xfprintf(stderr, "writenaddrs = %d, write_length = %d\n", exent.ex_writeaddrs.naddrs, write_length);
X#endif	/* 0 */
X		}
X		else
X			write_length = 0;
X
X		switch (exent.ex_auth)
X		{
X		case AUTH_UNIX:
X			first_length = exent.ex_u.exunix.rootaddrs.naddrs * sizeof(struct bsd43_sockaddr);
X#if	0
Xfprintf(stderr, "rootnaddrs = %d, root_length = %d\n", exent.ex_u.exunix.rootaddrs.naddrs, first_length);
X#endif	/* 0 */
X
X			if (bufset((unsigned int)(first_length + write_length)) == -1)
X				return -1;
X
X			if (quiet_procmget(GLOBALdipc, (unsigned long)exent.ex_u.exunix.rootaddrs.addrvec, sys_call_buf, first_length) == -1)
X				return -1;
X
X			exent.ex_u.exunix.rootaddrs.addrvec = (struct sockaddr *)sys_call_buf;
X			break;
X
X		case AUTH_DES:
X			/*
X			 * No thanks -- I'll wait till I see it used.
X			 */
X			return -2;
X
X		default:
X			return -2;
X		}
X
X		if (exent.ex_flags & EX_RDMOSTLY)
X		{
X			if (quiet_procmget(GLOBALdipc, (unsigned long)exent.ex_writeaddrs.addrvec, sys_call_buf + first_length, write_length) == -1)
X				return -1;
X
X			exent.ex_writeaddrs.addrvec = (struct sockaddr *)(sys_call_buf + first_length);
X		}
X
X		exp = &exent;
X	}
X
X	Rstart;
X	return_value0 = syscall(syscallno, dirnamep, exp);
X	return_errno = errno;
X	Rstop;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_fcntl(syscallno)
Xint	syscallno;
X{
X	switch ((int)arg[1])
X	{
X	case BSD43_F_DUPFD:
X		Rstart;
X		return_value0 = syscall(BSD43_SYS_dup, fd_lookup((int)arg[0]));
X		return_errno = errno;
X		Rstop;
X
X		if (return_value0 != -1)
X		{
X			int	newfd;
X			int	nfiles;
X
X			for (nfiles = fd_nfiles(), newfd = (int)arg[2]; newfd < nfiles && fd_lookup(newfd) != -1; newfd++)
X				;
X
X			if (newfd >= nfiles)
X			{
X				(void)close(return_value0);
X				errno = EMFILE;
X				return 0;
X			}
X
X			fd_dopen(return_value0, newfd);
X
X			return_value0 = newfd;
X		}
X		break;
X
X	case BSD43_F_GETFD:
X	case BSD43_F_SETFD:
X	case BSD43_F_GETFL:
X	case BSD43_F_SETFL:
X	case BSD43_F_SETOWN:
X		Rstart;
X		return_value0 = syscall(syscallno, fd_lookup((int)arg[0]), (int)arg[1], (int)arg[2]);
X		return_errno = errno;
X		Rstop;
X		break;
X
X	default:
X		return -2;
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_fstat(syscallno)
Xint	syscallno;
X{
X	return generic_fstat(syscallno, sizeof(struct bsd43_stat));
X}
X
Xstatic
Xint
Xsys_fstatfs(syscallno)
Xint	syscallno;
X{
X	struct bsd43_statfs	*bufp;
X
X	if (dmget(arg[1], sizeof(*bufp), &bufp) == -1)
X		return -1;
X
X	Rstart;
X	return_value0 = syscall(syscallno, arg[0], bufp);
X	return_errno = errno;
X	Rstop;
X
X	if (mput(arg[1], bufp, sizeof(*bufp), return_value0) == -1)
X		return -1;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_getgid(syscallno)
Xint	syscallno;
X{
X	/*
X	 * TODO: second return value for BSD43 getgid().
X	 */
X	Rstart;
X	return_value0 = syscall(syscallno);
X	return_value1 = getegid();	/* Not really correct. */
X	return_errno = errno;
X	Rstop;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_getgroups(syscallno)
Xint	syscallno;
X{
X	return generic_getgroups(syscallno, BSD43_NGROUPS);
X}
X
Xstatic
Xint
Xsys_getitimer(syscallno)
Xint	syscallno;
X{
X	return generic_getitimer(syscallno, sizeof(struct bsd43_itimerval));
X}
X
Xstatic
Xint
Xsys_getpgrp(syscallno)
Xint	syscallno;
X{
X	Rstart;
X	return_value0 = syscall(syscallno, (int)arg[0]);
X	return_errno = errno;
X	Rstop;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_getrlimit(syscallno)
Xint	syscallno;
X{
X	return generic_getrlimit(syscallno, sizeof(struct bsd43_rlimit));
X}
X
Xstatic
Xint
Xsys_getrusage(syscallno)
Xint	syscallno;
X{
X	return generic_getrusage(syscallno, sizeof(struct bsd43_rusage));
X}
X
Xstatic
Xint
Xsys_gettimeofday(syscallno)
Xint	syscallno;
X{
X	struct bsd43_timeval	tv;
X	struct bsd43_timezone	tz;
X
X	return generic_gettimeofday(syscallno, &tv, sizeof(tv), &tz, sizeof(tz));
X}
X
Xstatic
Xint
Xsys_getuid(syscallno)
Xint	syscallno;
X{
X	/*
X	 * TODO: second return value for BSD43 getuid().
X	 */
X	Rstart;
X	return_value0 = syscall(syscallno);
X	return_value1 = geteuid();	/* Not really correct. */
X	return_errno = errno;
X	Rstop;
X
X	return 0;
X}
X
Xtypedef union bsd43_ifcu	bsd43_ifcu;
Xunion bsd43_ifcu
X{
X	caddr_t		ifcu_buf;
X	struct ifreq	*ifcu_req;
X};
X
Xtypedef struct bsd43_ifconf	bsd43_ifconf;
Xstruct bsd43_ifconf
X{
X	int		ifc_len;	/* size of associated buffer */
X	bsd43_ifcu	ifc_ifcu;
X};
X
X#define	ifconf	bsd43_ifconf
X
X/*
X * See /bsd43/usr/include/sys/ioctl.h.
X */
Xstatic
Xint
Xsys_ioctl(syscallno)
Xint	syscallno;
X{
X	int		length;
X	int		need_copy_in;
X	int		need_copy_out;
X	char		iocbuf[BSD43_IOCPARM_MASK];
X	bsd43_ifconf	*ifp;
X	caddr_t		saved_ifcu_buf;
X
X	if ((arg[1] & (unsigned long)(BSD43_IOC_INOUT | BSD43_IOC_VOID)) == 0)
X		return sysv_sys_ioctl();
X
X	need_copy_in = arg[1] & (unsigned long)BSD43_IOC_IN;
X	need_copy_out = arg[1] & (unsigned long)BSD43_IOC_OUT;
X	length = (arg[1] >> (unsigned long)16) & (unsigned long)BSD43_IOCPARM_MASK;
X
X	if (need_copy_in)
X	{
X		if (quiet_procmget(GLOBALdipc, (unsigned long)arg[2], &iocbuf[0], length) == -1)
X			return -1;
X	}
X
X	/*
X	 * Sadly, the bsd43 ioctl encoding scheme only handles
X	 * one level of indirection, so ...
X	 */
X	switch (arg[1])
X	{
X	case BSD43_SIOCGIFCONF:
X		/*
X		 * if(7)
X		 */
X		ifp = (bsd43_ifconf *)&iocbuf[0];
X
X		if (bufset((unsigned int)ifp->ifc_len) == -1)
X			return -1;
X
X		saved_ifcu_buf = ifp->ifc_ifcu.ifcu_buf;
X		ifp->ifc_ifcu.ifcu_buf = sys_call_buf;
X		break;
X	}
X
X	/*
X	 * TODO: But what about fd's hidden in ioctl() args?
X	 *       strioctl() calls, for example.
X	 */
X	Rstart;
X	return_value0 = syscall(syscallno, fd_lookup((int)arg[0]), (int)arg[1], &iocbuf[0]);
X	return_errno = errno;
X	Rstop;
X
X	if (return_value0 != -1 && need_copy_out)
X	{
X		switch (arg[1])
X		{
X		case BSD43_SIOCGIFCONF:
X			ifp = (bsd43_ifconf *)&iocbuf[0];
X
X			if (quiet_procmput(GLOBALdipc, (unsigned long)saved_ifcu_buf, sys_call_buf, ifp->ifc_len) == -1)
X				return -1;
X
X			ifp->ifc_ifcu.ifcu_buf = saved_ifcu_buf;
X			break;
X		}
X
X		if (quiet_procmput(GLOBALdipc, (unsigned long)arg[2], &iocbuf[0], length) == -1)
X			return -1;
X	}
X
X	return 0;
X}
X
X/*
X * Global entry point so that the sysv ioctl()
X * can call the bsd43 ioctl() when it finds that
X * it is really being called with bsd43 arguments
X * .. yes, this is fairly gross.
X */
Xint
Xbsd43_sys_ioctl()
X{
X	static int	ive_been_called_before;
X	int		result;
X
X	if (ive_been_called_before)
X		result = -2;
X	else
X	{
X		ive_been_called_before = 1;
X		result = sys_ioctl(BSD43_SYS_ioctl);
X	}
X
X	ive_been_called_before = 0;
X
X	return result;
X}
X
Xstatic
Xint
Xsys_lstat(syscallno)
Xint	syscallno;
X{
X	struct bsd43_stat	statb;
X
X	return generic_lstat(syscallno, &statb, sizeof(statb));
X}
X
Xstatic
Xint
Xsys_mount(syscallno)
Xint	syscallno;
X{
X	char				*typenamep;
X	char				typename[1024];
X	char				*dirnamep;
X	char				dirname[1024];
X	char				*normal_argsp;
X	char				normal_args[1024];
X	struct bsd43_nfs_args		nfsargs;
X	/*
X	 * Should be:
X
X	struct bsd43_sockaddr_in	sock;
X
X	 * but there doesn't seem to be such
X	 * a definition in any of the include
X	 * files I've looked through, so...
X	 */
X	struct sockaddr_in		sock;
X	fhandle_t			fh;
X	char				*data;
X	char				shostname[HOSTNAMESZ];
X	char				snetname[MAXNETNAMELEN + 1];
X
X	if (mgets(arg[0], &typenamep) == -1)
X		return -1;
X
X	if (typenamep != (char *)0)
X	{
X		(void)strcpy(&typename[0], typenamep);
X		typenamep = &typename[0];
X	}
X
X	if (mgets(arg[1], &dirnamep) == -1)
X		return -1;
X
X	if (dirnamep != (char *)0)
X	{
X		(void)strcpy(&dirname[0], dirnamep);
X		dirnamep = &dirname[0];
X	}
X
X	if
X	(
X		strcmp(&typename[0], "ffs") == 0
X		||
X		strcmp(&typename[0], "ufs") == 0
X		||
X		strcmp(&typename[0], "4.3") == 0
X	)
X	{
X		if (mgets(arg[3], &normal_argsp) == -1)
X			return -1;
X
X		if (normal_argsp != (char *)0)
X		{
X			(void)strcpy(&normal_args[0], normal_argsp);
X			normal_argsp = &normal_args[0];
X		}
X
X		data = normal_argsp;
X	}
X	else	/* "nfs" */
X	{
X		if (quiet_procmget(GLOBALdipc, (unsigned long)arg[3], &nfsargs, sizeof(nfsargs)) == -1)
X			return -1;
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)nfsargs.addr, &sock, sizeof(sock)) == -1)
X			return -1;
X
X		/*
X		 * This cast is wrong but see comment
X		 * above at start of this routine.
X		 */
X		*(char **)&nfsargs.addr = (char *)&sock;
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)nfsargs.fh, &fh, sizeof(fh)) == -1)
X			return -1;
X
X		nfsargs.fh = (caddr_t)&fh;
X
X		if (nfsargs.flags & BSD43_NFSMNT_HOSTNAME)
X		{
X			if (quiet_procmget(GLOBALdipc, (unsigned long)nfsargs.bsd43_hostname, &shostname[0], sizeof(shostname)) == -1)
X				return -1;
X
X			nfsargs.bsd43_hostname = &shostname[0];
X		}
X
X		if (nfsargs.flags & BSD43_NFSMNT_SECURE)
X		{
X			if (quiet_procmget(GLOBALdipc, (unsigned long)nfsargs.netname, &snetname[0], sizeof(snetname)) == -1)
X				return -1;
X
X			nfsargs.netname = &snetname[0];
X		}
X
X		data = (char *)&nfsargs;
X	}
X
X	Rstart;
X	return_value0 = syscall(syscallno, typenamep, dirnamep, (int)arg[2], (int)data);
X	return_errno = errno;
X	Rstop;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_pipe(syscallno)
Xint	syscallno;
X{
X	/*
X	 * TODO: do real bsd43 syscall for pipe()
X	 */
X	int	fds[2];
X
X	Rstart;
X	return_value0 = pipe(&fds[0]);
X	return_errno = errno;
X	Rstop;
X
X	if (return_value0 != -1)
X	{
X		return_value0 = fd_open(fds[0]);
X		return_value1 = fd_open(fds[1]);
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_readv(syscallno)
Xint	syscallno;
X{
X	struct bsd43_iovec	*saved_iov;
X	struct bsd43_iovec	*iov;
X	int			iovcnt;
X	int			i;
X
X	iovcnt = arg[2];
X
X	/*
X	 * Copy in the scatter/gather array.
X	 */
X	if ((struct bsd43_iovec *)arg[1] != (struct bsd43_iovec *)0)
X	{
X		if ((iov = (struct bsd43_iovec *)malloc(iovcnt * sizeof(*iov))) == (struct bsd43_iovec *)0)
X		{
X			vcouldnot("allocate buffer for scatter/gather vector of %d elements", iovcnt);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)arg[1], iov, (unsigned int)iovcnt * sizeof(*iov)) == -1)
X			return -1;
X
X		/*
X		 * Save a copy of the array.
X		 */
X		if ((saved_iov = (struct bsd43_iovec *)malloc(iovcnt * sizeof(*iov))) == (struct bsd43_iovec *)0)
X		{
X			vcouldnot("allocate buffer for saved scatter/gather vector of %d elements", iovcnt);
X			return -1;
X		}
X
X		(void)memcpy(saved_iov, iov, iovcnt * sizeof(*iov));
X
X		/*
X		 * Copy in each entry of the array.
X		 */
X		for (i = 0; i < iovcnt; i++)
X		{
X			struct bsd43_iovec	*liovp;
X
X			liovp = &iov[i];
X
X			if (liovp->iov_base != (caddr_t)0)
X			{
X				caddr_t	b;
X
X				if ((b = (caddr_t)malloc(liovp->iov_len)) == (caddr_t)0)
X				{
X					vcouldnot("allocate buffer for member of scatter/gather vector of %d bytes", liovp->iov_len);
X					return -1;
X				}
X
X				if (quiet_procmget(GLOBALdipc, (unsigned long)liovp->iov_base, b, (unsigned int)liovp->iov_len) == -1)
X					return -1;
X
X				liovp->iov_base = b;
X			}
X		}
X	}
X
X	Rstart;
X	return_value0 = syscall(syscallno, fd_lookup((int)arg[0]), iov, iovcnt);
X	return_errno = errno;
X	Rstop;
X
X	/*
X	 * Copy out fields to the user, free()'ing as we go.
X	 */
X
X	/*
X	 * Copy out the scatter/gather array.
X	 */
X	if ((struct bsd43_iovec *)(arg[1]) != (struct bsd43_iovec *)0)
X	{
X		/*
X		 * Copy out each entry of the array.
X		 */
X		for (i = 0; i < iovcnt; i++)
X		{
X			struct bsd43_iovec	*liovp;
X
X			liovp = &iov[i];
X
X			if (saved_iov[i].iov_base != (caddr_t)0)
X			{
X				if (quiet_procmput(GLOBALdipc, (unsigned long)saved_iov[i].iov_base, liovp->iov_base, (unsigned int)liovp->iov_len) == -1)
X					return -1;
X
X				(void)free(liovp->iov_base);
X			}
X		}
X
X		(void)free(saved_iov);
X
X		/*
X		 * Copy out the reconstructed array itself?
X		 */
X
X		(void)free(iov);
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_recvfrom(syscallno)
Xint	syscallno;
X{
X	struct bsd43_sockaddr	from;
X
X	return generic_recvfrom(syscallno, &from);
X}
X
Xstatic
Xint
Xsys_recvmsg(syscallno)
Xint	syscallno;
X{
X	struct bsd43_msghdr	local_msghdr;
X	struct bsd43_msghdr	saved_local_msghdr;
X	struct bsd43_iovec	*saved_msg_iov;
X
X	if (quiet_procmget(GLOBALdipc, (unsigned long)arg[1], &local_msghdr, sizeof(local_msghdr)) == -1)
X		return -1;
X
X	saved_local_msghdr = local_msghdr;
X
X	/*
X	 * Copy in the optional address.
X	 */
X	if (local_msghdr.msg_name != (caddr_t)0)
X	{
X		caddr_t	name;
X
X		if ((name = (caddr_t)malloc(local_msghdr.msg_namelen)) == (caddr_t)0)
X		{
X			vcouldnot("allocate buffer for msg_name of length %d bytes", local_msghdr.msg_namelen);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)local_msghdr.msg_name, name, (unsigned int)local_msghdr.msg_namelen) == -1)
X			return -1;
X
X		local_msghdr.msg_name = name;
X	}
X
X	/*
X	 * Copy in the scatter/gather array.
X	 */
X	if (local_msghdr.msg_iov != (struct bsd43_iovec *)0)
X	{
X		struct bsd43_iovec	*v;
X		int			i;
X
X		if ((v = (struct bsd43_iovec *)malloc(local_msghdr.msg_iovlen * sizeof(*v))) == (struct bsd43_iovec *)0)
X		{
X			vcouldnot("allocate buffer for scatter/gather vector of %d elements", local_msghdr.msg_iovlen);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)local_msghdr.msg_iov, v, (unsigned int)local_msghdr.msg_iovlen * sizeof(*v)) == -1)
X			return -1;
X
X		local_msghdr.msg_iov = v;
X
X		/*
X		 * Save a copy of the array.
X		 */
X		if ((saved_msg_iov = (struct bsd43_iovec *)malloc(local_msghdr.msg_iovlen * sizeof(*v))) == (struct bsd43_iovec *)0)
X		{
X			vcouldnot("allocate buffer for saved scatter/gather vector of %d elements", local_msghdr.msg_iovlen);
X			return -1;
X		}
X
X		(void)memcpy(saved_msg_iov, v, local_msghdr.msg_iovlen * sizeof(*v));
X
X		/*
X		 * Copy in each entry of the array.
X		 */
X		for (i = 0; i < local_msghdr.msg_iovlen; i++)
X		{
X			struct bsd43_iovec	*liovp;
X
X			liovp = &(local_msghdr.msg_iov[i]);
X
X			if (liovp->iov_base != (caddr_t)0)
X			{
X				caddr_t	b;
X
X				if ((b = (caddr_t)malloc(liovp->iov_len)) == (caddr_t)0)
X				{
X					vcouldnot("allocate buffer for member of scatter/gather vector of %d bytes", liovp->iov_len);
X					return -1;
X				}
X
X				if (quiet_procmget(GLOBALdipc, (unsigned long)liovp->iov_base, b, (unsigned int)liovp->iov_len) == -1)
X					return -1;
X
X				liovp->iov_base = b;
X			}
X		}
X	}
X
X	/*
X	 * Copy in the optional(?) access rights.
X	 */
X	if (local_msghdr.msg_accrights != (caddr_t)0)
X	{
X		caddr_t	a;
X
X		if ((a = (caddr_t)malloc(local_msghdr.msg_accrightslen)) == (caddr_t)0)
X		{
X			vcouldnot("allocate buffer for access rights of length %d bytes", local_msghdr.msg_accrightslen);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)local_msghdr.msg_accrights, a, (unsigned int)local_msghdr.msg_accrightslen) == -1)
X			return -1;
X
X		local_msghdr.msg_accrights = a;
X	}
X
X	Rstart;
X	return_value0 = syscall(syscallno, fd_lookup((int)arg[0]), &local_msghdr, (int)arg[2]);
X	return_errno = errno;
X	Rstop;
X
X	/*
X	 * Copy out fields to the user, free()'ing as we go.
X	 */
X
X	/*
X	 * Copy out the access rights.
X	 */
X	if (saved_local_msghdr.msg_accrights != (caddr_t)0)
X	{
X		if (quiet_procmput(GLOBALdipc, (unsigned long)saved_local_msghdr.msg_accrights, local_msghdr.msg_accrights, (unsigned int)local_msghdr.msg_accrightslen) == -1)
X			return -1;
X
X		(void)free((char *)local_msghdr.msg_accrights);
X	}
X
X	/*
X	 * Copy out the scatter/gather array.
X	 */
X	if (saved_local_msghdr.msg_iov != (struct bsd43_iovec *)0)
X	{
X		int	i;
X
X		/*
X		 * Copy out each entry of the array.
X		 */
X		for (i = 0; i < local_msghdr.msg_iovlen; i++)
X		{
X			struct bsd43_iovec	*liovp;
X
X			liovp = &(local_msghdr.msg_iov[i]);
X
X			if (saved_msg_iov[i].iov_base != (caddr_t)0)
X			{
X				if (quiet_procmput(GLOBALdipc, (unsigned long)saved_msg_iov[i].iov_base, liovp->iov_base, (unsigned int)liovp->iov_len) == -1)
X					return -1;
X				
X				(void)free(liovp->iov_base);
X			}
X		}
X
X		(void)free(saved_msg_iov);
X
X		/*
X		 * Copy out the reconstructed array itself?
X		 */
X
X		(void)free(local_msghdr.msg_iov);
X	}
X
X	/*
X	 * Copy out the received name and its length?
X	 */
X
X	(void)free(local_msghdr.msg_name);
X
X	return 0;
X}
X
X#define	select_dget(a,d,pp,m,nm)	\
X{ \
X	if (a == 0) \
X		pp = (struct bsd43_fd_set *)0; \
X	else \
X	{ \
X		struct bsd43_fd_set	tfds; \
X		int			fd; \
X \
X		if (quiet_procmget(GLOBALdipc, (unsigned long)a, &tfds, howmany(m, NFDBITS) * sizeof(bsd43_fd_mask)) == -1) \
X			return -1; \
X \
X		BSD43_FD_ZERO(&d); \
X \
X		for (fd = 0; fd < m; fd++) \
X		{ \
X			int	nfd; \
X \
X			if \
X			( \
X				BSD43_FD_ISSET(fd, &tfds) \
X				&& \
X				(nfd = fd_lookup(fd)) != -1 \
X			) \
X			{ \
X				BSD43_FD_SET(nfd, &d); \
X				if (nfd >= nm) \
X					nm = nfd + 1; \
X			} \
X		} \
X \
X		pp = &d; \
X	} \
X}
X
X#define	select_tget(a,d,p,t)	\
X{ \
X	if (a == 0) \
X		p = (t *)0; \
X	else \
X	{ \
X		if (quiet_procmget(GLOBALdipc, (unsigned long)a, &d, sizeof(d)) == -1) \
X			return -1; \
X \
X		p = &d; \
X	} \
X}
X
X#define	select_dput(a,pp,nn)	\
X{ \
X	if (a != 0) \
X	{ \
X		struct bsd43_fd_set	tfds; \
X		int			fd; \
X \
X		BSD43_FD_ZERO(&tfds); \
X \
X		for (fd = 0; fd < nn; fd++) \
X		{ \
X			int	nfd; \
X \
X			if \
X			( \
X				(nfd = fd_lookup(fd)) != -1 \
X				&& \
X				BSD43_FD_ISSET(nfd, pp) \
X			) \
X				BSD43_FD_SET(fd, &tfds); \
X		} \
X \
X		if (quiet_procmput(GLOBALdipc, (unsigned long)a, &tfds, howmany(nn, BSD43_NFDBITS) * sizeof(bsd43_fd_mask)) == -1) \
X			return -1; \
X	} \
X}
X
Xstatic
Xint
Xsys_select(syscallno)
Xint	syscallno;
X{
X	struct bsd43_fd_set	rfds;
X	struct bsd43_fd_set	*rfdsp;
X	struct bsd43_fd_set	wfds;
X	struct bsd43_fd_set	*wfdsp;
X	struct bsd43_fd_set	efds;
X	struct bsd43_fd_set	*efdsp;
X	struct bsd43_timeval	timeout;
X	struct bsd43_timeval	*timeoutp;
X	int			nfds;
X	int			newnfds;
X
X	nfds = (int)arg[0];
X	if (nfds > fd_nfiles())
X		nfds = fd_nfiles();
X	newnfds = 0;
X
X	select_dget(arg[1], rfds, rfdsp, nfds, newnfds);
X	select_dget(arg[2], wfds, wfdsp, nfds, newnfds);
X	select_dget(arg[3], efds, efdsp, nfds, newnfds);
X	select_tget(arg[4], timeout, timeoutp, struct bsd43_timeval);
X
X	Rstart;
X	return_value0 = syscall(syscallno, newnfds, rfdsp, wfdsp, efdsp, timeoutp);
X	return_errno = errno;
X	Rstop;
X
X	if (return_value0 != -1)
X	{
X		select_dput(arg[3], efdsp, nfds);
X		select_dput(arg[2], wfdsp, nfds);
X		select_dput(arg[1], rfdsp, nfds);
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_sendmsg(syscallno)
Xint	syscallno;
X{
X	struct bsd43_msghdr	local_msghdr;
X
X	if (quiet_procmget(GLOBALdipc, (unsigned long)arg[1], &local_msghdr, sizeof(local_msghdr)) == -1)
X		return -1;
X
X#if	0
Xfprintf(outfp, "local_msghdr.msg_name = 0x%x\n", local_msghdr.msg_name);
Xfprintf(outfp, "local_msghdr.msg_namelen = %d\n", local_msghdr.msg_namelen);
X#endif	/* 0 */
X
X	/*
X	 * Copy in the optional address.
X	 */
X	if (local_msghdr.msg_name != (caddr_t)0)
X	{
X		caddr_t	name;
X
X		if ((name = (caddr_t)malloc(local_msghdr.msg_namelen)) == (caddr_t)0)
X		{
X			vcouldnot("allocate buffer for msg_name of length %d bytes", local_msghdr.msg_namelen);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)local_msghdr.msg_name, name, (unsigned int)local_msghdr.msg_namelen) == -1)
X			return -1;
X
X		local_msghdr.msg_name = name;
X
X#if	0
X{
X	int	i;
X
X	fprintf(outfp, "msg_name =");
X	for (i = 0; i < local_msghdr.msg_namelen; i++)
X		fprintf(outfp, "%02x", local_msghdr.msg_name[i] & 0xFF);
X	fprintf(outfp, "\n");
X}
X#endif	/* 0 */
X	}
X
X#if	0
Xfprintf(outfp, "local_msghdr.msg_iov = 0x%x\n", local_msghdr.msg_iov);
Xfprintf(outfp, "local_msghdr.msg_iovlen = %d\n", local_msghdr.msg_iovlen);
X#endif	/* 0 */
X
X	/*
X	 * Copy in the scatter/gather array.
X	 */
X	if (local_msghdr.msg_iov != (struct bsd43_iovec *)0)
X	{
X		struct bsd43_iovec	*v;
X		int			i;
X
X		if ((v = (struct bsd43_iovec *)malloc(local_msghdr.msg_iovlen * sizeof(*v))) == (struct bsd43_iovec *)0)
X		{
X			vcouldnot("allocate buffer for scatter/gather vector of %d elements", local_msghdr.msg_iovlen);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)local_msghdr.msg_iov, v, (unsigned int)local_msghdr.msg_iovlen * sizeof(*v)) == -1)
X			return -1;
X
X		local_msghdr.msg_iov = v;
X
X		/*
X		 * Copy in each entry in the array.
X		 */
X		for (i = 0; i < local_msghdr.msg_iovlen; i++)
X		{
X			struct bsd43_iovec	*liovp;
X
X			liovp = &(local_msghdr.msg_iov[i]);
X
X#if	0
Xfprintf(outfp, "local_msghdr.msg_iov[%d].iov_base = 0x%x\n", i, liovp->iov_base);
Xfprintf(outfp, "local_msghdr.msg_iov[%d].iov_len = %d\n", i, liovp->iov_len);
X#endif	/* 0 */
X
X			if (liovp->iov_base != (caddr_t)0)
X			{
X				caddr_t	b;
X
X				if ((b = (caddr_t)malloc(liovp->iov_len)) == (caddr_t)0)
X				{
X					vcouldnot("allocate buffer for member of scatter/gather vector of %d bytes", liovp->iov_len);
X					return -1;
X				}
X
X				if (quiet_procmget(GLOBALdipc, (unsigned long)liovp->iov_base, b, (unsigned int)liovp->iov_len) == -1)
X					return -1;
X
X				liovp->iov_base = b;
X			}
X		}
X	}
X
X#if	0
Xfprintf(outfp, "local_msghdr.msg_accrights = %d\n", local_msghdr.msg_accrights);
Xfprintf(outfp, "local_msghdr.msg_accrightslen = %d\n", local_msghdr.msg_accrightslen);
X#endif	/* 0 */
X
X	/*
X	 * Copy in the optional(?) access rights.
X	 */
X	if (local_msghdr.msg_accrights != (caddr_t)0)
X	{
X		caddr_t	a;
X
X		if ((a = (caddr_t)malloc(local_msghdr.msg_accrightslen)) == (caddr_t)0)
X		{
X			vcouldnot("allocate buffer for access rights of length %d bytes", local_msghdr.msg_accrightslen);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)local_msghdr.msg_accrights, a, (unsigned int)local_msghdr.msg_accrightslen) == -1)
X			return -1;
X
X		local_msghdr.msg_accrights = a;
X	}
X
X	Rstart;
X	return_value0 = syscall(syscallno, fd_lookup((int)arg[0]), &local_msghdr, (int)arg[2]);
X	return_errno = errno;
X	Rstop;
X
X	/*
X	 * Should we copy out any of these fields to the user?
X	 * Assuming "no" until demonstrated otherwise.
X	 */
X
X	/*
X	 * Free up all the temporary space...
X	 */
X
X	if (local_msghdr.msg_accrights != (caddr_t)0)
X		(void)free((char *)local_msghdr.msg_accrights);
X
X	if (local_msghdr.msg_iov != (struct bsd43_iovec *)0)
X	{
X		int	i;
X
X		for (i = 0; i < local_msghdr.msg_iovlen; i++)
X		{
X			struct bsd43_iovec	*liovp;
X
X			liovp = &local_msghdr.msg_iov[i];
X
X			if (liovp->iov_base != (caddr_t)0)
X				(void)free((char *)liovp->iov_base);
X		}
X
X		(void)free((char *)local_msghdr.msg_iov);
X	}
X
X	if (local_msghdr.msg_name != (caddr_t)0)
X		(void)free((char *)local_msghdr.msg_name);
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_sendto(syscallno)
Xint	syscallno;
X{
X	struct bsd43_sockaddr	to;
X
X	return generic_sendto(syscallno, &to);
X}
X
Xstatic
Xint
Xsys_setitimer(syscallno)
Xint	syscallno;
X{
X	struct bsd43_itimerval	it;
X	struct bsd43_itimerval	oit;
X
X	return generic_setitimer(syscallno, &it, sizeof(it), &oit, sizeof(oit));
X}
X
Xstatic
Xint
Xsys_setpgrp(syscallno)
Xint	syscallno;
X{
X	Rstart;
X	return_value0 = syscall(syscallno, (int)arg[0], (int)arg[1]);
X	return_errno = errno;
X	Rstop;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_setrlimit(syscallno)
Xint	syscallno;
X{
X	return generic_setrlimit(syscallno, sizeof(struct bsd43_rlimit));
X}
X
Xstatic
Xint
Xsys_settimeofday(syscallno)
Xint	syscallno;
X{
X	struct bsd43_timeval	tv;
X	struct bsd43_timezone	tz;
X
X	return generic_settimeofday(syscallno, &tv, sizeof(tv), &tz, sizeof(tz));
X}
X
Xstatic
Xint
Xsys_sigblock(syscallno)
Xint	syscallno;
X{
X	/*
X	 * TODO - sys_sigblock().
X	 */
X	Rstart;
X	return_value0 = syscall(syscallno, (int)arg[0]);
X	return_errno = errno;
X	Rstop;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_sigpause(syscallno)
Xint	syscallno;
X{
X	/*
X	 * TODO - sys_sigpause().
X	 */
X	Rstart;
X	return_value0 = syscall(syscallno, (int)arg[0]);
X	return_errno = errno;
X	Rstop;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_sigreturn(syscallno)
Xint	syscallno;
X{
X	/*
X	 * TODO - sys_sigreturn().
X	 */
X	return_value0 = -1;
X	return_errno = EFAULT;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_sigsetmask(syscallno)
Xint	syscallno;
X{
X	/*
X	 * TODO - sys_sigsetmask().
X	 */
X	Rstart;
X	return_value0 = syscall(syscallno, (int)arg[0]);
X	return_errno = errno;
X	Rstop;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_sigstack(syscallno)
Xint	syscallno;
X{
X	/*
X	 * TODO - sys_sigstack().
X	 */
X	return_value0 = 0;
X	return_errno = errno;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_sigvec(syscallno)
Xint	syscallno;
X{
X	struct bsd43_sigvec	sv;
X	struct bsd43_sigvec	*svp;
X	struct bsd43_sigvec	osv;
X	struct bsd43_sigvec	*osvp;
X
X	if (mget(arg[1], &sv, sizeof(sv), &svp) == -1)
X		return -1;
X
X	if (mget(arg[2], &osv, sizeof(osv), &osvp) == -1)
X		return -1;
X
X	if
X	(
X		svp == (struct bsd43_sigvec *)0
X		||
X		sv.sv_handler == BSD43_SIG_DFL
X		||
X		sv.sv_handler == BSD43_SIG_IGN
X	)
X	{
X		Rstart;
X		return_value0 = syscall(syscallno, arg[0], svp, osvp);
X		return_errno = errno;
X		Rstop;
X	}
X	else
X	{
X		/*
X		 * TODO - rest of sys_sigvec().
X		 */
X		return_value0 = 0;
X		return_errno = errno;
X	}
X
X	if (mput(arg[2], osvp, sizeof(osv), return_value0) == -1)
X		return -1;
X
X	if (mput(arg[1], svp, sizeof(sv), return_value0) == -1)
X		return -1;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_stat(syscallno)
Xint	syscallno;
X{
X	struct bsd43_stat	statb;
X
X	return generic_stat(syscallno, &statb, sizeof(statb));
X}
X
Xstatic
Xint
Xsys_statfs(syscallno)
Xint	syscallno;
X{
X	char			*cp;
X	struct bsd43_statfs	buf;
X	struct bsd43_statfs	*bufp;
X
X	if (mgets(arg[0], &cp) == -1)
X		return -1;
X
X	if (mget(arg[1], &buf, sizeof(buf), &bufp) == -1)
X		return -1;
X
X	Rstart;
X	return_value0 = syscall(syscallno, cp, bufp);
X	return_errno = errno;
X	Rstop;
X
X	if (mput(arg[1], bufp, sizeof(buf), return_value0) == -1)
X		return -1;
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_sysmips(syscallno)
Xint	syscallno;
X{
X	struct bsd43_hw_config	*hwcp;
X	struct bsd43_rusage	*rusep;
X	union bsd43_wait	status;
X	union bsd43_wait	*statusp;
X
X	switch (arg[0])
X	{
X	case BSD43_MIPS_HWCONF:
X		if (dmget(arg[2], sizeof(*hwcp), &hwcp) == -1)
X			return -1;
X
X		Rstart;
X		return_value0 = syscall(syscallno, arg[0], arg[1], hwcp, arg[3]);
X		return_errno = errno;
X		Rstop;
X
X		if (dmput(arg[2], hwcp, sizeof(*hwcp), return_value0) == -1)
X			return -1;
X
X		break;
X
X	case BSD43_MIPS_GETRUSAGE:
X		if (dmget(arg[2], arg[3], &rusep) == -1)
X			return -1;
X
X		Rstart;
X		return_value0 = syscall(syscallno, arg[0], arg[1], rusep, arg[3]);
X		return_errno = errno;
X		Rstop;
X
X		if (dmput(arg[2], rusep, arg[3], return_value0) == -1)
X			return -1;
X
X		break;
X
X	case BSD43_MIPS_WAIT3:
X		if (mget(arg[1], &status, sizeof(status), &statusp) == -1)
X			return -1;
X
X		if (dmget(arg[3], arg[4], &rusep) == -1)
X			return -1;
X
X		Rstart;
X		return_value0 = syscall(syscallno, arg[0], statusp, arg[2], rusep, arg[4]);
X		return_errno = errno;
X		Rstop;
X
X		if (dmput(arg[3], rusep, arg[4], return_value0) == -1)
X			return -1;
X
X		if (mput(arg[1], statusp, sizeof(status), return_value0) == -1)
X			return -1;
X
X		break;
X
X	default:
X		return -2;
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_utimes(syscallno)
Xint	syscallno;
X{
X	struct bsd43_timeval	tv[2];
X
X	return generic_utimes(syscallno, &tv[0], sizeof(tv));
X}
X
Xstatic
Xint
Xsys_vfork(syscallno)
Xint	syscallno;
X{
X	int	parent_pid;
X
X	parent_pid = getpid();
X
X	/*
X	 * Not right for vfork() but close
X	 * enough for now.
X	 * Can't be a real vfork() here
X	 * because the child must be allowed to
X	 * return from this routine (aka stack frame).
X	 * So this will break programs
X	 * that rely on (e.g.) the shared memory
X	 * properties of vfork()...
X	 *
X	 * TODO -- proper vfork().
X	 */
X	errno = 0;
X	Rstart;
X	return_value0 = syscall(BSD43_SYS_fork);
X	return_errno = errno;
X	Rstop;
X
X	if ((P.p_pid = getpid()) != parent_pid)
X		return_value0 = 0;
X
X	switch (return_value0)
X	{
X	case -1:	/* error */
X		break;
X
X	case 0:		/* child */
X		return_value1 = 1;
X		break;
X
X	default:	/* parent */
X		return_value1 = 0;
X		break;
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_writev(syscallno)
Xint	syscallno;
X{
X	struct bsd43_iovec	*iov;
X	int			iovcnt;
X	int			i;
X
X	/*
X	 * Copy in the scatter/gather array.
X	 */
X	if ((struct bsd43_iovec *)arg[1] == (struct bsd43_iovec *)0)
X		iov = (struct bsd43_iovec *)0;
X	else
X	{
X		iovcnt = arg[2];
X
X		if ((iov = (struct bsd43_iovec *)malloc(iovcnt * sizeof(*iov))) == (struct bsd43_iovec *)0)
X		{
X			vcouldnot("allocate buffer for scatter/gather vector of %d elements", iovcnt);
X			return -1;
X		}
X
X		if (quiet_procmget(GLOBALdipc, (unsigned long)arg[1], iov, (unsigned int)iovcnt * sizeof(*iov)) == -1)
X			return -1;
X
X		/*
X		 * Copy in each entry in the array.
X		 */
X		for (i = 0; i < iovcnt; i++)
X		{
X			struct bsd43_iovec	*liovp;
X
X			liovp = &iov[i];
X
X			if (liovp->iov_base != (caddr_t)0)
X			{
X				caddr_t	b;
X
X				if ((b = (caddr_t)malloc(liovp->iov_len)) == (caddr_t)0)
X				{
X					vcouldnot("allocate buffer for member of scatter/gather vector of %d bytes", liovp->iov_len);
X					return -1;
X				}
X
X				if (quiet_procmget(GLOBALdipc, (unsigned long)liovp->iov_base, b, (unsigned int)liovp->iov_len) == -1)
X					return -1;
X
X				liovp->iov_base = b;
X			}
X		}
X	}
X
X	Rstart;
X	return_value0 = syscall(syscallno, fd_lookup((int)arg[0]), iov, iovcnt);
X	return_errno = errno;
X	Rstop;
X
X	/*
X	 * Should we copy out any of these fields to the user?
X	 * Assuming "no" until demonstrated otherwise.
X	 */
X
X	/*
X	 * Free up all the temporary space...
X	 */
X
X	if (iov != (struct bsd43_iovec *)0)
X	{
X		for (i = 0; i < iovcnt; i++)
X		{
X			struct bsd43_iovec	*liovp;
X
X			liovp = &iov[i];
X
X			if (liovp->iov_base != (caddr_t)0)
X				(void)free((char *)liovp->iov_base);
X		}
X
X		(void)free((char *)iov);
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsys_wait3(syscallno)
Xint	syscallno;
X{
X	union bsd43_wait	s;
X	struct bsd43_rusage	r;
X
X	return generic_wait3(syscallno, &s, sizeof(s), &r, sizeof(r));
X}
X
Xstatic sysentry	bsd43_systab[]	=
X{
X	{ "syscall",	0,	"d",	'd',	(int (*)())0,	},
X	{ "_exit",	1,	"d",	'e',	generic_exit,	},
X	{ "fork",	0,	"",	'Y',	generic_fork,	},
X	{ "read",	3,	"dRd",	'd',	generic_read,	},
X	{ "write",	3,	"dWd",	'd',	generic_write,	},
X	{ "open",	3,	"FOm",	'd',	generic_open,	},
X	{ "close",	1,	"d",	'd',	generic_close,	},
X	{ "Owait",	0,	"",	'\0',	(int (*)())0,	},
X	{ "creat",	2,	"Fm",	'd',	generic_creat, 	},
X	{ "link",	2,	"FF",	'd',	generic_link,	},
X
X	{ "unlink",	1,	"F",	'd',	generic_unlink,	},
X	{ "Oexecv",	0,	"",	'\0',	(int (*)())0,	},
X	{ "chdir",	1,	"F",	'd',	generic_chdir,	},
X	{ "Otime",	0,	"",	'\0',	(int (*)())0,	},
X	{ "mknod",	3,	"Fmx",	'd',	generic_mknod,	},
X	{ "chmod",	2,	"Fm",	'd',	generic_chmod,	},
X	{ "chown",	3,	"Fdd",	'd',	generic_chown,	},
X	{ "brk",	1,	"I",	'd',	generic_brk,	},
X	{ "Ostat",	0,	"",	'\0',	(int (*)())0,	},
X	{ "lseek",	3,	"duw",	'u',	generic_lseek, 	},
X
X	{ "getpid",	0,	"",	'd',	generic_getpid,	},
X	{ "Omount",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Oumount",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Osetuid",	0,	"",	'\0',	(int (*)())0,	},
X	{ "getuid",	0,	"",	'Y',	sys_getuid,	},
X	{ "Ostime",	0,	"",	'\0',	(int (*)())0,	},
X	{ "ptrace",	4,	"ddxd",	'd',	generic_ptrace,	},
X	{ "Oalarm",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Ofstat",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Opause",	0,	"",	'\0',	(int (*)())0,	},
X
X	{ "Outime",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Ostty",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Ogtty",	0,	"",	'\0',	(int (*)())0,	},
X	{ "access",	2,	"FP",	'd',	generic_access,	},
X	{ "Onice",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Oftime",	0,	"",	'\0',	(int (*)())0,	},
X	{ "sync",	0,	"",	'd',	generic_sync,	},
X	{ "kill",	2,	"dK",	'd',	generic_kill,	},
X	{ "stat",	2,	"FS",	'd',	sys_stat,	},
X	{ "Osetpgrp",	0,	"",	'\0',	(int (*)())0,	},
X
X	{ "lstat",	2,	"FS",	'd',	sys_lstat,	},
X	{ "dup",	1,	"d",	'd',	generic_dup,	},
X	{ "pipe",	0,	"",	'Y',	sys_pipe,	},
X	{ "Otimes",	0,	"",	'\0',	(int (*)())0,	},
X	{ "profil",	4,	"Iddd",	'd',	generic_profil,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "Osetgid",	0,	"",	'\0',	(int (*)())0,	},
X	{ "getgid",	0,	"",	'Y',	sys_getgid,	},
X	{ "Osigsys",	0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "acct",	1,	"F",	'd',	generic_acct,	},
X	{ "Ophys",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Osyslock",	0,	"",	'\0',	(int (*)())0,	},
X	{ "ioctl",	3,	"dCA",	'd',	sys_ioctl,	},
X	{ "reboot",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Ompxchan",	0,	"",	'\0',	(int (*)())0,	},
X	{ "symlink",	2,	"FF",	'd',	generic_symlink,	},
X	{ "readlink",	3,	"FRd",	'd',	generic_readlink,	},
X	{ "execve",	3,	"FlE",	'e',	sys_execve,	},
X
X	{ "umask",	1,	"x",	'x',	generic_umask,	},
X	{ "chroot",	1,	"F",	'd',	generic_chroot,	},
X	{ "fstat",	2,	"dS",	'd',	sys_fstat,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "getpagesize", 0,	"",	'd',	generic_getpagesize, },
X	{ "mremap",	0,	"",	'\0',	(int (*)())0,	},
X	{ "vfork",	0,	"",	'Y',	sys_vfork,	},
X	{ "Ovread",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Ovwrite",	0,	"",	'\0',	(int (*)())0,	},
X	{ "sbrk",	0,	"",	'\0',	(int (*)())0,	},
X
X	{ "sstk",	0,	"",	'\0',	(int (*)())0,	},
X	{ "mmap",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Ovadvise",	0,	"",	'\0',	(int (*)())0,	},
X	{ "munmap",	0,	"",	'\0',	(int (*)())0,	},
X	{ "mprotec",	0,	"",	'\0',	(int (*)())0,	},
X	{ "madvise",	0,	"",	'\0',	(int (*)())0,	},
X	{ "vhangup",	0,	"",	'd',	generic_vhangup,	},
X	{ "Ovlimit",	0,	"",	'\0',	(int (*)())0,	},
X	{ "mincore",	0,	"",	'\0',	(int (*)())0,	},
X	{ "getgroups",	2,	"dG",	'd',	sys_getgroups,	},
X
X	{ "setgroups",	2,	"dg",	'd',	generic_setgroups,	},
X	{ "getpgrp",	1,	"d",	'd',	sys_getpgrp,	},
X	{ "setpgrp",	2,	"dd",	'd',	sys_setpgrp,	},
X	{ "setitimer",	3,	"dVV",	'd',	sys_setitimer,	},
X	{ "wait3",	3,	"xxx",	'd',	sys_wait3,	},
X	{ "swapon",	0,	"",	'\0',	(int (*)())0,	},
X	{ "getitimer",	2,	"dV",	'd',	sys_getitimer,	},
X	{ "gethostname", 2,	"xd",	'd',	generic_gethostname, },
X	{ "sethostname", 0,	"",	'\0',	(int (*)())0,	},
X	{ "getdtablesize", 0,	"",	'd',	generic_getdtablesize, },
X
X	{ "dup2",	2,	"dd",	'd',	sys_dup2,	},
X	{ "getdopt",	0,	"",	'\0',	(int (*)())0,	},
X	{ "fcntl",	3,	"dBH",	'd',	sys_fcntl,	},
X	{ "select",	5,	"dDDDT", 'd',	sys_select,	},
X	{ "setdopt",	0,	"",	'\0',	(int (*)())0,	},
X	{ "fsync",	1,	"d",	'd',	generic_fsync,	},
X	{ "setpriority", 3,	"ddd",	'd',	generic_setpriority, },
X	{ "socket",	3,	"abc",	'd',	generic_socket,	},
X	{ "connect",	3,	"dLd",	'd',	generic_connect,	},
X	{ "accept",	3,	"dLU",	'd',	generic_accept,	},
X
X	{ "getpriority", 2,	"dd",	'd',	generic_getpriority, },
X	{ "send",	4,	"dWdN",	'd',	generic_send,	},
X	{ "recv",	4,	"dRdN",	'd',	generic_recv,	},
X	{ "sigreturn",	1,	"I",	'd',	sys_sigreturn,	},
X	{ "bind",	3,	"dLd",	'd',	generic_bind,	},
X	{ "setsockopt", 5,	"dddpd", 'd',	generic_setsockopt, },
X	{ "listen",	2,	"dd",	'd',	generic_listen,	},
X	{ "Ovtimes",	0,	"",	'\0',	(int (*)())0,	},
X	{ "sigvec",	3,	"Kff",	'd',	sys_sigvec,	},
X	{ "sigblock",	1,	"M",	'M',	sys_sigblock,	},
X
X	{ "sigsetmask", 1,	"M",	'M',	sys_sigsetmask, },
X	{ "sigpause",	1,	"K",	'd',	sys_sigpause,	},
X	{ "sigstack",	2,	"II",	'd',	sys_sigstack,	},
X	{ "recvmsg",	3,	"dpN",	'd',	sys_recvmsg,	},
X	{ "sendmsg",	3,	"dpN",	'd',	sys_sendmsg,	},
X	{ "Ovtrace",	0,	"",	'\0',	(int (*)())0,	},
X	{ "gettimeofday", 2,	"TZ",	'd',	sys_gettimeofday, },
X	{ "getrusage",	2,	"dx",	'd',	sys_getrusage,	},
X	{ "getsockopt", 5,	"dddxU", 'd',	generic_getsockopt,	},
X	{ "Oresuba",	0,	"",	'\0',	(int (*)())0,	},
X
X	{ "readv",	3,	"dpd",	'd',	sys_readv,	},
X	{ "writev",	3,	"dpd",	'd',	sys_writev,	},
X	{ "settimeofday", 2,	"TZ",	'd',	sys_settimeofday, },
X	{ "fchown",	3,	"ddd",	'd',	generic_fchown,	},
X	{ "fchmod",	2,	"dm",	'd',	generic_fchmod,	},
X	{ "recvfrom",	6,	"dRdNLU", 'd',	sys_recvfrom,	},
X	{ "setreuid",	2,	"dd",	'd',	generic_setreuid,	},
X	{ "setregid",	2,	"dd",	'd',	generic_setregid,	},
X	{ "rename",	2,	"FF",	'd',	generic_rename,	},
X	{ "truncate",	2,	"Fu",	'd',	generic_truncate,	},
X
X	{ "ftruncate",	2,	"du",	'd',	generic_ftruncate,	},
X	{ "flock",	2,	"dd",	'd',	generic_flock,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "sendto",	6,	"dWdNLd", 'd',	sys_sendto,	},
X	{ "shutdown",	2,	"dd",	'd',	generic_shutdown,	},
X	{ "socketpair", 4,	"abcQ",	'd',	generic_socketpair,	},
X	{ "mkdir",	2,	"Fm",	'd',	generic_mkdir,	},
X	{ "rmdir",	1,	"F",	'd',	generic_rmdir,	},
X	{ "utimes",	2,	"FV",	'd',	sys_utimes,	},
X	{ "sigcleanup", 0,	"",	'\0',	(int (*)())0,	},
X
X	{ "adjtime",	2,	"TT",	'd',	sys_adjtime,	},
X	{ "getpeername", 3,	"dLU",	'd',	generic_getpeername, },
X	{ "gethostid",	0,	"",	'u',	generic_gethostid,	},
X	{ "sethostid",	1,	"u",	'd',	generic_sethostid,	},
X	{ "getrlimit",	2,	"dx",	'd',	sys_getrlimit,	},
X	{ "setrlimit",	2,	"dx",	'd',	sys_setrlimit,	},
X	{ "killpg",	2,	"dK",	'd',	generic_killpg,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "Osetquota",	0,	"",	'\0',	(int (*)())0,	},
X	{ "Oquota",	0,	"",	'\0',	(int (*)())0,	},
X
X	{ "getsockname", 3,	"dLU",	'd',	generic_getsockname, },
X	{ "sysmips",	4,	"dxxx",	'd',	sys_sysmips,	},
X	{ "cacheflush", 3,	"Idd",	'd',	generic_cacheflush,	},
X	{ "cachectl",	3,	"Idd",	'd',	generic_cachectl,	},
X	{ "debug",	0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "",		0,	"",	'\0',	(int (*)())0,	},
X	{ "Onfs_mount",	0,	"",	'\0',	(int (*)())0,	},
X	{ "nfssvc",	1,	"d",	'd',	generic_nfssvc,	},
X	{ "getdirentries", 4,	"dRdU",	'd',	generic_getdirentries, },
X
X	{ "statfs",	2,	"FX",	'd',	sys_statfs,	},
X	{ "fstatfs",	2,	"dX",	'd',	sys_fstatfs,	},
X	{ "unmount",	1,	"F",	'd',	generic_unmount,	},
X	{ "async_daemon", 0,	"",	'd',	generic_async_daemon, },
X	{ "getfh",	0,	"",	'\0',	(int (*)())0,	},
X	{ "getdomainname", 2,	"xd",	'd',	generic_getdomainname, },
X	{ "setdomainname", 2,	"xd",	'd',	generic_setdomainname, },
X	{ "Opcfs_mount", 0,	"",	'\0',	(int (*)())0,	},
X	{ "quotactl",	0,	"",	'\0',	(int (*)())0,	},
X	{ "old_exportfs", 0,	"",	'\0',	(int (*)())0,	},
X
X	{ "mount",	4,	"FFxp",	'd',	sys_mount,	},
X	{ "hdwconf",	0,	"",	'\0',	(int (*)())0,	},
X	{ "exportfs",	2,	"Fp",	'd',	sys_exportfs,	},
X	{ "nfsfh_open", 0,	"",	'\0',	(int (*)())0,	},
X	{ "libattach",	0,	"",	'\0',	(int (*)())0,	},
X	{ "libdetach",	0,	"",	'\0',	(int (*)())0,	},
X};
X
Xsysentry	*
Xbsd43_systab_entry(n)
Xint	n;
X{
X	if (n >= 0 && n < nels(bsd43_systab))
X		return &bsd43_systab[n];
X
X	return (sysentry *)0;
X}
X
Xint
Xbsd43_print_open_flags(arg)
Xlong	arg;
X{
X	need_leading_pipe = 0;
X
X	if ((arg & (BSD43_O_WRONLY | BSD43_O_RDWR)) == 0)
X	{
X		say_flag(BSD43_O_RDONLY, "O_RDONLY", arg);
X	}
X	else
X	{
X		say_flag(BSD43_O_WRONLY, "O_WRONLY", arg);
X		say_flag(BSD43_O_RDWR, "O_RDWR", arg);
X	}
X
X	say_flag(BSD43_O_APPEND, "O_APPEND", arg);
X	say_flag(BSD43_O_CREAT, "O_CREAT", arg);
X	say_flag(BSD43_O_EXCL, "O_EXCL", arg);
X	say_flag(BSD43_O_NDELAY, "O_NDELAY", arg);
X	say_flag(BSD43_O_TRUNC, "O_TRUNC", arg);
X
X	say_residual(arg);
X
X	return 0;
X}
X
Xint
Xbsd43_print_stat(arg)
Xlong	arg;
X{
X	struct bsd43_stat	statbuf;
X
X	if (quiet_procmget(GLOBALdipc, (unsigned long)arg, (char *)&statbuf, sizeof(statbuf)) == -1)
X		return -1;
X
X	fprintf(outfp, "{" /* } */ );
X	fprintf(outfp, "st_dev=0x%x,", statbuf.st_dev);
X	fprintf(outfp, " st_ino=%d,", statbuf.st_ino);
X	fprintf(outfp, " st_mode=0x%x,", statbuf.st_mode);
X	fprintf(outfp, " st_nlink=%d,", statbuf.st_nlink);
X	fprintf(outfp, " st_uid=%d,", statbuf.st_uid);
X	fprintf(outfp, " st_gid=%d,", statbuf.st_gid);
X	fprintf(outfp, " st_rdev=0x%x,", statbuf.st_rdev);
X	fprintf(outfp, " st_size=%d,", statbuf.st_size);
X	fprintf(outfp, " st_atime=");
X	say_time(outfp, statbuf.st_atime);
X	fprintf(outfp, ",");
X	fprintf(outfp, " st_mtime=");
X	say_time(outfp, statbuf.st_mtime);
X	fprintf(outfp, ",");
X	fprintf(outfp, " st_ctime=");
X	say_time(outfp, statbuf.st_ctime);
X	fprintf(outfp, ",");
X	fprintf(outfp, " st_blksize=%d,", statbuf.st_blksize);
X	fprintf(outfp, " st_blocks=%d,", statbuf.st_blocks);
X	fprintf(outfp, /* { */ "}");
X
X	return 0;
X}
X
Xint
Xbsd43_print_ioctl_cmd(cmd)
Xunsigned long	cmd;
X{
X	switch (cmd)
X	{
X	case BSD43_TIOCGETP:
X		fprintf(outfp, "TIOCGETP");
X		break;
X
X	case BSD43_TIOCSETP:
X		fprintf(outfp, "TIOCSETP");
X		break;
X
X	case BSD43_TIOCSETN:
X		fprintf(outfp, "TIOCSETN");
X		break;
X
X	case BSD43_TIOCGWINSZ:
X		fprintf(outfp, "TIOCGWINSZ");
X		break;
X
X	case BSD43_TIOCLGET:
X		fprintf(outfp, "TIOCLGET");
X		break;
X
X	case BSD43_TIOCLSET:
X		fprintf(outfp, "TIOCLSET");
X		break;
X
X	case BSD43_TIOCGETC:
X		fprintf(outfp, "TIOCGETC");
X		break;
X
X	case BSD43_TIOCSETC:
X		fprintf(outfp, "TIOCSETC");
X		break;
X
X	case BSD43_TIOCGLTC:
X		fprintf(outfp, "TIOCGLTC");
X		break;
X
X	case BSD43_TIOCSLTC:
X		fprintf(outfp, "TIOCSLTC");
X		break;
X
X	case BSD43_FIONBIO:
X		fprintf(outfp, "FIONBIO");
X		break;
X
X	case BSD43_TIOCGPGRP:
X		fprintf(outfp, "TIOCGPGRP");
X		break;
X
X	default:
X		fprintf(outfp, "0x%x", cmd);
X		break;
X	}
X
X	return 0;
X}
X
Xstatic
Xint
Xsay_sgttyb(arg)
Xunsigned long	arg;
X{
X	struct bsd43_sgttyb	sgb;
X
X	if (quiet_procmget(GLOBALdipc, arg, (char *)&sgb, sizeof(sgb)) == -1)
X		return -1;
X
X	fprintf
X	(
X		outfp,
X		"{sg_ispeed=%d, sg_ospeed=%d, sg_erase=0x%02x, sg_kill=0x%02x, sg_flags=",
X		sgb.sg_ispeed & 0xFF,
X		sgb.sg_ospeed & 0xFF,
X		sgb.sg_erase & 0xFF,
X		sgb.sg_kill & 0xFF
X	);
X
X	need_leading_pipe = 0;
X
X	say_notflag(BSD43_BSDELAY, "BS0", sgb.sg_flags);
X	say_flag(BSD43_BS1, "BS1", sgb.sg_flags);
X	say_notflag(BSD43_VTDELAY, "FF0", sgb.sg_flags);
X	say_flag(BSD43_FF1, "FF1", sgb.sg_flags);
X	say_notflag(BSD43_CRDELAY, "CR0", sgb.sg_flags);
X	say_flag(BSD43_CR3, "CR3", sgb.sg_flags);
X	say_flag(BSD43_CR2, "CR2", sgb.sg_flags);
X	say_flag(BSD43_CR1, "CR1", sgb.sg_flags);
X	say_notflag(BSD43_TBDELAY, "TAB0", sgb.sg_flags);
X	say_flag(BSD43_XTABS, "XTABS", sgb.sg_flags);
X	say_flag(BSD43_TAB2, "TAB2", sgb.sg_flags);
X	say_flag(BSD43_TAB1, "TAB1", sgb.sg_flags);
X	say_notflag(BSD43_NLDELAY, "NL0", sgb.sg_flags);
X	say_flag(BSD43_NL3, "NL3", sgb.sg_flags);
X	say_flag(BSD43_NL2, "NL2", sgb.sg_flags);
X	say_flag(BSD43_NL1, "NL1", sgb.sg_flags);
X
X	say_flag(BSD43_EVENP, "EVENP", sgb.sg_flags);
X	say_flag(BSD43_ODDP, "ODDP", sgb.sg_flags);
X	say_flag(BSD43_RAW, "RAW", sgb.sg_flags);
X	say_flag(BSD43_CRMOD, "CRMOD", sgb.sg_flags);
X	say_flag(BSD43_ECHO, "ECHO", sgb.sg_flags);
X	say_flag(BSD43_LCASE, "LCASE", sgb.sg_flags);
X	say_flag(BSD43_CBREAK, "CBREAK", sgb.sg_flags);
X	say_flag(BSD43_TANDEM, "TANDEM", sgb.sg_flags);
X
X	fprintf(outfp, "}");
X
X	return 0;
X}
X
Xstatic
Xint
Xsay_lmword(arg)
Xunsigned long	arg;
X{
X	int	local_mode_word;
X
X	if (quiet_procmget(GLOBALdipc, arg, (char *)&local_mode_word, sizeof(local_mode_word)) == -1)
X		return -1;
X
X	need_leading_pipe = 0;
X
X	say_flag(BSD43_LCRTBS, "LCRTBS", local_mode_word);
X	say_flag(BSD43_LPRTERA, "LPRTERA", local_mode_word);
X	say_flag(BSD43_LCRTERA, "LCRTERA", local_mode_word);
X	say_flag(BSD43_LTILDE, "LTILDE", local_mode_word);
X	say_flag(BSD43_LMDMBUF, "LMDMBUF", local_mode_word);
X	say_flag(BSD43_LLITOUT, "LLITOUT", local_mode_word);
X	say_flag(BSD43_LTOSTOP, "LTOSTOP", local_mode_word);
X	say_flag(BSD43_LFLUSHO, "LFLUSHO", local_mode_word);
X	say_flag(BSD43_LNOHANG, "LNOHANG", local_mode_word);
X#ifndef	BSD43_LETXACK
X#ifndef	BSD43_ETXACK
X#define	BSD43_ETXACK	(BSD43_L001000 >> 16)
X#endif	/* BSD43_ETXACK */
X#define	BSD43_LETXACK	(BSD43_ETXACK >> 16)
X#endif	/* BSD43_LETXACK */
X	say_flag(BSD43_LETXACK, "LETXACK", local_mode_word);
X	say_flag(BSD43_LCRTKIL, "LCRTKIL", local_mode_word);
X	say_flag(BSD43_LPASS8, "LPASS8", local_mode_word);
X	say_flag(BSD43_LCTLECH, "LCTLECH", local_mode_word);
X	say_flag(BSD43_LPENDIN, "LPENDIN", local_mode_word);
X	say_flag(BSD43_LDECCTQ, "LDECCTQ", local_mode_word);
X	say_flag(BSD43_LNOFLSH, "LNOFLSH", local_mode_word);
X
X	say_residual(local_mode_word);
X
X	return 0;
X}
X
Xstatic
Xint
Xsay_ltc(arg)
Xunsigned long	arg;
X{
X	struct bsd43_tchars	tcs;
X
X	if (quiet_procmget(GLOBALdipc, arg, (char *)&tcs, sizeof(tcs)) == -1)
X		return -1;
X
X	fprintf(outfp, "{");
X	fprintf(outfp, "t_intrc=0x%02x, ", tcs.t_intrc);
X	fprintf(outfp, "t_quitc=0x%02x, ", tcs.t_quitc);
X	fprintf(outfp, "t_startc=0x%02x, ", tcs.t_startc);
X	fprintf(outfp, "t_stopc=0x%02x, ", tcs.t_stopc);
X	fprintf(outfp, "t_eofc=0x%02x, ", tcs.t_eofc);
X	fprintf(outfp, "t_brkc=0x%02x, ", tcs.t_brkc);
X	fprintf(outfp, "}");
X
X	return 0;
X}
X
Xstatic
Xint
Xsay_sltc(arg)
Xunsigned long	arg;
X{
X	struct bsd43_ltchars	ltcs;
X
X	if (quiet_procmget(GLOBALdipc, arg, (char *)&ltcs, sizeof(ltcs)) == -1)
X		return -1;
X
X	fprintf(outfp, "{");
X	fprintf(outfp, "t_suspc=0x%02x, ", ltcs.t_suspc);
X	fprintf(outfp, "t_dsuspc=0x%02x, ", ltcs.t_dsuspc);
X	fprintf(outfp, "t_rprntc=0x%02x, ", ltcs.t_rprntc);
X	fprintf(outfp, "t_flushc=0x%02x, ", ltcs.t_flushc);
X	fprintf(outfp, "t_werasc=0x%02x, ", ltcs.t_werasc);
X	fprintf(outfp, "t_lnextc=0x%02x, ", ltcs.t_lnextc);
X	fprintf(outfp, "}");
X
X	return 0;
X}
X
Xstatic
Xint
Xsay_int(arg)
Xunsigned long	arg;
X{
X	int	i;
X
X	if (quiet_procmget(GLOBALdipc, arg, (char *)&i, sizeof(i)) == -1)
X		return -1;
X
X	fprintf(outfp, "{");
X	fprintf(outfp, "i=%d", i);
X	fprintf(outfp, "}");
X
X	return 0;
X}
X
Xstatic
Xint
Xsay_winsize(arg)
Xunsigned long	arg;
X{
X	struct bsd43_winsize	w;
X
X	if (quiet_procmget(GLOBALdipc, arg, (char *)&w, sizeof(w)) == -1)
X		return -1;
X
X	fprintf(outfp, "{");
X	fprintf(outfp, "row=%d,", w.ws_row);
X	fprintf(outfp, "col=%d,", w.ws_col);
X	fprintf(outfp, "xpixel=%d,", w.ws_xpixel);
X	fprintf(outfp, "ypixel=%d,", w.ws_ypixel);
X	fprintf(outfp, "}");
X
X	return 0;
X}
X
Xint
Xbsd43_print_ioctl_arg(args)
Xunsigned long	*args;
X{
X	switch (args[1])
X	{
X	case BSD43_TIOCGETP:
X	case BSD43_TIOCSETN:
X	case BSD43_TIOCSETP:
X		if (say_sgttyb(args[2]) == -1)
X			return -1;
X		break;
X
X	case BSD43_TIOCLGET:
X	case BSD43_TIOCLSET:
X		if (say_lmword(args[2]) == -1)
X			return -1;
X		break;
X
X	case BSD43_TIOCGETC:
X	case BSD43_TIOCSETC:
X		if (say_ltc(args[2]) == -1)
X			return -1;
X		break;
X
X	case BSD43_TIOCGLTC:
X	case BSD43_TIOCSLTC:
X		if (say_sltc(args[2]) == -1)
X			return -1;
X		break;
X
X	case BSD43_FIONBIO:
X	case BSD43_TIOCGPGRP:
X		if (say_int(args[2]) == -1)
X			return -1;
X		break;
X
X	case BSD43_TIOCGWINSZ:
X		if (say_winsize(args[2]) == -1)
X			return -1;
X		break;
X
X	default:
X		fprintf(outfp, "0x%x", args[2]);
X		break;
X	}
X
X	return 0;
X}
X
Xint
Xbsd43_print_fdset(nfds, arg)
Xint		nfds;
Xunsigned long	arg;
X{
X	if (arg == (unsigned long)0)
X		fprintf(outfp, "0x%x", arg);
X	else
X	{
X		struct bsd43_fd_set	tfds;
X		int			fd;
X
X		if (quiet_procmget(GLOBALdipc, arg, &tfds, sizeof(tfds)) == -1)
X			return -1;
X
X		fprintf(outfp, "{");
X
X		for (fd = 0; fd < nfds; fd++)
X		{
X			if (BSD43_FD_ISSET(fd, &tfds))
X				fprintf(outfp, "%d,", fd);
X		}
X
X		fprintf(outfp, "}");
X	}
X
X	return 0;
X}
X
Xint
Xbsd43_print_whence(arg)
Xunsigned long	arg;
X{
X	switch (arg)
X	{
X	case BSD43_L_SET:
X		fprintf(outfp, "L_SET");
X		break;
X
X	case BSD43_L_INCR:
X		fprintf(outfp, "L_INCR");
X		break;
X
X	case BSD43_L_XTND:
X		fprintf(outfp, "L_XTND");
X		break;
X
X	default:
X		fprintf(outfp, "0x%x", arg);
X		break;
X	}
X
X	return 0;
X}
X
Xint
Xbsd43_print_statfs(arg)
Xunsigned long	arg;
X{
X	if (arg == (unsigned long)0)
X		fprintf(outfp, "0x%x", arg);
X	else
X	{
X		struct bsd43_statfs	t;
X
X		if (quiet_procmget(GLOBALdipc, arg, &t, sizeof(t)) == -1)
X			return -1;
X
X		fprintf(outfp, "{");
X		fprintf(outfp, "type=%d,", t.f_type);
X		fprintf(outfp, "bsize=%d,", t.f_bsize);
X		fprintf(outfp, "blocks=%d,", t.f_blocks);
X		fprintf(outfp, "bfree=%d,", t.f_bfree);
X		fprintf(outfp, "bavail=%d,", t.f_bavail);
X		fprintf(outfp, "files=%d,", t.f_files);
X		fprintf(outfp, "ffree=%d,", t.f_ffree);
X		fprintf(outfp, "fsid.val[0]=%d,", t.f_fsid.val[0]);
X		fprintf(outfp, "fsid.val[1]=%d,", t.f_fsid.val[1]);
X		fprintf(outfp, "}");
X	}
X	return 0;
X}
X
Xint
Xbsd43_print_sigvec(arg)
Xunsigned long	arg;
X{
X	if (arg == (unsigned long)0)
X		fprintf(outfp, "0x%x", arg);
X	else
X	{
X		struct bsd43_sigvec	t;
X
X		if (quiet_procmget(GLOBALdipc, arg, &t, sizeof(t)) == -1)
X			return -1;
X
X		fprintf(outfp, "{");
X
X		fprintf(outfp, "handler=");
X		switch ((int)t.sv_handler)
X		{
X		case BSD43_BADSIG:
X			fprintf(outfp, "BADSIG");
X			break;
X
X		case BSD43_SIG_DFL:
X			fprintf(outfp, "SIG_DFL");
X			break;
X
X		case BSD43_SIG_IGN:
X			fprintf(outfp, "SIG_IGN");
X			break;
X
X		default:
X			fprintf(outfp, "%s", proc_text_address(t.sv_handler));
X			break;
X		}
X		fprintf(outfp, ",");
X
X		fprintf(outfp, "mask=%s,", signal_set(t.sv_mask));
X		fprintf(outfp, "flags={");
X		need_leading_pipe = 0;
X		say_flag(BSD43_SV_ONSTACK, "SV_ONSTACK", t.sv_flags);
X		say_flag(BSD43_SV_INTERRUPT, "SV_INTERRUPT", t.sv_flags);
X		say_residual(t.sv_flags);
X		fprintf(outfp, "}");
X		fprintf(outfp, "}");
X	}
X	return 0;
X}
X
Xvoid
Xbsd43_print_sigcontext(outfp, p)
XFILE		*outfp;
Xunsigned long	p;
X{
X	fprintf(outfp, "0x%x");
X}
END_OF_FILE
if test 51326 -ne `wc -c <'bsd43.c'`; then
    echo shar: \"'bsd43.c'\" unpacked with wrong size!
fi
# end of 'bsd43.c'
fi
echo shar: End of archive 7 \(of 8\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
