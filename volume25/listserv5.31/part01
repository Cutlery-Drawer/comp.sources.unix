Subject: v25i035: listserv5.31 - mailing list management system, Part01/06
Newsgroups: comp.sources.unix
Approved: vixie@pa.dec.com

Submitted-By: tasos@cs.bu.edu
Posting-Number: Volume 25, Issue 35
Archive-Name: listserv5.31/part01

This is a system that implements  various  discussion  lists
with  one  list server. It is automated, and obliterates the
need for  user  intervention  and  maintenance  of  multiple
aliases  of  the form "list, list-owner, list-request", etc.
There is support provided  for  archives,  moderated  lists,
peer lists, news connections and gateways, and mail queuing.

[ Essentially, this is bunch of tools that lets people subscribe,
  unsubscribe, and get various info about mailing lists automatically.  The
  tools take incoming mail for the list(s) and distribute them to the
  active subscribers.  It also provides an interface (via mail) for archives,
  allowing remote users to list and retreive things from the archive.

  The main hook for the system is through the machine's aliases file.  All
  incoming mail is dumped into a queue for the various lists, and then
  the tools that he provide process the queues.

  I think that this is a pretty useful system.  It would be neat if it
  gained wide-spread usage.					--Nick ]

[ I am sad to see that the man pages are not in source form; this practice
  is hereby discouraged in all future postings.                 --vix ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 6)."
# Contents:  .awk .grep .ignored .stats MANIFEST archives
#   archives/listserv archives/listserv/DIR archives/listserv/INDEX
#   archives/listserv/example.dat
#   archives/listserv/example.dat/example.dat1
#   archives/listserv/example.dat/example.dat2
#   archives/listserv/example.dat/example.dat3 archives/listserv/info
#   archives/listserv/refcard archives/pub archives/pub/DIR
#   archives/pub/INDEX archives/pub/info archives/pub/unix
#   archives/pub/unix/DIR archives/pub/unix/INDEX
#   archives/pub/unix/info config doc doc/README doc/farch.nr
#   doc/queue.nr flocks help help/general help/get help/index
#   help/information help/lists help/recipients help/release help/set
#   help/statistics help/subscribe help/unsubscribe news peer queued
#   redux reformat setup src src/Makefile src/REGISTRATION
#   src/global.h src/list.h src/listserv.h src/pqueue.c src/pqueue.h
#   src/serverd.h src/signals.c src/start.h src/struct.h src/tlock.c
#   stds ulock
# Wrapped by vixie@cognition.pa.dec.com on Fri Dec 13 18:31:08 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f '.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.awk'\"
else
echo shar: Extracting \"'.awk'\" \(423 characters\)
sed "s/^X//" >'.awk' <<'END_OF_FILE'
X{
X  tabcol = 40;
X  l = 0;
X  if (length ($1) < tabcol)
X    l = int ((tabcol + 7 - length ($1)) / 8);
X  printf "%s", $1;
X  k = 8 - int ((length ($1) % 8));
X  for (i = 0; i < k; i++) printf (" ");
X  for (i = 0; i < l; i++) printf "        ";
X  if ($2 != "") printf " %s", $2;
X  if ($3 != "") printf " %s", $3;
X  if ($4 != "") printf " %s", $4;
X  if ($5 != "") printf " %s", $5;
X  if ($6 != "") printf " %s", $6;
X  print "";
X}
END_OF_FILE
if test 423 -ne `wc -c <'.awk'`; then
    echo shar: \"'.awk'\" unpacked with wrong size!
fi
# end of '.awk'
fi
if test -f '.grep' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.grep'\"
else
echo shar: Extracting \"'.grep'\" \(115 characters\)
sed "s/^X//" >'.grep' <<'END_OF_FILE'
X#!/bin/sh
f="k"
while [ "$f" != "" ]; do
X  read f
X  if [ "$f" != "" ]; then
X    grep -i "$f$" $1 | wc -l
X  fi
done
END_OF_FILE
if test 115 -ne `wc -c <'.grep'`; then
    echo shar: \"'.grep'\" unpacked with wrong size!
fi
# end of '.grep'
fi
if test -f '.ignored' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.ignored'\"
else
echo shar: Extracting \"'.ignored'\" \(25 characters\)
sed "s/^X//" >'.ignored' <<'END_OF_FILE'
root
server
bin
sys
uucp
END_OF_FILE
if test 25 -ne `wc -c <'.ignored'`; then
    echo shar: \"'.ignored'\" unpacked with wrong size!
fi
# end of '.ignored'
fi
if test -f '.stats' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.stats'\"
else
echo shar: Extracting \"'.stats'\" \(470 characters\)
sed "s/^X//" >'.stats' <<'END_OF_FILE'
X#!/bin/sh
pth=$1
subscribers=$2
headers=$3
outfile=$4
shift; shift; shift; shift
if [ $# = 0 ]; then
X  if [ `cut -d" " -f1 $subscribers > emails` ]; then
X    exit 1
X  fi
else
X  for user 
X  do
X    echo $user >> emails
X  done
fi
if [ `cat emails | $pth/.grep $headers > counts` ]; then
X  exit 1
fi
if [ `paste emails counts | awk -f $pth/.awk - >> $outfile` ]; then
X  exit 1
fi
echo Total number of messages on file: `cat $headers | wc -l` >> $outfile
rm counts
rm emails
END_OF_FILE
if test 470 -ne `wc -c <'.stats'`; then
    echo shar: \"'.stats'\" unpacked with wrong size!
fi
# end of '.stats'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2445 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X .awk                       1	
X .grep                      1	
X .ignored                   1	
X .stats                     1	
X MANIFEST                   1	
X archives                   1	
X archives/listserv          1	
X archives/listserv/DIR      1	
X archives/listserv/INDEX    1	
X archives/listserv/example.dat  1	
X archives/listserv/example.dat/example.dat1  1	
X archives/listserv/example.dat/example.dat2  1	
X archives/listserv/example.dat/example.dat3  1	
X archives/listserv/info     1	
X archives/listserv/refcard  1	
X archives/pub               1	
X archives/pub/DIR           1	
X archives/pub/INDEX         1	
X archives/pub/info          1	
X archives/pub/unix          1	
X archives/pub/unix/DIR      1	
X archives/pub/unix/INDEX    1	
X archives/pub/unix/info     1	
X config                     1	
X doc                        1	
X doc/README                 1	
X doc/farch.nr               1	
X doc/queue.nr               1	
X doc/server.nr              5	
X flocks                     1	
X help                       1	
X help/general               1	
X help/get                   1	
X help/index                 1	
X help/information           1	
X help/lists                 1	
X help/recipients            1	
X help/release               1	
X help/set                   1	
X help/statistics            1	
X help/subscribe             1	
X help/unsubscribe           1	
X news                       1	
X peer                       1	
X queued                     1	
X redux                      1	
X reformat                   1	
X setup                      1	
X src                        1	
X src/Makefile               1	
X src/README                 2	
X src/REGISTRATION           1	
X src/defs.h                 2	
X src/farch.c                3	
X src/global.h               1	
X src/list.c                 4	
X src/list.h                 1	
X src/listserv.c             6	
X src/listserv.h             1	
X src/misc.c                 3	
X src/pqueue.c               1	
X src/pqueue.h               1	
X src/sender.c               2	
X src/serverd.c              2	
X src/serverd.h              1	
X src/signals.c              1	
X src/start.c                2	
X src/start.h                1	
X src/struct.h               1	
X src/sysmail.c              2	
X src/sysmail.h              2	
X src/tlock.c                1	
X stds                       1	
X ulock                      1	
END_OF_FILE
if test 2445 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test ! -d 'archives' ; then
    echo shar: Creating directory \"'archives'\"
    mkdir 'archives'
fi
if test ! -d 'archives/listserv' ; then
    echo shar: Creating directory \"'archives/listserv'\"
    mkdir 'archives/listserv'
fi
if test -f 'archives/listserv/DIR' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/listserv/DIR'\"
else
echo shar: Extracting \"'archives/listserv/DIR'\" \(236 characters\)
sed "s/^X//" >'archives/listserv/DIR' <<'END_OF_FILE'
info 1 /usr/server/archives/listserv Info about the master archive
refcard 1 /usr/server/archives/listserv List of available requests
example.dat 3 /usr/server/archives/listserv/example.dat Example file
hosts 1 /etc System's hosts file
END_OF_FILE
if test 236 -ne `wc -c <'archives/listserv/DIR'`; then
    echo shar: \"'archives/listserv/DIR'\" unpacked with wrong size!
fi
# end of 'archives/listserv/DIR'
fi
if test -f 'archives/listserv/INDEX' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/listserv/INDEX'\"
else
echo shar: Extracting \"'archives/listserv/INDEX'\" \(103 characters\)
sed "s/^X//" >'archives/listserv/INDEX' <<'END_OF_FILE'
LISTSERV /usr/server/archives/listserv
pub /usr/server/archives/pub
unix /usr/server/archives/pub/unix
END_OF_FILE
if test 103 -ne `wc -c <'archives/listserv/INDEX'`; then
    echo shar: \"'archives/listserv/INDEX'\" unpacked with wrong size!
fi
# end of 'archives/listserv/INDEX'
fi
if test ! -d 'archives/listserv/example.dat' ; then
    echo shar: Creating directory \"'archives/listserv/example.dat'\"
    mkdir 'archives/listserv/example.dat'
fi
if test -f 'archives/listserv/example.dat/example.dat1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/listserv/example.dat/example.dat1'\"
else
echo shar: Extracting \"'archives/listserv/example.dat/example.dat1'\" \(27 characters\)
sed "s/^X//" >'archives/listserv/example.dat/example.dat1' <<'END_OF_FILE'
Part 1 of file EXAMPLE.DAT
END_OF_FILE
if test 27 -ne `wc -c <'archives/listserv/example.dat/example.dat1'`; then
    echo shar: \"'archives/listserv/example.dat/example.dat1'\" unpacked with wrong size!
fi
# end of 'archives/listserv/example.dat/example.dat1'
fi
if test -f 'archives/listserv/example.dat/example.dat2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/listserv/example.dat/example.dat2'\"
else
echo shar: Extracting \"'archives/listserv/example.dat/example.dat2'\" \(27 characters\)
sed "s/^X//" >'archives/listserv/example.dat/example.dat2' <<'END_OF_FILE'
Part 2 of file EXAMPLE.DAT
END_OF_FILE
if test 27 -ne `wc -c <'archives/listserv/example.dat/example.dat2'`; then
    echo shar: \"'archives/listserv/example.dat/example.dat2'\" unpacked with wrong size!
fi
# end of 'archives/listserv/example.dat/example.dat2'
fi
if test -f 'archives/listserv/example.dat/example.dat3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/listserv/example.dat/example.dat3'\"
else
echo shar: Extracting \"'archives/listserv/example.dat/example.dat3'\" \(27 characters\)
sed "s/^X//" >'archives/listserv/example.dat/example.dat3' <<'END_OF_FILE'
Part 3 of file EXAMPLE.DAT
END_OF_FILE
if test 27 -ne `wc -c <'archives/listserv/example.dat/example.dat3'`; then
    echo shar: \"'archives/listserv/example.dat/example.dat3'\" unpacked with wrong size!
fi
# end of 'archives/listserv/example.dat/example.dat3'
fi
if test -f 'archives/listserv/info' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/listserv/info'\"
else
echo shar: Extracting \"'archives/listserv/info'\" \(50 characters\)
sed "s/^X//" >'archives/listserv/info' <<'END_OF_FILE'
Place to put information for the LISTSERV archive
END_OF_FILE
if test 50 -ne `wc -c <'archives/listserv/info'`; then
    echo shar: \"'archives/listserv/info'\" unpacked with wrong size!
fi
# end of 'archives/listserv/info'
fi
if test -f 'archives/listserv/refcard' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/listserv/refcard'\"
else
echo shar: Extracting \"'archives/listserv/refcard'\" \(289 characters\)
sed "s/^X//" >'archives/listserv/refcard' <<'END_OF_FILE'
Recognized commands are:
X
help [command]
set <list> [<option> <value>]
subscribe <list> <your name>
unsubscribe <list> (or: signoff <list>)
recipients <list> (or: review <list>)
information <list>
statistics <list> [subscriber email address(es)]
lists
index [archive]
get <archive> <file>
END_OF_FILE
if test 289 -ne `wc -c <'archives/listserv/refcard'`; then
    echo shar: \"'archives/listserv/refcard'\" unpacked with wrong size!
fi
# end of 'archives/listserv/refcard'
fi
if test ! -d 'archives/pub' ; then
    echo shar: Creating directory \"'archives/pub'\"
    mkdir 'archives/pub'
fi
if test -f 'archives/pub/DIR' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/pub/DIR'\"
else
echo shar: Extracting \"'archives/pub/DIR'\" \(32 characters\)
sed "s/^X//" >'archives/pub/DIR' <<'END_OF_FILE'
info 1 /usr/server/archives/pub
END_OF_FILE
if test 32 -ne `wc -c <'archives/pub/DIR'`; then
    echo shar: \"'archives/pub/DIR'\" unpacked with wrong size!
fi
# end of 'archives/pub/DIR'
fi
if test -f 'archives/pub/INDEX' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/pub/INDEX'\"
else
echo shar: Extracting \"'archives/pub/INDEX'\" \(64 characters\)
sed "s/^X//" >'archives/pub/INDEX' <<'END_OF_FILE'
PUB /usr/server/archives/pub
unix /usr/server/archives/pub/unix
END_OF_FILE
if test 64 -ne `wc -c <'archives/pub/INDEX'`; then
    echo shar: \"'archives/pub/INDEX'\" unpacked with wrong size!
fi
# end of 'archives/pub/INDEX'
fi
if test -f 'archives/pub/info' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/pub/info'\"
else
echo shar: Extracting \"'archives/pub/info'\" \(45 characters\)
sed "s/^X//" >'archives/pub/info' <<'END_OF_FILE'
Place to put information for the PUB archive
END_OF_FILE
if test 45 -ne `wc -c <'archives/pub/info'`; then
    echo shar: \"'archives/pub/info'\" unpacked with wrong size!
fi
# end of 'archives/pub/info'
fi
if test ! -d 'archives/pub/unix' ; then
    echo shar: Creating directory \"'archives/pub/unix'\"
    mkdir 'archives/pub/unix'
fi
if test -f 'archives/pub/unix/DIR' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/pub/unix/DIR'\"
else
echo shar: Extracting \"'archives/pub/unix/DIR'\" \(37 characters\)
sed "s/^X//" >'archives/pub/unix/DIR' <<'END_OF_FILE'
info 1 /usr/server/archives/pub/unix
END_OF_FILE
if test 37 -ne `wc -c <'archives/pub/unix/DIR'`; then
    echo shar: \"'archives/pub/unix/DIR'\" unpacked with wrong size!
fi
# end of 'archives/pub/unix/DIR'
fi
if test -f 'archives/pub/unix/INDEX' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/pub/unix/INDEX'\"
else
echo shar: Extracting \"'archives/pub/unix/INDEX'\" \(35 characters\)
sed "s/^X//" >'archives/pub/unix/INDEX' <<'END_OF_FILE'
UNIX /usr/server/archives/pub/unix
END_OF_FILE
if test 35 -ne `wc -c <'archives/pub/unix/INDEX'`; then
    echo shar: \"'archives/pub/unix/INDEX'\" unpacked with wrong size!
fi
# end of 'archives/pub/unix/INDEX'
fi
if test -f 'archives/pub/unix/info' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archives/pub/unix/info'\"
else
echo shar: Extracting \"'archives/pub/unix/info'\" \(40 characters\)
sed "s/^X//" >'archives/pub/unix/info' <<'END_OF_FILE'
Place to put info for the UNIX archive.
END_OF_FILE
if test 40 -ne `wc -c <'archives/pub/unix/info'`; then
    echo shar: \"'archives/pub/unix/info'\" unpacked with wrong size!
fi
# end of 'archives/pub/unix/info'
fi
if test -f 'config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config'\"
else
echo shar: Extracting \"'config'\" \(3105 characters\)
sed "s/^X//" >'config' <<'END_OF_FILE'
X#
X#		Discussion list system configuration file
X#
X#			      version 5.31
X#
X#			     December 1991
X#
X# AGREEMENT: This software can be used and distributed freely as long
X# as you do not remove or alter the Copyright notice in the file defs.h;
X# this notice is #define'd in the symbol VERSION. Although you may alter
X# the code provided, you may not alter the functions create_header()
X# and create_multi_recipient_header() in list.c and listserv.c.
X# By using this software you are bound by this agreement.
X# This software comes with no warranties and cannot be sold for profit.
X# The AGREEMENT and COPYRIGHT notices should be included in all source
X# files when distributing this software.
X# COPYRIGHT: Copyright (c) 1991, Anastasios C. Kotsikonas
X#
X# Note: On SysV and BSD Unix systems 'sendmail' is located under /usr/lib/
X# but on SysVR4 it is located under /usr/ucblib/; also, check the path to
X# rmail if you are going to use it.
X
organization Boston University	     # define your site
server listserv@sal -e -r statistics # define the server w/ restriction (opt.)
list ermis ermis@sal -m 50 -e	     # define a list called 'ermis'
list venus venus@sal -e	 # define a list called 'venus' (echo to screen)
list herc herc@sal -r -s # define 'herc' w/ restricted mail and no subscription
X			 # checking
disable herc statistics	 # cannot get statistics for ermis
serverd -l 3 -e	 # the serverd program may be run with the -l option
X		 # serverd will delay if the load average is above 3
X		 # Note that the -1 flag is used by default by start
restriction 20	 # certain requests may not be serviced abover this # of users
manager tasos@sal	 # email address of the manager of the system
password ellines # password for the 'restart' and 'shutdown' requests
comment server	 #Actual comment must be preceded by a pound sign
comment ermis	 #Same here
comment venus	 #Venus Distribution List
frequency 0	 # how often to read mail (in seconds >= 0)
limit message 65536	 # reject messages longer than 65536 bytes
option sysv_ps	 # forces use of the SYS V ps command; other choice is bsd_ps
option bsd_mail	 # define it if BSD mail is available
option post_mail # Post to news; other choice is gate_mail
mailmethod system
X#mailmethod env_var LOGNAME /bin/rmail	# Valid 'mailmethod' options:
X					# telnet
X					# sendmail /usr/lib/sendmail -bs
X					# sendmail /usr/lib/sendmail -t (IDA)
X					# rmail /bin/rmail
X					# binmail
X					# env_var VARIABLE /bin/mail
X					# env_var VARIABLE /usr/lib/sendmail -t
X					# env_var VARIABLE /bin/rmail
X					# env_var VARIABLE /usr/bin/mail
X#
X# WARNING: All other mailmethods except 'system' and 'sendmail'
X# will become obsolete soon.
X#
X#option bad_telnet # use this flag when a telnet session is not terminating
X#
X# IMPORTANT NOTE:
X#
X# listserv also recognizes the requests 'restart' and 'shutdown' followed by
X# a password, that can be used to remotely restart and shutdown the server
X# system. The password is defined in the 'config' file using the 'password'
X# directive followed by the actual password.
X# This feature is not documented in the man page for obvious reasons.
END_OF_FILE
if test 3105 -ne `wc -c <'config'`; then
    echo shar: \"'config'\" unpacked with wrong size!
fi
# end of 'config'
fi
if test ! -d 'doc' ; then
    echo shar: Creating directory \"'doc'\"
    mkdir 'doc'
fi
if test -f 'doc/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/README'\"
else
echo shar: Extracting \"'doc/README'\" \(756 characters\)
sed "s/^X//" >'doc/README' <<'END_OF_FILE'
X
To install the man pages permanently on your system you will need to do the
following as superuser:
X
X% cp server.nr farch.nr queue.nr /usr/man/cat1 <- or wherever the man pages are
X% cd /usr/man/cat1
X% compress server.nr farch.nr queue.nr
X% mv server.nr.Z server.1
X% mv farch.nr.Z farch.1
X% mv queue.nr.Z queue.1
X% chmod 444 server.1 farch.1 queue.1
X% vi Index <--- if availbable
X  add the following lines in Index in the appropriate alphabetic location:
X	server.1:server:
X	farch.1:farch:
X	queue.1:queue:
X% vi /usr/man/whatis <-- or whatever file is used when doing man -k
X  add the following lines in whatis:
X	server (1)	- discussion list server system
X	farch (1)	- file archiving for list server system
X	queue (1)	- mail queueing for list server system
END_OF_FILE
if test 756 -ne `wc -c <'doc/README'`; then
    echo shar: \"'doc/README'\" unpacked with wrong size!
fi
# end of 'doc/README'
fi
if test -f 'doc/farch.nr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/farch.nr'\"
else
echo shar: Extracting \"'doc/farch.nr'\" \(4751 characters\)
sed "s/^X//" >'doc/farch.nr' <<'END_OF_FILE'
X
X
X
farch(1)                  USER COMMANDS                  farch(1)
X
X
X
NNNNAAAAMMMMEEEE
X     farch - archive files in /usr/server/archives
X
SSSSYYYYNNNNOOOOPPPPSSSSIIIISSSS
X     farch [-n] [-b] [-s size] [-a archive] [-d  dir]  [-t  file]
X     files
X
DDDDEEEESSSSCCCCRRRRIIIIPPPPTTTTIIIIOOOONNNN
X     _f_a_r_c_h is used  to  archive  files  in  /usr/server/archives.
X     Archives  reside under that directory as subdirectories; the
X     default is _l_i_s_t_s_e_r_v, and it  is  also  the  master  archive.
X     Archives are hierarchically structured, and each archive has
X     at least two files in its directory:
X
X     INDEX
X          A list of all subarchives including itself; the  format
X          is  one  line  per archive with the archive's name fol-
X          lowed by the archive's full path.
X
X     DIR  A list of files available from that archive; the format
X          is  one  line per file, followed by the number of parts
X          it may be split into, followed by the full path to  the
X          directory these parts can be found, followed by a short
X          descriptive message about the file (optional).
X
X     The following command line options are recognized:
X
X     -n   Do not split files when archiving them.
X
X     -b   Input files  are  binary;  they  are  uuencoded  before
X          archived.
X
X     -s size
X          Specify the maximum _s_i_z_e in kilobytes of  each  of  the
X          subparts (default is 64).
X
X     -a archive
X          Specify the  _a_r_c_h_i_v_e  that  the  input  files  will  be
X          archived under (default is listserv).
X
X     -d dir
X          Specify the _d_i_rectory that the output files are  to  be
X          placed  (default  is /usr/server/archives/listserv). If
X          the directory does not exist, it will be created.
X
X     -t file
X          Input files are tarred into _f_i_l_e which is then archived
X          (-b flag is automatically turned on).
X
AAAARRRRCCCCHHHHIIIIVVVVIIIINNNNGGGG AAAA FFFFIIIILLLLEEEE
X     _f_a_r_c_h by default splits the input files if necessary (or the
X     tar  file, if any), into files of maximum size as specified.
X
X
X
Anastasios Kotsikonas                                          1
X
X
X
X
X
X
farch(1)                  USER COMMANDS                  farch(1)
X
X
X
X     Each part will contain as many complete lines from the  ori-
X     ginal  input  file as possible, without exceeding the speci-
X     fied size.  Binary  files  are  uuencoded  before  they  are
X     archived,  and  all archived files are compressed, if possi-
X     ble.
X
AAAADDDDDDDDIIIINNNNGGGG AAAA NNNNEEEEWWWW AAAARRRRCCCCHHHHIIIIVVVVEEEE
X     Step 1
X          Create a directory under /usr/server/archives with  the
X          new archive's name.
X
X     Step 2
X          Edit    the     master     archive's     index     file
X          (/usr/server/archives/listserv/INDEX)  and  add the new
X          archive along with its path at the bottom of the  file.
X          The  first  line  of  every  INDEX  file  should be the
X          archive  that  owns  it.   Also  edit  every   ancestor
X          archive's INDEX file, if the new archive is not a child
X          of the default.
X
X     Step 3
X          Create a new INDEX file in the new archive's  directory
X          and put an entry for itself.
X
X     Step 4
X          Create an empty DIR file in the  new  archive's  direc-
X          tory.
X
XEEEEXXXXAAAAMMMMPPPPLLLLEEEESSSS
X     Archive src/data and src/data2 under listserv, using a  max-
X     imum  file  size of 1K; the output file(s) will be placed in
X     /tmp:
X
X       % farch -s 1 -d /tmp src/data src/data2
X
X     Archive /etc/hosts under archive unix:
X
X       % farch -a unix -d /etc /etc/hosts
X
X     Tar and archive all files in /usr/src:
X
X       % farch -t source /usr/src/*.c
X     Descriptive messages about these files  are  added  manually
X     into the archive's DIR file.
X
RRRREEEESSSSTTTTRRRRIIIICCCCTTTTIIIIOOOONNNNSSSS
X     The input files must use only lower case characters  of  the
X     alphabet.
X
SSSSEEEEEEEE AAAALLLLSSSSOOOO
X     server(1)
X
X
X
X
Anastasios Kotsikonas                                          2
X
X
X
X
X
X
farch(1)                  USER COMMANDS                  farch(1)
X
X
X
AAAAUUUUTTTTHHHHOOOORRRR
X     Anastasios C. Kotsikonas, Boston University.
X     Copyright (c) 1991, Anastasios Kotsikonas
X     Comments to tasos@cs.bu.edu
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
Anastasios Kotsikonas                                          3
X
X
X
END_OF_FILE
echo shar: 297 control characters may be missing from \"'doc/farch.nr'\"
if test 4751 -ne `wc -c <'doc/farch.nr'`; then
    echo shar: \"'doc/farch.nr'\" unpacked with wrong size!
fi
# end of 'doc/farch.nr'
fi
if test -f 'doc/queue.nr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/queue.nr'\"
else
echo shar: Extracting \"'doc/queue.nr'\" \(3302 characters\)
sed "s/^X//" >'doc/queue.nr' <<'END_OF_FILE'
X
X
X
queue(1)                  USER COMMANDS                  queue(1)
X
X
X
NNNNAAAAMMMMEEEE
X     queued - mail queue daemon
X
SSSSYYYYNNNNOOOOPPPPSSSSIIIISSSS
X     qqqquuuueeeeuuuueeeedddd <ffffrrrreeeeqqqquuuueeeennnnccccyyyy> <mmmmaaaannnnaaaaggggeeeerrrr>
X
NNNNAAAAMMMMEEEE
X     pqueue - process the specified mail queue files
X
SSSSYYYYNNNNOOOOPPPPSSSSIIIISSSS
X     ppppqqqquuuueeeeuuuueeee [----eeee] [----DDDD] <ffffiiiilllleeeessss>
X
OOOOVVVVEEEERRRRVVVVIIIIEEEEWWWW
X     This part of the system can be employed only when using  the
X     _s_y_s_t_e_m  mailmethod  (see  _s_e_r_v_e_r(_1)).  Messages and requests
X     not delivered due to network  problems  are  queued  by  the
X     server system in the directory /usr/server/mqueue. This part
X     of the system attempts periodic redelivery of  these  files.
X     If  problems  still persist, files (messages) that cannot be
X     delivered are requeued.
X
DDDDEEEESSSSCCCCRRRRIIIIPPPPTTTTIIIIOOOONNNN:::: qqqquuuueeeeuuuueeeedddd
X     This is the daemon that looks for files in the  mail  queue.
X     It  uses  _p_q_u_e_u_e  for redelivery. The queue is checked every
X     _f_r_e_q_u_e_n_c_y seconds. Whenever an  error  occurs  with  _p_q_u_e_u_e,
X     _q_u_e_u_e_d sends a mail message to _m_a_n_a_g_e_r and aborts.
X
X     _q_u_e_u_e_d is not spawned by _s_t_a_r_t in order to reduce the number
X     of  processes  running,  since  the  probability of messages
X     being queued is very low.  Instead,  it  should  be  started
X     manually  whenever  there are files in the mail queue direc-
X     tory.
X
DDDDEEEESSSSCCCCRRRRIIIIPPPPTTTTIIIIOOOONNNN:::: ppppqqqquuuueeeeuuuueeee
X     The _f_i_l_e_s given as arguments  are  redelivered.  If  any  of
X     these  cannot  be redelivered, they are requeued and will be
X     processed in the  next  run.  _p_q_u_e_u_e  reports  to  the  file
X     /usr/server/.report.pqueue
X
X     The following command line options are recognized:
X
X     -e   Echo reports to the screen.
X
X     -D   Turns debugging on; a copy of the last SMPT transaction
X          can   be   found  in  the  files  /usr/server/sent  and
X          /usr/server/received. Warning:  these  files  are  also
X          used  by  _l_i_s_t  and _l_i_s_t_s_e_r_v when they have their debug
X          mode on, so use caution.
X
NNNNOOOOTTTTEEEE
X     This mail queuing system should not be confused with the one
X     implemented by sendmail.
X
X
X
Anastasios Kotsikonas                                          1
X
X
X
X
X
X
queue(1)                  USER COMMANDS                  queue(1)
X
X
X
SSSSEEEEEEEE AAAALLLLSSSSOOOO
X     server(1)
X
AAAAUUUUTTTTHHHHOOOORRRR
X     Anastasios C. Kotsikonas, Boston University.
X     Copyright (c) 1991, Anastasios Kotsikonas
X     Comments to tasos@cs.bu.edu
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
Anastasios Kotsikonas                                          2
X
X
X
END_OF_FILE
echo shar: 447 control characters may be missing from \"'doc/queue.nr'\"
if test 3302 -ne `wc -c <'doc/queue.nr'`; then
    echo shar: \"'doc/queue.nr'\" unpacked with wrong size!
fi
# end of 'doc/queue.nr'
fi
if test -f 'flocks' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flocks'\"
else
echo shar: Extracting \"'flocks'\" \(102 characters\)
sed "s/^X//" >'flocks' <<'END_OF_FILE'
X#include "/usr/server/src/defs.h"
rm -f SERVERD_LOCK_FILE
rm -f LIST_LOCK_FILE
rm -f SERVER_LOCK_FILE
END_OF_FILE
if test 102 -ne `wc -c <'flocks'`; then
    echo shar: \"'flocks'\" unpacked with wrong size!
fi
# end of 'flocks'
fi
if test ! -d 'help' ; then
    echo shar: Creating directory \"'help'\"
    mkdir 'help'
fi
if test -f 'help/general' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/general'\"
else
echo shar: Extracting \"'help/general'\" \(2544 characters\)
sed "s/^X//" >'help/general' <<'END_OF_FILE'
Recognized requests are:
X
X*******************************************************************************
X
help [request]
X--------------
Without arguments, this file. Otherwise get specific information on the
selected topic.
X
X*******************************************************************************
X
set <list> [<option> <value>]
X-----------------------------
Without the optional arguments, get a list of all current settings for
the specified list. Otherwise change the option to the new value for that
list.
X
X*******************************************************************************
X
subscribe <list> <your name>
X----------------------------
The only way to subscribe to a list.
X
X*******************************************************************************
X
unsubscribe <list> (or: signoff <list>)
X---------------------------------------
Remove yourself from the specified list.
X
X*******************************************************************************
X
recipients <list> (or: review <list>)
X-------------------------------------
Get a list of all people subscribed in the specified list.
X
X*******************************************************************************
X
information <list>
X------------------
Get information about the specified list.
X
X*******************************************************************************
X
statistics <list> [subscriber email address(es)]
X------------------------------------------------
Get a list of subscribers along with the number of messages each one
of them has sent to the specified list. If the optional email addresses
are given, then statistics will be collected for these users only.
X
X*******************************************************************************
X
lists
X-----
Get a list of discussion lists that are served by this server.
X
X*******************************************************************************
X
index [archive]
X---------------
Get a list of files in the selected archive, or the master archive if
no archive was specified.
X
X*******************************************************************************
X
get <archive> <file> [parts]
X----------------------------
Get the requested file from the specified archive. Certain subparts may
be obtained by specifying them as optional arguments.
X
X*******************************************************************************
X
release
X-------
Get information about the current release of this listserv system.
X
X*******************************************************************************
END_OF_FILE
if test 2544 -ne `wc -c <'help/general'`; then
    echo shar: \"'help/general'\" unpacked with wrong size!
fi
# end of 'help/general'
fi
if test -f 'help/get' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/get'\"
else
echo shar: Extracting \"'help/get'\" \(806 characters\)
sed "s/^X//" >'help/get' <<'END_OF_FILE'
Syntax: get <archive> <file> [parts]
X	Get the specified file from the specified archive. The file may
X	have been split into parts because some mailers cannot send large
X	files, and in this case you will receive as many messages as the
X	number of parts the file has been split into. Binary files are
X	uuencoded, so you will need to combine all the parts sent and
X	uudecode. The requested file may be a tar file (containing other
X	files and perhaps directories) in which case when you uudecode,
X	a tar file will be created and you will need to run the UNIX
X	utility 'tar' on it to extract the files and directories.
X
X	If certain parts are specified, then only these parts (if they exist)
X	will be sent. The parts are specified as numbers separated by spaces.
X	You may not specify ranges of parts (e.g. 1-3).
END_OF_FILE
if test 806 -ne `wc -c <'help/get'`; then
    echo shar: \"'help/get'\" unpacked with wrong size!
fi
# end of 'help/get'
fi
if test -f 'help/index' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/index'\"
else
echo shar: Extracting \"'help/index'\" \(292 characters\)
sed "s/^X//" >'help/index' <<'END_OF_FILE'
Syntax: index [archive]
X	Get a list of files for the specified archive, or listserv -- the
X	master archive, if none given. Files are actually listed for
X	the requested archive, plus all of its subarchives. Obviously
X	the master archive will list all of the available files from this
X	server.
END_OF_FILE
if test 292 -ne `wc -c <'help/index'`; then
    echo shar: \"'help/index'\" unpacked with wrong size!
fi
# end of 'help/index'
fi
if test -f 'help/information' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/information'\"
else
echo shar: Extracting \"'help/information'\" \(159 characters\)
sed "s/^X//" >'help/information' <<'END_OF_FILE'
Syntax: information <list>
X        Get information about the specified list. This usually includes
X	its purpose and certain restrictions for posting messages.
END_OF_FILE
if test 159 -ne `wc -c <'help/information'`; then
    echo shar: \"'help/information'\" unpacked with wrong size!
fi
# end of 'help/information'
fi
if test -f 'help/lists' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/lists'\"
else
echo shar: Extracting \"'help/lists'\" \(152 characters\)
sed "s/^X//" >'help/lists' <<'END_OF_FILE'
Syntax: lists
X        Get a list of all discussion lists served by this server; the list
X	consists of email addresses and a brief comment for each one.
END_OF_FILE
if test 152 -ne `wc -c <'help/lists'`; then
    echo shar: \"'help/lists'\" unpacked with wrong size!
fi
# end of 'help/lists'
fi
if test -f 'help/recipients' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/recipients'\"
else
echo shar: Extracting \"'help/recipients'\" \(288 characters\)
sed "s/^X//" >'help/recipients' <<'END_OF_FILE'
Syntax: recipients <list> (or: review <list>)
X        Get a listing of the current subscribers for the specified list;
X	each person's email address is followed by his/her name. If the list
X	is linked with any peer lists, your request will be forwarded to
X	the appropriate server(s) also.
END_OF_FILE
if test 288 -ne `wc -c <'help/recipients'`; then
    echo shar: \"'help/recipients'\" unpacked with wrong size!
fi
# end of 'help/recipients'
fi
if test -f 'help/release' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/release'\"
else
echo shar: Extracting \"'help/release'\" \(84 characters\)
sed "s/^X//" >'help/release' <<'END_OF_FILE'
Syntax: release
X	Get information about the current release of this listserv system.
END_OF_FILE
if test 84 -ne `wc -c <'help/release'`; then
    echo shar: \"'help/release'\" unpacked with wrong size!
fi
# end of 'help/release'
fi
if test -f 'help/set' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/set'\"
else
echo shar: Extracting \"'help/set'\" \(590 characters\)
sed "s/^X//" >'help/set' <<'END_OF_FILE'
Syntax: set <list> [<option> <value>]
X	Without the optional arguments, get a list of all current settings for
X	the specified list. Otherwise change the option to the new value for
X	that list, as follows:
X
X        option can be: mail
X        value can be: ack, noack, postpone
X
X        'set <list>': get the current option settings for the list
X        'set <list> mail ack': your message is sent back to you
X        'set <list> mail noack': your message is not sent back to you
X        'set <list> mail postpone': no messages will be sent to you until you
X                change mode again
END_OF_FILE
if test 590 -ne `wc -c <'help/set'`; then
    echo shar: \"'help/set'\" unpacked with wrong size!
fi
# end of 'help/set'
fi
if test -f 'help/statistics' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/statistics'\"
else
echo shar: Extracting \"'help/statistics'\" \(473 characters\)
sed "s/^X//" >'help/statistics' <<'END_OF_FILE'
Syntax: statistics <list> [subscriber email address(es)]
X        Get statistical information for all subscribers, or for the specified
X        one(s) only, in the specified list. Each email address is followed
X	by a count of the number of messages sent to this list by this user
X	to date. Wild characters are allowed when inquiring about specific
X	subscribers. If the list is linked with other peer lists, your request
X	will be forwarded to the appropriate server(s) also.
END_OF_FILE
if test 473 -ne `wc -c <'help/statistics'`; then
    echo shar: \"'help/statistics'\" unpacked with wrong size!
fi
# end of 'help/statistics'
fi
if test -f 'help/subscribe' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/subscribe'\"
else
echo shar: Extracting \"'help/subscribe'\" \(140 characters\)
sed "s/^X//" >'help/subscribe' <<'END_OF_FILE'
Syntax: subscribe <list> <your full name>
X        The only way to subscribe to a list. Any extraneous characters in
X	your name are removed.
END_OF_FILE
if test 140 -ne `wc -c <'help/subscribe'`; then
    echo shar: \"'help/subscribe'\" unpacked with wrong size!
fi
# end of 'help/subscribe'
fi
if test -f 'help/unsubscribe' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/unsubscribe'\"
else
echo shar: Extracting \"'help/unsubscribe'\" \(85 characters\)
sed "s/^X//" >'help/unsubscribe' <<'END_OF_FILE'
Syntax: unsubscribe <list> (or: signoff <list>)
X        Remove yourself from a list.
END_OF_FILE
if test 85 -ne `wc -c <'help/unsubscribe'`; then
    echo shar: \"'help/unsubscribe'\" unpacked with wrong size!
fi
# end of 'help/unsubscribe'
fi
if test -f 'news' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'news'\"
else
echo shar: Extracting \"'news'\" \(1891 characters\)
sed "s/^X//" >'news' <<'END_OF_FILE'
X#!/bin/sh
X# Shell script to add a news group to a discussion list.
X#
X# Usage: news <LIST_ALIAS> <news group> <news email address> <news mode>
X#
X# where:
X# LIST_ALIAS: a local list alias, capitalized, that is to be connected to
X#  the news group.
X# news group: the news group name (e.g. alt.sex)
X# news email address: full email address of the news source.
X# news mode: "receive" if the local list will only be receiving articles,
X#  or "send_receive" if the local list will post to the news group as
X#  well.
X
PROG=`basename $0`
if [ $# -lt 4 ]; then
X  echo Usage: $PROG \<LIST_ALIAS\> \<news group\> \<$PROG email address\> \<$PROG mode\>
X  exit 1
fi
X
ARGS=$PROG\ $*
DIR=/usr/server/lists/`echo $1 | tr '[a-z]' '[A-Z]'`
REPORT=/usr/server/.report.server
CONFIG=/usr/server/config
XFILE=$DIR/.news
GROUP=`echo $2 | tr '[A-Z]' '[a-z]'`
XEMAIL=`echo $3 | tr '[A-Z]' '[a-z]'`
shift; shift; shift
X
if [ ! -d $DIR ]; then
X  echo $DIR: no such list
X  exit 2
fi
if [ ! -r $CONFIG ]; then
X  echo Cannot open $CONFIG
X  exit 2
fi
if [ ! -r $FILE ]; then
X  echo Cannot open $FILE
X  exit 2
fi
if [ "$1" = "receive" ]; then
X  MODE=POSTPONE
elif [ "$1" = "send_receive" ]; then
X  MODE=NOACK
else
X  echo Token $1 not recognized
X  exit 2
fi
X
echo >> $REPORT
echo --- NEW MAIL HAS ARRIVED --- >> $REPORT
echo $ARGS >> $REPORT
LOCAL=`grep -i "^list *$REMOTE_ALIAS *$EMAIL" $CONFIG | awk '{ print $2 }'`
if [ "$LOCAL" = "" ]; then
X  LOCAL=`grep -i "^server\  *$EMAIL" $CONFIG | awk '{ print $2 }'`
X  txt=server
else
X  txt=list
fi
if [ "$LOCAL" != "" ]; then
X  echo Cannot add local $txt $LOCAL as $PROG to $FILE >&1 | tee -a $REPORT
else
X  if [ "`grep -i $EMAIL $FILE`" != "" ] || [ "`grep -i $GROUP $FILE`" != "" ]
X  then
X    echo $EMAIL\: Already subscribed as a $PROG group in $FILE >&1 | \
X         tee -a $REPORT
X  else
X    echo $EMAIL $MODE $GROUP >> $FILE
X  fi
fi
echo Time/Date: `date` >> $REPORT
exit 0
END_OF_FILE
if test 1891 -ne `wc -c <'news'`; then
    echo shar: \"'news'\" unpacked with wrong size!
fi
# end of 'news'
fi
if test -f 'peer' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'peer'\"
else
echo shar: Extracting \"'peer'\" \(1838 characters\)
sed "s/^X//" >'peer' <<'END_OF_FILE'
X#!/bin/sh
X# Shell script to add a peer list to a discussion list. 
X#
X# Usage: peer <LIST_ALIAS> <remote alias> <remote peer email address> 
X#	      <remote peer listserv email address>
X# where:
X# LIST_ALIAS: a local list alias, capitalized, that is to be connected to
X#  the new peer.
X# remote alias: the peer's list alias on the remote machine
X# remote peer email address: full email address of the peer list to be added
X# remote peer listserv email address: full email address of the server
X#   that handles the remote peer.
X
PROG=`basename $0`
if [ $# -lt 4 ]; then
X  echo Usage: $PROG \<LIST_ALIAS\> \<remote alias\> \
X\<remote $PROG email address\> \<remote $PROG listserv email address\>
X  exit 1
fi
X
ARGS=$PROG\ $*
DIR=/usr/server/lists/`echo $1 | tr '[a-z]' '[A-Z]'`
REMOTE_ALIAS=`echo $2 | tr '[A-Z]' '[a-z]'`
XEMAIL=`echo $3 | tr '[A-Z]' '[a-z]'`
REMOTE_SERVER=`echo $4 | tr '[A-Z]' '[a-z]'`
REPORT=/usr/server/.report.server
CONFIG=/usr/server/config
MODE=NOACK
XFILE=$DIR/.peers
shift; shift; shift; shift
X
if [ ! -d $DIR ]; then
X  echo $DIR: no such list
X  exit 2
fi
if [ ! -r $CONFIG ]; then
X  echo Cannot open $CONFIG
X  exit 2
fi
if [ ! -r $FILE ]; then
X  echo Cannot open $FILE
X  exit 2
fi
X
echo >> $REPORT
echo --- NEW MAIL HAS ARRIVED --- >> $REPORT
echo $ARGS >> $REPORT
LOCAL=`grep -i "^list *$REMOTE_ALIAS *$EMAIL" $CONFIG | awk '{ print $2 }'`
if [ "$LOCAL" = "" ]; then
X  LOCAL=`grep -i "^server\  *$EMAIL" $CONFIG | awk '{ print $2 }'`
X  txt=server
else
X  txt=list
fi
if [ "$LOCAL" != "" ]; then
X  echo Cannot add local $txt $LOCAL as $PROG to $FILE >&1 | tee -a $REPORT
else
X  if [ "`grep -i $EMAIL $FILE`" != "" ]; then
X    echo $EMAIL\: Already subscribed as a $PROG in $FILE >&1 | tee -a $REPORT
X  else
X    echo $EMAIL $MODE $REMOTE_ALIAS $REMOTE_SERVER >> $FILE
X  fi
fi
echo Time/Date: `date` >> $REPORT
exit 0
END_OF_FILE
if test 1838 -ne `wc -c <'peer'`; then
    echo shar: \"'peer'\" unpacked with wrong size!
fi
# end of 'peer'
fi
if test -f 'queued' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'queued'\"
else
echo shar: Extracting \"'queued'\" \(703 characters\)
sed "s/^X//" >'queued' <<'END_OF_FILE'
X#!/bin/sh
X# queued <frequency> <manager>
X# Daemon to process the mail queue periodically. The frequency is given
X# in seconds.
X
if [ $# -ne 2 ]; then
X  echo Usage: `basename $0` \<frequency\> \<manager\>
X  exit 3
fi
DIR=/usr/server/mqueue
XFREQ=$1
MANAGER=$2
shift; shift
if [ ! -d $DIR ]; then
X  echo $DIR directory missing
X  exit 3
fi
cd $DIR
PWD=`pwd`
while [ 007 ]; do
X  for i in `\ls`
X  do
X    if [ ! -r /usr/server/pqueue ]; then
X      echo queued aborts: pqueue not found | /bin/rmail $MANAGER
X      exit 1
X    fi
X    /usr/server/pqueue -e $PWD/$i
X    if [ $? -gt 0 ]; then
X      echo queued aborts: pqueue exit status $? | /bin/rmail $MANAGER
X      exit 1
X    fi
X  done
X  sleep $FREQ
done
exit 0
END_OF_FILE
if test 703 -ne `wc -c <'queued'`; then
    echo shar: \"'queued'\" unpacked with wrong size!
fi
# end of 'queued'
fi
if test -f 'redux' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'redux'\"
else
echo shar: Extracting \"'redux'\" \(494 characters\)
sed "s/^X//" >'redux' <<'END_OF_FILE'
X#!/bin/sh
X# Script to reduce the size of mboxes by removing unnecessary fields in
X# the header of each message.
X# Usage: redux [mbox-file] (default is ./mbox)
X
XFILE=$1
if [ $# = 0 ]; then
X  FILE=./mbox
fi
if [ ! -r $FILE ]; then
X  echo File $FILE not found.
X  exit
fi
echo Reducing $FILE\; reduced file in /tmp/reduced >&2
X/usr/bin/egrep -v "^Cc: |^          with BSMTP;|^Received: |^Status: |^Message-Id: |^Comment: |^Reply-To: |^Sender: |^To: |^Return-Path: |^	id " $FILE > /tmp/reduced
exit
END_OF_FILE
if test 494 -ne `wc -c <'redux'`; then
    echo shar: \"'redux'\" unpacked with wrong size!
fi
# end of 'redux'
fi
if test -f 'reformat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'reformat'\"
else
echo shar: Extracting \"'reformat'\" \(358 characters\)
sed "s/^X//" >'reformat' <<'END_OF_FILE'
X#!/bin/sh
X# This script reformats incoming messages; mailers are supposed to convert
X# any message text starting with "From " to ">From ", but some fail to do it.
X# This script should be used instead in the aliases file. For example:
X#
X#test-list:"|/bin/cat | /usr/server/reformat >> /usr/server/lists/TEST-LIST/mail
read x
echo $x
sed 's/^From\ /\>From\ /'
END_OF_FILE
if test 358 -ne `wc -c <'reformat'`; then
    echo shar: \"'reformat'\" unpacked with wrong size!
fi
# end of 'reformat'
fi
if test -f 'setup' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'setup'\"
else
echo shar: Extracting \"'setup'\" \(992 characters\)
sed "s/^X//" >'setup' <<'END_OF_FILE'
X#!/bin/sh
cd /usr/server
if [ ! -d lists ]; then
X  echo Creating directory `pwd`/lists
X  mkdir lists
fi
if [ ! -d mqueue ]; then
X  echo Creating directory `pwd`/mqueue
X  mkdir mqueue
fi
cd src
make
make install
cd ..
if [ ! -r start ]; then
X  echo start not found
X  exit 2
fi
if [ ! -r serverd ]; then
X  echo serverd not found
X  exit 2
fi
if [ ! -r list ]; then
X  echo list not found
X  exit 2
fi
if [ ! -r listserv ]; then
X  echo listserv not found
X  exit 2
fi
if [ ! -r config ]; then
X  echo config not found
X  exit 2
fi
if [ ! -r .awk ]; then
X  echo .awk not found
X  exit 2
fi
if [ ! -r .stats ]; then
X  echo .stats not found
X  exit 2
fi
if [ ! -r .grep ]; then
X  echo .grep not found
X  exit 2
fi
if [ ! -r .ignored ]; then
X  echo .ignored not found
X  exit 2
fi
touch requests
chmod 700 start serverd list listserv .awk .stats .grep ulock redux \
peer news stds queued
chmod 755 reformat
chmod 733 .
chmod 711 lists
chmod 600 config
chmod 666 requests
echo List Server System ready.
exit 0
END_OF_FILE
if test 992 -ne `wc -c <'setup'`; then
    echo shar: \"'setup'\" unpacked with wrong size!
fi
chmod +x 'setup'
# end of 'setup'
fi
if test ! -d 'src' ; then
    echo shar: Creating directory \"'src'\"
    mkdir 'src'
fi
if test -f 'src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile'\"
else
echo shar: Extracting \"'src/Makefile'\" \(2146 characters\)
sed "s/^X//" >'src/Makefile' <<'END_OF_FILE'
X#
X# Makefile for listserv
X#
X# See the README file and the bottom of ../doc/server.nr for machine-specific
X# instructions on compiling and installing this program.
X#
X# If you wish to use an ANSI C compiler and preprocessor, you will have
X# to do the following first:
X# % ../stds *.[ch]
X#
X
SHELL		= /bin/sh
HOMEDIR         = /usr/server
CC              = cc
CPP             = /lib/cpp
CFLAGS          = -g
LDFLAGS         = -g
X
ARCHIVED        = signals.o sender.o misc.o sysmail.o
ARCHIVE_LIB     = libserver.a
TARGETS         = listserv list serverd start tlock farch pqueue
X
all: $(ARCHIVE_LIB) $(TARGETS)
X
X$(ARCHIVE_LIB): $(ARCHIVED)
X	@rm -f $(ARCHIVE_LIB)
X	ar cr $(ARCHIVE_LIB) $(ARCHIVED)
X	@if [ -f /usr/bin/ranlib -o -f /bin/ranlib ]; then \
X	  echo ranlib $(ARCHIVE_LIB); \
X	  ranlib $(ARCHIVE_LIB);\
X	else\
X	  echo ar ts $(ARCHIVE_LIB); \
X	  ar ts $(ARCHIVE_LIB); \
X	fi
X
listserv: listserv.o $(ARCHIVE_LIB)
X	$(CC) $(LDFLAGS) $@.o $(ARCHIVE_LIB) -o $@ -lm
X
list: list.o $(ARCHIVE_LIB)
X	$(CC) $(LDFLAGS) $@.o $(ARCHIVE_LIB) -o $@
X
serverd: serverd.o $(ARCHIVE_LIB)
X	$(CC) $(LDFLAGS) $@.o $(ARCHIVE_LIB) -o $@ -lm
X
start: start.o $(ARCHIVE_LIB)
X	$(CC) $(LDFLAGS) $@.o $(ARCHIVE_LIB) -o $@
X
tlock: tlock.o $(ARCHIVE_LIB)
X	$(CC) $(LDFLAGS) $@.o $(ARCHIVE_LIB) -o $@
X
farch: farch.o $(ARCHIVE_LIB)
X	$(CC) $(LDFLAGS) $@.o $(ARCHIVE_LIB) -o $@
X
pqueue: pqueue.o $(ARCHIVE_LIB)
X	$(CC) $(LDFLAGS) $@.o $(ARCHIVE_LIB) -o $@
X
install: $(ARCHIVE_LIB) $(TARGETS) $(HOMEDIR)
X	@for t in $(TARGETS); do \
X	  echo Installing "$$t"; \
X	  rm -f $(HOMEDIR)/"$$t"; \
X	  cp "$$t" $(HOMEDIR); \
X	done
X
X$(HOMEDIR):
X	mkdir $(HOMEDIR)
X
clean:
X	rm -f $(TARGETS) $(ARCHIVE_LIB) *.o
X
X# Hand-generated dependencies
listserv.o:     defs.h struct.h global.h listserv.h
X
list.o:         defs.h struct.h global.h list.h
X
serverd.o:      defs.h struct.h global.h serverd.h
X
start.o:        defs.h struct.h global.h start.h
X
sender.o:       defs.h
X
signals.o:      defs.h struct.h
X
sysmail.o:      defs.h struct.h sysmail.h
X
misc.o:         defs.h struct.h
X
tlock.o:        defs.h
X
farch.o:        defs.h struct.h listserv.h
X
pqueue.o:       defs.h struct.h global.h pqueue.h
END_OF_FILE
if test 2146 -ne `wc -c <'src/Makefile'`; then
    echo shar: \"'src/Makefile'\" unpacked with wrong size!
fi
# end of 'src/Makefile'
fi
if test -f 'src/REGISTRATION' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/REGISTRATION'\"
else
echo shar: Extracting \"'src/REGISTRATION'\" \(468 characters\)
sed "s/^X//" >'src/REGISTRATION' <<'END_OF_FILE'
X
X		  DISCUSSION LIST SERVER SYSTEM
X		  -----------------------------
X
X			Copy Registration
X
X			 tasos@cs.bu.edu
X
Keep an eye on the anonymous ftp site cs.bu.edu (128.197.10.1) for any
updates, in the directory pub/listserv
X
If you use this software and have not filled out a registration form before,
please email me the following information:
X
Name:
XEmail address:
Organization:
Address:
Phone:
Type of computer system:
Version of server using (% list -v):
Comments:
END_OF_FILE
if test 468 -ne `wc -c <'src/REGISTRATION'`; then
    echo shar: \"'src/REGISTRATION'\" unpacked with wrong size!
fi
# end of 'src/REGISTRATION'
fi
if test -f 'src/global.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/global.h'\"
else
echo shar: Extracting \"'src/global.h'\" \(1141 characters\)
sed "s/^X//" >'src/global.h' <<'END_OF_FILE'
X/*
X  AGREEMENT: This software can be used and distributed freely as long
X  as you do not remove or alter the Copyright notice in the file defs.h;
X  this notice is #define'd in the symbol VERSION. Although you may alter
X  the code provided, you may not alter the functions create_header()
X  and create_multi_recipient_header() in list.c and listserv.c.
X  By using this software you are bound by this agreement.
X  This software comes with no warranties and cannot be sold for profit.
X  The AGREEMENT and COPYRIGHT notices should be included in all source
X  files when distributing this software.
X  COPYRIGHT: Copyright (c) 1991, Anastasios C. Kotsikonas
X*/
X
char subscribersf [MAX_LINE];
char newsf [MAX_LINE];
char peersf [MAX_LINE];
char aliasesf [MAX_LINE];
char headersf [MAX_LINE];
char restrictedf [MAX_LINE];
char ignoredf [MAX_LINE];
char list_mail_f [MAX_LINE];
char report_listf [MAX_LINE];
char server_ignoredf [MAX_LINE];
char infof [MAX_LINE];
char welcomef [MAX_LINE];
char message_idsf [MAX_LINE];
char message_id [MAX_LINE];
SYS  sys;
COMMANDS commands [MAX_COMMANDS]; /* Set of recognizable commands */
BOOLEAN debug = FALSE;
END_OF_FILE
if test 1141 -ne `wc -c <'src/global.h'`; then
    echo shar: \"'src/global.h'\" unpacked with wrong size!
fi
# end of 'src/global.h'
fi
if test -f 'src/list.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/list.h'\"
else
echo shar: Extracting \"'src/list.h'\" \(2870 characters\)
sed "s/^X//" >'src/list.h' <<'END_OF_FILE'
X/* 
X  AGREEMENT: This software can be used and distributed freely as long
X  as you do not remove or alter the Copyright notice in the file defs.h;
X  this notice is #define'd in the symbol VERSION. Although you may alter
X  the code provided, you may not alter the functions create_header()
X  and create_multi_recipient_header() in list.c and listserv.c.
X  By using this software you are bound by this agreement.
X  This software comes with no warranties and cannot be sold for profit.
X  The AGREEMENT and COPYRIGHT notices should be included in all source
X  files when distributing this software.
X  COPYRIGHT: Copyright (c) 1991, Anastasios C. Kotsikonas
X
X  Below are the #define's pertinent to list.c
X
X  Preserve any quotes and new lines that appear below; change only path names.
X
X  ALWAYS SPECIFY ABSOLUTE PATHS.
X
X*/
X
X#define MAIL_COPY         ".messages"
X#define MSG               ".msg"
X#define MAILFORWARD       ".mailforward"
X#define MSG_NO            ".msgno"
X#define MBOX              "mbox"            /* place to save list's messages */
X#define FROM              "From: " /* Keep this line and the following from */
X#define ORIGIN		  "Originator: "
X#define REPLY_TO	  "Reply-To: "
X#define NO_RECIPIENT_FILE "NONE"
X
X#define PREPEND(str, buf) \
X  { char copy [1024];\
X    RESET (copy);\
X    strcat (copy, buf);\
X    sprintf (buf, "%s%s", str, copy);\
X  }
X
char mboxf [MAX_LINE];
char msg_nof [MAX_LINE];
char mailforwardf [MAX_LINE];
char msgf [MAX_LINE];
char mail_copyf [MAX_LINE];
char list_moderated_f [MAX_LINE];
char **multi_recipients;  /* List of multiple recipient addresses */
char *list_alias  = NULL; /* arg to the -L command option */
X
XFILE *mail        = NULL; /* Source of messages */
XFILE *report      = NULL; /* Progress report to the administrator */
XFILE *subscribers = NULL; /* List of subscribers */
XFILE *news	  = NULL; /* List of newsgroups */
XFILE *peers	  = NULL; /* List of peers */
XFILE *restricted  = NULL; /* List of people whose messages require special
X                              handling */
XFILE *ignored     = NULL; /* List of people whose messages are ignored */
XFILE *msg_no      = NULL; /* Last message count */
XFILE *headers     = NULL; /* File containing headers of messages only */
XFILE *message_ids = NULL; /* File containing message ids */
X
BOOLEAN tty_echo	    = FALSE;/* -e option off */
BOOLEAN send_to_subscribers = TRUE; /* -r option off */
BOOLEAN execute_once        = FALSE;/* -1 option off */
BOOLEAN errors_to_manager   = FALSE;/* -f option off */
BOOLEAN multi_recip	    = FALSE;/* -m option off */
BOOLEAN do_not_check_subscriptions = FALSE;/* -s option off */
BOOLEAN article_replies_to_author  = FALSE;/* -p option off */
int     returned_msg = 0;           /* Counts the invalid messages */
int     public_msg = 0;             /* Counts the public messages */
int     listid = -1;
int	maxrecipients = 0;
END_OF_FILE
if test 2870 -ne `wc -c <'src/list.h'`; then
    echo shar: \"'src/list.h'\" unpacked with wrong size!
fi
# end of 'src/list.h'
fi
if test -f 'src/listserv.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/listserv.h'\"
else
echo shar: Extracting \"'src/listserv.h'\" \(4151 characters\)
sed "s/^X//" >'src/listserv.h' <<'END_OF_FILE'
X/*
X  AGREEMENT: This software can be used and distributed freely as long
X  as you do not remove or alter the Copyright notice in the file defs.h;
X  this notice is #define'd in the symbol VERSION. Although you may alter
X  the code provided, you may not alter the functions create_header()
X  and create_multi_recipient_header() in list.c and listserv.c.
X  By using this software you are bound by this agreement.
X  This software comes with no warranties and cannot be sold for profit.
X  The AGREEMENT and COPYRIGHT notices should be included in all source
X  files when distributing this software.
X  COPYRIGHT: Copyright (c) 1991, Anastasios C. Kotsikonas
X
X  Below are the #define's pertinent to listserv.c
X
X  Preserve any quotes and new lines that appear below; change only path names.
X
X  ALWAYS SPECIFY ABSOLUTE PATHS.
X
X*/
X
X#define UPDATE_DATE	  "December 9, 1991"
X#define MAIL_COPY         PATH/.messages"
X#define OLD_SUBSCRIBERS   PATH/.oldsubscribers"
X#define MAILFORWARD       PATH/.mailforward"
X#define MSG_NO            PATH/.msgno"
X#define RECIP_FILE	  ".recip"
X#define AWK_PROG	  PATH/.awk"
X#define STATS_PROG	  PATH/.stats"
X#define SERVER_MBOX       PATH/mbox"	/* place to save server's messages */
X#define STATS_FILE        "/tmp/stats"
X#define USERS_FILE	  "/tmp/users"
X#define HELP_GENERAL	  PATH/help/general"
X#define HELP_SET	  PATH/help/set"
X#define HELP_SUBSCRIBE	  PATH/help/subscribe"
X#define HELP_UNSUBSCRIBE  PATH/help/unsubscribe"
X#define HELP_RECIPIENTS	  PATH/help/recipients"
X#define HELP_INFORMATION  PATH/help/information"
X#define HELP_STATISTICS	  PATH/help/statistics"
X#define HELP_LISTS	  PATH/help/lists"
X#define HELP_INDEX	  PATH/help/index"
X#define HELP_GET	  PATH/help/get"
X#define HELP_RELEASE	  PATH/help/release"
X#define ARCHIVE_DIR	  PATH/archives"
X#define DEFAULT_ARCHIVE	  "listserv"
X#define INDEX		  "INDEX"
X#define DIR		  "DIR"
X#define PEER_SERVER_REQUEST "Peer Server Request: "
X#define START_OF_SIGNATURE "--"
X#define MAX_SET_OPTIONS	  1 
X
X#define DELIVER_MAIL(recipient) \
X  if (sys.options & USE_SYSMAIL) \
X    sysmail (MAILFORWARD); \
X  else \
X    syscom ("%s %s < %s", sys.mail.method, \
X            (((sys.options & USE_TELNET) == 0) ? locase (recipient) : ""), \
X            MAILFORWARD)
X
X#define APPEND_TELNET(func) \
X  if (sys.options & USE_TELNET) {\
X    if ((f = fopen (MAILFORWARD, "a")) == NULL)\
X      sprintf (error, "%s(): Could not open %s", func, MAILFORWARD),\
X      report_progress (report, error, TRUE),\
X      exit (1);\
X    COMPLETE_FILE (f);\
X    fclose (f);\
X  }
X
X#define NOTIFY_MANAGER(msg) \
X  create_header (&f, MAILFORWARD, sys.server.address, sys.manager, sender);\
X  fprintf (f, "%s %s\n", msg, sender);\
X  COMPLETE_TELNET (f);\
X  fclose (f);\
X  DELIVER_MAIL (sys.manager);\
X  sprintf (error, "%s %s; forwarding message to %s\n", msg, sender,\
X	   sys.manager);\
X  report_progress (report, error, FALSE)
X
X#define NOTIFY_OF_BAD_ARCHIVE(msg, archive) \
X  create_header (&f, MAILFORWARD, sys.server.address, sender, request);\
X  fprintf (f, msg, archive);\
X  COMPLETE_TELNET (f);\
X  fclose (f);\
X  DELIVER_MAIL (sender)
X
X
char recipf [MAX_LINE];	  /* path to list + RECIP_FILE */
X
XFILE *mail        = NULL; /* Source of messages */
XFILE *report      = NULL; /* Progress report to the administrator */
XFILE *subscribers = NULL; /* List of subscribers */
XFILE *ignored     = NULL; /* List of people whose messages are ignored */
XFILE *msg_no      = NULL; /* Last message count */
XFILE *message_ids = NULL; /* List of message ids */
X
int     listid = -1;
int     request_no = 0;             /* Counts the public messages */
int     restricted_commands = 0;    /* Mask of restrictions */
int	disabled_commands = 0;	    /* Mask for disabling commands */
int     nlists = -1;                /* # of lists defined in CONFIG */
BOOLEAN one_rejection = FALSE;
BOOLEAN restart_sys = FALSE;
BOOLEAN tty_echo = FALSE;	    /* -e option off */
BOOLEAN do_not_notify_peer_server = FALSE;
BOOLEAN peer_server_request = FALSE;
char    *options [] = { "MAIL" }; /* valid SET options */
char    *values [] = { "ACK|NOACK|NEVERACK|POSTPONE" }; /* and values */
char    *default_values [] = { "NOACK" };
END_OF_FILE
if test 4151 -ne `wc -c <'src/listserv.h'`; then
    echo shar: \"'src/listserv.h'\" unpacked with wrong size!
fi
# end of 'src/listserv.h'
fi
if test -f 'src/pqueue.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/pqueue.c'\"
else
echo shar: Extracting \"'src/pqueue.c'\" \(3728 characters\)
sed "s/^X//" >'src/pqueue.c' <<'END_OF_FILE'
X/*
X  ----------------------------------------------------------------------------
X  |                    MAIL QUEUE PROCESSING ROUTINES                        |
X  |                                                                          |
X  |                             Version 1.0                                  |
X  |                                                                          |
X  |                (or, when Computer Science gets to you)                   |
X  |                                                                          |
X  |                    Written by Anastasios Kotsikonas                      |
X  |                           (tasos@cs.bu.edu)                              |
X  |                                                                          |
X  | AGREEMENT: This software can be used and distributed freely as long      |
X  | as you do not remove or alter the Copyright notice in the file defs.h;   |
X  | this notice is #define'd in the symbol VERSION. Although you may alter   |
X  | the code provided, you may not alter the functions create_header()       |
X  | and create_multi_recipient_header() in list.c and listserv.c.            |
X  | By using this software you are bound by this agreement.                  |
X  | This software comes with no warranties and cannot be sold for profit.    |
X  | The AGREEMENT and COPYRIGHT notices should be included in all source     |
X  | files when distributing this software.                                   |
X  | COPYRIGHT: Copyright (c) 1991, Anastasios C. Kotsikonas                  |
X  ----------------------------------------------------------------------------
X
X  The 'system' mailmethod is used to attempt another delivery of the
X  specified file. If it cannot be done, the file is queued again.
X*/
X
X#include <stdio.h>
X#include <unistd.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <fcntl.h>
X#include <signal.h>
X#include "defs.h"
X#include "struct.h"
X#include "global.h"
X#include "pqueue.h"
X
extern BOOLEAN sysmail (char *);
X
void   main (int, char **, char **);
void   usage (void);
void   gexit (void);
X
void main (int argc, char **argv, char **envp)
X{
X  char msg [MAX_LINE], *options = "eD";
X  int c;
X  FILE *f;
X  struct stat stat_buf;
X  extern char *optarg;
X  extern int optopt, optind;
X
X  while ((c = getopt (argc, argv, options)) != EOF)
X    switch ((char) c) {
X    case 'e': tty_echo = TRUE; break;
X    case 'D': debug = TRUE; break;
X    case '?':
X    default:
X      usage ();
X  }
X  if (argc < 2)
X    fprintf (stderr, "pqueue: filename(s) missing.\n"),
X    exit (3);
X#ifndef _MINIX
X  if (lockf (open (PQUEUE_LOCK_FILE, O_RDWR), F_TLOCK, 0))
X    fprintf (stderr, "pqueue: Unable to lock %s. Aborting.\n",
X	     PQUEUE_LOCK_FILE),
X    exit (2);
X#endif
X  init_signals();
X  catch_signals();
X  if ((report = fopen (REPORT_PQUEUE, "a")) == NULL)
X    fprintf (stderr, "pqueue: Could not open %s\n", REPORT_PQUEUE),
X    exit (1);
X  if ((f = fopen (PID_PQUEUE, "w")) != NULL)
X    fprintf (f, "%d", getpid()),
X    fclose (f);
X  signal (SIGINT, gexit);
X  while (--argc >= optind) { /* main loop */
X    if (stat (argv [argc], &stat_buf))
X      sprintf (msg, "\nmain(): Could not stat %s", argv [argc]),
X      report_progress (report, msg, TRUE),
X      exit (1);
X    if (sysmail (argv [argc]))
X      if (unlink (argv [argc]))
X	sprintf (msg, "\nmain(): Could not unlink file %s", argv [argc]),
X 	report_progress (report, msg, TRUE),
X	exit (1);
X  }
X  fclose (report);
X  gexit ();
X}
X
void usage ()
X{
X  fprintf (stderr, "Usage: pqueue [-e] [-D] <files>\n\
X-e: Echo reports to the screen.\n\
X-D: Turn debug on.\n");
X  exit (3);
X}
X
X/*
X  Graceful exit. Remove pid file.
X*/
X
void gexit ()
X{
X  unlink (PID_PQUEUE);
X  exit (0);
X}
END_OF_FILE
if test 3728 -ne `wc -c <'src/pqueue.c'`; then
    echo shar: \"'src/pqueue.c'\" unpacked with wrong size!
fi
# end of 'src/pqueue.c'
fi
if test -f 'src/pqueue.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/pqueue.h'\"
else
echo shar: Extracting \"'src/pqueue.h'\" \(911 characters\)
sed "s/^X//" >'src/pqueue.h' <<'END_OF_FILE'
X/*
X  AGREEMENT: This software can be used and distributed freely as long
X  as you do not remove or alter the Copyright notice in the file defs.h;
X  this notice is #define'd in the symbol VERSION. Although you may alter
X  the code provided, you may not alter the functions create_header()
X  and create_multi_recipient_header() in list.c and listserv.c.
X  By using this software you are bound by this agreement.
X  This software comes with no warranties and cannot be sold for profit.
X  The AGREEMENT and COPYRIGHT notices should be included in all source
X  files when distributing this software.
X  COPYRIGHT: Copyright (c) 1991, Anastasios C. Kotsikonas
X
X  Below are the #define's pertinent to pqueue.c
X
X  Preserve any quotes and new lines that appear below; change only path names.
X
X  ALWAYS SPECIFY ABSOLUTE PATHS.
X
X*/
X
XFILE *report		= NULL;  /* Progress report */
BOOLEAN tty_echo	= FALSE; /* -e option off */
END_OF_FILE
if test 911 -ne `wc -c <'src/pqueue.h'`; then
    echo shar: \"'src/pqueue.h'\" unpacked with wrong size!
fi
# end of 'src/pqueue.h'
fi
if test -f 'src/serverd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/serverd.h'\"
else
echo shar: Extracting \"'src/serverd.h'\" \(881 characters\)
sed "s/^X//" >'src/serverd.h' <<'END_OF_FILE'
X/*
X  AGREEMENT: This software can be used and distributed freely as long
X  as you do not remove or alter the Copyright notice in the file defs.h;
X  this notice is #define'd in the symbol VERSION. Although you may alter
X  the code provided, you may not alter the functions create_header()
X  and create_multi_recipient_header() in list.c and listserv.c.
X  By using this software you are bound by this agreement.
X  This software comes with no warranties and cannot be sold for profit.
X  The AGREEMENT and COPYRIGHT notices should be included in all source
X  files when distributing this software.
X  COPYRIGHT: Copyright (c) 1991, Anastasios C. Kotsikonas
X
X  Below are the #define's pertinent to serverd.c
X
X  ALWAYS SPECIFY ABSOLUTE PATHS.
X
X*/
X
X#define LOAD_FILE	 PATH/.load"
X#define MAX_TRIES	 10      /* wait MAX_TRIES * 30 seconds */
X
BOOLEAN tty_echo = FALSE;	 /* -e option off */
END_OF_FILE
if test 881 -ne `wc -c <'src/serverd.h'`; then
    echo shar: \"'src/serverd.h'\" unpacked with wrong size!
fi
# end of 'src/serverd.h'
fi
if test -f 'src/signals.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/signals.c'\"
else
echo shar: Extracting \"'src/signals.c'\" \(2997 characters\)
sed "s/^X//" >'src/signals.c' <<'END_OF_FILE'
X/*
X  ----------------------------------------------------------------------------
X  |                            SIGNAL FUNCTIONS                              |
X  |                                                                          |
X  |                              Version 2.0                                 |
X  |                                                                          |
X  |                (or, when Computer Science gets to you)                   |
X  |                                                                          |
X  |                    Written by Anastasios Kotsikonas                      |
X  |                           (tasos@cs.bu.edu)                              |
X  |                                                                          |
X  | AGREEMENT: This software can be used and distributed freely as long      |
X  | as you do not remove or alter the Copyright notice in the file defs.h;   |
X  | this notice is #define'd in the symbol VERSION. Although you may alter   |
X  | the code provided, you may not alter the functions create_header()       |
X  | and create_multi_recipient_header() in list.c and listserv.c.            |
X  | By using this software you are bound by this agreement.                  |
X  | This software comes with no warranties and cannot be sold for profit.    |
X  | The AGREEMENT and COPYRIGHT notices should be included in all source     |
X  | files when distributing this software.                                   |
X  | COPYRIGHT: Copyright (c) 1991, Anastasios C. Kotsikonas                  |
X  ----------------------------------------------------------------------------
X*/
X
X#include <stdio.h>
X#include <signal.h>
X#include "defs.h"
X#include "struct.h"
X
extern void report_progress (FILE *, char *, int);
X
void   init_signals (void);
void   catch_signals (void);
void   my_abort (int);
X
static char *signals[MAX_SIGNAL + 1];   /* Signal names */
X
X/*
X  Initialize the signals[].
X*/
X
void init_signals ()
X{
X  signals[SIGHUP] = "SIGHUP";
X  signals[SIGINT] = "SIGINT";
X  signals[SIGQUIT] = "SIGQUIT";
X  signals[SIGTERM] = "SIGTERM";
X  signals[SIGBUS] = "SIGBUS";
X  signals[SIGSEGV] = "SIGSEGV";
X}
X
X/*
X  Catch signals to print messages before aborting.
X*/
X
void catch_signals ()
X{
X  signal (SIGHUP, my_abort);
X  signal (SIGQUIT, my_abort);
X  signal (SIGTERM, my_abort);
X  signal (SIGSEGV, my_abort);
X  signal (SIGBUS, my_abort);
X  signal (SIGKILL, my_abort); /* Can't be caught, but why not try? */
X}
X
X/*
X  Kill program after sending message to MANAGER that this is
X  about to happen (message is sent only when using UCB mail).
X*/
X
void my_abort (int sig)
X{
X  extern SYS sys;
X
X  if (sig == SIGHUP) { /* Damn AIX passes signals from children to parents */
X    signal (SIGHUP, my_abort);
X    return;
X  }
X  printf ("\n*** Received %s signal ***\n", signals[sig]);
X  if (sys.options & BSD_MAIL)
X    syscom ("%s -s \"SERVERD/SERVER/LIST received %s\" %s &", UCB_MAIL,
X	    signals[sig], sys.manager);
X  exit (8);
X}
END_OF_FILE
if test 2997 -ne `wc -c <'src/signals.c'`; then
    echo shar: \"'src/signals.c'\" unpacked with wrong size!
fi
# end of 'src/signals.c'
fi
if test -f 'src/start.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/start.h'\"
else
echo shar: Extracting \"'src/start.h'\" \(1197 characters\)
sed "s/^X//" >'src/start.h' <<'END_OF_FILE'
X/*
X  AGREEMENT: This software can be used and distributed freely as long
X  as you do not remove or alter the Copyright notice in the file defs.h;
X  this notice is #define'd in the symbol VERSION. Although you may alter
X  the code provided, you may not alter the functions create_header()
X  and create_multi_recipient_header() in list.c and listserv.c.
X  By using this software you are bound by this agreement.
X  This software comes with no warranties and cannot be sold for profit.
X  The AGREEMENT and COPYRIGHT notices should be included in all source
X  files when distributing this software.
X  COPYRIGHT: Copyright (c) 1991, Anastasios C. Kotsikonas
X
X  Below are the #define's pertinent to start.c
X
X  Preserve any quotes that appear below; change only path names.
X
X  ALWAYS SPECIFY ABSOLUTE PATHS.
X
X*/
X
X#define REPORT_LIST_ACC     ".rep.list.acc"
X#define REPORT_SERVER_ACC   PATH/.rep.server.acc"
X#define REPORT_SERVERD_ACC  PATH/.rep.serverd.acc"
X#define REPORT_START_ACC    PATH/.rep.start.acc"
X#define REPORT_PQUEUE_ACC   PATH/.rep.pqueue.acc"
X#define REPORT_START	    PATH/.report.start"
X#define MODERATED_MAIL_FILE "moderated"
X
char    report_list_accf [MAX_LINE];
BOOLEAN tty_echo = TRUE;
END_OF_FILE
if test 1197 -ne `wc -c <'src/start.h'`; then
    echo shar: \"'src/start.h'\" unpacked with wrong size!
fi
# end of 'src/start.h'
fi
if test -f 'src/struct.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/struct.h'\"
else
echo shar: Extracting \"'src/struct.h'\" \(2195 characters\)
sed "s/^X//" >'src/struct.h' <<'END_OF_FILE'
X/*
X  AGREEMENT: This software can be used and distributed freely as long
X  as you do not remove or alter the Copyright notice in the file defs.h;
X  this notice is #define'd in the symbol VERSION. Although you may alter
X  the code provided, you may not alter the functions create_header()
X  and create_multi_recipient_header() in list.c and listserv.c.
X  By using this software you are bound by this agreement.
X  This software comes with no warranties and cannot be sold for profit.
X  The AGREEMENT and COPYRIGHT notices should be included in all source
X  files when distributing this software.
X  COPYRIGHT: Copyright (c) 1991, Anastasios C. Kotsikonas
X*/
X
typedef struct {
X  struct {
X    char alias [MAX_LINE],	/* as it appears in the aliases file */
X	 comment [MAX_LINE],	/* Comment: line in the outgoing mail message */
X         address [MAX_LINE],	/* full email address of the list */
X         cmdoptions [MAX_LINE];	/* list-specific command line options */
X    int  disabled_commands;	/* mask of disabled commands for this list */
X  } lists [MAX_LISTS];		/* structure for each list */
X  struct {
X    char address [MAX_LINE],	/* full email address of the server */
X	 comment [MAX_LINE],	/* Comment: line in the outgoing mail message */
X         cmdoptions [MAX_LINE],	/* listserv-specific command line options */
X	 password [MAX_LINE];	/* for 'shutdown' and 'restart' */
X  } server;			/* structure for the server */
X  struct {
X    char *method;		/* mail method to use */
X    char env_var [MAX_LINE];	/* environment variable to use */
X    char mail_prog [MAX_LINE];	/* which mail program to use */
X  } mail;			/* mail method structure */
X  struct {
X    long int msg;		/* maximum message limit in bytes */
X  } limits;
X  char serverd_cmdoptions [MAX_LINE];/* command line options */
X  char manager [MAX_LINE];	/* manager of the system */
X  char arg [MAX_LINE];		/* temporary storage */
X  char organization [MAX_LINE]; /* Organization's name */
X  int users;			/* used by listserv when -r is given */
X  int frequency;		/* how often to read mail */
X  long int options;		/* various flags: BSD_PS, USE_TELNET, etc. */
X} SYS;
X
typedef struct {
X  char *name;
X  int  mask;
X  void (*func)();
X} COMMANDS;
END_OF_FILE
if test 2195 -ne `wc -c <'src/struct.h'`; then
    echo shar: \"'src/struct.h'\" unpacked with wrong size!
fi
# end of 'src/struct.h'
fi
if test -f 'src/tlock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/tlock.c'\"
else
echo shar: Extracting \"'src/tlock.c'\" \(2280 characters\)
sed "s/^X//" >'src/tlock.c' <<'END_OF_FILE'
X/*
X  ----------------------------------------------------------------------------
X  |                		tlock UTILITY 				     |
X  |                                                                          |
X  |                              Version 1.0                                 |
X  |                                                                          |
X  |                (or, when Computer Science gets to you)                   |
X  |                                                                          |
X  |                    Written by Anastasios Kotsikonas                      |
X  |                           (tasos@cs.bu.edu)                              |
X  |                                                                          |
X  | AGREEMENT: This software can be used and distributed freely as long      |
X  | as you do not remove or alter the Copyright notice in the file defs.h;   |
X  | this notice is #define'd in the symbol VERSION. Although you may alter   |
X  | the code provided, you may not alter the functions create_header()       |
X  | and create_multi_recipient_header() in list.c and listserv.c.            |
X  | By using this software you are bound by this agreement.                  |
X  | This software comes with no warranties and cannot be sold for profit.    |
X  | The AGREEMENT and COPYRIGHT notices should be included in all source     |
X  | files when distributing this software.                                   |
X  | COPYRIGHT: Copyright (c) 1991, Anastasios C. Kotsikonas                  |
X  ----------------------------------------------------------------------------
X*/
X
X#include <stdio.h>
X#include <unistd.h>
X#include <fcntl.h>
X#include <errno.h>
X#include "defs.h"
X
void main ();
X
char *s[] = { 
X  SERVERD_LOCK_FILE, LIST_LOCK_FILE, SERVER_LOCK_FILE, PQUEUE_LOCK_FILE, NULL
X};
X
X/*
X  Test whether any locks exist on the above files by other processes.
X*/
X
void main ()
X{
X#ifndef _MINIX
X  int i, fd, locks = 0;
X
X  for (i = 0; s[i]; i++) {
X    if (lockf ((fd = open (s[i], O_RDWR)), F_TLOCK, 0))
X      if (errno == EBADF)
X	locks = -1,
X	fprintf (stderr, "Cannot access %s\n", s[i]);
X      else
X	++locks,
X	printf ("Lock placed on %s\n", s[i]);
X    close (fd);
X  }
X  if (!locks)
X#endif
X    printf ("No files locked.\n");
X}
END_OF_FILE
if test 2280 -ne `wc -c <'src/tlock.c'`; then
    echo shar: \"'src/tlock.c'\" unpacked with wrong size!
fi
# end of 'src/tlock.c'
fi
if test -f 'stds' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stds'\"
else
echo shar: Extracting \"'stds'\" \(354 characters\)
sed "s/^X//" >'stds' <<'END_OF_FILE'
X#!/bin/sh
if [ $# = 0 ]; then
X  echo Usage: `basename $0` \<system source C and header files\>
fi
for i
do
X  if [ ! -r $i ]; then
X    echo $i: not found
X  else
X    echo $i
X    sed 's/\"\/usr\/server/\"\/usr\/server\"/' $i > /tmp/s
X    sed 's/PATH\//\"\/usr\/server\//' /tmp/s > /tmp/t
X    sed 's/PATH\"/PATH/' /tmp/t > $i 
X    rm /tmp/t /tmp/s
X  fi
done
END_OF_FILE
if test 354 -ne `wc -c <'stds'`; then
    echo shar: \"'stds'\" unpacked with wrong size!
fi
chmod +x 'stds'
# end of 'stds'
fi
if test -f 'ulock' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ulock'\"
else
echo shar: Extracting \"'ulock'\" \(133 characters\)
sed "s/^X//" >'ulock' <<'END_OF_FILE'
X#!/bin/sh
X# ulock - in conjunction with the file 'flocks', this utility removes all
X#        locked files.
X/lib/cpp flocks | /bin/sh
END_OF_FILE
if test 133 -ne `wc -c <'ulock'`; then
    echo shar: \"'ulock'\" unpacked with wrong size!
fi
# end of 'ulock'
fi
echo shar: End of archive 1 \(of 6\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
