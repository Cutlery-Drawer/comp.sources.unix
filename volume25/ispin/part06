Newsgroups: comp.sources.unix
From: sir-alan!ispin!lbartz@iuvax.cs.indiana.edu (Larry Bartz)
Subject: v25i117: Indianapolis Standard Printer Interface for Networked printers, Part06/15
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: sir-alan!ispin!lbartz@iuvax.cs.indiana.edu (Larry Bartz)
Posting-Number: Volume 25, Issue 117
Archive-Name: ispin/part06

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 15)."
# Contents:  ISPIN/src/IQUEUER.c.ab
#   ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/C351_PLAIN
#   ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/PLAIN
#   ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_NOSHT
#   ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_SHT
#   ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/C351_PLAIN
#   ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/PLAIN
#   ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_NOSHT
#   ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_SHT
#   ISPIN/install/Makefile ISPIN/install/install.sh
#   ISPIN/install/split_it.sh ISPIN/doc/future.doc
#   ISPIN/misc/ISPIT.dr/eot_trap.c
# Wrapped by socrates@indy6 on Tue Jan 28 15:26:43 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ISPIN/src/IQUEUER.c.ab' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/src/IQUEUER.c.ab'\"
else
echo shar: Extracting \"'ISPIN/src/IQUEUER.c.ab'\" \(30223 characters\)
sed "s/^X//" >'ISPIN/src/IQUEUER.c.ab' <<'END_OF_FILE'
X  while(count1 < intsize)
X  {
X    msg_buf[count2++] = out_msg.pad1.chr[count1++];
X  }
X  count1 = 0;
X
X
X  /* send the message to the ISPIN's FIFO */
X
X  if((kill(c_curr_dsptch->job_id.my_pid.intgr, 0)) == -1)
X  {
X    /* the ISPIN died or was killed before we could help him */
X    ret_val = clean_out(c_curr_dsptch->job_id.my_pid.intgr);
X    close(outfifo);
X    return(0);
X  }
X
X  write(outfifo,msg_buf,to_ispinsiz);
X
X  close(outfifo);
X}
X
X
Xqueue_it()
X{
X
X  struct wait_queue *c_head_wait;
X  struct wait_queue *c_curr_wait;
X  struct wait_queue *c_list_wait;
X  struct wait_queue *c_hold_wait;
X
X  /* set the local pointers to aim at the true head of the list */
X  c_head_wait = c_curr_wait = c_list_wait = c_hold_wait = head_wait;
X
X  /* walk the list */
X
X/* what if at very beginning of list */
X
X  while(c_curr_wait->next != NULL)
X    c_curr_wait = c_curr_wait->next;
X
X  /* create a new list member */
X  /* allocate memory for the new member of the list */
X  c_curr_wait->next = (struct wait_queue *) calloc(1,sizeof(struct wait_queue));
X      
X  /* point the new one back at the current one */
X  c_curr_wait->next->prev = c_curr_wait;
X
X  /* change our notion of "current" to the new one */
X  c_curr_wait = c_curr_wait->next;
X
X  /* terminate the list */
X  c_curr_wait->next = NULL;
X
X  /* fill the new structure */
X
X  c_curr_wait->job_id.typ.intgr        =  WAITING;
X  c_curr_wait->job_id.my_pid.intgr     =  incoming.my_pid.intgr;
X  c_curr_wait->job_id.my_fifo.intgr    =  incoming.my_fifo.intgr;
X  c_curr_wait->devinod[0] = c_curr_wait->job_id.dev1_inod.intgr  
X    =  incoming.dev1_inod.intgr;
X  c_curr_wait->devinod[1] = c_curr_wait->job_id.dev2_inod.intgr  
X    =  incoming.dev2_inod.intgr;
X  c_curr_wait->devinod[2] = c_curr_wait->job_id.dev3_inod.intgr  
X    =  incoming.dev3_inod.intgr;
X  c_curr_wait->devinod[3] = c_curr_wait->job_id.dev4_inod.intgr  
X    =  incoming.dev4_inod.intgr;
X  c_curr_wait->devinod[4] = c_curr_wait->job_id.dev5_inod.intgr  
X    =  incoming.dev5_inod.intgr;
X  c_curr_wait->devinod[5] = c_curr_wait->job_id.dev6_inod.intgr  
X    =  incoming.dev6_inod.intgr;
X  c_curr_wait->devinod[6] = c_curr_wait->job_id.dev7_inod.intgr  
X    =  incoming.dev7_inod.intgr;
X  c_curr_wait->devinod[7] = c_curr_wait->job_id.dev8_inod.intgr  
X    =  incoming.dev8_inod.intgr;
X  c_curr_wait->devinod[8] = c_curr_wait->job_id.dev9_inod.intgr  
X    =  incoming.dev9_inod.intgr;
X  c_curr_wait->devinod[9] = c_curr_wait->job_id.dev10_inod.intgr  
X    =  incoming.dev10_inod.intgr;
X  c_curr_wait->devinod[10] = c_curr_wait->job_id.dev11_inod.intgr  
X    =  incoming.dev11_inod.intgr;
X  c_curr_wait->job_id.uid.intgr        =  incoming.uid.intgr;
X  c_curr_wait->job_id.loop.intgr       =  incoming.loop.intgr;
X  /* tloc was set in switch case HERE of main() */
X  c_curr_wait->time_in           =  tloc;
X
X}
X
X
Xcheck_queue()
X{
X  int in_use, ivar;
X
X  struct go_list *c_head_dsptch;
X  struct go_list *c_curr_dsptch;
X  struct go_list *c_list_dsptch;
X  struct go_list *c_hold_dsptch;
X
X  struct wait_queue *c_head_wait;
X  struct wait_queue *c_curr_wait;
X  struct wait_queue *c_list_wait;
X  struct wait_queue *c_hold_wait;
X
X  /* set the local pointers to aim at the true head of the list */
X  c_head_wait = c_curr_wait = c_list_wait = c_hold_wait = head_wait;
X
X  /* Are any of the devices (upon which jobs are waiting) available now? */
X  /* If so, get them going and re-org the wait list.                     */
X
X  /* who is waiting? */
X  while(c_curr_wait->next != NULL)
X  {
X      c_curr_wait = c_curr_wait->next;
X
X      /* check the go_list to see if the device is in use */
X
X      /* check for the availability of each device(tty) which the job can */
X      /* be sent through.                                                 */
X      for (ivar = 0; ivar < 11 && c_curr_wait->devinod[ivar] > 0; ivar++)
X        {
X          in_use = 0;
X
X          /* set the local pointers to aim at the true head of the list */
X          c_head_dsptch = c_curr_dsptch = c_list_dsptch = c_hold_dsptch 
X            = head_dsptch;
X          while(c_curr_dsptch->next != NULL)
X            {
X              c_curr_dsptch = c_curr_dsptch->next;
X              if(c_curr_dsptch->devinod == c_curr_wait->devinod[ivar])
X                {
X                  in_use = 1;
X                  break;
X                }
X            }
X          if (in_use == 0)  /* if the device in devinod[ivar] is not being used */
X          {
X            strcpy(lil_buf,myncheck(c_curr_wait->devinod[ivar],"/dev"));
X            /* we'll try to create a lockfile for the tty we want */
X            in_use = lockit(lil_buf);
X            if(in_use == 0)
X            {
X              break;
X            }
X          }
X        }
X
X
X      if(in_use == 0)
X      {
X        /* The device is not in use, so the waiting job may be issued.       */
X        /* If we got this far, we also know we have the lockfile controlled. */
X
X        ret_val = go_for_it(&c_curr_wait->job_id,c_curr_wait->devinod[ivar],c_curr_wait->time_in);
X
X        /* now re-arrange the wait list to delete the one we just issued */
X        
X        /* cut our guy out from between his neighbors */
X
X        if(c_curr_wait->next != NULL)
X        {
X          /* if we're not at the end of the list */
X          c_curr_wait->prev->next = c_curr_wait->next;
X          c_curr_wait->next->prev = c_curr_wait->prev;
X        }
X        else
X        {
X          /* if we are at the end of the list */
X          c_curr_wait->prev->next = NULL;
X        }
X
X        /* hold onto the memory location we're about to free */
X
X        c_hold_wait = c_curr_wait;
X
X        /* Shortly, the local curr_wait will be pointing at thin air. */
X        /* Aim it at a valid memory location.                         */
X
X        c_curr_wait = c_curr_wait->prev;
X
X        /* if you love someone, set them free */
X
X        free(c_hold_wait);
X      }
X  }
X
X}
X
X
Xwrite_status()
X{
X
X  int chars;
X
X  /* read go_list and wait list, gather up all the info, write to statFIFO */
X
X  /* We don't have to worry about competing writers to the status fifo.    */
X  /* We are the only writer, and only one of us will ever exist at any     */
X  /* given time. So, we can write one record at a time, indicating the     */
X  /* last record by all zeros. If we have nothing to report, the first     */
X  /* record will be all zeros.                                             */
X  /*                                                                       */
X  /* We do, however, have to worry about competing readers of statFIFO.    */
X  /* Multiple near-simultaneous invocations of IQ (the status inquirer)   */
X  /* may result in interleaved reads from statFIFO. NG (no good).          */
X  /*                                                                       */
X  /* To prevent this unhappy occurance, IQUEUER will retain (as a global   */
X  /* variable) the pid of the last previous IQ. If that process still      */
X  /* exists, the newer IQ's request will not be satisfied. We'll send a    */
X  /* SIGNAL (SIGTERM) back to the new guy, upon receipt of which he (the   */
X  /* unsatisfied IQ) will report to the invoker (user) that another        */
X  /* inquiry is currently being served. The unsatisfied user of IQ will    */
X  /* will then be welcome to try again or go into a dark corner and cry.   */
X  /* This singular (for this application) usage of signals is the main     */
X  /* reason IQUEUER must, must, MUST be invoked by the superuser.          */
X  /* Otherwise, we could not guarantee that the signal we send will get    */
X  /* through to the interrupting IQ process.                               */
X  /*                                                                       */
X  /* If the last previous IQ does not exist, it would behoove us to make   */
X  /* darned sure the statFIFO is completely empty before we write into it. */
X  /* What if the last-served IQ didn't read everything we sent down the    */
X  /* pipe? Just another golden opportunity for one IQ picking up what we   */
X  /* meant to send to another. NG.                                         */
X
X  if(iq_pid != 31999)
X  {
X    /* this is not the first time down here during this invocation */
X
X    /* does the last request we satisfied still exist? */
X    if(kill(iq_pid, 0) == 0)
X    {
X      /* tell the new requester we can't help him right now */
X      kill(incoming.my_pid.intgr, SIGTERM);
X      return(0);
X    }
X  }
X
X
X  iq_pid = incoming.my_pid.intgr;
X
X  /* is the status fifo empty? */
X
X  if((statdump = open(statFIFO,O_RDONLY | O_NDELAY)) != -1)
X  {
X    /* if the open does not fail */
X    /* read from the fifo until it is empty */
X    chars = 1;
X    while(chars > 0)
X    {
X      /* if there are any chars in there, just throw them away */
X      chars = read(statdump,"/dev/null", BUFSIZ);
X    }
X
X    close(statdump);
X  }
X  /* check both of our lists, write any valid records to the statFIFO */
X
X  /* check the go_list first */
X
X  /* walk the list */
X
X  while(curr_dsptch->next != NULL)
X  {
X    curr_dsptch = curr_dsptch->next;
X    /* fill the to_iq struct and write it */
X    count1 = count2 = 0;
X
X    to_IQ.typ.lng      = (long)curr_dsptch->job_id.typ.intgr;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.typ.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.devinod.lng    = (long)curr_dsptch->devinod;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.devinod.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.my_fifo.lng  = (long)curr_dsptch->job_id.my_fifo.intgr;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.my_fifo.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.pid.lng      = (long)curr_dsptch->job_id.my_pid.intgr;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.pid.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.time_in.lng  = (long)curr_dsptch->time_in;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.time_in.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.time_out.lng = (long)curr_dsptch->time_out;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.time_out.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.uid.lng      = (long)curr_dsptch->job_id.uid.intgr;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.uid.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.loop.lng     = (long)curr_dsptch->job_id.loop.intgr;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.loop.chr[count1++];
X    }
X    count1 = 0;
X
X
X    write(statfifo,msg_buf,to_iq_siz);
X  }
X
X  /* check the wait_queue next */
X
X  /* walk the list */
X
X  while(curr_wait->next != NULL)
X  {
X    curr_wait = curr_wait->next;
X
X      /* fill the to_iq struct and write it */
X    count1 = count2 = 0;
X
X    to_IQ.typ.lng      = (long)curr_wait->job_id.typ.intgr;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.typ.chr[count1++];
X    }
X    count1 = 0;
X
X    /* Use -1 for device inode number since this job is waiting and has */
X    /* not yet been assigned a device. "iq" will know that -1 signifies */
X    /* unassigned.                                                      */
X
X    to_IQ.devinod.lng    = (long) -1;
X    /* to_IQ.devinod.lng    = (long)curr_wait->devinod; - old logic */
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.devinod.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.my_fifo.lng  = (long)curr_wait->job_id.my_fifo.intgr;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.my_fifo.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.pid.lng      = (long)curr_wait->job_id.my_pid.intgr;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.pid.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.time_in.lng  = (long)curr_wait->time_in;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.time_in.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.time_out.lng = 0L;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.time_out.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.uid.lng      = (long)curr_wait->job_id.uid.intgr;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.uid.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.loop.lng     = (long)curr_wait->job_id.loop.intgr;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.loop.chr[count1++];
X    }
X    count1 = 0;
X
X
X    write(statfifo,msg_buf,to_iq_siz);
X  }
X      /* fill the to_iq struct with zeroes and write it */
X    count1 = count2 = 0;
X
X    to_IQ.typ.lng      = 0L; 
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.typ.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.devinod.lng    = 0L;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.devinod.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.my_fifo.lng  = 0L;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.my_fifo.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.pid.lng      = 0L;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.pid.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.time_in.lng  = 0L;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.time_in.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.time_out.lng = 0L;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.time_out.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.uid.lng      = 0L;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.uid.chr[count1++];
X    }
X    count1 = 0;
X
X    to_IQ.loop.lng     = 0L;
X    while(count1 < longsize)
X    {
X      msg_buf[count2++] = to_IQ.loop.chr[count1++];
X    }
X    count1 = 0;
X
X
X    count1 = write(statfifo,msg_buf,to_iq_siz);
X    count1 = 0;
X}
X
X
Xmy_error(reason)
Xint reason;
X{
X 
X  switch(reason)
X  {
X    case NO_EXIT:
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X            return(0);
X      break;
X    case SIGTERM:
X  /************************************************************************/
X  /* Reset traps on all signals!                                          */
X  /* We don't want to be interrupted when we already know we're           */
X  /* on our way out!                                                      */
X  /************************************************************************/
X
X/* take care of the signals */
X        signal(SIGINT, SIG_IGN);    /* ignore "interrupt" signal <DEL> */
X        signal(SIGHUP, SIG_IGN);    /* ignore "hang up" signal */
X        signal(SIGQUIT, SIG_IGN);   /* ignore "quit" signal */
X        signal(SIGALRM, SIG_IGN);   /* ignore "alarm" signal */
X        signal(SIGTERM, SIG_IGN);   /* ignore "term" signal */
X#ifdef NQ
X        signal(SIGRES, SIG_IGN);     /* ignore "restart" signal */
X        signal(SIGBACK, SIG_IGN);   /* ignore "back-up" signal */
X        signal(SIGSTOP, SIG_IGN);   /* ignore "stop" signal */
X#endif
X            /* format an error message */
X            time(&tloc);
X            nowtime = (struct tm *)localtime(&tloc);
X            time_str = asctime(nowtime);
X            strcpy(errmsg,"IQUEUER: received SIGTERM. time:\n");
X            strcat(errmsg,"                            ");
X            strcat(errmsg,time_str);
X            strcat(errmsg,"\n");
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X            my_exit(reason);
X      break;
X    case SIGHUP:
X  /************************************************************************/
X  /* Reset traps on all signals!                                          */
X  /* We don't want to be interrupted when we already know we're           */
X  /* on our way out!                                                      */
X  /************************************************************************/
X
X/* take care of the signals */
X        signal(SIGINT, SIG_IGN);    /* ignore "interrupt" signal <DEL> */
X        signal(SIGHUP, SIG_IGN);    /* ignore "hang up" signal */
X        signal(SIGQUIT, SIG_IGN);   /* ignore "quit" signal */
X        signal(SIGALRM, SIG_IGN);   /* ignore "alarm" signal */
X        signal(SIGTERM, SIG_IGN);   /* ignore "term" signal */
X#ifdef NQ
X        signal(SIGRES, SIG_IGN);     /* ignore "restart" signal */
X        signal(SIGBACK, SIG_IGN);   /* ignore "back-up" signal */
X        signal(SIGSTOP, SIG_IGN);   /* ignore "stop" signal */
X#endif
X            /* format an error message */
X            time(&tloc);
X            nowtime = (struct tm *)localtime(&tloc);
X            time_str = asctime(nowtime);
X            strcpy(errmsg,"IQUEUER: received SIGHUP. time:\n");
X            strcat(errmsg,"                            ");
X            strcat(errmsg,time_str);
X            strcat(errmsg,"\n");
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X            my_exit(reason);
X      break;
X#ifdef NQ
X    case SIGSTOP:
X  /************************************************************************/
X  /* Reset traps on all signals!                                          */
X  /* We don't want to be interrupted when we already know we're           */
X  /* on our way out!                                                      */
X  /************************************************************************/
X
X/* take care of the signals */
X        signal(SIGINT, SIG_IGN);    /* ignore "interrupt" signal <DEL> */
X        signal(SIGHUP, SIG_IGN);    /* ignore "hang up" signal */
X        signal(SIGQUIT, SIG_IGN);   /* ignore "quit" signal */
X        signal(SIGALRM, SIG_IGN);   /* ignore "alarm" signal */
X        signal(SIGTERM, SIG_IGN);   /* ignore "term" signal */
X        signal(SIGRES, SIG_IGN);     /* ignore "restart" signal */
X        signal(SIGBACK, SIG_IGN);   /* ignore "back-up" signal */
X        signal(SIGSTOP, SIG_IGN);   /* ignore "stop" signal */
X
X            /* format an error message */
X            time(&tloc);
X            nowtime = (struct tm *)localtime(&tloc);
X            time_str = asctime(nowtime);
X            strcpy(errmsg,"IQUEUER: received SIGSTOP. time:\n");
X            strcat(errmsg,"                            ");
X            strcat(errmsg,time_str);
X            strcat(errmsg,"\n");
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X            my_exit(reason);
X      break;
X#endif
X    default:
X  /************************************************************************/
X  /* Reset traps on all signals!                                          */
X  /* We don't want to be interrupted when we already know we're           */
X  /* on our way out!                                                      */
X  /************************************************************************/
X
X/* take care of the signals */
X        signal(SIGINT, SIG_IGN);    /* ignore "interrupt" signal <DEL> */
X        signal(SIGHUP, SIG_IGN);    /* ignore "hang up" signal */
X        signal(SIGQUIT, SIG_IGN);   /* ignore "quit" signal */
X        signal(SIGALRM, SIG_IGN);   /* ignore "alarm" signal */
X        signal(SIGTERM, SIG_IGN);   /* ignore "term" signal */
X#ifdef NQ
X        signal(SIGRES, SIG_IGN);     /* ignore "restart" signal */
X        signal(SIGBACK, SIG_IGN);   /* ignore "back-up" signal */
X        signal(SIGSTOP, SIG_IGN);   /* ignore "stop" signal */
X#endif
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X            my_exit(reason);
X      break;
X  }
X}
X
X
Xmy_exit(reason)
Xint reason;
X{
X  switch(reason)
X  {
X    case 0:
X      exit(0);
X      break;
X
X    case SIGTERM:
X    case SIGHUP:
X      exit(1);
X      break;
X
X    case NONOTIFY:
X      exit(1);
X      break;
X
X#ifdef NQ
X    case SIGSTOP:
X      exit(1);
X      break;
X#endif
X
X    default:
X      exit(1);
X      break;
X  }
X}
X
X
Xtimeout(sig)
Xint sig;
X{
X  signal (SIGALRM, timeout);    /* set up the signal call again */
X  time_out = 1;
X  return;
X}
X
X
Xnewstate(pid,state)
Xint pid, state;
X{
X  /* we are given the pid and new state of the job from whichever list */
X
X  /* some strictly local pointers which mimic the global ones */
X
X  struct wait_queue *c_head_wait;
X  struct wait_queue *c_curr_wait;
X  struct wait_queue *c_list_wait;
X  struct wait_queue *c_hold_wait;
X
X  struct go_list *c_head_dsptch;
X  struct go_list *c_curr_dsptch;
X  struct go_list *c_list_dsptch;
X  struct go_list *c_hold_dsptch;
X
X  /* set the local pointers to aim at the true heads of the lists */
X  c_head_wait = c_curr_wait = c_list_wait = c_hold_wait = head_wait;
X  c_head_dsptch = c_curr_dsptch = c_list_dsptch = c_hold_dsptch = head_dsptch;
X
X  /* check the go_list first */
X
X  /* walk the list */
X
X  while(c_curr_dsptch->next != NULL)
X  {
X    c_curr_dsptch = c_curr_dsptch->next;
X
X    if(c_curr_dsptch->job_id.my_pid.intgr == pid)
X    {
X      /* update the status */
X      c_curr_dsptch->job_id.typ.intgr = state;
X      time(&tloc);
X      c_curr_dsptch->time_out         =  tloc;
X      return(0);
X    }
X  }
X
X  /* check the wait_queue next */
X
X  /* walk the list */
X
X  while(c_curr_wait->next != NULL)
X  {
X    c_curr_wait = c_curr_wait->next;
X
X    if(c_curr_wait->job_id.my_pid.intgr == pid)
X      {
X        /* update the status */
X        c_curr_wait->job_id.typ.intgr = state;
X        return(0);
X      }
X  }
X}
X
X
X
Xfirstime(pid)
Xint pid;
X{
X  /* we are given the pid of the job from whichever list */
X
X  /* some strictly local pointers which mimic the global ones */
X
X  struct wait_queue *c_head_wait;
X  struct wait_queue *c_curr_wait;
X  struct wait_queue *c_list_wait;
X  struct wait_queue *c_hold_wait;
X
X  struct go_list *c_head_dsptch;
X  struct go_list *c_curr_dsptch;
X  struct go_list *c_list_dsptch;
X  struct go_list *c_hold_dsptch;
X
X  /* set the local pointers to aim at the true heads of the lists */
X  c_head_wait = c_curr_wait = c_list_wait = c_hold_wait = head_wait;
X  c_head_dsptch = c_curr_dsptch = c_list_dsptch = c_hold_dsptch = head_dsptch;
X
X  /* check the go_list first */
X
X  /* walk the list */
X
X  while(c_curr_dsptch->next != NULL)
X  {
X    c_curr_dsptch = c_curr_dsptch->next;
X
X    if(c_curr_dsptch->job_id.my_pid.intgr == pid)
X    {
X      /* save the old time */
X      oldtime = c_curr_dsptch->time_in;
X      return(0);
X    }
X  }
X
X  /* check the wait_queue next */
X
X  /* walk the list */
X
X  while(c_curr_wait->next != NULL)
X  {
X    c_curr_wait = c_curr_wait->next;
X
X
X    if(c_curr_wait->job_id.my_pid.intgr == pid)
X      {
X        /* save the old time */
X        oldtime = c_curr_wait->time_in;
X        return(0);
X      }
X  }
X}
X
X/**************************************************************************/
X/*                                                                        */
X/* MYNCHECK                                                               */
X/*                                                                        */
X/* 04/20/89 L. Bartz, Internal Revenue Service, Indianapolis              */
X/*                                                                        */
X/* This function is given an inode number and (pointer to) directory      */
X/* name. It returns (pointer to) file name associated with the inode      */
X/* number on success, null character pointer on failure.                  */
X/*                                                                        */
X/* Must have been declared in the calling function like so:               */
X/*                                                                        */
X/*                        char *myncheck();                               */
X/* Called like so:                                                        */
X/*                                                                        */
X/*                  strcpy(fylname,myncheck(inode,dirname));              */
X/*                                                                        */
X/* Where variables have been declared in the calling function like so:    */
X/*                                                                        */
X/*                  int inode;                                            */
X/*                  char *dirname;                                        */
X/*                  char fylname[DIRSIZ + 1];                             */
X/*                                                                        */
X/* DIRSIZ is #defined in sys/dir.h                                        */
X/*                                                                        */
X/*                                                                        */
X/*                                                                        */
X/* 05/11/90  LSB  - Modified for enhanced portability to accomodate the   */
X/*                  more modern "dirent" directory structure and related  */
X/*                  family of directory access routines.                  */
X/*                  Presently only good for those dirent-style systems    */
X/*                  which support a vestigal sys/dir.h file and a         */
X/*                  struct dirent which is named "direct" for backwards   */
X/*                  compatibility.                                        */
X/*                                                                        */
X/*                                                                        */
X/**************************************************************************/
Xchar *myncheck(inode,dirname)
Xint inode;
Xchar *dirname;
X{
X/* uncomment the following if not elsewhere included */
X/* #include <stdio.h> */
X
X/* uncomment the following if not elsewhere included */
X/* #include <sys/types.h> */
X
X/* uncomment the following if not elsewhere included */
X/* #include <sys/dir.h> */
X
X
X  int rtrnval = 1;
X
X#ifdef MODERN_DIRS
X/* uncomment the following if not elsewhere included */
X/* #include <strings.h> */
X
X  DIR *file1;
X  struct direct *dp;
X  char dir_name[MAXNAMLEN+1];
X#else
X/* uncomment the following if not elsewhere included */
X/* #include <string.h> */
X/* uncomment the following if not elsewhere included */
X/* #include <fcntl.h> */
X  FILE *file1;
X  struct direct dir1;
X#endif
X
X
X
X#ifdef MODERN_DIRS
X
X        file1 = opendir(dirname);
X
X        while((dp = readdir(file1)) != NULL )
X        {
X          if((int)dp->d_ino == inode)
X          {
X            strcpy(&dir_name[0], dp->d_name);
X	    closedir(file1);
X            return((char *) &dir_name[0]);
X          }
X        }
X        closedir(file1);
X        
X#else
X        file1 = fopen(dirname,"r");
X
X        while(rtrnval > 0)
X        {
X          rtrnval = fread(&dir1,sizeof(struct direct),1,file1);
X          if((int)dir1.d_ino == inode)
X          {
X	    fclose(file1);
X            return((char *) &dir1.d_name[0]);
X          }
X        }
X        fclose(file1);
X#endif
X
X        /* we didn't find it */
X        return((char *) 0);
X}
X
X/**************************************************************************/
X/*                                                                        */
X/* LOCKIT                                                                 */
X/*                                                                        */
X/* 05/11/90 L. Bartz, Internal Revenue Service, Indianapolis              */
X/*                                                                        */
X/* This function is given a (pointer to) a tty name for which a lock      */
X/* file is to be created. It returns zero on success, else non-zero.      */
X/*                                                                        */
X/* LOCKIT honors all "foreign" lockfiles.                                 */
X/*                                                                        */
X/* The lockfile LOCKIT creates is meant to be unassailable by competing   */
X/* processes.                                                             */
X/*                                                                        */
X/*                                                                        */
X/**************************************************************************/
Xlockit(lck_tty)
Xchar *lck_tty;
X{
X
X  /* uncomment this if these are not included or def'd elsewhere
X
X  #include <stdio.h>
X  #include <sys/types.h>
X  #include <sys/stat.h>
X  #include <signal.h>
X  #include <fcntl.h>
X  #include <termio.h>
X  #include <sys/errno.h>
X
X  char *strcpy();
X  char *strcat();
X  unsigned sleep();
X  unsigned alarm();
X  void exit();
X
X
X  end of commented-out section */
X
X  int rtrnval;
X
X 
X  /* create a lock file name */
X
X  strcpy(tty_lock,LCK_DIR);
X  strcat(tty_lock,"LCK..");
X  strcat(tty_lock,lck_tty);
X
X  oumask = umask(077);
X
X  /* My lockfile is a directory file with completely closed permissions, so */
X  /* no competing process can trash it without my permission.               */
X
X#ifdef MKDIR
X
X  /* for Berzerkeley systems and others */
X  if(mkdir(tty_lock,0) != SUCCESS)
X  {
X    sprintf(errmsg,"IQUEUER: mkdir %s: %s. time:\n",tty_lock,sys_errlist[errno]);
X    /* need to send out an error msg */
X    /* format an error message */
X    time(&tloc);
X    nowtime = (struct tm *)localtime(&tloc);
X    time_str = asctime(nowtime);
X    strcat(errmsg,time_str);
X    strcat(errmsg,"\n");
X
X   /* call the error routine, don't exit */
X   rtrnval = my_error(NO_EXIT);
X
X   umask(oumask);
X   return(1);
X
X  }
X
X#else
X
X  if(mknod(tty_lock,0040777,1) != SUCCESS)
X  {
X    sprintf(errmsg,"IQUEUER: mknod %s: %s. time:\n",tty_lock,sys_errlist[errno]);
X    /* need to send out an error msg */
X    /* format an error message */
X    time(&tloc);
X    nowtime = (struct tm *)localtime(&tloc);
X    time_str = asctime(nowtime);
X    strcat(errmsg,time_str);
X    strcat(errmsg,"\n");
X
X   /* call the error routine, don't exit */
X   rtrnval = my_error(NO_EXIT);
X
X   umask(oumask);
X   return(1);
X
X  }
X
X
X#endif
X
X
X  /* A "known" DYNIX bug requires this.                 */
X  /* The unlink(2) of the directory will fail unless    */
X  /* the directory contains valid "." and ".." entries. */
X  /*                                      05/15/90  LSB */
X#ifdef DYNIX
X  /* dot */
X  strcpy(lil_buf,tty_lock);
X  strcat(lil_buf,"/.");
X  link(tty_lock,lil_buf);
X  /* dot-dot */
X  strcat(lil_buf,".");
X  link(LCK_DIR,lil_buf);
X#endif
X  return(0);
X}
END_OF_FILE
if test 30223 -ne `wc -c <'ISPIN/src/IQUEUER.c.ab'`; then
    echo shar: \"'ISPIN/src/IQUEUER.c.ab'\" unpacked with wrong size!
fi
# end of 'ISPIN/src/IQUEUER.c.ab'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/C351_PLAIN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/C351_PLAIN'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/C351_PLAIN'\" \(548 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/C351_PLAIN' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X# substitute your node/link.channel for 999/1.11.
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-Bfound;-DSystem?;-Q\w\K\d;-Q\pbye\d;System?-\p\K\pbye\r\p-System?;\d999/1.11\r\d;connect-\p\K\dbye\r\d\d999/1.11\r\w-connect;\d\n\f;;;
END_OF_FILE
if test 548 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/C351_PLAIN'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/C351_PLAIN'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/C351_PLAIN'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/PLAIN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/PLAIN'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/PLAIN'\" \(544 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/PLAIN' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X# substitute your node/link.channel for 999/1.11.
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-Bfound;-DSystem?;-Q\w\K\d;-Q\pbye\d;System?-\p\K\pbye\r\p-System?;\d999/1.11\r\d;connect-\p\K\dbye\r\d\d999/1.11\r\w-connect;\d;;;
END_OF_FILE
if test 544 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/PLAIN'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/PLAIN'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/PLAIN'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_NOSHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_NOSHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_NOSHT'\" \(579 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_NOSHT' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X# substitute your node/link.channel for 999/1.11.
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-Bfound;-DSystem?;-Q\L\L\K\d;-Q\pbye\d;System?-\p\K\pbye\r\p-System?;\d999/1.11\r\d;connect-\p\K\dbye\r\d\d999/1.11\r\w-connect;\033S\033F66\033C00\0339\015\033T\E;;;
END_OF_FILE
if test 579 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_NOSHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_NOSHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_NOSHT'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_SHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_SHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_SHT'\" \(579 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_SHT' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X# substitute your node/link.channel for 999/1.11.
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-Bfound;-DSystem?;-Q\L\L\K\d;-Q\pbye\d;System?-\p\K\pbye\r\p-System?;\d999/1.11\r\d;connect-\p\K\dbye\r\d\d999/1.11\r\w-connect;\033S\033F90\033C28\0339\015\033T\E;;;
END_OF_FILE
if test 579 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_SHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_SHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_PTR/ADDR_SPEC/QUME_SHT'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/C351_PLAIN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/C351_PLAIN'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/C351_PLAIN'\" \(581 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/C351_PLAIN' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X#
X# user will be required to type node/link.channel as the address of the
X# printer, like so: 135/0.14
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-DSystem?;-Q\w\K\d;-Q\pbye\d;System?-\p\K\pbye\r\p-System?;\d\U\r\d;connect-\p\K\dbye\r\d\d\U\r\w-connect;\d\n\f;;;
END_OF_FILE
if test 581 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/C351_PLAIN'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/C351_PLAIN'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/C351_PLAIN'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/PLAIN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/PLAIN'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/PLAIN'\" \(577 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/PLAIN' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X#
X# user will be required to type node/link.channel as the address of the
X# printer, like so: 135/0.14
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-DSystem?;-Q\w\K\d;-Q\pbye\d;System?-\p\K\pbye\r\p-System?;\d\U\r\d;connect-\p\K\dbye\r\d\d\U\r\w-connect;\d;;;
END_OF_FILE
if test 577 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/PLAIN'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/PLAIN'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/PLAIN'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_NOSHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_NOSHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_NOSHT'\" \(612 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_NOSHT' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X#
X# user will be required to type node/link.channel as the address of the
X# printer, like so: 135/0.14
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-DSystem?;-Q\L\L\K\d;-Q\pbye\d;System?-\p\K\pbye\r\p-System?;\d\U\r\d;connect-\p\K\dbye\r\d\d\U\r\w-connect;\033S\033F66\033C00\0339\015\033T\E;;;
END_OF_FILE
if test 612 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_NOSHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_NOSHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_NOSHT'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_SHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_SHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_SHT'\" \(612 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_SHT' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X#
X# user will be required to type node/link.channel as the address of the
X# printer, like so: 135/0.14
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-DSystem?;-Q\L\L\K\d;-Q\pbye\d;System?-\p\K\pbye\r\p-System?;\d\U\r\d;connect-\p\K\dbye\r\d\d\U\r\w-connect;\033S\033F90\033C28\0339\015\033T\E;;;
END_OF_FILE
if test 612 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_SHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_SHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_PTR/USER_ADDR/QUME_SHT'
fi
if test -f 'ISPIN/install/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/Makefile'\"
else
echo shar: Extracting \"'ISPIN/install/Makefile'\" \(4318 characters\)
sed "s/^X//" >'ISPIN/install/Makefile' <<'END_OF_FILE'
X# Makefile for compiling ISPIN C programs and doing installation
X#
X# ** IMPORTANT ** YOU MUST SET THE VARIABLE SPOOLER TO ONE OF THE FOLLOWING:
X#                      3B1, ZILOGNQ, ZILOGLP, DYNIX, CCI, UNISYS, OR LP
X#
X# Setting SPOOLER to LP is fine for most systems. Others are weird in some way:
X#
X# 3B1     - The only one of the Sys V's which puts lock files in /usr/spool/uucp
X# ZILOGNQ - For Zilog's Zeus 3.21 nq/xq/dqueuer queuer subsystem
X# ZILOGLP - Requires the "-Kfpe" flag on the compile line
X# DYNIX   - Conditional compile for ISPIN.c for jerking the ioctl around when
X#           doing the raw read after each burst of chars. Otherwise, we had 
X#           flow control probs. The UNISYS 5000 required this too.
X#         - Conditional compile for IQUEUER.c for special handling of the
X#           lockfiles we make. I talked to Sequent tech support about this.
X#           This is what they refer to as a "known bug".
X# CCI     - CCI's file system implements "dirent" style directory structure
X#           and routines. As POSIX-compliant boxes come along, this should
X#           come up more frequently. 
X# UNISYS  - As described above, the Unisys 5000 needed to have its ioctl
X#           tickled in a manner similar to the DYNIX (Sequent) machine.
X#          
X#
XSPOOLER = GIZMO
X
XSHELL=/bin/sh
X.PRECIOUS: *.h *.c
X
Xdefault: cprogs
X
Xcprogs: ckspooler unsplit ../obj/ispin ../obj/iq ../obj/iqueuer ../obj/ispintrfce 
X
Xunsplit:
X	cat ../src/IQUEUER.c.?? > ../src/IQUEUER.c
X	cat ../src/ISPIN.c.?? > ../src/ISPIN.c
X
Xinstall: ckspooler
X	/bin/sh install.sh $(SPOOLER)
X
Xckspooler:
X	@if [ $(SPOOLER) != "ZILOGNQ" -a $(SPOOLER) != "ZILOGLP" -a $(SPOOLER) != "DYNIX" -a $(SPOOLER) != "LP" -a $(SPOOLER) != "CCI" -a $(SPOOLER) != "3B1" -a $(SPOOLER) != "UNISYS" ] ; \
X	   then \
X	     echo "SPOOLER MUST BE SET TO ZILOGNQ, ZILOGLP, DYNIX, CCI, 3B1, UNISYS, OR LP - MAKE ABORTED" ; \
X	     exit 1 ; \
X	 fi
X
X../obj/ispin: ../src/ISPIN.c ../h/ispin.h ../h/localcnfg.h ../h/common.h ../h/nqspool.h
X	if [ $(SPOOLER) = "ZILOGNQ" ] ; \
X	  then scc -DNQ -o ../obj/ispin ../src/ISPIN.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "ZILOGLP" ] ; \
X	  then cc -Kfpe -o ../obj/ispin ../src/ISPIN.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "DYNIX" -o $(SPOOLER) = "UNISYS" ] ; \
X	  then cc -DDYNIX -o ../obj/ispin ../src/ISPIN.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "LP" -o $(SPOOLER) = "CCI" -o $(SPOOLER) = "3B1" ] ; \
X	  then cc -o ../obj/ispin ../src/ISPIN.c -s ; \
X	fi
X
X	chmod 711 ../obj/ispin
X
X../obj/iq: ../src/IQ.c ../h/iqueuer.h ../h/common.h
X	if [ $(SPOOLER) = "ZILOGNQ" ] ; \
X	  then scc -DNQ -o ../obj/iq ../src/IQ.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "ZILOGLP" ] ; \
X	  then cc -Kfpe -o ../obj/iq ../src/IQ.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "UNISYS" ] ; \
X	  then cc -o ../obj/iq ../src/IQ.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "DYNIX" -o $(SPOOLER) = "LP" -o $(SPOOLER) = "3B1" ] ; \
X	  then cc -o ../obj/iq ../src/IQ.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "CCI" ] ; \
X	  then cc -DMODERN_DIRS -o ../obj/iq ../src/IQ.c -s ; \
X	fi
X
X	chmod 711 ../obj/iq
X
X../obj/iqueuer: ../src/IQUEUER.c ../h/iqueuer.h ../h/common.h
X	if [ $(SPOOLER) = "ZILOGNQ" ] ; \
X	  then scc -DNQ -o ../obj/iqueuer ../src/IQUEUER.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "ZILOGLP" ] ; \
X	  then cc -DLCK_DIR=\"/usr/spool/locks/\" -Kfpe -o ../obj/iqueuer ../src/IQUEUER.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "DYNIX" ] ; \
X	  then cc -DDYNIX -DLCK_DIR=\"/usr/spool/uucp/LCK/\" -o ../obj/iqueuer ../src/IQUEUER.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "LP" -o $(SPOOLER) = "UNISYS" ] ; \
X	  then cc -DLCK_DIR=\"/usr/spool/locks/\" -o ../obj/iqueuer ../src/IQUEUER.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "CCI" ] ; \
X	  then cc -DMODERN_DIRS -DLCK_DIR=\"/usr/spool/locks/\" -o ../obj/iqueuer ../src/IQUEUER.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "3B1" ] ; \
X	  then cc -o ../obj/iqueuer ../src/IQUEUER.c -s ; \
X	fi
X
X	chmod 700 ../obj/iqueuer
X
X../obj/ispintrfce: ../src/ISPINTRFCE.c ../h/localcnfg.h
X	if [ $(SPOOLER) = "ZILOGLP" ] ; \
X	  then cc -Kfpe -o ../obj/ispintrfce ../src/ISPINTRFCE.c -s ; \
X	fi
X
X	if [ $(SPOOLER) = "DYNIX" -o $(SPOOLER) = "LP" -o $(SPOOLER) = "CCI" -o $(SPOOLER) = "3B1" -o $(SPOOLER) = "UNISYS" ] ; \
X	  then cc -o ../obj/ispintrfce ../src/ISPINTRFCE.c -s   ; \
X	fi
X
X	if [ $(SPOOLER) != "ZILOGNQ" ] ; \
X	  then chmod 755 ../obj/ispintrfce ; \
X	fi
X
Xclean: 
X	/bin/rm -f ../obj/*
X	/bin/sh ./split_it.sh
X
END_OF_FILE
if test 4318 -ne `wc -c <'ISPIN/install/Makefile'`; then
    echo shar: \"'ISPIN/install/Makefile'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/Makefile'
fi
if test -f 'ISPIN/install/install.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/install.sh'\"
else
echo shar: Extracting \"'ISPIN/install/install.sh'\" \(3478 characters\)
sed "s/^X//" >'ISPIN/install/install.sh' <<'END_OF_FILE'
X#!/bin/sh
X# install.sh - called by make when command "make install" is executed
X
Xspooler=$1
Xif [ $spooler != "ZILOGNQ" ] && [ $spooler != "ZILOGLP" ] && [ $spooler != "DYNIX" ] && [ $spooler != "LP" ] && [ $spooler != "CCI" ] && [ $spooler != "3B1" ] && [ $spooler != "UNISYS" ]
Xthen
X  echo " ERROR : install.sh must be called with an argument specifying spooler"
X  echo "         (i.e. install.sh ZILOGLP) "
X  exit 1
Xfi
X
Xif [ $spooler = "ZILOGNQ" ]
Xthen
X  dirname="queuer"
Xelse
X  dirname="lp"
Xfi
X
Xif [ ! -d /usr/spool/$dirname/ISPIN ]
Xthen
X  echo "making new directories"
X  echo "mkdir /usr/spool/$dirname/ISPIN"
X  mkdir /usr/spool/$dirname/ISPIN
X  chmod 777 /usr/spool/$dirname/ISPIN
Xfi
X
Xif [ ! -d /usr/spool/$dirname/ISPIN/FIFO ]
Xthen
X  echo "mkdir /usr/spool/$dirname/ISPIN/FIFO"
X  mkdir /usr/spool/$dirname/ISPIN/FIFO
X  chmod 777 /usr/spool/$dirname/ISPIN/FIFO
Xfi
X
Xif [ ! -r /usr/spool/$dirname/ISPIN/FIFO/IQUEUER ]
Xthen
X  echo "creating named pipes"
X  echo "/etc/mknod /usr/spool/$dirname/ISPIN/FIFO/IQUEUER p"
X  /etc/mknod /usr/spool/$dirname/ISPIN/FIFO/IQUEUER p
X  chmod 666 /usr/spool/$dirname/ISPIN/FIFO/IQUEUER
Xfi
X
Xif [ ! -r /usr/spool/$dirname/ISPIN/FIFO/STATUS ]
Xthen
X  echo "/etc/mknod /usr/spool/$dirname/ISPIN/FIFO/STATUS p"
X  /etc/mknod /usr/spool/$dirname/ISPIN/FIFO/STATUS p
X  chmod 666 /usr/spool/$dirname/ISPIN/FIFO/STATUS
Xfi
X
Xif [ ! -f /usr/spool/$dirname/ISPIN/rtab ]
Xthen
X  echo "copy <<empty>> rtab to /usr/spool/$dirname/ISPIN directory"
X  echo "cp rtab /usr/spool/$dirname/ISPIN"
X  cp rtab /usr/spool/$dirname/ISPIN
X  chmod 744 /usr/spool/$dirname/ISPIN/rtab
Xfi
X
Xecho "copy executable iqueuer to /usr/spool/$dirname/ISPIN directory"
Xecho "cp ../obj/iqueuer /usr/spool/$dirname/ISPIN"
Xcp ../obj/iqueuer /usr/spool/$dirname/ISPIN
X
Xecho "copy executable ispin to /usr/spool/$dirname/ISPIN directory"
Xecho "cp ../obj/ispin /usr/spool/$dirname/ISPIN"
Xcp ../obj/ispin /usr/spool/$dirname/ISPIN
X
Xif [ $spooler != "ZILOGNQ" ]
Xthen
X  echo "copy ispintrfce to /usr/spool/$dirname/ISPIN directory"
X  echo "cp ../obj/ispintrfce /usr/spool/$dirname/ISPIN"
X  cp ../obj/ispintrfce /usr/spool/$dirname/ISPIN
Xfi
X
Xecho "What's left?"
Xecho
Xecho "1. Copy iq to a directory to which your users have a path for"
Xecho "   execution ( such as, generally, /z/bin, or /usr/local/bin )."
Xecho "2. Make provision in your system start-up script(s) to invoke"
Xecho "   /usr/spool/$dirname/ISPIN/iqueuer (the daemon) every start-up"
Xecho "   Execute it now, just for the first start-up."
Xecho "3. Choose the tty(s) through which ISPIN will contact printer(s)"
Xecho "4. Connect tty(s) to network"
Xecho "5. Edit the /usr/spool/$dirname/ISPIN/rtab to add a line for"
Xecho "   connect info for each remote printer"
Xif [ $spooler =  "ZILOGNQ" ]
Xthen
X  echo "6. Add each remote printer as a member of the native queuer by"
X  echo "   editing the /usr/spool/queuer/config file"
X  echo "7. Force the dqueuer (native queueing daemon) to read the config file"
X  echo "    by executing:     dqueuer -r"
X  echo "   The dqueuer will thus re-read the config file and learn of the"
X  echo "   new printer(s)."
Xelse
X  echo "6. Shut down lpsched by executing lpshut."
X  echo "7. Add each remote printer as a member of the native queuer by"
X  echo "   executing     lpadmin -pyour_printer_name -iispintrfce -v/dev/null"
X  echo "8. Re-start the lp scheduler by executing lpsched."
X  echo "9. Use the lp-family commands << enable >> and << accept >> to"
X  echo "    bring each new printer on-line."
Xfi
END_OF_FILE
if test 3478 -ne `wc -c <'ISPIN/install/install.sh'`; then
    echo shar: \"'ISPIN/install/install.sh'\" unpacked with wrong size!
fi
chmod +x 'ISPIN/install/install.sh'
# end of 'ISPIN/install/install.sh'
fi
if test -f 'ISPIN/install/split_it.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/split_it.sh'\"
else
echo shar: Extracting \"'ISPIN/install/split_it.sh'\" \(307 characters\)
sed "s/^X//" >'ISPIN/install/split_it.sh' <<'END_OF_FILE'
X#!/bin/sh
X# split_it.sh - called by make when command "make clean" is executed
X
Xif [ -f ../src/IQUEUER.c ]
Xthen
X	cd ../src
X	/usr/bin/split IQUEUER.c IQUEUER.c.
X	/bin/rm IQUEUER.c
X	cd ../install
Xfi
X
Xif [ -f ../src/ISPIN.c ]
Xthen
X	cd ../src
X	/usr/bin/split ISPIN.c ISPIN.c.
X	/bin/rm ISPIN.c
X	cd ../install
Xfi
END_OF_FILE
if test 307 -ne `wc -c <'ISPIN/install/split_it.sh'`; then
    echo shar: \"'ISPIN/install/split_it.sh'\" unpacked with wrong size!
fi
chmod +x 'ISPIN/install/split_it.sh'
# end of 'ISPIN/install/split_it.sh'
fi
if test -f 'ISPIN/doc/future.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/doc/future.doc'\"
else
echo shar: Extracting \"'ISPIN/doc/future.doc'\" \(6419 characters\)
sed "s/^X//" >'ISPIN/doc/future.doc' <<'END_OF_FILE'
X
X
XIRS National Office has allocated a full staff year to Central Region in
Xfiscal year 92 for ISPIN support. How much of that year trickles down
Xto Indy remains to be seen. I've heard it may be anywhere from one half
Xstaff year (most likely) to the whole thing (when pigs fly).
X
XA whole staff year (2088 hours) is a lot. By my reckoning, that's a lot
Xmore than the total number of hours I've spent on ISPIN analysis, develop-
Xment, testing, and customer support since August, 1988. Even if we only
Xsee a half staff year, that's still a pretty big chunk.
X
XWhat are we going to do with all that FY 92 time on our hands? Glad you
Xasked.
X
XJust as I did about a year and a half ago, before I start laying fingers
Xon the keyboard, I'm soliciting your input. Last time we worked together
Xthis way we produced ISPIN_2.1. It worked out so well that I wouldn't
Xconsider doing this by myself.
X
XBelow is a list of proposals for the next ISPIN release. I think I've
Xincluded all the items you have suggested along the way, but I want to be
Xsure.
X
XLook this listing over. Think it over. Are there any more features or
Xadditional functionality you want? Are there any bugs, glitches, or
Xdeficiencies which should be addressed?
X
XI won't guarantee that everything on this listing will be included in
Xthe next release. Some of it (like ISPIX and printing to LAN printers)
Xdepends on whether I can secure a proper development platform. Support
Xfor Berkeley lpr spooler might never happen. I will guarantee that any
Xnew ISPIN release will contain enough additional value to make its 
Xinstallation worth your while.
X
XI'd like to start shortly after the new FY begins, so let me hear from
Xyou by the end of September. E-mail responses are best for me but I'll
Xtake notes from phone calls too.
X
X
XSep  4 15:26 1991  future.doc Page 1
X
X
XFUTURE DIRECTIONS
X
X   Here, in no particular order of importance, are planned features,
X   fixes, dreams, etc.
X
X
X   ISPIN
X
X         - Support variable level debug on execution, similar to
X           uucico. This would be available to the sysadmin via
X           an rtab flag and argument.
X
X         - Alternative log file for debug, error, and event logging
X           specified in rtab
X
X         - variable output packet size
X
X         - TCP/IP interface for ISPIN to support printers on the LAN.
X           GOSIP later. I'm not talking about printers which are attached
X           to systems which are on the LAN. That's easy, and it's been
X           done. I'm thinking about printers which are on a LAN-attached
X           terminal server; or maybe going through a LAN-attached terminal
X           server, to get to an X.25 apad, then across the X.25 to 
X           printers on another apad.
X
X         - add capability to specify in rtab when speed of tty should
X           change - we go out at an initial speed, tell the net or modem
X           to change its speed, then immediately change ours to adjust
X
X         - add capability to specify in rtab to set up the tty at other
X           than the current generic 8 data bits, 1 stop bit, no parity.
X
X         - Support additional flags and arguments which can be passed
X           from the lp command line. The string passed as the arg to
X           the "-o" flag could be parsed by ISPIN for all sorts of
X           additional functionality. Right now, ISPIN assumes that any
X           argument to "-o" is a string which will be substituted
X           for "\U" in the rtab entry. Possibilities  include:
X
X             * variable level debug
X             * alternative log file for debug, error, and event logging
X             * specification of filters through which data could be
X               piped before it is sent out by ISPIN
X             * multiple substitution strings for rtab entry, such as:
X               \U, \U1, \U2...\Un
X             * remove file(s) after printing - some lp/lpscheds already
X               support this, some don't
X             * optional/alternative file name for banner page
X             * read data from a named pipe - lp/lpsched won't permit
X               queueing a file of null length, so giving a named pipe's
X               file name to lp doesn't work. Under this option, an
X               existing non-null "dummy" file would be given to lp as
X               the file arg, but ISPIN would actually read from the
X               named pipe specified by this optional flag and arg.
X             * variable dark/light level for toaster interface
X
X         - Support Berkeley lpr - this is on the cold, cold back burner
X           since IRS doesn't own many pure Berzerkeley Boxes.
X
X         - On dual universe boxes, switch to att if called from ucb
X
X         - man pages (yeah, sure)
X
X
X
X
X
X
X
X
XSep  4 15:26 1991  future.doc Page 2
X
X
X
X
X
X   ISPI
X
X         - Read external table and/or termcap/terminfo to retrieve the
X           string which turns on the terminal's auxiliary port instead
X           of relying solely on the internal hard-coded table.
X
X         - Clear the screen internally (curses or call up from termcap/
X           terminfo) instead of system call to "clear".
X
X         - allow ISPI to accept standard input as the print job, like:
X
X                 pr bigfile|ispi -B
X
X         - X-windows face (ISPIX?)
X
X         - Support Berkeley lpr - this is on the cold, cold back burner
X           since IRS doesn't own many pure Berzerkeley Boxes.
X
X         - On dual universe boxes, switch to att if called from ucb
X
X         - man pages (get real)
X
X
X   SUPPORT
X
X           09/11/91
X         - implement an automated e-mail response/software-distribution
X           routine with logging capabilities.
X
X-- 
X|::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::|
X|  Larry Bartz                                                               |
X|                                                                            |
X|   UNIX/uucp e-mail:                                                        |
X|   {pharaoh, MWR, INDY_3, BUFFALO, ARC_CO, BSC05, arlva1,                   |
X|      clt2, TEPS!indy6, ln3, pscs27!indy6, uunet!sir-alan}!ispin!lbartz     |
X|                                                                            |
X|   IRS-private MMDF:                                                        |
X|   lbartz@indy6                                                             |
X|::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::|
END_OF_FILE
if test 6419 -ne `wc -c <'ISPIN/doc/future.doc'`; then
    echo shar: \"'ISPIN/doc/future.doc'\" unpacked with wrong size!
fi
# end of 'ISPIN/doc/future.doc'
fi
if test -f 'ISPIN/misc/ISPIT.dr/eot_trap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/misc/ISPIT.dr/eot_trap.c'\"
else
echo shar: Extracting \"'ISPIN/misc/ISPIT.dr/eot_trap.c'\" \(147 characters\)
sed "s/^X//" >'ISPIN/misc/ISPIT.dr/eot_trap.c' <<'END_OF_FILE'
X#include <stdio.h>
X
Xmain()
X{
X  int c;
X
X  while ((c = getc(stdin)) != EOF)
X  {
X    if(c == 4)
X    {
X      exit(0);
X    }
X
X    putc(c,stdout);
X  }
X}
END_OF_FILE
if test 147 -ne `wc -c <'ISPIN/misc/ISPIT.dr/eot_trap.c'`; then
    echo shar: \"'ISPIN/misc/ISPIT.dr/eot_trap.c'\" unpacked with wrong size!
fi
# end of 'ISPIN/misc/ISPIT.dr/eot_trap.c'
fi
echo shar: End of archive 6 \(of 15\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

