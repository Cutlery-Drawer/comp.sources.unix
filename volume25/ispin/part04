Newsgroups: comp.sources.unix
From: sir-alan!ispin!lbartz@iuvax.cs.indiana.edu (Larry Bartz)
Subject: v25i115: Indianapolis Standard Printer Interface for Networked printers, Part04/15
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: sir-alan!ispin!lbartz@iuvax.cs.indiana.edu (Larry Bartz)
Posting-Number: Volume 25, Issue 115
Archive-Name: ispin/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 15)."
# Contents:  ISPIN/h/nqspool.h ISPIN/h/localcnfg.h ISPIN/src/IQ.c
#   ISPIN/src/ISPINTRFCE.c
#   ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/PLAIN
#   ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/C351_PLAIN
#   ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_NOSHT
#   ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_SHT
#   ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/C351_PLAIN
#   ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_NOSHT
#   ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_SHT
#   ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/PLAIN
#   ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/C351_PLAIN
# Wrapped by socrates@indy6 on Tue Jan 28 15:26:34 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ISPIN/h/nqspool.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/h/nqspool.h'\"
else
echo shar: Extracting \"'ISPIN/h/nqspool.h'\" \(7069 characters\)
sed "s/^X//" >'ISPIN/h/nqspool.h' <<'END_OF_FILE'
X/* @[$]spool.h  2.3  10/26/82 16:54:01 - Zilog Inc */
X/* include file for spooler routines ... especially backends */
X
X/***************************************************************
X**
X** Instructions for writing backends for the Zeus printer spooler
X**
X**
X** The purpose of a backend is to do the actual printing for the
X** spooling system.  The simplest backend would merely copy input
X** from file descriptor RFFD to file descriptor SFFD.  Many devices
X** require modification of their input in order to work properly.
X** In many cases, they require the addition or deletion of control
X** sequences for proper operation.  A familiar example is the line
X** printer which generally cannot handle backspace characters.
X** 
X** In addition to filtering, backends can be used to generate banner
X** pages and burst pages for easy separation and identification of
X** print requests.
X** 
X** Backends for the Zeus printer spooler are expected to copy input
X** from RFFD to SFFD while doing any filtering required. Other
X** than copying input to output, there is only one other condition
X** backends must handle.  If they receive a '-B' on the command
X** line, they must not read RFFD.  The '-B' flag is generated by
X** the dqueuer when it cannot find the file to be printed.  It
X** is used by the dqueuer to cause system supplied backends to indicate
X** 'file not found' on a banner page by itself.  A backend
X** may handle flags and status that the dqueuer passes to it.
X** 
X** Backends may expect the following flags to be passed as arguments 
X** when they are invoked.  They are used for banner page information
X** by the system backends.
X** 
X**      -B              File not found.
X**      -c x            Print file x number of times.
X**      -d dest         Destination string
X**      -f file         File name being printed.
X**      -F from         'from' is the user making the request.
X**      -s time         String with time that file was spooled
X**      -t title        Title requested
X** 
X** In addition to these flags, any extra options included in the 
X** options field of a device line in the configuration file will
X** be passed directory to the backend.  For instance, the text(M)
X** backend recognizes '-T command' in the configuration file as
X** and will pass the 'command' to stty.
X** 
X** The spooling system also allows the backend to return certain
X** statuses so that xq(1) can monitor its progress.  This is done
X** through the file on STATUSFD.  The contents of this file is the
X** structure 'Dstat' whose definition is included in this file.
X** the only fields that the backend may access are the 'Dpgsdone'
X** (number of pages printed) and the 'Dpercentd' (percentage of file
X** printed) fields.  Modification of the other fields may
X** cause unpredictable results.  Use the OFFSET macro included in
X** this file to access these fields.  An example of its use 
X** follows:
X** 
X**      int pages;
X**      struct Dstat dummy;
X** 
X**      lseek(STATUSFD, OFFSET(dummy,Dpgsdone),0);
X**      write(STATUSFD, &pages,  sizeof(pages));
X** 
X** The fields Dpgsdone and Dpercentd are printed by xq(1).  They
X** are originally set to -1 indicating to xq that the backend does
X** not support these counters.  Thus, no problems will be caused 
X** by not including this support.  Again, do not try to read or 
X** write any other fields of the Dstat structure.  The spooler
X** uses recording locking extensively, and even reading a field 
X** may cause a deadlock situation.
X** 
X** Upon completion of processing, the backend exits.  If the exit
X** returns a non-zero value, the spooler will assume an error has
X** occured and try to recover.  If error logging is enabled it will
X** write a message and the return the code into the error file.  It
X** will then try to repeat the request.  If the error reoccures more
X** than two times, the dqueuer will set the device status to DOWN.
X** The Device may be reenabled by using the command
X** 
X**      xq -q q:dev -Ud
X** 
X** where 'q:dev' is replaced with the que name and device number.  SEe
X** xq(M) for more details.
X**
X****************************************************************/
X
X/* special types */
X
X/* for purposes of ISPIN: */
X/* comment these out because we already have them specified in another .h */
X/* #include <sys/types.h> */
X/* #include <signal.h> */
X
X/* spooler logs errors ... they are classified as: */
X#define FATAL   0
X#define WARNING 1
X
X/* for purposes of ISPIN: */
X/* we are using STATUS for our own purposes */
X/* #define STATUS       2 */
X
X#define FORML    9      /* max length of form names     */
X
X/* Macro definition to find the offset (in bytes) of a certain element in a
X** structure
X*/
X#define OFFSET(struct,item) (off_t)((char *)&(struct.item) - (char *)&struct)
X
X/* interprocess communication sometimes uses double record locking
X** the following structure is used in those cases
X*/
Xtypedef struct ippid {
X                        int     pide;   /* pid element */
X                        int     accesse;/* access element */
X                        } ippid;
X
X/* entries in device status directory */
Xstruct Dstat    {       
X                                int             Dstatus;
X                                int             Duid;
X                                char    Dform[FORML];
X                                time_t  last_dispatched;/* last time we were
X                                                                                ** dispatched
X                                                                                */
X                                int     retrys;         /* number of dispatch retrys */
X                                ippid Dpid;             /* pid of backend active on
X                                                                ** this device
X                                                                */
X                                int Dpgsdone;
X                                int     Dseqn;
X                                int     Dpercentd;
X                                };
X
X/* redefinition of signals used between backends and the spooler programs */
X#define SIGBACK         SIGTRAP
X#define SIGSTOP         SIGIOT
X#define SIGRES          SIGFPE
X
X/* these defines identify which fds go with what during invocation of
X** backends, logerr and other stuff
X*/
X#define LOGERRFD        0               /* fileds of logerr/error file */
X#define SFFD            1               /* fileds of special file being used
X                                                        ** NOTE: this constant should not be changed.
X                                                        ** The text(M) backend exec's stty(1) and will
X                                                        ** come up with megaproblems if fileds 1 is not
X                                                        ** the special file
X                                                        */
X#define STATUSFD        2               /* fileds of status file for device */
X#define RFFD            3               /* fileds of request file to be printed */
END_OF_FILE
if test 7069 -ne `wc -c <'ISPIN/h/nqspool.h'`; then
    echo shar: \"'ISPIN/h/nqspool.h'\" unpacked with wrong size!
fi
# end of 'ISPIN/h/nqspool.h'
fi
if test -f 'ISPIN/h/localcnfg.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/h/localcnfg.h'\"
else
echo shar: Extracting \"'ISPIN/h/localcnfg.h'\" \(6540 characters\)
sed "s/^X//" >'ISPIN/h/localcnfg.h' <<'END_OF_FILE'
X/****************************************************************************/
X/*                                                                          */
X/* 1988, SOWSEAR ENGINEERING, SOFTWARE GROUP    Indianapolis, IN            */
X/*                                                                          */
X/*               our motto: "Who says you can't...?"                        */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* LOCALCNFG.H                                                              */
X/*                                                                          */
X/* localcnfg.h is a header file which is shared by ISPIN, IQUEUER, and IQ.  */
X/*                                                                          */
X/* The items and constants described in this header file are those which    */
X/* are likely to be adjusted at install time to suit local needs and        */
X/* preferences.                                                             */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* COMMENTS                                                                 */
X/*                                                                          */
X/* read common.h for the BIG PICTURE                                        */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DEFINES                                                                  */
X/*                                                                          */
X/*                                                                          */
X/* SITELINE is the opportunity for you to tailor the banner page to reflect */
X/* the name of your site.                                                   */
X/* Please only modify what is between the first and last asterisk.          */
X/* Leave it just this width, so it matches the rest of the banner.          */
X/*                                                                          */
X#define SITELINE "* *****        INDIANAPOLIS DISTRICT OFFICE        ***** *\n"
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/* These path-specific #defined variables seemed to me like logical places  */
X/* to put things. If you don't agree, change 'em!                           */
X/*                                                                          */
X/* If you do change the locations, adjust your applicable install script    */
X/* accordingly.                                                             */
X/*                                                                          */
X/* The file where we'll write event msgs and error msgs.                    */
X#ifdef NQ
X#define LOGFILE "/usr/spool/queuer/ISPIN/log"
X#else
X#define LOGFILE "/usr/spool/lp/ISPIN/log"
X#endif
X/*                                                                          */
X/*                                                                          */
X/* Directory location FIFOs. Again, the location is merely a suggestion.    */
X#ifdef NQ
X#define FIFOdir "/usr/spool/queuer/ISPIN/FIFO/"
X#else
X#define FIFOdir "/usr/spool/lp/ISPIN/FIFO/"
X#endif
X/*                                                                          */
X/*                                                                          */
X/* Name of ISPIN's table of remote printer information. Again, the location */
X/* is merely a suggestion.                                                  */
X#ifdef NQ
X#define RTAB "/usr/spool/queuer/ISPIN/rtab"
X#else
X#define RTAB "/usr/spool/lp/ISPIN/rtab"
X#endif
X/*                                                                          */
X/*                                                                          */
X/* Location of the ISPIN executable. This constant is used by the small     */
X/* executable which serves as the "interface" in the LP situation, thereby  */
X/* requiring only one centrally located copy of the ISPIN executable.       */
X/* INTRFCE execs the ISPIN. This saves considerable disk space, as opposed  */
X/* to having a complete, separate ISPIN as the interface for each queue     */
X/* member.                                                                  */
X#define INTRFCE "/usr/spool/lp/ISPIN/ispin"
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* INCLUDES                                                                 */
X/*                                                                          */
X/* Refer to common.h                                                        */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DATA TYPES, VARIABLES, ETC                                               */
X/*                                                                          */
X/* Refer to common.h                                                        */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
END_OF_FILE
if test 6540 -ne `wc -c <'ISPIN/h/localcnfg.h'`; then
    echo shar: \"'ISPIN/h/localcnfg.h'\" unpacked with wrong size!
fi
# end of 'ISPIN/h/localcnfg.h'
fi
if test -f 'ISPIN/src/IQ.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/src/IQ.c'\"
else
echo shar: Extracting \"'ISPIN/src/IQ.c'\" \(24478 characters\)
sed "s/^X//" >'ISPIN/src/IQ.c' <<'END_OF_FILE'
X/****************************************************************************/
X/*                                                                          */
X/* IQ - IQUEUER query program. An executable to check current status of:    */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/* IQUEUER - the secondary queueing daemon for:                             */
X/*                                                                          */
X/* ISPIN                                                                    */
X/*                                                                          */
X/* Indianapolis Standard Printer Interface (for Network printers)           */
X/****************************************************************************/
X/*                                                                          */
X/*  Copyright (C) 1991                                                      */
X/*  Larry Bartz                                                             */
X/*  Internal Revenue Service                                                */
X/*  Indianapolis District Office                                            */
X/*                                                                          */
X/*  This program is free software; you can redistribute it and/or modify    */
X/*  it under the terms of the GNU General Public License as published by    */
X/*  the Free Software Foundation, version 1.                                */
X/*                                                                          */
X/*  This program is distributed in the hope that it will be useful,         */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of          */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           */
X/*  GNU General Public License for more details.                            */
X/*                                                                          */
X/*  You should have received a copy of the GNU General Public License       */
X/*  along with this program; if not, write to the Free Software             */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* COMMENTS                                                                 */
X/*                                                                          */
X/* Read comments in common.h for the BIG PICTURE.                           */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DEFINES                                                                  */
X/*                                                                          */
X/* Refer to common.h and iqueuer.h                                          */
X/*                                                                          */
X/* #define DEBUG                                                            */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* INCLUDES                                                                 */
X/*                                                                          */
X/* Refer to common.h and iqueuer.h                                          */
X/*                                                                          */
X#include "../h/iqueuer.h"
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DATA TYPES, VARIABLES, ETC                                               */
X/*                                                                          */
X/* Refer to common.h and iqueuer.h                                          */
X/*                                                                          */
X/*                                                                          */
X/*                                                                         */
X/****************************************************************************/
X/*                                                                          */
X/* MODIFICATIONS                                                            */
X/*                                                                          */
X/* 10/13/89 Kevin Fannin - Modified program to print "unassigned" for port  */
X/*                         when iq reports on a waiting job. Waiting jobs   */
X/*                         now have the port inode number set to -1 to      */
X/*                         indicate that no device has been chosen yet.     */
X/****************************************************************************/
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X  int gotstats = 0;
X
X  int check_char, keep_char;
X
X  int not_now();
X
X  char out_buf[BUFSIZ];
X
X  char *myncheck();
X
X
X  count1 = count2 = 0;
X  
X  /* take care of the signals */
X  signal(SIGINT, SIG_DFL);    /* default for "interrupt" signal <DEL> */
X  signal(SIGHUP, SIG_DFL);    /* default for "hang up" signal */
X  signal(SIGQUIT, SIG_DFL);   /* default for "quit" signal */
X  signal(SIGALRM, SIG_DFL);   /* default for "alarm" signal */
X  signal(SIGTERM, not_now);   /* trap "term" signal */
X
X  /* allocate storage for our file status buffer */
X  stat_buf = (struct stat *) calloc(1,sizeof(struct stat));
X
X
X  /* what is the name of the FIFO I talk through?   */
X  strcpy(outFIFO,FIFOdir);
X  strcat(outFIFO,"IQUEUER");
X  /* does it exist? */
X  if(stat(outFIFO,stat_buf))
X  {
X    /* if not,      */
X    /* die horribly */
X    /* need to send out an error msg */
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          sprintf(errmsg,"IQ: stat outFIFO: %s. time:\n",sys_errlist[errno]);
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X
X    fprintf(stderr,errmsg);
X    exit(1);
X
X  }
X
X
X  /* An open for writing will block unless a process (IQUEUER) has the file   */
X  /* open for reading.                                                        */
X
X
X  signal(SIGALRM, not_now);
X  alarm(5);
X  /* this open of the FIFO is the one we'll use for our write           */
X  if((outfifo = open(outFIFO,O_WRONLY)) == -1)
X  {
X    /* need to send out an error msg */
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          sprintf(errmsg,"IQ: open %s: %s. time:\n",outFIFO,sys_errlist[errno]);
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X
X         fprintf(stderr,errmsg);
X         exit(1);
X
X  }
X  alarm(0);
X  signal(SIGALRM, SIG_IGN);
X
X
X  /* open the status fifo */
X
X  /* what is the name of the status FIFO ? */
X  strcpy(statFIFO,FIFOdir);
X  strcat(statFIFO,"STATUS");
X  /* does it exist? */
X  if(stat(statFIFO,stat_buf))
X  {
X    /* if not,      */
X    /* create it if we can */
X    if(mknod(statFIFO,0010666,1) != SUCCESS)
X    {
X      /* It didn't exist and we couldn't create it either. */
X      /* All hope is lost.                                 */
X      /* need to send out an error msg */
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          sprintf(errmsg,"IQ: mknod statFIFO: %s. time:\n",sys_errlist[errno]);
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X
X          /* We can still write to stderr at this point. */
X          fprintf(stderr,errmsg);
X
X          exit(1);
X    }
X  }
X
X
X  /* An open for reading will block unless a process (IQUEUER) has the file   */
X  /* open for writing.                                                        */
X
X  signal(SIGALRM, not_now);
X  alarm(5);
X  if((statropn = open(statFIFO,O_RDONLY)) == -1)
X  {
X    /* need to send out an error msg */
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          sprintf(errmsg,"IQ: IQUEUER does not exist. time:\n");
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X
X          /* We can still write to stderr at this point. */
X          fprintf(stderr,errmsg);
X
X          exit(1);
X  }
X  alarm(0);
X  signal(SIGALRM, SIG_IGN);
X
X  free(stat_buf);
X
X  /* format our message to the almighty IQUEUER */
X
X      /* what type of message? */
X      req_msg.typ.intgr = STATUS;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.typ.chr[count1++];
X      }
X      count1 = 0;
X
X      /* what is my pid? */
X      req_msg.my_pid.intgr = getpid();
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.my_pid.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.my_fifo.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.my_fifo.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.dev1_inod.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev1_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.dev2_inod.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev2_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.dev3_inod.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev3_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.dev4_inod.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev4_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.dev5_inod.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev5_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.dev6_inod.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev6_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.dev7_inod.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev7_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.dev8_inod.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev8_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.dev9_inod.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev9_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.dev10_inod.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev10_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.dev11_inod.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev11_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      /* identify the requesting user */
X      req_msg.uid.intgr = (int)getuid();
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.uid.chr[count1++];
X      }
X      count1 = 0;
X
X      req_msg.loop.intgr = 0;
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.loop.chr[count1++];
X      }
X      count1 = 0;
X      count2 = 0;
X
X  /* send our message to the almighty IQUEUER */
X
X      count1 = write(outfifo,msg_buf,to_iqrsiz);
X      close(outfifo);
X
X#ifdef DEBUG
X      printf("wrote %d chars\n",count1);
X#endif
X
X      count1 = 0;
X
X  /* read until we get a message of all zeroes */
X
X
X  to_IQ.typ.lng = 1L;
X
X  while(to_IQ.typ.lng != 0L)
X  {
X    chars_got = read(statropn,msg_buf, to_iq_siz);
X
X#ifdef DEBUG
X      printf("first read %d chars\n",chars_got);
X#endif
X
X    if(chars_got < 1)
X    {
X      close(statropn);
X      if((statropn = open(statFIFO,O_RDONLY)) == -1)
X      {
X        /* need to send out an error msg */
X              /* format an error message */
X              time(&tloc);
X              nowtime = (struct tm *)localtime(&tloc);
X              time_str = asctime(nowtime);
X              sprintf(errmsg,"IQ: IQUEUER does not exist. time:\n");
X              strcat(errmsg,"                            ");
X              strcat(errmsg,time_str);
X              strcat(errmsg,"\n");
X
X              /* We can still write to stderr at this point. */
X              fprintf(stderr,errmsg);
X
X              exit(1);
X      }
X      chars_got = read(statropn,msg_buf, to_iq_siz);
X
X#ifdef DEBUG
X      printf("second read %d chars\n",chars_got);
X#endif
X
X      
X    }
X
X    /* fill our structure of unions from the msg_buf */
X    count1 = count2 = 0;
X
X    while(count1 < longsize)
X    {
X      to_IQ.typ.chr[count1++] = msg_buf[count2++];
X    }
X    count1 = 0;
X
X    while(count1 < longsize)
X    {
X      to_IQ.devinod.chr[count1++] = msg_buf[count2++];
X    }
X    count1 = 0;
X
X    while(count1 < longsize)
X    {
X      to_IQ.my_fifo.chr[count1++] = msg_buf[count2++];
X    }
X    count1 = 0;
X
X    while(count1 < longsize)
X    {
X      to_IQ.pid.chr[count1++] = msg_buf[count2++];
X    }
X    count1 = 0;
X
X    while(count1 < longsize)
X    {
X      to_IQ.time_in.chr[count1++] = msg_buf[count2++];
X    }
X    count1 = 0;
X
X    while(count1 < longsize)
X    {
X      to_IQ.time_out.chr[count1++] = msg_buf[count2++];
X    }
X    count1 = 0;
X
X    while(count1 < longsize)
X    {
X      to_IQ.uid.chr[count1++] = msg_buf[count2++];
X    }
X    count1 = 0;
X
X    while(count1 < longsize)
X    {
X      to_IQ.loop.chr[count1++] = msg_buf[count2++];
X    }
X    count1 = 0;
X    count2 = 0;
X
X    /* now see what we got */
X    if(to_IQ.typ.lng != 0L)
X    {
X      ++gotstats;
X
X      if(gotstats == 1)
X      {
X          /* do a header for jobs which are running */
X          sprintf(out_buf,"PORT           ");     /* 14 positions, plus space */
X          strcat(out_buf,"PRINTER        ");     /* 14 positions, plus space */
X          strcat(out_buf,"PID    ");             /*  6 positions, plus space */
X          strcat(out_buf,"TIME-IN  ");           /*  8 positions, plus space */
X          strcat(out_buf,"STATE-TIME ");         /*  8 positions, plus space */
X                                                 /*  STATE TIME header over- */
X                                                 /*  -runs following field   */
X          strcat(out_buf,"USER   ");             /*  8 positions, plus space */
X          strcat(out_buf," LOOP ");              /*  5 positions, plus space */
X          strcat(out_buf,"STATE\n\n");           /* 10 positions, plus \n's  */
X
X          printf(out_buf);
X      }
X
X      /* make some sense of what we got */
X
X     /**********************************************************************/
X
X      /* If -1 was passed as inode number, this signifies that the job   */
X      /* is waiting to be assigned a device once one becomes available.  */
X
X      if (to_IQ.devinod.lng == -1)     
X        strcpy(lil_buf,"unassigned");
X      else
X        /* get cpu port's name from inode number */
X        strcpy(lil_buf,myncheck((int)to_IQ.devinod.lng,"/dev"));
X
X      if(strlen(lil_buf) == 0)
X      {
X        /* need to send out an error msg */
X        /* format an error message */
X        time(&tloc);
X        nowtime = (struct tm *)localtime(&tloc);
X        time_str = asctime(nowtime);
X        sprintf(errmsg,"IQ: can't find port used by ISPIN pid = %d.  time:\n",(int)to_IQ.pid.lng);
X        strcat(errmsg,"                            ");
X        strcat(errmsg,time_str);
X        strcat(errmsg,"\n");
X    
X        fprintf(stderr,errmsg);
X       /* don't exit */
X     }
X
X/*****************************************************************************/
X     sprintf(out_buf,"%-*s",15, lil_buf);
X/*****************************************************************************/
X      /* get printer's fifo's name from inode number */
X      /* where's his FIFO? */
X
X      strcpy(lil_buf,myncheck((int)to_IQ.my_fifo.lng,FIFOdir));
X
X      if(strlen(lil_buf) == 0)
X      {
X        /* need to send out an error msg */
X        /* format an error message */
X        time(&tloc);
X        nowtime = (struct tm *)localtime(&tloc);
X        time_str = asctime(nowtime);
X        sprintf(errmsg,"IQ: can't find FIFO of ISPIN pid = %d.  time:\n",(int)to_IQ.pid.lng);
X        strcat(errmsg,"                            ");
X        strcat(errmsg,time_str);
X        strcat(errmsg,"\n");
X    
X       fprintf(stderr,errmsg);
X       /* don't exit */
X     }
X
X
X/*****************************************************************************/
X     sprintf(build_cmd,"%-*s",15,lil_buf);
X     strcat(out_buf, build_cmd);
X/*****************************************************************************/
X
X     sprintf(build_cmd,"%-*ld",7,to_IQ.pid.lng);
X     strcat(out_buf, build_cmd);
X     
X     /* create something from the time */
X     tloc = to_IQ.time_in.lng;
X     nowtime = (struct tm *)localtime(&tloc);
X     sprintf(build_cmd,"%2.2d:",nowtime->tm_hour);
X     strcat(out_buf, build_cmd);
X     sprintf(build_cmd,"%2.2d:",nowtime->tm_min);
X     strcat(out_buf, build_cmd);
X     sprintf(build_cmd,"%2.2d ",nowtime->tm_sec);
X     strcat(out_buf, build_cmd);
X
X     if((int)to_IQ.typ.lng == WAITING)
X     {
X       strcat(out_buf,"          ");
X     }
X     else
X     {
X       /* create something from the time */
X       tloc = to_IQ.time_out.lng;
X       nowtime = (struct tm *)localtime(&tloc);
X       sprintf(build_cmd,"%2.2d:",nowtime->tm_hour);
X       strcat(out_buf, build_cmd);
X       sprintf(build_cmd,"%2.2d:",nowtime->tm_min);
X       strcat(out_buf, build_cmd);
X       sprintf(build_cmd,"%2.2d  ",nowtime->tm_sec);
X       strcat(out_buf, build_cmd);
X     }
X
X     /* get logname from uid */
X     pass = getpwuid((int)to_IQ.uid.lng);
X     sprintf(build_cmd,"%-*s",8,pass->pw_name);
X     strcat(out_buf, build_cmd);
X
X     /* which loop are we on? */
X     sprintf(build_cmd,"%*d",5,(int)to_IQ.loop.lng);
X     strcat(out_buf, build_cmd);
X
X     strcat(out_buf, " ");
X
X     switch((int)to_IQ.typ.lng)
X     {
X       case STARTUP:
X           strcat(out_buf,"STARTUP");
X       break;
X       case CONNECTING:
X           strcat(out_buf,"CONNECT");
X       break;
X       case PRINTING:
X           strcat(out_buf,"PRINTING");
X       break;
X       case LOOPING:
X           strcat(out_buf,"LOOPING");
X       break;
X       case WAITING:
X           strcat(out_buf,"WAIT port");
X       break;
X       case DISCONNECTING:
X         strcat(out_buf,"DISCONNECT");
X       break;
X       case QUITTING:
X         strcat(out_buf,"QUITTING");
X       break;
X       default:
X         strcat(out_buf,"NOTIFY SYS ADMIN");
X       break;
X     }
X
X     
X     strcat(out_buf, "\n");
X
X
X     printf(out_buf);
X    }
X  }
X  if(gotstats == 0)
X  {
X    fprintf(stderr,"all quiet\n");
X  }
X}
X
X
Xnot_now(sig)
Xint sig;
X{
X  /* take care of the signals */
X  signal(SIGINT, SIG_IGN);    /* ignore "interrupt" signal <DEL> */
X  signal(SIGHUP, SIG_IGN);    /* ignore "hang up" signal */
X  signal(SIGQUIT, SIG_IGN);   /* ignore "quit" signal */
X  signal(SIGALRM, SIG_IGN);   /* ignore "alarm" signal */
X  signal(SIGTERM, SIG_IGN);   /* ignore "term" signal */
X
X  switch(sig)
X  {
X    case SIGTERM:
X       fprintf(stderr, "IQ: IQUEUER status not available now.\n"); 
X    break;
X    case SIGALRM:
X       fprintf(stderr, "IQ: IQUEUER not running now.\n"); 
X    break;
X    default:
X       fprintf(stderr, "IQ: IQ bombed off.\n"); 
X    break;
X  }
X
X  exit(1);
X}
X
X/**************************************************************************/
X/*                                                                        */
X/* MYNCHECK                                                               */
X/*                                                                        */
X/* 04/20/89 L. Bartz, Internal Revenue Service, Indianapolis              */
X/*                                                                        */
X/* This function is given an inode number and (pointer to) directory      */
X/* name. It returns (pointer to) file name associated with the inode      */
X/* number on success, null character pointer on failure.                  */
X/*                                                                        */
X/* Must have been declared in the calling function like so:               */
X/*                                                                        */
X/*                        char *myncheck();                               */
X/* Called like so:                                                        */
X/*                                                                        */
X/*                  strcpy(fylname,myncheck(inode,dirname));              */
X/*                                                                        */
X/* Where variables have been declared in the calling function like so:    */
X/*                                                                        */
X/*                  int inode;                                            */
X/*                  char *dirname;                                        */
X/*                  char fylname[DIRSIZ + 1];                             */
X/*                                                                        */
X/* DIRSIZ is #defined in sys/dir.h                                        */
X/*                                                                        */
X/*                                                                        */
X/*                                                                        */
X/* 05/11/90  LSB  - Modified for enhanced portability to accomodate the   */
X/*                  more modern "dirent" directory structure and related  */
X/*                  family of directory access routines.                  */
X/*                  Presently only good for those dirent-style systems    */
X/*                  which support a vestigal sys/dir.h file and a         */
X/*                  struct dirent which is named "direct" for backwards   */
X/*                  compatibility.                                        */
X/*                                                                        */
X/*                                                                        */
X/**************************************************************************/
Xchar *myncheck(inode,dirname)
Xint inode;
Xchar *dirname;
X{
X/* uncomment the following if not elsewhere included */
X/* #include <stdio.h> */
X
X/* uncomment the following if not elsewhere included */
X/* #include <sys/types.h> */
X
X/* uncomment the following if not elsewhere included */
X/* #include <sys/dir.h> */
X
X
X  int ret_val = 1;
X
X#ifdef MODERN_DIRS
X/* uncomment the following if not elsewhere included */
X/* #include <strings.h> */
X
X  DIR *file1;
X  struct direct *dp;
X  char dir_name[MAXNAMLEN+1];
X#else
X/* uncomment the following if not elsewhere included */
X/* #include <string.h> */
X/* uncomment the following if not elsewhere included */
X/* #include <fcntl.h> */
X  FILE *file1;
X  struct direct dir1;
X#endif
X
X
X
X#ifdef MODERN_DIRS
X
X        file1 = opendir(dirname);
X
X        while((dp = readdir(file1)) != NULL )
X        {
X          if((int)dp->d_ino == inode)
X          {
X            strcpy(&dir_name[0], dp->d_name);
X	    closedir(file1);
X            return((char *) &dir_name[0]);
X          }
X        }
X        closedir(file1);
X        
X#else
X        file1 = fopen(dirname,"r");
X
X        while(ret_val > 0)
X        {
X          ret_val = fread(&dir1,sizeof(struct direct),1,file1);
X          if((int)dir1.d_ino == inode)
X          {
X	    fclose(file1);
X            return((char *) &dir1.d_name[0]);
X          }
X        }
X        fclose(file1);
X#endif
X
X        /* we didn't find it */
X        return((char *) 0);
X}
END_OF_FILE
if test 24478 -ne `wc -c <'ISPIN/src/IQ.c'`; then
    echo shar: \"'ISPIN/src/IQ.c'\" unpacked with wrong size!
fi
# end of 'ISPIN/src/IQ.c'
fi
if test -f 'ISPIN/src/ISPINTRFCE.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/src/ISPINTRFCE.c'\"
else
echo shar: Extracting \"'ISPIN/src/ISPINTRFCE.c'\" \(5601 characters\)
sed "s/^X//" >'ISPIN/src/ISPINTRFCE.c' <<'END_OF_FILE'
X/****************************************************************************/
X/*                                                                          */
X/* ISPINTRFCE - serves as the "interface" program under the lp(1) spooler.  */
X/*              determines spool member name, then passes name and all      */
X/*              other arguments to ISPIN for execution.                     */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/* ISPIN                                                                    */
X/*                                                                          */
X/* Indianapolis Standard Printer Interface (for Network printers)           */
X/****************************************************************************/
X/*                                                                          */
X/*  Copyright (C) 1991                                                      */
X/*  Larry Bartz                                                             */
X/*  Internal Revenue Service                                                */
X/*  Indianapolis District Office                                            */
X/*                                                                          */
X/*  This program is free software; you can redistribute it and/or modify    */
X/*  it under the terms of the GNU General Public License as published by    */
X/*  the Free Software Foundation, version 1.                                */
X/*                                                                          */
X/*  This program is distributed in the hope that it will be useful,         */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of          */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           */
X/*  GNU General Public License for more details.                            */
X/*                                                                          */
X/*  You should have received a copy of the GNU General Public License       */
X/*  along with this program; if not, write to the Free Software             */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* COMMENTS                                                                 */
X/*                                                                          */
X/* Read comments in common.h for the BIG PICTURE.                           */
X/*                                                                          */
X/* This small executable adds one argument to the argument vector, then     */
X/* execs a centralized ISPIN executable.                                    */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DEFINES                                                                  */
X/*                                                                          */
X/* Nothing defined locally in this program                                  */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* INCLUDES                                                                 */
X/*                                                                          */
X/*                                                                          */
X#include <stdio.h>
X#include <string.h>
X#include "../h/localcnfg.h"
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DATA TYPES, VARIABLES, ETC                                               */
X/*                                                                          */
X/* All local to this program only.                                          */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X  int args, myargs, lp_args;
X  char *base, intrfce[BUFSIZ];
X  char **myargv;
X
X  myargv = (char **) calloc(argc + 1, sizeof(char *));
X
X  base = strrchr(argv[0],'/');
X  ++base;
X  
X  /* INTRFCE is defined in localcnfg.h */
X  strcpy(intrfce,INTRFCE);
X  myargv[0] = &intrfce[0];
X
X  myargv[1] = base;
X
X  myargs = 2;
X  lp_args = 1;
X
X  while(lp_args <= argc)
X  {
X    myargv[myargs++] = argv[lp_args++];
X  }
X
X
X
X  execv(INTRFCE, myargv);
X  
X
X}
END_OF_FILE
if test 5601 -ne `wc -c <'ISPIN/src/ISPINTRFCE.c'`; then
    echo shar: \"'ISPIN/src/ISPINTRFCE.c'\" unpacked with wrong size!
fi
# end of 'ISPIN/src/ISPINTRFCE.c'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/PLAIN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/PLAIN'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/PLAIN'\" \(945 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/PLAIN' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X#
X# The address entered by the user must be the last 8 (eight) digits of the
X# fourteen digit X.25 address of the printer.
X# If you use the ISPI application as the frontend for your users, the comment
X# line following this entry will be used in ISPI's menu.
X#
Xnetind1;/dev/tty22,/dev/contty;9600;-L;-Busy;-Bcongestion;-Bremote dte;-Bfound;-Dcleared;-Dpad>;-DSystem?;-Q\w\032\dclr\r\d;-Q\d\K\pbye\d;System?-\p\K\pbye\r\p-System?;\ppacout\r\d\r\d;connect-\p\r\p-pad>;\p\r\d;pad>-\p\K\dclr\r\w-pad>;set recall=26\r\dconnect\s000000\U\r\d;pened-\p\K\dclr\r\dset recall=26\r\dconnect\s000000\U\r\w-pened;\d;;;
X# user addressable PLAIN
END_OF_FILE
if test 945 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/PLAIN'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/PLAIN'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/PLAIN'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/C351_PLAIN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/C351_PLAIN'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/C351_PLAIN'\" \(947 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/C351_PLAIN' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X#
X# The address entered by the user must be the last 8 (eight) digits of the
X# fourteen digit X.25 address of the printer.
X# If you use the ISPI application as the frontend for your users, the comment
X# line following this entry will be used in ISPI's menu.
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-Bcongestion;-Bremote dte;-Bfound;-Dcleared;-Dpad>;-DSystem;-Q\w\032\dclr\r\d;-Q\d\K\pbye\d;System?-\p\K\pbye\r\p-System?;\ppacout\r\d\r\d;connect-\p\r\d-pad>;\p\r\d;pad>-\p\K\dclr\r\w-pad>;set recall=26\r\dconnect\s000000\U\r\d;pened-\p\K\dclr\r\dset recall=26\r\dconnect\s000000\U\r\w-pened;\d\n\f;;;
X# user addressable C351
END_OF_FILE
if test 947 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/C351_PLAIN'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/C351_PLAIN'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/C351_PLAIN'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_NOSHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_NOSHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_NOSHT'\" \(980 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_NOSHT' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X#
X# The address entered by the user must be the last 8 (eight) digits of the
X# fourteen digit X.25 address of the printer.
X# If you use the ISPI application as the frontend for your users, the comment
X# line following this entry will be used in ISPI's menu.
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-Bcongestion;-Bremote dte;-Bfound;-Dcleared;-Dpad>;-DSystem?;-Q\L\L\032\dclr\r\d;-Q\d\K\pbye\d;System?-\p\K\pbye\r\p-System?;\ppacout\r\d\r\d;connect-\p\r\d-pad>;\p\r\d;pad>-\p\K\dclr\r\w-pad>;set recall=26\r\dconnect\s000000\U\r\d;pened-\p\K\dclr\r\dset recall=26\r\dconnect\s000000\U\r\w-pened;\033S\033F66\033C00\0339\015\033T\E;;;
X# user addressable QUME
X
END_OF_FILE
if test 980 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_NOSHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_NOSHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_NOSHT'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_SHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_SHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_SHT'\" \(980 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_SHT' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X#
X# The address entered by the user must be the last 8 (eight) digits of the
X# fourteen digit X.25 address of the printer.
X# If you use the ISPI application as the frontend for your users, the comment
X# line following this entry will be used in ISPI's menu.
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-Bcongestion;-Bremote dte;-Bfound;-Dcleared;-Dpad>;-DSystem?;-Q\L\L\032\dclr\r\d;-Q\d\K\pbye\d;System?-\p\K\pbye\r\p-System?;\ppacout\r\d\r\d;connect-\p\r\d-pad>;\p\r\d;pad>-\p\K\dclr\r\w-pad>;set recall=26\r\dconnect\s000000\U\r\d;pened-\p\K\dclr\r\dset recall=26\r\dconnect\s000000\U\r\w-pened;\033S\033F90\033C28\0339\015\033T\E;;;
X# user addressable QUME
X
END_OF_FILE
if test 980 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_SHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_SHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/USER_ADDR/QUME_SHT'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/C351_PLAIN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/C351_PLAIN'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/C351_PLAIN'\" \(330 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/C351_PLAIN' <<'END_OF_FILE'
X#
X#
Xnetind1;/dev/ttyi07,/dev/ttyi31,/dev/ttyi15;9600;-L;-Bcongestion;-Bremote dte;-Q\L\L\032\dclr\r\d;-DConnection cleared;-Dpad>;ad>-\p\K\pclr\r\d-ad>;\r\p;pad>-\p\K\pclr\r\d-pad>;set recall=26\r\p;pad>-\r\d-pad>;\pconnect\s00000099999999\r\d;pened-\p\K\pclr\r\dset recall=26\r\p\pconnect\s00000099999999\r\d-pened;\d\n\f;;;
X#
X#
END_OF_FILE
if test 330 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/C351_PLAIN'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/C351_PLAIN'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/C351_PLAIN'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_NOSHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_NOSHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_NOSHT'\" \(349 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_NOSHT' <<'END_OF_FILE'
X#
X#
X#
Xnetind1;/dev/ttyi07,/dev/ttyi31,/dev/ttyi15;9600;-L;-Bcongestion;-Bremote dte;-Q\L\L\032\dclr\r\d;-DConnection cleared;-Dpad>;ad>-\p\K\pclr\r\d-ad>;\r\p;pad>-\p\K\pclr\r\d-pad>;set recall=26\r\p;pad>-\r\d-pad>;\pconnect\s00000099999999\r\d;pened-\p\K\pclr\r\dset recall=26\r\p\pconnect\s00000099999999\r\d-pened;\d\033F66\033C00\0339\d;;;
X#
X#
END_OF_FILE
if test 349 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_NOSHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_NOSHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_NOSHT'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_SHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_SHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_SHT'\" \(349 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_SHT' <<'END_OF_FILE'
X#
X#
X#
Xnetind1;/dev/ttyi07,/dev/ttyi31,/dev/ttyi15;9600;-L;-Bcongestion;-Bremote dte;-Q\L\L\032\dclr\r\d;-DConnection cleared;-Dpad>;ad>-\p\K\pclr\r\d-ad>;\r\p;pad>-\p\K\pclr\r\d-pad>;set recall=26\r\p;pad>-\r\d-pad>;\pconnect\s00000099999999\r\d;pened-\p\K\pclr\r\dset recall=26\r\p\pconnect\s00000099999999\r\d-pened;\d\033F90\033C28\0339\d;;;
X#
X#
END_OF_FILE
if test 349 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_SHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_SHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/QUME_SHT'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/PLAIN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/PLAIN'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/PLAIN'\" \(578 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/PLAIN' <<'END_OF_FILE'
X# The address entered by the user must be the last 8 (eight) digits of the
X# fourteen digit X.25 address of the printer.
X# If you use the ISPI application as the frontend for your users, the comment
X# line following this entry will be used in ISPI's menu.
X#
X#
X#
Xextplain;/dev/ttyi07,/dev/ttyi31,/dev/ttyi15;9600;-L;-Bcongestion;-Bremote dte;-Q\L\L\032\dclr\r\d;-DConnection cleared;-Dpad>;ad>-\p\K\pclr\r\d-ad>;\r\p;pad>-\p\K\pclr\r\d-pad>;set recall=26\r\p;pad>-\r\d-pad>;\pconnect\s000000\U\r\d;pened-\p\K\pclr\r\dset recall=26\r\p\pconnect\s000000\U\r\d-pened;\d;;;
X#Plain
X#
END_OF_FILE
if test 578 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/PLAIN'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/PLAIN'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/PLAIN'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/C351_PLAIN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/C351_PLAIN'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/C351_PLAIN'\" \(592 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/C351_PLAIN' <<'END_OF_FILE'
X# The address entered by the user must be the last 8 (eight) digits of the
X# fourteen digit X.25 address of the printer.
X# If you use the ISPI application as the frontend for your users, the comment
X# line following this entry will be used in ISPI's menu.
X#
X#
X#
Xextcent;/dev/ttyi07,/dev/ttyi31,/dev/ttyi15;9600;-L;-Bcongestion;-Bremote dte;-Q\L\L\032\dclr\r\d;-DConnection cleared;-Dpad>;ad>-\p\K\pclr\r\d-ad>;\r\p;pad>-\p\K\pclr\r\d-pad>;set recall=26\r\p;pad>-\r\d-pad>;\pconnect\s000000\U\r\d;pened-\p\K\pclr\r\dset recall=26\r\p\pconnect\s000000\U\r\d-pened;\d\n\f;;;
X#Centronics
X#
X#
X#
X#
END_OF_FILE
if test 592 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/C351_PLAIN'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/C351_PLAIN'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/C351_PLAIN'
fi
echo shar: End of archive 4 \(of 15\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

