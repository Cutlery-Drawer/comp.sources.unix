Newsgroups: comp.sources.unix
From: sir-alan!ispin!lbartz@iuvax.cs.indiana.edu (Larry Bartz)
Subject: v25i119: Indianapolis Standard Printer Interface for Networked printers, Part08/15
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: sir-alan!ispin!lbartz@iuvax.cs.indiana.edu (Larry Bartz)
Posting-Number: Volume 25, Issue 119
Archive-Name: ispin/part08

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 15)."
# Contents:  ISPIN/src/ISPIN.c.ab ISPIN/install/rtab
#   ISPIN/doc/OLD-DOCS/README.beta.2 ISPIN/misc/ISPIT.dr/do_ispit.sh
#   ISPIN/misc/ISPIT.dr/interface
# Wrapped by socrates@indy6 on Tue Jan 28 15:26:52 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ISPIN/src/ISPIN.c.ab' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/src/ISPIN.c.ab'\"
else
echo shar: Extracting \"'ISPIN/src/ISPIN.c.ab'\" \(27709 characters\)
sed "s/^X//" >'ISPIN/src/ISPIN.c.ab' <<'END_OF_FILE'
X
X                    /* Put our new-found data in the newly allocated storage */
X                    /* after first aiming the pointer at more new storage.   */
X                    /* string begins at tokptr[2] */
X                    dead_curr->dead_strg = (char *) calloc(1, ((strlen(&tokptr[2]))+1));
X                    strcpy(dead_curr->dead_strg,&tokptr[2]);
X
X
X
X
X
X                    /* terminate the list */
X                    dead_curr->next = NULL;
X                    break;
X                  case 'Q':
X                    /* QUIT */
X                    while(quit_curr->next != NULL) /* until end o'list */
X                    {
X                      /* walk down the list */
X                      quit_curr = quit_curr->next;
X                    }
X
X                    /* don't really use the head for data storage */
X                    /* allocate a new one */
X                    quit_list = (struct quit_list *) calloc(1,sizeof(struct quit_list));
X
X                    /* link it */
X                    quit_curr->next = quit_list;
X
X                    /* make the new list member the current list member */
X                    quit_curr = quit_list;
X
X                    /* Put our new-found data in the newly allocated storage */
X                    /* after first aiming the pointer at more new storage.   */
X                    /* string begins at tokptr[2] */
X                    quit_curr->quit_strg = (char *) calloc(1, ((strlen(&tokptr[2]))+1));
X                    strcpy(quit_curr->quit_strg,&tokptr[2]);
X
X
X
X
X
X                    /* terminate the list */
X                    quit_curr->next = NULL;
X                    break;
X                  case 'D':
X                    /* DISCONNECT */
X                    while(disc_curr->next != NULL) /* until end o'list */
X                    {
X                      /* walk down the list */
X                      disc_curr = disc_curr->next;
X                    }
X
X                    /* don't really use the head for data storage */
X                    /* allocate a new one */
X                    disc_list = (struct disc_list *) calloc(1,sizeof(struct disc_list));
X
X                    /* link it */
X                    disc_curr->next = disc_list;
X
X                    /* make the new list member the current list member */
X                    disc_curr = disc_list;
X
X                    /* Put our new-found data in the newly allocated storage */
X                    /* after first aiming the pointer at more new storage.   */
X                    /* string begins at tokptr[2] */
X                    disc_curr->disc_strg = (char *) calloc(1, ((strlen(&tokptr[2]))+1));
X                    strcpy(disc_curr->disc_strg,&tokptr[2]);
X
X
X
X
X
X                    /* terminate the list */
X                    disc_curr->next = NULL;
X                    break;
X                  case 'L':
X                    /* LOGGING enabled */
X                    ++logging;
X                    break;
X                  case 'R':
X                    /* absolutely RAW output */
X                    ++raw;
X                    break;
X                  case 'T':
X                    /* TAB EXPANSION enabled */
X                    if(raw < 1)
X                    {
X                      ++tab_expand;
X                    }
X                    break;
X                }
X                break;
X              default:
X                switch(toggle)
X                {
X                  case 0:
X                    /* EXPECT */
X                    toggle = 1;   /* switch the EXPECT/SEND toggle */
X                    while(expt_curr->next != NULL) /* until end o'list */
X                    {
X                      /* walk down the list */
X                      expt_curr = expt_curr->next;
X                    }
X
X                    /* don't really use the head for data storage */
X                    /* allocate a new one */
X                    expt_list = (struct expt_list *) calloc(1,sizeof(struct expt_list));
X
X                    /* link it */
X                    expt_list->prev = expt_curr;
X                    expt_curr->next = expt_list;
X
X                    /* make the new list member the current list member */
X                    expt_curr = expt_list;
X
X                    /* Put our new-found data in the newly allocated storage */
X                    /* after first aiming the pointer at more new storage.   */
X                    expt_curr->expt_strg = (char *) calloc(1, ((strlen(tokptr))+1));
X                    strcpy(expt_curr->expt_strg,tokptr);
X
X                    /* terminate the list */
X                    expt_curr->next = NULL;
X                    break;
X                  case 1:
X                    /* SEND */
X                    toggle = 0;   /* switch the EXPECT/SEND toggle */
X                    while(send_curr->next != NULL) /* until end o'list */
X                    {
X                      /* walk down the list */
X                      send_curr = send_curr->next;
X                    }
X
X                    /* don't really use the head for data storage */
X                    /* allocate a new one */
X                    send_list = (struct send_list *) calloc(1,sizeof(struct send_list));
X
X                    /* link it */
X                    send_list->prev = send_curr;
X                    send_curr->next = send_list;
X
X                    /* make the new list member the current list member */
X                    send_curr = send_list;
X
X                    /* Put our new-found data in the newly allocated storage */
X                    /* after first aiming the pointer at more new storage.   */
X                    send_curr->send_strg = (char *) calloc(1, ((strlen(tokptr))+1));
X                    strcpy(send_curr->send_strg,tokptr);
X
X                    /* terminate the list */
X                    send_curr->next = NULL;
X                    break;
X                }
X                break;
X            }
X            break;
X        }
X      }
X      return(0);
X    }
X    else
X    {
X      return(1);
X    }
X  }
X  else
X  {
X    return(1);
X  }
X}
X
X
X/****************************************************************************/
X/*  notify               author = bartz                            112988   */
X/****************************************************************************/
X/*                                                                          */
X/*   subroutine to notify secondary queuer of our state and (maybe) await   */
X/*   acknowledgement                                                        */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/*   description -  This function sends a message to the secondary queuer   */
X/*                  via a FIFO from which only the secondary queuer is      */
X/*                  reading. We then read from a private FIFO through       */
X/*                  which only the secondary queuer will write. The         */
X/*                  message we send notifies the secondary queuer of our    */
X/*                  state and of our needs. The message the secondary       */
X/*                  queuer (IQUEUER) sends us gives us our marching         */
X/*                  orders.                                                 */
X/*                                                                          */
X/*                                                                          */
X/*   how invoked - notify(state)                                            */
X/*                 int state;                                               */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X
Xnotify(state)
Xint state;
X{
X
X  /* set a global variable to retain current state */
X  stayt = state;
X
X  switch(state)
X  {
X    case HERE:
X      /* tell IQUEUER we're here */
X      /* construct the message */
X
X      /* what type of message? */
X      req_msg.typ.intgr = HERE;
X
X      /* what is my pid? */
X      req_msg.my_pid.intgr = getpid();
X
X      /* get the inode of the device(s) we want */
X
X      for(ret_val = 0;ret_val <= 10; ++ret_val)
X      {
X        if(strcmp(dev_ray[ret_val].name,"NONE") != 0)
X        {
X          if(stat(dev_ray[ret_val].name,stat_buf))
X          {
X            /* need to send out an error msg */
X            /* format an error message */
X            time(&tloc);
X            nowtime = (struct tm *)localtime(&tloc);
X            time_str = asctime(nowtime);
X
X            sprintf(errmsg,"ISPIN: printer %s: stat %s: %s.\n",dest,dev_ray[ret_val].name,sys_errlist[errno]);
X            sprintf(errmsg2,"    USER: %s\n",from);
X            strcat(errmsg,errmsg2);
X          if(usr_addr)
X          {
X            sprintf(errmsg2,"    ADDR: %s\n",usr_strng);
X            strcat(errmsg,errmsg2);
X          }
X#ifdef NQ
X            sprintf(errmsg2,"    FILE: %s\n",fyle);
X#else
X            sprintf(errmsg2,"    FILE: %s\n",fyles[0]);
X#endif
X            strcat(errmsg,errmsg2);
X            sprintf(errmsg2,"    TIME: %s\n",time_str);
X            strcat(errmsg,errmsg2);
X
X            /* call the error routine, never come back */
X            my_error(SYSERR);
X          }
X          dev_ray[ret_val].inode = (int)stat_buf->st_ino;
X        }
X	else
X	{
X	  dev_ray[ret_val].inode = 0;
X	}
X      }
X
X      req_msg.dev1_inod.intgr = dev_ray[0].inode;
X      req_msg.dev2_inod.intgr = dev_ray[1].inode;
X      req_msg.dev3_inod.intgr = dev_ray[2].inode;
X      req_msg.dev4_inod.intgr = dev_ray[3].inode;
X      req_msg.dev5_inod.intgr = dev_ray[4].inode;
X      req_msg.dev6_inod.intgr = dev_ray[5].inode;
X      req_msg.dev7_inod.intgr = dev_ray[6].inode;
X      req_msg.dev8_inod.intgr = dev_ray[7].inode;
X      req_msg.dev9_inod.intgr = dev_ray[8].inode;
X      req_msg.dev10_inod.intgr = dev_ray[9].inode;
X      req_msg.dev11_inod.intgr = dev_ray[10].inode;
X
X      /* identify the requesting user */
X      if((pass = getpwnam(from)) != NULL)
X      {
X        req_msg.uid.intgr = pass->pw_uid;
X        endpwent();
X      }
X      else
X      {
X        req_msg.uid.intgr = (int)getuid();
X      }
X
X#ifdef LP
X      /* If this process is running as setuid to root (uid == 0),
X         then setuid to the requesting user.      05/09/91  LSB   */
X      if(geteuid() == 0)
X      {
X        setgid(pass->pw_gid);
X        setuid(pass->pw_uid);
X      }
X#endif
X
X      /* this is loop 0 */
X      req_msg.loop.intgr = 0;
X
X      /* fill the msg_buf from the structure of unions */
X      count1 = count2 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.typ.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.my_pid.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.my_fifo.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev1_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev2_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev3_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev4_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev5_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev6_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev7_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev8_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev9_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev10_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev11_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.uid.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.loop.chr[count1++];
X      }
X      count1 = 0;
X      count2 = 0;
X
X      /* the message is ready to go, so send it */
X
X      write(outfifo,msg_buf,to_iqrsiz);
X
X      /* Now wait for a response, in the form of a work order. */
X      /* A blocking read will allow the kernel to put us to sleep until... */
X
X      chars_got = read(infifo,msg_buf,to_ispinsiz);
X      if(chars_got < 1)
X      {
X        close(infifo);
X        if((infifo = open(inFIFO,O_RDONLY)) == -1)
X        {
X          /* need to send out an error msg */
X                /* format an error message */
X                time(&tloc);
X                nowtime = (struct tm *)localtime(&tloc);
X                time_str = asctime(nowtime);
X
X                sprintf(errmsg,"ISPIN: printer %s: open %s: %s.\n",dest,inFIFO,sys_errlist[errno]);
X          sprintf(errmsg2,"    USER: %s\n",from);
X          strcat(errmsg,errmsg2);
X          if(usr_addr)
X          {
X            sprintf(errmsg2,"    ADDR: %s\n",usr_strng);
X            strcat(errmsg,errmsg2);
X          }
X#ifdef NQ
X          sprintf(errmsg2,"    FILE: %s\n",fyle);
X#else
X          sprintf(errmsg2,"    FILE: %s\n",fyles[0]);
X#endif
X          strcat(errmsg,errmsg2);
X          sprintf(errmsg2,"    TIME: %s\n",time_str);
X          strcat(errmsg,errmsg2);
X
X               /* call the error routine, never come back */
X               my_error(SYSERR);
X
X        }
X        chars_got = read(infifo,msg_buf,to_ispinsiz);
X      }
X
X      /* back from the read, so proceed */
X      /* fill the structure of unions from the msg_buf */
X      while(count1 < intsize)
X      {
X        cmd_msg.orders.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        cmd_msg.iq_pid.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        cmd_msg.dev_use_ino.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        cmd_msg.pad1.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X      count2 = 0;
X
X      /* the way things look now (12/06/88), the only message we'll get is GO */
X      /* otherwise, I'd put in a switch on cmd_msg.orders right here.          */
X
X
X      /* IQUEUER chose which device we are to use */
X      for(ret_val = 0;ret_val <= 10; ++ret_val)
X      {
X        if(cmd_msg.dev_use_ino.intgr == dev_ray[ret_val].inode)
X        {
X          strcpy(GO_dev,dev_ray[ret_val].name);
X	  /* set a flag to indicate success */
X	  count1 = 1;
X        }
X      }
X      if(count1 == 0)
X      {
X        /* big problems */
X        /* need to send out an error msg */
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X
X          sprintf(errmsg,"ISPIN: printer %s: goofy inode from IQUEUER.\n",dest);
X          sprintf(errmsg2,"    USER: %s\n",from);
X          strcat(errmsg,errmsg2);
X          if(usr_addr)
X          {
X            sprintf(errmsg2,"    ADDR: %s\n",usr_strng);
X            strcat(errmsg,errmsg2);
X          }
X#ifdef NQ
X          sprintf(errmsg2,"    FILE: %s\n",fyle);
X#else
X          sprintf(errmsg2,"    FILE: %s\n",fyles[0]);
X#endif
X          strcat(errmsg,errmsg2);
X          sprintf(errmsg2,"    TIME: %s\n",time_str);
X          strcat(errmsg,errmsg2);
X
X         /* call the error routine, never come back */
X         my_error(MYERR);
X
X      }
X      
X      break;
X
X    case BUSY:
X   /* Assign an initial value to GO_dev string, so log messages which use */
X   /* it make sense. Also so we don't dump core trying to strcat from a   */
X   /* memory address which is undefined.                    05/09/90 LSB  */
X   sprintf(GO_dev,"undefined");
X
X      /* what type of message? */
X      req_msg.typ.intgr = BUSY;
X
X      /* that's all we have to change from the previous message */
X
X      /* the message is ready to go, so send it */
X
X      /* fill the msg_buf from the structure of unions */
X      count1 = count2 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.typ.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.my_pid.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.my_fifo.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev1_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev2_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev3_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev4_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev5_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev6_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev7_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev8_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev9_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev10_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev11_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.uid.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.loop.chr[count1++];
X      }
X      count1 = 0;
X      count2 = 0;
X
X      /* the message is ready to go, so send it */
X
X      write(outfifo,msg_buf,to_iqrsiz);
X
X      /* Now wait for a response, in the form of a work order. */
X      /* A blocking read will allow the kernel to put us to sleep until... */
X
X      chars_got = read(infifo,msg_buf,to_ispinsiz);
X      if(chars_got < 1)
X      {
X        close(infifo);
X        if((infifo = open(inFIFO,O_RDONLY)) == -1)
X        {
X          /* need to send out an error msg */
X                /* format an error message */
X                time(&tloc);
X                nowtime = (struct tm *)localtime(&tloc);
X                time_str = asctime(nowtime);
X
X                sprintf(errmsg,"ISPIN: printer %s: open %s: %s.\n",dest,inFIFO,sys_errlist[errno]);
X          sprintf(errmsg2,"    USER: %s\n",from);
X          strcat(errmsg,errmsg2);
X          if(usr_addr)
X          {
X            sprintf(errmsg2,"    ADDR: %s\n",usr_strng);
X            strcat(errmsg,errmsg2);
X          }
X#ifdef NQ
X          sprintf(errmsg2,"    FILE: %s\n",fyle);
X#else
X          sprintf(errmsg2,"    FILE: %s\n",fyles[0]);
X#endif
X          strcat(errmsg,errmsg2);
X          sprintf(errmsg2,"    TIME: %s\n",time_str);
X          strcat(errmsg,errmsg2);
X
X               /* call the error routine, never come back */
X               my_error(SYSERR);
X
X        }
X        chars_got = read(infifo,msg_buf,to_ispinsiz);
X      }
X
X
X      /* back from the read, so proceed */
X      /* fill the structure of unions from the msg_buf */
X      while(count1 < intsize)
X      {
X        cmd_msg.orders.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        cmd_msg.iq_pid.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        cmd_msg.dev_use_ino.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        cmd_msg.pad1.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X      count2 = 0;
X
X      /* the way things look now (12/06/88), the only message we'll get is GO */
X      /* otherwise, I'd put in a switch on cmd_msg.orders right here.          */
X
X      /* IQUEUER chose which device we are to use */
X      for(ret_val = 0;ret_val <= 10; ++ret_val)
X      {
X        if(cmd_msg.dev_use_ino.intgr == dev_ray[ret_val].inode)
X        {
X          strcpy(GO_dev,dev_ray[ret_val].name);
X	  /* set a flag to indicate success */
X	  count1 = 1;
X        }
X      }
X      if(count1 == 0)
X      {
X        /* big problems */
X        /* need to send out an error msg */
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X
X          sprintf(errmsg,"ISPIN: printer %s: goofy inode from IQUEUER.\n",dest);
X          sprintf(errmsg2,"    USER: %s\n",from);
X          strcat(errmsg,errmsg2);
X          if(usr_addr)
X          {
X            sprintf(errmsg2,"    ADDR: %s\n",usr_strng);
X            strcat(errmsg,errmsg2);
X          }
X#ifdef NQ
X          sprintf(errmsg2,"    FILE: %s\n",fyle);
X#else
X          sprintf(errmsg2,"    FILE: %s\n",fyles[0]);
X#endif
X          strcat(errmsg,errmsg2);
X          sprintf(errmsg2,"    TIME: %s\n",time_str);
X          strcat(errmsg,errmsg2);
X
X         /* call the error routine, never come back */
X         my_error(MYERR);
X
X      }
X
X      break;
X
X
X    case DONE:
X    case TROUBLE:
X      /* tell IQUEUER we're finished */
X      /* construct the message */
X
X      /* what type of message? */
X      req_msg.typ.intgr = DONE;
X
X      /* that's all we have to change from the previous message */
X
X      /* the message is ready to go, so send it */
X
X      /* fill the msg_buf from the structure of unions */
X      count1 = count2 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.typ.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.my_pid.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.my_fifo.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev1_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev2_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev3_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev4_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev5_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev6_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev7_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev8_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev9_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev10_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev11_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.uid.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.loop.chr[count1++];
X      }
X      count1 = 0;
X      count2 = 0;
X
X      /* the message is ready to go, so send it */
X
X      write(outfifo,msg_buf,to_iqrsiz);
X
X
X      /* Don't wait for a response */
X
X      break;
X
X    default:
X      /* pass current state to IQUEUER */
X      /* construct the message */
X
X      /* what type of message? */
X      req_msg.typ.intgr = state;
X
X      /* that's all we have to change from the previous message */
X
X      /* the message is ready to go, so send it */
X
X      /* fill the msg_buf from the structure of unions */
X      count1 = count2 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.typ.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.my_pid.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.my_fifo.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev1_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev2_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev3_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev4_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev5_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev6_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev7_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev8_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev9_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev10_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.dev11_inod.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.uid.chr[count1++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        msg_buf[count2++] = req_msg.loop.chr[count1++];
X      }
X      count1 = 0;
X      count2 = 0;
X
X      /* the message is ready to go, so send it */
X
X      write(outfifo,msg_buf,to_iqrsiz);
X
X
X      /* Don't wait for a response */
X
X      break;
X  }
X}
X
X
Xtimeout(sig)
Xint sig;
X{
X        signal(SIGALRM, my_error);
X
X  /* take care of the signals */
X        signal(SIGINT, SIG_IGN);    /* ignore "interrupt" signal <DEL> */
X        signal(SIGHUP, SIG_IGN);    /* ignore "hang up" signal */
X        signal(SIGQUIT, SIG_IGN);   /* ignore "quit" signal */
X        signal(SIGTERM, my_error);
X#ifdef NQ
END_OF_FILE
if test 27709 -ne `wc -c <'ISPIN/src/ISPIN.c.ab'`; then
    echo shar: \"'ISPIN/src/ISPIN.c.ab'\" unpacked with wrong size!
fi
# end of 'ISPIN/src/ISPIN.c.ab'
fi
if test -f 'ISPIN/install/rtab' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/rtab'\"
else
echo shar: Extracting \"'ISPIN/install/rtab'\" \(18364 characters\)
sed "s/^X//" >'ISPIN/install/rtab' <<'END_OF_FILE'
X# PUT YOUR NEW RTAB ENTRIES ABOVE HERE. SEPARATE EACH ENTRY WITH A COMMENT
X# LINE OR TWO FOR EASIER READING.
X#
X#
X#NAME;DEVICE(s);SPEED;FLAGS;EXPECT;SEND;...;EXPECT;SEND;
X#
X# GENERAL INFORMATION:  A leading "#" makes the current line a comment. 
X#                       Blank lines are not valid - use a line with only a 
X#                       "#" instead.
X#                       Maximum line length is BUFSIZ for your cpu; plenty.
X#                       Line feed or carriage return terminates the line.
X#                       Allow long lines to wrap around.
X#
X# DELIMETER: The field delimiter is the semi-colon. The use of a field
X#            delimiter drags the syntax of the table away from the uucp-like
X#            format we were looking for. The positive side of the trade-off
X#            is that the delimiter makes it much easier for the user to specify
X#            tabs and spaces in the EXPECT/SEND pairs when or if necessary.
X#
X# CARRIAGE RETURNS: Uucp will generally tag its own carriage return on the end
X#                   of any sent string. The user is responsible (under Honey-
X#                   DanBer uucp, at least) for specifying when a carriage 
X#                   return should NOT be sent at the end of a string. 
X#                   In our case, however, WYSIWYG (what you see is what you
X#                   get). So if you want a carriage return to be issued at
X#                   any point, make a carriage return (a REAL <ctrl>M or a \r)
X#                   part of the string to be sent.
X#
X#
X# NAME is a required entry. NAME must match the name by which the
X# queuer knows the printer (LP), or the argument to the "-P" flag which
X# must be specified on the appropriate line in /usr/spool/queuer/config
X# (NQ).
X#
X#
X# DEVICE is a required entry. At least the primary device must be shown
X# in this field. A total of eleven devices may be specified. They can be used
X# as alternative routes to the printer. If ISPIN is unable to contact
X# the printer via the first device because IQUEUER has determined it is
X# busy, ISPIN will attempt to contact the printer via the subsequent
X# devices. If contact via the other devices is also blocked,
X# the print request will be queued in the shortest of IQUEUER's virtual
X# queues for the devices.
X# Within the DEVICES field, the primary and subsequent device are separated
X# by commas. No white space allowed. From one to eleven devices may be
X# defined.
X#
X#
X# SPEED is a required entry. Valid entries include
X#
X#                                                  50
X#                                                  75
X#                                                  110
X#                                                  134
X#                                                  150
X#                                                  200
X#                                                  300
X#                                                  600
X#                                                  1200
X#                                                  1800
X#                                                  2400
X#                                                  4800
X#                                                  9600
X#                                                  19200
X#
X# Any other value in this field will be considered nonsense.
X# The SPEED parameter must match the speed of the port to the
X# network connection through which the remote printer will
X# be addressed. The primary and subsequent devices must all
X# be the same speed. No white space allowed.
X#
X# Other tty communication parameters are presently hard-coded as:
X# 
X# 8  data bits
X# 1  stop bit
X# NO parity
X#
X# This seems to have suited everyone so far. If it causes you a pain,
X# let me know.
X#
X# FLAGS
X#
X# The seven flags and their associated arguments are optional but their
X# inclusion will help assure a successful network negotiation, assist in
X# the diagnosis of problems, and permit tuning of the behavior of the ispin
X# process.
X#
X# -Bstring
X# The "-B" flag allows specification as many "busy" strings as necessary.
X# What do we do in case of network busy? A "busy" condition could be 
X# encountered at any link in the net. The administrator should specify
X# a key string from each busy msg which may be encountered. The key word(s)
X# will vary from Tellabs, to X.25 async pad, Mitron, whatever. If more than one 
X# type of networking system will be encountered, multiple "busy" flags
X# and strings should be specified. If a designated busy situation is 
X# encountered, the ISPIN process will sleep a while (number of seconds
X# specified at compile time), quit the network, close the port, notify the
X# IQUEUER it has encountered "busy", then await another go ahead message 
X# from the IQUEUER.
X#
X# -Istring
X# The "-I" flag allows specification of as many "inactive" strings as necessary.
X# Inactive condition is just a FAILURE, so no looping is permitted. 
X# If a network negotiation fails due to an identified inactive condition,
X# the failure error message will so specify. The sysadm, datacom, and user
X# should rectify the inactive condition before the user re-requests.
X# Beta testing has shown that this flag is usually not necessary.
X#
X# -Qstring
X# the "-Q" flag and argument allows specification of as many "quit" strings
X# as necessary. These will be issued at the conlusion of the print job in the
X# sequence they are shown in the table. The purpose of these "quit" strings
X# is to allow the job to sever the network virtual connections in a clean and
X# logical manner. This is also the place to issue any post-printing commands
X# to the printer, such as to return it to a "standard" configuration if
X# necessary.
X#
X# -Dstring
X# The "-D" flag and argument allows the specification of a string the network
X# will send us when/if the printer is powered-down or otherwise disconnected.
X# After each burst of characters, the program will check to see if there are
X# any characters to be read. Under normal conditions, there will be none.
X# If the printer has been powered-down or disconnected, we expect the network
X# to somehow signify the event with a particular message or other readable
X# response. These possible responses are specified as argument(s) to the "-D" 
X# flag. ISPIN's reaction to this condition is to loop and try to re-establish
X# the connection. 
X#
X# -L
X# This flag takes no argument. If the -L flag is present, event logging is
X# enabled. ISPIN will write an entry to its log file for each file which is
X# printed. If the -L flag is absent, only error messages will be written to
X# the log file.
X#
X# -R
X# This flag takes no argument. If the -R flag is present, the tty through
X# which ISPIN communicates will be set so that it DOES NOT transmit the
X# "newline" (ascii "LF", or octal \012) as the newline/carriage return pair.
X# Note that the LF/LF-CR conversion is the default condition if -R is not
X# present. For most printers, DO NOT USE THIS FLAG. This flag is included
X# specifically for supporting the transmission of binary information (such
X# as would be the case with raster graphics).
X#
X# -T
X# This flag takes no argument. If the -T flag is present, tabs will be
X# expanded to spaces on output. If -R flag is present, -T has no effect.
X#
X# EXPECT SEND
X#
X# ISPIN supports uucp's EXPECT-SEND-EXPECT construct and logic. That is,
X# if there is an EXPECT string which contains two dashes, the string will
X# be parsed such that everything up to the first dash is expected. If it is
X# not received, the chars which lie between the dashes will be sent. Then, what
X# remains beyond the second dash is expected. Alternatively, if the first
X# expected string IS received, the remainder of the construct is ignored.
X#
X# ISPIN does support the HoneyDanBer-style faked ascii representation
X# of special characters (two-character pairs such as "\N" for the null
X# character, "\n" for the newline character, and "\t" for tab), as well as
X# the "\###" octal representation of ascii characters.
X# The set of such characters and the associated actions follows:
X#
X#           \N
X#             send a NULL
X#
X#           \b
X#             send a backspace
X#
X#           \L
X#             loaf 30 seconds
X#
X#           \w
X#             wait 10 seconds
X#
X#           \d
X#             delay 3 seconds
X#
X#           \p
X#             pause a second
X#
X#           \n
X#             send a newline
X#
X#           \e
X#             send "escape"
X#
X#           \r
X#             send a carriage return
X#
X#           \s
X#             send a space
X#
X#           \t
X#             send a tab
X#
X#           \f
X#             send a formfeed
X#
X#           \K
X#             send BREAK
X#
X#           \E
X#             send two EOT and newline pairs
X#
X#           \D
X#             send a DELETE
X#
X#           \U
X#             send the user-supplied string. The string is passed to 
X#             ISPIN via the "dest" argument to nq's "-d" flag, or
X#             via the "option" argument to lp's "-o" flag
X#
X#           \###
X#             not literally "###" but three digits which will be 
X#             interpreted as an octal representation of the character
X#             which is to be sent, such as \007 for ascii BEL, and
X#             \033 for ESCAPE.
X#             MUST BE THREE, and ONLY THREE DIGITS.
X#
X#
X# It is NOT possible to specify a null EXPECT or SEND string by placing the
X# field delimeter ";" (semicolon) which terminates the string IMMEDIATELY
X# adjacent to the delimeter which marks the beginning of the string.
X# This is because of a quirk of the C strtok function we are using to parse
X# the rtab entry.
X#
X# It is possible to "fake" null SEND and EXPECT sequences thusly:
X#
X#       NULL SEND string:         ;\p;
X#                                        A timing pause of any duration,
X#                                        with no other characters results
X#                                        proper parsing but no characters
X#                                        sent.
X#
X#       NULL EXPECT string:       ; -;
X#                                        This is quirky, but it works. 
X#                                        This gets parsed as "Expect a
X#                                        space. If not received, send 
X#                                        nothing".
X#
X#
X#
X# Keep in mind that we are treating all WHITE SPACE as SIGNIFICANT.
X# If you put space(s), or tabs(s), or anything else within a field, that
X# that is what will be expected or sent.
X# WYSIWYG. What you see is what you get!
X#
X# Each received string will be compared to the "expect", each 
X# of the "busy" strings and each of the "inactive" strings.
X# The flags are optional. If none are configured, then any 
X# deviation from the "EXPECT/SEND" sequence will be treated as a FAILURE.
X#
X# The EXPECT/SEND pairs must be set up as PAIRS in the sequence ;EXPECT;SEND;
X# Since most printers do not issue any sort of acknowledgement message, the 
X# last EXPECT will be issued by the network. Terminate the sequence with a
X# null SEND, even though we know that upon receiving the final EXPECT, we
X# are connected. The terminating SEND must be "closed" with a terminating ";".
X#
X# RESTRICTIONS
X#
X# Any field, the first character of which is a "-" (dash), will be inter-
X# preted as a FLAG field. The second character of such a field MUST be 
X# "B", "Q", "I", "D", "L", or "R". Any other field, the first character
X# of which is a "-" (dash), is ignored.
X#
X# EXAMPLES - The examples are "quoted-out" with a leading "#" for your
X#            convenience.
X#
X#NAME  DEVICE               SPEED       FLAGS                     EXPECT SEND
X# This the rtab entry for my printer. The printer is hung from the pad, and the
X# cpu is connected to the Tellabs switch. The printer's name is LSB1. We may
X# access it from two possible ports. The speed is 9600. I have configured three
X# possible "busy" messages, and one "inactive" message. The "quit" sequence
X# makes a clean break from the pad (with <BREAK>clr), then from my switch
X# (with <BREAK>bye). The EXPECT/SEND sequence goes like this: expect "System?"
X# (part of my switch's login herald). If you don't get it, send <BREAK>bye,
X# then expect "System?" again. send "pacout", which is a dial sequence to
X# access X.25 async pad through our switch. expect "connect" (info message from
X# our switch). If you don't get it, send a carriage return, then expect "pad>",
X# which is the prompt from the pad. Send a carriage return. expect "pad>". If we
X# don't get it, send <BREAK>clr, then expect "pad>". send the "connect" command
X# and network address of the printer. expect the pad's message which indicates
X# a successful connection. If we don't get it, send the connect command and 
X# address again, and expect a successful connection message. The next "send"
X# is simply a 3 second delay. The sequence MUST be terminated by a NULL "send",
X# and since we don't expect the printer to give any indication that we are
X# connected, the last "send" is preceded by an NULL "expect".
X#
X# PLEASE NOTE the liberal sprinkling of 1 second pauses and 3 second delays.
X# Believe it or not, even the lowly Zilog is capable of executing the ISPIN
X# code faster than the network is able to resond. The pauses and delays keep
X# us from getting ahead of the network so we don't get lost.
X#
X# PLEASE NOTE: I have chopped this entry into separate lines so you may print
X# it. A REAL rtab entry must be all one line.
X#
X#LSB1;/dev/ttyhd,/dev/ttyi8;9600;-Busy;-Bcongestion;-Bremote dte;-BFound;-Inacti
X#ve;-Q\d\d\d\d\d\d\d\p\K\p;-Q\pclr\r\d;-Q\p\K\p;-Q\pbye\p;-DConnection cleared;-
X#Dpad>;-DSystem?;System?-\K\pbye\r\p-System?;\ppacout\r\d;connect;\p\r\d;pad>-\p
X#\K\pclr\r\d-pad>;\pconnect\s00000099999999\r\d;pened-\p\K\pclr\r\pconnect\s0000
X#0099999999\r\d-pened;\d;;;
X#
X#
X#
X#
X# This is an rtab entry to go out from the cpu, through the Tellabs, to a
X# printer which hangs from the Tellabs switch. The printer's name is netind2.
X# In this case, we may only access it via one port. The speed is 9600. The one
X# "busy" message and one "inactive" messages are messages we may expect from
X# Tellabs. The "quit" sequence for this switch is <BREAK>bye. The first EXPECT 
X# is a compound construction in which we look for "System?". If we don't get it,
X# we send <BREAK>bye and carriage return, then expect "System?" again. Next,
X# we send the link/channel combo which is the printer's address. We expect 
X# a "connect" message (switch's info messages are turned on). If we don't get
X# it, we send the link/channel combo again, then expect the "connect" message.
X#
X# The final non-NULL send is SOMETHING SPECIAL because the printer in this
X# example is a Centronics C-351, a printer IRS bought by the metric ton a few
X# years ago. The C-351, when attached to the network (both the Tellabs and the
X# X.25 async pad, in our experience) apparently detects a parity error at the
X# instant the virtual connection (VC) is established. The C-351's response to
X# this condition is to print a "@". You can't stop it by setting the dip
X# switches to ignore parity. So, if you don't want this junk character in 
X# your hard copy, simply formfeed past the page which the C-351 has just spat
X# upon.
X#
X# PLEASE NOTE the liberal sprinkling of 1 second pauses and 3 second delays.
X# Believe it or not, even the lowly Zilog is capable of executing the ISPIN
X# code faster than the network is able to resond. The pauses and delays keep
X# us from getting ahead of the network so we don't get lost.
X#
X# PLEASE NOTE: I have chopped this entry into separate lines so you may print
X# it. A REAL rtab entry must be all one line.
X#
X#netind2;/dev/tty8;9600;-Busy;-Iinactive;-Q\p\K\p;-Q\pbye\p;-DSystem?;System?-\K
X#\pbye\r\p-System?;\p135/2.2\r\d;connect-\p135/2.2\r\d-connect;\d\f;;;
X#
X#
X#
X#
X# This is an example of an rtab entry in the case where both the cpu and the
X# printer are directly connected to X.25 async pad.  It is different than the
X# rtab entry that was sent out with earlier versions of this application.
X# The X.25 pad disconnect sequence is changed from normal <BREAK>clr command to 
X# <CTRL>Z via the "set recall = 26" command. This change was made because
X# the <BREAK> causes Qume printers to print a garbage character.
X
X#
X# PLEASE NOTE: I have chopped this entry into separate lines so you may print
X# it. A REAL rtab entry must be all one line and doesn't have # symbols in it.
X#
X#netind3;/dev/ttyhd,/dev/ttyi8;9600;-L;-Bcongest;-Bmote dte;-Q\w\032\dcl
X#r\r\d;-DConnection cleared;-Dpad>;pad>-\p\K\pclr\r-pad>;\r\p;pad>-\p\K\pclr\r\
X#d-pad>;set recall=26\r\p;pad>-\r\d-pad>;\pconnect\s00000099999999\r\d;pened-\p\
X#K\pclr\r\dset recall=26\r\p\pconnect\s00000099999999\r\d-pened;\d;;;
X#
X#
X#
X#
X# This is an example of an rtab entry for the case where both a 
X# cpu and the printer are directly connected to the X.25 pad. It is different
X# than the rtab entry that was sent out with earlier versions of this 
X# application. It is the same as the preceding example except that the 
X# disconnect argument "-De" is also included. Since the letter "e" is the
X# most frequently used letter in the alphabet, the "-De" will assure that
X# a disconnected print job (chars we sent out are being echoed back to us
X# because the network has reverted to command mode) will be detected sooner.
X#
X#netind3;/dev/ttyhd,/dev/ttyi8;9600;-L;-Bcongest;-Bmote dte;-Q\w\032\dclr\r\d
X#;-DConnection cleared;-Dpad>;-De;pad>-\p\K\pclr\r\d-pad>;\r\p;pad>-\p\K\pcl
X#r\r\d-pad>;set recall=26\r\p;pad>-\r\d-pad>;\pconnect\s00000099999999\r\d;pened
X#-\p\K\pclr\r\dset recall=26\r\p\pconnect\s00000099999999\r\d-pened;\d;;;
X#
X#
X#
X# This is an example rtab entry for a printer which is hard wired to the cpu
X# at tty15. Although sending print jobs to hard wired printers through ISPIN
X# costs a little more in terms of overhead, there are a couple of valid
X# reasons for doing so. Under the NQ/DQUEUER native spooler, you might choose
X# the ISPIN backend to support hardwired printers just to avoid the costly
X# and clunky status reporting which is performed by the native "/usr/lib/text"
X# backend. Under the LP spooler, you might choose the ISPIN interface to
X# support hardwired printers because ISPIN offers an opportunuty to issue both
X# pre- and post-printing commands to the printer.
X#
X#netind4;/dev/tty15;9600;;;
X#
X#
X# NOTE:
X#       SEE ISPIN/install/lib_rtab/README for further info and more examples
X#
X#
END_OF_FILE
if test 18364 -ne `wc -c <'ISPIN/install/rtab'`; then
    echo shar: \"'ISPIN/install/rtab'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/rtab'
fi
if test -f 'ISPIN/doc/OLD-DOCS/README.beta.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/doc/OLD-DOCS/README.beta.2'\"
else
echo shar: Extracting \"'ISPIN/doc/OLD-DOCS/README.beta.2'\" \(4265 characters\)
sed "s/^X//" >'ISPIN/doc/OLD-DOCS/README.beta.2' <<'END_OF_FILE'
X
X
X
X        date:     February 14, 1989
X
X        to:       ISPIN Beta Test Site Volunteer
X
X        from:     Chief, Operations Branch, Information Systems Division, 35:IS
X
X        subject:  Indianapolis Standard Printer Interface (for Network printers)
X                  BETA Test release 2
X
X
X        I'm calling this the second version of the beta test release of
X        ISPIN. 
X
X        The biggest difference between this release and the first is that 
X        this second release compiles and executes on several more hardware
X        platforms. This is not due to extensive modification of the initial
X        issue. Only subtle adjustments to the IQUEUER.c and ISPIN.c were
X        necessary. ISPIN has been successfully installed and tested on:
X
X                                     Zilog Model 31
X                                     Zilog Model 32
X                                     Zilog Model 130
X                                     AT&T  3B1
X                                     Sequent Balance B8
X                                     Pyramid (whatever they have at
X                                              Atlanta Service Center)
X
X        This second release contains a few functional improvements as well.
X        Almost all of the error messages which an ISPIN may write to its
X        logfile now identify the printer. The error message written when
X        a network negotiation fails now reflects what was expected and what
X        was received. The functions which read the rtab and conduct the
X        network negotiation now permit the specification of a formfeed in
X        the rtab entry. Signal handling has been beefed up in the area of
X        intelligently handling SIGHUP.
X
X
X        The tape upon which I have transmitted the application was created
X        in cpio format. cd to a directory in which you want this release to
X        be written, then      cpio -iudmvB < your_nine_track_drive
X
X        The result of this cpio will be the creation of a directory named
X        ISPIN.beta.2. ISPIN.beta.2 will contain two subdirectories, namely
X        ISPI and ISPIN.
X
X        ISPIN contains the source code, install documents, and install
X        scripts for the new ISPIN application. Of course, the ISPIN
X        application serves as a BACKEND for either of two native
X        queuer/spoolers, lp or dqueuer. For this second release, I have
X        organized the directory ISPIN and its contents into subdirectories
X        using standard names "doc" (for documentation files), "h" (for header
X        files), "install" (where install scripts exist, and from which they
X        must be executed), "obj" (where the executables will be placed as
X        they are compiled), and "src" (where the source code resides).
X
X        The ISPI directory contains the freshest version of our ISPI
X        application. ISPI is an application which serves as a FRONTEND
X        for the two queuer/spoolers. The ISPI application is fully self-
X        contained, with its own source code, documentation, etc. Use it
X        if you like, or don't use it. I sent ISPI along because we have
X        found it to be an extremely useful tool to support the native
X        queuer/spoolers.
X
X        ISPIN and ISPI are TWO SEPARATE AND DISTINCT APPLICATIONS.
X        Neither depends upon the other for functionality. You may use ISPIN
X        without ISPI. You may use ISPI without ISPIN.
X
X        The documentation of the formal type is sparse, but the code is
X        overflowing with comments. Read everything in the "doc" directory
X        to get a general idea of what is going on in ISPIN and
X        its related entities.
X
X        If you are installing this application under ZEUS 3.21 and its
X        nq/xq/dqueuer queuer family, read NQinstall.doc.
X
X        If you are installing this application under System V UNIX and
X        the lp spooler, read LPinstall.doc.
X
X        If you have previously installed the initial release of ISPIN, the
X        install directory contains update scripts so you don't have to go
X        through a complete install.
X
X
X        Feedback is what I need. Please communicate whatever observations
X        you may have soon and often.
X
X
X  
X                                                         Larry Bartz
X
X
END_OF_FILE
if test 4265 -ne `wc -c <'ISPIN/doc/OLD-DOCS/README.beta.2'`; then
    echo shar: \"'ISPIN/doc/OLD-DOCS/README.beta.2'\" unpacked with wrong size!
fi
# end of 'ISPIN/doc/OLD-DOCS/README.beta.2'
fi
if test -f 'ISPIN/misc/ISPIT.dr/do_ispit.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/misc/ISPIT.dr/do_ispit.sh'\"
else
echo shar: Extracting \"'ISPIN/misc/ISPIT.dr/do_ispit.sh'\" \(1687 characters\)
sed "s/^X//" >'ISPIN/misc/ISPIT.dr/do_ispit.sh' <<'END_OF_FILE'
X#!/bin/sh
X# do_ispit.sh         08/07/91     LSB
X# When you install this in an accessible path, call it "ispit". This will
X# assure compatibility with possible future executables.
X# requires three args:
X# $1 is file to be xferred: could be a directory, could be more than one
X#                           file if all enclosed in double quote
X#
X# $2 is destination file name (full path on remote system, or relative to
X# ispit's home directory on the remote system)
X#
X# $3 is the lp queue member to use (for destination system)
X#
X# so:
X#     ispit source_file destination_file destination_system_queue_member
X#
X# examples:
X#
X# send testfile to /tmp/testfile on queue indy6:
X#     ispit testfile /tmp/testfile indy6
X#
X# send directory UUGETTY and all contents to /tmp/UUG.cp.Z.a on queue indy6:
X#     ispit UUGETTY /tmp/UUG.cp.Z.a indy6
X#
X# send all files whose names contain "ind" to /tmp/ind.cp.Z.a on queue indy6:
X#     ispit "`ls *ind*`" /tmp/ind.cp.Z.a indy6
X#
X# nowfile (not an argument) is the name of the named pipe in /tmp we'll use
X#
X#
Xnowfile=`/bin/date +%m%d%y`.`/bin/date +%H%M%S`
Xecho "ISPIT REQUEST" >> /tmp/ispit.log
Xdate >> /tmp/ispit.log
Xecho "        user: "`id`  >> /tmp/ispit.log
Xecho "      source: "$1  >> /tmp/ispit.log
Xecho " destination: "$2  >> /tmp/ispit.log
Xecho "       queue: "$3  >> /tmp/ispit.log
Xecho "        pipe: /tmp/"$nowfile  >> /tmp/ispit.log
X/bin/rm -f /tmp/$nowfile
X/etc/mknod /tmp/$nowfile p
X/bin/chmod 666 /tmp/$nowfile
Xfind $1 ! -type p -print|/bin/cpio -oc|/usr/local/bin/compress|/usr/local/bin/btoa > /tmp/$nowfile &
X/usr/bin/lp -d$3 -o$2@/tmp/$nowfile /etc/passwd
X# Yes, I do mean /etc/passwd! It's here as a necessary argument to fool lp.
END_OF_FILE
if test 1687 -ne `wc -c <'ISPIN/misc/ISPIT.dr/do_ispit.sh'`; then
    echo shar: \"'ISPIN/misc/ISPIT.dr/do_ispit.sh'\" unpacked with wrong size!
fi
# end of 'ISPIN/misc/ISPIT.dr/do_ispit.sh'
fi
if test -f 'ISPIN/misc/ISPIT.dr/interface' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/misc/ISPIT.dr/interface'\"
else
echo shar: Extracting \"'ISPIN/misc/ISPIT.dr/interface'\" \(545 characters\)
sed "s/^X//" >'ISPIN/misc/ISPIT.dr/interface' <<'END_OF_FILE'
X#!/bin/sh
X# 08/07/91 LSB
X# This interface script usable for ISPIT file transfer protocol
Xecho "ISPIT FILE TRANSFER" >> /tmp/ispit.log
Xdate >> /tmp/ispit.log
Xecho "      lp job id : "$1 >> /tmp/ispit.log
Xecho "requesting user : "$2 >> /tmp/ispit.log
Xecho "    destination : "`echo $5|/usr/bin/cut -d@ -f1` >> /tmp/ispit.log
Xecho "           pipe : "`echo $5|/usr/bin/cut -d@ -f2` >> /tmp/ispit.log
Xexec /usr/spool/lp/ISPIN/ispin `/bin/basename $0|/usr/bin/tr -d "[\012*]"` $1 $2 "" 1 `echo $5|/usr/bin/cut -d@ -f1` `echo $5|/usr/bin/cut -d@ -f2`
END_OF_FILE
if test 545 -ne `wc -c <'ISPIN/misc/ISPIT.dr/interface'`; then
    echo shar: \"'ISPIN/misc/ISPIT.dr/interface'\" unpacked with wrong size!
fi
# end of 'ISPIN/misc/ISPIT.dr/interface'
fi
echo shar: End of archive 8 \(of 15\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

