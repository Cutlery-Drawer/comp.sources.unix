Newsgroups: comp.sources.unix
From: sir-alan!ispin!lbartz@iuvax.cs.indiana.edu (Larry Bartz)
Subject: v25i116: Indianapolis Standard Printer Interface for Networked printers, Part05/15
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: sir-alan!ispin!lbartz@iuvax.cs.indiana.edu (Larry Bartz)
Posting-Number: Volume 25, Issue 116
Archive-Name: ispin/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 15)."
# Contents:  ISPIN/src/IQUEUER.c.aa ISPIN/src/ISPIN.c.af
#   ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_NOSHT
#   ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_SHT
#   ISPIN/install/lib_rtab/CPU_PTR/QUME_SHT
#   ISPIN/install/lib_rtab/CPU_PTR/QUME_NOSHT
#   ISPIN/install/lib_rtab/README ISPIN/doc/OLD-DOCS/bio
# Wrapped by socrates@indy6 on Tue Jan 28 15:26:39 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ISPIN/src/IQUEUER.c.aa' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/src/IQUEUER.c.aa'\"
else
echo shar: Extracting \"'ISPIN/src/IQUEUER.c.aa'\" \(34486 characters\)
sed "s/^X//" >'ISPIN/src/IQUEUER.c.aa' <<'END_OF_FILE'
X/****************************************************************************/
X/*                                                                          */
X/* IQUEUER - ISPIN's queuer                                                 */
X/*         - the secondary queueing daemon for:                             */
X/*                                                                          */
X/* ISPIN                                                                    */
X/*                                                                          */
X/* Indianapolis Standard Printer Interface (for Network printers)           */
X/****************************************************************************/
X/*                                                                          */
X/*  Copyright (C) 1991                                                      */
X/*  Larry Bartz                                                             */
X/*  Internal Revenue Service                                                */
X/*  Indianapolis District Office                                            */
X/*                                                                          */
X/*  This program is free software; you can redistribute it and/or modify    */
X/*  it under the terms of the GNU General Public License as published by    */
X/*  the Free Software Foundation, version 1.                                */
X/*                                                                          */
X/*  This program is distributed in the hope that it will be useful,         */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of          */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           */
X/*  GNU General Public License for more details.                            */
X/*                                                                          */
X/*  You should have received a copy of the GNU General Public License       */
X/*  along with this program; if not, write to the Free Software             */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* COMMENTS                                                                 */
X/*                                                                          */
X/* Read comments in common.h for the BIG PICTURE.                           */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DEFINES                                                                  */
X/*                                                                          */
X/* Refer to common.h and iqueuer.h                                          */
X/*                                                                          */
X/* #define DEBUG                                                            */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* INCLUDES                                                                 */
X/*                                                                          */
X/* Refer to common.h and iqueuer.h                                          */
X/*                                                                          */
X#include "../h/iqueuer.h"
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DATA TYPES, VARIABLES, ETC                                               */
X/*                                                                          */
X/* Refer to common.h and iqueuer.h                                          */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* MODIFICATIONS                                                            */
X/*                                                                          */
X/* 10/13/89 Kevin Fannin - Modified method by which waiting jobs are queued.*/
X/*                         Formerly, waiting print jobs were assigned to    */
X/*                         a device (port) and remained in queue for that   */
X/*                         device, even if another device which the job     */
X/*                         could use became available. Now, all waiting     */
X/*                         jobs are put in one queue and are not assigned   */
X/*                         a device until they are actually ready to be     */
X/*                         printed. To indicate that waiting jobs do not    */
X/*                         have an assigned device, the device inode is     */
X/*                         set to -1. This change also affected iqueuer.h   */
X/*                         and IQ.c.                                        */
X/****************************************************************************/
X
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X
X  int timeout();
X
X
X            /* format startup message */
X            time(&tloc);
X            nowtime = (struct tm *)localtime(&tloc);
X            time_str = asctime(nowtime);
X            strcpy(errmsg,"IQUEUER: startup time:\n");
X            strcat(errmsg,"                            ");
X            strcat(errmsg,time_str);
X            strcat(errmsg,"\n");
X         if((logfile = fopen(LOGFILE,"w")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X	    chmod(LOGFILE,00666);
X         }
X
X  /* The first thing to do is make sure that another invocation of iqueuer */
X  /* is not already running. T'would be disasterous!                       */
X  /* We'll use our status FIFO for this purpose. A running IQUEUER will be */
X  /* holding this named pipe open for writing. If we open this pipe for    */
X  /* reading without O_NDELAY set, and the open succeeds, that means that  */
X  /* a viable writer process exists. That writer process could ONLY be     */
X  /* another current IQUEUER. If the open fails, no other IQUEUER exists,  */
X  /* so we may proceed.                                                    */
X
X  iq_pid = 31999;        /* An impossible pid, just to get us started. */
X                         /* see write_status().                        */
X
X  /* allocate storage for our file status buffer */
X  stat_buf = (struct stat *) calloc(1,sizeof(struct stat));
X
X  /* what is the name of the status FIFO ? */
X  strcpy(statFIFO,FIFOdir);
X  strcat(statFIFO,"STATUS");
X  /* does it exist? */
X  if(stat(statFIFO,stat_buf))
X  {
X    /* if not,      */
X    /* create it if we can */
X    if(mknod(statFIFO,0010666,1) != SUCCESS)
X    {
X      /* It didn't exist and we couldn't create it either. */
X      /* All hope is lost.                                 */
X      /* need to send out an error msg */
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          sprintf(errmsg,"IQUEUER: mknod statFIFO: %s. time:\n",sys_errlist[errno]);
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X
X          /* We can still write to stderr at this point. */
X          fprintf(stderr,errmsg);
X
X         /* call the error routine, never come back */
X         my_error(NONOTIFY);
X
X    }
X  }
X
X
X  /* An open for reading will fail unless a process (IQUEUER) has the file    */
X  /* open for writing. Failure is what we want.                               */
X
X  signal(SIGALRM, timeout);     /* set up timeout for file open */
X  time_out = 0;         /* assume no timeout */
X  alarm(3);             /* wait a few seconds for file open      */
X
X  if((statropn = open(statFIFO,O_RDONLY)) >= 0)
X  {
X    if(time_out != 1)
X    {
X    /* if the open does not fail */
X    /* need to send out an error msg */
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          sprintf(errmsg,"IQUEUER: IQUEUER already exists. time:\n");
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X
X          /* We can still write to stderr at this point. */
X          fprintf(stderr,errmsg);
X
X         /* call the error routine, never come back */
X         my_error(NONOTIFY);
X    }
X
X  }
X  alarm(0);      /* turn off the alarm clock */
X  signal(SIGALRM, SIG_IGN);     /* ignore alarm again */
X
X  free(stat_buf);
X
X  /* Now that we know we're alone, proceed. */
X  /* Close all files we'll not be using.   */
X  fclose(stdin);
X  fclose(stdout);
X  fclose(stderr);
X
X  /* Fork child to run as the daemon. Parent dies */
X  if(fork() != 0)
X  {
X    exit(0);
X  }
X  /* child daemon starts here */
X
X  /* divorce ourself from the current process group and its control terminal */
X  setpgrp();
X
X  /* allocate storage for our file status buffer */
X  stat_buf = (struct stat *) calloc(1,sizeof(struct stat));
X
X  /* open up our communication FIFOs */
X
X  /* status FIFO: we'll be the writer */
X
X  /* this open just tricks the FIFO into staying open for our write           */
X  if((statropn = open(statFIFO,O_RDWR | O_NDELAY)) == -1)
X  {
X    /* need to send out an error msg */
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          sprintf(errmsg,"IQUEUER: open statFIFO: %s. time:\n",sys_errlist[errno]);
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X
X         /* call the error routine, never come back */
X         my_error(NONOTIFY);
X
X  }
X
X  /* this open of the FIFO is the one we'll use for our write           */
X  if((statfifo = open(statFIFO,O_WRONLY)) == -1)
X  {
X    /* need to send out an error msg */
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          sprintf(errmsg,"IQUEUER: open statFIFO: %s. time:\n",sys_errlist[errno]);
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X
X         /* call the error routine, never come back */
X         my_error(NONOTIFY);
X
X  }
X
X
X  /* IQUEUER's FIFO: we'll be the reader */
X
X  /* what is the name of the FIFO I listen through? */
X  strcpy(inFIFO,FIFOdir);
X  strcat(inFIFO,"IQUEUER");
X  /* does it exist? */
X  if(stat(inFIFO,stat_buf))
X  {
X    /* if not,      */
X    /* create it if we can */
X    if(mknod(inFIFO,0010666,1) != SUCCESS)
X    {
X      /* It didn't exist and we couldn't create it either. */
X      /* All hope is lost.                                 */
X      /* need to send out an error msg */
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          sprintf(errmsg,"IQUEUER: mknod inFIFO: %s. time:\n",sys_errlist[errno]);
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X
X         /* call the error routine, never come back */
X         my_error(SYSERR);
X
X    }
X  }
X
X  /* take care of the signals */
X        signal(SIGINT, SIG_IGN);    /* ignore "interrupt" signal <DEL> */
X        signal(SIGHUP, SIG_IGN);    /* ignore "hang up" signal */
X        signal(SIGQUIT, SIG_IGN);   /* ignore "quit" signal */
X        signal(SIGALRM, SIG_IGN);   /* ignore "alarm" signal */
X        signal(SIGTERM, my_error);   /* trap "term" signal */
X        /* Maybe on termination, we should write all waits to the FIFO */
X        /* so they'll be waiting there for the next IQUEUER to handle. */
X#ifdef NQ
X        signal(SIGRES, SIG_IGN);     /* ignore "restart" signal */
X        signal(SIGBACK, SIG_IGN);   /* ignore "back-up" signal */
X        signal(SIGSTOP, SIG_IGN);   /* ignore "stop" signal */
X#endif
X
X  /* set up our linked lists */
X      /* First, set up the heads of our lists.              */
X
X      head_wait = (struct wait_queue *) calloc(1,sizeof(struct wait_queue));
X      head_wait->prev = NULL;
X      head_wait->next = NULL;
X      curr_wait = list_wait = hold_wait = head_wait;
X
X      head_dsptch = (struct go_list *) calloc(1,sizeof(struct go_list));
X      head_dsptch->prev = NULL;
X      head_dsptch->next = NULL;
X      curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X
X  /* finally, do a "blocking" open for reading for   */
X  /* an opportunity to do "blocking" reads.          */
X  if((infifo = open(inFIFO,O_RDONLY)) == -1)
X  {
X    /* need to send out an error msg */
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          sprintf(errmsg,"IQUEUER: open inFIFO: %s. time:\n",sys_errlist[errno]);
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X
X         /* call the error routine, never come back */
X         my_error(SYSERR);
X
X  }
X
X  /* All set? You bet! */
X  while(1)
X  {
X      /* Now wait for a message, in the form of a work order. */
X      /* A blocking read will allow the kernel to put us to sleep until... */
X
X      count1 = count2 = 0;
X
X      chars_got = read(infifo,msg_buf,to_iqrsiz);
X      if(chars_got < 1)
X      {
X        close(infifo);
X        if((infifo = open(inFIFO,O_RDONLY)) == -1)
X        {
X          /* need to send out an error msg */
X                /* format an error message */
X                time(&tloc);
X                nowtime = (struct tm *)localtime(&tloc);
X                time_str = asctime(nowtime);
X                sprintf(errmsg,"IQUEUER: open inFIFO: %s. time:\n",sys_errlist[errno]);
X                strcat(errmsg,"                            ");
X                strcat(errmsg,time_str);
X                strcat(errmsg,"\n");
X
X               /* call the error routine, never come back */
X               my_error(SYSERR);
X
X        }
X        chars_got = read(infifo,msg_buf,to_iqrsiz);
X      }
X
X      /* fill the structure of unions from the msg_buf */
X      while(count1 < intsize)
X      {
X        incoming.typ.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.my_pid.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.my_fifo.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.dev1_inod.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.dev2_inod.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.dev3_inod.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.dev4_inod.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.dev5_inod.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.dev6_inod.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.dev7_inod.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.dev8_inod.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.dev9_inod.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.dev10_inod.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.dev11_inod.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.uid.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X
X      while(count1 < intsize)
X      {
X        incoming.loop.chr[count1++] = msg_buf[count2++];
X      }
X      count1 = 0;
X      count2 = 0;
X
X      /* what kind of request is this? */
X
X
X#ifdef DEBUG
X            /* format DEBUG message */
X            time(&tloc);
X            nowtime = (struct tm *)localtime(&tloc);
X            time_str = asctime(nowtime);
X            sprintf(errmsg,"IQUEUER: received message type = %d. time:\n",incoming.typ.intgr);
X            strcat(errmsg,"                            ");
X            strcat(errmsg,time_str);
X            strcat(errmsg,"\n");
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X#endif
X
X      if(kill(incoming.my_pid.intgr, 0) != -1)
X      {
X       /* if the message sender didn't die before we could help him */
X      switch(incoming.typ.intgr)
X      {
X        case HERE:
X          /* Always look for, and expunge any ISPINs which have croaked. */
X          /* Find_dead() will call clean_out() with pid of dead ISPINs.  */
X          find_dead();
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X           time(&tloc);                   /* what time did we get request ? */
X
X           /* let those who have been waiting go first */
X           check_queue();    /* re-org the lists, issue go orders if appropos */
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X           go_or_queue();                 /* go now or wait in queue? */
X        break;
X
X        case BUSY:
X          /* Always look for, and expunge any ISPINs which have croaked. */
X          /* Find_dead() will call clean_out() with pid of dead ISPINs.  */
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X          find_dead();
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X           /* save the original time_in */
X           ret_val = firstime(incoming.my_pid.intgr);
X
X           /* remove our previous list member for this job */
X           ret_val = clean_out(incoming.my_pid.intgr);
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X           /* let those who have been waiting go first */
X           check_queue();    /* re-org the lists, issue go orders if appropos */
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X           /* set the global time variable to the original time_in */
X           tloc = oldtime;
X           go_or_queue();                 /* go now or wait in queue? */
X        break;
X
X        case DONE:
X        case TROUBLE:
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X           ret_val = clean_out(incoming.my_pid.intgr);  /* remove job from whichever list */
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X          /* Always look for, and expunge any ISPINs which have croaked. */
X          /* Find_dead() will call clean_out() with pid of dead ISPINs.  */
X          find_dead();
X
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X           check_queue();    /* re-org the lists, issue go orders if appropos */
X        break;
X
X        case STARTUP:
X        case CONNECTING:
X        case PRINTING:
X        case LOOPING:
X        case WAITING:
X        case DISCONNECTING:
X        case QUITTING:
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X           ret_val = newstate(incoming.my_pid.intgr,incoming.typ.intgr);
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X        break;
X
X        case STATUS:
X          /* Always look for, and expunge any ISPINs which have croaked. */
X          /* Find_dead() will call clean_out() with pid of dead ISPINs.  */
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X          find_dead();
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X           check_queue();    /* re-org the lists, issue go orders if appropos */
X
X           /* reset the list pointers to aim at the head */
X           curr_wait = list_wait = hold_wait = head_wait;
X           curr_dsptch = list_dsptch = hold_dsptch = head_dsptch;
X
X           ret_val = write_status();   /* read both lists, write messages */
X        break;
X      }
X      }
X  }
X
X}
X
X/******************************************************************************/
X
X
Xfind_dead()
X{
X  /* check both of our lists, if any of the jobs have died, delete from list */
X
X  /* check the go_list first */
X
X  /* walk the list */
X
X  while(curr_dsptch->next != NULL)
X  {
X    curr_dsptch = curr_dsptch->next;
X    if((kill(curr_dsptch->job_id.my_pid.intgr, 0)) == -1)
X    {
X      ret_val = clean_out(curr_dsptch->job_id.my_pid.intgr);
X    }
X  }
X
X  /* check the wait_queue next */
X
X  /* walk the list */
X
X  while(curr_wait->next != NULL)
X  {
X    curr_wait = curr_wait->next;
X
X    if((kill(curr_wait->job_id.my_pid.intgr, 0)) == -1)
X      {
X        ret_val = clean_out(curr_wait->job_id.my_pid.intgr);
X      }
X  }
X}
X
X
Xclean_out(pid)
Xint pid;
X{
X  /* we are given the pid of a job to be deleted from whichever list */
X
X  /* some strictly local pointers which mimic the global ones */
X
X  struct wait_queue *c_head_wait;
X  struct wait_queue *c_curr_wait;
X  struct wait_queue *c_list_wait;
X  struct wait_queue *c_hold_wait;
X
X  struct go_list *c_head_dsptch;
X  struct go_list *c_curr_dsptch;
X  struct go_list *c_list_dsptch;
X  struct go_list *c_hold_dsptch;
X
X  /* set the local pointers to aim at the true heads of the lists */
X  c_head_wait = c_curr_wait = c_list_wait = c_hold_wait = head_wait;
X  c_head_dsptch = c_curr_dsptch = c_list_dsptch = c_hold_dsptch = head_dsptch;
X
X  /* check the go_list first */
X
X  /* walk the list */
X
X  while(c_curr_dsptch->next != NULL)
X  {
X    c_curr_dsptch = c_curr_dsptch->next;
X
X    if(c_curr_dsptch->job_id.my_pid.intgr == pid)
X    {
X
X      /* find the tty name */
X      strcpy(lil_buf,myncheck(c_curr_dsptch->devinod,"/dev"));
X    
X      /* create the lock file name */
X      strcpy(tty_lock,LCK_DIR);
X      strcat(tty_lock,"LCK..");
X      strcat(tty_lock,lil_buf);
X
X      /* get rid of the lockfile */
X      /* We know this is our own lockfile. This job could not have */
X      /* become a member of the go_list unless we were previously  */
X      /* able to successfully create our own lockfile.             */
X      ret_val = unlink(tty_lock);
X      if(ret_val != 0)
X      {
X        /* need to send out an error msg */
X        /* format an error message */
X        time(&tloc);
X        nowtime = (struct tm *)localtime(&tloc);
X        time_str = asctime(nowtime);
X        sprintf(errmsg,"IQUEUER: unlink %s: %s. time:\n",tty_lock,sys_errlist[errno]);
X        strcat(errmsg,"                            ");
X        strcat(errmsg,time_str);
X        strcat(errmsg,"\n");
X
X        /* call the error routine, don't exit */
X        ret_val = my_error(NO_EXIT);
X      }
X
X      /* take the job out of the list */
X      /* cut our guy out from between his neighbors */
X
X      if(c_curr_dsptch->next != NULL)
X      {
X        /* if we're not at the end of the list */
X        c_curr_dsptch->prev->next = c_curr_dsptch->next;
X        c_curr_dsptch->next->prev = c_curr_dsptch->prev;
X      }
X      else
X      {
X        /* if we are at the end of the list */
X        c_curr_dsptch->prev->next = NULL;
X      }
X
X      /* hold onto the memory location we're about to free */
X
X      c_hold_dsptch = c_curr_dsptch;
X
X      /* Shortly, the global curr_dsptch will be pointing at thin air. */
X      /* Aim it at a valid memory location; the local one too. */
X
X      curr_dsptch = c_curr_dsptch->prev;
X      c_curr_dsptch = c_curr_dsptch->prev;
X
X      /* if you love someone, set them free */
X
X      free(c_hold_dsptch);
X      return(0);
X    }
X  }
X
X  /* check the wait_queue next */
X
X  /* walk the list */
X
X  while(c_curr_wait->next != NULL)
X  { 
X    c_curr_wait = c_curr_wait->next;
X
X    /* walk the list */
X
X    if(c_curr_wait->job_id.my_pid.intgr == pid)
X      {
X        /* take it out of the list */
X        /* cut our guy out from between his neighbors */
X
X        if(c_curr_wait->next != NULL)
X        {
X          /* if we're not at the end of the list */
X          c_curr_wait->prev->next = c_curr_wait->next;
X          c_curr_wait->next->prev = c_curr_wait->prev;
X        }
X        else
X        {
X          /* if we are at the end of the list */
X          c_curr_wait->prev->next = NULL;
X        }
X
X        /* hold onto the memory location we're about to free */
X
X        c_hold_wait = c_curr_wait;
X
X        /* Shortly, the global curr_wait will be pointing at thin air. */
X        /* Aim it at a valid memory location; the local one too. */
X
X        curr_wait = c_curr_wait->prev;
X        c_curr_wait = c_curr_wait->prev;
X
X        /* if you love someone, set them free */
X
X        free(c_hold_wait);
X        return(0);
X      }
X  }
X}
X
X
Xgo_or_queue()
X{
X  int in_use = 0;
X  int louper = 0;
X
X  /* some strictly local pointers which mimic the global ones */
X
X  struct go_list *c_head_dsptch;
X  struct go_list *c_curr_dsptch;
X  struct go_list *c_list_dsptch;
X  struct go_list *c_hold_dsptch;
X
X
X  /* A work order has come in. May it be dispatched now, or must it wait? */
X
X  /* If any of the devices requested are not now members of the go_list,    */
X  /* the job may be dispatched now. If all devices are in use, queue the    */
X  /* job in the wait list. Remember, not all requests will ask for multiple */
X  /* devices.                                                               */
X
X  /* set the local pointers to aim at the true heads of the lists */
X  c_head_dsptch = c_curr_dsptch = c_list_dsptch = c_hold_dsptch = head_dsptch;
X
X  /* initialize the array of structures from incoming info */
X
X  dev_ray[0].inode = incoming.dev1_inod.intgr;
X  dev_ray[1].inode = incoming.dev2_inod.intgr;
X  dev_ray[2].inode = incoming.dev3_inod.intgr;
X  dev_ray[3].inode = incoming.dev4_inod.intgr;
X  dev_ray[4].inode = incoming.dev5_inod.intgr;
X  dev_ray[5].inode = incoming.dev6_inod.intgr;
X  dev_ray[6].inode = incoming.dev7_inod.intgr;
X  dev_ray[7].inode = incoming.dev8_inod.intgr;
X  dev_ray[8].inode = incoming.dev9_inod.intgr;
X  dev_ray[9].inode = incoming.dev10_inod.intgr;
X  dev_ray[10].inode = incoming.dev11_inod.intgr;
X
X  for(louper = 0; louper <= 10; ++louper)
X  {
X    dev_ray[louper].so_many = 0;
X  }
X
X  /* check the go_list */
X
X  /* walk the list */
X
X  while(c_curr_dsptch->next != NULL)
X  {
X    c_curr_dsptch = c_curr_dsptch->next;
X
X
X    for(louper = 0; louper <= 10; ++louper)
X    {
X      if(c_curr_dsptch->devinod == dev_ray[louper].inode)
X      {
X        dev_ray[louper].so_many = 1;
X      }
X    }
X
X   }
X
X/*************************************************************************/
X  for(louper = 0; louper <= 10; ++louper)
X  {
X    if((dev_ray[louper].inode > 0)&&(dev_ray[louper].so_many == 0))
X    {
X      strcpy(lil_buf,myncheck(dev_ray[louper].inode,"/dev"));
X      /* we'll try to create a lockfile for the tty we want */
X      in_use = lockit(lil_buf);
X      if(in_use == 0)
X      {
X        go_for_it(&incoming,dev_ray[louper].inode,tloc);
X        return;
X      }
X    }
X  }
X  queue_it();
X  return;
X/*************************************************************************/
X}
X
X
Xgo_for_it(go_job,go_inod,in_time)
Xstruct to_iqueuer *go_job;
Xint go_inod;
Xlong in_time;
X{
X  /* We have decided this job may proceed, using a certain device.   */
X  /* "in_time" is the time the job request was submitted to IQUEUER. */
X  /* "in_time" is determined on the fly if go_for_it() is called by  */
X  /* go_or_queue(). "in_time" comes from wait_queue->time_in if      */
X  /* go_for_it() is called by check_queue().                         */
X
X  /* char *myncheck(); */
X
X  /* some strictly local pointers which mimic the global ones */
X
X  struct go_list *c_head_dsptch;
X  struct go_list *c_curr_dsptch;
X  struct go_list *c_list_dsptch;
X  struct go_list *c_hold_dsptch;
X
X  /* set the local pointers to aim at the true heads of the lists */
X  c_head_dsptch = c_curr_dsptch = c_list_dsptch = c_hold_dsptch = head_dsptch;
X
X
X  /* add it to the go_list */
X  /* If we're called by check_que, it'll be his responsibility to */
X  /* tidy-up the wait list after we return.                       */
X
X  /* walk the list */
X
X  while(c_curr_dsptch->next != NULL)
X  {
X    c_curr_dsptch = c_curr_dsptch->next;
X  }
X
X  /* allocate memory for the new member of the list */
X  c_curr_dsptch->next = (struct go_list *) calloc(1,sizeof(struct go_list));
X
X  /* point the new one back at the current one */
X  c_curr_dsptch->next->prev = c_curr_dsptch;
X
X  /* change our notion of "current" to the new one */
X  c_curr_dsptch = c_curr_dsptch->next;
X
X  /* terminate the list */
X  c_curr_dsptch->next = NULL;
X
X  /* fill the new structure */
X
X  c_curr_dsptch->devinod                 =  go_inod;
X  c_curr_dsptch->job_id.typ.intgr        =  STARTUP;
X  c_curr_dsptch->job_id.my_pid.intgr     =  go_job->my_pid.intgr;
X  c_curr_dsptch->job_id.my_fifo.intgr    =  go_job->my_fifo.intgr;
X  c_curr_dsptch->job_id.dev1_inod.intgr  =  go_job->dev1_inod.intgr;
X  c_curr_dsptch->job_id.dev2_inod.intgr  =  go_job->dev2_inod.intgr;
X  c_curr_dsptch->job_id.dev3_inod.intgr  =  go_job->dev3_inod.intgr;
X  c_curr_dsptch->job_id.dev4_inod.intgr  =  go_job->dev4_inod.intgr;
X  c_curr_dsptch->job_id.dev5_inod.intgr  =  go_job->dev5_inod.intgr;
X  c_curr_dsptch->job_id.dev6_inod.intgr  =  go_job->dev6_inod.intgr;
X  c_curr_dsptch->job_id.dev7_inod.intgr  =  go_job->dev7_inod.intgr;
X  c_curr_dsptch->job_id.dev8_inod.intgr  =  go_job->dev8_inod.intgr;
X  c_curr_dsptch->job_id.dev9_inod.intgr  =  go_job->dev9_inod.intgr;
X  c_curr_dsptch->job_id.dev10_inod.intgr  =  go_job->dev10_inod.intgr;
X  c_curr_dsptch->job_id.dev11_inod.intgr  =  go_job->dev11_inod.intgr;
X  c_curr_dsptch->job_id.uid.intgr        =  go_job->uid.intgr;
X  c_curr_dsptch->job_id.loop.intgr       =  go_job->loop.intgr;
X  c_curr_dsptch->time_in                 =  in_time;
X  time(&tloc);
X  c_curr_dsptch->time_out          =  tloc;
X
X  /* now tell the ISPIN he may proceed */
X
X  /* where's his FIFO? */
X
X  strcpy(lil_buf,myncheck(c_curr_dsptch->job_id.my_fifo.intgr,FIFOdir));
X
X  if(strlen(lil_buf) == 0)
X  {
X    /* need to send out an error msg */
X    /* format an error message */
X    time(&tloc);
X    nowtime = (struct tm *)localtime(&tloc);
X    time_str = asctime(nowtime);
X    sprintf(errmsg,"IQUEUER: can't find outFIFO to ISPIN pid = %d.  time:\n",incoming.my_pid.intgr);
X    strcat(errmsg,"                            ");
X    strcat(errmsg,time_str);
X    strcat(errmsg,"\n");
X
X   /* call the error routine, don't exit */
X   ret_val = my_error(NO_EXIT);
X   ret_val = clean_out(c_curr_dsptch->job_id.my_pid.intgr);
X   return(0);
X }
X
X strcpy(outFIFO, FIFOdir);
X strcat(outFIFO, lil_buf);
X
X  /* this open of the FIFO is the one we'll use for our write           */
X  if((outfifo = open(outFIFO,O_WRONLY)) == -1)
X  {
X    /* need to send out an error msg */
X    /* format an error message */
X    time(&tloc);
X    nowtime = (struct tm *)localtime(&tloc);
X    time_str = asctime(nowtime);
X    sprintf(errmsg,"IQUEUER: open %s: %s. time:\n",outFIFO,sys_errlist[errno]);
X    strcat(errmsg,"                            ");
X    strcat(errmsg,time_str);
X    strcat(errmsg,"\n");
X
X   /* call the error routine, don't exit */
X   ret_val = my_error(NO_EXIT);
X   ret_val = clean_out(c_curr_dsptch->job_id.my_pid.intgr);
X   return(0);
X  }
X
X  /* construct the message */
X  count1 = count2 = 0;
X
X  out_msg.orders.intgr      = GO;
X  while(count1 < intsize)
X  {
X    msg_buf[count2++] = out_msg.orders.chr[count1++];
X  }
X  count1 = 0;
X
X  out_msg.iq_pid.intgr      = getpid();
X  while(count1 < intsize)
X  {
X    msg_buf[count2++] = out_msg.iq_pid.chr[count1++];
X  }
X  count1 = 0;
X
X  out_msg.dev_use_ino.intgr = go_inod;
X  while(count1 < intsize)
X  {
X    msg_buf[count2++] = out_msg.dev_use_ino.chr[count1++];
X  }
X  count1 = 0;
X
X  out_msg.pad1.intgr        = 0;
END_OF_FILE
if test 34486 -ne `wc -c <'ISPIN/src/IQUEUER.c.aa'`; then
    echo shar: \"'ISPIN/src/IQUEUER.c.aa'\" unpacked with wrong size!
fi
# end of 'ISPIN/src/IQUEUER.c.aa'
fi
if test -f 'ISPIN/src/ISPIN.c.af' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/src/ISPIN.c.af'\"
else
echo shar: Extracting \"'ISPIN/src/ISPIN.c.af'\" \(13239 characters\)
sed "s/^X//" >'ISPIN/src/ISPIN.c.af' <<'END_OF_FILE'
X                                /* assume no timeout */
X                                time_out = 0; 
X
X                                alarm(NETWAIT);
X
X              wr_count += write(out_file,usr_strng,strlen(usr_strng));
X
X                                /* turn off the alarm clock */
X                                alarm(0);
X
X                                /* ignore alarm */
X        signal(SIGALRM, SIG_IGN);
X
X                                if(time_out == 1)
X                                {
X                                  /* We timed out on the write.*/
X                                  /* Behave as though we were  */
X                                  /* disconnected.             */
X
X                                  my_error(NET_TIME);
X                                }
X
X              break;       
X            case '0':
X            case '1':
X            case '2':
X            case '3':
X            case '4':
X            case '5':
X            case '6':
X            case '7':
X              /* octal representation of an ascii character */
X              oct_cnt = sscanf(&msg[count - 1],"%3o",&octal);
X              if(octal <= 0177)
X              {
X                sprintf(octal_char,"%c",octal);
X
X                                /* set up timeout for write */
X        signal(SIGALRM, my_error);
X
X                                /* assume no timeout */
X                                time_out = 0; 
X
X                                alarm(NETWAIT);
X
X                wr_count += write(out_file,&octal_char[0],1);
X
X                                /* turn off the alarm clock */
X                                alarm(0);
X
X                                /* ignore alarm */
X        signal(SIGALRM, SIG_IGN);
X
X                                if(time_out == 1)
X                                {
X                                  /* We timed out on the write.*/
X                                  /* Behave as though we were  */
X                                  /* disconnected.             */
X
X                                  my_error(NET_TIME);
X                                }
X
X              }
X              /* Move our pointer along to account for possibly processing */
X              /* more than one char via the sscanf.                        */
X              /* count += (oct_cnt - 1); */
X              count += (oct_cnt + 1);
X              break;       
X            default:
X              /* send the character */
X
X                                /* set up timeout for write */
X        signal(SIGALRM, my_error);
X
X                                /* assume no timeout */
X                                time_out = 0; 
X
X                                alarm(NETWAIT);
X
X              wr_count += write(out_file,&msg[count - 1],1);
X
X                                /* turn off the alarm clock */
X                                alarm(0);
X
X                                /* ignore alarm */
X        signal(SIGALRM, SIG_IGN);
X
X                                if(time_out == 1)
X                                {
X                                  /* We timed out on the write.*/
X                                  /* Behave as though we were  */
X                                  /* disconnected.             */
X
X                                  my_error(NET_TIME);
X                                }
X
X              break;       
X          }
X        }
X        break;       
X      default:
X        /* send the character */
X
X                                /* set up timeout for write */
X        signal(SIGALRM, my_error);
X
X                                /* assume no timeout */
X                                time_out = 0; 
X
X                                alarm(NETWAIT);
X
X        wr_count += write(out_file,&msg[count - 1],1);
X
X                                /* turn off the alarm clock */
X                                alarm(0);
X
X                                /* ignore alarm */
X        signal(SIGALRM, SIG_IGN);
X
X                                if(time_out == 1)
X                                {
X                                  /* We timed out on the write.*/
X                                  /* Behave as though we were  */
X                                  /* disconnected.             */
X
X                                  my_error(NET_TIME);
X                                }
X
X        break;       
X    }
X    if(msg[count - 1] != '\0')
X    {
X      checkit = msg[count++];
X    }
X  }
X  return(wr_count);
X}
X
X
Xquit_net()
X{
X  int answer = 0;
X  if(stayt == QUITTING)
X  {
X    SETJMP(kwit);
X    ++quit_once;
X    if(quit_once == 3)
X    {
X      kill(getpid(), SIGTERM);
X    }
X  }
X  /************************************************************************/
X  /* Reset traps on all signals!                                          */
X  /* We don't want to be interrupted when we already know we're           */
X  /* on our way out!                                                      */
X  /************************************************************************/
X
X  /* advise IQUEUER of our current state */
X  notify(stayt);
X
X#ifdef DEBUG
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          strcpy(errmsg,"ISPIN: quit_net 1  time:\n");
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X#endif
X
X
X
X/* take care of the signals */
X        signal(SIGINT, SIG_IGN);    /* ignore "interrupt" signal <DEL> */
X        signal(SIGHUP, SIG_IGN);    /* ignore "hang up" signal */
X        signal(SIGQUIT, SIG_IGN);   /* ignore "quit" signal */
X        signal(SIGALRM, SIG_IGN);
X        signal(SIGTERM, my_error);
X#ifdef NQ
X        signal(SIGRES, SIG_IGN);     /* ignore "restart" signal */
X        signal(SIGBACK, SIG_IGN);   /* ignore "back-up" signal */
X        signal(SIGSTOP, my_error);   /* trap "stop" signal */
X#endif
X
X#ifdef DEBUG
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          strcpy(errmsg,"ISPIN: quit_net 2  time:\n");
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X#endif
X
X
X  /* The interaction between this module and others poses significant */
X  /* potential for loopiness in the extremus. If we have been here    */
X  /* once already in this iteration of ISPIN, we obviously weren't    */
X  /* able to quit successfully. This could happen in the case where   */
X  /* the device (network or printer) is refusing to accept characters.*/
X  /* The write of our "quit" strings times out, so we try to quit,    */
X  /* and so on, ad nauseum. Fuggit.                                   */
X
X  /* 06/25/90: At least some of the SysV lpscheds send two software   */
X  /* termination signals to jobs which are being cancelled. The second*/
X  /* signal   will interrupt a valid quit sequence. So we give it two */
X  /* chances to back out normally.                              LSB   */
X
X  if(quit_once <= 3)
X  {
X
X#ifdef DEBUG
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          strcpy(errmsg,"ISPIN: quit_net 3  time:\n");
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X#endif
X
X
X    /* start out with clean buffers */
X    ioctl(out_file, TCFLSH, 2);
X
X
X#ifdef DEBUG
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          strcpy(errmsg,"ISPIN: quit_net 4  time:\n");
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X#endif
X
X    /* set our list pointers to point at head of the list */
X    quit_list = quit_curr = quit_head;
X
X#ifdef DEBUG
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          strcpy(errmsg,"ISPIN: quit_net 5  time:\n");
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X#endif
X
X
X    while(quit_curr->next != NULL)
X    {
X
X
X      quit_curr = quit_curr->next;
X
X
X      answer = write_net(quit_curr->quit_strg);
X
X#ifdef DEBUG
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          strcpy(errmsg,"ISPIN: quit_net 6  time:\n");
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X#endif
X
X    }
X
X#ifdef DEBUG
X          /* format an error message */
X          time(&tloc);
X          nowtime = (struct tm *)localtime(&tloc);
X          time_str = asctime(nowtime);
X          strcpy(errmsg,"ISPIN: quit_net 7  time:\n");
X          strcat(errmsg,"                            ");
X          strcat(errmsg,time_str);
X          strcat(errmsg,"\n");
X         if((logfile = fopen(LOGFILE,"a+")) != NULL)
X         {
X            fprintf(logfile,errmsg);
X            fclose(logfile);
X         }
X#endif
X
X
X    alarm(0);
X
X  }
X  if(stayt == QUITTING)
X  {
X    ioctl(out_file, TCSETA, &Tsav);
X    close(out_file);
X    port_open = 0;
X    my_exit(0);
X  }
X  else
X  {
X    return(0);
X  }
X}
X
X
Xagain()
X{
X
X        ++netloop;
X        ++req_msg.loop.intgr;
X        /* free the allocated memory */
X        free(expt1);
X        free(c_send);
X        free(expt2);
X        stayt = DISCONNECTING;
X        ret_val = quit_net();
X        ioctl(out_file, TCSETA, &Tsav);
X        quit_once = 0;
X
X#ifndef NQ
X        if(strcmp(ctrl_tty,GO_dev) != 0)
X        {
X          /* never close the control terminal */
X          /* Pyramid puts us in la-la land if we do */
X          close(out_file);
X          out_file = ctrltty;
X        }
X        numfiles = num_ofile;
X#else
X        /* just because of a couple of old Zilogs in Fargo */
X        close(out_file);
X        port_open = 0;
X#endif
X        notify(LOOPING);
X        alarm(0);
X        sleep(NETSLEEP);
X        notify(BUSY);
X        /* jump back to main(), just before setuptty() call   07/27/90  LSB */
X        LONGJMP(agayn,netloop);
X}
X
X
Xisit_gone()
X{
X  /* called whenever the do_it function has reason to     */
X  /* believe the printer has been disconnected or powered */
X  /* down. The user (whoever configured the rtab entry    */
X  /* for this printer) has specified specific string(s)   */
X  /* which we expect the network may send us to indicate  */
X  /* the disconnected condition. Here is where we compare */
X  /* what we have received to what we expect. If we       */
X  /* determine we have been disconnected, try again.      */
X
X
X    if(netloop <= MAXNET_TRY)
X    {
X      if(disconn()== 1)
X      {
X        /* advise IQUEUER of our current state */
X        notify(DISCONNECTING);
X
X        my_error(DISCONNECTING);
X      }
X     }
X     else
X     {
X       /* need to send out an error msg */
X       /* format an error message */
X       time(&tloc);
X       nowtime = (struct tm *)localtime(&tloc);
X       time_str = asctime(nowtime);
X  
X       sprintf(errmsg,"ISPIN: printer %s: %d LOOPS, so quitting.\n",dest,netloop);
X          sprintf(errmsg2,"    USER: %s\n",from);
X          strcat(errmsg,errmsg2);
X          if(usr_addr)
X          {
X            sprintf(errmsg2,"    ADDR: %s\n",usr_strng);
X            strcat(errmsg,errmsg2);
X          }
X          if(port_open == 1)
X          {
X            sprintf(errmsg2,"     DEV: %s\n",GO_dev);
X            strcat(errmsg,errmsg2);
X          }
X#ifdef NQ
X          sprintf(errmsg2,"    FILE: %s\n",fyle);
X#else
X          sprintf(errmsg2,"    FILE: %s\n",fyles[0]);
X#endif
X          strcat(errmsg,errmsg2);
X          sprintf(errmsg2,"    TIME: %s\n",time_str);
X          strcat(errmsg,errmsg2);
X
X       /* call the error routine, never come back */
X       my_error(MYERR);
X     }
X}
X
X
Xdisconn()
X{
X  ushort answer;
X
X  /* set our list pointers to point at head of the list */
X  disc_list = disc_curr = disc_head;
X
X  while(disc_curr->next != NULL)
X  {
X    disc_curr = disc_curr->next;
X
X
X
X
X    answer = matcher(in_buf,disc_curr->disc_strg);
X
X    if(answer == 0)
X    {
X      return(1);
X    }
X  }
X  return(0);
X}
END_OF_FILE
if test 13239 -ne `wc -c <'ISPIN/src/ISPIN.c.af'`; then
    echo shar: \"'ISPIN/src/ISPIN.c.af'\" unpacked with wrong size!
fi
# end of 'ISPIN/src/ISPIN.c.af'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_NOSHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_NOSHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_NOSHT'\" \(599 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_NOSHT' <<'END_OF_FILE'
X# The address entered by the user must be the last 8 (eight) digits of the
X# fourteen digit X.25 address of the printer.
X# If you use the ISPI application as the frontend for your users, the comment
X# line following this entry will be used in ISPI's menu.
X#
X#
X#
Xextqume;/dev/ttyi07,/dev/ttyi31,/dev/ttyi15;9600;-L;-Bcongestion;-Bremote dte;-Q\L\L\032\dclr\r\d;-DConnection cleared;-Dpad>;ad>-\p\K\pclr\r\d-ad>;\r\p;pad>-\p\K\pclr\r\d-pad>;set recall=26\r\p;pad>-\r\d-pad>;\pconnect\s000000\U\r\d;pened-\p\K\pclr\r\dset recall=26\r\p\pconnect\s000000\U\r\d-pened;\d\033F66\033C00\0339\d;;;
X#Qume
X#
X#
END_OF_FILE
if test 599 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_NOSHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_NOSHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_NOSHT'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_SHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_SHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_SHT'\" \(615 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_SHT' <<'END_OF_FILE'
X# The address entered by the user must be the last 8 (eight) digits of the
X# fourteen digit X.25 address of the printer.
X# If you use the ISPI application as the frontend for your users, the comment
X# line following this entry will be used in ISPI's menu.
X#
X#
X#
Xextsqume;/dev/ttyi07,/dev/ttyi31,/dev/ttyi15;9600;-L;-Bcongestion;-Bremote dte;-Q\L\L\032\dclr\r\d;-DConnection cleared;-Dpad>;ad>-\p\K\pclr\r\d-ad>;\r\p;pad>-\p\K\pclr\r\d-pad>;set recall=26\r\p;pad>-\r\d-pad>;\pconnect\s000000\U\r\d;pened-\p\K\pclr\r\dset recall=26\r\p\pconnect\s000000\U\r\d-pened;\d\033F90\033C28\0339\d;;;
X#Qume - Sheet Feeder
X#
X#
END_OF_FILE
if test 615 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_SHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_SHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_CDN_PTR/USER_ADDR/QUME_SHT'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_PTR/QUME_SHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_PTR/QUME_SHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_PTR/QUME_SHT'\" \(70 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_PTR/QUME_SHT' <<'END_OF_FILE'
X#
Xnetind1;/dev/ttyi07;9600;-L;;\033S\033F90\033C28\0339\015\033T;;;
X#
END_OF_FILE
if test 70 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_PTR/QUME_SHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_PTR/QUME_SHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_PTR/QUME_SHT'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_PTR/QUME_NOSHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_PTR/QUME_NOSHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_PTR/QUME_NOSHT'\" \(70 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_PTR/QUME_NOSHT' <<'END_OF_FILE'
X#
Xnetind1;/dev/ttyi07;9600;-L;;\033S\033F66\033C00\0339\015\033T;;;
X#
END_OF_FILE
if test 70 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_PTR/QUME_NOSHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_PTR/QUME_NOSHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_PTR/QUME_NOSHT'
fi
if test -f 'ISPIN/install/lib_rtab/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/README'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/README'\" \(2325 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/README' <<'END_OF_FILE'
X
X
X
X
X
X                               LIB_RTAB
X
XThis directory contains subdirectories of valid, (mostly) tested rtab entries
Xfor various networking situations. These rtab entries may be added
Xdirectly to the top of your rtab. Adjust them to suit your needs, especially
Xin the areas of printer name, device(s)to be used, destination addresses,
Xlogin heralds and info messages from local switching hardware, and the like.
X
XSee ISPIN/doc/rtab. These sample rtab entries are pure vanilla, plain-jane
X(excuse me, Jane) examples. They do not demonstrate the full flexibility
Xand capability of this component of ISPIN. The rtab is intended as your entry
Xpoint for creative implementation of ISPIN. You will not be able to take 
Xadvantage of this feature unless you study ISPIN/doc/rtab carefully.
X
XThe major subdirectories at this time include:
X
XCPU_CDN_PTR - for connecting from the cpu, through PACNET/CDN, to the printer
X            - both the cpu and the printer are directly connected to CDN
X            - (PACNET/CDN is IRS's current (05/15/89) X.25 network, with
X              asynchronous pads at both ends.)
X
XCPU_SW_PTR - for connecting from the cpu, through a local switch (the examples
X             given are for Tellabs), to the printer
X           - both the cpu and the printer are connected to the switch
X
XCPU_SW_CDN_PTR - for connecting from the cpu, through a local switch (example
X                 is Tellabs), then through CDN to the printer
X               - the cpu is connected to the local switch, the switch is
X                 connected to CDN, the printer is connected to CDN
X
XCPU_PTR - for printers hardwired to the cpu
X
X
XEach of the above-mentioned directories contains two subdirectories, as follow:
X
XADDR_SPEC - for rtab entries in which the destination address is explicitly
X            specified
X
XUSER_ADDR - for rtab entries which allow the user to specify the destination
X            address of the printer
X
X
XFinally, beneath those directories lie the example rtab entries. One of those
Xentries is called PLAIN, and will suffice for most printers. Other entries
Xwill be named similarly to their make and model. The make and model-specific
Xrtab entries may contain special printer command/control sequences and/or
Xspecific variations on the pauses, delays, or waits upon connection and
Xdisconnection.
X
END_OF_FILE
if test 2325 -ne `wc -c <'ISPIN/install/lib_rtab/README'`; then
    echo shar: \"'ISPIN/install/lib_rtab/README'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/README'
fi
if test -f 'ISPIN/doc/OLD-DOCS/bio' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/doc/OLD-DOCS/bio'\"
else
echo shar: Extracting \"'ISPIN/doc/OLD-DOCS/bio'\" \(228 characters\)
sed "s/^X//" >'ISPIN/doc/OLD-DOCS/bio' <<'END_OF_FILE'
XAbout the author:
X
XLarry Bartz chose to enter the field of Data Processing in 1983 after
Xhis wife convinced him that hog farming was not the only attractive 
Xalternative to continuing his career with IRS's Examination Division.
END_OF_FILE
if test 228 -ne `wc -c <'ISPIN/doc/OLD-DOCS/bio'`; then
    echo shar: \"'ISPIN/doc/OLD-DOCS/bio'\" unpacked with wrong size!
fi
# end of 'ISPIN/doc/OLD-DOCS/bio'
fi
echo shar: End of archive 5 \(of 15\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

