Newsgroups: comp.sources.unix
From: sir-alan!ispin!lbartz@iuvax.cs.indiana.edu (Larry Bartz)
Subject: v25i113: Indianapolis Standard Printer Interface for Networked printers, Part02/15
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: sir-alan!ispin!lbartz@iuvax.cs.indiana.edu (Larry Bartz)
Posting-Number: Volume 25, Issue 113
Archive-Name: ispin/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 15)."
# Contents:  ISPI/ispi.c ISPI/UUSTUFF.dr/SYS_III.dr/uustart.c
#   ISPI/UUSTUFF.dr/SYS_V.dr/uustart.c
# Wrapped by socrates@indy6 on Tue Jan 28 15:26:26 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ISPI/ispi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPI/ispi.c'\"
else
echo shar: Extracting \"'ISPI/ispi.c'\" \(43525 characters\)
sed "s/^X//" >'ISPI/ispi.c' <<'END_OF_FILE'
X/****************************************************************************/
X/*                                                                          */
X/*  ISPI                                                                    */
X/*                                                                          */
X/*  Indianapolis Standard Printer Interface                                 */
X/*                                                                          */
X/*  - generates printer selection menu from table, serves as front-end      */
X/*    for System V lp/lpsched or Zilog System III nq/dqueuer spoolers.      */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/*  Copyright (C) 1991                                                      */
X/*  Kent Meurer                                                             */
X/*  Internal Revenue Service                                                */
X/*  Indianapolis District Office                                            */
X/*                                                                          */
X/*  This program is free software; you can redistribute it and/or modify    */
X/*  it under the terms of the GNU General Public License as published by    */
X/*  the Free Software Foundation, version 1.                                */
X/*                                                                          */
X/*  This program is distributed in the hope that it will be useful,         */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of          */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           */
X/*  GNU General Public License for more details.                            */
X/*                                                                          */
X/*  You should have received a copy of the GNU General Public License       */
X/*  along with this program; if not, write to the Free Software             */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               */
X/*                                                                          */
X/****************************************************************************/
X/*
X
X *
X  COMPILE
X        Zilog System III Zeus Unix:         cc -o ispi ispi.c -s
X        Zilog System V (Models 32 & 130):   cc -f -DSYSTEM_V -o ispi ispi.c -s
X        Sequent System V Unix:              cc -DSEQUENT -o ispi ispi.c -s
X        Other System V:                     cc -DSYSTEM_V -o ispi ispi.c -s
X
X             *
X              If Supporting ISPIN's external printing, include -DEXTERN
X              in the above compile lines.
X
X              If Supporting ISPI's file transfer capability, include -DXFER
X              in the above compile lines. Also check value assigned to
X              XFERCMD constant, below.
X
X              If Supporting UUCP printing, (88.  Print to Another System),
X              include -DUUCP in the above compile lines.
X
X              Written by:             Kent Meurer   IRS, Indianapolis District
X              modifications by:       Larry Bartz   IRS, Indianapolis District
X              modifications by:       Kevin Fannin  IRS, Indianapolis District
X
X
X                                                                              */
X
X#include <stdio.h>
X#include <sys/utsname.h>
X#include <signal.h>
X#include <pwd.h>
X
Xstruct term_types
X {
X   char term[8];
X   char on[8];
X   char off[8];
X };
X
Xstatic struct term_types terminals[] =  {
X/* Use octal representations of unprintable chars for ON and OFF strings.     */
X/* Terminate strings with \\c so echo does not send a newline. See echo(1).   */
X/*        TERM    ON     OFF                                                  */
X/*        ----    --     ---                                                  */
X          {"v5", "\033*\\c", "\033?\\c"},    /* Visual 50/55/65               */
X          {"v55", "\033*\\c", "\033?\\c"},   /* Visual 50/55/65               */
X          {"v65", "\033*\\c", "\033?\\c"},   /* Visual 50/55/65               */
X          {"d2", "\033[5i\\c", "\033[4i\\c"},/* TI/IBM PC's (VT100 Termcap)   */
X          {"vt100", "\033[5i\\c", "\033[4i\\c"},  /*  PC's (VT100 Termcap)    */
X          {"wy50", "\030\\c", "\024\\c"},      /* Wyse 50                       */
X                                             /* add new terminal type(s) here */
X          {"\0", "\0", "\0"}            };
X
X#define MAX_PRINTERS  28
X#define TERM_ENV      "TERM"
X#define CONFIG_ENV    "CONFIGDIR"
X#define TRUE          1
X#define FALSE         0
X#define FLAG(x)       (x == '-')
X#define NUM(x)        ((x >= '0') && (x <= '9'))
X#define WS(x)         ((x == ' ') || (x == '\t'))
X#define NL(x)         ((x == '\n') || (x == '\r'))
X#define NP(x)         (x == 014)
X#define ASCII(x)      (((x >= 040) && (x <= 0176)) || \
X                        (x == 010) || (x == 011) || (x == 012))
X
X#ifdef  EXTERN
X#  define EXTERN_QUEUE_NAME   "ext"
X#endif
X
X#ifdef SEQUENT
X#  define SYSTEM_V
X#  define CLEAR               "/usr/ucb/clear"
X#  ifdef UUCP
X#    define UUX               "ucb uux"
X#    define UUNAME            "ucb uuname"
X#  endif
X#else
X#  define CLEAR               "clear"
X#  ifdef UUCP
X#    define UUX               "uux"
X#    define UUNAME            "uuname"
X#  endif
X#endif
X
X#ifdef SYSTEM_V
X#  define setjmpret(p)        setjmp(p)
X#  define longjmpret(s, n)    longjmp(s, n)
X#  define CONFIG_PATH         "/usr/spool/lp/ISPIN"
X#  ifdef EXTERN
X#    define RTAB_PATH         "/usr/spool/lp/ISPIN"
X#  endif
X#else
X#  define setjmpret(p)        setret(p)
X#  define longjmpret(s, n)    longret(s, n)
X#  define CONFIG_PATH         "/usr/spool/queuer"
X#  ifdef EXTERN
X#    define RTAB_PATH         "/usr/spool/queuer/ISPIN"
X#  endif
X#endif
X
X/* file xfer stuff 12/11/90 LSB */
X#ifdef XFER
X
X   /* command to be invoked to transfer the file to user's system */
X
X#  define XFERCMD             "/usr/local/bin/kermit -is"
X
X   /* An environmental variable will override the compiled-in value, */
X   /* such as if certain (group of) user(s) would prefer to use [u,x,z]modem */
X#  define XFER_ENV            "XFERCMD"
X#endif
X
X
Xtypedef int            ret_buf[10];
Xtypedef unsigned int   index;
Xtypedef unsigned short bool;
X
Xstruct device
X {
X   char q_name[15];
X   char d_name[6];
X   char comments[21];
X };
X
XFILE              *fopen(), *config, *tty, *report;
Xunsigned short    exit_status = 0, num_printers;
Xint               num_choices, choice, c, copies = 1, fileargc, get_groupid(),
X                  usergroupid, proc_id;
Xchar              que_name[9], current_config[50], curr_system[10], printer[15],
X                  clear_buff[256], file_buffer[BUFSIZ], prog_name[15], term[10],
X                  *getenv(), *fileargv[100], *config_ptr, config_path[50];
X#ifdef XFER
Xchar              *xfer_ptr, xfer_cmd[50];
Xvoid              xfer_it();
X#endif
Xstruct term_types *t_ptr;
Xstruct device     devices[MAX_PRINTERS+1], *d_ptr;
Xstruct utsname    *sys_name, tmp_struct;
Xvoid              clear_scr(), ignore_line(), get_queue_descriptor(), view(), 
X                  get_device_descriptor(), save_comments(), set_lps(), show(),
X                  print_menu(), get_choice(), verify_choice(),
X                  get_copies(), printjob(), delfunc(), sysdelfunc(), uname(),
X                  check_group();
Xbool              no_choice_has_been_made = TRUE,
X                  remote_printer = FALSE, lp = FALSE, clear_set = FALSE,
X                  setcom = FALSE, banner = FALSE, copy = FALSE, mail = FALSE,
X                  all_printers = FALSE;
Xret_buf           print, sys;
X
X
X#ifdef UUCP
X  unsigned short  num_systems = 0;
X  static char     systems[32][9];
X  void            get_system();
X  bool            systems_set = FALSE;
X#endif
X
X#ifdef EXTERN
X  void            ignore_queue_name(), show_externs(), extdelfunc(),
X                  load_externs();
X  char            address[128];
X  ret_buf         ext;
X  bool            externs = FALSE;
X#endif
X
X
Xmain(argc, argv)
X int  argc;
X char *argv[];
X {
X  index  n = 1;
X  bool   q_came_first = FALSE, buffer_not_loaded = TRUE;
X
X   if((tty = fopen((ttyname(0)),"w")) == NULL)
X    {
X      fprintf(stderr,"Not a tty\n");
X      exit(5);
X    }
X
X   signal(SIGQUIT, SIG_IGN);
X   signal(SIGINT, SIG_IGN);
X
X   strcpy(prog_name, argv[0]);
X
X   /* Added support for defining config file location via ENVIRONMENT */
X   /* variable named CONFIGDIR.                                       */
X   /* 08/07/90   LSB                                                  */
X   config_ptr = getenv(CONFIG_ENV);
X   if(config_ptr ==  (char *)0)
X   {
X     sprintf(current_config,"%s/config", CONFIG_PATH);
X     sprintf(config_path,"%s", CONFIG_PATH);
X   }
X   else
X   {
X     sprintf(current_config,"%s/config", config_path);
X     /* Include alternative to revert to compiled-in path */
X     /* if the environmental variable is ill-defined.     */
X     if((config = fopen(current_config,"r")) == NULL)
X     {
X       sprintf(current_config,"%s/config", CONFIG_PATH);
X       sprintf(config_path,"%s", CONFIG_PATH);
X     }
X     else
X     {
X       fclose(config);
X     }
X   }
X
X
X   if((config = fopen(current_config,"r")) == NULL)
X    {
X        fprintf(stderr, "%s: Print Request Aborted - Unable to open %s\n",
X                         prog_name, current_config);
X        exit(7);
X
X    }
X
X
X   /* Added support for defining file transfer command via ENVIRONMENT */
X   /* variable named XFERCMD.                                          */
X   /* 12/10/90   LSB                                                   */
X#ifdef XFER
X   xfer_ptr = getenv(XFER_ENV);
X   if(xfer_ptr != (char *)0)
X   {
X     strcpy(xfer_cmd,xfer_ptr);
X   }
X   else
X   {
X     strcpy(xfer_cmd, XFERCMD);
X   }
X#endif
X
X
X   usergroupid = get_groupid();
X
X   sys_name = &tmp_struct;
X   uname(sys_name);
X   strcpy(curr_system,sys_name->nodename);
X
X
X   while(FLAG(argv[n][0]))
X    {
X      switch(argv[n][1])
X       {
X         case 'a':
X         case 'A':
X                   all_printers = TRUE;
X                   break;
X         case 's':
X                   setcom = TRUE;
X                   break;
X         case 'B':
X                   banner = TRUE;
X                   break;
X         case 'm':
X                   mail = TRUE;
X                   break;
X         case 'c':
X                   copy = TRUE;
X                   break;
X         case 't':
X                   copies = atoi(argv[n+1]);
X                   if(copies < 1)
X                    copies = 1;
X                   n++;
X                   break;
X         case 'd':
X         case 'p':           /* ignore these nq flags and their args */
X                   n++;
X                   break;
X         default:            /* ignore other flags we don't support  */
X                   break;
X       }
X      n++;
X    }
X
X   if((n == argc) && (! setcom))
X    {
X      fileargv[0] = &file_buffer[0];
X      fileargc = 1;
X      while(buffer_not_loaded)
X       {
X          n = 0;
X          fprintf(tty,"\n\nEnter the name of the File(s) to be printed: ");
X          fflush(tty);
X
X          file_buffer[n] = getc(stdin);
X
X          while(WS(file_buffer[n]))
X            file_buffer[n] = getc(stdin);
X
X          while((! NL(file_buffer[n])) && (n < BUFSIZ))
X           {
X             n++;
X             file_buffer[n] = getc(stdin);
X             while(! NL(file_buffer[n]) &&
X                  (! WS(file_buffer[n])) && (n < BUFSIZ))
X              {
X                n++;
X                file_buffer[n] = getc(stdin);
X              }
X
X             if(WS(file_buffer[n]))
X              {
X                file_buffer[n] = '\0';
X                n++;
X                file_buffer[n] = getc(stdin);
X                while(WS(file_buffer[n]))
X                  file_buffer[n] = getc(stdin);
X                if(! NL(file_buffer[n]))
X                 {
X                   fileargv[fileargc] = &file_buffer[n];
X                   fileargc++;
X                 }
X              }
X             buffer_not_loaded = FALSE;
X           }
X          file_buffer[n] = '\0';
X       }
X
X      if(n >= BUFSIZ)
X       {
X         fprintf(stderr,"%s: File list too long\n", prog_name);
X         exit(3);
X       }
X    }
X   else
X    {
X      fileargc = 0;
X      for(n; n < argc; n++, fileargc++)
X        fileargv[fileargc] = argv[n];
X    }
X
X
X   while(no_choice_has_been_made)
X    {
X      setjmpret(print);
X      signal(SIGINT, delfunc);
X      num_printers = 0;
X      d_ptr = devices;
X      while(((c = getc(config)) == ' ') || (c == '\t'));
X      lp = FALSE;
X
X      while((c != EOF) && (num_printers < MAX_PRINTERS))
X       {
X         switch(c)
X          {
X            case '#':
X              ignore_line();
X              break;
X            case 'Q':
X              q_came_first = TRUE;
X              get_queue_descriptor();
X              break;
X            case 'D':
X              if(q_came_first)
X               {
X                 get_device_descriptor();
X                 num_printers++;
X               }
X              else
X               {
X                 fprintf(stderr,
X                   "Print Request Unsuccessful - %s: file garbled\n",
X                   current_config);
X                 exit(8);
X               }
X              break;
X            case 'L':
X            case 'l':
X              if((((c = getc(config)) == 'P') || (c == 'p')) &&
X                   (! q_came_first))
X               {
X                 lp = TRUE;
X                 set_lps();
X               }
X              else
X               {
X                 fprintf(stderr,
X                   "Print Request Unsuccessful - %s: file garbled\n",
X                   current_config);
X                 exit(8);
X               }
X              break;
X            default:
X              fprintf(stderr,
X                "Print Request Unsuccessful - %s: file garbled\n",
X                current_config);
X              exit(8);
X              break;
X           }
X          if(c != EOF)
X            while(((c = getc(config)) == ' ') || (c == '\t'));
X       }
X
X     q_came_first = FALSE;
X     fclose(config);
X     /* KDF 11/29/90 Following caused last printer to be blank on lp systems */
X     /*              when menu was full.                                     */
X     /* d_ptr->d_name[0] = d_ptr->q_name[0] = d_ptr->comments[0] = NULL;     */
X     print_menu();
X     get_choice();
X     if(! no_choice_has_been_made)
X      {
X        if(! remote_printer)
X         {
X           if(lp)
X             strcpy(printer,devices[choice-1].q_name);
X           else
X             sprintf(printer,"%s:%s", devices[choice-1].q_name,
X                     devices[choice-1].d_name);
X         }
X        verify_choice();
X      }
X    }
X
X   printjob(fileargc, fileargv);
X   fclose(tty);
X   exit(exit_status);
X }
X
X
X/* Function added to get group id.    KDF 11/28/90 */
Xint get_groupid()
X {
X   struct passwd *pwentry, *getpwuid();
X
X   pwentry = getpwuid(getuid());
X   return(pwentry->pw_gid);
X }
X
Xvoid verify_choice()
X {
X   signal(SIGINT, delfunc);
X
X   clear_scr();
X   fprintf(tty, "\n\n\n\n\n\n\n\n\n                You have selected ");
X
X   if(remote_printer)
X     fprintf(tty, "Slave Printing");
X   else
X
X#  ifdef EXTERN
X   if(externs)
X    {
X       fprintf(tty, "%s - %s", printer, devices[choice-1].comments);
X       fprintf(tty, 
X               "\n                                  @ address %s", address);
X    }
X   else
X#  endif
X
X     fprintf(tty, "%s - %s", printer, devices[choice-1].comments);
X
X
X   fprintf(tty, "\n\n                Is this correct (y/n) ? ");
X   fflush(tty);
X
X   while(((c = getc(stdin)) == ' ') || (c == '\t'));
X   if(c != '\n')
X     while((getc(stdin)) != '\n');
X
X   if((c == 'Y') || (c == 'y'))
X     return;
X
X#  ifdef EXTERN
X     externs = FALSE;
X#  endif
X
X   no_choice_has_been_made = TRUE;
X   remote_printer  = FALSE;
X
X   if((config = fopen(current_config,"r")) == NULL)
X    {
X      fprintf(stderr, "%s: Print Request Aborted - Unable to open %s\n",
X                       prog_name, current_config);
X      exit(7);
X    }
X }
X
X
X
Xvoid clear_scr()
X {
X  FILE *clr;
X  char *cptr;
X
X   if(! clear_set)
X    {
X      if((clr = popen(CLEAR, "r")) == NULL)
X       {
X         fprintf(stderr,"%s: bad status from system clear\n", prog_name);
X         exit(6);
X       }
X      cptr = clear_buff;
X      while(((c = getc(clr)) != EOF) && (cptr != &clear_buff[255]))
X        *cptr++ = c;
X
X      *cptr = '\0';
X
X      clear_set = TRUE;
X    }
X
X   fprintf(tty, "%s", clear_buff);
X }
X
X
X
Xvoid ignore_line()
X {
X   while(((c = getc(config)) != '\n') && (c != EOF));
X }
X
X
X
Xvoid get_queue_descriptor()
X {
X  index n = 0;
X
X   que_name[n] = getc(config);
X   while((que_name[n] != ',') && (n < 9))
X    {
X      n++;
X      que_name[n] = getc(config);
X    }
X   que_name[n] = '\0';
X   ignore_line();
X
X#  ifdef EXTERN
X     if((strcmp(que_name, EXTERN_QUEUE_NAME)) == 0)
X       ignore_queue_name();
X#  endif
X }
X
X
X
X#ifdef EXTERN
X
Xvoid ignore_queue_name()
X {
X   while(((c = getc(config)) == ' ') || (c == '\t'));
X   while((c != EOF) && (c != 'Q'))
X    {
X      ignore_line();
X      while(((c = getc(config)) == ' ') || (c == '\t'));
X    }
X   ungetc(c,config);
X }
X
X#endif
X
X
X
Xvoid get_device_descriptor()
X {
X  index n = 0;
X
X   strcpy(d_ptr->q_name,que_name);
X   d_ptr->d_name[n] = getc(config);
X   while((d_ptr->d_name[n] != ',') && (n < 6))
X    {
X      n++;
X      d_ptr->d_name[n] = getc(config);
X    }
X   d_ptr->d_name[n] = '\0';
X
X   ignore_line();
X   save_comments();
X   d_ptr++;
X }
X
X
X
Xvoid save_comments()
X {
X  index n = 0;
X
X   while(((c = getc(config)) == ' ') || (c == '\t'));
X   if(c != '#')
X    {
X      while(n < 20)
X        d_ptr->comments[n++] = ' ';
X      d_ptr->comments[20] = '\0';
X      ungetc(c,config);
X      return;
X    }
X
X   while(((d_ptr->comments[n] = getc(config)) == ' ') ||
X          (d_ptr->comments[n] == '\t'));
X   while((d_ptr->comments[n] != '\n') && (n < 20))
X    {
X      n++;
X      c = getc(config);
X      if(c != EOF)
X       {
X         if(c != '\t')
X          d_ptr->comments[n] = c;
X         else
X          d_ptr->comments[n] = ' ';
X       }
X      else
X        break;
X    }
X
X   if((d_ptr->comments[n] != '\n') && (c != EOF))
X     ignore_line();
X
X   while(n < 20)
X    d_ptr->comments[n++] = ' ';
X   d_ptr->comments[n] = '\0';
X
X   check_group(); /* Function to check optional printer group parameter */
X }
X
X
X/* Code added to read optional printer GROUP comment line. KDF 11/28/90 */
X
Xvoid check_group()
X {
X   int n, printergroup; 
X   char holdnum[10];
X
X   while(((c = getc(config)) == ' ') || (c == '\t'));
X   if (c != '#')
X    {
X      ungetc(c,config);
X      return;
X    }
X
X   while(((c = getc(config)) == ' ') || (c == '\t'));
X
X   if ( (toupper(c)) != 'G' || (toupper(getc(config))) != 'R' || 
X        (toupper(getc(config))) != 'O' || (toupper(getc(config))) != 'U' || 
X        (toupper(getc(config))) != 'P' || 
X        ((c = (getc(config))) != ' ' && c != '\t')  )
X     {
X       ungetc(c,config);
X       ignore_line();
X       return;
X     }
X
X   while(((c = getc(config)) == ' ') || (c == '\t'));
X
X   if ((toupper(c)) == 'A') /* all groups specified */
X    {
X      ignore_line();
X      return;
X    }
X
X  n = 0;
X  while (c != '\n' && c != EOF)
X    {
X      if (c == ' ' || c == '\t')
X        {
X          holdnum[n] = '\0';
X          printergroup = atoi(holdnum);
X          if (printergroup == usergroupid)
X            {
X              ignore_line();
X              return;
X            }
X          while(((c = getc(config)) == ' ') || (c == '\t'));
X          n = 0;
X        }
X      else
X        {
X          holdnum[n] = c;
X          n++;
X          c = getc(config);
X        }
X    }
X
X  if (n > 0)
X    {
X      holdnum[n] = '\0';
X      printergroup = atoi(holdnum);
X      if (printergroup == usergroupid)
X        return;
X    }
X
X  /* if ispi called with -a flag, list all printers regardless of groups
X     that are specified in config file */
X  if (all_printers)
X    return;
X
X  /* if didn't find users group listed, then remove this printer from list */
X  d_ptr--;
X  num_printers--;
X
X }
X
X
Xvoid set_lps()
X {
X  index n = 0;
X
X   ignore_line();
X   num_printers = 0;
X
X   while((c != EOF) && (num_printers < MAX_PRINTERS))
X    {
X      d_ptr->d_name[0] = '\0';
X
X      while((c = getc(config)) == '#')
X        ignore_line();
X
X      while((WS(c)) || (NL(c)))
X        c = getc(config);
X
X      while((! WS(c)) && (! NL(c)) && (c != EOF) && (n < 14))
X       {
X         d_ptr->q_name[n++] = c;
X         c = getc(config);
X       }
X      if(n > 0)
X        num_printers++;
X      d_ptr->q_name[n++] = '\0';
X
X      while((! NL(c)) && (c != EOF))
X         c = getc(config);
X
X      if(c == EOF)
X        ungetc(c,config);
X      save_comments();
X
X      n = 0;
X      if(num_printers < MAX_PRINTERS)
X        d_ptr++;
X     }
X }
X
X
X
Xvoid print_menu()
X {
X  int   len;
X  index n;
X  char  fprinter[15], fprinter2[15];
X
X   num_choices = 1;
X   clear_scr();
X   fprintf(tty,"\n                      ");
X   fprintf(tty,"%s Printer Selection Menu\n", curr_system);
X   fprintf(tty,"                      ");
X   for(len = 0; len < strlen(curr_system); len++)
X     fprintf(tty,"-");
X   fprintf(tty," ------- --------- ----\n");
X   if(num_printers < 19)
X    fprintf(tty, "\n");
X
X
X   if(num_printers < 10)
X    {
X      d_ptr = devices;
X      /* Changed while statement KDF 11/29/90 */
X      /* while(d_ptr->q_name[0] != NULL) */
X      while(num_choices <= num_printers)
X       {
X        if(lp)
X           fprintf(tty,"                     %2d.  %s  %s", num_choices,
X                        d_ptr->comments, d_ptr->q_name);
X        else
X         {
X           sprintf(fprinter, "%s:%s", d_ptr->q_name, d_ptr->d_name);
X           fprintf(tty,"                     %2d.  %s  %s", num_choices,
X                        d_ptr->comments, fprinter);
X         }
X
X        for(len=(strlen(d_ptr->q_name)+strlen(d_ptr->d_name)); len <= 14; len++)
X          fprintf(tty," ");
X
X        fprintf(tty,"\n");
X        num_choices++;
X        d_ptr++;
X       }
X
X    }
X   else
X    {
X      num_choices = num_printers + 1;
X
X      if((num_printers + 1) % 2)
X       {
X        for(n = 0; n < (num_printers/2); n++)
X          if(lp)
X            fprintf(tty,"%2d. %.20s %-14.14s %2d. %.20s %-14.14s\n", n+1,
X                devices[n].comments, devices[n].q_name, n+((num_printers/2)+1),
X                devices[n+(num_printers/2)].comments,
X                devices[n+(num_printers/2)].q_name);
X          else
X           {
X             sprintf(fprinter, "%s:%s", devices[n].q_name, devices[n].d_name);
X             sprintf(fprinter2, "%s:%s", devices[n+(num_printers/2)].q_name,
X                                      devices[n+(num_printers/2)].d_name);
X
X             fprintf(tty,"%2d. %.20s %-15.14s%2d. %.20s %s\n",
X                 n+1, devices[n].comments, fprinter, n+((num_printers/2)+1),
X                 devices[n+(num_printers/2)].comments, fprinter2);
X           }
X       }
X      else
X       {
X        for(n = 0; n < (num_printers/2); n++)
X          if(lp)
X             fprintf(tty,"%2d. %.20s %-14.14s %2d. %.20s %-14.14s\n",
X                 n+1, devices[n].comments, devices[n].q_name,
X                 n+((num_printers/2)+2), devices[n+(num_printers/2)+1].comments,
X                 devices[n+(num_printers/2)+1].q_name);
X          else
X           {
X              sprintf(fprinter, "%s:%s", devices[n].q_name, devices[n].d_name);
X              sprintf(fprinter2, "%s:%s", devices[n+(num_printers/2)+1].q_name,
X                                      devices[n+(num_printers/2)+1].d_name);
X              fprintf(tty,"%2d. %.20s %-15.14s%2d. %.20s %s\n",
X                  n+1, devices[n].comments, fprinter, n+((num_printers/2)+2),
X                  devices[n+(num_printers/2)+1].comments, fprinter2);
X           }
X
X          if(lp)
X              fprintf(tty,"%2d. %.20s %-14.14s\n",
X                  n+1, devices[n].comments, devices[n].q_name);
X          else
X           {
X              sprintf(fprinter, "%s:%s", devices[n].q_name, devices[n].d_name);
X              fprintf(tty,"%2d. %.20s %-15.14s\n",
X                  n+1, devices[n].comments, fprinter);
X           }
X
X       }
X    }
X
X   fprintf(tty,"\n");
X
X   if((strcmp(curr_system,sys_name->nodename)) == 0)
X    {
X#     ifdef XFER
X      if(! setcom)
X        fprintf(tty,"                     33.  Download File\n");
X#     endif
X#     ifdef EXTERN
X        fprintf(tty,"                     44.  External Printers\n");
X#     endif
X      fprintf(tty,"                     55.  Slave Printer\n");
X    }
X   if(! setcom)
X      fprintf(tty,"                     66.  View File on Terminal\n");
X   fprintf(tty,
X         "                     77.  Change Number of Copies - Currently %d\n",
X                    copies);
X#  ifdef UUCP
X      fprintf(tty,"                     88.  Print File on Another System\n");
X#  endif
X   fprintf(tty,"                     99.  Abort Without Printing\n");
X   fprintf(tty,"\n");
X   if(num_printers < 19)
X      fprintf(tty,"\n");
X   fflush(tty);
X }
X
X
X
Xvoid get_choice()
X {
X  index n = 0;
X  char  char_choice[20];
X
X   while(1)
X    {
X      fprintf(tty,"                                 ");
X      fprintf(tty,"Enter your choice: ");
X      fflush(tty);
X
X      while(((char_choice[n] = getc(stdin)) == ' ') ||
X             (char_choice[n] == '\t'));
X
X      if(! NL(char_choice[n]))
X        n++;
X
X      if NUM(char_choice[n-1])
X       {
X         char_choice[n] = getc(stdin);
X         while((NUM(char_choice[n])) && (n < 19))
X          {
X            n++;
X            char_choice[n] = getc(stdin);
X          }
X       }
X
X      while(WS(char_choice[n]))
X          char_choice[n] = getc(stdin);
X
X      if(! NL(char_choice[n]))
X       {
X          while(((c = getc(stdin)) != '\n') && (c != '\r'));
X          n = 0;
X       }
X
X      char_choice[n] = '\0';
X
X      choice = atoi(char_choice);
X
X      if((choice == 66) && (! setcom))
X       {
X         view(fileargc, fileargv);
X         return;
X       }
X#ifdef XFER
X      if((choice == 33) && (! setcom))
X       {
X         xfer_it(fileargc, fileargv);
X         return;
X       }
X#endif
X      else if(choice == 77)
X       {
X         get_copies();
X         return;
X       }
X      else if(choice == 88)
X       {
X#        ifdef UUCP
X           get_system();
X           signal(SIGINT, delfunc);
X           return;
X#        else
X           choice = 0;
X#        endif
X       }
X      else if(choice == 99)
X       {
X         fprintf(tty,"\n                          Print Request Aborted\n");
X         fclose(tty);
X         if(setcom)
X           fprintf(stdout,"abort");
X         exit(1);
X       }
X      else if(choice == 44)
X       {
X#        ifdef EXTERN
X           if((strcmp(curr_system,sys_name->nodename)) == 0)
X            {
X               show_externs();
X               break;
X            }
X           else
X             choice = 0;
X#        else
X           choice = 0;
X#        endif
X       }
X      else if(choice == 55)
X       {
X         if((strcmp(curr_system,sys_name->nodename)) == 0)
X          {
X            strcpy(term,(getenv(TERM_ENV)));
X            t_ptr = terminals;
X            while(((strcmp(term,t_ptr->term)) != 0) && (t_ptr->term[0] != '\0'))
X              t_ptr++;
X            if(t_ptr->term[0] == '\0')
X             {
X               fprintf(tty,"\nSlave Printing Denied: Unknown Terminal Type\n");
X               fflush(tty);
X               sleep(4);
X             }
X            else
X             {
X               remote_printer = TRUE;
X               no_choice_has_been_made = FALSE;
X               break;
X             }
X          }
X         else
X           choice = 0;
X       }
X
X      if((choice > 0) && (choice < num_choices))
X       {
X         no_choice_has_been_made = FALSE;
X         break;
X       }
X
X      fprintf(tty,"\n                              INVALID CHOICE");
X      fflush(tty);
X      sleep(2);
X
X      print_menu();
X      n = 0;
X    }
X }
X
X
X
X#ifdef EXTERN
X
Xvoid show_externs()
X {
X  char rtab[80];
X  index n;
X
X
X   setjmpret(ext);
X   signal(SIGINT, extdelfunc);
X
X   sprintf(rtab, "%s/rtab", RTAB_PATH);
X   fclose(config);
X   if((config = fopen(rtab,"r")) == NULL)
X    {
X      fprintf(tty,"\nExternal Printing Denied: Unable to open %s\n", rtab);
X      fflush(tty);
X      sleep(4);
X      if((config = fopen(current_config,"r")) == NULL)
X       {
X         fprintf(stderr, "%s: Print Request Aborted - Unable to open %s\n",
X                          prog_name, current_config);
X         exit(7);
X       }
X      return;
X    }
X   clear_scr();
X   load_externs();
X
X   strcpy(curr_system, "External");
X
X   no_choice_has_been_made = TRUE;
X   choice = 0;
X# ifdef UUCP
X   while((choice != 88) && (choice != 99) && (no_choice_has_been_made))
X# else
X   while((choice != 99) && (no_choice_has_been_made))
X# endif
X    {
X      print_menu();
X      get_choice();
X    }
X   if(! no_choice_has_been_made)
X    {
X      fprintf(tty, "\n\n                     Enter Address: ");
X      fflush(tty);
X      n = 0;
X      while(((address[n++] = getc(stdin)) != '\n') && (n < 127));
X      if(address[--n] != '\n')
X        while((getc(stdin)) != '\n');
X      address[n] = '\0';
X      externs = TRUE;
X      strcpy(curr_system,sys_name->nodename);
X    }
X }
X
X
X
Xvoid load_externs()
X {
X  char  ext_name[15];
X  index n;
X  bool  found_slash = FALSE;
X
X   d_ptr = devices;
X   num_printers = 0;
X
X   while(((c = getc(config)) == ' ') || (c == '\t'));
X   while(c != EOF)
X    {
X      if(c == '#')
X        ignore_line();
X      else
X       {
X         ext_name[0] = c;
X         n = 1;
X         while(((ext_name[n++] = getc(config)) != ';') && (n < 14));
X         ext_name[--n] = '\0';
X
X         while(((c = getc(config)) != '\n') && (c != EOF))
X          {
X            if(found_slash)
X             {
X               if(c == 'U')
X               {
X                 if(lp)
X                   strcpy(d_ptr->q_name, ext_name);
X                 else
X                  {
X                    strcpy(d_ptr->d_name, ext_name);
X                    strcpy(d_ptr->q_name, EXTERN_QUEUE_NAME);
X                  }
X                 ignore_line();
X                 save_comments();
X                 num_printers++;
X                 d_ptr++;
X                 found_slash = FALSE;
X                 break;
X               }
X              else
X               if(c != '\\')
X                 found_slash = FALSE;
X             }
X            else
X              if(c == '\\')
X               found_slash = TRUE;
X          }
X       }
X      if(c != EOF) /*&& ((c == ' ') || (c == '\t')))*/
X        while(((c = getc(config)) == ' ') || (c == '\t'));
X    }
X   d_ptr->q_name[0] = d_ptr->d_name[0] = '\0';
X }
X
X#endif
X
X
X
X#ifdef UUCP
X
Xvoid get_system()
X {
X  char  char_choice[6], command[20];
X  int   sys_choice;
X  short n;
X  bool  system_not_chosen = TRUE;
X  FILE  *uudata;
X
X   setjmpret(sys);
X   signal(SIGINT, sysdelfunc);
X
X   if(! systems_set)
X    {
X      sprintf(command, "%s | sort", UUNAME);
X
X      if((uudata = popen(command, "r")) == NULL)
X       {
X         fprintf(stderr,"%s: bad status from uuname\n", prog_name);
X         exit(6);
X       }
X
X      while((c = getc(uudata)) != EOF)
X       {
X         n = 0;
X         while(c != '\n')
X          {
X            systems[num_systems][n] = c;
X            n++;
X            c = getc(uudata);
X          }
X         systems[num_systems][n] = '\0';
X
X         sprintf(curr_system,"%s", systems[num_systems]);
X         sprintf(current_config,"%s/config%s", config_path, curr_system);
X
X         if((config = fopen(current_config,"r")) != NULL)
X          {
X            fclose(config);
X            num_systems++;
X          }
X
X         if(num_systems > 31)
X          break;
X       }
X      systems_set = TRUE;
X   }
X
X
X   while(system_not_chosen)
X    {
X      clear_scr();
X      fprintf(tty,"\n\n");
X      fprintf(tty,"                            System Selection Menu\n");
X      fprintf(tty,"                            ------ --------- ----\n");
X
X      if(num_systems < 9)
X       {
X          for(n = 0; n < num_systems; n++)
X            fprintf(tty, "\n                     %2d.  %s", n+1, systems[n]);
X          fprintf(tty, "\n                      ");
X          fprintf(tty,"%d.  Return to Local System Menu (%s)\n\n",num_systems+1,
X                     sys_name->nodename );
X       }
X      else
X       {
X         if((num_systems + 1) % 2)
X          {
X           for(n = 0; n < (num_systems/2); n++)
X             fprintf(tty,
X                "\n                   %2d.  %-9s           %2d.  %-9s", n+1,
X                systems[n], n+((num_systems/2)+1), systems[n+(num_systems/2)]);
X          }
X         else
X          {
X           for(n = 0; n < (num_systems/2); n++)
X            fprintf(tty, "\n                   %2d.  %-9s           %2d.  %-9s",
X                n+1, systems[n], n+((num_systems/2)+2),
X                systems[n+(num_systems/2)+1]);
X            fprintf(tty, "\n                   %2d.  %-9s",
X                ((num_systems/2)+1), systems[(num_systems/2)]);
X          }
X        fprintf(tty, "\n\n                   ");
X        fprintf(tty,"%d.  Return to Local System Menu (%s)\n\n",num_systems+1,
X            sys_name->nodename );
X      }
X
X
X      fprintf(tty,"\n                                        ");
X      fprintf(tty,"Enter your choice: ");
X      fflush(tty);
X
X      n = 0;
X      while(((char_choice[n] = getc(stdin)) == ' ') ||
X             (char_choice[n] == '\t'));
X
X      if(! NL(char_choice[n]))
X        n++;
X
X      if NUM(char_choice[n-1])
X       {
X         char_choice[n] = getc(stdin);
X         while((NUM(char_choice[n])) && (n < 19))
X          {
X            n++;
X            char_choice[n] = getc(stdin);
X          }
X       }
X
X      while(WS(char_choice[n]))
X        char_choice[n] = getc(stdin);
X
X      if(! NL(char_choice[n]))
X       {
X         while(((c = getc(stdin)) != '\n') && (c != '\r'));
X         n = 0;
X       }
X
X      char_choice[n] = '\0';
X      sys_choice = atoi(char_choice);
X
X      if((sys_choice > 0) && (sys_choice <= (num_systems+1)))
X        system_not_chosen = FALSE;
X      else
X       {
X         fprintf(tty,"\n                              INVALID CHOICE");
X         fflush(tty);
X         sleep(2);
X       }
X
X    }
X
X   if(sys_choice == (num_systems+1))
X    {
X      strcpy(curr_system,sys_name->nodename);
X      sprintf(current_config,"%s/config" ,config_path);
X    }
X  else
X    {
X      sprintf(curr_system,"%s", systems[sys_choice-1]);
X      sprintf(current_config,"%s/config%s", config_path, curr_system);
X    }
X
X   if((config = fopen(current_config,"r")) == NULL)
X    {
X      fprintf(stderr, "%s: Print Request Aborted - Unable to open %s\n",
X                       prog_name, current_config);
X      exit(7);
X    }
X }
X
X#endif
X
X
X
Xvoid view(vargc, vargv)
X int  vargc;
X char *vargv[];
X {
X  index n;
X
X   fclose(config);
X
X   for(n = 0; n < vargc; n++)
X    {
X      if((report = fopen(vargv[n],"r")) == NULL)
X       {
X         clear_scr();
X         fprintf(tty,"\n\n\n%s: Cannot open %s\n\n\n", prog_name, vargv[n]);
X       }
X      else
X       {
X         clear_scr();
X         fprintf(tty, "\n\n\n\n\nNext File: %s", vargv[n]);
X         fprintf(tty, "\n\n\n\n<RETURN> to Continue - <DEL> to Abort ");
X         fflush(tty);
X         while((getc(stdin)) != '\n');
X         show();
X         fclose(report);
X       }
X      fprintf(tty, "<RETURN> to Continue ");
X      fflush(tty);
X      while((getc(stdin)) != '\n');
X    }
X   if((config = fopen(current_config,"r")) == NULL)
X    {
X      fprintf(stderr, "%s: Print Request Aborted - Unable to open %s\n",
X                       prog_name, current_config);
X      exit(7);
X    }
X
X }
X
X
X
Xvoid show()
X {
X   short columns = 0, rows = 0;
X
X    clear_scr();
X
X    while((c = getc(report)) != EOF)
X     {
X       if(ASCII(c))
X        {
X          if(rows >= 23)
X           {
X             fprintf(tty, "<RETURN> to Continue - <DEL> to Abort ");
X             fflush(tty);
X             while((getc(stdin)) != '\n');
X             rows = columns = 0;
X           }
X          fputc(c, tty);
X          columns++;
X          if((c == '\r') || (c == '\n') || (columns >= 80))
X           {
X             columns = 0;
X             rows++;
X           }
X        }
X       else
X        if(NP(c))
X         do
X          {
X            fputc('\n', tty);
X            rows++;
X          } while(rows < 23);
X     }
X
X    while(rows < 23)
X     {
X       fputc('\n', tty);
X       rows++;
X     }
X }
X
X
X
Xvoid get_copies()
X {
X  char  cnum[3];
X  bool  get_number = TRUE;
X  short tmp_copies;
X
X  while(get_number)
X   {
X     clear_scr();
X     fprintf(tty, "\n\n\nEnter Number of Copies (1-10 default = 1) : ");
X     fflush(tty);
X
X     while(((cnum[0] = getc(stdin)) == ' ') || (cnum[0] == '\t'));
X
X     if(cnum[0] == '\n')
X      {
X        copies = 1;
X        break;
X      }
X
X     if(! NUM(cnum[0]))
X      {
X        while((cnum[0] = getc(stdin)) != '\n');
X        fprintf(tty, "\n\n\07Bad Number - Please Re-enter");
X        fflush(tty);
X        sleep(2);
X        continue;
X      }
X
X     cnum[1] = getc(stdin);
X     if(cnum[1] == '\n')
X       cnum[1] = '\0';
X     else
X      {
X       if(! NUM(cnum[1]))
X        {
X          while((cnum[0] = getc(stdin)) != '\n');
X          fprintf(tty, "\n\n\07Bad Number - Please Re-enter");
X          fflush(tty);
X          sleep(2);
X          continue;
X        }
X
X       cnum[2] = getc(stdin);
X       if(cnum[2] != '\n')
X        {
X          while((cnum[0] = getc(stdin)) != '\n');
X          fprintf(tty, "\n\n\07Bad Number - Please Re-enter");
X          fflush(tty);
X          sleep(2);
X          continue;
X        }
X       cnum[2] = '\0';
X
X      }
X
X   tmp_copies = atoi(cnum);
X   if(tmp_copies > 10)
X    {
X      fprintf(tty, "\n\n10 Copy Maximum");
X      fflush(tty);
X      sleep(2);
X      continue;
X    }
X   else
X   if(tmp_copies < 1)
X    {
X      fprintf(tty, "\n\n1 Copy Minimum");
X      fflush(tty);
X      sleep(2);
X      continue;
X    }
X   else
X    get_number = FALSE;
X
X   copies = tmp_copies;
X
X  }
X
X   if((config = fopen(current_config,"r")) == NULL)
X    {
X      fprintf(stderr, "%s: Print Request Aborted - Unable to open %s\n",
X                       prog_name, current_config);
X      exit(7);
X    }
X }
X
X
X
Xvoid delfunc()
X {
X   signal(SIGQUIT, SIG_IGN);
X   signal(SIGINT, delfunc);
X
X   fclose(config);
X   if((config = fopen(current_config, "r")) == NULL)
X    {
X      fprintf(stderr, "%s: Print Request Aborted - Unable to open %s\n",
X                       prog_name, current_config);
X      exit(7);
X    }
X
X   longjmpret(print, 1);
X }
X
X
X
Xvoid sysdelfunc()
X {
X   signal(SIGINT, sysdelfunc);
X   signal(SIGQUIT, SIG_IGN);
X   longjmpret(sys, 1);
X }
X
X
X
X#ifdef EXTERN
X
Xvoid extdelfunc()
X {
X   signal(SIGINT, extdelfunc);
X   signal(SIGQUIT, SIG_IGN);
X   longjmpret(ext, 1);
X }
X
X#endif
X
X
Xvoid printjob(pjargc, pjargv)
X int  pjargc;
X char *pjargv[];
X {
X  char  command[BUFSIZ], files[BUFSIZ-50], flags[138];
X  bool  file_found = FALSE, found_at_least_one = FALSE;
X  index n;
X
X
X   files[0] = '\0';
X   for(n = 0; n < pjargc; n++)
X    {
X      if(! setcom)
X       {
X         if((report = fopen(pjargv[n],"r")) == NULL)
X          {
X            fprintf(stderr,"%s: Cannot open %s\n", prog_name, pjargv[n]);
X            exit_status = 2;
X            file_found = FALSE;
X          }
X         else
X          {
X            fclose(report);
X            found_at_least_one = TRUE;
X            file_found = TRUE;
X            exit_status = 0;
X          }
X       }
X
X      if((file_found) || (setcom))
X        sprintf(files, "%s %s", files, pjargv[n]);
X      else
X        pjargv[n][0] = '\0';
X    }
X
X   flags[0] = '\0';
X   if((found_at_least_one) || (setcom))
X    {
X      if(remote_printer)
X       {
X         if((setcom) && (pjargc == 0))
X         {
X         proc_id = getpid();
X
X         sprintf(command, 
X          "cat > /tmp/ispi%d << \\EOF%c#!/bin/sh%c cat > /tmp/$$.pr%c echo \"%s\"%c copeez=%d%c while [ $copeez -ge 1 ]%c do%c cat /tmp/$$.pr%c copeez=`expr $copeez - 1`%c done%c echo \"%s\"%c rm /tmp/$$.pr%c exit%cEOF%c chmod 755 /tmp/ispi%d%c%c",
X          proc_id, '\n', '\n', '\n', t_ptr->on, '\n', copies, '\n', '\n', '\n', '\n', '\n', '\n', t_ptr->off, '\n', '\n', '\n', '\n', proc_id, '\n', '\0');
X
X         system(command);
X         sprintf(command,"/tmp/ispi%d", proc_id);
X
X         }
X         else
X         {
X
X          sprintf(command,
X           "sh -c \'echo \"%s\"%c copeez=%d%c while [ $copeez -ge 1 ]%c do%c cat %s%c copeez=`expr $copeez - 1`%c done%c echo \"%s\"%c exit%c%c\'",
X           t_ptr->on, '\n', copies, '\n', '\n', '\n', files, '\n', '\n', '\n', t_ptr->off, '\n', '\n', '\0');
X
X         }
X
X
X       }
X
X      else if((strcmp(curr_system,sys_name->nodename)) == 0)
X       {
X         if(copy)
X          strcat(flags, "-c ");
X         if(mail)
X          strcat(flags, "-m ");
X
X         if(lp)
X          {
X            if(banner)
X              strcat(flags, "-tt");
X#           ifdef EXTERN
X            if(externs)
X              sprintf(flags, "%s -o\"%s\"", flags, address);
X#           endif
X            sprintf(command,"lp %s -n%d -s -d%s %s",
X                            flags, copies, printer, files);
X          }
X         else
X          {
X            if(! banner)
X              strcat(flags, "-nb");
X#           ifdef EXTERN
X            if(externs)
X              sprintf(flags, "%s -d \"%s\"", flags, address);
X#           endif
X            sprintf(command,"nq %s -t %d -q %s %s",
X                           flags, copies, printer, files);
X          }
X       }
X#    ifdef UUCP
X      else
X       {
X         if(mail)
X          strcat(flags, "-m ");
X         if(banner && lp)
X          strcat(flags, "-tt");
X         else if((! banner) && (! lp))
X          strcat(flags, "-nb");
X
X         command[0] = '\0';
X         if((pjargc == 0) && (setcom))
X          {
X            if(lp)
X              sprintf(command,"%s - %s\\! lp %s -c -n%d -s -d%s",
X                    UUX, curr_system, flags, copies, printer);
X            else
X              sprintf(command,"%s - %s\\! nq %s -c -t %d -q %s",
X                    UUX, curr_system, flags, copies, printer);
X          }
X         else for(n = 0; n < pjargc; n++)
X          {
X           if(pjargv[n][0] != '\0')
X            {
X             if(lp)
X               sprintf(command,"%scat %s | %s - %s\\! lp %s -c -n%d -s -d%s ; ",
X                 command, pjargv[n], UUX, curr_system, flags, copies, printer);
X             else
X               sprintf(command,"%scat %s | %s - %s\\! nq %s -c -t %d -q %s ; ",
X                 command, pjargv[n], UUX, curr_system, flags, copies, printer);
X            }
X          }
X       }
X#     endif
X    }
X
X    if(setcom)
X      fprintf(stdout,"%s",command);
X    else if(found_at_least_one)
X      exit_status = system(command);
X    else
X      exit_status = 2;
X }
X
X#ifdef XFER
Xvoid xfer_it(vargc, vargv)
X int  vargc;
X char *vargv[];
X {
X  index n;
X  char sistum[BUFSIZ];
X
X   fclose(config);
X
X   for(n = 0; n < vargc; n++)
X    {
X      if((report = fopen(vargv[n],"r")) == NULL)
X       {
X         clear_scr();
X         fprintf(tty,"\n\n\n%s: Cannot open %s\n\n\n", prog_name, vargv[n]);
X       }
X      else
X       {
X         clear_scr();
X         sprintf(sistum, "%s %s", xfer_cmd, vargv[n]);
X         fprintf(tty, "\n\n\n\n\n%s", sistum);
X         fprintf(tty, "\n\n\nABORT this routine if you are ");
X         fprintf(tty, "not prepared to start the receiving process.");
X         fprintf(tty, "\n\n\n\n<RETURN> to Begin - <DEL> to Abort ");
X         fflush(tty);
X         while((getc(stdin)) != '\n');
X         sleep(10);
X         system(sistum);
X         fclose(report);
X       }
X      fprintf(tty, "<RETURN> to Continue ");
X      fflush(tty);
X      while((getc(stdin)) != '\n');
X    }
X   if((config = fopen(current_config,"r")) == NULL)
X    {
X      fprintf(stderr, "%s: Print Request Aborted - Unable to open %s\n",
X                       prog_name, current_config);
X      exit(7);
X    }
X
X }
X#endif
END_OF_FILE
if test 43525 -ne `wc -c <'ISPI/ispi.c'`; then
    echo shar: \"'ISPI/ispi.c'\" unpacked with wrong size!
fi
# end of 'ISPI/ispi.c'
fi
if test -f 'ISPI/UUSTUFF.dr/SYS_III.dr/uustart.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPI/UUSTUFF.dr/SYS_III.dr/uustart.c'\"
else
echo shar: Extracting \"'ISPI/UUSTUFF.dr/SYS_III.dr/uustart.c'\" \(4318 characters\)
sed "s/^X//" >'ISPI/UUSTUFF.dr/SYS_III.dr/uustart.c' <<'END_OF_FILE'
X/*  UUSTART								*/
X/*		THIS IS UUSTART FOR THE MODEL 31 ZILOG			*/
X/*		This program is designed to invoke uucico on a more	*/
X/*	regular basis than would be possible via cron.                  */
X/*									*/
X/*	The program copies itself into a child process and runs		*/
X/*	continuously without tying up the user's terminal.  The		*/
X/*	program starts uucico at the requested interval.                */
X/*									*/
X/*      This timing and invocation routine is adapted from "monitor"	*/
X/*      which was written by:						*/
X/*									*/
X/*	       	John Withers						*/
X/*		IRS (Springfield District)				*/
X/*		Phone:	FTS 955-4842					*/
X/*									*/
X/*									*/
X/*      UUSTART was written by:						*/
X/*		Larry Bartz                                             */
X/*		IRS (Indianapolis District)                             */
X/*		Phone: FTS 331-6796                                     */
X/*									*/
X/*	Date:	December 30, 1986					*/
X/*									*/
X/*									*/
X
X#include <stdio.h>
X#include <time.h>
X#include <ssignal.h>
X
X/*  User adjustable constants for "uustart.c"				  */
X
X/* Define the execution window, STIME to ETIME on DAY1 through DAY2	  */
X
X#define STIME 25200	/* Daily starting time 6:00 AM (sec past midnight)*/
X#define ETIME 64800	/* Daily ending time 7:00 PM (sec past midnight)  */
X#define DAY1  0		/* Starting day of the week, (Sun = 0)		  */
X#define DAY2  6		/* Ending day of the week (Sun = 0)		  */
X
X/* Define the interval between samples					  */
X
X#define INTV  120	/* Interval between invocations [2 min](in seconds)*/
X
X
Xmain()
X
X{
X
X
X  int pid,
X      status,
X      child,
X      parent,
X      fork();
X
X  long last_time,
X       curtime,
X       stop();
X
X/* On with the show							*/
X
X  signal(SIGHUP, SIG_IGN);	/* Ignore 'Hang-up' signals		*/
X  signal(SIGINT, SIG_IGN);	/* Ignore 'Interrupt' signals		*/
X  signal(SIGQUIT,SIG_IGN);	/* Ignore 'Quit' signals		*/
X
X  switch (pid = fork())		/* Switch to child process		*/
X  {
X	case 0:			/* In child process, all ok		*/
X		break;
X
X	case -1:		/* In parent process with error		*/
X		sysmsg("uustart: fork failed");
X		exit(1);
X
X	default:		/* In parent process, all ok		*/
X		exit(0);
X  }
X
X  last_time = stop(INTV);	/* Wait until on interval get time	*/
X
X
X  for(;;)
X  {
X	curtime = stop(INTV);	/* Wait for interval, get current time	*/
X
X	last_time = curtime;
X
X	if (checktime(curtime) == 0) continue;
X
X	switch(child = fork())
X	{
X		case -1:
X			sysmsg("uustart - fork failed");
X			break;
X
X		case 0:		/* Child process			*/
X			execlp("/usr/lib/uucp/uucico","uucico","-r1",NULL);
X			sysmsg("uustart - exec failed");
X			break;
X
X		default:
X			parent = wait(&status);
X			break;
X	}
X  }
X}
X
X/*  STOP								*/
X/*	This function stops the current process until the next even	*/
X/*	'interval' (e.g. next quarter hour).  The function returns	*/
X/*	the current system time as its functional value			*/
X
Xlong stop(interval)
X
Xint interval;
X
X{
X  int intrtn();
X
X  unsigned length;
X
X  long now, time();
X
X  now = time((long *) 0);
X
X  length = ((now / interval) + 1) * interval - now;
X
X  signal(SIGALRM, intrtn);
X  alarm(length);
X  pause();
X  return(time((long *) 0));
X}
X
X/* INTRTN								*/
X/*  This function is present to allow for alarm clock signal trapping	*/
Xintrtn()
X{return;}
X
Xint checktime(when)
X
Xlong when;
X
X{
X  extern long timezone;		/* Seconds adjustment for time zone	*/
X
X  extern int  daylight;		/* TRUE if daylight savings time	*/
X
X  int wday,
X      flag = 1;
X
X  long now;
X
X  tzset();			/* Set the time zone adjustment		*/
X
X  when -= timezone;		/* Adjust for local time		*/
X
X  if (daylight) when += 3600;	/* Adjust for daylight saving time	*/
X
X  now = when % 86400;		/* Seconds since midnight		*/
X
X  if (now < (STIME + INTV) || now > ETIME) flag = 0;
X
X  wday = ((when / 86400) + 4) % 7;
X
X  if (wday < DAY1 || wday > DAY2) flag = 0;
X
X  return(flag);
X}
X
Xsysmsg(msg)
X
Xchar *msg;
X
X{
X  extern int 	errno,
X		deverr,
X		sys_nerr;
X
X  extern char	*sys_errlist[];
X
X  struct tm *x, *localtime();
X
X  long now, time();
X
X  now = time((long *) 0);
X
X  x = localtime(&now);
X
X  fprintf(stderr,"%02d/%02d/%02d %02d:%02d:%02d - ",
X	x->tm_mon+1, x->tm_mday, x->tm_year, x->tm_hour, x->tm_min, x->tm_sec);
X
X  fprintf(stderr,msg);
X
X  if (errno <= sys_nerr)
X	fprintf(stderr, " (%s)\n", sys_errlist[errno]);
X  else
X	fprintf(stderr, " (Error %d)\n", errno);
X
X  fflush(stderr);
X}
END_OF_FILE
if test 4318 -ne `wc -c <'ISPI/UUSTUFF.dr/SYS_III.dr/uustart.c'`; then
    echo shar: \"'ISPI/UUSTUFF.dr/SYS_III.dr/uustart.c'\" unpacked with wrong size!
fi
chmod +x 'ISPI/UUSTUFF.dr/SYS_III.dr/uustart.c'
# end of 'ISPI/UUSTUFF.dr/SYS_III.dr/uustart.c'
fi
if test -f 'ISPI/UUSTUFF.dr/SYS_V.dr/uustart.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPI/UUSTUFF.dr/SYS_V.dr/uustart.c'\"
else
echo shar: Extracting \"'ISPI/UUSTUFF.dr/SYS_V.dr/uustart.c'\" \(5192 characters\)
sed "s/^X//" >'ISPI/UUSTUFF.dr/SYS_V.dr/uustart.c' <<'END_OF_FILE'
X/*  UUSTART								*/
X/*		This program is designed to invoke uucico on a more	*/
X/*	regular basis than would be possible via cron.                  */
X/*									*/
X/*	The program copies itself into a child process and runs		*/
X/*	continuously without tying up the user's terminal.  The		*/
X/*	program starts uucico at the requested interval.                */
X/*									*/
X/*      This timing and invocation routine is adapted from "monitor"	*/
X/*      which was written by:						*/
X/*									*/
X/*	       	John Withers						*/
X/*		IRS (Springfield District)				*/
X/*		Phone:	FTS 955-4842					*/
X/*									*/
X/*									*/
X/*      UUSTART was written by:						*/
X/*		Larry Bartz                                             */
X/*		IRS (Indianapolis District)                             */
X/*		Phone: FTS 331-6796                                     */
X/*									*/
X/*	Date:	December 30, 1986					*/
X/*									*/
X/*									*/
X/*									*/
X/*	MODIFICATION:							*/
X/*									*/
X/*		This version calls a C-shell script "uuscout.csh"       */
X/*		instead of invoking uucico directly. This is necc-	*/
X/*		essary in System V UNIX because uucico will not		*/
X/*		execute without the "-ssys" specification. Version	*/
X/*		III (ZEUS) UNIX's uucico permitted a "-r1" invok-	*/
X/*		ation without "-ssys", in which case only those		*/
X/*		systems for which work was queued would be called.	*/
X/*		We don't want to waste time and system resources	*/
X/*		calling systems for which no work is queued, so		*/
X/*		we employ uuscout.csh to determine for which sys-	*/
X/*		tems work is queued and then invoke uucico only		*/
X/*		for them.						*/
X/*									*/
X/*		Larry Bartz                                             */
X/*		IRS (Indianapolis District)                             */
X/*		Phone: FTS 331-6796                                     */
X/*									*/
X/*	Date:	February 19, 1987					*/
X/*									*/
X
X#include <stdio.h>
X#include <time.h>
X#include <signal.h>
X
X/*  User adjustable constants for "uustart.c"				  */
X
X/* Define the execution window, STIME to ETIME on DAY1 through DAY2	  */
X
X#define STIME 25200	/* Daily starting time 6:00 AM (sec past midnight)*/
X#define ETIME 64800	/* Daily ending time 7:00 PM (sec past midnight)  */
X#define DAY1  0		/* Starting day of the week, (Sun = 0)		  */
X#define DAY2  6		/* Ending day of the week (Sun = 0)		  */
X
X/* Define the interval between samples					  */
X
X#define INTV  120	/* Interval between invocations [2 min](in seconds)*/
X
X
Xmain()
X
X{
X
X
X  int pid,
X      status,
X      child,
X      parent,
X      fork();
X
X  long last_time,
X       curtime,
X       stop();
X
X/* On with the show							*/
X
X  signal(SIGHUP, SIG_IGN);	/* Ignore 'Hang-up' signals		*/
X  signal(SIGINT, SIG_IGN);	/* Ignore 'Interrupt' signals		*/
X  signal(SIGQUIT,SIG_IGN);	/* Ignore 'Quit' signals		*/
X
X  switch (pid = fork())		/* Switch to child process		*/
X  {
X	case 0:			/* In child process, all ok		*/
X		break;
X
X	case -1:		/* In parent process with error		*/
X		sysmsg("uustart: fork failed");
X		exit(1);
X
X	default:		/* In parent process, all ok		*/
X		exit(0);
X  }
X
X  last_time = stop(INTV);	/* Wait until on interval get time	*/
X
X
X  for(;;)
X  {
X	curtime = stop(INTV);	/* Wait for interval, get current time	*/
X
X	last_time = curtime;
X
X	if (checktime(curtime) == 0) continue;
X
X	switch(child = fork())
X	{
X		case -1:
X			sysmsg("uustart - fork failed");
X			break;
X
X		case 0:		/* Child process			*/
X			system("/usr/lib/uucp/uuscout.csh");
X			exit(0);
X
X		default:
X			parent = wait(&status);
X			break;
X	}
X  }
X}
X
X/*  STOP								*/
X/*	This function stops the current process until the next even	*/
X/*	'interval' (e.g. next quarter hour).  The function returns	*/
X/*	the current system time as its functional value			*/
X
Xlong stop(interval)
X
Xint interval;
X
X{
X  int intrtn();
X
X  unsigned length;
X
X  long now, time();
X
X  now = time((long *) 0);
X
X  length = ((now / interval) + 1) * interval - now;
X
X  signal(SIGALRM, intrtn);
X  alarm(length);
X  pause();
X  return(time((long *) 0));
X}
X
X/* INTRTN								*/
X/*  This function is present to allow for alarm clock signal trapping	*/
Xintrtn()
X{return;}
X
Xint checktime(when)
X
Xlong when;
X
X{
X  extern long timezone;		/* Seconds adjustment for time zone	*/
X
X  extern int  daylight;		/* TRUE if daylight savings time	*/
X
X  int wday,
X      flag = 1;
X
X  long now;
X
X  tzset();			/* Set the time zone adjustment		*/
X
X  when -= timezone;		/* Adjust for local time		*/
X
X  if (daylight) when += 3600;	/* Adjust for daylight saving time	*/
X
X  now = when % 86400;		/* Seconds since midnight		*/
X
X  if (now < (STIME + INTV) || now > ETIME) flag = 0;
X
X  wday = ((when / 86400) + 4) % 7;
X
X  if (wday < DAY1 || wday > DAY2) flag = 0;
X
X  return(flag);
X}
X
Xsysmsg(msg)
X
Xchar *msg;
X
X{
X  extern int 	errno,
X		deverr,
X		sys_nerr;
X
X  extern char	*sys_errlist[];
X
X  struct tm *x, *localtime();
X
X  long now, time();
X
X  now = time((long *) 0);
X
X  x = localtime(&now);
X
X  fprintf(stderr,"%02d/%02d/%02d %02d:%02d:%02d - ",
X	x->tm_mon+1, x->tm_mday, x->tm_year, x->tm_hour, x->tm_min, x->tm_sec);
X
X  fprintf(stderr,msg);
X
X  if (errno <= sys_nerr)
X	fprintf(stderr, " (%s)\n", sys_errlist[errno]);
X  else
X	fprintf(stderr, " (Error %d)\n", errno);
X
X  fflush(stderr);
X}
END_OF_FILE
if test 5192 -ne `wc -c <'ISPI/UUSTUFF.dr/SYS_V.dr/uustart.c'`; then
    echo shar: \"'ISPI/UUSTUFF.dr/SYS_V.dr/uustart.c'\" unpacked with wrong size!
fi
chmod +x 'ISPI/UUSTUFF.dr/SYS_V.dr/uustart.c'
# end of 'ISPI/UUSTUFF.dr/SYS_V.dr/uustart.c'
fi
echo shar: End of archive 2 \(of 15\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

