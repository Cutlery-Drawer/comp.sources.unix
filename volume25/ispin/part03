Newsgroups: comp.sources.unix
From: sir-alan!ispin!lbartz@iuvax.cs.indiana.edu (Larry Bartz)
Subject: v25i114: Indianapolis Standard Printer Interface for Networked printers, Part03/15
Sender: sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: sir-alan!ispin!lbartz@iuvax.cs.indiana.edu (Larry Bartz)
Posting-Number: Volume 25, Issue 114
Archive-Name: ispin/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 15)."
# Contents:  ISPI/COPY+WARR.doc ISPIN/h/common.h ISPIN/h/iqueuer.h
#   ISPIN/h/ispin.h
#   ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/C351_PLAIN
#   ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/QUME_SHT
#   ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/PLAIN
#   ISPIN/install/lib_rtab/CPU_PTR/PLAIN
# Wrapped by socrates@indy6 on Tue Jan 28 15:26:29 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ISPI/COPY+WARR.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPI/COPY+WARR.doc'\"
else
echo shar: Extracting \"'ISPI/COPY+WARR.doc'\" \(9934 characters\)
sed "s/^X//" >'ISPI/COPY+WARR.doc' <<'END_OF_FILE'
X
X
X		    GNU GENERAL PUBLIC LICENSE
X		     Version 1, February 1989
X
X Copyright (C) 1989 Free Software Foundation, Inc.
X                    675 Mass Ave, Cambridge, MA 02139, USA
X Everyone is permitted to copy and distribute verbatim copies
X of this license document, but changing it is not allowed.
X
X			    Preamble
X
X  The license agreements of most software companies try to keep users
Xat the mercy of those companies.  By contrast, our General Public
XLicense is intended to guarantee your freedom to share and change free
Xsoftware--to make sure the software is free for all its users.  The
XGeneral Public License applies to the Free Software Foundation's
Xsoftware and to any other program whose authors commit to using it.
XYou can use it for your programs, too.
X
X  When we speak of free software, we are referring to freedom, not
Xprice.  Specifically, the General Public License is designed to make
Xsure that you have the freedom to give away or sell copies of free
Xsoftware, that you receive source code or can get it if you want it,
Xthat you can change the software or use pieces of it in new free
Xprograms; and that you know you can do these things.
X
X  To protect your rights, we need to make restrictions that forbid
Xanyone to deny you these rights or to ask you to surrender the rights.
XThese restrictions translate to certain responsibilities for you if you
Xdistribute copies of the software, or if you modify it.
X
X  For example, if you distribute copies of a such a program, whether
Xgratis or for a fee, you must give the recipients all the rights that
Xyou have.  You must make sure that they, too, receive or can get the
Xsource code.  And you must tell them their rights.
X
X  We protect your rights with two steps: (1) copyright the software, and
X(2) offer you this license which gives you legal permission to copy,
Xdistribute and/or modify the software.
X
X  Also, for each author's protection and ours, we want to make certain
Xthat everyone understands that there is no warranty for this free
Xsoftware.  If the software is modified by someone else and passed on, we
Xwant its recipients to know that what they have is not the original, so
Xthat any problems introduced by others will not reflect on the original
Xauthors' reputations.
X
X  The precise terms and conditions for copying, distribution and
Xmodification follow.
X
X		    GNU GENERAL PUBLIC LICENSE
X   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X
X  0. This License Agreement applies to any program or other work which
Xcontains a notice placed by the copyright holder saying it may be
Xdistributed under the terms of this General Public License.  The
X"Program", below, refers to any such program or work, and a "work based
Xon the Program" means either the Program or any work containing the
XProgram or a portion of it, either verbatim or with modifications.  Each
Xlicensee is addressed as "you".
X
X  1. You may copy and distribute verbatim copies of the Program's source
Xcode as you receive it, in any medium, provided that you conspicuously and
Xappropriately publish on each copy an appropriate copyright notice and
Xdisclaimer of warranty; keep intact all the notices that refer to this
XGeneral Public License and to the absence of any warranty; and give any
Xother recipients of the Program a copy of this General Public License
Xalong with the Program.  You may charge a fee for the physical act of
Xtransferring a copy.
X
X  2. You may modify your copy or copies of the Program or any portion of
Xit, and copy and distribute such modifications under the terms of Paragraph
X1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating that
X    you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish, that
X    in whole or in part contains the Program or any part thereof, either
X    with or without modifications, to be licensed at no charge to all
X    third parties under the terms of this General Public License (except
X    that you may choose to grant warranty protection to some or all
X    third parties, at your option).
X
X    c) If the modified program normally reads commands interactively when
X    run, you must cause it, when started running for such interactive use
X    in the simplest and most usual way, to print or display an
X    announcement including an appropriate copyright notice and a notice
X    that there is no warranty (or else, saying that you provide a
X    warranty) and that users may redistribute the program under these
X    conditions, and telling the user how to view a copy of this General
X    Public License.
X
X    d) You may charge a fee for the physical act of transferring a
X    copy, and you may at your option offer warranty protection in
X    exchange for a fee.
X
XMere aggregation of another independent work with the Program (or its
Xderivative) on a volume of a storage or distribution medium does not bring
Xthe other work under the scope of these terms.
X
X  3. You may copy and distribute the Program (or a portion or derivative of
Xit, under Paragraph 2) in object code or executable form under the terms of
XParagraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal charge
X    for the cost of distribution) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
XSource code for a work means the preferred form of the work for making
Xmodifications to it.  For an executable file, complete source code means
Xall the source code for all modules it contains; but, as a special
Xexception, it need not include source code for modules which are standard
Xlibraries that accompany the operating system on which the executable
Xfile runs, or for standard header files or definitions files that
Xaccompany that operating system.
X
X  4. You may not copy, modify, sublicense, distribute or transfer the
XProgram except as expressly provided under this General Public License.
XAny attempt otherwise to copy, modify, sublicense, distribute or transfer
Xthe Program is void, and will automatically terminate your rights to use
Xthe Program under this License.  However, parties who have received
Xcopies, or rights to use copies, from you under this General Public
XLicense will not have their licenses terminated so long as such parties
Xremain in full compliance.
X
X  5. By copying, distributing or modifying the Program (or any work based
Xon the Program) you indicate your acceptance of this license to do so,
Xand all its terms and conditions.
X
X  6. Each time you redistribute the Program (or any work based on the
XProgram), the recipient automatically receives a license from the original
Xlicensor to copy, distribute or modify the Program subject to these
Xterms and conditions.  You may not impose any further restrictions on the
Xrecipients' exercise of the rights granted herein.
X
X  7. The Free Software Foundation may publish revised and/or new versions
Xof the General Public License from time to time.  Such new versions will
Xbe similar in spirit to the present version, but may differ in detail to
Xaddress new problems or concerns.
X
XEach version is given a distinguishing version number.  If the Program
Xspecifies a version number of the license which applies to it and "any
Xlater version", you have the option of following the terms and conditions
Xeither of that version or of any later version published by the Free
XSoftware Foundation.  If the Program does not specify a version number of
Xthe license, you may choose any version ever published by the Free Software
XFoundation.
X
X  8. If you wish to incorporate parts of the Program into other free
Xprograms whose distribution conditions are different, write to the author
Xto ask for permission.  For software which is copyrighted by the Free
XSoftware Foundation, write to the Free Software Foundation; we sometimes
Xmake exceptions for this.  Our decision will be guided by the two goals
Xof preserving the free status of all derivatives of our free software and
Xof promoting the sharing and reuse of software generally.
X
X			    NO WARRANTY
X
X  9. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
XFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
XOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
XPROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
XOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
XMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
XTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
XPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
XREPAIR OR CORRECTION.
X
X  10. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
XWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
XREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
XINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
XOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
XTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
XYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
XPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
XPOSSIBILITY OF SUCH DAMAGES.
X
X		     END OF TERMS AND CONDITIONS
X
END_OF_FILE
if test 9934 -ne `wc -c <'ISPI/COPY+WARR.doc'`; then
    echo shar: \"'ISPI/COPY+WARR.doc'\" unpacked with wrong size!
fi
# end of 'ISPI/COPY+WARR.doc'
fi
if test -f 'ISPIN/h/common.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/h/common.h'\"
else
echo shar: Extracting \"'ISPIN/h/common.h'\" \(16935 characters\)
sed "s/^X//" >'ISPIN/h/common.h' <<'END_OF_FILE'
X/****************************************************************************/
X/*                                                                          */
X/* 1988, SOWSEAR ENGINEERING, SOFTWARE GROUP    Indianapolis, IN            */
X/*                                                                          */
X/*               our motto: "Who says you can't...?"                        */
X/*                                                                          */
X/****************************************************************************/
X/* COMMON.H                                                                 */
X/*                                                                          */
X/* This is the header file which is shared by ISPIN, IQUEUER, and IQ.       */
X/* Any defines, includes, or variables which may be peculiar to a           */
X/* particular program is in ispin.h, iqueuer.h, or iq.h, resectively.       */
X/*                                                                          */
X/* ISPIN                                                                    */
X/*                                                                          */
X/* Indianapolis Standard Printer Interface (for Network printers)           */
X/****************************************************************************/
X/*                                                                          */
X/* COMMENTS                                                                 */
X/*                                                                          */
X/* This program services printers which are not directly connected to       */
X/* the cpu, but which are accessible from the cpu via network facilities.   */
X/* ISPIN is conditionally compiled to support either one of two spooler/    */
X/* queuer environments. ISPIN is able to provide this service by capital-   */
X/* -izing upon the spooler/queuer facilities which are native to the        */
X/* system. Each of these native spooler/queuers was designed to permit the  */
X/* user (System Administrator and/or system programmer) the ability to      */
X/* create and implement customized programs ("backend" for NQ, "interface"  */
X/* for LP) such as this. Check the documentation. It's all there.           */
X/* It's no big deal.                                                        */
X/*                                                                          */
X/* NQ is for the older, System III Zilogs of which IRS had approximately    */
X/* 500 in service. These machines run under Zilog's ZEUS 3.21 UNIX. The     */
X/* spooler/queuer is comprised of the family nq(1), xq(1), dqueuer(M).      */
X/* In this environment, ISPIN will function as the "backend" program, so    */
X/* must be so specified in the /usr/spool/queuer/config file.               */
X/*                                                                          */
X/* LP is for the System V UNIX spooler, as implemented by AT&T and those    */
X/* which are similarly implemented. In this environment, ISPIN will         */
X/* function as the "interface" program.                                     */
X/*                                                                          */
X/* EXTERNAL ENTITIES                                                        */
X/*                                                                          */
X/* In addition to the native queueing system and its utilities, ISPIN       */
X/* depends on the existence and functionality of four entities which        */
X/* are external to ISPIN but which exist solely to support ISPIN.           */
X/*                                                                          */
X/*   RTAB - The first such entity is an ascii file which is a table of data */
X/* which is required to contact the remote printer. Each remote printer     */
X/* which is supported will have an entry in this table. The construction    */
X/* and usage of this table is roughly analogous to uucp's L.sys file (or    */
X/* the Systems file under HoneyDanBer uucp). See further comments in the    */
X/* quoted-out comments of the rtab file supplied with this release.         */
X/*                                                                          */
X/*   IQUEUER - The second of the external entities is the daemon IQUEUER.   */
X/* The sole function of IQUEUER is to manage a fair FIFO competition        */
X/* among multiple simultaneous invocations of ISPIN which may compete with  */
X/* each other for access to a cpu port. IQUEUER has no control over the     */
X/* life or death of the process ISPIN. Such control remains the exclusive   */
X/* domain of the native queuer.                                             */
X/*   This method (a secondary queuer) was chosen over the relatively        */
X/* arcane method of using LOCKFILEs for several reasons. LOCKFILE-controlled*/
X/* resource management naturally results in randomly sequenced servicing    */
X/* of those processes which are competing for resources. Under a LOCKFILE   */
X/* regime, there is no queueing. Race conditions and/or wasteful looping    */
X/* and checking determine access sequence. Also, LOCKFILEs may be aban-     */
X/* doned by dead processes (dead because they bombed, or were killed, or    */
X/* because the system crashed). Abandoned LOCKFILEs generally require the   */
X/* intervention of the Systems Administrator, who must expunge them in      */
X/* order to return the system to functionality.                             */
X/*                                                                          */
X/*   PIPES - ISPIN and IQUEUER communicate via named pipes. This communi-   */
X/* cation method is more robust than SIGNAL communication while being       */
X/* more efficient than communication which relies upon intermediate         */
X/* status files. The "blocking read" permitted under this approach allows   */
X/* ISPIN and IQUEUER to merely sleep while waiting for work orders, as      */
X/* opposed to wasteful looping and checking of an intermediate status file  */
X/* to see whether there is work to be done.                                 */
X/*                                                                          */
X/*   IQ - the status enquirer. This program is a command to be executed by  */
X/* those users who wish to know the current status of requests which have   */
X/* been released by the native queuer but are now being monitored and/or    */
X/* queued by IQUEUER. All such jobs will be shown as "running" or "now      */
X/* printing" by the native queuer, since (as far as the native queuer knows)*/
X/* once the backend (NQ) or interface (LP) program has been invoked, the    */
X/* request is being satisfied. IQ exercises no control whatsoever over the  */
X/* IQUEUER, the ISPIN, or the native queuer. Again, all control over the    */
X/* backend/interface (ISPIN) is retained by the native queuer and its       */
X/* utilities.                                                               */
X/*                                                                          */
X/*                                                                          */
X/* CHOICES                                                                  */
X/*                                                                          */
X/* We have chosen not to support certain "features" of the NQ/DQUEUER       */
X/* environment. These include, reporting print job progress to the status   */
X/* file (STATUSFD), and ignoring the restart and backup commands of the     */
X/* xq command. We have many good reasons for this, but system performance   */
X/* and robustness of the backend are paramount.                             */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DEFINES                                                                  */
X/*                                                                          */
X/* Which spooler are we compiling for?                                      */
X/* Define one or the other, never both.                                     */
X/*                                                                          */
X/* If we want to compile for NQ, we'll define it in the compile line.       */
X/*                                                                          */
X/* #define NQ                                                               */
X/* or #define LP                                                            */
X#ifndef NQ
X#define LP
X#endif
X/*                                                                          */
X/*  NQ is for the older System III Zilogs, which use nq, xq, and dqueuer.   */
X/*  LP is for System V lp spoolers.                                         */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X#define SUCCESS 0
X/*                                                                          */
X/* Flags for use with notify() function                                     */
X#define HERE 1
X#define WORKING 2
X#define DONE 3
X#define TROUBLE 4
X#define WAIT 5
X#define GO 6
X#define BUSY 7
X#define STATUS 8
X/* status, or current state of the ISPIN                                    */
X#define STARTUP 22
X#define CONNECTING 33
X#define PRINTING 44
X#define LOOPING 55
X#define WAITING 66
X#define DISCONNECTING 77
X#define QUITTING 88
X#define NET_TIME 90
X#define TIMEOUT 99
X/* error types for use with my_error() function                             */
X/* keep these less than 127, or lpsched will have a fit!                    */
X#define NO_EXIT 115
X#define NONOTIFY 116
X#define MYERR 117
X#define SYSERR 118
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* INCLUDES                                                                 */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/* Same for everybody.                                                      */
X#include <stdio.h>
X#include <ctype.h>
X#include <time.h>
X#include <fcntl.h>
X#include <errno.h>
X#include <pwd.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X/*                                                                          */
X/*                                                                          */
X/* Some conditional includes, assuming Zeus 3.21 for NQ                     */
X/* and System V UNIX for LP.                                                */
X/*                                                                          */
X#ifdef NQ
X#include <ssignal.h>
X#include "../h/nqspool.h"
X#else
X#include <signal.h>
X#include <string.h>
X#include <malloc.h>
X#endif
X/*                                                                          */
X/* Allow for local configuration adjustments                                */
X/*                                                                          */
X#include "../h/localcnfg.h"
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DATA TYPES, VARIABLES, ETC                                               */
X/*                                                                          */
X/*                                                                          */
XFILE *fopen(),
X     *logfile;    /* the error file stream            */
X
X
X/* a union used to treat integers as arrays of characters                   */
Xunion chr_int
X{
X  char chr[sizeof(int)];
X  int  intgr;
X};
X
Xint intsize;
Xintsize = sizeof(int);
X
X/* a union used to treat longs as arrays of characters                      */
Xunion chr_lng
X{
X  char chr[sizeof(long)];
X  long lng;
X};
X
Xint longsize;
Xlongsize = sizeof(long);
X
X/* for use with reads: how many characters did we get?                      */
Xint chars_got;
X/*                                                                          */
X
Xchar errmsg[BUFSIZ];     /* a place to format an error msg */
Xchar errmsg2[BUFSIZ];     /* a place to format an error msg */
Xchar msg_buf[BUFSIZ];    /* a place to format msg between procs via FIFOs */
X
Xlong tloc;
Xchar *time_str;
Xchar *asctime();
Xstruct tm *localtime();
Xstruct tm *nowtime;
X
Xstruct passwd *getpwnam(), *getpwuid(), *pass;
X
Xextern char **environ;
X
Xextern int  errno;           /*\            */
X#ifdef NQ
Xextern int  deverr;          /* \ see       */
X#endif
Xextern int  sys_nerr;        /* / perror(3) */
Xextern char *sys_errlist[];  /*/            */
X
Xchar *calloc();
X
X/* the structures used for communication with IQUEUER  */
X
X  struct to_iqueuer
X  {
X    union chr_int typ;              /* what kind of message is this? */
X    union chr_int my_pid;           /* the pid of this process       */
X    union chr_int my_fifo;          /* the inode number of my FIFO   */
X    union chr_int dev1_inod;        /* the inode number of the primary device */
X    union chr_int dev2_inod;        /* the inode number of secondary device */
X    union chr_int dev3_inod;        /* the inode number of tertiary device */
X    union chr_int dev4_inod;        /* the inode number of 4th device */
X    union chr_int dev5_inod;        /* the inode number of 5th device */
X    union chr_int dev6_inod;        /* the inode number of 6th device */
X    union chr_int dev7_inod;        /* the inode number of 7th device */
X    union chr_int dev8_inod;        /* the inode number of 8th device */
X    union chr_int dev9_inod;        /* the inode number of 9th device */
X    union chr_int dev10_inod;       /* the inode number of 10th device */
X    union chr_int dev11_inod;       /* the inode number of 11th device */
X                                    /* devX_inode == 0 if no Xth dev */
X    union chr_int  uid;             /* uid of the requesting user                   */
X    union chr_int loop;             /* counter for number of BUSY loops             */
X                                    /* Make sure we can go evenly into 512.  */
X  } req_msg;
X
Xint to_iqrsiz;
Xto_iqrsiz = sizeof(struct to_iqueuer);
X
X  struct to_ispin
X  {
X    union chr_int orders;           /* wait or go?                   */
X    union chr_int iq_pid;           /* the pid of the daemon         */
X    union chr_int dev_use_ino;      /* the inode number of the device to use */
X    union chr_int pad1;             /* Padding, FIFO either has enough room, */
X                                    /* or is full.                           */
X                                    /* Make sure we can go evenly into 512.  */
X  } cmd_msg;
X
Xint to_ispinsiz;
Xto_ispinsiz = sizeof(struct to_ispin);
X
X  struct dev_info
X  {
X    int inode;                      /* the inode number of the device */
X    char name[80];                  /* the name of the device         */
X    int so_many;                    /* how many requests for this dev */
X   } devinfo;
X
X  /* we'll handle up to eleven potential devices */
X  /* used by both IQUEUER and ISPIN              */
X  struct dev_info dev_ray[11];
X
X/* counters for use when moving chars to/from the FIFO read/write buffer      */
Xint count1, count2;
X/*                                                                            */
X/*                                                                            */
X/*                                                                            */
X/*                                                                            */
X/*                                                                            */
X/*                                                                            */
X/*                                                                            */
X/*                                                                            */
Xint    time_out = 0;        /* variable for knowing whether we timed out */
Xint    ret_val  = 0;        /* variable for return values of functions   */
Xint    my_error();
END_OF_FILE
if test 16935 -ne `wc -c <'ISPIN/h/common.h'`; then
    echo shar: \"'ISPIN/h/common.h'\" unpacked with wrong size!
fi
# end of 'ISPIN/h/common.h'
fi
if test -f 'ISPIN/h/iqueuer.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/h/iqueuer.h'\"
else
echo shar: Extracting \"'ISPIN/h/iqueuer.h'\" \(7698 characters\)
sed "s/^X//" >'ISPIN/h/iqueuer.h' <<'END_OF_FILE'
X/****************************************************************************/
X/*                                                                          */
X/* 1988, SOWSEAR ENGINEERING, SOFTWARE GROUP    Indianapolis, IN            */
X/*                                                                          */
X/*               our motto: "Who says you can't...?"                        */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* IQUEUER.H                                                                */
X/*                                                                          */
X/* common.h is the header file which is shared by ISPIN, IQUEUER, and IQ.   */
X/*                                                                          */
X/* Any defines, includes, or variables which may be peculiar to a           */
X/* particular program is in ispin.h, iqueuer.h, or iq.h, resectively.       */
X/*                                                                          */
X/*                                                                          */
X/* IQUEUER - the secondary queueing daemon for:                             */
X/*                                                                          */
X/* ISPIN                                                                    */
X/*                                                                          */
X/* Indianapolis Standard Printer Interface (for Network printers)           */
X/****************************************************************************/
X/*                                                                          */
X/* COMMENTS                                                                 */
X/*                                                                          */
X/* Read comments in common.h for the BIG PICTURE.                           */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DEFINES                                                                  */
X/*                                                                          */
X/* Refer to common.h                                                        */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* INCLUDES                                                                 */
X/*                                                                          */
X/* Refer to common.h                                                        */
X/*                                                                          */
X#include "../h/common.h"
X#include <sys/dir.h>
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DATA TYPES, VARIABLES, ETC                                               */
X/*                                                                          */
X/* Refer to common.h                                                        */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* MODIFICATIONS                                                            */
X/*                                                                          */
X/* Kevin Fannin 10/13/89 - Modified the wait_que structure drastically.     */
X/*                         Eliminated the job structure. See modification   */
X/*                         comments in IQUEUER.c for details.               */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X
X/* a struct to receive incoming messages                                    */
X
X  struct to_iqueuer incoming;
X
X/* a struct to build out-going messages to the ISPIN                        */
X
X  struct to_ispin out_msg;
X
X/* a struct to build out-going messages to the status inquirer              */
X
X  struct to_iq
X  {
X    union chr_lng typ;                  /* the current state */
X    union chr_lng devinod;              /* the dev's inode number    */
X    union chr_lng my_fifo;              /* so iq can figure printer's name */
X    union chr_lng pid;                  /* pid of the print job */
X    union chr_lng time_in;              /* when IQUEUER rec'd the request */
X    union chr_lng time_out;             /* when IQUEUER rec'd last status  */
X                                           /* report from the ISPIN process */
X    union chr_lng uid;                  /* uid of user requesting print job */
X    union chr_lng loop;                 /* if looping (BUSY), what iteration? */
X  } to_IQ;
X
Xint to_iq_siz;
Xto_iq_siz = sizeof(struct to_iq);
X
X/* Hold onto pid of last previous IQ (status inquiry). A tool to prevent    */
X/* interleaved reads of the status FIFO. See write_status().                */
X
Xint iq_pid;
X
X/* structures for linked lists (queues)                                     */
X
X/* the list of waiting requests                                             */
X
X  struct wait_queue
X  {
X    struct to_iqueuer job_id;   /* the info ISPIN gave in request for service */
X    int    devinod[11];         /* the possible devices for this job */
X    long   time_in;             /* when did we receive this request?       */
X    struct wait_queue *next;    /* the next job in this list               */
X    struct wait_queue *prev;    /* points backwards in the list            */
X  };
X  struct wait_queue *head_wait;
X  struct wait_queue *curr_wait;
X  struct wait_queue *list_wait;
X  struct wait_queue *hold_wait;
X
X
X/* the list of jobs running right now                                       */
X
X  struct go_list
X  {
X    int devinod;                /* the inode number for the tty     */
X    struct to_iqueuer job_id;   /* the info ISPIN gave in request for service */
X    long   time_in;             /* when did we receive this request?       */
X    long   time_out;            /* when was status last updated?           */
X    struct go_list *next;       /* the next job in the list                */
X    struct go_list *prev;       /* points backwards in the list            */
X  };
X  struct go_list *head_dsptch;
X  struct go_list *curr_dsptch;
X  struct go_list *list_dsptch;
X  struct go_list *hold_dsptch;
X
X  char inFIFO[160];
X  char statFIFO[160];
X  char outFIFO[160];
X  char build_cmd[240];
X  char lil_buf[BUFSIZ];
X
X  int outfifo,infifo,statfifo;
X  int outropn,inropn,inwopn,statropn,statdump;
X
X  struct stat *stat_buf;
X
X  int d, e;
X  long oldtime;
X
X
X  char tty_lock[100];
X  int oumask;
X
X#ifndef LCK_DIR
X#define LCK_DIR "/usr/spool/uucp/"
X#endif
X
X  char *myncheck();
END_OF_FILE
if test 7698 -ne `wc -c <'ISPIN/h/iqueuer.h'`; then
    echo shar: \"'ISPIN/h/iqueuer.h'\" unpacked with wrong size!
fi
# end of 'ISPIN/h/iqueuer.h'
fi
if test -f 'ISPIN/h/ispin.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/h/ispin.h'\"
else
echo shar: Extracting \"'ISPIN/h/ispin.h'\" \(15417 characters\)
sed "s/^X//" >'ISPIN/h/ispin.h' <<'END_OF_FILE'
X/****************************************************************************/
X/*                                                                          */
X/* 1988, SOWSEAR ENGINEERING, SOFTWARE GROUP    Indianapolis, IN            */
X/*                                                                          */
X/*               our motto: "Who says you can't...?"                        */
X/*                                                                          */
X/****************************************************************************/
X/* ISPIN.H                                                                  */
X/*                                                                          */
X/* common.h is the header file which is shared by ISPIN, IQUEUER, and IQ.   */
X/*                                                                          */
X/* Any defines, includes, or variables which may be peculiar to a           */
X/* particular program is in ispin.h, iqueuer.h, or iq.h, resectively.       */
X/*                                                                          */
X/* ISPIN                                                                    */
X/*                                                                          */
X/* Indianapolis Standard Printer Interface (for Network printers)           */
X/****************************************************************************/
X/*                                                                          */
X/* COMMENTS                                                                 */
X/*                                                                          */
X/* Read comments in common.h for the BIG PICTURE.                           */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* DEFINES                                                                  */
X/*                                                                          */
X/* Refer to common.h                                                        */
X/*                                                                          */
X/* number of seconds to wait before looping on network re-try               */
X#define NETSLEEP 30
X/*                                                                          */
X/* maximum number of attempts at network negotiation                        */
X#define MAXNET_TRY 10000
X/*                                                                          */
X/* number of seconds to wait between bursts of chars sent out to printer    */
X#define BURSTWAIT 0
X/*                                                                          */
X/* number of seconds to allow for any write operation, such as bursts of    */
X/* chars sent to printer. Setting the alarm clock for WRITEWAIT seconds     */
X/* makes sure we won't wait forever when/if output is blocked.              */
X/* If you modify this constant, make sure you leave enough time for the     */
X/* user to change the ribbon, clear the paper jam, or replenish the paper   */
X/* supply.                                                                  */
X#define WRITEWAIT 300
X/*                                                                          */
X/* number of seconds to allow for the write_net() function to send          */
X/* (usually) single chars during negotiate() and quit_net().                */
X/* We used to wait WRITEWAIT seconds in write_net(), but that was too long. */
X/* 07/26/90    LSB                                                          */
X#define NETWAIT 5
X/*                                                                          */
X/* Number of characters sent as a burst. Sized for our X.25 packet size     */
X/* optimization. UNIX cblocks are 64 bytes, of which there are four, so     */
X/* keep the BURSTSIZ below 256, so we never overflow the output buffer.     */
X#define BURSTSIZ 128
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X#define NULLCHARPTR (char *) 0
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* INCLUDES                                                                 */
X/*                                                                          */
X/* Refer to common.h                                                        */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/* Same for everybody.                                                      */
X#include <termio.h>
X#include <sys/utsname.h>
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/* DATA TYPES, VARIABLES, ETC                                               */
X/*                                                                          */
X/* Refer to common.h                                                        */
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
XFILE *fdopen(),
X     *i_stream,   /* the input file stream            */
X     *rtab;       /* the file stream for the external table of connect info */
X
Xchar line_buf[BUFSIZ];          /* a place to put connect info */
X
Xchar in_buf[BUFSIZ];            /* read into in_buf from out_file */
X
Xchar *cpnd_send, *cpnd_expt;  /* pointers for compound EXPECT-SEND-EXPECT */
Xchar *expt1, *c_send, *expt2; /* pointers to storage for EXPECT-SEND-EXPECT */
X
X
X
Xstruct termio T;        /* defined in termio.h */
Xstruct termio Tsav;        /* defined in termio.h */
Xstruct termio T_COOK;
Xstruct termio T_RAW;
X
X/****************************************************************************/
X/*                                                                          */
X/*                                                                          */
X/* vars and structs for common resolution of invocation flags and args      */
X
X  /* a couple just for the NQ crowd */
X
X  int   no_input = 0;     /* indicates no input file was passed */
X  char  *sptime;          /* time that file was spooled */
X
X  /* two just for the LP crowd */
X
X  char *lp_id;             /* request id from lp */
X  int numfiles;            /* howmany files are we asked to print ? */
X  int num_ofile;            /* howmany files are we asked to print ? */
X
X  /* the rest are same for either */
X
X  int   banner = 0;       /* indicates a banner should be printed */
X  int   prtimes = 1;      /* number of times to print the file(s) */
X
X  char  *from;            /* the user making the request */
X  char  *title;           /* title requested */
X  char  *dest;            /* destination string (printer name) */
X  char  *usr_strng;       /* string specified on the lp or nq command line */
X
X  /**************************************************************/
X  /* file descriptors and streams */
X  /* dqueuer will only pass one file name, while */
X  /* lp will pass additional args for add'l files */
X
X#ifdef NQ
X  char *fyle;   /* in the NQ case, this points merely to the base filename */
X#else
X  char **fyles;
X#endif
X
X  int out_file;/* file descriptor of output file     */
X                          /* necessary as argument to ioctl calls */
X/*                                                                          */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/*                                                                          */
X/*                                                                          */
X/* variables and structures for data gathered from read of rtab             */
X
X
X    
X
X    /* speed */
X    int speed;
X
X    /* a linked list for network "busy" strings */ 
X    struct busy_list
X        {
X          char *busy_strg;                        /* NULL terminated */
X          struct busy_list *next;                 /* pointer to next one */
X                                                  /* last has value NULL */
X        };
X    struct busy_list *busy_head;/* head of the list of "busy" strings         */
X    struct busy_list *busy_curr;/* current member of list of "busy" strings   */
X    struct busy_list *busy_list;/* movable pointer for list of "busy" strings */
X
X
X    /* a linked list for network "inactive" strings */ 
X    struct dead_list
X        {
X          char *dead_strg;                        /* NULL terminated */
X          struct dead_list *next;                 /* pointer to next one */
X                                                  /* last has value NULL */
X        };
X    struct dead_list *dead_head;/* head of the list of "dead" strings         */
X                                /* any other Dead Heads out there ?     LSB   */
X    struct dead_list *dead_curr;/* current member of list of "dead" strings   */
X    struct dead_list *dead_list;/* movable pointer for list of "dead" strings */
X
X    /* a linked list for network "quit" strings */ 
X    struct quit_list
X        {
X          char *quit_strg;                        /* NULL terminated */
X          struct quit_list *next;                 /* pointer to next one */
X                                                  /* last has value NULL */
X        };
X    struct quit_list *quit_head;/* head of the list of "quit" strings         */
X    struct quit_list *quit_curr;/* current member of list of "quit" strings   */
X    struct quit_list *quit_list;/* movable pointer for list of "quit" strings */
X
X
X    /* a linked list for network "disconnect" strings */ 
X    struct disc_list
X        {
X          char *disc_strg;                        /* NULL terminated */
X          struct disc_list *next;                 /* pointer to next one */
X                                                  /* last has value NULL */
X        };
X    struct disc_list *disc_head;/* head of the list of "disc" strings         */
X    struct disc_list *disc_curr;/* current member of list of "disc" strings   */
X    struct disc_list *disc_list;/* movable pointer for list of "disc" strings */
X
X
X    /* a linked list for network "expect" strings */ 
X    struct expt_list
X        {
X          char *expt_strg;                        /* NULL terminated */
X          struct expt_list *prev;                 /* pointer to prev one */
X                                                  /* first has value NULL */
X          struct expt_list *next;                 /* pointer to next one */
X                                                  /* last has value NULL */
X        };
X    struct expt_list *expt_head;/* head of the list of "expt" strings         */
X    struct expt_list *expt_curr;/* current member of list of "expt" strings   */
X    struct expt_list *expt_list;/* movable pointer for list of "expt" strings */
X
X    /* a linked list for network "send" strings */ 
X    struct send_list
X        {
X          char *send_strg;                        /* NULL terminated */
X          struct send_list *prev;                 /* pointer to prev one */
X                                                  /* first has value NULL */
X          struct send_list *next;                 /* pointer to next one */
X                                                  /* last has value NULL */
X        };
X    struct send_list *send_head;/* head of the list of "send" strings         */
X    struct send_list *send_curr;/* current member of list of "send" strings   */
X    struct send_list *send_list;/* movable pointer for list of "send" strings */
X
X
X/****************************************************************************/
X/*                                                                          */
X/*                                                                          */
X/* some general purpose stuff                                               */
X/*                                                                          */
X
X/* for supporting setjmp and longjmp */
X#ifdef NQ
X#include <setret.h>
X#define SETJMP(p) setret(p)
X#define LONGJMP(s,n) longret(s,n)
Xret_buf agayn, kwit;
X#else
X#include <setjmp.h>
X#define SETJMP(p) setjmp(p)
X#define LONGJMP(s,n) longjmp(s,n)
Xjmp_buf agayn, kwit;
X#endif
X
Xchar outFIFO[80];
Xchar inFIFO[80];
X
X#ifdef NQ
Xchar *strtok();
Xchar *strchr();
Xchar *strrchr();
X#endif
X
Xint outfifo,infifo;
Xint outropn,inropn,inwopn;
Xint check_char, keep_char;
Xint port_open = 0;
Xint quit_once = 0;
Xint savd_errno = 0;
X
Xint flgs_delay;
Xint flgs_ndelay;
X
Xstruct stat *stat_buf;
X
X
Xstruct utsname sysnam;
X
X
Xint    netloop;             /* counter for num of loops on network busy  */
Xint    status;              /* variable for return status of subroutines */
Xint    logging = 0;         /* flag to determine if event logging is on  */
Xint    raw = 0;             /* flag to determine if RAW output is desired*/
Xint    tab_expand = 0;      /* flag to determine if tab expansion desired*/
Xint    usr_addr = 0;        /* flag to determine if user-specified addr  */
Xint    stayt;               /* variable for current state of execution */
X
X
X/* THE output device chosen by IQUEUER, NULL terminated */
Xchar GO_dev[80];
X
X/* the control terminal, chosen by ISPIN, NULL terminated */
X/* string */
Xchar ctrl_tty[80];
X/* file descriptor */
Xint ctrltty;
X
X
X/* DEFINES required by regexp(5), used in matcher()                   */
X#define INIT            register char *sp = instring;
X#define GETC()          (*sp++)
X#define PEEKC()         (*sp)
X#define UNGETC(c)       (--sp)
X#define RETURN(c)       return;
X#define ERROR(c)        {\
X                         time(&tloc);\
X                         nowtime = (struct tm *)localtime(&tloc);\
X                         time_str = asctime(nowtime);\
X                         sprintf(errmsg,"ISPIN: REGEXP ERROR: %d. time:\n",c);\
X                         strcat(errmsg,"                            ");\
X                         strcat(errmsg,time_str);\
X                         strcat(errmsg,"\n");\
X                         my_error(SYSERR);\
X                        }
X
X/* INCLUDE required by regexp(5), used in matcher()   */
X#include <regexp.h>
X/*                                                                            */
X/*                                                                            */
X/******************************************************************************/
END_OF_FILE
if test 15417 -ne `wc -c <'ISPIN/h/ispin.h'`; then
    echo shar: \"'ISPIN/h/ispin.h'\" unpacked with wrong size!
fi
# end of 'ISPIN/h/ispin.h'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/C351_PLAIN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/C351_PLAIN'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/C351_PLAIN'\" \(677 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/C351_PLAIN' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-Bcongestion;-Bremote dte;-Bfound;-Dcleared;-Dpad>;-DSystem;-Q\w\032\dclr\r\d;-Q\d\K\pbye\d;System?-\p\K\pbye\r\p-System?;\ppacout\r\d\r\d;connect-\p\r\d-pad>;\p\r\d;pad>-\p\K\dclr\r\w-pad>;set recall=26\r\dconnect\s00000099999999\r\d;pened-\p\K\dclr\r\dset recall=26\r\dconnect\s00000099999999\r\w-pened;\d\n\f;;;
END_OF_FILE
if test 677 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/C351_PLAIN'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/C351_PLAIN'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/C351_PLAIN'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/QUME_SHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/QUME_SHT'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/QUME_SHT'\" \(708 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/QUME_SHT' <<'END_OF_FILE'
X# You'll need to adjust this to suit your switch's login herald and break
X# sequence. In this example, the login herald contains the string "System?",
X# and the switch's break sequence is defined as "<BREAK>bye". The switch's
X# info messages (Tellabs) are "on" in order to allow ISPIN to detect error
X# conditions.
X#
Xnetind1;/dev/contty,/dev/tty22;9600;-L;-Busy;-Bcongestion;-Bremote dte;-Bfound;-Dcleared;-Dpad>;-DSystem;-Q\L\L\032\dclr\r\d;-Q\d\K\dbye\d;System?-\p\K\pbye\r\p-System?;\ppacout\r\d\r\d;connect-\p\r\d-pad>;\p\r\d;pad>-\p\K\dclr\r\w-pad>;set recall=26\r\dconnect\s00000099999999\r\d;pened-\p\K\dclr\r\dset recall=26\r\dconnect\s00000099999999\r\w-pened;\033S\033F90\033C28\0339\015\033T\E;;;
END_OF_FILE
if test 708 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/QUME_SHT'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/QUME_SHT'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_SW_CDN_PTR/ADDR_SPEC/QUME_SHT'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/PLAIN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/PLAIN'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/PLAIN'\" \(328 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/PLAIN' <<'END_OF_FILE'
X#
X#
X#
Xnetind1;/dev/ttyi07,/dev/ttyi31,/dev/ttyi15;9600;-L;-Bcongestion;-Bremote dte;-Q\L\L\032\dclr\r\d;-DConnection cleared;-Dpad>;ad>-\p\K\pclr\r\d-ad>;\r\p;pad>-\p\K\pclr\r\d-pad>;set recall=26\r\p;pad>-\r\d-pad>;\pconnect\s00000099999999\r\d;pened-\p\K\pclr\r\dset recall=26\r\p\pconnect\s00000099999999\r\d-pened;\d;;;
X#
X#
END_OF_FILE
if test 328 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/PLAIN'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/PLAIN'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_CDN_PTR/ADDR_SPEC/PLAIN'
fi
if test -f 'ISPIN/install/lib_rtab/CPU_PTR/PLAIN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ISPIN/install/lib_rtab/CPU_PTR/PLAIN'\"
else
echo shar: Extracting \"'ISPIN/install/lib_rtab/CPU_PTR/PLAIN'\" \(35 characters\)
sed "s/^X//" >'ISPIN/install/lib_rtab/CPU_PTR/PLAIN' <<'END_OF_FILE'
X#
Xnetind1;/dev/ttyi07;9600;-L;;;
X#
END_OF_FILE
if test 35 -ne `wc -c <'ISPIN/install/lib_rtab/CPU_PTR/PLAIN'`; then
    echo shar: \"'ISPIN/install/lib_rtab/CPU_PTR/PLAIN'\" unpacked with wrong size!
fi
# end of 'ISPIN/install/lib_rtab/CPU_PTR/PLAIN'
fi
echo shar: End of archive 3 \(of 15\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

