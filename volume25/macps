Subject: v25i030: macps - utilities to help print Apple "LaserPrep" files
Newsgroups: comp.sources.unix
Approved: vixie@pa.dec.com

Submitted-By: Ed Moy <edmoy@violet.berkeley.edu>
Posting-Number: Volume 25, Issue 30
Archive-Name: macps

Macps is a Unix program that takes an uploaded PostScript file created
on a Macintosh (by typing Command-F at the LaserWriter dialog box; see
macps.1 for more details) and includes an appropriately modified
LaserPrep file so that the result can be sent to a PostScript printer
X>From Unix.  The LaserPrep file contains macros used by the PostScript
generator on the Macintosh.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  Installation MANIFEST Makefile ReadMe macaux.c macps.1
#   macps.c macps.config prepfix.1 prepfix.c str.h ucbwhich.c
#   ucbwhich.h
# Wrapped by vixie@cognition.pa.dec.com on Fri Dec 13 14:53:21 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Installation' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Installation'\"
else
echo shar: Extracting \"'Installation'\" \(3485 characters\)
sed "s/^X//" >'Installation' <<'END_OF_FILE'
Installation Instructions (SCCSid = "@(#)Installation	2.2 10/24/89")
X
X1) Look at the Makefile.  There are three CFLAGS options that you can
use.  Setting SYSV should allow macps and prepfix to compile on System
V machines (I've only tried it under A/UX).  Setting CONFIGDIR will
cause macps to look for macps.config in that directory.  Setting SAVE
will cause macps to enclose the entire print job is a PostScript
save/restore context.  Normally you don't need SAVE, since most
spooling software will automatically do an EOF between print jobs, which
effectively does a restore of memory for you, but some spooling
software does require the save/restore.  Note that defining SAVE will
cause printing to fail on a NeXT laser printer, while it is harmless on
most other systems.
X
The options will look something like:
X
CFLAGS = -O -DSYSV -DCONFIGDIR=\"/usr/new/lib\" -DSAVE
X
if you defined all the options.
X
X2) Type "make".  If all goes well, macps and prepfix will be created.
X
X3) To create the unprocessed LaserPrep file on the Mac, as well as
creating the raw PostScript files that you want to print, make sure
that either you're not running MultiFinder, or if you are, go to the
Chooser under the Apple menu, click on the LaserWriter icon and then
turn off Background Printing.
X
X4) For each version of LaserPrep on the Mac that you want to include,
install that version in the System Folder.  Then, open an empty
document in some simple application (one that doesn't have its
own ProcSet to download).  Choose Print from the File menu and the
LaserWriter print dialog will appear.  Click on the OK button and
IMMEDIATELY press and hold Command-K.  When a dialog box appears
telling you that it is creating a PostScript file, you can release
Command-K.  The unprocessed LaserPrep file will usually be found in one
of three places, in the System Folder, in the same folder as the
application or at the top level of the disk.
X
X5) Upload the PostScript file(s) to Unix, using some file transfer
program like MacTerminal, Versaterm, Red Ryder, MacKermit or NCSA
Telnet (if your file transfer program feels left out, feel free to add
it to your list).
X
X6) Run prepfix on each unprocessed file, diverting the standard output
to an appropriataly named file (like LaserPrep5.2).  If you want to
allow bit smoothing on a non-Apple PostScript printer, specify the -l
option to prepfix (you can specify as many printer names as you want,
each with a separate -l flag).  If you aren't sure the your printer can
do smoothing, you can try it and see if it works (if it doesn't, you
can always re-run prepfix on the unprocessed file(s), leaving off the
printer that doesn't work).  If you don't know the product name for you
printer, you can use the following PostScript code to print it:
X
X%!
X/in {72 mul} def
X/Courier findfont 18 scalefont setfont
X1 in 8 in moveto
statusdict /product get show
showpage
X
X7) Put the modified LaserPrep file(s) in some directory and modify the
macps.config file to point to these LaserPrep files.  Then put the
macps.config file in a "lib" subdirectory to where you install macps
X(or in the directory CONFIGDIR if you used that option).
X
X8) Now when you want to print something, do the same thing as in step 4
above with the LaserWriter print dialog, except press and hold
Command-F (this cause LaserPrep not to be included in the PostScript
file).
X
X9) Upload the PostScript file and run macps on it, sending the output
to your printer, as in:
X
X	% macps psfile | lpr
END_OF_FILE
if test 3485 -ne `wc -c <'Installation'`; then
    echo shar: \"'Installation'\" unpacked with wrong size!
fi
# end of 'Installation'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(517 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Installation               1	
X MANIFEST                   1	This shipping list
X Makefile                   1	
X ReadMe                     1	
X macaux.c                   1	
X macps.1                    1	
X macps.c                    1	
X macps.config               1	
X prepfix.1                  1	
X prepfix.c                  1	
X str.h                      1	
X ucbwhich.c                 1	
X ucbwhich.h                 1	
END_OF_FILE
if test 517 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(1338 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Copyright (c) 1988, The Regents of the University of California.
X# Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X# Information Systems and Technology.
X#
X# Permission is granted to any individual or institution to use, copy,
X# or redistribute this software so long as it is not sold for profit,
X# provided that this notice and the original copyright notices are
X# retained.  The University of California makes no representations about the
X# suitability of this software for any purpose.  It is provided "as is"
X# without express or implied warranty.
X#
X# SCCSid = "@(#)Makefile	2.2 10/24/89"
X#
X# For System V, include -DSYSV in CFLAGS below.
X# To specify a fixed path for macps.config, include -DCONFIGDIR=\"path\"
X# in CFLAGS below (path is the full pathname of the directory).
X# To do save/restore context, include -DSAVE in CFLAGS below.
X#
CFLAGS = -O
MACPS = macps.o macaux.o ucbwhich.o
PREPFIX = prepfix.o macaux.o
DESTPATH = /usr/local
X
all : macps prepfix
X
install :
X	install -c macps $(DESTPATH)/bin/macps
X	install -c macps.1 $(DESTPATH)/man/man1/macps.1
X	install -c prepfix $(DESTPATH)/bin/prepfix
X	install -c prepfix.1 $(DESTPATH)/man/man1/prepfix.1
X
macps : $(MACPS)
X	cc -o macps $(CFLAGS) $(MACPS)
X
prepfix : $(PREPFIX)
X	cc -o prepfix $(CFLAGS) $(PREPFIX)
X
clean :
X	/bin/rm -f *.o macps prepfix
END_OF_FILE
if test 1338 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'ReadMe' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ReadMe'\"
else
echo shar: Extracting \"'ReadMe'\" \(4682 characters\)
sed "s/^X//" >'ReadMe' <<'END_OF_FILE'
COPYRIGHT NOTICE (SCCSid = "@(#)ReadMe	2.2 10/24/89")
X
Copyright (c) 1988, The Regents of the University of California.
XEdward Moy, Workstation Software Support Group, Workstation Support
Serices, Information Systems and Technology.
X
Permission is granted to any individual or institution to use, copy, or
redistribute this software so long as it is not sold for profit,
provided that this notice and the original copyright notices are
retained.  The University of California makes no representations about
the suitability of this software for any purpose.  It is provided "as
is" without express or implied warranty.
X
WHAT IS MACPS?
X
Macps is a Unix program that takes an uploaded PostScript file created
on a Macintosh (by typing Command-F at the LaserWriter dialog box; see
macps.1 for more details) and includes an appropriately modified
LaserPrep file so that the result can be sent to a PostScript printer
X>From Unix.  The LaserPrep file contains macros used by the PostScript
generator on the Macintosh.
X
WHY IS MACPS NEEDED?
X
This is how Mac printing works.  When a Mac talks to a LaserWriter, it
asks if the LaserWriter has had a LaserPrep file downloaded to it.  A
LaserWriter that is first powered up, has no such LaserPrep file, and
so the Mac downloads it and makes the LaserPrep file resident in
memory.  Then the actual print file is sent to the LaserWriter.
Subsequent print requests need not download the LaserPrep file, unless
it is a different version.
X
Since a LaserWriter connected to a Unix system usually does things
other than Mac printing, it is unwise to make LaserPrep files resident
in memory so that other PostScript jobs have less memory to work with.
What prepfix does is to modify a LaserPrep file so that, among other
things, it does not make itself resident in memory.  Thus, the
LaserPrep file must be downloaded for each Mac print job.  This is the
function of macps, to automatically append the appropriate LaserPrep
file.
X
WHICH VERSION OF THE LASERPREP WILL BE USED?
X
Macps interprets the %%IncludeProcSet directive found in the PostScript
generated by LaserWriter driver 4.0 and greater.  It takes the ProcSet
id and looks it up in a file "macps.config", to get the pathname of the
prep file, and thus macps can convert PostScript generated by different
versions of the LaserWriter driver.
X
HOW ARE THE LASERPREP FILES GENERATED?
X
Since the Apple LaserPrep files are copyrighted, I've included a
program, prepfix, that reads version 4.0 and up LaserPrep files, and
edits them so that they are compatible with Unix, and are even
electronically mailable (See prepfix.1 for more details).
X
WHERE IS THE MACPS.CONFIG FILE LOCATED?
X
Macps has some special code that is able to figure out from which
directory it was called from.  It will then look in a "lib" subdiretory
for the macps.config file.
X
WHAT ABOUT BIT-SMOOTHING ON NON-LASERWRITER PRINTERS?
X
XFor PostScript printers using Motorola 680x0 processors and Adobe
PostScript firmware other than LaserWriters, there is an option that
will allow these printers to do bit-smoothing, just like LaserWriters.
X
CHANGES IN VERSION 2.2
X
Version 2.2 of prepfix now supports LaserPrep 6.0.  The PostScript
save/restore context is now a compile-time option, since it caused
printing to fail on a NeXT printer (though it was harmless on most
other printers).  This save/restore is now more intelligent about
clearing the stacks.
X
CHANGES IN VERSION 2.1
X
Version 2.1 of prepfix uses a safer method for turning on bit-smoothing
for non-Apple printers.  This should get around some of the problems
people have been having with specialized macros in the LaserPreps that
are Apple printer specific.  The -l and -p options in version 1.1 have
been replaced with the single -l option, and the limit on the number
of printers you can specify has been removed.
X
Also, prepfix removes some other various macros that cause
unpredictable problems, and a problem with Apple LaserWriter II/NTs
X(but not other Apple printers).
X
Version 2.1 macps has several new options.  The -c option allow you to
specify the number of copies to generate (overriding any multiple copy
option that was specified on the Macintosh).  The -d option allows an
alternate directory to look for the macps.config file.  Finally, the -r
X(raw) option suppresses the conversion of 8-bit binary into ASCII, and
is useful for some graphics programs that manipulate gray-scale images,
and produce 8-bit binary PostScript output.
X
Macps will even work with a NeXT laser printer, but (at least the 0.8
version of the operating system) will not do bit smoothing.  Beware,
though, that if you print Macintosh patterns at 400 dpi, they will
look funny.
END_OF_FILE
if test 4682 -ne `wc -c <'ReadMe'`; then
    echo shar: \"'ReadMe'\" unpacked with wrong size!
fi
# end of 'ReadMe'
fi
if test -f 'macaux.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'macaux.c'\"
else
echo shar: Extracting \"'macaux.c'\" \(3585 characters\)
sed "s/^X//" >'macaux.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, The Regents of the University of California.
X * Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X * Information Systems and Technology.
X *
X * Permission is granted to any individual or institution to use, copy,
X * or redistribute this software so long as it is not sold for profit,
X * provided that this notice and the original copyright notices are
X * retained.  The University of California makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X */
X
X#ifndef lint
static char *SCCSid = "@(#)macaux.c	2.2 10/24/89";
X#endif lint
X
X#include <ctype.h>
X#include <stdio.h>
X#include "str.h"
X
X#define	FALSE		0
X#define	TRUE		1
X
extern char *myname;
int rawmode = FALSE;
X
STR *
STRalloc()
X{
X	register STR *str;
X	char *malloc();
X
X	if((str = (STR *)malloc(sizeof(STR))) == NULL ||
X	 (str->bufptr = (unsigned char *)malloc(STRSIZE)) == NULL) {
X		fprintf(stderr, "%s: STRalloc: Out of memory\n", myname);
X		exit(1);
X	}
X	str->curendptr = str->bufptr;
X	str->realendptr = str->bufptr + STRSIZE;
X	return(str);
X}
X
STRfree(str)
STR *str;
X{
X	free((char *)str->bufptr);
X	free((char *)str);
X}
X
STRexpand(str)
register STR *str;
X{
X	register int curend, realend;
X	char *realloc();
X
X	curend = str->curendptr - str->bufptr;
X	realend = (str->realendptr - str->bufptr) + STRSIZEDELTA;
X	if((str->bufptr = (unsigned char *)realloc((char *)str->bufptr,
X	 realend)) == NULL) {
X		fprintf(stderr, "%s: STRexpand: Out of memory\n", myname);
X		exit(1);
X	}
X	str->curendptr = str->bufptr + curend;
X	str->realendptr = str->bufptr + realend;
X}
X
STRgets(str, fp)
register STR *str;
register FILE *fp;
X{
X	register int c;
X
X	str->curendptr = str->bufptr;
X	for( ; ; ) {
X		if((c = getc(fp)) == EOF)
X			return(str->curendptr > str->bufptr);
X		if(str->curendptr >= str->realendptr)
X			STRexpand(str);
X		*str->curendptr++ = c;
X		if(c == '\n' || c == '\r')
X			return(TRUE);
X	}
X}
X
STRputsptr(str, cp, fp)
register STR *str;
register unsigned char *cp;
register FILE *fp;
X{
X	if(rawmode) {
X		for( ; cp < str->curendptr ; cp++)
X			putc(*cp, fp);
X		return;
X	}
X	for( ; cp < str->curendptr ; cp++) {
X		if(!isascii(*cp))
X			fprintf(fp, "\\%03o", *cp);
X		else if(isprint(*cp))
X			putc(*cp, fp);
X		else {
X			switch(*cp) {
X			 case '\n':
X			 case '\r':
X				putc('\n', fp);
X				continue;
X			 case '\t':
X				putc('\t', fp);
X				continue;
X			 default:
X				fprintf(fp, "\\%03o", *str);
X				continue;
X			}
X		}
X	}
X}
X
STRcompareptr(str, cp, sp)
register STR *str;
register unsigned char *cp, *sp;
X{
X	register int comp;
X
X	for( ; ; ) {
X		if(*sp == 0)
X			return(cp >= str->curendptr ? 0 : 1);
X		if(cp >= str->curendptr)
X			return(-1);
X		if(*sp == '\n') {
X			if(*cp != '\n' && *cp != '\r')
X				return((int)*cp - (int)*sp);
X		} else if((comp = (int)*cp - (int)*sp) != 0)
X			return(comp);
X		cp++;
X		sp++;
X	}
X}
X
STRheadcmpptr(str, cp, sp)
register STR *str;
register unsigned char *cp, *sp;
X{
X	register int comp;
X
X	for( ; ; ) {
X		if(*sp == 0)
X			return(0);
X		if(cp >= str->curendptr)
X			return(-1);
X		if(*sp == '\n') {
X			if(*cp != '\n' && *cp != '\r')
X				return((int)*cp - (int)*sp);
X		} else if((comp = (int)*cp - (int)*sp) != 0)
X			return(comp);
X		cp++;
X		sp++;
X	}
X}
X
unsigned char *
STRmatch(str, sp)
register STR *str;
register unsigned char *sp;
X{
X	register unsigned char *mp, *last;
X	register int firstchar;
X
X	firstchar = *sp;
X	last = str->curendptr - strlen(sp);
X	mp = str->bufptr;
X	while(mp <= last) {
X		if(*mp == firstchar && STRheadcmpptr(str, mp, sp) == 0)
X			return(mp);
X		mp++;
X	}
X	return(NULL);
X}
END_OF_FILE
if test 3585 -ne `wc -c <'macaux.c'`; then
    echo shar: \"'macaux.c'\" unpacked with wrong size!
fi
# end of 'macaux.c'
fi
if test -f 'macps.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'macps.1'\"
else
echo shar: Extracting \"'macps.1'\" \(2592 characters\)
sed "s/^X//" >'macps.1' <<'END_OF_FILE'
X.\" SCCSid = "@(#)macps.1	2.2 10/24/89"
X.TH MACPS 1 "24 Oct 1989"
X.UC 4
X.SH NAME
macps \- print Macintosh-created PostScript file on Unix
X.SH SYNOPSIS
X.B macps
X[
X\-c copies
X]
X[
X\-d directory
X]
X[
X\-r
X]
X[
file
X]
X.SH DESCRIPTION
X.I Macps
takes the command-line file (or the standard input if no filename is given),
and prepends the appropriate Macintosh LaserPrep file (e.g., those generated
by
X.IR prepfix (1)).
The standard output can then be directed to a PostScript printer, via
X.IR lpr (1),
for example.
X.PP
The input PostScript file is generated on a Macintosh by typing (and holding)
Command-F immediately after clicking the OK button of the LaserWriter printer
dialog box.
Another dialog will appear, confirming that a file named ``PostScript'' is
being created (the Command-F keys can be released now).
X.PP
Depending on the application, the created PostScript file can be found in the
System Folder, the application folder or the top level of the disk.
This file can then be uploaded via some file transfer program, such as
MacTerminal/VersaTerm and
X.IR macget (1)
or MacKermit/Red Ryder and
X.IR kermit (1).
X.PP
Normally, you would specify the number of copies in the LaserWriter
print dialog box on the Macintosh.
However, you can override that after uploading the PostScript file by
specifying the
X.B \-c
option, followed by the number of copies.
X.PP
The file
X.B macps.config
specifies the mapping between the internal LaserPrep name and the actual
file it resides in.
This file is normally located in the lib subdirectory from which
X.I macps
was called from.
The
X.B \-d
option allow you to specify an alternate directory in which the
X.B macps.config
file can be found.
X.PP
Most Macintosh applications produce normal ASCII PostScript files.
However, some graphics programs that manipulate gray-scale images will
produce PostScript files that contain 8-bit binary data.
Since
X.I macps
normally converts this binary data, these PostScript file will not work
properly.
The
X.B \-r
X(raw) option suppresses this binary conversion.
X(Note: Depending on how the printer is physically connected, it may not be
able to handle 8-bit binary data properly, and results may be disappointing.)
X.SH FILES
X.TP "\w'lib/macps.config   'u"
lib/macps.config
maps ProcSet ids to LaserPrep filenames
X.SH "SEE ALSO"
lpr(1), macget(1), kermit(1), prepfix(1)
X.SH BUGS
X.I Macps
only works with version 4.0 and up of the Macintosh LaserPrep files.
Because of the way bit smoothing is implimented by the LaserWriter driver,
some PostScript printers other than the Apple LaserWriters may not be able to
bit smooth.
END_OF_FILE
if test 2592 -ne `wc -c <'macps.1'`; then
    echo shar: \"'macps.1'\" unpacked with wrong size!
fi
# end of 'macps.1'
fi
if test -f 'macps.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'macps.c'\"
else
echo shar: Extracting \"'macps.c'\" \(5053 characters\)
sed "s/^X//" >'macps.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, The Regents of the University of California.
X * Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X * Information Systems and Technology.
X *
X * Permission is granted to any individual or institution to use, copy,
X * or redistribute this software so long as it is not sold for profit,
X * provided that this notice and the original copyright notices are
X * retained.  The University of California makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X */
X
X#ifndef lint
static char *SCCSid = "@(#)macps.c	2.2 10/25/89";
X#endif lint
X
X#include <ctype.h>
X#include <stdio.h>
X#ifdef SYSV
X#include <string.h>
X#else SYSV
X#include <strings.h>
X#endif SYSV
X#include <sys/types.h>
X#include <sys/file.h>
X#include "str.h"
X#include "ucbwhich.h"
X
X#define	CONFIG		"macps.config"
X#ifdef SYSV
X#define	index		strchr
X#define	rindex		strrchr
X#endif SYSV
X
X#ifdef SAVE
char *finale = "clear countdictstack 2 sub{end}repeat macps restore\n";
char intro[] = "\
X%%! *** Created by macps: %s\
X/macps save def\n\
X";
X#else SAVE
char intro[] = "\
X%%! *** Created by macps: %s\
X";
X#endif SAVE
char *myname;
int ncopies = 0;
X#ifdef CONFIGDIR
char ucblib[UCBMAXPATHLEN] = CONFIGDIR;
X#else CONFIGDIR
int ucbalternate;
char ucbpath[UCBMAXPATHLEN];
char ucblib[UCBMAXPATHLEN];
X#endif CONFIGDIR
X
main(argc, argv)
int argc;
char **argv;
X{
X	register STR* str;
X	register char *cp, *pp;
X	register FILE *fp;
X	register int i, fd;
X	char line[BUFSIZ];
X	char path[UCBMAXPATHLEN];
X	long ltime;
X	char *ctime();
X
X#ifndef CONFIGDIR
X	ucbwhich(*argv);
X#endif CONFIGDIR
X	if(myname = rindex(*argv, '/'))
X		myname++;
X	else
X		myname = *argv;
X	cp = NULL;
X	for(argc--, argv++ ; argc > 0 && **argv == '-' ; argc--, argv++) {
X		switch((*argv)[1]) {
X		 case 'c':	/* multiple copies */
X			if((*argv)[2])
X				ncopies = atoi(&(*argv[2]));
X			else {
X				if(argc < 2)
X					Usage();	/* never returns */
X				argc--;
X				ncopies = atoi(*++argv);
X			}
X			if(ncopies <= 0)
X				Usage();	/* never returns */
X			break;
X		 case 'd':	/* alternate directory for config file */
X			if((*argv)[2])
X				cp = &(*argv[2]);
X			else {
X				if(argc < 2)
X					Usage();	/* never returns */
X				argc--;
X				cp = *++argv;
X			}
X			strcpy(ucblib, cp);
X			break;
X		 case 'r':	/* raw mode */
X			rawmode++;
X			break;
X		 default:
X			Usage();	/* never returns */
X		}
X	}
X	if(argc > 1)
X		Usage();	/* never returns */
X	if(argc == 1 && freopen(*argv, "r", stdin) == NULL) {
X		fprintf(stderr, "%s: can't open %s\n", myname, *argv);
X		exit(1);
X	}
X	str = STRalloc();
X	if(!STRgets(str, stdin)) {
X		fprintf(stderr, "%s: Null input\n", myname);
X		exit(1);
X	}
X	strcat(ucblib, "/");
X	strcpy(path, ucblib);
X	strcat(path, CONFIG);
X	if((fp = fopen(path, "r")) == NULL) {
X		fprintf(stderr, "%s: Can't open %s\n", myname, path);
X		exit(1);
X	}
X	time(&ltime);
X	printf(intro, ctime(&ltime));
X	do {
X		if(ncopies != 0 && STRheadcompare(str, "userdict /#copies ")
X		 == 0)
X			continue;
X		if(STRcompare(str, "%%EOF\n") == 0) {
X#ifdef SAVE
X			if(finale) {
X				fputs(finale, stdout);
X				finale = NULL;
X			}
X#endif SAVE
X			STRputs(str, stdout);
X			continue;
X		}
X		if(STRheadcompare(str, "%%IncludeProcSet:") == 0) {
X			for(cp = (char *)&str->bufptr[17] ; ; cp++) {
X				if(!*cp) {
X					fprintf(stderr,
X				 "%s: Syntax error on IncludeProcSet line\n",
X					 myname);
X					exit(1);
X				}
X				if(!isascii(*cp) || !isspace(*cp))
X					break;
X			}
X			pp = (char *)str->curendptr;
X			while(--pp >= cp) {
X				if(!isascii(*pp) || !isspace(*pp))
X					break;
X				*pp = 0;
X			}
X			str->curendptr = (unsigned char *)(pp + 1);
X			fseek(fp, 0L, 0);
X			for( ; ; ) {
X				if(!fgets(line, BUFSIZ, fp)) {
X					fprintf(stderr,
X					 "%s: Unknown IncludeProcSet %s\n",
X					 myname, cp);
X					exit(1);
X				}
X				if(*line == '#')
X					continue;
X				if(pp = index(line, '\n')) {
X					if(pp == line)
X						continue;
X					*pp = 0;
X				}
X				if(!(pp = index(line, '\t'))) {
X					fprintf(stderr,
X					 "%s: Syntax error in macps.config\n",
X					 myname);
X					exit(1);
X				}
X				*pp++ = 0;
X				if(STRcompareptr(str, cp, line) == 0)
X					break;
X			}
X			if(*pp == '/')
X				strcpy(path, pp);
X			else {
X				strcpy(path, ucblib);
X				strcat(path, pp);
X			}
X			fflush(stdout);
X			if((fd = open(path, O_RDONLY, 0)) < 0) {
X				fprintf(stderr, "%s: Can't open %s\n", myname,
X				 path);
X				exit(1);
X			}
X			while((i = read(fd, line, BUFSIZ)) > 0)
X				write(1, line, i);
X			close(fd);
X			continue;
X		}
X		STRputs(str, stdout);
X		if(ncopies > 1 && isascii(*str->bufptr) &&
X		 isdigit(*str->bufptr)) {
X			cp = (char *)str->bufptr;
X			while(cp < (char *)str->curendptr && isascii(*cp)
X			 && isdigit(*cp))
X				cp++;
X			if((char *)str->curendptr - cp == 4 &&
X			 STRcompareptr(str, cp, " mf\n") == 0) {
X				printf("userdict /#copies %d put\n", ncopies);
X				ncopies = -1;
X			}
X		}
X	} while(STRgets(str, stdin));
X#ifdef SAVE
X	if(finale)
X		fputs(finale, stdout);
X#endif SAVE
X	exit(0);
X}
X
Usage()
X{
X	fputs("Usage: macps [-c #] [-d directory] [-r] [file]\n", stderr);
X	exit(1);
X}
END_OF_FILE
if test 5053 -ne `wc -c <'macps.c'`; then
    echo shar: \"'macps.c'\" unpacked with wrong size!
fi
# end of 'macps.c'
fi
if test -f 'macps.config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'macps.config'\"
else
echo shar: Extracting \"'macps.config'\" \(536 characters\)
sed "s/^X//" >'macps.config' <<'END_OF_FILE'
X# This is the config file read by macps.
X# SCCSid = "@(#)macps.config	2.2 10/24/89"
X#
X# Each line is composed of the %%IncludeProcSet id, a tab and the file
X# containing the ProcSet.  If the file doesn't begin with a slash, the
X# the name is taken to be relative to the directory in which this config file
X# resides.
X
X"(AppleDict md)" 65 0	ProcSets/LaserPrep4.0
X"(AppleDict md)" 66	ProcSets/LaserPrep5.0
X"(AppleDict md)" 67 0	ProcSets/LaserPrep5.1
X"(AppleDict md)" 68 0	ProcSets/LaserPrep5.2
X"(AppleDict md)" 70 0	ProcSets/LaserPrep6.0
END_OF_FILE
if test 536 -ne `wc -c <'macps.config'`; then
    echo shar: \"'macps.config'\" unpacked with wrong size!
fi
# end of 'macps.config'
fi
if test -f 'prepfix.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prepfix.1'\"
else
echo shar: Extracting \"'prepfix.1'\" \(2100 characters\)
sed "s/^X//" >'prepfix.1' <<'END_OF_FILE'
X.\" SCCSid = "@(#)prepfix.1	2.2 10/24/89"
X.TH PREPFIX 1 "24 Oct 1989"
X.UC 4
X.SH NAME
prepfix \- converts Apple LaserPrep files to form useable on Unix
X.SH SYNOPSIS
X.B prepfix
X[
X\-l
printer_name1
X[
X\-l
printer_name2
X]...
X]
X[
file
X]
X.SH DESCRIPTION
X.I Prepfix
takes the command-line LaserPrep file (or the standard input if no filename is
given), and converts it into a form that is useable on Unix with the
X.IR macps (1),
and is even electronically mailable.
X.PP
To use
X.IR prepfix ,
create the input LaserPrep file on a Macintosh by opening an empty
document in some application, selecting
X.B Print
X>From the
X.B File
menu and then typing (and holding) Command-K immediately after clicking the
X.B OK
button in the LaserWriter print dialog box.
Another dialog will appear, confirming that a file named ``PostScript'' is
being created (the Command-K keys can be released now).
X.PP
Depending on the application, the created PostScript file can be found in the
System Folder, the application folder or the top level of the disk.
This file can then be uploaded via some file transfer program, such as
MacTerminal/VersaTerm and
X.IR macget (1)
or MacKermit/Red Ryder and
X.IR kermit (1).
X.PP
Normally, only Apple LaserWriters can take advantage of the bit smoothing
feature of the LaserPrep file.
However, other PostScript laser printer using the Motorola 680x0 processor
and the Adobe PostScript firmware can be made to do bit smoothing by
specifying for each printer the
X.B \-l
option and the printer's name, as returned by the PostScript
X.B product
command in
X.B statusdict
X(remember to quote the printer name if it contains blanks).
The resulting LaserPrep file will be modified so that for LaserWriters and for
printers specified in the
X.B \-l
option, bit smoothing will be allowed (smoothing must still be selected in the
Print Dialog box when saving the PostScript to disk).
More than one printer name can be specified using additional
X.B \-l
and printer name pairs.
X.SH "SEE ALSO"
macps(1), macget(1), kermit(1)
X.SH BUGS
X.I Prepfix
only works with version 4.0 and up of the Macintosh LaserPrep files.
END_OF_FILE
if test 2100 -ne `wc -c <'prepfix.1'`; then
    echo shar: \"'prepfix.1'\" unpacked with wrong size!
fi
# end of 'prepfix.1'
fi
if test -f 'prepfix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prepfix.c'\"
else
echo shar: Extracting \"'prepfix.c'\" \(5999 characters\)
sed "s/^X//" >'prepfix.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, The Regents of the University of California.
X * Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X * Information Systems and Technology.
X *
X * Permission is granted to any individual or institution to use, copy,
X * or redistribute this software so long as it is not sold for profit,
X * provided that this notice and the original copyright notices are
X * retained.  The University of California makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X */
X
X#ifndef lint
static char *SCCSid = "@(#)prepfix.c	2.2 10/25/89";
X#endif lint
X
X#include <ctype.h>
X#include <stdio.h>
X#ifdef SYSV
X#include <string.h>
X#else SYSV
X#include <strings.h>
X#endif SYSV
X#include "str.h"
X
X#define	CLEARTOMARK	12
X#define EEXECLEN	80
X#define EXTRA		(NZEROLINE * ZEROLINE + CLEARTOMARK)
X#define LINELEN		256
X#define	NPRODUCTS	32
X#define NZEROLINE	7
X#define ZEROLINE	65
X#ifdef SYSV
X#define	index		strchr
X#define	rindex		strrchr
X#endif SYSV
X
char exstr[] = "\
X%ck userdict/%s known not and{currentfile eexec}{%d{currentfile read\n\
pop pop}repeat}ifelse\n\
X";
char *match();
char *myname;
int maxproducts = NPRODUCTS;
int nproducts = 0;
char Ok[] = "\
X/Ok{ok{true}{save /Pd statusdict /product get def false 0 1 ProdArr length\n\
X1 sub{Pd exch ProdArr exch get anchorsearch exch pop{pop pop true exit}if}for\n\
exch restore}ifelse}bind def\n\
X";
char ProdArr0[] = "/ProdArr [\n";
char ProdArr1[] = "] def\n";
char **products;
char tempname[] = "/tmp/prepfixXXXXXX";
X
main(argc, argv)
int argc;
char **argv;
X{
X	register STR *str;
X	register FILE *tp;
X	register int i;
X	register unsigned char *lp;
X	char buf[BUFSIZ];
X	char *malloc(), *realloc();
X
X	if(myname = rindex(*argv, '/'))
X		myname++;
X	else
X		myname = *argv;
X	for(argc--, argv++ ; argc > 0 && **argv == '-' ; argc--, argv++) {
X		switch((*argv)[1]) {
X		 case 'h':
X			usage();
X		 case 'l':
X			if(nproducts <= 0 && (products =
X			 (char **)malloc(maxproducts*sizeof(char *))) == NULL) {
X				fprintf(stderr,
X				 "%s: Out of memory creating products array\n",
X				 myname);
X				exit(1);
X			} else if(nproducts >= maxproducts - 1 && (products =
X			 (char **)realloc(products, (maxproducts += NPRODUCTS)
X			 * sizeof(char *))) == NULL) {
X				fprintf(stderr,
X				 "%s: Out of memory expanding products array\n",
X				 myname);
X				exit(1);
X			}
X			if((*argv)[2])
X				products[nproducts++] = &(*argv)[2];
X			else {
X				if(argc < 2) {
X					fprintf(stderr,
X					 "%s: No argument for -l\n", myname);
X					exit(1);
X				}
X				argc--;
X				argv++;
X				products[nproducts++] = *argv;
X			}
X			break;
X		}
X	}
X	if(argc > 1)
X		usage();
X	if(argc > 0 && freopen(*argv, "r", stdin) == NULL) {
X		fprintf(stderr, "%s: Can't open %s\n", myname, *argv);
X		exit(1);
X	}
X	mktemp(tempname);
X	if((tp = fopen(tempname, "w+")) == NULL) {
X		fprintf(stderr, "%s: Can't create temp file %s\n",
X		 myname, tempname);
X		exit(1);
X	}
X	unlink(tempname);
X	str = STRalloc();
X	if(!STRgets(str, stdin)) {
X		fprintf(stderr, "%s: Null input\n", myname);
X		exit(1);
X	}
X	for( ; ; ) {
X		if(STRheadcompare(str, "% \251") == 0) {
X			fputs("% ", tp);
X			str->bufptr[0] = '(';
X			str->bufptr[1] = 'C';
X			str->bufptr[2] = ')';
X		} else if(STRheadcompare(str, "%%BeginProcSet:") == 0) {
X			STRputs(str, stdout);
X			fseek(tp, 0L, 0);
X			while((i = fread(buf, 1, BUFSIZ, tp)) > 0)
X				fwrite(buf, 1, i, stdout);
X			fclose(tp);
X			break;
X		}
X		STRputs(str, tp);
X		if(!STRgets(str, stdin)) {
X			fprintf(stderr, "%s: No BeginProcSet\n", myname);
X			exit(1);
X		}
X	}
X	while(STRgets(str, stdin)) {
X		if(nproducts > 0 && STRheadcompare(str, "/ok{") == 0) {
X			STRputs(str, stdout);
X			fputs(ProdArr0, stdout);
X			for(i = 0 ; i < nproducts ; i++)
X				printf("(%s)\n", products[i]);
X			fputs(ProdArr1, stdout);
X			fputs(Ok, stdout);
X			continue;
X		} else if(STRmatch(str, "setdefaulttimeouts")
X		 || STRmatch(str, "setsccinteractive"))
X			continue;
X		else if(STRmatch(str, "/stretch") && STRmatch(str, "eexec")) {
X			eexec("stretch", str);
X			continue;
X		} else if(STRmatch(str, "/smooth4") && STRmatch(str, "eexec")) {
X			eexec("smooth4", str);
X			continue;
X		} else if(STRmatch(str, " checkload")) {
X			checkload(str);
X			continue;
X		} else if(STRmatch(str, "(LaserWriter II NT)")) {
X			while(STRgets(str, stdin) && STRheadcompare(str, "35de")
X			 != 0)
X				{ /* ignore line */ }
X			while(STRgets(str, stdin) && isxdigit(*str->bufptr))
X				{ /* ignore line */ }
X		} else if(lp = STRmatch(str, "scaleby96{ppr")) {
X			STRputsptr(str, lp, stdout);
X			continue;
X		} else if(STRmatch(str, "waittimeout"))
X			continue;
X		else if(STRheadcompare(str, "%%EndProcSet") == 0) {
X			STRputs(str, stdout);
X			break;
X		}
X		STRputs(str, stdout);
X	}
X	exit(0);
X}
X
eexec(name, str)
char *name;
register STR *str;
X{
X	register int len;
X
X	if(!STRgets(str, stdin)) {
X		fprintf(stderr, "%s: EOF during reading eexec\n", myname);
X		exit(1);
X	}
X	len = (str->curendptr - str->bufptr) - 1;
X	printf(exstr, nproducts > 0 ? 'O' : 'o', name, len + (len / EEXECLEN)
X	 + (len % EEXECLEN ? 1 : 0) + EXTRA);
X	spliteexec(str);
X}
X
checkload(str)
register STR *str;
X{
X	if(nproducts > 0)
X		*str->bufptr = 'O';
X	STRputs(str, stdout);
X	if(!STRgets(str, stdin)) {
X		fprintf(stderr, "%s: EOF during reading eexec\n", myname);
X		exit(1);
X	}
X	spliteexec(str);
X}
X
spliteexec(str)
register STR *str;
X{
X	register int len;
X	register unsigned char *bp;
X
X	bp = str->bufptr;
X	len = (str->curendptr - bp) - 1;
X	while(len >= 80) {
X		fwrite(bp, 80, 1, stdout);
X		putchar('\n');
X		bp += 80;
X		len -= 80;
X	}
X	if(len > 0) {
X		fwrite(bp, len, 1, stdout);
X		putchar('\n');
X	}
X	for( ; ; ) {
X		if(!STRgets(str, stdin)) {
X			fprintf(stderr, "%s: EOF reached before cleartomark\n",
X			 myname);
X			exit(1);
X		}
X		STRputs(str, stdout);
X		if(STRheadcompare(str, "cleartomark") == 0)
X			return;
X	}
X}
X
usage()
X{
X	fprintf(stderr,
X	 "Usage: %s [-l product_name1 [-l product_name2]...] [file]\n",
X	 myname);
X	fprintf(stderr, "       %s -help\n", myname);
X	exit(1);
X}
END_OF_FILE
if test 5999 -ne `wc -c <'prepfix.c'`; then
    echo shar: \"'prepfix.c'\" unpacked with wrong size!
fi
# end of 'prepfix.c'
fi
if test -f 'str.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'str.h'\"
else
echo shar: Extracting \"'str.h'\" \(1160 characters\)
sed "s/^X//" >'str.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, The Regents of the University of California.
X * Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X * Information Systems and Technology.
X *
X * Permission is granted to any individual or institution to use, copy,
X * or redistribute this software so long as it is not sold for profit,
X * provided that this notice and the original copyright notices are
X * retained.  The University of California makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X */
X
X/*
X * SCCSid = "@(#)str.h	2.2 10/24/89"
X */
X
X#define	STRSIZEDELTA	1024
X#define	STRSIZE		1024
X
X#define	STRcompare(str,fp)	STRcompareptr((str), (str)->bufptr, (fp))
X#define	STRheadcompare(str,fp)	STRheadcmpptr((str), (str)->bufptr, (fp))
X#define	STRputs(str,fp)		STRputsptr((str), (str)->bufptr, (fp))
X
typedef struct {
X	unsigned char *bufptr;
X	unsigned char *curendptr;
X	unsigned char *realendptr;
X} STR;
X
extern int rawmode;
X
STR *STRalloc();
int STRcompareptr();
int STRfree();
int STRgets();
int STRheadcmpptr();
unsigned char *STRmatch();
int STRputsptr();
END_OF_FILE
if test 1160 -ne `wc -c <'str.h'`; then
    echo shar: \"'str.h'\" unpacked with wrong size!
fi
# end of 'str.h'
fi
if test -f 'ucbwhich.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ucbwhich.c'\"
else
echo shar: Extracting \"'ucbwhich.c'\" \(3273 characters\)
sed "s/^X//" >'ucbwhich.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, The Regents of the University of California.
X * Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X * Information Systems and Technology.
X *
X * Permission is granted to any individual or institution to use, copy,
X * or redistribute this software so long as it is not sold for profit,
X * provided that this notice and the original copyright notices are
X * retained.  The University of California makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X */
X
X#ifndef CONFIGDIR
X#ifndef lint
static char *SCCSid = "@(#)ucbwhich.c	2.2 10/24/89";
X#endif lint
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include "ucbwhich.h"
X
X#define	F_OK		0	/* does file exist */
X#define	X_OK		1	/* is it executable by caller */
X#define	W_OK		2	/* writable by caller */
X#define	R_OK		4	/* readable by caller */
X
X#define	LIBLEN		4
X#ifdef SYSV
X#define	index		strchr
X#define	rindex		strrchr
X#endif SYSV
X
static char lib[] = "/lib";
X
char ucblib[UCBMAXPATHLEN];
int ucbalternate = 0;
char ucbpath[UCBMAXPATHLEN];
X
ucbwhich(str)
char *str;
X{
X	register char *dir, *name, *cp, *tp;
X	register int len;
X	char dirbuf[UCBMAXPATHLEN], namebuf[UCBMAXPATHLEN];
X	struct stat sbuf;
X	char *index(), *rindex(), *getwd(), *getenv();
X
X	strcpy(name = namebuf, str);
X	if(*name == '/')	/* absolute pathname */
X		*(rindex(dir = name, '/')) = 0 ; /* remove tail */
X	else {
X		if(cp = index(name, '/')) { /* relative pathname */
X			if((dir = getwd(dirbuf)) == NULL)
X				return(0);
X			 /* if any errors occurs assume standard version */
X			*cp++ = 0;
X			for( ; ; ) {
X				if(*name != 0) { /* multiple slashes */
X					if(strcmp(name, "..") == 0) {
X						/* parent directory */
X						if((tp = rindex(dir, '/')) ==
X						 NULL)
X						 	return(0);
X						if(tp == dir)
X							tp++;
X						 /* root directory */
X						*tp = 0;
X						 /* remove last component */
X					} else if(strcmp(name, ".") != 0) {
X						/* subdirectory */
X						strcat(dir, "/");
X						strcat(dir, name);
X					}
X				}
X				name = cp;
X				if((cp = index(name, '/')) == NULL) break;
X				/* ignore last component */
X				*cp++ = 0;
X			}
X		} else { /* look through $PATH variable */
X			if((tp = getenv("PATH")) == NULL)
X				return(0);
X			for(name = namebuf ; ; ) {
X				if(*tp == 0)
X					return(0);
X				else if(*tp == ':')
X					tp++;
X				if((cp = index(tp, ':')) == NULL)
X					cp = tp + strlen(tp);
X				 /* positioned on null */
X				for(dir = dirbuf ; tp < cp ; )
X					*dir++ = *tp++;
X				*dir = 0;
X				strcpy(name, dir = dirbuf);
X				strcat(name, "/");
X				strcat(name, str);
X				if(stat(name, &sbuf) < 0 || (sbuf.st_mode &
X				 S_IFMT) != S_IFREG)
X					continue;
X				if(access(name, X_OK) == 0) {
X					if(strcmp(dir, ".") == 0 &&
X					 (dir = getwd(dirbuf)) == NULL)
X						return(0);
X					break;
X				}
X			}
X		}
X	}
X	strcpy(ucbpath, dir);
X	strcpy(ucblib, dir);
X	if((len = strlen(dir)) < LIBLEN || strcmp(&dir[len - LIBLEN], lib)
X	 != 0)
X		strcat(ucblib, lib);
X	else
X		ucbpath[len - LIBLEN] = 0;
X	ucbalternate = (strcmp(ucbpath, UCBSTANDARD) != 0);
X#ifdef EBUG
X	fprintf(stderr, "ucbwhich: alt=%d path=%s lib=%s\n", ucbalternate,
X	 ucbpath, ucblib);
X#endif EBUG
X	return(ucbalternate);
X}
X#endif CONFIGDIR
END_OF_FILE
if test 3273 -ne `wc -c <'ucbwhich.c'`; then
    echo shar: \"'ucbwhich.c'\" unpacked with wrong size!
fi
# end of 'ucbwhich.c'
fi
if test -f 'ucbwhich.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ucbwhich.h'\"
else
echo shar: Extracting \"'ucbwhich.h'\" \(778 characters\)
sed "s/^X//" >'ucbwhich.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, The Regents of the University of California.
X * Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X * Information Systems and Technology.
X *
X * Permission is granted to any individual or institution to use, copy,
X * or redistribute this software so long as it is not sold for profit,
X * provided that this notice and the original copyright notices are
X * retained.  The University of California makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X */
X
X/*
X * SCCSid = "@(#)ucbwhich.h	2.2 10/24/89"
X */
X
X#define	UCBMAXPATHLEN	128
X#define	UCBSTANDARD	"/usr/ucb"
X
extern char ucblib[];
extern int ucbalternate;
extern char ucbpath[];
END_OF_FILE
if test 778 -ne `wc -c <'ucbwhich.h'`; then
    echo shar: \"'ucbwhich.h'\" unpacked with wrong size!
fi
# end of 'ucbwhich.h'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
