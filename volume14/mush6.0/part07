From: island!argv@sun.com (Dan Heller)
Subject: Mail User's Shell, version 6.0

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 14)."
# Contents:  curses.c msgs.c
# Wrapped by rsalz@fig.bbn.com on Wed Apr 13 20:04:48 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'curses.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'curses.c'\"
else
echo shar: Extracting \"'curses.c'\" \(20603 characters\)
sed "s/^X//" >'curses.c' <<'END_OF_FILE'
X/* @(#)curses.c	(c) copyright 3/18/87 (Dan Heller) */
X
X/* curses.c -- routine to deal with the curses interface */
X#ifdef CURSES
X
X#include "mush.h"
X#include "bindings.h"
X
curses_init(argc, argv)
register char **argv;
X{
X    char buf[80];
X    extern char *UP, ttytype[];
X
X    if (argv && *++argv && !strcmp(*argv, "-?"))
X	return help(0, "curses", cmd_help);
X    if (iscurses) {
X	print("You can't run curses from the curses mode (silly).");
X	return -1;
X    }
X    if (ison(glob_flags, IS_GETTING)) {
X	print("Finish your letter first.\n");
X	return -1;
X    }
X#ifdef SUNTOOL
X    if (istool) {
X	print("My, aren't we the adventuresome type!");
X	timerclear(&(mail_timer.it_interval));
X	timerclear(&(mail_timer.it_value));
X	tool_destroy(tool), istool = FALSE;
X	curses_init(0, 0);
X	do_loop(); /* doesn't return */
X    }
X#endif /* SUNTOOL */
X
X#ifndef attrset		/* terminfo version of curses */
X    /* you can not start curses in no echo mode.. must be in normal mode */
X    echom();
X    nocrmode();
X#endif /* attrset */
X    (void) initscr();
X#ifdef SIGCONT
X    /* initscr will play with signals -- make sure they're set right. */
X    (void) signal(SIGTSTP, stop_start);
X    (void) signal(SIGCONT, stop_start);
X#endif /* SIGCONT */
X#if !defined(SYSV) && !defined(USG)
X    if (!UP || !*UP)
X#else /* ~SYSV && ~USG */
X    if (!stdscr)
X#endif /* ~SYSV && ~USG */
X		 {
X	print("Terminal type %s can not use the curses interface.\n", ttytype);
X	return -1;
X    }
X    iscurses = TRUE;
X    noechom(); /* reset tty state -- */
X    crmode(); /* do not use "echo_on/off()" */
X    scrollok(stdscr, TRUE);
X    /* if the user hasn't set his screen explicitely, set it for him */
X    if (!do_set(set_options, "screen"))
X#ifdef USG
X	switch (_tty.sg_ospeed & CBAUD)
X#else /* USG */
X	switch (_tty.sg_ospeed)
X#endif /* USG */
X	{
X	    case B300 :  screen = min(LINES-2, 7);
X	    when B1200 : screen = min(LINES-2, 14);
X	    when B2400 : screen = min(LINES-2, 22);
X	    otherwise :  screen = LINES-2;
X	}
X    else
X	screen = min(screen, LINES-2);
X    crt = LINES;
X    (void) cmd_line(sprintf(buf, "set screen = %d crt = %d", screen, crt),
X	msg_list);
X    if (argc)
X	(void) cmd_line(sprintf(buf, "headers %d", current_msg+1), msg_list);
X    if (!do_set(set_options, "no_reverse"))
X	turnon(glob_flags, REV_VIDEO);
X    turnoff(glob_flags, CONT_PRNT);
X    return -1; /* doesn't affect messages */
X}
X
X/*
X * get input in cbreak mode and execute the appropriate command.
X * when the command is done (usually), the user is prompted to
X * hit any key to continue. At this point, the user may enter a
X * new command so no screen refreshing needds to be done. This
X * new command is returned to caller and may be passed back.
X *
X * The flag CNTD_CMD (continued command) is set if
X * this routine is called with the passed parameter (c) > 0. If
X * so, then the character passed is the character input by the
X * user at the last "hit return" prompt indicating that he wants
X * to execute a new command and not draw the screen.
X *
X * CNTD_CMD is also set if the command that the user invokes
X * causes any sort of output that requires a screen refresh.  The
X * variable redo is set to 1 if the header page not only requires
X * redrawing, but updating ... (new call to do_hdrs)
X *
X * calls that say: print("%s", compose_hdr(current_msg)) are constructed
X * that way cuz if the header has a `%' in it, then print will try to
X * expand it.
X */
curses_command(c)
register int c;
X{
X    char 	buf[BUFSIZ], file[128], list[128];
X    int 	n, curlin;
X    static int  redo;  /* set if headers should be redrawn */
X
X    if (c > 0)
X	turnon(glob_flags, CNTD_CMD);
X    else
X	turnoff(glob_flags, CNTD_CMD);
X    clear_msg_list(msg_list); /* play it safe */
X    if (isoff(glob_flags, CNTD_CMD)) {
X	(void) check_new_mail();
X	curlin = max(1, current_msg - n_array[0] + 1);
X	(void) strncpy(buf, stdscr->_y[curlin], COLS-1);
X	buf[COLS-1] = 0; /* strncpy does not null terminate */
X	if (ison(glob_flags, REV_VIDEO) && msg_cnt)
X	    STANDOUT(curlin, 0, buf);
X	mail_status(0);
X	move(curlin, 0), refresh();
X	/* reprint to remove reverse video from current line (don't refresh) */
X	if (ison(glob_flags, REV_VIDEO))
X	    mvaddstr(curlin, 0, buf);
X	c = getcmd(); /* get input AFTER line redrawn without reverse video */
X    }
X    buf[0] = list[0] = file[0] = '\0';
X
X    /* goto a specific line number */
X    if (c == C_GOTO_MSG) {
X	c = C_NULL;
X	if (msg_cnt <= 1)
X	    print("Not enough messages."), getchar(); /* flush digit typed */
X	else if (curses_msg_list(strcpy(buf, "goto msg: "), list, msg_list)) {
X	    n = current_msg;
X	    do if (++n >= msg_cnt)
X		n = 0;
X	    while (n != current_msg && !msg_bit(msg_list, n));
X	    if (n == current_msg && !msg_bit(msg_list, n))
X		print("Message not found.");
X	    else if ((current_msg = n) < n_array[0] || n > n_array[screen-1])
X		redo = 1;
X	}
X	if (ison(glob_flags, CNTD_CMD) && msg_cnt)
X	    print("%-.*s", COLS-2, compose_hdr(current_msg));
X	if (ison(glob_flags, CNTD_CMD))
X	    putchar('\n');
X    } else if (c == C_WRITE_LIST || c == C_SAVE_LIST || c == C_COPY_LIST
X			       || c == C_DELETE_LIST || c == C_UNDEL_LIST) {
X	
X	if (msg_cnt <= 1)
X	    print("Not enough messages."), c = C_NULL;
X	else if (ison(glob_flags, READ_ONLY))
X	    print("Folder is read-only."), c = C_NULL;
X	else if (!curses_msg_list(sprintf(buf, "%s msg list: ",
X		(c == C_WRITE_LIST)? "write" : (c == C_SAVE_LIST)?  "save" :
X		(c == C_DELETE_LIST)? "delete" : "undelete"), list, msg_list))
X	    c = C_NULL;
X	if (ison(glob_flags, CNTD_CMD))
X	    putchar('\n');
X    }
X
X    /* first do non-mail command stype stuff */
X    switch (c) {
X	case C_NULL : ;
X
X	/* screen optimization stuff */
X	when C_REVERSE :
X	    if (ison(glob_flags, REV_VIDEO))
X		turnoff(glob_flags, REV_VIDEO);
X	    else
X		turnon(glob_flags, REV_VIDEO);
X
X	when C_REDRAW : if (!redo) redraw();
X
X	/*
X	 * screen movement
X	 */
X	when C_NEXT_MSG :
X	/* case 'j' : case 'J' : case '+' : case '\n' : /* next */
X	    if (current_msg + 2 > msg_cnt ||
X		isoff(glob_flags, CNTD_CMD) && curlin == screen)
X		bell(); /* reached the end */
X	    else {
X		if (++current_msg > n_array[screen-1])
X		    redo = 1;
X		if (ison(glob_flags, CNTD_CMD)) {
X		    print("%-.*s", COLS-2, compose_hdr(current_msg));
X		    putchar('\n');
X		}
X	    }
X
X	when C_PREV_MSG :
X	/* when 'k' : case 'K' : case '-' : case CTRL(k) : /* previous */
X	    if (isoff(glob_flags, CNTD_CMD) && curlin == 1 || current_msg == 0)
X		bell();  /* at the beginning */
X	    else {
X		if (--current_msg < n_array[0])
X		    redo = 1;
X		if (ison(glob_flags, CNTD_CMD)) {
X		    print("%-.*s", COLS-2, compose_hdr(current_msg));
X		    putchar('\n');
X		}
X	    }
X
X	when C_FIRST_MSG : case C_LAST_MSG :
X	    n = current_msg;
X	    move(LINES-1, 0), refresh();
X	    if (c == C_FIRST_MSG && (current_msg = 0) < n_array[0] ||
X		c == C_LAST_MSG && (current_msg = msg_cnt-1)> n_array[screen-1])
X		if (isoff(glob_flags, CNTD_CMD))
X		    (void) cmd_line(sprintf(buf, "headers %d", current_msg+1),
X			     msg_list);
X		else
X		    redo = 1;
X	    if (ison(glob_flags, CNTD_CMD) && n != current_msg)
X		print("%-.*s", COLS-2, compose_hdr(current_msg)), putchar('\n');
X
X	/* top and bottom of headers screen */
X	when C_TOP_PAGE : case C_BOTTOM_PAGE :
X	    if (isoff(glob_flags, CNTD_CMD))
X		if (c == C_TOP_PAGE)
X		    current_msg = n_array[0];
X		else
X		    current_msg = min(n_array[screen-1], msg_cnt-1);
X	    else
X		bell();
X
X	when C_NEXT_SCREEN : /* next page */
X	    move(LINES-1, 0), refresh();
X	    if (msg_cnt > screen) {
X		clear();
X		(void) cmd_line(strcpy(buf, "headers +"), msg_list);
X		current_msg = n_array[0];
X		return redo = 0;
X	    } else
X		bell();
X
X	when C_PREV_SCREEN : /* previous page */
X	    move(LINES-1, 0), refresh();
X	    if (n_array[0] > 0) {
X		clear();
X		(void) cmd_line(strcpy(buf, "headers -"), msg_list);
X		current_msg = n_array[0];
X		return redo = 0;
X	    } else
X		bell();
X
X	when C_SHOW_HDR :
X	    if (ison(glob_flags, CNTD_CMD) && msg_cnt)
X		puts(compose_hdr(current_msg));
X
X	/* read from/save to record file (.mushrc) */
X	when C_SOURCE : case C_SAVEOPTS : {
X	    int argc;
X	    char *argv[3];
X	    print("%s filename [default]: ",
X		(c == C_SOURCE)? "source" : "save options to");
X	    argc = Getstr(file, LINES-40, 0);
X	    clr_bot_line();
X	    if (argc < 0)
X		return 0;
X	    if (argc > 0)
X		argv[1] = file, argc = 2;
X	    else
X		argc = 1;
X	    argv[argc] = NULL;
X	    turnon(glob_flags, PRE_CURSES);
X	    if (c == C_SOURCE)
X		(void) source(argc, argv);
X	    else
X		(void) save_opts(argc, argv);
X	    turnoff(glob_flags, PRE_CURSES);
X	}
X
X	/*
X	 * search commands
X	 */
X	when C_NEXT_SEARCH : case C_PREV_SEARCH : case C_CONT_SEARCH :
X	    if (c != C_CONT_SEARCH)
X		c = search(0 + (c == C_PREV_SEARCH));
X	    else
X		c = search(-1);
X	    if (ison(glob_flags, CNTD_CMD))
X		putchar('\n');
X	    if (c == 0)
X		break;
X	    if (ison(glob_flags, CNTD_CMD))
X		print("%-.*s",COLS-2, compose_hdr(current_msg)), putchar('\n');
X	    if (n_array[0] > current_msg || n_array[screen-1] < current_msg) {
X		redo = 1;
X		if (isoff(glob_flags, CNTD_CMD))
X		    (void) cmd_line(sprintf(buf, "headers %d",
X					    current_msg+1), msg_list);
X	    }
X
X	/*
X	 * actions on messages
X	 */
X	/* delete/undelete */
X	when C_DELETE_MSG : case C_DELETE_LIST :
X	case C_UNDEL_MSG : case C_UNDEL_LIST :
X	    if (!msg_cnt) {
X		print("No messages.");
X		if (ison(glob_flags, CNTD_CMD))
X		    putchar('\n');
X		break;
X	    }
X	    if (ison(glob_flags, READ_ONLY)) {
X		print("Folder is read-only.");
X		if (ison(glob_flags, CNTD_CMD))
X		    putchar('\n');
X		break;
X	    }
X	    if (!*list)
X		set_msg_bit(msg_list, current_msg);
X	    turnon(glob_flags, DO_UPDATE);
X	    for (n = 0; n < msg_cnt; n++)
X		if (msg_bit(msg_list, n)) {
X		    if (c == C_DELETE_MSG || c == C_DELETE_LIST)
X			turnon(msg[n].m_flags, DELETE);
X		    else
X			turnoff(msg[n].m_flags, DELETE);
X		    if (isoff(glob_flags, CNTD_CMD) && (msg_cnt < screen ||
X			n >= n_array[0] && n <= n_array[screen-1]))
X			mvprintw(max(1, n - n_array[0] + 1), 0,
X			    "%-.*s", COLS-1, compose_hdr(n));
X		    else
X			redo = 1;
X		}
X	    if (ison(glob_flags, CNTD_CMD) || *list) {
X		/* print(), THEN putchar() -- overwrite line */
X		if (ison(glob_flags, CNTD_CMD)) {
X		    print("%sdeleted %s",
X		    (c == C_DELETE_MSG || c == C_DELETE_LIST)? "":"un", list);
X		    putchar('\n');
X		}
X		if (ison(msg[current_msg].m_flags, DELETE))
X		    (void) next_msg();
X		if (isoff(msg[current_msg].m_flags, DELETE) &&
X		    do_set(set_options, "autoprint"))
X		    return C_DISPLAY_MSG;
X		if (ison(glob_flags, CNTD_CMD))
X		    puts(compose_hdr(current_msg));
X	    }
X
X	/*
X	 * write/save messages.  If a list is necessary, the user already
X	 * entered it above since he must have used a capital letter. If so,
X	 * list will contain good data (already been validated above).
X	 * if a list is given, set iscurses to 0 so that print statements
X	 * will scroll and the user sees the multiple output. else, one
X	 * line can go on the bottom line just fine.
X	 */
X	when C_WRITE_MSG : case C_SAVE_MSG : case C_COPY_MSG :
X	case C_WRITE_LIST : case C_SAVE_LIST : case C_COPY_LIST : {
X	    register char *p =
X		(c == C_WRITE_MSG || c == C_WRITE_LIST)? "write" :
X		(c == C_SAVE_MSG  || c == C_SAVE_LIST)? "save" : "copy";
X	    if (!msg_cnt) {
X		print("No messages.");
X		if (ison(glob_flags, CNTD_CMD))
X		    putchar('\n');
X		break;
X	    }
X	    print(sprintf(buf, "filename to %s%s: ", p,
X		(c != C_WRITE_MSG && c != C_WRITE_LIST)? " [mbox]" : ""));
X	    if (Getstr(file, COLS-1-strlen(buf), 0) >= 0) {
X		char *argv[3];
X		clr_bot_line();
X		argv[0] = strcpy(buf, p);
X		argv[1] = (*file) ? file : NULL;
X		argv[2] = NULL;
X		if (!*list)
X		    set_msg_bit(msg_list, current_msg);
X		move(LINES-1, 0), refresh();
X		if (*list)
X		    iscurses = FALSE;
X		/* Turn on piping to make save_msg look at msg_list */
X		turnon(glob_flags, IS_PIPE);
X		if (save_msg(1 + (*file != '\0'), argv, msg_list) < 0)
X		    *list = 0;
X		turnoff(glob_flags, IS_PIPE);
X		if (ison(glob_flags, CNTD_CMD))
X		    redo = 1, putchar('\n'), puts(compose_hdr(current_msg));
X		if (*list)
X		    iscurses = redo = TRUE, turnon(glob_flags, CNTD_CMD);
X		else if (isoff(glob_flags, CNTD_CMD) && msg_cnt)
X		    mvprintw(curlin, 0, "%-.*s",
X			COLS-1, compose_hdr(current_msg));
X	    } else {
X		print("No messages saved.");
X		if (ison(glob_flags, CNTD_CMD))
X		    putchar('\n');
X	    }
X	}
X
X	/* preserve message */
X	when C_PRESERVE :
X	    if (!msg_cnt) {
X		print("No messages.");
X		if (ison(glob_flags, CNTD_CMD))
X		    putchar('\n');
X		break;
X	    }
X	    if (ison(msg[current_msg].m_flags, PRESERVE))
X		turnoff(msg[current_msg].m_flags, PRESERVE);
X	    else
X		turnon(msg[current_msg].m_flags, PRESERVE);
X	    turnon(glob_flags, DO_UPDATE);
X	    if (ison(glob_flags, CNTD_CMD)) {
X		wprint("%-.*s\n", COLS-1, compose_hdr(current_msg));
X		redo = 1;
X	    } else
X		mvprintw(curlin, 0, "%-.*s", COLS-1, compose_hdr(current_msg));
X
X	/* order messages (sort) and rediesplay the headers */
X	when C_SORT : case C_REV_SORT :
X	    (void) strcpy(file, "sort");
X	    if (c == C_REV_SORT) {
X		print("Reverse "), turnon(glob_flags, CONT_PRNT);
X		(void) strcat(file, " -");
X	    }
X	    print("Order messages by [Status, date, subject, author]: ");
X	    if ((c = getchar()) == 's' || c == 'S' || c == 'd' || c == 'a') {
X		print("reordering messages...");
X		(void) cmd_line(sprintf(buf, "%s %c", file, c), msg_list);
X		print_more("done.");
X		if (ison(glob_flags, CNTD_CMD))
X		    putchar('\n'), puts(compose_hdr(current_msg));
X		redo = 1;
X	    } else
X		clr_bot_line();
X
X	when C_QUIT_HARD :
X	    (void) quit(0, DUBL_NULL);
X	    redo = 1; /* new mail must have come in */
X
X	/* quit or update -- vrfy_update (returns 1 if updated) */
X	when C_QUIT : case C_UPDATE : {
X	    u_long do_update = ison(glob_flags, DO_UPDATE);
X	    clr_bot_line();
X	    if (!vrfy_update(&redo))
X		if (c == C_UPDATE)
X		    break;
X		else
X		    turnoff(glob_flags, DO_UPDATE);
X	    if (c == C_QUIT) {
X		if (do_update)
X		    putchar('\n');
X		cleanup(0);
X		redo = 1;
X	    } else if (isoff(glob_flags, CNTD_CMD))
X		(void) cmd_line(sprintf(buf, "headers %d", current_msg+1),
X				msg_list);
X	}
X
X	when C_EXIT : case C_EXIT_HARD :
X	    clr_bot_line();
X	    iscurses = FALSE;
X	    if (c != C_EXIT && c != C_EXIT_HARD)
X		putchar('\n');
X	    cleanup(0);
X
X	/* change to a new folder */
X	when C_FOLDER :
X	    for (;;) {
X		int (*oldint)(), (*oldquit)();
X		on_intr();
X		print("New folder (?=list): ");
X		c = Getstr(file, COLS-22, 0);
X		off_intr();
X		if (c > 0) {
X		    if (!strcmp(file, "?")) {
X			clr_bot_line();
X			iscurses = 0;
X			puts("folders in your folder directory:");
X			(void) cmd_line(strcpy(buf, "folders"), msg_list);
X	puts("Precede folder names with a +. `%' to specify system mailbox.");
X			turnon(glob_flags, CNTD_CMD), iscurses = 1;
X			continue;
X		    }
X		    clearok(stdscr, FALSE);
X		    /* if vrfy_update doesn't verify, but folder command fails,
X		     * then we need to reset the updatability of curren folder
X		     */
X		    c = (ison(glob_flags, DO_UPDATE))? TRUE : FALSE;
X		    if (strcmp(file, "-?"))
X			(void) vrfy_update(&redo);
X		    move(LINES-1, 0), refresh();
X		    if (cmd_line(sprintf(buf, "folder ! -N %s", file),
X			     msg_list) == -1) {
X			if (c) /* remember state of updatability of folder */
X			    turnon(glob_flags, DO_UPDATE);
X			if (ison(glob_flags, CNTD_CMD))
X			    putchar('\n');
X		    } else
X			redo = 1, turnoff(glob_flags, CNTD_CMD);
X		    break;
X		} else {
X		    print("\"%s\" unchanged.", mailfile);
X		    if (ison(glob_flags, CNTD_CMD))
X			putchar('\n');
X		    break;
X		}
X	    }
X
X	/* shell escape */
X	when C_SHELL_ESC :
X	    print("Shell command: ");
X	    if (Getstr(file, COLS-24, 0) < 0)
X		clr_bot_line();
X	    else {
X		putchar('\n');
X		iscurses = FALSE;
X		(void) cmd_line(sprintf(buf, "sh %s", file), msg_list);
X		iscurses = TRUE;
X		turnon(glob_flags, CNTD_CMD);
X	    }
X
X	/* do a line-mode like command */
X	when C_CURSES_ESC :
X	    print(":");
X	    if (Getstr(buf, COLS-2, 0) < 0)
X		break;
X	    putchar('\n');
X	    iscurses = FALSE;
X	    if (!*buf) {
X		/* return -1 because iscurses = 0 is not enough! */
X		redo = 0;
X		endwin(); /* this turns echoing back on! */
X		echo_off();
X		return -1;
X	    }
X	    (void) cmd_line(buf, msg_list);
X	    /* they may have affected message status or had text output */
X	    turnon(glob_flags, CNTD_CMD), redo = 1;
X	    iscurses = TRUE;
X	    if (msg_cnt)
X		puts(compose_hdr(current_msg));
X
X	/* send message to printer */
X	when C_PRINT_MSG : (void) lpr(0, DUBL_NULL, msg_list);
X
X	/* cd */
X	when C_CHDIR :
X	    print("chdir to [.]: ");
X	    if (Getstr(file, COLS-12, 0) < 0)
X		break;
X	    clr_bot_line();
X	    (void) cmd_line(sprintf(buf, "cd %s", file), msg_list);
X	    if (ison(glob_flags, CNTD_CMD))
X		putchar('\n');
X
X	/* variable settings */
X	when C_VAR_SET : case C_IGNORE : case C_ALIAS : case C_OWN_HDR :
X	    curs_vars(c); /* CNTD_CMD is reset if there's output! */
X
X	when C_VERSION :
X	    (void) do_version();
X	    if (ison(glob_flags, CNTD_CMD))
X		putchar('\n');
X
X	when C_MAIL_FLAGS :
X	    print("flags [-?]: ");
X	    if ((c = Getstr(file, COLS-12, 0)) < 0)
X		break;
X	    putchar('\n');
X	    if (c == 0)
X		(void) strcpy(file, "-?");
X	/* Fall thru */
X	case C_MAIL : {
X	    u_long flgs = glob_flags;
X	    turnon(glob_flags, IGN_BANG);
X	    clr_bot_line();
X	    iscurses = FALSE;
X	    (void) cmd_line(sprintf(buf, "mail %s", file), msg_list);
X	    glob_flags = flgs;
X	    iscurses = TRUE, turnon(glob_flags, CNTD_CMD);
X	    if (msg_cnt)
X		print("%-.*s", COLS-2, compose_hdr(current_msg)), putchar('\n');
X	}
X
X	/* reply to mail */
X	when C_REPLY_SENDER : case C_REPLY_ALL : {
X	    register char *p = (c == C_REPLY_ALL)? "replyall" : "replysender";
X	    clr_bot_line();
X	    iscurses = FALSE;
X	    if (isoff(msg[current_msg].m_flags, REPLIED))
X		redo = 1;
X	    (void) cmd_line(sprintf(buf, "%s %d", p, current_msg+1),
X		msg_list);
X	    if (msg_cnt)
X		puts(compose_hdr(current_msg));
X	    iscurses = TRUE, turnon(glob_flags, CNTD_CMD);
X	}
X
X	/* type out a message */
X	when C_DISPLAY_MSG : case C_TOP_MSG : case C_DISPLAY_NEXT :
X	    if (!msg_cnt ||
X		c != C_DISPLAY_NEXT && ison(msg[current_msg].m_flags, DELETE)) {
X		if (!msg_cnt)
X		    print("No messages.");
X		else
X		    print("Message %d deleted; type 'u' to undelete.",
X				      current_msg+1);
X		if (ison(glob_flags, CNTD_CMD))
X		    putchar('\n');
X		break;
X	    }
X	    clr_bot_line();
X	    iscurses = FALSE;
X	    if (ison(glob_flags, CNTD_CMD))
X		putchar('\n');
X	    if (c == C_DISPLAY_MSG)
X		c = cmd_line(strcpy(buf, "type"), msg_list);
X	    else if (c == C_TOP_MSG)
X		c = cmd_line(strcpy(buf, "top"), msg_list);
X	    else
X		c = cmd_line(strcpy(buf, "next"), msg_list);
X	    if (c > -1)
X		turnon(glob_flags, CNTD_CMD), redo = 1;
X	    iscurses = TRUE;
X	    puts(compose_hdr(current_msg));
X
X	/* bind a key or string to a command */
X	when C_BIND :  case C_UNBIND : {
X	    char *argv[2];
X	    argv[0] = (c == C_BIND) ? "bind" : "unbind";
X	    argv[1] = NULL;
X	    if (bind_it(0, argv) < -1)
X		turnon(glob_flags, CNTD_CMD);
X	    else if (ison(glob_flags, CNTD_CMD)) /* if it was set anyway */
X		putchar('\n');
X	}
X
X	/* help stuff */
X	when C_HELP :
X	    (void) c_bind(NULL);
X	    turnon(glob_flags, CNTD_CMD);
X	    if (msg_cnt)
X		puts(compose_hdr(current_msg));
X
X	/* now do interactive stuff as if run from the mush shell */
X	otherwise :
X	    bell();
X	    if (ison(glob_flags, CNTD_CMD)) {
X		/* use print instead of puts to overwrite hit_return msg */
X		print("unknown command"), putchar('\n');
X		redo = 1;
X	    }
X    }
X
X    if (ison(glob_flags, CNTD_CMD)) {
X	int old_cnt = msg_cnt;
X	if (!(c = hit_return()) && !redo && msg_cnt == old_cnt)
X	    redraw();
X	clr_bot_line();
X	if (old_cnt !=  msg_cnt)
X	    redo = 1;
X	if (c)
X	    return c;
X    }
X    if (redo) {
X	n = current_msg;
X	clear();
X	if (msg_cnt < screen || n_array[0] < n && n < n_array[screen-1])
X	    (void) do_hdrs(0, DUBL_NULL, NULL);
X	else
X	    (void) cmd_line(sprintf(buf, "headers %d", n+1), msg_list);
X	redo = 0;
X    }
X    return 0;
X}
X
vrfy_update(redo)
int *redo;
X{
X    char buf[16];
X    int c;
X
X    /* update current folder */
X    if (ison(glob_flags, DO_UPDATE)) {
X	if (ison(glob_flags, READ_ONLY)) {
X	    print("Folder is read-only.");
X	    if (ison(glob_flags, CNTD_CMD))
X		putchar('\n');
X	    return 0;
X	}
X	print("Update folder [y]? ");
X	if ((c = getchar()) != 'y' && c != 'Y' && c != '\n' && !isspace(c)) {
X	    print("Folder unchanged.");
X	    if (ison(glob_flags, CNTD_CMD))
X		putchar('\n');
X	    return 0;
X	}
X	if (cmd_line(strcpy(buf, "update"), msg_list) != -1 &&
X	    ison(glob_flags, CNTD_CMD))
X	    *redo = 1, turnoff(glob_flags, CNTD_CMD);
X    }
X    turnoff(glob_flags, DO_UPDATE);
X    return 1; /* make sure bottom line is clear and no reverse video */
X}
X#endif /* CURSES */
END_OF_FILE
if test 20603 -ne `wc -c <'curses.c'`; then
    echo shar: \"'curses.c'\" unpacked with wrong size!
fi
# end of 'curses.c'
fi
if test -f 'msgs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'msgs.c'\"
else
echo shar: Extracting \"'msgs.c'\" \(19132 characters\)
sed "s/^X//" >'msgs.c' <<'END_OF_FILE'
X/* @(#)msgs.c	(c) copyright 10/18/86 (Dan Heller) */
X
X#include "mush.h"
X#ifdef SYSV
X#ifndef USG
X#include <sys/locking.h>
X#else /* USG */
X#include <unistd.h>
X#endif /* USG */
X#endif /* SYSV */
X
lock_file(filename, fd)
char *filename;
X{
X#ifdef SYSV
X#ifndef USG
X    (void) locking(fd, LK_LOCK, 0); /* xenix */
X#else
X    /* if unable to lock, tell them */
X    if (Access(filename, W_OK) || lockf(fd, F_TLOCK, 0)) /* system-v */
X	return -1;
X#endif /* USG */
X#else
X#ifdef BSD
X    if (flock(fd, LOCK_SH))  /* if exclusively locked, flock blocks */
X	return -1;
X#else /* BSD */
X    "There is no supported file locking function compiled in this version!";
X#endif /* BSD */
X#endif /* SYSV */
X    return 0;
X}
X
close_lock(fp)
FILE *fp;
X{
X#ifdef SYSV
X#ifndef USG
X    locking(fileno(fp), LK_UNLCK, 0);
X#else
X    lockf(fileno(fp), F_ULOCK, 0);
X#endif /* USG */
X#endif /* SYSV */
X    fclose(fp);			/* implicit unlock for BSD */
X}
X
void
display_msg(n, flg)
register int n;
long flg;
X{
X    register FILE *pp;
X
X    if (ison(msg[n].m_flags, DELETE)) {
X	print("Message %d deleted; ", n+1);
X#ifdef SUNTOOL
X	if (istool)
X	    print_more("Select UNDELETE to read."), do_clear();
X	else
X#endif /* SUNTOOL */
X	if (iscurses)
X	    print_more("Type 'u' to undelete.");
X	else
X	    print("Type 'undelete %d' to undelete\n", n+1);
X	return;
X    }
X    set_isread(n);
X    if (ison(flg, TOP)) {
X	turnon(flg, NO_HEADER);
X	print("Top of "), turnon(glob_flags, CONT_PRNT);
X    }
X
X    if (!istool && isoff(flg, NO_PAGE) &&
X	    crt < msg[n].m_lines && isoff(flg, TOP)) {
X	char buf[32], *pager = do_set(set_options, "pager");
X	if (!pager)
X	    pager = DEF_PAGER;
X	if (!*pager || !strcmp(pager, "internal"))
X	    pager = NULL; /* default to internal pager if pager set to "" */
X	(void) do_pager(pager, TRUE); /* start pager */
X	(void) do_pager(sprintf(buf, "Message #%d (%d lines)\n",
X			 n+1, msg[n].m_lines), FALSE);
X	(void) copy_msg(n, NULL_FILE, flg);
X	(void) do_pager(NULL, FALSE); /* end pager */
X    } else {
X	print("Message #%d (%d lines)\n", n+1, msg[n].m_lines);
X	(void) copy_msg(n, stdout, flg);
X    }
X}
X
X/*
X * copy message 'n' to file "fp" according to various flag arguments
X * return number of lines copied or -1 if system error on fputs.
X * If "fp" is null, send to internal pager.  This can only happen from
X * display_msg above.
X */
copy_msg(n, fp, flags)
register int n;
long flags;
register FILE *fp;
X{
X    register int  ignoring = 0, lines = 0;
X    register char *indent_str;
X    int  on_hdr = 1, top, squeeze = FALSE;
X    char 	  line[BUFSIZ], *show_hdrs = NULL;
X
X    still_more = 0;
X    if (ison(flags, TOP)) {
X	register char *p = do_set(set_options, "toplines");
X	top = (p)? atoi(p) : crt;
X    }
X    /* When updating to a folder, always write all headers! */
X    if (ison(flags, UPDATE_STATUS))
X	turnon(flags, NO_IGNORE);
X    else if (do_set(set_options, "alwaysignore"))
X	turnoff(flags, NO_IGNORE);
X    if (isoff(flags, NO_IGNORE)) {
X	if (do_set(set_options, "squeeze"))
X	    squeeze = TRUE;
X	show_hdrs = do_set(set_options, "show_hdrs");
X    }
X
X#ifdef SUNTOOL
X    if (istool && (!fp || fp == stdout)) {
X	register int x = (msg[n].m_lines + 2) * l_height(curfont);
X
X	if (x > 32765) { /* to overcome a bug in pixrects that sun won't fix */
X	    print("message too big to display using this font");
X	    return 0;
X	}
X	if (x < msg_rect.r_height) /* make it at least as big as the window */
X	    x = msg_rect.r_height;
X	/* If the window isn't big enough, an inifite loop occurs in Addstr */
X	if (x < 2 * l_height(curfont) || msg_rect.r_width < 3*l_width(curfont))
X	    return 0;
X	do_clear();
X	lock_cursors();
X	/* msg_pix is for Addstr() */
X	if (!(msg_pix = mem_create(msg_rect.r_width, x, 1))) {
X	    error("mem_create");
X	    return 0;
X	}
X	pr_rop(msg_pix, 0,0, msg_rect.r_width-1, x-1, PIX_CLR, 0,0,0);
X	on_hdr = 1;
X    }
X#endif /* SUNTOOL */
X    if (ison(flags, INDENT)) {
X	if ((indent_str = do_set(set_options, "pre_indent_str"))) {
X	    char *old_fmt = hdr_format;
X	    hdr_format = indent_str;
X	    fprintf(fp, "%s\n", compose_hdr(n) + 9); /* magic number 9 !! */
X	    hdr_format = old_fmt;
X	}
X	if (!(indent_str = do_set(set_options, "indent_str")))
X	    indent_str = DEF_INDENT_STR;
X    }
X    if (fseek(tmpf, msg[n].m_offset, L_SET) == -1) {
X	error("Unable to find msg %d", n+1);
X	return -1;
X    }
X    while (still_more < msg[n].m_size && fgets(line, BUFSIZ, tmpf)) {
X	still_more += strlen(line);
X	/*
X	 * If squeeze is one, all blanks lines squeeze down to one blank line.
X	 * If squeeze is two, squeezing is in progress so wait for the next \n.
X	 */
X	if (*line == '\n') {
X	    if (on_hdr)    /* blank line -- end of header */
X		turnoff(flags, NO_HEADER), on_hdr = 0;
X	    if (squeeze > 1)
X		continue;
X	    else if (squeeze)
X		squeeze = 2;
X	} else if (squeeze > 1)
X	    squeeze = 1;
X
X	if (ison(flags, UPDATE_STATUS))
X	    if (!strncmp(line, "Status:", 7))
X		continue; /* ignore this and other "Status" lines */
X	    else if (!on_hdr) {
X		/* preserve NEW/UNREAD status on preserved messages */
X		register char *p = line;
X		p += Strcpy(p, "Status: O");
X		if (isoff(msg[n].m_flags, UNREAD) &&
X		    isoff(msg[n].m_flags, PRESERVE))
X		    *p++ = 'R';
X		if (ison(msg[n].m_flags, REPLIED))
X		    *p++ = 'r';
X		*p++ = '\n', *p = 0;
X		fputs(line, fp);
X		(void) strcpy(line, "\n");
X		turnoff(flags, UPDATE_STATUS);
X	    }
X	if (on_hdr && isoff(flags, NO_IGNORE)) {
X	    register char *p = any(line, " \t:");
X	    if (!p)
X		ignoring = 0, on_hdr = 0;
X	    else if (ignoring)
X		if (*p != ':') {
X		    Debug("Ignoring: %s", line);
X		    continue;
X		} else
X		    ignoring = 0;
X	    if (p && *p == ':') {
X		*p = 0;
X		ignoring = 0;
X		if (show_hdrs) {
X		    if (!chk_two_lists(line, show_hdrs, ":, \t"))
X			ignoring = 1;
X		} else {
X		    register struct options *opts;
X		    for (opts = ignore_hdr; opts; opts = opts->next)
X			if (!lcase_strcmp(opts->option, line)) {
X			    ignoring = 1;
X			    break;
X			}
X		}
X		*p = ':';
X		if (ignoring) {
X		    Debug("Ignoring: %s", line);
X		    continue;
X		}
X	    }
X	}
X	if (!on_hdr && ison(flags, TOP) && !--top)
X	    break;
X	if (isoff(flags, NO_HEADER)) {
X	    /* note that function returns the number of lines */
X	    lines++;
X#ifdef SUNTOOL
X	    if (istool && (!fp || fp == stdout)) {
X		Addstr(line);
X		continue;
X	    }
X#endif /* SUNTOOL */
X	    if (ison(flags, INDENT))
X		fputs(indent_str, fp);
X	    if (!fp) {
X		if (do_pager(line, FALSE) == EOF)
X		    return -1;
X	    } else if (fputs(line, fp) == EOF)
X		/* Pipe broken, out of filespace, etc */
X		return -1;
X	}
X    }
X    if (ison(flags, INDENT) &&
X	(indent_str = do_set(set_options, "post_indent_str")) && *indent_str) {
X	char *old_fmt = hdr_format;
X	hdr_format = indent_str;
X	fprintf(fp, "%s\n", compose_hdr(n)+9); /* magic number 9 !! */
X	hdr_format = old_fmt;
X    }
X#ifdef SUNTOOL
X    if (istool && (!fp || fp == stdout)) {
X	unlock_cursors();
X	txt.y = still_more = msg_rect.r_height;
X	scroll_win(0);  /* causes a display */
X    }
X#endif /* SUNTOOL */
X    return lines;
X}
X
X/* get mail from whatever the mailfile points to. open a tempfile for
X * appending, then close it and reopen it for read-only.  some systems
X * have flakey read/write access.
X */
void
getmail()
X{
X    register FILE	*mail_fp;
X    int 	lines = 0, get_status = 1, len;
X    long 	ftell(), bytes;
X    char	line[BUFSIZ];
X
X#ifdef SYSV
X    /* for SVID systems to lock, the file must be open for read/write */
X    if (isoff(glob_flags, READ_ONLY))
X	mail_fp = fopen(mailfile, "r+");
X    else
X#endif /* SYSV */
X	mail_fp = fopen(mailfile, "r");
X
X    if (!mail_fp) {
X	error("Unable to open %s", mailfile);
X	return;
X    }
X    /*
X     * since this file is usually open for read-only, close it and then
X     * reopen it for appending.  This is done to compensate for errors
X     * in XENIX and to play it safe with non-essentially writable files.
X     * see more notes below (end of proc).
X     */
X    if (isoff(glob_flags, READ_ONLY)) {
X	int	omask = umask(077);
X
X	(void) fclose(tmpf);
X	tmpf = fopen(tempfile, "a");
X	(void) umask(omask);
X	if (!tmpf) {
X	    error("Unable to open %s for appending", tempfile);
X	    (void) fclose(mail_fp);
X	    return;
X	}
X    } else if (msg_cnt)
X	(void) fseek(tmpf, msg[msg_cnt-1].m_offset+msg[msg_cnt-1].m_size,L_SET);
X
X    if (isoff(glob_flags, READ_ONLY) && lock_file(mailfile, fileno(mail_fp)))
X	error("WARNING: unable to lock %s", mailfile);
X
X    (void) fseek(mail_fp, ftell(tmpf), L_SET);
X
X#ifdef MSG_SEPARATOR
X    len = strlen(MSG_SEPARATOR);
X#endif /* MSG_SEPARATOR */
X
X    while (fgets(line, BUFSIZ, mail_fp) != NULL) {
X#ifndef MSG_SEPARATOR
X	if (!strncmp(line, "From ", 5) &&
X	    !sscanf(line+5, "%*s %*s %*s %*d %*d:%*d"))
X#else /* MSG_SEPARATOR */
X	if (!strncmp(line, MSG_SEPARATOR, len))
X#endif /* MSG_SEPARATOR */
X	{
X	    if (msg_cnt == MAXMSGS-1) {
X		print("WARNING: exceeded %d messages.\n", MAXMSGS);
X		print("You should split \"%s\" into smaller files.\n",mailfile);
X		/* make sure that tempfile isn't removed!! */
X		turnon(glob_flags, IGN_SIGS);
X		cleanup(0); /* probably a more elegant way to exit, but... */
X	    }
X	    bytes = ftell(tmpf);
X	    /* finish up message structure from previous message.
X	     * if this is incorporating new mail, check "lines" to
X	     * see if previous message has already been set!
X	     */
X	    if (msg_cnt && lines) {
X		msg[msg_cnt-1].m_size = bytes - msg[msg_cnt-1].m_offset;
X		msg[msg_cnt-1].m_lines = lines;
X	    }
X	    msg[msg_cnt].m_offset = bytes;
X	    msg[msg_cnt].m_flags = lines = 0;
X	    turnon(msg[msg_cnt].m_flags, UNREAD); /* initialize */
X
X	    if (isoff(glob_flags, READ_ONLY)) {
X		fputs(line, tmpf);
X		if (errno == ENOSPC)
X		    fs_error();
X	    }
X	    /* we've read the "From " line, now read the rest of
X	     * the message headers till we get to a blank line.
X	     */
X	    while (fgets(line, BUFSIZ, mail_fp) && (*line != '\n')) {
X		register char *p = line;
X		if (get_status && !(get_status = strncmp(p, "Status:", 7))) {
X		    turnon(msg[msg_cnt].m_flags, OLD);
X		    for (p += 8 ; *p != '\n'; p++)
X			switch(*p) {
X			    when 'R': turnoff(msg[msg_cnt].m_flags, UNREAD);
X			    when 'P': turnon(msg[msg_cnt].m_flags, UNREAD);
X			    when 'r': turnon(msg[msg_cnt].m_flags, REPLIED);
X			    otherwise :
X				if (ison(glob_flags, WARNING))
X				    print("unknown msg status flag: %c", *p);
X			}
X		}
X		lines++;
X		if (isoff(glob_flags, READ_ONLY)) {
X		    fputs(line, tmpf);
X		    if (errno == ENOSPC)
X			fs_error();
X		}
X	    }
X	    msg_cnt++, get_status = 1;
X	}
X	lines++;
X	if (isoff(glob_flags, READ_ONLY)) {
X	    fputs(line, tmpf);
X	    if (errno == ENOSPC)
X		fs_error();
X	} else
X	    (void) fseek(tmpf, ftell(mail_fp), L_SET);
X    }
X    /* msg_cnt may be 0 if there is an error with the format of mailfile */
X    if (msg_cnt) {
X	msg[msg_cnt-1].m_size = ftell(tmpf) - msg[msg_cnt-1].m_offset;
X	msg[msg_cnt-1].m_lines = lines;
X    }
X
X    close_lock(mail_fp);
X
X    /* I've had problems with sys-v opening a file for read/write. I'd
X     * try fgets after a seek to an arbitrary place and get NULL. "w+"
X     * could be broken (XENIX), so play it safe anyway.
X     */
X    if (isoff(glob_flags, READ_ONLY)) {
X	fclose(tmpf);
X	if (!(tmpf = fopen(tempfile, "r")))
X	    error("unable to open %s for reading", tempfile);
X    }
X}
X
fs_error()
X{
X    error("WARNING: unable to write to \"%s\"", tempfile);
X    print("Read the manual on what to do on full file systems.\n");
X    cleanup(0);
X}
X
X/*
X * copy temp or whatever back to mailfile
X * Return 0 if new mail came and user doesn't want to exit.
X */
copyback()
X{
X    register int	new = 0, i, j=0, k=0;
X    register long	flg = 0;
X    register FILE	*mbox = NULL_FILE, *mail_fp;
X    char		*mbox_file, action = 0;
X    int 		hold = 0, delete_it = 0, dont_unlink = FALSE;
X
X#ifdef SUNTOOL
X    if (istool) {
X	timerclear(&(mail_timer.it_interval));
X	timerclear(&(mail_timer.it_value));
X    }
X#endif /* SUNTOOL */
X    if (ison(glob_flags, READ_ONLY)) {
X	print("Unable to update %s: read only\n", mailfile);
X	return 1;
X    }
X    if (check_new_mail()) {
X	new = 1;
X	if (!istool) {
X	    char buf[256];
X	    if (iscurses)
X		putchar('\n');
X	    print("Really quit? ");
X	    buf[0] = 0;
X	    if (!Getstr(buf, 256, 0) || lower(*buf) != 'y')
X		return 0;
X	}
X    } else if (!msg_cnt) /* prevent unnecessary overwrite */
X	return 0;
X    /* open mbox if: "autodelete" AND "hold" are NOT set. */
X    if (!strcmp(mailfile, spoolfile)
X	    && !(delete_it = !!do_set(set_options, "autodelete"))
X	    && !(hold = !!do_set(set_options, "hold"))) {
X	register char *p;
X	int x = 1; /* tell getpath to ignore "ENOENT" if file not found */
X
X	if (!(p = do_set(set_options, "mbox")))
X	    p = DEF_MBOX;
X	mbox_file = getpath(p, &x);
X	if (x) {
X	    if (x > 0)
X		print("%s is a directory.\n", mbox_file);
X	    else
X		print("Unable to open %s: %s\n", p, mbox_file);
X	    mbox = NULL_FILE;
X	} else {
X	    if (Access(mbox_file, F_OK) == -1) /* does it exist? */
X		mbox = fopen(mbox_file, "w");
X	    else
X		mbox = fopen(mbox_file, "a");
X	    if (!mbox)
X		error("Unable to write to %s", mbox_file);
X	}
X    }
X    /* reopen the mailfile; set umask accordingly */
X    {
X	int omask = umask(077);
X	mail_fp = fopen(mailfile, "w+");
X	(void) umask(omask);
X	if (!mail_fp) {
X	    error("Unable to rewrite %s", mailfile);
X	    return 0;
X	}
X    }
X    turnon(glob_flags, IGN_SIGS);
X    print("Updating \"%s\"", mailfile);
X
X    if (lock_file(mailfile, fileno(mail_fp)))
X	error("WARNING: unable to lock %s", mailfile);
X
X    turnon(flg, UPDATE_STATUS);
X    turnon(flg, NO_IGNORE);
X
X    for (i = 0; i < msg_cnt; i++)
X	/* check to see if message is marked for deletion or, if read and not
X	 * preserved, delete it if autodelete is set. Otherwise, save the
X	 * message in the spool file if hold is set. If all fails, save in mbox.
X	 */
X	if (ison(msg[i].m_flags, DELETE)
X	    || isoff(msg[i].m_flags, UNREAD) && isoff(msg[i].m_flags, PRESERVE) 
X		&& delete_it) {
X	    Debug("%s %d",
X		(action!='d')? "\ndeleting message:" : "", i+1), action = 'd';
X	    continue;
X	} else if (ison(msg[i].m_flags, UNREAD) ||
X		 ison(msg[i].m_flags, PRESERVE) || hold || !mbox) {
X	    j++;
X	    Debug("%s %d",
X		(action!='s')? "\nsaving in spool:" : "", i+1), action = 's';
X	    if (copy_msg(i, mail_fp, flg) == -1) {
X		error("WARNING: unable to write back to spool");
X		print("ALL mail left in %s\n", tempfile);
X		print("Spool mailbox may be corrupted.\n");
X		if (new)
X		    print("New mail may be lost. :-(\n");
X		dont_unlink = TRUE;
X		break;
X	    }
X	} else if (!strcmp(mailfile, spoolfile)) {   /* copy back to mbox */
X	    k++;
X	    if (copy_msg(i, mbox, flg) == -1) {
X		error("WARNING: unable to write to mbox");
X		print("Unresolved mail left in %s\n", tempfile);
X		dont_unlink = TRUE;
X		break;
X	    }
X	    Debug("%s %d",
X		(action!='m')? "\nsaving in mbox:" : "", i+1), action = 'm';
X	}
X    Debug("\n%s", mailfile);
X
X    close_lock(mail_fp);
X
X    if (mbox)
X	fclose(mbox);
X    if (j) {
X	long times[2];
X	times[1] = time(&times[0]) - (long)2;
X	if (!strcmp(mailfile, spoolfile) && utime(mailfile, times))
X	    error("utime");
X	print_more(": saved %d message%s\n", j, (j==1)? NO_STRING: "s");
X    } else if (strcmp(mailfile, spoolfile) && !dont_unlink && !new)
X	if (unlink(mailfile))
X	    turnon(glob_flags, CONT_PRNT), error(": cannot remove");
X	else
X	    print_more(": removed\n");
X    else
X	print_more(": empty\n");
X    if (k)
X	print("saved %d message%s in %s\n",k,(k==1)? NO_STRING: "s",mbox_file);
X    if (new && !istool)
X	print("New mail has arrived.\n");
X    turnoff(glob_flags, IGN_SIGS);
X#ifdef SUNTOOL
X    if (istool) {
X	mail_timer.it_value.tv_sec = time_out;
X	setitimer(ITIMER_REAL, &mail_timer, NULL);
X    }
X#endif /* SUNTOOL */
X    return 1;
X}
X
mail_size()
X{
X    struct stat buf;
X    if (strcmp(mailfile, spoolfile)) {
X	char tmp[128];
X	if (!stat(sprintf(tmp, "%s/%s", MAILDIR, login), &buf))
X	    spool_size = buf.st_size;
X    }
X    if (!*mailfile)
X	return 0;
X    if (stat(mailfile, &buf)) {
X	if (errno != ENOENT)
X	    error("Unable to stat %s", mailfile);
X	return 0;
X    }
X    if (!strcmp(mailfile, spoolfile))
X	spool_size = buf.st_size;
X    if (buf.st_size > last_size) {
X	last_size = buf.st_size;
X	return 1;
X    }
X    return 0;
X}
X
void
mail_status(as_prompt)
X{
X    static char buf[256];
X    register int cnt = 0, new = 0, unread = 0, deleted = 0;
X
X    for ( ; cnt < msg_cnt; cnt++) {
X	if (ison(msg[cnt].m_flags, UNREAD))
X	    unread++;
X	if (ison(msg[cnt].m_flags, DELETE))
X	    deleted++;
X	if (isoff(msg[cnt].m_flags, OLD))
X	    new++;
X    }
X    if (as_prompt) {
X	register char *p, *b = buf;
X	for (p = prompt; *p; p++)
X	    if (*p == '\\')
X		switch (*++p) {
X		    case 'n': case 'r': *b++ = '\n';
X		    when 't': *b++ = '\t';
X		    otherwise: *b++ = *p;
X		}
X	    else if (*p == '%')
X		switch (*++p) {
X		    case 'm':
X			b += strlen(sprintf(b,"%d",(msg_cnt)? current_msg+1:0));
X		    when 't':
X			b += strlen(sprintf(b, "%d", msg_cnt));
X		    when 'd':
X			b += strlen(sprintf(b, "%d", deleted));
X		    when 'u':
X			b += strlen(sprintf(b, "%d", unread));
X		    when 'n':
X			b += strlen(sprintf(b, "%d", new));
X		    when 'f':
X			b += Strcpy(b, mailfile);
X			if (ison(glob_flags, READ_ONLY))
X			    b += Strcpy(b, " [read only]");
X		    when 'T': case 'D': case 'Y': case 'M': case 'N':
X			b += Strcpy(b, Time(p, (long)0));
X		    otherwise: *b++ = *p;
X		}
X	    else if (*p == '!')
X		b += strlen(sprintf(b, "%d", hist_no+1));
X	    else
X		*b++ = *p;
X	*b = 0;
X	print("%s", buf); /* buf MIGHT have a % in it... don't pass as fmt */
X	return;
X    }
X    (void) sprintf(buf,"\"%s\"%s: %d message%s, %d new, %d unread",
X	mailfile, ison(glob_flags, READ_ONLY)? " [read only]" : "",
X	msg_cnt, (msg_cnt != 1)? "s": NO_STRING, new, unread);
X    if (istool || iscurses)
X	(void) sprintf(buf+strlen(buf), ", %d deleted", deleted);
X#ifdef SUNTOOL
X    if (istool) {
X	static char ic_text[4];
X	extern struct pixrect mail_icon_image1, mail_icon_image2;
X	(void) sprintf(ic_text, "%3d", msg_cnt);
X	tool_set_attributes(tool,
X	    WIN_LABEL, buf,
X	    WIN_ICON_LABEL, ic_text,
X	    WIN_ICON_IMAGE, ison(glob_flags, NEW_MAIL)?
X		&mail_icon_image2 : &mail_icon_image1,
X	    0);
X    } else
X#endif /* SUNTOOL */
X#ifdef CURSES
X	if (iscurses)
X	    mvprintw(0, 0, "%-3d %-.*s",
X		((msg_cnt)? current_msg+1 : 0), COLS-5, buf), clrtoeol();
X	else
X#endif /* CURSES */
X	    puts(buf);
X    return;
X}
X
X/* return -1 since function doesn't affect messages */
check_flags(flags)
u_long flags;
X{
X    print_more(" ");
X    if (ison(flags, VERBOSE))
X	print_more("VERBOSE ");
X    if (ison(flags, INCLUDE))
X	print_more("INCLUDE ");
X    if (ison(flags, INCLUDE_H))
X	print_more("INCLUDE_H ");
X    if (ison(flags, EDIT))
X	print_more("EDIT ");
X    if (ison(flags, SIGN))
X	print_more("SIGN ");
X    if (ison(flags, DO_FORTUNE))
X	print_more("DO_FORTUNE ");
X    if (ison(flags, NO_HEADER))
X	print_more("NO_HEADER ");
X    if (ison(flags, DELETE))
X	print_more("DELETE ");
X    if (ison(flags, OLD))
X	print_more("OLD ");
X    if (ison(flags, UNREAD))
X	print_more("UNREAD ");
X    if (ison(flags, UPDATE_STATUS))
X	print_more("UPDATE_STATUS ");
X    if (ison(flags, NO_PAGE))
X	print_more("NO_PAGE ");
X    if (ison(flags, INDENT))
X	print_more("INDENT ");
X    if (ison(flags, NO_IGNORE))
X	print_more("NO_IGNORE ");
X    if (ison(flags, PRESERVE))
X	print_more("PRESERVE ");
X    print_more("\n");
X    return -1;
X}
END_OF_FILE
if test 19132 -ne `wc -c <'msgs.c'`; then
    echo shar: \"'msgs.c'\" unpacked with wrong size!
fi
# end of 'msgs.c'
fi
echo shar: End of archive 7 \(of 14\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
