Subject:  v14i037:  Mail User's Shell, version 6.0, Part05/14
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: island!argv@sun.com (Dan Heller)
Posting-number: Volume 14, Issue 37
Archive-name: mush6.0/part05



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 14)."
# Contents:  bind.c doproc.c main.c viewopts.c
# Wrapped by rsalz@fig.bbn.com on Wed Apr 13 20:04:46 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'bind.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bind.c'\"
else
echo shar: Extracting \"'bind.c'\" \(12063 characters\)
sed "s/^X//" >'bind.c' <<'END_OF_FILE'
X/* bind.c */
X
X#ifdef CURSES
X
X#include "bindings.h"
X#include "mush.h"
X
X#define MAX_BIND_LEN 20   /* max length a string can be to bind to a command */
X
struct cmd_map {
X    int m_cmd;  /* the command this is mapped to  */
X    char *m_str;  /* the string user types (cbreak) */
X    struct cmd_map *m_next;
X} *cmd_map;
X
init_bindings()
X{
X    add_bind("g", 1);
X    add_bind("w", 2);
X    add_bind("W", 3);
X    add_bind("s", 4);
X    add_bind("S", 5);
X    add_bind("c", 6);
X    add_bind("C", 7);
X    add_bind("d", 8);
X    add_bind("D", 9);
X    add_bind("u", 10);
X    add_bind("U", 11);
X    add_bind("\\CR", 12);
X    add_bind("\\CL", 13);
X    add_bind("j", 14), add_bind("J", 14), add_bind("\\n", 14), add_bind("+",14);
X    add_bind("k", 15), add_bind("K", 15), add_bind("-",15), add_bind("\\CK",15);
X    add_bind("^", 16);
X    add_bind("$", 17);
X    add_bind("{", 18);
X    add_bind("}", 19);
X    add_bind("z", 20);
X    add_bind("Z", 21);
X    add_bind("H", 22);
X    add_bind("(", 23);
X    add_bind(")", 24);
X    add_bind("/", 25);
X    add_bind("\\C_", 26);  /* this is really ^/ */
X    add_bind("\\CN", 27);
X    add_bind("\\CP", 28);
X    add_bind("o" ,29);
X    add_bind("O", 30);
X    add_bind("Q", 31);
X    add_bind("q", 32);
X    add_bind("X", 33);
X    add_bind("x", 34);
X    add_bind("\\CU", 35);
X    add_bind("f", 36);
X    add_bind("!", 37);
X    add_bind(":", 38);
X    add_bind("|", 39);
X    add_bind("%", 40);
X    add_bind("v", 41);
X    add_bind("i", 42);
X    add_bind("a", 43);
X    add_bind("h", 44);
X    add_bind("V", 45);
X    add_bind("M", 46);
X    add_bind("m", 47);
X    add_bind("r", 48);
X    add_bind("R", 49);
X    add_bind("t", 50), add_bind(".", 50), add_bind("p", 50);
X    add_bind("T", 51);
X    add_bind("n", 52);
X    add_bind("b", 53);
X    add_bind("B", 54);
X    add_bind("?", 55); /* C_HELP Must be the last one! */
X}
X
struct cmd_map map_func_names[] = {
X    { C_NULL,		NULL,			NULL_MAP },
X    { C_GOTO_MSG,	"goto msg",		NULL_MAP },
X    { C_WRITE_MSG,	"write",		NULL_MAP },
X    { C_WRITE_LIST,	"write list",		NULL_MAP },
X    { C_SAVE_MSG,	"save",			NULL_MAP },
X    { C_SAVE_LIST,	"save list",		NULL_MAP },
X    { C_COPY_MSG,	"copy",			NULL_MAP },
X    { C_COPY_LIST,	"copy list",		NULL_MAP },
X    { C_DELETE_MSG,	"delete",		NULL_MAP },
X    { C_DELETE_LIST,	"delete list",		NULL_MAP },
X    { C_UNDEL_MSG,	"undelete",		NULL_MAP },
X    { C_UNDEL_LIST,	"undelete list",	NULL_MAP },
X    { C_REVERSE,	"reverse video",	NULL_MAP },
X    { C_REDRAW,		"redraw",		NULL_MAP },
X    { C_NEXT_MSG,	"next msg",		NULL_MAP },
X    { C_PREV_MSG,	"back msg",		NULL_MAP },
X    { C_FIRST_MSG,	"first msg",		NULL_MAP },
X    { C_LAST_MSG,	"last msg",		NULL_MAP },
X    { C_TOP_PAGE,	"top page",		NULL_MAP },
X    { C_BOTTOM_PAGE,	"bottom page",		NULL_MAP },
X    { C_NEXT_SCREEN,	"screen next",		NULL_MAP },
X    { C_PREV_SCREEN,	"screen back",		NULL_MAP },
X    { C_SHOW_HDR,	"show hdr",		NULL_MAP },
X    { C_SOURCE,		"source",		NULL_MAP },
X    { C_SAVEOPTS,	"saveopts",		NULL_MAP },
X    { C_NEXT_SEARCH,	"search up",		NULL_MAP },
X    { C_PREV_SEARCH,	"search down",		NULL_MAP },
X    { C_CONT_SEARCH,	"search cont",		NULL_MAP },
X    { C_PRESERVE,	"preserve",		NULL_MAP },
X    { C_SORT,		"sort",			NULL_MAP },
X    { C_REV_SORT,	"sort reverse",		NULL_MAP },
X    { C_QUIT_HARD,	"quit!",		NULL_MAP },
X    { C_QUIT,		"quit",			NULL_MAP },
X    { C_EXIT_HARD,	"exit!",		NULL_MAP },
X    { C_EXIT,		"exit",			NULL_MAP },
X    { C_UPDATE,		"update",		NULL_MAP },
X    { C_FOLDER,		"folder",		NULL_MAP },
X    { C_SHELL_ESC,	"shell escape",		NULL_MAP },
X    { C_CURSES_ESC,	"line mode",		NULL_MAP },
X    { C_PRINT_MSG,	"lpr",			NULL_MAP },
X    { C_CHDIR,		"chdir",		NULL_MAP },
X    { C_VAR_SET,	"variable",		NULL_MAP },
X    { C_IGNORE,		"ignore",		NULL_MAP },
X    { C_ALIAS,		"alias",		NULL_MAP },
X    { C_OWN_HDR,	"my hdrs",		NULL_MAP },
X    { C_VERSION,	"version",		NULL_MAP },
X    { C_MAIL_FLAGS,	"mail flags",		NULL_MAP },
X    { C_MAIL,		"mail",			NULL_MAP },
X    { C_REPLY_SENDER,	"reply",		NULL_MAP },
X    { C_REPLY_ALL,	"reply all",		NULL_MAP },
X    { C_DISPLAY_MSG,	"display",		NULL_MAP },
X    { C_TOP_MSG,	"top",			NULL_MAP },
X    { C_DISPLAY_NEXT,	"display next",		NULL_MAP },
X    { C_BIND,		"bind",			NULL_MAP },
X    { C_UNBIND,		"unbind",		NULL_MAP },
X    { C_HELP,		"help",			NULL_MAP }
X};
X
getcmd()
X{
X    char 		buf[MAX_BIND_LEN];
X    register int 	c, m, match;
X    register char	*p = buf;
X    register struct cmd_map *list;
X
X    bzero(buf, MAX_BIND_LEN);
X    c = getchar();
X    /* If user did job control (^Z), then the interrupt flag will be
X     * set.  Be sure it's unset before continuing.
X     */
X    turnoff(glob_flags, WAS_INTR);
X    if (isdigit(c)) {
X	(void) ungetc(c, stdin);
X	return C_GOTO_MSG;
X    }
X    for (;; p += strlen(p), c = getchar()) {
X	if (c == ESC)
X	    (void) strcpy(buf, "\\E");
X	else if (c == '\n' || c == '\r')
X	    (void) strcpy(p, "\\n");
X	else if (c == '\t')
X	    (void) strcpy(p, "\\t");
X	else if (iscntrl(c))
X	    (void) sprintf(p, "\\C%c", upper(unctrl(c)[1]));
X	else
X	    *p = c;
X	m = 0;
X	for (list = cmd_map; list; list = list->m_next)
X	    if ((match = prefix(buf, list->m_str)) == MATCH) {
X		if (debug)
X		    print("\"%s\" ", map_func_names[list->m_cmd].m_str);
X		return list->m_cmd;
X	    } else if (match != NO_MATCH)
X		m++;
X	if (m == 0) {
X	    if (debug)
X		print("No binding for \"%s\" found.", buf);
X	    return C_NULL;
X	}
X    }
X}
X
X/*
X * bind chars or strings to commands -- doesn't touch messages; return -1
X * for curses mode, return -2 to have curses command set CNTD_CMD to
X * prevent screen refresh to allow user to read output in case of multilines.
X */
bind_it(len, argv)
char **argv;
X{
X    char buf[MAX_BIND_LEN], buf2[256];
X    register int x;
X    int (*oldint)(), (*oldquit)();
X    int unbind = (argv && **argv == 'u');
X    int ret = -1; /* return value */
X
X    if (argv && *++argv && !strcmp(*argv, "-?"))
X	return help(0, "bind", cmd_help) - 1;
X
X    if (iscurses)
X	on_intr();
X
X    if (unbind) {
X	if (!*argv) {
X	    print("Unbind what? ");
X	    if (Getstr(buf, MAX_BIND_LEN-1, 0) <= 0) {
X		if (iscurses)
X		    off_intr();
X		return -1;
X	    }
X	} else
X	    (void) strcpy(buf, *argv);
X	if (!un_bind(buf))
X	    print("\"%s\" isn't bound to a command.\n", buf);
X	if (iscurses)
X	    off_intr();
X	return -1;
X    }
X    if (argv && *argv) {
X	(void) strncpy(buf, *argv, MAX_BIND_LEN-1);
X	if (!argv[1]) {
X	    int binding = c_bind(*argv);
X	    if (binding)
X		print("\"%s\" is bound to \"%s\".\n",
X			*argv, map_func_names[binding].m_str);
X	    else
X		print("\"%s\" isn't bound to a command.\n", *argv);
X	    if (iscurses)
X		off_intr();
X	    return -1;
X	} else
X	    argv++;
X    } else {
X	extern char *_unctrl[];
X	register char *p, *p2 = buf2;
X
X	print("bind [<CR>=all, -?=help]: ");
X	if ((len = Getstr(buf, MAX_BIND_LEN-1, 0)) == 0) {
X	    if (iscurses)
X		putchar('\n');
X	    (void) c_bind(NULL);
X	    if (iscurses)
X		off_intr();
X	    return -2;
X	}
X	if (len < 0) {
X	    if (iscurses)
X		off_intr();
X	    return -1;
X	}
X	/* If user typed control chars, convert them to the \Cx format. */
X	for (p = buf; *p; p++)
X	    if (*p == '\n' || *p == '\r')
X		*p2++ = '\\', *p2++ = 'n';
X	    else if (*p == '\t')
X		*p2++ = '\\', *p2++ = 't';
X	    else if (*p == ESC)
X		*p2++ = '\\', *p2++ = 'E';
X	    else if (iscntrl(*p))
X		*p2++ = '\\', *p2++ = 'C', *p2++ = _unctrl[*p][1];
X	    else
X		*p2++ = *p;
X	*p2 = 0;
X	(void) strcpy(buf, buf2);
X    }
X    /* if a binding was given on the command line */
X    if (argv && *argv)
X	(void) argv_to_string(buf2, argv);
X    else {
X	int binding;
X	
X	if (!strcmp(buf, "-?")) {
X	    if (iscurses)
X		clr_bot_line();
X	    (void) help(0, "bind", cmd_help);
X	    if (iscurses)
X		off_intr();
X	    return -2;
X	}
X
X	binding = c_bind(buf);
X
X	for (len = 0; len == 0; ) {
X	    print("\"%s\" = <%s>: New function [<CR> for list]: ",
X		buf, (binding? map_func_names[binding].m_str : "unset"));
X	    len = Getstr(buf2, 29, 0);
X	    if (iscurses)
X		clr_bot_line();
X	    if (len == 0) {
X		char *maps[C_HELP+1], *p, *malloc();
X		int n = 0;
X
X		if (iscurses)
X		    putchar('\n');
X		for (x = 0; x < C_HELP; x++) {
X		    if (!(x % 4))
X			if (!(p = maps[n++] = malloc(81))) {
X			    error("malloc in bind()");
X			    free_vec(maps);
X			    if (iscurses)
X				off_intr();
X			    return -1;
X			}
X		    p += strlen(sprintf(p, "%-18.18s  ",
X					map_func_names[x+1].m_str));
X		}
X		maps[n] = NULL;
X		(void) help(0, maps, NULL);
X		free_vec(maps);
X		ret--;
X	    }
X	}
X	/* if list was printed, ret < -1 -- tells CNTD_CMD to be set and
X	 * prevents screen from being refreshed (lets user read output
X	 */
X	if (len == -1) {
X	    if (iscurses)
X		off_intr();
X	    return ret;
X	}
X    }
X    for (x = 1; x <= C_HELP; x++)
X	if (!strcmp(buf2, map_func_names[x].m_str)) {
X	    int add_to_ret;
X	    if (debug)
X		print("\"%s\" will execute \"%s\".\n", buf, buf2);
X	    add_to_ret = do_bind(buf, map_func_names[x].m_cmd);
X	    /* if do_bind hda no errors, it returned -1.  If we already
X	     * messed up the screen, then ret is less than -1.  return the
X	     * lesser of the two to make sure that CNTD_CMD gets set right
X	     */
X	    if (iscurses)
X		off_intr();
X	    return min(add_to_ret, ret);
X	}
X    print("\"%s\": Unknown function.\n", buf2);
X    if (iscurses)
X	off_intr();
X    return ret;
X}
X
X/*
X * print current key to command bindings if "str" is NULL.
X * else return the integer "m_cmd" which the str is bound to.
X */
c_bind(str)
register char *str;
X{
X    register struct cmd_map *opts;
X    register int    incurses = iscurses;
X    char buf[128]; /* these lines can't get very long */
X
X    if (!str) {
X	if (incurses)
X	    clr_bot_line(), iscurses = FALSE;
X	(void) do_pager(NULL, TRUE);
X	(void) do_pager("Current key to command bindings:\n\n", FALSE);
X    }
X
X    for (opts = cmd_map; opts; opts = opts->m_next)
X	if (!str) {
X	    if (do_pager(sprintf(buf, "%-20.20s %s\n",
X			 opts->m_str, map_func_names[opts->m_cmd].m_str),
X			 FALSE) == EOF)
X		break;
X	} else
X	    if (strcmp(str, opts->m_str))
X		continue;
X	    else if (opts->m_cmd)
X		return opts->m_cmd;
X	    else
X		return 0;
X    iscurses = incurses;
X    if (str)
X	(void) do_pager(NULL, FALSE);
X    return 0;
X}
X
X/*
X * doesn't touch messages: return -1.  Error output causes return < -1.
X */
do_bind(str, func)
register char *str;
X{
X    register struct cmd_map *list;
X    register int match, ret = -1;
X
X    (void) un_bind(str);
X    for (list = cmd_map; list; list = list->m_next)
X	if ((match = prefix(str, list->m_str)) == MATCH)
X	    puts("Something impossible just happened."), ret--;
X	else if (match == A_PREFIX_B)
X	    printf("Warning: \"%s\" prefixes \"%s\" (%s)\n",
X		str, list->m_str, map_func_names[list->m_cmd].m_str), ret--;
X	else if (match == B_PREFIX_A)
X	    printf("Warning: \"%s\" (%s) prefixes: \"%s\"\n",
X		list->m_str, map_func_names[list->m_cmd].m_str, str), ret--;
X    add_bind(str, func);
X    /* errors decrement ret.  If ret returns less than -1, CNTD_CMD is set
X     * and no redrawing is done so user can see the warning signs
X     */
X    return ret;
X}
X
add_bind(str, func)
register char *str;
X{
X    register struct cmd_map *tmp;
X    struct cmd_map *calloc();
X
X    /* now make a new option struct and set fields */
X    if (!(tmp = calloc((unsigned)1, sizeof(struct cmd_map)))) {
X	error("calloc");
X	return;
X    }
X    tmp->m_next = cmd_map;
X    cmd_map = tmp;
X
X    tmp->m_str = savestr(str);
X    tmp->m_cmd = func; /* strdup handles the NULL case */
X}
X
un_bind(p)
register char *p;
X{
X    register struct cmd_map *list = cmd_map, *tmp;
X
X    if (!list || !*list->m_str || !p || !*p)
X	return 0;
X
X    if (!strcmp(p, cmd_map->m_str)) {
X	cmd_map = cmd_map->m_next;
X	xfree (list->m_str);
X	xfree((char *)list);
X	return 1;
X    }
X    for ( ; list->m_next; list = list->m_next)
X	if (!strcmp(p, list->m_next->m_str)) {
X	    tmp = list->m_next;
X	    list->m_next = list->m_next->m_next;
X	    xfree (tmp->m_str);
X	    xfree ((char *)tmp);
X	    return 1;
X	}
X    return 0;
X}
X
prefix(a, b)
register char *a, *b;
X{
X    while (*a && *b && *a == *b)
X	a++, b++;
X    if (!*a && !*b)
X	return MATCH;
X    if (!*a && *b)
X	return A_PREFIX_B;
X    if (*a && !*b)
X	return B_PREFIX_A;
X    return NO_MATCH;
X}
X#endif /* CURSES */
END_OF_FILE
if test 12063 -ne `wc -c <'bind.c'`; then
    echo shar: \"'bind.c'\" unpacked with wrong size!
fi
# end of 'bind.c'
fi
if test -f 'doproc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doproc.c'\"
else
echo shar: Extracting \"'doproc.c'\" \(12080 characters\)
sed "s/^X//" >'doproc.c' <<'END_OF_FILE'
X/* @(#)doproc.c		(c) copyright	10/18/86 (Dan Heller) */
X
X/* do main panel item procedures */
X#include "mush.h"
X
respond_mail(item, value, event)
Panel_item item;
int value;
struct inputevent *event;
X{
X    char buf[80];
X
X    if (value == 4)
X	return help(panel_sw->ts_windowfd, "respond", tool_help);
X    if (ison(glob_flags, IS_GETTING)) {
X	print("Finish editing current message first");
X	return;
X    }
X    if (!msg_cnt) {
X	print("No messages to respond to.\n");
X	return;
X    }
X    print("Responding to message %d", current_msg+1);
X    if (event && event->ie_code == MS_LEFT)
X	value = 0;
X    (void) sprintf(buf, "%s %s %d",
X	(value == 2 || value == 3)? "replyall" : "replysender",
X	(value == 1 || value == 3)? "-i": NO_STRING, current_msg+1);
X    (void) cmd_line(buf, msg_list);
X}
X
X/* following macro is for the next two procedures */
X#define hdr_item (item == sub_hdr_item[0] || item == sub_hdr_item[1] || \
X                  item == sub_hdr_item[2] || item == sub_hdr_item[3] || \
X                  item == sub_hdr_item[4] || item == sub_hdr_item[5])
X
delete_mail(item, value, event)
register Panel_item item;
int value;
register struct inputevent *event;
X{
X    int val = value; /* save cuz we reset value immediately */
X    u_long bang = ison(glob_flags, IGN_BANG);
X    char buf[128];
X
X    panel_set(item, PANEL_VALUE, 0, 0);
X    if (hdr_item && event->ie_code != MS_LEFT || val == 2)
X	return help(panel_sw->ts_windowfd, "delete", tool_help);
X    /* delete current message */
X    print(sprintf(buf, "%sdelete %s",
X	((event->ie_code == MS_LEFT || val == 0)? "" : "un"),
X	panel_get_value(msg_num_item)));
X    turnon(glob_flags, IGN_BANG);
X    (void) cmd_line(buf, msg_list);
X    if (!bang)
X	turnoff(glob_flags, IGN_BANG);
X}
X
read_mail(item, value, event)
register Panel_item item;
register int value;
register struct inputevent *event;
X{
X    register int this_msg = current_msg;
X
X    /* check "event" in case we were called from select.c
X     * in which case event would be NULL
X     */
X    if (event && event->ie_code == MS_RIGHT &&
X        item && (item == read_item && value ||
X	(item == sub_hdr_item[0] || item == sub_hdr_item[1])))
X	return help(panel_sw->ts_windowfd, "next", tool_help);
X    if (item && (item == sub_hdr_item[4] || item == sub_hdr_item[5]))
X	return help(panel_sw->ts_windowfd, "msg_menu", tool_help);
X    if (!msg_cnt) {
X	print ("No Mail.");
X	return -1;
X    }
X    if (item && item == read_item || ison(msg[current_msg].m_flags, DELETE))
X	(void) next_msg();
X    if (this_msg != current_msg || ison(msg[current_msg].m_flags, UNREAD) ||
X	    (current_msg < n_array[0] || current_msg > n_array[screen])) {
X	set_isread(current_msg);
X	(void) do_hdrs(0, DUBL_NULL, NULL);
X    }
X    if (isoff(msg[current_msg].m_flags, DELETE))
X	display_msg(current_msg, (long)0);
X    return -1;
X}
X
X/* the panel button that says "filename" and "directory", etc... text item */
file_dir(item, event)
Panel_item item;
struct inputevent *event;
X{
X    register char *p;
X    u_long bang = ison(glob_flags, IGN_BANG);
X    char buf[128], *which = panel_get(item, PANEL_LABEL_STRING);
X
X    if (!strcmp(which, "folder:"))
X	if (event->ie_code == '\n' || event->ie_code == '\r')
X	    (void) sprintf(buf, "folder %s", panel_get_value(item));
X	else
X	    (void) sprintf(buf, "folder ! %s", panel_get_value(item));
X
X    else if (!strcmp(which, "directory:"))
X	(void) sprintf(buf, "cd %s", panel_get_value(item));
X
X    else if (!msg_cnt)
X	print("No messages to save");
X
X    else if (!strcmp(which, "filename:")) {
X	int x = 1;
X	register char *b = buf;
X	if (event->ie_code == '\n' || event->ie_code == '\r')
X	    b += Strcpy(buf, "save  ");
X	else
X	    b += Strcpy(buf, "write ");
X	if ((p = panel_get_value(msg_num_item)) && *p)
X	    b += Strcpy(b, p);
X	else
X	    b += strlen(sprintf(b, "%d", current_msg+1));
X	*b++ = ' ', *b = 0;
X	if (!(p = panel_get_value(item)) || !*p &&
X	    (!(p = do_set(set_options, "mbox")) || !*p))
X		p = DEF_MBOX;
X	print(buf), print_more("in %s?", p); /* prompt before adding to cmd */
X	(void) strcpy(b, p); /* now add to command */
X	if ((x = confirm(print_sw->ts_windowfd)) != 'y' && x != MS_LEFT) {
X	    print("Message not saved");
X	    return;
X	}
X    }
X    turnon(glob_flags, IGN_BANG);
X    (void) cmd_line(buf, msg_list);
X    if (!bang)
X	turnoff(glob_flags, IGN_BANG);
X}
X
do_file_dir(item, value, event)
Panel_item item;
int value;
struct inputevent *event;
X{
X    char buf[92];
X    u_long bang = ison(glob_flags, IGN_BANG);
X    int x; /* used for confirmation */
X
X    if (item == folder_item) {
X	(void) strcpy(buf, "folder ");
X	if (event->ie_code == MS_LEFT) {
X	    print("Current folder is: \"%s\"", mailfile);
X	    panel_set(file_item, PANEL_LABEL_STRING, "folder:", 0);
X	    panel_set(file_item, PANEL_MENU_CHOICE_STRINGS,
X			    "Change without updating current folder", 0, 0);
X	} else {
X	    if (!value)
X		(void) strcat(buf, "%");
X	    else if (value == 1)
X		(void) strcat(buf, "&");
X	    else if (value == 2)
X		(void) strcat(buf, "#");
X	    else {
X		(void) sprintf(buf, "folder %s",
X			      panel_get(item, PANEL_CHOICE_STRING, value));
X		if (!strcmp(buf+7, "Help"))
X		    return help(panel_sw->ts_windowfd, "folder", tool_help);
X	    }
X	}
X    } else if (item == cd_item) {
X	(void) strcpy(buf, "cd ");
X	if (event->ie_code == MS_LEFT || !value) {
X	    panel_set(file_item, PANEL_LABEL_STRING, "directory:", 0);
X	    panel_set(file_item, PANEL_MENU_CHOICE_STRINGS,
X				"Change to specified directory", 0, 0);
X	} else if (value == 1)
X	    (void) strcat(buf, "~");
X	else if (value == 2)
X	    (void) strcat(buf, "+");
X	else
X	    return help(panel_sw->ts_windowfd, "chdir", tool_help);
X    } else if (item == save_item) {
X	(void) strcpy(buf, "save ");
X	if (event->ie_code == MS_LEFT)
X	    if (!strcmp("filename:", panel_get(file_item,PANEL_LABEL_STRING))) {
X		event->ie_code = '\n';  /* let file_dir think it got a \n */
X		return file_dir(file_item, event);
X	    } else {
X		panel_set(file_item, PANEL_LABEL_STRING, "filename:", 0);
X		panel_set(file_item, PANEL_MENU_CHOICE_STRINGS,
X			"Save message WITHOUT headers", 0,0);
X		print("Type in Main Panel Window a filename to save message");
X		return;
X	    }
X	else if (value <= 1) {
X	    register char *p = panel_get_value(file_item);
X	    register char *p2 = panel_get_value(msg_num_item);
X	    if ((!p || !*p) && (!(p = do_set(set_options, "mbox")) || !*p))
X		p = DEF_MBOX;
X	    print("Save in %s? ", p);
X	    if ((x = confirm(panel_sw->ts_windowfd)) != 'y' && x != MS_LEFT) {
X		print("Message not saved");
X		return;
X	    }
X	    if (p2 && *p2) {
X		(void) strcat(buf, p2);
X		panel_set(msg_num_item, PANEL_VALUE, NO_STRING, 0);
X		(void) strcat(buf, " ");
X	    }
X	    (void) strcat(buf, p);
X	} else {
X	    (void) sprintf(buf, "save %s",
X		panel_get(item, PANEL_CHOICE_STRING, value));
X	    if (!strcmp(buf+5, "Help"))
X		return help(panel_sw->ts_windowfd, "save", tool_help);
X	}
X    }
X    turnon(glob_flags, IGN_BANG);
X    (void) cmd_line(buf, msg_list);
X    if (!bang)
X	turnoff(glob_flags, IGN_BANG);
X    panel_set(item, PANEL_VALUE, NO_STRING, 0); /* remove last value */
X}
X
text_done(item, event)
Panel_item item;
struct inputevent *event;
X{
X    char opt[30], buf[82], cmd[82];
X    register char *p;
X    u_long bang = ison(glob_flags, IGN_BANG);
X    Panel_item which = NO_ITEM;
X    int set_it;
X
X    if ((event->ie_code == '\n' || event->ie_code == '\r') && 
X				 *strcpy(buf, panel_get_value(item))) {
X	(void) strcpy(opt, panel_get(item, PANEL_LABEL_STRING));
X	set_it = (*opt == 'S');
X	if (!(p = index(opt, ' '))) {
X	    print("Hmmm... there seems to be a problem here.");
X	    return;
X	}
X	++p;
X	switch(lower(*p)) {
X	    case 'o':
X		(void) sprintf(cmd, "%set %s", (set_it)? "s": "uns", buf);
X		which = option_item;
X	    when 'i':
X		(void) sprintf(cmd, "%sgnore %s", (set_it)? "i": "uni", buf);
X		which = ignore_item;
X	    when 'a':
X		(void) sprintf(cmd, "%slias %s", (set_it)? "a": "una", buf);
X		which = alias_item;
X	    otherwise: print("HUH!? (%c)", *p); return;
X	}
X	turnon(glob_flags, IGN_BANG);
X	(void) cmd_line(cmd, msg_list);
X	if (!bang)
X	    turnoff(glob_flags, IGN_BANG);
X    }
X    panel_set(input_item, PANEL_VALUE, NO_STRING, 0); /* remove last value */
X    panel_set(item, PANEL_SHOW_ITEM, FALSE, 0);
X}
X
do_help(item, value, event)
Panel_item item;
register int value;
struct inputevent *event;
X{
X    register char *p, *helpfile = tool_help;
X    switch(value) {
X	case 1: p = "help";
X	when 2: p = "mouse";
X	when 3: p = "windows";
X	when 4: p = "function keys";
X	when 5: p = "hdr_format", helpfile = cmd_help;
X	when 6: p = "msg_list", helpfile = cmd_help;
X	otherwise: p = "general";
X    }
X    (void) help(panel_sw->ts_windowfd, p, helpfile);
X}
X
toolquit(item, value, event)
Panel_item item;
int value;
struct inputevent *event;
X{
X    register int which;
X
X    if (!value || event->ie_code == MS_LEFT) {
X	do_update(NO_ITEM, 0, NO_EVENT);
X	turnoff(glob_flags, NEW_MAIL);
X	mail_status(0); /* lower flag (if up) print current num of msgs */
X	wmgr_changestate (tool->tl_windowfd, rootfd, TRUE);
X	wmgr_changelevel (tool->tl_windowfd, parentfd, TRUE);
X	return;
X    } else if (value == 2) {
X	(void) help(panel_sw->ts_windowfd, "quit", tool_help);
X	return;
X    }
X    print("Left updates changes. Middle does not. Right aborts quit.");
X    if ((which = confirm(panel_sw->ts_windowfd)) == MS_RIGHT) {
X	print("Quit aborted.");
X	return;
X    }
X    abort_mail(NO_ITEM, 0);
X    if (which == MS_LEFT)
X	lock_cursors(), copyback();
X    else
X	print("Bye bye");
X    cleanup(0);
X}
X
do_lpr(item, value, event)
Panel_item item;
int value;
struct inputevent *event;
X{
X    char buf[128];
X
X    if (event && (event->ie_code == MS_LEFT || value == 1)) {
X	print("Sending message %d to printer...", current_msg+1);
X	(void) strcpy(buf, "lpr ");
X	if (value)
X	    (void) sprintf(buf, "lpr \"%s\"", panel_get_value(msg_num_item));
X	lock_cursors();
X	(void) cmd_line(buf, msg_list);
X	unlock_cursors();
X    } else
X	(void) help(panel_sw->ts_windowfd, "printer", tool_help);
X}
X
do_clear()
X{
X    /* actions that clears window indicates user wants to quit getting opts */
X    if (msg_pix)
X	pr_destroy(msg_pix), msg_pix = (struct pixrect *)NULL;
X    if (getting_opts)
X	getting_opts = 0, unlock_cursors();
X    pw_writebackground(msg_win, 0,0, msg_rect.r_width,msg_rect.r_height,
X		       PIX_CLR);
X    txt.x = 5, txt.y = l_height(curfont) - 1;
X}
X
do_update(item, value, event)
Panel_item item;
register int value;
struct inputevent *event;
X{
X    char *argv[2];
X    if (event && event->ie_code != MS_LEFT)
X	return help(panel_sw->ts_windowfd, "update", tool_help);
X    argv[0] = "update";
X    argv[1] = NULL;
X    (void) folder(0, argv, NULL);
X}
X
X/* panel selction button to send a letter.
X * add a CR if necessary, and finish up letter
X */
do_send(item, value, event)
Panel_item item;
register int value;
register struct inputevent *event;
X{
X    if (event->ie_code != MS_LEFT)
X	return help(panel_sw->ts_windowfd, "send", tool_help);
X    if (txt.x > 5) {
X	type_cursor(PIX_CLR);
X	add_to_letter(rite('\n')); /* if line isn't complete, flush it */
X    }
X    finish_up_letter();
X}
X
do_edit(item, value, event)
Panel_item item;
register int value;
register struct inputevent *event;
X{
X    char buf[4];
X    if (event->ie_code != MS_LEFT)
X	return help(panel_sw->ts_windowfd, "edit", tool_help);
X    if (txt.x > 5)
X	add_to_letter(rite('\n')); /* flush line for him */
X    add_to_letter(sprintf(buf, "%cv", *escape));
X}
X
do_compose(item, value, event)
Panel_item item;
register int value;
struct inputevent *event;
X{
X    if (event && event->ie_code != MS_LEFT)
X	return help(panel_sw->ts_windowfd, "compose", tool_help);
X    print("Composing letter.");
X    win_setcursor(msg_sw->ts_windowfd, &write_cursor);
X    clear_msg_list(msg_list);
X    do_mail(0, DUBL_NULL, msg_list);
X}
X
change_font(item, value, event)
Panel_item item;
register int value;
struct inputevent event;
X{
X    if (ison(glob_flags, IS_GETTING))
X	type_cursor(PIX_XOR);
X    curfont = value % total_fonts;
X    print("New font: %s\n",
X	    (!curfont)? "Normal": (curfont == 1)? "Small": "Large");
X    if (ison(glob_flags, IS_GETTING))
X	type_cursor(PIX_XOR);
X    crt = msg_rect.r_height / l_height(curfont);
X}
END_OF_FILE
if test 12080 -ne `wc -c <'doproc.c'`; then
    echo shar: \"'doproc.c'\" unpacked with wrong size!
fi
# end of 'doproc.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(11131 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/* @(#)main.c	(c) copyright 10/18/86 (Dan Heller) */
X
X#include "mush.h"
X
static char *usage_str =
X#ifdef SUNTOOL 
X    "usage: %s [-C] [-i] [-f [folder] ] [-v] [-S] [-t] [-s subject] [users]\n";
X#else
X#ifdef CURSES
X    "usage: %s [-C] [-i] [-f [folder] ] [-v] [-S] [-s subject] [user list]\n";
X#else
X    "usage: %s [-i] [-f [folder] ] [-v] [-S] [-s subject] [user list]\n";
X#endif /* CURSES */
X#endif /* SUNTOOL */
X
X#if defined(sun) && defined(M_DEBUG)
cpu()
X{
X    print("CPU time limit exceeded!\n");
X}
X#endif /* sun && DEBUG */
X
X/*ARGSUSED*/   /* we ignore envp */
main(argc, argv)
char **argv;
X{
X    u_long 	    flg = NO_FLG;
X    int		    n, source_rc = TRUE;
X    char 	    f_flags[10], buf[256], *Cc = NULL, *Subj = NULL;
X    register char  *p;
X    char	  **args;
X
X    if (prog_name = rindex(*argv, '/'))
X	prog_name++;
X    else
X	prog_name = *argv;
X
X    (void) signal(SIGBUS,  bus_n_seg);
X    (void) signal(SIGSEGV, bus_n_seg);
X
X    f_flags[0] = 0;
X    mailfile = "";
X
X#if defined(sun) && defined(M_DEBUG)
X    (void) signal(SIGXCPU, cpu);
X
X    if (p = getenv("MALLOC_DEBUG"))
X	malloc_debug(atoi(p));
X    else
X	malloc_debug(0);
X#endif /* sun && debug */
X
X    if (!isatty(0))
X	turnon(glob_flags, REDIRECT);
X    f_flags[0] = '\0';
X
X    n = 0; /* don't ignore no such file or directory */
X    p = getpath(COMMAND_HELP, &n);
X
X    if (n) {
X	fprintf(stderr, "Warning: can't read %s: %s\n", COMMAND_HELP, p);
X	cmd_help = "cmd_help";
X    } else
X	strdup(cmd_help, p);
X
X    init(); /* must be done before checking mail since "login" is set here */
X    strdup(spoolfile, sprintf(buf, "%s/%s", MAILDIR, login));
X
X    n = FALSE;
X#ifdef SUNTOOL
X    if (n = istool = strlen(prog_name) > 3 &&
X		 !strcmp(prog_name+strlen(prog_name)-4, "tool"))
X	turnon(glob_flags, DO_SHELL);
X#endif /* SUNTOOL */
X
X    /*
X     * preparse the command line to determine whether or not we're going
X     * to bail out after checking that the user has no mail.  Also, check
X     * to see if we're going to run a tool because it must be built first.
X     */
X    if (!istool && argc > 1) {
X	for (args = argv+1; *args && args[0][0] == '-'; args++)
X	    switch (args[0][1]) {
X#ifdef SUNTOOL
X		case 'T' :
X		    if (args[1])
X			args++;
X		case 't' :
X		    istool = 1;
X		    n = TRUE;
X		    turnon(glob_flags, DO_SHELL);
X		    break;
X#endif /* SUNTOOL */
X		case 'S' : turnon(glob_flags, DO_SHELL);
X		case 'f' :
X		case 'u' :
X		    if (args[1])
X			args++;
X		    n = TRUE;
X		    break;
X		case 'c' :
X		case 's' :
X		case '1' :
X		case '2' :
X		    if (args[1])
X			args++;
X		default : ;
X	    }
X	if (*args) {  /* unused args indicates sending mail to someone */
X	    n = TRUE;
X	    if (!istool)
X		turnon(glob_flags, IS_SENDING);
X	}
X    }
X
X#ifdef SUNTOOL
X    /* even if not running tool mode parse all potential suntools args out */
X    args = DUBL_NULL;
X    tool_parse_all(&argc, argv, &args, prog_name);
X#endif /* SUNTOOL */
X
X    /* check for any mail at all and exit if we're not continuing */
X    if (!n) {
X	struct stat statb;
X	if (stat(spoolfile, &statb) || statb.st_size == 0) {
X	    printf("No mail for %s.\n", login);
X	    exit(0);
X	}
X    }
X
X    for (++argv; *argv && **argv == '-'; argv++)
X	switch (argv[0][1]) {
X	    case 'e':
X		/*
X		 * don't set tty modes -- e.g. echo and cbreak modes aren't
X		 * changed.
X		 */
X		turnon(glob_flags, ECHO_FLAG);
X#ifdef CURSES
X	    when 'C':
X		/* don't init curses -- don't even set iscurses.   */
X		if (istool) {
X		    puts("-C: You are already running in tool mode");
X		    turnoff(glob_flags, PRE_CURSES);
X		} else if (hdrs_only)
X		    puts("headers only: ignoring -C flag");
X		else
X		    turnon(glob_flags, PRE_CURSES);
X#endif /* CURSES */
X	    when 'N':
X		(void) strcat(f_flags, "-N ");
X	    when 'r':
X		(void) strcat(f_flags, "-r "); /* folder() argument */
X	    when 'H':
X		if (istool) {
X		    puts("running in tool-mode; -H option ignored.");
X		    break;
X		}
X		turnoff(glob_flags, PRE_CURSES);
X		if (*(hdrs_only = (*argv)+2) != ':')
X		    hdrs_only = ":a";
X		(void) strcat(f_flags, "-N -r "); /* read only cuz no updates */
X	    when 'i':
X		/* force interactive even if !isatty(0) */
X		turnoff(glob_flags, REDIRECT);
X	    when 'u': /* specify a user's mailbox */
X		if (*mailfile)
X		    puts("You can't specify more than one mailbox"), exit(1);
X		strdup(mailfile, sprintf(buf, "%s/%s",
X			       MAILDIR, (argv[1])? argv[1] : "root"));
X		if (argv[1])
X		    ++argv;
X	    when 'f':
X		if (*mailfile)
X		    puts("You can't specify more than one mailbox"), exit(1);
X		if (argv[1])
X		    strdup(mailfile, *++argv);
X		else
X		    strdup(mailfile, "&");
X	    when '1':
X		if (argv[1])
X		    strdup(cmd_help, *++argv);
X		else
X		    puts("-1 \"filename\""), exit(1);
X#ifdef SUNTOOL
X	    when '2':
X		if (argv[1])
X		    strdup(tool_help, *++argv);
X		else
X		    puts("-2 \"filename\""), exit(1);
X#endif /* SUNTOOL */
X	    when 's':
X		if (istool)
X		    puts("bad option when run as a tool"), exit(1);
X		else if (argv[1])
X		    Subj = *++argv;
X		else
X		    puts("-s \"subject\""), exit(1);
X	    when 'c':
X		if (istool)
X		    puts("bad option when run as a tool"), exit(1);
X		else if (argv[1])
X		    Cc = *++argv;
X		else
X		    puts("-c \"cc list\""), exit(1);
X		break;
X#ifdef VERBOSE_ARG
X	    case 'v':
X		if (istool)
X		    puts("bad option when run as a tool"), exit(1);
X		turnon(flg, VERBOSE);
X		break;
X#endif /* VERBOSE_ARG */
X#ifdef SUNTOOL
X            case 'T':
X		if ((time_out = atoi(*argv)) <= 29)
X		    time_out = 30;
X		/* -T implies -t */
X	    case 't': istool = 1;
X#endif /* SUNTOOL */
X	    case 'S': turnon(glob_flags, DO_SHELL);
X	    when 'n': source_rc = FALSE;
X	    when 'd': debug = 1;
X	    otherwise:
X		print("%s: unknown option: `%c'\n", prog_name,
X		    argv[0][1]? argv[0][1] : '-');
X		print(usage_str, prog_name);
X	}
X
X    if (source_rc) {
X	(void) cmd_line(sprintf(buf, "source %s", DEFAULT_RC), msg_list);
X	(void) source(0, DUBL_NULL);
X    }
X
X    set_cwd();  /* call _after_ sourcing files */
X
X#ifdef SUNTOOL
X    if (istool)
X	if (ison(glob_flags, REDIRECT))
X	    puts("You can't redirect input to a tool."), exit(1);
X	else
X	    make_tool(args), turnon(glob_flags, DO_SHELL);
X#endif /* SUNTOOL */
X
X    /* now we're ready for I/O */
X    if (isoff(glob_flags, REDIRECT)) {
X	/* make sure we can always recover from no echo mode */
X	(void) signal(SIGINT, catch);
X	(void) signal(SIGQUIT, catch);
X	if (istool)
X	    turnon(glob_flags, ECHO_FLAG);
X	savetty();
X#ifdef TIOCGLTC
X	if (isatty(0) && ioctl(0, TIOCGLTC, &ltchars))
X	    error("TIOCGLTC");
X#endif /* TIOCGLTC */
X#ifdef SIGCONT
X	(void) signal(SIGTSTP, stop_start); /* this will take care of SIGCONT */
X#endif /* SIGCONT */
X	/* echo_off() checks to see if echo_flg is set, so don't worry */
X	echo_off();
X    }
X
X    if (!istool && *argv) { /* we could check IS_SENDING */
X	char recipients[BUFSIZ];
X	(void) argv_to_string(recipients, argv);
X	fix_up_addr(recipients);
X	if (Cc && *Cc)
X	    fix_up_addr(Cc);
X	/* prompt for subject and Cc list, but not "To: "
X	 * mail_someone() already takes care of redirection.
X	 * if -s or -c options are given, they will be passed.
X	 */
X	if (do_set(set_options, "ask"))
X	    turnon(flg, NEW_SUBJECT);
X	if (do_set(set_options, "autosign"))
X	    turnon(flg, SIGN);
X	if (do_set(set_options, "autoedit"))
X	    turnon(flg, EDIT);
X	if (do_set(set_options, "verbose"))
X	    turnon(flg, VERBOSE);
X	if (do_set(set_options, "fortune"))
X	    turnon(flg, DO_FORTUNE);
X	/* set now in case user is not running shell, but is running debug */
X	(void) signal(SIGCHLD, sigchldcatcher);
X	if (!setjmp(jmpbuf))
X	    (void) mail_someone(recipients, Subj, Cc, flg, NULL);
X	/* do shell set from above: "mush -S user" perhaps */
X	if (isoff(glob_flags, DO_SHELL) && !*mailfile) {
X	    if (isoff(glob_flags, REDIRECT))
X		echo_on();
X	    exit(0);
X	}
X    }
X    turnoff(glob_flags, IS_SENDING); /* no longer sending mail; running shell */
X
X    if (ison(glob_flags, REDIRECT)) {
X	puts("You can't redirect input unless you're sending mail.");
X	puts("If you want to run a shell with redirection, use \"-i\"");
X	cleanup(0);
X    }
X    if (!*mailfile) {
X	strdup(mailfile, spoolfile);
X	if (!mail_size() && isoff(glob_flags, DO_SHELL)) {
X	    /* we know it's not the spool file here */
X	    printf("No mail in %s.\n", mailfile);
X	    echo_on(), exit(0);
X	}
X    }
X
X    if (!hdrs_only) {
X	/* catch will test DO_SHELL and try to longjmp if set.  this is a
X	 * transition state from no-shell to do-shell to ignore sigs to
X	 * avoid a longjmp botch.  Note setjmp isn't called until do_loop().
X	 */
X	turnon(glob_flags, IGN_SIGS);
X#ifdef CURSES
X	if (ison(glob_flags, PRE_CURSES))
X	    (void) curses_init(0, DUBL_NULL);
X	turnoff(glob_flags, PRE_CURSES);
X#endif /* CURSES */
X    }
X
X    /* find a free tmpfile */
X    if (!(p = do_set(set_options, "home")) || !*p)
alted:
X	p = ALTERNATE_HOME;
X    flg = getpid();
X    while (!Access(sprintf(tempfile, "%s/.%s%d", p, prog_name, flg++), F_OK))
X	;
X    /* just create the file, make sure it's empty.  It'll close later and
X     * be reopened for reading only.
X     */
X    {
X	int omask = umask(077);
X	tmpf = fopen(tempfile, "w");
X	(void) umask(omask);
X	if (!tmpf) {
X	    if (p != ALTERNATE_HOME)
X		goto alted;
X	    error("Can't create tempfile %s", tempfile);
X	    cleanup(0);
X	}
X    }
X
X    /* do pseudo-intelligent stuff with certain signals */
X    (void) signal(SIGINT,  catch);
X    (void) signal(SIGQUIT, catch);
X    (void) signal(SIGHUP,  catch);
X
X    if (!hdrs_only && !istool && !do_set(set_options, "quiet"))
X	printf("%s: Type '?' for help.\n", VERSION);
X
X    (void) sprintf(buf, "folder %s %s", f_flags, mailfile);
X    if (argv = make_command(buf, TRPL_NULL, &argc)) {
X	if (folder(argc, argv, NULL) == -1 && isoff(glob_flags, DO_SHELL))
X	    turnoff(glob_flags, IGN_SIGS), cleanup(0);
X	free_vec(argv);
X    }
X
X    if (hdrs_only) {
X	(void) sprintf(buf, "headers %s", hdrs_only);
X	if (argv = make_command(buf, TRPL_NULL, &argc))
X	    (void) do_hdrs(argc, argv, NULL);
X	cleanup(0);
X    }
X
X    turnon(glob_flags, DO_SHELL);
X    if (istool && msg_cnt)
X	set_isread(current_msg);
X
X#ifdef SUNTOOL
X    if (istool) {
X	n = 0;
X	p = getpath(TOOL_HELP, &n);
X	if (n) {
X	    fprintf(stderr, "Warning: can't read %s: %s\n", TOOL_HELP, p);
X	    tool_help = "tool_help";
X	} else
X	    strdup(tool_help, p);
X	if (time_out < 30)
X	    time_out = 60;
X	turnoff(glob_flags, IGN_SIGS);
X	(void) do_hdrs(0, DUBL_NULL, NULL);
X	timerclear(&(mail_timer.it_interval));
X	timerclear(&(mail_timer.it_value));
X	mail_timer.it_value.tv_sec = time_out;
X	setitimer(ITIMER_REAL, &mail_timer, NULL);
X	(void) signal(SIGALRM, check_new_mail);
X	unlock_cursors();
X	while (!(tool->tl_flags & TOOL_DONE))
X	    tool_select(tool, 1);
X	cleanup(0);
X    }
X#endif /* SUNTOOL */
X    do_loop();
X}
X
do_version()
X{
X    print("%s\n", VERSION);
X    return -1;
X}
X
X/* set the current working directory */
set_cwd()
X{
X    char buf[MAXPATHLEN], cwd[MAXPATHLEN];
X#ifndef SYSV
X    extern char *getwd();
X#else /* SYSV */
X    extern char *getcwd();
X#endif /* SYSV */
X
X#ifndef SYSV
X    if (getwd(cwd) == NULL)
X#else
X    if (getcwd(cwd, MAXPATHLEN) == NULL)
X#endif /* SYSV */
X    {
X	error("getcwd: %s", cwd);
X	(void) un_set(&set_options, "cwd");
X    } else
X	(void) cmd_line(sprintf(buf, "set cwd=\"%s\"", cwd), msg_list);
X}
END_OF_FILE
if test 11131 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'viewopts.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'viewopts.c'\"
else
echo shar: Extracting \"'viewopts.c'\" \(12631 characters\)
sed "s/^X//" >'viewopts.c' <<'END_OF_FILE'
X/* @(#)viewopts.c	(c) copyright	10/18/86 (Dan Heller) */
X
X#include "mush.h"
X
struct viewopts {
X    char *v_opt;
X    char *v_prompt;
X    int  v_usage;
X#define TOOL  01
X#define TEXT  02
X    char *v_description;
X};
X
X/*
X * struct contains the option, a prompt if it has a string value, whether
X * or not it applies to non suntools, line mode, or both, and a
X * string describing what the option does. If the prompt string starts
X * with a minus sign, then the value can be set without a value. This
X * is there to indicate to option_line to print a toggle (cycle) pixrect
X * and to print TRUE/FALSE telling whether the value is on or off regardless
X * of it's "string" value.
X */
struct viewopts viewopts[] = {
X    { "alwaysignore", NULL, TOOL | TEXT,
X      "alwaysignore the message headers on the 'ignored' list." },
X    { "ask", NULL, TOOL | TEXT,
X      "Prompts for a subject on outgoing mail." },
X    { "askcc", NULL, TOOL | TEXT,
X      "Ask for list of Carbon Copy recipients whenever sending mail.", },
X    { "autodelete", NULL, TOOL | TEXT,
X      "Automatically delete ALL READ messages whenever you update mail.", },
X    { "autoedit", NULL, TOOL | TEXT,
X      "Automatically enter editor whenever you REPLY to mail.", },
X    { "autoinclude", NULL, TOOL | TEXT,
X      "Include a copy of author's message each time you reply to mail." },
X    { "autoprint", NULL, TOOL | TEXT,
X      "Display the next message on the list when you delete a message." },
X    { "auto_route", NULL, TOOL | TEXT,
X      "Remove redundant uucp addresses when replying to messages." },
X    { "autosign", "-Filename", TOOL | TEXT,
X      "Add file (~/.signature if set but no value) at end of all letters." },
X    { "autosign2", "Address : Filename", TOOL | TEXT,
X      "signature to use for specific addresses. \"addr, ... : <signature>\"", },
X    { "cdpath", "Path", TEXT,
X      "Path to search for directories when the \"cd\" command is issued." },
X    { "crt", "Lines", TEXT,
X      "The number of lines a message must have for 'pager' to be invoked." },
X    { "dead", "Filename", TOOL | TEXT,
X      "The name of the file to store dead mail. ~/dead.letter by default." },
X    { "dot", NULL, TOOL | TEXT,
X      "allow \".\" on a line by itself to send letter." },
X    { "editor", "Editor name/path", TOOL | TEXT,
X      "editor to use by default. Default is evironment EDITOR or \"vi\"" },
X    { "escape", "Character", TOOL | TEXT,
X      "Escape character for extended editing commands. (default = ~)" },
X    { "folder", "Pathname", TOOL | TEXT,
X      "Full pathname to the directory where personal folders are kept." },
X    { "fortune", "-Flag", TOOL | TEXT,
X      "Add fortune to end of letters. Flag to \"fortune\" is optional" },
X    { "fortunates", "Users", TOOL | TEXT,
X      "Those who will receive fortunes if fortune is set (default: All)." },
X    { "hdr_format", "Format", TOOL | TEXT,
X      "Formatting string for headers. \"headers -?\" or help hdr_format" },
X    { "history", "Number", TEXT,
X      "How many commands to remember (like csh)." },
X    { "hold", NULL, TOOL | TEXT,
X      "Read but not deleted messages are saved in spool -- not mbox." },
X    { "ignore_bang", NULL, TEXT,
X      "Ignore '!' as a history reference. Otherwise, escape by: \\!" },
X    { "ignoreeof", "-Command", TEXT,
X      "Ignores ^D as exit, or (if set), execute \"command\"." },
X    { "indent_str", "String", TOOL | TEXT,
X      "String to offset included messages within your letter", },
X    { "in_reply_to", NULL, TOOL | TEXT,
X      "When responding to mail, add In-Reply-To: to message headers." },
X    { "keepsave", NULL, TOOL | TEXT,
X      "Prevents messages from being marked as `deleted' when you `save'." },
X    { "known_hosts", "Host list", TOOL | TEXT,
X      "List of hosts that your site is known to uucp mail to." },
X    { "lister", "Arguemnts", TOOL | TEXT,
X      "Arguments passed to the 'ls' command." },
X    { "mbox", "Filename", TOOL | TEXT,
X      "Filename to use instead of ~/mbox for default mailbox." },
X    { "metoo", NULL, TOOL | TEXT,
X      "When replying to mail, metoo preserves your name on mailing list." },
X    { "mil_time", NULL, TOOL | TEXT,
X      "24-hour military time format is used whenever a time is printed. " },
X    { "newline", "-Command", TEXT,
X      "Ignore RETURN. If set to a string, execute \"command\"" },
X    { "no_expand", NULL, TEXT | TOOL,
X      "Prevents expansion of Mush aliases in outgoing mail." },
X    { "no_hdr", NULL, TOOL | TEXT,
X      "If set, personalized headers are NOT inserted to outgoing mail." },
X    { "no_reverse", NULL, TOOL | TEXT,
X      "disables reverse video in curses mode -- uses \"bold\" in tool mode." },
X    { "nosave", NULL, TOOL | TEXT,
X      "prevents aborted mail from being saved in dead.letter" },
X    { "pager", "Program", TEXT,
X      "Program name to be used as a pager for messages longer than crt." },
X    { "pre_indent_str", "String", TEXT | TOOL,
X      "String to precede interpolated message text into message body." },
X    { "post_indent_str", "String", TEXT | TOOL,
X      "String to succeed interpolated message text into message body." },
X    { "print_cmd", "Program", TOOL | TEXT,
X      "Alternate program to use to send messages to the printer." },
X    { "printer", "Printer", TOOL | TEXT,
X      "Printer to send messages to. Default is environment PRINTER" },
X    { "prompt", "String", TEXT,
X      "Your prompt.  \"help prompt\" for more information." },
X    { "quiet", NULL, TEXT,
X      "Don't print the version number of Mush on startup." },
X    { "record", "Filename", TOOL | TEXT,
X      "Save all outgoing mail in specified filename" },
X    { "reply_to_hdr", "Headers", TOOL | TEXT,
X      "List of headers use to construct reply adresses from a message.", },
X    { "screen", "Number of Headers", TEXT,
X      "Number of headers to print in non-suntools (text) mode" },
X    { "screen_win", "Number of Headers", TOOL,
X      "Set the size of the header window for the tool mode only." },
X    { "show_deleted", NULL, TOOL | TEXT,
X      "Show deleted messages in headers listings (unused in curses mode)" },
X    { "show_hdrs", "Headers", TOOL | TEXT,
X      "When displaying a message, show list of \"headers\" only." },
X    { "sendmail", "Program", TOOL | TEXT,
X      "Program to use to deliver mail instead of using the default."},
X    { "sort", "-Option", TOOL | TEXT,
X      "Pre-sorting of messages on program startup (set to valid sort option)" },
X    { "squeeze", NULL, TOOL | TEXT,
X      "When reading messages, squeeze all blank lines into one." },
X    { "top", "Lines", TOOL | TEXT,
X      "Number of lines to print of a message for the 'top' command."  },
X    { "unix", NULL, TEXT,
X      "Non-mush commands are considered to be UNIX commands." },
X    { "verify", NULL, TEXT,
X      "Verify to send, re-edit, or abort letter after editing." },
X    { "visual", "Visual editor", TOOL | TEXT,
X      "Visual editor to use by default. \"editor\" is used if not set." },
X    { "warning", NULL, TOOL | TEXT,
X      "Print warning messages for non-fatal errors." },
X    { "wrap", NULL, TOOL | TEXT,
X      "After referencing last message, message pointer wraps to start." }
X};
X
X#define total_opts (sizeof viewopts / sizeof (struct viewopts))
X
X#ifdef SUNTOOL
X
static int start_cnt;
X
X#define twenty 	5 + 20*l_width(DEFAULT)
X#define forty 	5 + 40*l_width(DEFAULT)
X#define image_at(x,y,image) pw_rop(msg_win, x, y, 16, 16, PIX_SRC, image, 0,0)
X
X/* print in default text, but increment in large text segments */
view_options()
X{
X    if (msg_rect.r_height < 80) {
X	print("Window not big enough to display options.");
X	return;
X    }
X    do_clear();
X    getting_opts = 1, start_cnt = 0;
X    win_setcursor(msg_sw->ts_windowfd, &checkmark);
X    highlight(msg_win, txt.x, txt.y, LARGE,
X	    "    : Toggle Value       : Description       : Menu (Help)");
X    image_at(txt.x +  2 * l_width(DEFAULT), txt.y - 12, &mouse_left);
X    image_at(txt.x + 25 * l_width(DEFAULT), txt.y - 12, &mouse_middle);
X    image_at(txt.x + 48 * l_width(DEFAULT), txt.y - 12, &mouse_right);
X
X    pw_vector(msg_win, 0, txt.y+6, msg_rect.r_width, txt.y+6, PIX_SRC, 1);
X    pw_vector(msg_win, 0, txt.y+8, msg_rect.r_width, txt.y+8, PIX_SRC, 1);
X
X    txt.y += 24;
X
X    pw_text(msg_win, 5,      txt.y, PIX_SRC, fonts[LARGE], "Option");
X    pw_text(msg_win, twenty, txt.y, PIX_SRC, fonts[LARGE], "On/Off");
X    pw_text(msg_win, forty,  txt.y, PIX_SRC, fonts[LARGE], "Values");
X
X    pw_vector(msg_win, 0, txt.y+6, msg_rect.r_width, txt.y+6, PIX_SRC, 1);
X    pw_vector(msg_win, 0, txt.y+8, msg_rect.r_width, txt.y+8, PIX_SRC, 1);
X
X    pw_text(msg_win, 59*l_width(DEFAULT),txt.y,PIX_SRC,fonts[LARGE],"Scroll:");
X    pw_rop(msg_win, 60*l_width(LARGE), txt.y-13,16,16,PIX_SRC, &dn_arrow,0,0);
X    pw_rop(msg_win, 60*l_width(LARGE)+20,txt.y-13,16,16,PIX_SRC, &up_arrow,0,0);
X
X    display_opts(0); /* create the pixrect and all that */
X}
X
display_opts(count)
register int count;
X{
X    register int total_displayable = (msg_rect.r_height - 60) / 20;
X
X    if (count < 0 && start_cnt + count < 0) {
X	print("At the beginning");
X	return;
X    } else if (count && start_cnt + count + total_displayable > total_opts) {
X	print("At the end");
X	return;
X    }
X    start_cnt += count;
X    if (!msg_pix) {
X	register int x = (total_opts+1) * 20;
X	if (x < msg_rect.r_height)
X	    x = msg_rect.r_height;
X	if (!(msg_pix = mem_create(msg_rect.r_width, x, 1))) {
X	    error("mem_create");
X	    return;
X	}
X	pr_rop(msg_pix,0,0, msg_rect.r_width-1, x-1, PIX_CLR,0,0,0);
X	for (count = 0; count < total_opts; count++)
X	    option_line(count);
X    }
X    pw_rop(msg_win, 0, 50, msg_rect.r_width - 1, msg_rect.r_height - 50,
X       PIX_SRC, msg_pix, 0, start_cnt * 20);
X}
X
void
toggle_opt(line)
X{
X    register char *p = viewopts[start_cnt+line].v_prompt;
X
X    if (do_set(set_options, viewopts[start_cnt+line].v_opt))
X	un_set(&set_options, viewopts[start_cnt+line].v_opt);
X    else {
X	if (p) {
X	    txt.x = 5 + 40 * l_width(DEFAULT) +
X		    (1 + strlen(p) - (*p=='-')) * l_width(DEFAULT);
X	    txt.y = 50 + line*20 + l_height(curfont);
X	}
X	if (!p || *p == '-') {
X	    register char *argv[2];
X	    argv[0] = viewopts[start_cnt+line].v_opt;
X	    argv[1] = NULL;
X	    (void) add_option(&set_options, argv);
X	}
X    }
X    option_line(line);
X    display_opts(0);
X    if (txt.x > 5)
X	type_cursor(PIX_SRC);
X}
X
void
help_opt(line)
X{
X    print(viewopts[start_cnt+line].v_description);
X}
X
add_opt(p, line)
register char *p;
X{
X    char buf[80], **argv;
X    int argc;
X    u_long save_bang = ison(glob_flags, IGN_BANG);
X
X    (void) sprintf(buf, "set %s=\"%s\"", viewopts[start_cnt+line].v_opt, p);
X    turnon(glob_flags, IGN_BANG);
X    if (argv = make_command(buf, DUBL_NULL, &argc))
X	(void) do_command(argc, argv, msg_list);
X    if (!save_bang)
X	turnoff(glob_flags, IGN_BANG);
X    option_line(line); /* make sure new value is entered into database */
X}
X
option_line(count)
register int count;
X{
X    register char *p, *v = do_set(set_options, viewopts[start_cnt+count].v_opt);
X    struct pr_prpos win;
X
X    win.pr = msg_pix;
X    win.pos.y = (start_cnt + count) * 20 + 16;
X    win.pos.x = 5;
X
X    pf_text(win, PIX_SRC, fonts[DEFAULT], blank);
X    pf_text(win, PIX_SRC, fonts[DEFAULT], viewopts[start_cnt+count].v_opt);
X    win.pos.x = twenty+20;
X
X    if (!(p = viewopts[start_cnt+count].v_prompt) || *p == '-') {
X	pr_rop(msg_pix, twenty, win.pos.y-10, 16, 16, PIX_SRC, &cycle, 0, 0);
X	pf_text(win, PIX_SRC, fonts[DEFAULT], (v)? "TRUE  ": "FALSE");
X	win.pos.x++;
X	pf_text(win, PIX_SRC, fonts[DEFAULT], (v)? "TRUE  ": "FALSE");
X    }
X    if (p) {
X	if (*p == '-')
X	    p++;
X	win.pos.x = forty;
X	/* heighlight */
X	pf_text(win, PIX_SRC, fonts[DEFAULT], p);
X	win.pos.x++;
X	pf_text(win, PIX_SRC, fonts[DEFAULT], p);
X        win.pos.x = forty + strlen(p) * l_width(DEFAULT);
X	pf_text(win, PIX_SRC, fonts[DEFAULT], ":");
X	if (v) {
X	    win.pos.x += (2 * l_width(DEFAULT));
X	    pf_text(win, PIX_SRC, fonts[DEFAULT], v);
X	}
X    }
X}
X
X#endif /* SUNTOOL */
X
X/*
X * return a string describing a variable.
X * parameters: count, str, buf.
X * If str != NULL, check str against ALL variables
X * in viewopts array.  The one that matches, set count to it and 
X * print up all the stuff from the viewopts[count] into the buffer
X * space in "buf" and return it.
X */
char *
variable_stuff(count, str, buf)
register char *str, buf[];
X{
X    if (str)
X	for (count = 0; count < total_opts; count++)
X	    if (!strcmp(str, viewopts[count].v_opt))
X		break;
X    if (count >= total_opts) {
X	(void) sprintf(buf, "%s: Not a default %s variable.",
X			   str? str : itoa(count), prog_name);
X	return NULL;
X    }
X    return sprintf(buf, "%s: %s",
X	viewopts[count].v_opt, viewopts[count].v_description);
X}
END_OF_FILE
if test 12631 -ne `wc -c <'viewopts.c'`; then
    echo shar: \"'viewopts.c'\" unpacked with wrong size!
fi
# end of 'viewopts.c'
fi
echo shar: End of archive 5 \(of 14\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
