Subject:  v14i057:  Jove, an emacs variant, version 4.9, Part01/21
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Jonathan Payne <jpayne@cs.rochester.edu>
Posting-number: Volume 14, Issue 57
Archive-name: jove4.9/part01

[  JOVE is full-screen text editor that resembles Emacs in many ways
   (the introductory documentation is a revised form of the Stallman's
   Emacs tutorial).  JOVE provides sub-processes, crash recovery,
   macros, and so on.  Not all features may be available on all systems,
   but I believe a sub-shell with pipes is available for sites without
   BSD-style networking.  The major new feature of this release is
   that Jove now works on MS-DOS and the Macintosh; this is a big win
   for people who have to use a number of different machines.  For more
   details, see all the README files and the very extensive
   documentation.  --r$  ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 21)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f './MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./MANIFEST'\"
else
echo shar: Extracting \"'./MANIFEST'\" \(2625 characters\)
sed "s/^X//" >'./MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X ./MANIFEST                 1	
X ./Makefile                 4	
X ./Makefile.dos             1	
X ./Ovmakefile               3	
X ./README                   4	
X ./Readme.dos               5	
X ./Readme.mac               8	
X ./abbrev.c                 3	
X ./argcount.c               1	
X ./ask.c                    6	
X ./buf.c                    6	
X ./c.c                      7	
X ./case.c                   1	
X ./ctype.c                  5	
X ./ctype.h                  1	
X ./delete.c                 3	
X ./disp.c                  13	
X ./doc/README               1	
X ./doc/cmds.doc.nr          1	
X ./doc/example.rc           1	
X ./doc/jove.1              19	
X ./doc/jove.2              17	
X ./doc/jove.3               6	
X ./doc/jove.4              20	
X ./doc/jove.5              16	
X ./doc/jove.nr              5	
X ./doc/jove.qref            2	
X ./doc/system.rc            1	
X ./doc/teach-jove          18	
X ./doc/teachjove.nr         1	
X ./extend.c                10	
X ./externs.h               11	
X ./fmt.c                    4	
X ./fp.c                     3	
X ./funcdefs.c               9	
X ./getch.c                  1	
X ./insert.c                 7	
X ./io.c                    12	
X ./io.h                     1	
X ./iproc-pipes.c            3	
X ./iproc-ptys.c             3	
X ./iproc.c                  4	
X ./jove.c                  11	
X ./jove.h                   8	
X ./keymaps.txt             15	
X ./mac.c                   21	
X ./mac.h                    2	
X ./macros.c                 3	
X ./macvert.c                1	
X ./malloc.c                 2	
X ./marks.c                  2	
X ./menumaps.txt             1	
X ./misc.c                   4	
X ./mjovers.Hqx              1	
X ./move.c                   2	
X ./paragraph.c              6	
X ./portsrv.c                1	
X ./proc.c                   9	
X ./re.c                    10	
X ./re.h                     1	
X ./re1.c                    5	
X ./rec.c                    1	
X ./rec.h                    1	
X ./recover.c                7	
X ./scandir.c                2	
X ./screen.c                14	
X ./setmaps.c                2	
X ./table.c                  1	
X ./table.h                  1	
X ./teachjove.c              1	
X ./temp.h                   1	
X ./term.c                   2	
X ./termcap.h                1	
X ./tune.dos                 1	
X ./tune.h                   2	
X ./tune.template            1	
X ./util.c                   8	
X ./vars.c                   2	
X ./version.c                1	
X ./wind.c                   4	
X MANIFEST                   1	This shipping list
END_OF_FILE
if test 2625 -ne `wc -c <'./MANIFEST'`; then
    echo shar: \"'./MANIFEST'\" unpacked with wrong size!
fi
# end of './MANIFEST'
fi
if test -f './Makefile.dos' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Makefile.dos'\"
else
echo shar: Extracting \"'./Makefile.dos'\" \(1886 characters\)
sed "s/^X//" >'./Makefile.dos' <<'END_OF_FILE'
X###########################################################################
X# This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE #
X# is provided to you without charge, and with no warranty.  You may give  #
X# away copies of JOVE, including sources, provided that this notice is    #
X# included in all the files.                                              #
X###########################################################################
X
MEM = L  			# M for medium or L for large
DEB = -Gs -Ot		# use -Zi and MEM = M for debugging
X#
X# define LINT_ARGS to use function prototypes
X#
CFLAGS = -A$(MEM) -J -Zp $(DEB) -DIBMPC
LIB = C:\C\LIB
X#
X# linker flags: for debugging use /NOE/NOI/F/B/PAC/CO/STACK:0x2000
X#
LDFLAGS = /NOE/NOI/MAP/F/B/E/PAC/STACK:0x2000
X#
X# set VPATH as below if you have sources in SRC
X#
SRC = .
X# VPATH = .;..	# should read .;$(SRC) - but doesn't work
X
OBJECTS = keymaps.obj funcdefs.obj abbrev.obj ask.obj buf.obj c.obj \
X	case.obj ctype.obj delete.obj extend.obj argcount.obj \
X	insert.obj io.obj jove.obj macros.obj marks.obj misc.obj move.obj \
X	paragrap.obj proc.obj re.obj re1.obj scandir.obj \
X	table.obj tune.obj util.obj vars.obj wind.obj \
X	fmt.obj disp.obj term.obj version.obj fp.obj screen.obj getch.obj
X
HEADERS = ctype.h io.h jove.h re.h table.h temp.h termcap.h tune.h externs.h
X
jove.exe:	$(OBJECTS) $(HEADERS)
X	link $(OBJECTS) $(LIB)\setargv,jove $(LDFLAGS);
X
X$(OBJECTS): $(HEADERS)
X
setmaps.exe:	setmaps.obj funcdefs.c
X	cl setmaps.obj
X
setmaps.obj:	funcdefs.c keymaps.txt
X	cl $(CFLAGS) $(SRC)\setmaps.c
X
keymaps.c:	setmaps.exe keymaps.txt
X	setmaps < keymaps.txt > keymaps.c
X
keymaps.obj:	keymaps.c jove.h
X	$(CC) $(CFLAGS) -I$(SRC) -c keymaps.c
X
X# to avoid accidental loss under unix
tune.c:	tune.dos
X	copy tune.dos tune.c
X
tune.obj: tune.c
X	$(CC) $(CFLAGS) -I$(SRC) -c tune.c
X
clean:
X	-rm *.obj setmaps.exe keymaps.c *.bak *.map
X
END_OF_FILE
if test 1886 -ne `wc -c <'./Makefile.dos'`; then
    echo shar: \"'./Makefile.dos'\" unpacked with wrong size!
fi
# end of './Makefile.dos'
fi
if test -f './argcount.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./argcount.c'\"
else
echo shar: Extracting \"'./argcount.c'\" \(3763 characters\)
sed "s/^X//" >'./argcount.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#include "jove.h"
X#include <ctype.h>
X
X#ifdef MAC
X#	undef private
X#	define private
X#endif
X
X#ifdef	LINT_ARGS
private	void
X	gather_numeric_argument(int),
X	quad_numeric_arg(void);
X#else
private	void
X	gather_numeric_argument(),
X	quad_numeric_arg();
X#endif
X
X#ifdef MAC
X#	undef private
X#	define private static
X#endif
X
private int	arg_supplied_p,
X		arg_count;
X
int
arg_type()
X{
X	return arg_supplied_p;
X}
X
void
set_is_an_arg(there_is)
X{
X	arg_supplied_p = there_is;
X}
X
void
set_arg_value(n)
X{
X	arg_supplied_p = YES;
X	arg_count = n;
X}
X
void
negate_arg_value()
X{
X	arg_count = -arg_count;
X}
X
void
clr_arg_value()
X{
X	arg_supplied_p = NO;
X	arg_count = 1;
X}
X
X/* return whether there is currently a numeric argument */
X
int
is_an_arg()
X{
X	return (arg_supplied_p != NO);
X}
X
X/* return the numeric argument */
X
int
arg_value()
X{
X	return arg_count;
X}
X
X/* called by C-U to gather a numeric argument, either C-U's or digits,
X   but not both */
X
void
TimesFour()
X{
X	quad_numeric_arg();
X}
X
X/* This initializes the numeric argument to 1 and starts multiplying
X   by 4 (the magic number Stallman came up with).  It is an error to
X   invoke quad_numeric_arg() interactively (via TimesFour()), because
X   it uses the LastKeyStruck variable to know what character signals
X   to multiply again (in the loop). */
private void
quad_numeric_arg()
X{
X	int	oldc = LastKeyStruck,
X		newc,
X		narg_count,
X		slow;
X
X	slow = 0;
X	arg_supplied_p = YES;
X	arg_count = 1;
X	this_cmd = ARG_CMD;
X	do {
X		if ((narg_count = arg_count * 4) != 0)
X			arg_count = narg_count;
X		if (!slow)
X			newc = waitchar(&slow);
X		else
X			newc = getch();
X		if (isdigit(newc) || newc == '-') {
X		     arg_supplied_p = NO;
X		     gather_numeric_argument(newc);
X		     return;
X		}
X		if (slow)
X			message(key_strokes);
X	} while (newc == oldc);
X	Ungetc(newc);
X}
X
private void
gather_numeric_argument(c)
X{
X	int	sign = 0;
X	static int	digited;
X	int	slow = 0;
X
X	if (!isdigit(c) && c != '-')
X		complain((char *) 0);
X	if (arg_supplied_p == NO) {	/* if we just got here */
X		arg_count = 0;	/* start over */
X		digited = NO;
X	} else if (arg_supplied_p == YES_NODIGIT) {
X		sign = (arg_count < 0) ? -1 : 1;
X		arg_count = 0;
X	}
X
X	if (!sign)
X		sign = (arg_count < 0) ? -1 : 1;
X	if (sign == -1)
X		arg_count = -arg_count;
X	if (c == '-') {
X		sign = -sign;
X		goto goread;
X	}
X	for (;;) {
X		if (slow)
X			message(key_strokes);
X		if (isdigit(c)) {
X			arg_count = (arg_count * 10) + (c - '0');
X			digited = YES;
X		} else {
X			if (digited)
X				arg_supplied_p = YES;
X			else {
X				arg_count = 1;
X				if (arg_supplied_p == NO)
X					arg_supplied_p = YES_NODIGIT;
X			}
X			arg_count *= sign;
X			this_cmd = ARG_CMD;
X			Ungetc(c);
X			return;
X		}
goread:		if (!slow)
X			c = waitchar(&slow);
X		else {
X			add_mess(NullStr);
X			c = getch();
X		}
X	}
X}
X
void
Digit()
X{
X	gather_numeric_argument(LastKeyStruck);
X}
X
void
Digit0()
X{
X	gather_numeric_argument('0');
X}
X
void
Digit1()
X{
X	gather_numeric_argument('1');
X}
X
void
Digit2()
X{
X	gather_numeric_argument('2');
X}
X
void
Digit3()
X{
X	gather_numeric_argument('3');
X}
X
void
Digit4()
X{
X	gather_numeric_argument('4');
X}
X
void
Digit5()
X{
X	gather_numeric_argument('5');
X}
X
void
Digit6()
X{
X	gather_numeric_argument('6');
X}
X
void
Digit7()
X{
X	gather_numeric_argument('7');
X}
X
void
Digit8()
X{
X	gather_numeric_argument('8');
X}
X
void
Digit9()
X{
X	gather_numeric_argument('9');
X}
END_OF_FILE
if test 3763 -ne `wc -c <'./argcount.c'`; then
    echo shar: \"'./argcount.c'\" unpacked with wrong size!
fi
# end of './argcount.c'
fi
if test -f './case.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./case.c'\"
else
echo shar: Extracting \"'./case.c'\" \(3737 characters\)
sed "s/^X//" >'./case.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#include "jove.h"
X#include "ctype.h"
X
X#ifdef MAC
X#	undef private
X#	define private
X#endif
X
X#ifdef	LINT_ARGS
private	int
X#if !(defined(IBMPC) || defined(MAC))
X	lower(char *),
X#endif
X	upper(char *);
X#else
private	int
X#if !(defined(IBMPC) || defined(MAC))
X	lower(),
X#endif
X	upper();
X#endif	/* LINT_ARGS */
X
X#ifdef MAC
X#	undef private
X#	define private static
X#endif
X
void
CapChar()
X{
X	register int	num,
X			restore = NO;
X	Bufpos	b;
X
X	DOTsave(&b);
X
X	num = arg_value();
X	if (num < 0) {
X		restore = YES;
X		num = -num;
X		b_char(num);	/* Cap previous EXP chars */
X	}
X	while (num--) {
X		if (upper(&linebuf[curchar])) {
X			modify();
X			makedirty(curline);
X		}
X		if (eolp()) {
X			if (curline->l_next == 0)
X				break;
X			SetLine(curline->l_next);
X		} else
X			curchar += 1;
X	}
X	if (restore)
X		SetDot(&b);
X}
X
void
CapWord()
X{
X	register int	num,
X			restore = NO;
X	Bufpos	b;
X
X	DOTsave(&b);
X	num = arg_value();
X	if (num < 0) {
X		restore = YES;
X		num = -num;
X		b_word(num);		/* Cap previous EXP words */
X	}
X	while (num--) {
X		to_word(1);	/* Go to the beginning of the next word. */
X		if (eobp())
X			break;
X		if (upper(&linebuf[curchar])) {
X			modify();
X			makedirty(curline);
X		}
X		curchar += 1;
X		while (!eolp() && isword(linebuf[curchar])) {
X			if (lower(&linebuf[curchar])) {
X				modify();
X				makedirty(curline);
X			}
X			curchar += 1;
X		}
X	}
X	if (restore)
X		SetDot(&b);
X}
X
void
case_word(up)
X{
X	Bufpos	before;
X
X	DOTsave(&before);
X	ForWord();	/* this'll go backward if negative argument */
X	case_reg(before.p_line, before.p_char, curline, curchar, up);
X}
X
private int
upper(c)
register char	*c;
X{
X	if (islower(*c)) {
X#ifndef ASCII			/* check for IBM extended character set */
X		if (*c <= 127)
X#endif /* ASCII */
X		*c -= ' ';
X#ifdef IBMPC			/* ... and change Umlaute	*/
X		else 
X		   switch (*c) {
X		     case 129: *c = 154; break;		/* ue */
X		     case 132: *c = 142; break;		/* ae */
X		     case 148: *c = 153; break;		/* oe */
X		   }
X#endif /* IBMPC */
X#ifdef MAC
X		else *c = CaseEquiv[*c];
X#endif
X		return 1;
X	}
X	return 0;
X}
X
X#if !(defined(IBMPC) || defined(MAC))
private
X#endif
int
lower(c)
char	*c;
X{
X	if (isupper(*c)) {
X#ifndef ASCII
X		if (*c <= 127) 
X#endif /* ASCII */
X		*c += ' ';
X#ifdef IBMPC
X		else
X   		   switch (*c) {
X		     case 142: *c = 132; break;		/* Ae */
X		     case 153: *c = 148; break;		/* Oe */
X		     case 154: *c = 129; break;		/* Ue */
X		   }
X#endif /* IBMPC */
X#ifdef MAC
X		else {
X			int n;
X			
X			for(n = 128; n < 256; n++) {
X				if((CaseEquiv[n] == *c) && islower(n)) {
X					*c = n;
X					break;
X				}
X			}
X			if(n > 255) return(0);
X		}
X#endif /* MAC */		
X		return 1;
X	}
X	return 0;
X}
X
void
case_reg(line1, char1, line2, char2, up)
Line	*line1,
X	*line2;
int	char1;
X{
X	(void) fixorder(&line1, &char1, &line2, &char2);
X	DotTo(line1, char1);
X
X	for (;;) {
X		if (curline == line2 && curchar == char2)
X			break;
X		if (!eolp())
X			if ((up) ? upper(&linebuf[curchar]) : lower(&linebuf[curchar])) {
X				makedirty(curline);
X				modify();
X			}
X		f_char(1);
X	}
X}
X
void
CasRegLower()
X{
X	CaseReg(0);
X}
X
void
CasRegUpper()
X{
X	CaseReg(1);
X}
X
void
CaseReg(up)
X{
X	register Mark	*mp = CurMark();
X	Bufpos	savedot;
X
X	DOTsave(&savedot);
X	case_reg(curline, curchar, mp->m_line, mp->m_char, up);
X	SetDot(&savedot);
X}
X
void
UppWord()
X{
X	case_word(1);
X}
X
void
LowWord()
X{
X	case_word(0);
X}
END_OF_FILE
if test 3737 -ne `wc -c <'./case.c'`; then
    echo shar: \"'./case.c'\" unpacked with wrong size!
fi
# end of './case.c'
fi
if test -f './ctype.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./ctype.h'\"
else
echo shar: Extracting \"'./ctype.h'\" \(1644 characters\)
sed "s/^X//" >'./ctype.h' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X/* The code in this file was snarfed from ctype.h and modified for JOVE. */
X
X#define	_U	01
X#define	_L	02
X#define	_N	04
X#define _P	010
X#define _C	020
X#define _W	040
X#define _Op	0100
X#define _Cl	0200
X
extern int	SyntaxTable;
X#define iswhite(c)	(isspace(c))
X#define isword(c)	((CharTable[SyntaxTable])[c]&(_W))
X#define	isalpha(c)	((CharTable[SyntaxTable])[c]&(_U|_L))
X#define	isupper(c)	((CharTable[SyntaxTable])[c]&_U)
X#define	islower(c)	((CharTable[SyntaxTable])[c]&_L)
X#define	isdigit(c)	((CharTable[SyntaxTable])[c]&_N)
X#define	isspace(c)	(c == ' ' || c == '\t')
X#define ispunct(c)	((CharTable[SyntaxTable])[c]&_P)
X
X
X#define toascii(c)	((c)&CHARMASK)
X#define isctrl(c)	((CharTable[0][c&CHARMASK])&_C)
X#define isopenp(c)	((CharTable[0][c&CHARMASK])&_Op)
X#define isclosep(c)	((CharTable[0][c&CHARMASK])&_Cl)
X#define has_syntax(c,s)	((CharTable[SyntaxTable][c&CHARMASK])&s)
X
X#ifdef ASCII
X#define toupper(c)	((c)&~040)
X#define tolower(c)	((c)|040)
X#else /* IBMPC or MAC */
X#define toupper(c)	(CaseEquiv[c])
X/* #define tolower(c)	((c)|040)	*/
X#endif /* IBMPC */
X
X#define WITH_TABLE(x) \
X{ \
X	int	push = SyntaxTable; \
X	SyntaxTable = x;
X
X#define END_TABLE() \
X	SyntaxTable = push; \
X}
END_OF_FILE
if test 1644 -ne `wc -c <'./ctype.h'`; then
    echo shar: \"'./ctype.h'\" unpacked with wrong size!
fi
# end of './ctype.h'
fi
if test -f './doc/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./doc/README'\"
else
echo shar: Extracting \"'./doc/README'\" \(306 characters\)
sed "s/^X//" >'./doc/README' <<'END_OF_FILE'
To create the jove manual (as opposed to the man pages)
just do "nroff -ms jove.[12345]" (or ditroff or troff).
That should do the trick.  The man pages will be installed
automatically by "make install" in the previous directory.
And the online/run-time documentation will be installed
automatically, too.
END_OF_FILE
if test 306 -ne `wc -c <'./doc/README'`; then
    echo shar: \"'./doc/README'\" unpacked with wrong size!
fi
# end of './doc/README'
fi
if test -f './doc/cmds.doc.nr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./doc/cmds.doc.nr'\"
else
echo shar: Extracting \"'./doc/cmds.doc.nr'\" \(238 characters\)
sed "s/^X//" >'./doc/cmds.doc.nr' <<'END_OF_FILE'
X.de bp
X..
X.de NH
X..
X.de IQ
X"\\$1"
X..
X.de dc
X.sp 1
X:entry "\\$1"
X.if '\\$2'(variable)' "Variable"
X.if !'\\$2'(variable)' "Command"
X.br
X..
X.de ID
X.sp 1
X.in +5
X..
X.de DE
X.fi
X.sp 1
X.in -5
X..
X.de DS
X.nf
X.sp 1
X.in +5
X..
X.de UX
UNIX\c
X..
X.ll 7i
END_OF_FILE
if test 238 -ne `wc -c <'./doc/cmds.doc.nr'`; then
    echo shar: \"'./doc/cmds.doc.nr'\" unpacked with wrong size!
fi
# end of './doc/cmds.doc.nr'
fi
if test -f './doc/example.rc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./doc/example.rc'\"
else
echo shar: Extracting \"'./doc/example.rc'\" \(715 characters\)
sed "s/^X//" >'./doc/example.rc' <<'END_OF_FILE'
if /ua/jonathan/src/jove/lib/isttytype iq120
X	bind-to-key Prefix-1 \\
X	bind-to-key set-mark ^[ 
X	set allow-^S-and-^Q on
endif
if /ua/jonathan/src/jove/lib/modemp
X	set mode-line  -%n %m "%f" %((%t%s%C%s%l)%)
else
X	set mode-line  -%n- %["%f" %m [%b] %]%s%((%t%s%C%s%l)%)%s(%M) %e
endif
auto-execute-command show-match .*\.[ch]$
set comment-format /* %!   %c%! */
set disable-biff on
set match-regular-expressions on
set use-i/d-char off
bind-to-key backward-paragraph ^[[
bind-to-key current-error ^X^C
bind-to-key exit-jove ^X^Z
bind-to-key find-tag-at-point ^[^T
bind-to-key grow-window ^Xg
bind-to-key kill-s-expression ^[^K
bind-to-key list-processes ^X^L
bind-to-key scroll-down ^C
bind-to-key shrink-window ^Xs
END_OF_FILE
if test 715 -ne `wc -c <'./doc/example.rc'`; then
    echo shar: \"'./doc/example.rc'\" unpacked with wrong size!
fi
# end of './doc/example.rc'
fi
if test -f './doc/system.rc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./doc/system.rc'\"
else
echo shar: Extracting \"'./doc/system.rc'\" \(377 characters\)
sed "s/^X//" >'./doc/system.rc' <<'END_OF_FILE'
auto-execute-command auto-fill-mode /tmp/Re\|/tmp/article
auto-execute-command show-match .*\.[lchy]$\|.*\.lisp$\|.*\.scm$\|.*\.slisp
auto-execute-command c-mode .*\.[chy]$
auto-execute-command lisp-mode .*\.l$\|.*\.lisp$\|.*\.scm$\|.*\.slisp
bind-to-key pause-jove ^[S
bind-to-key pause-jove ^[s
process-bind-to-key interrupt-process ^C
process-bind-to-key process-newline ^M
END_OF_FILE
if test 377 -ne `wc -c <'./doc/system.rc'`; then
    echo shar: \"'./doc/system.rc'\" unpacked with wrong size!
fi
# end of './doc/system.rc'
fi
if test -f './doc/teachjove.nr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./doc/teachjove.nr'\"
else
echo shar: Extracting \"'./doc/teachjove.nr'\" \(726 characters\)
sed "s/^X//" >'./doc/teachjove.nr' <<'END_OF_FILE'
X.hy 0
X.TH TEACHJOVE 1 "12 February 1986"
X.ad
X.SH NAME
TEACHJOVE - learn how to use the JOVE editor
X.SH SYNOPSIS
teachjove
X.SH DESCRIPTION
TEACHJOVE is a simple program that calls up the JOVE editor on a special
file that is an interactive tutorial for the JOVE editor.  Once in JOVE
all you do is follow the instructions and by doing so you will learn all
about JOVE!  NOTE: TEACHJOVE actually makes a copy of the tutorial in
your home directory; if you ever want to start over (if you trash the
file by accident) all you need to do is remove the file "~/teach-jove"
and run teachjove again.
X.SH FILES
LIBDIR/teach-jove -- THE special file.
X.SH SEE ALSO
JOVE(1) - to learn about JOVE in general.
X.fi
X.SH AUTHOR
Jonathan Payne
END_OF_FILE
if test 726 -ne `wc -c <'./doc/teachjove.nr'`; then
    echo shar: \"'./doc/teachjove.nr'\" unpacked with wrong size!
fi
# end of './doc/teachjove.nr'
fi
if test -f './getch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./getch.c'\"
else
echo shar: Extracting \"'./getch.c'\" \(2453 characters\)
sed "s/^X//" >'./getch.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#include "tune.h"
X
X#ifdef MSDOS
X
X#include <bios.h>
X#include <dos.h>
X
X#include "jove.h"
X
X#ifdef LINT_ARGS
private void waitfun(void);
X#else
private void waitfun();
X#endif
X
extern int UpdModLine;
X#ifdef IBMPC
static char last = 0;
extern int specialkey;
X#endif
X
getrawinchar()
X{
X#ifdef RAINBOW
X	union REGS regs;
X#endif /* RAINBOW */
X#ifdef IBMPC
X	unsigned scan;
X	
X	if (specialkey = last) {
X		scan = last;
X		last = 0;
X		return scan;
X	}
X#endif /* IBMPC */
X
X	while (!rawkey_ready())
X		waitfun();
X
X#ifdef IBMPC
X	scan = _bios_keybrd(_KEYBRD_READ);
X	if ((scan&0xff) == 0) {
X		last = (char) (scan >> 8);
X		return 0xff;
X	}
X	return scan&0xff;
X#else /* IBMPC */
X#ifdef RAINBOW
waitloop:
X	regs.x.di = 2;
X	int86(0x18, &regs, &regs);
X	if (regs.h.al != 0)	/* should never happen, but who knows */
X		return regs.h.al;
X	else
X		goto waitloop;
X#else /* RAINBOW */
X	return bdos(0x06, 0x00ff, 0xff) & 0xff;
X#endif /* RAINBOW */
X#endif /* IBMPC */
X}
X
static int waiting = 0;
X
rawkey_ready()
X{
X#ifndef IBMPC
X	union REGS regs;
X#endif
X
X	if (waiting)
X		return 0;
X#ifdef IBMPC
X	if (last) 
X		return 1;
X
X	return _bios_keybrd(_KEYBRD_READY);
X#else /* IBMPC */
X#ifdef RAINBOW
X	regs.x.di = 4;
X	int86(0x18, &regs, &regs);
X	return regs.h.cl != 0;
X#else /* RAINBOW */
X	regs.h.ah = 0x44;		/* ioctl call */
X	regs.x.bx = 0;			/* stdin file handle */
X	regs.h.al = 0x06;		/* get input status */
X	intdos(&regs, &regs);
X	return regs.h.al & 1;
X#endif /* RAINBOW */
X#endif /* IBMPC */
X}
X
X#ifdef IBMPC
static long timecount, lastcount = 0;
X#else
static char lastmin = 0;
X#endif
X
X
private void
waitfun()
X{
X#ifndef IBMPC
X	struct dostime_t tc;
X#endif
X
X	if (UpdModLine) {
X		waiting = 1;
X		redisplay();
X		waiting = 0;
X		return;
X	}
X#ifdef IBMPC
X	if (_bios_timeofday(_TIME_GETCLOCK, &timecount) ||  /* after midnight */
X            (timecount > lastcount + 0x444) ) {
X		lastcount = timecount;
X		UpdModLine = 1;
X	}
X#else
X	_dos_gettime(&tc);
X	if (tc.minute != lastmin) {
X		UpdModLine = 1;
X		lastmin = tc.minute;
X	}
X#endif
X}
X
X#endif /* MSDOS */
END_OF_FILE
if test 2453 -ne `wc -c <'./getch.c'`; then
    echo shar: \"'./getch.c'\" unpacked with wrong size!
fi
# end of './getch.c'
fi
if test -f './io.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./io.h'\"
else
echo shar: Extracting \"'./io.h'\" \(1502 characters\)
sed "s/^X//" >'./io.h' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#define putchar(c)	putc(c, stdout)
X#define putc(c, fp)	(--(fp)->f_cnt >= 0 ? (*(fp)->f_ptr++ = (c)) : _flush((c), fp))
X#define getc(fp)	(((--(fp)->f_cnt < 0) ? filbuf(fp) : *(fp)->f_ptr++))
X
typedef struct File {
X	int	f_cnt,		/* number of characters left in buffer */
X		f_bufsize,	/* size of what f_base points to */
X		f_fd,		/* fildes */
X		f_flags;	/* various flags */
X	char	*f_ptr,		/* current offset */
X		*f_base;	/* pointer to base */
X	char	*f_name;	/* name of open file */
X} File;
X
X#define F_READ		01
X#define F_WRITE		02
X#define F_APPEND	04
X#define F_MODE(x)	(x&07)
X#define F_EOF		010
X#define F_STRING	020
X#define F_ERR		040
X#define F_LOCKED	0100	/* don't close this file upon error */
X#define F_MYBUF		0200	/* f_alloc allocated the buffer, so
X				   f_close knows to free it up */
X#define F_TELLALL	0400	/* whether to display info upon close */
X
extern long	io_chars;
extern int	io_lines;
X
extern File
X	*stdout,
X
X	*open_file(),
X	*fd_open(),
X	*f_open();
X
X#ifdef VMUNIX
X#   define MAXTTYBUF	2048
X#else
X#   define MAXTTYBUF	512
X#endif
END_OF_FILE
if test 1502 -ne `wc -c <'./io.h'`; then
    echo shar: \"'./io.h'\" unpacked with wrong size!
fi
# end of './io.h'
fi
if test -f './macvert.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./macvert.c'\"
else
echo shar: Extracting \"'./macvert.c'\" \(3170 characters\)
sed "s/^X//" >'./macvert.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X/* Macvert converts old style macro files to the new style.  The old
X   style macros were binary files, the new ones are text files suitable
X   for loading with the "source" command of JOVE. */
X
X#include <stdio.h>
X
extern int	read(),
X		write();
X
int	mac_fd;
X
mac_io(fcn, ptr, nbytes)
int	(*fcn)();
char	*ptr;
X{
X	int	nio;
X
X	if ((nio = (*fcn)(mac_fd, ptr, nbytes)) != nbytes)
X		fprintf(stderr, "[Macro %s error: %d got %d]",
X			 (fcn == read) ? "read" : "write",
X			 nbytes,
X			 nio);
X}
X
X#define NEWWAY	1
X#define OLDWAY	0
X
int	int_how = NEWWAY;
X
X/* Formatting int's the old way or the new "improved" way? */
X
X#if vax || pdp11
long htonl(x)
register long x;
X{
X	return(	(((x >>  0) & 0377) << 24) |
X		(((x >>  8) & 0377) << 16) |
X		(((x >> 16) & 0377) <<  8) |
X		(((x >> 24) & 0377) <<  0) );
X}
X
short htons(x)
register short x;
X{
X	return(	(((x >>  0) & 0377) << 8) |
X		(((x >>  8) & 0377) << 0) );
X}
X
long ntohl(x)
register long x;
X{
X	return(	(((x >>  0) & 0377) << 24) |
X		(((x >>  8) & 0377) << 16) |
X		(((x >> 16) & 0377) <<  8) |
X		(((x >> 24) & 0377) <<  0) );
X}
X
short ntohs(x)
register short x;
X{
X	return(	(((x >>  0) & 0377) << 8) |
X		(((x >>  8) & 0377) << 0) );
X}
X#else
long htonl(x)
register long x;
X{
X	return(x);
X}
X
short htons(x)
register short x;
X{
X	return(x);
X}
X
long ntohl(x)
register long x;
X{
X	return(x);
X}
X
short ntohs(x)
register short x;
X{
X	return(x);
X}
X#endif
X
int_fmt(i)
X{
X	if (int_how == NEWWAY)
X		return ntohl(i);
X	return i;
X}
X
read_and_write_macros(filein)
char	*filein;
X{
X	int	namelen,
X		bodylen,
X		tmp;
X	char	macname[256],
X		macbuf[1024];
X
X	if ((mac_fd = open(filein, 0)) == -1)
X		fprintf(stderr, "Cannot open %s\n", filein);
X
X	while (read(mac_fd, (char *) &tmp, sizeof tmp) == (sizeof tmp)) {
retry:		bodylen = int_fmt(tmp);
X		if (bodylen <= 0 || bodylen > 10000) {
X			if (int_how == NEWWAY) {
X				int_how = OLDWAY;
X				goto retry;
X			} else {
X				fprintf(stderr, "I don't think \"%s\" is an old style JOVE macro file\n", filein);
X				exit(1);
X			}
X		}
X		mac_io(read, (char *) &namelen, sizeof namelen);
X		namelen = int_fmt(namelen);
X		mac_io(read, macname, namelen);
X		mac_io(read, macbuf, bodylen);
X		output_new_definition(macname, macbuf, bodylen);
X	}		
X}
X
pr_putc(c)
X{
X	if (c == '\\' || c == '^')
X		putchar('\\');
X	 else if (c < ' ' || c == '\177') {
X		putchar('^');
X		c = (c == '\177') ? '?' : (c + '@');
X	}
X	putchar(c);
X}
X
output_new_definition(name, body, bodylen)
char	*name,
X	*body;
X{
X	int	i;
X
X	fprintf(stdout, "define-macro %s ", name);
X	for (i = 0; i < bodylen; i++)
X		pr_putc(body[i]);
X	putchar('\n');
X}
X
main(argc, argv)
char	*argv[];
X{
X	if (argc != 2) {
X		fprintf(stderr, "usage: macvert <old-style-macro-file>\n");
X		exit(1);
X	}
X
X	read_and_write_macros(argv[1]);
X}
END_OF_FILE
if test 3170 -ne `wc -c <'./macvert.c'`; then
    echo shar: \"'./macvert.c'\" unpacked with wrong size!
fi
# end of './macvert.c'
fi
if test -f './menumaps.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./menumaps.txt'\"
else
echo shar: Extracting \"'./menumaps.txt'\" \(2539 characters\)
sed "s/^X//" >'./menumaps.txt' <<'END_OF_FILE'
X/************************************************************************
X * This program is Copyright (C) 1986 by Jonathan Payne.  JOVE is	*
X * provided to you without charge, and with no warranty.  You may give	*
X * away copies of JOVE, including sources, provided that this notice is *
X * included in all the files.						*
X ************************************************************************/
X
X/* menumaps.txt K. Mitchum 1/88. The same warnings apply as in keymaps.txt.
X   You MUST use a version of setmaps compiled with MAC defined for this
X   file to be converted correctly. */
X
X
X#include "jove.h"
X#include "mac.h"
X#MENU
data_obj MDIV = { STRING, "(-" };
data_obj MAJM = { STRING, "(Major Modes:" };
data_obj MINM = { STRING, "(Minor Modes:" };
data_obj BOOL = { STRING, "(Boolean:" };
data_obj DECM = { STRING, "(Decimal:" };
data_obj STRM = { STRING, "(String:" };
data_obj CHAR = { STRING, "(Character:" };
X#define MENU_DIV &MDIV
X
struct menu Menus[NMENUS] = {
X"File",101,0, {
X	"visit-file",
X	"find-file",
X	"insert-file",
X	MENU_DIV,
X	"save-file",
X	"write-file",
X	MENU_DIV,
X	"write-modified-files",
X	"write-region",
X	MENU_DIV,
X	"write-macros-to-file",
X	MENU_DIV,
X	"exit-jove",
X	0
X},
X
X"Buffer",103,0, {
X	&MAJM,
X	"c-mode",
X	"fundamental-mode",
X	"lisp-mode",
X	"text-mode",
X	&MINM,
X	"auto-fill-mode",
X	"auto-indent-mode",
X	"over-write-mode",
X	"show-match-mode",
X	"word-abbrev-mode",
X	MENU_DIV,
X	0
X},
X
X"Window",104,0, {
X	"grow-window",
X	"shrink-window",
X	MENU_DIV,
X	"split-current-window",
X	"delete-other-windows",
X	"window-find",
X	MENU_DIV,
X	"number-lines-in-window",
X	0
X},
X
X"Point",105,0, {
X	"set-mark",
X	"exchange-point-and-mark",
X	MENU_DIV,
X	"search-forward",
X	"search-reverse",
X	"i-search-forward",
X	"i-search-reverse",
X	"query-replace-string",
X	"replace-string",
X	MENU_DIV,
X	"find-tag",
X	0
X},
X
X"Command",106,0, {
X	"begin-kbd-macro",
X	"end-kbd-macro",
X	"name-kbd-macro",
X	"execute-kbd-macro",
X	"execute-macro",
X	MENU_DIV,
X	"bind-macro-to-key",
X	"bind-to-key",
X	"describe-key",
X	MENU_DIV,
X	"execute-named-command",
X	0
X},
X
X"Set",107,0, {
X	&BOOL,
X	"allow-bad-filenames",
X	"auto-case-abbrev",
X	"case-ignore-search",
X	"files-should-end-with-newline",
X	"macify",
X	"make-backup-files",
X	"marks-should-float",
X	"match-regular-expressions",
X	"send-typeout-to-buffer",
X	"wrap-search",
X	&DECM,
X	"c-indentation-increment",
X	"internal-tabstop",
X	"left-margin",
X	"mark-threshold",
X	"paren-flash-delay",
X	"right-margin",
X	"scroll-step",
X	"sync-frequency",
X	&STRM,
X	"comment-format",
X	"mode-line",
X	"tag-file",
X	&CHAR,
X	"abort-char",
X	0
X}
X};
X
END_OF_FILE
if test 2539 -ne `wc -c <'./menumaps.txt'`; then
    echo shar: \"'./menumaps.txt'\" unpacked with wrong size!
fi
# end of './menumaps.txt'
fi
if test -f './mjovers.Hqx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./mjovers.Hqx'\"
else
echo shar: Extracting \"'./mjovers.Hqx'\" \(1105 characters\)
sed "s/^X//" >'./mjovers.Hqx' <<'END_OF_FILE'
X(This file must be converted with BinHex 4.0)
X
X:#QeUEhCP,R*cFQ-!2j!%5PB`-3#3#!1JIqJ!N!3"!*!$![i!!!(q!*!$SJ%,!3F
X""J%'!3F"#3%(!3J"#3%+!38!"J!'!3S"#`!(#QeUEhCP,R*cFQ0b!J#30Cj)c4F
X!N!B$S!-5!!N!!J#3!c-!N$+L!%e5J!#3$`(!!*!,!`#3"6!!!!)Dd!#3#"!!N"-
F5PB`-3#3!`&*3diM!*!&J%C548B!N!@!!*!("d&38%`!N!8"!2q3!`#J!!%![q-
X"`+!!!8#2rm&`J!!"8)2rm9b!!!&8Mrr"9)!!!95i!!&8J!!"92q3!e5!!!&8[q-
X"9)!!!952rm&8J!!"9)2rm95!!!&8Mrr"9)!!!95i!!&8J!!"92q3!e6rN!08)!!
X!9$rrrp3)!!!8$rrrp!)!!!3$rrrmrj!$!2q3!`$rN!2!rj!$`2q3!r$rN!2`rj!
X$r2q3!rcrN!2mrj!$r2q3!rcrN!2mrj!$r2q3!rcrN!2mrj!$r2q3!rcrN!2mrj!
X$r2q3!rcrN!2mrj!$r2q3!rcrN!2mrj!$r2q3!r`rrrrm2rrrr!rrrr`2rrrm!rr
rr!2rrr`!N!1Z!!B!N!@q!A)!dJ'Z"!*25`#3"5J!&!$`!8m!N!F$!"3!$3(##!*
H-!#3"3m!&!!M!A`)!Pia!*!&+!&H!$F"c!J2B#!p)%963d&345"VCANZ%J#3"6F
X"AJ"'!F`)%N0[E@eKEQ3JB#!p)'!JDf9j,J#3"8X"AJ"Z!F`))80[ER4bEf`J25"
X$EfeYB@jN)'pb)%0[ER4bEf`J5f9j,JJ!N!-9!*!%!33"c!!"!*!)"q3!N!-"!*!
X$![i!!!(q!*!$SJ!"h(B%DJ#3!a`!PJ!&3Nj%6!#3!c*+9M!a!*!$2NC548B!N!0
X+5801)`#3!eC%594-!*!$BN4-6dF!N!0Z!)$rr`#3"3(XXJ!!rrm!N!-J!!(Y!J#
X!rrm!N!-N!!(H8J#!rrm!N!-[!!(XpJINrrm!!!%c!!(XeJI3!*!%!H8!!HbL#d&
X#6e98AdT%6%p(Ep3:
END_OF_FILE
if test 1105 -ne `wc -c <'./mjovers.Hqx'`; then
    echo shar: \"'./mjovers.Hqx'\" unpacked with wrong size!
fi
# end of './mjovers.Hqx'
fi
if test -f './portsrv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./portsrv.c'\"
else
echo shar: Extracting \"'./portsrv.c'\" \(3429 characters\)
sed "s/^X//" >'./portsrv.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X/* This is a server for jove sub processes.  It runs the command and
X   signals jove when there is some output ready to send to jove. By the
X   time we get here, out standard output goes to jove's process input. */
X
X#include "tune.h"
X
X#ifdef PIPEPROCS	/* the whole file! */
X
X#include "jove.h"
X
X#include <signal.h>
X#include <sys/ioctl.h>
X#ifdef BSD4_2
X#   include <sys/wait.h>
X#else
X#   include <wait.h>
X#endif
X
struct header {
X	int	pid;
X	int	nbytes;
X	char	buf[512];
X} header;
X
X#define HEADSIZE	((sizeof header.pid) + sizeof (header.nbytes))
X
error(str)
char	*str;
X{
X	header.pid = getpid();
X	header.nbytes = strlen(str);
X	strcpy(header.buf, str);
X	proc_write(&header, header.nbytes + HEADSIZE);
X	exit(-2);
X}
X
int	ppid,
X	InputFD,
X	JovesInput;
X
p_inform()
X{
X	long	nbytes;
X
X	ioctl(JovesInput, FIONREAD, (char *) &nbytes);
X	if (nbytes > 0)
X		kill(ppid, INPUT_SIG);
X}
X
proc_write(ptr, n)
char	*ptr;
X{
X	long	nbytes;
X
X	ioctl(1, FIONREAD, (char *) &nbytes);
X	
X	if (nbytes == 0)
X		kill(ppid, INPUT_SIG);
X
X	(void) write(1, ptr, n);
X	alarm(1);
X}
X
read_pipe()
X{
X	register int	n;
X	
X	(void) signal(SIGALRM, p_inform);
X
X	while ((header.nbytes = read(InputFD, header.buf, sizeof header.buf)) > 0) {
X		n = HEADSIZE + header.nbytes;
X		proc_write(&header, n);
X	}
X}
X
X/* ARGSUSED */
main(argc, argv)
char	*argv[];
X{
X	int	p[2];
X	int	pid;
X	int	tty_fd,
X		i;
X
X/*	tty_fd = open("/dev/tty", 1); */
X
X	if (pipe(p) == -1)
X		error("Cannot pipe jove portsrv.\n");
X
X/*	for (i = 0; i < argc; i++) {
X		write(tty_fd, "*argv++ = ", 10);
X		write(tty_fd, argv[i], strlen(argv[i]));
X		write(tty_fd, "\n", 1);
X	} */
X
X	ppid = getppid();
X	switch (pid = fork()) {
X	case -1:
X		error("portsrv: cannot fork.\n");
X
X	case 0:
X		/* We'll intercept childs output in p[0] */
X		(void) dup2(p[1], 1);
X		(void) dup2(p[1], 2);
X		(void) close(p[0]);
X		(void) close(p[1]);
X			
X		(void) setpgrp(getpid(), getpid());
X		execv(argv[2], &argv[3]);
X		_exit(-4);
X
X	default:
X		(void) close(0);
X
X		 /* don't want this guy to read anything jove sends to
X		    our soon to be created child */
X
X		JovesInput = atoi(argv[1]);
X		(void) signal(SIGINT, SIG_IGN);
X		(void) signal(SIGQUIT, SIG_IGN);
X		(void) close(p[1]);
X
X		/* tell jove the pid of the real child as opposed to us */
X		header.pid = getpid();
X		header.nbytes = sizeof (int);
X		*(int *) header.buf = pid;
X		(void) write(1, (char *) &header, sizeof pid + HEADSIZE);
X		p_inform();	/* Inform jove */
X
X		/* read proc's output and send it to jove */
X		InputFD = p[0];
X		read_pipe();
X		(void) close(p[0]);
X		header.pid = getpid();
X		header.nbytes = EOF;	/* tell jove we are finished */
X		(void) write(1, (char *) &header, HEADSIZE);
X		p_inform();
X		/* try to exit like our child did ... */
X		{
X			union wait	w;
X
X#ifndef BSD4_2
X			while (wait2(&w.w_status, 0) != pid)
X#else
X			while (wait3(&w.w_status, 0, 0) != pid)
X#endif
X				;
X			if (WIFEXITED(w))
X				exit(w.w_retcode);
X			else if (WIFSIGNALED(w))
X				kill(getpid(), w.w_termsig);
X		}
X	}
X}
X
X#else /* PIPEPROCS */
main()
X{
X}
X#endif
END_OF_FILE
if test 3429 -ne `wc -c <'./portsrv.c'`; then
    echo shar: \"'./portsrv.c'\" unpacked with wrong size!
fi
# end of './portsrv.c'
fi
if test -f './re.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./re.h'\"
else
echo shar: Extracting \"'./re.h'\" \(874 characters\)
sed "s/^X//" >'./re.h' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#define NALTS	10	/* number of alternate search strings */
X
extern char	searchstr[128],
X		compbuf[128],		/* global default compbuf */
X		rep_search[128],	/* replace search string */
X		rep_str[128],		/* contains replacement string */
X		*cur_compb,		/* usually points at compbuf */
X		REbuf[LBSIZE],		/* points at line we're scanning */
X		*alternates[NALTS];
X
extern int	REdirection,
X		REeom,
X		REbom,
X		REalt_num;
END_OF_FILE
if test 874 -ne `wc -c <'./re.h'`; then
    echo shar: \"'./re.h'\" unpacked with wrong size!
fi
# end of './re.h'
fi
if test -f './rec.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rec.c'\"
else
echo shar: Extracting \"'./rec.c'\" \(3912 characters\)
sed "s/^X//" >'./rec.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#include "jove.h"
X#include "io.h"
X#include "rec.h"
X
X#ifndef MAC
X#	include <sys/file.h>
X#endif
X
private int	rec_fd = -1;
private char	*recfname;
private File	*rec_out;
X
X#ifndef L_SET
X#	define L_SET 0
X#endif
X
private struct rec_head	Header;
X
recinit()
X{
X	char	buf[128];
X
X#ifdef MAC
X	sprintf(buf, "%s/%s", HomeDir, p_tempfile);
X#else
X	sprintf(buf, "%s/%s", TmpFilePath, p_tempfile);
X#endif
X	recfname = copystr(buf);
X	recfname = mktemp(recfname);
X	rec_fd = creat(recfname, 0644);
X	if (rec_fd == -1) {
X		complain("Cannot create \"%s\"; recovery disabled.", recfname);
X		return;
X	}
X	/* initialize the record IO */
X	rec_out = fd_open(recfname, F_WRITE|F_LOCKED, rec_fd, iobuff, LBSIZE);
X
X	/* Initialize the record header. */
X	Header.Uid = getuid();
X	Header.Pid = getpid();
X	Header.UpdTime = 0L;
X	Header.Nbuffers = 0;
X	(void) write(rec_fd, (char *) &Header, sizeof Header);
X}
X
recclose()
X{
X	if (rec_fd == -1)
X		return;
X	(void) close(rec_fd);
X	rec_fd = -1;
X	(void) unlink(recfname);
X}
X
private
putaddr(addr, p)
disk_line	addr;
register File	*p;
X{
X	register char	*cp = (char *) &addr;
X	register int	nchars = sizeof (disk_line);
X
X	while (--nchars >= 0)
X		putc(*cp++ & 0377, p);
X}
X
private
putn(cp, nbytes)
register char	*cp;
register int	nbytes;
X{
X	while (--nbytes >= 0)
X		putc(*cp++ & 0377, rec_out);
X}
X
X/* Write out the line pointers for buffer B. */
X
private
dmppntrs(b)
register Buffer	*b;
X{
X	register Line	*lp;
X
X	for (lp = b->b_first; lp != 0; lp = lp->l_next)
X		putaddr(lp->l_dline, rec_out);
X}
X
X/* dump the buffer info and then the actual line pointers. */
X
private
dmp_buf_header(b)
register Buffer	*b;
X{
X	struct rec_entry	record;
X	register Line	*lp;
X	register int	nlines = 0;
X
X	for (lp = b->b_first; lp != 0; lp = lp->l_next, nlines++)
X		if (lp == b->b_dot)
X			record.r_dotline = nlines;
X	strcpy(record.r_fname, b->b_fname ? b->b_fname : NullStr);
X	strcpy(record.r_bname, b->b_name);
X	record.r_nlines = nlines;
X	record.r_dotchar = b->b_char;
X	putn((char *) &record, sizeof record);
X}
X
X/* Goes through all the buffers and syncs them to the disk. */
X
int	SyncFreq = 50;
X
SyncRec()
X{
X	extern disk_line	DFree;
X	register Buffer	*b;
X	static int	beenhere = NO;
X
X	if (beenhere == NO) {
X		recinit();	/* Init recover file. */
X		beenhere = YES;
X	}
X	if (rec_fd == -1)
X		return;
X	lseek(rec_fd, 0L, L_SET);
X	(void) time(&Header.UpdTime);
X	Header.Nbuffers = 0;
X	for (b = world; b != 0; b = b->b_next)
X		if (b->b_type == B_SCRATCH || !IsModified(b))
X			continue;
X		else
X			Header.Nbuffers += 1;
X	Header.FreePtr = DFree;
X	putn((char *) &Header, sizeof Header);
X	if (Header.Nbuffers != 0) {
X		lsave();	/* this makes things really right */
X		SyncTmp();
X		for (b = world; b != 0; b = b->b_next)
X			if (b->b_type == B_SCRATCH || !IsModified(b))
X				continue;
X			else
X				dmp_buf_header(b);
X		for (b = world; b != 0; b = b->b_next)
X			if (b->b_type == B_SCRATCH || !IsModified(b))
X				continue;
X			else
X				dmppntrs(b);
X	}
X	flush(rec_out);
X}
X
X/* Full Recover.  What we have to do is go find the name of the tmp
X   file data/rec pair and use those instead of the ones we would have
X   created eventually.  The rec file has a list of buffers, and then
X   the actual pointers.  Stored for each buffer is the buffer name,
X   the file name, the number of lines, the current line, the current
X   character.  The current modes do not need saving as they will be
X   saved when the file name is set.  If a process was running in a
X   buffer, it will be lost. */
X
FullRecover()
X{
X}
END_OF_FILE
if test 3912 -ne `wc -c <'./rec.c'`; then
    echo shar: \"'./rec.c'\" unpacked with wrong size!
fi
# end of './rec.c'
fi
if test -f './rec.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rec.h'\"
else
echo shar: Extracting \"'./rec.h'\" \(826 characters\)
sed "s/^X//" >'./rec.h' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
struct rec_head {
X	int		Uid,		/* uid of owner */
X			Pid;		/* pid of jove process */
X	time_t		UpdTime;	/* last time this was updated */
X	int		Nbuffers;	/* number of buffers */
X	disk_line	FreePtr;	/* position of DFree */
X};
X
struct rec_entry {
X	char	r_bname[128],
X		r_fname[128];
X	int	r_nlines,
X		r_dotline,	/* so we can really save the context */
X		r_dotchar;
X};
END_OF_FILE
if test 826 -ne `wc -c <'./rec.h'`; then
    echo shar: \"'./rec.h'\" unpacked with wrong size!
fi
# end of './rec.h'
fi
if test -f './table.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./table.c'\"
else
echo shar: Extracting \"'./table.c'\" \(1145 characters\)
sed "s/^X//" >'./table.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#include "jove.h"
X#include "table.h"
X
private Table	*tables = NIL;
X
Table *
make_table()
X{
X	Table	*tab = (Table *) emalloc(sizeof *tab);
X
X	tab->t_next = tables;
X	tables = tab;
X	tab->t_wordlist = NIL;
X
X	return tab;
X}
X
Word *
word_in_table(text, table)
char	*text;
Table	*table;
X{
X	register Word	*w;
X
X	for (w = table_top(table); w != NIL; w = next_word(w))
X		if (strcmp(word_text(w), text) == 0)
X			break;	/* already in list */
X	return w;
X}
X
void
add_word(wname, table)
char	*wname;
Table	*table;
X{
X	register Word	*w;
X
X	if (w = word_in_table(wname, table))
X		return;
X	w = (Word *) emalloc(sizeof *w);
X	word_text(w) = wname;
X	next_word(w) = table_top(table);
X	table_top(table) = w;
X}
END_OF_FILE
if test 1145 -ne `wc -c <'./table.c'`; then
    echo shar: \"'./table.c'\" unpacked with wrong size!
fi
# end of './table.c'
fi
if test -f './table.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./table.h'\"
else
echo shar: Extracting \"'./table.h'\" \(888 characters\)
sed "s/^X//" >'./table.h' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
typedef struct word	Word;
typedef struct table	Table;
X
struct word {
X	Word	*wd_next;
X	char	*wd_text;
X};
X
struct table {
X	Table	*t_next;
X	Word	*t_wordlist;
X};
X
extern Table	*make_table();
extern Word	*word_in_table();
X
X#define	table_top(table)	(table->t_wordlist)
X#define next_word(w)		(w->wd_next)
X#define last_word_p(w)		(w->wd_next == NIL)
X#define word_text(w)		(w->wd_text)
X#define word_length(w)		(strlen(word_text(w)))
END_OF_FILE
if test 888 -ne `wc -c <'./table.h'`; then
    echo shar: \"'./table.h'\" unpacked with wrong size!
fi
# end of './table.h'
fi
if test -f './teachjove.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./teachjove.c'\"
else
echo shar: Extracting \"'./teachjove.c'\" \(1070 characters\)
sed "s/^X//" >'./teachjove.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/file.h>
X
X#ifndef TEACHJOVE
X#    define TEACHJOVE	"/usr/lib/jove/teach-jove"
X#endif
X
X#ifndef W_OK
X#   define W_OK	2
X#   define F_OK	0
X#endif
X
extern char	*getenv();
X
main()
X{
X	char	cmd[256],
X		fname[256],
X		*home;
X
X	if ((home = getenv("HOME")) == 0) {
X		printf("teachjove: cannot find your home!\n");
X		exit(-1);
X	}
X	(void) sprintf(fname, "%s/teach-jove", home);
X	if (access(fname, F_OK) != 0) {
X		(void) sprintf(cmd, "cp %s %s", TEACHJOVE, fname);
X		system(cmd);
X	}
X	(void) execlp("jove", "teachjove", fname, (char *) 0);
X	printf("teachjove: cannot execl jove!\n");
X}
X
END_OF_FILE
if test 1070 -ne `wc -c <'./teachjove.c'`; then
    echo shar: \"'./teachjove.c'\" unpacked with wrong size!
fi
# end of './teachjove.c'
fi
if test -f './temp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./temp.h'\"
else
echo shar: Extracting \"'./temp.h'\" \(4029 characters\)
sed "s/^X//" >'./temp.h' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X/* The tmp file is indexed in chunks of CH_SIZE characters.  CH_SIZE is
X   (1 << CH_BITS).  New lines are added to the end of the tmp file.  The
X   file is not garbage collected because that would be too painful.  As a
X   result, commands like Yank and Kill are really easy; basically all we
X   do is make copies of the disk addresses of the lines (as opposed to
X   the contents).  So, putline(buf) writes BUF to the disk and returns a
X   new disk address.  Getline(addr, buf) is the opposite of putline().
X   f_getputl(line, fp) reads from open FP directly into the tmp file (into
X   the buffer cache (see below)) and stores the address in LINE.  This is
X   used during read_file to minimize compying.
X
X   Lines do NOT cross block bounderies in the tmp file so that accessing
X   the contents of lines can be much faster.  Pointers to offsets into
X   disk buffers are returned instead of copying the contents into local
X   arrays and then using them.  This cuts down on the amount of copying a
X   great deal, at the expense of less efficiency.  The lower bit of disk
X   addresses is used for marking lines as needing redisplay done.
X
X   There is a buffer cache of NBUF buffers (64 on !SMALL machines and the
X   3 on small ones).  The blocks are stored in LRU order and each block
X   is also stored in a hash table by block #.  When a block is requested
X   it can quickly be looked up in the hash table.  If it's not there the
X   LRU block is assigned the new block #.  If it finds that the LRU block
X   is dirty (i.e., has pending IO) it syncs the WHOLE tmp file, i.e.,
X   does all the pending writes.  This works much better on floppy disk
X   systems, like the IBM PC, if the blocks are sorted before sync'ing. */
X
X#ifdef SMALL
X#   define CH_BITS		4
X#   if BUFSIZ == 512
X#	define MAX_BLOCKS	1024
X#   else
X#	define MAX_BLOCKS	512
X#   endif
X#else
X#   define CH_BITS		0
X#   define MAX_BLOCKS		4096	/* basically unlimited */
X#endif /* SMALL */
X
X#if BUFSIZ == 512
X#   define BNO_SHIFT		(9 - CH_BITS)
X#else
X#   define BNO_SHIFT		(10 - CH_BITS)
X#endif
X
X/* CH_SIZE is how big each chunk is.  For each 1 the DFree pointer
X   is incremented we extend the tmp file by CH_SIZE characters.
X   CH_PBLOCK is the # of chunks per block.  RND_MASK is used to mask
X   off the lower order bits of the daddr to round down to the beginning
X   of a block.  OFF_MASK masks off the higher order bits so we can get
X   at the offset into the disk buffer.
X
X   NOTE:  It's pretty important that these numbers be multiples of
X	  2.  Be careful if you change things. */
X#ifndef MAC
X#define CH_SIZE			(1 << CH_BITS)
X#define CH_PBLOCK		(BUFSIZ / CH_SIZE)
X#define RND_MASK		(CH_PBLOCK - 1)
X#define OFF_MASK		(BUFSIZ - 1)
X#define BNO_MASK		(MAX_BLOCKS - 1)
X#define blk_round(daddr)	(daddr & ~RND_MASK)
X#define forward_block(daddr)	(daddr + CH_PBLOCK)
X#define da_to_bno(daddr)	((daddr >> BNO_SHIFT) & BNO_MASK)
X#define da_to_off(daddr)	((daddr << CH_BITS) & OFF_MASK)
X#define da_too_huge(daddr)	((daddr >> BNO_SHIFT) >= MAX_BLOCKS)
X#else
X#define CH_SIZE			((disk_line)1 << CH_BITS)
X#define CH_PBLOCK		((disk_line)BUFSIZ / CH_SIZE)
X#define RND_MASK		((disk_line)CH_PBLOCK - 1)
X#define OFF_MASK		((disk_line)BUFSIZ - 1)
X#define BNO_MASK		((disk_line)MAX_BLOCKS - 1)
X#define blk_round(daddr)	((disk_line)daddr & ~RND_MASK)
X#define forward_block(daddr)	((disk_line)daddr + CH_PBLOCK)
X#define da_to_bno(daddr)	((disk_line)(daddr >> BNO_SHIFT) & BNO_MASK)
X#define da_to_off(daddr)	((disk_line)(daddr << CH_BITS) & OFF_MASK)
X#define da_too_huge(daddr)	((disk_line)(daddr >> BNO_SHIFT) >= MAX_BLOCKS)
X#endif
END_OF_FILE
if test 4029 -ne `wc -c <'./temp.h'`; then
    echo shar: \"'./temp.h'\" unpacked with wrong size!
fi
# end of './temp.h'
fi
if test -f './termcap.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./termcap.h'\"
else
echo shar: Extracting \"'./termcap.h'\" \(2260 characters\)
sed "s/^X//" >'./termcap.h' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#define MAXCOLS		256	/* maximum number of columns */
X
X#ifndef MAC
X#ifndef _TERM
X
X/* termcap definitions */
X
extern char
X	*UP,	/* Scroll reverse, or up */
X	*CS,	/* If on vt100 */
X	*SO,	/* Start standout */
X	*SE,	/* End standout */
X	*CM,	/* The cursor motion string */
X	*CL,	/* Clear screen */
X	*CE,	/* Clear to end of line */
X	*HO,	/* Home cursor */
X	*AL,	/* Addline (insert line) */
X	*DL,	/* Delete line */
X	*VS,	/* Visual start */
X	*VE,	/* Visual end */
X	*KS,	/* Keypad mode start */
X	*KE,	/* Keypad mode end */
X	*TI,	/* Cursor addressing start */
X	*TE,	/* Cursor addressing end */
X	*IC,	/* Insert char */
X	*DC,	/* Delete char */
X	*IM,	/* Insert mode */
X	*EI,	/* End insert mode */
X	*LL,	/* Last line, first column */
X	*M_IC,	/* Insert char with arg */
X	*M_DC,	/* Delete char with arg */
X	*M_AL,	/* Insert line with arg */
X	*M_DL,	/* Delete line with arg */
X	*SF,	/* Scroll forward */
X	*SR,	/* Scroll reverse */
X	*SP,	/* Send cursor position */
X	*VB,	/* visible bell */
X	*BL,	/* audible bell */
X	*IP,	/* insert pad after character inserted */
X	*lPC,
X	*NL;	/* newline character (usually \n) */
X
extern int
X	LI,		/* number of lines */
X	ILI,		/* number of internal lines */
X	CO,		/* number of columns */
X
X	UL,		/* underscores don't replace chars already on screen */
X	MI,		/* okay to move while in insert mode */
X	SG,		/* number of magic cookies left by SO and SE */
X
X	TABS,		/* whether we are in tabs mode */
X	UPlen,		/* length of the UP string */
X	HOlen,		/* length of Home string */
X	LLlen;		/* length of lower string */
X
extern char
X	PC,
X	*BC;		/* back space */
X
extern short	ospeed;
X
X#endif /* _TERM */
X
X#else /* MAC */	
extern int	/* probably should clean this up */
X	LI,		/* number of lines */
X	ILI,		/* number of internal lines */
X	CO,		/* number of columns */
X	TABS,
X	SG;
X#endif /* MAC */
END_OF_FILE
if test 2260 -ne `wc -c <'./termcap.h'`; then
    echo shar: \"'./termcap.h'\" unpacked with wrong size!
fi
# end of './termcap.h'
fi
if test -f './tune.dos' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./tune.dos'\"
else
echo shar: Extracting \"'./tune.dos'\" \(868 characters\)
sed "s/^X//" >'./tune.dos' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#define NOEXTERNS
X
X#include "tune.h"
X
X/* these are variables that can be set with the set command, so they are
X   allocated more memory than they actually need for the defaults */
char	TmpFilePath[64] = ".",
X	Shell[64] = "command",
X	ShFlags[16] = "-c",
X	CmdDb[64] = "c:/unix/cmds.doc";
X
X/* these guys are not settable */
char	*d_tempfile = "joveXXXXXX",	/* buffer lines go here */
X	*Joverc = "jove.rc";
X
END_OF_FILE
if test 868 -ne `wc -c <'./tune.dos'`; then
    echo shar: \"'./tune.dos'\" unpacked with wrong size!
fi
# end of './tune.dos'
fi
if test -f './tune.template' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./tune.template'\"
else
echo shar: Extracting \"'./tune.template'\" \(1038 characters\)
sed "s/^X//" >'./tune.template' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#define NOEXTERNS
X
X#include "tune.h"
X
char	*d_tempfile = "joveXXXXXX",	/* buffer lines go here */
X	*p_tempfile = "jrecXXXXXX",	/* line pointers go here */
X	*Recover = "LIBDIR/recover",
X	*CmdDb = "LIBDIR/cmds.doc",
X		/* copy of "cmds.doc" lives in the doc subdirectory */
X
X	*Joverc = "LIBDIR/.joverc",
X
X#ifdef PIPEPROCS
X	*Portsrv = "LIBDIR/portsrv",
X#endif
X
X/* these are variables that can be set with the set command, so they are
X   allocated more memory than they actually need for the defaults */
X
X	TmpFilePath[128] = "TMPDIR",
X	Shell[128] = "SHELL",
X	ShFlags[16] = "-c";
END_OF_FILE
if test 1038 -ne `wc -c <'./tune.template'`; then
    echo shar: \"'./tune.template'\" unpacked with wrong size!
fi
# end of './tune.template'
fi
if test -f './version.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./version.c'\"
else
echo shar: Extracting \"'./version.c'\" \(487 characters\)
sed "s/^X//" >'./version.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
char	*version = "4.9";
END_OF_FILE
if test 487 -ne `wc -c <'./version.c'`; then
    echo shar: \"'./version.c'\" unpacked with wrong size!
fi
# end of './version.c'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2625 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X ./MANIFEST                 1	
X ./Makefile                 4	
X ./Makefile.dos             1	
X ./Ovmakefile               3	
X ./README                   4	
X ./Readme.dos               5	
X ./Readme.mac               8	
X ./abbrev.c                 3	
X ./argcount.c               1	
X ./ask.c                    6	
X ./buf.c                    6	
X ./c.c                      7	
X ./case.c                   1	
X ./ctype.c                  5	
X ./ctype.h                  1	
X ./delete.c                 3	
X ./disp.c                  13	
X ./doc/README               1	
X ./doc/cmds.doc.nr          1	
X ./doc/example.rc           1	
X ./doc/jove.1              19	
X ./doc/jove.2              17	
X ./doc/jove.3               6	
X ./doc/jove.4              20	
X ./doc/jove.5              16	
X ./doc/jove.nr              5	
X ./doc/jove.qref            2	
X ./doc/system.rc            1	
X ./doc/teach-jove          18	
X ./doc/teachjove.nr         1	
X ./extend.c                10	
X ./externs.h               11	
X ./fmt.c                    4	
X ./fp.c                     3	
X ./funcdefs.c               9	
X ./getch.c                  1	
X ./insert.c                 7	
X ./io.c                    12	
X ./io.h                     1	
X ./iproc-pipes.c            3	
X ./iproc-ptys.c             3	
X ./iproc.c                  4	
X ./jove.c                  11	
X ./jove.h                   8	
X ./keymaps.txt             15	
X ./mac.c                   21	
X ./mac.h                    2	
X ./macros.c                 3	
X ./macvert.c                1	
X ./malloc.c                 2	
X ./marks.c                  2	
X ./menumaps.txt             1	
X ./misc.c                   4	
X ./mjovers.Hqx              1	
X ./move.c                   2	
X ./paragraph.c              6	
X ./portsrv.c                1	
X ./proc.c                   9	
X ./re.c                    10	
X ./re.h                     1	
X ./re1.c                    5	
X ./rec.c                    1	
X ./rec.h                    1	
X ./recover.c                7	
X ./scandir.c                2	
X ./screen.c                14	
X ./setmaps.c                2	
X ./table.c                  1	
X ./table.h                  1	
X ./teachjove.c              1	
X ./temp.h                   1	
X ./term.c                   2	
X ./termcap.h                1	
X ./tune.dos                 1	
X ./tune.h                   2	
X ./tune.template            1	
X ./util.c                   8	
X ./vars.c                   2	
X ./version.c                1	
X ./wind.c                   4	
X MANIFEST                   1	This shipping list
END_OF_FILE
if test 2625 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
echo shar: End of archive 1 \(of 21\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
