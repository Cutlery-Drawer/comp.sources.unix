Subject:  v14i067:  Jove, an emacs variant, version 4.9, Part11/21
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Jonathan Payne <jpayne@cs.rochester.edu>
Posting-number: Volume 14, Issue 67
Archive-name: jove4.9/part11

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 11 (of 21)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f './externs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./externs.h'\"
else
echo shar: Extracting \"'./externs.h'\" \(21599 characters\)
sed "s/^X//" >'./externs.h' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#ifdef TXT_TO_C
X#define STDIO
X#endif
X#ifdef LINT_ARGS
extern int
X	abs(int);
X
extern void
X	exit(int),
X	_exit(int),
X	*calloc(unsigned int, unsigned int),
X#ifndef MAC
X	free(void *),	/* returns an int on a Mac */
X#endif
X	*malloc(unsigned int),
X	*realloc(void *, unsigned int);
X
extern char
X	*getenv(char *),
X	*tgoto(char *, int, int);
X
extern  char 
X	**scanvec(char * *args,char *str),
X	*IOerr(char *err,char *file),
X	*MakeName(char *command),
X	*StrIndex(int dir,char *buf,int charpos,char what),
X	*ask(char *, char *, ...),
X	*ask_buf(struct buffer *def),
X	*ask_file(char *prmt,char *def,char *buf),
X	*basename(char *f),
X	*copystr(char *str),
X	*do_ask(char *, int (*)(), char *, char *, ...),
X	*emalloc(int size),
X	*filename(struct buffer *b),
X	*get_time(long *timep,char *buf,int from,int to),
X	*getsearch(void),
X	*itoa(int num),
X	*lbptr(struct line *line),
X	*lcontents(struct line *line),
X	*ltobuf(struct line *line,char *buf),
X	*pr_name(char *fname,int okay_home),
X	*ralloc(char *obj,int size),
X	*sprint(char *, ...),
X	switchar(void);
X
extern  int 
X	BufSwrite(int linenum),
X	FLine(struct window *w),
X	LineDist(struct line *nextp,struct line *endp),
X	LookingAt(char *pattern,char *buf,int offset),
X	ModBufs(int allp),
X	ModMacs(void),
X	Peekc(void),
X	TwoBlank(void),
X	UnixToBuf(char *,int ,int ,int , ...),
X	addgetc(void),
X	alphacomp(char * *a,char * *b),
X	arg_type(void),
X	arg_value(void),
X	ask_int(char *prompt,int base),
X	aux_complete(int c),
X	blnkp(char *buf),
X	calc_pos(char *lp,int c_char),
X	casecmp(char *s1,char *s2),
X	casencmp(char *s1,char *s2,int n),
X	charp(void),
X	chr_to_int(char *cp,int base,int allints, int *result),
X	complete(char * *possible,char *prompt,int flags),
X	do_if(char *cmd),
X	dosputc(char c),
X	f_getint(struct File *fp),
X	f_gets(struct File *fp,char *buf,int max),
X	f_match(char *file),
X	filbuf(struct File *fp),
X	find_pos(struct line *line,int c_char),
X	fixorder(struct line * *line1,int *char1,struct line * *line2,int *char2),
X	_flush(int c,struct File *fp),
X	getch(void),
X	getchar(void),
X	getrawinchar(void),
X	how_far(struct line *line,int col),
X	i_blank(struct line *lp),
X	i_bsblank(struct line *lp),
X	in_window(struct window *windes,struct line *line),
X	inlist(struct line *first,struct line *what),
X	in_macro(void),
X	inorder(struct line *nextp,int char1,struct line *endp,int char2),
X	is_an_arg(void),
X	ismword(int c),
X	joverc(char *file),
X	length(struct line *line),
X	look_at(char *expr),
X#ifdef IBMPC
X	lower(char *c),
X#endif
X	mac_getc(void),
X	match(char * *choices,char *what),
X	max(int a,int b),
X	min(int a,int b),
X	numcomp(char *s1,char *s2),
X	pnt_line(void),
X	rawkey_ready(void),
X	re_lindex(struct line *line,int offset,char *expr,char * *alts,int lbuf_okay),
X	scandir(char *dir,char * * *nmptr,int (*qualify)(),int (*sorter)()),
X	sindex(char *pattern,char *string),
X	swrite(char *line,int inversep,int abortable),
X	unbind_aux(int c),
X	waitchar(int *slow),
X	yes_or_no_p(char *, ...);
X
extern  disk_line 
X	f_getputl(struct line *line,struct File *fp),
X	putline(char *buf);
X
extern  struct File 
X	*f_open(char *name,int flags,char *buffer,int buf_size),
X	*fd_open(char *name,int flags,int fd,char *buffer,int bsize),
X	*open_file(char *fname,char *buf,int how,int ifbad,int loudness);
X
extern  struct buffer 
X	*buf_exists(char *name),
X	*do_find(struct window *w,char *fname,int force),
X	*do_select(struct window *w,char *name),
X	*file_exists(char *name),
X	*getNMbuf(void);
X
extern  struct cmd 
X	*FindCmd(void (*proc)());
extern  struct data_obj 
X	**IsPrefix(struct data_obj *cp),
X	*findcom(char *prompt),
X	*findmac(char *prompt),
X	*findvar(char *prompt);
X
extern  struct line 
X	*lastline(struct line *lp),
X	*listput(struct buffer *buf,struct line *after),
X	*max_line(struct line *l1,struct line *l2),
X	*min_line(struct line *l1,struct line *l2),
X	*nbufline(void),
X	*next_line(struct line *line,int num),
X	*prev_line(struct line *line,int num),
X	*reg_delete(struct line *line1,int char1,struct line *line2,int char2);
X
extern  struct m_thread 
X	*alloc_mthread(void);
X
extern  struct mark 
X	*CurMark(void),
X	*MakeMark(struct line *line,int column,int type);
X
extern  struct position 
X	*DoYank(struct line *fline,int fchar,struct line *tline,int tchar,struct line *atline,int atchar,struct buffer *whatbuf),
X	*c_indent(int incrmt),
X	*docompiled(int dir,char *expr,char * *alts),
X	*dosearch(char *pattern,int dir,int re),
X	*lisp_indent(void),
X	*m_paren(char p_type,int dir,int can_mismatch,int can_stop);
X
extern  struct table 
X	*make_table(void);
X
extern  struct window 
X	*div_wind(struct window *wp,int n),
X	*w_nam_typ(char *name,int type),
X	*windbp(struct buffer *bp);
X
extern  struct word 
X	*word_in_table(char *text,struct table *table);
X
extern  unsigned char 
X	chpl(void),
X	lpp(void);
X
extern  void 
X	AbbrevExpand(void),
X	AddSpecial(void),
X	AllMarkSet(struct buffer *b,struct line *line,int col),
X	AppReg(void),
X	Apropos(void),
X	BList(void),
X	BSexpr(void),
X	BUpList(void),
X	BackChar(void),
X	BackPara(void),
X	BackWord(void),
X	BindAKey(void),
X	BindMac(void),
X	BindMtoW(void),
X	BindSomething(struct data_obj *(*proc)()),
X	BindWMap(struct data_obj * *map,int lastkey,struct data_obj *cmd),
X	Bof(void),
X	Bol(void),
X	Bos(void),
X	Bow(void),
X	Buf10Select(void),
X	Buf1Select(void),
X	Buf2Select(void),
X	Buf3Select(void),
X	Buf4Select(void),
X	Buf5Select(void),
X	Buf6Select(void),
X	Buf7Select(void),
X	Buf8Select(void),
X	Buf9Select(void),
X	BufErase(void),
X	BufKill(void),
X	BufList(void),
X	BufPos(void),
X	BufSelect(void),
X	CAutoExec(void),
X	CalcWind(struct window *w),
X	CapChar(void),
X	CapWord(void),
X	CasRegLower(void),
X	CasRegUpper(void),
X	CaseReg(int up),
X	CentWind(struct window *w),
X	ChkWindows(struct line *line1,struct line *line2),
X	ChrToOct(void),
X	ClAndRedraw(void),
X	Comment(void),
X	CopyRegion(void),
X	CtlxPrefix(void),
X	DFixMarks(struct line *line1,int char1,struct line *line2,int char2),
X	DOTsave(struct position *buf),
X	DefAutoExec(struct data_obj *(*proc)()),
X	DefGAbbrev(void),
X	DefKBDMac(void),
X	DefMAbbrev(void),
X	DelBlnkLines(void),
X	DelCurWindow(void),
X	DelMacro(void),
X	DelMark(struct mark *m),
X	DelNChar(void),
X	DelNWord(void),
X	DelPChar(void),
X	DelPWord(void),
X	DelReg(void),
X	DelWtSpace(void),
X	DescBindings(void),
X	DescCom(void),
X	DescMap(struct data_obj * *map,char *pref),
X	DescWMap(struct data_obj * *map,int key),
X	Digit(void),
X	Digit0(void),
X	Digit1(void),
X	Digit2(void),
X	Digit3(void),
X	Digit4(void),
X	Digit5(void),
X	Digit6(void),
X	Digit7(void),
X	Digit8(void),
X	Digit9(void),
X	DoAutoExec(char *new,char *old),
X	DoJustify(struct line *l1,int c1,struct line *l2,int c2,int scrunch,int indent),
X	DoKeys(int nocmdline),
X	DoNewline(int indentp),
X	DoPara(int dir),
X	DoParen(void),
X	DoWriteReg(int app),
X	DotTo(struct line *line,int col),
X	DownScroll(void),
X	DrawMesg(int abortable),
X	EditAbbrevs(void),
X	Eof(void),
X	Eol(void),
X	Eos(void),
X	Eow(void),
X	ErrFree(void),
X	ErrParse(void),
X	EscPrefix(void),
X	ExecCmd(struct data_obj *cp),
X	ExecMacro(void),
X	Extend(void),
X	FDotTag(void),
X	FDownList(void),
X	FList(void),
X	FSexpr(void),
X	FSrchND(void),
X	FillComment(char *format),
X	FilterRegion(void),
X	FindFile(void),
X	FindTag(void),
X	ForChar(void),
X	ForPara(void),
X	ForSearch(void),
X	ForWord(void),
X	Forget(void),
X	GCchunks(void),
X	GSexpr(void),
X	GoLine(void),
X	GotoWind(void),
X	GrowWindow(void),
X	HandlePref(struct data_obj * *map),
X	IFixMarks(struct line *line1,int char1,struct line *line2,int char2),
X	IncFSearch(void),
X	IncRSearch(void),
X	InitCM(void),
X	InsFile(void),
X	Insert(int c),
X	Justify(void),
X	KeyDesc(void),
X	KillBos(void),
X	KillEOL(void),
X	KillEos(void),
X	KillExpr(void),
X	KillSome(void),
X	Leave(void),
X	LineAI(void),
X	LineInsert(int num),
X	LowWord(void),
X	MAutoExec(void),
X	MacInter(void),
X	MakeErrors(void),
X	MarkSet(struct mark *m,struct line *line,int column),
X	MiscPrefix(void),
X	NameMac(void),
X	Newline(void),
X	NextError(void),
X	NextLine(void),
X	NextPage(void),
X	NextWindow(void),
X	NotModified(void),
X	OneWindow(void),
X	OpenLine(void),
X	PageNWind(void),
X	PageScrollDown(void),
X	PageScrollUp(void),
X	ParseAll(void),
X	PathParse(char *name,char *intobuf),
X	Placur(int line,int col),
X	PopMark(void),
X	PrVar(void),
X	PrevError(void),
X	PrevLine(void),
X	PrevPage(void),
X	PrevWindow(void),
X	PtToMark(void),
X	Push(void),
X	PushPntp(struct line *line),
X	QRepSearch(void),
X	QuotChar(void),
X	REcompile(char *pattern,int re,char *into_buf,char * *alt_bufp),
X	RErecur(void),
X	RSrchND(void),
X	ReNamBuf(void),
X	ReadFile(void),
X	Recur(void),
X	RedrawDisplay(void),
X	RegJustify(void),
X	RegReplace(void),
X	RegToUnix(struct buffer *outbuf,char *cmd),
X	Remember(void),
X	RepSearch(void),
X	ResetTerm(void),
X	RestAbbrevs(void),
X	RevSearch(void),
X	RunMacro(void),
X	SO_off(void),
X	SO_on(void),
X	SaveAbbrevs(void),
X	SaveFile(void),
X	SelfInsert(void),
X	SetABuf(struct buffer *b),
X	SetBuf(struct buffer *newbuf),
X	SetDot(struct position *bp),
X	SetLMargin(void),
X	SetMark(void),
X	SetRMargin(void),
X	SetTop(struct window *w,struct line *line),
X	SetVar(void),
X	SetWind(struct window *new),
X	ShToBuf(void),
X	ShellCom(void),
X	ShowErr(void),
X	ShowVersion(void),
X	ShrWindow(void),
X	SitFor(unsigned int delay),
X	Source(void),
X	SplitWind(void),
X	StrLength(void),
X	SyncTmp(void),
X	TOstart(char *name,int auto_newline),
X	TOstop(void),
X	Tab(void),
X	TimesFour(void),
X	ToError(int forward),
X	ToFirst(void),
X	ToIndent(void),
X	ToLast(void),
X	ToMark(struct mark *m),
X	TogMinor(int bit),
X	TransChar(void),
X	TransLines(void),
X	Typeout(char *, ...),
X	UNIX_cmdline(int argc,char * *argv),
X	UnbindC(void),
X	Ungetc(int c),
X	UnsetTerm(char *),
X	UpScroll(void),
X	UppWord(void),
X	WNumLines(void),
X	WVisSpace(void),
X	WindFind(void),
X	WindSize(struct window *w,int inc),
X	WriteFile(void),
X	WriteMacs(void),
X	WrtReg(void),
X	WtModBuf(void),
X	XParse(void),
X	Yank(void),
X	YankPop(void),
X	add_mess(char *, ...),
X	add_stroke(int c),
X	add_word(char *wname,struct table *table),
X	b_char(int n),
X	b_word(int num),
X	bufname(struct buffer *b),
X	case_reg(struct line *line1,int char1,struct line *line2,int char2,int up),
X	case_word(int up),
X	cl_eol(void),
X	cl_scr(int doit),
X	close_file(struct File *fp),
X	clr_arg_value(void),
X	clrline(char *cp1,char *cp2),
X	complain(char *, ...),
X	confirm(char *, ...),
X	d_cache_init(void),
X	del_char(int dir,int num),
X	del_wind(struct window *wp),
X	dispatch(int c),
X	do_macro(struct macro *mac),
X	do_rfill(int ulm),
X	do_set_mark(struct line *l,int c),
X	do_sgtty(void),
X	do_space(void),
X	dobell(int x),
X	dofread(struct File *fp),
X	dword(int forward),
X	error(char *, ...),
X	f_char(int n),
X	f_close(struct File *fp),
X	f_mess(char *, ...),
X	f_readn(struct File *fp,char *addr,int n),
X	f_seek(struct File *fp,long offset),
X	f_toNL(struct File *fp),
X	f_word(int num),
X	file_backup(char *fname),
X	file_write(char *fname,int app),
X	filemunge(char *newname),
X	find_para(int how),
X	find_tag(char *tag,int localp),
X	finish(int code),
X	flush(struct File *fp),
X	flusho(void),
X	format(char *buf,int len,char *fmt,char *ap),
X#ifndef STDIO
X	fprintf(struct File *,char *, ...),
X#endif
X	fputnchar(char *s,int n,struct File *fp),
X	free_mthread(struct m_thread *t),
X	freedir(char * * *nmptr,int nentries),
X	freeline(struct line *line),
X	gc_openfiles(void),
X	getTERM(void),
X	getline(disk_line addr,char *buf),
X	i_set(int nline,int ncol),
X	init_43(void),
X	init_strokes(void),
X	init_term(void),
X	initlist(struct buffer *b),
X	ins_c(char c,char *buf,int atchar,int num,int max),
X	ins_str(char *str,int ok_nl),
X	insert_c(int c,int n),
X	isprocbuf(char *bufname),
X	len_error(int flag),
X	lfreelist(struct line *first),
X	lfreereg(struct line *line1,struct line *line2),
X	line_move(int dir,int n,int line_cmd),
X	linecopy(char *onto,int atchar,char *from),
X	lremove(struct line *line1,struct line *line2),
X	lsave(void),
X	mac_init(void),
X	mac_putc(int c),
X#ifndef MAC
X	main(int argc,char * *argv),
X#endif
X	make_argv(char * *argv,char *ap),
X	make_scr(void),
X	message(char *str),
X	minib_add(char *str,int movedown),
X	modify(void),
X	mp_error(void),
X	n_indent(int goal),
X	negate_arg_value(void),
X	null_ncpy(char *to,char *from,int n),
X	open_lines(int n),
X	patchup(struct line *line1,int char1,struct line *line2,int char2),
X	pop_env(jmp_buf),
X	pop_wind(char *name,int clobber,int btype),
X	prCTIME(void),
X	pr_putc(int c,struct File *fp),
X#ifndef STDIO
X	printf(char *, ...),
X#endif
X	push_env(jmp_buf),
X	put_bufs(int askp),
X	putmatch(int which,char *buf,int size),
X	putpad(char *str,int lines),
X	putreg(struct File *fp,struct line *line1,int char1,struct line *line2,int char2,int makesure),
X	putstr(char *s),
X	rbell(void),
X	re_dosub(char *tobuf,int delp),
X	read_file(char *file,int is_insert),
X	redisplay(void),
X	reg_kill(struct line *line2,int char2,int dot_moved),
X	reset_43(void),
X	s_mess(char *, ...),
X	set_arg_value(int n),
X	set_ino(struct buffer *b),
X	set_is_an_arg(int there_is),
X	set_mark(void),
X	set_wsize(int wsize),
X	setbname(struct buffer *b,char *name),
X	setcolor(unsigned char fg,unsigned char bg),
X	setfname(struct buffer *b,char *name),
X	setsearch(char *str),
X	settout(char *ttbuf),
X	slowpoke(void),
X#ifndef STDIO
X	sprintf(char *,char *, ...),
X#endif
X	tiewind(struct window *w,struct buffer *bp),
X	tmpclose(void),
X	tmpinit(void),
X	to_word(int dir),
X	ttinit(void),
X	ttsize(void),
X	tty_reset(void),
X	ttyset(int n),
X	unmodify(void),
X	unwind_macro_stack(void),
X	updmode(void),
X	v_clear(int line1,int line2),
X	v_del_line(int num,int top,int bottom),
X	v_ins_line(int num,int top,int bottom),
X	winit(void),
X	write_em(char *s),
X	write_emc(char *s,int n),
X	write_emif(),
X	write_emif(char *s);
X
X#ifdef MAC
X
extern int
X	creat(char *,int),
X	open(char *,int),
X	close(int),
X	read(int,char *,unsigned),
X	write(int,char *,unsigned),
X	free(char *);
X	unlink(char *),
X	chdir(char *),
X	rawchkc(void),
X	getArgs(char ***);
X	
X	
extern long 
X	lseek(int,long,unsigned);
X
extern char 
X	*pwd(void),
X	*index(char *,char),
X	*mktemp(char *),
X	*rindex(char *,char),
X	*getwd(void),
X	*pfile(char *),
X	*gfile(char *);
X	
extern void
X	MacInit(void),
X	InitBinds(void),
X	NPlacur(int,int),
X	i_lines(int,int,int),
X	d_lines(int,int,int),
X	clr_page(void),
X	clr_eoln(void),
X	docontrols(void),
X	RemoveScrollBar(Window *),
X	InitEvents(void),
X	menus_on(void),
X	menus_off(void);
X
X#endif /* MAC */
X
X#else
X
extern time_t
X	time();
X
extern long	
X	lseek();
X
extern int
X	abs(),
X	read(),
X	write();
X
extern void
X	exit(),
X	_exit(),
X	free();
X
extern char
X	*getenv(),
X	*pwd(),
X	*index(),
X	*malloc(),
X	*mktemp(),
X	*realloc(),
X	*rindex(),
X#ifdef IPROCS
X	*pstate(),
X#endif
X	*tgoto();
X
extern  char 
X	**scanvec(),
X	*IOerr(),
X	*MakeName(),
X	*StrIndex(),
X	*ask(),
X	*ask_buf(),
X	*ask_file(),
X	*basename(),
X	*copystr(),
X	*do_ask(),
X	*emalloc(),
X	*filename(),
X	*get_time(),
X	*getsearch(),
X	*itoa(),
X	*lbptr(),
X	*lcontents(),
X	*ltobuf(),
X	*pr_name(),
X	*ralloc(),
X	*sprint(),
X	switchar();
X
extern  int 
X	BufSwrite(),
X	FLine(),
X	LineDist(),
X	LookingAt(),
X	ModBufs(),
X	ModMacs(),
X	Peekc(),
X	TwoBlank(),
X	UnixToBuf(),
X	addgetc(),
X	alphacomp(),
X	arg_type(),
X	arg_value(),
X	ask_int(),
X	aux_complete(),
X	blnkp(),
X	calc_pos(),
X	casecmp(),
X	casencmp(),
X	charp(),
X	chr_to_int(),
X	complete(),
X	do_if(),
X	dosputc(),
X	f_getint(),
X	f_gets(),
X	f_match(),
X	filbuf(),
X	find_pos(),
X	fixorder(),
X	_flush(),
X	getch(),
X	getchar(),
X	getrawinchar(),
X	how_far(),
X	i_blank(),
X	i_bsblank(),
X	in_window(),
X	inlist(),
X	in_macro(),
X	inorder(),
X	is_an_arg(),
X	ismword(),
X	joverc(),
X	length(),
X	look_at(),
X#ifdef IBMPC
X	lower(),
X#endif	
X	mac_getc(),
X	match(),
X	max(),
X	min(),
X	numcomp(),
X	pnt_line(),
X	rawkey_ready(),
X	re_lindex(),
X	scandir(),
X	sindex(),
X	swrite(),
X	unbind_aux(),
X	waitchar(),
X	yes_or_no_p();
X
extern  disk_line 
X	f_getputl(),
X	putline();
X
extern  struct File 
X	*f_open(),
X	*fd_open(),
X	*open_file();
X
extern  struct buffer 
X	*buf_exists(),
X	*do_find(),
X	*do_select(),
X	*file_exists(),
X	*getNMbuf();
X
extern  struct cmd 
X	*FindCmd();
X
extern  struct data_obj 
X	**IsPrefix(),
X	*findcom(),
X	*findmac(),
X	*findvar();
X
extern  struct line 
X	*lastline(),
X	*listput(),
X	*max_line(),
X	*min_line(),
X	*nbufline(),
X	*next_line(),
X	*prev_line(),
X	*reg_delete();
X
extern  struct m_thread 
X	*alloc_mthread();
X
extern  struct mark 
X	*CurMark(),
X	*MakeMark();
X
extern  struct position 
X	*DoYank(),
X	*c_indent(),
X	*docompiled(),
X	*dosearch(),
X	*lisp_indent(),
X	*m_paren();
X
extern  struct table 
X	*make_table();
X
extern  struct window 
X	*div_wind(),
X	*w_nam_typ(),
X	*windbp();
X
extern  struct word 
X	*word_in_table();
X
extern  unsigned char 
X	chpl(),
X	lpp();
X
extern  void 
X	AbbrevExpand(),
X	AddSpecial(),
X	AllMarkSet(),
X	AppReg(),
X	Apropos(),
X	BList(),
X	BSexpr(),
X	BUpList(),
X	BackChar(),
X	BackPara(),
X	BackWord(),
X	BindAKey(),
X	BindMac(),
X	BindMtoW(),
X	BindSomething(),
X	BindWMap(),
X	Bof(),
X	Bol(),
X	Bos(),
X	Bow(),
X	Buf10Select(),
X	Buf1Select(),
X	Buf2Select(),
X	Buf3Select(),
X	Buf4Select(),
X	Buf5Select(),
X	Buf6Select(),
X	Buf7Select(),
X	Buf8Select(),
X	Buf9Select(),
X	BufErase(),
X	BufKill(),
X	BufList(),
X	BufPos(),
X	BufSelect(),
X	CAutoExec(),
X	CalcWind(),
X	CapChar(),
X	CapWord(),
X	CasRegLower(),
X	CasRegUpper(),
X	CaseReg(),
X	CentWind(),
X	ChkWindows(),
X	ChrToOct(),
X	ClAndRedraw(),
X	Comment(),
X	CopyRegion(),
X	CtlxPrefix(),
X	DFixMarks(),
X	DOTsave(),
X	DefAutoExec(),
X	DefGAbbrev(),
X	DefKBDMac(),
X	DefMAbbrev(),
X	DelBlnkLines(),
X	DelCurWindow(),
X	DelMacro(),
X	DelMark(),
X	DelNChar(),
X	DelNWord(),
X	DelPChar(),
X	DelPWord(),
X	DelReg(),
X	DelWtSpace(),
X	DescBindings(),
X	DescCom(),
X	DescMap(),
X	DescWMap(),
X	Digit(),
X	Digit0(),
X	Digit1(),
X	Digit2(),
X	Digit3(),
X	Digit4(),
X	Digit5(),
X	Digit6(),
X	Digit7(),
X	Digit8(),
X	Digit9(),
X	DoAutoExec(),
X	DoJustify(),
X	DoKeys(),
X	DoNewline(),
X	DoPara(),
X	DoParen(),
X	DoWriteReg(),
X	DotTo(),
X	DownScroll(),
X	DrawMesg(),
X	EditAbbrevs(),
X	Eof(),
X	Eol(),
X	Eos(),
X	Eow(),
X	ErrFree(),
X	ErrParse(),
X	EscPrefix(),
X	ExecCmd(),
X	ExecMacro(),
X	Extend(),
X	FDotTag(),
X	FDownList(),
X	FList(),
X	FSexpr(),
X	FSrchND(),
X	FillComment(),
X	FilterRegion(),
X	FindFile(),
X	FindTag(),
X	ForChar(),
X	ForPara(),
X	ForSearch(),
X	ForWord(),
X	Forget(),
X	GCchunks(),
X	GSexpr(),
X	GoLine(),
X	GotoWind(),
X	GrowWindow(),
X	HandlePref(),
X	IFixMarks(),
X	IncFSearch(),
X	IncRSearch(),
X	InitCM(),
X	InsFile(),
X	Insert(),
X	Justify(),
X	KeyDesc(),
X	KillBos(),
X	KillEOL(),
X	KillEos(),
X	KillExpr(),
X	KillSome(),
X	Leave(),
X	LineAI(),
X	LineInsert(),
X	LowWord(),
X	MAutoExec(),
X	MacInter(),
X	MakeErrors(),
X	MarkSet(),
X	MiscPrefix(),
X	NameMac(),
X	Newline(),
X	NextError(),
X	NextLine(),
X	NextPage(),
X	NextWindow(),
X	NotModified(),
X	OneWindow(),
X	OpenLine(),
X	PageNWind(),
X	PageScrollDown(),
X	PageScrollUp(),
X	ParseAll(),
X	PathParse(),
X	Placur(),
X	PopMark(),
X	PrVar(),
X	PrevError(),
X	PrevLine(),
X	PrevPage(),
X	PrevWindow(),
X	PtToMark(),
X	Push(),
X	PushPntp(),
X	QRepSearch(),
X	QuotChar(),
X	REcompile(),
X	RErecur(),
X	RSrchND(),
X	ReNamBuf(),
X	ReadFile(),
X	Recur(),
X	RedrawDisplay(),
X	RegJustify(),
X	RegReplace(),
X	RegToUnix(),
X	Remember(),
X	RepSearch(),
X	ResetTerm(),
X	RestAbbrevs(),
X	RevSearch(),
X	RunMacro(),
X	SO_off(),
X	SO_on(),
X	SaveAbbrevs(),
X	SaveFile(),
X	SelfInsert(),
X	SetABuf(),
X	SetBuf(),
X	SetDot(),
X	SetLMargin(),
X	SetMark(),
X	SetRMargin(),
X	SetTop(),
X	SetVar(),
X	SetWind(),
X	ShToBuf(),
X	ShellCom(),
X	ShowErr(),
X	ShowVersion(),
X	ShrWindow(),
X	SitFor(),
X	Source(),
X	SplitWind(),
X	StrLength(),
X	SyncTmp(),
X	TOstart(),
X	TOstop(),
X	Tab(),
X	TimesFour(),
X	ToError(),
X	ToFirst(),
X	ToIndent(),
X	ToLast(),
X	ToMark(),
X	TogMinor(),
X	TransChar(),
X	TransLines(),
X	Typeout(),
X	UNIX_cmdline(),
X	UnbindC(),
X	Ungetc(),
X	UnsetTerm(),
X	UpScroll(),
X	UppWord(),
X	WNumLines(),
X	WVisSpace(),
X	WindFind(),
X	WindSize(),
X	WriteFile(),
X	WriteMacs(),
X	WrtReg(),
X	WtModBuf(),
X	XParse(),
X	Yank(),
X	YankPop(),
X	add_mess(),
X	add_stroke(),
X	add_word(),
X	b_char(),
X	b_word(),
X	bufname(),
X	case_reg(),
X	case_word(),
X	cl_eol(),
X	cl_scr(),
X	close_file(),
X	clr_arg_value(),
X	clrline(),
X	complain(),
X	confirm(),
X	d_cache_init(),
X	del_char(),
X	del_wind(),
X	dispatch(),
X	do_macro(),
X	do_rfill(),
X	do_set_mark(),
X	do_sgtty(),
X	do_space(),
X	dobell(),
X	dofread(),
X	dword(),
X	error(),
X	f_char(),
X	f_close(),
X	f_mess(),
X	f_readn(),
X	f_seek(),
X	f_toNL(),
X	f_word(),
X	file_backup(),
X	file_write(),
X	filemunge(),
X	find_para(),
X	find_tag(),
X	finish(),
X	flush(),
X	flusho(),
X	format(),
X#ifndef STDIO
X	fprintf(),
X#endif	
X	fputnchar(),
X	free_mthread(),
X	freedir(),
X	freeline(),
X	gc_openfiles(),
X	getTERM(),
X	getline(),
X	i_set(),
X	init_43(),
X	init_strokes(),
X	init_term(),
X	initlist(),
X	ins_c(),
X	ins_str(),
X	insert_c(),
X	isprocbuf(),
X	len_error(),
X	lfreelist(),
X	lfreereg(),
X	line_move(),
X	linecopy(),
X	lremove(),
X	lsave(),
X	mac_init(),
X	mac_putc(),
X	main(),
X	make_argv(),
X	make_scr(),
X	message(),
X	minib_add(),
X	modify(),
X	mp_error(),
X	n_indent(),
X	negate_arg_value(),
X	null_ncpy(),
X	open_lines(),
X	patchup(),
X	pop_env(),
X	pop_wind(),
X	prCTIME(),
X	pr_putc(),
X#ifndef STDIO
X	printf(),
X#endif	
X	push_env(),
X	put_bufs(),
X	putmatch(),
X	putpad(),
X	putreg(),
X	putstr(),
X	rbell(),
X	re_dosub(),
X	read_file(),
X	redisplay(),
X	reg_kill(),
X	reset_43(),
X	s_mess(),
X	set_arg_value(),
X	set_ino(),
X	set_is_an_arg(),
X	set_mark(),
X	set_wsize(),
X	setbname(),
X	setcolor(),
X	setfname(),
X	setsearch(),
X	settout(),
X	slowpoke(),
X#ifndef STDIO
X	sprintf(),
X#endif	
X	tiewind(),
X	tmpclose(),
X	tmpinit(),
X	to_word(),
X	ttinit(),
X	ttsize(),
X	tty_reset(),
X	ttyset(),
X	unmodify(),
X	unwind_macro_stack(),
X	updmode(),
X	v_clear(),
X	v_del_line(),
X	v_ins_line(),
X	winit(),
X	write_em(),
X	write_emc(),
X	write_emif(),
X	write_emif();
X#endif
END_OF_FILE
if test 21599 -ne `wc -c <'./externs.h'`; then
    echo shar: \"'./externs.h'\" unpacked with wrong size!
fi
# end of './externs.h'
fi
if test -f './jove.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./jove.c'\"
else
echo shar: Extracting \"'./jove.c'\" \(25416 characters\)
sed "s/^X//" >'./jove.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X/* Contains the main loop initializations, and some system dependent
X   type things, e.g. putting terminal in CBREAK mode, etc. */
X
X#include "jove.h"
X#include "io.h"
X#include "termcap.h"
X
X#ifdef MAC
X#	include "mac.h"
X#else
X#	include <varargs.h>
X#	include <sys/stat.h>
X#endif
X
X#include <signal.h>
X#include <errno.h>
X
X#ifdef UNIX
X#	ifndef SYSV
X#		include <sgtty.h>
X#	else
X#		include <termio.h>
X#	endif /* SYSV */
X#endif /* UNIX */
X
X#ifdef MSDOS
X#	include <process.h>
X#endif /* MSDOS */
X
X#ifndef MAC
X#	include <fcntl.h>
X#endif
X
X#ifdef MAC
X#	undef private
X#	define private
X#endif
X
X#ifdef	LINT_ARGS
extern	long	time(long *);
private	void	break_off(void);
private	void	break_rst(void);
X#else
extern	long	time();
private	void	break_off();
private	void	break_rst();
X#endif
X
X#ifdef MAC
X#	undef private
X#	define private static
X#endif
X
X#ifdef UNIX
X#ifdef TIOCSLTC
struct ltchars	ls1,
X		ls2;
X#endif /* TIOCSLTC */
X
X#ifdef TIOCGETC
struct tchars	tc1,
X		tc2;
X#endif
X
X#ifdef PASS8			/* use pass8 instead of raw for meta-key */
int	lm_word1,		/* local mode word */
X	lm_word2;
X#endif
X
X#ifdef BRLUNIX
struct sg_brl	sg1, sg2;
X#else
X#ifdef SYSV
struct termio	sg1, sg2;
X#else /* SYSV */
struct sgttyb	sg1, sg2;
X#endif /* SYSV */
X#endif /* BRLUNIX */
X
X#ifdef BIFF
private struct stat	tt_stat;	/* for biff */
X#ifndef BSD4_2
private char	*tt_name = 0;		/* name of the control tty */
extern char	*ttyname();		/* for systems w/o fchmod ... */
X#endif
private int	dw_biff = NO;		/* whether or not to fotz at all */
X#endif
X#endif /* UNIX */
X
int	errormsg;
extern char	*tfname;
char	NullStr[] = "";
X
X#ifdef MSDOS
X#define SIGHUP	99
X#endif /* MSDOS */
X
void
finish(code)
X{
X	int	CoreDump = (code != 0 && code != SIGHUP),
X		DelTmps = 1;		/* Usually we delete them. */
X
X	if (code == SIGINT) {
X		char	c;
X
X#ifndef MENLO_JCL
X		(void) signal(code, finish);
X#endif
X		f_mess("Abort (Type 'n' if you're not sure)? ");
X#ifndef MSDOS
X		(void) read(0, &c, 1);
X#else /* MSDOS */
X		c = getrawinchar();
X#endif /* MSDOS */
X		message(NullStr);
X		if ((c & 0377) != 'y') {
X			redisplay();
X			return;
X		}
X	}
X	ttyset(OFF);
X	UnsetTerm(NullStr);
X#ifndef MSDOS
X	if (code != 0) {
X		if (!Crashing) {
X			Crashing = YES;
X			lsave();
X			SyncRec();
X			printf("JOVE CRASH!! (code %d)\n", code);
X			if (ModBufs(1)) {
X				printf("Your buffers have been saved.\n");
X				printf("Use \"jove -r\" to have a look at them.\n");
X				DelTmps = 0;	/* Don't delete anymore. */
X			} else
X				printf("You didn't lose any work.\n");
X		} else
X			printf("\r\nYou may have lost your work!\n");
X	}
X#endif /* MSDOS */
X	flusho();
X	if (DelTmps) {
X		tmpclose();
X#ifndef MSDOS
X		recclose();
X#endif /* MSDOS */
X	}
X#ifdef UNIX
X	if (CoreDump)
X		abort();
X#ifdef PROFILING
X	exit(0);
X#else
X	_exit(0);
X#endif
X#else /* MSDOS or MAC*/
X#ifdef MSDOS
X	break_rst();	/* restore previous ctrl-c handling */
X#endif
X	exit(0);
X#endif /* UNIX */
X}
X
private char	smbuf[20],
X		*bp = smbuf;
private int	nchars = 0;
X
private char	peekbuf[10],
X		*peekp = peekbuf;
X
X#if defined(SYSV) || defined(M_XENIX)
void
setblock(fd, on)	/* turn blocking on or off */
register int	fd, on;
X{
X    static int blockf, nonblockf;
X    static int first = 1;
X    int flags;
X
X    if (first) {
X	first = 0;
X	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
X	    finish(SIGHUP);
X	blockf = flags & ~O_NDELAY;	/* make sure O_NDELAY is off */
X	nonblockf = flags | O_NDELAY;	/* make sure O_NDELAY is on */
X    }
X    if (fcntl(fd, F_SETFL, on ? blockf : nonblockf) == -1)
X	finish(SIGHUP);
X}
X#endif /* SYSV */
X
int
Peekc()
X{
X	int	c;
X
X	if (peekp == peekbuf)
X		c = -1;
X	else
X		c = *--peekp & 0377;
X	return c;
X}
X
void
Ungetc(c)
X{
X	if (peekp == &peekbuf[(sizeof peekbuf) - 1])
X		return;		/* Sorry, can't oblige you ... */
X	*peekp++ = c;
X}
X
char	*Inputp = 0;
X
X#ifdef IPROCS
X#ifdef PIPEPROCS
getchar()
X{
X	extern int	errno;
X	register int	c;
X
X	if (nchars <= 0) {
X		do
X			nchars = read(0, smbuf, sizeof smbuf);
X#ifdef SYSV
X		while (nchars == 0 || (nchars < 0 && errno == EINTR));
X		if (nchars < 0)
X#else
X		while (nchars < 0 && errno == EINTR);
X		if (nchars <= 0)
X#endif /* SYSV */
X			finish(SIGHUP);
X		bp = smbuf;
X		InputPending = nchars > 1;
X	}
X	if (((c = *bp) & 0200) && MetaKey != 0) {
X		*bp = (c & CHARMASK);
X		return '\033';
X	}
X	nchars -= 1;
X	return (*bp++ & CHARMASK);
X}
X#else /* PIPEPROCS */
getchar()
X{
X	extern long	global_fd;
X	long		reads;
X	extern int	NumProcs,
X			errno;
X	register int	tmp,
X			nfds;
X	int		c;
X
X	if (nchars <= 0) {
X		/* Get a character from the keyboard, first checking for
X		   any input from a process.  Handle that first, and then
X		   deal with the terminal input. */
X		if (NumProcs > 0) {
X			do {
X				do {
X					reads = global_fd;
X					nfds = select(32, &reads, (long *)0, (long *)0, (struct timeval *)0);
X				} while (nfds < 0 && errno == EINTR);
X
X				switch (nfds) {
X				case -1:
X					printf("\rerror %d in select %ld", errno, global_fd);
X					global_fd = 1;
X					break;
X				default:
X					if (reads & 01) {
X						nchars = read(0, smbuf, sizeof(smbuf));
X						reads &= ~01;
X						nfds -= 1;
X					}
X
X					while (nfds--) {
X						tmp = ffs(reads) - 1;
X						read_proc(tmp);
X						reads &= ~(1L << tmp);
X					}
X
X					break;
X				}
X			} while (nchars <= 0);
X		} else {
X			do
X				nchars = read(0, smbuf, sizeof(smbuf));
X			while (nchars < 0 && errno == EINTR);
X		}
X
X		if (nchars <= 0)
X			finish(SIGHUP);
X
X		bp = smbuf;
X		InputPending = (nchars > 1);
X	}
X
X	if (((c = *bp) & 0200) && MetaKey != 0) {
X		*bp = (c & CHARMASK);
X		return '\033';
X	}
X	nchars -= 1;
X	return *bp++ & 0377;
X}
X#endif /* PIPEPROCS */
X#else /* IPROCS */
int
getchar()
X{
X	extern int	errno;
X	register int	c;
X
X	if (nchars <= 0) {
X		do {
X#ifdef MSDOS
X			*smbuf = getrawinchar();
X			nchars = 1;
X#else
X			nchars = read(0, smbuf, sizeof smbuf);
X#endif
X		} while (nchars < 0
X#ifndef MSDOS
X			&& errno == EINTR
X#endif
X			);
X
X		if (nchars <= 0)
X			finish(SIGHUP);
X		bp = smbuf;
X		InputPending = nchars > 1;
X	}
X	if (((c = *bp) & 0200) && MetaKey != 0) {
X		*bp = (c & CHARMASK);
X		return '\033';
X	}
X	nchars -= 1;
X	return *bp++ & 0377;
X}
X
X#endif /* IPROCS */
X
int	InputPending = 0;
X
X/* Returns non-zero if a character waiting */
X
int
charp()
X{
X#ifndef MSDOS
X	int	some = 0;
X#endif /* MSDOS */
X
X	if (InJoverc != 0 || nchars > 0 || Inputp != 0)
X		return 1;
X#ifdef BRLUNIX
X	{
X		static struct sg_brl gttyBuf;
X
X		gtty(0, (char *) &gttyBuf);
X		if (gttyBuf.sg_xflags & INWAIT)
X			some += 1;
X	}
X#endif
X#ifdef FIONREAD
X	{
X		long c;
X
X		if (ioctl(0, FIONREAD, (struct sgttyb *) &c) == -1)
X			c = 0;
X		some = (c > 0);
X	}
X#endif /* FIONREAD */
X#if defined(SYSV) || defined(M_XENIX)
X	setblock(0, 0);		/* turn blocking off */
X	nchars = read(0, smbuf, sizeof smbuf);	/* Is anything there? */
X	setblock(0, 1);		/* turn blocking on */
X	if (nchars > 0)		/* something was there */
X	    bp = smbuf;		/* make sure bp points to it */
X	some = (nchars > 0);	/* just say we found something */
X#endif /* SYSV */
X#ifdef c70
X	some = !empty(0);
X#endif
X#ifdef MSDOS
X    return rawkey_ready();
X#else
X#ifdef MAC
X	some = rawchkc();
X#endif
X	return some;
X#endif /* MSDOS */
X}
X
X#ifdef TERMCAP
void
ResetTerm()
X{
X	putpad(TI, 1);
X	putpad(VS, 1);
X	putpad(KS, 1);
X#ifndef MSDOS
X	(void) chkmail(YES);	/* force it to check to we can be accurate */
X#endif
X#ifdef BIFF
X	if (BiffChk != dw_biff)
X		biff_init();
X	/* just in case we changed our minds about whether to deal with
X	   biff */
X#endif
X	do_sgtty();		/* this is so if you change baudrate or stuff
X				   like that, JOVE will notice. */
X	ttyset(ON);
X}
X
void
UnsetTerm(mesg)
char	*mesg;
X{
X	ttyset(OFF);
X	putpad(KE, 1);
X	putpad(VE, 1);
X	putpad(TE, 1);
X#ifdef ID_CHAR
X	INSmode(0);
X#endif
X	Placur(ILI, 0);
X	printf("%s", mesg);
X	putpad(CE, 1);
X	flusho();
X}
X#endif /* TERMCAP */
X
X#ifdef JOB_CONTROL
PauseJove()
X{
X	UnsetTerm(ModBufs(0) ? "[There are modified buffers]" : NullStr);
X	(void) kill(0, SIGTSTP);
X	ResetTerm();
X	ClAndRedraw();
X}
X#endif
X
X
X#ifndef MAC
void
Push()
X{
X	int
X#ifndef MSDOS
X		pid,
X		(*old_quit)() = signal(SIGQUIT, SIG_IGN),
X#endif /* MSDOS */
X   		(*old_int)() = signal(SIGINT, SIG_IGN);
X
X#ifndef MSDOS
X#ifdef IPROCS
X	sighold(SIGCHLD);
X#endif
X	switch (pid = fork()) {
X	case -1:
X		complain("[Fork failed]");
X
X	case 0:
X		UnsetTerm(NullStr);
X#ifdef IPROCS
X		sigrelse(SIGCHLD);
X#endif
X		(void) signal(SIGTERM, SIG_DFL);
X#else /* MSDOS */
X	UnsetTerm(NullStr);
X#endif /* MSDOS */
X		(void) signal(SIGINT, SIG_DFL);
X#ifdef UNIX
X		(void) signal(SIGQUIT, SIG_DFL);
X		execl(Shell, basename(Shell), (char *)0);
X		message("[Execl failed]");
X		_exit(1);
X	}
X    	dowait(pid, (int *) 0);
X#ifdef IPROCS
X	sigrelse(SIGCHLD);
X#endif
X#endif /* UNIX */
X#ifdef MSDOS
X	break_rst();
X	if (spawnl(0, Shell, basename(Shell), (char *)0) == -1)
X		message("[Spawn failed]"); 
X#endif /* MSDOS */
X    	ResetTerm();
X    	ClAndRedraw();
X#ifndef MSDOS
X	(void) signal(SIGQUIT, old_quit);
X#else /* MSDOS */
X	break_off();
X#ifdef CHDIR
X	getCWD();
X#endif	
X#endif /* MSDOS */
X    	(void) signal(SIGINT, old_int);
X}
X#endif /* MAC */
X
int	OKXonXoff = 0,		/* ^S and ^Q initially DON'T work */
X	IntChar = CTL(']');
X
void
ttsize()
X{
X#ifdef UNIX
X#ifdef TIOCGWINSZ
X	struct winsize win;
X
X	if (ioctl (0, TIOCGWINSZ, &win) == 0) {
X		if (win.ws_col)
X			CO = win.ws_col;
X		if (win.ws_row)
X			LI = win.ws_row;
X	}
X#else /* TIOCGWINSZ */
X#ifdef BTL_BLIT
X#include <sys/jioctl.h>
X	struct jwinsize jwin;
X
X	if (ioctl(0, JWINSIZE, &jwin) == 0) {
X		if (jwin.bytesx)
X			CO = jwin.bytesx;
X		if (jwin.bytesy)
X			LI = jwin.bytesy;
X	}
X#endif /* BTL_BLIT */
X#endif /* TIOCGWINSZ */
X#endif /* UNIX */
X	ILI = LI - 1;
X}
X
X#ifdef BIFF
biff_init()
X{
X	dw_biff = ((BiffChk) &&
X#ifndef BSD4_2
X		   ((tt_name != 0) || (tt_name = ttyname(0))) &&
X		   (stat(tt_name, &tt_stat) != -1) &&
X#else
X		   (fstat(0, &tt_stat) != -1) &&
X#endif
X		   (tt_stat.st_mode & S_IEXEC));	/* he's using biff */
X
X}
X
biff(on)
X{
X	if (dw_biff == NO)
X		return;
X#ifndef BSD4_2
X	(void) chmod(tt_name, on ? tt_stat.st_mode :
X				   (tt_stat.st_mode & ~S_IEXEC));
X#else
X	(void) fchmod(0, on ? tt_stat.st_mode :
X			      (tt_stat.st_mode & ~S_IEXEC));
X#endif
X}
X
X#endif
X
void
ttinit()
X{
X#ifdef BIFF
X	biff_init();
X#endif
X#ifdef TIOCSLTC
X	(void) ioctl(0, TIOCGLTC, (struct sgttyb *) &ls1);
X	ls2 = ls1;
X	ls2.t_suspc = (char) -1;
X	ls2.t_dsuspc = (char) -1;
X	ls2.t_flushc = (char) -1;
X	ls2.t_lnextc = (char) -1;
X#endif
X
X#ifdef TIOCGETC
X	/* Change interupt and quit. */
X	(void) ioctl(0, TIOCGETC, (struct sgttyb *) &tc1);
X	tc2 = tc1;
X	tc2.t_intrc = IntChar;
X	tc2.t_quitc = (char) -1;
X	if (OKXonXoff) {
X		tc2.t_stopc = (char) -1;
X		tc2.t_startc = (char) -1;
X	}
X#endif /* TIOCGETC */
X	do_sgtty();
X}
X
private int	done_ttinit = 0;
X
void
do_sgtty()
X{
X#ifdef UNIX
X#ifdef SYSV
X	(void) ioctl(0, TCGETA, (char *) &sg1);
X#else
X	(void) gtty(0, &sg1);
X#endif /* SYSV */
X	sg2 = sg1;
X
X#ifdef LPASS8
X	(void) ioctl(0, TIOCLGET, &lm_word1);
X	lm_word2 = lm_word1;
X	if (MetaKey == YES)
X		lm_word2 |= LPASS8;
X#endif
X
X#ifdef SYSV
X	TABS = !((sg1.c_oflag & TAB3) == TAB3);
X	ospeed = sg1.c_cflag & CBAUD;
X
X	if (OKXonXoff)
X		sg2.c_iflag &= ~(IXON | IXOFF);
X	sg2.c_iflag &= ~(INLCR|ICRNL|IGNCR);
X	sg2.c_lflag &= ~(ISIG|ICANON|ECHO);
X	sg2.c_oflag &= ~(OCRNL|ONLCR);
X	sg2.c_cc[VMIN] = sizeof smbuf;
X	sg2.c_cc[VTIME] = 1;
X#else
X	TABS = !(sg1.sg_flags & XTABS);
X	ospeed = sg1.sg_ospeed;
X#ifdef BRLUNIX
X	sg2.sg_flags &= ~(ECHO | CRMOD);
X	sg2.sg_flags |= CBREAK;
X
X	/* VT100 Kludge: leave STALL on for flow control if DC3DC1 (Yuck.) */
X	sg2.sg_xflags &= ~((sg2.sg_xflags&DC3DC1 ? 0 : STALL) | PAGE);
X#else
X	sg2.sg_flags &= ~(ECHO | CRMOD);
X#endif /* BRLUNIX */
X
X#ifdef EUNICE
X	sg2.sg_flags |= RAW;	/* Eunice needs RAW mode last I heard. */
X#else
X#ifdef PURDUE_EE
X#   ifdef pdp11
X	sg2.sg_flags |= RAW;
X#   else
X	sg2.sg_flags |= (MetaKey ? RAW : CBREAK);
X#   endif
X#else
X#   ifdef LPASS8
X	sg2.sg_flags |= CBREAK;
X#   else
X	sg2.sg_flags |= (MetaKey ? RAW : CBREAK);
X#   endif
X#endif /* PURDUE_EE */
X#endif /* EUNICE */
X#endif /* SYSV */
X#endif /* UNIX */
X
X#ifdef MSDOS
X#	ifndef IBMPC
X	setmode(1, 0x8000);
X#	endif /* IBMPC */
X	TABS = 0;
X#endif /* MSDOS */
X}
X
void
tty_reset()
X{
X	if (!done_ttinit)
X		return;
X	ttyset(OFF);	/* go back to original modes */
X	ttinit();
X	ttyset(ON);
X}
X
X/* If n is OFF reset to original modes */
X
void
ttyset(n)
X{
X	if (!done_ttinit && n == 0)	/* Try to reset before we've set! */
X		return;
X#ifdef UNIX
X#   ifdef SYSV
X	(void) ioctl(0, TCSETAW, n == 0 ? (struct sgttyb *) &sg1 : (struct sgttyb *) &sg2);
X#   else
X#     ifdef BRLUNIX
X	(void) stty(0, n == 0 ? (struct sgttyb *) &sg1 : (struct sgttyb *) &sg2);
X#     else
X	(void) ioctl(0, TIOCSETN, n == 0 ? (struct sgttyb *) &sg1 : (struct sgttyb *) &sg2);
X#     endif /* BRLUNIX */
X#   endif /* SYSV */
X
X#   ifdef TIOCSETC
X	(void) ioctl(0, TIOCSETC, n == 0 ? (struct sgttyb *) &tc1 : (struct sgttyb *) &tc2);
X#   endif /* TIOCSETC */
X#   ifdef TIOCSLTC
X	(void) ioctl(0, TIOCSLTC, n == 0 ? (struct sgttyb *) &ls1 : (struct sgttyb *) &ls2);
X#   endif /* TIOCSLTC */
X#   ifdef LPASS8
X	(void) ioctl(0, TIOCLSET, n == 0 ? &lm_word1 : &lm_word2);
X#   endif
X#endif /* UNIX */
X
X#ifdef MSDOS
X#   ifndef IBMPC
X	setmode(1, n == 0 ? 0x4000 : 0x8000);
X#   endif /* IBMPC */
X#endif /* MSDOS */
X	done_ttinit = 1;
X#ifdef BIFF
X	biff(!n);
X#endif
X}
X
int	this_cmd,
X	last_cmd;
X
void
dispatch(c)
register int	c;
X{
X	data_obj	*cp;
X
X	this_cmd = 0;
X	cp = mainmap[c & CHARMASK];
X
X	if (cp == 0) {
X		rbell();
X		clr_arg_value();
X		errormsg = NO;
X		message(NullStr);
X	} else
X		ExecCmd(cp);
X}
X
int	LastKeyStruck,
X	MetaKey = 0;
X
int
getch()
X{
X	register int	c,
X			peekc;
X#ifdef IPROCS
X	extern int	NumProcs;
X#endif
X	extern int	ModCount,
X			Interactive;
X
X	if (Inputp) {
X		if ((c = *Inputp++) != 0)
X			return LastKeyStruck = c;
X		Inputp = 0;
X	}
X
X	if (InJoverc)
X		return EOF;	/* somethings wrong if Inputp runs out while
X				   we're reading a .joverc file. */
X
X#ifndef MSDOS
X	if (ModCount >= SyncFreq) {
X		ModCount = 0;
X		SyncRec();
X	}
X#endif /* MSDOS */
X
X	/* If we're not interactive and we're not executing a macro,
X	   AND there are no ungetc'd characters, we read from the
X	   terminal (i.e., getch()).  And characters only get put
X	   in macros from inside this if. */
X	if (((peekc = c = Peekc()) == -1) && (Interactive || ((c = mac_getc()) == -1))) {
X		/* So messages that aren't error messages don't
X		   hang around forever. */
X		if (!UpdMesg && !Asking) {	/* Don't erase if we are asking */
X			if (mesgbuf[0] && !errormsg)
X				message(NullStr);
X		}
X		redisplay();
X#ifdef IPROCS
X#  ifdef PIPEPROCS
X		if (NumProcs > 0) {
X			sigrelse(INPUT_SIG);
X			sigrelse(SIGCHLD);
X		}
X#  endif
X#endif
X#ifdef UNIX
X		inIOread = 1;
X#endif
X		if ((c = getchar()) == EOF)
X			finish(SIGHUP);
X#ifdef UNIX
X		inIOread = 0;
X#endif
X
X#ifdef IPROCS
X#  ifdef PIPEPROCS
X		if (NumProcs > 0) {
X			sighold(INPUT_SIG);
X			sighold(SIGCHLD);
X		}
X#  endif
X#endif
X		if (!Interactive && InMacDefine)
X			mac_putc(c);
X	}
X	if (peekc == -1)	/* don't add_stroke peekc's */
X		add_stroke(c);
X	return LastKeyStruck = c;
X}
X
X#ifdef UNIX
dorecover()
X{
X	execl(Recover, "recover", "-d", TmpFilePath, (char *) 0);
X	printf("%s: execl failed!\n", Recover);
X	flusho();
X	_exit(-1);
X}
X#endif /* UNIX */
X		
X
void
ShowVersion()
X{
X	extern char	*version;
X
X	s_mess("Jonathan's Own Version of Emacs (%s)", version);
X}
X
void
UNIX_cmdline(argc, argv)
char	*argv[];
X{
X	int	lineno = 0,
X		nwinds = 1;
X	Buffer	*b;
X
X	ShowVersion();
X	while (argc > 1) {
X		if (argv[1][0] != '-' && argv[1][0] != '+') {
X			int	force = (nwinds > 0 || lineno != 0);
X
X#ifdef MSDOS
X			strlwr(argv[1]);
X#endif /* MSDOS */
X			minib_add(argv[1], force ? YES : NO);
X			b = do_find(nwinds > 0 ? curwind : (Window *) 0,
X				    argv[1], force);
X			if (force) {
X				SetABuf(curbuf);
X				SetBuf(b);
X				if (lineno >= 0)
X					SetLine(next_line(curbuf->b_first, lineno));
X				else
X					SetLine(curbuf->b_last);
X				if (nwinds > 1)
X					NextWindow();
X				if (nwinds)
X					nwinds -= 1;
X			}
X			lineno = 0;
X		} else	switch (argv[1][1]) {
X			case 'd':
X				argv += 1;
X				argc -= 1;
X				break;
X
X			case 'j':	/* Ignore .joverc in HOME */
X				break;
X#ifndef MAC
X			case 'p':
X				argv += 1;
X				argc -= 1;
X				if (argv[1] != 0) {
X					SetBuf(do_find(curwind, argv[1], 0));
X					ErrParse();
X					nwinds = 0;
X				}
X				break;
X#endif
X			case 't':
X 				/* check if syntax is -tTag or -t Tag */
X 				if (argv[1][2] != 0) {
X 					find_tag(&(argv[1][2]), YES);
X 				} else {
X					argv += 1;
X					argc -= 1;
X					if (argv[1] != 0)
X						find_tag(argv[1], YES);
X 				}
X  				break;
X  
X			case 'w':
X				if (argv[1][2] == '\0')
X					nwinds += 1;
X				else {
X					int	n;
X
X					(void) chr_to_int(&argv[1][2], 10, NO, &n);
X					nwinds += -1 + n;
X				}
X				(void) div_wind(curwind, nwinds - 1);
X				break;
X
X			case '0':
X			case '1':
X			case '2':
X			case '3':
X			case '4':
X			case '5':
X			case '6':
X			case '7':
X			case '8':
X			case '9':
X				(void) chr_to_int(&argv[1][1], 10, NO, &lineno);
X				lineno -= 1;
X				break;
X			case  0: 
X				lineno = -1;	/* goto end of file ... */
X				break;		/* just like some people's */
X		}				/* favourite editor */
X		argv += 1;
X		argc -= 1;
X	}
X}
X
X/* VARARGS1 */
X
void
error(fmt, va_alist)
char	*fmt;
va_dcl
X{
X	va_list	ap;
X
X	if (fmt) {
X		va_start(ap);
X		format(mesgbuf, sizeof mesgbuf, fmt, ap);
X		va_end(ap);
X		UpdMesg = YES;
X	}
X	rbell();
X	longjmp(mainjmp, ERROR);
X}
X
X/* VARARGS1 */
X
void
complain(fmt, va_alist)
char	*fmt;
va_dcl
X{
X	va_list	ap;
X
X	if (fmt) {
X		va_start(ap);
X		format(mesgbuf, sizeof mesgbuf, fmt, ap);
X		va_end(ap);
X		UpdMesg = YES;
X	}
X	rbell();
X	longjmp(mainjmp, COMPLAIN);
X}
X
X/* VARARGS1 */
X
void
confirm(fmt, va_alist)
char	*fmt;
va_dcl
X{
X	char	*yorn;
X	va_list	ap;
X
X	va_start(ap);
X	format(mesgbuf, sizeof mesgbuf, fmt, ap);
X	va_end(ap);
X	yorn = ask((char *) 0, mesgbuf);
X	if (*yorn != 'Y' && *yorn != 'y')
X		longjmp(mainjmp, COMPLAIN);
X}
X
int	RecDepth = 0;
X
void
Recur()
X{
X	char	bname[128];
X	Mark	*m;
X
X	sprintf(bname, "%s", curbuf->b_name);
X	m = MakeMark(curline, curchar, M_FLOATER);
X
X	RecDepth += 1;
X	UpdModLine = YES;
X	DoKeys(1);	/* 1 means not first time */
X	UpdModLine = YES;
X	RecDepth -= 1;
X	SetBuf(do_select(curwind, bname));
X	if (!is_an_arg())
X		ToMark(m);
X	DelMark(m);
X}
X
jmp_buf	mainjmp;
X
X#ifdef MAC
jmp_buf auxjmp;
X#endif
X
int	iniargc;	/* main sets these for DoKeys() */
char	**iniargv;
X
void
DoKeys(nocmdline)
X{
X	int	c;
X	jmp_buf	savejmp;
X
X	push_env(savejmp);
X
X	switch (setjmp(mainjmp)) {
X	case 0:
X		if (!nocmdline)
X			UNIX_cmdline(iniargc, iniargv);
X		break;
X
X	case QUIT:
X		if (RecDepth == 0) {
X			if (ModMacs()) {
X				rbell();
X				if (CharUpcase(*ask("No",
X"Some MACROS haven't been saved; leave anyway? ")) != 'Y')
X					break;
X			}
X			if (ModBufs(0)) {
X				rbell();
X				if (CharUpcase(*ask("No",
X"Some buffers haven't been saved; leave anyway? ")) != 'Y')
X					break;
X			}
X#ifdef IPROCS
X			KillProcs();
X#endif
X		}
X		pop_env(savejmp);
X		return;
X
X	case ERROR:
X		getDOT();	/* God knows what state linebuf was in */
X
X	case COMPLAIN:
X	    {
X		extern int	DisabledRedisplay;
X
X		gc_openfiles();	/* close any files we left open */
X		errormsg = YES;
X		unwind_macro_stack();
X		Asking = 0;
X		curwind->w_bufp = curbuf;
X		DisabledRedisplay = NO;
X		redisplay();
X		break;
X	    }
X	}
X
X	this_cmd = last_cmd = 0;
X
X	for (;;) {
X#ifdef MAC
X		setjmp(auxjmp);
X#endif
X		if (this_cmd != ARG_CMD) {
X			clr_arg_value();
X			last_cmd = this_cmd;
X			init_strokes();
X		}
X#ifdef MAC
X		HiliteMenu(0);
X		EventCmd = 0;
X		menus_on();
X#endif
X		c = getch();
X		if (c == -1)
X			continue;
X	 	dispatch(c);
X	}
X}
X
int	Crashing = 0;
X
char **
scanvec(args, str)
register char	**args,
X		*str;
X{
X	while (*args) {
X		if (strcmp(*args, str) == 0)
X			return args;
X		args += 1;
X	}
X	return 0;
X}
X
X#ifdef UNIX
int	UpdFreq = 30,
X	inIOread = 0;
X
updmode()
X{
X	UpdModLine = YES;
X	if (inIOread)
X		redisplay();
X#ifndef JOB_CONTROL
X	(void) signal(SIGALRM, updmode);
X#endif
X	(void) alarm((unsigned) UpdFreq);
X}
X#endif /* UNIX */
X
X#ifndef MSDOS
X#ifdef TIOCGWINSZ
X#ifdef SIGWINCH
extern win_reshape();
X#endif
X#endif
X#else /* MSDOS */
X#ifndef IBMPC
char	ttbuf[BUFSIZ];
X#endif	/* IBMPC */
X#endif /* MSDOS */
X
X#ifdef TIOCGWINSZ
X#ifdef SIGWINCH
win_reshape()
X{
X	register int oldsize;
X	register int newsize, total;
X	register Window *wp;
X
X	(void) signal(SIGWINCH, SIG_IGN);
X
X	/*
X	 * Save old number of lines.
X	 */
X	oldsize = LI;
X
X	/*
X	 * Get new line/col info.
X	 */
X	ttsize();
X
X	/*
X	 * LI has changed, and now holds the
X	 * new value.
X	 */
X	/* 
X	 *  Go through the window list, changing each window size in
X	 *  proportion to the resize. If a window becomes too small,
X	 *  delete it. We keep track of all the excess lines (caused by
X	 *  roundoff!), and give them to the current window, as a sop -
X	 *  can't be more than one or two lines anyway. This seems fairer
X	 *  than just resizing the current window.
X	 */
X	wp = fwind;
X	total = 0;
X	do {
X		newsize = LI * wp->w_height / oldsize;
X
X		if (newsize < 2) {
X			total += wp->w_height;
X			wp = wp->w_next;
X			del_wind(wp->w_prev);
X		} else {
X			wp->w_height = newsize;
X			total += newsize;
X			wp = wp->w_next;
X		}
X	} while (wp != fwind);
X
X	curwind->w_height += LI - total - 1;
X
X	/* Make a new screen structure */
X	make_scr();
X	/* Do a 'hard' update on the screen - clear and redraw */
X	cl_scr(1);
X	flusho();
X	redisplay();
X
X	(void) signal(SIGWINCH, win_reshape);
X}
X#endif
X#endif
X
void
X
X#ifdef MAC	/* will get args from user, if option key held during launch */
main()
X{
X	int argc;
X	char **argv;
X#else
main(argc, argv)
char	*argv[];
X{
X#endif /* MAC */
X
X#ifndef MSDOS
X	char	ttbuf[MAXTTYBUF],
X#ifndef VMUNIX
X		s_iobuff[LBSIZE],
X		s_genbuf[LBSIZE],
X		s_linebuf[LBSIZE],
X#endif
X		*cp;
X
X
X#ifndef VMUNIX
X	/* The way I look at it, there ain't no way I is gonna run
X	   out of stack space UNLESS I have some kind of infinite
X	   recursive bug.  So why use up some valuable memory, when
X	   there is plenty of space on the stack?  (This only matters
X	   on wimpy pdp11's, of course.) */
X
X	iobuff = s_iobuff;
X	genbuf = s_genbuf;
X	linebuf = s_linebuf;
X#endif
X
X#else /* MSDOS */
X	char	*cp,
X		*getenv();
X#endif /* MSDOS */
X
X	errormsg = 0;
X
X#ifdef MAC
X	MacInit();		/* initializes all */
X	if(make_cache() == 0) exit(-1);
X	argc = getArgs(&argv);
X#endif /* MAC */
X
X	iniargc = argc;
X	iniargv = argv;
X
X	if (setjmp(mainjmp)) {
X		printf("\rAck! I can't deal with error \"%s\" now.\n\r", mesgbuf);
X		finish(0);
X	}
X
X#ifdef MSDOS
X	/* import the temporary file path from the environment and
X	   fix the string, so that we can append a slash safely	*/
X
X	if (((cp = getenv("TMP")) || (cp = getenv("TMPDIR"))) &&
X	    (*cp != '\0')) {
X		strcpy(TmpFilePath, cp);
X		cp = &TmpFilePath[strlen(TmpFilePath)-1];
X		if ((*cp == '/') || (*cp == '\\'))
X			*cp = 0;
X	}
X	ShFlags[0] = switchar();
X#endif /* MSDOS */
X
X	getTERM();	/* Get terminal. */
X	if (getenv("METAKEY"))
X		MetaKey = 1;
X	ttsize();
X	InitCM();
X#ifdef MAC
X	InitEvents();
X#endif
X
X	d_cache_init();		/* initialize the disk buffer cache */
X#ifndef MAC
X	if ((cp = getenv("COMSPEC")) && (*cp != '\0')) {
X		strcpy(Shell, cp);
X	}
X#endif
X#ifdef MSDOS
X	if ((cp = getenv("DESCRIBE")) && (*cp != '\0'))
X	   strcpy(CmdDb, cp);
X#endif /* MSDOS */
X
X	make_scr();
X	mac_init();	/* Initialize Macros */
X	winit();	/* Initialize Window */
X#ifdef IPROCS
X	pinit();	/* Pipes/process initialization */
X#endif
X	SetBuf(do_select(curwind, Mainbuf));
X
X#ifdef CHDIR
X	{
X		char	**argp;
X
X		if ((argp = scanvec(argv, "-d")) && (argp[1][0] == '/'))
X			setCWD(argp[1]);
X		else
X			getCWD();	/* After we setup curbuf in case we have to getwd() */
X	}
X#endif
X	HomeDir = getenv("HOME");
X	if (HomeDir == 0)
X		HomeDir = "/";
X	HomeLen = strlen(HomeDir);
X
X#ifdef UNIX
X#ifdef SYSV
X	sprintf(Mailbox, "/usr/mail/%s", getenv("LOGNAME"));
X#else
X	sprintf(Mailbox, "/usr/spool/mail/%s", getenv("USER"));
X#endif /* SYSV */
X#endif /* UNIX */
X#ifdef MSDOS
X	if ((cp = getenv("JOVERC")) && (*cp != '\0'))
X	   (void) joverc(cp);
X#endif /* MSDOS */
X	(void) joverc(Joverc);
X	if (!scanvec(argv, "-j")) {
X		char	tmpbuf[100];
X		sprintf(tmpbuf, "%s/.joverc", HomeDir);
X		(void) joverc(tmpbuf);
X	}
X#ifndef MSDOS
X	if (scanvec(argv, "-r"))
X		dorecover();
X	if (scanvec(argv, "-rc"))
X		FullRecover();
X#endif 	/* MSDOS */
X	ttinit();	/* initialize terminal (after ~/.joverc) */
X#ifndef IBMPC
X	settout(ttbuf);	/* not until we know baudrate */
X#endif
X
X#ifdef MSDOS
X	(void) signal(SIGINT, SIG_IGN);
X	break_off();	/* disable ctrl-c checking */
X#endif /* MSDOS */
X#ifdef UNIX
X	(void) signal(SIGHUP, finish);
X	(void) signal(SIGINT, finish);
X	(void) signal(SIGBUS, finish);
X	(void) signal(SIGSEGV, finish);
X	(void) signal(SIGPIPE, finish);
X	(void) signal(SIGTERM, SIG_IGN);
X#ifdef TIOCGWINSZ
X#ifdef SIGWINCH
X	(void) signal(SIGWINCH, win_reshape);
X#endif
X#endif 
X	/* set things up to update the modeline every UpdFreq seconds */
X	(void) signal(SIGALRM, updmode);
X	(void) alarm((unsigned) (60 - (time((time_t *) 0) % 60)));
X#endif /* UNIX */
X
X	ResetTerm();
X	cl_scr(1);
X	flusho();
X	RedrawDisplay();	/* start the redisplay process. */
X	DoKeys(0);
X	finish(0);
X}
X
X#ifdef MSDOS
X
X#include <dos.h>
X
static	char break_state;
X
X/* set the break state to off */
private void
break_off()
X{
X	union REGS regs;
X
X	regs.h.ah = 0x33;		/* break status */
X	regs.h.al = 0x00;		/* request current state */
X	intdos(&regs, &regs);
X	break_state = regs.h.dl;
X	bdos(0x33, 0, 1);	/* turn off break */
X}
X
X/* reset the break state */
private void
break_rst()
X{
X	bdos(0x33, break_state, 1);
X}
X#endif
END_OF_FILE
if test 25416 -ne `wc -c <'./jove.c'`; then
    echo shar: \"'./jove.c'\" unpacked with wrong size!
fi
# end of './jove.c'
fi
echo shar: End of archive 11 \(of 21\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
