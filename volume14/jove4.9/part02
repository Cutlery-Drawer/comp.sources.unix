Subject:  v14i058:  Jove, an emacs variant, version 4.9, Part02/21
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Jonathan Payne <jpayne@cs.rochester.edu>
Posting-number: Volume 14, Issue 58
Archive-name: jove4.9/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 21)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f './doc/jove.qref' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./doc/jove.qref'\"
else
echo shar: Extracting \"'./doc/jove.qref'\" \(5757 characters\)
sed "s/^X//" >'./doc/jove.qref' <<'END_OF_FILE'
X					JOVE Command Quick Reference Guide
X
X--- HELP
apropos					describe-bindings			describe-command	ESC ?
describe-key		C-X ?		describe-variable			execute-named-command	ESC X
X
X
X--- MOVING AROUND
backward-character	C-B		backward-list		ESC C-P		backward-paragraph	ESC [
backward-s-expression	ESC C-B		backward-sentence	ESC A		backward-up-list	ESC C-U
backward-word		ESC B		beginning-of-file	ESC <		beginning-of-line	C-A
beginning-of-window	ESC ,		current-error				down-list		ESC C-D
end-of-file		ESC >		end-of-line		C-E		end-of-window		ESC .
find-tag		C-X T		find-tag-at-point			first-non-blank		ESC M
forward-character	C-F		forward-list		ESC C-N		forward-paragraph	ESC ]
forward-s-expression	ESC C-F		forward-sentence	ESC E		forward-word		ESC F
goto-line		ESC G		next-error		C-X C-N		next-line		C-N
next-page		C-V		previous-error		C-X C-P		previous-line		C-P
previous-page		ESC V		window-find-tag		C-X 4 t		
X
X--- INSERTING AND DELETING
delete-blank-lines	C-X C-O		delete-next-char	C-D		delete-previous-char	C-H (DEL)
delete-white-space	ESC-\		erase-buffer				handle-tab		C-I (TAB)
kill-next-word		ESC D		kill-next-word		ESC d		kill-previous-word	ESC ^?
kill-s-expression	ESC C-K		kill-to-beginning-of-se	C-X ^?		kill-to-end-of-line	C-K
kill-to-end-of-sentence	ESC K		newline			C-M (RETURN)	newline-and-backup	C-O
newline-and-indent	C-J		over-write-mode				quoted-insert		C-^
X
X
X--- SEARCH AND REPLACE
find-tag		C-X T		find-tag-at-point			i-search-forward	
i-search-reverse			query-replace-string	ESC Q		replace-in-region	
replace-string		ESC R		search-forward		C-\		search-reverse		C-R
window-find-tag		C-X 4 t		
X
X--- MARKS AND REGIONS
append-region				append-region				case-region-lower	
case-region-upper			copy-region		ESC W		exchange-point-and-mark	C-X C-X
filter-region				kill-region		C-W		replace-in-region	
set-mark		C-@ (C-SPACE)	write-region				yank			C-Y
yank-pop		ESC Y		
X
X--- TEXT PROCESSING
auto-fill-mode				bind-macro-to-word-abbr			case-character-capitali	
case-region-lower			case-region-upper			case-word-capitalize	ESC C
case-word-lower		ESC L		case-word-upper		ESC U		current-error		
define-global-word-abbr			define-mode-word-abbrev			edit-word-abbrevs	
fill-paragraph		ESC J		fill-region				left-margin-here	
next-error		C-X C-N		over-write-mode				parse-spelling-errors-i	
previous-error		C-X C-P		read-word-abbrev-file			right-margin-here	
spell-buffer				text-mode				transpose-characters	C-T
transpose-lines		C-X C-T		visible-spaces-in-windo			word-abbrev-mode	
write-word-abbrev-file			
X
X--- DISPLAY AND WINDOWS
clear-and-redraw	ESC C-L		delete-current-window	C-X D		delete-current-window	C-X d
delete-other-windows	C-X 1		grow-window		C-X ^		next-window		C-X N
number-lines-in-window			page-next-window	ESC C-V		previous-window		C-X P
redraw-display		C-L		scroll-down		ESC Z		scroll-up		C-Z
shrink-window				split-current-window	C-X 2		window-find-buffer	C-X 4 b
window-find-file	C-X 4 f		window-find-tag		C-X 4 t		
X
X--- FILES AND BUFFERS
append-region				append-region				buffer-position		
delete-buffer		C-X K		delete-buffer		C-X k		erase-buffer		
find-file		C-X C-F		insert-file		C-X C-I		kill-buffer		C-X K
list-buffers		C-X C-B		make-buffer-unmodified	ESC ~		read-macros-from-file	
read-word-abbrev-file			rename-buffer				save-file		C-X C-\
save-file		C-X C-S		select-buffer		C-X B		select-existing-buffer	C-X B
spell-buffer				visit-file		C-X C-V		visit-file		C-X C-R
window-find-buffer	C-X 4 b		window-find-file	C-X 4 f		write-file		C-X C-W
write-macros-to-file			write-modified-files	C-X C-M		write-region		
write-word-abbrev-file			
X
X--- DIRECTORIES
cd					dirs					popd			
pushd					pwd					
X
X
X--- PROGRAMMERS
auto-indent-mode			backward-s-expression	ESC C-B		c-mode			
compile-it(make)	C-X C-E		current-error				fill-comment		
forward-s-expression	ESC C-F		grind-s-expr				kill-s-expression	ESC C-K
lisp-mode				next-error		C-X C-N		number-lines-in-window	
paren-flash		),],}		parse-errors				parse-special-errors	
previous-error		C-X C-P		show-match-mode				string-length		
visible-spaces-in-windo			
X
X--- REPEAT
digit			ESC -		digit			ESC [0-9]	quadruple-numeric-argum	C-U
X
X
X--- MACROS
delete-macro				execute-keyboard-macro	C-X E		make-macro-interactive	
make-macro-interactive	ESC I		read-macros-from-file			begin-kbd-macro	C-X (
end-kbd-macro		C-X )		write-macros-to-file			
X
X--- SHELL
exit-jove		C-X C-C		i-shell-command				pause-jove		ESC S
pause-jove		ESC s		push-shell				shell			
shell-command		C-X !		shell-command-to-buffer			suspend-jove		
X
X
X--- PROCESSES
eof-process				interrupt-process	C-C		kill-process		
list-processes				process-bind-to-key			process-newline		C-M (RETURN)
process-send-data-no-re			quit-process				stop-process		
X
X
X--- MISCELLANEOUS
auto-execute-command			auto-execute-macro			bind-macro-to-key	
bind-macro-to-word-abbr			bind-to-key				character-to-octal-inse	
date					execute-extended-comman	ESC X		fundamental-mode	
print					recursive-edit				ring-the-bell(ABORT)	C-G
set					source					unbind-key		
version					
X
X--- VARIABLES
allow-^S-and-^Q				allow-bad-filenames			auto-case-abbrev	
bad-filename-extensions			c-indentation-increment			case-ignore-search	
comment-format				disable-biff				error-window-size	
file-creation-mode			files-should-end-with-n			internal-tabstop	
left-margin				mailbox					mail-check-frequency	
make-backup-files			mark-threshold				marks-should-float	
match-regular-expressio			meta-key				mode-line		
mode-line-should-stando			paren-flash-delay			physical-tabstop	
process-prompt				interrupt-character			right-margin		
scroll-step				search-exit-char			send-typeout-to-buffer	
shell					shell-flags				sync-frequency		
tag-file				tmp-file-pathname			update-time-frequency	
use-i/d-char				visible-bell				wrap-search		
write-files-on-make			
END_OF_FILE
if test 5757 -ne `wc -c <'./doc/jove.qref'`; then
    echo shar: \"'./doc/jove.qref'\" unpacked with wrong size!
fi
# end of './doc/jove.qref'
fi
if test -f './mac.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./mac.h'\"
else
echo shar: Extracting \"'./mac.h'\" \(4616 characters\)
sed "s/^X//" >'./mac.h' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X/* Macintosh related things. K. Mitchum 2/88 */
X
X
X#define NMENUS 6
X#define NMENUITEMS 40	/* This has GOT to be enough! */
X	
typedef data_obj *menumap[NMENUITEMS];
X#ifndef _mac
X	typedef char **MenuHandle;
X#endif
struct menu {
X	char *Name;
X	int menu_id;
X	MenuHandle Mn;
X	menumap m;
X};
X
struct stat {
X	int st_dev;		/* volume number */
X	long st_ino;		/* file number on volume */
X	dev_t st_rdev;
X	off_t st_size;		/* logical end of file */
X	int st_mode;
X	time_t st_mtime;	/* last modified */
X};
X
X#define S_IFDIR 2
X
typedef char *va_list;
X#define va_dcl va_list va_alist;
X#define va_start(l) l = (va_list)&va_alist
X#define va_arg(l,m) ((m*)(l += sizeof(m)))[-1]
X#define va_end(l) l = NULL
X
X#ifdef _mac
extern struct menu Menus[NMENUS];
X
static	EventRecord the_Event;
X
X/* keycodes (from Inside MacIntosh I-251). because of changes with
the MacPlus, there are some duplicate codes between cursor keys and
keypad keys. these can be deciphered by the corresponding character
codes, which are different. this table simply translates a keycode
into a character code that is appropriate. */
X
X#define NOKEY -1
X#define RET 0x0D	
X#define TAB 0x09	
X#define BACKSP 0x08
X#define ENTERL NOKEY	/* left enter key absent on MacPlus */
X#define COMMAND NOKEY	/* will be no translation anyway for these */
X#define SHIFT NOKEY
X#define CAPSLOCK NOKEY
X#define OPTION NOKEY
X#define PADDOT '.'		/* PAD period */
X#define PAD0 '0'
X#define PAD1 '1'
X#define PAD2 '2'
X#define PAD3 '3'
X#define PAD4 '4'
X#define PAD5 '5'
X#define PAD6 '6'
X#define PAD7 '7'
X#define PAD8 '8'
X#define PAD9 '9'
X#define LEFTCURS 'B'		/* jove only, make like commands */
X#define RIGHTCURS 'F'
X#define UPCURS 'P'
X#define DOWNCURS 'N'
X#define PADENTER RET
X#define PADMINUS '-'
X#define CLEAR 0
X
static char nsh_keycodes[] = {
X	'a','s','d','f','h',						/* 0 - 4 */
X	'g','z','x','c','v',						/* 5 - 9 */
X	NOKEY,'b','q','w','e',					/* 10 - 14 */
X	'r','y','t','1','2',					/* 15 - 19 */
X	'3','4','6','5','=',					/* 20 - 24 */
X	'9','7','-','8','0',					/* 25 - 29 */
X	']','O','u','[','i',					/* 30 - 34 */
X	'p',RET,'l','j','\'',					/* 35 - 39 */
X	'k',';','\\',',','/',					/* 40 - 44 */
X	'n','m','.',TAB,NOKEY,					/* 45 - 49 */
X	'`',BACKSP,ENTERL,NOKEY,NOKEY,			/* 50 - 54 */
X	COMMAND,SHIFT,CAPSLOCK,OPTION, NOKEY,	/* 55 - 59 */
X	NOKEY,NOKEY,NOKEY,NOKEY,NOKEY,			/* 60 - 64 */
X	PADDOT,RIGHTCURS,NOKEY,NOKEY,NOKEY,		/* 65 - 69 */
X	LEFTCURS,CLEAR,DOWNCURS,NOKEY,NOKEY,	/* 70 - 74 */
X	NOKEY,PADENTER,UPCURS,PADMINUS,NOKEY,	/* 75 - 79 */
X	NOKEY,NOKEY,PAD0,PAD1,PAD2,				/* 80 - 84 */
X	PAD3,PAD4,PAD5,PAD6,PAD7,				/* 85 - 89 */
X	NOKEY,PAD8,PAD9
X};
X
static char sh_keycodes[] = {
X	'A','S','D','F','H',						/* 0 - 4 */
X	'G','Z','X','C','V',						/* 5 - 9 */
X	NOKEY,'B','Q','W','E',					/* 10 - 14 */
X	'R','Y','T','!','@',					/* 15 - 19 */
X	'#','$','^','%','+',					/* 20 - 24 */
X	'(','&','_','*',')',					/* 25 - 29 */
X	'}','O','U','{','I',					/* 30 - 34 */
X	'P',RET,'L','J','\'',					/* 35 - 39 */
X	'K',';','|','<','?',					/* 40 - 44 */
X	'N','M','>',TAB,NOKEY,					/* 45 - 49 */
X	'~',BACKSP,ENTERL,NOKEY,NOKEY,			/* 50 - 54 */
X	COMMAND,SHIFT,CAPSLOCK,OPTION, NOKEY,	/* 55 - 59 */
X	NOKEY,NOKEY,NOKEY,NOKEY,NOKEY,			/* 60 - 64 */
X	PADDOT,RIGHTCURS,NOKEY,NOKEY,NOKEY,		/* 65 - 69 */
X	LEFTCURS,CLEAR,DOWNCURS,NOKEY,NOKEY,	/* 70 - 74 */
X	NOKEY,PADENTER,UPCURS,PADMINUS,NOKEY,	/* 75 - 79 */
X	NOKEY,NOKEY,PAD0,PAD1,PAD2,				/* 80 - 84 */
X	PAD3,PAD4,PAD5,PAD6,PAD7,				/* 85 - 89 */
X	NOKEY,PAD8,PAD9
X};
X
X
X
X/* tn.h Modified for variable screen size 11/21/87. K. Mitchum */
X
static int tn_rows, tn_cols, tn_top, tn_left, tn_bottom, tn_right;
int MAXROW, MAXCOL;
X
X#define SCREENSIZE (tn_rows * ROWSIZE)
X#define FONT monaco
X#define TEXTSIZE 9
X
X#define HEIGHT 11
X#define WIDTH 6
X#define DESCENT 2
X#define TWIDTH tn_cols * WIDTH
X#define THEIGHT tn_rows * HEIGHT
X
X/* window specs */
X
X#define SCROLLWIDTH 16 /* width of scroll bar control in pixels */
X#define WINDWIDTH tn_right - tn_left - SCROLLWIDTH - 1/* local coordinates */
X#define WINDHEIGHT tn_bottom - tn_top	/* local coordinates */
X
X/* for keyboard routines */
X#define MCHARS 32	/* must be power of two */
X#define NMASK MCHARS -1	/* circular buffer */
X
X#endif /* _mac */
X
X
END_OF_FILE
if test 4616 -ne `wc -c <'./mac.h'`; then
    echo shar: \"'./mac.h'\" unpacked with wrong size!
fi
# end of './mac.h'
fi
if test -f './malloc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./malloc.c'\"
else
echo shar: Extracting \"'./malloc.c'\" \(4027 characters\)
sed "s/^X//" >'./malloc.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#include "tune.h"
X
X#ifdef MY_MALLOC
X
X/*	avoid break bug */
X#ifdef pdp11
X#	define GRANULE 64
X#else
X#	define GRANULE 0
X#endif
X
X/*	C storage allocator
X *	circular first-fit strategy
X *	works with noncontiguous, but monotonically linked, arena
X *	each block is preceded by a ptr to the (pointer of) 
X *	the next following block
X *	blocks are exact number of words long 
X *	aligned to the data type requirements of ALIGN
X *	pointers to blocks must have BUSY bit 0
X *	bit in ptr is 1 for busy, 0 for idle
X *	gaps in arena are merely noted as busy blocks
X *	last block of arena (pointed to by alloct) is empty and
X *	has a pointer to first
X *	idle blocks are coalesced during space search
X *
X *	a different implementation may need to redefine
X *	ALIGN, NALIGN, BLOCK, BUSY, INT
X *	where INT is integer type to which a pointer can be cast
X */
X
X#define INT		int
X#define ALIGN		int
X#define NALIGN		1
X#define WORD		sizeof(union store)
X#define BLOCK		1024	/* a multiple of WORD*/
X#define BUSY		1
X#define NULL		0
X#define testbusy(p)	((INT)(p)&BUSY)
X#define setbusy(p)	(union store *) ((INT) (p) | BUSY)
X#define clearbusy(p)	(union store *) ((INT) (p) &~ BUSY)
X
union store {
X	union store	*ptr;
X	ALIGN	dummy[NALIGN];
X	int	calloc;		/*calloc clears an array of integers*/
X};
X
static union store	allocs[2],	/*initial arena*/
X			*allocp,	/*search ptr*/
X			*alloct,	/*arena top*/
X			*allocx;	/*for benefit of realloc*/
X
char	*sbrk();
X
char *
malloc(nbytes)
unsigned int	nbytes;
X{
X	register union store	*p,
X				*q;
X	register int	nw;
X	static int	temp;	/* coroutines assume no auto */
X
X	if (allocs[0].ptr == 0) {	/* first time */
X		allocs[0].ptr = setbusy(&allocs[1]);
X		allocs[1].ptr = setbusy(&allocs[0]);
X		alloct = &allocs[1];
X		allocp = &allocs[0];
X	}
X	nw = (nbytes + WORD + WORD - 1) / WORD;
X	for (p = allocp; ; ) {
X		for (temp = 0; ; ) {
X			if (!testbusy(p->ptr)) {
X				while (!testbusy((q = p->ptr)->ptr))
X					p->ptr = q->ptr;
X				if(q >= p + nw && p + nw >= p)
X					goto found;
X			}
X			q = p;
X			p = clearbusy(p->ptr);
X			if (p > q)
X				;
X			else if (q != alloct || p != allocs)
X				return NULL;
X			else if (++temp > 1)
X				break;
X		}
X		temp = ((nw + BLOCK/WORD) / (BLOCK/WORD)) * (BLOCK/WORD);
X		q = (union store *) sbrk(0);
X		if (q + temp + GRANULE < q)
X			return NULL;
X		q = (union store *) sbrk(temp * WORD);
X		if ((INT) q == -1)
X			return NULL;
X		alloct->ptr = q;
X		if (q != alloct+1)
X			alloct->ptr = setbusy(alloct->ptr);
X		alloct = q->ptr = q + temp - 1;
X		alloct->ptr = setbusy(allocs);
X	}
found:
X	allocp = p + nw;
X	if (q > allocp) {
X		allocx = allocp->ptr;
X		allocp->ptr = p->ptr;
X	}
X	p->ptr = setbusy(allocp);
X	return (char *) (p + 1);
X}
X
X/* freeing strategy tuned for LIFO allocation */
X
free(ap)
register char	*ap;
X{
X	register union store	*p = (union store *) ap;
X
X	allocp = --p;
X	p->ptr = clearbusy(p->ptr);
X}
X
X/*	realloc(p, nbytes) reallocates a block obtained from malloc()
X *	and freed since last call of malloc()
X *	to have new size nbytes, and old content
X *	returns new location, or 0 on failure
X*/
X
char *
realloc(obj, nbytes)
char	*obj;
unsigned int	nbytes;
X{
X	register union store	*q,
X				*p = (union store *) obj;
X	union store	*s,
X			*t;
X	register unsigned int	nw;
X	unsigned int	onw;
X
X	if (testbusy(p[-1].ptr))
X		free((char *) p);
X	onw = p[-1].ptr - p;
X	q = (union store *) malloc(nbytes);
X	if(q == NULL || q == p)
X		return((char *) q);
X	s = p;
X	t = q;
X	nw = (nbytes + WORD - 1)/WORD;
X	if (nw < onw)
X		onw = nw;
X	while (onw-- != 0)
X		*t++ = *s++;
X	if(q < p && q + nw >= p)
X		(q + (q+nw-p))->ptr = allocx;
X	return (char *) q;
X}
X
X#endif /* MY_MALLOC */
END_OF_FILE
if test 4027 -ne `wc -c <'./malloc.c'`; then
    echo shar: \"'./malloc.c'\" unpacked with wrong size!
fi
# end of './malloc.c'
fi
if test -f './marks.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./marks.c'\"
else
echo shar: Extracting \"'./marks.c'\" \(4499 characters\)
sed "s/^X//" >'./marks.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
int	MarksShouldFloat = 1;
X
X#include "jove.h"
X
Mark *
MakeMark(line, column, type)
register Line	*line;
X{
X	register Mark	*newmark = (Mark *) emalloc(sizeof *newmark);
X
X	MarkSet(newmark, line, column);
X	newmark->m_next = curbuf->b_marks;
X	newmark->m_flags = type;
X	curbuf->b_marks = newmark;
X	return newmark;
X}
X
void
flush_marks(b)
Buffer	*b;
X{
X	register Mark	*m,
X			*next;
X
X	m = b->b_marks;
X	while (m != 0) {
X		next = m->m_next;
X		free((char *) m);
X		m = next;
X	}
X}
X
void
DelMark(m)
register Mark	*m;
X{
X	register Mark	*mp = curbuf->b_marks;
X
X	if (m == mp)
X		curbuf->b_marks = m->m_next;
X	else {
X		while (mp != 0 && mp->m_next != m)
X			mp = mp->m_next;
X		if (mp == 0)
X			complain("Unknown mark!");
X		mp->m_next = m->m_next;
X	}
X	free((char *) m);
X}
X
void
AllMarkSet(b, line, col)
Buffer	*b;
register Line	*line;
X{
X	register Mark	*mp;
X
X	for (mp = b->b_marks; mp != 0; mp = mp->m_next)
X		MarkSet(mp, line, col);
X}
X
void
MarkSet(m, line, column)
Mark	*m;
Line	*line;
X{
X	m->m_line = line;
X	m->m_char = column;
X}
X
void
PopMark()
X{
X	int	pmark;
X
X	if (curmark == 0)
X		return;
X	if (curbuf->b_markring[(curbuf->b_themark + 1) % NMARKS] == 0) {
X		pmark = curbuf->b_themark;
X		do {
X			if (--pmark < 0)
X				pmark = NMARKS - 1;
X		} while (curbuf->b_markring[pmark] != 0);
X
X		curbuf->b_markring[pmark] = MakeMark(curline, curchar, MarksShouldFloat ? M_FLOATER : M_FIXED);
X		ToMark(curmark);
X		DelMark(curmark);
X		curmark = 0;
X	} else
X		PtToMark();
X
X	pmark = curbuf->b_themark - 1;
X	if (pmark < 0)
X		pmark = NMARKS - 1;
X	curbuf->b_themark = pmark;
X}
X
void
SetMark()
X{
X	if (is_an_arg())
X		PopMark();
X	else
X		set_mark();
X}
X
void
set_mark()
X{
X	do_set_mark(curline, curchar);
X}
X
void
do_set_mark(l, c)
Line	*l;
X{
X	curbuf->b_themark = (curbuf->b_themark + 1) % NMARKS;
X	if (curmark == 0)
X		curmark = MakeMark(l, c, MarksShouldFloat ? M_FLOATER : M_FIXED);
X	else
X		MarkSet(curmark, l, c);
X	s_mess("[Point pushed]");
X}
X
X/* Move point to Mark */
X
void
ToMark(m)
Mark	*m;
X{
X	int	len;
X
X	if (m == 0)
X		return;
X	DotTo(m->m_line, m->m_char);
X	if (curchar > (len = length(curline)))
X		curchar = len;
X}
X
Mark *
CurMark()
X{
X	if (curmark == 0)
X		complain("No mark.");
X	return curmark;
X}
X
void
PtToMark()
X{
X	Line	*mline;
X	int	mchar;
X	Mark	*m = CurMark();
X
X	mline = curline;
X	mchar = curchar;
X
X	ToMark(m);
X	MarkSet(m, mline, mchar);
X}
X
X/* Fix marks for after a deletion.  For now, even marks that don't
X   float will actually float, because we can't allow marks to point
X   to non-existant lines. */
X
void
DFixMarks(line1, char1, line2, char2)
register Line	*line1,
X		*line2;
X{
X	register Mark	*m;
X	Line	*lp = line1;
X
X	if (curbuf->b_marks == 0)
X		return;
X	while (lp != line2->l_next) {
X		for (m = curbuf->b_marks; m != 0; m = m->m_next)
X			if (m->m_line == lp)
X				m->m_char |= (1 << 15);
X		lp = lp->l_next;
X	}
X	for (m = curbuf->b_marks; m; m = m->m_next) {
X		if ((m->m_char & (1 << 15)) == 0)
X			continue;	/* Not effected */
X		m->m_char &= ~(1 << 15);
X		if (m->m_line == line1 && m->m_char < char1)
X			continue;	/* This mark is not affected */
X		if (line1 == line2) {
X			if (m->m_char >= char1 && m->m_char <= char2)
X				m->m_char = char1;
X			else if (m->m_char > char2)
X				m->m_char -= (char2 - char1);
X			/* Same line move the mark backward */
X		} else if (m->m_line == line2) {
X			if (m->m_char > char2)
X				m->m_char = char1 + (m->m_char - char2);
X			else
X				m->m_char = char1;
X			m->m_flags |= M_BIG_DELETE;
X			m->m_line = line1;
X		} else {
X			m->m_char = char1;
X			m->m_line = line1;
X			m->m_flags |= M_BIG_DELETE;
X		}
X	}
X}
X
X/* Fix marks after an insertion.  Marks that don't float are ignored
X   on insertion, which means PtToMark has to be careful ... */
X
void
IFixMarks(line1, char1, line2, char2)
register Line	*line1,
X		*line2;
X{
X	register Mark	*m;
X
X	for (m = curbuf->b_marks; m != 0; m = m->m_next) {
X		if ((m->m_flags & M_FLOATER) == 0)
X			continue;
X		if (m->m_line == line1) {
X			if (m->m_char > char1) {
X				m->m_line = line2;
X				if (line1 == line2)
X					m->m_char += (char2 - char1);
X				else
X					m->m_char = char2 + (m->m_char - char1);
X			}
X		} 
X	}
X}
END_OF_FILE
if test 4499 -ne `wc -c <'./marks.c'`; then
    echo shar: \"'./marks.c'\" unpacked with wrong size!
fi
# end of './marks.c'
fi
if test -f './move.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./move.c'\"
else
echo shar: Extracting \"'./move.c'\" \(4844 characters\)
sed "s/^X//" >'./move.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#include "jove.h"
X#include "ctype.h"
X
X#ifdef MAC
X#	undef private
X#	define private
X#endif
X
X#ifdef	LINT_ARGS
private void to_sent(int);
X#else
private void to_sent();
X#endif
X
X#ifdef MAC
X#	undef private
X#	define private static
X#endif
X
static int	line_pos;
X
void
f_char(n)
register int	n;
X{
X	if (n < 0) {
X		b_char(-n);
X		return;
X	}
X	while (--n >= 0) {
X		if (eolp()) {			/* Go to the next Line */
X			if (curline->l_next == 0)
X				break;
X			SetLine(curline->l_next);
X		} else
X			curchar += 1;
X	}
X}
X
void
b_char(n)
register int	n;
X{
X	if (n < 0) {
X		f_char(-n);
X		return;
X	}
X	while (--n >= 0) {
X		if (bolp()) {
X			if (curline->l_prev == 0)
X				break;
X			SetLine(curline->l_prev);
X			Eol();
X		} else
X			curchar -= 1;
X	}
X}
X
void
ForChar()
X{
X	f_char(arg_value());
X}
X
void
BackChar()
X{
X	b_char(arg_value());
X}
X
void
NextLine()
X{
X	if ((curline == curbuf->b_last) && eolp())
X		complain(NullStr);
X	line_move(FORWARD, arg_value(), YES);
X}
X
void
PrevLine()
X{
X	if ((curline == curbuf->b_first) && bolp())
X		complain(NullStr);
X	line_move(BACKWARD, arg_value(), YES);
X}
X
X/* moves to a different line in DIR; LINE_CMD says whether this is
X   being called from NextLine() or PrevLine(), in which case it tries
X   to line up the column with the column of the current line */
X
void
line_move(dir, n, line_cmd)
X{
X	Line	*(*proc)() = (dir == FORWARD) ? next_line : prev_line;
X	Line	*line;
X
X	line = (*proc)(curline, n);
X	if (line == curline) {
X		if (dir == FORWARD) Eol();
X			else Bol();
X		return;
X	}
X
X	if (line_cmd) {
X		this_cmd = LINECMD;
X		if (last_cmd != LINECMD)
X			line_pos = calc_pos(linebuf, curchar);
X	}
X	SetLine(line);		/* curline is in linebuf now */
X	if (line_cmd)
X		curchar = how_far(curline, line_pos);
X}
X
X/* returns what cur_char should be for that position col */
X
int
how_far(line, col)
Line	*line;
X{
X	register char	*lp;
X	register int	pos,
X			c;
X	char	*base;
X
X	base = lp = lcontents(line);
X	pos = 0;
X
X	while (pos < col && (c = (*lp & CHARMASK))) {
X		if (c == '\t')
X			pos += (tabstop - (pos % tabstop));
X		else if (isctrl(c))
X			pos += 2;
X		else
X			pos += 1;
X		lp += 1;
X	}
X
X	return lp - base;
X}
X
void
Bol()
X{
X	curchar = 0;
X}
X
void
Eol()
X{
X	curchar = strlen(linebuf);
X}
X
void
Eof()
X{
X	PushPntp(curbuf->b_last);
X	ToLast();
X}
X
void
Bof()
X{
X	PushPntp(curbuf->b_first);
X	ToFirst();
X}
X
X/* Move forward (if dir > 0) or backward (if dir < 0) a sentence.  Deals
X   with all the kludgery involved with paragraphs, and moving backwards
X   is particularly yucky. */
X
private void
to_sent(dir)
X{
X	Bufpos	*new,
X		old;
X	extern char	*ParaStr;
X
X	DOTsave(&old);
X
X	new = dosearch("^[ \t]*$\\|[?.!]", dir, 1);
X	if (new == 0) {
X		if (dir == BACKWARD) ToFirst();
X			else ToLast();
X		return;
X	}
X	SetDot(new);
X	if (dir < 0) {
X		to_word(1);
X		if ((old.p_line == curline && old.p_char <= curchar) ||
X		    (inorder(new->p_line, new->p_char, old.p_line, old.p_char) &&
X		     inorder(old.p_line, old.p_char, curline, curchar))) {
X		     	SetDot(new);
X		     	to_sent(dir);
X		}
X		return;		/* We're there? */
X	}
X	if (blnkp(linebuf)) {
X		Bol();
X		b_char(1);
X		if (old.p_line == curline && old.p_char >= curchar) {
X			to_word(1);	/* Oh brother this is painful */
X			to_sent(1);
X		}
X	} else {
X		extern int	REbom;
X
X		curchar = REbom + 1;	/* Just after the [?.!] */
X		if (LookingAt("[\")]  *\\|[\")]$", linebuf, curchar))
X			curchar += 1;
X		else if (!eolp() && !LookingAt("  *", linebuf, curchar))
X			to_sent(dir);
X	}
X}
X
void
Bos()
X{
X	register int	num = arg_value();
X
X	if (num < 0) {
X		negate_arg_value();
X		Eos();
X		return;
X	}
X
X	while (--num >= 0) {
X		to_sent(-1);
X		if (bobp())
X			break;
X	}
X}
X
void
Eos()
X{
X	register int	num = arg_value();
X
X	if (num < 0) {
X		negate_arg_value();
X		Bos();
X		return;
X	}
X
X	while (--num >= 0) {
X		to_sent(1);
X		if (eobp())
X			break;
X	}
X}
X
void
f_word(num)
register int	num;
X{
X	register char	c;
X	if (num < 0) {
X		b_word(-num);
X		return;
X	}
X	while (--num >= 0) {
X		to_word(FORWARD);
X		while ((c = linebuf[curchar]) != 0 && isword(c))
X			curchar += 1;
X		if (eobp())
X			break;
X	}
X	this_cmd = 0;	/* Semi kludge to stop some unfavorable behavior */
X}
X
void
b_word(num)
register int	num;
X{
X	register char	c;
X
X	if (num < 0) {
X		f_word(-num);
X		return;
X	}
X	while (--num >= 0) {
X		to_word(BACKWARD);
X		while (!bolp() && (c = linebuf[curchar - 1], isword(c)))
X			curchar -= 1;
X		if (bobp())
X			break;
X	}
X	this_cmd = 0;
X}
X
void
ForWord()
X{
X	f_word(arg_value());
X}
X
void
BackWord()
X{
X	b_word(arg_value());
X}
END_OF_FILE
if test 4844 -ne `wc -c <'./move.c'`; then
    echo shar: \"'./move.c'\" unpacked with wrong size!
fi
# end of './move.c'
fi
if test -f './scandir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./scandir.c'\"
else
echo shar: Extracting \"'./scandir.c'\" \(4890 characters\)
sed "s/^X//" >'./scandir.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#include "jove.h"
X
X#ifdef MSDOS
X#include <dos.h>
X#include <search.h>
X#endif
X
X#ifdef UNIX
X#include <sys/stat.h>
X#ifdef M_XENIX
X#include <sys/ndir.h>
X#else
X#include <sys/dir.h>
X#endif /* M_XENIX */
X#endif
X
X#ifdef F_COMPLETION
X
X#ifdef UNIX
X
X#if defined(BSD4_2) || defined(M_XENIX)
X
X#define DIRSIZE(entry)	DIRSIZ(entry)
X
X#else
X
X#define DIRSIZE(entry)	(entry->d_name[DIRSIZ-1]=='\0' ? strlen(entry->d_name) : DIRSIZ)
X
typedef struct {
X	int	d_fd;		/* File descriptor for this directory */
X} DIR;
X
DIR *
opendir(dir)
char	*dir;
X{
X	DIR	*dp = (DIR *) malloc(sizeof *dp);
X	struct stat	stbuf;
X
X	if ((dp->d_fd = open(dir, 0)) == -1)
X		return 0;
X	if ((fstat(dp->d_fd, &stbuf) == -1) || !(stbuf.st_mode & S_IFDIR)) {
X		closedir(dp);
X		return 0;	/* this isn't a directory! */
X	}
X	return dp;
X}
X
closedir(dp)
DIR	*dp;
X{
X	(void) close(dp->d_fd);
X	free((char *) dp);
X}
X
struct direct *
readdir(dp)
DIR	*dp;
X{
X	static struct direct	dir;
X
X	do
X		if (read(dp->d_fd, &dir, sizeof dir) != sizeof dir)
X			return 0;
X#if defined(elxsi) && defined(SYSV)
X	/*
X	 * Elxsi has a BSD4.2 implementation which may or may not use
X	 * `twisted inodes' ...  Anyone able to check?
X	 */
X	while (*(unsigned short *)&dir.d_ino == 0);
X#else
X	while (dir.d_ino == 0);
X#endif
X
X	return &dir;
X}
X
X#endif /* BSD4_2 */
X
X/* Scandir returns the number of entries or -1 if the directory cannoot
X   be opened or malloc fails. */
X
int
scandir(dir, nmptr, qualify, sorter)
char	*dir;
char	***nmptr;
int	(*qualify)();
int	(*sorter)();
X{
X	DIR	*dirp;
X	struct direct	*entry;
X	char	**ourarray;
X	unsigned int	nalloc = 10,
X			nentries = 0;
X
X	if ((dirp = opendir(dir)) == 0)
X		return -1;
X	if ((ourarray = (char **) malloc(nalloc * sizeof (char *))) == 0)
memfail:	complain("[Malloc failed: cannot scandir]");
X	while ((entry = readdir(dirp)) != 0) {
X		if (qualify != 0 && (*qualify)(entry->d_name) == 0)
X			continue;
X		if (nentries == nalloc) {
X			ourarray = (char **) realloc((char *) ourarray, (nalloc += 10) * sizeof (char *));
X			if (ourarray == 0)
X				goto memfail;
X		}
X		ourarray[nentries] = (char *) malloc(DIRSIZE(entry) + 1);
X		null_ncpy(ourarray[nentries], entry->d_name, (int) DIRSIZE(entry));
X		nentries += 1;
X	}
X	closedir(dirp);
X	if ((nentries + 1) != nalloc)
X		ourarray = (char **) realloc((char *) ourarray,
X					((nentries + 1) * sizeof (char *)));
X	if (sorter != 0)
X		qsort((char *) ourarray, nentries, sizeof (char **), sorter);
X	*nmptr = ourarray;
X	ourarray[nentries] = 0;		/* guaranteed 0 pointer */
X
X	return nentries;
X}
X
X#endif /* UNIX */
X
X#ifdef MSDOS
X#define	DIRSIZ	13
X#define DIRSIZE(entry)	strlen(entry.name)
X
X/* Scandir returns the number of entries or -1 if the directory cannoot
X   be opened or malloc fails. */
X
unsigned int fmask = _A_NORMAL|_A_RDONLY|_A_HIDDEN|_A_SUBDIR;
X
int
scandir(dir, nmptr, qualify, sorter)
char	*dir;
char	***nmptr;
int	(*qualify)();
int	(*sorter)();
X{
X	char dirname[FILESIZE];
X	struct find_t entry;
X	char *ptr;
X	char	**ourarray;
X	unsigned int	nalloc = 10,
X			nentries = 0;
X
X	strcpy(dirname, dir);
X	ptr = &dirname[strlen(dirname)-1];
X	if ((dirname[1] == ':' && !dirname[2]) || (*ptr == '/') || (*ptr == '\\'))
X	   strcat(dirname, "*.*");
X	else
X	   strcat(dirname, "/*.*");
X
X	if (_dos_findfirst(dirname, fmask, &entry))
X	   return -1;
X	if ((ourarray = (char **) malloc(nalloc * sizeof (char *))) == 0)
memfail:	complain("[Malloc failed: cannot scandir]");
X	do  {
X		if ((fmask == 0x10) && !(entry.attrib&fmask))
X			goto skip;
X		strlwr(entry.name);
X		if (qualify != (int (*)())0 && (*qualify)(entry.name) == 0)
X			goto skip;
X		if (nentries == nalloc) {
X			ourarray = (char **) realloc((char *) ourarray, (nalloc += 10) * sizeof (char *));
X			if (ourarray == 0)
X				goto memfail;
X		}
X		ourarray[nentries] = (char *) malloc(DIRSIZE(entry) + 1);
X		null_ncpy(ourarray[nentries], entry.name, (int) DIRSIZE(entry));
X		nentries++;
skip:	;
X    }
X    while (_dos_findnext(&entry) == 0);
X
X	if ((nentries + 1) != nalloc)
X		ourarray = (char **) realloc((char *) ourarray,
X					((nentries + 1) * sizeof (char *)));
X	if (sorter != (int (*)())0)
X		qsort((char *) ourarray, nentries, sizeof (char **), sorter);
X	*nmptr = ourarray;
X	ourarray[nentries] = 0;		/* guaranteed 0 pointer */
X
X	return nentries;
X}
X
X#endif /* MSDOS */
X
void
freedir(nmptr, nentries)
char	***nmptr;
X{
X	char	**ourarray = *nmptr;
X
X	while (--nentries >= 0)
X		free(*ourarray++);
X	free((char *) *nmptr);
X	*nmptr = 0;
X}
X
int
alphacomp(a, b)
char	**a,
X	**b;
X{
X	return strcmp(*a, *b);
X}
X#endif
END_OF_FILE
if test 4890 -ne `wc -c <'./scandir.c'`; then
    echo shar: \"'./scandir.c'\" unpacked with wrong size!
fi
# end of './scandir.c'
fi
if test -f './setmaps.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./setmaps.c'\"
else
echo shar: Extracting \"'./setmaps.c'\" \(4068 characters\)
sed "s/^X//" >'./setmaps.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#define TXT_TO_C	1	/* must be a number for MAC compiler */
X
X#include "funcdefs.c"
X
X#ifdef MAC
X#include "vars.c"
X#endif
X
X#undef putchar	/* From jove.h via funcdefs.c, conflicts with STDIO */
X#undef putc
X#undef getc
X#undef EOF
X#undef FILE
X#undef BUFSIZ
X#undef NULL
X#include <stdio.h>
X
matchcmd(choices, what)
register struct cmd	choices[];
register char	*what;
X{
X	register int	len;
X	int	i,
X		found = 0,
X		save,
X		exactmatch = -1;
X
X	len = strlen(what);
X	for (i = 0; choices[i].Name != 0; i++) {
X		if (*what != *choices[i].Name)
X			continue;
X#ifdef MAC /* see "left-margin" and "left-margin-here" */
X		if (strcmp(what, choices[i].Name) == 0)
X#else
X		if (strncmp(what, choices[i].Name, len) == 0)
X#endif
X		return i;
X	}
X	return -1;
X}
X
X#ifdef MAC
matchvar(choices, what)
register struct variable choices[];
register char	*what;
X{
X	register int	len;
X	int	i,
X		found = 0,
X		save,
X		exactmatch = -1;
X
X	len = strlen(what);
X	for (i = 0; choices[i].Name != 0; i++) {
X		if (*what != *choices[i].Name)
X			continue;
X		if (strcmp(what, choices[i].Name) == 0)
X			return i;
X	}
X	return -1;
X}
X#endif
X
char *
PPchar(c)
int	c;
X{
X	static char	str[16];
X	char	*cp = str;
X
X	if (c & 0200) {
X		c &= ~0200;
X		strcpy(cp, "M-");
X		cp += 2;
X	}
X	if (c == '\033')
X		strcpy(cp, "ESC");
X#ifdef IBMPC
X	else if (c == '\377')
X	        strcpy(cp, "M");
X#endif /* IBMPC */
X	else if (c < ' ')
X		(void) sprintf(cp, "C-%c", c + '@');
X	else if (c == '\177')
X		strcpy(cp, "^?");
X	else
X		(void) sprintf(cp, "%c", c);
X	return str;
X}
X
void
extract(into, from)
char	*into,
X	*from;
X{
X	from += 2;	/* Past tab and first double quote. */
X	while ((*into = *from++) != '"')
X		into += 1;
X	*into = 0;
X}
X
X
void
X
X#ifdef MAC
X_main()		/* for Mac, so we can use redirection */
X#else
main()
X#endif
X{
X	FILE	*ifile,
X		*of;
X	char	line[100],
X#ifdef MAC
X		*which,
X#endif
X		comname[70];
X	int	comnum,
X		ch,
X#ifdef MAC
X		inmenu = 0,
X#endif
X		savech = -1,
X		errors = 0;
X
X	ifile = stdin;
X	of = stdout;
X	if (ifile == NULL || of == NULL) {
X		printf("Cannot read input or write output.\n");
X		exit(1);
X	}
X	while (fgets(line, sizeof line, ifile) != NULL) {
X		if (strncmp(line, "#if", 3) == 0) {
X			savech = ch;
X			fprintf(of, line);
X			continue;
X		} else if (strncmp(line, "#else", 5) == 0) {
X			if (savech == -1)
X				fprintf(stderr, "WARNING: ifdef/endif mismatch!\n");
X			else
X				ch = savech;
X			fprintf(of, line);
X			continue;
X		} else if (strncmp(line, "#endif", 6) == 0) {
X			savech = -1;
X			fprintf(of, line);
X			continue;
X#ifdef MAC
X		} else if (strncmp(line, "#MENU", 5) == 0) {
X			inmenu = 1;
X			continue;
X#endif
X		} else if (strncmp(line, "\t\"", 2) != 0) {
X			fprintf(of, line);
X			ch = 0;
X			continue;
X		}
X		extract(comname, line);
X		if (strcmp(comname, "unbound") == 0)
X			comnum = 12345;
X		else {
X#ifdef MAC
X			which = "commands";
X#endif
X			comnum = matchcmd(commands, comname);
X#ifdef MAC
X			if (comnum < 0 && inmenu) {
X				comnum = matchvar(variables, comname);
X				which = "variables";
X			}
X#endif
X			if (comnum < 0) {
X#ifdef MAC
X				fprintf(stderr, "Warning: cannot find item \"%s\".\n", comname);
X#else
X				fprintf(stderr, "Warning: cannot find command \"%s\".\n", comname);
X#endif
X				errors += 1;
X				comnum = 12345;
X			}
X		}
X#ifdef MAC
X		if(inmenu) {
X			if (comnum == 12345)
X				fprintf(of, "	(data_obj *) 0,\n");
X			else
X				fprintf(of, "	(data_obj *) &%s[%d],\n",which, comnum);
X		} 
X		else {
X#endif
X		if (comnum == 12345)
X			fprintf(of, "	(data_obj *) 0,                 /* %s */\n", PPchar(ch++));
X		else
X			fprintf(of, "	(data_obj *) &commands[%d],	/* %s */\n", comnum, PPchar(ch++));
X	}
X#ifdef MAC
X	}
X#endif
X	fclose(of);
X	fclose(ifile);
X	exit(errors);
X}
END_OF_FILE
if test 4068 -ne `wc -c <'./setmaps.c'`; then
    echo shar: \"'./setmaps.c'\" unpacked with wrong size!
fi
# end of './setmaps.c'
fi
if test -f './term.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./term.c'\"
else
echo shar: Extracting \"'./term.c'\" \(4482 characters\)
sed "s/^X//" >'./term.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#include "jove.h"
X#include <ctype.h>
X#include <errno.h>
X
X#ifndef MAC	/* most of the file... */
X
X#ifndef MSDOS
X#ifdef SYSV
X#   include <termio.h>
X#else
X#   include <sgtty.h>
X#endif /* SYSV */
X#endif /* MSDOS */
X
X#ifdef IPROCS
X#   include <signal.h>
X#endif
X
X#define _TERM
X#include "termcap.h"
X
X/* Termcap definitions */
X
X#ifndef IBMPC
char	*CS,
X	*SO,
X	*SE,
X	*CM,
X	*CL,
X	*CE,
X	*HO,
X	*AL,
X	*DL,
X	*VS,
X	*VE,
X	*KS,
X	*KE,
X	*TI,
X	*TE,
X	*IC,
X	*DC,
X	*IM,
X	*EI,
X	*LL,
X	*M_IC,	/* Insert char with arg */
X	*M_DC,	/* Delete char with arg */
X	*M_AL,	/* Insert line with arg */
X	*M_DL,	/* Delete line with arg */
X	*SF,	/* Scroll forward */
X	*SR,
X	*SP,	/* Send Cursor Position */
X	*VB,
X	*BL,
X	*IP,	/* insert pad after character inserted */
X	*lPC,
X	*NL;
X#endif
X
int	LI,
X	ILI,	/* Internal lines, i.e., 23 of LI is 24. */
X	CO,
X
X	UL,
X	MI,
X	SG,	/* number of magic cookies left by SO and SE */
X	XS,	/* whether standout is braindamaged */
X
X	TABS,
X	UPlen,
X	HOlen,
X	LLlen;
X
extern char	PC,
X		*BC,
X		*UP;
X
X#ifdef notdef
X	/*
X	 * Are you sure about this one Jon?  On the SYSV system I tried this
X	 * on I got a multiple definition of PC because it was already
X	 * defined in -ltermcap.  Similarly for BC and UP ...
X	 */
X#ifdef SYSVR2 /* release 2, at least */
char	PC;
X#else
extern char	PC;
X#endif /* SYSVR2 */
X#endif
X
X#ifndef IBMPC
static char	tspace[256];
X
X/* The ordering of ts and meas must agree !! */
static char	*ts="vsvealdlspcssosecmclcehoupbcicimdceillsfsrvbksketiteALDLICDCpcipblnl";
static char	**meas[] = {
X	&VS, &VE, &AL, &DL, &SP, &CS, &SO, &SE,
X	&CM, &CL, &CE, &HO, &UP, &BC, &IC, &IM,
X	&DC, &EI, &LL, &SF, &SR, &VB, &KS, &KE,
X	&TI, &TE, &M_AL, &M_DL, &M_IC, &M_DC,
X	&lPC, &IP, &BL, &NL, 0
X};
X
static void
gets(buf)
char	*buf;
X{
X	buf[read(0, buf, 12) - 1] = 0;
X}	
X
X/* VARARGS1 */
X
static void
TermError(fmt, a)
char	*fmt;
X{
X	printf(fmt, a);
X	flusho();
X	_exit(1);
X}
X
void
getTERM()
X{
X	char	*getenv(), *tgetstr() ;
X	char	termbuf[13],
X		*termname = NULL,
X		*termp = tspace,
X		tbuff[2048];	/* Good grief! */
X	int	i;
X
X	termname = getenv("TERM");
X	if ((termname == NULL) || (*termname == '\0') ||
X	    (strcmp(termname, "dumb") == 0) ||
X	    (strcmp(termname, "unknown") == 0) ||
X	    (strcmp(termname, "network") == 0)) {
X		putstr("Enter terminal type (e.g, vt100): ");
X		flusho();
X		gets(termbuf);
X		if (termbuf[0] == 0)
X			TermError(NullStr);
X
X		termname = termbuf;
X	}
X
X	if (tgetent(tbuff, termname) < 1)
X		TermError("[\"%s\" unknown terminal type?]", termname);
X
X	if ((CO = tgetnum("co")) == -1)
wimperr:	TermError("You can't run JOVE on a %s terminal.\n", termname);
X
X	else if (CO > MAXCOLS)
X		CO = MAXCOLS;
X
X	if ((LI = tgetnum("li")) == -1)
X		goto wimperr;
X
X	if ((SG = tgetnum("sg")) == -1)
X		SG = 0;			/* Used for mode line only */
X
X	if ((XS = tgetflag("xs")) == -1)
X		XS = 0;			/* Used for mode line only */
X
X	for (i = 0; meas[i]; i++) {
X		*(meas[i]) = (char *) tgetstr(ts, &termp);
X		ts += 2;
X	}
X	if (lPC)
X		PC = *lPC;
X	if (XS)
X		SO = SE = 0;
X
X	if (CS && !SR)
X		CS = SR = SF = 0;
X
X	if (CS && !SF)
X		SF = "\n";
X
X	if (IM && (*IM == 0))
X		IM = 0;
X	else
X		MI = tgetflag("mi");
X
X	UL = tgetflag("ul");
X
X	if (NL == 0)
X		NL = "\n";
X	else {			/* strip stupid padding information */
X		while (isdigit(*NL))
X			NL += 1;
X		if (*NL == '*')
X			NL += 1;
X	}
X
X	if (BL == 0)
X		BL = "\007";
X
X#ifdef ID_CHAR
X	disp_opt_init();
X#endif
X	if (CanScroll = ((AL && DL) || CS))
X		IDline_setup(termname);
X}
X
X#else
X
void
InitCM()
X{
X}
X
int EGA;
X
void
getTERM()
X{
X	char	*getenv(), *tgetstr() ;
X	char	*termname;
X    	void	init_43(), init_term();
X	unsigned char lpp(), chpl();
X
X	if (getenv("EGA") || (!stricmp(getenv("TERM"), "EGA"))) {
X	   termname = "ega";
X	   init_43();
X	   EGA = 1;
X	}
X	else {
X	   termname = "ibmpc";
X	   init_term();
X	   EGA = 0;
X	}
X
X	CO = chpl();
X	LI = lpp();
X
X	SG = 0;			/* Used for mode line only */
X	XS = 0;			/* Used for mode line only */
X
X	CanScroll = 1;
X}
X
X#endif /* IBMPC */
X
X#else /* MAC */
int	LI,
X	ILI,	/* Internal lines, i.e., 23 of LI is 24. */
X	CO,
X	TABS,
X	SG;
X	
void getTERM()
X{
X	SG = 0;
X	CanScroll = 1;
X}
X
X#endif /* MAC */
X
X
END_OF_FILE
if test 4482 -ne `wc -c <'./term.c'`; then
    echo shar: \"'./term.c'\" unpacked with wrong size!
fi
# end of './term.c'
fi
if test -f './tune.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./tune.h'\"
else
echo shar: Extracting \"'./tune.h'\" \(4774 characters\)
sed "s/^X//" >'./tune.h' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#define TUNED		/* don't touch this */
X
X/*#define MAC 1		/* alas, there is no command line for this */
X
X#ifdef MAC
X#	define defined(x) (x)	/* take this out and you're in trouble... */
X#endif
X
X
X/* The operating system (MSDOS or MAC) must be defined by this point.
X   IBMPC is defined in the Makefile. All MAC defines should be
X   numerical (i.e. #define MAC 1) so that defined() will work. */
X
X#if !(defined(MSDOS) || defined(MAC))
X#	define UNIX
X#endif
X
X
X#ifdef UNIX		
X			/* pick your version of Unix */
X#   define BSD4_2	/* Berkeley 4.2 BSD */
X#   define BSD4_3	/* Berkeley 4.3 BSD and 2.10 BSD */
X/*# define SYSV		/* for (System III/System V) UNIX systems */
X/*# define SYSVR2	/* system 5, rel. 2 */
X			/* M_XENIX is defined by the Compiler */
X#endif /* UNIX */
X
X#ifdef SYSVR2
X#   ifndef SYSV
X#	define SYSV	/* SYSV is a subset of SYSVR2 */
X#   endif
X#endif
X
X#ifdef BSD4_3
X#   ifndef BSD4_2
X#	define BSD4_2	/* 4.3 is 4.2 only different. */
X#   endif
X#endif
X
X#ifdef M_XENIX
X#   define iAPX286 1	/* we have segments. */
X#endif
X
X#ifdef MSDOS
X#   ifdef M_I86LM		/* large memory model */
X#		define NBUF 64
X#	else
X#		define NBUF 3
X#   		define SMALL
X#   endif
X#   define BUFSIZ	512		/* or 1024 */
X#endif
X
X#ifdef UNIX
X#   if vax || sel || sun || pyr || mc68000 || tahoe || iAPX286 || GOULD_NP1 || u3b2
X#	define VMUNIX		/* Virtual Memory UNIX */
X#	define BUFSIZ	1024
X#	if iAPX286
X#	    define NBUF	48	/* NBUF*BUFSIZ must be less than 64 kB */
X#	else
X#	    define NBUF	64	/* number of disk buffers */
X#	endif /* iAPX286 */
X#   else
X#	define SMALL
X#	define BUFSIZ	512	/* or 1024 */
X#   endif
X#
X#   define LOAD_AV	/* Use the load average for various commands.
X#			   Do not define this if you lack a load average
X#			   system call and kmem is read protected. */
X#
X#   define JOB_CONTROL	/* if you have job stopping */
X#
X#   ifdef JOB_CONTROL
X#       define MENLO_JCL
X#       define IPROCS	/* Interactive processes only work with JOB_CONTROL. */
X#   endif
X#
X#   define SUBPROCS	/* only on UNIX systems (NOT INCORPORATED YET) */
X#endif /* UNIX */
X
X
X#ifdef SMALL
X    typedef	unsigned short	disk_line;
X#else
X#   if defined(iAPX286) || defined(MSDOS) || defined(MAC)
X	typedef long	disk_line;
X#   else
X	typedef	int	disk_line;
X#   endif /* iAPX286 */
X#endif /* SMALL */
X
X#define BACKUPFILES	/* enable the backup files code */
X#define F_COMPLETION	/* filename completion */
X#define ABBREV		/* word abbreviation mode */
X#if !(defined(IBMPC) || defined(MAC))
X#   define ANSICODES	/* extra commands that process ANSI codes */
X#   define ID_CHAR	/* include code to IDchar */
X#   define WIRED_TERMS	/* include code for wired terminals */
X#endif
X#define CHDIR		/* cd command and absolute pathnames */
X#define LISP		/* include the code for Lisp Mode */
X#define CMT_FMT		/* include the comment formatting routines */
X
X#ifdef UNIX
X#   define BIFF		/* if you have biff (or the equivalent) */
X#   define KILL0	/* kill(pid, 0) returns 0 if proc exists */
X#   define SPELL	/* spell words and buffer commands */
X#if !sun && !iAPX286
X#   define MY_MALLOC	/* use more memory efficient malloc (not on suns) */
X#endif
X#endif
X
X#define DFLT_MODE	0666	/* file will be created with this mode */
X
X#ifdef BSD4_3
X#   define RESHAPING	/* enable windows to handle reshaping */
X#endif
X
X#ifdef BSD4_2			/* byte_copy(from, to, len) */
X#   define	byte_copy bcopy	/* use fast assembler version */
X#endif
X
X#ifdef IPROCS
X#   ifdef BSD4_2
X#	define INPUT_SIG	SIGIO
X#   else
X#	define PIPEPROCS		/* do it with pipes */
X#	define INPUT_SIG	SIGTINT
X#   endif
X#endif
X
X#if defined(SYSV) || defined(MSDOS) || defined(M_XENIX)
X#   define byte_copy(s2, s1, n)	memcpy(s1, s2, n)
X#   define bzero(s, n)	memset(s, 0, n)
X#   define index	strchr
X#   define rindex	strrchr
X#endif
X
X#ifdef MAC
X#	undef F_COMPLETION	/* can't do it with spaces in filenames */
X#	undef CHDIR
X#	define CHDIR 1
X#	define rindex strrchr
X#	define index strchr
X#	define bzero(s,n) setmem(s,n,0)
X#	define LINT_ARGS
X#	define NBUF 64
X#	define BUFSIZ 1024
X#endif
X
X/* These are here since they define things in tune.c.  If you add things to
X   tune.c, add them here too, if necessary. */
X
X#ifndef NOEXTERNS
extern char
X	*d_tempfile,
X	*p_tempfile,
X	*Recover,
X	*Joverc,
X
X#ifdef PIPEPROCS
X	*Portsrv,
X#endif
X
X#ifdef MSDOS
X	CmdDb[],
X#else
X	*CmdDb,
X#endif
X
X	TmpFilePath[],
X	Shell[],
X	ShFlags[];
X#endif /* NOEXTERNS */
X
X
END_OF_FILE
if test 4774 -ne `wc -c <'./tune.h'`; then
    echo shar: \"'./tune.h'\" unpacked with wrong size!
fi
# end of './tune.h'
fi
if test -f './vars.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./vars.c'\"
else
echo shar: Extracting \"'./vars.c'\" \(4304 characters\)
sed "s/^X//" >'./vars.c' <<'END_OF_FILE'
X/***************************************************************************
X * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *
X * is provided to you without charge, and with no warranty.  You may give  *
X * away copies of JOVE, including sources, provided that this notice is    *
X * included in all the files.                                              *
X ***************************************************************************/
X
X#ifndef TXT_TO_C	/* so that jove.h isn't included twice in setmaps */
X#include "jove.h"
X#endif
X
struct variable	variables[] = {
X	VARIABLE, "abort-char", &AbortChar, V_CHAR,
X#ifdef UNIX
X	VARIABLE, "allow-^S-and-^Q", &OKXonXoff, V_BOOL|V_TTY_RESET,
X#endif /* UNIX */
X	VARIABLE, "allow-bad-filenames", &OkayBadChars, V_BOOL,
X#ifdef ABBREV
X	VARIABLE, "auto-case-abbrev", &AutoCaseAbbrev, V_BOOL,
X#endif
X#ifdef IBMPC
X	VARIABLE, "background-color", &Bgcolor, V_BASE10|V_CLRSCREEN,
X#endif /* IBMPC */
X#ifdef F_COMPLETION
X	VARIABLE, "bad-filename-extensions", (int *) BadExtensions, V_STRING,
X#endif
X	VARIABLE, "c-indentation-increment", &CIndIncrmt, V_BASE10,
X	VARIABLE, "case-ignore-search", &CaseIgnore, V_BOOL,
X#ifdef CMT_FMT
X 	VARIABLE, "comment-format", (int *) CmtFmt, V_STRING,
X#endif
X#ifdef BIFF
X	VARIABLE, "disable-biff", &BiffChk, V_BOOL,
X#endif
X#ifdef F_COMPLETION
X	VARIABLE, "display-bad-filenames", &DispBadFs, V_BOOL,
X#endif
X#ifndef MAC
X	VARIABLE, "error-format-string", (int *) ErrFmtStr, V_STRING,
X	VARIABLE, "error-window-size", &EWSize, V_BASE10,
X#endif
X	VARIABLE, "expand-environment-variables", &DoEVexpand, V_BOOL,
X	VARIABLE, "file-creation-mode", &CreatMode, V_BASE8,
X	VARIABLE, "files-should-end-with-newline", &EndWNewline, V_BOOL,
X#ifdef IBMPC
X	VARIABLE, "foreground-color", &Fgcolor, V_BASE10|V_CLRSCREEN,
X#endif /* IBMPC */
X	VARIABLE, "internal-tabstop", &tabstop, V_BASE10|V_CLRSCREEN,
X	VARIABLE, "left-margin", &LMargin, V_BASE10,
X#ifdef UNIX
X	VARIABLE, "mailbox", (int *) Mailbox, V_FILENAME,
X	VARIABLE, "mail-check-frequency", (int *) &MailInt, V_BASE10,
X#endif /* UNIX */
X#ifdef MAC
X	VARIABLE, "macify", &Macmode, V_BOOL,
X#endif
X#ifdef BACKUPFILES
X	VARIABLE, "make-backup-files", &BkupOnWrite, V_BOOL,
X#endif
X	VARIABLE, "mark-threshold", &MarkThresh, V_BASE10,
X	VARIABLE, "marks-should-float", &MarksShouldFloat, V_BOOL,
X	VARIABLE, "match-regular-expressions", &UseRE, V_BOOL,
X	VARIABLE, "meta-key", &MetaKey, V_BOOL|V_TTY_RESET,
X	VARIABLE, "mode-line", (int *) ModeFmt, V_STRING|V_MODELINE,
X#ifdef IBMPC
X	VARIABLE, "mode-line-color", &Mdcolor, V_BASE10|V_MODELINE,
X#endif	
X	VARIABLE, "mode-line-should-standout", &BriteMode, V_BOOL|V_MODELINE,
X	VARIABLE, "paren-flash-delay", &PDelay, V_BASE10,
X#ifndef MAC
X	VARIABLE, "physical-tabstop", &phystab, V_BASE10|V_CLRSCREEN,
X#endif
X#ifdef IPROCS
X	VARIABLE, "process-prompt", (int *) proc_prompt, V_STRING,
X#endif
X	VARIABLE, "interrupt-character", &IntChar, V_CHAR|V_TTY_RESET,
X	VARIABLE, "right-margin", &RMargin, V_BASE10,
X	VARIABLE, "scroll-step", &ScrollStep, V_BASE10,
X	VARIABLE, "scroll-all-lines", &ScrollAll, V_BOOL,
X	VARIABLE, "search-exit-char", &SExitChar, V_CHAR,
X	VARIABLE, "send-typeout-to-buffer", &UseBuffers, V_BOOL,
X#ifndef MAC
X	VARIABLE, "shell", (int *) Shell, V_STRING,
X	VARIABLE, "shell-flags", (int *) ShFlags, V_STRING,
X#endif
X#ifndef MSDOS
X	VARIABLE, "sync-frequency", &SyncFreq, V_BASE10,
X#endif /* MSDOS */
X	VARIABLE, "tag-file", (int *) TagFile, V_FILENAME,
X#ifndef MAC
X	VARIABLE, "tmp-file-pathname", (int *) TmpFilePath, V_FILENAME,
X#endif
X#ifdef UNIX
X	VARIABLE, "update-time-frequency", &UpdFreq, V_BASE10,
X#endif /* UNIX */
X#ifdef ID_CHAR
X	VARIABLE, "use-i/d-char", &UseIC, V_BOOL,
X#endif
X	VARIABLE, "visible-bell", &VisBell, V_BOOL,
X	VARIABLE, "wrap-search", &WrapScan, V_BOOL,
X#ifndef MAC
X	VARIABLE, "write-files-on-make", &WtOnMk, V_BOOL,
X#endif
X	VARIABLE, 0, 0, 0
X};
X
X#ifndef TXT_TO_C
data_obj *
findvar(prompt)
char	*prompt;
X{
X	static char	*strings[(sizeof variables) / sizeof (struct variable)];
X	static int	beenhere = 0;
X	register int	com;
X
X	if (beenhere == 0) {
X		register char	**strs = strings;
X		register struct variable	*v = variables;
X
X		beenhere = 1;
X		for (; v->Name; v++)
X			*strs++ = v->Name;
X		*strs = 0;
X	}
X
X	if ((com = complete(strings, prompt, NOTHING)) < 0)
X		return 0;
X	return (data_obj *) &variables[com];
X}
X#endif
END_OF_FILE
if test 4304 -ne `wc -c <'./vars.c'`; then
    echo shar: \"'./vars.c'\" unpacked with wrong size!
fi
# end of './vars.c'
fi
echo shar: End of archive 2 \(of 21\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
