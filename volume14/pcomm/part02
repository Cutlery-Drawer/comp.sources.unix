Subject:  v14i100:  Dial out and terminal emulator, Part02/06
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: fthood!egray@uunet.UU.NET
Posting-number: Volume 14, Issue 100
Archive-name: pcomm/part02

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	Makefile
#	Unixpc.shar
#	dial_dir.h
#	misc.h
#	modem.h
#	param.h
#	status.h
#	xmodem.h
#	admin.c
#	chg_dir.c
#	curses.c
#	d_delete.c
#	d_lib.c
#	d_manual.c
#	d_menu.c
export PATH; PATH=/bin:/usr/bin:$PATH
echo shar: "extracting 'Makefile'" '(3099 characters)'
if test -f 'Makefile'
then
	echo shar: "will not over-write existing file 'Makefile'"
else
sed 's/^X//' << \SHAR_EOF > 'Makefile'
X#				PCOMM
X#			for a generic Unix box
X#
X# valid compile time definitions (CFLAGS) are:
X#
X# OLDCURSES	use termcap (in lieu of terminfo) for curses
X# UNIXPC	use AT&T Unix PC 7300/3b1 specific routines
X# SGID		retore the real group id before doing anything dangerous
X#
X# for systems without getcwd(3) or getopt(3)
X#
X#GETCWD = getcwd.o
X#GETOPT = getopt.o
X
XCC = cc -O
XCFLAGS =
X#CURSES = -lcurses -ltermlib
XCURSES = -lcurses
XLDFLAGS =
XSHAR = shar -a
X
XOBJECTS = $(GETCWD) $(GETOPT) admin.o chg_dir.o curses.o d_delete.o d_lib.o \
X	d_manual.o d_menu.o d_print.o d_prompt.o d_revise.o data_log.o \
X	di_delay.o di_win.o dial.o expand.o help.o info.o init.o input.o \
X	line_set.o list_dir.o ls_menu.o m_lib.o main.o n_shell.o p_lib.o \
X	pexit.o port.o redial.o s_axfer.o s_gen.o s_menu.o s_modem.o \
X	s_prompt.o s_term.o s_tty.o screen.o st_line.o strings.o terminal.o \
X	x_ascii.o x_batch.o x_menu.o x_rcv.o x_send.o x_win.o xmodem.o
X
Xpcomm:	$(OBJECTS)
X	$(CC) $(LDFLAGS) $(OBJECTS) -o pcomm $(CURSES)
X
Xlint:
X	lint $(CFLAGS) *.c
X
Xshar:
X	$(SHAR) Readme Release.notes Doc Pcomm.1 Pcomm.dial_dir Pcomm.modem \
X	Pcomm.param > pcomm_sh.1
X	$(SHAR) Makefile dial_dir.h misc.h modem.h param.h status.h xmodem.h \
X	admin.c chg_dir.c curses.c d_delete.c d_lib.c d_manual.c d_menu.c \
X	d_print.c > pcomm_sh.2
X	$(SHAR) d_prompt.c d_revise.c data_log.c di_delay.c di_win.c dial.c \
X	expand.c getcwd.c getopt.c help.c info.c init.c input.c > pcomm_sh.3
X	$(SHAR) line_set.c list_dir.c ls_menu.c m_lib.c main.c n_shell.c \
X	p_lib.c pexit.c port.c redial.c s_axfer.c s_gen.c > pcomm_sh.4
X	$(SHAR) s_menu.c s_modem.c s_prompt.c s_term.c s_tty.c screen.c \
X	st_line.c strings.c terminal.c x_ascii.c x_batch.c > pcomm_sh.5
X	$(SHAR) x_menu.c x_rcv.c x_send.c x_win.c xmodem.c > pcomm_sh.6
X
Xadmin.o:	dial_dir.h param.h
Xchg_dir.o:	misc.h
Xcurses.o:	misc.h
Xd_delete.o:	dial_dir.h misc.h param.h
Xd_lib.o:	dial_dir.h param.h status.h
Xd_manual.o:	dial_dir.h
Xd_menu.o:	dial_dir.h misc.h param.h
Xd_print.o:	dial_dir.h misc.h
Xd_prompt.o:	dial_dir.h misc.h
Xd_revise.o:	dial_dir.h misc.h param.h
Xdata_log.o:	misc.h param.h status.h
Xdi_delay.o:	misc.h param.h
Xdi_win.o:	dial_dir.h misc.h modem.h param.h status.h
Xdial.o:		dial_dir.h modem.h param.h status.h
Xhelp.o:		misc.h
Xinit.o:		misc.h status.h
Xline_set.o:	dial_dir.h param.h status.h
Xlist_dir.o:	misc.h
Xls_menu.o:	dial_dir.h misc.h param.h
Xm_lib.o:	modem.h status.h
Xmain.o:		dial_dir.h modem.h param.h status.h
Xp_lib.o:	param.h status.h
Xpexit.o:	dial_dir.h misc.h param.h status.h
Xport.o:		dial_dir.h modem.h status.h
Xredial.o:	dial_dir.h misc.h
Xs_axfer.o:	misc.h param.h
Xs_gen.o:	misc.h param.h
Xs_menu.o:	misc.h
Xs_modem.o:	misc.h modem.h
Xs_prompt.o:	misc.h
Xs_term.o:	misc.h param.h
Xs_tty.o:	misc.h modem.h status.h
Xscreen.o:	param.h status.h
Xst_line.o:	dial_dir.h misc.h modem.h param.h status.h
Xterminal.o:	dial_dir.h modem.h param.h status.h
Xx_ascii.o:	param.h status.h
Xx_batch.o:	misc.h xmodem.h
Xx_menu.o:	misc.h xmodem.h
Xx_rcv.o:	dial_dir.h misc.h xmodem.h
Xx_send.o:	dial_dir.h misc.h status.h xmodem.h
Xx_win.o:	dial_dir.h misc.h status.h xmodem.h
Xxmodem.o:	param.h status.h xmodem.h
SHAR_EOF
if test 3099 -ne "`wc -c < 'Makefile'`"
then
	echo shar: "error transmitting 'Makefile'" '(should have been 3099 characters)'
fi
fi
echo shar: "extracting 'Unixpc.shar'" '(8328 characters)'
if test -f 'Unixpc.shar'
then
	echo shar: "will not over-write existing file 'Unixpc.shar'"
else
sed 's/^X//' << \SHAR_EOF > 'Unixpc.shar'
X#! /bin/sh
X# This is a shell archive, meaning:
X# 1. Remove everything above the #! /bin/sh line.
X# 2. Save the resulting text in a file.
X# 3. Execute the file with /bin/sh (not csh) to create:
X#	Dial_codes
X#	Ifile.sh
X#	Makefile
X#	Pcomm.modem
X# This archive created: Sun Mar 27 10:35:36 1988
Xexport PATH; PATH=/bin:/usr/bin:$PATH
Xecho shar: "extracting 'Dial_codes'" '(2193 characters)'
Xif test -f 'Dial_codes'
Xthen
X	echo shar: "will not over-write existing file 'Dial_codes'"
Xelse
Xsed 's/^X//' << \SHAR_EOF > 'Dial_codes'
XX				  PCOMM v1.0
XX
XX			      AT&T Unix PC 7300
XX				Dialing Codes
XX
XX	The dialing codes used by the OBM (On Board Modem) are not straight-
XX	forward.  The modem setup, as distributed, looks like this:
XX
XX	-------------------------- Modem Setup --------------------------
XX
XX		1) Modem name ............. OBM
XX
XX		2) Modem init string ......
XX		3) Dialing command ........ %
XX		4) Dialing cmd suffix ..... @
XX		5) Hangup string ..........
XX		6) 300 baud connect ....... CONNECT
XX		7) 1200 baud connect ...... CONNECT
XX		8) 2400 baud connect ......
XX		9) 4800 baud connect ......
XX		10) 9600 baud connect .....
XX		11) 19200 baud connect ....
XX		12) No connect string 1 ...
XX		13) No connect string 2 ...
XX		14) No connect string 3 ...
XX		15) No connect string 4 ...
XX
XX	---------------------------------------------------------------
XX	OPTION ==> _				    Press ESC to return
XX
XX	The relevant fields of the modem setup are:
XX
XX		1) Modem name.  This must be "OBM".
XX
XX	NOTE: Pcomm uses the modem name as a flag to determine which dialing
XX	method to use.  The string "OBM" is a "reserved word" that pcomm uses
XX	to switch to the AT&T 7300 Unix PC dialing method.
XX
XX		3) Dialing command.  This should be '%' for touch tone
XX		dialing or '^' for pulse dialing. 
XX
XX		4) Dialing cmd suffix.  This must be the '@' character.
XX
XX		6-7) Connect strings.  The 300 and 1200 baud connect
XX		strings must both be set to "CONNECT".
XX
XX	NOTE: The OBM cannot determine the connected baud rate if it's 
XX	different from what it expects.  The two identical connect strings
XX	disable this feature.
XX
XX
XX	Additional OBM dialing commands from phone(7):
XX
XX		'~'	wait for next dial tone
XX		','	pause 2 seconds
XX		':'	pause 10 seconds
XX		'&'	perform a hookflash
XX		'%'	begin tone dialing
XX		'^'	begin pulse dialing
XX
XX	These commands can be inserted into the phone number string, for
XX	example:
XX		
XX		555-1234~56	dial 555-1234, wait for dial tone, dial 56
XX		9,555-1234	dial 9, wait 2 seconds, dial 555-1234
XX		%555^1234	dial 555 using tone, dial 1234 using pulse
XX
XX	NOTE: The dialing commands for the OBM are not subject to character
XX	synonym translations, therefore the '^' and '~' characters do NOT
XX	have to be preceded by the '\' character to remove their special
XX	meaning.
XSHAR_EOF
Xif test 2193 -ne "`wc -c < 'Dial_codes'`"
Xthen
X	echo shar: "error transmitting 'Dial_codes'" '(should have been 2193 characters)'
Xfi
Xfi
Xecho shar: "extracting 'Ifile.sh'" '(705 characters)'
Xif test -f 'Ifile.sh'
Xthen
X	echo shar: "will not over-write existing file 'Ifile.sh'"
Xelse
Xsed 's/^X//' << \SHAR_EOF > 'Ifile.sh'
XXex - $1 << EOF
XX1,\$s/^PC/xPC/
XX1,\$s/^BC/xBC/
XX1,\$s/^UP/xUP/
XX1,\$s/^ospeed/xospeed/
XX1,\$s/^LINES/xLINES/
XX1,\$s/^COLS/xCOLS/
XX1,\$s/^tgetflag/xtgetflag/
XX1,\$s/^tgetent/xtgetent/
XX1,\$s/^tgetstr/xtgetstr/
XX1,\$s/^tgetnum/xtgetnum/
XX1,\$s/^tgoto/xtgoto/
XX1,\$s/^tputs/xtputs/
XX1,\$s/^wrefresh/xwrefresh/
XX1,\$s/^initscr/xinitscr/
XX1,\$s/^cbreak/xcbreak/
XX1,\$s/^nl/xnl/
XX1,\$s/^flushinp/xflushinp/
XX1,\$s/^noecho/xnoecho/
XX1,\$s/^savetty/xsavetty/
XX1,\$s/^resetty/xresetty/
XX1,\$s/^echo/xecho/
XX1,\$s/^nocbreak/xnocbreak/
XX1,\$s/^nonl/xnonl/
XX1,\$s/^keypad/xkeypad/
XX1,\$s/^endwin/xendwin/
XX1,\$s/^printw/xprintw/
XX1,\$s/^fixterm/xfixterm/
XX1,\$s/^resetterm/xresetterm/
XX1,\$s/^setterm/xsetterm/
XX1,\$s/^baudrate/xbaudrate/
XXw
XXq
XXEOF
XSHAR_EOF
Xif test 705 -ne "`wc -c < 'Ifile.sh'`"
Xthen
X	echo shar: "error transmitting 'Ifile.sh'" '(should have been 705 characters)'
Xfi
Xfi
Xecho shar: "extracting 'Makefile'" '(3372 characters)'
Xif test -f 'Makefile'
Xthen
X	echo shar: "will not over-write existing file 'Makefile'"
Xelse
Xsed 's/^X//' << \SHAR_EOF > 'Makefile'
XX#				Pcomm
XX#			for AT&T Unix PC 7300/3b1
XX#
XX# valid compile time definitions (CFLAGS) are:
XX#
XX# OLDCURSES	use termcap (in lieu of terminfo) for curses
XX# UNIXPC	use AT&T Unix PC 7300/3b1 specific routines
XX# SGID		retore the real group id before doing anything dangerous
XX#
XX# for systems without getcwd(3) or getopt(3)
XX#
XX#GETCWD = getcwd.o
XX#GETOPT = getopt.o
XX
XXCC = cc -O
XXCFLAGS = -DUNIXPC
XXCURSES = -lcurses
XXLD = ld -s
XXSHAR = shar -a
XXSTARTUP = /lib/crt0s.o
XXSHAREDLIB = shlib_c.ifile
XX
XXOBJECTS = $(GETCWD) $(GETOPT) admin.o chg_dir.o curses.o d_delete.o d_lib.o \
XX	d_manual.o d_menu.o d_print.o d_prompt.o d_revise.o data_log.o \
XX	di_delay.o di_win.o dial.o expand.o help.o info.o init.o input.o \
XX	line_set.o list_dir.o ls_menu.o m_lib.o main.o n_shell.o p_lib.o \
XX	pexit.o port.o redial.o s_axfer.o s_gen.o s_menu.o s_modem.o \
XX	s_prompt.o s_term.o s_tty.o screen.o st_line.o strings.o terminal.o \
XX	x_ascii.o x_batch.o x_menu.o x_rcv.o x_send.o x_win.o xmodem.o
XX
XXOTHERS = setvbuf.o doprnt.o
XX
XXpcomm:	$(OBJECTS) $(OTHERS) $(SHAREDLIB)
XX	$(LD) $(OBJECTS) $(OTHERS) $(CURSES) $(STARTUP) $(SHAREDLIB) -o pcomm
XX
XXlint:
XX	lint $(CFLAGS) *.c
XX
XXshar:
XX	$(SHAR) Readme Release.notes Doc Pcomm.1 Pcomm.dial_dir Pcomm.modem \
XX	Pcomm.param Ifile.sh > pcomm_sh.1
XX	$(SHAR) Makefile dial_dir.h misc.h modem.h param.h status.h xmodem.h \
XX	admin.c chg_dir.c curses.c d_delete.c d_lib.c d_manual.c d_menu.c \
XX	d_print.c > pcomm_sh.2
XX	$(SHAR) d_prompt.c d_revise.c data_log.c di_delay.c di_win.c dial.c \
XX	expand.c getcwd.c getopt.c help.c info.c init.c input.c > pcomm_sh.3
XX	$(SHAR) line_set.c list_dir.c ls_menu.c m_lib.c main.c n_shell.c \
XX	p_lib.c pexit.c port.c redial.c s_axfer.c s_gen.c > pcomm_sh.4
XX	$(SHAR) s_menu.c s_modem.c s_prompt.c s_term.c s_tty.c screen.c \
XX	st_line.c strings.c terminal.c x_ascii.c x_batch.c > pcomm_sh.5
XX	$(SHAR) x_menu.c x_rcv.c x_send.c x_win.c xmodem.c > pcomm_sh.6
XX
XXsetvbuf.o:
XX	ar x /lib/libc.a setvbuf.o
XX
XXdoprnt.o:
XX	ar x /lib/libc.a doprnt.o
XX
XXshlib_c.ifile:
XX	cp /lib/shlib.ifile shlib_c.ifile
XX	sh Ifile.sh shlib_c.ifile
XX
XXadmin.o:	dial_dir.h param.h
XXchg_dir.o:	misc.h
XXcurses.o:	misc.h
XXd_delete.o:	dial_dir.h misc.h param.h
XXd_lib.o:	dial_dir.h param.h status.h
XXd_manual.o:	dial_dir.h
XXd_menu.o:	dial_dir.h misc.h param.h
XXd_print.o:	dial_dir.h misc.h
XXd_prompt.o:	dial_dir.h misc.h
XXd_revise.o:	dial_dir.h misc.h param.h
XXdata_log.o:	misc.h param.h status.h
XXdi_delay.o:	misc.h param.h
XXdi_win.o:	dial_dir.h misc.h modem.h param.h status.h
XXdial.o:		dial_dir.h modem.h param.h status.h
XXhelp.o:		misc.h
XXinit.o:		misc.h status.h
XXline_set.o:	dial_dir.h param.h status.h
XXlist_dir.o:	misc.h
XXls_menu.o:	dial_dir.h misc.h param.h
XXm_lib.o:	modem.h status.h
XXmain.o:		dial_dir.h modem.h param.h status.h
XXp_lib.o:	param.h status.h
XXpexit.o:	dial_dir.h misc.h param.h status.h
XXport.o:		dial_dir.h modem.h status.h
XXredial.o:	dial_dir.h misc.h
XXs_axfer.o:	misc.h param.h
XXs_gen.o:	misc.h param.h
XXs_menu.o:	misc.h
XXs_modem.o:	misc.h modem.h
XXs_prompt.o:	misc.h
XXs_term.o:	misc.h param.h
XXs_tty.o:	misc.h modem.h status.h
XXscreen.o:	param.h status.h
XXst_line.o:	dial_dir.h misc.h modem.h param.h status.h
XXterminal.o:	dial_dir.h modem.h param.h status.h
XXx_ascii.o:	param.h status.h
XXx_batch.o:	misc.h xmodem.h
XXx_menu.o:	misc.h xmodem.h
XXx_rcv.o:	dial_dir.h misc.h xmodem.h
XXx_send.o:	dial_dir.h misc.h status.h xmodem.h
XXx_win.o:	dial_dir.h misc.h status.h xmodem.h
XXxmodem.o:	param.h status.h xmodem.h
XSHAR_EOF
Xif test 3372 -ne "`wc -c < 'Makefile'`"
Xthen
X	echo shar: "error transmitting 'Makefile'" '(should have been 3372 characters)'
Xfi
Xfi
Xecho shar: "extracting 'Pcomm.modem'" '(154 characters)'
Xif test -f 'Pcomm.modem'
Xthen
X	echo shar: "will not over-write existing file 'Pcomm.modem'"
Xelse
Xsed 's/^X//' << \SHAR_EOF > 'Pcomm.modem'
XXTTY_1=ph1;OBM;1200
XXTTY_2=tty000;DIRECT;19200
XXMODEM_1a=OBM;;%;@;
XXMODEM_1b=CONNECT;CONNECT;;;;
XXMODEM_1c=;;;
XXMODEM_2a=DIRECT;;;;
XXMODEM_2b=;;;;;
XXMODEM_2c=;;;
XSHAR_EOF
Xif test 154 -ne "`wc -c < 'Pcomm.modem'`"
Xthen
X	echo shar: "error transmitting 'Pcomm.modem'" '(should have been 154 characters)'
Xfi
Xfi
Xexit 0
X#	End of shell archive
SHAR_EOF
if test 8328 -ne "`wc -c < 'Unixpc.shar'`"
then
	echo shar: "error transmitting 'Unixpc.shar'" '(should have been 8328 characters)'
fi
fi
echo shar: "extracting 'dial_dir.h'" '(815 characters)'
if test -f 'dial_dir.h'
then
	echo shar: "will not over-write existing file 'dial_dir.h'"
else
sed 's/^X//' << \SHAR_EOF > 'dial_dir.h'
X/*
X * The dialing directory structure.  The first eight elements are
X * contained in the pcomm.dial_dir file.
X */
X
X#define NUM_DIR		100
X#define NUM_QUEUE	10
X
Xstruct DIAL_DIR {
X	char	*name[NUM_DIR+1];	/* name of system being called */
X	char	*number[NUM_DIR+1];	/* phone number */
X	int	baud[NUM_DIR+1];	/* baud rate */
X	char	parity[NUM_DIR+1];	/* parity */
X	int	dbits[NUM_DIR+1];	/* data bits */
X	int	sbits[NUM_DIR+1];	/* stop bits */
X	char	duplex[NUM_DIR+1];	/* duplex (F = full, H = half) */
X	char 	*index[NUM_DIR+1];	/* command line index (or tty) */
X
X	int	d_entries;		/* number of entries in the file */
X	int	d_cur;			/* the current entry */
X	int	q_num[NUM_QUEUE];	/* entry numbers in the queue */
X	char	q_ld[NUM_QUEUE];	/* LD codes in the queue */
X};
X
X#ifndef MAIN
Xextern struct DIAL_DIR *dir;
X#endif /* MAIN */
SHAR_EOF
if test 815 -ne "`wc -c < 'dial_dir.h'`"
then
	echo shar: "error transmitting 'dial_dir.h'" '(should have been 815 characters)'
fi
fi
echo shar: "extracting 'misc.h'" '(1031 characters)'
if test -f 'misc.h'
then
	echo shar: "will not over-write existing file 'misc.h'"
else
sed 's/^X//' << \SHAR_EOF > 'misc.h'
X/*
X * Definitions to support the home-grown curses functions and to make the
X * old curses routines happy
X */
X
X#define NOPROMOTE
X
X#define mvwattrstr(w,y,x,a,s)	(wmove(w,y,x)==ERR?ERR:wattrstr(w,a,s))
X#define mvwattrch(w,y,x,a,c)	(wmove(w,y,x)==ERR?ERR:wattrch(w,a,c))
X#define mvwattrnum(w,y,x,a,n)	(wmove(w,y,x)==ERR?ERR:wattrnum(w,a,n))
X#define mvattrstr(y,x,a,s)	(wmove(stdscr,y,x)==ERR?ERR:wattrstr(stdscr,a,s))
X#define mvattrch(y,x,a,c)	(wmove(stdscr,y,x)==ERR?ERR:wattrch(stdscr,a,c))
X#define mvattrnum(y,x,a,n)	(wmove(stdscr,y,x)==ERR?ERR:wattrnum(stdscr,a,n))
X#define attrstr(a,s)		wattrstr(stdscr,a,s)
X#define attrch(a,c)		wattrch(stdscr,a,c)
X#define attrnum(a,n)		wattrnum(stdscr,a,n)
X
X#ifdef OLDCURSES
X#ifdef NOPROMOTE
X#define A_BOLD		0
X#define A_BLINK		0
X#define A_REVERSE	1
X#define A_DIM		0
X#define A_STANDOUT	1
X#define A_UNDERLINE	0
X#else /* NOPROMOTE */
X#define A_BOLD		1
X#define A_BLINK		1
X#define A_REVERSE	1
X#define A_DIM		1
X#define A_STANDOUT	1
X#define A_UNDERLINE	1
X#endif /* NOPROMOTE */
X#endif /* OLDCURSES */
SHAR_EOF
if test 1031 -ne "`wc -c < 'misc.h'`"
then
	echo shar: "error transmitting 'misc.h'" '(should have been 1031 characters)'
fi
fi
echo shar: "extracting 'modem.h'" '(1417 characters)'
if test -f 'modem.h'
then
	echo shar: "will not over-write existing file 'modem.h'"
else
sed 's/^X//' << \SHAR_EOF > 'modem.h'
X/*
X * The modem and tty databases.  The first 3 elements make up the tty
X * database, the next 15 make up the modem database.  A "tname" in common
X * with a "mname" link the two together.
X */
X
X#define NUM_TTY		10
X#define NUM_MODEM	10
X
Xstruct MODEM {
X	char 	*tty[NUM_TTY];		/* tty names */
X	char	*tname[NUM_TTY];	/* modem name */
X	int	mbaud[NUM_TTY];		/* maximum baud rate */
X
X	char	*mname[NUM_MODEM];	/* modem name (matches tname above) */
X	char	*init[NUM_MODEM];	/* initialization */
X	char	*dial[NUM_MODEM];	/* dial command */
X	char	*suffix[NUM_MODEM];	/* dialing command suffix */
X	char	*hangup[NUM_MODEM];	/* hang up the modem */
X	char	*con_3[NUM_MODEM];	/* 300 baud connect message */
X	char	*con_12[NUM_MODEM];	/* 1200 baud connect message */
X	char	*con_24[NUM_MODEM];	/* 2400 baud connect message */
X	char	*con_48[NUM_MODEM];	/* 4800 baud connect message */
X	char	*con_96[NUM_MODEM];	/* 9600 baud connect message */
X	char	*con_192[NUM_MODEM];	/* 19200 baud connect message */
X	char	*no_con1[NUM_MODEM];	/* no connect #1 */
X	char	*no_con2[NUM_MODEM];	/* no connect #2 */
X	char	*no_con3[NUM_MODEM];	/* no connect #3 */
X	char	*no_con4[NUM_MODEM];	/* no connect #4 */
X
X	int	t_entries;		/* number of tty entries */
X	int	m_entries;		/* number of modem entries */
X	int	t_cur;			/* current tty entry number */
X	int	m_cur;			/* current modem entry number */
X};
X
X#ifndef MAIN
Xextern struct MODEM *modem;
X#endif /* MAIN */
SHAR_EOF
if test 1417 -ne "`wc -c < 'modem.h'`"
then
	echo shar: "error transmitting 'modem.h'" '(should have been 1417 characters)'
fi
fi
echo shar: "extracting 'param.h'" '(2262 characters)'
if test -f 'param.h'
then
	echo shar: "will not over-write existing file 'param.h'"
else
sed 's/^X//' << \SHAR_EOF > 'param.h'
X/*
X * The standard pcomm parameters.  Everything can be altered by using one
X * of pcomm's menus.  Although editing by hand is not encouraged, the
X * pcomm.param file is just an ASCII file.
X */
X
X#define MAX_CDELAY	120
X#define MIN_CDELAY	10
X#define MAX_PAUSE	120
X#define MIN_PAUSE	1
X#define MAX_TIMER	20
X#define MIN_TIMER	2
X
X#define NUM_PARAM	33
X#define LINE_SET	0
X#define TERM_SETUP	4
X#define GEN_SETUP	10
X#define DELAY_TIMES	18
X#define ASCII_SETUP	20
X#define LD_CODES	29
X
Xstruct PARAM {
X				/* 0-3 used in line_set_menu() */
X	int	d_baud;			/* default baud rate */
X	char	d_parity;		/* default parity */
X	int	d_dbits;		/* default data bits */
X	int 	d_sbits;		/* default stop bits */
X
X				/* 4-9 used in term_setup() */
X	int	hot;			/* the decimal code for the hot key */
X	char 	*ascii_hot;		/* ascii representation of hot key */
X	char 	*d_duplex;		/* default duplex */
X	char	*flow;			/* flow control */
X	char	*cr_in;			/* send as carriage return */
X	char	*cr_out;		/* receive carriage return as */
X
X				/* 10-17 used in gen_setup() */
X	char	*logfile;		/* default log file */
X	char	*dumpfile;		/* default screen dump file */
X	char	*strip;			/* strip high bit (translate table) */
X	char	pause_char;		/* pause char synonym */
X	char 	cr_char;		/* carriage return char synonym */
X	char 	ctrl_char;		/* ctrl char synonym */
X	char 	esc_char;		/* escape char synonym */
X	char 	*abort;			/* destination of aborted downloads */
X
X				/* 18-19 used in gen_setup() & delay_times() */
X	int	cdelay;			/* connect delay time */
X	int	pause;			/* pause between dialing attempts */
X
X				/* 20-27 used in ascii_xfer_setup() */
X	char	*lecho;			/* echo locally ? */
X	char	*expand;		/* expand blank lines? */
X	int	cr_delay;		/* carriage return delay (ms) */
X	char	*pace;			/* pace the output ? */
X	char	*cr_up;			/* send carriage return as */
X	char	*lf_up;			/* send line feed as */
X	int	timer;			/* Transfer timeout */
X	char	*cr_dn;			/* receive carriage return as */
X	char	*lf_dn;			/* receive line feed as */
X
X				/* 28-31 used in d_revise() */
X	char	*ld_plus;		/* + long distance code */
X	char	*ld_minus;		/* - long distance code */
X	char	*ld_at;			/* @ long distance code */
X	char	*ld_pound;		/* # long distance code */
X};
X
X#ifndef MAIN
Xextern struct PARAM *param;
X#endif /* MAIN */
SHAR_EOF
if test 2262 -ne "`wc -c < 'param.h'`"
then
	echo shar: "error transmitting 'param.h'" '(should have been 2262 characters)'
fi
fi
echo shar: "extracting 'status.h'" '(631 characters)'
if test -f 'status.h'
then
	echo shar: "will not over-write existing file 'status.h'"
else
sed 's/^X//' << \SHAR_EOF > 'status.h'
X/*
X * The location of the support files, status flags, and other various
X * changeable things.
X */
X
Xstruct STATUS {
X	char	*p_path;		/* pcomm.param file */
X	char	*d_path;		/* pcomm.dial_dir file */
X	char	*m_path;		/* pcomm.modem file */
X	char	*lock_path;		/* UUCP lock file */
X	char	*vs_path;		/* virtual screen file */
X	char	*log_path;		/* data logging file */
X	int	fd;			/* file descriptor for tty */
X	int	log;			/* status of log option */
X	int	print;			/* status of print option */
X	int	msg;			/* the 'msg' status */
X	int	pid;			/* the pid of the child process */
X};
X
X#ifndef MAIN
Xextern struct STATUS *status;
X#endif /* MAIN */
SHAR_EOF
if test 631 -ne "`wc -c < 'status.h'`"
then
	echo shar: "error transmitting 'status.h'" '(should have been 631 characters)'
fi
fi
echo shar: "extracting 'xmodem.h'" '(373 characters)'
if test -f 'xmodem.h'
then
	echo shar: "will not over-write existing file 'xmodem.h'"
else
sed 's/^X//' << \SHAR_EOF > 'xmodem.h'
X/*
X * Definitions for the xmodem stuff.
X */
X
X#define MAX_ERRORS 	10
X
X#define SOH		1
X#define STX		2
X#define EOT		4
X#define ACK		6
X#define NAK		21
X#define CAN		24
X#define CTRLZ		26
X
X#define PROTOCOLS	6
X#define XMODEM		0
X#define XMODEM_1k	1
X#define MODEM7		2
X#define YMODEM		3
X#define YMODEM_G	4
X#define XASCII		5
X
X#define ABORT		(-1)
X#define ERROR		(-2)
X#define CANCEL		(-3)
SHAR_EOF
if test 373 -ne "`wc -c < 'xmodem.h'`"
then
	echo shar: "error transmitting 'xmodem.h'" '(should have been 373 characters)'
fi
fi
echo shar: "extracting 'admin.c'" '(2871 characters)'
if test -f 'admin.c'
then
	echo shar: "will not over-write existing file 'admin.c'"
else
sed 's/^X//' << \SHAR_EOF > 'admin.c'
X/*
X * Perform administrative functions.  Check to see if the user has
X * permission to make long distance calls, and record all phone calls
X * made by pcomm.
X */
X
X#undef LOG_CALLS
X#undef LIMIT_LD
X
X#define LOGFILE "/usr/adm/phone.calls"
X#define GRPNAME "uucp"
X
X#include <stdio.h>
X#include <grp.h>
X#include "dial_dir.h"
X#include "param.h"
X
X/*
X * Make a log of all calls made by pcomm.  The argument is the index
X * into the queue.
X */
X
Xint
Xlog_calls(i)
Xint i;
X{
X#ifdef LOG_CALLS
X	FILE *fp;
X	char *number, *build_num(), *date, *ctime(), *getlogin();
X	long now, time();
X	void error_win();
X					/* build the complete phone number */
X	number = build_num(i);
X					/* build date and time */
X	time(&now);
X	date = ctime(&now);
X	date[10] = NULL;
X	date[16] = NULL;
X
X	if (!(fp = fopen(LOGFILE, "a+")))
X		error_win(1, "Can't open phone log file", "Contact your system administrator");
X
X	fprintf(fp, "pcomm: %s called %s at %s on %s\n", getlogin(), number, &date[11], date);
X	fclose(fp);
X#endif /* LOG_CALLS */
X	return (0);
X}
X
X/*
X * Check to see if long distance (toll) call is authorized.  The argument
X * is the index into the queue.
X */
X
Xint
Xlimit_ld(i)
Xint i;
X{
X#ifdef LIMIT_LD
X	char *number, *build_num(), *name, *getlogin();
X	struct group *getgrnam(), *grpbuf;
X
X					/* if no group, don't bother */
X	grpbuf = getgrnam(GRPNAME);
X	if (!grpbuf || !*grpbuf->gr_mem)
X		return(0);
X					/* are you in the group? */
X	name = getlogin();
X	for (; *grpbuf->gr_mem != NULL; grpbuf->gr_mem++) {
X		if (!strcmp(*grpbuf->gr_mem, name))
X			return(0);
X	}
X					/* numbers only... */
X	number = build_num(i);
X
X	/*
X	 * Very site specific!!!  We use a '9' to get an outside line,
X	 * so any 9 followed by a 1 is a toll call (except for 1-800
X	 * numbers).
X	 */
X	if (!strncmp(number, "91", 2) && strncmp(number, "91800", 5)) {
X		error_win(0, "You are not authorized to place long distance \(toll\) calls", NULL);
X		return(1);
X	}
X
X	if (*number == NULL) {
X		error_win(0, "You are not authorized direct access to the line", "Use the automatic dialing feature");
X		return(1);
X	}
X#endif /* LIMIT_LD */
X	return(0);
X}
X
X#ifdef LOG_CALLS || LIMIT_LD
X/*
X * Put together the complete phone number but strip out the extraneous
X * characters.
X */
X
Xchar *
Xbuild_num(i)
Xint i;
X{
X	int j;
X	char *t, temp[40], *strcpy(), *strcat();
X	static char ans[40];
X
X	temp[0] = NULL;
X					/* add LD codes ? */
X	switch (dir->q_ld[i]) {
X		case 0:
X			break;
X		case '+':
X			strcpy(temp, param->ld_plus);
X			break;
X		case '-':
X			strcpy(temp, param->ld_minus);
X			break;
X		case '@':
X			strcpy(temp, param->ld_at);
X			break;
X		case '#':
X			strcpy(temp, param->ld_pound);
X			break;
X	}
X					/* add the number */
X	strcat(temp, dir->number[dir->q_num[i]]);
X
X					/* copy only digits */
X	j = 0;
X	t = temp;
X	while (*t) {
X		if (*t >= '0' && *t <= '9')
X			ans[j++] = *t;
X		t++;
X	}
X	ans[j] = NULL;
X
X	return(ans);
X}
X#endif /* LOG_CALLS || LIMIT_LD */
SHAR_EOF
if test 2871 -ne "`wc -c < 'admin.c'`"
then
	echo shar: "error transmitting 'admin.c'" '(should have been 2871 characters)'
fi
fi
echo shar: "extracting 'chg_dir.c'" '(1363 characters)'
if test -f 'chg_dir.c'
then
	echo shar: "will not over-write existing file 'chg_dir.c'"
else
sed 's/^X//' << \SHAR_EOF > 'chg_dir.c'
X/*
X * Open a window to prompt for a new directory.  Checks to see if the
X * directory exists, but doesn't move to there (yet).  Returns the path
X * to the new directory, or NULL if you chickened out.
X */
X
X#include <curses.h>
X#include "misc.h"
X
Xchar *
Xchange_dir(fd)
Xint fd;
X{
X	WINDOW *ch_win, *newwin();
X	int got_it;
X	char *ans, *dir, *expand(), *cwd, *getcwd(), cwdbuf[200];
X	char *get_str();
X	void free_ptr();
X
X	cwd = getcwd(cwdbuf, 200);
X
X	ch_win = newwin(6, 70, 5, 5);
X
X	mvwprintw(ch_win, 2, 4, "Current directory: %s", cwd);
X	mvwaddstr(ch_win, 3, 4, "New directory: ");
X	box(ch_win, '|', '-');
X
X	mvwattrstr(ch_win, 0, 3, A_BOLD, " Change directory ");
X	wmove(ch_win, 3, 19);
X	wrefresh(ch_win);
X					/* get the answer */
X	got_it = 0;
X	while ((ans = get_str(ch_win, 60, NULL, " 	")) != NULL) {
X		if (*ans == NULL)
X			break;
X					/* expand the input */
X		dir = expand(ans);
X					/* if it exists */
X		if (!access(dir, 1)) {
X			got_it++;
X			break;
X		}
X		beep();
X		mvwattrstr(ch_win, 4, 15, A_BOLD, "No such directory or no access permission");
X		wrefresh(ch_win);
X		wait_key(ch_win, 3);
X					/* cleanup the mess */
X		clear_line(ch_win, 3, 19, 1);
X		clear_line(ch_win, 4, 14, 1);
X		wmove(ch_win, 3, 19);
X		wrefresh(ch_win);
X		free_ptr(dir);
X	}
X	if (fd == -1) {
X		werase(ch_win);
X		wrefresh(ch_win);
X	}
X	delwin(ch_win);
X	if (got_it)
X		return(dir);
X	return(NULL);
X}
SHAR_EOF
if test 1363 -ne "`wc -c < 'chg_dir.c'`"
then
	echo shar: "error transmitting 'chg_dir.c'" '(should have been 1363 characters)'
fi
fi
echo shar: "extracting 'curses.c'" '(7649 characters)'
if test -f 'curses.c'
then
	echo shar: "will not over-write existing file 'curses.c'"
else
sed 's/^X//' << \SHAR_EOF > 'curses.c'
X/*
X * Miscellaneous curses routines.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include <signal.h>
X#include <setjmp.h>
X#ifdef OLDCURSES
X#include <fcntl.h>
X#else /* OLDCURSES */
X#include <term.h>
X#endif /* OLDCURSES */
X#include "misc.h"
X
X/*
X * Get a string from a window.  Similar to wgetstr(), except we limit
X * the length, return a NULL (not pointer to NULL) on ESC key, beep
X * at any character in 'disallow' string, and beep at any character not
X * in 'allow'. (It doesn't make sense to use both 'allow' and 'disallow'
X * at the same time)
X */
X
Xchar *
Xget_str(win, num, allow, disallow)
XWINDOW *win;
Xint num;
Xchar *allow, *disallow;
X{
X	int count, x, y;
X	char ans, *strchr();
X	static char buf[80];
X
X	count = 0;
X	while ((ans = wgetch(win)) != '\r') {
X					/* do our own backspace */
X		if (ans == 8) {
X			if (!count) {
X				beep();
X				continue;
X			}
X			count--;
X			buf[count] = NULL;
X			getyx(win, y, x);
X			x--;
X			wmove(win, y, x);
X			waddch(win, ' ');
X			wmove(win, y, x);
X			wrefresh(win);
X			continue;
X		}
X					/* an ESC anywhere in the string */
X		if (ans == 27)
X			return(NULL);
X
X					/* illegal character ? */
X		if (disallow != NULL && strchr(disallow, ans)) {
X			beep();
X			continue;
X		}
X		if (allow != NULL && !strchr(allow, ans)) {
X			beep();
X			continue;
X		}
X					/* exceeded the max ? */
X		if (count == num) {
X			beep();
X			continue;
X		}
X
X		buf[count] = ans;
X		waddch(win, ans);
X		wrefresh(win);
X		count++;
X	}
X	buf[count] = NULL;
X	return(buf);
X}
X
X/*
X * Get a number from a window.  We limit the length and return a -1
X * on ESC key.
X */
X
Xint
Xget_num(win, num)
XWINDOW *win;
Xint num;
X{
X	int count, x, y, number;
X	char ans, buf[80];
X
X	count = 0;
X	while ((ans = wgetch(win)) != '\r') {
X					/* do our own backspace */
X		if (ans == 8) {
X			if (!count) {
X				beep();
X				continue;
X			}
X			count--;
X			buf[count] = NULL;
X			getyx(win, y, x);
X			x--;
X			wmove(win, y, x);
X			waddch(win, ' ');
X			wmove(win, y, x);
X			wrefresh(win);
X			continue;
X		}
X					/* an ESC anywhere in the string */
X		if (ans == 27)
X			return(-1);
X					/* only digits are allowed */
X		if (ans < '0' || ans > '9') {
X			beep();
X			continue;
X		}
X					/* exceeded the max ? */
X		if (count == num) {
X			beep();
X			continue;
X		}
X
X		buf[count] = ans;
X		waddch(win, ans);
X		wrefresh(win);
X		count++;
X	}
X	buf[count] = NULL;
X	number = atoi(buf);
X	return(number);
X}
X
X/*
X * Change video attributes while printing a string.  The use of the
X * pre-processor definition NOPROMOTE (located in misc.h) means that
X * strings will be printed without any special video attribute if the
X * requested capability doesn't exist.
X */
X
Xwattrstr(win, attr, str)
XWINDOW *win;
Xint attr;
Xchar *str;
X{
X	int do_it;
X					/* if nothing, do nothing */
X	if (str == NULL || *str == NULL)
X		return(0);
X
X#ifdef OLDCURSES
X	if (attr)
X		wstandout(win);
X	waddstr(win, str);
X	if (attr)
X		wstandend(win);
X#else /* OLDCURSES */
X#ifdef NOPROMOTE
X					/* does the capability exist ? */
X	do_it = 0;
X	if ((attr & A_STANDOUT) && enter_standout_mode)
X		do_it++;
X	if ((attr & A_UNDERLINE) && enter_underline_mode)
X		do_it++;
X	if ((attr & A_REVERSE) && (enter_reverse_mode || enter_standout_mode))
X		do_it++;
X	if ((attr & A_BLINK) && enter_blink_mode)
X		do_it++;
X	if ((attr & A_BOLD) && enter_bold_mode)
X		do_it++;
X	if ((attr & A_DIM) && enter_dim_mode)
X		do_it++;
X#else /* NOPROMOTE */
X	do_it = 1;
X#endif /* NOPROMOTE */
X
X	if (do_it)
X		wattron(win, attr);
X					/* print the string */
X	waddstr(win, str);
X	if (do_it)
X		wattroff(win, attr);
X#endif /* OLDCURSES */
X	return(0);
X}
X
X/*
X * Change video attributes while printing a character.
X */
X
Xwattrch(win, attr, c)
XWINDOW *win;
Xint attr;
Xchar c;
X{
X	int do_it;
X
X	if (c == NULL)
X		return(0);
X#ifdef OLDCURSES
X	if (attr)
X		wstandout(win);
X	waddch(win, c);
X	if (attr)
X		wstandend(win);
X#else /* OLDCURSES */
X#ifdef NOPROMOTE
X					/* does the capability exist ? */
X	do_it = 0;
X	if ((attr & A_STANDOUT) && enter_standout_mode)
X		do_it++;
X	if ((attr & A_UNDERLINE) && enter_underline_mode)
X		do_it++;
X	if ((attr & A_REVERSE) && (enter_reverse_mode || enter_standout_mode))
X		do_it++;
X	if ((attr & A_BLINK) && enter_blink_mode)
X		do_it++;
X	if ((attr & A_BOLD) && enter_bold_mode)
X		do_it++;
X	if ((attr & A_DIM) && enter_dim_mode)
X		do_it++;
X#else /* NOPROMOTE */
X	do_it = 1;
X#endif /* NOPROMOTE */
X
X	if (do_it)
X		wattron(win, attr);
X					/* print the character */
X	waddch(win, c);
X	if (do_it)
X		wattroff(win, attr);
X#endif /* OLDCURSES */
X	return(0);
X}
X
X
X/*
X * Change video attributes while printing a number.
X */
X
Xwattrnum(win, attr, num)
XWINDOW *win;
Xint attr, num;
X{
X	int do_it;
X	char buf[20];
X
X	sprintf(buf, "%d", num);
X
X#ifdef OLDCURSES
X	if (attr)
X		wstandout(win);
X	waddstr(win, buf);
X	if (attr)
X		wstandend(win);
X#else /* OLDCURSES */
X#ifdef NOPROMOTE
X					/* does the capability exist ? */
X	do_it = 0;
X	if ((attr & A_STANDOUT) && enter_standout_mode)
X		do_it++;
X	if ((attr & A_UNDERLINE) && enter_underline_mode)
X		do_it++;
X	if ((attr & A_REVERSE) && (enter_reverse_mode || enter_standout_mode))
X		do_it++;
X	if ((attr & A_BLINK) && enter_blink_mode)
X		do_it++;
X	if ((attr & A_BOLD) && enter_bold_mode)
X		do_it++;
X	if ((attr & A_DIM) && enter_dim_mode)
X		do_it++;
X#else /* NOPROMOTE */
X	do_it = 1;
X#endif /* NOPROMOTE */
X
X	if (do_it)
X		wattron(win, attr);
X					/* print the character */
X	waddstr(win, buf);
X	if (do_it)
X		wattroff(win, attr);
X#endif /* OLDCURSES */
X	return(0);
X}
X
X/*
X * Prompt for a Yes or No answer.  Echo the single key input as words.
X * Handle the funny cursor movement problems with magic cookie terminals.
X * Returns a 1 on yes.
X */
X
Xint
Xyes_prompt(win, y, x, attr, str)
XWINDOW *win;
Xint y, x, attr;
Xchar *str;
X{
X	int save, ret_code;
X	char new_str[80], *strcpy(), *strcat();
X					/* build and display the prompt */
X	strcpy(new_str, str);
X	strcat(new_str, "? (y/n):");
X	mvwattrstr(win, y, x, attr, new_str);
X	wmove(win, y, strlen(new_str)+x+2);
X	wrefresh(win);
X
X	ret_code = 0;
X	save = wgetch(win);
X	if (save == 'y' || save == 'Y') {
X		waddstr(win, "Yes");
X		ret_code = 1;
X	}
X	else
X		waddstr(win, "No");
X
X	wrefresh(win);
X	return(ret_code);
X}
X
X/*
X * Handy routine for clear-to-end-of-line.  Fixes up the box if requested.
X */
X
Xint
Xclear_line(win, y, x, re_box)
XWINDOW *win;
Xint y, x, re_box;
X{
X	if (wmove(win, y, x) == ERR)
X		return(ERR);
X
X	wclrtoeol(win);
X
X	if (re_box) {
X		mvwaddch(win, y, win->_maxx-1, '|');
X		wmove(win, y, x);
X	}
X	return(0);
X}
X
X/*
X * Wait for a key or time out.  Returns a -1 on timeout.
X */
X
Xjmp_buf wk_jmp;
X
Xint
Xwait_key(win, sec)
XWINDOW *win;
Xunsigned int sec;
X{
X	int c, force_wk();
X	unsigned int alarm();
X
X	signal(SIGALRM, force_wk);
X	if (setjmp(wk_jmp))
X		return(-1);
X	alarm(sec);
X	c = wgetch(win);
X	alarm(0);
X	return(c);
X}
Xint
Xforce_wk(dummy)
Xint dummy;
X{
X	void longjmp();
X
X	longjmp(wk_jmp, 1);
X}
X
X/*
X * Here are some routines that are probably missing from the older
X * flavors of curses(3)
X */
X
X#ifdef OLDCURSES
X/*
X * Make the terminal bell go off
X */
X
Xint
Xbeep()
X{
X	fputc(7, stderr);
X	return(0);
X}
X
X/*
X * Fix the stdin so that a read is satisfied immediately.  When read()
X * is called it returns the character in the queue, or an error if no
X * key was pressed.  The window argument is not used!
X */
X
Xint
Xnodelay(win, flag)
XWINDOW *win;
Xint flag;
X{
X	if (flag)
X		fcntl(0, F_SETFL, fcntl(0, F_GETFL, 0) | O_NDELAY);
X	else
X		fcntl(0, F_SETFL, fcntl(0, F_GETFL, 0) & ~O_NDELAY);
X	return(0);
X}
X
X/*
X * Take the terminal out of the "curses mode"
X */
X
Xint
Xresetterm()
X{
X	resetty();
X	return(0);
X}
X
X/*
X * Put the terminal back into the "curses mode"
X */
X
Xint
Xmyputchar(c)
Xchar c;
X{
X	putchar(c);
X}
Xint
Xfixterm()
X{
X	tputs(TI, 1, myputchar);
X	tputs(VS, 1, myputchar);
X	nonl();
X	crmode();
X	noecho();
X	return(0);
X}
X#endif /* OLDCURSES */
SHAR_EOF
if test 7649 -ne "`wc -c < 'curses.c'`"
then
	echo shar: "error transmitting 'curses.c'" '(should have been 7649 characters)'
fi
fi
echo shar: "extracting 'd_delete.c'" '(1987 characters)'
if test -f 'd_delete.c'
then
	echo shar: "will not over-write existing file 'd_delete.c'"
else
sed 's/^X//' << \SHAR_EOF > 'd_delete.c'
X/*
X * The delete option of the dialing directory.  Prompts for saving
X * changes to disk. A return code of 1 means that entries were deleted.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "dial_dir.h"
X#include "misc.h"
X#include "param.h"
X
Xint
Xdelete()
X{
X	WINDOW *d_win, *newwin();
X	int i, first, last;
X	void free_ptr();
X	extern char *null_ptr;
X	
X	d_win = newwin(6, 32, 10, 15);
X
X	mvwaddstr(d_win, 2, 2, "Delete entry:     thru:");
X	box(d_win, '|', '-');
X	wmove(d_win, 2, 16);
X	wrefresh(d_win);
X					/* get the first of the range */
X	while ((first = get_num(d_win, 3)) != -1) {
X		if (first > 0 && first <= NUM_DIR)
X			break;
X		mvwaddstr(d_win, 2, 16, "   ");
X		wmove(d_win, 2, 16);
X		beep();
X		wrefresh(d_win);
X	}
X	if (first == -1) {
X		delwin(d_win);
X		return(0);
X	}
X					/* get the last of the range */
X	wmove(d_win, 2, 26);
X	wrefresh(d_win);
X	while ((last = get_num(d_win, 3)) != -1) {
X		if ((first <= last && last <= NUM_DIR) || last == 0)
X			break;
X		mvwaddstr(d_win, 2, 26, "   ");
X		wmove(d_win, 2, 26);
X		beep();
X		wrefresh(d_win);
X	}
X	if (last == -1) {
X		delwin(d_win);
X		return(0);
X	}
X					/* if "last" omitted, echo "first" */
X	if (!last) {
X		last = first;
X		mvwprintw(d_win, 2, 26, "%d", first);
X		wrefresh(d_win);
X	}
X					/* save to disk? */
X	if (yes_prompt(d_win, 3, 2, A_BOLD, "Are you sure")) {
X					/* delete from the physical file */
X		if (del_dir(first, last)) {
X			touchwin(d_win);
X			wrefresh(d_win);
X		}
X		/*
X		 * We don't really care if del_dir() fails because we still
X		 * change the version in memory.
X		 */
X		for (i=first; i<=last; i++) {
X			free_ptr(dir->name[i]);
X			free_ptr(dir->number[i]);
X			free_ptr(dir->index[i]);
X			dir->name[i] = null_ptr;
X			dir->number[i] = null_ptr;
X			dir->baud[i] = param->d_baud;
X			dir->parity[i] = param->d_parity;
X			dir->dbits[i] = param->d_dbits;
X			dir->sbits[i] = param->d_sbits;
X			dir->duplex[i] = *param->d_duplex;
X			dir->index[i] = null_ptr;
X		}
X		delwin(d_win);
X		return(1);
X	}
X	delwin(d_win);
X	return(0);
X}
SHAR_EOF
if test 1987 -ne "`wc -c < 'd_delete.c'`"
then
	echo shar: "error transmitting 'd_delete.c'" '(should have been 1987 characters)'
fi
fi
echo shar: "extracting 'd_lib.c'" '(6469 characters)'
if test -f 'd_lib.c'
then
	echo shar: "will not over-write existing file 'd_lib.c'"
else
sed 's/^X//' << \SHAR_EOF > 'd_lib.c'
X/*
X * Routines to manipulate the dialing directory file pcomm.dial_dir
X */
X
X#include <stdio.h>
X#include "dial_dir.h"
X#include "param.h"
X#include "status.h"
X
X/*
X * Read the dialing directory.  Returns a pointer to a static area
X * containing the DIAL_DIR structure.  All of the entries are created
X * reguardless of the number of physical entries in the file.  Element
X * number zero is reserved for the "manual" entry.  All errors are fatal.
X */
X
Xstruct DIAL_DIR *
Xread_dir()
X{
X	FILE *fp;
X	int i, j, oops;
X	char *strdup(), buf[80], *temp_token, *str, *str_tok(), token[20];
X	char message[80], *sep;
X	static struct DIAL_DIR d;
X	void error_win();
X	extern char *null_ptr;
X
X	if (!(fp = fopen(status->d_path, "r"))) {
X		sprintf(buf, "'%s' for read", status->d_path);
X		error_win(1, "Can't open dialing directory file", buf);
X	}
X
X	sep = ";;---;;\n";
X	i = 0;
X	oops = 0;
X	while (fgets(buf, 80, fp) != NULL) {
X		i++;
X		if (i > NUM_DIR)
X			break;
X					/* get the token */
X		if (!(temp_token = str_tok(buf, '='))) {
X			sprintf(message, "is missing a token at line %d", i);
X			oops++;
X			break;
X		}
X		/*
X		 * Parse the rest of the line.  This is similar to using
X		 * the "real" strtok() function, but my version returns
X		 * a null pointer if the parameter is missing.  Note the
X		 * array of field separators.
X		 */
X		for (j=0; j<8; j++) {
X			if (!(str = str_tok((char *) NULL, sep[j]))) {
X				sprintf(message, "is missing a parameter at line %d", i);
X				oops++;
X				break;
X			}
X			switch(j) {
X				case 0:
X					d.name[i] = strdup(str);
X					break;
X				case 1:
X					d.number[i] = strdup(str);
X					break;
X				case 2:
X					d.baud[i] = atoi(str);
X					break;
X				case 3:
X					d.parity[i] = *str;
X					break;
X				case 4:
X					d.dbits[i] = atoi(str);
X					break;
X				case 5:
X					d.sbits[i] = atoi(str);
X					break;
X				case 6:
X					d.duplex[i] = *str;
X					break;
X				case 7:
X					d.index[i] = strdup(str);
X					break;
X			}
X		}
X		if (oops)
X			break;
X					/* sanity checking */
X		sprintf(token, "DIR_%d", i);
X		if (strcmp(temp_token, token)) {
X			sprintf(message, "is corrupted at line %d", i);
X			oops++;
X			break;
X		}
X	}
X	fclose(fp);
X
X	if (oops) {
X		sprintf(buf, "Directory file '%s'", status->d_path);
X		error_win(1, buf, message);
X	}
X	d.d_entries = i;
X					/* fill in the rest with defaults */
X	i++;
X	for (; i<=NUM_DIR; i++) {
X		d.name[i] = null_ptr;
X		d.number[i] = null_ptr;
X		d.baud[i] = param->d_baud;
X		d.parity[i] = param->d_parity;
X		d.dbits[i] = param->d_dbits;
X		d.sbits[i] = param->d_sbits;
X		d.duplex[i] = *param->d_duplex;
X		d.index[i] = null_ptr;
X	}
X					/* create an empty "manual" entry */
X	d.name[0] = null_ptr;
X	d.number[0] = null_ptr;
X	d.baud[0] = param->d_baud;
X	d.parity[0] = param->d_parity;
X	d.dbits[0] = param->d_dbits;
X	d.sbits[0] = param->d_sbits;
X	d.duplex[0] = *param->d_duplex;
X	d.index[0] = null_ptr;
X					/* create an empty queue */
X	for (i=0; i<NUM_QUEUE; i++) {
X		d.q_ld[i] = NULL;
X		d.q_num[i] = -1;
X	}
X					/* the startup d_cur is 0 */
X	d.d_cur = 0;
X	return(&d);
X}
X
X/*
X * Update a dialing directory entry.  Update only the one entry asked for,
X * not the entire image in memory.  If the new entry is beyond the end of
X * the physical file, then fill in the holes, and update "dir->d_entries".
X * A return code of 1 means a non-fatal error.
X */
X
Xint
Xupdate_dir(entry)
Xint entry;
X{
X	FILE *fp_in, *fp_out;
X	char *temp[NUM_DIR+1], buf[80], *strdup();
X	int i;
X	void error_win(), free_ptr();
X
X					/* open for read */
X	if (!(fp_in = fopen(status->d_path, "r"))) {
X		sprintf(buf, "'%s' for read", status->d_path);
X		error_win(1, "Can't open dialing directory file", buf);
X	}
X					/* read in a temporary version */
X	i = 0;
X	while (fgets(buf, 80, fp_in) != NULL)
X		temp[++i] = strdup(buf);
X	
X	fclose(fp_in);
X					/* alter only 1 entry */
X	sprintf(buf, "DIR_%d=%s;%s;%d-%c-%d-%d;%c;%s\n", entry,
X	 dir->name[entry], dir->number[entry], dir->baud[entry],
X	 dir->parity[entry], dir->dbits[entry], dir->sbits[entry],
X	 dir->duplex[entry], dir->index[entry]);
X
X	if (entry <= dir->d_entries)
X		free_ptr(temp[entry]);
X	temp[entry] = strdup(buf);
X					/* fill in holes if beyond end */
X	if (entry > dir->d_entries+1) {
X		for (i=dir->d_entries+1; i<entry; i++) {
X			sprintf(buf, "DIR_%d=;;%d-%c-%d-%d;%c;\n", i,
X			 param->d_baud, param->d_parity, param->d_dbits,
X			 param->d_sbits, *param->d_duplex);
X			temp[i] = strdup(buf);
X		}
X	}
X					/* update "dir->d_entries" */
X	if (entry > dir->d_entries)
X		dir->d_entries = entry;
X
X					/* open for read */
X	if (!(fp_out = fopen(status->d_path, "w"))) {
X		for (i=1; i<=dir->d_entries; i++)
X			free_ptr(temp[i]);
X		sprintf(buf, "'%s'", status->d_path);
X		error_win(0, "No write permission on directory file", buf);
X		return(1);
X	}
X					/* put it back */
X	for (i=1; i<=dir->d_entries; i++) {
X		fputs(temp[i], fp_out);
X		free_ptr(temp[i]);
X	}
X
X	fclose(fp_out);
X	return(0);
X}
X
X/*
X * Delete a range of dialing directory entries.  Actually, just copies
X * default (empty) entries in place of deleted entries.  However, it will
X * shrink the file if deletions occur at the physical EOF.  A return code
X * of 1 means a non-fatal error.
X */
X
Xint
Xdel_dir(first, last)
Xint first, last;
X{
X	FILE *fp_in, *fp_out;
X	int i;
X	char *temp[NUM_DIR+1], buf[80], *strdup();
X	void error_win(), free_ptr();
X					/* sanity checking */
X	if (first > dir->d_entries)
X		return(0);
X	if (last > dir->d_entries)
X		last = dir->d_entries;
X
X					/* open for read */
X	if (!(fp_in = fopen(status->d_path, "r"))) {
X		sprintf(buf, "'%s' for read", status->d_path);	
X		error_win(1, "Can't open dialing directory file", buf);
X	}
X					/* read in a temporary version */
X	i = 0;
X	while (fgets(buf, 80, fp_in) != NULL)
X		temp[++i] = strdup(buf);
X
X	fclose(fp_in);
X					/* delete the range of values */
X	for (i=first; i<=last; i++) {
X		sprintf(buf, "DIR_%d=;;%d-%c-%d-%d;%c;\n", i, param->d_baud,
X		 param->d_parity, param->d_dbits, param->d_sbits,
X		 *param->d_duplex);
X		free_ptr(temp[i]);
X		temp[i] = strdup(buf);
X	}
X					/* shrink the file? */
X	if (last >= dir->d_entries) {
X		for (i=first; i<=last; i++)
X			free_ptr(temp[i]);
X		dir->d_entries = first-1;
X	}
X					/* open for write */
X	if (!(fp_out = fopen(status->d_path, "w"))) {
X		for (i=1; i<=dir->d_entries; i++)
X			free_ptr(temp[i]);
X		sprintf(buf, "'%s'", status->d_path);
X		error_win(0, "No write permission on dialing directory file", buf);
X		return(1);
X	}
X					/* put it all back */
X	for (i=1; i<=dir->d_entries; i++) {
X		fputs(temp[i], fp_out);
X		free_ptr(temp[i]);
X	}
X
X	fclose(fp_out);
X	return(0);
X}
SHAR_EOF
if test 6469 -ne "`wc -c < 'd_lib.c'`"
then
	echo shar: "error transmitting 'd_lib.c'" '(should have been 6469 characters)'
fi
fi
echo shar: "extracting 'd_manual.c'" '(1757 characters)'
if test -f 'd_manual.c'
then
	echo shar: "will not over-write existing file 'd_manual.c'"
else
sed 's/^X//' << \SHAR_EOF > 'd_manual.c'
X/*
X * The manual dial option of the dialing directory.  A return code of
X * 1 means we're ready to dial.  Dialing directory entry 0 is reserved
X * for the manual dial option.  No sanity checking is done on the input.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "dial_dir.h"
X
Xint
Xmanual()
X{
X	WINDOW *m_win, *newwin();
X	char *number, *strdup(), *get_str(), ld_code, *strchr();
X	void fix_xmc(), free_ptr();
X	extern int xmc;
X	
X	m_win = newwin(5, 50, 0, 20);
X
X	box(m_win, '|', '-');
X	mvwaddstr(m_win, 2, 3, "Phone Number: ");
X	wrefresh(m_win);
X					/* get a phone number */
X	if ((number = get_str(m_win, 30, NULL, NULL)) == NULL) {
X		werase(m_win);
X		wrefresh(m_win);
X		delwin(m_win);
X		if (xmc > 0)
X			fix_xmc();
X		return(0);
X	}
X					/* is first char an LD code ? */
X	ld_code = NULL;
X	if (strchr("+-@#", *number)) {
X		ld_code = *number;
X		number++;
X	}
X					/* put it in the queue */
X	dir->q_ld[0] = ld_code;
X	dir->q_num[0] = 0;
X					/* end of queue marker */
X	dir->q_num[1] = -1;
X	dir->d_cur = 0;
X					/* build the entry zero */
X	free_ptr(dir->name[0]);
X	free_ptr(dir->number[0]);
X	dir->name[0] = strdup(number);
X	dir->number[0] = strdup(number);
X					/* it overlaps dm_win, so erase it */
X	werase(m_win);
X	wrefresh(m_win);
X	delwin(m_win);
X	if (xmc > 0)
X		fix_xmc();
X	return(1);
X}
X
X/*
X * Clear the end of the physical screen where the magic cookie got shifted
X * Geez, I hate magic cookie terminals...  Wyse, are you listening?
X */
X
Xvoid
Xfix_xmc()
X{
X	WINDOW *cl_win, *newwin();
X
X	/*
X	 * Since the cookie got shifted off the window, we have to
X	 * create a new window to cover where the cookie ended up.
X	 */
X	cl_win = newwin(1, 2, 4, 78);
X					/* have to touch, otherwise nothing! */
X	touchwin(cl_win);
X	wrefresh(cl_win);
X	delwin(cl_win);
X	
X	return;
X}
SHAR_EOF
if test 1757 -ne "`wc -c < 'd_manual.c'`"
then
	echo shar: "error transmitting 'd_manual.c'" '(should have been 1757 characters)'
fi
fi
echo shar: "extracting 'd_menu.c'" '(6870 characters)'
if test -f 'd_menu.c'
then
	echo shar: "will not over-write existing file 'd_menu.c'"
else
sed 's/^X//' << \SHAR_EOF > 'd_menu.c'
X/*
X * Routines for the dialing directory menu.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "dial_dir.h"
X#include "misc.h"
X#include "param.h"
X
X/*
X * Display the dialing directory and prompt for options.  A return code of
X * 1 means we're ready to dial.
X */
X
Xint
Xdial_menu()
X{
X	WINDOW *dm_win, *newwin();
X	char buf[5], ld_code;
X	int ans, start, current, needs_repair, count, x, y, i, ret_code;
X	void scroll_dir(), active_ld(), disp_ld(), print_dir();
X	extern int xmc;
X
X	dm_win = newwin(22, 78, 1, 1);
X	mvwattrstr(dm_win, 1, 20, A_BOLD, "D I A L I N G       D I R E C T O R Y");
X	waddstr(dm_win, "\n-----------------------------------------------------------------------------\n");
X	wattrstr(dm_win, A_STANDOUT, "           Name                   Number        Baud P D S Dpx  Index/tty    ");
X					/* show the first 10 entries */
X	scroll_dir(dm_win, 1);
X
X	mvwaddstr(dm_win, 15, 4, "==>");
X	mvwattrch(dm_win, 15, 14, A_BOLD, 'R');
X	waddstr(dm_win, " Revise");
X	mvwattrch(dm_win, 15, 32, A_BOLD, 'M');
X	waddstr(dm_win, " Manual Dialing");
X	mvwaddstr(dm_win, 15, 55, "Entry to Dial");
X
X	mvwattrch(dm_win, 16, 14, A_BOLD, 'P');
X	waddstr(dm_win, " LD Codes");
X	mvwattrch(dm_win, 16, 32, A_BOLD, 'D');
X	waddstr(dm_win, " Delete Entry");
X	mvwattrstr(dm_win, 16, 55, A_BOLD, "<cr>");
X	waddstr(dm_win, " Scroll Down");
X
X	mvwattrstr(dm_win, 17, 14, A_BOLD, "up/dn");
X	waddstr(dm_win, " Page");
X	mvwattrch(dm_win, 17, 32, A_BOLD, 'L');
X	waddstr(dm_win, " Print Entries");
X	mvwattrstr(dm_win, 17, 55, A_BOLD, "ESC");
X	waddstr(dm_win, " Exit");
X
X	mvwaddstr(dm_win, 19, 4, "LD Codes Active:");
X					/* show which LD codes are active */
X	active_ld(dm_win);
X
X	box(dm_win, '|', '-');
X	y = 15;
X	x = 8;
X	wmove(dm_win, 15, 8);
X	wrefresh(dm_win);
X#ifndef OLDCURSES
X	keypad(dm_win, 1);
X#endif /* OLDCURSES */
X					/* prompt for options */
X	current = 1;
X	count = 0;
X	ld_code = NULL;
X	ret_code = 0;
X	do {
X		needs_repair = 0;
X		ans = wgetch(dm_win);
X					/* get an entry number */
X		if (ans >= '0' && ans <= '9') {
X			if (count > 2) {
X				beep();
X				continue;
X			}
X			buf[count] = ans;
X			waddch(dm_win, ans);
X			wrefresh(dm_win);
X			count++;
X			continue;
X		}
X		switch (ans) {
X			case 8:		/* do our own backspace */
X				if (!count) {
X					beep();
X					break;
X				}
X				count--;
X				if (!count)
X					ld_code = NULL;
X				buf[count] = NULL;
X				getyx(dm_win, y, x);
X				x--;
X				wmove(dm_win, y, x);
X				waddch(dm_win, ' ');
X				wmove(dm_win, y, x);
X				wrefresh(dm_win);
X				break;
X#ifndef OLDCURSES
X			case KEY_UP:
X#endif /* OLDCURSES */
X			case 'u':
X			case 'U':	/* up arrow key */
X				if (current == 1) {
X					beep();
X					break;
X				}
X				start = current - 10;
X				if (start < 1)
X					start = 1;
X				current = start;
X				scroll_dir(dm_win, start);
X				break;
X#ifndef OLDCURSES
X			case KEY_DOWN:
X			case '\n':
X#endif /* OLDCURSES */
X			case 'n':
X			case 'N':	/* down arrow key */
X				if (current == NUM_DIR-9) {
X					beep();
X					break;
X				}
X				start = current + 10;
X				if (start > NUM_DIR-9)
X					start = NUM_DIR-9;
X				current = start;
X				scroll_dir(dm_win, start);
X				break;	
X			case '\r':	/* <CR> key */
X				if (!count) {
X					if (current == NUM_DIR-9) {
X						beep();
X						break;
X					}
X					current++;
X					if (current > NUM_DIR-9)
X						current = NUM_DIR-9;
X					scroll_dir(dm_win, current);
X				}
X				/*
X				 * The CR is used for the scroll-down-one-line
X				 * function, and to terminate numeric input.
X				 */
X				else {
X					buf[count] = NULL;
X					i = atoi(buf);
X					if (!i || i > NUM_DIR) {
X						beep();
X						mvwaddstr(dm_win, 15, 8, "   ");
X						x = 8;
X						count = 0;
X						break;
X					}
X					dir->q_ld[0] = ld_code;
X					dir->q_num[0] = i;
X					dir->d_cur = i;
X
X					/* end of queue marker */
X					dir->q_num[1] = -1;
X					
X					ret_code = 1;
X					break;
X				}
X				break;	
X			case 'r':
X			case 'R':	/* revise */
X				if (revise()) {
X					active_ld(dm_win);
X					scroll_dir(dm_win, current);
X				}
X				touchwin(dm_win);
X				break;
X			case 'p':	/* display LD codes */
X			case 'P':
X				disp_ld();
X				touchwin(dm_win);
X				needs_repair = 1;
X				break;
X			case 'd':
X			case 'D':	/* delete a range of entries */
X				if (delete())
X					scroll_dir(dm_win, current);
X				touchwin(dm_win);
X				break;
X			case 'm':
X			case 'M':	/* manual dial */
X				if (manual()) {
X					ret_code = 1;
X					break;
X				}
X				touchwin(dm_win);
X				needs_repair = 1;
X				break;
X			case 'l':
X			case 'L':	/* print the entries */
X				print_dir();
X				touchwin(dm_win);
X				needs_repair = 1;
X				break;
X			case '+':	/* LD codes */
X			case '-':
X			case '@':
X			case '#':
X				waddch(dm_win, ans);
X				wrefresh(dm_win);
X				ld_code = ans;
X				continue;
X			case 27:	/* ESC key (exit) */
X				break;
X			default:
X				beep();
X		}
X		if (ret_code)
X			break;
X					/* magic cookie terminal ? */
X		if (xmc > 0 && needs_repair) {
X			clear_line(dm_win, 1, 0, 0);
X			clear_line(dm_win, 3, 0, 0);
X			wrefresh(dm_win);
X			mvwattrstr(dm_win, 1, 20, A_BOLD, "D I A L I N G       D I R E C T O R Y");
X			mvwattrstr(dm_win, 3, 0, A_STANDOUT, "           Name                   Number        Baud P D S Dpx  Index/tty    ");
X			box(dm_win, '|', '-');
X		}
X		wmove(dm_win, y, x);
X		wrefresh(dm_win);
X	} while (ans != 27);
X
X	werase(dm_win);
X	wrefresh(dm_win);
X	delwin(dm_win);
X	return(ret_code);
X}
X
X/*
X * Scroll the dialing directory.  Actually, we're not doing a real scroll
X * function on the screen, we're just repainting 10 lines.
X */
X
Xvoid
Xscroll_dir(win, start)
XWINDOW *win;
Xint start;
X{
X	int i;
X
X	wmove(win, 4, 0);
X	for (i=start; i<start+10; i++)
X		wprintw(win,
X		 "%4d- %-20.20s %18.18s  %5d-%c-%d-%d  %c  %-14.14s\n", i,
X		 dir->name[i], dir->number[i], dir->baud[i], dir->parity[i],
X		 dir->dbits[i], dir->sbits[i], dir->duplex[i], dir->index[i]);
X	box(win, '|', '-');
X	return;
X}
X
X/*
X * Display the Long Distance codes.  Press any key to continue.
X */
X
Xvoid
Xdisp_ld()
X{
X	WINDOW *ld_win, *newwin();
X
X	ld_win = newwin(12, 30, 0, 0);
X	mvwaddstr(ld_win, 1, 5, "Long Distance Codes\n");
X	waddstr(ld_win, "------------------------------");
X	mvwprintw(ld_win, 3, 2, "+ %-20.20s", param->ld_plus);
X	mvwprintw(ld_win, 5, 2, "- %-20.20s", param->ld_minus);
X	mvwprintw(ld_win, 7, 2, "@ %-20.20s", param->ld_at);
X	mvwprintw(ld_win, 9, 2, "# %-20.20s", param->ld_pound);
X	box(ld_win, '|', '-');
X
X	mvwaddstr(ld_win, 11, 8, " Press any key ");
X	wmove(ld_win, 11, 29);
X	wrefresh(ld_win);
X	wgetch(ld_win);
X					/* it overlaps, so erase it */
X	werase(ld_win);
X	wrefresh(ld_win);
X	delwin(ld_win);
X	return;
X}
X
X/*
X * Display which of the Long Distance codes are active.
X */
X
Xvoid
Xactive_ld(win)
XWINDOW *win;
X{
X	mvwaddstr(win, 19, 21, "        ");
X	wmove(win, 19, 21);
X					/* a NULL pointer means not active */
X	if (*param->ld_plus != NULL)
X		waddstr(win, "+ ");
X	if (*param->ld_minus != NULL)
X		waddstr(win, "- ");
X	if (*param->ld_at != NULL)
X		waddstr(win, "@ ");
X	if (*param->ld_pound != NULL)
X		waddstr(win, "# ");
X	return;
X}
SHAR_EOF
if test 6870 -ne "`wc -c < 'd_menu.c'`"
then
	echo shar: "error transmitting 'd_menu.c'" '(should have been 6870 characters)'
fi
fi
exit 0
#	End of shell archive
