Subject:  v14i047:  Network News Transfer Protocol, version 1.5, Part01/09
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Phil Lapsley <phil@ucbvax.berkeley.edu>
Posting-number: Volume 14, Issue 47
Archive-name: nntp1.5/part01

[  NNTP is a protocol and software package that runs on top of TCP/IP.
   Many hosts on the Internet (ARPAnet, MILnet, NSFnet, etc.) use it to
   exchange articles rather than using compressed UUCP batches.  Even if
   you're not on the Internet, but just have a local LAN NNTP is useful.
   Enclosed are patches to the RN sources so that an organization need
   not have a copy of the Netnews database on every single machine at
   their site.  After this posting will be patches to VN that also allow
   this.  --r$  ]


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 9)."
# Wrapped by rsalz@fig.bbn.com on Tue Apr 19 18:16:34 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f './Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./Makefile'\"
else
echo shar: Extracting \"'./Makefile'\" \(1532 characters\)
sed "s/^X//" >'./Makefile' <<'END_OF_FILE'
X
X#
X# Makefile for NNTP intstallation
X#
X
DISTFILES = Makefile README CHANGES rrnpatches
X
DISTDIRS = common doc inews server support xfer xmit
X
DIST = $(DISTFILES) $(DISTDIRS)
X
X# Make this either "server" or "client" depending on whether
X# you want this package compiled to be a server or a client
X# (You can always say "make server" or "make client" if you want.
X
TYPE = 
X
all: make_$(TYPE)
X
make_:
X	@ echo "If you want to make a server version or a client version,"
X	@ echo "type \"make server\" or \"make client\" respectively."
X	@ echo "See README for details."
X
make_server: /nowhere
X	cd server; make
X	cd support; make
X	cd doc; make
X	cd xmit; make
X
server: make_server
X
make_client: /nowhere
X	cd inews; make
X	cd doc; make
X
client: make_client
X
install: install_$(TYPE)
X
install_:
X	@ echo "If you want to install a server version or"
X	@ echo "a client version, type \"make install_server\""
X	@ echo "or \"make install_client\" respectively."
X	@ echo "See README for more details."
X
install_server:
X	cd server; make install
X	cd support; make install
X	cd doc; make install
X
install_client:
X	cd inews; make install
X	cd doc; make install
X
clean:
X	for i in $(DISTDIRS); do cd $$i; make clean; cd ..; done
X
check:
X	for i in $(DISTDIRS); do cd $$i; make check; cd ..; done
X
distrib: check
X	mkdir ../nntp.dist
X	cp -rp $(DIST) ../nntp.dist
X	cd ../nntp.dist; for i in $(DISTDIRS); do cd $$i; make distrib; cd ..; done
X
rpt: /nowhere
X	tar cf rrnpatches.tar rrnpatches; compress rrnpatches.tar
X
server: /nowhere
client: /nowhere
X
X/nowhere: ;
END_OF_FILE
if test 1532 -ne `wc -c <'./Makefile'`; then
    echo shar: \"'./Makefile'\" unpacked with wrong size!
fi
# end of './Makefile'
fi
if test ! -d './common' ; then
    echo shar: Creating directory \"'./common'\"
    mkdir './common'
fi
if test -f './common/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./common/Makefile'\"
else
echo shar: Extracting \"'./common/Makefile'\" \(222 characters\)
sed "s/^X//" >'./common/Makefile' <<'END_OF_FILE'
X#
X# Makefile for common directory
X#
X
SRCS	=	version.c clientlib.c
OBJS	=	version.o clientlib.o
HFILES	=
X
clean:
X	-rm -f ${OBJS}
X
distrib: clean
X	rm -rf SCCS
X
check:
X	sccs check
X
lint:
X	lint ${SRCS}
X
tags:
X	ctags ${CFILES}
END_OF_FILE
if test 222 -ne `wc -c <'./common/Makefile'`; then
    echo shar: \"'./common/Makefile'\" unpacked with wrong size!
fi
# end of './common/Makefile'
fi
if test -f './common/README.HPUX' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./common/README.HPUX'\"
else
echo shar: Extracting \"'./common/README.HPUX'\" \(107 characters\)
sed "s/^X//" >'./common/README.HPUX' <<'END_OF_FILE'
X
If you're compiling this under hpux, you'll need to edit
server/Makefile and add
X
X	LIBS = -lbsdipc -lBSD
X
END_OF_FILE
if test 107 -ne `wc -c <'./common/README.HPUX'`; then
    echo shar: \"'./common/README.HPUX'\" unpacked with wrong size!
fi
# end of './common/README.HPUX'
fi
if test -f './common/README.LIB' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./common/README.LIB'\"
else
echo shar: Extracting \"'./common/README.LIB'\" \(1375 characters\)
sed "s/^X//" >'./common/README.LIB' <<'END_OF_FILE'
X     This directory contains lotsa good stuff common to both
the news server, support, and client programs.  The short of it is:
X
conf.h		Configuration information for NNTP server,
X		support, and client programs.  Described in detail
X		in README in this directory.
X
nntp.h		These are the #define's of the numeric response
X		codes (and other stuff) in NNTP as defined by RFC 977.
X
clientlib.c	This file is a collection of routines which clients
X		can use to talk to the NNTP server.  The code is
X		well documented, but briefly, the functions are
X
X			getserverbyfile	Opens a named file and
X					returns the contents,
X					presumed to be a host name
X			server_init	Open connection to server
X			getsocket	Get a stream socket
X			get_server	Get line from server
X			put_server	Send line to server
X			close_server	Close connection
X
X		It is worth noting that these routines use
X		buffered I/O, and leave the external variables
X		"ser_rd_fp" and "ser_wr_fp" (server read/write
X		file pointers, respectively) floating around
X		for use by programs which need them.
X
If you use the clientlib package to build an NNTP client of your
own, you either need to define NNTPSRC on the "cc" command
line when compiling clientlib.c, or add compile-type -D lines to
the "cc" command line for each option.  Defining NNTPSRC will
try to include "../common/conf.h", which should be used if it exists.
END_OF_FILE
if test 1375 -ne `wc -c <'./common/README.LIB'`; then
    echo shar: \"'./common/README.LIB'\" unpacked with wrong size!
fi
# end of './common/README.LIB'
fi
if test -f './common/README.SYSV' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./common/README.SYSV'\"
else
echo shar: Extracting \"'./common/README.SYSV'\" \(1287 characters\)
sed "s/^X//" >'./common/README.SYSV' <<'END_OF_FILE'
X[This is from Stan Barber, <sob@tmc.edu>.  Thanks, Stan. --Phil]
X
To make nntp run on SYSV, do the following:
X
X1. Get the Berkeley Directory Library emulation package. You can get it
from your nearest comp.sources.unix archive. This is the so-called NDIR 
package. Install it. (If you don't know if you have it, look for the
file ndir.h in /usr/include. If it is there, you have the NDIR library
and can move on the step 2.)
X
X2. Edit common/conf.h. Make sure you define USG and look at all the
other stuff in there to be sure you have defined all the other things
you need. (You will most likely need to define U_LONG, ALONE, vfork,
and FAKESYSLOG. You will most likely need to undefine FASTFORK, BSD_42,
DBM, SUBNET, NETMASK, DAMAGED_NETMASK, and DECNET.) You will probably need to
undefine SYSLOG if you don't define FAKESYSLOG.
X
X3. Edit server/Makefile. Make sure to add -lndir to the LIBS line.
If you have EXCELAN, you will probably need to add a -lsocket here as
well. If the networking include files are not in the "standard location"
X(i.e. /usr/include), be sure to add -Ilocation_of_the_network_include_files
to the CFLAGS line.
X
X4. Now, you can cd to the server directory and type make.
X
If you have problems, send mail to sob@tmc.edu and he will help if he
can.
X
Stan Barber
X
END_OF_FILE
if test 1287 -ne `wc -c <'./common/README.SYSV'`; then
    echo shar: \"'./common/README.SYSV'\" unpacked with wrong size!
fi
# end of './common/README.SYSV'
fi
if test -f './common/clientlib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./common/clientlib.h'\"
else
echo shar: Extracting \"'./common/clientlib.h'\" \(230 characters\)
sed "s/^X//" >'./common/clientlib.h' <<'END_OF_FILE'
X/*
X * Definitions for NNTP client routines.
X *
X * @(#)clientlib.h	1.1	(Berkeley) 1/9/88
X */
X
extern	char	*getserverbyfile();
extern	int	server_init();
extern	void	put_server();
extern	int	get_server();
extern	void	close_server();
END_OF_FILE
if test 230 -ne `wc -c <'./common/clientlib.h'`; then
    echo shar: \"'./common/clientlib.h'\" unpacked with wrong size!
fi
# end of './common/clientlib.h'
fi
if test -f './common/version.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./common/version.c'\"
else
echo shar: Extracting \"'./common/version.c'\" \(96 characters\)
sed "s/^X//" >'./common/version.c' <<'END_OF_FILE'
X/*
X * Provide the version number of this release.
X */
X
char	nntp_version[] = "1.5 (26 Feb 88)";
END_OF_FILE
if test 96 -ne `wc -c <'./common/version.c'`; then
    echo shar: \"'./common/version.c'\" unpacked with wrong size!
fi
# end of './common/version.c'
fi
if test ! -d './doc' ; then
    echo shar: Creating directory \"'./doc'\"
    mkdir './doc'
fi
if test -f './doc/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./doc/Makefile'\"
else
echo shar: Extracting \"'./doc/Makefile'\" \(990 characters\)
sed "s/^X//" >'./doc/Makefile' <<'END_OF_FILE'
X#
X# Makefile for manual pages for nntp service
X#
X# Created by Stan Barber; Mon Apr  6 13:25:27 CDT 1987
X#
X
X# change these to suit your system
ROFF	= ditroff
PRINTER	= lw301
MANDIR	= /usr/man
X
X# from here down should be constant
SHELL	= /bin/sh
MACROS	= -man
MANPAGES= nntpd.8c mkgrdates.8c getactive.1
EXTRACT	= ./config.sh
X
all: $(MANPAGES)
X	@echo "Done"
X
nntpd.8c: nntpd.dst $(EXTRACT)
X	$(EXTRACT) nntpd.dst nntpd.8c
X
mkgrdates.8c: mkgrdates.dst $(EXTRACT)
X	$(EXTRACT) mkgrdates.dst mkgrdates.8c
X
getactive.1: getactive.dst $(EXTRACT)
X	$(EXTRACT) getactive.dst getactive.1
X
install: $(MANPAGES)
X	mv nntpd.8c $(MANDIR)/man8/nntpd.8c
X	mv mkgrdates.8c $(MANDIR)/man8/mkgrdates.8c
X	mv getactive.1 $(MANDIR)/man1/getactive.1
X	mv nntpxmit.1 $(MANDIR)/man1/nntpxmit.1
X
print: $(MANPAGES)
X	$(ROFF) $(MACROS) -P$(PRINTER) nntpd.8c
X	$(ROFF) $(MACROS) -P$(PRINTER) mkgrdates.8c
X	$(ROFF) $(MACROS) -P$(PRINTER) getactive.1
X
clean:
X	-rm -f $(MANPAGES)
X
distrib: clean
X	rm -rf SCCS
X
check:
X	sccs check
END_OF_FILE
if test 990 -ne `wc -c <'./doc/Makefile'`; then
    echo shar: \"'./doc/Makefile'\" unpacked with wrong size!
fi
# end of './doc/Makefile'
fi
if test -f './doc/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./doc/README'\"
else
echo shar: Extracting \"'./doc/README'\" \(379 characters\)
sed "s/^X//" >'./doc/README' <<'END_OF_FILE'
X
X[A README file for a doc directory?  Yow...]
X
Manual pages are in the *.dst files.  Because some manual pages contain
site-dependent things (e.g., path name references for the news lib
directory, etc.), you should customize the file "config.sh".
X
Once you've done that (look at config.sh -- it's self explanatory),
type "make".
X
The RFC describing the protocol is in "rfc977".
X
END_OF_FILE
if test 379 -ne `wc -c <'./doc/README'`; then
    echo shar: \"'./doc/README'\" unpacked with wrong size!
fi
# end of './doc/README'
fi
if test -f './doc/getactive.dst' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./doc/getactive.dst'\"
else
echo shar: Extracting \"'./doc/getactive.dst'\" \(1024 characters\)
sed "s/^X//" >'./doc/getactive.dst' <<'END_OF_FILE'
X.\"
X.\" @(#)getactive.dst	1.2	(Berkeley) 10/15/87
X.\"
X.TH GETACTIVE 1 "8 July 1987"
X.UC 4
X.SH NAME
getactive \- retrieve the active file from the remote news server
X.SH SYNOPSIS
X.B RNLIB/getactive filename
X.SH DESCRIPTION
X.I Getactive
retrieves the newsgroup ``active file'' (which contains
the list of all known newsgroups and their high/low message
numbers) from the news server on a remote machine and
places it in
X.I filename.
X.PP
The normal use is in support of shell scripts (such as
X.I newsgroups
or
X.I newsetup )
which have been taken from existing software, such
as
X.I rn.
When used in such scripts, the active file is usually
retrieved into a temporary file such as
X.IR /tmp/active.$$ ,
and should be deleted before the shell script exits.
X.PP
The active file is retrieved from the machine
listed in the file SERVERFILE, which is
defined by the constant
SERVER_FILE in
X.I common/conf.h
in thef NNTP source directory.
The environment variable NNTPSERVER can be used to
override this choice.
X.SH AUTHOR
Phil Lapsley
END_OF_FILE
if test 1024 -ne `wc -c <'./doc/getactive.dst'`; then
    echo shar: \"'./doc/getactive.dst'\" unpacked with wrong size!
fi
# end of './doc/getactive.dst'
fi
if test ! -d './inews' ; then
    echo shar: Creating directory \"'./inews'\"
    mkdir './inews'
fi
if test -f './inews/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./inews/Makefile'\"
else
echo shar: Extracting \"'./inews/Makefile'\" \(812 characters\)
sed "s/^X//" >'./inews/Makefile' <<'END_OF_FILE'
X#
X# Makefile for pseudo-inews
X#
X
SRCS	=	inews.c uname.c ../common/clientlib.c ../common/version.c
OBJS	=	inews.o uname.o ../common/clientlib.o ../common/version.o
HFILES	=	../common/nntp.h ../common/conf.h
X
CFLAGS	= -O
X
DESTDIR	= /usr/local
X
inews:  $(OBJS) $(HFILES)
X	$(CC) $(CFLAGS) $(OBJS) -o inews
X
uname.o: ../common/conf.h
X
X../common/clientlib.o:
X	${CC} ${CFLAGS} -DNNTPSRC -c ../common/clientlib.c
X	mv clientlib.o ../common/clientlib.o
X
X../common/version.o:
X	${CC} ${CFLAGS} -c ../common/version.c
X	mv version.o ../common/version.o
X
install: inews
X	cp inews ${DESTDIR}/inews
X	chmod 755 ${DESTDIR}/inews
X
clean:
X	-rm -f ${OBJS} inews make*.out
X
distrib: clean
X	rm -f make.out
X	rm -rf SCCS
X
check:
X	sccs check
X	sccs prt -y *.[ch] > /dev/null
X
lint:
X	lint ${SRCS} ${HFILES}
X
tags:
X	ctags $(CFILES) $(HFILES)
END_OF_FILE
if test 812 -ne `wc -c <'./inews/Makefile'`; then
    echo shar: \"'./inews/Makefile'\" unpacked with wrong size!
fi
# end of './inews/Makefile'
fi
if test -f './inews/test' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./inews/test'\"
else
echo shar: Extracting \"'./inews/test'\" \(177 characters\)
sed "s/^X//" >'./inews/test' <<'END_OF_FILE'
Path: ucbingres!grady
From: grady@ucbnug.ARPA
Subject: testola
Newsgroups: ucb.test
Distribution: ucb
Follow-up: ucb.test
Extra-entry: and another thing..
X
bnug, dude.
X.
yeah..
END_OF_FILE
if test 177 -ne `wc -c <'./inews/test'`; then
    echo shar: \"'./inews/test'\" unpacked with wrong size!
fi
# end of './inews/test'
fi
if test -f './inews/test1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./inews/test1'\"
else
echo shar: Extracting \"'./inews/test1'\" \(187 characters\)
sed "s/^X//" >'./inews/test1' <<'END_OF_FILE'
Path: ucbdean!phil
From: phil@ucbdean.BERKELEY.EDU
Subject: testosterone
Newsgroups: ucb.test
Distribution: ucb
Follow-up: ucb.test
Extra-entry: and another thing..
X
bnug, dude.
X.
yeah..
END_OF_FILE
if test 187 -ne `wc -c <'./inews/test1'`; then
    echo shar: \"'./inews/test1'\" unpacked with wrong size!
fi
# end of './inews/test1'
fi
if test -f './inews/test2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./inews/test2'\"
else
echo shar: Extracting \"'./inews/test2'\" \(197 characters\)
sed "s/^X//" >'./inews/test2' <<'END_OF_FILE'
Subject: test of remote inews posting
Newsgroups: ucb.test
Distribution: ucb
Follow-up: ucb.test
Extra-entry: and another thing..
X
X$NAME has an & in it; does full name above?
X
bnug, dude.
X.
yeah..
END_OF_FILE
if test 197 -ne `wc -c <'./inews/test2'`; then
    echo shar: \"'./inews/test2'\" unpacked with wrong size!
fi
# end of './inews/test2'
fi
if test ! -d './rrnpatches' ; then
    echo shar: Creating directory \"'./rrnpatches'\"
    mkdir './rrnpatches'
fi
if test -f './rrnpatches/MAKE_RRN_CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rrnpatches/MAKE_RRN_CHANGES'\"
else
echo shar: Extracting \"'./rrnpatches/MAKE_RRN_CHANGES'\" \(313 characters\)
sed "s/^X//" >'./rrnpatches/MAKE_RRN_CHANGES' <<'END_OF_FILE'
X#!/bin/sh
X
PATH=/usr/ucb:/usr/bin:/bin:/usr/local/bin:/usr/local
export PATH
X
for filename in Configure Makefile.SH Pnews.SH Rnmail.SH addng.c \
X	artio.c common.h final.c head.c init.c newsetup.SH newsgroups.SH \
X	ng.c ngdata.c ngdata.h rcstuff.c respond.c term.c util.c
do
patch $filename < ${filename}.pat
done
END_OF_FILE
if test 313 -ne `wc -c <'./rrnpatches/MAKE_RRN_CHANGES'`; then
    echo shar: \"'./rrnpatches/MAKE_RRN_CHANGES'\" unpacked with wrong size!
fi
chmod +x './rrnpatches/MAKE_RRN_CHANGES'
# end of './rrnpatches/MAKE_RRN_CHANGES'
fi
if test -f './rrnpatches/Pnews.SH.pat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rrnpatches/Pnews.SH.pat'\"
else
echo shar: Extracting \"'./rrnpatches/Pnews.SH.pat'\" \(1205 characters\)
sed "s/^X//" >'./rrnpatches/Pnews.SH.pat' <<'END_OF_FILE'
X*** rn/Pnews.SH	Sun Mar 15 19:54:30 1987
X--- rrn/Pnews.SH	Sun Mar 15 23:55:35 1987
X***************
X*** 39,44
X  define)
X  # your site name
X  sitename=\`$hostcmd\`
X  # where recordings, distributions and moderators are kept
X  lib=\`$filexp $lib\`
X  # where important rn things are kept
X
X--- 39,51 -----
X  define)
X  # your site name
X  sitename=\`$hostcmd\`
X+ case \$sitename in
X+ 	*.*)
X+ 		;;
X+ 	*)
X+ 		sitename=\${sitename}.$domain
X+ 		;;
X+ esac
X  # where recordings, distributions and moderators are kept
X  lib=\`$filexp $lib\`
X  # where important rn things are kept
X***************
X*** 630,635
X  esac
X  
X  $cat > $tmpart <<EOHeader
X  Newsgroups: $ng
X  Subject: $title
X  Expires: 
X
X--- 637,644 -----
X  esac
X  
X  $cat > $tmpart <<EOHeader
X+ From: $logname@$sitename ($fullname)
X+ Path: $sitename!$logname
X  Newsgroups: $ng
X  Subject: $title
X  Expires: 
X***************
X*** 635,641
X  Expires: 
X  References: 
X  Sender: 
X! Reply-To: $logname@$sitename.UUCP ($fullname)
X  Followup-To: $follow
X  Distribution: $dist
X  Organization: $orgname
X
X--- 644,650 -----
X  Expires: 
X  References: 
X  Sender: 
X! Reply-To: $logname@$sitename ($fullname)
X  Followup-To: $follow
X  Distribution: $dist
X  Organization: $orgname
END_OF_FILE
if test 1205 -ne `wc -c <'./rrnpatches/Pnews.SH.pat'`; then
    echo shar: \"'./rrnpatches/Pnews.SH.pat'\" unpacked with wrong size!
fi
# end of './rrnpatches/Pnews.SH.pat'
fi
if test -f './rrnpatches/README_RRN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rrnpatches/README_RRN'\"
else
echo shar: Extracting \"'./rrnpatches/README_RRN'\" \(812 characters\)
sed "s/^X//" >'./rrnpatches/README_RRN' <<'END_OF_FILE'
Updated hacks to change rn into rrn	25 Feb 1988
X
Everything is now automated to install the changes.  There may
be some breakage if you apply these patches and don't want things
built as rrn, since I haven't tested that at all.  In summary,
apply these patches only if you want rrn.  [Sorry, Gene, for
botching this.]
X
To apply: copy this directory into a COPY of your rn #39 source.
Then type "MAKE_RRN_CHANGES".  You should now be able to run
Configure as usual.
X
X[The original patches and the MAKE_RRN_CHANGES script were the original
work of Gene Spafford.  However, the current version of rrn, #39, is not
up to snuff and you can't quite have both the rrn and rn version live in
the same directory.  The blame for this rests on my shoulders.
BTW, rn version 39 is available on ucbvax.berkeley.edu.  --Phil]
END_OF_FILE
if test 812 -ne `wc -c <'./rrnpatches/README_RRN'`; then
    echo shar: \"'./rrnpatches/README_RRN'\" unpacked with wrong size!
fi
# end of './rrnpatches/README_RRN'
fi
if test -f './rrnpatches/Rnmail.SH.pat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rrnpatches/Rnmail.SH.pat'\"
else
echo shar: Extracting \"'./rrnpatches/Rnmail.SH.pat'\" \(519 characters\)
sed "s/^X//" >'./rrnpatches/Rnmail.SH.pat' <<'END_OF_FILE'
X*** rn/Rnmail.SH	Sun Mar 15 19:54:38 1987
X--- rrn/Rnmail.SH	Mon Mar 16 09:15:08 1987
X***************
X*** 36,42
X  
X  # your site name
X  case $portable in
X! define) sitename=\`$hostcmd\` ;;
X  undef) sitename="$sitename" ;;
X  esac
X  # your organization name
X
X--- 36,51 -----
X  
X  # your site name
X  case $portable in
X! define)
X! 	sitename=\`$hostcmd\`
X! 	case \$sitename in
X! 		*.*)
X! 			;;
X! 		*)
X! 			sitename=\${sitename}.$domain
X! 			;;
X! 	esac
X! 	;;
X  undef) sitename="$sitename" ;;
X  esac
X  # your organization name
END_OF_FILE
if test 519 -ne `wc -c <'./rrnpatches/Rnmail.SH.pat'`; then
    echo shar: \"'./rrnpatches/Rnmail.SH.pat'\" unpacked with wrong size!
fi
# end of './rrnpatches/Rnmail.SH.pat'
fi
if test -f './rrnpatches/addng.c.pat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rrnpatches/addng.c.pat'\"
else
echo shar: Extracting \"'./rrnpatches/addng.c.pat'\" \(1113 characters\)
sed "s/^X//" >'./rrnpatches/addng.c.pat' <<'END_OF_FILE'
X*** rn/addng.c	Sun Mar 15 19:54:42 1987
X--- rrn/addng.c	Sun Mar 15 20:10:54 1987
X***************
X*** 1,3
X  /* $Header: addng.c,v 4.3.1.2 85/05/29 09:06:24 lwall Exp $
X   *
X   * $Log:	addng.c,v $
X
X--- 1,7 -----
X+ /*
X+  * Hacked for rrn
X+  */
X+ 
X  /* $Header: addng.c,v 4.3.1.2 85/05/29 09:06:24 lwall Exp $
X   *
X   * $Log:	addng.c,v $
X***************
X*** 109,114
X      char tst[128];
X      long time();
X   
X      sprintf(tst, ngsize ? "%s/%s/1" : "%s/%s" ,spool,getngdir(ngnam));
X      if (stat(tst,&filestat) < 0)
X  	return (ngsize ? 0L : time(Null(long *)));
X
X--- 113,124 -----
X      char tst[128];
X      long time();
X   
X+ #ifdef SERVER
X+ 
X+     return (ngsize < 2 ? time(0) : 0);
X+ 
X+ #else not SERVER
X+ 
X      sprintf(tst, ngsize ? "%s/%s/1" : "%s/%s" ,spool,getngdir(ngnam));
X      if (stat(tst,&filestat) < 0)
X  	return (ngsize ? 0L : time(Null(long *)));
X***************
X*** 115,120
X  	/* not there, assume something good */
X      else
X  	return filestat.st_mtime;
X  }
X  
X  bool
X
X--- 125,132 -----
X  	/* not there, assume something good */
X      else
X  	return filestat.st_mtime;
X+ 
X+ #endif
X  }
X  
X  bool
END_OF_FILE
if test 1113 -ne `wc -c <'./rrnpatches/addng.c.pat'`; then
    echo shar: \"'./rrnpatches/addng.c.pat'\" unpacked with wrong size!
fi
# end of './rrnpatches/addng.c.pat'
fi
if test -f './rrnpatches/final.c.pat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rrnpatches/final.c.pat'\"
else
echo shar: Extracting \"'./rrnpatches/final.c.pat'\" \(1178 characters\)
sed "s/^X//" >'./rrnpatches/final.c.pat' <<'END_OF_FILE'
X*** rn/final.c	Sun Mar 15 19:54:39 1987
X--- rrn/final.c	Mon Jul 13 15:48:50 1987
X***************
X*** 15,20
X  #include "bits.h"
X  #include "last.h"
X  #include "rcstuff.h"
X  #include "INTERN.h"
X  #include "final.h"
X  
X
X--- 15,22 -----
X  #include "bits.h"
X  #include "last.h"
X  #include "rcstuff.h"
X+ #include "ngdata.h"
X+ #include "artio.h"
X  #include "INTERN.h"
X  #include "final.h"
X  
X***************
X*** 51,56
X  finalize(status)
X  int status;
X  {
X      if (bizarre)
X  	resetty();
X      UNLINK(lockname);
X
X--- 53,62 -----
X  finalize(status)
X  int status;
X  {
X+ #ifdef SERVER
X+     char artname[32];
X+ #endif SERVER
X+ 
X      if (bizarre)
X  	resetty();
X      UNLINK(lockname);
X***************
X*** 54,59
X      if (bizarre)
X  	resetty();
X      UNLINK(lockname);
X      if (status < 0) {
X  	chdir("/usr/tmp");
X  	sigset(SIGILL,SIG_DFL);
X
X--- 60,73 -----
X      if (bizarre)
X  	resetty();
X      UNLINK(lockname);
X+ #ifdef SERVER
X+     if (openart > 0) {
X+ 	sprintf(artname, "/tmp/rrn%ld.%ld", openart, getpid());
X+         UNLINK(artname);
X+     }
X+     UNLINK(active_name);
X+     close_server();
X+ #endif SERVER
X      if (status < 0) {
X  	chdir("/usr/tmp");
X  	sigset(SIGILL,SIG_DFL);
END_OF_FILE
if test 1178 -ne `wc -c <'./rrnpatches/final.c.pat'`; then
    echo shar: \"'./rrnpatches/final.c.pat'\" unpacked with wrong size!
fi
# end of './rrnpatches/final.c.pat'
fi
if test -f './rrnpatches/newsgroups.SH.pat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rrnpatches/newsgroups.SH.pat'\"
else
echo shar: Extracting \"'./rrnpatches/newsgroups.SH.pat'\" \(1341 characters\)
sed "s/^X//" >'./rrnpatches/newsgroups.SH.pat' <<'END_OF_FILE'
X*** rn/newsgroups.SH	Sun Mar 15 19:54:46 1987
X--- rrn/newsgroups.SH	Thu Feb 25 20:35:38 1988
X***************
X*** 1,5
X  case $CONFIG in
X!     '') . config.sh ;;
X  esac
X  echo "Extracting newsgroups (with variable substitutions)"
X  $spitshell >newsgroups <<!GROK!THIS!
X
X--- 1,5 -----
X  case $CONFIG in
X!     '') . ./config.sh ;;
X  esac
X  echo "Extracting newsgroups (with variable substitutions)"
X  $spitshell >newsgroups <<!GROK!THIS!
X***************
X*** 20,26
X  : You might want to change pager to a "make column" program if you have one.
X  : On the other hand, if your kernel does paging, cat would probably do.
X  pager="${pager-/usr/ucb/more}"
X! active="${active-/usr/lib/news/active}"
X  
X  : End of system dependencies, hopefully
X  
X
X--- 20,26 -----
X  : You might want to change pager to a "make column" program if you have one.
X  : On the other hand, if your kernel does paging, cat would probably do.
X  pager="${pager-/usr/ucb/more}"
X! active="/tmp/active.\$\$"
X  
X  : End of system dependencies, hopefully
X  
X***************
X*** 24,32
X  
X  : End of system dependencies, hopefully
X  
X! case \$active in
X! ~*) active=\`$filexp \$active\` ;;
X! esac
X  
X  if $test \$# -ge 2 ; then
X      pager=$cat
X
X--- 24,30 -----
X  
X  : End of system dependencies, hopefully
X  
X! $rnlib/getactive \$active
X  
X  if $test \$# -ge 2 ; then
X      pager=$cat
END_OF_FILE
if test 1341 -ne `wc -c <'./rrnpatches/newsgroups.SH.pat'`; then
    echo shar: \"'./rrnpatches/newsgroups.SH.pat'\" unpacked with wrong size!
fi
# end of './rrnpatches/newsgroups.SH.pat'
fi
if test -f './rrnpatches/ngdata.h.pat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rrnpatches/ngdata.h.pat'\"
else
echo shar: Extracting \"'./rrnpatches/ngdata.h.pat'\" \(635 characters\)
sed "s/^X//" >'./rrnpatches/ngdata.h.pat' <<'END_OF_FILE'
X*** rn/ngdata.h	Sun Mar 15 19:54:52 1987
X--- rrn/ngdata.h	Sun Mar 15 22:37:32 1987
X***************
X*** 10,15
X  EXT bool writesoft INIT(FALSE);	/* rewrite the soft pointer file? */
X  EXT int softtries INIT(0), softmisses INIT(0);
X  
X  #ifdef CACHEFIRST
X      EXT ART_NUM abs1st[MAXRCLINE];	/* 1st real article in newsgroup */
X  #else
X
X--- 10,19 -----
X  EXT bool writesoft INIT(FALSE);	/* rewrite the soft pointer file? */
X  EXT int softtries INIT(0), softmisses INIT(0);
X  
X+ #ifdef SERVER
X+     EXT char active_name[256];
X+ #endif
X+ 
X  #ifdef CACHEFIRST
X      EXT ART_NUM abs1st[MAXRCLINE];	/* 1st real article in newsgroup */
X  #else
END_OF_FILE
if test 635 -ne `wc -c <'./rrnpatches/ngdata.h.pat'`; then
    echo shar: \"'./rrnpatches/ngdata.h.pat'\" unpacked with wrong size!
fi
# end of './rrnpatches/ngdata.h.pat'
fi
if test -f './rrnpatches/term.c.pat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rrnpatches/term.c.pat'\"
else
echo shar: Extracting \"'./rrnpatches/term.c.pat'\" \(844 characters\)
sed "s/^X//" >'./rrnpatches/term.c.pat' <<'END_OF_FILE'
X*** rn/term.c	Sun Mar 15 19:54:29 1987
X--- rrn/term.c	Wed Aug 19 21:37:40 1987
X***************
X*** 190,195
X      }
X      LINES = tgetnum("li");		/* lines per page */
X      COLS = tgetnum("co");		/* columns on page */
X      AM = tgetflag("am");		/* terminal wraps automatically? */
X      XN = tgetflag("xn");		/* then eats next newline? */
X      VB = Tgetstr("vb");
X
X--- 190,205 -----
X      }
X      LINES = tgetnum("li");		/* lines per page */
X      COLS = tgetnum("co");		/* columns on page */
X+ 
X+ #ifdef TIOCGWINSZ
X+     { struct winsize ws;
X+ 	if (ioctl(0, TIOCGWINSZ, &ws) >= 0 && ws.ws_row > 0 && ws.ws_col > 0) {
X+ 	    LINES = ws.ws_row;
X+ 	    COLS = ws.ws_col;
X+ 	}
X+     }
X+ #endif
X+ 	
X      AM = tgetflag("am");		/* terminal wraps automatically? */
X      XN = tgetflag("xn");		/* then eats next newline? */
X      VB = Tgetstr("vb");
END_OF_FILE
if test 844 -ne `wc -c <'./rrnpatches/term.c.pat'`; then
    echo shar: \"'./rrnpatches/term.c.pat'\" unpacked with wrong size!
fi
# end of './rrnpatches/term.c.pat'
fi
if test -f './rrnpatches/util.c.pat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./rrnpatches/util.c.pat'\"
else
echo shar: Extracting \"'./rrnpatches/util.c.pat'\" \(676 characters\)
sed "s/^X//" >'./rrnpatches/util.c.pat' <<'END_OF_FILE'
X*** rn/util.c	Sun Mar 15 19:54:32 1987
X--- rrn/util.c	Sun Mar 15 20:50:30 1987
X***************
X*** 45,50
X      else if ((shell = getenv("SHELL")) == Nullch || !*shell)
X  	shell = PREFSHELL;
X      if ((pid = vfork()) == 0) {
X  	if (*s)
X  	    execl(shell, shell, "-c", s, Nullch);
X  	else
X
X--- 45,59 -----
X      else if ((shell = getenv("SHELL")) == Nullch || !*shell)
X  	shell = PREFSHELL;
X      if ((pid = vfork()) == 0) {
X+ #ifdef SERVER
X+         int i;
X+ 
X+ 	/* This is necessary to keep bourne shell from puking */
X+ 
X+         for (i = 3; i < 10; ++i)
X+                 (void) close(i);
X+ #endif SERVER
X+ 
X  	if (*s)
X  	    execl(shell, shell, "-c", s, Nullch);
X  	else
END_OF_FILE
if test 676 -ne `wc -c <'./rrnpatches/util.c.pat'`; then
    echo shar: \"'./rrnpatches/util.c.pat'\" unpacked with wrong size!
fi
# end of './rrnpatches/util.c.pat'
fi
if test ! -d './server' ; then
    echo shar: Creating directory \"'./server'\"
    mkdir './server'
fi
if test -f './server/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/Makefile'\"
else
echo shar: Extracting \"'./server/Makefile'\" \(1342 characters\)
sed "s/^X//" >'./server/Makefile' <<'END_OF_FILE'
X#
X# Makefile for NNTP server
X#
X
SRVROBJ = main.o serve.o access.o access_inet.o access_dnet.o active.o \
X	ahbs.o globals.o group.o help.o ihave.o list.o misc.o netaux.o \
X	newgroups.o newnews.o nextlast.o ngmatch.o post.o parsit.o scandir.o \
X	slave.o spawn.o strcasecmp.o subnet.o time.o xhdr.o fakesyslog.o \
X	../common/version.o
X
SRVRSRC = main.c serve.c access.c access_inet.c access_dnet.c active.c \
X	ahbs.c globals.c group.c help.c ihave.c list.c misc.c netaux.c \
X	newgroups.c newnews.c nextlast.c ngmatch.c post.c parsit.c scandir.c \
X	slave.c spawn.c strcasecmp.c subnet.c time.c xhdr.c fakesyslog.c \
X	../common/version.c
X
SRVRINC = common.h ../common/conf.h ../common/nntp.h
X
SRCS	= ${SRVRSRC}
X
X# -ldbm here if you've #define'ed DBM in ../common/conf.h
LIBS	=
X
CFLAGS	= -O
X
X# Where nntpd is going to live
X
DESTDIR	= /etc
X
all:	nntpd
X
nntpd: ${SRVROBJ} ${SRVRINC}
X	${CC} ${CFLAGS} -o nntpd ${SRVROBJ} ${LIBS}
X
X${SRVROBJ}: ${SRVRINC}
X
install: nntpd
X	cp nntpd ${DESTDIR}/nntpd
X	chmod 711 ${DESTDIR}/nntpd
X
lint:
X	lint ${SRVRSRC}
X
clean:
X	-rm -f *.o nntpd make*.out a.out
X
distrib: clean
X	rm -rf SCCS save tags
X
check:
X	sccs check
X	sccs prt -y *.[ch] > /dev/null
X
tags:	${SRVRSRC} ${SRVRINC}
X	ctags ${SRVRSRC} ${SRVRINC}
X
X# Dependencies
X
X../common/version.o:
X	${CC} ${CFLAGS} -c ../common/version.c
X	mv version.o ../common/version.o
END_OF_FILE
if test 1342 -ne `wc -c <'./server/Makefile'`; then
    echo shar: \"'./server/Makefile'\" unpacked with wrong size!
fi
# end of './server/Makefile'
fi
if test -f './server/access_dnet.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/access_dnet.c'\"
else
echo shar: Extracting \"'./server/access_dnet.c'\" \(1413 characters\)
sed "s/^X//" >'./server/access_dnet.c' <<'END_OF_FILE'
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/types.h>
X
X#include "common.h"
X
X#ifdef DECNET
X
X#ifndef lint
static	char	*sccsid = "@(#)access_dnet.c	1.6	(Berkeley) 1/9/88";
X#endif
X
X
X/*
X * dnet_netnames -- return the network, subnet, and host names of
X * our peer process for the DECnet domain.  Since DECnet doesn't
X * have subnets, we always return "subnet_name"'s first char as '\0';
X *
X *	Parameters:	"sock" is the socket connect to our peer.
X *			"sap" is a pointer to the result of
X *			a getpeername() call.
X *			"net_name", "subnet_name", and "host_name"
X *			are filled in by this routine with the
X *			corresponding ASCII names of our peer.
X *	Returns:	Nothing.
X *	Side effects:	None.
X */
X
dnet_netnames(sock, sap, net_name, subnet_name, host_name)
X	int		sock;
X	struct sockaddr	*sap;
X	char		*net_name;
X	char		*subnet_name;
X	char		*host_name;
X{
X	char		*cp;
X	struct linger	l;
X	char		*getenv();
X
X	cp = getenv("NETWORK");
X	(void) strcpy(net_name, cp ? cp : "DECnet");
X
X	cp = getenv("REMNODE");
X	(void) strcpy(host_name, cp ? cp : "unknown");
X
X	*subnet_name = '\0';
X
X	/*
X	 * Give decnet a chance to flush its buffers before the
X 	 * link is killed.
X	 */
X
X	l.l_onoff = 1;		/* on */
X	l.l_linger = 15;	/* seconds */
X
X	if (setsockopt(sock, SOL_SOCKET, SO_LINGER, (char *) &l,
X		sizeof (l)) < 0) {
X#ifdef LOG
X		syslog(LOG_ERR,
X			"access_dnet: setsockopt SOL_SOCKET SO_LINGER: %m");
X#endif
X	}
X}
X#endif
END_OF_FILE
if test 1413 -ne `wc -c <'./server/access_dnet.c'`; then
    echo shar: \"'./server/access_dnet.c'\" unpacked with wrong size!
fi
# end of './server/access_dnet.c'
fi
if test -f './server/fakesyslog.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/fakesyslog.c'\"
else
echo shar: Extracting \"'./server/fakesyslog.c'\" \(1518 characters\)
sed "s/^X//" >'./server/fakesyslog.c' <<'END_OF_FILE'
X#ifndef lint
static char	*sccsid = "@(#)fakesyslog.c	1.3	(Berkeley) 2/6/88";
X#endif
X
X/*
X * Fake syslog routines for systems that don't have syslog.
X * Taken from an idea by Paul McKenny, <mckenny@sri-unix.arpa>.
X * (Unfortunately, Paul, I can't distribute the real syslog code
X * as you suggested ... sigh.)
X *
X * Warning: this file contains joe code that may offend you.
X */
X
X#include <stdio.h>
X
X#include "../common/conf.h"
X
X#ifdef FAKESYSLOG
X
extern	int	errno;
extern	int	sys_nerr;
extern	char	*sys_errlist[];
X
static FILE	*logfp;
X
char	*strcpy(), *strcat(), *ctime();
X
openlog()
X{
X	logfp = fopen(FAKESYSLOG, "a");
X}
X
X
syslog(pri, msg, x1, x2, x3, x4, x5, x6)
X	int	pri;
X	char	*msg, *x1, *x2, *x3, *x4, *x5, *x6;
X{
X	char		buf[1024];
X	char		*cp, *bp;
X	long		clock;
X	static int	failed = 0;
X
X	if (failed)
X		return;
X
X	if (logfp == NULL) {
X		openlog();
X		if (logfp == NULL) {
X			failed = 1;
X			return;
X		}
X	}
X
X	(void) time(&clock);
X	(void) strcpy(buf, ctime(&clock));
X
X	bp = buf + strlen(buf)-1;
X	*bp++ = ' ';
X	*bp = '\0';
X	for (cp = msg; *cp; cp++) {
X		if (*cp == '%' && cp[1] == 'm') {
X			*bp = '\0';
X			if (errno >= sys_nerr || errno < 0) {
X				char	work[32];
X				sprintf(work, "unknown error #%d", errno);
X				(void) strcat(bp, work);
X			} else
X				(void) strcat(bp, sys_errlist[errno]);
X			bp = buf + strlen(buf);
X			cp++;
X		} else {
X			*bp++ = *cp;
X		}
X	}
X	*bp = '\0';
X	/* Ah, the semantic security of C ... */
X	if (bp[-1] != '\n')
X		(void) strcat(bp, "\n");
X
X	fprintf(logfp, buf, x1, x2, x3, x4, x5, x6);
X}
X
X#endif
END_OF_FILE
if test 1518 -ne `wc -c <'./server/fakesyslog.c'`; then
    echo shar: \"'./server/fakesyslog.c'\" unpacked with wrong size!
fi
# end of './server/fakesyslog.c'
fi
if test -f './server/fakesyslog.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/fakesyslog.h'\"
else
echo shar: Extracting \"'./server/fakesyslog.h'\" \(953 characters\)
sed "s/^X//" >'./server/fakesyslog.h' <<'END_OF_FILE'
X/*
X * Fake syslog definitions.
X *
X * @(#)fakesyslog.h	1.1	(Berkeley) 12/18/87
X */
X
X#ifdef FAKESYSLOG
X
X/*
X *  Facility codes
X */
X
X#define LOG_KERN	0
X#define LOG_USER	0
X#define LOG_MAIL	0
X#define LOG_DAEMON	0
X#define LOG_AUTH	0
X#define LOG_SYSLOG	0
X#define LOG_LPR		0
X#define LOG_NEWS	0
X#define LOG_LOCAL0	0
X#define LOG_LOCAL1	0
X#define LOG_LOCAL2	0
X#define LOG_LOCAL3	0
X#define LOG_LOCAL4	0
X#define LOG_LOCAL5	0
X#define LOG_LOCAL6	0
X#define LOG_LOCAL7	0
X
X#define LOG_NFACILITIES	0
X#define LOG_FACMASK	0
X
X/*
X *  Priorities
X */
X
X#define LOG_EMERG	0
X#define LOG_ALERT	0
X#define LOG_CRIT	0
X#define LOG_ERR		0
X#define LOG_WARNING	0
X#define LOG_NOTICE	0
X#define LOG_INFO	0
X#define LOG_DEBUG	0
X
X#define LOG_PRIMASK	0
X
X/*
X * arguments to setlogmask.
X */
X
X#define	LOG_MASK(pri)	0
X#define	LOG_UPTO(pri)	0
X
X/*
X *  Option flags for openlog.
X */
X
X#define	LOG_PID		0
X#define	LOG_CONS	0
X#define	LOG_ODELAY	0
X#define LOG_NDELAY	0
X#define LOG_NOWAIT	0
X
X#endif FAKESYSLOG
END_OF_FILE
if test 953 -ne `wc -c <'./server/fakesyslog.h'`; then
    echo shar: \"'./server/fakesyslog.h'\" unpacked with wrong size!
fi
# end of './server/fakesyslog.h'
fi
if test -f './server/globals.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/globals.c'\"
else
echo shar: Extracting \"'./server/globals.c'\" \(697 characters\)
sed "s/^X//" >'./server/globals.c' <<'END_OF_FILE'
X#ifndef lint
static char	*sccsid = "@(#)globals.c	1.4	(Berkeley) 7/17/87";
X#endif
X
X/*
X * Common variables.
X */
X
X#include "common.h"
X
X/*
X * Variables initialized from ../common/conf.h
X */
X
char	spooldir[] = SPOOLDIR;
char	activefile[] = ACTIVE_FILE;
char	accessfile[] = ACCESS_FILE;
char	historyfile[] = HISTORY_FILE;
char	ngdatefile[] = NGDATE_FILE;
char	inews[] = INEWS;
char	rnews[] = RNEWS;
X
X/*
X * Other random externals.
X */
X
char	**group_array;
int	num_groups;
int	ingroup = 0;
int	art_ptr;
int	num_arts;
int	art_array[MAX_ARTICLES];
FILE	*art_fp;
int	uid_poster, gid_poster;
int	canpost, canread, canxfer;
char	**ngpermlist;
int	ngpermcount;
X
X#ifdef LOG
int	arts_acsd;
int	grps_acsd;
X#endif
END_OF_FILE
if test 697 -ne `wc -c <'./server/globals.c'`; then
    echo shar: \"'./server/globals.c'\" unpacked with wrong size!
fi
# end of './server/globals.c'
fi
if test -f './server/help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/help.c'\"
else
echo shar: Extracting \"'./server/help.c'\" \(833 characters\)
sed "s/^X//" >'./server/help.c' <<'END_OF_FILE'
X#ifndef lint
static char	*sccsid = "@(#)help.c	1.7	(Berkeley) 6/26/87";
X#endif
X
X#include "common.h"
X
X/*
X * HELP
X *
X * Provide a naive user with a brief help message.
X *
X */
X
help(argc, argv)
int	argc;
char	*argv[];
X{
X	printf("%d This server accepts the following commands:\r\n", INF_HELP);
X	printf("ARTICLE     BODY         GROUP\r\n");
X	printf("HEAD        LAST         LIST\r\n");
X	printf("NEXT        POST         QUIT\r\n");
X	printf("STAT        NEWGROUPS    HELP\r\n");
X	printf("IHAVE       NEWNEWS      SLAVE\r\n");
X	printf("\r\nAdditionally, the following extention is supported:\r\n\r\n");
X	printf("XHDR        Retrieve a single header line from a range of articles.\r\n");
X	printf("\r\n");
X	printf("Bugs to Phil Lapsley (Internet: phil@berkeley.edu; UUCP: ...!ucbvax!phil)\r\n");
X	printf(".\r\n");
X	(void) fflush(stdout);
X}
END_OF_FILE
if test 833 -ne `wc -c <'./server/help.c'`; then
    echo shar: \"'./server/help.c'\" unpacked with wrong size!
fi
# end of './server/help.c'
fi
if test -f './server/ihave.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/ihave.c'\"
else
echo shar: Extracting \"'./server/ihave.c'\" \(1236 characters\)
sed "s/^X//" >'./server/ihave.c' <<'END_OF_FILE'
X#ifndef lint
static char	*sccsid = "@(#)ihave.c	1.11	(Berkeley) 1/11/88";
X#endif
X
X#include "common.h"
X
X#ifdef LOG
int	ih_accepted;
int	ih_rejected;
int	ih_failed;
X#endif LOG
X
X/*
X * IHAVE <messageid>
X *
X * Accept an article for transferral if we haven't seen it before.
X */
X
ihave(argc, argv)
X	int		argc;
X	char		*argv[];
X{
X	char		errbuf[2 * NNTP_STRLEN];
X	int		retcode;
X	register char	*cp;
X
X	if (argc != 2) {
X		printf("%d Usage: IHAVE <message-id>.\r\n", ERR_CMDSYN);
X		(void) fflush(stdout);
X		return;
X	}
X
X	cp = gethistent(argv[1]);
X	if (cp != NULL) {
X		printf("%d Got it.\r\n", ERR_GOTIT);
X		(void) fflush(stdout);
X#ifdef LOG
X		ih_rejected++;
X#ifdef IHAVE_DEBUG
X		syslog(LOG_DEBUG, "%s ihave %s rejected", hostname, argv[1]);
X#endif IHAVE_DEBUG
X#endif LOG
X		return;
X	}
X		
X	retcode = spawn(rnews, "rnews", (char *) 0, CONT_XFER, ERR_XFERFAIL, errbuf);
X	if (retcode <= 0)
X		printf("%d %s\r\n", ERR_XFERFAIL, errbuf);
X	else if (retcode > 0)
X		printf("%d Thanks.\r\n",
X			OK_XFERED);
X	(void) fflush(stdout);
X
X#ifdef LOG
X	if (retcode == 1)
X		ih_accepted++;
X	else
X		ih_failed++;
X		
X#ifdef IHAVE_DEBUG
X	syslog(LOG_DEBUG, "%s ihave %s accepted %s",
X		hostname, argv[1], retcode == 1 ? "succeeded" : "failed");
X#endif IHAVE_DEBUG
X#endif LOG
X
X}
END_OF_FILE
if test 1236 -ne `wc -c <'./server/ihave.c'`; then
    echo shar: \"'./server/ihave.c'\" unpacked with wrong size!
fi
# end of './server/ihave.c'
fi
if test -f './server/list.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/list.c'\"
else
echo shar: Extracting \"'./server/list.c'\" \(979 characters\)
sed "s/^X//" >'./server/list.c' <<'END_OF_FILE'
X#ifndef lint
static char	*sccsid = "@(#)list.c	1.10	(Berkeley) 2/6/88";
X#endif
X
X#include "common.h"
X
X/*
X * LIST
X *
X * List active newsgroups.
X *
X */
X
list(argc, argv)
X	int		argc;
X	char		*argv[];
X{
X	char		line[NNTP_STRLEN];
X	char		*grparray[2];
X	register char	*cp;
X	register FILE	*active_fp;
X
X	grparray[0] = line;
X	grparray[1] = NULL;
X
X	active_fp = fopen(activefile, "r");
X
X	if (active_fp == NULL) {
X		printf("%d No list of newsgroups available.\r\n", ERR_FAULT);
X		(void) fflush(stdout);
X#ifdef SYSLOG
X		syslog(LOG_ERR, "list: fopen %s: %m", activefile);
X#endif
X		return;
X	}
X
X	printf("%d Newsgroups in form \"group high low y/n/m\".\r\n",
X		OK_GROUPS);
X
X	while (fgets(line, sizeof(line), active_fp) != NULL) {
X		if ((cp = index(line, '\n')) != NULL)
X			*cp = '\0';
X		if (ngpermcount)
X			if (ngmatch(s1strneql, ALLBUT,
X			    ngpermlist, ngpermcount,
X			    grparray, 1) == 0)
X				continue;
X		putline(line);
X	}
X	(void) fclose(active_fp);
X
X	putline(".");
X	(void) fflush(stdout);
X}
END_OF_FILE
if test 979 -ne `wc -c <'./server/list.c'`; then
    echo shar: \"'./server/list.c'\" unpacked with wrong size!
fi
# end of './server/list.c'
fi
if test -f './server/post.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/post.c'\"
else
echo shar: Extracting \"'./server/post.c'\" \(1047 characters\)
sed "s/^X//" >'./server/post.c' <<'END_OF_FILE'
X#ifndef lint
static char	*sccsid = "@(#)post.c	1.12	(Berkeley) 1/11/88";
X#endif
X
X#include "common.h"
X
X/*
X * POST
X *
X * Post an article to a set of newsgroups.
X */
X
post(argc, argv)
X	int	argc;
X	char	*argv[];
X{
X	char	errbuf[2 * NNTP_STRLEN];
X	int	retcode;
X
X	if (!canpost) {
X		printf("%d Sorry, you're not allowed to post.\r\n",
X			ERR_NOPOST);
X#ifdef LOG
X			syslog(LOG_INFO, "%s post rejected", hostname);
X#endif
X		(void) fflush(stdout);
X		return;
X	}
X
X#ifdef POSTER
X	if (uid_poster == 0) {
X		printf("%d User %s does not exist!  Can't post.\r\n",
X			ERR_POSTFAIL, POSTER);
X#ifdef SYSLOG
X		syslog(LOG_ERR, "post: User %s does not exist.", POSTER);
X#endif
X		(void) fflush(stdout);
X		return;
X	}
X#endif
X
X	retcode = spawn(inews, "inews", "-h", CONT_POST, ERR_POSTFAIL, errbuf);
X	if (retcode <= 0)
X		printf("%d %s\r\n", ERR_POSTFAIL, errbuf);
X	else if (retcode > 0)
X		printf("%d Article posted successfully.\r\n", OK_POSTED);
X	(void) fflush(stdout);
X
X#ifdef LOG
X	syslog(LOG_INFO, "%s post %s", hostname,
X			retcode == 1 ? "succeeded" : "failed");
X#endif
X}
END_OF_FILE
if test 1047 -ne `wc -c <'./server/post.c'`; then
    echo shar: \"'./server/post.c'\" unpacked with wrong size!
fi
# end of './server/post.c'
fi
if test -f './server/profile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/profile.c'\"
else
echo shar: Extracting \"'./server/profile.c'\" \(381 characters\)
sed "s/^X//" >'./server/profile.c' <<'END_OF_FILE'
X#ifndef lint
static char	*sccsid = "@(#)profile.c	1.1	(Berkeley) 12/18/87";
X#endif
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#define	MON	"gmon.out"
X#define	DIR	"/usr/tmp/nntpd.prof"
X
profile()
X{
X	static char	tmp[] = "gmon.XXXXXX";
X	struct stat	statbuf;
X
X	if (chdir(DIR) < 0)
X		return;
X
X	if (stat(MON, statbuf) < 0)
X		return;
X
X	(void) mktemp(tmp);
X
X	(void) rename(MON, tmp);
X}
END_OF_FILE
if test 381 -ne `wc -c <'./server/profile.c'`; then
    echo shar: \"'./server/profile.c'\" unpacked with wrong size!
fi
# end of './server/profile.c'
fi
if test -f './server/scandir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/scandir.c'\"
else
echo shar: Extracting \"'./server/scandir.c'\" \(1300 characters\)
sed "s/^X//" >'./server/scandir.c' <<'END_OF_FILE'
X#ifndef lint
static char	*sccsid = "@(#)scandir.c	1.3	(Berkeley) 6/26/87";
X#endif
X
X#include "common.h"
X
X/*
X * scan_dir -- scan the current directory for news articles,
X *	loading the article numbers into art_array.  Return
X *	number of articles loaded.
X *
X *	Paramaters:	"low_msg", "high_msg" are the low
X *			and high messages numbers in this
X *			group; we ignore numbers outside this
X *			range.
X *
X *	Returns:	Number of articles loaded into
X *			array.
X *
X *	Side effects:	Changes "art_array".
X */
X
extern	int	intcmp();
X
scan_dir(low_msg, high_msg)
int	low_msg, high_msg;
X{
X	register struct direct	*dirent;
X	register DIR		*dirp;
X	int			artnum;
X
X	num_arts = 0;
X
X	dirp = opendir(".");
X
X	if (dirp == NULL)
X		return (0);
X
X	while ((dirent = readdir(dirp)) != NULL) {
X		artnum = atoi(dirent->d_name);
X		if (artnum != 0 && artnum >= low_msg && artnum <= high_msg)
X			art_array[num_arts++] = artnum;
X	}
X
X	closedir(dirp);
X
X	qsort((char *) art_array, num_arts, sizeof(int), intcmp);
X
X	return (num_arts);
X}
X
X
X/*
X * intcmp -- compare to integers.
X *
X *	Parameters:	"x", "y" point to the integers to be compared.
X *
X *	Returns:	-1 if "x" is less than "y",
X *			0 if "x" equals "y", and
X *			1 if "x" is greater than "y".
X *
X *	Side effects:	None.
X */
X
intcmp(x, y)
register int	*x, *y;
X{
X	return (*x - *y);
X}
END_OF_FILE
if test 1300 -ne `wc -c <'./server/scandir.c'`; then
    echo shar: \"'./server/scandir.c'\" unpacked with wrong size!
fi
# end of './server/scandir.c'
fi
if test -f './server/slave.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/slave.c'\"
else
echo shar: Extracting \"'./server/slave.c'\" \(350 characters\)
sed "s/^X//" >'./server/slave.c' <<'END_OF_FILE'
X#ifndef lint
static char	*sccsid = "@(#)slave.c	1.3	(Berkeley) 6/26/87";
X#endif
X
X#include "common.h"
X
X/*
X * SLAVE
X *
X * note slave status, which is actually unimplemented.
X */
X
slave(argc, argv)
X	int	argc;
X	char	*argv[];
X{
X	printf("%d Kinky, kinky.  I don't support such perversions.\r\n",
X		OK_SLAVE);		/* Thanks Serge! */
X	(void) fflush(stdout);
X}
END_OF_FILE
if test 350 -ne `wc -c <'./server/slave.c'`; then
    echo shar: \"'./server/slave.c'\" unpacked with wrong size!
fi
# end of './server/slave.c'
fi
if test -f './server/time.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./server/time.h'\"
else
echo shar: Extracting \"'./server/time.h'\" \(177 characters\)
sed "s/^X//" >'./server/time.h' <<'END_OF_FILE'
X/*
X * Time manipulation routines.
X *
X * @(#)time.h	1.1	(Berkeley) 12/18/87
X */
X
extern	long	dtol();
extern	char	*ltod();
extern	long	local_to_gmt();
extern	long	gmt_to_local();
END_OF_FILE
if test 177 -ne `wc -c <'./server/time.h'`; then
    echo shar: \"'./server/time.h'\" unpacked with wrong size!
fi
# end of './server/time.h'
fi
if test ! -d './support' ; then
    echo shar: Creating directory \"'./support'\"
    mkdir './support'
fi
if test -f './support/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./support/Makefile'\"
else
echo shar: Extracting \"'./support/Makefile'\" \(573 characters\)
sed "s/^X//" >'./support/Makefile' <<'END_OF_FILE'
X#
X# Makefile for NNTP server support programs
X#
X
OBJS	=	mkgrdates.o
X
SRCS	=	mkgrdates.c
X
HFILES	=	../common/conf.h
X
CFLAGS= -O
X
X# Where these support programs will live
X
DESTDIR	= /usr/lib/news
X
all: mkgrdates
X
mkgrdates: mkgrdates.o
X	$(CC) ${CFLAGS} -o mkgrdates mkgrdates.o
X
install: mkgrdates
X	cp mkgrdates ${DESTDIR}/mkgrdates
X	chmod 755 ${DESTDIR}/mkgrdates
X
lint:
X	lint mkgrdates.c
X
clean:
X	-rm -f *.o mkgrdates
X
distrib: clean
X	rm -rf SCCS old
X
check:
X	sccs check
X	sccs prt -y *.[ch] > /dev/null
X
tags:	${SRCS} ${HFILES}
X	ctags ${SRCS} ${HFILES}
X
X${OBJS}:	${HFILES}
END_OF_FILE
if test 573 -ne `wc -c <'./support/Makefile'`; then
    echo shar: \"'./support/Makefile'\" unpacked with wrong size!
fi
# end of './support/Makefile'
fi
if test -f './support/access_file' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./support/access_file'\"
else
echo shar: Extracting \"'./support/access_file'\" \(717 characters\)
sed "s/^X//" >'./support/access_file' <<'END_OF_FILE'
X#
X# Sample NNTP access file.  "read" implies "xfer".
X# Note that "default" must be the first entry in the
X# table.
X#
X# If you defined SUBNET when you compiled the server,
X# this file can have subnets as well as class A, B, C
X# networks and hosts.
X#
X# host/net	read/xfer/no	post/no
X#
X# by default, let anyone transfer news, but not read or post
default		xfer		no
X# hosts on the Berkeley campus can read and post news
ucb-ether	read		post
X# bugs, a notorious undergraduate machine, is not allowed
X# to read or post news at all.
bugs		read		no
X# ic can read and post news, but users on ic cannot read
X# articles in the group ucb.postgres or any of its decendents
X# (e.g., ucb.postgres.core)
ic		read		post	!ucb.postgres
END_OF_FILE
if test 717 -ne `wc -c <'./support/access_file'`; then
    echo shar: \"'./support/access_file'\" unpacked with wrong size!
fi
# end of './support/access_file'
fi
if test ! -d './xfer' ; then
    echo shar: Creating directory \"'./xfer'\"
    mkdir './xfer'
fi
if test -f './xfer/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./xfer/Makefile'\"
else
echo shar: Extracting \"'./xfer/Makefile'\" \(77 characters\)
sed "s/^X//" >'./xfer/Makefile' <<'END_OF_FILE'
X
clean:
X	-rm -f *.o nntpxfer make*.out
X
distrib: clean
X	rm -rf SCCS
X
check:;
END_OF_FILE
if test 77 -ne `wc -c <'./xfer/Makefile'`; then
    echo shar: \"'./xfer/Makefile'\" unpacked with wrong size!
fi
# end of './xfer/Makefile'
fi
if test -f './xfer/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./xfer/README'\"
else
echo shar: Extracting \"'./xfer/README'\" \(339 characters\)
sed "s/^X//" >'./xfer/README' <<'END_OF_FILE'
This is a "passive" news transmission client.  It queries
other servers for news with NEWNEWS and gets it via the article
command.
X
No docs, sorry.  It's unsupported (like the rest of the stuff is???).
Read the source code.
X
Originally written by Brian Kantor <brian@sdcsvax.ucsd.edu>, with some
bug fixes by Ambar <ambar@athena.mit.edu>.
END_OF_FILE
if test 339 -ne `wc -c <'./xfer/README'`; then
    echo shar: \"'./xfer/README'\" unpacked with wrong size!
fi
# end of './xfer/README'
fi
if test ! -d './xmit' ; then
    echo shar: Creating directory \"'./xmit'\"
    mkdir './xmit'
fi
if test -f './xmit/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./xmit/README'\"
else
echo shar: Extracting \"'./xmit/README'\" \(1444 characters\)
sed "s/^X//" >'./xmit/README' <<'END_OF_FILE'
X     The program "nntpxmit" is an active trnamission client
X(see the comment in nntpxmit.c for a description of the
difference between active and passive clients) written by Erik Fair
X<fair@ucbvax.berkeley.edu, ...!ucbvax!fair>.  A larger comment on
its inner workings can be found by looking at nntpxmit.c
X
X     To use nntpxmit, you should edit your news sys file to have
an entry like this:
X
X#
X# NASA Ames Research Center
X#
nike:ucb,uc,mod,to.nike:F:/usr/spool/news/batch/ames-titan.arpa
X
This will place names of news articles in the ucb, uc, and mod newsgroups
in the file "/usr/spool/news/batch/ames-titan.arpa".  This is because
we assume the output batch file will be the machine's internet name.
X
Periodically, you should have crontab run "nntpsend" to transmit
the news.  A good choice for "periodically" is every 10 minutes.
nntpsend depends on the program "shlock", which make should have
made already.  Also, nntpsend will need to be customized for your system.
Fortunately, it's pretty straightforward.
X
X     nntpxmit has an option "-s" which *supresses* statistic
logging via syslog.  Additionally, the "-d" option is availible
for debugging.
X
X     Please forward comments/suggestions for improvement/bugs to
Erik Fair, <fair@ucbvax.berkeley.edu>.
X
X     [My thanks extended to Erik for writing nntpxmit, shlock,
and the stats scripts.  My thanks also to Mel Pleasant
X<pleasant@topaz.rutgers.edu> for the nntpsend script.  --Phil]
END_OF_FILE
if test 1444 -ne `wc -c <'./xmit/README'`; then
    echo shar: \"'./xmit/README'\" unpacked with wrong size!
fi
# end of './xmit/README'
fi
if test -f './xmit/get_tcp_conn.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./xmit/get_tcp_conn.h'\"
else
echo shar: Extracting \"'./xmit/get_tcp_conn.h'\" \(510 characters\)
sed "s/^X//" >'./xmit/get_tcp_conn.h' <<'END_OF_FILE'
X/*
X** Return codes from get_tcp_conn().
X*/
X#ifndef	FAIL
X#define FAIL		(-1)		/* routine failed */
X#endif
X#define	NOHOST		(FAIL-1)	/* no such host */
X#define	NOSERVICE	(FAIL-2)	/* no such service */
X
X#ifndef NULL
X#define	NULL	0
X#endif
X
X#ifdef USG	/* brain-dead USG compilers can't deal with typedef */
X#define	u_long	unsigned long
X#define	u_short	unsigned short
X#endif
X
X#ifdef	EXCELAN
X#define	NONETDB
X#define	OLDSOCKET
X#endif
X
X#ifdef	NONETDB
X#define	IPPORT_NNTP	119		/* NNTP is on TCP port 119 */
X#endif	NONETDB
END_OF_FILE
if test 510 -ne `wc -c <'./xmit/get_tcp_conn.h'`; then
    echo shar: \"'./xmit/get_tcp_conn.h'\" unpacked with wrong size!
fi
# end of './xmit/get_tcp_conn.h'
fi
if test -f './xmit/llist.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./xmit/llist.c'\"
else
echo shar: Extracting \"'./xmit/llist.c'\" \(1179 characters\)
sed "s/^X//" >'./xmit/llist.c' <<'END_OF_FILE'
X/*
X** Routines for fiddlin' linked lists
X** Erik E. Fair <fair@ucbarpa.berkeley.edu>
X*/
X
X#include <sys/types.h>
X#include "llist.h"
X
extern free();
extern caddr_t	malloc();
X
X/*
X** a little wasteful for some cases, but it works, and I don't mind
X** the extra padding - think of it as insurance.
X*/
X#define	ALIGN(x)	((x) + (sizeof(long) - (x) % sizeof(long)))
X
X/*
X** recursively free a linked list
X*/
void
l_free(lp)
register ll_t *lp;
X{
X	if (lp->l_next == (ll_t *)NULL)
X		return;
X	l_free(lp->l_next);
X	(void) free(lp->l_item);
X}
X
X/*
X** allocate a new element in a linked list, along with enough space
X** at the end of the item for the next list element header.
X*/
ll_t *
l_alloc(lp, s, len)
register ll_t	*lp;
caddr_t	s;
register int len;
X{
X	if (s == (caddr_t)NULL || lp == (ll_t *)NULL || len <= 0)
X		return((ll_t *)NULL);
X
X	lp->l_len = len;
X	len = ALIGN(len);
X
X	if ((lp->l_item = malloc((unsigned)len + sizeof(ll_t))) == (caddr_t)NULL)
X		return((ll_t *)NULL);
X
X	bcopy(s, lp->l_item, lp->l_len);
X	lp->l_next = (ll_t *)(&lp->l_item[len]);
X
X	/*
X	** set up next list entry
X	*/
X	lp = lp->l_next;
X	lp->l_next = (ll_t *)NULL;
X	lp->l_item = (caddr_t)NULL;
X	lp->l_len = 0;
X	return(lp);
X}
END_OF_FILE
if test 1179 -ne `wc -c <'./xmit/llist.c'`; then
    echo shar: \"'./xmit/llist.c'\" unpacked with wrong size!
fi
# end of './xmit/llist.c'
fi
if test -f './xmit/llist.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./xmit/llist.h'\"
else
echo shar: Extracting \"'./xmit/llist.h'\" \(354 characters\)
sed "s/^X//" >'./xmit/llist.h' <<'END_OF_FILE'
X/*
X** Stuff for fiddlin' linked lists
X** Erik E. Fair <fair@ucbarpa.berkeley.edu>
X*/
X
struct llist {
X	struct llist	*l_next;
X	caddr_t		l_item;
X	int		l_len;
X};
X
typedef	struct llist	ll_t;
X
extern void	l_free();
extern ll_t	*l_alloc();
X
X#ifndef NULL
X#define NULL	0
X#endif
X
X#define	L_LOOP(p,head)	\
X	for(p = &head; p->l_item != (caddr_t)NULL; p = p->l_next)
END_OF_FILE
if test 354 -ne `wc -c <'./xmit/llist.h'`; then
    echo shar: \"'./xmit/llist.h'\" unpacked with wrong size!
fi
# end of './xmit/llist.h'
fi
if test -f './xmit/nntpsend.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./xmit/nntpsend.sh'\"
else
echo shar: Extracting \"'./xmit/nntpsend.sh'\" \(1365 characters\)
sed "s/^X//" >'./xmit/nntpsend.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X# What we have here is a csh script for sending netnews to NNTP sites.
X#
batchdir=/usr/spool/news/batch
libdir=/usr/spool/news/lib
PATH=${libdir}:/usr/ucb:/usr/bin:/bin:${PATH}
export PATH
pname=`basename $0`
echo ${pname}: "[$$]" begin `date`
X#
X# Go to where the action is
X#
cd $batchdir
umask 022
X#
X#	For NNTP
X#
X#	Here "foo", "bar", and "zot" are the Internet names of
X#	the machines to which to send.  We make the supposition
X#	that the batch files will be a host's internet name.
X#	So, for example "nike"'s internet name is "ames-titan.arpa".
X#	Because of this, your sys file must have "ames-titan.arpa"
X#	as the batch file output for the machine "nike".
X#
for host in ${remotes=$*}
do
X	lock=L.${host}
X	tmp=${host}.tmp
X	send=${host}.nntp
X	if shlock -p $$ -f ${lock} ; then
X		if test -e ${tmp} ; then
X			cat ${tmp} >> ${send}
X			rm ${tmp}
X		fi
X# we let the tmp file cool off for a while if there's other work to do
X# and we pick it up again during next iteration
X		if test -e ${host} ; then
X			if test -e ${send} ; then
X				mv ${host} ${tmp}
X			else
X				mv ${host} ${send}
X			fi
X		fi
X		if test -e ${send} ; then
X			echo ${pname}: "[$$]" begin ${host}
X			time nntpxmit ${host}:${send}
X			echo ${pname}: "[$$]" end ${host}
X		fi
X		rm -f ${lock}
X	else
X		echo ${pname}: "[$$]" ${host} locked by "[`cat ${lock}`]"
X	fi
done
echo ${pname}: "[$$]" end `date`
END_OF_FILE
if test 1365 -ne `wc -c <'./xmit/nntpsend.sh'`; then
    echo shar: \"'./xmit/nntpsend.sh'\" unpacked with wrong size!
fi
# end of './xmit/nntpsend.sh'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(3853 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X .                          1	
X ./CHANGES                  6	
X ./Makefile                 1	
X ./README                   5	
X ./common                   1	
X ./common/Makefile          1	
X ./common/README            7	
X ./common/README.HPUX       1	
X ./common/README.LIB        1	
X ./common/README.SYSV       1	
X ./common/clientlib.c       6	
X ./common/clientlib.h       1	
X ./common/conf.h            4	
X ./common/nntp.h            2	
X ./common/version.c         1	
X ./doc                      1	
X ./doc/Makefile             1	
X ./doc/README               1	
X ./doc/config.sh            2	
X ./doc/getactive.dst        1	
X ./doc/mkgrdates.dst        2	
X ./doc/nntpd.dst            4	
X ./doc/nntpxmit.1           4	
X ./doc/rfc977               9	
X ./inews                    1	
X ./inews/Makefile           1	
X ./inews/README             2	
X ./inews/inews.c            4	
X ./inews/test               1	
X ./inews/test1              1	
X ./inews/test2              1	
X ./inews/uname.c            2	
X ./rrnpatches               1	
X ./rrnpatches/Configure.pat  5	
X ./rrnpatches/MAKE_RRN_CHANGES  1	
X ./rrnpatches/Makefile.SH.pat  3	
X ./rrnpatches/Pnews.SH.pat  1	
X ./rrnpatches/README_RRN    1	
X ./rrnpatches/Rnmail.SH.pat  1	
X ./rrnpatches/addng.c.pat   1	
X ./rrnpatches/artio.c.pat   3	
X ./rrnpatches/common.h.pat  3	
X ./rrnpatches/final.c.pat   1	
X ./rrnpatches/getactive.c   2	
X ./rrnpatches/head.c.pat    3	
X ./rrnpatches/init.c.pat    2	
X ./rrnpatches/newsetup.SH.pat  4	
X ./rrnpatches/newsgroups.SH.pat  1	
X ./rrnpatches/ng.c.pat      4	
X ./rrnpatches/ngdata.c.pat  2	
X ./rrnpatches/ngdata.h.pat  1	
X ./rrnpatches/rcstuff.c.pat  5	
X ./rrnpatches/respond.c.pat  2	
X ./rrnpatches/term.c.pat    1	
X ./rrnpatches/util.c.pat    1	
X ./server                   1	
X ./server/Makefile          1	
X ./server/README            3	
X ./server/SYSLOG            2	
X ./server/access.c          3	
X ./server/access_dnet.c     1	
X ./server/access_inet.c     3	
X ./server/active.c          3	
X ./server/ahbs.c            2	
X ./server/common.h          2	
X ./server/fakesyslog.c      1	
X ./server/fakesyslog.h      1	
X ./server/globals.c         1	
X ./server/group.c           2	
X ./server/help.c            1	
X ./server/ihave.c           1	
X ./server/list.c            1	
X ./server/main.c            2	
X ./server/misc.c            7	
X ./server/netaux.c          4	
X ./server/newgroups.c       2	
X ./server/newnews.c         6	
X ./server/nextlast.c        2	
X ./server/ngmatch.c         2	
X ./server/parsit.c          2	
X ./server/post.c            1	
X ./server/profile.c         1	
X ./server/scandir.c         1	
X ./server/serve.c           5	
X ./server/slave.c           1	
X ./server/spawn.c           4	
X ./server/strcasecmp.c      3	
X ./server/subnet.c          5	
X ./server/time.c            3	
X ./server/time.h            1	
X ./server/xhdr.c            3	
X ./support                  1	
X ./support/Makefile         1	
X ./support/README           2	
X ./support/access_file      1	
X ./support/mkgrdates.c      3	
X ./support/nntp_awk         7	
X ./support/nntp_awk.ucbvax  8	
X ./xfer                     1	
X ./xfer/Makefile            1	
X ./xfer/README              1	
X ./xfer/nntpxfer.c          6	
X ./xmit                     1	
X ./xmit/Makefile            2	
X ./xmit/README              1	
X ./xmit/get_tcp_conn.c      5	
X ./xmit/get_tcp_conn.h      1	
X ./xmit/llist.c             1	
X ./xmit/llist.h             1	
X ./xmit/nntp.h              2	
X ./xmit/nntp_awk            7	
X ./xmit/nntpsend.csh        2	
X ./xmit/nntpsend.sh         1	
X ./xmit/nntpxmit.1          4	
X ./xmit/nntpxmit.c          8	
X ./xmit/nntpxmit.h          2	
X ./xmit/remote.c            6	
X ./xmit/shlock.c            5	
X ./xmit/sysexits.h          3	
X MANIFEST                   1	This shipping list
END_OF_FILE
if test 3853 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
echo shar: End of archive 1 \(of 9\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 9 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
