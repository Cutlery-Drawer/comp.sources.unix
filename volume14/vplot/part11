Subject:  v14i016:  Device-independant graphics system, with drivers
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Joe Dellinger <joe@hanauma.STANFORD.EDU>
Posting-number: Volume 14, Issue 16
Archive-name: vplot/part11

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 11 (of 24)."
# Wrapped by rsalz@fig.bbn.com on Fri Mar 25 11:47:14 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'RasterTek_device/rteklib/rtekraster.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'RasterTek_device/rteklib/rtekraster.c'\"
else
echo shar: Extracting \"'RasterTek_device/rteklib/rtekraster.c'\" \(3873 characters\)
sed "s/^X//" >'RasterTek_device/rteklib/rtekraster.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/rteklib/rtekraster.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include "rtekpen.h"
X
X/* Revised  4/19/87  Stewart A. Levin   SEP   added direct raster
X *                                            for all orients
X *
X *  For orient=1, simply switch nrows and ncols from orient=0
X *  For orient=2, reverse raster line in core and write it out
X *  For orient=3, same method as orient=2.  Code also left in
X *                to use rtek internal pixel functions to reverse
X *                within the display using 3 XOR's.  This is not
X *                invoked on the Convex because it's slower.
X *
X * Joe Dellinger 6/12/87 need to set lost=YES after raster.
X * Joe Dellinger Feb 16 1988
X *	Update to new order of arguments for dumb raster.
X */
extern int      genraster ();
extern int      lost;
X
rtekraster (count, out_of, xpos, ypos, length, orient, raster, dummy1, dummy2)
X    int             count, out_of, xpos, ypos, length, orient, dummy1, dummy2;
X    char           *raster;
X{
int             hlen;
register char  *ptr;
X
X    switch (orient)
X    {
X    case 0:
X	rtekplot (xpos, ypos, 0);
X	CHKLEN (5 + length);
X	byte (PIXEL8);		/* cmdlen = 5 + length */
X	word (1);
X	word (length);
X	fwrite (raster, 1, length, rtekfd);
X	break;
X    case 1:
X	rtekplot (xpos, ypos, 0);
X	CHKLEN (5 + length);
X	byte (PIXEL8);		/* cmdlen = 5 + length */
X	word (length);
X	word (1);
X	fwrite (raster, 1, length, rtekfd);
X	break;
X    case 2:
X	rtekplot (xpos - length + 1, ypos, 0);
X	CHKLEN (5 + length);
X	byte (PIXEL8);
X	word (1);
X	word (length);
X	for (ptr = raster + length - 1; ptr >= raster; ptr--)
X	    putc (*ptr, rtekfd);
X	break;
X    case 3:
X	rtekplot (xpos, ypos + length - 1, 0);
X	CHKLEN (5 + length);
X	byte (PIXEL8);
X	word (length);
X	word (1);
X	for (ptr = raster + length - 1; ptr >= raster; ptr--)
X	    putc (*ptr, rtekfd);
X#ifdef undef
X	/* this reverses rasters inside device */
X	hlen = length >> 1;
X	rtekplot (xpos, ypos + length - 1, 0);
X	CHKLEN (5 + length);	/* load rasters backwards */
X	byte (PIXEL8);
X	word (length);
X	word (1);
X	fwrite (raster, 1, length, rtekfd);
X	CHKLEN (2);		/* set to XOR pixel mode */
X	byte (PIXFUN);
X	byte (4);
X	CHKLEN (6);		/* define 2 half-length windows */
X	byte (CLOAD);
X	byte (11);
X	word (xpos);
X	word (ypos);
X	CHKLEN (6);
X	byte (CLOAD);
X	byte (12);
X	word (xpos);
X	word (ypos + hlen - 1);
X	CHKLEN (6);
X	byte (CLOAD);
X	byte (13);
X	word (xpos);
X	word (ypos + length - 1);
X	CHKLEN (6);
X	byte (CLOAD);
X	byte (14);
X	word (xpos);
X	word (ypos + length - hlen);
X	CHKLEN (1);
X	byte (PIXMOV);		/* perform XOR number 1 */
X	CHKLEN (3);
X	byte (CMOVE);
X	byte (11);
X	byte (13);
X	CHKLEN (3);
X	byte (CMOVE);
X	byte (12);
X	byte (14);
X	CHKLEN (6);
X	byte (CLOAD);
X	byte (13);
X	word (xpos);
X	word (ypos);
X	CHKLEN (6);
X	byte (CLOAD);
X	byte (14);
X	word (xpos);
X	word (ypos + hlen - 1);
X	CHKLEN (1);
X	byte (PIXMOV);
X	CHKLEN (3);
X	byte (CMOVE);
X	byte (13);
X	byte (11);
X	CHKLEN (3);
X	byte (CMOVE);
X	byte (14);
X	byte (12);
X	CHKLEN (6);
X	byte (CLOAD);
X	byte (11);
X	word (xpos);
X	word (ypos);
X	CHKLEN (6);
X	byte (CLOAD);
X	byte (12);
X	word (xpos);
X	word (ypos + hlen - 1);
X	CHKLEN (1);
X	byte (PIXMOV);
X	CHKLEN (2);
X	byte (PIXFUN);		/* reset pixel to insert mode */
X	byte (0);
X#endif undef
X	break;
X    default:			/* this shouldn't happen */
X	genraster (count, out_of, xpos, ypos, length, orient, raster, 0, 0);
X	break;
X    }
X    lost = 1;
X}
END_OF_FILE
if test 3873 -ne `wc -c <'RasterTek_device/rteklib/rtekraster.c'`; then
    echo shar: \"'RasterTek_device/rteklib/rtekraster.c'\" unpacked with wrong size!
fi
# end of 'RasterTek_device/rteklib/rtekraster.c'
fi
if test -f 'Regis_device/gigilib/gigiplot.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Regis_device/gigilib/gigiplot.c'\"
else
echo shar: Extracting \"'Regis_device/gigilib/gigiplot.c'\" \(3046 characters\)
sed "s/^X//" >'Regis_device/gigilib/gigiplot.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/gigilib/gigiplot.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include <stdio.h>
X#include "gigi.h"
extern FILE    *pltout;
extern int      dev_xmax, dev_ymax, dev_xmin, dev_ymin;
int             lost = 1;	/* used by genvector */
X
gigiplot (xnew, ynew, draw)
X    int             xnew, ynew, draw;
X{
int             ix, iy, dx, dy, gdx, gdy, adx, ady;
float           slope, x, y, fdx, fdy;
static int      xold, yold;
X
X    gcon (&xnew, &ynew);	/* Convert to Gigi's perverse coordinate
X				 * system */
X
X    if (!in_a_poly)
X    {
X	if (!draw)
X	{
X	    if (lastop != 'P')
X		fprintf (pltout, "P@W");
X	}
X	else
X	{
X	    if (lastop != 'V')
X		fprintf (pltout, "V@W");
X	}
X    }
X
X    if (lost == 0)
X    {
X	gdx = xnew - xold;
X	gdy = ynew - yold;
X	adx = (gdx > 0 ? gdx : -gdx);
X	ady = (gdy > 0 ? gdy : -gdy);
X	if (adx == 0 && ady == 0)
X	    goto done;
X    }
X    else
X    {
X	lost = 0;
X	adx = 100;
X	ady = 100;
X    }
X    /* general move, fast for long vectors */
X    if (adx > 10 || ady > 10)
X    {
X	fprintf (pltout, "[%d,%d]", 2 * ynew, 2 * xnew);
X	goto done;
X    }
X    /* equivalent move, fast for short vectors */
X    fdx = gdx;
X    fdy = gdy;
X    if (adx >= ady)
X    {
X	slope = 1.0001 * fdy / fdx;
X	slope = (gdx > 0. ? slope : -slope);
X	iy = yold;
X	y = yold;
X	for (ix = 0; ix < adx; ix++)
X	{
X	    y = y + slope;
X	    dy = y - iy;
X	    iy = iy + dy;
X	    if (dy == 0)
X	    {
X		if (gdx > 0)
X		    fprintf (pltout, "6");
X		else
X		    fprintf (pltout, "2");
X	    }
X	    else
X	    if (dy > 0)
X	    {
X		if (gdx > 0)
X		    fprintf (pltout, "7");
X		else
X		    fprintf (pltout, "1");
X	    }
X	    else
X	    {
X		if (gdx > 0)
X		    fprintf (pltout, "5");
X		else
X		    fprintf (pltout, "3");
X	    }
X	}
X    }
X    else
X    {
X	slope = 1.0001 * fdx / fdy;
X	slope = (gdy > 0. ? slope : -slope);
X	ix = xold;
X	x = xold;
X	for (iy = 0; iy < ady; iy++)
X	{
X	    x = x + slope;
X	    dx = x - ix;
X	    ix = ix + dx;
X	    if (dx == 0)
X	    {
X		if (gdy > 0)
X		    fprintf (pltout, "0");
X		else
X		    fprintf (pltout, "4");
X	    }
X	    else
X	    if (dx > 0)
X	    {
X		if (gdy > 0)
X		    fprintf (pltout, "7");
X		else
X		    fprintf (pltout, "5");
X	    }
X	    else
X	    {
X		if (gdy > 0)
X		    fprintf (pltout, "1");
X		else
X		    fprintf (pltout, "3");
X	    }
X	}
X    }
done:
X    if (!in_a_poly)
X    {
X	if (!draw)
X	{
X	    fprintf (pltout, "0V@W4");
X	}
X	lastop = 'V';
X    }
X    xold = xnew;
X    yold = ynew;
X    return;
X}
X
gcon (x, y)
X    int            *x, *y;
X{
int             temp;
X
X    temp = *x;
X    *x = dev_ymin + dev_ymax - *y;
X    *y = temp;
X}
END_OF_FILE
if test 3046 -ne `wc -c <'Regis_device/gigilib/gigiplot.c'`; then
    echo shar: \"'Regis_device/gigilib/gigiplot.c'\" unpacked with wrong size!
fi
# end of 'Regis_device/gigilib/gigiplot.c'
fi
if test -f 'Tek_device/cteklib/ctekraster.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Tek_device/cteklib/ctekraster.c'\"
else
echo shar: Extracting \"'Tek_device/cteklib/ctekraster.c'\" \(3690 characters\)
sed "s/^X//" >'Tek_device/cteklib/ctekraster.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/cteklib/ctekraster.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Joe Dellinger Feb 16 1988
X *	Updated raster call.
X */
X
X#include	<stdio.h>
X#include	"ctek.h"
X#include "../include/enum.h"
X#include "../include/extern.h"
extern FILE    *pltout;
extern int      need_devcolor, overlay;
extern int      genraster1 ();
extern int      lost;
X
X/*
X * IMPORTANT NOTE
X * We couldn't just change the raster line which is handed to us to
X * do the color mapping, because the same line MAY get handed to us
X * again, which creates havoc when it gets mapped TWICE.
X */
X
ctekraster (count, out_of, xpos, ypos, length, orient, raster, dummy1, dummy2)
X    int             count, out_of, xpos, ypos, length, orient, dummy1, dummy2;
X    char           *raster;
X{
register int    ii, jj, kk;
int             length2;
int             pixel[6];	/* Most number pixels per one character */
static int      pix_pak = 0;
int             xbreak;
int             failure_count;
X
X/* Why were we even called? */
X    if (length == 0)
X	return;
X
X/*
X * pixel stuff has to overwrite
X */
X    overlay = NO;
X
X    if (orient != 0)
X    {
X	genraster1 (count, out_of, xpos, ypos, length, raster, orient);
X	return;
X    }
X
X/*
X * If it is just a solid line (or nearly solid) of a few colors, better to use
X * genraster1.
X */
X    xbreak = 0;
X    failure_count = 0;
X    for (jj = 1; jj < length; jj++)
X    {
X	if (raster[jj] != raster[jj - 1])
X	{
X	    if (jj - xbreak < 10)
X	    {
X		failure_count++;
X		if (failure_count > 2)
X		    break;
X	    }
X	    xbreak = jj;
X	}
X    }
X    if (jj == length)
X    {
X	genraster1 (0, 1, xpos, ypos, length, raster, orient);
X	return;
X    }
X
X
X/*
X * Probably "runlength write" would be more efficient here in many
X * circumstances. Anyone want to make this use that when it is faster?
X * -JAD
X */
X
X/* Do tek4105 Raster write */
X
X    cteksetmode (TEK);
X
X/* See how many bits we need to use */
X    jj = 0;
X    for (ii = 0; ii < length; ii++)
X    {
X	kk = ctekcolmap ((int) raster[ii]);
X	if (jj < kk)
X	    jj = kk;
X	if (jj > 3)
X	    break;
X    }
X    switch (jj)
X    {
X    case 0:
X    case 1:
X	jj = 6;
X	break;
X    case 2:
X    case 3:
X	jj = 3;
X	break;
X    default:
X	jj = 2;
X	break;
X    }
X
X    if (pix_pak != jj)
X    {
X	pix_pak = jj;		/* pix_pak is number of pixels per char */
X	fprintf (pltout, "%cRU1", ESC);	/* Begin Pixel Operations */
X	tekipack (11);		/* Replace whatever was there before */
X	tekipack (6 / pix_pak);	/* 6/pix_pak bits per pixel */
X    }
X
X
X    fprintf (pltout, "%cRH", ESC);	/* position pixel beam */
X    ctekxypack (xpos, ypos);
X
X/* length2 is number of characters needed to hold length pixels */
X    length2 = length / pix_pak;
X    if (length % pix_pak != 0)
X	length2++;
X
X    fprintf (pltout, "%cRP", ESC);	/* raster write (one line) */
X    tekipack (length);		/* Number of pixels to set, */
X    tekipack (length2);		/* encoded into this many characters */
X
X    for (jj = 0; jj < length; jj += pix_pak)
X    {
X	for (kk = 0; kk < pix_pak; kk++)
X	{
X	    if (jj + kk >= length)
X	    {
X		pixel[kk] = 0;
X		break;
X	    }
X	    pixel[kk] = ctekcolmap ((int) raster[jj + kk]);
X	}
X
X	pixpack (pixel, pix_pak);
X    }
X    lost = 1;
X    need_devcolor = YES;
X    return;
X}
END_OF_FILE
if test 3690 -ne `wc -c <'Tek_device/cteklib/ctekraster.c'`; then
    echo shar: \"'Tek_device/cteklib/ctekraster.c'\" unpacked with wrong size!
fi
# end of 'Tek_device/cteklib/ctekraster.c'
fi
if test -f 'Tek_device/teklib/tekopen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Tek_device/teklib/tekopen.c'\"
else
echo shar: Extracting \"'Tek_device/teklib/tekopen.c'\" \(3098 characters\)
sed "s/^X//" >'Tek_device/teklib/tekopen.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/teklib/tekopen.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X/*
X * Device open routine for tek4010 emulators (no-op for a real tek401x)
X *	Devices supported:
X *		graphon 140, 230, 235, 240
X *		selanar hi-rez 100
X *		digital engineering retrographics boards in dec vt102 and vt131
X *			and televideo 950 terminals
X * 		seiko d-scan (gr-1104), in monochrome
X *
X *							chuck karish  25 november 1986
X */
X
X#include <stdio.h>
X#include "../include/enum.h"
X#include "../include/extern.h"
X#include "../teklib/tek.h"
extern FILE    *pltout;
extern char     wstype[];
extern char     callname[];
X
tekopen ()
X{
X/*
X * physical device parameters
X */
X    dev_xmax = 1000;
X    dev_ymax = 750;
X    dev_xmin = 0;
X    dev_ymin = 0;
X    pixels_per_inch = 78.;
X    aspect_ratio = 1.;
X
X/*
X * device capabilities
X */
X    need_end_erase = NO;
X    buffer_output = YES;
X    smart_clip = NO;
X    num_col = 0;
X
X    if (!strcmp (wstype, "default"))
X    {
X	strcpy (wstype, "tek401X");
X    }
X    if ((!strcmp (wstype, "graphon")) ||
X	(!strcmp (callname, "gopen")))
X    {
X	strcpy (wstype, "graphon");
X	dev_xmax = 1023;
X	dev_ymax = 780;
X	pixels_per_inch = 128;
X	need_end_erase = NO;
X
X	fprintf (pltout, "\0331");	/* go into 4014 mode and stay there */
X	fflush (stdout);
X	endpause = YES;
X    }
X
X    else
X	if ((!strcmp (wstype, "retrographics")) ||
X	    (!strcmp (callname, "retpen")) ||
X	    (!strcmp (callname, "ret")))
X    {
X	strcpy (wstype, "retrographics");
X	dev_xmax = 1023;
X	dev_ymax = 780;
X	pixels_per_inch = 128;
X
X	fprintf (pltout, "\035");	/*go into 4010 mode and stay there */
X	fflush (stdout);
X    }
X
X    else
X	if ((!strcmp (wstype, "selanar")) ||
X	    (!strcmp (callname, "selpen")))
X    {
X	strcpy (wstype, "selanar");
X	dev_xmax = 1023;
X	dev_ymax = 780;
X	pixels_per_inch = 128;
X	need_end_erase = YES;
X	endpause = YES;
X/*
X * The text screen must be erased to keep fragments of the text
X * plane from flashing by while drawing is taking place.
X */
X	fprintf (pltout, "\033[0;0H");	/* return cursor to home position */
X	fprintf (pltout, "\033[2J");	/* erase text screen */
X	fprintf (pltout, "\033[>0t");	/* turn off text video */
X	fprintf (pltout, "\0331");	/* go to 4014 mode and stay there */
X	fflush (stdout);
X    }
X    else
X	if ((!strcmp (wstype, "dscan")) ||
X	    (!strcmp (callname, "dscanpen")))
X    {
X	strcpy (wstype, "dscan");
X	dev_xmax = 1023;
X	dev_ymax = 779;
X	pixels_per_inch = 128;
X	need_end_erase = NO;
X	buffer_output = YES;
X	smart_clip = NO;
X	num_col = 0;
X
X	fprintf (pltout, "\033*");	/* go into 4014 mode and stay there */
X	fflush (stdout);
X	endpause = YES;
X    }
X}
END_OF_FILE
if test 3098 -ne `wc -c <'Tek_device/teklib/tekopen.c'`; then
    echo shar: \"'Tek_device/teklib/tekopen.c'\" unpacked with wrong size!
fi
# end of 'Tek_device/teklib/tekopen.c'
fi
if test -f 'Virtual_device/raslib/rasopen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Virtual_device/raslib/rasopen.c'\"
else
echo shar: Extracting \"'Virtual_device/raslib/rasopen.c'\" \(3778 characters\)
sed "s/^X//" >'Virtual_device/raslib/rasopen.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/raslib/rasopen.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include <stdio.h>
X#include "../include/enum.h"
X#include "../include/extern.h"
X#include "../include/err.h"
X#include <strings.h>
X#ifdef SEP
X#include <ctype.h>
X#endif
X#define DEFAULT_OUT	isatty(fileno(pltout))
X#include "raspen.h"
X
char           *image;
extern char    *malloc ();
extern float    aspect_ratio;
extern float    pixels_per_inch;
int             color_mult, rasor = 0;
char            colfile[60];
X
extern int      num_col;
extern int      rasvector2 ();
X
rasopen ()
X{
extern char   **xargv;
extern FILE    *pltout;
extern char    *alloc ();
X#ifdef SEP
extern int      headfd;
char            headname[30], fname[80];
char            path[50];
char           *front, *tail, *ptr;
X#endif
char            newpath[60];
X
X/*
X * physical device parameters
X */
X    dev_xmax = 100;
X    dev_ymax = 100;
X    dev_xmin = 0;
X    dev_ymin = 0;
X    pixels_per_inch = 100.;
X    aspect_ratio = 1.;
X
X/*
X * device capabilities
X */
X    need_end_erase = YES;
X    buffer_output = YES;
X    smart_clip = NO;
X
X    color_mult = 2;
X    getpar ("colormult", "d", &color_mult);
X    num_col = NCOLOR / color_mult;
X
X    getpar ("or", "1", &rasor);
X    if (rasor)
X    {
X	dev.vector = rasvector2;
X    }
X
X    dev_xmax = 1024;
X    dev_ymax = 768;
X    aspect_ratio = 1.;
X    getpar ("n1", "d", &dev_xmax);
X    getpar ("n2", "d", &dev_ymax);
X    getpar ("aspect", "f", &aspect_ratio);
X    pixels_per_inch /= ((float) 768 / (float) dev_ymax);
X    getpar ("ppi", "d", &pixels_per_inch);
X#ifdef SEP
X    Puthead ("\n\n# Raspen: VPLOT graphics via Movie,\n");
X    Puthead ("#\tor any other byte-deep raster device.\n\n");
X    Puthead ("\taspect_ratio=%f\n", aspect_ratio);
X    Puthead ("\tesize=1\n");
X    Puthead ("\tn1=%d\n", dev_xmax);
X    Puthead ("\tn2=%d\n", dev_ymax);
X#endif
X
X
X    /*
X     * Allocate space for image 
X     */
X    if ((image = malloc (dev_xmax * dev_ymax)) == NULL)
X    {
X	ERR (FATAL, name, "Can't allocate space for raster image\n");
X    }
X
X    if (DEFAULT_OUT)
X    {
X#ifdef SEP
X	datapath (path);
X/* Code stolen from output.c to get a reasonable raster file name. */
X	if (0 < findnm (headfd, headname, sizeof (headname)))
X	{
X	    /* modify slightly */
X	    strcpy (fname, "");
X	    front = rindex (headname, '/');
X	    if (front == ((char *) NULL))
X		front = headname;
X	    else
X		front++;
X	    if ((*front) == 'H')
X		strcat (fname, ++front);
X	    else
X	    {
X		tail = rindex (front, '.');
X		if (tail == ((char *) NULL))
X		    strcat (fname, front);
X		else
X		{
X		    for (ptr = tail + 1; *ptr; ptr++)
X			if (!isupper (*ptr))
X			    break;
X		    if (!(*ptr))/* drop suffix if all caps */
X			*tail = '\0';
X		    (void) strcat (fname, front);
X		}
X	    }
X	    (void) strcat (fname, ".raster");
X	}
X	else
X	{
X	    strcpy (fname, "raster");
X	}
X
X	sprintf (newpath, "%s%s", path, fname);
X	Puthead ("\tin=%s\n", newpath);
X#else
X	sprintf (newpath, "%s", "raster_file");
X#endif
X	pltout = fopen (newpath, "w");
X	if (pltout == NULL)
X	    ERR (FATAL, name, "can't open file %s\n", newpath);
X
X	strcpy (colfile, "colfile");
X	getpar (colfile, "s", colfile);
X#ifdef SEP
X	Puthead ("\tcolfile=%s\n", colfile);
X	Puthead ("\tcolor=T\n");
X	if (color_mult == 1)
X	    Puthead ("\tumask=255\n");
X#endif
X    }
X}
END_OF_FILE
if test 3778 -ne `wc -c <'Virtual_device/raslib/rasopen.c'`; then
    echo shar: \"'Virtual_device/raslib/rasopen.c'\" unpacked with wrong size!
fi
# end of 'Virtual_device/raslib/rasopen.c'
fi
if test -f 'Virtual_device/vplib/vptextT.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Virtual_device/vplib/vptextT.c'\"
else
echo shar: Extracting \"'Virtual_device/vplib/vptextT.c'\" \(3424 characters\)
sed "s/^X//" >'Virtual_device/vplib/vptextT.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/vplib/vptextT.c
X *
X * Joe Dellinger (SEP), Dec 19 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X/*
X * THIS FILE SHOWS HOW TO DO TEXT USING THE VP_TEXT COMMAND.
X * I INCLUDE THIS AS AN EXAMPLE OF HOW TO SUPPORT HARDWARE
X * TEXT WELL ON DEVICES THAT CAN'T DO ARBITRARY TRANSFORMATIONS.
X */
X
X#include	<stdio.h>
X#include	<math.h>
X#include	"../include/vplot.h"
X#include	"../include/extern.h"
X#include	"../include/enum.h"
X#include	"../include/params.h"
X#include	"../include/round.h"
X#include	"./vp.h"
X
static double   path_orient_dx, path_orient_dy;
static double   up_orient_dx, up_orient_dy;
X
extern int
gentext (), nulldev ();
X
vptext (string, pathx, pathy, upx, upy)
X    char           *string;
X    float           pathx, pathy, upx, upy;
X{
double          fpathx, fpathy, fupx, fupy;
double          up, path;
int             vpsize, vporient;
float           dot, cross, aspect;
int             (*savevector) ();
int             (*saveattributes) ();
int             (*savearea) ();
X
X    vpsetflag = NO;
X    lost = YES;
X
X    if (*string == '\0')
X	return;
X
X/*
X * Set the inital parameters
X */
X    fpathx = (double) pathx;
X    fpathy = (double) pathy;
X    fupx = (double) upx;
X    fupy = (double) upy;
X
X    path = sqrt ((double) (fpathx * fpathx + fpathy * fpathy));
X    up = sqrt ((double) (fupx * fupx + fupy * fupy));
X
X    path_orient_dx = fpathx / path;
X    path_orient_dy = fpathy / path;
X    up_orient_dx = fupx / up;
X    up_orient_dy = fupy / up;
X
X/*
X * Check for skewed coordinates
X *
X * If the path and orient vectors are scewed by more than 2
X * degrees, or if the height/width ratio is more than 1 percent
X * off, or if the letters are mirrored, then use vector text.
X */
X
X    dot = path_orient_dx * up_orient_dx +
X     path_orient_dy * up_orient_dy;
X
X    cross = path_orient_dx * up_orient_dy -
X     path_orient_dy * up_orient_dx;
X
X    if (path != 0.)
X    {
X	aspect = up / path;
X    }
X    else
X    {
X	if (up == 0.)
X	    aspect = 1.;
X	else
X	    aspect = 0.;
X    }
X
X    if (fabs (dot) > .01 || cross < 0. || fabs (aspect - 1.) > .01)
X    {
X	gentext (string, pathx, pathy, upx, upy);
X	return;
X    }
X
X/*
X *   Set the font and size
X */
X    vpsize = ROUND (TXPERIN * path / RPERIN);
X    vporient = ROUND (acos (path_orient_dx) * 180 / 3.141592654);
X    if (pathy < 0)
X	vporient *= -1;
X
X    vp_text ((float) xold / RPERIN, (float) yold / RPERIN,
X	     vpsize, vporient, string);
X
X/*
X *   Now reset the pen position.
X *   Do a dummy run through (if this indeed a gentext font)
X */
X    if (txfont < NUMGENFONT)
X    {
X	savevector = dev.vector;
X	saveattributes = dev.attributes;
X	savearea = dev.area;
X
X/*
X *   Disconnect everything except error messages
X */
X	dev.vector = nulldev;
X	dev.attributes = nulldev;
X	dev.area = nulldev;
X
X	gentext (string, pathx, pathy, upx, upy);
X
X	dev.vector = savevector;
X	dev.attributes = saveattributes;
X	dev.area = savearea;
X
X	vp_move ((float) xold / RPERIN, (float) yold / RPERIN);
X    }
X}
END_OF_FILE
if test 3424 -ne `wc -c <'Virtual_device/vplib/vptextT.c'`; then
    echo shar: \"'Virtual_device/vplib/vptextT.c'\" unpacked with wrong size!
fi
# end of 'Virtual_device/vplib/vptextT.c'
fi
if test -f 'Vplot_Kernel/filters/Tests/polytest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/Tests/polytest.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/Tests/polytest.c'\" \(3083 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/Tests/polytest.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/Tests/polytest.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include <stdio.h>
X#include <vplot.h>
X#include <math.h>
X
X#define NP 10
X
main ()
X{
int             mtype, msize;
float           xarray[NP], yarray[NP];
float           dash[2], gap[2];
int             i, j;
int             pattern[100];
X
X/*
X * Set up where you want the vplot output to go.
X */
X    vp_filep (stdout);
X
X/*
X * Decide what "style" plot this is to be.
X */
X    vp_style (STANDARD);
X
X/*
X * Draw polymarkers.
X */
X    for (i = 0; i < NP; i++)
X    {
X	xarray[i] = 4.25 + i % 3;
X	yarray[i] = (1. - (float) i / NP) * 8.;
X    }
X    msize = 20;
X    mtype = 23;
X    vp_color (RED);
X    vp_pmark (NP, mtype, msize, xarray, yarray);
X
X/*
X * Draw dashed polyline.
X */
X    dash[0] = (.5);
X    dash[1] = (.1);
X    gap[0] = (.1);
X    gap[1] = (.1);
X    vp_setdash (dash, gap, 2);
X    vp_color (WHITE);
X
X    for (i = 0; i < NP; i++)
X    {
X	xarray[i] = 4.25 + (i + 1) % 3;
X	yarray[i] = (1. - (float) i / NP) * 8.;
X    }
X    vp_pline (xarray, yarray, NP);
X
X    vp_color (BLUE);
X
X    for (i = 0; i < NP; i++)
X    {
X	xarray[i] = 4.25 + (i + 2) % 3;
X	yarray[i] = (1. - (float) i / NP) * 8.;
X    }
X    vp_pline (xarray, yarray, NP);
X
X    for (i = 0; i < 10; i++)
X	for (j = 0; j < 10; j++)
X	{
X	    pattern[i + j * 10] = (int)
X	     (.25 * ((i - 6.) * (i - 3.) + (j - 6.) * (j - 3.)));
X	    if (pattern[i + j * 10] > 7 || pattern[i + j * 10] < 0)
X		pattern[i + j * 10] = 7;
X	}
X    vp_patload (10, 10, 10, GREEN, pattern);
X
X    i = 0;
X    pattern[i++] = 1;
X    pattern[i++] = RED;
X    pattern[i++] = 0. * HATCHPERIN;
X    pattern[i++] = (.5) * HATCHPERIN;
X
X    pattern[i++] = 1;
X    pattern[i++] = WHITE;
X    pattern[i++] = (.25) * HATCHPERIN;
X    pattern[i++] = (.5) * HATCHPERIN;
X
X    pattern[i++] = 1;
X    pattern[i++] = BLUE;
X    pattern[i++] = 0. * HATCHPERIN;
X    pattern[i++] = (.5) * HATCHPERIN;
X
X    pattern[i++] = 1;
X    pattern[i++] = WHITE;
X    pattern[i++] = (.25) * HATCHPERIN;
X    pattern[i++] = (.5) * HATCHPERIN;
X
X    vp_hatchload (30, 2, RED, pattern);
X
X    vp_color (GREEN);
X    for (i = 0; i < NP; i++)
X    {
X	xarray[i] = 9. + 2. * cos (i * 2. * 3.14159 / NP);
X	yarray[i] = 4. + 2. * sin (i * 2. * 3.14159 / NP);
X    }
X    vp_fill (xarray, yarray, NP);
X
X    vp_color (RED);
X    for (i = 0; i < NP; i++)
X    {
X	xarray[i] = 2. + 2. * cos (i * 2. * 3.14159 / NP);
X	yarray[i] = 4. + 2. * sin (i * 2. * 3.14159 / NP);
X    }
X    vp_fill (xarray, yarray, NP);
X
X    vp_fat (5);
X    vp_setdash (NULL, NULL, 0);
X    vp_pline (xarray, yarray, NP);
X
X/*
X * Finish up
X */
X    vp_endplot ();
X}
END_OF_FILE
if test 3083 -ne `wc -c <'Vplot_Kernel/filters/Tests/polytest.c'`; then
    echo shar: \"'Vplot_Kernel/filters/Tests/polytest.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/Tests/polytest.c'
fi
if test -f 'Vplot_Kernel/filters/genlib/vecarea.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/genlib/vecarea.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/genlib/vecarea.c'\" \(3158 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/genlib/vecarea.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/genlib/vecarea.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include <stdio.h>
X#include "../include/pat.h"
X#include "../include/vertex.h"
X#include "../include/params.h"
X#include "../include/extern.h"
X
extern char    *malloc ();
X
vecarea (npts, head)
X    int             npts;
X    struct vertex  *head;
X{
register int    x, y, i;
register int    xstr, xend, ystr, yend;
int             skip;
int             ncross;
int             vminx, vmaxx, vminy, vmaxy;
struct vertex  *xhead, *yhead, *v;
int            *crosses;
X
X    /*
X     * allocate storage for scan line cross points 
X     */
X    crosses = (int *) malloc ((unsigned) npts * sizeof (int));
X
X    /*
X     * double link the vertices. (head) is set to the node with the maximum
X     * x-value so that intersect() will not eliminate 'head' while casting
X     * off vertices. 
X     */
X    vminx = head->x;
X    vmaxx = head->x;
X    vminy = head->y;
X    vmaxy = head->y;
X    xhead = head;
X    yhead = head;
X
X    v = head;
X    for (i = 0; i < npts; i++)
X    {
X	if (v->x > vmaxx)
X	{
X	    vmaxx = v->x;
X	    xhead = v;
X	}
X	if (v->y > vmaxy)
X	{
X	    vmaxy = v->y;
X	    yhead = v;
X	}
X	if (v->x < vminx)
X	    vminx = v->x;
X	if (v->y < vminy)
X	    vminy = v->y;
X	v++;
X    }
X
X    if (vmaxx > xwmax)
X	vmaxx = xwmax;
X    if (vminx < xwmin)
X	vminx = xwmin;
X    if (vmaxy > ywmax)
X	vmaxy = ywmax;
X    if (vminy < ywmin)
X	vminy = ywmin;
X
X    if ((pat[ipat] .ydim > 0) || (pat[ipat] .xdim == 1))
X    {
X	/* stretch polygon in y-direction */
X	v = yhead;
X	do
X	{
X	    v->y = 2 * (v->y) + 1;
X	    v = v->next;
X	} while (v != yhead);
X
X	skip = (pat[ipat] .xdim == 1) ? 1 : pat[ipat] .ydim;
X	for (y = vminy; y <= vmaxy; y += skip)
X	{
X	    ncross = intersect (2 * y, crosses, yhead, 1);
X	    sort (crosses, ncross);
X	    for (i = 0; i < ncross; i += 2)
X	    {
X		xstr = crosses[i];
X		xend = crosses[i + 1];
X		dev.vector (xstr, y, xend, y, 0, 0);
X	    }
X	}
X	/* shrink in y */
X	v = yhead;
X	do
X	{
X	    v->y = ((v->y - 1) / 2);
X	    v = v->next;
X	} while (v != yhead);
X    }
X
X    if ((pat[ipat] .xdim > 1) && (pat[ipat] .ydim > 1))
X    {
X	/*
X	 * expand in x 
X	 */
X	v = xhead;
X	do
X	{
X	    v->x = 2 * v->x + 1;
X	    v = v->next;
X	} while (v != xhead);
X
X	skip = pat[ipat] .xdim;
X	for (x = vminx; x <= vmaxx; x += skip)
X	{
X	    ncross = intersect (2 * x, crosses, xhead, 0);
X	    sort (crosses, ncross);
X	    for (i = 0; i < ncross; i += 2)
X	    {
X		ystr = crosses[i];
X		yend = crosses[i + 1];
X		dev.vector (x, ystr, x, yend, 0, 0);
X	    }
X	}
X
X	/*
X	 * shrink in x 
X	 */
X	v = xhead;
X	do
X	{
X	    v->x = ((v->x - 1) / 2);
X	    v = v->next;
X	} while (v != xhead);
X    }
X    free ((char *) crosses);
X}
END_OF_FILE
if test 3158 -ne `wc -c <'Vplot_Kernel/filters/genlib/vecarea.c'`; then
    echo shar: \"'Vplot_Kernel/filters/genlib/vecarea.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/genlib/vecarea.c'
fi
if test -f 'Vplot_Kernel/filters/loclib/getpar_decode.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/loclib/getpar_decode.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/loclib/getpar_decode.c'\" \(3753 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/loclib/getpar_decode.c' <<'END_OF_FILE'
X/*
X *
X *  source file:   ./filters/loclib/getpar_decode.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X/* Revised 3-8-86 stew  Added timestamp to recover older functionality
X *			when presented with multiple tags
X * Revised 9-18-86 joe  Added '1' type ... y or 1 for yes, n or 0 for no
X */
X#include <stdio.h>
X#include "fastpar.h"
X
X/*
X * split off first tag "n1" from input tags "n1 nt ne"
X */
static int tag_split(tag,tlen,subtag,sublen)
register char *tag;
char **subtag;
register int tlen;
int *sublen;
X{
X register int i,j;
X
X for(i=0; i<tlen; i++) if(tag[i] != ' ') break;
X if(i == tlen) return(0); /* all bytes consumed */
X *subtag = tag+i;
X for(j=i+1; j<tlen; j++) if(tag[j] == ' ') break;
X *sublen = (j-i);
X return(1);
X}
X
X/*
X * take string "n1 nt ne" and look up stored parameters with those
X * names, returning value with most recent timestamp
X */
int getpar_decode(q,qlen,tag,type,val)
hash_item **q;
int qlen;
char *tag, *type;
MIXED val;
X{
X register char *next, *end;
X char *subtag;
X int sublen, count = 0 ;
X register hash_item *foundit, *saveit;
X extern hash_item *getpar_hash_lookup();
X register int bigtime = -1;
X
X next=tag; end = tag+strlen(tag);
X while(tag_split(next,end-next,&subtag,&sublen)) {
X    foundit = getpar_hash_lookup(q,qlen,subtag,sublen);
X    if(foundit != ((hash_item *) NULL))
X	if(bigtime < foundit->timestamp) {
X	    bigtime = foundit->timestamp;
X	    saveit = foundit;
X	    }
X    next = subtag+sublen;
X    }
X if(bigtime >= 0) count = getpar_getval(saveit,type,val);
X return(count);
X }
X
X/*
X * return 1 if char c is not in string s; else return 0
X */
static int
getpar_neq(c,s)
register int c;
register char *s;
X{
X	do {
X		if(*s == c) {
X			return(0); 
X		}
X	} 
X	while(*s++);
X	return(1);
X}
X
X/*
X * take stored string value and convert it according to "type" format
X * result stored at "ptr"
X *
X * type formats:
X *               "i" or "d"  to convert to integer
X *               "r" or "f"  to convert to real
X *               "g"         to convert to double precision
X *               "s"         to keep as a string value
X *
X * stored string values may specify a vector of numerics:
X *
X *               3.0,5x3.5,-1.0,3*2.2
X * 
X * yields the result:
X *
X *               3.0,3.5,3.5,3.5,3.5,3.5,-1.0,2.2,2.2,2.2
X *
X * the function's return value will be the count (10) of items converted
X */
static int getpar_getval(foundit,type,ptr)
hash_item *foundit;
char *type;
MIXED ptr;
X{
X    register char *sptr, *str;
X    register int ival, jval;
X    register int index, endindex;
X    extern double atof();
X    extern int atoi();
X    float flt;
X    double dubble;
X    int integer;
X    index=0;
X    str = foundit->val;
X    ival = foundit->vlen;
X
X    while(ival > 0) {
X	endindex= index+1;
X	if(*type != 's') {
X		sptr = str;
X		jval = ival;
X		while(jval && getpar_neq((int) (*sptr),"*x,"))
X			{ sptr++; jval--;}
X		if(jval > 0)
X		    if(*sptr=='*' || *sptr=='x') {
X			endindex= index+atoi(str);
X			str= sptr+1;
X			ival = jval-1;
X		}
X	}
X	switch(*type) {
X	case 'd':
X	case 'i':
X		integer= atoi(str);
X		while(index<endindex) ptr.i[index++]= integer;
X		break;
X	case '1':
X		if (str[0] == 'y' || str[0] == '1' || str[0] == 'Y')
X			integer = 1;
X		else
X			integer = 0;
X		while(index<endindex) ptr.i[index++]= integer;
X		break;
X	case 'f':
X	case 'r':
X		flt= atof(str);
X		while(index<endindex) ptr.f[index++]= flt;
X		break;
X	case 'g':
X		dubble= atof(str);
X		while(index<endindex) ptr.g[index++]= dubble;
X		break;
X	case 's':
X		bcopy(str,ptr.s,ival);
X		ptr.s[ival]='\0';
X		return(1);
X	default:
X		err("getpar() unknown conversion type %c\n",*type);
X	}
X	while((--ival) && ((*(str++)) != ',')); /* skip past next comma */
X    }
X    return(endindex);
X}
END_OF_FILE
if test 3753 -ne `wc -c <'Vplot_Kernel/filters/loclib/getpar_decode.c'`; then
    echo shar: \"'Vplot_Kernel/filters/loclib/getpar_decode.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/loclib/getpar_decode.c'
fi
if test -f 'Vplot_Kernel/filters/proc_vplot.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/proc_vplot.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/proc_vplot.c'\" \(3621 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/proc_vplot.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/proc_vplot.c
X *
X * Joe Dellinger (SEP), Feb 19 1988
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X *
X * Joe Dellinger Feb 22 1988
X *	Created INT_PAUSE to be separate from INT_GET_STRING.
X * Joe Dellinger Feb 27 1988
X *	Interact option turns of endpausing.
X */
X
X#include	<stdio.h>
X#include	<math.h>
X#define		GETPAR	getpar
X
X
X#include	<sys/ioctl.h>
X#include	<sys/types.h>
X#include	<sys/stat.h>
X#include	<sgtty.h>
X#include	<ctype.h>
X#include	<strings.h>
X
X#include	<vplot.h>
X
X#include	"./include/params.h"	/* for machine dependencies */
X#include	"./include/enum.h"
X#include	"./include/err.h"
X#include	"./include/attrcom.h"
X#include	"./include/intcom.h"
X#include	"./include/mesgcom.h"
X#include	"./include/erasecom.h"
X#include	"./include/closestat.h"
X#include	"./include/pat.h"
X#include	"./include/vertex.h"
X#include	"./include/round.h"
X#include	"./include/extern.h"
X
extern struct sgttyb tty_clean_state;
extern int      tty_clean_local_mode;
extern int      need_end_erase;
extern int      buffer_input;
extern int      ever_called;
extern int      out_isatty;
extern int      nplots;
extern int      endpause;
extern int      allowecho;
extern int      epause;
extern char     interact[];
extern int      pltoutfd;
extern int      (*message) ();
extern FILE    *pltin;
extern FILE    *controltty;
extern FILE    *pltinarray[];
extern char     pltinname[][MAXFLEN + 1];
extern char     pltname[];
extern int      infileno;
extern int      (*genreader) ();
X
FILE           *fopen ();
X
X/*
X * This routine is responsible for processing the input files,
X * and performing the necessary pausing, etc, that may be needed
X * at the end before exiting.
X */
X
proc_vplot ()
X{
int             ii;
char            string[MAXFLEN + 1];
X
X/*
X * Finally, shove all the plot files off to be done!
X */
X
X    if (!buffer_input)
X    {
X	for (ii = 0; ii < infileno; ii++)
X	{
X	    setbuf (pltinarray[ii], (char *) NULL);
X	}
X    }
X
X    (*genreader) (infileno, pltinarray, pltinname);
X
X/*
X * Normally, *genreader will be gen_do_dovplot, found in genlib
X */
X
X    if (ever_called)
X    {
X	dev.close (CLOSE_FLUSH);
X	if (epause > 0)
X	{
X	    sleep ((unsigned) epause);
X	}
X	if (need_end_erase)
X	{
X	    dev.erase (ERASE_END);
X	}
X	/*
X	 * Inquire point back from device. Skip endpause stuff if we do
X	 * interact, Since that's a pause in itself. 
X	 */
X	if (interact[0] != '\0')
X	{
X	    getapoint ();
X	}
X	else
X	{
X
X/*
X * Pause at the end if the user specifically asks us to on the command line,
X * even if we don't think we should because we think it's a file.
X */
X	    if (epause <= 0 &&
X		(out_isatty || getpar ("endpause", "s", string))
X		&& endpause)
X	    {
X		dev.close (CLOSE_PAUSE);
X		dev.interact (INT_F_PAUSE, controltty, string);
X	    }
X	}
X	message (MESG_ON);
X	dev.close (CLOSE_NORMAL);
X	dev.close (CLOSE_DONE);
X	nplots++;
X    }
X    else
X    {
X	dev.close (CLOSE_NOTHING);
X	ERR (COMMENT, name, "No input?");
X	dev.close (CLOSE_DONE);
X    }
X
X    /*
X     * Done, let them see what they are doing again 
X     */
X    if (!allowecho)
X    {
X	ioctl (pltoutfd, TIOCLSET, (char *) (&tty_clean_local_mode));
X	ioctl (pltoutfd, TIOCSETN, (char *) (&tty_clean_state));
X    }
X}
END_OF_FILE
if test 3621 -ne `wc -c <'Vplot_Kernel/filters/proc_vplot.c'`; then
    echo shar: \"'Vplot_Kernel/filters/proc_vplot.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/proc_vplot.c'
fi
if test -f 'Vplot_Kernel/filters/utilities/error.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/utilities/error.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/utilities/error.c'\" \(3578 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/utilities/error.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/utilities/error.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Stewart A. Levin (SEP), June 23 1987
X *	Changed system("stty echo") to ioctl() to restore original tty
X *	settings after we've deliberately forced echo off.
X * Stewart A. Levin (SEP), July 5,1987
X *      Added reset of local mode word corresponding to frontend.c change.
X * Joe Dellinger, Nov 9, 1987
X *	Stew's changes make it necessary to explicitly put "Carriage-Return
X *	Line-Feed" instead of just "\n", since output stream may be
X *	uncooked. "CRLF" is defined in mesgcom.h.
X * Joe Dellinger, Jan 10, 1988
X *	Up to 8 arguments instead of just 3! This routine isn't very kosher.
X * Joe Dellinger, Feb 16, 1988
X *	Use vsprintf on machines that have them.
X */
X
X/*
X * error reporting for VPLOT filters
X * To print text to the outside world, other routines must go through err,
X * which in turn must go through message.
X */
X
X#include <sys/ioctl.h>
X#include <sgtty.h>
X#include <stdio.h>
X#include "../include/err.h"
X#include "../include/closestat.h"
X#include "../include/mesgcom.h"
X#include "../include/extern.h"
extern int      device_open;
extern struct sgttyb tty_clean_state;
extern int      tty_clean_local_mode;
X
X#if defined (SUN) || defined (ULTRIX)
X
X#include <varargs.h>
X
ERR (va_alist)
va_dcl
X{
va_list         apdum;
int             type;
char           *filter, *fmt;
X
char            string[200];
char            text[150];
extern char    *sprintf (), *strcat ();
X
X    va_start (apdum);
X    type = va_arg (apdum, int);
X    filter = va_arg (apdum, char *);
X    fmt = va_arg (apdum, char *);
X
X    (void) vsprintf (text, fmt, apdum);
X    (void) sprintf (string, "%s: ", filter);
X
X    va_end (apdum);
X
X#else
X
ERR (type, filter, fmt, a1, a2, a3, a4, a5, a6, a7, a8)
X    int             type;
X    char           *filter, *fmt;
X    double          a1, a2, a3, a4, a5, a6, a7, a8;
X{
char            string[200];
char            text[150];
extern char    *sprintf (), *strcat ();
X
X    (void) sprintf (text, fmt, a1, a2, a3, a4, a5, a6, a7, a8);
X    (void) sprintf (string, "%s: ", filter);
X
X#endif
X
X    message (MESG_READY);
X
X    switch (type)
X    {
X    case WARN:
X	(void) strcat (string, "(warning) ");
X	(void) strcat (string, text);
X	(void) strcat (string, CRLF);
X	message (MESG_TEXT, string);
X	message (MESG_DONE);
X	break;
X    case COMMENT:
X	(void) strcat (string, " ");
X	(void) strcat (string, text);
X	(void) strcat (string, CRLF);
X	message (MESG_TEXT, string);
X	message (MESG_DONE);
X	break;
X    case FATAL:
X    default:
X	(void) strcat (string, "(fatal) ");
X	(void) strcat (string, text);
X	(void) strcat (string, CRLF);
X	message (MESG_TEXT, string);
X	message (MESG_DONE);
X	if (device_open)
X	{
X	    dev.close (CLOSE_ERROR);
X	    message (MESG_ON);
X	    dev.close (CLOSE_DONE);
X	    fflush (pltout);
X	}
X	if (!allowecho)		/* restore terminal to original tty state */
X	{
X	    (void) ioctl ((int) (fileno (pltout)), TIOCLSET,
X			  (char *) (&tty_clean_local_mode));
X	    (void) ioctl ((int) (fileno (pltout)), TIOCSETN,
X			  (char *) (&tty_clean_state));
X	}
X	exit (-1);
X    }
X}
END_OF_FILE
if test 3578 -ne `wc -c <'Vplot_Kernel/filters/utilities/error.c'`; then
    echo shar: \"'Vplot_Kernel/filters/utilities/error.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/utilities/error.c'
fi
if test -f 'Vplot_Kernel/filters/utilities/vptodev.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/utilities/vptodev.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/utilities/vptodev.c'\" \(3185 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/utilities/vptodev.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/utilities/vptodev.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X/*
X * convert vplot coordinates to device coordinates, or vice versa
X */
X#include <stdio.h>
X#include "../include/extern.h"
X#include "../include/round.h"
X
vptodevxy (x, y, outx, outy)
X    int             x, y;
X    int            *outx, *outy;
X{
float           tempx, tempy, temp;
X
X
X    tempx = (float) (x - xorigin) * xscale;
X    tempy = (float) (y - yorigin) * yscale;
X
X    temp = mxx * tempx + mxy * tempy;
X    tempy = myx * tempx + myy * tempy;
X    tempx = temp;
X
X    tempx = tempx * hdevscale + dev_xmin + hshift;
X    tempy = tempy * vdevscale + dev_ymin + vshift;
X
X    *outx = ROUND (tempx);
X    *outy = ROUND (tempy);
X}
X
vptodevw (x1, y1, x2, y2, x1out, y1out, x2out, y2out)
X    int             x1, y1, x2, y2;
X    int            *x1out, *y1out, *x2out, *y2out;
X{
int             x11, y11, x12, y12, x21, y21, x22, y22, a, b;
X
X    vptodevxy (x1, y1, &x11, &y11);
X    vptodevxy (x1, y2, &x12, &y12);
X    vptodevxy (x2, y1, &x21, &y21);
X    vptodevxy (x2, y2, &x22, &y22);
X
X    a = (x11 > x12 ? x11 : x12);
X    b = (x22 > x21 ? x22 : x21);
X    *x2out = (a > b ? a : b);
X
X    a = (y11 > y12 ? y11 : y12);
X    b = (y22 > y21 ? y22 : y21);
X    *y2out = (a > b ? a : b);
X
X    a = (x11 < x12 ? x11 : x12);
X    b = (x22 < x21 ? x22 : x21);
X    *x1out = (a < b ? a : b);
X
X    a = (y11 < y12 ? y11 : y12);
X    b = (y22 < y21 ? y22 : y21);
X    *y1out = (a < b ? a : b);
X}
X
devtovpxy (x, y, outx, outy)
X    int             x, y;
X    int            *outx, *outy;
X{
float           tempx, tempy, temp;
X
X    tempx = (float) (x - dev_xmin - hshift) / hdevscale;
X    tempy = (float) (y - dev_ymin - vshift) / vdevscale;
X
X    temp = mxx * tempx - mxy * tempy;
X    tempy = -myx * tempx + myy * tempy;
X    tempx = temp;
X
X    tempx = tempx / xscale + xorigin;
X    tempy = tempy / yscale + yorigin;
X
X    *outx = ROUND (tempx);
X    *outy = ROUND (tempy);
X}
X
devtovpw (x1, y1, x2, y2, x1out, y1out, x2out, y2out)
X    int             x1, y1, x2, y2;
X    int            *x1out, *y1out, *x2out, *y2out;
X{
int             x11, y11, x12, y12, x21, y21, x22, y22, a, b;
X
X    devtovpxy (x1, y1, &x11, &y11);
X    devtovpxy (x1, y2, &x12, &y12);
X    devtovpxy (x2, y1, &x21, &y21);
X    devtovpxy (x2, y2, &x22, &y22);
X
X    a = (x11 > x12 ? x11 : x12);
X    b = (x22 > x21 ? x22 : x21);
X    *x2out = (a > b ? a : b);
X
X    a = (y11 > y12 ? y11 : y12);
X    b = (y22 > y21 ? y22 : y21);
X    *y2out = (a > b ? a : b);
X
X    a = (x11 < x12 ? x11 : x12);
X    b = (x22 < x21 ? x22 : x21);
X    *x1out = (a < b ? a : b);
X
X    a = (y11 < y12 ? y11 : y12);
X    b = (y22 < y21 ? y22 : y21);
X    *y1out = (a < b ? a : b);
X}
END_OF_FILE
if test 3185 -ne `wc -c <'Vplot_Kernel/filters/utilities/vptodev.c'`; then
    echo shar: \"'Vplot_Kernel/filters/utilities/vptodev.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/utilities/vptodev.c'
fi
if test -f 'Vplot_Kernel/lvplot/fixcplot' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/lvplot/fixcplot'\"
else
echo shar: Extracting \"'Vplot_Kernel/lvplot/fixcplot'\" \(3089 characters\)
sed "s/^X//" >'Vplot_Kernel/lvplot/fixcplot' <<'END_OF_FILE'
X#!/bin/csh
X# fixcplot: a sed script to change cplotlib function names to the
X#           newer vplotlib names.
X#
X# keywords: vplot fix vplotlib update
X#
if ($#argv == 0) then
X	echo "fixcplot, a shell to change archaic cplotlib function names"
X	echo "to their new forms. The original file is kept in .Boriginal_file"
X	echo "Usage: fixcplot file_name"
exit
endif
X
cp $1 .B$1
expand < .B$1 | sed \
X	-e 's/ window[ ]*(/ vp_clip (/g'\
X	-e 's/ windo[ ]*(/ vp_clip (/g'\
X	-e 's/ where[ ]*(/ vp_where (/g'\
X	-e 's/ uwindow[ ]*(/ vp_uclip (/g'\
X	-e 's/ uwindo[ ]*(/ vp_uclip (/g'\
X	-e 's/ setfn[ ]*(/ vp_file (/g'\
X	-e 's/ setfp[ ]*(/ vp_filep (/g'\
X	-e 's/ set0[ ]*(/ vp_orig (/g'\
X	-e 's/ setu0[ ]*(/ vp_uorig (/g'\
X	-e 's/ setcol[ ]*(/ vp_color (/g'\
X	-e 's/ setscl[ ]*(/ vp_scale (/g'\
X	-e 's/ setdash[ ]*(/ vp_dash (/g'\
X	-e 's/ text[ ]*(\([^,]*\),\([^,]*\),\([^,]*\),\([^,]*\),\([^,]*\))/ vp_text (\1,\2,\3,90*(\4),\5)/g'\
X	-e 's/ utext[ ]*(\([^,]*\),\([^,]*\),\([^,]*\),\([^,]*\),\([^,]*\))/ vp_utext (\1,\2,\3,90*(\4),\5)/g'\
X	-e 's/ Text[ ]*(/ vp_text (/g'\
X	-e 's/ uText[ ]*(/ vp_utext (/g'\
X	-e 's/ arrow[ ]*(/ vp_arrow (/g'\
X	-e 's/ uarrow[ ]*(/ vp_uarrow (/g'\
X	-e 's/ area[ ]*(/ vp_area (/g'\
X	-e 's/ uarea[ ]*(/ vp_uarea (/g'\
X	-e 's/ draw[ ]*(/ vp_draw (/g'\
X	-e 's/ udraw[ ]*(/ vp_udraw (/g'\
X	-e 's/ endplot[ ]*(/ vp_endplot (/g'\
X	-e 's/ endplt[ ]*(/ vp_endplot (/g'\
X	-e 's/ erase[ ]*(/ vp_erase (/g'\
X	-e 's/ move[ ]*(/ vp_move (/g'\
X	-e 's/ umove[ ]*(/ vp_umove (/g'\
X	-e 's/ pendn[ ]*(/ vp_pendn (/g'\
X	-e 's/ upendn[ ]*(/ vp_upendn (/g'\
X	-e 's/ penup[ ]*(/ vp_penup (/g'\
X	-e 's/ plot[ ]*(/ vp_plot (/g'\
X	-e 's/ uplot[ ]*(/ vp_uplot (/g'\
X	-e 's/ purge_plot[ ]*(/ vp_purge (/g'\
X	-e 's/ setfat[ ]*(/ vp_fat (/g'\
X	-e 's/ setovl[ ]*(/ vp_overlay (/g' \
X	-e 's/^window[ ]*(/vp_clip (/'\
X	-e 's/^windo[ ]*(/vp_clip (/'\
X	-e 's/^where[ ]*(/vp_where (/'\
X	-e 's/^uwindow[ ]*(/vp_uclip (/'\
X	-e 's/^uwindo[ ]*(/vp_uclip (/'\
X	-e 's/^setfn[ ]*(/vp_file (/'\
X	-e 's/^setfp[ ]*(/vp_filep (/'\
X	-e 's/^set0[ ]*(/vp_orig (/'\
X	-e 's/^setu0[ ]*(/vp_uorig (/'\
X	-e 's/^setcol[ ]*(/vp_color (/'\
X	-e 's/^setscl[ ]*(/vp_scale (/'\
X	-e 's/^setdash[ ]*(/vp_dash (/'\
X	-e 's/^text[ ]*(\([^,]*\),\([^,]*\),\([^,]*\),\([^,]*\),\([^,]*\))/vp_text (\1,\2,\3,90*(\4),\5)/'\
X	-e 's/^utext[ ]*(\([^,]*\),\([^,]*\),\([^,]*\),\([^,]*\),\([^,]*\))/vp_utext (\1,\2,\3,90*(\4),\5)/'\
X	-e 's/^Text[ ]*(/vp_text (/'\
X	-e 's/^uText[ ]*(/vp_utext (/'\
X	-e 's/^arrow[ ]*(/vp_arrow (/'\
X	-e 's/^uarrow[ ]*(/vp_uarrow (/'\
X	-e 's/^area[ ]*(/vp_area (/'\
X	-e 's/^uarea[ ]*(/vp_uarea (/'\
X	-e 's/^draw[ ]*(/vp_draw (/'\
X	-e 's/^udraw[ ]*(/vp_udraw (/'\
X	-e 's/^endplot[ ]*(/vp_endplot (/'\
X	-e 's/^endplt[ ]*(/vp_endplot (/'\
X	-e 's/^erase[ ]*(/vp_erase (/'\
X	-e 's/^move[ ]*(/vp_move (/'\
X	-e 's/^umove[ ]*(/vp_umove (/'\
X	-e 's/^pendn[ ]*(/vp_pendn (/'\
X	-e 's/^upendn[ ]*(/vp_upendn (/'\
X	-e 's/^penup[ ]*(/vp_penup (/'\
X	-e 's/^plot[ ]*(/vp_plot (/'\
X	-e 's/^uplot[ ]*(/vp_uplot (/'\
X	-e 's/^purge_plot[ ]*(/vp_purge (/'\
X	-e 's/^setfat[ ]*(/vp_fat (/'\
X	-e 's/^setovl[ ]*(/vp_overlay (/' \
X| unexpand > $1
END_OF_FILE
if test 3089 -ne `wc -c <'Vplot_Kernel/lvplot/fixcplot'`; then
    echo shar: \"'Vplot_Kernel/lvplot/fixcplot'\" unpacked with wrong size!
fi
chmod +x 'Vplot_Kernel/lvplot/fixcplot'
# end of 'Vplot_Kernel/lvplot/fixcplot'
fi
if test -f 'Vplot_Kernel/lvplot/vp_plot.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/lvplot/vp_plot.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/lvplot/vp_plot.c'\" \(3100 characters\)
sed "s/^X//" >'Vplot_Kernel/lvplot/vp_plot.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./lvplot/vp_plot.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Joe Dellinger Jan 14 1988
X *	Do rounding (not truncation) before output.
X */
X
X#ifndef FORTRAN
X#include <stdio.h>
X#include <vplot.h>
X#include "round.h"
X#include "vp_pc.h"
X
PC              vp_pc =
X{
X 0.0, 0.0,
X 0.0, 0.0,
X 1.0, 1.0,
X 0.0, 0.0,
X 0.0,
X 0.0, 0.0, 0.0, 0.0,
X 0,
X 0,
X stdout,
X TH_NORMAL, TV_NORMAL,
X NO_CHANGE, NO_CHANGE, NO_CHANGE,
X};
X
vp_plot (x, y, down)
X    float           x, y;
X    int             down;
X{
float           dx, dy, dist, dpos, xp, yp, tonext, cosine, sine;
int             i;
double          p_fmod (), sqrt ();
X
X    if (!down || !vp_pc._dashon)	/* if move or no dashes */
X    {
X	p_pout (x, y, down, vp_pc._pltout);	/* output a move or draw */
X	vp_pc._xold = x;
X	vp_pc._yold = y;		/* save old x and y */
X	vp_pc._dpos = 0.0;		/* reset position in dashes */
X	return;
X    }
X    dx = x - vp_pc._xold;
X    dy = y - vp_pc._yold;		/* change in x and y */
X    dist = sqrt (dx * dx + dy * dy);	/* distance */
X    if (dist <= 0.)
X	return;			/* return if no change */
X    cosine = dx / dist;
X    sine = dy / dist;
X    dpos = vp_pc._dpos;		/* current position in dashes */
X    vp_pc._dpos = p_fmod (dpos + dist, vp_pc._ddef[3]);	/* next position in
X							 * dashes */
X    for (i = 0; i < 4 && vp_pc._ddef[i] <= dpos; i++);	/* index to dash def */
X    xp = vp_pc._xold;
X    yp = vp_pc._yold;		/* initialize xp and yp */
X    while (dist > 0.0)
X    {
X	tonext = vp_pc._ddef[i] - dpos;	/* dist to next gap or dash */
X	if (tonext > dist)
X	    tonext = dist;
X	xp += tonext * cosine;
X	yp += tonext * sine;
X	p_pout (xp, yp, !(i % 2), vp_pc._pltout);
X	dpos = vp_pc._ddef[i];	/* new position */
X	i = (i + 1) % 4;	/* i = 0,1,2, or 3 */
X	if (i == 0)
X	    dpos = 0.0;		/* back to start of dashes */
X	dist -= tonext;
X    }
X    vp_pc._xold = xp;
X    vp_pc._yold = yp;
X}
X
p_pout (xp, yp, down, plt)
X    float           xp, yp;
X    int             down;
X    FILE           *plt;
X{
int             ix, iy;
X    xp = (xp > VP_MAX) ? VP_MAX : xp;
X    xp = (xp < -VP_MAX) ? -VP_MAX : xp;
X    yp = (yp > VP_MAX) ? VP_MAX : yp;
X    yp = (yp < -VP_MAX) ? -VP_MAX : yp;
X    ix = ROUND (xp * RPERIN);
X    iy = ROUND (yp * RPERIN);
X    putc ((down ? VP_DRAW : VP_MOVE), plt);
X    puth (ix, plt);
X    puth (iy, plt);
X}
X
static double
p_fmod (x, y)
X    float           x, y;
X{
double          floor ();
X    return (x - floor (x / y) * y);
X}
X
X#else
X
X#include <stdio.h>
X#include <vplot.h>
X#include "vp_pc.h"
X
vpplot_ (x, y, down)
X    float          *x, *y;
X    int            *down;
X{
X    vp_plot (*x, *y, *down);
X}
X#endif
END_OF_FILE
if test 3100 -ne `wc -c <'Vplot_Kernel/lvplot/vp_plot.c'`; then
    echo shar: \"'Vplot_Kernel/lvplot/vp_plot.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/lvplot/vp_plot.c'
fi
echo shar: End of archive 11 \(of 24\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
