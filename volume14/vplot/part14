Subject:  v14i019:  Device-independant graphics system, with drivers
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Joe Dellinger <joe@hanauma.STANFORD.EDU>
Posting-number: Volume 14, Issue 19
Archive-name: vplot/part14

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 14 (of 24)."
# Wrapped by rsalz@fig.bbn.com on Fri Mar 25 11:47:23 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Imagen_device/imaglib/imagpoly.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imagen_device/imaglib/imagpoly.c'\"
else
echo shar: Extracting \"'Imagen_device/imaglib/imagpoly.c'\" \(5904 characters\)
sed "s/^X//" >'Imagen_device/imaglib/imagpoly.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/imaglib/imagpoly.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include <stdio.h>
X#include "imagen.h"
X#include "../include/extern.h"
X#include "../include/err.h"
X#include "../include/params.h"
X#include "../include/pat.h"
extern FILE    *pltout;
X
extern int      ipat;
extern struct pat pat[];
X
static int      loaded[NPAT];
static int      lastcolor = BLACK, lastxmask = 0, lastymask = 0, lasttexture = 0;
static int      loadm[96][3], ldnum = 1;
X
static int      draw;
X
imagstartpoly (npts)
X    int             npts;
X{
unsigned int    imask[32];
int             ix, iy, nx, ny, xmax, ymax, i, n, xmask, ymask;
int            *bptr;
char            cbuf[80];
X
X    draw = 0;
X    endpath (DRAW_PATH, imag_curcolor);	/* sets lost=1 for us as well */
X/*
X * Don't go more than a PATHLENGTH worth or addpath will draw it as a path!
X * This is no limitation, because the imagen can't hold paths any longer
X * than that anyway. So it is up to the user to fragment his polygon.
X */
X    if (npts > PATHLENGTH - 2)
X	ERR (FATAL, name, "Too many points in this polygon for the imagen!");
X
X/* pattern filling stuff */
X    if (ipat == 0)
X    {				/* masking -- old area command */
X	xmask = pat[0].xdim;
X	ymask = pat[0].ydim;
X	if (lasttexture >= 0 || lastxmask != xmask || lastymask != ymask || lastcolor != imag_curcolor)
X	{
X	    for (n = 1; n < ldnum; n++)
X	    {			/* check to see if the pattern is already
X				 * downloaded */
X		if (loadm[n][0] == xmask && loadm[n][1] == ymask
X		    && loadm[n][2] == imag_curcolor)
X		    break;
X	    }
X	    if (n == ldnum && n < 96)
X	    {			/* not loaded yet */
X		for (i = 0; i < 32; i++)
X		    imask[i] = 0;
X		if (xmask && ymask && imag_curcolor == BLACK)
X		{
X		    for (iy = 0; iy < 32; iy += ymask)
X			imask[0] |= (01 << iy);
X		    for (ix = xmask; ix < 32; ix += xmask)
X			imask[ix] = imask[0];
X		}
X		loadglyph (11, n, imask);
X		loadm[n][0] = xmask;
X		loadm[n][1] = ymask;
X		loadm[n][2] = imag_curcolor;
X		ldnum++;
X	    }
X	    settexture (11, n);
X	    lasttexture = -n;
X	    lastxmask = xmask;
X	    lastymask = ymask;
X	    lastcolor = imag_curcolor;
X	}
X    }
X    else
X    {				/* loaded patterns */
X	if (pat[ipat].patbits == NULL)
X	{
X	    sprintf (cbuf, "Pattern number %d not loaded.", ipat);
X	    ERR (WARN, name, cbuf);
X	    settexture (0, 0);
X	    lasttexture = 0;
X	    return;
X	}
X	if (ipat < 0)
X	{
X	    settexture (0, 0);
X	    lasttexture = 0;
X	    return;
X	}
X	if (lasttexture != ipat)
X	{
X	    if (!loaded[ipat])
X	    {
X		nx = pat[ipat].xdim;
X		ny = pat[ipat].ydim;
X		bptr = pat[ipat].patbits;
X		if (nx > 32 || ny > 32)
X		{
X		    ERR (WARN, name, "Imagen pattern fill is 32 bits by 32 bits;\n\tGot %d by %d, so truncating.", nx, ny);
X		}
X		if ((nx < 32 && nx != 16 && nx != 8 && nx != 4 && nx != 2 && nx != 1) ||
X		    (ny < 32 && ny != 16 && ny != 8 && ny != 4 && ny != 2 && ny != 1))
X		{
X		    ERR (WARN, name, "Imagen pattern fill is 32 bits by 32 bits;\n\tGot %d by %d, so partially replicating.", nx, ny);
X		}
X		xmax = (nx < 32) ? nx : 32;
X		ymax = (ny < 32) ? ny : 32;
X		for (i = 0; i < 32; i++)
X		    imask[i] = 0;
X/*
X * IMPRESS bit order for pattern filling starts at lower left and scans upward
X * along the left edge, then left to right by columns.  This would be standard
X * order for a page oriented for text, but not for our graphics convention
X * of x-direction is paper-feed direction.
X */
X
X		for (iy = 0; iy < ymax; iy++)
X		{
X		    for (ix = 0; ix < xmax; ix++)
X		    {
X			if (*bptr++)
X			{
X			    imask[ix] |= (01 << iy);
X			}
X		    }
X		    if (nx > 32)
X		    {
X			for (; ix < nx; ix++)
X			    bptr++;	/* discard extra y-bits */
X		    }
X		}
X		if (ny < 32)
X		{		/* replicate in y-direction */
X		    do
X		    {
X			for (ix = 0; ix < xmax; ix++)
X			    imask[ix] |= (imask[ix] << iy);
X			iy *= 2;
X		    } while (iy < 32);
X		}
X		for (ix = xmax; ix < 32; ix++)
X		{		/* replicate in x-direction */
X		    imask[ix] = imask[ix - nx];
X		}
X		loadglyph (10, ipat, imask);
X		loaded[ipat] = 1;
X	    }
X	    settexture (10, ipat);
X	    lasttexture = ipat;
X	}
X    }
X}
X
X
imagmidpoly (x, y)
X    int             x, y;
X{
X    imagplot (x, y, draw);
X    draw = 1;
X}
X
imagendpoly (done)
X    int             done;
X{
extern int      overlay;
int             overlay_im;
X
X    switch (overlay)
X    {
X    case 0:
X	overlay_im = OPAQUE;
X	break;
X    case 1:
X	overlay_im = OR;
X	break;
X    }
X    endpath (FILL_PATH, overlay_im);
X}
X
settexture (family, member)
X{
X    putc (SET_TEXTURE, pltout);
X    putrfm (0, family, member);
X}
X
loadglyph (family, member, imask)
X    unsigned int    imask[];
X{
int             i;
X
X    putc (BGLY, pltout);
X    putrfm (0, family, member);
X    put2byte (0);
X    put2byte (32);
X    put2byte (0);
X    put2byte (32);
X    put2byte (0);
X    for (i = 0; i < 32; i++)
X    {
X	put4byte (imask[i]);
X    }
X}
X
putrfm (rot, fam, mem)
X{
char            rfm1, rfm2;
X
X    rfm1 = ((rot & 03) << 6) | ((unsigned) (fam & 0177) >> 1);
X    rfm2 = ((fam & 01) << 7) | (mem & 0177);
X    putc (rfm1, pltout);
X    putc (rfm2, pltout);
X}
X
put2byte (in)
X    unsigned int    in;
X{
char            c;
X
X    c = (in >> 8) & 0xff;
X    putc (c, pltout);
X    c = (in & 0xff);
X    putc (c, pltout);
X}
X
put4byte (in)
X    unsigned int    in;
X{
char            c;
X
X    c = (in >> 24) & 0xff;
X    putc (c, pltout);
X    c = (in >> 16) & 0xff;
X    putc (c, pltout);
X    c = (in >> 8) & 0xff;
X    putc (c, pltout);
X    c = (in & 0xff);
X    putc (c, pltout);
X}
END_OF_FILE
if test 5904 -ne `wc -c <'Imagen_device/imaglib/imagpoly.c'`; then
    echo shar: \"'Imagen_device/imaglib/imagpoly.c'\" unpacked with wrong size!
fi
# end of 'Imagen_device/imaglib/imagpoly.c'
fi
if test -f 'Imagen_device/imaglib/imagraster.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imagen_device/imaglib/imagraster.c'\"
else
echo shar: Extracting \"'Imagen_device/imaglib/imagraster.c'\" \(8746 characters\)
sed "s/^X//" >'Imagen_device/imaglib/imagraster.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/imaglib/imagraster.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Joe Dellinger Feb 16 1988
X *	Update to new raster call.
X */
X
X#include <stdio.h>
X#include "../include/extern.h"
X#include "../include/enum.h"
X#include "../include/err.h"
X#include "imagen.h"
X
extern int      overlay;
extern char    *calloc ();
extern FILE    *pltout;
extern int      overlay;
X
X/*
X * raster for the (barf) imagen-300, which can only align things on multiples
X * of 32 by 32! This routine does what is necessary to make the imagen ACT
X * as if it could place it arbitrarily. - Joe Dellinger, Nov 1986
X */
X
imagraster (count, out_of, xout, yout, length, orient, raster, dummy1, dummy2)
X    int             count, out_of, xout, yout, length, orient, dummy1, dummy2;
X    char           *raster;
X{
int             ii, jj, kk, ll, base;
int             xgoof_s, ygoof_s, xgoof_e, ygoof_e, length_x, length_y;
char            byte;
static int      num_lines;
static char    *array;
static int      ylength, length_p;
static int      xgoof, ygoof, xpatch;
static int      overlay_im;
X
X    if (count == 0)
X    {
X/*
X * First time through. Do various things that need to be done once at the
X * beginning:
X */
X
X	switch (overlay)
X	{
X	case 0:
X	    overlay_im = OPAQUE;
X	    break;
X	case 1:
X	    overlay_im = OR;
X	    break;
X	}
X
X	/*
X	 * Treasure the raster up into 32 byte blocks. This is actually a
X	 * constant, but I'll let it be a variable so that the similarity of
X	 * this code to genraster1.c is more clear. 
X	 */
X	num_lines = 32;
X
X	/* End any unfinished path */
X	endpath (DRAW_PATH, imag_curcolor);
X
X	/*
X	 * Imagen can only position raster every 32 pixels... 
X	 *
X	 * The complexity here comes about because the truncation occurs in
X	 * physical, unrotated coordinates, whereas we're working in
X	 * (possibly) rotated and opposite-handed ones. Ug! 
X	 */
X
X	/* Dimensions in each direction in Imagen physical coordinates  */
X	if (orient == 1 || orient == 3)
X	{
X	    length_x = out_of;
X	    length_y = length;
X	}
X	else
X	{
X	    length_x = length;
X	    length_y = out_of;
X	}
X
X	/* Find extremes of padded raster area */
X	if (orient == 0 || orient == 3)
X	{
X	    /* X direction start truncates down */
X	    xgoof_s = num_lines * div_round (xout, num_lines);
X	    xgoof = xout - xgoof_s;
X	    /* X direction end truncates up */
X	    xgoof_e = num_lines * div_round ((xout + (length_x - 1) + num_lines), num_lines);
X	}
X	else
X	{
X	    /* X direction start truncates up */
X	    xgoof_s = num_lines * div_round ((xout + num_lines), num_lines);
X	    xgoof = -(xout - xgoof_s) - 1;
X	    /* X direction end truncates down */
X	    xgoof_e = num_lines * div_round ((xout - (length_x - 1)), num_lines);
X	}
X
X	if (orient == 0 || orient == 1)
X	{
X	    /* Y direction start truncates up */
X	    ygoof_s = num_lines * div_round ((yout + num_lines), num_lines);
X	    ygoof = -(yout - ygoof_s) - 1;
X	    /* Y direction end truncates down */
X	    ygoof_e = num_lines * div_round ((yout - (length_y - 1)), num_lines);
X	}
X	else
X	{
X	    /* Y direction start truncates down */
X	    ygoof_s = num_lines * div_round (yout, num_lines);
X	    ygoof = yout - ygoof_s;
X	    /* Y direction end truncates up */
X	    ygoof_e = num_lines * div_round ((yout + (length_y - 1) + num_lines), num_lines);
X	}
X
X	/*
X	 * Tell the imagen where to put it while we're still in physical
X	 * coord's 
X	 */
X	putc (SET_ABS_H, pltout);
X	putc (hib (ygoof_s), pltout);
X	putc (lob (ygoof_s), pltout);
X	putc (SET_ABS_V, pltout);
X	putc (hib (xgoof_s), pltout);
X	putc (lob (xgoof_s), pltout);
X
X	if (orient == 1 || orient == 3)
X	{
X	    ii = xgoof;
X	    xgoof = ygoof;
X	    ygoof = ii;
X	    ii = xgoof_s;
X	    xgoof_s = ygoof_s;
X	    ygoof_s = ii;
X	    ii = xgoof_e;
X	    xgoof_e = ygoof_e;
X	    ygoof_e = ii;
X	    ii = xout;
X	    xout = yout;
X	    yout = ii;
X	}
X/* 
X * xgoof and ygoof now tell us how much padding we have to insert to
X * correct for the imagen's mispositioning goofs.
X */
X
X	/*
X	 * Rotate the imagen's internal coordinate system so that the main
X	 * thrust of its raster direction is in the same direction as
X	 * Vplot's. 
X	 */
X	putc (SET_HV_SYSTEM, pltout);
X	putc (0x01, pltout);
X
X	/*
X	 * If rotated coordinates, then rotate on top of this to match 
X	 */
X	if (orient == 1 || orient == 3)
X	{
X	    putc (SET_HV_SYSTEM, pltout);
X	    putc (0x01, pltout);
X	}
X
X	/*
X	 * If flipped coordinates, then flip on top of this to match 
X	 */
X	if (orient == 2 || orient == 3)
X	{
X	    putc (SET_HV_SYSTEM, pltout);
X	    putc (0x02, pltout);
X	}
X
X	/*
X	 * Allocate an array to hold 32 raster lines at a time. Use calloc so
X	 * that we start out full of 0's, some of which we'll need for
X	 * padding. length_p gives length rounded to the correct multiple of
X	 * 32, which is needed for the raster plus the padding. xpatch tells
X	 * us how many patches we'll need per line. 
X	 */
X
X	length_p = abs (xgoof_e - xgoof_s);
X	xpatch = length_p / num_lines;
X	array = (char *) calloc (num_lines * length_p, sizeof (char));
X	if (array == NULL)
X	    ERR (FATAL, name, "Can't allocate %d bytes for imagen raster buffer",
X		 num_lines * length_p * sizeof (char));
X
X	/*
X	 * Displace where we start into the block the first time through to
X	 * do the required padding. 
X	 */
X	ylength = ygoof;
X    }
X
X/*
X * Each time we're called, we get another line of the raster image.
X * Save this line in the block we're currently storing up, converting
X * to monochrome as we do so.
X */
X    for (ii = 0; ii < length; ii++)
X    {
X	array[length_p * ylength + ii + xgoof] = (raster[ii] > 0);
X    }
X    ylength++;
X
X/*
X * See if we've saved up an entire block yet. Also, if this is the last
X * call, we'd better not wait around either.
X */
X    if (ylength >= num_lines || count == out_of - 1)
X    {
X	if (count == out_of - 1)
X	{
X	    /*
X	     * Clear out any garbage left in the part of the patch that's
X	     * padding. Only need to worry about this the last time, when we
X	     * may not have filled in the entire patch. 
X	     */
X	    for (jj = ylength; jj < num_lines; jj++)
X	    {
X		for (ii = 0; ii < length; ii++)
X		{
X		    array[length_p * jj + ii + xgoof] = 0;
X		}
X	    }
X	}
X
X	/*
X	 * Tell the imagen a bitmap is coming 
X	 */
X	putc (BITMAP, pltout);
X	/* Set the overlay mode as given in Vplot */
X	putc (overlay_im, pltout);
X	/* How many patches needed to draw this line */
X	putc (xpatch, pltout);
X	/* Each Y line gets a separate call of its own */
X	putc (1, pltout);
X
X	/* Finally, here are the actual bits */
X	for (ii = 0; ii < xpatch; ii++)
X	{
X	    /* Loop over patches */
X	    for (jj = 0; jj < num_lines; jj++)
X	    {
X		/* Loop over 32 rows in a patch */
X		for (kk = 0; kk < 4; kk++)
X		{
X		    /*
X		     * 4 for the 4 bytes encoding 32 bits for the 32 pixels
X		     * in each row of a patch 
X		     */
X/*
X * Here we calculate base offset into our array. The bizarre ordering
X * is due to the bizarre order in which the imagen wants the bits.
X */
X		    base = ii * num_lines + jj * length_p + kk * 8;
X
X		    byte = 0x0;
X		    for (ll = 0; ll < 8; ll++)
X		    {
X			/* Loop over the 8 bits in each byte */
X
X			byte = (byte << 1) | (array[base + ll] & 0x1);
X		    }
X		    /* Another byte rides the bus */
X		    putc (byte, pltout);
X		}
X	    }
X	}
X
X	if (count != out_of - 1)
X	{
X/*
X * Now we've done a block. Reset our position in a block to 0 again, and
X * advance the imagen's current position one block-length. (Drawing raster
X * doesn't change the imagen's "current pen position".) Pointless to do this
X * stuff if we're never coming back.
X */
X	    ylength = 0;
X	    putc (SET_REL_V, pltout);
X	    putc (hib (num_lines), pltout);
X	    putc (lob (num_lines), pltout);
X	}
X	else
X	{
X/*
X * Things that have to be done before we exit the last time.
X */
X	    /* Free up the array */
X	    free (array);
X	    /* Put the imagen's coordinate system back again */
X	    if (orient == 2 || orient == 3)
X	    {
X		putc (SET_HV_SYSTEM, pltout);
X		putc (0x02, pltout);
X	    }
X	    if (orient == 1 || orient == 3)
X	    {
X		putc (SET_HV_SYSTEM, pltout);
X		putc (0x03, pltout);
X	    }
X	    putc (SET_HV_SYSTEM, pltout);
X	    putc (0x03, pltout);
X	}
X    }
X}
X
div_round (a, b)
X    int             a, b;
X{
X    if ((a >= 0) == (b >= 0))
X	return (a / b);
X    else
X    {
X	if (b > 0)
X	    return (a - (b - 1)) / b;
X	else
X	    return (-a - (-b - 1)) / -b;
X    }
X}
END_OF_FILE
if test 8746 -ne `wc -c <'Imagen_device/imaglib/imagraster.c'`; then
    echo shar: \"'Imagen_device/imaglib/imagraster.c'\" unpacked with wrong size!
fi
# end of 'Imagen_device/imaglib/imagraster.c'
fi
if test -f 'Virtual_device/vplib/vpdovplot.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Virtual_device/vplib/vpdovplot.c'\"
else
echo shar: Extracting \"'Virtual_device/vplib/vpdovplot.c'\" \(6843 characters\)
sed "s/^X//" >'Virtual_device/vplib/vpdovplot.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/vplib/vpdovplot.c
X *
X * Joe Dellinger (SEP), Jan 9 1988
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include <stdio.h>
X#include <vplot.h>
X#include "../include/enum.h"
X#include "../include/extern.h"
X#include "../include/params.h"
X#include "../include/err.h"
X#include "vp.h"
X
extern FILE    *pltout;
extern int      first_time;
extern int      style;
extern int      default_style;
X
extern int
vecarea (), genmarker (), gentext (), genraster ();
extern int
genmessage (), genvector (), vp_do_dovplot (), nulldev ();
extern int
vplogvector (), vplogmessage ();
extern int      (*genreader) ();
X
extern int
vpopen (), vpreset (), vpmessage (), vperase (), vpclose ();
extern int
vpattributes (), vpvector (), vpplot ();
extern int
vpstartpoly (), vpmidpoly (), vpendpoly ();
extern int
vpraster (), vpmarker (), vptext ();
extern int
genarea (), genpoint ();
X
int             vpxmax, vpxmin, vpymax, vpymin;
static int      vpxmaxs, vpxmins, vpymaxs, vpymins;
X
vp_do_dovplot (nn, inpltin, innames)
X    int             nn;
X    FILE          **inpltin;
X    char            innames[][MAXFLEN + 1];
X{
int             ii;
int             save_wantras;
int             save_shade;
char            string[80];
static int      it_got_clipped;
float           hh, ww;
X
X    if (nn == 0)
X	return;
X
X/*
X * If they want statistics, make one "dummy" pass through first
X * before you really do it.
X */
X    if (vpalign)
X    {
X	/*
X	 * Turn on automatic processing 
X	 */
X	smart_clip = NO;
X	smart_raster = NO;
X
X	/*
X	 * Just outline polygons and raster with vectors 
X	 */
X	save_wantras = wantras;
X	save_shade = shade;
X
X	wantras = NO;
X	shade = NO;
X
X	/*
X	 * Turn off any actual output 
X	 */
X	dev.reset = nulldev;
X	dev.message = vplogmessage;
X	message = dev.message;
X	dev.erase = nulldev;
X	dev.close = nulldev;
X	dev.vector = vplogvector;
X	dev.marker = genmarker;
X	dev.text = gentext;
X	dev.area = nulldev;
X	dev.raster = nulldev;
X	dev.point = genpoint;
X	dev.attributes = nulldev;
X
X/*
X * Now do the trial pass
X */
X
X	vpxmaxs = dev_xmin;
X	vpxmins = dev_xmax;
X	vpymaxs = dev_ymin;
X	vpymins = dev_ymax;
X
X	it_got_clipped = NO;
X
X	for (ii = 0; ii < nn; ii++)
X	{
X	    vpxmax = dev_xmin;
X	    vpxmin = dev_xmax;
X	    vpymax = dev_ymin;
X	    vpymin = dev_ymax;
X
X	    pltin = inpltin[ii];
X	    strcpy (pltname, innames[ii]);
X	    dovplot ();
X	    rewind (pltin);
X
X	    if (vpxmaxs < vpxmax)
X		vpxmaxs = vpxmax;
X	    if (vpymaxs < vpymax)
X		vpymaxs = vpymax;
X	    if (vpxmins > vpxmin)
X		vpxmins = vpxmin;
X	    if (vpymins > vpymin)
X		vpymins = vpymin;
X
X	    if (vpstat)
X	    {
X		hh = (float) (vpymax - vpymin) / RPERIN;
X		ww = (float) (vpxmax - vpxmin) / RPERIN;
X
X		if (hh < 0. || ww < 0.)
X		{
X		    fprintf (pltout,
X			     "%17s: clipped away. ",
X			     innames[ii]);
X		}
X		else
X		{
X		    fprintf (pltout,
X			     "%17s: h=%6.2f w=%6.2f;  x=(%6.2f,%6.2f) y=(%6.2f,%6.2f) ",
X			     innames[ii],
X			     hh, ww,
X			     (float) vpxmin / RPERIN,
X			     (float) vpxmax / RPERIN,
X			     (float) vpymin / RPERIN,
X			     (float) vpymax / RPERIN);
X		}
X
X		if (vpxmax == dev_xmin || vpxmax == dev_xmax ||
X		    vpxmin == dev_xmax || vpxmin == dev_xmin ||
X		    vpymax == dev_ymin || vpymax == dev_ymax ||
X		    vpymin == dev_ymax || vpymin == dev_ymin)
X		{
X		    fprintf (pltout, "*\n");
X		    it_got_clipped = YES;
X		}
X		else
X		{
X		    fprintf (pltout, "\n");
X		}
X	    }
X	}
X
X	if (vpstat && nn > 1)
X	{
X	    sprintf (string, "All %d", nn);
X	    fprintf (pltout,
X		"%17s: h=%6.2f w=%6.2f;  x=(%6.2f,%6.2f) y=(%6.2f,%6.2f)\n",
X		     string,
X		     (float) (vpymaxs - vpymins) / RPERIN,
X		     (float) (vpxmaxs - vpxmins) / RPERIN,
X		     (float) vpxmins / RPERIN,
X		     (float) vpxmaxs / RPERIN,
X		     (float) vpymins / RPERIN,
X		     (float) vpymaxs / RPERIN);
X	}
X
X	if (vpstat)
X	{
X	    if (it_got_clipped)
X	    {
X		if (vpbig)
X		{
X		    fprintf (pltout,
X			 "\nA * indicates a plot that has been clipped.\n");
X		    fprintf (pltout,
X			     "Remember rotated style plots go to the top of the screen,\n");
X		    fprintf (pltout,
X			     "which is infinitely far away if big=y.\n");
X		}
X		else
X		{
X		    fprintf (pltout,
X		    "\nA * indicates a plot that has been clipped at the\n");
X		    fprintf (pltout,
X		     "virtual screen boundaries. You may not want this.\n");
X		    fprintf (pltout,
X		    "This clipping can be disabled by the big=y option.\n");
X		}
X	    }
X
X	    for (ii = 0; ii < nn; ii++)
X	    {
X		pltin = inpltin[ii];
X		fclose (pltin);
X	    }
X	    return;
X/*
X * Statistics get changed by re-aligning anyways,
X * So might as well just exit.
X */
X	}
X
X	switch (vpaligns[0])
X	{
X	case 'l':
X	    default_hshift += (0 - vpxmins);
X	    break;
X	case 'r':
X	    default_hshift += (0 - vpxmaxs);
X	    break;
X	case 'c':
X	    default_hshift += (0 - ((vpxmaxs + vpxmins) / 2));
X	    break;
X	case 'u':
X	    break;
X	default:
X	    ERR (WARN, name, "Unknown left-right alignment type %c.",
X		 vpaligns[0]);
X	    break;
X	}
X
X	switch (vpaligns[1])
X	{
X	case 'b':
X	    default_vshift += (0 - vpymins);
X	    break;
X	case 't':
X	    default_vshift += (0 - vpymaxs);
X	    break;
X	case 'c':
X	    default_vshift += (0 - ((vpymaxs + vpymins) / 2));
X	    break;
X	case 'u':
X	    break;
X	default:
X	    ERR (WARN, name, "Unknown top-bottom alignment type %c.",
X		 vpaligns[1]);
X	    break;
X	}
X
X	style = default_style;
X
X	reset_parameters ();
X
X	/*
X	 * Lie to dovplot, tell it to start from scratch again 
X	 */
X	first_time = YES;
X
X	/*
X	 * Undo the damage from the first pass 
X	 */
X	wantras = save_wantras;
X	shade = save_shade;
X
X	dev.reset = vpreset;
X	dev.message = vpmessage;
X	message = dev.message;
X	dev.erase = vperase;
X	dev.close = vpclose;
X	dev.vector = vpvector;
X	dev.marker = vpmarker;
X	dev.text = vptext;
X	dev.area = genarea;
X	dev.raster = vpraster;
X	dev.point = genpoint;
X	dev.attributes = vpattributes;
X    }
X
X/*
X *********************************************************************
X * "Real" pass
X *********************************************************************
X */
X
X    if (vpdumb)
X    {
X	dev.message = genmessage;
X	dev.vector = genvector;
X	dev.marker = genmarker;
X	dev.text = gentext;
X	dev.area = vecarea;
X	dev.raster = genraster;
X	smart_clip = NO;
X	smart_raster = NO;
X    }
X    else
X    {
X	smart_clip = YES;
X	smart_raster = YES;
X    }
X
X/* Second (or first) pass */
X    for (ii = 0; ii < nn; ii++)
X    {
X	pltin = inpltin[ii];
X	strcpy (pltname, innames[ii]);
X	dovplot ();
X	fclose (pltin);
X    }
X}
END_OF_FILE
if test 6843 -ne `wc -c <'Virtual_device/vplib/vpdovplot.c'`; then
    echo shar: \"'Virtual_device/vplib/vpdovplot.c'\" unpacked with wrong size!
fi
# end of 'Virtual_device/vplib/vpdovplot.c'
fi
if test -f 'Vplot_Kernel/filters/Tests/DEMO_Graph' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/Tests/DEMO_Graph'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/Tests/DEMO_Graph'\" \(6754 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/Tests/DEMO_Graph' <<'END_OF_FILE'
e
S s
w 0 0 7560 5580
f 1
c 7
m 1380 690
d 6180 690
p
m 1380 900
d 6180 900
p
m 1380 1110
d 6180 1110
p
m 1380 1320
d 6180 1320
p
m 1380 1530
d 6180 1530
p
m 1380 1740
d 6180 1740
p
m 1380 1950
d 6180 1950
p
m 1380 2160
d 6180 2160
p
m 1380 2370
d 6180 2370
p
m 1380 2580
d 6180 2580
p
m 1380 2790
d 6180 2790
p
m 1380 3000
d 6180 3000
p
m 1380 3210
d 6180 3210
p
m 1380 3420
d 6180 3420
p
m 1380 3630
d 6180 3630
p
m 1380 3840
d 6180 3840
p
m 1380 4050
d 6180 4050
p
m 1380 4260
d 6180 4260
p
m 1380 4470
d 6180 4470
p
m 1380 4680
d 6180 4680
p
m 1380 4890
d 6180 4890
p
f 2
m 1380 690
d 6180 690
p
f 0
J 3 3
m 1260 690
T 6 0
X0
p
f 2
m 1380 1530
d 6180 1530
p
f 0
m 1260 1530
T 6 0
X200
p
f 2
m 1380 2370
d 6180 2370
p
f 0
m 1260 2370
T 6 0
X400
p
f 2
m 1380 3210
d 6180 3210
p
f 0
m 1260 3210
T 6 0
X600
p
f 2
m 1380 4050
d 6180 4050
p
f 0
m 1260 4050
T 6 0
X800
p
f 2
m 1380 4890
d 6180 4890
p
f 0
m 1260 4890
T 6 0
X1000
p
J 2 -2
m 660 2790
T 6 90
Pressure (psia)
p
f 1
m 1380 690
d 1380 4890
p
m 1540 690
d 1540 4890
p
m 1700 690
d 1700 4890
p
m 1860 690
d 1860 4890
p
m 2020 690
d 2020 4890
p
m 2180 690
d 2180 4890
p
m 2340 690
d 2340 4890
p
m 2500 690
d 2500 4890
p
m 2660 690
d 2660 4890
p
m 2820 690
d 2820 4890
p
m 2980 690
d 2980 4890
p
m 3140 690
d 3140 4890
p
m 3300 690
d 3300 4890
p
m 3460 690
d 3460 4890
p
m 3620 690
d 3620 4890
p
m 3780 690
d 3780 4890
p
m 3940 690
d 3940 4890
p
m 4100 690
d 4100 4890
p
m 4260 690
d 4260 4890
p
m 4420 690
d 4420 4890
p
m 4580 690
d 4580 4890
p
m 4740 690
d 4740 4890
p
m 4900 690
d 4900 4890
p
m 5060 690
d 5060 4890
p
m 5220 690
d 5220 4890
p
m 5380 690
d 5380 4890
p
m 5540 690
d 5540 4890
p
m 5700 690
d 5700 4890
p
m 5860 690
d 5860 4890
p
m 6020 690
d 6020 4890
p
m 6180 690
d 6180 4890
p
f 2
m 1380 690
d 1380 4890
p
f 0
J 2 6
m 1380 570
T 6 0
X200
p
f 2
m 2180 690
d 2180 4890
p
f 0
m 2180 570
T 6 0
X250
p
f 2
m 2980 690
d 2980 4890
p
f 0
m 2980 570
T 6 0
X300
p
f 2
m 3780 690
d 3780 4890
p
f 0
m 3780 570
T 6 0
X350
p
f 2
m 4580 690
d 4580 4890
p
f 0
m 4580 570
T 6 0
X400
p
f 2
m 5380 690
d 5380 4890
p
f 0
m 5380 570
T 6 0
X450
p
f 2
m 6180 690
d 6180 4890
p
f 0
m 6180 570
T 6 0
X500
p
J 2 8
m 3780 330
T 6 0
Temperature
p
J 2 -2
m 3780 5070
T 9 0
Binary P-T Diagram   C2 - nC5
p
w 1380 690 6180 4890
f 3
c 6
m 4449 1307
d 4777 1616
d 4858 1708
d 5215 2201
d 5472 2680
d 5587 2987
d 5590 3011
d 5588 3024
d 5580 3030
d 5526 2986
d 5268 2650
d 4801 2083
d 4307 1616
d 4093 1455
d 3483 1111
d 2958 921
d 2513 817
p
c 5
m 3864 1307
d 4307 1616
d 4417 1708
d 5048 2368
d 5431 2867
d 5535 2996
d 5580 3030
d 5585 3028
d 5588 3024
d 5590 3011
d 5582 2963
d 5530 2813
d 5370 2474
d 5133 2074
d 4777 1616
d 4680 1515
d 4277 1181
d 3922 983
d 3608 865
p
f 5
c 4
m 4241 1307
d 4536 1616
d 4609 1708
d 5003 2368
d 5275 3104
d 5289 3160
d 5336 3414
d 5343 3518
d 5330 3622
d 5324 3637
d 5268 3677
d 5237 3672
d 5031 3507
d 4734 3160
d 4663 3072
d 4312 2641
d 3992 2270
d 3703 1964
d 3442 1714
d 3331 1616
d 3206 1512
d 2991 1349
d 2702 1160
d 2446 1024
d 2218 925
d 1919 828
p
c 3
m 2932 1307
d 3305 1595
d 3331 1616
d 3746 2007
d 4271 2592
d 4733 3160
d 4884 3342
d 5189 3648
d 5267 3677
d 5303 3665
d 5324 3637
d 5331 3620
d 5342 3544
d 5343 3518
d 5333 3384
d 5289 3160
d 5266 3070
d 5148 2710
d 4991 2343
d 4705 1842
d 4536 1616
d 4430 1493
d 4173 1250
d 3934 1080
d 3609 917
p
f 3
c 2
m 4124 1307
d 4404 1616
d 4472 1708
d 4840 2368
d 5108 3160
d 5110 3165
d 5194 3746
d 5188 3851
d 5158 3970
d 5083 4026
d 4914 3930
d 4725 3731
d 4531 3485
d 4340 3227
d 4291 3160
d 4155 2973
d 3978 2733
d 3729 2405
d 3498 2119
d 3284 1874
d 3035 1616
d 2992 1575
d 2730 1345
d 2494 1170
d 2179 986
p
c 1
m 2683 1307
d 2994 1577
d 3035 1616
d 3349 1946
d 3755 2438
d 4220 3063
d 4291 3160
d 4736 3743
d 4986 3984
d 5079 4017
d 5156 3965
d 5172 3928
d 5193 3763
d 5194 3748
d 5180 3544
d 5137 3289
d 5108 3160
d 5031 2879
d 4885 2473
d 4711 2099
d 4452 1680
d 4404 1616
d 4205 1386
d 3973 1179
d 3757 1034
d 3460 893
p
f 5
c 6
m 3995 1307
d 4258 1616
d 4322 1708
d 4665 2368
d 4915 3160
d 4974 3457
d 5020 3950
d 5020 3979
d 4957 4290
d 4938 4311
d 4872 4338
d 4864 4338
d 4779 4306
d 4686 4233
d 4590 4130
d 4442 3941
d 4294 3728
d 4077 3393
d 3929 3160
d 3868 3064
d 3670 2755
d 3392 2342
d 3138 1994
d 2903 1707
d 2821 1616
d 2585 1378
d 2301 1146
d 2046 986
d 1712 840
p
c 5
m 2506 1307
d 2777 1568
d 2821 1616
d 3078 1918
d 3597 2644
d 3929 3160
d 4208 3597
d 4851 4337
d 4873 4339
d 4958 4292
d 5020 3955
d 5020 3916
d 4915 3160
d 4895 3077
d 4623 2268
d 4339 1733
d 4258 1616
d 4065 1380
d 3810 1146
d 3573 991
d 3253 852
p
f 3
c 4
m 3847 1307
d 4094 1616
d 4153 1708
d 4471 2368
d 4700 3160
d 4756 3457
d 4818 4126
d 4796 4394
d 4766 4498
d 4716 4583
d 4667 4611
d 4646 4613
d 4606 4606
d 4541 4571
d 4438 4475
d 4372 4394
d 4278 4264
d 4116 4007
d 3956 3728
d 3724 3307
d 3643 3160
d 3504 2908
d 3295 2546
d 3005 2082
d 2737 1712
d 2660 1616
d 2491 1426
d 2156 1125
d 1859 939
d 1596 828
p
c 3
m 2371 1307
d 2614 1562
d 2660 1616
d 2877 1898
d 3317 2582
d 3643 3160
d 3818 3478
d 4370 4392
d 4372 4394
d 4632 4612
d 4647 4613
d 4717 4585
d 4794 4394
d 4806 4303
d 4815 4109
d 4785 3664
d 4700 3160
d 4659 2982
d 4503 2456
d 4337 2051
d 4172 1739
d 4094 1616
d 4009 1498
d 3776 1237
d 3558 1060
d 3355 940
d 3077 829
p
f 5
c 2
m 3672 1307
d 3899 1616
d 3954 1708
d 4244 2368
d 4452 3160
d 4502 3457
d 4563 4202
d 4563 4243
d 4557 4394
d 4516 4652
d 4471 4750
d 4423 4790
d 4417 4793
d 4391 4797
d 4356 4791
d 4292 4752
d 4189 4642
d 4030 4397
d 4028 4394
d 3869 4098
d 3710 3775
d 3479 3290
d 3417 3160
d 3258 2837
d 3048 2431
d 2749 1925
d 2532 1616
d 2471 1539
d 2213 1256
d 1861 984
d 1552 835
p
c 1
m 2265 1307
d 2485 1556
d 2532 1616
d 2719 1878
d 3096 2521
d 3417 3160
d 3508 3351
d 3955 4262
d 4028 4394
d 4182 4633
d 4391 4797
d 4393 4797
d 4423 4790
d 4480 4736
d 4543 4527
d 4557 4394
d 4563 4207
d 4562 4122
d 4503 3462
d 4452 3160
d 4403 2928
d 4286 2498
d 4164 2150
d 4039 1869
d 3915 1642
d 3899 1616
d 3734 1381
d 3560 1191
d 3315 1000
d 3091 882
p
f 3
c 6
m 3119 1307
d 3297 1616
d 3339 1708
d 3560 2368
d 3714 3160
d 3749 3457
d 3783 4056
d 3782 4138
d 3761 4394
d 3744 4465
d 3685 4538
d 3672 4536
d 3629 4504
d 3579 4434
d 3557 4394
d 3475 4219
d 3362 3934
d 3241 3609
d 3115 3265
d 3075 3160
d 2915 2750
d 2599 2060
d 2340 1616
d 2279 1528
d 1968 1167
d 1632 919
p
c 5
m 2104 1307
d 2287 1539
d 2340 1616
d 2473 1830
d 2752 2374
d 3075 3160
d 3108 3246
d 3427 4102
d 3556 4394
d 3629 4506
d 3684 4538
d 3687 4538
d 3761 4394
d 3769 4343
d 3783 4062
d 3764 3626
d 3715 3160
d 3523 2230
d 3380 1805
d 3297 1616
d 3236 1498
d 3096 1275
d 2960 1114
d 2831 997
d 2649 879
p
w 0 0 7560 5580
f 0
c 7
m 1380 690
d 1380 4890
p
m 1380 690
d 6180 690
p
m 6180 4890
d 6180 690
p
m 6180 4890
d 1380 4890
p
END_OF_FILE
if test 6754 -ne `wc -c <'Vplot_Kernel/filters/Tests/DEMO_Graph'`; then
    echo shar: \"'Vplot_Kernel/filters/Tests/DEMO_Graph'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/Tests/DEMO_Graph'
fi
if test -f 'Vplot_Kernel/filters/genlib/polysubs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/genlib/polysubs.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/genlib/polysubs.c'\" \(7470 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/genlib/polysubs.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/genlib/polysubs.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include <stdio.h>
X#include "../include/extern.h"
X#define OUT 0
X#define IN  1
X#define UNSET -1
X
X/*
X * Do a simple-minded polygon clipping. If it goes out, draw it to where it
X * crossed the edge. When it comes back in, draw it from where it hit the
X * edge. This is complicated if you have to deal with several edges, but
X * very easy for one edge. So, since I'm lazy, I did it four times, each
X * routine reading in points, clipping, and sending the output on for
X * further clipping. Finally, it sends it on to polyfix which does
X * complicated processing. JAD 5-11-84
X */
X
inter (x1, x2, y1, y2, x)
X    int             x1, x2, y1, y2, x;
X{
X    return y1 + (y2 - y1) * (x - x1) / (x2 - x1);
X}
X
xminclip (xin, yin, first)
X    int             xin, yin, *first;
X{
static int      xstart, ystart;
static int      ostatus;
int             status;
static int      firstout;
static int      xold, yold;
X
X    if (*first == 2)
X    {
X	ostatus = UNSET;
X	firstout = 2;
X	yminclip (0, 0, &firstout);
X	return;
X    }
X
X    if (*first == -1)
X    {
X	if (ostatus == UNSET)
X	{
X	    /* We never got anything! */
X	    return;
X	}
X	/* finish up */
X	xin = xstart;
X	yin = ystart;
X    }
X
X    status = IN;
X    if (xin < xwmin)
X	status = OUT;
X
X    if (*first == 1)
X    {
X	/* This is the first time we have been called */
X	xstart = xin;
X	ystart = yin;
X	firstout = 1;
X	*first = 0;
X	ostatus = status;
X	xold = xin;
X	yold = yin;
X	return;
X    }
X/* Not our first time */
X
X    switch (status)
X    {
X    case IN:
X	switch (ostatus)
X	{
X	case IN:
X	    /* in this time, in last time */
X	    yminclip (xin, yin, &firstout);
X	    break;
X	case OUT:
X	    /* out last time, in now */
X	    /* find where we came in! */
X	    yminclip (xwmin, inter (xold, xin, yold, yin, xwmin), &firstout);
X	    yminclip (xin, yin, &firstout);
X	    break;
X	}
X	break;
X    case OUT:
X	switch (ostatus)
X	{
X	case IN:
X	    /* in last time, out now */
X	    /* find where we went out */
X	    yminclip (xwmin, inter (xold, xin, yold, yin, xwmin), &firstout);
X	    break;
X	case OUT:
X	    /* out last time, still out */
X	    /* don't output anything */
X	    break;
X	}
X	break;
X    }
X    if (*first == -1)
X    {
X	firstout = -1;
X	yminclip (0, 0, &firstout);
X    }
X    else
X    {
X	xold = xin;
X	yold = yin;
X	ostatus = status;
X    }
X}
X
X
yminclip (xin, yin, first)
X    int             xin, yin, *first;
X{
static int      xstart, ystart;
static int      ostatus;
int             status;
static int      firstout;
static int      xold, yold;
X
X    if (*first == 2)
X    {
X	ostatus = UNSET;
X	firstout = 2;
X	xmaxclip (0, 0, &firstout);
X	return;
X    }
X
X    if (*first == -1)
X    {
X	if (ostatus == UNSET)
X	{
X	    /* We never got anything! */
X	    return;
X	}
X	/* finish up */
X	xin = xstart;
X	yin = ystart;
X    }
X
X    status = IN;
X    if (yin < ywmin)
X	status = OUT;
X
X    if (*first == 1)
X    {
X	/* This is the first time we have been called */
X	xstart = xin;
X	ystart = yin;
X	firstout = 1;
X	*first = 0;
X	ostatus = status;
X	xold = xin;
X	yold = yin;
X	return;
X    }
X/* Not our first time */
X
X    switch (status)
X    {
X    case IN:
X	switch (ostatus)
X	{
X	case IN:
X	    /* in this time, in last time */
X	    xmaxclip (xin, yin, &firstout);
X	    break;
X	case OUT:
X	    /* out last time, in now */
X	    /* find where we came in! */
X	    xmaxclip (inter (yold, yin, xold, xin, ywmin), ywmin, &firstout);
X	    xmaxclip (xin, yin, &firstout);
X	    break;
X	}
X	break;
X    case OUT:
X	switch (ostatus)
X	{
X	case IN:
X	    /* in last time, out now */
X	    /* find where we went out */
X	    xmaxclip (inter (yold, yin, xold, xin, ywmin), ywmin, &firstout);
X	    break;
X	case OUT:
X	    /* out last time, still out */
X	    /* don't output anything */
X	    break;
X	}
X	break;
X    }
X    if (*first == -1)
X    {
X	firstout = -1;
X	xmaxclip (0, 0, &firstout);
X    }
X    else
X    {
X	xold = xin;
X	yold = yin;
X	ostatus = status;
X    }
X}
X
xmaxclip (xin, yin, first)
X    int             xin, yin, *first;
X{
static int      xstart, ystart;
static int      ostatus;
int             status;
static int      firstout;
static int      xold, yold;
X
X    if (*first == 2)
X    {
X	ostatus = UNSET;
X	firstout = 2;
X	ymaxclip (0, 0, &firstout);
X	return;
X    }
X
X    if (*first == -1)
X    {
X	if (ostatus == UNSET)
X	{
X	    /* We never got anything! */
X	    return;
X	}
X	/* finish up */
X	xin = xstart;
X	yin = ystart;
X    }
X
X    status = IN;
X    if (xin > xwmax)
X	status = OUT;
X
X    if (*first == 1)
X    {
X	/* This is the first time we have been called */
X	xstart = xin;
X	ystart = yin;
X	firstout = 1;
X	*first = 0;
X	ostatus = status;
X	xold = xin;
X	yold = yin;
X	return;
X    }
X/* Not our first time */
X
X    switch (status)
X    {
X    case IN:
X	switch (ostatus)
X	{
X	case IN:
X	    /* in this time, in last time */
X	    ymaxclip (xin, yin, &firstout);
X	    break;
X	case OUT:
X	    /* out last time, in now */
X	    /* find where we came in! */
X	    ymaxclip (xwmax, inter (xold, xin, yold, yin, xwmax), &firstout);
X	    ymaxclip (xin, yin, &firstout);
X	    break;
X	}
X	break;
X    case OUT:
X	switch (ostatus)
X	{
X	case IN:
X	    /* in last time, out now */
X	    /* find where we went out */
X	    ymaxclip (xwmax, inter (xold, xin, yold, yin, xwmax), &firstout);
X	    break;
X	case OUT:
X	    /* out last time, still out */
X	    /* don't output anything */
X	    break;
X	}
X	break;
X    }
X    if (*first == -1)
X    {
X	firstout = -1;
X	ymaxclip (0, 0, &firstout);
X    }
X    else
X    {
X	xold = xin;
X	yold = yin;
X	ostatus = status;
X    }
X}
X
X
ymaxclip (xin, yin, first)
X    int             xin, yin, *first;
X{
static int      xstart, ystart;
static int      ostatus;
int             status;
static int      firstout;
static int      xold, yold;
X
X    if (*first == 2)
X    {
X	ostatus = UNSET;
X	return;
X    }
X
X    if (*first == -1)
X    {
X	if (ostatus == UNSET)
X	{
X	    /* We never got anything! */
X	    return;
X	}
X	/* finish up */
X	xin = xstart;
X	yin = ystart;
X    }
X
X    status = IN;
X    if (yin > ywmax)
X	status = OUT;
X
X    if (*first == 1)
X    {
X	/* This is the first time we have been called */
X	xstart = xin;
X	ystart = yin;
X	firstout = 1;
X	*first = 0;
X	ostatus = status;
X	xold = xin;
X	yold = yin;
X	return;
X    }
X/* Not our first time */
X
X    switch (status)
X    {
X    case IN:
X	switch (ostatus)
X	{
X	case IN:
X	    /* in this time, in last time */
X	    polyfix (xin, yin, &firstout);
X	    break;
X	case OUT:
X	    /* out last time, in now */
X	    /* find where we came in! */
X	    polyfix (inter (yold, yin, xold, xin, ywmax), ywmax, &firstout);
X	    polyfix (xin, yin, &firstout);
X	    break;
X	}
X	break;
X    case OUT:
X	switch (ostatus)
X	{
X	case IN:
X	    /* in last time, out now */
X	    /* find where we went out */
X	    polyfix (inter (yold, yin, xold, xin, ywmax), ywmax, &firstout);
X	    break;
X	case OUT:
X	    /* out last time, still out */
X	    /* don't output anything */
X	    break;
X	}
X	break;
X    }
X    if (*first == -1)
X    {
X	/* We're done! */
X	return;
X    }
X    else
X    {
X	xold = xin;
X	yold = yin;
X	ostatus = status;
X    }
X}
END_OF_FILE
if test 7470 -ne `wc -c <'Vplot_Kernel/filters/genlib/polysubs.c'`; then
    echo shar: \"'Vplot_Kernel/filters/genlib/polysubs.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/genlib/polysubs.c'
fi
if test -f 'Vplot_Kernel/filters/include/vplotfonts/pen.vplot_font' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/include/vplotfonts/pen.vplot_font'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/include/vplotfonts/pen.vplot_font'\" \(6248 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/include/vplotfonts/pen.vplot_font' <<'END_OF_FILE'
X30 131
X2 3 7
X8 6 3 0 -2
X
e 5555 5555 " 5555 (Out of order, but order doesn't matter)
m -1 6
d -1 5
m 0 6
d 0 5
e 1 1 \127 4 (Character number 127... no good ASCII representation)
A 4
X	-1 3
X	-1 5
X	1 5
X	1 3
X/* This line is a comment */
e 5555 5555 $ (The final "5555" can just be dropped, if you wish)
m -2 2
d -1 1
d 1 1
d 2 2
d 1 3
d -1 3
d -2 4
d -1 5
d 1 5
d 2 4
m 0 6
d -1 0
m 1 6
d 0 0
e 1 1 ! (This character needs a bit of extra space over the default)
m 0 7
d 0 2
d 1 7
d 0 7
m 0 1
d 0 0
d 1 1
d 0 1
e 5555 5555 ~
m -2 4
d -1 5
d 1 4
d 2 5
e 5555 5555 #
m -2 0
d 0 6
m 0 0
d 2 6
m -2 4
d 2 4
m -2 2
d 2 2
e 5555 5555 %
m -2 0
d 2 6
d -1 6
d -2 5
d -1 4
d 0 5
d -1 6
m 1 0
d 0 1
d 1 2
d 2 1
d 1 0
e 5555 5555 &
m 2 1
d 1 0
d -1 0
d -2 1
d -2 2
d -1 3
d 1 3
d 2 4
d 2 5
d 1 6
d 0 6
d -1 5
d -1 4
d 2 0
e 5555 5555 '
m -1 4
d 0 6
e 5555 5555 (
m 1 0
d 0 1
d 0 5
d 1 6
e 5555 5555 )
m -1 0
d 0 1
d 0 5
d -1 6
e 5555 5555 *
m -2 1
d 2 5
m -2 5
d 2 1
m 0 0
d 0 6
m -2 3
d 2 3
e 5555 5555 +
m -2 3
d 2 3
m 0 5
d 0 1
e 5555 5555 ,
m -1 -1
d 1 1
d 0 2
d -1 1
d 0 0
e 5555 5555 -
m -2 3
d 2 3
e 5555 5555 .
m 0 0
d 1 1
d 0 2
d -1 1
d 0 0
e 5555 5555 /
m -2 0
d 2 6
e 5555 5555 0
m -1 0
d -2 1
d -2 5
d -1 6
d 1 6
d 2 5
d 2 1
d 1 0
d -1 0
e 5555 5555 1
m -1 5
d 0 6
d 0 0
m -1 0
d 1 0
e 5555 5555 2
m -2 5
d -1 6
d 1 6
d 2 5
d 2 4
d 1 3
d -1 3
d -2 2
d -2 0
d 2 0
d 2 1
e 5555 5555 3
m -2 1
d -1 0
d 1 0
d 2 1
d 2 2
d 1 3
d -1 3
m 1 3
d 2 4
d 2 5
d 1 6
d -1 6
d -2 5
e 5555 5555 4
m 1 0
d 1 6
d -2 2
d 2 2
e 5555 5555 5
m -2 1
d -1 0
d 1 0
d 2 1
d 2 2
d 1 3
d -2 3
d -2 6
d 2 6
e 5555 5555 6
m 2 5
d 1 6
d -1 6
d -2 5
d -2 1
d -1 0
d 1 0
d 2 1
d 2 2
d 1 3
d -1 3
d -2 2
e 5555 5555 7
m -2 6
d 2 6
d -2 0
m -1 3
d 1 3
e 5555 5555 8
m -1 0
d -2 1
d -2 2
d -1 3
d 1 3
d 2 2
d 2 1
d 1 0
d -1 0
m -1 3
d -2 4
d -2 5
d -1 6
d 1 6
d 2 5
d 2 4
d 1 3
e 5555 5555 9
m -2 1
d -1 0
d 1 0
d 2 1
d 2 5
d 1 6
d -1 6
d -2 5
d -2 3
d -1 2
d 1 2
d 2 3
e 5555 5555 :
m 0 1
d 1 2
d -1 4
d 0 5
d 1 4
d -1 2
d 0 1
e 5555 5555 ;
m -1 -1
d 1 1
d -1 3
d 0 4
d 1 3
d -1 1
d 0 0
e 5555 5555 <
m 2 5
d -2 3
d 2 1
e 5555 5555 =
m -2 4
d 2 4
m -2 2
d 2 2
e 5555 5555 >
m -2 5
d 2 3
d -2 1
e 5555 5555 ?
m -2 5
d -1 6
d 1 6
d 2 5
d 2 4
d 1 3
d 0 3
d 0 2
m 0 1
d 0 0
e 5555 5555 @
m 0 1
d 1 2
d 1 4
d 0 5
d -1 4
d -1 2
d 0 1
d 1 1
d 2 2
d 2 5
d 1 6
d -1 6
d -2 5
d -2 1
d -1 0
d 1 0
d 2 1
e 5555 5555 A
m -2 0
d -2 5
d -1 6
d 1 6
d 2 5
d 2 0
m -2 2
d 2 2
e 5555 5555 B
m -2 0
d -2 6
d 1 6
d 2 5
d 2 4
d 1 3
d -2 3
m 1 3
d 2 2
d 2 1
d 1 0
d -2 0
e 5555 5555 C
m 2 1
d 1 0
d -1 0
d -2 1
d -2 5
d -1 6
d 1 6
d 2 5
e 5555 5555 D
m -2 0
d -2 6
d 1 6
d 2 5
d 2 1
d 1 0
d -2 0
e 5555 5555 E
m -2 0
d -2 6
d 2 6
m -2 3
d 1 3
m -2 0
d 2 0
e 5555 5555 F
m -2 0
d -2 6
d 2 6
m -2 3
d 1 3
e 5555 5555 G
m 1 2
d 2 2
d 2 1
d 1 0
d -1 0
d -2 1
d -2 5
d -1 6
d 1 6
d 1 6
d 2 5
e 5555 5555 H
m -2 0
d -2 6
m -2 3
d 2 3
m 2 6
d 2 0
e 5555 5555 I
m -1 0
d 1 0
m 0 0
d 0 6
m -1 6
d 1 6
e 5555 5555 J
m -2 1
d -1 0
d 0 0
d 1 1
d 1 6
e 5555 5555 K
m -2 0
d -2 6
m -2 2
d 2 6
m 0 4
d 2 0
e 5555 5555 L
m -2 6
d -2 0
d 2 0
d 2 1
e 5555 5555 M
m -2 0
d -2 6
d 0 3
d 2 6
d 2 0
e 5555 5555 N
m -2 0
d -2 6
d 2 0
d 2 6
e 5555 5555 O
m -1 0
d -2 1
d -2 5
d -1 6
d 1 6
d 2 5
d 2 1
d 1 0
d -1 0
e 5555 5555 P
m -2 0
d -2 6
d 1 6
d 2 5
d 2 4
d 1 3
d -2 3
e 5555 5555 Q
m -1 0
d -2 1
d -2 5
d -1 6
d 1 6
d 2 5
d 2 1
d 1 0
d -1 0
m 1 1
d 2 0
e 5555 5555 R
m -2 0
d -2 6
d 1 6
d 2 5
d 2 4
d 1 3
d -2 3
m 0 3
d 2 0
e 5555 5555 S
m -2 1
d -1 0
d 1 0
d 2 1
d 2 2
d 1 3
d -1 3
d -2 4
d -2 5
d -1 6
d 1 6
d 2 5
e 5555 5555 T
m -2 6
d 2 6
m 0 6
d 0 0
e 5555 5555 U
m -2 6
d -2 1
d -1 0
d 1 0
d 2 1
d 2 6
e 5555 5555 V
m -2 6
d 0 0
d 2 6
e 5555 5555 W
m -2 6
d -1 0
d 0 3
d 1 0
d 2 6
e 5555 5555 X
m -2 0
d 2 6
m -2 6
d 2 0
e 5555 5555 Y
m -2 6
d 0 3
d 2 6
m 0 3
d 0 0
e 5555 5555 Z
m -2 6
d 2 6
d -2 0
d 2 0
e 5555 5555 [
m 2 6
d 0 6
d 0 0
d 2 0
e 5555 5555 \
m -2 6
d 2 0
e 5555 5555 ]
m -2 0
d 0 0
d 0 6
d -2 6
e 5555 5555 ^
m -2 4
d 0 6
d 2 4
e 5555 5555 _
m -3 -1
d 3 -1
e 5555 5555 `
m 0 6
d 1 4
e 5555 5555 a
m -1 0
d -2 1
d -2 3
d -1 4
d 1 4
d 2 3
d 2 1
d 2 1
d 1 0
d -1 0
m 2 4
d 2 0
e 5555 5555 b
m -2 0
d -2 6
m -2 3
d -1 4
d 1 4
d 2 3
d 2 1
d 1 0
d -1 0
d -2 1
e 5555 5555 c
m 2 3
d 1 4
d -1 4
d -2 3
d -2 1
d -1 0
d 1 0
d 2 1
e 5555 5555 d
m 2 6
d 2 0
m 2 1
d 1 0
d -1 0
d -2 1
d -2 3
d -1 4
d 1 4
d 2 3
e 5555 5555 e
m 2 1
d 1 0
d -1 0
d -2 1
d -2 3
d -1 4
d 1 4
d 2 3
d 2 2
d -2 2
e 5555 5555 f
m -1 0
d -1 5
d 0 6
d 1 6
d 2 5
m -2 3
d 0 3
e 5555 5555 g
m -2 -1
d -1 -2
d 1 -2
d 2 -1
d 2 4
m 2 3
d 1 4
d -1 4
d -2 3
d -2 1
d -1 0
d 1 0
d 2 1
e 5555 5555 h
m -2 0
d -2 6
m -2 3
d -1 4
d 1 4
d 2 3
d 2 0
e 5555 5555 i
m 0 0
d 0 4
m 0 6
d 0 7
e 5555 5555 j
m -2 -1
d -1 -2
d 0 -2
d 1 -1
d 1 3
m 1 4
d 1 5
e 5555 5555 k
m -2 0
d -2 6
m -2 2
d 2 4
m 0 3
d 2 0
e 5555 5555 l
m 0 0
d 0 5
e 5555 5555 m
m -2 0
d -2 4
m -2 3
d -1 4
d 0 3
d 0 0
m 0 3
d 1 4
d 2 3
d 2 0
e 5555 5555 n
m -2 0
d -2 4
m -2 3
d -1 4
d 1 4
d 2 3
d 2 0
e 5555 5555 o
m -1 0
d -2 1
d -2 3
d -1 4
d 1 4
d 2 3
d 2 1
d 1 0
d -1 0
e 5555 5555 p
m -2 4
d -2 -2
m -2 3
d -1 4
d 1 4
d 2 3
d 2 1
d 1 0
d -1 0
d -2 1
e 5555 5555 q
m 2 -2
d 2 4
m 2 3
d 1 4
d -1 4
d -2 3
d -2 1
d -1 0
d 1 0
d 2 1
e 5555 5555 r
m -2 0
d -2 4
m -2 3
d -1 4
d 1 4
d 2 3
e 5555 5555 s
m -2 1
d -1 0
d 1 0
d 2 1
d 1 2
d -1 2
d -2 3
d -1 4
d 1 4
d 2 3
e 5555 5555 t
m 0 0
d 0 5
m -1 4
d 1 4
e 5555 5555 u
m -2 4
d -2 1
d -1 0
d 1 0
d 2 1
d 2 4
e 5555 5555 v
m -2 4
d 0 0
d 2 4
e 5555 5555 w
m -2 4
d -1 0
d 0 4
d 1 0
d 2 4
e 5555 5555 x
m -2 0
d 2 4
m -2 4
d 2 0
e 5555 5555 y
m -1 -2
d 1 -2
d 2 -1
d 2 4
m 2 1
d 1 0
d -1 0
d -2 1
d -2 4
e 5555 5555 z
m -2 4
d 2 4
d -2 0
d 2 0
e 5555 5555 {
m 2 6
d 1 6
d 0 5
d 0 4
d -1 3
d 0 2
d 0 1
d 1 0
d 2 0
e 5555 5555 |
m 0 7
d 0 5
m 0 2
d 0 0
e 5555 5555 }
m -2 0
d -1 0
d 0 1
d 0 2
d 1 3
d 0 4
d 0 5
d -1 6
d -2 6
e 5555 5555 \128
m -2 3
d 0 2
A 5
X	-2 3
X	-2 5
X	0 6
X	2 5
X	2 3
m 2 3
d 0 2
e 5555 5555 \129
m 0 3
d -1 5
d -1 3
d 0 3
A 3
X	0 3
X	1 5
X	1 3
e 5555 5555 \130
A 4
X	-1 3
X	1 5
X	-1 5
X	1 3
m -2 2
d 2 6
d -2 6
d 2 2
d -2 2
e 5555 5555 \131
m -2 2
d -2 6
d 2 6
d 2 2
d -2 2
A 4
X	-1 3
X	-1 5
X	1 5
X	1 3
e 5555 5555 \30    # The "error" glyph
m -2 5
d -1 6
d 1 6
d 2 5
d 2 4
d 1 3
d 0 3
d 0 2
m 0 1
d 0 0
m 0 -2
d -5 3
d 0 8
d 5 3
d 0 -2
END_OF_FILE
if test 6248 -ne `wc -c <'Vplot_Kernel/filters/include/vplotfonts/pen.vplot_font'`; then
    echo shar: \"'Vplot_Kernel/filters/include/vplotfonts/pen.vplot_font'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/include/vplotfonts/pen.vplot_font'
fi
echo shar: End of archive 14 \(of 24\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
