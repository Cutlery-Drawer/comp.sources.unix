Subject:  v14i021:  Device-independant graphics system, with drivers
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Joe Dellinger <joe@hanauma.STANFORD.EDU>
Posting-number: Volume 14, Issue 21
Archive-name: vplot/part16

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 16 (of 24)."
# Wrapped by rsalz@fig.bbn.com on Fri Mar 25 11:47:26 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Vplot_Kernel/filters/include/vplotfonts/makefont.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/include/vplotfonts/makefont.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/include/vplotfonts/makefont.c'\" \(13926 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/include/vplotfonts/makefont.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/include/vplotfonts/makefont.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Joe Dellinger Oct 18 1987
X *	Made arrays allocated dynamically
X */
X
X/*
X * This program converts easily understandable "Vplot font" files into
X * an "include" form which is suitable for being included into gentext.c,
X * and also simultaneously into a binary ("bin") form that can be loaded at
X * runtime by gentext.c. (The Makefile in this directory shows how the
X * several resulting files must be combined.)
X *
X * makefont font_name < Vplot_font > Vplot_font.include
X *
X * If no font_name is given, it will be called "XXXXX".
X *
X * A "Vplot font" file has the following form:
X * Line 1:   start  end
X * These are the ASCII values of the beginning and ending characters
X * which will be in this font.
X * (Beginning and ending as in lowest and highest numbered in the ASCII
X * collating sequence... it is OK to not have every character in that interval)
X * Line 2: letter line space
X * Space between letters, space between lines, width of a space.
X * Line 3: top cap half base bottom
X * Vertical coordinates for "top" (Top of highest normal character in font,
X * typically), "cap" (Top of typical capital letter), "half" (What you align
X * on for vertical centering), "base" (Bottom of most letters, except those
X * with descenders), "bottom" (Bottom of lowest normal descender)
X * N Lines: Lig val1 val2 val3 ...
X * The first number is the integer ascii value of a glyph which is a ligature
X * of the ascii characters with value val1, val2, ... (up to 6)
X * A blank line signifies the end of the ligatures.
X * Start of a character line: e left right char symb
X * 'e' is simply the Vplot character for "erase", and is fixed.
X * "char" tells what ASCII code to assign this glyph to... (need be in no
X * particular order!) If "char" is outside the normal ASCII range it can also
X * be represented \num , where num is the "ASCII" number of the glyph. num
X * is NOT restricted to be less than 256! These characters can be accessed
X * via the \vnum command of gentext.
X * left, right, give the left and right half-widths
X * of the character (it is assumed that all characters are centered at
X * coordinate zero left and right), symb gives the vertical coordinate for
X * centering if this character is used as a symbol. If "left", "right",
X * or "symb" are unknown, these may be replaced instead by "5555" and
X * this program will calculate them for you. (Also leftright=0 set inside
X * this program will force such calculation of all left and right widths,
X * as will symbol=0 force such calculation of all vertical centering
X * coordinates. Instead of 5555, "symb" can also simply be omitted.)
X * Move line: m xcoordinate ycoordinate
X * Start of actual glyph coordinates... you must always start with a move.
X * Coordinates must be LESS THAN 64 in absolute value.
X * Draw line: d xcoordinate ycoordinate
X * Typically the next line will be a draw.
X * Start polygon line: A npts
X * It is also possible to put in a polygon.
X * Polygon line: tab xcoordinate ycoordinate
X * there should be following a Start Polygon line npts lines of coordinates,
X * each beginning with a tab or a space.
X * Continue in this way until the next 'e' signals the start of the next
X * character.
X *
X * Files in this format may be viewed using plas:
X * plas < Vplot_font | ?pen xcenter=0 ycenter=0 scale=150 ...
X *
X * Refer to the pen.vplot_font file given here as an example.
X *
X * - Joe Dellinger, Stanford University Dept of Earth Science
X */
X
X#include <stdio.h>
X#include "../params.h"
extern char    *malloc ();
X
X#define EOCBIT 0x8000	/* END OF CHARACTER MARK OR POLYGON BIT */
X#define DRAWBIT 0x4000	/* DRAW BIT */
X#define XBIT 0x0040
X#define YBIT 0x2000
X#define UNDEFINED	-1
X
X/* Too big a number to be a possible width or height, which is bounded by 64 */
X#define MAGIC		5555
X#define MAX_LENGTH	10000	/* Max number of lines in input Vplot file */
X#define MAX_FONT	32768	/* Max number of symbols in a font */
X#define MAX_STRING	10	/* Max length of char number */
X
int             length[7] =
X{
X 0, 0, 0, 0, 0, 0, 0
X};
int             length2[7] =
X{
X 0, 0, 0, 0, 0, 0, 0
X};
X
main (argc, argv)
X    int             argc;
X    char          **argv;
X{
char           *mde, *cp;
int            *x, *y, *z, *xp, *yp, *zp;
char           *ch, *chp;
int            *addr;
int             addr_index;
int             xout, xmax, xmin, ymin, ymax, nc = 0;
int            *lwidth, *rwidth;
int            *symb;
int             pad, leftright, symbol;
char            string[133];
int             start, end;
int             first = 1;
int             letter, line, space, top, cap, half, base, bottom;
int             left, right, vsymb, count;
char            name[100];
int             i, j, iaddr;
int             fd;
unsigned short  ushort;
short           sshort;
int             integer;
int             lengtht;
int             lig[7];
X
X    mde = (char *) malloc (MAX_LENGTH * sizeof (char));
X    x = (int *) malloc (MAX_LENGTH * sizeof (int));
X    y = (int *) malloc (MAX_LENGTH * sizeof (int));
X    z = (int *) malloc (MAX_LENGTH * sizeof (int));
X    ch = (char *) malloc (MAX_LENGTH * MAX_STRING * sizeof (char));
X    addr = (int *) malloc (MAX_FONT * sizeof (int));
X    lwidth = (int *) malloc (MAX_FONT * sizeof (int));
X    rwidth = (int *) malloc (MAX_FONT * sizeof (int));
X    symb = (int *) malloc (MAX_FONT * sizeof (int));
X
X    for (i = 0; i < MAX_FONT; i++)
X    {
X	addr[i] = UNDEFINED;
X	lwidth[i] = UNDEFINED;
X	rwidth[i] = UNDEFINED;
X    }
X    for (i = 0; i < MAX_LENGTH; i++)
X    {
X	x[i] = MAGIC;
X	y[i] = MAGIC;
X	z[i] = MAGIC;
X    }
X
X    xp = x;
X    yp = y;
X    zp = z;
X    cp = mde;
X    chp = ch;
X
X/*
X * Change these next 3 lines in order to add padding or to always ignore
X * the given width and height information
X */
X    pad = 0;
X    leftright = 1;
X    symbol = 1;
X
X
X    if (argc == 1)
X    {
X	strcpy (name, "XXXXX");
X    }
X    else
X    {
X	strcpy (name, argv[1]);
X    }
X    strcat (name, "_");
X
X    gets (string);
X    sscanf (string, "%d %d", &start, &end);
X    gets (string);
X    sscanf (string, "%d %d %d", &letter, &line, &space);
X    space -= 2 * letter;
X    gets (string);
X    sscanf (string, "%d %d %d %d %d", &top, &cap, &half, &base, &bottom);
X
X    sprintf (string, "%slig", name);
X    fd = creat (string, 0777);
X    printf ("int %slig[] =\n{\n", name);
X
X    while (1)
X    {
X	gets (string);
X/* At most 6 characters in a ligature! */
X	lig[0] = 0;
X	i = sscanf (string, "%d %d %d %d %d %d %d",
X		 lig, lig + 1, lig + 2, lig + 3, lig + 4, lig + 5, lig + 6);
X	if (i <= 1)
X	{
X	    printf ("%d,  ", 0);
X	    integer = 0;
X	    write (fd, (char *) &integer, sizeof (int));
X	    length[6] += sizeof (int);
X
X	    printf ("\n};\n\n");
X	    close (fd);
X	    break;
X	}
X	else
X	{
X	    printf ("%d,  ", i - 1);
X	    integer = i - 1;
X	    write (fd, (char *) &integer, sizeof (int));
X	    length[6] += sizeof (int);
X
X	    printf ("%d, ", lig[0]);
X	    integer = lig[0];
X	    write (fd, (char *) &integer, sizeof (int));
X	    length[6] += sizeof (int);
X
X	    for (j = 1; j < i; j++)
X	    {
X		printf ("%d,", lig[j]);
X		integer = lig[j];
X		write (fd, (char *) &integer, sizeof (int));
X		length[6] += sizeof (int);
X	    }
X	    printf ("\n");
X	}
X    }
X
X    while (gets (string))
X    {
X	*chp = '\0';
X	*(chp + 1) = '\0';
X	*(chp + 2) = '\0';
X	sscanf (string, "%c %d %d %s %d", cp++, xp++, yp++, chp, zp++);
X	chp += MAX_STRING;
X	nc++;
X    }
X    *cp = 'e';
X    *chp = '\0';
X    nc++;
X
X    printf ("unsigned short %svec[] =\n{\n", name);
X    sprintf (string, "%ssvec", name);
X    fd = creat (string, 0777);
X
X    for (i = 0, iaddr = 0; i < nc; ++i)
X    {
X	switch (mde[i])
X	{
X	case ('e'):
X	    /* Things to do when ending a character */
X	    if (!first)
X	    {
X		xout = EOCBIT;
X		if (!leftright || left == MAGIC || right == MAGIC)
X		{
X		    lwidth[addr_index] = -xmin + pad / 2.;
X		    rwidth[addr_index] = xmax + pad / 2.;
X		}
X		else
X		{
X		    lwidth[addr_index] = left;
X		    rwidth[addr_index] = right;
X		}
X		if (!symbol || vsymb == MAGIC)
X		{
X		    symb[addr_index] = (ymax + ymin) / 2;
X		}
X		else
X		{
X		    symb[addr_index] = vsymb;
X		}
X	    }
X	    else
X		first = 0;
X
X	    /* Things to do when beginning a character */
X	    if (ch[i * MAX_STRING + 0] != '\0')
X	    {
X		count = 0;
X		ymax = -10000;
X		ymin = 10000;
X		xmax = -10000;
X		xmin = 10000;
X		if (ch[i * MAX_STRING + 0] != '\\' || ch[i * MAX_STRING + 1] == '\0')
X		{
X		    addr_index = ch[i * MAX_STRING + 0];
X		}
X		else
X		{
X		    sscanf (&ch[i * MAX_STRING + 0], "\\%d ", &addr_index);
X		}
X		if (addr_index < start || addr_index > end)
X		{
X		    fprintf (stderr, "Character value %d out of promised range %d to %d!\n", addr_index, start, end);
X		    exit (1);
X		}
X		addr_index -= start;
X		addr[addr_index] = iaddr;
X		left = x[i];
X		right = y[i];
X		vsymb = z[i];
X	    }
X	    break;
X	case 'A':
X	    count = x[i];
X	    if (count < 3)
X	    {
X		fprintf (stderr, "Polygon must have more than 2 vertices!\n");
X		exit (2);
X	    }
X	    /* Don't increment iaddr, no output */
X	    continue;
X	    break;
X	case '\t':
X	    mde[i] = ' ';
X	case ' ':
X	    count--;
X	case ('d'):
X	case ('m'):
X	    xout = x[i] < 0 ? -(x[i]) : x[i];
X	    if (x[i] < 0)
X		xout |= XBIT;
X	    xout |= ((y[i] < 0 ? -(y[i]) : y[i]) << 7);
X	    if (y[i] < 0)
X		xout |= YBIT;
X	    if (mde[i] == 'd')
X		xout |= DRAWBIT;
X	    else
X	    if (mde[i] == ' ')
X	    {
X		xout |= DRAWBIT;
X		if (count > 0)
X		    xout |= EOCBIT;
X	    }
X
X	    xmax = x[i] < xmax ? xmax : x[i];
X	    xmin = x[i] > xmin ? xmin : x[i];
X	    ymax = y[i] < ymax ? ymax : y[i];
X	    ymin = y[i] > ymin ? ymin : y[i];
X	    break;
X	default:
X	    /* ignore this line */
X	    continue;
X	    break;
X	}
X
X	/*
X	 * Only increment pointer for those things which output something,
X	 * and also the first time. 
X	 */
X	iaddr++;
X	if (i > 0)
X	{
X	    printf ("%d,", xout);
X	    ushort = xout;
X	    write (fd, (char *) &ushort, sizeof (unsigned short));
X	    length[5] += sizeof (unsigned short);
X	    if (xout == EOCBIT)
X		printf ("\n");
X	}
X    }				/* end for loop  */
X    close (fd);
X
X/*
X * Check info
X */
X    sprintf (string, "%scheck", name);
X    fd = creat (string, 0777);
X    write (fd, (char *) "Vplot Binary fonT  \n", 20);
X    integer = FONTCHECK;
X    write (fd, (char *) &integer, sizeof (int));
X    close (fd);
X
X/*
X * Now write out all the Binary information.
X * We will write out each different sort of thing into a different
X * file, and then use "cat" to put them all together.
X * Keep track of how long each piece is as we write it out
X * so that we construct the "table of contents" to the concatenated file.
X */
X
X    sprintf (string, "%saddr", name);
X    fd = creat (string, 0777);
X
X    printf ("};\n\n\nint %saddr[] =\n{\n", name);
X    for (i = 0; i <= end - start; ++i)
X    {
X	printf ("%d,", addr[i]);
X	integer = addr[i];
X	write (fd, (char *) &integer, sizeof (int));
X	length[1] += sizeof (int);
X    }
X    close (fd);
X
X    sprintf (string, "%swidthl", name);
X    fd = creat (string, 0777);
X
X    printf ("\n};\n\n\nshort %swidthl[] =\n{\n", name);
X    for (i = 0; i <= end - start; ++i)
X    {
X	printf ("%d,", lwidth[i]);
X	sshort = lwidth[i];
X	write (fd, (char *) &sshort, sizeof (short));
X	length[2] += sizeof (short);
X    }
X    close (fd);
X
X    sprintf (string, "%swidthr", name);
X    fd = creat (string, 0777);
X
X    printf ("\n};\n\n\nshort %swidthr[] =\n{\n", name);
X    for (i = 0; i <= end - start; ++i)
X    {
X	printf ("%d,", rwidth[i]);
X	sshort = rwidth[i];
X	write (fd, (char *) &sshort, sizeof (short));
X	length[3] += sizeof (short);
X    }
X    close (fd);
X
X    sprintf (string, "%ssymbol", name);
X    fd = creat (string, 0777);
X
X    printf ("\n};\n\n\nshort %ssymbol[] =\n{\n", name);
X    for (i = 0; i <= end - start; ++i)
X    {
X	printf ("%d,", symb[i]);
X	sshort = symb[i];
X	write (fd, (char *) &sshort, sizeof (short));
X	length[4] += sizeof (short);
X    }
X    close (fd);
X
X    printf ("\n};\n\n\n");
X
X    printf ("short %sdim[] = {%d, %d, %d, %d, %d, %d, %d, %d, %d, %d};\n",
X       name, bottom, base, half, cap, top, letter, line, space, start, end);
X    sprintf (string, "%sdim", name);
X    fd = creat (string, 0777);
X    sshort = bottom;
X    write (fd, (char *) &sshort, sizeof (short));
X    sshort = base;
X    write (fd, (char *) &sshort, sizeof (short));
X    sshort = half;
X    write (fd, (char *) &sshort, sizeof (short));
X    sshort = cap;
X    write (fd, (char *) &sshort, sizeof (short));
X    sshort = top;
X    write (fd, (char *) &sshort, sizeof (short));
X    sshort = letter;
X    write (fd, (char *) &sshort, sizeof (short));
X    sshort = line;
X    write (fd, (char *) &sshort, sizeof (short));
X    sshort = space;
X    write (fd, (char *) &sshort, sizeof (short));
X    sshort = start;
X    write (fd, (char *) &sshort, sizeof (short));
X    sshort = end;
X    write (fd, (char *) &sshort, sizeof (short));
X    length[0] += 10 * sizeof (short);
X    close (fd);
X
X/*
X * Length is an array which says how long each piece is;
X * Length2 says at what offset each begins.
X * Lengtht gives the total length of the whole file (not including the
X * table of contents itself, which goes at the beginning and is of
X * fixed length).
X */
X
X    lengtht = length[0];
X    for (i = 1; i < 7; i++)
X    {
X	length2[i] = length2[i - 1] + length[i - 1];
X	lengtht += length[i];
X    }
X
X    sprintf (string, "%sheader", name);
X    fd = creat (string, 0777);
X    write (fd, (char *) &lengtht, sizeof (int));
X    write (fd, (char *) length2, 7 * sizeof (int));
X    close (fd);
X}
END_OF_FILE
if test 13926 -ne `wc -c <'Vplot_Kernel/filters/include/vplotfonts/makefont.c'`; then
    echo shar: \"'Vplot_Kernel/filters/include/vplotfonts/makefont.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/include/vplotfonts/makefont.c'
fi
if test -f 'Vplot_Kernel/filters/loclib/getpar_scan.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/loclib/getpar_scan.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/loclib/getpar_scan.c'\" \(14981 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/loclib/getpar_scan.c' <<'END_OF_FILE'
X# include "stdio.h"
X# define U(x) x
X# define NLSTATE yyprevious=YYNEWLINE
X# define BEGIN yybgin = yysvec + 1 +
X# define INITIAL 0
X# define YYLERR yysvec
X# define YYSTATE (yyestate-yysvec-1)
X# define YYOPTIM 1
X# define YYLMAX 200
X# define output(c) putc(c,yyout)
X# define input() (((yytchar=yysptr>yysbuf?U(*--yysptr):getc(yyin))==10?(yylineno++,yytchar):yytchar)==EOF?0:yytchar)
X# define unput(c) {yytchar= (c);if(yytchar=='\n')yylineno--;*yysptr++=yytchar;}
X# define yymore() (yymorfg=1)
X# define ECHO fprintf(yyout, "%s",yytext)
X# define REJECT { nstr = yyreject(); goto yyfussy;}
int yyleng; extern char yytext[];
int yymorfg;
extern char *yysptr, yysbuf[];
int yytchar;
FILE *yyin ={stdin}, *yyout ={stdout};
extern int yylineno;
struct yysvf { 
X	struct yywork *yystoff;
X	struct yysvf *yyother;
X	int *yystops;};
struct yysvf *yyestate;
extern struct yysvf yysvec[], *yybgin;
X/* lexical scanning for fast getpar */
X/* Revised 3-8-86 stew  Added time stamp to enable older method of handling
X *			multiple tags.  Moved par= intiialization to
X *			separate routine to avoid code duplication.
X */
X#include <ctype.h>
X#include "fastpar.h"
X#undef input
X#define input() ((int) *(input_stack[input_depth]++))
X#undef unput
X/* The redundant  =(c) insures side effects of expressions occur */
X#define unput(c) (*(--(input_stack[input_depth]))=(c))
X#define yywrap() getpar_pop_input()
X#define yylex() getpar_lexscan()
X#define yylook() getpar_yylook()
X
X#define MAX_INPUT_DEPTH 10
static int input_depth = -1;
static char *input_stack[MAX_INPUT_DEPTH];
static char *dealloc_stack[MAX_INPUT_DEPTH];
X
static struct {
X	char *tag;  int tlen;
X	char *val;  int vlen;
X       } yy;
X
X
static int  SMALLBLOCK = 4096;
static char
X*suballoc (size)
int size;
X{
X	static char *myblock = (char *) NULL; static int bytesleft = 0;
X	char *ptr; extern char *alloc();
X
X	if(size > SMALLBLOCK) return(alloc(size));
X	else
X	  { 
X	    if(bytesleft < size)
X	       {
X	        myblock = alloc (SMALLBLOCK);
X		bytesleft = SMALLBLOCK - size;
X	       }
X	   else
X	       {
X		bytesleft -= size;
X	       }
X	   ptr = myblock;
X	   myblock += size;
X	   return(ptr);
X	  }
X}
X
static int  prime[10] = {31,29,23,19,17,13,11,7,5,3};
int getpar_hash(array,len)
register char *array;
register int len;
X{
X  register int hash;
X  register int i;
X  if(len >10) len=10;
X  hash=0;
X  for(i=0; i<len; i++)
X    hash += array[i]*prime[i];
X  return(hash);
X}
X
X/* workhorse to decode par files; shell already parses command line */
getpar_scan(queue,qlen)
register hash_item **queue;
register int qlen;
X{
X extern int yylex();
X
X while(yylex()) {
X	getpar_hash_store(queue,qlen,yy.tag,yy.val,yy.tlen,yy.vlen);
X	if(yy.tlen == 3 && 0 == bcmp(yy.tag,"par",3))
X		getpar_stack_par(yy.val);
X	}
X}
X
X/* read parfile into core and put buffer on scan input stack */
getpar_stack_par(val)
char *val;
X{
X register char *buffer;
X register int fd, len;
X extern int file(), fsize();
X extern char *alloc();
X
X    fd = file(val,0);
X    len = fsize(fd);
X    buffer=alloc(len+3);
X    buffer[0]='\n';
X    read(fd,buffer+1,len);
X    buffer[len+1]='\n';
X    buffer[len+2]='\0';
X    getpar_push_input(buffer,1);
X    close(fd);
X}
X
X /* return 1 if match; 0 otherwise */
X#define getpar_hash_compare(next1,tag1,tlen1)  \
X ((next1)->tlen == (tlen1) && 0 == bcmp((next1)->tag,tag1,tlen1))
X
getpar_hash_store(q,qlen,tag,val,tlen,vlen)
hash_item **q;
register char *tag, *val;
register int tlen;
int qlen, vlen;
X{
X register hash_item *hold, *next;
X static int storetime = 0;
X
X hold=(hash_item *) (q+getpar_hash(tag,tlen)%qlen);
X next=hold->next;
X
X while(next != ((hash_item *) NULL)) {
X	if(getpar_hash_compare(next,tag,tlen) ) {
X		next->val = val; next->vlen = vlen;
X		next->timestamp = storetime++; return;
X		}
X	hold = next; next = next->next;
X	}
X
X hold->next = next = (hash_item *) suballoc(sizeof(hash_item));
X next->next = (hash_item *) NULL;
X next->tlen = tlen;
X next->tag = tag;
X next->vlen = vlen;
X next->val = val;
X next->timestamp = storetime++;
X}
X
hash_item *getpar_hash_lookup(q,qlen,tag,tlen)
register hash_item **q;
register char *tag;
register int tlen;
register int qlen;
X{
X register hash_item *next;
X
X next = *(q + getpar_hash(tag,tlen)%qlen);
X
X while(next != ((hash_item *) NULL) ) {
X	if(getpar_hash_compare(next,tag,tlen)) break;
X	next = next->next;
X	}
X return(next);
X}
X
X# define FOUNDTAG 2
X# define YYNEWLINE 10
yylex(){
int nstr; extern int yyprevious;
while((nstr = yylook()) >= 0)
yyfussy: switch(nstr){
case 0:
if(yywrap()) return(0); break;
case 1:
X	{
X			 yy.vlen = yyleng-2; yy.val=suballoc(yy.vlen+1);
X			 yy.vlen = massage(yytext+1,yy.val,yy.vlen,yytext[0]);
X			 yy.val[yy.vlen]='\0'; BEGIN 0; return(FOUNDTAG);
X			 }
break;
case 2:
X	{
X			 yy.vlen = yyleng-2; yy.val=suballoc(yy.vlen+1);
X			 yy.vlen = massage(yytext+1,yy.val,yy.vlen,yytext[0]);
X			 yy.val[yy.vlen]='\0'; BEGIN 0; return(FOUNDTAG);
X			 }
break;
case 3:
X{
X				 yy.vlen=yyleng; yy.val=suballoc(yy.vlen+1);
X		 		 bcopy(yytext,yy.val,yy.vlen+1); BEGIN 0;
X				 return(FOUNDTAG);
X				 }
break;
case 4:
X{
X			 yy.tlen=yyleng-1; yy.tag=suballoc(yy.tlen+1);
X			 bcopy(yytext,yy.tag,yy.tlen);
X			 yy.tag[yy.tlen]='\0'; BEGIN FOUNDTAG;
X			 }
break;
case 5:
X{
X			 yy.tlen=yyleng-2; yy.tag=suballoc(yy.tlen+1);
X			 bcopy(yytext+1,yy.tag,yy.tlen);
X			 yy.tag[yy.tlen]='\0'; BEGIN FOUNDTAG;
X			 }
break;
case 6:
X/* skip comment lines */;
break;
case 7:
case 8:
X;
break;
case -1:
break;
default:
fprintf(yyout,"bad switch yylook %d",nstr);
X} return(0); }
X/* end of yylex */
X	getpar_push_input(buffer,dealloc)
X	register char *buffer;
X	register int dealloc;
X	{
X	  if(input_depth++ == MAX_INPUT_DEPTH)
X		err("too many nested par files\n");
X	  input_stack[input_depth] = buffer;
X	  if(dealloc) dealloc_stack[input_depth] = buffer;
X	  else dealloc_stack[input_depth] = (char *) NULL;
X	}
X
X	int
X	yywrap()
X	{
X	  if(((char *) NULL) != dealloc_stack[input_depth]) {
X		free(dealloc_stack[input_depth]);
X		dealloc_stack[input_depth] = (char *) NULL;
X		}
X	  input_stack[input_depth--] = (char *) NULL;
X	  if(input_depth < 0) return(1);
X	  return(0);
X	}
X
X	static int
X	massage(string,out,len,quote)
X	register char *string, *out;
X	register int len, quote;
X	{
X 	register int i,j;
X	
X	for(i=0,j=0; i<len-1; j++) {
X		out[j]=string[i++];
X		if(out[j]==quote) /* compress doubled quotes */
X			if(string[i]==quote) i++;
X		}
X	if(i<len) out[j++] = string[i];
X	return(j);
X	}
int yyvstop[] ={
X0,
X
X7,
X0,
X
X7,
X0,
X
X8,
X0,
X
X6,
X7,
X0,
X
X7,
X0,
X
X3,
X7,
X0,
X
X3,
X7,
X0,
X
X3,
X8,
X0,
X
X7,
X0,
X
X7,
X0,
X
X3,
X6,
X7,
X0,
X
X3,
X7,
X0,
X
X6,
X0,
X
X-4,
X0,
X
X3,
X0,
X
X3,
X0,
X
X2,
X0,
X
X2,
X0,
X
X1,
X0,
X
X1,
X0,
X
X3,
X6,
X0,
X
X3,
X0,
X
X3,
X-4,
X0,
X
X-5,
X0,
X
X4,
X0,
X
X3,
X-5,
X0,
X
X3,
X4,
X0,
X
X5,
X0,
X
X3,
X5,
X0,
X0};
X# define YYTYPE char
struct yywork { YYTYPE verify, advance; } yycrank[] ={
X0,0,	0,0,	1,5,	0,0,	
X0,0,	3,10,	0,0,	0,0,	
X0,0,	0,0,	1,6,	1,7,	
X0,0,	3,11,	3,12,	18,0,	
X12,0,	12,0,	0,0,	21,0,	
X21,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	35,0,	
X35,0,	0,0,	37,0,	37,0,	
X0,0,	0,0,	0,0,	1,5,	
X0,0,	2,8,	3,13,	12,0,	
X1,5,	4,15,	21,0,	3,14,	
X25,23,	28,26,	1,5,	11,0,	
X11,0,	3,10,	35,0,	0,0,	
X17,17,	37,0,	0,0,	17,17,	
X17,17,	17,17,	17,17,	17,17,	
X17,17,	17,17,	17,17,	17,17,	
X17,17,	0,0,	1,5,	2,9,	
X17,32,	3,10,	11,0,	4,16,	
X6,17,	6,17,	6,17,	6,17,	
X6,17,	6,17,	6,17,	6,17,	
X6,17,	6,17,	6,17,	6,17,	
X6,17,	6,17,	6,17,	6,17,	
X6,17,	6,17,	6,17,	6,17,	
X6,17,	6,17,	6,17,	6,17,	
X6,17,	6,17,	0,0,	0,0,	
X0,0,	0,0,	17,17,	11,22,	
X6,17,	6,17,	6,17,	6,17,	
X6,17,	6,17,	6,17,	6,17,	
X6,17,	6,17,	6,17,	6,17,	
X6,17,	6,17,	6,17,	6,17,	
X6,17,	6,17,	6,17,	6,17,	
X6,17,	6,17,	6,17,	6,17,	
X6,17,	6,17,	8,18,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X16,0,	16,0,	8,18,	8,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	16,0,	
X0,0,	0,0,	0,0,	8,18,	
X0,0,	0,0,	0,0,	0,0,	
X8,18,	0,0,	0,0,	0,0,	
X16,30,	0,0,	8,18,	9,19,	
X0,0,	0,0,	9,19,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X16,31,	0,0,	0,0,	9,20,	
X16,30,	0,0,	8,18,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	0,0,	0,0,	0,0,	
X0,0,	9,19,	0,0,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	9,19,	9,19,	9,19,	
X9,19,	10,21,	0,0,	13,23,	
X0,0,	14,26,	22,0,	22,0,	
X0,0,	10,0,	10,0,	13,23,	
X13,24,	14,26,	14,27,	15,29,	
X0,0,	0,0,	0,0,	20,33,	
X0,0,	0,0,	29,29,	0,0,	
X15,0,	0,0,	0,0,	20,0,	
X20,0,	22,0,	0,0,	29,0,	
X10,0,	0,0,	10,21,	0,0,	
X13,25,	0,0,	14,26,	10,21,	
X0,0,	13,23,	22,22,	14,28,	
X0,0,	10,21,	0,0,	13,23,	
X15,29,	14,26,	20,0,	0,0,	
X20,33,	15,29,	0,0,	29,29,	
X0,0,	20,33,	22,34,	15,29,	
X29,29,	0,0,	22,22,	20,33,	
X31,35,	10,21,	29,29,	13,23,	
X0,0,	14,26,	30,0,	30,0,	
X31,0,	31,0,	0,0,	0,0,	
X32,36,	0,0,	0,0,	15,29,	
X34,37,	0,0,	0,0,	20,33,	
X32,0,	32,0,	29,29,	0,0,	
X34,0,	34,0,	0,0,	0,0,	
X0,0,	30,0,	0,0,	31,0,	
X0,0,	31,35,	0,0,	0,0,	
X0,0,	0,0,	31,35,	0,0,	
X0,0,	0,0,	30,30,	32,0,	
X31,35,	32,36,	0,0,	34,0,	
X0,0,	34,37,	32,36,	0,0,	
X0,0,	0,0,	34,37,	0,0,	
X32,36,	0,0,	30,31,	0,0,	
X34,37,	0,0,	30,30,	0,0,	
X31,35,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X32,36,	0,0,	0,0,	0,0,	
X34,37,	0,0,	0,0,	0,0,	
X0,0};
struct yysvf yysvec[] ={
X0,	0,	0,
yycrank+-1,	0,		0,	
yycrank+-2,	yysvec+1,	0,	
yycrank+-4,	0,		0,	
yycrank+-6,	yysvec+3,	0,	
yycrank+0,	0,		yyvstop+1,
yycrank+7,	0,		yyvstop+3,
yycrank+0,	0,		yyvstop+5,
yycrank+-129,	0,		yyvstop+7,
yycrank+130,	0,		yyvstop+10,
yycrank+-252,	0,		yyvstop+12,
yycrank+-38,	yysvec+10,	yyvstop+15,
yycrank+-7,	yysvec+10,	yyvstop+18,
yycrank+-254,	0,		yyvstop+21,
yycrank+-256,	0,		yyvstop+23,
yycrank+-266,	yysvec+8,	yyvstop+25,
yycrank+-127,	yysvec+10,	yyvstop+29,
yycrank+7,	yysvec+6,	0,	
yycrank+-5,	yysvec+8,	yyvstop+32,
yycrank+0,	yysvec+9,	0,	
yycrank+-270,	0,		yyvstop+34,
yycrank+-10,	yysvec+10,	yyvstop+36,
yycrank+-249,	yysvec+10,	yyvstop+38,
yycrank+0,	yysvec+13,	0,	
yycrank+0,	0,		yyvstop+40,
yycrank+10,	0,		yyvstop+42,
yycrank+0,	yysvec+14,	0,	
yycrank+0,	0,		yyvstop+44,
yycrank+6,	0,		yyvstop+46,
yycrank+-273,	yysvec+8,	yyvstop+48,
yycrank+-313,	yysvec+10,	yyvstop+51,
yycrank+-315,	0,		yyvstop+53,
yycrank+-327,	0,		yyvstop+56,
yycrank+0,	0,		yyvstop+58,
yycrank+-331,	0,		yyvstop+60,
yycrank+-18,	yysvec+10,	yyvstop+63,
yycrank+0,	0,		yyvstop+66,
yycrank+-21,	yysvec+10,	yyvstop+68,
X0,	0,	0};
struct yywork *yytop = yycrank+396;
struct yysvf *yybgin = yysvec+1;
char yymatch[] ={
X00  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,011 ,012 ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X011 ,01  ,'"' ,01  ,01  ,01  ,01  ,047 ,
X01  ,01  ,01  ,01  ,01  ,'-' ,01  ,01  ,
X'-' ,'-' ,'-' ,'-' ,'-' ,'-' ,'-' ,'-' ,
X'-' ,'-' ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,
X'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,
X'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,
X'A' ,'A' ,'A' ,01  ,01  ,01  ,01  ,'-' ,
X01  ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,
X'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,
X'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,
X'A' ,'A' ,'A' ,01  ,01  ,01  ,01  ,01  ,
X0};
char yyextra[] ={
X0,0,0,0,1,1,0,0,
X0,0,0,0,0,0,0,0,
X0};
X/*	ncform	4.1	83/08/11	*/
X
int yylineno =1;
X# define YYU(x) x
X# define NLSTATE yyprevious=YYNEWLINE
char yytext[YYLMAX];
struct yysvf *yylstate [YYLMAX], **yylsp, **yyolsp;
char yysbuf[YYLMAX];
char *yysptr = yysbuf;
int *yyfnd;
extern struct yysvf *yyestate;
int yyprevious = YYNEWLINE;
yylook(){
X	register struct yysvf *yystate, **lsp;
X	register struct yywork *yyt;
X	struct yysvf *yyz;
X	int yych;
X	struct yywork *yyr;
X# ifdef LEXDEBUG
X	int debug;
X# endif
X	char *yylastch;
X	/* start off machines */
X# ifdef LEXDEBUG
X	debug = 0;
X# endif
X	if (!yymorfg)
X		yylastch = yytext;
X	else {
X		yymorfg=0;
X		yylastch = yytext+yyleng;
X		}
X	for(;;){
X		lsp = yylstate;
X		yyestate = yystate = yybgin;
X		if (yyprevious==YYNEWLINE) yystate++;
X		for (;;){
X# ifdef LEXDEBUG
X			if(debug)fprintf(yyout,"state %d\n",yystate-yysvec-1);
X# endif
X			yyt = yystate->yystoff;
X			if(yyt == yycrank){		/* may not be any transitions */
X				yyz = yystate->yyother;
X				if(yyz == 0)break;
X				if(yyz->yystoff == yycrank)break;
X				}
X			*yylastch++ = yych = input();
X		tryagain:
X# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"char ");
X				allprint(yych);
X				putchar('\n');
X				}
X# endif
X			yyr = yyt;
X			if ( (int)yyt > (int)yycrank){
X				yyt = yyr + yych;
X				if (yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				}
X# ifdef YYOPTIM
X			else if((int)yyt < (int)yycrank) {		/* r < yycrank */
X				yyt = yyr = yycrank+(yycrank-yyt);
X# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"compressed state\n");
X# endif
X				yyt = yyt + yych;
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				yyt = yyr + YYU(yymatch[yych]);
X# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"try fall back character ");
X					allprint(YYU(yymatch[yych]));
X					putchar('\n');
X					}
X# endif
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transition */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				}
X			if ((yystate = yystate->yyother) && (yyt= yystate->yystoff) != yycrank){
X# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"fall back to state %d\n",yystate-yysvec-1);
X# endif
X				goto tryagain;
X				}
X# endif
X			else
X				{unput(*--yylastch);break;}
X		contin:
X# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"state %d char ",yystate-yysvec-1);
X				allprint(yych);
X				putchar('\n');
X				}
X# endif
X			;
X			}
X# ifdef LEXDEBUG
X		if(debug){
X			fprintf(yyout,"stopped at %d with ",*(lsp-1)-yysvec-1);
X			allprint(yych);
X			putchar('\n');
X			}
X# endif
X		while (lsp-- > yylstate){
X			*yylastch-- = 0;
X			if (*lsp != 0 && (yyfnd= (*lsp)->yystops) && *yyfnd > 0){
X				yyolsp = lsp;
X				if(yyextra[*yyfnd]){		/* must backup */
X					while(yyback((*lsp)->yystops,-*yyfnd) != 1 && lsp > yylstate){
X						lsp--;
X						unput(*yylastch--);
X						}
X					}
X				yyprevious = YYU(*yylastch);
X				yylsp = lsp;
X				yyleng = yylastch-yytext+1;
X				yytext[yyleng] = 0;
X# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"\nmatch ");
X					sprint(yytext);
X					fprintf(yyout," action %d\n",*yyfnd);
X					}
X# endif
X				return(*yyfnd++);
X				}
X			unput(*yylastch);
X			}
X		if (yytext[0] == 0  /* && feof(yyin) */)
X			{
X			yysptr=yysbuf;
X			return(0);
X			}
X		yyprevious = yytext[0] = input();
X		if (yyprevious>0)
X			output(yyprevious);
X		yylastch=yytext;
X# ifdef LEXDEBUG
X		if(debug)putchar('\n');
X# endif
X		}
X	}
yyback(p, m)
X	int *p;
X{
if (p==0) return(0);
while (*p)
X	{
X	if (*p++ == m)
X		return(1);
X	}
return(0);
X}
X	/* the following are only used in the lex library */
yyinput(){
X	return(input());
X	}
yyoutput(c)
X  int c; {
X	output(c);
X	}
yyunput(c)
X   int c; {
X	unput(c);
X	}
END_OF_FILE
if test 14981 -ne `wc -c <'Vplot_Kernel/filters/loclib/getpar_scan.c'`; then
    echo shar: \"'Vplot_Kernel/filters/loclib/getpar_scan.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/loclib/getpar_scan.c'
fi
if test -f 'Vplot_Kernel/filters/main_vplot.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/main_vplot.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/main_vplot.c'\" \(12441 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/main_vplot.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/main_vplot.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X/*
X * generic pen -  VPLOT filter for whatever
X * Keyword: graphics vplot pen
X */
X
X/*
X *  Edit History
X *
X *  "Pen" written 1979 for a PDP-11, Rob Clayton
X *  Eventually modified into "tekpen" by Glenn Kroeger early 1984
X *  Made device independent and extensively modified into "screenpen"
X *  by Joe Dellinger 1984 through 1985
X *  Reworked to be more GKS-like by Glenn and Michel Debiche, 1985
X *  Cleaned up, Joe 1986
X *  Added 'wstype' variable so one program can support multiple
X *		terminal types		-- Chuck Karish, Nov 1986
X *  Raster capability added -- Joe and Steve Cole 1987
X *  Cleaned up and documented for public release, Joe Dellinger 1987
X *  Whew!
X *
X *  Changed system("stty ...") calls to ioctls.  The system() calls
X *  are hanging for jon under 6.0.  Added sigblock() to cleanup
X *  error handler to avoid exit() problems.  Also shut down output
X *  translations to tty graphics terminals.  Stewart A. Levin  6-23-87
X *
X *  Shut down output translations with LLITOUT now that I've gotten
X *  the magic incantation that makes it stick on buggy BSD systems.
X *  Stewart A. Levin  7-5-87
X *
X *  Made "scale" a global so dovplot could use it.
X *  Joe Dellinger Oct 18 1987
X *
X *  Gather up all the incoming plot files, and then have "genreader"
X *  process them all. This allows someone to make a vplot-editor that
X *  can re-order plot files, repeat them, etc, etc. Added "buffer_input"
X *  and "allow_pipe" as part of this.
X *  Joe Dellinger Dec 16 1987
X *
X *  Added "hclose_done" to SEPlib version.
X *  Joe Dellinger Dec 19 1987
X *
X *  Added "reset_parameters" to frontend and dovplot
X *  Joe Dellinger Jan 8 1988
X *
X *  Added group_name, group_number, pltname
X *  Joe Dellinger Jan 20 1988
X *
X *  Inverted window should mean that everything gets clipped.
X *  Make it possible to override standard defaults for SEP.
X *  Joe Dellinger Feb 12 1988
X *
X *  Just use getpar, not getpar_.
X *  Joe Dellinger Feb 16 1988
X *
X *  Split "frontend.c" into 3 files,
X *  main_vplot, init_vplot, and proc_vplot.
X *  This so that other programs can use vplot and still keep their own
X *  mains.
X *  Joe Dellinger Feb 18 1988
X */
X
X#ifdef SEP
extern void     sepwhere ();
extern char     sepoutwhere[];
extern char     sepheadwhere[];
X
X#define		OUT	sepoutwhere
X#define		HEAD	sepheadwhere
X#define		SOURCE  "\014Joe Dellinger, Stanford Exploration Project\014"
X#include	<sep.main>
X#define		GETPAR	fetch
X
X#else SEP
X#include	<stdio.h>
X#include	<math.h>
X#define		GETPAR	getpar
X#endif SEP
X
X
X#include	<sys/ioctl.h>
X#include	<sys/types.h>
X#include	<sys/stat.h>
X#include	<sgtty.h>
X#include	<ctype.h>
X#include	<strings.h>
X#include	<signal.h>
X
X#include	<vplot.h>
X
X#include	"./include/params.h"	/* for machine dependencies */
X#include	"./include/enum.h"
X#include	"./include/err.h"
X#include	"./include/attrcom.h"
X#include	"./include/intcom.h"
X#include	"./include/mesgcom.h"
X#include	"./include/erasecom.h"
X#include	"./include/closestat.h"
X#include	"./include/pat.h"
X#include	"./include/vertex.h"
X#include	"./include/round.h"
X#include	"./include/extern.h"
X
X
X/*
X * signal catching
X */
int             cleanup ();
int             sigvec ();
int             signum[] =
X{
X SIGHUP, SIGINT, SIGQUIT, SIGIOT, SIGEMT, SIGPIPE, SIGTERM, SIGXCPU, SIGXFSZ
X};
X#define NOSIG (sizeof (signum)/sizeof (int))	/* number of signals caught */
struct sigvec   errhandler =
X{
X cleanup, 0, 0
X};
struct sigvec   ignored =
X{
X SIG_IGN, 0, 0
X};
struct sigvec   oldvec;
X
extern struct sgttyb tty_clean_state;	/* external for utilities */
extern int      tty_clean_local_mode;
extern int      allow_pipe;
extern char     callname[];
extern int      nplots;
extern int      allowecho;
X
X/*
X * file and terminal control variables
X */
extern int      genmessage ();
extern int      (*message) ();
extern FILE    *pltout;
X
FILE           *fopen ();
FILE           *fdopen ();
X
extern FILE    *pltinarray[MAXIN];
extern char     pltinname[MAXIN][MAXFLEN + 1];
extern int      infileno;
extern int      pltoutfd;
X
X/*
X * This routine is responsible for finding the input files,
X * setting up the input and output, and calling init_vplot
X * and proc_vplot. You can link to vplot without using this
X * routine, and so have your own main. See vplothacker.doc to
X * learn how to do this. (Especially you, Jon!)
X */
X
X#ifdef SEP
int             xxargc;
char          **xxargv;
char            scrap[MAXFLEN + 1];
int             hclose_done = NO;
int             fake_header = NO;
MAIN ()
X
X#else SEP
int             xargc;
char          **xargv;	/* for getpar */
main (argc, argv)
X    int             argc;
X    char           *argv[];
X#endif SEP
X{
X#ifndef SEP
int             in_isatty, num_vplot, docflag;
char            instring[MAXFLEN + 1];
X#endif SEP
X
char           *cptr;
char           *stringptr;
int             ii;
FILE           *temp;
char            string[MAXFLEN + 1];
X
X
X    nulldev ();			/* Just to make sure it gets loaded */
X
X#ifndef SEP
X    if (stringptr = rindex (argv[0], '/'))
X	strncpy (callname, ++stringptr, 24);
X    else
X	strncpy (callname, argv[0], 24);
X#else SEP
X    if (stringptr = rindex (xargv[0], '/'))
X	strncpy (callname, ++stringptr, 24);
X    else
X	strncpy (callname, xargv[0], 24);
X#endif SEP
X
X#ifdef SEP
X    pltout = outstream;
X    if (redout ())
X    {
X	getch ("head", "s", scrap);
X	if (strcmp (scrap, "/dev/null") == 0 &&
X	    strcmp (sepheadwhere, "/dev/null") == 0)
X	{
X	    fake_header = YES;
X	    getch ("out", "s", scrap);
X	    if (strcmp (scrap, "stdout") != 0)
X	    {
X		/*
X		 * They probably want the header output into the redirected
X		 * output. (SEP only) 
X		 */
X		headstream = stdout;
X		headfd = fileno (headstream);
X		Puthead ("Fake header for special device-dependent data only.\n");
X		Puthead ("To get input history passed along, over-ride default with head = stdout\n");
X		/*
X		 * If the output is going into a file, then put this
X		 * information into the header file. 
X		 */
X		if (strcmp (scrap, "/dev/tty") != 0)
X		{
X		    fullnm (scrap, MAXFLEN + 1);
X		    Puthead ("\tin=%s\n", scrap);
X		}
X		else
X		{
X		    Puthead ("\tin= nowhere\n");
X		    Puthead ("\t(Sorry, the data went to the terminal; it's gone now!)\n");
X		}
X
X		/*
X		 * Have to use my own puthead routine. Standard ones such as
X		 * putch, etc, don't work with this. They remember where the
X		 * header used to be. Puthead does this, checking for
X		 * headstream not null. This is so this will work without
X		 * sep, as well. 
X		 */
X	    }
X	}
X    }
X
X    if (!fake_header)
X    {
X	Puthead ("\tn3 = unknown\n\t(Sorry, SEPlib requires the header be closed now)\n");
X	hclose ();
X	hclose_done = YES;
X    }
X#else SEP
X
X    /*
X     * If no arguments, and not in a pipeline, self document "wstype="
X     * doesn't count as an argument for our purposes 
X     */
X    in_isatty = isatty ((int) (fileno (stdin)));
X    xargc = argc;
X    xargv = argv;
X    docflag = 0;
X    if (argc == 1)
X	docflag = 1;
X    if ((argc == 2) && !strncmp ("wstype=", argv[1], 7))
X	docflag = 1;
X    getpar ("selfdoc", "1", &docflag);
X    if (in_isatty && docflag)
X    {
X	for (ii = 0; ii < doclength; ii++)
X	    printf ("%s\n", documentation[ii]);
X	exit (0);
X    }
X
X    pltout = stdout;
X#endif SEP
X
X    /*
X     * This getpar for signal is only included for debugging purposes. By
X     * using a signal option, one can stop any signals from being caught. 
X     */
X    if (getpar ("signal", "s", string) == 0)
X    {
X	for (ii = 0; ii < NOSIG; ++ii)
X	{
X	    if (-1 == sigvec (signum[ii], &ignored, &oldvec))
X	    {
X		ERR (FATAL, name, "Bad sigvec call!");
X	    }
X	    if (oldvec.sv_handler == ignored.sv_handler)
X		(void) sigvec (signum[ii], &oldvec, (struct sigvec *) NULL);
X	    else
X		(void) sigvec (signum[ii], &errhandler, (struct sigvec *) NULL);
X	}
X    }
X
X/*
X ****************************************************************************
X * Set all global variables, open the device.
X ****************************************************************************
X */
X    init_vplot ();
X
X/*
X ****************************************************************************
X * Start processing input files
X ****************************************************************************
X */
X
X#ifdef SEP
X    if (instream != NULL)
X    {
X	if (!allow_pipe && isapipe (fileno (instream)))
X	{
X	    ERR (WARN, name, "cannot use pipes with this device");
X	}
X	else
X	{
X	    if (infileno >= MAXIN)
X	    {
X		ERR (FATAL, name, "too many input files (%d max)", MAXIN);
X	    }
X	    strcpy (pltinname[infileno], "Pipe");
X	    pltinarray[infileno] = instream;
X	    infileno++;
X	}
X    }
X    else
X	ERR (WARN, name, "cannot read input pipe");
X
X    xxargc = xargc;
X    xxargv = xargv;
X
X    for (xxargc--, xxargv++; xxargc; xxargc--, xxargv++)
X    {
X	cptr = *xxargv;
X	while (*cptr)
X	{
X	    if (*cptr == '=')
X		break;
X	    cptr++;
X	}
X	if (*cptr)
X	    continue;
X	/* Ignore dummy arguments */
X	if (strcmp (*xxargv, "dummy") == 0)
X	    continue;
X	if ((temp = fopen (*xxargv, "r")) == NULL)
X	{
X	    ERR (WARN, name, "cannot open header file %s", *xxargv);
X	    continue;
X	}
X	fclose (temp);
X	if (getch2 ("in", "s", string, *xxargv))
X	{
X	    if ((temp = fopen (string, "r")) != NULL)
X	    {
X		Puthead ("   +  %s --> in = %s\n", *xxargv, string);
X		if (infileno >= MAXIN)
X		{
X		    ERR (FATAL, name, "too many input files (%d max)", MAXIN);
X		}
X		strcpy (pltinname[infileno], string);
X		pltinarray[infileno] = temp;
X		infileno++;
X	    }
X	    else
X	    {
X		ERR (WARN, name, "cannot open input file %s", string);
X	    }
X	}
X    }
X
X#else SEP
X    /*
X     * first process pipe input 
X     */
X    if (!in_isatty)
X    {
X	if (!allow_pipe)
X	{
X	    ERR (WARN, name, "cannot use pipes with this device");
X	}
X	else
X	{
X	    if (infileno >= MAXIN)
X	    {
X		ERR (FATAL, name, "too many input files (%d max)", MAXIN);
X	    }
X	    strcpy (pltinname[infileno], "stdin");
X	    pltinarray[infileno] = stdin;
X	    infileno++;
X	}
X    }
X
X    /*
X     * next process in= inputfiles If they set num_vplot, also look for in1=
X     * in2= etc 
X     */
X
X    num_vplot = 0;
X    getpar ("numvplot", "d", &num_vplot);
X
X    for (ii = 0; ii <= num_vplot; ii++)
X    {
X	if (ii == 0)
X	    strcpy (instring, "in");
X	else
X	    sprintf (instring, "in%d", ii);
X
X	if (getpar (instring, "s", string))
X	{
X	    if ((temp = fopen (string, "r")) != NULL)
X	    {
X		if (infileno >= MAXIN)
X		{
X		    ERR (FATAL, name, "too many input files (%d max)", MAXIN);
X		}
X		strcpy (pltinname[infileno], string);
X		pltinarray[infileno] = temp;
X		infileno++;
X	    }
X	    else
X	    {
X		ERR (WARN, name, "cannot open %s", string);
X	    }
X	}
X    }
X
X    /*
X     * finally process input line for non-getpar arguments and assume they
X     * are also input files 
X     */
X    for (argc--, argv++; argc; argc--, argv++)
X    {
X	cptr = *argv;
X	while (*cptr)
X	{
X	    if (*cptr == '=')
X		break;
X	    cptr++;
X	}
X	if (*cptr)
X	    continue;
X	cptr = *argv;
X	if ((temp = fopen (cptr, "r")) != NULL)
X	{
X	    if (infileno >= MAXIN)
X	    {
X		ERR (FATAL, name, "too many input files (%d max)", MAXIN);
X	    }
X	    strcpy (pltinname[infileno], cptr);
X	    pltinarray[infileno] = temp;
X	    infileno++;
X	}
X	else
X	{
X	    ERR (WARN, name, "cannot open %s", cptr);
X	}
X    }
X#endif SEP
X
X/*
X ****************************************************************************
X * Go do the plots
X ****************************************************************************
X */
X    proc_vplot ();
X
X#ifdef SEP
X    if (!hclose_done)
X    {
X	Puthead ("\tn3=%d\n", nplots);
X	hclose ();
X	hclose_done = YES;
X    }
X#endif SEP
X
X    exit (0);
X}
X
cleanup ()
X{
X    sigblock (~(SIGKILL | SIGSTOP | SIGCONT));
X    dev.close (CLOSE_INTERRUPT);
X    message (MESG_ON);
X    ERR (COMMENT, name, "Interrupted out.");
X    dev.close (CLOSE_DONE);
X    /*
X     * Let them see what they are doing again 
X     */
X    if (!allowecho)
X    {
X	ioctl (pltoutfd, TIOCLSET, (char *) (&tty_clean_local_mode));
X	ioctl (pltoutfd, TIOCSETN, (char *) (&tty_clean_state));
X    }
X    exit (0);
X}
END_OF_FILE
if test 12441 -ne `wc -c <'Vplot_Kernel/filters/main_vplot.c'`; then
    echo shar: \"'Vplot_Kernel/filters/main_vplot.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/main_vplot.c'
fi
echo shar: End of archive 16 \(of 24\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
