Subject:  v14i015:  Device-independant graphics system, with drivers
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Joe Dellinger <joe@hanauma.STANFORD.EDU>
Posting-number: Volume 14, Issue 15
Archive-name: vplot/part10

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 24)."
# Wrapped by rsalz@fig.bbn.com on Fri Mar 25 11:47:10 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Envision_device/envilib/envireset.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Envision_device/envilib/envireset.c'\"
else
echo shar: Extracting \"'Envision_device/envilib/envireset.c'\" \(2788 characters\)
sed "s/^X//" >'Envision_device/envilib/envireset.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/envilib/envireset.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include <stdio.h>
X#include "../include/extern.h"
X#include "envi.h"
X
envireset ()
X{
extern FILE    *pltout;
extern int      dev_xmax, dev_ymax, dev_xmin, dev_ymin;
X
X/*
X * physical device size
X */
X    dev_xmax = 639;
X    dev_xmin = 0;
X    dev_ymin = 0;
X    pixels_per_inch = 67.;
X    aspect_ratio = 1.;
X    num_col = 8;
X
X    /*
X     * Reset the terminal. On the Envision, it is a pain To do this without
X     * logging the person out! (Escape C) 
X     */
X    putc (ESC, pltout);
X    fprintf (pltout, "OR1");
X    /* Select decimal mode. Slower, but I'm lazy */
X    /*
X     * Almost all actual drawing is done in tek mode, and that is in binary,
X     * and optimized. So don't get too upset about this inefficiency. 
X     */
X    putc (ESC, pltout);
X    fprintf (pltout, "G0");	/* Turn off Graphics Cursor */
X    putc (ESC, pltout);
X    fprintf (pltout, "T0");	/* Turn off dotted lines */
X    putc (ESC, pltout);
X    fprintf (pltout, "L0");	/* Select Drawing Logic mode 0 */
X    putc (ESC, pltout);
X    fprintf (pltout, "OW%d,%d,%d,%d,", dev_xmin * 4, dev_ymin * 4,
X	     (dev_xmax + 1) * 4, (dev_ymax + 1) * 4);
X    /*
X     * This really sets the window to xmin =0, ymin=0, xmax= xmax, ymax=ymax
X     * . (Note these were set by termfirst) This is chosen so that 1 pixel
X     * equals 1 unit. For some reason, whenever we are in Tektronix emulation
X     * mode, the window is 1/4'd ! So we have to multiply by 4 to start with!
X     * Strange, huh? The "+1" was added to get around an apparent slight
X     * envision bug. (Lost top row of pixels) 
X     */
X    putc (ESC, pltout);
X    fprintf (pltout, "J7");	/* Enable all Color planes */
X    putc (ESC, pltout);
X    fprintf (pltout, "C7");	/* Set drawing color to white */
X    putc (ESC, pltout);
X    fprintf (pltout, "B0");	/* Set background color to black */
X
X    /* Turn all the guns on all the way */
X    fprintf (pltout, "%cQ0000%cQ1?00%cQ20?0%cQ3??0%cQ400?%cQ5?0?%cQ60??%cQ7???"
X	     ,ESC, ESC, ESC, ESC, ESC, ESC, ESC, ESC);
X    fprintf (pltout, "%cRR1", ESC);	/* Turn the graphics plane on */
X    fprintf (pltout, "%cOH0", ESC);	/* Set polygon fill style */
X    envisetpan ();		/* Set Graph and Pan mode, turn off soft keys */
X}
END_OF_FILE
if test 2788 -ne `wc -c <'Envision_device/envilib/envireset.c'`; then
    echo shar: \"'Envision_device/envilib/envireset.c'\" unpacked with wrong size!
fi
# end of 'Envision_device/envilib/envireset.c'
fi
if test -f 'Envision_device/envilib/enviset.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Envision_device/envilib/enviset.c'\"
else
echo shar: Extracting \"'Envision_device/envilib/enviset.c'\" \(2719 characters\)
sed "s/^X//" >'Envision_device/envilib/enviset.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/envilib/enviset.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include	<stdio.h>
X#include	"../include/err.h"
X#include	"../include/extern.h"
X#include    "envi.h"
X
X/*
X *  Please note that this routine is NEVER CALLED by screenpen or any of
X * the device independent routines! They don't even know what a mode is.
X * This routine is only called by device dependent routines in this library.
X * Making one routine responsible for keeping track of the terminal's mode
X * saves a lot of trouble. The envision is a simple case, with only 2 modes
X * it can be in.
X */
X
envisetmode (mode)	/* Get the terminal into the required mode */
X    int             mode;
X{
static int      current_mode = REG;
X    switch (mode)
X    {
X    case MOV:
X	if (current_mode == MOV)
X	    return;
X	else
X	if (current_mode == TEK)
X	    putc (US, pltout);
X	putc (FS, pltout);
X	current_mode = MOV;
X	lost = 1;
X	return;
X
X    case TEK:
X	if (current_mode == TEK)
X	    return;
X	else
X	if (current_mode == MOV)
X	    putc (US, pltout);
X	putc (GS, pltout);
X	current_mode = TEK;
X	lost = 1;
X	break;
X
X    case REG:
X	if (current_mode == REG)
X	    return;
X	/*
X	 * Envision Documentation says you also need an ESC at this point,
X	 * but tek's don't use it, and it seems to work. 
X	 */
X	putc (US, pltout);
X	current_mode = REG;
X	lost = 1;		/* vector is warned */
X	break;
X
X    default:
X	ERR (FATAL, name, "setmode: I've never heard of that mode before!");
X	break;
X    }
X}
X
envipanon ()
X{
X    if (version > 215)
X	fprintf (pltout, "%cRP1", ESC);
X}
X
envipanoff ()
X{
X    if (version > 215)
X	fprintf (pltout, "%cRP0", ESC);
X}
X
envisetpan ()
X{
X    envisoftkeyoff ();
X    fprintf (pltout, "%cRG1", ESC);
X    if (version > 215)
X	fprintf (pltout, "%cRP1", ESC);
X}
X
enviresetpan ()
X{
X    envisoftkeyon ();
X    fprintf (pltout, "%cRG0", ESC);
X    if (version > 215)
X	fprintf (pltout, "%cRP0", ESC);
X}
X
enviresetcolors ()
X{
X    fprintf (pltout, "%cQ ", ESC);
X}
X
envinograph ()
X{
X    fprintf (pltout, "%cRR0", ESC);
X}
X
envicursoron ()
X{
X    fprintf (pltout, "%cG1", ESC);
X}
X
envicursoroff ()
X{
X    fprintf (pltout, "%cG0", ESC);
X}
X
envisoftkeyon ()
X{
X    fprintf (pltout, "%c>", ESC);
X}
X
envisoftkeyoff ()
X{
X    fprintf (pltout, "%c=", ESC);
X}
END_OF_FILE
if test 2719 -ne `wc -c <'Envision_device/envilib/enviset.c'`; then
    echo shar: \"'Envision_device/envilib/enviset.c'\" unpacked with wrong size!
fi
# end of 'Envision_device/envilib/enviset.c'
fi
if test -f 'Imagen_device/imaglib/imagerase.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imagen_device/imaglib/imagerase.c'\"
else
echo shar: Extracting \"'Imagen_device/imaglib/imagerase.c'\" \(2646 characters\)
sed "s/^X//" >'Imagen_device/imaglib/imagerase.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/imaglib/imagerase.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X/*
X * Erase the graphics area (ie issue an ENDPAGE after cleanup)
X */
X#include <stdio.h>
X#include "imagen.h"
X#include "../include/enum.h"
X#include "../include/erasecom.h"
X#include "../include/extern.h"
X
X#define BOX_HEIGHT 60
X#define BOX_Y_POS  75
X#define CHAR_WIDTH  30
X#define INCHES_FROM_LEFT  .7
X
imagerase (command)
X    int             command;
X{
register int    i, ii;
static int      page_count = 1;
char            full_label[100];
int             box_length, box_start;
X
X    switch (command)
X    {
X    case ERASE_MIDDLE:
X    case ERASE_END:
X	endpath (DRAW_PATH, imag_curcolor);
X
X	/*
X	 * Put on label, if desired 
X	 */
X	if (label[0] != '\0')
X	{
X	    if (page_count == 1 && command == ERASE_END)
X	    {
X		sprintf (full_label, "%s", label);
X	    }
X	    else
X	    {
X		sprintf (full_label, "%s : Page %d.", label, page_count);
X	    }
X	    for (i = 0; i < 60 && full_label[i] != '\0'; i++);
X	    box_length = (i + 1) * CHAR_WIDTH;
X	    box_start = dev_xmax - INCHES_FROM_LEFT * 300 - box_length;
X	    dev.plot (box_start, BOX_Y_POS, 0);
X	    dev.plot (box_start, BOX_Y_POS + BOX_HEIGHT, 1);
X	    dev.plot (box_start + box_length, BOX_Y_POS + BOX_HEIGHT, 1);
X	    dev.plot (box_start + box_length, BOX_Y_POS, 1);
X	    endpath (FILL_PATH, WHITE);
X	    fprintf (pltout, "%c%c", SET_ADV_DIRS, '\002');
X	    fprintf (pltout, "%c%c", SET_FAMILY, '\002');
X	    fprintf (pltout, "%c%c%c",
X		     SET_SP, hib (CHAR_WIDTH), lob (CHAR_WIDTH));
X	    fprintf (pltout, "%c", SET_ABS_V);
X	    fprintf (pltout, "%c%c", hib (box_start + CHAR_WIDTH / 2),
X		     lob (box_start + CHAR_WIDTH / 2));
X	    fprintf (pltout, "%c", SET_ABS_H);
X	    fprintf (pltout, "%c%c", hib (BOX_Y_POS + CHAR_WIDTH / 2),
X		     lob (BOX_Y_POS + CHAR_WIDTH / 2));
X	    for (ii = 0; ii < i; ii++)
X	    {
X		if (full_label[ii] != ' ')
X		{
X		    fprintf (pltout, "%c", full_label[ii]);
X		}
X		else
X		{
X		    fprintf (pltout, "%c", SP);
X		}
X	    }
X	}
X	if (!stripped)
X	{
X	    fprintf (pltout, "%c", ENDPAGE);
X	}
X	page_count++;
X	break;
X    case ERASE_START:
X    default:
X	break;
X    }
X}
END_OF_FILE
if test 2646 -ne `wc -c <'Imagen_device/imaglib/imagerase.c'`; then
    echo shar: \"'Imagen_device/imaglib/imagerase.c'\" unpacked with wrong size!
fi
# end of 'Imagen_device/imaglib/imagerase.c'
fi
if test -f 'Imagen_device/imaglib/imagreset.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imagen_device/imaglib/imagreset.c'\"
else
echo shar: Extracting \"'Imagen_device/imaglib/imagreset.c'\" \(2619 characters\)
sed "s/^X//" >'Imagen_device/imaglib/imagreset.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/imaglib/imagreset.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Stewart A. Levin (SEP), July 2, 1987
X *	Support command line ncopies= option
X */
X
X#include <stdio.h>
X#include "../include/enum.h"
X#include "../include/extern.h"
X#include "imagen.h"
X
imagreset ()
X{
X    /*
X     * Make sure that the imagen knows this is in impress language! 
X     */
X    if (stripped == NO)
X    {
X	prepend (pltout);	/* puts in ipr's document control strings */
X	fprintf (pltout, "@document(language ImPRESS, ");
X	if (brute_force)
X	    fprintf (pltout, "prerasterization on, ");
X	if (holdreason[0] != '\0')
X	    fprintf (pltout, "hold \"%s; 'rj' to proceed\", ",
X		     holdreason);
X	fprintf (pltout, "copies %d, ", ncopies_document);
X	fprintf (pltout, "jobheader off)");
X    }
X    if (label[0] != '\0')
X    {
X	fprintf (pltout, "%c%c%c%c%s%c", CREATE_FAMILY_TABLE,
X		 '\002', '\001', '\000', "COUR12", '\0');
X    }
X    if (tex == YES)
X    {
X	fprintf (pltout, "%c%c%c", SET_PUSH_MASK, '\001', '\377');
X	fprintf (pltout, "%c", PUSH);
X	fprintf (pltout, "%c%c", SET_HV_SYSTEM, '\143');
X    }
X}
X
X
X#include <pwd.h>
static
prepend (newfile)
X    FILE           *newfile;
X{
X    /*
X     * Stolen from ipr to set up document control 
X     */
X
char            SYSIDENT[256];
register char  *sp, *dp;
long            spooltime;
struct passwd  *pw, *getpwuid ();
long            time ();/* Date/time-getting support */
char           *ctime ();
char            now[32];
X
X    /* Add a document header to this file */
X    time (&spooltime);
X    sp = ctime (&spooltime);
X    dp = now;
X    while (*sp && *sp != '\n')
X	*dp++ = *sp++;
X    *dp = '\0';
X    fprintf (newfile, "@document(");
X    pw = getpwuid (getuid ());
X    gethostname (SYSIDENT, sizeof (SYSIDENT));
X    if (pw != 0)
X    {
X	fprintf (newfile, "owner \"%s", pw->pw_name);
X	if (pw->pw_gecos != 0 && pw->pw_gecos[0] != '\0')
X	    fprintf (newfile, " (%s)", pw->pw_gecos);
X	fprintf (newfile, "\", site \"%s\"", SYSIDENT);
X    }
X    else
X	fprintf (newfile, "site \"%s\"", SYSIDENT);
X    fprintf (newfile, ", spooldate \"%s\"", now);
X    fprintf (newfile, ")");
X
X}
END_OF_FILE
if test 2619 -ne `wc -c <'Imagen_device/imaglib/imagreset.c'`; then
    echo shar: \"'Imagen_device/imaglib/imagreset.c'\" unpacked with wrong size!
fi
# end of 'Imagen_device/imaglib/imagreset.c'
fi
if test -f 'Masscomp_device/gpslib/gpsopen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Masscomp_device/gpslib/gpsopen.c'\"
else
echo shar: Extracting \"'Masscomp_device/gpslib/gpsopen.c'\" \(2798 characters\)
sed "s/^X//" >'Masscomp_device/gpslib/gpsopen.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/gpslib/gpsopen.c
X *
X * Stew Levin (SEP), July 3 1987
X *	Copied from raslib and modified for gps (Masscomp color, I hope)
X */
X
X#include <stdio.h>
X#include "../include/enum.h"
X#include "../include/extern.h"
X#include "../include/err.h"
X#include "../include/vplot.h"
X#include <strings.h>
X#ifdef SEP
X#include <ctype.h>
X#endif
X#define DEFAULT_OUT	isatty(fileno(pltout))
X#include "gpspen.h"
X
char           *image;
extern float    aspect_ratio;
extern float    pixels_per_inch;
int             color_mult;
X
extern int      num_col;
X
gpsopen ()
X{
extern char   **xargv;
extern FILE    *pltout;
X#ifdef SEP
extern int      headfd;
char            headname[30], fname[80];
char            path[50];
char           *front, *tail, *ptr;
X#endif
char            newpath[60];
char            plpipe[60];
X
X/*
X * physical device parameters
X */
X
X/*
X * device capabilities
X */
X    need_end_erase = YES;
X    buffer_output = YES;
X    smart_clip = NO;
X
X    color_mult = 1;
X    getpar ("colormult", "d", &color_mult);
X    num_col = NCOLOR / color_mult;
X
X    dev_xmin = -6554;		/* from default window 13 */
X    dev_ymin = -6554;
X    dev_xmax = 6553;
X    dev_ymax = 6553;
X    aspect_ratio = 1.;
X    pixels_per_inch = RPERIN;	/* good enough */
X    getpar ("aspect", "f", &aspect_ratio);
X    getpar ("ppi", "d", &pixels_per_inch);
X    allowecho = YES;
X
X    if (DEFAULT_OUT)
X    {
X#ifdef SEP
X	datapath (path);
X/* Code stolen from output.c to get a reasonable raster file name. */
X	if (0 < findnm (headfd, headname, sizeof (headname)))
X	{
X	    /* modify slightly */
X	    strcpy (fname, "");
X	    front = rindex (headname, '/');
X	    if (front == ((char *) NULL))
X		front = headname;
X	    else
X		front++;
X	    if ((*front) == 'H')
X		strcat (fname, ++front);
X	    else
X	    {
X		tail = rindex (front, '.');
X		if (tail == ((char *) NULL))
X		    strcat (fname, front);
X		else
X		{
X		    for (ptr = tail + 1; *ptr; ptr++)
X			if (!isupper (*ptr))
X			    break;
X		    if (!(*ptr))/* drop suffix if all caps */
X			*tail = '\0';
X		    (void) strcat (fname, front);
X		}
X	    }
X	    (void) strcat (fname, ".p");
X	}
X	else
X	{
X	    strcpy (fname, "gps.p");
X	}
X
X	sprintf (newpath, "%s%s", path, fname);
X	Puthead ("\tin=%s\n", newpath);
X#else
X	sprintf (newpath, "%s", "gps.p");
X#endif
X	plpipe[0] = '\0';
X    }
X    else
X    {
X	newpath[0] = '\0';
X	strcpy (plpipe, "cat");
X    }
X    new_plot (newpath, plpipe);
X}
END_OF_FILE
if test 2798 -ne `wc -c <'Masscomp_device/gpslib/gpsopen.c'`; then
    echo shar: \"'Masscomp_device/gpslib/gpsopen.c'\" unpacked with wrong size!
fi
# end of 'Masscomp_device/gpslib/gpsopen.c'
fi
if test -f 'Printronix_device/lprlib/lprerase.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Printronix_device/lprlib/lprerase.c'\"
else
echo shar: Extracting \"'Printronix_device/lprlib/lprerase.c'\" \(2952 characters\)
sed "s/^X//" >'Printronix_device/lprlib/lprerase.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/lprlib/lprerase.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X/*
X * Erase the graphics area (ie output raster image and clear memory)
X */
X#include <stdio.h>
X#include "lprpen.h"
X#include "../include/enum.h"
X#include "../include/erasecom.h"
X#include "../include/extern.h"
X
lprerase (command)
X    int             command;
X{
X    switch (command)
X    {
X    case ERASE_MIDDLE:
X    case ERASE_END:
X	cat ();
X	zap (mem, xlimit);
X    case ERASE_START:
X    default:
X	break;
X    }
X}
X
X
X#define M	0100	/* mask bit for printronix */
char            rev[] =	/* bit reverse table for Printronix format */
X{
X (000 | M), (040 | M), (020 | M), (060 | M), (010 | M), (050 | M), (030 | M), (070 | M),
X (004 | M), (044 | M), (024 | M), (064 | M), (014 | M), (054 | M), (034 | M), (074 | M),
X (002 | M), (042 | M), (022 | M), (062 | M), (012 | M), (052 | M), (032 | M), (072 | M),
X (006 | M), (046 | M), (026 | M), (066 | M), (016 | M), (056 | M), (036 | M), (076 | M),
X (001 | M), (041 | M), (021 | M), (061 | M), (011 | M), (051 | M), (031 | M), (071 | M),
X (005 | M), (045 | M), (025 | M), (065 | M), (015 | M), (055 | M), (035 | M), (075 | M),
X (003 | M), (043 | M), (023 | M), (063 | M), (013 | M), (053 | M), (033 | M), (073 | M),
X (007 | M), (047 | M), (027 | M), (067 | M), (017 | M), (057 | M), (037 | M), (077 | M)
X};
X#define PUT(x)	putc(prev[x], pltout)
X
cat ()
X{
register short *p1, *p2;
register char  *prev;
register int    len;
int             x, xmax, count, addr;
X
X    prev = rev;
X
X    for (p2 = &mem[xlimit * NYW - 1]; p2 >= mem && *p2 == 0; p2--);
X    xmax = (p2 - mem) / NYW + 1;
X    for (x = 0; x < xmax; x++)
X    {
X	p1 = mem + x * NYW;
X	p2 = p1 + (NYW - 1);
X	while (p2 >= p1 && *p2 == 0)
X	    p2--;
X	if (*p2 == 0)
X	    len = 0;
X	else
X	    len = (16 * (p2 - p1 + 1) + 5) / 6;
X	if (len > 132)
X	    len = 132;
X	putc (05, pltout);
X	while (len > 0)
X	{
X	    PUT ((p1[0] >> 10) & 077);
X	    PUT ((p1[0] >> 4) & 077);
X	    PUT ((p1[0] << 2) & 074 | (p1[1] >> 14) & 03);
X	    PUT ((p1[1] >> 8) & 077);
X
X	    if (len == 4)
X		break;
X	    PUT ((p1[1] >> 2) & 077);
X	    PUT ((p1[1] << 4) & 060 | (p1[2] >> 12) & 017);
X	    PUT ((p1[2] >> 6) & 077);
X	    PUT ((p1[2]) & 077);
X	    p1 += 3;
X	    len -= 8;
X	}
X	putc ('\n', pltout);
X    }
X    putc ('\f', pltout);
X    return;
X}
X
zap (addr, nx)		/* zero memory */
X    register int   *addr, nx;
X{
register int    count;
X    count = nx * NYW / 2;
X    while (count--)
X	*addr++ = 0;
X}
END_OF_FILE
if test 2952 -ne `wc -c <'Printronix_device/lprlib/lprerase.c'`; then
    echo shar: \"'Printronix_device/lprlib/lprerase.c'\" unpacked with wrong size!
fi
# end of 'Printronix_device/lprlib/lprerase.c'
fi
if test -f 'RasterTek_device/rteklib/rtekopen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'RasterTek_device/rteklib/rtekopen.c'\"
else
echo shar: Extracting \"'RasterTek_device/rteklib/rtekopen.c'\" \(2973 characters\)
sed "s/^X//" >'RasterTek_device/rteklib/rtekopen.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/rteklib/rtekopen.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Joe Dellinger Feb 12 1988
X *	Initial color should be white not blue!
X * Joe Dellinger Mar 3 1988
X *	Get device file name in /dev out of include file.
X */
X
X#include "rtekpen.h"
X#ifdef SEP
X#define	GETPAR fetch
X#else
X#define	GETPAR getpar
X#endif
X
X#include "../include/attrcom.h"
X#include "../include/params.h"
X
FILE           *rtekfd = NULL;
char            devname[] = RTEKDEV;
extern int      allowecho;
X
rtekopen ()
X{
int             bufsize;
char            block[10], *buffer;
X
X    dev_xmax = 635;
X    dev_ymax = 507;
X    dev_xmin = -635;
X    dev_ymin = -507;
X    pixels_per_inch = 100.;
X    aspect_ratio = 1.;
X
X    /* device capabilities */
X    need_end_erase = YES;
X    buffer_output = NO;
X    smart_clip = YES;
X    num_col = 256;
X
X    /* make pen leave our echoing alone */
X    allowecho = YES;
X
X    /* fast device, so default a nice font */
X    txfont = DEFAULT_HARDCOPY_FONT;
X    txprec = DEFAULT_HARDCOPY_PREC;
X
X    /* open dma channel to Raster Tech */
X    rtekfd = fopen (devname, "w");
X    if (rtekfd == NULL)
X	ERR (FATAL, name, "can't open Raster Tech\n");
X
X    /* setup buffer */
X    GETPAR ("block", "s", block);
X    switch (block[0])
X    {
X    case 'l':
X    case 'b':
X    case 'h':
X	bufsize = 100000;
X	break;
X    case 's':
X	bufsize = 16;
X	break;
X    case 'm':
X    default:
X	bufsize = 512;
X	break;
X    }
X    bufsize &= ~1;		/* make sure it is even */
X    buffer = (char *) malloc (bufsize);
X    setbuffer (rtekfd, buffer, bufsize);
X
X    /* set graphics mode, undo any Movie remnants */
X
X    CHKLEN (26);
X    byte (GRAPHICS);		/* cmdlen = 26 */
X    byte (NOP);
X    byte (RDMODE);
X    byte (1);
X    byte (MODDIS);
X    byte (2);
X    byte (NOP);
X    byte (ZOOM);
X    byte (1);
X    byte (SCRORG);
X    word (0);
X    word (0);
X    byte (WINDOW);
X    word (dev_xmin);
X    word (dev_ymin);
X    word (dev_xmax);
X    word (dev_ymax);
X    byte (WMSK16);
X    word (65535);
X
X    /* initialize color */
X    rtekattributes (SET_COLOR_TABLE, 0, 0, 0, 0);
X    rtekattributes (SET_COLOR_TABLE, 1, 0, 0, 255);
X    rtekattributes (SET_COLOR_TABLE, 2, 255, 0, 0);
X    rtekattributes (SET_COLOR_TABLE, 3, 255, 0, 255);
X    rtekattributes (SET_COLOR_TABLE, 4, 0, 255, 0);
X    rtekattributes (SET_COLOR_TABLE, 5, 0, 255, 255);
X    rtekattributes (SET_COLOR_TABLE, 6, 255, 255, 0);
X    rtekattributes (SET_COLOR_TABLE, 7, 255, 255, 255);
X    rtekattributes (SET_COLOR, 7, 0, 0, 0);
X}
END_OF_FILE
if test 2973 -ne `wc -c <'RasterTek_device/rteklib/rtekopen.c'`; then
    echo shar: \"'RasterTek_device/rteklib/rtekopen.c'\" unpacked with wrong size!
fi
# end of 'RasterTek_device/rteklib/rtekopen.c'
fi
if test -f 'Virtual_device/raslib/rasvector.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Virtual_device/raslib/rasvector.c'\"
else
echo shar: Extracting \"'Virtual_device/raslib/rasvector.c'\" \(2575 characters\)
sed "s/^X//" >'Virtual_device/raslib/rasvector.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/raslib/rasvector.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include <stdio.h>
X#include <math.h>
X#include "../include/extern.h"
X#include "raspen.h"
X
X/*
X * This code originally written by Jeff Thorson ("apenh"),
X * stolen by Joe Dellinger and somewhat modified for vplot standardization.
X */
X
X#ifdef OR
X#define WRITEIT(A,B) Image (A, B) |= rascolor
X#define RASVECTOR rasvector2
X#else
X#define WRITEIT(A,B) Image (A, B) = rascolor
X#define RASVECTOR rasvector
X#endif
X
RASVECTOR (x1, y1, x2, y2, nfat, dashon)
X    int             x1, y1, x2, y2;
X    int             nfat, dashon;
X{
int             test, tmp, x, y;
double          slope, fx, fx3, fy, fy3;
X
X/*
X * Vector rasterizes the line defined by the endpoints (x1,y1) and (x2,y2).
X * If 'nfat' is nonzero then draw parallel lines to fatten the line, by
X * recursive calls to vector.
X */
X
X    if (nfat < 0)
X	return;
X
X    if (dashon)
X    {
X	dashvec (x1, y1, x2, y2, nfat, dashon);
X	return;
X    }
X
X    if (nfat)
X    {
X	if (clip (&x1, &y1, &x2, &y2))
X	    return;
X
X	fatvec (x1, y1, x2, y2, nfat, dashon);
X	return;
X    }
X
X    if (clip (&x1, &y1, &x2, &y2))
X	return;
X
X/* Beware checks out of bounds, since the coordinate system may have rotated */
X
X    test = (abs (x2 - x1) >= abs (y2 - y1));
X
X    if (test)
X    {
X	if (x1 == x2)
X	{
X	    /* Just a point */
X	    WRITEIT (x1, y1);
X	    return;
X	}
X	else
X	if (x1 > x2)
X	{
X	    tmp = x1;
X	    x1 = x2;
X	    x2 = tmp;
X	    tmp = y1;
X	    y1 = y2;
X	    y2 = tmp;
X	}
X	slope = (double) (y2 - y1) / (double) (x2 - x1);
X	fy3 = y1;
X
X	for (x = x1, fy = fy3; x < x2; x++, fy += slope)
X	{
X	    y = fy + .5;	/* OK rounding, since always positive */
X	    WRITEIT (x, y);
X	}
X	WRITEIT (x2, y2);
X	return;
X    }
X    else
X    {
X	/* y1 can't equal y2 here */
X	if (y1 > y2)
X	{
X	    tmp = x1;
X	    x1 = x2;
X	    x2 = tmp;
X	    tmp = y1;
X	    y1 = y2;
X	    y2 = tmp;
X	}
X	slope = (double) (x2 - x1) / (double) (y2 - y1);
X	fx3 = x1;
X
X	for (y = y1, fx = fx3; y < y2; y++, fx += slope)
X	{
X	    x = fx + .5;
X	    WRITEIT (x, y);
X	}
X	WRITEIT (x2, y2);
X	return;
X    }
X}
END_OF_FILE
if test 2575 -ne `wc -c <'Virtual_device/raslib/rasvector.c'`; then
    echo shar: \"'Virtual_device/raslib/rasvector.c'\" unpacked with wrong size!
fi
# end of 'Virtual_device/raslib/rasvector.c'
fi
if test -f 'Vplot_Kernel/Hershey/hertogrid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/Hershey/hertogrid.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/Hershey/hertogrid.c'\" \(2586 characters\)
sed "s/^X//" >'Vplot_Kernel/Hershey/hertogrid.c' <<'END_OF_FILE'
X/*
X *
X *  source file:   ./Hershey/hertogrid.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X/*
X * This program allows you to scan the glyphs in the Hershey character sets,
X * and tells you the Hershey glyph number of each.
X * This allows you to construct appropriate .hmp files for a new font you are
X * putting together.
X * .hmp files have already been created for all the occidental files, but nothing
X * has been done with the oriental ones. Anyone out there in Japan want to do this?
X *
X * This program is used by:
X * cat hershey.oc? | hertogrid | plas | pen_filter
X *
X * As a start to anyone out there that wants to do Japanese,
X * Hirigana runs from 6000 to 6079, and
X * Katakana runs from 6100 to 6179.
X *
X * (What do you get with glyphs 1056 and then 5055?)
X *
X * Joe Dellinger,
X * Stanford University Dept of Geophysics
X */
X#include <stdio.h>
X/*
X * scanint: a function to scan an integer, using n characters of
X *          the input file, ignoring newlines. (scanf won't work
X *          because it also ignores blanks)
X */
int
scanint (n)
X    int             n;
X{
char            buf[20];
int             i, c;
X
X    for (i = 0; i < n; i++)
X    {
X	while ((c = getchar ()) == '\n');	/* discard spare newlines */
X	if (c == EOF)
X	    return (-1);
X	buf[i] = c;
X    }
X
X    buf[i] = 0;
X    return (atoi (buf));
X}
X
int             rows = 10, cols = 10, scale = 11, maxpage = 10;
main ()
X{
int             ich, nch, i, x, y, k, kn, xx, yy;
int             line[2][1000];
int             move, ipnt;
X
X    printf ("S r\nJ 2 5\n");
X    for (k = 0, kn = rows * cols * maxpage; k < kn; k++)
X    {
X	if ((ich = scanint (5)) < 1)
X	{
X	    exit (0);
X	}
X	nch = scanint (3);
X
X	for (i = 0; i < nch; i++)
X	{
X	    if ((i == 32) || (i == 68) || (i == 104) || (i == 140))
X		getchar ();	/* skip newlines */
X	    line[0][i] = getchar ();
X	    line[1][i] = getchar ();
X	}
X	getchar ();
X
X/*		     .. left and right widths */
X
X	if (k % (rows * cols) == 0 && k > 0)
X	    printf ("e\n");
X	xx = (k % rows) * 40 + 20;
X	yy = (k % (rows * cols)) / rows * 47 + 25;
X
X	printf ("m %d %d\n", scale * xx, scale * (yy - 15));
X	printf ("T 2 0\n");
X	printf ("%d\n", ich);
X
X	move = 1;
X	for (ipnt = 1; ipnt < nch; ipnt++)
X	{
X	    if (line[0][ipnt] == ' ')
X	    {
X		move = 1;
X	    }
X	    else
X	    {
X		x = (int) line[0][ipnt] - (int) 'R' + xx;
X		y = yy - (int) line[1][ipnt] + (int) 'R';
X		if (move)
X		    printf ("m ");
X		else
X		    printf ("d ");
X		move = 0;
X		printf ("%d %d\n", scale * x, scale * y);
X	    }
X	}
X    }
X}
END_OF_FILE
if test 2586 -ne `wc -c <'Vplot_Kernel/Hershey/hertogrid.c'`; then
    echo shar: \"'Vplot_Kernel/Hershey/hertogrid.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/Hershey/hertogrid.c'
fi
if test -f 'Vplot_Kernel/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/README'\"
else
echo shar: Extracting \"'Vplot_Kernel/README'\" \(2565 characters\)
sed "s/^X//" >'Vplot_Kernel/README' <<'END_OF_FILE'
Read all the other README files which are in most directories
before attempting "make install".
X
You may also want to look at all the stuff in the directory ./Documentation.
In particular, you should read the copyright notice in vplot.mn.
X
Here are the files you should have:
X
Documentation - just what it says
X
Hershey - stuff for converting the Hershey fonts as distributed to something
X	  Vplot can use.
X
Hershey_Fonts - the actual Hershey Fonts themselves. These are NOT themselves
X		part of Vplot, but this directory may be included as a
X		convenience. If you don't have this directory, you'll have
X		to track down your own copy of the Hershey Fonts. Vplot is
X		useable without them, but you'll only have 1 boring font.
X
Makefile - just spawns off all the other makefiles in the subdirectories.
X
README - this file
X
filters - the source for the vplot filters.
X
lvplot - the source for the lvplot library.
X
util - the source for some vplot utility programs.
X
X- Joe Dellinger
X
X##########################################################################
X
Notes for the "long" version of the distribution:
X
I have tried to make the "makefile" in this directory such that
X"make install" will do EVERYTHING.
X
Remember, you WILL have to get ALL the site-dependent parameters,
include files, makefile defines, etc, etc, all set FIRST.
X(For the most part, this just means doing the stuff in the README
file in "filters". The make install should probably handle everything
else.)
X
After you THINK you've got that all right, if you're brave, you can
try running this make. It worked on our system, at least...
X
X##########################################################################
X
Notes for the "short" version (if you don't have the Hershey_Fonts directory,
you've got the short version):
X
You will be missing some "demo" files in ./filters/Tests, no big deal.
X
You will either have to get a copy of the Hershey fonts OR edit
X./filters/include/font_definitions.h before any of the pen filters
will compile.
X
The device-dependent code for various filters will be distributed
separately. Simply get the appropriate device-dependent library,
stick it in ./filters, re-run MakeMake, do make, and you should
be in business. Here are the various devices so far (some of them
may not be distributed for a while if I think there's a chance of
getting them improved first):
X
Masscomp (gps),
Sun (2: suntools + NeWS),
XX,
Virtual (2: Generic Raster + Vplot "Editor"),
Tek (2: 401X and 410X),
Envision (Lear Siegler),
Regis,
Imagen,
PostScript,
RasterTek
HPGL
X
X- Joe Dellinger
END_OF_FILE
if test 2565 -ne `wc -c <'Vplot_Kernel/README'`; then
    echo shar: \"'Vplot_Kernel/README'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/README'
fi
if test -f 'Vplot_Kernel/filters/Tests/TEST_clipping' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/Tests/TEST_clipping'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/Tests/TEST_clipping'\" \(2854 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/Tests/TEST_clipping' <<'END_OF_FILE'
X#plas: Vplot units used in this file
e
S s
w -32760 -32760 32760 32760
F 0 0 0
J 0 0
s 0
f 0
c 7
m 0 0
d 8191 0
d 8191 6144
d 0 6144
d 0 0
z
Test of polygon clipping.
z
X
z
First a complicated polygon is drawn in cyan.
z
Then various clipping windows are turned on,
z
and the polygon is drawn again in yellow, blue, red, and green.
z
X
z
Each clipping window is outlined in white.
z
Each polygon should just cover its white window outline,
z
without extending outside.
z
X
d 8191 0
d 8191 6144
d 0 6144
d 0 0
F 0 0 0
J 0 0
s 0
f 0
f 1
m 499 499
d 0 4999
f 0
f 1
m 999 1399
d 499 499
f 0
f 1
m 4999 499
d 999 1399
f 0
f 1
m 3999 499
d 4999 499
f 0
f 1
m 2499 3999
d 3999 499
f 0
f 1
m 4500 1500
d 2499 3999
f 0
f 1
m 2250 2250
d 4500 1500
f 0
f 1
m 999 999
d 2250 2250
f 0
f 1
m 4999 0
d 999 999
f 0
f 1
m 0 4999
d 4999 0
f 0
c 5
a 10
X-1 1 1
X498 498
X998 1399
X4999 498
X3998 498
X2498 3998
X4500 1500
X2250 2250
X998 998
X4999 0
X0 4999
c 7
w 499 499 1249 32760
m 499 499
d 1249 499
d 1249 6144
d 499 6144
d 499 499
f 1
c 6
m 499 499
d 0 4999
f 0
f 1
m 999 1399
d 499 499
f 0
f 1
m 4999 499
d 999 1399
f 0
f 1
m 3999 499
d 4999 499
f 0
f 1
m 2499 3999
d 3999 499
f 0
f 1
m 4500 1500
d 2499 3999
f 0
f 1
m 2250 2250
d 4500 1500
f 0
f 1
m 999 999
d 2250 2250
f 0
f 1
m 4999 0
d 999 999
f 0
f 1
m 0 4999
d 4999 0
f 0
a 10
X-1 1 3
X498 498
X998 1399
X4999 498
X3998 498
X2498 3998
X4500 1500
X2250 2250
X998 998
X4999 0
X0 4999
w 1999 1999 2499 2499
c 7
m 1999 1999
d 2499 1999
d 2499 2499
d 1999 2499
d 1999 1999
c 6
f 1
c 1
m 499 499
d 0 4999
f 0
f 1
m 999 1399
d 499 499
f 0
f 1
m 4999 499
d 999 1399
f 0
f 1
m 3999 499
d 4999 499
f 0
f 1
m 2499 3999
d 3999 499
f 0
f 1
m 4500 1500
d 2499 3999
f 0
f 1
m 2250 2250
d 4500 1500
f 0
f 1
m 999 999
d 2250 2250
f 0
f 1
m 4999 0
d 999 999
f 0
f 1
m 0 4999
d 4999 0
f 0
a 10
X-1 4 1
X498 498
X998 1399
X4999 498
X3998 498
X2498 3998
X4500 1500
X2250 2250
X998 998
X4999 0
X0 4999
w 750 999 4999 1249
c 7
m 750 999
d 4999 999
d 4999 1249
d 750 1249
d 750 999
c 1
f 1
c 4
m 499 499
d 0 4999
f 0
f 1
m 999 1399
d 499 499
f 0
f 1
m 4999 499
d 999 1399
f 0
f 1
m 3999 499
d 4999 499
f 0
f 1
m 2499 3999
d 3999 499
f 0
f 1
m 4500 1500
d 2499 3999
f 0
f 1
m 2250 2250
d 4500 1500
f 0
f 1
m 999 999
d 2250 2250
f 0
f 1
m 4999 0
d 999 999
f 0
f 1
m 0 4999
d 4999 0
f 0
a 10
X-1 3 3
X498 498
X998 1399
X4999 498
X3998 498
X2498 3998
X4500 1500
X2250 2250
X998 998
X4999 0
X0 4999
w 2750 1350 3999 2100
c 7
m 2750 1350
d 3999 1350
d 3999 2100
d 2750 2100
d 2750 1350
c 4
f 1
c 2
m 499 499
d 0 4999
f 0
f 1
m 999 1399
d 499 499
f 0
f 1
m 4999 499
d 999 1399
f 0
f 1
m 3999 499
d 4999 499
f 0
f 1
m 2499 3999
d 3999 499
f 0
f 1
m 4500 1500
d 2499 3999
f 0
f 1
m 2250 2250
d 4500 1500
f 0
f 1
m 999 999
d 2250 2250
f 0
f 1
m 4999 0
d 999 999
f 0
f 1
m 0 4999
d 4999 0
f 0
a 10
X-1 8 2
X498 498
X998 1399
X4999 498
X3998 498
X2498 3998
X4500 1500
X2250 2250
X998 998
X4999 0
X0 4999
END_OF_FILE
if test 2854 -ne `wc -c <'Vplot_Kernel/filters/Tests/TEST_clipping'`; then
    echo shar: \"'Vplot_Kernel/filters/Tests/TEST_clipping'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/Tests/TEST_clipping'
fi
if test -f 'Vplot_Kernel/filters/Tests/TEST_colors' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/Tests/TEST_colors'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/Tests/TEST_colors'\" \(2555 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/Tests/TEST_colors' <<'END_OF_FILE'
X#plas: Vplot units used in this file
e
S s
w -32760 -32760 32760 32760
F 0 0 0
J 0 0
s 0
w -32760 -32760 8190 32760
f 0
c 7
z
Test of colors and polygon fill densities.
z
X
c 0
f 1
m 0 0
d 0 499
f 0
f 1
m 7000 0
d 0 0
f 0
f 1
m 7000 499
d 7000 0
f 0
f 1
m 0 499
d 7000 499
f 0
c 1
f 1
m 0 499
d 0 999
f 0
f 1
m 7000 499
d 0 499
f 0
f 1
m 7000 999
d 7000 499
f 0
f 1
m 0 999
d 7000 999
f 0
a 4
X-1 7 7
X0 499
X7000 499
X7000 999
X0 999
c 2
f 1
m 0 999
d 0 1500
f 0
f 1
m 7000 999
d 0 999
f 0
f 1
m 7000 1500
d 7000 999
f 0
f 1
m 0 1500
d 7000 1500
f 0
a 4
X-1 6 6
X0 999
X7000 999
X7000 1500
X0 1500
c 3
f 1
m 0 1500
d 0 1999
f 0
f 1
m 7000 1500
d 0 1500
f 0
f 1
m 7000 1999
d 7000 1500
f 0
f 1
m 0 1999
d 7000 1999
f 0
a 4
X-1 5 5
X0 1500
X7000 1500
X7000 1999
X0 1999
c 4
f 1
m 0 1999
d 0 2499
f 0
f 1
m 7000 1999
d 0 1999
f 0
f 1
m 7000 2499
d 7000 1999
f 0
f 1
m 0 2499
d 7000 2499
f 0
a 4
X-1 4 4
X0 1999
X7000 1999
X7000 2499
X0 2499
c 5
f 1
m 0 2499
d 0 3000
f 0
f 1
m 7000 2499
d 0 2499
f 0
f 1
m 7000 3000
d 7000 2499
f 0
f 1
m 0 3000
d 7000 3000
f 0
a 4
X-1 3 3
X0 2499
X7000 2499
X7000 3000
X0 3000
c 6
f 1
m 0 3000
d 0 3500
f 0
f 1
m 7000 3000
d 0 3000
f 0
f 1
m 7000 3500
d 7000 3000
f 0
f 1
m 0 3500
d 7000 3500
f 0
a 4
X-1 2 2
X0 3000
X7000 3000
X7000 3500
X0 3500
c 7
f 1
m 0 3500
d 0 3999
f 0
f 1
m 7000 3500
d 0 3500
f 0
f 1
m 7000 3999
d 7000 3500
f 0
f 1
m 0 3999
d 7000 3999
f 0
a 4
X-1 1 1
X0 3500
X7000 3500
X7000 3999
X0 3999
f 20
c 0
m 3500 0
d 3500 3999
F 1 -1 3
J 2 3
f 5
c 7
m 3500 249
T 10 0
Black
m 3881 249
m 3500 750
T 10 0
Blue
m 3804 750
m 3500 1249
T 10 0
Red
m 3766 1249
m 3500 1750
T 10 0
Magenta
m 4091 1750
m 3500 2250
T 10 0
Green
m 3907 2250
m 3500 2750
T 10 0
Cyan
m 3842 2750
m 3500 3249
T 10 0
Yellow
m 3928 3249
m 3500 3750
T 10 0
White
m 3873 3750
z
On a color device colors of bars should match with their labels.
z
If not, then the default colors for the device are wrong.
z
Monochrome devices should display a grey scale, with the background color
z
at the bottom and the opposite of it at the top.
z
The vertical stripe should be drawn in the background color.
f 4
c 1
m 0 4250
d 7000 4250
f 2
c 7
m 1999 4250
T 10 0
Box A
m 2407 4250
F -1 -1 1
m 4999 4250
T 10 0
Box B
m 5420 4250
z
X
z
Box A and Box B at the top should both look exactly the same,
z
except that the blue line should disappear behind Box A and not Box B.
z
If any of the boxes are shaded with something besides the background color
z
X(possibly making it so you can't read the text except in Box B)
z
then your device driver does not do proper fill for color 0. (serious bug)
END_OF_FILE
if test 2555 -ne `wc -c <'Vplot_Kernel/filters/Tests/TEST_colors'`; then
    echo shar: \"'Vplot_Kernel/filters/Tests/TEST_colors'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/Tests/TEST_colors'
fi
if test -f 'Vplot_Kernel/filters/include/extern.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/include/extern.h'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/include/extern.h'\" \(2630 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/include/extern.h' <<'END_OF_FILE'
X/*
X * defines structures referred to herein
X */
X#include "../include/device.h"
X
X/*
X * external variables (quite a few of them)
X */
X
X/*
X * these must be DECLARED in dev.conf
X */
extern char *documentation[];
extern int doclength;
extern char name[];
X
X/*
X * these MUST be initialized in either dev.open or dev.reset
X * (Not setting them will cause a fatal error.)
X */
extern int dev_xmax, dev_ymax, dev_xmin, dev_ymin;
extern float pixels_per_inch;
extern float aspect_ratio;
extern int num_col;
X
X/*
X * options and variables that may also need to be reset in dev.open
X * They can't be reset in dev.reset, because the user may override
X * the values set by the device. (Except that mono will not be reset
X * to NO if the device says it is YES.)
X */
extern int mono, invras;
extern float fatmult;
extern float patternmult;
extern int shade;
extern int wantras;
extern int rotate;
extern float  hshift, vshift;
extern int dither;
extern int endpause;
extern int txfont,txprec,txovly;
extern float pixc, greyc;
X
X/*
X * these can also be set in dev.open or dev.reset if dovplot gets them wrong,
X * but can usually be left at their default values.
X *
X * allowecho must only be reset in dev.open because the user can override
X * from the command line to force it to be YES. (But user can't force it NO.)
X */
extern int allowecho;
extern int need_end_erase;
extern int buffer_output;
extern int smart_clip;
extern int smart_raster;
X
X/*
X * This might also need to be set if you needed to force allowecho.
X */
extern int (*message)();
X
X/*
X * These variables may be useful for referring to in dev.open,
X * so that similar devices can be merged under one pen filter.
X */
extern char wstype[];
extern char callname[];
X
X/*
X * Usual place to read from and place to send the plot to.
X * The device can use these if they are appropriate, or reject
X * these and handle things on its own instead.
X */
extern FILE *pltin;
extern FILE *pltout;
X
X/*
X * device structure stuff.
X */
extern struct device dev;
extern int (*message)();
X
X/*
X * options
X */
extern int epause;
extern int size;
extern int echo;
extern int  xorig, yorig;
extern int overlay;
extern float  xscale, yscale, txscale, mkscale, dashscale;
extern float  hdevscale, vdevscale;
X
X/*
X * variables
X */
extern int xold,yold;
extern int xnew,ynew;
extern int xwmin,xwmax,ywmin,ywmax;
extern int xorigin,yorigin;
extern int fat,fatbase,dashon;
extern int afat;
extern int ipat;
extern struct pat pat[];
extern struct txalign txalign;
extern float mxx, mxy, myx, myy;
extern float dashes[];
extern float dashpos, dashsum;
extern char pltname[];
extern char group_name[];
extern int group_number;
END_OF_FILE
if test 2630 -ne `wc -c <'Vplot_Kernel/filters/include/extern.h'`; then
    echo shar: \"'Vplot_Kernel/filters/include/extern.h'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/include/extern.h'
fi
if test -f 'Vplot_Kernel/filters/include/font_definitions.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/include/font_definitions.h'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/include/font_definitions.h'\" \(2498 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/include/font_definitions.h' <<'END_OF_FILE'
X/*
X * NUM_FONTS is the total number of fonts.
X * Font 0 should be the good old pen font.
X * The Marker routine assumes that fonts 15 and 16
X * are math and misc fonts.
X * Other than that, I suppose you can reorder them as you like
X * but probably it's a good idea to leave the first 17 fonts just
X * like I've got them here.
X *
X * Additional device-independent fonts can be added quite easily.
X * Fonts 100 and up are reserved for hardware device-dependent fonts,
X * however!
X *
X * - Joe Dellinger
X */
X#define NUM_FONTS	17
X
X
X/*
X * Here are the fonts that we want included at compile time into gentext.c.
X * All other fonts will be loaded at runtime on demand.
X */
X#include "../include/vplotfonts/pen.include"
X#include "../include/vplotfonts/romans.include"
X#include "../include/vplotfonts/romanc.include"
X
X
X#define	BOTTOM	0
X#define	BASE	1
X#define	HALF	2
X#define	CAP	3
X#define	TOP	4
X#define	LETTER	5
X#define	LINE	6
X#define	SPACE	7
X#define	START	8
X#define	END	9
X
X#define NOT_LOADED 0,0,0,0,0,0,0
X
typedef struct {
X	int load;
X	char name[10];
X	short *dim;
X	int   *saddr;
X	short *swidthl;
X	short *swidthr;
X	short *symbol;
X	unsigned short *svec;
X	int *lig;
X} GLYPH;
X
X/*
X * Here are two examples of fonts loaded at compile time.
X * You have to specify all the entries in the GLYPH structure.
X * The "1" in the first slot specifies that this font is already loaded.
X */
GLYPH font[NUMGENFONT] = {
X
X{1, "pen", pen_dim, pen_addr, pen_widthl, pen_widthr, pen_symbol, pen_vec, pen_lig},
X
X
X{1, "romans", romans_dim, romans_addr, romans_widthl, romans_widthr, romans_symbol, romans_vec, romans_lig},
X
X/*
X * Here's an example of a font loaded at run time.
X * You put in ZERO for the first entry in the GLYPH structure.
X * This specifies that this font is not loaded.
X * You still put the font name in the second slot as for a loaded font.
X * All the rest of the slots should have zeroes put in them
X * to make the compiler happy.
X * The define NOT_LOADED puts in the correct number of zeroes for you.
X */
X{0, "romand", NOT_LOADED},
X
X{1, "romanc", romanc_dim, romanc_addr, romanc_widthl, romanc_widthr, romanc_symbol, romanc_vec, romanc_lig},
X
X{0, "romant", NOT_LOADED},
X
X{0, "italicc", NOT_LOADED},
X
X{0, "italict", NOT_LOADED},
X
X{0, "scripts", NOT_LOADED},
X
X{0, "scriptc", NOT_LOADED},
X
X{0, "greeks", NOT_LOADED},
X
X{0, "greekc", NOT_LOADED},
X
X{0, "cyrilc", NOT_LOADED},
X
X{0, "gothgbt", NOT_LOADED},
X
X{0, "gothgrt", NOT_LOADED},
X
X{0, "gothitt", NOT_LOADED},
X
X{0, "math", NOT_LOADED},
X
X{0, "misc", NOT_LOADED},
X
X};
END_OF_FILE
if test 2498 -ne `wc -c <'Vplot_Kernel/filters/include/font_definitions.h'`; then
    echo shar: \"'Vplot_Kernel/filters/include/font_definitions.h'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/include/font_definitions.h'
fi
if test -f 'Vplot_Kernel/filters/include/mesgcom.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/include/mesgcom.h'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/include/mesgcom.h'\" \(2737 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/include/mesgcom.h' <<'END_OF_FILE'
X/*
X * commands for device's message routine
X */
X#define MESG_HOME			0
X#define MESG_OFF 			1
X#define MESG_ON 			2
X#define MESG_ERASE			3
X#define MESG_HIGHLIGHT_ON		4
X#define MESG_HIGHLIGHT_OFF 		5
X#define MESG_READY 			6
X#define MESG_DONE			7
X#define MESG_TEXT			8
X#define MESG_MESSAGE			9
X
X/*
X *  MESG_HOME: home the cursor. This does not have to be the terminal's
X *	"home" position. Anyplace likely to be out of the way of the graph
X *	will do.  Leave room for the prompt's text which will surely follow
X *	immediately on this command's heels. If you handle all prompting
X *	yourself, ignore this command.
X *
X *  MESG_OFF: turn the message (text screen) off, leaving the text intact
X *	but invisible. If this is not possible, this should be interpreted
X *	as an erase. If the text and graphics screen are completely
X *	separate, ignore this command.
X *
X *  MESG_ON: turn the message (text screen) back on again if you turned it off.
X *	If you erased it, this may not be possible. If so, just forget about it.
X *
X *  MESG_ERASE: erase the text screen. Do this even if you know how to just
X *	make the text invisible; we want to use the text screen for
X *	prompting and need to leave it on. If you handle all prompting
X *	yourself, ignore this command.
X *
X *  MESG_HIGHLIGHT_ON: after "READY", means that the following message is
X *	a prompt generated by the vplot device-independent code. Normally
X *	you will want to indicate to the user that this text is a prompt by
X *	going into some sort of "highlighted" text mode. Some devices may
X *	want to handle prompting by themselves in dev.interact in a
X *	device-dependent way, however, and they can take this as a signal
X *	to ignore the following text.
X *
X *  MESG_HIGHLIGHT_OFF: get out of "prompt mode".
X *
X *  MESG_READY: get ready to print a message.
X *
X *  MESG_DONE: we're through printing the message.
X *
X *  MESG_TEXT: print out the given text.
X *
X *  MESG_MESSAGE: after "READY", means that the following message is
X *	from the "VP_MESSAGE" vplot command, and so might want to be
X *	treated differently from other messages such as errors or prompts.
X */
X
X/*
X * The modes MESG_READY, MESG_TEXT, MESG_HIGHLIGHT_OFF,
X * MESG_HIGHLIGHT_ON, MESG_DONE, and MESG_MESSAGE can only occur
X * in the following orders:
X *
X * READY, [MESSAGE optionally], TEXT, DONE
X *
X * For a prompt:
X * READY, HIGHLIGHT_ON, TEXT, DONE, dev.interact,
X * HIGHLIGHT_OFF, [READY, TEXT (carriage return - line feed),] DONE
X *
X * The other modes can occur at any time in any order!
X */
X
X#define CRLF			"\015\012"
X
X/*
X * Use CRLF instead of \n when you are putting a newline on the end of
X * a message, since the output may be (probably is, in fact) in raw mode.
X * Note that "error" puts this on FOR you.
X */
X
END_OF_FILE
if test 2737 -ne `wc -c <'Vplot_Kernel/filters/include/mesgcom.h'`; then
    echo shar: \"'Vplot_Kernel/filters/include/mesgcom.h'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/include/mesgcom.h'
fi
if test -f 'Vplot_Kernel/filters/include/vplot.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/include/vplot.h'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/include/vplot.h'\" \(2561 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/include/vplot.h' <<'END_OF_FILE'
X/*
X * Weird backwards-compatible units
X */
X#define RPERIN 		600.	/* vplot units per inch */
X#define HATCHPERIN	100.	/* Hatch units per inch */
X#define TXPERIN 	33.	/* Text units per inch */
X#define FATPERIN	200.	/* Fatness units per inch */
X/*
X * Height in inches of "standard" device, standard style
X */
X#define STANDARD_HEIGHT 10.24
X/*
X * Height in inches of "standard" device, rotated style
X */
X#define ROTATED_HEIGHT	 7.5
X/*
X * Aspect ratio of the default window (height/width)
X */
X#define SCREEN_RATIO 0.75
X#define VP_MAX 54.6		/* absolute maximum x or y coordinate in inches */
X
X/*
X * text alignment enumerations
X */
X/* horizontal */
X#define	TH_NORMAL	0
X#define	TH_LEFT		1
X#define	TH_CENTER	2
X#define	TH_RIGHT	3
X#define TH_SYMBOL	4
X
X/* vertical */
X#define	TV_NORMAL	0
X#define TV_BOTTOM	1
X#define TV_BASE		2
X#define TV_HALF		3
X#define TV_CAP		4
X#define TV_TOP		5
X#define TV_SYMBOL	6
X
struct txalign {
X	int hor;
X	int ver;
X};
X
X/*
X * text precision enumerations
X */
X#define STRING	0
X#define CHAR	1
X#define STROKE	2
X/* leave it what it already was */
X#define NO_CHANGE -1
X
X/*
X * text overlay enumerations
X */
X#define OVLY_NORMAL	0
X#define OVLY_BOX	1
X#define OVLY_SHADE	2
X#define OVLY_SHADE_BOX	3
X
X/*
X * colors
X */
X#define BLACK    0
X#define BLUE     1
X#define RED      2
X#define PURPLE   3
X#define GREEN    4
X#define CYAN     5
X#define YELLOW   6
X#define WHITE    7
X
X/*
X * Coordinate Origin
X */
X#define STANDARD	0
X#define ROTATED		1
X#define ABSOLUTE 	3
X
X/*
X * Fonts
X */
X
X#define PEN		0
X#define ROMANS		1
X#define ROMAND		2
X#define ROMANC		3
X#define ROMANT		4
X#define ITALICC		5
X#define ITALICT		6
X#define SCRIPTS		7
X#define SCRIPTC		8
X#define GREEKS		9
X#define GREEKC		10
X#define CYRILC		11
X#define GOTHGBT		12
X#define GOTHGRT		13
X#define GOTHITT		14
X#define MATH		15
X#define MISC		16
X
X/*
X * vplot metafile op-codes
X */
X
X#define VP_SETSTYLE		'S'
X
X#define VP_MOVE			'm'
X#define VP_DRAW			'd'
X#define VP_PLINE	    	'L'
X#define VP_PMARK	   	'M'
X#define VP_TEXT			'T'
X#define VP_GTEXT		'G'
X#define VP_AREA			'A'
X#define VP_OLDAREA		'a'
X#define VP_BYTE_RASTER		'R'
X#define VP_BIT_RASTER		'r'
X
X#define VP_ERASE		'e'
X#define VP_BREAK		'b'
X#define VP_PURGE		'p'
X#define VP_NOOP			'n'
X
X#define VP_ORIGIN		'o'
X#define VP_WINDOW		'w'
X
X#define VP_FAT			'f'
X#define VP_SETDASH		's'
X#define VP_COLOR		'c'
X#define VP_SET_COLOR_TABLE	'C'
X#define VP_TXALIGN		'J'
X#define VP_TXFONTPREC		'F'
X#define VP_PATLOAD		'l'
X#define VP_OVERLAY		'v'
X
X#define VP_MESSAGE		'z'
X#define VP_BEGIN_GROUP		'['
X#define VP_END_GROUP		']'
X
X/* Hopefully now dead primitives */
X#define VP_OLDTEXT		't'
END_OF_FILE
if test 2561 -ne `wc -c <'Vplot_Kernel/filters/include/vplot.h'`; then
    echo shar: \"'Vplot_Kernel/filters/include/vplot.h'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/include/vplot.h'
fi
if test -f 'Vplot_Kernel/filters/utilities/dashvec.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/utilities/dashvec.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/utilities/dashvec.c'\" \(2919 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/utilities/dashvec.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/utilities/dashvec.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Joe Dellinger Mar 2 1987
X *	Simplify a few expressions that made the IBM RT's barf.
X */
X
X/*
X * Utility routine to make dashed lines.
X * Should ONLY be called if dashon > 0
X */
X
X#include <stdio.h>
X#include <math.h>
X#include "../include/extern.h"
X#include "../include/round.h"
X
X/*
X * dash1, gap1, dash2, gap2
X * in inches.
X */
X
dashvec (x1, y1, x2, y2, nfat, dashon)
X    int             x1, y1, x2, y2;
X    int             nfat, dashon;
X{
double          dash_ahead, dash_behind, dashdist, dist, sine, cosine;
double          deltax, deltay, lambda1, lambda2;
int             i, nextdash;
double          dashmod ();
int             xv1, xv2, yv1, yv2;
X
X/*
X * If not a dashed line, should never have even been called.
X * Can't dash a single point!
X */
X    if (!dashon || (x1 == x2 && y1 == y2))
X	return;
X
X/*
X * find current position in dashes
X */
X    dashpos = (float) dashmod ((double) dashpos, (double) dashsum);
X    dash_behind = dashpos;
X
X    i = 0;
X    dash_ahead = 0.;
X    while (dash_ahead < dash_behind)
X    {
X	dash_ahead += dashes[i];
X	i++;
X    }
X    nextdash = i - 1;
X/*
X * compute distances, properly scaled
X */
X    deltax = x2 - x1;
X    deltay = y2 - y1;
X    lambda1 = 1. / pixels_per_inch;
X    lambda2 = aspect_ratio / pixels_per_inch;
X    dist = sqrt (lambda1 * lambda1 * deltax * deltax + lambda2 * lambda2 * deltay * deltay);
X    sine = deltay / dist;
X    cosine = deltax / dist;
X
X/*
X * draw the dashed line
X */
X    for (dashdist = 0.;
X	 dash_ahead - dashpos < dist;
X	 dashdist += dash_ahead - dash_behind,
X	 dash_behind = dash_ahead,
X	 nextdash++,
X	 dash_ahead += dashes[nextdash % (dashon * 2)])
X    {
X	if (nextdash % 2 == 0)
X	{
X	    xv1 = ROUND (x1 + cosine * (dashdist));
X	    yv1 = ROUND (y1 + sine * (dashdist));
X	    xv2 = ROUND (x1 + cosine * (dashdist + (dash_ahead - dash_behind)));
X	    yv2 = ROUND (y1 + sine * (dashdist + (dash_ahead - dash_behind)));
X
X	    dev.vector (xv1, yv1, xv2, yv2, nfat, 0);
X	}
X    }
X
X    if (nextdash % 2 == 0)
X    {
X	xv1 = ROUND (x1 + cosine * (dashdist));
X	yv1 = ROUND (y1 + sine * (dashdist));
X
X	dev.vector (xv1, yv1, x2, y2, nfat, 0);
X    }
X
X/*
X * Increment to new position in dash pattern.
X */
X    dashpos += dashmod (dist, (double) dashsum);
X}
X
X/*
X * mod subroutine
X */
double
dashmod (a, b)
X    double          a, b;
X{
X    return (a - floor (a / b) * b);
X}
END_OF_FILE
if test 2919 -ne `wc -c <'Vplot_Kernel/filters/utilities/dashvec.c'`; then
    echo shar: \"'Vplot_Kernel/filters/utilities/dashvec.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/utilities/dashvec.c'
fi
echo shar: End of archive 10 \(of 24\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
