Subject:  v14i017:  Device-independant graphics system, with drivers
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Joe Dellinger <joe@hanauma.STANFORD.EDU>
Posting-number: Volume 14, Issue 17
Archive-name: vplot/part12

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 24)."
# Wrapped by rsalz@fig.bbn.com on Fri Mar 25 11:47:16 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Printronix_device/lprlib/lprvector.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Printronix_device/lprlib/lprvector.c'\"
else
echo shar: Extracting \"'Printronix_device/lprlib/lprvector.c'\" \(4223 characters\)
sed "s/^X//" >'Printronix_device/lprlib/lprvector.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/lprlib/lprvector.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include <stdio.h>
X#include "lprpen.h"
X#include "../include/err.h"
X#include "../include/enum.h"
X#include "../include/extern.h"
X
X/*
X * Vector rasterizes the line defined by the endpoints (x1,y1) and (x2,y2).
X */
X
extern int      lpr_color;
X
lprvector (x1, y1, x2, y2, nfat, dashon)
X    int             x1, y1, x2, y2, nfat, dashon;
X{
register int    test, bit, dx2, dy2, len;
register short *psec;
int             dx, dy, i;
X
X    if (nfat < 0)
X	return;
X
X    if (dashon)
X    {
X	dashvec (x1, y1, x2, y2, nfat, dashon);
X	return;
X    }
X
X    if (nfat)
X    {
X	fatvec (x1, y1, x2, y2, nfat, dashon);
X	return;
X    }
X
X    if (clip (&x1, &y1, &x2, &y2))
X	return;
X
X    if (x2 >= xlimit)
X    {
X	/*
X	 * Try expanding memory. If it fails take what we can get and
X	 * rewindow the vector. Expand will print a warning message. 
X	 */
X	if (expand (x2) <= x2)
X	    if (clip (&x1, &y1, &x2, &y2))
X		return;
X    }
X    dx = (x2 > x1 ? x2 - x1 : x1 - x2);
X    dy = (y2 > y1 ? y2 - y1 : y1 - y2);
X    dx2 = dx << 1;
X    dy2 = dy << 1;
X    if (((dx < dy) && (y1 > y2)) || ((dx >= dy) && (x1 > x2)))
X    {
X	test = x1;
X	x1 = x2;
X	x2 = test;		/* swap endpoints to make */
X	test = y1;
X	y1 = y2;
X	y2 = test;		/* intervals positive  */
X    }
X    psec = mem + x1 * NYW + (y1 >> 4);
X    bit = 0100000 >> (y1 & 017);
X    if (lpr_color > 0)
X	*psec |= bit;		/* plot first point */
X    else
X	*psec &= ~bit;		/* plot first point */
X
X    if (dx >= dy)		/* plot y = f(x)  */
X    {
X	len = dx;
X	test = len - dy2;
X	if (y2 > y1)
X	{
X	    while (len--)
X	    {
X		psec += NYW;
X		if (test <= 0)	/* test for y increment */
X		{
X		    if ((bit = (bit >> 1)) == 0)
X		    {
X			bit = 0100000;
X			psec++;
X		    }
X		    test += dx2;
X		}
X		if (lpr_color > 0)
X		    *psec |= bit;
X		else
X		    *psec &= ~bit;
X		test -= dy2;
X	    }
X	}
X	else
X	{
X	    while (len--)
X	    {
X		psec += NYW;
X		if (test <= 0)	/* test for y increment */
X		{
X		    if ((bit = (bit << 1)) == 0200000)
X		    {
X			bit = 01;
X			psec--;
X		    }
X		    test += dx2;
X		}
X		if (lpr_color > 0)
X		    *psec |= bit;
X		else
X		    *psec &= ~bit;
X		test -= dy2;
X	    }
X	}
X    }
X    else			/* plot x = f(y)  */
X    {
X	len = dy;
X	test = len - dx2;
X	if (x2 > x1)
X	{
X	    while (len--)
X	    {
X		if (test <= 0)	/* test for x increment */
X		{
X		    psec += NYW;
X		    test += dy2;
X		}
X		if ((bit = (bit >> 1)) == 0)
X		{
X		    bit = 0100000;
X		    psec++;
X		}
X		if (lpr_color > 0)
X		    *psec |= bit;
X		else
X		    *psec &= ~bit;
X		test -= dx2;
X	    }
X	}
X	else
X	{
X	    while (len--)
X	    {
X		if (test <= 0)	/* test for x increment */
X		{
X		    psec -= NYW;
X		    test += dy2;
X		}
X		if ((bit = (bit >> 1)) == 0)
X		{
X		    bit = 0100000;
X		    psec++;
X		}
X		if (lpr_color > 0)
X		    *psec |= bit;
X		else
X		    *psec &= ~bit;
X		test -= dx2;
X	    }
X	}
X    }
X}
X
X/*
X * expand memory in units of 2*NYW*XINCSZ bytes.
X * If we fail to get more memory then use what
X * already have and set the window.
X */
expand (x)
X    int             x;
X{
int             xinc, desired, newxlimit, newsize;
short          *memhold;
char           *realloc ();
X
X    xinc = ((x + XINCSZ) / XINCSZ) * XINCSZ - xlimit;
X    desired = xinc;
X    while (xinc > 0)
X    {
X	newsize = 2 * (xlimit + xinc) * NYW;
X	memhold = mem;
X	mem = (short *) realloc (memhold, newsize);
X	if (mem != NULL)
X	    break;
X	mem = memhold;
X	xinc -= XINCSZ;
X    }
X    newxlimit = xlimit + xinc;
X    if (xinc < desired)
X    {
X	ERR (WARN, name,
X	     "cannot expand memory. Plot limited to %6.2f inches",
X	     (float) (newxlimit / 200.0));
X	/* stop requests for more memory */
X	xwmax = newxlimit - 1;
X    }
X    zap (&mem[xlimit * NYW], xinc);
X    xlimit = newxlimit;
X    return (xlimit);
X}
END_OF_FILE
if test 4223 -ne `wc -c <'Printronix_device/lprlib/lprvector.c'`; then
    echo shar: \"'Printronix_device/lprlib/lprvector.c'\" unpacked with wrong size!
fi
# end of 'Printronix_device/lprlib/lprvector.c'
fi
if test -f 'Virtual_device/vplib/vpattr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Virtual_device/vplib/vpattr.c'\"
else
echo shar: Extracting \"'Virtual_device/vplib/vpattr.c'\" \(4864 characters\)
sed "s/^X//" >'Virtual_device/vplib/vpattr.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/vplib/vpattr.c
X *
X * Joe Dellinger (SEP), Dec 19 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include <stdio.h>
X#include <vplot.h>
X#include "../include/attrcom.h"
X#include "../include/params.h"
X#include "../include/extern.h"
X#include "../include/round.h"
X#include "../include/enum.h"
X#include "../include/pat.h"
X#include "vp.h"
X
int             vpcolor = WHITE;
int             vpfat = 0;
X
vpattributes (command, value, v1, v2, v3)
X    int             command, value;
X    int             v1, v2, v3;
X{
static float    vpdash[MAXDASH];
static float    vpgap[MAXDASH];
static int      vpndash;
static int     *vpattrarray;
static int      vpxwmin, vpywmin, vpxwmax, vpywmax;
static int      vpfont1, vpfont2, vpfont3;
static int      vpjust1, vpjust2;
static int      vpcolt1, vpcolt2, vpcolt3, vpcolt4;
static int      vpovly;
int             ii, jj;
X
X    lost = YES;
X
X    if (!vpdumb)
X    {
X	switch (command)
X	{
X	case SET_COLOR:
X	    if (vpsetflag & F_COL)
X	    {
X		if (vpcolor == value)
X		    break;
X	    }
X	    vp_color (value);
X	    vpcolor = value;
X	    vpsetflag |= F_COL;
X	    break;
X
X	case SET_COLOR_TABLE:
X	    if (vpsetflag & F_COLT)
X	    {
X		if (vpcolt1 == value &&
X		    vpcolt2 == v1 &&
X		    vpcolt3 == v2 &&
X		    vpcolt4 == v3)
X		    break;
X	    }
X	    vp_coltab (value,
X		       (float) v1 / (float) MAX_GUN,
X		       (float) v2 / (float) MAX_GUN,
X		       (float) v3 / (float) MAX_GUN);
X	    vpcolt1 = value;
X	    vpcolt2 = v1;
X	    vpcolt3 = v2;
X	    vpcolt4 = v3;
X	    vpsetflag |= F_COLT;
X	    break;
X
X	case SET_WINDOW:
X
X	    if (vpsetflag & F_CLIP)
X	    {
X		if (value == vpxwmin &&
X		    v1 == vpywmin &&
X		    v2 == vpxwmax &&
X		    v3 == vpywmax)
X		    break;
X	    }
X
X	    vp_clip ((float) (value) / RPERIN, (float) (v1) / RPERIN,
X		     (float) (v2) / RPERIN, (float) (v3) / RPERIN);
X	    vpxwmin = value;
X	    vpywmin = v1;
X	    vpxwmax = v2;
X	    vpywmax = v3;
X	    vpsetflag |= F_CLIP;
X	    break;
X
X	case NEW_DASH:
X	    if (vpsetflag & F_DASH)
X	    {
X		if (value == vpndash)
X		{
X		    jj = YES;
X		    for (ii = 0; ii < value; ii++)
X		    {
X			if (vpdash[ii] != dashes[2 * ii] ||
X			    vpgap[ii] != dashes[2 * ii + 1])
X			    jj = NO;
X		    }
X		    if (jj)
X			break;
X		}
X	    }
X
X	    for (ii = 0; ii < value; ii++)
X	    {
X		vpdash[ii] = dashes[2 * ii];
X		vpgap[ii] = dashes[2 * ii + 1];
X	    }
X	    vp_setdash (vpdash, vpgap, value);
X	    vpndash = value;
X	    vpsetflag |= F_DASH;
X	    break;
X
X	case NEW_PAT:
X	    vpattrarray = (int *) malloc ((unsigned)
X		      (pat[value] .xdim * pat[value] .ydim * sizeof (int)));
X
X	    if (vpattrarray != NULL)
X	    {
X		for (ii = 0; ii < pat[value] .xdim * pat[value] .ydim; ii++)
X		    vpattrarray[ii] = pat[value] .patbits[ii];
X
X		vp_patload ((int) RPERIN,
X			    pat[value] .xdim, pat[value] .ydim,
X			    value - 1, vpattrarray);
X
X		free ((char *) vpattrarray);
X	    }
X	    break;
X
X	case NEW_FONT:
X	    if (value == -1)
X		value = vpfont1;
X	    if (v1 == -1)
X		v1 = vpfont2;
X	    if (v2 == -1)
X		v2 = vpfont3;
X
X	    if (vpsetflag & F_FONT)
X	    {
X		if (vpfont1 == value &&
X		    vpfont2 == v1 &&
X		    vpfont3 == v2)
X		    break;
X	    }
X
X	    vp_tfont (value, v1, v2);
X	    vpfont1 = value;
X	    vpfont2 = v1;
X	    vpfont3 = v2;
X	    vpsetflag |= F_FONT;
X	    break;
X
X	case NEW_OVERLAY:
X	    if (vpsetflag & F_OVLY)
X	    {
X		if (vpovly == value)
X		    break;
X	    }
X/*
X * Another libvplot command that doesn't exist but should.
X * XXXXXX
X *		vp_overlay(value);
X */
X	    vpsetflag |= F_OVLY;
X	    vpovly = value;
X	    break;
X
X	case NEW_ALIGN:
X	    if (vpsetflag & F_JUST)
X	    {
X		if (vpjust1 == value &&
X		    vpjust2 == v1)
X		    break;
X	    }
X	    vp_tjust (value, v1);
X	    vpjust1 = value;
X	    vpjust2 = v1;
X	    vpsetflag |= F_JUST;
X	    break;
X
X	case NEW_FAT:
X	    if (vpsetflag & F_FAT)
X	    {
X		if (vpfat == value)
X		    break;
X	    }
X
X	    vp_fat (ROUND (value * FATPERIN / RPERIN));
X	    vpfat = value;
X	    vpsetflag |= F_FAT;
X	    break;
X
X	case BEGIN_GROUP:
X	    if (value > 0)
X		vp_bgroup (group_name);
X	    break;
X
X	case END_GROUP:
X	    if (value > 0)
X		vp_egroup ();
X	    break;
X
X	default:
X	    break;
X	}
X    }
X    else
X    {
X	switch (command)
X	{
X	case SET_COLOR:
X	    if (vpsetflag & F_COL)
X	    {
X		if (vpcolor == value)
X		    break;
X	    }
X	    vp_color (value);
X	    vpcolor = value;
X	    vpsetflag |= F_COL;
X	    break;
X
X	default:
X	    break;
X	}
X    }
X
X    return 0;
X}
END_OF_FILE
if test 4864 -ne `wc -c <'Virtual_device/vplib/vpattr.c'`; then
    echo shar: \"'Virtual_device/vplib/vpattr.c'\" unpacked with wrong size!
fi
# end of 'Virtual_device/vplib/vpattr.c'
fi
if test -f 'Virtual_device/vplib/vpopen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Virtual_device/vplib/vpopen.c'\"
else
echo shar: Extracting \"'Virtual_device/vplib/vpopen.c'\" \(4172 characters\)
sed "s/^X//" >'Virtual_device/vplib/vpopen.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/vplib/vpopen.c
X *
X * Joe Dellinger (SEP), Dec 19 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include <stdio.h>
X#include <vplot.h>
X#include "../include/enum.h"
X#include "../include/extern.h"
X#include "../include/err.h"
X#include "../include/params.h"
X#include "vp.h"
X
extern int
vpopen (), vpreset (), vpmessage (), vperase (), vpclose ();
extern int
vpattributes (), vpvector (), vpplot ();
extern int
vpstartpoly (), vpmidpoly (), vpendpoly ();
extern int
vpraster (), vpmarker (), vptext ();
extern int
genarea (), genpoint ();
extern int      nulldev ();
X
extern FILE    *pltout;
X
extern int      vp_do_dovplot ();
extern int      (*genreader) ();
extern int      allow_pipe;
extern int      first_time;
X
int             vpbig = YES;
int             vpdumb = NO;
int             vpstat = NO;
int             vpalign = NO;
int             vpstyle = YES;
int             vpblast = YES;
int             vpbit = 0;
char            vpaligns[80] = "uu";
int             vparray[2] = {0, 0};
int             vpasize[2] = {0, 0};
int             vpframe = -1;
X
int             vpsetflag;
X
vpopen ()
X{
float           atemp[2];
X
X    first_time = YES;
X
X/*
X * Special options
X */
X    getpar ("dumb", "1", &vpdumb);
X    getpar ("blast", "1", &vpblast);
X    getpar ("bit", "d", &vpbit);
X    getpar ("grid", "d", &vpframe);
X
X    getpar ("stat", "1", &vpstat);
X    getpar ("align", "s", vpaligns);
X
X    if (vpstat || strcmp (vpaligns, "uu") != 0)
X    {
X	vpalign = YES;
X	allow_pipe = NO;
X    }
X
X    getpar ("gridnum", "d", vparray);
X
X    if (vparray[1] == 0)
X	vparray[1] = vparray[0];
X
X    if (vparray[0] != 0)
X    {
X	vpbig = NO;
X	vpstyle = NO;
X    }
X
X    getpar ("big", "1", &vpbig);
X    getpar ("vpstyle", "1", &vpstyle);
X
X    if (vparray[0] != 0)
X    {
X	if (vpbig || vpalign)
X	    ERR (FATAL, name, "Incompatible option with gridnum");
X	atemp[0] = (float) (STANDARD_HEIGHT / SCREEN_RATIO) / vparray[0];
X	atemp[1] = (float) (STANDARD_HEIGHT) / vparray[1];
X
X	getpar ("gridsize", "f", atemp);
X
X	vpasize[0] = atemp[0] * RPERIN;
X	vpasize[1] = atemp[1] * RPERIN;
X    }
X
X
X/*
X * We want to go through the input files ourselves
X */
X
X    genreader = vp_do_dovplot;
X
X/*
X * device capabilities
X */
X
X    if (vpbig)
X    {
X	dev_xmax = VP_MAX * RPERIN;
X	dev_ymax = VP_MAX * RPERIN * SCREEN_RATIO;
X	dev_xmin = -dev_xmax;
X	dev_ymin = -dev_ymax;
X	default_hshift = -dev_xmin;
X	default_vshift = -dev_ymin;
X    }
X    else
X    {
X	dev_xmax = STANDARD_HEIGHT * RPERIN / SCREEN_RATIO;
X	dev_ymax = STANDARD_HEIGHT * RPERIN;
X	dev_xmin = 0;
X	dev_ymin = 0;
X	default_hshift = 0;
X	default_vshift = 0;
X    }
X
X    pixels_per_inch = RPERIN;
X    aspect_ratio = 1.;
X    num_col = 256;
X    if (vparray[0] == 0)
X	size = ABSOLUTE;
X
X
X/*
X * Since font gets hard-wired in after first pass,
X * make it a nice one if they don't specify it.
X */
X    txfont = DEFAULT_HARDCOPY_FONT;
X    txprec = DEFAULT_HARDCOPY_PREC;
X
X/*
X * Make vplib routines more useful to be included in other programs
X * besides just vppen
X */
X    dev.open = vpopen;
X    dev.reset = vpreset;
X    dev.message = vpmessage;
X    dev.erase = vperase;
X    dev.close = vpclose;
X    dev.vector = vpvector;
X    dev.marker = vpmarker;
X    dev.text = vptext;
X    dev.area = genarea;
X    dev.raster = vpraster;
X    dev.point = genpoint;
X    dev.attributes = vpattributes;
X    dev.getpoint = nulldev;
X    dev.interact = nulldev;
X    dev.plot = vpplot;
X    dev.startpoly = vpstartpoly;
X    dev.midpoly = vpmidpoly;
X    dev.endpoly = vpendpoly;
X
X/*
X * To keep messages from being lost
X */
X    message = dev.message;
X
X/*
X * Open up the "device", if we're ever going to use libvplot at all.
X */
X    if (!vpstat)
X    {
X	vp_filep (pltout);
X    }
X
X    allowecho = YES;
X
X}
END_OF_FILE
if test 4172 -ne `wc -c <'Virtual_device/vplib/vpopen.c'`; then
    echo shar: \"'Virtual_device/vplib/vpopen.c'\" unpacked with wrong size!
fi
# end of 'Virtual_device/vplib/vpopen.c'
fi
if test -f 'Vplot_Kernel/Hershey/hertovplot.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/Hershey/hertovplot.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/Hershey/hertovplot.c'\" \(4655 characters\)
sed "s/^X//" >'Vplot_Kernel/Hershey/hertovplot.c' <<'END_OF_FILE'
X/*
X *
X *  source file:   ./Hershey/hertovplot.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X/*
X * This program converts the Hershey fonts in the form distributed with
X * mod.sources into "Vplot fonts", given a ".hmp" file as the first argument.
X * Here is a sample .hmp file, that for the font "romanc":
X *
X2199    2214    2217    2275    2274    2271    2272    2251
X2221    2222    2219    2232    2211    2231    2210    2220
X2200-2209
X2212    2213    2241    2238    2242    2215    2273
X2001-2026
X2223    804     2224    2262    999     2252
X2101-2126
X2225    2229    2226    2246    2218
X2177-2182
X *
X * It is simply a list of the Hershey glyphs to use in that font.
X * For example, the first glyph would be number 2199, the second number 2214,
X * etc, etc. As a shorthand convenience, the notation X-Y will give the
X * inclusive range from number X to number Y. (2200-2209 are the glyphs for
X * the digits, as you might expect.)
X *
X * The optional second argument (default 32) is an integer giving the
X * ASCII value of the first character in the font. (Note that there CAN
X * be more than 256 characters in a font!)
X *
X * For example,
X * cat hersh.oc* | hershtovplot romanc.hmp 32 > romanc_font
X *
X * You have to go in yourself and add such information as the letter spacing,
X * top height, bottom, etc, etc. The hershey fonts provide the left and right
X * width data, which is used, but do not provide data about where to center
X * the symbol vertically if it is used as a marker. This must be edited in
X * by hand if the default calculated by "makefont" is unacceptable.
X *
X * SEE ALSO: makefont.c, a program which "packs" Vplot font files into
X * ".include" fonts so that they can be included into font_definitions.h
X *  and thus be used with "gentext.c". It also makes runtime-loadable
X *  ".bin" fonts. It also gives the format of a vplot font in the comments
X *  at the start of the source!
X *
X * - Joe Dellinger, Stanford University Dept of Geophysics
X *
X * Bits of this code are stolen from "hershey.c" by James Hurt.
X *
X */
X
X#include <stdio.h>
X#include <strings.h>
X
X/*
X * scanint: a function to scan an integer, using n characters of
X *          the input file, ignoring newlines. (scanf won't work
X *          because it also ignores blanks)
X */
int
scanint (n)
X    int             n;
X{
char            buf[20];
int             i, c;
X
X    for (i = 0; i < n; i++)
X    {
X	while ((c = getchar ()) == '\n');	/* discard spare newlines */
X	if (c == EOF)
X	    return (-1);
X	buf[i] = c;
X    }
X
X    buf[i] = 0;
X    return (atoi (buf));
X}
X
main (argc, argv)
X    int             argc;
X    char          **argv;
X{
int             ich, nch, i, j, x, y;
int             font[32000];
int             line[2][1000];
int             move, ipnt;
FILE           *fp;
char            string[100];
int             nc, start;
X
X    if (argc == 1)
X    {
X	fprintf (stderr, "Sorry, but you must specify a .hmp file for me to use\n");
X	exit (1);
X    }
X    fp = fopen (argv[1], "r");
X    if (fp == NULL)
X    {
X	fprintf (stderr, "Can't open the file %s.\n", argv[1]);
X	exit (0);
X    }
X
X    if (argc == 3)
X    {
X	start = atoi (argv[2]);
X    }
X    else
X	start = 32;
X
X    nc = 0;
X    i = 0;
X    while (fscanf (fp, "%s", string) != EOF)
X    {
X	if (index (string, '-'))
X	{
X	    for (j = atoi (string); j <= atoi (index (string, '-') + 1); j++)
X	    {
X		font[i] = j;
X		i++;
X		nc++;
X	    }
X	}
X	else
X	{
X	    font[i] = atoi (string);
X	    i++;
X	    nc++;
X	}
X    }
X
X    fprintf (stderr, "%d glyphs in this font.\n", nc);
X
X    while (1)
X    {
X	if ((ich = scanint (5)) < 1)
X	{
X	    exit (0);
X	}
X	nch = scanint (3);
X
X	for (i = 0; i < nch; i++)
X	{
X	    if ((i == 32) || (i == 68) || (i == 104) || (i == 140))
X		getchar ();	/* skip newlines */
X	    line[0][i] = getchar ();
X	    line[1][i] = getchar ();
X	}
X	getchar ();
X
X	for (i = 0; i < nc; i++)
X	{
X	    if (font[i] == ich)
X		break;
X	}
X
X	if (i < nc)
X	{
X	    fprintf (stderr, "hershey=%d, place=%d\n", ich, i);
X/*		     .. left and right widths */
X
X	    x = -((int) line[0][0] - (int) 'R');
X	    y = (int) line[1][0] - (int) 'R';
X
X	    move = i + start;
X	    if (move >= '!' && move <= '~')
X		printf ("e %d %d %c\n", x, y, move);
X	    else
X		printf ("e %d %d \\%d\n", x, y, move);
X
X	    move = 1;
X	    for (ipnt = 1; ipnt < nch; ipnt++)
X	    {
X		if (line[0][ipnt] == ' ')
X		{
X		    move = 1;
X		}
X		else
X		{
X		    x = (int) line[0][ipnt] - (int) 'R';
X		    y = (int) line[1][ipnt] - (int) 'R';
X		    if (move)
X			printf ("m ");
X		    else
X			printf ("d ");
X		    move = 0;
X		    printf ("%d %d\n", x, -y);
X		}
X	    }
X	}
X    }
X}
END_OF_FILE
if test 4655 -ne `wc -c <'Vplot_Kernel/Hershey/hertovplot.c'`; then
    echo shar: \"'Vplot_Kernel/Hershey/hertovplot.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/Hershey/hertovplot.c'
fi
if test -f 'Vplot_Kernel/filters/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/README'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/README'\" \(4744 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/README' <<'END_OF_FILE'
X
X    PEN filters:  programs to display VPLOT files
X
To make a new set of executables,
X
X    - Link  ./include/vplot.h to /usr/include/vplot.h
X
X    - Edit  ./machdep to reflect the configuration you desire:
X        BIN directory:
X	    Where to put the executables.
X        OWNER, GROUP: parameters for "install"
X        CFLAGS: Link for debugging?  Where are the include files?
X            Note that CFLAGS will be exported to the subdirectories
X            when make is run there.
X
X    - Edit ./machdep_restrict to indicate pen filters that should
X	only be runnable by people in a certain group.
X	Normally all pen filters are owned by "OWNER" and in group
X	"GROUP" (as set in machdep) with everybody having execute
X	permission.
X	Each line of machdep_restrict has the format:
X	pen_filter_name	group_name
X	Pen filter "pen_filter_name" will be executable only by
X	people in group "group_name". If machdep_restrict doesn't
X	exist, all pen filters will be installed with the default
X	permissions.
X
X    - Move subdirectories for pen libraries you don't need (does
X        your installation have a Raster Technologies display?) to
X        ./otherpens.  This will prevent MakeMake from adding those
X        libraries to the Makefile.
X	(If you don't HAVE any pen libraries at all, don't panic,
X	they are also being distributed by the same channels as
X	this "Vplot Kernel" package. For example, if you want a
X	pen filter for an Envision, you simply get the "Envision_device"
X	distribution. In this distribution will be a directory "envilib".
X	Move that directory into this one, and you're ready to go to
X	the next step.)
X
X    - Remove MakeMakesep if you don't have SEPlib on your machine.
X	If you do have SEPlib edit machdepsep like you edited
X	machdep. (See comment on SEPlib at the bottom of this file.)
X
X    - Edit ./hosttype to give your machine type
X
X    - Check the entries in ./include/params.h to be sure the default
X        parameters are correct for your system.
X		The default STYLE is usually STANDARD or ROTATED.
X		The traditional default vplot font is 0; Some prefer 1,
X		the Hershey Roman simplex font.
X
X    - Do
X        csh MakeMake
X            and a Makefile will be generated, based on makefile
X            fragments (*makef files) taken from each device subdirectory.
X	    (If you have written a new device, you should also create
X	    a makef file for it, following one of the ones for another
X	    device as an example.)
X
X        Comment out install lines for files which won't be installed.
X
X        Check the group and owner entries on the install lines.
X            If your users don't have write access in the spooling
X            directory, ipen and pspen must be setuid or setgid
X            (and the owner or group must have the appropriate
X            access).
X
X    - Do
X	Either get the Hershey fonts and install them as described in
X	man vplottext, or edit ./include/font_definitions.h so that you
X	only try to compile the provided pen font into gentext.c.
X	(You can leave the other fonts to be loaded at runtime; if you
X	try to use them you'll only get a warning. That way if you later
X	get the Hershey fonts you can slip them in without having to recompile
X	anything.) Don't forget to do "make" in the directory
X	./include/vplotfonts to install all the required fonts in the required
X	formats.
X
X    - Do 
X        make >& Makelog &
X            and then
X        make install
X            and the programs should be usable. (Good luck! If they're not,
X	    I suppose you have to look in Makelog and figure out what
X	    happened...)
X
Remember to also install copies of plas and pldb (they are in ../util).
You'll need them to try out most of the tests (in ./Tests).
X
If the number of vplot filters on your system grows large, I recommend
creating a shell to pick the correct pen filter for the user. We call
ours ``tube''. An example copy of it is in ../util. Since you won't have
the same terminals, yours will have to be different.
X
The mysterious references to "SEP" in ifdef's throughout the code
and in the Makefiles can be safely ignored if you don't know what SEPlib
is and don't have the -lsep library. This code is designed to run either
under SEP-lib or outside of it. (SEPlib is a seismic data-processing
system invented by Stew Levin and Jon Claerbout that we use in the
Stanford Exploration Project in the Geophysics Department at
Stanford University.)
I didn't want to create a different version of the source code just
for this distribution. We use both the SEP and non-SEP versions of the code
at Stanford.
X
X                                        Written by Chuck Karish
X                                        January 8, 1987
X					Modified by Joe Dellinger
X                                        June 2, 1987
END_OF_FILE
if test 4744 -ne `wc -c <'Vplot_Kernel/filters/README'`; then
    echo shar: \"'Vplot_Kernel/filters/README'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/README'
fi
if test -f 'Vplot_Kernel/filters/Tests/TEST_aspect_ratio' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/Tests/TEST_aspect_ratio'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/Tests/TEST_aspect_ratio'\" \(3917 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/Tests/TEST_aspect_ratio' <<'END_OF_FILE'
X#plas: Vplot units used in this file
e
S s
z
Test for proper aspect ratio.
z
X
w -32760 -32760 32760 32760
F 0 0 0
J 0 0
s 0
f 0
c 7
F 0 0 0
J 0 0
s 0
f 0
F 0 0 0
J 0 0
s 0
f 0
F 0 0 0
J 0 0
s 0
f 0
z
This square should really be exactly square!
z
If it isn't, then you don't have "aspect_ratio" right.
z
X
m 1620 1620
d 5100 1620
d 5100 5100
d 1620 5100
d 1620 1620
m 1967 1620
d 5100 1967
d 4752 5100
d 1620 4752
d 1967 1620
m 2280 1650
d 5063 2280
d 4434 5063
d 1650 4434
d 2280 1650
m 2556 1710
d 4998 2556
d 4152 4998
d 1710 4152
d 2556 1710
m 2796 1794
d 4908 2796
d 3906 4908
d 1794 3906
d 2796 1794
m 3004 1890
d 4806 3004
d 3690 4806
d 1890 3690
d 3004 1890
m 3185 1998
d 4692 3185
d 3510 4692
d 1998 3510
d 3185 1998
m 3335 2112
d 4572 3335
d 3354 4572
d 2112 3354
d 3335 2112
m 3454 2232
d 4446 3454
d 3228 4446
d 2232 3228
d 3454 2232
m 3552 2352
d 4320 3552
d 3126 4320
d 2352 3126
d 3552 2352
m 3624 2472
d 4200 3624
d 3048 4200
d 2472 3048
d 3624 2472
m 3678 2585
d 4080 3678
d 2988 4080
d 2585 2988
d 3678 2585
m 3713 2694
d 3965 3713
d 2946 3965
d 2694 2946
d 3713 2694
m 3738 2796
d 3863 3738
d 2915 3863
d 2796 2915
d 3738 2796
m 3750 2885
d 3767 3750
d 2904 3767
d 2885 2904
d 3750 2885
m 3750 2970
d 3678 3750
d 2898 3678
d 2970 2898
d 3750 2970
m 3738 3048
d 3600 3738
d 2904 3600
d 3048 2904
d 3738 3048
m 3720 3113
d 3528 3720
d 2915 3528
d 3113 2915
d 3720 3113
m 3696 3174
d 3461 3696
d 2933 3461
d 3174 2933
d 3696 3174
m 3672 3222
d 3406 3672
d 2956 3406
d 3222 2956
d 3672 3222
m 3642 3263
d 3360 3642
d 2981 3360
d 3263 2981
d 3642 3263
m 3611 3300
d 3317 3611
d 3004 3317
d 3300 3004
d 3611 3300
m 3582 3330
d 3281 3582
d 3030 3281
d 3330 3030
d 3582 3330
m 3552 3354
d 3252 3552
d 3060 3252
d 3354 3060
d 3552 3354
m 3522 3372
d 3228 3522
d 3083 3228
d 3372 3083
d 3522 3372
m 3492 3383
d 3210 3492
d 3106 3210
d 3383 3106
d 3492 3383
m 3461 3390
d 3198 3461
d 3131 3198
d 3390 3131
d 3461 3390
m 3431 3396
d 3185 3431
d 3154 3185
d 3396 3154
d 3431 3396
m 3402 3396
d 3180 3402
d 3180 3180
d 3396 3180
d 3402 3396
m 3378 3396
d 3180 3378
d 3198 3180
d 3396 3198
d 3378 3396
m 5100 1620
d 1620 1620
m 5100 1620
d 5100 5100
d 1620 5100
d 1620 1620
m 4752 1620
d 5100 4752
d 1967 5100
d 1620 1967
d 4752 1620
m 5063 4434
d 2280 5063
d 1650 2280
d 4434 1650
d 5063 4434
m 2556 4998
d 1710 2556
d 4152 1710
d 4998 4152
d 2556 4998
m 1794 2796
d 3906 1794
d 4908 3906
d 2796 4908
d 1794 2796
m 3690 1890
d 4806 3690
d 3004 4806
d 1890 3004
d 3690 1890
m 4692 3510
d 3185 4692
d 1998 3185
d 3510 1998
d 4692 3510
m 3335 4572
d 2112 3335
d 3354 2112
d 4572 3354
d 3335 4572
m 2232 3454
d 3228 2232
d 4446 3228
d 3454 4446
d 2232 3454
m 3126 2352
d 4320 3126
d 3552 4320
d 2352 3552
d 3126 2352
m 4200 3048
d 3624 4200
d 2472 3624
d 3048 2472
d 4200 3048
m 3678 4080
d 2585 3678
d 2988 2585
d 4080 2988
d 3678 4080
m 2694 3713
d 2946 2694
d 3965 2946
d 3713 3965
d 2694 3713
m 2915 2796
d 3863 2915
d 3738 3863
d 2796 3738
d 2915 2796
m 3767 2904
d 3750 3767
d 2885 3750
d 2904 2885
d 3767 2904
m 3750 3678
d 2970 3750
d 2898 2970
d 3678 2898
d 3750 3678
m 3048 3738
d 2904 3048
d 3600 2904
d 3738 3600
d 3048 3738
m 2915 3113
d 3528 2915
d 3720 3528
d 3113 3720
d 2915 3113
m 3461 2933
d 3696 3461
d 3174 3696
d 2933 3174
d 3461 2933
m 3672 3406
d 3222 3672
d 2956 3222
d 3406 2956
d 3672 3406
m 3263 3642
d 2981 3263
d 3360 2981
d 3642 3360
d 3263 3642
m 3004 3300
d 3317 3004
d 3611 3317
d 3300 3611
d 3004 3300
m 3281 3030
d 3582 3281
d 3330 3582
d 3030 3330
d 3281 3030
m 3552 3252
d 3354 3552
d 3060 3354
d 3252 3060
d 3552 3252
m 3372 3522
d 3083 3372
d 3228 3083
d 3522 3228
d 3372 3522
m 3106 3383
d 3210 3106
d 3492 3210
d 3383 3492
d 3106 3383
m 3198 3131
d 3461 3198
d 3390 3461
d 3131 3390
d 3198 3131
m 3431 3185
d 3396 3431
d 3154 3396
d 3185 3154
d 3431 3185
m 3396 3402
d 3180 3396
d 3180 3180
d 3402 3180
d 3396 3402
m 3198 3396
d 3180 3198
d 3378 3180
d 3396 3378
d 3198 3396
END_OF_FILE
if test 3917 -ne `wc -c <'Vplot_Kernel/filters/Tests/TEST_aspect_ratio'`; then
    echo shar: \"'Vplot_Kernel/filters/Tests/TEST_aspect_ratio'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/Tests/TEST_aspect_ratio'
fi
if test -f 'Vplot_Kernel/filters/Tests/TEST_pattern' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/Tests/TEST_pattern'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/Tests/TEST_pattern'\" \(3984 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/Tests/TEST_pattern' <<'END_OF_FILE'
e
S s
z
Test of user-loaded polygon patterns
z
X
z
This file tests polygons filled with a user-defined pattern.
z
You should have to tilt your head left to read the square insert,
z
and tilt your head right for the bow-tie shaped insert.
z
The background pattern is right side up.
z
Try using the pen option "patternmult=.1" on an imagen.
z
X
z
The hammer should be cyan, and the sickle should be blue.
z
For devices that can only fill with a solid color, the background should
z
be red, and the two inserts should be green.
C 10 255 0 0
C 11 0 255 0
C 12 0 255 0
l   300    0     0    9
l   30   32    32   10
X00000000000000000000000000000000
X44444444444444444444444444444444
X00000000000000000000000000000004
X00000000000000000000000000000004
X00000000000000000000000000000004
X00000000000000000000000000000004
X00000000000000000000000000000004
X00000000000000000000000000000004
X00000000000011111111110000000004
X00000000001111111111111111000004
X00000000011100000000001111000004
X00000000011000000500000011000004
X00000000011100000555000000000004
X00000000011100000555500000000004
X00000000001110555555500000000004
X00000000055111000005500000000004
X00005555500011100000000000000004
X00550000000000110000000000000004
X00000000000001100000000000000004
X00000000000011000000000000000004
X00000000000110000000000000000004
X00000000011100000000000000000004
X00000000000000000000000000000004
X00000000000000000000000000000004
X00000000000000000000000000000004
X00333333033333303333330333333004
X00300000030000003000000300003004
X00300000030000003000000300003004
X00300000030000003000000333330004
X00300000030000003000000300000004
X00333333033333303333330300000004
X00000000000000000000000300000004
l   50   32    32   11
X04444444444444444444444444444444
X04000000000000000000000000000000
X04000000000000000000000000000000
X04000000000000000000000003330000
X04000000000000000000000003003000
X04000000000000000000000003003000
X04000000011100000000000003003000
X04000000011100000000000003003000
X04000000011000000000000003333333
X04000000011000000000000000000000
X04000000110000000000000003000030
X04000000110005550000000003000030
X04000000110055550000000003000030
X04000000110055500000000003000030
X04000000110555500000000003000030
X04000000110000500000000003333330
X04000000110000500100000000000000
X04000000110000501110000003000030
X04000000110000011011000003000030
X04000000110000111001100003000030
X04000000011011110000110003000030
X04000000011111150000010003000030
X04000000001111050000010003333330
X04000000000000005000000000000000
X04000000000000005000000003000030
X04000000000000005000000003000030
X04000000000000005000000003000030
X04000000000000005000000003000030
X04000000000000000500000003000030
X04000000000000000500000003333330
X04000000000000000000000000000000
X04000000000000000000000000000000
l   60   32    32   12
X00000000000000000000000000000040
X00000000000000000000000000000040
X03333330000000500000000000000040
X03000030000000500000000000000040
X03000030000000050000000000000040
X03000030000000050000000000000040
X03000030000000050000000000000040
X03000030000000050000000000000040
X00000000000000050000000000000040
X03333330001000005011110000000040
X03000030001000005111111000000040
X03000030001100001111011000000040
X03000030000110011100001100000040
X03000030000011011000001100000040
X03000030000001110500001100000040
X00000000000000100500001100000040
X03333330000000000500001100000040
X03000030000000000555501100000040
X03000030000000000555001100000040
X03000030000000005555001100000040
X03000030000000005550001100000040
X03000030000000000000001100000040
X00000000000000000000011000000040
X33333330000000000000011000000040
X00030030000000000000111000000040
X00030030000000000000111000000040
X00030030000000000000000000000040
X00030030000000000000000000000040
X00003330000000000000000000000040
X00000000000000000000000000000040
X00000000000000000000000000000040
X44444444444444444444444444444440
c 10
A 4
X0000 0000
X0000 6000
X6000 6000
X6000 0000
c 11
A 4
X0500 0500
X0500 2000
X2000 2000
X2000 0500
c 12
o -2400 -2000
A 4
X0500 0500
X2000 2000
X0500 2000
X2000 0500
END_OF_FILE
if test 3984 -ne `wc -c <'Vplot_Kernel/filters/Tests/TEST_pattern'`; then
    echo shar: \"'Vplot_Kernel/filters/Tests/TEST_pattern'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/Tests/TEST_pattern'
fi
if test -f 'Vplot_Kernel/filters/genlib/genmarker.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/genlib/genmarker.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/genlib/genmarker.c'\" \(4464 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/genlib/genmarker.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/genlib/genmarker.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X *
X * Joe Dellinger, Dec 7 1987
X *	Fixed a bug that caused markers >127 and (>6 and <19)
X *	not to be drawn.
X * Joe Dellinger Feb 28 1988
X *	Even if size is zero still plot a point.
X */
X
X#include "../include/params.h"
X#include <stdio.h>
X#include <math.h>
X#include <vplot.h>
X#include "../include/enum.h"
X#include "../include/extern.h"
X#include "../include/round.h"
X
genmarker (npts, type, size, pvec)
X    int             npts, type, size;
X    int            *pvec;
X{
int             savetxfont, savetxprec, savetxovly, savefat;
struct txalign  savealign;
extern float    fatmult_orig;
char            txbuf[10];
char           *txbuffer = txbuf;
X
X    savealign.hor = txalign.hor;
X    savealign.ver = txalign.ver;
X
X    savetxfont = txfont;
X    savetxprec = txprec;
X    savetxovly = txovly;
X    savefat = fat;
X
X/*
X * If it's shrunk away to nothing, plot it as a point.
X * Gentext eats zero-size text.
X */
X    if (size == 0)
X	type = 0;
X
X    fat = (fatmult_orig * size * SYMBFATRATIO);
X    fat += fatmult * (float) fatbase;
X    txalign.hor = TH_SYMBOL;
X    txalign.ver = TV_SYMBOL;
X    txovly = OVLY_NORMAL;
X
X    if ((type > 32) && (type < 127))	/* is it a printing character? */
X    {
X	*txbuffer = (char) (type);
X	*(txbuffer + 1) = '\0';
X	text_marker (txbuffer, size, npts, pvec);
X    }
X    else
X    if (type >= 127)		/* special non-ASCII character */
X    {
X	sprintf (txbuffer, "\\v%d \0", type);
X	text_marker (txbuffer, size, npts, pvec);
X    }
X    else			/* 0 through 5 are pre-defined; 6 through 20
X				 * reserved */
X    {
X	switch (type)
X	{
X	case 0:
X	case 1:
X	    while (npts--)
X	    {
X		dev.point (*pvec, *(pvec + 1));
X		pvec += 2;
X	    }
X	    break;
X	case 2:		/* '+' */
X	    txfont = MATH;
X	    *txbuffer = (char) 57;
X	    *(txbuffer + 1) = '\0';
X	    text_marker (txbuffer, size, npts, pvec);
X	    break;
X	case 3:		/* '*' */
X	    txfont = MATH;
X	    *txbuffer = (char) 33;
X	    *(txbuffer + 1) = '\0';
X	    text_marker (txbuffer, size, npts, pvec);
X	    break;
X	case 4:		/* circle */
X	    txfont = MISC;
X	    *txbuffer = (char) 105;
X	    *(txbuffer + 1) = '\0';
X	    text_marker (txbuffer, size, npts, pvec);
X	    break;
X	case 5:		/* 'X' */
X	    txfont = MATH;
X	    *txbuffer = (char) 60;
X	    *(txbuffer + 1) = '\0';
X	    text_marker (txbuffer, size, npts, pvec);
X	    break;
X	case 20:		/* square */
X	    txfont = MISC;
X	    *txbuffer = (char) 72;
X	    *(txbuffer + 1) = '\0';
X	    text_marker (txbuffer, size, npts, pvec);
X	    break;
X	case 21:		/* triangle */
X	    txfont = MISC;
X	    *txbuffer = (char) 73;
X	    *(txbuffer + 1) = '\0';
X	    text_marker (txbuffer, size, npts, pvec);
X	    break;
X	case 22:		/* diamond */
X	    txfont = MISC;
X	    *txbuffer = (char) 74;
X	    *(txbuffer + 1) = '\0';
X	    text_marker (txbuffer, size, npts, pvec);
X	    break;
X	case 23:		/* star */
X	    txfont = MISC;
X	    *txbuffer = (char) 75;
X	    *(txbuffer + 1) = '\0';
X	    text_marker (txbuffer, size, npts, pvec);
X	    break;
X	default:
X	    while (npts--)
X	    {
X		dev.point (*pvec, *(pvec + 1));
X		pvec += 2;
X	    }
X	    break;
X	}
X    }
X
X    txalign.hor = savealign.hor;
X    txalign.ver = savealign.ver;
X    txfont = savetxfont;
X    txprec = savetxprec;
X    txovly = savetxovly;
X    fat = savefat;
X
X    return (0);
X}
X
text_marker (txbuffer, size, npts, pvec)
X    char           *txbuffer;
X    int             size, npts;
X    int            *pvec;
X{
X
X    while (npts--)
X    {
X	xold = *pvec;
X	yold = *(pvec + 1);
X	if (txfont < NUMGENFONT)
X	{
X	    gentext (txbuffer,
X	    /* Character path direction */
X		     (float) size * aspect_ratio,
X		     (float) 0,
X	    /* Character up vector direction */
X		     (float) 0,
X		     (float) size);
X	}
X	else
X	{
X	    dev.text (txbuffer,
X	    /* Character path direction */
X		      (float) size * aspect_ratio,
X		      (float) 0,
X	    /* Character up vector direction */
X		      (float) 0,
X		      (float) size);
X	}
X	pvec += 2;
X    }
X}
END_OF_FILE
if test 4464 -ne `wc -c <'Vplot_Kernel/filters/genlib/genmarker.c'`; then
    echo shar: \"'Vplot_Kernel/filters/genlib/genmarker.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/genlib/genmarker.c'
fi
if test -f 'Vplot_Kernel/filters/genlib/genpatarea.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/genlib/genpatarea.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/genlib/genpatarea.c'\" \(4233 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/genlib/genpatarea.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/genlib/genpatarea.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Joe Dellinger, Feb 16 1988
X *	Make number of arguments to dev.attributes and dev.raster consistent.
X */
X
X#include <stdio.h>
X#include "../include/pat.h"
X#include "../include/vertex.h"
X#include "../include/params.h"
X#include "../include/extern.h"
X#include "../include/enum.h"
X#include "../include/attrcom.h"
X
X/* Make the damn modulo function work for negative numbers */
X#define MODULO(A,B)	(((A)>=0)?((A)%(B)):(((A)%(B)+(B))%(B)))
X
X/*
X * This routine turns polygons filled with a pattern into calls to
X * dev.raster. (one line at a time).
X */
extern int      need_devcolor, cur_color;
extern char    *malloc ();
X
genpatarea (npts, head)
X    int             npts;
X    struct vertex  *head;
X{
register int    y, i, ii;
register int    xstr, xend;
int             ncross;
int             vminx, vmaxx, vminy, vmaxy;
struct vertex  *yhead, *v;
int            *crosses;
unsigned char  *rasline;
static int      cur_color_save;
int             color;
X
X/*
X * Save color so we can restore it the last time.
X */
X    cur_color_save = cur_color;
X
X    /*
X     * allocate storage for scan line cross points 
X     */
X    crosses = (int *) malloc ((unsigned) npts * sizeof (int));
X
X    /*
X     * allocate storage for raster line 
X     */
X    rasline = (unsigned char *) malloc ((unsigned) (xwmax - xwmin + 1) * sizeof (unsigned char));
X
X    /*
X     * double link the vertices. (head) is set to the node with the maximum
X     * x-value so that intersect() will not eliminate 'head' while casting
X     * off vertices. 
X     */
X    vminx = head->x;
X    vmaxx = head->x;
X    vminy = head->y;
X    vmaxy = head->y;
X    yhead = head;
X
X    v = head;
X    for (i = 0; i < npts; i++)
X    {
X	if (v->x > vmaxx)
X	{
X	    vmaxx = v->x;
X	}
X	if (v->y > vmaxy)
X	{
X	    vmaxy = v->y;
X	    yhead = v;
X	}
X	if (v->x < vminx)
X	    vminx = v->x;
X	if (v->y < vminy)
X	    vminy = v->y;
X	v++;
X    }
X
X    if (vmaxx > xwmax)
X	vmaxx = xwmax;
X    if (vminx < xwmin)
X	vminx = xwmin;
X    if (vmaxy > ywmax)
X	vmaxy = ywmax;
X    if (vminy < ywmin)
X	vminy = ywmin;
X
X    if ((pat[ipat] .ydim > 0) && (pat[ipat] .xdim > 0))
X    {
X	/* stretch polygon in y-direction */
X	v = yhead;
X	do
X	{
X	    v->y = 2 * (v->y) + 1;
X	    v = v->next;
X	} while (v != yhead);
X
X	for (y = vminy; y <= vmaxy; y++)
X	{
X	    ncross = intersect (2 * y, crosses, yhead, 1);
X	    sort (crosses, ncross);
X	    for (i = 0; i < ncross; i += 2)
X	    {
X		xstr = crosses[i];
X		xend = crosses[i + 1];
X
X		if (xstr < xwmin && xend < xwmin)
X		    continue;
X		if (xstr > xwmax && xend > xwmax)
X		    continue;
X
X		if (xstr < xwmin)
X		    xstr = xwmin;
X		if (xend > xwmax)
X		    xend = xwmax;
X
X		if (pat[ipat] .xdim == 1)
X		{
X/* Faster to fill it with one vector */
X		    color =
X		     pat[ipat] .patbits[
X					((pat[ipat] .ydim - 1) - (MODULO (y, pat[ipat] .ydim))) * pat[ipat] .xdim
X		     ];
X		    if (cur_color != color || need_devcolor)
X		    {
X			cur_color = color;
X			dev.attributes (SET_COLOR, cur_color, 0, 0, 0);
X			need_devcolor = NO;
X		    }
X		    dev.vector (xstr, y, xend, y, 0, 0);
X		}
X		else
X		{
X		    for (ii = xstr; ii <= xend; ii++)
X		    {
X			rasline[ii - xstr] =
X			 pat[ipat] .patbits[
X					    ((pat[ipat] .ydim - 1) - (MODULO (y, pat[ipat] .ydim))) * pat[ipat] .xdim
X					    + MODULO (ii, pat[ipat] .xdim)
X			 ];
X		    }
X		    if (xstr <= xend)
X			dev.raster (0, 1, xstr, y, xend - xstr + 1, 0, rasline, 0, 0);
X		}
X	    }
X	}
X	/* shrink in y */
X	v = yhead;
X	do
X	{
X	    v->y = ((v->y - 1) / 2);
X	    v = v->next;
X	} while (v != yhead);
X    }
X
X    free ((char *) rasline);
X    free ((char *) crosses);
X
X    if (cur_color != cur_color_save)
X    {
X	cur_color = cur_color_save;
X	need_devcolor = YES;
X    }
X}
END_OF_FILE
if test 4233 -ne `wc -c <'Vplot_Kernel/filters/genlib/genpatarea.c'`; then
    echo shar: \"'Vplot_Kernel/filters/genlib/genpatarea.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/genlib/genpatarea.c'
fi
if test -f 'Vplot_Kernel/filters/genlib/genraster1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/genlib/genraster1.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/genlib/genraster1.c'\" \(4682 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/genlib/genraster1.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/genlib/genraster1.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Joe Dellinger Feb 16 1988
X *	Make number of arguments consistent between smart and dumb forms
X *	of dev.raster.
X */
X
X#include <stdio.h>
X#include "../include/extern.h"
X#include "../include/enum.h"
X#include "../include/attrcom.h"
X#include "../include/params.h"
X
X#define	MAXMEM 200000
X#define OFF 0
X#define ON 1
X
extern int      overlay, cur_color, need_devcolor, num_col_8;
extern char    *malloc ();
X/*
X * Less than or equal to this, better to use point mode 
X */
int             break_point = 4;
X
X/*
X * A more efficient genraster version for devices that can draw a
X * string of points quickly. Break the plot up by color, and by
X * points and vectors.
X */
X
genraster1 (count, out_of, xpos, ypos, length, orient, raster, dummy1, dummy2)
X    int             count, out_of, xpos, ypos, length, orient, dummy1, dummy2;
X    unsigned char  *raster;
X{
int             ii, jj, yy, kk, ll;
int             xstart, state;
static int      cur_color_save;
static int      num_lines;
static unsigned char *array;
static int      ylength, ystart, jstart;
static int      color_used[MAX_COL + 1];
int             xsign, ysign, xy, xrpos, yrpos;
X
X    switch (orient)
X    {
X    case 0:
X	xrpos = xpos;
X	yrpos = ypos;
X	xsign = 1;
X	ysign = 1;
X	xy = 0;
X	break;
X    case 1:
X	xrpos = ypos;
X	yrpos = xpos;
X	xsign = -1;
X	ysign = 1;
X	xy = 1;
X	break;
X    case 2:
X	xrpos = xpos;
X	yrpos = ypos;
X	xsign = -1;
X	ysign = -1;
X	xy = 0;
X	break;
X    case 3:
X	xrpos = ypos;
X	yrpos = xpos;
X	xsign = 1;
X	ysign = -1;
X	xy = 1;
X	break;
X    }
X
X    if (count == 0)
X    {
X	/*
X	 * First time remember the color so we can restore it the last time. 
X	 */
X	cur_color_save = cur_color;
X
X	/*
X	 * Also find out how many lines we can do at once. 
X	 */
X	num_lines = MAXMEM / length;
X	if (num_lines < 1)
X	    num_lines = 1;
X	array = (unsigned char *) malloc ((unsigned) num_lines * length * sizeof (unsigned char));
X	/*
X	 * See whether we need to do color 0 or not 
X	 */
X	jstart = 0;
X	if (overlay == 1)
X	    jstart = 1;
X    }
X
X    if (ylength == 0)
X    {
X	/*
X	 * Just starting a block. Remember where it is. 
X	 */
X	ystart = yrpos;
X	for (ii = 0; ii <= num_col_8; ii++)
X	{
X	    color_used[ii] = 0;
X	}
X    }
X
X/*
X * Save it.
X */
X    for (ii = 0; ii < length; ii++)
X    {
X	array[length * ylength + ii] = raster[ii];
X	color_used[raster[ii]] = 1;
X    }
X    ylength++;
X
X    if (ylength >= num_lines || count == out_of - 1)
X    {
X/*
X * Plot it. Loop by color
X */
X
X	need_devcolor = NO;
X
X	for (kk = 0; kk < 2; kk++)
X	{
X/*
X * For maximum efficiency of output, better to have the kk loop
X * inside the jj loop. However, while watching on the screen better
X * to have "most important" stuff come out first.
X */
X	    for (jj = jstart; jj < num_col_8; jj++)
X	    {
X		if (color_used[jj] == 0)
X		    continue;
X
X		cur_color = jj;
X		dev.attributes (SET_COLOR, cur_color, 0, 0, 0);
X
X		for (yy = 0; yy < ylength; yy++)
X		{
X		    state = OFF;
X		    for (ii = 0; ii <= length; ii++)
X		    {
X			if (ii != length && array[length * yy + ii] == jj && state == OFF)
X			{
X			    xstart = xrpos + xsign * ii;
X			    state = ON;
X			    continue;
X			}
X			if ((ii == length || array[length * yy + ii] != jj) && state == ON)
X			{
X			    switch (kk)
X			    {
X			    case 0:
X				if (xsign * (xrpos + xsign * ii - xstart) > break_point)
X				{
X				    if (xy)
X					dev.vector (ystart - ysign * yy, xstart, ystart - ysign * yy, xrpos + xsign * (ii - 1), 0, 0);
X				    else
X					dev.vector (xstart, ystart - ysign * yy, xrpos + xsign * (ii - 1), ystart - ysign * yy, 0, 0);
X				}
X				break;
X			    case 1:
X				if (xsign * (xrpos + xsign * ii - xstart) <= break_point)
X				{
X				    for (ll = 0; ll < xsign * (xrpos + xsign * ii - xstart); ll++)
X				    {
X					if (xy)
X					    dev.point (ystart - ysign * yy, xstart + xsign * ll);
X					else
X					    dev.point (xstart + xsign * ll, ystart - ysign * yy);
X				    }
X				}
X				break;
X			    }
X			    state = OFF;
X			}
X		    }
X		}
X
X	    }
X	}
X	ylength = 0;
X	if (count == out_of - 1)
X	{
X	    free ((char *) array);
X	    if (cur_color != cur_color_save)
X	    {
X		cur_color = cur_color_save;
X		need_devcolor = YES;
X	    }
X	}
X    }
X}
END_OF_FILE
if test 4682 -ne `wc -c <'Vplot_Kernel/filters/genlib/genraster1.c'`; then
    echo shar: \"'Vplot_Kernel/filters/genlib/genraster1.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/genlib/genraster1.c'
fi
if test -f 'Vplot_Kernel/filters/loclib/getpar.mn' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/loclib/getpar.mn'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/loclib/getpar.mn'\" \(4757 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/loclib/getpar.mn' <<'END_OF_FILE'
X.TH GETPAR 9
X.SH NAME
getpar \-  parse input parameters
X.SH SYNOPSIS
X.B "C Version"
X.br
X.sp
X.B "getpar(name,type,ptr)"
X.br
X.B "char *name;"
X.br
X.B "char *type;"
X.br
X.B "union { char *s; int  *i; float *f; } ptr;"
X.br
X.sp
X.B "F77 Version"
X.br
X.sp
X.B "getpar(name,type,var)"
X.br
X.B "character*1 name()"
X.br
X.B "character*1 type"
X.br
X.B "real var"
or
X.B "integer var"
or
X.B "character*1 var()"
X.SH DESCRIPTION
X.I Getpar
is a routine to handle input parameters in a manner which is similar to
X(but not the same as) the old Fortran namelists.
The arguments, in the form
X.B name=value,
are normally taken from the command line.
If in the command line the argument
X.I "par=filename"
is encountered, then
X.I filename
is searched in addition.
Any number of such diversions may occur on a given command line.
X.PP
On the first invocation of
X.B getpar(),
all
X.B name=value
pairs are read from the command line and from par files
and stored in a hashed list, and the requested value is returned.
Subsequent calls return the values directly from the hashed list.
X.PP
The typical use of getpar is given by the following example
X.RS
X.PP
X.nf
X/* set defaults */
float x = 1.2345;
int ix  = 7;
char title[25] = "no title";
int xargc; char **xargv;
main(ac,av)
int ac; char **av;
X   {
X	/* set up external values */
X	xargc= ac; xargv= av;
X	/* get args (if any) */
X	getpar("title","s",title);
X	getpar("x","f",&x);
X	getpar("ix","d",&ix);
X	etc.....
X   }
X
X
X	real x/1.2345/
X	integer ix/7/
X	character*1 title(25)/'no title'/
X	character*1 str/'s'/, int/'i'/, flt/'f'/
X	call getpar('title',str,title);
X	call getpar('x',flt,x)
X	call getpar('ix',int,ix)
X	etc....
X.fi
X.RE
The argument
X.I name
is the name the variable is known by externally (i.e., on the command line).
The user also has the option of giving more than one name for a variable.
For example,
X.RS
X.nf
X	getpar("in input infile", "s", file)
X.fi
X.RE
will search for the variables "in", "input", and "infile" on the
command line.
If the command line has any of these variables list in name,
then it will return the string.
The variables are searched in the order they are listed in the string
X.I name.
If the variable is listed twice
on the command line, only the last instance will be returned by a call to
X.I getpar().
For example, if the command line had
X.RS
X.nf
X	in=temp n1=65 n4=901 data=s input=test
X.fi
X.RE
and the
X.I getpar
listed above were used, then
X.I file
would be set to
X.I test.
This is because the
X.I input
on a command line has priority over the
X.I in
because the
X.I input
comes after the
X.I in
in the command line.
The order of variables in the
X.I name
string does not affect the priority.
The variables in the string
X.I name
can be separated by blanks, commas, colons, or semicolons.
X.I Type
specifies the interpretation to be applied to the value of the
variable.
The following types are currently defined
X.RS
X.PP
X.nf
X"s" - string
X"d" - integer (long)
X"f" - float
X"g" - double
X"1" - boolean (accepts y/n or 1/0 and returns an int)
X.fi
X.RE
The variable
X.I ptr
is a pointer to the location of the parameter value.
If no occurrence of the parameter is found then the contents of
X.I ptr
are unchanged.
Thus defaults can be set in advance of parsing.
X.PP
X.I Getpar
returns the number of occurrences of the variable found.
Thus if a particular variable must be assigned then the
appropriate usage is
X.RS
X.nf
if(getpar("title","s",title)==0) {
X	fprintf(stderr,"must specify title\\n");
X	exit(-1);
X}
X.fi
X.RE
X.PP
The format for a parameter is
X.I "name=value".
X.I Name
is the name of the variable and
X.I value
is its value in one of the formats mentioned above.
No interbedded blanks are allowed.
The arguments may be in any order.
X.PP
Integer and floating point vectors may also be input by the construction
X.I "name=value1,value2,value3,...".
Only use this form of input if the program is expecting a vector or else
you will probably overwrite some variable or cause a memory fault.
X.PP
In the parameter files individual parameter specifications
are separated from each other by any number of blanks, tabs, or
newlines.
Any line that begins with a # is a comment line, and is ignored.
Character strings with blanks or tabs can be delimited with
quotes (') or double quotes (").
X.SH BUGS
The current implementation is complicated.
It is, however, well structured and easily extensible.
X.SH "AUTHOR"
Robert W. Clayton developed getpar while in the
Geophysics Department at Stanford University.
He was last seen at Cal Tech.
He welcomes free and widespread distribution. -JFC
The option of having multiple variables in the
X.I name
string was added by Ron Ullmann, Dec. 2, 1982.
More thanks to R. W. Clayton for the fast, hashed version of
X.B getpar.
X.SH "SEE ALSO"
seplib(9), fetch(9s), getch(9s), getch2(9s), hetch(9s)
END_OF_FILE
if test 4757 -ne `wc -c <'Vplot_Kernel/filters/loclib/getpar.mn'`; then
    echo shar: \"'Vplot_Kernel/filters/loclib/getpar.mn'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/loclib/getpar.mn'
fi
echo shar: End of archive 12 \(of 24\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
