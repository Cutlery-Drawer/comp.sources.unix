Subject:  v14i018:  Device-independant graphics system, with drivers
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Joe Dellinger <joe@hanauma.STANFORD.EDU>
Posting-number: Volume 14, Issue 18
Archive-name: vplot/part13

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 24)."
# Wrapped by rsalz@fig.bbn.com on Fri Mar 25 11:47:20 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Imagen_device/imaglib/imagopen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imagen_device/imaglib/imagopen.c'\"
else
echo shar: Extracting \"'Imagen_device/imaglib/imagopen.c'\" \(5164 characters\)
sed "s/^X//" >'Imagen_device/imaglib/imagopen.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/imaglib/imagopen.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Stew Levin (SEP), July 2, 1987
X *	Added ncopies= command line option.
X */
X
X/*
X * get Imagen specific parameters and go
X */
X#include <stdio.h>
X#include "../include/err.h"
X#include "../include/enum.h"
X#include "../include/extern.h"
X#include "../include/params.h"
X
X#define BRUTE_DEFAULT YES
X
X#ifdef SEP
X#define GETPAR fetch
X#else
X#define GETPAR getpar
X#endif
X
int             file_created = NO;
int             stripped = NO;
int             tex = NO;
int             brute_force = BRUTE_DEFAULT;
int             ncopies_document = 1;
char            label[100];
char            string[80];
X
char            mapfile[100] = "default";
char            holdreason[100];
char            scratch_file[100];
X
X/*
X * The option "strip=y" was created for use with TEX, allowing plots
X * to be included with text. The output is not indented, does not have
X * any job control information at the start, has no erases, no "end of
X * form" marker at the end, and does not attempt to put in a label.
X * The option "tex=y" does everything that strip does but also rotates
X * the coordinates (as appropriate for dviimp), and saves and restores
X * all settings. "hold=reason" to insert document control to tell the
X * imagen not to print the job until a "release jobs" (rj) is issued
X * at the imagen control console.  This makes it easier to insert
X * special paper for example.
X */
X
imagopen ()
X{
char            name[50];
char            date[50];
X
X/*
X * physical device parameters
X */
X    dev_xmin = 45;
X    dev_ymin = 90;
X    pixels_per_inch = 300.;
X    aspect_ratio = 1.0;
X
X/*
X * device capabilities
X */
X    need_end_erase = YES;
X    buffer_output = YES;
X    smart_clip = NO;
X    num_col = 0;
X    mono = 1;
X    dither = 3;
X    pixc = 0.6;
X    greyc = -0.5;
X
X/* Since this is a hard copy device, might as well use a nice font */
X    txfont = DEFAULT_HARDCOPY_FONT;
X    txprec = DEFAULT_HARDCOPY_PREC;
X
X    if (!GETPAR ("label", "s", label))
X    {
X	getname (name);
X	getdate (date);
X	sprintf (label, "%s, %s", name, date);
X    }
X    else
X    {
X	if ((strcmp (label, "no") == 0) || (strcmp (label, "n") == 0)
X	    || (strcmp (label, " ") == 0) || (strcmp (label, "") == 0))
X	    label[0] = '\0';
X    }
X
X    if (isatty (fileno (pltout)))
X    {
X	file_created = YES;
X	sprintf (scratch_file, "%s%s", IPEN_SPOOL, "/Impress_XXXXXX");
X	mktemp (scratch_file);
X	pltout = fopen (scratch_file, "w");
X	if (pltout == NULL)
X	{
X	    ERR (FATAL, name, "could not open scratch file %s!",
X		 scratch_file);
X	}
X    }
X
X    if (GETPAR ("paper", "s", string))
X    {
X	if (strcmp (string, "legal") == 0)
X	{
X	    dev_xmax = 4032 - 20;
X	    dev_ymax = 2416 - 1;
X	}
X	else
X	if (strcmp (string, "letter") == 0)
X	{
X	    dev_xmax = 3296 - 20;
X	    dev_ymax = 2416 - 1;
X	}
X	else
X	{
X	    ERR (FATAL, name, "don't recognize paper type %s!", string);
X	}
X    }
X    else
X    {
X	/* letter */
X	dev_xmax = 3296 - 20;
X	dev_ymax = 2416 - 1;
X    }
X
X    if (GETPAR ("tex", "s", string))
X    {
X	if ((string[0] == 'y') || (string[0] == 'Y'))
X	    stripped = YES;
X    }
X    else
X    if (GETPAR ("strip", "s", string))
X    {
X	if ((string[0] == 'y') || (string[0] == 'Y'))
X	    stripped = YES;
X    }
X
X    if (stripped == YES)
X    {
X	/* Don't leave space at edge of plot */
X	dev_xmax -= dev_xmin;
X	dev_xmin = 0;
X/*
X * Make plotting surface big enough that no matter which way they
X * may use the plot, nothing will be clipped. The imagen is SUPPOSED
X * to be able to handle stuff going off the page anyway.
X */
X	dev_ymax = dev_xmax;
X	dev_ymin = dev_xmin;
X
X	/* TEX shifts plot 1 inch to the right; undo this */
X	dev_xmax -= 300;
X	dev_xmin -= 300;
X
X	/* Turn off label */
X	label[0] = '\0';
X    }
X    else
X    {
X	if (GETPAR ("brute", "s", string))
X	{
X	    if ((string[0] == 'n') || (string[0] == 'N'))
X		brute_force = NO;
X	    else
X		brute_force = YES;
X	}
X    }
X
X    if (!GETPAR ("hold", "s", holdreason))
X    {
X	holdreason[0] = '\0';
X    }
X
X    if (!GETPAR ("ncopies copies", "i", &ncopies_document))
X    {
X	ncopies_document = 1;
X    }
X
X    epause = 0;
X    endpause = NO;
X    size = ABSOLUTE;
X}
X
X
X/*
X * get the login name of the person running the program.
X */
getname (name)
X    char           *name;
X{
char            line[100];
int             i;
X    getpw (getuid (), line);
X    i = 0;
X    while ((name[i] = line[i]) != ':')
X	i++;
X    name[i] = '\0';
X}
X
X/*
X * get the date
X */
X#include <sys/time.h>
getdate (date)
X    char           *date;
X{
long            time ();
long            clock;
struct tm      *localtime ();
char           *asctime ();
X
X    clock = time (0);
X    sprintf (date, "%.16s", asctime (localtime (&clock)));
X}
END_OF_FILE
if test 5164 -ne `wc -c <'Imagen_device/imaglib/imagopen.c'`; then
    echo shar: \"'Imagen_device/imaglib/imagopen.c'\" unpacked with wrong size!
fi
# end of 'Imagen_device/imaglib/imagopen.c'
fi
if test -f 'Imagen_device/imaglib/ipen.mn' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imagen_device/imaglib/ipen.mn'\"
else
echo shar: Extracting \"'Imagen_device/imaglib/ipen.mn'\" \(5710 characters\)
sed "s/^X//" >'Imagen_device/imaglib/ipen.mn' <<'END_OF_FILE'
X.TH Ipen 9 "April 6 1986"
X.SH NAME
ipen \- VPLOT filter for Imagen
X.PP
X.SH SYNOPSIS
ipen  plot_file1 [plot_file2 ...] [options]
X.PP
Seplib version: Ipen < Plot1.h [Plot2.h ...] [options]
X.PP
X.SH DESCRIPTION
All
X.B pen
filters accept input in the
X.B vplot
graphical metalanguage, and either cause a
plot to appear on a device or write a file which if sent to that device will
create a plot.
X.B Ipen
is the filter for the Imagen 8/300 laser printer.
It translates from vplot
to the imPRESS language understood by the printer.
If called without
redirected output, it creates a temporary file with a unique name,
spools the plot,
and removes the temporary file upon exiting.
The location and name of the temporary file are set when ipen
is compiled, by editing an include file.
If the output is redirected,
the imPRESS output is written to standard out (or to out= for Seplib)
and no spooling is done.
X.PP
X.SH OPTIONS
X.PP
Only Imagen-specific options are covered here.  For a list of all generic
pen options, which also apply to ipen, do ``man 9 pen''.
X.PP
X.TP 
X.B paper=letter
Paper size.  Paper=legal is also possible.
X.PP
X.TP
X.B label=string
By default, plots are labeled with the username of the person making the plot
and the time and date.  This can be replaced with some other label by using
this option.  The label may obscure part of the plot, as it whites out
a rectangle in the area it will occupy before writing text over it.
X.B label=``''
or
X.B label=no
turns off the label and the white-out rectangle.
X.PP
X.TP
X.B strip=no tex=no
If strip=y, then the output imPRESS file has no label or document control
language prepended, and additional imPRESS commands to save and restore
the Imagen state are prepended and appended to the file.
This makes the output imPRESS
file useful for inclusion into a paper via the `plot' macro of TeX.
This allows your figures and text to come out of the machine together, and
eliminates cutting and pasting.
X(TeX is a typesetting language similar to, but newer than, troff.  Troff
can also be used in a similar manner, but nobody has bothered to figure out
how).
X.PP
X.TP
X.B brute=y
The Imagen is quite buggy, and complicated plots will give it a nervous
breakdown, which results in it chopping up your plot into little pieces
and scattering them through the next person's Imagen output.  Imagen seems
incapable of fixing this very serious bug.
The current version of the Imagen operating system has a special document
control language option which turns on a brute-force rasterization technique,
which seems to avoid this bug.  The
X.B brute=y
option of ipen turns this on,
which also has the effect of slightly slowing down the printing of the plot.
It's worth it, though!
X.PP
X.TP
X.B hold=message
This parameter tells the Imagen to print the message on the Imagen control
console and wait for the ``rj'' (Release Job) command to be issued at the
console.   Typical usage is hold=``insert transparency''.
X.PP
X.TP
X.B ncopies=1
This parameter is used to save time and effort by printing multiple
copies of the plot on the Imagen.
X.PP
X.TP
X.B dither=3
Dithering is a means of representing a continuous-tone grey image on a
hardcopy device such as the Imagen.  The default dithering method is the
minimized average error algorithm.  See the Vplotraster manual page
for a complete discussion of dithering options.
X.PP
X.TP
X.B greyc=-0.5
This parameter applies only when using dithering as described above.
Greyc is discussed in the Pen manual page and more thoroughly
in the Vplotraster manual page.  To repeat some of the discussion found
elsewhere, grey scale reproduction on a hardcopy device is quite different
from that on a display device.  The transition from black to white occurs
more abruptly on a display device, leaving both ends of the grey scale
clipped at black or white.  This nonlinearity in the perceived grey scale
is a useful feature that can be simulated on the Imagen using the greyc
parameter.  Greyc=-0.5 seems to give grey scale reproduction on the Imagen
comparable to many graphics displays, though further experimentation might
be required to bring the Imagen output into agreement with a particular
device.  greyc=1. disables this correction.
See the
X.B vplotraster
manual page for more details.
X.PP
X.TP
X.B pixc=0.6
Pixc also applies only when using dithering as described above. 
Grey rasters seem significantly darker when plotted on the Imagen than
when displayed on a graphics screen.  Assuming that this darkening is
caused by the overlapping of dots on the Imagen, this parameter compensates
for that overlap by shifting the grey color scale toward white. 
Pixc=0.6 seems to give greyscale reproduction on the Imagen that is
comparable to many graphics displays.
pixc=1. disables this correction.
See the Vplotraster manual page for more details.
X.SH SEE ALSO
vppen, pen, vplot, vplotraster
X.PP
X.SH COPYRIGHT
The Vplot source is copyrighted. Please read the copyright which can be
found in the accompanying Vplot manual page.
X.PP
X.SH AUTHOR
The device-dependent code of Ipen was written by Joe Dellinger, although
persons unknown seem to have also made some minor changes to it.
Stew Levin has fixed some bugs and added some options.
Doug Wilson wrote most of imagpoly.c.
X.PP
X.SH BUGS
The code for ipen is quite complicated, but much of the complexity
is to work around various Imagen hardware bugs in software.
You should try to draw raster blocks as the first things on the imagen,
as the imagen may erase a little beyond the background of the
raster block if the overlay mode is ``no''. There's no easy way to
correct for this imagen limitation in software.
In order to use the brute=y option you have to pay for extra memory
on the Imagen.
END_OF_FILE
if test 5710 -ne `wc -c <'Imagen_device/imaglib/ipen.mn'`; then
    echo shar: \"'Imagen_device/imaglib/ipen.mn'\" unpacked with wrong size!
fi
# end of 'Imagen_device/imaglib/ipen.mn'
fi
if test -f 'Vplot_Kernel/filters/Tests/libvplot_example.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/Tests/libvplot_example.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/Tests/libvplot_example.c'\" \(5043 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/Tests/libvplot_example.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/Tests/libvplot_example.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X#include    <math.h>
X#include    <vplot.h>
X#include    <stdio.h>
X
X/*
X * Sample program to demonstrate simple libvplot usage.
X *      Excerpted from 'legend.c', by C. R. Karish:
X *      format entries for a legend for a geologic map.
X *  To compile:
X *      cc -o example vplot_example.c -lvplot -lm
X *  To run:
X *      example < infile > outfile
X *      tube outfile
X *  Sample input:       (remove asterisks)
X *      unit "Qa"  "Quaternary alluvium"
X *      unit "Tb"  "Tertiary basalt"
X *      unit "Kg"  "biotite monzogranite"
X *      unit "Krp"  "rhyolite porphyry"
X *      unit "Krd"  "biotite rhyodacite"
X */
X
X/*
X * external parameters, used by many subroutines
X */
float           boxsz[2];	/* size of the symbol box, in inches */
float           tab[2];	/* locations of tab stops, in inches */
int             charsz;	/* text size used for explanations (in vplot size
X			 * units) */
float           vspace;	/* vertical spacing for rock unit entries */
float           vpos;	/* present location on the page (inches) */
X
main ()
X{
char            command[30], line[125], symbol[30], text[90];
int             count;
X
X    /*
X     * set global geometric parameters 
X     */
X
X    vpos = 10.3;		/* start at 10.3 inches from bottom of page */
X    vspace = 0.90;		/* base line spacing = 0.90 inches */
X    charsz = 10;		/* default text size = .30 inches */
X    boxsz[0] = 1.0;		/* default box: 1.0 x 0.70 inches */
X    boxsz[1] = 0.70;
X    tab[0] = 1.0;		/* default tabs: 1.0 and 3.5 inches */
X    tab[1] = 3.5;
X
X    /*
X     * set up a vplot output stream and coordinate system 
X     */
X    vp_filep (stdout);		/* initialize pc structure and open stream */
X    vp_style (STANDARD);	/* origin at lower left; y axis vertical */
X    vp_clip (0., 0., 8.5, 11.0);/* set clipping window */
X    /* (wider than screen!) */
X    vp_tfont (1, STROKE, 0);	/* use Roman simplex, full precision, */
X    /* no special overlay processing */
X    vp_fat ((int) (charsz / 2));/* set line width, scaled to text size */
X    vp_orig (0., 0.);		/* set the user origin to coincide with */
X    /* the device origin (same as default) */
X
X    /*
X     * main loop: read and interpret input file 
X     */
X    while (gets (line) != NULL)
X    {
X	if (sscanf (line, "%s", command) == 0)	/* skip blank lines */
X	    continue;
X	if (command[0] == '#')	/* ... and comments */
X	    continue;
X	if ((count = sscanf (line,	/* parse strings from input */
X			   "%*s \"%[^\"]\" \"%[^\"]\"", symbol, text)) != 2)
X	{
X	    fprintf (stderr, "unit count = %d\n", count);
X	    fprintf (stderr, "%s\n", line);	/* complain if argument */
X	    continue;		/* count is wrong */
X	}
X	mapunit (symbol, text);	/* produce some output */
X    }				/* end of main loop */
X    vp_endplot ();		/* close output stream */
X}
X
mapunit (symbol, text)	/* produce an entry for a map legend */
X    char           *symbol, *text;
X{
X    if (vpos < 1.0)		/* leave 1" bottom margin */
X	feedpage ();
X    vpos -= vspace / 2;		/* space down a half line */
X    if (strcmp (symbol, "nobox"))	/* strcmp==TRUE means `no match' */
X    {
X	drawbox (tab[0], vpos);	/* draw the box */
X	vp_tjust (TH_CENTER, TV_HALF);	/* center the symbol in the box */
X	vp_fat ((int) ((charsz - 1) / 2));	/* pick a good text fatness */
X	vp_text (tab[0] + (boxsz[0] / 2),
X		 vpos, charsz - 1, 0, symbol);	/* write the map symbol */
X    }
X    vp_fat ((int) (charsz / 2));
X    vp_tjust (TH_LEFT, TV_HALF);/* reset left justification */
X    vp_text (tab[1], vpos, charsz, 0, text);	/* write the explanation */
X    vpos -= vspace / 2;		/* space down a half line */
X}
X
X
X/*
X * draw a box, boxsz[0] by boxsz[1] inches, left edge at xpos,
X *      centered vertically at ypos:
X */
X
drawbox (xpos, ypos)
X    float           xpos, ypos;
X{
X    vp_fat ((int) (charsz / 2));/* set linewidth, same as for text */
X    vp_move (xpos, ypos - (boxsz[1] / 2));	/* move to the upper left
X						 * corner */
X    vp_draw (xpos + boxsz[0], ypos - (boxsz[1] / 2));	/* draw it. */
X    vp_draw (xpos + boxsz[0], ypos + (boxsz[1] / 2));
X    vp_draw (xpos, ypos + (boxsz[1] / 2));
X    vp_draw (xpos, ypos - (boxsz[1] / 2));
X}
X
feedpage ()
X{
X    vp_erase ();		/* feed a page, and reset defaults */
X    vp_clip (0., 0., 8.0, 11.0);/* reset our clipping window */
X    vp_tfont (1, STROKE, 0);	/* reset our font */
X    vp_fat ((int) (charsz / 2));/* reset our fatness */
X    vp_orig (0., 0.);		/* reset our origin */
X    vpos = 10.3;		/* start at the top of the page */
X}
END_OF_FILE
if test 5043 -ne `wc -c <'Vplot_Kernel/filters/Tests/libvplot_example.c'`; then
    echo shar: \"'Vplot_Kernel/filters/Tests/libvplot_example.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/Tests/libvplot_example.c'
fi
if test -f 'Vplot_Kernel/filters/genlib/genhatch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/genlib/genhatch.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/genlib/genhatch.c'\" \(5398 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/genlib/genhatch.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/genlib/genhatch.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Joe Dellinger, Feb 16 1988
X *	Make number of arguments to dev.attributes consistent.
X */
X
X#include <stdio.h>
X#include <math.h>
X#include "../include/enum.h"
X#include "../include/vertex.h"
X#include "../include/params.h"
X#include "../include/extern.h"
X#include "../include/attrcom.h"
X
extern int      cur_color;
extern int      need_devcolor;
extern char    *malloc ();
X
genhatch (npts, numhatch, angle, hafat, hacol, haoff, hasiz, head)
X    int             npts, numhatch;
X    struct vertex  *head;
X    float           angle;
X    int            *hafat, *hacol, *haoff, *hasiz;
X{
register int    x, y, i;
int             xstr, xend, ystr, yend, y1, y2, x1, x2, start;
int             xa[4], ya[4], xwmin_r, xwmax_r, ywmin_r, ywmax_r;
int             skip, which_time;
int             ncross;
int             vminx, vmaxx, vminy, vmaxy;
struct vertex  *xhead, *yhead, *v;
int            *crosses;
int             cur_color_save;
X
X    cur_color_save = cur_color;
X
X    v = head;
X    for (i = 0; i < npts; i++)
X    {
X	poly_rot (angle, &v->x, &v->y);
X	v++;
X    }
X
X    /*
X     * allocate storage for scan line cross points 
X     */
X    crosses = (int *) malloc ((unsigned) npts * sizeof (int));
X
X    /*
X     * double link the vertices. (head) is set to the node with the maximum
X     * x-value so that intersect() will not eliminate 'head' while casting
X     * off vertices. 
X     */
X    vminx = head->x;
X    vmaxx = head->x;
X    vminy = head->y;
X    vmaxy = head->y;
X    xhead = head;
X    yhead = head;
X
X    v = head;
X    for (i = 0; i < npts; i++)
X    {
X	if (v->x > vmaxx)
X	{
X	    vmaxx = v->x;
X	    xhead = v;
X	}
X	if (v->y > vmaxy)
X	{
X	    vmaxy = v->y;
X	    yhead = v;
X	}
X	if (v->x < vminx)
X	    vminx = v->x;
X	if (v->y < vminy)
X	    vminy = v->y;
X	v++;
X    }
X
X/*
X * Find a new window which contains the old, rotated window
X */
X    xwmin_r = xa[0] = xa[1] = xwmin;
X    xwmax_r = xa[2] = xa[3] = xwmax;
X    ywmin_r = ya[0] = ya[3] = ywmin;
X    ywmax_r = ya[1] = ya[2] = ywmax;
X    for (i = 0; i < 4; i++)
X    {
X	poly_rot (angle, &xa[i], &ya[i]);
X	if (xwmin_r > xa[i])
X	    xwmin_r = xa[i];
X	if (ywmin_r > ya[i])
X	    ywmin_r = ya[i];
X	if (xwmax_r < xa[i])
X	    xwmax_r = xa[i];
X	if (ywmax_r < ya[i])
X	    ywmax_r = ya[i];
X    }
X
X    if (vmaxx > xwmax_r)
X	vmaxx = xwmax_r;
X    if (vminx < xwmin_r)
X	vminx = xwmin_r;
X    if (vmaxy > ywmax_r)
X	vmaxy = ywmax_r;
X    if (vminy < ywmin_r)
X	vminy = ywmin_r;
X
X    /* stretch polygon in y-direction */
X    v = yhead;
X    do
X    {
X	v->y = 2 * (v->y) + 1;
X	v = v->next;
X    } while (v != yhead);
X
X    for (which_time = numhatch; which_time < 2 * numhatch; which_time++)
X    {
X	if (hasiz[which_time] > 0)
X	{
X	    if (cur_color != hacol[which_time] || need_devcolor)
X	    {
X		cur_color = hacol[which_time];
X		dev.attributes (SET_COLOR, cur_color, 0, 0, 0);
X		need_devcolor = NO;
X	    }
X
X	    skip = hasiz[which_time];
X	    start = haoff[which_time] + skip * (int) (vminy / skip);
X	    for (y = start; y <= vmaxy; y += skip)
X	    {
X		ncross = intersect (2 * y, crosses, yhead, 1);
X		sort (crosses, ncross);
X		for (i = 0; i < ncross; i += 2)
X		{
X		    xstr = crosses[i];
X		    xend = crosses[i + 1];
X		    y1 = y2 = y;
X		    poly_rot (-angle, &xstr, &y1);
X		    poly_rot (-angle, &xend, &y2);
X		    dev.vector (xstr, y1, xend, y2, hafat[which_time], 0);
X		}
X	    }
X	}
X    }
X    /* shrink in y */
X    v = yhead;
X    do
X    {
X	v->y = ((v->y - 1) / 2);
X	v = v->next;
X    } while (v != yhead);
X
X    /*
X     * expand in x 
X     */
X    v = xhead;
X    do
X    {
X	v->x = 2 * v->x + 1;
X	v = v->next;
X    } while (v != xhead);
X
X    for (which_time = 0; which_time < numhatch; which_time++)
X    {
X	if (hasiz[which_time] > 1)
X	{
X	    if (cur_color != hacol[which_time] || need_devcolor)
X	    {
X		cur_color = hacol[which_time];
X		dev.attributes (SET_COLOR, cur_color, 0, 0, 0);
X		need_devcolor = NO;
X	    }
X
X	    skip = hasiz[which_time];
X	    start = haoff[which_time] + skip * (int) (vminx / skip);
X	    for (x = start; x <= vmaxx; x += skip)
X	    {
X		ncross = intersect (2 * x, crosses, xhead, 0);
X		sort (crosses, ncross);
X		for (i = 0; i < ncross; i += 2)
X		{
X		    ystr = crosses[i];
X		    yend = crosses[i + 1];
X		    x1 = x2 = x;
X		    poly_rot (-angle, &x1, &ystr);
X		    poly_rot (-angle, &x2, &yend);
X		    dev.vector (x1, ystr, x2, yend, hafat[which_time], 0);
X		}
X	    }
X
X	}
X    }
X    /*
X     * shrink in x 
X     */
X    v = xhead;
X    do
X    {
X	v->x = ((v->x - 1) / 2);
X	v = v->next;
X    } while (v != xhead);
X
X    free ((char *) crosses);
X
X    if (cur_color != cur_color_save)
X    {
X	cur_color = cur_color_save;
X	need_devcolor = YES;
X    }
X}
X
poly_rot (angle, x, y)
X    float           angle;
X    int            *x, *y;
X{
int             temp;
X    temp = (*x * cos (angle) - *y * sin (angle)) + .5;
X    *y = (*x * sin (angle) + *y * cos (angle)) + .5;
X    *x = temp;
X}
END_OF_FILE
if test 5398 -ne `wc -c <'Vplot_Kernel/filters/genlib/genhatch.c'`; then
    echo shar: \"'Vplot_Kernel/filters/genlib/genhatch.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/genlib/genhatch.c'
fi
if test -f 'Vplot_Kernel/filters/include/attrcom.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/include/attrcom.h'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/include/attrcom.h'\" \(5514 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/include/attrcom.h' <<'END_OF_FILE'
X/*
X * commands to the device's "attributes" routine
X */
X
X#define	SET_COLOR		1
X#define SET_COLOR_TABLE 	2
X#define SET_WINDOW		3
X#define NEW_DASH		4
X#define NEW_PAT			5
X#define NEW_FONT		6
X#define NEW_OVERLAY		7
X#define NEW_ALIGN		8
X#define NEW_FAT			9
X#define BEGIN_GROUP		10
X#define END_GROUP		11
X
X#define DOVPLOT_CONT		0	/* MUST be zero */
X#define DOVPLOT_EXIT		1
X
X/*
X * Uses:
X * Dummy arguments are not used, but should be listed to make some finicky
X * compilers happy, even if you don't use any of the commands that require
X * all 4 arguments. By the same token, you should explicitly declare a
X * return value of 0 even for those calls that don't use the return value.
X *
X * dev.attributes(SET_COLOR, col, dummy1, dummy2, dummy3)
X *
X * Set the current drawing color to col. The device is assumed to
X * start out with the current drawing color 7 = WHITE.
X *
X * dev.attributes(SET_COLOR_TABLE, col, red, green, blue)
X * 
X * Set color number col to have the color (red,green,blue).
X * Red, green, and blue are in the range from 0 to MAX_GUN (255),
X * with 0 being off and MAX_GUN being fully on.
X * Thus, (0,0,0) is black, (128,128,128) is grey, (255,255,255) is white,
X * (255,0,0) is red, (255,255,0) is yellow, etc... The device is assumed
X * to start out with colors 0 through 7 set as in the vplot standard.
X *
X * dev.attributes(SET_WINDOW, xmin, ymin, xmax, ymax)
X *
X * Set current clipping window. (xmin,ymin) is the lower-leftmost
X * displayable point. (xmax,ymax) is the upper-rightmost displayable point.
X * Only necessary to support this if smart_clip=YES, smart_raster=YES, or
X * you don't use a generic routine (genarea) to clip polygons for you.
X * After dev.reset has been called, dovplot assumes that the clipping
X * window is set by the device to the edge of the device's screen.
X * Dev.attributes(SET_WINDOW, ...) will thereafter be called whenever
X * the clipping window is changed from its previous setting. (Thus,
X * if no clipping window is ever set at all, dev.attributes(SET_WINDOW, ...)
X * will never be called.) It is possible for xmin > xmax or ymin > ymax.
X * If this happens everything should be clipped away.
X *
X * dev.attributes(NEW_DASH, dashon, dummy1, dummy2, dummy3)
X *
X * Warn the device that the current dashed line pattern has just
X * been changed. "dashon" is the new value of the external variable
X * dashon. (See the dev.vector documentation.)
X *
X * dev.attributes(NEW_PAT, ipat, dummy1, dummy2, dummy3)
X *
X * Warn the device that raster pattern "ipat" has been defined
X * or redefined. The device does not have to allow re-definition
X * of defined patterns. (See the dev.area documentation for a
X * description of how patterns are stored.)
X *
X * dev.attributes(NEW_FONT, txfont, txprec, txovly, dummy1)
X *
X * Warn the device that the text font, precision, or overlay may have
X * been changed. A value of "-1" means no change from the previous value,
X * which may be a device-dependent default. This form of dev.attributes
X * will be called whenever the user uses the "set text font and precision"
X * vplot command (and only then), so you probably should check to see if
X * anything really changed before bothering the device. Even better,
X * only check these variables at the time that you output hardware text,
X * and don't bother with this option in dev.attributes at all.
X *
X * dev.attributes(NEW_OVERLAY, overlay, dummy1, dummy2, dummy3)
X *
X * Warn the device that the overlay mode may have been changed. Again,
X * most devices will ignore this dev.attributes call, and check the
X * external variable overlay only when they actually need to know what
X * it is.
X *
X * dev.attributes(NEW_ALIGN, txalign.hor, txalign.ver, dummy1, dummy2)
X *
X * Warn the device that the text alignment mode has been changed. Again,
X * most devices will ignore this call and just check the alignment
X * when hardware text is drawn.
X *
X * dev.attributes(NEW_FAT, fat, dummy1, dummy2, dummy3)
X *
X * Warn the device that the fatness has been changed. Again, most devices
X * should ignore this call and just check the fatness before processing
X * any of the 3 things in which it is used: vectors, text, markers.
X * Check the dev.vector documentation for caveats similar to those for
X * the NEW_PAT case.
X *
X * dev.attributes(BEGIN_GROUP, group_number, pos, dummy1, dummy2)
X * dev.attributes(END_GROUP, group_number, dummy1, dummy2, dummy3)
X *
X * extern char group_name[MAXFLEN+1];
X *
X * return iflag
X *
X * Everything between these calls is grouped as one "object".
X * Objects may be nested. Objects may not extend across erases,
X * breaks, or files. The name of the most recently begun object is
X * stored in the external variable group_name. Group_name is defined
X * in extern.h. "group_number" gives the heirarchical order of the
X * object. Each plot frame is itself an object of group number 0.
X * "pos" gives the offset from the start of the file of the start of
X * this object. If "pos" is negative, then the input file is one
X * for which seeks don't work. Dev.attributes(END_GROUP,...) returns
X * "iflag" to tell dovplot what it should do next.
X * If "iflag" is DOVPLOT_CONT (=0), then dovplot should continue exactly
X * as normal. If "iflag" is DOVPLOT_EXIT, then dovplot will exit upon the
X * return of this call. Note that K+R says that failing to declare
X * a return value returns garbage, so you MUST declare a return value
X * for dev.attributes(END_GROUP,...). To help make sure you do this,
X * dovplot will issue a warning message if an unknown return value is
X * given.
X *
X */
END_OF_FILE
if test 5514 -ne `wc -c <'Vplot_Kernel/filters/include/attrcom.h'`; then
    echo shar: \"'Vplot_Kernel/filters/include/attrcom.h'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/include/attrcom.h'
fi
if test -f 'Vplot_Kernel/filters/loclib/getpar_scan.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/loclib/getpar_scan.l'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/loclib/getpar_scan.l'\" \(5332 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/loclib/getpar_scan.l' <<'END_OF_FILE'
X%C
NONWHITE	[^ \t\n]
ALPHA	[A-Za-z]
ALPHANUM	[A-Za-z0-9_-]
TAG	{ALPHA}{ALPHANUM}*=
SQ	\'([^'\n]*\'\')*[^'\n]*['\n]
DQ	\"([^"\n]*\"\")*[^"\n]*["\n]
X%{
X/* lexical scanning for fast getpar */
X/* Revised 3-8-86 stew  Added time stamp to enable older method of handling
X *			multiple tags.  Moved par= intiialization to
X *			separate routine to avoid code duplication.
X */
X#include <ctype.h>
X#include "fastpar.h"
X#undef input
X#define input() ((int) *(input_stack[input_depth]++))
X#undef unput
X/* The redundant  =(c) insures side effects of expressions occur */
X#define unput(c) (*(--(input_stack[input_depth]))=(c))
X#define yywrap() getpar_pop_input()
X#define yylex() getpar_lexscan()
X#define yylook() getpar_yylook()
X
X#define MAX_INPUT_DEPTH 10
static int input_depth = -1;
static char *input_stack[MAX_INPUT_DEPTH];
static char *dealloc_stack[MAX_INPUT_DEPTH];
X
static struct {
X	char *tag;  int tlen;
X	char *val;  int vlen;
X       } yy;
X
X
static int  SMALLBLOCK = 4096;
static char
X*suballoc (size)
int size;
X{
X	static char *myblock = (char *) NULL; static int bytesleft = 0;
X	char *ptr; extern char *alloc();
X
X	if(size > SMALLBLOCK) return(alloc(size));
X	else
X	  { 
X	    if(bytesleft < size)
X	       {
X	        myblock = alloc (SMALLBLOCK);
X		bytesleft = SMALLBLOCK - size;
X	       }
X	   else
X	       {
X		bytesleft -= size;
X	       }
X	   ptr = myblock;
X	   myblock += size;
X	   return(ptr);
X	  }
X}
X
static int  prime[10] = {31,29,23,19,17,13,11,7,5,3};
int getpar_hash(array,len)
register char *array;
register int len;
X{
X  register int hash;
X  register int i;
X  if(len >10) len=10;
X  hash=0;
X  for(i=0; i<len; i++)
X    hash += array[i]*prime[i];
X  return(hash);
X}
X
X/* workhorse to decode par files; shell already parses command line */
getpar_scan(queue,qlen)
register hash_item **queue;
register int qlen;
X{
X extern int yylex();
X
X while(yylex()) {
X	getpar_hash_store(queue,qlen,yy.tag,yy.val,yy.tlen,yy.vlen);
X	if(yy.tlen == 3 && 0 == bcmp(yy.tag,"par",3))
X		getpar_stack_par(yy.val);
X	}
X}
X
X/* read parfile into core and put buffer on scan input stack */
getpar_stack_par(val)
char *val;
X{
X register char *buffer;
X register int fd, len;
X extern int file(), fsize();
X extern char *alloc();
X
X    fd = file(val,0);
X    len = fsize(fd);
X    buffer=alloc(len+3);
X    buffer[0]='\n';
X    read(fd,buffer+1,len);
X    buffer[len+1]='\n';
X    buffer[len+2]='\0';
X    getpar_push_input(buffer,1);
X    close(fd);
X}
X
X /* return 1 if match; 0 otherwise */
X#define getpar_hash_compare(next1,tag1,tlen1)  \
X ((next1)->tlen == (tlen1) && 0 == bcmp((next1)->tag,tag1,tlen1))
X
getpar_hash_store(q,qlen,tag,val,tlen,vlen)
hash_item **q;
register char *tag, *val;
register int tlen;
int qlen, vlen;
X{
X register hash_item *hold, *next;
X static int storetime = 0;
X
X hold=(hash_item *) (q+getpar_hash(tag,tlen)%qlen);
X next=hold->next;
X
X while(next != ((hash_item *) NULL)) {
X	if(getpar_hash_compare(next,tag,tlen) ) {
X		next->val = val; next->vlen = vlen;
X		next->timestamp = storetime++; return;
X		}
X	hold = next; next = next->next;
X	}
X
X hold->next = next = (hash_item *) suballoc(sizeof(hash_item));
X next->next = (hash_item *) NULL;
X next->tlen = tlen;
X next->tag = tag;
X next->vlen = vlen;
X next->val = val;
X next->timestamp = storetime++;
X}
X
hash_item *getpar_hash_lookup(q,qlen,tag,tlen)
register hash_item **q;
register char *tag;
register int tlen;
register int qlen;
X{
X register hash_item *next;
X
X next = *(q + getpar_hash(tag,tlen)%qlen);
X
X while(next != ((hash_item *) NULL) ) {
X	if(getpar_hash_compare(next,tag,tlen)) break;
X	next = next->next;
X	}
X return(next);
X}
X
X%}
X%S FOUNDTAG
X%%
X<FOUNDTAG>{SQ}		{
X			 yy.vlen = yyleng-2; yy.val=suballoc(yy.vlen+1);
X			 yy.vlen = massage(yytext+1,yy.val,yy.vlen,yytext[0]);
X			 yy.val[yy.vlen]='\0'; BEGIN 0; return(FOUNDTAG);
X			 }
X<FOUNDTAG>{DQ}		{
X			 yy.vlen = yyleng-2; yy.val=suballoc(yy.vlen+1);
X			 yy.vlen = massage(yytext+1,yy.val,yy.vlen,yytext[0]);
X			 yy.val[yy.vlen]='\0'; BEGIN 0; return(FOUNDTAG);
X			 }
X<FOUNDTAG>[^'"]{NONWHITE}*	{
X				 yy.vlen=yyleng; yy.val=suballoc(yy.vlen+1);
X		 		 bcopy(yytext,yy.val,yy.vlen+1); BEGIN 0;
X				 return(FOUNDTAG);
X				 }
X^{TAG}/{NONWHITE}	{
X			 yy.tlen=yyleng-1; yy.tag=suballoc(yy.tlen+1);
X			 bcopy(yytext,yy.tag,yy.tlen);
X			 yy.tag[yy.tlen]='\0'; BEGIN FOUNDTAG;
X			 }
X([ \t]{TAG})/{NONWHITE}	{
X			 yy.tlen=yyleng-2; yy.tag=suballoc(yy.tlen+1);
X			 bcopy(yytext+1,yy.tag,yy.tlen);
X			 yy.tag[yy.tlen]='\0'; BEGIN FOUNDTAG;
X			 }
X^\#.*	/* skip comment lines */;
X.	|
X\n	;
X%%
X	getpar_push_input(buffer,dealloc)
X	register char *buffer;
X	register int dealloc;
X	{
X	  if(input_depth++ == MAX_INPUT_DEPTH)
X		err("too many nested par files\n");
X	  input_stack[input_depth] = buffer;
X	  if(dealloc) dealloc_stack[input_depth] = buffer;
X	  else dealloc_stack[input_depth] = (char *) NULL;
X	}
X
X	int
X	yywrap()
X	{
X	  if(((char *) NULL) != dealloc_stack[input_depth]) {
X		free(dealloc_stack[input_depth]);
X		dealloc_stack[input_depth] = (char *) NULL;
X		}
X	  input_stack[input_depth--] = (char *) NULL;
X	  if(input_depth < 0) return(1);
X	  return(0);
X	}
X
X	static int
X	massage(string,out,len,quote)
X	register char *string, *out;
X	register int len, quote;
X	{
X 	register int i,j;
X	
X	for(i=0,j=0; i<len-1; j++) {
X		out[j]=string[i++];
X		if(out[j]==quote) /* compress doubled quotes */
X			if(string[i]==quote) i++;
X		}
X	if(i<len) out[j++] = string[i];
X	return(j);
X	}
END_OF_FILE
if test 5332 -ne `wc -c <'Vplot_Kernel/filters/loclib/getpar_scan.l'`; then
    echo shar: \"'Vplot_Kernel/filters/loclib/getpar_scan.l'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/loclib/getpar_scan.l'
fi
if test -f 'Vplot_Kernel/filters/utilities/dither.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/utilities/dither.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/utilities/dither.c'\" \(5256 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/utilities/dither.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/utilities/dither.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Steve Cole (SEP), September 1 1987
X *      Added method 4 (digital halftoning).
X */
X
X/*
X * this subroutine converts a single raster line to single bit
X * using one of the following algorithms:
X *
X * 1 random threshold
X * 2 256 element ordered dither (oriented at 0 degrees)
X * 3 Floyd-Steinberg minimized average error method
X * 4 32 element halftone (oriented at 45 degrees)
X *
X * Steve Cole, April 1987
X *
X */
X#include <stdio.h>
X#include "../include/err.h"
X#include "../include/params.h"
X#include "../include/extern.h"
static int      pix_on, pix_off;
char           *malloc ();
static float   *errline;
static int      ialloc;
static float    alpha = 0.4375;
static float    beta = 0.1875;
static float    gamma = 0.3125;
static float    delta = 0.0625;
static int      dith256[256] = {
X	1, 128, 32, 160, 8, 136, 40, 168, 2, 130, 34, 162, 10, 138, 42, 170,
X   192, 64, 224, 96, 200, 72, 232, 104, 194, 66, 226, 98, 202, 74, 234, 106,
X     48, 176, 16, 144, 56, 184, 24, 152, 50, 178, 18, 146, 58, 186, 26, 154,
X 240, 112, 208, 80, 248, 120, 216, 88, 242, 114, 210, 82, 250, 122, 218, 90,
X       12, 140, 44, 172, 4, 132, 36, 164, 14, 142, 46, 174, 6, 134, 38, 166,
X 204, 76, 236, 108, 196, 68, 228, 100, 206, 78, 238, 110, 198, 70, 230, 102,
X     60, 188, 28, 156, 52, 180, 20, 148, 62, 190, 30, 158, 54, 182, 22, 150,
X 252, 124, 220, 92, 244, 116, 212, 84, 254, 126, 222, 94, 246, 118, 214, 86,
X	3, 131, 35, 163, 11, 139, 43, 171, 1, 129, 33, 161, 9, 137, 41, 169,
X   195, 67, 227, 99, 203, 75, 235, 107, 193, 65, 225, 97, 201, 73, 233, 105,
X     51, 179, 19, 147, 59, 187, 27, 155, 49, 177, 17, 145, 57, 185, 25, 153,
X 243, 115, 211, 83, 251, 123, 219, 91, 241, 113, 209, 81, 249, 121, 217, 89,
X       15, 143, 47, 175, 7, 135, 39, 167, 13, 141, 45, 173, 5, 133, 37, 165,
X 207, 79, 239, 111, 199, 71, 231, 103, 205, 77, 237, 109, 197, 69, 229, 101,
X     63, 191, 31, 159, 55, 183, 23, 151, 61, 189, 29, 157, 53, 181, 21, 149,
X  254, 127, 223, 95, 247, 119, 215, 87, 253, 125, 221, 93, 245, 117, 213, 85
X};
static int      halftone32[64] = {
X				  92, 100, 124, 148, 164, 156, 132, 108,
X				  28, 20, 76, 220, 228, 236, 180, 36,
X				  4, 12, 84, 212, 252, 244, 172, 44,
X				  52, 60, 116, 188, 204, 196, 140, 68,
X				  164, 156, 132, 108, 92, 100, 124, 148,
X				  228, 236, 180, 36, 28, 20, 76, 220,
X				  252, 244, 172, 44, 4, 12, 84, 212,
X				  204, 196, 140, 68, 52, 60, 116, 188
X};
X
X
dithline (inline, outline, npixels, linenum, imethod)
X    unsigned char  *inline, *outline;
X    int             npixels, linenum, imethod;
X{
int             greydata;
int             i1, ipoint, jpoint;
float           pixel, pixerr, nexterr;
int             irand;
X
X/* set polarity */
X    if (linenum == 1)
X    {
X	if (invras)
X	{
X	    pix_off = 0;
X	    pix_on = 7;
X	}
X	else
X	{
X	    pix_off = 7;
X	    pix_on = 0;
X	}
X    }
X
X/* Random Dither */
X    if (imethod == 1)
X    {
X	for (i1 = 0; i1 < npixels; i1++)
X	{
X	    greydata = inline[i1];
X	    irand = (random () & 255);
X	    if (greydata > irand)
X	    {
X		outline[i1] = pix_off;
X	    }
X	    else
X	    {
X		outline[i1] = pix_on;
X	    }
X	}
X    }
X
X/* Ordered Dither */
X    if (imethod == 2)
X    {
X	for (i1 = 0; i1 < npixels; i1++)
X	{
X	    greydata = inline[i1];
X	    ipoint = i1 % 16;
X	    jpoint = linenum % 16;
X	    ipoint = ipoint * 16 + jpoint;
X	    if (greydata > dith256[ipoint])
X	    {
X		outline[i1] = pix_off;
X	    }
X	    else
X	    {
X		outline[i1] = pix_on;
X	    }
X	}
X    }
X
X/* Floyd-Steinberg */
X    if (imethod == 3)
X    {
X	if (ialloc != 1)
X	{
X	    if ((errline = (float *) malloc ((unsigned) npixels * sizeof (float))) == NULL)
X	    {
X		ERR (FATAL, name, "Can't allocate space for Floyd-Steinberg\n");
X		return;
X	    }
X	    ialloc = 1;
X	    for (i1 = 0; i1 < npixels; i1++)
X	    {
X		errline[i1] = 0.;
X	    }
X	}
X	nexterr = errline[0];
X	for (i1 = 0; i1 < npixels; i1++)
X	{
X	    pixel = inline[i1];
X	    pixel += nexterr;
X	    if (pixel < 128)
X	    {
X		outline[i1] = pix_on;
X		pixerr = pixel;
X	    }
X	    else
X	    {
X		outline[i1] = pix_off;
X		pixerr = pixel - 255;
X	    }
X	    if (i1 < npixels)
X	    {
X		nexterr = errline[i1 + 1] + pixerr * alpha;
X		errline[i1 + 1] = pixerr * delta;
X	    }
X	    if (i1 > 0)
X	    {
X		errline[i1 - 1] += pixerr * beta;
X	    }
X	    errline[i1] += pixerr * gamma;
X	    if (i1 == 0)
X		errline[i1] = pixerr * gamma;
X	}
X    }
X
X
X/* 32 element halftone at 45 degrees */
X    if (imethod == 4)
X    {
X	for (i1 = 0; i1 < npixels; i1++)
X	{
X	    greydata = inline[i1];
X	    ipoint = i1 % 8;
X	    jpoint = linenum % 8;
X	    ipoint = ipoint * 8 + jpoint;
X	    if (greydata > halftone32[ipoint])
X	    {
X		outline[i1] = pix_off;
X	    }
X	    else
X	    {
X		outline[i1] = pix_on;
X	    }
X	}
X    }
X
X}
END_OF_FILE
if test 5256 -ne `wc -c <'Vplot_Kernel/filters/utilities/dither.c'`; then
    echo shar: \"'Vplot_Kernel/filters/utilities/dither.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/utilities/dither.c'
fi
if test -f 'Vplot_Kernel/filters/utilities/fatvec.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/filters/utilities/fatvec.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/filters/utilities/fatvec.c'\" \(5227 characters\)
sed "s/^X//" >'Vplot_Kernel/filters/utilities/fatvec.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./filters/utilities/fatvec.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X */
X
X/*
X * Utility routine to make fat vectors from several thin ones.
X * Should ONLY be called if nfat > 0 and dashon = 0
X *
X * Algorithm by Glenn Kroeger
X * Changes added by Joe Dellinger to make it more efficient when plotting
X */
X
X#include <stdio.h>
X#include <math.h>
X#include "../include/extern.h"
X
fatvec (x1, y1, x2, y2, nfat, dashon)
X    int             x1, y1, x2, y2;
X    int             nfat, dashon;
X{
register int    i;
register int    fplus, fminus;
static int      lastdir = 0;
X
X    lastdir = 1 - lastdir;
X
X    if (aspect_ratio != 1. && (y2 != y1 || x2 != x1) && nfat)
X    {
nfat = (float) nfat *sqrt (
X	                    ((y2 - y1) * (y2 - y1) + ((x2 - x1) * (x2 - x1))
X			     /               (aspect_ratio * aspect_ratio)) /
X	                   ((y2 - y1) * (y2 - y1) + ((x2 - x1) * (x2 - x1)))
X	);
X    }
X
X    fminus = (nfat / 2);
X    fplus = (nfat + 1) / 2;
X
X    if (x1 <= x2)
X    {
X	if (y2 > y1)
X	{
X	    if (x1 == x2)
X	    {
X		for (i = -fminus; i <= fplus; i++)
X		    dev.vector (x1 + i, y1 - fminus, x2 + i, y2 + fplus, 0, 0);
X	    }
X	    else
X	    {
X
X		if (lastdir)
X		{
X		    for (i = (fminus + fplus); i > 0; i--)
X		    {
X			dev.vector (x1 - fminus + i, y1 - fminus, x2 + fplus,
X				    y2 + fplus - i, 0, 0);
X		    }
X		    dev.vector (x1 - fminus, y1 - fminus, x2 + fplus, y2 + fplus, 0, 0);
X		    for (i = 1; i < (fminus + fplus + 1); i++)
X		    {
X			dev.vector (x1 - fminus, y1 - fminus + i, x2 + fplus - i,
X				    y2 + fplus, 0, 0);
X		    }
X		}
X		else
X		{
X		    for (i = (fminus + fplus); i > 0; i--)
X		    {
X			dev.vector (x1 - fminus, y1 - fminus + i, x2 + fplus - i,
X				    y2 + fplus, 0, 0);
X		    }
X		    dev.vector (x1 - fminus, y1 - fminus, x2 + fplus, y2 + fplus, 0, 0);
X		    for (i = 1; i < (fminus + fplus + 1); i++)
X		    {
X			dev.vector (x1 - fminus + i, y1 - fminus, x2 + fplus,
X				    y2 + fplus - i, 0, 0);
X		    }
X		}
X	    }
X	}
X	else
X	if (y2 == y1)
X	{
X	    for (i = -fminus; i <= fplus; i++)
X		dev.vector (x1 - fminus, y1 + i, x2 + fplus, y2 + i, 0, 0);
X	}
X	else
X	{
X	    if (x1 == x2)
X	    {
X		for (i = -fminus; i <= fplus; i++)
X		    dev.vector (x1 + i, y1 + fplus, x2 + i, y2 - fminus, 0, 0);
X	    }
X	    else
X	    {
X
X		if (lastdir)
X		{
X		    for (i = (fminus + fplus); i > 0; i--)
X		    {
X			dev.vector (x1 - fminus + i, y1 + fplus, x2 + fplus,
X				    y2 - fminus + i, 0, 0);
X		    }
X		    dev.vector (x1 - fminus, y1 + fplus, x2 + fplus, y2 - fminus, 0, 0);
X		    for (i = 1; i < (fminus + fplus + 1); i++)
X		    {
X			dev.vector (x1 - fminus, y1 + fplus - i, x2 + fplus - i,
X				    y2 - fminus, 0, 0);
X		    }
X		}
X		else
X		{
X		    for (i = (fminus + fplus); i > 0; i--)
X		    {
X			dev.vector (x1 - fminus, y1 + fplus - i, x2 + fplus - i,
X				    y2 - fminus, 0, 0);
X		    }
X		    dev.vector (x1 - fminus, y1 + fplus, x2 + fplus, y2 - fminus, 0, 0);
X		    for (i = 1; i < (fminus + fplus + 1); i++)
X		    {
X			dev.vector (x1 - fminus + i, y1 + fplus, x2 + fplus,
X				    y2 - fminus + i, 0, 0);
X		    }
X		}
X	    }
X	}
X    }
X    else
X    {
X	if (y2 > y1)
X	{
X	    if (lastdir)
X	    {
X		for (i = (fminus + fplus); i > 0; i--)
X		{
X		    dev.vector (x1 + fplus, y1 - fminus + i, x2 - fminus + i, y2 + fplus, 0, 0);
X		}
X		dev.vector (x1 + fplus, y1 - fminus, x2 - fminus, y2 + fplus, 0, 0);
X		for (i = 1; i < (fminus + fplus + 1); i++)
X		{
X		    dev.vector (x1 + fplus - i, y1 - fminus, x2 - fminus, y2 + fplus - i, 0, 0);
X		}
X	    }
X	    else
X	    {
X		for (i = (fminus + fplus); i > 0; i--)
X		{
X		    dev.vector (x1 + fplus - i, y1 - fminus, x2 - fminus, y2 + fplus - i, 0, 0);
X		}
X		dev.vector (x1 + fplus, y1 - fminus, x2 - fminus, y2 + fplus, 0, 0);
X		for (i = 1; i < (fminus + fplus + 1); i++)
X		{
X		    dev.vector (x1 + fplus, y1 - fminus + i, x2 - fminus + i, y2 + fplus, 0, 0);
X		}
X	    }
X	}
X	else
X	if (y2 == y1)
X	{
X	    for (i = -fminus; i <= fplus; i++)
X		dev.vector (x1 + fplus, y1 + i, x2 - fminus, y2 + i, 0, 0);
X	}
X	else
X	{
X	    if (lastdir)
X	    {
X		for (i = (fminus + fplus); i > 0; i--)
X		{
X		    dev.vector (x1 + fplus, y1 + fplus - i, x2 - fminus + i, y2 - fminus, 0, 0);
X		}
X		dev.vector (x1 + fplus, y1 + fplus, x2 - fminus, y2 - fminus, 0, 0);
X		for (i = 1; i < (fminus + fplus + 1); i++)
X		{
X		    dev.vector (x1 + fplus - i, y1 + fplus, x2 - fminus, y2 - fminus + i, 0, 0);
X		}
X	    }
X	    else
X	    {
X		for (i = (fminus + fplus); i > 0; i--)
X		{
X		    dev.vector (x1 + fplus - i, y1 + fplus, x2 - fminus, y2 - fminus + i, 0, 0);
X		}
X		dev.vector (x1 + fplus, y1 + fplus, x2 - fminus, y2 - fminus, 0, 0);
X		for (i = 1; i < (fminus + fplus + 1); i++)
X		{
X		    dev.vector (x1 + fplus, y1 + fplus - i, x2 - fminus + i, y2 - fminus, 0, 0);
X		}
X	    }
X	}
X    }
X}
END_OF_FILE
if test 5227 -ne `wc -c <'Vplot_Kernel/filters/utilities/fatvec.c'`; then
    echo shar: \"'Vplot_Kernel/filters/utilities/fatvec.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/filters/utilities/fatvec.c'
fi
if test -f 'Vplot_Kernel/lvplot/vp_raster.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Vplot_Kernel/lvplot/vp_raster.c'\"
else
echo shar: Extracting \"'Vplot_Kernel/lvplot/vp_raster.c'\" \(5777 characters\)
sed "s/^X//" >'Vplot_Kernel/lvplot/vp_raster.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 the Board of Trustees of the Leland Stanford Junior
X * University. Official permission to use this software is included in
X * the documentation. It authorizes you to use this file for any
X * non-commercial purpose, provided that this copyright notice is not
X * removed and that any modifications made to this file are commented
X * and dated in the style of my example below.
X */
X
X/*
X *
X *  source file:   ./lvplot/vp_raster.c
X *
X * Joe Dellinger (SEP), June 11 1987
X *	Inserted this sample edit history entry.
X *	Please log any further modifications made to this file:
X * Joe Dellinger Jan 14 1988
X *	Do rounding.
X */
X
X/* This program cannot be indented! */
X
X#include <stdio.h>
X#include <vplot.h>
X#include "round.h"
X#include "vp_pc.h"
X
X#ifdef FORTRAN
X
X#define RASTER		vpraster_
X#define XLL		*xll
X#define YLL		*yll
X#define XPIX		*xpix
X#define YPIX		*ypix
X#define PPI		*ppi
X#define	BIT		*bit
X#define OFFSET		*offset
X#define	BLAST		*blast
X#define	ORIENT		*orient
X#define	INVERT		*invert
X
X#else
X
X#define RASTER		vp_raster
X#define XLL		xll
X#define YLL		yll
X#define XPIX		xpix
X#define YPIX		ypix
X#define PPI		ppi
X#define	BIT		bit
X#define OFFSET		offset
X#define	BLAST		blast
X#define	ORIENT		orient
X#define	INVERT		invert
X
X#endif
X
X#define ARRAY(A,B)	array[(((INVERT)==0)?(A):(YPIX-1-(A)))*(XPIX)+(B)]
X
X#define MAXREP	8
X#define PUTHSIZE sizeof(int)
X
X#define RASOUT(NUMPAT,NUMBYTE,BITFLAG,BYTES)	\
X{\
X    puth ((int) (NUMPAT), vp_pc._pltout);\
X    puth ((int) (NUMBYTE), vp_pc._pltout);\
X\
X    if (BITFLAG)\
X    {\
X	for (nn = 0; nn + 7 < (NUMBYTE); nn += 8)\
X	{\
X	    obyte = 0x00;\
X\
X	    obyte =\
X		((*((BYTES) + nn + 0) != 0) << 7) |\
X		((*((BYTES) + nn + 1) != 0) << 6) |\
X		((*((BYTES) + nn + 2) != 0) << 5) |\
X		((*((BYTES) + nn + 3) != 0) << 4) |\
X		((*((BYTES) + nn + 4) != 0) << 3) |\
X		((*((BYTES) + nn + 5) != 0) << 2) |\
X		((*((BYTES) + nn + 6) != 0) << 1) |\
X		((*((BYTES) + nn + 7) != 0) << 0);\
X	    putc ((char) obyte, vp_pc._pltout);\
X	}\
X	if (nn < (NUMBYTE))\
X	{\
X	    obyte = 0x00;\
X	    for (nnn = 7; nn < (NUMBYTE); nn++, nnn--)\
X	    {\
X		obyte |= ((*((BYTES) + nn) != 0) << nnn);\
X	    }\
X	    putc ((char) obyte, vp_pc._pltout);\
X	}\
X    }\
X    else\
X    {\
X	for (nn = 0; nn < (NUMBYTE); nn++)\
X	{\
X	    putc ((char) * ((BYTES) + nn), vp_pc._pltout);\
X	}\
X    }\
X}
X
RASTER (array, blast, bit, offset, xpix, ypix, xll, yll, ppi, xur, yur, orient, invert)
unsigned char  *array;
float   XLL, YLL, *xur, *yur, PPI;
int     XPIX, YPIX, BIT, OFFSET, BLAST, ORIENT, INVERT;
X{
X    int     mm, nn, nnn, ll, kk, jj, ii, count, ucount, bitbyte;
X    int     ix, iy;
X    unsigned char   obyte;
X
X    if (BIT)
X    {
X	bitbyte = 8;
X	putc (VP_BIT_RASTER, vp_pc._pltout);
X    }
X    else
X    {
X	bitbyte = 1;
X	putc (VP_BYTE_RASTER, vp_pc._pltout);
X    }
X
X    if (ORIENT >= 0)
X	ORIENT = ORIENT % 4;
X    else
X	ORIENT = ((ORIENT % 4) + 4) % 4;
X
X    puth ((int) ORIENT, vp_pc._pltout);
X    puth ((int) offset, vp_pc._pltout);
X    ix = ROUND (XLL * RPERIN);
X    iy = ROUND (YLL * RPERIN);
X    puth (ix, vp_pc._pltout);
X    puth (iy, vp_pc._pltout);
X    if (PPI > 0)
X    {
X	ix += ROUND (RPERIN * XPIX / PPI);
X	iy += ROUND (RPERIN * YPIX / PPI);
X	*xur = ix / (float) RPERIN;
X	*yur = iy / (float) RPERIN;
X    }
X    else
X    {
X	ix = ROUND (*xur * RPERIN);
X	iy = ROUND (*yur * RPERIN);
X    }
X    puth (ix, vp_pc._pltout);
X    puth (iy, vp_pc._pltout);
X
X    puth ((int) XPIX, vp_pc._pltout);
X    puth ((int) YPIX, vp_pc._pltout);
X
X    if (BLAST)
X    {
X/* Don't try to compact it at all */
X	for (ii = 0; ii < YPIX; ii++)
X	{
X	    puth ((int) 1, vp_pc._pltout);
X	    RASOUT (1, XPIX, BIT, &ARRAY (ii, 0));
X	}
X    }
X    else
X    {
X/* Try to compact it */
X	count = 1;
X	for (ii = 0; ii < YPIX; ii++)
X	{
X	    for (jj = 0; jj < XPIX; jj++)
X	    {
X		if (ii == YPIX - 1 || ARRAY (ii, jj) != ARRAY (ii + 1, jj))
X		{
X/* Write this row out, it's not just a repeat of the next one */
X
X/* Write out how many times this line is to be repeated */
X		    puth (count, vp_pc._pltout);
X
X/*
X * This entire section tries to efficiently represent ONE RASTER LINE
X */
X
X/*
X * Keep track of "unaccounted for" bytes between
X * bytes containted in a pattern
X */
X		    ucount = 0;
X/* Loop through a raster line */
X		    for (kk = 0; kk < XPIX; kk++)
X		    {
X/* Try different size patterns */
X			for (ll = 1; ll <= MAXREP; ll++)
X			{
X/* See how far this pattern size works */
X			    for (mm = 0; mm <= XPIX - (kk + ll); mm++)
X			    {
X/* Pattern stopped working */
X				if (mm == XPIX - (kk + ll) ||
X					ARRAY (ii, kk + mm) != ARRAY (ii, kk + mm + ll))
X				{
X/* See how many repetitions we got */
X				    mm = ll * (1 + (int) (mm / ll));
X/* Is it worth it to use this? */
X/* (PUTHSIZE is the number of bytes needed for a puth */
X				    if (PUTHSIZE * 2 + ll <= 1 + (mm - 1) / bitbyte)
X				    {
X/* First take care of bytes not in a pattern */
X					if (ucount > 0)
X					{
X					    RASOUT (1, ucount, BIT, &ARRAY (ii, kk - ucount));
X					    ucount = 0;
X					}
X/* Now take care of the bytes in the pattern */
X					RASOUT ((int) mm / ll, ll, BIT, &ARRAY (ii, kk));
X					kk += mm - 1;
X/* Stop looking, we already found what we wanted */
X					goto compact_found;
X				    }
X/* This pattern didn't work. Stop looking at this size and try a longer one */
X				    break;
X				}
X			    }
X			}
X/* No pattern including this byte, add it to the unaccounted for list */
X			ucount++;
X		compact_found: 
X			continue;
X		    }
X/* Take care of any bytes left hanging on the end */
X		    if (ucount > 0)
X		    {
X			RASOUT (1, ucount, BIT, &ARRAY (ii, kk - ucount));
X		    }
X/*
X * END of section that does ONE RASTER LINE
X */
X
X
X/* Reset counter */
X		    count = 1;
X/* Exit the loop */
X		    break;
X		}
X	    }
X/* If we didn't write it out, it will just be a repeat of the next one */
X	    if (jj == XPIX)
X		count++;
X	}
X    }
X}
END_OF_FILE
if test 5777 -ne `wc -c <'Vplot_Kernel/lvplot/vp_raster.c'`; then
    echo shar: \"'Vplot_Kernel/lvplot/vp_raster.c'\" unpacked with wrong size!
fi
# end of 'Vplot_Kernel/lvplot/vp_raster.c'
fi
echo shar: End of archive 13 \(of 24\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
