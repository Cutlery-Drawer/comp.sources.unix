Subject:  v14i082:  Flex, a lex replacement, Part04/05
Newsgroups: comp.sources.unix
Sender: sources
Approved: rsalz@uunet.UU.NET

Submitted-by: Vern Paxson <vern@lbl-csam.arpa>
Posting-number: Volume 14, Issue 82
Archive-name: flex/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 5)."
# Contents:  scan.c.dist
# Wrapped by rsalz@fig.bbn.com on Tue May  3 17:31:33 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'scan.c.dist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scan.c.dist'\"
else
echo shar: Extracting \"'scan.c.dist'\" \(36366 characters\)
sed "s/^X//" >'scan.c.dist' <<'END_OF_FILE'
X#define YY_DEFAULT_ACTION YY_FATAL_ERROR( "flex scanner jammed" );
X#define FLEX_USE_ECS
X#define FLEX_USE_MECS
X/* A lexical scanner generated by flex */
X
X#include "flexskeldef.h"
X
X# line 1 "scan.l"
X#define INITIAL 0
X/* scan.l - scanner for flex input */
X/*
X * Copyright (c) 1987, the University of California
X * 
X * The United States Government has rights in this work pursuant to
X * contract no. DE-AC03-76SF00098 between the United States Department of
X * Energy and the University of California.
X * 
X * This program may be redistributed.  Enhancements and derivative works
X * may be created provided the new works, if made available to the general
X * public, are made available for use by anyone.
X */
X# line 16 "scan.l"
X#include "flexdef.h"
X#include "parse.h"
X
X#define ACTION_ECHO fprintf( temp_action_file, "%s", yytext )
X#define MARK_END_OF_PROLOG fprintf( temp_action_file, "%%%% end of prolog\n" );
X
X#undef YY_DECL
X#define YY_DECL \
X	int flexscan()
X
X#define RETURNCHAR \
X	yylval = yytext[0]; \
X	return ( CHAR );
X
X#define RETURNNAME \
X	(void) strcpy( nmstr, yytext ); \
X	return ( NAME );
X
X#define PUT_BACK_STRING(str, start) \
X	for ( i = strlen( str ) - 1; i >= start; --i ) \
X	    unput(str[i])
X#define SECT2 2
X#define SECT2PROLOG 4
X#define SECT3 6
X#define CODEBLOCK 8
X#define PICKUPDEF 10
X#define SC 12
X#define CARETISBOL 14
X#define NUM 16
X#define QUOTE 18
X#define FIRSTCCL 20
X#define CCL 22
X#define ACTION 24
X#define RECOVER 26
X#define BRACEERROR 28
X#define C_COMMENT 30
X#define C_COMMENT_2 32
X#define ACTION_COMMENT 34
X#define ACTION_STRING 36
X#define PERCENT_BRACE_ACTION 38
X# line 53 "scan.l"
X#define YY_JAM 226
X#define YY_JAM_BASE 800
X#define YY_TEMPLATE 227
static char l[227] =
X    {   0,
X       -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,
X       -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,
X       -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,
X       -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,
X       14,    7,   13,   11,    7,   12,   14,   14,   14,   10,
X       46,   39,   40,   32,   46,   45,   30,   46,   46,   46,
X       39,   28,   46,   45,   31,    0,   27,   99,    0,   21,
X        0,   23,   22,   24,   52,   48,   49,   51,   53,   67,
X       68,   65,   64,   66,   54,   56,   55,   54,   60,   59,
X       60,   60,   62,   62,   62,   63,   76,   80,   79,   81,
X
X       81,   74,   75,    0,   25,   70,   69,   17,   19,   18,
X       89,   91,   90,   83,   85,   84,   92,   94,   95,   96,
X       72,   72,   73,   72,    7,   11,    0,    7,    1,    0,
X        2,    0,    8,    4,    5,    0,    3,   10,   39,   40,
X        0,    0,   35,    0,    0,   97,   97,    0,   34,   33,
X       34,    0,   39,   28,    0,    0,    0,   42,   38,   26,
X        0,   23,   50,   51,   64,   98,   98,    0,   57,   58,
X       61,   76,    0,   78,    0,   77,   15,   87,   83,   82,
X       92,   93,   71,    1,    0,    9,    8,    0,    0,    6,
X       36,    0,   37,   43,    0,    0,   97,   34,   34,   44,
X
X       29,    0,   36,    0,   29,    0,   42,    0,   20,   98,
X        0,   16,    0,   88,   71,    0,    0,   97,   98,    0,
X        0,   97,   98,    4,    0,    0
X    } ;
X
static char e[128] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    2,    1,    4,    5,    6,    7,    1,    8,    9,
X        9,   10,    9,   11,   12,    9,   13,   14,   15,   15,
X       15,   15,   15,   15,   15,   15,   15,    1,    1,   16,
X        1,   17,    9,    1,   23,   22,   22,   22,   22,   22,
X       22,   22,   22,   22,   22,   22,   22,   22,   22,   22,
X       22,   24,   25,   26,   22,   22,   22,   27,   22,   22,
X       18,   19,   20,   21,   22,    1,   23,   22,   22,   22,
X
X       22,   22,   22,   22,   22,   22,   22,   22,   22,   22,
X       22,   22,   22,   24,   25,   26,   22,   22,   22,   27,
X       22,   22,   28,   29,   30,    1,    1
X    } ;
X
static char m[31] =
X    {   0,
X        1,    2,    3,    4,    1,    1,    1,    5,    1,    6,
X        1,    1,    5,    7,    7,    1,    1,    1,    8,    9,
X        1,    7,    7,    7,    7,    7,    7,    5,    1,   10
X    } ;
X
static short int b[276] =
X    {   0,
X        0,   26,   52,   80,  286,  285,    0,    0,  284,    1,
X        3,    7,   99,  116,  265,  264,  141,  169,   11,   13,
X        0,   22,   25,   47,  197,  225,  281,  280,    8,   10,
X       32,   54,   66,   69,   75,   85,   88,   99,  110,  112,
X      800,  280,  800,    0,   44,  800,  277,  104,  269,    0,
X      800,  144,  800,  800,   71,  800,  800,  259,   83,  242,
X      268,  800,  270,  266,  800,  271,    0,  800,  270,  800,
X       33,    0,  270,  800,  800,  800,  242,    0,  800,  800,
X      800,  800,   91,  800,  800,  800,  800,  114,  800,  800,
X      116,  250,  800,    0,  136,  800,    0,  800,  800,  126,
X
X      251,  800,  800,  257,  800,  800,  800,  150,  800,  246,
X      151,  800,  245,    0,  800,  241,    0,  800,  800,    0,
X      249,  156,  800,  145,  249,    0,  247,  162,  800,  246,
X      800,  245,    0,  219,  800,  234,  800,    0,  167,  800,
X      206,  229,  800,  147,  165,  800,  162,    0,    0,  800,
X      284,  165,  313,  800,  178,  179,  184,    0,  800,  800,
X      218,    0,  800,    0,  178,  800,  180,    0,  800,  800,
X      800,    0,  190,  800,    0,  800,  216,  187,    0,  800,
X        0,  800,    0,  800,  185,  800,    0,  139,  146,  800,
X      800,  133,  800,  800,  188,  100,  197,    0,    0,  800,
X
X      800,  210,  201,  213,  800,  212,    0,   97,  800,  203,
X       91,  800,   74,  800,    0,   51,  216,  209,  225,   34,
X      227,  800,  800,  800,  224,  800,  342,  352,  362,  372,
X      382,  392,  402,  412,  422,  432,  442,  452,  462,  472,
X      482,  492,  502,  512,   13,  522,  532,  542,   11,  552,
X      562,  572,  582,  592,  602,    0,  612,  622,  632,  642,
X      651,  661,  671,  681,  691,  701,  711,  721,  731,  740,
X      750,  760,  770,  780,  790
X    } ;
X
static short int d[276] =
X    {   0,
X      227,  227,  228,  228,  229,  229,  230,  230,  231,  231,
X      232,  232,  233,  233,  226,  226,  234,  234,  235,  235,
X      236,  236,  237,  237,  238,  238,  239,  239,  226,  226,
X      240,  240,  241,  241,  242,  242,  243,  243,  244,  244,
X      226,  226,  226,  245,  246,  226,  247,  248,  226,  249,
X      226,  226,  226,  226,  226,  226,  226,  250,  251,  252,
X      253,  226,  226,  226,  226,  229,  254,  226,  231,  226,
X      231,  255,  226,  226,  226,  226,  226,  256,  226,  226,
X      226,  226,  226,  226,  226,  226,  226,  251,  226,  226,
X      257,  258,  226,  259,  251,  226,  260,  226,  226,  261,
X
X      226,  226,  226,  239,  226,  226,  226,  240,  226,  226,
X      241,  226,  226,  262,  226,  226,  263,  226,  226,  264,
X      244,  244,  226,  244,  226,  245,  246,  246,  226,  247,
X      226,  265,  266,  226,  226,  267,  226,  249,  226,  226,
X      226,  268,  226,  250,  250,  226,  226,  251,  269,  226,
X      269,  253,  253,  226,  253,  253,  270,  271,  226,  226,
X      272,  255,  226,  256,  226,  226,  226,  257,  226,  226,
X      226,  260,  261,  226,  261,  226,  273,  274,  262,  226,
X      263,  226,  275,  226,  265,  226,  266,  226,  267,  226,
X      226,  268,  226,  226,  250,  250,  226,  269,  151,  226,
X
X      226,  253,  253,  270,  226,  270,  271,  272,  226,  226,
X      273,  226,  274,  226,  275,  226,  250,  226,  226,  226,
X      250,  226,  226,  226,  250,-32767,  226,  226,  226,  226,
X      226,  226,  226,  226,  226,  226,  226,  226,  226,  226,
X      226,  226,  226,  226,  226,  226,  226,  226,  226,  226,
X      226,  226,  226,  226,  226,  226,  226,  226,  226,  226,
X      226,  226,  226,  226,  226,  226,  226,  226,  226,  226,
X      226,  226,  226,  226,  226
X    } ;
X
static short int n[831] =
X    {   0,
X      226,   42,   43,   70,   73,   74,  164,   71,   73,   74,
X      106,   90,  106,   86,   87,   86,   87,  138,   91,  126,
X       92,   44,   44,   44,   44,   44,   44,   45,   46,   88,
X       47,   88,   48,   90,  109,   70,   94,  107,   49,  107,
X       91,  110,   92,   95,   96,  128,  129,   50,   50,   50,
X       50,   50,   50,   52,   53,   54,  109,   55,   94,  224,
X       56,   56,  161,  110,   56,   95,   96,   57,  112,   58,
X       59,  112,  143,  143,  220,  113,  214,  115,  113,   60,
X       56,   61,   62,   54,  116,   55,   63,  115,   56,   56,
X      118,  119,   64,  212,  116,   57,  147,   58,   59,  209,
X
X       65,  118,  119,  148,  165,  165,  120,   60,   56,   76,
X      133,  122,  123,  122,  123,   77,  124,  120,  124,  144,
X       78,   78,   78,   78,   78,   78,   76,  147,  134,  167,
X      135,  136,   77,  174,  148,  193,  168,   78,   78,   78,
X       78,   78,   78,   81,  175,  139,  140,  226,  190,  147,
X      141,   82,  226,  226,   83,   83,  148,  122,  226,  226,
X      226,  216,  124,  128,  129,  145,  194,  201,  139,  140,
X       84,   81,  142,  141,  183,  197,  197,  202,  195,   82,
X      201,  201,   83,   83,  144,  196,  205,  186,  159,  214,
X      202,  165,  165,  210,  210,  142,  206,  174,   84,   98,
X
X       99,  217,  217,  201,  100,  203,  145,  194,  175,  101,
X      218,  218,  201,  202,  205,  205,  219,  219,  212,  226,
X      209,  192,  222,  222,  102,  206,  103,   98,   99,  221,
X      221,  193,  100,  191,  145,  194,  190,  101,  223,  223,
X      225,  225,  145,  194,  188,  145,  194,  186,  131,  184,
X      125,  226,  102,  180,  103,  150,  150,  178,  177,  105,
X      176,  170,  163,  151,  151,  151,  151,  151,  151,  153,
X      154,   73,   70,   67,  155,  159,  158,  145,  137,  131,
X      156,  125,  105,  105,   79,   79,   70,   67,   67,  226,
X      226,  226,  226,  226,  226,  226,  157,  199,  199,  226,
X
X      226,  226,  226,  226,  226,  199,  199,  199,  199,  199,
X      199,  226,  226,  200,  153,  154,  226,  226,  226,  155,
X      226,  226,  226,  226,  226,  156,  226,  226,  226,  226,
X      226,  226,  226,  226,  226,  226,  226,  226,  226,  226,
X      226,  157,   41,   41,   41,   41,   41,   41,   41,   41,
X       41,   41,   51,   51,   51,   51,   51,   51,   51,   51,
X       51,   51,   66,   66,   66,   66,   66,   66,   66,   66,
X       66,   66,   68,   68,   68,   68,   68,   68,   68,   68,
X       68,   68,   69,   69,   69,   69,   69,   69,   69,   69,
X       69,   69,   72,   72,   72,   72,   72,   72,   72,   72,
X
X       72,   72,   75,   75,  226,   75,   75,   75,   75,   75,
X       75,   75,   80,   80,   80,   80,   80,   80,   80,   80,
X       80,   80,   85,   85,   85,   85,   85,   85,   85,   85,
X       85,   85,   89,   89,  226,   89,   89,   89,   89,   89,
X       89,   89,   93,   93,  226,   93,   93,   93,   93,   93,
X       93,   93,   97,   97,   97,   97,   97,   97,   97,   97,
X       97,   97,  104,  104,  104,  104,  104,  104,  104,  104,
X      104,  104,  108,  108,  108,  108,  108,  108,  108,  108,
X      108,  108,  111,  111,  111,  111,  111,  111,  111,  111,
X      111,  111,  114,  114,  114,  114,  114,  114,  114,  114,
X
X      114,  114,  117,  117,  117,  117,  117,  117,  117,  117,
X      117,  117,  121,  121,  121,  121,  121,  121,  121,  121,
X      121,  121,  127,  127,  127,  127,  127,  127,  127,  127,
X      127,  127,  130,  130,  130,  130,  130,  130,  130,  130,
X      130,  130,  132,  132,  132,  132,  132,  132,  132,  132,
X      132,  132,  144,  144,  226,  144,  144,  144,  144,  144,
X      226,  144,  146,  146,  226,  146,  146,  146,  146,  146,
X      146,  146,  149,  149,  226,  149,  149,  149,  149,  149,
X      149,  149,  152,  152,  152,  152,  152,  152,  152,  152,
X      152,  152,  160,  226,  226,  160,  160,  160,  160,  160,
X
X      160,  160,  162,  162,  226,  162,  162,  162,  162,  162,
X      162,  162,  166,  166,  226,  166,  166,  166,  166,  166,
X      166,  166,  169,  169,  226,  169,  169,  169,  169,  169,
X      169,  169,  171,  171,  226,  171,  171,  171,  171,  171,
X      226,  171,  172,  172,  226,  226,  226,  172,  172,  172,
X      172,  173,  173,  226,  173,  173,  173,  173,  173,  173,
X      173,  179,  179,  226,  179,  179,  226,  179,  179,  179,
X      179,  181,  181,  226,  226,  181,  181,  181,  226,  181,
X      181,  182,  182,  226,  182,  182,  182,  182,  182,  182,
X      182,  185,  185,  185,  185,  185,  185,  185,  185,  185,
X
X      185,  187,  187,  226,  187,  187,  187,  187,  187,  187,
X      187,  189,  189,  189,  189,  189,  189,  189,  189,  189,
X      189,  192,  192,  192,  192,  192,  192,  192,  192,  192,
X      192,  198,  198,  226,  198,  198,  198,  198,  198,  198,
X      204,  204,  204,  204,  204,  204,  204,  204,  204,  204,
X      207,  207,  226,  207,  207,  207,  207,  207,  207,  207,
X      208,  208,  208,  208,  208,  208,  208,  208,  208,  208,
X      211,  211,  211,  211,  211,  211,  211,  211,  211,  211,
X      213,  213,  213,  213,  213,  213,  213,  213,  213,  213,
X      215,  215,  226,  215,  215,  215,  215,  215,  215,  215,
X
X      226,  226,  226,  226,  226,  226,  226,  226,  226,  226,
X      226,  226,  226,  226,  226,  226,  226,  226,  226,  226,
X      226,  226,  226,  226,  226,  226,  226,  226,  226,  226
X    } ;
X
static short int c[831] =
X    {   0,
X        0,    1,    1,   10,   11,   11,  256,   10,   12,   12,
X       29,   21,   30,   19,   19,   20,   20,  249,   21,  245,
X       21,    1,    1,    1,    1,    1,    1,    2,    2,   19,
X        2,   20,    2,   22,   31,   71,   23,   29,    2,   30,
X       22,   31,   22,   23,   23,   45,   45,    2,    2,    2,
X        2,    2,    2,    3,    3,    3,   32,    3,   24,  220,
X        3,    3,   71,   32,    3,   24,   24,    3,   33,    3,
X        3,   34,   55,   55,  216,   33,  213,   35,   34,    3,
X        3,    4,    4,    4,   35,    4,    4,   36,    4,    4,
X       37,   37,    4,  211,   36,    4,   59,    4,    4,  208,
X
X        4,   38,   38,   59,   83,   83,   37,    4,    4,   13,
X       48,   39,   39,   40,   40,   13,   39,   38,   40,  196,
X       13,   13,   13,   13,   13,   13,   14,   88,   48,   91,
X       48,   48,   14,  100,   88,  192,   91,   14,   14,   14,
X       14,   14,   14,   17,  100,   52,   52,  124,  189,   95,
X       52,   17,  108,  111,   17,   17,   95,  122,  122,  108,
X      111,  188,  122,  128,  128,  144,  144,  152,  139,  139,
X       17,   18,   52,  139,  124,  147,  147,  152,  145,   18,
X      155,  156,   18,   18,  145,  145,  157,  185,  156,  178,
X      155,  165,  165,  167,  167,  139,  157,  173,   18,   25,
X
X       25,  195,  195,  203,   25,  155,  195,  195,  173,   25,
X      197,  197,  202,  203,  206,  204,  210,  210,  177,  202,
X      161,  206,  218,  218,   25,  204,   25,   26,   26,  217,
X      217,  142,   26,  141,  217,  217,  136,   26,  219,  219,
X      221,  221,  225,  225,  134,  221,  221,  132,  130,  127,
X      125,  121,   26,  116,   26,   60,   60,  113,  110,  104,
X      101,   92,   77,   60,   60,   60,   60,   60,   60,   61,
X       61,   73,   69,   66,   61,   64,   63,   58,   49,   47,
X       61,   42,   28,   27,   16,   15,    9,    6,    5,    0,
X        0,    0,    0,    0,    0,    0,   61,  151,  151,    0,
X
X        0,    0,    0,    0,    0,  151,  151,  151,  151,  151,
X      151,    0,    0,  151,  153,  153,    0,    0,    0,  153,
X        0,    0,    0,    0,    0,  153,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,  153,  227,  227,  227,  227,  227,  227,  227,  227,
X      227,  227,  228,  228,  228,  228,  228,  228,  228,  228,
X      228,  228,  229,  229,  229,  229,  229,  229,  229,  229,
X      229,  229,  230,  230,  230,  230,  230,  230,  230,  230,
X      230,  230,  231,  231,  231,  231,  231,  231,  231,  231,
X      231,  231,  232,  232,  232,  232,  232,  232,  232,  232,
X
X      232,  232,  233,  233,    0,  233,  233,  233,  233,  233,
X      233,  233,  234,  234,  234,  234,  234,  234,  234,  234,
X      234,  234,  235,  235,  235,  235,  235,  235,  235,  235,
X      235,  235,  236,  236,    0,  236,  236,  236,  236,  236,
X      236,  236,  237,  237,    0,  237,  237,  237,  237,  237,
X      237,  237,  238,  238,  238,  238,  238,  238,  238,  238,
X      238,  238,  239,  239,  239,  239,  239,  239,  239,  239,
X      239,  239,  240,  240,  240,  240,  240,  240,  240,  240,
X      240,  240,  241,  241,  241,  241,  241,  241,  241,  241,
X      241,  241,  242,  242,  242,  242,  242,  242,  242,  242,
X
X      242,  242,  243,  243,  243,  243,  243,  243,  243,  243,
X      243,  243,  244,  244,  244,  244,  244,  244,  244,  244,
X      244,  244,  246,  246,  246,  246,  246,  246,  246,  246,
X      246,  246,  247,  247,  247,  247,  247,  247,  247,  247,
X      247,  247,  248,  248,  248,  248,  248,  248,  248,  248,
X      248,  248,  250,  250,    0,  250,  250,  250,  250,  250,
X        0,  250,  251,  251,    0,  251,  251,  251,  251,  251,
X      251,  251,  252,  252,    0,  252,  252,  252,  252,  252,
X      252,  252,  253,  253,  253,  253,  253,  253,  253,  253,
X      253,  253,  254,    0,    0,  254,  254,  254,  254,  254,
X
X      254,  254,  255,  255,    0,  255,  255,  255,  255,  255,
X      255,  255,  257,  257,    0,  257,  257,  257,  257,  257,
X      257,  257,  258,  258,    0,  258,  258,  258,  258,  258,
X      258,  258,  259,  259,    0,  259,  259,  259,  259,  259,
X        0,  259,  260,  260,    0,    0,    0,  260,  260,  260,
X      260,  261,  261,    0,  261,  261,  261,  261,  261,  261,
X      261,  262,  262,    0,  262,  262,    0,  262,  262,  262,
X      262,  263,  263,    0,    0,  263,  263,  263,    0,  263,
X      263,  264,  264,    0,  264,  264,  264,  264,  264,  264,
X      264,  265,  265,  265,  265,  265,  265,  265,  265,  265,
X
X      265,  266,  266,    0,  266,  266,  266,  266,  266,  266,
X      266,  267,  267,  267,  267,  267,  267,  267,  267,  267,
X      267,  268,  268,  268,  268,  268,  268,  268,  268,  268,
X      268,  269,  269,    0,  269,  269,  269,  269,  269,  269,
X      270,  270,  270,  270,  270,  270,  270,  270,  270,  270,
X      271,  271,    0,  271,  271,  271,  271,  271,  271,  271,
X      272,  272,  272,  272,  272,  272,  272,  272,  272,  272,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
X      275,  275,    0,  275,  275,  275,  275,  275,  275,  275,
X
X      226,  226,  226,  226,  226,  226,  226,  226,  226,  226,
X      226,  226,  226,  226,  226,  226,  226,  226,  226,  226,
X      226,  226,  226,  226,  226,  226,  226,  226,  226,  226
X    } ;
X
X
X/* these declarations have to come after the section 1 code or lint gets
X * confused about whether the variables are used
X */
XFILE *yyin = stdin, *yyout = stdout;
X
X/* these variables are all declared out here so that section 3 code can
X * manipulate them
X */
static int yy_start, yy_b_buf_p, yy_c_buf_p, yy_e_buf_p;
static int yy_saw_eof, yy_init = 1;
X
X/* yy_ch_buf has to be 1 character longer than YY_BUF_SIZE, since when
X * setting up yytext we can try to put a '\0' just past the end of the
X * matched text
X */
static char yy_ch_buf[YY_BUF_SIZE + 1];
static int yy_st_buf[YY_BUF_SIZE];
static char yy_hold_char;
char *yytext;
static int yyleng;
X
YY_DECL
X    {
X    int yy_n_chars, yy_lp, yy_iii, yy_buf_pos, yy_act;
X
X
X    static int bracelevel, didadef;
X    int i, cclval;
X    char nmdef[MAXLINE], myesc();
X
X
X    if ( yy_init )
X	{
X	YY_INIT;
X	yy_start = 1;
X	yy_init = 0;
X	}
X
X    goto get_next_token;
X
do_action:
X    for ( ; ; )
X	{
X	YY_DO_BEFORE_ACTION
X
X#ifdef FLEX_DEBUG
X	fprintf( stderr, "--accepting rule #%d\n", yy_act );
X#endif
X	switch ( yy_act )
X	    {
case 1:
X# line 58 "scan.l"
X++linenum; ECHO; /* indented code */
X	YY_BREAK
case 2:
X# line 59 "scan.l"
X++linenum; ECHO; /* treat as a comment */
X	YY_BREAK
case 3:
X# line 60 "scan.l"
ECHO; BEGIN(C_COMMENT);
X	YY_BREAK
case 4:
X# line 61 "scan.l"
return ( SCDECL );
X	YY_BREAK
case 5:
X# line 62 "scan.l"
return ( XSCDECL );
X	YY_BREAK
case 6:
X# line 63 "scan.l"
X++linenum; line_directive_out( stdout ); BEGIN(CODEBLOCK);
X	YY_BREAK
case 7:
X# line 64 "scan.l"
return ( WHITESPACE );
X	YY_BREAK
case 8:
X# line 66 "scan.l"
X{
X			sectnum = 2;
X			line_directive_out( stdout );
X			BEGIN(SECT2PROLOG);
X			return ( SECTEND );
X			}
X	YY_BREAK
case 9:
X# line 73 "scan.l"
X{
X			fprintf( stderr,
X			     "old-style lex command at line %d ignored:\n\t%s",
X				 linenum, yytext );
X			++linenum;
X			}
X	YY_BREAK
case 10:
X# line 80 "scan.l"
X{
X			(void) strcpy( nmstr, yytext );
X			didadef = false;
X			BEGIN(PICKUPDEF);
X			}
X	YY_BREAK
case 11:
X# line 86 "scan.l"
RETURNNAME;
X	YY_BREAK
case 12:
X# line 87 "scan.l"
X++linenum; /* allows blank lines in section 1 */
X	YY_BREAK
case 13:
X# line 88 "scan.l"
X++linenum; return ( '\n' );
X	YY_BREAK
case 14:
X# line 89 "scan.l"
synerr( "illegal character" ); BEGIN(RECOVER);
X	YY_BREAK
case 15:
X# line 92 "scan.l"
ECHO; BEGIN(0);
X	YY_BREAK
case 16:
X# line 93 "scan.l"
X++linenum; ECHO; BEGIN(0);
X	YY_BREAK
case 17:
X# line 94 "scan.l"
ECHO;
X	YY_BREAK
case 18:
X# line 95 "scan.l"
ECHO;
X	YY_BREAK
case 19:
X# line 96 "scan.l"
X++linenum; ECHO;
X	YY_BREAK
case 20:
X# line 98 "scan.l"
X++linenum; BEGIN(0);
X	YY_BREAK
case 21:
X# line 99 "scan.l"
X++linenum; ECHO;
X	YY_BREAK
case 22:
X# line 101 "scan.l"
X/* separates name and definition */
X	YY_BREAK
case 23:
X# line 103 "scan.l"
X{
X			(void) strcpy( nmdef, yytext );
X
X			for ( i = strlen( nmdef ) - 1;
X			      i >= 0 &&
X			      nmdef[i] == ' ' || nmdef[i] == '\t';
X			      --i )
X			    ;
X
X			nmdef[i + 1] = '\0';
X
X                        ndinstal( nmstr, nmdef );
X			didadef = true;
X			}
X	YY_BREAK
case 24:
X# line 118 "scan.l"
X{
X			if ( ! didadef )
X			    synerr( "incomplete name definition" );
X			BEGIN(0);
X			++linenum;
X			}
X	YY_BREAK
case 25:
X# line 125 "scan.l"
X++linenum; BEGIN(0); RETURNNAME;
X	YY_BREAK
case 26:
YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */
yy_c_buf_p -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 128 "scan.l"
X{
X			++linenum;
X			ACTION_ECHO;
X			MARK_END_OF_PROLOG;
X			BEGIN(SECT2);
X			}
X	YY_BREAK
case 27:
X# line 135 "scan.l"
X++linenum; ACTION_ECHO;
X	YY_BREAK
case 28:
X# line 137 "scan.l"
X++linenum; /* allow blank lines in section 2 */
X	YY_BREAK
X	/* this horrible mess of a rule matches indented lines which
X	 * do not contain "/*".  We need to make the distinction because
X	 * otherwise this rule will be taken instead of the rule which
X	 * matches the beginning of comments like this one
X	 */
case 29:
X# line 144 "scan.l"
X{
X			synerr( "indented code found outside of action" );
X			++linenum;
X			}
X	YY_BREAK
case 30:
X# line 149 "scan.l"
BEGIN(SC); return ( '<' );
X	YY_BREAK
case 31:
X# line 150 "scan.l"
return ( '^' );
X	YY_BREAK
case 32:
X# line 151 "scan.l"
BEGIN(QUOTE); return ( '"' );
X	YY_BREAK
case 33:
YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */
yy_c_buf_p = yy_b_buf_p;
YY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 152 "scan.l"
BEGIN(NUM); return ( '{' );
X	YY_BREAK
case 34:
X# line 153 "scan.l"
BEGIN(BRACEERROR);
X	YY_BREAK
case 35:
YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */
yy_c_buf_p = yy_b_buf_p;
YY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 154 "scan.l"
return ( '$' );
X	YY_BREAK
case 36:
X# line 156 "scan.l"
X{
X			bracelevel = 1;
X			BEGIN(PERCENT_BRACE_ACTION);
X			return ( '\n' );
X			}
X	YY_BREAK
case 37:
X# line 161 "scan.l"
X++linenum; return ( '\n' );
X	YY_BREAK
case 38:
X# line 163 "scan.l"
ACTION_ECHO; BEGIN(C_COMMENT_2);
X	YY_BREAK
case 39:
X# line 165 "scan.l"
X{ /* needs to be separate from following rule due to
X			   * bug with trailing context
X			   */
X			bracelevel = 0;
X			BEGIN(ACTION);
X			return ( '\n' );
X			}
X	YY_BREAK
case 40:
YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */
yy_c_buf_p -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 173 "scan.l"
X{
X			bracelevel = 0;
X			BEGIN(ACTION);
X			return ( '\n' );
X			}
X	YY_BREAK
case 41:
X# line 179 "scan.l"
X++linenum; return ( '\n' );
X	YY_BREAK
case 42:
X# line 181 "scan.l"
X{
X			/* guarantee that the SECT3 rule will have something
X			 * to match
X			 */
X			yyless(1);
X			sectnum = 3;
X			BEGIN(SECT3);
X			return ( EOF ); /* to stop the parser */
X			}
X	YY_BREAK
case 43:
X# line 191 "scan.l"
X{
X			(void) strcpy( nmstr, yytext );
X
X			/* check to see if we've already encountered this ccl */
X			if ( (cclval = ccllookup( nmstr )) )
X			    {
X			    yylval = cclval;
X			    ++cclreuse;
X			    return ( PREVCCL );
X			    }
X			else
X			    {
X			    /* we fudge a bit.  We know that this ccl will
X			     * soon be numbered as lastccl + 1 by cclinit
X			     */
X			    cclinstal( nmstr, lastccl + 1 );
X
X			    /* push back everything but the leading bracket
X			     * so the ccl can be rescanned
X			     */
X			    PUT_BACK_STRING(nmstr, 1);
X
X			    BEGIN(FIRSTCCL);
X			    return ( '[' );
X			    }
X			}
X	YY_BREAK
case 44:
X# line 218 "scan.l"
X{
X			register char *nmdefptr;
X			char *ndlookup();
X
X			(void) strcpy( nmstr, yytext );
X			nmstr[yyleng - 1] = '\0';  /* chop trailing brace */
X
X			/* lookup from "nmstr + 1" to chop leading brace */
X			if ( ! (nmdefptr = ndlookup( nmstr + 1 )) )
X			    synerr( "undefined {name}" );
X
X			else
X			    { /* push back name surrounded by ()'s */
X			    unput(')');
X			    PUT_BACK_STRING(nmdefptr, 0);
X			    unput('(');
X			    }
X			}
X	YY_BREAK
case 45:
X# line 237 "scan.l"
return ( yytext[0] );
X	YY_BREAK
case 46:
X# line 238 "scan.l"
RETURNCHAR;
X	YY_BREAK
case 47:
X# line 239 "scan.l"
X++linenum; return ( '\n' );
X	YY_BREAK
case 48:
X# line 242 "scan.l"
return ( ',' );
X	YY_BREAK
case 49:
X# line 243 "scan.l"
BEGIN(SECT2); return ( '>' );
X	YY_BREAK
case 50:
YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */
yy_c_buf_p = yy_b_buf_p;
YY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 244 "scan.l"
BEGIN(CARETISBOL); return ( '>' );
X	YY_BREAK
case 51:
X# line 245 "scan.l"
RETURNNAME;
X	YY_BREAK
case 52:
X# line 246 "scan.l"
synerr( "bad start condition name" );
X	YY_BREAK
case 53:
X# line 248 "scan.l"
BEGIN(SECT2); return ( '^' );
X	YY_BREAK
case 54:
X# line 251 "scan.l"
RETURNCHAR;
X	YY_BREAK
case 55:
X# line 252 "scan.l"
BEGIN(SECT2); return ( '"' );
X	YY_BREAK
case 56:
X# line 254 "scan.l"
X{
X			synerr( "missing quote" );
X			BEGIN(SECT2);
X			++linenum;
X			return ( '"' );
X			}
X	YY_BREAK
case 57:
YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */
yy_c_buf_p = yy_b_buf_p;
YY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 262 "scan.l"
BEGIN(CCL); return ( '^' );
X	YY_BREAK
case 58:
YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */
yy_c_buf_p = yy_b_buf_p;
YY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 263 "scan.l"
return ( '^' );
X	YY_BREAK
case 59:
X# line 264 "scan.l"
BEGIN(CCL); yylval = '-'; return ( CHAR );
X	YY_BREAK
case 60:
X# line 265 "scan.l"
BEGIN(CCL); RETURNCHAR;
X	YY_BREAK
case 61:
YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */
yy_c_buf_p = yy_b_buf_p;
YY_DO_BEFORE_ACTION; /* set up yytext again */
X# line 267 "scan.l"
return ( '-' );
X	YY_BREAK
case 62:
X# line 268 "scan.l"
RETURNCHAR;
X	YY_BREAK
case 63:
X# line 269 "scan.l"
BEGIN(SECT2); return ( ']' );
X	YY_BREAK
case 64:
X# line 272 "scan.l"
X{
X			yylval = myctoi( yytext );
X			return ( NUMBER );
X			}
X	YY_BREAK
case 65:
X# line 277 "scan.l"
return ( ',' );
X	YY_BREAK
case 66:
X# line 278 "scan.l"
BEGIN(SECT2); return ( '}' );
X	YY_BREAK
case 67:
X# line 280 "scan.l"
X{
X			synerr( "bad character inside {}'s" );
X			BEGIN(SECT2);
X			return ( '}' );
X			}
X	YY_BREAK
case 68:
X# line 286 "scan.l"
X{
X			synerr( "missing }" );
X			BEGIN(SECT2);
X			++linenum;
X			return ( '}' );
X			}
X	YY_BREAK
case 69:
X# line 294 "scan.l"
synerr( "bad name in {}'s" ); BEGIN(SECT2);
X	YY_BREAK
case 70:
X# line 295 "scan.l"
synerr( "missing }" ); ++linenum; BEGIN(SECT2);
X	YY_BREAK
case 71:
X# line 298 "scan.l"
bracelevel = 0;
X	YY_BREAK
case 72:
X# line 299 "scan.l"
ACTION_ECHO;
X	YY_BREAK
case 73:
X# line 300 "scan.l"
X{
X			++linenum;
X			ACTION_ECHO;
X			if ( bracelevel == 0 )
X			    {
X			    fputs( "\tYY_BREAK\n", temp_action_file );
X			    BEGIN(SECT2);
X			    }
X			}
X	YY_BREAK
case 74:
X# line 310 "scan.l"
ACTION_ECHO; ++bracelevel;
X	YY_BREAK
case 75:
X# line 311 "scan.l"
ACTION_ECHO; --bracelevel;
X	YY_BREAK
case 76:
X# line 312 "scan.l"
ACTION_ECHO;
X	YY_BREAK
case 77:
X# line 313 "scan.l"
ACTION_ECHO; BEGIN(ACTION_COMMENT);
X	YY_BREAK
case 78:
X# line 314 "scan.l"
ACTION_ECHO; /* character constant */
X	YY_BREAK
case 79:
X# line 315 "scan.l"
ACTION_ECHO; BEGIN(ACTION_STRING);
X	YY_BREAK
case 80:
X# line 316 "scan.l"
X{
X			++linenum;
X			ACTION_ECHO;
X			if ( bracelevel == 0 )
X			    {
X			    fputs( "\tYY_BREAK\n", temp_action_file );
X			    BEGIN(SECT2);
X			    }
X			}
X	YY_BREAK
case 81:
X# line 325 "scan.l"
ACTION_ECHO;
X	YY_BREAK
case 82:
X# line 327 "scan.l"
ACTION_ECHO; BEGIN(ACTION);
X	YY_BREAK
case 83:
X# line 328 "scan.l"
ACTION_ECHO;
X	YY_BREAK
case 84:
X# line 329 "scan.l"
ACTION_ECHO;
X	YY_BREAK
case 85:
X# line 330 "scan.l"
X++linenum; ACTION_ECHO;
X	YY_BREAK
case 86:
X# line 331 "scan.l"
ACTION_ECHO;
X	YY_BREAK
case 87:
X# line 333 "scan.l"
ACTION_ECHO; BEGIN(SECT2);
X	YY_BREAK
case 88:
X# line 334 "scan.l"
X++linenum; ACTION_ECHO; BEGIN(SECT2);
X	YY_BREAK
case 89:
X# line 335 "scan.l"
ACTION_ECHO;
X	YY_BREAK
case 90:
X# line 336 "scan.l"
ACTION_ECHO;
X	YY_BREAK
case 91:
X# line 337 "scan.l"
X++linenum; ACTION_ECHO;
X	YY_BREAK
case 92:
X# line 339 "scan.l"
ACTION_ECHO;
X	YY_BREAK
case 93:
X# line 340 "scan.l"
ACTION_ECHO;
X	YY_BREAK
case 94:
X# line 341 "scan.l"
X++linenum; ACTION_ECHO;
X	YY_BREAK
case 95:
X# line 342 "scan.l"
ACTION_ECHO; BEGIN(ACTION);
X	YY_BREAK
case 96:
X# line 343 "scan.l"
ACTION_ECHO;
X	YY_BREAK
case 97:
X# line 346 "scan.l"
X{
X			yylval = myesc( yytext );
X			return ( CHAR );
X			}
X	YY_BREAK
case 98:
X# line 351 "scan.l"
X{
X			yylval = myesc( yytext );
X			BEGIN(CCL);
X			return ( CHAR );
X			}
X	YY_BREAK
case 99:
X# line 358 "scan.l"
X{
X			register int numchars;
X
X			/* black magic - we know the names of a flex scanner's
X			 * internal variables.  We cap the input buffer with
X			 * an end-of-string and dump it to the output.
X			 */
X			YY_DO_BEFORE_SCAN; /* recover from setting up yytext */
X
X#ifdef FLEX_FAST_SKEL
X			fputs( yy_c_buf_p + 1, stdout );
X#else
X			yy_ch_buf[yy_e_buf_p + 1] = '\0';
X
X			/* ignore the first character; it's the second '%'
X			 * put back by the yyless(1) above
X			 */
X			fputs( yy_ch_buf + yy_c_buf_p + 1, stdout );
X#endif
X
X			/* if we don't do this, the data written by write()
X			 * can get overwritten when stdout is finally flushed
X			 */
X			(void) fflush( stdout );
X
X			while ( (numchars = read( fileno(yyin), yy_ch_buf,
X						  YY_BUF_MAX )) > 0 )
X			    (void) write( fileno(stdout), yy_ch_buf, numchars );
X	
X			if ( numchars < 0 )
X			    flexerror( "fatal read error in section 3" );
X
X			return ( EOF );
X			}
X	YY_BREAK
X
case YY_NEW_FILE:
break; /* begin reading from new file */
X
case YY_DO_DEFAULT:
YY_DEFAULT_ACTION;
break;
X
case YY_END_TOK:
return ( YY_END_TOK );
X
default:
YY_FATAL_ERROR( "fatal flex scanner internal error" );
X	    }
X
get_next_token:
X	{
X	register int yy_curst;
X	register char yy_sym;
X
X	YY_DO_BEFORE_SCAN
X
X	/* set up to begin running DFA */
X
X	yy_curst = yy_start;
X
X	if ( yy_ch_buf[yy_c_buf_p] == '\n' )
X	    ++yy_curst;
X
X	/* yy_b_buf_p points to the position in yy_ch_buf
X	 * of the start of the current run.
X	 */
X
X	yy_b_buf_p = yy_c_buf_p + 1;
X
X	do /* until the machine jams */
X	    {
X	    if ( yy_c_buf_p == yy_e_buf_p )
X		{ /* need more input */
X		if ( yy_e_buf_p >= YY_BUF_LIM )
X		    { /* not enough room to do another read */
X		    /* see if we can make some room for more chars */
X
X		    yy_n_chars = yy_e_buf_p - yy_b_buf_p;
X
X		    if ( yy_n_chars >= 0 )
X			/* shift down buffer to make room */
X			for ( yy_iii = 0; yy_iii <= yy_n_chars; ++yy_iii )
X			    {
X			    yy_buf_pos = yy_b_buf_p + yy_iii;
X			    yy_ch_buf[yy_iii] = yy_ch_buf[yy_buf_pos];
X			    yy_st_buf[yy_iii] = yy_st_buf[yy_buf_pos];
X			    }
X
X		    yy_b_buf_p = 0;
X		    yy_e_buf_p = yy_n_chars;
X
X		    if ( yy_e_buf_p >= YY_BUF_LIM )
X			YY_FATAL_ERROR( "flex input buffer overflowed" );
X
X		    yy_c_buf_p = yy_e_buf_p;
X		    }
X
X		else if ( yy_saw_eof )
X		    {
saweof:		    if ( yy_b_buf_p > yy_e_buf_p )
X			{
X			if ( yywrap() )
X			    {
X			    yy_act = YY_END_TOK;
X			    goto do_action;
X			    }
X			
X			else
X			    {
X			    YY_INIT;
X			    yy_act = YY_NEW_FILE;
X			    goto do_action;
X			    }
X			}
X
X		    else /* do a jam to eat up more input */
X			{
X#ifndef FLEX_INTERACTIVE_SCANNER
X			/* we're going to decrement yy_c_buf_p upon doing
X			 * the jam.  In this case, that's wrong, since
X			 * it points to the last non-jam character.  So
X			 * we increment it now to counter the decrement.
X			 */
X			++yy_c_buf_p;
X#endif
X			break;
X			}
X		    }
X
X		YY_INPUT( (yy_ch_buf + yy_c_buf_p + 1), yy_n_chars,
X			  YY_MAX_LINE );
X
X		if ( yy_n_chars == YY_NULL )
X		    {
X		    if ( yy_saw_eof )
X	YY_FATAL_ERROR( "flex scanner saw EOF twice - shouldn't happen" );
X		    yy_saw_eof = 1;
X		    goto saweof;
X		    }
X
X		yy_e_buf_p += yy_n_chars;
X		}
X
X	    ++yy_c_buf_p;
X
X#ifdef FLEX_USE_ECS
X	    yy_sym = e[yy_ch_buf[yy_c_buf_p]];
X#else
X	    yy_sym = yy_ch_buf[yy_c_buf_p];
X#endif
X
X#ifdef FLEX_FULL_TABLE
X	    yy_curst = n[yy_curst][yy_sym];
X
X#else /* get next state from compressed table */
X
X	    while ( c[b[yy_curst] + yy_sym] != yy_curst )
X		{
X		yy_curst = d[yy_curst];
X
X#ifdef FLEX_USE_MECS
X		/* we've arrange it so that templates are never chained
X		 * to one another.  This means we can afford make a
X		 * very simple test to see if we need to convert to
X		 * yy_sym's meta-equivalence class without worrying
X		 * about erroneously looking up the meta-equivalence
X		 * class twice
X		 */
X
X		if ( yy_curst >= YY_TEMPLATE )
X		    yy_sym = m[yy_sym];
X#endif
X		}
X
X	    yy_curst = n[b[yy_curst] + yy_sym];
X
X#endif
X
X	    yy_st_buf[yy_c_buf_p] = yy_curst;
X
X	    }
X#ifdef FLEX_INTERACTIVE_SCANNER
X	while ( b[yy_curst] != YY_JAM_BASE );
X#else
X	while ( yy_curst != YY_JAM );
X	--yy_c_buf_p; /* put back character we jammed on */
X
X#endif
X
X	if ( yy_c_buf_p >= yy_b_buf_p )
X	    { /* we matched some text */
X	    yy_curst = yy_st_buf[yy_c_buf_p];
X	    yy_lp = l[yy_curst];
X
X#ifdef FLEX_REJECT_ENABLED
find_rule: /* we branch to this label when doing a REJECT */
X#endif
X
X	    for ( ; ; ) /* until we find what rule we matched */
X		{
X#ifdef FLEX_REJECT_ENABLED
X		if ( yy_lp && yy_lp < l[yy_curst + 1] )
X		    {
X		    yy_act = a[yy_lp];
X		    goto do_action; /* "continue 2" */
X		    }
X#else
X		if ( yy_lp )
X		    {
X		    yy_act = yy_lp;
X		    goto do_action; /* "continue 2" */
X		    }
X#endif
X
X		if ( --yy_c_buf_p < yy_b_buf_p )
X		    break;
X
X		yy_curst = yy_st_buf[yy_c_buf_p];
X		yy_lp = l[yy_curst];
X		}
X	    }
X
X	/* if we got this far, then we didn't find any accepting
X	 * states
X	 */
X
X	/* so that the default applies to the first char read */
X	++yy_c_buf_p;
X
X	yy_act = YY_DO_DEFAULT;
X	}
X	}
X
X    /*NOTREACHED*/
X    }
X
X
static int unput( c )
char c;
X
X    {
X    YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */
X
X    if ( yy_c_buf_p == 0 )
X	{
X	register int i;
X	register int yy_buf_pos = YY_BUF_MAX;
X
X	for ( i = yy_e_buf_p; i >= yy_c_buf_p; --i )
X	    {
X	    yy_ch_buf[yy_buf_pos] = yy_ch_buf[i];
X	    yy_st_buf[yy_buf_pos] = yy_st_buf[i];
X	    --yy_buf_pos;
X	    }
X
X	yy_c_buf_p = YY_BUF_MAX - yy_e_buf_p;
X	yy_e_buf_p = YY_BUF_MAX;
X	}
X
X    if ( yy_c_buf_p <= 0 )
X	YY_FATAL_ERROR( "flex scanner push-back overflow" );
X
X    if ( yy_c_buf_p >= yy_b_buf_p && yy_ch_buf[yy_c_buf_p] == '\n' )
X	yy_ch_buf[yy_c_buf_p - 1] = '\n';
X
X    yy_ch_buf[yy_c_buf_p--] = c;
X
X    YY_DO_BEFORE_ACTION; /* set up yytext again */
X    }
X
X
static int input()
X
X    {
X    int c;
X
X    YY_DO_BEFORE_SCAN
X
X    if ( yy_c_buf_p == yy_e_buf_p )
X	{ /* need more input */
X	int yy_n_chars;
X
X	/* we can throw away the entire current buffer */
X	if ( yy_saw_eof )
X	    {
X	    if ( yywrap() )
X		return ( EOF );
X
X	    YY_INIT;
X	    }
X
X	yy_b_buf_p = 0;
X	YY_INPUT( yy_ch_buf, yy_n_chars, YY_MAX_LINE );
X
X	if ( yy_n_chars == YY_NULL )
X	    {
X	    yy_saw_eof = 1;
X
X	    if ( yywrap() )
X		return ( EOF );
X
X	    YY_INIT;
X
X	    return ( input() );
X	    }
X
X	yy_c_buf_p = -1;
X	yy_e_buf_p = yy_n_chars - 1;
X	}
X
X    c = yy_ch_buf[++yy_c_buf_p];
X
X    YY_DO_BEFORE_ACTION;
X
X    return ( c );
X    }
X# line 392 "scan.l"
X
END_OF_FILE
if test 36366 -ne `wc -c <'scan.c.dist'`; then
    echo shar: \"'scan.c.dist'\" unpacked with wrong size!
fi
# end of 'scan.c.dist'
fi
echo shar: End of archive 4 \(of 5\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
